["mod = 10 ** 9 + 7\nMAX = 2 * 10 ** 5\n\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 1)\nfor i in range(2, MAX + 1):\n    inv[i] = inv[mod % i] * (mod - mod // i) % mod\n\nfact_inv = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n\ndef comb(n, k):\n    if n < k:\n        return 0\n    return fact[n] * fact_inv[n-k] * fact_inv[k] % mod\n\n\nn, m, k = list(map(int, input().split()))\n\nans = 0\ncmb = comb(m * n - 2, k - 2)\nfor i in range(1, m):\n    ans += i * (m - i) * n * n * cmb\n    ans %= mod\n\nfor i in range(1, n):\n    ans += i * m * m * (n - i) * cmb\n    ans %= mod\n\nprint(ans)\n", "import sys\n\nMOD = 10 ** 9 + 7 \n\ndef make_table(size=10**6, p=MOD):\n    fac = [None] * (size + 1)\n    fac[0] = 1\n    for i in range(size):\n        fac[i+1] = fac[i] * (i + 1) % p\n    ifac = [None] * (size + 1)\n    ifac[size] = pow(fac[size], p-2, p)\n    for i in range(size, 0, -1):\n        ifac[i-1] = ifac[i] * i % p\n    return fac, ifac\n\nfac, ifac = make_table(2*10**5)\n\ndef comb(n, r, mod=MOD):\n    if r > n or r < 0: return 0\n    return fac[n] * ifac[r] % mod * ifac[n-r] % mod\n\nn, m, k = map(int, sys.stdin.readline().split())\n\ndef main():\n    vert = list(range(n+1))\n    horiz = list(range(m+1))\n    for i in range(1, n):\n        vert[i+1] += vert[i]\n        vert[i+1] %= MOD\n    for i in range(1, m):\n        horiz[i+1] += horiz[i]\n        horiz[i+1] %= MOD\n    \n    res = 0\n    for i in range(1, n):\n        res += (vert[n] - vert[i] - i * (n - i)) * m % MOD * m % MOD\n        res %= MOD\n    for i in range(1, m):\n        res += (horiz[m] - horiz[i] - i * (m - i)) * n % MOD * n % MOD\n        res %= MOD\n    \n    res *= comb(n*m-2, k-2)\n    res %= MOD\n    return res\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "# python 3.4.3\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# library\n# -------------------------------------------------------------\ndef init_fact(n,mod):\n    fact,finv,inv = [1]*n,[1]*n,[1]*n\n    for i in range(2,n):\n        fact[i] = (fact[i-1]*i) % mod\n        inv[i]  = mod - inv[mod%i] * (mod//i)%mod\n        finv[i] = finv[i-1] * inv[i] % mod\n    return (fact,finv,inv)\n \ndef nCr(n,r,mod,fact,finv):\n    if n<r:\n        return 0\n    else:\n        return fact[n] * (finv[r] * finv[n-r] % mod) % mod\n\nmod = 10**9+7\nfact,finv,inv = init_fact(200010,mod)\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\n\nN,M,K = map(int,input().split())\n\nans = 0\nfor d in range(1,N):\n    t = d * nCr(N*M-2, K-2, mod, fact, finv)\n    t %= mod\n    t *= (N-d)*M*M\n    t %= mod\n    ans += t\n    ans %= mod\nfor d in range(1,M):\n    t = d * nCr(N*M-2, K-2, mod, fact, finv)\n    t %= mod\n    t *= (M-d)*N*N\n    t %= mod\n    ans += t\n    ans %= mod\n\nprint(ans)", "n,m,k=list(map(int,input().split()))\nU = 2*10**5\nMOD = 10**9+7\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n  fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\n \nfor i in range(U,0,-1):\n\tfact_inv[i-1] = (fact_inv[i]*i)%MOD\n \ndef comb(n,k):\n  if k < 0 or k > n:\n    return 0\n  x = fact[n]\n  x *= fact_inv[k]\n  x %= MOD\n  x *= fact_inv[n-k]\n  x %= MOD\n  return x\n\nans=0\nfor i in range(n):\n    for j in range(m):\n        if i!=0 and j!=0:\n            ans+=2*(n-i)*(m-j)*(i+j)\n        else:\n            ans+=(n-i)*(m-j)*(i+j)\n        ans%=MOD\n\nprint((ans*comb(n*m-2,k-2)%MOD))\n\n", "mod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\nn, m, k = map(int, input().split())\nans = 0\nc = nCr(n * m)\nfor i in range(n):\n    ans += i * (n - i) * m * m\n    ans %= mod\nfor i in range(m):\n    ans += i * (m - i) * n * n\n    ans %= mod\nprint(ans * c.comb(n * m - 2, k - 2) % mod)", "MOD = 10**9+7\n\ndef comb_mod(n,r,mod):\n    a,b=1,1\n    r = min(r,n-r)\n    for i in range(r):\n        a = a*(n-i) % mod\n        b = b*(r-i) % mod\n    return a * pow(b, mod-2, mod) % mod\n    \n\nN,M,K = map(int,input().split())\n    \nans = 0\nfor dx in range(1,M):\n    ans += N*N % MOD * (M-dx) % MOD * dx % MOD\n    ans %= MOD\nfor dy in range(1,N):\n    ans += M*M % MOD * (N-dy) % MOD * dy % MOD\n    ans %= MOD\n    \nans *= comb_mod(N*M-2, K-2, MOD)\nans %= MOD\nprint(ans)", "n, m, k = list(map(int, input().split()))\n\nmod = 10**9+7\nN = 2*10**5+50\nfac = [1]*(N+1)\nfinv = [1]*(N+1)\nfor i in range(N):\n    fac[i+1] = fac[i] * (i+1) % mod\nfinv[-1] = pow(fac[-1], mod-2, mod)\nfor i in reversed(list(range(N))):\n    finv[i] = finv[i+1] * (i+1) % mod\n\ndef cmb1(n, r, mod):\n    if r <0 or r > n:\n        return 0\n    r = min(r, n-r)\n    return fac[n] * finv[r] * finv[n-r] % mod\n\nans = 0\nfor i in range(n*m):\n    x, y = divmod(i, m)\n    # x\n    ans += x*m*cmb1(n*m-2, k-2, mod)*x\n    ans -= (n-1-x)*m*cmb1(n*m-2, k-2, mod)*x\n    # y\n    ans += y*n*cmb1(n*m-2, k-2, mod)*y\n    ans -= (m-1-y)*n*cmb1(n*m-2, k-2, mod)*y\n\nans %= mod\nprint(ans)\n", "n,m,k = map(int,input().split())\n\nmod = 10**9+7 \nfact = [1,1]\nfinv = [1,1]\ninv = [0,1]\n \nfor i in range(2,n*m+1):\n    fact.append((fact[-1]*i)%mod)\n    inv.append((inv[mod%i]*(mod-mod//i))%mod)\n    finv.append((finv[-1]*inv[-1])%mod)\n \ndef nCr(n,r,mod):\n    if r > n:\n        return 0\n    else: \n        return fact[n]*finv[r]*finv[n-r]%mod    \n\n\nans = 0\n\nfor i in range(1,n):\n    \n    ans += nCr(n*m-2,k-2,mod)*i*(n-i)*m**2\n    ans %= mod\n    \nfor i in range(1,m):\n    \n    ans += nCr(n*m-2,k-2,mod)*i*(m-i)*n**2\n    ans %= mod\n    \nprint(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nmod = 10**9 + 7\n\ndef make_tables(n, mod = 10 ** 9 + 7):\n    fac = [1, 1] # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n    finv = [1, 1] #\u9006\u5143\u306e\u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n    inv = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((mod -inv[mod % i] * (mod // i)) % mod)\n        finv.append((finv[-1] * inv[-1]) % mod)\n    return fac, finv\n\ndef nCk(n, k, mod = 10 ** 9 + 7):\n    k = min(k, n-k)\n    return fac[n] * finv[k] * finv[n-k] % mod\n\n##########################\n\nn, m, k = list(map(int, input().split()))\n\nfac, finv = make_tables(n*m - 2)\n\nans = 0\n\nfor i in range(1, m):\n    ans += i*n*n*(m - i)*nCk(n*m - 2, k - 2)\n    ans %= mod\nfor j in range(1, n):\n    ans += j*m*m*(n - j)*nCk(n*m - 2, k - 2)\n    ans %= mod\n\nprint(ans)\n\n\n\n\n\n", "n,m,k=map(int,input().split())\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 3*10**5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nxans,yans=0,0\nfor i in range(1,n):\n  xans+=i*cmb(n*m-2,k-2,mod)*(n-i)*m**2%mod\nfor i in range(1,m):\n  yans+=i*cmb(n*m-2,k-2,mod)*(m-i)*n**2%mod\nprint((xans+yans)%mod)", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def nCr(self, n, r):\n        r = min(n - r, r)\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n    def nHr(self, n, r):\n        return self.nCr(n - 1 + r, r)\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M, K = list(map(int, input().split()))\n\n    calc = Calc(max_value=N * M - 2, mod=MOD)\n\n    t = 0\n    for d in range(1, N):\n        t = (t + (N - d) * d) % MOD\n    t = t * M * M * calc.nCr(N * M - 2, K - 2) % MOD\n\n    u = 0\n    for d in range(1, M):\n        u = (u + (M - d) * d) % MOD\n    u = u * N * N * calc.nCr(N * M - 2, K - 2) % MOD\n\n    ans = (t + u) % MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m, k = list(map(int, input().split()))\n\n\nmod = 10 ** 9 + 7\nN = 10 ** 6\n\n#\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv_t = [0]+[1]\nfor i in range(2, N):\n  inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]\n\n#\u968e\u4e57\u8a08\u7b97\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n\tkai.append(kai[-1] * i % mod)\n\trev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n,r):\n    res = 1\n    for i in range(r):\n        res *= n * inv_t[r]\n        res %= mod\n        n -= 1\n        r -= 1\n    return res\n\ndef calc(n):\n    res = 0\n    for i in range(1, n):\n        res += (n - i) * i\n        res %= mod\n    return res\n\nans = 0\nans += m * m * cmb(n*m -2, k-2) * calc(n)\nans %= mod\n\nans += n * n * cmb(n*m -2, k-2) * calc(m)\nans %= mod\n\nprint(ans)\n", "n,m,k = map(int, input().split())\nn_ = n*m\nmod = 10**9+7\nfun = [1]*(n_+1)\nfor i in range(1,n_+1):\n    fun[i] = fun[i-1]*i%mod\nrev = [1]*(n_+1)\nrev[n_] = pow(fun[n_],mod-2,mod)\nfor i in range(n_-1,0,-1):\n    rev[i] = rev[i+1]*(i+1)%mod\n\ndef nCr(n,r):\n    if r > n:\n        return 0\n    return fun[n]*rev[r]%mod*rev[n-r]%mod\n  \nx = sum(i*(n-i) for i in range(n))%mod\ny = sum(i*(m-i) for i in range(m))%mod\nans = (x*m**2 + y*n**2)%mod*nCr(n*m-2,k-2)%mod\nprint(ans)", "n,m,k=map(int,input().split())\nmod=10**9+7\nf=[1]\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\nans=0\nfor i in range(1,n):\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n  ans%=mod\nfor i in range(1,m):\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n  ans%=mod\nprint(ans)", "n,m,k = map(int,input().split())\nmod = 10**9+7\ndef combination(n,r,p):\n    if n < r or r < 0:\n        return 0\n    r = min(n-r,r)\n    \n    fact = [1,1]\n    factinv = [1,1]\n    inv = [0,1]\n    for i in range(2,n+1):\n        fact.append((fact[-1]*i)%p)\n        inv.append((-inv[p%i]*(p//i))%p)\n        factinv.append((factinv[-1]*inv[-1])%p)\n    return fact[n]*factinv[r]*factinv[n-r]%p\ntemp = combination(n*m-2,k-2,mod)\nans = 0\nfor d in range(1,n):\n    ans += d*((n-d)*(m**2))*temp\nfor d in range(1,m):\n    ans += d*((m-d)*(n**2))*temp\nprint(ans%mod)", "n, m, k = map(int, input().split())\nmod = 10**9 + 7\n\nfac = [1] * n*m\nfinv = [1] * n*m\ninv = [1] * n*m\n\nans = 0\ndef COMinit():\n    for i in range(2, n*m):\n        fac[i] = fac[i - 1] * i % mod\n        inv[i] = mod - inv[mod % i] * (mod // i) % mod\n        finv[i] = finv[i - 1] * inv[i] % mod\n\n\ndef COM(n, k):\n    if n < 0 or k < 0 or n < k:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod\nCOMinit()\nfor i in range(1, n):\n    ans += (COM(n*m - 2, k-2)) * ((n-i)*i * m**2)%mod\nfor j in range(1, m):\n    ans += (COM(n*m - 2, k-2)) * ((m-j)*j * n**2)%mod\nprint(ans%mod)", "N,M,K =map(int, input().split())\nmod = 10**9 + 7\n\n# cmb\u304c10**10\u304f\u3089\u3044\u3060\u3051\u3069\u6c42\u3081\u3089\u308c\u308b\u304b\uff1f\u3063\u3066\u611f\u3058\n# \u554f\u984c\u8aad\u307f\u9055\u3048\u3066\u3044\u305f\u3002\u3002\u3002N*M <= 2*10**5\u3060\u3002\u3002\u3002\u307e\u3042\u666e\u901a\u3060\u3002\n# \u3082\u3046\u30e9\u30a4\u30d6\u30e9\u30ea\u4f7f\u304a\u3046\u3002\u6614nCr\u306er\u304c\u5c0f\u3055\u3044\u6642\u306e\u5de5\u592b\u3068\u304b\u3042\u3063\u305f\u3051\u3069\u4eca\u56de\u306f\u5927\u4e08\u592b\u3060\u3002\n\n# https://ikatakos.com/pot/programming_algorithm/number_theory/mod_combination\nimport numpy as np\n \ndef prepare(n, MOD):\n    nrt = int(n ** 0.5) + 1\n    nsq = nrt * nrt\n    facts = np.arange(nsq, dtype=np.int64).reshape(nrt, nrt)\n    facts[0, 0] = 1\n    for i in range(1, nrt):\n        facts[:, i] = facts[:, i] * facts[:, i - 1] % MOD\n    for i in range(1, nrt):\n        facts[i] = facts[i] * facts[i - 1, -1] % MOD\n    facts = facts.ravel().tolist()\n \n    invs = np.arange(1, nsq + 1, dtype=np.int64).reshape(nrt, nrt)\n    invs[-1, -1] = pow(facts[-1], MOD - 2, MOD)\n    for i in range(nrt - 2, -1, -1):\n        invs[:, i] = invs[:, i] * invs[:, i + 1] % MOD\n    for i in range(nrt - 2, -1, -1):\n        invs[i] = invs[i] * invs[i + 1, 0] % MOD\n    invs = invs.ravel().tolist()\n \n    return facts, invs\n\nfacts, invs = prepare(N*M+10,mod)\ndef cmb(n,r,MOD):\n  return (((facts[n] * invs[n-r]) % mod) * invs[r]) % mod\n\n## \u30b7\u30b0\u30de\u3092\u5206\u96e2\u3059\u308b\u3053\u3068\u3002\uff12\u70b9i,j\u306e\u9078\u3073\u65b9\u6570\u3001\u304b\u3051\u308b\u3053\u3068\u306ei,j\u306e\u8ddd\u96e2\u3068\u3059\u308b\u3002\u3042\u3068\u306f\u3053\u308c\u306b\uff12\u70b9\u4ee5\u5916\u306e\u9078\u3073\u65b9\u306e\u30d1\u30bf\u30fc\u30f3\u6570\u3092\u304b\u3051\u308c\u3070\u826f\u3044\n# X,Y\u3092\u72ec\u7acb\u3057\u3066\u8003\u3048\u308b\n# \u4f8b\u3048\u3070X\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3068\u3001\u4f7f\u3046\u5217\u306e\u9078\u3073\u65b9\u304cN*2, \u4f7f\u3046\u884c\u306e\u9078\u3073\u65b9\u306fM-dis(1\u306a\u3089M-1\u3060\u3057\u3001M-1\u96e2\u308c\u3066\u308b\u306e\u306f\uff11\u500b\u3057\u304b\u9078\u3079\u306a\u3044\uff09\n# dis\u306f\u8ddd\u96e2\u304c\u7b54\u3048\u306b\u5bc4\u4e0e\u3059\u308b\u304b\u3089\n# cmb()\u306f\u305d\u306e\uff12\u70b9\u4ee5\u5916\u306e\u9078\u3073\u65b9\u306e\u500b\u6570\u306e\u8a71\u3002\n#  \u3082\u3061\u308d\u3093\u4ed6\u306ei,j\u306b\u3064\u3044\u3066\u898b\u305f\u3089\u540c\u3058\u76e4\u9762\u4f55\u5ea6\u3082\u898b\u3066\u308b\u3051\u3069\u3001\u4eca\u306ei,j\u306b\u95a2\u3059\u308b\u5024\u3057\u304b\u8a08\u7b97\u3057\u3066\u306a\u3044\u304b\u3089OK\nans = 0\n\nfor dis in range(M):\n  ans += N**2 * (M-dis) * dis * cmb(N*M-2, K-2, mod)\n  ans %= mod\nfor dis in range(N):\n  ans += M**2 * (N-dis) * dis * cmb(N*M-2, K-2, mod)\n  ans %= mod\n\nprint(ans)", "# python 3.4.3\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# library\n# -------------------------------------------------------------\nclass Combination:\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.fact = [1]*n\n        self.finv = [1]*n\n        self.inv  = [1]*n\n        for i in range(2,n):\n            self.fact[i] = (self.fact[i-1]*i) % self.mod\n            self.inv[i]  = self.mod - self.inv[self.mod%i] * (self.mod//i)%self.mod\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.mod\n \n    def nCr(self, n, r):\n        if n<r:\n            return 0\n        else:\n            return self.fact[n] * (self.finv[r] * self.finv[n-r] % self.mod) % self.mod\n\nmod = 10**9+7\nCombination = Combination(200010, mod)\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\n\nN,M,K = list(map(int,input().split()))\n\nans = 0\nfor d in range(1,N):\n    t = d * Combination.nCr(N*M-2, K-2)\n    t %= mod\n    t *= (N-d)*M*M\n    t %= mod\n    ans += t\n    ans %= mod\nfor d in range(1,M):\n    t = d * Combination.nCr(N*M-2, K-2)\n    t %= mod\n    t *= (M-d)*N*N\n    t %= mod\n    ans += t\n    ans %= mod\n\nprint(ans)\n", "n,m,k = map(int,input().split())\nmod = 10**9+7\n\ndef make_array_for_comb(N, mod=10**9+7):\n    fact = [1,1]\n    fact_inv = [1,1]\n    inv = [0,1]\n    for i in range(2, N+1):\n        fact.append((fact[-1]*i) % mod)\n        inv.append((-inv[mod%i] * (mod//i)) % mod)\n        fact_inv.append((fact_inv[-1]*inv[i]) % mod)\n    return fact, fact_inv\n\ndef comb(n, r, mod=10**9+7):\n  if (r < 0) or (n < r):\n      return 0\n  r = min(r, n - r)\n  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n\nfact, fact_inv = make_array_for_comb(n*m,mod)\n\nl = comb(n*m-2,k-2,mod)\nans = 0\nfor a in range(1,n+1):\n  ans += a*m*(a-1)*m\n  ans -= a*m*(n-a)*m\nans %= mod\n\nfor b in range(1,m+1):\n  ans += b*n*(b-1)*n\n  ans -= b*n*(m-b)*n\nans %= mod\n\nprint(ans*l%mod)", "def power(a, b):\n\tif b == 0:\n\t\treturn 1\n\telif b == 1:\n\t\treturn a % 1000000007\n\telif b % 2 == 0:\n\t\treturn (power(a, b//2) ** 2) % 1000000007\n\telse:\n\t\treturn (power(a, b//2) ** 2 * a) % 1000000007\n \ndef divide(a, b):\n\treturn (a * power(b, 1000000005)) % 1000000007\n\nfac_lim = 200000\nfac = [None]*(fac_lim+1)\nfac[0] = 1\nfor i in range(fac_lim):\n    fac[i+1] = fac[i] * (i+1)\n    fac[i+1] = fac[i + 1] % 1000000007\n\nfac_inv = [None]*(fac_lim+1)\nfac_inv[fac_lim] = power(fac[fac_lim], 1000000005)\nfor i in range(fac_lim, 0, -1):\n    fac_inv[i-1] = (fac_inv[i] * i)  % 1000000007\n\ndef conv(a, b):\n    return (fac[a] * fac_inv[a-b] * fac_inv[b]) % 1000000007\n\nMOD = 1000000007\nN, M, K = (int(i) for i in input().split())\nmidN = 0\nmidM = 0\nif N > 1:\n    for i in range(1,N):\n        midN += i*(N-i)*2\n        midN % MOD\n    midN = divide(midN, N**2)\nelse:\n    midN = 0\nif M > 1:\n    for i in range(1,M):\n        midM += i*(M-i)*2\n        midM % MOD\n    midM = divide(midM, M**2)\nelse:\n    midM = 0\nkt = (midN+midM)*(N*M)\nkt = divide(kt, N*M-1)\npt = conv(N*M, K)\nans = kt*pt % MOD\nans = ans*K*(K-1) % MOD\nans = divide(ans, 2)\nprint(ans%MOD)", "N,M,K=map(int,input().split())\nMOD=10**9+7\nans=0\nx,y=1,1\nk=min(K-2,N*M-K)\nfor i in range(k):\n    x*=N*M-2-i\n    y*=k-i\n    x%=MOD\n    y%=MOD\ncomb=x*pow(y,MOD-2,MOD)\ncomb%=MOD\nfor i in range(1,N):\n    a=i*comb*(N-i)*M**2\n    ans+=a\n    ans%=MOD\nfor i in range(1,M):\n    a=i*comb*(M-i)*N**2\n    ans+=a\n    ans%=MOD\nprint(ans%MOD)", "N, M ,K = map(int, input().split())\nMOD = 10**9 + 7\n\ndef comb(n, r, mod=10**9+7):\n  if n==0 and r==0:\n    return 1\n  else:\n    a = b = 1\n    A, B = n, r\n    for i in range(r):\n      a = a*A % mod\n      b = b*B % mod\n      A -= 1\n      B -= 1\n    return a * pow(b, mod-2, mod) % mod\n\nans = comb(N*M-2, K-2) * ((M*(N-1)*(N+1) + N*(M-1)*(M+1))*N*M//6)%MOD % MOD\nprint(ans)", "n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\nMAX = n * m\n\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 1)\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\nfor i in range(MAX, 0, -1):\n    inv[i-1] = (inv[i] * i) % mod\n\n\ndef comb(n, k):\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\nans = 0\nfor i in range(n):\n    for j in range(m):\n        add = (n - i) * (m - j) * (i + j) % mod\n        if i != 0 and j != 0:\n            add *= 2\n            add %= mod\n\n        ans += add\n        ans %= mod\n\nans *= comb(MAX - 2, k - 2)\nans %= mod\nprint(ans)\n", "N,M,K=map(int,input().split())\ndef cmb(x,y):\n  X=1\n  Y=1\n  for i in range(1,y+1):\n    X= X*(x+1-i)%MOD\n    Y= Y*i%MOD\n  return (X*pow(Y,MOD-2,MOD))%MOD\nMOD=10**9+7\nA=cmb(M*N-2, K-2)\nans=0\nfor d in range(1,N):\n  ans+=d*(N-d)*M*M*A%MOD\nfor d in range(1,M):\n  ans+=d*(M-d)*N*N*A%MOD\nprint(ans%MOD)", "N,M,K=map(int,input().split())\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\nmod=10**9+7\ng1=[1,1]\ng2=[1,1]\ninverse=[0,1]\nfor i in range(2,N*M+1):\n    g1.append((g1[-1]*i)%mod)\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g2.append((g2[-1]*inverse[-1])%mod)\nans=0\nfor i in range(1,N):\n  ans+=i*(N-i)*M*M\nfor j in range(1,M):\n  ans+=j*(M-j)*N*N\nans*=cmb(N*M-2,K-2,mod)\nprint(ans%mod)", "def cmb(a,b,c):\n    b = min(b,a-b)\n    num = 1\n    for i in range(b):\n        num = num*(a-i) % c\n    den = 1\n    for i in range(b):\n        den = den*(i+1) % c\n    return num * pow(den,c-2,c) % c\nn,m,k = list(map(int,input().split()))\nmod = 10**9+7\nans = 0\nC = cmb(n*m-2,k-2,mod)\nfor i in range(1,n):\n    ans += i*(n-i)*m**2*C\n    ans %= mod\nfor i in range(1,m):\n    ans += i*(m-i)*n**2*C\n    ans %= mod\nprint(ans)\n", "# E - Cell Distance\n\nn, m, k = list(map(int, input().split()))\nmod = 10**9 + 7\n\ndifx = 0\ndify = 0\n\nfor i in range(m):\n    difx += (i * (m-i) * pow(n, 2, mod))%mod\n\nfor j in range(n):\n    dify += (j * (n-j) * pow(m, 2, mod))%mod\n\ndef comb_mod(n, r, p):\n    num = 1\n    den = 1\n    r = min(r, n-r)\n    for i in range(r):\n        num = (num * (n-i))%p\n        den = (den * (i+1))%p\n    return num * pow(den, p-2, p)  \n\npat = comb_mod(n*m-2, k-2, mod)\n\nans = ((difx + dify) * pat)%mod\n\nprint(ans)\n", "# 1 \u3064\u306e\u7d44\u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u3001\u305d\u306e\u4ed6\u306e\u7f6e\u304d\u65b9\u306f (N*M-2)C(K-2) \u901a\u308a\n# x \u5ea7\u6a19\u304c h \u96e2\u308c\u308b\u7d44\u307f\u5408\u308f\u305b\u306f\u3001(N-h)*M*M \u901a\u308a (h!=0)\n\ndef combination(n, r, mod=10**9+7):\n    # nCr mod m\n    # r\u304cn/2\u306b\u8fd1\u3044\u3068\u975e\u5e38\u306b\u91cd\u304f\u306a\u308b\n    n1, r = n+1, min(r, n-r)\n    numer = denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n1-i) % mod\n        denom = denom * i % mod\n    return numer * pow(denom, mod-2, mod) % mod\n\ndef main():\n    N, M, K = list(map(int, input().split()))\n    mod = 10**9 + 7\n    ans1 = 0\n    for h in range(1, N):\n        ans1 += (N - h) * h\n    ans1 = ans1 * M * M % mod\n    ans2 = 0\n    for w in range(1, M):\n        ans2 += (M - w) * w\n    ans2 = ans2 * N * N % mod\n    ans = (ans1 + ans2) * combination(N*M-2, K-2) % mod\n    print(ans)\n\nmain()\n", "MOD = 10 ** 9 + 7\n\nN, M, K = list(map(int, input().split()))\n\ndef f(x):\n    return (x * (x + 1) * (x - 1)) // 6 % MOD\n\ntmp = (N * N * f(M)) % MOD + (M * M *f(N)) % MOD\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\nc = Factorial(N * M - 2, MOD).comb\n\ntmp *= c(N * M - 2, K - 2)\ntmp %= MOD\n\nprint (tmp)\n", "def inv(x, mod):\n    return pow(x, mod - 2, mod)\n\n\ndef main() -> None:\n    N, M, K = list(map(int, input().split()))\n    MOD = 10 ** 9 + 7\n    ans = 0\n    for d in range(1, N):\n        ans += M * M * (N - d) * d\n        ans %= MOD\n    for d in range(1, M):\n        ans += N * N * (M - d) * d\n        ans %= MOD\n\n    for i in range(K - 2):\n        ans = (ans * (N * M - 2 - i)) % MOD\n    for i in range(K - 2):\n        ans = (ans * inv(i + 1, MOD)) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\n# \u6570\u3048\u4e0a\u3052\n\nN, M, K = list(map(int, input().split()))\nans = 0\n\nMOD = 10 ** 9 + 7\n\n\ndef cumprod(arr, MOD):\n    L = len(arr)\n    Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]\n        arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]\n        arr[n] %= MOD\n    return arr.ravel()[:L]\n\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64)\n    x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64)\n    x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\n\nU = N * M + 10\nfact, fact_inv = make_fact(U, MOD)\nfact, fact_inv = fact.tolist(), fact_inv.tolist()\n\n\ndef mod_comb_k(n, k, mod):\n    return fact[n] * fact_inv[k] % mod * fact_inv[n - k] % mod\n\n\n# X\nfor dx in range(1, N):\n    pat = N - dx\n    ans += dx * pat * M * M\n    ans %= MOD\n\n# Y\nfor dy in range(1, M):\n    pat = M - dy\n    ans += dy * pat * N * N\n    ans %= MOD\n\nans *= mod_comb_k(N * M - 2, K-2, MOD)\nans %= MOD\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nclass Comb:\n    def __init__(self, n, mod=pow(10, 9)+7, f=True, i=False):\n        self.n = n\n        self.mod = mod\n        self.factorial_table = None\n        self.inverse_table = None\n        if f: self.get_factorial()\n        if i: self.get_inverse()\n        \n    def get_factorial(self):\n        self.factorial_table = [1]*(self.n+1)\n        for i in range(1, self.n+1):\n            self.factorial_table[i] = self.factorial_table[i-1]*i%self.mod\n        self.inverse_table = None\n    \n    def get_inverse(self):\n        mod = self.mod\n        self.inverse_table = [1]*(self.n+1)\n        for i in range(self.n+1):\n            self.inverse_table[i] = pow(self.factorial_table[i], -1, mod)\n    \n    def factorial(self, n):\n        if self.factorial_table == None:\n            return None\n        return self.factorial_table[n]\n    \n    def inverse(self, n):\n        if self.inverse_table == None:\n            return None\n        return self.inverse_table[n]   \n    \n    def permutation(self, n, k):\n        if self.factorial_table == None:\n            return None\n        mod = self.mod\n        if self.inverse_table == None:\n            return self.factorial_table[n]*pow(self.factorial_table[n-k], -1, mod)%mod\n        return self.factorial_table[n]*self.inverse_table[n-k]%mod\n            \n    def comb(self, n, k):\n        mod = self.mod\n        if self.factorial_table == None:\n            res = 1\n            for i in range(k):\n                res *= n-i\n                res *= i+1\n                res %= mod\n            return res\n        if self.inverse_table == None:\n            res = self.factorial_table[n]*pow(self.factorial_table[n-k], -1, mod)%mod\\\n                                    *pow(self.factorial_table[k], -1, mod)%mod\n        else:\n            res = self.factorial_table[n]*self.inverse_table[n-k]%mod\\\n                                    *self.inverse_table[k]%mod\n        return res\n    \n    def recomb(self, n, k):\n        if n+k-1 > self.n:\n            return None\n        return self.comb(n+k-1, k)\n        \n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    mod = pow(10, 9) + 7\n    \n    comb = Comb(n*m, i=True)\n    \n    ans = 0\n    \n    for i in range(n):\n        ans += (i) * (n-i) * m**2\n        ans %= mod\n        \n    \n    for i in range(m):\n        ans += (i) * (m-i) * n**2\n        ans %= mod\n    \n    \n    \n    ans *= comb.comb(n*m-2, k-2)\n    ans %= mod\n    \n    print(ans)\n    \n    \ndef __starting_point():\n    main()\n\n\n__starting_point()", "def ext_euc(a, b):\n    # return x, y, gcd(a, b) s.t. ax + by = gcd(a, b)\n    if b == 0:\n        return 1, 0, a\n    y, x, v = ext_euc(b, a % b)\n    y -= (a // b) * x\n    return x, y, v\n\n\ndef mod_inv(a, mod):\n    x, _, _ = ext_euc(a, mod)\n    return x % mod\n\n\ndef comb(n, k, mod):\n    if k >= n // 2:\n        return comb(n, n - k, mod)\n    ret = 1\n    for i in range(k):\n        ret *= n - i\n        ret *= mod_inv(k - i, mod)\n        ret %= mod\n    return ret\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N, M, K = list(map(int, input().split(' ')))\n    ans = comb(N * M - 2, K - 2, MOD)\n    ans *= ((N ** 2) * (M - 1) * M * (M + 1) + (M ** 2) * (N - 1) * N * (N + 1)) // 6\n    ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m, k = map(int, input().split())\n\nmod = 1000000007\ndef pow(x, n):\n    ret = 1\n    while n > 0:\n        if (n & 1) == 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        n >>= 1\n    return ret\n\nfac = [1]\ninv = [1]\nfor i in range(1, n * m + 1):\n    fac.append((fac[-1] * i) % mod)\n    inv.append(pow(fac[i], mod - 2))\n\ndef cmb(n, k):\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\ndef doit(n, m, k):\n    ret = 0\n    for d in range(m):\n        ret = (ret + d * (m - d)) % mod\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\nprint((doit(n, m, k) + doit(m, n, k)) % mod)", "n,m,k=map(int,input().split())\n#n*m\u304b\u3089k\u500b\u9078\u3076\n#x\u65b9\u5411\nmod=10**9+7\nkaidan=[1]*(n*m+1)\ngyaku=[1]*(n*m+1)\nfor i in range(1,n*m+1):\n    kaidan[i]=i*kaidan[i-1]%mod\n    gyaku[i]=pow(kaidan[i],mod-2,mod)\ndef comb(n,r):\n    if n-r>0 and n>0 and r>0:\n        return (kaidan[n]*gyaku[n-r]*gyaku[r])%mod\n    elif n==0 or r==0 or n==r:\n        return 1\n    else:\n        0\nans=0\nfor d in range(1,n):\n    ans+=d*(n-d)*m*m*comb(n*m-2,k-2)\nfor d in range(1,m):\n    ans+=d*(m-d)*n*n*comb(n*m-2,k-2)\nprint(ans%mod)", "N,M,K = map(int,input().split())\n\nans = 0\nmod = 10**9+7\n\ndef cmb(n, r, mod):\n    if r<0 or r>n:\n        return 0\n    r = min(n, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\ng1 = [1,1]\ng2 = [1,1]\ninverse = [0,1]\nfor i in range(2, N*M+1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\ncoef = cmb(N*M-2, K-2, mod)\n\nfor i in range(1,N):\n    ans += i*(N-i)*M*M\n\nfor j in range(1,M):\n    ans += j*(M-j)*N*N\n\nans *= coef\nans %= mod\nprint(ans)", "MOD = 10 ** 9 + 7\nn, m, k = list(map(int, input().split()))\ndef f(i, j):\n    return i*(i-1)*(i+1)//6 * j ** 2\ndef c(a, b):\n    r = 1\n    for i in range(a, a - b, -1):\n        r = r * i % MOD\n    t = 1\n    for i in range(1, b + 1):\n        t = t * i % MOD\n    return r * pow(t, MOD - 2, MOD)\nprint(((f(n, m) + f(m, n)) * c(n*m - 2, k - 2) % MOD))\n", "N, M, K = list(map(int, input().split()))\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nmod = 10 ** 9 + 7\nn = 3 * 10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n#\u4e00\u3064\u306e\u914d\u7f6e\u3067K C 2\u672c\u306e\u7dda\n#\u914d\u7f6e\u306fMN C K \u901a\u308a\n#\u3088\u3063\u3066\u3001MNCK * KC2 / MNC2 = (MN - 2)C(K - 2)\u56de\n#\u54042\u9802\u70b9\u9593\u306e\u30b3\u30b9\u30c8\u306f\u8db3\u3055\u308c\u308b\u3002\n#\u7b54\u3048\u306f\u5168\u3066\u306e2\u9802\u70b9\u9593\u306e\u30b3\u30b9\u30c8\u306e\u548c * (MN - 2)C(K - 2)\n\n#\u5168\u3066\u306e2\u9802\u70b9\u9593\u306e\u30b3\u30b9\u30c8\u306e\u548c\u3092\u6c42\u3081\u308b\n#\u8ddd\u96e2 i \u96e2\u308c\u305f\u4e8c\u70b9\u306e\u500b\u6570\u306f (1 + 2 + ... N - i) * N\n#\u3064\u307e\u308a\u3001N * (N - i + 1) * (N - i) / 2\n#\u7e26\u6a2a\u3042\u308b\u306e\u3067\u3001 \u305d\u308c\u305e\u308c\u8db3\u3059\nans1 = 0\nfor i in range(1, M):\n  ans1 += i * (M - i) % mod\n  #print(ans1)\nans1 = (ans1 * N * N) % mod\n\nans2 = 0\nfor i in range(1, N):\n  ans2 += i * (N - i) % mod\nans2 = (ans2 * M * M) % mod\n\n#print(ans1, ans2)\n\nans = ans1 + ans2\nprint((ans * cmb(M * N - 2, K - 2, p) % mod))\n\n", "mod = 10**9 + 7\nn, m, k = map(int, input().split())\nnm = n * m\nfact = [1] * (nm-1)\ninv = [1] * (nm-1)\ninv_fact = [1] * (nm-1)\nfor i in range(2, nm-1):\n  fact[i] = fact[i-1] * i % mod\n  inv[i] = -(mod // i) * inv[mod % i] % mod\n  inv_fact[i] = inv_fact[i-1] * inv[i] % mod\ncomb = fact[nm-2] * inv_fact[k-2] * inv_fact[nm-k] % mod\ncost_x = (n-1) * nm * (n+1) // 6 * m % mod\ncost_y = (m-1) * nm * (m+1) // 6 * n % mod\nprint(comb * (cost_x + cost_y) % mod)", "\"\"\"\n\nAtCoder Beginner Contest 127  E - Cell Distance\n\n\nx,y\u306f\u72ec\u7acb\u3057\u3066\u8003\u3048\u3089\u308c\u308b\u306e\u3067\u5206\u3051\u308b\u3002\n\u5dee\u5206\u306e\u7d76\u5bfe\u5024\u306e\u548c\u306e\u554f\u984c\u306f\n\u3042\u308b\u9805\u306b\u3064\u3044\u3066\u3001\uff0b\u3068\u3057\u3066\u50cd\u304f\u306e\u304c\u4f55\u56de\u304b\u3001\uff0d\u3068\u3057\u3066\u50cd\u304f\u306e\u304c\u4f55\u56de\u304b\n\u3092\u8003\u3048\u3066\u305d\u306e\u5206\u3092\u8db3\u3057\u3066\u3042\u3052\u308c\u3070\u3044\u3044\n\n\u4f8b1\u306e 2 x 2\u3067\u8003\u3048\u308b\u3068\u3001x=2,y=1\u306e\u306b\u3064\u3044\u3066\u3001\nx\u304c\uff0b\u306b\u50cd\u304f\u306e\u306f\u3001x=2\u3088\u308a\u5c0f\u3055\u3044\u3001(x,y)=(1,1),(1,2)\nx\u304c\u00b10\u306a\u306e\u306f\u3001x\u304c\u540c\u3058\u3001(x,y)=(2,2)\nx\u304c\uff0d\u306b\u50cd\u304f\u306e\u306f\u306a\u3057\uff08x=2\u307e\u3067\u306a\u306e\u3067\uff09\n\u7684\u306a\u3002\n\n\n\nK\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3068\u3001\u3042\u308b\u99d2a,b\u9593\u306e\u30b3\u30b9\u30c8\u304c\u6c42\u3081\u3089\u308c\u308b\u56de\u6570\u306f\u3001nCr(N*M-2, K-2)\n\uff08\u5168\u90e8\u3067K\u500b\u9078\u3076\u3068\u304d\u306ba,b\u3092\u5148\u306b\u9078\u3093\u3067\u3001\u6b8b\u308a\u306eN-2\u304b\u3089K-2\u500b\u9078\u3076\u304b\u3089\u3002\uff09\n\nN x M\u306e\u30de\u30b9\u3067\u3001(ax,ay)\u306e\u7269\u306e\u30b3\u30b9\u30c8\u306b\u3064\u3044\u3066\u3001\nX\uff1a+ax*(ax - 1) * N - ax * (M - ax) * N = ax*N*(ax-1-M+ax) = ax*N*(2ax-1-M)\n\u3053\u308c\u304c\u30de\u30b9\u306e\u9ad8\u3055\u306e\u5206\u3060\u3051\u3042\u308b(ay\u304c1~N\u307e\u3067)&\u3053\u308c\u304cnCr(N*M-2, K-2)\u56de\nY\u3082\u540c\u69d8\n\"\"\"\n\n\nN,M,K = list(map(int, input().split()))\n\nMOD = 10**9+7\n \nMAXN = N*M + 10\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n \ndef nCr(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\n\n#X\uff1a+ax*(ax - 1) * N - ax * (M - ax) * N = ax*N*(ax-1-M+ax) = ax*N*(2ax-1-M)\u304cN\u500b\uff06nCr(N*M-2, K-2))\u56de\nans = 0\n\nfor i in range(1,M+1):\n    tmp = (((((i * N) % MOD) * (2*i - 1 - M)) % MOD) * N) % MOD\n    \n    #print(\"~~~\", i*N, 2*i - 1 - M,tmp, nCr(N*M-2, K-2))\n\n    tmp *= nCr(N*M-2, K-2)\n\n    tmp %= MOD\n    #print(\"pppp\", tmp)\n    ans += tmp\n\n    ans %= MOD\n\n\nfor i in range(1,N+1):\n    tmp = (((((i * M) % MOD) * (2*i - 1 - N)) % MOD) * M) % MOD\n\n    tmp *= nCr(N*M-2, K-2)\n\n    tmp %= MOD\n    ans += tmp\n    ans %= MOD\n\n\nprint(ans)\n", "n, m, k = map(int, input().split())\n\nMOD = 1000000007\ndef pow_mod(x, y):\n    if y == 0: return 1\n    ans = 1\n    while y > 1:\n        if y % 2 != 0: \n            ans *= x\n            ans %= MOD\n        x *= x\n        x %= MOD\n        y //= 2\n    return ans * x % MOD\nmod_inv = lambda x: pow_mod(x, MOD - 2)\n\na = 0\nfor i in range(1, n):\n  a += (i * (n - i)) % MOD \n  a %= MOD\na *= (m * m) % MOD\na %= MOD\n\nb = 0\nfor i in range(1, m):\n  b += (i * (m - i)) % MOD \n  b %= MOD\nb *= (n * n) % MOD\nb %= MOD\n\nw = (m * n - 2) % MOD\nu = 1\nv = 1\nfor i in range(1, k-1):\n  u *= (w - i + 1)\n  u %= MOD\n  v *= i\n  v %= MOD\n\nans = ((a + b) % MOD) \nans *= u\nans %= MOD\nans *= mod_inv(v)\nans %= MOD\n\n\nprint(ans)", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nimport sys\nimport numpy as np\nmod=10**9+7\ndef ncr_1(n,r,p):##\u3000n>>r \u306e\u5834\u5408\u306encr\u3000O(r)\n    x = 1\n    y = 1\n    for i in range(r):\n        x*=(n-i)\n        y*=(i+1)\n        x%=p\n        y%=p\n    return x*modinv(y,p) %p\ndef modinv(a,p):\n    b,u,v = p,1,0\n    while b:\n        t = a//b\n        a -= t*b\n        a,b = b,a\n        u -=t*v\n        u,v = v,u\n    u %=p\n    return u\nn,m,k = ma()\nans=0\nfor i in range(1,n):\n    ans+=i*(n-i)*m**2\n    ans%=mod\nfor i in range(1,m):\n    ans+=i*(m-i)*n**2\n    ans%=mod\nprint((ans*ncr_1(n*m-2,k-2,mod))%mod)\n", "p,q,r=map(int,input().split())\n\n    \ndef comb_mod(N,K,modp):\n\n    K_fact=1\n    NK_fact=1\n    N_fact=1\n\n    for i in range(1,K+1):\n        K_fact*=i\n        K_fact=K_fact%modp\n    for i in range(1,N-K+1):\n        NK_fact*=i\n        NK_fact=NK_fact%modp\n    for i in range(1,N+1):\n        N_fact*=i\n        N_fact=N_fact%modp\n\n    K_inv=pow(K_fact, -1, modp)\n    NK_inv=pow(NK_fact, -1, modp)\n    pat=(N_fact*K_inv)%modp*NK_inv%modp\n    return pat\n\npat=comb_mod(p*q-2,r-2,10**9+7)\n\nans=0\nfor i in range(0,q+1):\n    ans+=i*(q-i)*p*p\n    ans=ans%(10**9+7)\n    \nfor k in range(0,p+1):\n    ans+=k*(p-k)*q*q%(10**9+7)\n    ans=ans%(10**9+7)\n\nprint(ans*pat%(10**9+7))", "N, M, K = list(map(int, input().split()))\nmod = 10**9 + 7\n\n# N\u884c, M\u5217 i-j\n# 1-1, 1-2, 1-3, 1-4, ... , 1-M\n# 2-1, 2-2, 2-3, 2-4, ... , 2-M\n# 3-1. 3-2. 3-3, 3-4, ... , 3-M\n# ...\n# N-1, N-2, N-3, N-4, ... , N-M\n\n# K\u500b\u306e\u99d2\u304c\u4e0a\u8a18\u306e\u5ea7\u8868\u4e0a\u306b\u7f6e\u304b\u308c\u305f\u6642\u306e\u914d\u7f6e\u5168\u7a2e\u985e\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u3092\u8abf\u3079\u305f\u3044\n\nfactorial = [1 for i in range(N*M + 1)]\nfor i in range(1, N * M + 1):\n\tif i==1:\n\t\tfactorial[i] = 1\n\telse:\n\t\tfactorial[i] = factorial[i-1]*i % mod\n\ndef comb(n, k):\n\treturn (factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod)) % mod\n\nxscore = 0\nfor i in range(1, N):\n\txscore += i * (N-i)\nxscore %= mod\nxscore *= M**2 * comb(N*M-2, K-2)\nxscore %= mod\n\nyscore = 0\nfor i in range(1, M):\n\tyscore += i * (M-i)\nyscore %= mod\nyscore *= N**2 * comb(N*M-2, K-2)\nyscore %= mod\n\nprint(((xscore + yscore) % mod))\n", "# python 3.4.3\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# library\n# -------------------------------------------------------------\nclass Combination:\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.fact = [1]*n\n        self.finv = [1]*n\n        self.inv  = [1]*n\n        for i in range(2,n):\n            self.fact[i] = (self.fact[i-1]*i) % self.mod\n            self.inv[i]  = self.mod - self.inv[self.mod%i] * (self.mod//i)%self.mod\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.mod\n \n    def nCr(self, n, r):\n        if n<r:\n            return 0\n        else:\n            return self.fact[n] * (self.finv[r] * self.finv[n-r] % self.mod) % self.mod\n\nmod = 10**9+7\nCombination = Combination(200010, mod)\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\n\nN,M,K = map(int,input().split())\n\nans = 0\nfor d in range(1,N):\n    t = d * Combination.nCr(N*M-2, K-2)\n    t %= mod\n    t *= (N-d)*M*M\n    t %= mod\n    ans += t\n    ans %= mod\nfor d in range(1,M):\n    t = d * Combination.nCr(N*M-2, K-2)\n    t %= mod\n    t *= (M-d)*N*N\n    t %= mod\n    ans += t\n    ans %= mod\n\nprint(ans)", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nm,n,k = list(map(int,readline().split()))\n\ndef comb(n, r, mod):\n    r = min(r, n-r)\n    mol = 1\n    deno = 1\n    for i in range(1, r+1):\n        mol = mol * (n-r+i) % mod\n        deno = deno * i % mod\n    ret = mol * pow(deno, mod-2, mod) % mod\n    return ret\n\ndef f1(x,y,a,b):\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\ndef f2(x,a):\n    return (a-x)*(a-x+1)//2\n\nans = 0\n\nfor x in range(1,n+1):\n    for y in range(1,m+1):\n        a = n-x+1\n        b = m-y+1\n        c = m*(a*(a-1)+x*(x-1))\n        d = n*(b*(b-1)+y*(y-1))\n        ans += (c+d)//2\n        ans %= mod\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\nans = ans*pow(2,mod-2,mod)%mod\n\nprint(ans)\n\n", "H, W, K = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nfactorial = [1, 1]\ninverse = [1, 1]\ninvere_base = [0, 1]\nfor i in range(2, H * W + 2):\n    factorial.append((factorial[-1] * i) % MOD)\n    invere_base.append((-invere_base[MOD % i] * (MOD // i)) % MOD)\n    inverse.append((inverse[-1] * invere_base[-1]) % MOD)\n\n\ndef nCr(n, r):\n    if not 0 <= r <= n:\n        return 0\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\nans = 0\nfor dh in range(1, H):\n    ans += dh * (H - dh) * pow(W, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n    ans %= MOD\nfor dw in range(1, W):\n    ans += dw * (W - dw) * pow(H, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n    ans %= MOD\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    N,M,K = map(int,input().split())\n\n    MAXN = N*M\n    fact = [1]\n    for i in range(1,MAXN + 1):\n        fact.append(fact[-1]*i%MOD)\n    inv_fact = [-1] * (MAXN + 1)\n    inv_fact[-1] = pow(fact[-1],MOD - 2,MOD)\n    for i in range(MAXN - 1,-1,-1):\n        inv_fact[i] = inv_fact[i + 1]*(i + 1)%MOD\n    \n    nck = lambda N,K: 0 if K > N or K < 0 else fact[N]*inv_fact[N - K]*inv_fact[K]%MOD\n\n    ans = 0\n    const = nck(N*M - 2,K - 2)\n    for i in range(1,N):\n        ans += (N - i) * M*M * const * i % MOD\n        ans %= MOD\n    \n    for i in range(1,M):\n        ans += (M - i) * N*N * const * i % MOD\n        ans %= MOD\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nm,n,k = list(map(int,readline().split()))\n\ndef comb(n, r, mod):\n    r = min(r, n-r)\n    mol = 1\n    deno = 1\n    for i in range(1, r+1):\n        mol = mol * (n-r+i) % mod\n        deno = deno * i % mod\n    ret = mol * pow(deno, mod-2, mod) % mod\n    return ret\n\nans = m*n*(m+n)*(m*n-1)//3\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\nans = ans*pow(2,mod-2,mod)%mod\n\nprint(ans)\n\n", "def sum_distance(a, b):\n    x = 0\n    for i in range(a):\n        x += ((i + 1) * (a - i))\n        x %= mod\n    x *= pow(b, 2)\n    return x % mod\n\ndef comb(n, r):\n    x, y = 1, 1\n    for i in range(n, n - r, -1):\n        x *= i\n        y *= i + r - n\n        x %= mod\n        y %= mod\n    return pow(y, mod - 2, mod) * x % mod\n\nn, m, k = map(int, input().split())\nmod = pow(10, 9) + 7\nans = 0\nans += sum_distance(n - 1, m)\nans += sum_distance(m - 1, n)\nans %= mod\nans *= comb(n * m - 2, k - 2)\nans %= mod\nprint(ans)", "n, m, k = [int(i) for i in input().split()]\nmod = 10**9+7\n\n\ndef kai(x, p=mod):\n    a = 1\n    for i in range(1, x + 1):\n        a *= i\n        a %= p\n    return a\n\n\ndef comb(a, b, p=mod):\n    if a < 0 or b < 0:\n        return 0\n    elif a < b:\n        return 0\n    c = 1\n    c *= kai(a, p)\n    c *= pow(kai(b, p), p - 2, p)\n    c *= pow(kai(a - b, p), p - 2, p)\n    return c % p\n\n\nans = 0\nfor i in range(1, n):\n    ans += i * (n - i) * m ** 2\n    ans %= mod\n\nfor i in range(1, m):\n    ans += i * (m - i) * n ** 2\n    ans %= mod\nans *= comb(n * m - 2, k - 2)\nans %= mod\nprint(ans)\n", "class Combination:\n    def __init__(self, mod, max_n):\n        self.MOD = mod\n        self.MAX_N = max_n\n\n        self.f = self.factorial(self.MAX_N)\n        self.f_inv = [self.inv(x) for x in self.f]\n\n    def inv(self,x):\n        return pow(x, self.MOD-2, self.MOD)\n    \n    def factorial(self, n):\n        res = [1]\n        for i in range(1,n+1):\n            res.append(res[-1] * i % self.MOD)\n        return res\n    \n    def comb(self, n, r):\n        return (self.f[n] * self.f_inv[r] % self.MOD) * self.f_inv[n-r] % self.MOD\n\nN, M, K = list(map(int,input().split()))\nCB = Combination(10**9+7, 200010)\n\nans = 0\n\nfor d in range(N):\n    ans += (((CB.comb(N*M-2, K-2) * (N-d) % CB.MOD ) * M % CB.MOD ) * M % CB.MOD) * d % CB.MOD\n    ans %= CB.MOD\n\nfor d in range(M):\n    ans += (((CB.comb(N*M-2, K-2) * (M-d) % CB.MOD ) * N % CB.MOD ) * N % CB.MOD) * d % CB.MOD\n    ans %= CB.MOD\n\nprint(ans)\n\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    #from math import gcd\n\n    #inf = 10**17\n    mod = 10**9 + 7\n\n    # max_nCr\u307e\u3067\u8abf\u3079\u3089\u308c\u308b\n    max_n = 4*10**5\n    fac, inv = [1]*(max_n+1), [0]*(max_n+1)\n    for i in range(2, max_n+1):\n        fac[i] = fac[i-1] * i % mod\n    inv[-1] = pow(fac[-1], mod-2, mod)\n    for i in range(max_n, 0, -1):\n        inv[i-1] = inv[i] * i % mod\n    \n    # nCr\u3092\u6c42\u3081\u308b\n    def ncr(n, r):\n        return fac[n]*inv[r]*inv[n-r]%mod\n\n    n,m,k = map(int, input().split())\n\n    base = ncr(n*m-2, k-2)\n\n    res = 0\n    # x\u65b9\u5411\n    for i in range(1, m):\n        res += n**2 * i * (m-i)\n        res %= mod\n\n    for i in range(1, n):\n        res += m**2 * i * (n-i)\n        res %= mod\n\n    print(res*base%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nMAX = n * m\n\n\nclass ModInt:\n    def __init__(self, num):\n        self.num = num\n\n    def __str__(self):\n        return str(self.num)\n\n    def __repr__(self):\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n    def __add__(self, other):\n        ret = self.num + other.num\n        ret %= mod\n        return ModInt(ret)\n\n    def __sub__(self, other):\n        ret = self.num - other.num\n        ret %= mod\n        return ModInt(ret)\n\n    def __mul__(self, other):\n        ret = self.num * other.num\n        ret %= mod\n        return ModInt(ret)\n\n    def pow(self, times):\n        pw = pow(self.num, times, mod)\n        return ModInt(pw)\n\n    def inverse(self):\n        return ModInt(inv[self.num])\n\n    def __truediv__(self, other):\n        num = self * other.inverse()\n        return ModInt(num)\n\n\ndef comb(n, k):\n    return fact[n] * inv[n-k] * inv[k]\n\n\nfact = [None] * (MAX + 1)\nfact[0] = ModInt(1)\nfor i in range(1, MAX + 1):\n    fact[i] = fact[i-1] * ModInt(i)\n\ninv = [None] * (MAX + 1)\ninv[MAX] = fact[MAX].pow(mod - 2)\nfor i in range(MAX, 0, -1):\n    inv[i-1] = inv[i] * ModInt(i)\n\nans = ModInt(0)\nfor i in range(n):\n    for j in range(m):\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n        if i != 0 and j != 0:\n            add *= ModInt(2)\n\n        ans += add\n\nans *= comb(n * m - 2, k - 2)\nprint(ans)\n", "import math\n\nmod = 10**9+7\nN,M,K = list(map(int, input().split()))\nMAX = min(N*M,mod)\n\nfacts = [1 for i in range(MAX)]\ninvs = [1 for i in range(MAX)]\n\ndef inv(x):\n\treturn pow(x,mod-2,mod)\n\nfor i in range(1,MAX):\n    facts[i] = (facts[i-1] * i)% mod\n    invs[i] = inv(facts[i])\n\ndef nCr(n,r):\n\treturn facts[n] * invs[r] * invs[n-r] % mod\n\ndef main():\n    ans = 0\n    complement = nCr((N*M-2)%mod,(K-2)%mod)\n    for i in range(1,N):\n        ans += i * (N-i) * M**2\n    for i in range(1,M):\n        ans += i * (M-i) * N**2\n    print(((ans*complement) % mod))\n\nmain()\n", "MOD = 10 ** 9 + 7\n\nn, m, k = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nN = n * m + 10\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nans = 0\nfor i in range(n-1, 0, -1):\n    ans += m * m * (i + 1) * i // 2 \n    ans %= MOD\nfor i in range(m - 1, 0, -1):\n    ans += n * n * (i + 1) * i // 2\n    ans %= MOD\n\nans *= nCk(n * m - 2, k - 2)\nans %= MOD\nprint(ans)", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nm,n,k = list(map(int,readline().split()))\n\ndef comb(n, r, mod):\n    r = min(r, n-r)\n    mol = 1\n    deno = 1\n    for i in range(1, r+1):\n        mol = mol * (n-r+i) % mod\n        deno = deno * i % mod\n    ret = mol * pow(deno, mod-2, mod) % mod\n    return ret\n\ndef f1(x,y,a,b):\n    return (a+b-x-y)*(a-x+1)*(b-y+1)//2\n\ndef f2(x,a):\n    return (a-x)*(a-x+1)//2\n\nans = 0\n\nfor x in range(1,n+1):\n    for y in range(1,m+1):\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n        ans %= mod\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\nans = ans*pow(2,mod-2,mod)%mod\n\nprint(ans)\n", "n,m,k=map(int,input().split())\n\nmod = 10**9+7\nf = [1]\nfor i in range(n*m):\n  f += [f[-1]*(i+1) % mod]\ndef comb(a, b):\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\nans=0\nfor dist in range(1,n):\n  c=n-dist\n  p=(c*m*m)%mod\n  ans+=p*dist\nfor dist in range(1,m):\n  c=m-dist\n  p=(c*n*n)%mod\n  ans+=p*dist\nans%=mod\nprint(ans*comb(n*m-2,k-2)%mod)", "n, m, k = list(map(int, input().split()))\n\nmod = 10**9 + 7\n\n# (n * m - 2)C(k - 2)\n# \u8ddd\u96e2x\u306e\u7d44 -  n - x + 1\n# \u6a2a n - x + 1\n# \u7e26 m * m\nans = 0\nfor y in range(1, n):\n    ans += y * (n - y) * m * m % mod\nfor x in range(1, m):\n    ans += x * (m - x) * n * n % mod\n\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\n\n# comb\nfor i in range(k - 2):\n    ans = ans * (n * m - 2 - i) * inv(i + 1) % mod\n\nprint(ans)\n", "N, M, K = map(int, input().split())\n\nMOD = 10**9+7\nn = N*M-2\nfac = [1]*(n+1)\nrev = [1]*(n+1)\n \nfor i in range(1,n+1):\n  fac[i] = i*fac[i-1]%MOD\n  rev[i] = pow(fac[i], MOD-2, MOD)\n \ncomb = lambda a,b:(fac[a]*rev[a-b]*rev[b])%MOD\n\nC = comb(N*M-2, K-2)\nans = 0\nfor d in range(N):\n    ans += d*(N-d)*(M**2)*C\n    ans %= MOD\n\nfor d in range(M):\n    ans += d*(M-d)*(N**2)*C\n    ans %= MOD\n\nprint(ans)", "# E - Cell Distance\n# https://atcoder.jp/contests/abc127/tasks/abc127_e\n\ndef comb(n,k,mod):\n    if n<k:\n        return 0\n    if n<0 or k<0:\n        return 0\n    k=min(n-k,k)\n    ans=1\n    inv=[1]*(k+1)\n    if k>=1:\n        ans*=(n-k+1)%mod\n    for i in range(2,k+1):\n        inv[i]=mod-inv[mod%i]*(mod//i)%mod\n        ans=ans*(n-k+i)*inv[i]%mod\n    return ans\n\nn, m, k = map(int, input().split())\n\nMOD = 1000000007\n\ndistX = 0\nfor d in range(n):\n    distX += d * (n - d) * m ** 2\n\ndistY = 0\nfor d in range(m):\n    distY += d * (m - d) * n ** 2\n\nans = ((distX + distY) * comb(n * m - 2, k - 2, MOD)) % MOD\n\nprint(ans)", "N, M, K = map(int, input().split())\nmod = int(1e9) + 7\nfact = [1 for _ in range(N*M+1)]\ninvf = [1 for _ in range(N*M+1)]\ndef inved(a):\n  x, y, u, v, k, l = 1, 0, 0, 1, a, mod\n  while l != 0:\n    x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n    k, l = l, k % l\n  return x % mod\nfor i in range(N*M):\n  fact[i+1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(N*M, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\nZ = (fact[M*N-2] * invf[K-2] * invf[M*N-K]) % mod\nX = M * (N + 1) * (N - 1)\nX %= mod\nY = N * (M + 1) * (M - 1)\nY %= mod\nXY = (inved(6) * M * N * (X + Y)) % mod\nprint((XY * Z) % mod)", "n,m,k=map(int,input().split())\nM=10**9+7\nc=1\na=0\nfor i in range(1,k-1):c=(c*(n*m-1-i)*pow(i,M-2,M))%M\nfor i in range(n):a=(a+i*(n-i)*(m**2)*c)%M\nfor i in range(m):a=(a+i*(m-i)*(n**2)*c)%M\nprint(a)", "N,M,K=map(int,input().split())\nmod = 10**9+7\n\nfactorial=[1 for i in range(N*M+1)]\nfor i in range(1,N*M+1):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i % mod\n\ndef comb(n,k):\n    return (factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod))%mod\n  \nxscore = 0\nfor i in range(1,N):\n  xscore += i * (N-i)\nxscore %= mod\nxscore *= M**2 * comb(N*M-2,K-2)\nxscore %= mod\n\nyscore = 0\nfor i in range(1,M):\n  yscore += i * (M-i)\nyscore %= mod\nyscore *= N**2 * comb(N*M-2,K-2)\nyscore %= mod\n\nprint((xscore + yscore) %mod)", "n, m, k = map(int, input().split())\nmod = 10**9 + 7\ncum_n = 0\nt = 0\nfor i in range(1, n):\n  t += i\n  cum_n += t\n\ncum_m = 0\nt = 0\nfor i in range(1, m):\n  t += i\n  cum_m += t\n\nans = (cum_n * m**2 + cum_m * n**2) % mod\n\ndef nCr(n,r,mod = 10**9+7):\n    r = min(n-r,r)\n    numer = denom = 1\n    for i in range(1,r+1):\n        numer = numer * (n+1-i) %mod\n        denom = denom * i % mod\n    return numer * pow(denom,mod-2,mod) %mod\n\nif n*m-2 == 0:\n  p = 1\nelse:\n  p = nCr(n*m-2, k-2)\n\nans = (ans*p)%mod\nprint(ans)", "n, m, k = map(int, input().split())\n\nmod = 1000000007\nfac = [1]\nfor i in range(1, n * m + 1):\n    fac.append((fac[-1] * i) % mod)\n\ndef pow(x, n):\n    ret = 1\n    while n > 0:\n        if (n & 1) == 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        n >>= 1\n    return ret\n\ndef inv(i):\n    return pow(fac[i], mod - 2)\n\ndef cmb(n, k):\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\nx = sum(d * (m - d) for d in range(m)) % mod\ny = sum(d * (n - d) for d in range(n)) % mod\n\nc = cmb(n * m - 2, k - 2)\nx = (x * n * n * c) % mod\ny = (y * m * m * c) % mod\n\nprint((x + y) % mod)", "from functools import reduce\nn, m, k = list(map(int, input().split()))\nmod = 10**9 + 7\n\n\ndef nCr(n, r, MOD=10**9 + 7):\n    from functools import reduce\n    if r == 0:\n        return 1\n    num = reduce(lambda x, y: x * y % MOD, list(range(n, n - r, -1)))\n    den = reduce(lambda x, y: x * y % MOD, list(range(1, r + 1)))\n    return num * pow(den, MOD - 2, MOD) % MOD\n\n\nncr = nCr(n * m - 2, k - 2)\nans = 0\nfor d in range(1, m):\n    temp = d * (m - d) * n**2\n    temp %= mod\n    ans += temp\n    ans %= mod\nfor d in range(1, n):\n    temp = d * (n - d) * m**2\n    temp %= mod\n    ans += temp\n    ans %= mod\nans *= ncr\nans %= mod\nprint(ans)\n", "class Combination:\n    def __init__(self, size, mod=10**9 + 7):\n        self.size = size + 2\n        self.mod = mod\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % self.mod\n            self.inv[i] = -self.inv[self.mod % i] * (self.mod // i) % self.mod\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % self.mod\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % self.mod\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % self.mod) % self.mod\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b\n        return self.ncr(n + r - 1, n - 1)\n\n    def factN(self, n):\n        if n < 0:\n            return 0\n        return self.fact[n]\n\nN, M, K = list(map(int, input().split()))\nMOD = 10**9 + 7\ncomb = Combination(N * M + 100)\n\nS = 0\nfor x in range(1, N):\n    S += (N - x) * (M**2) * x\nfor y in range(1, M):\n    S += (M - y) * (N**2) * y\n\nans = S * comb.ncr(N * M - 2, K - 2)\nprint((ans % MOD))\n", "MOD = 10**9 + 7\n\nN, M, K = list(map(int, input().split()))\n\ndef getComb(n, k, MOD):\n    if n < k:\n        return 0\n    if n-k < k:\n        k = n-k\n    comb = 1\n    for x in range(n-k+1, n+1):\n        comb = (comb * x) % MOD\n    d = 1\n    for x in range(1, k+1):\n        d = (d * x) % MOD\n    comb *= pow(d, MOD-2, MOD)\n    return comb % MOD\n\ncomb = getComb(N*M-2, K-2, MOD)\n\nans = 0\nfor i in range(N):\n    ans += i*(N-i)*M*M\n    ans %= MOD\n\nfor j in range(M):\n    ans += j*(M-j)*N*N\n    ans %= MOD\n\nans *= comb\nans %= MOD\n\nprint(ans)\n", "# inverse x^(-1)\ndef inv(x):\n    nonlocal mod\n    return pow(x, mod - 2, mod)\n\n# factorial x!\ndef fact(x):\n    nonlocal mod\n    res=1\n    for i in range(2 , x + 1):\n        res=res * i % mod\n    return res\n\n# combination nCr\ndef combi(n,r):\n    if r < 0 or r > n:\n        return 0\n    else:\n        return fact(n) * inv(fact(r)) * inv(fact(n - r)) % mod\n\nmod = 10 ** 9 + 7\nN, M, K = map(int,input().split())\nx = (N - 1) * N * (N + 1) * inv(6) % mod\nx = x * M * M % mod\ny = (M - 1) * M * (M + 1) * inv(6) % mod\ny = y * N * N % mod\nz = combi(M * N - 2, K - 2)\nans = (x + y) * z % mod\nprint(ans)", "N,M,K=map(int,input().split())\nc=[0 for i in range(N*M)]\nc[1]=1\nc[0]=1\nmod=10**9+7\nfor i in range(1,N*M-1):\n  c[i+1]=(i+1)*c[i]%mod\ndef comb(a,b):\n  return c[a]*pow(c[b],mod-2,mod)*pow(c[a-b],mod-2,mod)%mod\nans=0\nfor i in range(N):\n  ans+=i*(N-i)*pow(M,2)\n  ans%=mod\nfor i in range(M):\n  ans+=i*(M-i)*pow(N,2)%mod\n  ans%=mod\nans*=comb(N*M-2,K-2)\n\nans%=mod\nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass ModTools:\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n        inverse = [1] * MAX\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, 0, -1):\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n        if n < r: return 0\n        # 10C7 = 10C3\n        r = min(r, n-r)\n        # \u5206\u5b50\u306e\u8a08\u7b97\n        numerator = self.fact[n]\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\nH, W, K = MAP()\n\nN = H * W\nmt = ModTools(N, MOD)\n\nansh = 0\nfor i in range(1, H+1):\n    ansh += i * (H-i) * pow(W, 2, MOD)\n    ansh %= MOD\nansh *= mt.nCr(N-2, K-2)\nansh %= MOD\n\nansw = 0\nfor i in range(1, W+1):\n    answ += i * (W-i) * pow(H, 2, MOD)\n    answ %= MOD\nansw *= mt.nCr(N-2, K-2)\nansw %= MOD\n\nprint(((ansh + answ) % MOD))\n", "MOD=10**9+7\nN,M,K=map(int,input().split())\n\ndef powmod(a,p):\n  if p==0:\n    return 1\n  elif p==1:\n    return a\n  else:\n    pow2=powmod(a,p//2)\n    if p%2==0:\n      return (pow2**2)%MOD\n    else:\n      return (a*pow2**2)%MOD\n\ndef invmod(a):\n  return powmod(a,MOD-2)\n\ndef comb_mod(n,r):\n  nPr=1\n  fact_r=1\n  for i in range(r):\n    nPr*=n-i\n    nPr%=MOD\n    fact_r*=r-i\n    fact_r%=MOD  \n  return (nPr*invmod(fact_r))%MOD\n\nanswer_tate=0\nfor d in range(1,N):\n  answer_tate+=d*M**2*(N-d)\n  answer_tate%=MOD\n  \nanswer_yoko=0\nfor d in range(1,M):\n  answer_yoko+=d*N**2*(M-d)\n  answer_yoko%=MOD\n\ncomb=comb_mod(N*M-2,K-2)\nprint(comb*(answer_tate+answer_yoko)%MOD)", "\ndef xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a // b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return x0\n\ndef modinv(a, m):\n    x = xgcd(a, m)\n    return x % m\n\n\nmax_num = 10 ** 9 + 7\nres = 0\nn, m, k = list(map(int, input().strip().split()))\n\nfor d in range(1, n):\n    res += (n - d) * d * m * m\n    res %= max_num\nfor d in range(1, m):\n    res += (m - d) * d * n * n\n    res %= max_num\n\nr = min(n*m-2, k-2)\nfor i in range(1, r+1):\n    res *= n * m - 1 - i\n    res %= max_num\nfor i in range(1, r+1):\n    res *= modinv(i, max_num)\n    res %= max_num\n\nprint(res)\n", "#!/usr/bin/env python3\ndef main():\n    N, M, K = list(map(int, input().split()))\n    m = 10**9+7\n    # \u65b9\u91dd: \uff12\u3064\u306e\u99d2\u306e\u8ddd\u96e2\u3060\u3051\u8003\u3048\u308c\u3070\u826f\u3044\u3001\u305d\u308c\u4ee5\u5916K-2\u500b\u306e\u99d2\u306e\u4f4d\u7f6e\u304c(N*M-2)C(K-2)\u901a\u308a\u3042\u308b\n    # \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u306fx\u65b9\u5411\u3068y\u65b9\u5411\u3092\u72ec\u7acb\u306b\u6271\u3048\u308b\n    ans = 0\n    for d in range(1,M):\n        ans += (d*(M-d)%m) * pow(N,2,m) % m\n        ans %= m\n\n    for d in range(1,N):\n        ans += (d*(N-d)%m) * pow(M,2,m) % m\n        ans %= m\n\n    # \u7b54\u3048\u306b(NM-2)C(K-2)\u304b\u3051\u308b\n    # K\u56de\u3057\u304b\u51e6\u7406\u3057\u306a\u3044\u304b\u3089\u9593\u306b\u5408\u3046\n    for r in range(K-2):\n        ans *= ((N*M%m-2)%m-r)%m\n        ans %= m\n        ans *= pow(r+1,m-2,m)\n        ans %= m\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 10 ** 9 + 7\n\n\nclass Combination:\n    \"\"\"\n    SIZE\u304c10^6\u7a0b\u5ea6\u4ee5\u4e0b\u306e\u4e8c\u9805\u4fc2\u6570\u3092\u4f55\u56de\u3082\u547c\u3073\u51fa\u3057\u305f\u3044\u3068\u304d\u306b\u4f7f\u3046\n    \u4f7f\u3044\u65b9:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    N, M, K = map(int, input().split())\n    comb = Combination(N * M + 10, mod)\n\n    ans = 0\n    for d in range(1, N):\n        tmp = (N - d) * M * M % mod\n        ans += d * tmp * comb(N * M - 2, K - 2)\n        ans %= mod\n\n    for d in range(1, M):\n        tmp = (M - d) * N * N % mod\n        ans += d * tmp * comb(N * M - 2, K - 2)\n        ans %= mod\n\n    print(ans)\n__starting_point()", "def combination_mod(n,r,MOD=10**9+7):\n    n_=1\n    for i in range(1,n+1):\n        n_=(n_*i)%MOD\n    r_=1\n    for i in range(1,r+1):\n        r_=(r_*i)%MOD\n    nr_=1\n    for i in range(1,n-r+1):\n        nr_=(nr_*i)%MOD\n\n    power_r=pow(r_,MOD-2,MOD)\n    power_nr=pow(nr_,MOD-2,MOD)\n\n    return (n_*power_r*power_nr)%MOD\n\n\ndef main():\n    N,M,K=list(map(int,input().split()))\n\n    MOD=10**9+7\n    num=combination_mod(N*M-2,K-2)\n\n    col_ans=0\n    row_ans=0\n\n    for i in range(1,M):\n        col_ans+=pow(N,2)*(M-i)*num*i\n\n    for i in range(1,N):\n        row_ans+=pow(M,2)*(N-i)*num*i\n\n    ans=(col_ans+row_ans)%MOD\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n,m,k = map(int,input().split())\nmod = 10**9+7\nrng = n*m+10\nfctr = [1]\nfinv = [1]\nfor i in range(1,rng):\n  fctr.append(fctr[-1]*i%mod)\nfor i in range(1,rng):\n  finv.append(pow(fctr[i],mod-2,mod))\ndef cmb(n,k):\n  if n<0 or k<0:\n    return 0\n  else:\n    return fctr[n]*finv[n-k]*finv[k]%mod\n\ncost = [[0 for i in range(m+1)] for j in range(n+1)]\ncost[1][1] = ((n-1)+(m-1))*n*m//2\nfor i in range(1,n+1):\n  for j in range(1,m+1):\n    if j>1:\n      cost[i][j] = cost[i][j-1]-(m-2*(j-1))*n\n    elif i>1:\n      cost[i][j] = cost[i-1][j]-(n-2*(i-1))*m\nans = 0\nfor i in cost:\n  ans = (ans+sum(i))%mod\nans = ans*pow(2,mod-2,mod)%mod\nans = ans*cmb(n*m-2,k-2)%mod\nprint(ans)", "MOD = 10**9+7\n\n# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef nCr(n, r, mod=10**9+7):\n    r = min(r, n-r)\n    numer = denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n+1-i) % mod\n        denom = denom * i % mod\n    return numer * pow(denom, mod-2, mod) % mod\n\nN, M, K = list(map(int, input().split()))\nans = 0\n# 2\u70b9\u306e\u5dee\u304cx\u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306f\u540c\u3058\u884c\u3067M-x\u901a\u308a\u30012\u70b9\u306e\u884c\u306e\u7d44\u307f\u5408\u308f\u305b\u306fN*N\u901a\u308a\nfor x in range(M):\n    ans += x * (M-x) * N*N\nfor y in range(N):\n    ans += y * (N-y) * M*M\n\n# 2\u70b9\u4ee5\u5916(K-2)\u3092N*M-2\u306e\u30de\u30b9\u306b\u914d\u7f6e\u3059\u308b\u7d44\u307f\u5408\u308f\u305b\u306fnCr(N*M-2, K-2)\u901a\u308a\nans *= nCr(N*M-2, K-2, MOD)\nans %= MOD\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, M, K = list(map(int, input().split()))\n    MOD = 10**9+7\n\n    class Comb:\n        def __init__(self, N):\n            self.fac = [1] * (N+1)\n            for i in range(2, N+1): self.fac[i] = self.fac[i-1] * i % MOD\n\n        def pow(self, a, b):\n            res = 1\n            while b:\n                if b & 1: res = res * a % MOD\n                a = a**2 % MOD\n                b >>= 1\n            return res\n\n        def comb(self, n, r):\n            if r < 0 or r > n: return 0\n            return (self.fac[n] * self.pow(self.fac[r], MOD-2)) % MOD * self.pow(self.fac[n-r], MOD-2) % MOD\n\n        def permutation(self, n, r):\n            if r == 0: return 1\n            return self.fac[n] * self.pow(self.fac[n-r], MOD-2) % MOD\n\n    comb = Comb(N*M-2)\n\n    ans = 0\n    for i in range(M):\n        ans += i * (M-i) * (N**2)\n\n    for i in range(N):\n        ans += i * (N-i) * (M**2)\n\n    print(ans*comb.comb(N*M-2, K-2)%MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "U = 2*10**5\nMOD = 10**9+7\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[k]\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n\nn, m, k = map(int, input().split())\nans = ((n-1)*n*(n+1)//6*m**2 + (m-1)*m*(m+1)//6*n**2) * comb(n*m-2, k-2)\nprint(ans%MOD)", "N, M, K = map(int,input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nMAX_N = 10**6 # N >= n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, MAX_N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nk = cmb(M * N - 2,K - 2,mod)\n\n\n\ndef calc(p, q, d):\n    return d * (p - d) * (q ** 2)\n\nans = 0\n\nfor i in range(N):\n    ans += calc(N, M, i)\nfor i in range(M):\n    ans += calc(M, N, i)\n\nans %= mod\n\nans *= k\n\nans %= mod\n\nprint(ans)", "n, m, k = map(int, input().split())\nmod = 10 ** 9 + 7\n\nres_n = 0\nfor i in range(1, n+1):\n    res_n += (n + 1 - i) * (n - i) // 2\n    res_n %= mod\nres_n = (res_n * (m ** 2)) % mod\n\nres_m = 0\nfor i in range(1, m+1):\n    res_m += (m + 1 - i) * (m - i) // 2\n    res_m %= mod\nres_m = (res_m * (n ** 2)) % mod\n\nres = res_n + res_m\n#print(res)\n\nf = [1 for _ in range(n*m)]\nfor i in range(1, n*m):\n    f[i] = f[i-1] * i % mod\n\nres = res * f[n*m-2] * pow(f[k-2], mod-2, mod) * pow(f[n*m-k], mod-2, mod) % mod\n\nprint(res)", "\nN,M,K = list(map(int, input().split()))\n\nMOD = 10**9+7\n \nMAXN = N*M + 10\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n \ndef nCr(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\n\n#X\uff1a+ax*(ax - 1) * N - ax * (M - ax) * N = ax*N*(ax-1-M+ax) = ax*N*(2ax-1-M)\nans = 0\n\nfor i in range(1,M+1):\n    tmp = (((((i * N) % MOD) * (2*i - 1 - M)) % MOD) * N) % MOD\n    \n    #print(\"~~~\", i*N, 2*i - 1 - M,tmp, nCr(N*M-2, K-2))\n\n    tmp *= nCr(N*M-2, K-2)\n\n    tmp %= MOD\n    #print(\"pppp\", tmp)\n    ans += tmp\n\n    ans %= MOD\n\n\nfor i in range(1,N+1):\n    tmp = (((((i * M) % MOD) * (2*i - 1 - N)) % MOD) * M) % MOD\n\n    tmp *= nCr(N*M-2, K-2)\n\n    tmp %= MOD\n    ans += tmp\n    ans %= MOD\n\n\nprint(ans)\n", "n,m,k=map(int,input().split())\nmod=pow(10,9)+7\n\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u3001\u3055\u3089\u306b\u9ad8\u901f\u3002\u3042\u3089\u304b\u3058\u3081O(N)\u306e\u8a08\u7b97\u3092\u3059\u308b\u3053\u3068\u3067\u306e\u3061\u306e\u8a08\u7b97\u304c\u65e9\u304f\u306a\u308b\ndef cmb(n,r,mod):\n  if (r<0 or r>n):\n    return 0\n  r=min(r,n-r)\n  return g1[n]*g2[r]*g2[n-r]%mod\ng1=[1,1] # g1[i]=i! % mod\u3000:\u968e\u4e57\ng2=[1,1] # g2[i]=(i!)^(-1) % mod\u3000:\u968e\u4e57\u306e\u9006\u5143\ninverse=[0,1]\nfor i in range(2,n*m+1):\n  g1.append((g1[-1]*i)%mod)\n  inverse.append((-inverse[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inverse[-1])%mod)\n\nans=0\nfor d in range(1,n):\n  tmp=d*(n-d)*m**2\n  tmp%=mod\n  tmp*=cmb(n*m-2,k-2,mod)\n  ans+=tmp\n  ans%=mod\nfor d in range(1,m):\n  tmp=d*(m-d)*n**2\n  tmp%=mod\n  tmp*=cmb(n*m-2,k-2,mod)\n  ans+=tmp\n  ans%=mod\nprint(ans)", "N,M,K = map(int,input().split())\nMOD = 10**9+7\n\nMAXN = N*M+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\na = 0\nfor d in range(1,N):\n    a += d*(N-d) * M*M\nb = 0\nfor d in range(1,M):\n    b += d*(M-d) * N*N\nans = (a+b) * comb(N*M-2, K-2)\nans %= MOD\nprint(ans)", "def comb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n############################################################\n\nN, M, K = map(int, input().split())\nMOD = 10**9+7\nsumx = 0\nsumy = 0\n\nfor d in range(1, N):\n    cnt = (N-d)*M**2\n    cnt %= MOD\n    cnt *= comb(N*M-2, K-2, MOD)\n    sumx += d*cnt\n    sumx %= MOD\n\nfor d in range(1, M):\n    cnt = (M-d)*N**2\n    cnt %= MOD\n    cnt *= comb(N*M-2, K-2, MOD)\n    sumy += d*cnt\n    sumy %= MOD\nprint((sumx + sumy)%MOD)", "\n\ndef modinv(a, mod):\n    b = mod\n    x, u = 1, 0\n    while b:\n        q = a//b\n        a, b = b, a-q*b\n        x, u = u, x-q*u\n    x %= mod\n    return x\n\n\ndef mod_nCr_init(n, mod):\n    fac[0] = fac[1] = 1\n    facinv[0] = facinv[1] = 1\n    inv[1] = 1\n    for i in range(2, n):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = -inv[mod % i] * (mod // i) % mod\n        facinv[i] = facinv[i-1] * inv[i] % mod\n\n\ndef mod_nCr(n, r, mod):\n    if n < r or n < 0 or r < 0:\n        return 0\n    return fac[n] * (facinv[r] * facinv[n-r] % mod) % mod\n\n\nN, M, K = list(map(int, input().split()))\nfac = [0]*(N*M)\nfacinv = [0]*(N*M)\ninv = [0]*(N*M)\n\nmod = 10**9 + 7\nmod_nCr_init(N*M, mod)\nC = mod_nCr(N*M-2, K-2, mod)\n\nans = 0\nfor _ in [0, 0]:\n    for d in range(1, N):\n        ans += (N-d)*M*M*d*C\n\n    N, M = M, N\n\nprint((ans % mod))\n\n", "N, M, K = map(int, input().split())\nmod = 10**9+7\n\ndef nCk(n, k, mod):\n    nu = 1\n    de = 1 \n    for i in range(1, k+1):\n        nu *= (n-i+1)\n        de *= i\n        nu = nu % mod\n        de = de % mod\n    ans = nu * pow(de, mod-2, mod) % mod\n    return ans\n\nans = nCk(N*M-2, K-2, mod)*N*M*(M+N)*(M*N-1)//6\nans = ans % mod\nprint(ans)", "##mod,n\u306b\u3064\u3044\u3066\u306e\u5236\u7d04\u306f\u81ea\u5206\u3067\u3044\u304b\u306b\u8a18\u5165\u3059\u308b\nmod=10**9+7\ndef find_power(n,mod):\n    # 0!\u304b\u3089n!\u307e\u3067\u306e\u3073\u3063\u304f\u308a\u3092\u51fa\u3057\u3066\u304f\u308c\u308b\u95a2\u6570(\u305f\u3060\u3057\u3001mod\u3067\u5272\u3063\u305f\u5024\u306b\u5bfe\u3057\u3066\u3067\u3042\u308b\uff09\n    powlist=[0]*(n+1)\n    powlist[0]=1\n    powlist[1]=1\n    for i in range(2,n+1):\n        powlist[i]=powlist[i-1]*i%(mod)\n    return powlist\n #\u3042\u308b\u304b\u305ax\u306en\u4e57\u3092mod\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3092\u8fd4\u3059\u95a2\u6570pow_cal(x,n,mod)\ndef pow_cal(x,n,mod):\n    if n==0:\n         return 1\n    elif n==1:\n         return x%mod\n    elif n>=2:\n        if n%2==0:\n             return (pow_cal(x,n//2,mod)**2)%mod\n        else:\n             return (x*pow_cal(x,n//2,mod)**2)%mod\n\ndef find_inv_power(n,mod):\n    #0!\u304b\u3089n!\u307e\u3067\u306e\u9006\u5143\u3092\u7d20\u6570mod\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\u95a2\u6570\n    c=1\n    uselist=[0 for i in range(n+1)]\n    for i in range(1,n+1):\n        c*=i\n        c%=mod\n    first=pow_cal(c,mod-2,mod)\n    uselist[n]=first\n    for i in range(n,0,-1):\n        uselist[i-1]=(uselist[i]*i)%(mod)\n    return uselist\n    \nA=find_power(4*10**5,mod)\nB=find_inv_power(4*10**5,mod)\n\ndef combi(n,r,mod):\n    if n<r:\n        return 0\n    elif n>=r:\n        return (A[n]*B[r]*B[n-r])%(mod)\n\n    \nM,N,K=list(map(int,input().split()))\nans=M*N*(M+N)*(M*N-1)//6\n\nprint((ans*combi(M*N-2,K-2,mod)%mod))\n\n", "MOD = 10**9 + 7\n\ndef MOD_perm(n, r):\n    rtn = 1\n    for _ in range(r):\n        rtn *= n\n        rtn %= MOD\n        n -= 1\n    return rtn\n\ndef MOD_inv(a):\n    b = MOD\n    u = 1\n    v = 0\n    while b > 0:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u = u % MOD\n    if u < 0:\n        u += MOD\n    return u\n\ndef MOD_COM2(n, r):\n    return MOD_perm(n, r) * MOD_inv(MOD_perm(r, r)) % MOD\n\ndef main():\n    n, m, k = map(int, input().split())\n    comb = MOD_COM2(n*m-2, k-2)\n    ans = 0\n    for i in range(1, n+1):\n        U = (i-1)*i//2\n        U *= m*m\n        U *= comb\n        U %= MOD\n        ans += U\n        ans %= MOD\n    for j in range(1, m+1):\n        L = (j-1)*j//2\n        L *= n*n\n        L *= comb\n        L %= MOD\n        ans += L\n        ans %= MOD\n    print(ans%MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "H, W, K = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nfactorial = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse_from = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, H * W + 1):\n    factorial.append((factorial[-1] * i) % MOD)\n    inverse_from.append((-inverse_from[MOD % i] * (MOD // i)) % MOD)\n    inverse.append((inverse[-1] * inverse_from[-1]) % MOD)\n\n\ndef nCr(n, r):\n    if n < r or r < 0:\n        return 0\n    elif r == 0:\n        return 1\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\nans = 0\n# H\u306b\u3064\u3044\u3066\nfor d in range(1, H):\n    ans += d * (H - d) * pow(W, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n    ans %= MOD\n# W\u306b\u3064\u3044\u3066\nfor d in range(1, W):\n    ans += d * (W - d) * pow(H, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n    ans %= MOD\n\nprint((ans % MOD))\n", "import sys\nmod = 7 + 10 ** 9\n\ndef comb(n, r, fact, revfact):\n    return (fact[n] * revfact[n-r] * revfact[r]) % mod\ndef solve():\n    input = sys.stdin.readline\n    N, M, K = map(int, input().split())\n    fact = [1] * (N * M + 1)\n    for i in range(1, N * M + 1): fact[i] = (fact[i-1] * i) % mod\n    revfact = [1] * ( N * M + 1)\n    revfact[N * M] = pow(fact[N * M], mod-2, mod)\n    for i in reversed(range(1, N * M)): revfact[i] = ((i + 1) * revfact[i+1]) % mod\n\n    others = comb(N * M - 2, K - 2, fact, revfact)\n    pair_type = 0\n    for i in range(N): #\u7e26\u306e\u8ddd\u96e2\u304ci\n        if i == 0:\n            for j in range(1, M): #\u6a2a\u306e\u8ddd\u96e2\u304cj\n                pair_type += (i + j) * (N - i) * (M - j) % mod\n                pair_type %= mod\n        else:\n            for j in range(M):\n                if j == 0: pair_type += (i + j) * (N - i) * (M - j) % mod\n                else: pair_type += 2 * (i + j) * (N - i) * (M - j) % mod\n                pair_type %= mod\n    \n    print(pair_type * others % mod)\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "N,M,K = map(int,input().split())\nMOD = 10**9+7\n\nMAXN = N*M+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\na = 0\nfor d in range(1,N):\n    a += d*(N-d)*M*M\nb = 0\nfor d in range(1,M):\n    b += d*(M-d)*N*N\n\nans = (a+b) * comb(N*M-2, K-2)\nans %= MOD\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport copy\n\ndef main():\n    N,M,K = list(map(int,input().split()))\n    MOD = 10**9+7\n    fac = [0 for _ in range(N*M-1)]\n    fac[0],fac[1] = 1,1\n    inv = copy.deepcopy(fac)\n    invfac = copy.deepcopy(fac)\n    \n    for i in range(2,N*M-1):\n        fac[i] = (fac[i-1]*i)%MOD\n        inv[i] = MOD-(MOD//i)*inv[MOD%i]%MOD\n        invfac[i] = (invfac[i-1]*inv[i])%MOD\n        \n    def coef(x,y):\n        num = (((fac[x]*invfac[y])%MOD)*invfac[x-y]%MOD)\n        return num\n\n    xa = ((M**2)*N*(N-1)*(N+1)//6)%MOD\n    ya = ((N**2)*M*(M-1)*(M+1)//6)%MOD\n    print(((xa+ya)*coef(N*M-2,K-2)%MOD))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M, K = list(map(int, input().split()))\n\n    calc = Calc(max_value=N * M - 2, mod=MOD)\n\n    xsum = 0\n    for d in range(1, N):\n        xsum = (xsum + d * (N - d)) % MOD\n    xsum = (xsum * M * M) % MOD\n\n    ysum = 0\n    for d in range(1, M):\n        ysum = (ysum + d * (M - d)) % MOD\n    ysum = (ysum * N * N) % MOD\n\n    ans = (xsum + ysum) * calc.combination(N * M - 2, K - 2) % MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n# import sys\n#\n# sys.setrecursionlimit(10 ** 7)\n#\n# input = sys.stdin.readline\n# rstrip()\n# int(input())\n# map(int, input().split())\n\n__starting_point()", "#!python3\n\ndef LI():\n    return list(map(int, input().split()))\n\n# input\nN, M, K = LI()\n\nMOD = 10 ** 9 + 7\nMAX = 10 ** 5 * 2\nfac, finv, inv = [None] * MAX, [None] * MAX, [None] * MAX\n\n\ndef comb_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = -inv[MOD%i] * int(MOD / i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n\ndef comb(n, k):\n    if n < k or n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\n\ndef s(x):\n    return x * (x + 1) // 2\n\n\ndef cal(a, b):\n    ret = a * s(b - 1) + b * s(a - 1)\n    return ret % MOD\n\n\ndef main():\n    comb_init()\n    ans = 0\n    for i in range(N):\n        for j in range(M):\n            v = cal(N - i, M - j) + cal(N - i, j + 1) - (s(j) + s(N - i - 1))\n            ans = (ans + v) % MOD\n\n    ans = ans * comb(N * M - 2, K - 2) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
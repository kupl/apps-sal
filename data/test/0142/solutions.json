["3\n# Copyright (C) 2017 Sayutin Dmitry.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 3\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\n\ndef solve(a, l):\n    if l == 0:\n        return 0\n\n    if l == 1:\n        return a[0]\n    \n    k = 0\n    while (2 ** k) < l:\n        k += 1\n    \n    return min(a[k], a[k - 1] + solve(a, l - (2 ** (k - 1))))\n    \n\ndef main():\n    n, l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n\n    for i in range(n - 2, -1, -1):\n        if a[i] > a[i + 1]:\n            a[i] = a[i + 1]\n    \n    for i in range(1, n):\n        if a[i] > 2 * a[i - 1]:\n            a[i] = 2 * a[i - 1]\n\n    while len(a) < 35:\n        a.append(2 * a[len(a) - 1])\n\n    #print(a)\n\n    print(solve(a, l))\n            \nmain()\n", "import sys\ninput = sys.stdin.readline\n\nn, L = map(int, input().split())\nc = list(map(int, input().split()))\na = [c[0]]\n\nfor i in range(1, 31):\n  cand = [a[-1] * 2]\n  if i < n: cand.append(c[i])\n  a.append(min(cand))\n\nans = []\nsum = 0\n\nfor i in reversed(range(31)):\n  if L <= (1<<i):\n    ans.append(sum + a[i])\n  else:\n    L -= (1<<i)\n    sum += a[i]\n  \nprint(min(ans))", "n, m = map(int, input().split())\nl = [int(x) for x in input().split()]\nfor i in range(1, n):\n    l[i] = min(l[i], 2*l[i - 1])\nc = l + [l[-1] * 2 ** i for i in range(1, 32)]\n\ndef cost(x):\n    ans = 0\n    for i in range(32):\n        if x & (1 << i):\n            ans += c[i]\n    return ans\n\nans = cost(m)\nfor i in range(32):\n    if not (m & (1 << i)):\n        tmp = m - (m % (1 << i)) + (1 << i)\n        ans = min(ans, cost(tmp))\n\nprint(ans)", "read = lambda: list(map(int, input().split()))\nn, L = read()\nc = list(read())\nfor _ in range(5):\n    for i in range(n - 2, -1, -1):\n        c[i] = min(c[i], c[i + 1])\n    for i in range(1, n):\n        c[i] = min(c[i], c[i - 1] * 2)\ncur = 0\nans = 10 ** 30\nL1 = L\nfor i in range(n - 1, -1, -1):\n    cnt = L1 // (2**i)\n    cur += cnt * c[i]\n    ans = min(ans, cur + c[i])\n    L1 -= cnt * (2**i)\nans = min(ans, cur)\nfor i in range(n - 1, -1, -1):\n    if (2**i)>=L:\n        ans = min(ans, c[i])\nprint(ans)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Jan  8 09:32:18 2018\n\n@author: yanni\n\"\"\"\n\nn, L = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nsize = [2**p for p in range(n)]\nfor index in range(n):\n    if (index > 0):\n        c[index] = min(c[index], c[index-1]*2)\nfor index in range(n):\n    if (index > 0):\n        temp = n-1-index\n        c[temp] = min(c[temp], c[temp+1])\nposs = []\nbase = 0\nmaxindex = 0\nwhile (size[maxindex] < L and maxindex < n-1):\n    maxindex += 1\nif (size[maxindex] < L):\n    base = (L//size[maxindex]) * c[maxindex]\n    L = L % size[maxindex]\nif (L == 0):\n    print(base)\nelse:\n    poss.append(base + c[maxindex])\n    curr = base\n    while (L > 0):\n        while (size[maxindex] >= 2*L):\n            maxindex -= 1\n        poss.append(curr + c[maxindex])\n        if (maxindex == 0):\n            curr += c[0]\n            L = 0\n        else:\n            L -= size[maxindex-1]\n            curr += c[maxindex-1]\n    poss.append(curr)\n    print(min(poss))\n    \n        \n", "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, L = mi()\nC = li()\nfor i in range(1, n):\n    C[i] = min(C[i], C[i-1] * 2)\n\nx = 2 ** (n-1)\ny = 0\nz = 10 ** 18\nfor i in range(n-1, -1, -1):\n    t = L // x\n    y += C[i] * t\n    z = min(z, y + C[i])\n    L %= x\n    x //= 2\nz = min(z, y)\nprint(z)", "#!/usr/bin/env python3\n\ndef main():\n    n, needed = list(map(int, input().split()))\n    costs = list(map(int, input().split()))\n\n    done = False\n    while not done:\n        done = True\n        cur = costs[0]\n        for i, x in enumerate(costs[1:], 1):\n            cur <<= 1\n            if cur < x:\n                costs[i] = cur\n                done = False\n            else:\n                cur = x\n        for i in range(n - 2, -1, -1):\n            if costs[i] > costs[i + 1]:\n                costs[i] = costs[i + 1]\n                done = False\n\n    def calc(total):\n        result = 0\n        for i in range(31):\n            if total & 1 << i:\n                if i < n:\n                    result += costs[i]\n                else:\n                    result += costs[-1] << (i - n + 1)\n        return result\n\n    result = calc(needed)\n    for i in range(30, -1, -1):\n        x = (needed >> i | 0x1) << i\n        if x >= needed:\n            result = min(result, calc(x))\n\n    print(result)\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n", "from sys import stdin, stdout\n\n\nsze = 100\nINF = float('inf')\n\nn, l = map(int, stdin.readline().split())\nc = list(map(int, stdin.readline().split()))\nmay = [1 for i in range(sze)]\n\nfor i in range(n - 1, -1, -1):\n    for j in range(i):\n        if c[i] > c[j] * 2 ** (i - j):\n            may[i] = 0\n\n\n\nans = INF\n\ncnt = 0\nvalue = 0\n\nfor i in range(n - 1, -1, -1):\n    if not may[i]:\n        continue\n    \n    v = l - value\n    \n    if not v % (2 ** i):\n        ans = min(ans, cnt + v * c[i] // (2 ** i))\n    else:\n        ans = min(ans, cnt + (v // (2 ** i) + 1) * c[i])\n    \n    cnt += v // (2 ** i) * c[i]\n    value += (v // (2 ** i)) * (2 ** i)\n\nstdout.write(str(ans))", "n, l = map(int, input().split())\np = list(map(int, input().split()))\nd = []\nd = [[p[i] / 2**i, i + 1] for i in range(n)]\nd.sort(key = lambda x: x[0])\nres = 10**18\nq = l\ncurres = 0\nfor i in d:\n\tif i[1] == 1:\n\t\tcurres += p[i[1] - 1] * q\n\t\tres = min(res, curres)\n\t\tbreak\n\tcurb = q // 2**(i[1] - 1)\n\tcurres += curb * p[i[1] - 1]\n\tres = min(res, curres + p[i[1] - 1])\n\tq %= 2**(i[1] - 1)\nprint(res)", "n, l = map(int, input().split())\narr = list(map(int, input().split()))\nfor i in range(1, len(arr)):\n\tarr[i] = min(arr[i], arr[i - 1] * 2)\nfor i in range(64):\n\tarr.append(arr[-1] * 2)\ndp = 0\nfor i in range(64):\n\tif ((l >> i) & 1):\n\t\tdp += arr[i]\n\telse:\n\t\tdp = min(dp, arr[i])\nprint(dp)", "n, L = list(map(int, input().split()))\npr = list(map(int, input().split()))\nres = 0\nposs = []\nber = [(pr[i] / 2 ** i, i) for i in range(n)]\nber.sort()\nfor i in range(n):\n    d = L // (2 ** ber[i][1])\n    res += d * pr[ber[i][1]]\n    L -= d * (2 ** ber[i][1])\n    if L == 0:\n        poss.append(res)\n    poss.append(res + pr[ber[i][1]])\nprint(min(poss))\n", "n, L = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\nfor i in range(1, n):\n    if (c[i] > c[i-1] * 2):\n        c[i] = c[i-1] * 2\nans1 = 0\nans2 = 0\nans = 10**20\nfor i in range(n-1, -1, -1):\n    r1 = L // (2**i)\n    r2 = (L + 2**i - 1) // (2**i)\n    L -= (r1 * 2**i)\n    ans1 = ans2 + r2 * c[i]\n    ans2 += r1 * c[i]\n    ans = min(ans, ans1)\nans = min(ans, ans2)\nprint(ans)", "n,L=map(int,input().split())\n\npowers=[]\nfir=1\nfor i in range(n):\n    powers.append(fir)\n    fir*=2\n    \nc=list(map(int,input().split()))\n\nfor i in range(1,n):\n    c[i]=min(2*c[i-1],c[i])\ncost=0\nfincost=[]\n#print(powers)\nfor i in range(n-1,-1,-1):\n    cost+=(L//powers[i])*c[i]\n    L=L%powers[i]\n    if(L==0):\n        fincost.append(cost)\n        \n    else:\n        fincost.append(cost+c[i])\nprint(int(min(fincost)))", "def solve(l, costs):\n\tans = 0\n\tfor i in range(31, -1, -1):\n\t\tif ((l >> i) & 1) == 1:\n\t\t\tans += min(costs[i + 1], costs[i] + solve(l - ex(2, i), costs))\n\t\t\tbreak\n\treturn ans\n\ndef ex(base, exp):\n\tans = 1\n\tfor i in range(exp):\n\t\tans = ans * base\n\treturn ans\n\nn, l = str(input()).split(' ')\nn, l = int(n), int(l)\n\ncosts = str(input()).split(' ')\ncosts = [int(c) for c in costs]\n\nfor i in range(1, n):\n\tcosts[i] = min(costs[i], 2 * costs[i - 1])\n\t\nfor i in range(len(costs), 32):\n\tcosts.append(2 * costs[i - 1])\n\nfor i in range(30, -1, -1):\n\tcosts[i] = min(costs[i], costs[i + 1])\n\t\nprint(solve(l, costs))\n", "\nn, L = map(int, input().split())\nc = [*map(int, input().split())]\nrational = [True] * n\nfor i in range(n):\n\tfor j in range(n):\n\t\tif i < j and c[i] >= c[j]:\n\t\t\trational[i] = False\n\t\tif i < j and c[i] * (2 ** (j - i)) <= c[j]:\n\t\t\trational[j] = False\n\ndef dfs(i, L):\n\tif i == 0: \n\t\treturn L * c[0]\n\telif rational[i]:\n\t\tLi = 2 ** i\n\t\tif Li >= L:\n\t\t\treturn min(c[i], dfs(i - 1, L))\n\t\telse:\n\t\t\treturn (L // Li * c[i]) + dfs(i, L % Li)\n\telse:\n\t\treturn dfs(i - 1, L)\n\n\nprint(dfs(n - 1, L))", "import sys\n\nn, L = list(map (int, sys.stdin.readline().split()))\nc = list (map (int, sys.stdin.readline().split()))\nfor i in range (1, n):\n  c[i] = min (c[i], 2 * c[i-1])\nfor i in range (n-2, -1, -1):\n  c[i] = min (c[i], c[i+1])\n#print (c)\n\n\nres = L // 2 ** (n - 1) * c[n - 1]\nL %= 2 ** (n - 1)\ntres = 0\nfor sh in range (n):\n  if (L & (2 ** sh)) != 0:\n    tres += c[sh]\n  else:\n    tres = min (tres, c[sh])\n\nres += tres\nprint (res)\n", "def solve(a1,b1, cur_sum, cur_L, idx):\n    if cur_L == 0:\n        return cur_sum\n    if idx == len(a1)-1:\n        if cur_L > 0:\n            ost = cur_L%b1[-1] > 0\n            if ost:\n                cur_sum += a1[-1]\n            cur_sum += a1[-1]* (cur_L//b1[-1])\n            return cur_sum\n        else:\n            return cur_sum\n    else:\n        ost = cur_L%b1[idx] > 0\n        if ost:\n            s1 = solve(a1,b1, cur_sum+a1[idx]*((cur_L//b[idx]) + 1), 0,idx+1)\n            s2 = solve(a1,b1, cur_sum+a1[idx]*((cur_L//b[idx])), cur_L % b1[idx],idx+1)\n            return min(s1,s2)\n        else:\n            return solve(a1,b1, cur_sum+a1[idx]*((cur_L//b[idx])), cur_L % b1[idx],idx+1)\n            \n\n            \nn, L = list(map(int, input().split()))\na = list(map(int,input().split()))\nb = [2**i for i in range(len(a))]\nfor i in range(len(a)):\n        for j in range(len(a) - 1, i, -1):\n            if a[j]/b[j] < a[j-1]/b[j-1]:\n                a[j], a[j-1] = a[j-1], a[j]\n                b[j], b[j-1] = b[j-1], b[j]\nans = solve(a,b,0,L,0)\nprint (ans)\n\n        \n", "n, lt = (int(x) for x in input().split())\ncosts = [int(x) for x in input().split()]\n\nc1 = costs[0]\ncosts = costs[1:]\n\nmaincost = lt * c1\nmainlen = lt\nremcost = 0\n\ncurrv = 1\nfor c in costs:\n    currv *= 2\n    nmainl = lt - (lt % currv)\n    prevc = (maincost / mainlen) if maincost != 0 else 0\n    if prevc > (c/currv):\n\n\n        nremlen = mainlen - nmainl\n        remcost += (maincost * nremlen // mainlen)\n\n        mainlen = nmainl\n        maincost = mainlen * c // currv\n\n    if remcost > c:\n        remcost = c\nprint(maincost + remcost)", "n, lit = list(map(int, input().split()))\ncost = list(map(int, input().split())) + ([1 << 100] * 33)\nn = len(cost)\nrlit = lit\n\nfor i in range(n):\n    for j in range(i-1, -1, -1):\n        cost[i] = min(cost[i], cost[j] * (1 << (i - j)))\n\nres = 0\n\nfor i in range(n):\n    if (1 << i) & lit:\n        res += cost[i]\n\nb = []\n\nwhile lit:\n    b.append(lit % 2)\n    lit //= 2\n\nrres = res\n\nfor i in range(len(b)-1, -1, -1):\n    if b[i] == 1:\n        for j in range(i-1, -1, -1):\n            if b[j] == 0:\n                add = cost[j]\n                sub = 0\n                for k in range(j-1, -1, -1):\n                    if b[k] == 1:\n                        sub += cost[k]\n                res = min(res, rres+add-sub)\n\nfor i in range(n):\n    if (1 << i) > rlit and cost[i] < res:\n        res = cost[i]\n\nprint(res)\n", "from itertools import permutations\n\nMOD = 10**9+7\n\ndef find_best(c):\n    n = 2 ** len(c)\n    best_c = c[0] * n\n    best_i = 0\n    for i, ci in enumerate(c):\n        if n // (2**i) * c[i] < best_c:\n            best_c = n // (2**i) * c[i]\n            best_i = i\n    return best_i\n\ndef main():\n    n, l = [int(c) for c in input().split(' ')]\n    c = [int(c) for c in input().split(' ')]\n    ans = []\n    cur_ans = 0\n    while l:\n        ind = find_best(c[:n])\n        vol = 2**ind\n        cnt = l // vol\n        l %= vol\n        cur_ans += cnt * c[ind]\n        ans.append(cur_ans + (l % vol and c[ind] or 0))\n        n = ind\n    print(min(ans))\n\nwhile 1:\n    main()\n    break\n# input()\n", "INF = int(1e18)\n\ndef read_int():\n    return list(map(int, input().split()))\n\n\nn, l = read_int()\ncosts = read_int()\n\nbottles = [(1 << i, c) for i, c in enumerate(costs)]\nbottles.sort(key=lambda b: (b[1] / b[0], 1 / b[1]))\n\nmin_cost = dict()\n\ndef find_min_cost(l):\n    if l == 0:\n        return 0\n    if l in min_cost:\n        return min_cost[l]\n    c = INF\n    for b in bottles:\n        c1 = (l + b[0] - 1) // b[0] * b[1]\n        c2 = l // b[0] * b[1] + find_min_cost(l % b[0]) if l > b[0] else INF\n        c = min(c, c1, c2)\n    min_cost[l] = c\n    return min_cost[l]\n\nprint(find_min_cost(l))", "n, l = map(int, input().split())\nc = list(map(int, input().split()))\n\nv = []\nfor i in range(n):\n    v.append(2**i)\nfrom math import ceil\ndef sl(n,l,c, bl):\n    #print(n, l, c, bl)\n    s = []\n    for i in range(n):\n        if i not in bl:\n            s.append((v[i], v[i]/c[i], c[i], i))\n    sm = min(s, key=lambda x: -x[1])\n    ct = ceil(l / sm[0])\n    if sm[0] == 1:\n        return ct*sm[2]\n    ans = (ct-1)*sm[2]\n    ans1 = min(sm[2], sl(n, l-(ct-1)*sm[0], c, bl + [sm[3]]))\n    return ans + ans1\nprint(sl(n, l, c, []))", "n,L=[int(i) for i in input().split()]\nc=[int(i) for i in input().split()]\ncostPerLemon=[]\nans=12345678901234567890\n\nfor i in range(n):\n\tcostPerLemon.append(c[i]/2**i)\n\n\nsize=n\nmoney=0\nwhile size>1:\n\ttarget=min(costPerLemon)\n\ti=costPerLemon.index(target)\n\t\n\ttimes=int(L/(2**i))\n\tmoney+=c[i]*times\n\tL-=(2**i)*times\n\t\n\tans=min(ans,money+c[i])\n\tsize=i\n\twhile len(costPerLemon)>size:\n\t\tcostPerLemon.pop(-1)\nmoney+=L*c[0]\nans=min(ans,money)\n\nprint(ans)\n\n", "n, L = [int(k) for k in input().split(' ') if k]\ndp = [int(k) for k in input().split(' ') if k]\nfor i in range(1, n):\n\tdp[i] = min(2 * dp[i - 1], dp[i])\nbinary = []\nwhile L != 0:\n\tbinary.append(L % 2)\n\tL //= 2\nwhile len(dp) < len(binary):\n\tdp.append(2 * dp[-1])\ndef minify(p):\n\tresult = 999999999999999999999999999\n\tfor i in range(p + 1, len(dp)):\n\t\tresult = min(result, dp[i])\n\tif p == 0:\n\t\treturn min(result, (dp[p] if binary[p] else 0))\n\treturn min(result, (dp[p] if binary[p] else 0) + minify(p - 1))\nprint(minify(len(binary) - 1))\n", "n, L = list(map(int,input().split()))\narr = [int(x) for x in input().split()]\n\ndef pos(x):\n    ans = 0\n    while(x):\n        x //= 2\n        ans += 1\n    return ans - 1\n\ndef solve(ltr):\n    if ltr == 0:\n        return 0\n    val = pos(ltr)\n    if val + 1 < n:\n        Bmin = min(arr[val + 1:])\n    else:\n        val = n - 1\n        Bmin = 4e20\n    minCost = 4e20\n    amt = 0\n    for i in range(val + 1):\n        v = arr[i] / (2 ** i)\n        if v <= minCost:\n            minCost = v\n            amt = i\n    minCost = arr[amt]\n    minCost *= ltr // (2 ** amt)\n    return min(minCost + solve(ltr % ( 2 ** amt)), Bmin)\n\nprint(solve(L))\n"]
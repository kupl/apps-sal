["#!/usr/bin/env python3\n# coding=utf-8\n\nimport sys\n\nimport numpy as np\n\nn, k = list(map(int, sys.stdin.readline().strip().split(\" \")))\nxyc = [l.strip().split(\" \") for l in sys.stdin.readlines()]\nxy = [(int(_x) % (2 * k), int(_y) % (2 * k) if _c == \"W\" else (int(_y) + k) % (2 * k))\n      for (_x, _y, _c) in xyc]\n\n# ans = np.zeros((2 * k, 2 * k), dtype=np.int32)\nans = [[0 for j in range(2 * k + 1)] for i in range(2 * k + 1)]\nfor _x, _y in xy:\n    if (_x - k + 0.5) * (_y - k + 0.5) > 0:\n        _x %= k\n        _y %= k\n        ans[_x][_y] += 2\n        ans[_x + k][_y] -= 2\n        ans[_x][_y + k] -= 2\n        ans[_x + k][_y + k] += 2\n        ans[_x + k][0] += 1\n        ans[0][_y + k] += 1\n        ans[0][0] += 1\n        ans[_x][0] -= 1\n        ans[0][_y] -= 1\n    else:\n        _x %= k\n        _y %= k\n        ans[_x][_y] -= 2\n        ans[_x + k][_y] += 2\n        ans[_x][_y + k] += 2\n        ans[_x + k][_y + k] -= 2\n        ans[_x + k][0] -= 1\n        ans[0][_y + k] -= 1\n        ans[_x][0] += 1\n        ans[0][_y] += 1\nprint((np.asarray(ans).cumsum(axis=1).cumsum(axis=0).max()))\n", "import sys\n\n#\u7e26k\u3001\u6a2ak\u306e\u30de\u30b9\u306b\u79fb\u52d5\u3055\u305b\u3066\u8003\u3048\u308b\nn, k = map(int, sys.stdin.readline().strip().split())\nx = []\ny = []\nmx = []\nmy = []\nfor _ in range(n):\n    xx, yy, c = sys.stdin.readline().strip().split()\n    xx = int(xx)\n    yy = int(yy)\n    if c == 'W':\n        xx += k\n    xx %= 2 * k\n    yy %= 2 * k\n    if xx >= k:\n        if yy >= k:\n            x.append(xx - k)\n            y.append(yy - k)\n        else:\n            mx.append(xx - k)\n            my.append(yy)\n    else:\n        if yy >= k:\n            mx.append(xx)\n            my.append(yy - k)\n        else:\n            x.append(xx)\n            y.append(yy)\n\ngraph = [[0 for _ in range(k)] for __ in range(k)]\n\n#\u7d2f\u7a4d\u548c\n#lx + lmx = n\nlx = len(x)\ngraph[0][0] += lx\nfor i in range(lx):\n    graph[x[i]][0] -= 1\n    graph[0][y[i]] -= 1\n    graph[x[i]][y[i]] += 2\n\nlmx = len(mx)\ngraph[0][0] -= lmx\nfor i in range(lmx):\n    graph[mx[i]][0] += 1\n    graph[0][my[i]] += 1\n    graph[mx[i]][my[i]] -= 2\n\nfor i in graph:\n    for j in range(k-1):\n        i[j+1] += i[j]\n\nfor i in range(k):\n    for j in range(k-1):\n        graph[j+1][i] += graph[j][i]\n\n#\u6700\u5927\u5024\u3001\u6700\u5c0f\u5024\u3092\u53d6\u5f97\nbig = max([max(i) for i in graph]) + lmx\nsmall = min([min(i) for i in graph]) - lx\n\nif big + small >= 0:\n    print(big)\nelse:\n    print(-small)", "n, k = map(int, input().split())\nfavor = [tuple(input().split()) for _ in range(n)]\nsquare = [[0 for _ in range(k)] for _ in range(k)]\ninitscore = 0\nfor xc, yc, c in favor:\n    x = int(xc)\n    y = int(yc)\n    x %= 2*k\n    y %= 2*k\n    if (x in range(k) and y in range(k)) or (x in range(k, 2*k) and y in range(k, 2*k)):\n        if c == 'B':\n            square[x%k][y%k] += 1\n        else:\n            square[x%k][y%k] -= 1\n            initscore += 1\n    else:\n        if c == 'B':\n            square[x%k][y%k] -= 1\n            initscore += 1\n        else:\n            square[x%k][y%k] += 1\ncum = [[0 for _ in range(k+1)] for _ in range(k+1)]\nfor i in range(k):\n    for j in range(k):\n        cum[i+1][j+1] = cum[i+1][j] + cum[i][j+1] - cum[i][j] + square[i][j]\nmaxscore = 0\nfor i in range(k):\n    for j in range(k):\n        score = cum[i][k] + cum[k][j] - 2*cum[i][j]\n        maxscore = max(maxscore, max(cum[k][k] - score, score))\nprint(maxscore + initscore)", "import numpy as np\nN, K, *XYC = open(0).read().split()\nN = int(N)\nK = int(K)\nboard = np.zeros((4 * K + 1, 4 * K + 1), dtype=np.int64)\nfor x, y, c in zip(XYC[::3], XYC[1::3], XYC[2::3]):\n    x = int(x)\n    y = int(y)\n    if c == 'W':\n        x += K\n    x = x % (2 * K)\n    y = y % (2 * K)\n    board[x, y] += 1\n    board[(x + K) % (2 * K), (y + K) % (2 * K)] += 1\nboard[1 + 2 * K:, 1 + 2 * K:] = board[:2 * K, :2 * K]\nboard[1:1 + 2 * K, 1 + 2 * K:] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1 + 2 * K:, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1:1 + 2 * K, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[0, :] = 0\nboard[:, 0] = 0\nfor j in range(1, 3 * K):\n    board[:, j] += board[:, j - 1]\nfor j in range(1, 3 * K):\n    board[j, :] += board[j - 1, :]\nans = np.max(board[K:3 * K, K:3 * K] + board[:2 * K, :2 * K] -\n             board[:2 * K, K:3 * K] - board[K:3 * K, :2 * K])\nprint(ans)\n", "from subprocess import*\ncall(('julia','-e',\"\"\"\nconst lines=readlines()\ninput()=shift!(lines)\nint(s)=parse(Int32,s)\nintLine()=map(int,split(input()))\nfunction nextLine(k)\n    x,y,c=split(input())\n    int(x)%2k+1,(int(y)+(c==\"W\")k)%2k+1\nend\nfunction solve(k,g)\n    m=0\n    for i=1:2k,j=1:2k\n        a=0\n        for x=-1:2,y=-1:2\n            (x+y)%2!=0&&continue\n            v,w=i+x*k,j+y*k\n            v>0<w&&(a+=g[min(2k,v)][min(2k,w)])\n            v>k&&w>0&&(a-=g[min(2k,v-k)][min(2k,w)])\n            w>k&&v>0&&(a-=g[min(2k,v)][min(2k,w-k)])\n            v>k<w&&(a+=g[min(2k,v-k)][min(2k,w-k)])\n        end\n        m=max(m,a)\n    end\n    m\nend\nfunction main()\n    n,k=intLine()\n    g=Array{Int32,1}[[0for j=1:2k]for i=1:2k]\n    for i=1:n\n        x,y=nextLine(k)\n        g[x][y]+=1\n    end\n    println(solve(k,cumsum(map(cumsum,g))))\nend\nmain()\n\"\"\"))", "N,K = list(map(int,input().split()))\ncum = [[0]*(2*K+1) for i in range(2*K+1)]\n\ndef vertex(z):\n    if z < K:\n        return [(0,z+1),(z+K+1,2*K)]\n    else:\n        return [(z-K+1,z+1)]\n\nfor i in range(N):\n    x,y,c = input().split()\n    x = int(x)\n    y = int(y)\n    x %= 2*K\n    if c == 'B':\n        y %= 2*K\n    else:\n        y += K\n        y %= 2*K\n\n    for d in [0,K]:\n        for b,t in vertex((y+d)%(2*K)):\n            for l,r in vertex((x+d)%(2*K)):\n                cum[b][l] += 1\n                cum[t][r] += 1\n                cum[b][r] -= 1\n                cum[t][l] -= 1\n\nimport numpy as np\ncum = np.array(cum)\nprint((np.cumsum(np.cumsum(cum,axis=0),axis=1).max()))\n", "# D - Checker\n\nN, K = map(int, input().split())\ng = [[0]*K for _ in range(K)] # PDF\u89e3\u8aac\u901a\u308a2K*2K\u7bc4\u56f2\u3067\u3084\u308b\u3068\u5e02\u677e\u6a21\u69d8\u306e\u51e6\u7406\u304c\u5927\u5909\u306a\u306e\u3067K*K\u306e\u7bc4\u56f2\u3067\u8a08\u7b97\n\nfor _ in range(N):\n    x, y, c = input().split()\n    x = int(x)\n    y = int(y)\n    tmp = (x//K + y//K) % 2\n    x %= K\n    y %= K\n    if (tmp == 0 and c == \"B\") or (tmp == 1 and c == \"W\"):\n        g[x][y] += 1\n    else:\n        g[x][y] -= 1 # \u767d\u5e0c\u671b\u306e\u70b9\u3092-1\u3067\u8a18\u9332\u3059\u308b\n\nfor i in range(K):\n    for j in range(1,K):\n        g[i][j] += g[i][j-1]\n\nfor i in range(1,K):\n    for j in range(K):\n        g[i][j] += g[i-1][j]\n\n# [i,j]\u3092\u9ed2\u7bc4\u56f2\u306e\u5de6\u4e0b\u306e\u70b9\u3068\u3059\u308b\u3002[0,i] * [0,j] \u306e\u7bc4\u56f2\u307e\u305f\u306f[i+1,K-1] * [j+1,K-1]\u306e\u7bc4\u56f2\u306b\u3042\u308b\u9ed2\u5e0c\u671b\u70b9\u306e\u500b\u6570\u3092\u8db3\u3057\u3001\u767d\u5e0c\u671b\u306e\u70b9\u306e\u500b\u6570\u3092\u5f15\u304f\n# \u4e0a\u8a18\u7bc4\u56f2\u5916\u306b\u3042\u308b\u767d\u5e0c\u671b\u306e\u70b9\u306e\u500b\u6570\u3092\u8db3\u3057\u3001\u9ed2\u5e0c\u671b\u306e\u70b9\u306e\u500b\u6570\u3092\u5f15\u304f\nans = 0\nfor i in range(K):\n    for j in range(K):\n        n_satisfied = g[-1][-1] -2*(g[-1][j] + g[i][-1]) + 4*g[i][j]\n        ans = max(ans, (N + n_satisfied)//2, (N - n_satisfied)//2) # ((\u5e0c\u671b\u901a\u308a\u306e\u70b9 + \u5e0c\u671b\u901a\u308a\u3067\u306a\u3044\u70b9) + (\u5e0c\u671b\u901a\u308a\u306e\u70b9 - \u5e0c\u671b\u901a\u308a\u3067\u306a\u3044\u70b9))//2\n\nprint(ans)", "import numpy as np\n\ndef getBoundary(p, k, k2):\n    if p - k + 1 >= 0:\n        return [(p - k + 1, p + 1)]\n    else:\n        return [(0, p + 1), ((p - k + 1) % k2, k2)]\n\nn, k = list(map(int, input().strip().split()))\nk2 = k * 2\nb = [[0 for i in range(k2 + 1)] for j in range(k2 + 1)]\n\nfor i in range(n):\n    x_str, y_str, c_str = input().strip().split()\n    x = int(x_str) % k2\n    y = (int(y_str) + (c_str == 'B') * k) % k2\n    for xb, xe in getBoundary(x % k2, k, k2):\n        for yb, ye in getBoundary(y % k2, k, k2):\n            b[xb][yb] += 1\n            b[xb][ye] -= 1\n            b[xe][yb] -= 1\n            b[xe][ye] += 1\n    for xb, xe in getBoundary((x + k) % k2, k, k2):\n        for yb, ye in getBoundary((y + k) % k2, k, k2):\n            b[xb][yb] += 1\n            b[xb][ye] -= 1\n            b[xe][yb] -= 1\n            b[xe][ye] += 1\n\narr_b = np.array(b)\nfor i in range(k2):\n    arr_b[i + 1] += arr_b[i]\nfor j in range(k2):\n    arr_b[:, j + 1] += arr_b[:, j]\nprint((arr_b.max()))\n", "import numpy as np\nN, K = list(map(int, input().split()))\nub = K * 2\nb = [[0 for j in range(ub + 1)] for i in range(ub + 1)]\nADD = {\"B\": 0, \"W\": K}\n\n\ndef create_bound(p, K, ub):\n    if p - K + 1 >= 0:\n        return [(p - K + 1, p + 1)]\n    else:\n        return [(0, p + 1), ((p - K + 1) % ub, ub)]\n\n\nfor i in range(N):\n    x, y, c = input().split()\n    nx = int(x) % ub\n    ny = (int(y) + ADD[c]) % ub\n    for add in [0, K]:\n        for xlb, xub in create_bound((nx + add) % ub, K, ub):\n            for ylb, yub in create_bound((ny + add) % ub, K, ub):\n                b[xlb][ylb] += 1\n                b[xlb][yub] -= 1\n                b[xub][ylb] -= 1\n                b[xub][yub] += 1\n\nb_arr = np.array(b)\nfor i in range(ub):\n    b_arr[i + 1, :] += b_arr[i, :]\nfor j in range(ub):\n    b_arr[:, j + 1] += b_arr[:, j]\nprint((b_arr.max()))\n", "n, k = map(int, input().split())\ns = [[0] * k for _ in range(2 * k + 1)]\nfor _ in range(n):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    x -= (x // (2 * k)) * (2 * k)\n    y -= (y // (2 * k)) * (2 * k)\n    if x >= k and y >= k:\n        x -= k\n        y -= k\n    elif y >= k:\n        x += k\n        y -= k\n    if c == \"B\":\n        if x >= k:\n            x -= k\n        else:\n            x += k\n    s[x + 1][y] += 1\nfor i in range(2 * k):\n    for j in range(k):\n        s[i + 1][j] += s[i][j]\nans = 0\nfor i in range(k):\n    cnt = 0\n    for j in range(k):\n        cnt += (s[i + k][j] - s[i][j])\n    ans = max(ans, cnt, n - cnt)\n    for j in range(k):\n        cnt -= (2 * (s[i + k][j] - s[i][j]))\n        cnt += s[2 * k][j]\n        ans = max(ans, cnt, n - cnt)\nprint(ans)", "from numpy import*\nN,K=map(int,input().split())\nm=zeros((3*K,3*K),dtype=int)\nL=2*K\no=0\nfor _ in [0]*N:\n x,y,c=input().split()\n x,y=int(x)%L,int(y)%L\n t=c=='W'\n m[x,y]+=2*t-1\n o+=t\nfor _ in [0,0]:\n m[L:]=m[:K]\n m=cumsum(m,axis=0)\n m[:L]-=m[K:]\n m=m.T\nm=m[:L,:L]\nprint(o-int((m+roll(roll(m,K,axis=0),K,axis=1)).min()))", "import sys\nimport numpy as np\nfrom collections import Counter\n\nread = sys.stdin\n\nN, K = list(map(int, read.readline().split()))\nk = 2 * K\nxyc = np.array(read.read().split(), np.str).reshape(-1, 3)\nx = xyc[:, 0].astype(int)\ny = xyc[:, 1].astype(int)\nc = xyc[:, 2]\n\nx = np.where(c == 'B', x - K, x)\nx %= k\ny %= k\n\n'''\n# grid[[1,2],[1,2]]+=1 \u3068\u3057\u3066\u3082grid[1,2]=1\u3067\u3042\u308a\u91cd\u8907\u306f\u8003\u616e\u3055\u308c\u306a\u3044\u3002\n# unique\u3092\u4f7f\u3063\u3066(x,y)\u306e\u91cd\u8907\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n# return_count\u306fver1.9\u304b\u3089\u3060\u3063\u305f\u30fb\u30fb\u30fb \u30c0\u30e1\u3058\u3083\u3093\nxy, cnt = np.unique(x + y * 10000, return_counts=True)\nx = xy % 10000\ny = xy // 10000\n'''\nxy = Counter(list(zip(x, y)))\ncnt = np.array(list(xy.values()), np.int64)\nxy = np.array(list(xy.keys()), np.int64)\nx = xy[:, 0]\ny = xy[:, 1]\n\ngrid = np.zeros((3 * K, 3 * K), np.int64)\ngrid[x, y] += cnt\ngrid[x + K, y + K] += cnt\ngrid[x + K, y] -= cnt\ngrid[x, y + K] -= cnt\nnp.cumsum(grid, axis=0, out=grid)\nnp.cumsum(grid, axis=1, out=grid)\n\np1 = grid[:K, :K] + grid[k:, k:] + grid[K:k, K:k] + grid[k:, :K] + grid[:K, k:]\np2 = grid[K:k, :K] + grid[K:k, k:] + grid[:K, K:k] + grid[k:, K:k]\nprint((max(p1.max(), p2.max())))\n", "import numpy as np\nN, K = list(map(int, input().split()))\nmod = 2*K\nfield = [[0]*(2*K+1) for _ in range(2*K+1)]\n\ndef gen_pattern(x):\n    if x < K-1:\n        return [[0, x+1], [x+K+1, 2*K]]\n    else:\n        return [[x-K+1, x+1]]\n\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'W':\n        y += K\n    x %= mod\n    y %= mod\n    for tmp in [0, K]:\n        for l, r in gen_pattern((x+tmp) % mod):\n            for b, t in gen_pattern((y+tmp) % mod):\n                field[l][b] += 1\n                field[l][t] -= 1\n                field[r][b] -= 1\n                field[r][t] += 1\n\nprint((np.max(np.cumsum(np.cumsum(field, axis=0), axis=1))))\n", "import numpy as np\nimport io\n\nnime, mike = map(int, input().split())\nmod = 2*mike\narray = [[0]*(2*mike+1) for _ in range(2*mike+1)]\n\ndef gen_pattern(x):\n    if x < mike-1:\n        return [[0, x+1], [x+mike+1, 2*mike]]\n    else:\n        return [[x-mike+1, x+1]]\n\nfor _ in range(nime):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'W':\n        y += mike\n    x %= mod\n    y %= mod\n    for tmp in [0, mike]:\n        for l, r in gen_pattern((x+tmp) % mod):\n            for b, t in gen_pattern((y+tmp) % mod):\n                array[l][b] += 1\n                array[l][t] -= 1\n                array[r][b] -= 1\n                array[r][t] += 1\nprint(np.max(np.cumsum(np.cumsum(array, axis=0), axis=1)))", "import numpy as np\n \nN,K=map(int, input().split())\np=[list(input().split()) for _ in range(N)]\ngrid = [[[0]*2 for j in range(K)] for i in range(K)]\n\nfor i in range(N):\n  x, y, c = p[i]\n  x, y = int(x), int(y)\n  mx, my = x%K, y%K\n  f = False\n  if (x//K)%2 != (y//K)%2:\n    f = not f\n  if c == \"W\":\n    f = not f\n  if f:\n    grid[0][0][0] += 1\n    grid[mx][0][0] -= 1\n    grid[0][my][0] -= 1\n    grid[mx][my][0] += 2\n  else:\n    grid[0][my][0] += 1\n    grid[mx][0][0] += 1\n    grid[mx][my][0] -= 2\n  f = False\n  if (x//K)%2 != (y//K)%2:\n    f = not f\n  if c == \"B\":\n    f = not f\n  if f:\n    grid[0][0][1] += 1\n    grid[mx][0][1] -= 1\n    grid[0][my][1] -= 1\n    grid[mx][my][1] += 2\n  else:\n    grid[0][my][1] += 1\n    grid[mx][0][1] += 1\n    grid[mx][my][1] -= 2\ngrid = np.array(grid)\ngrid = np.cumsum(grid, axis=0)\ngrid = np.cumsum(grid, axis=1)\nprint(int(np.max(grid)))", "n, k = map(int, input().split())\n\nxy = []\nF = [[0]*(2*k+1) for _ in range(2*k+1)]\nfor __ in range(n):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'B':\n        y += k\n    x %= 2*k\n    y %= 2*k\n\n    for _ in range(2):\n        x = (x+k)%(2*k)\n        y = (y+k)%(2*k)\n        #\u53f3\u4e0a\n        F[y+1][x+1] += 1\n        if x-k >= 0 and y-k >= 0:\n            #\u666e\u901a\u306e\u5de6\u4e0a\u3068\u5de6\u4e0a\u53f3\u4e0b\n            F[y+1][x-k+1] -= 1\n            F[y-k+1][x+1] -= 1\n            F[y-k+1][x-k+1] += 1\n        elif y-k >= 0:\n            #\u7279\u6b8a\u306a\u5de6\n            F[y-k+1][0] += 1\n            F[y+1][0] -= 1\n            F[y-k+1][x+1] -= 1\n            #\u7279\u6b8a\u306a\u5de6\u4e0a\u3068\u5de6\u4e0b\n            F[y-k+1][x+k+1] += 1\n            F[y+1][x+k+1] -= 1\n        elif x-k >= 0:\n            F[0][x-k+1] += 1\n            F[0][x+1] -= 1\n            F[y+1][x-k+1] -= 1\n\n            F[y+k+1][x-k+1] += 1\n            F[y+k+1][x+1] -=1\n        else:\n            F[0][x+1] -= 1\n            F[y+1][0] -= 1\n            F[0][0] += 1\n            #\u5de6\u4e0a\n            F[y+k+1][0] += 1\n            F[y+k+1][x+1] -= 1\n            #\u53f3\u4e0b\n            F[0][x+k+1] += 1\n            F[y+1][x+k+1] -= 1\n            #\u53f3\u4e0a\n            F[y+k+1][x+k+1] += 1\n    if __ == 0:\n        pass\n        # break\nans = 0\nm = 3\n\nfrom numpy import array\nF = array(F)\nfor i in range(0, 2*k):\n    F[:, i+1] += F[:, i]\nfor i in range(0, 2*k):\n    F[i+1, :] += F[i, :]\nprint(F[:2*k, :2*k].max())", "import numpy as np\n\n\ndef solve(string):\n    n, k, *xyc = string.split()\n    k = int(k)\n    l = 2 * int(k)\n    xy = [(int(x) % l, int(y) % l) if c == \"W\" else (int(x) % l, (int(y) + k) % l)\n          for x, y, c in zip(xyc[::3], xyc[1::3], xyc[2::3])]\n    ans = [[0 for j in range(l + 0)] for i in range(l + 0)]\n    for _x, _y in xy:\n        if (_x - k + 0.5) * (_y - k + 0.5) > 0:\n            _x %= k\n            _y %= k\n            ans[_x][_y] += 2\n            ans[_x + k][_y] -= 2\n            ans[_x][_y + k] -= 2\n            ans[_x + k][_y + k] += 2\n            ans[_x + k][0] += 1\n            ans[0][_y + k] += 1\n            ans[0][0] += 1\n            ans[_x][0] -= 1\n            ans[0][_y] -= 1\n        else:\n            _x %= k\n            _y %= k\n            ans[_x][_y] -= 2\n            ans[_x + k][_y] += 2\n            ans[_x][_y + k] += 2\n            ans[_x + k][_y + k] -= 2\n            ans[_x + k][0] -= 1\n            ans[0][_y + k] -= 1\n            ans[_x][0] += 1\n            ans[0][_y] += 1\n    return str(np.asarray(ans).cumsum(axis=1).cumsum(axis=0).max())\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    print((solve('{} {}\\n'.format(n, m) + '\\n'.join([input() for _ in range(n)]))))\n\n__starting_point()", "N, K = map(int, input().split())\nimport numpy as np\n#\u5bfe\u79f0\u6027\u3092\u5229\u7528\u3057\u3066\u70b9\u3092\u5358\u4f4d\u683c\u5b50K*2K\u306b\u5727\u7e2e\n_2K, _4K = 2*K, 4*K\nshape = (_2K+1,_4K+1) #\u5f8c\u3067K*2K\u306b\u5727\u7e2e\nGrd = np.zeros(shape,dtype='int64')\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'B':\n        x, y = x%_2K, y%_2K\n    else: \n        x, y = (x+K)%_2K, y%_2K\n    #\u70b9\u306b\u3064\u3044\u3066\u30012K*2K -> K*2K\u306e\u8abf\u6574\u3002\u6b21\u306f\u7b49\u4fa1\u3001(K+i,K+j)==(i,j),(i,K+j)==(i+K,j)\n    if x >= K and y >= K: x -= K; y -= K\n    if x < K and y >= K: x += K; y -= K\n    #\u3053\u306e\u70b9\u304cK*K\u306e\u9ed2\u8272\u6b63\u65b9\u5f62\u5185\u306b\u5165\u308b\u3002\u6b63\u65b9\u5f62\u3092\u7279\u5fb4\u3065\u3051\u308b\u306b\u306f\u5de6\u4e0b\u306e\u5ea7\u6a19\u3060\u3051\u3067\u5341\u5206\u3002\n    #\u21d2\uff11\u3064\u306e\u70b9\u306fK**2\u500b\u306e\u5857\u308a\u65b9\u306b+1\u306e\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u3002\n    #\u6bce\u56de2K**2\u306e\u30de\u30b9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068TLE\u3059\u308b\u305f\u3081\u3001\u3042\u3068\u3067\u7d2f\u7a4d\u548c(\u8a08\u7b97\u91cfO(K**2))\u3092\u53d6\u3063\u305f\u6642\u306b+1\u3055\u308c\u308b\u7bc4\u56f2\u304c\u7b49\u3057\u304f\u306a\u308b\u3088\u3046\u306b\u8abf\u6574\u3059\u308b(\u96a3\u63a5\u5dee\u5206\u3092\u53d6\u308b)\u3002\n    #K=3\u306e\u5834\u5408\n    #[[1 1 1 0 0 0]    [[ 1 0 0 -1 0 0  0]\n    # [1 1 1 0 0 0]     [ 0 0 0  0 0 0  0]\n    # [1 1 1 0 0 0]  => [ 0 0 0  0 0 0  0]\n    # [0 0 0 0 0 0]     [-1 0 0  1 0 0  0]\n    # [0 0 0 0 0 0]     [ 0 0 0  0 0 0  0]\n    # [0 0 0 0 0 0]]    [ 0 0 0  0 0 0  0]\n    #                   [ 0 0 0  0 0 0  0]\n    \n    Grd[y, x] += 1\n    Grd[y+K, x+K] += 1\n    Grd[y+K, x] += -1\n    Grd[y, x+K] += -1\ndel x, y, c\n\n#2\u91cd\u7d2f\u7a4d\u548c\u8a08\u7b97\nGrd = Grd.cumsum(axis=1).cumsum(axis=0)\n#2K*4K -> K*2K\u3078\u5727\u7e2e\nGrd = Grd[:,:_2K] +Grd[:,_2K:_4K]\nGrd = Grd[:K,:] +np.concatenate((Grd[K:_2K,K:_2K],Grd[K:_2K,:K]),axis=1) \n\nans = Grd.max()\nprint(ans)", "import sys\nimport numpy as np\ndef main():\n    input = sys.stdin.readline\n    def gen_pattern(x):\n        if x < K-1:\n            return [[0, x+1], [x+K+1, 2*K]]\n        else:\n            return [[x-K+1, x+1]]\n    def inputs():\n        return [int(x) for x in input().split()]\n    def inputstr():\n        return list(input().split())\n    N,K = inputs()\n    BB = [[0]*(2*K+1) for _ in range(2*K+1)]\n    for i in range(N):\n        x,y,c = inputstr()\n        if c==\"W\":\n            y = int(y)+K\n        x = int(x)%(2*K)\n        y = int(y)%(2*K)\n        #BB[x,y] += 1\n        for shift in [0,K]:\n            for b,t in gen_pattern((y+shift)%(2*K)):\n                for l,r in gen_pattern((x+shift)%(2*K)):\n                    BB[b][l] +=1\n                    BB[b][r] -=1\n                    BB[t][l] -=1\n                    BB[t][r] +=1\n    ans = (np.max(np.cumsum(np.cumsum(BB, axis=1), axis=0)))\n    #print(BB)\n    print((int(ans)))\nmain()\n", "import numpy as np\nN, K = list(map(int, input().split()))\nub = K * 2\nb = [[0 for j in range(ub + 1)] for i in range(ub + 1)]\nADD = {\"B\": 0, \"W\": K}\n\ndef create_bound(p, K, ub):\n\tif p - K + 1 >= 0:\n\t\treturn [(p - K + 1, p + 1)]\n\telse:\n\t\treturn [(0, p + 1), ((p - K + 1) % ub, ub)]\n\nfor i in range(N):\n\tx, y, c = input().split()\n\tnx = int(x) % ub\n\tny = (int(y) + ADD[c]) % ub\n\tfor add in [0, K]:\n\t\tfor xlb, xub in create_bound((nx + add) % ub, K, ub):\n\t\t\tfor ylb, yub in create_bound((ny + add) % ub, K, ub):\n\t\t\t\tb[xlb][ylb] += 1\n\t\t\t\tb[xlb][yub] -= 1\n\t\t\t\tb[xub][ylb] -= 1\n\t\t\t\tb[xub][yub] += 1\n\nb_arr = np.array(b)\nfor i in range(ub):\n\tb_arr[i + 1, :] += b_arr[i, :]\nfor j in range(ub):\n\tb_arr[:, j + 1] += b_arr[:, j]\nprint((b_arr.max()))\n", "import numpy as np\n\nN, K = list(map(int, input().split()))\nB = np.zeros((2 * K, 2 * K), np.int32)\n\nfor _ in range(N):\n    x, y, c = input().split()\n    if c == \"B\":\n        B[int(x) % (2 * K)][int(y) % (2 * K)] += 1\n    else:\n        B[int(x) % (2 * K)][(int(y) + K) % (2 * K)] += 1\n\nSB = np.zeros((4 * K + 1, 4 * K + 1), np.int32)\n\nSB[0*K+1:2*K+1, 0*K+1:2*K+1] = B\nSB[0*K+1:2*K+1, 2*K+1:4*K+1] = B\nSB[2*K+1:4*K+1, 0*K+1:2*K+1] = B\nSB[2*K+1:4*K+1, 2*K+1:4*K+1] = B\n\nnp.cumsum(SB, 0, out=SB)\nnp.cumsum(SB, 1, out=SB)\n\nans = 0\ncand = SB[1*K:3*K+1, 1*K:3*K+1].copy()\ncand -= SB[0*K:2*K+1, 1*K:3*K+1]\ncand -= SB[1*K:3*K+1, 0*K:2*K+1]\ncand += SB[0*K:2*K+1, 0*K:2*K+1]\ncand += SB[2*K:4*K+1, 2*K:4*K+1]\ncand -= SB[1*K:3*K+1, 2*K:4*K+1]\ncand -= SB[2*K:4*K+1, 1*K:3*K+1]\ncand += SB[1*K:3*K+1, 1*K:3*K+1]\nans = np.max(cand)\n\nprint(ans)\n", "import numpy as np\n\nN, K = map(int, input().split())\nK2 = 2 * K\nMij = [[0 for _ in range(K2 + 1)] for _ in range(K2 + 1)]\n\n\ndef imos(x1, y1, x2, y2):\n    Mij[y1][x1] += 1\n    Mij[y2][x2] += 1\n    Mij[y2][x1] -= 1\n    Mij[y1][x2] -= 1\n\nfor _ in range(N):\n    ls = input().split()\n    x = int(ls[0]) % K2\n    y = int(ls[1]) % K2\n    if ls[2] == \"B\":\n        y = (y + K) % K2\n    x_ = x % K\n    y_ = y % K\n\n    if (x < K and y < K) or (K <= x and K <= y):\n        imos(0, 0, x_ + 1, y_ + 1)\n        imos(x_ + K + 1, 0, K2, y_ + 1)\n        imos(0, y_ + K + 1, x_ + 1, K2)\n        imos(x_ + K + 1, y_ + K + 1, K2, K2)\n        imos(x_ + 1, y_ + 1, x_ + K + 1, y_ + K + 1)\n    else:\n        imos(x_ + 1, 0, x_ + K + 1, y_ + 1)\n        imos(x_ + 1, y_ + K + 1, x_ + K + 1, K2)\n        imos(0, y_ + 1, x_ + 1, y_ + K + 1)\n        imos(x_ + K + 1, y_ + 1, K2, y_ + K + 1)\n\nMij = np.array(Mij)\nfor x in range(K2):\n    Mij[:, x + 1] += Mij[:, x]\nfor y in range(K2):\n    Mij[y + 1, :] += Mij[y, :]\n\nprint(Mij.max())", "n,k = map(int, input().split())\ng = [[0]*(k+1) for _ in range(k+1)]\nans,b = 0,0\nfor _ in range(n):\n  x,y,c = input().split()\n  x,y = int(x), int(y)\n  d = x//k + y//k\n  x %= k; y %= k\n  if (c == 'W') ^ (d%2):\n    g[x+1][y+1] += 1\n  else:\n    g[x+1][y+1] -= 1\n    b += 1\nfor i in range(k):\n  for j in range(k):\n    g[i+1][j+1] += g[i][j+1] + g[i+1][j] - g[i][j]\nfor i in range(k):\n  for j in range(k):\n    cur = g[k][k] - g[k][j] - g[i][k] + g[i][j]*2 + b\n    if cur > ans: ans = cur\n    if n-cur > ans: ans = n-cur\nprint(ans)", "# python 3.4.3\nimport sys\ninput = sys.stdin.readline\nimport numpy as np\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\ndef sum2d(i1,j1,i2,j2):\n    A[i1][j1] += 1\n    A[i1][j2] -= 1\n    A[i2][j1] -= 1\n    A[i2][j2] += 1\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,K = list(map(int,input().split()))\nXYC = [list(input().split()) for _ in range(N)]\n\nA = [[0 for _ in range(K*2+1)] for _ in range(K*2+1)]\n\nfor x,y,c in XYC:\n    # \u767d\u306f\u305d\u306e\u307e\u307e, \u9ed2\u306fx\u8ef8\u65b9\u5411\u306bK\u305a\u3089\u3057\u3066\u767d\u3068\u3057\u3066\u6271\u3046\n    i = (int(x) if c==\"W\" else int(x)+K) % (K*2)\n    j = int(y) % (K*2)\n    i0 = i%K\n    j0 = j%K\n\n    # \u5206\u5272\u533a\u753b\u306e\u5de6\u4e0b\u304c\u767d\u306e\u5834\u5408 (\u767d\u306f5\u7b87\u6240)\n    #   a * b\n    #   * c *\n    #   d * e\n    if (i<K and j<K) or (i>=K and j>=K):\n        sum2d(0,0,i0,j0) # (a)\u5de6\u4e0a\n        sum2d(i0+K,0,K*2,j0) # (b)\u53f3\u4e0a\n        sum2d(i0,j0,i0+K,j0+K) # (c)\u771f\u3093\u4e2d\n        sum2d(0,j0+K,i0,K*2) # (d)\u5de6\u4e0b\n        sum2d(i0+K,j0+K,K*2,K*2) # (e)\u53f3\u4e0b\n\n    # \u5206\u5272\u533a\u753b\u306e\u5de6\u4e0b\u304c\u9ed2\u306e\u5834\u5408 (\u767d\u306f4\u7b87\u6240)\n    #   * a *\n    #   b * c\n    #   * d *\n    else:\n        sum2d(i0,0,i0+K,j0) # (a)\u4e0a\n        sum2d(0,j0,i0,j0+K) # (b)\u5de6\n        sum2d(i0+K,j0,K*2,j0+K) # (c)\u53f3\n        sum2d(i0,j0+K,i0+K,K*2) # (d)\u4e0b\n \n# 2\u6b21\u5143\u7d2f\u7a4d\u548c\nAA = np.array(A)\nfor i in range(K*2):\n    AA[i+1, :] += AA[i, :]\nfor j in range(K*2):\n    AA[:, j+1] += AA[:, j]\n \nprint((AA.max()))\n", "n, k = map(int, input().split())\nX, Y, C = [], [], []\nfor _ in range(n):\n  x, y, c = input().split()\n  X.append(int(x)%(2*k))\n  Y.append(int(y)%(2*k))\n  C.append(c==\"B\")\nG = [[0]*k for _ in range(k)]\ncnt = 0\nfor x, y, c in zip(X, Y, C):\n  if (x >= k and y < k) or (x < k and y >= k):\n    x += k\n    c ^= 1\n  x %= k\n  y %= k\n  G[x][y] += (-1)**c\n  cnt += c\nfor i in range(k):\n  for j in range(k-1):\n    G[i][j+1] += G[i][j]\nfor j in range(k):\n  for i in range(k-1):\n    G[i+1][j] += G[i][j]\nans = 0\nfor i in range(k):\n  for j in range(k):\n    temp = G[k-1][k-1] - G[i][k-1] - G[k-1][j] + G[i][j]*2 + cnt\n    ans = max(ans, temp, n-temp)\nprint(ans)", "import sys\nimport numpy as np\nfrom collections import Counter\n\nread = sys.stdin\n\nN, K = list(map(int, read.readline().split()))\nk = 2 * K\nxyc = np.array(read.read().split(), np.str).reshape(-1, 3)\nx = xyc[:, 0].astype(int)\ny = xyc[:, 1].astype(int)\nc = xyc[:, 2]\n\nx[c == 'B'] -= K\nx %= k\ny %= k\n\n'''\n# grid[[1,1],[2,2]]+=1 \u3068\u3057\u3066\u3082grid[1,2]=1\u3067\u3042\u308a\u91cd\u8907\u306f\u8003\u616e\u3055\u308c\u306a\u3044\u3002\n# unique\u3092\u4f7f\u3063\u3066(x,y)\u306e\u91cd\u8907\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n# return_count\u306fver1.9\u304b\u3089\u3060\u3063\u305f\u30fb\u30fb\u30fb \u30c0\u30e1\u3058\u3083\u3093\nxy, cnt = np.unique(x + y * 10000, return_counts=True)\nx = xy % 10000\ny = xy // 10000\n'''\nxy = Counter(list(zip(x, y)))\ncnt = np.array(list(xy.values()), np.int64)\nxy = np.array(list(xy.keys()), np.int64)\nx = xy[:, 0]\ny = xy[:, 1]\n\ngrid = np.zeros((3 * K, 3 * K), np.int64)\ngrid[x, y] += cnt\ngrid[x + K, y + K] += cnt\ngrid[x + K, y] -= cnt\ngrid[x, y + K] -= cnt\nnp.cumsum(grid, axis=0, out=grid)\nnp.cumsum(grid, axis=1, out=grid)\n\np1 = grid[:K, :K] + grid[k:, k:] + grid[K:k, K:k] + grid[k:, :K] + grid[:K, k:]\np2 = grid[K:k, :K] + grid[K:k, k:] + grid[:K, K:k] + grid[k:, K:k]\nprint((max(p1.max(), p2.max())))\n", "N, K = map(int, input().split())\nimport numpy as np\n#\u5bfe\u79f0\u6027\u3092\u5229\u7528\u3057\u3066\u70b9\u3092\u5358\u4f4d\u683c\u5b50K*2K\u306b\u5727\u7e2e\n_2K, _4K = 2*K, 4*K\nshape = (_2K,_4K) #\u5f8c\u3067K*2K\u306b\u5727\u7e2e\nGrd = np.zeros(shape, dtype='int64')\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'B':\n        x, y = x%_2K, y%_2K\n    else: \n        x, y = (x+K)%_2K, y%_2K\n    #\u70b9\u306b\u3064\u3044\u3066\u30012K*2K -> K*2K\u306e\u8abf\u6574\u3002\u6b21\u306f\u7b49\u4fa1\u3001(K+i,K+j)\u3068(i,j),(i,K+j)\u3068(i+K,j)\n    if x >= K and y >= K: x -= K; y -= K\n    if x < K and y >= K: x += K; y -= K\n    #\u3053\u306e\u70b9\u304cK*K\u306e\u9ed2\u8272\u6b63\u65b9\u5f62\u5185\u306b\u5165\u308b\u3002\u6b63\u65b9\u5f62\u3092\u7279\u5fb4\u3065\u3051\u308b\u306b\u306f\u9802\u70b9\u306e\u5ea7\u6a19\uff11\u3064\u3060\u3051\u3067\u5341\u5206\u3002\n    #\u21d2\uff11\u3064\u306e\u70b9\u306fK*K\u500b\u306e\u5857\u308a\u65b9\u306b+1\u306e\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u3002\n    #\u6bce\u56deK**2\u306e\u30de\u30b9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068TLE\u3059\u308b\u305f\u3081\u3001\u5f8c\u3067\u7d2f\u7a4d\u548c(\u8a08\u7b97\u91cfO(K**2))\u3092\u53d6\u3063\u305f\u6642\u306b+1\u3055\u308c\u308b\u7bc4\u56f2\u304c\u7b49\u3057\u304f\u306a\u308b\u3088\u3046\u306b\u8abf\u6574\u3059\u308b(\u96a3\u63a5\u5dee\u5206\u3092\u53d6\u308b)\u3002\n    #K=3\u306e\u5834\u5408\n    #[[1 1 1 0 0 0]    [[ 1 0 0 -1 0 0 0]\n    # [1 1 1 0 0 0]     [ 0 0 0  0 0 0 0]\n    # [1 1 1 0 0 0]  => [ 0 0 0  0 0 0 0]\n    # [0 0 0 0 0 0]     [-1 0 0  1 0 0 0]\n    # [0 0 0 0 0 0]     [ 0 0 0  0 0 0 0]\n    # [0 0 0 0 0 0]]    [ 0 0 0  0 0 0 0]\n    #                   [ 0 0 0  0 0 0 0]\n    \n    Grd[y, x] += 1\n    Grd[y+K, x+K] += 1\n    Grd[y+K, x] += -1\n    Grd[y, x+K] += -1\ndel x, y, c\n\n#2\u91cd\u7d2f\u7a4d\u548c\u8a08\u7b97\nGrd = Grd.cumsum(axis=1).cumsum(axis=0)\n#2K*4K -> K*2K\u3078\u5727\u7e2e\nGrd = Grd[:,:_2K] +Grd[:,_2K:_4K]\nGrd = Grd[:K,:] +np.concatenate((Grd[K:_2K,K:_2K],Grd[K:_2K,:K]),axis=1) \n\nans = Grd.max()\nprint(ans)", "import numpy as np\nN, K = list(map(int, input().split()))\nmod = 2*K\n#field = np.zeros((2*K+1, 2*K+1), dtype='i')\nfield = [[0]*(2*K+1) for _ in range(2*K+1)]\n\ndef gen_pattern(x):\n    if x < K-1:\n        return [[0, x+1], [x+K+1, 2*K]]\n    else:\n        return [[x-K+1, x+1]]\n\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'W':\n        y += K\n    x %= mod\n    y %= mod\n    for tmp in [0, K]:\n        for l, r in gen_pattern((x+tmp) % mod):\n            for b, t in gen_pattern((y+tmp) % mod):\n                field[l][b] += 1\n                field[l][t] -= 1\n                field[r][b] -= 1\n                field[r][t] += 1\n\nfield = np.array(field)\nprint((field.cumsum(axis=0).cumsum(axis=1).max()))\n", "import itertools\nimport numpy as np\nN, K, *XYC = open(0).read().split()\nN = int(N)\nK = int(K)\nboard = np.zeros((4 * K + 1, 4 * K + 1), dtype=np.uint16)\nfor x, y, c in zip(XYC[::3], XYC[1::3], XYC[2::3]):\n    x = int(x)\n    y = int(y)\n    if c == 'W':\n        x += K\n    x = x % (2 * K)\n    y = y % (2 * K)\n    board[x, y] += 1\n    board[(x + K) % (2 * K), (y + K) % (2 * K)] += 1\nboard[1 + 2 * K:, 1 + 2 * K:] = board[:2 * K, :2 * K]\nboard[1:1 + 2 * K, 1 + 2 * K:] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1 + 2 * K:, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1:1 + 2 * K, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[0, :] = 0\nboard[:, 0] = 0\nfor j in range(1, 3 * K):\n    board[:, j] += board[:, j - 1]\nfor j in range(1, 3 * K):\n    board[j, :] += board[j - 1, :]\nans = np.max(board[K:3 * K, K:3 * K] + board[:2 * K, :2 * K] -\n             board[:2 * K, K:3 * K] - board[K:3 * K, :2 * K])\nprint(ans)\n", "import numpy as np\nn,k=map(int,input().split())\nm=np.zeros((3*k,3*k),dtype=int)\nl=2*k\no=0\nfor _ in range(n):\n  x,y,c=input().split()\n  x,y=int(x)%l,int(y)%l\n  t=c=='W'\n  m[x,y]+=1-2*t\n  o+=t\nfor _ in range(2):\n  m[l:]=m[:k]\n  m=np.cumsum(m,axis=0)\n  m[:l]=m[k:]-m[:l]\n  m=m.T\nm=m[:l,:l]\nprint(o+(m+np.roll(np.roll(m,k,axis=0),k,axis=1)).max())", "import numpy as np\n\nn, k = list(map(int, input().split()))\nxyc = [list(input().split()) for _ in range(n)]\n\nb = np.zeros((3 * k - 1, 2 * k - 1), np.int64)\n\nfor x, y, c in xyc:\n    x = int(x)\n    y = int(y)\n\n    q, r = divmod(x, k)\n    if q % 2:\n        y += k\n    x = r\n\n    if c == \"W\":\n        y += k\n\n    y %= 2 * k\n\n    b[y][x] += 1\n\nb[:k, k:] = b[k:2*k, :k-1]\nb[k:2*k, k:] = b[:k, :k-1]\nb[2*k:, :] = b[:k-1, :]\n\nb = np.pad(b, (1, 0), \"constant\")\n\nb = np.cumsum(b, axis=0)\nb = np.cumsum(b, axis=1)\n\ncnt = b[k:, k:] - b[k:, :-k] - b[:-k, k:] + b[:-k, :-k]\nans = cnt.max()\nprint(ans)\n", "#(6,6)\u5468\u671f\n#36\u7a2e\u306e\u5e0c\u671b\n\nimport numpy as np\nN,K = list(map(int,input().split()))\nKK = 2*K\nhope = np.zeros((KK,KK),dtype=np.int32)\n\nXYC = [input().split() for _ in range(N)]\n\nfor x,y,c in XYC:\n  x = int(x)\n  y = int(y)\n  if c == 'B':\n    x -= K\n  x %= KK\n  y %= KK\n  hope[x,y] += 1\n# (x,y)\u3092\u5e0c\u671b\u3055\u308c\u305f\u5834\u5408\u3001[x,x+K), [y,y+K)\u306b\u7d42\u70b9\u304c\u3042\u308b\u3079\u304d\n# \u533a\u9593\u306e\u91cd\u306a\u3063\u3066\u308b\u679a\u6570\u3092\u96c6\u8a08\u30021,0,0,-1, cumsum\nA = np.zeros((KK+K,KK+K),dtype=np.int32)\nA[:-K,:-K] = hope[:]\nA[K:,:-K] += -hope[:]\nA[:-K,K:] += -hope[:]\nA[K:,K:] += hope[:]\nA = A.cumsum(axis = 0).cumsum(axis = 1)\n\n# \u5b9f\u8cea\u540c\u3058\u5834\u6240\u3092\u307e\u3068\u3081\u308b\nB = A[:,:KK]\nB[:,:K] += A[:,KK:] #(3K,2K)\nA = B[:KK,:]\nA[:K,:] += B[KK:,:] #(2K,2K)\nB = A[:K,:] #(K,2K)\nB[:,:K] += A[K:,K:]\nB[:,K:] += A[K:,:K]\n\nanswer = B.max()\nprint(answer)\n", "import sys\nimport numpy as np\n\nread=sys.stdin.read\nreadline=sys.stdin.readline\n\ndef main():\n  wb={'W':1,'B':0}\n  n,k=list(map(int,readline().split()))\n  xyc=[l.split() for l in read().splitlines()]\n  xy=[[int(lst[0]) % (2*k),(int(lst[1])+k*wb[lst[2]]) % (2*k)] for lst in xyc]\n  mat=np.zeros((k+1,2*k+1),dtype='int64')\n  cand=np.zeros((k+1,k+1),dtype='int64')\n  for e in xy:\n    f0=e[0]>=k\n    f1=e[1]>=k\n    mat[e[0]-f0*k+1,e[1]+(-1)**f1*f0*k+1]+=1\n  mat=np.cumsum(mat,axis=0)\n  mat=np.cumsum(mat,axis=1)\n  cand=mat[k,2*k]-mat[k,k:2*k+1]+mat[k,:k+1]\\\n       -np.reshape(mat[:k+1,2*k],(k+1,1))+2*mat[:,k:2*k+1]-2*mat[:,:k+1]\n  print((max(np.max(cand),mat[k,2*k]-np.min(cand))))\n  \ndef __starting_point():\n  main()\n  \n  \n  \n\n__starting_point()", "import sys\nimport numpy as np\n\nread = sys.stdin\n\nN, K = list(map(int, read.readline().split()))\nk = 2 * K\nxyc = np.array(read.read().split(), np.str)\nx = xyc[::3].astype(int)\ny = xyc[1::3].astype(int)\nc = xyc[2::3]\n\nx[c == 'B'] -= K\nx %= k\ny %= k\n\ngrid = np.zeros((3 * K, 3 * K), np.int64)\nnp.add.at(grid, (x, y), 1)\nnp.add.at(grid, (x + K, y + K), 1)\nnp.subtract.at(grid, (x + K, y), 1)\nnp.subtract.at(grid, (x, y + K), 1)\nnp.cumsum(grid, axis=0, out=grid)\nnp.cumsum(grid, axis=1, out=grid)\n\np1 = grid[:K, :K] + grid[k:, k:] + grid[K:k, K:k] + grid[k:, :K] + grid[:K, k:]\np2 = grid[K:k, :K] + grid[K:k, k:] + grid[:K, K:k] + grid[k:, K:k]\nprint((max(p1.max(), p2.max())))\n", "ri = lambda: int(input())\nrl = lambda: list(map(int,input().split()))\nrr = lambda N: [ri() for _ in range(N)]\nYN = lambda b: print('YES') if b else print('NO')\nINF = 10**18\n \nN,K=rl()\n \nW = [[0 for _ in range(K+3)] for _ in range(K+3)]\nfor i in range(N):\n    x,y,c=input().split()\n    x = int(x)%(2*K)\n    y = (int(y) if c=='W' else int(y)+K)%(2*K)\n    if (x<K)^(y<K):\n        x %= K\n        y %= K\n        W[0][y+1] += 1\n        W[x+1][y+1] -= 2\n        W[0][K+1] -= 1\n        W[x+1][K+1] += 1\n        W[x+1][0] += 1\n        W[K+1][0] -= 1\n        W[K+1][y+1] += 1\n    else:\n        x %= K\n        y %= K\n        W[0][0] += 1\n        W[x+1][0] -= 1\n        W[0][y+1] -= 1\n        W[x+1][y+1] += 2\n        W[K+1][y+1] -= 1\n        W[x+1][K+1] -= 1\n        W[K+1][K+1] += 1\n \nfor x in range(0,K+2):\n    for y in range(0,K+2):\n        W[x][y] += W[x][y-1]\nfor y in range(0,K+2):\n    for x in range(0,K+2):\n        W[x][y] += W[x-1][y]\n \nans = 0\nfor x in range(K+1):\n    for y in range(K+1):\n        res = W[x][y]\n        ans = max(ans,res,N-res)\n \nprint(ans)", "import itertools\nimport numpy as np\nN, K, *XYC = open(0).read().split()\nN = int(N)\nK = int(K)\nboard = np.zeros((4 * K + 1, 4 * K + 1), dtype=np.uint16)\nfor x, y, c in zip(XYC[::3], XYC[1::3], XYC[2::3]):\n    x = int(x)\n    y = int(y)\n    if c == 'W':\n        x += K\n    x = x % (2 * K)\n    y = y % (2 * K)\n    board[x, y] += 1\n    board[(x + K) % (2 * K), (y + K) % (2 * K)] += 1\nboard[1 + 2 * K:, 1 + 2 * K:] = board[:2 * K, :2 * K]\nboard[1:1 + 2 * K, 1 + 2 * K:] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1 + 2 * K:, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[1:1 + 2 * K, 1:1 + 2 * K] = board[1 + 2 * K:, 1 + 2 * K:]\nboard[0, :] = 0\nboard[:, 0] = 0\nfor j in range(1, 1 + 4 * K):\n    board[:, j] += board[:, j - 1]\nfor j in range(1, 1 + 4 * K):\n    board[j, :] += board[j - 1, :]\nans = np.max(board[K:3 * K, K:3 * K] + board[:2 * K, :2 * K] -\n             board[:2 * K, K:3 * K] - board[K:3 * K, :2 * K])\nprint(ans)\n", "import numpy as np\nn, k = map(int, input().split())\nlist_subj = []\nfor i in range(n):\n  x, y, c = input().split()\n  if c == \"W\":\n    list_subj.append([int(x) % (2*k), int(y) % (2*k)])\n  else:\n    list_subj.append([(int(x) + k) % (2*k), int(y) % (2*k)])\n\nimos_field = [[0] * (2*k+1) for _ in range(2*k+1)]\nfor x, y in list_subj:\n  for place in (0, k):\n    adj_y = (y + place) % (2 * k)\n    if adj_y >= k - 1:\n      imos_y = [(adj_y-k+1, adj_y+1)]\n    else:\n      imos_y = [(0, adj_y+1), (adj_y+k+1, 2*k)]\n    adj_x = (x + place) % (2 * k)\n    if adj_x >= k - 1:\n      imos_x = [(adj_x-k+1, adj_x+1)]\n    else:\n      imos_x = [(0, adj_x+1), (adj_x+k+1, 2*k)]\n    for bottom, top in imos_y:\n      for left, right in imos_x:\n        imos_field[bottom][left] += 1\n        imos_field[top][left] -= 1\n        imos_field[bottom][right] -= 1\n        imos_field[top][right] += 1\n\nresult = np.cumsum(imos_field, axis=1)\nresult = np.cumsum(result, axis=0)\nresult = int(np.max(result))\nprint(result)", "import sys\nimport numpy as np\nfrom collections import Counter\n\nread = sys.stdin\n\nN, K = list(map(int, read.readline().split()))\nk = 2 * K\nxyc = np.array(read.read().split(), np.str).reshape(-1, 3)\nx = xyc[:, 0].astype(int)\ny = xyc[:, 1].astype(int)\nc = xyc[:, 2]\n\nx[c == 'B'] -= K\nx %= k\ny %= k\n\ngrid = np.zeros((3 * K, 3 * K), np.int64)\nnp.add.at(grid, (x, y), 1)\nnp.add.at(grid, (x + K, y + K), 1)\nnp.subtract.at(grid, (x + K, y), 1)\nnp.subtract.at(grid, (x, y + K), 1)\nnp.cumsum(grid, axis=0, out=grid)\nnp.cumsum(grid, axis=1, out=grid)\n\np1 = grid[:K, :K] + grid[k:, k:] + grid[K:k, K:k] + grid[k:, :K] + grid[:K, k:]\np2 = grid[K:k, :K] + grid[K:k, k:] + grid[:K, K:k] + grid[k:, K:k]\nprint((max(p1.max(), p2.max())))\n", "import numpy as np\n\nN, K = map(int, input().split())\n_3K = 3 * K\n_2K = 2 * K\nG = np.zeros((_2K, _3K), dtype='int64') # \u5f8c\u304b\u3089 2K * K \u306b\u5727\u7e2e\u3059\u308b\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    # 2K * 2K \u306e\u9ed2\u306e\u5e0c\u671b\u306b\u7f6e\u304d\u63db\u3048\n    if c == 'B':\n        x = x % _2K\n        y = y % _2K\n    else:\n        x = (x + K) % _2K\n        y = y % _2K\n    # \u3055\u3089\u306b\u3001 2K * K \u306e\u9ed2\u306e\u5e0c\u671b\u306b\u5727\u7e2e\u3059\u308b\n    if (y >= K) and (x >= K):\n        x -= K\n        y -= K\n    if (y >= K) and (x < K):\n        x += K\n        y -= K\n    # \u5857\u308a\u65b9\u306f\u53f3\u4e0b\u304c\u3069\u306e\u30de\u30b9\u306b\u6765\u308b\u304b\u306e 2K * K \u901a\u308a\n    # \u2192 \u6700\u7d42\u7684\u306b 2K * K \u306e\u30b0\u30ea\u30c3\u30c9\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\n    # \u5404\u5e0c\u671b\u3092\u6e80\u305f\u3059\u5857\u308a\u65b9\u306f K * K \u901a\u308a\n    # \u2192 2K * K \u306e\u30b0\u30ea\u30c3\u30c9\u5185\u306e\u5e0c\u671b\u3092\u6e80\u305f\u3059 K * K \u30de\u30b9\u306b 1 \u3092\u52a0\u7b97\u3059\u308c\u3070\u3001\n    #   \u5168\u5e0c\u671b\u306e\u52a0\u7b97\u5f8c\u306b\u306f\u5404\u30de\u30b9\uff1d\u5404\u5857\u308a\u65b9\u304c\u3044\u304f\u3064\u306e\u5e0c\u671b\u3092\u6e80\u305f\u3059\u304b\u304c\u308f\u304b\u308b\n    # K * K \u30de\u30b9\u306b 1 \u3092\u52a0\u7b97\u3059\u308b\u306b\u306f o(K^2) \u304b\u304b\u3063\u3066\u3057\u307e\u3046\n    # \u2192 \u3044\u3082\u3059\u6cd5\u3092\u4f7f\u3046\n    # \u5857\u308a\u65b9\u3092 3K * 2K \u306e\u7bc4\u56f2\u3067\u8003\u3048\u3066\u7d2f\u7a4d\u548c\u3092\u3068\u3063\u305f\u5f8c\u3001 2K * K \u306e\u7bc4\u56f2\u306b\u5727\u7e2e\u3059\u308b\n    G[y, x] += 1\n    G[y+K, x+K] += 1\n    G[y+K, x] -= 1\n    G[y, x+K] -= 1\n\n# 3K * 2K \u306e\u7bc4\u56f2\u306e\u7d2f\u7a4d\u548c\u3092\u3068\u308b\nG = G.cumsum(axis=1).cumsum(axis=0)\n# 2K * K \u306e\u7bc4\u56f2\u306b\u5727\u7e2e\nG = G[:K, :_2K] + G[K:_2K, K:_3K] + np.concatenate((G[:K, _2K:_3K], G[K:_2K, :K]), axis=1)\nans = G.max()\nprint(ans)", "def d_checker():\n    # \u53c2\u80031: https://pitsbuffersolution.com/compro/atcoder/arc089d.php\n    # \u53c2\u80032: https://atcoder.jp/contests/abc086/submissions/3271380\n    import numpy as np\n    N, K = [int(i) for i in input().split()]\n\n    def get_bound(p):\n        \"\"\"\u3042\u308b\u5e0c\u671b\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u89d2\u306e\u30de\u30b9\u306e\u96c6\u5408\u306fKxK\u6b63\u65b9\u5f62\u533a\u9593\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\n        p<K-1 \u306e\u3068\u304d\u306f\u305d\u306e\u6b63\u65b9\u5f62\u3092\u5206\u5272\u3057\u306a\u3044\u3068\u306a\u3089\u306a\u3044\"\"\"\n        return [(0, p + 1), (p + K + 1, 2 * K)] if p < K - 1 else [(p - K + 1, p + 1)]\n\n    # \u30de\u30b9(x, y)\u304c\u767d\u21d4\u30de\u30b9(x, y+K)\u304c\u9ed2\u306a\u306e\u3067\u3001\u5e0c\u671b\u306e\u8272\u3092\u9ed2\u306b\u7d71\u4e00\u3059\u308b\n    # \u5e02\u677e\u6a21\u69d8\u306e\u5468\u671f\u306f2K\u306a\u306e\u3067\u3001x, y\u5ea7\u6a19\u3092\u305d\u308c\u305e\u308c2K\u3067\u5270\u4f59\u3092\u53d6\u3063\u305f\u5ea7\u6a19\u3068\u540c\u4e00\u8996\u3067\u304d\u308b\n    requests_black = [[0] * (2 * K + 1) for _ in range(2 * K + 1)]\n    for _ in range(N):\n        x, y, c = input().split()\n        x = int(x) % (2 * K)\n        y = int(y) % (2 * K) if c == 'B' else (int(y) + K) % (2 * K)\n\n        for shift in (0, K):  # 2Kx2K\u306e\u5e02\u677e\u6a21\u69d8\u306e\u4e2d\u306b\u540c\u8272\u306e\u9818\u57df\u304c2\u3064\u305a\u3064\u3042\u308b\u3053\u3068\u3092\u53cd\u6620\n            # bottom, top, left, right\n            for b, t in get_bound((y + shift) % (2 * K)):\n                for l, r in get_bound((x + shift) % (2 * K)):\n                    # 2\u6b21\u5143imos\u6cd5(\u5de6\u4e0a\u3001\u5de6\u4e0b\u3001\u53f3\u4e0a\u3001\u53f3\u4e0b\u306b\u00b11\u3059\u308b\u3053\u3068\u3068\u5bfe\u5fdc)\n                    requests_black[b][l] += 1\n                    requests_black[t][l] -= 1\n                    requests_black[b][r] -= 1\n                    requests_black[t][r] += 1\n    # \u6700\u5f8c\u306b\u7d2f\u7a4d\u548c\u3092\u53d6\u308b\u3068\u3001\u3042\u308b\u30de\u30b9\u3092\u6b63\u65b9\u5f62\u306e\u89d2\u3068\u3057\u305f\u3068\u304d\u53f6\u3048\u3089\u308c\u308b\u5e0c\u671b\u306e\u6570\u304c\u308f\u304b\u308b\n    return int(np.max(np.cumsum(np.cumsum(requests_black, axis=1), axis=0)))\n\nprint(d_checker())", "#!/usr/bin/env python3\n\ndef main():\n    na = list(map(int, input().split()))\n    N = na[0]\n    K = na[1]\n    x = []\n    y = []\n    c = []\n    for i in range(N):\n        sa = input().split()\n        x.append(int(sa[0]))\n        y.append(int(sa[1]))\n        c.append(True if sa[2] == 'W' else False)\n\n    hopes = [[0 for j in range(K)] for i in range(K)]\n    ysum = [[0 for j in range(K * 2)] for i in range(K)]\n\n    score = 0\n    for i in range(N):\n        xmod = x[i] % K\n        ymod = y[i] % K\n        f = (int(x[i] / K) + int(y[i] / K)) % 2 == 1\n        c[i] ^= f\n        if c[i]:\n            score += 1\n        h = -1 if c[i] else 1\n        hopes[xmod][ymod] += h\n\n    for i in range(K):\n        s = 0\n        for j in range(K):\n            s += hopes[i][j]\n            ysum[i][j] = s\n        for j in range(K):\n            s -= hopes[i][j]\n            ysum[i][K + j] = s\n\n    smax = 0\n    for j in range(K):\n        s = 0\n        for i in range(K):\n            s += ysum[i][K + j]\n        for i in range(K):\n            s += (ysum[i][j] - ysum[i][K + j])\n            smax = max(smax, s)\n        for i in range(K):\n            s -= (ysum[i][j] - ysum[i][K + j])\n            smax = max(smax, s)\n\n    print((score + smax))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "N, K = (int(i) for i in input().split())\nW = list()\nfor index in range(N):\n\tx, y, c = (s for s in input().split())\n\tx = int(x)\n\ty = int(y)\n\tc = 0 if c == \"W\" else 1\n\tif x%(2*K) != x%K:\n\t\tc = 1-c\n\tif y%(2*K) != y%K:\n\t\tc = 1-c\n\tW.append((x%K, y%K, c))\n\nw = [[0 for _ in range(K)] for _ in range(K)]\nb = [[0 for _ in range(K)] for _ in range(K)]\nwx = [0 for _ in range(K)]\nwy = [0 for _ in range(K)]\nbx = [0 for _ in range(K)]\nby = [0 for _ in range(K)]\nfor x, y, c in W:\n\tif c == 0:\n\t\tw[x][y] += 1\n\t\twx[x] += 1\n\t\twy[y] += 1\n\telse:\n\t\tb[x][y] += 1\n\t\tbx[x] += 1\n\t\tby[y] += 1\n\nM = 0\nfor row in w:\n\tM += sum(row)\n\ns = M\nfor x in range(K):\n\ttmp = s\n\tfor y in range(K):\n\t\ts += by[y]\n\t\ts -= wy[y]\n\t\tM = max(s, N-s, M)\n\tfor y in range(K):\n\t\tby[y] += w[x][y]\n\t\tby[y] -= b[x][y]\n\t\twy[y] += b[x][y]\n\t\twy[y] -= w[x][y]\n\ttmp += bx[x]\n\ttmp -= wx[x]\n\ts = tmp\n\tM = max(s, N-s, M)\n\nprint(M)", "import numpy as np\n\n\ndef solve(string):\n    n, k, *xyc = string.split()\n    k = int(k)\n    l = 2 * int(k)\n    xy = [(int(x) % l, int(y) % l) if c == \"W\" else (int(x) % l, (int(y) + k) % l)\n          for x, y, c in zip(xyc[::3], xyc[1::3], xyc[2::3])]\n    ans = [[0 for j in range(l + 0)] for i in range(l + 0)]\n    for _x, _y in xy:\n        if (_x - k + 0.5) * (_y - k + 0.5) > 0:\n            lt = 2\n            lte = 1\n            ans[0][0] += 1\n        else:\n            lt = -2\n            lte = -1\n        _x %= k\n        _y %= k\n        ans[_x][_y] += lt\n        ans[_x + k][_y] -= lt\n        ans[_x][_y + k] -= lt\n        ans[_x + k][_y + k] += lt\n        ans[_x + k][0] += lte\n        ans[0][_y + k] += lte\n        ans[_x][0] -= lte\n        ans[0][_y] -= lte\n    return str(np.asarray(ans).cumsum(axis=1).cumsum(axis=0).max())\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    print((solve('{} {}\\n'.format(n, m) + '\\n'.join([input() for _ in range(n)]))))\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn,k = map(int, input().split())\ngrid = [[0]*k for i in range(k)]\nblack = 0\nfor i in range(n):\n    a,b,c =input().split()\n    a,b = int(a), int(b)\n    f = a//k + b//k\n    a %= k\n    b %= k\n    if (c == \"W\" and f%2==0) or (c == \"B\" and f%2==1):\n        grid[a][b] += 1\n    else:\n        grid[a][b] -= 1\n        black += 1\n\ns = [[0]*(k+1) for i in range(k+1)]\nfor i in range(k):\n    for j in range(k):\n        s[i+1][j+1] = s[i][j+1] + s[i+1][j] - s[i][j] + grid[i][j]\n\nans = 0\nfor i in range(k):\n    for j in range(k):\n        a = s[k][k] - s[i][k] - s[k][j] + 2*s[i][j] + black\n        ans = max(ans, max(a, n-a))\nprint(ans)", "import numpy as np\nn, k = list(map(int, input().split()))\n\ndef get_bound(x):\n    if x < k-1:\n        return [(0, x+1), (x+k+1, 2*k)]\n    else:\n        return [(x-k+1, x+1)]\n\nblacks = [[0]*(2*k+1) for _ in range(2*k+1)]\nfor _ in range(n):\n    x, y, c = input().split()\n    x = int(x)%(2*k)\n    y = int(y)%(2*k) if c == 'B' else (int(y)+k)%(2*k)\n\n    for shift in [0, k]:\n        for b, t in get_bound((y+shift)%(2*k)):\n            for l, r in get_bound((x+shift)%(2*k)):\n                blacks[b][l] += 1\n                blacks[t][l] -= 1\n                blacks[b][r] -= 1\n                blacks[t][r] += 1\n        \nans = np.max(np.cumsum(np.cumsum(blacks, axis = 1), axis = 0))\nprint((int(ans)))\n", "import numpy as np\nimport sys\n\ndef sum2d(i1,j1,i2,j2):\n    A[i1][j1] += 1\n    A[i1][j2] -= 1\n    A[i2][j1] -= 1\n    A[i2][j2] += 1\n\nN,K = list(map(int,input().split()))\nXYC = [list(input().split()) for _ in range(N)]\n\nA = [[0 for _ in range(K*2+1)] for _ in range(K*2+1)]\n\nfor x,y,c in XYC:\n    i = (int(x) if c==\"W\" else int(x)+K) % (K*2)\n    j = int(y) % (K*2)\n    i0 = i%K\n    j0 = j%K\n    if (i<K and j<K) or (i>=K and j>=K):\n        sum2d(0,0,i0,j0) # \u5de6\u4e0a\n        sum2d(i0+K,0,K*2,j0) # \u53f3\u4e0a\n        sum2d(i0,j0,i0+K,j0+K) # \u771f\u3093\u4e2d\n        sum2d(0,j0+K,i0,K*2) # \u5de6\u4e0b\n        sum2d(i0+K,j0+K,K*2,K*2) # \u53f3\u4e0b\n    else:\n        sum2d(i0,0,i0+K,j0) # \u4e0a\n        sum2d(0,j0,i0,j0+K) # \u5de6\n        sum2d(i0+K,j0,K*2,j0+K) # \u53f3\n        sum2d(i0,j0+K,i0+K,K*2) # \u4e0b\n\n# 2\u6b21\u5143\u7d2f\u7a4d\u548c\nAA = np.array(A)\nfor i in range(K*2):\n    AA[i+1, :] += AA[i, :]\nfor j in range(K*2):\n    AA[:, j+1] += AA[:, j]\n\nprint((AA.max()))\n\n\n", "import numpy as np\n\nn, k = list(map(int, input().split()))\nxyc = [list(input().split()) for _ in range(n)]\n\nb = np.zeros((2 * k, k), np.int32)\n\nfor x, y, c in xyc:\n    x = int(x)\n    y = int(y)\n\n    q, r = divmod(x, k)\n    if q % 2:\n        y += k\n    x = r\n\n    if c == \"W\":\n        y += k\n\n    y %= 2 * k\n\n    b[y][x] += 1\n\nb = np.vstack([b, b])\nb = np.hstack([b, np.roll(b, k, axis=0)])\n\nb = np.pad(b, (1, 0), \"constant\")\nb = np.cumsum(b, axis=0)\nb = np.cumsum(b, axis=1)\n\ncnt = b[k:, k:] - b[k:, :-k] - b[:-k, k:] + b[:-k, :-k]\nans = cnt.max()\nprint(ans)\n", "import numpy as np\n\nN, K = map(int, input().split())\nK2 = K*2\n\nM = np.zeros((K2, K2), int)\nnb = 0\nfor _ in range(N):\n  x, y, c = input().split()\n  x = int(x) % K2\n  y = int(y) % K2\n  if c=='B': nb+=1\n  M[x, y] += 1 if c=='W' else -1\n\nSx = np.zeros((K2, K2+1), int)\nfor y in range(K2):\n  Sx[:, y+1] = Sx[:, y] + M[:, y]\n\nS = np.zeros((K2+1, K2+1), int)\nfor x in range(K2):\n  S[x+1] = S[x] + Sx[x]\n\nans = -1000000\nfor x in range(K2):\n  x0 = 0\n  x1 = max(x-K , 0)\n  x2 = x\n  x3 = min(x+K , K2)\n  x4 = K2\n\n  T1 = S[x4] - S[x3] + S[x2] - S[x1]\n  T2 = S[x3] - S[x2] + S[x1] - S[x0]\n\n  U = T1[K2] - T1[K:K2] + T1[:K] + T2[K:K2] - T2[:K]\n  ans = max(ans, np.max(U))\n  \nprint(nb + ans)", "import numpy as np\nimport sys\n\nN, K = map(int, input().split())\nK2 = K * 2\nMij = [[0 for _ in range(K2 + 1)] for _ in range(K2 + 1)]\n\ndef imos(i1, j1, i2, j2):\n    Mij[i1][j1] += 1\n    Mij[i1][j2] -= 1\n    Mij[i2][j1] -= 1\n    Mij[i2][j2] += 1\n\nfor _ in range(N):\n    i, j, s = sys.stdin.readline().split()\n    i = int(i) % K2\n    j = int(j) % K2\n    if s == \"B\":\n        i = (i + K) % K2\n    i1 = i % K\n    j1 = j % K\n    if (i < K and j < K) or (K <= i and K <= j):\n        imos(0, 0, i1, j1)\n        imos(0, j1 + K, i1, K2)\n        imos(i1 + K, 0, K2, j1)\n        imos(i1 + K, j1 + K, K2, K2)\n        imos(i1, j1, i1 + K, j1 + K)\n    else:\n        imos(0, j1, i1, j1 + K)\n        imos(i1 + K, j1, K2, j1 + K)\n        imos(i1, 0, i1 + K, j1)\n        imos(i1, j1 + K, i1 + K, K2)\n\n# \u7d2f\u7a4d\u548c\nMij = np.array(Mij)\nfor x in range(K2):\n    Mij[:, x + 1] += Mij[:, x]\nfor y in range(K2):\n    Mij[y + 1, :] += Mij[y, :]\nprint(Mij.max())", "import numpy as np\n\ndef main():\n    n, k = map(int, input().split())\n    p = [list(map(str, input().split())) for _ in range(n)]\n    arr = [[[0]*2 for j in range(k)] for i in range(k)]\n    for i in range(n):\n        x, y, c = p[i]\n        x, y = int(x), int(y)\n        mx, my = x%k, y%k\n        f = False\n        if (x//k)%2 != (y//k)%2:\n            f = not f\n        if c == \"W\":\n            f = not f\n        if f:\n            arr[0][0][0] += 1\n            arr[mx][0][0] -= 1\n            arr[0][my][0] -= 1\n            arr[mx][my][0] += 2\n        else:\n            arr[0][my][0] += 1\n            arr[mx][0][0] += 1\n            arr[mx][my][0] -= 2\n        f = False\n        if (x//k)%2 != (y//k)%2:\n            f = not f\n        if c == \"B\":\n            f = not f\n        if f:\n            arr[0][0][1] += 1\n            arr[mx][0][1] -= 1\n            arr[0][my][1] -= 1\n            arr[mx][my][1] += 2\n        else:\n            arr[0][my][1] += 1\n            arr[mx][0][1] += 1\n            arr[mx][my][1] -= 2\n    np_arr = np.array(arr)\n    np_arr = np.cumsum(np_arr, axis=0)\n    np_arr = np.cumsum(np_arr, axis=1)\n    print(int(np.max(np_arr)))\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n# from time import time\n\n# t0 = time()\nN, K = list(map(int, input().split()))\nB = np.zeros((2 * K, 2 * K), np.int32)\nW = np.zeros((2 * K, 2 * K), np.int32)\n# t1 = time()\n# print(t1 - t0)\nfor _ in range(N):\n    x, y, c = input().split()\n    if c == \"B\":\n        B[int(x) % (2 * K)][int(y) % (2 * K)] += 1\n    else:\n        W[int(x) % (2 * K)][int(y) % (2 * K)] += 1\n# t2 = time()\n# print(t2 - t1)\nSB = np.zeros((4 * K + 1, 4 * K + 1), np.int32)\nSW = np.zeros((4 * K + 1, 4 * K + 1), np.int32)\n# t3 = time()\n# print(t3 - t2)\nSB[0*K+1:2*K+1, 0*K+1:2*K+1] = B\nSB[0*K+1:2*K+1, 2*K+1:4*K+1] = B\nSB[2*K+1:4*K+1, 0*K+1:2*K+1] = B\nSB[2*K+1:4*K+1, 2*K+1:4*K+1] = B\nSW[0*K+1:2*K+1, 0*K+1:2*K+1] = W\nSW[0*K+1:2*K+1, 2*K+1:4*K+1] = W\nSW[2*K+1:4*K+1, 0*K+1:2*K+1] = W\nSW[2*K+1:4*K+1, 2*K+1:4*K+1] = W\n# t4 = time()\n# print(t4 - t3)\nnp.cumsum(SB, 0, out=SB)\nnp.cumsum(SB, 1, out=SB)\nnp.cumsum(SW, 0, out=SW)\nnp.cumsum(SW, 1, out=SW)\n# t5 = time()\n# print(t5 - t4)\nans = 0\ncand = SB[1*K:3*K+1, 1*K:3*K+1].copy()\ncand -= SB[0*K:2*K+1, 1*K:3*K+1]\ncand -= SB[1*K:3*K+1, 0*K:2*K+1]\ncand += SB[0*K:2*K+1, 0*K:2*K+1]\ncand += SB[2*K:4*K+1, 2*K:4*K+1]\ncand -= SB[1*K:3*K+1, 2*K:4*K+1]\ncand -= SB[2*K:4*K+1, 1*K:3*K+1]\ncand += SB[1*K:3*K+1, 1*K:3*K+1]\ncand += SW[2*K:4*K+1, 1*K:3*K+1]\ncand -= SW[1*K:3*K+1, 1*K:3*K+1]\ncand -= SW[2*K:4*K+1, 0*K:2*K+1]\ncand += SW[1*K:3*K+1, 0*K:2*K+1]\ncand += SW[1*K:3*K+1, 2*K:4*K+1]\ncand -= SW[0*K:2*K+1, 2*K:4*K+1]\ncand -= SW[1*K:3*K+1, 1*K:3*K+1]\ncand += SW[0*K:2*K+1, 1*K:3*K+1]\nans = np.max(cand)\n# t6 = time()\n# print(t6 - t5)\n\nprint(ans)\n", "import numpy as np\nN, K = map(int, input().split())\nmod = 2*K\nfield = [[0]*(2*K+1) for _ in range(2*K+1)]\n\ndef gen_pattern(x):\n    if x < K-1:\n        return [[0, x+1], [x+K+1, 2*K]]\n    else:\n        return [[x-K+1, x+1]]\n\nfor _ in range(N):\n    x, y, c = input().split()\n    x, y = int(x), int(y)\n    if c == 'W':\n        y += K\n    x %= mod\n    y %= mod\n    for tmp in [0, K]:\n        for l, r in gen_pattern((x+tmp) % mod):\n            for b, t in gen_pattern((y+tmp) % mod):\n                field[l][b] += 1\n                field[l][t] -= 1\n                field[r][b] -= 1\n                field[r][t] += 1\nprint(np.max(np.cumsum(np.cumsum(field, axis=0), axis=1)))", "#(6,6)\u5468\u671f\n#36\u7a2e\u306e\u5e0c\u671b\n\nimport numpy as np\nN,K = list(map(int,input().split()))\nKK = 2*K\nhope = np.zeros((KK,KK),dtype=np.int32)\n\nfor _ in range(N):\n  x,y,c  = input().split()\n  x = int(x)\n  y = int(y)\n  if c == 'B':\n    x -= K\n  hope[x%KK,y%KK] += 1\n# (x,y)\u3092\u5e0c\u671b\u3055\u308c\u305f\u5834\u5408\u3001[x,x+K), [y,y+K)\u306b\u7d42\u70b9\u304c\u3042\u308b\u3079\u304d\n# \u533a\u9593\u306e\u91cd\u306a\u3063\u3066\u308b\u679a\u6570\u3092\u96c6\u8a08\u30021,0,0,-1, cumsum\nA = np.zeros((KK+K,KK+K),dtype=np.int32)\nA[:-K,:-K] = hope[:]\nA[K:,:-K] += -hope[:]\nA[:-K,K:] += -hope[:]\nA[K:,K:] += hope[:]\nA = A.cumsum(axis = 0).cumsum(axis = 1)\n\n# \u5b9f\u8cea\u540c\u3058\u5834\u6240\u3092\u307e\u3068\u3081\u308b\nB = A[:,:KK]\nB[:,:K] += A[:,KK:] #(3K,2K)\nA = B[:KK,:]\nA[:K,:] += B[KK:,:] #(2K,2K)\nB = A[:K,:] #(K,2K)\nB[:,:K] += A[K:,K:]\nB[:,K:] += A[K:,:K]\n\nanswer = B.max()\nprint(answer)\n", "import numpy as np\n\n\ndef imos2d(x1, y1, x2, y2, board):\n    board[y1][x1] += 1\n    board[y2][x2] += 1\n    board[y2][x1] -= 1\n    board[y1][x2] -= 1\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    lines = [input() for _ in range(N)]\n\n    # N, K = 4, 3\n    # lines = [\"0 1 W\", \"1 2 W\", \"5 3 B\", \"5 4 B\"]\n\n    K2 = 2 * K\n    add_dict = {\"W\": 0, \"B\": K}\n    board = [[0 for _ in range(K2 + 1)] for _ in range(K2 + 1)]\n    for line in lines:\n        ls = line.split()\n        x = int(ls[0]) % K2\n        y = (int(ls[1]) + add_dict[ls[2]]) % K2\n        x_ = x % K\n        y_ = y % K\n\n        # \u5de6\u4e0a\u30fb\u53f3\u4e0a\u30fb\u4e2d\u592e\u30fb\u5de6\u4e0b\u30fb\u53f3\u4e0b\n        if (x < K and y < K) or (K <= x and K <= y):\n            # \u5de6\u4e0a\n            imos2d(0, 0, x_ + 1, y_ + 1, board)\n            # \u53f3\u4e0a\n            imos2d(x_ + K + 1, 0, K2, y_ + 1, board)\n            # \u5de6\u4e0b\n            imos2d(0, y_ + K + 1, x_ + 1, K2, board)\n            # \u53f3\u4e0b\n            imos2d(x_ + K + 1, y_ + K + 1, K2, K2, board)\n            # \u4e2d\u592e\n            imos2d(x_ + 1, y_ + 1, x_ + K + 1, y_ + K + 1, board)\n        # \u4e0a\u30fb\u4e0b\u30fb\u5de6\u30fb\u53f3\n        else:\n            # \u4e0a\n            imos2d(x_ + 1, 0, x_ + K + 1, y_ + 1, board)\n            # \u4e0b\n            imos2d(x_ + 1, y_ + K + 1, x_ + K + 1, K2, board)\n\n            # \u5de6\n            imos2d(0, y_ + 1, x_ + 1, y_ + K + 1, board)\n            imos2d(x_ + K + 1, y_ + 1, K2, y_ + K + 1, board)\n\n    board = np.array(board)\n    for x in range(K2):\n        board[:, x + 1] += board[:, x]\n    for y in range(K2):\n        board[y + 1, :] += board[y, :]\n\n    print((board.max()))\n\n__starting_point()", "import sys\nimport numpy as np\nfrom collections import Counter\n\nread = sys.stdin\n\nN, K = list(map(int, read.readline().split()))\nk = 2 * K\nxyc = np.array(read.read().split(), np.str).reshape(-1, 3)\nx = xyc[:, 0].astype(int)\ny = xyc[:, 1].astype(int)\nc = xyc[:, 2]\n\nx[c == 'B'] -= K\nx %= k\ny %= k\n\n'''\n# grid[[1,1],[2,2]]+=1 \u3068\u3057\u3066\u3082grid[1,2]=1\u3067\u3042\u308a\u91cd\u8907\u306f\u8003\u616e\u3055\u308c\u306a\u3044\u3002\n# unique\u3092\u4f7f\u3063\u3066(x,y)\u306e\u91cd\u8907\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n# return_count\u306fver1.9\u304b\u3089\u3060\u3063\u305f\u30fb\u30fb\u30fb \u30c0\u30e1\u3058\u3083\u3093\nxy, cnt = np.unique(x + y * 10000, return_counts=True)\nx = xy % 10000\ny = xy // 10000\n'''\nxy = Counter(list(zip(x.tolist(), y.tolist())))\ncnt = np.array(list(xy.values()), np.int64)\nxy = np.array(list(xy.keys()), np.int64)\nx = xy[:, 0]\ny = xy[:, 1]\n\ngrid = np.zeros((3 * K, 3 * K), np.int64)\ngrid[x, y] += cnt\ngrid[x + K, y + K] += cnt\ngrid[x + K, y] -= cnt\ngrid[x, y + K] -= cnt\nnp.cumsum(grid, axis=0, out=grid)\nnp.cumsum(grid, axis=1, out=grid)\n\np1 = grid[:K, :K] + grid[k:, k:] + grid[K:k, K:k] + grid[k:, :K] + grid[:K, k:]\np2 = grid[K:k, :K] + grid[K:k, k:] + grid[:K, K:k] + grid[k:, K:k]\nprint((max(p1.max(), p2.max())))\n", "import numpy as np\n\n\ndef imos2d(x1, y1, x2, y2, board):\n    board[y1][x1] += 1\n    board[y2][x2] += 1\n    board[y2][x1] -= 1\n    board[y1][x2] -= 1\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    lines = [input() for _ in range(N)]\n\n    K2 = 2 * K\n    add_dict = {\"W\": 0, \"B\": K}\n    board = [[0 for _ in range(K2 + 1)] for _ in range(K2 + 1)]\n    for line in lines:\n        ls = line.split()\n        x = int(ls[0]) % K2\n        y = (int(ls[1]) + add_dict[ls[2]]) % K2\n        x_ = x % K\n        y_ = y % K\n\n        # \u5de6\u4e0a\u30fb\u53f3\u4e0a\u30fb\u4e2d\u592e\u30fb\u5de6\u4e0b\u30fb\u53f3\u4e0b\n        if (x < K and y < K) or (K <= x and K <= y):\n            # \u5de6\u4e0a\n            imos2d(0, 0, x_ + 1, y_ + 1, board)\n            # \u53f3\u4e0a\n            imos2d(x_ + K + 1, 0, K2, y_ + 1, board)\n            # \u5de6\u4e0b\n            imos2d(0, y_ + K + 1, x_ + 1, K2, board)\n            # \u53f3\u4e0b\n            imos2d(x_ + K + 1, y_ + K + 1, K2, K2, board)\n            # \u4e2d\u592e\n            imos2d(x_ + 1, y_ + 1, x_ + K + 1, y_ + K + 1, board)\n        # \u4e0a\u30fb\u4e0b\u30fb\u5de6\u30fb\u53f3\n        else:\n            # \u4e0a\n            imos2d(x_ + 1, 0, x_ + K + 1, y_ + 1, board)\n            # \u4e0b\n            imos2d(x_ + 1, y_ + K + 1, x_ + K + 1, K2, board)\n\n            # \u5de6\n            imos2d(0, y_ + 1, x_ + 1, y_ + K + 1, board)\n            imos2d(x_ + K + 1, y_ + 1, K2, y_ + K + 1, board)\n\n    board = np.array(board)\n    for x in range(K2):\n        board[:, x + 1] += board[:, x]\n    for y in range(K2):\n        board[y + 1, :] += board[y, :]\n\n    print((board.max()))\n\n__starting_point()", "N, K = map(int, input().split())\n\nscore = [[0] * (K+1) for y in range(K+1)]\nbase_hope = 0\n\nfor i in range(N):\n    x, y, c = input().split()\n    x2, y2 = int(x) // K, int(y) // K\n    x_coord, y_coord = int(x) % K + 1, int(y) % K + 1\n    if ((x2 + y2) % 2 == 0 and c == \"W\") or ((x2 + y2) % 2 == 1 and c == \"B\"):\n        score[y_coord][x_coord] += 1\n        base_hope += 1\n    else:\n        score[y_coord][x_coord] -= 1\n\nxy = [(x, y) for x in range(K) for y in range(K)]\nfor x, y in xy:\n    score[y+1][x+1] += score[y+1][x] + score[y][x+1] - score[y][x]\n\nmax_hope = 0\nfor x, y in xy:\n    hope = base_hope - score[K][x] - score[y][K] + 2 * score[y][x]\n    true_hope = hope if hope > N - hope else N - hope\n    if true_hope > max_hope:\n        max_hope = true_hope\n\nprint(max_hope)", "def main():\n  n, k = map(int, input().split())\n  mp1 = [[0] * k for _ in range(k)]\n  mp2 = [[0] * k for _ in range(k)]\n  for _ in range(n):\n    x, y, c = input().split()\n    t = int(x) // k + int(y) // k\n    x = int(x) % k\n    y = int(y) % k\n    if c == \"B\":\n      t += 1\n    if t % 2:\n      mp1[y][x] += 1\n    else:\n      mp2[y][x] += 1\n  \n  mp10 = mp1[0]\n  mp20 = mp2[0]\n  for x in range(1, k):\n    mp10[x] += mp10[x - 1]\n    mp20[x] += mp20[x - 1]\n  \n  for y in range(1, k):\n    acc1 = 0\n    acc2 = 0\n    mp1y = mp1[y]\n    mp2y = mp2[y]\n    mp1y1 = mp1[y - 1]\n    mp2y1 = mp2[y - 1]\n    for x in range(k):\n      acc1 += mp1y[x]\n      mp1y[x] = acc1 + mp1y1[x]\n      acc2 += mp2y[x]\n      mp2y[x] = acc2 + mp2y1[x]\n  \n  ans = 0\n  sum1 = mp1[k - 1][k - 1]\n  sum2 = mp2[k - 1][k - 1]\n  mp1k = mp1[k - 1]\n  mp2k = mp2[k - 1]\n  for y in range(k):\n    mp1y = mp1[y]\n    mp1yk = mp1y[k - 1]\n    mp2y = mp2[y]\n    mp2yk = mp2y[k - 1]\n    for x in range(k):\n      mp1yx = mp1y[x]\n      mp2yx = mp2y[x]\n      mp1kx = mp1k[x]\n      mp2kx = mp2k[x]\n  \n      a1 = 2 * mp1yx + sum1 - mp1yk - mp1kx + mp2kx + mp2yk - 2 * mp2yx\n      a2 = 2 * mp2yx + sum2 - mp2yk - mp2kx + mp1kx + mp1yk - 2 * mp1yx\n  \n      if ans < a1:\n        ans = a1\n      if ans < a2:\n        ans = a2\n  \n  \n  print(ans)\n\nmain()", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# \u7e26K\u3001\u6a2a2*K\u306e\u9577\u65b9\u5f62\u306b\u5168\u3066\u306e\u5e0c\u671b\u3092W\u3068\u3057\u3066\u5165\u308c\u308b\n# numpy\u306e\u7d2f\u7a4d\u548c\u3001\u6700\u5f8c\u306bmax\u3092\u3068\u308b\nN, K = lr()\ntable = [[0] * 2*K for _ in range(K)]\nfor _ in range(N):\n    x, y, c = sr().split()\n    x = int(x); y = int(y)\n    if c == 'B':\n        x -= K  # \u3053\u3053\u3067\u5168\u3066W\u3068\u3057\u3066\u6271\u3048\u308b\n    x %= 2 * K; y %= 2 * K\n    if x >= K and y >= K:\n        x -= K; y -= K\n    elif y >= K:\n        x += K; y -= K\n    # \u9577\u65b9\u5f62\u306b\u5165\u3063\u305f\n    table[y][x] += 1\n\ntable = np.array(table, dtype=np.int32)\ntable = np.concatenate([table, table], axis=1)\ntable2 = np.roll(table, K, axis=1)\ntable = np.concatenate([table, table2], axis=0)\ntable_cum = table.cumsum(axis=1).cumsum(axis=0)\nprev = table_cum.copy()\ntable_cum[:, K:] -= prev[:, :-K]\ntable_cum[K:, :] -= prev[:-K, :]\ntable_cum[K:, K:] += prev[:-K, :-K]\nanswer = table_cum.max()\nprint(answer)\n", "from numpy import *\nN,K = map(int,input().split())\nM = zeros((3*K,3*K),int)\nL = 2*K\nO = 0\n\nfor n in range(N):\n  x,y,c = input().split()\n  x = int(x)%L\n  y = int(y)%L\n  t = c==\"W\"\n  M[x,y]+=1-2*t\n  O+=t\n\nfor n in range(2):\n  M[L:] = M[:K]\n  M = cumsum(M,axis=0)\n  M[:L] = M[K:]-M[:L]\n  M = M.T\n  \nM = M[:L,:L]\nprint(O+(M+roll(roll(M,K,axis=0),K,axis=1)).max())"]
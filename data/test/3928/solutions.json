["def f(x):\n    z=[0 for i in range(len(x))]\n    l=0\n    r=0\n    for i in range(1,len(x)):\n        if i<=r:\n            z[i]=min(z[i-l],r-i+1)\n        while i+z[i]<len(x) and x[z[i]]==x[i+z[i]]:\n            z[i]+=1\n        if i+z[i]-1>r:\n            l,r=i,i+z[i]-1\n    return z\na=list(map(int,input('').split()))\nn,a,b=a[0],a[1],a[2]\ns=input('')\ndp=[0 for i in range(n)]\ndp[0]=a\nfor i in range(1,n):\n    t=s[:i+1]\n    dp[i]=dp[i-1]+a\n    q=f(t[::-1])\n    maxs=[0 for j in range(i+1)]\n    maxs[0]=q[i]\n    for j in range(1,i):\n        maxs[j]=max(maxs[j-1],q[i-j])\n    for j in range(i):\n        if maxs[j]>=i-j:\n            dp[i]=min(dp[i],dp[j]+b)\nprint(dp[len(dp)-1])\n            \n", "def f(x):\n    z=[0 for i in range(len(x))]\n    l=0\n    r=0\n    for i in range(1,len(x)):\n        if i<=r:\n            z[i]=min(z[i-l],r-i+1)\n        while i+z[i]<len(x) and x[z[i]]==x[i+z[i]]:\n            z[i]+=1\n        if i+z[i]-1>r:\n            l,r=i,i+z[i]-1\n    return z\na=list(map(int,input('').split()))\nn,a,b=a[0],a[1],a[2]\ns=input('')\ndp=[0 for i in range(n)]\ndp[0]=a\nfor i in range(1,n):\n    t=s[:i+1]\n    dp[i]=dp[i-1]+a\n    q=f(t[::-1])\n    maxs=[0 for j in range(i+1)]\n    maxs[0]=q[i]\n    for j in range(1,i):\n        maxs[j]=max(maxs[j-1],q[i-j])\n    for j in range(i):\n        if maxs[j]>=i-j:\n            dp[i]=min(dp[i],dp[j]+b)\nprint(dp[len(dp)-1])", "import collections\n\n# The first line contains three positive integers, separated by spaces:\n# n, a and b (1\u2264n,a,b\u22645000) \u2014 the length of the string, the cost to compress a one-character string\n# and the cost to compress a string that appeared before.\n\nn, a, b = list(map(int, input().split()))\n\n# The second line contains a single string s, consisting of n lowercase English letters.\n# s = collections.deque(input())\n# s.appendleft(0)\ns = \" \" + input()\n\n# maxn = 5010\nmaxn = n + 1\n\n# dp[0]=0,\n# dp[p]=min(a+dp[p\u22121],\n#           min(b+dp[k\u22121] where s[k,p] is a substring of s[1,k\u22121]))\ndp = [0x3f for _ in range(maxn)]\nv = [[0 for _c in range(maxn)] for _r in range(maxn)]\nNext = [0 for _n in range(maxn)]\n\n# for (int i = 1; i <= n; i++)\n# for (int j = i; j <= n; j++) {\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        if s[i] == s[j]:\n            v[i][j] = v[i - 1][j - 1] + 1\n# for row in v: print(row)\n\ndp[0] = 0\nfor i in range(1, n+1):\n    dp[i] = dp[i - 1] + a\n    for j in range(1, i):\n        t = min(i - j, v[j][i])\n        if t :\n            dp[i] = min(dp[i], dp[i - t] + b)\n\nprint(dp[n])\n"]
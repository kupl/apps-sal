["from heapq import heappush, heappop\nqueue = []\ndegree = []\ns = []\nans = []\nn = int(input())\nused = [False for i in range(n)]\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    degree.append(a)\n    s.append(b)\n    heappush(queue, (a, i))\nwhile queue:\n    el = heappop(queue)\n    vert = el[1]\n    if used[vert]:\n        continue\n    used[vert] = True\n    if degree[vert] == 0:\n        continue\n    other = s[vert]\n    ans.append((vert, other))\n    s[other] ^= vert\n    degree[other] -= 1\n    heappush(queue, (degree[other], other))\nprint(len(ans))\nfor el in ans:\n    print(el[0], el[1])\n\n", "#!/usr/bin/env python3\n\nfrom queue import PriorityQueue\n\nN = int(input())\n\nv = list()\nQ = list()\n\nfor i in range(N):\n    s, k = input().split()\n    v.append((int(s), int(k)))\n    if int(s) == 1:\n        Q.append(i)\n\nedge = list()\n\nwhile len(Q) > 0:\n    u = Q.pop()\n    if v[u][0] == 0:\n        continue\n    g = v[u][1]\n    edge.append((u, g))\n    v[g] = (v[g][0] - 1, v[g][1] ^ u)\n    if v[g][0] == 1:\n        Q.append(g)\n\nprint(len(edge))\nfor i, j in edge:\n    print(i, j)\n\n", "from collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    bydegree = defaultdict(set)\n    bys = defaultdict(set)\n    l = []\n    for i in range(n):\n        degree, s = list(map(int, input().split()))\n        bydegree[degree].add(i)\n        bys[s].add(i)\n        l.append((degree, s))\n    res = []\n    ones = bydegree[1]\n    while ones:\n        i = ones.pop()\n        degree_i, j = l[i]\n        degree_j, s = l[j]\n        res.append(' '.join((str(i), str(j))))\n        bydegree[degree_j].remove(j)\n        degree_j -= 1\n        bydegree[degree_j].add(j)\n        l[j] = (degree_j, s ^ i)\n    print(len(res))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nv = []\ndeg1 = []\ndegsum = 0\nhas_v = [True]*n\nfor i in range(n):\n    d, s = list(map(int, input().split()))\n    degsum += d\n    if d == 1: deg1.append(i)\n    if d == 0: has_v[i] = False\n    v.append([d, s])\n\n\nedge = []\nwhile deg1 != []:\n    f = deg1[0]\n    del deg1[0]\n    if has_v[f] is False: continue\n    v[f][0] -= 1\n    has_v[f] = False\n    t = v[f][1]\n    edge.append([f, t])\n    v[t][0] -= 1\n    v[t][1] ^= f\n    if v[t][0] == 1:\n        deg1.append(t)\n    elif v[t][0] == 0:\n        has_v[t] = False\n\nprint(degsum//2)\nfor f, t in edge: print(f, t)\n    \n    \n\n", "n = int(input())\nv = []\ndeg1 = []\ndegsum = 0\nhas_v = [True]*n\nfor i in range(n):\n    d, s = list(map(int, input().split()))\n    degsum += d\n    if d == 1: deg1.append(i)\n    if d == 0: has_v[i] = False\n    v.append([d, s])\n\n\nedge = []\nwhile deg1 != []:\n    f = deg1.pop()\n    if has_v[f] is False: continue\n    v[f][0] -= 1\n    has_v[f] = False\n    t = v[f][1]\n    edge.append([f, t])\n    v[t][0] -= 1\n    v[t][1] ^= f\n    if v[t][0] == 1:\n        deg1.append(t)\n    elif v[t][0] == 0:\n        has_v[t] = False\n\nprint(degsum//2)\nfor f, t in edge: print(f, t)\n    \n    \n\n", "n = int(input())\nv = []\ndeg1 = []\ndegsum = 0\nhas_v = [True]*n\nfor i in range(n):\n    d, s = list(map(int, input().split()))\n    degsum += d\n    if d == 1: deg1.append(i)\n    if d == 0: has_v[i] = False\n    v.append([d, s])\n\nprint(degsum//2)\n\nedge = []\nwhile deg1 != []:\n    f = deg1.pop()\n    if has_v[f] is False: continue\n    v[f][0] -= 1\n    has_v[f] = False\n    t = v[f][1]\n    print(f, t)\n    v[t][0] -= 1\n    v[t][1] ^= f\n    if v[t][0] == 1:\n        deg1.append(t)\n    elif v[t][0] == 0:\n        has_v[t] = False\n    \n    \n\n", "n = int(input())\nf = [list(map(int,input().split())) for i in range(n)]\ndeg1 = []\nedges = []\nfor i in range(n):\n\tif f[i][0] == 1:\n\t\tdeg1.append(i)\nwhile len(deg1):\n\ti = deg1.pop()\n\tif f[i][0] == 0:\n\t\tcontinue\n\tedges.append([i,f[i][1]])\n\tf[i][0] -= 1\n\tf[f[i][1]][0] -= 1\n\tf[f[i][1]][1] ^= i\n\tif f[f[i][1]][0] == 1:\n\t\tdeg1.append(f[i][1])\nprint(len(edges))\nfor e in edges:\n\tprint(e[0],e[1])", "def main():\n    n = int(input())\n    ones, l = set(), []\n    for i in range(n):\n        degree, s = list(map(int, input().split()))\n        if degree == 1:\n            ones.add(i)\n        l.append((degree, s))\n    res = []\n    while ones:\n        i = ones.pop()\n        degree_i, j = l[i]\n        degree_j, s = l[j]\n        res.append(' '.join((str(i), str(j))))\n        if degree_j == 1:\n            ones.remove(j)\n        else:\n            degree_j -= 1\n            if degree_j == 1:\n                ones.add(j)\n            l[j] = (degree_j, s ^ i)\n    print(len(res))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, l, ones, j = int(input()), [], [], 0\n    for i in range(n):\n        degree, s = list(map(int, input().split()))\n        l.append((degree, s))\n        j += degree\n        if degree == 1:\n            ones.append(i)\n    print(j // 2)\n    while ones:\n        i = ones.pop()\n        degree, j = l[i]\n        if degree == 1:\n            print(i, j)\n            degree, s = l[j]\n            s ^= i\n            degree -= 1\n            l[j] = degree, s\n            if degree == 1:\n                ones.append(j)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, l, ones = int(input()), [], []\n    for i in range(n):\n        degree, s = list(map(int, input().split()))\n        l.append((degree, s))\n        if degree == 1:\n            ones.append(i)\n    res = []\n    while ones:\n        i = ones.pop()\n        degree, j = l[i]\n        if degree == 1:\n            res.append(' '.join((str(i), str(j))))\n            degree, s = l[j]\n            s ^= i\n            degree -= 1\n            l[j] = degree, s\n            if degree == 1:\n                ones.append(j)\n    print(len(res))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict\n\n\ndef main2(n,d,s,info=0):\n    # correct, but slow\n    edges = []\n    m = mm = sum(d)//2\n    while m>0:\n        f = [x for x in zip(d,list(range(n))) if x[0]==1]\n        for _,i in f:\n            if d[i]==1:\n                d[i] = 0\n                d[s[i]] -= 1\n                s[s[i]] ^= i\n                m -= 1\n                edges.append([i,s[i]])\n    print(mm)\n    for u,v in edges:\n        print(u,v)\n\ndef main(n,d,s,info=0):\n    edges = []\n    curr = []\n    for i in range(n):\n        if d[i]==1: curr.append(i)\n    while len(curr):\n        i = curr.pop()\n        if d[i]==1:\n            d[i] = 0\n            d[s[i]] -= 1\n            s[s[i]] ^= i\n            edges.append([i,s[i]])\n            if d[s[i]] == 1:\n                curr.append(s[i])\n    print(len(edges))\n    for u,v in edges:\n          print(u,v)\n\ndef main_input(info=0):\n    n = int(input())\n    d,s = list(range(n)), list(range(n))\n    for i in range(n):\n        d[i],s[i] = list(map(int,input().split()))\n    main(n,d,s,info=info)\n\ndef __starting_point():\n    main_input()\n\n__starting_point()", "from collections import deque\nn = int(input())\nprocess = deque()\nvs = []\nfor i in range(n):\n\td, s = list(map(int, input().split()))\n\tif d == 1:\n\t\tprocess.append(i)\n\tvs.append((d, s))\nedges = []\nwhile process:\n\ta = process.popleft()\n\td, s = vs[a]\n\tif d == 0:\n\t\tcontinue\n\tdd, ss = vs[s]\n\tvs[s] = (dd - 1, ss ^ a)\n\tif dd == 2:\n\t\tprocess.append(s)\n\tedges.append((a, s))\nprint(len(edges))\nfor a, b in edges:\n\tprint(a, b)\n", "# 501C\n\n__author__ = 'artyom'\n\nread = lambda: map(int, input().split())\nn = int(input())\ngraph = [set() for _ in range(n)]\ndegrees = []\nadj = []\nqueue = []\nfor i in range(n):\n  degree, s = read()\n  degrees.append(degree)\n  adj.append(s)\n  if degree == 1:\n    queue.append(i)\n\ncounter = 0\nans = ''\nwhile queue:\n  v = queue.pop()\n  if degrees[v] == 0:\n    continue\n  s = adj[v]\n  for u in graph[v]:\n    s ^= u\n  graph[s].add(v)\n  graph[v].add(s)\n  counter += 1\n  ans += '\\n' + str(s) + ' ' + str(v)\n  degrees[s] -= 1\n  if degrees[s] == 1:\n    queue.append(s)\n\nprint(str(counter) + ans)", "# 501C\n\n__author__ = 'artyom'\n\nread = lambda: map(int, input().split())\nn = int(input())\ngraph = [set() for _ in range(n)]\ndegrees = []\nadj = []\nqueue = []\nfor i in range(n):\n  degree, s = read()\n  degrees.append(degree)\n  adj.append(s)\n  if degree == 1:\n    queue.append(i)\n\ncounter = 0\nans = ''\nwhile queue:\n  v = queue.pop()\n  if degrees[v] == 0:\n    continue\n  s = adj[v]\n  for u in graph[v]:\n    s ^= u\n  graph[s].add(v)\n  counter += 1\n  ans += '\\n' + str(s) + ' ' + str(v)\n  degrees[s] -= 1\n  if degrees[s] == 1:\n    queue.append(s)\n\nprint(str(counter) + ans)", "n, st, xors, sumst, buf = int(input()), [], [], 0, []\n\nfor i in range(n):\n    s=input().split()\n    st.append(int(s[0])); xors.append(int(s[1])); sumst+=st[i]\n    if st[i]==1:\n        buf.append(i)\n\nif sumst % 2 != 0:\n    print(\"0\"); return\n\nprint(sumst // 2 )\n\nwhile buf:\n    v=buf.pop()\n    if st[v]==1:\n        print(str(v)+\" \"+str(xors[v]))\n        xors[xors[v]]^=v; st[xors[v]]-=1\n        if st[xors[v]]==1:\n            buf.append(xors[v])\n", "from collections import deque\nn = int(input())\nprocess = deque()\nvs = []\nfor i in range(n):\n\td, s = list(map(int, input().split()))\n\tif d == 1:\n\t\tprocess.append(i)\n\tvs.append((d, s))\nedges = []\nwhile process:\n\ta = process.popleft()\n\td, s = vs[a]\n\tif d == 0:\n\t\tcontinue\n\tdd, ss = vs[s]\n\tvs[s] = (dd - 1, ss ^ a)\n\tif dd == 2:\n\t\tprocess.append(s)\n\tedges.append((a, s))\nprint(len(edges))\nfor a, b in edges:\n\tprint(a, b)\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\nstack_leaves = []\ndeg = [0]*n\ns = [0]*n\nsumm = 0\nfor i in range(n):\n    deg[i], s[i] = map(int, input().split())\n    summ += deg[i]\n    if deg[i] == 1:\n        stack_leaves.append(i)\nprint(summ // 2)\nwhile stack_leaves:\n    x = stack_leaves.pop()\n    if deg[x] != 0:\n        print(x, s[x])\n        deg[s[x]] -= 1\n        s[s[x]] ^= x\n        if deg[s[x]] == 1:\n            stack_leaves.append(s[x])", "n = int(input())\nverts = []\ne = []\nfor i in range(n):\n    inp = [*map(int, input().split(' '))]\n    verts.append([i] + inp)\n\nleavesQ = list(filter(lambda v: v[1] == 1, verts))\n\nwhile len(leavesQ) > 0:\n    l = leavesQ.pop()\n    if l[1] != 1:\n        continue\n    l2 = verts[l[2]]\n    e.append([l[0], l2[0]])\n\n    l[1] -= 1\n    l2[1] -= 1\n    l2[2] ^= l[0]\n    if l2[1] == 1:\n        leavesQ.append(l2)\n\nprint(len(e))\nfor [x, y] in e:\n    print(x, y)", "R = lambda: map(int, input().split())\nn = int(input())\ndegs, xors = [0] * (2 ** 16 + 1), [0] * (2 ** 16 + 1)\nedges = []\nfor curr in range(n):\n    degs[curr], xors[curr] = R()\nq = []\nfor curr in range(n):\n    if degs[curr] == 1:\n        q.append(curr)\nwhile q:\n    curr = q.pop()\n    if degs[curr] != 1:\n        continue\n    neighbor = xors[curr]\n    edges.append((min(curr, neighbor), max(curr, neighbor)))\n    degs[neighbor] -= 1\n    xors[neighbor] ^= curr\n    if degs[neighbor] == 1:\n        q.append(neighbor)\nfilter(lambda p: p[0] < p[1], edges)\nprint(len(edges))\nfor u, v in edges:\n    if u < v:\n        print(u, v)", "n = int(input())\nd = []\nv = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    v.append([a, b, i])\n\ng = dict()\nfor i in range(n+20):\n    g[i] = set()\nfor i in v:\n    if i[0] in g:\n        g[i[0]].add(i[2])\n    else:\n        g[i[0]] = set()\n        g[i[0]].add(i[2])\n\nans = []\n\nwhile len(g[1]) > 0:\n    i = 0\n    for x in g[1]:\n        i = x\n        break\n    a = v[i][2]\n    b = v[i][1]\n\n    g[v[a][0]].discard(v[a][2])\n    g[v[a][0]-1].add(v[a][2])\n    v[a][0] -= 1\n\n    g[v[b][0]].discard(v[b][2])\n    g[v[b][0]-1].add(v[b][2])\n    v[b][0] -= 1\n\n    v[b][1] ^= a\n    ans.append((a, b))\n\n\n\nprint(len(ans))\nfor i in ans:\n    print(*i)\n\n'''\n9\n2 5\n4 3\n7 6\n8 3\n5 0\n6 1\n3 9\n1 0\n9 0\n'''", "n = int(input())\nd = []\nv = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    v.append([a, b, i])\n\ng = dict()\nfor i in range(n+20):\n    g[i] = set()\nfor i in v:\n    if i[0] in g:\n        g[i[0]].add(i[2])\n    else:\n        g[i[0]] = set()\n        g[i[0]].add(i[2])\n\nans = []\n\nwhile len(g[1]) > 0:\n    i = g[1].pop()\n    a = v[i][2]\n    b = v[i][1]\n\n    g[v[a][0]].discard(v[a][2])\n    g[v[a][0]-1].add(v[a][2])\n    v[a][0] -= 1\n\n    g[v[b][0]].discard(v[b][2])\n    g[v[b][0]-1].add(v[b][2])\n    v[b][0] -= 1\n\n    v[b][1] ^= a\n    ans.append((a, b))\n\n\n\nprint(len(ans))\nfor i in ans:\n    print(*i)\n\n'''\n9\n2 5\n4 3\n7 6\n8 3\n5 0\n6 1\n3 9\n1 0\n9 0\n'''", "n=int(input())\nl=[]\nstack=[]\nfor i in range(n):\n    d,s=map(int,input().split())\n    if d==1:\n        stack.append(i)\n    l.append([d,s])\nc=0\nedges=''\nwhile stack:\n    i=stack.pop(0)\n    d,s=l[i]\n    if d==0:\n        continue\n    dd,ss=l[s]\n    if dd==2:\n        stack.append(s)\n    l[s]=[dd-1,ss^i]\n    edges+=str(i)+' '+str(s)+'\\n'\n    c+=1\nprint(c)\nprint(edges)", "n = int(input())\ndeg2vs = {}\nss = [0] * n\ndegs = [0] * n\nfor i in range(n):\n    degs[i], ss[i] = list(map(int, input().split()))\n    if degs[i] > 0:\n        if degs[i] not in deg2vs:\n            deg2vs[degs[i]] = set()\n        deg2vs[degs[i]].add(i)\nedges = []\nwhile len(deg2vs) != 0:\n    leaves = deg2vs.pop(1)\n    for leaf in leaves:\n        if degs[leaf] == 0:\n            continue\n        v = ss[leaf]\n        edges.append((leaf, v))\n        v_deg = degs[v]\n        if v_deg > 1:\n            deg2vs[v_deg].remove(v)\n            if len(deg2vs[v_deg]) == 0:\n                deg2vs.pop(v_deg)\n\n        ss[v] = ss[v] ^ leaf\n        degs[v] -= 1\n        if degs[v] > 0:\n            if degs[v] not in deg2vs:\n                deg2vs[degs[v]] = set()\n            deg2vs[degs[v]].add(v)\nprint(len(edges))\nfor edge in edges:\n    print(edge[0], edge[1])\n\n\n\n\n", "n = int(input())\nss = [0] * n\ndegs = [0] * n\nleaves = []\nfor i in range(n):\n    degs[i], ss[i] = list(map(int, input().split()))\n    if degs[i] == 1:\n        leaves.append(i)\n\nedges = []\nwhile len(leaves) != 0:\n    leaf = leaves.pop()\n    if degs[leaf] == 0:\n        continue\n    v = ss[leaf]\n    edges.append((leaf, v))\n    v_deg = degs[v]\n\n    ss[v] = ss[v] ^ leaf\n    degs[v] -= 1\n    if degs[v] == 1:\n        leaves.append(v)\n\nprint(len(edges))\nfor edge in edges:\n    print(edge[0], edge[1])\n\n\n\n\n"]
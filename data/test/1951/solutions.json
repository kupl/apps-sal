["import sys\nimport heapq\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    S = [[x for x in input().split()] for _ in range(2 * N)]\n\n    q = []\n    ans = []\n    for s in S[::-1]:\n        if s[0] == \"-\":\n            heapq.heappush(q, int(s[1]))\n        else:\n            if q:\n                c = heapq.heappop(q)\n                ans.append(c)\n            else:\n                print(\"NO\")\n                return\n\n    ans2 = ans[::-1]\n\n    q = []\n    current = 0\n    for s in S:\n        if s[0] == \"-\":\n            c = heapq.heappop(q)\n            if c != int(s[1]):\n                print(\"NO\")\n                return\n        else:\n            heapq.heappush(q, ans2[current])\n            current += 1\n\n    print(\"YES\")\n    print(*ans2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict as _defaultdict\nimport sys as _sys\n\n\ndef main():\n    n, = _read_ints()\n    events = _read_events(2 * n)\n    try:\n        result = restore_shurikens_order(events, n)\n    except ValueError:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*result)\n\n\ndef _read_events(events_n):\n    for i_event in range(events_n):\n        event_type, *event_args = _read_line().split(' ')\n        if event_type == '+':\n            assert len(event_args) == 0\n            event = (PLACE_SHURIKEN_ID,)\n        else:\n            assert event_type == '-'\n            assert len(event_args) == 1\n            event = (BUY_SHURIKEN_ID, int(event_args[0]))\n        yield event\n\n\nPLACE_SHURIKEN_ID = 0\nBUY_SHURIKEN_ID = 1\n\n\ndef restore_shurikens_order(events, shurikens_n):\n    result = [None] * shurikens_n\n    \n    limits_tree = [0] * (shurikens_n + 1 + 1)\n    limits_counter = _defaultdict(int)\n    sources_by_limits = [[] for limit in range(shurikens_n+1)]\n    \n    next_placement_index = 0\n    \n    for event in events:\n        \n        if event[0] == PLACE_SHURIKEN_ID:\n            limit = 1\n            _fenwick_add(limits_tree, limit, 1)\n            sources_by_limits[limit].append(next_placement_index)\n            limits_counter[limit] += 1\n            next_placement_index += 1\n        \n        else:\n            assert event[0] == BUY_SHURIKEN_ID\n            item_to_buy = event[1]\n            if _fenwick_prefix_sum(limits_tree, item_to_buy) == 0:\n                raise ValueError(\"unable to restore shurikens order\")\n            \n            limits_can_be_removed_n = _fenwick_prefix_sum(limits_tree, item_to_buy)\n            \n            min_limit_to_remove = 1\n            max_limit_to_remove = item_to_buy\n            while min_limit_to_remove != max_limit_to_remove:\n                mid_limit_to_remove = (min_limit_to_remove + max_limit_to_remove) >> 1\n                if limits_can_be_removed_n \\\n                        - _fenwick_prefix_sum(limits_tree, mid_limit_to_remove) == 0:\n                    max_limit_to_remove = mid_limit_to_remove\n                else:\n                    min_limit_to_remove = mid_limit_to_remove + 1\n            limit_to_remove = min_limit_to_remove\n            \n            _fenwick_add(limits_tree, limit_to_remove, -1)\n            result[sources_by_limits[limit_to_remove].pop()] = item_to_buy\n            limits_counter[limit_to_remove] -= 1\n            \n            moved_limits = _fenwick_move_all_before_to(limits_tree, item_to_buy)\n            for limit in moved_limits:\n                moved_n = limits_counter[limit]\n                del limits_counter[limit]\n                limits_counter[item_to_buy] += moved_n\n                assert moved_n > 0\n                sources_from = sources_by_limits[limit]\n                sources_to = sources_by_limits[item_to_buy]\n                assert len(sources_from) == moved_n\n                if len(sources_from) > len(sources_to):\n                    sources_to, sources_from = sources_from, sources_to\n                    sources_by_limits[item_to_buy], sources_by_limits[limit] \\\n                        = sources_to, sources_from\n                sources_to.extend(sources_from)\n                sources_from.clear()\n    \n    return result\n\n\ndef _fenwick_prefix_sum(tree, index):\n    index += 1\n    result = 0\n    while index != 0:\n        result += tree[index]\n        index -= index & (-index)\n    return result\n\n\ndef _fenwick_add(tree, index, value):\n    index += 1\n    while index < len(tree):\n        tree[index] += value\n        index += index & (-index)\n\n\ndef _fenwick_move_all_before_to(tree, index_arg):\n    index_arg += 1\n    planned_additions = []\n    \n    index = index_arg\n    while index < len(tree):\n        father_last_i = index - (index & (-index))\n        segment_begin = father_last_i + 1\n        planned_additions.append((index, _fenwick_prefix_sum(tree, segment_begin - 1 - 1)))\n        index += index & (-index)\n    \n    queue_to_make_segments_zero = []\n    i = index_arg - 1\n    while i != 0:\n        if tree[i] != 0:\n            queue_to_make_segments_zero.append(i)\n        i -= i & (-i)\n    \n    i_queue = 0\n    while i_queue < len(queue_to_make_segments_zero):\n        i = queue_to_make_segments_zero[i_queue]\n        # Make all elements zero in the segment of i\n        # Example:\n        # i = 11 0100 0000\n        # j = 11 0010 0000  (initial)\n        # j = 11 0011 0000\n        # j = 11 0011 1000\n        # j = 11 0011 1100\n        # j = 11 0011 1110\n        # j = 11 0011 1111\n        sum_in_that_segment_except_last = 0\n        last_i_digit = i & (-i)\n        j = i - (last_i_digit >> 1)\n        if j != i:\n            if tree[j] != 0:\n                queue_to_make_segments_zero.append(j)\n                sum_in_that_segment_except_last += tree[j]\n            while j & 1 != 1:\n                j += (j & (-j)) >> 1\n                if tree[j] != 0:\n                    queue_to_make_segments_zero.append(j)\n                    sum_in_that_segment_except_last += tree[j]\n        if i & 1 == 1 or tree[i] - sum_in_that_segment_except_last != 0:\n            yield i - 1\n        tree[i] = 0\n        \n        i_queue += 1\n    \n    for index, value_to_add in planned_additions:\n        tree[index] += value_to_add\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["n,s = map(int,input().split())\nA = list(map(int,input().split()))\nif A[s-1] != 0:\n    per = 1\n    A[s-1] = 0\nelse:\n    per = 0\nA.sort()\nmaxs = max(A)\nans = [0] * (maxs + 1)\nanswer = maxs + 1\no = -1\nfor j in range(n):\n    if A[j] == 0:\n        o += 1\n    \n    if ans[A[j]] == 0:\n        ans[A[j]] = 1\n        answer -= 1\nan = per + max(o, answer)\n\nfor j in range(n-2,-1,-1):\n    \n    for t in range(A[j+1]-1, A[j] -1,-1):\n        if ans[t] == 0:\n            answer -= 1\n    \n    an = min(an, per + max(answer,o+n - j - 1))\nprint(an)", "\"\"\" This is a solution to the problem Subordinates on codeforces.com\n    \n    There is a DAG with n nodes, pointing towards the root, without further constraints. \n    Given: for each node, a number signifying the count of (direct and indirect) predecessors, and the ID of root s.\n    Some of these counts might be wrong. Give the minimum amount of wrong counts.\n    \n    For details, see\n    http://codeforces.com/problemset/problem/729/E\n\"\"\"\n\n#Idea: count = level of DAG. Check constraints: root has 0 predecessors, level 0 has only one count, each level to the last has be > 0\n\nfrom sys import stdin\n\n#lines = open(\"input.txt\", 'r').readlines()\nlines = stdin.readlines()\n\nn, s = map(int, lines[0].split())\ncounts = list(map(int, lines[1].split()))\n    \ntotalwrong = 0\nif counts[s-1] > 0: # root has to be 0\n    totalwrong += 1\n    counts[s-1] = 0\n     \nmaxlevel = max(counts)    \n# count number of nodes on levels\nlevelcount = [0] * (max(counts) + 1)\n\nfor c in counts:\n    levelcount[c] += 1\n    \ncurwrong = levelcount[0] - 1 # only one root\nlevelcount[0] = 1\ntotalwrong += curwrong \n\ncurlevel = 0\nwhile curlevel <= maxlevel:\n    lc = levelcount[curlevel]\n    if lc == 0:         # a mistake\n        if curwrong > 0: # still mistakes available, just use them to fill\n            curwrong -= 1\n            levelcount[curlevel] = 1\n        else: # else fill from last level\n            levelcount[maxlevel] -= 1\n            levelcount[curlevel] = 1        \n            totalwrong += 1\n            while levelcount[maxlevel] == 0:\n                maxlevel -= 1       # as levelcount[curlevel] = 1, this aborts at some point\n    curlevel += 1\nprint(totalwrong)", "f = lambda: map(int, input().split())\nn, s = f()\nc = [0] * n\nt = list(f())\nfor i in t: c[i] += 1\nk = t[s - 1]\nc[k] -= 1\nd = c[0]\nc += [d]\nd += k > 0\ni, j = 1, n\nwhile i < j:\n    if c[i]: i += 1\n    elif c[j]:\n        c[j] -= 1\n        i += 1\n        d += j < n\n    else: j -= 1\nprint(d)", "[n, s] = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\n\nmistakes = 0\n\nmistakes += (a[s-1] is not 0)\na[s - 1] = 0\n\nnumSuperiors = [0]*(2*100000+100)\n\nfor superiors in a:\n    numSuperiors[superiors] += 1\n\ncachedMistakes = 0\n\nwhile numSuperiors[0] != 1:\n    cachedMistakes += 1\n    numSuperiors[0] -= 1\n\nrightIndex = len(numSuperiors) - 1\nleftIndex = 0\nwhile True:\n    while True:\n        if numSuperiors[leftIndex] == 0 and cachedMistakes != 0:\n            numSuperiors[leftIndex] += 1\n            cachedMistakes -= 1\n            mistakes += 1\n        if numSuperiors[leftIndex] == 0:\n            break\n        leftIndex += 1\n    while numSuperiors[rightIndex] == 0:\n        rightIndex -= 1\n    if leftIndex >= rightIndex:\n        break\n    numSuperiors[rightIndex] -= 1\n    cachedMistakes += 1\n\nprint(mistakes)", "n, root = map(int, input().split())\na = list(map(int, input().split()))\n\ndef push(d, x, val):\n    if x not in d:\n        d[x] = 0\n    d[x]+=val\n    \n    if d[x]==0:\n        del d[x]\n    \nd = {}\nfor x in a:\n    push(d, x, 1)\n\nmin_  =  0\nroot -=  1\ninf   = 9999999\n\nif a[root] != 0:\n    min_+=1\n    push(d, a[root], -1)\n    push(d, 0, 1)\n    \nif 0 in d and d[0] > 1:\n    add  = d[0] - 1\n    min_+=add\n    push(d, inf, add)\n    d[0] = 1\n    \nS   = [[val, num] for val, num in sorted(d.items(), key = lambda x:x[0])] \n#print(min_, S)\ncur = -1\ni   =  0\n\nwhile i < len(S):\n    remain = S[i][0] - (cur+1)\n    \n    while remain > 0:\n        val, num = S[-1]\n        \n        if val == S[i][0]:\n            if val != inf:\n                min_ += min(remain, num)\n            break   \n        else:\n            add     = min(num, remain)\n            remain -= add\n            \n            if val != inf:\n                min_   += add\n            \n            if num == add:\n                S.pop()\n            else:    \n                S[-1][1] -= add\n        \n    cur=S[i][0]\n    i+=1\n    \nprint(min_)"]
["#!/usr/bin/env python3\n\nimport numpy as np\nfrom scipy.special import comb\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na_sum = np.cumsum(a)\n\n\nre_list = {}\nre_list[0] = 1\nfor i in a_sum:\n    re = i % m\n    if re in re_list:\n        re_list[re] += 1\n    else:\n        re_list[re] = 1\n\n# print(re_list)\nans = 0\nfor value in list(re_list.values()):\n    ans += comb(value, 2, exact=True)\n\nprint(ans)\n", "from itertools import accumulate\nn, m = map(int, input().split())\na = [0]+list(accumulate(map(int, input().split())))\ndi = {}\nfor i in a:\n    i %= m\n    if i not in di:\n        di[i] = 0\n    di[i] += 1\nans = 0\nfor i in di.values():\n    ans += i*(i-1)//2\nprint(ans)", "import collections\n    \nn, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nans_list = [0] * (n + 1)\nfor i in range(1, n + 1):\n  A[i - 1] %= m\n  ans_list[i] = (ans_list[i - 1] + A[i - 1]) % m\nans_list.pop(ans_list[0])\nans_list = dict(collections.Counter(ans_list))\n  \n#print(A)\n#print(ans_list)\ncount = 0\nif 0 in ans_list:\n  count = ans_list[0]\n#print(count)\nfor v in list(ans_list.values()):\n  #print(v)\n  if v != 1:\n    count +=  v * (v - 1) / 2\n    \nprint((int(count)))   \n    \n    \n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\ntmp=0\nca=[tmp]\nfor ai in a:\n  tmp+=ai\n  tmp%=m\n  ca.append(tmp)\nfrom collections import Counter\ncnt_ca=Counter(ca)\nans=0\nfor c in cnt_ca.values():\n  ans+=(c*(c-1))//2\nprint(ans)", "import sys\nimport collections\ninput = sys.stdin.readline\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n\n    B = [0]\n    for a in A:\n        B.append((B[-1] + a) % M)\n\n    c = collections.Counter(B)\n    ans = 0\n    for k in list(c.keys()):\n        if c[k] <= 1:\n            continue\n        ans += (c[k] * (c[k] - 1)) // 2\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "N, M = map(int, input().split())\nL = list(map(int, input().split()))\n\nif N == 1:\n\tif L[0]%M == 0:\n\t\tprint(1)\n\t\treturn\n\telse:\n\t\tprint(0)\n\t\treturn\n\nfor i in range (0, N):\n\tL[i] = L[i]%M\n\ncount = 0\n\nfor i in range (1, N):\n\tL[i]= (L[i-1]+L[i])%M\n\nL = sorted(L)\n\nalreadythere = []\nimport collections\n\ncnt = collections.Counter()\nfor number in L:\n\tcnt[number] += 1\n\nL = set(L)\n\nfor i in L:\n\tif i == 0:\n\t\tK = cnt[i]\n\t\tcount+=(int(K*(K-1)/2)+K)\n\telse:\n\t\tK = cnt[i]\n\t\tcount+=int(K*(K-1)/2)\n\nprint(count)", "import numpy as np\nfrom collections import Counter\n\nn,m = map(int,input().split())\n\na = np.array([0]+list(map(int,input().split())),dtype=np.int64)\na = np.mod(a.cumsum(),m)\n\nc = Counter(a)\n\nans = 0\n\nfor i in c.values():\n    ans += i*(i-1)//2\n\nprint(ans)", "from collections import Counter\n\nN, M = list(map(int, input().split()))\nA = [int(i)%M for i in input().split()]\n\nB = [0] * (N+1)\nfor i in range(N):\n  B[i+1] = (B[i]+A[i]) % M\n  \ncounter = dict(Counter(B))\nans = 0\nfor num in counter:\n  ans += (counter[num]-1) * counter[num] // 2\n\nprint(ans)\n\n", "import itertools, collections\nN, M = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\ncum = [0] + [c % M for c in itertools.accumulate(A)]\ncnt = collections.Counter(cum)\nans = sum(v * (v - 1) // 2 for v in list(cnt.values()))\nprint(ans)\n", "n,m=map(int,input().split())\na=[0]+list(map(int,input().split()))\na[0]%=2\nfor i in range(n):\n\ta[i+1]+=a[i]\n\ta[i+1]%=m\na.sort()\nans=0\ncnt=1\nfor i in range(n):\n\tif a[i]==a[i+1]:\n\t\tcnt+=1\n\telse:\n\t\tans+=cnt*(cnt-1)//2\n\t\tcnt=1\nans+=cnt*(cnt-1)//2\nprint(ans)", "import sys\nimport math\nfrom collections import deque\nfrom collections import Counter\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\ndef make_cumulative(A):\n    C = [0] * (len(A) + 1)\n    for i, a in enumerate(A):\n        i += 1\n        C[i] = C[i - 1] + a\n    return C\n\n\ndef main():\n\tN, M = NMI()\n\tA = NLI()\n\tC = make_cumulative(A)\n\tC = [c%M for c in C]\n\tC = Counter(C)\n\tans = 0\n\tfor c, x in C.items():\n\t\tif x >= 2:\n\t\t\tans += x * (x-1) // 2\n\tprint(ans)\n\t\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    A_sum = [0]\n    D = defaultdict(int)\n    D[A_sum[-1]] += 1\n    for a in A:\n        A_sum.append((A_sum[-1] + a) % m)\n        D[A_sum[-1]] += 1\n\n    res = 0\n    for v in list(D.values()):\n        res += v * (v - 1) // 2\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import Counter\n\nn, m = map(int, input().split())\na = [int(i)%m for i in input().split()]\nfor i in range(1,n):\n    a[i] = (a[i] + a[i-1])%m\na = [0] + a\na = Counter(a)\nret = 0\nfor i, v in a.items():\n    ret += v*(v-1)//2\nprint(ret)", "from collections import defaultdict\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    A = list(map(int, input().split(' ')))\n    d = defaultdict(int)\n    d[0] += 1\n    cs = 0\n    for i in range(N):\n        cs += A[i]\n        cs %= M\n        d[cs] += 1\n    ans = 0\n    for v in d.values():\n        ans += v * (v - 1) // 2\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    N, M = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n\n    d = {0: 1}\n\n    ans = 0\n\n    t = 0\n    for x in A:\n        t = (t + x) % M\n        ans += (cnt := d.get(t, 0))\n        d[t] = cnt + 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# D - Candy Distribution\n# https://atcoder.jp/contests/abc105/tasks/abc105_d\n\nfrom collections import Counter\n\nn, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\naccr = [0] * (n + 1)\n\nfor i in range(n):\n  accr[i + 1] = accr[i] + A[i]\n\nli = [i % m for i in accr]\n\nC = Counter(li)\n\nans = 0\nfor v in list(C.values()):\n  if v > 1:\n    ans += v * (v - 1) // 2\n\nprint(ans)\n", "from itertools import accumulate\nfrom collections import Counter\nN, M = map(int, input().split())\nAs = list(map(int, input().split()))\n\ndef f(a, b):\n    return (a+b)%M\ncumsum = list(accumulate([0]+As, f))\n\nanswer = 0\nfor k, v in Counter(cumsum).items():\n    answer += v * (v-1) // 2\n\nprint(answer)", "n, m = list(map(int, input().split()))\nA = tuple(map(int, input().split()))\n\nfrom itertools import accumulate\nAS = [0] + list(accumulate(A))\ncounts = dict()\nfor a in AS:\n    r = a%m\n    counts.setdefault(r, 0)\n    counts[r] += 1\n\nans = 0\nfor k, v in list(counts.items()):\n    ans += v*(v-1)//2\nprint(ans)\n", "import sys\nfrom itertools import accumulate\nfrom collections import Counter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *A = list(map(int, read().split()))\n\n    B = [0]\n    B.extend(accumulate(A))\n    B = [b % M for b in B]\n\n    counter = Counter(B)\n    ans = 0\n    for v in list(counter.values()):\n        ans += v * (v - 1) // 2\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\ndef cmb(n, r):\n    \"\"\"\u7d44\u307f\u5408\u308f\u305b\"\"\"\n    import math\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, M, A):\n    A_sum = [0]\n    A_sum_mod_map = {0: 1}\n    for a in A:\n        A_sum.append(A_sum[-1] + a)\n        tmp1 = A_sum[-1] % M\n        A_sum_mod_map.setdefault(tmp1, 0)\n        A_sum_mod_map[tmp1] += 1\n    ans = 0\n    for v in list(A_sum_mod_map.values()):\n        ans += cmb(v, 2)\n    print(ans)\n\n\ndef __starting_point():\n    # S = input()\n    # N = int(input())\n    N, M = list(map(int, input().split()))\n    A = [int(i) for i in input().split()]\n    # B = [int(i) for i in input().split()]\n    # AB = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, M, A)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "#!/usr/bin/env python3\n\nimport sys\n# import math\n# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits\n# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)\n# from operator import itemgetter              # itemgetter(1), itemgetter('key')\n# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()\n# from collections import defaultdict          # subclass of dict. defaultdict(facroty)\nfrom collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)\n# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).\n# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).\n# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])\n# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]\n# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]\n# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])\n# from itertools import combinations, combinations_with_replacement\nfrom itertools import accumulate             # accumulate(iter[, f])\n# from functools import reduce                 # reduce(f, iter[, init])\n# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)\n# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).\n# from copy import deepcopy                    # to copy multi-dimentional matrix without reference\n# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)\n\n\ndef main():\n    mod = 1000000007                # 10^9+7\n    inf = float('inf')              # sys.float_info.max = 1.79...e+308\n    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19\n    sys.setrecursionlimit(10**6)    # 1000 -> 1000000\n    def input(): return sys.stdin.readline().rstrip()\n    def ii():    return int(input())\n    def mi():    return list(map(int, input().split()))\n    def mi_0():  return [int(x)-1 for x in input().split()]\n    def lmi():   return list(map(int, input().split()))\n    def lmi_0(): return list([int(x)-1 for x in input().split()])\n    def li():    return list(input())\n    \n    \n    n, m = mi()\n    L = list([int(x) % m for x in input().split()])\n    # accum[i] -> (sum(L[0:i]) % m)\n    # accum[j] - accum[i] (j > i) -> (sum(L[i:j]) % m)\n    accum = [0] + list(accumulate(L, lambda x, y: (x + y) % m))\n    # print(accum)\n    \n    # accum[i] = accum[j] \u306a\u308b i < j \u306e\u7d44\u307f\u5408\u308f\u305b\u306e\u500b\u6570\u304c\u7b54\u3048\n    ans = 0\n    for _, duplicate_num in list(Counter(accum).items()):\n        ans += duplicate_num * (duplicate_num - 1) // 2\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\nalis = list(map(int, input().split()))\nmy_dict = dict()\n\ntmp = 0\n\nfor item in alis:\n    tmp += item\n    tmp %= m\n    if tmp in my_dict:\n        my_dict[tmp] += 1\n    else:\n        my_dict[tmp] = 1\n\nret = 0\n\nfor item in my_dict:\n    if item == 0:\n        val = my_dict[item]\n        ret += val * (val - 1) // 2 + val\n    else:\n        val = my_dict[item]\n        ret += val * (val - 1) // 2\n\nprint(ret)\n", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# Summarize count of factor within list -- START --\ndef summarizeList(l):\n  sl=sorted(l)\n\n  a=sl[0]\n  c=1\n  res=[]\n\n  for x in sl[1:]:\n    if x==a:\n      c+=1\n    else:\n      res.append([a,c])\n      a=x\n      c=1\n  res.append([a,c])\n\n  return res\n# Summarize count of factor within list --- END ---\n\ndef main():\n  n,m=LI()\n  l=LI()\n\n  rui=[0]\n  for x in l:\n    y=rui[-1]+x\n    rui.append(y%m)\n\n  # print(rui)\n\n  sl=summarizeList(rui)\n  ans=0\n  for x,c in sl:\n    ans+=c*(c-1)//2\n\n  return ans\n\n# main()\nprint((main()))\n", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nD = {0:1}\na = 0\nans = 0\n\nfor n in range(N):\n  a = (a+A[n])%M\n  ans+=D.get(a,0)\n  D[a] = 1+D.get(a,0)\n\nprint(ans)", "import sys\nreadline = sys.stdin.readline\nfrom collections import Counter\n\ndef main():\n    N, M = map(int, readline().rstrip().split())\n    A = list(map(int, readline().rstrip().split()))\n    pre = 0\n    B = [0]\n    for a in A:\n        pre += a\n        B.append(pre)\n    \n    B = [b % M for b in B]\n    c = Counter(B)\n    res = 0\n    for cnt in c.values():\n        res += cnt * (cnt-1) // 2\n\n    print(res)    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nB = {}\ns = 0\nans = 0\nB[0] = 1\nfor a in A:\n    s = (s + a) % M\n    ans += B.get(s, 0)\n    B[s] = B.get(s, 0) + 1\n\nprint(ans)\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\ntable={0:0}\ns=a[0]%m\ntable[s]=1\nfor i in range(1,n):\n    s=(s+a[i])%m\n    if s in table:\n        table[s]+=1\n    else:\n        table[s]=1\nans=0\nfor i in table.values():\n    ans+=(i*(i-1))//2\nprint(ans+table[0])", "import collections\n\nn,m=map(int,input().split())\narr=[0]+list(map(int,input().split()))\ncnt=collections.defaultdict(int)\ncnt[0]+=1\nfor i in range(1,n+1):\n  arr[i]+=arr[i-1]\n  arr[i]%=m\n  cnt[arr[i]]+=1\nans=0\nfor key in cnt.keys():\n  ans+=(cnt[key]*(cnt[key]-1))//2\nprint(ans)", "from collections import Counter\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\naccA = [0] * (N + 1)\nfor i, a in enumerate(A, start=1):\n    accA[i] = (accA[i - 1] + a) % M\n\ncntS = Counter()\nans = 0\nfor s in accA:\n    ans += cntS[s]\n    cntS[s] += 1\n\nprint(ans)\n", "from itertools import accumulate\nfrom collections import defaultdict\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nacc = [0]+list(accumulate(A,lambda x,y:x+y))\nd = defaultdict(list)\nfor i in range(len(acc)):\n    d[acc[i] % M].append(i)\nans = 0\nfor l in map(len,d.values()):\n    ans += l*(l-1)//2\nprint(ans)", "import sys\nfrom collections import Counter\ndef input():\n    return sys.stdin.readline()[:-1]\ndef main():\n    N, M = list(map(int,input().split()))\n    A = list(map(int,input().split()))\n    S = [0]*N\n    S[0] = A[0]%M\n    for k in range(1,N):\n        S[k] = (S[k-1] + A[k])%M\n    C = Counter(S)\n    C[0] += 1\n    ans = 0\n    for e in C:\n        ans += (C[e]*(C[e]-1))//2\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nn,m = map(int,input().split())\na = list(map(int,input().split()))\n\"\"\"\na\u306e\u9023\u7d9a\u5217\u304cM\u306e\u500d\u6570\u3067\u3042\u308c\u3070\u3044\u3044\ndp[j] := j\u306e\u500d\u6570\u306b\u306a\u308b\u7dcf\u6570.\n\"\"\"\ndp = defaultdict(lambda: 0)\ndp[0] = 1\ntmp = 0\nans = 0\nfor i in range(n):\n\ttmp += a[i]\n\tans += dp[tmp%m]\n\tdp[tmp%m] += 1\nprint(ans)", "N, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nAA = []\na_dict = {}\nans = 0\nfor a in A:\n  num = a%M\n  if len(AA) > 0:\n    num = (num+AA[-1])%M\n  if not num in a_dict:\n    a_dict[num] = 1\n  else:\n    a_dict[num] += 1\n  if num == 0:\n    ans += 1\n  AA.append(num)\n\ndef comb(n):\n  return n*(n-1)//2\n\nfor k, v in list(a_dict.items()):\n  if v >= 2:\n    ans += comb(v)\nprint(ans)\n", "\nfrom collections import Counter\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nB = [0]\nfor i in range(N):\n  B.append((B[-1]+A[i])%M)\n\nC = Counter(B)\nans = 0\n\nfor mod, c in C.most_common():\n  ans += c*(c-1)//2\n\nprint(ans)", "from itertools import accumulate\nfrom collections import Counter\nn,m=map(int,input().split())\ns=[0]+list(map(lambda x:x%m,list(accumulate(list(map(int,input().split()))))))\nans=0\nfor i in Counter(s).values():\n    ans+=(i*(i-1)//2)\nprint(ans)", "from collections import *\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nS = [0] * (N+1)\n\nfor i in range(N):\n    S[i+1] = (S[i] + A[i]) % M\n\nc = Counter()\n\nans = 0\n\nfor i in range(N+1):\n    ans += c[S[i]]\n    c[S[i]] += 1\n\nprint(ans)", "# \u982d\u306b0\u3092\u8db3\u3057\u3066\u3001\u7d2f\u7a4d\u548c\u306emod M\u3092\u53d6\u308b\n# \u5404mod M\u306e\u500b\u6570\u306b\u5bfe\u3057\u3066\u3001\u500b\u6570C2\u3092\u53d6\u3063\u3066\u8db3\u3057\u5408\u308f\u305b\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nA = [0] + list(map(int,readline().split()))\n\nfor i in range(1,len(A)):\n  A[i] = A[i - 1] + A[i]\n  \nA = list(map(lambda x:x % M, A))\n\nfrom collections import Counter\nc = Counter(A)\n\nans = 0\nfor v in c.values():\n  ans += (v * (v - 1)) // 2\n  \nprint(ans)", "from itertools import accumulate\nimport collections\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\ndic = collections.defaultdict(int)\nP = list(accumulate(A))\nfor p in P:\n    dic[p%M] += 1\nans = 0\nfor key,val in dic.items():\n    if key==0: ans += val # \u3042\u307e\u308a0\u306e\u6642\u306f\u305d\u308c\u81ea\u4f53\u3082\u30ab\u30a6\u30f3\u30c8\n    ans += val*(val-1)//2\nprint(ans)", "n,m=map(int,input().split())\na=list(map(int,input().split()))\n\nfor i in range(1,n):\n  a[i]+=a[i-1]\na=[0]+a\nb=[q%m for q in a]\nfrom collections import Counter\nc=Counter(b).items()\nans=0\nfor i,j in c:\n  ans+=(j*(j-1)//2)\nprint(ans)", "from collections import Counter\n \nn, m = map(int, input().split())\nA = list(map(int, input().split()))\n \nB = [0] * (n + 1)\n \nfor i in range(n):\n  B[i + 1] = B[i] + A[i] # B\u306fA\u306e\u7d2f\u7a4d\u548c\n\nli = [i % m for i in B] # \u305d\u308c\u3092M\u3067\u5272\u3063\u305f\u4f59\u308a\u304cli\n\nC = Counter(li) # \u4f59\u308a\u304c\u540c\u3058\u3082\u306e\u306e\u500b\u6570\u304c2\u3064\u4ee5\u4e0a\u3042\u308b\u969b\u3001\u305d\u306e2\u3064\u306e\u7d44\u307f\u5408\u308f\u305b\u306b\u3088\u3063\u3066\u3001\u5272\u308a\u5207\u308c\u308b\u548c\u306e\u7d44\u307f\u5408\u308f\u305b\u500b\u6570\u304c\u6c42\u307e\u308b\n\nans = 0\nfor v in C.values():\n  if v > 1:\n    ans += v * (v - 1) // 2\n \nprint(ans)", "from sys import stdin\n\ninput = stdin.readline\n\nn,m = map(int,input().split(\" \"))\n\narr = list(map(int,input().split(\" \")))\n\ndicti= {0:1}\nsumi = 0\n\nfor i in range(n):\n\tsumi += arr[i]\n\tsumi = sumi%m\n\tdicti[sumi] = dicti.get(sumi,0)+1\n\nanswer = 0\nfor i in dicti:\n\tval = dicti[i]\n\n\ttoadd = val*(val-1)\n\ttoadd = toadd//2\n\n\tanswer += toadd\nprint(answer)", "from collections import Counter\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\n\ndef nC2(n):\n  return n*(n-1)//2\n\ncum=[A[0]%M]\nfor i in range(1,N):\n  cum.append((cum[-1]+A[i])%M)\n\nc = Counter(cum)\n\nans=c[0]\nfor k in c.keys():\n  ans += nC2(c[k])\n\nprint(ans)", "N,M=map(int, input().split())\nA=list(map(int, input().split()))\nimport numpy\nD=list(numpy.cumsum(A))\nC={}\nfor i in D:\n  d=i%M\n  if d not in C:\n    C[d]=1\n  else:\n    C[d]+=1\n#print(C)\n\nans=0\nfor i in C.values():\n  ans+=i*(i-1)//2\n#\u4f59\u308a0\u306f\u305d\u308c\u5358\u72ec\u3067ok\nif 0 in C:\n  ans+=C[0]\nprint(ans)", "\nfrom collections import defaultdict\n\n\ndef submit():\n    n, m = list(map(int, input().split()))\n    a = [int(e) for e in input().split()]\n    \n    # mod m\u3092\u9069\u7528\n    a_mod = [e % m for e in a]\n    s_mod = []\n    prev = 0\n    for am in a_mod:\n        prev += am\n        prev %= m\n        s_mod.append(prev)\n    \n    mod_cnt = defaultdict(int)\n    mod_cnt[0] = 1\n    ans = 0\n    for s in s_mod:\n        ans += mod_cnt[s]\n        mod_cnt[s] += 1\n\n    print(ans)\n\n\nsubmit()\n", "N,M=map(int, input().split())\nA=list(map(int, input().split()))\nfrom collections import defaultdict\nD=defaultdict(int)\n\n\nL=[0]*(N+1)\nD[0]+=1\nfor i in range(1,N+1):\n    L[i]=(L[i-1]+A[i-1])%M\n    D[L[i]]+=1\nD=dict(D)\n#print(D)\nans=0\nfor v in D.values():\n    if v>1:\n        ans+=v*(v-1)//2\nprint(ans)", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    A_sum = [0]\n    for a in A:\n        A_sum.append((A_sum[-1] + a) % m)\n\n    D = defaultdict(int)\n    res = 0\n    for i in range(n + 1):\n        res += D.get(A_sum[i], 0)\n        D[A_sum[i]] += 1\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,M=map(int,input().split())\nA=list(map(int,input().split()))\nS=0\ndic={}\nfor i in range(N):\n  S+=A[i]\n  S=S%M\n  if(S not in dic):\n    dic[S]=1\n  else:\n    dic[S]+=1\nans=0\n#print(dic)\nfor k in dic.keys():\n  #print(k)\n  if(k!=0):\n    ans+=dic[k]*(dic[k]-1)//2\n  if(k==0):\n    ans+=dic[k]+dic[k]*(dic[k]-1)//2\nprint(ans)", "# -*- coding: utf-8 -*-\n\n\ndef main():\n    from collections import defaultdict\n    import sys\n    input = sys.stdin.readline\n\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    summed = [0 for _ in range(n + 1)]\n    d = defaultdict(int)\n\n    # See:\n    # https://www.youtube.com/watch?v=7bbIZTIeDZM\n    # KeyInsight:\n    # \u611a\u76f4\u89e3\u304b\u3089\u8a08\u7b97\u91cf\u3092\u6e1b\u3089\u3059\u5de5\u592b\n    # \u25ef: 1. \u4efb\u610f\u306e\u8981\u7d20\u6570\u306e\u548c\u3092\u8a08\u7b97\u3001O(N)\u2192\u7d2f\u7a4d\u548c\u3001\u524d\u8a08\u7b97\u304c(N)\u30fb\u5404\u30af\u30a8\u30ea\u306e\u51e6\u7406\u304cO(1)\n    # \u25ef: 2. m\u306e\u500d\u6570\u2192mod m = 0\n    # \u25b3: mod\u306e\u4e16\u754c\u306b\u5bfe\u3059\u308b\u7406\u89e3\n    #    \u7d2f\u7a4d\u548c\u306e\u3046\u3061\u3001x, y\u756a\u76ee\u306e\u5024a, b\u306e\u5dee\u304cm\u3067\u5272\u308a\u5207\u308c\u308b\n    #    (b - a) mod m == 0\n    #    a mod m == b mod m\u3068\u306a\u308b\n    #    m\u3067\u5272\u3063\u305f\u4f59\u308a\u304c\u4e00\u81f4\u3059\u308b\u500b\u6570\u3092\u6570\u3048\u308c\u3070\u3088\u3044\n    for i in range(n):\n        summed[i + 1] = (summed[i] + a[i]) % m\n\n    ans = 0\n\n    # \u3042\u308b\u5730\u70b9j\u306b\u304a\u3044\u3066\u3001m\u3067\u5272\u3063\u305f\u4f59\u308a\u304c\u4e00\u81f4\u3059\u308b\u500b\u6570\u3092\u6570\u3048\u308b\n    for j in range(n + 1):\n        ans += d[summed[j]]\n        d[summed[j]] += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nn,m = map(int,input().split())\na = list(map(int,input().split()))\ns = [0]*(n+1)\nfor i in range(1,n+1):\n    s[i] = (s[i-1]+a[i-1])%m\nc = Counter(s)\nans = 0\nfor k,v in c.items():\n    if k == 0:\n        ans += v-1+(v-2)*(v-1)//2\n    else:\n        ans += v*(v-1)//2\nprint(ans)", "n,m=list(map(int,input().split()))\nA=[int(i) for i in input().split()]\nB=[0]\nfor i in range(n):\n    B.append((B[-1]+A[i])%m)\nB.sort()\ncnt=1\nnow=0\nans=0\nfor i in range(1,n+1):\n    if B[i]>now:\n        ans+=cnt*(cnt-1)//2\n        cnt=1\n        now=B[i]\n    else:\n        cnt+=1\nans+=cnt*(cnt-1)//2\nprint(ans)\n\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = 0\nd = {0: 1}\nfor i in a:\n  s = (s + i) % m\n  if s not in d:\n    d[s] = 1\n  else:\n    d[s] += 1\nans = 0\nfor k, v in list(d.items()):\n  ans += v * (v - 1) // 2\nprint(ans)\n", "n,m = map(int, input().split())\nal = list(map(int, input().split())) \n\nres = 0\n\ndef c(x):\n    y = x*(x-1)//2\n    return y\n\nimport itertools\nals= list(itertools.accumulate(al))\n\nalm = list(map(lambda x:x %m,als))\n\nfrom collections import Counter\ncount = Counter(alm)\nfor i in count:\n    if count[i]>1:\n        res += c(count[i])\n\nres += count[0]\nprint(res)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom itertools import accumulate\n\n\ndef read():\n    N, M = list(map(int, input().strip().split()))\n    A = list(map(int, input().strip().split()))\n    return N, M, A\n\ndef solve(N, M, A):\n    D = defaultdict(int)\n    S = [0 for i in range(N+1)]\n    for i in range(N):\n        s = (S[i] + A[i]) % M\n        S[i+1] = s\n        D[s] += 1\n    ans = 0\n    k = 0\n    for i in range(N):\n        ans += D[k]\n        k += A[i]\n        k %= M\n        D[k] -= 1\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((solve(*inputs)))\n\n__starting_point()", "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nans = 0\nacc = [0 for _ in range(N+1)]\nmod_count = defaultdict(int)\nmod_count[0] += 1\n\nfor i, a_i in enumerate(A):\n    # \u7d2f\u7a4d\u548c\u304cr\n    acc[i+1] = acc[i] + a_i\n    mod = acc[i+1] % M\n    # \u305d\u306e\u6642\u70b9\u3067\u306e\u7d2f\u7a4d\u30ab\u30a6\u30f3\u30c8\u304cl\u306e\u548c\u306e\u7dcf\u6570\n    ans += mod_count[mod]\n    mod_count[mod] += 1\n\nprint(ans)", "N,M=map(int,input().split())\nl=list(map(int,input().split()))\nmem=[0]*N\ndef f(n):\n   return n*(n-1)//2\ns=0\nfor i in range(N):\n   s+=l[i]\n   mem[i]=s\nmem=[i%M for i in mem]\nfrom collections import Counter\nmem=Counter(mem)\nans=mem[0]\nmem=list(mem.values())\nfor i in mem:\n   ans+=f(i)\nprint(ans)", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\n\nfrom collections import Counter\nc=Counter()\ns=0\nc[s]+=1\nfor i in range(n):\n  s+=a[i]\n  c[s%m]+=1\n\nans=0\nfor v in list(c.values()):\n  ans+=v*(v-1)//2\nprint(ans)\n", "n,m=input().split();d={0:1};r=s=0\nfor i in input().split():s+=int(i);s%=int(m);x=d.get(s,0);r+=x;d[s]=x+1\nprint(r)", "from collections import Counter\n\nN, M = map(int, input().split())\nA = list(int(a) for a in input().split())\n\nsumA = [0] * (N+1)\nfor i in range(N):\n    sumA[i+1] = (sumA[i] + A[i]) % M\n\nans = 0\nc = Counter(sumA)\nfor k, v in c.items():\n    ans += (v*(v-1))//2\nprint(ans)", "from collections import defaultdict\nn,m = map(int,input().split())\na = [int(i) for i in input().split()]\ns = [0]*(n+1)\nfor i in range(n):\n    s[i+1] = s[i] + a[i]\ndct = defaultdict(int)\nfor i in range(n+1):\n    dct[s[i]%m] += 1\nans = 0\nfor v in dct.values():\n    ans += v*(v-1)//2\nprint(ans)", "N,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\nB = [0 for i in range(N+1)]\n\nfor i in range(N):\n    B[i+1] += B[i] + A[i]\n    B[i+1] %= M\n\nfrom collections import Counter\n\ncounterB = Counter(B)\n\nans = 0\nfor v in list(counterB.values()):\n    ans += v*(v-1)//2\n\nprint(ans)\n", "from collections import Counter\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nssum = [0]*(n+1)\nfor i in range(n):\n    ssum[i+1] = (ssum[i]+a[i])%m\nc = Counter(ssum)\nans = 0\nfor v in c.values():\n    ans += v*(v-1)//2\nprint(ans)", "import collections\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nS = [0 for _ in range(N+1)]\nfor i in range(len(A)):\n    S[i+1] = (S[i]+A[i])%M\n\nc = collections.Counter(S)\nans = 0\nfor val in c.values():\n    ans += (val*(val-1))//2\nprint(ans)", "import sys\nfrom itertools import accumulate\nfrom collections import Counter\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    R = [0] + list(accumulate(A))\n    R_mod = [r % m for r in R]\n\n    D = Counter(R_mod)\n    res = 0\n    for v in list(D.values()):\n        res += (v - 1) * v // 2\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\nd={0:1}\ns=0\nfor i in a:\n  s=(s+i)%m\n  if s in d:\n    d[s]+=1\n  else:\n    d[s]=1\n    \ndef f(x):\n  return int(x*(x-1)/2)\n\ns=0\nfor i in d:\n  s+=f(d[i])\nprint(s)", "from itertools import accumulate\nfrom collections import Counter\nn,m=map(int,input().split())\ns=[0]+list(map(lambda x:x%m,list(accumulate(list(map(int,input().split()))))))\nans=0\nfor i in Counter(s).values():\n    ans+=(i*(i-1)//2)\nprint(ans)", "from sys import stdin\nfrom itertools import accumulate\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,m=map(int,readline().split())\n    a=list(map(int,readline().split()))\n\n    d=dict()\n    for s in accumulate(a):\n        x=s%m\n        if x not in d:\n            d[x]=1\n        else:\n            d[x]+=1\n\n    if 0 in d:\n        ans=d[0]\n    else:\n        ans=0\n    for v in d.values():\n        ans+=v*(v-1)//2\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nN, M=map(int, input().split())\nA=list(map(int, input().split()))\nB=[0]*N\nB[0]=A[0]%M\nC=defaultdict(int)\nfor i in range(1, N):\n  B[i]=(B[i-1]+A[i])%M\n  \nfor b in B:\n  C[b]+=1\n  \nans=C[0]\nfor key in C.keys():\n  t=C[key]\n  ans+=t*(t-1)//2\n  \nprint(ans)", "N,M=map(int,input().split())\nA=[0]+list(map(int,input().split()))\n\na=0\nm=[0]*(N+1)\nfor i in range(N+1):\n    a+=A[i]%M\n    a%=M\n    m[i]=a\n\nm.sort()\nans=0\ncnt=1\nfor i in range(N):\n    if m[i+1]==m[i]:\n        cnt+=1\n    else:\n        ans+=cnt*(cnt-1)//2\n        cnt=1\nans+=cnt*(cnt-1)//2\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, A: \"List[int]\"):\n    from collections import defaultdict\n    acc = [0] * (N+1)\n    for i, a in enumerate(A, 1):\n        acc[i] = (acc[i-1] + a) % M\n    dp = defaultdict(int)        \n    ans = 0\n    for a in acc:\n        ans += dp[a]\n        dp[a] += 1\n    return ans\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    print((solve(N, M, A)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nl = [0]\nfor i in range(n):\n    l.append(a[i] + l[i])\nfor i in range(n + 1):\n    l[i] %= m\nc = Counter(l)\nans = 0\nfor i in c.values():\n    ans += i * (i - 1) // 2\nprint(ans)", "from collections import Counter\n\nN, M = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\nac = [0]*(N+1)\n\nfor i in range(1, N+1):\n    ac[i] = (ac[i-1]+A[i-1])%M\n\nc = Counter(ac)\nans = 0\nfor i in list(c.values()):\n    ans += i*(i-1)//2\nprint(ans)\n", "import collections\nN,M=map(int,input().split())\nL=list(map(int,input().split()))\nR=[0]\nsums=0\nfor i in L:\n  sums+=i\n  sums=sums%M\n  R.append(sums)\nc = collections.Counter(R)\nA=list(c.values())\nA=[i*(i-1)//2 for i in A]\nprint(sum(A))", "from collections import defaultdict\n\nn,m = map(int,input().split())\nA = list(map(int,input().split()))\n\ndic = defaultdict(int)\ndic[0] += 1\ncum = 0\n\nfor i in range(n):  \n  cum += A[i]\n  dic[cum%m] += 1\n  \nans = 0  \nfor v in dic.values():\n  ans += v*(v-1)//2\n  \nprint(ans)  ", "import sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\ndef main():\n    N,M=mi()\n    A=list(mi())\n\n    v = [0] * 2*10**5\n    seen = set([0])\n    for i in range(N):\n        v[i+1] = A[i] + v[i]\n        v[i+1] %= M\n        seen.add(v[i+1])\n    \n    counts = {x:0 for x in seen}\n    for i in range(N+1):\n        counts[v[i]] += 1\n    \n    ans = 0\n    for _,count in counts.items():\n        ans += count * (count-1) // 2\n    \n    print(ans)\n    \n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\nfrom collections import Counter\nc=Counter()\nsm=0\nc[sm]+=1\nfor i in range(n):\n  sm+=a[i]\n  c[sm%m]+=1\nans=0\nfor v in list(c.values()):\n  ans+=v*(v-1)//2\nprint(ans)\n", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\ncums = [0]\nfor a in A:\n    cums.append(cums[-1] + a)\n\ncump = [c%M for c in cums]\nfrom collections import Counter\nctr = Counter(cump)\n\nans = 0\nfor v in ctr.values():\n    ans += v*(v-1)//2\nprint(ans)", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\n\ntab_sum = [0]\nsum_tmp = 0\nfor Ai in A:\n    sum_tmp += Ai\n    tab_sum.append(sum_tmp)\n\ncnt = {}\nfor item in tab_sum:\n    key = str(item % M)\n    cnt.setdefault(key, 0)\n    cnt[key] += 1\n\n    \nans = 0\nfor key, val in cnt.items():\n    ans += val * (val - 1) // 2\n\nprint(ans)", "n,m,*c=map(int,open(0).read().split())\nd={0:1}\nr=s=0\nfor i in c:s+=i;x=d.get(s%m,0);r+=x;d[s%m]=x+1\nprint(r)", "N,M=map(int, input().split())\nA=list(map(int, input().split()))\nimport numpy\nD=list(numpy.cumsum(A))\nC={}\nD.append(0)\nfor i in D:\n  d=i%M\n  if d not in C:\n    C[d]=1\n  else:\n    C[d]+=1\n#print(C)\nans=0\nfor i in C.values():\n  ans+=i*(i-1)//2\nprint(ans)", "n, m = map(int, input().split())\na = [int(x)%m for x in input().split()]\n\nb = [0]*(n+1)\nfor i in range(n):\n  b[i+1] = (b[i]+a[i])%m\n\nkey = dict()\nkey[0] = 0\nfor i in range(1, n+1):\n  if b[i] in key:\n    key[b[i]] += 1\n  else:\n    key[b[i]] = 1\n\nans = key[0]\nfor value in key.values():\n  ans += value*(value-1)//2\n\nprint(ans)", "N,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=[0]\ntmp=0\nfor i in A:\n  tmp+=i\n  B.append(tmp)\n\nd = {}\nfor i in B:\n  i %= M\n  if i not in d:\n    d[i] = 0\n  d[i] += 1\n\nans = 0\nfor i in d.values():\n  ans += i*(i-1)//2\nprint(ans)", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nfrom collections import Counter\nc = Counter()\nsum_val = 0\nc[sum_val] += 1\nfor i in range(n):\n    sum_val += a[i]\n    sum_val %= m\n    c[sum_val] += 1\nans = 0\nfor v in list(c.values()):\n    ans += v*(v-1)//2\nprint(ans)\n\n\n", "from collections import Counter\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nl = [0]\n#\u7d2f\u7a4d\u548c\nfor i in range(N):\n    l.append(A[i]+l[i])\n# print(l)\n\n#M\u306e\u4f59\u308a\u306b\u5909\u63db\nfor i in range(N+1):\n    l[i] %= M\n\nc = Counter(l)\n# print(c)\nans = 0\n#\u540c\u3058\u4f59\u308a\u540c\u58eb\u306e\u533a\u9593\u306f\u6761\u4ef6\u3092\u6e80\u305f\u3059\nfor i in c.values():\n    ans += i*(i-1)//2\nprint(ans)", "import collections\n\nN, M = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\nc = collections.Counter()\n\nans = 0\ns = 0\nc[0] += 1\nfor a in A:\n    s += a\n    s %= M\n    ans += c[s]\n    c[s] += 1\n\nprint(ans)\n", "n,m,*c=map(int,open(0).read().split());d={0:1};r=s=0\nfor i in c:s+=i;s%=m;x=d.get(s,0);r+=x;d[s]=x+1\nprint(r)", "n,m,*c=map(int,open(0).read().split());d={0:1};r=s=0\nfor i in c:s+=i;x=d.get(s%m,0);r+=x;d[s%m]=x+1\nprint(r)", "import unittest\nimport collections\n\n\ndef solve_b(n, m, a):\n    print(a)\n    b = [0]*(n+1)\n    for i in range(n):\n        b[i+1] = (a[i] + b[i]) % m\n    print(c)\n    print(b)\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if (b[j] - b[i]) % m == 0:\n                cnt += 1\n    return cnt\n\n\ndef solve(n, m, a):\n    b = [0]*(n+1)\n    for i in range(n):\n        b[i+1] = (a[i] + b[i]) % m\n    c = collections.Counter(b[1:])\n    total = 0\n    for k, v in list(c.items()):\n        if k != 0:\n            v -= 1\n        if v == 0:\n            continue\n        total += v * (v+1)//2\n    return total\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    a = list([int(x) % m for x in input().split()])\n    print((solve(n, m, a)))\n\n\ndef __starting_point():\n    main()\n\n\nclass Test(unittest.TestCase):\n    def get_a(self, a, m):\n        return list([int(x) % m for x in a.split()])\n\n    def test1(self):\n        n = 3\n        m = 2\n        a = self.get_a(\"4 1 5\", m)\n        expected = 3\n        self.assertEqual(solve(n, m, a), expected)\n\n    def test2(self):\n        n = 13\n        m = 17\n        a = self.get_a(\"29 7 5 7 9 51 7 13 8 55 42 9 81\", m)\n        expected = 6\n        self.assertEqual(solve(n, m, a), expected)\n\n    def test3(self):\n        n = 10\n        m = 400000000\n        a = self.get_a(\n            \"1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\", m)\n        expected = 25\n        self.assertEqual(solve(n, m, a), expected)\n\n__starting_point()", "from itertools import accumulate\nfrom collections import Counter\nimport math\n\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nn,m=map(int,input().split())\ns=list(map(lambda x:x%m,list(accumulate(list(map(int,input().split()))))))\ns.append(0)\n#print(s)\nd=Counter(s)\n#print(d)\nans=0\nfor i in d:\n    if d[i]>=2:\n        ans+=combinations_count(d[i],2)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nfrom collections import defaultdict\n\nN, M = list(map(int, input().split()))\nA = [0] + list(map(int, input().split()))\n\ndic = defaultdict(int)\ndic[0] += 1\nans = 0\nfor i in range(N):\n    A[i + 1] += A[i]\n    A[i + 1] %= M\n    ans += dic[A[i + 1]]\n    dic[A[i + 1]] += 1\n\nprint (ans)\n\n\n", "n,m,*c=open(0).read().split();d={0:1};r=s=0\nfor i in c:s+=int(i);s%=int(m);x=d.get(s,0);r+=x;d[s]=x+1\nprint(r)", "\nN, M=map(int,input().split())\nA=list(map(int,input().split()))\n\nfor i in range(N):\n  A[i]%=M\nrui=[A[0]]*N\nfor i in range(1,N):\n  rui[i]=(rui[i-1]+A[i])%M\nrui.sort()\nlast=0\ncnt=0\nfor i in range(1,N):\n  if rui[i] != rui[i-1]:\n    if i - last >=2:\n      cnt+=(i-last)*(i-last-1)//2\n    last=i\nif N - last >= 2:\n  cnt+=(N-last)*(N-last-1)//2\nprint(int(cnt)+rui.count(0))"]
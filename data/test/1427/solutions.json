["n=int(input())\na=[int(x) for x in input().rstrip().split()]\n\nnow=1\nmod=10**9+7\ndef lcm(a,b):#\u6700\u5c0f\u516c\u500d\u6570\n    ori_a=a\n    ori_b=b\n    while b!=0:\n        a,b=b,a%b\n    return (ori_a*ori_b)//a\n  \nfor i in a:\n  now=lcm(i,now)\n# print(now)\nprint((sum([now//i for i in a])%mod))\n  \n", "n=int(input())\na=list(map(int,input().split()))\nmod=10**9+7\nfrom math import gcd\nans=a[0]\nfor i in range(1,n):\n  ans=ans*a[i]//gcd(ans,a[i])\ns=sum(pow(x,mod-2,mod) for x in a)\nprint((s*ans%mod))\n", "n = int(input())\na = list(map(int, input().split()))\n\nmod = 1000000007\n\ndef add(a, b):\n    return (a + b) % mod\n\ndef mul(a, b):\n    return (a * b) % mod\n\ndef pow(p, k):\n    ret = 1\n    b = p\n    while k > 0:\n        if k % 2 == 1:\n            ret = mul(ret, b)\n        b = mul(b, b)\n        k //= 2\n    return ret\n\ndef inv(p, k):\n    return pow(p, mod - k - 1)\n\nlcm = {}\nps = []\nfor i in range(n): \n    ai = a[i]\n    p = 2\n    ps.append({})\n    while ai > 1:\n        if ai % p == 0:\n            ps[i][p] = 0\n            while ai % p == 0:\n                ps[i][p] += 1\n                ai //= p\n            lcm[p] = max(lcm.get(p, 0), ps[i][p])\n        p = p + 1 if p * p < ai else ai\n\nlcmv = 1\nfor p in lcm:\n    lcmv = mul(lcmv, pow(p, lcm[p]))\n\nret = 0\nfor i in range(n):\n    prod = lcmv\n    for p in ps[i]:\n        prod = mul(prod, inv(p, ps[i][p]))\n    ret = add(ret, prod)\n\nprint(ret)\n        \n", "import fractions\n# import math as fractions\nmod = 10**9+7\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print((1))\n    return\n\ng = fractions.gcd(a[0], a[1]) # \u6700\u5927\u516c\u7d04\u6570\nf = a[0]*a[1]//g # \u6700\u5c0f\u516c\u500d\u6570\nans = a[0]//g+a[1]//g\n\nfor i in range(2, n):\n    # print(ans, g, f)\n    h = fractions.gcd(f, a[i])\n    g = a[i] // h\n    f = f*a[i]// h\n    ans *= g\n    ans += f // a[i]\n    ans %= mod\nprint((ans%mod))\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int,readline().split()))\nDIV = 10 ** 9 + 7\nimport math\n\nfrom functools import reduce\n\ndef lcm(a,b,):\n  return (a // math.gcd(a,b)) * b\n\nG = reduce(lcm, A)\nans = sum(map(lambda x:G // x, A))\n\nprint(ans % DIV)", "import math\nN = int(input())\nA = list(map(int,input().split()))\nB = [0] * (N)\nlcmall = A[0]\nfor i in range(1,N):\n    gcdall = math.gcd(lcmall,A[i])\n    lcmall = lcmall*A[i] // gcdall\nsum = 0\nfor i in range(N):\n    B[i] =int(lcmall // A[i])\n    sum += B[i]\nprint(sum % (10 ** 9 + 7))", "from collections import defaultdict\nMOD = 10 ** 9 + 7\n\nn = int(input())\nalst = list(map(int, input().split()))\ndd = defaultdict(int)\nans = 0\nfor a in alst:\n    ans += pow(a, MOD - 2, MOD)\n    ans %= MOD\n    num = a\n    for i in range(2, int(a ** 0.5) + 1):\n        cnt = 0\n        while num % i == 0:\n            num //= i\n            cnt += 1\n        if cnt > 0:\n            dd[i] = max(dd[i], cnt)\n    if num != 1:\n        dd[num] = max(dd[num], 1)\nfor key, value in list(dd.items()):\n    ans *= pow(key, value, MOD)\n    ans %= MOD\nprint(ans)\n\n", "\nfrom fractions import gcd\ndef main():\n\n    N = int(input())\n    a_list = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n\n    a_lcm = a_list[0]\n    for a in a_list[1:]:\n        a_lcm *= a // gcd(a,a_lcm)\n\n    res = 0\n    for a in a_list:\n        res += a_lcm // a\n    print(res%MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "def gcd(m, n):\n    r = m % n\n    return gcd(n, r) if r else n\n\ndef lcm(m, n):\n    return m//gcd(m, n)*n\nMOD = 10**9+7\nn = int(input())\na = list(map(int, input().split()))\nl = a[0]\nfor x in a:\n    l = lcm(x, l)\nans = 0\nfor x in a:\n    ans += l*pow(x, MOD-2, MOD)%MOD\nprint((ans%MOD))\n", "import sys\nimport math\nimport fractions\nfrom collections import defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\n\nmod = 10**9 + 7\n\n\ndef factorize(n):\n    b = 2\n    fct = defaultdict(lambda: 0)\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            fct[b] += 1\n        b = b + 1\n    if n > 1:\n        fct[n] += 1\n    return fct\n\n\ndef divmod(x, mod=10**9 + 7):\n    return pow(x, mod - 2, mod)\n\n\ndef solve():\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [[1] for _ in range(N)]\n\n    fac_list = defaultdict(lambda: 0)\n    for i in range(N):\n        d = factorize(A[i])\n        for k, v in list(d.items()):\n            fac_list[k] = max(fac_list[k], v)\n\n    lcm = 1\n    for k, v in list(fac_list.items()):\n        lcm *= (k**v)\n        lcm %= mod\n\n    ans = 0\n    for i in range(N):\n        ans += divmod(A[i])\n        ans %= mod\n\n    ans *= lcm\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\nx = a[0]\nmod = 10**9+7\nfor i in range(1, n):\n    x = x*a[i]//gcd(x, a[i])\nans = 0\nfor i in range(n):\n    ans += x//a[i]\nprint(ans%mod)", "#!/usr/bin/env python\nimport math\nn = int(input()) \na = list(map(int, input().split()))\n\nmod = 10**9+7\n\ndef lcm(a, b): \n    return a*b//math.gcd(a, b)\n\nl = a[0]\nfor i in range(n):\n    l = lcm(l, a[i])\nl %= mod \n\nans = 0 \nfor i in range(n):\n    inv = pow(a[i], mod-2, mod)\n    ans += (l*inv)%mod\n\nprint((ans%mod))\n", "import sys, bisect, math, itertools, string, queue, copy\nimport numpy as np\nimport scipy\nfrom collections import Counter,defaultdict,deque\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nfrom fractions import gcd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nn = inp()\nA = inpl()\n\ndef lcm(A):\n    from fractions import gcd\n    x = A[0]\n    for a in A:\n        x = (x * a) // math.gcd(x, a)\n    return x\n\nl = lcm(A)\n\nans = 0\nfor a in A:\n    ans += l // a\n\nprint((ans % mod))\n\n", "def main():\n    from math import gcd\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    mod = 1000000007\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    lcm = 1\n    for i in A:\n        lcm = lcm * i // gcd(lcm, i)\n    lcm %= mod\n\n    ans = 0\n    for i in A:\n        ans += lcm * pow(i, mod-2, mod)\n        ans %= mod\n\n    print(ans)\n\n\nmain()", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\nclass PrimeFactor():\n\n    def __init__(self, n):                  # \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u3000O(N loglog N)\n        self.n = n\n        self.table = [i if i % 2 else 2 for i in range(n + 1)]\n        self.table[0] = 0\n        for p in range(3, n + 1):\n            if self.table[p] == p:\n                for q in range(p * p, n + 1, 2 * p):\n                    self.table[q] = p\n\n    def is_prime(self, x):  # \u7d20\u6570\u5224\u5b9a\u3000O(1)\n        if x < 2:\n            return False\n        return self.table[x] == x\n\n    def prime_factors(self, x):             # \u7d20\u56e0\u6570\u5206\u89e3 O(logN)\n        res = []\n        if x < 2:\n            return res\n        while self.table[x] != 1:\n            res.append(self.table[x])\n            x //= self.table[x]\n        return res\n\n    def prime_counter(self, x):             # \u7d20\u56e0\u6570\u5206\u89e3\uff08\u500b\u6570\u306e\u30ea\u30b9\u30c8\uff09\n        res = defaultdict(int)\n        if x < 2:\n            return res\n        while self.table[x] != 1:\n            res[self.table[x]] += 1\n            x //= self.table[x]\n        return res\n\n    def prime_gcd(self, X):                 # n\u500b\u306e\u6700\u5927\u516c\u7d04\u6570\u3000X:n\u500b\u306e\u30ea\u30b9\u30c8\n        exponents = self.prime_counter(X[0])\n        for x in X[1:]:\n            Y = self.prime_counter(x)\n            for prime, exp in exponents.items():\n                if Y[prime] < exp:\n                    exponents[prime] = Y[prime]\n        res = 1\n        for prime, exp in exponents.items():\n            res *= pow(prime, exp)\n        return res\n\n    def prime_lcm(self, X, mod=None):       # n\u500b\u306e\u6700\u5c0f\u516c\u500d\u6570\u3000X:n\u500b\u306e\u30ea\u30b9\u30c8\n        exponents = defaultdict(int)\n        for x in X:\n            for prime, exp in self.prime_counter(x).items():\n                if exp > exponents[prime]:\n                    exponents[prime] = exp\n        res = 1\n        for prime, exp in exponents.items():\n            res *= pow(prime, exp, mod)\n        if mod == None:\n            return res\n        else:\n            return res % mod\n\nmod = 10 ** 9 + 7\n\nN = int(input())\nA = list(map(int, input().split()))\ntable = PrimeFactor(10**6)\nnum = table.prime_lcm(A,mod)\n\nres = 0\nfor a in A:\n    res += num * pow(a, mod - 2, mod)\n\nprint(res % mod)", "# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9, \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef make_prime_table(n):\n    sieve = list(range(n + 1))\n    sieve[0] = -1\n    sieve[1] = -1\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i] != i:\n            continue\n        for j in range(i * i, n + 1, i):\n            if sieve[j] == j:\n                sieve[j] = i\n    return sieve\n\n\ndef prime_factorize(n):\n    result = []\n    while n != 1:\n        p = prime_table[n]\n        c = 0\n        while n % p == 0:\n            n //= p\n            c += 1\n        result.append((p, c))\n    return result\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nprime_table = make_prime_table(10 ** 6)\n\nlcm_factors = {}\nfor a in A:\n    for p, c in prime_factorize(a):\n        if p not in lcm_factors or lcm_factors[p] < c:\n            lcm_factors[p] = c\n\nlcm = 1\nfor p in lcm_factors:\n    lcm *= pow(p, lcm_factors[p], m)\n    lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], m - 2, m)\n    result %= m\nprint(result)\n", "import math\nfrom functools import reduce\nfrom collections import defaultdict\n\n#\u7d20\u56e0\u6570\u5206\u89e3O(\u221an)\ndef primeFactor(n):\n    res = defaultdict(lambda: 0)\n    for i in range(2, int(n**0.5)+1):\n        while n % i == 0:\n            res[i] += 1\n            n = n // i\n    if n != 1:\n        res[n] += 1\n    return res\n\n    \n\nN = int(input())\nA = list(map(int, input().split()))\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\nMOD = 10**9+7\nGCD = gcd(*A)\n\nP = defaultdict(lambda: 0)\n\nfor i in range(N):\n    factors = primeFactor(A[i])\n    for k, v in list(factors.items()):\n        if v > P[k]:\n            P[k] = v\n\n\nP_mod = 1\nfor k in list(P.keys()):\n    P_mod = P_mod*(k**P[k])%MOD\n\nans = 0\nfor i in range(N):\n    b = A[i]\n    mod_inv = pow(b, MOD-2, MOD)\n    ans = (ans + P_mod * mod_inv) % MOD\n\nprint(ans)\n\n\n", "import fractions\nmod=10**9+7\ndef lcm(m,n):return m//fractions.gcd(m,n)*n\nn=int(input())\na=list(map(int,input().split()))\nl=a[0]\nans=0\nfor i in a:l=lcm(i,l)\nfor i in a:ans+=l*pow(i,mod-2,mod)%mod\nprint(ans%mod)", "from fractions import gcd\nfrom functools import reduce\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nlcm = reduce(lambda a, b: a * b // gcd(a, b), A)\nprint((sum(lcm // a for a in A) % m))\n", "from math import gcd\n\nmod = 1000000007\nn = int(input())\na = list(map(int, input().split()))\nd = 1\nres = 0\nfor v in a:\n    d *= v // gcd(v, d)\nfor v in a:\n    res += d // v\nprint((res % mod))\n", "def gcd(m, n):\n    r = m % n\n    return gcd(n, r) if r else n\n\ndef lcm(m, n):\n    return m//gcd(m, n)*n\n\nMOD = 10**9+7\nn = int(input())\na = list(map(int, input().split()))\nl = a[0]\nfor x in a[1:]:\n    l = lcm(x, l)\nl %= MOD\n\nans = 0\nfor x in a:\n    ans = (ans + l * pow(x, MOD-2, MOD)%MOD)%MOD\nprint(ans)\n", "import math\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N = int(input())\n    A = list(map(int, input().split(' ')))\n    # \u7b54\u3048\u306f sum(lcm(A) / A)\n    L = 1\n    for a in A:\n        L = L * a // math.gcd(L, a)\n    ans = 0\n    for a in A:\n        ans += L * pow(a, MOD - 2, MOD)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# from fractions import gcd\n# P = 10**9+7\n# N = int(input())\n# S = list(map(int, input().split()))\n\n# l = {2:0}\n# for num in S:\n#     temp = num\n#     M = temp//2+2\n#     cnt = 0\n#     while temp%2 == 0:\n#         cnt += 1\n#         temp //= 2\n#     l[2] = max(l[2], cnt)\n#     i = 3\n#     while temp > 1 and i < M:\n#         cnt = 0\n#         while temp%i == 0:\n#             cnt += 1\n#             temp //= i\n#         if cnt > 0:\n#             if i in l:\n#                 l[i] = max(l[i], cnt)\n#             else:\n#                 l[i] = cnt\n#         i += 2\n#     if temp > 1:\n#         if temp in l:\n#             l[temp] = max(l[temp], 1)\n#         else:\n#             l[temp] = 1\n    \n    \n# ans = 0\n# for i in range(N):\n#     ans = (temp//S[i]+ans)%P\n# print(ans)\n\n\n\nfrom fractions import gcd\nP = 10**9+7\nN = int(input())\nS = list(map(int, input().split()))\n \ntemp = S[0]\nfor i in range(1, N):\n    temp = temp*S[i] // gcd(temp, S[i])\ntemp %= P\n \nans = 0\nfor num in S:\n    ans = ((temp*pow(num, P-2, P))%P+ans)%P\nprint(ans)", "import sys\nimport  math\nimport fractions\nfrom collections import defaultdict\nfrom functools import reduce\nstdin = sys.stdin\n         \nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n     \nINF=10**18\nmod=10**9+7\nN=int(input())\nA=nl()\nans=0\nmin_bai=1\nfor i in range(N):#\u6700\u5927\u516c\u500d\u6570\n    min_bai=min_bai*A[i]//fractions.gcd(min_bai,A[i])\n\n#lcm = reduce(lambda x,y: x//fractions.gcd(x,y)*y, A)\n \nfor i in range(N):\n    ans+=min_bai//A[i]\n\n#ans = sum(lcm//x for x in A)\nprint((ans%mod))\n", "import math\n\nmod = 10**9+7\nN = int(input())\nA = list(map(int, input().split()))\nans = 1\nlcm = A[0]\nfor i in range(1, N):\n    a = A[i]\n    b = lcm\n    gcd = math.gcd(a, b)\n    lcm = (a*b)//gcd\n    ans *= lcm//b\n    ans += lcm//a\n    ans %= mod\n    \nprint(ans)", "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\nn = int(input()) \na = list(map(int,input().split()))\n\nl = lcm(*a)\n\nMOD = 10**9+7\nans = 0\nfor i in range(n):\n    ans += l // a[i]\nprint((ans % MOD))\n", "# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9, \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef make_prime_table(N):\n    sieve = [0] * (N + 1)\n    sieve[0] = -1\n    sieve[1] = -1\n    for i in range(2, N + 1):\n        if sieve[i] != 0:\n            continue\n        sieve[i] = i\n        for j in range(i * i, N + 1, i):\n            if sieve[j] == 0:\n                sieve[j] = i\n    return sieve\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nsieve = make_prime_table(1000000)\n\nlcm_factors = {}\nfor i in range(N):\n    t = []\n    a = A[i]\n    while a != 1:\n        if len(t) != 0 and t[-1][0] == sieve[a]:\n            t[-1][1] += 1\n        else:\n            t.append([sieve[a], 1])\n        a //= sieve[a]\n    for k, v in t:\n        if k not in lcm_factors or lcm_factors[k] < v:\n            lcm_factors[k] = v\n\nlcm = 1\nfor k in lcm_factors:\n    for i in range(lcm_factors[k]):\n        lcm *= k\n        lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], m - 2, m)\n    result %= m\nprint(result)\n", "from math import *\n\ndef gcd(x, y):\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\n\ndef lcm(x,y):\n    return x*y//gcd(x,y)\nn = int(input())\na = [int(x) for x in input().split()]\n\nmod = 1000000000+7\n\nk = 1\nfor x in a:\n    k = lcm(k,x)\n\nans = 0\n\nfor x in a:\n    ans += k//x\n\nprint((ans%mod))\n", "# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9, \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef make_prime_table(N):\n    sieve = list(range(N + 1))\n    sieve[0] = -1\n    sieve[1] = -1\n    for i in range(2, int(N ** 0.5) + 1):\n        if sieve[i] != i:\n            continue\n        for j in range(i * i, N + 1, i):\n            if sieve[j] == j:\n                sieve[j] = i\n    return sieve\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nprime_table = make_prime_table(1000000)\n\nlcm_factors = {}\nfor i in range(N):\n    t = []\n    a = A[i]\n    while a != 1:\n        if len(t) != 0 and t[-1][0] == prime_table[a]:\n            t[-1][1] += 1\n        else:\n            t.append([prime_table[a], 1])\n        a //= prime_table[a]\n    for k, v in t:\n        if k not in lcm_factors or lcm_factors[k] < v:\n            lcm_factors[k] = v\n\nlcm = 1\nfor k in lcm_factors:\n    for i in range(lcm_factors[k]):\n        lcm *= k\n        lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], m - 2, m)\n    result %= m\nprint(result)\n", "from itertools import groupby\nfrom collections import Counter\n\n### https://atcoder.jp/contests/abc152/submissions/15835670\ndef fast_prime_factorization_many(lst):\n  # \u7d20\u56e0\u6570\u5206\u89e3\uff08\u30ed\u30fc\u6cd5\u3001\u8907\u6570\uff09\n  from subprocess import Popen, PIPE\n  res = Popen([\"factor\"] + list(map(str, lst)), stdout=PIPE).communicate()[0].split(b\"\\n\")[:-1]\n  return [Counter(list(map(int, r.split()[1:]))) for r in res]\n\ndef main():\n  import sys\n  input = sys.stdin.readline\n  N = int(input())\n  A = list(map(int, input().split()))\n  if N == 1:\n    print((1))\n    return\n  \n  mod = int(1e9+7)\n  Factors = fast_prime_factorization_many(A)\n  #print(Factors)\n  ### lcm\u3092\u6c42\u3081\u308b\n  lcm = 1\n  max_factor = [0] * (1000010)\n  for f in Factors:\n    for k,v in list(f.items()):\n      v_prev = max_factor[k]\n      if v_prev < v:\n        for i in range(v-v_prev):\n          lcm = lcm * k % mod\n        max_factor[k] = v\n        \n  #print(lcm)\n  ans = 0\n  for a in A:\n    wk =  lcm * pow(a,mod-2,mod)\n    #print(wk)\n    ans += wk\n    ans %= mod\n  print(ans)\n  return\n  \nmain()\n", "n = int(input())\na = list(map(int, input().split()))\n\nmod = 1000000007\n\nlcm = {}\nps = []\nfor i in range(n): \n    ai = a[i]\n    p = 2\n    ps.append({})\n    while p * p <= ai:\n        if ai % p == 0:\n            ps[i][p] = 0\n            while ai % p == 0:\n                ps[i][p] += 1\n                ai //= p\n            lcm[p] = max(lcm.get(p, 0), ps[i][p])\n        p += 1\n    if ai > 1:\n        ps[i][ai] = 1\n        lcm[ai] = max(lcm.get(ai, 0), ps[i][ai])\n\nlcmv = 1\nfor p in lcm:\n    lcmv = (lcmv * (p ** lcm[p])) % mod\n\ndef inv(p, k):\n    k = mod - k - 1\n    ret = 1\n    b = p\n    while k > 0:\n        if k % 2 == 1:\n            ret = (ret * b) % mod\n        b = (b * b) % mod\n        k //= 2\n    return ret\n\nret = 0\nfor i in range(n):\n    prod = lcmv\n    for p in ps[i]:\n        prod = (prod * inv(p, ps[i][p])) % mod\n    ret = (ret + prod) % mod\n\nprint(ret)\n        \n", "import math\nimport itertools\n\n\nMOD = 1000000007\n\n\nN = list(map(int, input().split()))[0]\nA = list(map(int, input().split()))\n\nl = 1\nfor i in range(N):\n    l = A[i] // math.gcd(A[i], l) * l\n\n# ans = 0\nA = [l // x for x in A];\nans = list(itertools.accumulate(A))[-1]\nans %= MOD\n\n# for i in range(N):\n#     ans += l // A[i]\n#     ans %= MOD\n\nprint(ans)\n", "def main():\n    import copy\n    n = int(input())\n    a = list(map(int,input().split()))\n    A = copy.deepcopy(a)\n    mod = 10**9+7\n    l = {}\n    for i in range(n):\n        for j in range(2,int(a[i]**0.5)+1):\n            if a[i]%j==0:\n                cnt = 0\n                while a[i]%j==0:\n                    cnt += 1\n                    a[i] = a[i]//j\n                if l.get(j)==None:\n                    l[j] = cnt\n                else:\n                    l[j] = max(cnt,l[j])\n        if a[i]!=1:\n            if l.get(a[i])==None:\n                l[a[i]] = 1\n    L = 1\n    for k in list(l.keys()):\n        L *= pow(k,l[k],mod)\n    L = L%mod\n    ans = 0\n    for i in range(n):\n        ans += L * pow(A[i],mod-2,mod) % mod\n        ans = ans % mod\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom functools import reduce\n     \ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n     \ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n      \nN = int(input())\nA = list(map(int,input().split()))\nans = 0\n     \nlcm = lcm_list(A)\n     \nfor i in range(N):\n    ans += lcm//A[i]\n     \nprint(ans%1000000007)", "\nfrom fractions import gcd\ndef main():\n\n    N = int(input())\n    a_list = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n\n    a_lcm = a_list[0]\n    for a in a_list[1:]:\n        a_lcm *= a // gcd(a_lcm,a)\n\n    res = 0\n    for a in a_list:\n        res += a_lcm // a\n    print((res%MOD))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    from functools import reduce\n\n    n = ni()\n    a = na()\n\n    lcm = a[0]\n    for i in a:\n        lcm = lcm // math.gcd(lcm, i) * i\n    lcm %= MOD\n\n    ans = 0\n    for ai in a:\n        ans += lcm * pow(ai, MOD - 2, MOD) % MOD\n        ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\nMOD = 1000000007\n\nN = int(input())\n\nA = list(map(int, input().split()))\n\nlcm_ = 1\nfor a in A:\n    lcm_ = lcm(lcm_, a)\n\nans = 0\nfor a in A:\n    ans += lcm_ // a\n\nans %= MOD\nprint(ans)", "# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9, \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nmax_A = 1000000\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nsieve = [0] * (max_A + 1)\nsieve[0] = -1\nsieve[1] = -1\nfor i in range(2, max_A + 1):\n    if sieve[i] != 0:\n        continue\n    sieve[i] = i\n    for j in range(i * i, max_A + 1, i):\n        if sieve[j] == 0:\n            sieve[j] = i\n\nlcm_factors = {}\nfor i in range(N):\n    t = []\n    a = A[i]\n    while a != 1:\n        if len(t) != 0 and t[-1][0] == sieve[a]:\n            t[-1][1] += 1\n        else:\n            t.append([sieve[a], 1])\n        a //= sieve[a]\n    for k, v in t:\n        if k not in lcm_factors or lcm_factors[k] < v:\n            lcm_factors[k] = v\n\nlcm = 1\nfor k in lcm_factors:\n    for i in range(lcm_factors[k]):\n        lcm *= k\n        lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], m - 2, m)\n    result %= m\nprint(result)\n", "import math\nn = int(input())\na = list(map(int, input().split()))\n\ndef lcm(a,b):\n    return a * b // math.gcd(a,b)\n\np = 1000000007\n\nk = 1\nfor i in range(n):\n    k = lcm(k,a[i])\n\nk %= p\n\nans = 0\nfor i in range(n):\n    ans += k * pow(a[i],p-2,p)\n    ans %= p\n\nprint(ans)\n", "n = int(input())\nl = list(map(int, input().split(' ')))\n\ndef gcd(a, b):\n    return b if a % b == 0 else gcd(b, a % b)\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nhoge = 1\nfor p in l:\n    hoge = lcm(hoge, p)\nans = 0\nfor p in l:\n    ans += hoge // p\nprint((ans % int(1e9 + 7)))  # TLE ????\n", "#\n\nimport sys\nfrom fractions import gcd\ninput=sys.stdin.readline\n\ndef main():\n    MOD=10**9+7\n    N=int(input())\n    A=list(map(int,input().split()))\n    if N==1:\n        print((1))\n        return\n    l=(A[0]*A[1])//gcd(A[0],A[1])\n    for i in range(2,N):\n        l=(l*A[i])//gcd(A[i],l-A[i])\n    l%=MOD\n    ans=0\n    for i in range(N):\n        ans+=l*pow(A[i],MOD-2,MOD)\n        ans%=MOD\n    print(ans)\n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import reduce\nfrom fractions import gcd\nfrom collections import defaultdict,Counter\nimport copy\n\nn = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\n\ndic = defaultdict(int)\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nfor i in a:\n    c = Counter(prime_factorize(i))\n    for j,k in c.items():\n        if dic[j] < k:\n            dic[j] = k\n\nl = 1\n\nfor i,j in dic.items():\n    l *= pow(i,j,mod)\n    l %= mod\n\npoint = 0\n\nfor i in a:\n    point += l*pow(i,mod-2,mod)\n    point %= mod\n\nprint(point%mod)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\nm=10**9+7\n\"\"\"n\u3092\u7d20\u56e0\u6570\u5206\u89e3\"\"\"\n\"\"\"2\u4ee5\u4e0a\u306e\u6574\u6570n => [[\u7d20\u56e0\u6570, \u6307\u6570], ...]\u306e2\u6b21\u5143\u30ea\u30b9\u30c8\"\"\"\n\ndef factorization(n):\n    arr = []\n    temp = n\n    i=2\n    if temp%i==0:\n        cnt=0\n        while temp%i==0:\n            cnt+=1\n            temp //= i\n        arr.append([i, cnt])\n            \n    for i in range(3, int(-(-n**0.5//1))+1,2):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])    \n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nN=int(input())\nA=list(map(int,input().split()))\nd = collections.defaultdict(int)\nfor a in A:\n    arr = factorization(a)\n    for ar in arr:\n        if d[ar[0]]<ar[1]:\n            d[ar[0]]=ar[1]\n\ngcd = 1\nfor key,val in list(d.items()):\n    gcd = gcd*pow(key,val)\n\nans = 0\nfor a in A:\n    ans = ans+gcd//a\nprint((ans%m))\n", "import sys\nfrom collections import defaultdict\ninput = lambda: sys.stdin.readline().rstrip()\n\nmod = 10**9 + 7\n\n\nclass Factorize(object):\n\n    def __init__(self, maxnum):\n        self.primes = self.__smallest_prime_factors(maxnum)\n\n    # \u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b(\u30ea\u30b9\u30c8)\n    def factorize_list(self, n):\n\n        fct = []\n        while n != 1:\n            fct.append(self.primes[n])\n            n //= self.primes[n]\n        return fct\n\n    # \u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b(\u8f9e\u66f8)\n    def factorize_dict(self, n):\n        fct = defaultdict(lambda: 0)\n        while n != 1:\n            fct[self.primes[n]] += 1\n            n //= self.primes[n]\n        return fct\n\n    # n\u4ee5\u4e0b\u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u3092\u5217\u6319\u3059\u308b\n    def __smallest_prime_factors(self, n):\n\n        prime = list(range(n + 1))\n\n        for i in range(2, int(n**0.5) + 1):\n            if prime[i] != i:\n                continue\n            for j in range(i * 2, n + 1, i):\n                prime[j] = min(prime[j], i)\n        return prime\n\n\ndef divmod(x, mod=10**9 + 7):\n    return pow(x, mod - 2, mod)\n\n\ndef solve():\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    fct = Factorize(max(A))\n\n    lcm_dict = defaultdict(lambda: 0)\n    for i in range(N):\n        d = fct.factorize_dict(A[i])\n        for k, v in list(d.items()):\n            lcm_dict[k] = max(lcm_dict[k], v)\n\n    lcm = 1\n    for k, v in list(lcm_dict.items()):\n        lcm *= (k**v)\n        lcm %= mod\n\n    ans = 0\n    for i in range(N):\n        ans += divmod(A[i])\n        ans %= mod\n\n    ans *= lcm\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\n\nMOD = 10**9 + 7\n\n\ndef solve():\n    N = Scanner.int()\n    A = Scanner.map_int()\n    l = 1\n    for a in A:\n        l = lcm(a, l)\n    ans = 0\n    for a in A:\n        ans += l // a\n    ans %= MOD\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import reduce\n\nN=int(input())\n*A,=map(int,input().split())\nmod = 10**9+7\n\ndef gcd(a,b):\n  if b == 0:\n    return a\n  return gcd(b,a%b)\n\ndef lcm(a,b):\n  return a*b//gcd(a,b)\n\nLCM = reduce(lcm,A)%mod\n\nprint(sum([LCM*pow(A[i],-1,mod)%mod for i in range(N)])%mod)", "N = int(input())\nA = list(map(int, input().split()))\nmod = 10**9 + 7\na = max(A)\nprime_num = [2]\nsgn = [0 for _ in range(max(int(a**0.5)+1, 4))]\nsgn[2] = 1\nfor k in range(3, len(sgn), 2):\n  if sgn[k] == 0:\n    prime_num.append(k)\n    for j in range(k, a+1, k**2):\n      sgn[k] = 1\nbaisu = []\ncount = [0 for _ in range(a+1)]\nfor k in range(N):\n  b = 0 + A[k]\n  for p in prime_num:\n    if p**2 <= b:\n      if b%p == 0:\n        if count[p] == 0:\n          baisu.append(p)\n        c = 0\n        while b % p == 0:\n          b //= p \n          c += 1 \n        if c > count[p]:\n          count[p] = c\n    else:\n      break\n  if b != 1:\n    if count[b] == 0:\n      count[b] = 1\n      baisu.append(b)\n\nproduct = 1\nfor item in baisu:\n  product *= pow(item, count[item], mod)\n  product %= mod\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\nans = 0\nfor k in range(N):\n  ans += product*modinv(A[k])\n  ans %= mod\n\nprint(ans)\n", "import sys\nfrom collections import defaultdict\n\nmod = 10 ** 9 + 7\n\n\ndef factorization(n):\n    \"\"\" n \u306e\u7d20\u56e0\u6570\u5206\u89e3\n\n    Args:\n        n (int): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n\n    arr = []\n    tmp = n\n    for i in range(2, int(-(-n**0.5 // 1)) + 1):  # sqrt(n) \u307e\u3067\n        # i \u3067\u5272\u308c\u308b\u3060\u3051\u5272\u308b\u3001\u3092\u7e70\u308a\u8fd4\u3059\n        if tmp % i == 0:\n            cnt = 0\n            while tmp % i == 0:\n                cnt += 1\n                tmp //= i\n            arr.append([i, cnt])  # \u7d50\u679c\u3092\u8ffd\u52a0\n\n    if tmp != 1:\n        arr.append([tmp, 1])  # \u307e\u3060\u4f59\u3063\u3066\u3044\u308c\u3070\u8ffd\u52a0\u3057\u3066\u304a\u304f\n\n    if arr == []:\n        arr.append([n, 1])  # \u3053\u306e\u30d6\u30ed\u30c3\u30af\u3001\u5fc5\u8981\u304b\uff1f\n\n    return arr\n\n\ndef main():\n\n    N = int(sys.stdin.readline().rstrip())\n    A = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n    # \u6700\u5c0f\u516c\u500d\u6570\u3092\u4f5c\u308b\n    p = defaultdict(int)  # p \u306b \u56e0\u6570 : \u6307\u6570 \u3067\u3082\u305f\u305b\u308b\n    for a in A:\n        for x, y in factorization(a):\n            p[x] = max(p[x], y)\n\n    # \u4e00\u65e6\u3001\u5168\u90e8\u306e\u639b\u3051\u5408\u308f\u305b\u3092\u4f5c\u308b\n    U = 1\n    for x, y in p.items():\n        U = (U * pow(x, y, mod)) % mod\n\n    # \u8db3\u3059\n    ans = 0\n    for a in A:\n        ans = (ans + U * pow(a, mod - 2, mod)) % mod  # \u9006\u5143\u3092\n\n    print(ans)\n\n\nmain()", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\nfrom functools import reduce\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    from functools import reduce\n\n    # \u6700\u5c0f\u516c\u500d\u6570\n    def lcm_base(x, y):\n        return (x * y) // math.gcd(x, y)\n\n    def lcm_list(numbers):\n        return reduce(lcm_base, numbers, 1)\n\n    n = ni()\n    a = na()\n\n    lcm = a[0]\n    for i in a:\n        lcm = lcm // math.gcd(lcm, i) * i\n    lcm %= MOD\n\n    ans = 0\n    for ai in a:\n        ans += lcm * pow(ai, MOD - 2, MOD) % MOD\n        ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def gcd(m, n):\n    r = m % n\n    return gcd(n, r) if r else n\n\ndef lcm(m, n):\n    return m//gcd(m, n)*n\n\nMOD = 10**9+7\nn = int(input())\na = list(map(int, input().split()))\nl = a[0]\nfor x in a[1:]:\n    l = lcm(x, l)\n\nl %= MOD\n\nans = 0\nfor x in a:\n    ans += l*pow(x, MOD-2, MOD)%MOD\nprint((ans%MOD))\n", "from functools import reduce\nfrom fractions import gcd\nfrom collections import defaultdict,Counter\nimport copy\n\nn = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\n\ndic = defaultdict(int)\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nfor i in a:\n    c = Counter(prime_factorize(i))\n    for j,k in c.items():\n        if dic[j] < k:\n            dic[j] = k\n\nl = 1\n\nfor i,j in dic.items():\n    l *= pow(i,j,mod)\n\npoint = 0\n\nfor i in a:\n    point += l*pow(i,mod-2,mod)\n    point %= mod\n\nprint(point%mod)", "def gcd(a, b):\n    if b==0:\n        return a\n    return gcd(b, a%b)\n\ndef lcm(a, b):\n    return a*(b//gcd(a, b))\n\nmod = int(1e9+7)\ndef ext_gcd(a, b, x, y):\n    if b==0:\n        x[0] = 1\n        y[0] = 0\n        return a\n    g = ext_gcd(b, a%b, y, x)\n    y[0]-=a//b*x[0]\n    return g\n\ndef mod_inv(a):\n    x = [0]\n    y = [0]\n    ext_gcd(a, mod, x, y)\n    return (x[0]%mod + mod)%mod;\n\nn = int(input())\nvs = list(map(int, input().split()))\nl = 1\nfor x in vs:\n    l = lcm(l, x)\nl = l%mod;\nans = 0\nfor x in vs:\n    ans = (ans + ((l*mod_inv(x))%mod))%mod\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\nclass PrimeFactor():\n\n    def __init__(self, n):                  # \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u3000O(N loglog N)\n        self.n = n\n        self.table = list(range(n+1))\n        self.table[2::2] = [2]*(n//2)\n        for p in range(3, int(n**0.5) + 2, 2):\n            if self.table[p] == p:\n                self.table[p * p::2 * p] = [p] * ((n - p * p - 1) // (2 * p) + 1)\n\n    def is_prime(self, x):  # \u7d20\u6570\u5224\u5b9a\u3000O(1)\n        if x < 2:\n            return False\n        return self.table[x] == x\n\n    def prime_factors(self, x):             # \u7d20\u56e0\u6570\u5206\u89e3 O(logN)\n        res = []\n        if x < 2:\n            return res\n        while self.table[x] != 1:\n            res.append(self.table[x])\n            x //= self.table[x]\n        return res\n\n    def prime_counter(self, x):             # \u7d20\u56e0\u6570\u5206\u89e3\uff08\u500b\u6570\u306e\u30ea\u30b9\u30c8\uff09\n        res = defaultdict(int)\n        if x < 2:\n            return res\n        while self.table[x] != 1:\n            res[self.table[x]] += 1\n            x //= self.table[x]\n        return res\n\n    def prime_gcd(self, X):                 # n\u500b\u306e\u6700\u5927\u516c\u7d04\u6570\u3000X:n\u500b\u306e\u30ea\u30b9\u30c8\n        exponents = self.prime_counter(X[0])\n        for x in X[1:]:\n            Y = self.prime_counter(x)\n            for prime, exp in exponents.items():\n                if Y[prime] < exp:\n                    exponents[prime] = Y[prime]\n        res = 1\n        for prime, exp in exponents.items():\n            res *= pow(prime, exp)\n        return res\n\n    def prime_lcm(self, X, mod=None):       # n\u500b\u306e\u6700\u5c0f\u516c\u500d\u6570\u3000X:n\u500b\u306e\u30ea\u30b9\u30c8\n        exponents = defaultdict(int)\n        for x in X:\n            for prime, exp in self.prime_counter(x).items():\n                if exp > exponents[prime]:\n                    exponents[prime] = exp\n        res = 1\n        for prime, exp in exponents.items():\n            res *= pow(prime, exp, mod)\n        if mod == None:\n            return res\n        else:\n            return res % mod\n\nmod = 10 ** 9 + 7\n\nN = int(input())\nA = list(map(int, input().split()))\ntable = PrimeFactor(10**6)\nnum = table.prime_lcm(A,mod)\n\nres = 0\nfor a in A:\n    res += num * pow(a, mod - 2, mod)\n\nprint(res % mod)", "'''\n\u7814\u7a76\u5ba4PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\ndir = [(-1,0),(1,0),(0,-1),(0,1)]\nalp = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef rev(n,mod=(10**9+7)):\n    ni = n\n    nm = 1\n    m2 = mod-2\n    while m2 > 0:\n        if m2&1:\n            nm = (nm*ni)%mod\n        m2 >>= 1\n        ni = (ni**2)%mod\n    return nm\n\n#\u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    d = dict()\n    ni = n\n    pn = 2\n    t = 0\n    while pn**2 <= n and ni > 1:\n        if ni%pn == 0:\n            t += 1\n            ni //= pn\n        else:\n            if not t == 0:\n                d[pn] = t\n                t = 0\n            if pn == 2:\n                pn = 3\n            else:\n                pn += 2\n    if t > 0:\n        d[pn] = t\n    if ni > 1:\n        d[ni] = 1\n    return d\n\ndef main():\n    n = int(ipt())\n    ans = 0\n    a = [int(i) for i in ipt().split()]\n    d = defaultdict(int)\n    for i in a:\n        ans += rev(i)\n        di = factorization(i)\n        for ki,vi in list(di.items()):\n            d[ki] = max(d[ki],vi)\n        ans %= mod\n\n    for ki,vi in list(d.items()):\n        ans *= pow(ki,vi,mod)\n        ans %= mod\n\n    print(ans)\n\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\nclass SieveOfEratosthenes:\n    def __init__(self, V):\n        self.is_prime = np.ones(V + 1, dtype=bool)\n        self.is_prime[4::2] = False\n        self.is_prime[9::3] = False\n        self.is_prime[25::5] = False\n        self.primes = [2, 3, 5]\n        for i in range(7, V + 1, 2):\n            if self.is_prime[i]:\n                self.primes.append(i)\n                self.is_prime[i * i::i] = False\n    \n    def factorize(self, x):\n        assert x >= 1\n        if x == 1:\n            return [(1, 1)]\n        result = []\n        for p in self.primes:\n            exp = 0\n            while x % p == 0:\n                exp += 1\n                x = x // p\n            if exp > 0:\n                result.append((p, exp))\n            if p * p > x:\n                break\n        if x > 1:\n            result.append((x, 1))\n        return result\n\n\nN = int(input())\nM = 10**9 + 7\nA = list(map(int, input().split()))\n\nsieve = SieveOfEratosthenes(10**3)\nF = [dict(sieve.factorize(a)) for a in A]\n\nlcm = F[0]\nfor i in range(1, len(F)):\n    for p, e in list(F[i].items()):\n        if p in lcm:\n            lcm[p] = max(lcm[p], e)\n        else:\n            lcm[p] = e\n\nval = 1\nfor p, e in list(lcm.items()):\n    val = val * pow(p, e, M) % M\n# print(val)\n\nB = [val * pow(a, M - 2, M) % M for a in A]\nprint((sum(B) % M))\n", "n=int(input())\nA=list(map(int,input().split()))\nmod=10**9+7\ndef lcm(X,Y):\n    x=X\n    y=Y\n    if y>x:\n        x,y=y,x\n    while x%y!=0:\n        x,y=y,x%y\n    return X*Y//y\n\ncnt=0\nans=0\nLCM=1\nfor i in range(n):\n    Q=lcm(LCM,A[i])\n    cnt*=Q//LCM\n    LCM=Q\n    cnt+=Q//A[i]\nprint(cnt%mod)", "import sys\nimport math\nimport fractions\ninput = lambda: sys.stdin.readline().rstrip()\n\nmod = 10**9 + 7\n\n\ndef factorize(n):\n    b = 2\n    fct = dict()\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            if b in fct:\n                fct[b] += 1\n            else:\n                fct[b] = 1\n        b = b + 1\n    if n > 1:\n        if b in fct:\n            fct[n] += 1\n        else:\n            fct[n] = 1\n    return fct\n\n\ndef divmod(x, mod=10**9 + 7):\n    return pow(x, mod - 2, mod)\n\n\ndef solve():\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [[1] for _ in range(N)]\n\n    fac_list = dict()\n    for i in range(N):\n        d = factorize(A[i])\n        for k, v in list(d.items()):\n            fac_list[k] = max(fac_list.get(k, 0), v)\n\n    lcm = 1\n    for k, v in list(fac_list.items()):\n        lcm *= (k**v)\n        lcm %= mod\n\n    ans = 0\n    for i in range(N):\n        ans += divmod(A[i])\n        ans %= mod\n\n    ans *= lcm\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "N = int(input())\nA = list(map(int, input().split()))\nmod = 10**9 + 7\na = max(A)\nprime_num = [2]\nsgn = [0 for _ in range(max(int(a**0.5)+1, 4))]\nsgn[2] = 1\nfor k in range(3, len(sgn), 2):\n  if sgn[k] == 0:\n    prime_num.append(k)\n    for j in range(k, a+1, k**2):\n      sgn[k] = 1\nbaisu = []\ncount = [0 for _ in range(a+1)]\nfor k in range(N):\n  b = 0 + A[k]\n  for p in prime_num:\n    if p**2 <= b:\n      if b%p == 0:\n        if count[p] == 0:\n          baisu.append(p)\n        c = 0\n        while b % p == 0:\n          b //= p \n          c += 1 \n        if c > count[p]:\n          count[p] = c\n    else:\n      break\n  if b != 1:\n    if count[b] == 0:\n      count[b] = 1\n      baisu.append(b)\n\nproduct = 1\nfor item in baisu:\n  product *= pow(item, count[item], mod)\n  product %= mod\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\nans = 0\nfor k in range(N):\n  ans += product*modinv(A[k])\n  ans %= mod\n\nprint(ans)\n", "from functools import reduce\nfrom fractions import gcd\nmod = 10**9 + 7\nn, *A = map(int, open(0).read().split())\nif len(A) == 1:\n    print(1)\nelse:\n    l = reduce(lambda x, y: x*y // gcd(x, y), A) % mod\n    s = 0\n    for a in A:\n        s += l * pow(a, mod-2, mod)\n        s %= mod\n    print(s)", "import numpy as np\n\nclass SieveOfEratosthenes:\n    def __init__(self, V):\n        self.is_prime = np.ones(V + 1, dtype=bool)\n        self.is_prime[2::2] = False\n        self.is_prime[3::3] = False\n        self.is_prime[5::5] = False\n        self.primes = [2, 3, 5]\n        for i in range(7, V + 1, 2):\n            if self.is_prime[i]:\n                self.primes.append(i)\n                if i * i < V + 1:\n                    self.is_prime[i * i::i] = False\n    \n    def factorize(self, x, return_dict=False):\n        if x == 1:\n            return {1:1} if return_dict else [(1, 1)]\n        result = []\n        for p in self.primes:\n            exp = 0\n            while x % p == 0:\n                exp += 1\n                x = x // p\n            if exp > 0:\n                result.append((p, exp))\n            if p * p > x:\n                break\n        if x > 1:\n            result.append((x, 1))\n        if return_dict:\n            result = {p: e for p, e in result}\n        return result\n\n\nN = int(input())\nM = 10**9 + 7\nA = list(map(int, input().split()))\n\nsieve = SieveOfEratosthenes(10**3)\nF = [sieve.factorize(a, return_dict=True) for a in A]\n\nlcm = F[0]\nfor i in range(1, len(F)):\n    for p, e in list(F[i].items()):\n        if p in lcm:\n            lcm[p] = max(lcm[p], e)\n        else:\n            lcm[p] = e\n\nval = 1\nfor p, e in list(lcm.items()):\n    val = val * pow(p, e, M) % M\n\nB = [val * pow(a, M - 2, M) % M for a in A]\nprint((sum(B) % M))\n", "import sys\nfrom math import gcd\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    L = 1\n    for a in A:\n        L = lcm(L, a)\n\n    res = 0\n    for a in A:\n        res += L * pow(a, mod - 2, mod)\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import math\nn = int(input())\na = list(map(int, input().split()))\ns = a[0]\nfor i in a[1:]:\n    s = (s*i)//math.gcd(s,i)\nnum = 0\nfor h in a:\n    num += (s//h)\nprint(num%((10**9)+7))", "import math\n\nMOD = 10**9 + 7\n\nans = 0\nN = int(input())\nA = list(map(int,input().split()))\n\nmin_lcm = A[0]\n\n#\u6700\u5c0f\u516c\u500d\u6570\u3092\u6c42\u3081\u308b\nfor i in range(1,N):\n    min_lcm = A[i] * min_lcm // math.gcd(A[i],min_lcm)\n\n\nfor i in range(N):\n    ans += min_lcm // A[i]\n\nprint((ans % MOD))\n", "import math\nimport sys\n\n\ndef lcm(a, b):\n  return a * b // math.gcd(a, b)\n\n\ninput = sys.stdin.readline\nn = int(input())\nA = list(map(int, input().split()))\nLCM = 1\nans = 0\nMOD = 1000000007\nfor x in A:\n  LCM = lcm(LCM, x)\nfor x in A:\n  ans += LCM // x\n\nprint(ans%MOD)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\nm=10**9+7\n\"\"\"n\u3092\u7d20\u56e0\u6570\u5206\u89e3\"\"\"\n\"\"\"2\u4ee5\u4e0a\u306e\u6574\u6570n => [[\u7d20\u56e0\u6570, \u6307\u6570], ...]\u306e2\u6b21\u5143\u30ea\u30b9\u30c8\"\"\"\n\ndef factorization(n):\n    arr = []\n    temp = n\n    i=2\n    if temp%i==0:\n        cnt=0\n        while temp%i==0:\n            cnt+=1\n            temp //= i\n        arr.append([i, cnt])\n            \n    for i in range(3, int(-(-n**0.5//1))+1,2):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])    \n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nN=int(input())\nA=list(map(int,input().split()))\nd = collections.defaultdict(int)\nfor a in A:\n    arr = factorization(a)\n    for ar in arr:\n        if d[ar[0]]<ar[1]:\n            d[ar[0]]=ar[1]\n\nlcm = 1\nfor key,val in list(d.items()):\n    lcm = lcm*pow(key,val)\n\nans = 0\nfor a in A:\n    ans = ans+lcm//a\nprint((ans%m))\n", "import math\nfrom functools import reduce\nn=int(input())\na=list(map(int,input().split()))\ndef lcm(x,y):\n  return x*y//math.gcd(x,y)\nl=reduce(lcm,a)\nb=list(map(lambda x:l//x,a))\nm=10**9+7\nprint(sum(b)%m)", "N = int(input())\nA = list(map(int,input().split()))\n\nmod = pow(10,9)+7\nok = 1\n\nimport math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nLCM = lcm_list(A)\n\nimport numpy as np\nB = np.array(A)\nC = LCM//B\n\n\nprint(sum(C)%mod)", "def make_prime_table(n):\n    sieve = list(range(n + 1))\n    sieve[0] = -1\n    sieve[1] = -1\n    for i in range(4, n + 1, 2):\n        sieve[i] = 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i] != i:\n            continue\n        for j in range(i * i, n + 1, i * 2):\n            if sieve[j] == j:\n                sieve[j] = i\n    return sieve\n\n\ndef prime_factorize(n):\n    result = []\n    while n != 1:\n        p = prime_table[n]\n        e = 0\n        while n % p == 0:\n            n //= p\n            e += 1\n        result.append((p, e))\n    return result\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nprime_table = make_prime_table(10 ** 6)\n\nlcm_factors = {}\nfor a in A:\n    for p, e in prime_factorize(a):\n        if p not in lcm_factors or lcm_factors[p] < e:\n            lcm_factors[p] = e\n\nlcm = 1\nfor p in lcm_factors:\n    lcm *= pow(p, lcm_factors[p], m)\n    lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], m - 2, m)\n    result %= m\nprint(result)\n", "n = int(input())\na = list(map(int, input().split()))\nmod = 10**9+7\nfrom math import gcd\ncm = 1\nfor i in range(n):\n    cm = cm*a[i]//gcd(cm, a[i])\nai = sum(pow(x, mod-2, mod) for x in a)\nprint(int(ai*cm%mod))", "n,*aa = map(int, open(0).read().split())\nMOD = 10**9+7\n\nfrom collections import defaultdict\nfrom math import sqrt, ceil\ndef factors(x):\n    d = defaultdict(int)\n    while x % 2 == 0:\n        d[2] += 1\n        x //= 2\n    for i in range(3, ceil(sqrt(x)) + 2, 2):\n        while x % i == 0:\n            d[i] += 1\n            x //= i\n    if x > 1:\n        d[x] += 1\n    return d\n\nfactors_of_aa = list(map(factors, aa))\n\nfactors_of_lcm = defaultdict(int)\nfor factors_of_a in factors_of_aa:\n    for k in factors_of_a:\n        factors_of_lcm[k] = max(factors_of_lcm[k], factors_of_a[k])\nlcm = 1\nfor factor, cnt in factors_of_lcm.items():\n    lcm *= pow(factor, cnt, MOD)\n\nans = 0\nfor factors_of_a in factors_of_aa:\n    to_add = lcm\n    for factor, cnt in factors_of_a.items():\n        to_add *= pow(factor, -cnt, MOD)\n        to_add %= MOD\n    ans += to_add\n    ans %= MOD\n\nprint(ans)", "\nfrom math import gcd\nfrom functools import reduce\ndef resolve():\n    def lcm_base(x, y):\n        return (x * y) // gcd(x, y)\n\n    def lcm_list(arr):\n        return reduce(lcm_base, arr, 1)\n\n    MOD = 10**9+7\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    num = lcm_list(A) % MOD\n    ans = 0\n    for a in A:\n        ans += (num * pow(a, MOD - 2, MOD)) % MOD\n    ans %= MOD\n\n    print(ans)\n    \ndef __starting_point():\n    resolve()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\nMOD = 10**9 + 7\n\n\ndef fact(N):\n    res = {}\n    tmp = N\n    for i in range(2, int(N ** 0.5 + 1) + 1):\n        cnt = 0\n        while tmp % i == 0:\n            cnt += 1\n            tmp //= i\n        if cnt > 0:\n            res[i] = cnt\n    if tmp != 1:\n        res[tmp] = 1\n    if res == {}:\n        res[N] = 1\n    return res\n\n\ndef modpow(n, p):\n    res = 1\n    while p > 0:\n        if p & 1:\n            res = res * n % MOD\n        n = n * n % MOD\n        p >>= 1\n    return res\n\n\ndef modinv(n):\n    b, u, v = MOD, 1, 0\n    while b > 0:\n        t = n // b\n        n -= t * b\n        n, b = b, n\n        u -= t * v\n        u, v = v, u\n    u %= MOD\n    if u < 0:\n        u += MOD\n    return u\n\n\ndef solve():\n    N = Scanner.int()\n    A = Scanner.map_int()\n    L = defaultdict(int)\n    for i in range(N):\n        for k, v in list(fact(A[i]).items()):\n            L[k] = max(L[k], v)\n    lcm = 1\n    for k, v in list(L.items()):\n        lcm *= modpow(k, v)\n        lcm %= MOD\n    ans = 0\n    for i in range(N):\n        x = lcm * modinv(A[i]) % MOD\n        ans += x\n        ans %= MOD\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\ninput = stdin.readline\nfrom fractions import gcd\n \nmod = 10**9+7\n \nn = int(input())\na = list(map(int,input().split()))\nd = 1\nfor i in range(n):\n  d *= a[i] // gcd(a[i],d)\nans = 0\nfor i in range(n):\n  ans += d//a[i]\n \nprint(ans%mod)", "N = int(input())\n*A, = list(map(int, input().split()))\n\nmod = 10**9 + 7\nMAX = 1_000_000\n\n\ndef gen_primes(n):\n    n = int(n**0.5) + 2\n    is_prime = [True]*n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, n):\n        if is_prime[i]:\n            for j in range(2*i, n, i):\n                is_prime[j] = False\n    return [i for i, flag in enumerate(is_prime) if flag]\n\n\nC = [0]*(MAX+1)\nprimes = gen_primes(MAX)\n\n\ndef prime_fact(n):\n    cnt = 0\n    for p in primes:\n        if n % p:\n            continue\n        while n % p == 0:\n            cnt += 1\n            n //= p\n        C[p] = max(C[p], cnt)\n        cnt = 0\n    if n != 1:\n        C[n] = 1\n\n\nfor a in A:\n    prime_fact(a)\n\nlcm = 1\nfor i, c in enumerate(C):\n    if c:\n        lcm = lcm * pow(i, c, mod) % mod\n\nans = 0\nfor a in A:\n    ans = (ans + lcm * pow(a, mod-2, mod) % mod) % mod\nprint(ans)\n", "n = int(input())\nA = list(map(int, input().split( )))\nmod = 10**9 + 7\n#A\u305f\u3061\u306e\u6700\u5c0f\u516c\u500d\u6570\u3092M\u3068\u3059\u308c\u3070\n#\u7b54\u3048\u306fsum_{i}M/A_{i} (mod 10**9 + 7)\ndef lcm(X,Y):\n    x=X\n    y=Y\n    if y>x:\n        x,y=y,x\n    while x%y!=0:\n        x,y=y,x%y\n    return X*Y//y\n\n#(A,B,C)\u306e\u6700\u5c0f\u516c\u500d\u6570\u3000=(A,B)\u306e\u6700\u5c0f\u516c\u500d\u6570\u3068C\u306e\u6700\u5c0f\u516c\u500d\u6570\u3092\u5229\u7528\u3059\u308c\u3070\u7c21\u5358\u305d\u3046.\na = 1\nc = 0\ns = 0\nfor i in range(n):\n  q = lcm(a,A[i])\n  s*=q//a\n  a = q\n  s+=q//A[i]\nprint((s%mod))\n\n", "import sys\nfrom functools import reduce\nfrom collections import defaultdict\ndef input(): return sys.stdin.readline().rstrip()\n\n\nmod = 10**9+7\n\n\ndef prime(x):\n    pf = defaultdict(int)\n    for i in range(2, int(x**0.5)+1):\n        while x % i == 0:\n            pf[i] += 1\n            x //= i\n    if x > 1:\n        pf[x] = 1\n    return pf\n\n\ndef lcm(x, y):\n    xx=x.copy()\n    yy=y.copy()\n    for k, v in yy.items():\n        xx[k] = max(xx[k], v)\n    return xx\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a2 = list(map(prime, a))\n    lcms = reduce(lcm, a2)\n    lcmss = 1\n    for k, v in lcms.items():\n        lcmss = (lcmss*(k**v)) % mod\n    ans = 0\n    for aa in a:\n        ans += lcmss*pow(aa,-1,mod)\n    print(ans % mod)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n  \nN = int(input())\nA = list(map(int,input().split()))\nans = 0\n\nlcm = lcm_list(A)\n\nfor i in range(N):\n  ans += lcm//A[i]\n\nprint(ans%1000000007)", "import sys\nimport  math\nimport fractions\nfrom collections import defaultdict\nfrom functools import reduce\nimport collections \nstdin = sys.stdin\n         \nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: map(int, stdin.readline().split())\nnl = lambda: list(map(int, stdin.readline().split()))\n     \nINF=10**18\nmod=10**9+7\nN=int(input())\nA=nl()\nNMAX=10**6\nclass Sieve:\n    def __init__(self,n):\n        self.n=n\n        self.f=[0]*(n+1)\n        self.prime=[]\n        self.f[0]=self.f[1]=-1\n        for i in range(2,n+1):\n            if(self.f[i]):\n                continue\n            else:\n                self.prime.append(i)\n                self.f[i]=i\n                for j in range(i*i,n+1,i):\n                    if(~self.f[j]):\n                        self.f[j]=i\n    def isProme(self,x):\n        return (self.f[x]==x)\n    def factorList(self,x):\n        res=[]\n        while(x!=1):\n            res.append(self.f[x])\n            x//=self.f[x]\n        return res\n    def factor(self,x):\n        fl=self.factorList(x)\n        return collections.Counter(fl)\n        \n\n\n                \n                \n            \n        \n        \ndef get_sieve_of_eratosthenes(n):\n    prime = [2]\n    limit = int(n**0.5)\n    data = [i + 1 for i in range(2, n, 2)]\n    while True:\n        p = data[0]\n        if limit <= p:\n            return prime + data\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\n\n\n\nsieve=Sieve(10**6)\nmp=defaultdict(int)\nfor i in range(N):\n    f=sieve.factor(A[i])\n    for key,val in f.items():\n        mp[key]=max(val,mp[key])\n\n\nlcm=1\nfor key,val in mp.items():\n    lcm*=(key**val)\n\n\nans=0\nfor i in range(N):\n    ans+=lcm//A[i]\n\nprint(ans%mod)", "import fractions\nN=int(input())\nA=list(map(int,input().split()))\nMOD=10**9+7\nans=1\ngcd=A[0]\nfor i in range(1,N):\n    a=A[i]\n    b=fractions.gcd(a,gcd)\n    temp=gcd\n    gcd=temp*a//b\n    ans=ans*(a//b)+temp//b\n    ans%=MOD\nprint(ans)", "import numpy as np\n\nclass SieveOfEratosthenes:\n    def __init__(self, V):\n        self.is_prime = np.ones(V + 1, dtype=bool)\n        self.is_prime[4::2] = False\n        self.is_prime[9::3] = False\n        self.is_prime[25::5] = False\n        self.primes = [2, 3, 5]\n        for i in range(7, V + 1, 2):\n            if self.is_prime[i]:\n                self.primes.append(i)\n                if i * i < V + 1:\n                    self.is_prime[i * i::i] = False\n    \n    def factorize(self, x):\n        assert x >= 1\n        if x == 1:\n            return [(1, 1)]\n        result = []\n        for p in self.primes:\n            exp = 0\n            while x % p == 0:\n                exp += 1\n                x = x // p\n            if exp > 0:\n                result.append((p, exp))\n            if p * p > x:\n                break\n        if x > 1:\n            result.append((x, 1))\n        return result\n\n\nN = int(input())\nM = 10**9 + 7\nA = list(map(int, input().split()))\n\nsieve = SieveOfEratosthenes(10**3)\nF = [dict(sieve.factorize(a)) for a in A]\n\nlcm = F[0]\nfor i in range(1, len(F)):\n    for p, e in list(F[i].items()):\n        if p in lcm:\n            lcm[p] = max(lcm[p], e)\n        else:\n            lcm[p] = e\n\nval = 1\nfor p, e in list(lcm.items()):\n    val = val * pow(p, e, M) % M\n# print(val)\n\nB = [val * pow(a, M - 2, M) % M for a in A]\nprint((sum(B) % M))\n", "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b%a, a)\n\ndef lcm(a, b):\n    return (a*b)//gcd(a, b)\n    \nn = int(input())\n\nnumbers = list(map(int, input().split()))\n\nl = numbers[0]\nfor i in range(1, n):\n    l = lcm(l, numbers[i])\n\nans = 0\n\nfor i in range(n):\n    ans += l//numbers[i]\n\nMOD = 1000000007\nprint((ans%MOD))\n", "n = int(input())\nnums = list(map(int, input().split()))\n\nimport math\n\nsumm = 1\nb = 1\nmod = 10**9 + 7\n\nfor idx in range(1, n):\n    temp = b * nums[idx-1]\n    gcd = math.gcd(temp, nums[idx])\n    multiple = nums[idx] // gcd\n    summ *= multiple\n\n    b = b * nums[idx-1] * multiple // nums[idx]\n    summ += b\n    summ %= mod\n\nprint(summ)\n", "import math\nMOD = 10**9+7\n\nN = int(input())\nA = list(map(int,input().split()))\nA.sort()\nMAX = max(A[-1],2)\n\nC = [0 for _ in range(MAX+1)]\n\nfor a in A:\n  C[a] += 1\n\nans = 1\nP = [1 for _ in range(MAX+1)] #\u7d20\u6570\u304b\u3069\u3046\u304b\nP[0] = 0\nP[1] = 0\nS = [0 for _ in range(MAX+1)] #\u6700\u5c0f\u516c\u500d\u6570\u306e\u7d20\u56e0\u6570\u5206\u89e3\u3057\u305f\u3082\u306e\nfor i in range(MAX+1):\n  #\u7d20\u6570\u3067\u306a\u3044\u306a\u3089\u4ee5\u4e0b\u306e\u624b\u9806\u3092\u884c\u308f\u306a\u3044\n  if P[i] == 0:\n    continue\n  #\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n  k = i*2\n  while k <= MAX:\n    P[k] = 0\n    k += i\n  ind = 0\n  k = 1\n  while k <= MAX:\n    k *= i\n    ind += 1\n  k = k // i \n  ind -= 1\n  #\u6700\u5927\u306e\u3079\u304d\u3092\u8abf\u3079\u308b\n  while k > 1:\n    l = k\n    flag = False\n    while l <= MAX:\n      if C[l] > 0:\n        flag = True\n        break\n      l += k\n    if flag:\n      break\n    k = k // i\n    ind -= 1\n  S[i] = ind\n  ans *= pow(i,ind,MOD)\n  ans %= MOD\n  \n#\u30e2\u30b8\u30e5\u30e9\u9006\u6570\ndef xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a // b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0\n\ndef modinv(a, m):\n    g, x, y = xgcd(a, m)\n    #if g != 1:\n        #raise Exception('modular inverse does not exist')\n    #else:\n    return x % m\n      \nB = [0 for _ in range(MAX+1)]\nans_2 = 0\nfor a in A:\n  if B[a] > 0:\n    ans_2 += B[a]\n  else:\n    B[a] = modinv(a, MOD)\n    ans_2 += B[a]    \n  ans_2 %= MOD \n\n#print(ans, ans_2, P, S, B)\nprint(((ans * ans_2) % MOD))\n  \n\n", "from functools import reduce\nfrom math import gcd\n\nMOD = 10 ** 9 + 7\n\n_ = int(input())\nla = list(map(int, input().split()))\n\n\ndef inv(a):\n    return pow(a, MOD - 2, MOD)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\ndef addmod(a, b):\n    return (a + b) % MOD\n\n\nl = reduce(lcm, la) % MOD\nanswer = reduce(addmod, (l * inv(a) for a in la), 0)\nprint(answer)\n", "from itertools import groupby\n\ndef fast_prime_factorization_many(lst):\n    # \u7d20\u56e0\u6570\u5206\u89e3\uff08\u30ed\u30fc\u6cd5\u3001\u8907\u6570\uff09\n    from subprocess import Popen, PIPE\n    res = Popen([\"factor\"] + list(map(str, lst)), stdout=PIPE).communicate()[0].split(b\"\\n\")[:-1]\n    return [list(map(int, r.split()[1:])) for r in res]\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    mod = 10**9+7\n    max_factor = [0] * (1010101)\n    lcm = 1\n    Factors = fast_prime_factorization_many(A)\n    for factors in Factors:\n        for prime, group in groupby(factors):\n            n = len(list(group))\n            n_old = max_factor[prime]\n            if n_old < n:\n                for i in range(n - n_old):\n                    lcm = lcm * prime % mod\n                max_factor[prime] = n\n    ans = 0\n    for a in A:\n        ans += pow(a, mod-2, mod)\n    ans = ans * lcm % mod\n    print(ans)\n\nmain()\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(pow(n, 0.5)) + 1):\n        if n % i == 0:\n            ex = 0\n            while n % i == 0:\n                ex += 1\n                n //= i\n            res.append([i, ex])\n    if n != 1:\n        res.append([n, 1])\n    return res\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    prime = [0] * max(A)\n    for a in A:\n        primes = prime_factorization(a)\n        for num, ex in primes:\n            prime[num - 1] = max(prime[num - 1], ex)\n\n    L = 1\n    for i in range(len(prime)):\n        if prime[i] == 0:\n            continue\n        L *= pow(i + 1, prime[i])\n\n    res = 0\n    for a in A:\n        res += L * pow(a, mod - 2, mod)\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import math\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\nn = int(input())\na = list(map(int,input().split()))\nmod = 10**9 + 7\n\nlc = 1\nfor i in range(n):\n    lc = lcm(lc,a[i])\nans = 0\nfor i in range(n):\n    ans += lc * pow(a[i],-1,mod)\n    ans %= mod\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass Eratosthenes:\n    def __init__(self, n):\n        self.n = n\n        self.min_factor = [-1] * (n + 1)\n        self.min_factor[0], self.min_factor[1] = 0, 1\n\n    def get_primes(self):\n        primes = []\n        is_prime = [True] * (self.n + 1)\n        is_prime[0] = is_prime[1] = False\n        for i in range(2, self.n + 1):\n            if not is_prime[i]:\n                continue\n            primes.append(i)\n            self.min_factor[i] = i\n            for j in range(i * 2, self.n + 1, i):\n                is_prime[j] = False\n                if self.min_factor[j] == -1:\n                    self.min_factor[j] = i\n        return primes\n\n    def prime_factorization(self, n):\n        res = []\n        while n != 1:\n            prime = self.min_factor[n]\n            exp = 0\n            while self.min_factor[n] == prime:\n                exp += 1\n                n //= prime\n            res.append([prime, exp])\n        return res\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    MAX_A = max(A) + 1\n\n    er = Eratosthenes(MAX_A)\n    er.get_primes()\n    num = [0] * MAX_A\n    for i in range(n):\n        pf = er.prime_factorization(A[i])\n        for p, ex in pf:\n            num[p] = max(num[p], ex)\n\n    LCM = 1\n    for v in range(2, MAX_A):\n        LCM *= pow(v, num[v], mod)\n        LCM %= mod\n\n    res = 0\n    for a in A:\n        res += LCM * pow(a, mod - 2, mod)\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import math\nn = int(input())\na = list(map(int,input().split()))\nmod = 10**9+7\nans = 0\nlcm = a[0]\nfor i in range(1,n):\n    lcm = lcm*a[i]//math.gcd(lcm,a[i])\nfor i in range(n):\n    ans += lcm//a[i]\nprint(ans%mod)", "n = int(input())\nnums = list(map(int, input().split()))\n\n\ndef factorize(n):\n    if n == 1:\n        raise('n >= 2')\n    \n    factor = {}\n    div = 2\n    while True:\n        if div * div > n:\n            factor[n] = factor.get(n, 0) + 1\n            return factor\n\n        if n % div == 0:\n            n //= div\n            factor[div] = factor.get(div, 0) + 1\n        else:\n            div += 1\n\n\ndef factor_product(a, b):\n    '''\n    \u7d20\u56e0\u6570\u5206\u89e3\u306edict a, b\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\n    \u7a4d\u306b\u5bfe\u5fdc\u3059\u308bdict\u3092\u8fd4\u3059\n    '''\n    product = a.copy()\n    for k, v in list(b.items()):\n        product[k] = product.get(k, 0) + v\n    return product\n\nimport math\n\nsumm = 1\nb = 1\nmod = 10**9 + 7\n\nfor idx in range(1, n):\n    temp = b * nums[idx-1]\n    gcd = math.gcd(temp, nums[idx])\n    multiple = nums[idx] // gcd\n    summ *= multiple\n\n    b = b * nums[idx-1] * multiple // nums[idx]\n    summ += b\n    summ %= mod\n\nprint(summ)\n", "import sys\nimport  math\nimport fractions\nfrom collections import defaultdict\nfrom functools import reduce\nstdin = sys.stdin\n         \nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n     \nINF=10**18\nmod=10**9+7\nN=int(input())\nA=nl()\nans=0\nmin_bai=1\n#for i in range(N):#\u6700\u5927\u516c\u500d\u6570\n#    min_bai=min_bai*A[i]//fractions.gcd(min_bai,A[i])\n\nlcm = reduce(lambda x,y: x//fractions.gcd(x,y)*y, A)\n \n#for i in range(N):\n#    ans+=lcm//A[i]\n\nans = sum(lcm//x for x in A)\nprint((ans%mod))\n", "from math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = [int(i) for i in input().split()]\nmod = 10**9 + 7\n\ndef lcm_base(x, y):\n    return (x * y) // gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nnum = lcm_list(A)%mod\nans = 0\nfor a in A:\n    ans += (num * pow(a, mod-2, mod))%mod\nans %= mod\n\nprint(ans)\n", "# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9, \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef make_prime_table(n):\n    sieve = list(range(n + 1))\n    sieve[0] = -1\n    sieve[1] = -1\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i] != i:\n            continue\n        for j in range(i * i, n + 1, i):\n            if sieve[j] == j:\n                sieve[j] = i\n    return sieve\n\n\ndef prime_factorize(n):\n    result = []\n    while n != 1:\n        p = prime_table[n]\n        c = 0\n        while n % p == 0:\n            n //= p\n            c += 1\n        result.append((p, c))\n    return result\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nprime_table = make_prime_table(10 ** 6)\n\nlcm_factors = {}\nfor a in A:\n    for p, c in prime_factorize(a):\n        if p not in lcm_factors or lcm_factors[p] < c:\n            lcm_factors[p] = c\n\nlcm = 1\nfor p in lcm_factors:\n    lcm *= pow(p, lcm_factors[p], m)\n    lcm %= m\n\nresult = 0\nfor i in range(N):\n    result += lcm * pow(A[i], -1, m)\n    result %= m\nprint(result)\n", "import fractions\nc=0\nN=int(input())\nL=list(map(int,input().split()))\na=L[0]\nfor i in range(1,N):\n  a=(L[i]*a)//fractions.gcd(L[i], a)\nfor i in range(N):\n  c+=(a//L[i])\nprint(c%(10**9+7))", "n = int(input())\na = list(map(int,input().split()))\nso_list = [0 for i in range(10**6)]\nmod = 10**9+7\n\ndef fac(n):\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            if so_list[i]<cnt:\n              so_list[i]= cnt\n    if temp!=1:\n    #  print(temp)\n      if so_list[temp]==0:\n        so_list[temp]=1\nfor i in range(n):\n  a1 = a[i]\n  fac(a1)\nl = 1\nfor i in range(len(so_list)):\n  if so_list[i]!=0:\n    l *= pow(i,so_list[i],mod)\n    l %= mod\nans = 0\n#print(l)\nfor i in a:\n  t = pow(i,mod-2,mod)\n  ans += (l*t)%mod\nprint((ans%mod))\n", "def gcd(a:int,b:int):\n\tif (a > b):\n\t\tc = a\n\t\ta = b\n\t\tb = c\n\tif (a == 0):\n\t\treturn b\n\treturn gcd(b % a, a)\n\ndef lcm(a, b):\n\tGCD = gcd(a,b)\n\treturn a*b//GCD\n\ndef lcm_of_all(v):\n    tmp = v[0]\n    for i in range(1,len(v)):\n        tmp = lcm(tmp,v[i])\n    return tmp\n\nN = int(input())\nliA = list(map(int,input().split()))\nliB = [-1 for _ in range(N)]\nG = lcm_of_all(liA)\nMOD = 10**9+7\nss = 0\nfor i in range(N):\n    liB[i] = G//liA[i]\n    ss += liB[i]\nss %= MOD\nprint(ss)"]
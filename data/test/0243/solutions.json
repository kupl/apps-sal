["def g():\n return list(map(int,input().split()))\nn,m,k=g()\np=list(range(n+1))\nz=[0]*(n+1)\nfor x in g():\n z[x]=1\ne=[]\nfor i in range(m):\n u,v,w=g()\n e+=[(w,u,v)]\ne=sorted(e)\ndef q(x):\n if x!=p[x]:\n  p[x]=q(p[x])\n return p[x]\nfor w,u,v in e:\n u=q(u);v=q(v)\n if u!=v:\n  if u%5==3:\n   u,v=v,u\n  p[u]=v;z[v]+=z[u]\n  if z[v]==k:\n   print(((str(w)+' ')*k));return\n", "import sys\nimport heapq\nfrom collections import deque\n\nn,m,k=list(map(int,sys.stdin.readline().split()))\nX=list(map(int,sys.stdin.readline().split()))\nstart=X[0]\n\nEDGE=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\nCOST_vertex=[[] for i in range(n+1)]\nfor i,j,w in EDGE:\n    COST_vertex[i].append((j,w))\n    COST_vertex[j].append((i,w))\n    \n\nMINCOST=[float(\"inf\")]*(n+1)#\u6c42\u3081\u305f\u3044\u30ea\u30b9\u30c8:start\u304b\u3089\u9802\u70b9i\u3078\u306e\u6700\u77ed\u8ddd\u96e2\nMINCOST[start]=0\nchecking=[(0,start)]#start\u6642\u70b9\u306ecost\u306f0.\u6700\u521d\u306f\u3053\u308c\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b.\nwhile checking:\n    cost,checktown=heapq.heappop(checking)\n    #cost,checktown\u304b\u3089\u306e\u884c\u304d\u5148\u3092check.\n    #cost\u6700\u5c0f\u306a\u3082\u306e\u3092\u78ba\u5b9a\u3057,\u78ba\u5b9a\u3057\u305f\u3082\u306e\u306fchecking\u304b\u3089\u629c\u304f.\n    if MINCOST[checktown]<cost:#\u78ba\u5b9a\u3057\u305f\u3082\u306e\u3092\u518d\u5ea6\u30c1\u30a7\u30c3\u30af\u3057\u306a\u304f\u3066\u826f\u3044.\n        continue    \n    for to,co in COST_vertex[checktown]:\n        if MINCOST[to]>max(MINCOST[checktown],co):\n            MINCOST[to]=max(MINCOST[checktown],co)\n            #MINCOST\u5019\u88dc\u306b\u8ffd\u52a0\n            heapq.heappush(checking,(max(MINCOST[checktown],co),to))\n\n\nANSLIST=[MINCOST[X[i]] for i in range(1,k)]\n\nANS=(str(max(ANSLIST))+\" \")*k\n\nsys.stdout.write(str(ANS)+\"\\n\")\n    \n\n", "import sys\nimport heapq\nfrom collections import deque\n\nn,m,k=list(map(int,sys.stdin.readline().split()))\nX=list(map(int,sys.stdin.readline().split()))\nstart=X[0]\n\nEDGE=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\nCOST_vertex=[[] for i in range(n+1)]\nfor i,j,w in EDGE:\n    COST_vertex[i].append((j,w))\n    COST_vertex[j].append((i,w))\n    \n\nMINCOST=[float(\"inf\")]*(n+1)#\u6c42\u3081\u305f\u3044\u30ea\u30b9\u30c8:start\u304b\u3089\u9802\u70b9i\u3078\u306e\u6700\u77ed\u8ddd\u96e2\nMINCOST[start]=0\nchecking=[(0,start)]#start\u6642\u70b9\u306ecost\u306f0.\u6700\u521d\u306f\u3053\u308c\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b.\nwhile checking:\n    cost,checktown=heapq.heappop(checking)\n    #cost,checktown\u304b\u3089\u306e\u884c\u304d\u5148\u3092check.\n    #cost\u6700\u5c0f\u306a\u3082\u306e\u3092\u78ba\u5b9a\u3057,\u78ba\u5b9a\u3057\u305f\u3082\u306e\u306fchecking\u304b\u3089\u629c\u304f.\n    if MINCOST[checktown]<cost:#\u78ba\u5b9a\u3057\u305f\u3082\u306e\u3092\u518d\u5ea6\u30c1\u30a7\u30c3\u30af\u3057\u306a\u304f\u3066\u826f\u3044.\n        continue    \n    for to,co in COST_vertex[checktown]:\n        if MINCOST[to]>max(MINCOST[checktown],co):\n            MINCOST[to]=max(MINCOST[checktown],co)\n            #MINCOST\u5019\u88dc\u306b\u8ffd\u52a0\n            heapq.heappush(checking,(max(MINCOST[checktown],co),to))\n\n\nANSLIST=[MINCOST[X[i]] for i in range(1,k)]\n\nANS=(str(max(ANSLIST))+\" \")*k\n\nsys.stdout.write(str(ANS)+\"\\n\")\n    \n\n", "import sys\nsys.setrecursionlimit(300000)\nn,m,k=list(map(int,input().split()))\nx=list(map(int,input().split()))\nedges=[]\nfor i in range(m):\n    a,b,c=list(map(int,input().split()))\n    edges.append((c,a,b))\nedges.sort()\ntree=[i for i in range(n+1)]\nused=[]\nedgess=0\ndef q(x):\n    if x!=tree[x]:\n        tree[x]=q(tree[x])\n    return(tree[x])\nfor w,u,v in edges:\n    if edgess==n-1:\n        break\n    a,b=q(u),q(v)\n    if a%2==1:\n        a,b=b,a\n    if a!=b:\n        tree[a]=b\n        used.append((w,u,v))\n        edgess+=1\nneigh=[]\nfor i in range(n+1):\n    neigh.append([])\nfor w,u,v in used:\n    neigh[u].append((v,w))\n    neigh[v].append((u,w))\nlayer=[x[0]]\npars=[None]\ndists=[None]*(n+1)\ndists[x[0]]=0\nwhile layer!=[]:\n    newlayer=[]\n    newpars=[]\n    for i in range(len(layer)):\n        guy=layer[i]\n        par=pars[i]\n        for v,w in neigh[guy]:\n            if v!=par:\n                dists[v]=max(dists[guy],w)\n                newlayer.append(v)\n                newpars.append(guy)\n    layer=newlayer\n    pars=newpars\nhigh=0\nfor guy in x:\n    high=max(high,dists[guy])\nprint((str(high)+\" \")*k)\n", "import sys\ndef int_reader():\n    yield from (int(d) for d in sys.stdin.read().split())\n\nints = int_reader()\nn, m, k = [next(ints) for i in range(3)]\nspecial = [next(ints) for i in range(k)]\nis_special = [0]*(n+1)\nfor x in special:\n    is_special[x] = 1\n\nedges = []\nfor i in range(m):\n    u, v, w = [next(ints) for j in range(3)]\n    edges.append((w, u, v))\nedges.sort()\n\nfu = [i for i in range(n+1)]\ndef find(x):\n    S = []\n    while fu[x] != x:\n        S.append(x)\n        x = fu[x]\n    for y in S:\n        fu[y] = x\n    return x\ndef union(e):\n    a, b = find(e[1]), find(e[2])\n    if is_special[b]:\n        a, b = b, a\n    fu[b] = a\n\nans = 0\nfor e in edges:\n    a, b = find(e[1]), find(e[2])\n    if a == b: continue\n    if is_special[a] and is_special[b]:\n        ans = e[0]\n    union(e)\nprint((str(ans) + ' ') * k)\n", "import sys\ndef int_reader():\n    yield from (int(d) for d in sys.stdin.read().split())\n\nints = int_reader()\nn, m, k = [next(ints) for i in range(3)]\nsp = {next(ints) for i in range(k)}\n\nedges = []\nfor i in range(m):\n    u, v, w = [next(ints) for j in range(3)]\n    edges.append((w, u, v))\nedges.sort()\n\nfu = [i for i in range(n+1)]\ndef find(x):\n    S = []\n    while fu[x] != x:\n        S.append(x)\n        x = fu[x]\n    for y in S:\n        fu[y] = x\n    return x\ndef union(a, b):\n    if b in sp:\n        a, b = b, a\n    fu[b] = a\n\nans = 0\nfor e in edges:\n    a, b = find(e[1]), find(e[2])\n    if a == b: continue\n    if a in sp and b in sp:\n        ans = e[0]\n    union(a, b)\nprint((str(ans) + ' ') * k)\n", "n, m, k = map(int, input().split())\nx = list(map(int, input().split()))\ne = []\nfor _ in range(m) :\n    e.append(tuple(map(int, input().split())))\ne.sort(key = lambda x : x[2])\n\nfa = list(range(n + 1))\nsz = [0] * (n + 1)\nfor u in x : sz[u] += 1\n\ndef find(x) :\n    while fa[x] != x :\n        fa[x] = fa[fa[x]]\n        x = fa[x]\n    return x\n\ndef unite(u, v) :\n    u, v = map(find, (u, v))\n    fa[u] = v;\n    if u == v : return False\n    ret = sz[u] > 0 and sz[v] > 0\n    sz[v] += sz[u]\n    return ret\n\nfor ed in e : \n    if unite(ed[0], ed[1]) : ans = ed[2]\n\nprint(*[ans]*k)", "import sys\ndef int_reader():\n    yield from (int(d) for d in sys.stdin.read().split())\n\nints = int_reader()\nn, m, k = [next(ints) for i in range(3)]\nsp = {next(ints) for i in range(k)}\n\n'''\nedges = []\nfor i in range(m):\n    u, v, w = [next(ints) for j in range(3)]\n    edges.append((w, u, v))\n'''\nedges = [(w,u,v) for (u,v,w) in [(next(ints) for i in range(3)) for j in range(m)]]\nedges.sort()\n\nfu = [i for i in range(n+1)]\ndef find(x):\n    S = []\n    while fu[x] != x:\n        S.append(x)\n        x = fu[x]\n    for y in S:\n        fu[y] = x\n    return x\ndef union(a, b):\n    if b in sp:\n        a, b = b, a\n    fu[b] = a\n\nans = 0\nfor e in edges:\n    a, b = find(e[1]), find(e[2])\n    if a == b: continue\n    if a in sp and b in sp:\n        ans = e[0]\n    union(a, b)\nprint((str(ans) + ' ') * k)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Apr 28 18:52:59 2019\n\n@author: phamv\n\"\"\"\n####Function Definition \ndef find(x):\n    while f[x] != x :\n        f[x] = f[f[x]]\n        x = f[x]\n    return x\n\ndef merge(u, v) :\n    u, v = map(find, (u, v))\n    f[u] = v;\n    if u == v:\n        return False\n    ret = s[u] > 0 and s[v] > 0\n    s[v] += s[u]\n    return ret\n\n###############\n\nn, m, k = map(int, input().split())\nx = list(map(int, input().split()))\nlst = list()\nfor i in range(m):\n    lst.append(tuple(map(int, input().split())))\nlst.sort(key = lambda x: x[2])\n\nf = list(range(n + 1))\ns = [0] * (n + 1)\n\nfor j in x:\n    s[j] += 1\n\nfor h in lst: \n    if merge(h[0], h[1]): \n        answer = h[2]\n\nprint(*[answer]*k)", "\"\"\"\n@author: phamv\n\"\"\"\n####Function Definition \ndef find(x):\n    while f[x] != x :\n        f[x] = f[f[x]]\n        x = f[x]\n    return x\n\ndef merge(u, v) :\n    u, v = map(find, (u, v))\n    f[u] = v;\n    if u == v:\n        return False\n    ret = s[u] > 0 and s[v] > 0\n    s[v] += s[u]\n    return ret\n\n###############\n\nn, m, k = map(int, input().split())\nx = list(map(int, input().split()))\nlst = list()\nfor i in range(m):\n    lst.append(tuple(map(int, input().split())))\nlst.sort(key = lambda x: x[2])\n\nf = list(range(n + 1))\ns = [0] * (n + 1)\n\nfor j in x:\n    s[j] += 1\n\nfor h in lst: \n    if merge(h[0], h[1]): \n        answer = h[2]\n\nprint(*[answer]*k)", "def g():\n return map(int,input().split())\nn,m,k=g()\np=list(range(n+1))\nz=[0]*(n+1)\nfor x in g():\n z[x]=1\ne=[]\nfor i in range(m):\n u,v,w=g()\n e+=[(w,u,v)]\ne=sorted(e)\ndef q(x):\n if x!=p[x]:\n  p[x]=q(p[x])\n return p[x]\nfor w,u,v in e:\n u=q(u);v=q(v)\n if u!=v:\n  if u%5==3:\n   u,v=v,u\n  p[u]=v;z[v]+=z[u]\n  if z[v]==k:\n   print((str(w)+' ')*k);return", "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\ng = []\n\nf = list(range(n+1))\ns = [0] * (n+1)\n\ndef search(n):\n    while f[n] != n:\n        f[n] = f[f[n]]\n        n = f[n]\n    return n\ndef can_merge(u, v):\n    u = search(u)\n    v = search(v)\n    f[u] = v\n    if u == v:\n        return False\n    r = s[u] > 0 and s[v] > 0\n    s[v] += s[u]\n    return r\n\nfor _ in range(m):\n    u,v,w = map(int, input().split())\n    g.append((u,v,w))\ng.sort(key = lambda tup: tup[2])\n\nfor i in a:\n    s[i] += 1\n\nans = 0\nfor t in g:\n    if can_merge(t[0],t[1]):\n       ans = t[2]\n\nprint(' '.join([str(ans)] * k))", "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\ng = []\n\nf = list(range(n+1))\ns = [0] * (n+1)\n\ndef search(n):\n    while f[n] != n:\n        f[n] = f[f[n]]\n        n = f[n]\n    return n\ndef can_merge(u, v):\n    u = search(u)\n    v = search(v)\n    f[u] = v\n    if u == v:\n        return False\n    r = s[u] > 0 and s[v] > 0\n    s[v] += s[u]\n    return r\n\nfor _ in range(m):\n    u,v,w = map(int, input().split())\n    g.append((u,v,w))\ng.sort(key = lambda tup: tup[2])\n\nfor i in a:\n    s[i] += 1\n\nans = 0\nfor t in g:\n    if can_merge(t[0],t[1]):\n       ans = t[2]\n\nprint(' '.join([str(ans)] * k))", "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\ng = []\n\nf = list(range(n+1))\ns = [0] * (n+1)\n\ndef search(n):\n    while f[n] != n:\n        # print(f[n])\n\n        f[n] = f[f[n]]\n        n = f[n]\n    return n\ndef can_merge(u, v):\n    u = search(u)\n    v = search(v)\n    f[u] = v\n    if u == v:\n        return False\n    r = s[u] > 0 and s[v] > 0\n    s[v] += s[u]\n    return r\n\nfor _ in range(m):\n    u,v,w = map(int, input().split())\n    g.append((u,v,w))\ng.sort(key = lambda tup: tup[2])\n\nfor i in a:\n    s[i] += 1\n\nans = 0\nfor t in g:\n    if can_merge(t[0],t[1]):\n       ans = t[2]\n\nprint(' '.join([str(ans)] * k))", "class Union:\n    def __init__(self, n, list_k):\n        self.p    = {i:i for i in range(n+1)}\n        self.rank = {i:0 for i in range(n+1)} \n        \n        for k in list_k:\n            self.rank[k] = 1\n            \n    def find(self, x):\n        if x < 0: return x\n    \n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        if x < 0 or y < 0:return\n        \n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.p[x]     = y\n                self.rank[y] += self.rank[x]\n            else:\n                self.p[y]     = x\n                self.rank[x] += self.rank[y]\n                \nn, m, k  = list(map(int, input().split()))\nlist_k   = list(map(int, input().split()))\nedge  = []\n\nfor _ in range(m):\n    u, v, w = list(map(int, input().split()))\n    edge.append((u,v,w))\n    \nedge = sorted(edge, key=lambda x:x[2])\n\nU   = Union(n, list_k)\nval = 0\n\nfor u, v, w in edge:\n    if u == v: continue\n        \n    par_1 =  U.find(u)\n    par_2 =  U.find(v)    \n        \n    if par_1 == par_2:\n        continue\n        \n    if U.rank[par_1] + U.rank[par_2] == k:\n        val = w\n        break\n    \n    U.union(u, v)\n\ns = ''\nfor _ in  range(len(list_k)):\n    s += str(val) + ' '    \n                \nprint(s)\n                \n#2 3 2\n#2 1\n#1 2 3\n#1 2 2\n#2 2 1\n", "import sys\ninput = sys.stdin.readline\n\n# def find(a):\n#     if par[a] == a:\n#         return a\n#     par[a] = find(par[a])\n#     return par[a]\n\ndef find(a):\n    upd = []\n    cur = a\n    while par[cur] != cur:\n        upd.append(cur)\n        cur = par[cur]\n    for x in upd:\n        par[x] = cur\n    return cur\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a == b:\n        return\n    par[a] = b\n\n\ndef mst():\n    ret = []\n    for edge in edges:\n        u, v, w = edge\n        u = find(u)\n        v = find(v)\n        if u != v:\n            union(u, v)\n            ret.append(edge)\n    return ret\n\n\ndef dfs(u, par):\n    for v, w in adj[u]:\n        if v != par:\n            dist[v] = max(dist[u], w)\n            dfs(v, u)\n\ndef bfs(u):\n    visit = [False] * (n+1)\n    from collections import deque\n\n    dq = deque()\n    dq.append(u)\n    visit[u] = True\n    while dq:\n        u = dq.popleft()\n        for v, w in adj[u]:\n            if not visit[v]:\n                dist[v] = max(dist[u], w)\n                dq.append(v)\n                visit[v] = True\n\n\nn, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n# n = 50000\n# m = 2 * n\n# k = n\n# a = [i for i in range(1, n+1)]\n# import random\n\npar = [0] * (n+1)\nfor i in range(1, n+1):\n    par[i] = i\nedges = []\n# for i in range(1, n+1):\n#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n#     edges.append(edge)\nfor i in range(m):\n    edge = tuple(map(int, input().split()))\n    edges.append(edge)\nedges.sort(key=lambda x: x[2])\nedges = mst()\nadj = [list() for i in range(n+1)]\nfor edge in edges:\n    u, v, w = edge\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndist = [0] * (n+1)\n# dfs(a[0], -1)\nbfs(a[0])\nans = 0\nfor x in a:\n    ans = max(ans, dist[x])\nans = [ans] * k\nprint(*ans)\n\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    # def find(a):\n    #     if par[a] == a:\n    #         return a\n    #     par[a] = find(par[a])\n    #     return par[a]\n    \n    def find(a):\n        upd = []\n        cur = a\n        while par[cur] != cur:\n            upd.append(cur)\n            cur = par[cur]\n        for x in upd:\n            par[x] = cur\n        return cur\n    \n    def union(a, b):\n        a = find(a)\n        b = find(b)\n        if a == b:\n            return\n        par[a] = b\n    \n    \n    def mst():\n        ret = []\n        for edge in edges:\n            u, v, w = edge\n            u = find(u)\n            v = find(v)\n            if u != v:\n                union(u, v)\n                ret.append(edge)\n        return ret\n    \n    \n    def dfs(u, par):\n        for v, w in adj[u]:\n            if v != par:\n                dist[v] = max(dist[u], w)\n                dfs(v, u)\n    \n    def bfs(u):\n        visit = [False] * (n+1)\n        from collections import deque\n    \n        dq = deque()\n        dq.append(u)\n        visit[u] = True\n        while dq:\n            u = dq.popleft()\n            for v, w in adj[u]:\n                if not visit[v]:\n                    dist[v] = max(dist[u], w)\n                    dq.append(v)\n                    visit[v] = True\n    \n    \n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    # n = 50000\n    # m = 2 * n\n    # k = n\n    # a = [i for i in range(1, n+1)]\n    # import random\n    \n    par = [0] * (n+1)\n    for i in range(1, n+1):\n        par[i] = i\n    edges = []\n    # for i in range(1, n+1):\n    #     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n    #     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n    #     edges.append(edge)\n    for i in range(m):\n        edge = tuple(map(int, input().split()))\n        edges.append(edge)\n    edges.sort(key=lambda x: x[2])\n    edges = mst()\n    adj = [list() for i in range(n+1)]\n    for edge in edges:\n        u, v, w = edge\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    \n    dist = [0] * (n+1)\n    # dfs(a[0], -1)\n    bfs(a[0])\n    ans = 0\n    for x in a:\n        ans = max(ans, dist[x])\n    ans = [ans] * k\n    print(*ans)\n    \n\nmain()", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    # def find(a):\n    #     if par[a] == a:\n    #         return a\n    #     par[a] = find(par[a])\n    #     return par[a]\n\n    def find(a):\n        upd = []\n        cur = a\n        while par[cur] != cur:\n            upd.append(cur)\n            cur = par[cur]\n        for x in upd:\n            par[x] = cur\n        return cur\n\n    def union(a, b):\n        a = find(a)\n        b = find(b)\n        if a == b:\n            return\n        if height[b] > height[a]:\n            a, b = b, a\n        par[b] = a\n        if height[a] == height[b]:\n            height[a] += 1\n\n\n    def mst():\n        ret = []\n        for edge in edges:\n            u, v, w = edge\n            u = find(u)\n            v = find(v)\n            if u != v:\n                union(u, v)\n                ret.append(edge)\n        return ret\n\n\n    def dfs(u, par):\n        for v, w in adj[u]:\n            if v != par:\n                dist[v] = max(dist[u], w)\n                dfs(v, u)\n\n    def bfs(u):\n        visit = [False] * (n+1)\n        from collections import deque\n\n        dq = deque()\n        dq.append(u)\n        visit[u] = True\n        while dq:\n            u = dq.popleft()\n            for v, w in adj[u]:\n                if not visit[v]:\n                    dist[v] = max(dist[u], w)\n                    dq.append(v)\n                    visit[v] = True\n\n\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    # n = 50000\n    # m = 2 * n\n    # k = n\n    # a = [i for i in range(1, n+1)]\n    # import random\n\n    par = [0] * (n+1)\n    height = [1] * (n+1)\n    for i in range(1, n+1):\n        par[i] = i\n        height[i] = 1\n    edges = []\n    # for i in range(1, n+1):\n    #     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n    #     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n    #     edges.append(edge)\n    for i in range(m):\n        edge = tuple(map(int, input().split()))\n        edges.append(edge)\n    edges.sort(key=lambda x: x[2])\n    edges = mst()\n    adj = [list() for i in range(n+1)]\n    for edge in edges:\n        u, v, w = edge\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n\n    dist = [0] * (n+1)\n    # dfs(a[0], -1)\n    bfs(a[0])\n    ans = 0\n    for x in a:\n        ans = max(ans, dist[x])\n    ans = [ans] * k\n    print(*ans)\n\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    # def find(a):\n    #     if par[a] == a:\n    #         return a\n    #     par[a] = find(par[a])\n    #     return par[a]\n\n    def find(a):\n        upd = []\n        cur = a\n        while par[cur] != cur:\n            upd.append(cur)\n            cur = par[cur]\n        for x in upd:\n            par[x] = cur\n        return cur\n\n    def union(a, b):\n        a = find(a)\n        b = find(b)\n        if a == b:\n            return\n        par[b] = a\n\n\n    def mst():\n        ret = []\n        for edge in edges:\n            u, v, w = edge\n            u = find(u)\n            v = find(v)\n            if u != v:\n                union(u, v)\n                ret.append(edge)\n        return ret\n\n\n    def dfs(u, par):\n        for v, w in adj[u]:\n            if v != par:\n                dist[v] = max(dist[u], w)\n                dfs(v, u)\n\n    def bfs(u):\n        visit = [False] * (n+1)\n        from collections import deque\n\n        dq = deque()\n        dq.append(u)\n        visit[u] = True\n        while dq:\n            u = dq.popleft()\n            for v, w in adj[u]:\n                if not visit[v]:\n                    dist[v] = max(dist[u], w)\n                    dq.append(v)\n                    visit[v] = True\n\n\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    # n = 50000\n    # m = 2 * n\n    # k = n\n    # a = [i for i in range(1, n+1)]\n    # import random\n\n    par = [0] * (n+1)\n    for i in range(1, n+1):\n        par[i] = i\n    edges = []\n    # for i in range(1, n+1):\n    #     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n    #     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n    #     edges.append(edge)\n    for i in range(m):\n        edge = tuple(map(int, input().split()))\n        edges.append(edge)\n    edges.sort(key=lambda x: x[2])\n    edges = mst()\n    adj = [list() for i in range(n+1)]\n    for edge in edges:\n        u, v, w = edge\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n\n    dist = [0] * (n+1)\n    # dfs(a[0], -1)\n    bfs(a[0])\n    ans = 0\n    for x in a:\n        ans = max(ans, dist[x])\n    ans = [ans] * k\n    print(*ans)\n\n\nmain()", "import sys\nsys.setrecursionlimit(300000)\nn,m,k=list(map(int,input().split()))\nx=list(map(int,input().split()))\nedges=[]\nfor i in range(m):\n    a,b,c=list(map(int,input().split()))\n    edges.append((c,a,b))\nedges.sort()\ntree=[i for i in range(n+1)]\nused=[]\nedgess=0\ndef q(x):\n    if x!=tree[x]:\n        tree[x]=q(tree[x])\n    return(tree[x])\nfor w,u,v in edges:\n    if edgess==n-1:\n        break\n    a,b=q(u),q(v)\n    if a%2==1:\n        a,b=b,a\n    if a!=b:\n        tree[a]=b\n        used.append((w,u,v))\n        edgess+=1\nneigh=[]\nfor i in range(n+1):\n    neigh.append([])\nfor w,u,v in used:\n    neigh[u].append((v,w))\n    neigh[v].append((u,w))\nlayer=[x[0]]\npars=[None]\ndists=[None]*(n+1)\ndists[x[0]]=0\nwhile layer!=[]:\n    newlayer=[]\n    newpars=[]\n    for i in range(len(layer)):\n        guy=layer[i]\n        par=pars[i]\n        for v,w in neigh[guy]:\n            if v!=par:\n                dists[v]=max(dists[guy],w)\n                newlayer.append(v)\n                newpars.append(guy)\n    layer=newlayer\n    pars=newpars\nhigh=0\nfor guy in x:\n    high=max(high,dists[guy])\nprint((str(high)+\" \")*k)\n", "import sys\ninput = sys.stdin.readline\n\n\nn, m, k = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nuf = [-1 for _ in range(n+1)]\n\n\ndef find(p, uf):\n    if uf[p] < 0:\n        return p\n    uf[p] = find(uf[p], uf)\n    return uf[p]\n\n\ndef union(p, q, uf, specials):\n    proot = find(p, uf)\n    qroot = find(q, uf)\n    if proot == qroot:\n        return\n    elif uf[proot] > uf[qroot]:\n        uf[qroot] += uf[proot]\n        uf[proot] = qroot\n        specials[qroot] = specials[qroot] or specials[proot]\n    else:\n        uf[proot] += uf[qroot]\n        uf[qroot] = proot\n        specials[proot] = specials[qroot] or specials[proot]\n\n\nedges = []\nfor _ in range(m):\n    u, v, w = list(map(int, input().split()))\n    edges.append((w, u, v))\nedges = sorted(edges, key=lambda item: item[0])\nspecials = [0] * (n + 1)\nfor item in x:\n    specials[item] = 1\n#special_edges = []\nans = -1\nfor w, u, v in edges:\n    ufather, vfather = find(u, uf), find(v, uf)\n    if ufather != vfather:\n        if specials[ufather] == 1 and specials[vfather] == 1:\n            #special_edges.append((w, u, v))\n            ans = max(ans, w)\n        union(u, v, uf, specials)\n#special_edges = sorted(special_edges, key=lambda item:item[0])\n\nres = [ans] * k\nprint(' '.join(map(str, res)))\n", "import sys\ninput = sys.stdin.readline\n\nn, m, k = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nuf = [-1 for _ in range(n+1)]\n\ndef find(p, uf):\n    if uf[p] < 0:\n        return p\n    uf[p] = find(uf[p], uf)\n    return uf[p]\n\ndef union(p, q, uf, specials):\n    proot = find(p, uf)\n    qroot = find(q, uf)\n    if proot == qroot:\n        return\n    elif uf[proot] > uf[qroot]:\n        uf[qroot] += uf[proot]\n        uf[proot] = qroot\n        specials[qroot] = specials[qroot] or specials[proot]\n    else:\n        uf[proot] += uf[qroot]\n        uf[qroot] = proot\n        specials[proot] = specials[qroot] or specials[proot]\n\nedges = []\nfor _ in range(m):\n    u, v, w = list(map(int, input().split()))\n    edges.append((w, u, v))\nedges = sorted(edges, key=lambda item: item[0])\nspecials = [0] * (n + 1)\nfor item in x:\n    specials[item] = 1\n\nans = -1\nfor w, u, v in edges:\n    ufather, vfather = find(u, uf), find(v, uf)\n    if ufather != vfather:\n        if specials[ufather] == 1 and specials[vfather] == 1:\n            ans = max(ans, w)\n        union(u, v, uf, specials)\n\nres = [ans] * k\nprint(' '.join(map(str, res)))\n", "def put():\n    return list(map(int, input().split()))\n\ndef find(i):\n    if i == p[i]:\n        return i\n    p[i]=find(p[i])\n    return p[i]\n\ndef union(i,j):\n    if rank[i]<rank[j]:\n        i,j = j,i\n    elif rank[i]==rank[j]:\n        rank[i]+=1\n    p[j]=i\n    z[i]+=z[j]\n    return z[i]\n\nn,m,k =put()\nl = list(put())\nz,edge,p,rank = [0]*(n+1), [], list(range(n+1)), [0]*(n+1)\n\nfor i in l:\n    z[i]=1\nfor i in range(m):\n    u,v,w = put()\n    edge.append((w,u,v))\nedge.sort()\n\nfor w,u,v in edge:\n    u,v = list(map(find, (u,v)))\n    if u!=v:\n        cnt=union(u,v)\n        if cnt==k:\n            print((str(w)+' ')*k)\n            break\n    \n"]
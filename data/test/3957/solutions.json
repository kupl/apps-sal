["def bfs(source):\n    q = [0] * (n + 1);\n    fa = [-1] * n\n    l, r = [1] * 2\n    fa[source] = source\n    q[1] = source\n    while l <= r:\n        x = q[l]\n        l += 1\n        for y in e[x]:\n            if  fa[y] == -1:\n                fa[y] = x\n                r += 1\n                q[r] = y\n    i = r;\n    while i >= 1:\n        x = q[i]\n        for y in e[x]:\n            if fa[y] == x:\n                sum[x] += sum[y]\n                dp[x] += dp[y] + min(sum[y], m - sum[y])\n        i -= 1\n\nn, m =[int(x) for x in input().split()]\nm <<= 1\nt = [int(x) for x in input().split()]\ne = [list() for i in range(n)]\nsum = [0] * n\ndp = [0] * n\n#print(len(e), e)\nfor i in range(n - 1):\n    x, y = [int(a) for a in input().split()]\n    e[x - 1].append(y - 1)\n    e[y - 1].append(x - 1)\nfor x in t:\n    sum[x - 1] = 1\nbfs(0)\nprint(dp[0])", "def main():\n    n, k = list(map(int, input().split()))\n    s = [0] * n\n    for i in map(int, input().split()):\n        s[i - 1] = 1\n    e = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        x, y = (int(s) - 1 for s in input().split())\n        e[x].append(y)\n        e[y].append(x)\n    q, fa = [0], [-1] * n\n    fa[0] = 0\n    for i in range(n):\n        x = q[i]\n        for y in e[x]:\n            if fa[y] == -1:\n                fa[y] = x\n                q.append(y)\n    dp, k2 = [0] * n, k * 2\n    for x in reversed(q):\n        for y in e[x]:\n            if fa[y] == x:\n                i = s[y]\n                s[x] += i\n                dp[x] += dp[y] + (k2 - i if i > k else i)\n    print(dp[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = list(map(int, input().split()))\ns = [0] * n\nfor i in map(int, input().split()):\n    s[i - 1] = 1\ne = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    x, y = (int(s) - 1 for s in input().split())\n    e[x].append(y)\n    e[y].append(x)\nq, fa = [0], [-1] * n\nfa[0] = 0\nfor i in range(n):\n    x = q[i]\n    for y in e[x]:\n        if fa[y] == -1:\n            fa[y] = x\n            q.append(y)\ndp, k2 = [0] * n, k * 2\nfor x in reversed(q):\n    for y in e[x]:\n        if fa[y] == x:\n            i = s[y]\n            s[x] += i\n            dp[x] += dp[y] + (k2 - i if i > k else i)\nprint(dp[0])\n", "def bfs(source):\n\n    q = [0] * (n + 1);\n\n    fa = [-1] * n\n\n    l, r = [1] * 2\n\n    fa[source] = source\n\n    q[1] = source\n\n    while l <= r:\n\n        x = q[l]\n\n        l += 1\n\n        for y in e[x]:\n\n            if  fa[y] == -1:\n\n                fa[y] = x\n\n                r += 1\n\n                q[r] = y\n\n    i = r;\n\n    while i >= 1:\n\n        x = q[i]\n\n        for y in e[x]:\n\n            if fa[y] == x:\n\n                sum[x] += sum[y]\n\n                dp[x] += dp[y] + min(sum[y], m - sum[y])\n\n        i -= 1\n\n\n\nn, m =[int(x) for x in input().split()]\n\nm <<= 1\n\nt = [int(x) for x in input().split()]\n\ne = [list() for i in range(n)]\n\nsum = [0] * n\n\ndp = [0] * n\n\n#print(len(e), e)\n\nfor i in range(n - 1):\n\n    x, y = [int(a) for a in input().split()]\n\n    e[x - 1].append(y - 1)\n\n    e[y - 1].append(x - 1)\n\nfor x in t:\n\n    sum[x - 1] = 1\n\nbfs(0)\n\nprint(dp[0])\n\n\n\n# Made By Mostafa_Khaled\n", "from collections import defaultdict\ndef put(): return map(int, input().split())\n\ndef dfs():\n    s = [(1,0)]\n    ans = 0\n    vis = [0]*(n+1)\n    while s:\n        i,p = s.pop()\n        if vis[i]==0:\n            vis[i]=1\n            s.append((i,p))\n            for j in tree[i]:\n                if j!=p:\n                    s.append((j,i))\n        elif vis[i]==1:\n            vis[i]=2\n            for j in tree[i]:\n                if j != p:\n                    mark[i]+= mark[j]\n            ans += min(mark[i], 2*k - mark[i])\n    print(ans)\n        \n\n\n\n\nn,k = put()\nl = list(put())\n\nedge = defaultdict()\ntree = [[] for i in range(n+1)]\nmark = [0]*(n+1)\nfor i in l:\n    mark[i]=1\nfor _ in range(n-1):\n    x,y = put()\n    tree[x].append(y)\n    tree[y].append(x)\ndfs()", "from collections import defaultdict\nfrom sys import stdin\n\ndef put(): return map(int, stdin.readline().split())\n\ndef dfs():\n    s = [(1,0)]\n    ans = 0\n    vis = [0]*(n+1)\n    while s:\n        i,p = s.pop()\n        if vis[i]==0:\n            vis[i]=1\n            s.append((i,p))\n            for j in tree[i]:\n                if j!=p:\n                    s.append((j,i))\n        elif vis[i]==1:\n            vis[i]=2\n            for j in tree[i]:\n                if j != p:\n                    mark[i]+= mark[j]\n            ans += min(mark[i], 2*k - mark[i])\n    print(ans)\n        \n\n\n\n\nn,k = put()\nl = list(put())\n\nedge = defaultdict()\ntree = [[] for i in range(n+1)]\nmark = [0]*(n+1)\nfor i in l:\n    mark[i]=1\nfor _ in range(n-1):\n    x,y = put()\n    tree[x].append(y)\n    tree[y].append(x)\ndfs()", "def parser():\n    return [int(x) for x in input().split(\" \")]\n\ndef DFS():\n    visited[0]=True\n    stack=[]\n    intruduction_order=[]\n    stack.append(0)\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if university_in_city[u]:\n                    count_universities_subtree[u]+=1\n                stack.append(u)\n                intruduction_order.append(u)\n    for v in intruduction_order[::-1]:\n        count_universities_subtree[pi[v]]+=count_universities_subtree[v]\n\n\nn,k=parser()\nvisited=[False for x in range(n)]\npi=[0 for x in range(n)]\ncount_universities_subtree=[0 for x in range(n)]\nuniversity_in_city=[False for x in range(n)]\n\ncities_universities=parser()\nfor i in range(2*k):\n    university_in_city[cities_universities[i]-1]=True\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    edge=parser()\n    adjacents_list[edge[0]-1].append(edge[1]-1)\n    adjacents_list[edge[1]-1].append(edge[0]-1)\n\nDFS()\n\ntotal=0\n\nfor i in range(1,n):\n    total+=min(count_universities_subtree[i],2*k-count_universities_subtree[i])\n\nprint(total)", "#parsea una l\u00ednea\ndef parser():\n    return [int(x) for x in input().split()]\n\n#M\u00e9todo usado para contar las universidades en cada sub\u00e1rbol\ndef DFS():\n    visited[0]=True\n    stack=[]\n    introduction_order=[]\n    stack.append(0)\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if university_in_city[u]:\n                    count_universities_subtree[u]+=1\n                stack.append(u)\n                introduction_order.append(u)\n    \n    #Recorriendo para saber la cantidad de universidades que hay en el subarbol de cada vertice\n    for v in introduction_order[::-1]:\n        count_universities_subtree[pi[v]]+=count_universities_subtree[v]\n\n#Recibiendo los valores de n y k\nn,k=parser()\n#visitados\nvisited=[False for x in range(n)]\n#padres\npi=[0 for x in range(n)]\n#universidades en el subarbol\ncount_universities_subtree=[0 for x in range(n)]\n#universidad en la ciudad\nuniversity_in_city=[False for x in range(n)]\n\n#Recibiendo las ciudades que tienen universidades\ncities_universities=parser()\nfor i in cities_universities:\n    university_in_city[i-1]=True\n\n#Armando el \u00e1rbol que representa a Treeland\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    #Leyendo una arista\n    edge=parser()\n    adjacents_list[edge[0]-1].append(edge[1]-1)\n    adjacents_list[edge[1]-1].append(edge[0]-1)\n\nDFS()\n\n#Calculando el total\ntotal=0\nfor i in range(1,n):\n    total+=min(count_universities_subtree[i],2*k-count_universities_subtree[i])\n\n#Imprimiendo el resultado\nprint(total)"]
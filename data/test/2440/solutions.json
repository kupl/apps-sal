["import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nfrom collections import deque\n\nclass LCA():\n    def __init__(self, G, root):\n        self.n = len(G)\n        self.dep=[0]*self.n\n        self.par=[[-1]*self.n for i in range(18)]\n\n        def bfs(root):\n            que = deque()\n            que.append((-1,root,0))\n            while que:\n                p,v,d = que.pop()\n                self.dep[v]=d\n                self.par[0][v]=p\n                for to in G[v]:\n                    if to != p:\n                        que.append((v,to,d+1))\n\n        bfs(root)\n\n        for i in range(17):\n            for j in range(self.n):\n                self.par[i+1][j]=self.par[i][self.par[i][j]]\n\n    def lca(self,a,b):\n        if self.dep[a]>self.dep[b]:\n            a,b=b,a\n        for i in range(18):\n            if (self.dep[b]-self.dep[a]) & 1<<i:\n                b=self.par[i][b]\n        if a==b:\n            return a\n        for i in range(18)[::-1]:\n            if self.par[i][a]!=self.par[i][b]:\n                a=self.par[i][a]\n                b=self.par[i][b]\n        return self.par[0][a]\n\n    def dist(self, a,b):\n        lca = self.lca(a,b)\n        return self.dep[a]+self.dep[b]-2*self.dep[lca]\n\nn = int(input())\nG = [[] for i in range(n)]\n\nfor i in range(n-1):\n    a,b = list(map(int, input().split()))\n    a,b = a-1,b-1\n    G[a].append(b)\n    G[b].append(a)\n\nL = LCA(G, 0)\n\nq = int(input())\nfor i in range(q):\n    x,y,a,b,k = list(map(int, input().split()))\n    x,y,a,b = x-1,y-1,a-1,b-1\n\n    ab = L.dist(a,b)\n    base = [ab]\n\n    ax = L.dist(a,x)\n    ay = L.dist(a,y)\n    bx = L.dist(b,x)\n    by = L.dist(b,y)\n\n    base.append(ax+1+by)\n    base.append(ay+1+bx)\n\n    flag = any(ki<=k and (k-ki)%2==0 for ki in base)\n\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\nclass LowestCommonAncestor():\n    def __init__(self, tree, root):\n        self.n = len(tree)\n        self.depth = [0] * self.n\n        self.log_size = (self.n).bit_length()\n        self.parent = [[-1] * self.n for i in range(self.log_size)]\n\n        q = deque([(root, -1, 0)]) \n        while q:\n            v, par, dist = q.pop()\n            self.parent[0][v] = par\n            self.depth[v] = dist\n            for child_v in tree[v]:\n                if child_v != par:\n                    self.depth[child_v] = dist + 1\n                    q.append((child_v, v, dist + 1))\n\n        for k in range(1, self.log_size):\n            for v in range(self.n):\n                self.parent[k][v] = self.parent[k-1][self.parent[k-1][v]]\n            \n    def lca(self, u, v):\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        for k in range(self.log_size):\n            if (self.depth[v] - self.depth[u] >> k) & 1:\n                v = self.parent[k][v]\n        if u == v:\n            return u\n          \n        for k in reversed(range(self.log_size)):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\n\nn = int(input())\ninfo = [list(map(int, input().split())) for  i in range(n - 1)]\n\ntree = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n    \nlca = LowestCommonAncestor(tree, 0)\n\nq = int(input())\nquery = [list(map(int, input().split())) for i in range(q)]\n    \nfor i in range(q):\n    x, y, a, b, k = query[i]\n    lca_ab = lca.lca(a - 1, b - 1)\n    ab = lca.depth[a - 1] + lca.depth[b - 1] - 2 * lca.depth[lca_ab]\n    lca_xy = lca.lca(x - 1, y - 1)\n    xy = lca.depth[x - 1] + lca.depth[y - 1] - 2 * lca.depth[lca_xy]\n\n    lca_ax = lca.lca(a - 1, x - 1)\n    lca_ay = lca.lca(a - 1, y - 1)\n    lca_bx = lca.lca(b - 1, x - 1)\n    lca_by = lca.lca(b - 1, y - 1)\n    \n    ax = lca.depth[a - 1] + lca.depth[x - 1] - 2 * lca.depth[lca_ax]\n    ay = lca.depth[a - 1] + lca.depth[y - 1] - 2 * lca.depth[lca_ay]\n    bx = lca.depth[b - 1] + lca.depth[x - 1] - 2 * lca.depth[lca_bx]\n    by = lca.depth[b - 1] + lca.depth[y - 1] - 2 * lca.depth[lca_by]\n    if ab <= k and k % 2 == ab % 2:\n        print(\"YES\")\n    elif ax+1+by <= k and k % 2 == (ax+1+by) % 2:\n        print(\"YES\")\n    elif ay+1+bx <= k and k % 2 == (ay+1+bx) % 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")"]
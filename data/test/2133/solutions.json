["from collections import defaultdict, deque\n\nclass DSU:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for i in range(n)]\n\n    def find_parent(self, v):\n        if self.parents[v] == v:\n            return v\n        self.parents[v] = self.find_parent(self.parents[v])\n        return self.parents[v]\n\n    def join_sets(self, u, v):\n        u = self.find_parent(u)\n        v = self.find_parent(v)\n        if u != v:\n            if self.ranks[u] < self.ranks[v]:\n                u, v = v, u\n            self.parents[v] = u\n            if self.ranks[v] == self.ranks[u]:\n                self.ranks[u] += 1\n\nn = int(input())\ndsu = DSU(n)\ncolors = list(map(int, input().split(' ')))\nvertices = []\nfor i in range(n-1):\n    u, v = [int(x)-1 for x in input().split(' ')]\n    if colors[u] == colors[v]:\n        dsu.join_sets(u, v)\n    vertices.append((u,v))\ngraph = defaultdict(list)\nfor u, v in vertices:\n    if colors[u] != colors[v]:\n        u = dsu.find_parent(u)\n        v = dsu.find_parent(v)\n        graph[u].append(v)\n        graph[v].append(u)\n\n\ndef bfs(u):\n    d = dict()\n    d[u] = 0\n    q = deque()\n    q.append(u)\n    while q:\n        u = q.pop()\n        for v in graph[u]:\n            if v not in d:\n                d[v] = d[u] + 1\n                q.append(v)\n    return d\nif graph:\n    v = list(graph.keys())[0]\n    d = bfs(v)\n    u = v\n    for i in d:\n        if d[i] > d[u]:\n            u = i\n    d = bfs(u)\n    w = u\n    for i in d:\n        if d[i] > d[w]:\n            w = i\n    print((d[w]+1)//2)\nelse:\n    print(0)\n", "def main():\n    n = int(input())\n    colors = [c == '1' for c in input()[::2]]\n    dsu = list(range(n))\n    edges = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            a, b = dsu[u], dsu[v]\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = u\n                while v != a:\n                    u = dsu[v]\n                    dsu[v] = a\n                    v = u\n            else:\n                dsu[a] = v\n                while u != b:\n                    v = dsu[u]\n                    dsu[u] = b\n                    u = v\n        else:\n            edges[u].append(v)\n            edges[v].append(u)\n    for u, v in enumerate(dsu):\n        dsu[u] = dsu[v]\n    if not any(dsu):\n        print(0)\n        return\n    d = {u: set() for u, v in enumerate(dsu) if u == v}\n    for u, e in enumerate(edges):\n        u = dsu[u]\n        for v in e:\n            v = dsu[v]\n            d[u].add(v)\n            d[v].add(v)\n\n    def bfs(x):\n        nxt, visited, t = [x], set(), 0\n        while nxt:\n            t += 1\n            cur, nxt = nxt, []\n            for u in cur:\n                visited.add(u)\n                for v in d[u]:\n                    if v not in visited:\n                        nxt.append(v)\n        return t, cur[0]\n\n    print(bfs(bfs(0)[1])[0] // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    colors = input()[::2]\n    dsu = list(range(n))\n    edges = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            a, b = dsu[u], dsu[v]\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges[u].append(v)\n    for u, v in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for u, v in enumerate(dsu) if u == v}\n    for u, e in enumerate(edges):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        nxt, visited, t = [x], set(), 0\n        while nxt:\n            t += 1\n            cur, nxt = nxt, []\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return t, cur[0]\n\n    print(bfs(bfs(0)[1])[0] // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    colors = input()[::2]\n    edges = [[[] for _ in range(n)] for _ in (0, 1)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        e = edges[colors[u] != colors[v]]\n        e[u].append(v)\n        e[v].append(u)\n    dsu, e = [-1] * n, edges[0]\n    for u, v in enumerate(dsu):\n        if v == -1:\n            nxt, c = [u], colors[u]\n            while nxt:\n                cur, nxt = nxt, []\n                for v in cur:\n                    dsu[v] = u\n                    for v in e[v]:\n                        if dsu[v] == -1:\n                            nxt.append(v)\n\n    d = {u: [] for u, v in enumerate(dsu) if u == v}\n    for u, e in enumerate(edges[1]):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n\n    def bfs(x):\n        nxt, visited, t = [x], set(), 0\n        while nxt:\n            t += 1\n            cur, nxt = nxt, []\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return t, cur[0]\n\n    print(bfs(bfs(0)[1])[0] // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from collections import defaultdict\n    n, colors = int(input()), input()[::2]\n    dsu, edges, d = list(range(n)), [], defaultdict(list)\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            a, b = dsu[u], dsu[v]\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges.append(u)\n            edges.append(v)\n    for u, v in enumerate(dsu):\n        dsu[u] = dsu[v]\n    while edges:\n        u, v = dsu[edges.pop()], dsu[edges.pop()]\n        d[u].append(v)\n        d[v].append(u)\n\n    def bfs(x):\n        nxt, avail, t = [x], [True] * n, 0\n        while nxt:\n            t += 1\n            cur, nxt = nxt, []\n            for y in cur:\n                avail[y] = False\n                for y in d[y]:\n                    if avail[y]:\n                        nxt.append(y)\n        return t if x else cur[0]\n\n    print(bfs(bfs(0)) // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "f = lambda: map(int, input().split())\ns, n = 0, int(input())\n\ng = [set() for i in range(n + 1)]\nc = [0] + list(f())\nd = [0] * (n + 1)\n\nfor j in range(n - 1):\n    a, b = f()\n    g[a].add(b)\n    g[b].add(a)\n\np = [q for q, t in enumerate(g) if len(t) == 1]\nwhile p:\n    a = p.pop()\n    if not g[a]: break\n    b = g[a].pop()\n    g[b].remove(a)\n    if c[a] - c[b]: d[a] += 1\n    s = max(s, d[b] + d[a])\n    d[b] = max(d[b], d[a])\n    if len(g[b]) == 1: p.append(b)\n\nprint(s + 1 >> 1)", "from collections import defaultdict, deque\n \nclass DSU:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for i in range(n)]\n \n    def find_parent(self, v):\n        if self.parents[v] == v:\n            return v\n        self.parents[v] = self.find_parent(self.parents[v])\n        return self.parents[v]\n \n    def join_sets(self, u, v):\n        u = self.find_parent(u)\n        v = self.find_parent(v)\n        if u != v:\n            if self.ranks[u] < self.ranks[v]:\n                u, v = v, u\n            self.parents[v] = u\n            if self.ranks[v] == self.ranks[u]:\n                self.ranks[u] += 1\n \nn = int(input())\ndsu = DSU(n)\ncolors = list(map(int, input().split(' ')))\nvertices = []\nfor i in range(n-1):\n    u, v = map(lambda x: int(x)-1, input().split(' '))\n    if colors[u] == colors[v]:\n        dsu.join_sets(u, v)\n    vertices.append((u,v))\ngraph = defaultdict(list)\nfor u, v in vertices:\n    if colors[u] != colors[v]:\n        u = dsu.find_parent(u)\n        v = dsu.find_parent(v)\n        graph[u].append(v)\n        graph[v].append(u)\n \n \ndef bfs(u):\n    d = dict()\n    d[u] = 0\n    q = deque()\n    q.append(u)\n    while q:\n        u = q.pop()\n        for v in graph[u]:\n            if v not in d:\n                d[v] = d[u] + 1\n                q.append(v)\n    return d\nif graph:\n    v = list(graph.keys())[0]\n    d = bfs(v)\n    u = v\n    for i in d:\n        if d[i] > d[u]:\n            u = i\n    d = bfs(u)\n    w = u\n    for i in d:\n        if d[i] > d[w]:\n            w = i\n    print((d[w]+1)//2)\nelse:\n    print(0)", "f = lambda: map(int, input().split())\ns, n = 0, int(input())\n\ng = [set() for i in range(n + 1)]\nc = [0] + list(f())\nd = [0] * (n + 1)\n\nfor j in range(n - 1):\n    a, b = f()\n    g[a].add(b)\n    g[b].add(a)\n\np = [q for q, t in enumerate(g) if len(t) == 1]\nwhile p:\n    a = p.pop()\n    if not g[a]: break\n    b = g[a].pop()\n    g[b].remove(a)\n    if c[a] - c[b]: d[a] += 1\n    s = max(s, d[b] + d[a])\n    d[b] = max(d[b], d[a])\n    if len(g[b]) == 1: p.append(b)\n\nprint(s + 1 >> 1)"]
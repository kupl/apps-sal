["def main():\n    X, Y, A, B, C = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    p.sort(reverse=True); q.sort(reverse=True); r.sort()\n\n    p = p[:X]\n    q = q[:Y]\n    s = p + q\n    s.sort()\n\n    rtmp = r.pop()\n    for i in range(len(s)):\n        if s[i] < rtmp:\n            s[i] = rtmp\n            if len(r) == 0:\n                break\n            rtmp = r.pop()\n        else:\n            break\n    ans = sum(s)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x, y, a, b, c = map(int, input().split())\np = sorted(list(map(int, input().split())), reverse=True)\nq = sorted(list(map(int, input().split())), reverse=True)\nr = sorted(list(map(int, input().split())), reverse=True)\nprint(sum(sorted(p[:x]+q[:y]+r, reverse=True)[:(x+y)]))", "X, Y, A, B, C = [int(n) for n in input().split(\" \")]\n\np = [int(n) for n in input().split(\" \")]\nq = [int(n) for n in input().split(\" \")]\nr = [int(n) for n in input().split(\" \")]\n\nR = sorted(p)\nG = sorted(q)\nT = sorted(r)\n\nW = 0\nGetR = 0\nGetG = 0\nGetS = 0\n\nwhile GetS < X + Y:\n    a = -1\n    b = -1\n    c = -1\n    if len(R) > 0 and GetR < X:\n        a = R[-1]\n    if len(G) > 0 and GetG < Y:\n        b = G[-1]\n    if len(T) > 0:\n        c = T[-1]\n\n    t = max([a, b, c])\n    index = [a, b, c].index(t)\n    W += t\n    #print(R, G, T)\n    GetS += 1\n    if index == 0:\n        del(R[-1])\n        GetR += 1\n    if index == 1:\n        del(G[-1])\n        GetG += 1\n    if index == 2:\n        del(T[-1])\n\nprint(W)", "x,y,a,b,c=map(int,input().split())\np=sorted(list(map(int,input().split())))[::-1][:x]\nq=sorted(list(map(int,input().split())))[::-1][:y]\nr=sorted(list(map(int,input().split())))[::-1]\nr=r[:min(len(r),x+y)]\nl=sum([p,q,r],[])\nprint(sum(sorted(l)[::-1][:x+y]))", "x_aka,y_mid,a,b,c = list(map(int,input().split()))\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nr = list(map(int,input().split()))\np_aka = sorted(p,reverse=True)\nq_mid = sorted(q,reverse=True)\nr_mu = sorted(r,reverse=True)\n#print(p_aka[:x_aka],q_mid[:y_mid],r_mu)\ntmp = p_aka[:x_aka] + q_mid[:y_mid] + r_mu\nsort_tmp = sorted(tmp,reverse=True)\n#print(sort_tmp[:(x_aka+y_mid)])\nprint((sum(sort_tmp[:(x_aka+y_mid)])))\n", "def LI():\n    return list(map(int, input().split()))\n\n\nX, Y, A, B, C = LI()\nred = LI()\ngreen = LI()\nmu = LI()\nred.sort(reverse=True)\ngreen.sort(reverse=True)\nans = red[:X]+green[:Y]+mu\nans.sort(reverse=True)\ntotal = 0\nfor i in range(X+Y):\n    total += ans[i]\nprint(total)\n", "import heapq\nX,Y,A,B,C = map(int,input().split())\nPlist = list(map(int,input().split()))\nQlist=  list(map(int,input().split()))\nRlist  = list(map(int,input().split()))\nPlist.sort(reverse = True)\nQlist.sort(reverse = True)\nRlist.sort(reverse = True)\ni,j,k = 0,0,0\npmax = Plist[i]\nqmax = Qlist[i]\nrmax = Rlist[i]\nAns = 0\nfor _ in range(2*10**5):\n    Ans += max(pmax,qmax,rmax)\n    if pmax == max(pmax,qmax,rmax):\n        i += 1\n        if i != X:\n            pmax = Plist[i]\n        else:\n            pmax = -1\n    elif qmax == max(pmax,qmax,rmax):\n        j += 1\n        if j != Y:\n            qmax = Qlist[j]\n        else:\n            qmax = -1\n    else:\n        k += 1\n        try:\n            rmax = Rlist[k]\n        except:\n            rmax = -1\n    if i+j+k == X+Y:\n        break\nprint(Ans)", "X, Y, A, B, C = map(int, input().split())\np_list = list(map(int, input().split()))\nq_list = list(map(int, input().split()))\nr_list = list(map(int, input().split()))\n\np_list_max = sorted(p_list, reverse=True)\nq_list_max = sorted(q_list, reverse=True)\nr_list_max = sorted(r_list, reverse=True)\n\np_list_X = p_list_max[:X]\nq_list_Y = q_list_max[:Y]\n\nans_list = []\nans_list.extend(p_list_X)\nans_list.extend(q_list_Y)\nans_list.extend(r_list_max)\nans_list_max = sorted(ans_list, reverse=True)\n\nans = 0\n#print(p_list_X, q_list_Y, ans_list_max)\nfor i in range(X+Y):\n    ans += ans_list_max[i]\nprint(ans)", "X,Y,A,B,C = list(map(int,input().split()))\nP = sorted(list(map(int,input().split())),reverse=True)[:X]\nQ = sorted(list(map(int,input().split())),reverse=True)[:Y]\nR = list(map(int,input().split()))\n\nall = P + Q + R\n\nall.sort(reverse=True)\n\nprint((sum(all[:X+Y])))\n", "x,y,a,b,c=map(int,input().split())\n\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\np=sorted(p,reverse=True)\nq=sorted(q,reverse=True)\nr=sorted(r)\n\nbox=[]\n\nans=0\n\n\nfor i in range(x):\n    box.append(p[i])\n\nfor j in range(y):\n    box.append(q[j])\n\nbox = box + r\n\nbox=sorted(box,reverse=True)\n\nfor k in range(x+y):\n    ans+=box[k]\n\nprint(ans)", "x, y, a, b, c = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\n\ns = p[:x] + q[:y]\ns.sort()\nans = sum(s)\nfor si, ri in zip(s, r):\n    if si < ri:\n        ans += ri - si\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    X, Y, A, B, C = list(map(int, input().split()))\n    P = sorted(list(map(int, input().split())), reverse=True)[:X]\n    Q = sorted(list(map(int, input().split())), reverse=True)[:Y]\n    R = sorted(list(map(int, input().split())), reverse=True)\n    L = sorted(P + Q + R, reverse=True)\n    res = sum(L[:X + Y])\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\n\nx, y, a, b, c = map(int, input().split())\n\np = np.array(list(map(int, input().split())))\nq = np.array(list(map(int, input().split())))\nr = np.array(list(map(int, input().split())))\n\np.sort()\nq.sort()\nr.sort()\n\nans = p[-x:].sum()+q[-y:].sum()\n\np_cnt = 0\nq_cnt = 0\nr_cnt = 0\nwhile not(-x+p_cnt == 0 and -y+q_cnt == 0) and -1-r_cnt >= -c:\n  if -x+p_cnt == 0:\n    if r[-1-r_cnt] > q[-y+q_cnt]:\n      ans += r[-1-r_cnt] - q[-y+q_cnt]\n      q_cnt += 1\n      r_cnt += 1\n    else:\n      break\n  \n  elif -y+q_cnt == 0:\n    if r[-1-r_cnt] > p[-x+p_cnt]:\n      ans += r[-1-r_cnt] - p[-x+p_cnt]\n      p_cnt += 1\n      r_cnt += 1\n    else:\n      break\n\n  elif p[-x+p_cnt] <= q[-y+q_cnt] and r[-1-r_cnt] > p[-x+p_cnt]:\n    ans += r[-1-r_cnt] - p[-x+p_cnt]\n    p_cnt += 1\n    r_cnt += 1\n\n  elif p[-x+p_cnt] > q[-y+q_cnt] and r[-1-r_cnt] > q[-y+q_cnt]:\n    ans += r[-1-r_cnt] - q[-y+q_cnt]\n    q_cnt += 1\n    r_cnt += 1\n\n  else:\n    break\n\nprint(ans)", "x,y,a,b,c = map(int,input().split())\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nr = list(map(int,input().split()))\np.sort(reverse = True)\nq.sort(reverse = True)\nr.sort(reverse = True)\np = p[:x]\nq = q[:y]\nl = p + q + r\nl.sort(reverse = True)\nprint(sum(l[:x+y]))", "def main():\n    import heapq\n    x,y,a,b,c = list(map(int,input().split()))\n    p = sorted(list(map(int,input().split())),reverse=True)[0:x]\n    q = sorted(list(map(int,input().split())),reverse=True)[0:y]\n    r = sorted(list(map(int,input().split())),reverse=True)\n    P,Q = [],[]\n    for i in range(x):\n        heapq.heappush(P,p[i])\n    for i in range(y):\n        heapq.heappush(Q,q[i])\n    for i in range(c):\n        p,q = heapq.heappop(P), heapq.heappop(Q)\n        if p>q:\n            heapq.heappush(P,p)\n            if r[i]>q:\n                heapq.heappush(Q,r[i])\n            else:\n                heapq.heappush(Q,q)\n        else:\n            heapq.heappush(Q,q)\n            if r[i]>p:\n                heapq.heappush(P,r[i])\n            else:\n                heapq.heappush(P,p)\n    print((sum(P)+sum(Q)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "'''\nCreated on 2020/09/10\n\n@author: harurun\n'''\ndef main():\n  import heapq\n  import sys\n  pin=sys.stdin.readline\n  pout=sys.stdout.write\n  perr=sys.stderr.write\n  \n#   dl=[]\n\n  X,Y,A,B,C=list(map(int,pin().split()))\n  p=list(map(int,pin().split()))\n  q=list(map(int,pin().split()))\n  r=list(map(int,pin().split()))\n\n  p.sort(reverse=True)\n  q.sort(reverse=True)\n  r.sort(reverse=True)\n\n  p=p[:X]\n  q=q[:Y]\n  \n  Q=[]\n  for i in p:\n    Q.append([i,0])\n  for j in q:\n    Q.append([j,1])\n\n  heapq.heapify(Q)\n  cntp=0\n  cntq=0\n  ans=0\n  for k in r:\n    t=heapq.heappop(Q)\n    if t[1]==0 and t[0]<k and cntp<=X:\n      ans+=k \n      cntp+=1\n#       dl.append(k)\n    elif t[1]==1 and t[0]<k and cntq<=Y:\n      ans+=k \n      cntq+=1\n#       dl.append(k)\n    else:\n      ans+=t[0]\n      break\n  while True:\n    try:\n      s=heapq.heappop(Q)\n      ans+=s[0] \n#       dl.append(s[0])\n    except:\n      break\n  print(ans)\n#   print(dl)\n#   print(p)\n#   print(q)\n  \n  return \n\nmain()\n", "x,y,a,b,c=list(map(int,input().split()))\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\np.sort(reverse=True)\nq.sort(reverse=True)\nans=[]\nfor i in range(x):\n  r.append(p[i])\nfor i in range(y):\n  r.append(q[i])\nr.sort(reverse=True)\nprint((sum(r[0:x+y])))\n  \n\n", "from collections import deque\n\nX,Y,A,B,C = map(int, input().split())\nA=[int(a) for a in input().split()]\nB=[int(b) for b in input().split()]\nC=[int(c) for c in input().split()]\n\nA=sorted(A, reverse=True)[:X]\nB=sorted(B, reverse=True)[:Y]\nAB=deque(sorted(A+B))\n\nfor c in sorted(C, reverse=True):\n  if c >= AB[0]:\n    AB.popleft()\n    AB.append(c)\n  else:\n    break\n\nprint(sum(AB))", "import sys, bisect, math, itertools, string, queue, copy\nimport numpy as np\nimport scipy\nfrom collections import Counter,defaultdict,deque\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nfrom fractions import gcd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return map(int,input().split())\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nx,y,a,b,c = inpm()\np = list(reversed(sorted(inpl())))\nq = list(reversed(sorted(inpl())))\nr = list(reversed(sorted(inpl())))\npp = x-1\nqq = y-1\nrr = 0\n\ntmp = []\ntmp.extend(p[:pp+1])\ntmp.extend(q[:qq+1])\ntmp.extend(r)\n\ntmp = list(reversed(sorted(tmp)))\nans = sum(tmp[:x+y])\nprint(ans)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\n#from operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nimport sys\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nX, Y, A, B, C = na()\np = na()\nq = na()\nr = na()\np.append(inf)\nq.append(inf)\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\ns1 = sum(p[1:X+1])\ns2 = sum(q[1:Y+1])\np_idx = X\nq_idx = Y\nans = s1 + s2\nfor i in range(C):\n    now_r = r[i]\n    now_p = p[p_idx]\n    now_q = q[q_idx]\n    #print(now_r, now_p, now_q)\n    if now_r <= now_p and now_r <= now_q:\n        break\n    elif now_r > now_p and now_r > now_q:\n        if now_p > now_q:\n            ans = ans + now_r - now_q\n            q_idx -= 1\n        else:\n            ans = ans + now_r - now_p\n            p_idx -= 1\n    elif now_r > now_p:\n        ans = ans + now_r - now_p\n        p_idx -= 1\n    elif now_r > now_q:\n        ans = ans + now_r - now_q\n        q_idx -= 1\nprint(ans)", "X,Y,a,b,c = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\nA.sort()\nB.sort()\nC.sort()\n\nans = 0\nif X < a:\n    A = A[a-X:]\nif Y < b:\n    B = B[b-Y:]\nans = 0\nfor i in range(X+Y):\n    if len(A) == 0:\n        A.append(0)\n    if len(B) == 0:\n        B.append(0)\n    if len(C) == 0:\n        C.append(0)\n    if max(A[-1],B[-1],C[-1]) == A[-1]:\n        ans += A[-1]\n        A.pop()\n    elif max(A[-1],B[-1],C[-1]) == B[-1]:\n        ans += B[-1]\n        B.pop()\n    else:\n        ans += C[-1]\n        C.pop()\nprint(ans)", "x, y, a, b, c = list(map(int, input().split()))\nplst = list(map(int, input().split()))\nqlst = list(map(int, input().split()))\nrlst = list(map(int, input().split()))\nplst.sort()\nqlst.sort()\nrlst.sort(reverse = True)\ninf = 10 ** 20\nplst = plst[-x:] + [inf]\nqlst = qlst[-y:] + [inf]\nr_pos = 0\np_pos = 0\nq_pos = 0\nwhile 1:\n    if rlst[r_pos] <= plst[p_pos] and rlst[r_pos] <= qlst[q_pos]:\n        break\n    elif plst[p_pos] < qlst[q_pos]:\n        plst[p_pos] = rlst[r_pos]\n        p_pos += 1\n        r_pos += 1\n    else:\n        qlst[q_pos] = rlst[r_pos]\n        q_pos += 1\n        r_pos += 1\n    if r_pos == c:\n        break\nprint((sum(plst) + sum(qlst) - inf * 2))\n", "X, Y, A, B, C = list(map(int, input().split()))\np = sorted(list(map(int, input().split())), reverse=True)\nq = sorted(list(map(int, input().split())), reverse=True)\nr = sorted(list(map(int, input().split())), reverse=True)\n\nred = p[:X]\ngreen = q[:Y]\n\nred_no_eat = 0\ngreen_no_eat = 0\nfor no in r:\n    red_worst = red[-red_no_eat - 1] if red_no_eat < X else 10 ** 10\n    green_worst = green[-green_no_eat - 1] if green_no_eat < Y else 10 ** 10\n    if no > red_worst or no > green_worst:\n        if red_worst < green_worst:\n            red_no_eat += 1\n        else:\n            green_no_eat += 1\nprint((sum(p[:X-red_no_eat]) + sum(q[:Y-green_no_eat]) + sum(r[:red_no_eat+green_no_eat])))\n", "x, y, a, b, c = map(int, input().split())\np = sorted(map(int, input().split()))\nq = sorted(map(int, input().split()))\nr = sorted(map(int, input().split()))\nans = p[-x:] + q[-y:] + r\nans.sort()\nn = len(ans)\ncnt = 0\nfor i in range(x+y):\n    cnt += ans[n-1-i]\nprint(cnt)", "x,y,a,b,c=list(map(int,input().split()))\np=[0]+sorted(list(map(int,input().split())))[a-x:]\nq=[0]+sorted(list(map(int,input().split())))[b-y:]\nr=[0]+sorted(list(map(int,input().split())))\npi=-1\nqi=-1\nri=-1\ngs=0\nrs=0\nws=0\ns=0              \nwhile gs+rs+ws!=x+y:\n    if r[ri]>=q[qi]>=p[pi]:\n        s += r[ri]\n        ws+=1\n        ri-=1\n\n    elif r[ri]>=p[pi]>=q[qi]:\n        s += r[ri]\n        ws += 1\n        ri -= 1\n\n    elif q[qi]>=r[ri]>=p[pi]:\n        s += q[qi]\n        gs += 1\n        qi -= 1\n\n    elif q[qi]>=p[pi]>=r[ri]:\n        s += q[qi]\n        gs += 1\n        qi -= 1\n\n    elif p[pi]>=r[ri]>=q[qi]:\n        s += p[pi]\n        rs += 1\n        pi -= 1\n\n    elif p[pi]>=q[qi]>=r[ri]:\n        s += p[pi]\n        rs += 1\n        pi -= 1\n\nprint(s)\n", "X, Y, A, B, C = list(map(int, input().split()))\nP = list([[int(s), 1] for s in input().split()])\nQ = list([[int(s), 2] for s in input().split()])\nR = list([[int(s), 0] for s in input().split()])\nL = P+Q+R\nL.sort(reverse=True, key=lambda x:x[0])\nT = X + Y\nnr, ng, total = 0, 0, 0\nans = 0\nfor i in range(A+B+C):\n  a, l = L[i]\n  if l==1 and nr<X:\n    nr += 1\n    ans += a\n    total += 1\n  if l==2 and ng<Y:\n    ng += 1\n    ans += a\n    total += 1\n  if l==0:\n    ans += a\n    total += 1\n  if total == T:\n    break\nprint(ans)\n    \n", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    X, Y, A, B, C = MI()\n    # R = LI()\n    # G = LI()\n    # T = LI()\n    L = []\n    for r in LI():\n        L.append((r, 'R'))\n    for g in LI():\n        L.append((g, 'G'))\n    for t in LI():\n        L.append((t, 'T'))\n    L = sorted(L, reverse=True)\n    # print(L)\n\n    ans = 0\n    left = X + Y\n    for n, c in L:\n        if c == 'R':\n            if X > 0:\n                ans += n\n                X -= 1\n            else:\n                continue\n        elif c == 'G':\n            if Y > 0:\n                ans += n\n                Y -= 1\n            else:\n                continue\n        else:\n            ans += n\n\n        left -= 1\n        if left == 0:\n            print(ans)\n            return\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "x,y,a,b,c = map(int, input().split())\nl = [list(map(int, input().split())) for i in range(3)]\nk = sorted(l[0],reverse=True)[:x]\nfor i in sorted(l[1],reverse=True)[:y]:\n  k.append(i)\nfor i in l[2]:\n  k.append(i)\nm = sorted(k,reverse=True)[:x+y]\nprint(sum(m))", "x, y, a, b, c = map(int,input().split())\ndatp = sorted(list(map(int, input().split())), reverse=True)\ndatq = sorted(list(map(int, input().split())), reverse=True)\ndatr = list(map(int, input().split()))\ndat = sorted(datp[:x] + datq[:y] + datr, reverse=True)\nprint(sum(dat[:x+y]))", "X,Y,A,B,C=map(int, input().split())\np=list(map(int, input().split()))\nq=list(map(int, input().split()))\nr=list(map(int, input().split()))\n\nx=X-1\ny=Y-1\n\np=sorted(p,reverse=True)\nq=sorted(q,reverse=True)\nr=sorted(r,reverse=True)\n\n#print(p[:X],q[:Y])\n\nif p[x]>=q[y]:\n  a=q[y]\n  f=1\nelse:\n  a=p[x]\n  f=2\nwhile len(r)>=1 and a<r[0]:\n#  print(a,r[0])\n  if f==1 :\n#    print('f=1')\n    q[y]=r[0]\n    y-=1\n    r.pop(0)\n  elif f==2 :\n#    print('f=2')\n    p[x]=r[0]\n    x-=1\n    r.pop(0)\n  else:\n#    print('break1')\n    break\n    \n#  print(x,y,p[x],q[y])\n    \n  if (y==-1 and x>=0) or (x>=0 and p[x]<q[y]):\n#    print('a=p[x]')\n    a=p[x]\n    f=2\n  elif (x==-1 and y>=0) or (y>=0 and p[x]>=q[y]):\n#    print('a=q[y]')\n    a=q[y]\n    f=1\n  else:\n#    print('break2')\n    break\n\nans=0\n#print(p[:X],q[:Y])\nfor i in p[:X]:\n  ans+=i\nfor i in q[:Y]:\n  ans+=i\n\nprint(ans)", "x,y,a,b,c,=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\np=p[:x]\nq=q[:y]\nans=p+q+r\nans.sort(reverse=True)\nprint(sum(ans[:x+y]))", "x, y, a, b, c = map(int, input().split())\np_l = sorted(list(map(int, input().split())), reverse=True)[:x]\nq_l = sorted(list(map(int, input().split())), reverse=True)[:y]\nr_l = list(map(int, input().split()))\np_l = sorted(p_l + q_l + r_l, reverse=True)\n\nprint(sum(p_l[:x+y]))", "import math\nimport sys\nimport collections\nimport bisect\nreadline = sys.stdin.readline\n\n\ndef main():\n    x, y, a, b, c = list(map(int, input().split()))\n    p = sorted(list(map(int, input().split())), reverse=True)[0:x]\n    q = sorted(list(map(int, input().split())), reverse=True)[0:y]\n    r = sorted(list(map(int, input().split())), reverse=True)\n    pq = sorted((p + q))\n    for i in range(min(c, (x + y))):\n        if pq[i] > r[i]:\n            break\n        pq[i] = r[i]\n    print((sum(pq)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x, y, a, b, c = list(map(int, input().split()))\np = [0]+list(map(int, input().split()))\nq = [0]+list(map(int, input().split()))\nr = [0]+list(map(int, input().split()))\np.sort()\nq.sort()\nr.sort()\nans = 0\nnum = x+y\nfor _ in range(num):\n    if x > 0 and y > 0:\n      i, j, k = p[-1], q[-1], r[-1]\n      if i >= j and i >= k:\n          ans += i\n          p.pop()\n          x -= 1\n      elif j >= i and j >= k:\n          ans += j\n          q.pop()\n          y -= 1\n      else:\n          ans += k\n          r.pop()\n    elif x > 0:\n        i, j = p[-1], r[-1]\n        x -= 1\n        if i >= j:\n            ans += i\n            p.pop()\n        else:\n            ans += j\n            r.pop()\n    elif y > 0:\n        y -= 1\n        i, j = q[-1], r[-1]\n        if i >= j:\n            ans += i\n            q.pop()\n        else:\n            ans += j\n            r.pop()\n    \nprint(ans)\n", "import heapq\nx,y,a,b,c = map(int,input().split())\nP = list(map(int,input().split()))\nQ = list(map(int,input().split()))\nR = list(map(int,input().split()))\n\nP.sort(reverse=True)\nQ.sort(reverse=True)\nR.sort(reverse=True)\n\nx_tmp = P[:x]\ny_tmp = Q[:y]\n\ntmp_li = x_tmp+y_tmp\nheapq.heapify(tmp_li)\n\nfor i in range(c):\n    if R[i]>tmp_li[0]:\n        heapq.heapreplace(tmp_li,R[i])\nprint(sum(tmp_li))", "x,y,a,b,c=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\ns=[]\nfor i in range(a):\n    s.append([p[i],1])\nfor i in range(b):\n    s.append([q[i],2])\nfor i in range(c):\n    s.append([r[i],0])\ns.sort(reverse=True)\no=0\nX,Y,Z=0,0,0\nfor i in range(a+b+c):\n    if s[i][1]==1 and X<x:\n        X+=1\n        Z+=1\n        o+=s[i][0]\n    elif s[i][1]==2 and Y<y:\n        Y+=1\n        Z+=1\n        o+=s[i][0]\n    elif s[i][1]==0:\n        Z+=1\n        o+=s[i][0]\n    if Z==x+y:\n        break\nprint(o)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nx,y,a,b,c=nii()\np=lnii()\nq=lnii()\nr=lnii()\n\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\n\nl=p[:x]+q[:y]\nl.sort()\n\nans=0\nfor i in range(x+y):\n  if i<c:\n    ans+=max(l[i],r[i])\n  else:\n    ans+=l[i]\n\nprint(ans)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nx,y,a,b,c=nii()\np=sorted(lnii(),reverse=True)\nq=sorted(lnii(),reverse=True)\nr=sorted(lnii(),reverse=True)\n\nl=p[:x]+q[:y]\nl.sort()\n\nans=0\nfor i in range(x+y):\n  if i<c:\n    ans+=max(l[i],r[i])\n  else:\n    ans+=l[i]\n\nprint(ans)", "x, y, a, b, c = map(int, input().split())\nrs = [int(i) for i in input().split()]\ngs = [int(i) for i in input().split()]\nws = [int(i) for i in input().split()]\n\nrs.sort(reverse=True)\ngs.sort(reverse=True)\nws.sort(reverse=True)\nweight = 0\nrs = rs[:x]\nrs = [0] + rs\ngs = gs[:y]\ngs = [0] + gs\nws = [0] + ws\nr = 0\ng = 0\nw = 0\nwhile r + g + w < x + y:\n  if r < x:\n    w1 = weight + rs[r + 1]\n  else:\n    w1 = 0\n  if g < y:\n    w2 = weight + gs[g + 1]\n  else:\n    w2 = 0\n  if w < c:\n    w3 = weight + ws[w + 1]\n  else:\n    w3 = 0\n  weight = max(w1, w2, w3)\n  if weight == w1:\n    r += 1\n  elif weight == w2:\n    g += 1\n  elif weight == w3:\n    w += 1\nprint(weight)", "(x,y,a,b,c),p,q,r=[[*list(map(int,i.split()))]for i in open(0)]\nprint((sum(sorted(sorted(p)[-x:]+sorted(q)[-y:]+r)[-x-y:])))\n", "x, y, a, b, c = list(map(int, input().split()))\n\npA = list(map(lambda x: (int(x), \"a\"), input().split()))\npB = list(map(lambda x: (int(x), \"b\"), input().split()))\npC = list(map(lambda x: (int(x), \"c\"), input().split()))\n\napples = sorted(pA + pB + pC)\n\ncntA = 0\ncntB = 0\ncntC = 0\ncnt = 0\n\nwhile cntA + cntB + cntC < x+y:\n    val, col = apples.pop()\n\n    if col == \"a\" and cntA < x:\n        cntA += 1\n        cnt += val\n    elif col == \"b\" and cntB < y:\n        cntB += 1\n        cnt += val\n    elif col == \"c\":\n        cntC += 1\n        cnt += val\n\nprint(cnt)", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nfrom functools import reduce\n\n\nx,y,a,b,c = list(map(int, input().split()))\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\np = sorted(p, reverse=True)[:x]\nq = sorted(q, reverse=True)[:y]\nr = sorted(r, reverse=True)\n\npq = sorted(p+q)\nans = sum(pq)\n\nfor i in range(len(r)):\n    if pq[i] < r[i]:\n        ans = ans + r[i] -pq[i]\n    else:\n        break\n\nprint(ans)\n", "X,Y,A,B,C=list(map(int,input().split()))\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\nfrom collections import deque\n\np.sort()\np=p[len(p)-X:]\nq.sort()\nq=q[len(q)-Y:]\nr.sort(reverse=True)\np=deque(p)\nq=deque(q)\n\nfor i in r:\n  if min(p[0],q[0])>i:break\n  if p[0]<q[0]:\n    p.popleft()\n    p.append(i)\n  else:\n    q.popleft()\n    q.append(i)\nprint((sum(p)+sum(q)))\n", "from collections import deque\nx,y,a,b,c = map(int,input().split())\nls = []\nla = list(map(int,input().split()))\nlb = list(map(int,input().split()))\nlc = list(map(int,input().split()))\nla.sort(reverse=True)\nlb.sort(reverse=True)\nlc.sort(reverse=True)\nfor i in range(a):\n    ls.append([la[i],1])\nfor j in range(b):\n    ls.append([lb[j],2])\nfor l in range(c):\n    ls.append([lc[l],3])\nls.sort(key=lambda x:x[0],reverse=True)\nls = deque(ls)\ns,t,k = 0,0,0\ncnt = 0\nwhile True:\n    now = ls.popleft()\n    if now[1] == 1:\n        if s < x:\n            cnt += now[0]\n            s += 1\n    elif now[1] == 2:\n        if t < y:\n            cnt += now[0]\n            t += 1\n    else:\n        cnt += now[0]\n        k += 1\n    if s + t + k == x + y:\n        print(cnt)\n        break", "#ABC160\nx, y, a, b, c = list(map(int, input().split()))\np = list(map(int, input().split())) # list()\u3067\u30ea\u30b9\u30c8\u5316\u3001\u305d\u308c\u3092\u5909\u6570\u306b\u4ee3\u5165\u3002\nq = list(map(int, input().split())) # list()\u3067\u30ea\u30b9\u30c8\u5316\u3001\u305d\u308c\u3092\u5909\u6570\u306b\u4ee3\u5165\u3002\nr = list(map(int, input().split())) # list()\u3067\u30ea\u30b9\u30c8\u5316\u3001\u305d\u308c\u3092\u5909\u6570\u306b\u4ee3\u5165\u3002\n\np.sort(reverse = True)\nq.sort(reverse = True)\nr.sort(reverse = True)\n#print(p)\n#print(q)\n#print(r)\np = p[:x]\nq = q[:y]\n\neat = p + q + r\n\neat.sort(reverse = True)\neat = eat[:(x+y)]\n\nprint((sum(eat)))\n#print(eat)\n", "import math\nimport sys\nimport collections\nimport bisect\nreadline = sys.stdin.readline\n\n\ndef main():\n    x, y, a, b, c = list(map(int, input().split()))\n    print((sum(sorted((sorted(list(map(int, input().split())), reverse=True)[0:x] + sorted(list(map(int, input(\n    ).split())), reverse=True)[0:y] + sorted(list(map(int, input().split())), reverse=True)), reverse=True)[0:(x + y)])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x,y,a,b,c=list(map(int,input().split()))\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\np2=p[:x]\nq2=q[:y]\nnum=p2+q2\nnum.sort()\nans=sum(num)\ncnt=ans\nfor i in range(min(x+y,c)):\n    cnt+=r[i]-num[i]\n    ans=max(ans,cnt)\nprint(ans)\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n    x,y,a,b,c=map(int, input().split())\n    p=list(map(int, input().split()))\n    q=list(map(int, input().split()))\n    r=list(map(int, input().split()))\n    p.sort(reverse=True)\n    q.sort(reverse=True)\n    r.sort(reverse=True)\n    p=[10**10]+p[:x]\n    q=[10**10]+q[:y]\n    r+=[0]*(a+b)\n    ans=sum(p)+sum(q)-2*10**10\n    pcnt,qcnt=0,0\n    for i in range(x+y):\n        if p[-1-pcnt] >= r[i] and q[-1-qcnt] >= r[i]:\n            break\n        elif p[-1-pcnt] > q[-1-qcnt]:\n            ans += -q[-1-qcnt] + r[i]\n            qcnt +=1\n        else:\n            ans += -p[-1-pcnt] + r[i]\n            pcnt +=1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "X,Y,A,B,C = list(map(int, input().split()))\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\nR = list(map(int, input().split()))\nP.sort(reverse=True)\nP = P[:X]\nQ.sort(reverse=True)\nQ = Q[:Y]\nsp = sum(P)\nsq = sum(Q)\nans = sp+sq\nR.sort(reverse=True)\nimport heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\nheapq.heapify(P)  # \u30ea\u30b9\u30c8\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u3078\nheapq.heapify(Q)\np = heapq.heappop(P) # \u6700\u5c0f\u5024\u306e\u53d6\u308a\u51fa\u3057\nq = heapq.heappop(Q)\nr = R.pop(0)\nwhile p<r or q<r:\n  #print(p,q,r,ans)\n  if r-p > r-q:\n    heapq.heappush(P, r)\n    ans += r-p\n    p = heapq.heappop(P)\n  else:\n    heapq.heappush(Q, r)\n    ans += r-q\n    q = heapq.heappop(Q)\n  if len(R)==0:\n    break\n  r = R.pop(0)\n  #print(p,q,r,ans)\nprint(ans)\n\n#print(*ans[1:], sep='\\n')\n", "x,y,a,b,c = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\np.sort()\nq.sort()\nr.sort()\nw = p[a-x:a] + q[b-y:b] + r\nw.sort()\nprint(sum(w[len(w)-(x+y):len(w)]))", "X,Y,A,B,C =map(int,input().split())\nP = list(map(int,input().split()))\nQ = list(map(int,input().split()))\nR = list(map(int,input().split()))\n\nP.sort()\nQ.sort()\nR.sort()\n\nP_new = P[-X::]\nQ_new = Q[-Y::]\n\n\nagg = P_new + Q_new +R\nagg.sort()\nprint(sum(agg[-X-Y::]))", "(x, y, a, b, c), p, q, r = [map(int, o.split()) for o in open(0)]\nprint(sum(sorted(sorted(p)[-x:] + sorted(q)[-y:] + list(r))[-x-y:]))", "def main():\n    X, Y, A, B, C = list(map(int, input().split()))\n    *P, = list(map(int, input().split()))\n    *Q, = list(map(int, input().split()))\n    *R, = list(map(int, input().split()))\n\n    P.sort(reverse=True)\n    Q.sort(reverse=True)\n\n    ans = sum(sorted(P[:X] + Q[:Y] + R, reverse=True)[:X + Y])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x,y,a,b,c=map(int,input().split())\np=sorted(list(map(int,input().split())),reverse=True)\nq=sorted(list(map(int,input().split())),reverse=True)\nr=sorted(list(map(int,input().split())),reverse=True)\nall=sorted(p[:x]+q[:y]+r,reverse=True)\nprint(sum(all[:x+y]))", "x,y,a,b,c = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\np = sorted(p, reverse=True)\nq = sorted(q, reverse=True)\n\npq = sorted(p[:x] + q[:y])\nr = sorted(r)\nans=0\nj = r.pop()\nfor i in pq:\n  if i < j:\n    ans += j\n    j = 0\n    if r:\n      j = r.pop()\n  else:\n    ans += i\n    \nprint(ans)", "X, Y, A, B, C = map(int, input().split())\np_l = sorted(map(int,input().split()), reverse = True)\nq_l = sorted(map(int,input().split()), reverse = True)\nr_l = sorted(map(int,input().split()), reverse = True)\np = X\nq = Y\nr = 0\nfor i in range(min(X+Y, C)):\n    if p == 0 and q == 0:\n        break\n    elif p == 0 and r_l[i] <= q_l[q-1]:\n        break\n    elif q == 0 and r_l[i] <= p_l[p-1]:\n        break\n    elif p == 0 and r_l[i] > q_l[q-1]:\n        r, q = r+1, q-1\n    elif q == 0 and r_l[i] > p_l[p-1]:\n        r, p = r+1, p-1\n    elif r_l[i] > q_l[q-1] and p_l[p-1] >= q_l[q-1]:\n        r, q = r+1, q-1\n    elif r_l[i] > p_l[p-1] and q_l[q-1] >= p_l[p-1]:\n        r, p = r+1, p-1\n    else:\n        break\nprint(sum(p_l[:p])+sum(q_l[:q])+sum(r_l[:r]))", "x, y, a, b, c = list(map(int, input().split()))\np = sorted(map(int, input().split()), reverse=True)\nq = sorted(map(int, input().split()), reverse=True)\nr = sorted(map(int, input().split()))\nv = 0\nc = sorted(p[0:x] + q[0:y])\nfor i in range(x + y):\n    if len(r):\n        if c[i] < r[-1]:\n            c[i] = r.pop()\n    else:\n        break\nprint((sum(c)))\n", "x, y, a, b, c = list(map(int, input().split()))\np = sorted(list(map(int, input().split())))[::-1]\nq = sorted(list(map(int, input().split())))[::-1]\nr = sorted(list(map(int, input().split())))[::-1]\n\nu = sorted(p[:x] + q[:y] + r)[::-1]\nprint((sum(u[:x + y])))\n", "import heapq\nx,y,a,b,c=map(int,input().split())\np=sorted(list(map(int,input().split())),reverse=True)\nq=sorted(list(map(int,input().split())),reverse=True)\nr=list(map(lambda x:-int(x),input().split()))\nheapq.heapify(r)\nfor i in range(x):\n    heapq.heappush(r,-p[i])\nfor i in range(y):\n    heapq.heappush(r,-q[i])\nans=0\nfor i in range(x+y):\n    ans-=heapq.heappop(r)\nprint(ans)", "x,y,a,b,c=list(map(int, input().split()))\np=sorted(list(map(int, input().split())), reverse=True)[:x]\nq=sorted(list(map(int, input().split())), reverse=True)[:y]\nr=sorted(list(map(int, input().split())), reverse=True)[:x+y]\n\nnew=sorted(p+q+r, reverse=True)\nprint((sum(new[:x+y])))\n", "x,y,a,b,c=[int(i) for i in input().split()]\n\nred_list=[int(i) for i in input().split()]\ngreen_list=[int(i) for i in input().split()]\nnon_col_list=[int(i) for i in input().split()]\n\nred_list.sort()\ngreen_list.sort()\nnon_col_list.sort()\n\neat_red=[]\neat_green=[]\nfor i in range(x):\n    eat_red.append(red_list.pop())\nfor i in range(y):\n    eat_green.append(green_list.pop())\n\n\nans_list=eat_green+eat_red+non_col_list\nans_list.sort()\nans=0\nfor i in range(x+y):\n    ans+=ans_list.pop()\n\nprint(ans)", "x, y, a, b, c = map(int, input().split())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\nR = list(map(int, input().split()))\n\nP.sort(reverse=True)\nQ.sort(reverse=True)\nR.sort(reverse=True)\n\nL = P[:x] + Q[:y] + R\nL.sort(reverse=True)\nprint(sum(L[:x+y]))", "x,y,a,b,c = map(int, input().split())\nl = [list(map(int, input().split())) for i in range(3)]\nk = sorted(l[0],reverse=True)[:x]\nfor i in sorted(l[1],reverse=True)[:y]:\n  k.append(i)\nfor i in l[2]:\n  k.append(i)\nm = sorted(k,reverse=True)[:x+y]\nprint(sum(m))", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\nimport heapq\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n\n    X,Y,a,b,c=list(map(int, readline().rstrip().split()))\n\n    R=list([int(x)*(-1) for x in readline().rstrip().split()])\n    G=list([int(x)*(-1) for x in readline().rstrip().split()])\n    C=list([int(x)*(-1) for x in readline().rstrip().split()])\n\n    heapq.heapify(R)\n    heapq.heapify(G)\n    heapq.heapify(C)\n    ans = []\n    heapq.heapify(ans)\n\n    for _ in range(X):\n        a = heapq.heappop(R)\n        heapq.heappush(ans,a)\n    for _ in range(Y):\n        a = heapq.heappop(G)\n        heapq.heappush(ans,a)\n    for _ in range(min(X+Y,c)):\n        a = heapq.heappop(C)\n        heapq.heappush(ans,a)\n    a=0\n    for _ in range(X+Y):\n        a += heapq.heappop(ans) * -1\n\n    print(a)\n    #n=int(readline())\n    #ss=readline().rstrip()\n    #yn(1)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    X, Y, A, B, C = MI()\n    R = sorted(LI(), reverse=True)[:X]\n    G = sorted(LI(), reverse=True)[:Y]\n    T = LI()\n    L = sorted(R + G + T, reverse=True)[:X+Y]\n    print((sum(L)))\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "X,Y,A,B,C = map(int,input().split())\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nr = list(map(int,input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\nans = sum(p[:X]) + sum(q[:Y])\nx = X-1\ny = Y-1\nm = min(p[x],q[y])\nn = 1\nwhile len(r)>0 and r[0] > m:\n    if n == 1:\n        if p[x] > q[y]:\n            ans += r[0] - q[y]\n            y -= 1\n        else:\n            ans += r[0] - p[x]\n            x -= 1\n    else:\n        ans += r[0] - m\n        if x<0:\n            y -= 1\n        else:\n            x -= 1\n    r.pop(0)\n    if y >= 0 and x >= 0:\n        m = min(p[x],q[y])\n    elif x >= 0 and y<0:\n        m = p[x]\n        n = 0\n    elif y >= 0 and x<0:\n        m = q[y]\n        n = 0\n    else:\n        m = 10 ** 9 + 1\n        n = 0\nprint(ans)", "x,y,a,b,c = map(int,input().split())\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nr = list(map(int,input().split()))\n\np.sort(reverse=True)\nq.sort(reverse=True)\n\np2 = p[:x]\nq2 = q[:y]\n\nl = p2 + q2 + r\nl.sort(reverse=True)\n\nans = sum(l[:x+y])\nprint(ans)", "x,y,a,b,c=[int(i) for i in input().split()]\np=[int(i) for i in input().split()]\nq=[int(i) for i in input().split()]\nr=[int(i) for i in input().split()]\n\np.sort()\nq.sort()\nr.sort()\n\np=p[-x:]\nq=q[-y:]\n\nans=p+q+r\nans.sort()\nans=ans[-x-y:]\nprint((sum(ans)))\n", "import heapq\n\nx,y,a,b,c = list(map(int,input().split()))\n\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\nr = list(map(int,input().split()))\n\nans = 0\nred_cnt = 0\ngreen_cnt = 0\ncnt = 0\n\nheap = []\nfor i in range(len(p)):\n    heapq.heappush(heap,(-p[i],0))\nfor i in range(len(q)):\n    heapq.heappush(heap,(-q[i],1))\nfor i in range(len(r)):\n    heapq.heappush(heap,(-r[i],2))\n\nwhile len(heap):\n    _x,_y = heapq.heappop(heap)\n    if _y == 0 and red_cnt < x:\n        red_cnt += 1\n        ans += _x\n        cnt += 1\n    elif _y == 1 and green_cnt < y:\n        green_cnt += 1\n        ans += _x\n        cnt += 1\n    elif _y == 2:\n        cnt += 1\n        ans += _x\n\n    if cnt == x + y:\n        print((-ans))\n        return\n", "X,Y,A,B,C=map(int,input().split())\nP=sorted(map(int,input().split()), reverse=True)[:X]\nQ=sorted(map(int,input().split()), reverse=True)[:Y]\nR=sorted(map(int,input().split()), reverse=True)[:X+Y]\ni,j=X-1,Y-1\nfor r in R:\n    if i==-1 and j==-1:\n        break\n    elif j==-1:\n        if r>P[i]:\n            P[i]=r\n            i-=1\n        else:\n            break\n    elif i==-1:\n        if r>Q[j]:\n            Q[j]=r\n            j-=1\n        else:\n            break\n    elif P[i]>Q[j]:\n        if r>Q[j]:\n            Q[j]=r\n            j-=1\n        else:\n            break\n    else:\n        if r>P[i]:\n            P[i]=r\n            i-=1\n        else:\n            break\nprint(sum(P)+sum(Q))", "from heapq import heapify, heappop, heappush\n\nx, y, a, b, c = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\nr = [-x for x in r]\n\np.sort()\nq.sort()\nr.sort()\n\np = p[-x:]\nq = q[-y:]\n\nheapify(p)\nheapify(q)\nheapify(r)\n\nwhile r:\n    pp = heappop(p)\n    qq = heappop(q)\n    rr = heappop(r)\n    rr *= -1\n\n    if pp >= rr and qq >= rr:\n        heappush(p, pp)\n        heappush(q, qq)\n        break\n\n    elif pp <= qq:\n        heappush(q, qq)\n        if pp < rr:\n            heappush(p, rr)\n    else:\n        heappush(p, pp)\n        if qq < rr:\n            heappush(q, rr)\n\nprint(sum(p) + sum(q))", "x, y, a,  b, c = list(map(int, input().split()))\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\nR = list(map(int, input().split()))\nP.sort(reverse = True)\nQ.sort(reverse = True)\nR = R + P[: x] + Q[: y]\nR.sort(reverse = True)\nprint((sum(R[: x + y])))\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    X, Y, A, B, C = map(int, input().split())\n    P = sorted(list(map(int, input().split())))\n    Q = sorted(list(map(int, input().split())))\n    R = sorted(list(map(int, input().split())))\n\n    l = sorted(P[-X:] + Q[-Y:])\n    ans = 0\n    for i in range(len(l)):\n        if len(R) > 0 and R[-1] > l[i]:\n            ans += R.pop(-1)\n        else:\n            ans += l[i]\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nfrom collections import deque\nmust_red, must_green, a,b,c = list(map(int,input().split()))\ndelicious_red_ls = list(map(int, input().split()))\ndelicious_green_ls = list(map(int, input().split()))\ndelicious_free_ls = list(map(int, input().split()))\ndelicious_red_ls.sort(reverse=True)\ndelicious_green_ls.sort(reverse=True)\nfirst_red = delicious_red_ls[:must_red]\nfirst_green = delicious_green_ls[:must_green]\nfirst_set = first_green + first_red\nfirst_set.sort()\ndelicious_free_ls.sort()\n\nwhile delicious_free_ls:\n    to_be_erased = heapq.heappop(first_set)\n    erase = delicious_free_ls[-1]\n    if to_be_erased < erase:\n        new = delicious_free_ls.pop()\n        heapq.heappush(first_set, new)\n    else:\n        heapq.heappush(first_set, to_be_erased)\n        break\nprint((sum(first_set)))\n\n\n", "X, Y, A, B, C = list(map(int, input().split()))\nP = sorted(map(int, input().split()), reverse=True)[:X]\nQ = sorted(map(int, input().split()), reverse=True)[:Y]\nR = sorted(map(int, input().split()), reverse=True)\n\nPQ = sorted(P+Q)\nans = sum(PQ)\nfor r, pq in zip(R, PQ):\n    if r > pq:\n        ans += r - pq\nprint(ans)\n", "X, Y, A, B, C = map(int, input().split())\np = sorted(list(map(int, input().split())))[::-1]\nq = sorted(list(map(int, input().split())))[::-1]\nr = sorted(list(map(int, input().split())))[::-1]\n\ni = X - 1\nj = Y - 1\nk = 0\n\np.append(float(\"INF\"))\nq.append(float(\"INF\"))\nr.append(-1)\n\nwhile p[i] < r[k] or q[j] < r[k]:\n    if p[i] < q[j]:\n        i -= 1\n        k += 1\n    else:\n        j -= 1\n        k += 1\n\nans = 0\nif i != -1:\n    ans += sum(p[:i+1])\nif j != -1:\n    ans += sum(q[:j+1])\nif k != 0:\n    ans += sum(r[:k])\n\nprint(ans)", "x,y,a,b,c  = map(int,input().split())\np=[int(x) for x in input().rstrip().split()]\nq=[int(x) for x in input().rstrip().split()]\nr=[int(x) for x in input().rstrip().split()]\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\n\np=p[:x]\nq=q[:y]\npq=p+q\npqr=pq+r\npqr.sort(reverse=True)\nprint(sum(pqr[:x+y]))", "X, Y, A, B, C = list(map(int, input().split()))\nP = sorted(list(map(int, input().split())), reverse=True)\nQ = sorted(list(map(int, input().split())), reverse=True)\nR = sorted(list(map(int, input().split())), reverse=True)\n\npq = sorted(P[:X] + Q[:Y])\ncnt = 0\nfor i in range(min(C, X+Y)):\n    if R[i] <= pq[i]: \n        break\n    cnt += 1\n\nans = sum(pq[cnt:]) + sum(R[:cnt])\n\nprint(ans)\n", "import heapq\n\nX,Y,A,B,C=map(int,input().split())\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort()\n\ns = p[:X]+q[:Y]\nans=sum(s)\nheapq.heapify(s)\n\nwhile r and s:\n    if s[0]<r[-1]:\n        ans += r[-1]\n        r.pop()\n        ans -= heapq.heappop(s)\n    else:\n        break\nprint(ans)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[10]:\n\n\nX,Y,A,B,C = list(map(int, input().split()))\np = sorted(list(map(int, input().split())), reverse=True)\nq = sorted(list(map(int, input().split())), reverse=True)\nr = sorted(list(map(int, input().split())), reverse=True)\n\n\n# In[14]:\n\n\np_list = p[:X]\nq_list = q[:Y]\nmylist = sorted(p_list + q_list + r, reverse=True)\nans = 0\nfor i in range(X+Y):\n    ans += mylist[i]\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "from collections import deque\n\nX, Y, A, B, C = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\nALL = p + q + r\nALL.sort(reverse=True)\nALL = deque(ALL)\n\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\n\np = deque(p)\nq = deque(q)\nr = deque(r)\n\nans = 0\np_cnt = 0\nq_cnt = 0\nr_cnt = 0\nloopcnt = 0\nwhile loopcnt < X+Y:\n    apple = ALL.popleft()\n    if p_cnt < X and apple == p[0]:\n        ans += p.popleft()\n        p_cnt += 1\n        loopcnt += 1\n    elif q_cnt < Y and apple == q[0]:\n        ans += q.popleft()\n        q_cnt += 1\n        loopcnt += 1\n    elif r_cnt < C and apple == r[0]:\n        ans += r.popleft()\n        r_cnt += 1\n        loopcnt += 1\nprint(ans)", "import heapq\n\nx,y,a,b,c=list(map(int,input().split()))\np=list(map(int,input().split()))\nq=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\np.sort(reverse=True)\nq.sort(reverse=True)\nr.sort(reverse=True)\n\nans=[]\nfor i in range(x):\n  ans.append(p[i])\n  \nfor j in range(y):\n  ans.append(q[j])\n  \nans.sort()\n\nheapq.heapify(ans)\n\nfor j in range(c):\n  min_a=heapq.heappop(ans)\n  if min_a<=r[j]:\n    heapq.heappush(ans,r[j])\n  else:\n    heapq.heappush(ans,min_a)\n    break\n    \nprint((sum(ans)))\n\n\n", "X, Y, A, B, C = map(int, input().split())\nplist = list(map(int, input().split()))\nqlist = list(map(int, input().split()))\nrlist = list(map(int, input().split()))\n\nplist.sort()\nqlist.sort()\nrlist.sort()\n\nplist = plist[::-1][:X]\nqlist = qlist[::-1][:Y]\nrlist = rlist[::-1]\n\npqrlist = plist + qlist + rlist\npqrlist.sort()\npqrlist = pqrlist[::-1]\n\nprint(sum(pqrlist[:X+Y]))", "import sys,math,collections,itertools,heapq\ninput = sys.stdin.readline\ndef f(n):\n    return -1*int(n)\n\nx,y,a,b,c=list(map(int,input().split()))\np=sorted(list(map(int,input().split())),reverse=1)[:x]\nq=sorted(list(map(int,input().split())),reverse=1)[:y]\nr=list(map(f,input().split()))\n\np = collections.deque(p)\nq = collections.deque(q)\nheapq.heapify(r)\n\ntmp = -1*heapq.heappop(r)\nwhile tmp > p[-1]:\n    p.appendleft(tmp)\n    tmp = p.pop()\n    tmp = -1* heapq.heappushpop(r,-1*tmp)\n\nwhile tmp > q[-1]:\n    q.appendleft(tmp)\n    tmp = q.pop()\n    tmp = -1 * heapq.heappushpop(r,-1*tmp)\n\nprint((sum(p)+sum(q)))\n\n        \n", "X, Y, A, B, C = [int(x) for x in input().split()]\np = sorted([int(x) for x in input().split()], reverse=True)[:X]\nq = sorted([int(x) for x in input().split()], reverse=True)[:Y]\nr = sorted([int(x) for x in input().split()], reverse=True)[:X + Y]\n\ns = sorted(p + q + r, reverse=True)\n\nans = sum(s[:X + Y])\n\nprint(ans)", "x,y,a,b,c=map(int,input().split())\nred=list(map(int,input().split()))\ngreen=list(map(int,input().split()))\ncolorless=list(map(int,input().split()))\ntemp=[]\nred.sort(reverse=True)\ngreen.sort(reverse=True)\ncolorless.sort(reverse=True)\nfor i in range(min(x,a)):\n  temp.append(red[i])\nfor i in range(min(y,b)):\n  temp.append(green[i])\nfor i in range(c):\n  temp.append(colorless[i])\ntemp.sort(reverse=True)\nans=0\nfor i in range(x+y):\n  ans+=temp[i]\nprint(ans)", "import heapq\nimport sys\nX, Y, A, B, C = list(map(int, input().split()))\nAv = list(map(int, input().split()))\nBv = list(map(int, input().split()))\nCv = list(map(int, input().split()))\nheapq.heapify(Av)\nheapq.heapify(Bv)\nheapq.heapify(Cv)\nfor i in range(A-X):\n    heapq.heappop(Av)\nfor i in range(B-Y):\n    heapq.heappop(Bv)\nif C > X+Y:\n    for i in range(C-(X+Y)):\n        heapq.heappop(Cv)\n    NotTake = X+Y\nelse:\n    NotTake = C\ntotal = X+Y\nC = NotTake\nfor _ in range(NotTake):\n    Amin = heapq.heappop(Av)\n    Bmin = heapq.heappop(Bv)\n    Cmin = heapq.heappop(Cv)\n    if X > 0 and Amin == min(Amin, Bmin, Cmin):\n        heapq.heappush(Bv, Bmin)\n        heapq.heappush(Cv, Cmin)\n        X -= 1\n    elif Y > 0 and Bmin == min(Bmin, Cmin):\n        heapq.heappush(Av, Amin)\n        heapq.heappush(Cv, Cmin)\n        Y -= 1\n    elif C > 0:\n        heapq.heappush(Av, Amin)\n        heapq.heappush(Bv, Bmin)\n        C -= 1\n    if X == 0 or Y == 0 or C == 0:\n        break\nNotTake = X+Y+C-total\nif X == 0:\n    Iv = Bv\n    Jv = Cv\n    I = Y\n    J = C\nelif Y == 0:\n    Iv = Av\n    Jv = Cv\n    I = X\n    J = C\nelse:\n    print((sum(Av)+sum(Bv)+sum(Cv)))\n    return\n\nfor _ in range(NotTake):\n    Imin = heapq.heappop(Iv)\n    Jmin = heapq.heappop(Jv)\n    if I > 0 and Imin == min(Imin, Jmin):\n        heapq.heappush(Jv, Jmin)\n        I -= 1\n    elif J > 0:\n        heapq.heappush(Iv, Imin)\n        J -= 1\n    if J == 0 or I == 0:\n        break\n\nprint((sum(Av)+sum(Bv)+sum(Cv)))\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    X, Y, A, B, C = list(map(int, readline().split()))\n    P = list(map(int, readline().split()))\n    Q = list(map(int, readline().split()))\n    R = list(map(int, readline().split()))\n\n    P.sort(reverse=True)\n    Q.sort(reverse=True)\n\n    apple = P[:X] + Q[:Y] + R\n    apple.sort(reverse=True)\n\n    print((sum(apple[: X + Y])))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x, y, a, b, c = map(int, input().split())\np_array = list(map(int, input().split()))\nq_array = list(map(int, input().split()))\nr_array = list(map(int, input().split()))\n\np_array_sort = sorted(p_array, reverse=True)\nq_array_sort = sorted(q_array, reverse=True)\nr_array_sort = sorted(r_array, reverse=True)\n\np_i = x - 1\nq_i = y - 1\n\nfor r in r_array_sort:\n    p = p_array_sort[p_i]\n    q = q_array_sort[q_i]\n    if r <= p and r <= q:\n        break\n    elif q <= p:\n        q_array_sort[q_i] = r\n        q_i = max(q_i - 1, 0)\n    else:\n        p_array_sort[p_i] = r\n        p_i = max(p_i - 1, 0)\n\nans = sum(p_array_sort[:x]) + sum(q_array_sort[:y])\nprint(ans)", "X, Y, A, B, C = list(map(int, input().split()))\nPs = list(map(int, input().split()))\nQs = list(map(int, input().split()))\nRs = list(map(int, input().split()))\n\nPs.sort(reverse=True)\nQs.sort(reverse=True)\nRs += Ps[:X] + Qs[:Y]\n\nRs.sort(reverse=True)\n\nans = sum(Rs[:X+Y])\nprint(ans)\n", "X,Y,A,B,C=map(int,input().split())\n*P,=sorted(map(int,input().split()))\n*Q,=sorted(map(int,input().split()))\n*R,=map(int,input().split())\n\nP=P[-X:]\nQ=Q[-Y:]\nR=sorted(P+Q+R)\nans=sum(R[-(X+Y):])\nprint(ans)", "x,y,a,b,c=list(map(int,input().split()))\np=[0]+sorted(list(map(int,input().split())))[a-x:]\nq=[0]+sorted(list(map(int,input().split())))[b-y:]\nr=[0]+sorted(list(map(int,input().split())))\npi=-1\nqi=-1\nri=-1\ngs=0\nrs=0\nws=0\ns=0              \nwhile gs+rs+ws!=x+y:\n    if r[ri]>=q[qi]>=p[pi]:\n        s += r[ri]\n        ws+=1\n        ri-=1\n\n    elif r[ri]>=p[pi]>=q[qi]:\n        s += r[ri]\n        ws += 1\n        ri -= 1\n\n    elif q[qi]>=r[ri]>=p[pi]:\n        s += q[qi]\n        gs += 1\n        qi -= 1\n\n    elif q[qi]>=p[pi]>=r[ri]:\n        s += q[qi]\n        gs += 1\n        qi -= 1\n\n    elif p[pi]>=r[ri]>=q[qi]:\n        s += p[pi]\n        rs += 1\n        pi -= 1\n\n    elif p[pi]>=q[qi]>=r[ri]:\n        s += p[pi]\n        rs += 1\n        pi -= 1\n\nprint(s)\n", "def main():\n    import sys\n\n    def input(): return sys.stdin.readline().rstrip()\n\n    x, y, a, b, c = map(int, input().split())\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    p.sort(reverse=True)\n    q.sort(reverse=True)\n    r = p[:x]+q[:y]+r\n    r.sort(reverse=True)\n    print(sum(r[:x+y]))\n\ndef __starting_point():\n    main()\n__starting_point()", "x,y,a,b,c=list(map(int,input().split()))\np=sorted(list(map(int,input().split())))[-x:]\nq=sorted(list(map(int,input().split())))[-y:]\nr=sorted(list(map(int,input().split())))[::-1]\n\ni=j=k=0\noi=0\nwhile i<c:\n  if x>j and y>k:\n    if p[j]>=q[k] and q[k]<r[i]:\n      q[k]=r[i]\n      k+=1\n      i+=1\n    elif p[j]<q[k] and p[j]<r[i]:\n      p[j]=r[i]\n      j+=1\n      i+=1\n  elif x>j:\n    if p[j]<r[i]:\n      p[j]=r[i]\n      j+=1\n      i+=1\n  elif y>k:\n    if q[k]<r[i]:\n      q[k]=r[i]\n      k+=1\n      i+=1\n  if oi==i:break\n  oi=i\n\nprint((sum(p)+sum(q)))\n\n", "x,y,a,b,c = map(int,input().split())\np = sorted(list(map(int,input().split())), reverse=True)\nq = sorted(list(map(int,input().split())), reverse=True)\nr = sorted(list(map(int,input().split())), reverse=True)\npq = sorted(p[:x] + q[:y])\nans = sum(pq)\ni = 0\nwhile i < min(a+b, c):\n  if r[i] <= pq[i]:\n    break\n  ans += r[i] - pq[i]\n  i += 1\nprint(ans)", "x,y,a,b,c = map(int,input().split())\np = sorted([int(x) for x in input().split()])[::-1][:x]\nq = sorted([int(x) for x in input().split()])[::-1][:y]\nr = [int(x) for x in input().split()]\nrow = sorted(p+q+r)[::-1]\nprint(sum(row[:x+y]))", "# import itertools\n# import math\n# from functools import reduce\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\nfrom collections import deque\n# import heapq\n\n# \u5165\u529b\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nX, Y, A, B, C = map(int, input().split())\nQ_A = list(map(int, input().split()))\nQ_B = list(map(int, input().split()))\nQ_C = list(map(int, input().split()))\n# A = list(map(lambda x: int(x)*(-1), input().split()))\n# x_y = [list(map(int,input().split())) for _ in range(N)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# edges = [list(map(int,input().split())) for _ in range(N - 1)]\n# tree = [[] for _ in range(N + 1)]\n\n# for edge in edges:\n#     tree[edge[0]].append(edge[1])\n#     tree[edge[1]].append(edge[0])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n# count = [0] * (N + 1)\n\n# for i in range(Q):\n#     p, x = map(int, input().split())\n#     count[p] += x\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + 1\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# \u7d20\u56e0\u6570\u5206\u89e3\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n# \u7d04\u6570\u5217\u6319\n# def make_divisors(n):\n#     lower_divisors , upper_divisors = [], []\n#     i = 1\n#     while i*i <= n:\n#         if n % i == 0:\n#             lower_divisors.append(i)\n#             if i != n // i:\n#                 upper_divisors.append(n//i)\n#         i += 1\n#     return lower_divisors + upper_divisors[::-1]\n\n# bfs\n# tree = [[] for _ in range(N + 1)]\n# edges = [list(map(int,input().split())) for _ in range(M)]\n\n# for edge in edges:\n#     tree[edge[0]].append(edge[1])\n#     tree[edge[1]].append(edge[0])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n\n# d = deque()\n# d.append(1)\n\n# ans = [0] * (N + 1)\n# while d:\n#  v = d.popleft()\n#  for i in tree[v]:\n#    if depth[i] != -1:\n#      continue\n#    depth[i] = depth[v] + 1\n#    ans[i] = v\n#    d.append(i)\n\n# # ans = depth[2:]\n# print('Yes')\n# print(*ans[2:], sep=\"\\n\")\n\n# def gcd_list(numbers):\n#     return reduce(math.gcd, numbers)\n\n# # \u9ad8\u901f\u7d20\u56e0\u6570\u5206\u89e3\u6e96\u5099\n# MAXN = 10**6+10\n# sieve = [i for i in range(MAXN+1)]\n# p = 2\n# while p*p <= MAXN:\n#     if sieve[p] == p:\n#         for q in range(2*p, MAXN+1, p):\n#             if sieve[q] == q:\n#                 sieve[q] = p\n#     p += 1\n\nQ_A = sorted(Q_A, reverse=True)[:X]\nQ_B = sorted(Q_B, reverse=True)[:Y]\nQ_C = sorted(Q_C, reverse=True)\n\ncand = Q_A + Q_B + Q_C\n\ncand = sorted(cand, reverse=True)\nprint(sum(cand[:(X + Y)]))", "import numpy as np\n\nx, y, a, b, c = [int(i) for i in input().split()]\np = np.array([int(i) for i in input().split()])\nq = np.array([int(i) for i in input().split()])\nr = np.array([int(i) for i in input().split()])\n\np.sort()\nq.sort()\nr.sort()\n\np = p[-x:]\nq = q[-y:]\nif x+y < r.size:\n\tr = r[-x-y:]\napple = np.hstack([p, q, r])\napple.sort()\n\nsweet = apple[-x-y:].sum()\n\n# print(x,y,a,b,c)\n# print(p,q,r)\n# print(apple)\nprint(sweet)", "(x,y,a,b,c),p,q,r=[[*list(map(int,i.split()))]for i in open(0)]\np=sorted(p)[-x:]\nq=sorted(q)[-y:]\npq = sorted(p+q)\nr.sort(reverse=True)\nans = sum(pq)\nfor i in range(min(c,x+y)):\n    if r[i] > pq[i]:\n        ans += r[i] - pq[i]\n    else:\n        break\nprint(ans)\n"]
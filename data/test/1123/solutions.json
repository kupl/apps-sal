["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\nclass Prime():\n    def __init__(self, n):\n        self.M = m = int(math.sqrt(n)) + 10\n        self.A = a = [True] * m\n        a[0] = a[1] = False\n        self.T = t = [2]\n        for j in range(4, m, 2):\n            a[j] = False\n        for i in range(3, m, 2):\n            if not a[i]:\n                continue\n            t.append(i)\n            for j in range(i*i,m,i):\n                a[j] = False\n        self.ds_memo = {}\n        self.ds_memo[1] = set([1])\n\n    def is_prime(self, n):\n        return self.A[n]\n\n    def division(self, n):\n        d = collections.defaultdict(int)\n        for c in self.T:\n            while n % c == 0:\n                d[c] += 1\n                n //= c\n            if n < 2:\n                break\n        if n > 1:\n            d[n] += 1\n        return d.items()\n\n    # memo\n    def divisions(self, n):\n        if n in self.ds_memo:\n            return self.ds_memo[n]\n\n        for c in self.T:\n            if n % c == 0:\n                rs = set([c])\n                for cc in self.divisions(n // c):\n                    rs.add(cc)\n                    rs.add(cc * c)\n                self.ds_memo[n] = rs\n                return rs\n\n        rs = set([1, n])\n        self.ds_memo[n] = rs\n        return rs\n\ndef main():\n    n,k = LI()\n    pr = Prime(10**5)\n    c = collections.defaultdict(int)\n    for i in range(k, 0, -1):\n        t = k // i\n        p = (pow(t, n, mod) + c[i]) % mod\n        ds = pr.divisions(i)\n        for kk in ds:\n            if kk == i:\n                continue\n            c[kk] -= p\n        c[i] = p\n\n    r = sum(k*v%mod for k,v in c.items()) % mod\n\n    return r\n\nprint(main())\n\n\n\n", "#!/usr/bin/env python\nn, k = list(map(int, input().split()))\nmod = 10**9+7\n\nd = [-1 for _ in range(k+1)]\nd[k] = 1 \n\nfor i in range(k-1, 0, -1):\n    d[i] = pow(k//i, n, mod)\n    j = 2*i \n    while j <= k:\n        d[i] -= d[j]\n        j += i\n\n#print('d =', d)\nans = 0 \nfor i in range(1, k+1):\n    ans += (i*d[i])%mod\nprint((ans%mod))\n", "import sys\ninput=lambda :sys.stdin.readline().rstrip()\n\nmod = 10**9+7\n\nn, k = map(int, input().split())\n\nd = [0] * (k+1)\nfor i in range(1, k+1):\n    d[i] = pow(k//i, n, mod)\n\nfor i in range(k, 0, -1):\n    for j in range(2*i, k+1, i):\n        d[i] -= d[j]\n        d[i] %= mod\nans=0\nfor i in range(1, k+1):\n    ans += d[i]*i\n    ans %= mod\n\nprint(ans)", "MOD = 10 ** 9 + 7\nN, K = list(map(int, input().split()))\nd = [0] * (K + 1)\nfor i in range(1, K + 1):\n    d[i] = pow(K // i, N, MOD)\nfor i in reversed(list(range(1, K + 1))):\n    for j in range(2 * i, K + 1, i):\n        d[i] -= d[j]\n        d[i] %= MOD\nans = 0\nfor i in range(1, K + 1):\n    ans += d[i] * i\n    ans %= MOD\nprint(ans)\n", "N, K = map(int, input().split())\nnumgcd = [0]*(K+1)\nsumgcd = 0\nmod = 10**9+7\nfor i in range(1, K+1)[::-1]:\n    numgcd[i] = pow(K//i, N, mod)\n    count = 2\n    while count*i <= K:\n        numgcd[i] -= numgcd[count*i]\n        count += 1\n    sumgcd += numgcd[i]*i\nprint(sumgcd%mod)", "N, K = map(int, input().split())\nli = [0]*(K+1)\n\nout = 0\nmod = 10**9+7\n\nfor i in range(K, 0, -1):\n  li[i] = pow(K//i, N, mod) \n  for j in range(i*2, K+1, i):\n    li[i] -= li[j]\n  out += li[i] * i\nprint(out%mod)", "def main():\n    import sys\n    input = sys.stdin.readline\n    \"\"\"\"\u3053\u3053\u306b\u4eca\u307e\u3067\u306e\u30b3\u30fc\u30c9\"\"\"\n    n, k = list(map(int, input().split()))\n    MOD = 10 ** 9 + 7\n    ans = 0\n    baig = [0 for i in range(10 ** 5 + 1)]\n\n    for i in range(1, k + 1):\n        baig[i] = pow(k // i , n , MOD)\n\n    for j in range(k, 0, -1):\n        for jj in range(2 * j, k + 1, j):\n            baig[j] -= baig[jj]\n        baig[j] %= MOD\n        ans += baig[j] * j\n        ans %= MOD\n    print((int(ans)))\ndef __starting_point():\n    main()\n\n__starting_point()", "def pow(a, n, mod):\n    ret = 1\n    pw = a\n    while n > 0:\n        if n & 1 == 1:\n            ret *= pw\n            ret %= mod\n        n >>= 1\n        pw *= pw\n        pw %= mod\n    return ret\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N, K = list(map(int, input().split(' ')))\n    n_gcds = [0 for _ in range(K + 1)]\n    for g in range(K, 0, -1):\n        v = pow(K // g, N, MOD)\n        gg = g\n        while gg + g <= K:\n            gg += g\n            v -= n_gcds[gg]\n            v %= MOD\n        n_gcds[g] = v\n    ans = 0\n    for g, n in enumerate(n_gcds):\n        ans += g * n\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K=map(int,input().split())\nD=[0]*(K+1)\nD[K]=1\nmod=10**9+7\nfor i in range(K,0,-1):\n  D[i]=pow(K//i,N,mod)\n  for j in range(2*i,K+1,i):\n    D[i]=(D[i]-D[j])%mod\n\nc=0\nfor i in range(len(D)):\n  c+=D[i]*i\nprint(c%mod)", "# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left\u3000\u3053\u308c\u3067\u4e8c\u90e8\u63a2\u7d22\u306e\u5927\u5c0f\u691c\u7d22\u304c\u884c\u3048\u308b\nimport fractions #\u6700\u5c0f\u516c\u500d\u6570\u306a\u3069\u306f\u3053\u3063\u3061\nimport math\nimport sys\nimport collections\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # \u518d\u5e30\u56de\u6570\u4e0a\u9650\u306f\u3067default1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN, K = LI()\n\n# \u9006\u306b\u8003\u3048\u308b\n\"\"\"\nX = gcd(A_1, A_2,...A_K)\n\u3068\u306a\u308b\u3088\u3046\u306aX\u3092\u8003\u3048\u308b\u3068\u6eb6\u3051\u308b\nX = 3\u306e\u6642\u305d\u306e\u500b\u6570\u306f\n[K/3]**N\n\"\"\"\n\nx_cnt = [0] * (K + 1)\nfor x in range(K, 0, -1):\n    # print(x)\n    tmp = pow(K // x, N, mod)\n    for j in range(x + x, K+1, x):\n        tmp -= x_cnt[j]\n    x_cnt[x] = tmp\n\nans = 0\nfor i in range(1,K+1):\n    ans += i * x_cnt[i]\n    ans %= mod\nprint(ans)\n\n\n    \n\n", "n, k = list(map(int, input().split()))\ng = [1] * k\nmod = 10 ** 9 + 7\n\nfor i in range(k, 0, -1):\n    x = k // i\n    m = n\n    while m > 0:\n        if m & 1:\n            g[i-1] = g[i-1] * x % mod\n        x = x * x % mod\n        m >>= 1\n\n    y = 2\n    while i * y <= k:\n        g[i-1] -= g[i*y-1]\n        y += 1\n\nans = 0\nfor i in range(k):\n    ans = (ans + g[i] * (i + 1)) % mod\n\nprint(ans)\n", "n,k=list(map(int,input().split()))\nMOD=10**9+7\nans=0\n\nbaig=[0]*(10**5+1)\nexg=[0]*(10**5+1)\n\nfor i in range(1,k+1):\n    baig[i]=pow(k//i,n,MOD)\n\nfor j in range(k,0,-1):\n    exg[j]=baig[j]\n    for jj in range(2*j,k+1,j):\n        exg[j]-=exg[jj]\n    exg[j]%=MOD\n    ans+=exg[j]*j\n    ans%=MOD\n\nprint((int(ans)))\n\n", "MOD = 10**9 + 7\ndef mod_pow(p, q):\n    res = 1\n    while q > 0:\n        if q & 1:\n            res = (res * p) % MOD\n        q //= 2\n        p = (p * p) % MOD\n    return res\n\ndef solve(n, k):\n    dp = [0] * (k+1)\n    ans = 0\n    for x in range(k, 0, -1):\n        dp[x] = mod_pow((k // x), n) - sum(dp[y] for y in range(2*x, k+1, x))\n        dp[x] %= MOD\n        ans += dp[x] * x\n    return ans % MOD\n\nn, k = map(int, input().split())\nprint(solve(n, k))", "mod = 1000000007\nn,k = map(int, input().split())\nd = [0]*(k+1)\nfor i in range(1,k+1):\n    d[i] = pow(k//i,n,mod)\nfor i in range(k,0,-1):\n    for j in range(2*i,k+1,i):\n        d[i] -= d[j]\n        d[i] %= mod\nans = 0\nfor i in range(1,k+1):\n    ans += d[i]*i\n    ans %= mod\nprint(ans)", "mod = 10 ** 9 + 7\nN, K = map(int, input().split())\n\nans = 0\nmemo = [0] * (K + 1)\nfor i in range(K, 0, -1):\n    x = K // i\n    cnt = pow(x, N, mod)\n\n    a = i\n    while a <= K:\n        cnt -= memo[a]\n        a += i\n\n    memo[i] = cnt\n    ans += i * cnt\n    ans %= mod\n\nprint(ans)", "n,k = map(int,input().split())\nmod = 10**9+7\n\"\"\"\ndp[i] := gcd(a1,...,an) = i \u3068\u306a\u308b\u3082\u306e\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n\"\"\"\ndp = [0 for _ in range(k+1)]\nsubdp = [0 for _ in range(k+1)]\nfor i in range(1, k+1)[::-1]:\n\ttarget = pow(k//i, n, mod)\n\tfor j in range(2*i, k+1, i):\n\t\ttarget -= dp[j]\n\tdp[i] = target\nans = 0\nfor i in range(k+1):\n\tans = (ans + dp[i]*i) % mod\nprint(ans)", "def modpow(val, n, mod):\n    ret = 1\n    while n:\n        if n & 1:\n            ret = (ret * val) % mod\n        val = (val * val) % mod\n        n = n >> 1\n    return ret\n\n\nmod = 10 ** 9 + 7\nn, k = list(map(int, input().split()))\n\nmy_dict = dict()\nret = 0\n\nfor i in range(k, 0, -1):\n    tmp = modpow(k // i, n, mod)\n    cnt = 2\n    while True:\n        val = i * cnt\n        if val > k:\n            break\n        else:\n            cnt += 1\n            tmp -= my_dict[val]\n    my_dict[i] = tmp\n    ret += tmp * i % mod\n\nprint((ret % mod))\n", "n,k=map(int,input().split())\nmod=10**9+7\nans=[0]*(k+1)\nanss=0\nfor i in range(k,0,-1):\n  m=pow(k//i,n,mod)\n  for j in range(i*2,k+1,i):m-=ans[j]\n  ans[i]=m%mod\n  anss+=ans[i]*i\n  anss%=mod\nprint(anss)", "import numpy as np\nMOD = 10 ** 9 + 7\nN, K = list(map(int, input().split()))\ngcds = np.zeros((K + 1,), dtype=np.int64)\nfor n in range(K, 0, -1):\n    gcds[n] = (pow(K // n, N, MOD) - gcds[np.arange(1, K // n + 1, dtype=np.int64) * n].sum()) % MOD\nprint((gcds @ np.arange(K + 1) % MOD))\n", "MOD = 10**9+7\nN, K = list(map(int, input().split()))\nt = {}\nans = 0\n\nfor i in range(K, 0, -1):\n    n = pow(K//i, N, MOD)\n\n    for j in range(2*i, K+1, i):\n        n -= t[j]\n    t[i] = n\n    ans = (ans + i * n) % MOD\nprint(ans)", "n,k=map(int,input().split())\nMOD=10**9+7\nl=[0]*(k+1)\nfor i in range(k,0,-1):\n  l[i]=pow(k//i,n,MOD)\nfor i in range(k,0,-1):\n  for j in range(k//i,1,-1):\n    l[i]=(l[i]-l[i*j])%MOD\nans=0\nfor i,c in enumerate(l):\n  ans+=i*c\n  ans%=MOD\nprint(ans)", "mod = 10 ** 9 + 7\nN, K = map(int, input().split())\ncnt = [0 for i in range(K+1)]\nfor i in range(K, 0, -1):\n    tmp_sum = pow(K//i, N, mod)\n    for j in range(2, 10**7+1):\n        if i*j > K:\n            break\n        tmp_sum -= cnt[i*j]\n    cnt[i] = tmp_sum\nans = sum(cnt[i]*i for i in range(1,K+1)) % mod\nprint(ans)", "n, k = map(int, input().split())\n\nxs = [i for i in range(1, k + 1)]\nxs.reverse()\n\ndict_x = {}\n\nmod = 10 ** 9 + 7\n\ndef pow(x, y):\n    nonlocal mod\n    a = 1\n    b = x\n    c = y\n    while c > 0:\n        if c & 1:\n            a = (a * b) % mod\n        b = (b * b) % mod\n        c = c >> 1\n    return a\n\nanswer = 0\nfor x in xs:\n    num = k // x\n    a = pow(num, n)\n    # print(a)\n    s = 2\n    while x * s <= k:\n        a -= dict_x[x * s]\n        s += 1\n    dict_x[x] = a\n    answer = (answer + a * x) % mod\n\nprint(answer)", "n,k = map(int,input().split())\nmod = 10**9+7\nans = 0\nm = {}\nfor i in range(k,0,-1):\n  chk = pow(k//i,n,mod)\n  t = k//i\n  if t > 1:\n    for j in range(2,t+1):\n      chk -= m[i*j]\n  m[i] = chk%mod\n  ans += chk*i%mod\n  ans %= mod\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n = pow(K // k, N, mod=P)\n        for m in range(2, K // k + 1):\n            n -= n_gcd[k * m]\n        n_gcd[k] = n % P\n        ans = (ans + k * n_gcd[k]) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#from line_profiler import LineProfiler\n \nN, K = list(map(int, input().split()))\nmod = 10**9 + 7\ndef main():\n  b = N\n  blis = []\n  c = 0\n  while b >0:\n    if b & 1 == 1:\n      blis.append(c)\n    c += 1\n    b >>= 1\n\n\n  def modpow(a, blis= blis, c = c):\n    if a == 1:\n      return 1\n    else:\n      res = 1\n      li = []\n      for _ in range(c):\n        li.append(a%mod)\n        a = a*a%mod\n      for item in blis:\n        res = res *li[item] %mod\n      return res\n\n    \n  fact_count = [0 for _ in range(K+1)]\n  for k in range(1, K+1):\n    fact_count[k] = K//k\n\n  ans = 0\n  count = [0 for _ in range(K+1)]\n  for k in range(K, 0, -1):\n    x = 1*fact_count[k]\n    cc = modpow(x)\n    j = 2*k\n    l = 2\n    while(j<=K):\n      cc -= count[j]\n      l += 1\n      j = k*l\n    count[k] = cc\n    cc = cc*k%mod\n    ans += cc\n    ans %= mod\n  print(ans)\ndef __starting_point():\n  main()\n#prof = LineProfiler()\n#prof.add_function(main)\n#prof.runcall(main)\n#prof.print_stats()\n\n__starting_point()", "from math import gcd \nN,K=list(map(int,input().split()))\n\nmod=10**9+7\n\nA=[0]*K\n\nfor i in range(K,0,-1):\n    a=K//i\n    b=pow(a,N,mod)\n    A[i-1]=b\n\nfor i in range(K,0,-1):\n    for j in range(K//i-1):\n        c=i*(j+2)\n        A[i-1]-=A[c-1]\n        A[i-1]%=mod\n\ns=0\nfor i in range(K):\n    s+=A[i]*(i+1)\n    s%=mod\n\nprint(s)\n", "MOD = 10**9+7\nn, k = map(int, input().split())\ncnt = [0]*(k+1)\nfor i in range(1, k+1):\n    cnt[i] = pow(k//i, n, MOD)\n\n\ndp = [0]*(k+1)\nfor i in reversed(range(1, k+1)):\n    if not cnt[i]:\n        continue\n    tmp = cnt[i]\n    for j in range(2, k+1):\n        if k < i*j:\n            break\n        tmp -= dp[i*j]\n        tmp %= MOD\n    dp[i] = tmp\n\nans = 0\nfor i in range(1, k+1):\n    ans += i*dp[i]\n    ans %= MOD\n\nprint(ans)", "# E - Sum of gcd of Tuples (Hard)\nMOD = 10**9+7\n\ndef pow_mod(x,n):\n    if n==0:\n        return 1\n    elif n%2==0:\n        return (pow_mod((x**2)%MOD,n//2))%MOD\n    else:\n        return (x*pow_mod((x**2)%MOD,n//2))%MOD\n\nN,K = map(int,input().split())\nans = 0\nrec = [0]*(K+1)\nfor X in range(K,0,-1):\n    rec[X] = pow_mod(K//X,N)\n    for i in range(2,K//X+1):\n        rec[X] = (rec[X]-rec[i*X])%MOD\n    ans = (ans+X*rec[X])%MOD\nprint(ans)", "N, K = [int(n) for n in input().split()]\nNUM = 1000000007\n\ndef modpow(a, b): # (a ** b) % NUM\n    ans = 1\n    while b != 0:\n        if b % 2 == 1:\n            ans *= a\n            ans %= NUM\n        a = a * a\n        a %= NUM\n        b //= 2\n    return ans\n\nC = [0 for _ in range(K+1)]\nfor d in range(K):\n    k = K - d # K ... 1\n    L = K // k\n    C[k] = modpow(L, N) # A = 1*k ... L*k\n    for l in range(2, L+1):\n        C[k] -= C[l*k]\n        if C[k] < 0:\n            C[k] += NUM\n        C[k] %= NUM\n\nans = 0\nfor k in range(1, K+1):\n    ans += k * C[k]\n    ans %= NUM\nprint(ans)\n\n", "import numpy as np\nMOD = 10 ** 9 + 7\nN, K = list(map(int, input().split()))\ngcds = np.zeros((K + 1,), dtype=np.int64)\nfor n in range(K, 0, -1):\n    gcds[n] = (pow(K // n, N, MOD) - gcds[np.arange(1, K // n + 1, dtype=np.int64) * n].sum()) % MOD\nprint((gcds @ np.arange(K + 1, dtype=np.int64) % MOD))\n", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    n_multiple = [0] * (K + 1)\n    for k in range(1, K + 1):\n        n_multiple[k] = K // k\n\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n_gcd[k] = pow(n_multiple[k], N, mod=P)\n        m = 2\n        kk = k * m\n        while kk <= K:\n            n_gcd[k] = (n_gcd[k] - n_gcd[kk]) % P\n            m += 1\n            kk = k * m\n\n    ans = 0\n    for k in range(1, K + 1):\n        ans = (ans + k * n_gcd[k]) % P\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nmod = pow(10, 9) + 7\n\ndef main():\n    N, K = list(map(int, input().split()))\n    table = [0]*(K+1)\n    for k in range(K, 0, -1):\n        m = K//k\n        tmp = pow(m, N, mod)\n        for l in range(2, m+1):\n            tmp -= table[l*k]\n            tmp %= mod\n        table[k] = tmp\n\n    ans = 0\n    for i in range(len(table)):\n        ans += (i * table[i])%mod\n    ans %= mod\n    #print(table)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - Sum of gcd of Tuples (Hard)\n# https://atcoder.jp/contests/abc162/tasks/abc162_e\n\nMOD = 10 ** 9 + 7\n\nn, k = list(map(int, input().split()))\ndic = [0] * (k + 1)\n\nans = 0\nfor i in range(k, 0, -1):\n  dic[i] = pow(k // i, n, MOD)\n\nfor i in range(k, 0, -1):\n  for j in range(i * 2, k + 1, i):\n    dic[i] -= dic[j]\n    dic[i] %= MOD\n\nans = 0\nfor i in range(1, k + 1):\n  ans += dic[i] * i\n  ans %= MOD\n\nprint(ans)\n\n", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n_gcd[k] = pow(K // k, N, mod=P)\n        for m in range(2, K // k + 1):\n            n_gcd[k] -= n_gcd[k * m]\n        n_gcd[k] %= P\n        ans = (ans + k * n_gcd[k]) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN, K = MAP()\n\ngcd_cnt = [0]*(K+1)\nans = 0\nfor i in range(K, 0, -1):\n\tcnt = pow(K//i, N, mod)\n\tfor j in range(2, K//i+1):\n\t\tcnt -= gcd_cnt[j*i]\n\t\tcnt %= mod\n\tgcd_cnt[i] = cnt\n\tans += i*cnt\n\tans %= mod\n\nprint(ans)\n", "N,K=map(int,input().split())\nMOD=10**9+7\n\nB=[0 for i in range(K+1)]\nfor i in range(K+1)[::-1]:\n    if i==0: continue\n    B[i]=pow((K//i),N,MOD)\n    t=i*2\n    while t<=K:\n        B[i]-=B[t]\n        t+=i\n\nans=0\nfor i in range(K+1):\n    ans+=i*B[i]\n    ans%=MOD\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n_gcd[k] = pow(K // k, N, mod=P)\n        for m in range(2, K // k + 1):\n            n_gcd[k] = (n_gcd[k] - n_gcd[k * m]) % P\n        ans = (ans + k * n_gcd[k]) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def sumGCD(N,K,M):\n    dp = [None for _ in range(K+1)]\n    #dp[i]:gcd(A) % i == 0\u3092\u6e80\u305f\u3059A\u306e\u500b\u6570\n    for i in reversed(list(range(1,K+1))):\n        dp[i] = pow(K//i,N,M)\n        for j in range(2,K//i+1):\n            dp[i] -= dp[i*j]\n            dp[i] %= M\n\n    output = 0\n    for i in range(1,K+1):\n        output += (dp[i]*i)\n        output %= M\n\n    return output\n\ndef main():\n    N,K = list(map(int,input().split()))\n\n    print((sumGCD(N,K,10**9+7)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nlst = [0] + [pow(K // d, N, MOD) for d in range(1, K + 1)]\n\nfor d in range(K, 0, -1):\n    lst[d] -= sum(lst[d * i] for i in range(2, K // d + 1))\n\nans = 0\nfor i, x in enumerate(lst):\n    ans = (ans + i * x) % MOD\nprint(ans)\n", "MOD=10**9+7\nN,K=map(int,input().split())\nd=[0]\nd+=[pow(K//i,N,MOD) for i in range(1,K+1)]\nfor i in reversed(range(1,K+1)):\n    j=2\n    while(i*j<=K):\n        d[i]=(d[i]-d[i*j]+MOD)%MOD\n        j+=1\nans=0\nfor i in range(1,K+1):\n    ans=(ans+d[i]*i%MOD)%MOD\nprint(ans)", "\ndef solve(N, K):\n    mod = 10 ** 9 + 7\n    multiples = [[] for _ in range(K + 1)]\n    for k in range(1, K + 1):\n        for i in range(k, K + 1, k):\n            multiples[k].append(i)\n\n    gcdcounts = [0] * (K + 1)  # gcd \u6bce\u306e\u7d44\u307f\u5408\u308f\u305b\u500b\u6570\n    gcdsums = [0] * (K + 1)   # gcd \u6bce\u306e\u5408\u8a08\u5024\n    for k in reversed(list(range(1, K + 1))):\n        x = pow(len(multiples[k]), N, mod)\n        for l in multiples[k]:\n            x -= gcdcounts[l]\n        gcdcounts[k] = x % mod\n        gcdsums[k] = x * k % mod\n    print((sum(gcdsums) % mod))\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    solve(N, K)\n\n__starting_point()", "N, K = list(map(int, input().split()))\nMOD = 1_000_000_007\ngcd_cnt = [0] * (K + 1)\nfor g in range(K, 0, -1):\n    gcd_cnt[g] = pow(K // g, N, MOD)\n    for g_mul in range(2, K // g + 1):\n        gcd_cnt[g] -= gcd_cnt[g * g_mul]\n\nans = 0\nfor g, cnt in enumerate(gcd_cnt):\n    ans += g * cnt % MOD\n    ans %= MOD\nprint(ans)\n", "n,k=map(int,input().split())\nmod=10**9+7\ncount=[0]*(k+1)\ndef getnum(m):\n    ret = pow(k//m,n,mod)\n    mul=2\n    while m*mul<=k:\n        ret-=count[m*mul]\n        mul+=1\n    return ret%mod\nans=0\nfor i in range(1,k+1)[::-1]:\n    g=getnum(i)\n    count[i]=g\n    ans+=g*i\n    ans%=mod\nprint(ans)", "n, k = map(int, input().split())\nmod = 10**9+7\nans = [0]*(k+1)\nanss = 0\nfor i in reversed(range(1, k+1)):\n  ans[i] = pow(k//i, n, mod)\n  for j in range(2, k//i+1):\n    ans[i] -= ans[i*j]\n  anss += i*ans[i]\n  anss %= mod\nprint(anss)", "n,k = map(int,input().split())\nmod = 10**9+7\n\nl = [0]*(k+1)\n\nfor i in range(k,0,-1):\n  m = k//i\n  l[i] += pow(k//i,n,mod)\n  for j in range(2,m+1):\n    l[i] -= l[i*j]\n\nans = 0\nfor i in range(k+1):\n  ans += i*l[i] % mod\n  ans %= mod\nprint(ans)", "Mod = 1000000000 + 7\n\ndef fastpow(x,y):\n    ans = 1\n\n    nonlocal Mod\n    while y:\n        if (y & 1): ans = (ans * x) % Mod\n        x = (x * x) % Mod\n        y >>= 1\n    return ans\n\ndef solve(N,K):\n    # f[i] is number (x1,....xn) such that gcd(x1,..,xK) = i\n    \n    f = [0]*(K + 1)\n    for i in range(K,0,-1):\n        f[i] = fastpow(K//i,N)\n        for j in range(i + i,K + 1,i):\n            f[i] -= f[j]\n\n    nonlocal Mod\n    ans = 0\n    for i in range(1,K + 1):\n        ans = (ans + i*f[i]) % Mod\n    return ans\n\n\ndef __starting_point():\n    \n    N, K = list(map(int,input().split()))\n    print((solve(N,K)))\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\nMOD = 1000000007  # type: int\n\n\ndef solve(N: int, K: int):\n    num_gcd = {}\n    for k in range(K, 0, -1):\n        num_select = K // k\n        num_gcd_k = pow(num_select, N, MOD)\n        for multiple in range(2, num_select+1):\n            num_gcd_k -= num_gcd[k * multiple]\n        num_gcd[k] = num_gcd_k\n\n    result = 0\n    for k in range(1, K+1):\n        result += (k * num_gcd[k]) % MOD\n    print((result % MOD))\n    return\n\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    solve(N, K)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    n_multiple = [0] * (K + 1)\n    for k in range(1, K + 1):\n        n_multiple[k] = K // k\n\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n_gcd[k] = pow(n_multiple[k], N, mod=P)\n        for m in range(2, K // k + 1):\n            n_gcd[k] = (n_gcd[k] - n_gcd[k * m]) % P\n\n    ans = 0\n    for k in range(1, K + 1):\n        ans = (ans + k * n_gcd[k]) % P\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K = list(map(int, input().split()))\nmod = int(1e9+7)\nA = [0] * (K+1)\nans = 0\n\nfor i in range(K,0,-1):\n  #print(i, K//i, N, mod)\n  A[i] = pow(K//i, N, mod)\n  idx = 2*i\n  while idx <= K:\n    A[i] = (A[i] - A[idx]) % mod\n    idx += i\n  ans = (ans + A[i] * i) % mod\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(10 ** 8)\nni = lambda: int(sys.stdin.readline())\nnm = lambda: list(map(int, sys.stdin.readline().split()))\nnl = lambda: list(nm())\nns = lambda: sys.stdin.readline().rstrip()\n\nMOD = 10 ** 9 + 7\nN, K = nm()\n\n\ndef solve():\n    ans = 0\n    tbl = [0] * (K + 1)\n    for i in range(K, 0, -1):\n        m = K // i\n        p = pow(m, N, MOD)\n\n        j = 2\n        while j * i <= K:\n            p += MOD - tbl[j * i] % MOD\n            p %= MOD\n            j += 1\n        tbl[i] = p\n\n        ans += i * p % MOD\n        ans %= MOD\n    return ans\n\n\nprint((solve()))\n", "MOD = 10**9+7\nn,k = map(int,input().split())\n\nL = [0]*(k+1)\n\nfor i in range(k,0,-1):    \n  L[i] = pow(k//i,n,MOD)\n  for j in range(2,k//i+1):        \n    L[i] -= L[i*j]\n  \nans = 0\nfor i in range(1,k+1):  \n  ans = (ans + i*L[i]) % MOD\n  \nprint(ans)  ", "mod = 10**9 + 7\nn,k= [int(i) for i in input().split()]\n\nd = [0] * (k + 1)\n\nfor i in range(1,k+1):\n    d[i] = pow(k//i,n,mod)\n    \n    \nfor i in range(k,0,-1):\n    for j in range(2*i,k+1,i):\n        d[i] -= d[j]\n        d[i] %= mod\n        \nans = 0 \nfor idx,i in enumerate(d):\n    ans += (idx) * i\n    ans %= mod\n\nprint(ans)\n", "mod = 10 ** 9 + 7\nN, K = list(map(int, input().split()))\ncnt = [0 for i in range(K+1)]\nfor i in range(K, 0, -1):\n    tmp_sum = pow(K//i, N, mod)\n    for j in range(2, 10**7+1):\n        if i*j > K:\n            break\n        tmp_sum -= cnt[i*j]\n    cnt[i] = tmp_sum\nans = sum(cnt[i]*i for i in range(1,K+1)) % mod\nprint(ans)\n", "N, K = list(map(int, input().split()))\nd = [0]*(K+1)\nMOD = 10**9+7\nfor i in range(1, K+1):\n    d[i] = pow(K//i, N, MOD)\nfor i in range(K, 0, -1):\n    for j in range(2*i, K+1, i):\n        d[i] -= d[j]\n        d[i] %= MOD\nans = 0\nfor i in range(1, K+1):\n    ans += d[i]*i\n    ans %= MOD\nprint(ans)\n\n", "n,k=list(map(int,input().split()))\nm=1000000007\nans=0\ndp=[0]*(k+1) #dp[i]:=i\u3092\u6570\u5217\u5185\u306e\u6700\u5927\u5024\u3068\u3059\u308b\u3082\u306e\u306egcd\u5408\u8a08\nfor i in range(k,0,-1):\n  mul_i=k//i#i\u306e\u500d\u6570\u306e\u500b\u6570\n  dp[i]=pow(mul_i,n,m)\n  for j in range(2,mul_i+1):\n    dp[i]=(m+dp[i]-dp[i*j])%m\n  ans+=i*dp[i]%m\nans%=m\nprint(ans)\n\n\n\n\n", "N,K = map(int,input().split())\nmod = 10**9+7\nans = 0\n\ndata = [0]*(K+1)\nfor x in range(K,0,-1):\n    p = pow(K//x,N,mod)\n    for k in range(2,K//x+1):\n        p -= data[k*x]\n        p %= mod\n    data[x] = p\n    ans += x*p\n    ans %= mod\n\n###\n#print(data)\n###\n    \nprint(ans)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN, K = MAP()\n\ngcd_cnt = [0]*(K+1)\n\nfor i in range(K, 0, -1):\n\tcnt = pow(K//i, N, mod)\n\tfor j in range(2, K//i+1):\n\t\tcnt -= gcd_cnt[j*i]\n\t\tcnt %= mod\n\tgcd_cnt[i] = cnt\n\nans = 0\nfor i, x in enumerate(gcd_cnt):\n\tans += i*x\n\tans %= mod\n\nprint(ans)\n", "n, k = list(map(int, input().split()))\nMOD = 1000000007\ncnt = [0] * (k + 1)\nfor i in range(1, k + 1):\n    cnt[i] = pow(k // i, n, MOD)\n\nfor i in range(k, 0, -1):\n    j = i * 2\n    while j <= k:\n        cnt[i] = (MOD + cnt[i] - cnt[j]) % MOD\n        j += i\nans = 0\nfor i in range(1, k + 1):\n    ans = (ans + cnt[i] * i) % MOD\nprint(ans)\n\n", "MOD=10**9 + 7\nn,k=map(int,input().split())\nmp = [0]*(k+1)\nfor i in range(k,0,-1):\n    mp[i]=pow(k//i,n,MOD)\n    t=2\n    while i*t<=k:\n        mp[i]-=mp[t*i]\n        t+=1\nans=0\nfor i in range(1,k+1):\n    ans += i * mp[i]\nprint(ans % MOD)", "MOD = 10**9 + 7\nn, k = map(int, input().split())\nd = [0] + [pow(k // i, n, MOD) for i in range(1, k + 1)]\nfor i in range(k, 0, -1):\n    for j in range(2*i, k + 1, i):\n        d[i] -= d[j]\n        d[i] %= MOD\nprint(sum(i * d[i] % MOD for i in range(1, k + 1)) % MOD)", "\nmod = 1000000007\nn,k = map(int, input().split())\nd = [0]*(k+1)\nfor i in range(1,k+1):\n    d[i] = pow(k//i, n, mod)\nfor i in range(k,0,-1):\n    for j in range(2*i, k+1, i):\n        d[i] -= d[j]\n        d[i] %= mod\nans = 0\nfor i in range(1,k+1):\n    ans += d[i]*i\n    ans %= mod\nprint(ans)", "N, K = map( int, input().split() )\nmod = 10 ** 9 + 7\nCnt = [ 0 ] * ( K + 1 )\n\nfor i in range( K, 0, -1 ):\n  elem_cnt = K // i\n  i_s_cnt = pow( elem_cnt, N, mod)\n  for j in range( 2, elem_cnt + 1 ):\n    i_s_cnt -= Cnt[ i * j ]\n  Cnt[ i ] = i_s_cnt\n\ncnt = 0\nfor i , c in enumerate( Cnt ):\n  cnt += i * c\n  cnt = cnt % mod \n\nprint( cnt )", "MOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\n\nnums = [0] * (K+1)\nfor i in reversed(list(range(1, K+1))):\n    num = pow(K//i, N, MOD)\n    for j in range(2*i, K+1, i):\n        num -= nums[j]\n    nums[i] = num % MOD\n\nans = 0\nfor i in range(1, K+1):\n    ans += i * nums[i] % MOD\n    ans %= MOD\n\nprint(ans)\n", "n, k = map(int, input().split())\n\ns = [0] * (k + 1)\nans = 0\n\nfor i in range(k, 0, -1):\n    s[i] += pow(int(k / i), n, int(1e9 + 7))\n    s[i] %= 1e9 + 7\n    for j in range(i * 2, k + 1, i):\n        s[i] += 1e9 + 7\n        s[i] -= s[j]\n        s[i] %= 1e9 + 7\n\nfor i in range(1, k+1):\n    ans += i * s[i]\n    ans %= 1e9 + 7\n\nans %= 1e9+7\n\nprint(int(ans))", "N, K = map(int,input().split())\nMOD = 10**9+7\nls = [0]*(K+1) #\u500b\u6570\nfor i in range(1, K+1)[::-1]:\n  ls[i] =  pow(K // i, N, MOD)\n  if K // i != 1:\n    a = K // i\n    for j in range(2, a+1):\n      ls[i] -= ls[i*j]  \n    \nans = 0\nfor i in range(1, K+1):\n  ans += i * ls[i]\n  ans %= MOD  \nprint(ans) ", "N, K = list(map(int, input().split()))\nmod = 10**9 + 7\ncnt = [0]*(K+1)\nans = 0\nfor g in range(K, 0, -1):\n    sub = sum(cnt[2*g:K+1:g])\n    q = pow(K//g, N, mod) - sub\n    ans = (ans + g * q) % mod\n    cnt[g] = q\nprint(ans)\n", "def left_bin(a, n, c):\n    ns = [int(i) for i in bin(n)[3:]]\n    t = a\n    for i in ns:\n        t = t*t % c\n        if i == 1:\n            t = t*a % c\n    return t\n\n\nn, k = list(map(int, input().split()))\nc = 10**9+7\ntm = [0] + [1]*k\na = k//2\nans = k*(k+1)//2 - a*(a+1)//2\nfor i in range(k//2, 0, -1):\n    a = k//i\n    t = (left_bin(a, n, c) - sum([tm[j*i] for j in range(2, a+1)])) % c\n    ans = (ans + t*i) % c\n    tm[i] = t\nprint(ans)\n", "import math\nfrom collections import defaultdict\n\nN,K = list(map(int,input().split()))\nmod = 10**9+7\nDP = [0]*(K+1)  #DP[i]:gcd=i\u3068\u306a\u308b\u6570\u5217\u306e\u500b\u6570\nans = 0\n\nfor i in range(K,0,-1):\n    m = K//i    #m:i\u306e\u500d\u6570\u306e\u500b\u6570\n    DP[i] = pow(m,N,mod)\n    for j in range(2,m+1):\n        DP[i] -= DP[i*j]\n    ans += (DP[i]*i) % mod\n    ans %= mod\n\nprint(ans)\n", "N, K = list(map(int, input().split()))\nmod = 10**9 + 7\n\n  \nfact_count = [0 for _ in range(K+1)]\nfor k in range(1, K+1):\n  fact_count[k] = K//k\n\nans = 0\ncount = [0 for _ in range(K+1)]\nfor k in range(K, 0, -1):\n  c = pow(fact_count[k], N, mod)\n  j = 2*k\n  l = 2\n  while(j<=K):\n    c -= count[j]\n    l += 1\n    j = k*l\n  count[k] = c\n  c = c*k%mod\n  ans += c\n  ans %= mod\nprint(ans)\n\n", "#%%\nN, K = list(map(int,input().split()))\nMOD = 10**9 + 7\n\n\n#%%\nans = 0\ngcds = [0]*(K+1)\nfor i in reversed(list(range(1, K+1))):\n    gcds[i] = pow(K//i, N, MOD)\n    idx = i*2\n    while idx<K+1:\n        gcds[i] -= gcds[idx] + MOD\n        gcds[i] %= MOD\n        idx += i\n    ans += (i * gcds[i])\n    ans %= MOD\n\n\nprint(ans)\n\n", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n = pow(K // k, N, mod=P)\n        for kk in range(2 * k, K + 1, k):\n            n -= n_gcd[kk]\n        n_gcd[k] = n % P\n        ans = (ans + k * n_gcd[k]) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 10**9 + 7\nn, k = map(int,input().split())\ncnt = [0]*(k+1)\n\nfor i in range(k, 0, -1):\n  cnt[i]+=pow(k//i,n,mod)\n  for j in range(2, k//i+1):\n    cnt[i]-=cnt[i*j]\nans = 0\nfor i in range(1, k+1):\n  ans+=i*(cnt[i])%mod\n  ans%=mod\n  \nprint(ans)", "n, k = map(int, input().split())\nMOD = 10 ** 9 + 7\nd = [0] * (k + 1)\n\nfor i in range(1, k + 1):\n    d[i] = pow(k // i, n, MOD)\n\nfor i in range(k, 0, -1):\n    for j in range(i * 2, k + 1, i):\n        d[i] -= d[j]\n        d[i] %= MOD\n\nans = 0\nfor i in range(1, k + 1):\n    ans += d[i] * i\n    ans %= MOD\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = dict.fromkeys(list(range(K + 1)), 0)\n    for k in reversed(list(range(1, K + 1))):\n        n_gcd[k] = pow(K // k, N, mod=P)\n        for m in range(2, K // k + 1):\n            n_gcd[k] = (n_gcd[k] - n_gcd[k * m]) % P\n        ans = (ans + k * n_gcd[k]) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = [int(i) for i in input().split()]\nMOD = 10**9 + 7\n\nclass ModInt:\n    def __init__(self, x):\n        self.x = x % MOD\n\n    def __str__(self):\n        return str(self.x)\n\n    __repr__ = __str__\n\n    def __add__(self, other):\n        return (\n            ModInt(self.x + other.x) if isinstance(other, ModInt) else\n            ModInt(self.x + other)\n        )\n\n    def __sub__(self, other):\n        return (\n            ModInt(self.x - other.x) if isinstance(other, ModInt) else\n            ModInt(self.x - other)\n        )\n\n    def __mul__(self, other):\n        return (\n            ModInt(self.x * other.x) if isinstance(other, ModInt) else\n            ModInt(self.x * other)\n        )\n\n    def __truediv__(self, other):\n        return (\n            ModInt(\n                self.x * pow(other.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(self.x * pow(other, MOD - 2, MOD))\n        )\n\n    def __pow__(self, other):\n        return (\n            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(self.x, other, MOD))\n        )\n\n    __radd__ = __add__\n\n    def __rsub__(self, other):\n        return (\n            ModInt(other.x - self.x) if isinstance(other, ModInt) else\n            ModInt(other - self.x)\n        )\n\n    __rmul__ = __mul__\n\n    def __rtruediv__(self, other):\n        return (\n            ModInt(\n                other.x * pow(self.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(other * pow(self.x, MOD - 2, MOD))\n        )\n\n    def __rpow__(self, other):\n        return (\n            ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(other, self.x, MOD))\n        )\n\n\nmemo = [-1] * K\ndef count(k):\n    if(memo[k-1] != -1):\n        return memo[k-1]\n    \n    if(k > K//2):\n        memo[k-1] = ModInt(1)\n        return memo[k-1]\n    \n    res = ModInt(K//k) ** N\n    for i in range(2, K//k + 1):\n        res -= count(i * k)\n\n    memo[k-1] = res\n    return res\n\nans = 0\nfor k in range(K, 0, -1):\n    ans += count(k) * k\nprint(ans)", "n,k=map(int,input().split())\nm=10**9+7\nl=[0]*(k+1)\na=0\nfor i in range(k,0,-1):\n l[i]=pow(k//i,n,m)\n for j in range(2,k//i+1):l[i]-=l[i*j]\n a+=i*l[i]\n a%=m\nprint(a)", "n,k=map(int,input().split())\nnum=[0]*k\nans=0\n\ndef njo(arg,n):\n  if n==0:\n    return 1\n  elif n%2==0:\n    return njo((arg**2)%1000000007,n//2)\n  else:\n    return arg*njo((arg**2)%1000000007,n//2)\n\nfor i in range(k):\n  test=k-i\n  num[test-1]=njo(k//test,n)\n  mul=test*2\n  while mul<=k:\n    num[test-1]-=num[mul-1]\n    mul+=test\n\n  ans+=num[test-1]*test\n  \nwhile ans<0:\n  ans+=1000000007\nprint(str(ans%1000000007))", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n\n    ans = 0\n    n_gcd = [0] * (K + 1)\n    for k in reversed(list(range(1, K + 1))):\n        n = pow(K // k, N, mod=P)\n        for kk in range(2 * k, K + 1, k):\n            n -= n_gcd[kk]\n        n_gcd[k] = n % P\n        ans += k * n_gcd[k]\n        ans %= P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n#from collections import defaultdict\n#d = defaultdict(int)\n#import fractions\n#import math\n#import collections\n#from collections import deque\n#from bisect import bisect_left\n#from bisect import insort_left\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [input() for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\n#import itertools\n#import heapq\n#import numpy as np\n#INF = float(\"inf\")\n#MOD = 10**9+7\nMOD = 10**9+7\nimport math\nN,K = map(int,input().split())\nans = [0]*K\nfor i in range(K):\n    p = K-i\n    a = pow(math.floor(K/p),N,MOD)\n    x = 1\n    while p*(x+1) <= K:\n        a -= ans[p*(x+1)-1]\n        x = x+1\n    ans[p-1] = a%MOD\ns = 0\nfor i in range(K):\n    s += (i+1)*ans[i]\n    s = s%MOD\nprint(s)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nN, K = map(int, input().split())\n\nlst = [0] * (K + 1)\n\nfor i in range(K, 0, -1):\n    a = K // i\n    tmp = pow(a, N, MOD)\n    for j in range(i + i, K + 1, i):\n        tmp -= lst[j]\n    lst[i] = tmp\n\nans = 0\nfor i in range(K + 1):\n    ans += i * lst[i]\n    ans %= MOD\n\nprint (ans)", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, k = map(int, input().split())\n    mod = 10 ** 9+ 7\n    table = [0]*(k+1)\n    ans= 0\n    for i in range(k, 0, -1):\n        table[i] = pow(k//i, n, mod)\n        j = 2\n        while i*j <= k:\n            table[i] -= table[i*j]\n            table[i] %= mod\n            j += 1\n        ans += i*table[i]\n        ans %= mod\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k = map(int,input().split())\nmod = 1000000007\ncnt = [0]*(k+1)\nfor i in range(1,k+1)[::-1]:\n    cnt[i] = pow(k//i,n,mod)\n    for j in range(2*i,k+1,i):\n        cnt[i] -= cnt[j]\n        cnt[i] %= mod\nans = 0\nfor i in range(1,k+1):\n    ans += cnt[i]*i\n    ans %= mod\nprint(ans)", "MOD = 10 ** 9 + 7\n\nn, k = map(int, input().split())\n\ndivisor_lst = [i - 1 for i in range(1, k + 1)]\ndivisor_lst[0] = 1\n\nfor i in range(2, k):\n    for j in range(2 * i, k + 1, i):\n        divisor_lst[j - 1] -= divisor_lst[i - 1]\n\nans = 0\nfor num in range(1, k + 1):\n    ans += pow(k // num, n, MOD) * divisor_lst[num - 1]\n    ans %= MOD\nprint(ans)", "mod=10**9+7    \nn,k=map(int,input().split())\ncnt=[0]*(k+1) \nfor i in range(k,0,-1): \n   cnt[i]+=pow(k//i,n,mod)\n   for j in range(2,k//i+1):\n     cnt[i]-=cnt[i*j]\nans=0\nfor i in range(1,k+1):\n   ans+=i*(cnt[i])%mod \n   ans%=mod\nprint(ans)", "N, K = list(map(int, input().split()))\nMOD = 10**9 + 7\nmemo = {}\n\n\ndef a(n):\n    if n in memo:\n        return memo[n]\n    else:\n        ret = pow(n, N, MOD)\n        for i in range(2, n+1):\n            ret -= a(n//i)\n        memo[n] = ret\n        return ret\n\n\nans = 0\nfor i in range(1, K+1):\n    ans += i*a(K//i)\n    ans %= MOD\nprint(ans)\n", "N, K = [int(_) for _ in input().split()]\nmod = 10**9 + 7\nA = [0] * (K + 1)\nfor i in range(K, 0, -1):\n    A[i] = pow(K // i, N, mod)\n    for j in range(2, K // i + 1):\n        A[i] -= A[i * j]\n        A[i] %= mod\nprint((sum(i * a for i, a in enumerate(A)) % mod))\n", "mod = 1000000007\nn, k = map(int, input().split())\n\nd = [0] * (k + 1)\n\nfor i in range(1, k + 1):\n    d[i] = pow(k//i, n, mod)\n\nfor i in range(k, 0, -1):\n    for j in range(2*i, k + 1, i):\n        d[i] -= d[j]\n        d[i] %= mod\n\nans = 0\nfor i in range(i, k+1):\n    ans += d[i] * i\n\nans %= mod\nprint (ans)", "# \u89e3\u8aacAC\nmod = 10 ** 9 + 7\nn, k = list(map(int, input().split()))\ndp = [-1] * (k + 1)\nans = 0\nfor i in range(k, 0, -1):\n    dp[i] = pow(k // i, n, mod)\n    t = 0\n    t += 2 * i\n    while t <= k:\n        dp[i] -= dp[t]\n        dp[i] %= mod\n        t += i\n    ans += i * dp[i]\n    ans %= mod\nprint(ans)\n", "N,K=map(int,input().split())\nm=10**9+7\nd=[0]*K\nfor k in range(K,0,-1):\n    d[k-1]=pow(K//k,N,m)\n    for l in range(2*k,K+1,k):\n        d[k-1]=(d[k-1]-d[l-1])%m\nprint(sum([(k+1)*d[k]%m for k in range(K)])%m)", "n, k = list(map(int, input().split()))\n\nmod = 10**9 + 7\ncnt = [0]*(k + 1)\nans = 0\nfor i in range(k, 0, -1):\n    cnt[i] = (pow(k//i, n, mod) - sum(cnt[2*i:k+1:i])) % mod\n    ans = (ans + i*cnt[i]) % mod\n\nprint(ans)\n", "\ndef resolve():\n    MOD = 10**9+7\n    N, K = map(int, input().split())\n    cnt = [0]*(K+1)\n\n    for g in range(K, 0, -1):\n        cnt[g] = pow(K//g, N, MOD) # (K//g)**N\n        gg = g*2\n        while gg <= K:\n            cnt[g] -= cnt[gg]\n            gg += g\n    ans = 0\n    for g in range(1, K+1):\n        ans += cnt[g] * g\n        ans %= MOD\n    print(ans)    \n\ndef __starting_point():\n    resolve()\n__starting_point()", "Q = 10**9+7\ndef main():\n    N, K = list(map( int, input().split()))\n    ANS = [0]*(K+1)\n    for x in range(K,0,-1):\n        ans = pow(K//x,N,Q)\n        for i in range(2, K+1):\n            if x*i > K:\n                break\n            ans -= ANS[x*i]\n        ANS[x] = ans%Q\n    print(( sum( [ANS[i]*i%Q for i in range(K+1)])%Q))\n        \ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport os\n\ndef file_input():\n    f = open('Beginner_Contest_162/input.txt', 'r')\n    sys.stdin = f\n\ndef main():\n    #file_input()\n\n    N,K=list(map(int, input().split()))   #K\u4ee5\u4e0b\u3001N\u306e\u9577\u3055\n\n    tmp=[0]*(K+1)\n    mod=10**9+7\n    out=0\n\n    for i in range(K,0,-1):\n        tmp[i]=pow(K//i,N,mod)  #i\u306e\u500d\u6570\u306fK/i\u500b\u3042\u308b\u3002\u305d\u308c\u304cN\u500b\u4e26\u3093\u3067\u3044\u308b\n        for j in range(i*2,K+1,i):\n            tmp[i]-=tmp[j]\n        out+=tmp[i]*i\n\n    print((out%mod))\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 5*10**5\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * 2\n        for idx in range(2, max_fact + 1):\n            f += [f[idx - 1] * idx % mod]\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 5 * 10**5\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "import sys\nimport math\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n\n    MOD = 10 ** 9 + 7\n\n    fact = [1, 1]\n    factinv = [1, 1]\n    inv = [0, 1]\n\n    def cmb(n, k, p):\n        if (k < 0) or (n < k):\n            return 0\n        r = min(k, n - k)\n        return fact[n] * factinv[k] * factinv[n - k] % p\n\n    for i in range(2, 10 ** 6 + 1):\n        fact.append((fact[-1] * i) % MOD)\n        inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n        factinv.append((factinv[-1] * inv[-1]) % MOD)\n\n    X = fact[M] * factinv[M - N]\n\n    ans = 0\n    for i in range(N + 1):\n        c = fact[M - i] * factinv[(M - i) - (N - i)]\n        if i % 2 == 0:\n            ans += X * c * cmb(N, i, MOD)\n        else:\n            ans -= X * c * cmb(N, i, MOD)\n\n        ans %= MOD\n\n    print((ans % MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    import os\n    import re\n    with open(__file__) as f:\n        source = f.read().split('###''nbacl')\n    for s in source[1:]:\n        s = re.sub(\"'''.*\", '', s)\n        sp = s.split(maxsplit=1)\n        if os.path.dirname(sp[0]):\n            os.makedirs(os.path.dirname(sp[0]), exist_ok=True)\n        with open(sp[0], 'w') as f:\n            f.write(sp[1])\n    from nbmodule import cc\n    cc.compile()\nfrom nbmodule import solve\n\nN, M = [int(x) for x in input().split()]\nans = solve(N, M)\nprint(ans)\n'''\n###nbacl nbmodule.py\nimport numpy as np\nfrom numpy import int64\nfrom numba import njit\nfrom numba.types import i8\nfrom numba.pycc import CC\n\ncc = CC('nbmodule')\nMOD = 1000000007\n\n\n@njit\ndef inv_mod(x, mod):\n    old_t, t = 0, 1\n    old_r, r = mod, x\n\n    while r != 0:\n        quotient = old_r // r\n\n        old_r, r = r, old_r - quotient * r\n        old_t, t = t, old_t - quotient * t\n\n    return old_t % mod\n\n\n@njit\ndef calc_fac(fac):\n    fac[0] = 1\n    for i in range(1, fac.shape[0]):\n        fac[i] = fac[i - 1] * i % MOD\n\n\n@njit\ndef calc_inv_fac(inv_fac):\n    inv_fac[0] = 1\n    for i in range(1, inv_fac.shape[0]):\n        inv_fac[i] = inv_fac[i - 1] * inv_mod(i, MOD) % MOD\n\n\n@njit((i8, i8), cache=True)\n@cc.export('solve', (i8, i8))\ndef solve(N, M):\n    fac = np.empty(M + 1, dtype=int64)\n    inv_fac = np.empty(M + 1, dtype=int64)\n\n    def p(m, n):\n        return fac[m] * inv_fac[m - n] % MOD\n    def c(m, n):\n        return fac[m] * inv_fac[n] % MOD * inv_fac[m - n] % MOD\n\n    calc_fac(fac)\n    calc_inv_fac(inv_fac)\n\n    ret = 0\n    for r in range(N + 1):\n        if r & 1:\n            ret = (ret - c(N, r) * p(M - r, N - r)) % MOD\n        else:\n            ret = (ret + c(N, r) * p(M - r, N - r)) % MOD\n    return ret * p(M, N) % MOD\n\n\ndef __starting_point():\n    cc.compile()\n\n'''\n\n__starting_point()", "N, M = map(int, input().split())\nmod = 10 ** 9 + 7\n\ndef calc(n):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= mod\n        factorials.append(f)\n    inv = pow(f, mod - 2, mod)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= mod\n        invs[m - 1] = inv\n    return factorials, invs\n\nfactorials, invs = calc(M)\nmPn = (factorials[M] * invs[M - N]) % mod\nans = (mPn * mPn) % mod\nfor k in range(1, N + 1):\n    v = pow(-1, k - 1) * factorials[N] * factorials[M - k] * invs[N - k] * invs[k] * invs[M - N] % mod\n    ans -= v * mPn\nprint(ans % mod)", "def prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n        \n\nN, M = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nmodFacts, invs = prepare(max(N, M))\n\nans = 0\nfor i in range(N + 1):\n    Ti = (modFacts[N] * invs[i] * invs[N - i]) % MOD\n    Ti *= (modFacts[M] * invs[M - i]) % MOD\n    Ti %= MOD\n    Ti *= pow(modFacts[M - i] * invs[(M - i) - (N - i)], 2, MOD)\n    Ti %= MOD\n    ans += pow(-1, i) * Ti\n    ans %= MOD\n\nprint(ans)", "n, m = map(int,input().split())\nmod = 10**9 + 7\n\ndef cmb(n, r, mod):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%mod\n\nN = 10**6  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%mod)\n\tinv.append((-inv[mod%i]*(mod//i))%mod)\n\tfactinv.append((factinv[-1]*inv[-1])%mod)\n\n\"\"\"\n1\u3064\u5f53\u305f\u3063\u3066\u3044\u308b\u2192Free\u306fn-1\u500b\u2192m-1 C n-1\n\u540c\u69d8\u306b2\u3064\u2192m-2 C n-2\n\u6570\u306f\uff1f\u2192 n C 2\n\u5305\u9664\u539f\u7406\n\"\"\"\nmode = -1\nans = 0\nfor i in range(n+1):\n\tmode = -mode\n\tans = (ans + mode * cmb(n, i, mod) * cmb(m-i, n-i, mod) * fact[n-i]) % mod\nprint(ans * cmb(m, n, mod) * fact[n] % mod)", "n,m=map(int,input().split())\nmod=10**9+7\nfact=[1]*(m+1)\ninv=[1]*(m+1)\nfor i in range(2,m+1):\n    fact[i]=i*fact[i-1]%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(m,1,-1):\n    inv[i-1]=inv[i]*i%mod\ndef comb(x,y):return fact[x]*inv[y]%mod*inv[x-y]%mod if x>=y>=0 else 0\ndef p(x,y):return fact[x]*inv[x-y]%mod if x>=y>=0 else 0\nans=p(m,n)**2%mod\na=-1\nfor i in range(1,n+1):\n    ans=(ans+a*(p(m,i)*comb(n,i)*p(m-i,n-i)**2%mod))%mod\n    a*=-1\nprint(ans)", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nPr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[n - r] % self.mod\n\nMOD = 10**9+7\ndef resolve():\n    N, M = list(map(int, input().split()))\n    cmb = Combination(5 * 10**5)\n\n    ans = 0\n    for p in range(N+1):\n        ans += (-1)**p * cmb.nCr(N, p) * cmb.nPr(M-p, N-p)\n        ans %= MOD\n\n    ans *= cmb.nPr(M, N)\n    ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,m=list(map(int,input().split()))\nmod=pow(10,9)+7\n# n<=m\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u3001\u3055\u3089\u306b\u9ad8\u901f\u3002\u3042\u3089\u304b\u3058\u3081O(N)\u306e\u8a08\u7b97\u3092\u3059\u308b\u3053\u3068\u3067\u306e\u3061\u306e\u8a08\u7b97\u304c\u65e9\u304f\u306a\u308b\ndef cmb(n,r,mod):\n  if (r<0 or r>n):\n    return 0\n  r=min(r,n-r)\n  return g1[n]*g2[r]*g2[n-r]%mod\ng1=[1,1] # g1[i]=i! % mod\ng2=[1,1] # g2[i]=(i!)^(-1) % mod\ninverse=[0,1]\nfor i in range(2,m+1):\n  g1.append((g1[-1]*i)%mod)\n  inverse.append((-inverse[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inverse[-1])%mod)\n\n# \u6570\u5217a\u306e\u4f5c\u308a\u65b9\nans_a=g1[m]*g2[m-n]\n\n# \u6570\u5217b\u306e\u4f5c\u308a\u65b9\nans_b=0\nfor i in range(n+1):\n  tmp=cmb(n,i,mod)\n  tmp*=(g1[m-i]*g2[m-n])%mod\n  tmp%=mod\n  ans_b+=tmp*(-1)**i\n  ans_b%=mod\n  #print(i,tmp,ans_b)\n\nprint(((ans_a*ans_b)%mod))\n#print(ans_a,ans_b)\n\n", "'''\nLet g(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u6700\u591a x \u500b\u4f4d\u7f6e\u4e0d\u540c\u3002\nLet f(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u7d66\u5b9a x \u500b\u4f4d\u7f6e\u6642\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u3002\n\n\u984c\u76ee\u6240\u6c42\u662f C(N, N) f(N)\u3002\n\n\u5176\u4e2d g(x) \u4ee3\u8868\u6709\u81f3\u5c11 N - x \u500b\u4f4d\u7f6e\u662f\u76f8\u540c\u3002\u53ef\u4ee5\u5206\u4e09\u500b\u90e8\u4efd\u586b\u6578\u5b57\uff0c\u6ce8\u610f\u9806\u5e8f\u6703\u5f71\u97ff\uff0c\u6240\u4ee5\u8981\u4e58\u4e0a\u5168\u6392\u5e8f\uff1a\n(1) N - x \u500b\u4f4d\u7f6e\uff08\u6578\u5b57\u5fc5\u9700\u76f8\u540c\uff09\uff1aC(M, N - x) * (N - x)! = P(M, N - x)\n(2) \u5e8f\u5217 A \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\n(3) \u5e8f\u5217 B \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\ng(x) = (1) * (2) * (3)\n\ng(x) \u662f\u300c\u9078\u5b9a 0 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u300c\u9078\u5b9a 1 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u2026\u3001\u300c\u9078\u5b9a N \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\uff0c\u5373\n\ng(x) = C(x, 0) f(0) + C(x, 1) f(1) + ... + C(x, x) f(x)\n     = sum( C(x, i) * f(i) for i in [0, x] )\n\u6839\u64da\u4e8c\u9805\u5f0f\u53cd\u6f14\uff0c\u5f97\u5230\nf(x) = sum( (-1) ** (x - i) * C(x, i) * g(i) for i in [0, x] )\n'''\n\nclass CombMod:\n    def __init__(self, V, p):\n        self.fact = [1] * V\n        self.finv = [1] * V\n        for i in range(1, V):\n            self.fact[i] = self.fact[i - 1] * i % p\n        self.finv[-1] = pow(self.fact[-1], p - 2, p)\n        for i in range(V - 2, 0, -1):\n            self.finv[i] = self.finv[i + 1] * (i + 1) % p\n        self.p = p\n        \n    def fact(self, a):\n        return self.fact[a]\n    \n    def finv(self, a):\n        return self.finv[a]\n\n    def comb(self, a, b):\n        return self.fact[a] * self.finv[b] % self.p * self.finv[a - b] % self.p\n        \n    def perm(self, a, b):\n        return self.fact[a] * self.finv[a - b] % self.p\n    \n    def hcomb(self, a, b):\n        return self.comb(a + b - 1, b)\n\n\nN, M = list(map(int, input().split()))\nmod = 10**9 + 7\ntool = CombMod(max(N, M) + 10, mod)\n\nans = 0\nfor i in range(0, N + 1):\n    p1 = tool.perm(M, N - i)\n    p2 = tool.perm(M - (N - i), i)\n    g_i = p1 * p2 % mod * p2 % mod\n    val = pow(-1, N - i, mod) * tool.comb(N, i) % mod * g_i % mod\n    ans = (ans + val) % mod\nprint(ans)\n", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 5 * 10**5\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "n,m=map(int,input().split())\na,M,d=1,10**9+7,[1]*(n+1)\nfor i in range(n):\n  d[i+1]=((m-n+i)*d[i]+i*d[i-1])%M\n  a=a*(m-i)%M\nprint(a*d[-1]%M)", "#atcoder template\ndef main():\n    import sys\n    imput = sys.stdin.readline\n    if sys.argv[-1] == 'ONLINE_JUDGE':\n        import numba\n        from numba.pycc import CC\n        i8 = numba.int64\n        cc = CC('my_module')\n \n        def cc_export(f, signature):\n            cc.export(f.__name__, signature)(f)\n            return numba.njit(f)\n \n            fact_table = cc_export(fact_table, (i8, i8))\n            main = cc_export(main, (i8, i8, i8))\n            cc.compile()\n\n    #\u6587\u5b57\u5217\u5165\u529b\u306e\u6642\u306f\u4e0a\u8a18\u306ferror\u3068\u306a\u308b\u3002\n    #\u3053\u3053\u306b\u30b3\u30fc\u30c9\n    #input\n    n, m = list(map(int, input().split()))\n\n    #output\n    mod = pow(10, 9) + 7\n\n    n_ = 5 * pow(10, 5) + 5\n    fun = [1] * (n_+1)\n    for i in range(1, n_+1):\n        fun[i] = fun[i-1] * i % mod\n    rev = [1] * (n_+1)\n    rev[n_] = pow(fun[n_], mod-2, mod)\n    for i in range(n_-1, 0, -1):\n        rev[i] = rev[i+1] * (i+1) % mod\n    def cmb(n,r):\n        if n < 0 or r < 0 or r > n: return 0\n        return fun[n] * rev[r] % mod * rev[n-r] % mod\n    def perm(n, r):\n        if n < 0 or r < 0 or r > n: return 0\n        return fun[n] * rev[n-r] % mod\n\n    #A\u30921, 2, ..., n\u3068\u3059\u308b\u3002\n    #\u6c42\u3081\u308b\u5199\u50cf\u306e\u7dcf\u6570\u3092s(n, m)\u3068\u3059\u308b\u3002\n    #s(n, m) = sum(k=0, n)(cmb(n, k)* (-1)^k * cmb(m-k, n-k)*(n-k)!)\n\n    import math\n    answer = 0\n    for i in range(n+1):\n        temp = perm(n, i) * cmb(m, i) * pow(perm(m-i, n-i), 2)\n        temp %= mod\n        if i % 2 == 0:\n            answer += temp\n        else:\n            answer -= temp\n    print((answer % mod))\n\n    #N = 1\u306e\u3068\u304d\u306a\u3069corner case\u3092\u78ba\u8a8d\uff01\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\nmod = 10**9+7\nnums = 5*(10**5) # \u5236\u7d04\u306b\u5408\u308f\u305b\u3088\u3046\n\ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n    \ndef nPr(n, r):\n    return g1[n] * g2[n-r] % mod\n\ndef nCr(n, r):\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nans = 0\nfor r in range(n+1):\n    tmp = nCr(n, r)*nPr(m, r)*(nPr(m-r, n-r)**2)%mod\n    ans = (ans+(-1)**r*tmp)%mod\nprint(ans)", "# E - NEQ\nimport sys\nsys.setrecursionlimit(10**6)\nMOD = 10**9+7\nmon_l = dict({})\n\ndef mon(m,n):\n    if (m,n) in mon_l:\n        return mon_l[(m,n)]\n    if n==1:\n        mon_l[(m,n)] = m-1\n        return mon_l[(m,n)]\n    if n==2:\n        mon_l[(m,n)] = ((m-1)+(m-2)**2)%MOD\n        return mon_l[(m,n)]\n    else:\n        mon_l[(m,n)] = ((n-1)*(mon(m-1,n-1)+mon(m-2,n-2)) + (m-n)*mon(m-1,n-1))%MOD\n        return mon_l[(m,n)]\n    \ndef permu(m,n):\n    ans = 1\n    for _ in range(n):\n        ans = m*ans%MOD\n        m -= 1\n    return ans\n\nN,M = map(int,input().split())\nans = permu(M,N)*mon(M,N)%MOD\nprint(ans)", "max_fact = 5 * 10**5\nmod = 10**9 + 7\n\nf = [1] * (max_fact + 1)\nfor idx in range(2, max_fact + 1):\n    f[idx] = f[idx - 1] * idx\n    f[idx] %= mod\nfi = [pow(f[-1], mod - 2, mod)]\nfor idx in range(max_fact, 0, -1):\n    fi += [fi[-1] * idx % mod]\nfi = fi[::-1]\n\ndef factorial(n):\n    return f[n]\n\ndef factorial_inverse(n):\n    return fi[n]\n\ndef combination(n, r):\n    return f[n] * fi[r] * fi[n - r] % mod\n\ndef permutation(n, r):\n    return f[n] * fi[n - r] % mod\n\ndef homogeneous_product(n, r):\n    return f[n + r - 1] * fi[r] * fi[n - 1] % mod\n\n\ncomb = combination\nperm = permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "M=10**9+7\nn,m=map(int,input().split())\nF=[1]\nfor i in range(1,m+1): F+=[i*F[-1]%M]\na=0\nfor k in range(n+1):\n  a+=(-1)**k*F[m-k]*pow(F[k]*F[n-k],-1,M)%M\nprint(a*F[n]*F[m]*pow(F[m-n]**2,-1,M)%M)", "N, M = map(int, input().split())\n\nmod = 10 ** 9 + 7\n#L = 5 * 10**5\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\ndef comb(n, r):\n  return fac[n] * ( finv[r] * finv[n-r] % mod ) % mod\n\ndef perm(n, r):\n  return  fac[n] * finv[n-r] % mod\n \nfor i in range(2, M + 1):\n  fac.append( ( fac[-1] * i ) % mod )\n  inv.append( mod - ( inv[mod % i] * (mod // i) % mod ) )\n  finv.append( finv[-1] * inv[-1]  % mod )\n\nans = 0\n\nfor K in range(N+1):\n  ans += comb(N, K) * (-1)**(K%2) % mod * perm(M, K) % mod * pow(perm(M-K, N-K), 2, mod)\n  ans %= mod\n\nprint(ans)", "n,m=map(int,input().split())\ni,a,b=0,1,0\nwhile i<n:c=((m-i)*((m-n+i)*a+i*b*(m-i+1)))%(10**9+7);i+=1;a,b=c,a\nprint(a)", "n,m=list(map(int,input().split()))\nd=[1]*(n+1)\nfor i in range(n):\n  d[i+1]=((m-i)*((m-n+i)*d[i]+i*d[i-1]*(m-i+1)))%(10**9+7)\nprint((d[-1]))\n", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nfrom functools import reduce\n\n\nN = 10**6\nmod = 10**9+7\n\ninv_t = [0] + [1]\nfor i in range(2, N):\n    inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]\n\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n    kai.append(kai[-1] * i % mod)\n    rev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\ndef cmb(n, r):\n    return kai[n] * rev_kai[r] * rev_kai[n - r] % mod\n\ndef prm(n, r):\n    return kai[n] * rev_kai[n - r] % mod\n\nn,m = list(map(int, input().split()))\n\na = 0\nfor k in range(n+1):\n    a += prm(m, k)*prm(m-k,n-k)**2*(-1)**k*cmb(n,k) % mod\n\nprint(a % mod)", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\n\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nclass Combination(object):\n    def __init__(self, N, mod=MOD):\n        fac, finv, inv = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)\n        fac[:2] = 1, 1\n        finv[:2] = 1, 1\n        inv[1] = 1\n        for i in range(2, N + 1):\n            fac[i] = fac[i - 1] * i % mod\n            inv[i] = -inv[mod % i] * (mod // i) % mod\n            finv[i] = finv[i - 1] * inv[i] % mod\n        self.N = N\n        self.MOD = mod\n        self.fac = fac\n        self.finv = finv\n        self.inv = inv\n\n    def __call__(self, n, k):\n        return self.C(n, k)\n\n    def C(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        fac = self.fac\n        finv = self.finv\n        mod = self.MOD\n        return fac[n] * (finv[k] * finv[n - k] % mod) % mod\n\n    def P(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return self.fac[n] * self.finv[n - k]\n\n\ndef main():\n    N, M = MAP()\n    cmb = Combination(M)\n\n    ans = 0\n    for i in range(N + 1):\n        buf = (-1) ** i * cmb(N, i)\n        buf %= MOD\n        buf *= cmb.P(M, i)\n        buf %= MOD\n        buf *= pow(cmb.P(M - i, N - i), 2, MOD)\n        buf %= MOD\n        ans += buf\n        ans %= MOD\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def prepare(n, MOD):\n \n    # n! \u306e\u8a08\u7b97\n    f = 1\n    fn=[1]*(n+1)\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        fn[m]=f\n     \n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return fn, invs\n\ndef main():\n    n,m=map(int,input().split())\n    MOD=10**9+7\n    fn,invs=prepare(m,MOD)\n    ans=0\n    for i in range(n+1):\n        x=(fn[m-i]*invs[m-n])%MOD\n        x=(x*fn[n]*invs[i]*invs[n-i])%MOD\n        x*=(-1)**i\n        ans+=x\n    ans=(ans*fn[m]*invs[m-n])%MOD\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m=map(int,input().split())\na = 1\nMod=10**9+7\nd = [1]*(n+1)\nfor i in range(n):\n  d[i+1]=((m-n+i)*d[i]+i*d[i-1])%Mod\n  a=a*(m-i)%Mod\nprint(a*d[n]%Mod)", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\n\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nclass Combination(object):\n    def __init__(self, N, mod=MOD):\n        fac, finv, inv = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)\n        fac[:2] = 1, 1\n        finv[:2] = 1, 1\n        inv[1] = 1\n        for i in range(2, N + 1):\n            fac[i] = fac[i - 1] * i % mod\n            inv[i] = -inv[mod % i] * (mod // i) % mod\n            finv[i] = finv[i - 1] * inv[i] % mod\n        self.N = N\n        self.MOD = mod\n        self.fac = fac\n        self.finv = finv\n        self.inv = inv\n\n    def __call__(self, n, k):\n        return self.C(n, k)\n\n    def C(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        fac = self.fac\n        finv = self.finv\n        mod = self.MOD\n        return fac[n] * (finv[k] * finv[n - k] % mod) % mod\n\n    def P(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return self.fac[n] * self.finv[n - k]\n\n\ndef main():\n    N, M = MAP()\n    ans = 0\n\n    cmb = Combination(M)\n\n    sign = +1\n    for i in range(N+1):\n        ans += sign * cmb.P(M-i, N-i) * cmb(N, i)\n        ans %= MOD\n        sign *= -1\n    ans *= cmb.P(M, N)\n    ans %= MOD\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nn = N + M\nfac = [1] * (n + 1) \ninv = [1] * (n + 1)\nfor j in range(1, n + 1):\n    fac[j] = (fac[j - 1] * j) % MOD\n\ninv[n] = pow(fac[n], MOD-2, MOD)\nfor j in range(n - 1, -1, -1):\n    inv[j] = (inv[j + 1] * (j + 1)) % MOD\n\ndef comb(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return (fac[n] * inv[n - r] * inv[r]) % MOD\n\ndef perm(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return comb(n, r) * fac[r] % MOD\n\nans = pow(perm(M, N), 2, MOD)\n# r: Ai\u3068Bi\u304c\u4e00\u81f4\u3059\u308b\u500b\u6570\nfor r in range(1, N + 1):\n    p = comb(M, r) * perm(N, r) * pow(perm(M - r, N - r), 2, MOD) % MOD\n    p *= -(-1) ** (r % 2)\n    ans -= p\n    ans %= MOD\n\nprint(ans)", "# E - NEQ\n\nN, M = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\n\nfor i in range(2, M+1):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD)\n\nfixed = (fac[N] * fac[M] * pow(finv[M-N], 2, MOD)) % MOD\n\ndef f(k):\n    return (fac[M-k] * finv[k] * finv[N-k]) % MOD\n\nans = 0\nfor i in range(N+1):\n    ans = (ans + f(i) * pow(-1, i)) % MOD\n\nprint((fixed * ans) % MOD)", "class Combination():\n    def __init__(self, n, mod=10**9+7):\n        self.mod = mod\n        self.fac = [1]*(n+1)\n        for i in range(1,n+1):\n            self.fac[i] = self.fac[i-1] * i % self.mod\n        self.invfac = [1]*(n+1)\n        self.invfac[n] = pow(self.fac[n], self.mod - 2, self.mod)\n        for i in range(n-1, 0, -1):\n            self.invfac[i] = self.invfac[i+1] * (i+1) % self.mod\n\n    def combination(self, n, r):\n        return self.fac[n] * self.invfac[r] % self.mod * self.invfac[n-r] % self.mod\n\n    def permutation(self, n, r):\n        return self.factorial(n) * self.invfactorial(n-r) % self.mod\n\n    def factorial(self, i):\n        return self.fac[i]\n\n    def invfactorial(self, i):\n        return self.invfac[i]\n\ndef main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, m = map(int, input().split())\n    c = Combination(m)\n    mod = 10**9 + 7\n    ans = 0\n    for i in range(n+1):\n        tmp = c.combination(n,i)*pow(-1,i%2)*c.permutation(m, i)%mod\n        tmp *= c.permutation(m-i, n-i)**2\n        tmp %= mod\n        ans += tmp\n        ans %= mod\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M = list(map(int, readline().split()))\n\n    COM_MAX = M\n\n    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n\n    for i in range(2, COM_MAX + 1):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    def com(n, r):\n        if n < 0 or r < 0 or n < r:\n            return 0\n        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD\n\n    def perm(n, r):\n        if n < 0 or r < 0 or n < r:\n            return 0\n        return fac[n] * finv[n - r] % MOD\n\n    ans = 0\n    for k in range(N + 1):\n        tmp = perm(M - k, N - k) * com(N, k) % MOD\n        if k & 1:\n            tmp *= -1\n        ans = (ans + tmp) % MOD\n\n    ans = ans * perm(M, N) % MOD\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nmod = 10**9+7\nN, M = map(int, readline().split())\n \nfact = [1] * (M+1)\nfact_inv = [1] * (M+1)\nfor i in range(1,M+1):\n    fact[i] = fact[i-1] * i % mod \nfact_inv[M] = pow(fact[M],mod-2,mod)\nfor i in range(M,0,-1):\n    fact_inv[i-1] = (i * fact_inv[i]) % mod \n \ndef comb(n,r):\n  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\ntotal = 0\nfor k in range(N+1):\n    a = fact[M-k] * fact_inv[M-N] * comb(N,k) % mod\n    if k % 2 == 0:\n        total += a\n    else:\n        total -= a\nans = (comb(M,N) * fact[N]) % mod * total \nprint(ans%mod)", "mod = 10 ** 9 + 7\n\ndef mod_prepare(N):\n    fac = [1, 1]\n    finv = [1, 1]\n    inv = [0, 1]\n    for i in range(2, N + 1):\n        fac.append(fac[i - 1] * i % mod)\n        inv.append(mod - inv[mod % i] * (mod // i) % mod)\n        finv.append(finv[i - 1] * inv[i] % mod)\n    return fac, finv\n\nN, M = map(int, input().split())\n\nfac, inv = mod_prepare(M)\n\nans = 0\nsign = 1\nfor k in range(N + 1):\n    ans += sign * fac[M - k] * inv[k] * inv[N - k]\n    sign *= -1\n    ans %= mod\n\nprint(ans * fac[N] * fac[M] * inv[M - N] * inv[M - N] % mod)", "import sys\ninput = sys.stdin.readline\n\nN,M=map(int,input().split())\nmod=10**9+7\n\nFACT=[1]\nfor i in range(1,5*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(5*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nANS=0\nfor i in range(N+1):\n    if i%2==0:\n        ANS=(ANS+Combi(N,i)*FACT[M-i]*FACT_INV[M-N])%mod\n    else:\n        ANS=(ANS-Combi(N,i)*FACT[M-i]*FACT_INV[M-N])%mod\n\nprint(ANS*FACT[M]*FACT_INV[M-N]%mod)", "n,m = map(int,input().split())\nmod = 10**9+7\n\nfact = [1,1]\nfinv = [1,1]\ninv = [0,1]\n \nfor i in range(2,max(n,m)+5):\n    fact.append((fact[-1]*i)%mod)\n    inv.append((inv[mod%i]*(mod-mod//i))%mod)\n    finv.append((finv[-1]*inv[-1])%mod)\n \ndef nCr(n,r,mod):\n    if r > n:\n        return 0\n    else: \n        return fact[n]*finv[r]*finv[n-r]%mod\n\ndef nPr(n,r,mod):\n    if r > n:\n        return 0\n    else: \n        return fact[n]*finv[n-r]%mod\n\n\nans = 0\nfor i in range(n+1):\n    now = nCr(n,i,mod)\n    now *= nPr(m-i,n-i,mod)\n    now %= mod\n    if i%2:\n        now = -now\n    ans += now\n    ans % mod\nans *= nPr(m,n,mod)\nans %= mod\nprint(ans)", "def cmb(n, r, mod):#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u306e\u9ad8\u901f\u8a08\u7b97\u3000\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 5*10**5 #N\u306e\u6700\u5927\u5024\ng1 = [1, 1] #\u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN, M = map(int, input().split())\nans = 0\nfor i in range(N+1):\n    ans += cmb(N,i,mod)*((-1)**i)*g1[M]*g2[M-i]*((g1[M-i]*g2[M-N])**2)\n    ans %= mod\nprint(ans)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, M = MAP()\n\nlim = M+10  # \u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u308c\u308b\nfact = [1] * (lim+1)\nfact_inv = [1] * (lim+1)\nfor n in range(1, lim+1):\n    fact[n] = (fact[n-1] * n) % mod\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n    fact_inv[n-1] = (n * fact_inv[n]) % mod\ndef C(n, r):\n    return (((fact[n] * fact_inv[r]) % mod) * fact_inv[n-r]) % mod\n\ndef P(n, r):\n    return fact[n]*fact_inv[n-r]%mod\n\nans = 0\nfor k in range(N+1):\n    ans += (-1)**(k%2) * C(N, k) * P(M-k, N-k)\n    ans %= mod\n\nans *= P(M, N)\nprint((ans%mod))\n", "N,M=map(int, input().split())\n\nmd=1000000007\nfac=[0]*(M+1)\ninv=[0]*(M+1)\nifac=[0]*(M+1)\ninv[1]=1\nfor i in range(2,M+1):\n\tinv[i] = (md - (md//i) * inv[md%i] % md) % md;\nfac[0]=1\nifac[0]=1\nfor i in range(1,M+1):\n    fac[i]=fac[i-1]*i%md;\n    ifac[i]=ifac[i-1]*inv[i]%md;\n\ndef choose(n,k):\n    return fac[n]*ifac[k]*ifac[n-k]%md\ndef perm(m,n):\n    return fac[m]*ifac[m-n]%md\nans=0\nfor k in range(N+1):\n    if k%2==0:\n        ans+=choose(N,k)*perm(M,k)*perm(M-k,N-k)**2\n        ans%=md\n    else:\n        ans-=choose(N,k)*perm(M,k)*perm(M-k,N-k)**2\n        ans%=md\nprint(ans)", "# coding: utf-8\nimport sys\n# from operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nsys.setrecursionlimit(10 ** 7)\n#from heapq import heappop, heappush\n#from collections import OrderedDict, defaultdict\n#import math\n#from itertools import product, accumulate, combinations, product\n#import bisect# lower_bound etc\nimport numpy as np\n#from copy import deepcopy\nfrom collections import deque\n#import numba\n\ndef generate_inv(n,mod):\n    \"\"\"\n    \u9006\u5143\u884c\u5217\n    n >= 2\n    Note: mod must bwe a prime number\n    \"\"\"\n    ret = [0, 1]\n    for i in range(2,n+1):\n        next = -ret[mod%i] * (mod // i)\n        next %= mod\n        ret.append(next)\n    return ret\n\ndef generate_comb_m_i(M, N, inv, mod):\n    ret = [1, M]\n    for i in range(2, N+1):\n        tmp = (ret[-1] * (M-(i-1)) * inv[i]) % mod\n        ret.append(tmp)\n    return ret\ndef generate_p_N_i(N, mod):\n    ret = [1]\n    for i in range(1, N+1):\n        tmp = (ret[-1] * (N - (i-1))) % mod\n        ret.append(tmp)\n    return ret\n\ndef generate_p_mi_ni(M, N, mod):\n    ret = deque([1])\n    cache = deque([1])\n    for i in range(1, N+1):\n        tmp = (cache[0] * (M-N+i)) % mod\n        cache.appendleft(tmp)\n        ret.appendleft((tmp ** 2) % mod)\n    return ret\n\n\ndef run():\n    N, M = map(int, input().split())\n    mod = 10 ** 9 + 7\n\n    inv = generate_inv(M, mod)\n\n    comb_m_i = generate_comb_m_i(M, N, inv, mod)\n    #print(comb_m_i[0])\n    p_N_i = generate_p_N_i(N, mod)\n    #print(p_N_i[0])\n    p_mi_ni = generate_p_mi_ni(M, N, mod)\n    #print(p_mi_ni[0])\n\n    ret = p_mi_ni[0]\n\n    arr01 = [-1, 1] * (N//2 + 1)\n    arr01 = arr01[:N+1]\n\n    comb_m_i = np.array(comb_m_i, dtype=np.int64)\n    p_N_i = np.array(p_N_i, dtype=np.int64)\n    p_mi_ni = np.array(p_mi_ni, dtype=np.int64)\n    arr01 = np.array(arr01, dtype=np.int64)\n\n    tmp = (comb_m_i * p_N_i) % mod\n    tmp = (tmp * p_mi_ni) % mod\n    tmp = (tmp * arr01) % mod\n    tmp = tmp[1:]\n    sub = 0\n    for val in tmp:\n        sub += val\n        sub %= mod\n\n    ret -= sub\n    ret %= mod\n\n    print(ret)\n\ndef __starting_point():\n    run()\n__starting_point()", "#\u4e8c\u9805\u4fc2\u6570\u3001\u9806\u5217\u6e96\u5099\nMAX_NUM = 5* 10**5 + 1\nMOD = 10**9+7\n\nfac  = [0 for _ in range(MAX_NUM)]\nfinv = [0 for _ in range(MAX_NUM)]\ninv  = [0 for _ in range(MAX_NUM)]\n\nfac[0]  = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\n\nfor i in range(2,MAX_NUM):\n  fac[i] = fac[i-1] * i % MOD\n  inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n  finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,k):\n  if n < k:\n    return 0\n  if n < 0 or k < 0:\n    return 0\n  return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD\n\ndef perm(n,k):\n  if n < k:\n    return 0\n  if n < 0 or k < 0:\n    return 0\n  return fac[n] * finv[n-k] % MOD\n\n#\u4e3b\u8a08\u7b97\nN, M = map(int,input().split())\n\nans = 0\nfor K in range(N+1):\n  term = comb(N, K) * perm(M, K) \n  term *= perm(M - K, N - K)**2\n  term %= MOD\n  if K % 2 == 0:\n    ans = (ans + term) % MOD\n  else:\n    ans = (ans - term) % MOD\n    \nprint(ans)", "n, m = map(int, input().split())\n\nmod = 10**9+7\nN = 10**6  # N!\u307e\u3067\u6c42\u3081\u308b\nfact  = [1, 1]  # \u968e\u4e57\u306e\u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1]  # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb 1,2,,...\u306e\u9006\u5143\u3092\u6c42\u3081\u3066\u308b\n\n# \u8a08\u7b97 O(1)\ndef comb(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n\ndef perm(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    return fact[n] *  fact_inv[n-r] % mod\n\n# \u524d\u51e6\u7406 O(n)\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * inv[-1]) % mod)\n\nans = 0\nfor k in range(n+1):\n    ans += comb(n, k, mod) * perm(m, k, mod) * (perm(m-k, n-k, mod) ** 2) * ((-1) ** k)\n    ans %= mod\n\nprint(ans)", "import sys\n\n# ## COMBINATION (MOD) ## #\nMOD = 10**9 + 7  # , N = 2*10**5 \u3067 0.3s\nN_MAX = 5 * 10**5  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\n\nfac = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\nfacinv = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 1):\n    fac.append((fac[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    facinv.append((facinv[-1] * inv[-1]) % MOD)\n\n\ndef cmb(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[r] * facinv[n - r] % MOD\n\n\ndef prm(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[n - r] % MOD\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    all = prm(M, N) ** 2 % MOD\n\n    dup = 0\n\n    for i in range(1, N + 1):\n\n        tmp = prm(M, i) * prm(M - i, N - i) ** 2 % MOD\n        tmp *= cmb(N, i) * (-1) ** (i - 1)\n\n        dup += tmp % MOD\n\n    print(((all - dup) % MOD))\n\nmain()\n", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 10**6\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "\ndef main():\n    n,m = list(map(int,input().split()))\n    MOD = 10**9 + 7\n\n    fact = [1]\n    fact_inv = [1]\n    for i in range(m):\n        fact.append(fact[-1]*(i+1)%MOD)\n    fact_inv = [1] * (m+1)\n    fact_inv[m] = pow(fact[m],MOD-2,MOD)\n    for i in range(m):\n        fact_inv[m-i-1] = fact_inv[m-i] * (m-i) % MOD\n    # print(fact_inv)\n\n\n    \uff4dPn = fact[m] * pow(fact[m-n],MOD-2,MOD) % MOD\n\n    a = pow(mPn,2,MOD)\n    b = 0\n    for i in range(1,n+1):\n        nCr = fact[n] * fact_inv[i] % MOD * fact_inv[n-i] % MOD\n        b += (-1)**(i%2) * nCr * fact[m-i] % MOD * fact_inv[m-n] % MOD\n        b %= MOD\n    ans = a + b * mPn\n    print((ans%MOD))\n\n\nmain()\n\n\n", "# \u89e3\u8aac\u306a\u3069\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# https://mathtrain.jp/hojo\n# https://qiita.com/DaikiSuyama/items/4d0388a3f68b60c3e5f3\n# https://atcoder.jp/contests/abc172/submissions/16541798\n# tag: \u5305\u9664\u539f\u7406\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\nclass FermatCmb:\n    \"\"\"\u30d5\u30a7\u30eb\u30de\u30fc\u5c0f\u5b9a\u7406\u3092\u4f7f\u7528\u3057\u305f\u9806\u5217, \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\"\"\"\n\n    def __init__(self, max_num, mod):\n        \"\"\"\n        :param max_num: max n of nCk\n        :param mod: any prime number\n        \"\"\"\n        self.max_num = max_num\n        self.mod = mod\n        self.fact = [0 for _ in range(max_num + 1)]\n        self.factinv = [0 for _ in range(max_num + 1)]\n\n        self.fact[0] = 1\n        for i in range(1, max_num + 1):\n            self.fact[i] = (i * self.fact[i - 1]) % self.mod\n\n        self.factinv[-1] = pow(self.fact[-1], mod - 2, mod)\n        for i in range(max_num, 0, -1):\n            self.factinv[i - 1] = self.factinv[i] * i\n            self.factinv[i - 1] %= self.mod\n\n    def nCk(self, n, k):\n        return (self.fact[n] * self.factinv[k] * self.factinv[n - k]) % self.mod\n\n    def nPk(self, n, k):\n        return (self.fact[n] * self.factinv[n - k]) % self.mod\n\n\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, M):\n    mod = 10 ** 9 + 7\n    cf = FermatCmb(M, mod)\n    ans = 0\n    for k in range(N + 1):\n        ans += (-1) ** k * cf.nCk(N, k) * cf.nPk(M, k) * (\n                cf.nPk(M - k, N - k) ** 2)\n        ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    # S = input()\n    # N = int(input())\n    N, M = list(map(int, input().split()))\n    # A = [int(i) for i in input().split()]\n    # B = [int(i) for i in input().split()]\n    # AB = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, M)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "MOD = 10**9 + 7\n\nMOD_t_MAX = 5*10**5+10\n\nfac  = [None] * MOD_t_MAX\nfinv = [None] * MOD_t_MAX\ninv  = [None] * MOD_t_MAX\ndef MOD_COM_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MOD_t_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\ndef MOD_COM(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef MOD_perm(n, r):\n    rtn = 1\n    for _ in range(r):\n        rtn *= n\n        rtn %= MOD\n        n -= 1\n    return rtn\n\ndef main():\n    n, m = map(int, input().split())\n    ans = 0\n    perm = MOD_perm(m, n)\n    MOD_COM_init()\n    for i in range(n+1):\n        tmp = perm * MOD_COM(n, i) % MOD\n        ans += (-1)**i * tmp\n        ans %= MOD\n        if i < n:\n            perm *= inv[m-i]\n            perm %= MOD\n    print(ans*MOD_perm(m, n)%MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "# MOD\u4e0b\u3067\u306e\u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u3092\u6c42\u3081\u308b\u95a2\u6570\n# O(nlogn + n) ?\ndef prepare(n):\n    nonlocal mod\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % mod\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], mod - 2, mod)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % mod\n\n    return modFacts, invs\n\nn,m = list(map(int,input().split()))\nmod = 10**9+7\nmodFacts,invs = prepare(m)\nans = 0\nnci = 0\nfor i in range(n+1):\n    nci = (modFacts[n]*invs[n-i]*invs[i]) % mod\n    mpi = (modFacts[m]*invs[m-i]) % mod\n    mipni = (modFacts[m-i]*invs[m-n]) % mod\n    ans += ((nci * mpi * mipni**2) % mod )* (-1)**i\n    ans %= mod\n    # print(i,nci,mpi,mipni)\nprint(ans)\n", "'''\nLet g(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u6700\u591a x \u500b\u4f4d\u7f6e\u4e0d\u540c\u3002\nLet f(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u7d66\u5b9a x \u500b\u4f4d\u7f6e\u6642\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u3002\n\n\u984c\u76ee\u6240\u6c42\u662f C(N, N) f(N)\u3002\n\n\u5176\u4e2d g(x) \u4ee3\u8868\u6709\u81f3\u5c11 N - x \u500b\u4f4d\u7f6e\u662f\u76f8\u540c\u3002\u53ef\u4ee5\u5206\u4e09\u500b\u90e8\u4efd\u586b\u6578\u5b57\uff0c\u6ce8\u610f\u9806\u5e8f\u6703\u5f71\u97ff\uff0c\u6240\u4ee5\u8981\u4e58\u4e0a\u5168\u6392\u5217\uff1a\n(1) N - x \u500b\u4f4d\u7f6e\uff08\u6578\u5b57\u5fc5\u9700\u76f8\u540c\uff09\uff1aC(M, N - x) * (N - x)! = P(M, N - x)\n(2) \u5e8f\u5217 A \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\n(3) \u5e8f\u5217 B \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\ng(x) = (1) * (2) * (3)\n\ng(x) \u662f\u300c\u9078\u5b9a 0 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u300c\u9078\u5b9a 1 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u2026\u3001\u300c\u9078\u5b9a x \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\uff0c\u5373\ng(x) = C(x, 0) f(0) + C(x, 1) f(1) + ... + C(x, x) f(x)\n     = sum( C(x, i) * f(i) for i in [0, x] )\n\u6839\u64da\u4e8c\u9805\u5f0f\u53cd\u6f14\uff0c\u5f97\u5230\nf(x) = sum( (-1) ** (x - i) * C(x, i) * g(i) for i in [0, x] )\n'''\n\nclass CombMod:\n    def __init__(self, V, p):\n        self.fact = [1] * V\n        self.finv = [1] * V\n        for i in range(1, V):\n            self.fact[i] = self.fact[i - 1] * i % p\n        self.finv[-1] = pow(self.fact[-1], p - 2, p)\n        for i in range(V - 2, 0, -1):\n            self.finv[i] = self.finv[i + 1] * (i + 1) % p\n        self.p = p\n        \n    def fact(self, a):\n        return self.fact[a]\n    \n    def finv(self, a):\n        return self.finv[a]\n\n    def comb(self, a, b):\n        return self.fact[a] * self.finv[b] % self.p * self.finv[a - b] % self.p\n        \n    def perm(self, a, b):\n        return self.fact[a] * self.finv[a - b] % self.p\n    \n    def hcomb(self, a, b):\n        return self.comb(a + b - 1, b)\n\n\nN, M = list(map(int, input().split()))\nmod = 10**9 + 7\ntool = CombMod(max(N, M) + 10, mod)\n\nf_N = 0\nfor i in range(0, N + 1):\n    p1 = tool.perm(M, N - i)\n    p2 = tool.perm(M - (N - i), i)\n    g_i = p1 * p2 % mod * p2 % mod\n    val = (-1)**((N - i) % 2) * tool.comb(N, i) % mod * g_i % mod\n    f_N = (f_N + val) % mod\nans = tool.comb(N, N) * f_N % mod\nprint(ans)\n", "n, m = map(int, input().split(' '))\nmod = int(1e9 + 7)\n\nl = [1] * (m+1)\nfor i in range(1, m+1):\n\tl[i] = (l[i-1] * i) % mod\n\nl2 = [1] * (m+1)\nl2[m] = pow(l[m], mod-2, mod)\nfor i in range(m-1, 0, -1):\n\tl2[i] = (l2[i+1] * (i+1)) % mod\n\ns = 0\nfor k in range(n+1):\n\tn_choose_k = (l[n] * l2[k] * l2[n-k]) % mod\n\tm_perm_k = (l[m] * l2[m-k]) % mod\n\tmk_perm_nk = (l[m-k] * l2[m-n]) % mod\n\ts += ((-1) ** k * n_choose_k * m_perm_k * mk_perm_nk ** 2 ) % mod \n\nprint(s % mod)", "class Factorial():\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.fct = [0 for _ in range(n + 1)]\n        self.inv = [0 for _ in range(n + 1)]\n        self.fct[0] = 1\n        self.inv[0] = 1\n        for i in range(n):\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n        for i in range(n)[::-1]:\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n\n    def fact(self, m):\n        return self.fct[m]\n\n    def invf(self, m):\n        return self.inv[m]\n\n    def perm(self, m, k):\n        if m < k: return 0\n        return self.fct[m] * self.inv[m - k] % self.mod\n\n    def comb(self, m, k):\n        if m < k: return 0\n        return self.fct[m] * self.inv[k] * self.inv[m - k] % self.mod\n\nMOD = 1000000007\n\nN, M = map(int, input().split())\n\nf = Factorial(M, MOD)\n\nres = f.perm(M, N)\n\nfor k in range(1, N + 1):\n    res -= (-1)**(k - 1) * f.comb(N, k) * f.perm(M - k, N - k)\n\nres *= f.perm(M, N)\nres %= MOD\n\nprint(res)", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * 2 + [None] * (max_fact - 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx % mod\n        fi = [None] * max_fact + [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi[idx - 1] = fi[idx] * idx % mod\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 5 * 10**5\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "MOD = 10**9 + 7\nMAX = 5*10**5 + 1\n\nfact = [0 for _ in range(MAX)]\nfactinv = [0 for _ in range(MAX)]\n\nfact[0] = 1\nfor k in range(1, MAX):\n    fact[k] = fact[k - 1]*k\n    fact[k] %= MOD\n\nfactinv[MAX - 1] = pow(fact[MAX - 1], MOD - 2, MOD)\nfor k in range(MAX - 1, 0, -1):\n    factinv[k - 1] = factinv[k]*k\n    factinv[k - 1] %= MOD\n\ndef nCk(n, k):\n    return fact[n]*factinv[k]*factinv[n - k] % MOD\n\ndef nPk(n, k):\n    return fact[n]*factinv[n - k] % MOD\n\nn, m = map(int, input().split(' '))\n\nans = 0\nfor k in range(n + 1):\n    tmp = nCk(n, k)*nPk(m, k)*nPk(m - k, n - k)*nPk(m - k, n - k) % MOD\n    if not k % 2: ans += tmp\n    else: ans -= tmp\n    ans %= MOD\n\nprint(ans)", "n, m = [int(x) for x in input().split(\" \")]\nMOD = int(1e9 + 7)\n\n\nfact = [0 for _ in range(m + 1)]\nfact[0] = 1\nfor i in range(1, m + 1):\n    fact[i] = fact[i-1] * i % MOD\n\nfinv = [0 for _ in range(m + 1)]\nfinv[m] = pow(fact[m], MOD-2, MOD)\nfor i in range(m-1, -1, -1):\n    finv[i] = finv[i+1] * (i + 1) % MOD\n\ndef nCk(n, k):\n    return fact[n] * finv[k] * finv[n-k] % MOD\n\ndef nPk(n, k):\n    return fact[n] * finv[n-k] % MOD\n\nans = 0\nfor k in range(0, n + 1):\n    tmp = nCk(n, k) * nPk(m, k) * (nPk(m-k, n-k) ** 2)\n    if k % 2 == 0:\n        ans += tmp\n    else:\n        ans -= tmp\n    ans = ans % MOD\n\nprint(ans)\n\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nfrom decimal import Decimal\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\nN,M = list(map(int,input().split()))\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nMOD = 10**9+7\nfor i in range(2, M+2):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD) \ndef comb_mod(n, r, m):  #nCr mod m\n    if (n<0 or r<0 or n<r): return 0\n    r = min(r, n-r)\n    return fac[n] * finv[n-r] * finv[r] % m\n\ndef chofuku(n,r): # nHr mod MOD \u306e\u8a08\u7b97\n    return comb_mod(n+r-1,r)\n \ndef nPr(n,r,m): #nPr mod MOD \u306e\u8a08\u7b97\n    return fac[n]*finv[n-r]%m\nans = 0\nfor i in range(1,N+1):\n    if i % 2 == 1:\n        flag = 1\n    else:\n        flag = -1\n    s = flag*comb_mod(N,i,MOD)*nPr(M-i,N-i,MOD)\n    ans += s\n    if ans > MOD:\n        ans %= MOD\nans1 = 1\nfor i in range(N):\n    ans1 *= (M-i)\n    ans1 %= MOD\nans2 = (ans1*ans1)%MOD\nans3 = (ans*nPr(M,N,MOD)) %MOD\nprint(((ans2-ans3)%MOD))\n", "def cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\ndef per(n, r, p):\n    if r < 0 or n < r:\n        return 0\n    return fact[n] * factinv[n-r] % p\n\np = 10 ** 9 + 7#mod\nN = 5*pow(10, 5)  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\u3002\u5927\u4f53\u554f\u984c\u8a2d\u5b9a\u306e\u30aa\u30fc\u30c0\u30fc\u306b\u5408\u308f\u305b\u308b(N >= max(n, r)\u3002\u4e0a\u306ecmb\u95a2\u6570\u306e\u30ea\u30b9\u30c8\u540c\u58eb\u306e\u639b\u3051\u7b97\u306b\u304a\u3044\u3066\u3001fact[n], factinv[r]\u3092\u53c2\u7167\u3059\u308b\u305f\u3081)\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nn, m = map(int, input().split())\nans = 0\nfor i in range(n+1):\n    ans += pow(per(m-i, n-i, p), 2) * per(m, i, p) * cmb(n, i, p) * (-1)**i % p\nans = ans % p\nprint(ans)", "n,m=map(int,input().split())\nM,F=10**9+7,[1]\nfor i in range(m): F+=[-~i*F[i]%M]\nprint(sum((-1)**k*F[m-k]*pow(F[k]*F[n-k]*F[m-n]**2,-1,M) for k in range(n+1))*F[n]*F[m]%M)", "#\u5199\u7d4c\n#https://atcoder.jp/contests/abc172/submissions/14794920\n\nMOD = 10**9 + 7\n\ndef resolve():\n    N,M = map(int,input().split())\n    a = 1\n    d = [1]\n    for i in range(N):\n        d.append(((M-N+i)*d[i]+i*d[i-1])%MOD)\n        a=a*(M-i)%MOD\n    print(a*d[-1]%MOD)\nresolve()", "\ndef factorials_with_inv(k,mod):\n    \"\"\"\n    0! ... k! \u3068\u305d\u308c\u3089\u306emod\u9006\u5143\u3092\u6c42\u3081\u3066\u8fd4\u3059\n    \"\"\"\n    fac = [1]*(k+1)\n    inv = [1]*(k+1)\n    t = 1\n    for i in range(1,k+1):\n        t *= i\n        t %= mod\n        fac[i] = t\n\n    t = pow(t,-1,mod)\n    for i in reversed(range(1,k+1)):\n        inv[i] = t\n        t *= i\n        t %= mod\n\n    return fac, inv\n\nMOD = 10**9+7\n\ndef solve(N,M):\n    fac,inv = factorials_with_inv(max(N,M), MOD)\n\n    # (M-k)!/(k!(N-k)!) * N!M!/((M-N)!^2)\n\n    res = 0\n    sign = True\n    for k in range(N+1):\n        t = fac[M-k]*inv[k]*inv[N-k]\n        if sign:\n            res += t\n        else:\n            res -= t\n        res %= MOD\n        sign = not sign\n\n    res *= fac[N]*fac[M]*inv[M-N]**2\n    res %= MOD\n    return res\n\nfrom itertools import permutations\n\ndef naive(N,M):\n    res = 0\n    for A in permutations(range(M),N):\n        for B in permutations(range(M),N):\n            res += all(a != b for a,b in zip(A,B))\n    return res%MOD\n\ndef __starting_point():\n    N,M = map(int,input().split())\n\n    # print(naive(N,M))\n    print(solve(N,M))\n__starting_point()", "n, m = map(int, input().split())\nmod = 10**9+7\nnums = 5*(10**5) # \u5236\u7d04\u306b\u5408\u308f\u305b\u3088\u3046\n\ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n    \ndef nPr(n, r):\n    return g1[n] * g2[n-r] % mod\n\ndef nCr(n, r):\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nans = 0\nfor r in range(n+1):\n    tmp = nCr(n, r)*nPr(m, r)*(nPr(m-r, n-r)**2)%mod\n    ans = (ans+(-1)**r*tmp)%mod\nprint(ans)", "from functools import lru_cache\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % MOD\n            self.inv[i] = -self.inv[MOD % i] * (MOD // i) % MOD\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % MOD\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nN, M = list(map(int, input().split()))\nMOD = 10**9 + 7\ncomb = Combination(M + 100)\n\nans = 0\nfor k in range(N + 1):\n    ans += comb.ncr(N, k) * ((-1)**k) * comb.npr(M, k) * (comb.npr(M - k, N - k)**2)\n    ans %= MOD\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nN = m + 100\nMOD = 10 ** 9 + 7\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = i * fact[i - 1] % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\n    \ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \ndef nPk(n, k):\n    return fact[n] * invfact[n - k] % MOD\n    \nans = 0\nsign = 1\n\nfor i in range(n + 1):\n    ans = (ans + nPk(m, i) * nCk(n, i) * nPk(m - i, n - i) ** 2 * sign) % MOD\n    sign *= -1\n    \nprint(ans)\n    \n", "n,m=list(map(int,input().split()))\na,M,d=1,10**9+7,[1]*(n+1)\nfor i in range(n):\n  d[i+1]=((m-n+i)*d[i]+i*d[i-1])%M\n  a=a*(m-i)%M\nprint((a*d[-1]%M))\n", "n,m=map(int,input().split())\ni=b=0\na=1\nwhile i<n:a,b,i=((m-i)*((m-n+i)*a+i*(m-i+1)*b))%(10**9+7),a,i+1\nprint(a)", "class Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\nN, M = map(int, input().split())\n\nMOD = 10 ** 9 + 7\n\nF = Factorial(M + 1, MOD)\n\nans = 0\nfor k in range(N + 1):\n    tmp1 = F.comb(N, k)\n    tmp2 = (F.factorial(M) * F.ifactorial(M - k)) % MOD\n    tmp3 = ((F.factorial(M - k) * F.ifactorial(M - N))) ** 2 % MOD\n    tmp = (tmp1 * tmp2 * tmp3) % MOD\n    if k % 2 == 0:\n        ans += tmp\n    else:\n        ans -= tmp\n    ans %= MOD\n\nprint (ans)", "n,m = list(map(int,input().split()))\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nimport math\n\ndef perm(n, r):\n    ''' nPr % mod '''\n    if r > n:\n        return 0\n    return g1[n] * g2[n-r] % mod\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nN = 5 * 10**5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor k in range(n+1):\n    a = cmb(n,k,mod)\n    p1 = perm(m,k)\n    p2 = perm(m-k, n-k)\n    ans += (a * (-1)**k * p1 * p2**2)\n\nprint(ans%mod)", "class Factorials:\n    def __init__(self, n, mod):\n        self.mod = mod\n\n        # self.fac[i] \u2261 i! (factorial:\u968e\u4e57)\n        self.fac = [1]\n        num = 1\n        for i in range(1, n+1):\n            num *= i\n            num %= mod\n            self.fac.append(num)\n\n        # self.rec[i] \u2261 1 / i! (reciprocal:\u9006\u6570)\n        num = pow(num, mod-2, mod)\n        self.rec = [1 for i in range(n+1)]\n        self.rec[n] = num\n        for i in range(n-1, 0, -1):\n            num *= i + 1\n            num %= mod\n            self.rec[i] = num\n\n    # comb(n, r) \u2261 nCr\n    def comb(self, n, r):\n        return self.fac[n] * self.rec[r] * self.rec[n - r] % self.mod\n    \n    # perm(n, r) \u2261 nPr\n    def perm(self, n, r):\n        return self.fac[n] * self.rec[n-r] % self.mod\n\ndef main():\n    n, m = map(int, input().split())\n    mod = 10**9 + 7\n\n    f = Factorials(m, mod)\n\n    ans = 0\n    for i in range(n+1):\n        if i % 2 == 0:\n            ans += f.comb(n, i) * f.perm(m, i) * f.perm(m-i, n-i) * f.perm(m-i, n-i) % mod\n        else:\n            ans -= f.comb(n, i) * f.perm(m, i) * f.perm(m-i, n-i) * f.perm(m-i, n-i) % mod\n        ans %= mod\n\n    print(ans)\n\nmain()", "import math\nMOD = 10 ** 9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\ndef init(n):\n    for i in range(2, n + 1):\n        fact.append((fact[-1] * i) % MOD)\n        inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n        factinv.append((factinv[-1] * inv[-1]) % MOD)\n\ndef nPk(n, k):\n    return fact[n] * factinv[n - k] % MOD\n\ndef nCk(n, k):\n    return fact[n] * factinv[n - k] * factinv[k] % MOD\n\nN, M = list(map(int, input().split()))\ninit(M)\nans = 0\nfor k in range(N + 1):\n    if k % 2 == 0:\n        ans += nCk(N, k) * nPk(M - k, N - k)\n    else:\n        ans -= nCk(N, k) * nPk(M - k, N - k)\n    ans = (ans + MOD) % MOD\nans *= nPk(M, N)\nans %= MOD\nprint(ans)\n", "MOD = 10**9+7\nn, m = list(map(int, input().split()))\n\nU = max(n, m)\nfact = [0]*(U+1)\nfact[0] = 1\nfor i in range(1, U+1):\n    fact[i] = fact[i-1]*i % MOD\n\n\ninvfact = [0]*(U+1)\ninvfact[U] = pow(fact[U], MOD-2, MOD)\nfor i in reversed(list(range(U))):\n    invfact[i] = invfact[i+1]*(i+1) % MOD\n\n\ndef nCr(n, r):\n    if r < 0 or n < r:\n        return 0\n    return fact[n]*invfact[r]*invfact[n-r]\n\n\ndef nPr(n, r):\n    return fact[n]*invfact[n-r]\n\n\nans = 0\nfor k in range(n+1):\n    tmp = nCr(n, k)*nPr(m, n)*nPr(m-k, n-k)\n    if k % 2 == 0:\n        ans += tmp\n    else:\n        ans -= tmp\n    ans %= MOD\nprint(ans)\n", "import sys \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nmod = 10**9+7\nN, M = map(int, readline().split())\n\nfact = [1] * (M+1)\nfact_inv = [1] * (M+1)\nfor i in range(1,M+1):\n    fact[i] = fact[i-1] * i % mod \nfact_inv[M] = pow(fact[M],mod-2,mod)\nfor i in range(M,0,-1):\n    fact_inv[i-1] = (i * fact_inv[i]) % mod \n\ndef comb(n,r):\n  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\ntotal = 0\nfor k in range(N+1):\n    a = fact[M-k] * fact_inv[M-N] * comb(N,k) % mod\n    if k % 2 == 0:\n        total += a\n    else:\n        total -= a\nans = (comb(M,N) * fact[N]) % mod * total \nprint(ans%mod)", "MOD = 10**9 + 7\nfac = [1,1] # \u968e\u4e57 n!\ninv = [0,1] # \u9006\u5143 1/n\nfinv = [1,1] # \u9006\u5143\u306e\u968e\u4e57 (n^-1)! = (1/n)!\n\ndef finv_init(n, m):\n    for i in range(2, n+1):\n        fac.append( (fac[-1] * i ) % m )\n        inv.append( (-inv[m%i] * (m//i)) % m )\n        finv.append( (finv[-1] * inv[-1]) % m )\n\ndef nPr(n, r, m): return fac[n] * finv[n-r]\n\nn, m = list(map(int, input().split()))\nfinv_init(m, MOD)\nans = 0\nfor d in range(0, n+1):\n    a = nPr(m-d, n-d, MOD) * nPr(n, d, MOD) * finv[d] % MOD\n    if d & 1: a = -a\n    ans += a; ans %= MOD\nans *= nPr(m, n, MOD)\nprint((ans % MOD))\n", "N,M = map(int,input().split())\nmod = 10**9 + 7\nleng = 500010\nfac = [1,1]\nfor i in range(2,500010):\n    fac.append(fac[-1]*i%mod)\n\ninvfac = [0]*500010\ninvfac[500009] = pow(fac[500009],-1,mod)\nfor i in range(500009):\n    invfac[500008-i] = invfac[500009-i]*(500009-i)%mod\n\ndef combi(n,m):\n    return(fac[n]*invfac[m]*invfac[n-m]%mod)\n\ndef permu(n,m):\n    return(fac[n]*invfac[n-m]%mod)\n\nAns = 0\n\nfor i in range(N+1):\n    if i%2 == 0:\n        Ans += combi(N,i)*permu(M,i)*(permu(M-i,N-i)**2)\n    else:\n        Ans -= combi(N,i)*permu(M,i)*(permu(M-i,N-i)**2)\n\nprint(Ans%mod)", "SIZE=5*10**5+1; MOD=10**9+7 #998244353 #\u3053\u3053\u3092\u5909\u66f4\u3059\u308b\n \nSIZE += 1\ninv = [0]*SIZE  # inv[j] = j^{-1} mod MOD\nfac = [0]*SIZE  # fac[j] = j! mod MOD\nfinv = [0]*SIZE # finv[j] = (j!)^{-1} mod MOD\ninv[1] = 1\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,SIZE):\n    inv[i] = MOD - (MOD//i)*inv[MOD%i]%MOD\n    fac[i] = fac[i-1]*i%MOD\n    finv[i]= finv[i-1]*inv[i]%MOD\n \ndef choose(n,r): # nCr mod MOD \u306e\u8a08\u7b97\n    if 0 <= r <= n:\n        return (fac[n]*finv[r]%MOD)*finv[n-r]%MOD\n    else:\n        return 0\n \ndef chofuku(n,r): # nHr mod MOD \u306e\u8a08\u7b97\n    return choose(n+r-1,r)\n\ndef narabekae(n,r): #nPr mod MOD \u306e\u8a08\u7b97\n    return fac[n]*finv[n-r]%MOD\n\n\nN,M=list(map(int,input().split()))\nans=0\nfor k in range(N+1):\n    ans+=choose(N,k)*narabekae(M-k,N-k)*(-1 if k%2==1 else 1)\n    ans%=MOD\nans*=narabekae(M,N)\nprint((ans%MOD))\n", "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\ndef fact_table(N, mod):\n    inv = np.empty(N, np.int64)\n    inv[0] = 0\n    inv[1] = 1\n\n    for n in range(2,N):\n        q, r = divmod(mod, n)\n        inv[n] = inv[r] * (-q) % mod\n\n    fact = np.empty(N, np.int64)\n    fact[0] = 1\n    for n in range(1,N):\n        fact[n] = n * fact[n-1] % mod\n    fact_inv = np.empty(N, np.int64)\n    fact_inv[0] = 1\n    for n in range(1,N):\n        fact_inv[n] = fact_inv[n-1] * inv[n] % mod\n    return fact, fact_inv, inv\n\ndef main():\n    n, m = list(map(int, readline().split()))\n    mod = 10**9 + 7\n    fact, fact_inv, inv = fact_table(n+1, mod)\n    comb = fact[n] * fact_inv % mod * fact_inv[::-1] % mod\n    comb[1::2] *= (-1)\n    comb = comb[::-1]\n\n    p = 1\n    ans = 0\n    for k in range(n+1):\n        ans += comb[k] * p % mod\n        if k != n:\n            p = p * (m-n+1+k)%mod\n    ans %= mod\n    print(( p * ans % mod ))\n    return\n\nmain()\n\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nfrom decimal import Decimal\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\nN,M = list(map(int,input().split()))\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nMOD = 10**9+7\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nfor i in range(2, M+1):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD) \ndef comb_mod(n, r, m):  #nCr mod m\n    if (n<0 or r<0 or n<r): return 0\n    r = min(r, n-r)\n    return fac[n] * finv[n-r] * finv[r] % m\n\ndef chofuku(n,r): # nHr mod MOD \u306e\u8a08\u7b97\n    return comb_mod(n+r-1,r)\n \ndef nPr(n,r,m): #nPr mod m \u306e\u8a08\u7b97\n    return fac[n]*finv[n-r]%m\nans = 0\nfor i in range(1,N+1):\n    if i % 2 == 1:\n        flag = 1\n    else:\n        flag = -1\n    s = flag*comb_mod(N,i,MOD)*nPr(M-i,N-i,MOD)\n    ans += s\n    if ans > MOD:\n        ans %= MOD\nans1 = 1\nfor i in range(N):\n    ans1 *= (M-i)\n    ans1 %= MOD\nans2 = (ans1*ans1)%MOD\nans3 = (ans*nPr(M,N,MOD)) %MOD\nprint(((ans2-ans3)%MOD))\n", "mod=10**9+7\nn=10**6\ninv_t=[0]+[1]\nfor i in range(2,n):\n  inv_t+=[inv_t[mod%i]*(mod-int(mod/i))%mod]\n\nkai=[1,1]\nrev_kai=[1,inv_t[1]]\nfor i in range(2,n):\n  kai.append(kai[-1]*i%mod)\n  rev_kai.append(rev_kai[-1]*inv_t[i]%mod)\n\ndef cmb(n,r):\n  return kai[n]*rev_kai[r]*rev_kai[n-r]%mod\n\ndef prm(n,r):\n  return kai[n]*rev_kai[n-r]%mod\n\nN,M=map(int, input().split())\ndef f(x):\n  e=cmb(N,x)*prm(M,x)*prm(M-x,N-x)*prm(M-x,N-x)\n  e%=mod\n  return e\n\nans=0\nfor i in range(N+1):\n  g=f(i)*((-1)**i)\n  ans+=g\nprint(ans%mod)", "n,m=map(int,input().split())\ni,d=0,[1]*(n+1)\nwhile i<n:d[i+1]=((m-i)*((m-n+i)*d[i]+i*d[i-1]*(m-i+1)))%(10**9+7);i+=1\nprint(d[-1])", "'''\nLet g(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u6700\u591a x \u500b\u4f4d\u7f6e\u4e0d\u540c\u3002\nLet f(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u7d66\u5b9a x \u500b\u4f4d\u7f6e\u6642\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u3002\n\n\u984c\u76ee\u6240\u6c42\u662f C(N, N) f(N)\u3002\n\n\u5176\u4e2d g(x) \u4ee3\u8868\u6709\u81f3\u5c11 N - x \u500b\u4f4d\u7f6e\u662f\u76f8\u540c\u3002\u53ef\u4ee5\u5206\u4e09\u500b\u90e8\u4efd\u586b\u6578\u5b57\uff0c\u6ce8\u610f\u9806\u5e8f\u6703\u5f71\u97ff\uff0c\u6240\u4ee5\u8981\u4e58\u4e0a\u5168\u6392\u5e8f\uff1a\n(1) N - x \u500b\u4f4d\u7f6e\uff08\u6578\u5b57\u5fc5\u9700\u76f8\u540c\uff09\uff1aC(M, N - x) * (N - x)! = P(M, N - x)\n(2) \u5e8f\u5217 A \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\n(3) \u5e8f\u5217 B \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\ng(x) = (1) * (2) * (3)\n\ng(x) \u662f\u300c\u9078\u5b9a 0 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u300c\u9078\u5b9a 1 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u2026\u3001\u300c\u9078\u5b9a N \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\uff0c\u5373\n\ng(x) = C(x, 0) f(0) + C(x, 1) f(1) + ... + C(x, x) f(x)\n     = sum( C(x, i) * f(i) for i in [0, x] )\n\u6839\u64da\u4e8c\u9805\u5f0f\u53cd\u6f14\uff0c\u5f97\u5230\nf(x) = sum( (-1) ** (x - i) * C(x, i) * g(i) for i in [0, x] )\n'''\n\nclass CombMod:\n    def __init__(self, V, p):\n        self.fact = [1] * V\n        self.finv = [1] * V\n        for i in range(1, V):\n            self.fact[i] = self.fact[i - 1] * i % p\n        self.finv[-1] = pow(self.fact[-1], p - 2, p)\n        for i in range(V - 2, 0, -1):\n            self.finv[i] = self.finv[i + 1] * (i + 1) % p\n        self.p = p\n        \n    def fact(self, a):\n        return self.fact[a]\n    \n    def finv(self, a):\n        return self.finv[a]\n\n    def comb(self, a, b):\n        return self.fact[a] * self.finv[b] % self.p * self.finv[a - b] % self.p\n        \n    def perm(self, a, b):\n        return self.fact[a] * self.finv[a - b] % self.p\n    \n    def hcomb(self, a, b):\n        return self.comb(a + b - 1, b)\n\n\nN, M = list(map(int, input().split()))\nmod = 10**9 + 7\ntool = CombMod(max(N, M) + 10, mod)\n\nf_N = 0\nfor i in range(0, N + 1):\n    p1 = tool.perm(M, N - i)\n    p2 = tool.perm(M - (N - i), i)\n    g_i = p1 * p2 % mod * p2 % mod\n    val = (-1)**((N - i) % 2) * tool.comb(N, i) % mod * g_i % mod\n    f_N = (f_N + val) % mod\nans = tool.comb(N, N) * f_N % mod\nprint(ans)\n", "n, m = map(int, input().split())\nmod = 10**9+7\nnums = 5*(10**5) # \u5236\u7d04\u306b\u5408\u308f\u305b\u3088\u3046\n \ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n    \ndef nPr(n, r):\n    return g1[n] * g2[n-r] % mod\n \ndef nCr(n, r):\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nans = 0\nfor r in range(n+1):\n    tmp = nCr(n, r)*nPr(m, r)*(nPr(m-r, n-r)**2)%mod\n    ans = (ans+(-1)**r*tmp)%mod\nprint(ans)", "MAX = 5 * (10**5)\nMOD = 10**9 + 7\n\n_fact = [1,1] + [0] * MAX\n_inv = [0,1] + [0] * MAX\n_fact_inv = [1,1] + [0] * MAX\nfor k in range(2, MAX + 1):\n    _fact[k] = _fact[k-1] * k % MOD\n    _inv[k] = (-_inv[MOD % k] * (MOD // k)) % MOD\n    _fact_inv[k] = _fact_inv[k-1] * _inv[k] % MOD\n\ndef P(m, n):\n    return _fact[m] * _fact_inv[m-n] % MOD\n\ndef C(m, n):\n    return _fact[m] * _fact_inv[m-n] * _fact_inv[n] % MOD\n\ndef solve(n, m):\n    res = 0\n    for k in range(n+1):\n        sign = 1 - 2 * (k%2)\n        cur = sign * C(n, k) * P(m, k) * (P(m-k, n-k) ** 2)\n        res = (res + cur) % MOD\n    return res\n\nn, m = map(int, input().split())\nprint(solve(n, m))", "MOD = 1000000007\nclass mint:\n    def __init__(self,x=0):\n        self.x = x % MOD\n    def __str__(self):\n        return str(self.x)\n\n    __repr__ = __str__\n\n    def __add__(self, other):\n        return(\n            mint(self.x + other.x) if isinstance(other, mint) else mint(self.x + other)\n        )\n\n    def __sub__(self, other):\n        return(\n            mint(self.x - other.x) if isinstance(other, mint) else mint(self.x - other)\n        )\n    \n    def __mul__(self, other):\n        return(\n            mint(self.x * other.x) if isinstance(other, mint) else mint(self.x * other)\n        )\n\n    def __truediv__(self, other):\n        return(\n            mint(self.x * pow(other.x, MOD - 2, MOD)) if isinstance(other, mint) else mint(self.x * pow(other, MOD - 2,MOD))\n        )\n\n    def __pow__(self, other):\n        return(\n            mint(pow(self.x, other.x, MOD)) if isinstance(other, mint) else mint(pow(self.x, other, MOD))\n        )\n\n\n    __radd__ = __add__\n\n    def __rsub__(self, other):\n        return (\n            mint(other.x - self.x) if isinstance(other, mint) else mint(other - self.x)\n        )\n\n    __rmul__ = __mul__\n\n    def __rtruediv__(self, other):\n        return (\n            mint(other.x * pow(self.x, MOD - 2, MOD)) if isinstance(other, mint) else mint(other * pow(self.x, MOD - 2, MOD))\n        )\n\n    def __rpow__(self, other):\n        return (\n            mint(pow(other.x, self.x, MOD)) if isinstance(other, mint) else mint(pow(other, self.x, MOD))\n        )\n\nMAX = 1000005\nfac = [1,1]\nfinv = [1,1]\ninv = [0,1]\ndef COMinit():\n    for i in range(2,MAX):\n        fac.append((fac[-1] * i) % MOD)\n        inv.append((-inv[MOD%i] * (MOD//i)) % MOD)\n        finv.append((finv[-1] * inv[-1]) % MOD)\n\ndef COM(n, k):\n    if(n < k):\n        return 0\n    if(n < 0 or k < 0):\n         return 0\n    return fac[n] * finv[k] * finv[n-k] % MOD \n\ndef P(n, k):\n    return fac[n] * finv[n-k] % MOD \n\nN,M = map(int, input().split())\nCOMinit()\nres = mint(0)\nnow = mint()\nfor i in range(N+1):\n    now = COM(N, i)\n    now *= P(M-i, N-i)\n    if(i%2 == 1):\n        now = -1 * now\n    res += now\nres *= P(M, N)\nprint(res)", "n,m=map(int,input().split())\ni=b=0\na=1\nwhile i<n:c=((m-i)*((m-n+i)*a+(m-i+1)*i*b))%(10**9+7);i+=1;a,b=c,a\nprint(a)", "N,M = map(int,input().split())\nMOD = 10**9+7\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 1\nfor i in range(N):\n    ans *= (M-i)\n    ans %= MOD\n\nps = [1]\nfor i in range(N):\n    ps.append((ps[-1] * (M-N+1+i)) % MOD)\nps.reverse()\n\ntmp = 0\nfor i,p in enumerate(ps):\n    t = p * comb(N,i)\n    if i%2:\n        t *= -1\n    tmp += t\n\nans *= tmp\nans %= MOD\nprint(ans)", "n,m=map(int,input().split())\na,M,d=1,10**9+7,[1]\nfor i in range(1,n+1):\n  d.append(((m-n+i-1)*d[i-1]+(i-1)*d[i-2])%M)\n  a=a*(m-i+1)%M\nprint(a*d[-1]%M)", "# -*- coding: utf-8 -*-\n#nC\u3092p(=10**9+7)\u3067\u5272\u3063\u305f\u3068\u304d\u306e\u3042\u307e\u308a(\u30e2\u30b8\u30e5\u30e9\u9006\u6570)\ndef cmb(n,r,p):\n  if r<0 or n<r:\n    return 0\n  r=min(r,n-r)\n  return facto[n]*factoinv[r]*factoinv[n-r]%p\np=10**9+7\nn,m=map(int,input().split())\n#0,1\u306e\u6642\u306e\u5024\u3092\u3044\u308c\u305fn!\u306e\u30ea\u30b9\u30c8(modp)\nfacto=[1,1]\n#0,1\u306e\u6642\u306e\u5024\u3092\u3044\u308c\u305fn!\u306e\u9006\u5143\u306e\u30ea\u30b9\u30c8(modp)\nfactoinv=[1,1]\n#0,1\u306e\u5834\u5408\u3092\u5165\u308c\u305fn!\u306e\u9006\u5143\u3082\u6c42\u3081\u308b\u305f\u3081\u306b\u4f7f\u3046n\u306e\u9006\u5143\u306e\u30ea\u30b9\u30c8(modp)\ninv=[0,1]\n#2\u304b\u3089\u30b9\u30bf\u30fc\u30c8\nfor i in range(2,m+1):\n  facto.append((facto[-1]*i)%p)\n  inv.append((-inv[p%i]*(p//i))%p)\n  factoinv.append((factoinv[-1]*inv[-1])%p)\nif n==m:\n  kosuub=0\n  for i in range(n+1):\n    kosuub+=(facto[(n-i)]*cmb(n,i,p)*((-1)**i))%p\n  kosuu=(kosuub*facto[(n)])%p\n  print(kosuu)\nelse:\n  kosuub=0\n  for i in range(n+1):\n    kosuub+=(cmb((m-i),(n-i),p)*facto[(n-i)]*cmb(n,i,p)*((-1)**i))%p\n  kosuu=(kosuub*cmb(m,n,p)*facto[n])%p\n  print(kosuu)", "n, m = map(int, input().split())\nmod = 10**9+7\nnums = 5*(10**5) \n \ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n    \ndef nPr(n, r):\n    return g1[n] * g2[n-r] % mod\n \ndef nCr(n, r):\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nans = 0\nfor r in range(n+1):\n    tmp = nCr(n, r)*nPr(m, r)*(nPr(m-r, n-r)**2)%mod\n    ans = (ans+(-1)**r*tmp)%mod\nprint(ans)", "'''\nLet g(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u6700\u591a x \u500b\u4f4d\u7f6e\u4e0d\u540c\u3002\nLet f(x) = \u5e8f\u5217\u5167\u6578\u5b57\u552f\u4e00\uff0c\u4e14\u7d66\u5b9a x \u500b\u4f4d\u7f6e\u6642\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u3002\n\n\u984c\u76ee\u6240\u6c42\u662f C(N, N) f(N)\u3002\n\n\u5176\u4e2d g(x) \u4ee3\u8868\u6709\u81f3\u5c11 N - x \u500b\u4f4d\u7f6e\u662f\u76f8\u540c\u3002\u53ef\u4ee5\u5206\u4e09\u500b\u90e8\u4efd\u586b\u6578\u5b57\uff0c\u6ce8\u610f\u9806\u5e8f\u6703\u5f71\u97ff\uff0c\u6240\u4ee5\u8981\u4e58\u4e0a\u5168\u6392\u5e8f\uff1a\n(1) N - x \u500b\u4f4d\u7f6e\uff08\u6578\u5b57\u5fc5\u9700\u76f8\u540c\uff09\uff1aC(M, N - x) * (N - x)! = P(M, N - x)\n(2) \u5e8f\u5217 A \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\n(3) \u5e8f\u5217 B \u5176\u9918\u4f4d\u7f6e\uff08\u53ef\u4ee5\u96a8\u4fbf\u586b\uff0c\u4f46\u4e0d\u80fd\u7528\u5230 (1) \u7684\u6578\u5b57\uff09\uff1aC(M - (N - x), x) * x! = P(M - (N - x), x)\ng(x) = (1) * (2) * (3)\n\ng(x) \u662f\u300c\u9078\u5b9a 0 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u300c\u9078\u5b9a 1 \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\u3001\u2026\u3001\u300c\u9078\u5b9a x \u500b\u4f4d\u7f6e\uff0c\u4f7f\u9019\u4e9b\u4f4d\u7f6e\u4e0d\u540c\u7684\u65b9\u6cd5\u6578\u300d\uff0c\u5373\ng(x) = C(x, 0) f(0) + C(x, 1) f(1) + ... + C(x, x) f(x)\n     = sum( C(x, i) * f(i) for i in [0, x] )\n\u6839\u64da\u4e8c\u9805\u5f0f\u53cd\u6f14\uff0c\u5f97\u5230\nf(x) = sum( (-1) ** (x - i) * C(x, i) * g(i) for i in [0, x] )\n'''\n\nclass CombMod:\n    def __init__(self, V, p):\n        self.fact = [1] * V\n        self.finv = [1] * V\n        for i in range(1, V):\n            self.fact[i] = self.fact[i - 1] * i % p\n        self.finv[-1] = pow(self.fact[-1], p - 2, p)\n        for i in range(V - 2, 0, -1):\n            self.finv[i] = self.finv[i + 1] * (i + 1) % p\n        self.p = p\n        \n    def fact(self, a):\n        return self.fact[a]\n    \n    def finv(self, a):\n        return self.finv[a]\n\n    def comb(self, a, b):\n        return self.fact[a] * self.finv[b] % self.p * self.finv[a - b] % self.p\n        \n    def perm(self, a, b):\n        return self.fact[a] * self.finv[a - b] % self.p\n    \n    def hcomb(self, a, b):\n        return self.comb(a + b - 1, b)\n\n\nN, M = list(map(int, input().split()))\nmod = 10**9 + 7\ntool = CombMod(max(N, M) + 10, mod)\n\nf_N = 0\nfor i in range(0, N + 1):\n    p1 = tool.perm(M, N - i)\n    p2 = tool.perm(M - (N - i), i)\n    g_i = p1 * p2 % mod * p2 % mod\n    val = (-1)**((N - i) % 2) * tool.comb(N, i) % mod * g_i % mod\n    f_N = (f_N + val) % mod\nans = tool.comb(N, N) * f_N % mod\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\nN = 10 ** 6\n\n#\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv_t = [0]+[1]\nfor i in range(2, N):\n    inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]\n\n#\u968e\u4e57\u8a08\u7b97\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n    kai.append(kai[-1] * i % mod)\n    rev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n, r):\n    return kai[n] * rev_kai[r] * rev_kai[n-r] % mod\n\ndef prm(n, r):\n    return kai[n] * rev_kai[n-r] % mod\n\nans = 0\ntmp = 1\n\n# \u5305\u9664\u539f\u7406\u306b\u5f93\u3063\u3066\u5834\u5408\u306e\u6570\u3092\u6c42\u3081\u308b\nfor k in range(n+1):\n    #\u3000!(Ai != Bi)\u3001\u3064\u307e\u308a\u3000Ai == Bi\u3000\u3068\u3044\u3046\u6761\u4ef6N\u500b\u304b\u3089K\u500b\u9078\u3073\n    # \u305d\u308c\u3089\u306e\u6761\u4ef6\u306e\u300c\u304b\u3064\u300d\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u5834\u5408\u306e\u6570\u8003\u3048\u308b\n    ans += tmp * cmb(n, k) * prm(m-k, n-k) % mod # K\u306fA\u3068\u4e00\u81f4\u3059\u308b\u3088\u3046\u306b\u6c7a\u3081\u3066\u3001\u6b8b\u308a\u306eN-K\u7b87\u6240\u3092\u81ea\u7531\u306b\u6c7a\u3081\u308b\n    ans %= mod\n    tmp *= -1\n\n# A\u306e\u9078\u3073\u65b9\u3092\u304b\u3051\u308b\nans *= prm(m, n)\nans %= mod\n\nprint(ans)\n\n", "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\nn_ = 5 * 10**5\nmod = 10**9 + 7\nfun = [1] * (n_ + 1)\nfor i in range(1, n_ + 1):\n    fun[i] = fun[i - 1] * i % mod\nrev = [1] * (n_ + 1)\nrev[n_] = pow(fun[n_], mod - 2, mod)\nfor i in range(n_ - 1, 0, -1):\n    rev[i] = rev[i + 1] * (i + 1) % mod\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fun[n] * rev[r] % mod * rev[n - r] % mod\n\ndef modinv(x, mod):\n    a, b = x, mod\n    u, v = 1, 0\n    while b:\n        t = a // b\n        a -= t * b; a, b = b, a\n        u -= t * v; u, v = v, u\n    return u % mod\n\ndef solve():\n    n, m = nm()\n    s = 0\n    v = 1\n    for i in range(n+1):\n        s = (s + v * nCr(n, i) * nCr(m, i) * fun[i] % mod * (nCr(m-i, n-i) * fun[n-i] % mod)**2) % mod\n        v *= -1\n    print(s)\n    return\n\nsolve()\n", "n,m=map(int,input().split())\ni,d=0,[1]*(n+1)\nwhile i<n:\n  d[i+1]=((m-i)*((m-n+i)*d[i]+i*d[i-1]*(m-i+1)))%(10**9+7);i+=1\nprint(d[-1])", "#atcoder template\ndef main():\n    import sys\n    imput = sys.stdin.readline\n    #\u6587\u5b57\u5217\u5165\u529b\u306e\u6642\u306f\u4e0a\u8a18\u306ferror\u3068\u306a\u308b\u3002\n    #\u3053\u3053\u306b\u30b3\u30fc\u30c9\n    #input\n    n, m = list(map(int, input().split()))\n\n    #output\n    mod = pow(10, 9) + 7\n\n    n_ = 5 * pow(10, 5) + 5\n    fun = [1] * (n_+1)\n    for i in range(1, n_+1):\n        fun[i] = fun[i-1] * i % mod\n    rev = [1] * (n_+1)\n    rev[n_] = pow(fun[n_], mod-2, mod)\n    for i in range(n_-1, 0, -1):\n        rev[i] = rev[i+1] * (i+1) % mod\n    def cmb(n,r):\n        if n < 0 or r < 0 or r > n: return 0\n        return fun[n] * rev[r] % mod * rev[n-r] % mod\n    def perm(n, r):\n        if n < 0 or r < 0 or r > n: return 0\n        return fun[n] * rev[n-r] % mod\n\n    #A\u30921, 2, ..., n\u3068\u3059\u308b\u3002\n    #\u6c42\u3081\u308b\u5199\u50cf\u306e\u7dcf\u6570\u3092s(n, m)\u3068\u3059\u308b\u3002\n    #s(n, m) = sum(k=0, n)(cmb(n, k)* (-1)^k * cmb(m-k, n-k)*(n-k)!)\n\n    import math\n    answer = 0\n    for i in range(n+1):\n        temp = perm(n, i) * cmb(m, i) * pow(perm(m-i, n-i), 2)\n        temp %= mod\n        if i % 2 == 0:\n            answer += temp\n        else:\n            answer -= temp\n    print((answer % mod))\n\n    #N = 1\u306e\u3068\u304d\u306a\u3069corner case\u3092\u78ba\u8a8d\uff01\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\na,M,d=1,10**9+7,[1]\nfor i in range(n):\n  d.append(((m-n+i)*d[i]+i*d[i-1])%M)\n  a=a*(m-i)%M\nprint(a*d[-1]%M)", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 10**6\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n", "mod = pow(10,9)+7\nn,m = map(int,input().split())\nans = 0\ninv = [0,1]\nfact = [1,1]\nifact = [1,1]\nfor i in range(2,m+1):\n    inv.append(inv[mod%i]*(mod-int(mod/i))%mod)\n    fact.append(i*fact[-1]%mod)\n    ifact.append(ifact[-1]*inv[i]%mod)\n\ndef combi(a,b):\n    return fact[a]*ifact[b]*ifact[a-b]%mod\ndef permi(a,b):\n    return fact[a]*ifact[a-b]%mod\n\nfor i in range(n+1):\n    now = combi(n,i)\n    now *= permi(m-i,n-i)\n    now %= mod\n    ans += now*(-1)**(i&1)\n    ans %= mod\nans *= permi(m,n)\nans %= mod\nprint(ans)", "#test\nclass Combi():\n    def __init__(self, N, mod):\n        self.power = [1 for _ in range(N+1)]\n        self.rev = [1 for _ in range(N+1)]\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n\n    def com(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n\n    def pom(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n\n\ndef main():\n    N, M = map(int, input().split())\n    mod = 10**9+7\n    c = Combi(5*10**5, mod)\n    ans = c.pom(M, N)**2 % mod\n    for k in range(1, N+1):\n        s = (-1)**((k-1) % 2)\n        t = c.com(N, k)\n        u = c.pom(M-k, N-k)**2\n        v = c.pom(M, k)\n        ans -= s*t*u*v\n        ans = ans % mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10**9 + 7\nfac = [1,1] # \u968e\u4e57 n!\ninv = [0,1] # \u9006\u5143 1/n\nfinv = [1,1] # \u9006\u5143\u306e\u968e\u4e57 (n^-1)! = (1/n)!\n\ndef finv_init(n, m):\n    for i in range(2, n+1):\n        fac.append( (fac[-1] * i ) % m )\n        inv.append( (-inv[m%i] * (m//i)) % m )\n        finv.append( (finv[-1] * inv[-1]) % m )\n\ndef nPr(n, r, m): return fac[n] * finv[n-r] % m\n\nn, m = list(map(int, input().split()))\nfinv_init(m, MOD)\nans = 0\nfor d in range(0, n+1):\n    a = nPr(m-d, n-d, MOD) * nPr(n, d, MOD) * finv[d] % MOD\n    if d & 1: a = -a\n    ans += a; ans %= MOD\nans *= nPr(m, n, MOD)\nprint((ans % MOD))\n", "MOD = 10 ** 9 + 7\ntable_len = 500010\n\nfac = [1, 1]\nfor i in range(2, table_len):\n    fac.append(fac[-1] * i % MOD)\n    \nfinv = [0] * table_len\nfinv[-1] = pow(fac[-1], MOD - 2, MOD)\nfor i in range(table_len-1, -1, -1):\n    finv[i-1] = finv[i] * i % MOD\n\ndef comb(n, k):\n    return fac[n] * finv[k] * finv[n-k] % MOD\n\ndef perm(n, k):\n    return fac[n] * finv[n-k] % MOD\n\nN, M = list(map(int, input().split()))\n\nprint((sum( ((-1)**k * comb(N, k) * perm(M, k) * perm(M-k, N-k)**2 % MOD ) for k in range(N+1)) % MOD))\n", "n,m=map(int,input().split())\nM,d=10**9+7,[1]*(n+1)\nfor i in range(n):\n  d[i+1]=((m-i)*((m-n+i)*d[i]+i*d[i-1]*(m-i+1)))%M\nprint(d[-1])", "# E - NEQ\n\nN, M = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\n\nfor i in range(2, M+1):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD)\n\nfixed = (fac[N] * fac[M] * pow(finv[M-N], 2, MOD)) % MOD\n\ndef f(k):\n    return (fac[M-k] * finv[k] * finv[N-k]) % MOD\n\nans = 0\nfor i in range(N+1):\n    ans = (ans + fixed * f(i) * pow(-1, i)) % MOD\n\nprint(ans)", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nfrom decimal import Decimal\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\nN,M = list(map(int,input().split()))\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nMOD = 10**9+7\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nfor i in range(2, M+1):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD) \ndef comb_mod(n, r, m):  #nCr mod m\n    if (n<0 or r<0 or n<r): return 0\n    r = min(r, n-r)\n    return fac[n] * finv[n-r] * finv[r] % m\n\ndef chofuku(n,r): # nHr mod MOD \u306e\u8a08\u7b97\n    return comb_mod(n+r-1,r)\n \ndef nPr(n,r,m): #nPr mod m \u306e\u8a08\u7b97\n    return fac[n]*finv[n-r]%m\nans = 0\nfor i in range(1,N+1):\n    if i % 2 == 1:\n        flag = 1\n    else:\n        flag = -1\n    s = flag*comb_mod(N,i,MOD)*nPr(M-i,N-i,MOD)\n    ans += s\n    if ans > MOD:\n        ans %= MOD\nans1 = 1\nfor i in range(N):\n    ans1 *= (M-i)\n    ans1 %= MOD\nans2 = (ans1*ans1)%MOD\nans3 = (ans*nPr(M,N,MOD)) %MOD\nprint(((ans2-ans3)%MOD))\n", "n,m=map(int,input().split())\ni=b=0\na=1\nwhile i<n:a,b=((m-i)*((m-n+i)*a+i*(m-i+1)*b))%(10**9+7),a;i+=1\nprint(a)", "MOD = 10**9 + 7\n\nclass Combinatorics:\n    def __init__(self, N, mod):\n        '''\n        Preprocess for calculating binomial coefficients nCr (0 <= r <= n, 0 <= n <= N)\n        over the finite field Z/(mod)Z.\n        Input:\n            N (int): maximum n\n            mod (int): a prime number. The order of the field Z/(mod)Z over which nCr is calculated.\n        '''\n        self.mod = mod\n        self.fact = [0] * (N+1)           # n!\n        self.inverse = [None] + [0] * N   # inverse of n in the field Z/(MOD)Z\n        self.fact_inverse = [0] * (N+1)   # inverse of n! in the field Z/(MOD)Z\n        \n        # preprocess\n        self.fact[0] = self.fact[1] = 1\n        self.fact_inverse[0] = self.fact_inverse[1] = 1\n        self.inverse[1] = 1\n        for i in range(2, N+1):\n            self.fact[i] = i * self.fact[i-1] % self.mod\n            q, r = divmod(self.mod, i)\n            self.inverse[i] = (- (q % self.mod) * self.inverse[r]) % self.mod\n            self.fact_inverse[i] = self.inverse[i] * self.fact_inverse[i-1] % self.mod\n    \n    def perm(self, n, r):\n        '''\n        Calculate nPr = n! / (n-r)! % mod\n        '''\n        if n < r or n < 0 or r < 0: return 0\n        else: return (self.fact[n] * self.fact_inverse[n-r]) % self.mod\n    \n    def binom(self, n, r):\n        '''\n        Calculate nCr = n! /(r! (n-r)!) % mod\n        '''\n        if n < r or n < 0 or r < 0: return 0\n        else: return self.fact[n] * (self.fact_inverse[r] * self.fact_inverse[n-r] % self.mod) % self.mod\n        \n    def hom(self, n, r):\n        '''\n        Calculate nHr = {n+r-1}Cr % mod.\n        Assign r objects to one of n classes.\n        Arrangement of r circles and n-1 partitions:\n            o o o | o o | | | o | | | o o | | o\n        '''\n        if n == 0 and r > 0: return 0\n        if n >= 0 and r == 0: return 1\n        return self.binom(n + r - 1, r)\n\nN, M = map(int, input().split())\ncom = Combinatorics(M, MOD)\nans = 0\nfor i in range(N+1):\n    temp = com.perm(M, N)\n    temp *= com.binom(N, i); temp %= MOD\n    temp *= com.perm(M-i, N-i); temp %= MOD\n    ans += ((-1)**i) * temp; ans %= MOD\nprint(ans)"]
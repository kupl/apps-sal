["3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    if N == 2:\n        return [0, 1]\n\n    degv = [set() for _ in range(5)]\n    for i in range(M):\n        d = len(G[i])\n        if d == 0 or d >= 5:\n            return []\n        degv[d].add(i)\n\n    layer_vcount = 1 << (N - 1)\n    vs = degv[1]\n    levels = bytearray(M)\n    ans = []\n    for level in range(1, N):\n        #dprint('level', level, [x for x in levels])\n        #dprint('vs', vs)\n        #dprint('layer_vcount', layer_vcount)\n\n        if len(vs) not in (layer_vcount - 1, layer_vcount):\n            return []\n        if len(vs) == layer_vcount - 1:\n            if ans:\n                return []\n            if level == 1:\n                sp_deg_off = -1\n            else:\n                sp_deg_off = 1\n        else:\n            sp_deg_off = 0\n        #dprint('sp_deg_off', sp_deg_off)\n\n        ndeg = 3 if level < N - 1 else 2\n        us = set()\n        ss = set()\n\n        for v in vs:\n            #dprint('v', v)\n            levels[v] = level\n            p = None\n            for u in G[v]:\n                if levels[u] == 0:\n                    if p is not None:\n                        return []\n                    p = u\n                    break\n            #dprint('  p', p)\n            if p is None:\n                return []\n            deg = len(G[p])\n            #dprint('  deg', deg)\n\n            if deg == ndeg:\n                us.add(p)\n            elif deg == ndeg + sp_deg_off:\n                ss.add(p)\n            elif sp_deg_off == 0 and deg == ndeg + 1:\n                ss.add(p)\n            else:\n                return []\n\n        #dprint('us', us)\n        #dprint('ss', ss)\n\n        if sp_deg_off != 0:\n            if len(ss) != 1:\n                return []\n            (sp,) = list(ss)\n            ans = [sp]\n            us.add(sp)\n\n        if sp_deg_off == 0:\n            if level == N - 2:\n                if ss:\n                    return []\n                if not ans:\n                    li = list(us)\n                    li.sort()\n                    return li\n            if len(ss) > 1:\n                return []\n\n        vs = us\n        layer_vcount >>= 1\n\n    return ans\n\n\ndef main():\n    N = int(inp())\n    M = (1 << N) - 2\n    G = [[] for _ in range(M)]\n    for _ in range(M - 1):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    print(len(ans))\n    if ans:\n        print(*[v + 1 for v in ans])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    if N == 2:\n        return [0, 1]\n\n    degv = [set() for _ in range(5)]\n    for i in range(M):\n        d = len(G[i])\n        if d == 0 or d >= 5:\n            return []\n        degv[d].add(i)\n\n    layer_vcount = 1 << (N - 1)\n    vs = degv[1]\n    levels = [0] * M\n    ans = []\n    for level in range(1, N):\n        #dprint('level', level, [x for x in levels])\n        #dprint('vs', vs)\n        #dprint('layer_vcount', layer_vcount)\n\n        if len(vs) not in (layer_vcount - 1, layer_vcount):\n            return []\n        if len(vs) == layer_vcount - 1:\n            if ans:\n                return []\n            if level == 1:\n                sp_deg_off = -1\n            else:\n                sp_deg_off = 1\n        else:\n            sp_deg_off = 0\n        #dprint('sp_deg_off', sp_deg_off)\n\n        ndeg = 3 if level < N - 1 else 2\n        us = set()\n        ss = set()\n\n        for v in vs:\n            #dprint('v', v)\n            levels[v] = level\n            p = None\n            for u in G[v]:\n                if levels[u] == 0:\n                    if p is not None:\n                        return []\n                    p = u\n                    break\n            #dprint('  p', p)\n            if p is None:\n                return []\n            deg = len(G[p])\n            #dprint('  deg', deg)\n\n            if deg == ndeg:\n                us.add(p)\n            elif deg == ndeg + sp_deg_off:\n                ss.add(p)\n            elif sp_deg_off == 0 and deg == ndeg + 1:\n                ss.add(p)\n            else:\n                return []\n\n        #dprint('us', us)\n        #dprint('ss', ss)\n\n        if sp_deg_off != 0:\n            if len(ss) != 1:\n                return []\n            (sp,) = list(ss)\n            ans = [sp]\n            us.add(sp)\n\n        if sp_deg_off == 0:\n            if level == N - 2:\n                if ss:\n                    return []\n                if not ans:\n                    li = list(us)\n                    li.sort()\n                    return li\n            if len(ss) > 1:\n                return []\n\n        vs = us\n        layer_vcount >>= 1\n\n    return ans\n\n\ndef main():\n    N = int(inp())\n    M = (1 << N) - 2\n    G = [[] for _ in range(M)]\n    for _ in range(M - 1):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    print(len(ans))\n    if ans:\n        print(*[v + 1 for v in ans])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
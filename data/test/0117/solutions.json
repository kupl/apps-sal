["#\u5199\u7d4c\n#https://atcoder.jp/contests/abc168/submissions/14421546\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\nfrom bisect import bisect_left, bisect_right\nINF = 10 **18\n\ndef resolve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for i in range(n)]\n    b = [list(map(int, input().split())) for i in range(m)]\n \n    X = {-INF, INF}\n    Y = {-INF, INF}\n    for i in a:\n        Y.add(i[2])\n    for i in b:\n        X.add(i[0])\n \n    X = list(sorted(X))\n    Y = list(sorted(Y))\n    n = len(X) - 1\n    m = len(Y) - 1\n    wallx = [[False] * m for i in range(n)]\n    wally = [[False] * m for i in range(n)]\n \n    for x1, x2, y1 in a:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        x2 = bisect_right(X, x2) - 1\n        for i in range(x1, x2):\n            wally[i][y1] = True\n \n    for x1, y1, y2 in b:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        y2 = bisect_right(Y, y2) - 1\n        for i in range(y1, y2):\n            wallx[x1][i] = True\n \n    cow = [[False] * m for i in range(n)]\n    cx = bisect_right(X, 0) - 1\n    cy = bisect_right(Y, 0) - 1\n    cow[cx][cy] = True\n    q = [(cx, cy)]\n    ans = 0\n \n    while q:\n        x, y = q.pop()\n        if not x or not y:\n            print(\"INF\")\n            return\n        ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        if x and not wallx[x][y] and not cow[x - 1][y]:\n            cow[x - 1][y] = True\n            q.append((x - 1, y))\n        if y and not wally[x][y] and not cow[x][y - 1]:\n            cow[x][y - 1] = True\n            q.append((x, y - 1))\n        if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\n            cow[x + 1][y] = True\n            q.append((x + 1, y))\n        if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\n            cow[x][y + 1] = True\n            q.append((x, y + 1)) \n    print(ans)\nresolve()", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    from bisect import bisect_left, bisect_right\n\n    INF = 10**18\n\n    n, m = list(map(int, input().split()))\n    a = [list(map(int, input().split())) for i in range(n)]\n    b = [list(map(int, input().split())) for i in range(m)]\n\n    X = {-INF, INF}\n    Y = {-INF, INF}\n    for i in a:\n        Y.add(i[2])\n    for i in b:\n        X.add(i[0])\n\n    X = list(sorted(X))\n    Y = list(sorted(Y))\n    n = len(X) - 1\n    m = len(Y) - 1\n    wallx = [[False] * m for i in range(n)]\n    wally = [[False] * m for i in range(n)]\n\n    for x1, x2, y1 in a:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        x2 = bisect_right(X, x2) - 1\n        for i in range(x1, x2):\n            wally[i][y1] = True\n\n    for x1, y1, y2 in b:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        y2 = bisect_right(Y, y2) - 1\n        for i in range(y1, y2):\n            wallx[x1][i] = True\n\n    cow = [[False] * m for i in range(n)]\n    cx = bisect_right(X, 0) - 1\n    cy = bisect_right(Y, 0) - 1\n    cow[cx][cy] = True\n    q = [(cx, cy)]\n    ans = 0\n\n    while q:\n        x, y = q.pop()\n        if not x or not y:\n            print(\"INF\")\n            return\n        ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        if x and not wallx[x][y] and not cow[x - 1][y]:\n            cow[x - 1][y] = True\n            q.append((x - 1, y))\n        if y and not wally[x][y] and not cow[x][y - 1]:\n            cow[x][y - 1] = True\n            q.append((x, y - 1))\n        if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\n            cow[x + 1][y] = True\n            q.append((x + 1, y))\n        if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\n            cow[x][y + 1] = True\n            q.append((x, y + 1))\n\n    print(ans)\n\nmain()\n\n\n\n", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    #for x1, x2, y in zip(A, B, C):\n    #    for x in range(x1, x2):\n    #        LineY[x][y] = True\n    for i in range(len(A)):\n        y = C[i]\n        for x in range(A[i], B[i]):\n            LineY[x][y] = True\n\n    #for x, y1, y2 in zip(D, E, F):\n    #    for y in range(y1, y2):\n    #        LineX[x][y] = True\n    for i in range(len(D)):\n        x = D[i]\n        for y in range(E[i], F[i]):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        area += DX[x] * DY[y]\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    #for x1, x2, y in zip(A, B, C):\n    #    for x in range(x1, x2):\n    #        LineY[x][y] = True\n    for i in range(len(A)):\n        y = C[i]\n        for x in range(A[i], B[i]):\n            LineY[x][y] = True\n\n    #for x, y1, y2 in zip(D, E, F):\n    #    for y in range(y1, y2):\n    #        LineX[x][y] = True\n    for i in range(len(D)):\n        x = D[i]\n        for y in range(E[i], F[i]):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n\n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\nfrom numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    LenX = len(X)\n    LenY = len(Y)\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n    \n    visit = [[False] * LenY for _ in range(LenX)]\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    while queue:\n        x, y = queue.pop()\n\n        if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1:\n            area = 0\n            break\n        \n        area += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    #for x1, x2, y in zip(A, B, C):\n    #    for x in range(x1, x2):\n    #        LineY[x][y] = True\n    for i in range(len(A)):\n        y = C[i]\n        for x in range(A[i], B[i]):\n            LineY[x][y] = True\n\n    #for x, y1, y2 in zip(D, E, F):\n    #    for y in range(y1, y2):\n    #        LineX[x][y] = True\n    for i in range(len(D)):\n        x = D[i]\n        for y in range(E[i], F[i]):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n        \n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n        \n        x1 = x - 1\n        if not LineX[x][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y - 1\n        if not LineY[x][y] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n        x1 = x + 1\n        if not LineX[x1][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y + 1\n        if not LineY[x][y1] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    #A = A.tolist()\n    #B = B.tolist()\n    #C = C.tolist()\n    #D = D.tolist()\n    #E = E.tolist()\n    #F = F.tolist()\n    #X = X.tolist()\n    #Y = Y.tolist()\n    #DX = DX.tolist()\n    #DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n        \n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n        \n        x1 = x - 1\n        if not LineX[x][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y - 1\n        if not LineY[x][y] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n        x1 = x + 1\n        if not LineX[x1][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y + 1\n        if not LineY[x][y1] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n\n    while queue:\n        x, y = queue.pop()\n\n        if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1:\n            area = 0\n            break\n        \n        #area += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        area += DX[x] * DY[y]\n\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n\n    q_pop = queue.pop\n    q_append = queue.append\n    \n    while queue:\n        x, y = q_pop()\n        \n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n        \n        x1 = x - 1\n        if not LineX[x][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            q_append((x1, y))\n        y1 = y - 1\n        if not LineY[x][y] and not visit[x][y1]:\n            visit[x][y1] = True\n            q_append((x, y1))\n        x1 = x + 1\n        if not LineX[x1][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            q_append((x1, y))\n        y1 = y + 1\n        if not LineY[x][y1] and not visit[x][y1]:\n            visit[x][y1] = True\n            q_append((x, y1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "import bisect\nimport sys\n\nlower_bound = bisect.bisect_left\nupper_bound = bisect.bisect_right\nINF = 0x3fffffff\n\nn, m = list(map(int, input().split()))\na = [list(map(int, input().split())) for i in range(n)]\nb = [list(map(int, input().split())) for i in range(m)]\n\nX = {-INF, INF}\nY = {-INF, INF}\nfor i in a:\n    Y.add(i[2])\nfor i in b:\n    X.add(i[0])\n\nX = list(sorted(X))\nY = list(sorted(Y))\nn = len(X) - 1\nm = len(Y) - 1\nwallx = [[False] * m for i in range(n)]\nwally = [[False] * m for i in range(n)]\n\nfor x1, x2, y1 in a:\n    x1 = lower_bound(X, x1)\n    y1 = lower_bound(Y, y1)\n    x2 = upper_bound(X, x2) - 1\n    for i in range(x1, x2):\n        wally[i][y1] = True\n\nfor x1, y1, y2 in b:\n    x1 = lower_bound(X, x1)\n    y1 = lower_bound(Y, y1)\n    y2 = upper_bound(Y, y2) - 1\n    for i in range(y1, y2):\n        wallx[x1][i] = True\n\ncow = [[False] * m for i in range(n)]\ncx = upper_bound(X, 0) - 1\ncy = upper_bound(Y, 0) - 1\ncow[cx][cy] = True\nq = [(cx, cy)]\nans = 0\n\nwhile q:\n    x, y = q.pop()\n    if not x or not y:\n        print(\"INF\")\n        return\n    ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n    if x and not wallx[x][y] and not cow[x - 1][y]:\n        cow[x - 1][y] = True\n        q.append((x - 1, y))\n    if y and not wally[x][y] and not cow[x][y - 1]:\n        cow[x][y - 1] = True\n        q.append((x, y - 1))\n    if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\n        cow[x + 1][y] = True\n        q.append((x + 1, y))\n    if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\n        cow[x][y + 1] = True\n        q.append((x, y + 1))\n\nprint(ans)\n", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n\n    while queue:\n        x, y = queue.pop()\n\n        if x == 0 or x == LenX - 1 or y == 0 or y == LenY - 1:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    #X = np.unique(np.concatenate([D, [-INF, 0, INF]]))\n    #Y = np.unique(np.concatenate([C, [-INF, 0, INF]]))\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n\n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n\n        if not LineX[x][y] and not visit[x - 1][y]:\n            visit[x - 1][y] = True\n            queue.append((x - 1, y))\n        if not LineY[x][y] and not visit[x][y - 1]:\n            visit[x][y - 1] = True\n            queue.append((x, y - 1))\n        if not LineX[x + 1][y] and not visit[x + 1][y]:\n            visit[x + 1][y] = True\n            queue.append((x + 1, y))\n        if not LineY[x][y + 1] and not visit[x][y + 1]:\n            visit[x][y + 1] = True\n            queue.append((x, y + 1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()", "#168 - F\nimport sys\nimport numpy as np\n#from numba import njit\n\n\ndef main():\n    N, M = list(map(int, sys.stdin.buffer.readline().split()))\n    LineData = np.int64(sys.stdin.buffer.read().split())\n\n    INF = 10**9 + 1\n\n    LineData = LineData.reshape(-1, 3)\n    A, B, C = LineData[:N].T\n    D, E, F = LineData[N:].T\n    X = np.unique(np.concatenate([D, [-INF, INF]]))\n    Y = np.unique(np.concatenate([C, [-INF, INF]]))\n    A = np.searchsorted(X, A)\n    B = np.searchsorted(X, B, 'right') - 1\n    C = np.searchsorted(Y, C)\n    D = np.searchsorted(X, D)\n    E = np.searchsorted(Y, E)\n    F = np.searchsorted(Y, F, 'right') - 1\n\n    area = cal_area(A, B, C, D, E, F, X, Y)\n\n    if area == 0:\n        print(\"INF\")\n    else:\n        print(area)\n\n\n#@njit\ndef cal_area(A, B, C, D, E, F, X, Y):\n    x = np.searchsorted(X, 0, 'right') - 1\n    y = np.searchsorted(Y, 0, 'right') - 1\n\n    DX = X[1:] - X[:-1]\n    DY = Y[1:] - Y[:-1]\n\n    A = A.tolist()\n    B = B.tolist()\n    C = C.tolist()\n    D = D.tolist()\n    E = E.tolist()\n    F = F.tolist()\n    X = X.tolist()\n    Y = Y.tolist()\n    DX = DX.tolist()\n    DY = DY.tolist()\n\n    LenX = len(X)\n    LenY = len(Y)\n\n    visit = [[False] * LenY for _ in range(LenX)]\n    visit[x][y] = True\n    area = 0\n    queue = [(x, y)]\n\n    LineX = [[False] * LenY for _ in range(LenX)]\n    LineY = [[False] * LenY for _ in range(LenX)]\n\n    for x1, x2, y in zip(A, B, C):\n        for x in range(x1, x2):\n            LineY[x][y] = True\n    #for i in range(len(A)):\n    #    y = C[i]\n    #    for x in range(A[i], B[i]):\n    #        LineY[x][y] = True\n\n    for x, y1, y2 in zip(D, E, F):\n        for y in range(y1, y2):\n            LineX[x][y] = True\n    #for i in range(len(D)):\n    #    x = D[i]\n    #    for y in range(E[i], F[i]):\n    #        LineX[x][y] = True\n\n    LenX -= 1\n    LenY -= 1\n    \n    while queue:\n        x, y = queue.pop()\n        \n        if x == 0 or x == LenX or y == 0 or y == LenY:\n            area = 0\n            break\n        \n        area += DX[x] * DY[y]\n        \n        x1 = x - 1\n        if not LineX[x][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y - 1\n        if not LineY[x][y] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n        x1 = x + 1\n        if not LineX[x1][y] and not visit[x1][y]:\n            visit[x1][y] = True\n            queue.append((x1, y))\n        y1 = y + 1\n        if not LineY[x][y1] and not visit[x][y1]:\n            visit[x][y1] = True\n            queue.append((x, y1))\n\n    return area\n\n\ndef __starting_point():\n\tmain()\n\nreturn\n\n__starting_point()"]
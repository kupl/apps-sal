["from collections import deque\nimport sys\n\nN_MAX = 200000 + 5\n\nH, W, K = list(map(int, input().split()))\nsth, stw, glh, glw = list(map(int, input().split()))\n\nINF = 10**6 * K\n\ndp = [[INF for _ in range(W+2)] for _ in range(H+2)]\n\ndp[0] = [-1]*(W+2)\ndp[H+1] = [-1]*(W+2)\nfor h in range(1, H+1):\n    s = sys.stdin.readline()\n    dp[h][0] = -1\n    dp[h][W+1] = -1\n    for w in range(1, W+1):\n        if s[w-1] == \"@\":\n            dp[h][w] = -1\n\n\n# Seen = [[INF]*W for _ in range(H)]\nXY = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n\n\ndef bfs(sth, stw, glh, glw):\n    next_q = deque()\n    next_q.append((sth, stw, 0))\n    dp[sth][stw] = 0\n\n    while len(next_q) != 0:\n        # \u30ad\u30e5\u30fc\u53d6\u308a\u51fa\u3057(\u5148\u982d)\n        h, w, c = next_q.popleft()\n        for dh, dw in XY:\n            for sk in range(1, K+1):\n                hs, ws = h + dh*sk, w + dw*sk\n                if dp[hs][ws] == -1:\n                    break\n                if dp[hs][ws] == INF:\n                    next_q.append((hs, ws, c+1))\n                    dp[hs][ws] = c + 1\n                elif dp[hs][ws] <= c:\n                    break\n                if hs == glh and ws == glw:\n                    return c + 1\n    return -1\n\n\ndef main():\n    ret = bfs(sth, stw, glh, glw)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport sys\n\n\ndef bfs(x1, y1, d):\n    q = deque()\n    q.append((d, x1, y1))\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        M[x1][y1] = d\n\n        if [x1, y1] == [xg, yg]:\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n\n                if (0 <= x2 < H) and (0 <= y2 < W):\n                    if m[x2][y2] == \"@\":\n                        break\n                    elif M[x2][y2] == -1:\n                        M[x2][y2] = d + 1\n                        q.append((d + 1, x2, y2))  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif M[x2][y2] < d + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nxs, ys, xg, yg = list(map(int, input().split()))\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(xs, ys, 0)\n\nprint((M[xg][yg]))\n", "from collections import deque\nimport sys\n\n\ndef bfs(M, sy, sx):\n    queue = deque([[xs, ys]])\n    M[sy][sx] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        x1, y1 = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [x1, y1] == [xg, yg]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return M[x1][y1]\n        \n        for dx, dy in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            for k in range(1, K + 1):\n                new_x = x1 + dx * k\n                new_y = y1 + dy * k\n\n                if (0 <= new_x < H) and (0 <= new_y < W):\n                    if m[new_x][new_y] == \"@\":\n                        break\n                    elif M[new_x][new_y] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        M[new_x][new_y] = M[x1][y1] + 1\n                        queue.append([new_x, new_y])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif M[new_x][new_y] < M[x1][y1] + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nxs, ys, xg, yg = list(map(int, input().split()))\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(M, xs, ys)\n\nprint((M[xg][yg]))\n", "h,a,*m=open(0)\nh,w,k,a,b,f,g=map(int,(h+a).split())\nd=[I:=h*w]*I\nm+=d,\nq=[a:=~w+a*w+b]\nd[a]=1\nfor s in q:\n for y,x in(1,0),(-1,0),(0,1),(0,-1):\n  for z in range(k):\n   if'.'!=m[(i:=s//w+y*~z)][(j:=s%w+x*~z)]or d[s]>=d[(t:=i*w+j)]:break\n   if-~d[s]<d[t]:q+=t,;d[t]=d[s]+1\nprint(d[~w+f*w+g]%I-1)", "def main():\n  ## IMPORT MODULE\n  from collections import deque\n  import sys\n  input=lambda :sys.stdin.readline().rstrip()\n\n  #sys.setrecursionlimit(100000)\n\n  #f_inf=float(\"inf\")\n  #MOD=10**9+7\n  \n  if 'get_ipython' in globals(): \n    ## SAMPLE INPUT\n    h, w, k = 3, 5, 2\n    x1, y1, x2, y2 = 3, 2, 3, 4\n    dist = ['.....', '.@..@', '..@..']\n\n  else:\n    ##INPUT \n    h, w, k = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    dist = [input() for _ in range(h)]\n\n  ## SUBMITION CODES HERE\n  x1-=1\n  y1-=1\n  x2-=1\n  y2-=1\n\n  ans = [[-1]*w for _ in range(h)]\n  ans[x1][y1] = 0\n\n  que = deque()\n  que.append((x1, y1))\n  direction = ((1, 0), (-1, 0), (0, -1), (0, 1))\n  while que:\n    x, y = que.popleft()\n\n    if x == x2 and y == y2:\n      print(ans[x][y]);return\n\n    for dx, dy in direction:\n      for i in range(1, k+1):\n        kx = x + dx*i\n        ky = y + dy*i\n\n        if not(0 <= kx < h and 0 <= ky < w) or dist[kx][ky] == \"@\":\n          break\n\n        if 0 <= ans[kx][ky] <= ans[x][y]:\n          break\n\n        if ans[kx][ky] == -1:\n          que.append((kx, ky))\n\n        ans[kx][ky] = ans[x][y]+1\n\n  print(-1)\n\nmain()", "from collections import*\nz,v,a=input,range,print\nh,w,k=map(int,z().split());r,s,t,u=map(lambda x:int(x)-1,z().split());b=[z()for _ in v(h)];l=[[-1]*w for _ in v(h)];l[r][s]=0;d=deque([(r,s)])\nwhile d:\n  x,y=d.popleft();j=l[x][y]\n  if(x==t)&(y==u):(a(j));return\n  for e,f in[[1,0],[-1,0],[0,-1],[0,1]]:\n    for i in v(1,k+1):\n      p,q=x+e*i,y+f*i\n      if not((0<=p<h)&(0<=q<w))or b[p][q]==\"@\" or 0<=l[p][q]<=j:break\n      if l[p][q]<0:d+=[(p,q)];l[p][q]=j+1\na(-1)\n", "from collections import deque\n\nH, W, K = list(map(int, input().split()))\nsx, sy, tx, ty = [int(a) - 1 for a in input().split()]\nINF = 10**18\n\nA = [input() for _ in range(H)]\n\nminDist = [[INF] * W for _ in range(H)]\nminDist[sx][sy] = 0\nque = deque([(0, sx, sy)])\n\nwhile que:\n    dist, nx, ny = que.popleft()\n    if nx == tx and ny == ty:\n        break\n\n    for i in range(1, K + 1):\n        if nx + i >= H:\n            break\n        if minDist[nx + i][ny] <= dist or A[nx + i][ny] == '@':\n            break\n        if minDist[nx + i][ny] > dist + 1:\n            minDist[nx + i][ny] = dist + 1\n            que.append((dist + 1, nx + i, ny))\n    for i in range(1, K + 1):\n        if nx - i < 0:\n            break\n        if minDist[nx - i][ny] <= dist or A[nx - i][ny] == '@':\n            break\n        if minDist[nx - i][ny] > dist + 1:\n            minDist[nx - i][ny] = dist + 1\n            que.append((dist + 1, nx - i, ny))\n    for i in range(1, K + 1):\n        if ny + i >= W:\n            break\n        if minDist[nx][ny + i] <= dist or A[nx][ny + i] == '@':\n            break\n        if minDist[nx][ny + i] > dist + 1:\n            minDist[nx][ny + i] = dist + 1\n            que.append((dist + 1, nx, ny + i))\n    for i in range(1, K + 1):\n        if ny - i < 0:\n            break\n        if minDist[nx][ny - i] <= dist or A[nx][ny - i] == '@':\n            break\n        if minDist[nx][ny - i] > dist + 1:\n            minDist[nx][ny - i] = dist + 1\n            que.append((dist + 1, nx, ny - i))\n\nans = minDist[tx][ty]\nprint((ans if ans < INF else -1))\n", "h,a,*m=open(0)\nh,w,k,a,b,f,g=map(int,(h+a).split())\nd=[I:=h*w]*I\nm+=d,\nq=[a:=~w+a*w+b]\nd[a]=1\nfor s in q:\n for y,x in(1,0),(-1,0),(0,1),(0,-1):\n  for z in range(k):\n   if'.'!=m[(i:=s//w+y*~z)][(j:=s%w+x*~z)]or(p:=d[s]+1)>d[(t:=i*w+j)]:break\n   if d[t]>p:q+=t,;d[t]=p\nprint(d[~w+f*w+g]%I-1)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom heapq import heapify, heappush as hpush, heappop as hpop\nH, W, K = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nX = [1] * (W + 2)\nfor _ in range(H):\n    X += [1] + [1 if a == \"@\" else 0 for a in input()] + [1]\nX += [1] * (W + 2)\nX += X[:]\nH, W = H+2, W+2\nHW = H * W\ns, t = x1 * W + y1, x2 * W + y2\nss, tt = s + HW, t + HW\ndef dijkstra():\n    n = 2 * H * W\n    h = [(0, s), (0, ss)]\n    D = [-1] * n\n    done = [0] * n\n    D[s] = 0\n    D[ss] = 0\n    while h:\n        d, i = hpop(h)\n        done[i] = 1\n        if i < HW:\n            for j in (i+1, i-1):\n                nd = d + 1\n                if X[j]: continue\n                if D[j] < 0 or D[j] > nd:\n                    if done[j] == 0:\n                        hpush(h, (nd, j))\n                        D[j] = nd\n        else:\n            for j in (i+W, i-W):\n                nd = d + 1\n                if X[j]: continue\n                if D[j] < 0 or D[j] > nd:\n                    if done[j] == 0:\n                        hpush(h, (nd, j))\n                        D[j] = nd\n            \n        j = i + HW if i < HW else i - HW\n        nd = (d + K - 1) // K * K\n        if X[j]: continue\n        if D[j] < 0 or D[j] > nd:\n            if done[j] == 0:\n                hpush(h, (nd, j))\n                D[j] = nd\n    return [-(-a//K) for a in (D[t], D[tt]) if a >= 0]\n\ndi = dijkstra()\nprint(min(di) if di else -1)", "#import heapq\nfrom collections import deque\nh,w,k = list(map(int, input().split()))\nx1,y1,x2,y2 = list(map(int, input().split()))\nx1,y1,x2,y2 = x1-1,y1-1,x2-1,y2-1\ndp = [[-1]*w for _ in range(h)]\n#que = []\nque = deque()\nc = [input() for _ in range(h)]\n\ndp[x1][y1] = 0\n#heapq.heappush(que, (dp[x1][y1], [x1,y1]))\nque.append((x1,y1))\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\nwhile que:\n  #p= heapq.heappop(que)[1]\n  #x,y= p[0],p[1]\n  x,y = que.popleft()\n  if (x == x2) & (y == y2):print(dp[x2][y2]);return\n  for i in range(4):\n    for j in range(1,k+1):\n      nx = x + dx[i]*j\n      ny = y + dy[i]*j\n      if not ((0 <= nx < h) & (0 <= ny < w)):break\n      if c[nx][ny] == '@':break\n      if 0 <= dp[nx][ny] <= dp[x][y]:break\n      if dp[nx][ny] == -1:\n        #heapq.heappush(que, (dp[nx][ny], [nx,ny]))\n        que.append((nx,ny))\n      dp[nx][ny] = dp[x][y] + 1\n\nprint(-1)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nH,W,K=map(int,input().split())\nx1,y1,x2,y2=map(int,input().split())\nMAP=[list(input().strip()) for i in range(H)]\n\nfor i in range(H):\n    for j in range(W):\n        if MAP[i][j]==\".\":\n            MAP[i][j]=1<<30\n        else:\n            MAP[i][j]=-1\n\nQ=deque()\nQ.append((x1-1,y1-1))\nMAP[x1-1][y1-1]=0\n\nwhile Q:\n    x,y=Q.pop()\n\n    for i in range(1,K+1):\n        if 0<=x+i<H and 0<=y<W and (MAP[x+i][y]==1<<30 or MAP[x+i][y]>MAP[x][y]):\n            if MAP[x+i][y]==1<<30:\n                MAP[x+i][y]=MAP[x][y]+1\n                Q.appendleft((x+i,y))\n        else:\n            break\n\n    for i in range(1,K+1):\n        if 0<=x-i<H and 0<=y<W and (MAP[x-i][y]==1<<30 or MAP[x-i][y]>MAP[x][y]):\n            if MAP[x-i][y]==1<<30:\n                MAP[x-i][y]=MAP[x][y]+1\n                Q.appendleft((x-i,y))\n        else:\n            break\n\n    for i in range(1,K+1):\n        if 0<=x<H and 0<=y+i<W and (MAP[x][y+i]==1<<30 or MAP[x][y+i]>MAP[x][y]):\n            if MAP[x][y+i]==1<<30:\n                MAP[x][y+i]=MAP[x][y]+1\n                Q.appendleft((x,y+i))\n        else:\n            break\n\n    for i in range(1,K+1):\n        if 0<=x<H and 0<=y-i<W and (MAP[x][y-i]==1<<30 or MAP[x][y-i]>MAP[x][y]):\n            if MAP[x][y-i]==1<<30:\n                MAP[x][y-i]=MAP[x][y]+1\n                Q.appendleft((x,y-i))\n        else:\n            break\nif MAP[x2-1][y2-1]==1<<30:\n    print(-1)\nelse:\n    print(MAP[x2-1][y2-1])", "from collections import deque\nd = [[1, 0], [-1, 0], [0, -1], [0, 1]]\nh, w, k = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nc = [list(input()) for i in range(h)]\nvisited = [[-1] * w for i in range(h)]\nvisited[x1 - 1][y1 - 1] = 0\nQ = deque([(x1 - 1, y1 - 1)])\nwhile Q:\n    nx, ny = Q.popleft()\n    if nx == x2 - 1 and ny == y2 - 1:\n        print(visited[nx][ny]);return\n    for dx, dy in d:\n        for i in range(k):\n            p, q = nx + dx * (i + 1), ny + dy * (i + 1)\n            if not (0 <= p < h and 0 <= q < w) or c[p][q] == \"@\":\n                break\n            if 0 <= visited[p][q] <= visited[nx][ny]:\n                break\n            if visited[p][q] == -1:\n                Q.append((p, q))\n            visited[p][q] = visited[nx][ny] + 1\nprint(-1)", "H,W,K=list(map(int,input().split()))\nx1,y1,x2,y2=[int(x)-1 for x in input().split()]\n\npond=[]\nfor _ in range(H):\n    pond.append(list(input()))\n\ninf=10**7\ncost=[[inf]*W for _ in range(H)]\ncost[x1][y1]=0\nfrom heapq import heapify,heappop,heappush\nhq=[(0,x1,y1)]\n\nwhile hq:\n    t,x,y=heappop(hq)\n    #\u5317\u3078\n    for i in range(1,K+1):\n        if x-i<0 or pond[x-i][y]==\"@\" or cost[x-i][y]<t+1:\n            break\n        if cost[x-i][y]>t+1:\n            cost[x-i][y]=t+1\n            heappush(hq,(t+1,x-i,y))\n    #\u6771\u3078\n    for i in range(1,K+1):\n        if y+i>W-1 or pond[x][y+i]==\"@\" or cost[x][y+i]<t+1:\n            break\n        if cost[x][y+i]>t+1:\n            cost[x][y+i]=t+1\n            heappush(hq,(t+1,x,y+i))\n    #\u5357\u3078\n    for i in range(1,K+1):\n        if x+i>H-1 or pond[x+i][y]==\"@\" or cost[x+i][y]<t+1:\n            break\n        if cost[x+i][y]>t+1:\n            cost[x+i][y]=t+1\n            heappush(hq,(t+1,x+i,y))\n    #\u897f\u3078\n    for i in range(1,K+1):\n        if y-i<0 or pond[x][y-i]==\"@\" or cost[x][y-i]<t+1:\n            break\n        if cost[x][y-i]>t+1:\n            cost[x][y-i]=t+1\n            heappush(hq,(t+1,x,y-i))\n\nif cost[x2][y2]==inf:\n    print((-1))\n    return  \nprint((cost[x2][y2]))\n", "import sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n    \n    h, w, k = map(int, input().split())\n    xs, ys, xg, yg = map(lambda x: int(x)-1, input().split())\n    field = [input() for _ in range(h)]\n\n    inf = 1e7\n\n    dist = [[inf]*w for _ in range(h)]\n    dist[xs][ys] = 0\n    que = deque([(xs, ys)])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    while que:\n        x, y = que.popleft()\n        for i in range(4):\n            nx, ny = x, y\n            for _ in range(k):\n                nx += dx[i]\n                ny += dy[i]\n                if nx < 0 or nx >= h or ny < 0 or ny >= w: break\n                if field[nx][ny] == '@' or dist[nx][ny] <= dist[x][y]: break\n                if dist[nx][ny] > dist[x][y] + 1:\n                    dist[nx][ny] = dist[x][y] + 1\n                    que.append((nx, ny))\n        \n    if dist[xg][yg] == inf:\n        print(-1)\n    else:\n        print(dist[xg][yg])\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nH,W,K = map(int,input().split())\nr1,c1,r2,c2 = map(lambda x:int(x)-1,input().split())\nC = [input() for i in range(H)]\n\ndef solve():\n    from collections import deque\n    dxy = [(0,1),(1,0),(0,-1),(-1,0)]\n    INF = float('inf')\n    dists = [[INF]*W for _ in range(H)]\n    dists[r1][c1] = 0\n    q = deque([(r1,c1)])\n    while q:\n        y,x = q.popleft()\n        if y==r2 and x==c2:\n            print(dists[y][x])\n            return\n        for dx,dy in dxy:\n            for i in range(1,K+1):\n                nx,ny = x+dx*i,y+dy*i\n                if not 0 <= nx < W: break\n                if not 0 <= ny < H: break\n                if C[ny][nx] == '@': break\n                if dists[ny][nx] <= dists[y][x]: break\n                if dists[ny][nx] <= dists[y][x] + 1: continue\n                dists[ny][nx] = dists[y][x] + 1\n                q.append((ny,nx))\n    print(-1)\nsolve()", "#!/usr/bin/env python3\nfrom collections import deque\n\ndef main():\n    H, W, K = map(int, input().split())\n    x1, y1, x2, y2 = map(lambda x: int(x)-1, input().split())\n    c = [input() for _ in range(H)]\n\n    adj = [[] for _ in range(W*H)]\n    dx = [1,-1,0,0]\n    dy = [0,0,1,-1]\n    INF = 10**12\n    \n    for i in range(H):\n        for j in range(W):\n            if c[i][j] == '@': continue\n            for k in range(4):\n                y = i + dy[k]\n                x = j + dx[k]\n                if 0 <= y < H and 0 <= x < W and c[y][x] == '.':\n                    adj[W*i+j].append(W*y+x)\n    \n    queue = deque([W*x1+y1])\n    visit = [INF] * (W*H)\n    visit[W*x1+y1] = 0\n    \n    while queue:\n        now = queue.popleft()\n        for u in adj[now]:\n            # now\u304b\u3089u\u306e\u65b9\u5411\u306b'.'\u304c\u7d9a\u304f\u304b\u304e\u308a\uff08\u6700\u5927K\u500b\uff09\n            count = 0\n            direct = u - now\n            fromC = now\n            toC = u\n            while count < K and toC in adj[fromC] and visit[now] < visit[toC]:\n                count += 1\n                if visit[toC] == INF:\n                    queue.append(toC)\n                    visit[toC] = visit[now] + 1\n                fromC = toC\n                toC += direct \n\n    print(visit[W*x2+y2]) if visit[W*x2+y2] < INF else print(-1)\n    # print(visit)\n\ndef __starting_point():\n    main()\n__starting_point()", "h,a,*m=open(0)\nh,w,k,a,b,f,g=map(int,(h+a).split())\nd=[I:=h*w]*I\nm+=d,\na=~w+a*w+b\nd[a]=1\nq=[a]\nfor s in q:\n for y,x in(1,0),(-1,0),(0,1),(0,-1):\n  for z in range(k):\n   i,j=s//w+y*~z,s%w+x*~z;t=i*w+j;p=d[s]+1\n   if'.'!=m[i][j]or d[t]<p:break\n   if d[t]>p:q+=t,;d[t]=p\nprint(d[~w+f*w+g]%I-1)", "from collections import deque\n\nH, W, K = list(map(int, input().split()))\nsx, sy, tx, ty = [int(a) - 1 for a in input().split()]\nINF = 10**18\n\nA = [input() for _ in range(H)]\n\nminDist = [[INF] * W for _ in range(H)]\nminDist[sx][sy] = 0\nque = deque([(0, sx, sy)])\n\nwhile que:\n    dist, nx, ny = que.popleft()\n\n    for i in range(1, K + 1):\n        if nx + i >= H:\n            break\n        if minDist[nx + i][ny] <= dist or A[nx + i][ny] == '@':\n            break\n        if minDist[nx + i][ny] > dist + 1:\n            minDist[nx + i][ny] = dist + 1\n            que.append((dist + 1, nx + i, ny))\n    for i in range(1, K + 1):\n        if nx - i < 0:\n            break\n        if minDist[nx - i][ny] <= dist or A[nx - i][ny] == '@':\n            break\n        if minDist[nx - i][ny] > dist + 1:\n            minDist[nx - i][ny] = dist + 1\n            que.append((dist + 1, nx - i, ny))\n    for i in range(1, K + 1):\n        if ny + i >= W:\n            break\n        if minDist[nx][ny + i] <= dist or A[nx][ny + i] == '@':\n            break\n        if minDist[nx][ny + i] > dist + 1:\n            minDist[nx][ny + i] = dist + 1\n            que.append((dist + 1, nx, ny + i))\n    for i in range(1, K + 1):\n        if ny - i < 0:\n            break\n        if minDist[nx][ny - i] <= dist or A[nx][ny - i] == '@':\n            break\n        if minDist[nx][ny - i] > dist + 1:\n            minDist[nx][ny - i] = dist + 1\n            que.append((dist + 1, nx, ny - i))\n\nans = minDist[tx][ty]\nprint((ans if ans < INF else -1))\n", "import sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n    def bfs():\n        \n\n        inf = 1e7\n\n        dist = [[inf]*w for _ in range(h)]\n        dist[xs][ys] = 0\n        que = deque([(xs, ys)])\n        dx = [-1, 0, 1, 0]\n        dy = [0, 1, 0, -1]\n        while que:\n            x, y = que.popleft()\n            for i in range(4):\n                nx, ny = x, y\n                for _ in range(k):\n                    nx += dx[i]\n                    ny += dy[i]\n                    if nx < 0 or nx >= h or ny < 0 or ny >= w: break\n                    if field[nx][ny] == '@' or dist[nx][ny] <= dist[x][y]: break\n                    if dist[nx][ny] > dist[x][y] + 1:\n                        dist[nx][ny] = dist[x][y] + 1\n                        que.append((nx, ny))\n            \n        if dist[xg][yg] == inf:\n            print(-1)\n        else:\n            print(dist[xg][yg])\n\n    h, w, k = map(int, input().split())\n    xs, ys, xg, yg = map(lambda x: int(x)-1, input().split())\n    field = [input() for _ in range(h)]\n    bfs()\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\n\n\ndef bfs(x1, y1, d):\n    q = deque([])\n    q.append((d, x1, y1))\n    M[x1][y1] = d\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n                # if m[x2][y2] == '@':\n                #     break\n                # if x2 < 0 or x2 >= H:\n                #     break\n                # if y2 < 0 or y2 >= W:\n                #     break\n                # if M[x2][y2] < d + 1:\n                #     break\n                # if M[x2][y2] == d + 1:\n                #     continue\n\n                if (0 <= x2 < H) and (0 <= y2 < W):\n                    if m[x2][y2] == '@':\n                        break\n                    elif M[x2][y2] == -1:\n                        M[x2][y2] = d + 1\n                        q.append((d + 1, x2, y2))\n                    elif M[x2][y2] <= d:\n                        break\n                    elif M[x2][y2] == d + 1:\n                        continue\n                    else:\n                        break\n                else:\n                    break\n    print((-1))\n\n\nH, W, K = list(map(int, sys.stdin.readline().strip().split()))\nxs, ys, xg, yg = list(map(int, sys.stdin.readline().strip().split()))\nxg -= 1\nyg -= 1\n\nm = []\nfor _ in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for _ in range(H)]\n\nbfs(xs - 1, ys - 1, 0)\n", "import sys\nfrom collections import deque\n\n\ndef bfs(x1, y1, d):\n    q = deque([])\n    q.append((d, x1, y1))\n    M[x1][y1] = d\n\n    while q:\n        d, x1, y1 = q.popleft()\n        M[x1][y1] = d\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n                if x2 < 0 or x2 >= H:  # \u67a0\u5916\n                    break\n                if y2 < 0 or y2 >= W:  # \u67a0\u5916\n                    break\n                if m[x2][y2] == '@':  # \u84ee\u306e\u8449\n                    break\n                if M[x2][y2] < d + 1:  # \u3088\u308a\u826f\u3044\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\n                    break\n                if M[x2][y2] == d + 1:  # \u540c\u7b49\u306e\u826f\u3055\u306e\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\u3000\u98db\u3073\u8d8a\u3048\u3066\u6b21\u306e\u30de\u30b9\u3092\u63a2\u7d22\u3059\u308b\u3002\n                    continue\n\n                q.append((d + 1, x2, y2))\n                M[x2][y2] = d + 1\n\n    print((-1))\n\n\nH, W, K = list(map(int, sys.stdin.readline().strip().split()))\nxs, ys, xg, yg = list(map(int, sys.stdin.readline().strip().split()))\nxg -= 1\nyg -= 1\n\nm = []\nfor _ in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[float('inf')] * W for _ in range(H)]\n\nbfs(xs - 1, ys - 1, 0)\n", "import sys\ninput=sys.stdin.readline\nh,w,k=map(int,input().split())\nsi,sj,ti,tj=map(int,input().split())\nsi-=1\nsj-=1\nti-=1\ntj-=1\nb=[input()for _ in range(h)]\nans=[[-1]*w for _ in range(h)]\nans[si][sj]=0\nfrom collections import deque\nd=deque()\nd.append((si,sj))\nwhile d:\n  x,y=d.popleft()\n  if x==ti and y==tj:\n    print(ans[x][y]);return\n  for dx,dy in [[1,0],[-1,0],[0,-1],[0,1]]:\n    for i in range(1,k+1):\n      xx=x+dx*i\n      yy=y+dy*i\n      if not(0<=xx<h and 0<=yy<w) or b[xx][yy]==\"@\":break\n      if 0<=ans[xx][yy]<=ans[x][y]:break\n      if ans[xx][yy]==-1:d.append((xx,yy))\n      ans[xx][yy]=ans[x][y]+1\nprint(-1)\n", "# F - Pond Skater\n\nfrom collections import deque\n\nH, W, K = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nx1 -= 1\ny1 -= 1\nx2 -= 1\ny2 -= 1\ngrid = []\nfor _ in range(H):\n    grid.append(list(str(input())))\n\ndist = [[-1] * W for _ in range(H)]\ndist[x1][y1] = 0\nq = deque()\nq.append((x1, y1))\n\nwhile q:\n    (x, y) = q.popleft()\n    if (x, y) == (x2, y2):\n        break\n    for vx, vy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n        for k in range(1, K+1):\n            nx = x + vx*k\n            ny = y + vy*k\n            if nx < 0 or nx >= H or ny < 0 or ny >= W or grid[nx][ny] == '@':\n                break\n            if dist[nx][ny] != -1 and dist[nx][ny] != dist[x][y] + 1:\n                break\n            if dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\nprint(dist[x2][y2])", "#import heapq\nfrom collections import deque\nh,w,k = list(map(int, input().split()))\nx1,y1,x2,y2 = list(map(int, input().split()))\nx1,y1,x2,y2 = x1-1,y1-1,x2-1,y2-1\ndp = [[-1]*w for _ in range(h)]\n#que = []\nque = deque()\nc = [input() for _ in range(h)]\n\ndp[x1][y1] = 0\n#heapq.heappush(que, (dp[x1][y1], [x1,y1]))\nque.append((x1,y1))\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\nwhile que:\n  x,y=que.popleft()\n  if x==x2 and y==y2:\n    print(dp[x][y]);return\n  for dx,dy in [[1,0],[-1,0],[0,-1],[0,1]]:\n    for i in range(1,k+1):\n      xx=x+dx*i\n      yy=y+dy*i\n      if not(0<=xx<h and 0<=yy<w) or c[xx][yy]==\"@\":break\n      if 0<=dp[xx][yy]<=dp[x][y]:break\n      if dp[xx][yy]==-1:que.append((xx,yy))\n      dp[xx][yy]=dp[x][y]+1\nprint(-1)\n", "H,W,K=list(map(int,input().split()))\nx1,y1,x2,y2=[int(x)-1 for x in input().split()]\n\npond=[]\nfor _ in range(H):\n    pond.append(list(input()))\n\ninf=10**7\ncost=[[inf]*W for _ in range(H)]\ncost[x1][y1]=0\nfrom heapq import heapify,heappop,heappush\nhq=[(0,x1,y1)]\n\nwhile hq:\n    t,x,y=heappop(hq)\n    if x==x2 and y==y2:\n      print(t)\n      return\n    #\u5317\u3078\n    for i in range(1,K+1):\n        if x-i<0 or pond[x-i][y]==\"@\" or cost[x-i][y]<t+1:\n            break\n        if cost[x-i][y]>t+1:\n            cost[x-i][y]=t+1\n            heappush(hq,(t+1,x-i,y))\n    #\u6771\u3078\n    for i in range(1,K+1):\n        if y+i>W-1 or pond[x][y+i]==\"@\" or cost[x][y+i]<t+1:\n            break\n        if cost[x][y+i]>t+1:\n            cost[x][y+i]=t+1\n            heappush(hq,(t+1,x,y+i))\n    #\u5357\u3078\n    for i in range(1,K+1):\n        if x+i>H-1 or pond[x+i][y]==\"@\" or cost[x+i][y]<t+1:\n            break\n        if cost[x+i][y]>t+1:\n            cost[x+i][y]=t+1\n            heappush(hq,(t+1,x+i,y))\n    #\u897f\u3078\n    for i in range(1,K+1):\n        if y-i<0 or pond[x][y-i]==\"@\" or cost[x][y-i]<t+1:\n            break\n        if cost[x][y-i]>t+1:\n            cost[x][y-i]=t+1\n            heappush(hq,(t+1,x,y-i))\n\nprint((-1))\n\n", "h,w,k = map(int,input().split())\ny1,x1,y2,x2 = map(int,input().split())\ngrid = []\ngrid.append(['@']*(w+2))\nfor i in range(h):\n    grid.append(['@']+list(input())+['@'])\ngrid.append(['@']*(w+2))\n\nq = set()\nnext_q = set()\nnext_q.add((y1,x1))\nans = 0\nwhile True:\n    if not next_q:\n        print(-1)\n        return\n    for y,x in next_q:\n        grid[y][x] = '@'\n    q = next_q\n    next_q = set()\n    while q:\n        y,x = q.pop()\n        if (y,x) == (y2,x2):\n            print(ans)\n            return\n        for i in range(1,k+1):\n            if grid[y+i][x] == '@':\n                break\n            next_q.add((y+i,x))\n        for i in range(1,k+1):\n            if grid[y-i][x] == '@':\n                break\n            next_q.add((y-i,x))\n        for i in range(1,k+1):\n            if grid[y][x+i] == '@':\n                break\n            next_q.add((y,x+i))\n        for i in range(1,k+1):\n            if grid[y][x-i] == '@':\n                break\n            next_q.add((y,x-i))\n    ans += 1", "from collections import deque\ndxdy = ((-1,0), (1,0), (0,-1), (0,1)) # \u30bf\u30d7\u30eb\u3084\u30ea\u30b9\u30c8\u3067\u6301\u3063\u3066\u304a\u304f\u3068\u4fbf\u5229\n\nH, W, K = map(int,input().split())\nx1, y1, x2, y2 = map(int,input().split())\nmp = [input() for _ in range(H)]\nINF = 10**10\ndist = [[INF]*W for _ in range(H)]\ndist[x1-1][y1-1] = 0\nq = deque()\nq.append((x1-1,y1-1)) # \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u3092enqueue\nwhile(q):\n    x, y = q.popleft()\n    if x==x2-1 and y==y2-1:\n        print (dist[x2-1][y2-1])\n        return\n    else:\n        for dx, dy in  dxdy:\n            for i in range(1,K+1):\n                nx = x + dx*i\n                ny = y + dy*i\n                if not (0<=nx<H and 0<=ny<W) or mp[nx][ny]=='@':\n                    break\n                if dist[nx][ny] <= dist[x][y]:\n                    break \n                if dist[nx][ny] == INF:\n                    q.append((nx,ny))\n                    dist[nx][ny] = dist[x][y] + 1\nprint(-1)", "from sys import stdin\ndef input():\n    return stdin.readline().strip()\n\nimport heapq\n\ndef main():\n    h, w, k = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n\n    # surround the square with '@'\n    c = [['@'] * (w+2)]\n    for _ in range(h):\n        i = input()\n        l = ['@']\n        for j in i:\n            l.append(j)\n        l.append('@')\n        c.append(l)\n    c.append(['@'] * (w+2))\n\n    # Dijkstra\n    # seen[x][y] = the minimum cost of (x, y)\n    # if seen[x][y] == -1, (x, y) is unresearched\n    seen = [[-1] * (w+2) for _ in range(h+2)]\n\n    # todo[i] == (cost, x, y, direction)\n    todo = [(0, x1, y1, 0)]\n    heapq.heapify(todo)\n\n    # direction\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while len(todo) > 0:\n        cost, xi, yi, direction = heapq.heappop(todo)\n\n        # only straight\n        if seen[xi][yi] != -1:\n            if (seen[xi][yi]+k-1)//k * k > cost:\n                xj, yj = xi + dx[direction], yi + dy[direction]\n                if c[xj][yj] == '.':\n                    heapq.heappush(todo, (cost+1, xj, yj, direction))\n            continue\n        seen[xi][yi] = cost\n\n        # goal\n        if xi == x2 and yi == y2:\n            print((cost+k-1)//k)\n            return\n        \n        # 4 directions\n        for j in range(4):\n            xj, yj = xi + dx[j], yi + dy[j]\n            if c[xj][yj] == '.':\n                if j == direction:\n                    if seen[xj][yj] == -1 or (seen[xj][yj]+k-1)//k * k > cost:\n                        heapq.heappush(todo, (cost+1, xj, yj, j))\n                elif seen[xj][yj] == -1:\n                    heapq.heappush(todo, ((cost+k-1)//k * k + 1, xj, yj, j))\n\n    print(-1)\n\nmain()", "from collections import deque\n\n\ndef bfs(maze, visited, sy, sx, gy, gx):\n    queue = deque([[sy, sx]])\n    visited[sy][sx] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        y, x = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [y, x] == [gy, gx]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return visited[y][x]\n        for dx, dy in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            for k in range(1, K + 1):\n                new_x = x + dx * k\n                new_y = y + dy * k\n                \n                if (0 <= new_y < H) and (0 <= new_x < W):\n                    if maze[new_y][new_x] == \"@\":\n                        break\n                    elif visited[new_y][new_x] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        visited[new_y][new_x] = visited[y][x] + 1\n                        queue.append([new_y, new_x])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif visited[new_y][new_x] < visited[y][x] + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = map(int, input().split())\n# K = min(K, max(H, W))\nx1, y1, x2, y2 = map(int, input().split())\nx1, y1, x2, y2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1\nC = [0] * H\nfor i in range(H):\n    C[i] = str(input())\nvisited = [[-1] * W for i in range(H)]\nbfs(C, visited, x1, y1, x2, y2)\n# print(visited)\nprint(visited[x2][y2])", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nfrom collections import deque\nINF = float('inf')\ndef resolve():\n    H, W, K = list(map(int, input().split()))\n    sx, sy, gx, gy = [int(x)-1 for x in input().split()]\n    G = [list(input()) for _ in range(H)]\n\n    dist = [[INF] * W for i in range(H)]\n    dist[sx][sy] = 0\n    q = deque([(sx, sy)])\n\n    drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while q:\n        x, y = q.popleft()\n        if (x, y) == (gx, gy):\n            print((dist[x][y]))\n            return\n        for dx, dy in drc:\n            nx = x\n            ny = y\n            for k in range(K):\n                nx += dx\n                ny += dy\n                if 0 <= nx < H and 0 <= ny < W and G[nx][ny] != '@':\n                    if dist[nx][ny] <= dist[x][y]:\n                        break\n                    if dist[nx][ny] == INF:\n                        q.append((nx, ny))\n                    dist[nx][ny] = dist[x][y] + 1\n                else:\n                    break\n    print((-1))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def ii():return int(input())\ndef iim():return list(map(int,input().split()))\ndef iil():return list(map(int,input().split()))\nfrom collections import deque\n\n\ndef bfs(xg,yg):\n    queue = deque([(xs,ys,0)])\n    while queue:\n        x,y,dep = queue.popleft()\n        l = []\n        for xx,yy in [(1,0),(0,1),(-1,0),(0,-1)]:\n            for i in range(1,k+1):\n                nx,ny = x+xx*i,y+yy*i\n                if cord[ny][nx] == '.':\n                    l.append((nx,ny))\n                elif cord[ny][nx] == dep+1:\n                    continue\n                else:\n                    break\n        for nx, ny in l:\n            if cord[ny][nx] == '.':\n                cord[ny][nx] = dep+1\n                if (nx,ny) == (xg,yg):\n                    return dep+1\n                else:\n                    queue.append((nx,ny,dep+1))\n    return -1\n\nh,w,k = iim()\nys,xs,yg,xg = iim()\n\ncord = [['@']*(w+2)]\nfor i in range(h):\n    cord.append(['@']+list(input())+['@'])\ncord.append(['@']*(w+2))\ncord[ys][xs] = '#'\n#for i in cord:\n#    print(*i)\n#print(len(cord),len(cord[0]))\n\nprint((bfs(xg,yg)))\n", "from collections import deque\ndxdy = ((-1,0), (1,0), (0,-1), (0,1)) # \u30bf\u30d7\u30eb\u3084\u30ea\u30b9\u30c8\u3067\u6301\u3063\u3066\u304a\u304f\u3068\u4fbf\u5229\n\nH, W, K = list(map(int,input().split()))\nx1, y1, x2, y2 = list(map(int,input().split()))\nmp = [input() for _ in range(H)]\nINF = 10**10\ndist = [[INF]*W for _ in range(H)]\ndist[x1-1][y1-1] = 0\nq = deque()\nq.append((x1-1,y1-1)) # \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u3092enqueue\nwhile(q):\n    x, y = q.popleft()\n    if x==x2-1 and y==y2-1:\n        print((dist[x2-1][y2-1]))\n        return\n    else:\n        for dx, dy in  dxdy:\n            for i in range(1,K+1):\n                nx = x + dx*i\n                ny = y + dy*i\n                if not (0<=nx<H and 0<=ny<W) or mp[nx][ny]=='@':\n                    break\n                #print(nx,ny,x,y)\n                #print (dist[nx][ny] , dist[x][y])\n                if dist[nx][ny] <= dist[x][y]:\n                    break \n                #print(nx,ny,x,y)\n                if dist[nx][ny] == INF:\n                    q.append((nx,ny))\n                dist[nx][ny] = dist[x][y] + 1\nprint((-1))\n\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom heapq import heapify, heappush as hpush, heappop as hpop\nH, W, K = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nX = [1] * (W + 2)\nfor _ in range(H):\n    X += [1] + [1 if a == \"@\" else 0 for a in input()] + [1]\nX += [1] * (W + 2)\nX += X[:]\nH, W = H+2, W+2\nHW = H * W\ns, t = x1 * W + y1, x2 * W + y2\nss, tt = s + HW, t + HW\ndef dijkstra():\n    n = 2 * H * W\n    h = [s, ss]\n    D = [-1] * n\n    done = [0] * n\n    D[s] = 0\n    D[ss] = 0\n    kk = 21\n    m = (1 << kk) - 1\n    while h:\n        x = hpop(h)\n        d, i = x >> kk, x & m\n        done[i] = 1\n        if i < HW:\n            for j in (i+1, i-1):\n                nd = d + 1\n                if X[j]: continue\n                if D[j] < 0 or D[j] > nd:\n                    if done[j] == 0:\n                        hpush(h, (nd << kk) + j)\n                        D[j] = nd\n        else:\n            for j in (i+W, i-W):\n                nd = d + 1\n                if X[j]: continue\n                if D[j] < 0 or D[j] > nd:\n                    if done[j] == 0:\n                        hpush(h, (nd << kk) + j)\n                        D[j] = nd\n            \n        j = i + HW if i < HW else i - HW\n        nd = (d + K - 1) // K * K\n        if X[j]: continue\n        if D[j] < 0 or D[j] > nd:\n            if done[j] == 0:\n                hpush(h, (nd << kk) + j)\n                D[j] = nd\n    return [-(-a//K) for a in (D[t], D[tt]) if a >= 0]\n\ndi = dijkstra()\nprint(min(di) if di else -1)", "h, w, k = list(map(int, input().split()))\nx1, y1, x2, y2 = list(map(int, input().split()))\nx1, y1, x2, y2 = x1-1, y1-1, x2-1, y2-1\n\nm = [[-1] * w for _ in range(h)]\nfor hh in range(h):\n    c = input()\n    for ww, cc in enumerate(c):\n        if cc == '.':\n            m[hh][ww] = h*w\n\nfrom collections import deque\nq = deque()\n\nq.append((0, x1, y1))\nwhile q:\n    s, x, y = q.popleft()\n    s1 = s + 1\n\n    for i in range(1, k+1):\n        xx, yy = x + i, y\n        if xx >= h or m[xx][yy] <= s:\n            break\n        if m[xx][yy] == s1:\n            continue\n        if xx == x2 and yy == y2:\n            print(s1)\n            return\n        m[xx][yy] = s1\n        q.append((s1, xx, yy))\n\n    for i in range(1, k+1):\n        xx, yy = x - i, y\n        if xx < 0 or m[xx][yy] <= s:\n            break\n        if m[xx][yy] == s1:\n            continue\n        if xx == x2 and yy == y2:\n            print(s1)\n            return\n        m[xx][yy] = s1\n        q.append((s1, xx, yy))\n\n    for i in range(1, k+1):\n        xx, yy = x, y + i\n        if yy >= w or m[xx][yy] <= s:\n            break\n        if m[xx][yy] == s1:\n            continue\n        if xx == x2 and yy == y2:\n            print(s1)\n            return\n        m[xx][yy] = s1\n        q.append((s1, xx, yy))\n\n    for i in range(1, k+1):\n        xx, yy = x, y - i\n        if yy < 0 or m[xx][yy] <= s:\n            break\n        if m[xx][yy] == s1:\n            continue\n        if xx == x2 and yy == y2:\n            print(s1)\n            return\n        m[xx][yy] = s1\n        q.append((s1, xx, yy))\n\nprint((-1))\n", "import sys\nfrom collections import deque\n\n\ndef bfs(x1, y1, d):\n    q = deque([])\n    q.append((d, x1, y1))\n\n    while q:\n        d, x1, y1 = q.popleft()\n        M[x1][y1] = d\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n                if x2 < 0 or x2 >= H:  # \u67a0\u5916\n                    break\n                if y2 < 0 or y2 >= W:  # \u67a0\u5916\n                    break\n                if m[x2][y2] == '@':  # \u84ee\u306e\u8449\n                    break\n                if M[x2][y2] < d + 1:  # \u3088\u308a\u826f\u3044\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\n                    break\n                if M[x2][y2] == d + 1:  # \u540c\u7b49\u306e\u826f\u3055\u306e\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\u3000\u98db\u3073\u8d8a\u3048\u3066\u6b21\u306e\u30de\u30b9\u3092\u63a2\u7d22\u3059\u308b\u3002\n                    continue\n\n                q.append((d + 1, x2, y2))\n                M[x2][y2] = d + 1  # \u3053\u3053\u3067\u66f4\u65b0\u3057\u306a\u3044\u3068\u7121\u99c4\u306a\u63a2\u7d22\u304c\u767a\u751f\u3059\u308b\n\n    print((-1))\n\n\nH, W, K = list(map(int, sys.stdin.readline().strip().split()))\nxs, ys, xg, yg = list(map(int, sys.stdin.readline().strip().split()))\nxg -= 1\nyg -= 1\n\nm = []\nfor _ in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[float('inf')] * W for _ in range(H)]\n\nbfs(xs - 1, ys - 1, 0)\n", "# -*- coding: utf-8 -*-\n\nH,W,K = map(int, input().split())\nx1,y1,x2,y2 = map(int, input().split())\n\nC = [input() for _ in range(H)]\nT = [[-1 for _ in range(W)] for _ in range(H)]\nT[x1-1][y1-1] = 0\n\nque = set([(x1-1,y1-1)])\nstep = 1\n\nwhile len(que)>0:\n  que_next = set()\n  for q in que:\n    x,y = q[0],q[1]\n    for i in range(1,K+1):\n      if x-i<0:\n        break\n      if C[x-i][y]=='@' or T[x-i][y]==1:\n        break\n      if x-i==x2-1 and y==y2-1:\n        print(step)\n        return\n      que_next.add((x-i,y))\n    for i in range(1,K+1):\n      if x+i>H-1:\n        break\n      if C[x+i][y]=='@' or T[x+i][y]==1:\n        break\n      if x+i==x2-1 and y==y2-1:\n        print(step)\n        return\n      que_next.add((x+i,y))\n    for i in range(1,K+1):\n      if y-i<0:\n        break\n      if C[x][y-i]=='@' or T[x][y-i]==1:\n        break\n      if x==x2-1 and y-i==y2-1:\n        print(step)\n        return\n      que_next.add((x,y-i))\n    for i in range(1,K+1):\n      if y+i>W-1:\n        break\n      if C[x][y+i]=='@' or T[x][y+i]==1:\n        break\n      if x==x2-1 and y+i==y2-1:\n        print(step)\n        return\n      que_next.add((x,y+i))\n  que = que_next\n  for q in que:\n    T[q[0]][q[1]] = 1\n  step += 1\n\nprint(-1)", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n \nH, W, K = map(int,input().split())\nsth, stw, glh, glw = map(int,input().split())\nsth, stw = sth-1, stw-1\nglh, glw = glh-1, glw-1\n \nINF = -1\nGmap = [list(input()) for _ in range(H)]\nSeen = [[INF]*W for _ in range(H)]\ndirec = {(1,0), (-1,0), (0,1), (0,-1)}\n \nfrom collections import deque\n \ndef bfs(sth, stw, glh, glw):\n    next_q = deque([])\n    next_q.append((sth,stw,0))\n    Seen[sth][stw] = 0\n \n    while len(next_q)!=0:\n        #\u30ad\u30e5\u30fc\u53d6\u308a\u51fa\u3057(\u5148\u982d)\n        h, w, c = next_q.popleft()\n        for dh, dw in direc:\n            for sk in range(1,K+1):\n                hs, ws = h + dh*sk, w + dw*sk\n                if not (0<=hs<H and 0<=ws<W):\n                    break\n                if Gmap[hs][ws]=='@':\n                    break\n                if Seen[hs][ws]==INF:\n                    next_q.append((hs,ws,c+1))\n                    Seen[hs][ws] = c + 1\n                elif Seen[hs][ws]<=c:\n                    break\n                if hs==glh and ws==glw:\n                    return c + 1\n    return -1\n\ndef main():\n    ret = bfs(sth, stw, glh, glw)\n    print(ret)\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    import sys\n    from collections import deque\n    input=sys.stdin.readline\n\n    h,w,k=list(map(int,input().split()))\n    sy,sx,gy,gx=list(map(int,input().split()))\n\n    #maze=[]\n    #for _ in range(h):\n    #    maze.append(tuple(input()))\n\n    maze=[tuple(input()) for _ in range(h)]\n\n    sy-=1\n    sx-=1\n    gy-=1\n    gx-=1\n\n    #maze[sy][sx]=\"S\"\n\n    dis=[[-1]*w for _ in range(h)]\n\n\n\n    dis[sy][sx]=0\n\n\n\n    d = deque([(sx,sy)])\n    while len(d)>0:\n        (x,y)=d.popleft()\n        if x==gx and y==gy:\n            print((dis[gy][gx]))\n            #maze[gy][gx]=\"G\"\n\n            #pri(dis)\n            #pri(maze)\n\n            return\n\n        for (mx,my) in ((0,1),(1,0),(-1,0),(0,-1)):\n            #print(mx,my,d)\n            for j in range(1,k+1):\n                nx=x+mx*j\n                ny=y+my*j\n                #print(y,x,\">>\",ny,nx)\n                if 0<=nx<w and 0<=ny<h:\n                    if maze[ny][nx]==\".\" and (dis[ny][nx]==-1 or dis[ny][nx]==dis[y][x]+1):\n                        if dis[ny][nx]==-1:\n                            d.append((nx,ny))\n                        dis[ny][nx]=dis[y][x]+1\n                        \n                        #pri(dis)\n                    else:\n                        break\n                else:\n                    break\n\n    print((-1))\n        \ndef __starting_point():\n    main()\n\n\n                \n\n\n\n\n\n\n\n\n\n__starting_point()", "from collections import deque\n\n\ndef bfs(visited, sy, sx, gy, gx):\n    queue = deque([[sy, sx]])\n    visited[sy][sx] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        y, x = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [y, x] == [gy, gx]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return visited[y][x]\n        for dx, dy in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            for k in range(1, K + 1):\n                new_x = x + dx * k\n                new_y = y + dy * k\n\n                if (0 <= new_y < H) and (0 <= new_x < W):\n                    if m[new_y][new_x] == \"@\":\n                        break\n                    elif visited[new_y][new_x] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        visited[new_y][new_x] = visited[y][x] + 1\n                        queue.append([new_y, new_x])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif visited[new_y][new_x] < visited[y][x] + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nx1, y1, x2, y2 = list(map(int, input().split()))\nx1, y1, x2, y2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1\nm = []\nfor i in range(H):\n    m.append(str(input()))\nvisited = [[-1] * W for i in range(H)]\nbfs(visited, x1, y1, x2, y2)\nprint((visited[x2][y2]))\n", "H,W,K=list(map(int,input().split()))\nx1,y1,x2,y2=[int(x)-1 for x in input().split()]\n\npond=[list(input()) for _ in range(H)]\n\ninf=float(\"inf\")\ncost=[[inf]*W for _ in range(H)]\ncost[x1][y1]=0\nfrom heapq import heappop,heappush\nhq=[(0,x1,y1)]\n\nwhile hq:\n    t,x,y=heappop(hq)\n    if x==x2 and y==y2:\n      print(t)\n      return\n    #\u5317\u3078\n    for i in range(1,K+1):\n        if x-i<0 or pond[x-i][y]==\"@\" or cost[x-i][y]<t+1:\n            break\n        if cost[x-i][y]>t+1:\n            cost[x-i][y]=t+1\n            heappush(hq,(t+1,x-i,y))\n    #\u6771\u3078\n    for i in range(1,K+1):\n        if y+i>W-1 or pond[x][y+i]==\"@\" or cost[x][y+i]<t+1:\n            break\n        if cost[x][y+i]>t+1:\n            cost[x][y+i]=t+1\n            heappush(hq,(t+1,x,y+i))\n    #\u5357\u3078\n    for i in range(1,K+1):\n        if x+i>H-1 or pond[x+i][y]==\"@\" or cost[x+i][y]<t+1:\n            break\n        if cost[x+i][y]>t+1:\n            cost[x+i][y]=t+1\n            heappush(hq,(t+1,x+i,y))\n    #\u897f\u3078\n    for i in range(1,K+1):\n        if y-i<0 or pond[x][y-i]==\"@\" or cost[x][y-i]<t+1:\n            break\n        if cost[x][y-i]>t+1:\n            cost[x][y-i]=t+1\n            heappush(hq,(t+1,x,y-i))\n\nprint((-1))\n\n", "from collections import deque\nh,w,k = map(int,input().split())\na,b,c,d = map(int,input().split())\na -= 1\nb -= 1\nc -= 1\nd -= 1\nmaze = [input() for _ in range(h)]\ndx = [1,-1,0,0]\ndy = [0,0,1,-1]\ndepth = [[float(\"inf\") for _ in range(w)] for _ in range(h)]\ndq = deque([(b,a)])\ndepth[a][b] = 0\nwhile dq:\n    x,y = dq.popleft()\n    if x == d and y == c:\n        break\n    for i in range(4):\n        nx,ny,K = x,y,k\n        while K:\n            K -= 1\n            nx += dx[i]\n            ny += dy[i]\n            if 0<=nx<=w-1 and 0<=ny<=h-1 and maze[ny][nx] != \"@\" and depth[ny][nx] > depth[y][x]:\n                if depth[ny][nx] == depth[y][x]+1:\n                    continue\n                depth[ny][nx] = depth[y][x] +1\n                dq.append((nx,ny))\n            else:\n                break\nprint(depth[c][d] if depth[c][d] != float(\"inf\") else -1)", "H,W,K=list(map(int,input().split()))\nx1,y1,x2,y2=list(map(int,input().split()))\nC=[]\nnx=set([])\n\nfor _ in range(H):\n    C.append(list(input()))\n\ndef keiro(x,y,k):\n    i=1\n    while True:\n        if y+i>W-1 or C[x][y+i]!='.' or i>k:\n            break\n        else:\n            if (x,y+i) not in nx:\n                nx.add((x,y+i))\n            i+=1\n    \n    i=1\n    while True:\n        if y-i<0 or C[x][y-i]!='.' or i>k:\n            break\n        else:\n            if (x,y-i) not in nx:\n                nx.add((x,y-i))\n            i+=1\n    \n    i=1\n    while True:\n        if x+i>H-1 or C[x+i][y]!='.' or i>k:\n            break\n        else:\n            if (x+i,y) not in nx:\n                nx.add((x+i,y))\n            i+=1\n    \n    i=1\n    while True:\n        if x-i<0 or C[x-i][y]!='.' or i>k:\n            break\n        else:\n            if (x-i,y) not in nx:\n                nx.add((x-i,y))\n            i+=1\n\n    return 0\n\nC[x1-1][y1-1]=0\nkeiro(x1-1,y1-1,K)\ntaisho=nx.copy()\nresult=1\nfor j in nx:\n    C[j[0]][j[1]]=result\n\nwhile C[x2-1][y2-1]=='.':\n    nx=set([])\n    if len(taisho)==0 or result>10**6:\n        result=-1\n        break\n    for l in taisho:\n        keiro(l[0],l[1],K)\n    result+=1\n    for j in nx:\n        C[j[0]][j[1]]=result\n    taisho=nx.copy()\n\nprint(result)\n", "# -*- coding: utf-8 -*-\n\nH,W,K = list(map(int, input().split()))\nx1,y1,x2,y2 = list(map(int, input().split()))\n\nC = [input() for _ in range(H)]\nT = [[-1 for _ in range(W)] for _ in range(H)]\nT[x1-1][y1-1] = 0\n\nque = {(x1-1,y1-1):0}\nstep = 1\n\nwhile len(que)>0:\n  que_next = {}\n  for q in list(que.keys()):\n    x,y = q[0],q[1]\n    for i in range(1,K+1):\n      if x-i<0:\n        break\n      if C[x-i][y]=='@' or T[x-i][y]==1:\n        break\n      if x-i==x2-1 and y==y2-1:\n        print(step)\n        return\n      que_next[(x-i,y)] = 0\n    for i in range(1,K+1):\n      if x+i>H-1:\n        break\n      if C[x+i][y]=='@' or T[x+i][y]==1:\n        break\n      if x+i==x2-1 and y==y2-1:\n        print(step)\n        return\n      que_next[(x+i,y)] = 0\n    for i in range(1,K+1):\n      if y-i<0:\n        break\n      if C[x][y-i]=='@' or T[x][y-i]==1:\n        break\n      if x==x2-1 and y-i==y2-1:\n        print(step)\n        return\n      que_next[(x,y-i)] = 0\n    for i in range(1,K+1):\n      if y+i>W-1:\n        break\n      if C[x][y+i]=='@' or T[x][y+i]==1:\n        break\n      if x==x2-1 and y+i==y2-1:\n        print(step)\n        return\n      que_next[(x,y+i)] = 0\n  que = que_next\n  for q in list(que.keys()):\n    T[q[0]][q[1]] = 1\n  step += 1\n\nprint((-1))\n", "#!/usr/bin/env python3\nimport sys\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return [LIST() for _ in range(n)]\n\ndef main():\n    from heapq import heappush, heappop, heapify\n    H, W, K = MAP()\n    HH = max(H, W) + 2\n    x1, y1, x2, y2 = LIST()\n    c = [[-1] + [0 if c == \".\" else -1 for c in input()] + [-1]\n         for i in range(H)]\n    c = [[-1] * (W + 2)] + c + [[-1] * (W + 2)]\n\n    # 0123: \u4e0a\u4e0b\u5de6\u53f3\n    stack = []\n    heappush(stack, (0, x1, y1, 0))\n    heappush(stack, (0, x1, y1, 1))\n    heappush(stack, (0, x1, y1, 2))\n    heappush(stack, (0, x1, y1, 3))\n    DX = (1, 0, -1, 0)\n    DY = (0, 1, 0, -1)\n    while stack:\n        new_stack = []\n        while stack:\n            curr, x, y, d = heappop(stack)\n            dx, dy = DX[d], DY[d]\n            flag = True\n            a = curr + 1\n            for k in range(1, K + 1):\n                xx, yy = x + k * dx, y + k * dy\n                if c[xx][yy] == 0:\n                    b = c[xx + DX[(d - 1) % 4]][yy + DY[(d - 1) % 4]]\n                    if b == 0 or b == a + 1:\n                        heappush(new_stack, (a, xx, yy, (d - 1) % 4))\n                    b = c[xx + DX[(d + 1) % 4]][yy + DY[(d + 1) % 4]]\n                    if b == 0 or b == a + 1:\n                        heappush(new_stack, (a, xx, yy, (d + 1) % 4))\n                    c[xx][yy] = a\n                elif c[xx][yy] != a:\n                    flag = False\n                    break\n            if flag:\n                heappush(new_stack, (a, xx, yy, d))\n            if c[x2][y2] > 0:\n                print(c[x2][y2], flush=True)\n                return\n        stack = new_stack\n\n    print(-1)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nh, w, k = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nx1-=1\ny1-=1\nx2-=1\ny2-=1\n\ndist = [input() for _ in range(h)]\nans = [[-1]*w for _ in range(h)]\nans[x1][y1] = 0\n\nque = deque()\nque.append((x1, y1))\ndirection = ((1, 0), (-1, 0), (0, -1), (0, 1))\nwhile que:\n  x, y = que.popleft()\n\n  if x == x2 and y == y2:\n      print(ans[x][y])\n      return\n\n  for dx, dy in direction:\n    for i in range(1, k+1):\n      kx = x + dx*i\n      ky = y + dy*i\n\n      if not(0 <= kx < h and 0 <= ky < w) or dist[kx][ky] == \"@\":\n          break\n\n      if 0 <= ans[kx][ky] <= ans[x][y]:\n          break\n\n      if ans[kx][ky] == -1:\n          que.append((kx, ky))\n\n      ans[kx][ky] = ans[x][y]+1\n\nprint(-1)", "from collections import deque\nimport sys\n\n\ndef bfs(xs, ys):\n    queue = deque([[xs, ys]])\n    M[xs][ys] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        x1, y1 = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [x1, y1] == [xg, yg]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return M[x1][y1]\n\n        for dx, dy in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            for k in range(1, K + 1):\n                new_x = x1 + dx * k\n                new_y = y1 + dy * k\n\n                if (0 <= new_x < H) and (0 <= new_y < W):\n                    if m[new_x][new_y] == \"@\":\n                        break\n                    elif M[new_x][new_y] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        M[new_x][new_y] = M[x1][y1] + 1\n                        queue.append([new_x, new_y])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif M[new_x][new_y] < M[x1][y1] + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nxs, ys, xg, yg = list(map(int, input().split()))\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(xs, ys)\n\nprint((M[xg][yg]))\n", "#!/usr/bin/env python3\nimport sys\nfrom heapq import heappush, heappop, heapify\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return [LIST() for _ in range(n)]\n\ndef main():\n    H, W, K = MAP()\n    HH = max(H, W) + 2\n    x1, y1, x2, y2 = LIST()\n    c = [[-1] + [0 if c == \".\" else -1 for c in input()] + [-1]\n         for i in range(H)]\n    c = [[-1] * (W + 2)] + c + [[-1] * (W + 2)]\n\n    # 0123: \u4e0a\u4e0b\u5de6\u53f3\n    stack = []\n    heappush(stack, (0, x1, y1, 0))\n    heappush(stack, (0, x1, y1, 1))\n    heappush(stack, (0, x1, y1, 2))\n    heappush(stack, (0, x1, y1, 3))\n    DX = (1, 0, -1, 0)\n    DY = (0, 1, 0, -1)\n    while stack:\n        new_stack = []\n        while stack:\n            curr, x, y, d = heappop(stack)\n            flag = True\n            a = curr + 1\n            for k in range(1, K + 1):\n                xx, yy = x + k * DX[d], y + k * DY[d]\n                if c[xx][yy] == 0:\n                    b = c[xx + DX[(d - 1) % 4]][yy + DY[(d - 1) % 4]]\n                    if b == 0 or b == a + 1:\n                        heappush(new_stack, (a, xx, yy, (d - 1) % 4))\n                    b = c[xx + DX[(d + 1) % 4]][yy + DY[(d + 1) % 4]]\n                    if b == 0 or b == a + 1:\n                        heappush(new_stack, (a, xx, yy, (d + 1) % 4))\n                    c[xx][yy] = a\n                elif c[xx][yy] != a:\n                    flag = False\n                    break\n            if flag:\n                heappush(new_stack, (a, xx, yy, d))\n            if c[x2][y2] > 0:\n                print((c[x2][y2]))\n                return\n        stack = new_stack\n\n    print((-1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\n\ndef log(*args):\n    print(*args, file=sys.stderr)\n\n\ndef main():\n    h, w, k = map(int, input().strip().split())\n    x1, y1, x2, y2 = map(int, input().strip().split())\n    x1 -= 1\n    y1 -= 1\n    x2 -= 1\n    y2 -= 1\n    m = []\n    costs1 = [[None for j in range(w)] for i in range(h)]\n    costs2 = [[None for j in range(w)] for i in range(h)]\n    for _ in range(h):\n        m.append(list(input().strip()))\n    q1 = deque()\n    q1.append((x1, y1, 0))\n    costs1[x1][y1] = 0\n    q2 = deque()\n    q2.append((x2, y2, 0))\n    costs2[x2][y2] = 0\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    while q1 and q2:\n        (x, y, cost) = q1.popleft()\n        if not costs2[x][y] is None:\n            print(cost + costs2[x][y])\n            return\n        for (add_x, add_y) in directions:\n            for dist in range(1, k + 1):\n                new_x = x + add_x * dist\n                new_y = y + add_y * dist\n                if new_x >= h or new_x < 0 or new_y >= w or new_y < 0 or m[new_x][new_y] == '@' or ((not costs1[new_x][new_y] is None) and costs1[new_x][new_y] < cost + 1):\n                    break\n                if costs1[new_x][new_y] is None:\n                    costs1[new_x][new_y] = cost + 1\n                    q1.append((new_x, new_y, cost + 1))\n        (x, y, cost) = q2.popleft()\n        if not costs1[x][y] is None:\n            print(cost + costs1[x][y])\n            return\n        for (add_x, add_y) in directions:\n            for dist in range(1, k + 1):\n                new_x = x + add_x * dist\n                new_y = y + add_y * dist\n                if new_x >= h or new_x < 0 or new_y >= w or new_y < 0 or m[new_x][new_y] == '@' or ((not costs2[new_x][new_y] is None) and costs2[new_x][new_y] < cost + 1):\n                    break\n                if costs2[new_x][new_y] is None:\n                    costs2[new_x][new_y] = cost + 1\n                    q2.append((new_x, new_y, cost + 1))\n    print(\"-1\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef resolve():\n    H,W,K = map(int,input().split())\n    ys, xs, yg, xg = map(int,input().split())\n\n    board = [['@']*(W+2)]\n    for i in range(H):\n        board.append(['@'] + list(input())+['@'])\n    board.append(['@']*(W+2))\n    board[ys][xs] = '#'\n\n    queue = deque([(xs,ys,0)])\n    while queue:\n        x,y,dep = queue.popleft()\n        l = []\n        f1 = True\n        f2 = True\n        f3 = True\n        f4 = True\n        for i in range(1,K+1):\n            if f1:\n                if board[y][x+i] == '.':\n                    l.append((x+i,y))\n                elif board[y][x+i] == '@' or board[y][x+i] != dep+1:\n                    f1 = False \n            if f2:\n                if board[y][x-i] == '.':\n                    l.append((x-i,y))\n                elif board[y][x-i] == '@' or board[y][x-i] != dep+1:\n                    f2 = False \n            if f3:\n                if board[y+i][x] == '.':\n                    l.append((x,y+i))\n                elif board[y+i][x] == '@' or board[y+i][x] != dep+1:\n                    f3 = False \n            if f4:\n                if board[y-i][x] == '.':\n                    l.append((x,y-i))\n                elif board[y-i][x] == '@' or board[y-i][x] != dep+1:\n                    f4 = False \n            if not(f1 or f2 or f3 or f4):\n                break\n        for nx,ny in l:\n            if board[ny][nx] == '.':\n                board[ny][nx] = dep + 1\n                if (nx,ny) == (xg,yg):\n                    print(dep+1)\n                    return \n                else:\n                    queue.append((nx,ny,dep+1))\n    print(-1)\n    return \nresolve()", "from collections import deque\n\ndef main():\n    H, W, K = list(map(int, input().split()))\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    M = []\n    Cost = [[1000000] * W for i in range(H)]\n    dxdy = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    Cost[x1-1][y1-1] = 0\n    q = deque([(x1-1, y1-1)])\n    for h in range(H):\n        M.append(list(input()))\n\n    while q:\n        x, y = q.popleft()\n        for ddx, ddy in dxdy:\n            for i in range(1, K+1):\n                dx = ddx*i\n                dy = ddy*i\n\n                if not (0 <= x+dx < H and 0 <= y+dy < W):\n                    break\n                if M[x+dx][y+dy] == '@' or Cost[x+dx][y+dy] <= Cost[x][y]:\n                    break\n                if x+dx == x2-1 and y+dy == y2-1:\n                    print((Cost[x][y]+1))\n                    return\n                if Cost[x+dx][y+dy] > Cost[x][y] + 1:\n                    Cost[x+dx][y+dy] = Cost[x][y] + 1\n                    q.append((x+dx,y+dy))\n    \n\n    print((-1))\n\n    \ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "import sys\nimport collections\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    H, W, K = [int(x) for x in input().split()]\n    X1, Y1, X2, Y2 = [int(x) for x in input().split()]\n    C = [input().strip() for _ in range(H)]\n\n    q = collections.deque()\n    q.append((X1 - 1, Y1 - 1, 0))\n\n    V = [[float(\"inf\")] * W for j in range(H)]\n    V[X1 - 1][Y1 - 1] = 0\n\n\n    while q:\n        c = q.popleft()\n        x = c[0]\n        y = c[1]\n        d = c[2]\n\n        if y == Y2 - 1 and x == X2 - 1:\n            print((c[2]))\n            return\n\n        e, w, n, s = True, True, True, True\n        for k in range(1, K + 1):\n            if not e and not w and not n and not s:\n                break\n            if e:\n                if y + k >= W or C[x][y + k] == \"@\":\n                    e = False\n                else:\n                    if V[x][y + k] == float(\"inf\"):\n                        V[x][y + k] = d + 1\n                        q.append((x, y + k, d + 1))\n\n                    if V[x][y + k] < d + 1:\n                        e = False\n            if w:\n                if y - k < 0 or C[x][y - k] == \"@\":\n                    w = False\n                else:\n                    if V[x][y - k] == float(\"inf\"):\n                        V[x][y - k] = d + 1\n                        q.append((x, y - k, d + 1))\n                    if V[x][y - k] < d + 1:\n                        w = False\n\n            if n:\n                if x - k < 0 or C[x - k][y] == \"@\":\n                    n = False\n                else:\n                    if V[x - k][y] == float(\"inf\"):\n                        V[x - k][y] = d + 1\n                        q.append((x - k, y, d + 1))\n                    if V[x - k][y] < d + 1:\n                        n = False\n\n            if s:\n                if x + k >= H or C[x + k][y] == \"@\":\n                    s = False\n                else:\n                    if V[x + k][y] == float(\"inf\"):\n                        V[x + k][y] = d + 1\n                        q.append((x + k, y, d + 1))\n                    if V[x + k][y] < d + 1:\n                        s = False\n\n    print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def ii():return int(input())\ndef iim():return list(map(int,input().split()))\ndef iil():return list(map(int,input().split()))\nfrom collections import deque\n\n\ndef bfs(xg,yg):\n    queue = deque([(xs,ys,0)])\n    while queue:\n        x,y,dep = queue.popleft()\n        l = []\n        for xx,yy in [(1,0),(0,1),(-1,0),(0,-1)]:\n            for i in range(1,k+1):\n                nx,ny = x+xx*i,y+yy*i\n                if cord[ny][nx] == '.':\n                    l.append((nx,ny))\n                elif type(cord[ny][nx]) != int or cord[ny][nx] < dep+1:\n                    break\n        for nx, ny in l:\n            if cord[ny][nx] == '.':\n                cord[ny][nx] = dep+1\n                if (nx,ny) == (xg,yg):\n                    return dep+1\n                else:\n                    queue.append((nx,ny,dep+1))\n    return -1\n\nh,w,k = iim()\nys,xs,yg,xg = iim()\n\ncord = [['@']*(w+2)]\nfor i in range(h):\n    cord.append(['@']+list(input())+['@'])\ncord.append(['@']*(w+2))\ncord[ys][xs] = '#'\n\nprint((bfs(xg,yg)))\n", "from heapq import heappop, heappush\n\n\ndef solve(field, s, t, k):\n    INF = 10 ** 18\n    ans = [[INF, INF] for _ in field]\n    ans[s][0] = ans[s][1] = 0\n    MOVE = [(-w2, 0), (-1, 1), (1, 1), (w2, 0)]\n\n    q = [(0, 0, s, 0)]\n    while q:\n        cost, straight, v, direction = heappop(q)\n        if v == t:\n            return (cost - 1) // k + 1\n\n        ceiling = ((cost - 1) // k + 1) * k + 1\n        for di, ax in MOVE:\n            u = v + di\n            if field[u] == '@':\n                continue\n            if di == direction:\n                nc = cost + 1\n                ns = straight + 1\n                if ns > k:\n                    ns -= k\n            else:\n                nc = ceiling\n                ns = 1\n            if ans[u][ax] <= nc:\n                continue\n            ans[u][ax] = nc\n            heappush(q, (nc, ns, u, di))\n\n    return -1\n\n\nh, w, k = list(map(int, input().split()))\nx1, y1, x2, y2 = list(map(int, input().split()))\nh2 = h + 2\nw2 = w + 2\n\nfield_tmp = [input() for _ in range(h)]\nfield = ['@' * w2]\nfor row in field_tmp:\n    field.append('@')\n    field.append(row)\n    field.append('@')\nfield.append('@' * w2)\nfield = ''.join(field)\ns = x1 * w2 + y1\nt = x2 * w2 + y2\nprint((solve(field, s, t, k)))\n", "from heapq import heappop, heappush \nfrom collections import deque\ndef dijkstra(xs, ys, xg, yg,h,w,k,field):\n    # que->(cost, x, y, direction)\n    inf = 1e18\n    dist = [[inf]*w for _ in range(h)]\n    dist[xs][ys] = 0\n    que = deque([(0, xs, ys)])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    while que:\n        cost, x, y = que.popleft()\n        if cost > dist[x][y]:\n            continue\n        for v in range(4):\n            nx, ny = x, y\n            for _ in range(k):\n                nx += dx[v]\n                ny += dy[v]\n                if not field[nx][ny]:\n                    break\n                if dist[nx][ny]<=dist[x][y]:\n                    break\n                if dist[nx][ny] > dist[x][y]+1:\n                    dist[nx][ny] = dist[x][y]+1\n                    que.append((dist[nx][ny], nx, ny))\n\n    if dist[xg][yg] == inf:\n        print((-1))\n    else:\n        print((dist[xg][yg]))\n\n        \n\ndef main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    h, w, k = list(map(int, input().split()))\n    xs, ys, xg, yg = list(map(int, input().split()))\n    field = [[False]*(w+2) for _ in range(h+2)]\n    for i in range(h):\n        # False \u3067\u8986\u3046\u3053\u3068\u3067x,y\u306e\u5236\u9650\u3092\u306a\u304f\u3059\u3002\n        s = [True if _ == '.' else False for _ in input()]\n        field[i+1] = [False]+s+[False]\n    h += 2\n    w += 2\n    dijkstra(xs, ys, xg, yg, h, w, k, field)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\n\ndef bfs(x1, y1, d):\n    q = deque([])\n    q.append((d, x1, y1))\n    M[x1][y1] = d\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n                if x2 < 0 or x2 >= H:\n                    break\n                if y2 < 0 or y2 >= W:\n                    break\n                if m[x2][y2] == '@':\n                    break\n                if M[x2][y2] < d + 1:\n                    break\n                if M[x2][y2] == d + 1:\n                    continue\n\n                q.append((d + 1, x2, y2))\n                M[x2][y2] = d + 1\n\n                # if (0 <= x2 < H) and (0 <= y2 < W):\n                #     if m[x2][y2] == '@':\n                #         break\n                #     elif M[x2][y2] == -1:\n                #         M[x2][y2] = d + 1\n                #         q.append((d + 1, x2, y2))\n                #     elif M[x2][y2] == d + 1:\n                #         continue\n                #     else:\n                #         break\n                # else:\n                #     break\n    print((-1))\n\n\nH, W, K = list(map(int, sys.stdin.readline().strip().split()))\nxs, ys, xg, yg = list(map(int, sys.stdin.readline().strip().split()))\nxg -= 1\nyg -= 1\n\nm = []\nfor _ in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[float('inf')] * W for _ in range(H)]\n\nbfs(xs - 1, ys - 1, 0)\n", "#import heapq\nfrom collections import deque\nh,w,k = list(map(int, input().split()))\nx1,y1,x2,y2 = list(map(int, input().split()))\nx1,y1,x2,y2 = x1-1,y1-1,x2-1,y2-1\ndp = [[-1]*w for _ in range(h)]\n#que = []\nque = deque()\nc = [input() for _ in range(h)]\n\ndp[x1][y1] = 0\n#heapq.heappush(que, (dp[x1][y1], [x1,y1]))\nque.append((x1,y1))\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\nwhile que:\n  #p= heapq.heappop(que)[1]\n  #x,y= p[0],p[1]\n  p = que.popleft()\n  if (p[0] == x2) & (p[1] == y2):print(dp[x2][y2]);return\n  for i in range(4):\n    for j in range(1,k+1):\n      nx = p[0] + dx[i]*j\n      ny = p[1] + dy[i]*j\n      if not ((0 <= nx < h) & (0 <= ny < w)):break\n      if c[nx][ny] == '@':break\n      if 0 <= dp[nx][ny] <= dp[p[0]][p[1]]:break\n      if dp[nx][ny] == -1:\n        #heapq.heappush(que, (dp[nx][ny], [nx,ny]))\n        que.append((nx,ny))\n      dp[nx][ny] = dp[p[0]][p[1]] + 1\n\nprint(-1)", "from collections import deque\nimport sys\n\n\ndef bfs(xs, ys, d):\n    queue = deque()\n    queue.append((xs, ys, d))\n    M[xs][ys] = d\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        x1, y1, d = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [x1, y1] == [xg, yg]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return\n\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n\n                if (0 <= x2 < H) and (0 <= y2 < W):\n                    if m[x2][y2] == \"@\":\n                        break\n                    elif M[x2][y2] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        M[x2][y2] = d + 1\n                        queue.append((x2, y2, d + 1))  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif M[x2][y2] < d + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nxs, ys, xg, yg = list(map(int, input().split()))\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(xs, ys, 0)\n\nprint((M[xg][yg]))\n", "def main():\n  import sys\n  input=sys.stdin.readline\n  h,w,k=map(int,input().split())\n  sx,sy,tx,ty=map(int,input().split())\n  b=[[-1]*(w+2)]\n  for i in range(h):\n    s=input()\n    bb=[-1]\n    for j in s:\n      if j==\".\":bb.append(0)\n      else:bb.append(-1)\n    bb.append(-1)\n    b.append(bb)\n  b.append([-1]*(w+2))\n  d=[]\n  d.append((sx,sy))\n  for ss in d:\n    x,y=ss\n    if x==tx and y==ty:\n      print(b[x][y]);return\n    for i in range(1,k+1):\n      if b[x+i][y]<=b[x][y] and b[x+i][y]!=0:break\n      if b[x+i][y]==0:d.append((x+i,y))\n      b[x+i][y]=b[x][y]+1\n    for i in range(1,k+1):\n      if b[x-i][y]<=b[x][y] and b[x-i][y]!=0:break\n      if b[x-i][y]==0:d.append((x-i,y))\n      b[x-i][y]=b[x][y]+1\n    for j in range(1,k+1):\n      if b[x][y+j]<=b[x][y] and b[x][y+j]!=0:break\n      if b[x][y+j]==0:d.append((x,y+j))\n      b[x][y+j]=b[x][y]+1\n    for j in range(1,k+1):\n      if b[x][y-j]<=b[x][y] and b[x][y-j]!=0:break\n      if b[x][y-j]==0:d.append((x,y-j))\n      b[x][y-j]=b[x][y]+1\n  print(-1)\ndef __starting_point():\n  main()\n\n__starting_point()", "h,a,*m=open(0)\nh,w,k,a,b,f,g=map(int,(h+a).split())\nm+='@'*w,\nd=[I:=h*w]*I\na=~w+a*w+b\nd[a]=1\nq=[a]\nfor s in q:\n for y,x in(1,0),(-1,0),(0,1),(0,-1):\n  for z in range(k):\n   i,j=s//w+y*~z,s%w+x*~z;t=i*w+j;p=d[s]+1\n   if'.'!=m[i][j]or d[t]<p:break\n   if d[t]>p:q+=t,;d[t]=p\nprint(d[~w+f*w+g]%I-1)", "from sys import stdin\ndef input():\n    return stdin.readline().strip()\n\nimport heapq\n\ndef main():\n    h, w, k = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n\n    # surround the square with '@'\n    c = [['@'] * (w+2)]\n    for _ in range(h):\n        i = input()\n        l = ['@']\n        for j in i:\n            l.append(j)\n        l.append('@')\n        c.append(l)\n    c.append(['@'] * (w+2))\n\n    # Dijkstra\n    # seen[x][y] = the minimum cost of (x, y)\n    # if seen[x][y] == -1, (x, y) is unresearched\n    seen = [[-1] * (w+2) for _ in range(h+2)]\n\n    # todo[i] == (cost, x, y, direction)\n    todo = [(0, x1, y1, 0)]\n    heapq.heapify(todo)\n\n    # direction\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while len(todo) > 0:\n        cost, xi, yi, direction = heapq.heappop(todo)\n\n        # only straight\n        if seen[xi][yi] != -1:\n            if (seen[xi][yi]+k-1)//k * k > cost:\n                xj, yj = xi + dx[direction], yi + dy[direction]\n                if c[xj][yj] == '.':\n                    heapq.heappush(todo, (cost+1, xj, yj, direction))\n            continue\n        seen[xi][yi] = cost\n\n        # goal\n        if xi == x2 and yi == y2:\n            print((cost+k-1)//k)\n            return\n        \n        # 4 directions\n        for j in range(4):\n            xj, yj = xi + dx[j], yi + dy[j]\n            if c[xj][yj] == '.':\n                if j == direction:\n                    if seen[xj][yj] == -1 or (seen[xj][yj]+k-1)//k * k > cost:\n                        heapq.heappush(todo, (cost+1, xj, yj, j))\n                elif seen[xj][yj] == -1:\n                    heapq.heappush(todo, ((cost+k-1)//k * k + 1, xj, yj, j))\n\n    print(-1)\n\nmain()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random,resource\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    h,w,k = LI()\n    y1,x1,y2,x2 = LI_()\n    ca = [S() for _ in range(h)]\n\n    aa = [[-1 if c == '@' else inf for c in s] for s in ca]\n    aa[y1][x1] = 0\n    q = [(y1,x1)]\n    v = collections.defaultdict(bool)\n    t = 0\n    while q:\n        t += 1\n        nq = []\n        for y,x in q:\n            for dy, dx in dd:\n                for i in range(1, k+1):\n                    ty = y + dy * i\n                    tx = x + dx * i\n                    if ty < 0 or ty >= h or tx < 0 or tx >= w or aa[ty][tx] < t:\n                        break\n\n                    if aa[ty][tx] == t:\n                        continue\n\n                    aa[ty][tx] = t\n                    nq.append((ty,tx))\n\n        q = nq\n\n    if aa[y2][x2] == inf:\n        return -1\n\n    return aa[y2][x2]\n\n\nprint(main())\n\n\n", "from collections import deque\n\n\ndef bfs(maze, visited, sy, sx, gy, gx):\n    queue = deque([[sy, sx]])\n    visited[sy][sx] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        y, x = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [y, x] == [gy, gx]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return visited[y][x]\n        for j, k in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            l = 1\n            while True:\n                new_y, new_x = y + j * l, x + k * l\n                if (0 <= new_y < H) and (0 <= new_x < W):\n                    if maze[new_y][new_x] == \"@\":\n                        break\n                    elif visited[new_y][new_x] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        visited[new_y][new_x] = visited[y][x] + 1\n                        queue.append([new_y, new_x])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif visited[new_y][new_x] < visited[y][x] + 1:\n                        break\n                else:\n                    break\n                l += 1\n                if l == K + 1:\n                    break\n\n\nH, W, K = map(int, input().split())\n# K = min(K, max(H, W))\nx1, y1, x2, y2 = map(int, input().split())\nx1, y1, x2, y2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1\nC = [0] * H\nfor i in range(H):\n    C[i] = str(input())\nvisited = [[-1] * W for i in range(H)]\nbfs(C, visited, x1, y1, x2, y2)\n# print(visited)\nprint(visited[x2][y2])", "from collections import*\nz,v,a=input,range,print\nh,w,k=map(int,z().split());r,s,t,u=map(lambda x:int(x)-1,z().split());b=[z()for _ in v(h)];l=[[-1]*w for _ in v(h)];l[r][s]=0;d=deque([(r,s)])\nwhile d:\n  x,y=d.popleft();j=l[x][y]\n  if(x==t)&(y==u):a(j);return\n  for e,f in[[1,0],[-1,0],[0,-1],[0,1]]:\n    for i in v(1,k+1):\n      p,q=x+e*i,y+f*i\n      if not((0<=p<h)&(0<=q<w))or b[p][q]==\"@\" or 0<=l[p][q]<=j:break\n      if l[p][q]<0:d+=[(p,q)];l[p][q]=j+1\na(-1)", "# -*- coding: utf-8 -*-\n\nH,W,K = map(int, input().split())\nx1,y1,x2,y2 = map(int, input().split())\n\nC = [input() for _ in range(H)]\nT = [[-1 for _ in range(W)] for _ in range(H)]\nT[x1-1][y1-1] = 0\n\nque = set([(x1-1,y1-1)])\nstep = 1\n\nwhile len(que)>0:\n  que_next = set()\n  for q in que:\n    x,y = q[0],q[1]\n    for i in range(1,K+1):\n      if x-i<0:\n        break\n      if C[x-i][y]=='@' or T[x-i][y]==1:\n        break\n      que_next.add((x-i,y))\n    for i in range(1,K+1):\n      if x+i>H-1:\n        break\n      if C[x+i][y]=='@' or T[x+i][y]==1:\n        break\n      que_next.add((x+i,y))\n    for i in range(1,K+1):\n      if y-i<0:\n        break\n      if C[x][y-i]=='@' or T[x][y-i]==1:\n        break\n      que_next.add((x,y-i))\n    for i in range(1,K+1):\n      if y+i>W-1:\n        break\n      if C[x][y+i]=='@' or T[x][y+i]==1:\n        break\n      que_next.add((x,y+i))\n  que = que_next\n  for q in que:\n    if q[0]==x2-1 and q[1]==y2-1:\n      print(step)\n      return\n    T[q[0]][q[1]] = 1\n  step += 1\n\nprint(-1)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n    h, w, k = list(map(int, input().split()))\n    sx, sy, gx, gy = list(map(int, input().split()))\n\n    c = [input() for i in range(h)]\n\n    not_yet = deque([(sx-1, sy-1)])\n    dist = [[-1]*w for i in range(h)]\n    dist[sx-1][sy-1] = 0\n    already = [[False]*w for i in range(h)]\n    already[sx-1][sy-1] = True\n\n    while not_yet:\n        x, y = not_yet.popleft()\n        d = dist[x][y]\n\n        for i in range(x+1, x+k+1):\n            if i >= h or c[i][y] == \"@\":\n                break\n            if already[i][y] and dist[i][y] < d + 1:\n                break\n            if already[i][y] and dist[i][y] == d + 1:\n                continue\n            dist[i][y] = d + 1\n            already[i][y] = True\n            not_yet.append((i, y))\n\n        for i in range(x-1, x-k-1, -1):\n            if i < 0 or c[i][y] == \"@\":\n                break\n            if already[i][y] and dist[i][y] < d + 1:\n                break\n            if already[i][y] and dist[i][y] == d + 1:\n                continue\n            dist[i][y] = d + 1\n            already[i][y] = True\n            not_yet.append((i, y))\n        \n        for i in range(y+1, y+k+1):\n            if i >= w or c[x][i] == \"@\":\n                break\n            if already[x][i] and dist[x][i] < d + 1:\n                break\n            if already[x][i] and dist[x][i] == d + 1:\n                continue\n            dist[x][i] = d + 1\n            already[x][i] = True\n            not_yet.append((x, i))\n\n        for i in range(y-1, y-k-1, -1):\n            if i < 0 or c[x][i] == \"@\":\n                break\n            if already[x][i] and dist[x][i] < d + 1:\n                break\n            if already[x][i] and dist[x][i] == d + 1:\n                continue\n            dist[x][i] = d + 1\n            already[x][i] = True\n            not_yet.append((x, i))\n\n    ans = dist[gx-1][gy-1]\n    print(ans)\n\n    \ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import deque\nh, w, k = map(int, input().split())\ny1, x1, y2, x2 = map(int, input().split())\nc = []\nfor _ in range(h):\n    c.append(input())\nq = deque([(x1-1, y1-1)])\ndxdy = [(-1,0), (0,-1), (0,1), (1,0)]\ndist = [[1000000]*w for _ in range(h)]\ndist[y1-1][x1-1] = 0\nwhile q:\n    x, y = q.popleft()\n    for ddx, ddy in dxdy:\n        for i in range(1, k+1):\n            dx = ddx*i\n            dy = ddy*i\n            if not (0<=x+dx<w and 0<=y+dy<h):\n                break\n            if c[y+dy][x+dx]=='@' or dist[y+dy][x+dx]<=dist[y][x]:\n                break\n            if x+dx==x2-1 and y+dy==y2-1:\n                print(dist[y][x]+1)\n                return\n            if dist[y+dy][x+dx]>dist[y][x]+1:\n                dist[y+dy][x+dx] = dist[y][x]+1\n                q.append((x+dx, y+dy))\nprint(-1)", "from collections import deque\nimport sys\n\ndef bfs(M, sy, sx, gy, gx):\n    queue = deque([[sy, sx]])\n    M[sy][sx] = 0\n    while queue:\n        # queue\u306b\u306f\u8a2a\u308c\u305f\u5730\u70b9\u304c\u5165\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u304b\u3089\u30014\u65b9\u5411\u306b\u79fb\u52d5\u3067\u304d\u308b\u304b\u8003\u3048\u3001queue\u304b\u3089\u6d88\u3059\u3002\n        y, x = queue.popleft()  # queue\u306b\u5165\u3063\u3066\u3044\u305f\u3082\u306e\u3092\u6d88\u3059\u3002\n        if [y, x] == [gy, gx]:  # \u3082\u3057\u30b4\u30fc\u30eb\u306b\u3064\u3044\u3066\u3044\u305f\u306a\u3089\u3070\u3001\u305d\u306e\u3068\u304d\u306e\u624b\u6570\u3092\u51fa\u3059\u3002\n            return M[y][x]\n        for dx, dy in ([1, 0], [-1, 0], [0, 1], [0, -1]):\n            for k in range(1, K + 1):\n                new_x = x + dx * k\n                new_y = y + dy * k\n\n                if (0 <= new_y < H) and (0 <= new_x < W):\n                    if m[new_y][new_x] == \"@\":\n                        break\n                    elif M[new_y][new_x] == -1:  # \u307e\u3060\u6765\u305f\u3053\u3068\u306a\u3044\u70b9\u3060\u3063\u305f\u3068\u3044\u3046\u6761\u4ef6\n                        M[new_y][new_x] = M[y][x] + 1\n                        queue.append([new_y, new_x])  # \u65b0\u3057\u3044\u70b9\u3092\u8db3\u3059\u3002\n                    elif M[new_y][new_x] < M[y][x] + 1:\n                        break\n                else:\n                    break\n\n\nH, W, K = list(map(int, input().split()))\n# K = min(K, max(H, W))\nx1, y1, x2, y2 = list(map(int, input().split()))\nx1, y1, x2, y2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n    \nM = [[-1] * W for i in range(H)]\n\nbfs(M, x1, y1, x2, y2)\n\nprint((M[x2][y2]))\n", "from sys import stdin\ndef input():\n    return stdin.readline().strip()\n\nimport heapq\n\ndef main():\n    h, w, k = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n\n    # surround the square with '@'\n    c = [['@'] * (w+2)]\n    for _ in range(h):\n        i = list('@' + input() + '@')\n        c.append(i)\n    c.append(['@'] * (w+2))\n\n    # Dijkstra\n    # seen[x][y] = the minimum cost of (x, y)\n    # if seen[x][y] == -1, (x, y) is unresearched\n    seen = [[-1] * (w+2) for _ in range(h+2)]\n\n    # todo[i] == (cost, x, y, direction)\n    todo = [(0, x1, y1, 0)]\n    heapq.heapify(todo)\n\n    # direction\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    while len(todo) > 0:\n        cost, xi, yi, direction = heapq.heappop(todo)\n\n        # special case\n        if seen[xi][yi] != -1:\n            if (seen[xi][yi]+k-1)//k * k >= cost:\n                xj, yj = xi + dx[direction], yi + dy[direction]\n                if c[xj][yj] == '.':\n                    heapq.heappush(todo, (cost+1, xj, yj, direction))\n            continue\n        seen[xi][yi] = cost\n\n        # goal\n        if xi == x2 and yi == y2:\n            print((cost+k-1)//k)\n            return\n        \n        # add\n        for j in range(4):\n            xj, yj = xi + dx[j], yi + dy[j]\n            if c[xj][yj] == '.':\n                if j == direction:\n                    if seen[xj][yj] == -1 or (seen[xj][yj]+k-1)//k * k > cost:\n                        heapq.heappush(todo, (cost+1, xj, yj, j))\n                elif seen[xj][yj] == -1:\n                    heapq.heappush(todo, ((cost+k-1)//k * k + 1, xj, yj, j))\n\n    print(-1)\n\nmain()", "import sys\nfrom collections import deque\n\n\ndef bfs(x1, y1, d):\n    q = deque([])\n    q.append((d, x1, y1))\n    M[x1][y1] = d\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n                if x2 < 0 or x2 >= H:  # \u67a0\u5916\n                    break\n                if y2 < 0 or y2 >= W:  # \u67a0\u5916\n                    break\n                if m[x2][y2] == '@':  # \u84ee\u306e\u8449\n                    break\n                if M[x2][y2] < d + 1:  # \u3088\u308a\u826f\u3044\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\n                    break\n                if M[x2][y2] == d + 1:  # \u540c\u7b49\u306e\u826f\u3055\u306e\u7d4c\u8def\u3092\u63a2\u7d22\u6e08\u307f\u3002\u3000\u98db\u3073\u8d8a\u3048\u3066\u6b21\u306e\u30de\u30b9\u3092\u63a2\u7d22\u3059\u308b\u3002\n                    continue\n\n                q.append((d + 1, x2, y2))\n                M[x2][y2] = d + 1\n\n    print((-1))\n\n\nH, W, K = list(map(int, sys.stdin.readline().strip().split()))\nxs, ys, xg, yg = list(map(int, sys.stdin.readline().strip().split()))\nxg -= 1\nyg -= 1\n\nm = []\nfor _ in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[float('inf')] * W for _ in range(H)]\n\nbfs(xs - 1, ys - 1, 0)\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nH, W, K = map(int,input().split())\nsth, stw, glh, glw = map(int,input().split())\nsth, stw = sth-1, stw-1\nglh, glw = glh-1, glw-1\n\nINF = -1\nGmap = [list(input()) for _ in range(H)]\nSeen = [[INF]*W for _ in range(H)]\ndirec = {(1,0), (-1,0), (0,1), (0,-1)}\n\nfrom collections import deque\n\ndef bfs(sth, stw, glh, glw):\n    next_q = deque([])\n    next_q.append((sth,stw,0))\n    Seen[sth][stw] = 0\n\n    while len(next_q)!=0:\n        #\u30ad\u30e5\u30fc\u53d6\u308a\u51fa\u3057(\u5148\u982d)\n        h, w, c = next_q.popleft()\n        for dh, dw in direc:\n            for sk in range(1,K+1):\n                hs, ws = h + dh*sk, w + dw*sk\n                if not (0<=hs<H and 0<=ws<W):\n                    break\n                if Gmap[hs][ws]=='@':\n                    break\n                if Seen[hs][ws]==INF:\n                    next_q.append((hs,ws,c+1))\n                    Seen[hs][ws] = c + 1\n                elif Seen[hs][ws]<=c:\n                    break\n                if hs==glh and ws==glw:\n                    return c + 1\n    return -1\n\ndef main():\n    ret = bfs(sth, stw, glh, glw)\n    print(ret)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef main():\n  h, w, k = map(int, input().split())\n  x1, y1, x2, y2 = map(lambda x:int(x)-1, input().split())\n  v1 = x1*(w+1)+y1\n  v2 = x2*(w+1)+y2\n  C = \"\".join(input().rstrip()+\"@\" for _ in range(h))\n  dist = [-1 if c==\"@\" else 10**10 for c in C]\n  ans = 0\n  que = deque()\n  que.append(v1)\n  dist[v1] = 0\n  while que:\n    v = que.popleft()\n    if v == v2:\n      print(dist[v2])\n      return\n    d = dist[v]+1\n    for dr in (-(w+1), -1, w+1, 1):\n      for i in range(1, k+1):\n        nv = v+dr*i\n        if 0 <= nv < h*(w+1):\n          if dist[nv] > d:\n            dist[nv] = d\n            que.append(nv)\n          elif dist[nv] == d:\n            continue\n          else:\n            break\n        else:\n          break\n  print(-1)\ndef __starting_point():\n  main()\n__starting_point()", "def main():\n    h,a,*m=open(0)\n    h,w,k,a,b,f,g=map(int,(h+a).split())\n    I=h*w\n    d=[I]*I\n    a=~w+a*w+b\n    d[a]=1\n    q=[a]\n    for s in q:\n        for y,x in(1,0),(-1,0),(0,1),(0,-1):\n            for z in range(k):\n                i,j=s//w+y*~z,s%w+x*~z\n                t=i*w+j\n                if not h>i>-1<j<w or'.'<m[i][j]or d[t]<=d[s]:break\n                if d[t]==I:\n                    q+=t,\n                    d[t]=d[s]+1\n    print(d[~w+f*w+g]%I-1)\nmain()", "from collections import deque\nimport sys\n\nN_MAX = 200000 + 5\n\nH, W, K = list(map(int, input().split()))\nsth, stw, glh, glw = list(map(int, input().split()))\n\nINF = 10**6 * K\n\ndp = [[INF for _ in range(W + 2)] for _ in range(H + 2)]\n\ndp[0] = [-1] * (W + 2)\ndp[H + 1] = [-1] * (W + 2)\nfor h in range(1, H + 1):\n    s = sys.stdin.readline()\n    dp[h][0] = -1\n    dp[h][W + 1] = -1\n    for w in range(1, W + 1):\n        if s[w - 1] == \"@\":\n            dp[h][w] = -1\n\ndp[sth][stw] = 0\n\n\n# Seen = [[INF]*W for _ in range(H)]\nXY = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n\n\ndef bfs(sth, stw, glh, glw):\n    next_q = deque()\n    next_q.append((sth, stw))\n\n    while len(next_q) != 0:\n        # \u30ad\u30e5\u30fc\u53d6\u308a\u51fa\u3057(\u5148\u982d)\n        h, w = next_q.popleft()\n        for dh, dw in XY:\n            for sk in range(1, K + 1):\n                hs, ws = h + dh * sk, w + dw * sk\n                if dp[hs][ws] == -1:\n                    break\n                if dp[hs][ws] == INF:\n                    next_q.append((hs, ws))\n                    dp[hs][ws] = dp[h][w] + 1\n                elif dp[hs][ws] <= dp[h][w]:\n                    # \u3082\u3057\u3001dp[hs][ws] \u304c \u4eca\u306e\u5024\u4ee5\u4e0b\u306a\u3089\n                    # \u305d\u306e\u5148\u306fdp[hs][ws]\u3092\u3082\u3068\u306b \u66f8\u304d\u8fbc\u307e\u308c\u3066\u3044\u308b or \u4eca\u5f8c\u66f8\u304d\u8fbc\u307e\u308c\u308b \u306e\u3067\u6b62\u3081\u308b\n                    break\n                # if hs == glh and ws == glw:\n                #    return dp[h][w] + 1\n    # return -1\n\n\ndef main():\n    bfs(sth, stw, glh, glw)\n\n    if dp[glh][glw] == INF:\n        print((-1))\n    else:\n        print((dp[glh][glw]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: list(map(int, readline().split()))\nnl = lambda: list(map(int, readline().split()))\n\n\ndef solve():\n    h, w, k = nm()\n    sy, sx, gy, gx = nm()\n    d = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    sx -= 1; sy -= 1\n    gx -= 1; gy -= 1\n    C = [ns() for _ in range(h)]\n    G = [[10**7]*w for _ in range(h)]\n    G[sy][sx] = 0\n    q = deque([(sy, sx)])\n    while q:\n        y, x = q.popleft()\n        for i in range(4):\n            dy, dx = d[i]\n            ny, nx = y, x\n            for _ in range(k):\n                ny += dy; nx += dx\n                if ny < 0 or h <= ny or nx < 0 or w <= nx:\n                    break\n                if C[ny][nx] == '@' or G[ny][nx] <= G[y][x]:\n                    break\n                if G[ny][nx] > G[y][x] + 1:\n                    G[ny][nx] = G[y][x] + 1\n                    q.append((ny, nx))\n                    if ny == gy and nx == gx:\n                        print((G[y][x] + 1))\n                        return\n    print((-1))\n    return\n\nsolve()\n", "from collections import deque\nimport sys\n\nN_MAX = 200000 + 5\n\nH, W, K = list(map(int, input().split()))\nsth, stw, glh, glw = list(map(int, input().split()))\n\nINF = 10**6 * K\n\ndp = [[INF for _ in range(W+2)] for _ in range(H+2)]\n\ndp[0] = [-1]*(W+2)\ndp[H+1] = [-1]*(W+2)\nfor h in range(1, H+1):\n    s = sys.stdin.readline()\n    dp[h][0] = -1\n    dp[h][W+1] = -1\n    for w in range(1, W+1):\n        if s[w-1] == \"@\":\n            dp[h][w] = -1\n\ndp[sth][stw] = 0\n\n\n# Seen = [[INF]*W for _ in range(H)]\nXY = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n\n\ndef bfs(sth, stw, glh, glw):\n    next_q = deque()\n    next_q.append((sth, stw))\n\n    while len(next_q) != 0:\n        # \u30ad\u30e5\u30fc\u53d6\u308a\u51fa\u3057(\u5148\u982d)\n        h, w = next_q.popleft()\n        for dh, dw in XY:\n            for sk in range(1, K+1):\n                hs, ws = h + dh*sk, w + dw*sk\n                if dp[hs][ws] == -1:\n                    break\n                if dp[hs][ws] == INF:\n                    next_q.append((hs, ws))\n                    dp[hs][ws] = dp[h][w] + 1\n                elif dp[hs][ws] <= dp[h][w]:\n                    break\n                if hs == glh and ws == glw:\n                    return dp[h][w] + 1\n    return -1\n\n\ndef main():\n    ret = bfs(sth, stw, glh, glw)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappop, heappush\n\n\ndef solve(field, s, t, k):\n    INF = 10 ** 18\n    ans = [[INF, INF] for _ in field]\n    ans[s][0] = ans[s][1] = 0\n    MOVE = [(-w2, 0), (-1, 1), (1, 1), (w2, 0)]\n\n    q = [(0, s, 0)]\n    while q:\n        cost, v, direction = heappop(q)\n        if v == t:\n            return (cost - 1) // k + 1\n\n        ceiling = -1\n        for di, ax in MOVE:\n            u = v + di\n            if field[u] == '@':\n                continue\n            nc = cost + 1 if di == direction else ceiling\n            if nc == -1:\n                nc = ceiling = ((cost - 1) // k + 1) * k + 1\n            if ans[u][ax] <= nc:\n                continue\n            ans[u][ax] = nc\n            heappush(q, (nc, u, di))\n\n    return -1\n\n\nh, w, k = list(map(int, input().split()))\nx1, y1, x2, y2 = list(map(int, input().split()))\nh2 = h + 2\nw2 = w + 2\n\nfield_tmp = [input() for _ in range(h)]\nfield = ['@' * w2]\nfor row in field_tmp:\n    field.append('@')\n    field.append(row)\n    field.append('@')\nfield.append('@' * w2)\nfield = ''.join(field)\ns = x1 * w2 + y1\nt = x2 * w2 + y2\nprint((solve(field, s, t, k)))\n", "from collections import deque\nh,w,k = map(int,input().split())\ny1,x1,gy,gx = map(int,input().split())\nm = [\"@\"*(w+2)]+[\"@\"+input()+\"@\" for i in range(h)]+[\"@\"*(w+2)]\nopt = [(1,0),(0,1),(-1,0),(0,-1)]\ndq=deque([(y1,x1)])\nans = 0\ntemp = [[-1]*(w+2) for i in range(h+2)]\ntemp[y1][x1] = 0\ncnt = 0\nwhile dq:\n    # cnt += 1\n    # print(cnt)\n    y,x = dq.popleft()\n    # print(dq,y,x)\n    for j in opt:\n        y1 = y+j[0]\n        x1 = x+j[1]\n        if m[y1][x1] == \"@\":\n            # print(y1,x1,\"@@\")\n            continue\n        if temp[y1][x1] == -1 or temp[y1][x1]-temp[y][x]>0:\n            for i in range(k):\n                if (temp[y1+i*j[0]][x1+i*j[1]] == -1 or temp[y1+i*j[0]][x1+i*j[1]]-temp[y][x]>0) and m[y1+i*j[0]][x1+i*j[1]] == \".\":\n                    if temp[y1+i*j[0]][x1+i*j[1]]-temp[y][x]==1:\n                        continue\n                    temp[y1+i*j[0]][x1+i*j[1]] = temp[y][x]+1\n                    dq.append((y1+i*j[0],x1+i*j[1]))\n                    # print(y1+i*j[0],x1+i*j[1],\"a\",k,m[y1+i*j[0]][x1+i*j[1]],temp[y1+i*j[0]][x1+i*j[1]])\n                else:\n                    # print(y1+i*j[0],x1+i*j[1],\"b\",k,m[y1+i*j[0]][x1+i*j[1]],temp[y1+i*j[0]][x1+i*j[1]])\n                    break\n    # for i in temp:\n    #     print(i)\n# print(temp)\nprint(temp[gy][gx])", "import collections\n\nH, W, K = [int(x) for x in input().split()]\nX1, Y1, X2, Y2 = [int(x) for x in input().split()]\nC = [input().strip() for _ in range(H)]\n\nans = [[float(\"inf\")] * W for j in range(H)]\n\nq = collections.deque()\nq.append((X1 - 1, Y1 - 1))\n\nans[X1 - 1][Y1 - 1] = 0\n\nwhile q:\n    cx, cy = q.popleft()\n    cc = ans[cx][cy]\n    nc = cc + 1\n\n    # right\n    for i in range(1, K + 1):\n        if cy + i >= W or C[cx][cy + i] == \"@\":\n            break\n        if ans[cx][cy + i] <= nc - 1:\n            break\n        if ans[cx][cy + i] <= nc:\n            continue\n        ans[cx][cy + i] = nc\n        q.append((cx, cy + i))\n    # left\n    for i in range(1, K + 1):\n        if cy - i <= -1 or C[cx][cy - i] == \"@\":\n            break\n        if ans[cx][cy - i] <= nc - 1:\n            break\n        if ans[cx][cy - i] <= nc:\n            continue\n        ans[cx][cy - i] = nc\n        q.append((cx, cy - i))\n    # up\n    for i in range(1, K + 1):\n        if cx - i <= -1 or C[cx - i][cy] == \"@\":\n            break\n        if ans[cx - i][cy] <= nc - 1:\n            break\n        if ans[cx - i][cy] <= nc:\n            continue\n        ans[cx - i][cy] = nc\n        q.append((cx - i, cy))\n    # down\n    for i in range(1, K + 1):\n        if cx + i >= H or C[cx + i][cy] == \"@\":\n            break\n        if ans[cx + i][cy] <= nc - 1:\n            break\n        if ans[cx + i][cy] <= nc:\n            continue\n        ans[cx + i][cy] = nc\n        q.append((cx + i, cy))\n\nif ans[X2 - 1][Y2 - 1] == float(\"inf\"):\n    print((-1))\nelse:\n    print((ans[X2 - 1][Y2 - 1]))\n", "#\n\nimport sys\nfrom collections import deque\ninput=sys.stdin.readline\n\ndef main():\n    H,W,K=map(int,input().split())\n    x1,y1,x2,y2=map(int,input().split())\n    x1-=1\n    y1-=1\n    x2-=1\n    y2-=1\n    mas=[list(input()) for i in range(H)]\n\n    dist=[[-1]*W for i in range(H)]\n    dist[x1][y1]=0\n    \n    qu=deque([(x1,y1)])\n    qup=qu.popleft\n    qua=qu.append\n    \n    d=((-1,0),(1,0),(0,-1),(0,1))\n    \n    while(len(qu)>0):\n        v=qup()\n        for di in d:\n            for i in range(1,K+1):\n                nvh=v[0]+i*di[0]\n                nvw=v[1]+i*di[1]\n                if nvh<0 or nvh>=H or nvw<0 or nvw>=W or mas[nvh][nvw]==\"@\":\n                    break\n                if dist[nvh][nvw]!=-1 and dist[nvh][nvw]<=dist[v[0]][v[1]]:\n                    break\n                if dist[nvh][nvw]==-1:\n                    dist[nvh][nvw]=dist[v[0]][v[1]]+1\n                    qua((nvh,nvw))\n    print(dist[x2][y2])\n    \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nimport sys\n\n\ndef bfs(x1, y1, d):\n    q = deque()\n    q.append((d, x1, y1))\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        M[x1][y1] = d\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n\n                if (0 <= x2 < H) and (0 <= y2 < W):\n                    if m[x2][y2] == '@':\n                        break\n                    elif M[x2][y2] == -1:\n                        M[x2][y2] = d + 1\n                        q.append((d + 1, x2, y2))\n                    elif M[x2][y2] < d + 1:\n                        break\n                else:\n                    break\n    print((-1))\n\n\nH, W, K = list(map(int, input().split()))\nxs, ys, xg, yg = list(map(int, input().split()))\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(xs, ys, 0)\n", "from collections import deque\n\nH, W, K = map(int, input().split())\nx1, y1, x2, y2 = (int(i) - 1 for i in input().split())\nC = [input() for _ in range(H)]\n\nans = [[-1] * W for _ in range(H)]\nans[x1][y1] = 0\n\nQ = deque([(x1, y1)])\nwhile Q:\n    x, y = Q.popleft()\n    if (x, y) == (x2, y2):\n        print(ans[x][y])\n        return\n\n    for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        for a in range(1, K + 1):\n            nx = x + a * di\n            ny = y + a * dj\n\n            if not (0 <= nx < H and 0 <= ny < W) or C[nx][ny] == \"@\" or 0 <= ans[nx][ny] <= ans[x][y]:\n                break\n\n            if ans[nx][ny] == -1:\n                Q.append((nx, ny))\n\n            ans[nx][ny] = 1 + ans[x][y]\n\nprint(-1)", "from heapq import heappop, heappush \nfrom collections import deque\ndef dijkstra(xs, ys, xg, yg,h,w,k,field):\n    # que->(cost, x, y, direction)\n    inf = 1e18\n    dist = [[inf]*w for _ in range(h)]\n    dist[xs][ys] = 0\n    que = deque([(0, xs, ys)])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    while que:\n        cost, x, y = que.popleft()\n        if cost > dist[x][y]:\n            continue\n        for v in range(4):\n            nx, ny = x, y\n            for _ in range(k):\n                nx += dx[v]\n                ny += dy[v]\n                if not field[nx][ny]:\n                    break\n                if dist[nx][ny]<=dist[x][y]:\n                    break\n                if dist[nx][ny] > dist[x][y]+1:\n                    dist[nx][ny] = dist[x][y]+1\n                    que.append((dist[nx][ny], nx, ny))\n\n    if dist[xg][yg] == inf:\n        print(-1)\n    else:\n        print(dist[xg][yg])\n\n        \n\ndef main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    h, w, k = map(int, input().split())\n    xs, ys, xg, yg = map(int, input().split())\n    field = [[False]*(w+2) for _ in range(h+2)]\n    for i in range(h):\n        # False \u3067\u8986\u3046\u3053\u3068\u3067x,y\u306e\u5236\u9650\u3092\u306a\u304f\u3059\u3002\n        s = [True if _ == '.' else False for _ in input()]\n        field[i+1] = [False]+s+[False]\n    h += 2\n    w += 2\n    dijkstra(xs, ys, xg, yg, h, w, k, field)\n\ndef __starting_point():\n    main()\n__starting_point()", "def ii():return int(input())\ndef iim():return list(map(int,input().split()))\ndef iil():return list(map(int,input().split()))\nfrom collections import deque\n\n\ndef bfs(xg,yg):\n    queue = deque([(xs,ys,0)])\n    while queue:\n        x,y,dep = queue.popleft()\n        l = []\n        f1 = True\n        f2 = True\n        f3 = True\n        f4 = True\n        for i in range(1,k+1):\n            if f1:\n                if cord[y][x+i] == '.':\n                    l.append((x+i,y))\n                elif cord[y][x+i] == '@' or cord[y][x+i] != dep+1:\n                    f1 = False\n            if f2:\n                if cord[y][x-i] == '.':\n                    l.append((x-i,y))\n                elif cord[y][x-i] == '@' or cord[y][x-i] != dep+1:\n                    f2 = False\n            if f3:\n                if cord[y+i][x] == '.':\n                    l.append((x,y+i))\n                elif cord[y+i][x] == '@' or cord[y+i][x] != dep+1:\n                    f3 = False\n            if f4:\n                if cord[y-i][x] == '.':\n                    l.append((x,y-i))\n                elif cord[y-i][x] == '@' or cord[y-i][x] != dep+1:\n                    f4 = False\n            if not (f1 or f2 or f3 or f4):\n                break\n        for nx, ny in l:\n            if cord[ny][nx] == '.':\n                cord[ny][nx] = dep+1\n                if (nx,ny) == (xg,yg):\n                    return dep+1\n                else:\n                    queue.append((nx,ny,dep+1))\n    return -1\n\nh,w,k = iim()\nys,xs,yg,xg = iim()\n\ncord = [['@']*(w+2)]\nfor i in range(h):\n    cord.append(['@']+list(input())+['@'])\ncord.append(['@']*(w+2))\ncord[ys][xs] = '#'\n#for i in cord:\n#    print(*i)\n#print(len(cord),len(cord[0]))\n\nprint((bfs(xg,yg)))\n", "import sys\nfrom collections import deque\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: list(map(int, readline().split()))\nnl = lambda: list(map(int, readline().split()))\n\n\ndef solve():\n    h, w, k = nm()\n    sy, sx, gy, gx = nm()\n    d = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    sx -= 1; sy -= 1\n    gx -= 1; gy -= 1\n    C = [ns() for _ in range(h)]\n    G = [[10**7]*w for _ in range(h)]\n    G[sy][sx] = 0\n    q = deque([(sy, sx)])\n    while q:\n        y, x = q.popleft()\n        for i in range(4):\n            dy, dx = d[i]\n            ny, nx = y, x\n            for _ in range(k):\n                ny += dy; nx += dx\n                if ny < 0 or h <= ny or nx < 0 or w <= nx:\n                    break\n                if C[ny][nx] == '@' or G[ny][nx] <= G[y][x]:\n                    break\n                if G[ny][nx] > G[y][x] + 1:\n                    G[ny][nx] = G[y][x] + 1\n                    q.append((ny, nx))\n    ans = G[gy][gx]\n    print((ans if ans < 10**7 else -1))\n    return\n\nsolve()\n", "h,a,*m=open(0)\nh,w,k,a,b,f,g=map(int,(h+a).split())\nd=[I:=h*w]*I\nm+=d,\nq=[a:=~w+a*w+b]\nd[a]=1\nfor s in q:\n for y,x in(1,0),(-1,0),(0,1),(0,-1):\n  for z in range(k):\n   i,j=s//w+y*~z,s%w+x*~z;t=i*w+j;p=d[s]+1\n   if'.'!=m[i][j]or d[t]<p:break\n   if d[t]>p:q+=t,;d[t]=p\nprint(d[~w+f*w+g]%I-1)", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nfrom collections import deque\n \nH, W, K = map(int,readline().split())\nx1, y1, x2, y2 = map(int,readline().split())\nx1 -= 1; y1 -= 1; x2 -= 1; y2 -= 1\nC = read().split()\n\ndist = [[-1]*W for i in range(H)]\ndist[x1][y1] = 0\nd = deque([[x1, y1]])\ndxy= [[1, 0], [0, 1], [-1, 0], [0, -1]]\nwhile d:\n  x, y = d.popleft()\n  if (x, y) == (x2, y2):\n    print(dist[x][y])\n    return\n  for dx, dy in dxy:\n    xx = x; yy = y\n    for i in range(K):\n      xx += dx; yy += dy\n      if 0<=xx<H and 0<=yy<W and C[xx][yy]!='@':\n        if 0 <= dist[xx][yy] <= dist[x][y]:\n          break\n        if dist[xx][yy] == -1:\n           d.append([xx, yy])\n        dist[xx][yy] = dist[x][y] + 1\n      else:\n        break\n\nprint(-1)", "from collections import deque\nh,w,k = map(int,input().split())\na,b,c,d = map(int,input().split())\na -= 1\nb -= 1\nc -= 1\nd -= 1\nmaze = [input() for _ in range(h)]\ndx = [1,-1,0,0]\ndy = [0,0,1,-1]\ndepth = [[float(\"inf\") for _ in range(w)] for _ in range(h)]\ndq = deque([(b,a)])\ndepth[a][b] = 0\nwhile dq:\n    x,y = dq.popleft()\n    if x == d and y == c:\n        break\n    for i in range(4):\n        nx,ny,K = x,y,k\n        while K:\n            K -= 1\n            nx += dx[i]\n            ny += dy[i]\n            if 0<=nx<=w-1 and 0<=ny<=h-1 and maze[ny][nx] != \"@\" and depth[ny][nx] > depth[y][x]:\n                if depth[ny][nx] == depth[y][x]+1:\n                    continue\n                depth[ny][nx] = depth[y][x] +1\n                dq.append((nx,ny))\n            else:\n                break\nprint(depth[c][d] if depth[c][d] != float(\"inf\") else -1)", "from collections import deque\nfrom heapq import heappop, heappush\n\nimport numpy as np\n\nfrom numba import njit\n\n\n@njit('UniTuple(i8[:],4)(i1[:],i8,i8,i8)')\ndef reachable(field, h2, w2, k):\n    # \u5404\u30de\u30b9\u304b\u3089\u4e0a\u4e0b\u5de6\u53f3\u306b\u3069\u3053\u307e\u3067\u884c\u3051\u308b\u304b\n    hw = h2 * w2\n    up = np.full(hw, -1, dtype=np.int64)\n    dw = np.full(hw, -1, dtype=np.int64)\n    lf = np.full(hw, -1, dtype=np.int64)\n    rg = np.full(hw, -1, dtype=np.int64)\n    lf_tmp = -1\n    for i in range(w2, hw - w2):\n        if field[i]:\n            if lf_tmp == -1:\n                lf_tmp = i\n            lf[i] = max(lf_tmp, i - k)\n        else:\n            lf_tmp = -1\n    rg_tmp = -1\n    for i in range(hw - w2, w2 - 1, -1):\n        if field[i]:\n            if rg_tmp == -1:\n                rg_tmp = i\n            rg[i] = min(rg_tmp, i + k)\n        else:\n            rg_tmp = -1\n    wk = w2 * k\n    for j in range(1, w2):\n        up_tmp = -1\n        for i in range(j, hw, w2):\n            if field[i]:\n                if up_tmp == -1:\n                    up_tmp = i\n                up[i] = max(up_tmp, i - wk)\n            else:\n                up_tmp = -1\n        dw_tmp = 0\n        for i in range(hw - w2 + j, w2 - 1, -w2):\n            if field[i]:\n                if dw_tmp == -1:\n                    dw_tmp = i\n                dw[i] = min(dw_tmp, i + wk)\n            else:\n                dw_tmp = -1\n    return up, dw, lf, rg\n\n\n@njit('i8(i8,i8,i8,i1[:],i8,i8,i8,i8)')\ndef solve(h2, w2, k, field, x1, y1, x2, y2):\n    s = x1 * w2 + y1\n    t = x2 * w2 + y2\n    up, dw, lf, rg = reachable(field, h2, w2, k)\n\n    INF = 10 ** 18\n    ans = [[INF, INF] for _ in field]\n    ans[s][0] = ans[s][1] = 0\n\n    q = [(0, s)]\n    while q:\n        cost, v = heappop(q)\n        if v == t:\n            return cost\n        nc = cost + 1\n\n        for u in range(up[v], v, w2):\n            if ans[u][0] <= nc:\n                break\n            ans[u][0] = nc\n            heappush(q, (nc, u))\n\n        for u in range(dw[v], v, -w2):\n            if ans[u][0] <= nc:\n                break\n            ans[u][0] = nc\n            heappush(q, (nc, u))\n\n        for u in range(lf[v], v, 1):\n            if ans[u][1] <= nc:\n                break\n            ans[u][1] = nc\n            heappush(q, (nc, u))\n\n        for u in range(rg[v], v, -1):\n            if ans[u][1] <= nc:\n                break\n            ans[u][1] = nc\n            heappush(q, (nc, u))\n\n    return -1\n\n\nh, w, k = list(map(int, input().split()))\nx1, y1, x2, y2 = list(map(int, input().split()))\nh2 = h + 2\nw2 = w + 2\n\nfield_tmp = [input() for _ in range(h)]\nfield = [0] * w2\nfor row in field_tmp:\n    field.append(0)\n    field.extend(list(map('@.'.index, row)))\n    field.append(0)\nfield.extend([0] * w2)\nfield = np.array(field, dtype=np.int8)\nprint((solve(h2, w2, k, field, x1, y1, x2, y2)))\n", "from collections import deque\nimport sys\n\n\ndef bfs(x1, y1, d):\n    q = deque()\n    q.append((d, x1, y1))\n\n    while q:\n        d, x1, y1 = q.popleft()\n\n        M[x1][y1] = d\n\n        if [x1, y1] == [xg, yg]:\n            print(d)\n            return\n\n        for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n            for k in range(1, K + 1):\n                x2 = x1 + dx * k\n                y2 = y1 + dy * k\n\n                if (0 <= x2 < H) and (0 <= y2 < W):\n                    if m[x2][y2] == '@':\n                        break\n                    elif M[x2][y2] == -1:\n                        M[x2][y2] = d + 1\n                        q.append((d + 1, x2, y2))\n                    elif M[x2][y2] < d + 1:\n                        break\n                else:\n                    break\n    print(-1)\n\n\nH, W, K = map(int, input().split())\nxs, ys, xg, yg = map(int, input().split())\nxs, ys, xg, yg = xs - 1, ys - 1, xg - 1, yg - 1\n\nm = []\nfor i in range(H):\n    m.append(list(map(str, sys.stdin.readline().strip())))\n\nM = [[-1] * W for i in range(H)]\n\nbfs(xs, ys, 0)"]
["from math import sin, cos, tan, atan, pi\n\n\ndef main():\n    w, h, a = map(int, input().split())\n    a = min(a, 180 - a) * pi / 180\n    if h > w:\n        h, w = w, h\n    if h * (1 + cos(a)) < w * sin(a):\n        res = h * h / sin(a)\n    else:\n        res = h * w - ((w - h * tan(a / 2)) ** 2 * tan(a) + (h - w * tan(a / 2)) ** 2 * tan(a)) / 4\n    print('{:.9f}'.format(res))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import radians, cos, sin, atan2\n\ndef rotate(point, alpha):\n    x = point[0]\n    y = point[1]\n    return (x * cos(alpha) - y * sin(alpha), x * sin(alpha) + y * cos(alpha))\n\ndef crs(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef m(end, start):\n    return (end[0] - start[0], end[1] - start[1])\n\ndef area(poly):\n    ret = 0\n    n = len(poly)\n\n    for i in range(n):\n        j = (i + 1) % n\n        ret += crs(poly[i], poly[j])\n\n    return abs(ret) / 2.0\n\ndef intersect(a, b, c, d):\n    r = crs(m(c, d), m(a, d)) * crs(m(c, d), m(b, d)) <= 0\n    r &= crs(m(b, a), m(c, a)) * crs(m(b, a), m(d, a)) <= 0\n    if not r:\n        return None\n\n    x1 = a[0]\n    y1 = a[1]\n\n    x2 = c[0]\n    y2 = c[1]\n\n    dx1 = b[0] - a[0]\n    dx2 = d[0] - c[0]\n\n    dy1 = b[1] - a[1]\n    dy2 = d[1] - c[1]\n\n    if dx2 * dy1 == dx1 * dy2:\n        return None\n\n    t = ((x1 - x2) * dy2 + (y2 - y1) * dx2) / (dx2 * dy1 - dx1 * dy2)\n    return (x1 + t * dx1, y1 + t * dy1)\n\n\nw, h, alpha = list(map(int, input().split()))\n\nif alpha == 0 or alpha == 180:\n    print(w * h)\nelse:\n    alpha = radians(alpha) \n    pnt = []\n\n    pnt.append((w / 2, h / 2))\n    pnt.append((-w / 2, h / 2))\n    pnt.append((-w / 2, -h / 2))\n    pnt.append((w / 2, -h / 2))\n\n\n    pnt2 = []\n    for p in pnt:\n        pnt2.append(rotate(p, alpha))\n\n    pnt2.append(pnt2[0])\n    pnt.append(pnt[0])\n\n    points_total = []\n\n    for st in range(4):\n        for en in range(4):\n            t = intersect(pnt[st], pnt[st + 1], pnt2[en], pnt2[en + 1])\n\n            if t != None:\n                points_total.append(t)\n\n    points_total = sorted(points_total, key=lambda x: atan2(x[1], x[0]))\n\n    print(area(points_total))\n", "from math import sin,cos,tan\nPI = 3.141592653589793238463\n[w,h,a] =[int(i) for i in input().split()]\nif h > w:\n    h,w = w,h\nif a > 90:\n    a = 180 - a\nif a==0:\n    print(w*h)\nelse:\n    b = (a*PI)/180\n    w = w/2.0\n    h = h/2.0\n    if tan(b/2) >= h/w:\n        print(4*h*h/sin(b))\n    else:\n        ans = 4*w*h\n        m = -1 / tan(b)\n        c = w*sin(b) + w*cos(b) / tan(b)\n        ans = ans - (h - m*w - c)*(w - (h - c)/m)\n        m = tan(b)\n        c = h*cos(b) + h*sin(b)*tan(b)\n        ans = ans - (h + m*w - c)*((h - c)/m + w)\n        print (ans)\n", "from math import sin,cos,tan,pi\n[w,h,a] =[int(i) for i in input().split()]\nif h > w:\n    h,w = w,h\nif a > 90:\n    a = 180 - a\nif a==0:\n    print(w*h)\nelse:\n    b = (a*pi)/180\n    w = w/2.0\n    h = h/2.0\n    if tan(b/2) >= h/w:\n        print(4*h*h/sin(b))\n    else:\n        ans = 4*w*h\n        m = -1 / tan(b)\n        c = w*sin(b) + w*cos(b) / tan(b)\n        ans = ans - (h - m*w - c)*(w - (h - c)/m)\n        m = tan(b)\n        c = h*cos(b) + h*sin(b)*tan(b)\n        ans = ans - (h + m*w - c)*((h - c)/m + w)\n        print (ans)\n", "from math import sin, cos, tan, atan, pi\n\n\ndef main():\n    w, h, a = map(int, input().split())\n    a = min(a, 180 - a) * pi / 180\n    if h > w:\n        h, w = w, h\n    if h * (1 + cos(a)) < w * sin(a):\n        res = h * h / sin(a)\n    else:\n        res = h * w - ((w - h * tan(a / 2)) ** 2 * tan(a) + (h - w * tan(a / 2)) ** 2 * tan(a)) / 4\n    print('{:.9f}'.format(res))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import *\n\nw,h,alpha = [int(x) for x in input().strip().split()]\n\nif alpha > 90 : alpha = 180 - alpha\nif w < h: w,h = h,w\n\nc = cos(alpha * pi / 180.0)\ns = sin(alpha * pi / 180.0)\nt = tan(alpha * pi / 360.0)\n\nprint(h * h / s) if t > h / w else print( (w * h - (w * w + h * h) / 2 * tan(alpha * pi / 360.0)) / (c))", "import math\nw,h,alpha=list(map(lambda x: int(x),input().split(\" \")));\n\nif alpha>90: alpha=180-alpha;\nif alpha==0 : print(w*h);\nelif alpha==90:\n  print(min(w,h)**2);\n\n\nelse:\n  limit=2*(math.degrees(math.atan(h/w)));\n  if limit>90: limit=180-limit;\n  c=math.cos(math.radians(alpha));\n  s=math.sin(math.radians(alpha));\n # print(limit);\n  if alpha>=limit:\n    print(min(w,h)**2/s);\n  else:\n    print(w*h -((c-1)*((4*w*h*s)-2*(w**2+h**2))/(4*s*c)));", "import math\n\nw, h, a = list(map(int, input().strip().split()))\n\nif h > w:\n    w, h = h, w\n\nif a > 90:\n    a = 90 - (a - 90)\n\na = math.radians(a)\n\nif a < 2 * math.atan2(h, w):\n    area = w * h\n\n    s = (w / 2) - (h / 2 * math.tan(a / 2))\n    bigger_area = 0.5 * s * s * math.tan(a)\n\n    s = (h / 2) - (w / 2 * math.tan(a / 2))\n    lower_area = 0.5 * s * s * math.tan(a)\n\n    print(area - 2 * bigger_area - 2 * lower_area)\nelse:\n    print(h * h / math.sin(a))\n\n", "import math\n\nw, h, a = list(map(int, input().strip().split()))\n\nif h >   w:\n    w, h = h, w\n\nif a > 90:\n    a = 90 - (a - 90)\n\na = math.radians(a)\n\nif a < 2 * math.atan2(h, w):\n    area = w * h\n\n    s = (w / 2) - (h / 2 * math.tan(a / 2))\n    bigger_area = 0.5 * s * s * math.tan(a)\n\n    s = (h / 2) - (w / 2 * math.tan(a / 2))\n    lower_area = 0.5 * s * s * math.tan(a)\n\n    print(area - 2 * bigger_area - 2 * lower_area)\nelse:\n    print(h * h / math.sin(a))\n\n", "import math\nfrom decimal import *\ngetcontext().prec = 40\n\nEPS = Decimal(0.000000000000000000001)\nPI = Decimal(3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328)\n\ndef labs(x):\n\tif x < 0:\n\t\treturn -x\n\treturn x\n\nclass Point:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\n\tdef Add(self, p):\n\t\tself.x += p.x\n\t\tself.y += p.y\n\t\n\tdef Sub(self, p):\n\t\tself.x -= p.x\n\t\tself.y -= p.y\n\n\tdef Scale(self, v):\n\t\tself.x *= v\n\t\tself.y *= v\n\n\tdef Rotate(self, angle):\n\t\tnewX = self.x * Decimal(math.cos(angle)) - self.y * Decimal(math.sin(angle))\n\t\tnewY = self.x * Decimal(math.sin(angle)) + self.y * Decimal(math.cos(angle))\n\t\tself.x = newX\n\t\tself.y = newY\n\t\n\tdef Equals(self, p):\n\t\tif Decimal(labs(p.x - self.x)) < EPS and Decimal(labs(p.y - self.y)) < EPS:\n\t\t\treturn True\n\t\treturn False\n\nclass Line:\n\tdef __init__(self, start, end):\n\t\tself.start = start\n\t\tself.end = end\n\t\n\tdef GetIntersection(self, l):\n\t\ta = Point(self.start.x, self.start.y)\n\t\tb = Point(self.end.x, self.end.y)\n\t\tc = Point(l.start.x, l.start.y)\n\t\td = Point(l.end.x, l.end.y)\n\t\tab = Point(self.end.x, self.end.y)\n\t\tcd = Point(l.end.x, l.end.y)\n\t\tab.Sub(a)\n\t\tcd.Sub(c)\n\t\tk = Decimal((cd.x * (a.y - c.y) + cd.y * (c.x - a.x)) / (ab.x * cd.y - ab.y * cd.x))\n\t\tab.Scale(k)\n\t\ta.Add(ab)\n\t\treturn a\n\nclass Polygon:\n\tdef __init__(self, vertices):\n\t\tself.vertices = vertices\n\n\tdef GetArea(self): \n\t\tarea = Decimal(0)\n\t\tfor i in range(0, len(self.vertices)):\n\t\t\tarea += self.vertices[i].x * self.vertices[(i + 1) % len(self.vertices)].y - self.vertices[(i + 1) % len(self.vertices)].x * self.vertices[i].y\n\t\treturn Decimal(labs(area)) / Decimal(2)\n\nx, y, alpha = input().split()\nx = Decimal(x)\ny = Decimal(y)\nif x < y:\n\ttmp = x\n\tx = y\n\ty = tmp\nalpha = Decimal(alpha)\nsingleArea = x * y\nif alpha > 90:\n\talpha = Decimal(180) - alpha\nif alpha == 0:\n\tprint(singleArea)\n\treturn\nalpha = alpha * PI / Decimal(180)\na = Point(x / Decimal(2), y / Decimal(2))\nb = Point(x / Decimal(2), -y / Decimal(2))\nc = Point(-x / Decimal(2), -y / Decimal(2))\nd = Point(-x / Decimal(2), y / Decimal(2))\ne = Point(a.x, a.y)\nf = Point(b.x, b.y)\ng = Point(c.x, c.y)\nh = Point(d.x, d.y)\ne.Rotate(alpha)\nf.Rotate(alpha)\ng.Rotate(alpha)\nh.Rotate(alpha)\nab = Line(a, b)\nbc = Line(b, c)\ncd = Line(c, d)\nda = Line(d, a)\nef = Line(e, f)\nfg = Line(f, g)\ngh = Line(g, h)\nhe = Line(h, e)\narea = 0\nif a.Equals(f):\n\tt1 = Polygon([he.GetIntersection(da), e, f])\n\tt2 = Polygon([fg.GetIntersection(bc), g, h])\n\tarea = singleArea - t1.GetArea() - t2.GetArea()\nelif f.y > a.y:\n\tp1 = Polygon([he.GetIntersection(da), e, f, fg.GetIntersection(da)])\n\tp2 = Polygon([fg.GetIntersection(bc), g, h, he.GetIntersection(bc)])\n\tarea = singleArea - p1.GetArea() - p2.GetArea()\nelse:\n\tt1 = Polygon([da.GetIntersection(he), e, ef.GetIntersection(da)])\n\tt2 = Polygon([ef.GetIntersection(ab), f, fg.GetIntersection(ab)])\n\tt3 = Polygon([fg.GetIntersection(bc), g, gh.GetIntersection(bc)])\n\tt4 = Polygon([gh.GetIntersection(cd), h, he.GetIntersection(cd)])\n\tarea = singleArea - t1.GetArea() - t2.GetArea() - t3.GetArea() - t4.GetArea()\nprint(area)\n", "from math import *\nw,h,alpha = [int(x) for x in input().strip().split()]\nif alpha > 90 : alpha = 180-alpha\nif w < h: w,h = h,w\nc = cos(alpha*pi/180.0)\ns = sin(alpha*pi/180.0)\nt = tan(alpha*pi/360.0)\n \nprint(h*h/s) if t > h/w else print( (w*h-(w*w+h*h)/2*tan(alpha*pi/360.0))/(c) )\n \t   \t \t  \t \t\t \t\t\t \t \t\t\t\t   \t", "from math import *\nfrom sys import stdin, stdout \n\nio = stdin.readline().split()\n\nw = float(io[0])\nh = float(io[1])\na = float(io[2])\n\nif (a > 90): a = 180 - a\n\nif (a == 0) :\n    print(w * h)\nelif (a == 90) :\n    print(min(w, h) ** 2)\nelse :\n    a = a * pi / 180.0\n    if (w < h) : w, h = h, w\n    corner_x = cos(a) * (w / 2.0) + sin(a) * (h / 2.0)\n    if (corner_x >= w / 2 ) :\n        x0 = w / 2.0 + (h / 2.0 - (h / 2.0) / cos(a)) * (cos(a) / sin(a))\n        y0 = h / 2.0 - (tan(a) * (- w / 2.0) + (h / 2.0) / cos(a))\n        x1 = w / 2.0 - (h / 2.0 - (w / 2.0) / sin(a)) * (-tan(a))\n        y1 = h / 2.0 - ((-cos(a) / sin(a)) * (w / 2.0) + (w / 2.0) / sin(a))\n\n        print(w * h - x1 * y1 - x0 * y0)\n    else :\n        y = tan(a) * (w / 2.0) - (h / 2.0) / cos(a) + h / 2.0\n        y0 = y - h\n        x0 = y * tan(pi / 2.0 - a)\n        print(w * h - (y0 * tan(pi / 2.0 - a) + x0) * h)\n    \n\n\n", "from math import cos, pi, sin, atan\nW, H, b = map(float, input().split())\na = (b/180)*pi\n\nif (W < H):\n    X = W\n    W = H\n    H = X\n\nif (a > 0.5*pi):\n    a = 0.5*pi - (a - 0.5*pi)\n\nopp = W*H\nif (a == 0):\n    eindopp = W*H\nelse:\n    if a > (atan(H/W)*2):\n        Schuin = H/sin(a)\n        eindopp = Schuin*H\n    else:\n        y = -2*cos(a)-cos(a)**2-1+sin(a)**2\n        hks = (W*sin(a)-H*cos(a)-H)/y\n        hgs = (H-hks-hks*cos(a))/sin(a)\n        \n        eindopp = opp - hks*sin(a)*hks*cos(a) - hgs*sin(a)*hgs*cos(a)\n\n\nprint(round(eindopp,9))"]
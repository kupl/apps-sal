["n, m = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na = [-1] * 100001\nfor i in range(n):\n\tif a[f[i]] != -1:\n\t\ta[f[i]] = -2\n\telse:\n\t\ta[f[i]] = i\nfor i in b:\n\tif a[i] == -1:\n\t\tprint('Impossible')\n\t\treturn\nfor i in b:\n\tif a[i] == -2:\n\t\tprint('Ambiguity')\n\t\treturn\nprint('Possible')\nfor i in b:\n\tprint(a[i] + 1, end=' ')", "#!/usr/bin/env python3\n\nfrom collections import defaultdict\n\ntry:\n    while True:\n        n, m = list(map(int, input().split()))\n        f = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        d = [[ ] for i in range(n + 1)]\n        for i, x in enumerate(f, 1):\n            d[x].append(i)\n        a = [None] * m\n        ambigious = False\n        for i in range(m):\n            x = d[b[i]]\n            if not x:\n                print(\"Impossible\")\n                break\n            if len(x) != 1:\n                ambigious = True\n            else:\n                a[i] = x[0]\n        else:\n            if ambigious:\n                print(\"Ambiguity\")\n            else:\n                print(\"Possible\")\n                print(' '.join(map(str, a)))\nexcept EOFError:\n    pass\n", "import collections\n\nn, m = map(int, input().split())\nfs = list(map(int, input().split()))\nbs = list(map(int, input().split()))\n\ndef solve(n, m, fs, bs):\n    if not is_possible(n, m, fs, bs):\n        print('Impossible')\n        return\n    ans = solve2(n, m, fs, bs)\n    if not ans:\n        print('Ambiguity')\n    else:\n        print('Possible')\n        print(*ans)\n        \ndef is_possible(n, m, fs, bs):\n    setf = set(fs)\n    setb = set(bs)\n    return setb <= setf\n\n\ndef solve2(n, m, fs, bs):\n    finv = collections.defaultdict(set)\n    for i, f in enumerate(fs):\n        finv[f].add(i)\n    As = []\n    for b in bs:\n        fb = finv[b]\n        if len(fb) > 1:\n            return False\n        for a in fb:\n            As.append(a + 1)\n    return As\n    \n\n\nsolve(n, m, fs, bs)", "def main():\n    n, m = [int(i) for i in input().split()]\n    f = [-1] + [int(i) for i in input().split()]\n    b = [-1] + [int(i) for i in input().split()]\n    \n    d = [-1] * (n + 1)\n    cnt = [0] * (n + 1)\n    for i in range(1, n + 1):\n        cnt[f[i]] += 1\n        d[f[i]] = i\n   \n    a = [-1] * (m + 1)\n    for i in range(1, m + 1):\n        a[i] = d[b[i]]\n        if d[b[i]] == -1:\n            print(\"Impossible\")\n            return\n    for i in range(1, m + 1):\n        if cnt[b[i]] > 1:\n            print(\"Ambiguity\")\n            return\n    print(\"Possible\")\n    print(' '.join(str(i) for i in a[1:]))\n    \n\nmain()", "__author__ = 'MoonBall'\n\nimport sys\n# sys.stdin = open('data/B.in', 'r')\nT = 1\n\ndef process():\n    N, M = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    fc = {}\n    for idx, fv in enumerate(f): fc[fv] = (1, idx) if not fc.get(fv) else (fc[fv][0] + 1, idx)\n\n    a = []\n    failed = False\n    multi = False\n    for bv in b:\n        if not fc.get(bv):\n            failed = True\n            continue\n        if fc[bv][0] > 1:\n            multi = True\n            continue\n        a.append(fc[bv][1] + 1)\n\n    if failed:\n        print('Impossible')\n    elif multi:\n        print('Ambiguity')\n    else:\n        print('Possible')\n        print(' '.join(map(str, a)))\n\n\n\n\n\n\n\nfor _ in range(T):\n    process()\n", "n, m = map(int, input().split())\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\ns1 = set(f)\ns2 = set(b)\nans = []\nif s2 <= s1:\n    d = {}\n    for i in range(len(f)):\n        if f[i] in d:\n            d[f[i]].append(i + 1)\n        else:\n            d[f[i]] = [i + 1]\n    for u in b:\n        if u in d and len(d[u]) > 1:\n            print('Ambiguity')\n            break\n        elif u in d:\n            ans.append(d[u][0])\n    else:\n        print('Possible')\n        print(' '.join(map(str, ans)))\nelse:\n    print('Impossible')", "#n = int(input())\nfrom collections import defaultdict\ngod = defaultdict(int)\nn, m = [int(i) for i in input().split(\" \")]\nfuck = [int(i) for i in input().split(\" \")]\nb = [int(i) for i in input().split(\" \")]\nfor i in fuck:\n    god[i] += 1\nans = []\nf = dict( zip(fuck, range(1, n+1)) )\ns = set( fuck )\nansw = \"Possible\"\nfor i in b:\n    if not i in s:\n        answ = \"Impossible\"\n        break\n    elif god[i] > 1:\n        answ = \"Ambiguity\"\n    else:\n        ans.append(f[i])\n\nprint(answ)\nif answ == \"Possible\":\n    for i in ans:\n        print(i, end=' ')\n", "n, m = map(int, input().split())\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf_back = dict()\nkeys = set()\nfor i in range(n):\n    if f[i] in keys:\n        f_back[f[i]] = -1\n    else:\n        f_back[f[i]] = i\n        keys.add(f[i])\nstate = 1\na = [0] * m\nfor i in range(m):\n    if b[i] in keys:\n        if state == 1:\n            if f_back[b[i]] == -1:\n                state = 2\n            else:\n                a[i] = f_back[b[i]] + 1\n    else:\n        state = 0\n        break\nif state == 1:\n    print('Possible')\n    print(' '.join(map(str, a)))\nelif state == 2:\n    print('Ambiguity')\nelse:\n    print('Impossible')", "n,m = map(int, input().split())\nf = []\nb = []\nx = []\ny = []\nf = list(map(int, input().split()))\nfor i in range(n):\n\tx.append(0)\n\ty.append(0)\nfor i in range(n):\n\tx[f[i]-1] = x[f[i]-1] + 1\n\ty[f[i]-1] = i + 1\nb = list(map(int, input().split()))\namb = 0\nimp = 0\nfor i in range(m):\n\tif x[b[i]-1] > 1:\n\t\tamb = 1\n\telif x[b[i]-1] == 0:\n\t\timp = 1\n\nif imp > 0:\n\tprint(\"Impossible\")\t\nelif amb > 0:\n\tprint(\"Ambiguity\")\nelif 1 == 1:\n\tprint(\"Possible\")\t\n\tfor i in range(m):\n\t\tprint( str(y[b[i]-1]) + \" \", end=\"\")\t\t", "n, m = [int(x) for x in input().split()]\nf = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nfor i in range(n):\n    f[i] = [f[i], i]\nfor i in range(m):\n    b[i] = [b[i], i]\nf.sort()\nb.sort()\nans = [0] * m\nj = 0\ni = 0\nflag = 0\nwhile i < m and j < n:\n    if b[i][0] < f[j][0]:\n        flag = 1\n        print('Impossible')\n        break\n    elif b[i][0] == f[j][0]:\n        ans[b[i][1]] = f[j][1] + 1\n        i += 1\n        if j < n - 1 and f[j + 1][0] == f[j][0]:\n            flag = 2\n    else:\n        j += 1\nif i < m and flag != 1 :\n    print('Impossible')\nelif flag == 2:\n    print('Ambiguity')\nelif flag == 0:\n    print('Possible')\n    print(*ans)", "n, m = map(int, input().split())\n\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nf_count = [0 for i in range(n + 1)]\nf_pos = [0 for i in range(n + 1)]\n\nfor i in range(n):\n    f_pos[f[i]] = i + 1\n    f_count[f[i]] += 1\nans = []\nAmbiguity = False\nImpossible = False\nfor i in range(m):\n    if f_count[b[i]] == 1:\n        ans.append(f_pos[b[i]])\n    elif f_count[b[i]] == 0:\n        Impossible = True\n        break\n    else:\n        Ambiguity = True\n\nif Impossible:\n    print('Impossible')\nelif Ambiguity:\n    print('Ambiguity')\nelse:\n    print('Possible')\n    print(*ans)", "\"\"\"\nCodeforces Round #332\n\nProblem 599 B. Spongebob and Joke\n\n@author yamaton\n@date 2015-11-20\n\"\"\"\n\n\ndef solve(fs, bs, n, m):\n    set_fs = set(fs)\n    set_bs = set(bs)\n    if not all(b in set_fs for b in bs):\n        return ('Impossible', )\n\n    # if len(bs) != len(set_bs):\n    #     return ('Ambiguity', )\n\n    ys = [f for f in fs if f in set_bs]\n    if len(ys) != len(set(ys)):\n        return ('Ambiguity',)\n\n    d = {f: i for (i, f) in enumerate(fs, 1) if f in set_bs}\n    return ('Possible', [d[b] for b in bs])\n\n\n# def p(*args, **kwargs):\n#     return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    [n, m] = list(map(int, input().strip().split()))\n    fs = [int(_c) for _c in input().strip().split()]\n    bs = [int(_c) for _c in input().strip().split()]\n    assert len(fs) == n\n    assert len(bs) == m\n\n    result = solve(fs, bs, n, m)\n\n    if len(result) == 1:\n        print(result[0])\n    else:\n        print(result[0])\n        print(*result[1])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nn, m = list(map(int, input().split()))\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nctf, ctb = Counter(f), Counter(b)\npossible = True\nambiguous = False\nfor k, v in list(ctb.items()):\n    if k not in ctf:\n        possible = False\n    if ctf[k] >= 2:\n        ambiguous = True\nidx = {}\nfor i, v in enumerate(f):\n    idx[v] = i + 1\nif not possible:\n    print('Impossible')\nelif ambiguous:\n    print('Ambiguity')\nelse:\n    print('Possible')\n    a = []\n    for v in b:\n        a.append(idx[v])\n    print(' '.join(map(str, a)))\n", "from collections import Counter\n\ndef solve(n, m, f, b):\n    d1 = Counter(f)\n    d2 = Counter(b)\n    flag1, flag2 = True, False\n    for k, v in d2.items():\n        if k not in d1:\n            flag1 = False\n            break\n    if not flag1:\n        print('Impossible')\n        return\n    for k, v in d2.items():\n        if d1[k] > 1:\n            flag2 = True\n            break\n    if flag2:\n        print('Ambiguity')\n        return\n    d = {k : pos for pos, k in enumerate(f, start = 1)}\n    print('Possible')\n    for value in b:\n        print(d[value], end=' ')\n\nn, m = map(int, input().split())\n\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nsolve(n, m, f, b)\n", "#!/usr/bin/env python3\n# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Sponge Class (Main Program)\n###############################################################################\n\n\nclass Sponge:\n    \"\"\" Sponge representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.numf = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.numb = list(map(int, uinput().split()))\n\n        self.fd = {}\n        self.fdn = {}\n        for (i, n) in enumerate(self.numf):\n            self.fd[n] = self.fd.setdefault(n, 0) + 1\n            self.fdn[n] = i + 1\n        self.bd = {}\n        for (i, n) in enumerate(self.numb):\n            self.bd[n] = self.bd.setdefault(n, 0) + 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        for n in self.numb:\n            if n not in self.fd:\n                return \"Impossible\"\n        for n in self.numb:\n            if self.fd[n] > 1:\n                return \"Ambiguity\"\n            result.append(self.fdn[n])\n\n        return \"Possible\\n\" + \" \".join(map(str, result))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Sponge class testing \"\"\"\n\n        # Constructor test\n        test = \"3 3\\n3 2 1\\n1 2 3\"\n        d = Sponge(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 3)\n        self.assertEqual(d.numf, [3, 2, 1])\n        self.assertEqual(d.numb, [1, 2, 3])\n\n        # Sample test\n        self.assertEqual(Sponge(test).calculate(), \"Possible\\n3 2 1\")\n\n        # Sample test\n        test = \"3 3\\n1 1 3\\n1 2\"\n        self.assertEqual(Sponge(test).calculate(), \"Impossible\")\n\n        # Sample test\n        test = \"3 3\\n1 1 1\\n1 1 1\"\n        self.assertEqual(Sponge(test).calculate(), \"Ambiguity\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Sponge(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Sponge(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Sponge().calculate())\n\n__starting_point()", "#!/usr/bin/env python3\n# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Sponge Class (Main Program)\n###############################################################################\n\n\nclass Sponge:\n    \"\"\" Sponge representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.numf = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.numb = list(map(int, uinput().split()))\n\n        self.fd = {}\n        self.fdn = {}\n        for (i, n) in enumerate(self.numf):\n            self.fd[n] = self.fd.setdefault(n, 0) + 1\n            self.fdn[n] = i + 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        for n in self.numb:\n            if n not in self.fd:\n                return \"Impossible\"\n            result.append(self.fdn[n])\n        for n in self.numb:\n            if self.fd[n] > 1:\n                return \"Ambiguity\"\n\n        return \"Possible\\n\" + \" \".join(map(str, result))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Sponge class testing \"\"\"\n\n        # Constructor test\n        test = \"3 3\\n3 2 1\\n1 2 3\"\n        d = Sponge(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 3)\n        self.assertEqual(d.numf, [3, 2, 1])\n        self.assertEqual(d.numb, [1, 2, 3])\n\n        # Sample test\n        self.assertEqual(Sponge(test).calculate(), \"Possible\\n3 2 1\")\n\n        # Sample test\n        test = \"3 3\\n1 1 3\\n1 2\"\n        self.assertEqual(Sponge(test).calculate(), \"Impossible\")\n\n        # Sample test\n        test = \"3 3\\n1 1 1\\n1 1 1\"\n        self.assertEqual(Sponge(test).calculate(), \"Ambiguity\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Sponge(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Sponge(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Sponge().calculate())\n\n__starting_point()", "input()\nf, b = [list(map(int, input().split())) for _ in range(2)]\nd = {}\nz = []\nfor i in range(len(f)):\n    if f[i] in d:\n        z.append(f[i])\n    d[f[i]] = i + 1\nans = 2\nfor it in b:\n    if it not in d:\n        ans = 0\nif ans != 0:\n    if len(d) < len(f):\n        for it in z:\n            if it in b:\n                ans = 1\n                break\nif ans == 2:\n    print('Possible')\n    print(' '.join(str(d[i]) for i in b))\nelif ans == 1:\n    print('Ambiguity')\nelse:\n    print('Impossible')\n", "\n\nans=[]\ndef func(f,b):\n    nonlocal ans\n    dic={}\n    k=0\n    for i in range(len(f)):\n        dic[f[i]]=-1\n    for i in range(len(f)):\n        if dic[f[i]]!=-1:\n            dic[f[i]]=-10\n        else:\n            dic[f[i]]=i+1\n    for i in b:\n        if i in dic:\n            if dic[i]==-10:\n                k=1\n            ans.append(dic[i])\n        else:\n            return 3\n    if k:\n        return 2\n    return 1\n\n\nq=list(map(int,input().split()))\nn,m=q[0],q[1]\nf=list(map(int,input().split()))\nb=list(map(int,input().split()))\np=func(f,b)\nif p==1:\n    print(\"Possible\")\n    for i in ans:\n        print(i,end=' ')\nelif p==2:\n    print(\"Ambiguity\")\nelse:\n    print(\"Impossible\")", "def __starting_point():\n\n    n , m = [ int(x) for x in input().split() ]\n    f = [ int(x) for x in input().split() ]\n    b = [ int(x) for x in input().split() ]\n\n    fdict = dict()\n    for i , fi in enumerate(f):\n        if fi in fdict:\n            fdict[ fi ].append( i )\n        else:\n            fdict[ fi ] = [ i ]\n\n    a = []\n    res = \"Possible\"\n    for i,bi in enumerate(b):\n        if bi in fdict:\n            a_options = fdict[bi]\n            a.append( a_options[0] )\n            if len( a_options ) > 1:\n                res = \"Ambiguity\"\n        else:\n            res = \"Impossible\"\n            break\n\n    print(res)\n    if res == \"Possible\":\n\n        if len(a) != m:\n            print( \"len(a) != m , len(a) =\" , len(a) )\n\n        print(\" \".join([str(x+1) for x in a]))\n    elif res == \"Ambiguity\":\n\n        if len(a) != m:\n            print( \"len(a) != m , len(a) =\" , len(a) )\n__starting_point()", "#n,m = map(int,input().split())\n#f = [int(x) for x in input().split()]\n#b = [int(x) for x in input().split()]\n#list = [0]*100001\n\n#for i in range(n):\n#    list[f[i]] = i+1\n\n#for item in b:\n#    if list[item] == 0:\n#        print('Impossible')\n#        return\n\n#for item in b:\n#    if f.count(item) != 1:\n#        print('Ambiguity')\n#        return\n\n#output=[list[i] for i in b]\n\n#print('Possible')\n#print(' '.join([str(x) for x in output]))\n\nn, m = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na = [-1] * 100001\nfor i in range(n):\n\tif a[f[i]] != -1:\n\t\ta[f[i]] = -2\n\telse:\n\t\ta[f[i]] = i\nfor i in b:\n\tif a[i] == -1:\n\t\tprint('Impossible')\n\t\treturn\nfor i in b:\n\tif a[i] == -2:\n\t\tprint('Ambiguity')\n\t\treturn\nprint('Possible')\nfor i in b:\n\tprint(a[i] + 1, end=' ')", "#n,m = map(int,input().split())\n#f = [int(x) for x in input().split()]\n#b = [int(x) for x in input().split()]\n#list = [0]*100001\n\n#for i in range(n):\n#    list[f[i]] = i+1\n\n#for item in b:\n#    if list[item] == 0:\n#        print('Impossible')\n#        return\n\n#for item in b:\n#    if f.count(item) != 1:\n#        print('Ambiguity')\n#        return\n\n#output=[list[i] for i in b]\n\n#print('Possible')\n#print(' '.join([str(x) for x in output]))\n\nn, m = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na = [-1] * 100001\nfor i in range(n):\n\tif a[f[i]] != -1:\n\t\ta[f[i]] = -2\n\telse:\n\t\ta[f[i]] = i\nfor i in b:\n\tif a[i] == -1:\n\t\tprint('Impossible')\n\t\treturn\nfor i in b:\n\tif a[i] == -2:\n\t\tprint('Ambiguity')\n\t\treturn\n#print('Possible')\n#for i in b:\n#\tprint(a[i] + 1, end=' ')\n\noutput=[a[i]+1 for i in b]\n\nprint('Possible')\nprint(' '.join([str(x) for x in output]))", "#n,m = map(int,input().split())\n#f = [int(x) for x in input().split()]\n#b = [int(x) for x in input().split()]\n#list = [0]*100001\n\n#for i in range(n):\n#    list[f[i]] = i+1\n\n#for item in b:\n#    if list[item] == 0:\n#        print('Impossible')\n#        return\n\n#for item in b:\n#    if f.count(item) != 1:\n#        print('Ambiguity')\n#        return\n\n#output=[list[i] for i in b]\n\n#print('Possible')\n#print(' '.join([str(x) for x in output]))\n\n\nn,m = map(int,input().split())\n#n, m = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na = [-1] * 100001\nfor i in range(n):\n\tif a[f[i]] != -1:\n\t\ta[f[i]] = -2\n\telse:\n\t\ta[f[i]] = i\nfor i in b:\n\tif a[i] == -1:\n\t\tprint('Impossible')\n\t\treturn\nfor i in b:\n\tif a[i] == -2:\n\t\tprint('Ambiguity')\n\t\treturn\n#print('Possible')\n#for i in b:\n#\tprint(a[i] + 1, end=' ')\n\noutput=[a[i]+1 for i in b]\n\nprint('Possible')\nprint(' '.join([str(x) for x in output]))", "n,m = map(int,input().split())\nf = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nlist = [0]*100001\n\nfor i in range(n):\n    if list[f[i]] != 0:\n        list[f[i]] = -1\n    else:\n        list[f[i]] = i+1\n\nfor item in b:\n    if list[item] == 0:\n        print('Impossible')\n        return\n\nfor item in b:\n    if list[item] == -1:\n        print('Ambiguity')\n        return\n\noutput=[list[i] for i in b]\n\nprint('Possible')\nprint(' '.join([str(x) for x in output]))", "# import sys\n# sys.stdin = open('cf599b.in')\n\nfrom collections import Counter\n\nn, m = map(int, input().split())\n\nff = list(map(int, input().split()))\ndf = {int(v) : i for i, v in enumerate(ff, 1)}\ncnt = Counter(ff)\n\nbb = list(map(int, input().split()))\n\ntry:\n\tans = ' '.join(str(df[b]) for b in bb)\n\tif any(cnt[b] > 1 for b in bb):\n\t\tprint('Ambiguity')\n\telse:\n\t\tprint('Possible')\n\t\tprint(ans)\nexcept KeyError:\n\tprint('Impossible')"]
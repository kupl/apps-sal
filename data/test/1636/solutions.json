["def __starting_point():\n\n    n = int( input() )\n\n    maxX = [-1]*100005\n    for _ in range(n):\n        px,py = [int(x) for x in input().split()]\n        maxX[py] = max( maxX[py] , px )\n\n    #print( maxX[:2] )\n\n    w = [int(x) for x in input().split()]\n\n    p = [-1]*100005\n    p[0] = 0\n    wdict = dict()\n    wdict[0] = (0,0)\n    res = []\n    for wi in w:\n        if wi in wdict:\n            px , py = wdict.pop(wi)\n            res.append( (px,py) )\n            if maxX[py] > px:\n                wdict[py-(px+1)] = (px+1,py)\n                p[py] += 1\n            if maxX[py+1] != -1 and p[py+1] == -1:\n                wdict[py+1] = (0,py+1)\n                p[py+1] += 1\n        else:\n            break\n\n    if len(res) == n:\n        print(\"YES\")\n        for ares in res:\n            print(ares[0],ares[1])\n    else:\n        print(\"NO\")\n__starting_point()", "from collections import defaultdict\n\n\ndef solve():\n    N = int(input())\n\n    maxx = 0\n    maxy = 0\n    WS = defaultdict(list)\n\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        WS[y - x].append((x, y))\n        maxx = max(maxx, x)\n        maxy = max(maxy, y)\n\n    for w in WS:\n        WS[w].sort(reverse=True)\n\n    W = list(map(int, input().split()))\n\n    ans = [None] * N\n\n    mx = [0] * (maxy + 1)\n    my = [0] * (maxx + 1)\n\n    for i in range(N):\n        w = W[i]\n        if WS[w]:\n            ans[i] = ax, ay = WS[w].pop()\n            if mx[ay] == ax and my[ax] == ay:\n                mx[ay] = ax + 1\n                my[ax] = ay + 1\n\n            else:\n                print('NO')\n                return\n        else:\n            print('NO')\n            return\n\n    print('YES')\n    for a in ans:\n        print(a[0], a[1])\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import deque\ndp={}\nfor i in range(int(input())):\n\tx,y = list(map(int, input().split()))\n\tif y-x in dp:\n\t\tdp[y-x].append((x,y))\n\telse:\n\t\tdp[y-x]=[(x,y)]\nfor i in dp:\n\tdp[i].sort()\n\tdp[i]=deque(dp[i])\nw=list(map(int, input().split()))\nans=[0]*len(w)\nflag=1\nfor i in range(len(w)):\n\tif not w[i] in dp or not len(dp[w[i]]):\n\t\tflag=0\n\t\tbreak\n\tans[i]=dp[w[i]].popleft()\nif not flag:\n\tprint(\"NO\")\nelse:\n\tfor i in range(1,len(ans)):\n\t\tif ans[i][0]<=ans[i-1][0] and ans[i][1]<=ans[i-1][1]:\n\t\t\tflag=0\n\tif not flag:\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\tfor i in ans:\n\t\t\tprint(i[0], i[1])\n", "n = int(input())\nMAX = 100000\ncoord = [list() for i in range(2 * MAX + 1)]\nfor i in range(n):\n    x, y = map(int, input().split())\n    coord[y - x - MAX].append((x, y))\nw = list(map(int, input().split()))\nfor i in range(2 * MAX + 1):\n    coord[i].sort()\nans = [(0, 0) for i in range(n)]\npossible = True\nlast_x = [-1] * (MAX + 1)\nlast_y = [-1] * (MAX + 1)\nfor i in range(n):\n    if len(coord[w[i] - MAX]) > 0:\n        x = coord[w[i] - MAX][0][0]\n        y = coord[w[i] - MAX][0][1]\n        if last_x[y] == x - 1 and last_y[x] == y - 1:\n            last_x[y] += 1\n            last_y[x] += 1\n            ans[i] = x, y\n            coord[w[i] - MAX].pop(0)\n        else:\n            possible = False\n            break\n    else:\n        possible = False\n        break    \nif possible:\n    print(\"YES\")\n    print(\"\\n\".join([\" \".join(map(str, coords)) for coords in ans]))\nelse:\n    print(\"NO\")", "import collections\nimport heapq\n\nclass SegmentTree(object):\n    def __init__(self, size):\n        self.capacity = 1 << (len(bin(size - 1)) - 2)\n        self.tree = [-1] * self.capacity * 2\n        self.tree[0] = size\n        self.left = set()\n        p = self.capacity\n        while p:\n            self.left.add(p)\n            p >>= 1\n        \n\n    def update(self, x, y):\n        pos = self.capacity + x\n        while pos:\n            if y > self.tree[pos]:\n                self.tree[pos] = y\n            pos >>= 1\n\n\n    def getmax(self, x):\n        pos = self.capacity + x\n        y = self.tree[pos]\n        while pos:\n            if y < self.tree[pos]:\n                y = self.tree[pos]\n            if pos & 1:\n                pos = (pos >> 1) + 1\n                if pos in self.left:\n                    break\n            else:\n                pos >>= 1\n        return y\n    \n\ndef read_data():\n    n = int(input())\n    sxy = collections.defaultdict(list)\n    for i in range(n):\n        x, y = map(int, input().split())\n        heapq.heappush(sxy[y - x], x)\n    ws = list(map(int, input().split()))\n    return n, sxy, ws\n\ndef solve(n, sxy, ws):\n    path = []\n    for w in ws:\n        sxyw = sxy[w]\n        if sxyw:\n            x = heapq.heappop(sxy[w])\n            y = w + x\n            path.append((x, y))\n        else:\n            return False\n    if is_valid(path):\n        return path\n    else:\n        return False\n\ndef is_valid(path):\n    xys = compress(path)\n    segtree = SegmentTree(len(xys))\n    for x, y in xys:\n        maxy = segtree.getmax(x)\n        if maxy >= y:\n            return False\n        segtree.update(x, y)\n    return True\n        \ndef compress(path):\n    xset = set()\n    for x, y in path:\n        xset.add(x)\n    xuniq = list(xset)\n    xuniq.sort()\n    dic = {x: i for i, x in enumerate(xuniq)}\n    xys = [(dic[x], y) for x, y in path]\n    return xys\n\n\nn, sxy, ws = read_data()\nresult = solve(n, sxy, ws)\nif result:\n    print('YES')\n    for x, y in result:\n        print(x, y)\nelse:\n    print('NO')", "n = int(input())\n\nopens = {}\nsums = [n - i for i in range(n)] + [0] * (n + 1)\nfor i in range(n):\n    t = tuple(map(int, input().split()))\n    opens[t] = 1\n    \nnums = list(map(int, input().split()))\nres = 1\nres_nums = []\nfor elem in nums:\n    f = 1\n    x = 0\n    try:\n        x = sums[elem + n]\n    except:\n        f = 0\n    y = x + elem\n    \n    try:\n        u = opens[x, y]\n    except KeyError:\n        f = 0\n    try:\n        if opens[x, y - 1] == 1:\n            f = 0\n    except KeyError:\n        pass\n    try:\n        if opens[x - 1, y] == 1:\n            f = 0\n    except KeyError:\n        pass    \n    if f == 0: \n        res = 0\n        break\n    sums[elem + n] += 1\n    opens[x, y] = 0\n    res_nums.append((x, y))\n    \n    \nprint('YES' if res else 'NO')\nif res:\n    for elem in res_nums:\n        print(str(elem[0]) + ' ' + str(elem[1]))", "from bisect import bisect_left\n\nn = int(input())\nmas = []\nfor i in range(n):\n\tmas.append(0)\t\nfor i in range(n):\n\tx,y = list(map ( int, input().split()))\n\tmas[x] = max(mas[x], y)\nw = list(map(int, input().split()))\nfor i in range(n):\n\tw[i] = -w[i]\ns = []\nr = []\nres1 = []\nres2 = []\nres3 = []\n\nfor i in range(n):\n\ts.append(i)\t\n\tr.append(i)\n\tres2.append(-1)\n\ts[i] -= mas[i] + 1\t\n\nerror = 0\nfor i in range(n):\n\tif error == 1:\n\t\tbreak\n\tt = bisect_left(r, w[i])\n\tif ( t >= n or r[t] != w[i] ):\n\t\terror = 1\n\t\tbreak\n\telse:\n\t\tr[t] = r[t] - 1\n\t\tif ( ( r[t] < s[t] ) or ( t > 0 and r[t] == r[t-1] ) ):\n\t\t\terror = 1    \n\t\t\tbreak\n\tres1.append(t)\n\tres2[t] = res2[t] + 1\n\tres3.append( res2[t])\t\n\nif error == 1:\n\tprint(\"NO\")\t\t\nelse:\n\tprint(\"YES\")\n\tfor i in range(n):\n\t\tprint( str(res1[i]) + \" \" + str(res3[i]))\n", "def main():\n    n = int(input())\n    diag = [0] * 200005\n    use = [0] * 200005\n    for i in range(n):\n        x, y = [int(i) for i in input().split(' ')]\n        c = y - x\n        if c > 0:\n            diag[c] = max(x+1, diag[c])\n        else:\n            diag[c] = max(y+1, diag[c])\n\n    table = set()\n    for i in range(100005):\n        table.add((-1, i))\n        table.add((i, -1))\n\n    result = []\n\n    for v in [int(i) for i in input().split(' ')]:\n        # print(v)\n        if v > 0:\n            x = use[v]\n            y = x + v\n        else:\n            y = use[v]\n            x = y - v\n\n        # print(x, y, use[v], diag[v], use[v] > diag[v], (x-1, y) not in table, (x, y-1) not in table)\n\n        use[v] += 1\n\n        if use[v] > diag[v]:\n            print ('NO')\n            return\n\n        if (x-1, y) not in table or (x, y-1) not in table:\n            print ('NO')\n            return\n        table.add((x, y))\n        result.append((x, y))\n\n    print('YES')\n    for v in result:\n        print(v[0], v[1])\n\nmain()", "from sys import stdin\n_data = iter(stdin.read().split('\\n'))\ninput = lambda: next(_data)\n\nn = int(input())\nref, front = {}, {}\nans = []\nmax_x, max_y = 0, 0\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    max_x = max(max_x, x)\n    max_y = max(max_y, y)    \n    ref[(x, y)] = 2\n    if x == 0:\n        ref[(x, y)] -= 1\n    if y == 0:\n        ref[(x, y)] -= 1\n    if (x, y) == (0, 0):\n        del ref[(x, y)]\n        front[y - x] = x, y\nws = list(map(int, input().split()))\nfor w in ws:\n    if w not in front:\n        ans = []\n        break\n    x, y = front.pop(w)\n    ans.append((x, y))    \n    for dx, dy in ((1, 0), (0, 1)):\n        nx, ny = x + dx, y + dy\n        if (nx, ny) not in ref:\n            continue\n        ref[(nx, ny)] -= 1\n        if ref[(nx, ny)] == 0:\n            del ref[(nx, ny)]\n            front[ny - nx] = (nx, ny)\nif ans:\n    print('YES')\n    print('\\n'.join('{} {}'.format(x, y) for x, y in ans))\nelse:\n    print('NO')\n", "# import sys\n# sys.stdin = open('cf596c.in')\n\nfrom collections import namedtuple, defaultdict, Counter\n\nPoint = namedtuple(\"Point\", \"x y\")\n\nn = int(input())\npts = [Point(*list(map(int, input().split()))) for _ in range(n)]\n\nhave = Counter()\nfor pt in pts:\n\thave[pt.y - pt.x] += 1\n\nws = list(map(int, input().split()))\nbuckets = defaultdict(list)\n\nfor i, w in enumerate(ws):\n\tif have[w] == 0 or (\n\t\t(w == 0 and (len(buckets[1]) != len(buckets[0]) or (len(buckets[-1]) != len(buckets[0])))) or\n\t\t(w > 0 and ((len(buckets[w + 1]) != len(buckets[w])) or (len(buckets[w - 1]) != len(buckets[w]) + 1))) or\n\t\t(w < 0 and ((len(buckets[w - 1]) != len(buckets[w])) or (len(buckets[w + 1]) != len(buckets[w]) + 1)))\n\t\t):\n\t\tprint('NO')\n\t\treturn\n\tbuckets[w].append(i)\n\thave[w] -= 1\n\nans = []\nfor w, bucket in list(buckets.items()):\n\tfor x, i in enumerate(bucket, max(0, -w)):\n\t\tans.append((Point(x, w + x), i))\n\nans.sort(key=lambda item: item[1])\nprint('YES')\nprint('\\n'.join('%d %d' % pt for pt, i in ans))\n", "__author__ = 'mac'\n\nfrom collections import Counter\n\ndef sortByDiag(elem):\n        return elem[0]*elem[0]+elem[1]*elem[1]\n\ncount = int(input())\npoints = {}\ncompList = []\nfor i in range(count):\n    x,y = [int(x) for x in input().strip().split(' ')]\n    w = y-x\n    compList.append(w)\n    if not w in points:\n        points[w] = []\n    points[w].append([x,y])\n\nwArr = []\nfor x in input().strip().split(' '):\n    if (len(wArr) > 1 and int(x) == wArr[-1]) or (abs(int(x))>len(wArr)):\n        print('NO')\n        return\n    wArr.append(int(x))\n\n\n\nc1 = Counter(wArr)\nc2 = Counter(compList)\n\ndiff = c1-c2\nif len(list(diff.elements())) != 0:\n     print('NO')\n     return\n\nprint('YES')\n\nfor e in points:\n    points[e] = sorted(points[e], key = sortByDiag)\n\nfor i in wArr:\n    temp = points[i].pop(0)\n    print(temp[0],temp[1])", "from collections import deque\n\n\ndef ordering(s, ws):\n    pbs = {}\n    for p in sorted(s):\n        pbs.setdefault(p[1]-p[0], deque()).append(p)\n\n    o = []\n    os = set()\n    for w in ws:\n        try:\n            p = pbs[w].popleft()\n        except (IndexError, KeyError):\n            return None\n\n        if ((p[0] > 0 and (p[0]-1, p[1]) not in os)\n            or (p[1] > 0 and (p[0], p[1]-1) not in os)):\n            return None\n\n        o.append(p)\n        os.add(p)\n\n\n    return o\n\n\ndef pair(x, y):\n    return x, y\n\n\ndef __starting_point():\n    n = int(input())\n    s = {pair(*list(map(int, input().split()))) for _ in range(n)}\n    ws = tuple(map(int, input().split()))\n    o = ordering(s, ws)\n    if o:\n        print('YES')\n        for p in o:\n            print('{} {}'.format(*p))\n    else:\n        print('NO')\n\n__starting_point()", "n = int(input())\nR = lambda : list(map(int, input().split()))\n\np = []\nw = {}\nr = {}\npr = {}\n\nfrom collections import deque\n\nfor _ in range(n):\n    x,y = R()\n    p.append((x,y))\n\np = sorted(p)\n\nfor i,wi in enumerate(list(R()),1):\n    if wi not in w:\n        w[wi] = deque()\n    w[wi].append(i)\n\ndef solve(p,w,r):\n    for i in range(len(p)):\n        d = p[i][1]-p[i][0]\n        if d in w:\n            q = w[d]\n            if len(q) > 0:\n                ind = q.popleft()\n                r[ind] = p[i]\n                pr[p[i]] = ind\n                if not check_neighbours(p[i],ind,pr):\n                    return 0\n            else:\n                return 0\n        else:\n            return 0\n\n    return 1\n\ndef check_neighbours(p,ind,pr):\n    n1 = (p[0]-1,p[1])\n    n2 = (p[0],p[1]-1)\n    n3 = (p[0]-1,p[1]-1)\n    return (check_neighbour(n1,ind,pr) and check_neighbour(n2,ind,pr) and check_neighbour(n3,ind,pr))\n\ndef check_neighbour(nb,ind,pr):\n    if nb in pr:\n        if pr[nb] > ind:\n            return 0    \n    return 1\n\nif solve(p,w,r) == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for k,v in sorted(r.items()):\n        print(v[0], v[1])\n", "from collections import deque\n\ndp={}\n\nfor i in range(int(input())):\n\n\tx,y = list(map(int, input().split()))\n\n\tif y-x in dp:\n\n\t\tdp[y-x].append((x,y))\n\n\telse:\n\n\t\tdp[y-x]=[(x,y)]\n\nfor i in dp:\n\n\tdp[i].sort()\n\n\tdp[i]=deque(dp[i])\n\nw=list(map(int, input().split()))\n\nans=[0]*len(w)\n\nflag=1\n\nfor i in range(len(w)):\n\n\tif not w[i] in dp or not len(dp[w[i]]):\n\n\t\tflag=0\n\n\t\tbreak\n\n\tans[i]=dp[w[i]].popleft()\n\nif not flag:\n\n\tprint(\"NO\")\n\nelse:\n\n\tfor i in range(1,len(ans)):\n\n\t\tif ans[i][0]<=ans[i-1][0] and ans[i][1]<=ans[i-1][1]:\n\n\t\t\tflag=0\n\n\tif not flag:\n\n\t\tprint(\"NO\")\n\n\telse:\n\n\t\tprint(\"YES\")\n\n\t\tfor i in ans:\n\n\t\t\tprint(i[0], i[1])\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "from operator import itemgetter\nfrom collections import defaultdict\nn = int(input())\ncoor = []\ncoor_list = defaultdict(list)\nfor _ in range(n):\n    x, y = list(map(int,input().split()))\n    coor.append((x,y))\n    coor_list[y-x].append((x,y))\ncoor.sort(key=itemgetter(0,1))\norder = {cor:i for i, cor in enumerate(coor)}\nfor x,y in coor_list.items():\n    coor_list[x] = sorted(y, key=itemgetter(0,1),reverse=True)\n\n\nnums = list(map(int, input().split()))\nresult = []\nfor i in nums:\n    if i not in coor_list:\n        print(\"NO\")\n        return\n    else:\n        result.append(coor_list[i].pop())\nfor i in range(1,n):\n    if result[i][0] <= result[i-1][0] and result[i][1] <= result[i-1][1]:\n        print(\"NO\")\n        return\nprint(\"YES\")\nfor i in result:\n    print(*i)", "import collections\n\nlis = []\nn = int(input())\ndic = collections.defaultdict(list)\nfor i in range(n):\n    lis.append(tuple(map(int,input().split())))\n\nlis.sort(reverse=True)\n\nfor i in range(n):\n    dic[lis[i][1]-lis[i][0]].append(lis[i])\nlis1 = list(map(int,input().split()))\nst = \"\"\nmx1= (-1,-1)\nmx2 = (-1,-1)\nfor i in lis1:\n    if dic[i]:\n        a = dic[i].pop()\n        if (a>= mx1) or a >=mx2:\n            \n            if mx1[0] < a[0]:\n                mx1 = a\n            if mx2[1] < a[1]:\n                mx2 = a\n            \n            st+=str(a[0]) + \" \" + str(a[1])+\"\\n\"\n        else:\n            print(\"NO\")\n            return\n    else:\n        print(\"NO\")\n        return\nprint(\"YES\")\nprint(st,end=\"\")\n    \n", "from collections import defaultdict\nfrom operator import itemgetter\n\nn = int(input())\n\npoints = []\npoint_weights = defaultdict(list)\nfor _ in range(n):\n    x, y = tuple(map(int,input().split()))\n    points.append((x, y))\n    point_weights[y - x].append((x, y))\n\nweights = list(map(int, input().split()))\n\npoints.sort(key=itemgetter(0, 1))\n\nfor w, p in list(point_weights.items()):\n    point_weights[w] = sorted(p, key=itemgetter(0, 1), reverse=True)\n\nans = \"YES\"\nans_arr = []\nfor weight in weights:\n    if weight not in point_weights:\n        ans = \"NO\"\n        break\n    else:\n        if len(point_weights[weight]) == 0:\n            ans = \"NO\"\n            break\n        else:\n            ans_arr.append(point_weights[weight].pop())\n\nfor i in range(1, len(ans_arr)):\n    if ans_arr[i][0] <= ans_arr[i - 1][0] and ans_arr[i][1] <= ans_arr[i - 1][1]:\n        ans = \"NO\"\n        break\n\nprint(ans)\nif ans == \"YES\":\n    for point in ans_arr:\n        print(*point)\n", "from itertools import combinations,permutations\nfrom collections import defaultdict\n\ndef zeror():\n    return 0\n\ndef solution(n,c,cw,w):\n\n    c.sort(key=lambda tup:tup[0])\n    #print(c)\n\n    for k,v in cw.items():\n        cw[k]=sorted(v,key=lambda tup:tup[0])[::-1]\n\n    #print(cw)\n\n    ans=[]\n\n    for elem in w:\n        if elem not in cw:\n            print(\"NO\")\n            return\n        else:\n            ans.append(cw[elem].pop())\n\n    #print(ans)\n    temp=ans[0]\n    for elem in ans[1:]:\n        if temp[0]>=elem[0] and temp[1]>=elem[1]:\n            print(\"NO\")\n            return\n        temp=elem\n\n    print(\"YES\")\n    for elem in ans:\n        print(elem[0],elem[1])\n\n\n\n\ndef main():\n    n=int(input())\n    coordinates = []\n    coor_weights = defaultdict(list)\n    for _ in range(n):\n        coordinates.append(tuple(map(int,input().strip().split())))\n        coor_weights[coordinates[-1][1]-coordinates[-1][0]].append((coordinates[-1][0],coordinates[-1][1]))\n    weigths=list(map(int,input().strip().split()))\n\n    solution(n,coordinates,coor_weights,weigths)\n\n\n\ndef __starting_point():\n    main()\n\n\n\"\"\"\n\n5\n2 0\n0 0\n1 0\n1 1\n0 1\n0 -1 -2 1 \n\n\n\"\"\"\n__starting_point()", "n = int(input().rstrip())\nl = set()\nfor i in range(n):\n    l.add(tuple(map(int, input().rstrip().split())))\n\nw = list(map(int, input().rstrip().split()))\n\nd = {0: (0, 0)}\ns = \"\"\nvisited = set()\nvisited.add((0, 0))\nfor k in w:\n    if d.get(k, None) is None:\n        print(\"NO\")\n        return\n\n    p = d[k]\n    del d[k]\n    s += \"{} {}\\n\".format(*p)\n    if p[1] == 0 and (p[0] + 1, p[1]) in l:\n        visited.add((p[0] + 1, p[1]))\n        d[-p[0] - 1] = (p[0] + 1, 0)\n    else:\n        if (p[0] + 1, p[1] - 1) in visited and (p[0]+1, p[1]) in l:\n            visited.add((p[0] + 1, p[1]))\n            d[p[1] - p[0] - 1] = (p[0] + 1, p[1])\n    if p[0] == 0 and (0, p[1] + 1) in l:\n        d[p[1] + 1] = (0, p[1] + 1)\n        visited.add((0, p[1] + 1))\n    else:\n        if (p[0] - 1, p[1] + 1) in visited and (p[0], p[1] + 1) in l:\n            visited.add((p[0], p[1] + 1))\n            d[p[1]-p[0] + 1] = (p[0], p[1] + 1)\n\nprint(\"YES\")\nprint(s,end=\"\")\n\n     \t \t\t \t\t   \t   \t  \t\t \t  \t \t", "def binsearch(lofpoints,l,r,w,arr):\n    if(l>r):\n        return \"None\"\n    mid=(l+r)//2\n    if(lofpoints[mid][0]==w and arr[mid]==1):\n        if(mid==0):\n            arr[mid]=0\n            return mid\n        elif(lofpoints[mid-1][0]!=w or arr[mid-1]==0):\n            arr[mid]=0\n            return mid\n        else:\n            return binsearch(lofpoints,l,mid-1,w,arr)\n    if(lofpoints[mid][0]==w and arr[mid]==0):\n        return binsearch(lofpoints,mid+1,r,w,arr)\n    if(lofpoints[mid][0]<w):\n        return binsearch(lofpoints,mid+1,r,w,arr)\n    if(lofpoints[mid][0]>w):\n        return binsearch(lofpoints,l,mid-1,w,arr)\n\n\nn=int(input())\nlofpoints=[]\nfor i in range(n):\n    l=input().split()\n    x=int(l[0])\n    y=int(l[1])\n    lofpoints.append((y-x,x,y))\nlofpoints.sort()\nw=input().split()\nwi=[int(i) for i in w]\narr=[1 for i in range(n)]\nlsol=[]\ndone=1\n#print(lofpoints)\nfor i in range(n):\n    x=binsearch(lofpoints,0,n-1,wi[i],arr)\n    #print(x)\n    if(x==\"None\"):\n        done=0\n        break\n    elif(lsol==[]):\n        lsol.append((lofpoints[x][1],lofpoints[x][2]))\n\n    elif(lofpoints[x][1]<lsol[-1][0] and lofpoints[x][2]<lsol[-1][1]):\n        done=0\n        break\n    else:\n        lsol.append((lofpoints[x][1],lofpoints[x][2]))\n#print(lsol)\nif(done==1):\n    hashi=dict()\n    for i in range(n):\n        hashi[(lsol[i][0],lsol[i][1])]=i\n    for i in hashi:\n        x=i[0]\n        y=i[1]\n        t=hashi[i]\n        if((x,y+1) in hashi):\n            if(hashi[(x,y+1)]<t):\n                done=0\n                break\n        if((x+1,y) in hashi):\n            if(hashi[(x+1,y)]<t):\n                done=0\n                break\n\n    if(done==0):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in lsol:\n            print(i[0],i[1])\nelse:\n    print(\"NO\")\n", "n = int(input())\np = sorted([tuple(map(int, input().split())) for _ in range(n)])\narr = list(map(int, input().split()))\nw, r, pr = {}, {}, {}\n\nfor i, wi in enumerate(arr, 1):\n    if wi not in w:\n        w[wi] = []\n    w[wi].append(i)\n \ndef is_nbr(nb, i):\n    return 0 if pr.get(nb, 0) > i else 1\n\ndef check_nbrs(p, i):\n    n1 = (p[0] - 1, p[1])\n    n2 = (p[0], p[1] - 1)\n    n3 = (p[0] - 1, p[1] - 1)\n    return is_nbr(n1, i) and is_nbr(n2, i) and is_nbr(n3, i)\n\ndef solve():\n    for i in range(len(p)):\n        d = p[i][1] - p[i][0]\n        if d not in w:\n            return 0\n        q = w[d]\n        if not q:\n            return 0\n        ind = q.pop(0)\n        r[ind] = p[i]\n        pr[p[i]] = ind\n        if not check_nbrs(p[i], ind):\n            return 0\n    return 1\n \nif solve() == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for k, v in sorted(r.items()):\n        print(v[0], v[1])\n"]
["#!/usr/local/bin/python3\n\nfrom collections import defaultdict\nimport heapq\n\nnum_nodes, num_edges = list(map(int, input().split()))\n\nins = defaultdict(set)\nout = defaultdict(int)\n\nfor _ in range(num_edges):\n    node_out, node_in = list(map(int, input().split()))\n    ins[node_in].add(node_out)\n    out[node_out] += 1\n\nzeros = [-node for node in range(num_nodes, 0, -1) if out[node] == 0]\n\nfinal_mappings = {}\ncurrent_index = num_nodes\n\nwhile current_index > 0:\n\n    node = -heapq.heappop(zeros)\n    final_mappings[node] = current_index\n    current_index -= 1\n\n    for node_out in ins[node]:\n        out[node_out] -= 1\n        if out[node_out] == 0:\n            heapq.heappush(zeros, -node_out)\n    \nprint(' '.join(str(final_mappings[node]) for node in range(1, num_nodes + 1)))\n", "from heapq import heappush, heappop\nq = lambda:map(int, input().split())\nn, m = q()\na = d = [0] * n\ne = [[] for _ in range(n)]\nh = []\nwhile(m):\n    l, r = q()\n    d[l - 1] += 1\n    e[r - 1] += [l - 1]\n    m -= 1\nfor i in range(n):\n    if(d[i] == 0):\n        heappush(h, -i)\nj = n\nwhile(h):\n    t = -heappop(h)\n    a[t] = j\n    j -= 1\n    for x in e[t]:\n        d[x] -= 1\n        if(d[x] == 0):\n            heappush(h, -x)\nprint(''.join(str(x) + ' ' for x in a))", "n,m=map(int,input().split())\nd=[0]*n\ne=[[] for i in range(n)]\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tu-=1\n\tv-=1\n\td[u]+=1\n\te[v].append(u)\nfrom heapq import heappush, heappop\npq=[]\nfor i in range(n):\n\tif d[i]==0:\n\t\theappush(pq,-i)\nind=n\nans=[0]*n\nwhile(pq):\n\tu=-heappop(pq)\n\tans[u]=ind\n\tind-=1\n\tfor v in e[u]:\n\t\td[v]-=1\n\t\tif d[v]==0:\n\t\t\theappush(pq,-v)\nprint(' '.join(str(x) for x in ans))", "from heapq import *\n\nn, m = map(int, input().split())\ng = [[] for _ in range(n + 1)]\nout = [0] * (n + 1)\nfor _ in range(m):\n\tu, v = map(int, input().split())\n\tg[v].append(u)\n\tout[u] += 1\n\nq = [-u for u in range(1, n + 1) if not out[u]]\nheapify(q)\nr = [0] * (n + 1)\nc = n\nwhile q:\n\tu = -heappop(q)\n\tr[u] = c\n\tc -= 1\n\tfor v in g[u]:\n\t\tout[v] -= 1\n\t\tif not out[v]:\n\t\t\theappush(q, -v)\nprint(*r[1:])", "from queue import Queue\nimport heapq\n\nn, m = input().split()\nn = int(n)\nm = int(m)\n\nf = [0] * (n + 1)\nsol = [0] * (n + 1)\nadya = [[] for _ in range(n + 1)]\n\nfor i in range(m):\n    n1, n2 = input().split()\n    n1 = int(n1)\n    n2 = int(n2)\n    adya[n2].append(n1)\n    f[n1] += 1\n\ncola = []\ncnt = 0\n\nfor i in range(1, n + 1):\n    if(f[i] == 0):\n        heapq.heappush(cola, -1 * i)\n        cnt += 1\nnum = int(n)\nwhile(cnt > 0):\n    v = heapq.heappop(cola)\n    v *= -1\n    sol[v] = num\n    cnt -= 1\n    num -= 1\n    for to in adya[v]:\n        f[to] -= 1\n        if(f[to] == 0):\n            heapq.heappush(cola, -1 * to)\n            cnt += 1\n\nstringOut = \"\"\nfor i in range(1, n + 1):\n    stringOut += str(sol[i])\n    if(i != n):\n        stringOut += ' '\n        \nprint(stringOut)", "from queue import Queue\nimport heapq\n\nn, m = input().split()\nn = int(n)\nm = int(m)\n\nf = [0] * (n + 1)\nsol = [0] * (n + 1)\nadya = [[] for _ in range(n + 1)]\n\nfor i in range(m):\n    n1, n2 = input().split()\n    n1 = int(n1)\n    n2 = int(n2)\n    adya[n2].append(n1)\n    f[n1] += 1\n\ncola = []\ncnt = 0\n\nfor i in range(1, n + 1):\n    if(f[i] == 0):\n        heapq.heappush(cola, -1 * i)\n        cnt += 1\nnum = int(n)\nwhile(cnt > 0):\n    v = heapq.heappop(cola)\n    v *= -1\n    sol[v] = num\n    cnt -= 1\n    num -= 1\n    for to in adya[v]:\n        f[to] -= 1\n        if(f[to] == 0):\n            heapq.heappush(cola, -1 * to)\n            cnt += 1\n\nstringOut = \"\"\nfor i in range(1, n + 1):\n    stringOut += str(sol[i])\n    if(i != n):\n        stringOut += ' '\n        \nprint(stringOut)"]
["import itertools\n\ndef valid(grid, path, perm, start, goal):\n    x, y = start\n    n = len(grid)\n    m = len(grid[0])\n    for move in path:\n        dx, dy = perm[int(move)]\n        x += dx\n        y += dy\n        if (x, y) == goal:\n            return True\n        if not (0 <= x < n and 0 <= y < m) or grid[x][y] == '#':\n            return False\n\n    return False\n\ndef main():\n    n, m = list(map(int, input().split()))\n    grid = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                grid[i][j] = '.'\n            elif grid[i][j] == 'E':\n                gx, gy = i, j\n                grid[i][j] = '.'\n\n\n    path = input()\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    ans = 0\n    for perm in itertools.permutations(moves):\n        if valid(grid, path, perm, (sx, sy), (gx, gy)):\n            ans += 1\n\n    print(ans)\n\nmain()\n", "from itertools import permutations\n\ndirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n\nn, m = list(map(int, input().split()))\ns = [input() for _ in range(n)]\n\nspos = (0, 0)\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == 'S':\n            spos = (j, i)\n\nt = input()\n\nans = 0\nfor p in permutations(dirs):\n    x, y = spos\n    for c in t:\n        dr = p[int(c)]\n        x += dr[0]\n        y += dr[1]\n        if not 0 <= x < m or not 0 <= y < n:\n            break\n        if s[y][x] == '#':\n            break\n        if s[y][x] == 'E':\n            ans += 1\n            break\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\na = [input() for i in range(n)]\ns = input().strip()\n\nfor i in range(n):\n  for j in range(m):\n    if a[i][j] == 'S':\n      sx, sy = i, j\n    if a[i][j] == 'E':\n      ex, ey = i, j\n\nans = 0\n\nimport itertools\nfor p in itertools.permutations([(-1, 0), (1, 0), (0, 1), (0, -1)], 4):\n  x, y = sx, sy\n  good = True\n  for v in s:\n    x += p[int(v)][0]\n    y += p[int(v)][1]\n    if not(0 <= x < n and 0 <= y < m and a[x][y] != '#'):\n      good = False\n    if (x, y) == (ex, ey):\n      break\n  if (x, y) != (ex, ey):\n    good = False\n  if good:\n    ans += 1\n  \nprint(ans)", "from collections import defaultdict as di\nn,m = [int(x) for x in input().split()]\nfree = di(lambda:False)\nstartpos = (-1,-1)\ngoal = (-1,-1)\nfor y in range(n):\n    s = input()\n    for x in range(m):\n        c = s[x]\n        if c=='S':\n            startpos=(x,y)\n            free[(x,y)]=True\n        elif c=='E':\n            goal=(x,y)\n            free[(x,y)]=True\n        elif c=='.':\n            free[(x,y)]=True\ncounts = 0\ndire = '0123'\ncommand = input()\nfor up in dire:\n    for down in dire:\n        for right in dire:\n            for left in dire:\n                if len(set([up,down,left,right]))<4:\n                    continue\n                pos = startpos\n                for c in command:\n                    x,y = pos\n                    if c == up:\n                        y+=1\n                    elif c == down:\n                        y-=1\n                    elif c==right:\n                        x+=1\n                    else:\n                        x-=1\n                    pos = (x,y)\n                    if pos == goal:\n                        counts += 1\n                        break\n                    if not free[pos]:\n                        break\n\nprint(counts)\n", "n, m = map(int, input().split())\na = []\nstartx = 0\nstarty = 0\nfor i in range(n):\n    a.append(input())\n    if (\"S\" in a[i]):\n        startx = a[i].index('S')\n        starty = i\n        \ns = input()\nans = 0\nfor l in range(4):\n    for r in range(4):\n        if r == l: continue\n        for u in range(4):\n            if u == r or u == l: continue\n            for d in range(4):\n                if (d == u or d == r or d == l): continue\n                posx = startx\n                posy = starty\n                for i in s:\n                    i = int(i)\n                    if (i == l):\n                        posx -= 1\n                    elif (i == r):\n                        posx += 1\n                    elif (i == d):\n                        posy += 1\n                    elif (i == u):\n                        posy -= 1\n                    \n                    if (posy < 0 or posy >= n or posx < 0 or posx >= m):\n                        break\n                    elif (a[posy][posx] == '#'):\n                        break\n                    elif (a[posy][posx] == 'E'):\n                        ans += 1\n                        break\n                    \nprint(ans)", "import itertools as I\n\nh,w = list(map(int,input().split()))\nM = [list(input()) for _ in range(h)]\ncmds = input()\n\ndef ok(x,y):\n    return 0 <= x < w and 0 <= y < h and M[y][x]!='#'\n\nstart = None\nend = None\nfor i in range(h):\n    for j in range(w):\n        if M[i][j] == 'S':\n            start = (j,i)\n        if M[i][j] == 'E':\n            end = (j,i)\n         \ncnt = 0\nfor dirs in I.permutations([(1,0),(0,1),(-1,0),(0,-1)]):\n    x,y = start\n    for c in cmds:\n        dx,dy = dirs[int(c)]\n        x += dx\n        y += dy\n        if not ok(x,y):\n            break\n        if M[y][x] == 'E':\n            cnt += 1\n            break\nprint(cnt)\n", "from itertools import permutations\nn, m = list(map(int, input().split()))\nM = [input() for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if M[i][j] == 'S':\n            sx = j; sy = i\n        elif M[i][j] == 'E':\n            ex = j; ey = i\n*S, = list(map(int, input()))\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\ndef solve(p):\n    x = sx; y = sy\n    for c in S:\n        dx, dy = dd[p[c]]\n        x += dx; y += dy\n        if (not 0 <= x < m) or (not 0 <= y < n) or (M[y][x] == '#'):\n            return 0\n        if x == ex and y == ey:\n            return 1\n    return 0\n\nans = 0\nfor p in permutations(list(range(4))):\n    ans += solve(p)\nprint(ans)\n", "r, s = list(map(int, input().split()))\nm = []\nfor i in range(r):\n    m.append(input())\n    for j in range(s):\n        if m[i][j] == 'S':\n            start = i, j\nse = input()\nu = [0, 1, 0, -1]\nv = [1, 0, -1, 0]\nsol = 0\nfor a in range(4):\n    for b in range(4):\n        for c in range(4):\n            for d in range(4):\n                if len(set([a, b, c, d])) < 4:\n                    continue\n                x, y = start\n                cnt = 0\n                for znak in se:\n                    if znak == '0':\n                        x += u[a]\n                        y += v[a]\n                    if znak == '1':\n                        x += u[b]\n                        y += v[b]\n                    if znak == '2':\n                        x += u[c]\n                        y += v[c]\n                    if znak == '3':\n                        x += u[d]\n                        y += v[d]\n                    cnt += 1\n                    if x < 0 or y < 0 or x >= r or y >= s:\n                        cnt = -1\n                        break\n                    if m[x][y] not in ['.', 'S']:\n                        break\n                #print(a, b, c, d, m[x][y], cnt, x, y)\n                if cnt > 0 and m[x][y] == 'E':\n                    sol += 1\nprint(sol)\n", "import itertools\n\nn, m = [int(v) for v in input().split()]\nl = [input() for _ in range(n)]\ndirs = [int(c) for c in input()]\n\nstart, end = None, None\nfor i, line in enumerate(l):\n    ps = line.find('S')\n    pe = line.find('E')\n    if ps != -1:\n        start = (ps, i)\n    if pe != -1:\n        end = (pe, i)\n\n# up, down, left, right\nways = [(0, -1), (0, 1), (-1, 0), (1, 0)]\ncnt = 0\n\nfor p in itertools.permutations(list(range(4))):\n    dst = [ways[pp] for pp in p]\n    px, py = start\n    for d in dirs:\n        px += dst[d][0]\n        py += dst[d][1]\n        if px < 0 or px >= m or py < 0 or py >= n or l[py][px] == '#':\n            break\n        if (px, py) == end:\n            cnt += 1\n            break\n\nprint(cnt)\n", "import sys\n\ndr = [0, 1, 0, -1]\ndc = [1, 0, -1, 0]\nrows, cols = map(int, sys.stdin.readline().split())\n\nb = ['' for row in range(rows)]\nsr, sc = 0, 0\ner, ec = 0, 0\nfor row in range (rows):\n  b[row] = sys.stdin.readline().strip()\n  if 'S' in b[row]:\n    sr, sc = row, b[row].index('S')\n  if 'E' in b[row]:\n    er, ec = row, b[row].index('E')\n\n\ndirs = sys.stdin.readline().strip()\n\nres = 0\nfor i in range (4):\n  for j in range (4):\n    for k in range (4):\n      if j != i and i != k and j != k:\n        l = (0+1+2+3) - (i+j+k)\n        r, c = sr, sc\n        p = [i, j, k, l]\n        ok = 0\n        for d in dirs:\n          di = int(d)\n          r += dr[p[di]]\n          c += dc[p[di]]\n          if r < 0 or r >= rows or c < 0 or c >= cols or b[r][c] == '#':\n            break\n          if b[r][c] == 'E':\n            ok = 1\n        res += ok\n\nprint (res)         ", "n,m = list(map(int,input().split()))\ngrid = []\nsloc = (-1,-1)\neloc = (-1,-1)\nfor y in range(n):\n    l = input()\n    grid.append(list())\n    for x in range(m):\n        grid[-1].append(l[x]=='#')\n        if l[x]=='S':\n            sloc = (x,y)\n        elif l[x]=='E':\n            eloc = (x,y)\n\npb = []\nfor a in [(0,1),(0,-1),(1,0),(-1,0)]:\n    for b in [(0,1),(0,-1),(1,0),(-1,0)]:\n        for c in [(0,1),(0,-1),(1,0),(-1,0)]:\n            for d in [(0,1),(0,-1),(1,0),(-1,0)]:\n                if len(set([a,b,c,d]))==4 and [a,b,c,d] not in pb:\n                    pb.append([a,b,c,d])\n\ns = input()\n\nans = 0\nfor mp in pb:\n    seen = False\n    works = True\n    loc = sloc\n    for j in s:\n        j = int(j)\n        if seen:\n            break\n        if not works:\n            break\n        nloc = (loc[0]+mp[j][0],loc[1]+mp[j][1])\n        if min(nloc)<0 or nloc[0]>=m or nloc[1]>=n:\n            works = False\n            break\n        if grid[nloc[1]][nloc[0]]:\n            works = False\n            break\n        if nloc == eloc:\n            seen = True\n            break\n        loc = nloc\n    if seen:\n        ans+=1\n\nprint(ans)\n", "import sys\n\n#f = open('input', 'r')\nf = sys.stdin\nms = tuple(map(int, f.readline().split()))\nd = [(0, 1), (0, -1), (1, 0), (-1, 0)]\nmp = []\nfor i in range(ms[0]):\n  mp.append(f.readline().strip())\n  for j in range(ms[1]):\n    if mp[i][j] == 'S':\n      start_pos = (i, j)\n    elif mp[i][j] == 'E':\n      end_pos = (i, j)\n\ngo = f.readline().strip()\nimport itertools\nans = 0\nfor dp in itertools.permutations(d):\n  cur_pos = start_pos\n  failed = False\n  for x in go:\n    cur_pos = tuple(map(sum, list(zip(cur_pos, dp[int(x)]))))\n    for p, q in zip(cur_pos, ms):\n      if p < 0 or p >= q:\n        failed = True\n    if failed:\n      break\n    if mp[cur_pos[0]][cur_pos[1]] == '#':\n      failed = True\n      break\n    elif mp[cur_pos[0]][cur_pos[1]] == 'E':\n      failed = False\n      break\n  if not failed and mp[cur_pos[0]][cur_pos[1]] == 'E':\n    ans += 1\nprint(ans)\n", "import itertools\n\nr, c = input().split()\nr, c = int(r), int(c)\n\ndef add(a, b):\n    return (a[0] + b[0], a[1] + b[1])\n\ndef is_valid(k, r, c):\n    return (0 <= k[0] < r) and (0 <= k[1] < c)\n\nm = [input() for x in range(r)]\n\nfor a in range(r):\n    for b in range(c):\n        if m[a][b] == 'S':\n            start = (a, b)\n        elif m[a][b] == 'E':\n            end = (a, b)\n\nd = input()\nt = 0\n\nfor p in itertools.permutations([(0, 1), (0, -1), (-1, 0), (1, 0)]):\n    poss = True\n    curr = start\n    \n    for i in d:\n        curr = add(curr, p[int(i)])\n        \n        if (curr == end):\n            break\n\n        if (is_valid(curr, r, c)) and (m[curr[0]][curr[1]] != '#'):\n            continue\n        \n        poss = False\n        break\n    \n    if poss and (curr == end):\n        t += 1\n\nprint(t)\n", "n, m = list(map(int, input().split()))\nd = []\nfor i in range(n):\n\td.append(input())\n\tif 'S' in d[-1]:\n\t\ts = [i, d[-1].index('S')]\n\tif 'E' in d[-1]:\n\t\te = [i, d[-1].index('E')]\np = input()\ndic = {'n': [-1, 0], 'e':[0,1], 's':[1, 0], 'w':[0,-1]}\nimport itertools as it\nz = it.permutations('news', 4)\nres = 0\nfor i in z:\n\tst = s\n\tet = e\n\tq = {'0123'[j]:dic[i[j]] for j in range(4)}\n\tfor j in p:\n\t\tcur = q[j]\n\t\tst = [st[0] + cur[0], st[1] + cur[1]]\n\t\tif st[0] < 0 or st[0] >= n or st[1] < 0 or st[1] >= m or d[st[0]][st[1]] == '#':\n\t\t\tbreak\n\t\tif st == et:\n\t\t\tbreak\n\tif st == et:\n\t\tres += 1\nprint(res)\n", "def onGrid(p):\n  if p.real >= 0 and p.real < n and p.imag >= 0 and p.imag < m:\n    return True\nfrom itertools import permutations\nn,m = map(int, input().split())\ngrid = [input() for a in range(n)]\nfor a in range(n):\n  if \"S\" in grid[a]:\n    start = a+1j*grid[a].index(\"S\")\n  if \"E\" in grid[a]:\n    end = a+1j*grid[a].index(\"E\")\nways = list(permutations([1,-1,1j,-1j],4))\ncount = 0\ninstructions = input()\nfor way in ways:\n  coords = start+0\n  for i in instructions:\n    coords += way[int(i)]\n    if not onGrid(coords) or grid[int(coords.real)][int(coords.imag)] == \"#\":\n      break\n    if coords == end:\n      count += 1\n      break\nprint(count)", "n, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n\tgrid.append(input())\n\tif grid[-1].find('S') > -1:\n\t\tS = (i, grid[-1].find('S'))\n\tif grid[-1].find('E') > -1:\n\t\tE = (i, grid[-1].find('E'))\n\nstring = input()\n\ndirections = []\ndef all_permutations(seq):\n\tif len(seq) == 0:\n\t\tyield []\n\tfor i in seq:\n\t\tfor p in all_permutations([x for x in seq if x!=i]):\n\t\t\tyield [i] + p\n\nd_map = [(0,-1), (1,0), (0,1), (-1,0)]\nans = 0\nfor p in all_permutations([0,1,2,3]):\n\t#0 goes in direction d_map[p[0]]\n\tcr = S[0]\n\tcc = S[1]\n\tfor i in string:\n\t\tcr = cr + d_map[p[int(i)]][0]\n\t\tcc = cc + d_map[p[int(i)]][1]\n\t\tif cr >= n or cr < 0 or cc >= m or cc < 0 or grid[cr][cc] == \"#\":\n\t\t\tbreak\n\t\tif grid[cr][cc] == \"E\":\n\t\t\tans += 1\n\t\t\tbreak\n\t\t\n\nprint(ans)", "import itertools\n\ndirs = (list(itertools.permutations(['r', 'l', 'd', 'u'])))\n\nn,m = list(map(int, input().split()))\ngrid = []\nfor i in range(n):\n\tgrid.append(input())\n\npath = input()\n\ndx = {\n\t'r': 0,\n\t'l': 0,\n\t'u': -1,\n\t'd': 1\n}\ndy = {\n\t'r': 1,\n\t'l': -1,\n\t'u': 0,\n\t'd': 0\n}\n\ndef can_reach(n, m, grid, adir, path, dx, dy):\n\tx = y = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif grid[i][j] == 'S':\n\t\t\t\tx = i\n\t\t\t\ty = j\n\tfor i in range(len(path)):\n\t\tx += dx[adir[int(path[i])]]\n\t\ty += dy[adir[int(path[i])]]\n\t\tif x >= n or y >= m or x < 0 or y < 0 or grid[x][y] == '#':\n\t\t\treturn False\n\t\tif grid[x][y] == 'E':\n\t\t\treturn True\n\t\t\t\t\n\ncnt = 0\nfor adir in dirs:\n\tif can_reach(n, m, grid, adir, path, dx, dy):\n\t\tcnt+=1\nprint(cnt)\n\n", "import itertools\n\nn, m = list(map(int, input().split()))\nmaze = [input() for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == 'S':\n            sy = i\n            sx = j\n        elif maze[i][j] == 'E':\n            ey = i\n            ex = j\ns = [int(c) for c in input()]\ncnt = 0\nfor p in itertools.permutations([(0, 1), (0, -1), (1, 0), (-1, 0)], r=4):\n    y = sy\n    x = sx\n    for i in s:\n        dy, dx = p[i]\n        if 0 <= y + dy < n and 0 <= x + dx < m and maze[y+dy][x+dx] != '#':\n            y += dy\n            x += dx\n        else:\n            break\n        if y == ey and x == ex:\n            break\n    if y == ey and x == ex:\n\n        cnt += 1\nprint(cnt)\n", "n, m = map(int, input().split())\na = []\nstart = None\nfor i in range(n):\n    s = input()\n    a.append(s)\n    if 'S' in s:\n        start = [i, s.index('S')]\nh = input()\nans = 0\nms = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\ndef check(d):\n    ps = [i for i in start]\n    for l in h:\n        nm = ms[d[int(l)]]\n        dx, dy = nm\n        ps = [ps[0] + dx, ps[1] + dy]\n        if ps[0] >= n or ps[0] < 0 or ps[1] < 0 or ps[1] >= m or a[ps[0]][ps[1]] == '#':\n            return False\n        if a[ps[0]][ps[1]] == 'E':\n            return True\n    return False\n\nfor i in range(4):\n    for j in range(4):\n        if j != i:\n            for k in range(4):\n                if k not in [i, j]:\n                    for z in range(4):\n                        if z not in [i, j, k]:\n                            if check({0: i, 1: j, 2: k, 3: z}):\n                                ans += 1\nprint(ans)", "# coding: utf-8\n\nimport itertools\n\ndef check(dirs, inst, maze, s):\n    posy, posx = s\n    rx = len(maze[0])\n    ry = len(maze)\n    for i in inst:\n        if dirs[i] == \"N\":\n            posy -= 1\n        elif dirs[i] == \"S\":\n            posy += 1\n        elif dirs[i] == \"E\":\n            posx += 1\n        elif dirs[i] == \"W\":\n            posx -= 1\n        if posx < 0 or posx >= rx or posy < 0 or posy >= ry:\n            return False\n        if maze[posy][posx] == \"#\":\n            return False\n        if maze[posy][posx] == \"E\":\n            return True\n    return False\n\n\nn, m = list(map(int, input().split()))\nmaze = []\nfor i in range(n):\n    l = input().strip()\n    maze.append(l)\n    if \"S\" in l:\n        s = (i, l.index(\"S\"))\ninst = list(map(int, input().strip()))\nt = 0\nfor i in itertools.permutations(\"NWSE\"):\n    c = check(i, inst, maze, s)\n    t += check(i, inst, maze, s)\nprint(t)\n", "from itertools import permutations\n\ndef ok(n, m, v, a, l):\n    x, y = -1, -1\n    for i, q in enumerate(v):\n        if 'S' in q:\n            x = i\n            y = q.index('S')\n            break\n    for i in l:\n        if a[i] == 'u':\n            x -= 1\n        elif a[i] == 'd':\n            x += 1\n        elif a[i] == 'l':\n            y += 1\n        elif a[i] == 'r':\n            y -= 1\n\n        if x < 0 or x >= n or y < 0 or y >= m or v[x][y] == '#':\n            return False\n\n        if v[x][y] == 'E':\n            return True\n    \n    if x < 0 or x >= n or y < 0 or y >= m or v[x][y] == '#':\n        return False\n\n    return v[x][y] == 'E'\n\nn, m = map(int, input().split())\n\nv = [input() for _ in range(n)]\n\nl = list(map(int, input()))\n\nans = 0\n\nfor i in permutations(['u', 'd', 'l', 'r']):\n    if ok(n, m, v, i, l):\n        ans += 1\n\nprint(ans)", "\nn,m=map(int,input().split())\ndef road(ins):\n    cur=S.copy()\n    for x in s:\n        x=int(x)\n        if ar[cur[0]][cur[1]]== 'E':\n            return 1\n        if ins[x]=='U':\n            try:\n                if ar[cur[0]+1][cur[1]] != '#':\n                    cur=[cur[0]+1,cur[1]]\n                else:\n                    return 0\n            except:\n                return 0\n        if ins[x]=='D':\n            try:\n                if ar[cur[0]-1][cur[1]] != '#' and cur[0]-1 >= 0:\n                    cur=[cur[0]-1,cur[1]]\n                else:\n                    return 0\n            except:\n                return 0\n        if ins[x]=='R':\n            try:\n                if ar[cur[0]][cur[1]+1] != '#':\n                    cur=[cur[0],cur[1]+1] \n                else:\n                    return 0\n            except:\n                return 0\n        if ins[x]=='L':\n            try:\n                if ar[cur[0]][cur[1]-1] != '#' and cur[1]-1 >= 0:\n                    cur=[cur[0],cur[1]-1] \n                else:\n                    return 0\n            except:\n                return 0\n    #print(cur)\n    if ar[cur[0]][cur[1]]== 'E':\n        return 1\n    else:\n        return 0\nar=[input() for x in range(n)]\nS=[0,0]\nE=[0,0]\nfor x in range(n):\n    if 'S' in ar[x]:\n        S=[x,ar[x].index('S')]\n    if 'E' in ar[x]:\n        E=[x,ar[x].index('E')]\ns=input()\nimport itertools\ni=0\nfor x in list(itertools.permutations(['U','D','L','R'])):\n    #print(list(x))\n    i+= road(list(x))\nprint(i)"]
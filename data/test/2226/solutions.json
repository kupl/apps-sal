["import sys\ninput = sys.stdin.readline\n#lev contains height from root,lower neighbour, higher neighbours\n#lev[0] contains 0 (because it is the root), higher neighbours (=neighbours)\nn,m,q=map(int,input().split())\nmod=1000000007\nmxw=0\nwgts=[0]*n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b,w=map(int,input().split())\n    a-=1\n    b-=1\n    neig[a][0]+=1\n    neig[b][0]+=1\n    neig[a].append([b,w])\n    neig[b].append([a,w])\n    mxw=max(mxw,w)\n    wgts[a]=max(wgts[a],w)\n    wgts[b]=max(wgts[b],w)\nposs=[-1]*n\nposs[0]=0\nsol=0\ncurw=0\nhasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:\n        hasmxw[i]=True\nov=False\nl=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):\n                newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])\n    curmx=0\n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:\n            curmx=poss[i]\n            ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:\n                ov=True\n    curw=curmx\n    sol+=curw\n    sol%=mod\n    l+=1\nif l==q:\n    print(sol)\nelse:\n    if ov:\n        rem=q-l\n        sol+=rem*curw\n        sol%=mod\n        sol+=mxw*((rem*(rem+1))//2)\n        sol%=mod\n        print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0\n            for i in range(n):\n                if poss[i]==curw:\n                    mx=max(mx,wgts[i])\n            gd=-1\n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx\n                    loss=curw-poss[i]\n                    loss+=diff-1\n                    att=loss//diff\n                    if gd==-1:\n                        gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:\n                sol+=rem*curw\n                sol+=mx*((rem*(rem+1))//2)\n                sol%=mod\n                ov=True\n            else:\n                sol+=(gd-1)*curw\n                sol+=mx*((gd*(gd-1))//2)\n                sol%=mod\n                for i in range(n):\n                    poss[i]+=gd*wgts[i]\n                    curw=max(curw,poss[i])\n                sol+=curw\n                rem-=gd\n        print(sol)", "import sys\ninput = sys.stdin.readline\n#lev contains height from root,lower neighbour, higher neighbours\n#lev[0] contains 0 (because it is the root), higher neighbours (=neighbours)\nn,m,q=map(int,input().split())\nmod=1000000007\nmxw=0\nwgts=[0]*n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b,w=map(int,input().split())\n    a-=1\n    b-=1\n    neig[a][0]+=1\n    neig[b][0]+=1\n    neig[a].append([b,w])\n    neig[b].append([a,w])\n    mxw=max(mxw,w)\n    wgts[a]=max(wgts[a],w)\n    wgts[b]=max(wgts[b],w)\nposs=[-1]*n\nposs[0]=0\nsol=0\ncurw=0\nhasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:\n        hasmxw[i]=True\nov=False\nl=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):\n                newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])\n    curmx=0\n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:\n            curmx=poss[i]\n            ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:\n                ov=True\n    curw=curmx\n    sol+=curw\n    sol%=mod\n    l+=1\nif l==q:\n    print(sol)\nelse:\n    if ov:\n        rem=q-l\n        sol+=rem*curw\n        sol%=mod\n        sol+=mxw*((rem*(rem+1))//2)\n        sol%=mod\n        print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0\n            for i in range(n):\n                if poss[i]==curw:\n                    mx=max(mx,wgts[i])\n            gd=-1\n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx\n                    loss=curw-poss[i]\n                    loss+=diff-1\n                    att=loss//diff\n                    if gd==-1:\n                        gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:\n                sol+=rem*curw\n                sol+=mx*((rem*(rem+1))//2)\n                sol%=mod\n                ov=True\n            else:\n                sol+=(gd-1)*curw\n                sol+=mx*((gd*(gd-1))//2)\n                sol%=mod\n                for i in range(n):\n                    poss[i]+=gd*wgts[i]\n                    curw=max(curw,poss[i])\n                sol+=curw\n                rem-=gd\n        print(sol)", "import sys\ninput = sys.stdin.readline\nn,m,q=map(int,input().split())\nmod=1000000007\nmxw=0\nwgts=[0]*n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b,w=map(int,input().split())\n    a-=1;b-=1;neig[a][0]+=1;neig[b][0]+=1;neig[a].append([b,w]);neig[b].append([a,w])\n    mxw=max(mxw,w);wgts[a]=max(wgts[a],w);wgts[b]=max(wgts[b],w)\nposs=[-1]*n;poss[0]=0;sol=0;curw=0;hasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:hasmxw[i]=True\nov=False\nl=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):\n                newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])\n    curmx=0\n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:curmx=poss[i];ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:ov=True\n    curw=curmx;sol+=curw;sol%=mod;l+=1\nif l==q:print(sol)\nelse:\n    if ov:\n        rem=q-l\n        sol+=rem*curw\n        sol%=mod\n        sol+=mxw*((rem*(rem+1))//2)\n        sol%=mod\n        print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0\n            for i in range(n):\n                if poss[i]==curw:mx=max(mx,wgts[i])\n            gd=-1\n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx\n                    loss=curw-poss[i]\n                    loss+=diff-1\n                    att=loss//diff\n                    if gd==-1:\n                        gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:sol+=rem*curw;sol+=mx*((rem*(rem+1))//2);sol%=mod;ov=True\n            else:\n                sol+=(gd-1)*curw;sol+=mx*((gd*(gd-1))//2);sol%=mod\n                for i in range(n):poss[i]+=gd*wgts[i];curw=max(curw,poss[i])\n                sol+=curw;rem-=gd\n        print(sol)", "import sys\nn,m,q=map(int,input().split())\nmod,mxw = 1000000007,0;wgts,neig=[0]*n,[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b,w=map(int,input().split())\n    a-=1;b-=1;neig[a][0]+=1;neig[b][0]+=1;neig[a].append([b,w]);neig[b].append([a,w])\n    mxw=max(mxw,w);wgts[a]=max(wgts[a],w);wgts[b]=max(wgts[b],w)\nposs=[-1]*n;poss[0]=0;sol=0;curw=0;hasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:hasmxw[i]=True\nov=False;l=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n;curmx=0\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])    \n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:curmx=poss[i];ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:ov=True\n    curw=curmx;sol+=curw;sol%=mod;l+=1\nif l==q:print(sol)\nelse:\n    if ov:rem=q-l;sol+=rem*curw;sol%=mod;sol+=mxw*((rem*(rem+1))//2);sol%=mod;print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0;gd=-1\n            for i in range(n):\n                if poss[i]==curw:mx=max(mx,wgts[i])            \n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx;loss=curw-poss[i];loss+=diff-1;att=loss//diff\n                    if gd==-1:gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:sol+=rem*curw;sol+=mx*((rem*(rem+1))//2);sol%=mod;ov=True\n            else:\n                sol+=(gd-1)*curw;sol+=mx*((gd*(gd-1))//2);sol%=mod\n                for i in range(n):poss[i]+=gd*wgts[i];curw=max(curw,poss[i])\n                sol+=curw;rem-=gd\n        print(sol)", "n,m,q=map(int,input().split());mod,mxw = 1000000007,0;wgts,neig=[0]*n,[0]*n\nfor i in range(n):neig[i]=[0]\nfor i in range(m):a,b,w=map(int,input().split());a-=1;b-=1;neig[a][0]+=1;neig[b][0]+=1;neig[a].append([b,w]);neig[b].append([a,w]);mxw=max(mxw,w);wgts[a]=max(wgts[a],w);wgts[b]=max(wgts[b],w)\nposs=[-1]*n;poss[0]=0;sol=0;curw=0;hasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:hasmxw[i]=True\nov=False;l=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n;curmx=0\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])    \n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:curmx=poss[i];ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:ov=True\n    curw=curmx;sol+=curw;sol%=mod;l+=1\nif l==q:print(sol)\nelse:\n    if ov:rem=q-l;sol+=rem*curw;sol%=mod;sol+=mxw*((rem*(rem+1))//2);sol%=mod;print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0;gd=-1\n            for i in range(n):\n                if poss[i]==curw:mx=max(mx,wgts[i])            \n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx;loss=curw-poss[i];loss+=diff-1;att=loss//diff\n                    if gd==-1:gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:sol+=rem*curw;sol+=mx*((rem*(rem+1))//2);sol%=mod;ov=True\n            else:\n                sol+=(gd-1)*curw;sol+=mx*((gd*(gd-1))//2);sol%=mod\n                for i in range(n):poss[i]+=gd*wgts[i];curw=max(curw,poss[i])\n                sol+=curw;rem-=gd\n        print(sol)", "import sys\ninput = sys.stdin.readline\nn, m, q = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\nedges = []\nadj = [[] for _ in range(n)]\n\nfor i in range(m):\n\ta, b, w = list(map(int, input().split()))\n\ta -= 1\n\tb -= 1\n\tedges.append((a, b, w))\n\tadj[a].append((b, w))\n\tadj[b].append((a, w))\n\n\nINF = 10 ** 18\n\nans = 0\n\nDP = [-INF] * n\nDP[0] = 0\n\n# Paths are at most m long\nfor plen in range(m):\n\tNDP = [-INF] * n\n\n\tfor i in range(n):\n\t\tfor j, w in adj[i]:\n\t\t\tNDP[j] = max(NDP[j], DP[i] + w)\n\n\tDP = NDP\n\tans = (ans + max(DP)) % MOD\n\n#print(ans)\n#print(DP)\n#assert all(v > 0 for v in DP)\n\n\n\"\"\" From PyRival \"\"\"\ndef convex_hull_trick(K, M, integer = True):\n    \"\"\"\n    Given lines on the form y = K[i] * x + M[i] this function returns intervals,\n    such that on each interval the convex hull is made up of a single line.\n    Input:\n        K: list of the slopes\n        M: list of the constants (value at x = 0)\n        interger: boolean for turning on / off integer mode. Integer mode is exact, it\n                  works by effectively flooring the seperators of the intervals.\n    Return:\n        hull_i: on interval j, line i = hull_i[j] is >= all other lines\n        hull_x: interval j and j + 1 is separated by x = hull_x[j], (hull_x[j] is the last x in interval j)\n    \"\"\"\n    if integer:\n        intersect = lambda i,j: (M[j] - M[i]) // (K[i] - K[j])\n    else:\n        intersect = lambda i,j: (M[j] - M[i]) / (K[i] - K[j])\n\n    assert len(K) == len(M)\n\n    hull_i = []\n    hull_x = []\n    order = sorted(list(range(len(K))), key = K.__getitem__)\n    for i in order:\n        while True:\n            if not hull_i:\n                hull_i.append(i)\n                break\n            elif K[hull_i[-1]] == K[i]:\n                if M[hull_i[-1]] >= M[i]:\n                    break\n                hull_i.pop()\n                if hull_x: hull_x.pop()\n            else:\n                x = intersect(i, hull_i[-1])\n                if hull_x and x <= hull_x[-1]:\n                    hull_i.pop()\n                    hull_x.pop()\n                else:\n                    hull_i.append(i)\n                    hull_x.append(x)\n                    break\n    return hull_i, hull_x\n\n\nnedges = []\nslope, intersect = [], []\nfor a, b, w in edges:\n\ti = max(a, b, key=lambda i: DP[i])\n\n\tassert DP[i] > 0\n\n\t#print(f'edge ({a+1}, {b+1}, {w}) usable from {usable_from} with distance {w_at_time}', file=sys.stderr)\n\tslope.append(w)\n\tintersect.append(DP[i])\n\tnedges.append((DP[i], w))\n\n# For each edge, figure out the interval in which it is the best option\nhull_i, hull_x = convex_hull_trick(slope, intersect)\n\n#print(hull_i)\n#print(hull_x)\n\ndef tri(x):\n\treturn (x * (x + 1)) // 2\n\nlt = 0\nfor i, j in enumerate(hull_i):\n\twt, w = nedges[j]\n\n\tuntil = min(q if i == len(hull_x) else hull_x[i], q - m)\n\n\tif until <= 0: continue\n\n\tactive = (until - lt)\n\t#assert us <= lt\n\t#assert until > lt, (until, lt)\n\n\tans = (ans + active * wt) % MOD\n\n\tmin_uses = lt\n\tmax_uses = lt + active\n\n\ttimes = tri(max_uses) - tri(min_uses)\n\tans = (ans + times * w) % MOD\n\n\t#print(f'since {lt} to {until} use {(wt, w)} from {min_uses} to {max_uses} ({times}) times')\n\t#print(ans)\n\n\tlt = until\n\tif lt == q - m: break\n\nprint(ans)\n\n", "import sys\ninput = sys.stdin.readline\nn, m, q = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\nedges = []\nadj = [[] for _ in range(n)]\n\nfor i in range(m):\n\ta, b, w = list(map(int, input().split()))\n\ta -= 1\n\tb -= 1\n\tedges.append((a, b, w))\n\tadj[a].append((b, w))\n\tadj[b].append((a, w))\n\n\nINF = 10 ** 18\nans = 0\n\nDP = [-INF] * n\nDP[0] = 0\n\n# Paths are at most m long\nfor plen in range(m):\n\tNDP = [-INF] * n\n\n\tfor a, b, w in edges:\n\t\tNDP[b] = max(NDP[b], DP[a] + w)\n\t\tNDP[a] = max(NDP[a], DP[b] + w)\n\n\tDP = NDP\n\tans = (ans + max(DP)) % MOD\n\n\"\"\" From PyRival \"\"\"\ndef convex_hull_trick(K, M, integer = True):\n    \"\"\"\n    Given lines on the form y = K[i] * x + M[i] this function returns intervals,\n    such that on each interval the convex hull is made up of a single line.\n    Input:\n        K: list of the slopes\n        M: list of the constants (value at x = 0)\n        interger: boolean for turning on / off integer mode. Integer mode is exact, it\n                  works by effectively flooring the seperators of the intervals.\n    Return:\n        hull_i: on interval j, line i = hull_i[j] is >= all other lines\n        hull_x: interval j and j + 1 is separated by x = hull_x[j], (hull_x[j] is the last x in interval j)\n    \"\"\"\n    if integer:\n        intersect = lambda i,j: (M[j] - M[i]) // (K[i] - K[j])\n    else:\n        intersect = lambda i,j: (M[j] - M[i]) / (K[i] - K[j])\n\n    assert len(K) == len(M)\n\n    hull_i = []\n    hull_x = []\n    order = sorted(list(range(len(K))), key = K.__getitem__)\n    for i in order:\n        while True:\n            if not hull_i:\n                hull_i.append(i)\n                break\n            elif K[hull_i[-1]] == K[i]:\n                if M[hull_i[-1]] >= M[i]:\n                    break\n                hull_i.pop()\n                if hull_x: hull_x.pop()\n            else:\n                x = intersect(i, hull_i[-1])\n                if hull_x and x <= hull_x[-1]:\n                    hull_i.pop()\n                    hull_x.pop()\n                else:\n                    hull_i.append(i)\n                    hull_x.append(x)\n                    break\n    return hull_i, hull_x\n\n\nslope, intersect = [], []\nfor a, b, w in edges:\n\ti = max(a, b, key=lambda i: DP[i])\n\tassert DP[i] > 0\n\n\t#print(f'edge ({a+1}, {b+1}, {w}) usable from {usable_from} with distance {w_at_time}', file=sys.stderr)\n\tslope.append(w)\n\tintersect.append(DP[i])\n\n# For each edge, figure out the interval in which it is the best option\nhull_i, hull_x = convex_hull_trick(slope, intersect)\n\n#print(hull_i)\n#print(hull_x)\n\ndef tri(x):\n\treturn (x * (x + 1)) // 2\n\nlt = 0\nfor i, j in enumerate(hull_i):\n\twt, w = intersect[j], slope[j]\n\n\tuntil = min(q if i == len(hull_x) else hull_x[i], q - m)\n\n\tif until <= 0: continue\n\n\tactive = (until - lt)\n\tans = (ans + active * wt) % MOD\n\n\tmin_uses = lt\n\tmax_uses = lt + active\n\n\ttimes = tri(max_uses) - tri(min_uses)\n\tans = (ans + times * w) % MOD\n\n\t#print(f'since {lt} to {until} use {(wt, w)} from {min_uses} to {max_uses} ({times}) times')\n\t#print(ans)\n\n\tlt = until\n\tif lt == q - m: break\n\nprint(ans)\n\n", "import sys\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\n\nMOD = 10 ** 9 + 7\nINF = 100\n\n\ndef convex_hull_trick(K, M, integer=True):\n    \"\"\"\n    Given lines on the form y = K[i] * x + M[i] this function returns intervals,\n    such that on each interval the convex hull is made up of a single line.\n    Input:\n        K: list of the slopes\n        M: list of the constants (value at x = 0)\n        interger: boolean for turning on / off integer mode. Integer mode is exact, it\n                  works by effectively flooring the seperators of the intervals.\n    Return:\n        hull_i: on interval j, line i = hull_i[j] is >= all other lines\n        hull_x: interval j and j + 1 is separated by x = hull_x[j], (hull_x[j] is the last x in interval j)\n    \"\"\"\n    if integer:\n        intersect = lambda i, j: (M[j] - M[i]) // (K[i] - K[j])\n    else:\n        intersect = lambda i, j: (M[j] - M[i]) / (K[i] - K[j])\n\n    assert len(K) == len(M)\n\n    hull_i = []\n    hull_x = []\n    order = sorted(list(range(len(K))), key=K.__getitem__)\n    for i in order:\n        while True:\n            if not hull_i:\n                hull_i.append(i)\n                break\n            elif K[hull_i[-1]] == K[i]:\n                if M[hull_i[-1]] >= M[i]:\n                    break\n                hull_i.pop()\n                if hull_x: hull_x.pop()\n            else:\n                x = intersect(i, hull_i[-1])\n                if hull_x and x <= hull_x[-1]:\n                    hull_i.pop()\n                    hull_x.pop()\n                else:\n                    hull_i.append(i)\n                    hull_x.append(x)\n                    break\n    return hull_i, hull_x\n\n\ndef nn2(n):\n    return n * (n+1) // 2\n\n\ndef solve(n, m, q, edges):\n    # k < m\n    # dp[v][k] - max path cost ending in v and having k edges\n    dp = [[-INF]*(m+1) for _ in range(n)]\n    mk = [0]*(m+1)\n\n    dp[0][0] = 0\n\n    for k in range(1, m+1):\n        for e in edges:\n            if dp[e[0]][k-1] == -INF:\n                continue\n            dp[e[1]][k] = max(dp[e[1]][k], dp[e[0]][k-1] + e[2])\n            mk[k] = max(mk[k], dp[e[1]][k])\n\n    ans = sum(mk) % MOD\n    if q > m:\n        intersect = [dp[i][m] for i in range(n)]\n        slope = [0] * n\n\n        for e in edges:\n            if e[2] > slope[e[0]]:\n                slope[e[0]] = e[2]\n\n        hull_i, hull_x = convex_hull_trick(slope, intersect)\n\n        lt = 0\n        for i, j in enumerate(hull_i):\n            wt = intersect[j]\n            w = slope[j]\n\n            until = min(q if i == len(hull_x) else hull_x[i], q - m)\n            if until <= 0:\n                continue\n\n            active = (until - lt)\n\n            ans = (ans + active * wt) % MOD\n\n            min_uses = lt\n            max_uses = lt + active\n\n            times = nn2(max_uses) - nn2(min_uses)\n            ans = (ans + times * w) % MOD\n\n            lt = until\n            if lt == q - m: break\n\n\n    return ans\n\ndef main():\n    n, m, q = ria()\n    e = []\n    for _ in range(m):\n        u, v, w = ria()\n        u -= 1\n        v -= 1\n        e.append((u, v, w))\n        e.append((v, u, w))\n    wi(solve(n, m, q, e))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
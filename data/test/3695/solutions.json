["n, t = map(int,input().split())\nwait = list(map(int,input().split()))\nseg = []\nfor i in range(n):\n    # to get the food in wait[i], wait __ seconds before running\n    m = max(0, wait[i]-i-1)\n    M = t-i-2\n    if m > M: continue\n    seg.append((m, -1))\n    seg.append((M, 1))\nseg.sort()\n\nans = 0\ncur = 0\nfor t, q in seg:\n    cur-= q\n    ans = max(ans, cur)\nprint(ans)", "from heapq import heappush, heappop\n\nn, m = [int(i) for i in input().split()]\nfood = 0\ntummy = []\ndish = [ -int(i) for i in input().split()]\nfor i in range(1, min(m, n+1)):\n    while tummy and -tummy[0] >= m- i:\n        heappop(tummy)\n    if max(-dish[i-1], i) < m:\n        heappush(tummy, dish[i-1] + i)\n    food = max(len(tummy), food)\nprint(food)\n", "n, T = map(int, input().split())\n\nts = list(map(int, input().split()))\n\nintervals = []\n\nfor i in range(n):\n    start = max(0, ts[i] - i - 1)\n    end = T - i - 2\n    \n    if start > end:\n        continue\n    \n    intervals.append((start, -1))\n    intervals.append((end, 1))\n\nintervals.sort()\n\nans = 0\ncurrent = 0\n\nfor _, val in intervals:\n    current -= val\n    ans = max(ans, current)\n\nprint(ans)", "# using the min-heap \nfrom heapq import heappush,heappop\nbowels,Time = list(map(int,input().split()))\nmyLine = [-int(b) for b in input().split()]\ngulp = []; eat = 0\nfor i in range(1,min(bowels+1,Time)):\n    while gulp and -gulp[0] >= Time - i:\n        # remove the bowel with the highest time penalty \n        heappop(gulp)\n    # Check if the option is viable\n    if -myLine[i-1] < Time:\n        # Remove the step penalty and store the remaining \n        heappush(gulp,myLine[i-1] + i)\n    eat = max(len(gulp),eat)\nprint (eat)\n", "# using the min-heap \nfrom heapq import heappush,heappop\nbowels,Time = map(int,input().split())\nmyLine = [-int(b) for b in input().split()]\ngulp = []; eat = 0\nfor i in range(1,min(bowels+1,Time)):\n    # Terminate in cases where bowels > Time\n    if i >= Time:\n        break\n    while gulp and -gulp[0] >= Time - i:\n        # remove the bowel with the highest time penalty \n        heappop(gulp)\n    # Check if the option is viable\n    if -myLine[i-1] < Time:\n        # Remove the step penalty and store the remaining \n        heappush(gulp,myLine[i-1] + i)\n    eat = max(len(gulp),eat)\nprint (eat)", "# using the min-heap \nfrom heapq import heappush,heappop\nbowels,Time = map(int,input().split())\nmyLine = [-int(b) for b in input().split()]\ngulp = []; eat = 0\nfor i in range(1,min(bowels+1,Time)):\n    # redundant (now that i look at it. the min does that already)\n    if i >= Time:\n        break\n    while gulp and -gulp[0] >= Time - i:\n        # remove the bowel with the highest time penalty \n        heappop(gulp)\n    # Check if the option is viable\n    if -myLine[i-1] < Time:\n        # Remove the step penalty and store the remaining \n        heappush(gulp,myLine[i-1] + i)\n    eat = max(len(gulp),eat)\nprint (eat)"]
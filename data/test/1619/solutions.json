["\"\"\"Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I\"\"\"\n# from fractions import Fraction\n\n\n# def convert_to_fractions(poly):\n#     \"\"\"convert polygon vertex to fractional type\"\"\"\n#     poly_frac = []\n#     for x, y, z in poly:\n#         vertex = (Fraction(x),\n#                   Fraction(y),\n#                   Fraction(z))\n#         poly_frac.append(vertex)\n#     return poly_frac\n\n\ndef convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n\n\ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n\n\ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n\ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n\n\ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n\n\ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n\n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n\n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n\n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n\n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n\n    return u_list\n\n\ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n\n\ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n\n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n\n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n\n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n\n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n\n\ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n\n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n\n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n\n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n\n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n\n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n\n\ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n\n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n\n    b_len, = [int(num) for num in input().split()]\n\n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n\n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n\n\ndef __starting_point():\n    run_from_console()\n__starting_point()", "def convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n \n \ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n \n \ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n \n \ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n \n \ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n \n \ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n \n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n \n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n \n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n \n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n \n    return u_list\n \n \ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n \n \ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n \n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n \n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n \n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n \n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n \n \ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n \n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n \n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n \n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n \n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n \n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n \n \ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n \n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n \n    b_len, = [int(num) for num in input().split()]\n \n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n \n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n \n \ndef __starting_point():\n    run_from_console()\n__starting_point()", "def convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n \n \ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n \n \ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n \n \ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n \n \ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n \n \ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n \n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n \n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n \n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n \n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n \n    return u_list\n \n \ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n \n \ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n \n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n \n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n \n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n \n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n \n \ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n \n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n \n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n \n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n \n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n \n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n \n \ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n \n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n \n    b_len, = [int(num) for num in input().split()]\n \n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n \n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n \n \ndef __starting_point():\n    run_from_console()\n__starting_point()", "from math import gcd, sqrt\nfrom functools import reduce\nimport sys\n\ninput = sys.stdin.readline\n\nEPS = 0.0000000001\n\ndef inp():\n    return(int(input()))\n\ndef inlt():\n    return(list(map(int,input().split())))\n\ndef GCD(args):\n    return reduce(gcd, args)\n\ndef plane_value(plane, point):\n    A, B, C, D = plane\n    x, y, z = point\n    return A*x + B*y + C*z + D\n\ndef plane(p1, p2, p3):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    x3, y3, z3 = p3\n    a1, b1, c1 = x2 - x1, y2 - y1, z2 - z1\n    a2, b2, c2 = x3 - x1, y3 - y1, z3 - z1\n    a, b, c = b1 * c2 - b2 * c1, a2 * c1 - a1 * c2, a1 * b2 - b1 * a2\n    d = (- a * x1 - b * y1 - c * z1)\n    g = GCD([a,b,c,d])\n    return a//g, b//g, c//g, d//g\n\ndef cross(a, b):\n    return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\ndef intersection_of_two_planes(p1, p2):\n    A1, B1, C1, D1 = p1\n    A2, B2, C2, D2 = p2\n#\n    crossprod = cross([A1,B1,C1],[A2,B2,C2])\n\n    if (A1*B2-A2*B1) != 0:\n        x = ((B1*D2-B2*D1)/(A1*B2-A2*B1), crossprod[0])\n        y = ((A2*D1-A1*D2)/(A1*B2-A2*B1), crossprod[1])\n        z = (0,crossprod[2])\n    elif (B1*C2-B2*C1) != 0:\n        x = (0,crossprod[0])\n        y = ((C1*D2-C2*D1)/(B1*C2-B2*C1), crossprod[1])\n        z = ((B2*D1-B1*D2)/(B1*C2-B2*C1), crossprod[2])\n    elif (A1*C2-A2*C1) != 0:\n        x = ((C1*D2-C2*D1)/(A1*C2-A2*C1), crossprod[0])\n        y = (0,crossprod[1])\n        z = ((A2*D1-A1*D2)/(A1*C2-A2*C1), crossprod[2])\n    else:\n        return None\n\n    return x, y, z\n\ndef line_parametric(p1, p2):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    return (x2,x1-x2), (y2,y1-y2), (z2,z1-z2)\n\ndef solve_2_by_2(row1, row2):\n    a1, b1, c1 = row1\n    a2, b2, c2 = row2\n    if a1*b2-b1*a2:\n        return (c1*b2-b1*c2)/(a1*b2-b1*a2), (a1*c2-c1*a2)/(a1*b2-b1*a2)\n    else:\n        return None\n\ndef sgn(x):\n    return 1 if x>0 else 0 if x==0 else -1\n\ndef lines_intersection_point(i1, i2):\n    x1, y1, z1 = i1\n    x2, y2, z2 = i2\n\n    try:\n        t1, t2 = solve_2_by_2([x1[1], -x2[1], x2[0]-x1[0]], [y1[1], -y2[1], y2[0]-y1[0]])\n        if abs(t1*z1[1] - t2*z2[1] - z2[0] + z1[0]) < EPS:\n            return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n        else:\n            return None\n    except:\n        try:\n            t1, t2 = solve_2_by_2([x1[1], -x2[1], x2[0]-x1[0]], [z1[1], -z2[1], z2[0]-z1[0]])\n            if abs(t1*y1[1] - t2*y2[1] - y2[0] + y1[0]) < EPS:\n                return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n            else:\n                return None\n        except:\n            try:\n                t1, t2 = solve_2_by_2([y1[1], -y2[1], y2[0]-y1[0]], [z1[1], -z2[1], z2[0]-z1[0]])\n                if abs(t1*x1[1] - t2*x2[1] - x2[0] + x1[0]) < EPS:\n                    return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n                else:\n                    return None\n            except:\n                return None\n\ndef foo(points):\n    down_cnt, up_cnt = 0, 0\n    first = points[0]\n    other = 1-first\n    down = True\n    intrusion = True\n    for p in points[1:]:\n        if p==first:\n            intrusion = not intrusion\n        else:\n            if intrusion:\n                if down:\n                    down_cnt+=1\n                else:\n                    up_cnt+=1\n            down = not down\n    return down_cnt==up_cnt\n\ndef populate(plane, poly, tag):\n    res = []\n    prev = plane_value(plane,poly[-1])\n    prev_serious = plane_value(plane,poly[-2]) if not prev else prev\n    p_prev = poly[-1]\n    for i in range(len(poly)+1):\n        p = poly[i%len(poly)]\n        curr = plane_value(plane,p)\n        if sgn(curr) == -sgn(prev_serious):\n            intersector = line_parametric(p_prev,p)\n            point, t = lines_intersection_point(intersector,intersectee)\n            res.append((t,tag))\n            prev_serious = curr\n        if sgn(curr):\n            prev_serious = curr\n        prev, p_prev = curr, p\n    return res\n\nx_poly, y_poly = [], []\n\nfor _ in range(inp()):\n    x_poly.append(inlt())\nfor _ in range(inp()):\n    y_poly.append(inlt())\n\nx_plane = plane(*x_poly[:3])\ny_plane = plane(*y_poly[:3])\n\nintersectee = intersection_of_two_planes(x_plane,y_plane)\n\nif intersectee:\n    points = sorted(set(populate(y_plane,x_poly,0) + populate(x_plane,y_poly,1)))\n    points = [i[1] for i in points]\n\n    print('NO' if foo(points) else 'YES')\nelse:\n    print('NO')\n", "from math import gcd, sqrt\nfrom functools import reduce\nimport sys\n\ninput = sys.stdin.readline\n\nEPS = 0.000000001\n\ndef inp():\n    return(int(input()))\n\ndef inlt():\n    return(list(map(int,input().split())))\n\ndef GCD(args):\n    return reduce(gcd, args)\n\ndef plane_value(plane, point):\n    A, B, C, D = plane\n    x, y, z = point\n    return A*x + B*y + C*z + D\n\ndef plane(p1, p2, p3):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    x3, y3, z3 = p3\n    a1, b1, c1 = x2 - x1, y2 - y1, z2 - z1\n    a2, b2, c2 = x3 - x1, y3 - y1, z3 - z1\n    a, b, c = b1 * c2 - b2 * c1, a2 * c1 - a1 * c2, a1 * b2 - b1 * a2\n    d = (- a * x1 - b * y1 - c * z1)\n    g = GCD([a,b,c,d])\n    return a//g, b//g, c//g, d//g\n\ndef cross(a, b):\n    return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\ndef intersection_of_two_planes(p1, p2):\n    A1, B1, C1, D1 = p1\n    A2, B2, C2, D2 = p2\n\n    crossprod = cross([A1,B1,C1],[A2,B2,C2])\n\n    if (A1*B2-A2*B1) != 0:\n        x = ((B1*D2-B2*D1)/(A1*B2-A2*B1), crossprod[0])\n        y = ((A2*D1-A1*D2)/(A1*B2-A2*B1), crossprod[1])\n        z = (0,crossprod[2])\n    elif (B1*C2-B2*C1) != 0:\n        x = (0,crossprod[0])\n        y = ((C1*D2-C2*D1)/(B1*C2-B2*C1), crossprod[1])\n        z = ((B2*D1-B1*D2)/(B1*C2-B2*C1), crossprod[2])\n    elif (A1*C2-A2*C1) != 0:\n        x = ((C1*D2-C2*D1)/(A1*C2-A2*C1), crossprod[0])\n        y = (0,crossprod[1])\n        z = ((A2*D1-A1*D2)/(A1*C2-A2*C1), crossprod[2])\n    else:\n        return None\n\n    return x, y, z\n\ndef line_parametric(p1, p2):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    return (x2,x1-x2), (y2,y1-y2), (z2,z1-z2)\n\ndef solve_2_by_2(row1, row2):\n    a1, b1, c1 = row1\n    a2, b2, c2 = row2\n    if a1*b2-b1*a2:\n        return (c1*b2-b1*c2)/(a1*b2-b1*a2), (a1*c2-c1*a2)/(a1*b2-b1*a2)\n    else:\n        return None\n\ndef sgn(x):\n    return 1 if x>0 else 0 if x==0 else -1\n\ndef lines_intersection_point(i1, i2):\n    x1, y1, z1 = i1\n    x2, y2, z2 = i2\n\n    try:\n        t1, t2 = solve_2_by_2([x1[1], -x2[1], x2[0]-x1[0]], [y1[1], -y2[1], y2[0]-y1[0]])\n        if abs(t1*z1[1] - t2*z2[1] - z2[0] + z1[0]) < EPS:\n            return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n        else:\n            return None\n    except:\n        try:\n            t1, t2 = solve_2_by_2([x1[1], -x2[1], x2[0]-x1[0]], [z1[1], -z2[1], z2[0]-z1[0]])\n            if abs(t1*y1[1] - t2*y2[1] - y2[0] + y1[0]) < EPS:\n                return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n            else:\n                return None\n        except:\n            try:\n                t1, t2 = solve_2_by_2([y1[1], -y2[1], y2[0]-y1[0]], [z1[1], -z2[1], z2[0]-z1[0]])\n                if abs(t1*x1[1] - t2*x2[1] - x2[0] + x1[0]) < EPS:\n                    return (x1[0]+t1*x1[1], y1[0]+t1*y1[1], z1[0]+t1*z1[1]), t2\n                else:\n                    return None\n            except:\n                return None\n\ndef foo(points):\n    down_cnt, up_cnt = 0, 0\n    first = points[0]\n    other = 1-first\n    down = True\n    intrusion = True\n    for p in points[1:]:\n        if p==first:\n            intrusion = not intrusion\n        else:\n            if intrusion:\n                if down:\n                    down_cnt+=1\n                else:\n                    up_cnt+=1\n            down = not down\n    return down_cnt==up_cnt\n\ndef populate(plane, poly, tag):\n    res = []\n    prev = plane_value(plane,poly[-1])\n    prev_serious = plane_value(plane,poly[-2]) if not prev else prev\n    p_prev = poly[-1]\n    for i in range(len(poly)+1):\n        p = poly[i%len(poly)]\n        curr = plane_value(plane,p)\n        if sgn(curr) == -sgn(prev_serious):\n            intersector = line_parametric(p_prev,p)\n            point, t = lines_intersection_point(intersector,intersectee)\n            res.append((t,tag))\n            prev_serious = curr\n        if sgn(curr):\n            prev_serious = curr\n        prev, p_prev = curr, p\n    return res\n\nx_poly, y_poly = [], []\n\nfor _ in range(inp()):\n    x_poly.append(inlt())\nfor _ in range(inp()):\n    y_poly.append(inlt())\n\nx_plane = plane(*x_poly[:3])\ny_plane = plane(*y_poly[:3])\n\nintersectee = intersection_of_two_planes(x_plane,y_plane)\n\nif intersectee:\n    points = sorted(set(populate(y_plane,x_poly,0) + populate(x_plane,y_poly,1)))\n    points = [i[1] for i in points]\n\n    print('NO' if foo(points) else 'YES')\nelse:\n    print('NO')\n", "def convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n \n \ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n \n \ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n \n \ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n \n \ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n \n \ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n \n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    u = [dot_product(vert, proj_dir) for vert in poly]\n \n    vr = dot_product(plain_point, plain_norm)\n \n    v = [dot_product(vert, plain_norm) for vert in poly]\n \n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n \n    return u_list\n \n \ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n \n \ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n \n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n \n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n \n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n \n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n \n \ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n \n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n \n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n \n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n \n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n \n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n \n \ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n \n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n \n    b_len, = [int(num) for num in input().split()]\n \n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n \n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n \n \ndef __starting_point():\n    run_from_console()\n__starting_point()", "\ndef convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n \n \ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n \n \ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n \n \ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n \n \ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n \n \ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n \n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n \n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n \n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n \n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n \n    return u_list\n \n \ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n \n \ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n \n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n \n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n \n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n \n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n \n \ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n \n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n \n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n \n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n \n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n \n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n \n \ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n \n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n \n    b_len, = [int(num) for num in input().split()]\n \n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n \n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n \n \ndef __starting_point():\n    run_from_console()\n\n__starting_point()"]
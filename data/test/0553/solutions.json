["n = int(input())\n\nm = 6\narr = []\nfor i in range(n):\n    arr.append(input())\n    \nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        d = 0\n        for z in range(6):\n            if arr[i][z] != arr[j][z]:\n                d += 1\n                \n        if d == 6:\n            m = min(m, 2)\n        elif d == 5:\n            m = min(m, 2)\n        elif d == 4:\n            m = min(m, 1)\n        elif d == 3:\n            m = min(m, 1)\n        else:\n            m = 0\n            \nprint(m)", "n = int(input())\ncodes = []\nfor i in range(n):\n    codes.append(input())\n\n\ndef change(a, b, k):\n    x = 0\n    for i in range(6):\n        if a[i] != b[i]:\n            x += 1\n        if x == k:\n            return 3\n    if x % 2 == 0:\n        return x // 2 - 1\n    return x // 2\n\nif n == 1:\n    print(6)\n    return\n\nk = 2\nfor i in range(n):\n    for j in range(i + 1, n):\n        if change(codes[i], codes[j], 2 * k + 1) < k:\n            k = change(codes[i], codes[j], 2 * k + 1)\n        if k == 0:\n            break\nprint(k)", "n = int(input())\ncodes = [input() for i in range(n)]\ndef dist(w1, w2):\n    assert len(w1) == len(w2)\n    d = 0\n    for i in range(len(w1)):\n        if w1[i] != w2[i]: d += 1\n    return max(0, (d-1)//2)\nd = 6\nfor i in range(n):\n    for j in range(i+1, n):\n        d = min(d, dist(codes[i], codes[j]))\nprint(d)\n", "\ncount = int(input())\n\nif count == 1:\n    print('6')\nelse:\n    hamming = 6\n    codes = []\n    for _ in range(count):\n        new_code = input()\n        for code in codes:\n            distance = 0\n            distance += 0 if new_code[0] == code[0] else 1\n            distance += 0 if new_code[1] == code[1] else 1\n            distance += 0 if new_code[2] == code[2] else 1\n            distance += 0 if new_code[3] == code[3] else 1\n            distance += 0 if new_code[4] == code[4] else 1\n            distance += 0 if new_code[5] == code[5] else 1\n\n            hamming = min(hamming, distance)\n\n        codes.append(new_code)\n\n    print(int(hamming/2 - 0.5))\n", "def func(a,b):\n    t = 0\n    for i in range(6):\n        if a[i] != b[i]:\n            \n            t+=1\n    return t\nn = int(input())\nA = [0] * n\nfor i in range(n):\n    A[i] = input()\nper = 10\nfor i in range(0, n-1):\n    for j in range(i+1, n):\n        per = min(per, func(A[i], A[j]))\nif n == 1:\n    print(6)\nelse:\n    \n    if per in (5,6):\n        print(2)\n    elif per in (3,4):\n        print(1)\n    elif per in (0,1,2):\n        print(0)", "n = int(input())\n\ns = [''] * (n)\nfor i in range(n):\n    s[i] = input()\n\nif (n == 1):\n    print(6)\nelse:\n    diff = 6\n    \n    for u in s:\n        for v in s:\n            kol = 0    \n            for i in range(6):\n                if u[i] != v[i]:\n                    kol += 1\n            if kol > 0:\n                diff = min(diff, kol)\n                \n    diff = max(0, diff - 1)\n    print(diff // 2)", "import sys\n\ndef distance(s, t):\n    ans = 0\n    for (x, y) in zip(s, t):\n        ans += (x != y)\n    return ans\n\ndef min_distance(n):\n    codes = [line.rstrip() for line in sys.stdin]\n    m = 6\n    for i in range(n):\n        for j in range(i+1, n):\n            d = distance(codes[i], codes[j])\n            if m > d:\n                m = d\n                if d < 3:\n                    return 1\n    return m\n\nn = int(input())\nif n == 1:\n    print(6)\nelse:\n    print((min_distance(n) + 1) // 2 - 1)\n", "3\n\ndef dist(str1, str2):\n\tk = 0\n\tfor i in range(6):\n\t\tif str1[i] != str2[i]:\n\t\t\tk += 1\n\n\treturn k\n\ndef solve(promos):\n\tn = len(promos)\n\n\tdist_list = [0,0,0,1,1,2,2]\n\tmin_k = 6\n\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\td = dist(promos[i], promos[j])\n\n\t\t\tk = dist_list[d]\n\t\t\tif k < min_k: min_k = k\n\t\t\tif k == 0: break\n\n\treturn min_k\n\n\ndef test():\n\timport random\n\timport string\n\timport time\n\n\twhile True:\n\t\tn = 1000\n\t\tpromos = []\n\t\tfor i in range(n):\n\t\t\tpromo = ''.join([random.choice(string.digits) for i in range(6)])\n\t\t\tpromos.append(promo)\n\n\t\tif len(set(promos)) == n:\n\t\t\tbreak\n\n\tstart = time.clock()\n\tk = solve(promos)\n\tprint(k)\n\tend = time.clock()\n\n\tprint('Time: {} sec'.format(end-start))\n\n\ndef main():\n\tn = int(input())\n\tpromos = [None]*n\n\tfor i in range(n):\n\t\tpromos[i] = input()\n\n\tk = solve(promos)\n\n\tprint(k)\n\n\ndef __starting_point():\n\t# test()\n\tmain()\n\n__starting_point()", "n = int(input())\narr = []\nfor i in range(n):\n    line = int(input())\n    arr.append(line)\nm = 6\nfor i in range(n):\n    for j in range(i+1, n):\n        t1 = arr[i]\n        t2 = arr[j]\n        tm = 0\n        for k in range(6):\n            if t1 % 10 != t2 % 10: tm += 1\n            t1 //= 10\n            t2 //= 10\n        if tm < m: m = tm\nif m % 2 == 0: m -= 1\nm //= 2\nif m < 0: m = 0\nif n == 1: m = 6\nprint(m)\n\n", "def cmp(o1, o2):\n    result = 0\n    for i in range(6):\n        if o1[i] != o2[i]:\n            result += 1\n    return result\n\ncount = int(input())\nlst = []\nfor i in range(count):\n    lst += [str(input())]\nif count == 1:\n    print(6)\n    return\n\ndiv = 6\nfor n in range(1, count):\n    for i in range(n-1, -1, -1):\n        div = min(div, cmp(lst[n], lst[i]))\n        if div <= 2:\n            print(0)\n            return\nif div >= 5:\n    print(2)\nelif div >= 3:\n    print(1)\n\n", "# import time\n# start = time.time()\nn = int(input())\ncodes = [input() for i in range(n)]\nmindist = 6\nfor i in range(n-1):\n    for j in range(i+1, n):\n        d = sum([x!=y for x,y in zip(codes[i], codes[j])])\n        # for k in range(6):\n            # d += codes[i][k] != codes[j][k]\n        if mindist > d:\n            mindist = d\nif (n == 1):\n    print(6)\nelse:\n    print(max(0, (mindist-1)//2))\n# print(time.time()-start)\n# print(mindist)\n", "n = int(input())\ncodes = [tuple(input()) for i in range(n)]\nmind = 13 #Dirty hack for n=1\nfor i in range(n-1):\n    for j in range(i+1, n):\n        d = sum(x!=y for x,y in zip(codes[i], codes[j]))\n        if d<mind:\n            mind = d\nprint((mind-1)//2)", "import operator\nimport itertools\nn = int(input())\nstrings = [input() for i in range(n)]\nif n == 1:\n   print(6)\nelse:\n   minDiff = 6;\n   for a, b in itertools.combinations(strings, 2):\n      minDiff = min(minDiff, list(map(operator.eq, a, b)).count(False))\n   print(int((minDiff - 1) / 2))", "import math\ndef fnd(a,m,key):  #next\n    f1=[0,1][key]\n    f2=[lambda m:math.floor(m),lambda m:math.ceil(m)][key]\n    if type(m)==int:\n        return -1\n    if m[0] > a:\n        return -1\n    if m[-1] < a:\n        return -1\n    if len(m)== 2:\n        return(m[f1])\n\n    r= list([m for m in [fnd(a,m[len(m)//2:],key),fnd(a,m[:len(m)//2+1],key)] if m!= -1])\n    if len(r) == 0:\n        return m[f2(len(m)/2)]\n    return r[0]\n\ndef F(a,m,key=True):\n    if (m[0] > a) and key: return m[0]\n    if (m[-1] < a) and not key: return m[-1]\n    return fnd(a,m,key)\n\ndef distance(a, b):\n    c=0\n    for i in range(len(a)):\n        if a[i]!=b[i]:\n            c+=1\n    return c\nn=int(input())\npromos=[]\nfor i in range(n):\n    promos+=[input()]\nif  len(promos) == 1:\n    print(6)\n    return\n#print([(x,y) for x in promos for y in promos if x!=y])\na=min([distance(promos[x],promos[y]) for x in range(len(promos)) for y in range(x+1,len(promos))])\nr=[x for x in range(a+1) if x != a/2]\nprint(F(a/2,r,False))\n", "def main():\n    n, l, k = int(input()), [], 0\n    if n < 2:\n        print(6)\n        return\n    for _ in range(n):\n        a = input()\n        for b in l:\n            x = sum(u == v for u, v in zip(a, b))\n            if k < x:\n                k = x\n                if k > 4:\n                    print(0)\n                    return\n        l.append(a)\n    print(2 - k // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from operator import eq\n    n, l, k = int(input()), [], 0\n    if n < 2:\n        print(6)\n        return\n    for _ in range(n):\n        a = input()\n        for b in l:\n            x = sum(map(eq, a, b))\n            if k < x:\n                k = x\n                if k > 4:\n                    print(0)\n                    return\n        l.append(a)\n    print(2 - k // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from operator import eq\n    n, l, k = int(input()), [], 0\n    if n < 2:\n        print(6)\n        return\n    for _ in range(n):\n        a = tuple(input())\n        for b in l:\n            x = sum(map(eq, a, b))\n            if k < x:\n                k = x\n                if k > 4:\n                    print(0)\n                    return\n        l.append(a)\n    print(2 - k // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nl=[input() for i in range(n)]\ndef d(a,b): return sum(1 for k in range(6) if l[a][k]!=l[b][k])-1\nprint(min({d(i,j) for i in range(n) for j in range(i+1,n)}|{12})//2)", "n=int(input())\nl=[input() for i in range(n)]\nprint(min([sum(1 for k in range(6) if l[i][k]!=l[j][k])-1 for i in range(n) for j in range(i+1,n)]+[12])//2)", "n=int(input())\nl=[input() for i in range(n)]\nprint(min([sum(a!=b for a,b in zip(l[i],l[j]))-1 for i in range(n) for j in range(i+1,n)]+[12])//2)", "n=int(input())\nl=[input() for i in range(n)]\nprint(min([sum(a!=b for a,b in zip(l[i],l[j]))-1 for i in range(n) for j in range(i+1,n)]+[12])//2)", "n=int(input())\nl=[];s=12\nfor i in range(n):\n y=input()\n s=min({sum(a!=b for a,b in zip(x,y))-1 for x in l}|{s})\n l+=[y]\nprint(s//2)", "l=[];s=12\nfor i in range(int(input())):\n y=input()\n s=min({sum(a!=b for a,b in zip(x,y))-1 for x in l}|{s})\n l+=[y]\nprint(s//2)", "l=[];s=12\nfor i in range(int(input())):\n y=input()\n s=min({sum(a!=b for a,b in zip(x,y))-1 for x in l}|{s})\n l+=[y]\nprint(s//2)"]
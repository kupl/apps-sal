["import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n\tfact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n\tinv.append(P - P // i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n\tinv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n\tif least_div[p] == -1:\n\t\tprimes.append(p)\n\t\tleast_div[p] = p\n\tldiv = least_div[p]\n\tfor mult in primes:\n\t\tmark = mult * p\n\t\tif (mult > ldiv) or (mark >= N):\n\t\t\tbreak\n\t\tleast_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\nmemo_factor = dict()\n\ndef factor(n):\n\tif n in memo_factor:\n\t\treturn memo_factor[n]\n\tret = []\n\twhile n != 1:\n\t\ttmp = least_div[n]\n\t\tif not(ret and ret[-1] == tmp):\n\t\t\tret.append(tmp)\n\t\tn //= tmp\n\tmemo_factor[n] = ret\n\treturn ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n\tdivs = factor(n)\n\t# print(divs)\n\tret = 0\n\tfor subset in powerset(divs):\n\t\tdiv = functools.reduce(operator.mul, subset, 1)\n\t\t# print(div, f(n // div, k))\n\t\tif n // div >= k:\n\t\t\ttmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\n\t\t\tret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n\t\t\tret %= P\n\treturn ret\n\nfor _ in range(t):\n\tn, k = list(map(int, input().split()))\n\tprint(solve(n, k))\n", "import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n\tfact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n\tinv.append(P - P // i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n\tinv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n\tif least_div[p] == -1:\n\t\tprimes.append(p)\n\t\tleast_div[p] = p\n\tldiv = least_div[p]\n\tfor mult in primes:\n\t\tmark = mult * p\n\t\tif (mult > ldiv) or (mark >= N):\n\t\t\tbreak\n\t\tleast_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\n@functools.lru_cache(maxsize = None)\ndef factor(n):\n\tret = []\n\twhile n != 1:\n\t\ttmp = least_div[n]\n\t\tif not(ret and ret[-1] == tmp):\n\t\t\tret.append(tmp)\n\t\tn //= tmp\n\treturn ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n\tdivs = factor(n)\n\t# print(divs)\n\tret = 0\n\tfor subset in powerset(divs):\n\t\tdiv = functools.reduce(operator.mul, subset, 1)\n\t\t# print(div, f(n // div, k))\n\t\tif n // div >= k:\n\t\t\ttmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\n\t\t\tret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n\t\t\tret %= P\n\treturn ret\n\nfor _ in range(t):\n\tn, k = list(map(int, input().split()))\n\tprint(solve(n, k))\n", "import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n\tfact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n\tinv.append(P - P // i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n\tinv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n\tif least_div[p] == -1:\n\t\tprimes.append(p)\n\t\tleast_div[p] = p\n\tldiv = least_div[p]\n\tfor mult in primes:\n\t\tmark = mult * p\n\t\tif (mult > ldiv) or (mark >= N):\n\t\t\tbreak\n\t\tleast_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\n@functools.lru_cache(maxsize = None)\ndef factor(n):\n\tret = []\n\twhile n != 1:\n\t\ttmp = least_div[n]\n\t\tif not(ret and ret[-1] == tmp):\n\t\t\tret.append(tmp)\n\t\tn //= tmp\n\treturn ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n\tdivs = factor(n)\n\t# print(divs)\n\tret = 0\n\tfor subset in powerset(divs):\n\t\tdiv = functools.reduce(operator.mul, subset, 1)\n\t\t# print(div, f(n // div, k))\n\t\tif n // div >= k:\n\t\t\ttmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\n\t\t\tret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n\t\t\tret %= P\n\treturn ret\n\nfor _ in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))", "import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n\tfact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n\tinv.append(P - P // i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n\tinv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n\tif least_div[p] == -1:\n\t\tprimes.append(p)\n\t\tleast_div[p] = p\n\tldiv = least_div[p]\n\tfor mult in primes:\n\t\tmark = mult * p\n\t\tif (mult > ldiv) or (mark >= N):\n\t\t\tbreak\n\t\tleast_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\n@functools.lru_cache(maxsize = None)\ndef factor(n):\n\tret = []\n\twhile n != 1:\n\t\ttmp = least_div[n]\n\t\tif not(ret and ret[-1] == tmp):\n\t\t\tret.append(tmp)\n\t\tn //= tmp\n\treturn ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n\tdivs = factor(n)\n\t# print(divs)\n\tret = 0\n\tfor subset in powerset(divs):\n\t\tdiv = functools.reduce(operator.mul, subset, 1)\n\t\t# print(div, f(n // div, k))\n\t\tif n // div >= k:\n\t\t\ttmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\n\t\t\tret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n\t\t\tret %= P\n\treturn ret\n\nfor _ in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))"]
["import sys\nsys.setrecursionlimit(1000000000)\ninput = sys.stdin.readline\nn,w=map(int,input().split())\nknap=[[] for i in range(4)]\nw0,v=map(int,input().split())\nknap[0].append(v)\nfor i in range(n-1):\n    W,v=map(int,input().split())\n    knap[W-w0].append(v)\nfor i in range(4):\n    knap[i].sort(reverse=1)\n    knap[i]=[0]+knap[i]\nfor i in range(4):\n    for j in range(1,len(knap[i])):\n        knap[i][j]+=knap[i][j-1]\nans=0\nfor a in range(len(knap[0])):\n    for b in range(len(knap[1])):\n        for c in range(len(knap[2])):\n            for d in range(len(knap[3])):\n                if w0*a+(w0+1)*b+(w0+2)*c+(w0+3)*d<=w:\n                    ans=max(ans,knap[0][a]+knap[1][b]+knap[2][c]+knap[3][d])\nprint(ans)", "n,w = list(map(int,input().split()))\npack_list = [list(map(int,input().split())) for _  in range(n)]\n\n# dp = [[float('inf') for _ in range(10**7+1)] for _ in range(n+1)]\n# dp[0] = [0 for _ in range(10**7+1)]\n\ndp_dict = {0: {0:0}} # w,v\n\n'''\nfor i,pack in enumerate(pack_list):\n    for value,weight in enumerate(dp[i]):\n        dp[i+1][value] = min(dp[i][value],dp[i+1][value])\n        dp[i+1][value+pack[1]] = min(dp[i+1][value+pack[1]],dp[i][value]+pack[0])\n\nfor i,num in enumerate(dp[-1][::-1]):\n    if num <= w:\n        print(10**7-i)'''\n\nfor i,pack in enumerate(pack_list):\n    i += 1\n    if i not in dp_dict:\n        dp_dict[i] = {}\n    for weight,v in list(dp_dict[i-1].items()):\n        if weight not in dp_dict[i]:\n            dp_dict[i][weight] = v\n        else:\n            dp_dict[i][weight] = max(dp_dict[i][weight],v)\n        if weight+pack[0] <= w:\n            if weight+pack[0] not in dp_dict[i]:\n                dp_dict[i][weight+pack[0]] = v+pack[1]\n            else:\n                dp_dict[i][weight+pack[0]] = max(dp_dict[i][weight+pack[0]],v+pack[1])\n\ntarget = dp_dict[n]\nmax_num = 0\n\nfor k,v in list(target.items()):\n    if k <= w:\n        max_num = max(max_num,v)\n\nprint(max_num)\n\n", "n,w=list(map(int,input().split()))\nwv=[tuple(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "N, W = map(int, input().split())\ndata = tuple(tuple(map(int, input().split())) for _ in range(N))\ntable = [dict() for _ in range(N + 1)]\ntable[0][0] = 0\nfor n in range(N):\n    weight, value = data[n]\n    for w, now in table[n].items():\n        table[n + 1][w] = max(table[n + 1].get(w, 0), now)\n        if w + weight <= W:\n            table[n + 1][w + weight] = max(table[n + 1].get(w + weight, 0), now + value)\nprint(max(table[N].values()))", "# Simple Knapsack\nN, W = map(int, input().split())\nd = {i: [] for i in range(0, 4)}\nfor i in range(N):\n    w, v = map(int, input().split())\n    if i == 0:\n        w0 = w\n    d[w-w0].append(v)\n\nfor i in range(4):\n    cum = [0]\n    d[i].sort(reverse=True)\n    for j in d[i]:\n        cum.append(cum[-1] + j)\n    d[i] = cum[::]\n\n\nans = 0\nfor i in range(len(d[3])):\n    v3_sum = d[3][i]\n    w3_sum = (w0+3)*i\n    for j in range(len(d[2])):\n        v2_sum = d[2][j]\n        w2_sum = (w0+2)*j\n        for k in range(len(d[1])):\n            v1_sum = d[1][k]\n            w1_sum = (w0+1)*k\n\n            rest = W - (w1_sum + w2_sum + w3_sum)\n            if rest < 0:\n                continue\n            l = min(rest // w0, len(d[0])-1)\n            v0_sum = d[0][l]\n \n            ans = max(ans, v0_sum + v1_sum + v2_sum + v3_sum)\n\nprint(ans) ", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=10000000000\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x[z].append(v_sub)\nfor i in range(4):\n    x[i].sort(key=lambda x:-x)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "N,W = map(int,input().split())\n\nw1,v1 = map(int,input().split())\nstuff = [[] for _ in range(4)]\nstuff[0].append(v1)\n\nfor _ in range(N-1):\n    w,v = map(int,input().split())\n    stuff[w-w1].append(v)\n\nfor i in stuff:\n    i.sort(reverse=True)\n\nans = 0\n\nfor a in range(len(stuff[0])+1):\n    for b in range(len(stuff[1])+1):\n        for c in range(len(stuff[2])+1):\n            for d in range(len(stuff[3])+1):\n\n                if a*w1+b*(w1+1)+c*(w1+2)+d*(w1+3) <= W:\n                    ans = max(ans,sum(stuff[0][:a])+sum(stuff[1][:b])+sum(stuff[2][:c])+sum(stuff[3][:d]))\n\nprint(ans)", "N, W = map(int, input().split())\nwv = []\nw0 = []\nw1 = []\nw2 = []\nw3 = []\nfor i in range(N):\n    wv.append(list(map(int, input().split())))\nwv.sort(key=lambda x:(x[0], -x[1]))\n\nwbase = wv[0][0]\nfor w, v in wv:\n    if(w == wbase):\n        w0.append(v)\n    elif(w == wbase+1):\n        w1.append(v)\n    elif(w == wbase+2):\n        w2.append(v)\n    else:\n        w3.append(v)\n        \nsw0, sw1, sw2, sw3 = [0], [0], [0], [0]\ns = 0\nfor v in w0:\n    s += v\n    sw0.append(s)\ns = 0\nfor v in w1:\n    s += v\n    sw1.append(s)\ns = 0\nfor v in w2:\n    s += v\n    sw2.append(s)\ns = 0\nfor v in w3:\n    s += v\n    sw3.append(s)\n    \nvalue = 0\nans = 0\nfor i in range(len(sw0)):\n    if(wbase*i > W):\n        break\n    for j in range(len(sw1)):\n        if(wbase*i+(wbase+1)*j > W):\n            break\n        for k in range(len(sw2)):\n            if(wbase*i+(wbase+1)*j+(wbase+2)*k > W):\n                break\n            for l in range(len(sw3)):\n                if(wbase*i+(wbase+1)*j+(wbase+2)*k+(wbase+3)*l > W):\n                    break\n                value = sw0[i]+sw1[j]+sw2[k]+sw3[l]\n                ans = max(ans, value)        \nprint(ans)          ", "n,w = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[] for _ in range(4)]\nfor i,j in a:\n    b[i-a[0][0]].append(j)\nfor i in range(4):\n    b[i].sort()\n    b[i].reverse()\nfor i in range(4):\n    for j in range(1,len(b[i])):\n        b[i][j] += b[i][j-1]\n    b[i].reverse()\n    b[i].append(0)\n    b[i].reverse()\n#print(b)\nans = 0\nfor i in range(len(b[0])):\n    for j in range(len(b[1])):\n        for k in range(len(b[2])):\n            for l in range(len(b[3])):\n                #print(i,j,k,l)\n                if a[0][0]*i+(a[0][0]+1)*j+(a[0][0]+2)*k+(a[0][0]+3)*l <= w:\n                    #print(i,j,k,l)\n                    ans = max(ans, b[0][i]+b[1][j]+b[2][k]+b[3][l])\nprint(ans)", "N, W = map(int, input().split())\nw_v = [list(map(int, input().split())) for i in range(N)]\n\nmemo = {}\n\ndef  nap(i, j):\n    if i == N:\n        return 0\n\n    if (i, j) in memo:\n        return memo[i, j]\n    elif w_v[i][0] > j:\n        temp = nap(i+1, j)\n    else:\n        temp = max(nap(i+1, j), nap(i+1, j-w_v[i][0]) + w_v[i][1])\n    memo[i, j] = temp\n\n    return memo[i, j]\n\nprint(nap(0, W))", "N, W = map(int, input().split())\n\nvalue_table = [[] for i in range(4)]\nfor i in range(N):\n    w, v = map(int,input().split())\n    if i == 0:\n        w1 = w\n    value_table[w-w1] += [v]\n\n[value_table[i].sort(reverse=True) for i in range(4)]\n\nans = 0\nvalue_table_ruiseki = [[0] for i in range(4)]\nfor i in range(4):\n    for v in value_table[i]:\n        value_table_ruiseki[i] += [value_table_ruiseki[i][-1] + v]\n\nans = 0\nfor i, iv in enumerate(value_table_ruiseki[0]):\n    for j, jv in enumerate(value_table_ruiseki[1]):\n        for k, kv in enumerate(value_table_ruiseki[2]):\n            for ell, ellv in enumerate(value_table_ruiseki[3]):\n                weight = i*w1 + j*(w1+1) + k*(w1+2) + ell*(w1+3)\n                value = iv + jv + kv + ellv\n                if weight <=W:\n                    ans = max(ans, value)\n\nprint(ans)", "N, W = map(int, input().split())\n\nW1,V1 = map(int, input().split())\n\nP = {W1:[V1], W1+1:[], W1+2:[], W1+3:[]}\n\nfor i in range(1,N):\n  w,v = map(int, input().split())\n  P[w].append(v)\n\nPS={}\nfor k,v in P.items():\n  v.sort(reverse=True)\n  S = [0] * (len(v)+1)\n  for i in range(len(v)):\n    S[i+1] = S[i] + v[i]\n  PS[k] = S\n  \n#print(P)\n#print(PS)\nA,B,C,D = len(PS[W1]), len(PS[W1+1]), len(PS[W1+2]), len(PS[W1+3])\nans = 0\nfor a in range(A):\n  for b in range(B):\n    for c in range(C):\n      for d in range(D):\n        if a*W1 + b*(W1+1) + c*(W1+2) + d*(W1+3) > W:\n          continue\n        ans = max(ans, PS[W1][a] + PS[W1+1][b] + PS[W1+2][c] + PS[W1+3][d])\n        \nprint(ans)", "import sys\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, W, *WV = list(map(int, read().split()))\n    weight = WV[::2]\n    value = WV[1::2]\n\n    w_min = min(weight)\n    items = [[] for _ in range(4)]\n    for w, v in zip(weight, value):\n        items[w - w_min].append(v)\n\n    for i in range(4):\n        items[i].sort(reverse=True)\n\n    csums = [0] * 4\n    for i in range(4):\n        csums[i] = [0]\n        csums[i].extend(accumulate(items[i]))\n\n    def rec(i, w, v):\n        if i == 4:\n            if w <= W:\n                return v\n            else:\n                return -1\n        ans = 0\n        for j in range(len(csums[i])):\n            ans = max(ans, rec(i + 1, w + (w_min + i) * j, v + csums[i][j]))\n\n        return ans\n\n    print((rec(0, 0, 0)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nn, W = list(map(int, input().split()))\ndd = defaultdict(list)\nfor i in range(n):\n    weight, value = list(map(int, input().split()))\n    dd[weight].append(value)\n\na = min(dd.keys())\nb, c, d = a+1, a+2, a+3\nVcum = defaultdict(lambda: [0])\nfor k in [a, b, c, d]:\n    s = 0\n    dd[k].sort(reverse=True)\n    for val in dd[k]:\n        s += val\n        Vcum[k].append(s)\n\nans = 0\nfor w in range(len(dd[a])+1):\n    for x in range(len(dd[b])+1):\n        for y in range(len(dd[c])+1):\n            if W < a*w+b*x+c*y:\n                break\n            z = min((W-a*w-b*x-c*y)//d, len(dd[d]))\n            val = Vcum[a][w]+Vcum[b][x]+Vcum[c][y]+Vcum[d][z]\n            ans = max(ans, val)\nprint(ans)\n", "import numpy as np\nfrom itertools import product\nfrom collections import  defaultdict as dd\nN, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(N)]\nwi = wv[0][0]\nvi = wv[0][1]\ndic = dd(list)\ndic_cumsum = dd(list)\nfor w,v in wv:\n    dic[w].append(v)\n\nfor k,v in list(dic.items()):\n    tmp = sorted(v, reverse=True)\n    dic_cumsum[k] = [0] + list(np.zeros((N + 1), dtype=np.int64))\n    dic_cumsum[k][1:] = list(np.cumsum(tmp, dtype=np.int64))\nfor i in range(1,4):\n    if wi+i not in list(dic_cumsum.keys()):\n        dic_cumsum[wi+i] = [0]\n        \nn = [len(dic_cumsum[wi]), len(dic_cumsum[wi+1]), len(dic_cumsum[wi+2]), len(dic_cumsum[wi+3])]\nm = [list(range(val)) for val in n]\nres = 0\n\nfor ls in product(m[0], m[1], m[2]):\n    if sum(ls)*wi > W:\n        continue\n    tmp_value = 0\n    tmp_weight = 0\n    for i,k in enumerate(ls):\n        tmp_value += dic_cumsum[wi + i][k]\n        tmp_weight += k*(wi+i)\n    if tmp_weight > W:\n        continue\n    # wi, wi+1, wi+2\u306e\u500b\u6570\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001wi+3\u3092\u4f55\u500b\u53d6\u308c\u308b\u304b\u306fO(1)\u3067\u6c42\u3081\u3089\u308c\u308b\n    max_m3 = (W - tmp_weight) // (wi+3)\n    m3 = min(max_m3, n[3]-1)\n    tmp_value += dic_cumsum[wi+3][m3]\n    if tmp_value > res:\n        res = tmp_value\nprint(res)\n\n\n", "N,W = map(int,input().split())\nw1,v1 = map(int,input().split())\nd = [[-v1],[],[],[]]\nfor i in range(N-1):\n    w,v = map(int,input().split())\n    x = w - w1\n    d[x].append(-v)\nd[0].sort()\nn0 = len(d[0])\nd[1].sort()\nn1 = len(d[1])\nd[2].sort()\nn2 = len(d[2])\nd[3].sort()\nn3 = len(d[3])\ns0 = [0]\ns1 = [0]\ns2 = [0]\ns3 = [0]\nfor i in range(n0):\n    x = s0[-1] + d[0][i]\n    s0.append(x)\nfor i in range(n1):\n    x = s1[-1] + d[1][i]\n    s1.append(x)\nfor i in range(n2):\n    x = s2[-1] + d[2][i]\n    s2.append(x)\nfor i in range(n3):\n    x = s3[-1] + d[3][i]\n    s3.append(x)\nd = [[[[0 for i in range(n3+1)] for j in range(n2+1)] for k in range(n1+1)] for l in range(n0+1)]\nfor i in range(n0+1):\n    for j in range(n1+1):\n        for k in range(n2+1):\n            for l in range(n3+1):\n                s = s0[i] + s1[j] + s2[k] + s3[l]\n                s = -s\n                x = w1*(i+j+k+l) + j + 2*k + 3*l\n                if x <= W:\n                    d[i][j][k][l] = s\nans = 0\nfor i in range(n0+1):\n    for j in range(n1+1):\n        for k in range(n2+1):\n            for l in range(n3+1):\n                x = d[i][j][k][l]\n                ans = max(ans,x)\nprint(ans)", "N, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(N)]\nmw = wv[0][0]\nwv.sort(key=lambda x: -x[1])\nvalues = [[] for _ in range(4)]\nfor w, v in wv:\n    values[w-mw].append(v)\n\n\ndef solve(n, w, c):\n    if n >= 4 or w >= W or c >= N:\n        return 0\n    r = 0\n    for i in range(len(values[n])+1):\n        cw = w + (mw + n) * i\n        cc = c + i\n        if cw <= W and cc <= N:\n            r = max(r, sum(values[n][0:i]) + solve(n+1, cw, cc))\n    return r\n\n\nprint((solve(0, 0, 0)))\n", "n,W=list(map(int,input().split()))\nwv=[list(map(int,input().split()))]\nw0=wv[0][0]-1\nwv[0][0]=1\n# \u3059\u3079\u3066\u306ew\u304b\u3089w0\u3092\u5f15\u304f\nfor _ in range(n-1):\n  w,v=list(map(int,input().split()))\n  wv.append([w-w0,v])\nimport numpy as np\ndp=np.full((n+1,401),0,int)\n# dp[k][w]:k\u500b\u3067\u91cd\u3055w\u3067\u306e\u6700\u5927\u4fa1\u5024\ndp[0]=0\nfor w,v in wv:\n  for i in range(n):\n    dp[n-i][w:]=np.maximum(dp[n-i][w:],dp[n-i-1][:-w]+v)\nans=0\nfor i in range(1,n+1):\n  if W-i*w0<=0:break\n  ans=max(ans,dp[i][min(W-i*w0,400)])\nprint(ans)\n\n", "from collections import *\nN,W = map(int,input().split())\ndp = defaultdict(int)\ndp[0] = 0\n\nfor n in range(N):\n  w1,v1 = map(int,input().split())\n  for w2,v2 in dp.copy().items():\n    if w1+w2<=W:\n      dp[w1+w2] = max(dp[w1+w2],v1+v2)\n\nprint(max(dp.values()))", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, W = MAP()\nwv = [LIST() for _ in range(N)]\nw0 = wv[0][0]\n\ndic = defaultdict(list)\nfor w, v in wv:\n\tdic[w].append(v)\n\nfor key in dic:\n\tdic[key].sort(reverse=True)\n\tdic[key] = [0] + dic[key]\n\tdic[key] = list(accumulate(dic[key]))\n\nfor x in [w0, w0+1, w0+2, w0+3]:\n\tif not dic[x]:\n\t\tdic[x] = [0]\n# print(dic)\n\nans = 0\nfor a in range(len(dic[w0])):\n\tfor b in range(len(dic[w0+1])):\n\t\tfor c in range(len(dic[w0+2])):\n\t\t\tfor d in range(len(dic[w0+3])):\n\t\t\t\tw = w0*a + (w0+1)*b + (w0+2)*c + (w0+3)*d\n\t\t\t\ts = dic[w0][a] + dic[w0+1][b] + dic[w0+2][c] + dic[w0+3][d]\n\t\t\t\tif w <= W:\n\t\t\t\t\tans = s if ans < s else ans\nprint(ans)\n", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=1000000001\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x[z].append(v_sub)\nfor i in range(4):\n    x[i].sort(key=lambda x:-x)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    d=w-i*(w0+3)\n    if d>=0:\n        for j in range(l2):\n            d=w-i*(w0+3)-j*(w0+2)\n            if d>=0:\n                for k in range(l1):\n                    d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                    if d>=0:\n                        ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                    else:\n                        break\n            else:\n                break\n    else:\n        break\n\n\nprint(ma)\n", "N, W = map(int, input().split())\nItems = [tuple(map(int, input().split())) for _ in range(N)]\nfrom collections import defaultdict as dd\nBag = dd(lambda:0)\nBag[0] = 0\nfor w,v in Items:\n    temp = [(key+w,Bag[key]+v) for key in Bag if key + w <= W]\n    for key,value in temp:\n        Bag[key] = max(Bag[key],value)\nans = max(Bag.values())\nprint(ans)", "# coding: utf-8\n# hello world\u3068\u8868\u793a\u3059\u308b\n#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial,sqrt\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n\nn,w=MI()\nlis=[LI() for i in range(n)]\nu=lis[0][0]\nvals=[[] for i in range(4)]\nfor i in range(n):\n    if lis[i][0]==u:\n        vals[0].append(lis[i][1])\n    elif lis[i][0]==u+1:\n        vals[1].append(lis[i][1])\n    elif lis[i][0]==u+2:\n        vals[2].append(lis[i][1])\n    else:\n        vals[3].append(lis[i][1])\n#print(vals)\nfor i in range(4):\n    vals[i].sort(reverse=True)\n    vals[i]=list(accumulate(vals[i]))\n    vals[i]=[0]+vals[i]\nmx=0\n#print(vals)\nfor i in range(len(vals[0])):\n    for j in range(len(vals[1])):\n        for k in range(len(vals[2])):\n            for l in range(len(vals[3])):\n                if u*i+(u+1)*j+(u+2)*k+(u+3)*l>w:\n                    continue\n                V=vals[0][i]+vals[1][j]+vals[2][k]+vals[3][l]\n                if V>mx:\n                    mx=V\nprint(mx)\n            \n        \n\n    \n\n        \n        \n        \n            \n        \n\n                \n", "n,W = map(int,input().split())\n\ndp = [[[0]*(3*n+1) for _ in range(n)] for _ in range(n)]\n\nw1,v1 = map(int,input().split())\nfor i in range(3*n+1):\n    dp[0][0][i] = v1\n\nfor i in range(1,n):\n    w,v = map(int,input().split())\n    w -= w1\n    for j in range(min(i+1,n)):\n        for k in range(3*(j+1)+1):\n            if j>0 and k>=w:\n                dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-w] + v)\n            elif k>=w:\n                dp[i][0][k] = max(dp[i-1][0][k], v)\n            else:\n                dp[i][j][k] = dp[i-1][j][k]\n\nans = 0\nfor i in range(n):\n    for j in range(3*n+1):\n        if w1*(i+1) + j>W: continue\n        ans = max(ans,dp[-1][i][j])\n\nprint(ans)", "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, W = [int(x) for x in input().split()]\n    WV = [[int(x) for x in input().split()] for _ in range(N)]\n\n    weight = set()\n    weight.add(0)\n    weight.add(WV[0][0])\n    for i in range(1, N + 1):\n        for j in range(3 * i):\n            weight.add(WV[0][0] * i + j)\n\n    weight = sorted(list(weight))\n\n    dp = defaultdict(int)\n\n    for i in range(N):\n        for j in weight[::-1]:\n            if j >= WV[i][0]:\n                dp[j] = max(dp[j], dp[j - WV[i][0]] + WV[i][1])\n\n    ans = 0\n    for i in weight:\n        if i > W:\n            break\n        ans = max(ans, dp[i])\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nimport numpy as np\n\ndef main():\n    def itrsum(arr):\n        n=len(arr)\n        tri=np.array([[i>=j for i in range(n)] for j in range(n+1)])\n        return np.dot(tri,arr).astype('int64')\n    n,w=list(map(int,stdin.readline().strip().split()))\n    t=[list(map(int,stdin.readline().strip().split())) for _ in range(n)]\n    w1=t[0][0]\n    # arr=[sorted([x for x in t if x[0]==w1+i],reverse=True,key=lambda e:e[1]) for i in range(4)]\n    arr=[[x for x in t if x[0]==w1+i] for i in range(4)]\n    arr=[l for l in arr]\n    lenarr=list(map(len,arr))\n    arr0=[itrsum(np.array(sorted([x[0] for x in l]),dtype='int64')) for l in arr]\n    arr1=[itrsum(np.array(sorted([x[1] for x in l]),dtype='int64')) for l in arr]\n    # arr=[x.sort(reverse=True,key=lambda e:e[1]) for x in arr]\n    arr=np.array(arr)\n    arrw=0\n    arrv=0\n    for i in range(4):\n        arrw=np.ravel(arr0[i].reshape(lenarr[i]+1,1)+np.array([arrw]))\n        arrv=np.ravel(arr1[i].reshape(lenarr[i]+1,1)+np.array([arrv]))\n    #print(arr0)\n    #print(arr1)\n    #print('\\n')\n    #print(arrw)\n    #print(arrv)\n    #print(arrv[arrw<=w])\n    ansarr=arrv[arrw<=w]\n    print((np.max(ansarr)))\n    # wts=list(map(lambda l:l[0]-w1-1, t))\n    # val=list(map(lambda l:l[1], t))\n\ndef __starting_point():\n    main()   \n\n__starting_point()", "from itertools import product, accumulate\nimport sys\nsys.stdin.readline\n\ndef main():\n    N, W = map(int, input().split())\n    V = [[] for _ in range(4)]\n    w1 = 0\n    for i in range(N):\n        w, v = map(int, input().split())\n        if i == 0: w1 = w\n        V[w-w1].append(v)\n    U = []\n    for i in range(4):\n        U.append([0] + list(accumulate(sorted(V[i], reverse=True))))\n\n    ans = 0\n    for prod in product(*[range(len(U[i])) for i in range(4)]):\n        if sum((i+w1)*p for i, p in enumerate(prod)) <= W:\n            ans = max(ans, sum(U[i][p] for i, p in enumerate(prod)))\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nN,W = map(int, input().split())\nwv = [list(map(int, input().split())) for _ in range(N)]\nDP = defaultdict(int)\nDP[0] = 0\nfor weight, value in wv:\n  exists = list(DP.items())\n  for key, total in exists:\n    new_key = key + weight\n    if new_key > W:\n      continue\n    new_total = total + value\n    if DP[new_key] < new_total:\n      DP[new_key] = new_total\n\nprint(max(DP.values()))", "from collections import defaultdict\n\n\ndef main():\n    n, w = list(map(int, input().split()))\n    items = [list(map(int, input().split())) for _ in range(n)]\n    DP = defaultdict(int)\n    DP[0] = 0\n    for weight, value in items:\n        exists = list(DP.items())\n        for key, total in exists:\n            new_key = key + weight\n            if new_key > w:\n                continue\n            new_total = total + value\n            if DP[new_key] < new_total:\n                DP[new_key] = new_total\n\n    print((max(DP.values())))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, w = list(map(int, input().split()))\n    w1, v1 = list(map(int, input().split()))\n    values = [[] for _ in range(4)]\n    values[0].append(v1)\n    for _ in range(n - 1):\n        wi, vi = list(map(int, input().split()))\n        values[wi - w1].append(vi)\n    for i in range(4):\n        values[i].sort(reverse=True)\n    prefix = [[0] for _ in range(4)]\n    for i in range(4):\n        for j in range(len(values[i])):\n            prefix[i].append(prefix[i][-1] + values[i][j])\n    max_ans = 0\n    tot_val = [0] * 4\n    tot_weights = [0] * 4\n    for i in range(min(len(values[0]), w // w1) + 1):\n        tot_val[0] = prefix[0][i]\n        tot_weights[0] = w1 * i\n        for j in range(min(len(values[1]), w // (w1 + 1)) + 1):\n            tot_val[1] = tot_val[0] + prefix[1][j]\n            tot_weights[1] = tot_weights[0] + (w1 + 1) * j\n            if tot_weights[1] > w:\n                break\n            for k in range(min(len(values[2]), w // (w1 + 2)) + 1):\n                tot_val[2] = tot_val[1] + prefix[2][k]\n                tot_weights[2] = tot_weights[1] + k * (w1 + 2)\n                if tot_weights[2] > w:\n                    break\n                diff = w - tot_weights[2]\n                min_select = min(diff // (w1 + 3), len(values[3]))\n                tot_val[3] = tot_val[2] + prefix[3][min_select]\n                tot_weights[3] = tot_weights[2] + min_select * (w1 + 3)\n                max_ans = max(max_ans, tot_val[3])\n    print(max_ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,W = map(int,input().split())\n\ndp = [[[0]*(3*n+1) for _ in range(n)] for _ in range(n)]\n\nw1,v1 = map(int,input().split())\nfor i in range(3*n+1):\n    dp[0][0][i] = v1\n\nfor i in range(1,n):\n    w,v = map(int,input().split())\n    w -= w1\n    for j in range(min(i+1,n)):\n        for k in range(3*n+1):\n            if j>0 and k>=w:\n                dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-w] + v)\n            elif k>=w:\n                dp[i][0][k] = max(dp[i-1][0][k], v)\n            else:\n                dp[i][j][k] = dp[i-1][j][k]\n\nans = 0\nfor i in range(n):\n    for j in range(3*n+1):\n        if w1*(i+1) + j>W: continue\n        ans = max(ans,dp[-1][i][j])\n\nprint(ans)", "n,W=map(int,input().split())\nw=[0]*n\nv=[0]*n\nfor i in range(n):\n  w[i],v[i]=map(int,input().split())\nws=w[0]\nV=[[] for i in range(4)]\nfor i in range(n):\n  V[w[i]-ws].append(v[i])\nV[0].sort(reverse=True)\nV[1].sort(reverse=True)\nV[2].sort(reverse=True)\nV[3].sort(reverse=True)\nVV=[[0] for i in range(4)]\nfor i in range(4):\n  for j in range(len(V[i])):\n    VV[i].append(VV[i][-1]+V[i][j])\nans=0\nfor i in range(len(V[0])+1):\n  for j in range(len(V[1])+1):\n    for k in range(len(V[2])+1):\n      for l in range(len(V[3])+1):\n        if i*ws+j*(ws+1)+k*(ws+2)+l*(ws+3)>W:\n          break\n        if VV[0][i]+VV[1][j]+VV[2][k]+VV[3][l]>ans:\n          ans=VV[0][i]+VV[1][j]+VV[2][k]+VV[3][l]\nprint(ans)", "N, W = map(int, input().split())\nwv = [list(map(int, input().split())) for i in range(N)]\nw1 = wv[0][0]\n\nw_to_idx = {0:0}\nidx_to_w = {0:0}\nidx_W = 0\ndef calc():\n  nonlocal w_to_idx, idx_to_w, idx_W\n  idx = 1\n  w_max = 0\n  for i in range(1, N+1):\n    w = w1*i\n    for j in range(3*i + 1):\n      ww = w + j\n      if ww in w_to_idx:\n        continue\n      w_to_idx[ww] = idx\n      idx_to_w[idx] = ww\n      if w_max < ww <= W:\n        w_max = ww\n        idx_W = idx\n      idx += 1\n\ncalc()\nn = len(w_to_idx)\ndp = [[0]*n for i in range(N+1)]\nfor i, (w, v) in enumerate(wv, 1):\n  for j in range(n):\n    dp[i][j] = dp[i-1][j]\n    ww = idx_to_w[j]\n    if ww >= w and ww-w in w_to_idx:\n      jj = w_to_idx[ww - w]\n      dp[i][j] = max(dp[i][j], dp[i-1][jj] + v)\n\nprint(max(dp[-1][:idx_W+1]))", "# coding: utf-8\n# Your code here!\ndef saiki(value,HP,num):\n    if num==0:\n        #print(HP//base)\n        value+=wa[0][min(HP//base,len(wa[0])-1)]\n        ans.append(value)\n    else:\n        for i in range(len(wa[num])):\n            if HP-(num+base)*i>=0:\n                saiki(value+wa[num][i],HP-(num+base)*i,num-1)\n            else:\n                break\n    return\n\n\nN,W=list(map(int,input().split()))\n\nlis=[[] for i in range(4)]\n\nfor i in range(N):\n    w,v=list(map(int,input().split()))\n    if i==0:\n        base=w\n    lis[w-base].append(v)\n\nlis=list([sorted(x, reverse=True) for x in lis])\n\nwa=[[0] for i in range(4)]\n\nfor i in range(len(wa)):\n    for item in lis[i]:\n        wa[i].append(wa[i][-1]+item)\n\n#print(wa)\n\nans=[]\nsaiki(0,W,3)\n    \n\nprint((max(ans)))\n", "from collections import *\nN,W = map(int,input().split())\ndp = defaultdict(int)\ndp[0] = 0\n\nfor n in range(N):\n  w,v = map(int,input().split())\n  for k,b in dp.copy().items():\n    if k+w<=W:\n      dp[k+w] = max(dp[k+w],b+v)\n\nprint(max(dp.values()))", "N, W = map(int, input().split())\nw, v = [], []\nfor _ in range(N):\n  wi, vi = map(int, input().split())\n  w.append(wi)\n  v.append(vi)\n\nV = [[], [], [], []]\nfor wi, vi in zip(w, v):\n  V[wi - w[0]].append(vi)\n\nfor vv in V:\n  vv.sort(reverse=True)\n\nans = 0\nfor i in range(len(V[0]) + 1):\n  for j in range(len(V[1]) + 1):\n    for k in range(len(V[2]) + 1):\n      for l in range(len(V[3]) + 1):\n        if w[0] * i + (w[0] + 1)* j + (w[0]+2)*k + (w[0] + 3) * l <= W:\n          ans = max(ans, sum(V[0][:i]) +sum(V[1][:j]) +sum(V[2][:k]) +sum(V[3][:l])) \nprint(ans)", "n, w_max = list(map(int, input().split()))\nW, V = [], []\nDiff_zero = []\nDiff_one = []\nDiff_two = []\nDiff_three = []\nfor i in range(n):\n    w, v = list(map(int, input().split()))\n    W.append(w)\n    V.append(v)\n    diff = w - W[0]\n    if diff == 0:\n        Diff_zero.append(v)\n    elif diff == 1:\n        Diff_one.append(v)\n    elif diff == 2:\n        Diff_two.append(v)\n    elif diff == 3:\n        Diff_three.append(v)\n\nDiff_zero = sorted(Diff_zero, reverse=True)\nDiff_one = sorted(Diff_one, reverse=True)\nDiff_two = sorted(Diff_two, reverse=True)\nDiff_three = sorted(Diff_three, reverse=True)\n\nDiff_zero_ruiseki = [0]\nDiff_one_ruiseki = [0]\nDiff_two_ruiseki = [0]\nDiff_three_ruiseki = [0]\n\nfor i in range(len(Diff_zero)):\n    Diff_zero_ruiseki.append(Diff_zero[i] + Diff_zero_ruiseki[-1])\nfor i in range(len(Diff_one)):\n    Diff_one_ruiseki.append(Diff_one[i] + Diff_one_ruiseki[-1])\nfor i in range(len(Diff_two)):\n    Diff_two_ruiseki.append(Diff_two[i] + Diff_two_ruiseki[-1])\nfor i in range(len(Diff_three)):\n    Diff_three_ruiseki.append(Diff_three[i] + Diff_three_ruiseki[-1])\n\nvalue_max = 0\nw_zero = W[0]\n\nfor i in range(n+1):\n    if i > len(Diff_zero):\n        continue\n    for j in range(n+1):\n        if j > len(Diff_one):\n            continue\n        for k in range(n+1):\n            if k > len(Diff_two):\n                continue\n            for l in range(n+1):\n                if l > len(Diff_three):\n                    continue\n                if w_zero*i + (w_zero+1)*j + (w_zero+2)*k + (w_zero+3)*l > w_max:\n                    continue\n                if i + j + k + l > n:\n                    continue\n\n                value = Diff_zero_ruiseki[i] + Diff_one_ruiseki[j] + Diff_two_ruiseki[k] + Diff_three_ruiseki[l]\n                value_max = max(value, value_max)\n\nprint(value_max)\n\n\n             \n", "import numpy as np\nN, W = list(map(int,input().split()))\nls = []\nfor i in range(N):\n  w, v = list(map(int, input().split()))\n  ls += [[w,v]]\nls = np.array(ls)\nw1 = ls[0][0]\nls[:,0] -= w1\n\nM = 3*N\ndp = np.full((N+1,M+1), -float('inf'))\ndp[0][0] = 0\n\nfor i in range(N):\n  w, v = ls[i]\n  dp[1:,w:] = np.maximum(dp[1:,w:], dp[:N,:M-w+1]+v)\n  \nans = 0\nfor i in range(1,N+1):\n  B = i*w1\n  m = 0\n  for j in range(M+1):\n    if B+j<=W:\n      m = max(m,dp[i][j])\n  if ans<m:\n    ans = m\nprint((int(ans)))\n", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return list(map(int,input().split()))\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(list(map(max,x)))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)//2\n\n    if rr == mid:\n        return ll\n    if (\u3053\u3053\u306b\u8a55\u4fa1\u5165\u308c\u308b):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\nn,w = m()\n\npo = [[] for i in range(4)]\npr = [[0] for i in range(4)]\n\nfor i in range(n):\n    a,b = m()\n    if i == 0:\n        coo = a\n        po[0].append(b)\n    else:\n        kkk = a - coo\n        po[kkk].append(b)\n\nfor i in range(4):\n    po[i].sort(reverse = True)\n    for ii in range(len(po[i])):\n        pr[i].append(pr[i][-1] + po[i][ii])\n\nco = 0\nsu = 0\nfor i in range(len(po[0]) + 1):\n    for ii in range(len(po[1]) + 1):\n        for iii in range(len(po[2]) + 1):\n            for iiii in range(len(po[3]) + 1):\n                if (i * coo + ii * (coo + 1) + iii * (coo + 2) + iiii * (coo + 3)) <= w:\n                    su = max(su,pr[0][i]+pr[1][ii]+pr[2][iii]+pr[3][iiii])\n\nprint(su)\n\n\n\n\n", "from itertools import accumulate\nN,W=map(int,input().split())\nw1, w2, w3, w4 = [], [], [], []\nw, v = map(int, input().split())\nw1.append(v)\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    if a == w: w1.append(b)\n    if a == w+1: w2.append(b)\n    if a == w+2: w3.append(b)\n    if a == w+3: w4.append(b)\n\n\nfor w_ in [w1, w2, w3, w4]:\n    w_.sort(reverse= True)\n\nw1=[0]+w1\nw1=list(accumulate(w1))\nw2=[0]+w2\nw2=list(accumulate(w2))\nw3=[0]+w3\nw3=list(accumulate(w3))\nw4=[0]+w4\nw4=list(accumulate(w4))\n\n#print(w1,w2,w3,w4)\n#print(len(w1),len(w2),len(w3),len(w4))\n\nans=0\nfor a in range(len(w1)):\n    for b in range(len(w2)):\n        for c in range(len(w3)):\n            for d in range(len(w4)):\n                #print(a,b,c,d)\n                wei=w*a+(w+1)*b+(w+2)*c+(w+3)*d\n                val=w1[a]+w2[b]+w3[c]+w4[d]\n                #print(wei,val)\n                if wei<=W:\n                    ans=max(val,ans)\n\nprint(ans)", "n, W = map(int, input().split())\na = [tuple(map(int, input().split())) for _ in range(n)]\n\nbase = a[0][0]\ns = [[] for _ in range(4)]\nfor w, v in a:\n    s[w-base].append(v)\nfor i in range(4):\n    s[i].sort(reverse=True)\n\nlength = [len(s[i]) for i in range(4)]\ncum = [[] for _ in range(4)]\nfor i in range(4):\n    cum[i] = [0 for _ in range(length[i]+1)]\n    for j in range(length[i]):\n        cum[i][j+1] = cum[i][j] + s[i][j]\n\nans = 0\nfor i in range(length[0]+1):\n    for j in range(length[1]+1):\n        for k in range(length[2]+1):\n            for l in range(length[3]+1):\n                weight = (i+j+k+l) * base + j + 2*k + 3*l\n                if weight <= W:\n                    ans = max(ans, cum[0][i] + cum[1][j] + cum[2][k] + cum[3][l])\nprint(ans)", "N, W = list(map(int,input().split()))\nls = []\nfor i in range(N):\n  w, v = list(map(int, input().split()))\n  ls += [[w,v]]\nw1 = ls[0][0]\nfor i in range(N):\n  ls[i][0] -= w1\nans = 0\nM = 3*N\ndp = [[-1]*(M+1) for i in range(N+1)]\ndp[0][0] = 0\nfor i in range(N):\n  w, v = ls[i]\n  for h in range(N,0,-1):\n    for j in range(M,-1,-1):\n      if j-w>=0 and dp[h-1][j-w]!=-1:\n        dp[h][j] = max(dp[h][j], dp[h-1][j-w]+v)\nfor i in range(1,N+1):\n  B = i*w1\n  m = 0\n  for j in range(M+1):\n    if B+j<=W:\n      m = max(m,dp[i][j])\n  if ans<m:\n    ans = m\nprint(ans)\n", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nN,W = list(map(int,readline().split()))\ngoods = [tuple(map(int,readline().split())) for i in range(N)]\n\nfrom collections import defaultdict\n\nd = defaultdict(int)\nd[0] = 0\n\nfor (w,v) in goods:\n    dnew = defaultdict(int)\n    for key,value in list(d.items()):\n        dnew[key] = value\n    for key,value in list(d.items()):\n        dnew[key+w] = max(dnew[key+w],d[key]+v)\n    d = dnew\nans = 0\nfor k,v in list(d.items()):\n    if k <= W:\n        ans = max(ans,v)\nprint(ans)\n\n", "n,W=map(int,input().split())\nwv=[[]for _ in range(4)]\nfor i in range(n):\n\tw,v=map(int,input().split())\n\tif i==0:\n\t\tr=w\n\t\twv[0].append(v)\n\telse:\n\t\twv[w-r].append(v)\nfor i in range(4):\n\twv[i].sort(reverse=True)\n\tfor j in range(len(wv[i])-1):\n\t\twv[i][j+1]+=wv[i][j]\n\twv[i].insert(0,0)\nans=0\nfor i in range(len(wv[0])):\n\tfor j in range(len(wv[1])):\n\t\tfor k in range(len(wv[2])):\n\t\t\tfor l in range(len(wv[3])):\n\t\t\t\tp=wv[0][i]+wv[1][j]+wv[2][k]+wv[3][l]\n\t\t\t\tif i*r+j*(r+1)+k*(r+2)+l*(r+3)<=W:\n\t\t\t\t\tans=max(ans,p)\nprint(ans)", "# solution\nimport io\n\nnim, mike = [int(_) for _ in input().split()]\nWV = [[int(_) for _ in input().split()] for _ in range(nim)]\nqwe = {}\nqwe[0] = 0\nfor weight, value in WV:\n    dp_old = qwe.copy()\n    for k, v in list(dp_old.items()):\n        if k + weight <= mike:\n            qwe[k + weight] = max(qwe.get(k + weight, 0), v + value)\nans = 0\nfor k, v in list(qwe.items()):\n    ans = max(ans, v)\nprint(ans)\n", "N,W=map(int,input().split())\nA=[]\nW1,W2,W3,W4=[],[],[],[]\nfor i in range(N):\n  w,v=map(int,input().split())\n  if i==0:\n    a=w\n  A.append((v,w))\n  if w-a==0:\n    W1.append(v)\n  elif w-a==1:\n    W2.append(v)\n  elif w-a==2:\n    W3.append(v)\n  else:\n    W4.append(v)\n  \n\nW1,W2,W3,W4=sorted(W1)[::-1],sorted(W2)[::-1],sorted(W3)[::-1],sorted(W4)[::-1]\n\nl1,l2,l3,l4=len(W1),len(W2),len(W3),len(W4)\nans=0\nfor i in range(l1+1):\n  for j in range(l2+1):\n    for k in range(l3+1):\n      for l in range(l4+1):\n        value=sum(W1[:i])+sum(W2[:j])+sum(W3[:k])+sum(W4[:l])\n        if a*i+(a+1)*j+(a+2)*k+(a+3)*l<=W:\n          ans=max(ans,value)\nprint(ans)", "import sys\nfrom operator import itemgetter\n\nrl = sys.stdin.readline\n\n\ndef solve():\n    N, W = list(map(int, rl().split()))\n    w1, w2, w3, w4 = [[0, 0]], [[0, 0]], [[0, 0]], [[0, 0]]\n    w1.append(list(map(int, rl().split())))\n    min_w = w1[1][0]\n    for _ in range(N - 1):\n        w, v = list(map(int, rl().split()))\n        d = w - min_w\n        if d == 0:\n            w1.append([w, v])\n        elif d == 1:\n            w2.append([w, v])\n        elif d == 2:\n            w3.append([w, v])\n        else:\n            w4.append([w, v])\n    w1.sort(key=itemgetter(1), reverse=True)\n    w2.sort(key=itemgetter(1), reverse=True)\n    w3.sort(key=itemgetter(1), reverse=True)\n    w4.sort(key=itemgetter(1), reverse=True)\n    \n    ans = 0\n    for i in range(len(w1)):\n        w_tmp1, v_tmp1 = 0, 0\n        for j in range(i):\n            w_tmp1 += w1[j][0]\n            v_tmp1 += w1[j][1]\n        for j in range(len(w2)):\n            w_tmp2, v_tmp2 = w_tmp1, v_tmp1\n            for k in range(j):\n                w_tmp2 += w2[k][0]\n                v_tmp2 += w2[k][1]\n            for k in range(len(w3)):\n                w_tmp3, v_tmp3 = w_tmp2, v_tmp2\n                for l in range(k):\n                    w_tmp3 += w3[l][0]\n                    v_tmp3 += w3[l][1]\n                for l in range(len(w4)):\n                    w_tmp4, v_tmp4 = w_tmp3, v_tmp3\n                    for m in range(l):\n                        w_tmp4 += w4[m][0]\n                        v_tmp4 += w4[m][1]\n                    if w_tmp4 <= W:\n                        ans = max(ans, v_tmp4)\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n, w = map(int, input().split())\ns = [list(map(int, input().split())) for _ in range(n)]\nss = s[0][0]\ns.sort(key = lambda x : x[1], reverse = True)\nt = [[] for _ in range(4)]\nfor u in s:\n    t[u[0] - ss].append(u[1])\nl1, l2, l3, l4 = len(t[0]) + 1, len(t[1]) + 1, len(t[2]) + 1, len(t[3]) + 1\na, b, = [0] * l1, [0] * l2\nc, d, = [0] * l3, [0] * l4\nfor i in range(1, l1):\n    a[i] = t[0][i - 1] + a[i - 1]\nfor i in range(1, l2):\n    b[i] = t[1][i - 1] + b[i - 1]\nfor i in range(1, l3):\n    c[i] = t[2][i - 1] + c[i - 1]\nfor i in range(1, l4):\n    d[i] = t[3][i - 1] + d[i - 1]\nans = 0\nfor i in range(l1):\n    for j in range(l2):\n        for k in range(l3):\n            for l in range(l4):\n                if ss * (i + j + k + l) + (j + 2 * k + 3 * l) <= w:\n                    ans = max(ans, a[i] + b[j] + c[k] + d[l])\nprint(ans)", "from sys import stdin\nfrom itertools import accumulate\nreadline = stdin.readline\n\nN, W = list(map(int, input().split()))\nvs = [[] for _ in range(4)]\nw, v = list(map(int, input().split()))\nw1 = w\nvs[0].append(v)\nfor _ in range(N - 1):\n    w, v = list(map(int, input().split()))\n    vs[w - w1].append(v)\n\nfor i in range(4):\n    vs[i].sort(reverse=True)\n    vs[i] = [0] + list(accumulate(vs[i]))\n\nresult = 0\nfor i in range(len(vs[0])):\n    a = W - w1 * i\n    if a < 0:\n        break\n    for j in range(len(vs[1])):\n        b = a - (w1 + 1) * j\n        if b < 0:\n            break\n        for k in range(len(vs[2])):\n            c = b - (w1 + 2) * k\n            if c < 0:\n                break\n            t = vs[0][i] + vs[1][j] + vs[2][k]\n            for l in range(len(vs[3])):\n                d = c - (w1 + 3) * l\n                if d < 0:\n                    break\n                result = max(result, t + vs[3][l])\nprint(result)\n", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=1000000001\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x[z].append(v_sub)\nfor i in range(4):\n    x[i].sort(key=lambda x:-x)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "from collections import defaultdict\nn, W = list(map(int, input().split()))\ndd = defaultdict(list)\nfor i in range(n):\n    weight, value = list(map(int, input().split()))\n    dd[weight].append(value)\n\nfor k in list(dd.keys()):\n    dd[k].sort(reverse=True)\n\na = min(dd.keys())\nb, c, d = a+1, a+2, a+3\nans = 0\nfor w in range(len(dd[a])+1):\n    for x in range(len(dd[b])+1):\n        for y in range(len(dd[c])+1):\n            for z in range(len(dd[d])+1):\n                if W < a*w+b*x+c*y+d*z:\n                    continue\n                val = sum(dd[a][:w])+sum(dd[b][:x]) + \\\n                    sum(dd[c][:y])+sum(dd[d][:z])\n                ans = max(ans, val)\nprint(ans)\n", "from collections import defaultdict\nn, W = list(map(int, input().split()))\ndd = defaultdict(list)\nfor i in range(n):\n    weight, value = list(map(int, input().split()))\n    dd[weight].append(value)\n\na = min(dd.keys())\nb, c, d = a+1, a+2, a+3\nVcum = defaultdict(lambda: [0])\nfor k in [a, b, c, d]:\n    s = 0\n    dd[k].sort(reverse=True)\n    for val in dd[k]:\n        s += val\n        Vcum[k].append(s)\n\nans = 0\nfor w in range(len(dd[a])+1):\n    for x in range(len(dd[b])+1):\n        for y in range(len(dd[c])+1):\n            for z in range(len(dd[d])+1):\n                if W < a*w+b*x+c*y+d*z:\n                    continue\n                val = Vcum[a][w]+Vcum[b][x]+Vcum[c][y]+Vcum[d][z]\n                ans = max(ans, val)\nprint(ans)\n", "N, W = list(map(int, input().split()))\nitem = [tuple(map(int, input().split())) for _ in range(N)]\n\nw1 = item[0][0]\nV = [[] for _ in range(4)]\nfor w, v in item:\n    V[w - w1].append(v)\nfor i in range(4):\n    V[i].sort(reverse=True)\n\ncnt = [0] * 4\nfor i in range(4):\n    cnt[i] = len(V[i])\n\nans = 0\nfor i in range(cnt[0] + 1):\n    S0 = sum(V[0][:i])\n    W0 = i * w1\n    for j in range(cnt[1] + 1):\n        S1 = sum(V[1][:j])\n        W1 = j * (w1 + 1)\n        for k in range(cnt[2] + 1):\n            S2 = sum(V[2][:k])\n            W2 = k * (w1 + 2)\n            for l in range(cnt[3] + 1):\n                S3 = sum(V[3][:l])\n                W3 = l * (w1 + 3)\n                if W0 + W1 + W2 + W3 <= W:\n                    ans = max(ans, S0 + S1 + S2 + S3)\n\nprint(ans)\n", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\nx_sub=[[v_sub],[],[],[]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x_sub[z].append(v_sub)\nfor i in range(4):\n    x_sub[i].sort(key=lambda x:-x)\n#print(x_sub)\nx=[[0],[0],[0],[0]]\nfor i in range(4):\n    for j in x_sub[i]:\n        k=j+x[i][-1]\n        x[i].append(k)\n#print(x)\n#print(w0)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "def makelst(lst, v):\n    for i in range(N):\n        if wv[i][0] == v:\n            lst.append(wv[i][1])\n    lst.sort(reverse=True)\n\nN, W = map(int, input().split())\nwv = [list(map(int, input().split())) for _ in range(N)]\nv1cnt = W // wv[0][0]\nv2cnt = W // (wv[0][0] + 1)\nv3cnt = W // (wv[0][0] + 2)\nv4cnt = W // (wv[0][0] + 3)\nv1, v2, v3, v4 = [], [], [], []\nmakelst(v1, wv[0][0])\nmakelst(v2, wv[0][0] + 1)\nmakelst(v3, wv[0][0] + 2)\nmakelst(v4, wv[0][0] + 3)\n\n[0] + v1, [0] + v2, [0] + v3, [0] + v4\n\nans = 0\n\nv1cnt = min(v1cnt, len(v1))\nv2cnt = min(v2cnt, len(v2))\nv3cnt = min(v3cnt, len(v3))\nv4cnt = min(v4cnt, len(v4))\nru1 = [0] * (v1cnt + 1)\nru2 = [0] * (v2cnt + 1)\nru3 = [0] * (v3cnt + 1)\nru4 = [0] * (v4cnt + 1)\nfor i in range(1, v1cnt + 1):\n    ru1[i] = ru1[i - 1] + v1[i - 1]\n\nfor i in range(1, v2cnt + 1):\n    ru2[i] = ru2[i - 1] + v2[i - 1]\n\nfor i in range(1, v3cnt + 1):\n    ru3[i] = ru3[i - 1] + v3[i - 1]\n\nfor i in range(1, v4cnt + 1):\n    ru4[i] = ru4[i - 1] + v4[i - 1]\n\nfor i in range(len(ru1)):\n    for j in range(len(ru2)):\n        for k in range(len(ru3)):\n            for l in range(len(ru4)):\n                wtmp = (i * wv[0][0]) + (j * (wv[0][0] + 1)) + (k * (wv[0][0] + 2)) + (l * (wv[0][0] + 3))\n                if wtmp <= W:\n                    ans = max(ans, ru1[i] + ru2[j] + ru3[k] + ru4[l])\n\nprint(ans)", "n,w=list(map(int,input().split()))\nwv=[list(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "from itertools import product\n\nN, W = map(int,input().split())\nL = [[] for _ in range(4)]\nw, v = map(int,input().split())\nL[0].append(v)\nfor _ in range(N-1):\n    tmp_w, tmp_v = map(int,input().split())\n    L[tmp_w - w].append(tmp_v)\n\nfor i in range(4):\n    L[i].sort(reverse = True)\n\nfor i in range(4):\n    for j in range(len(L[i]) - 1):\n        L[i][j+1] += L[i][j]\n    L[i] = [0] + L[i]\n\nans = 0\n\nfor i, j, k, l in product(range(len(L[0])), range(len(L[1])), range(len(L[2])), range(len(L[3]))):\n   if w * (i + j + k + l) + j + 2 * k + 3 * l <= W:\n        ans = max(ans, L[0][i] + L[1][j] + L[2][k] + L[3][l])\n\nprint(ans)", "N, W = list(map(int, input().split()))\nwv = list(map(int, input().split()))\nw1 = wv[0]\n\nwvs = [[] for i in range(4)]\nwvs[0].append(wv[1])\n\nfor i in range(N - 1):\n  w, v = list(map(int, input().split()))\n  w -= w1\n  wvs[w].append(v)\n\ns = [0] * 4\nfor i in range(4):\n  wvs[i] = sorted(wvs[i], reverse = True)\n  s[i] = len(wvs[i])\n  if s[i] > 1:\n    for j in range(1, s[i]):\n      wvs[i][j] += wvs[i][j - 1]\n  wvs[i].insert(0, 0)\n#print(wvs)\n\nans = 0\nfor i in range(s[0] + 1):\n  for j in range(s[1] + 1):\n    for k in range(s[2] + 1):\n      for l in range(s[3] + 1):\n        weight = w1 * (i + j + k + l) + (j + 2 * k + 3 * l)\n        if weight <= W:\n          value = wvs[0][i] + wvs[1][j] + wvs[2][k] + wvs[3][l]\n          ans = max(ans, value)\n          \nprint(ans)\n        \n        \n\n\n  \n  \n", "N, W = map(int, input().split())\ndata = tuple(tuple(map(int, input().split())) for _ in range(N))\nd = {0: 0}\nfor n in range(N):\n    weight, value = data[n]\n    for w, now in d.copy().items():\n        if w + weight <= W:\n            d[w + weight] = max(d.get(w + weight, 0), now + value)\nprint(max(d.values()))", "#060_D\nn, W = map(int, input().split())\nw1, w2, w3, w4 = [], [], [], []\nw, v = map(int, input().split())\nw1.append(v)\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    if a == w: w1.append(b)\n    if a == w+1: w2.append(b)\n    if a == w+2: w3.append(b)\n    if a == w+3: w4.append(b)\n    \nfor w_ in [w1, w2, w3, w4]:\n    w_.sort(reverse= True)\n    \nans = 0\nfor i in range(0, len(w1)+1):\n    for j in range(0, len(w2)+1):\n        for k in range(0, len(w3)+1):\n            res = W - (i * w + j * (w+1) + k * (w+2))\n            if res < 0:\n                continue\n            tmp = sum(w1[:i])+sum(w2[:j])+sum(w3[:k])+sum(w4[:res//(w+3)])\n            ans = max(tmp, ans)\n            \nprint(ans)", "N, W = map(int, input().split())\nItems = [tuple(map(int, input().split())) for _ in range(N)]\nfrom collections import defaultdict as dd\nBag = dd(lambda:0)\nBag[0] = 0\nfor w,v in Items:\n    temp = [(key+w,Bag[key]+v) for key in Bag if key + w <= W]\n    for key,value in temp:\n        Bag[key] = max(Bag[key],value)\nans = max(Bag.values())\nprint(ans)", "n, W = map(int, input().split())\nwv = []\nfor i in range(n):\n    wv.append(list(map(int, input().split())))\nnum = wv[0][0]\ndp = [[-float(\"inf\") for i in range(3 * (n - 1) + 1)] for j in range(n + 1)]\ndp[0][0] = 0\nfor i in range(n):\n    w, v = wv[i][0], wv[i][1]\n    w -= num\n    for j in range(n - 1, -1, -1):\n        for k in range(3 * (n - 1) + 1 - w):\n            dp[j + 1][k + w] = max(dp[j + 1][k + w], dp[j][k] + v)\nans = 0\nfor i in range(3 * (n - 1) + 1):\n    for j in range(n + 1):\n        if j * num + i <= W:\n            ans = max(ans, dp[j][i])\nprint(ans)", "from collections import defaultdict\n\n\ndef main():\n    n, w = list(map(int, input().split()))\n    items = [list(map(int, input().split())) for _ in range(n)]\n    DP = defaultdict(int)\n    DP[0] = 0\n    for weight, value in items:\n        exists = list(DP.items())\n        for key, total in exists:\n            new_key = key + weight\n            new_total = total + value\n            if DP[new_key] < new_total:\n                DP[new_key] = new_total\n\n    candidates = [0]\n    for weight, value in sorted(DP.items()):\n        if weight > w:\n            break\n        candidates.append(value)\n\n    print((max(candidates)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import  numpy as np\nN, W, *L = map(int, open(0).read().split())\nM = 3*(N-1)+1\ndp = np.zeros((M,N+1),np.int64)\nfor w,v in zip(*[iter(L)]*2):\n  w -= L[0]\n  dp[w:,1:] = np.maximum(dp[w:,1:], dp[:M-w,:N]+v)\n\nans = 0\nfor i in range(N+1):\n  m = i*L[0]\n  if m>W:\n    continue\n  m = min(W-m,M-1)\n  ans = max(ans, dp[m,i])\nprint(ans)", "n,w=list(map(int,input().split()))\nwv=[tuple(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "N, W = map(int, input().split())\n\nV0 = []\nV1 = []\nV2 = []\nV3 = []\n\nfor i in range(N):\n    w, v = map(int, input().split())\n    if i == 0:\n        w1 = w\n        V0.append(v)\n    else:\n        if w == w1:\n            V0.append(v)\n        elif w == w1+1:\n            V1.append(v)\n        elif w == w1+2:\n            V2.append(v)\n        else:\n            V3.append(v)\n\nV0.sort(reverse=True)\nV1.sort(reverse=True)\nV2.sort(reverse=True)\nV3.sort(reverse=True)\n\nfrom itertools import accumulate\nCV0 = [0] + V0\nCV0 = list(accumulate(CV0))\nCV1 = [0] + V1\nCV1 = list(accumulate(CV1))\nCV2 = [0] + V2\nCV2 = list(accumulate(CV2))\nCV3 = [0] + V3\nCV3 = list(accumulate(CV3))\n\nans = -float('inf')\nfor a in range(len(V0)+1):\n    for b in range(len(V1)+1):\n        for c in range(len(V2)+1):\n            for d in range(len(V3)+1):\n                if w1*a + (w1+1)*b + (w1+2)*c + (w1+3)*d <= W:\n                    sum_v = CV0[a]+CV1[b]+CV2[c]+CV3[d]\n                    ans = max(ans, sum_v)\n\nprint(ans)", "import itertools\nfrom collections import defaultdict\n\nN, W = list(map(int, input().split()))\nd = defaultdict(list)\nfor _ in range(N):\n    w, v = list(map(int, input().split()))\n    d[w].append(v)\n\nfor i in d:\n    d[i] = list(itertools.accumulate(sorted(d[i], reverse=True)))\nmm = min(d)\n\nans = 0\nfor t in itertools.product(list(range(len(d[mm]) + 1)), list(range(len(d[mm + 1]) + 1)),\n                           list(range(len(d[mm + 2]) + 1)), list(range(len(d[mm + 3]) + 1))):\n    if sum((mm + i) * t[i] for i in range(4)) > W:\n        continue\n    ans = max(ans, sum(d[mm + i][t[i] - 1] if t[i] else 0 for i in range(4)))\nprint(ans)\n", "from collections import defaultdict\n\n\ndef main():\n    N, W = list(map(int, input().split(' ')))\n    items, cumsums = defaultdict(list), defaultdict(list)\n    w_0 = 0\n    for i in range(N):\n        w, v = list(map(int, input().split(' ')))\n        if i == 0:\n            w_0 = w\n        items[w].append(v)\n    for w in items.keys():\n        items[w].sort(reverse=True)\n        cumsum_w, cumsum_v = 0, 0\n        for v in items[w]:\n            cumsum_w += w\n            cumsum_v += v\n            # w - w_0 is in [0, 1, 2, 3]\n            cumsums[w - w_0].append((cumsum_w, cumsum_v))\n\n    def dfs(cur, rest_w):\n        if cur == 0:\n            max_v = 0\n            for cumsum_w, cumsum_v in cumsums[cur]:\n                if cumsum_w <= rest_w:\n                    max_v = cumsum_v\n            return max_v\n        else:\n            ret = dfs(cur - 1, rest_w)\n            for cumsum_w, cumsum_v in cumsums[cur]:\n                if rest_w >= cumsum_w:\n                    ret = max([ret, cumsum_v + dfs(cur - 1, rest_w - cumsum_w)])\n            return ret\n\n    print(dfs(3, W))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import accumulate\n\nN, W = map(int, input().split())\nwv = {}\nw1 = 0\nfor i in range(N):\n  w, v = map(int, input().split())\n  if i == 0:\n    w1 = w\n  if w in wv:\n    wv[w].append(v)\n  else:\n    wv[w] = [v]\n\nfor w in wv:\n  wv[w].sort(reverse=True)\n  wv[w] = [0] + list(accumulate(wv[w]))\n\nw2 = w1+1; w3 = w1+2; w4 = w1+3\nfor w in [w1, w1+1, w1+2, w1+3]:\n  if w not in wv:\n    wv[w] = [0]\n\nans = 0\nfor n1 in range(len(wv[w1])):\n  for n2 in range(len(wv[w2])):\n    for n3 in range(len(wv[w3])):\n      for n4 in range(len(wv[w4])):\n        w = w1*n1 + w2*n2 + w3*n3 + w4*n4\n        if w <= W:\n          ans = max(ans, wv[w1][n1]+wv[w2][n2]+wv[w3][n3]+wv[w4][n4])\n\nprint(ans)", "N, W, *WV = map(int, open(0).read().split())\n\nC = {0: 0}\nfor v, w in zip(*[reversed(WV)] * 2):\n    for x, y in C.copy().items():\n        if x + w <= W:\n            C[x + w] = max(C.get(x + w, 0), y + v)\n\nprint(max(C.values()))", "from sys import stdin\nfrom itertools import accumulate\nreadline = stdin.readline\n\nN, W = list(map(int, input().split()))\nvs = [[] for _ in range(4)]\nw, v = list(map(int, input().split()))\nw1 = w\nvs[0].append(v)\nfor _ in range(N - 1):\n    w, v = list(map(int, input().split()))\n    vs[w - w1].append(v)\n\nfor i in range(4):\n    vs[i].sort(reverse=True)\n    vs[i] = list(accumulate(vs[i]))\n\nresult = 0\nfor i in range(len(vs[0]) + 1):\n    a = W - w1 * i\n    if a < 0:\n        break\n    for j in range(len(vs[1]) + 1):\n        b = a - (w1 + 1) * j\n        if b < 0:\n            break\n        for k in range(len(vs[2]) + 1):\n            c = b - (w1 + 2) * k\n            if c < 0:\n                break\n            t = 0\n            if i != 0:\n              t += vs[0][i - 1]\n            if j != 0:\n              t += vs[1][j - 1]\n            if k != 0:\n              t += vs[2][k - 1]\n            for l in range(len(vs[3]) + 1):\n                d = c - (w1 + 3) * l\n                if d < 0:\n                    break\n                if l == 0:\n                    result = max(result, t)\n                else:\n                    result = max(result, t + vs[3][l -1])\nprint(result)\n", "n,w=list(map(int,input().split()))\nx1,y1=list(map(int,input().split()))\nd={x1:[y1],x1+1:[],x1+2:[],x1+3:[]}\nfor _ in range(n-1):\n    x,y=list(map(int,input().split()))\n    d[x].append(y)\nd={k:[0]+sorted(d[k],reverse=True) for k in d}\nvm=0\nv1,w1=0,0\nfor e in d[x1]:\n    v1+=e\n    w1+=0 if e==0 else x1\n    v2,w2=0,0\n    for f in d[x1+1]:\n        v2+=f\n        w2+=0 if f==0 else x1+1\n        v3,w3=0,0\n        for g in d[x1+2]:\n            v3+=g\n            w3+=0 if g==0 else x1+2\n            v4,w4=0,0\n            for h in d[x1+3]:\n                v4+=h\n                w4+=0 if h==0 else x1+3\n                ws=w1+w2+w3+w4\n                vs=v1+v2+v3+v4\n                if ws<=w:\n                    vm=max(vm,vs)\nprint(vm)\n", "from operator import itemgetter\nn,w=list(map(int,input().split()))\nwv=[tuple(map(int,input().split())) for i in range(n)]\nwv.sort(key=itemgetter(1),reverse=True)#reverse\nwv.sort(key=itemgetter(0))\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n,w=list(map(int,input().split()))\nwv=[list(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,len(x[0])-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n,w=list(map(int,input().split()))\nwv=[list(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        if w-i*(w0+3)-j*(w0+2)>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[[-1] * (3 * n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\ndp[0][0][0] = 0\nw1 = wv[0][0]\n\nfor i, (w, v) in enumerate(wv):\n    for j in range(i + 1):\n        for k in range(3 * n + 1):\n            if dp[i][j][k] != -1:\n                dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k])\n                w_diff = w - w1\n                if j + 1 <= n and k + w_diff <= 3 * n:\n                    dp[i+1][j+1][k+w_diff] = max(dp[i+1][j+1][k+w_diff], dp[i][j][k] + v)\n\nans = 0\nfor j in range(n + 1):\n    w_diff_mx = min(W - w1 * j, 3 * n)\n    for k in range(w_diff_mx + 1):\n        ans = max(ans, dp[n][j][k])\n\nprint(ans)\n", "from collections import defaultdict\nN,W=map(int,input().split())\nitems=[list(map(int,input().split())) for i in range(N)]\ndp=defaultdict(int)\ndp[0]=0\nfor w,v in items:\n  for tw,tv in list(dp.items()):\n    if tw+w<=W:\n      dp[tw+w]=max(tv+v,dp[tw+w])\nprint(max(dp.values()))", "import sys\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, W, *WV = list(map(int, read().split()))\n    weight = WV[::2]\n    value = WV[1::2]\n\n    w_min = min(weight)\n    items = [[] for _ in range(4)]\n    for w, v in zip(weight, value):\n        items[w - w_min].append(v)\n\n    for i in range(4):\n        items[i].sort(reverse=True)\n\n    csums = [0] * 4\n    for i in range(4):\n        csums[i] = [0]\n        csums[i].extend(accumulate(items[i]))\n\n    def rec(i, w, v):\n        if i == 4:\n            if w <= W:\n                return v\n            else:\n                return -1\n        ans = 0\n        for j in range(len(csums[i])):\n            w_next = w + (w_min + i) * j\n            if w_next > W:\n                break\n            ans = max(ans, rec(i + 1, w_next, v + csums[i][j]))\n\n        return ans\n\n    print((rec(0, 0, 0)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, W = map(int, input().split())\nwv = [list(map(int, input().split())) for _ in range(N)]\nw0 = wv[0][0]\nwv.sort(key=lambda x: (x[0], -x[1]))\nw1, w2, w3, w4 = [], [], [], []\nfor w, v in wv:\n    if w == w0:\n        w1.append(v)\n    elif w == w0 + 1:\n        w2.append(v)\n    elif w == w0 + 2:\n        w3.append(v)\n    else:\n        w4.append(v)\nSw1, Sw2, Sw3, Sw4 = [0], [0], [0], [0]\nS = 0\nfor v in w1:\n    S += v\n    Sw1.append(S)\nS = 0\nfor v in w2:\n    S += v\n    Sw2.append(S)\nS = 0\nfor v in w3:\n    S += v\n    Sw3.append(S)\nS = 0\nfor v in w4:\n    S += v\n    Sw4.append(S)\nl1, l2, l3, l4 = len(w1), len(w2), len(w3), len(w4)\nV = 0\nv = 0\nfor i in range(l1 + 1):\n    if w0 * i > W:\n        break\n    for j in range(l2 + 1):\n        if w0 * i + (w0 + 1) * j > W:\n            break\n        for k in range(l3 + 1):\n            if w0 * i + (w0 + 1) * j + (w0 + 2) * k > W:\n                break\n            for l in range(l4 + 1):\n                if w0 * i + (w0 + 1) * j + (w0 + 2) * k + (w0 + 3) * l > W:\n                    break\n                v = Sw1[i] + Sw2[j] + Sw3[k] + Sw4[l]\n                V = max(V, v)\nprint(V)", "from itertools import accumulate\n\nn, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(n)]\n\nw1 = wv[0][0]\nweights = [[] for _ in range(4)]\n\nfor w, v in wv:\n    w_diff = w - w1\n    weights[w_diff].append(v)\n\nfor i in range(4):\n    weights[i].sort(reverse=True)\n\nacc = [[0] + list(accumulate(li)) for li in weights]\n\nl3 = len(weights[3])\nans = 0\nfor i, e1 in enumerate(acc[0]):\n    for j, e2 in enumerate(acc[1]):\n        for k, e3 in enumerate(acc[2]):\n            w_sm = w1 * i + (w1 + 1) * j + (w1 + 2) * k\n            if w_sm > W:\n                break\n\n            l = min((W - w_sm) // (w1 + 3), l3)\n            val = acc[0][i] + acc[1][j] + acc[2][k] + acc[3][l]\n            ans = max(ans, val)\n\nprint(ans)\n", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=1000000001\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x[z].append(v_sub)\nfor i in range(4):\n    x[i].sort(reverse=True)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "from collections import defaultdict\n\nN, W = list(map(int, input().split()))\nwv = defaultdict(list)\nfor _ in range(N):\n    w, v = list(map(int, input().split()))\n    wv[w].append(v)\n\nfor k in list(wv.keys()):\n    wv[k].sort(reverse=True)\n\nkw = list(wv.keys())\nkw.sort()\nl = [len(wv[k]) for k in kw]\nl = l + (4 - len(l)) * [0]\n# print(l)\n\nans = 0\nfor i in range(l[0] + 1):\n    wi = kw[0] * i\n    if W < wi:\n        break\n    vi = sum(wv[kw[0]][:i])\n    if l[1] == 0:\n        ans = max(ans, vi)\n    for j in range(l[1] + 1):\n        if 2 <= len(kw):\n            wj = wi + kw[1] * j\n            if W < wj:\n                break\n            vj = vi + sum(wv[kw[1]][:j])\n            if l[2] == 0:\n                ans = max(ans, vj)\n            for k in range(l[2] + 1):\n                if 3 <= len(kw):\n                    wk = wj + kw[2] * k\n                    if W < wk:\n                        break\n                    vk = vj + sum(wv[kw[2]][:k])\n                    if l[3] == 0:\n                        ans = max(ans, vk)\n                    for m in range(l[3] + 1):\n                        if 4 <= len(kw):\n                            wm = wk + kw[3] * m\n                            if W < wm:\n                                break\n                            vm = vk + sum(wv[kw[3]][:m])\n                            ans = max(ans, vm)\nprint(ans)\n", "n,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=1000000001\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    w_sub-=w0\n    x[w_sub].append(v_sub)\nfor i in range(4):\n    x[i].sort(key=lambda x:-x)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "import sys\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, W, *WV = list(map(int, read().split()))\n    weight = WV[::2]\n    value = WV[1::2]\n\n    w_min = min(weight)\n    items = [[] for _ in range(4)]\n    for w, v in zip(weight, value):\n        items[w - w_min].append(v)\n\n    for i in range(4):\n        items[i].sort(reverse=True)\n\n    csums = [0] * 4\n    for i in range(4):\n        csums[i] = [0]\n        csums[i].extend(accumulate(items[i]))\n\n    def rec(i, vec):\n        if i == 4:\n            ans = 0\n            w_total = 0\n            for j in range(4):\n                w_total += (w_min + j) * vec[j]\n            if w_total > W:\n                return -1\n            for j in range(4):\n                ans += csums[j][vec[j]]\n            return ans\n        ans = 0\n        for j in range(len(csums[i])):\n            vec.append(j)\n            ans = max(ans, rec(i + 1, vec))\n            vec.pop()\n        return ans\n\n    print((rec(0, [])))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    n, lim = MI()\n    ww = []\n    vv = []\n    for _ in range(n):\n        w, v = MI()\n        ww.append(w)\n        vv.append(v)\n    w0=ww[0]\n    # dp[i][j]\u2026\u8377\u7269\u306e\u500b\u6570\u304ci\u3067\u3001\u7aef\u6570\u306e\u5408\u8a08\u304cj\u306e\u3068\u304d\u306e\u4fa1\u5024\u306e\u6700\u5927\u5024\n    dp=[[0]*(3*n+1) for _ in range(n+1)]\n    for w,v in zip(ww,vv):\n        for i in range(n,0,-1):\n            sj=min(lim-i*w0,3*n)\n            for j in range(sj,-1,-1):\n                nj=j-(w-w0)\n                if nj<0:break\n                dp[i][j]=max(dp[i][j],dp[i-1][nj]+v)\n    #p2D(dp)\n    print(max(max(row) for row in dp))\n\nmain()\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,W = map(int, input().split())\n    w,v = [], []\n    for i in range(n):\n        a,b = map(int, input().split())\n        if i == 0:\n            w.append(a)\n        else:\n            w.append(a - w[0])\n        v.append(b)\n    #w1\u306e\u91cd\u3055\n    base = w[0]\n    w[0] = 0\n    w0, w1, w2, w3 = [], [], [], []\n    for i in range(n):\n        if w[i] == 0:\n            w0.append(v[i])\n        if w[i] == 1:\n            w1.append(v[i])\n        if w[i] == 2:\n            w2.append(v[i])\n        if w[i] == 3:\n            w3.append(v[i])\n    w0.sort(reverse=1)\n    w1.sort(reverse=1)\n    w2.sort(reverse=1)\n    w3.sort(reverse=1)\n    w0 = [0] + w0\n    w1 = [0] + w1\n    w2 = [0] + w2\n    w3 = [0] + w3\n    w0 = list(accumulate(w0))\n    w1 = list(accumulate(w1))\n    w2 = list(accumulate(w2))\n    w3 = list(accumulate(w3))\n\n    res = 0\n    for i in range(len(w0)):\n        for j in range(len(w1)):\n            for k in range(len(w2)):\n                for l in range(len(w3)):\n                    if base*(i+j+k+l) + j + k*2 + l*3 <= W:\n                        res = max(res, w0[i]+w1[j]+w2[k]+w3[l])\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import accumulate\n\nn, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(n)]\n\nw1 = wv[0][0]\nweights = [[] for _ in range(4)]\n\nfor w, v in wv:\n    w_diff = w - w1\n    weights[w_diff].append(v)\n\nfor i in range(4):\n    weights[i].sort(reverse=True)\n\nacc = [[0] + list(accumulate(li)) for li in weights]\n\nans = 0\nfor i, e1 in enumerate(acc[0]):\n    for j, e2 in enumerate(acc[1]):\n        for k, e3 in enumerate(acc[2]):\n            for l, e4 in enumerate(acc[3]):\n                if w1 * i + (w1 + 1) * j + (w1 + 2) * k + (w1 + 3) * l <= W:\n                    ans = max(ans, e1 + e2 + e3 + e4)\n\nprint(ans)\n", "# https://atcoder.jp/contests/abc060/tasks/arc073_b\n# \u5178\u578b\u7684\u306a\u30ca\u30c3\u30d7\u30b5\u30c3\u30af\u3002\u3060\u3051\u3069\u914d\u5217\u304c\u5927\u304d\u3044\u306e\u3067\u7d20\u76f4\u306b\u5b9f\u88c5\u3059\u308b\u3068TLE\u306b\u306a\u308b\n# \u6210\u7d04\u306b\u3088\u308a\u3001w1\u4ee5\u4e0a\u306f\u5fc5\u305a\u524d\u306ej\u3092\u898b\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3068\u30c6\u30fc\u30d6\u30eb\u306e\u30b5\u30a4\u30ba\u304c\u3050\u3063\u3068\u6e1b\u308b\u3053\u3068\u306b\u6c17\u304c\u3064\u304f\u304c\u3053\u308c\u3092\u5b9f\u88c5\u3059\u308b\u306e\u306f\u306a\u304b\u306a\u304b\u3081\u3093\u3069\u304f\u3055\u305d\u3046\u3002\n# defaltdict\u3092\u5229\u7528\u3057\u305f\u518d\u5e30\u30e1\u30e2\u5316\u306a\u3089\u6bd4\u8f03\u7684\u5b9f\u88c5\u53ef\u80fd\u3067\u306f\uff1f\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\ndef read_col(H, n_cols):\n    '''\n    H is number of rows\n    n_cols is number of cols\n    A\u5217\u3001B\u5217\u304c\u4e0e\u3048\u3089\u308c\u308b\u3088\u3046\u306a\u3068\u304d\n    '''\n    ret = [[] for _ in range(n_cols)]\n    for _ in range(H):\n        tmp = list(map(int, read().split()))\n        for col in range(n_cols):\n            ret[col].append(tmp[col])\n    return ret\n\n\nN, W = read_ints()\nw, v = read_col(N, 2)\n\nfrom collections import defaultdict\ndp = defaultdict(lambda: -1)\n\n\ndef f(i, j):  # i\u756a\u76ee\u3092\u542b\u3093\u3067\u8003\u616e\u3057\u305f\u3068\u304d\u91cd\u3055j\u307e\u3067\u3067\u9054\u6210\u3067\u304d\u308b\u4fa1\u5024\u306e\u6700\u5927\u5024\n    if dp[i, j] != -1:\n        return dp[i, j]\n    if i == -1:\n        return 0\n    if j - w[i] < 0:\n        return f(i - 1, j)\n\n    ret = max(f(i - 1, j - w[i]) + v[i], f(i - 1, j))\n    dp[i, j] = ret\n    return ret\n\n\nprint((f(N - 1, W)))\n", "def main():\n    N, W = list(map(int, input().split()))\n    WV = [tuple(map(int, input().split())) for _ in range(N)]\n    cur = {0: 0}\n    for w, v in WV:\n        keys = sorted(list(cur.keys()), reverse=True)\n        for k in keys:\n            if k + w > W:\n                continue\n            cur[k + w] = max(cur[k] + v, cur.get(k + w, 0))\n    return max(cur.values())\n\nprint((main()))\n", "def main():\n    N, W = list(map(int, input().split()))\n    l = []\n    w, v = list(map(int, input().split()))\n    ww = w\n    dp = [[[0] * (3*N) for _ in range(N+1) ]for _ in range(N)]\n    dp[0][1][0] = v\n    l.append((0, v))\n    for _ in range(N-1):\n        w, v = list(map(int, input().split()))\n        l.append((w-ww, v))\n    if W < ww:\n        return 0\n    for i in range(1, N):\n        w, v = l[i]\n        for j in range(1, N+1):\n            for k in range(w):\n                dp[i][j][k] = dp[i-1][j][k]\n            for k in range(w, 3*N):\n                dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-1][k-w] + v)\n    r = 0\n    for i in range(N+1):\n        wt = W - i * ww\n        if wt < 0:\n            break\n        r = max(r, max(dp[-1][i][:wt+1]))\n    return r\nprint((main()))\n", "import sys\ninput = sys.stdin.readline\nn,w=list(map(int,input().split()))\nw_sub,v_sub=list(map(int,input().split()))\nw0=w_sub\ninf=1000000001\nx=[[inf,v_sub],[inf],[inf],[inf]]\nfor i in range(n-1):\n    w_sub,v_sub=list(map(int,input().split()))\n    z=w_sub-w0\n    x[z].append(v_sub)\nfor i in range(4):\n    x[i].sort(key=lambda x:-x)\n    x[i][0]=0\n    l_sub=len(x[i])\n    for j in range(1,l_sub):\n        x[i][j]+=x[i][j-1]\n\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n,w=list(map(int,input().split()))\nwv=[tuple(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    x[z].append(k)\n#print(x)\n#print(w0)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma=max(ma,x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)])\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "N, W = list(map(int, input().split()))\nwv = []\n\nfor _ in range(N):\n    wv.append(tuple(map(int, input().split())))\n\n# dp[i][j] i \u756a\u76ee\u307e\u3067\u3001 \u91cd\u3055 j \u3067\u6700\u5927\u5316\u3057\u305f\u4fa1\u5024\n# \u7b54\u3048: dp[N][W]\n# \u521d\u671f: dp[0][j] = 0\n#       dp[i][0] = 0\n#\n# dp[i+1][j] = \u54c1\u7269i+1 \u3092\u4f7f\u308f\u306a\u3044\u5834\u5408\u3001 dp[i][j]\n#               \u54c1\u7269i+1 \u3092\u4f7f\u3046\u5834\u5408\u3001 dp[i][j-w_{i+1}] + v_{i+1}\n# i\n\nmemo = {}\n\ndef dfs(i, j):\n    if (i,j) in memo:\n        return memo[(i,j)]\n\n    if i < 0 or j <= 0:\n        return 0\n\n    ret = 0\n    wi, vi = wv[i]\n    if j-wi < 0:\n        ret = dfs(i-1, j)\n    else:\n        ret = max(dfs(i-1, j), dfs(i-1, j-wi) + vi)\n\n    memo[(i,j)] = ret\n\n    return ret\n\nprint((dfs(N-1, W)))\n", "n,w=map(int,input().split())\nkind=[[] for _ in range(4)]\nfor i in range(n):\n    w_,v=map(int,input().split())\n    if i==0:\n        stan=w_\n    kind[w_-stan].append(v)\nfor i in range(4):\n    kind[i].sort(reverse=True)\n    if len(kind[i])>=2:\n        for j in range(len(kind[i])-1):\n            kind[i][j+1]+=kind[i][j]\n    kind[i]=[0]+kind[i]\nans=0\nfor i in range(len(kind[0])):\n    for j in range(len(kind[1])):\n        for k in range(len(kind[2])):\n            for l in range(len(kind[3])):\n                if stan*i+(stan+1)*j+(stan+2)*k+(stan+3)*l<=w:\n                    ans=max(ans,kind[0][i]+kind[1][j]+kind[2][k]+kind[3][l])\nprint(ans)", "from collections import defaultdict\n\nn, W = list(map(int, input().split()))\nwv = [list(map(int, input().split())) for _ in range(n)]\n\ndp = defaultdict(int)\ndp[0] = 0\n\nfor w, v in wv:\n    for k in sorted(list(dp.keys()), reverse=True):\n        if k + w <= W:\n            dp[k + w] = max(dp[k + w], dp[k] + v)\n\nans = max(dp.values())\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nINF = 10**20\nMOD = 10**9 + 7\nsys.setrecursionlimit(100000000)\nfrom bisect import bisect_right\n\ndef main():\n    n,w = map(int,input().split())\n    minw,u = map(int,input().split())\n    item = {minw:[u],minw + 1:[],minw + 2:[], minw + 3:[]}\n    for _ in range(n - 1):\n        wei,u = map(int,input().split())\n        item[wei].append(u)\n    \n    l = [0] * 4\n    keys = sorted(item.keys())\n    i = 0\n    for k in keys:\n        item[k].sort(reverse = True)\n        l[i] = len(item[k])\n        i += 1\n    \n    X = set()\n    for i in range(l[0] + 1):\n        if i == 0:\n            cumsum = 0\n        else:\n            cumsum += item[minw][i - 1]\n        cumsumx = cumsum\n        for j in range(l[1] + 1):\n            weight = minw * i + (minw + 1) * j \n            if j != 0:\n                cumsumx += item[minw + 1][j - 1]\n            if weight <= w:\n                X.add((weight, cumsumx))\n\n    Y = []\n    for i in range(l[2] + 1):\n        if i == 0:\n            cumsum = 0\n        else:\n            cumsum += item[minw + 2][i - 1]\n        cumsumy = cumsum\n        for j in range(l[3] + 1):\n            weight = (minw + 2) * i + (minw + 3) * j\n            if j != 0:\n                cumsumy += item[minw  + 3][j - 1]\n            if weight <= w:\n                Y.append((weight, cumsumy))\n    \n    Y.sort(key = lambda x:x[0])\n    Yw = [0] * len(Y)\n    cummax = [0] * len(Y)\n    for i in range(len(Y)):\n        if i == 0:\n            cummax[i] = Y[i][1]\n            Yw[i] = Y[i][0]\n        else:\n            cummax[i] = max(cummax[i - 1],Y[i][1])\n            Yw[i] = Y[i][0]\n    \n    ans = 0\n    for x in X:\n        wei,va = x\n        idx = bisect_right(Yw,w - wei)\n        if idx == 0:\n            continue\n        else:\n            ans = max(ans,cummax[idx - 1] + va)\n    \n    print(ans)\n    \n    \ndef __starting_point():\n    main() \n__starting_point()", "n,w=list(map(int,input().split()))\nwv=[list(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    m=min(d//w0,l0-1)\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][m]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n,w=list(map(int,input().split()))\nwv=[list(map(int,input().split())) for i in range(n)]\nwv.sort(key=lambda x:-x[1])#reverse\nwv.sort(key=lambda x:x[0])\n#print(wv)\nw0=wv[0][0]\nx=[[0],[0],[0],[0]]\nfor i in range(n):\n    z=wv[i][0]-w0\n    k=wv[i][1]+x[z][-1]\n    l=len(x[z])\n    if l*wv[i][0]<=w:\n        x[z].append(k)\nma=0\nl3=len(x[3])\nl2=len(x[2])\nl1=len(x[1])\nl0=len(x[0])\nfor i in range(l3):\n    for j in range(l2):\n        d=w-i*(w0+3)-j*(w0+2)\n        if d>=0:\n            for k in range(l1):\n                d=w-i*(w0+3)-j*(w0+2)-k*(w0+1)\n                if d>=0:\n                    ma_sub=x[3][i]+x[2][j]+x[1][k]+x[0][min(d//w0,l0-1)]\n                    ma=max(ma,ma_sub)\n                else:\n                    break\n        else:\n            break\n\nprint(ma)\n", "n,W=map(int,input().split())\nw=[0 for i in range(n)]\nv=[[] for i in range(4)]\ndp=[[0] for i in range(4)]\nfor i in range(n):\n  w[i],vi=map(int,input().split())\n  v[w[i]-w[0]].append(vi)\nfor i in range(4):\n  v[i].sort(reverse=True)\n  for j in v[i]:\n    dp[i].append(dp[i][-1]+j)\ndef dfs(i,cost):\n  if cost>W:\n    return -10**10\n  elif i==4:\n    return 0\n  else:\n    val=0\n    for j in range(len(dp[i])):\n      val=max(val,dp[i][j]+dfs(i+1,cost+j*(w[0]+i)))\n    return val\nprint(dfs(0,0))", "n,W=map(int,input().split())\nwv=[list(map(int,input().split())) for _ in range(n)]\nfrom collections import Counter\nw0=wv[0][0]\nd={w0:[0],w0+1:[0],w0+2:[0],w0+3:[0],}\nfor w,v in wv:\n  d[w].append(v)\nfor i in range(4):\n  d[w0+i].sort(reverse=True)\nsd={}\nfor i in range(4):\n  tmp=0\n  sd[w0+i]=[0]\n  for v in d[w0+i]:\n    tmp+=v\n    sd[w0+i].append(tmp)\nans=0\nfor i in range(len(d[w0])):\n  for j in range(len(d[w0+1])):\n    for k in range(len(d[w0+2])):\n      for l in range(len(d[w0+3])):\n        if w0*i+(w0+1)*j+(w0+2)*k+(w0+3)*l<=W:\n          ans=max(ans,sd[w0][i]+sd[w0+1][j]+sd[w0+2][k]+sd[w0+3][l])\nprint(ans)"]
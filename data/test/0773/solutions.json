["#~ # MAGIC CODEFORCES PYTHON FAST IO\nimport atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n#~ # END OF MAGIC CODEFORCES PYTHON FAST IO\n\nclass Arista():\n\tdef __init__(self,salida,llegada,capacidad,flujo,costo,indice):\n\t\tself.salida = salida\n\t\tself.llegada = llegada\n\t\tself.capacidad = capacidad\n\t\tself.flujo = flujo\n\t\tself.costo = costo\n\t\tself.indice = indice\n\t\t\n\tdef __str__(self):\n\t\ts = \"\"\n\t\ts = s + \"salida =\" + str(self.salida) + \"\\n\"\n\t\ts = s + \"llegada =\" + str(self.llegada) + \"\\n\"\n\t\ts = s + \"capacidad =\" + str(self.capacidad) + \"\\n\"\n\t\ts = s + \"flujo =\" + str(self.flujo) + \"\\n\"\n\t\ts = s + \"costo =\" + str(self.costo) + \"\\n\"\n\t\ts = s + \"indice =\" + str(self.indice) + \"\\n\"\n\t\ts = s + \"------------\"\n\t\treturn s\n\t\t\n\t\t\nclass Red(): \n\t## Representacion de una Red de flujo ##\n\tdef __init__(self,s,t): # Crea una red vacio\n\t\tself.lista_aristas = []\n\t\tself.lista_adyacencia = {}\n\t\tself.vertices = set()\n\t\tself.fuente = s\n\t\tself.sumidero = t\n\t\t\n\tdef agregar_vertice(self,vertice):\n\t\tself.vertices.add(vertice)\n\t\t\n\tdef agregar_arista(self,arista): \n\t\tself.vertices.add(arista.salida)\n\t\tself.vertices.add(arista.llegada)\n\t\tself.lista_aristas.append(arista)\n\t\tif arista.salida not in self.lista_adyacencia:\n\t\t\tself.lista_adyacencia[arista.salida] = set()\n\t\tself.lista_adyacencia[arista.salida].add(arista.indice)\n\t\t\t\n\tdef agregar_lista_aristas(self,lista_aristas):\n\t\tfor arista in lista_aristas:\n\t\t\tself.agregar_arista(arista)\n\t\t\t\n\tdef cantidad_de_vertices(self):\n\t\treturn len(self.vertices)\n\t\n\tdef vecinos(self,vertice):\n\t\tif vertice not in self.lista_adyacencia:\n\t\t\treturn set()\n\t\telse:\n\t\t\treturn self.lista_adyacencia[vertice]\n\t\n\tdef buscar_valor_critico(self,padre):\n\t\tINFINITO = 1000000000\n\t\tvalor_critico = INFINITO\n\t\tactual = self.sumidero\n\t\twhile actual != self.fuente:\n\t\t\tarista_camino = self.lista_aristas[padre[actual]]\n\t\t\tvalor_critico = min(valor_critico,arista_camino.capacidad - arista_camino.flujo)\n\t\t\tactual = arista_camino.salida\n\t\treturn valor_critico\n\t\n\tdef actualizar_camino(self,padre,valor_critico):\n\t\tactual = self.sumidero\n\t\tcosto_actual = 0\n\t\twhile actual != self.fuente:\n\t\t\tself.lista_aristas[padre[actual]].flujo += valor_critico\n\t\t\tself.lista_aristas[padre[actual]^1].flujo -= valor_critico\n\t\t\tcosto_actual += valor_critico*self.lista_aristas[padre[actual]].costo\n\t\t\tactual = self.lista_aristas[padre[actual]].salida\n\t\treturn costo_actual,True\t\n\t\t\n\tdef camino_de_aumento(self):\n\t\tINFINITO = 1000000000\n\t\tdistancia = {v:INFINITO for v in self.vertices}\n\t\tpadre = {v:-1 for v in self.vertices}\n\t\tdistancia[self.fuente] = 0\n\t\t#~ for iteracion in range(len(self.vertices)-1):\n\t\t\t#~ for arista in self.lista_aristas:\n\t\t\t\t#~ if arista.flujo < arista.capacidad and distancia[arista.salida] + arista.costo < distancia[arista.llegada]:\n\t\t\t\t\t#~ distancia[arista.llegada] = distancia[arista.salida] + arista.costo\n\t\t\t\t\t#~ padre[arista.llegada] = arista.indice\n\t\tcapa_actual,capa_nueva = set([self.fuente]),set()\n\t\twhile capa_actual:\n\t\t\tfor v in capa_actual:\n\t\t\t\tfor arista_indice in self.vecinos(v):\n\t\t\t\t\tarista = self.lista_aristas[arista_indice]\n\t\t\t\t\tif arista.flujo < arista.capacidad and distancia[arista.salida] + arista.costo < distancia[arista.llegada]: \n\t\t\t\t\t\tdistancia[arista.llegada] = distancia[arista.salida] + arista.costo\n\t\t\t\t\t\tpadre[arista.llegada] = arista.indice\n\t\t\t\t\t\tcapa_nueva.add(arista.llegada)\n\t\t\tcapa_actual = set()\n\t\t\tcapa_actual,capa_nueva = capa_nueva,capa_actual\n\t\t\t\t\n\t\tif distancia[self.sumidero] < INFINITO:\n\t\t\tvalor_critico = self.buscar_valor_critico(padre)\n\t\t\tcosto_actual,hay_camino = self.actualizar_camino(padre,valor_critico)\n\t\t\treturn valor_critico,costo_actual,hay_camino\n\t\telse:\n\t\t\treturn -1,-1,False\n\t\t\t\n\t\t\t\n\tdef max_flow_min_cost(self):\n\t\tflujo_total = 0\n\t\tcosto_total = 0\n\t\thay_camino = True\n\t\twhile hay_camino:\n\t\t\t#~ for x in self.lista_aristas:\n\t\t\t\t#~ print(x)\n\t\t\t\n\t\t\tflujo_actual,costo_actual,hay_camino = self.camino_de_aumento()\n\t\t\tif hay_camino:\n\t\t\t\tflujo_total += flujo_actual\n\t\t\t\tcosto_total += costo_actual\n\t\treturn flujo_total,costo_total\n\t\t\n\t\nINFINITO = 10000000000000\t\nn,q = list(map(int,input().split()))\nmaxi = [n for i in range(n)]\nmini = [1 for i in range(n)]\nR = Red(0,2*n+1)\nprohibidos = {i:set() for i in range(n)}\nfor i in range(n):\n\tfor k in range(n+1):\n\t\tR.agregar_arista(Arista(R.fuente,i+1,1,0,2*k+1,len(R.lista_aristas)))\n\t\tR.agregar_arista(Arista(i+1,R.fuente,0,0,-2*k-1,len(R.lista_aristas)))\n\nfor j in range(n):\n\tR.agregar_arista(Arista(n+j+1,R.sumidero,1,0,0,len(R.lista_aristas)))\n\tR.agregar_arista(Arista(R.sumidero,n+j+1,0,0,0,len(R.lista_aristas)))\n\nfor z in range(q):\n\tt,l,r,v = list(map(int,input().split()))\n\tif t == 1:\n\t\tfor i in range(v-1):\n\t\t\tfor j in range(l,r+1):\n\t\t\t\tprohibidos[i].add(j)\n\telse:\n\t\tfor i in range(v,n):\n\t\t\tfor j in range(l,r+1):\n\t\t\t\tprohibidos[i].add(j)\n\t\t\n\t\t\n\nfor i in range(n):\n\tfor j in range(mini[i],maxi[i]+1):\n\t\tif j not in prohibidos[i]:\n\t\t\tR.agregar_arista(Arista(i+1,n+j,1,0,0,len(R.lista_aristas)))\n\t\t\tR.agregar_arista(Arista(n+j,i+1,0,0,0,len(R.lista_aristas)))\t\t\n\t\t\nflujo_total,costo_total = R.max_flow_min_cost()\n#~ print(flujo_total,costo_total)\nif flujo_total < n:\n\tprint(\"-1\")\nelse:\n\tprint(costo_total)\t\t\n\t\t\n\n\t\t\n\t\n\t\t\t\n\t\t\n\n\n", "from collections import deque\nfrom heapq import heappop, heappush\n \nclass Edge(object):\n    __slots__ = ('x', 'y', 'cap', 'cost', 'inv')\n    def __repr__(self):\n        return f'{self.x}-->{self.y} ({self.cap} , {self.cost})'\n\n\nclass MCFP():\n    def __init__(self):\n        self.G = []\n    \n    def add(self, x, y, cap, cost):\n        G = self.G\n        G.extend(([] for i in range(max(0,max(x,y)+1-len(G)))))\n        e = Edge()\n        e.x=x ; e.y=y; e.cap=cap; e.cost=cost\n        z = Edge()\n        z.x=y ; z.y=x; z.cap=0; z.cost=-cost\n        e.inv=z ; z.inv=e\n        G[x].append(e)\n        G[y].append(z)\n \n    def solve(self, src, tgt, inf=float('inf')):\n        n, G = len(self.G), self.G\n        flowVal = flowCost = 0\n        phi = [0]*n\n        prev = [None]*n\n        inQ = [0]*n\n        cntQ = 1\n        dist = [inf]*n\n        while 1:\n            self.shortest(src, phi, prev, inQ, dist, inf, cntQ)\n            if prev[tgt] == None:\n                break\n            z = inf\n            x = tgt\n            while x!=src:\n                e = prev[x]\n                z = min(z, e.cap)\n                x = e.x\n            x = tgt\n            while x!=src:\n                e = prev[x]\n                e.cap -= z\n                e.inv.cap += z\n                x = e.x\n            flowVal += z\n            flowCost += z * (dist[tgt] - phi[src] + phi[tgt])\n            for i in range(n):\n                if prev[i] != None:\n                    phi[i] += dist[i]\n                    dist[i] = inf\n            cntQ += 1\n            prev[tgt] = None\n        return flowVal, flowCost\n\n    def shortest(self, src, phi, prev, inQ, dist, inf, cntQ):\n        n, G = len(self.G), self.G\n        Q = [(dist[src],src)]\n        inQ[src] = cntQ\n        dist[src] = 0\n        while Q:\n            _, x = heappop(Q)\n            inQ[x] = 0\n            dx = dist[x]+phi[x]\n            for e in G[x]:\n                y = e.y\n                dy = dx + e.cost - phi[y]\n                if e.cap > 0 and dy < dist[y]:\n                    dist[y] = dy\n                    prev[y] = e\n                    if inQ[y] != cntQ:\n                        inQ[y] = cntQ\n                        heappush(Q, (dy, y))\n        return dist, prev\n \n    def __repr__(self):\n        n, G = len(self.G), self.G\n        s = []\n        for i in range(n):\n            s.append('    G[{}]:'.format(i))\n            s.append('\\n'.join('        {}'.format(e) for e in G[i]))\n        return '\\n'.join(s)\n\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\nsys.setrecursionlimit(3000)\n\ndef main():\n    n, q = (next(ints) for i in range(2))\n    leq = [n-1]*n\n    geq = [0]*n\n    for q in range(q):\n        t,l,r,v = (next(ints) for i in range(4))\n        for i in range(l-1, r):\n            if t==1: geq[i] = max(geq[i], v-1)\n            if t==2: leq[i] = min(leq[i], v-1)\n    imp = any(geq[i]>leq[i] for i in range(n))\n    if imp:\n        ans = -1\n    else:\n        src = 2*n+n*n\n        tgt = 2*n+n*n+1\n        G = MCFP()\n        for i in range(n):\n            G.add(src, i, 1, 0)\n        for i in range(n):\n            for j in range(geq[i], leq[i]+1):\n                G.add(i, j+n, 1, 0)\n        for i in range(n):\n            for j in range(n):\n                G.add(i+n, 2*n+i*n+j, 1, 0)\n                G.add(2*n+i*n+j, tgt, 1, 2*j+1)\n        _, ans = G.solve(src, tgt)\n        #print(G)\n        #print(leq, geq)\n    print(ans)\n    return\n\nmain()\n", "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\nclass MinCostFlowwithDijkstra:\n    INF = 1<<60\n    \n    def __init__(self, N):\n        self.N = N\n        self.Edge = [[] for _ in range(N)]\n    \n    def add_edge(self, st, en, cap, cost):\n        self.Edge[st].append([en, cap, cost, len(self.Edge[en])])\n        self.Edge[en].append([st, 0, -cost, len(self.Edge[st])-1])\n    \n    def get_mf(self, so, si, fl):\n        N = self.N\n        INF = self.INF\n        res = 0\n        Pot = [0]*N\n        geta = N\n        \n        \n        prv = [None]*N\n        prenum = [None]*N\n        while fl:\n            dist = [INF]*N\n            dist[so] = 0\n            Q = [so]\n            \n            while Q:\n                cost, vn = divmod(hpp(Q), geta)\n                if dist[vn] < cost:\n                    continue\n                \n                for enum in range(len(self.Edge[vn])):\n                    vf, cap, cost, _ = self.Edge[vn][enum]\n                    cc = dist[vn] + cost - Pot[vn] + Pot[vf]\n                    if cap > 0 and dist[vf] > cc:\n                        dist[vf] = cc\n                        prv[vf] = vn\n                        prenum[vf] = enum\n                        hp(Q, cc*geta + vf)\n            \n            if dist[si] == INF:\n                return -1\n            \n            for i in range(N):\n                Pot[i] -= dist[i]\n            \n            cfl = fl\n            vf = si\n            while vf != so:\n                cfl = min(cfl, self.Edge[prv[vf]][prenum[vf]][1])\n                vf = prv[vf]\n            \n            fl -= cfl\n            res -= cfl*Pot[si]\n            vf = si\n            while vf != so:\n                e = self.Edge[prv[vf]][prenum[vf]]\n                e[1] -= cfl\n                self.Edge[vf][e[3]][1] += cfl\n                vf = prv[vf]\n        return res\n\nN, Q = list(map(int, readline().split()))\nT = MinCostFlowwithDijkstra(2*N+2)\ngeta = N\n\ncandi = [set(range(N)) for _ in range(N)]\n\nfor _ in range(Q):\n    t, l, r, v = list(map(int, readline().split()))\n    l -= 1\n    r -= 1\n    v -= 1\n    if t == 1:\n        for vn in range(l, r+1):\n            for i in range(v-1, -1, -1):\n                if i in candi[vn]:\n                    candi[vn].remove(i)\n    else:\n        for vn in range(l, r+1):\n            for i in range(v+1, N):\n                if i in candi[vn]:\n                    candi[vn].remove(i)\n\nif not all(candi):\n    print(-1)\nelse:\n    source = 2*N\n    sink = 2*N + 1\n    for i in range(N):\n        T.add_edge(source, i, 1, 0)\n        for v in candi[i]:\n            T.add_edge(i, geta+v, 1, 0)\n        for j in range(N):\n            T.add_edge(i+geta, sink, 1, 2*j+1)\n    print(T.get_mf(source, sink, N))\n", "import sys\n\ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tAUX = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tAUX.append(p[1])\n\t\t\t\t\n\t\twhile AUX and min(AUX) < x:\n\t\t\tAUX.remove(min(AUX))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif AUX:\n\t\t\t\tAUX.remove(min(AUX))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n\nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tfor x in range(n):\n\t\t\tfor y in range(n):\n\t\t\t\tif cnt[x] > cnt[y]+1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair \n\t\n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n", "import sys\n\ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tAUX = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tAUX.append(p[1])\n\t\t\t\t\n\t\twhile AUX and min(AUX) < x:\n\t\t\tAUX.remove(min(AUX))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif AUX:\n\t\t\t\tAUX.remove(min(AUX))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n\nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tfor x in range(n):\n\t\t\tfor y in range(n):\n\t\t\t\tif cnt[x] > cnt[y]+1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair \n\t\t\t\t\tif had_pair:\n\t\t\t\t\t\tbreak\n\t\t\tif had_pair:\n\t\t\t\tbreak\n\t\n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n", "import sys\n\ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tAUX = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tAUX.append(p[1])\n\t\t\t\t\n\t\twhile AUX and min(AUX) < x:\n\t\t\tAUX.remove(min(AUX))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif AUX:\n\t\t\t\tAUX.remove(min(AUX))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n\nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tfor x in range(n-1,-1,-1):\n\t\t\tfor y in range(n-1,-1,-1):\n\t\t\t\tif cnt[x] > cnt[y]+1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair \n\t\t\t\t\n\t\n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n", "import sys\nfrom random import seed,shuffle\n\nseed(25)\n\ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tAUX = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tAUX.append(p[1])\n\t\twhile AUX and min(AUX) < x:\n\t\t\tAUX.remove(min(AUX))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif AUX:\n\t\t\t\tAUX.remove(min(AUX))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n\nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tAUX = list(range(n))\n\t\tshuffle(AUX)\n\t\tfor x in AUX:\n\t\t\tAUX_2 = list(range(n))\n\t\t\tshuffle(AUX_2)\n\t\t\tfor y in AUX_2:\n\t\t\t\tif cnt[x] > cnt[y]+1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair \n\t\t\t\t\n\t\n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n", "import sys\n\ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tright = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tright.append(p[1])\n\t\t\t\t\n\t\twhile right and min(right) < x:\n\t\t\tright.remove(min(right))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif right:\n\t\t\t\tright.remove(min(right))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n\n\nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tfor x in range(n):\n\t\t\tfor y in range(n):\n\t\t\t\tif cnt[x] > cnt[y]+1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair \n\t\n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n", "import sys\n \ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tright = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tright.append(p[1])\n\t\t\t\t\n\t\twhile right and min(right) < x:\n\t\t\tright.remove(min(right))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif right:\n\t\t\t\tright.remove(min(right))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n \n \nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:0 for x in range(n)}\n\tfor y in range(n):\n\t\tfor x in range(n):\n\t\t\tif cnt[x] == y:\n\t\t\t\tcnt[x] += 1\n\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\tcnt[x] -= 1 \n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n"]
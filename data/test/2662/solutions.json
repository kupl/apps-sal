["from bisect import bisect_right\n\n\ndef main():\n    n = int(input())\n    a = [int(input()) for _ in range(n)]\n    a.reverse()\n    lis = [a[0]]\n    for i in range(1, n):\n        if a[i] >= lis[-1]:\n            lis.append(a[i])\n        else:\n            lis[bisect_right(lis, a[i])] = a[i]\n    print((len(lis)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\"\"\"Sorted List\n==============\n:doc:`Sorted Containers<index>` is an Apache2 licensed Python sorted\ncollections library, written in pure-Python, and fast as C-extensions. The\n:doc:`introduction<introduction>` is the best way to get started.\nSorted list implementations:\n.. currentmodule:: sortedcontainers\n* :class:`SortedList`\n* :class:`SortedKeyList`\n\"\"\"\n# pylint: disable=too-many-lines\n\n\nimport sys\nimport traceback\nfrom bisect import bisect_left, bisect_right, insort\nfrom itertools import chain, repeat, starmap\nfrom math import log\nfrom operator import add, eq, ne, gt, ge, lt, le, iadd\nfrom textwrap import dedent\nfrom collections.abc import Sequence, MutableSequence, ItemsView, KeysView, ValuesView, MutableSet, Set\nfrom functools import wraps, reduce\nfrom _thread import get_ident\n\n\ndef recursive_repr(fillvalue='...'):\n    \"Decorator to make a repr function return fillvalue for a recursive call.\"\n    # pylint: disable=missing-docstring\n    # Copied from reprlib in Python 3\n    # https://hg.python.org/cpython/file/3.6/Lib/reprlib.py\n\n    def decorating_function(user_function):\n        repr_running = set()\n\n        @wraps(user_function)\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                result = user_function(self)\n            finally:\n                repr_running.discard(key)\n            return result\n\n        return wrapper\n\n    return decorating_function\n\n###############################################################################\n# END Python 2/3 Shims\n###############################################################################\n\n\nclass SortedList(MutableSequence):\n    \"\"\"Sorted list is a sorted mutable sequence.\n    Sorted list values are maintained in sorted order.\n    Sorted list values must be comparable. The total ordering of values must\n    not change while they are stored in the sorted list.\n    Methods for adding values:\n    * :func:`SortedList.add`\n    * :func:`SortedList.update`\n    * :func:`SortedList.__add__`\n    * :func:`SortedList.__iadd__`\n    * :func:`SortedList.__mul__`\n    * :func:`SortedList.__imul__`\n    Methods for removing values:\n    * :func:`SortedList.clear`\n    * :func:`SortedList.discard`\n    * :func:`SortedList.remove`\n    * :func:`SortedList.pop`\n    * :func:`SortedList.__delitem__`\n    Methods for looking up values:\n    * :func:`SortedList.bisect_left`\n    * :func:`SortedList.bisect_right`\n    * :func:`SortedList.count`\n    * :func:`SortedList.index`\n    * :func:`SortedList.__contains__`\n    * :func:`SortedList.__getitem__`\n    Methods for iterating values:\n    * :func:`SortedList.irange`\n    * :func:`SortedList.islice`\n    * :func:`SortedList.__iter__`\n    * :func:`SortedList.__reversed__`\n    Methods for miscellany:\n    * :func:`SortedList.copy`\n    * :func:`SortedList.__len__`\n    * :func:`SortedList.__repr__`\n    * :func:`SortedList._check`\n    * :func:`SortedList._reset`\n    Sorted lists use lexicographical ordering semantics when compared to other\n    sequences.\n    Some methods of mutable sequences are not supported and will raise\n    not-implemented error.\n    \"\"\"\n    DEFAULT_LOAD_FACTOR = 1000\n\n    def __init__(self, iterable=None, key=None):\n        \"\"\"Initialize sorted list instance.\n        Optional `iterable` argument provides an initial iterable of values to\n        initialize the sorted list.\n        Runtime complexity: `O(n*log(n))`\n        >>> sl = SortedList()\n        >>> sl\n        SortedList([])\n        >>> sl = SortedList([3, 1, 2, 5, 4])\n        >>> sl\n        SortedList([1, 2, 3, 4, 5])\n        :param iterable: initial values (optional)\n        \"\"\"\n        assert key is None\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=None):\n        \"\"\"Create new sorted list or sorted-key list instance.\n        Optional `key`-function argument will return an instance of subtype\n        :class:`SortedKeyList`.\n        >>> sl = SortedList()\n        >>> isinstance(sl, SortedList)\n        True\n        >>> sl = SortedList(key=lambda x: -x)\n        >>> isinstance(sl, SortedList)\n        True\n        >>> isinstance(sl, SortedKeyList)\n        True\n        :param iterable: initial values (optional)\n        :param key: function used to extract comparison key (optional)\n        :return: sorted list or sorted-key list instance\n        \"\"\"\n        # pylint: disable=unused-argument\n        if key is None:\n            return object.__new__(cls)\n        else:\n            if cls is SortedList:\n                return object.__new__(SortedKeyList)\n            else:\n                raise TypeError('inherit SortedKeyList for key argument')\n\n    @property\n    def key(self):  # pylint: disable=useless-return\n        \"\"\"Function used to extract comparison key from values.\n        Sorted list compares values directly so the key function is none.\n        \"\"\"\n        return None\n\n    def _reset(self, load):\n        \"\"\"Reset sorted list load factor.\n        The `load` specifies the load-factor of the list. The default load\n        factor of 1000 works well for lists from tens to tens-of-millions of\n        values. Good practice is to use a value that is the cube root of the\n        list size. With billions of elements, the best load factor depends on\n        your usage. It's best to leave the load factor at the default until you\n        start benchmarking.\n        See :doc:`implementation` and :doc:`performance-scale` for more\n        information.\n        Runtime complexity: `O(n)`\n        :param int load: load-factor for sorted list sublists\n        \"\"\"\n        values = reduce(iadd, self._lists, [])\n        self._clear()\n        self._load = load\n        self._update(values)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    _clear = clear\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList()\n        >>> sl.add(3)\n        >>> sl.add(1)\n        >>> sl.add(2)\n        >>> sl\n        SortedList([1, 2, 3])\n        :param value: value to add to sorted list\n        \"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\n        Updates the index when the sublist length is less than double the load\n        level. This requires incrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n        \"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\n        Runtime complexity: `O(k*log(n))` -- approximate.\n        >>> sl = SortedList()\n        >>> sl.update([3, 1, 2])\n        >>> sl\n        SortedList([1, 2, 3])\n        :param iterable: iterable of values to add\n        \"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\n        ``sl.__contains__(value)`` <==> ``value in sl``\n        Runtime complexity: `O(log(n))`\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> 3 in sl\n        True\n        :param value: search for value in sorted list\n        :return: true if `value` in sorted list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        return _lists[pos][idx] == value\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\n        If `value` is not a member, do nothing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> sl.discard(5)\n        >>> sl.discard(0)\n        >>> sl == [1, 2, 3, 4]\n        True\n        :param value: `value` to discard from sorted list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\n        If `value` is not a member, raise ValueError.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList([1, 2, 3, 4, 5])\n        >>> sl.remove(5)\n        >>> sl == [1, 2, 3, 4]\n        True\n        >>> sl.remove(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 not in list\n        :param value: `value` to remove from sorted list\n        :raises ValueError: if `value` is not in sorted list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError('{0!r} not in list'.format(value))\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            raise ValueError('{0!r} not in list'.format(value))\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n        else:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\n        Combines lists that are less than half the load level.\n        Updates the index when the sublist length is more than half the load\n        level. This requires decrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n        :param int pos: lists index\n        :param int idx: sublist index\n        \"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\n        Many queries require the index be built. Details of the index are\n        described in ``SortedList._build_index``.\n        Indexing requires traversing the tree from a leaf node to the root. The\n        parent of each node is easily computable at ``(pos - 1) // 2``.\n        Left-child nodes are always at odd indices and right-child nodes are\n        always at even indices.\n        When traversing up from a right-child node, increment the total by the\n        left-child node.\n        The final index is the sum from traversal and the index in the sublist.\n        For example, using the index from ``SortedList._build_index``::\n            _index = 14 5 9 3 2 4 5\n            _offset = 3\n        Tree::\n                 14\n              5\t  9\n            3   2  4   5\n        Converting an index pair (2, 3) into a single index involves iterating\n        like so:\n        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify\n           the node as a left-child node. At such nodes, we simply traverse to\n           the parent.\n        2. At node 9, position 2, we recognize the node as a right-child node\n           and accumulate the left-child in our total. Total is now 5 and we\n           traverse to the parent at position 0.\n        3. Iteration ends at the root.\n        The index is then the sum of the total and sublist index: 5 + 3 = 8.\n        :param int pos: lists index\n        :param int idx: sublist index\n        :return: index in sorted list\n        \"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        total = 0\n\n        # Increment pos to point in the index to len(self._lists[pos]).\n\n        pos += self._offset\n\n        # Iterate until reaching the root of the index tree at pos = 0.\n\n        while pos:\n\n            # Right-child nodes are at odd indices. At such indices\n            # account the total below the left child node.\n\n            if not pos & 1:\n                total += _index[pos - 1]\n\n            # Advance pos to the parent node.\n\n            pos = (pos - 1) >> 1\n\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\n        Many queries require the index be built. Details of the index are\n        described in ``SortedList._build_index``.\n        Indexing requires traversing the tree to a leaf node. Each node has two\n        children which are easily computable. Given an index, pos, the\n        left-child is at ``pos * 2 + 1`` and the right-child is at ``pos * 2 +\n        2``.\n        When the index is less than the left-child, traversal moves to the\n        left sub-tree. Otherwise, the index is decremented by the left-child\n        and traversal moves to the right sub-tree.\n        At a child node, the indexing pair is computed from the relative\n        position of the child node as compared with the offset and the remaining\n        index.\n        For example, using the index from ``SortedList._build_index``::\n            _index = 14 5 9 3 2 4 5\n            _offset = 3\n        Tree::\n                 14\n              5\t  9\n            3   2  4   5\n        Indexing position 8 involves iterating like so:\n        1. Starting at the root, position 0, 8 is compared with the left-child\n           node (5) which it is greater than. When greater the index is\n           decremented and the position is updated to the right child node.\n        2. At node 9 with index 3, we again compare the index to the left-child\n           node with value 4. Because the index is the less than the left-child\n           node, we simply traverse to the left.\n        3. At node 4 with index 3, we recognize that we are at a leaf node and\n           stop iterating.\n        4. To compute the sublist index, we subtract the offset from the index\n           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we\n           simply use the index remaining from iteration. In this case, 3.\n        The final index pair from our example is (2, 3) which corresponds to\n        index 8 in the sorted list.\n        :param int idx: index in sorted list\n        :return: (lists index, sublist index) pair\n        \"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n\n            idx += self._len\n\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n\n        while child < len_index:\n            index_child = _index[child]\n\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n\n            child = (pos << 1) + 1\n\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\n        Indexes are represented as binary trees in a dense array notation\n        similar to a binary heap.\n        For example, given a lists representation storing integers::\n            0: [1, 2, 3]\n            1: [4, 5]\n            2: [6, 7, 8, 9]\n            3: [10, 11, 12, 13, 14]\n        The first transformation maps the sub-lists by their length. The\n        first row of the index is the length of the sub-lists::\n            0: [3, 2, 4, 5]\n        Each row after that is the sum of consecutive pairs of the previous\n        row::\n            1: [5, 9]\n            2: [14]\n        Finally, the index is built by concatenating these lists together::\n            _index = [14, 5, 9, 3, 2, 4, 5]\n        An offset storing the start of the first row is also stored::\n            _offset = 3\n        When built, the index can be used for efficient indexing into the list.\n        See the comment and notes on ``SortedList._pos`` for details.\n        \"\"\"\n        row0 = list(map(len, self._lists))\n\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(add, zip(head, tail)))\n\n        if len(row0) & 1:\n            row1.append(row0[-1])\n\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 2 ** (int(log(len(row1) - 1, 2)) + 1)\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(add, zip(head, tail)))\n            tree.append(row)\n\n        reduce(iadd, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\n        ``sl.__delitem__(index)`` <==> ``del sl[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList('abcde')\n        >>> del sl[2]\n        >>> sl\n        SortedList(['a', 'b', 'd', 'e'])\n        >>> del sl[:2]\n        >>> sl\n        SortedList(['d', 'e'])\n        :param index: integer or slice for indexing\n        :raises IndexError: if index out of range\n        \"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self._clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self._getitem(slice(None, start))\n                    if stop < self._len:\n                        values += self._getitem(slice(stop, None))\n                    self._clear()\n                    return self._update(values)\n\n            indices = range(start, stop, step)\n\n            # Delete items from greatest index to least so\n            # that the indices remain valid throughout iteration.\n\n            if step > 0:\n                indices = reversed(indices)\n\n            _pos, _delete = self._pos, self._delete\n\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\n        ``sl.__getitem__(index)`` <==> ``sl[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList('abcde')\n        >>> sl[1]\n        'b'\n        >>> sl[-1]\n        'e'\n        >>> sl[2:5]\n        ['c', 'd', 'e']\n        :param index: integer or slice for indexing\n        :return: value or list of values\n        :raises IndexError: if index out of range\n        \"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                # Whole slice optimization: start to stop slices the whole\n                # sorted list.\n\n                if start == 0 and stop == self._len:\n                    return reduce(iadd, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                start_list = _lists[start_pos]\n                stop_idx = start_idx + stop - start\n\n                # Small slice optimization: start index and stop index are\n                # within the start list.\n\n                if len(start_list) >= stop_idx:\n                    return start_list[start_idx:stop_idx]\n\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(iadd, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n\n                return result\n\n            if step == -1 and start > stop:\n                result = self._getitem(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            # Return a list because a negative step could\n            # reverse the order of the items and this could\n            # be the desired behavior.\n\n            indices = range(start, stop, step)\n            return list(self._getitem(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    _getitem = __getitem__\n\n    def __setitem__(self, index, value):\n        \"\"\"Raise not-implemented error.\n        ``sl.__setitem__(index, value)`` <==> ``sl[index] = value``\n        :raises NotImplementedError: use ``del sl[index]`` and\n            ``sl.add(value)`` instead\n        \"\"\"\n        message = 'use ``del sl[index]`` and ``sl.add(value)`` instead'\n        raise NotImplementedError(message)\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\n        ``sl.__iter__()`` <==> ``iter(sl)``\n        Iterating the sorted list while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n        \"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\n        ``sl.__reversed__()`` <==> ``reversed(sl)``\n        Iterating the sorted list while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n        \"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def reverse(self):\n        \"\"\"Raise not-implemented error.\n        Sorted list maintains values in ascending sort order. Values may not be\n        reversed in-place.\n        Use ``reversed(sl)`` for an iterator over values in descending sort\n        order.\n        Implemented to override `MutableSequence.reverse` which provides an\n        erroneous default implementation.\n        :raises NotImplementedError: use ``reversed(sl)`` instead\n        \"\"\"\n        raise NotImplementedError('use ``reversed(sl)`` instead')\n\n    def islice(self, start=None, stop=None, reverse=False):\n        \"\"\"Return an iterator that slices sorted list from `start` to `stop`.\n        The `start` and `stop` index are treated inclusive and exclusive,\n        respectively.\n        Both `start` and `stop` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted list.\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n        >>> sl = SortedList('abcdefghij')\n        >>> it = sl.islice(2, 6)\n        >>> list(it)\n        ['c', 'd', 'e', 'f']\n        :param int start: start index (inclusive)\n        :param int stop: stop index (exclusive)\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n        \"\"\"\n        _len = self._len\n\n        if not _len:\n            return iter(())\n\n        start, stop, _ = slice(start, stop).indices(self._len)\n\n        if start >= stop:\n            return iter(())\n\n        _pos = self._pos\n\n        min_pos, min_idx = _pos(start)\n\n        if stop == _len:\n            max_pos = len(self._lists) - 1\n            max_idx = len(self._lists[-1])\n        else:\n            max_pos, max_idx = _pos(stop)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\n        \"\"\"Return an iterator that slices sorted list using two index pairs.\n        The index pairs are (min_pos, min_idx) and (max_pos, max_idx), the\n        first inclusive and the latter exclusive. See `_pos` for details on how\n        an index is converted to an index pair.\n        When `reverse` is `True`, values are yielded from the iterator in\n        reverse order.\n        \"\"\"\n        _lists = self._lists\n\n        if min_pos > max_pos:\n            return iter(())\n\n        if min_pos == max_pos:\n            if reverse:\n                indices = reversed(range(min_idx, max_idx))\n                return map(_lists[min_pos].__getitem__, indices)\n\n            indices = range(min_idx, max_idx)\n            return map(_lists[min_pos].__getitem__, indices)\n\n        next_pos = min_pos + 1\n\n        if next_pos == max_pos:\n            if reverse:\n                min_indices = range(min_idx, len(_lists[min_pos]))\n                max_indices = range(max_idx)\n                return chain(\n                    map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                    map(_lists[min_pos].__getitem__, reversed(min_indices)),\n                )\n\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[min_pos].__getitem__, min_indices),\n                map(_lists[max_pos].__getitem__, max_indices),\n            )\n\n        if reverse:\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            sublist_indices = range(next_pos, max_pos)\n            sublists = map(_lists.__getitem__, reversed(sublist_indices))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                chain.from_iterable(map(reversed, sublists)),\n                map(_lists[min_pos].__getitem__, reversed(min_indices)),\n            )\n\n        min_indices = range(min_idx, len(_lists[min_pos]))\n        sublist_indices = range(next_pos, max_pos)\n        sublists = map(_lists.__getitem__, sublist_indices)\n        max_indices = range(max_idx)\n        return chain(\n            map(_lists[min_pos].__getitem__, min_indices),\n            chain.from_iterable(sublists),\n            map(_lists[max_pos].__getitem__, max_indices),\n        )\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        \"\"\"Create an iterator of values between `minimum` and `maximum`.\n        Both `minimum` and `maximum` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted list.\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n        >>> sl = SortedList('abcdefghij')\n        >>> it = sl.irange('c', 'f')\n        >>> list(it)\n        ['c', 'd', 'e', 'f']\n        :param minimum: minimum value to start iterating\n        :param maximum: maximum value to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _lists = self._lists\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if minimum is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_lists[min_pos], minimum)\n            else:\n                min_pos = bisect_right(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_lists[min_pos], minimum)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if maximum is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_lists[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_right(_lists[max_pos], maximum)\n            else:\n                max_pos = bisect_left(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_left(_lists[max_pos], maximum)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\n        ``sl.__len__()`` <==> ``len(sl)``\n        :return: size of sorted list\n        \"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\n        If the `value` is already present, the insertion point will be before\n        (to the left of) any existing values.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList([10, 11, 12, 13, 14])\n        >>> sl.bisect_left(12)\n        2\n        :param value: insertion index of value in sorted list\n        :return: index\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\n        Similar to `bisect_left`, but if `value` is already present, the\n        insertion point will be after (to the right of) any existing values.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList([10, 11, 12, 13, 14])\n        >>> sl.bisect_right(12)\n        3\n        :param value: insertion index of value in sorted list\n        :return: index\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    bisect = bisect_right\n    _bisect_right = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\n        >>> sl.count(3)\n        3\n        :param value: value to count in sorted list\n        :return: count\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\n        Runtime complexity: `O(n)`\n        :return: new sorted list\n        \"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def append(self, value):\n        \"\"\"Raise not-implemented error.\n        Implemented to override `MutableSequence.append` which provides an\n        erroneous default implementation.\n        :raises NotImplementedError: use ``sl.add(value)`` instead\n        \"\"\"\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def extend(self, values):\n        \"\"\"Raise not-implemented error.\n        Implemented to override `MutableSequence.extend` which provides an\n        erroneous default implementation.\n        :raises NotImplementedError: use ``sl.update(values)`` instead\n        \"\"\"\n        raise NotImplementedError('use ``sl.update(values)`` instead')\n\n    def insert(self, index, value):\n        \"\"\"Raise not-implemented error.\n        :raises NotImplementedError: use ``sl.add(value)`` instead\n        \"\"\"\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\n        Raise :exc:`IndexError` if the sorted list is empty or index is out of\n        range.\n        Negative indices are supported.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList('abcde')\n        >>> sl.pop()\n        'e'\n        >>> sl.pop(2)\n        'c'\n        >>> sl\n        SortedList(['a', 'b', 'd'])\n        :param int index: index of value (default -1)\n        :return: value\n        :raises IndexError: if index is out of range\n        \"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n\n        if index == 0:\n            val = _lists[0][0]\n            self._delete(0, 0)\n            return val\n\n        if index == -1:\n            pos = len(_lists) - 1\n            loc = len(_lists[pos]) - 1\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=None, stop=None):\n        \"\"\"Return first index of value in sorted list.\n        Raise ValueError if `value` is not present.\n        Index must be between `start` and `stop` for the `value` to be\n        considered present. The default value, None, for `start` and `stop`\n        indicate the beginning and end of the sorted list.\n        Negative indices are supported.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sl = SortedList('abcde')\n        >>> sl.index('d')\n        3\n        >>> sl.index('z')\n        Traceback (most recent call last):\n          ...\n        ValueError: 'z' is not in list\n        :param value: value in sorted list\n        :param int start: start index (default None, start of sorted list)\n        :param int stop: stop index (default None, end of sorted list)\n        :return: index of value\n        :raises ValueError: if value is not present\n        \"\"\"\n        _len = self._len\n\n        if not _len:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            right = self._bisect_right(value) - 1\n\n            if start <= right:\n                return start\n\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\n        ``sl.__add__(other)`` <==> ``sl + other``\n        Values in `other` do not need to be in sorted order.\n        Runtime complexity: `O(n*log(n))`\n        >>> sl1 = SortedList('bat')\n        >>> sl2 = SortedList('cat')\n        >>> sl1 + sl2\n        SortedList(['a', 'a', 'b', 'c', 't', 't'])\n        :param other: other iterable\n        :return: new sorted list\n        \"\"\"\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\n        ``sl.__iadd__(other)`` <==> ``sl += other``\n        Values in `other` do not need to be in sorted order.\n        Runtime complexity: `O(k*log(n))` -- approximate.\n        >>> sl = SortedList('bat')\n        >>> sl += 'cat'\n        >>> sl\n        SortedList(['a', 'a', 'b', 'c', 't', 't'])\n        :param other: other iterable\n        :return: existing sorted list\n        \"\"\"\n        self._update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\n        ``sl.__mul__(num)`` <==> ``sl * num``\n        Runtime complexity: `O(n*log(n))`\n        >>> sl = SortedList('abc')\n        >>> sl * 3\n        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c'])\n        :param int num: count of shallow copies\n        :return: new sorted list\n        \"\"\"\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\n        ``sl.__imul__(num)`` <==> ``sl *= num``\n        Runtime complexity: `O(n*log(n))`\n        >>> sl = SortedList('abc')\n        >>> sl *= 3\n        >>> sl\n        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c'])\n        :param int num: count of shallow copies\n        :return: existing sorted list\n        \"\"\"\n        values = reduce(iadd, self._lists, []) * num\n        self._clear()\n        self._update(values)\n        return self\n\n    def __make_cmp(seq_op, symbol, doc):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            if not isinstance(other, Sequence):\n                return NotImplemented\n\n            self_len = self._len\n            len_other = len(other)\n\n            if self_len != len_other:\n                if seq_op is eq:\n                    return False\n                if seq_op is ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n\n            return seq_op(self_len, len_other)\n\n        seq_op_name = seq_op.__name__\n        comparer.__name__ = '__{0}__'.format(seq_op_name)\n        doc_str = \"\"\"Return true if and only if sorted list is {0} `other`.\n        ``sl.__{1}__(other)`` <==> ``sl {2} other``\n        Comparisons use lexicographical order as with sequences.\n        Runtime complexity: `O(n)`\n        :param other: `other` sequence\n        :return: true if sorted list is {0} `other`\n        \"\"\"\n        comparer.__doc__ = dedent(doc_str.format(doc, seq_op_name, symbol))\n        return comparer\n\n    __eq__ = __make_cmp(eq, '==', 'equal to')\n    __ne__ = __make_cmp(ne, '!=', 'not equal to')\n    __lt__ = __make_cmp(lt, '<', 'less than')\n    __gt__ = __make_cmp(gt, '>', 'greater than')\n    __le__ = __make_cmp(le, '<=', 'less than or equal to')\n    __ge__ = __make_cmp(ge, '>=', 'greater than or equal to')\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values,))\n\n    @recursive_repr()\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\n        ``sl.__repr__()`` <==> ``repr(sl)``\n        :return: string representation\n        \"\"\"\n        return '{0}({1!r})'.format(type(self).__name__, list(self))\n\n    def _check(self):\n        \"\"\"Check invariants of sorted list.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._lists:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._lists)):\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._lists[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except BaseException:\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\n\n\ndef identity(value):\n    \"Identity function.\"\n    return value\n\n\nclass SortedKeyList(SortedList):\n    \"\"\"Sorted-key list is a subtype of sorted list.\n    The sorted-key list maintains values in comparison order based on the\n    result of a key function applied to every value.\n    All the same methods that are available in :class:`SortedList` are also\n    available in :class:`SortedKeyList`.\n    Additional methods provided:\n    * :attr:`SortedKeyList.key`\n    * :func:`SortedKeyList.bisect_key_left`\n    * :func:`SortedKeyList.bisect_key_right`\n    * :func:`SortedKeyList.irange_key`\n    Some examples below use:\n    >>> from operator import neg\n    >>> neg\n    <built-in function neg>\n    >>> neg(1)\n    -1\n    \"\"\"\n\n    def __init__(self, iterable=None, key=identity):\n        \"\"\"Initialize sorted-key list instance.\n        Optional `iterable` argument provides an initial iterable of values to\n        initialize the sorted-key list.\n        Optional `key` argument defines a callable that, like the `key`\n        argument to Python's `sorted` function, extracts a comparison key from\n        each value. The default is the identity function.\n        Runtime complexity: `O(n*log(n))`\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl\n        SortedKeyList([], key=<built-in function neg>)\n        >>> skl = SortedKeyList([3, 1, 2], key=neg)\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n        :param iterable: initial values (optional)\n        :param key: function used to extract comparison key (optional)\n        \"\"\"\n        self._key = key\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._keys = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=identity):\n        return object.__new__(cls)\n\n    @property\n    def key(self):\n        \"Function used to extract comparison key from values.\"\n        return self._key\n\n    def clear(self):\n        \"\"\"Remove all values from sorted-key list.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._keys[:]\n        del self._maxes[:]\n        del self._index[:]\n\n    _clear = clear\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted-key list.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl.add(3)\n        >>> skl.add(1)\n        >>> skl.add(2)\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n        :param value: value to add to sorted-key list\n        \"\"\"\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n\n        key = self._key(value)\n\n        if _maxes:\n            pos = bisect_right(_maxes, key)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _keys[pos].append(key)\n                _maxes[pos] = key\n            else:\n                idx = bisect_right(_keys[pos], key)\n                _lists[pos].insert(idx, value)\n                _keys[pos].insert(idx, key)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _keys.append([key])\n            _maxes.append(key)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\n        Updates the index when the sublist length is less than double the load\n        level. This requires incrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n        \"\"\"\n        _lists = self._lists\n        _keys = self._keys\n        _index = self._index\n\n        if len(_keys[pos]) > (self._load << 1):\n            _maxes = self._maxes\n            _load = self._load\n\n            _lists_pos = _lists[pos]\n            _keys_pos = _keys[pos]\n            half = _lists_pos[_load:]\n            half_keys = _keys_pos[_load:]\n            del _lists_pos[_load:]\n            del _keys_pos[_load:]\n            _maxes[pos] = _keys_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _keys.insert(pos + 1, half_keys)\n            _maxes.insert(pos + 1, half_keys[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted-key list by adding all values from `iterable`.\n        Runtime complexity: `O(k*log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList(key=neg)\n        >>> skl.update([3, 1, 2])\n        >>> skl\n        SortedKeyList([3, 2, 1], key=<built-in function neg>)\n        :param iterable: iterable of values to add\n        \"\"\"\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        values = sorted(iterable, key=self._key)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort(key=self._key)\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _keys.extend(list(map(self._key, _list)) for _list in _lists)\n        _maxes.extend(sublist[-1] for sublist in _keys)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted-key list.\n        ``skl.__contains__(value)`` <==> ``value in skl``\n        Runtime complexity: `O(log(n))`\n        >>> from operator import neg\n        >>> skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)\n        >>> 3 in skl\n        True\n        :param value: search for value in sorted-key list\n        :return: true if `value` in sorted-key list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        _keys = self._keys\n\n        idx = bisect_left(_keys[pos], key)\n\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return False\n            if _lists[pos][idx] == value:\n                return True\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return False\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted-key list if it is a member.\n        If `value` is not a member, do nothing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.discard(1)\n        >>> skl.discard(0)\n        >>> skl == [5, 4, 3, 2]\n        True\n        :param value: `value` to discard from sorted-key list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return\n            if _lists[pos][idx] == value:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted-key list; `value` must be a member.\n        If `value` is not a member, raise ValueError.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([1, 2, 3, 4, 5], key=neg)\n        >>> skl.remove(5)\n        >>> skl == [4, 3, 2, 1]\n        True\n        >>> skl.remove(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 not in list\n        :param value: `value` to remove from sorted-key list\n        :raises ValueError: if `value` is not in sorted-key list\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError('{0!r} not in list'.format(value))\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            raise ValueError('{0!r} not in list'.format(value))\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError('{0!r} not in list'.format(value))\n            if _lists[pos][idx] == value:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError('{0!r} not in list'.format(value))\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\n        Combines lists that are less than half the load level.\n        Updates the index when the sublist length is more than half the load\n        level. This requires decrementing the nodes in a traversal from the\n        leaf node to the root. For an example traversal see\n        ``SortedList._loc``.\n        :param int pos: lists index\n        :param int idx: sublist index\n        \"\"\"\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        _index = self._index\n        keys_pos = _keys[pos]\n        lists_pos = _lists[pos]\n\n        del keys_pos[idx]\n        del lists_pos[idx]\n        self._len -= 1\n\n        len_keys_pos = len(keys_pos)\n\n        if len_keys_pos > (self._load >> 1):\n            _maxes[pos] = keys_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_keys) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _keys[prev].extend(_keys[pos])\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _keys[prev][-1]\n\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_keys_pos:\n            _maxes[pos] = keys_pos[-1]\n        else:\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        \"\"\"Create an iterator of values between `minimum` and `maximum`.\n        Both `minimum` and `maximum` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted-key list.\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)\n        >>> it = skl.irange(14.5, 11.5)\n        >>> list(it)\n        [14, 13, 12]\n        :param minimum: minimum value to start iterating\n        :param maximum: maximum value to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n        \"\"\"\n        min_key = self._key(minimum) if minimum is not None else None\n        max_key = self._key(maximum) if maximum is not None else None\n        return self._irange_key(\n            min_key=min_key, max_key=max_key,\n            inclusive=inclusive, reverse=reverse,\n        )\n\n    def irange_key(self, min_key=None, max_key=None, inclusive=(True, True),\n                   reverse=False):\n        \"\"\"Create an iterator of values between `min_key` and `max_key`.\n        Both `min_key` and `max_key` default to `None` which is automatically\n        inclusive of the beginning and end of the sorted-key list.\n        The argument `inclusive` is a pair of booleans that indicates whether\n        the minimum and maximum ought to be included in the range,\n        respectively. The default is ``(True, True)`` such that the range is\n        inclusive of both minimum and maximum.\n        When `reverse` is `True` the values are yielded from the iterator in\n        reverse order; `reverse` defaults to `False`.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([11, 12, 13, 14, 15], key=neg)\n        >>> it = skl.irange_key(-14, -12)\n        >>> list(it)\n        [14, 13, 12]\n        :param min_key: minimum key to start iterating\n        :param max_key: maximum key to stop iterating\n        :param inclusive: pair of booleans\n        :param bool reverse: yield values in reverse order\n        :return: iterator\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _keys = self._keys\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if min_key is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, min_key)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_keys[min_pos], min_key)\n            else:\n                min_pos = bisect_right(_maxes, min_key)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_keys[min_pos], min_key)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if max_key is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_keys[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, max_key)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_right(_keys[max_pos], max_key)\n            else:\n                max_pos = bisect_left(_maxes, max_key)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_left(_keys[max_pos], max_key)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    _irange_key = irange_key\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted-key list.\n        If the `value` is already present, the insertion point will be before\n        (to the left of) any existing values.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_left(1)\n        4\n        :param value: insertion index of value in sorted-key list\n        :return: index\n        \"\"\"\n        return self._bisect_key_left(self._key(value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted-key list.\n        Similar to `bisect_left`, but if `value` is already present, the\n        insertion point will be after (to the right of) any existing values.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_right(1)\n        5\n        :param value: insertion index of value in sorted-key list\n        :return: index\n        \"\"\"\n        return self._bisect_key_right(self._key(value))\n\n    bisect = bisect_right\n\n    def bisect_key_left(self, key):\n        \"\"\"Return an index to insert `key` in the sorted-key list.\n        If the `key` is already present, the insertion point will be before (to\n        the left of) any existing keys.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_key_left(-1)\n        4\n        :param key: insertion index of key in sorted-key list\n        :return: index\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._keys[pos], key)\n\n        return self._loc(pos, idx)\n\n    _bisect_key_left = bisect_key_left\n\n    def bisect_key_right(self, key):\n        \"\"\"Return an index to insert `key` in the sorted-key list.\n        Similar to `bisect_key_left`, but if `key` is already present, the\n        insertion point will be after (to the right of) any existing keys.\n        Similar to the `bisect` module in the standard library.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.bisect_key_right(-1)\n        5\n        :param key: insertion index of key in sorted-key list\n        :return: index\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, key)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._keys[pos], key)\n\n        return self._loc(pos, idx)\n\n    bisect_key = bisect_key_right\n    _bisect_key_right = bisect_key_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted-key list.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([4, 4, 4, 4, 3, 3, 3, 2, 2, 1], key=neg)\n        >>> skl.count(2)\n        2\n        :param value: value to count in sorted-key list\n        :return: count\n        \"\"\"\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        total = 0\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                return total\n            if _lists[pos][idx] == value:\n                total += 1\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return total\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted-key list.\n        Runtime complexity: `O(n)`\n        :return: new sorted-key list\n        \"\"\"\n        return self.__class__(self, key=self._key)\n\n    __copy__ = copy\n\n    def index(self, value, start=None, stop=None):\n        \"\"\"Return first index of value in sorted-key list.\n        Raise ValueError if `value` is not present.\n        Index must be between `start` and `stop` for the `value` to be\n        considered present. The default value, None, for `start` and `stop`\n        indicate the beginning and end of the sorted-key list.\n        Negative indices are supported.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> from operator import neg\n        >>> skl = SortedKeyList([5, 4, 3, 2, 1], key=neg)\n        >>> skl.index(2)\n        3\n        >>> skl.index(0)\n        Traceback (most recent call last):\n          ...\n        ValueError: 0 is not in list\n        :param value: value in sorted-key list\n        :param int start: start index (default None, start of sorted-key list)\n        :param int stop: stop index (default None, end of sorted-key list)\n        :return: index of value\n        :raises ValueError: if value is not present\n        \"\"\"\n        _len = self._len\n\n        if not _len:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        key = self._key(value)\n        pos = bisect_left(_maxes, key)\n\n        if pos == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError('{0!r} is not in list'.format(value))\n            if _lists[pos][idx] == value:\n                loc = self._loc(pos, idx)\n                if start <= loc <= stop:\n                    return loc\n                elif loc > stop:\n                    break\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError('{0!r} is not in list'.format(value))\n                len_sublist = len(_keys[pos])\n                idx = 0\n\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted-key list containing all values in both sequences.\n        ``skl.__add__(other)`` <==> ``skl + other``\n        Values in `other` do not need to be in sorted-key order.\n        Runtime complexity: `O(n*log(n))`\n        >>> from operator import neg\n        >>> skl1 = SortedKeyList([5, 4, 3], key=neg)\n        >>> skl2 = SortedKeyList([2, 1, 0], key=neg)\n        >>> skl1 + skl2\n        SortedKeyList([5, 4, 3, 2, 1, 0], key=<built-in function neg>)\n        :param other: other iterable\n        :return: new sorted-key list\n        \"\"\"\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values, key=self._key)\n\n    __radd__ = __add__\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted-key list with `num` shallow copies of values.\n        ``skl.__mul__(num)`` <==> ``skl * num``\n        Runtime complexity: `O(n*log(n))`\n        >>> from operator import neg\n        >>> skl = SortedKeyList([3, 2, 1], key=neg)\n        >>> skl * 2\n        SortedKeyList([3, 3, 2, 2, 1, 1], key=<built-in function neg>)\n        :param int num: count of shallow copies\n        :return: new sorted-key list\n        \"\"\"\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values, key=self._key)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values, self.key))\n\n    @recursive_repr()\n    def __repr__(self):\n        \"\"\"Return string representation of sorted-key list.\n        ``skl.__repr__()`` <==> ``repr(skl)``\n        :return: string representation\n        \"\"\"\n        type_name = type(self).__name__\n        return '{0}({1!r}, key={2!r})'.format(type_name, list(self), self._key)\n\n    def _check(self):\n        \"\"\"Check invariants of sorted-key list.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists) == len(self._keys)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._keys:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._keys)):\n                assert self._keys[pos - 1][-1] <= self._keys[pos][0]\n\n            # Check _keys matches _key mapped to _lists.\n\n            for val_sublist, key_sublist in zip(self._lists, self._keys):\n                assert len(val_sublist) == len(key_sublist)\n                for val, key in zip(val_sublist, key_sublist):\n                    assert self._key(val) == key\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._keys[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except BaseException:\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_keys', len(self._keys))\n            print('keys', self._keys)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\n\n\nclass SortedSet(MutableSet, Sequence):\n    \"\"\"Sorted set is a sorted mutable set.\n    Sorted set values are maintained in sorted order. The design of sorted set\n    is simple: sorted set uses a set for set-operations and maintains a sorted\n    list of values.\n    Sorted set values must be hashable and comparable. The hash and total\n    ordering of values must not change while they are stored in the sorted set.\n    Mutable set methods:\n    * :func:`SortedSet.__contains__`\n    * :func:`SortedSet.__iter__`\n    * :func:`SortedSet.__len__`\n    * :func:`SortedSet.add`\n    * :func:`SortedSet.discard`\n    Sequence methods:\n    * :func:`SortedSet.__getitem__`\n    * :func:`SortedSet.__delitem__`\n    * :func:`SortedSet.__reversed__`\n    Methods for removing values:\n    * :func:`SortedSet.clear`\n    * :func:`SortedSet.pop`\n    * :func:`SortedSet.remove`\n    Set-operation methods:\n    * :func:`SortedSet.difference`\n    * :func:`SortedSet.difference_update`\n    * :func:`SortedSet.intersection`\n    * :func:`SortedSet.intersection_update`\n    * :func:`SortedSet.symmetric_difference`\n    * :func:`SortedSet.symmetric_difference_update`\n    * :func:`SortedSet.union`\n    * :func:`SortedSet.update`\n    Methods for miscellany:\n    * :func:`SortedSet.copy`\n    * :func:`SortedSet.count`\n    * :func:`SortedSet.__repr__`\n    * :func:`SortedSet._check`\n    Sorted list methods available:\n    * :func:`SortedList.bisect_left`\n    * :func:`SortedList.bisect_right`\n    * :func:`SortedList.index`\n    * :func:`SortedList.irange`\n    * :func:`SortedList.islice`\n    * :func:`SortedList._reset`\n    Additional sorted list methods available, if key-function used:\n    * :func:`SortedKeyList.bisect_key_left`\n    * :func:`SortedKeyList.bisect_key_right`\n    * :func:`SortedKeyList.irange_key`\n    Sorted set comparisons use subset and superset relations. Two sorted sets\n    are equal if and only if every element of each sorted set is contained in\n    the other (each is a subset of the other). A sorted set is less than\n    another sorted set if and only if the first sorted set is a proper subset\n    of the second sorted set (is a subset, but is not equal). A sorted set is\n    greater than another sorted set if and only if the first sorted set is a\n    proper superset of the second sorted set (is a superset, but is not equal).\n    \"\"\"\n\n    def __init__(self, iterable=None, key=None):\n        \"\"\"Initialize sorted set instance.\n        Optional `iterable` argument provides an initial iterable of values to\n        initialize the sorted set.\n        Optional `key` argument defines a callable that, like the `key`\n        argument to Python's `sorted` function, extracts a comparison key from\n        each value. The default, none, compares values directly.\n        Runtime complexity: `O(n*log(n))`\n        >>> ss = SortedSet([3, 1, 2, 5, 4])\n        >>> ss\n        SortedSet([1, 2, 3, 4, 5])\n        >>> from operator import neg\n        >>> ss = SortedSet([3, 1, 2, 5, 4], neg)\n        >>> ss\n        SortedSet([5, 4, 3, 2, 1], key=<built-in function neg>)\n        :param iterable: initial values (optional)\n        :param key: function used to extract comparison key (optional)\n        \"\"\"\n        self._key = key\n\n        # SortedSet._fromset calls SortedSet.__init__ after initializing the\n        # _set attribute. So only create a new set if the _set attribute is not\n        # already present.\n\n        if not hasattr(self, '_set'):\n            self._set = set()\n\n        self._list = SortedList(self._set, key=key)\n\n        # Expose some set methods publicly.\n\n        _set = self._set\n        self.isdisjoint = _set.isdisjoint\n        self.issubset = _set.issubset\n        self.issuperset = _set.issuperset\n\n        # Expose some sorted list methods publicly.\n\n        _list = self._list\n        self.bisect_left = _list.bisect_left\n        self.bisect = _list.bisect\n        self.bisect_right = _list.bisect_right\n        self.index = _list.index\n        self.irange = _list.irange\n        self.islice = _list.islice\n        self._reset = _list._reset\n\n        if key is not None:\n            self.bisect_key_left = _list.bisect_key_left\n            self.bisect_key_right = _list.bisect_key_right\n            self.bisect_key = _list.bisect_key\n            self.irange_key = _list.irange_key\n\n        if iterable is not None:\n            self._update(iterable)\n\n    @classmethod\n    def _fromset(cls, values, key=None):\n        \"\"\"Initialize sorted set from existing set.\n        Used internally by set operations that return a new set.\n        \"\"\"\n        sorted_set = object.__new__(cls)\n        sorted_set._set = values\n        sorted_set.__init__(key=key)\n        return sorted_set\n\n    @property\n    def key(self):\n        \"\"\"Function used to extract comparison key from values.\n        Sorted set compares values directly when the key function is none.\n        \"\"\"\n        return self._key\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted set.\n        ``ss.__contains__(value)`` <==> ``value in ss``\n        Runtime complexity: `O(1)`\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> 3 in ss\n        True\n        :param value: search for value in sorted set\n        :return: true if `value` in sorted set\n        \"\"\"\n        return value in self._set\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted set.\n        ``ss.__getitem__(index)`` <==> ``ss[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet('abcde')\n        >>> ss[2]\n        'c'\n        >>> ss[-1]\n        'e'\n        >>> ss[2:5]\n        ['c', 'd', 'e']\n        :param index: integer or slice for indexing\n        :return: value or list of values\n        :raises IndexError: if index out of range\n        \"\"\"\n        return self._list[index]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted set.\n        ``ss.__delitem__(index)`` <==> ``del ss[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet('abcde')\n        >>> del ss[2]\n        >>> ss\n        SortedSet(['a', 'b', 'd', 'e'])\n        >>> del ss[:2]\n        >>> ss\n        SortedSet(['d', 'e'])\n        :param index: integer or slice for indexing\n        :raises IndexError: if index out of range\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        if isinstance(index, slice):\n            values = _list[index]\n            _set.difference_update(values)\n        else:\n            value = _list[index]\n            _set.remove(value)\n        del _list[index]\n\n    def __make_cmp(set_op, symbol, doc):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted set and set.\"\n            if isinstance(other, SortedSet):\n                return set_op(self._set, other._set)\n            elif isinstance(other, Set):\n                return set_op(self._set, other)\n            return NotImplemented\n\n        set_op_name = set_op.__name__\n        comparer.__name__ = '__{0}__'.format(set_op_name)\n        doc_str = \"\"\"Return true if and only if sorted set is {0} `other`.\n        ``ss.__{1}__(other)`` <==> ``ss {2} other``\n        Comparisons use subset and superset semantics as with sets.\n        Runtime complexity: `O(n)`\n        :param other: `other` set\n        :return: true if sorted set is {0} `other`\n        \"\"\"\n        comparer.__doc__ = dedent(doc_str.format(doc, set_op_name, symbol))\n        return comparer\n\n    __eq__ = __make_cmp(eq, '==', 'equal to')\n    __ne__ = __make_cmp(ne, '!=', 'not equal to')\n    __lt__ = __make_cmp(lt, '<', 'a proper subset of')\n    __gt__ = __make_cmp(gt, '>', 'a proper superset of')\n    __le__ = __make_cmp(le, '<=', 'a subset of')\n    __ge__ = __make_cmp(ge, '>=', 'a superset of')\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted set.\n        ``ss.__len__()`` <==> ``len(ss)``\n        :return: size of sorted set\n        \"\"\"\n        return len(self._set)\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted set.\n        ``ss.__iter__()`` <==> ``iter(ss)``\n        Iterating the sorted set while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n        \"\"\"\n        return iter(self._list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted set.\n        ``ss.__reversed__()`` <==> ``reversed(ss)``\n        Iterating the sorted set while adding or deleting values may raise a\n        :exc:`RuntimeError` or fail to iterate over all values.\n        \"\"\"\n        return reversed(self._list)\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted set.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet()\n        >>> ss.add(3)\n        >>> ss.add(1)\n        >>> ss.add(2)\n        >>> ss\n        SortedSet([1, 2, 3])\n        :param value: value to add to sorted set\n        \"\"\"\n        _set = self._set\n        if value not in _set:\n            _set.add(value)\n            self._list.add(value)\n\n    _add = add\n\n    def clear(self):\n        \"\"\"Remove all values from sorted set.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        self._set.clear()\n        self._list.clear()\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted set.\n        Runtime complexity: `O(n)`\n        :return: new sorted set\n        \"\"\"\n        return self._fromset(set(self._set), key=self._key)\n\n    __copy__ = copy\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted set.\n        Runtime complexity: `O(1)`\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.count(3)\n        1\n        :param value: value to count in sorted set\n        :return: count\n        \"\"\"\n        return 1 if value in self._set else 0\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted set if it is a member.\n        If `value` is not a member, do nothing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.discard(5)\n        >>> ss.discard(0)\n        >>> ss == set([1, 2, 3, 4])\n        True\n        :param value: `value` to discard from sorted set\n        \"\"\"\n        _set = self._set\n        if value in _set:\n            _set.remove(value)\n            self._list.remove(value)\n\n    _discard = discard\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted set.\n        Raise :exc:`IndexError` if the sorted set is empty or index is out of\n        range.\n        Negative indices are supported.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet('abcde')\n        >>> ss.pop()\n        'e'\n        >>> ss.pop(2)\n        'c'\n        >>> ss\n        SortedSet(['a', 'b', 'd'])\n        :param int index: index of value (default -1)\n        :return: value\n        :raises IndexError: if index is out of range\n        \"\"\"\n        # pylint: disable=arguments-differ\n        value = self._list.pop(index)\n        self._set.remove(value)\n        return value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted set; `value` must be a member.\n        If `value` is not a member, raise :exc:`KeyError`.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.remove(5)\n        >>> ss == set([1, 2, 3, 4])\n        True\n        >>> ss.remove(0)\n        Traceback (most recent call last):\n          ...\n        KeyError: 0\n        :param value: `value` to remove from sorted set\n        :raises KeyError: if `value` is not in sorted set\n        \"\"\"\n        self._set.remove(value)\n        self._list.remove(value)\n\n    def difference(self, *iterables):\n        \"\"\"Return the difference of two or more sets as a new sorted set.\n        The `difference` method also corresponds to operator ``-``.\n        ``ss.__sub__(iterable)`` <==> ``ss - iterable``\n        The difference is all values that are in this sorted set but not the\n        other `iterables`.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.difference([4, 5, 6, 7])\n        SortedSet([1, 2, 3])\n        :param iterables: iterable arguments\n        :return: new sorted set\n        \"\"\"\n        diff = self._set.difference(*iterables)\n        return self._fromset(diff, key=self._key)\n\n    __sub__ = difference\n\n    def difference_update(self, *iterables):\n        \"\"\"Remove all values of `iterables` from this sorted set.\n        The `difference_update` method also corresponds to operator ``-=``.\n        ``ss.__isub__(iterable)`` <==> ``ss -= iterable``\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> _ = ss.difference_update([4, 5, 6, 7])\n        >>> ss\n        SortedSet([1, 2, 3])\n        :param iterables: iterable arguments\n        :return: itself\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        values = set(chain(*iterables))\n        if (4 * len(values)) > len(_set):\n            _set.difference_update(values)\n            _list.clear()\n            _list.update(_set)\n        else:\n            _discard = self._discard\n            for value in values:\n                _discard(value)\n        return self\n\n    __isub__ = difference_update\n\n    def intersection(self, *iterables):\n        \"\"\"Return the intersection of two or more sets as a new sorted set.\n        The `intersection` method also corresponds to operator ``&``.\n        ``ss.__and__(iterable)`` <==> ``ss & iterable``\n        The intersection is all values that are in this sorted set and each of\n        the other `iterables`.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.intersection([4, 5, 6, 7])\n        SortedSet([4, 5])\n        :param iterables: iterable arguments\n        :return: new sorted set\n        \"\"\"\n        intersect = self._set.intersection(*iterables)\n        return self._fromset(intersect, key=self._key)\n\n    __and__ = intersection\n    __rand__ = __and__\n\n    def intersection_update(self, *iterables):\n        \"\"\"Update the sorted set with the intersection of `iterables`.\n        The `intersection_update` method also corresponds to operator ``&=``.\n        ``ss.__iand__(iterable)`` <==> ``ss &= iterable``\n        Keep only values found in itself and all `iterables`.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> _ = ss.intersection_update([4, 5, 6, 7])\n        >>> ss\n        SortedSet([4, 5])\n        :param iterables: iterable arguments\n        :return: itself\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        _set.intersection_update(*iterables)\n        _list.clear()\n        _list.update(_set)\n        return self\n\n    __iand__ = intersection_update\n\n    def symmetric_difference(self, other):\n        \"\"\"Return the symmetric difference with `other` as a new sorted set.\n        The `symmetric_difference` method also corresponds to operator ``^``.\n        ``ss.__xor__(other)`` <==> ``ss ^ other``\n        The symmetric difference is all values tha are in exactly one of the\n        sets.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.symmetric_difference([4, 5, 6, 7])\n        SortedSet([1, 2, 3, 6, 7])\n        :param other: `other` iterable\n        :return: new sorted set\n        \"\"\"\n        diff = self._set.symmetric_difference(other)\n        return self._fromset(diff, key=self._key)\n\n    __xor__ = symmetric_difference\n    __rxor__ = __xor__\n\n    def symmetric_difference_update(self, other):\n        \"\"\"Update the sorted set with the symmetric difference with `other`.\n        The `symmetric_difference_update` method also corresponds to operator\n        ``^=``.\n        ``ss.__ixor__(other)`` <==> ``ss ^= other``\n        Keep only values found in exactly one of itself and `other`.\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> _ = ss.symmetric_difference_update([4, 5, 6, 7])\n        >>> ss\n        SortedSet([1, 2, 3, 6, 7])\n        :param other: `other` iterable\n        :return: itself\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        _set.symmetric_difference_update(other)\n        _list.clear()\n        _list.update(_set)\n        return self\n\n    __ixor__ = symmetric_difference_update\n\n    def union(self, *iterables):\n        \"\"\"Return new sorted set with values from itself and all `iterables`.\n        The `union` method also corresponds to operator ``|``.\n        ``ss.__or__(iterable)`` <==> ``ss | iterable``\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> ss.union([4, 5, 6, 7])\n        SortedSet([1, 2, 3, 4, 5, 6, 7])\n        :param iterables: iterable arguments\n        :return: new sorted set\n        \"\"\"\n        return self.__class__(chain(iter(self), *iterables), key=self._key)\n\n    __or__ = union\n    __ror__ = __or__\n\n    def update(self, *iterables):\n        \"\"\"Update the sorted set adding values from all `iterables`.\n        The `update` method also corresponds to operator ``|=``.\n        ``ss.__ior__(iterable)`` <==> ``ss |= iterable``\n        >>> ss = SortedSet([1, 2, 3, 4, 5])\n        >>> _ = ss.update([4, 5, 6, 7])\n        >>> ss\n        SortedSet([1, 2, 3, 4, 5, 6, 7])\n        :param iterables: iterable arguments\n        :return: itself\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        values = set(chain(*iterables))\n        if (4 * len(values)) > len(_set):\n            _list = self._list\n            _set.update(values)\n            _list.clear()\n            _list.update(_set)\n        else:\n            _add = self._add\n            for value in values:\n                _add(value)\n        return self\n\n    __ior__ = update\n    _update = update\n\n    def __reduce__(self):\n        \"\"\"Support for pickle.\n        The tricks played with exposing methods in :func:`SortedSet.__init__`\n        confuse pickle so customize the reducer.\n        \"\"\"\n        return (type(self), (self._set, self._key))\n\n    @recursive_repr()\n    def __repr__(self):\n        \"\"\"Return string representation of sorted set.\n        ``ss.__repr__()`` <==> ``repr(ss)``\n        :return: string representation\n        \"\"\"\n        _key = self._key\n        key = '' if _key is None else ', key={0!r}'.format(_key)\n        type_name = type(self).__name__\n        return '{0}({1!r}{2})'.format(type_name, list(self), key)\n\n    def _check(self):\n        \"\"\"Check invariants of sorted set.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        _set = self._set\n        _list = self._list\n        _list._check()\n        assert len(_set) == len(_list)\n        assert all(value in _set for value in _list)\n\n\nclass SortedDict(dict):\n    \"\"\"Sorted dict is a sorted mutable mapping.\n    Sorted dict keys are maintained in sorted order. The design of sorted dict\n    is simple: sorted dict inherits from dict to store items and maintains a\n    sorted list of keys.\n    Sorted dict keys must be hashable and comparable. The hash and total\n    ordering of keys must not change while they are stored in the sorted dict.\n    Mutable mapping methods:\n    * :func:`SortedDict.__getitem__` (inherited from dict)\n    * :func:`SortedDict.__setitem__`\n    * :func:`SortedDict.__delitem__`\n    * :func:`SortedDict.__iter__`\n    * :func:`SortedDict.__len__` (inherited from dict)\n    Methods for adding items:\n    * :func:`SortedDict.setdefault`\n    * :func:`SortedDict.update`\n    Methods for removing items:\n    * :func:`SortedDict.clear`\n    * :func:`SortedDict.pop`\n    * :func:`SortedDict.popitem`\n    Methods for looking up items:\n    * :func:`SortedDict.__contains__` (inherited from dict)\n    * :func:`SortedDict.get` (inherited from dict)\n    * :func:`SortedDict.peekitem`\n    Methods for views:\n    * :func:`SortedDict.keys`\n    * :func:`SortedDict.items`\n    * :func:`SortedDict.values`\n    Methods for miscellany:\n    * :func:`SortedDict.copy`\n    * :func:`SortedDict.fromkeys`\n    * :func:`SortedDict.__reversed__`\n    * :func:`SortedDict.__eq__` (inherited from dict)\n    * :func:`SortedDict.__ne__` (inherited from dict)\n    * :func:`SortedDict.__repr__`\n    * :func:`SortedDict._check`\n    Sorted list methods available (applies to keys):\n    * :func:`SortedList.bisect_left`\n    * :func:`SortedList.bisect_right`\n    * :func:`SortedList.count`\n    * :func:`SortedList.index`\n    * :func:`SortedList.irange`\n    * :func:`SortedList.islice`\n    * :func:`SortedList._reset`\n    Additional sorted list methods available, if key-function used:\n    * :func:`SortedKeyList.bisect_key_left`\n    * :func:`SortedKeyList.bisect_key_right`\n    * :func:`SortedKeyList.irange_key`\n    Sorted dicts may only be compared for equality and inequality.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize sorted dict instance.\n        Optional key-function argument defines a callable that, like the `key`\n        argument to the built-in `sorted` function, extracts a comparison key\n        from each dictionary key. If no function is specified, the default\n        compares the dictionary keys directly. The key-function argument must\n        be provided as a positional argument and must come before all other\n        arguments.\n        Optional iterable argument provides an initial sequence of pairs to\n        initialize the sorted dict. Each pair in the sequence defines the key\n        and corresponding value. If a key is seen more than once, the last\n        value associated with it is stored in the new sorted dict.\n        Optional mapping argument provides an initial mapping of items to\n        initialize the sorted dict.\n        If keyword arguments are given, the keywords themselves, with their\n        associated values, are added as items to the dictionary. If a key is\n        specified both in the positional argument and as a keyword argument,\n        the value associated with the keyword is stored in the\n        sorted dict.\n        Sorted dict keys must be hashable, per the requirement for Python's\n        dictionaries. Keys (or the result of the key-function) must also be\n        comparable, per the requirement for sorted lists.\n        >>> d = {'alpha': 1, 'beta': 2}\n        >>> SortedDict([('alpha', 1), ('beta', 2)]) == d\n        True\n        >>> SortedDict({'alpha': 1, 'beta': 2}) == d\n        True\n        >>> SortedDict(alpha=1, beta=2) == d\n        True\n        \"\"\"\n        if args and (args[0] is None or callable(args[0])):\n            _key = self._key = args[0]\n            args = args[1:]\n        else:\n            _key = self._key = None\n\n        self._list = SortedList(key=_key)\n\n        # Reaching through ``self._list`` repeatedly adds unnecessary overhead\n        # so cache references to sorted list methods.\n\n        _list = self._list\n        self._list_add = _list.add\n        self._list_clear = _list.clear\n        self._list_iter = _list.__iter__\n        self._list_reversed = _list.__reversed__\n        self._list_pop = _list.pop\n        self._list_remove = _list.remove\n        self._list_update = _list.update\n\n        # Expose some sorted list methods publicly.\n\n        self.bisect_left = _list.bisect_left\n        self.bisect = _list.bisect_right\n        self.bisect_right = _list.bisect_right\n        self.index = _list.index\n        self.irange = _list.irange\n        self.islice = _list.islice\n        self._reset = _list._reset\n\n        if _key is not None:\n            self.bisect_key_left = _list.bisect_key_left\n            self.bisect_key_right = _list.bisect_key_right\n            self.bisect_key = _list.bisect_key\n            self.irange_key = _list.irange_key\n\n        self._update(*args, **kwargs)\n\n    @property\n    def key(self):\n        \"\"\"Function used to extract comparison key from keys.\n        Sorted dict compares keys directly when the key function is none.\n        \"\"\"\n        return self._key\n\n    @property\n    def iloc(self):\n        \"\"\"Cached reference of sorted keys view.\n        Deprecated in version 2 of Sorted Containers. Use\n        :func:`SortedDict.keys` instead.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        try:\n            return self._iloc\n        except AttributeError:\n            warnings.warn(\n                'sorted_dict.iloc is deprecated.'\n                ' Use SortedDict.keys() instead.',\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            _iloc = self._iloc = SortedKeysView(self)\n            return _iloc\n\n    def clear(self):\n        \"\"\"Remove all items from sorted dict.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        dict.clear(self)\n        self._list_clear()\n\n    def __delitem__(self, key):\n        \"\"\"Remove item from sorted dict identified by `key`.\n        ``sd.__delitem__(key)`` <==> ``del sd[key]``\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> del sd['b']\n        >>> sd\n        SortedDict({'a': 1, 'c': 3})\n        >>> del sd['z']\n        Traceback (most recent call last):\n          ...\n        KeyError: 'z'\n        :param key: `key` for item lookup\n        :raises KeyError: if key not found\n        \"\"\"\n        dict.__delitem__(self, key)\n        self._list_remove(key)\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the keys of the sorted dict.\n        ``sd.__iter__()`` <==> ``iter(sd)``\n        Iterating the sorted dict while adding or deleting items may raise a\n        :exc:`RuntimeError` or fail to iterate over all keys.\n        \"\"\"\n        return self._list_iter()\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the keys of the sorted dict.\n        ``sd.__reversed__()`` <==> ``reversed(sd)``\n        Iterating the sorted dict while adding or deleting items may raise a\n        :exc:`RuntimeError` or fail to iterate over all keys.\n        \"\"\"\n        return self._list_reversed()\n\n    def __setitem__(self, key, value):\n        \"\"\"Store item in sorted dict with `key` and corresponding `value`.\n        ``sd.__setitem__(key, value)`` <==> ``sd[key] = value``\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict()\n        >>> sd['c'] = 3\n        >>> sd['a'] = 1\n        >>> sd['b'] = 2\n        >>> sd\n        SortedDict({'a': 1, 'b': 2, 'c': 3})\n        :param key: key for item\n        :param value: value for item\n        \"\"\"\n        if key not in self:\n            self._list_add(key)\n        dict.__setitem__(self, key, value)\n\n    _setitem = __setitem__\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted dict.\n        Runtime complexity: `O(n)`\n        :return: new sorted dict\n        \"\"\"\n        return self.__class__(self._key, self.items())\n\n    __copy__ = copy\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None):\n        \"\"\"Return a new sorted dict initailized from `iterable` and `value`.\n        Items in the sorted dict have keys from `iterable` and values equal to\n        `value`.\n        Runtime complexity: `O(n*log(n))`\n        :return: new sorted dict\n        \"\"\"\n        return cls((key, value) for key in iterable)\n\n    def keys(self):\n        \"\"\"Return new sorted keys view of the sorted dict's keys.\n        See :class:`SortedKeysView` for details.\n        :return: new sorted keys view\n        \"\"\"\n        return SortedKeysView(self)\n\n    def items(self):\n        \"\"\"Return new sorted items view of the sorted dict's items.\n        See :class:`SortedItemsView` for details.\n        :return: new sorted items view\n        \"\"\"\n        return SortedItemsView(self)\n\n    def values(self):\n        \"\"\"Return new sorted values view of the sorted dict's values.\n        See :class:`SortedValuesView` for details.\n        :return: new sorted values view\n        \"\"\"\n        return SortedValuesView(self)\n\n    # if sys.hexversion < 0x03000000:\n    #\t def __make_raise_attributeerror(original, alternate):\n    #\t\t # pylint: disable=no-self-argument\n    #\t\t message = (\n    #\t\t\t 'SortedDict.{original}() is not implemented.'\n    #\t\t\t ' Use SortedDict.{alternate}() instead.'\n    #\t\t ).format(original=original, alternate=alternate)\n\n    #\t\t def method(self):\n    #\t\t\t # pylint: disable=missing-docstring,unused-argument\n    #\t\t\t raise AttributeError(message)\n    #\t\t method.__name__ = original  # pylint: disable=non-str-assignment-to-dunder-name\n    #\t\t method.__doc__ = message\n    #\t\t return property(method)\n\n    #\t iteritems = __make_raise_attributeerror('iteritems', 'items')\n    #\t iterkeys = __make_raise_attributeerror('iterkeys', 'keys')\n    #\t itervalues = __make_raise_attributeerror('itervalues', 'values')\n    #\t viewitems = __make_raise_attributeerror('viewitems', 'items')\n    #\t viewkeys = __make_raise_attributeerror('viewkeys', 'keys')\n    #\t viewvalues = __make_raise_attributeerror('viewvalues', 'values')\n\n    class _NotGiven(object):\n        # pylint: disable=too-few-public-methods\n        def __repr__(self):\n            return '<not-given>'\n\n    __not_given = _NotGiven()\n\n    def pop(self, key, default=__not_given):\n        \"\"\"Remove and return value for item identified by `key`.\n        If the `key` is not found then return `default` if given. If `default`\n        is not given then raise :exc:`KeyError`.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> sd.pop('c')\n        3\n        >>> sd.pop('z', 26)\n        26\n        >>> sd.pop('y')\n        Traceback (most recent call last):\n          ...\n        KeyError: 'y'\n        :param key: `key` for item\n        :param default: `default` value if key not found (optional)\n        :return: value for item\n        :raises KeyError: if `key` not found and `default` not given\n        \"\"\"\n        if key in self:\n            self._list_remove(key)\n            return dict.pop(self, key)\n        else:\n            if default is self.__not_given:\n                raise KeyError(key)\n            return default\n\n    def popitem(self, index=-1):\n        \"\"\"Remove and return ``(key, value)`` pair at `index` from sorted dict.\n        Optional argument `index` defaults to -1, the last item in the sorted\n        dict. Specify ``index=0`` for the first item in the sorted dict.\n        If the sorted dict is empty, raises :exc:`KeyError`.\n        If the `index` is out of range, raises :exc:`IndexError`.\n        Runtime complexity: `O(log(n))`\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> sd.popitem()\n        ('c', 3)\n        >>> sd.popitem(0)\n        ('a', 1)\n        >>> sd.popitem(100)\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        :param int index: `index` of item (default -1)\n        :return: key and value pair\n        :raises KeyError: if sorted dict is empty\n        :raises IndexError: if `index` out of range\n        \"\"\"\n        if not self:\n            raise KeyError('popitem(): dictionary is empty')\n\n        key = self._list_pop(index)\n        value = dict.pop(self, key)\n        return (key, value)\n\n    def peekitem(self, index=-1):\n        \"\"\"Return ``(key, value)`` pair at `index` in sorted dict.\n        Optional argument `index` defaults to -1, the last item in the sorted\n        dict. Specify ``index=0`` for the first item in the sorted dict.\n        Unlike :func:`SortedDict.popitem`, the sorted dict is not modified.\n        If the `index` is out of range, raises :exc:`IndexError`.\n        Runtime complexity: `O(log(n))`\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> sd.peekitem()\n        ('c', 3)\n        >>> sd.peekitem(0)\n        ('a', 1)\n        >>> sd.peekitem(100)\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        :param int index: index of item (default -1)\n        :return: key and value pair\n        :raises IndexError: if `index` out of range\n        \"\"\"\n        key = self._list[index]\n        return key, self[key]\n\n    def setdefault(self, key, default=None):\n        \"\"\"Return value for item identified by `key` in sorted dict.\n        If `key` is in the sorted dict then return its value. If `key` is not\n        in the sorted dict then insert `key` with value `default` and return\n        `default`.\n        Optional argument `default` defaults to none.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict()\n        >>> sd.setdefault('a', 1)\n        1\n        >>> sd.setdefault('a', 10)\n        1\n        >>> sd\n        SortedDict({'a': 1})\n        :param key: key for item\n        :param default: value for item (default None)\n        :return: value for item identified by `key`\n        \"\"\"\n        if key in self:\n            return self[key]\n        dict.__setitem__(self, key, default)\n        self._list_add(key)\n        return default\n\n    def update(self, *args, **kwargs):\n        \"\"\"Update sorted dict with items from `args` and `kwargs`.\n        Overwrites existing items.\n        Optional arguments `args` and `kwargs` may be a mapping, an iterable of\n        pairs or keyword arguments. See :func:`SortedDict.__init__` for\n        details.\n        :param args: mapping or iterable of pairs\n        :param kwargs: keyword arguments mapping\n        \"\"\"\n        if not self:\n            dict.update(self, *args, **kwargs)\n            self._list_update(dict.__iter__(self))\n            return\n\n        if not kwargs and len(args) == 1 and isinstance(args[0], dict):\n            pairs = args[0]\n        else:\n            pairs = dict(*args, **kwargs)\n\n        if (10 * len(pairs)) > len(self):\n            dict.update(self, pairs)\n            self._list_clear()\n            self._list_update(dict.__iter__(self))\n        else:\n            for key in pairs:\n                self._setitem(key, pairs[key])\n\n    _update = update\n\n    def __reduce__(self):\n        \"\"\"Support for pickle.\n        The tricks played with caching references in\n        :func:`SortedDict.__init__` confuse pickle so customize the reducer.\n        \"\"\"\n        items = dict.copy(self)\n        return (type(self), (self._key, items))\n\n    @recursive_repr()\n    def __repr__(self):\n        \"\"\"Return string representation of sorted dict.\n        ``sd.__repr__()`` <==> ``repr(sd)``\n        :return: string representation\n        \"\"\"\n        _key = self._key\n        type_name = type(self).__name__\n        key_arg = '' if _key is None else '{0!r}, '.format(_key)\n        item_format = '{0!r}: {1!r}'.format\n        items = ', '.join(item_format(key, self[key]) for key in self._list)\n        return '{0}({1}{{{2}}})'.format(type_name, key_arg, items)\n\n    def _check(self):\n        \"\"\"Check invariants of sorted dict.\n        Runtime complexity: `O(n)`\n        \"\"\"\n        _list = self._list\n        _list._check()\n        assert len(self) == len(_list)\n        assert all(key in self for key in _list)\n\n\ndef _view_delitem(self, index):\n    \"\"\"Remove item at `index` from sorted dict.\n    ``view.__delitem__(index)`` <==> ``del view[index]``\n    Supports slicing.\n    Runtime complexity: `O(log(n))` -- approximate.\n    >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n    >>> view = sd.keys()\n    >>> del view[0]\n    >>> sd\n    SortedDict({'b': 2, 'c': 3})\n    >>> del view[-1]\n    >>> sd\n    SortedDict({'b': 2})\n    >>> del view[:]\n    >>> sd\n    SortedDict({})\n    :param index: integer or slice for indexing\n    :raises IndexError: if index out of range\n    \"\"\"\n    _mapping = self._mapping\n    _list = _mapping._list\n    dict_delitem = dict.__delitem__\n    if isinstance(index, slice):\n        keys = _list[index]\n        del _list[index]\n        for key in keys:\n            dict_delitem(_mapping, key)\n    else:\n        key = _list.pop(index)\n        dict_delitem(_mapping, key)\n\n\nclass SortedKeysView(KeysView, Sequence):\n    \"\"\"Sorted keys view is a dynamic view of the sorted dict's keys.\n    When the sorted dict's keys change, the view reflects those changes.\n    The keys view implements the set and sequence abstract base classes.\n    \"\"\"\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(cls, it):\n        return SortedSet(it)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup key at `index` in sorted keys views.\n        ``skv.__getitem__(index)`` <==> ``skv[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> skv = sd.keys()\n        >>> skv[0]\n        'a'\n        >>> skv[-1]\n        'c'\n        >>> skv[:]\n        ['a', 'b', 'c']\n        >>> skv[100]\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        :param index: integer or slice for indexing\n        :return: key or list of keys\n        :raises IndexError: if index out of range\n        \"\"\"\n        return self._mapping._list[index]\n\n    __delitem__ = _view_delitem\n\n\nclass SortedItemsView(ItemsView, Sequence):\n    \"\"\"Sorted items view is a dynamic view of the sorted dict's items.\n    When the sorted dict's items change, the view reflects those changes.\n    The items view implements the set and sequence abstract base classes.\n    \"\"\"\n    __slots__ = ()\n\n    @classmethod\n    def _from_iterable(cls, it):\n        return SortedSet(it)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup item at `index` in sorted items view.\n        ``siv.__getitem__(index)`` <==> ``siv[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> siv = sd.items()\n        >>> siv[0]\n        ('a', 1)\n        >>> siv[-1]\n        ('c', 3)\n        >>> siv[:]\n        [('a', 1), ('b', 2), ('c', 3)]\n        >>> siv[100]\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        :param index: integer or slice for indexing\n        :return: item or list of items\n        :raises IndexError: if index out of range\n        \"\"\"\n        _mapping = self._mapping\n        _mapping_list = _mapping._list\n\n        if isinstance(index, slice):\n            keys = _mapping_list[index]\n            return [(key, _mapping[key]) for key in keys]\n\n        key = _mapping_list[index]\n        return key, _mapping[key]\n\n    __delitem__ = _view_delitem\n\n\nclass SortedValuesView(ValuesView, Sequence):\n    \"\"\"Sorted values view is a dynamic view of the sorted dict's values.\n    When the sorted dict's values change, the view reflects those changes.\n    The values view implements the sequence abstract base class.\n    \"\"\"\n    __slots__ = ()\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted values view.\n        ``siv.__getitem__(index)`` <==> ``siv[index]``\n        Supports slicing.\n        Runtime complexity: `O(log(n))` -- approximate.\n        >>> sd = SortedDict({'a': 1, 'b': 2, 'c': 3})\n        >>> svv = sd.values()\n        >>> svv[0]\n        1\n        >>> svv[-1]\n        3\n        >>> svv[:]\n        [1, 2, 3]\n        >>> svv[100]\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        :param index: integer or slice for indexing\n        :return: value or list of values\n        :raises IndexError: if index out of range\n        \"\"\"\n        _mapping = self._mapping\n        _mapping_list = _mapping._list\n\n        if isinstance(index, slice):\n            keys = _mapping_list[index]\n            return [_mapping[key] for key in keys]\n\n        key = _mapping_list[index]\n        return _mapping[key]\n\n    __delitem__ = _view_delitem\n# Copyright 2014 - 2019 Grant Jenks\n# https://github.com/grantjenks/python-sortedcontainers\n\n\"\"\"\nsl=SortedList()\nsl.update(not sorted list/str) / list(sl) / list(reversed(sl)) / sl *3\nsl.add(x)\npop(ind) / remove(value) /del sl[1] / clear() \nx in sl / sl.count(x) / sl.index(x) / sl.bl|br / sl[1:4]|sl.islace(1,4)\nNG\nsl[2]=x   <- del[2] & sl.add(x)\nsl.reverse() <- reversed(sl)\nsl.append(x) <- sl.add(x)\n\"\"\"\nsl=SortedList()\nfor i in range(int(input())):\n    x=-int(input())\n    ind=sl.bisect_right(x)\n    if len(sl)!=ind:\n        sl.pop(ind)\n    sl.add(x)\nprint(len(sl))", "import sys\nfrom bisect import bisect_left\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [0] * N\n    for i in range(N):\n        A[i] = int(input())\n\n    colors = []\n    for a in A:\n        idx = bisect_left(colors, a)\n        if idx == 0:\n            colors.insert(0, a)\n        else:\n            colors[idx - 1] = a\n\n    ans = len(colors)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\nINF = 10**18\narr = deque([])\nfor a in A:\n    l, r = -1, len(arr)\n    while (r-l) > 1:\n        mid = (r+l)//2\n        if arr[mid] < a:\n            l = mid\n        else:\n            r = mid\n    if l == -1:\n        arr.appendleft(a)\n    else:\n        arr[l] = a\nprint(len(arr))", "#\u300c\u4e0e\u3048\u3089\u308c\u305f\u6570\u5217\u306e\u3001\u5e83\u7fa9\u5358\u8abf\u6e1b\u5c11\u5217\u306e\u9577\u3055\u306e\u6700\u5927\u5024 L\u300d\nfrom bisect import bisect_left, bisect_right\nn = int(input())\nINF = 1010101010\ndp = [INF] * n\na = [int(input()) for _ in range(n)]\na.reverse()\nfor i in a:\n    dp[bisect_right(dp, i)] = i\nprint(bisect_left(dp, INF))", "# Longest non-increasing subsequence\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\nimport sys\ninput = sys.stdin.readline\n\ndef bisect_right_reverse(L, target):\n    ok = len(L)\n    ng = -1\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        if L[mid] < target:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\ndp = [-1]  # A[i] >= 0\u306a\u306e\u3067\u3001A[0] > dp[0]\u3068\u306a\u308b\u3002\nfor i in range(N):\n    k = bisect_right_reverse(dp, A[i])\n    if k == len(dp):\n        dp.append(A[i])\n    else:\n        dp[k] = A[i]\n\nprint(len(dp))", "n=int(input())\na=[-int(input()) for i in range(n)]\nfrom bisect import bisect_right\nl=[]\nfor aa in a:\n  idx=bisect_right(l,aa)\n  if idx==len(l):\n    l.append(aa)\n  else:\n    l[idx]=aa\nprint(len(l))", "from _bisect import bisect_right\nN=int(input())\nA=[int(input()) for _ in range(N)][::-1]\n\nDP=[A[0]]\nfor i in range(1,N):\n    num=A[i]\n    if num>=DP[-1]:\n        DP.append(num)\n    else:\n        index=bisect_right(DP,num)\n        DP[index]=num\nprint(len(DP))", "import sys\nimport bisect\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    n = int(input())\n    A=[0]*n\n    for i in range(1,n+1):\n        A[-i]=int(input())\n    inf=10**10    \n    dp=[inf]*(n+1)\n    dp[0]=0\n    for AA in A:\n        bis=bisect.bisect_right(dp, AA)\n        dp[bis]=AA #n\u4ee5\u4e0b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    print(bisect.bisect_right(dp, inf-100)-1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nfrom bisect import bisect_left\n\nn=int(input())\nd=deque()\nfor i in range(n):\n  a=int(input())\n  b=bisect_left(d,a)\n  if b==0:\n    d.appendleft(a)\n  else:\n    d[b-1]=a \nprint((len(d)))\n", "n = int(input())\na = [(-1)*int(input()) for _ in range(n)]\ndp = [10**18 for _ in range(n)]\n\nimport bisect\ndef lis(a):\n\t\"\"\"\n\tparam a: list\n\treturn: the length of Longest increasing subsequence\n\t(be careful that [list] seq is not the LIS, but its length is accurate LIS length.)\n\t\"\"\"\n\tseq = []\n\ttmp = 0\n\tfor i in a:\n\t\tpos = bisect.bisect_right(seq, i)\n\t\tif tmp <= pos:\n\t\t\tseq.append(i)\n\t\t\ttmp += 1\n\t\telse:\n\t\t\tseq[pos] = i\n\treturn tmp\n\nprint(lis(a))", "\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque\nn = int(input())\nl = []\nfor _ in range(n):\n    a = int(input())\n    l.append(a)\n\n\nli = deque([l[0]])\nfor j in range(1,n):\n    ai = l[j]\n    ind = bisect_left(li , ai)\n    if ind == 0:\n        li.appendleft(ai)\n    else:\n        li[ind-1] = ai\nprint((len(li)))\n", "from collections import deque\nfrom bisect import bisect_left\n\nn = int(input())\na = [int(input()) for _ in range(n)]\n\ndq = deque()\nfor e in a:\n    i = bisect_left(dq, e)\n    if i == 0:\n        dq.appendleft(e)\n    else:\n        dq[i-1] = e\n\nans = len(dq)\nprint(ans)\n", "import bisect\nn = int(input())\ncolors = [-1]*(n+1)\nfor _ in range(n):\n    a = int(input())\n    idx = bisect.bisect_left(colors, a)-1\n    colors[idx] = a\nprint((n-bisect.bisect_left(colors, 0)+1))\n", "from bisect import bisect_left\nN = int(input())\nA = [int(input()) for _ in range(N)]\nL = [-1] * N\nfor a in A:\n    idx = bisect_left(L, a)\n    L[idx-1] = a\nprint((N - L.count(-1)))\n", "import bisect\n# from collections import deque\n# from collections import Counter\n# from fractions import gcd # >=Python3.5 # lcm\uff08\u6700\u5c0f\u516c\u500d\u6570\uff09 = (a*b)//gcd(a,b)\n# from fractions import Fraction\n# from math import gcd # <Python3.5\n# from math import sqrt\n \nn = int(input())\nli = [int(input()) for i in range(n)]\nli = [-x for x in li]\n\nX = []\nX.append(li[0])\n\nfor i in range(1,n):\n    idx = bisect.bisect_right(X,li[i])\n    if idx==len(X):\n        X.append(li[i])\n    else:\n        X[idx] = li[i]\n\nprint(len(X))", "from bisect import bisect_right\n\nn = int(input())\na = [-int(input()) for _ in range(n)]\n\nli = list()\nfor e in a:\n    i = bisect_right(li, e)\n    if i == len(li):\n        li.append(e)\n    else:\n        li[i] = e\n\nans = len(li)\nprint(ans)\n", "# AtCoder Beginner Contest 134 E - Sequence Decomposing\n\nimport sys\n\nN = int(input())\nnow = int(sys.stdin.readline().strip())\nans = [now]\n\nfor n in range(N - 1):\n    now = int(sys.stdin.readline().strip())\n\n    if now > ans[0]:\n        ans[0] = now\n    elif ans[-1] >= now:\n        ans.append(now)\n    else:\n        # 2\u90e8\u63a2\u67fb\u3067\u884c\u9032\u4f4d\u7f6e\u3092\u63a2\u308b\n        left = 0  # \u633f\u5165\u4e0d\u53ef\u80fd\n        right = len(ans) - 1  # \u633f\u5165\u53ef\u80fd\n\n        while right - left > 1:\n            mid = (right + left) // 2\n            if now > ans[mid]:\n                right = mid\n            else:\n                left = mid\n\n        ans[right] = now\n\nprint((len(ans)))\n", "from bisect import bisect_right\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\nA = A[::-1]\n\nLIS = []\n\nfor ai in A:\n    index = bisect_right(LIS,ai)\n    if index >= len(LIS):\n        LIS.append(ai)\n    else:\n        LIS[index] = ai\n\nprint(len(LIS))", "import bisect\nn=int(input())\na=[int(input()) for _ in range(n)][::-1]\ndp=[]\nfor i in a:\n  if bisect.bisect_right(dp,i)==len(dp):\n    dp.append(i)\n  else:\n    dp[bisect.bisect_right(dp,i)]=i\nprint(len(dp))", "from collections import deque\nimport bisect\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nQ = deque([A[0]])\nfor a in A[1:]:\n    if a <= Q[0]:\n        Q.appendleft(a)\n    else:\n        idx = bisect.bisect_left(Q,a)\n        Q[idx-1] = a\n\nprint(len(Q))", "N = int(input())\nA = [int(input()) for _ in range(N)]\ndef solve(A,n):\n    import bisect\n    dp = [float('inf')] * n\n    for i in range(n-1,-1,-1):\n        k = bisect.bisect_right(dp, A[i])\n        dp[k] = A[i]\n    ans = 0\n    for a in dp:\n        if a != float('inf'):\n            ans += 1\n        else:\n            break\n    return ans\nprint(solve(A,N))", "from bisect import bisect, bisect_left\n\nN = int(input())\ndp = [1]*N\n\nfor _ in range(N):\n  a = -int(input())\n  n = bisect(dp, a)\n  dp[n] = a\n\nprint(sum( 1 for i in dp if i <= 0 ))", "#!/usr/bin/env python3\nfrom collections import deque\nfrom bisect import bisect_left\n\ndef main():\n    N, *A = map(int, open(0))\n    # \u65b9\u91dd: \u8272\u3054\u3068\u306b\u6700\u5927\u5024\u3092\u30ea\u30b9\u30c8\u3067\u4fdd\u6301\u3059\u308b\n    # \u65b0\u3057\u304f\u8272\u3092\u8ffd\u52a0\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u6642\u306f\u6301\u3063\u3066\u3044\u308b\u5168\u3066\u306e\u6570\u5b57\u3088\u308a\u5c0f\u3055\u3044\u6642->\u5148\u982d\u8ffd\u52a0\u306a\u306e\u3067deque\u304c\u3044\u3044\n    # deque\u3092bisect\u3067\u4e8c\u5206\u63a2\u7d22\u3067\u304d\u308b\u3093\u3060...\n    q = deque([])\n    for i in range(N):\n        d = bisect_left(q,A[i])\n        if d == 0:\n            q.appendleft(A[i])\n        else:\n            q[d-1] = A[i]\n    print(len(q))\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom bisect import bisect_left\n\nN = int(input())\nA = []\nfor _ in range(N):\n    x = int(input())\n    idx = bisect_left(A, x)\n    if idx == 0:\n        A.insert(idx, x)\n    elif A[idx-1] == x:\n        A.insert(idx, x)\n    else:\n        A[idx-1] = x\n#    print(A,x)\nprint((len(A)))\n", "from collections import deque\nimport bisect\n\nN = int(input())\ntable = deque()\nfor n in range(N):\n    a = int(input())\n    if n == 0:\n        table.append(a)\n    else:\n        if a <= table[0]:\n            table.appendleft(a)\n        else:\n            table[bisect.bisect_left(table, a)-1] = a\n            \nprint(len(table))", "import sys\nimport bisect\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\nA = A[::-1]\n\n\ndef solve():\n\n    LIS = [A[0]]\n    for i in range(1, N):\n\n        if A[i] >= LIS[-1]:\n            LIS.append(A[i])\n        else:\n            LIS[bisect.bisect_right(LIS, A[i])] = A[i]\n\n    ans = len(LIS)\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "# YouTube\u89e3\u8aac\u306e\u65b9\u6cd5\uff08deque\u4f7f\u308f\u306a\u3044\uff09\nimport sys\ninput = sys.stdin.readline\n\ndef bisect_right_reverse(L, target):\n    ok = len(L)\n    ng = -1\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        if L[mid] < target:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nL = []\nfor i in range(N):\n    k = bisect_right_reverse(L, A[i])\n    if k == len(L):\n        L.append(A[i])\n    else:\n        L[k] = A[i]\n\nprint(len(L))", "from bisect import bisect_right\n\n\nN, *A = list(map(int, open(0).read().split()))\nA = [-a for a in A]\nq = []\nfor a in A:\n    idx = bisect_right(q, a)\n    if idx == len(q):\n        q.append(a)\n    else:\n        q[idx] = a\nprint((len(q)))\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nans = []\nimport bisect\nfor i in range(N):\n  a = -int(readline())\n  ind = bisect.bisect_right(ans, a)\n  if ind == len(ans):\n    ans.append(a)\n  else:\n    ans[ind] = a\n    \nprint((len(ans)))\n", "import bisect\n\n\ndef main():\n    INF = 10 ** 10\n    N = int(input())\n    A = [int(input()) for _ in range(N)]\n    A.reverse()\n    B = [INF for _ in range(N)]\n    for a in A:\n        index = bisect.bisect_right(B, a)\n        B[index] = a\n    ans = 0\n    for b in B:\n        if b == INF:\n            break\n        ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\nn = int(input())\ncolors = [-1]*(n+1)\nfor _ in range(n):\n    a = int(input())\n    idx = bisect.bisect_left(colors, a)-1\n    colors[idx] = a\nprint((colors[::-1].index(-1)))\n", "import bisect, copy, heapq, math\nfrom math import inf\nimport sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\ndef celi(a,b):\n    return -(-a//b)\nsys.setrecursionlimit(5000000)\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn=int(input())\na=[int(input()) for i in range(n)]\n\nnow=n\nlst=[-1]*n\n\nfor i in range(n):\n    tmp=bisect.bisect_left(lst,a[i])\n    if tmp==now:\n        lst[tmp-1]=a[i]\n        now-=1\n    else:\n        lst[tmp-1]=a[i]\n# print(lst)\nprint(n-now)", "import bisect\nn = int(input())\na = [int(input()) for i in range(n)][::-1]\n\ncolor_num = [a[0]]\nfor i in range(1, n):\n    if a[i] >= color_num[-1]:\n        color_num.append(a[i])\n    else:\n        temp = bisect.bisect_right(color_num, a[i])\n        color_num[temp] = a[i]\n\n\nprint(len(color_num))", "import bisect\nN= int(input())\ndp = [-1]*N\ncnt =0\nfor i in range(N):\n    a = int(input())\n    idx = bisect.bisect_left(dp,a)\n    dp[idx-1]=a\nprint((len(dp[bisect.bisect_left(dp,0):])))\n", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_left, bisect_right\n\n\ndef read():\n    N = int(input().strip())\n    A = [int(input().strip()) for _ in range(N)]\n    return N, A\n\n\ndef solve(N, A, INF=10**9+1):\n    # LIS\n    # dp[i]: \u9577\u3055i\u306e\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217(A[i]<A[j])\u306e\u3046\u3061\u3001\u6700\u3082\u5c0f\u3055\u3044\u6570\u5b57\n    dp = [INF for i in range(N)]\n    for i in range(N):\n        a = A[N-i-1]\n        idx = bisect_right(dp, a)\n        dp[idx] = a\n    return bisect_right(dp, INF-1)\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "from bisect import bisect\nN = int(input())\ndp = [1]*N\nfor _ in range(N):\n  a=-int(input())\n  n=bisect(dp,a)\n  dp[n]=a\nprint(sum(1 for i in dp if i <= 0))", "import bisect\nfrom collections import deque\n\nN = int(input())\nA = []\nfor _ in range(N):\n    A.append(int(input()))\n\nbuf = deque()\nfor a in A:\n    i = bisect.bisect_right(buf, a-1)-1\n    if i < 0:\n        buf.appendleft(a)\n    else:\n        buf[i] = a\nprint(len(buf))", "from collections import deque\nfrom bisect import bisect_left\n\nn = int(input())\na = [int(input()) for _ in range(n)]\n\ndp = deque([])\nb = []\nfor i in range(n):\n    j = bisect_left(dp, a[i])\n    if j == 0:\n        dp.appendleft(a[i])\n    else:\n        dp[j-1] = a[i]\n\nprint((len(dp)))\n", "from bisect import bisect_left\nfrom collections import deque\n\nn = int(input())\nans = []\nans.append(int(input()))\nans = deque(ans)\nfor i in range(n-1):  \n  temp = int(input())\n  if temp <= ans[0]:\n    ans.appendleft(temp)\n  else:\n    ans[bisect_left(ans, temp)-1]=temp\nprint((len(ans)))\n", "import bisect\nN= int(input())\ndp = [-1]*N\ncnt =0\nfor _ in range(N):\n    a = int(input())\n    idx = bisect.bisect_left(dp,a)\n    dp[idx-1]=a\nprint((len(dp[bisect.bisect_left(dp,0):])))\n", "import bisect\n\nn = int(input())\na = []\n\nfor i in range(n):\n    x = int(input())\n    a.append(x)\na = a[::-1]\n\nstack = [a[0]]\n\nfor i in range(1, n):\n    index = bisect.bisect_right(stack, a[i])\n    if index == len(stack):\n        stack.append(a[i])\n    else:\n        stack[index] = a[i]\n\nprint((len(stack)))\n", "from bisect import bisect_left, bisect_right\nN = int(input())\nseq = [0] * N\nfor i in range(N):\n  seq[i] = (-1) * int(input())\n\n\"\"\"\n#\u30ea\u30b9\u30c8seq\u304b\u3089LIS\u306e\u9577\u3055\u3092\u51fa\u3059\nLIS = [seq[0]]\nfor i in range(len(seq)):\n    if seq[i] >= LIS[-1]:\n        LIS.append(seq[i])\n    else:\n        LIS[bisect_right(LIS, seq[i])] = seq[i]\n\nprint(len(LIS) - 1)\n#print(LIS)\n\"\"\"\ndef getLIS(_N,a):\n  INF = 1e18\n  MaxP = _N+10\n  dp = [INF for _ in range(MaxP)]\n  for i in range(_N):\n    dp[bisect_right(dp,a[i])] = a[i]\n\n  #print(dp[:10])\n  return dp[:bisect_left(dp, INF)]\n\nLIS2 = getLIS(N,seq)\n\nprint(len(LIS2))", "from bisect import bisect_right\n\ndef main():\n    inf=float(\"inf\")\n    n=int(input())\n    alst=[int(input()) for _ in range(n)]\n    work=[inf]*n\n    for i in range(n-1,-1,-1):\n        j=bisect_right(work,alst[i])\n        work[j]=alst[i]\n    print(n-work.count(inf))\n\nmain()", "from bisect import bisect_right\nn = int(input())\n\ncolor = [0] * (n+1)\nfor i in range(n):\n    a = int(input())\n    j = bisect_right(color, a)\n    color[j-1] = a+1\n\nans = 0\nfor t in color:\n    if t != 0:\n        ans += 1\n\nprint(ans)\n\n", "from bisect import bisect_left,bisect_right\nn=int(input())\nINF=float('inf')\nl=[INF]*n\na=[int(input()) for _ in range(n)]\nfor i in a[::-1]:\n    l[bisect_right(l,i)]=i\nprint(bisect_left(l,INF))", "import bisect\n\nN = int(input())\nA = [int(input()) for i in range(N)]\n\ndef lis(S):\n    from bisect import bisect_right\n    L = [S[0]]\n\n    for s in S[1:]:\n        if s >= L[-1]:\n            L.append(s)\n        else:\n            L[bisect_right(L, s)] = s\n    return len(L)\n\nprint(lis(A[::-1]))", "import sys\nfrom bisect import bisect_right\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec = [INF] * N\n    for a in reversed(A):\n        vec[bisect_right(vec, a)] = a\n\n    try:\n        print((vec.index(INF)))\n    except:\n        print(N)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect\n\nn=int(input())\na=[0]*n\nfor i in range(n):\n    a[i]=-int(input())\n\ndef loopa():\n\n    n=len(a)\n    dp = [10**10]*(n+1)\n    dp[0] = -10**10\n    \n    for i in range(n):\n        idx = bisect(dp, a[i])\n        dp[idx] = min(a[i], dp[idx])\n\n    return dp\n\ndp=loopa()        \n\nprint((bisect(dp, 10**10-1)-1))    \n\n", "# \u8caa\u6b32\u3067\u3044\u3044\u3088\u306d\u3002\n# \u6700\u521d\u304b\u3089\u9806\u306b\u898b\u3066\u3044\u3063\u3066\u3001\u5897\u52a0\u5217\u3067\u53d6\u308c\u308b\u306a\u3089\u305d\u306e\u3046\u3061\u6700\u5927\u306e\u3082\u306e\u3067\u53d6\u308b\u3001\u7121\u7406\u306a\u3089\u65b0\u8a2d\u3059\u308b\u3002\n# \u3053\u308c\u304c\u6700\u9069\u306a\u7406\u7531\u306f\u2026\u2026\u53b3\u5bc6\u306b\u306f\u96e3\u3057\u3044\u306a\u3041\u3002\u3061\u3083\u3093\u3068\u5206\u304b\u3063\u3066\u306a\u3044\u3002\n\n# \u3067\u3053\u308c\u3092\u5b9f\u73fe\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u306f\u4f55\u304c\u826f\u3044\u304b\u3092\u8003\u3048\u308b\u308f\u3051\u3088\u306d\u3002\n# \u30bd\u30fc\u30c8\u3057\u305f\u30c7\u30fc\u30bf\u304b\u3089\u6307\u5b9a\u306e\u3082\u306e\u3092\u63a2\u3059\u30fb\u5024\u3092\u53d6\u308a\u51fa\u3059\u30fb\u65b0\u898f\u3067\u5165\u308c\u308b \u3092\u3057\u306a\u304d\u3083\u3044\u3051\u306a\u3044\u304b\u3089\u3001C++\u306eset\uff08\u5e73\u8861\u4e8c\u5206\u63a2\u7d22\u6728\uff09\u4f7f\u308f\u306a\u3044\u3068\u7121\u7406\u3058\u3083\u306d?\n# \u3068\u4e00\u77ac\u601d\u3046\u3051\u3069\u3001\u666e\u901a\u306e\u30ea\u30b9\u30c8\u3067\u53ef\u80fd\u3002\n# \u306a\u305c\u306a\u3089\u3001\u5024\u3092\u66f8\u304d\u63db\u3048\u308b\u3053\u3068\u3067\u30bd\u30fc\u30c8\u306f\u5d29\u308c\u306a\u3044\u304b\u3089\u3002\n# T\u304c\u6765\u305f\u3089\u3001T\u672a\u6e80\u306e\u3046\u3061\u6700\u3082\u53f3\u306e\u8981\u7d20\u3092\u898b\u3064\u3051\u3066\u3001T\u306b\u66f8\u304d\u63db\u3048\u308b\u3002T\u672a\u6e80\u3068T\u4ee5\u4e0a\u306e\u5883\u754c\u306a\u306e\u3067\u3001T\u306b\u66f8\u304d\u63db\u3048\u3066\u3082\u5024\u306f\u30bd\u30fc\u30c8\u9806\u3092\u98db\u3073\u8d8a\u3055\u306a\u3044\u3002\n\n# \u6607\u9806\u3067\u7ba1\u7406\u3060\u3068TLE\u306a\u306e\u3067\u964d\u9806\u306b\u3057\u307e\u3059\u2192bisect\u304c\u4f7f\u3048\u306a\u3044\u3084\u3093\u3051\u2192-1\u500d\u3057\u3066\u6607\u9806\u306b\u3057\u307e\u3059\n\nimport bisect\n\nn = int(input())\n\nans = 0\nmylist = []\nfor i in range(n):\n    k = int(input())\n    idx = bisect.bisect(mylist, -k)\n    if idx == ans:\n        mylist.append(-k)\n        ans += 1\n    else:\n        mylist[idx] = -k  # \u3053\u306e\u64cd\u4f5c\u306b\u3088\u308a\u30bd\u30fc\u30c8\u306f\u5d29\u308c\u306a\u3044\n\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\nfrom bisect import bisect_right\n\nINF = float(\"inf\")\n\n\ndef main():\n    N = int(input())\n    A = [int(input()) for _ in range(N)]\n\n    dp = [INF]*N\n    for i in range(N):\n        j = bisect_right(dp, -A[i])\n        dp[j] = -A[i]\n\n    print((sum([1 for d in dp if d < INF])))\n    # print(dp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nfrom bisect import bisect_left\nN = int(input())\nA = [int(input()) for i in range(N)]\n\nX = deque([])\n\nfor a in A:\n  i = bisect_left(X,a)\n  if i == 0:\n    X.appendleft(a)\n  else:\n    X[i-1] = a\nprint(len(X))", "from bisect import bisect_right\nN = int(input())\nA = [int(input()) for _ in range(N)]\nans = 1\nmin_vs = [A[-1]]\nfor i in range(N-2, -1, -1):\n    a = A[i]\n    idx = bisect_right(min_vs, a)\n    if idx == len(min_vs):\n        ans += 1\n        min_vs.append(a)\n    else:\n        min_vs[idx] = a\nprint(ans)\n", "def binary_search(key):\n    bad, good = -1, len(ans)\n    while good - bad > 1:\n        mid = (bad + good) // 2\n        if ans[mid][-1] < key:\n            good = mid\n        else:\n            bad = mid\n    return good\n\n\nN = int(input())\nans = []\nfor _ in range(N):\n    A = int(input())\n    idx = binary_search(A)\n    if idx == len(ans):\n        ans.append([A])\n    else:\n        ans[idx].append(A)\nprint((len(ans)))\n", "import bisect\nfrom collections import deque\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\ndp = deque()\ndp.append(A[0])\n\nfor i in range(1, N):\n    ind = bisect.bisect_left(dp, A[i])\n\n    if ind == 0:\n        dp.appendleft(A[i])\n    elif dp[-1] < A[i]:\n        dp[-1] = A[i]\n    else:\n        dp[ind-1] = A[i]\n\nprint(len(dp))", "from collections import deque\nimport bisect\n\nN = int(input())\n\nA = [int(input()) for i in range(N)]\n\nq = deque([A[0]])\n\nfor a in A[1:]:\n    idx = bisect.bisect_left(q, a)\n    if idx == 0:\n        q.appendleft(a)\n    else:\n        q[idx-1] = a\n\nprint(len(q))", "from bisect import bisect_left\nfrom collections import deque\n\nn = int(input())\nA = [int(input()) for _ in range(n)]\n\nD = deque([])\n\nfor a in A:\n    i = bisect_left(D, a)\n    if i == 0:\n        D.appendleft(a)\n    else:\n        D[i-1] = a\n\nprint(len(D))", "import bisect\nfrom collections import deque\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\ndp = deque()\ndp.append(A[0])\n\nfor i in range(1, N):\n    ind = bisect.bisect_left(dp, A[i])\n\n    if ind == 0:\n        dp.appendleft(A[i])\n    # elif dp[-1] < A[i]:\n    #     dp[-1] = A[i]\n    else:\n        dp[ind-1] = A[i]\n\nprint(len(dp))", "from collections import deque\nfrom bisect import bisect_left\nN = int(input())\nA = [int(input()) for _ in range(N)]\nque = deque()\nfor i in range(N):\n    k = bisect_left(que, A[i])\n    if k == 0:\n        que.appendleft(A[i])\n    else:\n        que[k - 1] = A[i]\n\nprint(len(que))", "import bisect\nn, *a = list(map(int, open(0).read().split()))\na = a[::-1]\nINF = 1 << 30\ndp = [INF] * (n + 1)\n\nfor e in a:\n    dp[bisect.bisect_right(dp, e)] = e\nprint((bisect.bisect_left(dp, INF)))\n", "import sys\nfrom bisect import bisect_right\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec = [A[-1]]\n    for a in reversed(A[:-1]):\n        if a >= vec[-1]:\n            vec.append(a)\n        else:\n            vec[bisect_right(vec, a)] = a\n\n    print((len(vec)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = list(int(input()) for _ in range(n))\n\n    que = deque([A[0]])\n    for i in range(1, n):\n        idx = bisect_left(que, A[i])\n        if idx == 0:\n            que.appendleft(A[i])\n        else:\n            idx -= 1\n            que[idx] = A[i]\n    print((len(que)))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_left\nn = int(input())\na = [int(input()) for i in range(n)]\ndp = [-float(\"inf\")] * (n + 1)\nfor i in a:\n    dp[bisect_left(dp, i) - 1] = i\nprint(dp[::-1].index(-float(\"inf\")))", "def bisect_right_reverse(a, x):\n    '''\n    reverse\u306b\u30bd\u30fc\u30c8\u3055\u308c\u305flist a\u306b\u5bfe\u3057\u3066x\u3092\u633f\u5165\u3067\u304d\u308bidx\u3092\u8fd4\u3059\u3002\n    x\u304c\u5b58\u5728\u3059\u308b\u5834\u5408\u306b\u306f\u4e00\u756a\u53f3\u5074\u306eidx+1\u3068\u306a\u308b\u3002\n    '''\n    if a[0] < x:\n        return 0\n    if x <= a[-1]:\n        return len(a)\n    # \u4e8c\u5206\u63a2\u7d22\n    ok = len(a) - 1\n    ng = 0\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if a[mid] < x:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef main():\n  N = int(input())\n  ans = 1\n  lis_min = [int(input())]\n  for i in range(N-1):\n    a = int(input())\n    index = bisect_right_reverse(lis_min, a)\n    if index != len(lis_min):\n      lis_min[index] = a\n    else:\n      ans += 1\n      lis_min.append(a)\n  print(ans)\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nfrom bisect import bisect_right\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec = [A[-1]]\n    for a in reversed(A[:-1]):\n        if a >= vec[-1]:\n            vec.append(a)\n        else:\n            vec[bisect_right(vec, a)] = a\n\n    print((len(vec)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#import sys\n#import numpy as np\nimport math\n#from fractions import Fraction\nimport itertools\nfrom collections import deque\nfrom collections import Counter\nimport heapq\n#from fractions  import gcd\n#input=sys.stdin.readline\nimport bisect\nn=int(input())\nd=[]\na=(int(input()))*-1\nd.append(a)\nans=1\nfor i in range(n-1):\n    a=-1*(int(input()))\n    ind=bisect.bisect_right(d,a)\n    l=len(d)\n    if ind==l:\n        d.append(a)\n        ans+=1\n    else:\n        d[ind]=a\nprint(ans)", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  n=I()\n  _l=[I() for _ in range(n)]\n  l=collections.deque()\n\n  for A in _l:\n    if len(l)==0:\n      l.append(A)\n      continue\n\n    lv=l[0]\n    rv=l[-1]\n    if rv<A:\n      l[-1]=A\n      continue\n    if A<=lv:\n      l.appendleft(A)\n      continue\n\n    li=0\n    ri=len(l)-1\n    while ri-li>1:\n      mi=(ri+li)//2\n      if l[mi]<A:\n        li=mi\n      else:\n        ri=mi\n\n    l[li]=A\n\n  # print(l)\n  return len(l)\n\n# main()\nprint((main()))\n", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN = int(input())\nAs = [-int(input()) for _ in range(N)]\n\nfrom bisect import bisect_right\nlis = [1]\nfor a in As:\n    if a>=lis[-1]:\n        lis.append(a)\n    else:\n        lis[bisect_right(lis, a)] = a\n\nprint(len(lis))", "import bisect\nfrom collections import deque\n\nn = int(input())\n#c = []\nc = deque([])\nfor i in range(n):\n    a = int(input())\n    if i == 0:\n        c.append(a)\n    else:\n        ind = bisect.bisect_left(c,a)\n        if ind > 0:\n            c[ind-1] = a\n        else:\n            c.appendleft(a)\n\nprint(len(c))", "def resolve():\n    N = int(input())\n    A = [int(input()) for _ in range(N)]\n    import bisect\n    import collections\n    colormax = collections.deque([A[0]])\n    for i in range(1, N):\n        idx = bisect.bisect_left(colormax, A[i])\n        if idx == 0:\n            colormax.appendleft(A[i])\n        else:\n            colormax[idx-1] = A[i]\n    print(len(colormax))\n\n\n\nif '__main__' == __name__:\n    resolve()", "#!/usr/bin/env python3\nimport sys\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\nINF = float(\"inf\")\n\n\ndef main():\n    N = int(input())\n    A = [int(input()) for _ in range(N)]\n\n    dp = [INF]*N\n    for i in range(N):\n        j = bisect_right(dp, -A[i])\n        dp[j] = -A[i]\n\n    print((bisect_left(dp, INF)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from random import random\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 6)\n\n\nclass TreapNode:\n    _value = None\n    _priority = None\n    _count = None\n    _left = None\n    _right = None\n\n    def __init__(self, value):\n        self._value = value\n        self._priority = random()\n        self._count = 1\n\n\ndef treap_rotate_right(n):\n    l = n._left\n    n._left = l._right\n    l._right = n\n    return l\n\n\ndef treap_rotate_left(n):\n    r = n._right\n    n._right = r._left\n    r._left = n\n    return r\n\n\ndef treap_insert(n, v):\n    if n is None:\n        return TreapNode(v)\n    if n._value == v:\n        n._count += 1\n        return n\n    if n._value > v:\n        n._left = treap_insert(n._left, v)\n        if n._priority > n._left._priority:\n            n = treap_rotate_right(n)\n    else:\n        n._right = treap_insert(n._right, v)\n        if n._priority > n._right._priority:\n            n = treap_rotate_left(n)\n    return n\n\n\ndef treap_delete(n, v):\n    if n is None:\n        raise Exception('no nodes')\n    if n._value > v:\n        n._left = treap_delete(n._left, v)\n        return n\n    if n._value < v:\n        n._right = treap_delete(n._right, v)\n        return n\n\n    # n._value == v\n    if n._count > 1:\n        n._count -= 1\n        return n\n\n    if n._left is None and n._right is None:\n        return None\n\n    if n._left is None:\n        n = treap_rotate_left(n)\n    elif n._right is None:\n        n = treap_rotate_right(n)\n    else:\n        # n._left is not None and n._right is not None\n        if n._left._priority < n._right._priority:\n            n = treap_rotate_right(n)\n        else:\n            n = treap_rotate_left(n)\n    return treap_delete(n, v)\n\n\ndef treap_size(n):\n    if n is None:\n        return 0\n    return n._count + treap_size(n._left) + treap_size(n._right)\n\n\ndef treap_str(n):\n    if n is None:\n        return \"\"\n    result = []\n    if n._left is not None:\n        result.append(treap_str(n._left))\n    result.append(\"%d:%d\" % (n._value, n._count))\n    if n._right is not None:\n        result.append(treap_str(n._right))\n    return ' '.join(result)\n\n\ndef treap_search(n, v):\n    # v \u672a\u6e80\u3067\u6700\u5927\u306e\u30ce\u30fc\u30c9\u3092\u691c\u7d22\u3059\u308b. v \u672a\u6e80\u306e\u30ce\u30fc\u30c9\u304c\u306a\u3051\u308c\u3070 None \u3092\u8fd4\u3059\n    if n is None:\n        return None\n    if n._value >= v:\n        if n._left is None:\n            return None\n        return treap_search(n._left, v)\n    # n._value < v\n    if n._right is None:\n        return n\n    r = treap_search(n._right, v)\n    if r is None:\n        return n\n    return r\n\n\nclass Treap:\n    _root = None\n    _size = 0\n\n    def insert(self, v):\n        self._root = treap_insert(self._root, v)\n        self._size += 1\n\n    def delete(self, v):\n        self._root = treap_delete(self._root, v)\n        self._size -= 1\n\n    def __len__(self):\n        return self._size\n\n    def __str__(self):\n        return treap_str(self._root)\n\n    def search(self, v):\n        return treap_search(self._root, v)\n\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nt = Treap()\nfor a in A:\n    n = t.search(a)\n    if n is not None:\n        t.delete(n._value)\n    t.insert(a)\nprint((len(t)))\n", "from collections import deque\nfrom bisect import bisect_left\n\nn=int(input())\na=[int(input()) for i in range(n)]\n\nd=deque()\nfor i in range(n):\n  b=bisect_left(d,a[i])\n  if b==0:\n    d.appendleft(a[i])\n  else:\n    d[b-1]=a[i]\n    \nprint((len(d)))\n", "import sys\nfrom collections import deque\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = list(int(input()) for _ in range(n))\n\n    LIS = deque()\n    for i in range(n):\n        if len(LIS) == 0:\n            LIS.appendleft(A[i])\n        else:\n            idx = bisect_left(LIS, A[i])\n            if idx == 0:\n                LIS.appendleft(A[i])\n            else:\n                LIS[idx - 1] = A[i]\n    print((len(LIS)))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import bisect\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\ndp = [-1] * N\ndp[N-1] = A[0]\n\nans = 0\nfor i in range(1, N):\n    target_index = bisect.bisect_left(dp, A[i])\n    dp[target_index-1] = A[i]\n\nprint(N - dp.count(-1))", "N = int(input())\nA = list(int(input()) for _ in range(N))\n\nS = [A[0]]\nfor i in range(1, N):\n    if A[i] <= S[0]:\n        S.insert(0, A[i])\n        continue\n    ok = 0\n    ng = len(S)\n    tmp = (ok+ng)\n    while ok+1 < ng:\n        tmp = (ok+ng)//2\n        if A[i] > S[tmp]:\n            ok = tmp\n        else:\n            ng = tmp\n    S[ok] = A[i]\nprint((len(S)))\n", "import sys\nfrom bisect import bisect_right\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec = [INF] * N\n    for a in reversed(A):\n        vec[bisect_right(vec, a)] = a\n\n    print((N - vec.count(INF)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nA = []\nfor i in range(N):\n  temp = int(input())\n  A.append(temp)\n#print(A)\nL = [A[0]]\nfor i in range(1,N):\n  if L[-1] >= A[i]:\n    L.append(A[i])\n  else:\n    if L[0] < A[i]:\n      L[0] = A[i]\n    else:\n      s = len(L)\n      ok = s\n      ng = 0\n      while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if L[mid] < A[i]:\n          ok = mid\n        else:\n          ng = mid\n      L[ok] = A[i]\n  #print(L)\nans = len(L)\nprint(ans)", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\nn=I()\nlis=[I() for i in range(n)]\ncols=deque([inf])\ni=0\nwhile i<n:\n    #print(cols)\n    x=lis[i]\n    if cols[0]>=x:\n        cols.appendleft(x)\n    else:\n        cols[bisect_left(cols,x)-1]=x\n        #print(bisect_left(cols,x))\n    i+=1\n#print(cols)\nprint((len(cols)-1))\n\n    \n    \n\n", "import bisect\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nA.reverse()\n\ndp = [A[0]]\n\nfor a in A[1:]:\n    idx = bisect.bisect_right(dp, a)\n    if idx == len(dp):\n        dp.append(a)\n    else:\n        dp[idx] = a\n\nprint(len(dp))", "from bisect import *\ndef solve():\n    ans = 0\n    N = int(input())\n    A = [-int(input()) for _ in range(N)]\n    lis = [A[0]]\n    for i in range(1,N):\n        if A[i]>=lis[-1]:\n            lis.append(A[i])\n        else:\n            ind = bisect_right(lis,A[i])\n            lis[ind] = A[i]\n    ans = len(lis)\n    return ans\nprint(solve())", "from bisect import bisect\nimport heapq\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\nq = []\nA.reverse()\n\nfor i in range(N):\n  ii = bisect(q,A[i])\n  if ii == len(q):\n    heapq.heappush(q,A[i])\n  else:\n    q[ii] = A[i]\n    \nprint(len(q))", "from collections import deque\nimport bisect\nN=int(input())\nL=deque()\nfor i in range(N):\n  s=int(input())\n  if i==0:\n    L.append(s)\n  else:\n    if s<=L[0]:\n      L.appendleft(s)\n    else:\n      L[bisect.bisect(L,s-1)-1]=s\nprint(len(L))", "import sys\nimport bisect\ndef input(): return sys.stdin.readline().rstrip()\n \n \ndef main():\n    n = int(input())\n    A=[0]*n\n    for i in range(1,n+1):\n        A[-i]=int(input())\n    inf=10**10    \n    dp=[0]\n    for AA in A:\n        if dp[-1]<=AA:\n            dp.append(AA)\n        else:\n            bis=bisect.bisect_right(dp, AA)\n            dp[bis]=AA #n\u4ee5\u4e0b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    print(len(dp)-1)\n \n \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom bisect import bisect_left, insort_right\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [0] * N\n    for i in range(N):\n        A[i] = int(input())\n\n    colors = []\n    for a in A:\n        idx = bisect_left(colors, a)\n        if idx != 0:\n            colors.pop(idx - 1)\n        insort_right(colors, a)\n\n    ans = len(colors)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_right\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [0] * N\n    for i in range(N):\n        A[i] = int(input())\n\n    A = [-a for a in A]\n\n    colors = []\n    for a in A:\n        idx = bisect_right(colors, a)\n        if idx == len(colors):\n            colors.append(a)\n        else:\n            colors[idx] = a\n\n    ans = len(colors)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\na=[int(input())for _ in range(n)]\ndp=[2]*(n+1)\nfrom bisect import bisect_left,bisect_right\nfor i in a:\n  dp[bisect_left(dp,-i+1)]=-i\nprint(dp.index(2))", "from bisect import bisect_right\n\nn = int(input())\na = [-int(input()) for _ in range(n)]\n\nlst = [a[0]]\nfor aa in a[1:]:\n    i = bisect_right(lst, aa)\n    if i == len(lst): lst.append(aa)\n    else: lst[i] = aa\n\nprint(len(lst))", "from random import random\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 5)\n\n\nclass TreapNode:\n    _value = None\n    _priority = None\n    _count = None\n    _left = None\n    _right = None\n\n    def __init__(self, value):\n        self._value = value\n        self._priority = random()\n        self._count = 1\n\n\ndef treap_rotate_right(n):\n    l = n._left\n    n._left = l._right\n    l._right = n\n    return l\n\n\ndef treap_rotate_left(n):\n    r = n._right\n    n._right = r._left\n    r._left = n\n    return r\n\n\ndef treap_insert(n, v):\n    if n is None:\n        return TreapNode(v)\n    if n._value == v:\n        n._count += 1\n        return n\n    if n._value > v:\n        n._left = treap_insert(n._left, v)\n        if n._priority > n._left._priority:\n            n = treap_rotate_right(n)\n    else:\n        n._right = treap_insert(n._right, v)\n        if n._priority > n._right._priority:\n            n = treap_rotate_left(n)\n    return n\n\n\ndef treap_delete(n, v):\n    if n is None:\n        raise Exception('no nodes')\n    if n._value > v:\n        n._left = treap_delete(n._left, v)\n        return n\n    if n._value < v:\n        n._right = treap_delete(n._right, v)\n        return n\n\n    # n._value == v\n    if n._count > 1:\n        n._count -= 1\n        return n\n\n    if n._left is None and n._right is None:\n        return None\n\n    if n._left is None:\n        n = treap_rotate_left(n)\n    elif n._right is None:\n        n = treap_rotate_right(n)\n    else:\n        # n._left is not None and n._right is not None\n        if n._left._priority < n._right._priority:\n            n = treap_rotate_right(n)\n        else:\n            n = treap_rotate_left(n)\n    return treap_delete(n, v)\n\n\ndef treap_size(n):\n    if n is None:\n        return 0\n    return n._count + treap_size(n._left) + treap_size(n._right)\n\n\ndef treap_str(n):\n    if n is None:\n        return \"\"\n    result = []\n    if n._left is not None:\n        result.append(treap_str(n._left))\n    result.append(\"%d:%d\" % (n._value, n._count))\n    if n._right is not None:\n        result.append(treap_str(n._right))\n    return ' '.join(result)\n\n\ndef treap_search(n, v):\n    # v \u672a\u6e80\u3067\u6700\u5927\u306e\u30ce\u30fc\u30c9\u3092\u691c\u7d22\u3059\u308b. v \u672a\u6e80\u306e\u30ce\u30fc\u30c9\u304c\u306a\u3051\u308c\u3070 None \u3092\u8fd4\u3059\n    if n is None:\n        return None\n    if n._value >= v:\n        if n._left is None:\n            return None\n        return treap_search(n._left, v)\n    # n._value < v\n    if n._right is None:\n        return n\n    r = treap_search(n._right, v)\n    if r is None:\n        return n\n    return r\n\n\nclass Treap:\n    _root = None\n    _size = 0\n\n    def insert(self, v):\n        self._root = treap_insert(self._root, v)\n        self._size += 1\n\n    def delete(self, v):\n        self._root = treap_delete(self._root, v)\n        self._size -= 1\n\n    def __len__(self):\n        return self._size\n\n    def __str__(self):\n        return treap_str(self._root)\n\n    def search(self, v):\n        return treap_search(self._root, v)\n\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nt = Treap()\nfor a in A:\n    n = t.search(a)\n    if n is not None:\n        t.delete(n._value)\n    t.insert(a)\nprint((len(t)))\n", "import heapq\nimport bisect\nN=int(input())\nA=[]\n\nfor i in range(N):\n  a=int(input())\n  A.append(a)\nh=[]\nc=0\nfor i in range(N-1,-1,-1):\n  p=bisect.bisect_right(h,A[i])\n  if p==len(h):\n    h.append(A[i])\n    c+=1\n  else:\n    h[p]=A[i]\nprint(c)", "from bisect import bisect_right, insort_right\nN = int(input())\nA = [int(input()) for _ in range(N)][::-1]\nres = [A[0]]\nfor a in A[1:]:\n    idx = bisect_right(res, a)\n    if idx == len(res):\n        res.append(a)\n    else:\n        if res[idx] == a:\n            insort_right(res, a)   \n        else:\n            res[idx] = a\nprint((len(res)))\n    \n"]
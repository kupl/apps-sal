["def main():\n    N = int(input())\n    S = list(map(int, input().split()))\n    INF = float('inf')\n\n    S.sort()\n\n    parents = [S[-1]]\n    S[-1] = INF\n\n    for _ in range(N):\n        checking = 2\n        parents.sort(reverse=True)\n        for i in parents[:]:\n            while True:\n                if S[-checking] < i:\n                    parents.append(S[-checking])\n                    S[-checking] = INF\n                    break\n                else:\n                    checking += 1\n                if checking == 2 ** N + 1:\n                    print('No')\n                    return\n    else:\n        print('Yes')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nN2 = 2**N\nS = list(map(int, input().split()))\nS.sort(reverse=True)\n\nslimes = [S[0]]\nS[0] = float('inf')\nnum = 1\nfor i in range(N):\n  slimes.sort()\n  n = num\n  idx = 0\n  while n and idx<=N2-1:\n    if S[idx] < slimes[n-1]:\n      slimes.append(S[idx])\n      S[idx] = float('inf')\n      idx += 1\n      n -= 1\n    else:\n      idx += 1\n  \n  if n:\n    print('No')\n    return\n  \n  num *= 2\n\nprint('Yes')", "N = int(input())\nS = list(map(int, input().split()))\n\nS.sort()\n\nparent = [S.pop()]\nrest = S\nfor _ in range(N):\n\tn_parent = []\n\tn_rest = []\n\n\tfor p in parent[::-1]:\n\t\twhile rest:\n\t\t\tx = rest.pop()\n\t\t\tif x < p:\n\t\t\t\tn_parent.append(x)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tn_rest.append(x)\n\tparent += n_parent\n\tparent.sort()\n\trest = rest + n_rest[::-1]\n\nif len(parent) == (2**N):\n\tprint(\"Yes\")\nelse:\n\tprint('No')\n\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    s = sorted(list(map(int, input().strip().split())), reverse=True)\n    check = [False] * (2**N)\n    now = []\n    now.append([s[0], 1])\n    check[0] = True\n    ok = True\n    for i in range(N):\n        next_ = []\n        tmp = 0\n        for j in range(len(now)):\n            hp, start = now[j]\n            start = max(start, tmp)\n            ok = False\n            for k in range(start, 2**N):\n                if s[k] < hp and not check[k]:\n                    tmp = k+1\n                    now[j][1] = k+1\n                    check[k] = True\n                    next_.append([s[k], k+1])\n                    ok = True\n                    break\n            if not ok:\n                break\n        now += next_\n        now = sorted(now, reverse=True)\n        if not ok:\n            break\n    \n    if ok:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n = int(input())\n    s = list(map(int, input().split(' ')))\n\n    s = sorted(s)[::-1]\n\n    slimes = [s[0]]\n    s = s[1:]\n\n    for i in range(n):\n        make_slimes = []\n        rest_slimes = []\n        make_idx = 0\n        for j in range(2 ** i):\n            for tmp_make_idx in range(make_idx, len(s)):\n                if slimes[j] > s[tmp_make_idx]:\n                    make_slimes.append(s[tmp_make_idx])\n                    break\n                else:\n                    rest_slimes.append(s[tmp_make_idx])\n            make_idx = tmp_make_idx + 1\n        rest_slimes += s[make_idx:]\n        if len(make_slimes) < 2 ** i:\n            print(\"No\")\n            return\n        slimes += make_slimes\n        s = rest_slimes\n        slimes = sorted(slimes)[::-1]\n        s = sorted(s)[::-1]\n    print(\"Yes\")\n\n\nmain()\n", "import sys\n\ndef main():\n    N,*S = map(int, open(0).read().split())\n    S = sorted(S)\n\n    g = [S.pop(-1)]\n\n    for gen in range(N):\n        tmp = []\n        for p in g[:2**gen]:\n            while S:\n                s = S.pop(-1)\n                if p > s:\n                    g.append(s)\n                    break\n                else:\n                    tmp.append(s)\n            else:\n                print('No')\n                return\n        S.extend(tmp[::-1])\n        g.sort(reverse=True)\n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nN2 = 1 << N\n\nS = sorted([int(x) for x in input().split()])\n\ns = []\ns.append(S[-1])\nS[-1] = -1\n\nflag = True\nfor i in range(N):\n    p = sorted([x for x in s])\n\n    Si = N2 - 1\n    while len(p) > 0 and Si >= 0:\n        if S[Si] == -1:\n            Si -= 1\n            continue\n\n        if S[Si] < p[-1]:\n            s.append(S[Si])\n            del p[-1]\n            S[Si] = -1\n        \n        Si -= 1\n    \n    if len(p) > 0:\n        flag = False\n\nprint('Yes' if flag else 'No')", "import sys\n\ndef main():\n    N,*S = map(int, open(0).read().split())\n    S = sorted(S)\n\n    g = [S.pop(-1)]\n\n    for _ in range(N):\n        tmp = []\n        lg = len(g)\n        for p in g[:lg]:\n            while S:\n                s = S.pop(-1)\n                if p > s:\n                    g.append(s)\n                    break\n                else:\n                    tmp.append(s)\n            else:\n                print('No')\n                return\n        S.extend(tmp[::-1])\n        g.sort(reverse=True)\n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    INF = float(\"inf\")\n\n    N, *S = list(map(int, open(0).read().split()))\n    M = len(S)\n\n    S.sort(reverse=True)\n\n    Q = [S[0]]\n    S[0] = INF\n    for _ in range(N):\n        Q.sort()\n        T = Q[:]\n\n        cur = 1\n        while Q:\n            p = Q.pop()\n            while S[cur] >= p:\n                cur += 1\n                if cur == M:\n                    print(\"No\")\n                    return\n            T.append(S[cur])\n            S[cur] = INF\n\n        Q = T\n\n    print(\"Yes\")\n\nmain()\n", "INF = float(\"inf\")\n\nN, *S = map(int, open(0).read().split())\nM = len(S)\n\nS.sort(reverse=True)\n\nQ = [S[0]]\nS[0] = INF\nfor _ in range(N):\n    Q.sort()\n    T = Q[:]\n\n    cur = 1\n    while Q:\n        p = Q.pop()\n        while S[cur] >= p:\n            cur += 1\n            if cur == M:\n                print(\"No\")\n                return\n        T.append(S[cur])\n        S[cur] = INF\n\n    Q = T\n\nprint(\"Yes\")", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\ndef main():\n    n = I()\n    a = sorted(LI())\n    q = [a[-1]]\n    a = a[:-1][::-1]\n    for i in range(n):\n        # print(i,q,a)\n        nq = []\n        qi = 0\n        na = []\n        for ai in range(len(a)):\n            c = a[ai]\n            if q[qi] > c:\n                nq.append(c)\n                qi += 1\n                if qi == len(q):\n                    na += a[ai+1:]\n                    break\n            else:\n                na.append(c)\n        if qi < len(q):\n            return 'No'\n        a = na\n        q = sorted(q + nq, reverse=True)\n\n    return 'Yes'\n\n\nprint(main())\n\n", "N = int(input())\nS = list(map(int, input().split()))\nINF = 10 ** 10\n\nS.sort()\n\nparents = [S[-1]]\nS[-1] = INF\nfrom_here = 1\n\nfor _ in range(N):\n    checking = from_here\n    first = True\n    parents.sort(reverse=True)\n    for i in parents[:]:\n        while True:\n            if S[-checking] < i and first:\n                parents.append(S[-checking])\n                S[-checking] = INF\n                from_here = checking + 1\n                break\n            elif S[-checking] < i:\n                parents.append(S[-checking])\n                S[-checking] = INF\n                break\n            else:\n                checking += 1\n                first = False\n            if checking == 2 ** N + 1:\n                print('No')\n                return\nelse:\n    print('Yes')", "N=int(input())\nS=list(map(int,input().split()))\nS.sort()\np=[S[-1]]\nr=S[:-1]\n\nfor i in range(N):\n    nr = []\n    for p_ in p[::-1]:\n        while r:\n            nr.append(r.pop())\n            if nr[-1]<p_:\n                p.append(nr.pop(-1))\n                break\n    p.sort()\n    r+=nr[::-1]\n\nprint(\"Yes\" if len(r)==0 else \"No\")", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = INT()\nA = LIST()\n\nA.sort(reverse=1)\ncur = [A[0]]\n# \u4f5c\u6210\u6e08\u3092-1\u3068\u3059\u308b\nA[0] = -1\n\nfor _ in range(N):\n    cur.sort(reverse=1)\n    nxt = cur[:]\n    j = 0\n    for i, a in enumerate(A):\n        if a == -1:\n            continue\n        if a < cur[j]:\n            # \u5927\u304d\u3044\u8981\u7d20\u304b\u3089\u9806\u306b\u3001\u307e\u3060\u4f5c\u3063\u3066\u3044\u306a\u3044\u5927\u304d\u3044\u8981\u7d20\u3092\u4f5c\u3063\u3066\u3044\u304f\n            nxt.append(a)\n            A[i] = -1\n            j += 1\n            # \u3053\u306e\u4e16\u4ee3\u306f\u4f5c\u308a\u7d42\u308f\u3063\u305f\n            if j == len(cur):\n                break\n    else:\n        # \u5b50\u8981\u7d20\u3092\u4f5c\u308c\u306a\u3044\u8981\u7d20\u304c\u3042\u3063\u305f\n        No()\n        return\n    cur = nxt[:]\nYes()\n", "N = int(input())\nA = sorted((int(x) for x in input().split()))\n \nparent = [A[-1]]\nrest = A[:-1]\nbl = True\nfor _ in range(N):\n    next_parent = []\n    next_rest = []\n    for p in parent[::-1]:\n        while rest:\n            x = rest.pop()\n            if x < p:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    rest = rest + next_rest[::-1]\n \nbl = len(parent) == (2**N)\nanswer = 'Yes' if bl else 'No'\nprint(answer)\n", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nS = sorted(map(int, input().split()), reverse=True)\nL = [S[0]]\nused = [False]*(1<<n)\nused[0] = True\nfor i in range(n):\n  L.sort(reverse=True)\n  idx = 0\n  for j, s in enumerate(S):\n    if used[j]:\n      continue\n    if L[idx] > s:\n      L.append(s)\n      used[j] = True\n      idx += 1\n      if idx == 1<<i:\n        break\n  else:\n    print(\"No\")\n    return\nprint(\"Yes\")", "def main():\n    N = int(input())\n    S = list(map(int, input().split()))\n    INF = float('inf')\n    n = 2 ** N + 1\n\n    S.sort()\n\n    parents = [S[-1]]\n    S[-1] = INF\n\n    for _ in range(N):\n        checking = 2\n        parents.sort()\n        tmp = parents[::-1]\n        for i in tmp:\n            while True:\n                if S[-checking] < i:\n                    parents.append(S[-checking])\n                    S[-checking] = INF\n                    break\n                else:\n                    checking += 1\n                if checking == n:\n                    print('No')\n                    return\n    else:\n        print('Yes')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    N = int(input())\n    S = list(map(int, input().split()))\n    INF = float('inf')\n\n    S.sort()\n\n    parents = [S[-1]]\n    S[-1] = INF\n\n    for _ in range(N):\n        checking = 2\n        parents.sort()\n        tmp = parents[::-1]\n        for i in tmp:\n            while True:\n                if S[-checking] < i:\n                    parents.append(S[-checking])\n                    S[-checking] = INF\n                    break\n                else:\n                    checking += 1\n                if checking == 2 ** N + 1:\n                    print('No')\n                    return\n    else:\n        print('Yes')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nM = 2**N\nA = list(map(int,input().split()))\nA.sort(reverse=True)\n\nar = [A[0]]\nA[0] = -1\nfor _ in range(N):\n    ar.sort(reverse=True)\n    br = []\n    i = 0\n    while i < M and len(br) < len(ar):\n        if A[i] >= 0:\n            if ar[len(br)] > A[i]:\n                br.append(A[i])\n                A[i] = -1\n        i += 1\n    if len(br) < len(ar):\n        print('No')\n        return\n    ar += br\nprint('Yes')", "import bisect\nimport heapq\nimport itertools\nimport math\nimport operator\nimport os\nimport re\nimport string\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom functools import lru_cache, reduce\nfrom operator import itemgetter, mul, add, xor\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n# \u89e3\u8aacAC\nN = int(sys.stdin.readline())\nS = list(map(int, sys.stdin.readline().split()))\n\n\ndef solve():\n    counts = Counter(S)\n    nums = list(sorted(list(counts.keys()), reverse=True))\n    if counts[nums[0]] > 1:\n        return False\n\n    # \u6728\u306e\u6df1\u3055\u3092\u3082\u3063\u3066\u6df1\u3044\u3084\u3064\u304b\u3089\u4f7f\u3063\u3066\u3044\u304f\n    trees = [-i for i in range(1, N + 1)]\n    heapq.heapify(trees)\n\n    for n in nums[1:]:\n        cnt = counts[n]\n        if cnt > len(trees):\n            return False\n        uses = []\n        for _ in range(cnt):\n            t = -heapq.heappop(trees)\n            uses.append(t)\n        # \u4f7f\u3063\u305f\u3089 t-1 \u500b\u306e\u6728\u306b\u5206\u89e3\u3059\u308b\n        for t in uses:\n            for i in range(1, t):\n                heapq.heappush(trees, -i)\n    return True\n\n\nif solve():\n    print('Yes')\nelse:\n    print('No')\n", "from collections import Counter\nN = int(input())\n*S, = map(int, input().split())\nC = Counter(S)\n\nmemo = [[-1]*(N+1) for i in range(N+1)]\ndef comb(n, k):\n    if memo[n][k] != -1:\n        return memo[n][k]\n    if k == 0 or n == k:\n        return 1\n    memo[n][k] = r = comb(n-1, k) + comb(n-1, k-1)\n    return r\n\n*CS, = C.items()\nCS.sort(reverse=1)\nS = [0]\nfor k, v in CS:\n    S.append(S[-1]+v)\nT = [0]\nfor i in range(N+1):\n    T.append(T[-1]+comb(N, i))\nok = 1\nif len(S) < len(T):\n    ok = 0\nelse:\n    ok = all(a <= b for a, b in zip(S, T)) and S[-2] >= 2**(N-1)\nprint(\"Yes\" if ok else \"No\")", "from collections import deque\n\ndef solve():\n    N = int(input())\n    Ss = list(map(int, input().split()))\n\n    Ss.sort(reverse=True)\n\n    Qs = [deque() for _ in range(N+1)]\n    Qs[0].append(10**10)\n\n    for S in Ss:\n        for day in range(N+1):\n            if not Qs[day]: continue\n            if Qs[day][0] > S:\n                Qs[day].popleft()\n                for d in range(day+1, N+1):\n                    Qs[d].append(S)\n                break\n        else:\n            return False\n\n    return True\n\n\nif solve():\n    print('Yes')\nelse:\n    print('No')\n", "# https://atcoder.jp/contests/abc140/submissions/7397810\n\nimport sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nn = ni()\na = na()\na.sort(reverse=True)\n\ndone = [False] * (1 << n)\nb = [a[0]]\ndone[0] = True\nfor d in range(n):  # d: d-th trial is passed.\n    j = 0  # j: skip num (already-generated or impossible-to-generate)\n    for i in range(1 << d):  # Try split of i-th slim.\n        while j < 1 << n and (done[j] or b[i] <= a[j]):\n            j += 1\n        if j == 1 << n:\n            print(\"No\")\n            return\n        b.append(a[j])  # b[i] > a[j]\n        done[j] = True\n    b.sort(reverse=True)\nprint(\"Yes\")\n", "N=int(input())\nS=list(map(int,input().split()))\nS.sort()\np = [S.pop(-1)]\nr = S\n\nfor i in range(N):\n    nr = []\n    for p_ in p[::-1]:\n        while r:\n            r_ = r.pop()\n            if r_ < p_:\n                p.append(r_)\n                break\n            nr.append(r_)\n    p.sort()\n    r+=nr[::-1]\n\nprint((\"Yes\" if len(r)==0 else \"No\"))\n", "#F\u554f\u984c\nN = int(input())\nS = list(map(int,input().split()))\nS.sort(reverse=True)\nvisit = [0]*(2**N)\nvisit[0] = 1\nused = [S[0]]\n\nflag = 0\nfor i in range(N):\n    add = used[::-1]\n    k = 0\n    for u in used:\n        while k < 2**N:\n            if visit[k] == 0 and S[k] < u:\n                visit[k] = 1\n                add.append(S[k])\n                break\n            k+=1\n        if k >= 2**N:\n            print(\"No\")\n            flag = 1\n            break\n    if flag == 1:\n        break\n    \n    used = add[::-1]\n    used.sort(reverse=True)\n    \nif flag == 0:\n    print(\"Yes\")", "#!/usr/bin/env python3\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nparent = [a[-1]]\nrest = a[:-1]\n\nfor _ in range(n):\n    next_parent = []\n    next_rest = []\n    for i in parent[::-1]:\n        while(rest):\n            x = rest.pop()\n            if x < i:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    next_rest.reverse()\n    rest += next_rest\n\nif len(parent) == 2**n:\n    print(\"Yes\")\nelse:\n    print(\"No\") \n", "from heapq import heappush, heappop\nfrom copy import deepcopy\n\n\ndef main():\n    n = int(input())\n    s = list(map(int, input().split()))\n\n    left = []\n    for e in s:\n        heappush(left, -e)\n    mx = heappop(left)\n\n    made = []\n    heappush(made, mx)\n\n    for _ in range(n):\n        made_prev = deepcopy(made)\n        tmp = []\n\n        while made_prev:\n            made_val = heappop(made_prev)\n            while left and left[0] <= made_val:\n                pp = heappop(left)\n                tmp.append(pp)\n\n            if not left:\n                print(\"No\")\n                return\n\n            left_val = heappop(left)\n            heappush(made, left_val)\n\n        for e in tmp:\n            heappush(left, e)\n\n    print(\"Yes\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nN2 = 2**N\nS = list(map(int, input().split()))\nS.sort(reverse=True)\n\nslimes = [S[0]]\nINF = S[0] + 1\nS[0] = INF\nnum = 1\nmin_idx = 1\nfor i in range(N):\n  slimes.sort()\n  n = num\n  idx = min_idx\n  is_continuous = True\n  while n and idx<=N2-1:\n    if S[idx] < slimes[n-1]:\n      slimes.append(S[idx])\n      S[idx] = INF\n      idx += 1\n      n -= 1\n      min_idx += is_continuous\n    else:\n      if S[idx] < INF:\n        is_continuous = False\n      idx += 1\n      min_idx += is_continuous\n  \n  if n:\n    print('No')\n    return\n  \n  num *= 2\n\nprint('Yes')", "from collections import Counter\nfrom heapq import heapify, heappush, heappop\n\ndef solve():\n    N = int(input())\n    Ss = list(map(int, input().split()))\n\n    cnt = Counter(Ss)\n\n    PQ = [-N]\n    for key in sorted(list(cnt.keys()), reverse=True):\n        num = cnt[key]\n        if len(PQ) < num:\n            return False\n        depths = []\n        for _ in range(num):\n            depths.append(-heappop(PQ))\n        for depth in depths:\n            for d in range(depth):\n                heappush(PQ, -d)\n\n    return True\n\nif solve():\n    print('Yes')\nelse:\n    print('No')\n\n", "N = int(input())\nS = list(map(int, input().split()))\nINF = float('inf')\n\nS.sort()\n\nparents = [S[-1]]\nS[-1] = INF\nchecked = 1\n\nfor _ in range(N):\n    checking = checked\n    first = True\n    parents.sort(reverse=True)\n    for i in parents[:]:\n        while True:\n            if S[-checking] < i and first:\n                parents.append(S[-checking])\n                S[-checking] = INF\n                checked = checking + 1\n                break\n            elif S[-checking] < i:\n                parents.append(S[-checking])\n                S[-checking] = INF\n                break\n            else:\n                checking += 1\n                first = False\n            if checking == 2 ** N + 1:\n                print('No')\n                return\nelse:\n    print('Yes')", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nfrom collections import deque\n\nN = int(input())\nA = sorted((int(x) for x in input().split()))\n\nparent = [A[-1]]\nrest = A[:-1]\nbl = True\nfor _ in range(N):\n    next_parent = []\n    next_rest = []\n    for p in parent[::-1]:\n        while rest:\n            x = rest.pop()\n            if x < p:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    rest = rest + next_rest[::-1]\n\nbl = len(parent) == (2**N)\nanswer = 'Yes' if bl else 'No'\nprint(answer)\n\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    s = sorted(list(map(int, input().strip().split())), reverse=True)\n    check = [False] * (2**N)\n    now = []\n    now.append([s[0], 1])\n    check[0] = True\n    ok = True\n    for i in range(N):\n        next_ = []\n        tmp = 0\n        for j in range(len(now)):\n            hp, start = now[j]\n            start = max(start, tmp)\n            ok = False\n            for k in range(start, 2**N):\n                if s[k] < hp and not check[k]:\n                    tmp = k+1\n                    now[j][1] = k+1\n                    check[k] = True\n                    next_.append([s[k], k+1])\n                    ok = True\n                    break\n            if not ok:\n                break\n        now += next_\n        now = sorted(now, reverse=True)\n        if not ok:\n            break\n    \n    if ok:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stderr, stdin\ninput = stdin.readline\nfrom collections import defaultdict\nfrom sys import stderr\ndef debug(var, name=\"hoge\"):\n    print(name +\":\" + str(type(var)) + \" = \" + repr(var), file=stderr)\n    return\ndef main():\n    N = int(input())\n    S = [int(a) for a in input().split()]\n    S = sorted(S)\n    exist = [S.pop()]\n    debug(S)\n    debug(exist)\n    for i in range(N):\n        next_exist = []\n        next_s = []\n        for p in exist[::-1]:\n            while S:\n                x = S.pop()\n                if x < p:\n                    next_exist.append(x)\n                    break\n                else:\n                    next_s.append(x)\n        exist += next_exist\n        exist.sort()\n        S += next_s[::-1]\n\n    if len(exist) == 2**N:\n        print(\"Yes\")\n        return\n    else:\n        print(\"No\")\n        return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nparent = [a[-1]]\nrest = a[:-1]\nfor _ in range(n):\n    next_parent = []\n    next_rest = []\n    for p in parent[::-1]:\n        while rest:\n            x = rest.pop()\n            if x < p:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    rest = rest + next_rest[::-1]\n\nif len(parent) == 2**n:\n    ans = 'Yes'\nelse:\n    ans = 'No'\nprint(ans)\n", "## \u4ed6\u306e\u65b9\u3068\u51e6\u7406\u5185\u5bb9\u304c\u307b\u307c\u540c\u3058\u306a\u306e\u306b\u4f55\u3067TLE\u306b\u306a\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\u4ed6\u306e\u65b9\u306e\u30b3\u30fc\u30c9\u3067\u30c6\u30b9\u30c8\nN = int(input())\na = list(map(int,input().split(' ')))\na.sort()\n    \n\nfathers = [a.pop()]\nfor _ in range(N):\n    sons = list()\n    b = list()\n    \n    for father in fathers:\n        while a:\n            x = a.pop()\n            if father > x:\n                sons.append(x)\n                break\n            else:\n                b.append(x)\n                \n    a = a + b[::-1]\n    fathers.extend(sons)\n    fathers.sort(reverse = True)\n    \n    \n    \nif len(fathers) == 2**N:\n    print('Yes')\nelse:\n    print('No')", "N = int(input())\nS = sorted([int(a) for a in input().split()])\nX = [1] + [0] * N\n\ndef popX(i0):\n    for i in range(i0, N+1):\n        if X[i]:\n            X[i] -= 1\n            return i\n    return N+1\ndef addX():\n    for l in L:\n        for i in range(l+1, N+1):\n            X[i] += 1\n\nwhile S:\n    a = S.pop()\n    c = 1\n    L = [popX(0)]\n    while S and S[-1] == a:\n        S.pop()\n        c += 1\n        L.append(popX(L[-1]))\n    if L[-1] > N:\n        print(\"No\")\n        break\n    addX()\nelse:\n    print(\"Yes\")", "import sys\n\ndef main():\n    N,*S = map(int, open(0).read().split())\n    S = sorted(S)\n\n    g = [S.pop(-1)]\n\n    for _ in range(N):\n        c = []\n        tmp = []\n        for p in g:\n            while S:\n                s = S.pop(-1)\n                if p > s:\n                    c.append(s)\n                    break\n                else:\n                    tmp.append(s)\n            else:\n                print('No')\n                return\n        S.extend(tmp[::-1])\n        g.extend(c)\n        g.sort(reverse=True)\n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\nN = int(input())\nS = list(map(int,input().split()))\nS.sort()\n\nused = [S.pop()]\nfor _ in range(N):\n \n    l, r = 0, len(used)\n    reuse = deque()\n    for i in range(len(S)):\n        v = S.pop()\n        if v < used[l]:\n            used.append(v)\n            l += 1\n        else:\n            reuse.appendleft(v)\n        if l == r:\n            break\n    else:\n        print('No')\n        break\n    S.extend(reuse)\n    used.sort(reverse=True)\nelse:\n    print('Yes')", "from heapq import heapify, heappush, heappop\n\ndef solve():\n    N = int(input())\n    Ss = list(map(int, input().split()))\n\n    Ss.sort(reverse=True)\n    pow2s = [2**i for i in range(N)]\n\n    PQs = [[-Ss[0]] for _ in range(N)]\n    nums = [0] * N\n    tm0 = 0\n    for S in Ss[1:]:\n        for tm in range(tm0, N):\n            if nums[tm] >= pow2s[tm]:\n                tm0 = tm\n            else:\n                if -PQs[tm][0] > S:\n                    heappop(PQs[tm])\n                    nums[tm] += 1\n                    for i in range(tm+1, N):\n                        heappush(PQs[i], -S)\n                    break\n        else:\n            return False\n\n    return True\n\nif solve():\n    print('Yes')\nelse:\n    print('No')\n", "import sys\ninput = sys.stdin.readline\n\nimport heapq as hp\nfrom collections import Counter\n\n\ndef main():\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    graph = [[] for _ in range(1<<N)]\n\n    for l in range(N):\n        for n in range(1<<l):\n            graph[n].append(n+(1<<l))\n\n    C = Counter(A)\n    Keys = sorted(C.keys(), reverse=True)\n    \n    q = [(-len(graph[0]), 0)]\n    for key in Keys:\n        num = C[key]\n        if num > len(q):\n            return False\n        use = []\n        for _ in range(num):\n            _, p = hp.heappop(q)\n            use.append(p)\n        for p in use:\n            for np in graph[p]:\n                hp.heappush(q, (-len(graph[np]), np))\n\n    return True\n\ndef __starting_point():\n    print(\"Yes\" if main() else \"No\")\n__starting_point()", "def solve_f(n, s_list):\n    res = 'Yes'\n    stage = 0\n    s_list_s = sorted(s_list)\n    length = len(s_list_s)\n    resolved = [0] * length\n    resolved[-1] = 1\n\n    for i in range(n):\n        parents = [s_list_s[k] for k in range(length) if resolved[k]]\n        for j in range(length - 1, -1, -1):\n            if parents[-1] > s_list_s[j] and resolved[j] == 0:\n                resolved[j] = 1\n                _ = parents.pop()\n            if len(parents) == 0:\n                break\n        if len(parents) > 0:\n            res = \"No\"\n            break\n\n    return res\n\n\ndef main():\n    n = int(input())\n    s_list = list(map(int, input().split()))\n    print((solve_f(n, s_list)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = [int(i) for i in input().split()]\na.sort()\n\nbig =  [a[-1]]\nrest = a[:-1]\n\n\nfor i in range(n):\n    not_yet = []\n    count = 0\n    for b in big:\n        if count==2**i:\n            break\n        while rest:\n            r = rest.pop()\n            if r < b:\n                big.append(r)\n                count += 1\n                break\n            not_yet.append(r)\n    big.sort(reverse=True)\n    rest += not_yet[::-1]\nprint(\"Yes\" if len(rest)==0 else \"No\")", "\nN = int(input())\na = list(map(int,input().split(' ')))\na.sort()\n \n \nfathers = [a.pop()]\nfor _ in range(N):\n    sons = list()\n    b = list()\n\n    for father in fathers:\n        while a:\n            x = a.pop()\n            if father > x:\n                sons.append(x)\n                break\n            else:\n                b.append(x)\n                \n    a = a + b[::-1]\n    fathers.extend(sons)\n    fathers.sort(reverse = True)\n    \n\n\nif len(fathers) == 2**N:\n    print('Yes')\nelse:\n    print('No')\n", "N = int(input())\nS = list(map(int, input().split()))\nINF = float('inf')\n\nS.sort()\n\nparents = [S[-1]]\nS[-1] = INF\n\nfor _ in range(N):\n    checking = 2\n    parents.sort(reverse=True)\n    for i in parents[:]:\n        while True:\n            if S[-checking] < i:\n                parents.append(S[-checking])\n                S[-checking] = INF\n                break\n            else:\n                checking += 1\n            if checking == 2 ** N + 1:\n                print('No')\n                return\nelse:\n    print('Yes')", "import math\ndef cmb(n,r):\n  return math.factorial(n)//(math.factorial(r)*math.factorial(n-r))\nn=int(input())\na=list(map(int,input().split()))\na.sort()\nls=[0]\ncnt=0\nfor i in range(1,2**n):\n  if a[i]>a[i-1]:\n    cnt+=1\n  ls.append(cnt)\nlmt = []\nfor i in range(n+1):\n  lmt.extend([i]*cmb(n,i))\nbias = ls[-1]-lmt[-1]\njdg = 0\nulmt = 0\nfor i in range(n):\n  jdg += ls.count(i)\n  ulmt += 2**(n-i-1)\n  if jdg > ulmt:\n    print(\"No\")\n    return\nfor x,l in zip(ls,lmt):\n  if x-l > bias:\n    print(\"No\")\n    break\nelse:\n  print(\"Yes\")", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = INT()\nA = LIST()\n\nA.sort(reverse=1)\ncur = [A[0]]\nnxt = cur[:]\n# \u4f5c\u6210\u6e08\u3092-1\u3068\u3059\u308b\nA[0] = -1\n\nfor _ in range(N):\n    j = 0\n    for i, a in enumerate(A):\n        if a == -1:\n            continue\n        if a < cur[j]:\n            # \u5927\u304d\u3044\u8981\u7d20\u304b\u3089\u9806\u306b\u3001\u307e\u3060\u4f5c\u3063\u3066\u3044\u306a\u3044\u5927\u304d\u3044\u8981\u7d20\u3092\u4f5c\u3063\u3066\u3044\u304f\n            nxt.append(a)\n            A[i] = -1\n            j += 1\n            # \u3053\u306e\u4e16\u4ee3\u306f\u4f5c\u308a\u7d42\u308f\u3063\u305f\n            if j == len(cur):\n                break\n    else:\n        # \u5b50\u8981\u7d20\u3092\u4f5c\u308c\u306a\u3044\u8981\u7d20\u304c\u3042\u3063\u305f\n        No()\n        return\n    nxt.sort(reverse=1)\n    cur = nxt[:]\nYes()\n", "N = int(input())\nA = sorted((int(x) for x in input().split()))\n \nparent = [A[-1]]\nrest = A[:-1]\nbl = True\nfor _ in range(N):\n    next_parent = []\n    next_rest = []\n    for p in parent[::-1]:\n        while rest:\n            x = rest.pop()\n            if x < p:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    rest = rest + next_rest[::-1]\n \nbl = len(parent) == (2**N)\nanswer = 'Yes' if bl else 'No'\nprint(answer)\n", "def main():\n    inf = 10 ** 9 + 5\n    n = int(input())\n    n2 = 2 ** n\n    s = list(map(int, input().split()))\n    s.sort(reverse=True)\n    # print(s)\n    pp = [s[0]]\n    s[0] = inf\n    for _ in range(n):\n        pp.sort()\n        i = 1\n        np = pp[:]\n        while pp:\n            p = pp.pop()\n            while 1:\n                if s[i] < p:\n                    np.append(s[i])\n                    s[i] = inf\n                    break\n                else:\n                    i += 1\n                if i == n2:\n                    print(\"No\")\n                    return\n        pp = np\n    print(\"Yes\")\n\nmain()\n", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    visited = [False]*(2**n)\n    visited[0] = 0\n    now = [a[0]]\n    for i in range(n):\n        new = []\n        now2 = 0\n        for j, i in enumerate(a):\n            if visited[j]:\n                continue\n            if now[now2] > i:\n                now2 += 1\n                new += [i]\n                visited[j] = True\n                if now2 == len(now):\n                    now += new\n                    now.sort(reverse=True)\n                    break\n        else:\n            print(\"No\")\n            return\n\n    print(\"Yes\")\n\n\nmain()", "def main():\n    N = int(input())\n    S = list(map(int, input().split()))\n    INF = float('inf')\n    n = 2 ** N + 1\n\n    S.sort()\n\n    parents = [S[-1]]\n    S[-1] = INF\n\n    for _ in range(N):\n        checking = 2\n        parents.sort(reverse=True)\n        for i in parents[:]:\n            while True:\n                if S[-checking] < i:\n                    parents.append(S[-checking])\n                    S[-checking] = INF\n                    break\n                else:\n                    checking += 1\n                if checking == n:\n                    print('No')\n                    return\n    else:\n        print('Yes')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nS = list(map(int, input().split()))\nS.sort(reverse=True)\nClosed = [False] * (1<<N)\nClosed[0] = True\nfor j in range(N):\n    num = 1<<j\n    cnt_all = 0\n    cnt = 0\n    cnt_ = 0\n    s_old = -1\n    for i, s in enumerate(S):\n        if s_old!=s:\n            cnt += cnt_\n            cnt_ = 0\n        c = Closed[i]\n        if c:\n            cnt_ += 1\n        elif cnt > 0:\n            Closed[i] = True\n            cnt -= 1\n            cnt_all += 1\n            if cnt_all == num:\n                break\n        s_old = s\n    else:\n        print(\"No\")\n        return\nprint(\"Yes\")\n", "n = int(input())\ns = list(map(int, input().split()))\nrest = sorted(s)\nparent = [rest.pop()]\n\nfor _ in range(n):\n    next_parent = []\n    next_rest = []\n    for i in parent[::-1]:\n        while rest:\n            x = rest.pop()\n            if x < i:\n                next_parent.append(x)\n                break\n            else:\n                next_rest.append(x)\n                continue\n    parent += next_parent\n    parent.sort()\n    rest += next_rest\n    rest.sort()\n\nif len(parent) == 2**n:\n    print('Yes')\nelse:\n    print('No')\n", "\ndef f_f():\n    n, *s = list(map(int, open(0).read().split()))\n    s.sort()\n    ps, next_ps, cs = [s.pop()], [], []\n    for _ in range(n):\n        for p in ps:\n            while s:\n                c = s.pop()\n                if p>c:\n                    next_ps.append(c)\n                    break\n                else:\n                    cs.append(c)\n        s, ps, next_ps, cs = s+cs[::-1], sorted(ps+next_ps, reverse=True), [], []\n\n    print((\"No\" if s else \"Yes\"))\n\ndef __starting_point():\n    f_f()\n\n__starting_point()", "from collections import Counter\nfrom heapq import heappop, heappush\n\n\ndef solve(n, sss):\n    ccc = Counter(sss)\n    keys = sorted(list(ccc.keys()), reverse=True)\n    if ccc[keys[0]] != 1:\n        return False\n\n    q = [(1, keys[0])]\n    for k in keys[1:]:\n        nq = []\n        for _ in range(ccc[k]):\n            try:\n                r, s = heappop(q)\n            except IndexError:\n                return False\n            if r < n:\n                nq.append((r + 1, k))\n                heappush(q, (r + 1, s))\n        for item in nq:\n            heappush(q, item)\n\n    return True\n\n\nn = int(input())\nsss = list(map(int, input().split()))\nprint(('Yes' if solve(n, sss) else 'No'))\n", "from collections import Counter\nn = int(input())\na = [int(item) for item in input().split()]\ncnt = Counter(a)\n\nkey_num = len(cnt.keys())\nrank = [0] * key_num \nkeys = list(cnt.keys())\nkeys.sort(reverse=True)\nfor i, key in enumerate(keys):\n    rank[i] = cnt[key]\ncur = [0] * key_num \ncur[0] = 1\nfor i in range(n):\n    tmp = cur[:]\n    free = 0\n    for j in range(key_num):\n        if rank[j] > cur[j] and free > 0:\n            if cur[j] + free > rank[j]:\n                free -= rank[j] - cur[j]\n                cur[j] = rank[j]\n            else:\n                cur[j] += free\n                free = 0\n        free += tmp[j] \nif sum(cur) == 2**n:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "N = int(input())\nS = sorted([int(a) for a in input().split()])\nX = [1] + [0] * N\n\ndef popX(i0):\n    for i in range(i0, N+1):\n        if X[i]:\n            X[i] -= 1\n            return i\n    return N+1\ndef addX():\n    for l in L:\n        for i in range(l+1, N+1):\n            X[i] += 1\n\nwhile S:\n    a = S.pop()\n    L = [popX(0)]\n    while S and S[-1] == a:\n        S.pop()\n        L.append(popX(L[-1]))\n    if L[-1] > N:\n        print(\"No\")\n        break\n    addX()\nelse:\n    print(\"Yes\")", "N = int(input())\nN2 = 2**N\nS = list(map(int, input().split()))\nS.sort(reverse=True)\n\nslimes = [S[0]]\nS[0] = float('inf')\nnum = 1\nmin_idx = 1\nfor i in range(N):\n  slimes.sort()\n  n = num\n  idx = min_idx\n  is_continuous = True\n  while n and idx<=N2-1:\n    if S[idx] < slimes[n-1]:\n      slimes.append(S[idx])\n      S[idx] = float('inf')\n      idx += 1\n      n -= 1\n      min_idx += is_continuous\n    else:\n      if S[idx] < float('inf'):\n        is_continuous = False\n      idx += 1\n      min_idx += is_continuous\n  \n  if n:\n    print('No')\n    return\n  \n  num *= 2\n\nprint('Yes')", "N=int(input())\nS=list(map(int,input().split()))\nS.sort()\np=S[-1:]\nr=S[:-1]\nfor i in range(N):\n    nr=[]\n    for p_ in p[::-1]:\n        while r:\n            r_=r.pop()\n            if r_<p_:\n                p.append(r_)\n                break\n            nr.append(r_)\n    p.sort()\n    r+=nr[::-1]\nprint(\"Yes\" if len(r)==0 else \"No\")"]
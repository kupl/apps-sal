["import math\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\nN = int(input())\nA = LI()\nAmin = min(A)\nans = Amin\nfor i in A:\n    if Amin == i:\n        continue\n    Amin = min(Amin, math.gcd(Amin, i))\nans = min(ans, math.gcd(Amin, ans))\n\nprint(ans)\n", "import math\nN=int(input())\nL=list(map(int,input().split()))\nans=L[0]\nfor i in range(N-1):\n  ans=math.gcd(ans,L[i+1])\nprint(ans)", "from math import gcd\n\nN = int(input())\na = list(map(int, input().split()))\n\nans = a[0]\nfor i in range(1, N):\n    ans = gcd(ans, a[i])\nprint(ans)\n", "import sys\nimport math\nimport itertools\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\nfrom operator import itemgetter, attrgetter\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\ndef TL(mylist): return [list(x) for x in zip(*mylist)] #\u884c\u3068\u5217\u5165\u308c\u66ff\u3048\ndef RtoL(mylist): return [list(reversed(x)) for x in mylist] #\u5de6\u53f3\u53cd\u8ee2\ndef HtoL(mylist): return [x for x in list(reversed(mylist))] #\u4e0a\u4e0b\u53cd\u8ee2\ndef convert_2d(l, colstart, colend, rawstart, rawend):return [i[rawstart:rawend] for i in l[colstart:colend]] #2\u6b21\u5143\u884c\u5217\u304b\u3089\u4e00\u90e8\u3092\u63a1\u53d6\ndef get_unique_list(seq):\n    seen = []\n    return [x for x in seq if x not in seen and not seen.append(x)]\n\ndef main():\n    N = I()\n    L = LI()\n    ans = L[0]\n    for i in range(N):\n        temp = L[i]\n        ans = math.gcd(ans, temp)\n    print(ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom math import gcd, factorial, ceil, floor, sqrt\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations, combinations, product, accumulate\nfrom collections import defaultdict, deque, Counter\nfrom functools import lru_cache\nsys.setrecursionlimit(10**8)\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(map(int, input().split()))\n\nN = ii()\na = li()\n\ncur = 0\nfor A in a:\n    cur = gcd(cur, A)\nprint(cur)", "import functools\nimport math\nn = int(input())\na = list(map(int, input().split()))\na = list(set(a))\nans = 0\nx = functools.reduce(math.gcd, a)\nprint(x)\n", "import math\nN=int(input())\nA=[int(x) for x in input().split()]\nans=A[0]\nfor i in range(1,N):\n    ans=math.gcd(ans,A[i])\nprint(ans)", "N=int(input())\nA=list(map(int,input().split()))\n\ndef gcd(a,b):\n    while b:\n        a,b=b,a%b\n    return a\n\nans=A[0]\nfor i in range(1,N):\n    ans=gcd(ans,A[i])\nprint(ans)", "#ARC105 B\n\nfrom math import gcd\n\n\nN = int(input())\nA = list(map(int,input().split()))\n\nans = 0\nfor i in range(N):\n    ans = gcd(ans, A[i])\n    \nprint(ans)\n\n", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n    \nN = int(input())\nA = list(map(int, input().split()))\n\nanswer = A[0]\nfor a in A:\n    answer = gcd(answer, a)\n\nprint(answer)", "N = int(input())\narr = list(map(int,input().split()))\n\narr = sorted(set(arr))\nwhile True:\n    # print(arr)\n    minValue = arr[0]\n    arr = [arr[i]%arr[0] for i in range(1,len(arr)) if arr[i]%arr[0] != 0]\n    arr.append(minValue)\n    arr = sorted(set(arr))\n    if len(arr) == 1:\n        print(arr[0])\n        return", "n = int(input())\nfrom math import gcd\nAs = list(map(int, input().split()))\nans = As[0]\nfor a in As:\n    ans = gcd(ans,a)\nprint(ans)", "def gcd(x,y):\n    while y>0:\n        x,y = y,x%y\n    return x\nN = int(input())\nA = list(map(int,input().split()))\na = A[0]\nfor i in range(1,N):\n    b = A[i]\n    a = gcd(a,b)\nprint(a)", "#https://atcoder.jp/contests/arc105/tasks/arc105_b\n\nfrom functools import reduce\nimport math\na= int(input())\nb= list(map(int, input().split()))\n\nGCD= b[0]\nfor c in b:\n    GCD = math.gcd(c, GCD)\n\nprint(GCD)", "from functools import reduce\nfrom math import gcd\n\n# \u6700\u5927\u516c\u7d04\u6570\ndef gcd_list(num_list: list) -> int:\n    return reduce(gcd, num_list)\n\n# \u6700\u5c0f\u516c\u500d\u6570\ndef lcm_base(x: int, y: int) -> int:\n    return (x * y) // gcd(x, y)\ndef lcm_list(num_list: list):\n    return reduce(lcm_base, num_list, 1)\n\n\nn = int(input())\nal = list(map(int, input().split()))\nprint(gcd_list(al))", "import math\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nans = a[0]\nfor i in range(n-1):\n    ans = math.gcd(ans, a[i+1])\n\nprint(ans)\n", "import math\nn=int(input())\nans,*A=map(int,input().split())\nfor a in A:\n    ans=math.gcd(a,ans)\nprint(ans)", "import math\nfrom functools import reduce\nN = int(input())\nA = list(map(int, input().split()))\nA = list(set(A))\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\nprint(gcd_list(A))", "import math\nfrom functools import reduce\nn = int(input())\na = list(map(int, input().split()))\nprint((reduce(math.gcd, a)))\n", "import math\n\nn = int(input())\nA = list(set(list(map(int,input().split()))))\n\nans = A[0]\n\nfor a in A:\n  ans = math.gcd(ans,a)\n  \nprint(ans)", "import math\nn = int(input())\na = list(map(int, input().split()))\nfor i in range(n-1):\n    a[i+1] = math.gcd(a[i], a[i+1])\nprint(a[-1])", "#template\nimport sys\nsys.setrecursionlimit(10**9)\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nread_int = lambda: int(readline())\nread_ints = lambda: map(int,readline().split())\nread_ints_list = lambda: list(map(int,readline().split()))\nread_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))\nread_strs_list = lambda: list(map(str,readline().rstrip().split()))\nread_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))\n\ndef read_allints_grid(w):\n    grid = map(int,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\ndef read_allstrs_grid(w):\n    grid = map(str,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\n#import\n# from copy import deepcopy\n# from decimal import Decimal\n# from math import ceil,floor\n# from collections import deque,Counter\n# from heapq import heapify,heappop,heappush\n# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement\n# from bisect import bisect_left,bisect_right\n\n#solution\ndef sol():\n    return None\ndef GCD(a:int,b:int)->int:\n    '''\n    \u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\u306b\u3088\u308b\u6700\u5927\u516c\u7d04\u6570/O(log min(a,b))\n    '''\n    if b==0:\n        return a\n    else:\n        return GCD(b,a%b)\n\ndef GCD_multi(vec:list)->int:\n    '''\n    \u6570\u5217\u306e\u8981\u7d20\u306e\u6700\u5927\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b/O(N log(a'))\n    '''\n    l = vec[0]\n    for i in range(len(vec)-1):\n        l = GCD(l,vec[i+1])\n    return l\n\ndef main():\n    #input data\n    n = read_int()\n    A = read_ints_list()\n\n    #solve\n    print(GCD_multi(A))\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\na=[int(x) for x in input().split()]\nfrom functools import reduce\nimport math\ndef my_gcd(*numbers):\n    return reduce(math.gcd, numbers)\nprint(my_gcd(*a))", "n=int(input())\na=set(list(map(int,input().split())))\n\ndef gcd(a,b):\n    while b!=0:\n        a,b=b,a%b\n    return a\n\nans=min(a)\nfor i in a:\n    ans=gcd(i,ans)\n\nprint(ans)", "import sys\nimport math\n\n\ndef input(): return sys.stdin.readline().strip()\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef S(): return input()\ndef LS(): return input().split()\n\n\nINF = float('inf')\n\n\nn = I()\na = LI()\nans = 0\nfor ai in a:\n    ans = math.gcd(ans, ai)\nprint(ans)\n", "def gcd(x,y):\n  while x:\n    x,y=y%x,x\n  return y\ninput()\n*a,=map(int,input().split())\nwhile len(a)>1:\n  x=a.pop()\n  y=a.pop()\n  a.append(gcd(x,y))\nprint(a.pop())", "from math import gcd\n\nN = int(input())\na = list(map(int,input().split()))\ncount = 0\nfor A in a:\n    count = gcd(count, A)\n    \n\nprint(count)\n", "import math\n\nN = int(input())\nA = list(map(int, input().split()))\n\nans = A[0]\nfor i in range(1, N):\n    ans = math.gcd(ans, A[i])\n\nprint(ans)", "import math\nfrom functools import reduce\ndef gcd(*numbers):\n  return reduce(math.gcd, numbers)\n\nn = int(input())\naa = list(map(int, input().split()))\nprint((gcd(*aa)))\n\n\n  \n \n\n\n\n\n\n\n\n", "import math\nfrom functools import reduce\nN=int(input())\na=list(map(int, input().split()))\nb=[0]*N\n\nmina=min(a)\n\n#print(mina,a)\n\nfor i in range(N):\n    if a[i]!=mina:\n        b[i]=a[i]%mina+mina\n    else:\n        b[i]=mina\n#print(b)\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\nprint(gcd(*b))", "from math import gcd\n\nn = int(input())\nA = list(map(int, input().split()))\n\nA = list(set(A))\nn = len(A)\nans = A[0]\nfor i in range(n):\n    ans = gcd(ans, A[i])\nprint(ans)", "def resolve():\n#====input code===\n    n = int(input())\n    a = list(map(int,input().split()))\n    while True:\n        min_num = min(a)\n        a = list(map(lambda x: min_num if x%min_num==0 else x%min_num, a))\n        if all(i==min_num for i in a):\n            print(min_num)\n            break\n#================\nresolve()", "import math\nN = int(input())\nA_lst = list(map(int, input().split()))\nA_lst.sort()\nans = A_lst[0]\nfor i in range(1, N):\n    ans = math.gcd(ans, A_lst[i])\nprint(ans)", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nfrom math import gcd\nfrom functools import reduce\ndef resolve():\n    input()\n    print(reduce(gcd, map(int, input().split())))\nresolve()", "from sys  import stdin,stdout\nfrom collections  import *\nfrom math import ceil, floor , log, gcd\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n \nmod=1000000007\nINF=float('inf')\n\ndef solve():\n    n=inp()\n    l=li()\n    g=l[0]\n    for i in range(1,n):\n        g=gcd(g,l[i])\n    pr(g)\n        \n\nfor _ in range(1):\n    solve()\n", "#a,b\u306e\u6700\u5927\u516c\u7d04\u6570\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nans = a[0]\nfor i in range(n):\n    ans = gcd(ans, a[i])\nprint(ans)", "import functools\nimport math\nn = int(input())\na = list(map(int, input().split()))\na = list(set(a))\nans = 0\nx = functools.reduce(math.gcd, a)\nprint(x)\n", "import sys,math,collections,itertools,functools\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN=int(input())\na=list(map(int,input().split()))\n\nans = functools.reduce(math.gcd,a)\nprint(ans)\n", "from math import gcd\nfrom functools import reduce\ninput()\na=list(map(int,input().split()))\nsum=reduce(lambda x,y:gcd(x,y),a)\nprint(sum)", "N=int(input())\na=list(map(int, input().split()))\n\nwhile 1:\n    temp=[]\n    a.sort()\n    k=a[0]\n    f=0\n    for i in range(1,len(a)):\n        if a[i]%k!=0:\n            f=1\n            temp.append(a[i]%k)\n    if temp==[] or f==0:\n        print(k)\n        return\n    a=[k]+temp", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nans = a[0]\nfor i in range(n):\n    ans = gcd(ans, a[i])\nprint(ans)", "import math\nfrom functools import reduce\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\nN = int(input())\nA = list(map(int,input().split()))\n\nprint(gcd_list(A))", "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\nres = a[0]\nfor i in range(1, len(a)):\n    res = gcd(res, a[i])\nprint(res)", "import math\n\nN = int(input())\nl = list(map(int, input().split()))\n\ngcd = l[0]\nfor i in range(1, N):\n  gcd = math.gcd(gcd, l[i])\n\nprint(gcd)\n", "import bisect\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nimport time\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor\nfrom types import FunctionType\nfrom typing import List\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\n\ndef main():\n    N = int(input())\n    A = lmi()\n    A.sort()\n    ans = reduce(math.gcd, A)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "def gcd(a, b):\n    while b != 0:\n        a, b = b, a%b\n    return a\n\nn = int(input())\na = list(set([int(i) for i in input().split()]))\nres = a[0]\nfor i in range(1, len(a)):\n    res = gcd(res, a[i])\nprint(res)", "import math\nfrom functools import reduce\nN=int(input())\nA = list(map(int, input().split()))\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\nprint(gcd_list(A))", "from functools import reduce\nfrom math import gcd\nfrom typing import List\n\n\ndef solve(n: int, a: List[int]) -> int:\n    return reduce(gcd, a)\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    print((solve(n, a)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport collections\nimport itertools\nimport copy\nfrom collections import deque\nimport bisect\n\ndef gcd(a, b):\n    \"\"\"Euclidean Algorithm\"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef resolve():\n    N=int(input())\n    A=list(map(int,input().split()))\n    \n    while(True):\n        Min=min(A)\n        Max=max(A)\n        for i in range(N):\n            A[i]=gcd(A[i],Min)\n        if(Min==Max):\n            break\n\n    print(Min)\nresolve()\n", "# # Make IO faster\n# import sys\n# input = sys.stdin.readline\n\n# # get single (or) multiple str\n# X = input()\n\n# # get single int\n# N = int(input())\n# # get multiple int (e.g., 2)\n# X, Y = map(int, input().split())\n# # get multiple int (e.g., 2) for N lines\n# XY = [list(map(int, input().split())) for _ in range(N)]\n\n# from IPython import embed; embed(); return;\n\n# \u5168\u90e8\u5165\u308a\nimport sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, fabs, gcd\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort_left\n# from fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nimport numpy as np\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\na = list(MAP())\nans = a[0]\nfor i in range(len(a) - 1):\n    ans = gcd(ans, a[i + 1])\nprint(ans)\n", "import numpy as np\ninput()\nprint(np.gcd.reduce(np.array(input().split(), dtype=np.int32)))", "import sys\ninput = sys.stdin.readline\nn = int(input())\nL = sorted(set(map(int, input().split())))\n\nwhile True:\n    num = L[0]\n    L = sorted(set(L[i]%L[0] for i in range(1,len(L)) if L[i]%L[0] != 0))\n    L.append(num)\n    L.sort()\n    if len(L) <= 1:\n        print((L[0]))\n        return\n", "n,*a=map(int,open(0).read().split())\nb=min(a)\nwhile sum(i%b for i in a):\n    a=[i-i//b*b for i in a if i-i//b*b>0]\n    b=min(a)\nprint(b)", "import math\ninput()\na=0\nfor i in map(int,input().split()):a=math.gcd(a,i)\nprint(a)", "import math\n\nN = int(input())\nl = list(map(int, input().split()))\n\ngcd = l[0]\nfor i in range(1, N):\n  gcd = math.gcd(gcd, l[i])\n\nprint(gcd)", "import heapq\nimport math\nN=int(input())\nCL=list(map(int, input().split()))\nheapq.heapify(CL)\nmin=heapq.heappop(CL)\npre=min\nGCD=min\nif N!=1:\n  for i in range(N-1):\n    now=heapq.heappop(CL)\n    GCD=math.gcd(GCD, now-pre)\n    pre=now\nprint(GCD)\n", "# MAX-=min\n\n# 0 <= x <= y \u3067\uff0cgcd(x, y) = gcd(x, y - x) \u304c\u6210\u7acb\n# gcd(a) \u3092\u6c42\u3081\u308c\u3070\u3088\u3044\n\nimport math\n\nN = int(input())\na = list(map(int, input().split()))\n\ngcd_a = a[0]\nfor i in range(1, N):\n    gcd_a = math.gcd(gcd_a, a[i])\n\nprint(gcd_a)\n", "def GCD(a,b):\n    if (b == 0):\n        return a;\n    else:\n        return GCD(b, a % b);\n\nn = int(input())\na = list(map(int,input().split()))\ncnt = 0\nfor i in range(n):\n    cnt = GCD(cnt,a[i])\nprint(cnt)", "#coding: utf-8\nfrom collections import deque\nfrom bisect import bisect_right\nfrom math import gcd\nN = int(input())\nA = list(set(map(int, input().split())))\nA.sort()\nans = A[0]\nfor a in A[1:]:\n    ans = gcd(ans, a)\nprint(ans)\n", "from math import gcd\n\nN = int(input())\narr = list(map(int,input().split()))\n\nans = arr[0]\nfor i in range(1,N):\n  ans = gcd(ans,arr[i])\nprint(ans)\n\n# gcd(0,5)=5 \u3088\u308a ans = 0 \u3067 range(N) \u3068\u3057\u3066\u3082OK\n# \u305f\u3060gcd\u306f\u6700\u5927\u516c\u7d04\u6570\u306a\u306e\u3067gcd(0,5)=5\u306f\u76f4\u611f\u306b\u53cd\u3059\u308b\n", "from functools import reduce\nimport math\n_=input()\na=sorted(set(map(int,input().split())))\nprint(reduce(math.gcd,a))", "import fractions\nN = int(input())\nA = list(map(int, input().split()))\n\nans = A[0]\nfor i in range(1, N):\n    ans = fractions.gcd(ans, A[i])\nprint(ans)", "n = int(input())\nl = [ int(x) for x in input().split() ]\n\nwhile True:\n    l = list(set(l))\n    if len(l) == 1:\n        print((l[0]))\n        return\n\n    mn = min(l)\n    for i, e in enumerate(l):\n        if e == mn:\n            pass\n        else:\n            if mn == 1:\n                l[i] = 1\n            else:\n                if e % mn == 0:\n                    l[i] = mn\n                else:\n                    l[i] = e % mn\n", "from heapq import heappush, heappop, heapify\nclass RemovableHeap:\n    def __init__(self, is_max_heap: bool=False, data :list=None):\n        self.data = [] if data is None else data\n        self.erased = []\n        self.sign = -1 if is_max_heap else 1\n    \n    def normalize(self):\n        while self.erased and self.data[0] == self.erased[0]:\n            heappop(self.data)\n            heappop(self.erased)\n    \n    def pop(self):\n        ret = self.sign * heappop(self.data)\n        self.normalize()\n        return ret\n\n    def push(self, x):\n        heappush(self.data, self.sign * x)\n        self.normalize()\n    \n    def remove(self, x):\n        heappush(self.erased, self.sign * x)\n        self.normalize()\n    \n    def __len__(self):\n        return max(len(self.data) - len(self.erased), 0)\n    \n    def get(self):\n        return self.sign * self.data[0]\ndef main():\n    N = int(input())\n    A = set(map(int, input().split()))\n\n    max_que = RemovableHeap(is_max_heap=True)\n    min_que = RemovableHeap()\n    for a in A:\n        max_que.push(a)\n        min_que.push(a)\n\n    while min_que.get() != max_que.get():\n        min_A = min_que.get()\n        while min_A < max_que.get():\n            X = max_que.pop()\n            min_que.remove(X)\n            max_que.push((X - 1) % min_A + 1)\n            min_que.push((X - 1) % min_A + 1)\n        max_que.remove(min_que.pop())\n\n\n    print((max_que.get()))\nmain()\n\n", "from functools import reduce\nN = int(input())\nL = list(map(int,input().split()))\n\ndef gcd(A,B):\n    if A<B:\n        A,B=B,A\n\n    while B:\n        A,B = B,A%B\n    return A\n\nprint((reduce(gcd,L)))\n", "import math\nN = int(input())\nl = list(map(int,input().split()))\ng = 0\nfor i in range(N):\n    g = math.gcd(g,l[i])\nprint(g)", "n=int(input())\n\ni = list(map(int, input().split())) \nans=i[0]\ndef gcd(a,b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b,a%b)\nfor k in range(1,n):\n    ans=gcd(ans,i[k])\nprint(ans)    ", "from math import gcd\nn=int(input())\na=[int(i) for i in input().split()]\nans = a[0]\nfor i in a:\n  ans = gcd(ans,i)\nprint(ans)", "import math\nn  = int(input())\nx = list(map(int,input().split()))\na = 0\nfor i in range(n):\n  a = math.gcd(a,x[i])\nprint(a)", "from math import gcd\n\nn=int(input())\nl=list(map(int,input().split()))\n\nGCD=l[0]\nfor i in range(1,n):\n    GCD=gcd(GCD,l[i])\n\nprint(GCD)", "def gcd(x: int, y: int) -> int:\n    if x < y:\n        x, y = y, x\n    while x % y > 0:\n        x, y = y, x % y\n    return y\n    \n\nN = int(input())\nA = list(map(int, input().split()))\nr = A[0]\n\nfor a in A[1:]:\n    r = gcd(r, a)\nprint(r)\n", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN = I()\nA = readInts()\ng = 0\nfor i in range(N):\n    g = gcd(g, A[i])\nprint(g)\n", "import math\n\nN = int(input())\nAi = list(set(map(int, input().split(\" \"))))\n\ng = Ai[0]\nfor i in Ai[1:]:\n    g = math.gcd(g,i)\nprint(g)", "n = int(input())\nl = list(map(int,input().split()))\n\nimport math\nfrom functools import reduce\n\ndef gcd_list(numbers:list) -> int:\n    return reduce(math.gcd, numbers)\n\nprint((gcd_list(l)))\n\n", "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(10**6)\n\ndef inp():\n    return int(input())\ndef inps():\n    return input().rstrip()\ndef inpl():\n    return list(map(int, input().split()))\ndef inpls():\n    return list(map(str, input().split()))\n\n# import decimal\n# from decimal import Decimal\n# decimal.getcontext().prec = 10\n\n# from heapq import heappush, heappop, heapify\n# import math\nfrom math import gcd, floor, ceil, factorial\nimport itertools as it\nfrom collections import deque, defaultdict\nfrom collections import Counter\n\ndef lcd(a, b):\n    return a * b // gcd(a, b)\n\ndef chmin(dp, i, x):\n    if x < dp[i]: dp[i] = x; return True\n    return False\n\ndef chmax(dp, i, x): \n    if x > dp[i]: dp[i] = x; return True\n    return False\n\n# ---------------------------------------\n\nN = inp()\na = inpl()\n\nfor i in range(len(a)):\n    if i == 0:\n        ans = a[i]\n    else:\n        ans = gcd(ans, a[i])\nprint(ans)\n", "#region Header\n#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nfrom queue import PriorityQueue\nimport bisect\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\nsys.setrecursionlimit(1000000)\n#endregion\n\n# _INPUT = \"\"\"# paste here...\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\n\n\n# def solve(N: int, a: List[int]) -> int:\ndef solve(N, a):\n\n    x = min(a)\n\n    while True:\n        min_k = 10**9\n        for i in range(N):\n            a[i] = a[i] % x\n            if a[i] > 0:\n                min_k = min(min_k, a[i])\n        if min_k == 10**9:\n            return x\n        x = min_k\n\n\ndef main():\n    N = int(input())\n    a = list(map(int, input().split()))\n    a1 = solve(N, a)\n    print(a1)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom functools import reduce\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\nn=int(input())\na=list(map(int,input().split()))\n\nprint(gcd_list(a))", "N = int(input())\na = list(map(int, input().split()))\n\ndef gcd(n, m):\n    if m == 0:\n        return n\n    elif m > n:\n        return gcd(m, n)\n    return gcd(m, n % m)\n\nif N == 1:\n    print(a[0])\nelse:\n    ans = gcd(a[0], a[1])\n    for i in range(2, N):\n        ans = gcd(ans, a[i])\n    print(ans)", "import math\n\nN = int(input())\na = list(map(int, input().split()))\nans = a[0]\nfor i in range(1, N):\n    ans = math.gcd(ans, a[i])\nprint(ans)\n", "n = int(input())\nA = list(map(int, input().split()))\nimport math\nfrom functools import reduce\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\ng = gcd_list(A)\nprint(g)\n", "from math import gcd\n\nn = int(input())\nA = list(map(int, input().split()))\n\nA = list(set(A))\nn = len(A)\nans = A[0]\nfor i in range(n):\n    ans = gcd(ans, A[i])\nprint(ans)", "from math import gcd\nfrom functools import reduce\nn=int(input())\na=list(map(int,input().split()))\n\nprint(reduce(gcd,a))", "import math\nfrom functools import reduce\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\nN = int(input())\nA = list(map(int, input().split()))\n\nprint(gcd_list(A))", "from math import gcd\n\nN = int(input())\na = list(map(int, input().split()))\n\nif N == 1:\n    print((a[0]))\n    return\n\nans = gcd(a[0], a[1])\nif N == 2:\n    print(ans)\n    return\nfor i in range(2, N):\n    ans = gcd(ans, a[i])\nprint(ans)\n", "# -*- coding: utf-8 -*-\n# a = int(input())\n# b, c = map(int, input().split())\n# \u6587\u5b57\u5217\u306e\u5165\u529b\n# s = input()\n# \u51fa\u529b\n# print(\"{} {}\".format(a+b+c, s))\n\n\nN = int(input())\na = list(map(int, input().split()))\n\nans = a[0]\n\nfrom math import gcd\n\nfor aval in a:\n    ans = gcd(ans, aval)\n\nprint(ans)", "n = int( input())\na = list( map( int, input().split()))\nimport functools\ndef euclid(a, b):\n    if b == 0:\n        return a\n    else:\n        return euclid(b, a%b)\ndef gcd(nums):\n  return functools.reduce(euclid, nums)\nprint(gcd(a))", "# coding: utf-8\nimport math\nn = int(input())\nA = list(map(int,input().split()))\n\nm = max(A)\nm_ = min(A)\ng = A[0]\nfor i in range(n):\n    g = math.gcd(g, A[i])\n\nprint(g)", "import math\nn = int(input())\nres = 0\nfor ai in list(map(int, input().split())):\n    res = math.gcd(res, ai)\nprint(res)", "from math import gcd\nn = int(input())\na = list(map(int,input().split()))\nans = 0\nfor i in a:\n    ans = gcd(ans,i)\nprint(ans)", "import sys\ninput=sys.stdin.readline\n\nn=int(input())\na=set(map(int,input().split()))\na=list(a)\na.sort()\n#print(a)\n\nwhile len(a)>1:\n  d=set([a[0]])\n  for ii in range(1,len(a)):\n    if a[ii]%a[0]>0:\n      d.add(a[ii]%a[0])\n  a=list(d)\n  a.sort()\n  \nprint(a[0])", "from math import gcd\ndef solve():\n    N = int(input())\n    A = list(map(int,input().split()))\n\n    ans = 0\n    for i in range(N):\n        ans = gcd(ans, A[i])\n    \n    print(ans)\ndef __starting_point():\n    solve()\n\n__starting_point()", "from numpy import *\nN = int(input())\nA = list(map(int,input().split()))\nprint(gcd.reduce(A))", "import sys\nimport math\nfrom functools import reduce\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef gcd(nums):\n    return reduce(math.gcd, nums)\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    ans = gcd(A)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom functools import reduce\n\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(gcd_list(a))", "import math\n\n\ndef multi_gcd(lst):\n    if len(lst) == 1:\n        return lst[0]\n    gcd = 0\n    for i in range(1, len(lst)):\n        if i == 1:\n            gcd = math.gcd(lst[0], lst[1])\n        else:\n            gcd = math.gcd(gcd, lst[i])\n    return gcd\n\n\nn = int(input())\na = list(map(int, input().split()))\nprint(multi_gcd(a))", "import math\nN = int(input())\nA = list(map(int,input().split()))\nans = A[0]\n\nfor i in A:\n    ans = math.gcd(i, ans)\nprint(ans)", "def gcd(x,y):\n    while y>0:\n        x,y = y,x%y\n    return x\nN = int(input())\nA = list(map(int,input().split()))\na = A[0]\nfor i in range(1,N):\n    b = A[i]\n    a = gcd(a,b)\nprint(a)", "import math\n\nN = int(input())\nl = list(map(int, input().split()))\n\ngcd = l[0]\nfor i in range(1, N):\n  gcd = math.gcd(gcd, l[i])\n\nprint(gcd)"]
["import copy\nh,w =list(map(int,input().split()))\n\ns = [[]*w for _ in range(h)]\nwhite =0\nfor i in range(h):\n    t = input()\n    for j in range(w):\n        if t[j] == \".\":\n            white += 1\n            s[i].append(10**5)\n        elif t[j] == \"#\":\n            s[i].append(t[j])\nnow = [0,0]\nsteps =[]\nsteps.append(now)\ndirection = []\ns[0][0] =0\na = [2]\nwhile len(steps) >0:\n    now = copy.copy(steps[0])\n    if s[now[0]][now[1]] ==\"#\":\n        continue\n    for k in [[0,1],[1,0],[-1,0],[0,-1]]:\n        now = copy.copy(steps[0])\n        if now[0] + k[0] >=0 and now[0] + k[0] < h:\n            now[0] += k[0]\n            if now[1] + k[1] >=0 and now[1] + k[1] <w:\n                now[1] += k[1]\n                if s[now[0]][now[1]] == 10**5:\n                    if not [now[0],now[1]] in steps:\n                        steps.append([now[0],now[1]])\n            else:\n                continue\n        else:\n            continue\n    # if s[steps[0][0]][steps[0][1]] ==0:\n    #     steps.pop(0)\n    #     continue\n    if s[steps[0][0]][steps[0][1]] >10**4:\n        direction =[]\n        for l in [[0,1],[1,0],[-1,0],[0,-1]]:\n            if steps[0][0]+l[0]>=0 and steps[0][0]+l[0]<h and steps[0][1]+l[1]< w and steps[0][1]+l[1] >=0 and s[steps[0][0]+l[0]][steps[0][1]+l[1]] != \"#\":\n                s[steps[0][0]][steps[0][1]]=min(s[steps[0][0]+l[0]][steps[0][1]+l[1]]+1,s[steps[0][0]][steps[0][1]])\n    steps.pop(0)\nif s[h-1][w-1] == \"#\" or s[h-1][w-1] == 10**5:\n    print((-1))\nelse:\n    print((white-1 - s[h-1][w-1]))\n\n\n\n\n\n\n\n", "from collections import deque\n\ndef bfs():\n    # \u305f\u3069\u308a\u7740\u304f\u307e\u3067\u306b\u304b\u304b\u3063\u305f\u56de\u6570\u3092\u3044\u308c\u308b\u591a\u91cd\u30ea\u30b9\u30c8\u3002\n    d = [[float(\"inf\")] * w for i in range(h)]\n    # 1\u30ce\u30fc\u30c9\u964d\u308a\u308b\u3068\u304d\u306bfor\u3067\u56de\u305b\u308b\u3088\u3046\u30ea\u30b9\u30c8\u5316\u3057\u3066\u304a\u304f\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n    # \u63a5\u3057\u305f\u30dd\u30a4\u30f3\u30c8\u3092\u53d6\u308a\u8fbc\u3080\u7528\u306eque\u3092\u5b9a\u7fa9\n    que = deque([])\n    # \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u3092que\u306b\u52a0\u3048\u308b\u3002\u63a2\u7d22\u306e\u969b\u306fque\u304b\u3089\u53d6\u308a\u51fa\u3059\u30eb\u30fc\u30d7\u3092\u56de\u3059\u306e\u3067\u6700\u521d\u3060\u3051\u5148\u306b\u5165\u308c\u3066\u304a\u304f\n    que.append((sx,sy))\n    # \u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u306b\u304b\u304b\u308b\u8ddd\u96e2\u306f0\u306a\u306e\u3067inf\u30920\u306b\u304b\u3048\u308b\u3002\n    d[sx][sy] = 0\n    # que\u304c\u3042\u308b\u304b\u304e\u308a\u7d9a\u3051\u308b\n    while que:\n        p = que.popleft()\n        # \u53d6\u308a\u51fa\u3057\u305f\u70b9\u304c\u30b4\u30fc\u30eb\u306a\u3089\u7d42\u4e86\n        if p[0] == gy and p[1] == gx:\n            break\n        #\u3000\u305d\u308c\u4ee5\u5916\u306e\u6642\u306f\uff0c\u63a5\u3057\u3066\u3044\u308b\u70b9\u30924\u65b9\u5411\u9806\u306b\u53d6\u5f97\u3002\u4e00\u3064\u305a\u3064\u51e6\u7406\u3059\u308b\u3002\n        for i in range(4):\n            nx = p[0] + dx[i]\n            ny = p[1] + dy[i]\n            # \u65b0\u3057\u304f\u53d6\u5f97\u3057\u305f\u5ea7\u6a19\u306b\u5bfe\u3057\u3066\u306e\u51e6\u7406\n            # \u8ff7\u8def\u5185\u306b\u5b58\u5728\u3059\u308b\u5ea7\u6a19\u3067\u3042\u308a\uff0c\u58c1\u3067\u306f\u306a\u304f\uff0c\u307e\u3060\u901a\u3063\u305f\u3053\u3068\u304c\u306a\u304fd\u304cinf\u306e\u70b9\u306a\u3089\u51e6\u7406\u3059\u308b = \u65b0\u3057\u304f\u53d6\u5f97\u3057\u305f\u9053\u5019\u88dc\u306e1\u3064\n            if 0 <= nx < h and 0 <= ny < w and maze[nx][ny] != \"#\" and d[nx][ny] == float(\"inf\"):\n                # \u9053\u5019\u88dc\u3092que\u306b\u52a0\u3048\u308b\u3002\n                que.append((nx, ny))\n                # \u305d\u306e\u9053\u5019\u88dc\u3078\u306e\u7d4c\u8def\u307e\u3067\u306b\u304b\u304b\u3063\u305f\u7d4c\u8def\u3092d\u306b\u52a0\u3048\u308b\u3002\n                d[nx][ny] = d[p[0]][p[1]] + 1\n    return d[gx][gy]\n\nh, w = list(map(int, input().split()))\nmaze = [list(input()) for i in range(h)]\nsx, sy = 0, 0\ngx, gy = h - 1, w - 1\n\nwhite = 0\nfor i in range(h):\n    for j in range(w):\n        if maze[i][j] == \".\":\n            white += 1\n\nres = bfs()\nif 0 < res < float(\"inf\"):\n    # \u767d\u3044\u30de\u30b9\u306e\u6570\u304b\u3089\u6700\u77ed\u7d4c\u8def\u3067\u304b\u304b\u308b\u30b3\u30b9\u30c8\u5206\u3092\u5f15\u304f\n    # \u30b4\u30fc\u30eb\u3092\u9ed2\u3044\u30de\u30b9\u306b\u5909\u3048\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u305f\u3081\u305d\u306e\u5206\u3082\u5f15\u304f\n    print((white - res - 1))\nelse:\n    print((-1))\n", "from collections import deque\nimport sys\nh,w = map(int,input().split())\nmp = [list(input()) for _ in range(h)]\n\nvisited = [[0]*w for _ in range(h)]\n\ndxdy = [[1,0],[0,1],[-1,0],[0,-1]]\n\nqueue = deque()\nqueue.append([0,0,1])\nvisited[0][0]=1\n\nwhile queue:\n    x,y,d = queue.popleft()\n    for dx,dy in dxdy:\n        nx,ny = x+dx,y+dy\n        if -1<nx<h and -1<ny<w and visited[nx][ny]==0 and mp[nx][ny]!=\"#\":\n            visited[nx][ny]=d+1\n            queue.append([nx,ny,d+1])\n            #[print(*visited[l]) for l in range(h)]\n            #print(\"---------------\")            \n\nif visited[-1][-1]==0:\n    print(-1)\n    return\n\ncnt = 0\nfor i in range(h):\n    for j in range(w):\n        if mp[i][j]!=\"#\":\n            cnt += 1\n\nprint(cnt-visited[-1][-1])", "from collections import deque\n\nh, w = list(map(int, input().split()))\ngrid = [input() for _ in range(h)]\n\nq = deque([(0, 0)])\ndists = [[10000] * w for _ in range(h)]\ndists[0][0] = 0\nprev = [[-1] * w for _ in range(h)]\n\nwhile q:\n    x, y = q.popleft()\n\n    nei = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for xo, yo in nei:\n        nextx, nexty = x+xo, y+yo\n\n        if nextx < 0 or nextx >= w or nexty < 0 or nexty >= h:\n            continue\n        if grid[nexty][nextx] == \"#\":\n            continue\n\n        dist = dists[y][x]+1\n\n        if dist < dists[nexty][nextx]:\n            dists[nexty][nextx] = dist\n            prev[nexty][nextx] = (x, y)\n            q.append((nextx, nexty))\n\nif prev[h-1][w-1] != -1:\n    path = []\n    cur = (w-1, h-1)\n\n    while cur != -1:\n        path.append(cur)\n        cur = prev[cur[1]][cur[0]]\n\n    cnt = 0\n    for i in range(w):\n        for j in range(h):\n            if grid[j][i] == \".\" and (i, j) not in path:\n                cnt += 1\n\n    print(cnt)\nelse:\n    print(-1)", "from collections import deque\n\nY, X = map(int, input().split())\nMap = list(input() for _ in range(Y))\n\ndef bfs(sy, sx, gy, gx):\n    seen = list([-1]*X for _ in range(Y))\n    queue = deque()\n    queue.append((sy, sx))\n    seen[sy][sx] = 0\n    while queue:\n        y, x = queue.popleft()\n        search_around(y, x, seen, queue)\n        if seen[gy][gx] > 0:\n            return seen[gy][gx]\n\ndef search_around(y, x, seen, queue):\n    count = seen[y][x]\n    for u,t in [(y-1,x), (y+1,x), (y,x-1), (y,x+1)]:\n        if u < 0 or t < 0 or u >= Y or t >= X:\n            continue\n        elif Map[u][t] == '#' or seen[u][t] != -1:\n            continue\n        queue.append((u, t))\n        seen[u][t] = count + 1\n        \ncnt = 0\nfor M in Map:\n    for m in M:\n        if m == '#':\n            cnt += 1\n\nb = bfs(0,0,Y-1,X-1)\nif b == None:\n    print(-1)\nelse:\n    print(Y*X - cnt - b - 1)", "H,W=map(int,input().split())\nMAP=[list(input()) for _ in range(H)]\ncnt=0\nfor l in MAP:\n  cnt+=l.count(\"#\")\nFLAG=[[-1]*W for _ in range(H)]\nFLAG[0][0]=1\nq=[(0,0)]\nd=[(1,0),(0,1),(-1,0),(0,-1)]\nwhile q:\n  y,x=q.pop(0)\n  for dy,dx in d:\n    if 0<=y+dy<H and 0<=x+dx<W and FLAG[y+dy][x+dx]==-1 and MAP[y+dy][x+dx]==\".\":\n      FLAG[y+dy][x+dx]=FLAG[y][x]+1\n      q.append((y+dy,x+dx))\n\nif FLAG[H-1][W-1]==-1:\n  print(-1)\nelse:\n  print(H*W-FLAG[H-1][W-1]-cnt)", "from collections import deque\n\nh,w=map(int,input().split())\nw_sum=0\nmaze=[]\ninf=10000000\nfor _ in range(h):\n  s=list(input())\n  for i in range(w):\n    if s[i]=='.':\n      s[i]=inf\n      w_sum+=1\n  maze.append(s)\n  \ndef solve(maze,h,w):\n  qu=deque([[0,0]])\n  maze[0][0]=0\n  while qu:\n    y,x=qu.popleft()\n    t=maze[y][x]\n    for i in ([1,0],[-1,0],[0,1],[0,-1]):\n      ny=y+i[0]\n      nx=x+i[1]\n      if 0<=ny<=h-1 and 0<=nx<=w-1 and maze[ny][nx]!='#':\n        if maze[ny][nx]>t+1:\n          maze[ny][nx]=t+1\n          qu.append([ny,nx])\n          \n  return maze[h-1][w-1]\n  \nif solve(maze,h,w)==inf:\n  print(-1)\nelse:\n  print(w_sum-solve(maze,h,w)-1)", "from collections import deque\nH, W = list(map(int, input().split()))\nroute = []\nn_black = 0\nfor _ in range(H):\n  tmp_ls = input()\n  n_black += tmp_ls.count(\"#\")\n  route.append(tmp_ls)\nvisited = [[False]*W for _ in range(H)]\ndist = [[-1]*W for _ in range(H)]\ndist[0][0] = 0\ntmp = [0,0]\ngoal = [H-1, W-1]\nkouho = deque()\ndef rinsetsu(ls):\n  x, y = ls[0], ls[1]\n  ans = []\n  if x-1 >= 0:\n    ans.append([x-1, y])\n  if x+1 <= H-1:\n    ans.append([x+1, y])\n  if y-1 >= 0:\n    ans.append([x, y-1])\n  if y+1 <= W-1:\n    ans.append([x, y+1])\n  return ans\nfor ls in rinsetsu([0,0]):\n  if route[ls[0]][ls[1]] == \".\":\n    kouho.append([ls[0], ls[1], 0, 0])\ndef bfs():\n  while True:\n    while True:\n      if len(kouho) == 0:\n        return\n      tmp = kouho.popleft()\n      if not visited[tmp[0]][tmp[1]]:\n        break\n    x, y = tmp[0], tmp[1]\n    visited[x][y] = True\n    dist[x][y] = dist[tmp[2]][tmp[3]] + 1\n    if [x, y] == goal:\n      return\n    for ls in rinsetsu([x,y]):\n      if not visited[ls[0]][ls[1]] and route[ls[0]][ls[1]] == \".\":\n        kouho.append(ls + [x, y])\nbfs()\nif dist[H-1][W-1] == -1:\n  print((-1))\nelse:\n  white = dist[H-1][W-1] + 1\n  print((H*W - white - n_black))\n\n", "from collections import deque\n\nH, W = list(map(int, input().split()))\n\nmazo = [list(input()) for _ in range(H)]\n\ncnt = 0 #\u521d\u671f\u72b6\u614b\u306e\u9ed2\u306e\u6570\u3092\u6570\u3048\u308b\nfor i in range(H):\n    for j in range(W):\n        if mazo[i][j] == \"#\":\n            cnt += 1\n\nd = deque()\nd.append((0,0))\n\nmove = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\nvisited = [[0]*W for _ in range(H)]\n\nflg = False\nwhile d:\n    y, x = d.popleft()\n    if (y==H-1) and (x==W-1):\n        flg = True\n        break\n\n    for u, v in move:\n        t = y + u\n        s = x + v\n        if 0 <= t and t<H and 0<=s and s<W and mazo[t][s]==\".\" and visited[t][s]==0:\n            visited[t][s] = visited[y][x] + 1\n            d.append((t, s))\n\nif flg:\n    print((H*W - cnt - visited[H-1][W-1] -1))\nelse:\n    print((-1))\n", "def __starting_point():\n    from collections import deque\n    H, W = map(int,input().split())\n    s = []\n    black = 0\n    for _ in range(H):\n        t = list(input())\n        for c in t:\n            if c == \"#\":\n                black += 1\n        s.append(t)\n    q = deque([(0,0,1)])\n    s[0][0] = \"#\"\n    while q:\n        x,y,d = q.popleft()\n        if x == H-1 and y == W-1:\n            print(H*W-d-black)\n            return\n        for nx,ny in [(x+1,y), (x,y+1), (x-1,y), (x,y-1)]:\n            if 0 <= nx < H and 0<= ny < W and s[nx][ny] == \".\":\n                s[nx][ny] = \"#\"\n                q.append((nx,ny,d+1))\n    print(-1)\n__starting_point()", "H, W = map(int, input().split())\nimport numpy as np\nGrid = np.array([[0 if x == '.' else -1 for x in input()] for _ in range(H)],dtype='int64')\n\ndef solveMase(Grid, start, goal): #bfs\u3067\u8ff7\u8def\u3092\u89e3\u304d\u3001\u30b9\u30bf\u30fc\u30c8-\u30b4\u30fc\u30eb\u9593\u306e\u6700\u4f4e\u5fc5\u8981\u767d\u30de\u30b9\u6570\u3092\u8fd4\u3059\n    seen = {start}\n    V = [start]\n    while len(V) != 0: #bfs\n        v = V.pop(0)\n        if v == goal:\n            return Grid[goal]\n        #\u79fb\u52d5\u5148nv\u3092\u30ea\u30b9\u30c8\u306b\u307e\u3068\u3081\u308b\n        y,x = v\n        nV = []\n        if x > 0: nV.append((y,x-1))\n        if y > 0: nV.append((y-1,x))\n        if x < W-1: nV.append((y,x+1))\n        if y < H-1: nV.append((y+1,x))\n        #bfs\n        for nv in nV:\n            if Grid[nv] == -1 or nv in seen:\n                continue\n            Grid[nv] = Grid[v] + 1\n            V.append(nv)\n            seen.add(nv)\n    return 0\n\nwhite = len(Grid[Grid == 0])-1\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\nprint(white-nes_white if nes_white > 0 else -1)", "from collections import deque\n\ndef bfs(sy,sx):\n  queue = deque([[sy,sx]])\n  d[sy][sx] = 0\n  while queue:\n    y,x = queue.popleft()\n    for i,j in [(-1,0),(1,0),(0,-1),(0,1)]:\n      dy,dx = y+i,x+j\n      if dy < 0 or h <= dy: continue\n      elif dx < 0 or w <= dx: continue\n      elif s[dy][dx] == \"#\": continue\n      elif d[dy][dx] != -1: continue\n      d[dy][dx] = d[y][x] + 1\n      queue.append([dy,dx])\n\nh,w = map(int, input().split())\ns = [input() for _ in range(h)]\n\nif s[0][0] == \"#\" or s[h-1][w-1] == \"#\":\n  print(-1)\n  return\n\nd = [[-1]*w for _ in range(h)]\nbfs(0,0)\nif d[h-1][w-1] == -1: print(-1)\nelse:\n  t = 0\n  for i in s: t += i.count(\"#\")\n  print(h*w - t - d[h-1][w-1] -1)", "from queue import Queue\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\nH, W = list(map(int, input().split()))\nS = [input() for _ in range(H)]\ndist = [[-1] * W for _ in range(H)]\nque = Queue()\n\n# \u521d\u671f\u6761\u4ef6\ndist[0][0] = 0\nque.put((0, 0))\n\n# \u5e45\u512a\u5148\u63a2\u7d22\nwhile not que.empty():\n    x, y = que.get()\n    for dir in range(4):\n        x2, y2 = x + dx[dir], y + dy[dir]\n        if x2 < 0 or x2 >= H or y2 < 0 or y2 >= W or S[x2][y2] == '#':\n            continue\n        if dist[x2][y2] != -1:\n            continue\n        dist[x2][y2] = dist[x][y] + 1\n        que.put((x2, y2))\n\n# \u767d\u30de\u30b9\u6570\nwhite = sum(sum(1 if S[x][y] == '.' else 0 for y in range(W)) for x in range(H))\n\n# \u7b54\u3048\nprint((white - dist[H-1][W-1] - 1 if dist[H-1][W-1] != -1 else -1))\n", "from _collections import deque\n\n\ndef bfs():  # \u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\u3000\u2192\u3000\u767d\u30de\u30b9\u306e\u6570\u304b\u3089\u6700\u77ed\u7d4c\u8def\u3092\u5f15\u304f\n    que = deque([])\n    que.append((0, 0))\n    dh = [-1, 0, 1, 0]\n    dw = [0, -1, 0, 1]\n    d = [[float(\"inf\")] * w for _ in range(h)]\n    d[0][0] = 0\n    while que:\n        p = que.popleft()\n        if p[0] == h-1 and p[1] == w-1:\n            break\n        for i in range(4):\n            nh = p[0] + dh[i]\n            nw = p[1] + dw[i]\n            if 0 <= nh < h and 0 <= nw < w and d[nh][nw] == float(\"inf\") and c[nh][nw] == '.':\n                que.append((nh, nw))\n                d[nh][nw] = 1 + d[p[0]][p[1]]\n    return d[h-1][w-1]\n\n\nh, w = list(map(int, input().split()))\nc = [list(input()) for _ in range(h)]\ncount = 0  # \u767d\u30de\u30b9\u306e\u6570\nfor i in range(h):\n    for j in range(w):\n        if c[i][j] == '.':\n            count += 1\n\nmi = bfs()\n\nif 0 < mi < float(\"inf\"):\n    print((count - mi -1))\nelse:\n    print((-1))\n", "from collections import deque\nimport sys\n\nH,W=map(int,input().split())\nS=[[x for x in input()] for _ in range(H)]\n\ncount=0\nfor i in range(len(S)):\n  count+=S[i].count('.')\n\nd=deque([(0,0)])\ndistance=[[-1]*W for _ in range(H)]\ndistance[0][0]=0\ngoal_distance=0\n\nwhile d:\n  h,w=d.popleft()\n  if h==H-1 and w==W-1:\n    goal_distance=distance[h][w]\n    break\n  \n  if h-1>=0 and S[h-1][w]=='.':\n    d.append((h-1,w))\n    distance[h-1][w]=distance[h][w]+1\n    S[h-1][w]='#'\n    \n  if h+1<=H-1 and S[h+1][w]=='.':\n    d.append((h+1,w))\n    distance[h+1][w]=distance[h][w]+1\n    S[h+1][w]='#'\n    \n  if w-1>=0 and S[h][w-1]=='.':\n    d.append((h,w-1))\n    distance[h][w-1]=distance[h][w]+1\n    S[h][w-1]='#'\n    \n  if w+1<=W-1 and S[h][w+1]=='.':\n    d.append((h,w+1))\n    distance[h][w+1]=distance[h][w]+1\n    S[h][w+1]='#'\nelse:\n  if distance[H-1][W-1]==-1:\n    print(-1)\n    return\n\nprint(count-(goal_distance+1))", "def main():\n\tH, W = [int(n) for n in input().split(\" \")]\n\tiniBlack = 0\n\tS = []\n\tS.append([\"X\"] * (W + 2))\n\tfor i in range(H):\n\t\trow = list(input())\n\t\tiniBlack += row.count(\"#\")\n\t\tS.append([\"X\"] + row + [\"X\"])\n\tS.append([\"X\"] * (W + 2))\n\n\tto_visit = [{\"row\": 1, \"col\": 1, \"step\": 1}]\n\tchecked = [[0] * (W + 2) for i in range(H + 2)]\n\tchecked[1][1] = 1\n\n\twhile len(to_visit) > 0:\n\t\tvisiting = to_visit.pop(0)\n\t\tr0 = visiting[\"row\"]\n\t\tc0 = visiting[\"col\"]\n\t\ts0 = visiting[\"step\"]\n\t\tfor d in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n\t\t\tr = r0 + d[0]\n\t\t\tc = c0 + d[1]\n\t\t\tif S[r][c] == \".\" and checked[r][c] == 0:\n\t\t\t\tto_visit.append({\"row\": r, \"col\": c, \"step\": s0 + 1})\n\t\t\t\tchecked[r][c] = s0 + 1\n\n\tif checked[H][W] == 0:\n\t\tprint(-1)\n\t\treturn 0\n\tprint(H * W - iniBlack - checked[H][W])\n\nmain()", "import queue\nh, w = list(map(int, input().split()))\ns = []\nblack_num = 0\nfor i in range(h):\n    s_ij = input()\n    s.append(s_ij)\n    for j in range(w):\n        if s_ij[j] == \"#\":\n            black_num += 1\n\nalready_pass = set()\nalready_pass.add((1, 1))\nq = queue.Queue()\nq.put([(1, 1), 1])\n\nwhile not q.empty():\n    x_y, l = q.get()\n    x = x_y[0]\n    y = x_y[1]\n    if x == h and y == w:\n        print((h * w - black_num - l))\n        break\n    next_xy = [(max(1, x - 1), y), (min(h, x + 1), y),\n               (x, max(1, y - 1)), (x, min(w, y + 1))]\n    for i in next_xy:\n        if i not in already_pass and s[i[0] - 1][i[1] - 1] != \"#\":\n            q.put([i, l + 1])\n            already_pass.add(i)\nelse:\n    print((-1))\n", "from collections import deque\n\n\ndef bfs(start, goal):\n    q = deque([[start]])\n    visited = set()\n    while q:\n        path = q.popleft()\n        i, j = path[-1]\n        if (i, j) == goal:\n            return path\n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W and field[ni][nj] == \".\"):\n                continue\n            if (ni, nj) not in visited:\n                q.append(path + [(ni, nj)])\n                visited.add((ni, nj))\n    return []\n\n\nH, W = list(map(int, input().split()))\nfield = [input() for _ in range(H)]\nshortest_path = bfs((0, 0), (H - 1, W - 1))\nif shortest_path:\n    print((sum(v == \".\" for row in field for v in row) - len(shortest_path)))\nelse:\n    print((-1))\n", "from collections import *\nH,W = map(int,input().split())\nS = [input() for h in range(H)]\nV = [W*[0] for h in range(H)]\nV[0][0] = 1\nQ = deque([(0,0)])\nwhile Q:\n  x,y = Q.popleft()\n  for dx,dy in ((-1,0),(0,-1),(1,0),(0,1)):\n    if 0<=x+dx<H and 0<=y+dy<W and V[x+dx][y+dy]==0 and S[x+dx][y+dy]==\".\":\n      V[x+dx][y+dy] = V[x][y]+1\n      Q.append((x+dx,y+dy))\n\nif V[H-1][W-1]==0:\n  print(-1)\nelse:\n  print(H*W-sum(s.count(\"#\") for s in S)-V[H-1][W-1])", "H, W = map(int, input().split())\nMAP = [ list(input()) for _ in range(H) ]\ncnt = 0\nfor l in MAP:\n    cnt += l.count(\"#\")\nFLAG = [[-1] * W for _ in range(H)]\nFLAG[0][0] = 1\nq = [(0, 0)]\nd = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nwhile q:\n    y, x = q.pop(0)\n    for dy, dx in d:\n        if 0 <= y + dy < H and 0 <= x + dx < W and FLAG[y + dy][x + dx] == -1 and MAP[y + dy][x + dx] == \".\":\n            FLAG[y + dy][x + dx] = FLAG[y][x] + 1\n            q.append((y + dy, x + dx))\n\nif FLAG[H - 1][W - 1] == -1:\n    print(-1)\nelse:\n    print(H * W - FLAG[H - 1][W - 1] - cnt)", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n  return int(readline())\nh,w = readInts()\nblock = [input() for _ in range(h)]\n\nallcnt = 0\nfor i in range(w):\n    for j in range(h):\n        if block[j][i] == '.':\n            allcnt += 1\nINF = float('inf')\nAR = [[INF] * w for _ in range(h)]\ndy = [1,0,0,-1]\ndx = [0,-1,1,0]\ndef bfs():\n    d = deque()\n    d.append([0,0])\n    while d:\n        y,x = d.popleft()\n        if y == 0 and x == 0:\n            AR[y][x] = 0\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if (not 0 <= ny < h) or (not 0 <= nx < w):\n                continue\n            if AR[ny][nx] == INF and block[ny][nx] != '#':\n                AR[ny][nx] = AR[y][x] + 1\n                d.append([ny,nx])\nbfs()\nif AR[h-1][w-1] == INF:\n    print((-1))\nelse:\n    print((allcnt - (AR[h-1][w-1]+1))) # start\u5730\u70b9\u306e\u5206\n", "from collections import deque\nh, w = map(int, input().split())\ns = [list(input()) for i in range(h)]\nans = sum([i.count(\"#\") for i in s])\ns = [[\"#\"]*(w+2)] + [[\"#\"]+i+[\"#\"] for i in s] + [[\"#\"]*(w+2)]\nd = deque([[1, 1, 1]])\nwhile len(d) > 0:\n    x, y, cnt = d.popleft()\n    if x == h and y == w:\n        print(h*w-cnt-ans)\n        return\n    s[x][y] = \"#\"\n    if s[x-1][y] == \".\":\n        d.append([x-1, y, cnt+1])\n        s[x-1][y] = \"#\"\n    if s[x+1][y] == \".\":\n        d.append([x+1, y, cnt+1])\n        s[x+1][y] = \"#\"\n    if s[x][y-1] == \".\":\n        d.append([x, y-1, cnt+1])\n        s[x][y-1] = \"#\"\n    if s[x][y+1] == \".\":\n        d.append([x, y+1, cnt+1])\n        s[x][y+1] = \"#\"\nprint(-1)", "H, W = map(int, input().split())\nimport numpy as np\nGrid = np.array([[0 if x == '.' else -1 for x in input()] for _ in range(H)],dtype='int64')\n\ndef solveMase(Grid, start, goal):\n    seen = {start}\n    V = [start]\n    while len(V) != 0:\n        v = V.pop(0)\n        if v == goal:\n            return Grid[goal]\n\n        y,x = v\n        nV = []\n        if x > 0: nV.append((y,x-1))\n        if y > 0: nV.append((y-1,x))\n        if x < W-1: nV.append((y,x+1))\n        if y < H-1: nV.append((y+1,x))\n\n        for nv in nV:\n            if Grid[nv] == -1 or nv in seen:\n                continue\n            Grid[nv] = Grid[v] + 1\n            V.append(nv)\n            seen.add(nv)\n    return 0\n\nwhite = len(Grid[Grid == 0])-1\nnes_white = solveMase(Grid, (0,0), (H-1,W-1))\nif nes_white > 0:\n    ans = white - nes_white\nelse:\n    ans = -1\nprint(ans)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nH,W = map(int,input().split())\nsy, sx = 0,0\ngy, gx = H-1,W-1\nD = [list(input()) for i in range(H)]\nBs = 0\nfor i in range(H):\n    Bs += D[i].count(\"#\")\n\nQ = deque()\nQ.append((sy,sx))\ndist = [[-1]*W for i in range(H)]\ndist[sy][sx] = 0\ndx = [1,0,-1,0]\ndy = [0,-1,0,1]\n\nwhile Q:\n    x,y = Q.popleft()\n    for i in range(4):\n        nx = x+dx[i]\n        ny = y+dy[i]\n        if 0<=nx<=W-1 and 0<=ny<=H-1 and D[ny][nx]!=\"#\" and dist[ny][nx] == -1:\n            Q.append((nx,ny))\n            dist[ny][nx] = dist[y][x]+1\n\nprint(H*W-Bs-1-dist[gy][gx] if dist[gy][gx]!=-1 else -1)", "from collections import deque\nh,w = map(int,input().split())\nmaze = [['#'] * (w+2) for i in range(h+2)]\nwall = 0\nfor i in range(1,h+1):\n    s = input()\n    for j in range(1,w+1):\n        if s[j-1] == '#':\n            wall += 1\n        maze[i][j] = s[j-1]\nqueue = deque([[1,1]])\nmaze[1][1] = 0\nwhile queue:\n    x,y = queue.popleft()\n    if [x,y] != [h,w]:\n        for n,m in ([0,-1],[0,1],[-1,0],[1,0]):\n            new_h,new_w = x+n,y+m\n            if maze[new_h][new_w] == '.':\n                maze[new_h][new_w] = maze[x][y] + 1\n                queue.append([new_h,new_w])\n            elif maze[new_h][new_w] != \"#\":\n                maze[new_h][new_w] = min(maze[new_h][new_w],maze[x][y]+1)\n            else:\n                pass\nif maze[h][w] == '.' or maze[h][w] == '#':\n    print(-1)\nelse:\n    print(h*w-(maze[h][w]+1)-wall)", "from collections import deque\nH, W = list(map(int, input().split()))\nS = [list(input()) for _ in range(H)]\n\ndef get_next(x, y, costs, S, cost):\n    ans = list()\n    if x != 0 and costs[x-1][y] == -1 and S[x-1][y] == \".\":\n        ans.append([x-1, y])\n        costs[x-1][y] = cost + 1\n\n    if x != H-1 and costs[x+1][y] == -1 and S[x+1][y] == \".\":\n        ans.append([x+1, y])\n        costs[x+1][y] = cost + 1\n\n    if y != 0 and costs[x][y-1] == -1 and S[x][y-1] == \".\":\n        ans.append([x, y-1])\n        costs[x][y-1] = cost + 1\n\n    if y != W-1 and costs[x][y+1] == -1 and S[x][y+1] == \".\":\n        ans.append([x, y+1])\n        costs[x][y+1] = cost + 1\n\n    return ans\n\ncosts = [[-1 for _ in range(W)] for _ in range(H)]\ncosts[0][0] = 0\nq = deque()\nq.append([0, 0])\nwhile len(q) and costs[H-1][W-1] == -1:\n    now = q.popleft()\n    nxt = get_next(now[0], now[1], costs, S, costs[now[0]][now[1]])\n    for dot in nxt:\n        q.append([dot[0], dot[1]])\n    \nfin_cost = costs[H-1][W-1]\nif fin_cost == -1:\n    print((-1))\nelse:\n    w_cnt = 0\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == \".\":\n                w_cnt += 1\n    print((w_cnt - fin_cost - 1))\n", "import sys\nfrom collections import deque\n\n\ndef IN_I(): return int(sys.stdin.readline().rstrip())\ndef IN_LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef IN_S(): return sys.stdin.readline().rstrip()\ndef IN_LS(): return list(sys.stdin.readline().rstrip().split())\n\n\nH, W = IN_LI()\ns = [IN_S() for _ in range(H)]\n\ndh = [-1, 0, 1, 0]\ndw = [0, -1, 0, 1]\n\ndist = [[-1] * W for j in range(H)]\ndist[0][0] = 0\n\nq = deque()\nq.append([0, 0])\n\nwhile q:\n    now = q.popleft()\n    now_h = now[0]\n    now_w = now[1]\n\n    for i in range(4):\n        next_h = now_h + dh[i]\n        next_w = now_w + dw[i]\n\n        if not (0 <= next_h < H and 0 <= next_w < W):\n            continue\n        if s[next_h][next_w] == '#':\n            continue\n\n        if dist[next_h][next_w] == -1:\n            q.append([next_h, next_w])\n            dist[next_h][next_w] = dist[now_h][now_w] + 1\n\nif dist[-1][-1] == -1:\n    print((-1))\n    return\n\nblack = sum([i.count('#') for i in s])\nans = (H * W - black) - (dist[-1][-1] + 1)\nprint(ans)\n", "def abc088d_grid_repainting():\n    import heapq\n    h, w = map(int, input().split())\n    maze = []\n    cnt = h * w\n    for _ in range(h):\n        s = input()\n        maze.append(s)\n        cnt -= s.count('#')\n    q = [(1, 0, 0)]\n    heapq.heapify(q)\n    check = [[False] * w for _ in range(h)]\n    while len(q) != 0:\n        dis, x, y = heapq.heappop(q)\n        if (x, y) == (h - 1, w - 1):\n            print(cnt - dis)\n            return\n        for dx, dy in zip([0, 0, 1, -1], [1, -1, 0, 0]):\n            if 0 <= x + dx < h and 0 <= y + dy < w and maze[x + dx][y + dy] != '#' and not check[x + dx][y + dy]:\n                check[x + dx][y + dy] = True\n                heapq.heappush(q, (dis+1, x + dx, y + dy))\n    print('-1')\nabc088d_grid_repainting()", "h,w = map(int,input().split())\nw_cnt = 0\nL = []\nfor i in range(h):\n    s = input()\n    w_cnt += s.count(\".\")\n    L.append(s)\n\nfrom collections import deque\nvisited = [[0]*w for _ in range(h)]\n\nq = deque([[0,0]])\nli = [[1,0],[0,1],[-1,0],[0,-1]]\n\nwhile q:\n    y,x = q.popleft()\n    for dy,dx in li:\n        ny,nx = y+dy,x+dx\n        if ny < 0 or ny >= h or nx < 0 or nx >= w or visited[ny][nx] > 0 or L[ny][nx] == \"#\" :\n            continue\n        visited[ny][nx] = visited[y][x] + 1\n        if [ny,nx] == [h-1,w-1]:\n            print(w_cnt-visited[ny][nx]-1)\n            return\n        q.append([ny,nx])\n        \nprint(-1)", "from collections import deque\n\n\ndef bfs():\n    d = [[float(\"inf\")] * w for i in range(h)]\n\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n\n    que = deque([])\n    que.append((sx, sy))\n    d[sx][sy] = 0\n\n    while que:\n        p = que.popleft()\n        if p[0] == gx and p[1] == gy:\n            break\n        for i in range(4):\n            nx = p[0] + dx[i]\n            ny = p[1] + dy[i]\n\n            if 0 <= nx < h and 0 <= ny < w and maze[nx][ny] != \"#\" and d[nx][ny] == float(\"inf\"):\n                que.append((nx, ny))\n                d[nx][ny] = d[p[0]][p[1]] + 1\n\n    return d[gx][gy]\n\n\nh, w = map(int, input().split())\nmaze = [list(input()) for i in range(h)]\nsx, sy = 0, 0\ngx, gy = h - 1, w - 1\n\n# \u767d\u3044\u30de\u30b9\u3092\u6570\u3048\u308b\nwhite = 0\nfor i in range(h):\n    for j in range(w):\n        if maze[i][j] == \".\":\n            white += 1\n\nres = bfs()\nif 0 < res < float(\"inf\"):\n    # \u767d\u3044\u30de\u30b9\u306e\u6570\u304b\u3089\u6700\u77ed\u7d4c\u8def\u3067\u304b\u304b\u308b\u30b3\u30b9\u30c8\u5206\u3092\u5f15\u304f\n    # \u30b4\u30fc\u30eb\u3092\u9ed2\u3044\u30de\u30b9\u306b\u5909\u3048\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u305f\u3081\u305d\u306e\u5206\u3082\u5f15\u304f\n    print(white - res - 1)\nelse:\n    print(-1)", "from collections import deque\nh,w=list(map(int,input().split()))\nnum=[list(input()) for _ in range(h)]\nseen=[[False]*w for _ in range(h)]\nqueue=deque()\nqueue.append([0,0])\nans=[[0]*w for _ in range(h)]\nseen[0][0]=True\nfor i in range(h*w*100):\n    if len(queue)==0:\n        break\n    cnt=queue.popleft()\n    if num[max(0,cnt[0]-1)][cnt[1]]==\".\" and seen[max(0,cnt[0]-1)][cnt[1]]==False:\n        queue.append([cnt[0]-1,cnt[1]])\n        seen[max(0,cnt[0]-1)][cnt[1]]=True\n        ans[max(0,cnt[0]-1)][cnt[1]]=ans[cnt[0]][cnt[1]]+1\n    if num[min(h-1,cnt[0]+1)][cnt[1]]==\".\" and seen[min(h-1,cnt[0]+1)][cnt[1]]==False:\n        queue.append([cnt[0]+1,cnt[1]])\n        seen[min(h-1,cnt[0]+1)][cnt[1]]=True\n        ans[min(h-1,cnt[0]+1)][cnt[1]]=ans[cnt[0]][cnt[1]]+1\n    if num[cnt[0]][max(cnt[1]-1,0)]==\".\" and seen[cnt[0]][max(cnt[1]-1,0)]==False:\n        queue.append([cnt[0],cnt[1]-1])\n        seen[cnt[0]][max(cnt[1]-1,0)]=True\n        ans[cnt[0]][max(cnt[1]-1,0)]=ans[cnt[0]][cnt[1]]+1\n    if num[cnt[0]][min(w-1,cnt[1]+1)]==\".\" and seen[cnt[0]][min(w-1,cnt[1]+1)]==False:\n        queue.append([cnt[0],cnt[1]+1])\n        seen[cnt[0]][min(w-1,cnt[1]+1)]=True\n        ans[cnt[0]][min(w-1,cnt[1]+1)]=ans[cnt[0]][cnt[1]]+1\nif seen[-1][-1]==False:\n    print((-1))\nelse:\n    cnt3=0\n    for i in range(h):\n        cnt3+=num[i].count(\".\")\n    print((cnt3-ans[-1][-1]-1))\n", "from collections import deque\n\n\ndef bfs(start, goal):\n    q = deque([[start]])\n    visited = set()\n    while q:\n        path = q.popleft()\n        i, j = path[-1]\n        if (i, j) == goal:\n            return path\n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W and field[ni][nj] == \".\"):\n                continue\n            if (ni, nj) not in visited:\n                q.append(path + [(ni, nj)])\n                visited.add((ni, nj))\n    return []\n\n\nH, W = list(map(int, input().split()))\nfield = [input() for _ in range(H)]\nshortest_path = bfs((0, 0), (H - 1, W - 1))\nif shortest_path:\n    print((sum(v == \".\" for row in field for v in row) - len(shortest_path)))\nelse:\n    print((-1))\n", "from collections import deque\nH, W = list(map(int,input().split()))\nS = [input() for _ in range(H)]\n\nQ = deque([[0,0]])\ndist = [[-1] * W for _ in range(H)]\ndist[0][0] = 0\n\nwhile Q:\n    h, w = Q.popleft()\n\n    for nh, nw in [[h+1,w],[h-1,w],[h,w-1],[h,w+1]]:\n        if 0 <= nh < H and 0 <= nw < W and S[nh][nw] == \".\" and dist[nh][nw] == -1:\n            dist[nh][nw] = dist[h][w] + 1\n            Q.append([nh,nw])\n\nif dist[H-1][W-1] == -1:\n    print((-1))\nelse:\n    ans = 0\n    for s in S: ans += s.count(\".\")\n    print((ans - dist[H-1][W-1] - 1))\n\n", "\n\n\n\n\ndx = (0,1,0,-1)\ndy = (1,0,-1,0)\n\n\nH, W = list(map(int, input().split()))\n\nS=[input() for i in range(H)]\nS_check = [[False]*W for _ in range(H)]\n\nstart = (0, 0, 1)\ngoal = (H-1, W-1)\n\nQ = []\nQ.append(start)\n\nstep = 0\nis_reached = False\n\nwhile Q:\n    current = Q.pop(0)\n    step = current[2]\n    \n    for i in range(4):\n        next_pos = (current[0]+dx[i], current[1]+dy[i])\n\n        if next_pos[0] < 0 or next_pos[0] > H-1 or next_pos[1] < 0 or next_pos[1] > W-1:\n            continue\n        elif S_check[next_pos[0]][ next_pos[1]]:\n            continue\n        elif next_pos == goal:\n            is_reached = True\n            break\n        elif S[next_pos[0]][ next_pos[1]] == \"#\":\n            continue\n        else:\n            S_check[next_pos[0]][ next_pos[1]] = True\n            Q.append((next_pos[0], next_pos[1], step+1))\n\n    if is_reached:\n        break\n\ncnt = 0\nfor i in range(H):\n    for j in range(W):\n       if S[i][j] == \"#\":\n           cnt += 1\nans = -1\nif is_reached:\n    ans = H * W - step -1 - cnt\nprint(ans)\n\n\n", "from collections import deque\n\nh, w = map(int, input().split())\ns = [list(input()) for _ in range(h)]\ndots = sum([v.count('.') for v in s]) # count the number of all dots('.')\n\nvisited = [[-1] * w for _ in range(h)] \n# visited shows the number of dots in the path up to there\n\nq = deque([[0, 0]])\nvisited[0][0] = 1\n\nwhile q:\n    y, x = q.popleft()\n    if y == h - 1 and x == w - 1:\n        break\n    for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n        ny, nx = y + i, x + j\n        if (not 0 <= ny < h) or (not 0 <= nx < w) or s[ny][nx] == '#':\n            continue\n        elif visited[ny][nx] == -1:\n            visited[ny][nx] = visited[y][x] + 1\n            q.append([ny, nx])\nif visited[h - 1][w - 1] != -1:\n    # in the case one can reach the goal\n    print(dots - visited[h - 1][w - 1])\nelse: # otherwise\n    print(-1)", "H, W = list(map(int, input().split()))\ngrid = [input() for _ in range(H)]\nchecked = [[False]*W for _ in range(H)]\n\n\ndef solve(arr, count):\n    next_arr = set()\n    count += 1\n    for a in arr:\n        y, x = a[0], a[1]\n        checked[y][x] = True\n        if y == H-1 and x == W-1:\n            return count\n        if y < H-1:\n            if not checked[y+1][x] and grid[y+1][x] == '.':\n                next_arr.add((y+1, x))\n        if 0 < y:\n            if not checked[y-1][x] and grid[y-1][x] == '.':\n                next_arr.add((y-1, x))\n        if x < W-1:\n            if not checked[y][x+1] and grid[y][x+1] == '.':\n                next_arr.add((y, x+1))\n        if 0 < x:\n            if not checked[y][x-1] and grid[y][x-1] == '.':\n                next_arr.add((y, x-1))\n    if len(next_arr) == 0:\n        return -1\n    return solve(next_arr, count)\n\n\nmin_steps = solve([(0, 0)], 0)\nif min_steps == -1:\n    print((-1))\nelse:\n    w_c = 0\n    for i in grid:\n        w_c += i.count('.')\n    print((w_c - min_steps))\n", "import sys\nread = sys.stdin.read\nfrom collections import deque\ndef main():\n    h, w = map(int, input().split())\n    wall_cnt = 0\n    gg = list()\n    gg.append([1] * (w + 2))\n    for _ in range(h):\n        row = tuple(input())\n        wall_cnt += row.count('#')\n        gg.append([1] + [c == '#' for c in row] + [1])\n    gg.append([1] * (w + 2))\n\n    g2 = [[0] * (w + 2) for _ in range(h + 2)]\n    g2[1][1] = 1\n    vs = deque()\n    vs.append((1, 1))\n    move_y = (0, 1, 0, -1)\n    move_x = (1, 0, -1, 0)\n    while vs:\n        y, x = vs.popleft()\n        ys = [y + i for i in move_y]\n        xs = [x + i for i in move_x]\n        for yse, xse in zip(ys, xs):\n            if not gg[yse][xse]:\n                vs.append((yse, xse))\n                gg[yse][xse] = 1\n                g2[yse][xse] = g2[y][x] + 1\n    if g2[h][w] == 0:\n        print(-1)\n    else:\n        ans = (h * w) - g2[h][w] - wall_cnt\n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\ninf = 10**10\n\nh,w = map(int,input().split())\nfield = [input() for _ in range(h)]\n\nlength = [[inf for j in range(w)]for i in range(h)]\nvisited = [[0 for j in range(w)]for i in range(h)]\n\nmove = [[-1,0],[1,0],[0,-1],[0,1]]\n\nque = deque([])\nque.append([0,0])\nlength[0][0] = 1 # \uff11\u30b9\u30bf\u30fc\u30c8\nvisited[0][0] = 1\n\nwhite = 0\n\nfor i in range(h):\n    white += field[i].count(\".\")\n\nwhile que:\n    y,x = que.popleft()\n\n    for i,j in move:\n        ny,nx = y+i,x+j\n\n        if ny < 0 or ny >= h or nx < 0 or nx >= w:\n            continue\n        elif field[ny][nx] == \"#\":\n            continue\n        elif visited[ny][nx] == 1:\n            continue\n        \n        visited[ny][nx] = 1\n        que.append([ny,nx])\n        length[ny][nx] = length[y][x] + 1\n\nif length[h-1][w-1] == inf:\n    print(-1)\nelse:\n    print(white-length[h-1][w-1]) # \u767d\u306e\u7dcf\u6570\u304b\u3089\u6700\u5c0f\u8ddd\u96e2\u5206\u5f15\u304f", "h, w = list(map(int, input().split()))\n\nmatrix = [list('#' * (w + 2))]\ncount_sharp = 0\nfor _ in range(h):\n    C = list(input())\n    count_sharp += C.count('#')\n    matrix.append(['#'] + C + ['#'])\nmatrix.append(list('#') * (w + 2))\n\nB = [[] for _ in range(10000)]\n\n\nfor i in range(h+2):\n    for j in range(w+2):\n        if matrix[i][j] == '.':\n            if matrix[i-1][j] == '.':\n                B[100*i+j].append(100*(i-1) + j)\n            if matrix[i][j-1] == '.':\n                B[100*i+j].append(100*i + j - 1)\n            if matrix[i][j+1] == '.':\n                B[100*i+j].append(100*i + j + 1)\n            if matrix[i+1][j] == '.':\n                B[100*i+j].append(100*(i+1) + j)\n\n# print(matrix)\ndef solver(matrix, h, w, count_):\n    path = [10000000] * 10000\n    depth = 0\n    path[101] = 0\n    reached = [101]\n    stack = []\n    stack.append(101)\n    while len(stack) > 0:\n        depth += 1\n        for _ in range(len(stack)):\n            val = stack.pop(0)\n            for j in matrix[val]:\n                if j not in set(reached):\n                    path[j] = min(depth, path[j])\n                    reached.append(j)\n                    stack.append(j)\n\n    if path[h*100 + w] == 10000000:\n        print((-1))\n    else:\n        print((h * w - path[h*100+w] - 1 - count_))\nsolver(B, h, w, count_sharp)\n", "from collections import deque\n\nH, W = map(int, input().split())\nS = [input() for _ in range(H)]\n\ns = 0\nfor c in S:\n    s += c.count('.')\n\nque = deque()\ndist = [[-1 for j in range(W)] for i in range(H)]\ndist[0][0] = 0\nst = (0, 0)\nque.append(st)\ndydx = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nwhile que:\n    p, q = que.popleft()\n\n    for dy, dx in dydx:\n        if 0 <= p+dy and p+dy < H and 0 <= q+dx and q+dx < W:\n            if dist[p+dy][q+dx] != -1 or S[p+dy][q+dx] != '.':\n                continue\n\n            dist[p+dy][q+dx] = dist[p][q] + 1\n            que.append((p+dy, q+dx))\n\nif dist[H-1][W-1] == -1:\n    print(-1)\nelse:\n    print(s-dist[H-1][W-1]-1)", "from collections import deque\nH,W=map(int,input().split())\nmp=[['#']*(W+2)]\ncount=0\nfor _ in range(H):\n    l=list(input())\n    mp.append(['#']+l+['#'])\n    count+=l.count('.')\nmp.append(['#']*(W+2))\n\ndist=[[-1]*(W+2)for _ in range(H+2)]\nQ=deque()\nQ.append((1,1))\ndist[1][1]=1\nf=False\n\nwhile Q:\n    y,x=Q.popleft()\n    if (y,x)==(H,W):\n        f=True\n        break\n    for dy,dx in [(1,0),(-1,0),(0,1),(0,-1)]:\n        ny=y+dy\n        nx=x+dx\n        if 0<=ny<H+2 and 0<=nx<W+2:\n            if mp[ny][nx]=='.' and dist[ny][nx]==-1:\n                Q.append((ny,nx))\n                dist[ny][nx]=dist[y][x]+1\n\nif f:\n    print(count-dist[H][W])\nelse:\n    print(-1)", "def getval():\n    h,w = map(int,input().split())\n    s = [input() for i in range(h)]\n    return h,w,s\n\ndef main(h,w,s):\n    #Find numbers of whites \n    whites = 0\n    for i in s:\n        for j in range(w):\n            if i[j]==\".\":\n                whites += 1\n\n    #Find the shortest path\n    d = [[-1 for i in range(w)] for j in range(h)]\n    q = [[0,0,0]]\n    d[0][0] = 0\n    while q:\n        idx = q.pop(0)\n        adj = [[idx[0]+1,idx[1],idx[2]+1],[idx[0]-1,idx[1],idx[2]+1],[idx[0],idx[1]+1,idx[2]+1],[idx[0],idx[1]-1,idx[2]+1]]\n        for i in adj:\n            if i[0]<0 or i[1]<0 or i[0]>=h or i[1]>=w:\n                continue\n            if d[i[0]][i[1]]!=-1:\n                continue\n            if s[i[0]][i[1]]==\"#\":\n                continue\n            q.append(i)\n            d[i[0]][i[1]] = i[2]\n\n    dist = d[h-1][w-1]\n    \n    #Compute the score\n    if dist==-1:\n        print(-1)\n    else:\n        print(whites-dist-1)\n\ndef __starting_point():\n    h,w,s = getval()\n    main(h,w,s)\n__starting_point()", "from collections import deque\n\nH,W=map(int,input().split())\nmaze=[list(input()) for i in range(H)]\n\nsx,sy=0,0\ngx,gy=H-1,W-1\n\ndef bfs():\n    d=[[float('inf')]*W for i in range(H)]\n    dx=[1,0,-1,0]\n    dy=[0,1,0,-1]\n\n    que=deque([])\n    que.append((sx,sy))\n    d[sx][sy]=0\n\n    while que:\n        p=que.popleft()\n        if p[0]==gx and p[1]==gy:\n            break\n        for i in range(4):\n            nx=p[0]+dx[i]\n            ny=p[1]+dy[i]\n            if 0<=nx<H and 0<=ny<W and maze[nx][ny]!=\"#\" and d[nx][ny]==float(\"inf\"):\n                que.append((nx,ny))\n                d[nx][ny]=d[p[0]][p[1]]+1\n        \n    return d[gx][gy]\n\nans=0\ncnt=0\nres=bfs()\nfor i in range(H):\n    for j in range(W):\n        if maze[i][j]=='.':\n            cnt+=1\nif res==float('inf'):\n    ans=-1\nelse:\n    ans=cnt-res-1\nprint(ans)", "H, W = map(int, input().split())\nG = [input() for _ in range(H)]\nsy, sx, gy, gx = 0, 0, H - 1, W - 1\nseen = [[-1] * W for _ in range(H)]\n\nif G[sy][sx] == '#' or G[gy][gx] == '#':\n    print(-1)\n    return\n\nfrom collections import deque\nque = deque()\nque.append([sy, sx])\nseen[sy][sx] = 0\nwhile que:\n    y, x = que.popleft()\n    for d in [-1, 0], [1, 0], [0, -1], [0, 1]:\n        dy = y + d[0]\n        dx = x + d[1]\n        if dy < 0 or H <= dy or dx < 0 or W <= dx:\n            continue\n        if G[dy][dx] == '#':\n            continue\n        if seen[dy][dx] > -1:\n            continue\n        que.append([dy, dx])\n        seen[dy][dx] = seen[y][x] + 1\n\ncount = 0\nbunpu = [0] * (H * W + 1)\nif seen[gy][gx] == -1:\n    print(-1)\n    return\nelse:\n    all = H * W\n    black = 0\n    for i in range(H):\n        for j in range(W):\n            if G[i][j] == '#':\n                black += 1\n    #start point = 0,0 \n    ans = all - black - seen[gy][gx] - 1\nprint(ans)", "from collections import deque\n\nH, W = map(int, input().split())\n\nM = []\n\nwhite = 0\nfor _ in range(H):\n    M.append(input())\n    white += M[-1].count('.')\n\nq = deque()\nq.append((0, 0))\nvisit = [0] * (H * W)\nvisit[0] = 1\n\ndef bfs():\n    while q:\n        x, y = q.popleft()\n        for (dx, dy) in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n            x2 = x + dx\n            y2 = y + dy\n\n            if x2 < 0 or x2 > W - 1: continue\n            if y2 < 0 or y2 > H - 1: continue\n\n            if visit[y2 * W + x2]: continue\n            if M[y2][x2] == '#': continue\n\n            visit[y2 * W + x2] = visit[y * W + x] + 1\n\n            if y2 == H - 1 and x2 == W - 1:\n                return visit[y2 * W + x2]\n\n            q.append((x2, y2))\n\nsteps = bfs()\nans = -1\nif steps:\n    ans = white - steps\n\nprint(ans)", "H,W=list(map(int,input().split()))\nsq=[list(input()) for i in range(H)]\nans=False\nc=H*W\npos=[[0,0,0]]\n\nwhile pos!=[]:\n    y,x,depth=pos.pop(0)\n\n    if x==W-1 and y==H-1:\n        ans=True\n        break\n\n    if 0<=x+1<=W-1:\n        if sq[y][x+1]==\".\":\n            pos.append([y,x+1,depth+1])\n            sq[y][x+1]=\"!\"\n            \n    if 0<=x-1<=W-1:\n        if sq[y][x-1]==\".\":\n            pos.append([y,x-1,depth+1])\n            sq[y][x-1]=\"!\"\n            \n    if 0<=y+1<=H-1:\n        if sq[y+1][x]==\".\":\n            pos.append([y+1,x,depth+1])\n            sq[y+1][x]=\"!\"\n            \n    if 0<=y-1<=H-1:\n        if sq[y-1][x]==\".\":\n            pos.append([y-1,x,depth+1])\n            sq[y-1][x]=\"!\"\n    \n    \nfor j in range(H):\n    for k in range(W):\n        if sq[j][k]==\"#\":\n            c-=1\n\nif ans==True:\n    print((c-depth-1))\nelse:\n    print((-1))\n", "# config\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\n\n# input\nH, W = map(int, input().split())\nmaze = []\nfor _ in range(H):\n    maze.append(input())\n\n\n# \u30b9\u30bf\u30fc\u30c8\u3068\u30b4\u30fc\u30eb\nsi, sj = 0, 0\ngi, gj = H-1, W-1\n\n# 4\u8fd1\u508d\u30d9\u30af\u30c8\u30eb\u2193\u2192\u2191\u2190\ndidj = [(1,0), (0,1), (-1, 0), (0, -1)]\n\ndef bfs(H, W, blocker=\"X\"):\n    # que\u304c\u7a7a\u306b\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\n    while que != deque():\n        i, j = que.popleft()\n        for di, dj in didj:\n            ni = i + di\n            nj = j + dj\n            # \u9077\u79fb\u5148ninj\u304c\u4e0d\u6b63\u3067\u306a\u3044\u304b\u30fb\u58c1\u3067\u306a\u3044\u304b\u30fb\u307e\u3060\u8a2a\u308c\u305f\u3053\u3068\u304c\u306a\u3044\u304b\u3092\u30c1\u30a7\u30c3\u30af\n            if 0 <= ni and ni < H and 0 <= nj and nj < W and maze[ni][nj] != blocker and d[ni][nj] == INF:\n                d[ni][nj] = d[i][j] + 1\n                que.append((ni, nj))\n    return\n\nINF = H*W*10\nd = [[INF for x in range(W)] for x in range(H)]\nd[si][sj] = 0\n\n# \u6700\u77ed\u7d4c\u8def\u63a2\u7d22\u958b\u59cb\nque = deque()\nque.append((si, sj))\nbfs(H,W, blocker=\"#\")\n\n# \u305f\u3069\u308a\u7740\u304f\u3068\u3053\u304c\u3067\u304d\u306a\u304b\u3063\u305f\u5834\u5408\nif d[gi][gj] == INF:\n    print(-1)\n\n# \u30b9\u30b3\u30a2\u51fa\u529b\nelse:\n    blc = 0\n    for h in maze:\n        for l in h:\n            if l == \"#\":\n                blc += 1\n    score = H*W - blc - d[gi][gj] - 1 # \u5168\u30de\u30b9\u6570 - \u58c1\u306e\u6570 - \u6700\u77ed\u7d4c\u8def\u5206 - \u30b9\u30bf\u30fc\u30c8\u30de\u30b9\u306e\u5206\n    print(score)", "t,*g=open(0);h,w=list(map(int,t.split()));v=[[0]*w for _ in range(h)];v[0][0]=1;q=[(0,0)]\nwhile q:\n\ta,b=q.pop(0)\n\tfor c,d in((-1,0),(0,-1),(1,0),(0,1)):\n\t\tx=a+c;y=b+d\n\t\tif w>x>=0<=y<h and v[y][x]<1 and g[y][x]==\".\":q+=[(x,y)];v[y][x]=v[b][a]+1\nt=v[-1][-1];print(((-1,sum(c.count(\".\")for c in g)-t)[t>0]))\n", "import collections\nimport math\n\n\nH,W=map(int,input().split())\n\nc=[list(str(input())) for i in range(H)]\n#1<=sy<=R\nd=[[0 for j in range(W)]for i in range(H)]\ninf=10**6\nans=0\nfor i in range(H):\n    for j in range(W):\n        if c[i][j]=='#':\n            d[i][j]=-1\n        else:\n            d[i][j]=inf\n            ans+=1\n\n\nd[0][0]=0\nqueue=collections.deque([[0,0]])\ngy,gx=H-1,W-1\n\nmoves=[[1,0],[-1,0],[0,1],[0,-1]]\n\nflag=False\nwhile len(queue)>0:\n    now=queue.popleft()\n    for i in range(4):\n        ny=now[0]+moves[i][0]\n        nx=now[1]+moves[i][1]\n        \n        if 0<=ny and ny<H and 0<=nx and nx<W and c[ny][nx]=='.' and d[ny][nx]==inf:\n            d[ny][nx]=d[now[0]][now[1]]+1\n            queue.append([ny,nx])\n            if ny==gy and nx==gx:\n                print(ans-d[ny][nx]-1)\n                return\nprint(-1)     ", "# \u767d\u3060\u3051\u52d5\u3044\u3066(0,0)\u304b\u3089(H-1, W-1)\u306b\u884c\u304f\n# \u305d\u306e\u969b\u306b\u3067\u304d\u308b\u3060\u3051\u9ed2\u3092\u5897\u3084\u3059\n# \u5168\u4f53\u306e\u767d\u304b\u3089\u6700\u77ed\u8ddd\u96e2\u3092\u9664\u3044\u305f\u3082\u306e\u304c\u7b54\u3048\n\nfrom collections import deque\n\n\nH, W = list(map(int, input().split()))\ngrid = [list(input()) for _ in range(H)] # .\u306f\u767d\u3001#\u306f\u9ed2\nvisited = [[-1] * W for _ in range(H)]\nmoves = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nq = deque()\nq.append((0, 0))\nvisited[0][0] = 0\n\nwhile q:\n    y, x = q.popleft()\n\n    for dy, dx in moves:\n        moved_y = y + dy\n        moved_x = x + dx\n\n        if moved_y < 0 or H-1 < moved_y or moved_x < 0 or W-1 < moved_x:\n            continue\n        if grid[moved_y][moved_x] == '#':\n            continue\n        if visited[moved_y][moved_x] != -1:\n            continue\n\n        visited[moved_y][moved_x] = visited[y][x] + 1\n        q.append((moved_y, moved_x))\n\nmin_route = visited[H-1][W-1]\n\nif min_route == -1:\n    answer = -1\nelse:\n    total_white = 0\n    for row in grid:\n        total_white += row.count('.')\n\n    answer = total_white - min_route - 1\n\nprint(answer)\n\n\n", "H,W=list(map(int,input().split()))\n\nsq=[list(input()) for i in range(H)]\n\npos=[[0,0,0]]\ng=True\n\nwhile pos!=[]:\n    y,x,depth=pos.pop(0)\n\n    if y==H-1 and x==W-1:\n        g=False\n        break\n    \n    if x-1>=0:\n        if sq[y][x-1]==\".\":\n            pos.append([y,x-1,depth+1])\n            sq[y][x-1]=\"!\"\n    if x+1<=W-1:\n        if sq[y][x+1]==\".\":\n            pos.append([y,x+1,depth+1])\n            sq[y][x+1]=\"!\"\n    if y-1>=0:\n        if sq[y-1][x]==\".\":\n            pos.append([y-1,x,depth+1])\n            sq[y-1][x]=\"!\"\n    if y+1<=H-1:\n        if sq[y+1][x]==\".\":\n            pos.append([y+1,x,depth+1])\n\nif g==True:\n    print((-1))\nelse:\n    temp=0\n    for k in range(H):\n        for m in range(W):\n            if sq[k][m]==\"#\":\n                temp+=1\n\n\n    print((H*W-temp-depth-1))\n", "a, b = map(int, input().split())\nG = []\nwhite_num = 0\nfor i in range(a):\n    s = list(input())\n    white_num += s.count('.')\n    G.append(s)\nfrom collections import deque\ndef mazesearch(G, initial_h, initial_w, target_h, target_w):\n    '''\n    G is for example:\n        G = [[1,0,1,1,1,1],\n            [1,0,1,0,1,0],\n            [1,0,1,0,1,1],\n            [1,1,1,0,1,1]]\n    '''\n    steps = 0\n    BLOCKED, ALLOWED   = '#', '.'\n    UNVISITED, VISITED = 0, 1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    if G[initial_h][initial_w] == BLOCKED:\n        return -1\n    height, width = len(G), len(G[0])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_h][initial_w] = VISITED\n    queue = deque([(initial_h, initial_w, steps)])\n    while queue:\n        h, w, steps = queue.popleft()\n        if h == target_h and w == target_w:\n            return steps\n        for dh, dw in directions:\n            new_h = h + dh\n            new_w = w + dw\n            if not (0 <= new_h < height and 0 <= new_w < width):\n                continue\n            if G[new_h][new_w] == ALLOWED and is_visited[new_h][new_w] == UNVISITED:\n                queue.append((new_h, new_w, steps + 1))\n                is_visited[new_h][new_w] = VISITED\n    return -1\nsteps = mazesearch(G, 0, 0, a-1, b-1)\nif steps == -1:\n    print(-1, flush=True)\nelse:\n    print(white_num - steps - 1, flush=True)\n", "from collections import deque\nimport copy\nH,W = map(int, input().split())\ns=[list(input()) for i in range(H)]\n#H,W=3,3\n#s=[['.', '.', '#'], ['#', '.', '.'], ['.', '.', '.']]\n\nss=copy.deepcopy(s)\nq=deque([[0,0]])#(H,W)\nss[0][0]=0\nmove=[[1,0],[0,1],[0,-1],[-1,0]]\nnum=0\nt=False\nwhile q:\n    num+=1\n    for i in range(len(q)):\n        b=q.popleft()\n        #print(b)\n        if b==[H-1,W-1]:\n            t=True\n            num-=1\n            break\n        for m in move:\n         #  print(m)\n            if 0<=b[0]+m[0]<=H-1 and 0<=b[1]+m[1]<=W-1 and ss[b[0]+m[0]][b[1]+m[1]]=='.':\n                ss[b[0]+m[0]][b[1]+m[1]]=num\n                q.append([b[0]+m[0],b[1]+m[1]])\n    else:\n        continue\n    break\nif not t :\n    print('-1')\nelse:\n    x=num\n    b=H-1,W-1\n    ss[b[0]][b[1]]='#'\n    while x!=0:\n        for m in move:\n            if 0<=b[0]+m[0]<=H-1 and 0<=b[1]+m[1]<=W-1 and ss[b[0]+m[0]][b[1]+m[1]]==x-1:\n                x=x-1\n                ss[b[0]+m[0]][b[1]+m[1]]='#'\n                b=b[0]+m[0],b[1]+m[1]\n                break\n    ans=0\n    for h in range(H):\n        for w in range(W):\n            if ss[h][w]!='#':\n                ans+=1\n    print(ans)", "from collections import deque\n\nH, W = map(int, input().split())\nM = []\nM = ['#' * (W+2)]\n\nnum_blk = 0\n\nfor h in range(H):\n    inp = input() \n    M.append('#' + inp + '#')\n    num_blk += inp.count('#')\nM.append('#' * (W+2))\n\nsy, sx = 1, 1\ngy, gx = H, W\n\nT = [[float('inf')] * (W + 2) for _ in range(H + 2)]\nT[sy][sx] = 0\n\nque = deque([(sy, sx)])\nwhile len(que) > 0:\n    y, x = que.popleft()\n    for a, b in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        if M[y+b][x+a] != '#' and T[y+b][x+a] == float('inf'):\n            T[y+b][x+a] = T[y][x]+1\n            que.append((y+b, x+a))\n    if y == gy and x == gx:\n        break\nif T[gy][gx] == float('inf'):\n    print(-1)\nelse:\n    print(H * W - num_blk - T[gy][gx] - 1)", "from collections import deque\nfrom collections import Counter\nH, W = map(int, input().split())\ns = [list(input()) for _ in range(H)]\nt = [[-1]*W for _ in range(H)]\nq = deque([[0,0]])\nt[0][0] = 0\nwhile len(q) > 0:\n  qq = q.popleft()\n  dh = [-1,0,1,0]\n  dw = [0,1,0,-1]\n  for i in range(4):\n    h = qq[0] + dh[i]\n    w = qq[1] + dw[i]\n    if 0 <= h < H and 0 <= w < W:\n      if s[h][w] == \"#\" or t[h][w] != -1: continue\n      t[h][w] = t[qq[0]][qq[1]] + 1\n      q.append([h,w])\n\nX = 0\nfor i in range(H):\n  c = Counter(s[i])\n  X += c[\".\"]\nif t[H-1][W-1] == -1:\n  print(-1)\nelse:\n  print(X-1-t[H-1][W-1])", "import sys\nfrom collections import Counter\nfrom collections import deque\n\ninput = sys.stdin.readline\n\ndef main():\n    H, W = list(map(int, input().split()))\n    grid = []\n    wh = 0\n    for _ in range(H):\n        tmp = list(input()[:-1])\n        wh += Counter(tmp)['.']\n        grid.append(tmp)\n    check = [[0]*W for _ in range(H)]\n        \n    # digtmp\n    digtmp = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    #digtmp = [(0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1)]\n    \n    # BFS\n    # please prefer objects:\n    #  H: height.\n    #  W: width\n    #  field: maze field made of '.', '#'.\n    #  check: check field\n    que = deque([(0, 0)])\n    check[0][0] = 1\n    while True:\n        a, b = que.popleft()\n        for dx, dy in digtmp:\n            x = a + dx\n            y = b + dy\n            if not (0 <= x < H and 0 <= y < W):\n                continue\n            if check[x][y] != 0 or grid[x][y] == '#':\n                continue\n            check[x][y] = check[a][b] + 1\n            que.append((x, y))\n        if len(que) == 0:\n            break\n    \n    if check[H-1][W-1] == 0:\n        print((-1))\n    else:\n        print((wh - check[H-1][W-1]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\nh, w, *s = open(0).read().split()\nh = int(h)\nw = int(w)\nall = sum(t.count('#') for t in s)\n\ninf = 1 << 30\nd = np.full((h + 1, w + 1), inf, dtype=np.int)\n\nd[0][0] = 0\nq = [(0, 0)]\nfor v in q:\n    for nv in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n        ny = v[0] + nv[0]\n        nx = v[1] + nv[1]\n        if 0 <= nx < w and 0 <= ny < h and d[ny][nx] == inf and s[ny][nx] == '.':\n            d[ny][nx] = d[v[0]][v[1]] + 1\n            q.append((ny, nx))\n\nif d[h - 1][w - 1] == inf:\n    print((-1))\nelse:\n    print((h * w - (d[h - 1][w - 1] + 1) - all))\n", "import sys\nimport operator\nfrom collections import deque,Counter\n\ninput=sys.stdin.readline\nh,w=map(int,input().split())\nsx,sy=0,0\n#print(sx,sy)\ngx,gy=h-1,w-1\n#print(gx,gy)\ns=[list(input()) for _ in range(h)]\n#\u767d\u306e\u30d6\u30ed\u30c3\u30af\u3092\u6570\u3048\u308b\nc=[]\nfor a in s:\n  c+=a\nc=Counter(c)\n#print(c[\".\"])\nwhite=c[\".\"]\n#\u79fb\u52d5\u51484\u65b9\u5411\ndx = [1, 0, -1,  0]\ndy = [0, 1,  0, -1]\n#\u8a2a\u554f\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\nvisited=[[-1]*w for _ in range(h)]\n\ndef bfs(x,y):\n  queue=deque([[x,y]])\n  visited[x][y]=0\n  while queue:\n    \n    x,y=queue.popleft()\n    if [x,y]==[gx,gy]:\n      return visited[x][y]\n    for i in range(4):\n      nx,ny=x+dx[i],y+dy[i]\n      if nx>=0 and nx<h and ny>=0 and ny<w and s[nx][ny]==\".\" and visited[nx][ny]==-1:\n        visited[nx][ny]=visited[x][y]+1\n        queue.append([nx,ny])\n        #print(queue)\n    \nbfs(sx,sy)\n#print(*visited,sep=\"\\n\")\nprint(white-visited[gx][gy]-1 if visited[gx][gy]!=-1 else -1)", "from collections import deque\n\ndef bfs(sy,sx):\n  q = deque([[sy,sx]])\n  d[sy][sx] = 0\n  while q:\n    y,x = q.popleft()\n    for i,j in [(-1,0),(1,0),(0,-1),(0,1)]:\n      dy,dx = y+i,x+j\n      if dy < 0 or h <= dy: continue\n      elif dx < 0 or w <= dx: continue\n      elif s[dy][dx] == \"#\": continue\n      elif d[dy][dx] != -1: continue\n      d[dy][dx] = d[y][x]+1\n      q.append([dy,dx])\n\nh,w = map(int, input().split())\ns = [input() for _ in range(h)]\n\nif s[0][0] == \"#\" or s[h-1][w-1] == \"#\":\n  print(-1)\n  return\n\nd = [[-1]*w for _ in range(h)]\nbfs(0,0)\nif d[h-1][w-1] == -1: print(-1)\nelse:\n  t = 0\n  for i in range(h): t += s[i].count(\"#\")\n  print(h*w-t-(d[h-1][w-1]+1))", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[47]:\n\n\nfrom collections import deque\n\n\n# In[50]:\n\n\nH,W = list(map(int, input().split()))\ngrid = [list(\"#\"*(W+2))]\nb_cnt = 0\nfor _ in range(H):\n    tmp = list(input())\n    grid.append([\"#\"]+tmp+[\"#\"])\ngrid.append(list(\"#\"*(W+2)))\n\n\n# In[52]:\n\n\ngrid[1][1] = 1\nq = deque([[1,1]])\nmove = [\n    [1,0],[-1,0],[0,1],[0,-1]\n]\nwhile q:\n    x,y = q.popleft()\n    for dx,dy in move:\n        if grid[x+dx][y+dy] == \".\":\n            grid[x+dx][y+dy] = grid[x][y]+1\n            q.append([x+dx,y+dy])\nif grid[H][W] == \".\":\n    print((-1))\nelse:\n    print(((H+2)*(W+2) - sum(g.count(\"#\") for g in grid) - grid[H][W]))\n\n\n# In[ ]:\n\n\n\n\n", "from collections import deque\n\nH, W = map(int, input().split())\nw = \"#\"*(W+2)\nwhite = 0\nS = [w]\nfor _ in range(H):\n    wwww = input()\n    white += wwww.count(\".\")\n    S.append(\"#\"+wwww+\"#\")\nS.append(w)\n\nm = [[10**10]*(W+2) for _ in range(H+2)]\n\nq = deque([[1, 1]])\nd = ((-1, 0), (0, -1), (0, 1), (1, 0))\n\nm[1][1] = 0\n\nwhile q:\n    y, x = q.popleft()\n    p = m[y][x]\n    for dx, dy in d:\n        xx = x + dx\n        yy = y + dy\n        if S[yy][xx] == \"#\":\n            continue\n        if m[yy][xx] > p+1:\n            m[yy][xx] = p+1\n            q.append([yy, xx])\n\nif m[H][W] == 10**10:\n    print(-1)\nelse:\n    print(white-m[H][W]-1)", "from collections import deque\n\ninf = 10**10\n\nh,w = map(int,input().split())\nfield = [input() for _ in range(h)]\n\nlength = [[inf for j in range(w)]for i in range(h)]\nvisited = [[0 for j in range(w)]for i in range(h)]\n\nmove = [[-1,0],[1,0],[0,-1],[0,1]]\n\nque = deque([])\nque.append([0,0])\nlength[0][0] = 0\nvisited[0][0] = 1\n\nwhite = 0\n\nfor i in range(h):\n    white += field[i].count(\".\")\n\nwhile que:\n    y,x = que.popleft()\n\n    for i,j in move:\n        ny,nx = y+i,x+j\n\n        if ny < 0 or ny >= h or nx < 0 or nx >= w:\n            continue\n        elif field[ny][nx] == \"#\":\n            continue\n        elif visited[ny][nx] == 1:\n            continue\n        \n        visited[ny][nx] = 1\n        que.append([ny,nx])\n        length[ny][nx] = length[y][x] + 1\n\nif length[h-1][w-1] == inf:\n    print(-1)\nelse:\n    print(white-(length[h-1][w-1]+1))", "from collections import deque\n\nH, W = [int(x) for x in input().split()]\nboard = []\nfor _ in range(H):\n    board.append(input())\n\nwhite = sum([board[h].count('.') for h in range(H)])\n\ndist = {(x, y):white + 1 for x in range(W) for y in range(H)}\nq = deque([(0, 0)])\ndist[(0, 0)] = 1\nwhile q:\n    x, y = q.popleft()\n    for d in range(4):\n        nx, ny = x + int(((1j)**d).real), y + int(((1j)**d).imag)\n        if nx < 0 or W <= nx or ny < 0 or H <= ny:\n            continue\n        if board[ny][nx] == '#':\n            continue\n        if dist[(nx, ny)] <= white:\n            continue\n        dist[(nx, ny)] = dist[(x, y)] + 1\n        q.append((nx, ny))\n\nlenofpath = dist[(W - 1, H - 1)]\nans = white - lenofpath\nprint(ans)", "#!/usr/bin/env python3\ndef main():\n    from collections import deque\n\n    H, W = list(map(int, input().split()))\n    S = []\n    num_path = 0\n    for _ in range(H):\n        s = input()\n        num_path += s.count('.')\n        S.append(s)\n\n    move = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    distance = [[1] * W for _ in range(H)]\n    queue = deque([(0, 0)])\n    while queue:\n        y, x = queue.popleft()\n        if y == H - 1 and x == W - 1:\n            break\n        for dy, dx in move:\n            ny = y + dy\n            nx = x + dx\n            if (1\n                    and 0 <= ny < H\n                    and 0 <= nx < W\n                    and distance[ny][nx] == 1\n                    and S[ny][nx] == '.'):\n                queue.append((ny, nx))\n                distance[ny][nx] = distance[y][x] + 1\n    if distance[H - 1][W - 1] == 1:\n        print((-1))\n    else:\n        print((num_path - distance[H - 1][W - 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nfrom collections import deque\n\n\ndef main():\n    def input(): return sys.stdin.readline()[:-1]\n    H, W = map(int, input().split())\n\n    graph = [input() for _ in range(H)]\n\n    dist = [[-1] * W for _ in range(H)]\n    queue = deque()\n\n    H -= 1\n    W -= 1\n    \n    # initialize\n    queue.append((0, 0))\n    dist[0][0] = 0\n    cnt = 0\n    for g in graph:\n        cnt += g.count(\".\")\n\n    while queue:\n        vx, vy = queue.popleft()\n\n        if (vx, vy) == (W, H):\n            break\n\n        dxdy = [(1,0), (0, 1), (-1, 0), (0, -1)]\n        for dx, dy in dxdy:\n            if (vx + dx > W) or (vy + dy > H): continue\n            elif (vx + dx < 0) or (vy + dy < 0): continue\n\n            elif graph[vy + dy][vx + dx] == \".\":\n                if dist[vy + dy][vx + dx] == -1:\n                    queue.append((vx + dx, vy + dy))\n                    dist[vy + dy][vx + dx] = dist[vy][vx] + 1\n                    \n\n            elif graph[vy + dy][vx + dx] == \"#\": continue\n            else: continue\n\n    # can't goal\n    if dist[H][W] == -1:\n        print(-1)\n    else:\n        # the number of \".\" - min(dist) - \".\" of start\n        print(cnt - dist[H][W] - 1)\n\ndef __starting_point():\n    main()\n__starting_point()", "H,W = map(int,input().split())\ns = [input() for i in range(H)]\nfrom collections import deque\nm = [[-1]*W for i in range(H)]\nm[0][0] = 0\nd = deque()\nd.append([0,0])\ndx = [1,-1,0,0]\ndy = [0,0,1,-1]\nwhile len(d) > 0:\n    y,x = d.popleft()\n    for i in range(4):\n        ny = y+dy[i]\n        nx = x+dx[i]\n        if 0 <= ny <= H-1 and 0 <= nx <= W-1 and s[ny][nx] == \".\" and m[ny][nx] == -1:\n            m[ny][nx] = m[y][x] + 1\n            d.append([ny,nx])\nans = m[H-1][W-1]\nwhites = -1\nfor i in s:\n    whites += i.count(\".\")\nif ans != -1:\n    ans = whites - ans\nprint(ans)", "H, W = map(int, input().split())\ninf = 101\ns = [''] * H\ncnt = 0\nfor i in range(H):\n\ts[i] = input()\n\tcnt += s[i].count('.')\nd = [[inf] * W for i in range(H)]\nfrom collections import deque\nqueue = deque([[0, 0]])\nd[0][0] = 0\n\nwhile queue:\n\tx, y = queue.popleft()\n\tif x+1 == H and y+1 == W:\n\t\tbreak\n\tdx, dy = [-1, 0, 1, 0], [0, -1, 0, 1]\n\tfor i in range(4):\n\t\tnx, ny = x + dx[i], y + dy[i]\n\t\tif 0 <= nx and nx < H and 0 <= ny and ny < W and s[nx][ny] != '#' and d[nx][ny] == inf:\n\t\t\tqueue.append([nx, ny])\n\t\t\td[nx][ny] = d[x][y] + 1\n\nif d[H-1][W-1] == inf:\n\tprint(-1)\nelse:\n\tprint(cnt-d[H-1][W-1]-1)", "import sys\nh,w=list(map(int,input().split()))\nss=[list(input()) for i in range(h)]\nnum=0\nfor i in range(h):\n    num+=ss[i].count('.')\n\nvisited=[[0 for i in range(w)] for j in range(h)]\nqueue=[]\nqueue.append([0,0])\nss[0][0]='fin'\ndy=[1,0,-1,0]\ndx=[0,1,0,-1]\n\n\nwhile len(queue)>0:\n    now=queue.pop(0)\n    for i in range(4):\n        x= now[1]+dx[i]\n        y= now[0]+dy[i]\n        if 0<=x<w and 0<=y<h :\n            if ss[y][x]=='.' and visited[y][x]==0:\n                visited[y][x]=visited[now[0]][now[1]]+1\n                queue.append([y,x])\n            if x==w-1 and y==h-1:\n                print((num-visited[y][x]-1))\n                return\nprint((-1))\n", "import sys\nsys.setrecursionlimit(10**7)\nfrom collections import deque\n\nH,W=list(map(int,input().split()))\ndots=H*W\nfield=[]\nfor _ in range(H):\n    tmp=input()\n    dots-=tmp.count(\"#\")\n    field.append(tmp)\n\nDX=[1,0,-1,0]\nDY=[0,1,0,-1]\ndist=[[-1]*W for _ in range(H)]\ndist[0][0]=0\nque=deque()\nque.append([0,0])\n\nwhile que:\n    y,x=que.popleft()\n    for dx,dy in zip(DX,DY):\n        nx=x+dx\n        ny=y+dy\n        if nx<0 or nx>=W or ny<0 or ny>=H: continue\n        if field[ny][nx]==\"#\": continue\n        if dist[ny][nx]==-1:\n            dist[ny][nx]=dist[y][x]+1\n            que.append([ny,nx])\n\nscore=-1\ngoal=dist[H-1][W-1]\nif goal!=-1:\n    score=dots-goal-1\nprint(score)\n", "from collections import deque\n\nh, w = map(int, input().split())\ns = [list(input()) for _ in range(h)]\n\nq = deque()\nq.append((0, 0, 0))\ncheck = [[0]*w for _ in range(h)]\n\nflag = False\nwhile q:\n    y, x, d = q.popleft()\n    if y == h-1 and x == w-1:\n        g = d\n        flag = True\n        break\n    if check[y][x] == 0:\n        check[y][x] = 1\n        for xdx, ydy in zip((x, x, x+1, x-1), (y+1, y-1, y, y)):\n            if (0 <= xdx < w) and (0 <= ydy < h):\n                if check[ydy][xdx] == 0 and s[ydy][xdx] == '.':\n                    q.append((ydy, xdx, d+1))\nss = 0\nfor i in s:\n    ss += i.count('#')\nprint(h*w-ss-d-1 if flag else -1)", "from collections import deque\n\n\ndef bfs(start):\n    q = deque([[start]])\n    visited = set()\n    while q:\n        path = q.popleft()\n        i, j = path[-1]\n        if (i, j) == (H - 1, W - 1):\n            return path\n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if (\n                0 <= ni < H\n                and 0 <= nj < W\n                and field[ni][nj] != \"#\"\n                and (ni, nj) not in visited\n            ):\n                q.append(path + [(ni, nj)])\n                visited.add((ni, nj))\n\n\nH, W = list(map(int, input().split()))\nfield = [input() for _ in range(H)]\nshortest_path = bfs((0, 0))\nif shortest_path is None:\n    print((-1))\n    return\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if field[i][j] == \".\" and (i, j) not in shortest_path:\n            ans += 1\nprint(ans)\n", "#\n# abc088 d\n#\nimport sys\nfrom io import StringIO\nimport unittest\nfrom collections import deque\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3 3\n..#\n# ..\n...\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"10 37\n.....................................\n...#...####...####..###...###...###..\n..#.#..#...#.##....#...#.#...#.#...#.\n..#.#..#...#.#.....#...#.#...#.#...#.\n.#...#.#..##.#.....#...#.#.###.#.###.\n.#####.####..#.....#...#..##....##...\n.#...#.#...#.#.....#...#.#...#.#...#.\n.#...#.#...#.##....#...#.#...#.#...#.\n.#...#.####...####..###...###...###..\n.....................................\"\"\"\n        output = \"\"\"209\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    H, W = list(map(int, input().split()))\n    S = [list(input()) for _ in range(H)]\n\n    F = [[-1]*W for _ in range(H)]\n\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n\n    Q = deque()\n    Q.append([0, 0])\n    F[0][0] = 1\n\n    while Q:\n        p = Q.popleft()\n        x, y = p\n\n        if x == W-1 and y == H-1:\n            break\n\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if nx < 0 or nx >= W or ny < 0 or ny >= H or S[ny][nx] == \"#\" or F[ny][nx] != -1:\n                continue\n\n            Q.append([nx, ny])\n            F[ny][nx] = F[y][x] + 1\n\n    if F[H-1][W-1] == -1:\n        print((-1))\n    else:\n        NS = 0\n        for s in S:\n            NS += s.count(\"#\")\n        print((W*H-F[H-1][W-1]-NS))\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "from collections import deque\ndef main():\n    # bfs\n    def _bfs():\n        while q:\n            now = q.popleft()\n            height, width = now[0], now[1]\n            # board[ny][nx] = \n            if height == h-1 and width == w-1:\n                return board[height][width]\n            for i in range(4):\n                ny = height + dy[i]\n                nx = width + dx[i]\n                if 0<= ny < h and 0 <= nx < w and board[ny][nx] == \".\":\n                    q.append((ny, nx))\n                    board[ny][nx] = 1 + board[height][width]\n        return -1\n\n    # input\n    h, w = list(map(int, input().split()))\n    # board creation\n    board = []\n    totalPoints = 0\n    for _ in range(h):\n        row = list(input())\n        # count the number of \".\"s\n        totalPoints += row.count(\".\")\n        board.append(row)\n\n    board[0][0] = 1\n    q = deque([(0, 0)])\n    dy = [0, -1, 0, 1]\n    dx = [1, 0, -1, 0]\n    \n    # print(totalPoints)\n    step = _bfs()\n    # subtrack # of \".\" - the result of bfs as the answer.\n    if step == -1:\n        return -1\n    ans = totalPoints - step\n    return ans\n\n    \ndef __starting_point():\n    print((main()))\n\n__starting_point()", "from collections import deque\nfrom typing import List\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    g = []\n    for _ in range(h):\n        gg = list(input())\n        g.append(gg)\n    print((gr(h, w, g)))\n\n\ndef gr(h: int, w: int, g: List[List[str]]) -> int:\n    m = [[-1] * w for _ in range(h)]\n    q = deque([(0, 0)])\n    m[0][0] = 0\n    while q:\n        x, y = q.popleft()\n        for nx, ny in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\n            if (0 <= nx <= w - 1 and 0 <= ny <= h - 1) and g[ny][nx] == \".\" and m[ny][nx] < 0:\n                m[ny][nx] = m[y][x] + 1\n                if nx == w - 1 and ny == h - 1:\n                    break\n                q.append((nx, ny))\n\n    if m[h - 1][w - 1] < 0:\n        return -1\n    return sum(gg.count(\".\") for gg in g) - m[h - 1][w - 1] - 1\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef bfs(sy,sx):\n  q = deque([[sy,sx]])\n  d[sy][sx] = 0\n  while q:\n    y,x = q.popleft()\n    for i,j in [(-1,0),(1,0),(0,-1),(0,1)]:\n      dy,dx = y+i,x+j\n      if 0<=dy<h and 0<=dx<w:\n        if s[dy][dx] == \"#\": continue\n        if d[dy][dx] != -1: continue\n        d[dy][dx] = d[y][x] + 1\n        q.append([dy,dx])\n\nh,w = map(int, input().split())\ns = [input() for _ in range(h)]\nd = [[-1]*w for _ in range(h)]\nif s[0][0] == \"#\" or s[h-1][w-1] == \"#\":\n  print(-1)\n  return\nbfs(0,0)\nif d[h-1][w-1] == -1: print(-1)\nelse:\n  t = 0\n  for i in range(h): t += s[i].count(\"#\")\n  print(h*w - (t+d[h-1][w-1]+1))", "import sys\n\nH, W = list(map(int, input().split()))\nsx = 0\nsy = 0\ngx = W-1\ngy = H-1\nans = 0\nA = [list(i for i in input()) for _ in range(H)]\nfor j in A:\n    ans += j.count(\".\")\ninf = -1\ndistance = [[inf] * W for _ in range(H)]\nqueue = []\nqueue.insert(0, (sy, sx))\ndistance[sy][sx] = 0\nX = 0\nwhile True:\n    try:\n        y, x = queue.pop()\n        # print(y,x)\n    except:\n        # print(\"Fail\")\n        break\n    for i in range(4):\n        nx = x + (-1, 0, 1, 0)[i]\n        ny = y + (0, -1, 0, 1)[i]\n        # print(\"nynx\",ny,nx)\n        if (0 <= nx and nx <= W-1 and 0 <= ny and ny <= H-1 and A[ny][nx] != '#' and distance[ny][nx] == inf):\n            queue.insert(0, (ny, nx))\n            distance[ny][nx] = distance[y][x] + 1\n            A[ny][nx] = \"!\"\n    # print(queue,\"Q\")\n\nif distance[H-1][W-1] != inf:\n    #print(distance[gy][gx])\n    ans -= distance[gy][gx] + 1\n    print(ans)\nelse:\n    print((-1))\n", "H, W = list(map(int, input().split()))\n# maze = [list(map(int, input().split())) for i in range(H)]\nmaze = []\ns_init_cnt = 0\nfor i in range(H):\n    gyo = list(input())\n    s_init_cnt += gyo.count('.')\n    maze.append(gyo)\n\n#print(maze)\n#print(s_init_cnt)\n\ndirection = [(-1, 0), (0, -1), (1, 0), (0, 1)]\nreached = [[-1] * W for i in range(H)]\nreached[0][0] = 1\nfrom collections import deque\n\n\ndef bfs():\n    d = deque([[0, 0]])\n    while len(d) > 0:\n        px, py = d.popleft()\n        for dx, dy in direction:\n            tx = px + dx\n            ty = py + dy\n            if tx >= H or ty >= W or tx < 0 or ty < 0:\n                continue\n            if reached[tx][ty] != -1 or maze[tx][ty] == '#':\n                continue\n            else:\n                reached[tx][ty] = reached[px][py] + 1\n                d.append([tx, ty])\nbfs()\nans = reached[H-1][W-1]\nif ans == -1:\n    print(ans)\nelse:\n    ans = s_init_cnt - ans\n    print(ans)\n", "from collections import deque\n\nH, W = list(map(int, input().split()))\nC=list(list(input()) for _ in range(H))\n\ndef bfs():\n\tsx, sy= 0, 0\n\tgx, gy= H-1, W-1\n\tdx = [1, 0, -1, 0]\n\tdy = [0, 1, 0, -1]\n\n\twork_queue=deque([])\n\twork_queue.append((sx, sy))\n\tvisited=[[float(\"inf\")]*W for _ in range(H)]\n\tvisited[sx][sy]=1\n\n\twhile work_queue:\n\t\tx, y = work_queue.popleft()\n\n\t\tfor i in range(4):\n\t\t\tnx, ny = x+dx[i], y+dy[i]\n\n\t\t\tif 0<=nx<H and 0<=ny<W and visited[nx][ny]==float(\"inf\") and C[nx][ny]!=\"#\":\n\t\t\t\twork_queue.append((nx, ny))\n\t\t\t\tvisited[nx][ny]= visited[x][y]+1\n\treturn visited[gx][gy]\n\n\ntemp=bfs()\n\nblack=0\nwhite=0\nfor i in range(H):\n\tfor j in range(W):\n\t\tif C[i][j]==\".\":\n\t\t\twhite+=1\n\t\telse:\n\t\t\tblack+=1\n\nif temp==float(\"inf\"):\n\tprint((-1))\nelse:\n\tprint((white-temp))\n\n\n\n\n", "import re\nimport copy\nimport numpy as np\nimport queue\n\ndef accept_input():\n    H,W = list(map(int,input().split()))\n    S = []\n    for _ in range(H):\n        S.append(input())\n    return H,W,S\n\n\ndef widthsearch(q):\n    movelist = [(0,1),(0,-1),(1,0),(-1,0)] \n    while not q.empty():\n        pack = q.get()\n        y = pack[0][0]\n        x = pack[0][1]\n        num = pack[1]\n        if S[y][x] == \"g\":\n            return num\n        for move in movelist:\n            if y+move[0] == -1 or y + move[0] == H or x+move[1] == -1 or x + move[1] == W:\n                continue\n            elif visitedlist[y+move[0]][x+move[1]] == 1:\n                continue\n            elif S[y+move[0]][x+move[1]] == \"#\":\n                continue\n            else:\n                visitedlist[y+move[0]][x+move[1]] = 1\n                q.put(((y+move[0],x+move[1]),num+1))\n    return -1\n\nH,W,S = accept_input()\nfor i in range(len(S)):\n    if i == 0:\n        S[i] = \"s\"+S[i][1:]\n    if i == H-1:\n        S[i] = S[i][:W-1]+\"g\"\nsiro = H*W\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == \"#\":\n            siro -= 1\nq = queue.Queue()\nq.put(((0,0),0))\n#\u5e45\u512a\u5148\u63a2\u7d22\nvisitedlist = np.zeros((H,W))\nvisitedlist[0][0] = 1\nresult = widthsearch(q)\nif result == -1:\n    print((-1))\nelse:\n    print((siro-result-1))\n", "from collections import deque\nh, w = map(int, input().split())\nfield = [input() for _ in range(h)]\nd = [(1, 0), (-1, 0), (0, 1), (0, -1)]\nwhite = 0\nfor i in range(h):\n    white += field[i].count(\".\")\ncnt = [[-1]*w for _ in range(h)]\ncnt[0][0] = 0\nq = deque([[0, 0]])\n\nwhile q:\n    y, x = q.pop()\n    for dy, dx in d:\n        ny = y + dy\n        nx = x + dx\n        if 0 <= ny < h and 0 <= nx < w and field[ny][nx] == \".\" and cnt[ny][nx] < 0:\n            cnt[ny][nx] = cnt[y][x] + 1\n            q.appendleft([ny, nx])\n        if ny == h-1 and nx == w-1:\n            print(white - cnt[h-1][w-1] - 1)\n            return\n\nprint(-1)", "from collections import deque\n\nh, w = map(int, input().split())\ns = [list(input()) for _ in range(h)]\ndots = sum([v.count('.') for v in s])\n\nvisited = [[-1] * w for _ in range(h)]\nq = deque([[0, 0]])\nvisited[0][0] = 1\n\nwhile q:\n    y, x = q.popleft()\n    if y == h - 1 and x == w - 1:\n        break\n    for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n        ny, nx = y + i, x + j\n        if (not 0 <= ny < h) or (not 0 <= nx < w) or s[ny][nx] == '#':\n            continue\n        elif visited[ny][nx] == -1:\n            visited[ny][nx] = visited[y][x] + 1\n            q.append([ny, nx])\nif visited[h - 1][w - 1] != -1:\n    print(dots - visited[h - 1][w - 1])\nelse:\n    print(-1)", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(1000000)\nfrom collections import deque\n\n#\u00a0\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\nH, W = list(map(int, input().split()))\n\n#\u914d\u5217\u306e\u5165\u529b\ns = [list(input()) for _ in range(H)]\n\ndist = [[-1 for _ in range(W)]for _ in range(H)]\n\n\ndef bfs():\n    que = deque()\n    que.append((0, 0))\n    dist[0][0] = 0\n    offset = ((1,0),(-1,0),(0,1),(0,-1))\n    while que:\n        now_h, now_w = que.popleft()\n        if now_h < 0 or H-1 < now_h or now_w < 0 or W-1 < now_w:\n            continue\n        if s[now_h][now_w] == '#':\n            continue\n        for oh, ow in offset:\n            if now_h+oh < 0 or H-1 < now_h+oh or now_w+ow < 0 or W-1 < now_w+ow:\n                continue\n            if dist[now_h+oh][now_w+ow] != -1:\n                continue\n            else:\n                dist[now_h+oh][now_w+ow] = dist[now_h][now_w]+1\n                que.append((now_h+oh, now_w+ow))\n\n\n\n\n\nbfs()\nm = dist[H-1][W-1]\n\nif m == -1:\n    print((-1))\nelse:\n    count = 0\n    for t in s:\n        count += t.count('.')\n    \n    print((count - m- 1))\n\n", "#\u30ad\u30e5\u30fc\u306e\u30af\u30e9\u30b9\nclass Queue:\n    def __init__(self,data = []):\n        self.data = data\n    def enqueue(self,x):\n        self.data.append(x)\n        return self.data\n    def dequeue(self):\n        if len(self.data) == 0:\n            return \"Queue is Empty!\"\n        else:\n            cell = self.data[0]\n            del self.data[0]\n            return self.data\n\nH, W = list(map(int, input().split()))\ns = [list(input()) for i in range(H)]\n#4\u8fd1\u508d\u63a2\u7d22\u306e\u305f\u3081\u306b\u7528\u610f\ndy = [-1, 0, 1, 0]\ndx = [0, 1, 0, -1]\n#\u6700\u5c0f\u8ddd\u96e2\u306e\u30ea\u30b9\u30c8(False\u3067\u521d\u671f\u5316)\nmin_dis = [[False for i in range(W)] for j in range(H)]\nmin_dis[0][0] = 1#\u30b9\u30bf\u30fc\u30c8\u4f4d\u7f6e\u30921\u306b\u3059\u308b(\u6ce8\u610f!!)\n#\u30ad\u30e5\u30fc\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9Q\u4f5c\u6210\nQ = Queue()\nQ.enqueue([0, 0])\n#\u30ad\u30e5\u30fc\u306e\u4e2d\u8eab\u304c\u306a\u304f\u306a\u308b\u307e\u3067\u30eb\u30fc\u30d7\nwhile Q.data:\n    y = Q.data[0][0]\n    x = Q.data[0][1]\n    #4\u8fd1\u508d\u63a2\u7d22\n    for i, j in zip(dy, dx):\n        if  (0 <= y + i < H) and  (0 <= x + j <W) and s[y + i][x + j] == \".\":#\uff08\u7bc4\u56f2\u5185\u306b\u3042\u3063\u305f\u5834\u5408\uff09\u304b\u3064\uff08\u9053\u3060\u3063\u305f\u5834\u5408\uff09\n            if min_dis[y+i][x+j] == False:#\u6700\u5c0f\u8ddd\u96e2\u304cFalse\u3060\u3063\u305f\u5834\u5408\n                min_dis[y+i][x+j] = min_dis[y][x] + 1\n                Q.enqueue([y+i, x+j])#\u5024\u3092\u66f4\u65b0\u3057\u305f\u30de\u30b9\u3092Q\u306b\u30d7\u30c3\u30b7\u30e5\n    Q.dequeue()#\u63a2\u7d22\u3057\u7d42\u308f\u3063\u305f\u30de\u30b9\u3092Q\u304b\u3089\u30d7\u30eb\n\nif not min_dis[H-1][W-1]:\n    print((-1))\n    return\n\n##\u30de\u30b9\u3092\u30ab\u30a6\u30f3\u30c8\nnum_shap = 0\nfor i in range(H):\n    for j in range(W):\n        if s[i][j] == \"#\":\n            num_shap += 1\n#\u30b9\u30b3\u30a2\uff1d\uff08\u5168\u30de\u30b9)-(#\u30de\u30b9)-(g\u3078\u306e\u6700\u77ed\u7d4c\u8def)\nscore = (H*W) - num_shap - (min_dis[H-1][W-1])\nprint(score)\n", "def cal():\n    import queue\n    h, w = list(map(int, input().split()))\n    s = [list(input()) for _ in range(h)]\n    cost = [[-1]*w for _ in range(h)]\n    INF = float('inf')\n    count, ans = 0, INF\n    for i in range(h):\n        for j in range(w):\n            if s[i][j] != '#':\n                cost[i][j] = INF\n            else:\n                count += 1        \n    q = queue.Queue()\n    q.put((0, 0, 1))\n    while not q.empty():\n        c0, c1, c2 = q.get()\n        s[c0][c1] = '#'\n        if c0 == h-1 and c1 == w-1:\n            return h*w-count-c2\n        for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            x, y = c0+i, c1+j\n            if 0 <= x < h and 0 <= y < w:\n                if s[x][y] != '#' and cost[x][y] == INF:\n                    cost[x][y] = c2+1\n                    q.put((x, y, c2+1))\n\n    return ans\n\nans = cal()\nif ans == float('inf'):\n    print((-1))\nelse:\n    print(ans)\n", "from collections import deque\nmove=((-1,0),(1,0),(0,-1),(0,1))\nH,W=map(int,input().split())\nM=[]\nvisited=[ [0]*W for _ in range(H)]\nD=[[0]*W for _ in range(H)]\nblack=0\nfor _ in range(H):\n  s=input()\n  M.append(s)\n  for c in s:\n    if c=='#':\n      black += 1\nq=deque()\nq.append((0,0))\ncost=-1\nwhile q:\n  y,x=q.popleft()\n  d=D[y][x]\n  if x==W-1 and y==H-1:\n    cost=d\n    break\n  if visited[y][x]==1:\n    continue\n  else:\n    visited[y][x] = 1\n    for dx,dy in move:\n      nx,ny=x+dx,y+dy\n      if (0<=nx<W) and (0<=ny<H):                \n        if visited[ny][nx]==0 and M[ny][nx]=='.':\n          D[ny][nx]=d+1\n          q.append((ny,nx))\nif cost==-1:\n  print (-1)\nelse:\n  print (H*W-cost-1-black)", "from collections import*\nH,W=map(int,input().split());M=[input()for _ in\"_\"*H];C=[[1]*W for _ in\"_\"*H];q=deque([[0,0]])\nwhile q:\n  x,y=q.popleft()\n  for i,j in [[1,0],[-1,0],[0,1],[0,-1]]:\n    h,w=x+i,y+j\n    if H>h>-1and W>w>-1and M[h][w]>'#'and C[h][w]<2:C[h][w]=C[x][y]+1;q.append([h,w])\nc=C[H-1][W-1];print(-1*(c<2)or sum(m.count(\".\") for m in M)-c)", "from collections import deque\n\n\ndef main():\n    H, W = list(map(int, input().split()))\n    field = [list(input().rstrip()) for _ in range(H)]\n\n    black = 0\n\n    for f in field:\n        for s in f:\n            if s == \"#\":\n                black += 1\n\n    dir_h = [0, 0, 1, -1]\n    dir_w = [1, -1, 0, 0]\n\n    print((H * W - black - bfs(H, W, field, dir_h, dir_w)))\n\n\ndef bfs(H, W, field, dir_h, dir_w):\n    q = deque([])\n    seen = [[-1 for _ in range(W)] for _ in range(H)]\n\n    q.append([0, 0])\n    seen[0][0] = 1\n\n    while q:\n        h, w = q.popleft()\n\n        for dh, dw in zip(dir_h, dir_w):\n            nh, nw = h + dh, w + dw\n\n            if nh < 0 or nh >= H or nw < 0 or nw >= W:\n                continue\n            elif field[nh][nw] == \"#\":\n                continue\n            elif seen[nh][nw] != -1:\n                continue\n\n            seen[nh][nw] = seen[h][w] + 1\n            q.append([nh, nw])\n\n    if seen[H - 1][W - 1] == -1:\n        print((-1))\n        return\n\n    return seen[H - 1][W - 1]\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nH,W = map(int,input().split())\nC = [list(input()) for i in range(H)]\ncost = [[-1 for i in range(W)] for i in range(H)]\nqueue = []\n\nblack = 0\nfor i in range(H):\n    black += C[i].count('#')\n\nqueue.append([0,0])\ncost[0][0] = 0\n            \ndy_dx = [[1,0],[0,1],[-1,0],[0,-1]]\n\nwhile len(queue) > 0:\n    now = queue.pop(0)\n    if now[0] == H-1 and now[1] == W-1:\n        ans = H*W - cost[H-1][W-1] - black - 1\n        print(ans)\n        return\n    for i in range(4):\n        y = now[0]+dy_dx[i][0]\n        x = now[1]+dy_dx[i][1]\n        if 0 <= y < H and 0 <= x < W:\n            if C[y][x] != '#' and cost[y][x] == -1:\n                cost[y][x] = cost[now[0]][now[1]] + 1\n                queue.append([y,x])     \nprint(-1)", "from collections import deque\n\nh, w = list(map(int, input().split()))\n\ns = [input() for _ in range(h)]\n\nc = 0\n\nfor i in range(h):\n    for j in range(w):\n        if s[i][j] == \"#\":\n            c += 1\n\n#DFS\nq = deque([[0, 0]])\ndist = [[10000] * w for _ in range(h)]\ndist[0][0] = 0\n\nflag = False\n\nwhile len(q) > 0:\n    i, j = q.popleft()\n    if i == h-1 and j == w-1:\n        break\n    else:\n        if i < h-1 and s[i+1][j] == \".\" and not dist[i+1][j] < 10000:\n            q.append([i+1, j])\n            dist[i+1][j] = dist[i][j] + 1\n        if j < w-1 and s[i][j+1] == \".\" and not dist[i][j+1] < 10000:\n            q.append([i, j+1])\n            dist[i][j+1] = dist[i][j] + 1\n        if i > 0 and s[i-1][j] == \".\" and not dist[i-1][j] < 10000:\n            q.append([i-1, j])\n            dist[i-1][j] = dist[i][j] + 1\n        if j > 0 and s[i][j-1] == \".\" and not dist[i][j-1] < 10000:\n            q.append([i, j-1])\n            dist[i][j-1] = dist[i][j] + 1\n\nif dist[h-1][w-1] < 10000:\n    print(h * w - dist[h-1][w-1] - 1 - c)\nelse:\n    print(-1)", "from collections import deque\n\nLOAD = \".\"\n\nH, W = map(int, input().split())\nfield = [[\"\" for _ in range(W)] for _ in range(H)]\ndist = [[-1 for _ in range(W)] for _ in range(H)]\nfor h in range(H):\n    field[h] = list(input())\n\ntotal_laod = 0\nfor f in field:\n    total_laod += f.count(LOAD)\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nsh, sw = (0, 0)\ngh, gw = (H-1, W-1)\ndist[sh][sw] = 0\nq = deque()\nq.append((sh, sw))\n\nwhile q:\n    h, w = q.popleft()\n    for i in range(4):\n        nh = h + dy[i]\n        nw = w + dx[i]\n\n        if nh < 0 or H <= nh or nw < 0 or W <= nw:\n            continue\n        if field[nh][nw] != LOAD:\n            continue\n        if dist[nh][nw] != -1:\n            continue\n\n        dist[nh][nw] = dist[h][w] + 1\n        q.append((nh, nw))\n\nif dist[gh][gw] == -1:\n    print(-1)\nelse:\n    print(total_laod - (dist[gh][gw] + 1))", "import sys\nfrom collections import deque\n\n\ndef IN_I(): return int(sys.stdin.readline().rstrip())\ndef IN_LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef IN_S(): return sys.stdin.readline().rstrip()\ndef IN_LS(): return list(sys.stdin.readline().rstrip().split())\n\n\nH, W = IN_LI()\ns = [IN_S() for _ in range(H)]\n\ndh = [-1, 0, 1, 0]\ndw = [0, -1, 0, 1]\n\ndist = [[-1] * W for j in range(H)]\ndist[0][0] = 0\n\nq = deque()\nq.append([0, 0])\n\nwhile q:\n    now = q.popleft()\n    now_h = now[0]\n    now_w = now[1]\n\n    for i in range(4):\n        next_h = now_h + dh[i]\n        next_w = now_w + dw[i]\n\n        if not (0 <= next_h < H and 0 <= next_w < W):\n            continue\n        if s[next_h][next_w] == '#':\n            continue\n\n        if dist[next_h][next_w] == -1:\n            q.append([next_h, next_w])\n            dist[next_h][next_w] = dist[now_h][now_w] + 1\n\nif dist[-1][-1] == -1:\n    print((-1))\n    return\n\nwhite = sum([i.count('.') for i in s])\nans = white - (dist[-1][-1] + 1)\nprint(ans)\n", "H,W=map(int,input().split())\nS=[list(input())for _ in range(H)]\n\nfrom collections import deque\ndef bfs(h,w,sy,sx,gy,gx,S):\n    maze=[[10**9]*(W)for _ in range(H)]\n    maze[sy-1][sx-1]=0\n    que=deque([[sy-1,sx-1]])\n    while que:\n        y,x=que.popleft()\n        for i,j in [(1,0),(0,1),(-1,0),(0,-1)]:\n            nexty,nextx=y+i,x+j\n            if 0<=nexty<h and 0<=nextx<w:\n                dist1=S[nexty][nextx]\n                dist2=maze[nexty][nextx]\n            else:\n                continue\n            if dist1!='#':\n                if dist2>maze[y][x]+1:\n                    maze[nexty][nextx]=maze[y][x]+1\n                    que.append([nexty,nextx])\n    return maze[gy-1][gx-1]+1\n\nA=0\nfor s in S:\n    A+=s.count('.')\n\nB=bfs(H,W,1,1,H,W,S)\nif B>10**9:\n    ans=-1\nelse:\n    ans=A-B\nprint(ans)", "from collections import deque\n\nR, C = map(int, input().split())\nmasu = [list(input()) for _ in range(R)]\nsr, sc = 0, 0\ngr, gc = R - 1, C - 1\n\ndef bfs():\n    d = [[float(\"inf\")] * C for _ in range(R)]\n    dr = [0, -1, 0, 1]\n    dc = [1, 0, -1, 0]\n    que = deque([])\n\n    que.append((sr, sc))\n    d[sr][sc] = 0\n    while que:\n        p = que.popleft()\n        if p[0] == gr and p[1] == gc:\n            break\n        for i in range(4):\n            nr = p[0] + dr[i]\n            nc = p[1] + dc[i]\n            if (0 <= nr < R) and (0 <= nc < C) and masu[nr][nc] != \"#\" and d[nr][nc] == float(\"inf\"):\n                que.append((nr, nc))\n                d[nr][nc] = d[p[0]][p[1]] + 1\n    \n    return d[gr][gc]\n\nwhite = 0\nfor i in range(R):\n    for j in range(C):\n        if masu[i][j] == \".\":\n            white += 1\n\nres = bfs()\nif 0 < res < float(\"inf\"):\n    print(white - res - 1)\nelse:\n    print(-1)", "import sys\nfrom collections import deque\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\ndef LSH(h):\n    return [list(input()) for _ in range(h)]\n\n\nH, W = LI()\nMAP = LSH(H)\nd = deque()\nd.append([0, 0])\nlooked = [[0 for i in range(W)]for j in range(H)]\nlooked[0][0] = 1\nmove = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nwhile d:\n    x = d.popleft()\n    h = x[0]\n    w = x[1]\n    for i in move:\n        a = h+i[0]\n        b = w+i[1]\n        if not(0 <= a < H) or not(0 <= b < W) or looked[a][b] != 0 or MAP[a][b] == \"#\":\n            continue\n        d.append([a, b])\n        looked[a][b] = looked[h][w]+1\nif looked[H-1][W-1] == 0:\n    print((-1))\n    return\n\nwhite = 0\nfor i in range(H):\n    for j in range(W):\n        if MAP[i][j] == \".\":\n            white += 1\n\nprint((white-looked[H-1][W-1]))\n", "from collections import deque, Counter\n\ndef main():\n    with open(0) as f:\n        H, W = map(int, f.readline().split())\n        maze = [list(line) for line in f.readlines()]\n\n    rank = [[None]*W for _ in range(H)]\n    rank[0][0] = 0\n    #bfs\n    reserved = deque([(0,0)])\n    while len(reserved) > 0:\n        x, y = reserved.popleft()\n        for u,v in [(s,t) for s,t in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)] if 0<=s<H and 0<=t<W]:\n            if rank[u][v] is not None:\n                continue\n            if maze[u][v] == '.':\n                rank[u][v] = rank[x][y] + 1\n                reserved.append((u,v))\n\n    if rank[H-1][W-1] is None:\n        print(-1)\n    else:\n        counter = Counter()\n        for line in maze:\n            counter.update(line)\n        print(counter['.'] - rank[H-1][W-1]-1)\n\nmain()", "from collections import deque\nh,w=list(map(int,input().split()))\nqueue=deque()\ns=[list(input()) for _ in range(h)]\nseen=[[False]*w for _ in range(h)]\nqueue.append([0,0])\nans=[[1000000000]*w for _ in range(h)]\nseen[0][0]=True\nans[0][0]=1\nfor i in range(h*w*10):\n    if len(queue)==0:\n        break\n    cnt=queue.popleft()\n    if cnt[0]!=0:\n        if seen[cnt[0]-1][cnt[1]]==False and s[cnt[0]-1][cnt[1]]==\".\":\n            queue.append([cnt[0]-1,cnt[1]])\n            ans[cnt[0]-1][cnt[1]]=ans[cnt[0]][cnt[1]]+1\n            seen[cnt[0]-1][cnt[1]]=True\n    if cnt[1]!=0:\n        if seen[cnt[0]][cnt[1]-1]==False and s[cnt[0]][cnt[1]-1]==\".\":\n            queue.append([cnt[0],cnt[1]-1])\n            ans[cnt[0]][cnt[1]-1]=ans[cnt[0]][cnt[1]]+1\n            seen[cnt[0]][cnt[1]-1]=True\n    if cnt[0]!=h-1:\n        if seen[cnt[0]+1][cnt[1]]==False and s[cnt[0]+1][cnt[1]]==\".\":\n            queue.append([cnt[0]+1,cnt[1]])\n            ans[cnt[0]+1][cnt[1]]=ans[cnt[0]][cnt[1]]+1\n            seen[cnt[0]+1][cnt[1]]=True\n    if cnt[1]!=w-1:\n        if seen[cnt[0]][cnt[1]+1]==False and s[cnt[0]][cnt[1]+1]==\".\":\n            queue.append([cnt[0],cnt[1]+1])\n            ans[cnt[0]][cnt[1]+1]=ans[cnt[0]][cnt[1]]+1\n            seen[cnt[0]][cnt[1]+1]=True\ncnt2=0\nfor i in range(h):\n    for j in range(w):\n        if s[i][j]==\".\":\n            cnt2+=1\nif seen[-1][-1]==False:\n    print((-1))\nelse:\n    print((cnt2-ans[-1][-1]))\n", "H,W = map(int,input().split())\ns = ['' for i in range(H)]\nwhite = H*W\nblack = 0\nfor i in range(H):\n    s[i] = input()\n    black += s[i].count('#')\nwhite -= black\ndirection = [[1,0],[0,1],[-1,0],[0,-1]]\nq = [[0,0,0]]\n\nmass = [[-1 for i in range(W)] for j in range(H)]\nwhile len(q) > 0:\n    tmp = [y,x,d] = q.pop(0)\n    if mass[y][x] >= 0: \n        continue\n    mass[y][x] = d\n    for [dy,dx] in direction:\n        ny = y + dy\n        nx = x + dx\n        if 0 <= ny and ny < H and 0 <= nx and nx < W:\n            if s[ny][nx] == '#' or mass[ny][nx] >= 0:\n                continue\n            q.append([ny,nx,d+1])\n# for i in mass:\n#     print(i)\nif mass[H-1][W-1] < 0:\n    print(-1)\nelse:\n    print(white - mass[H-1][W-1] - 1)", "from collections import *\nH,W = map(int,input().split())\nS = [(W+2)*[\"#\"]]+list([\"#\"]+list(input())+[\"#\"] for h in range(H))+[(W+2)*[\"#\"]]\nS[1][1] = 1\nQ = deque([[1,1]])\nD = [[1,0],[-1,0],[0,1],[0,-1]]\n\nwhile Q:\n  x,y = Q.popleft()\n  for dx,dy in D:\n    if S[x+dx][y+dy]==\".\":\n      S[x+dx][y+dy] = S[x][y]+1\n      Q.append([x+dx,y+dy])\n\nif S[H][W]==\".\":\n  print(-1)\nelse:\n  print((H+2)*(W+2)-sum(s.count(\"#\") for s in S)-S[H][W])", "from collections import deque\nmove=((-1,0),(1,0),(0,-1),(0,1))\nH,W=map(int,input().split())\nM=['#'*(W+2)]\nblack=0\nfor _ in range(H):\n  row=input()\n  M.append('#'+row+'#')\n  black+=row.count('#')\nM.append('#'*(W+2))\nsy,sx=1,1\ngy,gx=H,W\nD=[[-1]*(W+2) for _ in range(H+2)]\nD[sy][sx]=0\nvisited=set()\nq=deque()\nq.append((sy,sx))\nvisited.add((sy,sx))\nwhile q:\n  y,x=q.popleft()\n  for dy,dx in move:\n    ny,nx=y+dy,x+dx\n    if M[ny][nx]=='#' or D[ny][nx]!=-1:\n      continue\n    D[ny][nx]=D[y][x]+1\n    q.append((ny,nx))\nprint(W*H-(D[gy][gx]+1)-black if D[gy][gx]!=-1 else -1)"]
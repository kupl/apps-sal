["import sys\ninput = sys.stdin.readline\n\nn = int(input())\n\ndef MakeSet(x):\n     x.parent = x\n     x.rank   = 0\n\ndef Union(x, y):\n     xRoot = Find(x)\n     yRoot = Find(y)\n     if xRoot.rank > yRoot.rank:\n         yRoot.parent = xRoot\n     elif xRoot.rank < yRoot.rank:\n         xRoot.parent = yRoot\n     elif xRoot != yRoot:\n         yRoot.parent = xRoot\n         xRoot.rank = xRoot.rank + 1\n\ndef Find(x):\n     if x.parent == x:\n        return x\n     else:\n        x.parent = Find(x.parent)\n        return x.parent\n\nclass Node:\n    def __init__ (self, label):\n        self.label = label\n    def __str__(self):\n        return self.label\n\nused = [0] * 26\nnodes = [Node(ch) for ch in range(26)]\n[MakeSet(node) for node in nodes] \n  \nfor _ in range(n):\n    s = input().strip()\n    prev = -1\n    for c in s:\n        val = ord(c) - 97\n        used[val] = 1\n        if prev != -1:\n            Union(nodes[prev], nodes[val])\n        prev = val\n\nouts = [0] * 26\nfor node in nodes:\n    outs[Find(node).label] += 1\n\ncount = 0\nfor val in outs:\n    if val != 0:\n        count += 1\n\nprint(count + sum(used) - 26)\n        \n", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\np = list(range(n + 26))\n\ndef find(x):\n    if x != p[x]:\n        p[x] = find(p[x])\n    return p[x]\n\nfor i in range(n):\n    for c in set(input().rstrip()):\n        p[find(ord(c) - 97)] = find(26 + i)\n\nprint(sum((p[x] == x) for x in range(26, n + 26)))\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [-1] * n\n        self.cnt = n\n\n    def root(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            if self.parent[x] > self.parent[y]:\n                x, y = y, x\n            self.parent[x] += self.parent[y]\n            self.parent[y] = x\n            self.cnt -= 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return -self.parent[self.root(x)]\n\n    def get_cnt(self):\n        return self.cnt\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = [set(input()) for i in range(n)]\n\ninit_set = set([])\nfor i in range(n):\n    s[i].remove('\\n')\n    init_set |= s[i]\n\nuf = UnionFind(len(init_set))\nto_int = {}\nfor i, char in enumerate(init_set):\n    to_int[char] = i\n\nfor i in range(n):\n    char1 = s[i].pop()\n    for char in s[i]:\n        a, b = to_int[char1], to_int[char]\n        if not uf.is_same(a, b):\n            uf.merge(a, b)\nprint(uf.get_cnt())", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\n#P=[input().strip() for i in range(n)]\n\nGroup = [i for i in range(26)] \nNodes = [1]*(26) \nUSE = [0]*26\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        if Nodes[find(x)] < Nodes[find(y)]:\n            \n            Nodes[find(y)] += Nodes[find(x)]\n            Nodes[find(x)] = 0\n            Group[find(x)] = find(y)\n            \n        else:\n            Nodes[find(x)] += Nodes[find(y)]\n            Nodes[find(y)] = 0\n            Group[find(y)] = find(x)\n\nfor i in range(n):\n    P=input().strip()\n\n    for j in range(1,len(P)):\n        Union(ord(P[j-1])-97,ord(P[j])-97)\n    USE[ord(P[0])-97]=1\n\n#print(USE)\n#print(Group)\n\nSET=set()\nfor i in range(26):\n    if USE[i]==1:\n        SET.add(find(i))\n\nprint(len(SET))\n        \n\n", "import sys\ninput = sys.stdin.readline\n\nm = 26\nuf = [-1]*m\ndef root(x):\n    if uf[x] < 0:\n        return x\n    uf[x] = root(uf[x])\n    return uf[x]\ndef unite(x,y):\n    rx, ry = root(x), root(y)\n    if rx == ry:\n        return False\n    if uf[rx] > uf[ry]:\n        rx, ry = ry, rx\n    uf[rx] += uf[ry]\n    uf[ry] = rx\n    return True\n\nn = int(input())\nused = [0]*m\nfor i in range(n):\n    s = input()[:-1]\n    s = list(set(ord(c)-ord(\"a\") for c in s))\n    l = len(s)\n    for j in range(l):\n        used[s[j]] = 1\n        for k in range(j+1, l):\n            unite(s[j], s[k])\nans = sum(uf[i]<0 and used[i] for i in range(m))\nprint(ans)", "3\n\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    S = [inp() for _ in range(N)]\n    print(solve(N, S))\n\n\nclass Node(object):\n    def __init__(self, v):\n        self.v = v\n        self.p = self\n\n    def union(self, other):\n        r1 = self.find()\n        r2 = other.find()\n        if r1 is not r2:\n            r1.p = r2\n\n    def find(self):\n        r = self\n        while r.p != r:\n            r = r.p\n        n = self\n        while n.p != n:\n            p = n.p\n            n.p = r\n            n = p\n        return r\n\n\ndef solve(N, S):\n    letters = [None] * 26\n    nodes = [Node(i) for i in range(N)]\n    orda = ord('a')\n    for i in range(N):\n        s = S[i]\n        b = [False] * 26\n        for c in s:\n            b[ord(c) - orda] = True\n        for j in range(26):\n            if b[j]:\n                if letters[j] is None:\n                    letters[j] = nodes[i]\n                else:\n                    nodes[i].union(letters[j])\n\n    ns = set()\n    for n in nodes:\n        ns.add(n.find().v)\n    return len(ns)\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind(object):\n    __slots__ = ['nodes']\n\n    def __init__(self, n: int):\n        self.nodes = [-1]*n\n\n    def find(self, x: int) -> int:\n        if self.nodes[x] < 0:\n            return x\n        else:\n            self.nodes[x] = self.find(self.nodes[x])\n            return self.nodes[x]\n\n    def unite(self, x: int, y: int) -> bool:\n        root_x, root_y, nodes = self.find(x), self.find(y), self.nodes\n\n        if root_x != root_y:\n            if nodes[root_x] > nodes[root_y]:\n                root_x, root_y = root_y, root_x\n            nodes[root_x] += nodes[root_y]\n            nodes[root_y] = root_x\n\n        return root_x != root_y\n\n\ndef __starting_point():\n    import sys\n    n = int(input())\n    uf = UnionFind(26 + n)\n    cc_a = ord('a')\n    for i, p in enumerate((l.rstrip() for l in sys.stdin), start=26):\n        for cc in list(map(lambda c: ord(c)-cc_a, set(p))):\n            uf.unite(i, cc)\n\n    ans = sum(1 for i in range(26, 26+n) if uf.nodes[i] < 0)\n    print(ans)\n__starting_point()", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.rank = [0] * n\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def has_same_root(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return self.size[self.root(x)]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\nn = int(input())\npassword = []\nDS = DisjointSet(26)\nseen = set()\norda = ord(\"a\")\nfor i in range(n):\n    password = input().rstrip()\n    if len(password) == 1:\n        seen.add(password)\n        continue\n    for ch1, ch2 in zip(password, password[1:]):\n        DS.unite(ord(ch1) - orda, ord(ch2) - orda)\n        seen.add(ch1)\n        seen.add(ch2)\npars = set()\nfor item in seen:\n    pars.add(DS.root(ord(item) - orda))\nprint(len(pars))", "import sys\n\n\ndef get(p, x):\n    path_x = []\n    while x != p[x]:\n        path_x.append(x)\n        x = p[x]\n    return x, path_x\ndef join(p, rank, x, y):\n    x, path_x = get(p, x)\n    y, path_y = get(p, y)\n\n    if x == y:\n        return False\n    else:\n        if rank[x] > rank[y]:\n            x, y = y, x\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\n        p[x] = y\n        for el in path_x:\n            p[el] = y\n        for el in path_y:\n            p[el] = y\n        return True\n\ndef check(p, x, y):\n    x, path_x = get(p, x)\n    y, path_y = get(p, y)\n\n    for el in path_x:\n        p[el] = x\n    for el in path_y:\n        p[el] = y\n    return x == y\n\ndef get_id(c):\n    return ord(c) - 97\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (s.rstrip() for s in sys.stdin)\n\nn = int(next(reader))\np = list(range(26))\nrank = [0] * 26\nused = set()\nfor _ in range(n):\n    word = next(reader)\n    unq_cs = set(word)\n    used.update(unq_cs)\n    \n    c1 = unq_cs.pop()\n    i1 = get_id(c1)\n    while unq_cs:\n        c2 = unq_cs.pop()\n        i2 = get_id(c2)\n        join(p, rank, i1, i2)\n        \nunq_gr = set()\nfor c in used:\n    gr_id, _ = get(p, get_id(c))\n    unq_gr.add(gr_id)\nprint(len(unq_gr))\n\n# inf.close()\n", "n = int(input())\nused = []\nekv = []\na = []\nfor i in range(n):\n    s = list(input())\n    a.append(s)\na.sort()\n\nj = 1\nt = 0\na.append(\"dsh\")\nr = 0\nfor i in range(n-1):\n    r = 0\n    for k in range(len(a[i])):\n        if a[i][k] in a[i+1]:\n            r = 1\n            break\n    if r == 0:\n        j += 1\n\nprint(j)\n", "import sys\ninput = sys.stdin.readline\n \ndef r1():\n    return int(input())\ndef r2():\n    return list(map(int, input().split()))\n\npred = {}\nsize = {}\nk = 0\n\ndef get_lead(index):\n    if pred[index] == index:\n        return index\n    pred[index] = get_lead(pred[index])\n    return pred[index]\n\ndef merge(a, b, k):\n    pred_a = get_lead(a)\n    pred_b = get_lead(b)\n    if pred_a == pred_b:\n        return k\n    k -= 1\n    if size[pred_a] > size[pred_b]:\n        pred_a, pred_b = pred_b, pred_a\n    pred[pred_a] = pred_b\n    size[pred_b] = max(size[pred_b], size[pred_a] + 1)\n    return k\n\nn = r1()\nfor i in range(n):\n    psw = input()\n    first = psw[0]\n    for item in psw:\n        if item == '\\n':\n            break\n        if item not in pred:\n            pred[item] = item\n            size[item] = 1\n            k += 1\n        k = merge(item, first, k)\nprint(k)\n    \n    \n", "# from sys import stdin\n# def rl():\n#     return [int(w) for w in stdin.readline().split()]\nfrom bisect import bisect_right\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom math import sqrt,factorial,gcd,log2,inf,ceil\n# map(int,input().split())\n# # l = list(map(int,input().split()))\n# from itertools import permutations\nimport sys\ninput = sys.stdin.readline\n\n# t = int(input())\n#\n# for _ in range(t):\n#     a,b,c = map(int,input().split())\n#     a,b,c = sorted([a,b,c])\n#     ans = 0\n#     ans+=b\n#     c-=b\n#\n#     a,c = sorted([a,c])\n#     ans+=a\n#     print(ans)\n\n\n# print(ans)\n\ndef find_parent(u):\n    if par[u]!=u:\n        par[u]=find_parent(par[u])\n    return par[u]\n\n\n\n\nn = int(input())\nla = []\n\nhash = defaultdict(list)\npar = [0]+[i+1 for i in range(26)]\nrank = [1]*(26+1)\nseti = set()\nbooli = [False]*(27)\nfor i in range(n):\n       z = input()\n\n       z = z[:len(z)-1]\n       k = min(z)\n\n       set1 = set(min(k))\n\n       booli[ord(k) - 97 + 1] = True\n\n       a = ord(k) - 97 + 1\n       z2 = find_parent(a)\n       for i in range(len(z)):\n           booli[ord(z[i]) - 97 + 1] = True\n\n\n           if z[i] not in set1 :\n\n             b = ord(z[i]) - 97 + 1\n             z1 = find_parent(b)\n             if z1!=z2:\n               par[z1] = z2\n\n             set1.add(i)\n\nans = set()\n\nfor i in range(26):\n        if booli[i+1] == True:\n           # print(chr(i+98))\n           z = find_parent(i+1)\n           ans.add(z)\n\nprint(len(ans))\n\n\n\n", "import sys\nfrom itertools import combinations as cb\ninput = sys.stdin.readline\n\n\ndef f(u):\n    if u != p[u]:p[u] = f(p[u])\n    return p[u]\n\nN = int(input())\n\np = [0] * 26\nfor i in range(26):\n    p[i] = i\n\nvst = set()\n\nfor i in range(N):\n    t = input().rstrip()\n    al = set()\n    for a in t:\n        k = ord(a) - 97\n        al.add(k)\n        vst.add(k)\n    if len(al) > 1:\n        for u,v in cb(al, 2):\n            if f(u) != f(v):\n                p[f(u)] = p[f(v)]\n\nq = set()\nfor w in vst:\n    q.add(p[f(w)])\n\nprint(len(q))\n", "import sys\nimport string\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef dfs(i,vis,al):\n    vis[i] = True\n    for j in al[i]:\n        if not vis[j]:\n            dfs(j,vis,al)\n\nal = [list() for _ in range(26)]\ngot = set()\nn = int(input())\nfor _ in range(n):\n    s = input()\n    s = set([ord(c)-ord('a') for c in s])\n    s = list(s)\n    for i in range(len(s)):\n        got.add(s[i])\n        for j in range(i+1,len(s)):\n            al[s[i]].append(s[j])\n            al[s[j]].append(s[i])\nvis = [False]*26\n\ncnt = 0\nfor i in range(26):\n    if not vis[i] and i in got:\n        #print(got)\n        dfs(i,vis,al)\n        cnt+=1\nprint(cnt)\n\n\n\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.size = [1] * (n+1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x=None):\n        if x is not None:\n            return self.size[self.find(x)]\n        else:\n            res = set()\n            for i in range(self.n+1):\n                res.add(self.find(i))\n            return len(res) - 1\n\nN = INT()\nA = [input() for i in range(N)]\n\nS = set()\nfor a in A:\n    for c in a:\n        S.add(c)\ntonum = {}\nfor i, c in enumerate(list(S)):\n    tonum[c] = i\n\nuf = UnionFind(len(tonum))\nfor a in A:\n    for i, c in enumerate(a[1:], 1):\n        x = tonum[a[i]]\n        y = tonum[a[i-1]]\n        if not uf.is_same(x, y):\n            uf.union(x, y)\nprint(uf.get_size())\n", "'''input\n3\nab\nbc\nabc\n'''\nfrom sys import stdin, stdout\n\n\nfrom collections import defaultdict, deque\n\n\ndef get_map(password):\n\tmymap  = defaultdict(list)\n\n\tfor i in range(26):\n\t\tfor j in range(len(password)):\n\t\t\tif chr(ord('a') + i) in password[j]:\n\t\t\t\tmymap[chr(ord('a') + i)].append(j)\n\treturn mymap\n\n\n\ndef find_parent(node):\n\tt = node\n\twhile parent[node] != node:\n\t\tnode = parent[node]\n\tparent[t] = node\n\treturn node\n\n# main starts \nn = int(stdin.readline().strip())\npassword = []\nparent = dict()\nfor _ in range(n):\n\tpassword.append(stdin.readline().strip())\n\tparent[_] = _ \n\nmymap = get_map(password)\nfor i in mymap:\n\tfor j in range(1, len(mymap[i])):\n\t\tp1 = find_parent(mymap[i][j - 1])\n\t\tp2 = find_parent(mymap[i][j])\t\n\n\t\tparent[p2] = p1\n\nc = 0\nfor i in parent:\n\tif parent[i]  == i:\n\t\tc += 1\n\nprint(c)\n\n\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import stdin\n\ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\nclass Disjoint_set:\n    class node:\n        def __init__(self, a):\n            self.value = a\n            self.p = self\n            self.rank = 0\n\n    def __init__(self, a):\n        self.data = {i: self.make_set(i) for i in range(1,a+1)}\n\n    def make_set(self, val):\n        return self.node(val)\n\n    def union(self, x, y):\n        self.link(self.find_set(self.data[x]), self.find_set(self.data[y]))\n\n    def link(self, val1, val2):\n        if val1.rank > val2.rank:\n            val2.p = val1\n            val1.rank += 1\n        else:\n            val1.p = val2\n            val2.rank += 1\n\n    def find_set(self, val):\n        if val.p.value != val.value:\n            val.p = self.find_set(val.p)\n        return val.p\n    \n    def solution(self):\n        pr={}\n        parent={}\n        for i in self.data:\n            vl=self.find_set(self.data[i]).value\n            parent[i]=vl\n            if vl in pr:\n                pr[vl]+=1\n            else:\n                pr[vl]=1\n\n        return pr\n\n\n\n# range = xrange\n# input = raw_input\n# print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n\ndef main():\n    n=iin()\n    s=[''.join(list(set(input()))) for i in range(n)]\n    adj=[[] for _ in range(26)]\n    \n    s=list(set(s))\n    l=len(s)\n    for k,i in enumerate(s):\n        for j in i:\n            adj[ord(j)-ord('a')].append(k+1)\n    ds=Disjoint_set(l)\n    #print(s, adj)\n    done=set()\n    for i in range(26):\n        if adj[i]:\n            x=adj[i][0]\n            for j in adj[i]:\n                if x!=j and (x,j) not in done and (j, x) not in done:\n                    ds.union(x, j)\n                    done.add((x, j))\n    sl=ds.solution()\n    print(len(sl))\n\n\n\n\n\n\n    \n\n\n        \n\n\n     \nmain()\n", "import sys\ninput=sys.stdin.readline\nn=int(input())\ndef find(x):\n    if x!=f[x]:\n        f[x]=find(f[x])\n    return f[x]\nf=list(range(n+26))\nfor i in range(0,n):\n\tfor j in set(input().rstrip()):\n\t\tf[find(ord(j)-97)]=find(i+26)\nans=0\nfor i in range(26,n+26):\n\tif f[i]==i:\n\t\tans+=1\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\n#lines = stdin.readlines()\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n')\n\ndef oint():\n    return int(input())\n\nn = oint()\n\nnode = dict()\nfor _ in range(n):\n    s = set(input())\n    for c1 in s:\n        if not c1 in node:\n            node[c1] = s\n        else:\n            node[c1] = node[c1].union(s)\nv = set()\ndef dfs(k):\n    if k in v:\n        return\n    v.add(k)\n    for kk in node[k]:\n        if not kk in v:\n            dfs(kk)\n    return\nans = 0\nfor k in node:\n    if k in v:\n        continue\n    ans += 1\n    dfs(k)\n\nprint(ans)\n\n\n", "from collections import *\nfrom functools import reduce\nimport sys\ninput = sys.stdin.readline\n\ndef factors(n):    \n    return set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input())\nl = []\nfor i in range(val()):\n    l.append(st())\nl.sort(key = lambda x:len(set(x)),reverse = 1)\nd = {}\ntot = len(l)\nfor i in l:\n    curr = []\n    do = 1\n    for j in set(i):\n        if j in d and do:\n            tot -= 1\n            do = 0\n        curr.append(j)\n    for j in curr:d[j] = 1\ncurrans = tot\nl.sort()\nd = {}\ntot = len(l)\nfor i in l:\n    curr = []\n    do = 1\n    for j in set(i):\n        if j in d and do:\n            tot -= 1\n            do = 0\n        curr.append(j)\n    for j in curr:d[j] = 1\nprint(min(currans,tot))\n", "import sys\ninput=sys.stdin.readline\nn=int(input())\nf=[]\nd=[]\nfor i in range(0,26):\n\td.append([0]*26)\nuse=[0]*26\nfor i in range(0,26):\n\tf.append(i)\ndef find(x):\n\tif x!=f[x]:\n\t\tf[x]=find(f[x])\n\treturn f[x]\nfor i in range(0,n):\n\tl=[]\n\tfor j in set(input().rstrip()):\n\t\tuse[ord(j)-97]=1\n\t\tl.append(ord(j)-97)\n\tll=len(l)\n\tfor k in range(0,ll):\n\t\tfor j in range(k+1,ll):\n\t\t\td[l[k]][l[j]]=1\nfor i in range(0,26):\n\tfor j in range(0,26):\n\t\tif d[i][j]:\n\t\t\tif find(i)!=find(j):\n\t\t\t\tf[find(i)]=find(j)\nans=[]\na=0\nfor i in range(0,26):\n\tif use[i]==1 and find(i) not in ans:\n\t\tans.append(find(i))\n\t\ta+=1\nprint(a)"]
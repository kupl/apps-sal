["def dfs(v, x, y, t, l, pr):\n    ans[v] = x, y\n    nx = [(l, 0), (0, -l), (-l, 0), (0, l)]\n    if t == 0: p = 0, 1, 3\n    if t == 1: p = 0, 1, 2\n    if t == 2: p = 1, 2, 3\n    if t == 3: p = 0, 2, 3\n    listv = [u for u in g[v] if u != pr]\n    g[v] = listv[:]\n    for i in range(min(len(p), len(g[v]))):\n        dx = nx[p[i]][0]\n        dy = nx[p[i]][1]\n        newx = x + dx\n        newy = y + dy\n        u = g[v][i]\n        dfs(u, newx, newy, p[i], l // 4, v)\n\nread = lambda: map(int, input().split())\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    u, v = read()\n    g[u].append(v)\n    g[v].append(u)\ndef fail():\n    print('NO')\n    return\nroot = 1\nfor i in range(n + 1):\n    if len(g[i]) > 4:\n        fail()\n    if len(g[i]) > len(g[root]):\n        root = i\nans = [0] * (n + 1)\nans[root] = (0, 0)\ninf = 10 ** 18\nl = inf // 4\nnx = [(l, 0), (0, -l), (-l, 0), (0, l)]\nfor i in range(len(g[root])):\n    dx = nx[i][0]\n    dy = nx[i][1]\n    newx = 0 + dx\n    newy = 0 + dy    \n    dfs(g[root][i], newx, newy, i, l // 4, root)\nprint('YES')\n[print(*i) for i in ans[1:]]", "def main():\n\tn = int(input())\n\tgraph = [[] for i in range(n)]\n\tans = [(0,0)] * n\n\t\n\tfor _ in range(n - 1):\n\t\tu, v = [int(el) for el in input().split()]\n\t\tu -= 1\n\t\tv -= 1\n\t\tgraph[u].append(v)\n\t\tgraph[v].append(u)\n\t\n\tfor l in graph:\n\t\tif len(l) > 4:\n\t\t\tprint('NO')\n\t\t\treturn\n\t\n\tstep = 1 << 28\n\t\n\tused = [False] * n\n\tdef dfs(v, direction, step, koord):\n\t\tused[v] = True\n\t\tif direction == 'u':\n\t\t\tmy_koord = (koord[0] + step, koord[1])\n\t\t\tdirs = ['u', 'l', 'r']\n\t\telif direction == 'd':\n\t\t\tmy_koord = (koord[0] - step, koord[1])\n\t\t\tdirs = ['d', 'l', 'r']\n\t\telif direction == 'l':\n\t\t\tmy_koord = (koord[0], koord[1] - step)\n\t\t\tdirs = ['u', 'd', 'l']\n\t\telif direction == 'r':\n\t\t\tmy_koord = (koord[0], koord[1] + step)\n\t\t\tdirs = ['u', 'd', 'r']\n\t\telif direction == '':\n\t\t\tmy_koord = (0, 0)\n\t\t\tdirs = ['u', 'd', 'l', 'r']\n\t\t\n\t\tans[v] = my_koord\n\t\t\n\t\td = 0\n\t\tfor u in graph[v]:\n\t\t\tif not used[u]:\n\t\t\t\tdfs(u, dirs[d], step >> 1, my_koord)\n\t\t\t\td += 1\n\t\n\tdfs(0, '', step, (0, 0))\n\t\n\tprint('YES')\n\tfor k in ans:\n\t\tprint(k[0], k[1])\n\t\nmain()", "def dfs(v, x, y, t, l, pr):\n    ans[v] = x, y\n    p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n    g[v] = [u for u in g[v] if u != pr]\n    for i in range(min(len(p), len(g[v]))):\n        newx = x + nx[p[i]][0] * l\n        newy = y + nx[p[i]][1] * l\n        dfs(g[v][i], newx, newy, p[i], l // 4, v)\n\nread = lambda: map(int, input().split())\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    u, v = read()\n    g[u].append(v)\n    g[v].append(u)\nroot = 1\nfor i in range(n + 1):\n    if len(g[i]) > 4:\n        print('NO')\n        return\nans = [0] * (n + 1)\nans[root] = 0, 0\ninf = 10 ** 18\nl = inf // 4\nnx = (1, 0), (0, -1), (-1, 0), (0, 1)\nfor i in range(len(g[root])):\n    dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\nprint('YES')\n[print(*i) for i in ans[1:]]", "def dfs(v, x, y, t, l, pr):\n    ans[v] = x, y\n    p = [(0, 1, 3), (0, 1, 2), (1, 2, 3), (0, 2, 3)][t]\n    g[v] = [u for u in g[v] if u != pr]\n    for i in range(min(len(p), len(g[v]))):\n        newx = x + nx[p[i]][0] * l\n        newy = y + nx[p[i]][1] * l\n        dfs(g[v][i], newx, newy, p[i], l // 4, v)\n\nread = lambda: map(int, input().split())\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    u, v = read()\n    g[u].append(v)\n    g[v].append(u)\nroot = 1\nfor i in range(n + 1):\n    if len(g[i]) > 4:\n        print('NO')\n        return\nans = [0] * (n + 1)\nans[root] = 0, 0\ninf = 10 ** 18\nl = inf // 4\nnx = (1, 0), (0, -1), (-1, 0), (0, 1)\nfor i in range(len(g[root])):\n    dfs(g[root][i], nx[i][0] * l, nx[i][1] * l, i, l // 4, root)\nprint('YES')\n[print(*i) for i in ans[1:]]", "#!/usr/bin/env python3\nfrom collections import *\ndef ri():\n    return list(map(int, input().split()))\n\n\nd = [[1,0], [0, 1], [-1, 0], [0, -1]]\n\ndef bfs(s, adj, v, l):\n    if v[s] == 1:\n        return 0\n    q = deque()\n    q.append(s)\n    v[s] = 1\n    while q:\n        n = q.popleft()\n        for a in adj[n]:\n            if v[a] == 0:\n                for i in range(4):\n                    if dv[n][i] == 0:\n                        dv[n][i] = 1\n                        break\n                pos[a][0] = pos[n][0] + d[i][0]*2**(31-l[n])\n                pos[a][1] = pos[n][1] + d[i][1]*2**(31-l[n])\n                if i == 0:\n                    dv[a][2] = 1\n                elif i == 1:\n                    dv[a][3] = 1\n                elif i == 2:\n                    dv[a][0] = 1\n                elif i == 3:\n                    dv[a][1] = 1\n                l[a] = l[n] + 1\n                q.append(a)\n                v[a] = 1\n\n\nn = int(input())\nadj = [set() for i in range(n)]\nv = [0 for i in range(n)]\nl = [0 for i in range(n)]\ndv = [[0,0,0,0] for i in range(n)]\npos = [[0, 0] for i in range(n)]\n\nfor i in range(n-1):\n    a, b = ri()\n    a -= 1\n    b -= 1\n    adj[a].add(b)\n    adj[b].add(a)\n\nfor i in range(n):\n    if len(adj[i]) > 4:\n        print(\"NO\")\n        return\n\nbfs(0, adj, v, l)\n\nprint(\"YES\")\nfor i in range(n):\n    print(pos[i][0], pos[i][1])\n\n", "n = int(input())\np = [set() for i in range(n)]\nfor k in range(n - 1):\n    u, v = map(int, input().split())\n    p[u - 1].add(v - 1)\n    p[v - 1].add(u - 1)\n\ns = [(0, 0)] * n\nt = [(0, 1 << 30, 7)]\nl = [1, 0, -1, 0, 1]\n\nwhile t:\n    u, d, j = t.pop()\n    x, y = s[u]\n    i = 0\n    for v in p[u]:\n        if i == j: i += 1\n        if i > 3: print('NO');return\n        p[v].remove(u)\n        s[v] = (x + l[i] * d, y + l[i + 1] * d)\n        t.append((v, d >> 1, (i + 2) % 4))\n        i += 1\n\nprint('YES')\nfor x, y in s: print(x, y)", "from collections import deque\n\nn = int(input())\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ngr = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    a, b = [int(i) for i in input().split()]\n    a -= 1\n    b -= 1\n    gr[a].append(b)\n    gr[b].append(a)\nfor i in range(n):\n    if len(gr[i]) > 4:\n        print(\"NO\")\n        return\nprint(\"YES\")\nd = deque()\nd.append((0, 10 ** 18 // 2, 10 ** 18 // 2, -1, -1, 50))\nans = [0] * n\nwhile len(d) > 0:\n    v = d[0][0]\n    x = d[0][1]\n    y = d[0][2]\n    ans[v] = (d[0][1], d[0][2])\n    p = d[0][4]\n    dr = d[0][3]\n    pw = d[0][5]\n    d.popleft()\n    if p != -1:\n        gr[v].pop(gr[v].index(p))\n    cur = 0\n    for i in range(4):\n        if i == dr:\n            continue\n        if cur == len(gr[v]):\n            break\n        ngh = gr[v][cur]\n        d.append((ngh, x + 2 ** pw * dx[i], y + 2 ** pw * dy[i], (i + 2) % 4, v, pw - 1))\n        cur += 1\nfor i in ans:\n    print(*i)", "n = int(input())\nadj = [[] for _ in range(n)]\n\nfor _ in range(n - 1):\n    u, v = list(map(int, input().split()))\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\n\nfrom collections import deque\ndef bfs(v):\n    vis = [i == v for i in range(n)]\n    paths = deque([[v]])\n\n    while paths:\n        p = paths.popleft()\n        for nv in adj[p[-1]]:\n            if not vis[nv]:\n                vis[nv] = True\n                paths.append(p + [nv]) \n\n    return p\n\ndiameter = bfs(0)\ndiameter = bfs(diameter[-1])\np = diameter[len(diameter) // 2]\n\nstart = (0, 0)\nmove = [(0, 1), (1, 0), (0, -1), (-1, 0)]\ngpt = lambda pt, i, dis : (pt[0] + move[i][0] * dis, pt[1] + move[i][1] * dis)\n\nvis = [False] * n\ndis = 2 ** (len(diameter) + 1)\n\nans = [0] * n\nq = deque([(p, start, -1, dis)])\n\nwhile q:\n    p, start, dr, dis = q.popleft()\n    vis[p] = True\n    ans[p] = start\n\n    if len(adj[p]) > 4:\n        print(\"NO\")\n        return\n    \n    if dr == -1:\n        drs = [i for i in range(4)]\n    else:\n        drs = [i for i in range(4) if gpt(move[i], dr, 1) != (0, 0)]\n\n    for nv in adj[p]:       \n        if not vis[nv]:\n            vis[nv], dr = True, drs.pop()\n            npt = gpt(start, dr, dis)\n            q.append((nv, npt, dr, dis // 2))\n            ans[nv] = npt\n\nprint(\"YES\")\nfor pt in ans:\n    print(*pt)\n\n\n\n", "#https://codeforces.com/problemset/problem/761/E\ndef solve():\n    def push(u, v, g):\n        if u not in g:\n            g[u] = []\n        if v not in g:\n            g[v] = []    \n        g[u].append(v)\n        g[v].append(u)\n        \n    n = int(input())\n    g = {}\n    \n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        push(u, v, g)\n    \n    for u in g:\n        if len(g[u]) > 4:\n            return 'NO', None\n    d = {}    \n    build(1, 0, 0, 0, 31, -1, d, g)\n    s = ''\n    for u in range(1, n+1):\n        x, y = d[u]\n        s += str(x) + ' ' + str(y)\n        s += '\\n'\n    return 'YES', s\n\ndef cal_pos(dir_, cur_x, cur_y, cur_base):\n    if dir_   == 0:\n        return cur_x, cur_y + (1<<cur_base)\n    elif dir_ == 1:\n        return cur_x + (1<<cur_base), cur_y\n    elif dir_ == 2:\n        return cur_x, cur_y - (1<<cur_base)\n    else:\n        return cur_x - (1<<cur_base), cur_y\n        \ndef build(u, p, cur_x, cur_y, cur_base, pre_dir, d, g):\n    d[u]  = [cur_x, cur_y]\n    type_ = [0,1,2,3]\n        \n    if pre_dir in type_:\n        type_.remove(pre_dir)\n    \n    if u in g:\n        for v in g[u]:\n            if v != p:\n                dir_ = type_.pop() \n                \n                next_x, next_y =  cal_pos(dir_, cur_x, cur_y, cur_base)    \n                build(v, u, next_x, next_y, cur_base-1, (dir_ - 2)%4, d, g)\n                \nans ,s = solve()\nif ans == 'NO':\n    print(ans)\nelse:    \n    print(ans)\n    print(s)"]
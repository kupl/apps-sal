["def read_data():\n    n, m = map(int, input().split())\n    maze = [[False] * (m + 2)]\n    for i in range(n):\n        maze.append([False] + [c == '.' for c in input().rstrip()] + [False])\n    maze.append([False] * (m + 2))\n    r1, c1 = map(int, input().split())\n    r2, c2 = map(int, input().split())\n    return n, m, maze, r1, c1, r2, c2\n\n\ndef solve(n, m, maze, r1, c1, r2, c2):\n    dots = count_surrounding_intact_ices(maze, r2, c2)\n    if maze[r2][c2] == False:\n        if r1 == r2 and c1 == c2:\n            return dots >= 1\n        else:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n    else:\n        if dots >= 2:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n        if dots == 0:\n            return False\n        if dots == 1:\n            return is_side_by_side(r1, c1, r2, c2)\n\n\ndef is_side_by_side(r1, c1, r2, c2):\n    if r1 == r2:\n        return abs(c1 - c2) == 1\n    if c1 == c2:\n        return abs(r1 - r2) == 1\n    return False\n\n\ndef count_surrounding_intact_ices(maze, r, c):\n    count = 0\n    for rr, cc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n        if maze[rr][cc]:\n            count += 1\n    return count\n\ndef solve_wfs(n, m, maze, r1, c1, r2, c2):\n    frontier = [(r1, c1)]\n    while frontier:\n        new_frontier = []\n        for r, c in frontier:\n            for nr, nc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n                if nr == r2 and nc == c2:\n                    return True\n                if not maze[nr][nc]:\n                    continue\n                maze[nr][nc] = False\n                new_frontier.append((nr, nc))\n        frontier = new_frontier\n    return False\n\ndef __starting_point():\n    n, m, maze, r1, c1, r2, c2 = read_data()\n    if solve(n, m, maze, r1, c1, r2, c2):\n        print('YES')\n    else:\n        print('NO')\n__starting_point()", "n, m = (int(x) for x in input().split())\nmp = [[\"\"]] * n\nfor i in range(n):\n    mp[i] = list(input().strip())\n\nx0, y0 = (int(x) for x in input().split())\nx0 -= 1\ny0 -= 1\nx1, y1 = (int(x) for x in input().split())\nx1 -= 1\ny1 -= 1\n\ndef gen_neighbours(x, y):\n    res = []\n    if x > 0:\n        res.append((x-1, y))\n    if x < n - 1:\n        res.append((x+1, y))\n    if y > 0:\n        res.append((x, y - 1))\n    if y < m - 1:\n        res.append((x, y + 1))\n    return res\n\ncnt = 0\nfor el in gen_neighbours(x1, y1):\n    if mp[el[0]][el[1]] == '.' or el == (x0, y0):\n        cnt += 1\n\n\nif x0 == x1 and y0 == y1:\n    if cnt > 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    return\n\nif mp[x1][y1] == \".\" and cnt <= 1:\n    print(\"NO\")\n    return\n\nind = 0\nend = 1\nq = [0] * (n * m * 2)\nq[0] = (x0, y0)\n\nwhile True:\n    if ind == len(q) or q[ind] == 0:\n        break\n\n    x, y = q[ind]\n    if (x, y) == (x1, y1):\n        print(\"YES\")\n        return\n\n    for el in gen_neighbours(x, y):\n        if el == (x1, y1):\n            print(\"YES\")\n            return\n\n        if mp[el[0]][el[1]] == '.':\n            q[end] = el\n            end += 1\n            mp[el[0]][el[1]] = 'X'\n    ind += 1\n\nprint(\"NO\")", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef test(x):\n    if x == 'X' or type(x)== int:\n        return False\n    return True\n\n\n\n(n, m) = ( int(i) for i in input().split())\nmap = []\n\nfor i in range(n):\n    map.append([i for i in input()])\n\nfor i in map:\n    while ' ' in i:\n        i.remove(' ')\n\n\n(r1, c1) = ( int(i) for i in input().split())\n(r2, c2) = ( int(i) for i in input().split())\n\nstep = 0\nmap[r1-1][c1-1] = 0\n\nif (map[r2-1][c2-1] == 'X'):\n    flag = 0\n    map[r2-1][c2-1] = '.'\nelse:\n    flag = 1\n\nnow = [(r1-1, c1-1)]\n\nwhile (type(map[r2-1][c2-1]) != int and now != []):\n    now_new = []\n    for (i, j) in now:\n        if ( i > 0 ) :\n            if test(map[i-1][j]) :\n                map[i-1][j]= step+1\n                now_new.append((i-1, j))\n        if ( i < n-1 ) :\n            if test(map[i+1][j]) :\n                map[i+1][j]= step+1\n                now_new.append((i+1, j))\n\n        if ( j > 0  ) :\n            if test(map[i][j-1]) :\n                map[i][j-1]= step+1\n                now_new.append((i, j-1))\n\n        if ( j < m-1 ) :\n            if test(map[i][j+1]) :\n                map[i][j+1]= step+1\n                now_new.append((i, j+1))\n\n    now = now_new\n    step = step + 1\n\nif (type(map[r2-1][c2-1]) != int):\n    print(\"NO\")\n\nelse:\n    if flag == 0:\n        print(\"YES\")\n    else:\n        acc = 0\n        acc1 = 0\n        i = r2-1\n        j = c2-1\n\n        if ( i > 0 ) :\n            if type(map[i-1][j]) == int:\n                acc1 +=1\n            elif map[i-1][j] != 'X' :\n                acc += 1\n\n        if ( i < n-1 ) :\n            if type(map[i+1][j]) == int:\n                acc1 +=1\n            elif map[i+1][j] != 'X' :\n                acc += 1\n\n        if ( j > 0  ) :\n            if type(map[i][j-1]) == int :\n                acc1 +=1\n            elif map[i][j-1] != 'X' :\n                acc += 1\n\n        if ( j < m-1 ) :\n            if type(map[i][j+1]) == int:\n                acc1 +=1\n            elif map[i][j+1] != 'X' :\n                acc += 1\n\n\n\n        if (acc == 0 and acc1 < 2):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n", "def read_data():\n    n, m = map(int, input().split())\n    maze = [[False] * (m + 2)]\n    for i in range(n):\n        maze.append([False] + [c == '.' for c in input().rstrip()] + [False])\n    maze.append([False] * (m + 2))\n    r1, c1 = map(int, input().split())\n    r2, c2 = map(int, input().split())\n    return n, m, maze, r1, c1, r2, c2\n\n\ndef solve(n, m, maze, r1, c1, r2, c2):\n    dots = count_surrounding_intact_ices(maze, r2, c2)\n    if maze[r2][c2] == False:\n        if r1 == r2 and c1 == c2:\n            return dots >= 1\n        else:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n    else:\n        if dots >= 2:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n        if dots == 0:\n            return False\n        if dots == 1:\n            return is_side_by_side(r1, c1, r2, c2)\n\n\ndef is_side_by_side(r1, c1, r2, c2):\n    if r1 == r2:\n        return abs(c1 - c2) == 1\n    if c1 == c2:\n        return abs(r1 - r2) == 1\n    return False\n\n\ndef count_surrounding_intact_ices(maze, r, c):\n    count = 0\n    for rr, cc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n        if maze[rr][cc]:\n            count += 1\n    return count\n\ndef solve_wfs(n, m, maze, r1, c1, r2, c2):\n    frontier = [(r1, c1)]\n    while frontier:\n        new_frontier = []\n        for r, c in frontier:\n            for nr, nc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n                if nr == r2 and nc == c2:\n                    return True\n                if not maze[nr][nc]:\n                    continue\n                maze[nr][nc] = False\n                new_frontier.append((nr, nc))\n        frontier = new_frontier\n    return False\n\ndef __starting_point():\n    n, m, maze, r1, c1, r2, c2 = read_data()\n    if solve(n, m, maze, r1, c1, r2, c2):\n        print('YES')\n    else:\n        print('NO')\n__starting_point()", "#file = open('test.txt', 'r')\ndef recurse():\n\tnonlocal ans\n\tqu = []\n\tqu.append((r1, c1))\n\tcount = 1\n\ti = 0\n\twhile i < count:\n\t\tr, c = qu[i]\n\t\tif r == r2 and c == c2:\n\t\t\tans = True\n\t\t\treturn\n\t\t\n\t\tmas[r][c] = 1\n\t\t\t\n\t\tif mas[r + 1][c] == 0:\n\t\t\t#recurse(r + 1, c)\n\t\t\tqu.append((r + 1, c))\n\t\t\tmas[r + 1][c] = 1\n\t\t\tcount += 1\n\t\tif mas[r - 1][c] == 0:\n\t\t\t#recurse(r - 1, c)\n\t\t\tqu.append((r - 1, c))\n\t\t\tmas[r - 1][c] = 1\n\t\t\tcount += 1\n\t\tif mas[r][c + 1] == 0:\n\t\t\t#recurse(r, c + 1)\n\t\t\tqu.append((r, c + 1))\n\t\t\tmas[r][c + 1] = 1\n\t\t\tcount += 1\n\t\tif mas[r][c - 1] == 0:\n\t\t\t#recurse(r, c - 1)\n\t\t\tqu.append((r, c - 1))\n\t\t\tmas[r][c - 1] = 1\n\t\t\tcount += 1\n\t\ti += 1\n\nn, m = [int(x) for x in input().split()]\n#n, m = [int(x) for x in file.readline().split()]\nmas = []\nmas.append([-1] * (m + 2))\nfor i in range(1, n + 1):\n\tmas.append([0] * (m + 2))\nmas.append([-1] * (m + 2))\n\nfor i in range(1, n + 1):\n\tmas[i][0] = mas[i][m + 1] = -1\n\nfor i in range(1, n + 1):\t\n\ts = input()\n\t#s = file.readline()\n\tfor j in range(1, m + 1):\n\t\tif s[j - 1] == 'X':\n\t\t\tmas[i][j] = -1\n\nr1, c1 = [int(x) for x in input().split()]\nr2, c2 = [int(x) for x in input().split()]\n#r1, c1 = [int(x) for x in file.readline().split()]\n#r2, c2 = [int(x) for x in file.readline().split()]\n\nher = 0\nif mas[r2 - 1][c2] != -1:\n\ther += 1\nif mas[r2 + 1][c2] != -1:\n\ther += 1\nif mas[r2][c2 - 1] != -1:\n\ther += 1\nif mas[r2][c2 + 1] != -1:\n\ther += 1\nif r1 == r2 and c1 == c2:\n\tif her > 0:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\nelif abs(r1 - r2) + abs(c1 - c2) == 1:\n\tif mas[r2][c2] != 0 or her > 0:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\nelse:\n\tans = False\n\tz = mas[r2][c2]\n\tmas[r1][c1] = mas[r2][c2] = 0\n\trecurse()\n\t#mas[r2][c2] = z\n\tif not ans:\n\t\tprint(\"NO\")\n\telif z != 0:\n\t\tprint(\"YES\")\n\telse:\n\t\tif her > 1:\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")", "row, col = (int(x) for x in input().split())\n\nmatrix = [['X' for i in range(col + 2)]]\nfor _ in range(row):\n\tmatrix.append(['X'] + [str(x) for x in input()] + ['X'])\nmatrix.append(['X' for i in range(col + 2)])\n\nstartR, startC = (int(x) for x in input().split())\nendR, endC = (int(x) for x in input().split())\n\ndef search_way(matrix, startR, startC, endR, endC):\n\tcountToEnd = 0\n\tdx = [0, 0, -1, 1]\n\tdy = [1, -1, 0, 0]\n\tfor i in range(len(dx)):\n\t\tif matrix[endR + dx[i]][endC + dy[i]] == '.':\n\t\t\tcountToEnd += 1\n\tif endR == startR and endC == startC:\n\t\tif matrix[endR][endC] == 'X' and countToEnd < 1:\n\t\t\treturn \"NO\"\n\t\telif matrix[endR][endC] == 'X':\n\t\t\treturn \"YES\"\n\t\n\tif countToEnd < 2 and matrix[endR][endC] == '.':\n\t\t# print(\"Count To End!!\")\n\t\tif countToEnd == 1 and abs(endR - startR) + abs(endC - startC) == 1:\n\t\t\treturn \"YES\"\n\t\treturn \"NO\"\n\tmatrix[endR][endC] = '.'\n\tqueue = [(startR, startC),]\n\twhile len(queue) >= 1:\n\t\tcurValue = queue.pop(-1)\n\t\tif curValue[0] == endR and curValue[1] == endC:\n\t\t\treturn \"YES\"\n\t\t# print(curValue)\n\t\tfor i in range(len(dx)):\n\t\t\tif matrix[curValue[0] + dx[i]][curValue[1] + dy[i]] == '.':\n\t\t\t\tmatrix[curValue[0] + dx[i]][curValue[1] + dy[i]] = 'X'\n\t\t\t\tqueue.append((curValue[0] + dx[i], curValue[1] + dy[i]))\n\t# for i in range(len(matrix)):\n\t# \tprint(matrix[i])\n\treturn \"NO\"\n\nprint(search_way(matrix, startR, startC, endR, endC))", "def isConnected(r1, c1, r2, c2, board) :\n    visited = [[0]*c for i in range(r)]\n    Q = [[r1, c1]]\n    visited[r1][c1] = 1\n    while Q :\n        q = Q.pop(0)\n        x,y = q[0],q[1]\n        for i in range(4) :\n            new_x = x+dx[i]\n            new_y = y+dy[i]\n            if 0<= new_x < r and 0<= new_y < c and visited[new_x][new_y] == 0 and board[new_x][new_y] == '.' :\n                visited[new_x][new_y] = 1\n                Q.append([new_x, new_y])\n                if new_x == r2 and new_y == c2 : return True\n    return False\n\ndx = [-1, 0, 0, 1]\ndy = [0, -1, 1, 0]\n\nr,c = list(map(int, input().split()))\nboard = [list(input()) for i in range(r)]\nr1, c1 = list(map(int, input().split()))\nr2, c2 = list(map(int, input().split()))\nr1-=1;c1-=1;r2-=1;c2-=1\nisX = board[r2][c2] == 'X'\nG = []\n\nfor i in range(4) :\n    x = r2 + dx[i]\n    y = c2 + dy[i]\n    if x >=0 and x < r and y >= 0 and y < c and board[x][y] == '.' :\n        G.append([x,y])\nif abs(r1-r2) + abs(c1-c2) == 1 :\n    if board[r2][c2] == 'X' :\n        print(\"YES\")\n    else :\n        if len(G) > 0 :\n            print(\"YES\")\n        else :\n            print(\"NO\")\nelif r1 == r2 and c1 == c2 :\n    if len(G) == 0 :\n        print(\"NO\")\n    else :\n        print(\"YES\")\nelif len(G) == 0 :\n    print(\"NO\")\nelse :\n    if board[r2][c2] == 'X' :\n        board[r2][c2] = '.'\n        if isConnected(r1, c1, r2, c2, board) :\n            print(\"YES\")\n        else :\n            print(\"NO\")\n    else :\n        if len(G) < 2 :\n            print(\"NO\")\n        else :\n            if isConnected(r1, c1, r2, c2, board) :\n                print(\"YES\")\n            else :\n                print(\"NO\")\n", "def pick(D, v):\n\treturn D[v[0]][v[1]]\n\n\ndef getNeighbours(A, x, y, t='.'):\n\tneighbours = []\n\tif x > 0 and A[x-1][y] == t:\n\t\tneighbours.append((x-1, y))\n\tif y > 0 and A[x][y-1] == t:\n\t\tneighbours.append((x, y-1))\n\tif x < len(A)-1 and A[x+1][y] == t:\n\t\tneighbours.append((x+1, y))\n\tif y < len(A[0])-1 and A[x][y+1] == t:\n\t\tneighbours.append((x, y+1))\n\treturn neighbours\n\n\ndef countNeighbours(A, x, y, t='.'):\n\treturn len(getNeighbours(A, x, y, t))\n\n\ndef hasPath(A, xs, ys, xe, ye):\n\t# Pre-set end-location 'dot'\n\tA[xe][ye] = '.'\n\n\tD = [[-1 for _ in range(len(A[0]))] for _ in range(len(A))]\n\tD[xs][ys] = 0\n\tQ = [(xs, ys)]\n\n\t# BFS\n\twhile len(Q) > 0:\n\t\tu = Q.pop()\n\t\tfor v in getNeighbours(A, *u):\n\t\t\tif pick(D, v) == -1:\n\t\t\t\tQ.insert(0, v)\n\t\t\t\tD[v[0]][v[1]] = pick(D, u) + 1\n\n\treturn D[xe][ye] != -1\n\n\ndef solve(A, r1, c1, r2, c2):\n\tif r1 == r2 and c1 == c2:\n\t\tif countNeighbours(A, r1, c1) > 0:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telif (r2, c2) in getNeighbours(A, r1, c1) or (r2, c2) in getNeighbours(A, r1, c1, 'X'):\n\t\tif A[r2][c2] == 'X':\n\t\t\treturn True\n\t\telse:\n\t\t\tif countNeighbours(A, r2, c2) > 0:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\telif A[r2][c2] == '.':\n\t\tif countNeighbours(A, r2, c2) >= 2 and hasPath(A, r1, c1, r2, c2):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telif A[r2][c2] == 'X':\n\t\tif countNeighbours(A, r2, c2) > 0 and hasPath(A, r1, c1, r2, c2):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\ndef main():\n\tn, m = list(map(int, input().split()))\n\tA = [list(input()) for _ in range(n)]\n\tr1, c1 = [int(w)-1 for w in input().split()]\n\tr2, c2 = [int(w)-1 for w in input().split()]\n\n\tans = solve(A, r1, c1, r2, c2)\n\tprint('YES' if ans else 'NO')\n\nmain()\n", "def pick(D, v):\n\treturn D[v[0]][v[1]]\n\n\ndef getNeighbours(A, x, y, t='.'):\n\tneighbours = []\n\tif x > 0 and A[x-1][y] == t:\n\t\tneighbours.append((x-1, y))\n\tif y > 0 and A[x][y-1] == t:\n\t\tneighbours.append((x, y-1))\n\tif x < len(A)-1 and A[x+1][y] == t:\n\t\tneighbours.append((x+1, y))\n\tif y < len(A[0])-1 and A[x][y+1] == t:\n\t\tneighbours.append((x, y+1))\n\treturn neighbours\n\n\ndef countNeighbours(A, x, y, t='.'):\n\treturn len(getNeighbours(A, x, y, t))\n\n\ndef hasPath(A, xs, ys, xe, ye):\n\t# Pre-set end-location 'dot'\n\tA[xe][ye] = '.'\n\n\tD = [[-1 for _ in range(len(A[0]))] for _ in range(len(A))]\n\tD[xs][ys] = 0\n\tQ = [(xs, ys)]\n\n\t# BFS\n\twhile len(Q) > 0:\n\t\tu = Q.pop()\n\t\tfor v in getNeighbours(A, *u):\n\t\t\tif pick(D, v) == -1:\n\t\t\t\tQ.insert(0, v)\n\t\t\t\tD[v[0]][v[1]] = pick(D, u) + 1\n\n\treturn D[xe][ye] != -1\n\n\ndef solve(A, r1, c1, r2, c2):\n\tif r1 == r2 and c1 == c2:\n\t\tif countNeighbours(A, r1, c1) > 0:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telif (r2, c2) in getNeighbours(A, r1, c1) or (r2, c2) in getNeighbours(A, r1, c1, 'X'):\n\t\tif A[r2][c2] == 'X':\n\t\t\treturn True\n\t\telse:\n\t\t\tif countNeighbours(A, r2, c2) > 0:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\telif A[r2][c2] == '.':\n\t\tif countNeighbours(A, r2, c2) >= 2 and hasPath(A, r1, c1, r2, c2):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\telif A[r2][c2] == 'X':\n\t\tif countNeighbours(A, r2, c2) > 0 and hasPath(A, r1, c1, r2, c2):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\ndef main():\n\tn, m = list(map(int, input().split()))\n\tA = [list(input()) for _ in range(n)]\n\tr1, c1 = [int(w)-1 for w in input().split()]\n\tr2, c2 = [int(w)-1 for w in input().split()]\n\n\tans = solve(A, r1, c1, r2, c2)\n\tprint('YES' if ans else 'NO')\n\nmain()\n", "# -*- coding: utf-8 -*-\n\n\"\"\"\ncreated by huash06 at 2015-05-18 23:20\n\n\n\"\"\"\n\n__author__ = 'huash06'\n\nimport sys\nimport os\nimport itertools\nimport collections\nimport functools\nimport bisect\nimport datetime\n\n\n\nDELTA = [(1, 0 ), (-1, 0), (0, -1), (0, 1)]\n\ndef existsPath(board, sr, sc, er, ec):\n    visited = {(sr, sc)}\n    q = [(sr, sc)]\n    while q:\n        r, c = q.pop(0)\n\n        for d in DELTA:\n            nr = r + d[0]\n            nc = c + d[1]\n            if nr == er and nc == ec:\n                return True\n            if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited and board[nr][nc] == '.':\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    return False\n\ndef isNeighbor(sr, sc, er, ec):\n    for d in DELTA:\n        r = sr + d[0]\n        c = sc + d[1]\n        if r == er and c == ec:\n            return True\n    return False\n\nN, M = list(map(int, input().split()))\n\nboard = []\nfor i in range(N):\n    board.append([x for x in input()])\n\nsr, sc = list(map(int, input().split()))\ner, ec = list(map(int, input().split()))\n\nsr -= 1\nsc -= 1\ner -= 1\nec -= 1\n\n\nif board[er][ec] == 'X':\n    if existsPath(board, sr, sc, er, ec):\n        print('YES')\n    else:\n        print('NO')\nelse:\n    itactNeighbor = 0\n    for d in DELTA:\n        r = er + d[0]\n        c = ec + d[1]\n        if 0 <= r < N and 0 <= c < M and board[r][c] == '.':\n            itactNeighbor += 1\n\n    if itactNeighbor > 1:\n        if existsPath(board, sr, sc, er, ec):\n            print('YES')\n        else:\n            print('NO')\n    else:\n        if itactNeighbor == 1 and isNeighbor(sr, sc, er, ec):\n            print('YES')\n        else:\n            print('NO')\n\n\n\n", "n,m=[int(x) for x in input().split()]\ninp=[input() for i in range(n)]\nsource=[int(x)-1 for x in input().split()]\ndest=[int(x)-1 for x in input().split()]\n\ndef valid(x):\n\treturn True if 0<=x[0]<n and 0<=x[1]<m and inp[x[0]][x[1]]=='.' else False\n\ndef getn(x):\n\ttoret=[]\n\ty=(x[0]-1,x[1])\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0]+1,x[1])\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0],x[1]-1)\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0],x[1]+1)\n\tif valid(y):\n\t\ttoret.append(y)\n\treturn toret\n\nif source==dest:\n\tprint('YES' if len(getn(dest)) else 'NO')\nelse:\n\tdat=False\n\tdis=0\n\tif inp[dest[0]][dest[1]]=='X':\n\t\tinp[dest[0]]=inp[dest[0]][:dest[1]]+'.'+inp[dest[0]][dest[1]+1:]\n\t\tdat=True\n\tif tuple(dest) in getn(source):\n\t\tdis=1\n\tvis=[[False]*m for i in range(n)]\n\tmystak=[source]\n\twhile mystak!=[]:\n\t\tx=mystak.pop()\n\t\tif vis[x[0]][x[1]]:\n\t\t\tcontinue\n\t\tvis[x[0]][x[1]]=True\n\t\tfor i in getn(x):\n\t\t\tmystak.append(i)\n#\tfor i in vis:\n#\t\tprint(i)\n\tprint('YES' if vis[dest[0]][dest[1]] and (len(getn(dest))>1-dis or dat) else 'NO')\n", "n,m=[int(x) for x in input().split()]\ninp=[input() for i in range(n)]\nsource=[int(x)-1 for x in input().split()]\ndest=[int(x)-1 for x in input().split()]\n\ndef valid(x):\n\treturn True if 0<=x[0]<n and 0<=x[1]<m and inp[x[0]][x[1]]=='.' else False\n\ndef getn(x):\n\ttoret=[]\n\ty=(x[0]-1,x[1])\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0]+1,x[1])\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0],x[1]-1)\n\tif valid(y):\n\t\ttoret.append(y)\n\ty=(x[0],x[1]+1)\n\tif valid(y):\n\t\ttoret.append(y)\n\treturn toret\n\nif source==dest:\n\tprint('YES' if len(getn(dest)) else 'NO')\nelse:\n\tdat=False\n\tdis=0\n\tif inp[dest[0]][dest[1]]=='X':\n\t\tinp[dest[0]]=inp[dest[0]][:dest[1]]+'.'+inp[dest[0]][dest[1]+1:]\n\t\tdat=True\n\tif tuple(dest) in getn(source):\n\t\tdis=1\n\tvis=[[False]*m for i in range(n)]\n\tmystak=[source]\n\twhile mystak!=[]:\n\t\tx=mystak.pop()\n\t\tif vis[x[0]][x[1]]:\n\t\t\tcontinue\n\t\tvis[x[0]][x[1]]=True\n\t\tfor i in getn(x):\n\t\t\tmystak.append(i)\n#\tfor i in vis:\n#\t\tprint(i)\n\tprint('YES' if vis[dest[0]][dest[1]] and (len(getn(dest))>1-dis or dat) else 'NO')\n", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef bfs(x, y):\n    q = [(y, x)]\n    \n    while q:\n        x = q[0][1]\n        y = q[0][0]\n        q.pop(0)\n        if (x-1 > -1) and (g[y][x-1] == '.'):\n            g[y][x-1] = 'X'\n            q.append((y, x-1))\n        if (x+1 < m) and (g[y][x+1] == '.'):\n            g[y][x+1] = 'X'\n            q.append((y, x+1))\n        if (y-1 > -1) and (g[y-1][x] == '.'):\n            g[y-1][x] = 'X'\n            q.append((y-1, x))\n        if (y+1 < n) and (g[y+1][x] == '.'):\n            g[y+1][x] = 'X'\n            q.append((y+1, x))\n            \n            \nn, m = map(int, input().split())\ng = [['']*m for i in range(n)]\nfor i in range(n):\n    t = input()\n    for j in range(m):\n        g[i][j] = t[j]\n\ny, x = map(int, input().split())\nb, a = map(int, input().split())\nx -= 1\ny -= 1\na -= 1\nb -= 1\n    \nif (x == a) and (y == b):  # \u0435\u0441\u043b\u0438 \u043d\u0430\u0447\u0430\u043b\u043e \u0438 \u043a\u043e\u043d\u0435\u0446 \u043f\u0443\u0442\u0438 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442\n    if ((x-1 > -1) and (g[y][x-1] == '.')) or ((x+1 < m) and (g[y][x+1] == '.')) or ((y-1 > -1) and (g[y-1][x] == '.')) or ((y+1 < n) and (g[y+1][x] == '.')):\n        print('YES')\n    else:\n        print('NO')\n        \nelse:  # \u0435\u0441\u043b\u0438 \u0444\u0438\u043d\u0438\u0448\u043d\u0430\u044f \u043a\u043b\u0435\u0442\u043a\u0430 \u0442\u0440\u0435\u0441\u043d\u0443\u0432\u0448\u0430\u044f \u0438\u043b\u0438 \u0443 \u043d\u0435\u0435 \u0435\u0441\u0442\u044c \u0446\u0435\u043b\u044b\u0435 \u0441\u043e\u0441\u0435\u0434\u0438\n    f = False\n    if g[b][a] == '.':\n        f = True\n        \n    one = (a-1 > -1) and (g[b][a-1] == '.')\n    two = (a+1 < m) and (g[b][a+1] == '.')\n    three = (b-1 > -1) and (g[b-1][a] == '.')\n    four = (b+1 < n) and (g[b+1][a] == '.')\n\n    g[b][a] = '.'\n    bfs(x, y)\n    \n    if g[b][a] == 'X':\n        if f:\n            if one+two+three+four > 1:\n                print('YES')\n            elif (((a == x-1) and (b == y)) or ((a == x+1) and (b == y)) or ((a == x) and (b == y-1)) or ((a == x) and (b == y+1))) and (one+two+three+four == 1):\n                print('YES')\n            else:\n                print('NO')\n        else:\n            print('YES')\n    else:\n        print('NO')", "from collections import deque\nds = ((1, 0), (0, 1), (-1, 0), (0, -1))\nn, m = list(map(int, input().split()))\na = [list(input()) for _ in range(n)]\nsi, sj = tuple(map(int, input().split()))\nti, tj = tuple(map(int, input().split()))\nsi -= 1\nsj -= 1\nti -= 1\ntj -= 1\n\ndef count_ok(i, j):\n    r = 0\n    for di, dj in ds:\n        ni, nj = i + di, j + dj\n        if (0 <= ni < n and 0 <= nj < m and a[ni][nj] != 'X') \\\n           or (ni, nj) == (si, sj):\n            r += 1\n    return r\n\nif (si, sj) == (ti, tj):\n    print('YES' if count_ok(si, sj) >= 1 else 'NO')\n    return\n\nc = a[ti][tj]\na[ti][tj] = '.'\nused = set()\nq = deque()\nused.add((si, sj))\nq.append((si, sj))\nwhile q:\n    i, j = q.popleft()\n    for di, dj in ds:\n        ni, nj = i + di, j + dj\n        if 0 <= ni  < n and 0 <= nj < m and\\\n           a[ni][nj] != 'X' and (ni, nj) not in used:\n            used.add((ni, nj))\n            q.append((ni, nj))\nif (ti, tj) not in used:\n    print('NO')\nelse:\n    if c == 'X':\n        print('YES')\n    else:\n        print('YES' if count_ok(ti, tj) >= 2 else 'NO')\n\n          \n        \n", "n,m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append([])\nfor i in range(n):\n    c = input()\n    for j in c:\n        if (j == '.'):\n            a[i].append(0)\n        else:\n            a[i].append(1)\nx1,y1 = map(int,input().split())\nx2,y2 = map(int,input().split())\nx1 -= 1\ny1 -= 1\nx2 -= 1\ny2 -= 1\na[x1][y1] = 0\nf = []\nqs = 0\nqt = 1\nf.append([x1,y1])\nwhile (qs < qt):\n    x = f[qs][0]\n    y = f[qs][1]\n    if ([x,y] == [x2,y2]):\n        break\n    a[x][y] = 1\n    qs += 1\n    if (x < n-1 and (a[x+1][y] == 0 or [x+1,y] == [x2,y2])):\n        qt += 1\n        f.append([x+1,y])\n        if ([x+1,y] == [x2,y2]):\n            break;\n        a[x+1][y] += 2\n    if (x > 0 and (a[x-1][y] == 0 or [x-1,y] == [x2,y2])):\n        qt += 1\n        f.append([x-1,y])\n        if ([x-1,y] == [x2,y2]):\n            break;\n        a[x-1][y] += 2\n    if (y < m-1 and (a[x][y+1] == 0 or [x,y+1] == [x2,y2])):\n        qt += 1\n        f.append([x,y+1])\n        if ([x,y+1] == [x2,y2]):\n            break;\n        a[x][y+1] += 2\n    if (y > 0 and (a[x][y-1] == 0 or [x,y-1] == [x2,y2])):\n        qt += 1\n        f.append([x,y-1])\n        if ([x,y-1] == [x2,y2]):\n            break;\n        a[x][y-1] += 2\nelse:\n    print('NO')\n    return\nif (a[x2][y2] == 1):\n    print('YES')\nelse:\n    #print(a[x2-1][y2],a[x2][y2-1])\n    if (x2 > 0 and a[x2-1][y2] != 1):\n        print('YES')\n    elif (x2 < n-1 and a[x2+1][y2] != 1):\n        print('YES')\n    elif (y2 < m-1 and a[x2][y2+1] != 1):\n        print('YES')\n    elif (y2 > 0 and a[x2][y2-1] != 1):\n        print('YES')\n    else:\n        print('NO')", "import heapq\nfrom copy import deepcopy\ndir = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\ndef decr(x): return x - 1\n\nH, W = list(map(int, input().split()))\nl = [list(input()) for i in range(H)]\nsi, sj = list(map(decr, list(map(int, input().split()))))\ngi, gj = list(map(decr, list(map(int, input().split()))))\n\nque = []\nheapq.heappush(que, (si, sj))\nres = False\nwhile len(que):\n    i, j = heapq.heappop(que)\n    for k in range(4):\n        ni = i + dir[k][0]\n        nj = j + dir[k][1]\n        if ni == gi and nj == gj and l[ni][nj] == 'X':\n            res = True\n        if 0 <= ni < H and 0 <= nj < W and l[ni][nj] == '.':\n            l[ni][nj] = 'X'\n            heapq.heappush(que, (ni, nj))\n\n\nif res:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "3\nfrom collections import deque\ndef dfs ():\n  while(len(queue)!=0):\n    s=queue.popleft()\n    (i,j)=s\n    for (ni,nj) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:      \n      if ni in range(0,n) and nj in range(0,m):\n        fl=data[ni][nj]\n        if(e == (ni,nj)) and fl==\"X\":\n          return True\n        elif fl == \".\":\n          data[ni][nj] = \"X\"\n          queue.append((ni,nj))\n  return False\n[n,m]=list(map(int,(input().split())))\ndata=list()\nfor i in range(0,n):\n  data.append(list([x for x in input()]))\n[si,sj]=list(map(int,(input().split())))\n[ei,ej]=list(map(int,(input().split())))\ne=(ei-1,ej-1)\nqueue=deque()\nqueue.append((si-1,sj-1))\nprint(\"YES\" if dfs() else \"NO\")  \n", "3\nfrom collections import deque\nfrom array import array\ndef dfs ():\n  while(len(queue)!=0):\n    s=queue.popleft()\n    (i,j)=s\n    for (ni,nj) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:      \n      if ni in range(0,n) and nj in range(0,m):\n        c=ni*m+nj\n        fl=data[c]\n        if(e == (ni,nj)) and fl==1:\n          return True\n        elif fl == 0:\n          data[c] = 1\n          queue.append((ni,nj))\n  return False\n[n,m]=list(map(int,(input().split())))\ndata=array('B')\nfor i in range(0,n):\n  data.extend([0 if x=='.' else 1 for x in input()])\n[si,sj]=list(map(int,(input().split())))\n[ei,ej]=list(map(int,(input().split())))\ne=(ei-1,ej-1)\nqueue=deque()\nqueue.append((si-1,sj-1))\nprint(\"YES\" if dfs() else \"NO\")  \n", "n, m = [int(x) for x in input().split()]\nvisited = [[True for i in range(m+2)]]\nvisited += [[True]+[False if c == '.' else True for c in input()]+[True] for i in range(n)]\nvisited += [[True for i in range(m+2)]]\nstart = tuple(int(x) for x in input().split())\nfinish = tuple(int(x) for x in input().split())\nvisited[start[0]][start[1]] = False\n\ndef neighbours(p):\n    return ((p[0]+1,p[1]), (p[0],p[1]+1), (p[0]-1,p[1]), (p[0],p[1]-1))\ngates = [p for p in neighbours(finish) if not visited[p[0]][p[1]]]\n\ndef DFS(p, gates):\n    stack = [p]\n    while stack:\n        node = stack.pop()\n        if node in gates: return True\n        x,y = node\n        if visited[x][y]: continue\n        visited[x][y] = True\n        stack.extend(neighbours(node))\n    return False\n\nif finish == start and len(gates) > 0:\n    print('YES')\nelif not visited[finish[0]][finish[1]] and len(gates) < 2 or len(gates) == 0:\n    print('NO')\nelse:\n    print('YES' if DFS(start, gates) else 'NO')\n\n\n", "def main():\n    n, m = list(map(int, input().split()))\n    nm = n * m\n    neigh = [[] for _ in range(nm)]\n    for i in range(0, nm - m, m):\n        for j in range(i, i + m):\n            neigh[j].append(j + m)\n            neigh[j + m].append(j)\n    for i in range(0, nm, m):\n        for j in range(i, i + m - 1):\n            neigh[j].append(j + 1)\n            neigh[j + 1].append(j)\n    field = [c == '.' for _ in range(n) for c in input()]\n    l = []\n    for _ in (0, 1):\n        i, j = list(map(int, input().split()))\n        l.append(i * m + j - m - 1)\n    start, stop = l\n    if start == stop:\n        print((\"NO\", \"YES\")[any(field[_] for _ in neigh[stop])])\n        return\n    field[start] = True\n    if field[stop] and sum(field[_] for _ in neigh[stop]) < 2:\n        print(\"NO\")\n        return\n    nxt, field[stop] = (start,), True\n    while nxt:\n        cur, nxt = nxt, []\n        for u in cur:\n            if u == stop:\n                print(\"YES\")\n                return\n            for v in neigh[u]:\n                if field[v]:\n                    field[v] = False\n                    nxt.append(v)\n    print(\"NO\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    nm = n * m\n    neigh = [[] for _ in range(nm)]\n    for i in range(0, nm - m, m):\n        for j in range(i, i + m):\n            neigh[j].append(j + m)\n            neigh[j + m].append(j)\n    for i in range(0, nm, m):\n        for j in range(i, i + m - 1):\n            neigh[j].append(j + 1)\n            neigh[j + 1].append(j)\n    field = [c == '.' for _ in range(n) for c in input()]\n    l = []\n    for _ in (0, 1):\n        i, j = list(map(int, input().split()))\n        l.append(i * m + j - m - 1)\n    start, stop = l\n    if start == stop:\n        print((\"NO\", \"YES\")[any(field[_] for _ in neigh[stop])])\n        return\n    field[start] = True\n    if field[stop] and sum(field[_] for _ in neigh[stop]) < 2:\n        print(\"NO\")\n        return\n    nxt, field[stop] = (start,), True\n    while nxt:\n        cur, nxt = nxt, set()\n        for u in cur:\n            if u == stop:\n                print(\"YES\")\n                return\n            for v in neigh[u]:\n                if field[v]:\n                    field[v] = False\n                    nxt.add(v)\n    print(\"NO\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from http.cookiejar import reach\n\ndef is_path_exist( cage,visited,i1, j1, i2, j2):\n    dx=[0,0,-1,1]\n    dy=[-1,1,0,0]\n    temp_point=[]\n    reached=False\n    stk_adj=[]\n    stk_adj.append([i1,j1])\n    cage[i1][j1]='X'\n    while(len(stk_adj) and not reached):\n        temp_point=stk_adj.pop()\n        for i in range(0,4):\n            if ((temp_point[0] + dx[i] > -1 and temp_point[0] + dx[i] < len(cage))\n                and (temp_point[1] + dy[i] > -1 and temp_point[1] + dy[i] < len(cage[0]))\n                and visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] == False):\n                    if (temp_point[0] + dx[i] == i2 and temp_point[1] + dy[i] == j2):\n                        reached=True\n                        break\n                    if (cage[temp_point[0] + dx[i]][temp_point[1] + dy[i]] != 'X'):\n                        visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] = True;\n                        stk_adj.append([temp_point[0]+dx[i],temp_point[1]+dy[i]])\n    return reached\n\ndx=[0,0,-1,1]\ndy=[-1,1,0,0]\nnumbers = list(map(int, input().split()))\nn=int(numbers[0])\nm=int(numbers[1])\ntemp_line=\"\"\ncage=[]\nvisited=[[False for x in range(m)]for y in range(n)]\nfor i in range(0,n):\n    cage.append([])\n    temp_line=input()\n    for j in range(0,m):\n        cage[i].append(temp_line[j])\nnumbers = list(map(int, input().split()))\ni1=int(numbers[0]-1)\nj1=int(numbers[1]-1)\nnumbers = list(map(int, input().split()))\ni2=int(numbers[0]-1)\nj2=int(numbers[1]-1)\npos=0\nif(is_path_exist(cage, visited, i1, j1, i2, j2)):\n    if(cage[i2][j2]=='X'):\n        print('YES')\n        pos=1\n    if(pos==0):\n        count=0\n        for i in range(0,4):\n            if (i2 + dx[i] > -1 and i2 + dx[i] < len(cage) and j2 + dy[i] > -1 and j2 + dy[i] < len(cage[0])\n                        and (cage[i2 + dx[i]][j2 + dy[i]] == '.' or (i2 + dx[i] == i1 and j2 + dy[i] == j1)) ):\n                count+=1\n        if(count>1):\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')\n\n\n\n\n", "\ndef is_path_exist( cage,visited,i1, j1, i2, j2):\n    dx=[0,0,-1,1]\n    dy=[-1,1,0,0]\n    temp_point=[]\n    reached=False\n    stk_adj=[]\n    stk_adj.append([i1,j1])\n    cage[i1][j1]='X'\n    while(len(stk_adj) and not reached):\n        temp_point=stk_adj.pop()\n        for i in range(0,4):\n            if ((temp_point[0] + dx[i] > -1 and temp_point[0] + dx[i] < len(cage))\n                and (temp_point[1] + dy[i] > -1 and temp_point[1] + dy[i] < len(cage[0]))\n                and visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] == False):\n                    if (temp_point[0] + dx[i] == i2 and temp_point[1] + dy[i] == j2):\n                        reached=True\n                        break\n                    if (cage[temp_point[0] + dx[i]][temp_point[1] + dy[i]] != 'X'):\n                        visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] = True;\n                        stk_adj.append([temp_point[0]+dx[i],temp_point[1]+dy[i]])\n    return reached\n\ndx=[0,0,-1,1]\ndy=[-1,1,0,0]\nnumbers = list(map(int, input().split()))\nn=int(numbers[0])\nm=int(numbers[1])\ntemp_line=\"\"\ncage=[]\n\nvisited=[[False]*m for _ in range(n) ]\nfor i in range(0,n):\n    cage.append([])\n    temp_line=input()\n    for j in range(0,m):\n        cage[i].append(temp_line[j])\nnumbers = list(map(int, input().split()))\ni1=int(numbers[0]-1)\nj1=int(numbers[1]-1)\nnumbers = list(map(int, input().split()))\ni2=int(numbers[0]-1)\nj2=int(numbers[1]-1)\npos=0\nif(is_path_exist(cage, visited, i1, j1, i2, j2)):\n    if(cage[i2][j2]=='X'):\n        print('YES')\n        pos=1\n    if(pos==0):\n        count=0\n        for i in range(0,4):\n            if (i2 + dx[i] > -1 and i2 + dx[i] < len(cage) and j2 + dy[i] > -1 and j2 + dy[i] < len(cage[0])\n                        and (cage[i2 + dx[i]][j2 + dy[i]] == '.' or (i2 + dx[i] == i1 and j2 + dy[i] == j1)) ):\n                count+=1\n        if(count>1):\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')\n\n\n\n\n", "from http.cookiejar import reach\n#import numpy\ndef is_path_exist( cage,visited,i1, j1, i2, j2):\n    dx=[0,0,-1,1]\n    dy=[-1,1,0,0]\n    temp_point=[]\n    reached=False\n    stk_adj=[]\n    stk_adj.append([i1,j1])\n    #cage[i1][j1]='X'\n    while(len(stk_adj) and not reached):\n        temp_point=stk_adj.pop()\n        for i in range(0,4):\n            if ((temp_point[0] + dx[i] > -1 and temp_point[0] + dx[i] < len(cage))\n                and (temp_point[1] + dy[i] > -1 and temp_point[1] + dy[i] < len(cage[0]))\n                and visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] == False):\n                    if (temp_point[0] + dx[i] == i2 and temp_point[1] + dy[i] == j2):\n                        reached=True\n                        break\n                    if (cage[temp_point[0] + dx[i]][temp_point[1] + dy[i]] != 'X'):\n                        visited[temp_point[0] + dx[i]][temp_point[1] + dy[i]] = True;\n                        stk_adj.append([temp_point[0]+dx[i],temp_point[1]+dy[i]])\n    return reached\n\ndx=[0,0,-1,1]\ndy=[-1,1,0,0]\nnumbers = list(map(int, input().split()))\nn=int(numbers[0])\nm=int(numbers[1])\ntemp_line=\"\"\ncage=[['']*m for _ in range(n) ]\n#vstd=numpy.zeros(10)\nvisited=[[False]*m for _ in range(n) ]\nfor i in range(0,n):\n    temp_line=input()\n    for j in range(0,m):\n        cage[i][j]+=(temp_line[j])\nnumbers = list(map(int, input().split()))\ni1=int(numbers[0]-1)\nj1=int(numbers[1]-1)\nnumbers = list(map(int, input().split()))\ni2=int(numbers[0]-1)\nj2=int(numbers[1]-1)\npos=0\nif(is_path_exist(cage, visited, i1, j1, i2, j2)):\n    if(cage[i2][j2]=='X'):\n        print('YES')\n        pos=1\n    if(pos==0):\n        count=0\n        for i in range(0,4):\n            if (i2 + dx[i] > -1 and i2 + dx[i] < len(cage) and j2 + dy[i] > -1 and j2 + dy[i] < len(cage[0])\n                        and (cage[i2 + dx[i]][j2 + dy[i]] == '.' or (i2 + dx[i] == i1 and j2 + dy[i] == j1)) ):\n                count+=1\n        if(count>1):\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')\n\n\n\n\n"]
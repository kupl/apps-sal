["n, C = map(int, input().split())\ntime = 0\nstc = []\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    time = max(time, temp[1])\n    stc.append(temp)\ntv = [[0 for i in range(C)] for i in range(time + 1)]\nfor i in stc:\n    s, t, c = i[0], i[1], i[2]\n    for j in range(s, t + 1):\n        tv[j][c - 1] = 1\nans = 0\nfor i in tv:\n    ans = max(ans, sum(i))\nprint(ans)", "n, c = list(map(int, input().split()))\n# input\u6642\u306b\u524d\u51e6\u7406\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u3053\u3068\u3092\u3057\u3066\u304a\u304f\n#   * \u958b\u59cb\u6642\u9593\u3092-1(-0.5\u306e\u5236\u7d04\u3060\u304c\u3001-1\u3057\u3066\u3082\u5909\u308f\u3089\u306a\u3044\u306e\u3067-1\u3059\u308b)\u3057\u3066\u304a\u304f\n\n# \u30c6\u30ec\u30d3\u5c40\u306e\u756a\u7d44\u3092\u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306b\u767b\u9332\nr = [[0 for i in range(c)] for j in range(100000)]\nfor _ in range(n):\n    s,t,c = list(map(int, input().split()))\n    for j in range(s-1, t):\n        r[j][c - 1] = 1\n# print(*r,sep='\\n')\n\nans = 0\nfor i in range(len(r)):\n    ans = max(ans, sum(r[i]))\nprint(ans)\n\n\n# \u88dc\u8db3\n# \u30c1\u30e3\u30f3\u30cd\u30eb\u65704\u306e\u5834\u5408\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u914d\u5217\u304c\u3067\u304d\u308b\n# 1\u884c\u3067\u3068\u3042\u308b\u6642\u9593\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u72b6\u614b(1: \u9332\u753b\u3059\u308b, 0: \u9332\u753b\u3057\u306a\u3044)\u304c\u3064\u304f\n#[0, 0, 0, 0]\n#[0, 0, 1, 0]\n#[1, 1, 1, 0]  <- \u3053\u306e\u6642\u9593\u30673\u30c1\u30e3\u30f3\u30cd\u30eb\u9332\u753b\u304c\u5fc5\u8981\n#[1, 1, 0, 0]  <- \u3053\u306e\u6642\u9593\u30672\u30c1\u30e3\u30f3\u30cd\u30eb\u9332\u753b\u304c\u5fc5\u8981\n#[1, 1, 0, 0]\n#[1, 0, 0, 0]\n", "import heapq\nN, C = list(map(int, input().split()))\n\nans = C\nd = [list() for _ in range(C+1)]\nfor _ in range(N):\n    s, t, c = list(map(int, input().split()))\n    d[c].append([s, t])\n\nS = [0]*(10**5+1)\nT = [0]*(10**5+1)\n\nfor i in range(C+1):\n    if not d[i]:\n        continue\n    d[i].sort()\n    s, t = d[i][0]\n    for j in range(1, len(d[i])):\n        if t == d[i][j][0]:\n            t = d[i][j][1]\n        else:\n            S[s] += 1\n            T[t] += 1\n            s, t = d[i][j]\n    S[s] += 1\n    T[t] += 1\n\ntemp = 0\nans = 0\nfor i in range(1, 10**5+1):\n    temp += S[i]-T[i-1]\n    ans = max(ans, temp)\n    \nprint(ans)\n", "def main():\n    from itertools import accumulate\n    n, c, *stc = list(map(int, open(0).read().split()))\n    table = [0] * 2 * (10 ** 5 + 1)\n    m = list(zip(stc[::3], stc[1::3], stc[2::3]))\n    m.sort(key=lambda a: (a[2], a[0], a[1]))\n\n    ch_ = 0\n    t_ = 0\n    for s, t, ch in m:\n        if ch != ch_:\n            ch_ = ch\n            t_ = 0\n        if t_ == 2 * s:\n            table[t_ + 1] += 1\n        else:\n            table[2 * s - 1] += 1\n\n        table[2 * t + 1] -= 1\n        t_ = 2 * t\n\n    *x, = accumulate(table)\n    ans = max(x)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import *\nimport heapq\nimport math\n# from math import gcd\nimport bisect\nimport copy\nfrom itertools import permutations,accumulate,combinations,product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn,c=map(int,input().split())\nstc=[list(map(int,input().split())) for i in range(n)]\nstc.sort()\nlst=[0]*c\nfor i in range(n):\n    s,t,ctmp=stc[i]\n    for j in range(c):\n        if lst[j]==0:\n            lst[j]=stc[i]\n            break\n        else:\n            if lst[j][2]==ctmp:\n                lst[j]=stc[i]\n                break\n            elif lst[j][1]<s:\n                lst[j]=stc[i]\n                break\n# print(lst)\nans=0\nfor i in range(c):\n    if lst[i]!=0:\n        ans+=1\nprint(ans)", "n,c=list(map(int,input().split()))\ntable=[0]*220000\nchanels=[[]for i in range(c)]\nfor i in range(n):\n    a,s,ch=list(map(int,input().split()))\n    chanels[ch-1].append((a,s))\nfor i in range(c):\n    if chanels[i]:\n        chanels[i].sort()\n        x,y=chanels[i][0]\n        for p,q in chanels[i][1:]+[(0,0)]:\n            if y==p:y=q\n            else:\n                table[2*x-1]+=1\n                table[2*y]-=1\n                x,y=p,q\n\nfrom itertools import accumulate\nprint((max(list(accumulate(table)))))\n", "class Imos:\n    def __init__(self, n):\n        self.B = [0] * n\n        self.n = n\n        from itertools import accumulate\n        self.ac = accumulate\n\n    def __call__(self, l, r):\n        l, r = max(l, 0), min(r, self.n - 1)\n        self.B[l] += 1\n        if r + 1 != self.n:\n            self.B[r + 1] -= 1\n\n    def out(self):\n        *res, = self.ac(self.B)\n        return res\n\nfrom collections import defaultdict\nd = defaultdict(list)\nimos = Imos(10 ** 5 + 1)\n\n(N, C), *D = [[*map(int, o.split())] for o in open(0)]\nfor s, t, c in D:\n    d[c] += (s, t),\nfor p in d.values():\n    p.sort()\n    ps, pt = p[0]\n    for s, t in p[1:] + [[0,0]]:\n        if pt == s:\n            pt = t\n        else:\n            imos(ps - 1, pt - 1)\n            ps, pt = s, t\nprint(max(imos.out()))", "def main():\n    from itertools import accumulate\n    n, c, *stc = list(map(int, open(0).read().split()))\n    table = [0] * (10 ** 5 + 2)\n    m = list(zip(stc[::3], stc[1::3], stc[2::3]))\n    m.sort(key=lambda a: (a[2], a[0], a[1]))\n\n    ch_ = 0\n    t_ = 0\n    for s, t, ch in m:\n        if ch != ch_:\n            ch_ = ch\n            t_ = 0\n        if t_ == s:\n            table[t_ + 1] += 1\n        else:\n            table[s] += 1\n\n        table[t + 1] -= 1\n        t_ = t\n\n    *x, = accumulate(table)\n    ans = max(x)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, c = map(int, input().split())\ncnt = [[0 for _ in range(10 ** 5 + 1)] for _ in range(c)]\n\nfor _ in range(n):\n    s, t, _c = map(int, input().split())\n    for j in range(s, t + 1):\n        cnt[_c - 1][j] = 1\nans = 0\nfor i in range(10 ** 5 + 1):\n    ans = max(ans, sum(cnt[j][i] for j in range(c)))\nprint(ans)", "def main():\n    from itertools import accumulate\n    n, c, *stc = list(map(int, open(0).read().split()))\n    table = [0] * (10 ** 5 + 2)\n    m = sorted(list(zip(*[iter(stc)] * 3)), key=lambda a: (a[2], a[0]))\n\n    ch_ = 0\n    t_ = 0\n    for s, t, ch in m:\n        if ch != ch_:\n            ch_ = ch\n            t_ = 0\n        if t_ == s:\n            table[t_ + 1] += 1\n        else:\n            table[s] += 1\n\n        table[t + 1] -= 1\n        t_ = t\n\n    *x, = accumulate(table)\n    ans = max(x)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, C = map(int, input().split())\nsch = sorted([list(map(int, input().split())) for _ in range(N)], key=lambda x: x[0])\nrec = [[0, 0] for _ in range(C+1)]\nnum_rec = 1\n\nfor i in range(N):\n    s, t, c = sch[i]\n    start = False\n    for j in range(1, num_rec + 1):\n        if rec[j][0] - int(rec[j][1] == c) < s:\n            rec[j] = [t, c]\n            start = True\n            break\n    if not start:\n        num_rec += 1\n        rec[num_rec] = [t, c]\n    \nprint(num_rec)", "def main():\n    N, C = list(map(int, input().split()))\n    l = []\n    for _ in range(N):\n        s, t, c = list(map(int, input().split()))\n        l.append((s,t,c))\n    l.sort(key=lambda x: x[0])\n    r = []\n    for i in l:\n        if not r:\n            r.append((i[1], i[2]))\n            continue\n        for j, v in enumerate(r):\n            if v[0] < i[0] or (v[1] == i[2] and v[0] == i[0]):\n                r[j] = (i[1], i[2])\n                break\n        else:\n            r.append((i[1], i[2]))\n        r.sort(key=lambda x:x[0])\n    print((len(r)))\nmain()\n", "N,C=map(int, input().split())\nA=[list(map(int, input().split())) for _ in range(N)]\nD=[[] for i in range(C)]\nDD=[[] for i in range(C)]\nfor s,t,c in A:\n  D[c-1].append([s,t])\nfor i in range(C):\n  E=sorted(D[i])\n  e=len(E)\n  for j in range(e):\n    if j==0:\n      DD[i].append([E[j][0],E[j][1]])\n    elif j!=0 and E[j][0]==E[j-1][1]:\n      DD[i][-1][-1]=E[j][1]\n    else:\n      DD[i].append([E[j][0],E[j][1]])\nANS=[0]*(10**5+3)\nfor i in range(C):\n  F=DD[i]\n  for i,j in F:\n    ANS[i]+=1\n    ANS[j+1]-=1\nans=0\nd=0\nfor i in ANS:\n  d+=i\n  ans=max(d,ans)\nprint(ans)", "n,c=map(int,input().split())\nimos=[[0 for i in range(c)] for j in range(10**5+1)]#1~10**5+1\nfor i in range(n):\n    s,t,_c=map(int,input().split())\n    imos[s-1][_c-1]+=1\n    imos[t][_c-1]-=1\nfor i in range(1,10**5+1):\n    for j in range(c):\n        imos[i][j]+=imos[i-1][j]\nimosans=[0]*(10**5+1)\nfor i in range(10**5+1):\n    for j in range(c):\n        imosans[i]+=(imos[i][j]>=1)\nprint(max(imosans))", "def main():\n    from itertools import accumulate\n    n, c, *stc = list(map(int, open(0).read().split()))\n    table = [0] * (10 ** 5 + 2)\n    m = sorted(list(zip(*[iter(stc)] * 3)), key=lambda a: (a[2], a[0], a[1]))\n\n    ch_ = 0\n    t_ = 0\n    for s, t, ch in m:\n        if ch != ch_:\n            ch_ = ch\n            t_ = 0\n        if t_ == s:\n            table[t_ + 1] += 1\n        else:\n            table[s] += 1\n\n        table[t + 1] -= 1\n        t_ = t\n\n    *x, = accumulate(table)\n    ans = max(x)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nfrom itertools import accumulate\n\n\nN, K = map(int, input().split())\n\ntimetables = defaultdict(list)\nfor i in range(N):\n    s, t, c = map(int, input().split())\n    timetables[c].append([s, t])\n\nfor name, times in timetables.items():\n    times.sort()\n    new = []\n    for i, time in enumerate(times):\n        s, t = time\n        if i == 0:\n            new.append([s, t])\n            continue\n        if s == new[-1][1]:\n            new[-1][1] = t\n        else:\n            new.append([s, t])\n    timetables[name] = new\n\ntime_count = [0] * 100010\nfor name, times in timetables.items():\n    for s, t in times:\n        time_count[s] += 1\n        time_count[t + 1] -= 1\n\nacc = accumulate(time_count)\n\nprint(max(acc))", "n,c = list(map(int,input().split()))\n\nt = [[0 for i in range(100001)] for j in range(c)]\n\nfor i in range(n):\n    si,ti,ci = list(map(int,input().split()))\n    for j in range(si,ti+1):\n        t[ci-1][j] = 1\nprint((max(sum(t[j][i] for j in range(c)) for i in range(100001))))\n", "import math\nimport numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,c = list(map(int,ipt().split()))\n    cc = [[] for _ in [0]*c]\n    tma = 0\n    for i in range(n):\n        s,t,c = list(map(int,ipt().split()))\n        hpq.heappush(cc[c-1],(s,t))\n        if t > tma:\n            tma = t\n    cnt = np.zeros(tma+1,dtype=int)\n    for i in cc:\n        ps = -1\n        pt = -1\n        while len(i) > 0:\n            ns,nt = hpq.heappop(i)\n            if pt == ns:\n                pt = nt\n                continue\n            elif not pt == -1:\n                cnt[ps:pt+1:] += np.ones(pt-ps+1,dtype=int)\n            ps = ns\n            pt = nt\n        if not pt == -1:\n            cnt[ps:pt+1:] += np.ones(pt-ps+1,dtype=int)\n    print((max(cnt)))\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "imos = [0]*(10**5+2)#0~10**5+1\n\nN,C = map(int,input().split())\nC = 30\nmitai = [[] for i in range(C+1)]\n\nfor i in range(N):\n    s,t,c = map(int,input().split())\n    mitai[c].append([s,t])\n\nfor i in range(C+1):\n    mitai[i].sort()\n\n\nfor i in range(C+1):\n    preT = -1\n    for j in mitai[i]:\n        s,t = j[0],j[1]\n        if preT == s:\n            imos[s+1]+=1\n            imos[t+1]-=1\n        else:\n            imos[s]+=1\n            imos[t+1]-=1\n        preT = t\n\nfor i in range(1,len(imos)):\n    imos[i]=imos[i-1]+imos[i]\n\nprint(max(imos))", "import sys\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, C, *STC = list(map(int, read().split()))\n\n    P = [[] for _ in range(C)]\n    for s, t, c in zip(*[iter(STC)] * 3):\n        P[c - 1].append((s, t))\n\n    M = 10 ** 5\n    vec = [0] * (M + 2)\n    for i in range(C):\n        P[i].sort()\n        for j, (s, t) in enumerate(P[i]):\n            if j > 0 and s == P[i][j - 1][1]:\n                vec[s] += 1\n                vec[t] += -1\n            else:\n                vec[s - 1] += 1\n                vec[t] += -1\n\n    vec = list(accumulate(vec))\n\n    print((max(vec)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    N, C = list(map(int, input().split(' ')))\n    progams = [list(map(int, input().split(' '))) for _ in range(N)]\n    progams.sort(key=lambda p: p[0])  # sort in ascending order of start time\n    recorders = [[0, 0] for _ in range(C)]  # (end time, channel)\n    for prog in progams:\n        s, t, c = prog\n        for i in range(C):\n            can_record = (c == recorders[i][1] and recorders[i][0] <= s) or \\\n                (c != recorders[i][1] and recorders[i][0] < s)\n            if can_record:\n                recorders[i][0] = t\n                recorders[i][1] = c\n                break\n    ans = 0\n    for i in range(C):\n        if recorders[i][0] > 0:\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nn,c=list(map(int,input().split()))\ns=[list(map(int,input().split())) for _ in range(n)]\n\ndd=defaultdict(lambda: [0]*(10**5+1))\nfor s,t,ch in s:\n  for i in range(s,t+1):\n    dd[ch][i]=1\nans=0\nfor i in range(10**5+1):\n  cnt=0\n  for ch in range(c+1):\n    if dd[ch][i]==1:\n      cnt+=1\n  ans=max(ans,cnt)\nprint(ans)\n  \n", "N,C = map(int,input().split())\nT = [[0 for i in range(10**5+1)] for j in range(C)]\n\nfor i in range(N):\n    s,t,c = map(int,input().split())\n    T[c-1][s] += 1\n    T[c-1][t] -= 1\nfor i in range(C):\n    for j in range(10**5):\n        T[i][j+1] += T[i][j]\n\nans = 0\nfor i in range(1,10**5+1):\n    a = 0\n    for j in range(C):\n        if T[j][i] or T[j][i-1]:\n            a += 1\n    ans = max(ans,a)\nprint(ans)", "N, C = map(int, input().split())\nrec = [[0]*C for _ in range(10**5)]\nfor _ in range(N):\n  s, t, c = map(int, input().split())\n  for i in range(s-1, t):\n    rec[i][c-1] = 1\n\nprint(max([sum(rec[i]) for i in range(10**5)]))", "def Csum(a):\n    b,c=[0],0\n    for i in range(len(a)):\n        c+=a[i]\n        b.append(c)\n    return b\n\nn,c=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nb=[[0]*(10**5+10) for i in range(c)]\nfor i in a:\n    b[i[2]-1][i[0]-1]+=1\n    b[i[2]-1][i[1]]-=1\nb=[Csum(i) for i in b]\nans=[]\nfor i in range(10**5+10):\n    d=0\n    for j in range(c):\n        if b[j][i]>0:\n            d+=1\n    ans.append(d)\nprint(max(ans))", "import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    n, c = ns()\n    l = 10 ** 5\n    table = [[0 for _ in range(l + 1)] for __ in range(c)]\n\n    for _ in range(n):\n        s, t, ci = ns()\n        ci -= 1\n        table[ci][s] += 1\n        table[ci][t] -= 1\n\n    ans = 0\n    tmp = 0\n    for i in range(l + 1):\n        fin = 0\n        for j in range(c):\n            if table[j][i] > 0:\n                tmp += table[j][i]\n            else:\n                fin += table[j][i]\n        ans = max(ans, tmp)\n        tmp += fin\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nN, C = list(map(int,input().split()))\nMx = 10**5+1\nsch = [[0]*Mx for _ in range(C)]\nscht = [0]*Mx\nplist = [[] for _ in range(C)]\nfor _ in range(N):\n    s, t, c = list(map(int,input().split()))\n    plist[c-1].append((s,t))\nfor c, p in enumerate(plist):\n    p.sort()\n    prevt = 0\n    for s, t in p:\n        if prevt == s:\n            sch[c][prevt] = 0\n        else:\n            sch[c][s] = 1\n        sch[c][t] = -1\n        prevt = t\n    for i in range(1, Mx):\n        if sch[c][i]==1:\n            scht[i-1]+=1\n        if sch[c][i]==-1:\n            scht[i]-=1\n\nfor i in range(1, Mx):\n    scht[i] += scht[i-1]\n\nprint((max(scht)))\n", "n, C = map(int, input().split())\nstc = [list(map(int, input().split())) for i in range(n)]\nm = 0\nfor i in stc:\n    m = max(m, i[1])\nlis = [[0] * C for i in range(m + 1)]\nfor i in stc:\n    for j in range(i[0], i[1] + 1):\n        lis[j][i[2] - 1] = 1\nans = 0\nfor i in lis:\n    ans = max(ans, sum(i))\nprint(ans)", "from collections import defaultdict\nimport numpy as np\nimport sys\n\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, C = list(map(int, input().split()))\n    MAX = 10 ** 5 + 2\n    vals = [0] * MAX\n    D = defaultdict(list)\n    for _ in range(N):\n        s, t, c = list(map(int, input().split()))\n        D[c].append((s, t))\n\n    for k, v in list(D.items()):\n        prev = -1\n        v.sort(key=lambda x: x[0])\n        for s, t in v:\n            if prev == s:\n                vals[prev + 1] += 1\n                vals[t + 1] -= 1\n            else:\n                vals[s] += 1\n                vals[t + 1] -= 1\n            prev = t\n\n    cumsum = np.cumsum(vals)\n    ans = max(cumsum)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, C = list(map(int, input().split()))\n\ntv = [[0]*C for _ in range(100000)]\nfor _ in range(N):\n    s, t, c = list(map(int, input().split()))\n    for i in range(s-1, t): tv[i][c-1] = 1\n    \nprint((max([sum(tv[i]) for i in range(100000)])))\n", "import numpy as np\n\nn, c = list(map(int, input().split()))\nstc = [[] for i in range(c+1)]\nfor i in range(n):\n  s_, t_, c_ = list(map(int, input().split()))\n  stc[c_].append([s_,t_])\n  \n\nstc_ = []\nfor i in range(1, c+1):\n    stc[i] = sorted(stc[i], key=lambda x:(x[0], x[1]))\n    j = 0\n    l = len(stc[i])\n    flg = False\n    while j < l:\n        if not flg:\n            cs, ct = stc[i][j][0], stc[i][j][1]\n        if j == l-1:\n            stc_.append([cs, ct])\n            break\n        ns, nt = stc[i][j+1][0], stc[i][j+1][1]\n        if ct != ns:\n            flg = False\n            stc_.append([cs, ct])\n        else:\n            flg = True\n            ct = nt\n            if j == l - 2:\n                stc_.append([cs, ct])\n                break\n        j += 1\nstc_ = sorted(stc_, key=lambda x:(x[0], x[1]))\n\nm = len(stc_)\n\ncnt = np.zeros(10**5+5, dtype=int)\nfor i in range(m):\n    s, t = stc_[i][0]-1, stc_[i][1]\n    cnt[s:t] += 1\nprint((cnt.max()))\n", "N, C = map(int, input().split())\nch = [[0]*(10**5+1) for _ in range(C)]\n\nfor _ in range(N):\n  s, t, c = map(int, input().split())\n  ch[c-1][s] += 1\n  ch[c-1][t] -= 1\n\nfor c in range(C):\n  for i in range(10**5):\n    if ch[c][i+1] == 1:\n      ch[c][i+1] = ch[c][i+1] + ch[c][i]\n      ch[c][i] = 1\n    else:\n      ch[c][i+1] = ch[c][i+1] + ch[c][i]\n\nans = 0\nfor i in range(10**5):\n  temp = 0\n  for c in range(C):\n    temp += ch[c][i+1]\n  ans = max(ans, temp)\n\nprint(ans)", "from itertools import accumulate\nn, C = list(map(int, input().split()))\n\nU = 10**5\nchannels = [[0]*(U+1) for _ in range(C)]\nfor _ in range(n):\n    s, t, c = [int(x)-1 for x in input().split()]\n    channels[c][s] += 1\n    channels[c][t] -= 1\n\n\nfor i in range(C):\n    for j in range(U):\n        channels[i][j+1] += channels[i][j]\n\nschedules = [0]*(U+1)\nfor i in range(C):\n    L = None\n    for j in range(U+1):\n        if channels[i][j] and L is None:\n            L = j-1\n            continue\n\n        if not channels[i][j] and L is not None:\n            schedules[max(L, 0)] += 1\n            schedules[j] -= 1\n            L = None\n\nprint((max(accumulate(schedules))))\n", "import numpy as np\n\nn,c = map(int,input().split())\n\nli = np.zeros(10**5+1,int)\nch = [[] for _ in range(10**5+1)]\nlin = []\n\nfor _ in range(n):\n    s,t,c = map(int,input().split())\n    lin.append((s,t,c))\n\nlin.sort()\n\nfor i,j,k in lin:\n    if k in ch[i-1]:\n        li[i:j] += 1\n        ch[j-1].append(k)\n    else:\n        li[i-1:j] += 1\n        ch[j-1].append(k)\n\nprint(np.max(li))", "N,C = map(int, input().split())\ns =[0]*N\nt =[0]*N\nc =[0]*N\nfor i in range(N):\n    s[i],t[i],c[i] = map(int, input().split())\n\nimos = [[0]*int(1e5+20) for _ in range(31)]\nfor i in range(N):\n    imos[c[i]][s[i]]+=1\n    imos[c[i]][t[i]+1]-=1\n\nans = 0\nfor i in range(1,int(1e5+10)):\n    sm = 0\n    for j in range(31):\n        imos[j][i]=imos[j][i-1]+ imos[j][i]\n        if imos[j][i] >= 1:\n            sm+=1\n    ans = max(ans,sm)\nprint(ans)", "from numpy import *\nN,C = map(int,input().split())\nA = zeros((C,10**5),int32)\n\nfor n in range(N):\n  s,t,c = map(int,input().split())\n  A[c-1,s-1:t] = 1\nprint(max(sum(A,axis=0)))", "import heapq\nN, C = map(int, input().split())\n\nstc = [list(map(int, input().split())) for _ in range(N)]\n\nstc.sort()\n\nlst = []\nhq = [[-1, -1]]\nheapq.heapify(hq)\nans = 1\nfor i in range(N):\n    p = stc[i]\n    q = heapq.heappop(hq)\n    if p[0] < q[0]:\n        heapq.heappush(hq, q)\n\n        ans += 1\n\n    elif p[0] == q[0]:\n        lst = []\n        jdg2 = True\n\n        while p[0] == q[0] and p[2]>= q[1]:\n            if p[2] == q[1]:\n\n                jdg2 = False\n            else:\n                lst.append(q)\n            if hq: q = heapq.heappop(hq)\n            else: break\n        if jdg2:\n            ans += 1\n        if p[0] != q[0] or p[2] < q[1]:\n            heapq.heappush(hq, q)\n\n        for k in lst:\n            heapq.heappush(hq, k)\n\n    heapq.heappush(hq, [p[1], p[2]])\n\nprint(ans)", "N,C=map(int,input().split())\nSTC=[list(map(int,input().split())) for _ in range(N)]\n\nS=[[] for _ in range(10**5+1)]\nT=[[] for _ in range(10**5+1)]\n\nfor s,t,c in STC:\n    S[s].append(c)\n    T[t].append(c)\n\nused=set()\nans=0\nfor i in range(10**5+1):\n    start=set()\n    finish=set()\n    for s in S[i]:\n        start.add(s)\n    for t in T[i]:\n        finish.add(t)\n    ans=max(ans,len(used)+len(start-finish))\n    used=used-finish|start\nprint(ans)", "n,c = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\n\nimport numpy as np\na = np.zeros((c+1, 10**5))\n\nfor i in range(n):\n    a[ab[i][2]][(ab[i][0]-1):ab[i][1]] = [1]*(ab[i][1]-ab[i][0]+1)\n\nb = a.sum(axis=0)\n\nprint(int(max(b)))", "from heapq import heappop, heappush\n\n\ndef main():\n    n, c = list(map(int, input().split()))\n    program = [[] for _ in range(c)]\n    for _ in range(n):\n        s, t, cc = list(map(int, input().split()))\n        cc -= 1\n        s *= 2\n        t *= 2\n        program[cc].append([s - 1, t])\n    all_p = []\n    for i in range(c):\n        if len(program[i]) == 0:\n            continue\n        now = program[i]\n        now.sort(key=lambda x: x[1])\n        last_begin, last_end = now[0]\n        for begin, end in now[1:]:\n            if begin + 1 == last_end:\n                last_end = end\n            else:\n                all_p.append([last_begin, last_end, i])\n                last_begin = begin\n                last_end = end\n        all_p.append([last_begin, last_end, i])\n    all_p.sort()\n    q = [(-1, -1)]\n    for begin, end, now_channel in all_p:\n        last_end, last_channel = q[0]\n        if last_end < begin or now_channel == last_channel:\n            heappop(q)\n        heappush(q, (end, now_channel))\n    print((len(q)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, C = list(map(int, input().split()))\ntv = [[0]*C for _ in range(100000)]\nfor _ in range(N):\n    s, t, c = list(map(int, input().split()))\n    for i in range(s-1, t): tv[i][c-1] = 1\nprint((max([sum(tv[i]) for i in range(100000)])))\n", "from collections import deque\nN, C = list(map(int, input().split()))\nque = []\nQue = []\nchannel = [[] for i in range(C+1)]\nfor i in range(N):\n    s, t, c = list(map(int, input().split()))\n    channel[c].append((s, t))\nfor i in range(C+1):\n    channel[i].sort()\n    tmp_que = deque(channel[i])\n    left_que = deque([])\n    if tmp_que:\n        x, y = tmp_que.popleft()\n        left_que.append((x, y))\n        while tmp_que:\n            lx, ly = left_que.pop()\n            rx, ry = tmp_que.popleft()\n            if ly == rx:\n                left_que.append((lx, ry))\n            elif ly < rx:\n                left_que.append((lx, ly))\n                left_que.append((rx, ry))\n    for x, y in left_que:\n        Que.append((2*x-1, 1))\n        Que.append((2*y, -1))\nans = 0\nvalue = 0\nQue.sort(reverse=True)\nwhile Que:\n    v, command = Que.pop()\n    value += command\n    ans = max(ans, value)\nprint(ans)\n\n", "n, c = map(int, input().split())\nimos = [0 for _ in range(10 ** 5 + 1)]\nans = 0\nchannel = [[] for _ in range(30)]\nfor _ in range(n):\n    s, t, c = map(int, input().split())\n    channel[c - 1].append([s, t])\n    \nfor lst in channel:\n    lst.sort()\n    before = 0\n    for s, t in lst:\n        start = max(before, s - 1)\n        imos[start] += 1\n        end = min(t, 10 ** 5 + 1)\n        imos[end] -= 1\n        before = end\ntmp = 0\nfor num in imos:\n    tmp += num\n    ans = max(ans, tmp)\nprint(ans)    ", "n, c = list(map(int, input().split()))\nprogram = [[] for _ in range(c)]\n\nfor i in range(n):\n  s, t, cc = list(map(int, input().split()))\n  program[cc-1].append((s, t))\n\ncount = [0]*(10**5+1)\nfor i in range(c):\n  program[i].sort()\n  l = len(program[i])\n  judge = True\n  for j in range(l-1):\n    if judge:\n      count[program[i][j][0]-1] += 1\n    if program[i][j][1] == program[i][j+1][0]:\n      judge = False\n    else:\n      judge = True\n    if judge:\n      count[program[i][j][1]] -= 1\n  if l == 0:\n    continue\n  if judge:\n    count[program[i][l-1][0]-1] += 1\n  count[program[i][l-1][1]] -= 1\n\nans = 0\nfor i in range(10**5+1):\n  if i != 0:\n    count[i] += count[i-1]\n  if ans < count[i]:\n    ans = count[i]\nprint(ans)\n", "N , C = list(map(int,input().split()))\ntel = [[0,-1] for i in range(C)]\npro = [list(map(int,input().split())) for i in range(N)]\npro.sort()\nfor s , t , c in pro:\n    for i in range(C):\n        if tel[i][0] < s - 0.5 or tel[i][1] == c or tel[i][1] == -1:\n            tel[i][0] = t\n            tel[i][1] = c\n            break\nfor i in range(C):\n    if tel[i][1] == -1:\n        print(i)\n        return\nprint(C)\n", "N, C = map(int, input().split())\nprog = [list(map(int, input().split())) for _ in range(N)]\n\n#tv[i] = [t, c]\ntv = [[-1, 0] for i in range(C)]\n\nprog.sort()\n\nfor p in prog:\n    s, t, c = p\n    for i in range(C):\n        if tv[i][0] < s - 0.5 or tv[i][1] == c or tv[i][1] == 0:\n            tv[i][0] = t\n            tv[i][1] = c\n            break\n\n\nans = 0\nfor i in range(C):\n    if tv[i][0] > 0:\n        ans += 1\n    else:\n        break\n\nprint(ans)", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\ndef main(args):\n    N,C = map(int,input().split())\n    \n    time = [[0]*(10**5+1) for _ in range(C)]\n    \n    for _ in range(N):\n        s, t, c = map(lambda x:int(x)-1,input().split())\n        time[c-1][s] += 1\n        time[c-1][t+1] -= 1\n        \n    recorder = np.where(np.cumsum(time[0]) > 0, 1, 0)\n    \n    for i in range(1,C):\n        recorder += np.where(np.cumsum(time[i]) > 0, 1, 0)\n    \n    print(max(recorder))\n    \ndef __starting_point():\n    main(sys.argv[1:])\n__starting_point()", "import sys\nimport numpy as np\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\nn,c,*stc=list(map(int,read().split()))\nm=2*10**5\ncht=np.zeros((c,m+1),dtype='int64')\nfor s,t,ch in zip(*[iter(stc)]*3):\n  cht[ch-1,2*s-1:2*t]=np.ones(2*t-2*s+1)\nprint((max(np.sum(cht,axis=0))))\n", "import numpy as np\nN,C=list(map(int, input().split()))\n\n#s~t\u3067c\nL=np.zeros((C, 10**5+1))\n\nfor i in range(N):\n    s,t,c=list(map(int, input().split()))\n    L[c-1,s-1]+=1\n    L[c-1,t]-=1\n\nL=np.cumsum(L, axis=1)\nprint((int((L>0).sum(axis=0).max())))\n", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, C = [int(x) for x in input().split()]\n    STC = [[int(x) for x in input().split()] for _ in range(N)]\n\n    S = [[] for _ in range(10 ** 5 + 1)]\n    T = [[] for _ in range(10 ** 5 + 1)]\n\n    for s, t, c in STC:\n        S[s].append(c)\n        T[t].append(c)\n\n    used = set()\n    ans = 0\n    for i in range(10 ** 5 + 1):\n        sused = set()\n        tused = set()\n\n        for s in S[i]:\n            sused.add(s)\n        for t in T[i]:\n            tused.add(t)\n\n        ans = max(ans, len(used) + len(sused - tused))\n        used = used - tused | sused\n\n    print(ans)\n\n\n\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nN,C = ma()\nnn = 10**5+4\ntimes = [[0 for i in range(nn)] for j in range(C+1)]\nfor i in range(N):\n    s,t,c = ma()\n    times[c][s] +=1\n    times[c][t] -=1\nfor c in range(1,C+1):\n    for i in range(nn-1):\n        times[c][i+1] += times[c][i]\n\ntot = [0 for i in range(nn)]\nfor c in range(C+1):\n    for i in range(nn-1):\n        tot[i] += times[c][i]\n        if times[c][i] == 0 and times[c][i+1] ==1:\n            tot[i] +=1\nprint(max(tot))\n", "import sys\nimport numpy as np\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\nn,c=list(map(int,readline().split()))\nm=2*10**5\nstc=[list(map(int,l.split())) for l in read().splitlines()]\ncht=np.zeros((c,m+1),dtype='int64')\nfor e in stc:\n  cht[e[2]-1,2*e[0]-1:2*e[1]]=np.ones(2*e[1]-2*e[0]+1)\nprint((max(np.sum(cht,axis=0))))\n", "import numpy as np\n\ndef main():\n    with open(0) as f:\n        N, C = list(map(int, f.readline().split()))\n        Rec = [tuple(map(int, f.readline().split())) for _ in range(N)]\n    \n    time_line_by_channel = np.array([[0] * (10**5+1) for _ in range(C+1)])\n    #\u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306b\u30bf\u30a4\u30e0\u30e9\u30a4\u30f3\u3092\u4f5c\u6210\n    for s, t, c in Rec:\n        time_line_by_channel[c, s-1:t] = 1\n    #\u30bf\u30a4\u30e0\u30e9\u30a4\u30f3\u7d50\u5408\n    joined_timeline = np.sum(time_line_by_channel, axis=0)\n    ans = max(joined_timeline)\n    print(ans)\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nn,C = map(int,input().split())\nch = [[] for _ in range(C)]\ntmax = 0\nfor _ in range(n):\n  s,t,c = map(int,input().split())\n  ch[c-1].append((s,t))\n  tmax = max(tmax,t)\nch = [sorted(i,key= lambda x:x[0]) for i in ch]\nimos = [0]*(tmax+2)\nfor i in ch:\n  now = -1\n  for ds,dt in i:\n    if ds == now:\n      imos[ds] +=1\n    else:\n      imos[ds-1] += 1\n    imos[dt] -= 1\n    now = dt\nfor i in range(tmax +1):\n  imos[i+1] += imos[i]\nprint(max(imos))", "import heapq\nN, C, *STC = [int(_) for _ in open(0).read().split()]\nSTC = [(s, t, c) for s, t, c in zip(STC[::3], STC[1::3], STC[2::3])]\nSTC.sort()\n#\u3082\u3057c\u3092\u6620\u3057\u3066\u3044\u308b\u30c6\u30ec\u30d3\u304c\u3042\u308b\u306a\u3089\u3053\u308c\u306b\u3057\u3066\u3057\u307e\u3046\u306e\u304c\u6700\u9069\n#c\u3092\u6620\u3057\u3066\u3044\u308b\u30c6\u30ec\u30d3\u304c\u306a\u3044\u306a\u3089\u3059\u3067\u306b\u7d42\u308f\u3063\u3066\u3044\u308b\u30c6\u30ec\u30d3\u306e\u3069\u308c\u304b\u3092\u9078\u3076\n#\u3069\u306e\u30c6\u30ec\u30d3\u3082\u3059\u3067\u306b\u6620\u3057\u3066\u3044\u308b\u306a\u3089\u65b0\u3057\u3044\u30c6\u30ec\u30d3\u3092\u8ffd\u52a0\u3059\u308b\n\nclass SegmentTree():\n    def __init__(self, array, f, ti):\n        \"\"\"\n        Parameters\n        ----------\n        array : list\n            to construct segment tree from\n        f : func\n            binary operation of the monoid\n        ti : \n            identity element of the monoid\n        \"\"\"\n        self.f = f\n        self.ti = ti\n        self.n = n = 2**(len(array).bit_length())\n        self.dat = dat = [ti] * n + array + [ti] * (n - len(array))\n        for i in range(n - 1, 0, -1):  # build\n            dat[i] = f(dat[i << 1], dat[i << 1 | 1])\n\n    def update(self, p, v):  # set value at position p (0-indexed)\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = v\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_right(self, p, v):  # apply operator from the right side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(dat[p], v)\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_left(self, p, v):  # apply operator from the left side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(v, dat[p])\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def query(self, l, r):  # result on interval [l, r) (0-indexed)\n        f, ti, n, dat = self.f, self.ti, self.n, self.dat\n        vl = vr = ti\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                vl = f(vl, dat[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                vr = f(dat[r], vr)\n            l >>= 1\n            r >>= 1\n        return f(vl, vr)\n\nti = (10 ** 10, -10 ** 10)\nst = SegmentTree([(10 ** 10, i) for i in range(C + 1)], min, ti)\nans = 0\nfor s, t, c in STC:\n    if st.query(c, c + 1)[0] == 10 ** 10:\n        t2, c2 = st.query(1, C + 1)\n        if t2 < s:\n            st.update(c2, (10 ** 10, c2))\n        else:\n            ans += 1\n    st.update(c, (t, c))\nprint(ans)\n", "import numpy as np\nN, C = map(int,input().split())\nT1 = [[] for _ in range(C)]\nfor _ in range(N):\n    s, t, c = map(int,input().split())\n    T1[c-1].append([s,t])\nfor i in range(C):\n    T1[i].sort()\nT2 = [[] for _ in range(C)]\nfor i in range(C):\n    for s, t in T1[i]:\n        if len(T2[i]) != 0 and T2[i][-1][1] == s:\n            T2[i][-1][1] = t\n        else:\n            T2[i].append([s,t])\n\nL = np.zeros(10 ** 5 + 2, int)\nfor i in range(C):\n    for time in T2[i]:\n        L[time[0]] += 1\n        L[time[1]+1] -= 1\n\nans = L.cumsum().max()\n\nprint(ans)", "n,c=map(int,input().split())\nt=[[0 for i in range(100001)] for j in range(c)]\n\nfor i in range(n):\n    si,ti,ci = map(int,input().split())\n    for j in range(si,ti+1):\n        t[ci-1][j] = 1\nprint(max(sum(t[j][i] for j in range(c)) for i in range(100001)))", "from itertools import accumulate\n\n\ndef main():\n    n, c = list(map(int, input().split()))\n    p = [[] for _ in range(c + 1)]\n    for _ in range(n):\n        *st, cc = list(map(int, input().split()))\n        p[cc].append(st)\n    all_p = [0] * (10 ** 5 + 10)\n    for pp in p:\n        if len(pp) == 0:\n            continue\n        pp.sort()\n        last_start, last_end = pp[0]\n        for start, end in pp[1:]:\n            if start == last_end:\n                last_end = end\n            else:\n                all_p[last_start - 1] += 1\n                all_p[last_end] -= 1\n                last_start, last_end = start, end\n        all_p[last_start - 1] += 1\n        all_p[last_end] -= 1\n    print((max(accumulate(all_p))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u3042\u308b\u6642\u70b9\u306e\u91cd\u8907\u756a\u7d44\u6570\u3092\u524d\u304b\u3089\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3001\u6700\u5927\u5024\u304c\u7b54\u3048\n# s\u9806\u306b\u4e26\u3079\u3066\u3001\u30eb\u30fc\u30d7\u3054\u3068\u306b\u91cd\u8907\u6570\u3092\u5897\u3084\u3057\u3064\u3064\u3001\n# \u7d42\u4e86\u30ad\u30e5\u30fc\u306bt\u3092\u8ffd\u52a0\n# \u756a\u7d44\u8ffd\u52a0\u3059\u308b\u3054\u3068\u306b\u7d42\u4e86\u30ad\u30e5\u30fc\u306e\u4e2d\u8eab\u3092\u30c1\u30a7\u30c3\u30af\n# \u540c\u3058\u30c1\u30e3\u30f3\u30cd\u30eb\u3060\u3063\u305f\u3089\u3001\u7d42\u4e86\u30ad\u30e5\u30fct <= \u73fe\u5728\u6642\u523b \u306e\u3068\u304d\u306b\u7d42\u4e86\u30ad\u30e5\u30fc\u304b\u3089\u5916\u305b\u308b\n# \u9055\u3046\u30c1\u30e3\u30f3\u30cd\u30eb\u3060\u3063\u305f\u3089\u3001\u7d42\u4e86\u30ad\u30e5\u30fct < \u73fe\u5728\u6642\u523b\u3068\u306a\u308b\n# \u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306bheapq\u3092\u6301\u3064\n\nN,C = map(int,input().split())\nimport heapq\nendq = [[] for i in range(C)]\nfor i in range(C):\n  heapq.heapify(endq[i])\nprogs = [None] * N\nfor i in range(N):\n  s,t,c = map(int,input().split())\n  progs[i] = [s,t,c-1]\n\nprogs = sorted(progs,key = lambda x:x[0])\n\nans = 0\ncur = 0\n\nfor i in range(N):\n  s,t,c = progs[i]\n  # \u6642\u523bs\u306b\u7d42\u4e86\u3059\u308b\u756a\u7d44\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n  # \u307e\u305a\u540c\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u3082\u306e\u304c\u6642\u523bs\u306b\u7d42\u4e86\u3057\u3066\u3044\u305f\u3089\u3001\u305d\u308c\u3092\u5916\u3059\u3053\u3068\u304c\u51fa\u6765\u308b\n  while endq[c]:\n    endt = heapq.heappop(endq[c])\n    if endt <= s:\n      cur -= 1\n    else:\n      heapq.heappush(endq[c],endt)\n      break\n  \n  # \u4ed6\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n  for endc in range(C):\n    if endc == c:\n      continue # \u540c\u3058\u30c1\u30e3\u30f3\u30cd\u30eb\u306f\u30c1\u30a7\u30c3\u30af\u6e08\u307f\n    while endq[endc]:\n      endt = heapq.heappop(endq[endc]) # \u5404\u30c1\u30e3\u30f3\u30cd\u30eb\u306e\u30ad\u30e5\u30fc\u304b\u3089\u53d6\u308a\u51fa\u3059\n      if endt < s:\n        cur -= 1\n      else:\n        heapq.heappush(endq[endc],endt)\n        break\n  # \u4eca\u56de\u306e\u756a\u7d44\u3092\u683c\u7d0d\u3059\u308b\n  cur += 1\n  heapq.heappush(endq[c],t)\n  if cur > ans:\n    ans = cur\n\nprint(ans)", "# \u89e3\u8aac imos\nn, C = map(int, input().split())\nL = [tuple(map(int, input().split())) for _ in range(n)]\nm = 10 ** 5\nS = [0] * m\nfor i in range(1, C + 1):\n    T = [0] * (m + 1)\n    for s, t, c in L:\n        if c == i:\n            T[s - 1] += 1\n            T[t] -= 1\n    for i in range(m):\n        T[i + 1] += T[i]\n    for i in range(m):\n        S[i] += T[i] > 0\nprint(max(S))", "import numpy as np\nN, C = (int(x) for x in input().split())\nR = [[0]*100000 for _ in range(C)] #R[c][t]:\u6642\u523bt+1\u306b\u30c1\u30e3\u30f3\u30cd\u30ebc+1\u3092\u9332\u753b\u3059\u308b\u306e\u306b\u5fc5\u8981\u306a\u9332\u753b\u6a5f\u306e\u500b\u6570\nR = np.array(R)\nfor _ in range(N):\n    s, t, c = map(int,input().split())\n    R[c-1,s-1:t] = 1\nans = max(sum(R))\nprint(ans)", "n,c = list(map(int,input().split()))\n\nl = [[] for i in range(c)]\nfor i in range(n):\n    s,t,x = list(map(int,input().split()))\n    l[x-1].append([s,t])\n\nal= []\nfor i in range(c):\n    if len(l[i]) > 1:\n        l[i].sort()\n        now2 = l[i][0][1]\n        now1 = l[i][0][0]\n        check = False\n        for j in range(1,len(l[i])):\n            if l[i][j][0] == now2:\n                now2 = l[i][j][1]\n            else:\n                al.append([[now1,now2],i])\n                check = True\n                now1 = l[i][j][0]\n                now2 = l[i][j][1]\n        if not check:\n            al.append([[now1,now2],i])\n\n    else: \n        if l[i]:\n            al.append([l[i][0],i])\nal.sort()\n\ncount = [[-1,-1]]\nfor i in range(len(al)):\n    a,b,c = al[i][0][0], al[i][0][1],al[i][1]\n    check = False\n    for j in range(len(count)):\n        if count[j][0] < a:\n            count[j] = [b,c]\n            check = True\n            break\n    if not check:\n        count.append([b,c])\n\nprint((len(count)))\n", "n,c=map(int,input().split())\nchan=[[] for _ in range(c)]\nfor _ in range(n):\n    s,t,sc=map(int,input().split())\n    sc-=1\n    chan[sc].append((s,t))\nfor i in range(c):\n    chan[i].sort()\n#print(chan)\nfor i in range(c):\n    lis=[]\n    if len(chan[i])==1:\n        lis.append(chan[i][0][0])\n        lis.append(chan[i][0][1])\n    elif len(chan[i])>=2:\n        lis.append(chan[i][0][0])\n        for j in range(len(chan[i])-1):\n            if chan[i][j][1]!=chan[i][j+1][0]:\n                lis.append(chan[i][j][1])\n                lis.append(chan[i][j+1][0])\n        lis.append(chan[i][j+1][1])\n    chan[i]=lis\n#print(chan)\naccum=[0]*(10**5+2)\nfor i in range(c):\n    for j in range(0,len(chan[i])-1,2):\n        accum[chan[i][j]]+=1\n        accum[chan[i][j+1]+1]-=1\nfor i in range(10**5+1):\n    accum[i+1]+=accum[i]\n#print(accum)\nprint(max(accum))", "# solution\n\nimport io\nimport sys\nimport math\nfrom itertools import accumulate as acc\n\ndata=sys.stdin.readline\n\nN,C=map(int,data().split())\n\n\narray=[[0 for i in range(10**5+1)] for i in range(C+1)]\n\nrec=[0 for i in range(10**5+1)]\n\nfor i in range(N):\n    s,t,c=map(int,data().split())\n    recs,rect=array[c][s],array[c][t]\n    if recs==0 and rect==0:\n        rec[s-1]+=1\n        rec[t]-=1\n    elif recs==0 and rect==1:\n        rec[s-1]+=1\n        rec[t-1]-=1\n    elif recs==1 and rect==0:\n        rec[s]+=1\n        rec[t]-=1\n    elif recs==1 and rect==1:\n        rec[s]+=1\n        rec[t-1]-=1\n\n    array[c][s],array[c][t]=1,1\n\ntmp=0\nans=0\nfor i in range(10**5):\n    tmp+=rec[i]\n    ans=max(tmp,ans)\nprint(ans)", "import itertools\n\nN, C = list(map(int, input().split()))\nMAX = 10 ** 5 + 1\ntable = [[0] * MAX for _ in range(C)]\n\nfor _ in range(N):\n    s, t, c = list(map(int, input().split()))\n    c -= 1\n    table[c][s] += 1\n    table[c][t] -= 1\n\nfor c in range(C):\n    for x in range(MAX - 1):\n        if table[c][x + 1] == 1:\n            table[c][x + 1] = 0\n            table[c][x] += 1\n\ntable_sum = [sum(table[c][i] for c in range(C)) for i in range(MAX)]\nprint((max(itertools.accumulate(table_sum))))\n", "# heapq\u306e\u65b9\u91dd\u3067\u4e0a\u624b\u304f\u3044\u304b\u306a\u304b\u3063\u305f\n# \u89e3\u8aac\u653e\u9001\u3092\u898b\u3066imos\u306b\u3057\u305f\n\ndef main():\n    from collections import namedtuple\n    from heapq import heappop, heappush\n    import sys\n    input = sys.stdin.readline\n\n    Prog = namedtuple('Prog', 'L R')\n    Prog.__eq__ = lambda self, other: self.R == other.R\n    Prog.__lt__ = lambda self, other: self.R < other.R\n\n    N, C = list(map(int, input().split()))\n    ps = tuple([] for _ in range(30))\n    for _ in range(N):\n        l, r, ch = list(map(int, input().split()))\n        heappush(ps[ch - 1], Prog(l, r))\n\n    imos = [0] * (10 ** 5 + 1)\n    for ps_ch in ps:\n        while ps_ch:\n            l, r = heappop(ps_ch)\n            while ps_ch and ps_ch[0].L == r:\n                r = ps_ch[0].R\n                heappop(ps_ch)\n            else:\n                imos[l - 1] += 1\n                imos[r] -= 1\n\n    for i in range(10 ** 5):\n        imos[i + 1] += imos[i]\n\n    print((max(imos)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nN, C = map(int, sys.stdin.readline().split())\n\n# \u540c\u4e00\u30c1\u30e3\u30f3\u30cd\u30eb\u306a\u3089t\u3068s\u304c\u9023\u7d9a\u3057\u3066\u3044\u3066\u30821\u53f0\u3067\u9332\u753b\u3067\u304d\u308b\n# \u305d\u306e\u305f\u3081\u3001\u901a\u5e38\u306eimos\u6cd5\u3067\u306f\u306a\u304f\u3001\u9332\u753b\u958b\u59cb\u30fb\u7d42\u4e86\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u3092\u4fdd\u6301\u3059\u308b\ntimes = [[set() for _ in range(10**5 + 5)], [set() for _ in range(10**5 + 5)]]\nmax_t = 0\nfor _ in range(N):\n    s, t, c = map(int, sys.stdin.readline().split())\n    # \u57fa\u672c\u7684\u306bs-1\u3060\u3051\u3067\u3088\u3044\u304c\u3001\u540c\u4e00\u30c1\u30e3\u30f3\u30cd\u30eb\u3067\u9332\u753b\u304c\u9023\u7d9a\u3059\u308b\u5834\u5408\u306e\u5bfe\u5fdc\u3092\u5165\u308c\u3066\u304a\u304f\n    times[0][s-1].add(c)\n    times[0][s].add(c)\n    times[1][t].add(c)\n    max_t = max(max_t, t)\n\nans = 0\nrecording = set()\nfor i in range(max_t + 5):\n    recording -= times[1][i]\n    recording |= times[0][i]\n    ans = max(ans, len(recording))\n\nprint(ans)", "import numpy as np\nN, C = map(int, input().split())\ns = np.empty(N)\nt = np.empty(N)\nc = np.empty(N)\nfor i in range(N):\n  s[i], t[i], c[i] =  map(int, input().split())\nTimeTable = np.zeros((C,100001))\nmaxTime = 0\nfor i in range(N):\n  channle = int(c[i] - 1)\n  for j in range(int(s[i]),int(t[i])+1):\n    TimeTable[channle,j] = 1\n  if maxTime < t[i]:\n    maxTime = t[i]\nMaxRecode = 0\nfor i in range(int(maxTime)):\n  Recode = np.sum(TimeTable[:,i])\n  if Recode > MaxRecode:\n    MaxRecode = Recode\nprint(int(MaxRecode))", "N,C=map(int,input().split())\n\nold=[[] for i in range(C)]\n\nfor i in range(N):\n    s,t,c=map(int,input().split())\n    old[c-1].append((s,t))\nch=[]\nfor li in old:\n    li.sort()\n    j=0\n    while(j<len(li)):\n        start=li[j][0]\n        while(j<len(li)-1 and li[j][1]==li[j+1][0]):\n            j+=1\n        end=li[j][1]\n        ch.append((((start-1)*2)+1,end*2))\n        j+=1\n    \n        \nimos=[0]*(2*10**5+10)\nfor s,t in ch:\n    imos[s]+=1\n    imos[t]-=1\nfor i in range(1,2*10**5+10):\n    imos[i]=imos[i-1]+imos[i]\nprint(max(imos))", "import heapq\n\ndef main():\n    N, C = list(map(int, input().split()))\n    STC = [tuple(map(int, input().split())) for _ in range(N)]\n    STC.sort()\n    CC = [(0, 0)] * C\n    T = []\n    for s, t, c in STC:\n        ps, pt = CC[c - 1]\n        if ps == 0:\n            CC[c - 1] = (s, t)\n        elif s == pt:\n            CC[c - 1] = (ps, t)\n        else:\n            T.append((ps, pt, c))\n            CC[c - 1] = (s, t)\n    for c, (s, t) in enumerate(CC):\n        if s != 0:\n            T.append((s, t, c + 1))\n    T.sort()\n    STC = T\n\n    h = []\n    e = []\n    r = 0\n    for s, t, c in STC:\n        while h and h[0][0] <= s:\n            e.append(heapq.heappop(h)[1])\n        if not e:\n            e.append(r)\n            r += 1\n        heapq.heappush(h, (t + 1, e.pop()))\n    return r\n\nprint((main()))\n", "A,B=list(map(int,input().split()))\nl=[[] for i in range(100001)]\nfor i in range(A):\n   X,Y,Z=list(map(int,input().split()))\n   for j in range(X-1,Y):\n      l[j].append(Z)\nans=0\nfor i in l:\n   ans=max(ans,len(set(i)))\nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**6)\n# buff_readline = sys.stdin.buffer.readline\nbuff_readline = sys.stdin.readline\nreadline = sys.stdin.readline\n\nINF = 2**62-1\n\n\ndef read_int():\n    return int(buff_readline())\n\n\ndef read_int_n():\n    return list(map(int, buff_readline().split()))\n\n\ndef read_float():\n    return float(buff_readline())\n\n\ndef read_float_n():\n    return list(map(float, buff_readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n\n@mt\ndef slv(N, C, STC):\n    from collections import Counter\n    se = [(2*s, 0, c) for s, t, c in STC]\n    te = [(2*t+1, 1, c) for s, t, c in STC]\n    e = se + te\n    e.sort(reverse=True)\n    r = Counter()\n    ans = 0\n    while e:\n        _, k, c = e.pop()\n        if k == 0:\n            r[c] += 1\n        else:\n            r[c] -= 1\n            if r[c] == 0:\n                r.pop(c)\n        ans = max(ans, len(r))\n    return ans\n\n\ndef main():\n    N, C = read_int_n()\n    STC = [read_int_n() for _ in range(N)]\n    print(slv(N, C, STC))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\ninput = sys.stdin.readline\nn,C = map(int,input().split())\na = np.zeros((C,10**5),dtype=\"int\")\nfor _ in range(n):\n  s,t,c = map(int,input().split())\n  a[c-1,s-1:t] = 1\nprint(max(np.sum(a,axis=0)))", "def main():\n    import sys\n    input = sys.stdin.readline\n    from heapq import heappush\n    N, C = map(int, input().split())\n    table = [[0]*10**5 for _ in range(C)]\n    for _ in range(N):\n        s, t, c = map(int, input().split())\n        s -= 1\n        t -= 1\n        c -= 1\n        for i in range(s, t + 1):\n            table[c][i] = 1\n            \n    ans = 0\n    for i in range(10**5):\n        tmp = sum(table[j][i] for j in range(C))\n        ans = max(ans, tmp)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N,C = map(int, input().split())\ns =[0]*N\nt =[0]*N\nc =[0]*N\nfor i in range(N):\n    s[i],t[i],c[i] = map(int, input().split())\n\nimos = [[0]*int(1e5+20) for _ in range(31)]\nfor i in range(N):\n    imos[c[i]][s[i]]+=1\n    imos[c[i]][t[i]+1]-=1\n\nans = 0\nfor i in range(1,int(1e5+10)):\n    sm = 0\n    for j in range(C+1):\n        imos[j][i]=imos[j][i-1]+ imos[j][i]\n        if imos[j][i] >= 1:\n            sm+=1\n    ans = max(ans,sm)\nprint(ans)", "def Recording():\n    n, c = list(map(int, input().split()))\n    num = 2*10**5+1 \n\n    # \u30c1\u30e3\u30f3\u30cd\u30eb\u3054\u3068\u306bimos\u914d\u5217\n    imos = [[0]*num for _ in range(c)]\n    \n    # imos\n    for _ in range(n):\n        s, t, c0 = list(map(int, input().split()))\n        if imos[c0-1][s*2] < 0 and imos[c0-1][t*2-1] > 0:\n            imos[c0-1][s*2] = 0\n            imos[c0-1][t*2-1] = 0\n        elif imos[c0-1][s*2] < 0:            \n            imos[c0-1][s*2] = 0\n            imos[c0-1][t*2] -= 1\n        elif imos[c0-1][t*2-1] > 0:    \n            imos[c0-1][s*2-1] += 1\n            imos[c0-1][t*2-1] = 0\n        else:\n            imos[c0-1][s*2-1] += 1\n            imos[c0-1][t*2] -= 1\n    ans = [0 for _ in range(num)]\n    for i in range(c):\n        for j in range(1, num):\n            imos[i][j] += imos[i][j-1]\n            ans[j] += imos[i][j]\n    print((max(ans)))\n    \ndef __starting_point():\n    Recording()\n    \n\n__starting_point()", "# 1-index\nfrom sys import stdin\nimport numpy as np\nN, C = [int(x) for x in stdin.readline().rstrip().split()]\nimos = np.array([[0]*(10**5+1) for i in range(C+1)])\n\nfor i in range(N):\n    s, t, c = [int(x) for x in stdin.readline().rstrip().split()]\n    imos[c, s - 1:t] = 1\n\nimos = np.array(imos)\n# print(np.cumsum(imos,axis=1))\nans = max(imos.sum(axis=0))\nprint(ans)", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  N,C=LI()\n  l=[[0]*100100 for _ in range(C)]\n\n  for _ in range(N):\n    s,t,c=LI()\n    l[c-1][s]+=1\n    l[c-1][t+1]-=1\n\n  for i in range(C):\n    for j in range(100000):\n      l[i][j+1]+=l[i][j]\n\n  for i in range(C):\n    for j in range(100000):\n      if l[i][j]==2:\n        l[i][j]=1\n\n  mx=0\n  for i in range(100000):\n    sm=0\n    for j in range(C):\n      sm+=l[j][i]\n    mx=max(mx,sm)\n\n  return mx\n\n# main()\nprint((main()))\n", "# https://atcoder.jp/contests/abc080/tasks/abc080_d\n# D - Recording\n\nN,C = list(map(int,input().split()))\ns=[0]*N\nt=[0]*N\nc=[0]*N\nf=[False]*C\nyoyaku=[False]*C\nL=[]\nfor i in range(N):\n    s[i],t[i],c[i]= list(map(int,input().split()))\n    L.append( [s[i]-0.5,c[i]-1,1] )\n    L.append( [t[i],c[i]-1,0] )\n\nL.sort()\n#print(L)\nans=0\ntmp=0\n\nfor i,(time, ch, sw) in enumerate(L):\n    if sw==1:\n        if f[ch]==False:\n            tmp +=1\n            f[ch]=True\n            ans = max(ans,tmp)\n        else:\n            yoyaku[ch]=True\n    else:\n        if yoyaku[ch]:\n            yoyaku[ch]=False\n        else:\n            tmp -= 1\n            f[ch]=False\n   \nprint(ans)\n", "import itertools\nN,C=list(map(int,input().split()))\nch =[[] for _ in range(C+1)]\ntime= [0]*(10**5+1)\nfor _ in range(N):\n    s,t,c=list(map(int,input().split()))\n    ch[c].append(s)\n    ch[c].append(t)\n    \nfor i in range(1,C+1):\n    ch[i].sort()\n\nfor i in range(1,C+1):\n    for chi in range(len(ch[i])):\n        if chi %2 == 0:\n            if chi == 0:\n                time[ch[i][chi]-1]+=1\n            elif chi>1 and ch[i][chi-1]!=ch[i][chi]:\n                time[ch[i][chi]-1]+=1\n        elif chi %2 == 1:\n            if chi==len(ch[i])-1:\n                time[ch[i][chi]]-=1\n            elif ch[i][chi+1] != ch[i][chi]:\n                time[ch[i][chi]]-=1\n\ninteg_time = itertools.accumulate(time)\nprint((max(integ_time)))\n", "n,c,*stc = list(map(int,open(0).read().split()))\nstc = list(zip(stc[::3],stc[1::3],stc[2::3]))\n\nstc.sort()\n\nrecord = []\n\nfor s,t,c in stc:\n    \n    for i,(rt,rc) in enumerate(record):\n        if s-0.5 >= rt:\n            record[i] = (t,c)\n            break\n        elif c == rc and  s>= rt:\n            record[i] = (t,c)\n            break\n    else:\n        record.append((t,c))\n    \n    record.sort(reverse=True)\n\nprint((len(record)))\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, C = list(map(int, input().split()))\n\nC = 30\nst = [[] for i in range(C)]\n\nfor i in range(N):\n    s, t, c = list(map(int, input().split()))\n    st[c-1].append((s-1, t-1))\n\ndata = [0]*(10**5*2)\nfor i in range(C):\n    data_tmp = [0]*(10**5*2)\n    for j in range(len(st[i])):\n        s, t = st[i][j]\n\n        start = max(s*2, 0)\n        end = min((t-1)*2+1, 10**5*2-1)\n        data_tmp[start] += 1\n        data_tmp[end+1] -= 1\n    # print(data_tmp[:30])\n    for j in range(1, len(data_tmp)-1):\n        if data_tmp[j] > 0:\n            data_tmp[j-1] += data_tmp[j]\n            data_tmp[j] = 0\n    # for j in reversed(range(1, len(data_tmp)-1)):\n    #     if data_tmp[j] < 0:\n    #         data_tmp[j+1] += data_tmp[j]\n    #         data_tmp[j] = 0\n    for j in range(0, len(data_tmp)):\n        data[j] += data_tmp[j]\n    # print(data_tmp[:30])\n    # print()\nans = [data[0]]\nfor i in range(1, len(data)):\n    ans.append(ans[-1]+data[i])\n\nprint((max(ans)))\n", "import sys\nfrom collections import *\nimport heapq\nimport math\n# from math import gcd\nimport bisect\nimport copy\nfrom itertools import permutations,accumulate,combinations,product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn,c=map(int,input().split())\nstc=[list(map(int,input().split())) for i in range(n)]\nstc.sort()\nlst=[0]*c\nfor i in range(n):\n    s,t,ctmp=stc[i]\n    for j in range(c):\n        if lst[j]==0:\n            lst[j]=stc[i]\n            break\n        else:\n            if lst[j][2]==ctmp:\n                lst[j]=stc[i]\n                break\n            elif lst[j][1]<s:\n                lst[j]=stc[i]\n                break\n# print(lst)\nans=0\nfor i in range(c):\n    if lst[i]!=0:\n        ans+=1\nprint(ans)", "from operator import itemgetter\ndef resolve():\n    N, C = list(map(int, input().split()))\n    STC = sorted([list(map(int, input().split())) for _ in range(N)], key=itemgetter(2, 0))\n    \n    counts = [0]*(10**5+1)\n    prevt, prevc = -1, -1\n    for stc in STC:\n        s, t, c = stc\n        if prevt == s and prevc == c:\n            counts[s] += 1\n        else:\n            counts[s - 1] += 1\n        counts[t] -= 1\n        prevt, prevc = t, c\n    for i in range(1, 10**5+1):\n        counts[i] += counts[i-1]\n    #print(counts[:15])\n    print(max(counts))\n\n\nif '__main__' == __name__:\n    resolve()", "N, C = map(int, input().split())\ntable = [[0]*(10**5 + 1) for i in range(C)]\n\nst = [[] for i in range(C)]\nfor i in range(N):\n  s, t, c = map(int, input().split())\n  st[c-1].append([s, t])\n\nst_new = [[] for i in range(C)]\nfor c in range(C):\n  if st[c]:\n    st[c].sort()\n    st_new[c].append(st[c][0])\n    n = len(st[c])\n    for i in range(1, n):\n      si, ti = st[c][i]\n      sii, tii = st_new[c][-1]\n      if si == tii:\n        st_new[c][-1][1] = ti\n      else:\n        st_new[c].append([si, ti])\n\nfor c in range(C):\n  for s, t in st_new[c]:\n    table[c][s-1] += 1\n    table[c][t] -= 1\n  \nfor c in range(C):\n  for i in range(1, 10**5+1):\n    table[c][i] += table[c][i-1]\n\nans = 0\nfor i in range(10**5 + 1):\n  num = 0\n  for c in range(C):\n    num += table[c][i]\n  ans = max(ans, num)\n\nprint(ans)", "class Imos:\n    def __init__(self, n):\n        self.B = [0] * n\n        self.n = n\n        from itertools import accumulate\n        self.ac = accumulate\n\n    def __call__(self, l, r):\n        l, r = max(l, 0), min(r, self.n - 1)\n        self.B[l] += 1\n        self.B[r + 1] -= 1\n\n    def out(self):\n        *res, = self.ac(self.B)\n        # self.__init__(self.n)\n        return res\n\nfrom collections import defaultdict\nd = defaultdict(list)\nimos = Imos(10 ** 5 + 1)\n\n(N, C), *D = [[*map(int, o.split())] for o in open(0)]\nfor s, t, c in D:\n    d[c] += (s, t),\nfor p in d.values():\n    p.sort()\n    ps, pt = p[0]\n    for s, t in p[1:] + [[0,0]]:\n        if pt == s:\n            pt = t\n        else:\n            imos(ps - 1, pt - 1)\n            ps, pt = s, t\nprint(max(imos.out()))", "n,C=map(int,input().split())\n\nchs=[[] for i in range(31)]\n\nfor i in range(n):\n    s,t,c=map(int,input().split())\n    chs[c].append((s,t))\n\nfor q in range(len(chs)):\n    ch=chs[q][:]\n    ch.sort()\n    new=[]\n    if len(ch)<=1:\n        continue\n    else:\n        now=ch[0]\n        for i in range(1,len(ch)):\n            if now[1]==ch[i][0]:\n                now=(now[0],ch[i][1])\n            else:\n                new.append(now)\n                now=ch[i]\n        new.append(now)\n        chs[q]=new[:]\n\ntim=[0 for i in range(200002)]\n\nfor ch in chs:\n    for pro in ch:\n        tim[pro[0]*2-1]+=1\n        tim[pro[1]*2]-=1\n\ncnt=0\nans=0\nfor i in range(len(tim)):\n    cnt+=tim[i]\n    ans=max(ans,cnt)\nprint(ans)", "class Imos:\n    def __init__(self, n):\n        self.B = [0] * n\n        self.n = n\n        from itertools import accumulate\n        self.ac = accumulate\n\n    def __call__(self, l, r):\n        l, r = max(l, 0), min(r, self.n - 1)\n        self.B[l] += 1\n        if r + 1 != self.n:\n            self.B[r + 1] -= 1\n\n    def out(self):\n        *res, = self.ac(self.B)\n        self.__init__(self.n)\n        return res\n\nfrom collections import defaultdict\nd = defaultdict(list)\nimos = Imos(10 ** 5 + 1)\n\n(N, C), *D = [[*map(int, o.split())] for o in open(0)]\nfor s, t, c in D:\n    d[c] += (s, t),\nfor p in d.values():\n    p.sort()\n    ps, pt = p[0]\n    for s, t in p[1:] + [[0,0]]:\n        if pt == s:\n            pt = t\n        else:\n            imos(ps - 1, pt - 1)\n            ps, pt = s, t\nprint(max(imos.out()))", "from collections import defaultdict as dd\nN, C = tuple(map(int, input().split()))\nevents = []\ntmax = 0\ndic=dd(list)\nfor i in range(N):\n    s, t, c = map(int, input().split())\n    dic[c].append((s,t))\neps = 0.5\nfor k,v in dic.items():\n    v1 = sorted(v)\n    lev = len(v1)\n    prev = [-1,-1]\n    for i,val in enumerate(v1):\n        if tmax < val[1]:\n            tmax = val[1]\n        if prev == [-1,-1]:\n            prev[0] = val[0]\n            prev[1] = val[1] # end_time\n            if lev != 1:\n                continue\n            else:\n                events.append((prev[0]-eps, 1))\n                events.append((prev[1], 0))\n                break\n        if prev[1] == val[0]:# prev_end == now_start\n            prev[1] = val[1]\n            if i == lev - 1:\n                events.append((prev[0] - eps, 1))\n                events.append((prev[1], 0))\n                break\n        else:\n            events.append((prev[0]-eps, 1))\n            events.append((prev[1], 0))\n            prev[0] = val[0]\n            prev[1] = val[1]\n            if i==lev-1:\n                events.append((val[0]-eps, 1))\n                events.append((val[1], 0))\n                break\nevents.sort()\nidx = 0\ncnt = 0\nres = 0\nevents.append((0,-1))\nfor t in range(tmax + 1):\n    while events[idx][0] <= t:\n        event = events[idx]\n        if event[1] == 1:\n            cnt += 1\n            if res < cnt:\n                res = cnt\n        elif event[1] == 0:\n            cnt -= 1\n        else:\n            break\n        idx += 1\nprint(res)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, c = list(map(int, input().split()))\n    STC = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:[x[2], x[0]])\n\n    STC2 = []\n    tmp = STC[0]\n    for i in range(1, n):\n        pre_s, pre_t, pre_c = tmp\n        now_s, now_t, now_c = STC[i]\n        if pre_c == now_c:\n            if pre_t == now_s:\n                tmp = [pre_s, now_t, now_c]\n            else:\n                STC2.append(tmp)\n                tmp = STC[i]\n        else:\n            STC2.append(tmp)\n            tmp = STC[i]\n    if len(tmp):\n        STC2.append(tmp)\n\n    imos = [[0] * (10 ** 5 + 1) for _ in range(c)]\n    for i in range(len(STC2)):\n        s, t, c = STC2[i]\n        imos[c - 1][s - 1] += 1\n        imos[c - 1][t] -= 1\n\n    for i in range(c):\n        for j in range(1, 10 ** 5 + 1):\n            imos[i][j] += imos[i][j - 1]\n\n    res = [0] * (10 ** 5 + 1)\n    for i in range(c):\n        for j in range(10 ** 5 + 1):\n            res[j] += imos[i][j]\n\n    print((max(res)))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from itertools import accumulate\n\nMAX_T = 10 ** 5 + 100\nMAX_C = 30\n\nn, c = list(map(int, input().split()))\ntime = {c: [] for c in range(1, MAX_C + 1)}\n\nfor _ in range(n):\n    s, t, c = list(map(int, input().split()))\n    time[c].append((s, t))\n\nn_program = [0 for _ in range(MAX_T + 1)]\n\nfor c in range(1, MAX_C + 1):\n\n    recording = [0 for _ in range(MAX_T + 1)]\n\n    for s, t in time[c]:\n        recording[s] += 1\n        recording[t + 1] -= 1\n\n    recording = accumulate(recording)\n\n    for i, r in enumerate(recording):\n        if r:\n            n_program[i] += 1\n\nanswer = max(n_program)\nprint(answer)\n", "# heapq\u306e\u65b9\u91dd\u3067\u4e0a\u624b\u304f\u3044\u304b\u306a\u304b\u3063\u305f\n# \u89e3\u8aac\u653e\u9001\u3092\u898b\u3066imos\u306b\u3057\u305f\n\ndef main():\n    from collections import namedtuple\n    from heapq import heappop, heappush\n    import sys\n    input = sys.stdin.readline\n\n    Prog = namedtuple('Prog', 'L R')\n    Prog.__eq__ = lambda self, other: self.R == other.R\n    Prog.__lt__ = lambda self, other: self.R < other.R\n\n    N, C = list(map(int, input().split()))\n    ps = [[] for _ in range(30)]\n    for _ in range(N):\n        l, r, ch = list(map(int, input().split()))\n        heappush(ps[ch - 1], Prog(l, r))\n\n    imos = [0] * (10 ** 5 + 1)\n    for ps_ch in ps:\n        while ps_ch:\n            l, r = heappop(ps_ch)\n            while ps_ch and ps_ch[0].L == r:\n                r = ps_ch[0].R\n                heappop(ps_ch)\n            else:\n                imos[l - 1] += 1\n                imos[r] -= 1\n\n    ans = imos[0]\n    for i in range(10 ** 5):\n        imos[i + 1] += imos[i]\n        ans = max(ans, imos[i + 1])\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,c = map(int,input().split())\n\nt = [[0 for i in range(100001)] for j in range(c)]\n\nfor i in range(n):\n    si,ti,ci = map(int,input().split())\n    for j in range(si,ti+1):\n        t[ci-1][j] = 1\nans = 0\nfor i in range(100001):\n    ans = max(ans,sum(t[j][i] for j in range(c)))\nprint(ans)", "import sys\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\nn,c=list(map(int,readline().split()))\nm=2*10**5\nstc=[list(map(int,l.split())) for l in read().splitlines()]\ncht=[[0]*(m+1) for _ in range(c)]\nfor e in stc:\n  cht[e[2]-1][2*e[0]-1:2*e[1]]=[1 for _ in range(2*e[1]-2*e[0]+1)]\nmnr=0\nfor i in range(1,m+1):\n  mnr=max(mnr,sum(cht[ch][i] for ch in range(c)))\nprint(mnr)\n", "import sys\nimport numpy as np\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\ndef main():\n  n,c=map(int,readline().split())\n  m=2*10**5\n  stc=[list(map(int,l.split())) for l in read().splitlines()]\n  cht=np.zeros((c,m+1),dtype='int64')\n  for e in stc:\n    cht[e[2]-1,2*e[0]-1:2*e[1]]=np.ones(2*e[1]-2*e[0]+1)\n  print(max(np.sum(cht,axis=0)))\n\ndef __starting_point():\n  main()\n__starting_point()"]
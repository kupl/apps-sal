["n, m = map(int, input().split())\nvalists = [10**9 for _ in range(1<<n)]\nvalists[0] = 0\nfor i in range(m):\n\tvalues, b = map(int, input().split())\n\tc = list(map(int, input().split()))\n\tcnt = 0\n\tfor j in range(b):\n\t\tcnt += 2**(c[j]-1)\n\tfor j in range(len(valists)):\n\t\tx = j|cnt\n\t\tvalists[x] = min(valists[x], valists[j]+values)\n\t\t#print(j, cnt, x, valists)\n\n#print(valists)\nans = valists[2**n-1]\nif ans != 10**9:\n\tprint(ans)\nelse:\n\tprint(-1)", "n,m=map(int,input().split())\n\ndp=[10**9]*(1<<n)\ndp[0]=0\nfor _ in range(m):\n    a,b=map(int,input().split())\n    key=0\n    for i in map(int,input().split()):\n        key+=1<<(i-1)\n    for i in range(1<<n):\n        dp[i|key]=min(dp[i|key],dp[i]+a)\nif dp[-1]>10**8:\n    print(-1)\nelse:\n    print(dp[-1])", "def main():\n    n,m = tuple([int(t)for t in input().split()])\n\n    keys = []\n\n    dp = [10**9]*(1<<n)\n    dp[0] = 0\n    for _ in range(m):\n        a,_ = tuple([int(t)for t in input().split()])\n        c = tuple([int(t)for t in input().split()])\n        key = 0\n        for c_i in c:\n            key |= 1<<(c_i-1)\n        keys.append((a,key))\n    \n\n    for a,key in keys:\n        for i in range(1<<n):\n            dp[i|key] = min(dp[i|key],dp[i]+a)\n\n    if dp[-1]==10**9:\n        print(-1)\n    else:\n        print(dp[-1])\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nN,M = list(map(int,readline().split()))\nk = 2**N\ndp = [INF for i in range(k)]\ndp[0] = 0\n\nfor i in range(M):\n    a,b = list(map(int,readline().split()))\n    c = list(map(int,readline().split()))\n    d = sum(1<<(ci-1) for ci in c)\n    dpnew = dp[:]\n    for j in range(k):\n        dpnew[j|d] = min(dp[j]+a,dpnew[j|d])\n    dp = dpnew\n\nprint((dp[2**N-1] if dp[2**N-1] != INF else -1))\n\n\n", "n,m=map(int,input().split())\ndp=[10**20]*(1<<n)\ndp[0]=0\nfor i in range(m):\n    a,b=map(int,input().split())\n    c=list(map(int,input().split()))\n    bit=0\n    for j in c:bit|=1<<(j-1)\n    for j in range(1<<n):\n        dp[j|bit]=min(dp[j|bit],dp[j]+a)\nif dp[-1]==10**20:print(-1)\nelse:print(dp[-1])", "n,m=list(map(int,input().split()))\ninf=10**9\ncost=[inf for i in range(m)]\nfor i in range(m):\n  a,b=list(map(int,input().split()))\n  c=[int(x)-1 for x in input().split()]\n  s=0\n  for j in c:\n    s|=1<<j\n  cost[i]=[s,a]\n#print(cost)\n\ndp=[inf]*(1<<n)\ndp[0]=0\nfor s in range(1<<n):\n  for bit,c in cost:\n    dp[s|bit]=min(dp[s|bit], dp[s]+c)\n#print(dp)\nprint((-1 if dp[-1]==inf else dp[-1]))\n\n", "def main():\n  n, m = map(int, input().split())\n  \n  dp = [0]*(2**n)\n  len_dp = len(dp)\n\n  key_list = dict()\n  sub = 1\n  for i in range(n):\n    key_list[i+1] = sub\n    sub *= 2\n\n  for _ in range(m):\n    a, b = map(int, input().split())\n    c = [int(x) for x in input().split()]\n    key = 0\n    for value in c:\n      key += key_list[value]\n    for i in range(len_dp-1, -1, -1):\n      if i == 0 or dp[i]:\n        if dp[i|key]:\n          dp[i|key] = min([dp[i]+a, dp[i|key]])\n        else:\n          dp[i|key] = dp[i]+a\n\n  print(dp[len_dp-1] if dp[len_dp-1] else -1)\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    keys = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        C = list(map(int, input().split()))\n        s = 0\n        for c in C:\n            s |= 1 << (c - 1)\n        keys.append([a, s])\n\n    dp = [f_inf] * (1 << n)\n    dp[0] = 0\n    for now in range(1 << n):\n        for cost, key in keys:\n            nxt = now | key\n            dp[nxt] = min(dp[nxt], dp[now] + cost)\n    print((dp[-1] if dp[-1] != f_inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N, M = list(map(int, input().split()))\nA = []\nmin_state = [10**9] * (2**N)\nmin_state[0] = 0\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    key = 0\n    for tmp in c:\n        key += 2**(tmp-1)\n    A.append((a, key))\nL = len(min_state)\nfor a, key in A:\n    for i, score in enumerate(min_state):\n        next_key = key | i\n\n        if min_state[next_key] > score + a:\n            min_state[next_key] = score + a\nif min_state[-1] == 10**9:\n    print((-1))\nelse:\n    print((min_state[-1]))\n\n", "import sys\n\n\ndef main():\n    input = sys.stdin.readline\n\n    n, m = list(map(int, input().split()))\n\n    INF = 10**8\n    dp = [INF] * ((1 << n) + 1)\n    dp[0] = 0\n\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        c = sum(1 << (ci - 1) for ci in map(int, input().split()))\n\n        for j in range(1 << n):\n            if dp[j] + a < dp[j | c]:\n                dp[j | c] = dp[j] + a\n            # dp[j | c] = min(dp[j] + a, dp[j | c])\n\n    ans = -1 if dp[(1 << n) - 1] == INF else dp[(1 << n) - 1]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    INF = 10**10\n\n    N, M = list(map(int, input().split()))\n    keys = []\n    costs = []\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        costs.append(a)\n        cs = list(map(int, input().split()))\n        key = 0\n        for c in cs:\n            key |= 1<<(c-1)\n        keys.append(key)\n\n    dp = [INF] * (1<<N)\n    dp[0] = 0\n    for S in range(1<<N):\n        for key, cost in zip(keys, costs):\n            S2 = S | key\n            c2 = dp[S] + cost\n            if c2 < dp[S2]:\n                dp[S2] = c2\n\n    if dp[-1] == INF:\n        print((-1))\n    else:\n        print((dp[-1]))\n\n\nsolve()\n", "from functools import reduce\nN, M = map(int, input().split())\nL = 1 << N\ntable = {0: 0}\nfor _ in range(M):\n    cost, _ = map(int, input().split())\n    match = reduce(lambda a, b: a | b, (1 << shamt for shamt in map(lambda n: int(n) - 1, input().split())))\n    for l, now in table.copy().items():\n        table[l | match] = min(now + cost, table.get(l | match, 10 ** 7))\nprint(table[L - 1] if table.get(L - 1, False) else -1)", "N,M=list(map(int,input().split()))\nINF=10**18\ndp=[INF]*(1<<N)\ndp[0]=0\ncost=[None]*M\ntarget=[0]*M\n\nfor i in range(M):\n    cost[i],b=list(map(int,input().split()))\n    \n    c=[int(x) for x in input().split()]\n    for j in c:\n        target[i]=target[i]|(1<<(j-1))\n    \nfor s in range(1<<N):\n    for i in range(M):\n        ns=s|target[i]\n        dp[ns]=min(dp[ns],dp[s]+cost[i])\nif dp[-1]==INF:\n    print((-1))\nelse :\n    print((dp[-1]))\n", "def main():\n  n,m=map(int,input().split())\n  inf=10**9\n  cost=[inf for i in range(m)]\n  for i in range(m):\n    a,b=map(int,input().split())\n    c=[int(x)-1 for x in input().split()]\n    s=0\n    for j in c:\n      s|=1<<j\n    cost[i]=[s,a]\n  #print(cost)\n\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for s in range(1<<n):\n    for bit,c in cost:\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n  #print(dp)\n  print(-1 if dp[-1]==inf else dp[-1])\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 9\ndp = [INF] * (2 ** N)\ndp[0] = 0\nfor i in range(M):\n  a,b = list(map(int,readline().split()))\n  C = list(map(int,readline().split()))\n  key = 0\n  for c in C:\n    key += (1 << (c - 1))\n  for j in range(len(dp) - 1, -1, -1):\n    if dp[j] == INF:\n      continue\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\nif dp[-1] == INF:\n  print((-1))\nelse:\n  print((dp[-1]))\n", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 9\ndp = [INF] * (2 ** N)\ndp[0] = 0\nfor i in range(M):\n  a,b = list(map(int,readline().split()))\n  C = list(map(int,readline().split()))\n  key = 0\n  for c in C:\n    key += (1 << (c - 1))\n  for j in range(len(dp) - 1, -1, -1):\n    if dp[j] == INF:\n      continue\n    if dp[j | key] > dp[j] + a:\n      dp[j | key] = dp[j] + a\n\nif dp[-1] == INF:\n  print((-1))\nelse:\n  print((dp[-1]))\n", "def main():\n  N,M=map(int,input().split())\n  A=[0]*M\n  import heapq\n  import collections\n  from itertools import permutations\n  table=collections.defaultdict(list)\n  AC=[[0,0] for i in range(M)]\n  C=[set() for i in range(M)]\n  for i in range(M):\n    a,b=map(int,input().split())\n    AC[i][0]=a\n    tmp=set(map(int,input().split()))\n    for x in tmp:\n      AC[i][1] |= 1<<(x-1)\n  dp=[10**9]*(2**N)\n  dp[0]=0\n\n  for i in range(1,2**N):\n    k=0\n    s=set()\n    for j in range(1,i):\n      if i & j == j:\n        dp[i]=min(dp[i],dp[j]+dp[i^j])\n    for a,c in AC:\n      if c&i == i:\n        dp[i]=min(dp[i],a)\n    #print(dp[i],bin(i))\n\n  if dp[-1]==10**9:\n    print(-1)\n  else:\n    print(dp[-1])\nmain()", "def solve():\n  ans = 0\n  N, M = map(int, input().split())\n  A,C = [0]*M,[0]*M\n  for i in range(M):\n    A[i],b = map(int, input().split())\n    c = list(map(int, input().split()))\n    for j in range(b):\n      C[i] += 1<<(c[j]-1)\n  dp = [float('inf')]*(1<<N)\n  dp[0] = 0\n  for i in range(1,(1<<N)+1):\n    for key in range(M):\n      if C[key] & i == 0:\n        continue\n      dp[i] = min(dp[i],dp[i&~C[key]]+A[key])\n  ans = dp[-1]\n  if ans==float('inf'):\n    return -1\n  return ans\nprint(solve())", "def main():\n    n, m = map(int, input().split())\n    costs = [None]*m\n    keys = [None]*m\n    pattern = 2**n\n    inf = 10**12\n    dp = [inf]*pattern\n    for i in range(m):\n        costs[i] = int(input().split()[0])\n        keys[i] = sum([1<<(int(i)-1) for i in input().split()])\n    dp[0] = 0\n    for i in range(pattern):\n        for cost, key in zip(costs, keys):\n            pi = i|key\n            if dp[pi] > cost + dp[i]:\n                dp[pi] = cost + dp[i]\n    if dp[pattern-1] == inf:\n        print(-1)\n    else:\n        print(dp[pattern-1])\n        \n\ndef __starting_point():\n    main()\n__starting_point()", "N,M = map(int,input().split())\nfrom collections import defaultdict\nINF = float('inf')\ndic = defaultdict(lambda: INF)\nfor i in range(M):\n    a,b = map(int,input().split())\n    c = list(map(int,input().split()))\n    d = 0\n    for k in c:\n        d |= (1<<(k-1))\n    dic[d] = min(dic[d], a)\n\ndp = [INF] * (1<<N)\ndp[0] = 0\nfor k,v in dic.items():\n    for b in range((1<<N)-1):\n        if dp[b] == INF: continue\n        if b == (b|k): continue\n        dp[b|k] = min(dp[b|k], dp[b]+v)\nprint(-1 if dp[-1]==INF else dp[-1])                ", "n,m = list(map(int,input().split()))\nx = 2**n\ndp = [1000000000 for _ in range(x)]\ndp[0] = 0\nfor i in range(m):\n    ai,bi = list(map(int,input().split()))\n    c = list(map(int,input().split()))\n    bit = 0\n    for j in range(bi):\n        bit += 2**(c[j]-1)\n    for k in range(x):\n        dp[k | bit] = min(dp[k | bit],dp[k] + ai)\nif dp[x-1] == 1000000000:\n    print((-1))\nelse:\n    print((dp[x-1]))\n", "from sys import stdin\n\nn,m = map(int,stdin.readline().rstrip().split())\nc = []\na_list = []\n\ndef main():\n    for i in range(m):\n        a,b = map(int,stdin.readline().rstrip().split())\n        a_list.append(a)\n        c.append(sum(1 << j-1 for j in list(map(int,stdin.readline().rstrip().split()))))\n\n    inf = 10**10\n    dp = [inf]*(1 << n)\n    dp[0] = 0\n\n    for i in range(1 << n):\n        for A,C in zip(a_list,c):\n            dp[C|i] = min(dp[C|i],dp[i]+A)\n\n    if dp[-1] == inf:\n        print(-1)\n    else:\n        print(dp[-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "def min(a,b):\n  return a if a<=b else b\n\n\ndef main():\n  n,m=map(int,input().split())\n  inf=10**9\n  cost=[0]*m\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for i in range(m):\n    a,b=map(int,input().split())\n    t=sum([1<<(int(x)-1) for x in input().split()])\n    for s in range(1<<n):\n      dp[t|s]=min(dp[t|s], dp[s]+a)\n  print(-1 if dp[-1]==inf else dp[-1])\n  \n  \ndef __starting_point():\n  main()\n__starting_point()", "N, M = map(int, input().split())\na = []\nb = []\nc = []\n\nMY_INF = 1000000007\n\nfor _ in range(M):\n    a_tmp, b_tmp = map(int, input().split())\n    a.append(a_tmp)\n    b.append(b_tmp)\n    c.append(list(map(int, input().split())))\n\nc_bin = []\nfor i in range(M):\n    c_bin.append(sum([1 << (cij - 1) for cij in c[i]]))\n    \nmemo = [None] * (1 << N)\n\ndef dp(state):\n    nonlocal MY_INF\n    if state == (1 << N) - 1: return 0\n    if memo[state] != None: return memo[state]\n    #\n    rets = [MY_INF]\n    for i in range(M):\n        if (state | c_bin[i]) > state:\n            rets.append(a[i] + dp((state | c_bin[i])))\n    ret = min(rets)\n    #\n    memo[state] = ret\n    return ret\n\nans = dp(0)\nif ans != MY_INF:\n    print(ans)\nelse:\n    print(-1)", "def main():\n  n,m=map(int,input().split())\n  inf=10**9\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  \n  #cost=[inf for i in range(m)]\n  for i in range(m):\n    a,b=map(int,input().split())\n    c=[int(x)-1 for x in input().split()]\n    t=0\n    for j in c:\n      t|=1<<j\n    #cost[i]=[s,a]\n    for s in range(1<<n):\n      dp[t|s]=min(dp[t|s], dp[s]+a)\n    \n  #print(cost)\n  \"\"\"\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for s in range(1<<n):\n    for bit,c in cost:\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n  #print(dp)\n  \"\"\"\n  #print(dp)\n  print(-1 if dp[-1]==inf else dp[-1])\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef main():\n    n,m=map(int,input().split())\n    dp=[10**10]*(1<<n)\n    dp[0]=0\n    for i in range(m):\n        a,b=map(int,input().split())\n        C=list(map(int,input().split()))\n        d=0\n        for c in C:\n            d|=1<<(c-1)\n        for j in range(1<<n):\n            dp[j|d]=min(dp[j|d],dp[j]+a)\n    if dp[-1]==10**10:\n        print(-1)\n    else:\n        print(dp[-1])\n        \ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    inf = 10 ** 8 + 1\n    N, M = list(map(int, input().split()))\n\n    dp = [inf] * (1 << N)\n    dp[0] = 0\n\n    for _ in range(M):\n        price, _ = list(map(int, input().split()))\n        c = (int(x) - 1 for x in input().split())\n        k = sum(1 << x for x in c)\n        for bit in reversed(list(range(1 << N))):\n            nbit = bit | k\n            dp[nbit] = min(dp[nbit], dp[bit] + price)\n\n    ans = dp[(1 << N) - 1]\n    if ans == inf:\n        print((-1))\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n# import sys\n#\n# sys.setrecursionlimit(10 ** 7)\n#\n# input = sys.stdin.readline\n# rstrip()\n# int(input())\n# map(int, input().split())\n\n__starting_point()", "n, m = map(int, input().split())\ndp = [float(\"inf\") for i in range(1 << n)]\ndp[0] = 0\nfor i in range(m):\n    a, b = map(int, input().split())\n    c = list(map(int, input().split()))\n    bit = 0\n    for j in range(b):\n        bit |= 1 << (c[j] - 1)\n    for j in range(1 << n):\n        dp[j | bit] = min(dp[j | bit], dp[j] + a)\nif dp[-1] == float(\"inf\"):\n    print(\"-1\")\nelse:\n    print(dp[-1])", "# -*- coding: utf-8 -*-\n\"\"\"\nE - Get Everything\nhttps://atcoder.jp/contests/abc142/tasks/abc142_e\n\n\"\"\"\nimport sys\n\n\ndef solve(N, M):\n    dp = [float('inf')] * 2**N\n    dp[0] = 0\n    for y in range(1, M+1):\n        a, b = list(map(int, input().split()))\n        c = [int(i) for i in input().split()]\n        t = 0\n        for cc in c:\n            t |= (1 << (cc-1))\n        for x in range(2**N):\n            if dp[x|t] > dp[x] + a:\n                dp[x|t] = dp[x] + a\n    return -1 if dp[-1] == float('inf') else dp[-1]\n\n\ndef main(args):\n    N, M = list(map(int, input().split()))\n    ans = solve(N, M)\n    print(ans)\n\n\ndef __starting_point():\n    main(sys.argv[1:])\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\n\nINF = 10**8\ndp = [INF] * ((1 << n) + 1)\ndp[0] = 0\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    c = sum(1 << (ci - 1) for ci in map(int, input().split()))\n\n    for j in range(1 << n):\n        # if dp[j] + a < dp[j | c]:\n        #     dp[j | c] = dp[j] + a\n        dp[j | c] = min(dp[j] + a, dp[j | c])\n\nans = -1 if dp[(1 << n) - 1] == INF else dp[(1 << n) - 1]\n\nprint(ans)\n", "def main():\n    n, m = list(map(int, input().split()))\n    DP = [10**9] * 2**n\n    DP[0] = 0\n    updated_patterns = {0}\n    for _ in range(m):\n        cost, types = list(map(int, input().split()))\n        to_open = list(map(int, input().split()))\n\n        openable = 0\n        for open in to_open:\n            openable += 1 << (open-1)\n        new_updated = set()\n        for opened in updated_patterns:\n            pattern = opened | openable\n            new_cost = DP[opened] + cost\n            if DP[pattern] > new_cost:\n                DP[pattern] = new_cost\n                new_updated.add(pattern)\n\n        updated_patterns |= new_updated\n\n    full_open = 2**n - 1\n    ans = DP[full_open]\n    if ans == 10 ** 9:\n        ans = -1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nINF = 10 ** 10\ndp = [INF] * (2 ** N)\ndp[0] = 0\n\nfor i in range(M):\n  a,b = map(int,readline().split())\n  c = list(map(int,readline().split()))\n  key = 0\n  for j in range(len(c)):\n    key += (1 << (c[j] - 1))\n  for j in range(len(dp)):\n    if dp[j] == INF:\n      continue\n    if j | key == j:\n      continue\n    if dp[j | key] > dp[j] + a:\n      dp[j | key] = dp[j] + a\n\nif dp[-1] == INF:\n  print(-1)\nelse:\n  print(dp[-1])", "import sys\nimport re\nimport math\nimport collections\nimport decimal\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    n, m = ns()\n    d = []\n    for _ in range(m):\n        ai, bi = ns()\n        ci = na()\n        d.append([ai, bi, ci])\n\n    # bit DP\n    # dp[i] = i\u306e\u5404bit\u304c1\u3067\u3042\u308b\u756a\u76ee\u306e\u5b9d\u7bb1\u3092\u958b\u3051\u3089\u308c\u308b\u72b6\u614b\u3068\u306a\u308c\u308b\u6700\u5c0f\u30b3\u30b9\u30c8\n    dp = [INF for _ in range(2 ** n)]\n    dp[0] = 0\n\n    for ai, bi, ci in d:\n        getkey = 0\n        for cii in ci:\n            cii -= 1\n            getkey += 1 << cii\n\n        for i in range(2 ** n):\n            dp[i | getkey] = min(dp[i | getkey], dp[i] + ai)\n\n    tmp = dp[2 ** n - 1]\n    print((tmp if tmp != INF else -1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, M, ABCi):\n    inf = 10 ** 5 * 12 * 2\n    for i in range(M):\n        C = ABCi[i][2]\n        ABCi[i][2] = sum([2 ** (c - 1) for c in C])\n    # dp[i\u756a\u76ee\u307e\u3067\u306e\u30ab\u30ae\u3060\u3051\u8cfc\u5165\u3057\u305f\u3068\u304d\u306b][bin(j)\u306e\u5b9d\u7bb1\u304c\u958b\u3051\u3089\u308c\u308b\u6700\u5c0f\u91d1\u984d]\n    dp = [[inf] * (2 ** N) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, M + 1):\n        for j in range(2 ** N):\n            a, b, c = ABCi[i - 1]\n            dp[i][j] = min(dp[i - 1][(c & j) ^ j] + a, dp[i - 1][j])\n    ans = min([x[2 ** N - 1] for x in dp])\n    if ans == inf:\n        ans = -1\n    print(ans)\n\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    ABCi = [\n        [int(i) for i in input().split()] + [[int(i) for i in input().split()]]\n        for _ in range(M)]\n    solve(N, M, ABCi)\n\n    # # test\n    # from random import randint, sample\n    # from func import random_str\n    # N, M = 12, 10 ** 3\n    # tmp = [i for i in range(1, N + 1)]\n    # ABCi = [[randint(1, 10 ** 5), randint(1, N)] for _ in range(M)]\n    # print(ABCi)\n    # for i in range(M):\n    #     ABCi[i].append(sample(tmp, ABCi[i][1]))\n    # solve(N, M, ABCi)\n\n__starting_point()", "N,M = map(int,input().split())\nkey = []\nfor i in range(M):\n  a,b = map(int,input().split())\n  C = list(map(int,input().split()))\n  s = 0\n  for i in range(b):\n    C[i] -=1 #oindex\n    s = s|1<<C[i] #\u305d\u308c\u305e\u308c\u306e\u5b9d\u7bb1\u306e\u756a\u53f7\u3067\u5de6\u30b7\u30d5\u30c8\u3057\u3066or\u3092\u3068\u308b\u3053\u3068\u3067\u3069\u306e\u5b9d\u7bb1\u3092\u958b\u3051\u3089\u308c\u308b\u304b\u3092\u4fdd\u5b58\u3002\n  key.append((s,a)) #\u958b\u3051\u3089\u308c\u308b\u5b9d\u7bb1\u3068\u30b3\u30b9\u30c8\u3092\u4fdd\u5b58\n#print(key)\nINF = float(\"inf\")  \ndp = [INF for _ in range(1<<N)]\ndp[0] = 0\n#\u914d\u308bDP O(2^N*M)\nfor s in range(1<<N): #\u5c0f\u3055\u3044\u9806\u304b\u3089\u3084\u308b\u3068\u3046\u307e\u304f\u9077\u79fb\u304c\u3067\u304d\u308b\u3002\n  for i in range(M): #\u3059\u3079\u3066\u306e\u30ab\u30ae\u306b\u3064\u3044\u3066\u9077\u79fb\u3092\u8a66\u3059\u3002\n    t = s|key[i][0] #\u73fe\u5728\u306e\u5b9d\u7bb1\u306e\u72b6\u614bs\u306b\u5bfe\u3057\u3066\u3001\u65b0\u3057\u3044\u9375\u3092\u52a0\u3048\u305f\u3068\u304d\u306b\u958b\u3051\u3089\u308c\u308b\u5b9d\u7bb1\u306e\u72b6\u614b\u3002 \n    dp[t] = min(dp[t],dp[s] + key[i][1])\n#print(dp)\nif dp[-1] == INF:\n  ans = -1\nelse:\n  ans = dp[-1]\nprint(ans)", "def chmin(l, i, v):\n  if l[i] > v:\n    l[i] = v\n    return True\n  return False\n\ndef main():\n    N, M = map(int, input().split())\n    keys = []\n    for i in range(M):\n        a, b = map(int, input().split())\n        C = map(int, input().split())\n        # mask: n\u30d3\u30c3\u30c8\u76ee\u304c1\u306a\u3089\u3001n\u756a\u76ee\u306e\u30ab\u30ae\u3092\u958b\u3051\u3089\u308c\u308b\n        mask = 0\n        for c in C:\n            mask |= 1 << (c-1)\n        keys.append((a, mask))\n    \n    # N \u500b\u306e\u30ab\u30ae\u3092\u9078\u3076\u3001\u9078\u3070\u306a\u3044\u306e\u30d1\u30bf\u30fc\u30f3\u3092\u8003\u3048\u308b\u3068\u3001\u305d\u306e\u7d44\u307f\u5408\u308f\u305b\u306f2^N \u901a\u308a\n    # \u30b3\u30b9\u30c8\u7121\u9650\u5927\u3067\u521d\u671f\u5316\n    patterns = 1 << N\n    INF = float(\"inf\")\n    # dp[i]: i\u306en\u30d3\u30c3\u30c8\u76ee\u304c1\u306a\u3089\u3001n\u756a\u76ee\u306e\u30ab\u30ae\u3092\u958b\u3051\u3089\u308c\u3066\u3001\u305d\u306e\u958b\u3051\u3089\u308c\u308b\u30ab\u30ae\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u306e\u6700\u5b89\u5024\u3092\u793a\u3057\u3066\u3044\u308b\n    # \u4f8b: dp[3]: 1\u756a\u76ee\u30682\u756a\u76ee\u306e\u30ab\u30ae\u3092\u3042\u3051\u305f\u3044\u3068\u304d\u306e\u6700\u5b89\u5024\n    dp = [ INF ] * patterns\n    dp[0] = 0\n\n    # \u8a08\u7b97\u91cf: O(2^N * M) => \u6700\u5927\u3067\u3082 4096 * 10^3 ~= 10^6\n    for a, mask in keys:\n        for i in range(patterns):\n            chmin(dp, i|mask, dp[i] + a)\n\n    ans = dp[patterns-1]\n    print(-1 if ans == INF else ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN, M = MAP()\n\nkey_lis = []\nkey_cost = []\n\nfor _ in range(M):\n\ta, b = MAP()\n\tc = LIST()\n\tkey = 0\n\tfor x in c:\n\t\tkey += 2**(x-1)\n\tkey_lis.append(key)\n\tkey_cost.append(a)\n\n\ndp = [INF]*(1<<N)\ndp[0] = 0\n\nfor S in range(1<<N):\n\tfor i, key in enumerate(key_lis):\n\t\tdp[S|key] = min(dp[S|key], dp[S]+key_cost[i])\n\nif dp[-1] == INF:\n\tprint(-1)\nelse:\n\tprint(dp[-1])", "n,m=list(map(int,input().split()))\ng=(1<<n)\n\ndp=[float(\"inf\")]*g\ndp[0]=0\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    c_l=list(map(int,input().split()))\n    f=0\n    for c_i in c_l:\n        f+=1<<(c_i-1)\n    for j in range(g-1, -1, -1):\n        dp[j|f]=min(dp[j]+a, dp[j|f])\n\nprint((-1 if dp[-1]==float(\"inf\") else dp[-1]))\n", "n,m = map(int, input().split())\n\nabcsl = []\nfor _ in range(m):\n    a,b = map(int, input().split())\n    cl = list(map(int, input().split()))\n    abcsl.append((a,b,cl))\n\n# dp = [ [10**9]*(2**n) for _ in range(m) ]\ndp = [10**9]*(2**n)\ndp[0] = 0\nfor a,b,cl in abcsl:\n    b_bit = 0\n    for c in cl:\n        b_bit += 2**(c-1)\n    for i in range(2**n):\n        dp[i|b_bit] = min(dp[i]+a, dp[i|b_bit])\n\nif dp[2**n-1] == 10**9:\n    print(-1)\nelse:\n    print(dp[2**n-1])", "N,M = map(int,input().split())\nINF = 10 ** 10\ndp = [INF] * (2 ** N)\ndp[0] = 0\n\nfor i in range(M):\n  a,b = map(int,input().split())\n  c = list(map(int,input().split()))\n  key = 0\n  for j in range(len(c)):\n    key += (1 << (c[j] - 1))\n  for j in range(len(dp) - 1, -1, -1):\n    if dp[j] == INF:\n      continue\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\nprint((dp[-1], -1)[dp[-1] == INF])", "n, m = map(int, input().split())\nkeys = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    s = 0\n    for c in map(int, input().split()):\n        c -= 1\n        s |= 1 << c\n    keys.append((s, a))\n\nINF = 1001001001\ndp = [INF] * (1<<n)\ndp[0] = 0\nfor s in range(1<<n):\n    for k, v in keys:\n        t = s | k\n        cost = dp[s] + v\n        dp[t] = min(dp[t], cost)\n\nans = dp[-1]\nif ans == INF: ans = -1\nprint(ans)", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    L = pow(2, N)\n    Dist = [10 ** 20] * L\n    \n    Dist[0] = 0\n    for _ in range(M):\n        a, b = map(int, input().split())\n        bit = 0\n        C = [int(c) for c in input().split()]\n        for c in C: bit += pow(2, c-1)\n        for k in range(L):\n            if Dist[k] < 10 ** 20: Dist[k | bit] = min(Dist[k | bit], Dist[k] + a)\n    if Dist[L - 1] == 10 ** 20: print(-1)\n    else: print(Dist[L - 1])\n\n\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, m = map(int, input().split())\na = [None]*m\nc = [0]*m\nfor i in range(m):\n    a[i], b = map(int, input().split())\n    ls = list(map(int,input().split()))\n    for j in ls:\n        c[i] |= 1<<(j-1)\nn2 = 1<<n\ndp = [1e9]*(n2)\ndp[0] = 0\nfor i in range(m):\n    for S in range(n2):\n        if dp[S|c[i]] > dp[S]+a[i]:\n            dp[S|c[i]] = dp[S]+a[i]\nif dp[(n2)-1] < 1e9:\n    print(dp[(n2)-1])\nelse:\n    print(-1)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n\n    dp = [INF for i in range(1 << N)]\n    dp[0] = 0\n\n    key = []\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        C = tuple([int(x) - 1 for x in input().split()])\n        status = 0\n        for c in C:\n            status += 2 ** c\n        key.append((a, status))\n\n    for a, status in key:\n        if dp[status] > a:\n            dp[status] = a\n\n    for i in range(2 ** N - 1):\n        for a, status in key:\n            new_status = status | i\n            if dp[new_status] > dp[i] + a:\n                dp[new_status] = dp[i] + a\n\n    if dp[-1] == INF:\n        print((-1))\n    else:\n        print((dp[-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\nkeys = []\n\nfor _ in range(m):\n    cost, types = list(map(int, input().split()))\n    to_open = list(map(int, input().split()))\n    keys.append([cost, to_open])\n\nDP = [10**9] * (2**n)\nDP[0] = 0\n\nfor cost, (to_open) in keys:\n    openable = 0\n    for open in to_open:\n        openable |= 1 << (open-1)\n\n    for opened in range(2 ** n):\n        pattern = opened | openable\n        DP[pattern] = min(DP[pattern], DP[opened] + cost)\n\nfull_open = 2**n - 1\nans = DP[full_open]\n\nif ans == 10 ** 9:\n    ans = -1\n\nprint(ans)\n", "MOD = 10 ** 9 + 7\nINF = 10 ** 11\nimport sys\nsys.setrecursionlimit(100000000)\n\ndef main():\n    N,M = list(map(int,input().split()))\n    key = []\n    for _ in range(M):\n        a,b = list(map(int,input().split()))\n        c = list(map(int,input().split()))\n        can_open = 0\n        for i in c:\n            can_open ^= 1<<(i - 1)\n        key.append((a,can_open))\n    \n    dp = [[INF] * (1<<N) for _ in range(M + 1)]\n    for i in range(M):\n        dp[i][0] = 0\n    \n    for i in range(M):\n        price,can_open = key[i]\n        for s in range(1,1<<N):\n            dp[i + 1][s] = min(dp[i][s],dp[i][(s&can_open)^s] + price)\n    print((dp[-1][-1] if dp[-1][-1] != INF else -1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\ndp = [float('inf')] * (2 ** n)\ndp[0] = 0\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    c = sum(1 << (i - 1) for i in map(int, input().split()))\n    for j in range(2 ** n):\n        if dp[c | j] > dp[j] + a:\n            dp[c | j] = dp[j] + a\n\nif dp[-1] == float('inf'):\n    ans = -1\nelse:\n    ans = dp[-1]\nprint(ans)\n", "n,m=map(int,input().split())\nkey=[]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  c=list(map(int,input().split()))\n  bi=0\n  for i in c:\n    bi+=1<<(i-1)\n  key.append([a,bi])\n#print(key)\n\nINF=2**24\ndp=[INF]*(1<<n)\ndp[0]=0\nfor k in key:\n  for b in range(1<<n):\n    dp[b|k[1]]=min(dp[b|k[1]],dp[b]+k[0])\n    #print(b,k[1],b|k[1],dp)\n    \nprint(-1 if dp[-1]==INF else dp[-1])", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef main():\n\tN, M = MAP()\n\tdp = [INF]*(1<<N)\n\tdp[0] = 0\n\n\tfor _ in range(M):\n\t\ta, b = MAP()\n\t\tc = LIST()\n\t\ttmp = 0\n\t\tfor x in c:\n\t\t\ttmp = tmp|1<<(x-1)\n\t\tfor S in range(1<<N):\n\t\t\tdp[S|tmp] = min(dp[S|tmp], dp[S]+a)\n\n\tprint((dp[-1] if dp[-1] != INF else -1))\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "N,M=map(int,input().split())\ndp=[10**10]*(1<<N)\ndp[0]=0\nfor i in range(M):\n  a,b=map(int,input().split()) \n  c=list(map(int, input().split()))\n  d=0\n  for j in c:\n    d|=1<<j-1\n  for k in range(1<<N):\n    dp[k|d]=min(dp[k|d],dp[k]+a)\nif dp[-1]==10**10:\n  print(-1)\nelse:\n  print(dp[-1])", "INF = 10**9\nn, m = list(map(int, input().split()))\nkeys = []\nfor _ in range(m):\n    a, _ = list(map(int, input().split()))\n    c = 0\n    for i in input().split():\n        c += 2**(int(i)-1)\n    keys.append((a, c))\n\ndp = [INF]*(2**n)\ndp[0] = 0\nfor a, c in keys:\n    tmp = [INF]*(2**n)\n    for j, d in enumerate(dp):\n        if d == INF:\n            continue\n        if d < tmp[j]:\n            tmp[j] = d\n        if d+a < tmp[j|c]:\n            tmp[j|c] = d+a\n    dp = tmp\n\nprint((dp[-1] if dp[-1]<INF else -1))\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    A, C = [], []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        A.append(a)\n        key = 0\n        for c in map(int, input().split()):\n            key |= 1 << (c - 1)\n        C.append(key)\n\n    dp = [f_inf] * (1 << n)\n    dp[0] = 0\n    for S in range(1 << n):\n        for i in range(m):\n            key, cost = C[i], A[i]\n            dp[S | key] = min(dp[S | key], dp[S] + cost)\n    print((dp[-1] if dp[-1] != f_inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,m = map(int,input().split())\nINF = 10**10\n\nB = [INF]*(1<<n)\nB[0] = 0\n\nfor _ in range(m):\n  a,b = map(int,input().split())\n  C = list(map(int,input().split()))\n  opens = 0\n  for c in C:\n    opens |= (1<<(c-1))\n  \n  for i in range(2**n):\n    if B[i|opens] > B[i]+a:\n      B[i|opens] = B[i]+a\n\nif B[(1<<n)-1]==INF:\n  print(-1)\nelse:\n  print(B[(1<<n)-1])", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    A = [0] * M\n    C = [0] * M\n    for i in range(M):\n        A[i], _ = list(map(int, input().split()))\n        C[i] = sum(2 ** (int(c) - 1) for c in input().split())\n\n    INF = 10 ** 18\n    dp = [INF] * (2 ** N)\n    dp[0] = 0\n    for a, c in zip(A, C):\n        for s in range(2 ** N):\n            dp[s | c] = min(dp[s | c], dp[s] + a)\n\n    ans = dp[-1] if dp[-1] != INF else -1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\n\ndef main():\n    n,m=list(map(int,input().split()))\n\n    L=2**n\n\n    cost=[0]+[10**8 for i in range(L-1)]\n\n    for _ in range(m):\n        a,b = list(map(int,input().split()))\n\n        c = sum([2**(int(x)-1) for x in input().split()])\n        for i in range(L):\n            q = c|i\n            cost[q] = min(cost[q], cost[i]+a)\n    print((cost[L-1] if cost[L-1]<10**8 else -1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\ncan_open = []\ncost = []\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    cost.append(a)\n    can_open.append(sum(1 << (c-1) for c in map(int, input().split())))\n\nn_bit = 1 << n\nINF = 10**18\ndp = [INF]*n_bit\ndp[0] = 0\n\nfor x, y in zip(can_open, cost):\n    for j in range(n_bit):\n        m = j | x\n        z = dp[j]+y\n        if dp[m] > z:\n            dp[m] = z\n\nprint((dp[-1] if dp[-1] != INF else -1))\n", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**18\neps = 10**-7\n\nN,M = list(map(int,readline().split()))\nk = 2**N\ndp = [INF]*k \ndp[0] = 0\n\nfor i in range(M):\n    a,b = list(map(int,readline().split()))\n    c = list(map(int,readline().split()))\n    d = sum(1<<(ci-1) for ci in c)\n    dpnew = dp[:]\n    for j in range(k):\n        dpnew[j|d] = min(dp[j]+a,dpnew[j|d])\n    dp = dpnew\n\nprint((dp[2**N-1] if dp[2**N-1] != INF else -1))\n\n\n", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nkeys = [None] * M\nfor i in range(M):\n  cost,b = map(int,readline().split())\n  bit = 0\n  target = list(map(int,readline().split()))\n  for t in target:\n    bit += (1 << (t - 1))\n  keys[i] = (cost, bit)\n    \n# \u5168\u3066\u306e\u9375\u306e\u7d44\u307f\u5408\u308f\u305b\u3067DP\nINF = 10 ** 8 + 1\ndp = [INF for i in range(2 ** N)]\ndp[0] = 0\nfor key in keys:\n  cost, bit = key\n  for j in range(len(dp) - 1, -1, -1):\n    if dp[j] == -1:\n      continue\n    if dp[j | bit] > dp[j] + cost:\n      dp[j | bit] = dp[j] + cost\n\nif dp[-1] == INF:\n  print(-1)\nelse:\n  print(dp[-1])", "from itertools import product\nimport sys\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\ncan_open = []\ncost = []\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    cost.append(a)\n    can_open.append(sum(1 << (c-1) for c in map(int, input().split())))\n\nn_bit = 1 << n\nINF = 10**18\ndp = [INF]*n_bit\ndp[0] = 0\n\nfor j, (x, y) in product(list(range(n_bit)), list(zip(can_open, cost))):\n    m = j | x\n    z = dp[j]+y\n    if dp[m] > z:\n        dp[m] = z\n\nprint((dp[-1] if dp[-1] != INF else -1))\n", "def main():\n    n,m=map(int,input().split())\n    a=[0]*m\n    c=[0]*m\n    INF=10**9\n    dp=[INF]*2**n\n    for i in range(m):\n        a[i]=int(input().split()[0])\n        c[i]=sum([1<<(int(i)-1) for i in input().split()])\n    dp[0]=0\n    for i in range(2**n):\n        for cos,pat in zip(a,c):\n            npat=i|pat\n            if dp[npat]>cos+dp[i]:\n                dp[npat]=cos+dp[i]\n    if dp[2**n-1]==INF:\n        print(-1)\n    else:\n        print(dp[2**n-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m = map(int, input().split())\ndp = [0]*(2**n + 1)\nfor i in range(m):\n  a,b = map(int, input().split())\n  c = list(map(int, input().split()))\n  temp=0\n  for i in c:\n    temp += 2 ** (i-1)\n  for i in range(2**n):\n    if i != 0 and dp[i] == 0:\n      continue\n    t = i | temp\n    if dp[t] == 0:\n      dp[t] = dp[i] + a\n    else:\n      dp[t] = min(dp[i] + a, dp[t])\n\nans = dp[2**n - 1]\nif ans == 0:\n  print(-1)\nelse:\n  print(ans)", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    Dist = [10 ** 20] * pow(2, N)\n    Dist[0] = 0\n    for _ in range(M):\n        a, b = map(int, input().split())\n        C = [int(c) for c in input().split()]\n        binaryC = 0\n        for c in C: binaryC += pow(2, c-1)\n        for j, d in enumerate(Dist):\n            if d < 10 ** 20: Dist[j | binaryC] = min(Dist[j | binaryC], Dist[j] + a)\n    print(Dist[-1] if Dist[-1] < 10 ** 20 else -1)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "def main():\n    import numpy as np\n\n    n, m = list(map(int, input().split()))\n    dp = np.full(2**n, 10**9, dtype=np.int64)\n    dp[0] = 0\n    opened = np.arange(2**n)\n\n    for _ in range(m):\n        cost, types = list(map(int, input().split()))\n        to_open = np.array(list(map(int, input().split())), dtype=np.int64)\n\n        openable = np.left_shift(1, to_open-1).sum()\n        new_indexes = opened | openable\n        new_costs = dp + cost\n        sort_index = np.argsort(new_costs)\n        new_costs.sort()\n        update_pattern, idx = np.unique(new_indexes[sort_index], return_index=True)\n        update_cost = new_costs[idx]\n        dp[update_pattern] = np.minimum(dp[update_pattern], update_cost)\n\n    full_open = 2**n - 1\n    ans = dp[full_open]\n    if ans == 10 ** 9:\n        ans = -1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    keys = []\n    for _ in range(m):\n        bit = [\"0\"] * n\n        a, b = list(map(int, input().split()))\n        C = list(map(int, input().split()))\n        for c in C:\n            bit[c - 1] = \"1\"\n        bit = int(\"\".join(bit), 2)\n        keys.append([bit, a])\n\n    dp = [f_inf] * (1 << n)\n    dp[0] = 0\n    for i in range(1 << n):\n        for k, cost in keys:\n            idx = i | k\n            dp[idx] = min(dp[idx], dp[i] + cost)\n\n    print((dp[-1] if dp[-1] != f_inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    n, m = map(int, input().split())\n    price = [0]*m\n    typesnum = [0]*m\n    keybit=[0]*m\n    for i in range(m):\n        price[i], typesnum[i] = map(int, input().split())\n        keybit[i] = sum(map(lambda x: 2**(int(x)-1), input().split()))\n    dp = [10**9]*(1 << n)\n    dp[0]=0\n    for bit in range(1 << n):\n        for i in range(m):\n            dp[bit | keybit[i]] = min(dp[bit | keybit[i]], dp[bit]+price[i])\n    if dp[-1] == 10**9:\n        dp[-1] = -1\n    print(dp[-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    ABC = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        C = list(map(int, input().split()))\n        s = [\"0\"] * n\n        for c in C:\n            s[c - 1] = \"1\"\n\n        c = \"\".join(s[::-1])\n        ABC.append([a, b, int(c, 2)])\n\n    dp = [f_inf for _ in range(1 << n)]\n    dp[0] = 0\n    for a, b, c in ABC:\n        for i in range(1 << n):\n            idx = i | c\n            dp[idx] = min(dp[idx], dp[i] + a)\n\n    if dp[-1] == f_inf:\n        print((-1))\n    else:\n        print((dp[-1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nINF = 10**6\n\nn, m = list(map(int, input().split()))\ndp = [INF] * (2**n)\ndp[0] = 0\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    bit = ['0'] * n\n    for x in set(map(int, input().split())):\n        bit[x-1] = '1'\n    bit = int(''.join(bit[::-1]), 2)\n    for j in range(2**n-1, -1, -1):\n        dp[j|bit] = min(dp[j|bit], a + dp[j])\nif dp[-1] == INF:\n    print((-1))\nelse:\n    print((dp[-1]))\n", "N,M = map(int,input().split())\nCOST = []\nB = []\nC = []\nC_bit = []\nINF = 10**18\ndp = [INF]*(1<<N)\ndp[0] = 0\n\nfor _ in range(M):\n  a,b = map(int,input().split())\n  C.append(list(map(int,input().split())))\n  COST.append(a)\n  B.append(b)\n\nfor i in range(M):\n  bit = ['0']*N\n  for j in range(B[i]):\n    bit[C[i][j]-1] = '1'\n  bit_int = int(''.join(bit),2)\n  C_bit.append(bit_int)\n\nfor cost,c in zip(COST,C_bit):\n  for i in range(1<<N):\n    j = i|c\n    d = dp[i]+cost\n    if dp[j] > d:\n      dp[j] = d\n\nif dp[-1] == INF:\n  print(-1)\nelse:\n  print(dp[-1])", "n,m=map(int,input().split())\nkey=[]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  c=list(map(int,input().split()))\n  bi=0\n  for i in c:\n    bi+=2**(i-1)\n  key.append([a,bi])\ndp=[10**10]*(2**n)\ndp[0]=0\nfor k in key:\n  for b in range(2**n):\n    dp[b|k[1]]=min(dp[b|k[1]],dp[b]+k[0])\nif dp[-1]==10**10:\n  print(-1)\nelse:\n  print(dp[-1])", "def main():\n    n, m = list(map(int, input().split()))\n    all_patterns = 2**n\n    DP = [10**9] * all_patterns\n    DP[0] = 0\n    for _ in range(m):\n        cost, types = list(map(int, input().split()))\n        to_open = list(map(int, input().split()))\n\n        openable = 0\n        for open in to_open:\n            openable += 1 << (open-1)\n\n        for opened in range(all_patterns):\n            pattern = opened | openable\n            new_cost = DP[opened] + cost\n            if DP[pattern] > new_cost:\n                DP[pattern] = new_cost\n\n    full_open = 2**n - 1\n    ans = DP[full_open]\n    if ans == 10 ** 9:\n        ans = -1\n        \n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!usr/bin/env python3\nimport sys\n\nMOD = 10 ** 9 + 7\nINF = 10 ** 18\ninput = lambda: sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 8)\n\n\ndef main():\n    N, M = map(int, input().split())\n    keys = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        bits = sum([1 << (i - 1) for i in map(int, input().split())])\n        keys.append([a, bits])\n\n    dp = [INF] * (2 ** N + 10)\n    dp[0] = 0\n\n    for i in range(M):\n        for j in range(2 ** N):\n            dp[j | keys[i][1]] = min(dp[j | keys[i][1]], dp[j] + keys[i][0])\n    print(dp[2 ** N - 1] if dp[2 ** N - 1] != INF else -1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    INF = 10**10\n\n    N, M = list(map(int, input().split()))\n    keys = []\n    costs = []\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        costs.append(a)\n        cs = list(map(int, input().split()))\n        key = 0\n        for c in cs:\n            key |= 1<<(c-1)\n        keys.append(key)\n\n    dp = [INF] * (1<<N)\n    dp[0] = 0\n    for key, cost in zip(keys, costs):\n        for S in reversed(list(range(1<<N))):\n            S2 = S | key\n            c2 = dp[S] + cost\n            if c2 < dp[S2]:\n                dp[S2] = c2\n\n    if dp[-1] == INF:\n        print((-1))\n    else:\n        print((dp[-1]))\n\n\nsolve()\n", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nINF = 10 ** 10\ndp = [INF] * (2 ** N)\ndp[0] = 0\n\nfor i in range(M):\n  a,b = map(int,readline().split())\n  c = list(map(int,readline().split()))\n  key = 0\n  for j in range(len(c)):\n    key += (1 << (c[j] - 1))\n  for j in range(len(dp)):\n    if dp[j] == INF:\n      continue\n    if j | key == j:\n      continue\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\nif dp[-1] == INF:\n  print(-1)\nelse:\n  print(dp[-1])", "import sys\n\ninput = sys.stdin.readline\nINF = float(\"inf\")\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    keys = [None] * M\n    for i in range(M):\n        a, b = list(map(int, input().split()))\n        s = 0\n        for c in map(int, input().split()):\n            c -= 1\n            s |= 1 << c\n        keys[i] = (s, a)\n\n    dp = [INF] * (2 ** N)\n    dp[0] = 0\n    for s in range(2 ** N):\n        for key, a in keys:\n            t = s | key\n            dp[t] = min(dp[t], dp[s] + a)\n\n    ans = dp[-1] if dp[-1] != INF else -1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n  n,m=map(int,input().split())\n  inf=10**9\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  \n  #cost=[inf for i in range(m)]\n  for i in range(m):\n    a,b=map(int,input().split())\n    c=[1<<(int(x)-1) for x in input().split()]\n    t=sum(c)\n    #cost[i]=[s,a]\n    for s in range(1<<n):\n      dp[t|s]=min(dp[t|s], dp[s]+a)\n    \n  #print(cost)\n  \"\"\"\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for s in range(1<<n):\n    for bit,c in cost:\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n  #print(dp)\n  \"\"\"\n  #print(dp)\n  print(-1 if dp[-1]==inf else dp[-1])\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nfrom collections import defaultdict\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nMOD = 10 ** 9 + 7\nsys.setrecursionlimit(20000000)\nINF = float(\"inf\")\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    key = []\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        C = list([int(x) - 1 for x in input().split()])\n        state = 0\n        for c in C:\n            state += 2 ** c\n        key.append((a, state))\n    dp = [INF for _ in range(2 ** N)]\n    dp[0] = 0\n    for i in range(2 ** N - 1):\n        for k in range(M):\n            state = key[k][1]\n            tmp = dp[i] + key[k][0]\n            if dp[i | state] > tmp:\n                dp[i | state] = tmp\n    if dp[-1] == INF:\n        print((-1))\n    else:\n        print((dp[-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n  N, M = list(map(int, input().split()))\n  inf =  10**15\n  p = 1<<N\n  dp = [inf]*p\n  dp[0] = 0\n  for i in range(M):\n    a, b = list(map(int, input().split()))\n    c = sum(1<<(i-1) for i in map(int, input().split()))\n    for j in range(p):\n      dp[c|j] = min(dp[j]+a, dp[c|j])\n  if dp[-1] == inf:\n    print((-1))\n  else: \n    print((int(dp[-1])))\n  \ndef __starting_point():\n  main()\n\n__starting_point()", "n ,m= list(map(int,input().split()))\nkagi = [[]for _ in range(m)] \n#a\u5186\u3000b\u7a2e\u985e\u958b\u3051\u3089\u308c\u308b\nfor i in range(m):\n    a,b =  list(map(int,input().split()))\n    X =  list(map(int,input().split()))\n    bit = 0\n    for x in X:\n        bit |= 2**(x-1)\n    kagi[i] = [a,bit]\n\nok = 2**n-1#\u5168\u90e8\u7a7a\u3044\u305f\u3089\u3053\u308c\nkagi.sort(key=lambda x: x[1])\nzenkai = 2**n\ndp = [float('inf')]*int(zenkai+1)\ndp[0] = 0\nfor i in range(2**n):\n    if dp[i] == float('inf'):\n        continue\n    for j in range(m):\n        s = i|kagi[j][1]\n        # print(s)\n        dp[s] = min(dp[s],dp[i] + kagi[j][0])\n# print(dp)\nif dp[zenkai-1] == float('inf'):\n    print(-1)\nelse:\n    print(dp[zenkai-1])", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    ABC = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        C = list(map(int, input().split()))\n        bit = [\"0\"] * n\n        for c in C:\n            bit[c - 1] = \"1\"\n\n        bit = \"\".join(bit)\n        ABC.append([a, b, int(bit, 2)])\n\n    dp = [f_inf for _ in range(1 << n)]\n    dp[0] = 0\n    for i in range(1 << n):\n        for a, b, c in ABC:\n            idx = i | c\n            dp[idx] = min(dp[idx], dp[i] + a)\n\n    if dp[-1] != f_inf:\n        print((dp[-1]))\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nimport itertools\n\nN,M = map(int, input().split())\nAB = []\nC = []\nfor _ in range(M):\n    AB.append(tuple(map(int, input().split())))\n    C.append(sum(1<<(int(x)-1) for x in map(int, input().split())))\n\nINF = 10**18\ndp = [INF]*(1<<N)\ndp[0] = 0\n\nfor n,((a,b),c) in itertools.product(range(1<<N), zip(AB,C)):\n    m = n|c\n    x = dp[n] + a\n    if dp[m] > x:\n        dp[m] = x\n\nans = dp[-1]\nif ans == INF:\n    ans = -1\nprint(ans)", "def main():\n  n,m=map(int,input().split())\n  inf=10**9\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  \n  #cost=[inf for i in range(m)]\n  for i in range(m):\n    a,b=map(int,input().split())\n    c=[1<<(int(x)-1) for x in input().split()]\n    t=sum(c)\n    #cost[i]=[s,a]\n    for s in range(1<<n):\n      if dp[t|s]>dp[s]+a:\n        dp[t|s]=dp[s]+a\n      #dp[t|s]=min(dp[t|s], dp[s]+a)\n    \n  #print(cost)\n  \"\"\"\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for s in range(1<<n):\n    for bit,c in cost:\n      dp[s|bit]=min(dp[s|bit], dp[s]+c)\n  #print(dp)\n  \"\"\"\n  #print(dp)\n  print(-1 if dp[-1]==inf else dp[-1])\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nkeys = [None] * M\nfor i in range(M):\n  cost,b = map(int,readline().split())\n  bit = 0\n  target = list(map(int,readline().split()))\n  for t in target:\n    bit += (1 << (t - 1))\n  keys[i] = (cost, bit)\n    \n# \u5168\u3066\u306e\u9375\u306e\u7d44\u307f\u5408\u308f\u305b\u3067DP\nINF = 10 ** 8 + 1\ndp = [INF for i in range(2 ** N)]\ndp[0] = 0\nfor key in keys:\n  cost, bit = key\n  for j in range(len(dp) - 1, -1, -1):\n    if dp[j] == INF:\n      continue\n    if dp[j | bit] > dp[j] + cost:\n      dp[j | bit] = dp[j] + cost\n\nif dp[-1] == INF:\n  print(-1)\nelse:\n  print(dp[-1])", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  U = 2**n\n  dp = [ [float(\"inf\")]*(2**n) for _ in range(m) ]\n  dp[0][0] = 0\n  for i in range(1, m):\n    a, b = map(int, input().split())\n    k = map(int, input().split())\n    c = 0\n    for l in k:\n      c |= 1<<(l-1)\n    for j in range(U):\n      dp[i][j] = min(dp[i-1][j&(~c)]+a, dp[i-1][j])\n\n  if dp[m-1][2**n-1] == float(\"inf\"):\n    print(-1)\n  else:\n    print(dp[m-1][2**n-1])\n    \ndef __starting_point():\n  main()\n__starting_point()", "N,M = map(int,input().split())\ndp = [float('inf')]*2 ** N\ndp[0] = 0\nfor _ in range(M):\n  a, b = map(int, input().split())\n  c = sum([2**(int(i)-1) for i in input().split()])\n  for s in range(2**N):\n    t = s|c\n    if dp[t] > dp[s] + a:\n      dp[t] = dp[s] +a\nans = dp[-1]\nif dp[-1] == float('inf'):\n  print(-1)\nelse:\n  print(ans)", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    L = pow(2, N)\n    Inf = pow(10, 20)\n    Dist = [Inf] * L\n    \n    Dist[0] = 0\n    for _ in range(M):\n        a, b = map(int, input().split())\n        bit = 0\n        C = [int(c) for c in input().split()]\n        for c in C: bit += pow(2, c-1)\n        for k, d in enumerate(Dist):\n            if d < Inf: Dist[k | bit] = min(Dist[k | bit], d + a)\n            \n    print(Dist[L - 1] if Dist[L-1] < Inf else -1)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nINF = 10**6\n\nn, m = list(map(int, input().split()))\ndp = [INF] * (2**n)\ndp[0] = 0\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    bit = ['0'] * n\n    for x in set(map(int, input().split())):\n        bit[x-1] = '1'\n    bit = int(''.join(bit), 2)\n    for j in range(2**n-1, -1, -1):\n        dp[j|bit] = min(dp[j|bit], a + dp[j])\nif dp[-1] == INF:\n    print((-1))\nelse:\n    print((dp[-1]))\n", "n, m = list(map(int, input().split()))\n\nDP = [10**9] * (2**n)\nDP[0] = 0\nfor _ in range(m):\n    cost, types = list(map(int, input().split()))\n    to_open = list(map(int, input().split()))\n\n    openable = 0\n    for open in to_open:\n        openable += 1 << (open-1)\n\n    for opened in range(2 ** n):\n        pattern = opened | openable\n        DP[pattern] = min(DP[pattern], DP[opened] + cost)\n\nfull_open = 2**n - 1\nans = DP[full_open]\n\nif ans == 10 ** 9:\n    ans = -1\n\nprint(ans)\n", "N, M = list(map(int, input().split()))\nK = []\n\nfor _ in range(M):\n    a, _ = list(map(int, input().split()))\n    k = 0\n    for i in [int(a) - 1 for a in input().split()]:\n        k |= (1 << i)\n    K.append((a, k))\n\ndp = [10**18] * (1 << N)\ndp[0] = 0\nfor state in range(1 << N):\n    for a, k in K:\n        if dp[state | k] > dp[state] + a:\n            dp[state | k] = dp[state] + a\nans = dp[(1 << N) - 1]\nprint((ans if ans < 10**18 else -1))\n", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\n\nINF = 10**8\ndp = [INF] * ((1 << n) + 1)\ndp[0] = 0\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    c = sum(1 << (ci - 1) for ci in map(int, input().split()))\n\n    for j in range(1 << n):\n        if dp[j] + a < dp[j | c]:\n            dp[j | c] = dp[j] + a\n        # dp[j | c] = min(dp[j] + a, dp[j | c])\n\nans = -1 if dp[(1 << n) - 1] == INF else dp[(1 << n) - 1]\n\nprint(ans)\n", "def main():\n  N, M = map(int, input().split())\n  inf =  10**9\n  p = 1<<N\n  dp = [inf]*p \n  dp[0] = 0\n  for i in range(M):\n    a, b = map(int, input().split())\n    C = list(map(int, input().split()))\n    c_bit = sum([1<<(c-1) for c in C])\n    for j in range(p):\n      #print(min(dp[i][j|c_bit], dp[i][j] + a))\n      dp[j|c_bit] = min(dp[j|c_bit], dp[j] + a)\n  if dp[p-1] == inf:\n    print(-1)\n  else: \n    print(int(dp[p-1]))\n  \ndef __starting_point():\n  main() \n__starting_point()", "def main():\n  n,m=list(map(int,input().split()))\n  inf=10**9\n  dp=[inf]*(1<<n)\n  dp[0]=0\n  for i in range(m):\n    a,b=list(map(int,input().split()))\n    t=sum([1<<(int(x)-1) for x in input().split()])\n    for s in range(1<<n):\n      dp[t|s]=dp[t|s] if dp[t|s]<=dp[s]+a else dp[s]+a\n  print((-1 if dp[-1]==inf else dp[-1]))\n  \n  \ndef __starting_point():\n  main()\n\n__starting_point()", "n,m = list(map(int,input().split()))\ndp = [2**63]*4096\ndp[0] = 0\nfor i in range(m):\n  a,b = list(map(int,input().split()))\n  mask = 0\n  c = list(map(int,input().split()))\n  for i in c:\n    mask |= ( 1 << i-1 )\n  nxtdp = dp[:]\n  for j in range(1 << n):\n    if dp[j] < 2 ** 63:\n      nxtdp[j | mask] = min(nxtdp[j | mask], dp[j] + a)\n  dp = nxtdp\nprint((dp[(1<<n)-1] if dp[(1<<n)-1] < 2**63 else -1))\n", "N, M = map(int,input().split())\ndp = [float(\"inf\")]*(2**N)\ndp[0] = 0\nfor i in range(1, M+1):\n    a,b = map(int,input().split())\n    c = list(map(int,input().split()))\n    d = 0\n    for j  in range(1, N+1):\n        if j in c:\n            d += 2**(j-1)\n    for j in range(2**N):\n        dp[j | d] = min(dp[j | d], dp[j] + a)\nprint(dp[-1] if dp[-1] != float(\"inf\") else -1)"]
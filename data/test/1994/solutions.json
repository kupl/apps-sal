["s = input()\nn = len(s)\np = [0] * n\nk = 0\nfor i in range(1, n):\n  while k != 0 and s[k] != s[i]:\n    k = p[k - 1]\n  if s[k] == s[i]:\n    k += 1\n  p[i] = k\na = []\nk = n\nwhile k != 0:\n  a += [k]\n  k = p[k - 1]\nc = [0] * (n + 1)\nfor i in range(n):\n  c[p[i]] += 1\nfor i in range(n - 1, 1, -1):\n  c[p[i - 1]] += c[i]\nprint(len(a))\nfor t in reversed(a):\n  print(t, c[t] + 1)", "s = ' ' + input()\nn = len(s)\nr, c = [-1] * n, [1] * n\nfor i in range(1, n):\n    r[i] = r[i - 1] + 1\n    while r[i] and s[r[i]]  != s[i]:\n        r[i] = r[r[i] - 1] + 1\nd, n = [], n - 1\nfor i in range(n, 1, -1): c[r[i]] += c[i]\nwhile n > 0:\n  d.append(str(n) + ' ' + str(c[n]))\n  n = r[n]\nprint(len(d))\nd.reverse()\nprint('\\n'.join(d))", "s=input()\nn=len(s)\np=[0]\nfor i in range(1,n):\n    j=p[i-1]\n    while j>0 and s[j]!=s[i]:\n        j=p[j-1]\n    if s[j]==s[i]:\n        j+=1\n    p.append(j)\na = []\nk = n\nwhile k != 0:\n    a += [k]\n    k = p[k - 1]\nc = [0] * (n + 1)\nfor i in range(n):\n    c[p[i]] += 1\nfor i in range(n - 1, 1, -1):\n    c[p[i - 1]] += c[i]\nprint(len(a))\nfor t in a[::-1]:\n    print(t, c[t] + 1)", "def Count(s, t):\n    res = 0\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i+len(t)] == t:\n            res += 1\n    return res\ns = input()\nn = len(s)\np = [0] * n\nz = [0] * n\nans = [0] * n \n#Prefix \nfor i in range(1, n):\n    p[i] = p[i - 1]\n    while p[i] > 0 and s[i] != s[p[i]]:\n        p[i] = p[p[i] - 1]\n            \n    if s[i] == s[p[i]]:\n        p[i] += 1\n#Z func\nl = r = 0\nfor i in range(1, n):\n    if i <= r:\n        z[i] = min(z[i - l], r - i + 1)\n    while i + z[i] < n and s[i + z[i]] == s[z[i]]: z[i] += 1\n    \n    if i + z[i] - 1 > r:\n        l, r = i, i + z[i] - 1\n\n\n#for i in range(n - 2, -1, -1):\n#    ans[i] += ans[i + 1] + count[i + 1]\n\nfor i in range(n):\n    if z[i] > 0:\n        ans[z[i] - 1] += 1\nfor i in range(n - 2, -1, -1):\n    ans[i] += ans[i + 1] \noutput = []\nfor i in range(n):\n    if z[n - i - 1] == i + 1:\n        output.append((i, ans[i]))\nprint(len(output) + 1)\nfor i in range(len(output)):\n    print(output[i][0] + 1, output[i][1] + 1)\nprint(n, 1)\n", "def Count(s, t):\n    res = 0\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i+len(t)] == t:\n            res += 1\n    return res\n\ns = input()\nn = len(s)\np = [0] * (n + 1)\nz = [0] * n\nans = [0] * (n + 1)\n#Prefix \nfor i in range(1, n):\n    p[i] = p[i - 1]\n    while p[i] > 0 and s[i] != s[p[i]]:\n        p[i] = p[p[i] - 1]\n            \n    if s[i] == s[p[i]]:\n        p[i] += 1\n#Z func\nl = r = 0\nfor i in range(1, n):\n    if i <= r:\n        z[i] = min(z[i - l], r - i + 1)\n    while i + z[i] < n and s[i + z[i]] == s[z[i]]: z[i] += 1\n    \n    if i + z[i] - 1 > r:\n        l, r = i, i + z[i] - 1\n\n\n#for i in range(n - 2, -1, -1):\n#    ans[i] += ans[i + 1] + count[i + 1]\n\nfor i in range(n):\n    ans[p[i]] += 1\n#print(ans)\nfor i in range(n - 1, 0, -1):\n    ans[p[i - 1]] += ans[i]\n   # print(i, ': ', ans) \noutput = []\nfor i in range(n):\n    if z[n - i - 1] == i + 1:\n        output.append((i, ans[i + 1]))\nprint(len(output) + 1)\nfor i in range(len(output)):\n    print(output[i][0] + 1, output[i][1] + 1)\nprint(n, 1)\n", "from itertools import accumulate\n\ndef z_algorithm(s):\n    n = len(s)\n    l, d = 1, 0\n    ans = [0] * n\n    ans[0] = n\n    while l < n:\n        while l + d < n and s[d] == s[l + d]:\n            d += 1\n        ans[l] = d\n        if d == 0:\n            l += 1\n            continue\n        k = 1\n        while l + k < n and k + ans[k] < d:\n            ans[l + k] = ans[k]\n            k += 1\n        l += k\n        d -= k\n    return ans\n\nz = z_algorithm(input())\nn = len(z)\nct = [0] * (n + 1)\nmatch = [False] * (n + 1)\nfor i, v in enumerate(z):\n    ct[v] += 1\n    match[n - i] = (n - i) == v\nfor i in range(n - 1, -1, -1):\n    ct[i] += ct[i + 1]\nbuf = []\nfor i, v in enumerate(ct):\n    if i > 0 and v > 0 and match[i]:\n        buf.append('{} {}'.format(i, v))\nprint(len(buf))\nprint('\\n'.join(buf))\n", "s = str(input())\n\nlps = [0]*100005\ndp = [0]*100005\nada = [0]*100005\ntunda = [0]*100005\n\nn = len(s)\n\ni = 1\nj = 0\nlps[0] = 0\n\nwhile(i < n):\n    if (s[i] == s[j]):\n        j += 1\n        lps[i] = j\n        i += 1\n    elif (j == 0):\n        lps[i] = 0\n        i += 1\n    else:\n        j = lps[j-1]\n\n\nfor i in range(n-1,-1,-1):\n    tunda[i] += 1\n    dp[lps[i]] += tunda[i]\n    if (lps[i]):tunda[lps[i]-1] += tunda[i]\n\nj = n\n\n\"\"\"\nfor i in range(n):\n    print(\"SAD\", i, lps[i])\n\"\"\"\n\nvector = []\n\nwhile(1):\n    vector.append((j,1+dp[j]))\n    j = lps[j-1]\n    if (j == 0): break\n\n\nvector.reverse()\n\nprint(len(vector))\nfor i in vector:\n    print(i[0], i[1])\n", "def prefixFunction(s):\n\tj=0\n\tp=[0 for x in s]\n\tfor i in range(1,len(s)):\n\t\twhile j>0 and s[j]!=s[i]:\n\t\t\tj=p[j-1]\n\t\tif (s[j]==s[i]):j+=1\n\t\tp[i]=j\n\treturn p\ns=input()\np=prefixFunction(s)\nn=len(s)\nfreq=[0 for i in range(n)]\n\nfor i in range(n):\n    freq[p[i]]+=1\n\nfor i in range(n-1,0,-1):\n    freq[p[i-1]]+=freq[i]\n\npos =n-1\nans=[[n,1]]\nwhile pos>0:\n        if p[pos]>1:\n                ans.append([p[pos],freq[p[pos]]+1])\n        pos=p[pos]-1\n\nif len(s)>1 : \n        f= s.count(s[0])\n        if s[0] == s[len(s)-1] : ans.append([1,f])\nprint(len(ans))\nfor i in sorted (ans):\n    print(i[0],i[1])\n\n    \n", "s=input()\nn=len(s)\nif n==1:\n    print('1\\n1 1\\n')\n    return\np=[-1]*n\nq=-1\nfor i in range(1,n):\n    while q>=0 and s[i]!=s[q+1]:\n        q=p[q]\n    if s[i] == s[q + 1]:\n        q+=1\n        p[i]=q\n#print(p)\nc=[1]*n\nfor i in range(n-1,-1,-1):\n    if p[i]>=0:\n        c[p[i]]+=c[i]\n#print(c)\nans=[(n,1)]\nq=p[n-1]\nwhile q>=0:\n    ans.append((q+1,c[q]))\n    q=p[q]\nprint(len(ans))\nprint('\\n'.join([' '.join(map(str,x)) for x in reversed(ans)]))\n", "dep = dict()\n\ndef kmp(st):\n    tam = len(st)\n    pi = [0]*tam\n    for i in range(1,tam):\n        j = pi[i-1]\n        while j > 0 and st[j] != st[i]:\n            j = pi[j-1]\n        if st[j] == st[i]:\n            pi[i] = j + 1\n        dep[pi[i]] = pi[pi[i]-1]\n    return pi\n\n\ns = input()\narr = kmp(s)\npoints = [0] * len(s)\ntoimp = list()\nactpi = arr[-1]\nwhile actpi != 0:\n    toimp.append(actpi)\n    actpi = arr[actpi-1]\n\ntoimp.sort()\nfor i in range(len(arr)):\n    points[arr[i]] += 1\n\nfor i in range(len(s)-1,0, -1):\n    if i in dep:\n        points[dep[i]] += points[i]\n\nprint(len(toimp)+1)\nfor i in toimp:\n    print(str(i) + \" \" + str(points[i]+1))\nprint(str(len(s)) + \" 1\")\n", "import heapq\nfrom bisect import bisect_left, bisect_right, insort\nfrom collections import Counter\nfrom collections import OrderedDict\nfrom collections import deque\nfrom itertools import accumulate, product\n\nimport math\n\nR = lambda: map(int, input().split())\ns = input()\nl, r, z = 0, 0, [0] * len(s)\nfor i in range(1, len(s)):\n    if i > r - 1:\n        l = r = i\n        while r < len(s) and s[r] == s[r - i]:\n            r += 1\n        z[i] = r - l\n    elif z[i - l] < r - i:\n        z[i] = z[i - l]\n    else:\n        l = i\n        while r < len(s) and s[r] == s[r - i]:\n            r += 1\n        z[i] = r - l\nsz = sorted(z[:])\nres = []\nfor i in range(len(s) - 1, 0, -1):\n    if z[i] == len(s) - i:\n        res.append((z[i], len(sz) - bisect_left(sz, z[i])))\nprint(len(res) + 1)\nfor x in res:\n    print(x[0], x[1] + 1)\nprint(len(s), 1)", "\ndef z_advanced(s):\n    \"\"\"An advanced computation of Z-values of a string.\"\"\"\n\n    Z = [0] * len(s)\n    Z[0] = len(s)\n\n    rt = 0\n    lt = 0\n\n    for k in range(1, len(s)):\n        if k > rt:\n            # If k is outside the current Z-box, do naive computation.\n            n = 0\n            while n + k < len(s) and s[n] == s[n + k]:\n                n += 1\n            Z[k] = n\n            if n > 0:\n                lt = k\n                rt = k + n - 1\n        else:\n            # If k is inside the current Z-box, consider two cases.\n\n            p = k - lt  # Pair index.\n            right_part_len = rt - k + 1\n\n            if Z[p] < right_part_len:\n                Z[k] = Z[p]\n            else:\n                i = rt + 1\n                while i < len(s) and s[i] == s[i - k]:\n                    i += 1\n                Z[k] = i - k\n\n                lt = k\n                rt = i - 1\n    return Z\n\ndef kmptab(s):\n    tab = [0]*len(s)\n    i = 1\n    j = 0\n    while i < len(s):\n        if s[i] == s[j]:\n            tab[i] = j + 1\n            i += 1\n            j += 1\n        else:\n            if j != 0:\n                j = tab[j-1]\n            else:\n                i += 1\n    return tab\n\ndef __starting_point():\n    s = input()\n    tab = kmptab(s)\n    my_set = set()\n    i = len(s)\n    while i != 0:\n        my_set.add(i)\n        i = tab[i-1]\n    V = []\n    dict = {}\n    for i in my_set:\n        V.append(i)\n        dict[i] = 0\n    Z = z_advanced(s)\n\n    v = []\n    V.sort()\n    my_tab = [0]*(len(s)+1)\n    # print(Z)\n    for i in Z:\n        my_tab[i] += 1\n    somme = 0\n    # print(my_tab)\n    for i in range(len(my_tab)-1, -1, -1):\n\n        my_tab[i] += somme\n        somme = my_tab[i]\n    # print(my_tab)\n    for i in dict:\n        dict[i] = my_tab[i]\n        v.append((dict[i], i))\n    v.sort(key=lambda tup: tup[1])\n    print(len(v))\n    for i in v:\n        print(str(i[1]) + \" \" + str(i[0]))\n\n__starting_point()", "def zeta(s):\n\tn = len(s)\n\tz = [0]*n\n\tl,r = 0,0\n\tfor i in range(1,n):\n\t\tif(i<=r): z[i] = min(r-i+1,z[i-l])\n\t\twhile(i+z[i]<n and s[z[i]]==s[i+z[i]]):\n\t\t\tz[i]+=1\n\t\tif(i+z[i]-1>r):\n\t\t\tl=i\n\t\t\tr = i+z[i]-1\n\treturn z\ns = input()\nn = len(s)\nz = zeta(s)\nl = [0]*n\nfor i in z:\n\tl[i]+=1\ncum = [l[-1]]\nfor i in range(n-2,-1,-1):\n\tcum.append(l[i]+cum[-1])\ncum = cum[::-1]\nans = [(n,1)]\nfor i in range(n-1,0,-1):\n\tif(i+z[i]==n):\n\t\tans.append((n-i,cum[n-i]+1))\n\nprint(len(ans))\nfor i in sorted(ans):\n\tprint(*i)\n\n", "#!/usr/bin/env python3\n\"\"\"Compute z function.\"\"\"\n\n\ndef compute_z(data):\n    z = [0 for _ in range(len(data))]\n    z[0] = len(data)\n    l = 0\n    r = 0\n    for i in range(1, len(data)):\n        if i <= r: # nu am explorat\n            z[i] = min(z[i-l], r-i+1)\n        while i + z[i] < len(data) and data[z[i]] == data[i+z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            r = i + z[i] - 1\n            l = i\n    return z\n\n\ndata = input() # input -> eval 2.x ; input = read \n# print(data)\nn = len(data)\nz = compute_z(data)\nfeq_z = [0 for _ in range(n)]  # range(3) = 0, 1, 2\nfor value in z:\n    if value == 0:\n        continue\n    index = value - 1\n    feq_z[index] += 1\n\n\nfor i in range(n-2, -1, -1):\n    feq_z[i] += feq_z[i+1]\n\n# print(z)\n# print(feq_z)\ncount = 0 \nfor i in range(n-1, -1, -1):\n    if z[i] == n - i:\n        count += 1\nprint(count)\nfor i in range(n-1, -1, -1):\n    if z[i] == n - i:\n        print(\"{} {}\".format(z[i], feq_z[z[i]-1]))\n", "def zfunc(s):\n    n = len(s)\n    z = [0] * n\n    left = right = 0\n    for i in range(1, n):\n        if i <= right:\n            z[i] = min(z[i - left], right - i + 1)\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > right:\n            left, right = i, i + z[i] - 1\n    return z\n\ns = input()\nans = set()\nz = zfunc(s)\nz[0] = len(s)\nres = [0] * (len(s) + 1)\n\nfor i in z:\n    res[i] += 1\n\nfrom itertools import accumulate\nres = [*accumulate(res[::-1])][::-1]\n\nfor i, j in enumerate(z[::-1]):\n    if j > i:\n        ans.add((j, res[j]))\nprint(len(ans))\nfor i in sorted([*ans]):\n    print(*i)", "s=input();n=len(s)\nif n==1:\n    print(1)\n    print(1,1)\n    quit()\npriya=[-1]*n;q=-1\nfor i in range(1,n):\n    while q>=0 and s[i]!=s[q+1]:\n        q=priya[q]\n    if s[i] == s[q + 1]:\n        q+=1;priya[i]=q\ncnt=[1]*n\nfor i in range(n-1,-1,-1):\n    if priya[i]>=0:\n        cnt[priya[i]]+=cnt[i]\nAns=[(n,1)];q=priya[n-1]\nwhile q>=0:\n    Ans.append((q+1,cnt[q]))\n    q=priya[q]\nAns.sort()\nprint(len(Ans))\nfor i in Ans:print(*i)", "def getLPS(s2,l):\n  lps=[0]*l\n  i=1\n  j=0\n  while i<l:\n    if s2[i]==s2[j]:\n       lps[i]=j+1 \n       j+=1\n       i+=1\n       \n    else:\n      if j!=0:j=lps[j-1]\n      else:\n       lps[i]=0\n       i+=1\n  return lps\ns=input()\nn=len(s)\np=getLPS(s,n)\n#print(p)\nans=[]\nf=[0]*n\nfor i in range(n):\n  f[p[i]]+=1\n#print(f)\nfor i in range(n-1,0,-1):\n  f[p[i-1]]+=f[i]\n#print(f)\npos=n-1\nans=[[n,1]]\nwhile pos>0:\n  #print(pos)\n  if p[pos]>1:\n    ans.append([p[pos],f[p[pos]]+1])\n  pos=p[pos]-1\n \nif len(s)>1:\n  f=s.count(s[0])\n  if s[0]==s[len(s)-1]:\n    ans.append([1,f])\nprint(len(ans))\nfor i in sorted(ans):\n  print(i[0],i[1])\n", "'''\nYou have a string s\u2009=\u2009s1s2...s|s|, where |s| is the length of string s, and si its i-th character.\n\nLet's introduce several definitions:\n\n    A substring s[i..j] (1\u2009\u2264\u2009i\u2009\u2264\u2009j\u2009\u2264\u2009|s|) of string s is string sisi\u2009+\u20091...sj.\n    The prefix of string s of length l (1\u2009\u2264\u2009l\u2009\u2264\u2009|s|) is string s[1..l].\n    The suffix of string s of length l (1\u2009\u2264\u2009l\u2009\u2264\u2009|s|) is string s[|s|\u2009-\u2009l\u2009+\u20091..|s|]. \n\nYour task is, for any prefix of string s which matches a suffix of string s, print the number of times it occurs in string s as a substring.\n'''\n\ndef prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[j] != s[i]:\n            j = pi[j - 1]\n        pi[i] = j + (s[j] == s[i])\n    return pi\n\ndef solve(s):\n    n = len(s)\n    pi = prefix_function(s)\n    j = n\n    prefixes = []\n    while j:\n        prefixes.append(j)\n        j = pi[j - 1]\n    print(len(prefixes))\n    if len(prefixes) == 1:\n        print(n, 1)\n        return\n    cnt = [0] * (n + 1)\n    for i in range(n):\n        cnt[pi[i]] += 1\n    for i in range(n - 1, 0, -1):\n        cnt[pi[i - 1]] += cnt[i]\n    for i in range(n + 1):\n        cnt[i] += 1\n    for i in reversed(prefixes):\n        print(i, cnt[i])\n\ndef main():\n    s = input()\n    solve(s)\n\nmain()\n    \n\n\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nS=input().strip()\n\n\nLEN=len(S)\ni=1\nj=0\nA=[0]*LEN\nA[0]=LEN\n\nwhile i<LEN:\n    while i+j<LEN and S[j]==S[i+j]:\n        j+=1\n    A[i]=j\n    \n    if j==0:\n        i+=1\n        continue\n    \n    k=1\n    while i+k<LEN and k+A[k]<j:\n        A[i+k]=A[k]\n        k+=1\n    i+=k\n    j-=k\n\nANS=[0]*(LEN+1)\n\nfor a in A:\n    ANS[a]+=1\n\nfor i in range(LEN-1,-1,-1):\n    ANS[i]+=ANS[i+1]\n\nANS2=[]\nfor i in range(1,LEN+1):\n    if A[LEN-i]==i:\n        ANS2.append((i,ANS[i]))\n\nprint(len(ANS2))\nfor x,y in ANS2:\n    print(x,y)\n\n\n\n", "def computeLPSArray(pat, M, lps):\n    len = 0\n    lps[0]\n    i = 1\n\n    while i < M:\n        if pat[i]== pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            if len != 0:\n                len = lps[len-1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\ndef count_subs_occ(s,m,l):\n    occ=[0]*(m+1)\n\n    for i in range(m):\n        occ[l[i]]+=1\n\n    for i in range(m-1,0,-1):\n        occ[l[i-1]]+=occ[i]\n\n    for i in range(m+1):\n        occ[i]+=1\n\n    return occ\n\ns=input()\nm=len(s)\nl=[0]*m\n\nx=computeLPSArray(s,m,l)\nx=[0]+x\ny=count_subs_occ(s,m,l)\n\na=x[-1]\nif a==0:\n    print(1)\n    print(m,1)\nelif a==1:\n    print(2)\n    print(1,y[a])\n    print(m,1)\nelse:\n    u=x[-1]\n    v=x[u]\n    ans=[[u,y[u]]]\n    while(1):\n        if v==0:\n            break\n        u=v\n        v=x[u]\n        temp=[u,y[u]]\n        ans.append(temp)\n\n    ans.sort()\n    print(len(ans)+1)\n    for i in range(len(ans)):\n        print(ans[i][0],ans[i][1])\n    print(m,1)"]
["from scipy.special import comb\nmod = 10**9 + 7\nN, K = list(map(int,input().split()))\nfor i in range(1,K+1):\n    a = K-i\n    b = i-1\n    c = N-(i-1)-K\n    d = i\n    print((comb(a+b,b,exact=True)*comb(c+d,d,exact=True)%mod))\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\nclass Combination():\n    def __init__(self, n, mod=10**9+7):\n        self.mod = mod\n        self.fac = [1]*(n+1)\n        for i in range(1,n+1):\n            self.fac[i] = self.fac[i-1] * i % self.mod\n        self.invfac = [1]*(n+1)\n        self.invfac[n] = pow(self.fac[n], self.mod - 2, self.mod)\n        for i in range(n-1, 0, -1):\n            self.invfac[i] = self.invfac[i+1] * (i+1) % self.mod\n\n    def combination(self, n, r):\n        return self.fac[n] * self.invfac[r] % self.mod * self.invfac[n-r] % self.mod\n\n    def permutation(self, n, r):\n        return self.factorial(n) * self.invfactorial(n-r) % self.mod\n\n    def factorial(self, i):\n        return self.fac[i]\n\n    def invfactorial(self, i):\n        return self.invfac[i]\n\n\ndef main():\n    n, k = mi()\n    mod = 10**9 +7\n    c = Combination(n)\n    for i in range(k):\n        if n-k < i:\n            print(0)\n            continue\n        tmp = c.combination(n-k+1, i+1)\n        tmp *= c.combination(k-1, i)\n        tmp %= mod\n        print(tmp)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k=map(int,input().split())\n\n\np=10**9+7\n\nfuct=[1]\nfor i in range(2000):\n  fuct.append((fuct[i]*(i+1))%p)\n\nfor i in range(1,min(k,n-k+1)+1):\n  Ca=(fuct[k-1]*pow(fuct[i-1],p-2,p)*pow(fuct[k-i],p-2,p))%p\n  Cb=(fuct[n-k+1]*pow(fuct[i],p-2,p)*pow(fuct[n-k+1-i],p-2,p))%p\n  print((Ca*Cb)%p)\nfor i in range(min(k,n-k+1)+1,k+1):\n  print(0)", "import math\n\nn,k = list(map(int, input().split()))\n\ndef main(i):\n  blue = math.factorial(k-1) // (math.factorial(i-1) * math.factorial(k-i))\n  red = math.factorial(n-k+1) // (math.factorial(n-k+1-i) * math.factorial(i))\n  print(((blue*red) % (10**9 + 7)))\n\nfor i in range(1, k+1):\n  if i > n-k+1:\n    print('0')\n  else:\n   main(i)\n", "n,k = map(int,input().split())\n\n#mod\u3042\u308a\u306e\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9 + 7\nN = n #\u5fc5\u8981\u306a\u6570\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nfor i in range(1,k+1):\n    print(cmb(n-k+1,i,mod)*cmb(k-1,i-1,mod)%mod)", "N,K=list(map(int,input().split()))\n\ndef genCombinationFunction(max_k,mod):\n    modinv_table = [-1] * (max_k+1)\n    modinv_table[1] = 1\n    for i in range(2, max_k+1):\n        modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\n    def binomial_coefficients(n, k):\n        ans = 1\n        for i in range(k):\n            ans *= n-i\n            ans *= modinv_table[i + 1]\n            ans %= mod\n        return ans\n    return binomial_coefficients\n\nmod=10**9+7\nk=2000\nf=genCombinationFunction(k,mod)\nfor i in range(1,K+1):\n  redballs=N-K\n  position=redballs+1\n\n  order=f(position,i)\n  order*=f(K-1,i-1)\n  print((order%mod))\n", "from functools import lru_cache\n\nn,k = list(map(int, input().split()))\n\n# 2000\u307e\u3067\u306e\u968e\u4e57\uff08MOD:10^9+7\uff09\u3068\u305d\u306e\u9006\u5143\u3092\u8a08\u7b97\u3057\u3066\u304a\u304f\nMOD = 10**9+7\nfact = [1, 1]\nfact_inv = [1, 1]\n\nfor i in range(2, n+1):\n    fact.append(fact[i-1] * i % MOD)\n    fact_inv.append(pow(fact[i], MOD-2, MOD))\n\n@lru_cache(maxsize=None)\ndef combi(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return (fact[n] * fact_inv[k] * fact_inv[n-k]) % MOD\n\nfor i in range(1, k+1):\n    print((combi(n-k+1, i) * combi(k-1, i-1)) % MOD)", "n, k = list(map(int, input().split()))\nmod = 10**9 + 7\n\n\n# pow(\u6c42\u3081\u305f\u3044\u3082\u306e,-1,mod)\u3067python3.8.2\u306a\u3089\u3067\u304d\u308b\na = [1]  # i+1\u756a\u76ee\u307e\u3067\u306e\u968e\u4e57\nb = [1]  # a[i]\u306e\u9006\u5143\n\nfor i in range(1, n+1):\n    a.append(i * a[i-1] % mod)\n    b.append(pow(a[i], -1, mod))\nfor i in range(1, k+1):  # ../data_picture\n    if n-k < i-1:\n        print((0))\n    else:\n        blue_ball = k-i\n        blue_partition = i\n        blue_ans = a[blue_ball + blue_partition - 1] * \\\n            b[blue_ball] % mod * b[blue_partition-1] % mod\n        red_ball = n-k-i+1\n        red_partition = i+1\n        red_ans = a[red_ball + red_partition - 1] * \\\n            b[red_ball] % mod * b[red_partition-1] % mod\n        print(((blue_ans * red_ans) % mod))\n", "N,K=map(int,input().split())\nmod=10**9+7\n\nfactorial=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i % mod\n\ndef comb(n,k):\n    return factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod)\n\nfor i in range(1,K+1):\n  if i > N-K+1:print(0)\n  else:print(comb(K-1,i-1)*comb(N-K+1,i)%mod)", "import math\n\nn, k = map(int, input().split())\nmod = pow(10,9)+7\n\nfor i in range(1, k+1):\n    print(math.comb(n-k+1, i) * math.comb(k-1, i-1) % mod)", "def readinput():\n    n,k=list(map(int,input().split()))\n    return n,k\n\n# \u6cd5P\u306e\u4e0b\u3067\u306e\u7d44\u307f\u5408\u308f\u305b\u6570 nCk \u3092\u6c42\u3081\u308b\n# MAX: n\u306e\u6700\u5927\u5024\n\nMAX = 2000+5  # (X+Y)/3\u3088\u308a\u5927\u304d\u3044\u6574\u6570 1 <= X, Y <= 10**6\nMOD = (10**9)+7\n\nfac=[1 for x in range(MAX)]\ninv=[1 for x in range(MAX)]\nfinv=[1 for x in range(MAX)]\n\n# \u62e1\u5f35\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n# (d, x, y): d=ax+by \u3092\u6e80\u305f\u3059d, x, y\u3092\u6c42\u3081\u308b\n# a\u3068b\u304c\u4e92\u3044\u306b\u7d20\u306a\u6574\u6570\u3067\u3042\u308c\u3070gcd(a,b)=d=1, ax=1 (mod b)\n# x\u306f\u6cd5b\u306e\u5143\u3067a\u306e\u4e57\u6cd5\u9006\u5143a^-1\u306b\u306a\u308b\ndef exEuclid(a, b):\n    if (b==0):\n        return (a, 1, 0)\n    else:\n        (dd, xx, yy) = exEuclid(b, a % b)\n        return (dd, yy, xx - (a//b)*yy)\n\ndef COMinit():\n    for i in range(2,MAX):\n        #print(i,fac)\n        fac[i] = fac[i-1]*i % MOD\n        (d, x, y) = exEuclid(i, MOD)\n        inv[i] = x\n        finv[i] = finv[i-1]*inv[i] % MOD\n\ndef COM(n, k):\n    if(n<k):\n        return 0\n    elif ( (n<0)or(k<0)):\n        return 0\n    else:\n        return fac[n]*(finv[n-k]*finv[k] % MOD) % MOD\n\n\n\n\ndef main(n,k):\n    COMinit()\n    m=n-k+1\n    for i in range(1,k+1):\n        if i > min(m,k):\n            print((0))\n        else:\n            print(( ( COM(m,i)*COM(k-1,i-1) ) %MOD ))\n\ndef __starting_point():\n    n,k=readinput()\n    main(n,k)\n\n__starting_point()", "class Combination:\n    def __init__(self, mod, max_n):\n        self.MOD = mod\n        self.MAX_N = max_n\n\n        self.f = self.factorial(self.MAX_N)\n        self.f_inv = [self.inv(x) for x in self.f]\n\n    def inv(self,x):\n        return pow(x, self.MOD-2, self.MOD)\n    \n    def factorial(self, n):\n        res = [1]\n        for i in range(1,n+1):\n            res.append(res[-1] * i % self.MOD)\n        return res\n    \n    def comb(self, n, r):\n        return (self.f[n] * self.f_inv[r] % self.MOD) * self.f_inv[n-r] % self.MOD\n\nN, K = map(int,input().split())\n\nCB = Combination(10**9+7,10000)\n\nfor i in range(1,K+1):\n    if i > N-K+1:\n        print(0)\n    else:\n        print(CB.comb(N-K+1,i) * CB.comb(K-1,i-1) % CB.MOD)", "N, K = list(map(int, input().split()))\nR = N - K\nmod = 10**9 + 7\nfac = [0] * 2010\nfacinv = [0] * 2010\nfac[1] = 1\nfacinv[1] = pow(1, -1, mod)\nfac[0] = 1\nfacinv[0] = 1\n\nfor i in range(2, 2000):\n    fac[i] = (fac[i-1] * i) % mod\n    facinv[i] = (facinv[i-1] * pow(i, -1, mod)) % mod\n\ndef nCk(n, k):\n    return (fac[n] * facinv[k] * facinv[n-k]) % mod\n\nfor i in range(K):#i = \u9593\u306b\u5165\u308c\u308b\u30dc\u30fc\u30eb\n    if i > R:\n        print(\"0\")\n    else:\n        print(((nCk(K-1, i) * nCk(R+1, i+1)) % mod))\n", "def main():\n    n,k = list(map(int,input().split()))\n    mod = 10**9+7\n    a = 1\n    b = n-k+1\n    for i in range(k):\n        ans = a*b % mod\n        print(ans)\n        a = a * (k-1-i)//(i+1)\n        b = b * (n-k-i)//(i+2)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod=10**9+7\n\ndef add(a, b):\n    return (a + b) % mod\n\ndef sub(a, b):\n    return (a + mod - b) % mod\n\ndef mul(a, b):\n    return ((a % mod) * (b % mod)) % mod\n\ndef power(x, y):\n    if   y == 0     : return 1\n    elif y == 1     : return x % mod\n    elif y % 2 == 0 : return power(x, y//2)**2 % mod\n    else            : return power(x, y//2)**2 * x % mod\n\ndef div(a, b):\n    return mul(a, power(b, mod-2))\n\ndef cc(ii):\n    iii=1\n    for ii in range(1,ii+1):\n        iii=iii*ii\n    return iii\n\ndef cmb(a,b):\n    iii=1\n    for ii in range(a-b+1,a+1):\n        iii=(iii*ii)%mod\n    iiii=1\n    for ii in range(1,b+1):\n        iiii=(iiii*ii)%mod\n#        print(\"ii,iiii:\",ii,iiii)\n#    print(\"a:\",a,\"b:\",b,\"iii:\",iii,\"iiii:\",iiii)\n#    print(\"a:\",a,\"b:\",b,\"a-b:\",a-b,\"a!:\",iii,\"b!:\",iiii,\"cmb:\",iii//iiii)\n    return div(iii,iiii)        \n\n\nn,k=list(map(int,input().split()))\n\nib=k-1\nir=n-ib\n\nfor i in range(1,ib+2):\n#    cb=cc(ib)//cc(ib-i+1)//cc(i-1)\n#    cr=cc(ir)//cc(ir-i)//cc(i)\n    cb=cmb(ib,i-1)\n    cr=cmb(ir,i)\n#    print(\"ib:\",ib,i-1,cb,\"ir:\",ir,i,cr)\n    print((mul(cb,cr)))\n    \n", "# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\nmod = 10**9+7\ndef cmb(n, r, mod=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNN = 10**5 # \u4f7f\u3046\u30c7\u30fc\u30bf\u306b\u3088\u3063\u3066\u5909\u3048\u308b\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nN, K = map(int, input().split())\n\nfor i in range(1, K+1):\n    ans = cmb(K-1, K-i) * cmb(N-K+1, N-K-i+1) % mod\n    print(ans)", "from scipy.special import comb\nN,K=list(map(int,input().split()))\nmod=10**9+7\nred=N-K\nfor i in range(1,K+1):\n   tmp=comb(N-K+1,i,exact=True)*comb(K-1,i-1,exact=True)%mod\n   print(tmp)", "\ndef pre_combi1(n, p):\n    fact = [1]*(n+1)  # fact[n] = (n! mod p)\n    factinv = [1]*(n+1)  # factinv[n] = ((n!)^(-1) mod p)\n    inv = [0]*(n+1)  # factinv \u8a08\u7b97\u7528\n    inv[1] = 1\n    # \u524d\u51e6\u7406\n    for i in range(2, n + 1):\n        fact[i]= fact[i-1] * i % p\n        inv[i]= -inv[p % i] * (p // i) % p\n        factinv[i]= factinv[i-1] * inv[i] % p\n    return fact, factinv\n\ndef combi1(n, r, p, fact, factinv):\n    \"\"\"\n    k<n<10**7\u3067p\u304c\u7d20\u6570\u306e\u3068\u304d\u306enCr % p\u3092\u6c42\u3081\u308b\n    \"\"\"\n    # \u672c\u51e6\u7406\n    if r < 0 or n < r:\n        return 0\n    r = min(r, n-r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\nn,k=list(map(int,input().split()))\nf,inv=pre_combi1(2005,10**9+7)\nfor i in range(1,k+1):\n  print((combi1(n-k+1,i,10**9+7,f,inv)*combi1(k-1,i-1,10**9+7,f,inv)%(10**9+7)))\n\n", "import math\n\nn,k = list(map(int, input().split()))\n\ndef main(i):\n  blue = int(math.factorial(k-1) // (math.factorial(i-1) * math.factorial(k-i)))\n  red = int(math.factorial(n-k+1) // (math.factorial(n-k+1-i) * math.factorial(i)))\n  print(((blue*red) % (10**9 + 7)))\n\nfor i in range(1, k+1):\n  if i > n-k+1:\n    print('0')\n  else:\n   main(i)\n", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = map(int, input().split())\n\nm = 1000000007\n\n\ndef make_factorial_table(n):\n    result = [0] * (n + 1)\n    result[0] = 1\n    for i in range(1, n + 1):\n        result[i] = result[i - 1] * i % m\n    return result\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n\n\nn = max(K, N - K + 1)\nfac = make_factorial_table(n)\n\nresult = []\nfor i in range(1, K + 1):\n    result.append(mcomb(K - 1, i - 1) * mcomb(N - K + 1, i) % m)\n#print('\\n'.join(str(i) for i in result))\nprint(*result, sep='\\n')\n", "class BigCombination(object):\n    __slots__ = [\"mod\", \"factorial\", \"inverse\"]\n\n    def __init__(self, mod: int = 10**9+7, max_n: int = 10**6):\n        fac, inv = [1], []\n        fac_append, inv_append = fac.append, inv.append\n\n        for i in range(1, max_n+1):\n            fac_append(fac[-1] * i % mod)\n\n        inv_append(pow(fac[-1], mod-2, mod))\n\n        for i in range(max_n, 0, -1):\n            inv_append(inv[-1] * i % mod)\n\n        self.mod, self.factorial, self.inverse = mod, fac, inv[::-1]\n\n    def get_combination(self, n, r):\n        return self.factorial[n] * self.inverse[r] * self.inverse[n-r] % self.mod\n\n    def get_permutation(self, n, r):\n        return self.factorial[n] * self.inverse[n-r] % self.mod\n\nimport math\nBig = BigCombination()\nn,k = list(map(int,input().split()))\ns = 0\nfor i in range(k):\n    if n - k + 1 < i + 1:\n      \tprint('0')\n      \tcontinue\n    print(((Big.get_combination(n-k+1,i+1) *Big.get_combination(k-1,i))%(10**9+7)))\n\n", "import math\ndef comb(n, r):\n  if n-r>=0:\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n  else:\n    return 0\n\nn,k=map(int, input().split())\nfor i in range(1,k+1):\n  print(comb(n-k+1,i)*comb(k-1,i-1)%(10**9+7))", "def main():\n\tN, K = [int(a) for a in input().split(\" \")]\n\tif N == K:\n\t\tfor i in range(K):\n\t\t\tif i == 0:\n\t\t\t\tprint(1)\n\t\t\telse:\n\t\t\t\tprint(0)\n\t\treturn 0\n\n\tlim = max([K, N - K]) + K + 1\n\tp = 1000000007\n\tf = []\n\tfor i in range(lim):\n\t\tif i == 0:\n\t\t\tf.append(1)\n\t\telse:\n\t\t\tf.append((f[-1] * i) % p)\n\tlf = len(f)\n\tfi = [0] * lf\n\tfi[-1] = inv(f[-1], p)\n\tfor i in range(lf - 1):\n\t\tfi[lf - 1 - i - 1] = (fi[lf - 1 - i] * (lf - 1 - i)) % p\n\n\tdef comb_p(n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\treturn (f[n] * ((fi[k] * fi[n - k]) % p)) % p\n\tfor i in range(1, K + 1):\n\t\ts = (comb_p(K-1, i-1) * (comb_p(N-K-1, i-2) + 2 * comb_p(N-K-1, i-1) + comb_p(N-K-1,i)) % p) % p\n\t\tprint(s)\n\ndef inv(a, p):\n\tpower_a = [a]\n\tb_p = format(p - 2, 'b')\n\tans = 1\n\tfor i in range(len(b_p)):\n\t\tpower_a.append((power_a[-1] ** 2) % p)\n\tfor i in range(len(b_p)):\n\t\tif b_p[-i-1] == \"1\":\n\t\t\tans = (ans * power_a[i]) % p\n\treturn ans\n\nmain()", "def comb(n,k,p):\n  \"\"\"power_func\u3092\u7528\u3044\u3066(nCk) mod p \u3092\u6c42\u3081\u308b\"\"\"\n  from math import factorial\n  if n<0 or k<0 or n<k: return 0\n  if n==0 or k==0: return 1\n  a=factorial(n) %p\n  b=factorial(k) %p\n  c=factorial(n-k) %p\n  return (a*power_func(b,p-2,p)*power_func(c,p-2,p))%p\ndef power_func(a,b,p):\n  \"\"\"a^b mod p \u3092\u6c42\u3081\u308b\"\"\"\n  if b==0: return 1\n  if b%2==0:\n    d=power_func(a,b//2,p)\n    return d*d %p\n  if b%2==1:\n    return (a*power_func(a,b-1,p ))%p\nn,k=map(int, input().split())\nfor i in range(1,k+1):\n  print(comb(n-k+1,i,10**9+7)*comb(k-1,i-1,10**9+7)%(10**9+7))", "n, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nmax_n = 2050\ncomb = [[0] * max_n for i in range(max_n)]\nfor i in range(max_n):\n    comb[i][1] = i\n    comb[i][i] = 1\n    comb[i][0] = 1\nfor i in range(1, max_n):\n    for j in range(1, i):\n        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod\nfor i in range(1, k+1):\n    ans = comb[k-1][i-1]\n    ans = (ans * comb[n-k+1][i]) % mod\n    print(ans)\n", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\nmod = 10**9+7\nN = 10**4\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nN,K=map(int,input().split())\nmod=10**9+7\nans=0\nk=N-K\nfor i in range(K):\n  ans=cmb(N-K+1,i+1,mod)*cmb(K-1,i,mod)\n  print(ans%mod)", "import sys\ninput = sys.stdin.readline\n\nN,K = (int(x) for x in input().rstrip('\\n').split())\nred = 1\nblue = 1\nres = 1\nsub = N-K+1\nfor i in range(1,K+1):\n  red = red*(N-K+2-i)//i\n  if i==1:\n    blue = 1\n  else:\n    blue = blue*(K+1-i)//(i-1)\n  res = red*blue\n  print((res%1000000007))\n", "from operator import mul\nfrom functools import reduce\n\n\ndef cmb(n, r):\n\tif n < r:\n\t\treturn 0\n\tr = min(n - r, r)\n\tif r == 0:\n\t\treturn 1\n\tnumer = reduce(mul, range(n, n - r, -1))\n\tdenom = reduce(mul, range(1, r + 1))\n\treturn numer // denom % INF\n\n\nN, K = map(int, input().split())\nINF = 10 ** 9 + 7\n\nfor i in range(1, K + 1):\n\tprint(cmb(K - 1, i - 1) * cmb(N - K + 1, i) % INF)", "import sys\nsys.setrecursionlimit(3000)\nN, K = map(int,input().split())\ndef comb(n,k):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if k < 0:\n        return 0\n    if k == 0:\n        return 1\n    return comb(n-1,k-1) * n // k\nR = N-K\nMOD = 10**9+7\nA = K-1\nB = R-1\nif N == K:\n    print(1)\n    for i in range(2, K+1):\n        print(0)\nelse:\n    for i in range(1, K+1):\n        x = comb(A, i-1)\n        y = comb(B, i-2)\n        z = comb(B, i-1)\n        w = comb(B, i)\n        ans = x*(y+2*z+w)\n        print(ans % MOD)", "a = list(map(int,input().split()))\nN = a[0]\nK = a[1]\n\ni = 2\nx = (N-K+1)\ny = 1\nz = (x*y)%(10**9+7)\nprint(z)\n\nwhile K >= i:\n    if (N-K+1) >= i:\n        x = (N-K+2-i)*x//i\n        y = (K-i+1)*y//(i-1)\n        z = (x*y)%(10**9+7)\n        print(z)\n    else:\n        print((0))\n    i = i + 1\n", "M = 1000000007\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n\n    f = [1]\n    g = [1]\n    for i in range(1, 2 * n + 1):\n        f.append(i * f[i - 1] % M)\n        g.append(pow(f[i], -1, M))\n    for i in range(1, k + 1):\n        if n - k < i - 1:\n            print((0))\n        else:\n            blue_ball = k - i\n            blue_box = i\n            blue_comb = f[blue_ball + blue_box - 1] * \\\n                g[blue_ball] % M * g[blue_box - 1] % M\n            red_ball = n - k - i + 1\n            red_box = i + 1\n            red_comb = f[red_ball + red_box - 1] * \\\n                g[red_ball] % M * g[red_box - 1] % M\n            print((blue_comb * red_comb % M))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def nCk(_n,_k):\n  return fact[_n]*pow(fact[_k],m-2,m)*pow(fact[_n-_k],m-2,m)%m\n\nfact=[1]*2005\nfor i in range(1,2004):\n  fact[i]=fact[i-1]*i\n\nn,k=list(map(int,input().split()))\nm=10**9+7\n\nfor i in range(1,k+1):\n  print((nCk(n-k+1,i)*nCk(k-1,i-1)%m if n-k>=i-1 else 0))\n", "n,k=map(int,input().split())\np=10**9+7\ndef fact(n,p):\n    a=[[] for _ in range(n+1)]\n    a[0]=1\n    for i in range(n):\n        a[i+1]=(a[i]*(i+1))%p\n    return a\nf=fact(n,p)\ninvf=[]\nfor i in f:\n    invf.append(pow(i,-1,p))\nans=[]\nfor i in range(1,k+1):\n    if i>n-k+1:\n        ans.append(0)\n        continue\n    ans.append(((f[n-k+1]*invf[n-k+1-i])%p)*((invf[i]*f[k-1])%p)*((invf[i-1]*invf[k-i]))%p)\nfor i in ans:\n    print(i%p)", "def comb(n, r, p):\n    if n < r:\n        return 0\n    elif n < 0 or r < 0:\n        return 0\n    return fac[n] * (facinv[r] * facinv[n - r] % p) % p\n\n\ndef comb_pre(N, p):\n    for i in range(2, N + 1):\n        fac.append(fac[i - 1] * i % p)\n        inv.append(-inv[p % i] * (p // i) % p)\n        facinv.append(facinv[-1] * inv[-1] % p)\n\n\nfac = [1, 1]\nfacinv = [1, 1]\ninv = [0, 1]\n\nN, K = list(map(int, input().split()))\nMOD = 1_000_000_007\ncomb_pre(N, MOD)\nfor i in range(1, K + 1):\n    tmp = comb(N - K + 1, i, MOD)\n    tmp %= MOD\n    tmp *= comb(K - 1, i - 1, MOD)\n    tmp %= MOD\n    print(tmp)\n", "N, K = list(map(int, input().split()))\n\n# x_1 + x_2 + ... x_k = n\n# x_i >= 0\n# k\u500b\u306e\u7bb1\u306bn\u500b\u306e\u30dc\u30fc\u30eb\u3092\u5165\u308c\u308b\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\u3000n+k-1_C_k-1\n# n\u500b\u306e\u7389\u3068k-1\u500b\u306e\u4ed5\u5207\u308a\u3092\u4e26\u3079\u308b\n\n# x_1 + x_2 + ... x_k = n\n# x_i >= 1\n# k\u500b\u306e\u7bb1\u306bn\u500b\u306e\u30dc\u30fc\u30eb\u30921\u500b\u4ee5\u4e0a\u5165\u308c\u308b\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\u3000n-1_C_k-1\n# n\u500b\u306e\u7389\u306e\u4ed5\u5207\u308an-1\u500b\u306e\u4e2d\u306b\u3001k-1\u7b87\u6240\u4ed5\u5207\u308a\u3092\u5165\u308c\u308b\n\nfrom math import factorial\n\n# k = 1,2,...,K\nfor k in range(1, K + 1):\n    if k > N - K + 1:\n        print((0))\n        continue\n\n    # k = 1,2,...,K\n    # K\u500b\u306e\u9752\u3044\u30dc\u30fc\u30eb\u3092k\u500b\u306b\u5206\u5272\u3059\u308b\u65b9\u6cd5\n    # K-1_C_k-1\n    c1 = factorial(K - 1) // (factorial(K - k) * factorial(k - 1))\n    c1 = int(c1) % (10 ** 9 + 7)\n\n    # N-K\u500b\u306e\u8d64\u3044\u30dc\u30fc\u30eb\u306e\u5206\u5272\n    # k+1\u500b\u306b\u5206\u5272(\u3057\u304b\u3057\u4e21\u7aef\u306f\u306a\u304f\u3066\u3082\u826f\u3044)\n    # N-K+1_C_k\n\n    # x_1 + x_2 + ... + x_k + x_k+1 = N\u2212K\n    # x1 >= 0\n    # x_2,x_3,...,x_k >= 1\n    # x_k + 1 >= 0\n\n    c2 = factorial(N - K + 1) // (factorial(N - K - k + 1) * factorial(k))\n    c2 = int(c2) % (10**9 + 7)\n\n    ans = c1 * c2 % (10**9 + 7)\n    print(ans)\n", "import math\n \nn,k = map(int, input().split())\n \ndef main(i):\n  blue = math.factorial(k-1) // (math.factorial(i-1) * math.factorial(k-i))\n  red = math.factorial(n-k+1) // (math.factorial(n-k+1-i) * math.factorial(i))\n  print((blue*red) % (10**9 + 7))\n \nfor i in range(1, k+1):\n  if i > n-k+1:\n    print('0')\n  else:\n   main(i)", "def cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 3000  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n    \n    \nN,K = map(int,input().split())\nfor i in range(1,K+1):\n  print(cmb(N-K+1,i,p)*cmb(K-1,i-1,p)%p)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN,K=list(map(int,input().split()))\nm=10**9+7\n\ndef arrange(red,blue,m):\n    if red+1<blue:\n        return 0\n    a = (math.factorial(red+1))%m\n    b = pow(math.factorial(blue),m-2,m)\n    c = pow(math.factorial(red+1-blue),m-2,m)\n\n    return (a*b*c)%m\n\ndef bluegroup(blue,group,m):\n    a = (math.factorial(blue-1))%m\n    b = pow(math.factorial(group-1),m-2,m)\n    c = pow(math.factorial(blue-group),m-2,m)\n\n    return (a*b*c)%m\n\nfor i in range(1,K+1):\n    print(((arrange(N-K,i,m)*bluegroup(K,i,m))%m))\n", "import math\n\ndef comb(n, r, mod):\n    return math.factorial(n + r - 1)//(math.factorial(n - 1)*math.factorial(r))%mod\n\nn, k = map(int, input().split())\nmod = 10**9 + 7\nred = n - k\n\nfor i in range(k):\n    ans = 0\n    redmod = red - i\n    if redmod < 0:\n        print(0)\n        continue\n    redplace = 2 + i\n    bluemod = k - (i + 1)\n    if i == 0:\n        bluemod = 0\n    blueplace = i + 1\n    ans += comb(redplace, redmod, mod)*comb(blueplace, bluemod, mod)\n    print(ans%mod)", "mod=10**9+7\n\ndef add(a, b):\n    return (a + b) % mod\n\ndef sub(a, b):\n    return (a + mod - b) % mod\n\ndef mul(a, b):\n    return ((a % mod) * (b % mod)) % mod\n\ndef power(x, y):\n    if   y == 0     : return 1\n    elif y == 1     : return x % mod\n    elif y % 2 == 0 : return power(x, y//2)**2 % mod\n    else            : return power(x, y//2)**2 * x % mod\n\ndef div(a, b):\n    return mul(a, power(b, mod-2))\n\ndef cc(ii):\n    iii=1\n    for ii in range(1,ii+1):\n        iii=iii*ii\n    return iii\n\ndef cmb(a,b):\n    iii=1\n    for ii in range(a-b+1,a+1):\n        iii=(iii*ii)%mod\n    iiii=1\n    for ii in range(1,b+1):\n        iiii=(iiii*ii)%mod\n#        print(\"ii,iiii:\",ii,iiii)\n#    print(\"a:\",a,\"b:\",b,\"iii:\",iii,\"iiii:\",iiii)\n#    print(\"a:\",a,\"b:\",b,\"a-b:\",a-b,\"a!:\",iii,\"b!:\",iiii,\"cmb:\",iii//iiii)\n    return div(iii,iiii)        \n\nfrom functools import reduce\n\ndef cmb2(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    if r==1 : return n\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1,r + 1)))\n    return div(over,under)        \n\nn,k=list(map(int,input().split()))\n\nib=k-1\nir=n-ib\n\nfor i in range(1,ib+2):\n    if i>ir:\n        print((0))\n        continue\n#    cb=cc(ib)//cc(ib-i+1)//cc(i-1)\n#    cr=cc(ir)//cc(ir-i)//cc(i)\n    cb=cmb2(ib,i-1)\n    cr=cmb2(ir,i)\n#    print(\"ib:\",ib,i-1,cb,\"ir:\",ir,i,cr)\n    print((mul(cb,cr)))\n    \n", "mod=10**9+7\n\ndef add(a, b):\n    return (a + b) % mod\n\ndef sub(a, b):\n    return (a + mod - b) % mod\n\ndef mul(a, b):\n    return ((a % mod) * (b % mod)) % mod\n\ndef power(x, y):\n    if   y == 0     : return 1\n    elif y == 1     : return x % mod\n    elif y % 2 == 0 : return power(x, y//2)**2 % mod\n    else            : return power(x, y//2)**2 * x % mod\n\ndef div(a, b):\n    return mul(a, power(b, mod-2))\n\ndef cc(ii):\n    iii=1\n    for ii in range(1,ii+1):\n        iii=iii*ii\n    return iii\n\ndef cmb(a,b):\n    iii=1\n    for ii in range(a-b+1,a+1):\n        iii=(iii*ii)%mod\n    iiii=1\n    for ii in range(1,b+1):\n        iiii=(iiii*ii)%mod\n#        print(\"ii,iiii:\",ii,iiii)\n#    print(\"a:\",a,\"b:\",b,\"iii:\",iii,\"iiii:\",iiii)\n#    print(\"a:\",a,\"b:\",b,\"a-b:\",a-b,\"a!:\",iii,\"b!:\",iiii,\"cmb:\",iii//iiii)\n    return div(iii,iiii)        \n\nfrom functools import reduce\n\ndef cmb2(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n#    if r==1 : return n\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1,r + 1)))\n    return div(over,under)        \n\nn,k=list(map(int,input().split()))\n\nib=k-1\nir=n-ib\n\nfor i in range(1,ib+2):\n    if i>ir:\n        print((0))\n        continue\n#    cb=cc(ib)//cc(ib-i+1)//cc(i-1)\n#    cr=cc(ir)//cc(ir-i)//cc(i)\n    cb=cmb2(ib,i-1)\n    cr=cmb2(ir,i)\n#    print(\"ib:\",ib,i-1,cb,\"ir:\",ir,i,cr)\n    print((mul(cb,cr)))\n    \n", "import math\n\ndef comb(n, r, mod):\n    return math.factorial(n + r - 1)//(math.factorial(n - 1)*math.factorial(r))%mod\n\nn, k = map(int, input().split())\nmod = 10**9 + 7\nred = n - k\n\nfor i in range(k):\n    if red - i < 0:\n        print(0)\n        continue\n    bluemod = k - (i + 1)\n    if i == 0:\n        bluemod = 0\n    ans = comb(2 + i, red - i, mod)*comb(i + 1, bluemod, mod)\n    print(ans%mod)", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nfrom operator import mul\nfrom functools import reduce\n\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    modulo = 1000_000_000 + 7\n\n    def cmb(n, r):\n        if n < r:\n            return 0\n        r = min(n - r, r)\n        if r == 0:\n            return 1\n        numer = reduce(mul, range(n, n - r, -1))\n        denom = reduce(mul, range(1, r + 1))\n        return numer // denom % modulo\n\n    for i in range(1, k+1):\n        # i\u5206\u5272\u3059\u308b\u65b9\u6cd5\n        a = cmb(k-1, i-1)\n        # \u8d64\u306e\u30dc\u30fc\u30eb\u3092\u5206\u5272\u3059\u308b\u65b9\u6cd5\n        b = cmb(n-k+1, i)\n        print(a * b % modulo)\n\nmain()", "n,k = map(int,input().split())\nmod = 10**9+7\na = 1\nb = n-k+1\nfor i in range(k):\n  print(a*b%mod)\n  a = a*(k-1-i)//(i+1)\n  b = b*(n-k-i)//(i+2)", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\ndef resolve():\n    # \u9752\u3001\u8d64\u305d\u308c\u305e\u308c\u306e\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n    # K\u500b\u306e\u9752\u3044\u30dc\u30fc\u30eb\u3092i\u500b\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\u65b9\u6cd5\u304cK\u20131Ci\u20131\u901a\u308a\u3001\n    # \u305d\u308c\u3089\u3092\u8d64\u3044\u30dc\u30fc\u30eb\u306e\u9593\u306b\u5165\u308c\u308b\u65b9\u6cd5\u304cN-K+1Ci\u901a\u308a\n\n    MOD = 10 ** 9 + 7\n    N, K = list(map(int, input().split()))\n\n    CMB = Combination(N + 1)\n\n    for i in range(1, K + 1):\n        red = CMB.nCr(N - K + 1, i) % MOD\n        blue = CMB.nCr(K - 1, i - 1) % MOD\n        ans = red * blue\n        ans %= MOD\n        print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "mod=10**9+7\n\ndef add(a, b):\n    return (a + b) % mod\n\ndef sub(a, b):\n    return (a + mod - b) % mod\n\ndef mul(a, b):\n    return ((a % mod) * (b % mod)) % mod\n\ndef power(x, y):\n    if   y == 0     : return 1\n    elif y == 1     : return x % mod\n    elif y % 2 == 0 : return power(x, y//2)**2 % mod\n    else            : return power(x, y//2)**2 * x % mod\n\ndef div(a, b):\n    return mul(a, power(b, mod-2))\n\ndef cc(ii):\n    iii=1\n    for ii in range(1,ii+1):\n        iii=iii*ii\n    return iii\n\ndef cmb(a,b):\n    iii=1\n    for ii in range(a-b+1,a+1):\n        iii=(iii*ii)%mod\n    iiii=1\n    for ii in range(1,b+1):\n        iiii=(iiii*ii)%mod\n#        print(\"ii,iiii:\",ii,iiii)\n#    print(\"a:\",a,\"b:\",b,\"iii:\",iii,\"iiii:\",iiii)\n#    print(\"a:\",a,\"b:\",b,\"a-b:\",a-b,\"a!:\",iii,\"b!:\",iiii,\"cmb:\",iii//iiii)\n    return div(iii,iiii)        \n\n\nn,k=list(map(int,input().split()))\n\nib=k-1\nir=n-ib\n\nfor i in range(1,ib+2):\n#    cb=cc(ib)//cc(ib-i+1)//cc(i-1)\n#    cr=cc(ir)//cc(ir-i)//cc(i)\n    cb=cmb(ib,i-1)\n    cr=cmb(ir,i)\n#    print(\"ib:\",ib,i-1,cb,\"ir:\",ir,i,cr)\n    print((mul(cb,cr)))\n    \n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy\nfrom operator import itemgetter\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**4\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nN, K = na()\nfor i in range(K):\n    print((cmb(K-1, i, mod) * cmb(N-K+1, N-K-i, mod)) % mod)", "from scipy.special import comb\nn = 1000000007\n \na,b = map(int, input().split())\n \nfor i in range(1,b+1):\n  print(comb(a-b+1, i, exact=True)*comb(b-1, i-1, exact=True)%n)", "n,k = map(int,input().split())\nmod = 10**9+7\na = 1\nb = n-k+1\nfor i in range(k):\n    ans = a*b % mod\n    print(ans)\n    a = a * (k-1-i)//(i+1)\n    b = b * (n-k-i)//(i+2)", "import functools\nimport operator\n\ndef nCr(n, r):\n    if n < r:\n        return 0\n    r = min(r, n-r)\n    if r == 0:\n        return 1\n    num = functools.reduce(operator.mul, range(n, n-r, -1))\n    den = functools.reduce(operator.mul, range(1, r+1))\n    return num // den % mod\n\nn, k = map(int, input().split())\n\nmod = 10**9 + 7\nfor i in range(1, k+1):\n    print(nCr(k-1, i-1) * nCr(n-k+1, i) % mod)", "n, k = list(map(int, input().split()))\n\nm = 1000000007\n\ndef ncr(n, r, p):\n    num = 1\n    den = 1\n\n    for i in range(r):\n        num = (num*(n-i)) % p\n        den = (den*(i+1)) % p\n\n    return (num*pow(den, p-2, p)) % p\n\ndef comb(n, k, lowerBound):\n    if lowerBound == 0:\n        return ncr(n+k-1, n, m)\n    else:\n        return comb(n-(k*lowerBound), k, 0)\n\nfor i in range(1, k+1):\n    ans = comb(k, i, 1)\n    red = n-k-(i-1)\n\n    if red < 0:\n        ans = 0\n    else:\n        ans *= comb(red, i+1, 0)\n\n    print(ans%m)", "import math\ndef com(n,r):\n  return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))\nn,k=map(int,input().split())\nfor i in range(1,k+1):\n  if n-k+1<i:\n    print(0)\n  else:\n    print(com(k-1,i-1)*com(n-k+1,i)%(10**9+7))", "Limit = 2000 #\u4e0a\u9650\u3092\u6c7a\u3081\u308b\nCMB = [[0]*(Limit+1) for _ in range(Limit+1)]\ndef cmb_table(Limit):\n  for i in range(Limit+1):\n    for j in range(Limit+1):\n      if j == 0 or j == i: #\u7aef\u3063\u3053\u306e\u5834\u5408\n        CMB[i][j] = 1\n      else:\n        CMB[i][j] = CMB[i-1][j-1] + CMB[i-1][j]\n\ncmb_table(Limit) #\u3053\u308c\u5fc5\u9808\uff01\n#print(CMB[3][2])\nN,K = list(map(int,input().split()))\nMOD = pow(10,9)+7\nred = N-K\nblue = K\nfor i in range(1,K+1):\n  p = CMB[blue-1][i-1]%MOD\n  #print(p,i)\n  if i-1 > red:\n    print((0))\n  else:\n    ans = p*CMB[red+1][i]%MOD\n    print(ans)\n", "n, k = list(map(int, input().split()))\nmod = 10**9+7\ndef extgcd(a,b):\n    r = [1,0,a]\n    w = [0,1,b]\n    while w[2]!=1:\n        q = r[2]//w[2]\n        r2 = w\n        w2 = [r[0]-q*w[0],r[1]-q*w[1],r[2]-q*w[2]]\n        r = r2\n        w = w2\n    #[x,y]\n    return [w[0],w[1]]\n\n# a\u306e\u9006\u5143(mod m)\u3092\u6c42\u3081\u308b\u3002(a\u3068m\u306f\u4e92\u3044\u306b\u7d20\u3067\u3042\u308b\u3053\u3068\u304c\u524d\u63d0)\n#a/b = a*(b`)\u3068\u306a\u308bb`\u3092\u6c42\u3081\u308b\nmod = 10**9+7\ndef mod_inv(a,mod):\n    x = extgcd(a,mod)[0]\n    return (mod+x%mod)%mod\nN = n - k + 1\ncombi = [0 for i in range(n+1)]\ncombi[0] = 1\nfor i in range(1,N+1):\n    combi[i] = (combi[i-1]*(N-i+1)*mod_inv(i,mod)) % mod\nfact = [0 for i in range(n+1)]\nfact[0] = 1\nfor i in range(1, n+1):\n    fact[i] = (i * fact[i-1]) % mod\nfor i in range(1, k+1):\n    print(((combi[i] * fact[k-1] * pow(fact[k-i], -1, mod) * pow(fact[i-1], -1, mod)) % mod))\n", "\nimport datetime\nfrom decimal import Decimal, ROUND_DOWN\nimport heapq\nfrom fractions import gcd\nfrom functools import reduce\nfrom collections import deque\n# from math import factorial\nimport itertools\nimport collections\nimport math\nimport sys\nsys.setrecursionlimit(2000000)\n# import statistics\n# import numpy as np\n# n = int(input())\n# n, m, p = list(map(int, input().split()))\n# a = list(map(int, input().split()))\n#\n#  abc = [int(input()) for i in range(5)]\n# n = int(input())\nn, k = list(map(int, input().split()))\n# A = list(map(int, input().split()))\n# a = list(map(int, input().split()))\n# data = [list(map(int, input().split())) for i in range(n)]\n# q = int(input())\n# p = list(map(int, input().split()))\n# b = list(map(int, input().split()))\n# ab_sorted = sorted(ab, key=lambda x: x[0])\n# ab = [list(map(int, input().split())) for i in range(n)]\n# print(min(15*n, 100*(n//10+1), 100*(n//10)+15*(n % 10)))\n\nM = 1000000007\nf = [1]\ng = [1]\nfor i in range(1, 2*n+1):\n    f.append(i*f[i-1] % M)  # \u968e\u4e57\n    g.append(pow(f[i], -1, M))  # f[i]\u306e\u9006\u5143\n\nfor i in range(1, k+1):\n    if n-k < i-1:\n        print((0))\n    else:\n        a_com = f[n-k+1]*g[i] % M*g[n-k+1-i] % M\n        b_com = f[k-1]*g[i-1] % M*g[k-i] % M\n        print((a_com*b_com % M))\n", "mod = pow(10,9)+7\nn,k = map(int,input().split())\ninv = [0,1]\nfact = [1,1]\nifact = [1,1]\nfor i in range(2,n+1):\n    inv.append(inv[mod%i]*(mod-mod//i)%mod)\n    fact.append(i*fact[-1]%mod)\n    ifact.append(ifact[-1]*inv[i]%mod)\n\ndef combi(a,b):\n    if a >= b:\n        return fact[a]*ifact[b]*ifact[a-b]%mod\n    else:\n        return 0\n\nfor i in range(1,k+1):\n    print(combi(n-k+1,i)*combi(k-1,i-1)%mod)", "def C(n, r, MOD):\n    num = 1\n    den = 1\n    for i in range(r):\n        num *= n - i\n        num %= MOD\n        den *= i + 1\n        den %= MOD\n    return (num * pow(den, MOD - 2, MOD)) % MOD\n\nN, K = list(map(int, input().split()))\nMOD = 1_000_000_007\nfor i in range(1, K + 1):\n    print(((C(N - K + 1, i, MOD) * C(K - 1, i - 1, MOD)) % MOD))\n", "import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 19\nMOD = 10 ** 9 + 7\nEPS = 10 ** -10\n\nclass ModTools:\n    \"\"\" \u968e\u4e57\u30fb\u9006\u5143\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u69cb\u7bc9\u3059\u308b \"\"\"\n\n    def __init__(self, MAX, MOD):\n\n        # nCr\u306a\u3089n\u3001nHr\u306a\u3089n+r\u307e\u3067\u4f5c\u308b\n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        inverse = [1] * MAX\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, -1, -1):\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n\n    def nCr(self, n, r):\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b \"\"\"\n\n        if n < r: return 0\n        r = min(r, n-r)\n        numerator = self.fact[n]\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\nN, K = MAP()\nM = N - K\nmt = ModTools(N, MOD)\n\nfor k in range(1, K+1):\n    # M+1\u7b87\u6240\u306e\u9699\u9593\u304b\u3089k\u7b87\u6240\u9078\u3076 * k\u7b87\u6240\u306b\u5bfe\u3057\u3066K\u500b\u3092\u6700\u4f4e1\u500b\u4ee5\u4e0a\u5165\u308c\u306a\u304c\u3089\u5272\u308a\u632f\u308b(\u5199\u50cf\u306e6\u76f8)\n    res = mt.nCr(M+1, k) * mt.nCr(K-1, k-1) % MOD\n    print(res)\n", "import sys\nsys.setrecursionlimit(1<<30)\nM = 10**9+7\nN, Blue =map(int,input().split())\nRed = N-Blue\nComb = [[0]*(N+1) for i in range(0,N+1)]\nfor i in range(1,N+1):\n    Comb[i][0] = 1\n    Comb[i][1] = i\n    Comb[i][i] = 1\nComb[0][0] = 1\nfor i in range(1,N+1):\n    for j in range(2,i+1):\n        Comb[i][j] = (Comb[i-1][j] + Comb[i-1][j-1])%M\nfor i in range(1,Blue+1):\n    A = Comb[Red+1][i] * Comb[Blue-1][i-1]\n    print(A%M)", "class ModCalc:\n    mod = 10**9 + 7\n\n    def __init__(self, n):\n        self.n = n\n        self.inv = [1] * (self.n + 1)\n        self.fac = [1] * (self.n + 1)\n        self.finv = [1] * (self.n + 1)\n        self.inv[0] = 0\n        self.inv_table()\n\n    def inv_table(self):\n        for i in range(2, self.n+1):\n            self.inv[i] = self.inv[self.mod % i] * (self.mod - self.mod // i) % self.mod\n            self.fac[i] = self.fac[i-1] * i % self.mod\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.mod\n\n    def comb(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n\n        return self.fac[n] * self.finv[r] % self.mod * self.finv[n-r] % self.mod\n\n    def perm(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n\n        return self.fac[n] * self.finv[n-r] % self.mod\n\n    def fact(self, n):\n        return self.fac[n]\n\n\nn, k = list(map(int, input().split()))\n\nmc = ModCalc(n)\nmod = 10**9 + 7\n\nfor i in range(1, k+1):\n    tmp = mc.comb(n-k+1, i)\n    print((mc.comb(k-1, i-1) * tmp % mod))\n", "# \u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62\nN, K = map(int, input().split())\n\nm = 1000000007\n\nn = max(K, N - K + 1)\nc = [[0] * (n + 1) for _ in range(n + 1)]\nc[0][0] = 1\nfor i in range(1, n + 1):\n    c[i][0] = 1\n    for j in range(1, i + 1):\n        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % m\n\nresult = []\nfor i in range(1, K + 1):\n    result.append(c[K - 1][i - 1] * c[N - K + 1][i] % m)\n#print('\\n'.join(str(i) for i in result))\nprint(*result, sep='\\n')\n", "def nCk(_n,_k):\n  return (fact[_n]//(fact[_k]*fact[_n-_k]))%m\n\nfact=[1]*2005\nfor i in range(1,2004):\n  fact[i]=fact[i-1]*i\n\nn,k=list(map(int,input().split()))\nr=n-k\nm=10**9+7\n\nfor i in range(1,k+1):\n  if r<i-1: print((0)); continue;\n  if i==1: print((r+i)); continue;\n  else:\n    ans=nCk(r+1,i)*nCk(k-1,i-1)\n    print((ans%m))\n", "import sys\nsys.setrecursionlimit(1000000000)\nimport math\nfrom math import gcd\ndef lcm(a, b): return a * b // gcd(a, b)\nfrom itertools import count, permutations, chain, product\nfrom functools import lru_cache\nfrom collections import deque, defaultdict\nfrom pprint import pprint\nii = lambda: int(input())\nmis = lambda: list(map(int, input().split()))\nlmis = lambda: list(mis())\nINF = float('inf')\nN1097 = 10**9 + 7\n\ndef meg(f, ok, ng):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if f(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n\ndef get_inv(n, modp):\n    return pow(n, modp-2, modp)\n\ndef factorials_list(n, modp):    # 10**6\n    fs = [1]\n    for i in range(1, n+1):\n        fs.append(fs[-1] * i % modp)\n    return fs\n\ndef invs_list(n, fs, modp):     # 10**6\n    invs = [get_inv(fs[-1], modp)]\n    for i in range(n, 1-1, -1):\n        invs.append(invs[-1] * i % modp)\n    invs.reverse()\n    return invs\n\ndef comb(n, k, modp):\n    num = 1\n    for i in range(n, n-k, -1):\n        num = num * i % modp\n    den = 1\n    for i in range(2, k+1):\n        den = den * i % modp\n    return num * get_inv(den, modp) % modp\n\ndef comb_from_list(n, k, modp, fs, invs):\n    return fs[n] * invs[n-k] * invs[k] % modp\n\n#\n\nclass UnionFindEx:\n    def __init__(self, size):\n        #\u6b63\u306a\u3089\u6839\u306e\u756a\u53f7\u3001\u8ca0\u306a\u3089\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba\n        self.roots = [-1] * size\n    def getRootID(self, i):\n        r = self.roots[i]\n        if r < 0:   #\u8ca0\u306a\u3089\u6839\n            return i\n        else:\n            r = self.getRootID(r)\n            self.roots[i] = r\n            return r\n    def getGroupSize(self, i):\n        return -self.roots[self.getRootID(i)]\n    def connect(self, i, j):\n        r1, r2 = self.getRootID(i), self.getRootID(j)\n        if r1 == r2:\n            return False\n        if self.getGroupSize(r1) < self.getGroupSize(r2):\n            r1, r2 = r2, r1\n        self.roots[r1] += self.roots[r2]    #\u30b5\u30a4\u30ba\u66f4\u65b0\n        self.roots[r2] = r1\n        return True\n\nYes = 'Yes'\nNo = 'No'\n\n\ndef main():\n    N, K = mis()\n    B, R = K, N-K\n    fs = factorials_list(N+10, N1097)\n    invs = invs_list(N+10, fs, N1097)\n    for i in range(1, K+1):\n        if R+1 >= i and B-1 >= i-1:\n            print((comb_from_list(R+1, i, N1097, fs, invs) * comb_from_list(B-1, i-1, N1097, fs, invs) % N1097))\n        else:\n            print((0))\n\nmain()\n\n", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = list(map(int, input().split()))\n\nm = 1000000007\n\n\ndef make_factorial_table(n):\n    result = [0] * (n + 1)\n    result[0] = 1\n    for i in range(1, n + 1):\n        result[i] = result[i - 1] * i % m\n    return result\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n\n\nn = max(K, N - K + 1)\nfac = make_factorial_table(n)\n\nresult = []\nfor i in range(1, K + 1):\n    result.append(mcomb(K - 1, i - 1) * mcomb(N - K + 1, i) % m)\nprint(('\\n'.join(str(i) for i in result)))\n#print(*result, sep='\\n')\n", "from functools import lru_cache\n\nn,k = list(map(int, input().split()))\n\n# 2000\u307e\u3067\u306e\u968e\u4e57\uff08MOD:10^9+7\uff09\u3068\u305d\u306e\u9006\u5143\u3092\u8a08\u7b97\u3057\u3066\u304a\u304f\nMOD = 10**9+7\nfact = [1, 1]\nfact_inv = [1, 1]\n\nfor i in range(2, n+1):\n    fact.append(fact[i-1] * i % MOD)\n    fact_inv.append(pow(fact[i], MOD-2, MOD))\n\n@lru_cache(maxsize=None)\ndef combi(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nfor i in range(1, k+1):\n    print(combi(n-k+1, i) * combi(k-1, i-1) % MOD)", "n, k = map(int, input().split())\nmod = 10 ** 9 + 7\n\nfact = [1] * (n + 1)\nrevfact = [1] * (n + 1)\nfor i in range(n):\n    fact[i + 1] = ((i + 1) * fact[i]) % mod\nrevfact[n] = pow(fact[n], mod - 2, mod)\nfor i in reversed(range(n)):\n    revfact[i] = ((i + 1) * revfact[i + 1]) % mod\ndef combination(n, k, p):\n    return (fact[n] * revfact[k] * revfact[n - k]) % p\n\nfor i in range(1, k + 1):\n    if n - k + 1 < i:\n        ans  = 0\n    else:\n        ans = combination(n - k + 1, i, mod) * combination(k - 1, i - 1, mod)\n    print(ans % mod)", "from scipy.special import comb\nn = 1000000007\n\na,b = map(int, input().split())\n\nfor i in range(1,b+1):\n  ans = 0\n  print(comb(a-b+1, i, exact=True)*comb(b-1, i-1, exact=True)%n)", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\ndef resolve():\n    # \u9752\u3001\u8d64\u305d\u308c\u305e\u308c\u306e\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n    MOD = 10 ** 9 + 7\n    N, K = list(map(int, input().split()))\n\n    CMB = Combination(N + 1)\n\n    for i in range(1, K + 1):\n        if i > N - K + 1:\n            print((0))\n        else:\n            ans = CMB.nCr(N - K + 1, N - K - i + 1)\n            ans = ans * CMB.nCr(K - 1, K - i)\n            ans %= MOD\n            print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,K = map(int,input().split())\nBp = 1\nRp = N-K+1\n \nfor k in range(K):\n  print(Bp*Rp%(10**9+7))\n  Bp = Bp*(K-k-1)//(k+1)\n  Rp = Rp*(N-K-k)//(k+2)", "p = 10**9+7\ndef exp(y,x):\n  xbin=str(bin(x))[2:]\n  ans=1\n  yl=[0]*(len(xbin)+1)\n  yl[0]=y\n  yl[1]=y**2\n  for d,i in enumerate(xbin[::-1],start=0):\n    if d > 1:\n      yl[d]=yl[d-1]**2%p\n    if i == \"1\":\n      ans=(ans*yl[d])%p\n  return ans%p\nimport sys\nsys.setrecursionlimit(200000000)\n\ndef ff(n,ca):\n  if ca == 0:\n    return 1\n  if ca == 1:\n    return n\n  return n*ff(n-1, ca-1)%p\n\ndef main():\n  n,k = map(int,input().split())\n  fact=[1,1]\n  for i in range(2,n+1):\n    fact.append(fact[-1]*i % p)\n\n  for i in range(1,k+1):\n    t1 = ff(k-1,i-1)*exp(fact[i-1],p-2)%p\n    t2 = ff(n-k+1,i)*exp(fact[i],p-2)%p\n    print(t1*t2 % p)\n\ndef __starting_point():\n  main()\n__starting_point()", "N,K = map(int,input().split())\nB = 1\nR = N-K+1\n\nfor k in range(K):\n  print(B*R%(10**9+7))\n  B = B*(K-k-1)//(k+1)\n  R = R*(N-K-k)//(k+2)", "from operator import mul\nfrom functools import reduce\ndef cmb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1,r + 1)))\n    return (over // under)%(10**9+7)\nN,k=list(map(int,input().split()))\nl=N-k\nfor i in range(1,k+1):\n    if l<i-1:\n        print((0))\n    else:\n        num1=l-(i-1)\n        print(((cmb(k-1,i-1)*cmb(num1+i,i))%(10**9+7)))\n", "from operator import mul\nfrom functools import reduce\n\ndef cmb(n, r):\n\tif n < r:\n\t\treturn 0\n\tr = min(n-r, r)\n\tif r == 0:\n\t\treturn 1\n\tnumer = reduce(mul, range(n, n-r, -1))\n\tdenom = reduce(mul, range(1, r+1))\n\treturn numer // denom % mod\n\nN, K = map(int, input().split())\nmod = 10**9 + 7\n\nfor i in range(1, K+1):\n\tprint(cmb(K-1, i-1) * cmb(N-K+1, i) % mod)", "n, k = map(int, input().split())\nmod = 10**9+7\n\ndef nCr(N, R, mod):\n  R = min(R, N-R)\n  numer = denom = 1\n  for i in range(1, R+1):\n    numer = numer * (N+1-i) % mod\n    denom = denom * i % mod\n  res = numer * pow(denom, mod-2, mod) % mod\n  return res\n\nfor i in range(1,k+1):\n  if n-k+1<i:\n    print (0)\n    continue\n  y = nCr(n-k+1,i,mod)\n  y *= nCr(k-1,i-1, mod)\n  print (y%mod)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nN,K = list(map(int, input().split()))\n\n\n# In[5]:\n\n\nmod = 10**9+7\ndef nCr(N, R, mod):\n    R = min(R, N-R)\n    numer = denom = 1\n    for i in range(1, R+1):\n        numer = numer * (N+1-i) % mod\n        denom = denom * i % mod\n    res = numer * pow(denom, mod-2, mod) % mod\n    return res\n\n\n# In[7]:\n\n\nfor i in range(1,K+1):\n    if N-K+1<i:\n        print((0))\n        continue\n    y = nCr(N-K+1,i,mod)\n    y *= nCr(K-1,i-1,mod)\n    print((y%mod))\n\n\n# In[ ]:\n\n\n\n\n", "from math import factorial\ndef comb(n, r):\n  if r < 0 or n < r:\n    return 0\n  r = min(r, n-r)\n  return fac[n]*fin[r]*fin[n-r]%mod\n\nn, k = map(int, input().split())\nmod = 10**9+7\n\n# \u524d\u8a08\u7b97\nfac = [1, 1]\nfin = [1, 1]\ninv = [0, 1]\nfor i in range(2, n+1):\n  fac.append(fac[-1]*i%mod)\n  inv.append(pow(i, mod-2, mod))\n  fin.append(fin[-1]*inv[-1]%mod)\n\nfor i in range(1, k+1):\n  print(comb(n-k+1, i)*comb(k-1, i-1)%mod)", "N,K=map(int,input().split())\nR=N-K\nM=10**9+7\ndef cmb(n,r,m):\n    f=[1,1]\n    for i in range(2,n+1):\n        f.append(f[i-1]*i%m)\n    return f[n]*pow(f[r]*f[n-r]%m,m-2,m)%m\nfor i in range(1,K+1):\n    if i<=R+1:\n        Q=cmb(R+1,i,M)*cmb(K-1,i-1,M)\n        Q%=M\n        print(Q)\n    else:\n        print(0)", "#coding: utf-8\nfrom collections import defaultdict\nimport sys\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 3000  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nN, K = (int(i) for i in input().split())\nfor i in range(1, K + 1):\n    ret = cmb(N-K+1, i, p)\n    ret %= p\n    ret *= cmb(K-1, i-1, p)\n    ret %= p\n    print(ret)\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nimport heapq\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1] # warning bytes\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8')\nimport string\nimport operator\nimport random\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\n# sys.setrecursionlimit(int(1e6))\n\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n \n    def __call__(self, n, r):  \n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n \n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\ndef solve():\n    # n = int(input())\n    total, blue = [int(x) for x in input().split()]\n    red = total - blue\n\n    def fact(x):\n        ans = 1\n        while x:\n            ans *= x\n            ans %= MOD\n            x -= 1\n        return ans\n\n    def coef(n, k):\n        if k > n: return 0\n        return (fact(n) * pow((fact(k) * fact(n - k))%MOD, MOD - 2, MOD)) % MOD\n\n    for i in range(1, blue+1):\n        print(((coef(red+1, i) * coef(blue-1, i-1))%MOD))\n\nT = 1\n# T = int(input())\nfor case in range(1,T+1):\n    ans = solve()\n\n\n\"\"\"\n\ndp[num_changes][blue_placed]\n\n\nabba\n\n(m + 1)\n\n\"\"\"\n", "import math\n\ndef comb(n, r, mod):\n    return math.factorial(n + r - 1)//(math.factorial(n - 1)*math.factorial(r))%mod\n\nn, k = map(int, input().split())\nmod = 10**9 + 7\nred = n - k\n\nfor i in range(k):\n    if red - i < 0:\n        print(0)\n        continue\n    ans = comb(2 + i, red - i, mod)*comb(i + 1, k - i - 1, mod)\n    print(ans%mod)", "import math\n\nn, k = map(int, input().split())\n\nfor i in range(1, k+1):\n    ans = math.comb(n-k+1, i)*math.comb(k-1, i-1)\n    print(ans%(10**9+7))", "n, k = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nN = n + 10\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nfor i in range(1, k + 1):\n    ans = nCk(n - k + 1, i) * nCk(k - 1, i - 1)\n    ans %= MOD\n    print(ans)", "MOD = pow(10,9)+7\ndef MODINV(n:int, MOD=MOD):\n    return pow(n, MOD-2, MOD)\n\nclass common_combinations():\n    \"\"\"\n        mod \u3092\u542b\u3080 combination \u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u95a2\u6570\n        N < 5*10^6 \u307e\u3067\u5bfe\u5fdc. \u305d\u308c\u4ee5\u4e0a\u306e N \u306e\u5834\u5408\u306f common.combi(n, k) \u3092\u4f7f\u7528\u3059\u308b.\n        __init__: nCk \u3092\u6c42\u3081\u308b\u305f\u3081\u306e\u4e8b\u524d\u306e\u8a08\u7b97\u3092\u884c\u3046. O(N)\n        combinations: nCk \u3092\u6c42\u3081\u308b. O(1)\n    \"\"\"\n    def __init__(self, N=510000, MOD=pow(10, 9) + 7):\n        \"\"\"\n            combination \u3092 O(1) \u3067\u8a08\u7b97\u3059\u308b\u305f\u3081\u306e\u524d\u51e6\u7406\n        \"\"\"\n        self.N = N\n        self.MAX_NUM = self.N + 1\n        self.MOD = MOD\n\n        self.fac  = [0 for _ in range(self.MAX_NUM)]\n        self.finv = [0 for _ in range(self.MAX_NUM)]\n        self.inv  = [0 for _ in range(self.MAX_NUM)]\n\n        self.fac[0]  = self.fac[1] = 1\n        self.finv[0] = self.finv[1] = 1\n        self.inv[1] = 1\n\n        for i in range(2, self.MAX_NUM):\n            self.fac[i] = self.fac[i-1] * i % self.MOD\n            self.inv[i] = self.MOD - self.inv[self.MOD%i] * (self.MOD // i) % self.MOD\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.MOD\n\n    def combinations(self, n:int, k:int):\n        \"\"\"\n            combination \u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\n        \"\"\"\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return self.fac[n] * (self.finv[k] * self.finv[n-k] % self.MOD) % self.MOD\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    combi = common_combinations(N=N+10)\n    ans = 0\n    for i in range(1, K+1):\n        lineup = combi.combinations(N-K+1, i)\n        block = combi.combinations(K-1, i-1)\n        print(((lineup*block)%MOD))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = map(int, input().split())\nM = N - K\nMOD = 10 ** 9 + 7\n\nf = [1] * (N + 1)\nfor i in range(1, N + 1):\n    f[i] = f[i-1] * i\n\nfor i in range(1, K + 1):\n    ans = f[M+1] // (f[i] * f[M+1-i])\n    ans %= MOD\n    ans *= (f[K-1] // (f[i-1] * f[K-i]))\n    ans %= MOD\n    print(ans)", "N, B = list(map(int, input().split()))\nR = N-B\nmod = pow(10, 9)+7\nans = [0]*(B+1)\nBn = B-1\nRn = R+1\nif R+1 < B:\n    Br = B-R-1\n    Bbunshi = 1\n    Bbunbo = 1\n    for i in range(Br):\n        Bbunshi = (Bbunshi*(Bn-i)) % mod\n        Bbunbo = (Bbunbo*(i+1)) % mod\n    Rbunshi = 1\n    Rbunbo = 1\n    Rr = 1\n    Bn -= Br\n    Br += 1\n    ans[R+1] = (Bbunshi*pow(Bbunbo, -1, mod)) % mod\nelif R+1 > B:\n    Rr = R-B+1\n    Rbunshi = 1\n    Rbunbo = 1\n    for i in range(Rr):\n        Rbunshi = (Rbunshi*(Rn-i)) % mod\n        Rbunbo = (Rbunbo*(i+1)) % mod\n    Bbunshi = 1\n    Bbunbo = 1\n    Br = 1\n    Rn -= Rr\n    Rr += 1\n    ans[B] = (Rbunshi*pow(Rbunbo, -1, mod)) % mod\n\nelse:\n    Br = 1\n    Bbunshi = 1\n    Bbunbo = 1\n    Rr = 1\n    Rbunshi = 1\n    Rbunbo = 1\n    ans[B] = 1\n\nn = min(R+1, B)\nfor i in range(n-1, 0, -1):\n    Bbunshi = (Bbunshi*Bn) % mod\n    Bbunbo = (Bbunbo*Br) % mod\n    Rbunshi = (Rbunshi*Rn) % mod\n    Rbunbo = (Rbunbo*Rr) % mod\n    ans[i] = ((Bbunshi*pow(Bbunbo, -1, mod)) *\n              (Rbunshi*pow(Rbunbo, -1, mod))) % mod\n    Bn -= 1\n    Rn -= 1\n    Br += 1\n    Rr += 1\n\n\nfor i in range(1, B+1):\n    print((ans[i]))\n", "# \u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62\nN, K = list(map(int, input().split()))\n\nm = 1000000007\n\nn = max(K, N - K + 1)\nc = [[0] * (n + 1) for _ in range(n + 1)]\nc[0][0] = 1\nfor i in range(1, n + 1):\n    c[i][0] = 1\n    for j in range(1, i + 1):\n        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % m\n\nresult = []\nfor i in range(1, K + 1):\n    result.append(c[K - 1][i - 1] * c[N - K + 1][i] % m)\nprint(('\\n'.join(str(i) for i in result)))\n#print(*result, sep='\\n')\n", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nn, k = MAP()\n\nfor i in range(1, k+1):\n    ans = comb(n-k+1,i)*comb(k-1,i-1) % (10**9+7)\n    print(ans)", "N,K=map(int,input().split())\nlist=[0]*(N+1)\nmod=10**9+7\nlist[1]=1\nlist[0]=1\nfor i in range(1,N):\n  list[i+1]=list[i]*(i+1)%mod\ndef c(a,b):\n    ans=list[a]*pow(list[b],mod-2,mod)*pow(list[a-b],mod-2,mod)%mod\n    return ans\n\nfor i in range(1,K+1):\n  if i>N-K+1:\n    print(0)\n  else:\n    an=c(K-1,i-1)*c(N-K+1,i)%mod\n    print(an)", "def comb(n, r, p):\n    if n < r:\n        return 0\n    elif n < 0 or r < 0:\n        return 0\n    return fac[n] * (facinv[r] * facinv[n - r] % p) % p\n\n\ndef comb_pre(N, p):\n    for i in range(2, N + 1):\n        fac.append(fac[i - 1] * i % p)\n        inv.append(-inv[p % i] * (p // i) % p)\n        facinv.append(facinv[-1] * inv[-1] % p)\n\n\nfac = [1, 1]\nfacinv = [1, 1]\ninv = [0, 1]\n\nN, K = list(map(int, input().split()))\nMOD = 1_000_000_007\ncomb_pre(N + 1, MOD)\nfor i in range(1, K + 1):\n    tmp = comb(N - K + 1, i, MOD)\n    tmp %= MOD\n    tmp *= comb(K - 1, i - 1, MOD)\n    tmp %= MOD\n    print(tmp)\n", "n,k=map(int,input().split())\ndp=[[0]*(n+1) for _ in range(n+1)]\nmod=10**9+7\ndp[0][0]=1\ndp[1][0]=1\ndp[1][1]=1\nfor i in range(2,n+1):\n    for j in range(n+1):\n        dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%mod\nfor a in range(1,k+1):\n    if n-k+1<a:\n        print(0)\n        continue\n    else:\n        print(dp[n-k+1][a]*dp[k-1][a-1]%mod)   ", "import math\nn,k=map(int,input().split());m=10**9+7\nfor i in range(1,k+1): print(math.comb(n-k+1,i)*math.comb(k-1,i-1)%m)", "from functools import reduce\ndef nCr(n,r,DIV):\n  if r<n-r:\n    r=n-r\n  if r==0:\n    return 1\n  f=lambda x,y:x*y%DIV\n  X=reduce(f,range(n-r+1,n+1))\n  Y=reduce(f,range(1,r+1))\n  return X*pow(Y,DIV-2,DIV)%DIV\n\nn, k = map(int, input().split())\nmod = pow(10, 9) + 7\nfor i in range(k):\n    ans = -1\n    if i+1 > n-k+1:\n        ans = 0\n    else:\n        ans = (nCr(k - 1, i, mod) * nCr(n - k + 1, i + 1, mod)) % mod\n\n    print(ans)", "class Factorial():\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        ''' n! % mod '''\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._factorial[n]\n    \n    def _make(self, n):\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def fact_inv(self, n):\n        ''' n!^-1 % mod '''\n        if n >= self.mod:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        self._make(n)\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        if self._factorial_inv[n] == -1:\n            self._factorial_inv[n] = self.modinv(self._factorial[n])\n        return self._factorial_inv[n]\n    \n    @staticmethod\n    def xgcd(a, b):\n        '''\n        Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b)\n        '''\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        if g != 1:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        return x % self.mod\n\n    def comb(self, n, r):\n        ''' nCr % mod '''\n        if r > n:\n            return 0\n        t = self(n)*self.fact_inv(n-r) % self.mod\n        return t*self.fact_inv(r) % self.mod\n    \n    def comb_(self, n, r):\n        '''\n        nCr % mod\n        when r is not large and n is too large\n        '''\n        c = 1\n        for i in range(1, r+1):\n            c *= (n-i+1) * self.fact_inv(i)\n            c %= self.mod\n        return c\n\n    def comb_with_repetition(self, n, r):\n        ''' nHr % mod '''\n        t = self(n+r-1)*self.fact_inv(n-1) % self.mod\n        return t*self.fact_inv(r) % self.mod\n\n    def perm(self, n, r):\n        ''' nPr % mod '''\n        if r > n:\n            return 0\n        return self(n)*self.fact_inv(n-r) % self.mod\n\nn, k = map(int, input().split())\nmod = 10**9 + 7\ncomb = Factorial().comb\n\nfor i in range(1, k+1):\n    print(comb(n-k+1, i)*comb(k-1, i-1) % mod)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10 ** 9 + 7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef combMod(n, r, p):\n    numer = 1\n    denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n-r+i) % p\n        denom = denom * i % p\n    return numer * pow(denom, p-2, p) % p\n\ndef resolve():\n    N, K = LI()\n\n    for i in range(1, K + 1):\n        if i <= N - K + 1:\n            # \u9752\u7389\u3092i\u500b\u306e1\u500b\u4ee5\u4e0a\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\n            # \u8d64\u7389\u306f\u9752\u7389\u306e\u9699\u9593\u306b1\u500b\u305a\u3064\u7f6e\u3044\u305f\u5f8c\u30010\u500b\u4ee5\u4e0a\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\n            ans = combMod(K - 1, i - 1, MOD) * combMod(N - K + 1, i, MOD) % MOD\n            print(ans)\n        else:\n            print((0))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()"]
["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nA=[]\nCOVERED=[0]*(m+1)\n\nfor i in range(n):\n    x,y=list(map(int,input().split()))\n    A.append((x-y,x+y))\n\n    for j in range(max(0,x-y),min(m+1,x+y+1)):\n        COVERED[j]=1\n\nif min(COVERED[1:])==1:\n    print(0)\n    return\n\nA.sort()\n\nDP=[m]*(m+2)\nDP[1]=0\n\ncovind=1\n\nwhile COVERED[covind]==1:\n    DP[covind]=0\n    covind+=1\nDP[covind]=0\n\nNEXT=[i+1 for i in range(m+1)]\nfor j in range(m-1,-1,-1):\n    if COVERED[j+1]==1:\n        NEXT[j]=NEXT[j+1]\n\ndef nex(i):\n    if i<=m:\n        return NEXT[i]\n    else:\n        return m+1\n\n\nfor i in range(1,m+1):\n    if COVERED[i]==1:\n        continue\n\n    for x,y in A:\n        if x<i:\n            continue\n        DP[nex(y+(x-i))]=min(DP[i]+(x-i),DP[nex(y+(x-i))])\n\n#print(DP)\nANS=DP[-1]\nfor i in range(m,-1,-1):\n    if DP[i]!=m+1:\n        ANS=(min(ANS,DP[i]+(m+1-i)))\n\nprint(ANS)\n\n        \n        \n    \n", "import sys\nfrom operator import itemgetter\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\nINF = 10**9\n\n\nnew_info = []\nfor pos, width in info:\n    tmp = [max(pos-width-1, 0), min(pos+width, m)]\n    new_info.append(tmp)\n\npos = 0\nnew_info = sorted(new_info, key = itemgetter(1))\ndp = [[0]*(m+2) for i in range(n+1)]\n\nfor i in range(m+2):\n    dp[0][i] = i\n\nfor i in range(n):\n    begin, end = new_info[i]\n    for j in range(m+2):\n        if j <= end:\n            dp[i+1][j] = min(dp[i][begin], dp[i][j])\n        else:\n            dp[i+1][j] = min((j - end) + dp[i][max(begin - (j-end), 0)], dp[i][j])\n\nprint(dp[n][m])    ", "3\n\nimport os\nimport sys\n\n\ndef main():\n    N, M = read_ints()\n    A = [tuple(read_ints()) for _ in range(N)]\n    print(solve(N, M, A))\n\n\ndef solve(N, M, A):\n    A.sort()\n\n    D = {0: 0}\n    for x, s in A:\n        #dprint(x, s)\n        #dprint(D)\n        d = D.copy()\n        for x0, c in d.items():\n            if x - s <= x0 + 1:\n                nx = x + s\n                #dprint('  ', nx, '=>', c, '(x0=', x0, 'c=', c, ')')\n                if nx not in D:\n                    D[nx] = c\n                else:\n                    D[nx] = min(D[nx], c)\n            else:\n                nc = c + (x - s - x0 - 1)\n                nx = x + s + nc - c\n                #dprint('  ', nx, '=>', nc, '(x0=', x0, 'c=', c, ')')\n                if nx not in D:\n                    D[nx] = nc\n                else:\n                    D[nx] = min(D[nx], nc)\n        #dprint(D)\n\n    best = M * 2\n    for x, c in D.items():\n        if x == 0:\n            continue\n        if x < M:\n            c += M - x\n        best = min(best, c)\n    return best\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom operator import itemgetter\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\n \ninf = 10**9+7\n\n \nXS = [(0, 0)] + [tuple(map(int, readline().split())) for _ in range(N)]\nXS.sort(key = lambda x: x[0]-x[1])\nx, s = XS[0]\n\ndp1 = [0] + [max(0, x-s-1, j-x-s) for j in range(1, M+2)]\nfor x, s in XS[1:]:\n    \n    dp1n = dp1[:]\n    \n    dp1n[min(M, x+s)] = min(dp1n[min(M, x+s)], dp1[max(0, x-s-1)])\n    for j in range(M):\n        if x + s + j > M:\n            break\n        dp1n[x+s+j] = min(dp1n[x+s+j], j + dp1[max(0, x-s-1-j)])\n   \n    dp1 = dp1n[:]\n    \n    for i in range(M, -1, -1):\n        dp1[i] = min(dp1[i], dp1[i+1])\nprint(dp1[M]) ", "import sys\ninput = sys.stdin.readline\n\nn,m = map(int,input().split())\ndg = 10**10\n\ns = [0]\nt = [0]\n\ntank = []\nfor _ in [0]*n:\n    X,d = map(int,input().split())\n    tank.append((X+d)*dg + X)\ntank.sort()\n\nfor e in tank:\n    X_d = e//dg\n    X = e%dg\n    d = X_d-X\n    s.append(max(1,X_d-d*2))\n    t.append(min(m,X_d))\n\n\nn += 1\n\ndp = [[0]*(m+1) for i in range(2)]\nfor j in range(1,t[0]+1):\n    dp[0][j] = s[0]-1\nfor j in range(t[0]+1,m+1):\n    dp[0][j] = max(s[0]-1,j-t[0])\n\nfor i in range(1,n):\n    for j in range(1,m+1):\n        tmp = dp[(i+1)%2][j]\n        if j <= t[i]:\n            tmp = min(tmp,dp[(i+1)%2][s[i]-1])\n        else:\n            tmp = min(tmp,dp[(i+1)%2][max(0,s[i]+t[i]-j-1)]+j-t[i])\n        dp[i%2][j] = tmp\n\nprint(dp[(n+1)%2][-1])", "# Antennas coverage\n\nimport sys\nfrom bisect import bisect_right\n\n\ndef upgrade_minCost(n, m, antennas):\n    covered = [False] * (m + 1)\n    intervals = []\n    for x, s in antennas:\n        L = max(1, x - s)\n        R = min(m, x + s)\n        intervals.append((L, R))\n        for i in range(L, R + 1):\n            covered[i] = True\n    intervals.sort()\n            \n    d = [(m - i) for i in range(m + 1)]\n    for i in range(m - 1, -1, -1):\n        if covered[i + 1]:\n            d[i] = d[i + 1]\n        else:\n            ant_idx = bisect_right(intervals, (i, m))\n            for L, R in intervals[ant_idx:]:\n                u = L - i - 1\n                prev = min(m, R + u)\n                d[i] = min(d[i], u + d[prev])\n    return d[0]\n\ndef main():\n    # inf = open('input.txt', 'r')\n    # reader = (map(int, line.split()) for line in inf)\n    reader = (map(int, s.split()) for s in sys.stdin)\n\n    n, m = next(reader)\n    antennas = [list(next(reader)) for _ in range(n)]\n    ans = upgrade_minCost(n, m, antennas)\n    print(ans)\n    \n    # inf.close()\n\ndef __starting_point():\n    main()\n__starting_point()", "def dp(ind, max_covered):\n\tmax_covered = min(m, max_covered)\n\n\tif ind not in cache:\n\t\tcache[ind] = {}\n\n\td = cache[ind]\n\tif max_covered in d:\n\t\treturn d[max_covered]\n\n\tans = blah(ind, max_covered)\n\n\td[max_covered] = ans\n\treturn ans\n\n\n# path = {}\n\nclass Node:\n\tdef __init__(self, key, val, next=None):\n\t\tself.key = key\n\t\tself.val = val\n\t\tself.next = next\n\ndef blah(ind, max_covered):\n\tx, s = antenna[ind]\n\t# key = (ind, max_covered)\n\n\tif max_covered >= m:\n\t\t# path[key] = Node(key, 0)\n\t\treturn 0\n\n\tif ind == len(antenna) - 1:\n\t\tif max_covered < x - s - 1:\n\t\t\tleft_needed = x - s - (max_covered + 1)\n\t\t\tright_needed = max(m - (x + s), 0)\n\t\t\tans = max(left_needed, right_needed)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\t\telse:\n\t\t\tright_boundary = max(max_covered, x + s)\n\t\t\tans = max(0, m - right_boundary)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\n\tif max_covered < x - s - 1:\n\t\tnum_needed = x - s - (max_covered + 1)\n\t\tnew_boundary = min(x + s + num_needed, m)\n\t\tuse_i = num_needed + dp(ind + 1, new_boundary)\n\t\tdont_use_i = dp(ind + 1, max_covered)\n\n\t\t# if use_i < dont_use_i:\n\t\t# \tpath[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])\n\t\t# else:\n\t\t# \tpath[key] = Node(key, 0, path[(ind + 1, max_covered)])\n\n\t\treturn min(use_i, dont_use_i)\n\telse:\n\t\tnew_boundary = min(max(max_covered, x + s), m)\n\t\tans = dp(ind + 1, new_boundary)\n\t\t# path[key] = Node(key, 0, path[(ind + 1, new_boundary)])\n\t\treturn ans\n\nimport sys\n\ncache = {}\n\n\nn, m = [int(x) for x in sys.stdin.readline().split(\" \")]\n\nantenna = []\n\nfor i in range(n):\n\tx, s = [int(x) for x in sys.stdin.readline().split(\" \")]\n\n\tantenna.append((x, s))\n\nantenna.sort(key=lambda a: a[0])\n\nprint(dp(0, 0))\n", "     \nA = [(0, 0)]\ninf = 999999999999\nn, m = map(int, input().split())\n \nfor i in range(1, n+1):\n    x, s = map(int, input().split())\n    A.append((max(0, x-s), min(m, x+s)))\ndp = [inf] * (m+1)\ndp[0] = 0\nA = sorted(A)\n \nfor p in range(1, m+1):    \n    for i in range(1, n+1):\n \n        a, b = A[i]\n \n        if p >= a and p <= b:\n            dp[p] = dp[p-1]\n        elif p < a:\n            pwr = a - p\n            dp[p] = min(dp[p], pwr + dp[max(0,a-pwr-1)], p)\n        elif p > b:\n            pwr = p - b\n            dp[p] = min(dp[p], pwr + dp[max(a-pwr-1,0)], p)\n \nprint(dp[m])", "     \nA = []\nn, m = map(int, input().split())\n \nfor i in range(1, n+1):\n    x, s = map(int, input().split())\n    A.append((max(0, x-s), min(m, x+s)))\ndp = [9999999] * (m+1)\ndp[0] = 0\n\nfor p in range(1, m+1):    \n    for i in range(n): \n        a, b = A[i]\n \n        if p >= a and p <= b:\n            dp[p] = dp[p-1]\n        elif p < a:\n            pwr = a - p\n            dp[p] = min(dp[p], pwr + dp[max(0,a-pwr-1)], p)\n        elif p > b:\n            pwr = p - b\n            dp[p] = min(dp[p], pwr + dp[max(a-pwr-1,0)], p)\n \nprint(dp[m])", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\nantena = [list(map(int, input().split())) for i in range(n)]\nDP = [float(\"inf\")]*(m+1)\nDP[0] = 0\n\nfor i in range(1, m+1):\n    DP[i] = i\n    for x, s in antena:\n        l = max(1, x-s)\n        r = min(m, x+s)\n        if l<=i<=r:\n            DP[i] = DP[i-1]\n            break\n        elif r<i:\n            cost = i-r\n            DP[i] = min(DP[i], DP[max(0, l-cost-1)] + cost)\nprint(DP[-1])", "n , m  = list(map(int,input().split()))\na=[]\nfor i in range(n):\n    b , c = list(map(int,input().split()))\n    a.append((max(0,b-c),min(b+c,m)))\ndp=[0]*(m+1)\nfor i in range(1,m+1):\n    dp[i]=i\n    for j in range(n):\n        c,d=a[j]\n        if c<=i and i<=d:\n            dp[i]=dp[i-1]\n        elif i<c:\n            cost=c-i\n            dp[i]=min(dp[i],cost+dp[max(0,c-cost-1)])\n        elif i>d:\n            cost=i-d\n            dp[i]=min(dp[i],cost+dp[max(0,c-cost-1)])\nprint(dp[m])            \n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nSt = [list(map(int, input().split())) for _ in range(N)]\n\n\ndp = [M-i for i in range(M+1)]\n\nfor m in reversed(range(M)):\n    covered = False\n    for x, s in St:\n        if x-s <= m+1 <= x+s:\n            covered = True\n            break\n        if m < x-s:\n            u = x-s-m-1\n            dp[m] = min(dp[m], u+dp[min(M, x+s+u)])\n    if covered:\n        dp[m] = dp[m+1]\n\nprint(dp[0])", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\n# M = mod = 10**9 + 7\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n# def inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn, m = li()\nl = []\nfor i in range(n):\n    x, y = li()\n    l.append([x-y,x+y])\n\ndp = [m for i in range(m+1)]\ndp[0] = 0\nfor i in range(1,m+1):\n    dp[i] = min(dp[i-1] + 1,dp[i])\n    for j in l:\n        x = max(0,j[0] - i)\n        y = min(m,j[1] + x)\n        dp[y] = min(dp[y],dp[i - 1] + x)\n\nprint(dp[-1])", "n, m = list(map(int,input().split(' ')))\nl = []\nfor i in range(n):\n    x, y = list(map(int,input().split(' ')))\n    l.append([x-y,x+y])\n\ndp = [m for i in range(m+1)]\ndp[0] = 0\nfor i in range(1,m+1):\n    dp[i] = min(dp[i-1] + 1,dp[i])\n    for j in l:\n        x = max(0,j[0] - i)\n        y = min(m,j[1] + x)\n        dp[y] = min(dp[y],dp[i - 1] + x)\n\nprint(dp[-1])", "n, m, l = list(map(int,input().split(' '))) + [[]]\nfor i in range(n):l.append(list(map(int,input().split(' '))))\ndp = [0] + [m for i in range(m)]\nfor i in range(1,m+1):\n    dp[i] = min(dp[i-1] + 1,dp[i])\n    for j in l:\n        x = max(0,j[0] - j[1] - i)\n        y = min(m,j[0] + j[1] + x)\n        dp[y] = min(dp[y],dp[i - 1] + x)\nprint(dp[-1])", "def readint():\n  return int(input())\n\ndef readlistint():\n  return list(map(int, input().split()))\n\ndef readgridint(rows):\n  grid = []\n  for idx in range(rows):\n    col = list(map(int, input().split()))\n    grid.append(col)\n  \n  return grid\n\nantennas = []\ntotal_len = -1\nmemo = {}\ndef solve(left, idx):\n  if(left > total_len):\n    return 0\n  key = (left, idx)\n  if(key in memo):\n    return memo[key]\n  if(idx == len(antennas) - 1):\n    ret = max(0, max(antennas[idx][0] - left, total_len - antennas[idx][1]))\n    #print(left, idx, ret)\n    memo[key] = ret\n    return ret\n  else:\n    best = solve(left, idx + 1)\n    best = min(best, max(0, max(antennas[idx][0] - left, total_len - antennas[idx][1])))\n    added = max(antennas[idx][0] - left, 0)\n    best = min(best, added + solve(antennas[idx][1] + added + 1, idx+1))\n    memo[key] = best\n    return best\n    \ndef main():\n  nonlocal total_len\n  N, L = readlistint()\n  total_len = L\n  for idx in range(N):\n    pos, R = readlistint()\n    antennas.append([pos-R, pos + R])\n  \n  antennas.sort()\n  #print(total_len, antennas)\n  #ret = solve(1, 0)\n  #print(ret)\n  \n  INF = 100000000000\n  dp = [INF]*(total_len + 10)\n  dp[0] = 0\n  for ant in antennas:\n    ant_left, ant_right = ant\n    for idx in range(0, total_len + 1):\n      if(dp[idx] == INF):\n        continue\n      dp[total_len] = min(dp[total_len], dp[idx] + max(0, max(ant_left - idx - 1, total_len - ant_right)))\n      added = max(ant_left - idx - 1, 0)\n      right_point = min(total_len, ant_right + added)\n      dp[right_point] = min(dp[right_point], dp[idx] + added)\n  \n  print(dp[total_len])\n  \n\n\nmain()", "#watu\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nSt = [list(map(int, input().split())) for _ in range(N)]\n\n\ndp = [M-i for i in range(M+1)]\n\nfor m in reversed(range(M)):\n    covered = False\n    for x, s in St:\n        if x-s <= m+1 <= x+s:\n            covered = True\n            break\n        if m < x-s:\n            u = x-s-m-1\n            dp[m] = min(dp[m], u+dp[min(M, x+s+u)])\n    if covered:\n        dp[m] = dp[m+1]\n\nprint(dp[0])", "import os\nimport sys\n\n\ndef solve(xs, m):\n    xs = [(0, 0)] + xs\n    dp = [0] * (m + 1)\n    for i in range(1, m + 1):\n        dp[i] = dp[i - 1] + 1\n        for idx, (x, s) in enumerate(xs):\n            if x - s <= i <= x + s:\n                dp[i] = dp[i - 1]\n                break\n\n            if x + s < i:\n                c = i - x - s\n                dp[i] = min(c + dp[max(x - c - s - 1, 0)], dp[i])\n\n    return dp[-1]\n\n\ndef pp(input):\n    n, m = list(map(int, input().split()))\n    xs = [tuple(map(int, input().split())) for _ in range(n)]\n    print(solve(xs, m))\n\n\nif \"paalto\" in os.getcwd():\n    from string_source import string_source\n\n    pp(\n        string_source(\n            \"\"\"2 50\n20 0\n3 1\n\"\"\"\n        )\n    )\n\n    pp(\n        string_source(\n            \"\"\"3 595\n43 2\n300 4\n554 10\n\"\"\"\n        )\n    )\n\n    pp(\n        string_source(\n            \"\"\"1 1\n1 1\n\"\"\"\n        )\n    )\n\n    pp(\n        string_source(\n            \"\"\"5 240\n13 0\n50 25\n60 5\n155 70\n165 70\n\"\"\"\n        )\n    )\n\nelse:\n    pp(sys.stdin.readline)\n"]
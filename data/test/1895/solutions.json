["import time\n\nn, m =map(int, input().split())\n\nnames={None:0}\n\ncount={i:0 for i in range(1, m+1)}\n\na=[0]*(n+1)\n\nfor i in range(n):\n    l=list(input().split())\n    if l[0]=='2':\n        if l[1] not in names:\n            names[l[1]]=len(names)\n        a[i]=names[l[1]]\n        count[a[i]]=count[a[i]]+1\n    # else a[i] stays 0\n\ndense=[set() for _ in range(m+1)]\n\nbulk=set()\n\n# filling dense array of arrays\nfor i in range(n):\n    if a[i]==0:\n        bulk.clear()\n        continue\n    if a[i] in bulk: continue\n    for j in bulk:\n        dense[j].add(a[i])\n        dense[a[i]].add(j)\n    bulk.add(a[i])\n\nres=0\nhappy=set()\nunhappy=set()\nmindep=99\n\nindependent=set()\ndependent=set()\nfor i in range(1, m+1):\n    if len(dense[i])==0: independent.add(i)\n    else:\n        dependent.add(i)\n        if len(dense[i])<mindep:\n            mindep=len(dense[i])\n\n# print([i for i in dependent if mindep==len(dense[i])])\n\nfor k in list(dependent):\n    # iterate to... too sly\n    happy.clear()\n    unhappy.clear()\n    bulk.clear()\n    bulk.update(dependent)\n    happy.add(k)\n    bulk.remove(k)\n    for j in dense[k]:\n        if j in bulk:\n            unhappy.add(j)\n            bulk.remove(j)\n\n    # now making least connected happy\n    while bulk:\n        mini = min([len(dense[i]) for i in bulk])\n        for i in list(bulk):\n            if len(dense[i])==mini and (i in bulk):\n                happy.add(i)\n                bulk.remove(i)\n                for j in dense[i]:\n                    if j in bulk:\n                        unhappy.add(j)\n                        bulk.remove(j)\n                continue\n\n    res=max(res,len(happy))\n\nprint(res+len(independent))", "import time\n\ndef find_max_clique(remain, size, max_, index, maxs):\n    # print(remain, size, max_)\n    result = max_\n    if size + len(remain) <= result:\n        # print('pruning (1)...')\n        return result\n    if not remain:\n        # print('trivial')\n        return size\n    while remain:\n        candidate = max(remain)\n        # print('get candidate:', candidate)\n        if maxs[candidate] + size <= result:\n            # print('pruning (2)...')\n            return result\n        if size + len(remain) <= result:\n            # print('pruning (3)...')\n            return result\n        remain.remove(candidate)\n        # print('entering...')\n        sub_result = find_max_clique(remain & index[candidate], size + 1 , result, index, maxs)\n        if sub_result > result:\n            # print('{} > {}, existing...'.format(sub_result, result))\n            result = sub_result\n            return result\n    # print('result:', result)\n    return result\n\ndef test_find():\n    # index = {1: {2, 3, 4}, 2: {1, 3, 4}, 3: {1, 2}, 4: {1, 2}}\n    index = [{2, 4, 5, 7}, {4, 5, 6}, {0, 5, 6, 7},\n        {5, 6 ,7}, {0, 1, 6, 7}, {0, 1, 2, 3}, {1, 2, 3, 4},\n        {0, 2, 3, 4}]\n    m = 8\n    maxs = [0] * m\n    whole = set()\n    for i in range(m):\n        # print('i:', i)\n        whole.add(i)\n        # print('w:', whole)\n        maxs[i] = max(maxs[i - 1], find_max_clique(whole & index[i], 1, maxs[i - 1], index, maxs))\n        # print()\n    # print(maxs)\n\ndef solve(events, m):\n    index = [set() for _ in range(m)]\n    r = []\n    while events:\n        ele = events.pop()\n        if ele is None:\n            # ele is None\n            r.clear()\n        else:\n            # ele not None.\n            for n in r:\n                index[n].add(ele)\n            index[ele].update(r)\n            r.append(ele)\n    whole = set(range(m))\n    # print('w:', whole)\n    for i in range(m):\n        index[i] = whole - index[i] - {i}\n    maxs = [0] * m\n    whole = set()\n    for i in range(m):\n        whole.add(i)\n        maxs[i] = max(maxs[i - 1], find_max_clique(whole & index[i], 1, maxs[i - 1], index, maxs))\n    return maxs[-1]\n\n\ndef test():\n    events = []\n    m = 700\n    for i in range(m):\n        events.extend([None, i])\n    tick = time.time()\n    print(solve(events, m))\n    tock = time.time()\n    print('T:', round(tock - tick, 5)) \n    \ndef main():\n    # Deal input here.\n    n, m = list(map(int, input().split()))\n    events = []\n    d = {}\n    id_ = 0\n    for i in range(n):\n        line = input()\n        if line.startswith('1'):\n            events.append(None)\n        else:\n            if line not in d:\n                d[line] = id_\n                id_ += 1\n            events.append(d[line])\n    \n    # tick = time.time()\n    print(solve(events, m))\n    # tock = time.time()\n    # print(round(tock - tick, 5))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
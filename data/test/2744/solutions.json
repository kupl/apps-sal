["from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) + stream.truncate(0) + stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 2*10**12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ns = sys.stdin.read().replace(b'\\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(x))\n    sys.stdout.write('\\n')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) + stream.truncate(0) + stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ns = sys.stdin.read().replace(b'\\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write('\\n')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ns = sys.stdin.read().replace(b'\\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\n###### ACTUAL CODE\ns = sys.stdin.read().replace(b'\\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nimport heapq\nQ = [(best[i],i) for i in range(n)]\nheapq.heapify(Q)\n\nwhile Q:\n    c,node = heapq.heappop(Q)\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            heapq.heappush(Q,(C, nei))\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\n###### REWRITTEN HEAPQ\ndef heappush(heap, item):\n    heap.append(item)\n    _siftdown(heap, len(heap)-1)\n\ndef heappop(heap):\n    lastelt = heap.pop()\n    if not heap:\n        return lastelt\n\n    returnitem,heap[0] = heap[0],lastelt\n    _siftup(heap)\n    return returnitem\n\n# Does a pop and then a push\ndef heapreplace(heap, item):\n    returnitem,heap[0] = heap[0],item\n    _siftup(heap)\n    return returnitem\n\n# Does a push and then a pop\ndef heappushpop(heap, item):\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap)\n    return item\n\ndef heapify(x):\n    for i in reversed(range(len(x)//2)):\n        _siftup(x, i)\n\n\ndef _siftdown(heap, pos):\n    newitem = heap[pos]\n    ppos = (pos-1) >> 1\n    while pos and newitem < heap[ppos]:\n        heap[pos] = heap[ppos]\n        pos = ppos\n        ppos = (pos-1) >> 1\n    heap[pos] = newitem\n\ndef _siftup(heap, pos=0):\n    # Move the item at pos to a leaf\n    # by switching place with smallest child (bias to right)\n    newitem = heap[pos]\n    \n    leftchild = 2*pos + 1\n    rightchild = leftchild + 1\n    while rightchild < len(heap):\n        if heap[leftchild] < heap[rightchild]:\n            heap[pos] = heap[leftchild]\n            pos = leftchild\n        else:\n            heap[pos] = heap[rightchild]\n            pos = rightchild\n        leftchild = 2*pos + 1\n        rightchild = leftchild + 1\n    if leftchild < len(heap): # Special case of only one child\n        heap[pos] = heap[leftchild]\n        pos = leftchild\n    # Now newitem has been moved to an leaf\n    heap[pos] = newitem\n    _siftdown(heap,pos)\n\n###### ACTUAL CODE\ns = sys.stdin.read().replace(b'\\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\n\nQ = [(best[i],i) for i in range(n)]\nheapify(Q)\n\nwhile Q:\n    c,node = heappop(Q)\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            heappush(Q,(C, nei))\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0; sign = 1\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            elif s[i] == b'-'[0]: sign = -1\n            else: A.append(sign*numb); numb = 0; sign = 1\n        if s[-1]>=b'0'[0]: A.append(sign*numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ninp = sys.stdin.readint()\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0; sign = 1\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            elif s[i] == b'-'[0]: sign = -1\n            else: A.append(sign*numb); numb = 0; sign = 1\n        if s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ninp = sys.stdin.readint()\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readuint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            else: A.append(numb); numb = 0\n        if s and s[-1] >= b'0'[0]: A.append(numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ninp = sys.stdin.readuint()\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = 1.0*inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [1.0*inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readuint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            else: A.append(numb); numb = 0\n        if s and s[-1] >= b'0'[0]: A.append(numb)\n        return A\n    def readint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0; sign = 1\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            elif s[i] == b'-'[0]: sign = -1\n            else: A.append(sign*numb); numb = 0; sign = 1\n        if s and s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n    def readfloat(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0.0; sign = 1.0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10.0*numb + conv(s[i])-48.0\n            elif s[i] == b'-'[0]: sign = -1.0\n            else: A.append(sign*numb); numb = 0.0; sign = 1.0\n        if s and s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n    def readufloat(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0.0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10.0*numb + conv(s[i])-48.0\n            else: A.append(numb); numb = 0.0\n        if s and s[-1] >= b'0'[0]: A.append(numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ninp = sys.stdin.readufloat()\nind = 0\n\nn = int(inp[ind])\nind += 1\nm = int(inp[ind])\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[ind+0]-1)\n    u = int(inp[ind+1]-1)\n    w = inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readuint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            else: A.append(numb); numb = 0\n        if s and s[-1] >= b'0'[0]: A.append(numb)\n        return A\n    def readint(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0; sign = 1\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10*numb + conv(s[i])-48\n            elif s[i] == b'-'[0]: sign = -1\n            else: A.append(sign*numb); numb = 0; sign = 1\n        if s and s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n    def readfloat(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0.0; sign = 1.0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10.0*numb + conv(s[i])-48.0\n            elif s[i] == b'-'[0]: sign = -1.0\n            else: A.append(sign*numb); numb = 0.0; sign = 1.0\n        if s and s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n    def readufloat(self):\n        conv = ord if py2 else lambda x:x\n        s = sys.stdin.read().replace(b'\\r',b'')\n        A = []; numb = 0.0\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10.0*numb + conv(s[i])-48.0\n            else: A.append(numb); numb = 0.0\n        if s and s[-1] >= b'0'[0]: A.append(numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ninp = sys.stdin.readfloat()\nind = 0\n\nn = int(inp[ind])\nind += 1\nm = int(inp[ind])\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[ind+0]-1)\n    u = int(inp[ind+1]-1)\n    w = inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize:break\n            c = self.stream.read(1)[0]\n            curpos += 1\n            if c >= b'0'[0]: numb = 10 * numb + (conv(c) - 48)\n            elif c == b'-'[0]: sign = -1\n            elif c != b'\\r'[0]: A.append(sign*numb); numb = zero; sign = 1\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod, (Note, currently experimenting, not fully working)\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size).replace(b'\\r',b'')\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize:break\n            c = self.stream.read(1)[0]\n            curpos += 1\n            if c >= b'0'[0]: numb = 10 * numb + (conv(c) - 48)\n            elif c == b'-'[0]: sign = -1\n            else: A.append(sign*numb); numb = zero; sign = 1\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size).replace(b'\\r',b'')\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(1000,buffsize-curpos))\n            for i in range(len(s)):\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] == b'-'[0]: sign = -1\n                else: A.append(sign*numb); numb = zero; sign = 1\n                if len(A)==n: break\n            curpos += i+1\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size).replace(b'\\r',b'')\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(10000,buffsize-curpos))\n            for i in range(len(s)):\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] == b'-'[0]: sign = -1\n                else: A.append(sign*numb); numb = zero; sign = 1\n                if len(A)==n: break\n            curpos += i+1\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(10000,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(10,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(256,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(64,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(32,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, zero=0):\n        conv = ord if py2 else lambda x:x\n        s = self.read()\n        A = []; numb = zero; sign = 1\n        for i in range(len(s)):\n            if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n            elif s[i] != b'\\r'[0]:\n                if s[i] == b'-'[0]: sign = -1\n                else: A.append(sign*numb); numb = zero; sign = 1\n        if s and s[-1] >= b'0'[0]: A.append(sign*numb)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\ninp = sys.stdin.readnumbers(0.0)\nind = 0\n\nn = int(inp[ind])\nind += 1\nm = int(inp[ind])\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[ind+0]-1)\n    u = int(inp[ind+1]-1)\n    w = inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                buffsize += len(self.read2buffer())\n                if curpos==buffsize: break\n            s = self.stream.read(min(64,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)<n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                buffsize += len(self.read2buffer())\n                if curpos==buffsize: break\n            s = self.stream.read(min(64,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)<n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        if self.stream.tell()!=curpos: self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                buffsize += len(self.read2buffer())\n                if curpos==buffsize: break\n            s = self.stream.read(min(128,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)<n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        if self.stream.tell()!=curpos: self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\n# OLD VERSION\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                self.read2buffer()\n                self.stream.seek(0,2)\n                buffsize = self.stream.tell()\n                self.stream.seek(curpos)\n                if curpos==buffsize: break\n            s = self.stream.read(min(64,buffsize-curpos))\n            i = 0\n            while i<len(s) and len(A)!=n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: \n                    if s[i] == b'-'[0]: sign = -1\n                    else: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')", "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                buffsize += len(self.read2buffer())\n                if curpos==buffsize: break\n            small_buff = min(64,buffsize-curpos)\n            s = self.stream.read(small_buff)\n            i = 0\n            while i<small_buff and len(A)<n:\n                if s[i] >= b'-'[0]:\n                    if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                    else: sign = -1    \n                elif s[i] != b'\\r'[0]: A.append(sign*numb); numb = zero; sign = 1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        if self.stream.tell()!=curpos: self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')"]
["from collections import defaultdict\nimport sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef main():\n    N = int(input())\n    V = 100005\n    to = defaultdict(list)\n    for _ in range(N):\n        X, Y = map(int, input().split())\n        Y += V\n        to[X].append(Y)\n        to[Y].append(X)\n    visited = [0] * (2 * V)\n    cnt = [0] * 2  # cnt = [cnt of X, cnt of Y]\n\n    def dfs(v):\n        if visited[v] == 1:\n            return\n        visited[v] = 1\n        cnt[v // V] += 1\n        for nv in to[v]:\n            dfs(nv)\n\n    ans = 0\n    for v in range(2 * V):\n        if visited[v] == 1:\n            continue\n        cnt = [0] * 2\n        dfs(v)\n        ans += cnt[0] * cnt[1]\n    ans -= N\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        \"\"\"\n        \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"\n        y\u3092x\u306e\u6839\u306b\u7e4b\u3050\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        \"\"\"\n        x\u3068y\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"\n        x\u306e\u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def kruskal(self, edge):\n        \"\"\"\n        :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n        :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n        \"\"\"\n        edge.sort()\n        cost_sum = 0\n        for cost, node1, node2 in edge:\n            if not self.same(node1, node2):\n                cost_sum += cost\n                self.union(node1, node2)\n        return cost_sum\n\n\ndef resolve():\n    n = int(input())\n    MAX = 10 ** 5 + 10\n    uf = UnionFind(2 * MAX)\n    XY = []\n    for _ in range(n):\n        x, y = [int(x) - 1 for x in input().split()]\n        y += MAX\n        uf.union(x, y)\n        XY.append([x, y])\n\n    mx = defaultdict(int)\n    my = defaultdict(int)\n    for i in range(MAX):\n        mx[uf.find(i)] += 1\n\n    for i in range(MAX, 2 * MAX):\n        my[uf.find(i)] += 1\n\n    res = 0\n    for i in range(2 * MAX):\n        res += mx[i] * my[i]\n\n    print((res - n))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import defaultdict\n\n\nclass UnionFind():\n    n = 1\n    par = [0]\n    rnk = [0]\n\n    def __init__(self, size):\n        self.n = size\n        self.par = [i for i in range(self.n)]\n        self.rnk = [0 for i in range(self.n)]\n\n    def find(self, vertex1):\n        if self.par[vertex1] == vertex1:\n            return vertex1\n        else:\n            self.par[vertex1] = self.find(self.par[vertex1])\n            return self.par[vertex1]\n\n    def unite(self, vertex1, vertex2):\n        vertex1 = self.find(vertex1)\n        vertex2 = self.find(vertex2)\n        if vertex1 == vertex2:\n            return\n        if (self.rnk[vertex1] < self.rnk[vertex2]):\n            self.par[vertex1] = vertex2\n        else:\n            self.par[vertex2] = vertex1\n            if (self.rnk[vertex1] == self.rnk[vertex2]):\n                self.rnk[vertex1] += 1\n\n    def same(self, vetrex1, vertex2):\n        return self.find(vetrex1) == self.find(vertex2)\n\n\nN = int(input())\nP = [(i,) + tuple(map(int, input().split())) for i in range(N)]\nG = UnionFind(N)\nP.sort(key=lambda x: x[1])\nfor i in range(N - 1):\n    if P[i][1] == P[i + 1][1]:\n        G.unite(P[i][0], P[i + 1][0])\nP.sort(key=lambda x: x[2])\nfor i in range(N - 1):\n    if P[i][2] == P[i + 1][2]:\n        G.unite(P[i][0], P[i + 1][0])\nP.sort(key=lambda x: x[0])\nDx = defaultdict(set)\nDy = defaultdict(set)\nfor i in range(N):\n    j = G.find(i)\n    Dx[j].add(P[i][1])\n    Dy[j].add(P[i][2])\nans = -N\nfor j in Dx:\n    ans += len(Dx[j]) * len(Dy[j])\nprint(ans)", "n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nadj = [[] for _ in range(200000)]\nfor x, y in p:\n\tadj[x-1].append(y+99999)\n\tadj[y+99999].append(x-1)\n\nvisited = [False for _ in range(200000)]\n\ndef dfs(orig):\n\tstack = [orig]\n\tedges = len(adj[orig])\n\tif orig < 100000:\n\t\tx_num, y_num = 1, 0\n\telse:\n\t\tx_num, y_num = 0, 1\n\n\twhile stack:\n\t\tv = stack.pop()\n\t\tfor w in adj[v]:\n\t\t\tif visited[w] == False:\n\t\t\t\tvisited[w] = True\n\t\t\t\tif w < 100000:\n\t\t\t\t\tx_num += 1\n\t\t\t\telse:\n\t\t\t\t\ty_num += 1\n\t\t\t\tedges += len(adj[w])\n\t\t\t\tstack.append(w)\n\treturn x_num * y_num - (edges // 2)\n\nans = 0\nfor i in range(200000):\n\tif visited[i] == False and adj[i]:\n\t\tvisited[i] = True\n\t\tans += dfs(i)\nprint(ans)", "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.height = [0] * size\n        self.size = [1] * size\n        self.componentCount = size\n\n    def root(self, index):\n        if self.parent[index] == index:  # \u6839\u306e\u5834\u5408\n            return index\n        rootIndex = self.root(self.parent[index])  # \u8449\u306e\u5834\u5408\u89aa\u306e\u6839\u3092\u53d6\u5f97\n        self.parent[index] = rootIndex  # \u89aa\u306e\u4ed8\u3051\u76f4\u3057\n        return rootIndex\n\n    def union(self, index1, index2):  # \u7d50\u5408\n        root1 = self.root(index1)\n        root2 = self.root(index2)\n\n        if root1 == root2:  # \u9023\u7d50\u3055\u308c\u3066\u3044\u308b\u5834\u5408\n            return\n\n        self.componentCount -= 1  # \u9023\u7d50\u6210\u5206\u3092\u6e1b\u3089\u3059\n\n        if self.height[root1] < self.height[root2]:\n            self.parent[root1] = root2  # root2\u306b\u7d50\u5408\n            self.size[root2] += self.size[root1]\n        else:\n            self.parent[root2] = root1  # root1\u306b\u7d50\u5408\n            self.size[root1] += self.size[root2]\n            if self.height[root1] == self.height[root2]:\n                self.height[root1] += 1\n        return\n\n    def isSameRoot(self, index1, index2):\n        return self.root(index1) == self.root(index2)\n\n    def sizeOfSameRoot(self, index):\n        return self.size[self.root(index)]\n\nfrom collections import defaultdict\n\nN = int(input())\nXY = [tuple(map(int, input().split())) for _ in range(N)]\n\nxGrp = defaultdict(list)\nyGrp = defaultdict(list)\nfor i, (x, y) in enumerate(XY):\n    xGrp[x].append(i)\n    yGrp[y].append(i)\n\ntree = UnionFind(N)\nfor grp in list(xGrp.values()):\n    for l, r in zip(grp, grp[1:]):\n        tree.union(l, r)\nfor grp in list(yGrp.values()):\n    for l, r in zip(grp, grp[1:]):\n        tree.union(l, r)\n\nxGrpList = defaultdict(set)\nyGrpList = defaultdict(set)\nfor i, (x, y) in enumerate(XY):\n    xGrpList[tree.root(i)].add(x)\n    yGrpList[tree.root(i)].add(y)\n\nans = 0\nfor i in range(N):\n    if i != tree.root(i):\n        continue\n    X, Y = xGrpList[i], yGrpList[i]\n    if len(X) + len(Y) < 3:\n        continue\n    A = len(X) * len(Y)\n    ans += A - tree.sizeOfSameRoot(i)\nprint(ans)\n", "class UnionFind:\n    def __init__(self, N):\n        self.p = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def find_root(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find_root(self.p[x])\n\n        return self.p[x]\n\n    def same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def unite(self, x, y):\n        u = self.find_root(x)\n        v = self.find_root(y)\n\n        if u == v: return\n\n        if self.rank[u] < self.rank[v]:\n            self.p[u] = v\n            self.size[v] += self.size[u]\n            self.size[u] = 0\n        else:\n            self.p[v] = u\n            self.size[u] += self.size[v]\n            self.size[v] = 0\n\n            if self.rank[u] == self.rank[v]:\n                self.rank[u] += 1\n\n    def get_size(self, x):\n        return self.size[self.find_root(x)]\n\nn = int(input())\nxy = [tuple(int(x) for x in input().split()) for _ in range(n)]\n\nsx = set()\nsy = set()\n\nfor x, y in xy:\n    sx.add(x)\n    sy.add(y)\n\ndx = dict()\ndy = dict()\n\nfor i, x in enumerate(sx):\n    dx[x] = i\n\nlen_x = len(sx)\nm = len(sx) + len(sy)\n\nfor i, y in enumerate(sy):\n    dy[y] = i + len_x\n\n\nuft = UnionFind(m)\n\nfor x, y in xy:\n    uft.unite(dx[x], dy[y])\n\nmx = [0] * m\nmy = [0] * m\nfor i in range(len_x):\n    mx[uft.find_root(i)] += 1\nfor i in range(len_x, m):\n    my[uft.find_root(i)] += 1\n\nans = 0\nfor i in range(m):\n    ans += mx[i] * my[i]\n\nprint(ans - n)", "#!/usr/bin/env python3\nimport sys\nfrom collections.abc import Iterable\nfrom math import *\nfrom itertools import *\nfrom collections import *\nfrom functools import *\nfrom operator import *\ntry:\n    from math import gcd\nexcept Exception:\n    from fractions import gcd\n\n\nclass DGraph:\n    def __init__(self, n, edges):\n        self._vertice = [{} for _ in range(n)]\n        for e in edges:\n            self._vertice[e[0]][e[1]] = e[2] if len(e) == 3 else 1\n\n    def __len__(self):\n        return len(self._vertice)\n\n    def edges(self, n=None):\n        srcs = list(range(len(self))) if n is None else [n]\n        return sum([[(s, d, c) for d, c in list(self._vertice[s].items())] for s in srcs], [])\n\n    def transpose(self):\n        tedges = [(t, f, c) for f, t, c in self.edges()]\n        return DGraph(len(self), tedges)\n\n    def cost(self, src, dst):\n        return self._vertice[src].get(dst, float('inf'))\n\nclass Graph(DGraph):\n    def __init__(self, n, edges):\n        nd_edges = edges + [(d, s, c) for s, d, c in edges]\n        super().__init__(n, nd_edges)\n\n    def transpose(self):\n        return self\n\n\ndef solve(N: int, x: \"List[int]\", y: \"List[int]\"):\n    xs = {v:i for i, v in enumerate(set(x))}\n    ys = {v:i for i, v in enumerate(set(y), len(xs))}\n    \n    n = len(xs) + len(ys)\n    es = [(xs[cx], ys[cy], 1) for cx, cy in zip(x, y)]\n    g = Graph(n, es)\n\n    visited = [False] * len(g)\n    def dfs(g, src):\n        nonlocal visited\n        stack = [(src, 0)]\n        while stack:\n            n, c = stack.pop()\n            if visited[n]:\n                continue\n            visited[n] = True\n\n            for _, d, _ in g.edges(n):\n                #yield d\n                stack.append((d, c + 1))\n            yield n\n\n    def _f(i):\n        ls = list(i)\n        if len(ls) == 0:\n            return 0\n\n        xc = 0\n        yc = 0\n        es = 0\n        for i in ls:\n            es += len(g.edges(i))\n            if i < len(xs):\n                xc += 1\n            else:\n                yc += 1\n        es //= 2\n\n        if xc < 2 or yc < 2:\n            return 0\n\n        return xc * yc - es\n\n    return sum([_f(dfs(g, i)) for i in range(n)])\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\" \n    y = [int()] * (N)  # type: \"List[int]\" \n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    result = solve(N, x, y)\n    if isinstance(result, Iterable) and not isinstance(result, str):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nxy = [tuple(map(int,input().split())) for _ in range(N)]\nshift = 10**5+1\n\nnodes = {}\nvisited = {}\n\nfor x,y in xy:\n    y += shift\n    if x in nodes:\n        nodes[x].append(y)\n    else:\n        nodes[x] = [y]\n    if y in nodes:\n        nodes[y].append(x)\n    else:\n        nodes[y] = [x]\n    visited[x] = False\n    visited[y] = False\n\nans = 0\n\ndef dfs(s, nodes,visited):\n    q = [s]\n    cnt_x = 0\n    cnt_y = 0\n    \n    while q:\n        v = q.pop()\n        if visited[v]:\n            continue\n        visited[v] = True\n        \n        if v//shift < 1:\n            cnt_x += 1\n        else:\n            cnt_y += 1\n            \n        q.extend(nodes[v])\n        \n    return visited, cnt_x*cnt_y\n\nfor s in nodes:\n    if visited[s]:\n        continue\n    visited, cnt = dfs(s,nodes, visited)\n    ans += cnt\n    \nprint(ans - N)", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass UnionFind:\n    \"\"\" Union-Find\u6728 \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        # \u89aa\u8981\u7d20\u306e\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u683c\u7d0d\u3002par[x] == x\u306e\u6642\u305d\u306e\u30ce\u30fc\u30c9\u306f\u6839\n        # 1-indexed\u306e\u307e\u307e\u3067OK\u3001\u305d\u306e\u5834\u5408\u306f[0]\u306f\u672a\u4f7f\u7528\n        self.par = [i for i in range(n+1)]\n        # \u6728\u306e\u9ad8\u3055\u3092\u683c\u7d0d\u3059\u308b\uff08\u521d\u671f\u72b6\u614b\u3067\u306f0\uff09\n        self.rank = [0] * (n+1)\n        # \u3042\u308b\u30ce\u30fc\u30c9\u3092\u6839\u3068\u3059\u308b\u96c6\u5408\u306b\u5c5e\u3059\u308b\u30ce\u30fc\u30c9\u6570\n        self.size = [1] * (n+1)\n        # \u3042\u308b\u30ce\u30fc\u30c9\u3092\u6839\u3068\u3059\u308b\u96c6\u5408\u304c\u6728\u304b\u3069\u3046\u304b\n        self.tree = [True] * (n+1)\n\n    def find(self, x):\n        \"\"\" \u6839\u306e\u691c\u7d22(\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3068\u8a00\u3048\u306a\u304f\u3082\u306a\u3044) \"\"\"\n        # \u6839\u306a\u3089\u305d\u306e\u756a\u53f7\u3092\u8fd4\u3059\n        if self.par[x] == x:\n            return x\n        else:\n            # \u8d70\u67fb\u3057\u3066\u3044\u304f\u904e\u7a0b\u3067\u89aa\u3092\u66f8\u304d\u63db\u3048\u308b\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        \"\"\" \u4f75\u5408 \"\"\"\n        # \u6839\u3092\u63a2\u3059\n        x = self.find(x)\n        y = self.find(y)\n\n        # \u6728\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a\u7528\n        if x == y:\n            self.tree[x] = False\n            return\n        if not self.tree[x] or not self.tree[y]:\n            self.tree[x] = self.tree[y] = False\n\n        # \u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\u3001\u4f4e\u3044\u307b\u3046\u304b\u3089\u9ad8\u3044\u307b\u3046\u306b\u8fba\u3092\u5f35\u308b\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u306a\u3089\u7247\u65b9\u30921\u5897\u3084\u3059\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def is_same(self, x, y):\n        \"\"\" \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a \"\"\"\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x=None):\n        if x is not None:\n            \"\"\" \u3042\u308b\u30ce\u30fc\u30c9\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u30ce\u30fc\u30c9\u6570 \"\"\"\n            return self.size[self.find(x)]\n        else:\n            \"\"\" \u96c6\u5408\u306e\u6570 \"\"\"\n            res = set()\n            for i in range(self.n+1):\n                res.add(self.find(i))\n            # \u30b0\u30eb\u30fc\u30d70\u306e\u5206\u3092\u5f15\u3044\u3066\u8fd4\u5374\n            return len(res) - 1\n    \n    def is_tree(self, x):\n        \"\"\" \u6728\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a \"\"\"\n        return self.tree[self.find(x)]\n\nMAX = 10 ** 5\nN = INT()\nuf = UnionFind(MAX * 2)\nedges = []\nfor i in range(N):\n    x, y = MAP()\n    edges.append((x, y))\n    uf.union(x, y+MAX)\n\n# \u9023\u7d50\u6210\u5206S\u304c\u6301\u3064\u8fba\u306e\u6570i,x\u306e\u9802\u70b9\u6570j,y\u306e\u9802\u70b9\u6570k\n# D[S] = (i, j, k)\nD = defaultdict(lambda: [0, 0, 0])\n# \u8fba\u306e\u96c6\u8a08\nfor x, y in edges:\n    D[uf.find(x)][0] += 1\n# \u9802\u70b9\u306e\u96c6\u8a08\nfor x in range(1, MAX+1):\n    y = x + MAX\n    D[uf.find(x)][1] += 1\n    D[uf.find(y)][2] += 1\n\nans = 0\n# \u5404\u9023\u7d50\u6210\u5206\u306b\u3064\u3044\u3066\u306e\u3001\u8ffd\u52a0\u3067\u304d\u308b\u8fba\u306e\u6570\u3092\u5408\u8a08\u3059\u308b\nfor edgecnt, xcnt, ycnt in list(D.values()):\n    # \u8ffd\u52a0\u3067\u304d\u308b\u8fba\u306e\u6570 = \u5b8c\u51682\u90e8\u30b0\u30e9\u30d5\u306e\u8fba\u6570 - \u65e2\u306b\u3042\u308b\u8fba\u306e\u6570\n    ans += xcnt * ycnt - edgecnt\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.p = [e for e in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def same(self, u, v):\n        return self.find_set(u) == self.find_set(v)\n\n    def unite(self, u, v):\n        u = self.find_set(u)\n        v = self.find_set(v)\n\n        if u == v:\n            return\n\n        if self.rank[u] > self.rank[v]:\n            self.p[v] = u\n            self.size[u] += self.size[v]\n        else:\n            self.p[u] = v\n            self.size[v] += self.size[u]\n            if self.rank[u] == self.rank[v]:\n                self.rank[v] += 1\n\n    def find_set(self, u):\n        if u != self.p[u]:\n            self.p[u] = self.find_set(self.p[u])\n\n        return self.p[u]\n\n    def update_p(self):\n        for u in range(self.n):\n            self.find_set(u)\n\n    def get_size(self, u):\n        return self.size[self.find_set(u)]\n\n\nn = int(input())\nxy = [list(map(int, input().split())) for _ in range(n)]\nMAX = 10 ** 5\n\nuf = UnionFind(MAX * 2)\n\nfor x, y in xy:\n    x -= 1\n    y -= 1\n    uf.unite(x, y + MAX)\n\nx_size = [0] * MAX * 2\ny_size = [0] * MAX * 2\nfor i in range(MAX * 2):\n    root = uf.find_set(i)\n    if i < MAX:\n        x_size[root] += 1\n    else:\n        y_size[root] += 1\n\nans = -n\nfor i in range(MAX * 2):\n    ans += x_size[i] * y_size[i]\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**5)\n\ndef find_parent(i):\n    aaa=0\n    while True:\n        if parent[i]<0:\n            aaa=i\n            break\n        else:\n            i=parent[i]\n    return aaa\n\ndef connect(A,B):\n    A=find_parent(A)\n    B=find_parent(B)\n    if A!=B:\n        p_A,p_B=parent[A],parent[B]\n        if p_A<p_B:\n            parent[A]+=p_B\n            parent[B]=A\n            child[A].append(B)\n        else:\n            parent[B]+=p_A\n            parent[A]=B\n            child[B].append(A)\n\nn=int(input())\nx_max=0\ny_max=0\nxy=[]\nfor _ in range(n):\n    x,y=map(int,input().split())\n    x_max=max(x_max,x)\n    y_max=max(y_max,y)\n    xy.append([x,y])\ndata=[[] for _ in range(x_max+1)]\nparent=[-1]*(x_max+1)\nchild=[[] for i in range(x_max+1)]\nlst=[0]*(y_max+1)\nfor x,y in xy:\n    data[x].append(y)\n    if lst[y]==0:\n        lst[y]=x\n    else:\n        connect(lst[y],x)\n\nlsls=[]\nfor i in range(1,x_max+1):\n    if parent[i]>=0:\n        continue\n    if not data[i]:\n        continue\n    que=[i]\n    h=[i]\n    while que:\n        u=que.pop()\n        for v in child[u]:\n            que.append(v)\n            h.append(v)\n    lsls.append(h)\n\nans=0\nfor u in lsls:\n    L=len(u)\n    flag=[0]*(y_max+1)\n    cnt=0\n    count=0\n    for v in u:\n        for w in data[v]:\n            count+=1\n            if flag[w]==0:\n                flag[w]=1\n                cnt+=1\n    ans+=L*cnt-count\n\nprint(ans)", "\"\"\"\nhttps://atcoder.jp/contests/abc131/submissions/6086380\n\"\"\"\nimport os\nimport sys\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nN = int(sys.stdin.readline())\nX, Y = list(zip(*[list(map(int, sys.stdin.readline().split())) for _ in range(N)]))\nPAD = 10 ** 5 + 1\nX = np.array(X)\nY = np.array(Y) + PAD\n\ngraph = csr_matrix(([True] * N, (X, Y)), shape=(PAD * 2, PAD * 2))\n# i \u304b\u3089 j \u307e\u3067\u306e\u30d1\u30b9\u304c\u3042\u308c\u3070 components[i] \u3068 components[j] \u304c\u540c\u3058\u5024\n_, components = connected_components(graph)\n\n# \u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u542b\u307e\u308c\u308b X \u306e\u6570\n# x_cnt[i]: \u9023\u7d50\u6210\u5206 i \u306b\u542b\u307e\u308c\u308b x \u306e\u6570\nx_cnt = np.bincount(components[:PAD], minlength=PAD * 2)\ny_cnt = np.bincount(components[PAD:], minlength=PAD * 2)\n# \u540c\u3058\u9023\u7d50\u6210\u5206\u3067\u3042\u308b x \u306e\u6570\u3068 y \u306e\u6570\u3092\u304b\u3051\u305f\u6570\u3060\u3051\u305d\u306e\u9593\u306b\u8fba\u3092\u5f35\u308c\u308b\n# \u3059\u3067\u306b\u3042\u308b\u5206\u306f\u5f15\u304f\nprint(((x_cnt * y_cnt).sum() - N))\n", "N = int(input())\nXY = [tuple(map(int,input().split())) for i in range(N)]\n\nclass UnionFind:\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self._size = [1] * N\n        self.count = 0\n    def root(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            self.parent[a] = self.root(self.parent[a])\n            return self.parent[a]\n    def is_same(self,a,b):\n        return self.root(a) == self.root(b)\n    def unite(self,a,b):\n        ra = self.root(a)\n        rb = self.root(b)\n        if ra == rb: return\n        if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n        self._size[ra] += self._size[rb]\n        self.parent[rb] = ra\n        self.count += 1\n    def size(self,a):\n        return self._size[self.root(a)]\n\nM = 10**5\nuf = UnionFind(2*M)\nfor x,y in XY:\n    a,b = x-1,y-1+M\n    if uf.is_same(a,b): continue\n    uf.unite(a,b)\nfor i in range(2*M):\n    uf.root(i)\n\nrt = []\nfor i in range(2*M):\n    rt.append(uf.root(i))\nfrom collections import Counter\nxr = Counter(rt[:M])\nyr = Counter(rt[M:])\n\nans = 0\nfor k,v in xr.items():\n    ans += yr[k] * v\nans -= N\nprint(ans)", "import sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn = int(readline())\nxy = list(map(int, read().split()))\nXY = list(zip(xy, xy))\n\nmax_num = 10 ** 5\ndelta = 10 ** 5 + 10\n\ngraph = [[] for _ in range(max_num + delta + 1)]\n\nfor x, y in XY:\n    graph[x].append(delta + y)\n    graph[delta + y].append(x)\n\nx_used = [False] * (max_num + 1)\ny_used = [False] * (max_num + 1)\n\n\ndef dfs(idx):\n    x_res = 0\n    y_res = 0\n    edgenum = 0\n    stack = []\n    stack.append(idx)\n    if idx >= delta:\n        y_used[idx % delta] = True\n    else:\n        x_used[idx] = True\n    while stack:\n        v = stack.pop()\n        if v >= delta:\n            # if y_used[v % delta]:\n            #     continue\n            # y_used[v % delta] = True\n            y_res += 1\n        else:\n            # if x_used[v]:\n            #     continue\n            # x_used[v] = True\n            x_res += 1\n        for u in graph[v]:\n            if u >= delta:\n                if y_used[u % delta]:\n                    continue\n                y_used[u % delta] = True\n            else:\n                if x_used[u]:\n                    continue\n                x_used[u] = True\n            edgenum += 1\n            stack.append(u)\n    res = x_res * y_res\n    return res\n\n\nans = 0\nfor i in range(max_num + 1):\n    if x_used[i]:\n        continue\n    temp = dfs(i)\n    ans += temp\n\nfor i in range(max_num + 1):\n    if y_used[i]:\n        continue\n    i += delta\n    temp = dfs(i)\n    ans += temp\n\nprint((ans - n))\n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\n\nclass PotentialUnionFind:\n    def __init__(self,N): # \u9802\u70b9\u6570 N\n        self.table = [i for i in range(N)]    # \u89aa table[x] == x \u3067\u6839\n        self.rank  = [1 for i in range(N)]    # \u6728\u306e\u9577\u3055\n        self.size  = [1 for i in range(N)]    # \u96c6\u5408\u306e\u30b5\u30a4\u30ba\n        self.diffweight = [0 for i in range(N)]\n\n    def Find(self,x):    #x\u306e\u6839\u3092\u8fd4\u3059\n        if self.table[x] == x:\n            return x\n        else:\n            root = self.Find(self.table[x]) #\u89aa\u306e\u66f4\u65b0\n            self.size[x] = self.size[self.table[x]]\n            self.diffweight[x] += self.diffweight[self.table[x]]\n            self.table[x] = root\n            return root\n\n    def Unite(self,x,y,w): #x\u3068y\u3092Diff(x,y)=W \u3067\u7e4b\u3052\u308b\n        w = w - self.Weight(y) + self.Weight(x)\n        x,y = self.Find(x), self.Find(y)\n        sx,sy = self.Size(x), self.Size(y)\n        if x == y: return\n        if self.rank[x] > self.rank[y]:\n            self.table[y] = x\n            self.size[x] = sx + sy\n            self.diffweight[y] = w\n        else:\n            self.table[x] = y\n            self.size[y] = sx + sy\n            self.diffweight[x] = -w\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def Check(self,x,y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self,x):\n        return self.size[self.Find(x)]\n\n    def Weight(self,x): # \u91cd\u3055(\u6839\u304b\u3089\u306e\u8ddd\u96e2)\n        self.Find(x)\n        return self.diffweight[x]\n\n    def Diff(self,x,y): # \u7e4b\u304c\u3063\u3066\u308b\u4e8c\u70b9\u9593\u8ddd\u96e2\n        return self.Weight(y) - self.Weight(x)\n\n\nN = int(input())\nPUF = PotentialUnionFind(10**5+1)\n\nxys = [inpl() for _ in range(N)]\nxys.sort()\ntatedict = defaultdict(list)\nxx = set()\nfor x,y in xys:\n    tatedict[x].append(y)\n    xx.add(x)\n\nfor x in xx:\n    s = tatedict[x][0]\n    for t in tatedict[x]:\n        if not PUF.Check(s,t):\n            PUF.Unite(s,t,1)\n\nans = 0\nfor x in xx:\n    s = tatedict[x][0]\n    ans += PUF.Size(s) - len(tatedict[x])\n\nprint(ans)\n", "from collections import Counter\nimport sys\ninput = sys.stdin.readline\n\n# Union-Find\u30c7\u30fc\u30bf\u69cb\u9020\nclass UnionFind:\n    def __init__(self, numV):\n        self.pars = list(range(numV))\n        self.ranks = [0] * numV\n    def find(self, x):\n        if self.pars[x] == x: return x\n        else:\n            self.pars[x] = self.find(self.pars[x])\n            return self.pars[x]\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y: return\n        if self.ranks[x] < self.ranks[y]:\n            self.pars[x] = y\n        else:\n            self.pars[y] = x\n            if self.ranks[x] == self.ranks[y]:\n                self.ranks[x] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN = int(input())\nxys = [tuple(map(int, input().split())) for _ in range(N)]\n\nM = 10**5\nUF = UnionFind(2*M)\nfor x, y in xys:\n    x, y = x-1, y-1\n    UF.union(x, y+M)\n\nfor x in range(2*M):\n    UF.find(x)\n\ncntX = Counter(UF.pars[:M])\ncntY = Counter(UF.pars[M:])\n\nans = 0\nfor v in list(cntX.keys()):\n    ans += cntX[v] * cntY[v]\n\nprint((ans - N))\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [None]*n\n\n    def root(self, x):\n        if self.parent[x] == None:\n            return x\n        else:\n            return self.root(self.parent[x])\n\n    def union(self, x, y):\n        x0 = self.root(x)\n        y0 = self.root(y)\n        if x0 == y0:\n            return\n        if x0 > y0:\n            x0, y0 = y0, x0\n        self.parent[y0] = x0\n\n\nn = int(input())\nm = 10**5\nuf = UnionFind(2*m)\nX, Y = [], []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    X.append(x-1)\n    Y.append(y-1+m)\n    uf.union(x-1, y-1+m)\nR = {}\nfor x, y in zip(X, Y):\n    r = uf.root(x)\n    try:\n        R[r][0].add(x)\n        R[r][1].add(y)\n    except:\n        R[r] = [{x}, {y}]\nans = 0\nfor r in list(R.keys()):\n    ans += len(R[r][0])*len(R[r][1])\nprint((ans-n))\n", "import sys\ninput = sys.stdin.readline\nM = 10**5\n\nn = int(input())\nG = [[] for _ in range(2*M+1)]\nfor _ in range(n):\n  x, y = map(int, input().split())\n  G[x].append(y+M)\n  G[y+M].append(x)\nseen = [False]*(2*M+1)\ndef dfs(v):\n  stack = [v]\n  seen[v] = True\n  cnt_x, cnt_y = 0, 0\n  while stack:\n    v = stack.pop()\n    if v <= M:\n      cnt_x += 1\n    else:\n      cnt_y += 1\n    for nv in G[v]:\n      if seen[nv]:\n        continue\n      seen[nv] = True\n      stack.append(nv)\n  return cnt_x*cnt_y\nans = 0\nfor i in range(2*M+1):\n  if not seen[i]:\n    ans += dfs(i)\nans -= n\nprint(ans)", "import sys\nfrom collections import deque\nfrom operator import itemgetter\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    p = [list(map(int, input().split()))+[i] for i in range(n)]\n    tree = [[] for _ in range(n)]\n    \n    p.sort()\n    for i in range(n-1):\n        if p[i][0] == p[i+1][0]:\n            tree[p[i][2]].append(p[i+1][2])\n            tree[p[i+1][2]].append(p[i][2])\n\n    p.sort(key=itemgetter(1))\n    for i in range(n-1):\n        if p[i][1] == p[i+1][1]:\n            tree[p[i][2]].append(p[i+1][2])\n            tree[p[i+1][2]].append(p[i][2])\n\n    p.sort(key=itemgetter(2))\n\n    \n    already = [False]*n\n    ans = -n\n    for i in range(n):\n        if already[i]:\n            continue\n        already[i] = True\n        not_yet = deque([i])\n        key_x = {p[i][0]}\n        key_y = {p[i][1]}\n        while not_yet:\n            key = not_yet.popleft()\n            for v in tree[key]:\n                if already[v]:\n                    continue\n                already[v] = True\n                key_x.add(p[v][0])\n                key_y.add(p[v][1])\n                not_yet.append(v)\n        ans += len(key_x)*len(key_y)\n    \n    print(ans)\n        \n    \n    \ndef __starting_point():\n    main()\n\n\n__starting_point()", "n = int(input())\nMAX = 10**5\nadj = [[[] for u in range(MAX+1)] for t in range(2)]\nvis = [[False for u in range(MAX+1)] for t in range(2)]\nfor i in range(n):\n\tx, y = map(int,input().split())\n\tadj[0][x].append(y)\n\tadj[1][y].append(x)\n\nimport sys\nsys.setrecursionlimit(4*10**5+1)\n\ndef dfs(t,u): # Left, Right, Edges\n\tvis[t][u] = True\n\n\tct = [0,0,0]\n\tct[t] += 1\n\tfor v in adj[t][u]:\n\t\tct[2] += 1\n\t\tif not vis[t^1][v]:\n\t\t\tctv = dfs(t^1,v)\n\n\t\t\tct[0] += ctv[0]\n\t\t\tct[1] += ctv[1]\n\t\t\tct[2] += ctv[2]\n\n\treturn ct\n\nans = 0\nfor u in range(1,MAX+1):\n\tif not vis[0][u]:\n\t\tL, R, M = dfs(0,u)\n\t\tans += L*R-M//2\n\nprint(ans)", "class UnionFind:\n    def __init__(self, n):\n        self.ps = [-1] * (n + 1)\n\n    def find(self, x):\n        if self.ps[x] < 0:\n            return x\n        else:\n            self.ps[x] = self.find(self.ps[x])\n            return self.ps[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.ps[x] > self.ps[y]:\n            x, y = y, x\n        self.ps[x] += self.ps[y]\n        self.ps[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        x = self.find(x)\n        return -self.ps[x]\n\nn = int(input())\nv = 10**5 + 5\nuf = UnionFind(v*2 + 10)\nfor _ in range(n):\n  x, y = map(int, input().split())\n  uf.unite(x, y+v)\nd = dict()\nfor i in range(v*2):\n  if uf.size(i) > 1:\n    p = uf.find(i)\n    if p not in d:\n      d[p] = [0, 0]\n    d[p][i > v] += 1\nprint(sum(x*y for x,y in d.values()) - n)", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return tuple(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, XY):\n    g = [[] for _ in range((10**5)*2)]\n    offset = 10**5\n    cs = set()\n    for x, y in XY:\n        x -= 1\n        y = y - 1 + offset\n        g[x].append(y)\n        g[y].append(x)\n        cs.add(x)\n        cs.add(y)\n    ans = 0\n    while cs:\n        error_print(len(cs))\n        q = set([cs.pop()])\n        done = set()\n        done_c = set()\n        while q:\n            v = q.pop()\n            for u in g[v]:\n                if v >= offset:\n                    e = (u, v)\n                else:\n                    e = (v, u)\n                if e not in done:\n                    q.add(u)\n                    done.add(e)\n                    done_c.add(u)\n                    done_c.add(v)\n        xn = set()\n        yn = set()\n        for v, u in done:\n            for z in (v, u):\n                if z >= offset:\n                    yn.add(z)\n                else:\n                    xn.add(z)\n        ans += (len(xn) * len(yn)) - len(done)\n        cs -= done_c\n\n    return ans\n\ndef main():\n    N = read_int()\n    XY = [read_int_n() for _ in range(N)]\n    print(slv(N, XY))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\n\nX = [[] for _ in range(10**5)]\nY = [[] for _ in range(10**5)]\n\nP = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(N)]\n\nfor i in range(N):\n    x, y = P[i]\n    X[x].append(y)\n    Y[y].append(x)\n\nx_used = [0 for _ in range(10**5)]\ny_used = [0 for _ in range(10**5)]\nres = 0\n\nfor i in range(10**5):\n    if x_used[i]:\n        continue\n    stack = [(0, i)]\n    x_cnt = 1\n    x_used[i] = 1\n    y_cnt = 0\n    edge = 0\n    while stack:\n        axis, node = stack.pop()\n        if axis == 0:\n            for adj in X[node]:\n                edge += 1\n                if y_used[adj]:\n                    continue\n                y_cnt += 1\n                y_used[adj] = 1\n                stack.append((1, adj))\n        else:\n            for adj in Y[node]:\n                if x_used[adj]:\n                    continue\n                x_cnt += 1\n                x_used[adj] = 1\n                stack.append((0, adj))\n    res += x_cnt * y_cnt - edge\n\nprint(res)", "import sys\ninput = sys.stdin.readline\nmax_n = 10**5\nans = 0\nn = int(input())\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.sizea = [1 if _ < n//2 else 0 for _ in range(n)]\n        self.sizeb = [0 if _ < n//2 else 1 for _ in range(n)]\n        self.sizec = [1 for _ in range(n)]\n        self.rank = [0] * (n)\n        \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def is_root(self, x):\n        if self.par[x] == x:\n            return True\n        else:\n            return False\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizea[x] += self.sizea[y]\n            self.sizeb[x] += self.sizeb[y]\n            self.sizec[x] += self.sizec[y]\n        else:\n            self.sizec[x] += 1          \n\n    def get_size(self, x):\n        x = self.find(x)\n        return self.sizea[x],self.sizeb[x],self.sizec[x]\n\nuf = UnionFind(2*max_n)\n\nfor _ in range(n):\n  x,y = map(int, input().split())\n  x -= 1\n  y += max_n - 1\n  uf.union(x, y)\n\nfor i in range(max_n):\n  if uf.is_root(i):\n    a,b,c = uf.get_size(i)\n    if a*b > 1:\n      ans += a*b -(c-1)\nprint(ans)", "import sys\nfrom collections import Counter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n\ndef main():\n    N, *XY = list(map(int, read().split()))\n\n    MAX = 100010\n    uf = UnionFind(MAX * 2)\n    for x, y in zip(*[iter(XY)] * 2):\n        uf.union(x, y + MAX)\n\n    x_comp = Counter()\n    y_comp = Counter()\n    for i in range(MAX):\n        x_comp[uf.find(i)] += 1\n    for i in range(MAX, 2 * MAX):\n        y_comp[uf.find(i)] += 1\n\n    ans = 0\n    for k in list(x_comp.keys()):\n        ans += x_comp[k] * y_comp[k]\n\n    ans -= N\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# https://drken1215.hatenablog.com/entry/2019/06/23/004700\n# https://atcoder.jp/contests/abc131/submissions/7975278\n# https://tjkendev.github.io/procon-library/python/union_find/union_find.html\n\ndef main():\n    from collections import Counter\n    import sys\n    input = sys.stdin.readline\n\n    MX = 10 ** 5 + 10\n\n    *p, = [r for r in range(MX * 2)]\n\n    def root(x):\n        if x == p[x]:\n            return x\n        p[x] = y = root(p[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px == py:\n            return 0\n        if px < py:\n            p[py] = px\n        else:\n            p[px] = py\n        return 1\n\n    n = int(input())\n    for _ in range(n):\n        x, y = (int(x) - 1 for x in input().split())  # [1,)->[0,)\n        unite(x, y + MX)\n\n    ctr_x = Counter(root(r) for r in range(MX))\n    ctr_y = Counter(root(r) for r in range(MX, MX * 2))\n\n    rs = set(ctr_x.keys())\n    rs.update(list(ctr_y.keys()))\n\n    ans = sum(ctr_x[r] * ctr_y[r] for r in rs) - n\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\n\nMAXVAL = 10**5\nN = int(input())\nedge = [[] for _ in range(MAXVAL*2)]\nvisited = [0] * (MAXVAL*2)\nans = 0\nxnum = 0; ynum = 0; nodes = 0\n\ndef dfs(n):\n    nonlocal xnum, ynum, nodes\n    if visited[n] == 1:\n        return True\n    if n < MAXVAL:\n        xnum += 1\n    else:\n        ynum += 1\n    visited[n] = 1\n    for item in edge[n]:\n        nodes += 1\n        dfs(item)\n    return True\n\nfor i in range(N):\n    x, y = [int(item) for item in input().split()]\n    x -= 1; y -= 1\n    edge[x].append(y+MAXVAL)\n    edge[y+MAXVAL].append(x)\n\nfor i in range(MAXVAL*2):\n    if visited[i] == 1:\n        continue\n    xnum = 0; ynum = 0; nodes = 0\n    dfs(i)\n    if nodes >= 3:\n        ans += xnum * ynum - nodes // 2\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nedges = [[] for i in range(2*10**5)]\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    xi -= 1\n    yi = yi - 1 + 10**5\n    edges[xi].append(yi)\n    edges[yi].append(xi)\n\nalready = set([])\ndef dfs(x, y, node):\n    if node in already:\n        return x, y\n    if node < 10**5:\n        x += 1\n    else:\n        y += 1\n    already.add(node)\n    for next_node in edges[node]:\n        x, y = dfs(x, y, next_node)\n    return x, y\n\nnum = 0\nfor i in range(10**5):\n    x, y = dfs(0, 0, i)\n    num += x * y\nprint(num-n)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nn = int(input())\nxy = [[[] for _ in range(10**5+1)] for __ in range(2)]\n\nfor _ in range(n):\n    x,y = map(int,input().split())\n    xy[0][x].append(y)\n    xy[1][y].append(x)\n\nans = 0\nused = [[False for _ in range(10**5+1)] for __ in range(2)]\n\ndef dfs(i,flag):\n    for v in xy[flag][i]:\n        if not used[1-flag][v]:\n            used[1-flag][v] = True\n            dfs(v,1-flag)\n            count[1-flag] += 1\n\nfor i in range(10**5+1):\n    if xy[0][i] and not used[0][i]:\n        used[0][i] = True\n        count = [1,0]\n        dfs(i,0)\n        ans += count[0]*count[1]\n\nans -= n\nprint(ans)", "def main():\n    N = int(input())\n    X, Y = {}, {}\n    for _ in range(N):\n        x, y = list(map(int, input().split()))\n        if x not in X:\n            X[x] = set()\n        X[x].add(y)\n        if y not in Y:\n            Y[y] = set()\n        Y[y].add(x)\n    r = 0\n    while X:\n        x, ys = X.popitem()\n        tx = set([x])\n        ty = set(ys)\n        mx, my = set(), set(ys)\n        while mx or my:\n            while my:\n                y = my.pop()\n                mx |= Y.pop(y, set())\n            tx |= mx\n            while mx:\n                x = mx.pop()\n                my |= X.pop(x, set())\n            ty |= my\n        r += len(tx) * len(ty)\n    return r - N\n\nprint((main()))\n", "import sys\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.root[x] == x:\n            return x\n        else:\n            y = self.find(self.root[x])\n            self.root[x] = y\n            return self.root[x]\n\n    def unite(self, x, y):\n        if self.is_same(x, y):\n            return\n        rx = self.find(x)\n        ry = self.find(y)\n        if self.rank[rx] < self.rank[ry]:\n            self.root[rx] = ry\n        else:\n            self.root[ry] = rx\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n\ndef main():\n    input = sys.stdin.readline\n    V = 10**5  # max size of x\n    N = int(input())\n    uft = UnionFind(2*V)\n    for _ in range(N):\n        x, y = list(map(int, input().split()))\n        x -= 1\n        y += V - 1\n        uft.unite(x, y)\n\n    cnt_x = defaultdict(lambda: 0)\n    cnt_y = defaultdict(lambda: 0)\n    for i in range(2*V):\n        root = uft.find(i)\n        if i < V:  # node of x coordinate.\n            cnt_x[root] += 1\n        else:\n            cnt_y[root] += 1\n\n    ans = 0\n    for root in list(cnt_x.keys()):\n        ans += cnt_x[root] * cnt_y[root]\n\n    return ans - N\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "from queue import PriorityQueue\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nIA = lambda: [int(x) for x in input().split()]\nIM = lambda N: [IA() for _ in range(N)]\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nN=100005\nfa=[int(0) for i in range(2*(N+1))]\nxNum=[int(0) for i in range(2*(N+1))]\nyNum=[int(0) for i in range(2*(N+1))]\n\ndef find(x):\n    if(x==fa[x]):return x\n    else:\n        fa[x]=find(fa[x])\n        return fa[x]\n\nn=input()\nn=int(n)\n\nfor i in range(2*N+1):\n    fa[i]=i\n\nfor i in range(n):\n    x,y=IA()\n    y+=N\n    fx=int(find(x))\n    fy=int(find(y))\n \n    if(fx!=fy):\n        fa[fy]=fx\nfor i in range(N):\n    xNum[find(i)]+=1\nfor i in range(N):\n    yNum[find(i+N)]+=1\nans=0\nfor i in range(N):\n    ans+=xNum[i]*yNum[i]\nprint((ans-n))\n\n\n", "import os\nimport sys\nfrom collections import defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nN = int(sys.stdin.readline())\nX, Y = list(zip(*[list(map(int, sys.stdin.readline().split())) for _ in range(N)]))\n\nyx = defaultdict(lambda: set())\nxy = defaultdict(lambda: set())\nfor x, y in zip(X, Y):\n    xy[x].add(y)\n    yx[y].add(x)\n\n\ndef connected(x=None, y=None, xret=None, yret=None):\n    xret = xret if xret else set()\n    yret = yret if yret else set()\n\n    if x is not None:\n        for y in xy[x]:\n            if y in yret:\n                continue\n            yret.add(y)\n            xret, yret = connected(y=y, xret=xret, yret=yret)\n    if y is not None:\n        for x in yx[y]:\n            if x in xret:\n                continue\n            xret.add(x)\n            xret, yret = connected(x=x, xret=xret, yret=yret)\n\n    return xret, yret\n\n\nx_counted = set()\ny_counted = set()\n\n# X \u3068 Y \u306e\u4e8c\u90e8\u30b0\u30e9\u30d5\u3067\u3001\u9023\u7d50\u3067\u3042\u308b\u3059\u3079\u3066\u306e\u7d44\u306b\u8fba\u3092\u5f35\u308b\nans = 0\nfor x in list(xy.keys()):\n    if x in x_counted:\n        continue\n    xs, ys = connected(x=x)\n    # \u8fba\u6570\n    ans += len(xs) * len(ys)\n    x_counted |= xs\n    y_counted |= ys\n# \u3059\u3067\u306b\u3042\u308b\u8fba\u304c\u91cd\u8907\u3057\u3066\u308b\nans -= N\nprint(ans)\n", "n=int(input())\nxy=[list(map(int,input().split())) for _ in range(n)]\nmaxx=max([x for x,y in xy])\nmaxy=max([y for x,y in xy])\ng=[[] for _ in range(maxx+maxy+1)]\nfor x,y in xy:\n  y+=maxx\n  g[x].append(y)\n  g[y].append(x)\n# 1\u3088\u308a\u5927\u304d\u3044\u5947\u6570\u56de\u3067\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306b\u30d1\u30b9\u3092\u8ffd\u52a0\u3057\u3066\u3044\u304f\u3002\u6700\u77ed\u8ddd\u96e2\u304c3\u4ee5\u4e0a\u306e\u5947\u6570\u306e\u9802\u70b9\u306e\u30da\u30a2\u306e\u6570\u3002\u5947\u6570\u306e\u30d1\u30b9\u3092\u6570\u3048\u3001\u6700\u5f8c\u306b\u30d1\u30b9\u306e\u6570\u3092\u5f15\u304f\nmi=set(range(maxx+maxy+1))\nans=0\nwhile mi:\n  v=mi.pop()\n  todo=[v]\n  nx=0\n  ny=0\n  while todo:\n    v=todo.pop()\n    if v<=maxx:\n      nx+=1\n    else:\n      ny+=1\n    for nv in g[v]:\n      if nv in mi:\n        mi.discard(nv)\n        todo.append(nv)\n  ans+=nx*ny\nprint((ans-n))\n", "import sys\nfrom collections import deque\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nU = 10 ** 5\nedge = [[] for _ in range(2 * U + 1)]\nfor _ in range(N):\n    x, y = map(int, input().split())\n    y += U\n    edge[x].append(y)\n    edge[y].append(x)\n\nans = 0\nseen = [False] * (2 * U + 1)\nfor i in range(1, 2 * U + 1):\n    if not edge[i] or seen[i]:\n        continue\n    seen[i] = True\n    node = deque([i])\n    x = 0\n    y = 0\n    while node:\n        s = node.popleft()\n        if s <= U:\n            x += 1\n        else:\n            y += 1\n        for t in edge[s]:\n            if seen[t]:\n                continue\n            seen[t] = True\n            node.append(t)\n    ans += x * y\n\nans = ans - N\nprint(ans)", "def main():\n    n=int(input())\n    xy=[list(map(int,input().split())) for _ in [0]*n]\n    ixy=[[i,x,y] for i,(x,y) in enumerate(xy)]\n    class unionfind():\n        #size:\u8981\u7d20\u6570,tree\uff1aunionfind\u6728\n        def __init__(self,size):#self,\u8981\u7d20\u6570\n            self.size=size\n            self.tree_root=list(range(self.size))\n            self.tree_depth=[1]*self.size\n        \n        #root\u3092\u63a2\u3059\n        def root(self,index):\n            temp_list=[]\n            temp=self.tree_root[index]\n            while index!=temp:\n                temp_list.append(index)\n                index=temp\n                temp=self.tree_root[index]\n            for i in temp_list:\n                self.tree_root[i]=index\n            return index\n        \n        #\u7d50\u5408\n        def unite(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            if r1!=r2:\n                d1,d2=self.tree_depth[r1],self.tree_depth[r2]\n                if d1<=d2:\n                    self.tree_root[r1]=r2\n                    self.tree_depth[r2]=max(d1+1,d2)\n                else:\n                    self.tree_root[r2]=r1\n                    self.tree_depth[r1]=max(d2+1,d1)\n    \n        #\u540c\u3058\u304b\u5224\u5b9a\n        def same(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            return r1==r2\n    \n        #\u9023\u7d50\u6210\u5206\u306e\u500b\u6570\n        def component(self):\n            return len({self.root(i) for i in range(self.size)})\n\n    u=unionfind(n)\n    ixy.sort(key=lambda x:x[1])\n    for i in range(n-1):\n        if ixy[i][1]==ixy[i+1][1]:\n            u.unite(ixy[i][0],ixy[i+1][0])\n    ixy.sort(key=lambda x:x[2])\n    for i in range(n-1):\n        if ixy[i][2]==ixy[i+1][2]:\n            u.unite(ixy[i][0],ixy[i+1][0])\n    tate=[set() for _ in [0]*n]\n    yoko=[set() for _ in [0]*n]\n    cnt=[0]*n\n    for i in range(n):\n        r=u.root(i)\n        tate[r].add(xy[i][0])\n        yoko[r].add(xy[i][1])\n        cnt[r]+=1\n    print(sum([len(tate[i])*len(yoko[i])-cnt[i] for i in range(n)]))\nmain()", "from collections import deque\nN = int(input())\nV = set()\nE = {}\n\nfor _ in range(N):\n  x,y = map(int, input().split())\n  y += 100010\n  V.add(x)\n  V.add(y)\n  if x not in E:\n    E[x] = [y]\n  else:\n    E[x].append(y)\n  if y not in E:\n    E[y] = [x]\n  else:\n    E[y].append(x)\n\n#print(V)\n#print(E)\n## DFS\nvisited = [ False ] * 200020\nwillSearch = [ False ] * 200020\nQ = deque()\nans = 0\nfor v in V:\n  if visited[v]:\n    continue\n\n  Q.append(v)\n  xcount, ycount = 0,0\n  edge_count = 0\n  while len(Q) > 0:\n    now = Q.pop()\n    visited[now] = True\n\n    if now > 100005:\n      ycount += 1\n    else:\n      xcount += 1\n      \n    for nxt in E[now]:\n      edge_count += 1\n      if visited[nxt] or willSearch[nxt]:\n        continue\n      #print(v,now,nxt)\n\n      willSearch[nxt] = True\n\n      Q.append(nxt)\n  #print(v,xcount, ycount, edge_count)\n  ans += xcount * ycount\n  ans -= edge_count // 2\n  \nprint(ans)", "def main():\n    from collections import defaultdict\n    import sys\n    # functions used\n    r = lambda: sys.stdin.readline().strip()\n    R = lambda: list(map(int, r().split()))\n\n    N = int(r())\n    Dic = defaultdict(list)\n    V = 10**5 + 5\n    Arrived = [False] * (2 * V)\n    for _ in range(N):\n        x, y = R()\n        y += V\n        Dic[x].append(y)\n        Dic[y].append(x)\n\n    ans = 0\n    task = []\n    for k, v in Dic.items():\n        if Arrived[k]:\n            continue\n        Arrived[k] = True\n        if k < V:\n            cntx = 1\n            cnty = 0\n        else:\n            cntx = 0\n            cnty = 1\n        cntdot = 0\n        task.extend(v)\n        cntdot += len(v)\n        while task:\n            s = task.pop()\n            if Arrived[s]:\n                continue\n            if s < V:\n                cntx += 1\n            else:\n                cnty += 1\n            Arrived[s] = True\n            task.extend(Dic[s])\n            cntdot += len(Dic[s])\n        ans += cntx * cnty - cntdot // 2\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind:\n    def __init__(self, n: int) -> None:\n        #\u30de\u30a4\u30ca\u30b9\u306a\u3089\u30eb\u30fc\u30c8\u3067\u305d\u306e\u6df1\u3055\u3092\u8868\u3059\u3002\u30d7\u30e9\u30b9\u306a\u3089\u30eb\u30fc\u30c8\u306e\u30ce\u30fc\u30c9\u3092\u6307\u3059\u3002\n        self.nodes = [-1]*n\n \n    def find_root(self, x: int) -> int:\n        if self.nodes[x] < 0:\n            return x\n        else:\n            self.nodes[x] = self.find_root(self.nodes[x])\n            return self.nodes[x]\n \n    def unite(self, x: int, y: int) -> None:\n        x, y = self.find_root(x), self.find_root(y)\n        #\u6d45\u3044\u65b9\u306b\u3064\u306a\u3050\n        if (x != y):\n            if (x < y):\n                self.nodes[y] += self.nodes[x]\n                self.nodes[x] = y\n            else:\n                self.nodes[x] += self.nodes[y]\n                self.nodes[y] = x\n                \n    def get_num(self, x: int) -> int:\n        return -(self.nodes[x])\n\nMAX = 10**5+1\n\nN = int(input())\nuf = UnionFind(2*MAX)\n\nfor i in range(N):\n  x,y = list(map(int, input().split()))\n  uf.unite(x,y+MAX)\n\n#\u6570\u3048\u4e0a\u3052\nnum_x = [0]*2*MAX\nnum_y = [0]*2*MAX\nfor i in range(MAX):\n  num_x[uf.find_root(i)] += 1\n  num_y[uf.find_root(i+MAX)] += 1\n  #print(num_x[uf.find_root(i)], num_y[uf.find_root(i+MAX)])\n\nans = 0\nfor i in range(2*MAX):\n  ans += num_x[i] * num_y[i]\n\nprint((ans - N))\n", "class UnionFind:\n    def __init__(self, n, t, s):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n + 1)\n        self.sizex = [1] * t + [0] * s\n        self.sizey = [0] * t + [1] * s\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def sizeof(self, x):\n        return self.sizex[self.find(x)] * self.sizey[self.find(x)]\n\n    # \u4f75\u5408\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.sizex[y] += self.sizex[x]\n            self.sizey[y] += self.sizey[x]\n        else:\n            self.par[y] = x\n            self.sizex[x] += self.sizex[y]\n            self.sizey[x] += self.sizey[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef coordinate_compression(arr):\n    return {v: k for k, v in enumerate(sorted(set(arr)))}\n\n\nn = int(input())\nx = [0] * n\ny = [0] * n\nfor i in range(n):\n    x[i], y[i] = list(map(int, input().split()))\ndx = coordinate_compression(x)\ndy = coordinate_compression(y)\nuf = UnionFind(len(dx) + len(dy), len(dx), len(dy))\nfor i in range(n):\n    uf.unite(dx[x[i]], dy[y[i]] + len(dx))\ns = set()\nans = 0\nfor i in range(len(dx)):\n    p = uf.find(i)\n    if p in s:\n        continue\n    ans += uf.sizeof(i)\n    s.add(p)\nprint((ans - n))\n", "# import sys\n# sys.setrecursionlimit(20000)\n\n\nN = int(input())\nCOR = [tuple((list(map(int, input().split())))) for _ in range(N)]\n\n\nclass Group:\n    \n    def __init__(self):\n        self.n = 0\n        self.x = 0\n        self.y = 0\n        self.xy = {}\n        \n    def new_cor_n(self):\n        return self.x * self.y - self.n\n        \n\ndef grouping(group, x, xcor, ycor):\n    x_list = []\n    group.x += 1\n    for y in xcor[x][0]:\n        if (x, y) not in group.xy:\n            group.n += 1\n            group.xy[(x, y)] = None\n        if ycor[y][1]:\n            continue\n        ycor[y][1] = True\n        group.y += 1\n        for x_ in ycor[y][0]:\n            if (x_, y) not in group.xy:\n                group.n += 1\n                group.xy[(x_, y)] = None\n            if xcor[x_][1]:\n                continue\n            xcor[x_][1] = True\n            x_list.append(x_)\n    return x_list\n\nif N <= 2:\n    print((0))\nelse:\n    xcor, ycor = {}, {}\n    for xi, yi in COR:\n        if xi in xcor:\n            xcor[xi][0].append(yi)\n        else:\n            xcor[xi] = [[yi], False]\n        if yi in ycor:\n            ycor[yi][0].append(xi)\n        else:\n            ycor[yi] = [[xi], False]\n    group_list = []\n    for i, v in list(xcor.items()):\n        if v[1]:\n            continue\n        group = Group()\n        group_list.append(group)\n        xcor[i][1] = True\n        x_list = [i]\n        while True:\n            new_x_list = []\n            for x in x_list:\n                new_x_list += grouping(group, x, xcor, ycor)\n            if new_x_list == []:\n                break\n            x_list = new_x_list\n    s = 0\n    for group in group_list:\n        s += group.new_cor_n()\n    print(s)\n", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\n\"\"\"\n\u70b9(x,y) \u3092\u3001\u8fbax-y\u3068\u898b\u3066\u4e8c\u90e8\u30b0\u30e9\u30d5\u3068\u307f\u306a\u3059\n\"\"\"\n\nN = int(readline())\nXY = np.array(read().split(),np.int32)\n\nU = 10**5 + 100\nX = XY[::2]; Y = XY[1::2]\ngraph = csr_matrix((np.ones(N),(X,Y+U)),(U+U,U+U))\nNcomp,comp = connected_components(graph)\n\ncomp_x=np.bincount(comp[:U],minlength=Ncomp) # \u9023\u7d50\u6210\u5206\u306b\u542b\u307e\u308c\u308bx\u5ea7\u6a19\u306e\u500b\u6570\ncomp_y=np.bincount(comp[U:],minlength=Ncomp) # \u9023\u7d50\u6210\u5206\u306b\u542b\u307e\u308c\u308bx\u5ea7\u6a19\u306e\u500b\u6570\ncomp_E=np.bincount(comp[X],minlength=Ncomp) # \u9023\u7d50\u6210\u5206\u306b\u542b\u307e\u308c\u308b\u8fba\u306e\u500b\u6570\n\nanswer = (comp_x * comp_y - comp_E).sum()\nprint(answer)", "import sys\ninput = sys.stdin.readline\ninpl = lambda: list(map(int,input().split()))\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, N=None):\n        if N is None or N < 1:\n            self.parent = defaultdict(lambda: -1)\n        else:\n            self.parent = [-1]*int(N)\n\n    def root(self, n):\n        if self.parent[n] < 0:\n            return n\n        else:\n            m = self.root(self.parent[n])\n            self.parent[n] = m\n            return m\n\n    def merge(self, m, n):\n        rm = self.root(m)\n        rn = self.root(n)\n        if rm != rn:\n            if -self.parent[rm] < -self.parent[rn]:\n                rm, rn = rn, rm\n            self.parent[rm] += self.parent[rn]\n            self.parent[rn] = rm\n\n    def size(self, n):\n        return -self.parent[self.root(n)]\n    \n    def connected(self, m, n):\n        return self.root(m) == self.root(n)\n    \n    def groups(self):\n        if isinstance(self.parent,list):\n            return list(map(lambda x: x<0, self.parent)).count(True)\n        else: # self.parent: defaultdict\n            return list(map(lambda x: x<0, self.parent.values())).count(True) \n\nN = int(input())\nuf = UnionFind()\nfor _ in range(N):\n    x, y = inpl()\n    uf.merge(2*x,2*y+1)\n\nnxny = defaultdict(lambda: [0, 0])\nfor k in uf.parent.keys():\n    nxny[uf.root(k)][k % 2] += 1\n\nans = sum([ nx * ny for nx, ny in nxny.values() ]) - N\nprint(ans)", "def examA():\n    N = DI()/dec(7)\n    ans = N\n    print(N)\n    return\n\ndef examB():\n    ans = 0\n    print(ans)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    ans = 0\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    # x\u3068y\u306b\u5206\u3051\u308b\u3068\u306a\u3093\u304b\u4e8c\u90e8\u30b0\u30e9\u30d5\u304c\u898b\u3048\u3066\u304f\u308b\n    # \u9055\u3046\u3093\u304b\u3002\u3002\n    def bfs(V,used,s=0):\n        W = {}\n        W[s] = 1\n        que = deque([s])\n        while(que):\n            now = que.pop()\n            used[now] = True\n            ne = W[now]*(-1)\n            for v in V[now]:\n                if v not in W:\n                    W[v] = ne\n                    que.append(v)\n                elif W[v]!=ne:\n                    return False\n        return W,used\n    y_shift = 10**5 + 1\n    N = I()\n    V = defaultdict(set)\n    for _ in range(N):\n        x, y = LI()\n        y += y_shift\n        V[x].add(y)\n        V[y].add(x)\n\n    ans = 0\n    used = defaultdict(lambda:False)\n    for i in V.keys():\n        if used[i]:\n            continue\n        W,used = bfs(V,used,i)\n        x = 0\n        for w in W.values():\n            if w==1:\n                x += 1\n        y = len(W)-x\n        #print(W,x,y)\n        ans += x*y\n    ans = max(0,ans-N)\n    print(ans)\n    return\n\nfrom decimal import getcontext,Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nnonlocal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = dec(\"0.000000000001\")\nalphabet = [chr(ord('a') + i) for i in range(26)]\nalphabet_convert = {chr(ord('a') + i): i for i in range(26)}\n\ngetcontext().prec = 28\n\nsys.setrecursionlimit(10**7)\n\ndef __starting_point():\n    examF()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\n__starting_point()", "V=10**5+5\nclass UnionFind:\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.rank=[0 for _ in range(n)]\n        # use for n=2*V\n        self.xSize=[1 if i<V else 0 for i in range(n)]\n        self.ySize=[0 if i<V else 1 for i in range(n)]\n\n    def find(self,x):\n        if self.parent[x]==x:\n            return x\n        else:\n            parentx=self.find(self.parent[x])\n            self.parent[x]=parentx\n            return parentx\n\n    def union(self,x,y):\n        rootx=self.find(x)\n        rooty=self.find(y)\n        if rootx==rooty:\n            return\n        if self.rank[rootx]>self.rank[rooty]:\n            self.parent[rooty]=rootx\n            self.xSize[rootx]+=self.xSize[rooty]\n            self.ySize[rootx]+=self.ySize[rooty]\n        else:\n            self.parent[rootx]=rooty\n            self.xSize[rooty]+=self.xSize[rootx]\n            self.ySize[rooty]+=self.ySize[rootx]\n            if self.rank[rootx]==self.rank[rooty]:\n                self.rank[rooty]+=1\n\nn=int(input())\nxy=[tuple(map(int,input().split())) for _ in range(n)]\nuf=UnionFind(V*2)\nfor xi,yi in xy:\n    uf.union(xi,yi+V)\n\n# for i in range(V*2):\n#     uf.find(i)\n\nans=0\nused=set()\nfor i in range(V*2):\n    rooti=uf.find(i)\n    if rooti not in used:\n        used.add(rooti)\n        ans+= uf.xSize[rooti]*uf.ySize[rooti]\nprint((ans-n))\n", "from collections import Counter\n\nclass UnionFind:\n    def __init__(self, size):\n        self.data = [-1] * size\n\n    def find(self, x):\n        if self.data[x] < 0:\n            return x\n        else:\n            self.data[x] = self.find(self.data[x])\n            return self.data[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.data[y] < self.data[x]:\n                x, y = y, x\n            self.data[x] += self.data[y]\n            self.data[y] = x\n        return (x != y)\n\n    def same(self, x, y):\n        return (self.find(x) == self.find(y))\n\n    def size(self, x):\n        return -self.data[self.find(x)]\n\n\nMAX = 10 ** 5 + 10\nuf = UnionFind(2 * MAX)\n\nN, *XY = list(map(int, open(0).read().split()))\n\nfor x, y in zip(*[iter(XY)] * 2):\n    uf.union(x, y + MAX)\n\nX = Counter(uf.find(i) for i in range(MAX))\nY = Counter(uf.find(i) for i in range(MAX, MAX * 2))\nres = sum(X[i] * Y[i] for i in range(MAX * 2))\n\nprint((res - N))\n", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    M = 10 ** 5\n\n    N = int(input())\n\n    g = tuple(set() for _ in range(M * 2))\n    for _ in range(N):\n        x, y = (int(x) - 1 for x in input().split())  # \u4e00\u5f8b\u306b\u79fb\u52d5\n        g[x].add(y + M)\n        g[y + M].add(x)\n\n    visited = [0] * (M * 2)\n    ans = 0\n    for s in range(M * 2):\n        if visited[s]: continue\n        visited[s] = 1\n        dq = deque()\n        dq.append(s)\n\n        sz = 0\n        x = 0\n        e = 0\n        while dq:\n            v = dq.popleft()\n            sz += 1\n            if v < M:\n                x += 1\n            for u in g[v]:\n                e += 1\n                if visited[u]: continue\n                visited[u] = 1\n                dq.append(u)\n        ans += (sz - x) * x - (e // 2)\n        # ans += (sz - x) * x - (sz - 1) # sz-1\u306f\u6728\u306b\u9650\u3089\u308c\u308b\u306e\u3067WA\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\ninpl = lambda: list(map(int,input().split()))\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, N=None):\n        if N is None or N < 1:\n            self.parent = defaultdict(lambda: -1)\n        else:\n            self.parent = [-1]*int(N)\n\n    def root(self, n):\n        if self.parent[n] < 0:\n            return n\n        else:\n            m = self.root(self.parent[n])\n            self.parent[n] = m\n            return m\n\n    def merge(self, m, n):\n        rm = self.root(m)\n        rn = self.root(n)\n        if rm != rn:\n            if -self.parent[rm] < -self.parent[rn]:\n                rm, rn = rn, rm\n            self.parent[rm] += self.parent[rn]\n            self.parent[rn] = rm\n\n    def size(self, n):\n        return -self.parent[self.root(n)]\n    \n    def connected(self, m, n):\n        return self.root(m) == self.root(n)\n    \n    def groups(self):\n        if isinstance(self.parent,list):\n            return list(map(lambda x: x<0, self.parent)).count(True)\n        else: # self.parent: defaultdict\n            return list(map(lambda x: x<0, self.parent.values())).count(True) \n\nclass CountUp:\n    def __init__(self, start=0):\n        self.index = start-1\n\n    def __call__(self):\n        self.index += 1\n        return self.index\n\nN = int(input())\nuf = UnionFind()\nfor _ in range(N):\n    x, y = inpl()\n    uf.merge(2*x+1,2*y)\n\nNg = uf.groups()\nnx = [0]*Ng\nny = [0]*Ng\ngi = defaultdict(CountUp())\nfor k in uf.parent.keys():\n    if k % 2:\n        nx[gi[uf.root(k)]] += 1\n    else:\n        ny[gi[uf.root(k)]] += 1\n\nans = sum([ nx[g]*ny[g] for g in range(Ng) ]) - N\nprint(ans)", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    M = 10 ** 5\n\n    N = int(input())\n\n    g = tuple(set() for _ in range(M * 2))\n    ps = set()\n    for _ in range(N):\n        x, y = (int(x) - 1 for x in input().split())  # \u4e00\u5f8b\u306b\u79fb\u52d5\n        g[x].add(y + M)\n        g[y + M].add(x)\n        ps.add(x)\n        ps.add(y + M)\n\n    visited = [0] * (M * 2)\n    ans = 0\n    for s in ps:\n        if visited[s]: continue\n        visited[s] = 1\n        dq = deque()\n        dq.append(s)\n\n        sz = 0\n        x = 0\n        while dq:\n            v = dq.popleft()\n            sz += 1\n            if v < M:\n                x += 1\n            for u in g[v]:\n                if visited[u]: continue\n                visited[u] = 1\n                dq.append(u)\n        ans += (sz - x) * x\n\n    ans -= N\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n# \u9023\u7d50\u6210\u5206\u3054\u3068\u306b\n# x,y\u306e\u4e8c\u90e8\u30b0\u30e9\u30d5\u3092\u5b8c\u5168\u4e8c\u90e8\u30b0\u30e9\u30d5\u306b\u3059\u308b\n# cnt(x)*cnt(y)-\u65e2\u5b58\u306e\u8fba\u6570\u306e\u7dcf\u548c\n\n# \u6700\u5f8c\u306bN\u5f15\u3051\u3070\u3088\u3044\n\n__starting_point()", "class UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nN = int(input())\nM = 10 ** 5\nuft = UnionFindTree(N + 2 * M)\n\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    x, y = x-1, y-1\n    uft.unite(i, x + N)\n    uft.unite(i, y + N + M)\nx_dict, y_dict = dict(), dict()\nfor x in range(N, M + N):\n    par_x = uft.find(x)\n    x_dict[par_x] = x_dict.get(par_x, 0) + 1\nfor y in range(N + M, N + 2 * M):\n    par_y = uft.find(y)\n    y_dict[par_y] = y_dict.get(par_y, 0) + 1\nans = -N\nfor r in list(x_dict.keys()):\n    ans += x_dict.get(r, 0) * y_dict.get(r, 0)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(1000000)\n\nN = int(input().strip())\n\nX = {}\nY = {}\nG = (X, Y)\n\nfor _ in range(N):\n  x, y = list(map(int, input().strip().split()))\n  if x not in X: X[x] = []\n  if y not in Y: Y[y] = []\n  X[x].append(y)\n  Y[y].append(x)\n\n\ndef dfs_visit(visited, u, i):\n  if u in visited[i]: return\n  visited[i].add(u)\n  for v in G[i][u]:\n    dfs_visit(visited, v, (i + 1) % 2)\n\n\ncount = 0\ni = 0\nwhile len(X) > 0:\n  visited = (set(), set())\n  x = X.__iter__().__next__()\n  dfs_visit(visited, x, 0)\n\n  for x in visited[0]:\n    count += len(visited[1]) - len(X.pop(x))\n\nprint(count)\n", "# reference -> https://atcoder.jp/contests/abc131/submissions/10358162\nimport sys\nsys.setrecursionlimit(100000)\n\n# \u518d\u5e30\u7684\u306b\u9023\u7d50\u90e8\u5206\u306e\u8fba\u306e\u6570\u3092\u6c42\u3081\u308b\n# \u540c\u3058\u8fba\u30922\u56de\u305a\u3064\u6570\u3048\u308b\u306e\u3067\u3001\u6700\u7d42\u7684\u306b\u306f2\u3067\u5272\u308b\ndef solve(x, x_set, y_set, x2y, y2x):\n  num_e = 0\n  if x in x2y:\n    x_set.add(x)\n    yl = x2y.pop(x)\n    num_e += len(yl)\n    for y in yl:\n      num_e += solve(y, y_set, x_set, y2x, x2y)\n  return num_e\n\n\nN = int(input())\nX2Y = {}\nY2X = {}\nfor i in range(N):\n  x, y = map(int, input().split())\n  if x in X2Y:\n    X2Y[x].append(y)\n  else:\n    X2Y[x] = [y]\n  if y in Y2X:\n    Y2X[y].append(x)\n  else:\n    Y2X[y] = [x]\n\n\nans = 0\nwhile X2Y:\n    x = next(iter(X2Y)) # \u307e\u3060\u30b9\u30bf\u30fc\u30c8\u306b\u9078\u3093\u3067\u3044\u306a\u3044x\u3092\u53d6\u308a\u51fa\u3059\n    x_set = set() # \u4e0a\u306ex\u3068\u9023\u7d50\u3067\u3042\u308bx\u306e\u96c6\u5408\n    y_set = set() # \u4e0a\u306ex\u3068\u9023\u7d50\u3067\u3042\u308by\u306e\u96c6\u5408\n    num_e = solve(x, x_set, y_set, X2Y, Y2X)\n    ans += len(x_set)*len(y_set) - num_e//2\n\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections.abc import Iterable\nfrom math import *\nfrom itertools import *\nfrom collections import *\nfrom functools import *\nfrom operator import *\ntry:\n    from math import gcd\nexcept Exception:\n    from fractions import gcd\n\n\nclass DGraph:\n    def __init__(self, n, edges):\n        self._vertice = [{} for _ in range(n)]\n        for e in edges:\n            self._vertice[e[0]][e[1]] = e[2] if len(e) == 3 else 1\n\n    def __len__(self):\n        return len(self._vertice)\n\n    def edges(self, n=None):\n        srcs = list(range(len(self))) if n is None else [n]\n        return sum([[(s, d, c) for d, c in list(self._vertice[s].items())] for s in srcs], [])\n\n    def transpose(self):\n        tedges = [(t, f, c) for f, t, c in self.edges()]\n        return DGraph(len(self), tedges)\n\n    def cost(self, src, dst):\n        return self._vertice[src].get(dst, float('inf'))\n\nclass Graph(DGraph):\n    def __init__(self, n, edges):\n        nd_edges = edges + [(d, s, c) for s, d, c in edges]\n        super().__init__(n, nd_edges)\n\n    def transpose(self):\n        return self\n\n\ndef solve(N: int, x: \"List[int]\", y: \"List[int]\"):\n    xs = {v:i for i, v in enumerate(set(x))}\n    ys = {v:i for i, v in enumerate(set(y), len(xs))}\n    \n    n = len(xs) + len(ys)\n    es = [(xs[cx], ys[cy], 1) for cx, cy in zip(x, y)]\n    g = Graph(n, es)\n\n    visited = [False] * len(g)\n    def dfs(g, src):\n        nonlocal visited\n        stack = [(src, 0)]\n        while stack:\n            n, c = stack.pop()\n            if visited[n]:\n                continue\n            visited[n] = True\n\n            for _, d, _ in g.edges(n):\n                #yield d\n                stack.append((d, c + 1))\n            yield n, c\n\n    def _f(i):\n        ls = list(i)\n        if len(ls) == 0:\n            return 0\n\n        xc = 0\n        yc = 0\n        es = 0\n        for i, _ in ls:\n            es += len(g.edges(i))\n            if i < len(xs):\n                xc += 1\n            else:\n                yc += 1\n        es //= 2\n\n        if xc < 2 or yc < 2:\n            return 0\n\n        return xc * yc - es\n\n    return sum([_f(dfs(g, i)) for i in range(n)])\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\" \n    y = [int()] * (N)  # type: \"List[int]\" \n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    result = solve(N, x, y)\n    if isinstance(result, Iterable) and not isinstance(result, str):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(x, al):\n    nonlocal cntx, cnty\n    if (al, x) in used:\n        return\n    used.add((al, x))\n    if al == 0:\n        cntx += 1\n    else:\n        cnty += 1\n    for xy in to[al][x]:\n        dfs(xy, 1 - al)\n    return\n\nn = int(input())\nto = [{}, {}]\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    to[0].setdefault(x, [])\n    to[1].setdefault(y, [])\n    to[0][x] += [y]\n    to[1][y] += [x]\nused = set()\nans = 0\nfor x in list(to[0].keys()):\n    if (0, x) in used: continue\n    cntx = 0\n    cnty = 0\n    dfs(x, 0)\n    ans += cntx * cnty\nprint((ans - n))\n", "import sys\nsys.setrecursionlimit(10**6)\n\ndef main():\n    input = sys.stdin.readline\n    V = 10**5  # max size of x\n    N = int(input())\n    bgraph = [[] for _ in range(2*V)]\n    for _ in range(N):\n        x, y = list(map(int, input().split()))\n        x -= 1\n        y += V - 1\n        bgraph[x].append(y)\n        bgraph[y].append(x)\n\n    def dfs(i):\n        if visited[i]:\n            return cnt\n        visited[i] = True\n        cnt[i//V] += 1\n        for j in bgraph[i]:\n            dfs(j)\n        return cnt\n\n    visited = [False] * (2*V)\n    ans = 0\n    for i in range(V):\n        if visited[i]:\n            continue\n        cnt = [0, 0]\n        cnt = dfs(i)\n        ans += cnt[0] * cnt[1]\n\n    ans -= N\n    return ans\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "import sys, math\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations, product\nfrom heapq import heappush, heappop\nfrom functools import lru_cache\ninput = sys.stdin.readline\nrs = lambda: input().strip()\nri = lambda: int(input())\nrl = lambda: list(map(int, input().split()))\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\nN = ri()\nto = defaultdict(list)\nV = 100005\nX = []\nfor i in range(N):\n\tx, y = rl()\n\tX.append(x)\n\ty += V\n\tto[x].append(y)\n\tto[y].append(x)\n\nvisited = set()\nnx, ny = 0, 0\ndef dfs(n):\n\tnonlocal nx, ny\n\tif n in visited: return\n\tvisited.add(n)\n\tif n < V:\n\t\tnx += 1\n\telse:\n\t\tny += 1\n\tfor m in to[n]:\n\t\tdfs(m)\n\nans = 0\nfor x in X:\n\tif x in visited: continue\n\tnx, ny = 0, 0\n\tdfs(x)\n\tans += nx*ny\nprint((ans-N))\n\n", "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda :sys.stdin.readline().rstrip()\ndef resolve():\n    V=100005\n    n=int(input())\n    E=[[] for _ in range(V*2)]\n    for _ in range(n):\n        x,y=map(int,input().split())\n        y+=V\n        E[x].append(y)\n        E[y].append(x)\n\n    visited=[0]*(2*V)\n    def dfs(v):\n        if(visited[v]): return\n        visited[v]=1\n        cnt[v//V]+=1\n        for nv in E[v]: dfs(nv)\n\n    ans=[0]\n    for v in range(2*V):\n        if(visited[v]): continue\n        cnt=[0]*2 # \u9023\u7d50\u6210\u5206\u306ex,y\u306e\u500b\u6570\n        dfs(v)\n        ans[0]+=cnt[0]*cnt[1]\n    print(ans[0]-n)\nresolve()", "class DisjointSet:\n    def __init__(self, size):\n        self.rank = [0 for i in range(size)]\n        self.p = [0 for i in range(size)]\n        for i in range(size):\n            self.makeSet(i)\n    \n    def makeSet(self, x):\n        self.p[x] = x\n        self.rank[x] = 0\n\n    def same(self, x, y):\n        return self.findSet(x) == self.findSet(y)\n\n    def unite(self, x, y):\n        self.link(self.findSet(x), self.findSet(y))\n\n    def link(self, x, y):\n        if self.rank[x] > self.rank[y]:\n            self.p[y] = x\n        else:\n            self.p[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n    \n    def findSet(self, x):\n        if x != self.p[x]:\n            self.p[x] = self.findSet(self.p[x])\n        return self.p[x]\n        \n\ndef __starting_point():\n    maxxy = 10**5\n    N = int(input())\n    ds = DisjointSet(maxxy*2+1)\n    left = [0 for i in range(maxxy*2+1)]\n    right = [0 for i in range(maxxy*2+1)]\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        ds.unite(x, maxxy+y)\n    for i in range(maxxy+1):\n        left[ds.findSet(i)] += 1\n    for i in range(maxxy+1, maxxy*2+1):\n        right[ds.findSet(i)] += 1\n    ans = 0\n    for i in range(maxxy*2+1):\n        ans += left[i] * right[i]\n    ans -= N\n    print(ans)\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(G, F, crr, pre, ret, st):\n    F[crr] = False\n    if crr < 10**5:\n        ret[0] += 1\n    else:\n        ret[1] += 1\n    for nxt in G[crr]:\n        if nxt == pre:\n            continue\n        p, q = crr, nxt\n        if q < p:\n            p, q = q, p\n        if not (p, q) in st:\n            st.add((p, q))\n            ret[2] += 1\n        if F[nxt]:\n            dfs(G, F, nxt, crr, ret, st)\n\ndef main():\n    n = int(input())\n    G = [[] for _ in range(2 * 10**5)]\n    for _ in range(n):\n        x, y = map(int, input().split())\n        x, y = x-1, y-1 + 10**5\n        G[x].append(y)\n        G[y].append(x)\n    F = [True]*(2* 10**5)\n    ans = 0\n    st = set()\n    for i in range(2 * 10**5):\n        if F[i] and len(G[i]) > 0:\n            tmp = [0]*3\n            dfs(G, F, i, -1, tmp, st)\n            ans += tmp[0] * tmp[1] - tmp[2]\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 7)\nn = int(input())\nedges = [[] for i in range(200000)]\nfor i in range(n):\n    x, y = map(int, input().split())\n    edges[x - 1].append(y + 99999)\n    edges[y + 99999].append(x - 1)\nans = 0\nvisited = [0] * (200000)\ncntx, cnty = 0, 0\ndef dfs(u):\n    nonlocal cntx, cnty\n    visited[u] = 1\n    if u // 100000 >= 1:\n        cnty += 1\n    else:\n        cntx += 1\n    for i in edges[u]:\n        if visited[i] == 0:\n            dfs(i)\nans = -1 * n\nfor i in range(100000):\n    if visited[i] == 0:\n        cntx, cnty = 0, 0\n        dfs(i)\n        ans += cntx * cnty\nprint(ans)", "# https://drken1215.hatenablog.com/entry/2019/06/23/004700\n# https://tjkendev.github.io/procon-library/python/union_find/union_find.html\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    MX = 10 ** 5 + 10\n    \n    *p, = [r for r in range(MX * 2)]\n\n    def root(x):\n        if x == p[x]:\n            return x\n        p[x] = y = root(p[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px == py:\n            return 0\n        if px < py:\n            p[py] = px\n        else:\n            p[px] = py\n        return 1\n\n    n = int(input())\n    for _ in range(n):\n        x, y = (int(x) - 1 for x in input().split())  # [1,)->[0,)\n        unite(x, y + MX)\n\n    xs = [0] * (MX * 2)\n    ys = [0] * (MX * 2)\n\n    for r in range(MX):\n        xs[root(r)] += 1\n\n    for r in range(MX, MX * 2):\n        ys[root(r)] += 1\n\n    ans = -n\n    for r in range(MX * 2):\n        ans += xs[r] * ys[r]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\nclass UnionFind:\n    def __init__(self,N): # \u9802\u70b9\u6570 N\n        self.table = [i for i in range(N)]    #\u6728\u306e\u89aa table[x] == x \u306a\u3089\u6839\n        self.rank  = [1 for i in range(N)]    #\u6728\u306e\u9577\u3055\n        self.size  = [1 for i in range(N)]    #\u96c6\u5408\u306e\u30b5\u30a4\u30ba\n\n    def Find(self,x):    #x\u306e\u6839\u3092\u8fd4\u3059\n        if self.table[x] == x:\n            return x\n        else:\n            self.table[x] = self.Find(self.table[x])    #\u89aa\u306e\u66f4\u65b0(\u6839\u3092\u76f4\u63a5\u89aa\u306b\u3057\u3066\u53c2\u7167\u8ddd\u96e2\u3092\u77ed\u304f)\n            self.size[x] = self.size[self.table[x]]\n            return self.table[x]\n\n    def Unite(self,x,y):    #x\u3068y\u3092\u7e4b\u3052\u308b\n        x,y = self.Find(x), self.Find(y)\n        sx,sy = self.Size(x), self.Size(y)\n        if x == y: return\n        if self.rank[x] > self.rank[y]:\n            self.table[y] = x\n            self.size[x] = sx + sy\n        else:\n            self.table[x] = y\n            self.size[y] = sx + sy\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def Check(self,x,y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self,x):\n        return self.size[self.Find(x)]\n\n\n\nN = int(input())\nUF = UnionFind(10**5+1)\n\nxys = [inpl() for _ in range(N)]\nxys.sort()\ntatedict = defaultdict(list)\nxx = set()\nfor x,y in xys:\n    tatedict[x].append(y)\n    xx.add(x)\n\nfor x in xx:\n    s = tatedict[x][0]\n    for t in tatedict[x]:\n        if not UF.Check(s,t):\n            UF.Unite(s,t)\n\nans = 0\nfor x in xx:\n    s = tatedict[x][0]\n    ans += UF.Size(s) - len(tatedict[x])\n\nprint(ans)\n", "def main():\n    MAX = 10 ** 5 + 1\n\n    data = [-1] * (2 * MAX)\n\n    def find(x):\n        if data[x] < 0:\n            return x\n        else:\n            data[x] = find(data[x])\n            return data[x]\n\n    def union(x, y):\n        x, y = find(x), find(y)\n        if x != y:\n            if data[y] < data[x]:\n                x, y = y, x\n            data[x] += data[y]\n            data[y] = x\n        return (x != y)\n\n\n    N, *XY = list(map(int, open(0).read().split()))\n\n    for x, y in zip(*[iter(XY)] * 2):\n        union(x, y + MAX)\n\n    X = [0] * (MAX * 2)\n    Y = [0] * (MAX * 2)\n\n    for i in range(MAX):\n        X[find(i)] += 1\n    for i in range(MAX, MAX * 2):\n        Y[find(i)] += 1\n\n    res = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n    print((res - N))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nN = int(input())\nM = 10 ** 5\nuft = UnionFindTree(2 * M)\n\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    x, y = x-1, y-1\n    uft.unite(x, y + M)\nx_dict, y_dict = dict(), dict()\nfor x in range(M):\n    par_x = uft.find(x)\n    x_dict[par_x] = x_dict.get(par_x, 0) + 1\nfor y in range(M, 2 * M):\n    par_y = uft.find(y)\n    y_dict[par_y] = y_dict.get(par_y, 0) + 1\nans = -N\nfor r in list(x_dict.keys()):\n    ans += x_dict.get(r, 0) * y_dict.get(r, 0)\nprint(ans)\n", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\nclass union_find:\n    def __init__(self, n):\n        self.N = n\n        self._parent = [i for i in range(self.N)]\n        self._mem = [1] * self.N\n        self.compo = self.N\n\n    def parent(self, a):\n        if self._parent[a] == a:\n            return a\n        self._parent[a] = self.parent(self._parent[a])\n        return self._parent[a]\n\n    def united(self,a, b):\n        return self.parent(a) == self.parent(b)\n    \n    def unite(self,a, b):\n        a = self.parent(a)\n        b = self.parent(b)\n        if(a == b): return False\n        if self._mem[a] > self._mem[b]: a, b = b, a\n        self._parent[a] = b\n        self._mem[b] += self._mem[a]\n        self.compo -= 1\n        return True\n    \n    def is_root(self,a):\n        return a == self._parent[a]\n    def mem_cnt(self,a):\n        return self._mem[self.parent(a)]\n    def dump(self):\n        print((self._parent))\n\n\n\ndef main():\n    N = ri()\n    X = [0] * N\n    Y = [0] * N\n    for i in range(N):\n        X[i], Y[i] = rip()\n    \n    uf = union_find(N)\n    di = dict()\n    for i in range(N):\n        if not X[i] in di: di[X[i]] = i\n        uf.unite(i, di[X[i]])\n    di.clear()\n    for i in range(N):\n        if not Y[i] in di: di[Y[i]] = i\n        uf.unite(i, di[Y[i]])\n\n    hx = [set() for i in range(N)]\n    hy = [set() for i in range(N)]\n    for i in range(N):\n        hx[uf.parent(i)].add(X[i])\n        hy[uf.parent(i)].add(Y[i])\n    \n    tot = 0\n    for i in range(N):\n        tot += len(hx[i]) * len(hy[i])\n    \n    print((tot - N))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind:\n\n  def __init__(self, n):\n    self.par = [i for i in range(n)]\n    self.rank = [0] * n\n    self.sizes = [1] * n\n\n  def find(self, x):\n    if self.par[x] != x:\n      self.par[x] = self.find(self.par[x])\n    return self.par[x]\n\n  def union(self, x, y):\n    x, y = self.find(x), self.find(y)\n    if x == y:\n      return False\n    elif self.rank[x] < self.rank[y]:\n      self.par[x] = y\n      self.sizes[y] += self.sizes[x]\n    elif self.rank[x] > self.rank[y]:\n      self.par[y] = x\n      self.sizes[x] += self.sizes[y]\n    else:\n      self.par[y] = x\n      self.rank[x] += 1\n      self.sizes[x] += self.sizes[y]\n    return True\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def size(self, x):\n    return self.sizes[self.find(x)]\n\nn = int(input())\nnx = [0 for i in range(200020)]\nny = [0 for i in range(200020)]\nuf = UnionFind(200020)\nfor i in range(n):\n  x, y = list(map(int, input().split()))\n  uf.union(x, y+100010)\nans = 0\nfor i in range(100010):\n  nx[uf.find(i)] += 1\n  ny[uf.find(i+100010)] += 1\nfor i in range(200020):\n  ans += nx[i]*ny[i]\nprint(ans-n)", "import numpy as np\nfrom scipy.sparse import csr_matrix, csgraph\nimport sys\n\ninput = sys.stdin.readline\n\nU = 10 ** 5\nn = int(input())\nxy = np.array([input().split() for _ in range(n)], dtype=np.int32)\n\ngraph = csr_matrix((np.ones(n, dtype=np.bool), (xy[:, 0], U + xy[:, 1])), (2 * U + 1, 2 * U + 1))\n_, component = csgraph.connected_components(graph)\n\nx_cnt = np.bincount(component[:U + 1], minlength=2 * U + 2)\ny_cnt = np.bincount(component[U + 1:], minlength=2 * U + 2)\npts_cnt = np.bincount(component[xy[:, 0]], minlength=2 * U + 2)\nanswer = (x_cnt * y_cnt - pts_cnt).sum()\nprint(answer)\n", "import sys\nsys.setrecursionlimit(100000)\n\nN = int(input())\nvertex = set()\nconn = [[] for _ in range(2*10**5 + 1)]\ncheck = [False]*(2*10**5 + 1)\nfor i in range(N):\n    x, y = [int(x) for x in input().split()]\n    vertex.add(x)\n    vertex.add(y + 10**5)\n    conn[x].append(y + 10**5)\n    conn[y + 10**5].append(x)\n\ncount = [0] * 2\ndef dfs(z):\n    if check[z] == True:\n        return\n    check[z] = True\n    if z <= 10**5:\n        count[0] += 1\n    else:\n        count[1] += 1\n    for w in conn[z]:\n        dfs(w)\n\nans = 0\nfor z in vertex:\n    if check[z] == False:\n        count = [0]*2\n        dfs(z)\n        X, Y = count[0], count[1]\n        ans += X * Y\nans -= N\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n# PyPy\u3060\u3068\u518d\u5e30\u304c\u9045\u3044\u306e\u3067\u6ce8\u610f\n# BEGIN CUT HERE\nsys.setrecursionlimit(100000)\nclass UnionFind():\n    '''UnionFind\u6728'''\n    def __init__(self,n):\n        self.data = [-1] * n\n    \n    def unite(self, x, y):\n        '''x \u3068 y \u3092\u7d50\u5408'''\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        elif self.data[x] < self.data[y]:\n            x, y = y, x  # swap\n        self.data[x] += self.data[y]\n        self.data[y] = x\n    \n    def root(self, x):\n        '''\u30ce\u30fc\u30c9 x \u306e\u89aa\u3092\u8fd4\u3059'''\n        if self.data[x] < 0:\n            return x\n        self.data[x] = self.root(self.data[x])\n        return self.data[x]\n\n    def same(self, x, y):\n        '''x \u3068 y \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a'''\n        return self.root(x) == self.root(y)\n    \n    def size(self, x):\n        '''x \u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u306e\u30ce\u30fc\u30c9\u6570\u3092\u8fd4\u3059'''\n        return self.data[self.root(x)]\n        \n# END CUT HERE\n\ndef ABC120_D():\n    n, m = mi()\n    a = [0] * m\n    b = [0] * m\n    for i in range(m):\n        a[i], b[i] = mi()\n        \n    uf = UnionFind(n)\n    ans = [0] * (m + 1)\n    ans[m] = n * (n - 1) // 2\n\n    for i in range(m - 1, -1, -1):\n        a[i] -= 1\n        b[i] -= 1\n        ans[i] = ans[i + 1]\n        if uf.same(a[i], b[i]):\n            continue\n        \n        x = uf.size(a[i])\n        y = uf.size(b[i])\n        ans[i] -= x * y\n        \n        uf.unite(a[i],b[i])\n    \n    for i in range(1, m + 1):\n        print(ans[i])\n\n# verified on 2019/06/23\n# Python3:616ms https://atcoder.jp/contests/abc120/submissions/6094323\n\ndef ABC126_E():\n    N, M = mi()\n    uf = UnionFind(N)\n    for i in range(M):\n        _X, _Y, _Z = mi()\n        uf.unite(_X - 1, _Y - 1)\n    ans = 0\n    for i in range(N):\n        if uf.root(i) == i:\n            ans += 1\n    print(ans)\n# verified on 2019/06/23\n# Python3:468ms https://atcoder.jp/contests/abc126/submissions/6094497\n\ndef ABC131_F():\n    from collections import defaultdict\n    MAX = 100010\n    uf = UnionFind(2 * MAX)\n    N = ii()\n    for i in range(N):\n        x, y = mi()\n        uf.unite(x, y + MAX)\n    \n    mx = defaultdict(int)\n    for i in range(MAX):\n        mx[uf.root(i)] += 1\n    my = defaultdict(int)\n    for i in range(MAX,2*MAX):\n        my[uf.root(i)] += 1\n    ans = 0\n    for i in range(2 * MAX):\n        ans += mx[i] * my[i]\n    print(ans - N)\n\n\ndef __starting_point():\n    # ABC120_D()\n    # ABC126_E()\n    ABC131_F()\n__starting_point()", "import sys\nfrom collections import defaultdict, deque\nreadline = sys.stdin.readline\nN = int(readline())\nP = defaultdict(list); Q = defaultdict(list)\nfor i in range(N):\n    x, y = map(int, readline().split())\n    P[x].append(y)\n    Q[y].append(x)\nX = set(); Y = set()\n\nres = 0\nque = deque()\nfor x in P:\n    que.append((0, x))\n    X.add(x)\n    cx = 1; cy = 0\n    while que:\n        t, v = que.popleft()\n        if t:\n            for x in Q[v]:\n                if x in X:\n                    continue\n                X.add(x)\n                que.append((0, x))\n                cx += 1\n        else:\n            for y in P[v]:\n                if y in Y:\n                    continue\n                Y.add(y)\n                que.append((1, y))\n                cy += 1\n    res += cx * cy\nprint(res - N)", "from collections import Counter\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.data = [-1] * size\n\n    def find(self, x):\n        if self.data[x] < 0:\n            return x\n        else:\n            self.data[x] = self.find(self.data[x])\n            return self.data[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.data[y] < self.data[x]:\n                x, y = y, x\n            self.data[x] += self.data[y]\n            self.data[y] = x\n        return (x != y)\n\n    def same(self, x, y):\n        return (self.find(x) == self.find(y))\n\n    def size(self, x):\n        return -self.data[self.find(x)]\n\n\ndef main():\n    MAX = 10 ** 5 + 1\n    uf = UnionFind(2 * MAX)\n\n    N, *XY = list(map(int, open(0).read().split()))\n\n    for x, y in zip(*[iter(XY)] * 2):\n        uf.union(x, y + MAX)\n\n    X = Counter(uf.find(i) for i in range(MAX))\n    Y = Counter(uf.find(i) for i in range(MAX, MAX * 2))\n    res = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n    print((res - N))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_left\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nXY = [lr() for _ in range(N)]\nV = list(range(2 * 10**5 + 1)) # 1-indexed X coordinate\u3001Y coordinate\u306e\u9806\u756a\n\n# A\u3067x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(A,x):\n    p = A[x]\n    if p == x: return x\n    a = find(A,p)\n    A[x] = a\n    return a\n# A\u3067x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef union(A, x, y):\n    if find(A,x) > find(A,y):\n        bx, by = find(A,y), find(A,x)\n    else:\n        bx, by = find(A,x), find(A,y)\n    A[by] = bx # \u6839\u3092bx\u306b\u7d71\u4e00\n\nfor x, y in XY:\n    y += 10**5\n    if find(V, x) != find(V, y):\n        union(V, x, y)\n\nset_V = [set() for _ in range(2 * 10**5 + 1)] # 1-indexed\nfor x, y in XY:\n    root = find(V, x)\n    set_V[root] |= set([x, y+10**5])\n\nset_V = [x for x in set_V if x]\nanswer = 0\nfor z in set_V:\n    z = sorted(list(z))\n    cnt_x = bisect_left(z, 10 ** 5 + 1)\n    cnt_y = len(z) - cnt_x\n    answer += cnt_x * cnt_y\n\nanswer -= N\nprint(answer)\n# 48\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    n = I()\n    xy = [LI() for _ in range(n)]\n    xd = {}\n    yd = {}\n\n    xi = 0\n    yi = 0\n    for x,y in xy:\n        if x not in xd:\n            xd[x] = xi\n            xi += 1\n        if y not in yd:\n            yd[y] = yi\n            yi += 1\n\n    uf = UnionFind(xi+yi+n)\n    ii = xi + yi\n    for i in range(n):\n        x,y = xy[i]\n        uf.union(xd[x], ii + i)\n        uf.union(xi + yd[y], ii + i)\n\n    dx = collections.defaultdict(set)\n    dy = collections.defaultdict(set)\n    for i in range(n):\n        x,y = xy[i]\n        ui = uf.find(ii + i)\n        dx[ui].add(x)\n        dy[ui].add(y)\n\n    r = -n\n    for k,xv in dx.items():\n        yv = dy[k]\n        r += len(xv) * len(yv)\n\n    return r\n\n\nprint(main())\n\n", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    MAXS = 100005\n    N = int(input())\n    X = [set() for _ in range(MAXS)]\n    Y = [set() for _ in range(MAXS)]\n    for _ in range(N):\n        x,y = map(int,input().split())\n        X[x].add(y)\n        Y[y].add(x)\n    \n    used_x = [0] * MAXS\n    used_y = [0] * MAXS\n    ans = -N\n    for i in range(MAXS):\n        if used_x[i]:\n            continue\n        used_x[i] = 1\n        if not X[i]:\n            continue\n        max_height = set(X[i])\n        max_width = {i}\n        stack = [(i,0)]\n        while stack:\n            v,typ = stack.pop()\n            if typ == 0:\n                for y in X[v]:\n                    if used_y[y]:\n                        continue\n                    used_y[y] = 1\n                    if Y[y]:\n                        max_width |= Y[y]\n                        stack.append((y,1))\n            else:\n                for x in Y[v]:\n                    if used_x[x]:\n                        continue\n                    used_x[x] = 1\n                    if X[x]:\n                        max_height |= X[x]\n                        stack.append((x,0))\n        ans += len(max_width) * len(max_height)\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "from operator import itemgetter\nfrom collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\n# Union-Find\u30c7\u30fc\u30bf\u69cb\u9020\nclass UnionFind:\n    def __init__(self, numV):\n        self.pars = list(range(numV))\n        self.ranks = [0] * numV\n    def find(self, x):\n        if self.pars[x] == x: return x\n        else:\n            self.pars[x] = self.find(self.pars[x])\n            return self.pars[x]\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y: return\n        if self.ranks[x] < self.ranks[y]:\n            self.pars[x] = y\n        else:\n            self.pars[y] = x\n            if self.ranks[x] == self.ranks[y]:\n                self.ranks[x] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN = int(input())\nxys = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    xys.append((x, y, i))\n\nUF = UnionFind(N)\nfor k in range(2):\n    xys.sort(key=itemgetter(k))\n    for i in range(N-1):\n        if xys[i][k] == xys[i+1][k]:\n            UF.union(xys[i][2], xys[i+1][2])\n\nXs = defaultdict(set)\nYs = defaultdict(set)\nfor x, y, i in xys:\n    no = UF.find(i)\n    Xs[no].add(x)\n    Ys[no].add(y)\n\nans = 0\nfor no in list(Xs.keys()):\n    ans += len(Xs[no]) * len(Ys[no])\n\nprint((ans - N))\n", "import sys\nread = sys.stdin.buffer.read\nreadlines = sys.stdin.buffer.readlines\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10**7)\n\n\ndef main():\n    OFS = 100005\n    N = int(input())\n    G = [[] for _ in [0]*OFS*2]\n    for line in readlines():\n        x, y = map(int, line.split())\n        y += OFS\n        G[x].append(y)\n        G[y].append(x)\n\n    def dfs(v):\n        if v < OFS:\n            counter[0] += 1\n        else:\n            counter[1] += 1\n\n        for u in G[v]:\n            if visited[u]:\n                continue\n            visited[u] = 1\n            dfs(u)\n\n    visited = [0]*OFS*2\n    ans = 0\n    for i in range(OFS):\n        if visited[i]:\n            continue\n        counter = [0]*2\n        visited[i] = 1\n        dfs(i)\n        ans += counter[0] * counter[1]\n\n    print(ans - N)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n# input = sys.stdin.readline\nsys.setrecursionlimit(pow(10, 6))\n\nxedges = [[] for _ in range(100001)]\nyedges = [[] for _ in range(100001)]\nxvisited = [False for _ in range(100001)]\nyvisited = [False for _ in range(100001)]\n\ndef dfs(i, xy):\n  if xy == 0:\n    xvisited[i] = True\n  else:\n    yvisited[i] = True\n  xc, yc, ec = (xy+1)%2, xy%2, 0\n  if xy == 0:\n    ec += len(xedges[i])\n    for toy in xedges[i]:\n      if not yvisited[toy]:\n        _xc, _yc, _ec = dfs(toy, 1)\n        xc += _xc\n        yc += _yc\n        ec += _ec\n  else :\n    ec += len(yedges[i])\n    for tox in yedges[i]:\n      if not xvisited[tox]:\n        _xc, _yc, _ec = dfs(tox, 0)\n        xc += _xc\n        yc += _yc\n        ec += _ec\n  return xc, yc, ec\n\ndef main():\n  n = int(input())\n  for _ in range(n):\n    x, y = list(map(int, input().split()))\n    xedges[x].append(y)\n    yedges[y].append(x)\n\n  ans = 0\n  for i in range(1, 100001):\n    if not xvisited[i] and len(xedges[i]) != 0:\n      xc, yc, ec = dfs(i, 0)\n      ans += xc*yc-ec//2\n    elif not yvisited[i] and len(yedges[i]) != 0:\n      xc, yc, ec = dfs(i, 1)\n      ans += xc*yc-ec//2\n\n  print(ans)\n\n\ndef __starting_point():\n  main()\n\n__starting_point()", "N = int(input())\npoints = []\nfor i in range(0, N):\n    points.append(list(map(int, input().split(' '))))\nX = dict()\nY = dict()\ncount = 0\nfor p in points:\n    if p[0] not in X.keys():\n        X[p[0]] = []\n    X[p[0]].append(p[1])\n    if p[1] not in Y.keys():\n        Y[p[1]] = []\n    Y[p[1]].append(p[0])\nwhile len(X.items()) > 0:\n    item = list(X.items())[0]\n    del X[item[0]]\n    queue = [item]\n    point_dict = {'x': [], 'y': []}\n    queue_is_x = [True]\n    while len(queue) > 0:\n        item = queue.pop(0)\n        is_x = queue_is_x.pop(0)\n        if is_x:\n            point_dict['x'].append(item[0])\n            for i in item[1]:\n                if i in Y.keys():\n                    queue.append((i, Y[i]))\n                    queue_is_x.append(False)\n                    del Y[i]\n        else:\n            point_dict['y'].append(item[0])\n            for i in item[1]:\n                if i in X.keys():\n                    queue.append((i, X[i]))\n                    queue_is_x.append(True)\n                    del X[i]\n    # print((point_dict['x']))\n    # print(len((point_dict['x'])))\n    # print((point_dict['y']))\n    # print(len((point_dict['y'])))\n    count += len(set(point_dict['x'])) * len(set(point_dict['y']))\n\nprint(count - len(points))", "import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\nv = 10**5+2\ne = [[] for i in range(2*v)]\nfor i in range(n):\n    x,y = list(map(int,input().split()))\n    y += v\n    e[x].append(y)\n    e[y].append(x)\nvisit = [0]*(2*v)\ndef dfs(x):\n    if not visit[x]:\n        visit[x] = 1\n        count[x//v] += 1\n        for nex in e[x]:\n            dfs(nex)\nans = 0\nfor i in range(v):\n    if not visit[i]:\n        count = [0]*2\n        dfs(i)\n        ans += count[0]*count[1]\nprint((ans-n))\n    \n", "class UnionFind :\n    def __init__(self, size) :\n        self.parent = list(range(size))\n        self.height = [0] * size\n        self.size = [1] * size\n        self.component = size\n\n    def root(self, index) :\n        if self.parent[index] == index :  # \u6839\u306e\u5834\u5408\n            return index\n        rootIndex = self.root(self.parent[index])  # \u8449\u306e\u5834\u5408\u89aa\u306e\u6839\u3092\u53d6\u5f97\n        self.parent[index] = rootIndex  # \u89aa\u306e\u4ed8\u3051\u76f4\u3057\n        return rootIndex\n\n    def union(self, index1, index2) :  # \u7d50\u5408\n        root1 = self.root(index1)\n        root2 = self.root(index2)\n\n        if root1 == root2 :  # \u9023\u7d50\u3055\u308c\u3066\u3044\u308b\u5834\u5408\n            return\n\n        self.component -= 1  # \u9023\u7d50\u6210\u5206\u3092\u6e1b\u3089\u3059\n\n        if self.height[root1] < self.height[root2] :\n            self.parent[root1] = root2  # root2\u306b\u7d50\u5408\n            self.size[root2] += self.size[root1]\n        else :\n            self.parent[root2] = root1  # root1\u306b\u7d50\u5408\n            self.size[root1] += self.size[root2]\n            if self.height[root1] == self.height[root2] :\n                self.height[root1] += 1\n        return\n\n    def isSameRoot(self, index1, index2) :\n        return self.root(index1) == self.root(index2)\n\n    def sizeOfSameRoot(self, index) :\n        return self.size[self.root(index)]\n\n    def getComponent(self) :\n        return self.component\n\nN = int(input())\nR = 10**5 + 10\nIXY = []\n\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    IXY.append((i, x, y))\n\nX = [[] for _ in range(R)]\nY = [[] for _ in range(R)]\nfor i, x, y in IXY:\n    X[x].append(i)\n    Y[y].append(i)\n\ntree = UnionFind(N)\n\nfor x in X:\n    for fr, to in zip(x, x[1:]):\n        tree.union(fr, to)\nfor y in Y:\n    for fr, to in zip(y, y[1:]):\n        tree.union(fr, to)\n\nG = [[0, set(), set()] for _ in range(N)]\nfor i, x, y in IXY:\n    r = tree.root(i)\n    G[r][0] += 1\n    G[r][1].add(x)\n    G[r][2].add(y)\n\nans = 0\nfor grp in G:\n    if grp[0] < 3:\n        continue\n    x = len(grp[1])\n    y = len(grp[2])\n    A = x * y\n    ans += max(0, A - grp[0])\nprint(ans)\n", "import sys\nfrom collections import defaultdict\nimport queue\n\nn = int(sys.stdin.readline())\n\ngraph = defaultdict(list)\n\nX, Y = [[] for i in range(n)], [[] for i in range(n)]\natX, atY = defaultdict(list), defaultdict(list)\n\nfor i in range(n):\n\ta, b = map(int, sys.stdin.readline().split())\n\ta -= 1; b-= 1\n\tX[i] = a; Y[i] = b\n\tatX[X[i]].append(i)\n\tatY[Y[i]].append(i)\n\nvisX = set(); visY = set()\nfound = [False]*n\n\nans = n*(-1)\nfor root in range(n):\n\tif found[root]: continue\n\tusedX, usedY = set(), set()\n\n\tque = queue.Queue()\n\tque.put(root)\n\tfound[root] = True\n\tusedX.add(X[root])\n\tusedY.add(Y[root])\n\n\twhile not que.empty():\n\t\tcur = que.get()\n\t\ttoVisit = []\n\t\tif X[cur] not in visX:\n\t\t\tvisX.add(X[cur])\n\t\t\tfor ele in atX[X[cur]]:\n\t\t\t\ttoVisit.append(ele)\n\t\tif Y[cur] not in visY:\n\t\t\tvisY.add(Y[cur])\n\t\t\tfor ele in atY[Y[cur]]:\n\t\t\t\ttoVisit.append(ele)\n\n\t\tfor ele in toVisit:\n\t\t\tif found[ele]: continue\n\t\t\tfound[ele] = True\n\t\t\tusedX.add(X[ele])\n\t\t\tusedY.add(Y[ele])\n\t\t\tque.put(ele)\n\tans += len(usedX)*len(usedY)\nprint(ans)", "import copy\nimport collections\nimport sys\nread = sys.stdin.read\nNXY = [int(_) for _ in read().split()]\nN = NXY[0]\nX = NXY[1::2]\nY = NXY[2::2]\nxi = {x: i for i, x in enumerate(set(X))}\nyj = {y: j for j, y in enumerate(set(Y))}\n\n\nclass UnionFind():\n    def __init__(self, size):\n        self.dat = list(range(size))\n        self.SIZE = [1] * size  # 0-indexed\n\n    def find(self, x):\n        dat = self.dat\n        stack = [x]\n        while True:\n            y = stack[-1]\n            if dat[y] != y:\n                stack += [dat[y]]\n            else:\n                break\n        for s in stack:\n            dat[s] = y\n        return y\n\n    def unite(self, x, y):\n        is_same = self.is_same\n        find = self.find\n        SIZE = self.SIZE\n        dat = self.dat\n        if not is_same(x, y):\n            X, Y = find(x), find(y)\n            SX, SY = SIZE[X], SIZE[Y]\n            if SX > SY:\n                m = dat[X] = Y\n            else:\n                m = dat[Y] = X\n            SIZE[m] = SX + SY\n            SIZE[X + Y - m] = 0\n\n    def is_same(self, x, y):\n        find = self.find\n        return find(x) == find(y)\n\n    def scan_uf(self):\n        find = self.find\n        length = len(self.dat)\n        for i in range(length):\n            find(i)\n\n    def size(self, x):\n        return self.SIZE[self.find(x)]\n\n\nufx = UnionFind(len(xi))\nufy = UnionFind(len(yj))\nsxy = collections.defaultdict(set)\nsyx = collections.defaultdict(set)\nfor x, y in zip(X, Y):\n    i = xi[x]\n    j = yj[y]\n    sxy[i].add(j)\n    syx[j].add(i)\nsxy2 = copy.deepcopy(sxy)\nfor sy in list(sxy.values()):\n    y1 = sy.pop()\n    for y in sy:\n        ufy.unite(y1, y)\nfor sx in list(syx.values()):\n    x1 = sx.pop()\n    for x in sx:\n        ufx.unite(x1, x)\nufx.scan_uf()\nufy.scan_uf()\nans = 0\nfor x, vx in enumerate(ufx.SIZE):\n    if vx:\n        vy = ufy.size(sxy2[x].pop())\n        ans += vx * vy\nprint((ans - N))\n", "class Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.siz = [1]*(num+1)\n\n    def same_checker(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.siz[ry] += self.siz[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n        return\n\n    def size(self, x):\n        return self.siz[self.find(x)]\n\nn = int(input())\nuf = Union_Find(n)\n\nd = [list(map(int, input().split())) for i in range(n)]\nx = [[] for i in range(100001)]\ny = [[] for i in range(100001)]\n\nfor i in range(n):\n    xi, yi = d[i]\n    x[xi].append(i+1)\n    y[yi].append(i+1)\n\n\nfor i in range(1, 100001):\n    for j in range(len(x[i])-1):\n        uf.union(x[i][j], x[i][j+1])\n\nfor i in range(1, 100001):\n    for j in range(len(y[i])-1):\n        uf.union(y[i][j], y[i][j+1])\n\npar = [[] for i in range(n+1)]\nfor i in range(1, n+1):\n    par[uf.find(i)].append(d[i-1])\n\nans = -n\nfor i in range(1, n+1):\n    x = set()\n    y = set()\n    for xi, yi in par[i]:\n        x.add(xi)\n        y.add(yi)\n\n    ans += len(x)*len(y)\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    \"\"\"\n    <UnionFind\u3092\u4f7f\u308f\u306a\u3044\u5225\u89e3>\n\n    x\u65b9\u5411\u3068y\u65b9\u5411\u306b\u5206\u3051\u3066\u9802\u70b9\u3092\u8fba\u3060\u3068\u601d\u3046\u306e\u306f\u5b9a\u77f3\uff1f\uff1f\uff1f\uff08\u78ba\u304b\u306b\u9577\u65b9\u5f62\u304c\u30e1\u30a4\u30f3\u306a\u3089\u76f4\u7a4d\u5206\u89e3\u3057\u305f\u304f\u306a\u308b\uff1f\uff09\n    \u3053\u306e\u3068\u304d\u554f\u984c\u6587\u306f\u300c\u9577\u3055\uff13\u306e\u30d1\u30b9\u304c\u3042\u308c\u3070\u30d1\u30b9\u3092\uff11\u672c\u8ffd\u52a0\u3059\u308b\u64cd\u4f5c\u3092\u7e70\u308a\u8fd4\u3057\u3066\u3001\u5404\u9023\u7d50\u6210\u5206\u3092\u5b8c\u5168\u4e8c\u90e8\u30b0\u30e9\u30d5\u306b\u305b\u3088\u300d\n\n    \u5b8c\u5168\u4e8c\u90e8\u30b0\u30e9\u30d5\u306b\u306a\u308b\u306e\u306f\u80cc\u7406\u6cd5\u304b\u3089\u3059\u3050\u308f\u304b\u308b\u3002\u306a\u306e\u3067\u89e3\u6cd5\u306f(\u00a5Sum_{i:component}X_i Y_i) - N\n    \"\"\"\n\n    N = int(input())\n    V = 10 ** 5 + 1 # padding for y\n    repn = [[] for _ in range(V * 2)]\n    for _ in range(N):\n        x, y = list(map(int, input().split()))\n        repn[x].append(V + y)\n        repn[V + y].append(x)\n\n    visited = [0] * (V * 2)\n    count = [0, 0]\n\n    # dfs\u3067\u305d\u306e\u90fd\u5ea6\u9023\u7d50\u6210\u5206\u3092\u6c42\u3081\u308b\n    def dfs(v):\n        if visited[v]:\n            return\n        visited[v] = 1\n        count[v // V] += 1\n        for u in repn[v]:\n            dfs(u)\n\n    ans = 0\n    for i in range(V * 2):\n        if visited[i]:\n            continue\n        count[:] = [0, 0]\n        dfs(i)\n        ans += count[0] * count[1]\n    print((ans - N))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\n\ndef main():\n    class UnionFind:\n        def __init__(self, size):\n            self.data = [-1] * size\n\n        def find(self, x):\n            if self.data[x] < 0:\n                return x\n            else:\n                self.data[x] = self.find(self.data[x])\n                return self.data[x]\n\n        def union(self, x, y):\n            x, y = self.find(x), self.find(y)\n            if x != y:\n                if self.data[y] < self.data[x]:\n                    x, y = y, x\n                self.data[x] += self.data[y]\n                self.data[y] = x\n            return (x != y)\n\n    MAX = 10 ** 5 + 1\n    uf = UnionFind(2 * MAX)\n\n    N, *XY = list(map(int, open(0).read().split()))\n\n    for x, y in zip(*[iter(XY)] * 2):\n        uf.union(x, y + MAX)\n\n    X = Counter(uf.find(i) for i in range(MAX))\n    Y = Counter(uf.find(i) for i in range(MAX, MAX * 2))\n    res = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n    print((res - N))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\n\ndef main():\n    MAX = 10 ** 5 + 1\n\n    data = [-1] * (2 * MAX)\n\n    def find(x):\n        if data[x] < 0:\n            return x\n        else:\n            data[x] = find(data[x])\n            return data[x]\n\n    def union(x, y):\n        x, y = find(x), find(y)\n        if x != y:\n            if data[y] < data[x]:\n                x, y = y, x\n            data[x] += data[y]\n            data[y] = x\n        return (x != y)\n\n\n    N, *XY = map(int, open(0).read().split())\n\n    for x, y in zip(*[iter(XY)] * 2):\n        union(x, y + MAX)\n\n    X = Counter(find(i) for i in range(MAX))\n    Y = Counter(find(i) for i in range(MAX, MAX * 2))\n    res = sum(X[i] * Y[i] for i in range(MAX * 2))\n\n    print(res - N)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u4e8c\u90e8\u3050\u3089\u3075\u3001\u77e5\u3089\u306a\u304b\u3063\u305f\nfrom collections import defaultdict\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n + 1) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN = int(input())\nU = UnionFind(2*10**5)\nfor i in range(N):\n    x, y = map(int, input().split())\n    U.union(x, y+10**5)\nans = 0\nRoots = U.roots()\nD = {x: [] for x in Roots}\nfor i in range(2*10**5+1):\n    D[U.find(i)].append(i)\nfor x in Roots:\n    ss = D[x]\n    sx = 0\n    sy = 0\n    for c in ss:\n        if c <= 10**5:\n            sx += 1\n        else:\n            sy += 1\n    ans += sx*sy\nans -= N\nprint(ans)", "#  --*-coding:utf-8-*--\n\ndef dsMakeSet(ds, x):\n    ds[x] = x\n\n\ndef dsFind(ds, x):\n    if ds[x] == x:\n        return x\n\n    x0 = x\n    while ds[x] != x:\n        x = ds[x]\n\n    ds[x0] = x\n    return x\n\n\ndef dsUnion(ds, x, y):\n    xRoot = dsFind(ds, x)\n    yRoot = dsFind(ds, y)\n    \n    if xRoot != yRoot:\n        ds[yRoot] = xRoot\n        return True\n\n    return False\n\n\n\nN = int(input())\nQ = {}\n\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n\n    X = ('x', x)\n    Y = ('y', y)\n\n    if not (X in Q):\n        dsMakeSet(Q, X)\n\n    if not (Y in Q):\n        dsMakeSet(Q, ('y', y))\n    \n    dsUnion(Q, X, Y)\n\nR = {}\n\nfor q in Q:\n    root = dsFind(Q, q)\n    \n    if not(root in R):\n        R[root] = [0, 0]\n\n    r = R[root]\n    if q[0] == 'x':\n        r[0] += 1\n    else:\n        r[1] += 1\n\ns = 0\nfor r in list(R.values()):\n    s += r[0]*r[1]\n\nprint((s - N))\n\n    \n\n", "import sys\nsys.setrecursionlimit(10000000)\n\nV = 100005\nN = int(input())\n\nlines = [[] for _ in range(V * 2)]\nvisited = [False] * V * 2\n\ncount = []\ndef dfs(v):\n\tnonlocal count\n\tif visited[v]:\n\t\treturn\n\tvisited[v] = True\n\tcount[v // V] += 1\n\tfor u in lines[v]:\n\t\tdfs(u)\n\n\nfor i in range(N):\n\tx, y = [int(x) for x in input().split()]\n\ty += V\n\tlines[x].append(y)\n\tlines[y].append(x)\n\nans = 0\nfor i in range(V * 2):\n\tif visited[i]:\n\t\tcontinue\n\tcount = [0, 0]\n\tdfs(i)\n\tans += count[0] * count[1]\n\nans -= N\nprint(ans)", "n=int(input())\nxy=[]\nX=[]\nY=[]\nfor _ in range(n):\n  x,y=list(map(int,input().split()))\n  xy.append([x,y])\n  X.append(x)\n  Y.append(y)\nX=list(set(X))\nY=list(set(Y))\nX.sort()\nY.sort()\nfrom bisect import bisect_left\nxy=[[bisect_left(X,x),bisect_left(Y,y)] for x,y in xy]\nmx=0\nmy=0\nfor x,y in xy:\n  mx=max(mx,x)\n  my=max(my,y)\nmx,my=mx+1,my+1\nbg=[[] for _ in range(mx+my)]\nfor x,y in xy:\n  y+=mx\n  bg[x].append(y)\n  bg[y].append(x)\nmi=set(range(mx+my))\nren=[]\nwhile mi:\n  todo=[mi.pop()]\n  rx,ry=0,0\n  while todo:\n    v=todo.pop()\n    if v<mx:\n      rx+=1\n    else:\n      ry+=1\n    for nv in bg[v]:\n      if nv in mi:\n        todo.append(nv)\n        mi.discard(nv)\n  ren.append([rx,ry])\nans=0\nfor rx,ry in ren:\n  ans+=rx*ry\nans-=n\nprint(ans)\n", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    M = 10 ** 5\n\n    N = int(input())\n\n    g = tuple(set() for _ in range(M * 2))\n    for _ in range(N):\n        x, y = (int(x) - 1 for x in input().split())  # \u4e00\u5f8b\u306b\u79fb\u52d5\n        g[x].add(y + M)\n        g[y + M].add(x)\n\n    visited = [0] * (M * 2)\n    ans = 0\n    for s in range(M * 2):  # x\u3068y+M\u306eset\u306e\u65b9\u304c\u78ba\u8a8d\u3059\u308b\u6570\u306f\u6e1b\u308b?\n        if visited[s]: continue\n        visited[s] = 1\n        dq = deque()\n        dq.append(s)\n\n        sz = 0\n        x = 0\n        while dq:\n            v = dq.popleft()\n            sz += 1\n            if v < M:\n                x += 1\n            for u in g[v]:\n                if visited[u]: continue\n                visited[u] = 1\n                dq.append(u)\n        ans += (sz - x) * x\n\n    ans -= N\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n# \u9023\u7d50\u6210\u5206\u3054\u3068\u306b\n# x,y\u306e\u4e8c\u90e8\u30b0\u30e9\u30d5\u3092\u5b8c\u5168\u4e8c\u90e8\u30b0\u30e9\u30d5\u306b\u3059\u308b\n# cnt(x)*cnt(y)-\u65e2\u5b58\u306e\u8fba\u6570\u306e\u7dcf\u548c\n\n# \u6700\u5f8c\u306bN\u5f15\u3051\u3070\u3088\u3044\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**5)\nm = 100005\nvisited = [False]*(m*2)\ncnt = [0,0]\ndef dfs(i):\n    visited[i] = True\n    cnt[i//m] = cnt[i//m]+1\n    for j in to[i]:\n        if not visited[j]:\n            dfs(j)\n \ninput = sys.stdin.readline\nn = int(input())\nto = [[] for _ in range(m*2)]\nfor _ in range(n):\n    x,y = map(int,input().split())\n    y = y+m\n    to[x].append(y)\n    to[y].append(x)\n \nans = 0\nfor i in range(m):\n    if not visited[i]:\n        cnt = [0,0]\n        dfs(i)\n        ans = ans + cnt[0]*cnt[1]\n \nprint(ans-n)", "def get_group(x):\n    g = group[x]\n    if g == x:\n        return x\n    group[g] = re = get_group(g)\n    return re\n\ndef unite(x, y):\n    gx = get_group(x)\n    gy = get_group(y)\n    if gx != gy:\n        dx = depth[gx]\n        dy = depth[gy]\n        if dy > dx:\n            gx, gy = gy, gx\n        group[gy] = gx\n        if dx == dy:\n            depth[gx] += 1\n\nn = int(input())\ngroup = {}\ndepth = {}\nedge = []\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    group.setdefault(x, x)\n    group.setdefault(-y, -y)\n    depth.setdefault(x, 1)\n    depth.setdefault(-y, 1)\n    edge += [[x, -y]]\n\nfor x, y in edge:\n    unite(x, y)\n\ncnt = {}\nfor k in list(group.keys()):\n    g = get_group(k)\n    cnt.setdefault(g, [0, 0])\n    if k > 0:\n        cnt[g][0] += 1\n    else:\n        cnt[g][1] += 1\n\nans = 0\nfor cx, cy in list(cnt.values()):\n    ans += cx * cy\nprint((ans - n))\n", "class UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.components = n  # \u9023\u7d50\u6210\u5206\u306e\u6570\n\n    def root(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.root(self.p[x])\n            return self.p[x]\n    \n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x != y:\n            self.p[x] = y\n            self.components -= 1\n    \n    def same(self, x,y):\n        return (self.root(x) == self.root(y))\n\nN = int(input())\nMAX = 100010\nUF = UnionFind(2*MAX)\n\nfor _ in range(N):\n    x, y = map(int,input().split())\n    UF.unite(x,y+MAX)\n\n\ncnt_x, cnt_y = [0]*(2*MAX), [0]*(2*MAX)\n\nfor i in range(MAX):\n    cnt_x[UF.root(i)] += 1\n\nfor i in range(MAX,2*MAX):\n    cnt_y[UF.root(i)] += 1\n\nprint(sum([cnt_x[i]*cnt_y[i] for i in range(2*MAX)]) - N)", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\nn=int(input())\nm=10**5+5\nl=[]\nlx=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    l.append((a,b+m,1))\n    lx.append(a)\nedge=np.array(l,dtype=np.int64).T\ngraph=csr_matrix(((edge[2],edge[:2]-1)),(2*m,2*m))\nn,labels=connected_components(graph)\nlx=np.array(lx)\nx=np.bincount(labels[:m],minlength=n)\ny=np.bincount(labels[m:],minlength=n)\ne=np.bincount(labels[lx],minlength=n)\nprint((x*y-e).sum())", "# using main() makes code faster from the point of view of \"access to variables in nonlocal name-space\"\n# def main():\n\n# for i, a in enumerate(iterable)\n# q, mod = divmod(a, b)\n# divmod(x, y) returns the tuple (x//y, x%y)\n# manage median(s) using two heapq https://atcoder.jp/contests/abc127/tasks/abc127_f\nimport sys\nsys.setrecursionlimit(10**7)\nfrom itertools import accumulate, combinations, permutations # https://docs.python.org/ja/3/library/itertools.html\nfrom math import factorial\ndef factorize(n):\n    \"\"\"return the factors of the Arg and count of each factor\n    \n    Args:\n        n (long): number to be resolved into factors\n    \n    Returns:\n        list of tuples: factorize(220) returns [(2, 2), (5, 1), (11, 1)]\n    \"\"\"\n    fct = []  # prime factor\n    b, e = 2, 0  # base, exponent\n    while b * b <= n:\n        while n % b == 0:\n            n = n // b\n            e = e + 1\n        if e > 0:\n            fct.append((b, e))\n        b, e = b + 1, 0\n    if n > 1:\n        fct.append((n, 1))\n    return fct\ndef combinations_count(n, r):\n    \"\"\"Return the number of selecting r pieces of items from n kinds of items.\n    \n    Args:\n        n (long): number\n        r (long): number\n    \n    Raises:\n        Exception: not defined when n or r is negative\n    \n    Returns:\n        long: number\n    \"\"\"\n    # TODO: How should I do when n - r is negative?\n    if n < 0 or r < 0:\n        raise Exception('combinations_count(n, r) not defined when n or r is negative')\n    if n - r < r: r = n - r\n    if r < 0: return 0\n    if r == 0: return 1\n    if r == 1: return n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n    for p in range(2,r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1,r,p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n    return result\ndef combinations_with_replacement_count(n, r):\n    \"\"\"Return the number of selecting r pieces of items from n kinds of items allowing individual elements to be repeated more than once.\n    \n    Args:\n        n (long): number\n        r (long): number\n    \n    Raises:\n        Exception: not defined when n or r is negative\n    \n    Returns:\n        long: number\n    \"\"\"\n    if n < 0 or r < 0:\n        raise Exception('combinations_with_replacement_count(n, r) not defined when n or r is negative')\n    elif n == 0:\n        return 1\n    else:\n        return combinations_count(n + r - 1, r)\nfrom collections import deque, Counter, defaultdict # https://docs.python.org/ja/3/library/collections.html#collections.deque\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace,nlargest,nsmallest # https://docs.python.org/ja/3/library/heapq.html\nfrom copy import deepcopy, copy # https://docs.python.org/ja/3/library/copy.html\nfrom operator import itemgetter\n# ex1: List.sort(key=itemgetter(1))\n# ex2: sorted(tuples, key=itemgetter(1,2))\nfrom functools import reduce\nfrom fractions import gcd # Deprecated since version 3.5: Use math.gcd() instead.\ndef gcds(numbers):\n    return reduce(gcd, numbers)\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\ndef lcms(numbers):\n    return reduce(lcm, numbers, 1)\n\n# first create factorial_list\n# fac_list = mod_factorial_list(n)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nmodpow = lambda a, n, p = MOD: pow(a, n, p) # Recursive function in python is slow!\ndef modinv(a, p = MOD):\n    # evaluate reciprocal using Fermat's little theorem:\n    # a**(p-1) is identical to 1 (mod p) when a and p is coprime\n    return modpow(a, p-2, p)\ndef modinv_list(n, p = MOD):\n    if n <= 1:\n        return [0,1][:n+1]\n    else:\n        inv_t = [0,1]\n        for i in range(2, n+1):\n            inv_t += [inv_t[p % i] * (p - int(p / i)) % p]\n        return inv_t\ndef modfactorial_list(n, p = MOD):\n    if n == 0:\n        return [1]\n    else:\n        l = [0] * (n+1)\n        tmp = 1\n        for i in range(1, n+1):\n            tmp = tmp * i % p\n            l[i] = tmp\n        return l\ndef modcomb(n, k, fac_list = [], p = MOD):\n    # fac_list = modfactorial_list(100)\n    # print(modcomb(100, 5, modfactorial_list(100)))\n    from math import factorial\n    if n < 0 or k < 0 or n < k: return 0\n    if n == 0 or k == 0: return 1\n    if len(fac_list) <= n:\n        a = factorial(n) % p\n        b = factorial(k) % p\n        c = factorial(n-k) % p\n    else:\n        a = fac_list[n]\n        b = fac_list[k]\n        c = fac_list[n-k]\n    return (a * modpow(b, p-2, p) * modpow(c, p-2, p)) % p\ndef modadd(a, b, p = MOD):\n    return (a + b) % MOD\ndef modsub(a, b, p = MOD):\n    return (a - b) % p\ndef modmul(a, b, p = MOD):\n    return ((a % p) * (b % p)) % p\ndef moddiv(a, b, p = MOD):\n    return modmul(a, modpow(b, p-2, p))\n\n# initialize variables and set inputs\n# initialize variables\n    # to initialize list, use [0] * n\n    # to initialize two dimentional array, use [[0] * N for _ in range(N)]\n# set inputs\n    # open(0).read() is a convenient method:\n    # ex) n, m, *x = map(int, open(0).read().split())\n    #     min(x[::2]) - max(x[1::2])\n    # ex2) *x, = map(int, open(0).read().split())\n    #     don't forget to add comma after *x if only one variable is used\n# preprocessing\n    # transpose = [x for x in zip(*data)]\n    # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n# calculate and output\n    # output pattern\n    # ex1) print(*l) => when l = [2, 5, 6], printed 2 5 6\n\n# functions used\nr = lambda: sys.stdin.readline().strip()\nr_int = lambda: int(r())\nR = lambda: list(map(int, r().split()))\nRfloat = lambda: list(map(float, r().split()))\nRtuple = lambda: tuple(map(int, r().split()))\nRmap = lambda: list(map(int, r().split()))\n# single int: int(r())\n# single string: r()\n# single float: float(r())\n# line int: R()\n# line string: r().split()\n# line (str, int, int): [j if i == 0 else int(j) for i, j in enumerate(r().split())]\n# lines int: [R() for _ in range(n)]\n\n# set inputs\n# sys.stdin = open('sample.txt') # for test\nN = r_int()\nDic = defaultdict(list)\nV = 10**5 + 5\nArrived = [False] * (2 * V)\nfor _ in range(N):\n    x, y = R()\n    y += V\n    Dic[x].append(y)\n    Dic[y].append(x)\n\nans = 0\ntask = []\nfor k, v in list(Dic.items()):\n    if Arrived[k]:\n        continue\n    Arrived[k] = True\n    cntx = 0\n    cnty = 0\n    if k < V:\n        cntx += 1\n    else:\n        cnty += 1\n    cntdot = 0\n    task.extend(v)\n    cntdot += len(v)\n    while task:\n        s = task.pop()\n        if Arrived[s]:\n            continue\n        if s < V:\n            cntx += 1\n        else:\n            cnty += 1\n        Arrived[s] = True\n        task.extend(Dic[s])\n        cntdot += len(Dic[s])\n    ans += cntx * cnty - cntdot // 2\nprint(ans)\n\n# def __starting_point():\n#     main()\n\n__starting_point()", "class UnionFind:\n    def __init__(self, n):\n        self.v = [-1 for _ in range(n)]\n\n    def find(self, x):\n        if self.v[x] < 0:  # (\u8ca0)\u306f\u6839\n            return x\n        else:\n            self.v[x] = self.find(self.v[x])\n            return self.v[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if -self.v[x] < -self.v[y]:\n            x, y = y, x\n        self.v[x] += self.v[y]\n        self.v[y] = x\n\n    def root(self, x):\n        return self.v[x] < 0\n\n    def size(self, x):\n        return -self.v[self.find(x)]\n\n\nmx = 10 ** 5 + 10\n\nn = int(input())\n\nuf = UnionFind(mx * 2)\n\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    uf.unite(x, y + mx)\n\nvx = [0] * (mx * 2)\nvy = [0] * (mx * 2)\n\nfor i in range(mx):\n    root = uf.find(i)\n    vx[root] += 1\n\nfor i in range(mx, mx * 2):\n    root = uf.find(i)\n    vy[root] += 1\n\nans = -n\nfor xx, yy in zip(vx, vy):\n    ans += xx * yy\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**5)\nv = 100005\nvisited = [False]*(2*v)\ncount = [0, 0]\n\ndef dfs(a):\n    visited[a] = True\n    count[a//v] += 1\n    for i in vertex[a]:\n        if not visited[i]:\n            dfs(i)\n\ninput = sys.stdin.readline\nN = int(input())\nvertex = [[] for _ in range(v*2)]\nfor _ in range(N):\n    x, y=map(int, input().split())\n    y += v\n    vertex[x].append(y)\n    vertex[y].append(x)\n\nans = 0\nfor i in range(v):\n    if not visited[i]:\n        count = [0, 0]\n        dfs(i)\n        ans += count[0]*count[1]\n\nprint(ans-N)", "import sys\nsys.setrecursionlimit(100000)\n\nn = int(input())\nxy = [list(map(int, input().split())) for _ in range(n)]\nxtoy = {}\nytox = {}\nfor x, y in xy:\n    if x not in xtoy:\n        xtoy[x] = [y]\n    else:\n        xtoy[x].append(y)\n    if y not in ytox:\n        ytox[y] = [x]\n    else:\n        ytox[y].append(x)\n\ndef doit(x, xs, ys, xtoy, ytox):\n    ret = 0\n    if x in xtoy:\n        xs.add(x)\n        yl = xtoy.pop(x)\n        ret += len(yl)\n        for y in yl:\n            ret += doit(y, ys, xs, ytox, xtoy)\n    return ret\n\nret = 0\nwhile len(xtoy) > 0:\n    x = next(iter(xtoy))\n    xs = set()\n    ys = set()\n    num = doit(x, xs, ys, xtoy, ytox)\n    ret += len(xs) * len(ys) - num // 2\n\nprint(ret)", "class UnionFind():\n    def __init__(self,size):\n        self.table=[-1]*size\n    def root(self,x):\n        while self.table[x]>=0:\n            x=self.table[x]\n        return x\n    def unite(self,x,y):\n        s1=self.root(x)\n        s2=self.root(y)\n        if s1!=s2:\n            if self.table[s1]>self.table[s2]:\n                s1,s2=s2,s1\n            self.table[s1]+=self.table[s2]\n            self.table[s2]=s1\n        return\n    def same(self,x,y):\n        return self.root(x)==self.root(y)\n    def size(self,x):\n        return -self.table[self.root(x)]\nn,*z=map(int,open(0).read().split())\nu=UnionFind(10**5*2+1)\nfor x,y in zip(*[iter(z)]*2):\n    u.unite(x,10**5+y)\nd=[[0,set(),set()]for _ in range(10**5*2+1)]\nfor x,y in zip(*[iter(z)]*2):\n    t=d[u.root(x)]\n    t[0]+=1\n    t[1].add(x)\n    t[2].add(y)\nprint(sum(len(x)*len(y)-a for a,x,y in d))"]
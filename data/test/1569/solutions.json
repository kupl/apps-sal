["f = lambda: map(int, input().split())\ng = lambda: (a.i, b.i) if a.i < b.i else (b.i, a.i)\n\nclass T:\n    def __init__(t, i):\n        t.i = i\n        t.s = t.v = t.u = 0\n        t.p = []\n\nn, m = f()\nt = [T(i) for i in range(n + 1)]\nd, l = [], []\nfor k in range(m):\n    i, j, q = f()\n    a, b = t[i], t[j]\n    a.p.append(b)\n    b.p.append(a)\n    if q: d += [g()]\nd = set(d)\nx, y = [], []\na = t[1]\na.u = 1\nwhile a.i < n:\n    for b in a.p:\n        v = a.v + (g() in d)\n        if not b.u or b.u > a.u and v > b.v: b.v, b.s = v, a.i\n        if not b.u:\n            b.u = a.u + 1\n            y.append(b.i)\n    if not x:\n        x, y = y, x\n        x.reverse()\n    a = t[x.pop()]\nwhile a.i > 1:\n    b = t[a.s]\n    a.p.remove(b)\n    b.p.remove(a)\n    if g() in d: d.remove(g())\n    else: l += [(a.i, b.i)]\n    a = b\nprint(len(l) + len(d))\nfor a, b in l: print(a, b, 1)\nfor a, b in d: print(a, b, 0)", "f = lambda: map(int, input().split())\ng = lambda: (a.i, b.i) if a.i < b.i else (b.i, a.i)\n\nclass T:\n    def __init__(t, i):\n        t.i = i\n        t.s = t.v = t.u = 0\n        t.p = set()\n\nn, m = f()\nt = [T(i) for i in range(n + 1)]\nd, l = [], []\nfor k in range(m):\n    i, j, q = f()\n    a, b = t[i], t[j]\n    a.p.add(b)\n    b.p.add(a)\n    if q: d += [g()]\nd = set(d)\n\nx, y = [], []\na = t[1]\na.u = 1\nwhile a.i < n:\n    for b in a.p:\n        v = a.v + (g() in d)\n        if not b.u or b.u > a.u and v > b.v: b.v, b.s = v, a.i\n        if not b.u:\n            b.u = a.u + 1\n            y.append(b.i)\n    if not x:\n        x, y = y, x\n        x.reverse()\n    a = t[x.pop()]\n\nwhile a.i > 1:\n    b = t[a.s]\n    a.p.remove(b)\n    b.p.remove(a)\n    if g() in d: d.remove(g())\n    else: l += [(a.i, b.i)]\n    a = b\n\nprint(len(l) + len(d))\nfor a, b in l: print(a, b, 1)\nfor a, b in d: print(a, b, 0)", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))\n", "import collections\nimport heapq\ndef __starting_point():\n    n, m = [int(x) for x in input().split()]\n    G = collections.defaultdict(list)\n    road = []\n    for i in range(m):\n        s, e, f = [int(x) for x in input().split()]\n        road.append((s, e, f))\n        G[s].append((e, f))\n        G[e].append((s, f))\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            dis, cost, p = heapq.heappop(hq)\n            if d[p] < (dis, cost): continue\n            for e, f in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    ans = []\n    for s, e, f in road:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            ans.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            ans.append((s, e, 0))\n    print(k)\n    for s, e, f in ans:\n        print(s, e, f)\n\n__starting_point()"]
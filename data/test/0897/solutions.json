["n, m = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nmult = 1\nmod = 10 ** 9 + 7\nres = 0\n\nm_inv = pow(m, mod - 2, mod)\n\nfor x, y in zip(a, b):\n    if x and y:\n        if x > y:\n            res += mult\n            res %= mod\n            break\n        elif x == y:\n            continue\n        else:\n            break\n    elif x:\n        res += mult * (x-1) * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\n    elif y:\n        res += mult * (m - y) * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\n    else:\n        res += mult * m * (m - 1) // 2 * m_inv * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\nprint(res)\n", "import sys, math\n\n#f = open('input/input_2', 'r')\nf = sys.stdin\n\ndef modInverse(a, m) :\n    g = gcd(a, m)\n    if (g != 1) :\n        return None\n    else:\n        return  power(a, m - 2, m)\n\n# To compute x^y under modulo m\ndef power(x, y, m) :\n    if (y == 0) :\n        return 1\n    p = power(x, y // 2, m) ** 2\n    if (y & 1 == 1):\n      p *= x\n    return (p % m)\n\n# Function to return gcd of a and b\ndef gcd(a, b) :\n    while (a != 0):\n      t = b % a\n      b = a\n      a = t\n    return b\n\nn, m = list(map(int, f.readline().split()))\ns1 = list(map(int, f.readline().split()))\ns2 = list(map(int, f.readline().split()))\n\n#0 same, 1 big\npos = [1, 0]\nall_pos = 1\nfor a1, a2 in zip(s1, s2):\n  next_pos = [0, 0]\n  if a1 == 0 and a2 == 0:\n    next_pos[0] += pos[0] * m\n    next_pos[1] += pos[0] * m * (m-1) // 2\n    next_pos[1] += pos[1] * m * m\n\n    all_pos *= m*m\n  elif a1 == 0:\n    next_pos[0] += pos[0]\n    next_pos[1] += pos[0] * (m - a2)\n    next_pos[1] += pos[1] * m\n\n    all_pos *= m\n  elif a2 == 0:\n    next_pos[0] += pos[0]\n    next_pos[1] += pos[0] * (a1 - 1)\n    next_pos[1] += pos[1] * m\n\n    all_pos *= m\n  else:\n    if a1 > a2:\n      next_pos[1] += pos[0]\n    elif a1 == a2:\n      next_pos[0] += pos[0]\n    next_pos[1] += pos[1]\n  pos = next_pos\n  if pos[0] == 0:\n    break\n  g = gcd(pos[0], all_pos)\n  g = gcd(pos[1], g)\n  pos[0] //= g\n  pos[1] //= g\n  all_pos //= g\n  pos[0] %= 1000000007\n  pos[1] %= 1000000007\n  all_pos %= 1000000007\n\np = pos[1]\nq = all_pos\npq_gcd = gcd(p,q)\np //= pq_gcd\nq //= pq_gcd\n\nq_inv = modInverse(q, 1000000007)\nprint( (p * q_inv) % 1000000007)\n", "def rev(a, m):\n    res = 1\n    k = m-2\n    s = a\n    while k > 0:\n        if k%2 == 1:\n            res = (res * s) % m\n        k //= 2\n        s = (s**2) % m\n    return res\n\nn, m = [int(x) for x in input().split()]\na1 = [int(x) for x in input().split()]\na2 = [int(x) for x in input().split()]\na = []\nmul = 1\nfor x,y in zip(a1, a2):\n    if x == 0 and y == 0:\n        count = (m*(m-1))//2\n        counteq = m\n        maxcount = m**2\n    elif x == 0:\n        count = m - y\n        counteq = 1\n        maxcount = m\n    elif y == 0:\n        count = x-1\n        counteq = 1\n        maxcount = m\n    else:\n        count = 1 if x>y else 0\n        counteq = 1 if x==y else 0\n        maxcount = 1\n\n    a.append((count, counteq, maxcount))\n    if counteq == 0: break\na.reverse()\n\n##print(a)\n\nP, Q = 0, 1\nfor c, ce, mc in a:\n    P = (P*ce+ Q*c) % (10**9+7)\n    Q = (Q*mc)  % (10**9+7)\n  \n\nres, zeros = P, Q\nprint((res * rev(zeros, 10**9+7)) % (10**9+7))\n", "\np=10**9+7\n\nn,m=input().split()\nn=int(n)\nm=int(m)\n\na=input().split()\nb=input().split()\n\na=[int(k) for k in a]\nb=[int(k) for k in b]\n\ninvm=pow(m,p-2,p)\ninv2=pow(2,p-2,p)\n\nans=0\n\nfor i in reversed(range(n)):\n\tif a[i]==0 and b[i]==0:\n\t\tans=(((inv2*invm)%p)*(m-1)+invm*ans)%p\n\tif a[i]==0 and b[i]!=0:\n\t\tans= ((m-b[i])*invm+invm*ans)%p\n\tif a[i]!=0 and b[i]==0:\n\t\tans= ((a[i]-1)*invm+invm*ans)%p\n\tif a[i]!=0 and b[i]!=0:\n\t\tif a[i]>b[i]:\n\t\t\tans= 1\n\t\telif b[i]>a[i]:\n\t\t\tans= 0\n\t\telse:\n\t\t\tans= ans\n\nprint(ans)", "n, m = [int(x) for x in input().split()]\ns1 = [int(x) for x in input().split()]\ns2 = [int(x) for x in input().split()]\nmod = int(1e9 + 7)\n\ne = 1\nmi = pow(m, mod - 2, mod)\nmi2 = pow(2 * m, mod - 2, mod)\nres = 0\n\nfor i in range(n):\n    if s1[i] == 0 and s2[i] != 0:\n        res += ((((m - s2[i]) * mi) % mod) * e) %mod\n        e = (e * mi) % mod\n    elif s1[i] != 0 and s2[i] == 0:\n        res += ((((s1[i] - 1) * mi) % mod) * e) %mod\n        e = (e * mi) % mod\n    elif s1[i] == 0 and s2[i] == 0:\n        res += ((((m - 1)* mi2) % mod) * e)%mod\n        e = (e * mi) % mod\n    else:\n        if s1[i] > s2[i]:\n            res += e\n            break\n        if s1[i] < s2[i]:\n            break\n    res = res % mod\nprint(res%mod)\n", "MOD = 10**9 + 7\nn,m = [int(x) for x in input().split()]\ns1 = [int(x) for x in input().split()]\ns2 = [int(x) for x in input().split()]\n\nmi = pow(m, MOD - 2, MOD)\nm2 = pow(2, MOD - 2, MOD)\nans = 0\nmul = 1\nfor a,b in zip(s1, s2):\n\tif a == 0 and b == 0:\n\t\tans = (ans + mul * ((m - 1)*(mi * m2))) % MOD\n\t\tmul = (mul * mi) % MOD\n\telif a == 0:\n\t\tans = (ans + (mul * (m - b) * mi)) % MOD\n\t\tmul = (mul * mi) % MOD\n\telif b == 0:\n\t\tans = (ans + mul * (a - 1) * mi) % MOD\n\t\tmul = (mul * mi) % MOD\n\telif a > b:\n\t\tans = (ans + mul * 1) %  MOD\n\t\tbreak\n\telif a == b:\n\t\tpass\n\telif a < b:\n\t\tbreak\nprint(ans % MOD)", "def fast(a,b):\n    if(b==0):\n        return 1 \n    if(b%2==1):\n        return a*fast(a,b-1)%mod \n    x=fast(a,b/2)%mod\n    return x*x%mod\nn,m=map(int,input().split())\na=list(map(int,(input().split())))\nb=list(map(int,(input().split())))\np=0\nq=1\nz1=1\nz2=1\nmod=1000000007\nfor i in range(0,n):\n    if(a[i]!=0 and b[i]!=0):\n        if(a[i]==b[i]):continue\n        if(a[i]>b[i]):\n            p=(p*z2%mod+q*z1%mod)%mod   \n            q=(q*z2)%mod\n        break\n    if(a[i]==0 and b[i]!=0):\n        p=((p*m*z2)%mod+(z1*q*(m-b[i]))%mod)%mod\n        q=(q*z2*m)%mod\n        z2=(z2*m)%mod\n    if(a[i]!=0 and b[i]==0):\n        p=((p*m*z2)%mod+(z1*q*(a[i]-1))%mod)%mod\n        q=(q*z2*m)%mod\n        z2=(z2*m)%mod\n    if(a[i]==0 and b[i]==0):\n        p=(p*m*2*z2+z1*(q)*(m-1))%mod\n        q=(q*z2*2*m)%mod\n        z2=(z2*m)%mod\nprint(p*(fast(q,(mod-2))%mod)%mod)", "n, m = list(map(int, input().split()))\ns1 = list(map(int, input().split()))\ns2 = list(map(int, input().split()))\n\nMOD = 10**9 + 7\np, q = 0, 1\nfor i in reversed(list(range(n))):\n\tif s1[i] == 0 and s2[i] == 0:\n\t\tp = (q * (m - 1) + 2 * p) % MOD\n\t\tq = (2 * m * q) % MOD\n\telif s1[i] == 0:\n\t\tp = (q * (m - s2[i]) + p) % MOD\n\t\tq = (m * q) % MOD\n\telif s2[i] == 0:\n\t\tp = (q * (s1[i] - 1) + p) % MOD\n\t\tq = (m * q) % MOD\n\telif s1[i] < s2[i]:\n\t\t\tp, q = 0, 1\n\telif s1[i] > s2[i]:\n\t\t\tp, q = 1, 1\n\ndef mpow(a, n):\n\tif n == 0:\n\t\treturn 1\n\tt = mpow(a, n // 2)\n\tt = (t * t) % MOD\n\tif n % 2 == 1:\n\t\tt = (t * a) % MOD\n\treturn t\n\ninv_q = mpow(q, MOD - 2)\nr = (p * inv_q) % MOD\n\nprint(r)\n", "n, m = list(map(int, input().split()))\ns1 = list(map(int, input().split()))\ns2 = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\ninvm = pow(m, MOD - 2, MOD)\ninv2 = pow(2, MOD - 2, MOD)\n\nz = 0\np = 1\n\nfor a, b in zip(s1, s2):\n    if a == 0 and b == 0:\n        z = (z + p * ((m - 1) * (invm * inv2))) % MOD\n        p = (p * invm) % MOD\n    elif a == 0:\n        z = (z + (p * (m - b) * invm)) % MOD\n        p = (p * invm) % MOD\n    elif b == 0:\n        z = (z + (p * (a - 1) * invm)) % MOD\n        p = (p * invm) % MOD\n    elif a > b:\n        z = (z + p) % MOD\n        break\n    elif a < b:\n        break\nprint(z)\n", "from math import gcd\n\np = 10 ** 9 + 7\n\n\nclass RN:\n    p = 10 ** 9 + 7\n\n    def __init__(self, u, d):\n        self.u = u\n        self.d = d\n\n    def __str__(self):\n        return str(self.u) + '/' + str(self.d)\n\n    def cleanup(self):\n        self.u = self.u % p\n        self.d = self.d % p\n\n\n    def add(self, u, d):\n        self.u = self.u * d + u * self.d\n        self.d = self.d * d\n        self.cleanup()\n\n\n    def mult(self, u, d):\n\n        return (self.u * u)%p, (self.d * d)%p\n\n    def mult_ip(self, u, d):\n        # r.cleanup()\n        self.u, self.d = self.u * u, (self.d * d) % p\n\n\n    def get_m_exp(self):\n        self.cleanup()\n        a = gcd(self.u, self.d)\n        self.u //= a\n        self.d //= a\n\n        # print(str(self))\n        return ((pow(self.d, p - 2, p)) * self.u) % p\n\n\nn, m = tuple(map(int, input().split()))\ns1 = list(map(int, input().split()))\ns2 = list(map(int, input().split()))\n\n\ndef sum_ch(n):\n    return ((n + 1) * n) // 2\n\n\ndef sol(s1, s2, m):\n    strgr = RN(0, 1)\n\n    eq = RN(1, 1)\n    for gr, sm, i in zip(s1, s2, list(range(len(s1)))):\n\n        strgr.cleanup()\n\n\n        if gr != 0 and sm != 0:\n\n            if gr == sm:\n                continue\n            elif gr < sm:\n                return strgr.get_m_exp()\n            else:\n                strgr.add(eq.u, eq.d)\n                return strgr.get_m_exp()\n        else:\n            if gr == sm == 0:\n                strgr.add(*eq.mult(sum_ch(m - 1), m * m))\n\n            elif gr == 0:\n                strgr.add(*eq.mult(m - sm, m))\n\n            else:\n                strgr.add(*eq.mult(gr - 1, m))\n            eq.mult_ip(1, m)\n    return strgr.get_m_exp()\n\n\n'''\na = sol([0,0],[1,1], 2) # 3/4\n\na = sol([0,0,0],[1,1,1], 2) # 7/8\na = sol([0,1,1],[1,1,1], 2) # 1/2\na = sol([1,0,1],[1,1,1], 2) # 1/2\n\na = sol([0,0,0],[1,3,3], 3) # 2/2\na = sol([0,0,0],[1,1,0], 2) # 5/8\na = sol([0,0,0],[0,0,0], 2) # 13/16\n'''\n\nprint(sol(s1, s2, m))\n", "n, m = list(map(int, input().split(\" \")))\ns1 = list(map(int, input().split(\" \")))\ns2 = list(map(int, input().split(\" \")))\n\nN = 10 ** 9 + 7\nres = True\ninv = pow(m, N - 2, N)\ncur = 1\nresult = 0\ninv_2 = pow(2, N - 2, N)\n\nfor i in range(n):\n\tif s1[i] == 0 and s2[i] == 0:\n\t\tresult = (result + cur * inv_2  * (N + 1 - inv)) % N\n\t\tcur = (cur * inv) % N \n\t\tcontinue\n\n\tif s1[i] == 0:\n\t\tcur = (cur * inv) % N \n\t\tresult = (result + (m - s2[i]) * cur) % N\n\t\tcontinue\n\n\tif s2[i] == 0:\n\t\tcur = (cur * inv) % N\n\t\tresult = (result + (s1[i] - 1) * cur) % N\n\t\tcontinue\n\n\tif s1[i] < s2[i]:\n\t\tbreak\n\n\tif s1[i] > s2[i]:\n\t\tresult = (result + cur) % N\n\t\tbreak\n\nprint(result % N)\n", "MOD = 1000000007\n\nn, m = map(int, input().split())\nl1 = [int(x) for x in input().split()]\nl2 = [int(x) for x in input().split()]\n\nprobLeft = 1 # probability that I'm continuing\n\ndef modInv(x, n = MOD - 2):\n    if n <= 1:\n        return (x ** n) % MOD\n    tmp = (modInv(x, n // 2) ** 2) % MOD\n    if n % 2 == 1:\n        tmp = tmp * x % MOD\n    return tmp\n\ndp = {}\n\ndef fraction(x,y):\n    if (x,y) in dp:\n        return dp[(x,y)]\n    dp[(x,y)] = x * modInv(y) % MOD\n    return dp[(x,y)]\n\nminv = fraction(1, m)\n\nans = 0\nfor i in range(n):\n    a = l1[i]\n    b = l2[i]\n    if a == 0 or b == 0:\n        if b > 0:\n            ans += probLeft * (m - b) * minv % MOD\n        elif a > 0:\n            ans += probLeft * (a - 1) * minv % MOD\n        else:\n            ans += probLeft * ((m - 1) * m // 2) * minv * minv % MOD\n        probLeft = probLeft * minv % MOD\n    elif a > b:\n        ans += probLeft\n        break\n    elif a == b:\n        continue\n    else:\n        break\n\nprint(ans % MOD)", "def f():\n    nonlocal MOD, ans, factor\n    ans %= MOD\n    factor %= MOD\n\nMOD = 10**9 + 7\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nreverse = pow(m, MOD - 2, MOD)\nreverse_for_2 = (MOD + 1) // 2\nans = 0\nfactor = 1\nfor a, b in zip(a, b):\n    if (a == b == 0):\n        ans += factor * ((m - 1) * (reverse * reverse_for_2))\n        factor *= reverse\n        f()\n    elif (a == 0):\n        ans += factor * (m - b) * reverse\n        factor *= reverse\n        f()\n    elif (b == 0):\n        ans += factor * (a - 1) * reverse\n        factor *= reverse\n        f()\n    elif (a > b):\n        ans += factor\n        f()\n        break\n    elif (a == b):\n        pass\n    elif (a < b):\n        break\nf()\nprint(ans)", "rd = lambda: list(map(int, input().split()))\nM = 1000000007\ninv = lambda x: (M - M // x) * inv(M % x) % M if x - 1 else 1\nn, m = rd()\na = list(rd())\nb = list(rd())\ni = 0\np, q, r = 0, 1, 1\nwhile i < n:\n    x, y = a[i], b[i]\n    if x == 0 and y == 0:\n        p = (p * m * m + r * ((m - 1) * m >> 1)) % M\n        q = q * m * m % M\n        r = r * m % M\n    elif x == 0:\n        p = (p * m + r * (m - y)) % M\n        q = q * m % M\n    elif y == 0:\n        p = (p * m + r * (x - 1)) % M\n        q = q * m % M\n    else:\n        if x == y:\n            pass\n        else:\n            if x > y:\n                p = (p + r) % M\n            break\n    i += 1\nprint(p * inv(q) % M)\n", "rd = lambda: list(map(int, input().split()))\nM = 1000000007\ninv = lambda x: (M - M // x) * inv(M % x) % M if x - 1 else 1\nn, m = rd()\na = list(rd())\nb = list(rd())\np, q, r = 0, 1, 1\nfor i in range(n):\n    x, y = a[i], b[i]\n    if x == 0 and y == 0:\n        p = (p * m * m + r * ((m - 1) * m >> 1)) % M\n        q = q * m * m % M\n        r = r * m % M\n    elif x == 0:\n        p = (p * m + r * (m - y)) % M\n        q = q * m % M\n    elif y == 0:\n        p = (p * m + r * (x - 1)) % M\n        q = q * m % M\n    elif x != y:\n        if x > y:\n            p = (p + r) % M\n        break\nprint(p * inv(q) % M)\n", "from fractions import gcd;\n\ndef add(a,b,c,d):\n\tlcm =(b*d)//(gcd(b,d));\n\taa = lcm//b;\n\tbb = lcm//d;\n\t#print(\"aa:\",aa,\"bb:\",bb,\"a:\",a,\"b:\",b);\n\taa = aa*a;\n\tbb = bb*c;\n\t#print(\"aa:\",aa,\"bb:\",bb);\n\tcc = aa+bb;\n\tdd = gcd(lcm,cc);\n\t#print(\"cc:\",cc);\n\t#print(\"lcm:\",lcm);\n\tlcm = lcm//dd;\n\tcc = cc //dd;\n\t#print(\"cc:\",cc);\n\t#print(\"lcm:\",lcm);\n\treturn cc,lcm;\n\ndef mul(a,b,c,d):\n\taa = a*c;\n\tbb = b*d;\n\tdd = gcd(aa,bb);\n\taa = aa//dd;\n\tbb = bb//dd;\n\n\treturn aa,bb;\n\ndef eeuclid(a,b):\n\tq = a//b;\n\tr = a % b;\n\n\tif r == 1:\n\t\treturn 1,-q;\n\n\ta,b = eeuclid(b,r);\n\tm = 1;\n\tn = -q;\n\tm = m * b;\n\tn = n * b;\n\tn = n + a;\n\n\n\treturn m,n;\n\ndef mod_inverse(val,m):\n\ta,b = eeuclid(val,m);\n\treturn a % m;\n\nn,m = input().split();\nn = int(n);\nm = int(m);\nmod_val = 1000000007;\narr1 = [];\narr2 = [];\n\narr1 = [int(x) for x in input().split()];\narr2 = [int(x) for x in input().split()];\n\n\nnum = [];\nden = [];\nprob = [];\n\nfor i in range(0,n):\n\tnum.append(0);\n\tden.append(0);\n\tprob.append(0);\nnum.append(0);\nden.append(1);\nprob.append(0);\n\nfor i in range(n-1,-1,-1):\n\tif(arr1[i] != 0 and arr2[i] != 0):\n\t\tif(arr1[i] > arr2[i]):\n\t\t\tprob[i] = 1;\n\t\telif(arr1[i] == arr2[i]):\n\t\t\tif(prob[i+1] == 0):\n\t\t\t\tprob[i] = 0;\n\t\t\telse:\n\t\t\t\tprob[i] = prob[i+1];\n\t\telif(arr1[i] < arr2[i]):\n\t\t\tprob[i] = 0;\n\t\n\telif(arr1[i] == 0 and arr2[i] != 0):\n\t\tnum1 = m-arr2[i];\n\t\tinv1 = mod_inverse(m,mod_val);\n\t\tinv1 = inv1 % mod_val;\n\t\tqq = ((num1 % mod_val) * (inv1 % mod_val)) % mod_val;\n\n\t\tpp = inv1 * prob[i+1];\n\n\t\tprob[i] = (qq + pp) % mod_val;\n\n\telif(arr1[i] != 0 and arr2[i] == 0):\n\t\tnum1 = arr1[i]-1;\n\t\tinv1 = mod_inverse(m,mod_val);\n\n\t\tqq = ((num1 % mod_val) * (inv1 % mod_val)) % mod_val;\n\n\t\tpp = inv1 * prob[i+1];\n\t\tprob[i] = (qq + pp) % mod_val;\n\telse:\n\t\taa = (m * (m-1))//2;\n\t\taa = aa % mod_val;\n\n\t\tinv2 = mod_inverse(m*m,mod_val);\n\t\tinv1 = mod_inverse(m,mod_val);\n\n\t\tqq = (aa * inv2) % mod_val;\n\t\tpp = (inv1 * prob[i+1]) % mod_val;\n\n\t\tprob[i] = (pp + qq) % mod_val;\n\nprint((prob[0]));\n\n\n\n\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nMOD = int(1e9 + 7)\nm2 = pow(2, MOD - 2, MOD)\nmm = pow(m, MOD - 2, MOD)\nf = 1\nans = 0\nfor i, j in zip(a, b):\n    if i == 0 and j == 0:\n        ans += (m - 1) * m2 * mm * f\n        ans %= MOD\n        f = f * mm % MOD\n    elif i == 0:\n        ans += (m - j) * f * mm\n        ans %= MOD\n        f = f * mm % MOD\n    elif j == 0:\n        ans += (i - 1) * f * mm\n        ans %= MOD\n        f = f * mm % MOD\n    elif i > j:\n        ans += f\n        ans %= MOD\n        break\n    elif i < j:\n        break\n\nprint(ans)", "# a and m must be coprime!\n# returns x such that xa = 1 mod m\ndef modinverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n\n    if m == 1:\n        return 0\n\n    while a > 1:\n        q = a // m\n        t = m\n\n        m = a % m\n        a = t\n        t = y\n\n        y = x - q * y\n        x = t\n\n    if x < 0:\n        x += m0\n    \n    return x\n# runs in log(m)\n\nM = (10 ** 9) + 7\n\nline = [int(x) for x in input().split()]\n\nn = line[0]\nm = line[1]\n\nMi = modinverse(m, M)\nTi = modinverse(2, M)\n\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nPkp1 = 0\nPk = 0\n\nif a[-1] == 0 and b[-1] == 0:\n    Pkp1 = ((m-1) % M) * Mi * Ti\nelif a[-1] == 0:\n    Pkp1 = ((m-b[-1]) % M) * Mi\nelif b[-1] == 0:\n    Pkp1 = ((a[-1]-1) % M) * Mi\nelse:\n    if a[-1] > b[-1]:\n        Pkp1 = 1\n    else:\n        Pkp1 = 0\n\nPk = Pkp1\n\nfor i in range(1, n):\n    j = n - (i + 1)\n    \n    if a[j] == 0 and b[j] == 0:\n        Pk = ((2*Pkp1+m-1) % M) * Mi * Ti\n    elif a[j] == 0:\n        Pk = ((m-b[j]+Pkp1) % M) * Mi\n    elif b[j] == 0:\n        Pk = ((Pkp1+a[j]-1) % M) * Mi\n    else:\n        if a[j] > b[j]:\n            Pk = 1\n        elif a[j] < b[j]:\n            Pk = 0\n        else:\n            Pk = Pkp1\n\n    Pkp1 = Pk\n\nprint(Pk % M)\n", "import sys\n\nMOD = 1000000007\n\ndef solve(io):\n  N = io.readInt()\n  M = io.readInt()\n  S = io.readIntArray(N)\n  T = io.readIntArray(N)\n  \n  P = 0\n  Q = 1\n  A = 1\n  B = 1\n  for i in range(0, N):\n    if S[i] == 0 or T[i] == 0:\n      if S[i] == 0 and T[i] == 0:\n        gtTop = M * (M - 1) * A\n        gtBot = 2 * M * M * B\n        eqTop = 1\n        eqBot = M\n      elif S[i] == 0:\n        gtTop = (M - T[i]) * A\n        gtBot = M * B\n        eqTop = 1\n        eqBot = M\n      elif T[i] == 0:\n        gtTop = (S[i] - 1) * A\n        gtBot = M * B\n        eqTop = 1\n        eqBot = M\n    elif S[i] > T[i]:\n      gtTop = A\n      gtBot = B\n      eqTop = 0\n      eqBot = 1\n    elif S[i] < T[i]:\n      gtTop = 0\n      gtBot = 1\n      eqTop = 0\n      eqBot = 1\n    elif S[i] == T[i]:\n      gtTop = 0\n      gtBot = 1\n      eqTop = 1\n      eqBot = 1\n    P, Q = P * gtBot + gtTop * Q, Q * gtBot\n    P %= MOD\n    Q %= MOD\n    A = (A * eqTop) % MOD\n    B = (B * eqBot) % MOD\n    if S[i] != 0 and T[i] != 0 and S[i] != T[i]:\n      break\n  io.println((P * modinv(Q, MOD)) % MOD)\n\ndef extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n \ndef modinv(a, m):\n\tg, x, _ = extended_gcd(a, m)\n\tif g != 1:\n\t\traise ValueError\n\treturn x % m\n\n# +---------------------+\n# | TEMPLATE CODE BELOW |\n# |    DO NOT MODIFY    |\n# +---------------------+\n\n# TODO: maybe reading byte-by-byte is faster than reading and parsing tokens.\nclass IO:\n  input = None\n  output = None\n  raw = \"\"\n  buf = []\n  pos = 0\n  \n  def __init__(self, inputStream, outputStream):\n    self.input = inputStream\n    self.output = outputStream\n  \n  def readToBuffer(self):\n    self.raw = self.input.readline().rstrip('\\n')\n    self.buf = self.raw.split()\n    self.pos = 0\n  \n  def readString(self):\n    while self.pos == len(self.buf):\n      self.readToBuffer()\n    ans = self.buf[self.pos]\n    self.pos += 1\n    return ans\n  \n  def readInt(self):\n    return int(self.readString())\n  \n  def readFloat(self):\n    return float(self.readString())\n  \n  def readStringArray(self, N, offset = 0):\n    arr = [ None ] * offset\n    for _ in range(0, N):\n      arr.append(self.readString())\n    return arr\n  \n  def readIntArray(self, N, offset = 0):\n    arr = [ None ] * offset\n    for _ in range(0, N):\n      arr.append(self.readInt())\n    return arr\n  \n  def readFloatArray(self, N, offset = 0):\n    arr = [ None ] * offset\n    for _ in range(0, N):\n      arr.append(self.readFloat())\n    return arr\n  \n  def readLine(self):\n    while self.pos == len(self.buf):\n      self.readToBuffer()\n    if self.pos > 0:\n      raise ValueError(\"Cannot call readline in the middle of a line.\")\n    return self.raw\n  \n  def print(self, s):\n    self.output.write(str(s))\n  \n  def println(self, s):\n    self.print(s)\n    self.print('\\n')\n  \n  def flushOutput(self):\n    self.output.flush()\n\npythonIO = IO(sys.stdin, sys.stdout)\nsolve(pythonIO)\npythonIO.flushOutput()\n", "mod = 1000000007\ndef pow(a,b,c):\n    n = 1\n    m = a\n    v = b\n    if a == 1:\n        return 1\n    while v > 0:\n        if v%2 == 1:\n            n *= m%c\n            n %= c\n        m *= m\n        m %= c\n        v //= 2\n    return n%c\n\nn,m = map(int, input().split())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nz = [0 for i in range(n+10)]\n\nfor i in range(n)[::-1]:\n    z[i] = z[i+1]\n    if a[i] == 0:\n        z[i] += 1\n    if b[i] == 0:\n        z[i] += 1\nans = 0\ncmb = 1\n\nif z[0] == 0:\n    if a > b:\n        print(1)\n    else:\n        print(0)\n    quit()\ninverse_two = pow(2,mod-2,mod)\ncom = (m*(m-1))%mod*inverse_two%mod\nfor i in range(n):\n    if a[i] != 0 and b[i] != 0:\n        if a[i] > b[i]:\n            ans += cmb*pow(m,z[i+1],mod)%mod\n        break\n    elif a[i] == 0 and b[i] == 0:\n        ans += (cmb*com)%mod*pow(m,z[i+1],mod)%mod\n        cmb *= m\n        cmb %= mod\n    elif a[i] == 0:\n        ans += (cmb*(m-b[i]))%mod*pow(m,z[i+1],mod)%mod\n    elif b[i] == 0:\n        ans += (cmb*(a[i]-1))%mod*pow(m,z[i+1],mod)%mod\n    ans %= mod\n\nk = pow(m,z[0],mod)\nk = pow(k,mod-2,mod)\nans *= k\nans %= mod\nprint(ans)", "mod = 1000000007\ndef pow(a,b,c):\n    n = 1\n    m = a\n    v = b\n    if a == 1:\n        return 1\n    while v > 0:\n        if v%2 == 1:\n            n *= m%c\n            n %= c\n        m *= m\n        m %= c\n        v //= 2\n    return n%c\n\nn,m = map(int, input().split())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nz = [0 for i in range(n+10)]\n\nfor i in range(n)[::-1]:\n    z[i] = z[i+1]\n    if a[i] == 0:\n        z[i] += 1\n    if b[i] == 0:\n        z[i] += 1\nans = 0\ncmb = 1\n\nif z[0] == 0:\n    if a > b:\n        print(1)\n    else:\n        print(0)\n    quit()\ninverse_two = pow(2,mod-2,mod)\ncom = (m*(m-1))%mod*inverse_two%mod\nfor i in range(n):\n    if a[i] != 0 and b[i] != 0:\n        if a[i] > b[i]:\n            ans += cmb*pow(m,z[i+1],mod)%mod\n        break\n    elif a[i] == 0 and b[i] == 0:\n        ans += (cmb*com)%mod*pow(m,z[i+1],mod)%mod\n        cmb *= m\n        cmb %= mod\n    elif a[i] == 0:\n        ans += (cmb*(m-b[i]))%mod*pow(m,z[i+1],mod)%mod\n    elif b[i] == 0:\n        ans += (cmb*(a[i]-1))%mod*pow(m,z[i+1],mod)%mod\n    ans %= mod\n\nk = pow(m,z[0],mod)\nk = pow(k,mod-2,mod)\nans *= k\nans %= mod\nprint(ans)", "def _pow(a, d, md):\n    res = 1\n    a = a % md\n    while d > 0:\n        if d&1: res = res * a % md\n        d >>= 1\n        a = a*a % md\n    return res\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmod = 1000000007\np = 1\nq = 1\ndp = [[0 for i in range(n + 1)] for j in range(2)]\nbase = 1\ndp[0][-1] = 1\ndp[1][-1] = 0\nfor i in range(0, n):\n    if a[i] == 0 and b[i] != 0:\n        dp[0][i] = dp[0][i - 1] % mod\n        dp[1][i] = (dp[1][i - 1] * m + dp[0][i - 1]*(m - b[i])) % mod\n        base *= m\n        base %= mod\n    elif a[i] != 0 and b[i] == 0:\n        dp[0][i] = dp[0][i - 1] % mod\n        dp[1][i] = (dp[1][i - 1] * m + dp[0][i - 1] * (a[i] - 1)) % mod\n        base *= m\n        base %= mod\n    elif a[i] == 0 and b[i] == 0:\n        dp[0][i] = dp[0][i - 1] * m % mod\n        dp[1][i] = (dp[1][i - 1] * m * m) % mod\n        dp[1][i] += (dp[0][i - 1] * (m - 1) * m // 2) % mod\n        base *= m * m\n        base %= mod\n    elif a[i] != 0 and b[i] != 0:\n        if a[i] != b[i]:\n            dp[0][i] = 0\n            dp[1][i] = dp[1][i - 1] % mod\n            if a[i] > b[i]:\n                dp[1][i] += dp[0][i - 1] % mod\n        else:\n            dp[0][i] = dp[0][i - 1] % mod\n            dp[1][i] = dp[1][i - 1] % mod\n    #print(dp[0][i], dp[1][i])        \n\np = dp[1][n - 1]\nq = base\np %= mod\nq %= mod\nq = _pow(q, mod - 2, mod)\nprint(p*q % mod)", "def _pow(a, d, md):\n    res = 1\n    a = a % md\n    while d > 0:\n        if d&1: res = res * a % md\n        d >>= 1\n        a = a*a % md\n    return res\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmod = 1000000007\np = 1\nq = 1\ndp = [[0 for i in range(n + 1)] for j in range(2)]\nbase = 1\ndp[0][-1] = 1\ndp[1][-1] = 0\nfor i in range(0, n):\n    if a[i] == 0 and b[i] != 0:\n        dp[0][i] = dp[0][i - 1] % mod\n        dp[1][i] = (dp[1][i - 1] * m + dp[0][i - 1]*(m - b[i])) % mod\n        base *= m\n        base %= mod\n    elif a[i] != 0 and b[i] == 0:\n        dp[0][i] = dp[0][i - 1] % mod\n        dp[1][i] = (dp[1][i - 1] * m + dp[0][i - 1] * (a[i] - 1)) % mod\n        base *= m\n        base %= mod\n    elif a[i] == 0 and b[i] == 0:\n        dp[0][i] = dp[0][i - 1] * m % mod\n        dp[1][i] = (dp[1][i - 1] * m * m) % mod\n        dp[1][i] += (dp[0][i - 1] * (m - 1) * m // 2) % mod\n        base *= m * m\n        base %= mod\n    elif a[i] != 0 and b[i] != 0:\n        if a[i] != b[i]:\n            dp[0][i] = 0\n            dp[1][i] = dp[1][i - 1] % mod\n            if a[i] > b[i]:\n                dp[1][i] += dp[0][i - 1] % mod\n        else:\n            dp[0][i] = dp[0][i - 1] % mod\n            dp[1][i] = dp[1][i - 1] % mod\n    #print(dp[0][i], dp[1][i])        \n\np = dp[1][n - 1]\nq = base\np %= mod\nq %= mod\nq = _pow(q, mod - 2, mod)\nprint(p*q % mod)", "\n\nc_mod = 1000000007\n\ndef InverseMod(b: int, m: int):\n    b %= m\n    if b == 0 or b == 1: return b\n\n    a = m\n    qs = []\n    while True:\n        q = a // b\n        r = a % b\n        if (r == 0): break\n        a = b\n        b = r\n        qs.append(q)\n\n    qA = 1\n    qB = -qs[len(qs) - 1]\n    for i in range(len(qs) - 2, -1, -1):\n        t = qA\n        qA = qB\n        qB = qB*(-qs[i]) + t\n    \n    qB %= m\n    if qB < 0: \n        qB = m + qB\n    return qB\n\ndef save_mul(a, b):\n    return (a * b) % c_mod\n\n\nclass Fraction:\n    def __init__(self, a: int, b: int, dBase: int, dPow: int):\n        self.a, self.b, self.dBase, self.dPow = a, b, dBase, dPow\n    \n    def __add__(self, other):\n        f = Fraction(self.a, self.b, self.dBase, self.dPow)\n        if f.dPow > other.dPow:\n            f.a += other.a * (f.dBase ** (f.dPow - other.dPow))\n            f.a %= c_mod\n        elif f.dPow < other.dPow:\n            f.a = f.a * (f.dBase ** (other.dPow - f.dPow)) + other.a\n            f.b = other.b\n            f.dPow = other.dPow\n            f.a %= c_mod\n        else:\n            f.a += other.a\n            f.a %= c_mod\n        return f\n    \n    def __mul__(self, other):\n        f = Fraction(self.a, self.b, self.dBase, self.dPow)\n        f.a *= other.a\n        f.b *= other.b\n        f.dPow += other.dPow\n        f.a %= c_mod\n        f.b %= c_mod\n        return f\n    \n    def __str__(self):\n        return \"{0}/{1}\".format(self.a, self.b)\n\n\n\ndef main():\n    '''f1 = Fraction(6, 5)\n    f2 = Fraction(5, 5)\n    f1.dPow = 2\n    f1.b = 25\n    print(f1 + f2)\n    print(f1)'''\n\n    s = str(input()).split()\n    n, m = int(s[0]), int(s[1])\n    s1 = str(input()).split()\n    s2 = str(input()).split()\n    r = Fraction(0, 1, m, 0)\n    k = Fraction(1, 1, m, 0)\n\n    for i in range(n):\n        u = int(s1[i])\n        d = int(s2[i])\n        if u == 0 and d == 0:\n            f = Fraction(int(m * (m - 1) / 2), m * m, m, 2)\n            f = f * k\n            r = r + f\n            k.b = save_mul(k.b, m)\n            k.dPow += 1\n            continue\n        elif u == 0:\n            f = Fraction(m - d, m, m, 1)\n            f = f * k\n            r = r + f\n            k.b = save_mul(k.b, m)\n            k.dPow += 1\n            continue\n        elif d == 0:\n            f = Fraction(u - 1, m, m, 1)\n            f = f * k\n            r = r + f\n            k.b = save_mul(k.b, m)\n            k.dPow += 1\n            continue\n        \n        if u > d:\n            r = r + k\n\n        if u != d: break\n    \n    print(save_mul(r.a, InverseMod(r.b, c_mod)))\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\nmod = 10**9 + 7\ndef invmod(x, mod):\n    return pow(x, mod-2, mod)\n\nn, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\ndp = [0] * (n+1)\nfor i in range(n-1, -1, -1):\n    if a[i] == 0 and b[i] == 0:\n        sp, sq = m * m, m\n        tp, tq = m * m, m * (m-1) // 2\n    elif a[i] == 0:\n        sp, sq = m, 1\n        tp, tq = m, m - b[i]\n    elif b[i] == 0:\n        sp, sq = m, 1\n        tp, tq = m, a[i] - 1\n    else:\n        sp, sq = 1, 1 if a[i] == b[i] else 0\n        tp, tq = 1, 1 if a[i] > b[i] else 0\n    dp[i] = sq * invmod(sp, mod) * dp[i + 1]\n    dp[i] += tq * invmod(tp, mod)\n    dp[i] %= mod\nans = dp[0]\nprint(ans)"]
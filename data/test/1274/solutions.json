["import sys, math\nfrom functools import lru_cache\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\nsys.setrecursionlimit(10**9)\nMOD = 10**9+7\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return list(map(int, input().split()))\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\n\ndef lcm(a, b):\n    return a*b//math.gcd(a, b)\n\n\ndef main():\n    N, M = mi()\n    A, B = i2(N)\n    ans = 0\n\n    d = defaultdict(list)\n    for i in range(N):\n        d[A[i]].append(B[i])\n\n    h = []\n    heapq.heapify(h)\n\n    for i in range(1, M+1):\n        for v in d[i]:\n            heapq.heappush(h, -v)\n        if h:\n            ans -= heapq.heappop(h)\n        else:\n            continue\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport heapq\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\n\nN, M = inl()\n\n\nclass MinHeap(object):\n    def __init__(self):\n        self.h = []\n\n    def push(self, x):\n        heapq.heappush(self.h, x)\n\n    def pop(self):\n        return heapq.heappop(self.h)\n\n    def __getitem__(self, i):\n        return self.h[i]\n\n    def __len__(self):\n        return len(self.h)\n\n    def __bool__(self):\n        return bool(self.h)\n\n\nclass MaxHeap(MinHeap):\n    class Negator(object):\n        def __init__(self, val):\n            self.val = val\n\n        def __lt__(self, other):\n            return self.val > other.val\n\n        def __eq__(self, other):\n            return self.val == other.val\n\n        def __str__(self):\n            return str(self.val)\n\n    def push(self, x):\n        heapq.heappush(self.h, self.Negator(x))\n\n    def pop(self):\n        return heapq.heappop(self.h).val\n\n\ndef solve():\n    jobs = []\n    for i in range(N):\n        a, b = inl()\n        jobs.append((a, b))\n    jobs.sort()\n\n    hp = MaxHeap()\n    ans = 0\n    j = 0\n    for d in range(1, M + 1):\n        while j < N and jobs[j][0] == d:\n            a, b = jobs[j]\n            hp.push(b)\n            j += 1\n        if hp:\n            ans += hp.pop()\n    return ans\n\n\nprint((solve()))\n", "import sys\nfrom heapq import heappush, heappop\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    AB = [[] for _ in range(m)]\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        if a <= m:\n            AB[m - a].append(b)\n\n    que = []\n    res = 0\n    for i in reversed(list(range(m))):\n        for b in AB[i]:\n            heappush(que, -b)\n        if que:\n            res += heappop(que) * -1\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import heapq\n\nn,m = map(int, input().split())\nab = [[] * (m+1) for i in range(m+1)]\nfor i in range(n):\n  a,b = map(int, input().split())\n  if m - a < 0:\n    continue\n  ab[a].append(b)\n\nq=[]\nans = 0\nheapq.heapify(q)\nfor i in range(1,m+1):\n  for j in ab[i]:\n    heapq.heappush(q, j*(-1))\n  if q:\n    b = heapq.heappop(q)\n    ans += (-1) * b\nprint(ans)", "import sys\nimport heapq\ndef input(): return sys.stdin.readline().rstrip()\n \ndef main():\n    n,m=map(int, input().split())\n    li=[]\n    for _ in range(n):\n        b,a=map(int, input().split())\n        if m-b >= 0:\n            li.append([a,m-b])\n    li.sort(key=lambda x: x[1])\n    h=[]\n    for i in li:\n        if len(h) >= i[1]+1:\n            heapq.heappushpop(h, i[0])\n        else:\n            heapq.heappush(h, i[0])\n    print(sum(h))\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import*\n(N, M), *t = [map(int, s.split()) for s in open(0)]\nv = [[] for _ in [None] * 10**5]\nfor a, b in t:\n    v[a - 1] += b,\nz = 0\nq = []\nfor i in v[:M]:\n    for j in i:\n        heappush(q, -j)\n    if q:\n        z += -heappop(q)\nprint(z)", "import heapq\n\nN,M = list(map(int, input().split()))\n\n\nrinsetuList = [[] for _ in range(100001)]\n\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n    rinsetuList[A].append(B)\n\n#print(rinsetuList[:M+1])\n\nwork_list = []\nhpq = heapq.heapify(work_list)\n\nans = 0\nfor rinsetu in rinsetuList[:M+1]:\n    for money in rinsetu:\n        heapq.heappush(work_list, money * (-1))\n    if(len(work_list) != 0):\n        ans += heapq.heappop(work_list) * (-1)\n\n#    print(ans)\n#    print(work_list)\n\nprint(ans)", "import heapq\nN, M = map(int, input().split())\n\njobs = [[] for _ in range(M)]\nfor _ in range(N):\n    A, B = map(int, input().split())\n    if A > M:\n        continue\n    jobs[A-1].append(-B)\n\ntotal = 0\nheap = []\nfor i in range(M):\n    for job in jobs[i]:\n        heapq.heappush(heap, job)\n\n    if len(heap) == 0:\n        continue\n    else:\n        total += -heapq.heappop(heap)\n\nprint(total)", "import heapq\n\nn, m = map(int, input().split())\nab = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x: (-x[0], x[1]))\n\nq = []\nans = 0\nfor i in range(1, m+1):\n    while ab and ab[-1][0] == i:\n        a, b = ab.pop()\n        heapq.heappush(q, -b)\n    if q:\n        ans -= heapq.heappop(q)\nprint(ans)", "from heapq import *\nN,M = map(int,input().split())\nL = [[] for m in range(M)]\nH = []\nans = 0\n\nfor n in range(N):\n  a,b = map(int,input().split())\n  if a<=M:\n    L[M-a]+=[b]\n    \nfor m in range(M-1,-1,-1):\n  for l in L[m][::-1]:\n    heappush(H,-l)\n  if 0<len(H):\n    ans-=heappop(H)\n\nprint(ans)", "def insertHeap(array, val):\n    array.append(val)\n    n = len(array)-1\n    while n != 0:\n        parent = int((n - 1) / 2)\n        if array[n] > array[parent]:\n            tmp = array[n]\n            array[n] = array[parent]\n            array[parent] = tmp\n            n = parent\n        else:\n            break\n    return array\n\ndef desertHeap(array):\n    if array == []:\n      return None\n    array[0], array[-1] = array[-1], array[0]\n    res = array.pop(-1)\n    n = len(array)\n    if n == 0 or n == 1: \n      return res\n    parent = 0\n    while True:\n        child = 2 * parent + 1\n        if child >= n: break\n        if (child + 1 < n) and array[child] < array[child + 1]:\n            child += 1\n        if array[parent] < array[child]:\n            array[child], array[parent] = array[parent], array[child]\n            parent = child;\n        else:\n            break\n    return res\n\nn, m = map(int, input().split())\n \nli = [[] for j in range(10**5+1)]\n \nfor _ in range(n):\n  a, b = map(int, input().split())\n  li[a].append(b)\n \nans = 0\njobsHeap = []\nfor i in range(1, m+1):\n  for val in li[i]:\n    jobsHeap = insertHeap(jobsHeap, val)\n  \n  if jobsHeap != []:\n    res = desertHeap(jobsHeap)\n    ans += res\nprint(ans)", "N,M = list(map(int,input().split()))\nAB = [list(map(int,input().split())) for _ in range(N)]\n\nAB.sort(key= lambda x:(-x[1],-x[0]))#\u5831\u916c\u304c\u9ad8\u304f\u3001\u304b\u3064\u3001\u632f\u308a\u8fbc\u307f\u306e\u65e5\u6570\u304c\u9577\u3044\u3082\u306e\u304b\u3089\u3084\u308b\u305f\u3081\u306e\u30bd\u30fc\u30c8\nmemo = [0]*(10**5+1)#\u8acb\u3051\u8ca0\u3046\u3068\u6c7a\u3081\u305f\u4ed5\u4e8b\u306e\u65e5\u306e\u30e1\u30e2\u30021\u304c\u3064\u3044\u3066\u3044\u308b\u65e5\u306f\u4ed5\u4e8b\u304c\u3059\u3067\u306b\u3042\u308b\nwork = [float('inf')]*(10**5+1)#\u632f\u308a\u8fbc\u307f\u307e\u3067\u306b\u5fc5\u8981\u306a\u65e5\u6570\u306e\u3046\u3061\u3001\u524d\u56de\u8acb\u3051\u8ca0\u3044\u3092\u6c7a\u3081\u305f\u65e5\nnoMore = float('inf') #\u3053\u308c\u4ee5\u4e0a\u306e\u65e5\u6570\u304c\u632f\u308a\u8fbc\u307f\u306b\u304b\u304b\u308b\u4ed5\u4e8b\u306f\u53d7\u3051\u308c\u306a\u3044\nans = 0\nfor a,b in AB:\n    if a< noMore:#\u671f\u65e5\u307e\u3067\u306b\u5831\u916c\u304c\u53d7\u3051\u53d6\u308c\u308b\u4ed5\u4e8b\u3067\u3042\u308b\u3053\u3068\n        flag = 1\n        for idx in range(min(M-a,work[a]),-1,-1):#\u3053\u306e\u691c\u7d22\u7bc4\u56f2\u306e\u7d5e\u308a\u8fbc\u307f\u304cTLE\u89e3\u6d88\u306e\u6c7a\u3081\u624b\u3002\u524d\u56de\u691c\u7d22\u6642\u306b\u8acb\u3051\u8ca0\u3063\u305f\u65e5\u307e\u305f\u306fM-a\u65e5\u4ee5\u524d\u306e\u65e5\n            if memo[idx] == 0:#\u4ed5\u4e8b\u304c\u8acb\u3051\u3089\u308c\u308b\n                ans += b#\u5831\u916c\u3092\u8db3\u3059\n                memo[idx]=1#\u4ed5\u4e8b\u3092\u53d7\u3051\u305f\u3053\u3068\u306e\u8a18\u9332\u3002\u3053\u306e\u65e5\u306f\u3082\u3046\u53d7\u3051\u3089\u308c\u306a\u3044\n                flag = 0#noMore\u306e\u66f4\u65b0\u5206\u5c90\u306e\u305f\u3081\n                work[a] = idx#\u6b21\u56de\u691c\u7d22\u6642\u306e\u30e1\u30e2\n                break\n        if flag ==1:#\u8acb\u3051\u308c\u308b\u65e5\u304c\u898b\u3064\u304b\u3089\u306a\u3051\u308c\u3070\u3001\u4eca\u5f8c\u3053\u306e\u65e5\u6570\u4ee5\u4e0a\u306e\u65e5\u306f\u53d7\u3051\u308c\u306a\u3044\u306e\u3067\u8abf\u3079\u306a\u3044\n            noMore = a\n    \nprint(ans)\n    \n", "from heapq import heapify, heappop, heappush\nfrom collections import deque\nN,M=list(map(int,input().split()))\nA=[0]*N #\u30e9\u30b0\nB=[0]*N #\u5831\u916c\nC=[0]*N\nfor i in range(N):\n    A[i],B[i]= list(map(int,input().split()))\n    C[i]=[A[i],B[i]]\nC.sort()\nD=deque(C)\nreward=0\n#print(D)\n\nh=[]\nheapify(h)\n\nfor i in range(M-1,-1,-1):   \n    while D:\n        e = D.popleft()\n        if e[0]==M-i:\n            heappush(h,-1*e[1])\n        else:\n            D.appendleft(e)\n            break\n    #print(h)\n    if h:\n        reward += (-1)*heappop(h)\n        \nprint(reward)\n", "import heapq\nn, m = map(int, input().split())\nd = [[] for _ in range(m)]\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a <= m:\n        d[a-1].append(-b)\n\nt = []\nheapq.heapify(t)\nans = 0\nfor i in range(m):\n    for dd in d[i]:\n        heapq.heappush(t, dd)\n    if t:\n        ans += heapq.heappop(t)*(-1)\nprint(ans)", "import heapq\n\nn, m = map(int, input().split())\nx = [[] for _ in range(m + 1)]\ny = []\nheapq.heapify(y)\nfor i in range(1, m + 1):\n    heapq.heapify(x[i])\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a <= m:\n        heapq.heappush(x[a], -b)\nans = 0\nfor i in range(1, m + 1):\n    if x[i]:\n        s = heapq.heappop(x[i])\n        heapq.heappush(y, [s, i])\n    if y:\n        s, t = heapq.heappop(y)\n        ans -= s\n        if x[t]:\n            s = heapq.heappop(x[t])\n            heapq.heappush(y, [s, t])\nprint(ans)", "import heapq\n\nn, m = map(int, input().split())\nab = sorted([list(map(int, input().split())) for _ in range(n)], reverse=True)\n\nc = []\nans = 0\nfor i in range(m):\n    while len(ab) != 0 and ab[-1][0] <= i+1:\n        _, b = ab.pop()\n        heapq.heappush(c, -b)\n    if c:\n        ans += -heapq.heappop(c)\nprint(ans)", "n, m = map(int, input().split())\nab = [[] for _ in range(m+1)]\nfor i in range(n):\n  t = [int(inp) for inp in input().split()]\n  if t[0] <= m:\n    ab[t[0]].append(-t[1])\nans = 0\nimport heapq\nh = ab[1]\nheapq.heapify(h)\nfor i in range(1, m+1):\n  if len(h) > 0:\n    ans += heapq.heappop(h)\n  if i != m:\n    for t in ab[i+1]:\n      heapq.heappush(h, t)\nprint(-ans)", "from heapq import heappop, heappush \nN, M = list(map(int, input().split()))\nscore = 0\nAB = [[] for i in range(M)]\nfor i in range(N):\n  a, b = list(map(int, input().split()))\n  if M - a >= 0:\n    AB[M - a].append(b)\n  \n#print(AB)\nqueue = []\nfor i in range(1, M + 1):\n  for j in AB[-i]:\n    heappush(queue, -j)\n  if queue != []:\n    score += -1 * heappop(queue)\n  \n  #print(score, queue)  \nprint(score)  \n  \n  \n\n\n", "from heapq import *\nn,m=map(int,input().split())\nab=[]\nans=[[] for i in range(m)]\naa=0\nfor i in range(n):\n    a,b=map(int,input().split())\n    a-=1\n    b*=-1\n    ab.append((a,b))\nab.sort()\nt=[]\nheapify(t)\nfor a,b in ab:\n    if a<m:\n        ans[a].append(b)\nfor i in range(m):\n    for j in ans[i]:\n        heappush(t,j)\n    if len(t)>0:\n        tt=heappop(t)*(-1)\n        aa+=tt\nprint(aa)", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    from heapq import heappush, heappop\n\n    N, M = list(map(int, input().split()))\n    AB = [ [] for _ in range(100000) ]\n\n    for _ in range(N):\n        a, b = list(map(int, input().split()))\n        AB[a-1].append(-b)\n\n    ans = 0\n    heap = []\n    for a in range(M):\n        for b in AB[a]:\n            heappush(heap, b)\n        if heap:\n            ans -= heappop(heap)\n    \n    print(ans)\n\nmain()\n", "import heapq\n\nn, m = map(int, input().split())\nA = [[] for _ in range(m)]\nans = 0\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    if m-a < 0:\n        continue\n    else:\n        A[m-a].append(b)\n\navailable = []\n\nfor i in range(m-1, -1, -1):\n    for item in A[i]:\n        heapq.heappush(available, -item)\n    if available:\n        ans += -heapq.heappop(available)\n\nprint(ans)", "import heapq\nn,m = map(int,input().split())\nal = [[] for i in range(10**5)]\nans = 0\nh = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    al[a-1] += [-b]\nfor i in range(m):\n    for j in al[i]:\n        heapq.heappush(h,j)\n    if h:\n        ans -= heapq.heappop(h)\nprint(ans)", "import heapq\nn,m= map(int,input().split())\nfeeindays = [[] for _ in range(m)]\nfor i in range(n):\n    a,b= map(int,input().split())\n    if a<=m:feeindays[a-1]+=[b]\nq=[]\nheapq.heapify(q)\npay=0\nfor l in feeindays:\n    for c in l:heapq.heappush(q,-c)\n    if len(q)!=0:pay+=-1 * heapq.heappop(q)\nprint(pay)", "n,m = map(int,input().split())\nab = [0]*n\nV = [[] for i in range(m+1)]\nfor i in range(n):\n    a,b = map(int,input().split())\n    if a <= m:\n        V[a].append(-b)\n\nimport heapq\nq = []\nans = 0\nheapq.heapify(q)\nfor i in range(1,m+1):\n    for v in V[i]:\n        heapq.heappush(q,v)\n\n    if len(q) == 0:\n        pass\n    else:\n        ans -= heapq.heappop(q)\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n \nN,M = map(int,readline().split())\nfrom collections import defaultdict\ntasks = defaultdict(list)\nfor i in range(N):\n  a,b = map(int,readline().split())\n  tasks[a].append(b)\n  \nimport heapq as hq\nq = []\nans = 0\nfor i in range(1, M + 1):\n  newtask = tasks[i]\n  for t in newtask:\n    hq.heappush(q,-t)\n  if q:\n    ans += -hq.heappop(q)\n \nprint(ans)", "#!/usr/bin/env python3\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\n\ndef main():\n    N, M = list(map(int, input().split()))\n    AB = [[] for _ in range(10**5)]\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        AB[a-1].append(b)\n    \n    q = []\n    ans = 0\n    i = 0\n    while i < M:\n        for ab in AB[i]:\n            heappush(q,-ab)\n        if q:\n            ans -= heappop(q)\n        i += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn, m = list(map(int, input().split())) \n\nd = [[] for _ in range(m+1)]\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if a < m+1:\n        d[a].append(b)\n\nhq = []\nheapq.heapify(hq)\nans = 0\nfor i in range(1, m+1): \n    if len(d[i]) > 0:\n        for j in d[i]:\n            heapq.heappush(hq, j*(-1))\n    if len(hq) > 0:\n        ans += heapq.heappop(hq)*(-1)\nprint(ans)\n", "from heapq import heappush,heappop\n\nn,m=[int(x) for x in input().rstrip().split()]\nab=[[] for i in range(10**5)]\n\nfor i in range(n):\n  a,b=[int(x) for x in input().rstrip().split()]\n  if a<=m:\n    ab[m-a].append(-b)\n\nans=0\nl=[]\nfor i in range(m-1,-1,-1):\n  for b in ab[i]:\n    heappush(l,b)\n\n  if l:\n    ans-=heappop(l)\n\nprint(ans)\n", "import heapq\n\nn, m = map(int,input().split())\nab = [[0] * 2 for i in range(n)]\nfor i in range(n):\n    a, b = map(int,input().split())\n    ab[i][0], ab[i][1] = a, -1*b\nheapq.heapify(ab)\n\nb = [0]\nheapq.heapify(b)\nans = 0\nfor i in range(1, m+1):\n    while ab:\n        tmp = heapq.heappop(ab)\n        if tmp[0] <= i:\n            heapq.heappush(b, tmp[1])    \n        else:\n            heapq.heappush(ab, tmp)\n            break\n    if b:\n        ans -= heapq.heappop(b)\nprint(ans)", "import heapq\n\nN, M = list(map(int, input().split()))\n\nAB = []\ncan = [[] for i in range(M+1)]\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    AB.append([a, b])\n    if M - a >= 0:\n        can[M-a].append(-b)\n\nque = []\nans = 0\nfor i in range(M, -1, -1):\n    now_list = can[i]\n    for j in range(len(now_list)):\n        heapq.heappush(que, now_list[j])\n    if que:\n        ans += heapq.heappop(que)\n\nprint((-ans))\n", "import sys\nfrom heapq import heappush, heappop\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    B = [[] for _ in range(m)]\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        if m - a >= 0:\n            B[m - a].append(b)\n\n    que = []\n    res = 0\n    for i in reversed(list(range(m))):\n        for b in B[i]:\n            heappush(que, -b)\n        if que:\n            res += heappop(que) * (-1)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nfrom heapq import heappop, heappush\n\ninput = sys.stdin.readline\n\n\ndef main():\n    MAX_A = 10 ** 5\n    N, M = list(map(int, input().split()))\n    AB = [[] for _ in range(MAX_A + 1)]\n    for i in range(N):\n        A, B = list(map(int, input().split()))\n        AB[A].append(-B)\n\n    p_queue = []\n    ans = 0\n    for m in range(1, M + 1):\n        for b in AB[m]:\n            heappush(p_queue, b)\n        if p_queue:\n            x = heappop(p_queue)\n            x *= -1\n            ans += x\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def resolve():    \n    import heapq\n    n,m=map(int,input().split())\n    ab=[list(map(int,input().split())) for _ in range(n)]\n    b=[[] for _ in range(10**5+1)]\n    for i,j in ab:\n        b[i].append(-j)\n    q=[]\n    ans=0\n    for i in range(1,m+1):\n        for j in b[i]:\n            heapq.heappush(q,j)\n        if q:\n            ans+=heapq.heappop(q)\n    print(-ans)\n        \ndef __starting_point():\n    resolve()\n__starting_point()", "import heapq\nfrom collections import defaultdict\n\nn, m = list(map(int, input().split()))\n\ncnt = defaultdict(list)\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    cnt[a].append(b)\n\nt = []\nheapq.heapify(t)\nans = 0\nfor i in range(1, m+1):\n    for j in cnt[i]:\n        heapq.heappush(t, -j)\n    if t: ans -= heapq.heappop(t)\n\nprint(ans)\n", "import heapq\n\nfrom typing import List\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    v = []\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        v.append((a, b))\n\n    print((sv(v, k)))\n\n\ndef sv(v: List[List[int]], k: int) -> int:\n    vv = {}\n    for a, b in v:\n        if str(a) in vv:\n            vv[str(a)].append(b)\n        else:\n            vv[str(a)] = []\n            vv[str(a)].append(b)\n\n    hp = []\n    result = 0\n    bk = 1\n    while k >= bk:\n        if str(bk) in vv:\n            for b in vv[str(bk)]:\n                heapq.heappush(hp, -b)\n        if len(hp) > 0:\n            result += -heapq.heappop(hp)\n        bk += 1\n\n    return result\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "_,m=map(int,input().split())\nwork=sorted([tuple(map(int,input().split()))for k in range(_)],key=lambda x:(-x[0],x[1]))\nfrom heapq import heapify, heappop, heappush\nnow=[]\n#print(work)\nans=0\nfor i in range(1,m+1):\n    while work and work[-1][0]<=i:\n        a,b=work.pop()\n        heappush(now,-b)\n        #print(a,b)\n    \n    if now:\n        ans-=heappop(now)\n    #print(i,ans)\nprint(ans)", "from heapq import*\n(N, M), *t = [map(int, s.split()) for s in open(0)]\nq = [0] * 10**5\nv = [[] for _ in q]\nfor a, b in t:\n    v[a - 1] += b,\nz = 0\nfor i in v[:M]:\n    for j in i:\n        heappush(q, -j)\n    z += -heappop(q)\nprint(z)", "#<D>\nfrom heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\nX = sorted([list(map(int, input().split())) for n in range(N)], key = lambda x: x[0])\n#print(X)\nhq = []\nans, j = 0, 0\n\nfor i in range(1, M + 1): #M - i\u65e5\u5f8c\u306b\u3059\u308b\u30d0\u30a4\u30c8\u3092\u6c7a\u3081\u308b\n    while (j < N) and (X[j][0] <= i):\n        heappush(hq, -X[j][1]) # \u5019\u88dc\u306e\u8ffd\u52a0\n        j += 1\n    if len(hq):\n        ans += - heappop(hq) #\u5019\u88dc\u304c\u3042\u308b\u306a\u3089\u5019\u88dc\u304b\u3089\u6700\u5927\u5024\u3092\u53d6\u308a\u51fa\u3059\nprint(ans)\n", "import heapq\n#\u89e3\u8aac\u306e\u65b9\u6cd5\nN,M = list(map(int,input().split()))\nAB = [[] for _ in range(10**5+1)]#\u5831\u916c\u632f\u308a\u8fbc\u307f\u65e5\u6570\u3054\u3068\u306b\u5831\u916c\u3092\u683c\u7d0d\nfor _ in range(N):\n    a,b = list(map(int,input().split()))\n    AB[a].append(-b)\nq = []\nheapq.heapify(q)\nans =0\nfor i in range(1,M+1):\n    for b in AB[i]:\n        heapq.heappush(q,b)\n    if len(q)>0:\n        ans += -heapq.heappop(q)\nprint(ans)\n\n", "import heapq\n\nn, m = map(int, input().split())\nab = []\nfor i in range(n):\n    ab.append(list(map(int, input().split())))\nab.sort()\nans = 0\nnum = 0\nqueue = []\nheapq.heapify(queue)\nfor i in range(1, m + 1):\n    if num < n:\n        while ab[num][0] <= i:\n            heapq.heappush(queue, [-ab[num][1], ab[num][0]])\n            num += 1\n            if num == n:\n                break\n    if len(queue):\n        temp = heapq.heappop(queue)\n        ans += -temp[0]\nprint(ans)", "import heapq\nN, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(N)]\n\nAB = sorted(AB, key=lambda x: x[0])\n\nx = 0\nres = 0\n\nhq = []\nheapq.heapify(hq)\n\nfor i in range(M):\n    for j in range(x, N):\n        if AB[j][0] > i+1:\n            x = j\n            break\n        heapq.heappush(hq, AB[j][1]*-1)\n    else:\n        x = N\n    \n    if hq:\n        res += heapq.heappop(hq)*-1\n\nprint(res)\n", "import heapq\nn , m = list(map(int, input().split()))\nab=[[] for i in range(10**5)]\n\nfor i in range(n):\n    a , b = list(map(int, input().split()))\n    ab[a-1].append(b*(-1))\n\nque=[]\nans = 0\nfor i in range(m):\n    for b in ab[i]:\n        heapq.heappush(que,b)\n    if que:\n        ans+=heapq.heappop(que)\nprint((ans*(-1)))\n", "#import math\n#import itertools\n#import numpy as np\nimport heapq\n#from collections import deque\n# sys.setrecursionlimit(10 ** 6)\n#mod = 10 ** 9 + 7\n#INF = 10 ** 9\n#PI = 3.14159265358979323846\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\ndef do():\n    n,m=INTM()\n    ptj=[[] for i in range(10**5)]\n    ans=0\n    for i in range(n):\n        a,b=INTM()\n        a-=1\n        b*=(-1)\n        ptj[a].append(b)\n    h=[]\n    for i in range(m):\n        for p in ptj[i]:\n            heapq.heappush(h,p)\n        if len(h)!=0:\n            ans+=heapq.heappop(h)\n        #print(ans)\n    print(0-ans)\n    \n\ndef __starting_point():\n    do()\n__starting_point()", "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    data = {}\n    priorityQ = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a <= m:\n            if a in data:\n                data[a].append(b)\n            else:\n                data[a] = [b]\n    ans = 0\n    for i in range(1, m+1):\n        if i in data.keys():\n            for k in data[i]:\n                heapq.heappush(priorityQ, -k)\n        if priorityQ:\n            ans -= heapq.heappop(priorityQ)\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nN,M=map(int,input().split())\nAB=[[]for i in range(10**5+1)]\nfor i in range(N):\n    a,b=map(int,input().split())\n    AB[a].append(-b)\nq=[]\nheapq.heapify(q)\nans=0\nfor i in range(1,M+1):\n    for b in AB[i]:\n        heapq.heappush(q,b)\n    if len(q)>0:\n        ans+=-heapq.heappop(q)\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nfrom collections import defaultdict\ntasks = defaultdict(list)\nfor i in range(N):\n  a,b = map(int,readline().split())\n  tasks[a].append(b)\n  \nimport heapq as hq\nq = []\nans = 0\nfor i in range(1, M + 1):\n  newtask = tasks[i]\n  for t in newtask:\n    hq.heappush(q,-t)\n  if q:\n    ans += -hq.heappop(q)\n\nprint(ans)", "from heapq import heappush,heappop\n\nn,m=[int(x) for x in input().rstrip().split()]\nab=[[] for i in range(10**5)]\n\nfor i in range(n):\n  a,b=[int(x) for x in input().rstrip().split()]\n  ab[a-1].append(-b)\n\nans=0\ntime=0\nl=[]\nfor i in range(m):\n  for b in ab[i]:\n    heappush(l,b)\n  if l:\n    ans-=heappop(l)\n\nprint(ans)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    AB = [LI() for _ in range(N)]\n\n    W = [[] for _ in range(M + 1)]\n    for a, b in AB:\n        if 0 <= M - a:\n            W[M-a].append(b)\n    # print(W)\n\n    # \u9078\u629e\u80a2\u306e\u5c11\u306a\u3044\u5f8c\u308d\u306e\u65e5\u4ed8\u304b\u3089\u6c7a\u3081\u3066\u3044\u304f\n    ans = 0\n    hq = []\n    for i in reversed(W):\n        for j in i:\n            heapq.heappush(hq, -j)\n        if hq:\n            ans -= heapq.heappop(hq)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from heapq import heapify,heappop,heappush\nn,m=map(int,input().split())\nl=[[]for i in range(10**5)]\nans=0\nfor i in range(n):a,b=map(int,input().split());l[a-1].append(-b)\nfor i in range(10**5):heapify(l[i])\np = []\nheapify(p)\nfor i in range(m):\n if len(l[i])!=0:heappush(p,[heappop(l[i]),i])\n if len(p)!=0:\n  x=heappop(p)\n  ans+=-x[0]\n  if len(l[x[1]])!=0:heappush(p,[heappop(l[x[1]]),x[1]])            \nprint(ans)", "import heapq\n\nn, m = map(int, input().split())\nque = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    que.append((-b, a))\nque.sort(key=lambda x: x[1], reverse=True)\n\ndef solve(que, m):\n    ans = 0\n    h = []\n    heapq.heapify(h)\n    for i in range(1, m + 1):\n        while len(que) != 0 and que[-1][1] <= i:\n            tmp = que.pop()\n            heapq.heappush(h, tmp)\n        if len(h) == 0: continue\n        tmp = heapq.heappop(h)\n        ans -= tmp[0]\n    return ans\n\nprint(solve(que, m))", "n,m=map(int,input().split())\nab=[list(map(int,input().split()))for _ in range(n)]+[[100000000,0]]\nfor i in range(m):ab.append([i+1,0])\nab.sort()\nfrom heapq import heappop,heappush\nh=[]\nj=0\nans=0\nfor i in range(1,m+1):\n  while ab[j][0]<=i:\n    heappush(h,-ab[j][1])\n    j+=1\n  ans-=heappop(h)\nprint(ans)", "import heapq\n\nN, M = list(map(int, input().split()))\nAB = [[] for i in range(10**5+1)]\n\nfor i in range(N):\n    A, B = list(map(int, input().split()))\n    AB[A].append(-B)\n\nhq = []\nheapq.heapify(hq)\n\nans = 0\nfor i in range(1, M+1):\n    for b in AB[i]:\n        heapq.heappush(hq, b)\n\n    if len(hq) > 0:\n        ans += -heapq.heappop(hq)\n\nprint(ans)\n", "from operator import itemgetter\nfrom collections import defaultdict\nimport heapq\n\nn,m = list(map(int,input().split()))\n\n\n\nd = defaultdict(list)\nfor i in range(n):\n  a,b = list(map(int,input().split()))\n  d[a].append(-b)\n# l = sorted(l, key=itemgetter(1))\n# l = l[::-1]\n# print(d)\nQ = []\nheapq.heapify(Q)\n\nans = 0\nfor i in range(1,m+1):\n    for j in d[i]:\n      heapq.heappush(Q,j)\n    \n    if Q:ans += -heapq.heappop(Q)\n    # print(ans,i)\nprint(ans)\n", "import heapq\nn,m=map(int,input().split())\nt=[[] for _ in range(m+1)]\nfor i in range(n):\n    a,b=map(int,input().split())\n    if a>m:\n        continue\n    t[a].append(b)\nans=0\nh=[]\nfor l in t:\n    for i in l:\n        heapq.heappush(h,-i)\n    if h:\n        ans-=heapq.heappop(h)\nprint(ans)", "from heapq import heappop,heappush\nfrom collections import defaultdict\n\nN, M = map(int, input().split())\nD = defaultdict(list)\n\nfor _ in range(N):\n  A, B = map(int, input().split())\n  D[A].append(B)\n\nH = []\nans = [0]*(M+1)\n\nfor i in range(1, M+1):\n  for j in D[i]:\n    heappush(H, -j)\n  if H:\n    a = heappop(H)\n    ans[i] = -a\n\nprint(sum(ans))", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\n#from decimal import *\n\nN, M = MAP()\nAB = [LIST() for _ in range(N)]\nAB.sort(key = lambda x: x[0])\n\nans = 0\ni = 0\nB = []\nfor j in range(1, M+1):\n\twhile i < N and AB[i][0] <= j:\n\t\theappush(B, -AB[i][1])\n\t\ti += 1\n\tif B:\n\t\tans += -heappop(B)\n\nprint(ans)\n", "import heapq\n\nN, M = map(int, input().split())\njobs = [[] for i in range(M)]\n\nfor i in range(N):\n    A, B = map(int, input().split())\n    if A - 1 < M:\n        jobs[A-1].append(B)\n\nq = []\nheapq.heapify(q)\nans = 0\nfor i in range(M):\n    for j in jobs[i]:\n        heapq.heappush(q, -j)\n    if len(q) != 0:\n        ans += -heapq.heappop(q)\n\nprint(ans)", "N,K=list(map(int,input().split()))\nl=[]\nfor i in range(N):\n   l.append(list(map(int,input().split())))\nl.sort()\nimport heapq\nX=[]\nS=0\nans=0\nheapq.heapify(X)\nfor i in range(1,K+1):\n   for j in range(S,N):\n      if l[j][0]<=i:\n         S+=1\n         heapq.heappush(X,l[j][1]*-1)\n      else:\n         break\n   try:\n      tmp=heapq.heappop(X)\n      ans+=tmp*-1\n   except IndexError:\n      continue\nprint(ans)", "import heapq\nn, m = map(int, input().split())\nlimit = [[] for i in range(m)]\nfor i in range(n):\n    a, b = map(int, input().split())\n    if a > m:\n        # \u9593\u306b\u5408\u308f\u306a\u3044\u306e\u3067\u4f7f\u3048\u306a\u3044        \n        continue\n    # m-a\u65e5\u76ee\u307e\u3067\u306b\u53d6\u308a\u639b\u304b\u308c\u3070\u9593\u306b\u5408\u3046\u30d0\u30a4\u30c8\u3092\u683c\u7d0d\n    limit[m-a].append(b)\n\navailable = []\nans = 0\nfor i in range(m-1, -1, -1):\n    # \u6700\u7d42\u65e5\u304b\u3089\u8fbf\u308b\u3053\u3068\u3067\u3001\u65b0\u305f\u306b\u9078\u629e\u4e0d\u53ef\u3068\u306a\u308b\u30d0\u30a4\u30c8\u304c\u751f\u3058\u306a\u3044\n    for item in limit[i]:\n        heapq.heappush(available, -item)\n    if available:\n        ans += -heapq.heappop(available)\nprint(ans)", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\nclass SegmentTree:\n    \"\"\"Segment Tree class.\n\n    Args:\n        N (int): Number of elements\n        X (list[int]): List for initialization\n        func (callable): Function for interval.\n        init_v (int): Initial value that does not affect `func`.\n            For example, specify INF when `func = min`.\n\n    References:\n        <https://en.wikipedia.org/wiki/Segment_tree>\n    \"\"\"\n    def __init__(self, N, X, func, init_v):\n        N_ = 1\n        while N_ < N: N_ *= 2\n        self.N = N_\n        self.func = func\n        self.init_v = init_v\n        self.__build(X)\n\n    def __build(self, X):\n        # Initialize all nodes\n        self.node = [[self.init_v, -1] for _ in range(2 * self.N)]  # 1-based index\n\n        # Elementary intervals are stored\n        for i, x in enumerate(X, self.N):\n            self.node[i] = [x, i - self.N + 1]\n\n        # The internal nodes correspond to intervals that are the union of elementary intervals\n        for i in range(self.N - 1, 0, -1):\n            self.node[i] = self.func(self.node[i << 1], self.node[i << 1 | 1])\n\n    def update(self, i, x):\n        \"\"\"Update the i-th node value to x.\n\n        Args:\n            i (int): index (1-based index)\n            x (int): udpate value\n        \"\"\"\n        i += self.N - 1\n        self.node[i][0] = x\n        while i > 1:\n            i >>= 1\n            self.node[i] = self.func(self.node[i << 1], self.node[i << 1 | 1])\n\n    def query(self, l, r):\n        \"\"\"Query for right half-open interval [l, r).\n\n        Args:\n            l (int): index (1-based index)\n            r (int): index (1-based index)\n        \"\"\"\n        dst_l = [self.init_v, -1]\n        dst_r = [self.init_v, -1]\n        l += self.N - 1\n        r += self.N - 1\n        while l < r:\n            if l & 1:\n                dst_l = self.func(dst_l, self.node[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                dst_r = self.func(self.node[r], dst_r)\n            l >>= 1\n            r >>= 1\n        return self.func(dst_l, dst_r)\n\n\ndef func(a, b):\n    return a if a[0] > b[0] else b\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    AB = [None] * N\n    for i in range(N):\n        AB[i] = tuple(map(int, input().split()))\n\n    AB.sort(key=lambda x: x[0])\n    B = [0] * N\n    C = [0] * (1 + 10 ** 5)\n    for i, (a, b) in enumerate(AB):\n        B[i] = b\n        C[a] += 1\n    C = list(accumulate(C))\n\n    st = SegmentTree(N, B, func, -1)\n    ans = 0\n    l = 1\n    for r in C[1:M + 1]:\n        if r == 0:\n            continue\n        x, i = st.query(l, r + 1)\n        if x == -1:\n            continue\n        ans += x\n        st.update(i, -1)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn , m = map(int,input().split())\nkouho = [[] for i in range(m)]\nfor i in range(n):\n    a , b = map(int,input().split())\n    if a <= m:\n        kouho[a-1].append(-b)\nans = 0\np = []\nheapq.heapify(p)\n\nfor i in range(m):\n\n    for j in kouho[i]:\n        heapq.heappush(p,j)\n    if p:\n        ans -= heapq.heappop(p)\nprint(ans)", "from heapq import*\n(N, M), *t = [map(int, s.split()) for s in open(0)]\nq, z = [], 0\nv = [[] for _ in [None] * 10**5]\nfor a, b in t:\n    v[a - 1] += b,\nfor i in v[:M]:\n    for j in i:\n        heappush(q, -j)\n    if q:\n        z += -heappop(q)\nprint(z)", "from heapq import heappop, heapify, heappush\nfrom collections import defaultdict\nN, M = list(map(int,input().split()))\nd = defaultdict(list)\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    d[a].append(b)\nh = []\nans = 0\nfor i in range(1, M+1):\n    if len(d[i]) != 0:\n        for x in d[i]:\n            heappush(h, -x)\n    if len(h) != 0:\n        ans -= heappop(h)\nprint(ans)\n", "import heapq\n \nn,m=map(int,input().split())\nmm=10**5+5\nc=[[0] for i in range(mm)]\n \nfor i in range(n):\n  a,b=map(int,input().split())\n  c[a].append(b)\n \n#print(c)\n \nans=0\nh=[]\nfor i in reversed(range(m)):\n  d=m-i\n  for j in c[d]:\n    heapq.heappush(h,-j)\n  #heapq.heapify(h)\n  ans+=-heapq.heappop(h)\n \nprint(ans)", "from heapq import heappop,heappush,heapify\nfrom collections import deque\n\nN,M=map(int,input().split())\nA,B,C = [0]*N,[0]*N,[0]*N\nfor i in range(N):\n    A[i],B[i] = map(int,input().split())\n    C[i]=[A[i],B[i]]\nC.sort()\nC=deque(C)\n\na=[]\nheapify(a)\nans=0\n\nfor i in range(M,-1,-1):\n    while C:\n        if C[0][0]<=M-i:\n            heappush(a,(-1)*C[0][1])\n            C.popleft()\n        else:\n            break\n    if len(a)>0:\n        p = heappop(a)\n        ans += (-1)*p\n        \nprint(ans)", "import sys\nfrom heapq import heappush,heappop\n\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip('\\r\\n'))\n#print(lines)\nn,m = lines[0].split()\nn = int(n)\nm = int(m)\n\na=[]\nfor i in range(n):\n    x,y = lines[i+1].split()\n    x = int(x)\n    y = int(y)*(-1)\n    a.append((x,y))\na.sort()\na.append((0,0))\n\nh = []\n\ncur = 0\nsumm = 0\nfor i in range(1,m+1):\n    while(cur<n and a[cur][0]<=i):\n        heappush(h,a[cur][1])\n        cur+=1\n    if(len(h)>0):\n        summ+=heappop(h)*(-1)\nprint(summ)\n    \n", "# m-1\u65e5\u76ee\u306f\u3001a<=1\u3067\u6700\u5927\u5831\u916c\u306e\u30a2\u30eb\u30d0\u30a4\u30c8\u3092\u3084\u308b\n# m-2\u65e5\u76ee\u306f\u3001a<=2\u3067\u6700\u5927\u5831\u916c\u306e\u30a2\u30eb\u30d0\u30a4\u30c8\u3092\u3084\u308b\uff08\u305f\u3060\u3057\u3001m-1\u65e5\u76ee\u306b\u9078\u629e\u3057\u305f\u30a2\u30eb\u30d0\u30a4\u30c8\u3092\u9664\u304f\uff09\n# \u4ee5\u4e0b\u3053\u306e\u8981\u9818\u3067\u5f8c\u308d\u304b\u3089\u6c7a\u3081\u3066\u3044\u304f\nfrom collections import defaultdict\nfrom heapq import heapify, heappush, heappop\n\nn,m = list(map(int, input().split()))\nd = defaultdict(list)\nfor _ in range(n):\n    a,b = list(map(int, input().split()))\n    d[a].append(b)\n\nL = []\nheapify(L)\n\nans = 0\nfor remain in range(1,m+1):\n    for reward in d[remain]:\n        heappush(L, -reward)\n    if len(L):\n        ans -= heappop(L)\n\nprint(ans)", "import sys\nfrom heapq import heappop, heappush\nN, M = list(map(int, sys.stdin.readline().split()))\nA = [[] for _ in [0]*M]\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    if a > M:\n        continue\n    A[M-a].append(b)\n\nans = 0\nq = []\nfor i, B in enumerate(A):\n    for b in B:\n        heappush(q, b)\n        ans += b\n    while len(q) > i+1:\n        b = heappop(q)\n        ans -= b\nprint(ans)\n", "n,m=list(map(int,input().split()))\nab=[list(map(int, input().split())) for _ in range(n)]\nab=list(sorted(ab, key=lambda x: x[0]))\n\nimport heapq\nhq=[]\nans=0\nj=0\nfor i in range(1, m+1):  # m-i\u65e5\u5f8c\u3092\u8003\u3048\u308b\n    while (j<n) and (ab[j][0]<=i):\n        heapq.heappush(hq, -ab[j][1])\n        j+=1\n    if len(hq):\n        ans+=-heapq.heappop(hq)\n\nprint(ans)\n", "import heapq\nN, M = list(map(int, input().split()))\n\nAB = []\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n    AB.append((A, B))\nAB = sorted(AB, key=lambda x: x[0])\n\nhq = []\nheapq.heapify(hq)  # \u30ea\u30b9\u30c8hq\u306eheap\u5316\n\nans = 0\ni = 0\nfor d in range(1, M+1):\n    while i <= N-1 and AB[i][0] <= d:\n        heapq.heappush(hq, -AB[i][1])  # heap\u5316\u3055\u308c\u305f\u30ea\u30b9\u30c8hq\u306b\u8981\u7d20x\u3092\u8ffd\u52a0\n        i += 1\n    if hq:\n        ans -= heapq.heappop(hq)  # heap\u5316\u3055\u308c\u305f\u30ea\u30b9\u30c8hq\u304b\u3089\u6700\u5c0f\u5024\u3092\u524a\u9664\uff06\u305d\u306e\u6700\u5c0f\u5024\u3092\u51fa\u529b\nprint(ans)\n", "import heapq\nn, m = list(map(int, input().split()))\nbyte = [[] for _ in range(100001)]\n\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    byte[a].append(b)\nsearch = []\nday = 1\nans = 0\nwhile day-1 != m:\n    for b in byte[day]:\n        heapq.heappush(search, -b)\n    if not search:\n        day += 1\n        continue\n    tmp = -heapq.heappop(search)\n    ans += tmp\n    day += 1\n\nprint(ans)\n\n\n\n", "import heapq\nn, m = list(map(int, input().split()))\nbyte = [[] for _ in range(m+2)]\n\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if a > m+1:\n        continue\n    byte[a].append(b)\nsearch = []\nday = 1\nans = 0\nwhile day-1 != m:\n    for b in byte[day]:\n        heapq.heappush(search, -b)\n    if not search:\n        day += 1\n        continue\n    tmp = -heapq.heappop(search)\n    ans += tmp\n    day += 1\n\nprint(ans)\n\n\n\n", "from heapq import heappop, heappush\nimport sys\n\ndef read_str(): return sys.stdin.readline().strip()\ndef read_int(): return int(sys.stdin.readline().strip())\ndef read_ints(): return list(map(int, sys.stdin.readline().strip().split()))\ndef read_str_split(): return list(sys.stdin.readline().strip())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef Main():\n    n, m = read_ints()\n    query = [[] for _ in range(m)]\n    for _ in range(n):\n        a, b = read_ints()\n        if m - a < 0: continue\n        query[m - a].append(b)\n\n    total = 0\n    que = []\n    for i, b in enumerate(query):\n        for x in b:\n            heappush(que, x)\n            total += x\n        while len(que) > i + 1:\n            x = heappop(que)\n            total -= x\n    print(total)\n\ndef __starting_point():\n    Main()\n\n__starting_point()", "import sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nN, M = list(map(int, sys.stdin.readline().split()))\nA = defaultdict(list)\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    if a <= M:\n    \tA[M-a].append(b)\n\nans = 0\nq = []\nfor i, B in sorted(A.items()):\n    for b in B:\n        heappush(q, b)\n        ans += b\n    while len(q) > i+1:\n        b = heappop(q)\n        ans -= b\nprint(ans)\n", "import sys\nimport queue\n\ninput_methods=['clipboard','file','key']\nusing_method=0\ninput_method=input_methods[using_method]\n\nIN=lambda : map(int, input().split())\nmod=1000000007\n\n#+++++\n\nclass node:\n\tdef __init__(self,a_val, a_parent=None):\n\t\tself.val=a_val\n\t\tself.parent=a_parent\n\t\tself.right=None\n\t\tself.left=None\n\ndef main2():\n\tn, m = IN()\n\tvl=[]\n\tfor n in range(n):\n\t\ta,b = IN()\n\t\tvl.append((a,b))\n\t\t\n\tvl.sort(key=lambda x:-x[1])\n\tret = 0\n\tnwdl=[-1]*(m+1) #list(range(m+1))\n\tfor a, b in vl:\n\t\tj=m-a\n\t\twhile j >= 0:\n\t\t\tif nwdl[j]==-1:\n\t\t\t\tnwdl[j]=0\n\t\t\t\tret+=b\n\t\t\t\tbreak\n\t\t\tj-=1\n\t\t#pa((a,b,m-a,nwdl))\n\tprint(ret)\n\t\n\t\ndef main():\n\tn, m = IN()\n\tst_day=[[] for _ in range(m+1)]\n\tfor n in range(n):\n\t\tduration, pay = IN()\n\t\tif duration > m:\n\t\t\tcontinue\n\t\tst_day[m-duration].append(pay)\n\t\n\tpq=queue.PriorityQueue()\n\tret = 0\n\tfor di in range(m+1):\n\t\tday=m-di\n\t\tfor pay in st_day[day]:\n\t\t\tpq.put(-pay)\n\t\tif not pq.empty():\n\t\t\tv = pq.get()\n\t\t\tret -= v\n\tprint(ret)\n\t\t\t\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    data = {}\n    priorityQ = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if m + 1 - a >= 0:\n            if m+1-a in data:\n                data[m+1-a].append(b)\n            else:\n                data[m+1-a] = [b]\n    ans = 0\n    for i in range(m, 0, -1):\n        if i in data.keys():\n            for k in data[i]:\n                heapq.heappush(priorityQ, -k)\n        if priorityQ:\n            ans -= heapq.heappop(priorityQ)\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappush, heappop\n\ndef readinput():\n    n,m=list(map(int,input().split()))\n    a=[]\n    b=[]\n    for i in range(n):\n        ai,bi=list(map(int,input().split()))\n        a.append(ai)\n        b.append(bi)\n    return n,m,a,b\n\ndef main(n,m,a,b):\n    jobList=[]\n    for i in range(10**5+1):\n        jobList.append([])\n    for i in range(n):\n        jobList[a[i]].append(b[i])\n\n    goodjobs=[]\n    earn=0\n    for d in range(1,m+1):\n        for job in jobList[d]:\n            heappush(goodjobs,-job)\n        #print(goodjobs)\n        if len(goodjobs)>0:\n            earn+=heappop(goodjobs)\n    return -earn\n\ndef __starting_point():\n    n,m,a,b=readinput()\n    ans=main(n,m,a,b)\n    print(ans)\n\n__starting_point()", "from heapq import heappush, heappop\n\nN, M = map(int, input().split())\nAtoB = [[] for _ in range(M+1)]\nfor i in range(N):\n    A, B = map(int, input().split())\n    if A > M:\n        continue\n    AtoB[A].append(B)\n\n# A \u304c\u5c0f\u3055\u3044\u9806\u306b\u5897\u3048\u3066\u3044\u304f\nresult = 0\nque = [] # \u30d2\u30fc\u30d7\nfor Bs in AtoB:\n    for B in Bs:\n        heappush(que, -B) # Python3 \u306e\u30d2\u30fc\u30d7\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u5c0f\u3055\u3044\u9806\n    if que:\n        result -= heappop(que)\nprint(result)", "n,m=list(map(int, input().split()))\njob_list=[]\nfor i in range(n):\n    tmp=[int(x) for x in input().split()]\n    job_list.append(tmp)\njob_list.sort()\n\nimport heapq\nk=0\nans=0\nsalary_list=[]\nfor i in range(1,m+1):\n    while k<n and job_list[k][0]==i:\n        heapq.heappush(salary_list,job_list[k][1]*(-1))\n        k+=1\n    if len(salary_list)>0:\n        ans+=heapq.heappop(salary_list)\nprint(((-1)*ans))\n", "from heapq import heapify, heappop, heappush\nN,M = map(int,input().split())\nA = [[] for _ in range(M+1)]\n#HQ = []\nfor i in range(N):\n  a,b = map(int,input().split())\n  if a <= M:\n    A[a].append(b)\n#print(A)\nans = 0\nL = []\nfor day in range(1,M+1):\n  for t in A[day]:\n    heappush(L,-t)\n  #print(L)\n  if not L:\n    continue\n  temp = heappop(L)\n  ans += -temp\nprint(ans)  ", "import heapq\n\nn,m=map(int,input().split())\nmm=10**5+5\nc=[[0] for i in range(mm)]\n\nfor i in range(n):\n  a,b=map(int,input().split())\n  c[a].append(b)\n\n#print(c)\n\nans=0\nh=[]\nfor i in reversed(range(m)):\n  d=m-i\n  for j in c[d]:\n    heapq.heappush(h,-j)\n  #heapq.heapify(h)\n  ans+=-heapq.heappop(h)\n\nprint(ans)", "import heapq as hq\nimport numpy as np\n\nN, M = map(int, input().split())\njob = [list(map(int, input().split())) for _ in range(N)]\nans = 0\njob.sort()\njob.append([np.inf, np.inf])\njobhq = []\nindex = 0\nfor day in range(1, M + 1):\n    while day >= job[index][0]:\n        hq.heappush(jobhq, - job[index][1])\n        index += 1\n    if jobhq:\n        ans += - hq.heappop(jobhq)\nprint(ans)", "from collections import defaultdict\nfrom heapq import heappush, heappop\n\nN, M = list(map(int, input().split()))\njobs = defaultdict(list)\nheap = []\nans = 0\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    if a <= M:\n        jobs[a].append(b)\n\nfor m in range(1, M+1):\n    for b in jobs[m]:\n        heappush(heap, -b)\n    if heap:\n        maxb = -heappop(heap)\n        ans += maxb\nprint(ans)\n\n", "\nimport sys\n\nicase=0\nif icase==0:\n    n,m=list(map(int,input().split()))\n    ab=[[] for i in range(m)]\n    for i in range(n):\n        ai,bi=list(map(int,input().split()))\n        if m-ai>=0:\n            ab[m-ai].append(-bi)\nelif icase==1:\n    n,m=3,4\n    ab=[[-3, -1], [], [-2], []]    \nelif icase==2:\n    n,m=5,3\n    ab=[[], [-1, -3], [-2, -3, -4]]\nelif icase==3:\n    n,m=1,1\n    ab=[[]]\n\nfrom heapq import heappop,heappush\n\nif len(ab)==0:\n    print((0))\n    return\n\nn=len(ab)\nh=[]\nasum=0\nfor i in range(m-1,-1,-1):\n    if len(ab[i])>0:\n        for abi in ab[i]:\n            heappush(h,abi)\n#    print(i,h,asum)\n    if len(h)>0:\n        asum+=heappop(h)\n\nprint((-asum))\n    \n", "import heapq\nimport sys\nN, M = map(int, input().split())\nB = [[] for _ in range(M + 1)]\nfor _ in range(N):\n    a, b = map(int, sys.stdin.readline().split())\n    if a <= M:\n        B[a].append(b)\n\nans = 0\nq = []\nfor i in range(1, M + 1):\n    for b in B[i]:\n        heapq.heappush(q, -b)\n    if q:\n        ans += -(heapq.heappop(q))\nprint(ans)", "from math import factorial as fact\nimport math\nimport sys\nfrom itertools import product\nimport numpy as np\nfrom collections import Counter\nimport datetime\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nimport heapq\n\n\n\n#\u5165\u529b:N(int:\u6574\u6570)\ndef input1():\n\treturn int(input())\n\n#\u5165\u529b:N,M(int:\u6574\u6570)\ndef input2():\n\treturn list(map(int,input().split()))\n\n#\u5165\u529b:[n1,n2,...nk](int:\u6574\u6570\u914d\u5217)\ndef input_array():\n\treturn list(map(int,input().split()))\n\n\nn,m=input2()\nAB=[[] for _ in range(m)]\n\n\nfor i in range(n):\n\ta,b=input2()\n\tif a-1 < m: #\u5831\u916c\u53d7\u53d6\u65e5\u304cm\u3092\u8d85\u3048\u308b\u4ed5\u4e8b\u306f\u9664\u5916\u3059\u308b\n\t\tAB[a-1].append(-b) #heapq\u306e\u4ed5\u69d8\u306e\u305f\u3081\uff0c-\u3092\u8ffd\u52a0\n\nans=0\nheap=[]\nfor i in range(m):\n\tfor b in AB[i]:\n\t\theapq.heappush(heap,b)\n\t#\u6700\u5927\u5024\u3092heap\u304b\u3089\u53d6\u308a\u51fa\u3057\n\tif len(heap)>0:\n\t\tMAX=heapq.heappop(heap)\n\t\tans+= -MAX\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n", "import heapq\n\nn,m=list(map(int, input().split()))\nab = [[] for i in range(m+1)]\nd = []\nfor i in range(n):\n    a,b=list(map(int, input().split()))\n    if(not a>m):\n        ab[a-1].append(-1*b)\nres = 0\ncnt = 0\n\nfor i in range(m):\n    for j in range(len(ab[i])):\n        heapq.heappush(d,ab[i][j])\n    if(len(d)):\n        res+=(heapq.heappop(d))\nprint((-1*res))\n", "import heapq\nn,m = map(int,input().split())\nb_list = [[] for _ in range(10**5+10)]\n\nfor i in range(n):\n    a,b = map(int,input().split())\n    b_list[a].append(-b)\n\ncandy = []\nheapq.heapify(candy)\nans = 0\nfor i in range(1,m+1):\n    for j in b_list[i]:\n        heapq.heappush(candy,j)\n    if candy: \n        ans += (-1*heapq.heappop(candy))\n\nprint(ans)", "n,m=list(map(int,input().split()))\nab=[[] for _ in range(10**5+1)]\nfor j in range(1,10**5+1):\n    ab[j].append(0)\n\nfor _ in range(n):\n    a,b=list(map(int,input().split()))\n    ab[a].append(-1*b)\n\n\ntemp=[]\nimport heapq\nans=0\nfor i in range(1,m+1):\n    for j in ab[i]:\n        heapq.heappush(temp,j)\n    \n    x=heapq.heappop(temp)\n    \n    ans+=-1*x\nprint(ans) \n", "from heapq import heappop, heapify, heappush\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    work = [[] for _ in range(10 ** 5 + 1)]\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        work[a].append(b)\n    ans = 0\n    q = []\n    heapify(q)\n    for i in range(1, m + 1):\n        for w in work[i]:\n            heappush(q, -w)\n        if len(q) == 0:\n            continue\n        ans += heappop(q)\n    ans *= -1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nN, M = map(int, input().split())\narubaito = [list(map(int, input().split())) for _ in range(N)]\narubaito.sort()\narubaito2 = [[] for _ in range(M+1)]\nfor i in range(N):\n    if arubaito[i][0] <= M:\n        arubaito2[arubaito[i][0]].append(arubaito[i][1])\nfor i in range(M):\n    arubaito2[i].sort(reverse=True)\ntarget = []\nans = 0\nheapq.heapify(target)\nfor i in range(1,M+1):\n    for k in arubaito2[i]:\n        heapq.heappush(target,k*(-1))\n    if len(target) > 0:\n        ans += heapq.heappop(target)*(-1)\nprint(ans)", "import collections\nimport heapq\n\nn, m = map(int, input().split())\nque = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    que.append((-b, a))\nque.sort(key=lambda x: x[1])\nque = collections.deque(que)\nh = []\nheapq.heapify(h)\nans = 0\nfor i in range(1, m + 1):\n    while len(que) != 0 and que[0][1] <= i:\n        tmp = que.popleft()\n        heapq.heappush(h, tmp)\n    if len(h) == 0: continue\n    tmp = heapq.heappop(h)\n    ans -= tmp[0]\nprint(ans)", "from heapq import*\n(N, M), *t = [map(int, s.split()) for s in open(0)]\nq, z = [], 0\nv = [[] for _ in [None] * 10**5]\nfor a, b in t:\n    v[a - 1] += b,\nfor i in v[:M]:\n    for j in i:\n        heappush(q, -j)\n    if q:\n        z += -heappop(q)\nprint(z)"]
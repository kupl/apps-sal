["mod = int(1e9) + 7 # <-- input modulo\nmaxf = 500000           # <-- input factional limitation\n\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[-i-1]]\n        for j in range(L[-i-1]+1, k):\n            perm[j-1] = perm[j]\n    return LL\n\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\n\ndef inved(a, modulo=mod):\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n    while l != 0:\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n        k, l = l, k % l\n    return x % modulo\n\nfact = [1 for _ in range(maxf+1)]\ninvf = [1 for _ in range(maxf+1)]\n\nfor i in range(maxf):\n    fact[i+1] = (fact[i] * (i+1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i-1] = (invf[i] * i) % mod\nn, k = map(int, input().split())\nS = 0\nif n <= k + 1:\n    print(fact[2*n-1]*invf[n]*invf[n-1]%mod)\nelse:\n    S = 0\n    for i in range(min(n, k+1)):\n        S += invf[i]*invf[i]*invf[n-i-1]*invf[n-i]%mod\n        S %= mod\n    print(S*fact[n-1]*fact[n]%mod)", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n    def factorial(self, n):\n        return self.fact[n]\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, K = list(map(int, input().split()))\n    K = min(K, N)\n\n    calc = Calc(max_value=N * 2, mod=MOD)\n\n    ans = 0\n    for v in range(K + 1):  # \u7a7a\u5ba4\u6570\n        ans = (ans + calc.combination(N, v) * calc.combination(v + (N - v) - 1, v)) % MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nPr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[n - r] % self.mod\n\n    def nHr(self, n, r):\n        if (n == 0 and r > 0) or r < 0:\n            return 0\n        return self.fac[n + r - 1] * self.facinv[r] % self.mod * self.facinv[n - 1] % self.mod\n\n\ndef resolve():\n    MOD = 10**9+7\n    N, K = list(map(int, input().split()))\n\n    r = min(N-1, K)\n    cmb = Combination(N)\n\n    ans = 0\n    for i in range(r+1):\n        ans += cmb.nCr(N, i) * cmb.nHr(N-i, i)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,k = map(int,input().split())\nmod = 1000000007\ndef comb(n,k):\n    if n < k: return 0\n    if n < 0 or k < 0: return 0\n    return fac[n]*finv[k]%mod*finv[n-k]%mod\nfac = [1]*(n+1)\nfinv = [1]*(n+1)\nfor i in range(1,n+1):\n    fac[i] = fac[i-1]*i%mod\n    finv[i] = pow(fac[i],mod-2,mod)\n\nans = 0\nfor i in range(min(k+1,n)):\n    ans += comb(n,i)*comb(n-1,i)%mod\n    ans %= mod\nprint(ans)", "MOD = 10 ** 9 + 7\n\n\ndef prepare(n, MOD):\n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef comb(n, r, factorials, invs):\n    return factorials[n] * invs[r] * invs[n - r] % MOD\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    factorials, invs = prepare(n, MOD)\n    ans = 0\n    for m in range(min(k, n - 1) + 1):\n        ans += comb(n - 1, m, factorials, invs) * comb(n, m, factorials, invs)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "M=10**9+7\nn,k=map(int,input().split())\nfrom functools import lru_cache\n@lru_cache(None)\ndef f(x):\n  if x: return x*f(x-1)%M\n  return 1\nl=[f(i) for i in range(n+1)]\na=0\nfor i in range(min(n,k+1)):\n  c=l[n]*l[n-1]%M\n  p=l[i]**2*l[n-i]*l[n-i-1]%M\n  a+=c*pow(p,M-2,M)\nprint(a%M)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nmod = 10**9 + 7\n\n\nclass Mod:\n    \"\"\"\n    comb = Mod(1000000)\n    print(comb(5, 3))  # 5C3\n    \"\"\"\n\n    def __init__(self, n_max, mod=10**9 + 7):\n        self.mod = mod\n        self.modinv = self.__make_modinv_list(n_max)\n        self.fac, self.facinv = self.__make_factorial_list(n_max)\n\n    def comb(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def factorial(self, n):\n        return self.fac[n]\n\n    def factorial_inv(self, n):\n        return self.facinv[n]\n\n    def __make_factorial_list(self, n):\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def __make_modinv_list(self, n):\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod\n        return modinv\n\n\ndef solve():\n\n    n, k = list(map(int, input().split()))\n    k = min(n - 1, k)\n    m = Mod(n)\n\n    ans = 0\n    for i in range(k + 1):\n        ans += m.comb(n - 1, n - 1 - i) * m.comb(n, i)\n        ans %= mod\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "class Combination:\n    def __init__(self, size, mod=10**9 + 7):\n        self.size = size + 2\n        self.mod = mod\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % self.mod\n            self.inv[i] = -self.inv[self.mod % i] * (self.mod // i) % self.mod\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % self.mod\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % self.mod\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % self.mod) % self.mod\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b\n        return self.ncr(n + r - 1, n - 1)\n\n    def factN(self, n):\n        if n < 0:\n            return 0\n        return self.fact[n]\n\nN, K = list(map(int, input().split()))\nK = min(K, N)\nMOD = 10**9 + 7\ncomb = Combination(N + 100)\n\nans = 0\nfor k in range(K + 1):\n    ans += comb.ncr(N, k) * comb.nhr(N - k, k)\n    ans %= MOD\n\nprint(ans)\n", "\nnmax = 3*10**5\nmod = 10**9+7\n\nfac = [1]*nmax\nfinv = [1]*nmax\ninv = [1]*nmax\ndef ncr_pre():\n    for i in range(2,nmax):\n        fac[i] = fac[i-1]*i % mod\n        inv[i] = mod - inv[mod%i] * (mod//i) %mod\n        finv[i] = finv[i-1] * inv[i] %mod\n\ndef ncr(n,r):\n    if n<r:\n        return 0\n    if n<0 or r<0:\n        return 0\n    return fac[n]* (finv[r] * finv[n-r] %mod) %mod\n\n\nncr_pre()\nn,k = list(map(int,input().split()))\nans = 0\nfor i in range(min(n,k+1)):\n    ans+=ncr(n,i)*ncr(i+n-i-1,i)\n    ans%=mod\nprint(ans)\n", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 6  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\nN, K = lr()\nK = min(K, N-1)\nx = fact[N] * fact_inv[0:K+1] % MOD * fact_inv[N-K:N+1][::-1] % MOD\ny = fact[N-1] * fact_inv[0:K+1] % MOD * fact_inv[N-K-1:N][::-1] % MOD\nanswer = (x * y % MOD).sum()\nprint((answer % MOD))\n", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 4 * 10**5 + 100\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb_repl = fact_instance.homogeneous_product\ncomb = fact_instance.combination\n\nN, K = [int(_) for _ in input().split()]\nans = 0\nfor r in range(min(N - 1, K) + 1):\n    ans += comb(N, r) * comb_repl(N - r, r)\n    ans %= mod\nprint(ans)\n", "n, k = map(int, input().split())\nmod = 1000000007\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\nif k >=n:\n  L = 2*n-1\n  ansbunsi =1\n  for j in range(n-1):\n    ansbunsi = ansbunsi*L%mod\n    L -= 1\n  ansbunbo = 1\n  L = n - 1\n  for j in range(n-1):\n    ansbunbo = ansbunbo*L%mod\n    L -= 1\n  ansbunbo = modinv(ansbunbo)\n  print(ansbunsi*ansbunbo%mod)\n\nelse:\n  kaijou = [1, 1]\n  for j in range(2, k+n+1):\n    kaijou.append(kaijou[-1]*j%mod)\n  \n  ans = 0\n\n  for m in range(k+1):\n    ansbunsi = kaijou[n]*kaijou[n-1]%mod\n    ansbunbo = kaijou[m]*kaijou[n-m]%mod\n    ansbunbo = ansbunbo*kaijou[n-m-1]%mod\n    ansbunbo = ansbunbo*kaijou[m]%mod\n    ansbunbo = modinv(ansbunbo)\n    ans += ansbunbo*ansbunsi\n    ans %= mod\n  \n  print(ans)", "n, k = map(int, input().strip().split())\nk=min(k,n-1)\nMOD=10**9+7\n\n# a*a**(p-2) mod p (Fermat's little theorem)\ndef modInv(x,m=10**9+7):\n    return pow(x,m-2,m)\n\nclass combMod:\n    def __init__(self,maxN,mod=10**9+7):\n        self.maxN=maxN\n        self.mod=mod\n        self.fac=[None]*(maxN+1) # fac[0]=1, fac[1]=1, fac[2]=2 ... fac[maxN]\n        self.ifac=[None]*(maxN+1)\n        # self.ifac[0]=1\n        \n    def calc_fact(self): # make the table\n        self.fac[0]=1\n        for i in range(1,self.maxN+1):\n            self.fac[i] = self.fac[i-1]*i % self.mod\n        self.ifac[-1] = modInv(self.fac[-1])\n        for i in range(self.maxN,0,-1):\n            self.ifac[i-1] = self.ifac[i]*i % self.mod\n    def modnCr(self,n, r,mod=None):\n        if mod is None:\n            mod=self.mod\n        denom = self.fac[n]\n        numer = self.ifac[r] * self.ifac[n-r] % mod\n        return  denom * numer % mod\n\ncombMod=combMod(2*n+1)\ncombMod.calc_fact()\nans=0\nfor ki in range(k+1):\n    ans += combMod.modnCr(n, ki)*combMod.modnCr(n-ki-1+ki, ki)%MOD\nprint(ans%MOD)", "P = 10**9+7\nN = 700000 #\u4f7f\u3046\u6700\u5927\u5024\u4ee5\u4e0a\u306b\u3059\u308b\u3001\u5024\u306b\u6ce8\u610f4*10^5\u3068\u304b\u306b\u3057\u3068\u304f\u3068\u5b89\u5fc3\ninv = [0] + [1] # 1/x\nfinv = [1] + [1] # 1/x!\nfac = [1] + [1] # x!\nfor i in range(2,N+1):\n  inv += [inv[P % i] * (P - int(P / i)) % P]\n  fac += [(fac[i-1] * i) % P]\n  finv += [(finv[i-1] * inv[i]) % P]\n\ndef comb(a, b):\n    if a<b: return 0 # error\n    return (fac[a] * ((finv[b] * finv[a-b]) % P)) %P\n\nn, k = list(map(int, input().split()))\n\nans = 0\n#0\u304c0~min(n-1, k)\nnum = min(n-1, k) + 1\nfor i in range(num):\n    heya = n - i\n    #0\n    ret = comb(n, i)\n    person = n - heya\n    ret = (ret * comb(person+heya-1, person))%P\n    ans += ret\nprint((ans%P))\n", "M=10**9+7;n,k=map(int,input().split());a=c=p=1\nfor i in range(1,min(n,k+1)):c=c*(n-i+1)*(n-i)%M;p=p*i*i%M;a+=c*pow(p,M-2,M)\nprint(a%M)", "N, K = list(map(int, input().split()))\nMOD = 10**9 + 7\nMAX_N = 10**6 + 5\nfact = [0]*(MAX_N)\nfact_inv = [0]*(MAX_N)\nfact[0] = 1\nfor i in range(MAX_N-1):\n    fact[i+1] = fact[i]*(i+1) % MOD\nfact_inv[-1] = pow(fact[-1], MOD-2, MOD)\nfor i in range(MAX_N-2, -1, -1):\n    fact_inv[i] = fact_inv[i+1]*(i+1) % MOD\n\n\ndef comb(n, k):\n    return fact[n]*fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\n\nif K >= N:\n    print((comb(2*N-1, N-1)))\n    return\n\nans = 1\nfor i in range(1, K+1):\n    ans += comb(N, i)*comb(N-1, i) % MOD\n    ans %= MOD\nprint(ans)\n", "n,k = map(int,input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\n#con = cmb(n,k,mod)\n#print(con)\nfor i in range(min(k+1,n+1)):\n    ans += cmb(n,i,mod)*cmb(n-1,i,mod)\n    ans %= mod\n    \nprint(ans)", "n,k=map(int,input().split())\nmod=pow(10,9)+7\n# max:comb(2*n-1,n-1)\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\ng1 = [1, 1] \ng2 = [1, 1] \ninverse = [0, 1]\nfor i in range( 2, 2*n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nif k>=n-1:\n  print(cmb(2*n-1,n-1,mod))\nelse:\n  ans=0\n  for i in range(k+1):\n    ans+=cmb(n,i,mod)*cmb(n-1,i,mod)\n    ans%=mod\n  print(ans)", "def prepare(n, MOD):\n \n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\nMOD = 10**9+7\nfact, fact_inv = prepare(3*10**5, MOD)\n\nn, k = map(int,input().split())\n\nk = min(n-1, k)\n\nans = 1\nfor i in range(1,k+1):\n    z = fact[n] * fact_inv[i] % MOD * fact_inv[n-i] % MOD\n    p = fact[n-1] * fact_inv[n-i-1] % MOD * fact_inv[i] % MOD\n    ans += z * p % MOD\n    ans %= MOD\nprint(ans)", "N, K = list(map(int, input().split()))\n\nMOD = 10**9+7\nfac = [1]*(N+1)\nrev = [1]*(N+1)\n \nfor i in range(1, N+1):\n  fac[i] = i*fac[i-1]%MOD\n  rev[i] = pow(fac[i], MOD-2, MOD)\n\ncomb = lambda a,b:(fac[a]*rev[a-b]*rev[b])%MOD\nans = 0\n\nfor i in range(1+min(N-1, K)):\n  ans += comb(N, i) * comb(N-1, i)\nans %= MOD\nprint(ans)\n", "import sys\nimport math\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nfrom collections import deque\nfrom bisect import bisect_left\nfrom itertools import product\ndef I(): return int(sys.stdin.readline())\ndef MI(): return list(map(int, sys.stdin.readline().split()))\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]\n#\u6587\u5b57\u5217\u3092\u4e00\u6587\u5b57\u305a\u3064\u6570\u5b57\u306b\u5909\u63db\u3001'5678'\u3092[5,6,7,8]\u3068\u3067\u304d\u308b\ndef LSI(): return list(map(int, list(sys.stdin.readline().rstrip())))\ndef LSI2(N): return [list(map(int, list(sys.stdin.readline().rstrip()))) for i in range(N)]\n#\u6587\u5b57\u5217\u3068\u3057\u3066\u53d6\u5f97\ndef ST(): return sys.stdin.readline().rstrip()\ndef LST(): return sys.stdin.readline().rstrip().split()\ndef LST2(N): return [sys.stdin.readline().rstrip().split() for i in range(N)]\ndef FILL(i,h): return [i for j in range(h)]\ndef FILL2(i,h,w): return [FILL(i,w) for j in range(h)]\ndef FILL3(i,h,w,d): return [FILL2(i,w,d) for j in range(h)]\ndef FILL4(i,h,w,d,d2): return [FILL3(i,w,d,d2) for j in range(h)]\ndef sisha(num,digit): return Decimal(str(num)).quantize(Decimal(digit),rounding=ROUND_HALF_UP)\n#'0.01'\u3084'1E1'\u306a\u3069\u3067\u6307\u5b9a\u3001\u6574\u6570\u306b\u623b\u3059\u306a\u3089int\u3092\u304b\u307e\u3059\nMOD = 1000000007\nINF = float(\"inf\")\nsys.setrecursionlimit(10**6+10)\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = MOD #\u51fa\u529b\u306e\u5236\u9650\nN = 5*10**5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,K = MI()\nans = cmb(2*N-1,N-1,MOD)\nif K<N-1:\n    for i in range(K+1,N):\n        ans -= cmb(N,i,MOD)*cmb(N-1,i,MOD)\nprint((ans%MOD))\n", "mod = 10**9 + 7\nn,k = map(int,input().split())\n\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nfor i in range(1,n+1):\n  fac[i] = (fac[i-1]*i) % mod  \ninv[n] = pow(fac[n], mod-2, mod)\nfor i in range(n, 0, -1):\n  inv[i-1] = (inv[i]*i) % mod\n    \ndef nCr(n,r):  \n  if r < 1:\n    return 1\n  return (((fac[n] * inv[r])%mod) * inv[n-r]) % mod\n\nans = 0\nfor i in range( min(n-1,k) +1 ):    \n  ans = (ans + nCr(n,i) * nCr(n-1,i)) % mod\n\nprint(ans)", "n,k=map(int,input().split())\nP=10**9+7\nclass FactInv:\n    def __init__(self,N,P):\n        fact=[];ifact=[];fact=[1]*(N+1);ifact=[0]*(N+1)\n        for i in range(1,N):\n            fact[i+1]=(fact[i]*(i+1))%P\n        ifact[-1]=pow(fact[-1],P-2,P)\n        for i in range(N,0,-1):\n            ifact[i-1]=(ifact[i]*i)%P\n        self.fact=fact;self.ifact=ifact;self.P=P\n    def comb(self,n,k):\n        return (self.fact[n]*self.ifact[k]*self.ifact[n-k])%self.P\nC=FactInv(2*n+10,P)\nans=0\nfor i in range(0,min(k+1,n)):\n    ans+=(C.comb(n,i)*C.comb(n-1,n-i-1))%P\n    ans%=P\nprint(ans)", "n, k = map(int, input().split())\nmod = pow(10, 9) + 7\nc1, c2 = 1, 1\nn1, n2 = n, n - 1\nans = 1\nfor r in range(1, min(k + 1, n)):\n    c1 = (c1 * n1 * pow(r, mod - 2, mod)) % mod\n    c2 = (c2 * n2 * pow(r, mod - 2, mod)) % mod\n    n1 -= 1\n    n2 -= 1\n    ans += (c1 * c2) % mod\n    ans %= mod\nprint(ans)", "N,K=map(int, input().split())\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nn= 2*10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p) \u968e\u4e57\u306emod\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, n + 1):\n  fact.append((fact[-1] * i) % p)\n  inv.append((-inv[p % i] * (p // i)) % p)\n  factinv.append((factinv[-1] * inv[-1]) % p)\n\n\n#0\u306e\u6570\nzeros=min(K, N-1)\nans=1\nfor i in range(1,zeros+1):\n    ans+=(cmb(N,i,p)*cmb(i+N-i-1, i, p))%p\n    #print(pow(N-i, i, p))\n    ans%=p\n\nprint(ans)", "n, k = list(map( int, input().split() ))\nmod = 10 ** 9 + 7\n\nf = [ 1 ] * ( n + 1 ) \ninv = [ 1 ] * ( n + 1 )\n\nfor i in range( 1, n + 1 ):\n  f[ i ] = ( f[ i - 1 ] * i ) % mod\n  \ninv[ n ] = pow( f[ n ], mod - 2, mod )\nfor i in range( n, 0, - 1 ):\n  inv[ i - 1 ] = ( inv[ i ] * i ) % mod\n  \ndef nCr( n, r ):\n  if r < 1:\n    return 1\n  return ( f[ n ] * inv[ r ] % mod ) * inv[ n - r ] % mod\n\nans = 0\nfor i in range( min( k, n - 1 ) + 1 ):\n  ans = ( ans + nCr( n, i ) * nCr( n - 1, i ) ) % mod\n  \nprint( ans )\n\n\n", "import sys\nsys.setrecursionlimit(10000000)\ninput=sys.stdin.readline\nmod = 10 ** 9 + 7\n\nn,k = list(map(int,input().split()))\n\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nfor i in range(1,n+1):\n  fac[i] = (fac[i-1]*i) % mod  \ninv[n] = pow(fac[n], mod-2, mod)\nfor i in range(n, 0, -1):\n  inv[i-1] = (inv[i]*i) % mod\n    \ndef cmb(n, r):\n     \n  if r < 1:\n        return 1\n  return (((fac[n] * inv[r])%mod) * inv[n-r]) % mod\n \n\n\nans=0\nk=min(k,n-1)\nfor i in range(k+1):\n    ans += cmb(n,i) * cmb(n-1,i) %mod\n\nprint((ans%mod))\n\n\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n\n    #inf = 10**17\n    mod = 10**9 + 7\n\n    max_n = 2*(10**5)\n    fac, inv = [1]*(max_n+1), [0]*(max_n+1)\n    for i in range(2, max_n+1):\n        fac[i] = fac[i-1] * i % mod\n    inv[-1] = pow(fac[-1], mod-2, mod)\n    for i in range(max_n, 0, -1):\n        inv[i-1] = inv[i] * i % mod\n\n    # nCr\u3092\u6c42\u3081\u308b\n    def ncr(n, r):\n        return fac[n]*inv[r]*inv[n-r]%mod\n\n    n, k = list(map(int, input().split()))\n    res = 0\n    # i:\u7a7a\u304d\u90e8\u5c4b\u306e\u6570\n    for i in range(n):\n        if i > k:\n            continue\n        res += ncr(n, i) * ncr(n-1, i)\n        res %= mod\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if (n == 0 and r > 0) or r < 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):  # \u4e0a\u6607\u968e\u4e57\u51aa n * (n+1) * ... * (n+r-1)\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):  # \u7b2c 1 \u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570  lru_cache \u3092\u4f7f\u3046\u3068 O(nk)  # n \u8981\u7d20\u3092 k \u500b\u306e\u5de1\u56de\u5217\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):  # \u7b2c 2 \u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570 O(k + log(n))  # n \u8981\u7d20\u3092\u533a\u5225\u306e\u306a\u3044 k \u30b0\u30eb\u30fc\u30d7\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570\n        if n == k: return 1  # n==k==0 \u306e\u3068\u304d\u306e\u305f\u3081\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):  # n \u8981\u7d20\u3092\u533a\u5225\u306e\u3042\u308b k \u30b0\u30eb\u30fc\u30d7\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(k + log(n))\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):  # \u30d9\u30eb\u30cc\u30fc\u30a4\u6570  lru_cache \u3092\u4f7f\u3046\u3068 O(n**2 * log(mod))\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0  # \u9ad8\u901f\u5316\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):  # \u3079\u304d\u4e57\u548c 0^k + 1^k + ... + (n-1)^k\n        # bernoulli \u306b lru_cache \u3092\u4f7f\u3046\u3068 O(k**2 * log(mod))  bernoulli \u304c\u8a08\u7b97\u6e08\u307f\u306a\u3089 O(k * log(mod))\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):  # n \u8981\u7d20\u3092 k \u500b\u306e\u7a7a\u3067\u306a\u3044\u9806\u5e8f\u4ed8\u304d\u96c6\u5408\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(1)\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):  # n \u8981\u7d20\u3092 k \u30b0\u30eb\u30fc\u30d7\u4ee5\u4e0b\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(k**2 + k*log(mod))\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    mod = 10**9+7\n    sign = 1\n    L = []\n    comb = Combination(202020)\n    ans = 0\n    for n_zeroes in range(min(K+1, N)):\n        a = comb.C(N, n_zeroes) * comb.H(N-n_zeroes, n_zeroes) % mod\n        ans += a\n    print((ans % mod))\n\nmain()\n", "n,k=map(int,input().split())\nfact=[1]\nfor i in range(1,2*n):\n  fact.append((fact[i-1]*(i+1))%(10**9+7))\nfactinv=[]\nfor i in range(n):\n  factinv.append(pow(fact[i],10**9+5,10**9+7))\nif k==1:\n  print((n*(n-1))%(10**9+7))\nelif k>=n-1:\n  print((fact[2*n-2]*factinv[n-1]*factinv[n-2])%(10**9+7))\nelse:\n  ans=1\n  for i in range (k):\n    ans=(ans+fact[n-1]*factinv[i]*factinv[n-i-2]*fact[n-2]*factinv[i]*factinv[n-i-3])%(10**9+7)\n  print(ans)", "class Facts:\n\n  def __init__(self, mod=10**9+7, n_max=1):\n    self.mod     = mod\n    self.n_max   = n_max\n    self.fact    = [1, 1]\n    self.inv     = [0, 1]\n    self.factinv = [1, 1]\n    if 1 < n_max:\n      self.setup_table(n_max)\n\n  def cmb(self, n, r):\n    if r < 0 or n < r:\n      return 0\n    if self.n_max < n:\n      self.setup_table(n)\n    return self.fact[n] * (self.factinv[r] * self.factinv[n-r] % self.mod) % self.mod\n\n  def factorial(self, n):\n    if self.n_max < n:\n      self.setup_table(n)\n    return self.fact[n]\n    \n  def hom(self, n, k):\n    return self.cmb(n+k-1, k)\n\n  def prm(self, n, k):\n    if self.n_max < n:\n      self.setup_table(n)\n    return self.fact[n] * self.factinv[n-k] % self.mod\n\n  def setup_table(self, t):\n    for i in range(self.n_max+1,t+1):\n      self.fact.append( self.fact[-1] * i % self.mod )\n      self.inv.append( -self.inv[mod % i] * (self.mod // i) % self.mod )\n      self.factinv.append( self.factinv[-1] * self.inv[-1] % self.mod )\n    self.n_max = t\n\n# ABC156 Roaming\nmod = 10 ** 9 + 7\n\nn, k = list(map(int, input().split()))\n\nans = 0\nf = Facts(mod)\n\nfor i in range(0, min(n-1, k)+1):\n  ans += f.cmb(n,i) * f.hom(n-i,i) % mod\n  if ans >= mod:\n    ans -= mod \n\nprint(ans)\n\n# ABC167 E 2020/5/11\n# mod = 998244353\n\n# n, m, k = map(int, input().split())\n\n# ans = 0\n# f = Facts(mod)\n# t = m * pow(m-1, n-1-k, mod)\n\n# for i in range(k,-1,-1):\n#   ans += f.cmb(n-1,i) * t % mod\n#   t = t * (m-1) % mod\n\n# print(ans % mod)\n", "mod = 10 ** 9 + 7\nn, k = map(int, input().split())\nbinomial = [1]\ncum = 1\nfor i in range(1, n + 2):\n    cum *= i\n    cum = cum % mod\n    binomial.append(cum)\ninv = []\ntmp = pow(cum, mod - 2, mod)\ninv.append(tmp)\nfor j in range(n + 1, 0, -1):\n    tmp = j * tmp % mod\n    inv.append(tmp)\ninv.reverse()\n\ndef comb(n, k):\n    return binomial[n] * inv[n - k] % mod * inv[k] % mod if n >= k else 0\nk = min(k, n - 1)\nans = 0\nfor m in range(k + 1):\n        tmp = comb(n, m) * binomial[n - 1] * inv[n - 1 - m] * inv[m]\n        ans += tmp % mod\nans %= mod\nprint(ans)", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nMOD = 10 ** 9 + 7\nsys.setrecursionlimit(20000000)\n\n\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        if n < r:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod\n        return modinv\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    answer = 0\n    if K >= N - 1:\n        cmb = Combination(2 * N + 1)\n        answer = cmb(N * 2 - 1, N - 1)\n\n    else:\n        cmb = Combination(N)\n        for i in range(K + 1):\n            answer += cmb(N, i) * cmb(N - 1, N - 1 - i)\n    print((answer % MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 2*(10**5)+1\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\na,b=map(int,input().split())\nc=min(a,b)\ns=0\nfor i in range(0,c+1):\n    s+=cmb(a,i,10**9+7)*cmb(a-1,i,10**9+7)\nprint(s%(10**9+7))", "n, K = list(map(int,input().split()))\n\nMOD = 10**9 + 7\nfac = [1 for k in range(200010)]\ninv = [1 for k in range(200010)]\nfinv = [1 for k in range(200010)]\nfor k in range(2,200010):\n    fac[k] = (fac[k-1]*k)%MOD\n    inv[k] = (MOD - inv[MOD%k] * (MOD // k))%MOD\n    finv[k] = (finv[k - 1] * inv[k]) % MOD;\ndef nCr(n,r):\n    return (fac[n]*finv[r]*finv[n-r])%MOD\n\nans = 0\nfor i in range(min(n,K+1)):\n    ans += nCr(n,i)*nCr(n-1,n-i-1)\n    ans %= MOD\n\nprint(ans)\n", "n, k = map(int, input().split())\nmod = 1000000007\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\nif k >=n:\n  L = 2*n-1\n  ansbunsi =1\n  for j in range(n-1):\n    ansbunsi = ansbunsi*L%mod\n    L -= 1\n  ansbunbo = 1\n  L = n - 1\n  for j in range(n-1):\n    ansbunbo = ansbunbo*L%mod\n    L -= 1\n  ansbunbo = modinv(ansbunbo)\n  print(ansbunsi*ansbunbo%mod)\n\nelse:\n  kaijou = [1, 1]\n  for j in range(2, n+1):\n    kaijou.append(kaijou[-1]*j%mod)\n  \n  ans = 0\n\n  for m in range(k+1):\n    ansbunsi = kaijou[n]*kaijou[n-1]%mod\n    ansbunbo = kaijou[m]*kaijou[n-m]%mod\n    ansbunbo = ansbunbo*kaijou[n-m-1]%mod\n    ansbunbo = ansbunbo*kaijou[m]%mod\n    ansbunbo = modinv(ansbunbo)\n    ans += ansbunbo*ansbunsi\n    ans %= mod\n  \n  print(ans)", "# comb_mod(n, c, r, mod, fac, den) \u2261 nCr\ndef prepare(n, mod):\n    # fac[i] \u2261 i!\n    fac = [1]\n    for i in range(1, n+1):\n        fac.append((fac[-1] * i) % mod)\n\n    # rec \u2261 1 / n!\n    rec = pow(fac[-1], mod-2, mod)\n\n    # den[i] \u2261 1 / i!\n    den = [1 for _ in range(n+1)]\n    den[n] = rec\n    for i in range(n-1, 0, -1):\n        rec = (rec * (i+1)) % mod\n        den[i] = rec\n    \n    return fac, den\n\ndef comb_mod(n, r, mod, fac, den):\n    return (fac[n] * den[r] * den[n - r]) % mod\n\nn, k = map(int, input().split())\nmod = 10**9 + 7\nfac, den = prepare(2*n-1, mod)\n\nif k >= n-1:\n    print(comb_mod(2*n-1, n, mod, fac, den))\nelse:\n    ans = 0\n    for i in range(k+1):\n        ans += comb_mod(n-1, i, mod, fac, den) * comb_mod(n, i, mod, fac, den)\n        ans %= mod\n    print(ans)", "n,k=list(map(int, input().split()))\n\n\ndef cmb(n, r, p):\n  if (r < 0) or (n < r):\n    return 0\n  r = min(r, n - r)\n  return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 2*(10 ** 5 ) # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p) \u968e\u4e57\u306emod\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528 \n\nfor i in range(2, N + 1):\n  fact.append((fact[-1] * i) % p)\n  inv.append((-inv[p % i] * (p // i)) % p)\n  factinv.append((factinv[-1] * inv[-1]) % p)\n\n#0\u306e\u6570\u304cmin(n-1,k)\nMAX=min(n-1,k)\n\ndp=[0]*(MAX+1)\ndp[0]=1\nans=1\nfor i in range(1,MAX+1):\n    ans+=cmb(n,i,p)*cmb(n-i+i-1,i,p)\n    ans%=p\n    #print(ans)\n\nprint(ans)\n", "n,k=map(int,input().split())\nmod=10**9+7\n\nMAX_N=10**6\nfact=[1]\nfact_inv=[0]*(MAX_N+4)\nfor i in range(MAX_N+3):\n  fact.append(fact[-1]*(i+1)%mod)\n\nfact_inv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(MAX_N+2,-1,-1):\n  fact_inv[i]=fact_inv[i+1]*(i+1)%mod\n\ndef f(n,k,mod):\n  return fact[n]*fact_inv[k]%mod*fact_inv[n-k] %mod\n\nans=0\n#0\u4eba\u306e\u90e8\u5c4b\u306fmax\u3044\u304f\u3064\u3067\u304d\u308b\u304b\na=min(k,n-1)\nans=0\nfor i in range(a+1):\n  d=f(n,i,mod)*f(n-1,i,mod)\n  #print(i,d)\n  ans+=d%mod\n  ans%=mod\n\nprint(ans)", "n, k = map(int, input().split())\nmod = 10**9+7\nif n <= k:\n    l = 2*n-1\n    inverse = [0, 1]\n    g = [1, 1]\n    for i in range(2, n):\n        l *= 2*n-i\n        l %= mod\n        inverse.append(-inverse[mod%i]*(mod//i)%mod)\n        g.append(g[-1]*inverse[-1]%mod)\n    print(l*g[-1]%mod)\nelse:\n    h = [1, 1]\n    g = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, 2*n+1):\n        h.append(h[-1]*i%mod)\n        inverse.append(-inverse[mod%i]*(mod//i)%mod)\n        g.append(g[-1]*inverse[-1]%mod)\n    comb = lambda a, b: h[a]*g[b]*g[a-b]%mod\n    # i\u624b\u304b\u3051\u306a\u3044\u3068\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u3084\u3064\n    t = [comb(n, i)*comb(n-1, i)%mod for i in range(k+1)]\n    print(sum(t)%mod)", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\n#from itertools import combinations\ndef run():\n    n,k = map(int, input().split())\n    mod = 10 ** 9 + 7\n    ret = 0\n    inv = generate_inv(n, mod)\n\n    if k >= n-1:\n        k = n-1\n    left = 1\n    right = 1\n    ret = 1\n    for h in range(1, k+1):\n        right *= (n - h) * inv[h]\n        right %= mod\n        left *= (n - h + 1) * inv[h]\n        left %= mod\n        ret += right * left\n        ret %= mod\n    print(ret)\n\n\ndef generate_inv(n,mod):\n    \"\"\"\n    \u9006\u5143\u884c\u5217\n    n >= 2\n    \"\"\"\n    ret = [0, 1]\n    for i in range(2,n+1):\n        next = -ret[mod%i] * (mod // i)\n        next %= mod\n        ret.append(next)\n    return ret\n\n\ndef comb_mod(n, a, mod):\n    \"\"\"\n    return: [n, a] % mod\n    Note: mod must be a prime number\n    \"\"\"\n    up = 1\n    down = 1\n    for i in range(a):\n        up *= n - i\n        up %= mod\n        down *= i + 1\n        down %= mod\n    down = pow_mod(down, mod - 2, mod)\n    return (up * down) % mod\n\ndef pow_mod(n, k, mod):\n    res = 1\n    while True:\n        if k // 2 >= 1:\n            if k % 2 == 1:\n                res = (res * n) % mod\n            n = (n ** 2) % mod\n            k = k // 2\n        else:\n            break\n    return (n * res) % mod\n\n\ndef __starting_point():\n    run()\n__starting_point()", "N, K = map(int, input().split())\nK = min(N-1, K)\nfact = [1 for _ in range(200001)]\ninv = [1 for _ in range(200001)]\nfact_inv = [1 for _ in range(200001)]\nmod = 10**9+7\nfor i in range(2, 200001):\n    fact[i] = (fact[i-1]*i) % mod\n    inv[i] = mod - (inv[mod % i] * (mod // i)) % mod\n    fact_inv[i] = (fact_inv[i-1] * inv[i]) % mod\n\ndp = [0] * N\nfor i in range(N):\n    f1 = (fact[N] * fact_inv[N-i] * fact_inv[i]) % mod  \n    f2 = (fact[N-1] * fact_inv[N-i-1] * fact_inv[i]) % mod \n    f = (f1*f2)%mod\n    if i == 0:\n        dp[i] = f\n    else:\n        dp[i] = (dp[i-1] + f) % mod\nprint(dp[K])", "n, k = list(map(int, input().split()))\np = 10**9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append(-inv[p % i] * (p // i) % p)\n    factinv.append(factinv[-1] * inv[-1] % p)\n\ndef cmb(n, r, p):\n    if n < r:\n        return 0\n    else:\n        r = min(r, n - r)\n        return((fact[n] * factinv[r] * factinv[n - r]) % p)\n\nres = []\nfor i in range(n):\n    res.append((cmb(n, i, p) * cmb(n - 1, i, p)) % p)\n\nif n > k:\n    print((sum(res[:k + 1]) % p))\nelse:\n    print((sum(res) % p))\n", "def solve():\n    mod = 10**9+7\n    n, k = list(map(int, input().split()))\n    m = min(n-1,k)\n    ans = 1\n    dp0 = [1]*(m+1)\n    dp1 = [1]*(m+1)\n    for i in range(1,m+1):\n        dp0[i] = dp0[i-1]*(n-i+1)*pow(i,mod-2,mod)%mod\n        dp1[i] = dp1[i-1]*(n-i)*pow(i,mod-2,mod)%mod\n        ans += dp0[i]*dp1[i]%mod\n        ans %= mod\n    return ans\nprint((solve()))\n", "def nCr_frL(n,r,mod):\n    ret=[1,n%mod]\n    for i in range(2,r+1):\n        inv=pow(i,mod-2,mod)\n        ret.append((ret[-1]*(n-i+1)*inv)%mod)\n    return ret\n\nN,K=list(map(int,input().split()))\nMOD=10**9+7\ncom1=nCr_frL(N,N,MOD) # nCi\ncom2=nCr_frL(N-1,N-1,MOD) # n-1Ci\n\nif K>N-1:\n    K=N-1\nans=0\nfor m in range(K+1):\n    ans+=(com1[m]*com2[N-m-1])%MOD\nprint((ans%MOD))\n\n", "SIZE=4*10**5+1; MOD=10**9+7 #998244353 #\u3053\u3053\u3092\u5909\u66f4\u3059\u308b\n \nSIZE += 1\ninv = [0]*SIZE  # inv[j] = j^{-1} mod MOD\nfac = [0]*SIZE  # fac[j] = j! mod MOD\nfinv = [0]*SIZE # finv[j] = (j!)^{-1} mod MOD\ninv[1] = 1\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,SIZE):\n    inv[i] = MOD - (MOD//i)*inv[MOD%i]%MOD\n    fac[i] = fac[i-1]*i%MOD\n    finv[i]= finv[i-1]*inv[i]%MOD\n \ndef choose(n,r): # nCk mod MOD \u306e\u8a08\u7b97\n    if 0 <= r <= n:\n        return (fac[n]*finv[r]%MOD)*finv[n-r]%MOD\n    else:\n        return 0\n \ndef chofuku(ball,box): # nHk mod MOD \u306e\u8a08\u7b97\n    return choose(box+ball-1,box)\n\n\n\nN,K=list(map(int,input().split()))\nans=0\nfor i in range(min(N,K+1)):\n    ans+=choose(N,i)*chofuku(N-i,i)%MOD\n\nprint((ans%MOD))\n\n", "n, k = map( int, input().split() )\nmod = 10 ** 9 + 7\n \nnumer = [ 1 ] * ( n + 1 )\ndemon = [ 1 ] * ( n + 1 )\n \nfor i in range( 1, n + 1 ):\n  numer[ i ] = numer[ i - 1 ] * i % mod\n\ndemon[ n ] = pow( numer[ n ], mod - 2, mod )\nfor i in range( n, 0, -1 ):\n  demon[ i - 1 ] = ( demon[ i ] * i ) % mod\n\ndef nCr( n, r ):\n  if r < 1:\n    return 1\n  return ( numer[ n ] * demon[ r ] % mod ) * demon[ n - r ] % mod\n \nans = 0\nfor i in range( min( k, n - 1) + 1 ):\n  ans = ( ans + nCr( n, i ) * nCr( n - 1, i )) % mod\nprint( ans )", "n, k = map(int, input().split())\nmod = 10**9 + 7\n\nlist_size = 4*10**5 + 1\n \nf_list = [1] * list_size\nf_r_list = [1] * list_size\n \nfor i in range(list_size-1):\n\tf_list[i+1] = (f_list[i] * (i+1)) % mod\n \nf_r_list[-1] = pow(f_list[-1], mod - 2, mod)\n \nfor i in range(list_size-2, -1, -1):\n\tf_r_list[i] = (f_r_list[i+1] * (i+1)) % mod\n \ndef comb(n, r, mod):\n\tif n < r or r < 0:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (f_list[n] * f_r_list[n-r] * f_r_list[r]) % mod\n\n\nif k < n-1:\n    ans = 0\n    for i in range(k+1):\n        ans += (comb(n-1, i, mod)*comb(n, i, mod))%mod\n    print(ans%mod)\nelse:\n    print((comb(2*n-1, n, mod))%mod)", "n, k = list(map(int, input().split()))\nmod = 1000000007\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\nif k >=n:\n  L = 2*n-1\n  ansbunsi =1\n  for j in range(n-1):\n    ansbunsi = ansbunsi*L%mod\n    L -= 1\n  ansbunbo = 1\n  L = n - 1\n  for j in range(n-1):\n    ansbunbo = ansbunbo*L%mod\n    L -= 1\n  ansbunbo = modinv(ansbunbo)\n  print((ansbunsi*ansbunbo%mod))\n\nelse:\n  kaijou = [1, 1]\n  for j in range(2, n):\n    kaijou.append(kaijou[-1]*j%mod)\n  \n  ans = 0\n\n  for m in range(k+1):\n    ansbunsi = (kaijou[n-1]**2)*n%mod\n    ansbunbo = kaijou[n-m-1]*kaijou[m]%mod\n    ansbunbo = ansbunbo*ansbunbo%mod*(n-m)%mod\n    ansbunbo = modinv(ansbunbo)\n    ans += ansbunbo*ansbunsi%mod\n    ans %= mod\n  \n  print(ans)\n    \n", "from collections import defaultdict as dd\nN,k = map(int, input().split())\n\n# 0\u4eba\u306e\u90e8\u5c4b\u304ct\u500b\u3042\u308b\u3068\u3059\u308b\u3068\u3001n-t\u500b\u306e\u90e8\u5c4b\u306bn\u4eba\u304c\u3044\u308b\u3002\n# k!=1\u306e\u3068\u304d0<=t<=min(k, n-1)\n# k==1\u306e\u3068\u304dt=1\nres = 0\nfact = [0]*(N+1)\nifact = [0]*(N+1)\ninv = [0]*(N+1)\np=10**9+7\n\ndic = dd(int)\n\ndef combination(n,fact,ifact):\n    fact[0] = 1\n    fact[1] = 1\n    ifact[0] = 1\n    ifact[1] = 1\n    inv[1] = 1\n    for i in range(2,n+1):\n        fact[i] = (fact[i-1]*i)%p\n        inv[i] = p - inv[p%i]*(p//i)%p\n        ifact[i] = (ifact[i-1]*inv[i])%p\ndef op(n,k):\n    if (n,k) in dic.keys():\n        return dic[(n,k)]\n    if k<0 or k>n or n<0:\n        return 0\n    dic[(n,k)] = (fact[n]*ifact[k]*ifact[n-k])%(10**9+7)\n    return dic[(n,k)]\n\ncombination(N,fact,ifact)\nfor t in range(0, min(k, N-1)+1):\n    # n-t\u500b\u306e\u90e8\u5c4b\u306bn\u4eba\u3092\u5165\u308c\u308b\u3002\u305f\u3060\u3057\u3001\u3069\u306e\u90e8\u5c4b\u306b\u30821\u4eba\u4ee5\u4e0a\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n    # n\u500b\u306e\u90e8\u5c4b\u306e\u3046\u3061\u3069\u306et\u500b\u30920\u4eba\u306b\u3059\u308b\u304b\u3067nCt\n    # n-t\u500b\u306e\u90e8\u5c4b\u306e\u4eba\u6570\u3067n-1Cn-t-1\n    res += (op(N-1, N-t-1) * op(N, t))%p\nprint(res%p)", "n, k = map(int, input().split())\nmod = 10**9 + 7\n\nm = 4*10**5 + 500\n\nfac = [1] * (m + 1)\nfacinv = [1] * (m + 1)\nfor i in range(1, m+1):\n    fac[i] = (fac[i-1] * i) % mod\n    facinv[i] = (facinv[i-1] * pow(i, -1, mod)) % mod\n\ndef nCk(n, k):\n    return (fac[n] * facinv[k] * facinv[n-k]) % mod\n\nif k > (n - 2):\n    print(nCk(2*n-1, n))\nelse:\n    ans = 0\n    for i in range(k+1):\n        ans = (ans + nCk(n-1, i) * nCk(n, i)) % mod\n    print(ans)", "M=10**9+7\nn,k=map(int,input().split())\na=c=p=1\nfor i in range(1,min(n,k+1)):\n  c=c*(n-i+1)*(n-i)%M\n  p=p*i*i%M\n  a+=c*pow(p,M-2,M)\nprint(a%M)", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\ndef solve():\n    N, K = Scanner.map_int()\n\n    MOD = int(1e09) + 7\n    MAX = 200010\n    fac = [0] * MAX\n    finv = [0] * MAX\n    inv = [0] * MAX\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    def cmb(n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\n    ans = 0\n    for m in range(0, min(K, N - 1) + 1):\n        a = cmb(N, m)\n        b = cmb(N - 1, m)\n        ans += a * b\n        ans %= MOD\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\nMOD = int(1e09) + 7\n# INF = int(1e15)\n\n\ndef solve():\n    MAX = 2 * 10 ** 5 + 10\n    fac = [0] * MAX\n    inv = [0] * MAX\n    finv = [0] * MAX\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i - 1]*i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    def cmb(n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n    N, K = Scanner.map_int()\n    ans = 0\n    for i in range(min(N - 1, K) + 1):\n        ans += cmb(N, i) * cmb(N - 1, i)\n        ans %= MOD\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "MOD = 10**9 + 7\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % MOD\n            self.inv[i] = -self.inv[MOD % i] * (MOD // i) % MOD\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % MOD\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nN, K = list(map(int, input().split()))\nK = min(K, N)\nMOD = 10**9 + 7\ncomb = Combination(N + 100)\n\nans = 0\nfor k in range(K + 1):\n    ans += comb.ncr(N, k) * comb.nhr(N - k, k)\n    ans %= MOD\n\nprint(ans)\n", "n,k=list(map(int,input().split()))\nmod=10**9+7\ndef inv(x):\n    return pow(x,mod-2,mod)\nN=2*10**5\nFact=[0 for i in range(N+1)]\nFinv=[0 for i in range(N+1)]\nFact[0]=1\nfor i in range(N):\n    Fact[i+1]=(Fact[i]*(i+1))%mod\nFinv[N]=inv(Fact[N])\nfor i in range(N-1,-1,-1):\n    Finv[i]=((i+1)*Finv[i+1])%mod\ndef C(a,b):\n    return (Fact[a]*(Finv[b]*Finv[a-b])%mod)%mod\nans=0\nfor i in range(min(n,k+1)):\n    ans+=(C(n,i)*C(n-1,i))%mod\n    ans%=mod\nprint(ans)\n", "n, k = list(map(int, input().split()))\nMOD = 10**9+7\n\ndef prepare(n, MOD):\n    facts = [1]*(n+1)\n    for i in range(1, n+1):\n        facts[i] = facts[i-1]*i%MOD\n    invs = [1]*(n+1)\n    _invs = [1]*(n+1)\n    invs[n] = pow(facts[n], MOD-2, MOD)\n    for i in range(0, n)[::-1]:\n        invs[i] = invs[i+1] * (i+1) % MOD\n    return facts, invs\n\nans = 0\nfacts, invs = prepare(n, MOD)\n\nfor i in range(1+min(n-1, k)):\n    ans += facts[n]*invs[i]*invs[n-i]*facts[n-1]*invs[n-i-1]*invs[i]\n    ans %= MOD\n\nprint(ans)\n", "n, k = list(map(int,input().split()))\nmod = 10**9+7\n\n#nCr\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\u3002N\u306b\u6700\u5927\u5024\u3092\u5165\u308c\u3066\u4f7f\u7528\u3002\nN = n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\ndef cmb(n,r,mod):\n    if r<0 or r>n :\n        return 0\n    r = min(r,n-r)\n    return g1[n]*g2[r]*g2[n-r]%mod\nfor i in range(2,N+1):\n    g1.append((g1[-1]*i)%mod)\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g2.append((g2[-1]*inverse[-1])%mod)\n\nans = 0\nfor i in range(min(n-1,k)+1):\n    di = cmb(n,i,mod)*cmb(n-1,i,mod)%mod\n    ans = (ans+di)%mod\n\nprint(ans)\n", "# 0\u4eba\u306b\u306a\u308b\u90e8\u5c4b\u306e\u6570\n# \u30fb\u6700\u5c0f0 (k = 1\u3000\u306a\u3044\u3057\u306f\u3000N = 2 and k = 3\u304c\u5236\u7d04\u5916\u306a\u306e\u3067\u5fc5\u305a0\u306b\u306a\u308b)\n# \u30fb\u6700\u5927 min(k,N-1) (k\u4eba\u304c\u90e8\u5c4b\u3092\u7a7a\u306b\u51fa\u6765\u308b\u304c\u30011\u90e8\u5c4b\u306f\u5fc5\u305a\u7a7a\u3067\u306a\u3044\u90e8\u5c4b\u304c\u6b8b\u308b)\n# min(k,N-1)\u90e8\u5c4b\u304c\u7a7a\u306b\u306a\u308b\u3068\u3044\u3046\u3053\u3068\u306f\u3001N-min(k,N-1)\u90e8\u5c4b\u306b\u306f\u5fc5\u305a\u4eba\u304c\u3044\u308b\n# \u7a7a\u3067\u306a\u3044\u90e8\u5c4b\u306e\u6700\u5927\u6570\u306fN - K\n# N - K - 1\u90e8\u5c4b\u306b\u5272\u308a\u632f\u308b\u30d1\u30bf\u30fc\u30f3\u306f\u3042\u308a\u5f97\u306a\u3044\n# \u3064\u307e\u308aN-min(k,N-1)-1\u90e8\u5c4b\u306b\u4eba\u304c\u3044\u308b\u30b1\u30fc\u30b9\u306f\u3042\u308a\u5f97\u306a\u3044\n# N\u4eba\u3092N\u90e8\u5c4b\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u304b\u3089\u3001\n# N\u4eba\u3092N-min(k,N-1)-1\u90e8\u5c4b\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u3092\u5f15\u304f\n# \u3044\u305a\u308c\u30820\u306e\u5834\u5408\u3092\u542b\u3080\n# N\u500b\u3092K\u7bb1\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u306f\u3001N+K-1 C N\n\nDIV = 10 ** 9 + 7\nn = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % DIV )\n    inverse.append( ( -inverse[DIV % i] * (DIV//i) ) % DIV )\n    g2.append( (g2[-1] * inverse[-1]) % DIV )\n\ndef nCr(n, r, DIV):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % DIV\n\nN,K = map(int,input().split())\n\n# N\u4eba\u3092N\u90e8\u5c4b\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u304b\u3089\u3001\n# N\u4eba\u3092N-min(k,N-1)-1\u90e8\u5c4b\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u3092\u5f15\u304f\n# \u3044\u305a\u308c\u30820\u306e\u5834\u5408\u3092\u542b\u3080\n# N\u500b\u3092K\u7bb1\u306b\u5272\u308a\u632f\u308b\u5834\u5408\u306e\u6570\u306f\u3001N+K-1 C N\n\nans = 0\nfor i in range(min(K,N-1) + 1):\n  a = nCr(N,i,DIV)\n  \n  # N-i\u500b\u306e\u90e8\u5c4b\u306bN\u500b\u306e\u30dc\u30fc\u30eb\u3092\u8a70\u3081\u308b\n  # N\u500b\u306e\u3046\u3061\u306eN-i\u500b\u3092\u307e\u305a1\u500b\u305a\u3064\u8a70\u3081\u308b\n  # \u6b8b\u308a\u306fN - (N - i) = i\u500b\n  # i\u500b\u306e\u30dc\u30fc\u30eb\u3092N-i\u500b\u306b\u8a70\u3081\u308b\u3002i\u500b\u3068(N-i-1)\u500b\u306e\u4ed5\u5207\u308a\u306e\u4e26\u3073\u66ff\u3048\n  # (i + N - i - 1) C i = (N-1) C i\n  b = nCr(N-1,i,DIV)\n  \n  ans += (a * b) % DIV\n  ans %= DIV\n  \nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    k = min(k, n - 1)\n    cb = CmbMod(n + 1, mod)\n    cb.prep()\n    res = 0\n    for i in range(k + 1):\n        res += (cb.cmb_mod_with_prep(n, i) * cb.cmb_mod_with_prep(n - 1, i)) % mod\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq\n\nn,k = list(map(int, input().split()))\n\n# C,P\u3092\u6c42\u3081\u308b\u524d\u51e6\u7406\nm = 4*10**5\nmod = 10**9 + 7\n\n\nfact = [0]*(m+5)\nfact_inv = [0]*(m+5)\ninv = [0]*(m+5)\n\nfact[0] = fact[1] = 1\nfact_inv[0] = fact_inv[1] = 1\ninv[1] = 1\n\nfor i in range(2,m+5):\n    fact[i] = fact[i-1] * i % mod\n    inv[i] = mod - inv[mod % i] * (mod // i) % mod\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n# nCk\u3092mod\uff08\u7d20\u6570\uff09\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\uff0e\u305f\u3060\u3057n<10**7\n# \u524d\u51e6\u7406\u306fm=n+5\u307e\u3067\ndef cmb(n,k,mod):\n    return fact[n] * (fact_inv[k] * fact_inv[n-k] % mod) % mod\n\nif k >= n-1:\n    print((cmb(2*n-1, n-1, mod)%mod))\nelse:\n    ans = 0\n    for i in range(0,k+1):\n        ans += cmb(n,i,mod)*cmb(n-1,n-i-1,mod)%mod\n        ans %= mod\n    print(ans)\n\n\n\n\n", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\na,b=map(int,input().split())\nmod=(10**9)+7\nif b>=a-1:\n  print(cmb((2*a)-1, a,mod))\nelse:\n  ans=0\n  for i in range(1,b+1):\n    ans+=cmb(a, i,mod)*cmb(a-1, a-i-1,mod)\n  if b!=1:\n    ans+=1\n  print(ans%mod)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        if n < r:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod\n        return modinv\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    comb = Combination(n_max=10 ** 5 * 4 + 10)\n\n    if N <= K:\n        ans = comb(2 * N - 1, N)\n    else:\n        if K == 1:\n            ans = comb(N, 1) * comb(N - 1, 1)\n        else:\n            ans = 0\n            # m\u306f\u30bc\u30ed\u3068\u306a\u308b\u6570\n            for m in range(K + 1):\n                ans += comb(N, m) * comb(N - 1, m)\n                ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n    def factorial(self, n):\n        return self.fact[n]\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, K = list(map(int, input().split()))\n    K = min(K, N - 1)  # K=\u6700\u5927\u7a7a\u5ba4\u6570->N\u90e8\u5c4b\u7a7a\u5ba4\u306f\u4e0d\u53ef\u80fd\n\n    calc = Calc(max_value=N * 2, mod=MOD)\n\n    ans = 0\n    for v in range(K + 1):  # \u7a7a\u5ba4\u6570\n        ans = (ans + (calc.combination(N, v) * calc.combination(v + (N - v) - 1, v)) % MOD) % MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nN_MAX = 200000 + 5\nsys.setrecursionlimit(N_MAX)\nMOD = 10**9 + 7\n\n# ## COMBINATION (MOD) ## #\n\nfac = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\nfacinv = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 1):\n    fac.append((fac[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    facinv.append((facinv[-1] * inv[-1]) % MOD)\n\n\ndef cmb(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[r] * facinv[n - r] % MOD\n\n\ndef main():\n    n, k = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    k = min(n, k)\n\n    ans = 0\n    for m in range(k+1):\n        empty = cmb(n, m)\n        member = cmb(n - 1, n - m - 1)\n        ans += (empty * member) % MOD\n        ans %= MOD\n\n    print(ans)\n\n\nmain()\n", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef main():\n    # nCr\u306e\u5de6\u9805\u306b\u306fn\u4ee5\u5916\u3082\u6765\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u30011!\uff5e(n-1)!\u3092\u4fdd\u6301\n    def prepare(n, MOD):\n        # 1! - n! \u306e\u8a08\u7b97\n        f = 1\n        factorials = [1]  # 0!\u306e\u5206\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        # n!^-1 \u306e\u8a08\u7b97\n        inv = pow(f, MOD - 2, MOD)\n        # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n\n        return factorials, invs\n\n    n, k = ns()\n    facts, invs = prepare(n, MOD)\n\n    ans = 0\n    for ki in range(min(n, k + 1)):\n        zero_comb = facts[n] * invs[ki] * invs[n - ki] % MOD\n        nonzero_comb = facts[n - 1] * invs[ki] * invs[n - 1 - ki] % MOD\n        ans += zero_comb * nonzero_comb % MOD\n        ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "M=10**9+7;n,k=map(int,input().split());a=c=1\nfor i in range(1,min(n,k+1)):m=n-i;c=c*-~m*m*pow(i,M-2,M)**2%M;a+=c\nprint(a%M)", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nimport numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [input() for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\nn,k = map(int,input().split())\nMOD = 10**9 + 7\ndef comb(n, k, mod):\n    if n<0 or k<0 or n<k:\n        return 0\n    if n==0 or k==0:\n        return 1\n    k=k if k<=n-k else n-k\n    x = 1\n    y = 1\n    for i in range(k):\n        x=x*(n-i)%mod\n        y=y*(i+1)%mod\n    return (x*pow(y,mod-2,mod))%mod\n#\u3053\u3063\u3061\u306f\u8a08\u7b97\u91cfO(N)\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\nfor i in range(2, 2*n+1):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD) \ndef comb_mod(n, r, m):\n    if (n<0 or r<0 or n<r): return 0\n    r = min(r, n-r)\n    return fac[n] * finv[n-r] * finv[r] % m\nif k >= n-1:\n    ans = comb_mod(2*n-1,n,MOD)\n    print(ans%MOD)\nelif k == 1:\n    print(n*(n-1)%MOD)\nelse:\n    ans = 0\n    for i in range(k+1):\n        ans += comb_mod(n-1,i,MOD)*comb_mod(n,i,MOD)\n    print(ans%MOD)", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7\nsize = 4*10**5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n\nfor i in range( 2, size + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nn, k = map(int,input().split())\n\nk = min(k, n-1)\n\nans = 0\n\nfor m in range(k+1):\n    ans += cmb(n, m, mod) * cmb(n-1, n-m-1, mod)\n\nans %= mod\n\nprint(ans)", "def cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\nmod = 10**9+7  # \u51fa\u529b\u306e\u5236\u9650\nN, K = list(map(int, input().split()))\nn = N*2\nr = min(N, K+1)\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, n + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\nans = 0\nfor i in range(r):\n    ans += cmb(N, i, mod) * cmb(N-1, i, mod)\nif K == 1:\n    ans -= 1\nprint((ans % mod))\n", "M=10**9+7\nn,k=map(int,input().split())\nl=[1]\nf=1\nfor i in range(n):\n  f=f*(i+1)%M\n  l+=[f]\na=0\nfor i in range(min(n,k+1)):\n  c=p=1\n  c=c*l[n]*l[n-1]%M\n  p=p*l[i]**2*l[n-i]*l[n-i-1]%M\n  a+=c*pow(p,M-2,M)\nprint(a%M)", "U = 2 * 10 ** 5\nmod = 10 ** 9 + 7\n\n\nclass Combination:\n    \"\"\"\n    SIZE\u304c10^6\u7a0b\u5ea6\u4ee5\u4e0b\u306e\u4e8c\u9805\u4fc2\u6570\u3092\u4f55\u56de\u3082\u547c\u3073\u51fa\u3057\u305f\u3044\u3068\u304d\u306b\u4f7f\u3046\n    \u4f7f\u3044\u65b9:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    N, K = map(int, input().split())\n    comb = Combination(U + 5, mod)\n\n    ans = 1\n    for i in range(1, min(K + 1, N)):\n        vacant = comb(N, i)\n        person = comb(N - 1, i)\n        ans = (ans + vacant * person % mod) % mod\n    print(ans)\n__starting_point()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    n, k = list(map(int, readline().split()))\n\n    COM_MAX = n\n\n    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n\n    for i in range(2, COM_MAX + 1):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    def com(n, r):\n        if n < 0 or r < 0 or n < r:\n            return 0\n        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD\n\n    ans = 0\n    for r in range(min(n, k + 1)):\n        ans = (ans + com(n, r) * com(n - 1, r)) % MOD\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "MOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\n\ndef getFacts(n, MOD):\n    facts = [1] * (n+1)\n    for x in range(2, n+1):\n        facts[x] = (facts[x-1] * x) % MOD\n    return facts\nfacts = getFacts(2*N, MOD)\ndef getInvFacts(n, MOD):\n    invFacts = [0] * (n+1)\n    invFacts[n] = pow(facts[n], MOD-2, MOD)\n    for x in reversed(list(range(n))):\n        invFacts[x] = (invFacts[x+1] * (x+1)) % MOD\n    return invFacts\ninvFacts = getInvFacts(2*N, MOD)\ndef getComb(n, k, MOD):\n    if n < k:\n        return 0\n    return facts[n] * invFacts[k] * invFacts[n-k] % MOD\n\nans = 0\nfor x in range(min(K, N-1)+1):\n    ans += getComb(N, x, MOD) * getComb(N-1, x, MOD)\n    ans %= MOD\n\nprint(ans)\n", "n, k = list(map(int, input().split()))\nmod = 1000000007\nfac = [1]\ninv = [1]\nfor i in range(n * 2):\n    fac.append(fac[-1] * (i + 1) % mod)\n    inv.append(pow(fac[-1], mod - 2, mod))\n\n\ndef cmb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return ((fac[n] * inv[k]) % mod * inv[n - k]) % mod\n\n\nret = 0\nfor m in range(min(k + 1, n)):\n    ret = (ret + (cmb(n, m) * cmb(n - 1, n - m - 1)) % mod) % mod\nprint(ret)\n", "def main():\n    N, k = map(int, input().split())\n\n    MAX_N = 3 * 10 ** 5\n    MOD = 10 ** 9 + 7\n    fac = [0]*MAX_N\n    inv = [0]*MAX_N\n    finv = [0]*MAX_N\n    fac[0] = 1; fac[1] = 1\n    inv[1] = 1\n    finv[0] = 1; finv[1] = 1\n\n    def com_init():\n        for i in range(2, MAX_N):\n            fac[i] = fac[i-1] * i % MOD\n            inv[i] = -(MOD//i)*inv[MOD%i]%MOD\n            finv[i] = finv[i-1]*inv[i]%MOD\n\n    def com(n, k):\n        if n < 0:return 0\n        elif k > n: return 0\n        \n        return (fac[n]*finv[n-k]%MOD)*finv[k]%MOD\n    \n    k = min(k, N-1)\n    ans = 1\n    com_init()\n    for i in range(1, k+1):\n        ans += com(N, i)*com(N-1, N-i-1)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    k = min(n - 1, k)\n    cmb = CmbMod(n, mod)\n    cmb.prep()\n    res = 0\n    for i in range(k + 1):\n        res += (cmb.cmb_mod_with_prep(n, i) * cmb.cmb_mod_with_prep(n - 1, i)) % mod\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10000000)\ninput=sys.stdin.readline\nmod = 10 ** 9 + 7\n\nn,k = list(map(int,input().split()))\n\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nfor i in range(1,n+1):\n  fac[i] = (fac[i-1]*i) % mod  \ninv[n] = pow(fac[n], mod-2, mod)\nfor i in range(n, 0, -1):\n  inv[i-1] = (inv[i]*i) % mod\n    \ndef cmb(n, r):\n  if r < 0 or r > n: return 0\n  return (((fac[n] * inv[r])%mod) * inv[n-r]) % mod\n \n\n\nans=0\nk=min(k,n-1)\nfor i in range(k+1):\n    ans += cmb(n,i) * cmb(n-1,i) %mod\n\nprint((ans%mod))\n", "n,k = list(map(int, input().split()))\nmod = int(1e9+7)\n\n\n\ndef init_cmb(Nmax):\n    #mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range(2, Nmax + 1):\n        g1.append((g1[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        g2.append((g2[-1] * inverse[-1]) % mod)\n    return g1, g2\n\ng1,g2 = init_cmb(n+10)\n\ndef cmb(n, r, modn=mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % modn\n  \n# ci = 0 \u3067\u3042\u308b\u500b\u6570\u304c m \u3068\u306a\u308b\u3088\u3046\u306a\u6570\u5217\u306e\u6570\u306f\u3001 nCm \u00d7n\u2212m Hm = nCm * n-1Cn-m-1\n# 0 <= m < n \u3067\u8db3\u7b97\u3059\u308b\n\nans = 0\nfor i in range(min(k+1,n)):\n  wk = cmb(n,i) * cmb(n-1, n-i-1) % mod\n  ans = (ans + wk ) % mod\n  \nprint(ans)", "n,k = list(map(int, input().split()))\nmod = 10**9+7\n\ndef prepare():\n    fact = []\n    f = 1\n    for m in range(1, n):\n        f *= m\n        f %= mod\n    fact.append(f)\n    f *= n\n    f %= mod\n    fact.append(f)\n    \n    factinv = [1, 1]\n    inv = [0, 1]\n\n    for i in range(2, n + 1):\n        inv.append((-inv[mod % i] * (mod // i)) % mod)\n        factinv.append((factinv[-1] * inv[-1]) % mod)\n\n    return fact, factinv\n\ndef cmb(a, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    if a == 1:\n        return f[a] * v[r] * v[n - r] % mod\n    else:\n        return f[a] * v[r] * v[n - r - 1] % mod\n\nf,v = prepare()\n\nans = 1\nfor i in range(1, min(k + 1, n)):\n    ans += cmb(0, i, mod) * cmb(1, i, mod)\n    ans %= mod\n\nprint(ans)\n", "from sys import stdin\n#\u5165\u529b\nreadline=stdin.readline\nN,K=map(int,readline().split())\n\nmod=10**9+7\nfact=[1]*(2*N)\nfinv=[1]*(2*N)\ninv=[1]*(2*N)\ninv[0]=0\nfor i in range(2,2*N):\n    fact[i]=(fact[i-1]*i%mod)\n    inv[i]=(-inv[mod%i]*(mod//i))%mod\n    finv[i]=(finv[i-1]*inv[i])%mod\n\ndef com(N,K,mod):\n    if (K<0) or (N<K):\n        return 0\n    return fact[N]*finv[K]*finv[N-K]%mod\n\nif N-1<=K:\n    print(com(2*N-1,N,mod))\n\nelse:\n    res=0\n    for m in range(K+1):\n        res+=com(N,m,mod)*com(N-1,m,mod)\n        res%=mod\n    print(res)", "M=10**9+7\nn,k=map(int,input().split())\nl=[1]\nf=1\nfor i in range(n):\n  f=f*(i+1)%M\n  l+=[f]\na=0\nfor i in range(min(n,k+1)):\n  c=l[n]*l[n-1]%M\n  p=l[i]**2*l[n-i]*l[n-i-1]%M\n  a+=c*pow(p,M-2,M)\nprint(a%M)", "\"\"\"\nhttps://www.planeta.tokyo/entry/5195/\n\"\"\"\ndef cmb(n, r, p=10**9+7):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10**9+7\nn = 2*10**5+1  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n\nN,k = map(int,input().split())\n\n##\u79fb\u52d5\u304c\u8d77\u304d\u305f\u3068\u3057\u3066,\u90e8\u5c4b\u306b\u3044\u308b\u4eba\u6570\u306f\u9ad8\u3005min(N,k)\u4eba\u3067\u3042\u308b\n\nans = 0\nmod = 10**9 + 7\nfor i in range(1,min(N,k)+1):\n    ans += cmb(N,i)*cmb(N-1,i)\n\nprint(ans%mod+1)", "#\u90e8\u5c4b\u306b\u3044\u308b\u4eba\u6570\u304c\uff10\u306e\u7d44\u307f\u5408\u308f\u305b\uff08nCi\uff09\u3068\uff10\u3067\u306a\u3044\u90e8\u5c4b\u306b\u3044\u308b\u4eba\u6570\u306e\u7d44\u307f\u5408\u308f\u305b\uff08(n-1)Ci\uff09\u306e\u7a4d\u3067\u6c42\u3081\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\n\n\nN, K = list(map(int, input().split()))\nK = min(N-1, K)\nfact = [1 for _ in range(200001)]\ninv = [1 for _ in range(200001)]\nfact_inv = [1 for _ in range(200001)]\nmod = 10**9+7\n\n\nfor i in range(2, 200001):\n    fact[i] = (fact[i-1]*i) % mod\n    inv[i] = mod - (inv[mod % i] * (mod // i)) % mod\n    fact_inv[i] = (fact_inv[i-1] * inv[i]) % mod\n\n\ndp = [0] * N\n\nfor i in range(N):\n    #nCi\u3092\u6c42\u3081\u308b\n    f1 = (fact[N] * fact_inv[N-i] * fact_inv[i]) % mod  \n\n    #(n-1)Ci\u3092\u6c42\u3081\u308b\n    f2 = (fact[N-1] * fact_inv[N-i-1] * fact_inv[i]) % mod \n\n    #\u7a4d\u306e\u8a08\u7b97\n    f = (f1*f2)%mod\n    \n    if i == 0:\n        dp[i] = f\n    else:\n        dp[i] = (dp[i-1] + f) % mod\n\n\nprint((dp[K]))\n", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n# K\u56de\u306e\u79fb\u52d5\u304c\u7d42\u308f\u3063\u305f\u5f8c\u3001\u4eba\u304c\u3044\u308b\u90e8\u5c4b\u306e\u6570\u306fN\u304b\u3089N-K\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 6  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\nN, K = lr()\nanswer = 0\nfor x in range(N, max(0, N-K-1), -1):\n    # x\u500b\u306e\u5bb6\u306b\u306f1\u4eba\u4ee5\u4e0a\u3044\u308b\u306e\u3067\u3053\u306e\u4eba\u305f\u3061\u306f\u9664\u304f\n    can_move = N - x\n    # x-1\u306e\u58c1\u3092can_move+1\u306e\u5834\u6240\u306b\u5165\u308c\u308b\n    answer += cmb(N, x) * cmb(x - 1 + can_move, can_move)\n    answer %= MOD\n    \nprint((answer % MOD))\n# 31\n", "def cmb(n, r, mod):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%mod\n\n\nmod = 10**9+7\nN = 10**6  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%mod)\n\tinv.append((-inv[mod%i]*(mod//i))%mod)\n\tfactinv.append((factinv[-1]*inv[-1])%mod)\n\nn, k = map(int,input().split())\nans = 0\n\nfor i in range(0, min(n, k+1)):\n\t#0\u304ci\u500b\n\tans = (ans + cmb(n, i, mod) * cmb(n-1, i, mod)) % mod\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    N, K = list(map(int, input().strip().split()))\n    return N, K\n\n\ndef binom_preprocess(n, MOD=10**9+7):\n    f = [0 for i in range(n+1)]  # n!\n    invf = [0 for i in range(n+1)]  # (n!)^-1\n    f[0] = 1\n    f[1] = 1\n    invf[0] = 1\n    invf[1] = 1\n    for i in range(2, n+1):\n        f[i] = f[i-1] * i % MOD\n    invf[n] = pow(f[n], MOD-2, MOD)\n    for i in range(n, 2, -1):\n        invf[i-1] = invf[i] * i % MOD\n    return f, invf\n\n\ndef binom(n, k, f, invf, MOD=10**9+7):\n    if n < k or n < 0 or k < 0:\n        return 0\n    else:\n        return (f[n] * invf[k] % MOD) * invf[n-k] % MOD\n\n\ndef solve(N, K, MOD=10**9+7):\n    # k: \u4eba\u65700\u306e\u90e8\u5c4b\u306e\u6570\n    # N\u4eba\u3092(N-k)\u90e8\u5c4b\u306b\u62bc\u3057\u8fbc\u3080\u65b9\u6cd5\u3092\u8003\u3048\u308b\n    f, invf = binom_preprocess(N, MOD)\n    ans = 0\n    for k in range(0, min(N, K+1)):\n        ans += binom(N, k, f, invf, MOD) * binom(N-1, k, f, invf, MOD)\n        ans %= MOD\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"{}\".format(solve(*inputs))))\n\n__starting_point()", "n,k=list(map(int,input().split()))\n\nimport sys\nsys.setrecursionlimit(2147483647)\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\np = 10**9+7 #\u5272\u308b\u6570\nN = 2*n+1  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nans=1\n\nif k>n:\n    ans=cmb(n+n-1,n,p)\n\nelse:\n\n    for i in range(1,k+1):\n        ans+=(cmb(n, i, p)*cmb(n-1,n-i-1,p))%p\n        \n        #print(i,cmb(n, i, p),cmb(n-1,n-i-1,p))\n\nprint((ans%p))\n    \n", "MOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\nN, K = map(int, input().split())\n\nK = min(K, N - 1)\n\nF = Factorial(N + 1, MOD)\n\nans = 0\nfor k in range(K + 1):\n    tmp = F.comb(N, k) * F.factorial(N - 1) * F.ifactorial(N - 1 - k) * F.ifactorial(k)\n    ans += (tmp % MOD)\n    ans %= MOD\n\nprint (ans)", "\ndef main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    n, k = map(int, input().split())\n\n    mod = 1000000007\n    def make_fact(n):\n        fact = [1]*(n+1)\n        ifact = [1]*(n+1)\n        for i in range(1, n+1):\n            fact[i] = fact[i-1]*i % mod\n        ifact[n] = pow(fact[n], mod-2, mod)\n        for i in range(n, 0, -1):\n            ifact[i-1] = ifact[i]*i % mod\n        return fact, ifact\n    fact, ifact = make_fact(n)\n\n    def comb(n, k):\n        if k < 0 or k > n: return 0\n        return fact[n]*ifact[k]*ifact[n-k] % mod\n\n    ans = 0\n    if k > n-1:\n        k = n-1\n    for i in range(k+1):\n        ans = (ans + comb(n, i) * comb(n-1, i))% mod\n\n    print(ans)\n\nmain()", "def main():\n    n,k = list(map(int, input().split()))\n    MOD = 10**9+7\n\n    # 0\u4eba\u90e8\u5c4b\u304c0~k\u500b\u306e\u6642\u306e\u5834\u5408\u306e\u6570\u306e\u548c\n    # \u03a3(i=[0,k]){comb(n,i)*pow((n-i),i)} \u3092\u6c42\u3081\u308c\u3070\u826f\u3044\n    # \u3057\u304b\u3057\u4e0a\u5f0f\u3067\u306fpow\u306e\u8a08\u7b97\u91cf\u304c\u30c7\u30ab\u3059\u304e\u308b\u306e\u3067\u3001\u6349\u3048\u65b9\u3092\u5909\u3048\u3066\u4e0b\u5f0f\u307e\u3067\u5909\u5f62\n    # \u03a3(i=[0,k]){comb(n,i)*comb((n-1),i)} \u3092\u6c42\u3081\u308c\u3070\u826f\u3044\n    # \u6ce8:i=0\u306e\u3068\u304d\u3001\u3064\u307e\u308a0\u4eba\u90e8\u5c4b\u304c\u306a\u3044\u3001\u3064\u307e\u308a\u5168\u90e8\u5c4b\u306b1\u4eba\u305a\u3064\u3001\u306e\u30b1\u30fc\u30b9\u306f1\u901a\u308a\n    # comb(n,i+1) = comb(n,i) * (n-i)/(i+1) \u3067\u3042\u308b\u3053\u3068\u3092\u5229\u7528\u3059\u308b\n    ans = 0\n    k1 = 1\n    k2 = 1\n    for i in range(min(k+1,n)):\n        ans += k1*k2\n        ans %= MOD\n        k1 *= (n-i)*pow(i+1,MOD-2,MOD)\n        k1 %= MOD\n        k2 *= (n-1-i)*pow(i+1,MOD-2,MOD)\n        k2 %= MOD\n    print((int(ans)))\n\nmain()\n", "class Combination:\n    def __init__(self, mod, max_num):\n        self.mod = mod\n        self.fac = [0] * max_num\n        self.finv = [0] * max_num\n        self.inv = [0] * max_num\n\n        self.fac[0], self.fac[1] = 1, 1\n        self.finv[0], self.finv[1] = 1, 1\n        self.inv[1] = 1\n\n        for i in range(2, max_num):\n            self.fac[i] = self.fac[i-1] * i % mod\n            self.inv[i] = mod - self.inv[mod % i] * (mod // i) % mod\n            self.finv[i] = self.finv[i - 1] * self.inv[i] % mod\n\n    def calc(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        return self.fac[n] * (\n            self.finv[k] * self.finv[n - k] % self.mod) % self.mod\n\n\nn, k = list(map(int, input().split()))\ncom = Combination(1000000007, 500000)\n\nret = 1\n\nmin_val = min(n, k)\n\nfor i in range(1, min_val+1):\n    if i != n:\n        ret += com.calc(n, i) * com.calc(n-1, i)\n        ret %= 10 ** 9 + 7\n    else:\n        ret += 0\n\nprint(ret)\n", "def main():\n    n, kk = list(map(int, input().split()))\n\n    mod = 10**9+7\n    fact = [1, 1]\n    for i in range(2, 2*10**5+1):\n        fact.append(fact[-1]*i % mod)\n\n    def nCr(n, r, mod=10**9+7):\n        return pow(fact[n-r]*fact[r] % mod, mod-2, mod)*fact[n] % mod\n\n    ans = [1]\n\n    for k in range(1, n):\n        ans.append(nCr(n-1, k)*nCr(n, k) % mod)\n\n    print((sum(ans[:min(kk+1, n)]) % mod))\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    N, K = (int(_) for _ in input().split())\n\n    fact = [0] * (N + 1) # fact[n] = n!\n    ifact = [0] * (N + 1)\n    \n    for i in range(N+1):\n        if i == 0:\n            fact[i] = 1\n            continue\n        fact[i] = i * fact[i-1]\n        fact[i] %= MOD\n    ifact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N)[::-1]:\n        ifact[i] = ((i+1) * ifact[i+1])%MOD\n\n    ret = 0\n    for m in range(min(K, N-1) + 1):\n        ret += (fact[N] * ifact[m] * ifact[N-m])%MOD * (fact[N-1] * ifact[N-m-1] * ifact[m])%MOD\n        ret %= MOD\n    print((ret%MOD))\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = list(map(int, input().split()))\nMOD = 10**9 + 7\nMAX_N = 10**6 + 5\nfact = [0]*(MAX_N)\nfact_inv = [0]*(MAX_N)\nfact[0] = 1\nfor i in range(MAX_N-1):\n    fact[i+1] = fact[i]*(i+1) % MOD\nfact_inv[-1] = pow(fact[-1], MOD-2, MOD)\nfor i in range(MAX_N-2, -1, -1):\n    fact_inv[i] = fact_inv[i+1]*(i+1) % MOD\n\n\ndef comb(n, k):\n    return fact[n]*fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\n\nif K >= N:\n    print((comb(2*N-1, N-1)))\n    return\n\nans = 1\nfor i in range(1, K+1):\n    ans += comb(N, i)*comb(N-1, i) % MOD\n    ans %= MOD\nprint(ans)\n"]
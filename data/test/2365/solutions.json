["class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        if expression == 'f':\n            return False\n        if expression == 't':\n            return True\n        if expression[0] == '!':\n            return not self.parseBoolExpr(expression[2:-1])\n        if expression[0] == '|':\n            cursor = 2\n            while cursor < len(expression)-1:\n                end_of_next = self.getNextExpr(expression, cursor)\n                if self.parseBoolExpr(expression[cursor:end_of_next]):\n                    return True\n                cursor = end_of_next + 1\n            return False\n        if expression[0] == '&':\n            cursor = 2\n            while cursor < len(expression)-1:\n                end_of_next = self.getNextExpr(expression, cursor)\n                if not self.parseBoolExpr(expression[cursor:end_of_next]):\n                    return False\n                cursor = end_of_next + 1\n            return True\n    \n    def getNextExpr(self, expression, start):\n        if expression[start] == '!' or expression[start] == '|' or expression[start] == '&':\n            open_count = 1\n            close_count = 0\n            start += 1\n            while open_count > close_count:\n                start += 1\n                if expression[start] == '(':\n                    open_count += 1\n                if expression[start] == ')':\n                    close_count += 1\n                \n            return start + 1\n        else:\n            return start + 1", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        \n        bool_stack = []\n        expr_stack = []\n        \n        curr = []\n        for char in expression:\n            if char == ',':\n                continue\n            elif char == '(':\n                expr_stack.append(curr)\n                curr = []\n            elif char in 'tf':\n                curr.append(True if (char == 't') else False)\n            elif char in '|&!':\n                bool_stack.append(char)\n            else:\n                b = bool_stack.pop()\n                prev = expr_stack.pop() if expr_stack else []\n                if b == '!':\n                    curr = prev + [not curr.pop()]\n                elif b == '&':\n                    curr = prev + [all(curr)]\n                else:\n                    curr = prev + [any(curr)]\n        return curr.pop()", "from functools import reduce\n\n\nclass Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        def parse_or(*l):\n            return reduce(lambda x, y: x or y, l)\n        def parse_and(*l): \n            return reduce(lambda x, y: x and y, l)\n        def parse_not(x):\n            return not x\n        \n        expression = expression.replace('t', 'True')\n        expression = expression.replace('f', 'False')\n        \n        expression = expression.replace('|', 'parse_or')\n        expression = expression.replace('&', 'parse_and')\n        expression = expression.replace('!', 'parse_not')\n\n        return eval(expression)", "class Solution:\n\n    def get_arg_list(self, s1: List): \n        args = []\n        while s1 and isinstance(s1[-1], bool): \n            args.append(s1.pop())\n        return args\n    \n    def boolEval(self, symbol, s1: List):\n        if symbol == '!': \n            return not s1[0]\n        elif symbol == '&': \n            return all(s1)\n        elif symbol == '|': \n            return any(s1)\n        else: \n            raise ValueError('Invalid Symbol')\n                \n    def parseBoolExpr(self, expression: str) -> bool:\n        # push ! & | ( onto stack1\n        # push t and f onto stack2 \n        # pop ( from stack 1 when encounter )\n        # if top stack 1 is not paren, then use to evaluate using stack 2\n        s1 = []        \n        \n        for c in expression: \n            if c == '!' or c == '|' or c == '(' or c == '&': \n                s1.append(c)\n            elif c == 't' or c == 'f': \n                s1.append(True if c == 't' else False)\n            elif c == ')': \n                args = self.get_arg_list(s1)\n                s1.pop()\n                top = s1[-1]\n                while top == '!' or top == '|' or top == '&': \n                    ret = self.boolEval(s1.pop(), args)\n                    s1.append(ret)\n                    args = self.get_arg_list(s1)\n                    top = None if not s1 else s1[-1]\n                s1 += args\n\n            elif c == ',': \n                pass\n            else: \n                raise ValueError('Invalid character')\n\n        return s1[0]\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        return eval(expression.translate(str.maketrans({'t': '1', 'f': '0', '!': 'not', '|': 'or_', '&': 'and_'})), {'or_': lambda *a: any(a), 'and_': lambda *a: all(a)})\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        expression = list(expression)\n\n        def replace_or(start: int):\n            braket = 1\n            for i in range(start, len(expression)):\n                if expression[i] == '(':\n                    braket += 1\n                elif expression[i] == ')':\n                    braket -= 1\n                elif braket == 1 and expression[i] == ',':\n                    expression[i] = 'or'\n                elif braket == 0:\n                    break\n\n        for idx, char in enumerate(expression):\n            if char == '|':\n                expression[idx] = ''\n                replace_or(idx + 2)\n            elif char == '&':\n                expression[idx] = ''\n            elif char == 't':\n                expression[idx] = 'True'\n            elif char == 'f':\n                expression[idx] = 'False'\n            elif char == '!':\n                expression[idx] = 'not'\n\n        expr = ' '.join(expression).replace(',', 'and')\n\n        return eval(expr)\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        expression = list(expression)\n        table = {'|': 'or', '&': 'and', 't': 'True', 'f': 'False'}\n\n        logic = []\n        idx, par = 0, True\n        while idx < len(expression):\n            if expression[idx] in ['&', '|']:\n                logic.append(table[expression[idx]])\n                expression[idx] = ''\n                idx += 2\n            elif expression[idx] == '!':\n                logic.append('not')\n                expression[idx] = 'not'\n                idx += 2\n            else:\n                if not par and logic:\n                    logic.pop()\n                    par = True\n\n                if expression[idx] in ['t', 'f']:\n                    expression[idx] = table[expression[idx]]\n                elif expression[idx] == ',':\n                    expression[idx] = logic[-1]\n                elif expression[idx] == ')':\n                    if logic[-1] == 'not':\n                        logic.pop()\n                    else:\n                        par = False\n\n                idx += 1\n\n        return eval(' '.join(expression))\n", "class Solution:\n    def parseBoolExpr(self, ex: str) -> bool:\n        def recur(i):\n            if ex[i] in ('t','f'):\n                return True if ex[i]=='t' else False,i+1\n            op=ex[i]\n            i=i+2\n            stack=[]\n            while ex[i]!=')':\n                if ex[i]==',':\n                    i+=1\n                    continue\n                \n                res,i=recur(i)\n                stack.append(res)\n            \n            if op=='&':\n                return all(stack),i+1\n            elif op=='|':\n                return any(stack),i+1\n            elif op=='!':\n                return not stack[0],i+1\n            return res,i+1\n        return recur(0)[0]", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        expression = list(expression)\n\n        def replace(start: int, logical: str):\n            braket = 1\n            idxs = []\n            for i in range(start, len(expression)):\n                if expression[i] == '(':\n                    braket += 1\n                elif expression[i] == ')':\n                    braket -= 1\n                elif braket == 1 and expression[i] == ',':\n                    idxs.append(i)\n                elif braket == 0:\n                    break\n\n            for i in idxs:\n                expression[i] = logical\n\n        for idx, char in enumerate(expression):\n            if char == '|':\n                expression[idx] = ''\n                replace(idx + 2, 'or')\n            elif char == '&':\n                expression[idx] = ''\n\n        expr = ' '.join(expression).replace('t', 'True').replace('f', 'False').replace('!', 'not').replace(',', 'and')\n\n        return eval(expr)\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        expression = list(expression)\n\n        def replace(start: int, logical: str):\n            braket = 1\n            idxs = []\n            for i in range(start, len(expression)):\n                if expression[i] == '(':\n                    braket += 1\n                elif expression[i] == ')':\n                    braket -= 1\n                elif braket == 1 and expression[i] == ',':\n                    idxs.append(i)\n                elif braket == 0:\n                    break\n\n            for i in idxs:\n                expression[i] = logical\n\n        for idx, char in enumerate(expression):\n            if char == '|':\n                expression[idx] = ''\n                replace(idx + 2, 'or')\n            elif char == '&':\n                expression[idx] = ''\n            elif char == 't':\n                expression[idx] = 'True'\n            elif char == 'f':\n                expression[idx] = 'False'\n            elif char == '!':\n                expression[idx] = 'not'\n\n        expr = ' '.join(expression).replace(',', 'and')\n\n        return eval(expr)\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        exp=collections.deque(expression)\n        \n        def or_opt(exp):\n            exp.popleft() # skip (\n            ret=False\n            while exp:\n                ret |= exp_opt(exp)\n                if exp.popleft()==')': return ret\n        \n        def and_opt(exp):\n            exp.popleft() # skip (\n            ret=True\n            while exp:\n                ret &= exp_opt(exp)\n                if exp.popleft()==')': return ret\n                                \n        def exp_opt(exp):\n            ch=exp.popleft()\n            ret=False\n            if ch=='t': ret=True\n            elif ch=='f': ret=False\n            elif ch=='!': exp.popleft(); ret=not exp_opt(exp); exp.popleft() # remove (,)\n            elif ch=='|': ret=or_opt(exp)\n            elif ch=='&': ret=and_opt(exp)\n            return ret\n        \n        return exp_opt(exp)    ", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        table = {'|': 'or', '&': 'and', 't': 'True', 'f': 'False', '(': '('}\n\n        expr, logic = [], []\n        idx, par = 0, True\n        while idx < len(expression):\n            if expression[idx] in ['&', '|']:\n                logic.append(table[expression[idx]])\n            elif expression[idx] == '!':\n                logic.append('not')\n                expr.append('not')\n            else:\n                if not par and logic:\n                    logic.pop()\n                    par = True\n\n                if expression[idx] in ['t', 'f', '(']:\n                    expr.append(table[expression[idx]])\n                elif expression[idx] == ',':\n                    expr.append(logic[-1])\n                elif expression[idx] == ')':\n                    expr.append(')')\n                    if logic[-1] == 'not':\n                        logic.pop()\n                    else:\n                        par = False\n\n            idx += 1\n\n        return eval(' '.join(expr))\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        \n        def split_into_list(expression):\n            \n            res = []\n            depth = 0\n            ss = ''\n            \n            for e in expression:\n                if depth == 0 and e == ',':\n                    res.append(ss)\n                    ss = ''\n                \n                else:\n                    if e == '(':\n                        depth += 1\n                    elif e == ')':\n                        depth -= 1\n\n                    ss += e\n                \n            res.append(ss)\n            \n            return res\n        \n        if expression == 't':\n            return True\n        if expression == 'f':\n            return False\n        \n        if expression[0] == '!':\n            return not self.parseBoolExpr(expression[2:-1])\n            \n        if expression[0] == '&':\n            \n            res = True\n            for L in split_into_list(expression[2:-1]):\n                res &= self.parseBoolExpr(L)\n            \n            return res\n        \n        if expression[0] == '|':\n            \n            res = False\n            for L in split_into_list(expression[2:-1]):\n                res |= self.parseBoolExpr(L)\n            \n            return res", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        if len(expression) == 1:\n            return expression == 't'\n        op = expression[0]\n        boolean_list = []\n        level = 0\n        start = 2\n        for i in range(2, len(expression) - 1):\n            ch = expression[i]\n            if ch == '(':\n                level += 1\n            elif ch == ')':\n                level -= 1\n            elif ch == ',' and level == 0:\n                boolean_list.append(self.parseBoolExpr(expression[start:i]))\n                start = i+1\n            elif ch not in '&|!' and level == 0:\n                boolean_list.append(True if ch == 't' else False)\n        boolean_list.append(self.parseBoolExpr(expression[start:-1]))\n        if op == '!':\n            return not boolean_list[0]\n        elif op == '&':\n            return all(boolean_list)\n        else:\n            return any(boolean_list)\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        stack = []\n        for ch in expression:\n            if ch == ',':\n                continue\n            if ch != ')':\n                stack.append(ch)\n            else:\n                temp = ''\n                while stack[-1] != '(':\n                    temp += stack.pop()\n                stack.pop()\n                if stack[-1] == '&':\n                    res = 't' if temp.count('f') == 0 else 'f'\n                elif stack[-1] == '|':\n                    res = 'f' if temp.count('t') == 0 else 't'\n                else:\n                    res = 't' if temp == 'f' else 'f'\n                stack[-1] = res\n        return True if stack[-1] == 't' else False\n        \n        \n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        def parse(e: str, left, right):\n            if right - left == 1: \n                return e[left] == 't'               \n            res = e[left] == '&' # only when the first char is '&', ans assigned True.\n            level, start = 0, left + 2 # e[left + 1] must be '(', so start from lo + 2 to delimit sub-expression.\n            for i in range(left + 2, right):\n                if level == 0  and e[i] in [',', ')']: # found a sub-expression.\n                    cur = parse(e, start, i) \n                    start = i + 1 \n                    if e[left] == '&':\n                        res &= cur\n                    elif e[left] == '|':\n                        res |= cur\n                    else: # e[lo] is '!'.\n                        res = not cur\n                if e[i] == '(':\n                    level = level + 1\n                elif e[i] == ')':\n                    level = level - 1\n            return res;        \n        \n        return parse(expression, 0, len(expression))\n", "from functools import reduce\nclass Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        operations = {\n            '|': any,\n            '&': all,\n            '!': lambda x: not x[0]\n        }\n        \n        def getTokens(expression):\n            depth = 0\n            token = ''\n            for s in expression:\n                if s == ',' and depth == 0:\n                    yield token\n                    token = ''\n                    continue\n                if s == '(':\n                    depth += 1\n                elif s == ')':\n                    depth -= 1\n                token += s\n                \n            yield token\n        \n        def evaluate(expression):\n            if expression == 't':\n                return True\n            elif expression == 'f':\n                return False\n            \n            operator = operations[expression[0]]\n            values = [evaluate(token) for token in getTokens(expression[2:-1])]\n            return operator(values)\n            \n        return evaluate(expression)", "class Solution:\n    # https://www.youtube.com/watch?v=y2kFBqj_J08&list=PLLuMmzMTgVK45AiaeeEGGc6xqM6jrlXL4&index=1\n    def parseBoolExpr1(self, expression: str) -> bool:\n        def helper(queue):\n            res = True\n            while queue:\n                c = queue.pop()\n                print(('c = {0}'.format(c)))\n                if c in {'t', 'f'}:\n                    return True if c == 't' else False\n                if c == '!':\n                    # remove '('\n                    queue.pop()\n                    # print('!, queue = {0}'.format(queue))\n                    res = not helper(queue)\n                    # remove ')'\n                    queue.pop()\n                    return res\n                # elif c in {'&', '|'}:\n                    # for &, True & exp1 & exp2, for |, False | exp1 | exp2\n                isAnd = True if c == '&' else False\n                res = isAnd\n                # remove '('\n                queue.pop()\n                while True:\n                    if isAnd:\n                        res &= helper(queue)\n                    else:\n                        res |= helper(queue)\n                    # ch can be ')' or ,  e.g \\\"|(&(t,f,t),!(t))\\\"\n                    print(('isAnd = {0}, queue = {1}, res = {2}'.format(isAnd, queue, res)))\n                    ch = queue.pop()\n                    print(('after pop char, char = {0}, queue = {1}'.format(ch, queue)))\n                    if ch == ')':\n                        break\n            return res\n        \n        queue = collections.deque([])\n        for c in expression:\n            queue.appendleft(c)\n        return helper(queue)\n                        \n        \n    # slow, time: O(n^2)\n    def parseBoolExpr(self, expression: str) -> bool:\n        # j is inclusive\n        def helper(exp, i, j):\n            if i == j:\n                return exp[i] == 't'\n            op = exp[i]\n            res = op == '&'\n            # k starts from '('\n            k, count, prev = i + 1, 0, i + 2\n            # print('i = {0}, j = {1}'.format(i, j))\n            while k <= j:\n                c = exp[k]\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if (count == 1 and c == ',') or not count:\n                    # print('k = {0}, c = {1}, count = {2}, i1 = {3}, j1 = {4}'.format(k, c, count, i + 2, k - 1))\n                    val = helper(exp, prev, k - 1)\n                    prev = k + 1\n                    if op == '!':\n                        res = not val\n                    elif op == '&':\n                        res &= val\n                    elif op == '|':\n                        res |= val\n                k += 1\n            # print('i = {0}, j = {1}, res = {2}'.format(i, j, res))\n            return res\n        \n        return helper(expression, 0, len(expression) - 1)\n    \n    \n        # if len(expression) == 1:\n        #     return expression == 't'\n        # if expression[0] == '!':\n        #     return not self.parseBoolExpr(expression[2:-1])\n        # op, stack, i = expression[0], [], 2\n        # while i < len(expression) - 1:\n        #     if expression[i] == 't' or expression[i] == 'f':\n        #         stack.append(self.parseBoolExpr(expression[i]))\n        #         i += 1\n        #     elif expression[i] in {'!', '&', '|'}:\n        #         j, count = i + 2, 1\n        #         while j < len(expression) - 1:\n        #             if expression[j] == '(':\n        #                 count += 1\n        #             elif expression[j] == ')':\n        #                 count -= 1\n        #                 if not count:\n        #                     stack.append(self.parseBoolExpr(expression[i:j + 1]))\n        #                     i = j + 1\n        #                     break\n        #             j += 1\n        #     else:\n        #         i += 1\n        # if op == '&':\n        #     return all(val for val in stack)\n        # return any(val for val in stack)\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        expression = list(expression)\n\n        def replace(start: int, logical: str):\n            braket = 1\n            idxs = []\n            for i in range(start, len(expression)):\n                if expression[i] == '(':\n                    braket += 1\n                elif expression[i] == ')':\n                    braket -= 1\n                elif braket == 1 and expression[i] == ',':\n                    idxs.append(i)\n                elif braket == 0:\n                    break\n\n            for i in idxs:\n                expression[i] = logical\n\n        for idx, char in enumerate(expression):\n            if char == '|':\n                expression[idx] = ''\n                replace(idx + 2, 'or')\n            elif char == '&':\n                expression[idx] = ''\n                replace(idx + 2, 'and')\n\n        expr = ' '.join(expression).replace('t', 'True').replace('f', 'False').replace('!', 'not')\n\n        return eval(expr)\n", "class Solution:\n    def parseBoolExpr(self, ex: str) -> bool:\n        def recur(i):\n            if ex[i] in ('t','f'):\n                return True if ex[i]=='t' else False,i+1\n            op=ex[i]\n            i,stack=i+2,[]\n            while ex[i]!=')':\n                if ex[i]==',':\n                    i+=1\n                    continue\n                res,i=recur(i)\n                stack.append(res)\n            if op=='&':\n                return all(stack),i+1\n            elif op=='|':\n                return any(stack),i+1\n            elif op=='!':\n                return not stack[0],i+1\n            return res,i+1\n  \n        return recur(0)[0]", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        ops = {'!', '&', '|'}\n        \n        def parse(start):\n            if expression[start] == 'f':\n                return False, start + 1\n            if expression[start] == 't':\n                return True, start + 1\n            if expression[start] in ops:\n                new_start = start + 2\n                vals = set()\n                while new_start < len(expression):\n                    val, new_start = parse(new_start)\n                    vals.add(val)\n                    if expression[new_start] == ')':\n                        new_start += 1\n                        break\n                    assert expression[new_start] == ','\n                    new_start += 1\n                if expression[start] == '!':\n                    assert len(vals) == 1\n                    return not list(vals)[0], new_start\n                if expression[start] == '&':\n                    return all(vals), new_start\n                return any(vals), new_start\n        \n        return parse(0)[0]", "import operator\nfrom typing import List\n\n\nclass Solution:\n\n    @staticmethod\n    def split_by_comma(expression: str) -> List[str]:\n        start = 0\n        bracket_balance = 0\n        answer = []\n        for i in range(len(expression)):\n            if expression[i] == '(':\n                bracket_balance += 1\n            if expression[i] == ')':\n                bracket_balance -= 1\n            if expression[i] == ',' and not bracket_balance:\n                answer.append(expression[start: i+1])\n                start = i + 1\n        answer.append(expression[start:])\n        return answer\n\n    def parseBoolExpr(self, expression: str) -> bool:\n        if expression.startswith('t'):\n            return True\n        if expression.startswith('f'):\n            return False\n        if expression.startswith('!'):\n            return not self.parseBoolExpr(expression[2:-1])\n        if expression.startswith('|'):\n            return any(map(self.parseBoolExpr,\n                           self.split_by_comma(expression[2:-1])))\n        else:\n            return all(map(self.parseBoolExpr,\n                           self.split_by_comma(expression[2:-1])))\n\n", "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        stack = []\n        for c in expression:\n            if c not in [',', ')']:\n                stack.append(True if c=='t' else False if c=='f' else c)\n            elif c == ')':\n                seen = set() # capturing only distinct values i.e single 'f' and 't' \n                while stack[-1] != '(':\n                    seen.add(stack.pop())\n                stack.pop() # removing '('\n                operator = stack.pop()\n                stack.append(all(seen) if operator == '&' else any(seen) if operator == '|' else not seen.pop() )\n        \n        return stack[-1]"]
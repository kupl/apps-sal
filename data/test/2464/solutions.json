["class UnionFind:\n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.rank = [1 for i in range(N)]\n        self.rank[0] = 0\n    def union(self, x, y):\n        if not self.is_same_set(x, y):\n            par_x = self.find_par(x)\n            par_y = self.find_par(y)\n\n            if self.rank[par_x] > self.rank[par_y]:\n                self.rank[par_x] += self.rank[par_y]\n                self.rank[par_y] = 0\n                self.par[par_y] = par_x\n            else:\n                self.rank[par_y] += self.rank[par_x]\n                self.rank[par_x] = 0\n                self.par[par_x] = par_y\n\n    def find_par(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find_par(self.par[x])\n        return self.par[x]\n\n    def is_same_set(self, x, y):\n        return self.find_par(x) == self.find_par(y)\n\n    def size(self, x):\n        return self.rank[self.find_par(x)]\n# 2 unionfind, para 0 e para 1 formando 2 florestas\n# lista de adj\n# verificar todos os componentes existentes e adicionar na resposta n * (n-1)\n\nn = int(input())\n\nadj = [[] for i in range(n+1)]\n\nuf0 = UnionFind(n+1)\nuf1 = UnionFind(n+1)\n\nfor i in range(n-1):\n    x, y, c = list(map(int, input().split()))\n\n    if c == 0:\n        uf0.union(x, y)\n    else:\n        uf1.union(x, y)\n    adj[x].append(y)\n    adj[y].append(x)\nfor i in range(n+1):\n    uf0.find_par(i)\n    uf1.find_par(i)\n\nresp = 0\n\nfor i in set(uf0.par):\n    resp += uf0.rank[i] * (uf0.rank[i] - 1)\nfor i in set(uf1.par):\n    resp += uf1.rank[i] * (uf1.rank[i] - 1)\n\n# pra cada componente do 0-uf verificar se existe esse vertice na 1-uf e ele for conectado com algu\u00e9m, se sim, multiplicar (n-1)*(m-1) sendo n o componente da 0-uf e m o componente da 1-f e adicionar na resposta\n\nfor i in range(len(uf0.par)):\n    if uf0.rank[uf0.find_par(i)] > 1:\n        if uf1.rank[uf1.find_par(i)] > 1:\n            resp += (uf0.rank[uf0.find_par(i)] - 1) * (uf1.rank[uf1.find_par(i)] - 1)\nprint(resp)\n", "class UnionFind:\n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.rank = [1 for i in range(N)]\n        self.rank[0] = 0\n    def union(self, x, y):\n        if not self.is_same_set(x, y):\n            par_x = self.find_par(x)\n            par_y = self.find_par(y)\n\n            if self.rank[par_x] > self.rank[par_y]:\n                self.rank[par_x] += self.rank[par_y]\n                self.rank[par_y] = 0\n                self.par[par_y] = par_x\n            else:\n                self.rank[par_y] += self.rank[par_x]\n                self.rank[par_x] = 0\n                self.par[par_x] = par_y\n\n    def find_par(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find_par(self.par[x])\n        return self.par[x]\n\n    def is_same_set(self, x, y):\n        return self.find_par(x) == self.find_par(y)\n\n    def size(self, x):\n        return self.rank[self.find_par(x)]\n# 2 unionfind, para 0 e para 1 formando 2 florestas\n# lista de adj\n# verificar todos os componentes existentes e adicionar na resposta n * (n-1)\n\nn = int(input())\n\nadj = [[] for i in range(n+1)]\n\nuf0 = UnionFind(n+1)\nuf1 = UnionFind(n+1)\n\nfor i in range(n-1):\n    x, y, c = list(map(int, input().split()))\n\n    if c == 0:\n        uf0.union(x, y)\n    else:\n        uf1.union(x, y)\n    adj[x].append(y)\n    adj[y].append(x)\n\n    uf0.find_par(x)\n    uf1.find_par(y)\n\nresp = 0\n\nresp += sum([uf0.rank[i] * (uf0.rank[i] - 1) for i in set(uf0.par)])\nresp += sum([uf1.rank[i] * (uf1.rank[i] - 1) for i in set(uf1.par)])\n# pra cada componente do 0-uf verificar se existe esse vertice na 1-uf e ele for conectado com algu\u00e9m, se sim, multiplicar (n-1)*(m-1) sendo n o componente da 0-uf e m o componente da 1-f e adicionar na resposta\n#ja_visto = set()\nfor i in range(len(uf0.par)):\n    if uf0.rank[uf0.find_par(i)] > 1: #and not uf0.find_par(i) in ja_visto:\n        #ja_visto.add(uf0.find_par(i))\n        if uf1.rank[uf1.find_par(i)] > 1:\n            resp += (uf0.rank[uf0.find_par(i)] - 1) * (uf1.rank[uf1.find_par(i)] - 1)\nprint(resp)\n", "from collections import deque\n\ndef bfs(source, graph, mark, num, fcount):\n\tvisited = [source]\n\tq = deque()\n\tmark[source] = True\n\tq.append(source)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor v, c in g[u]:\n\t\t\tif c == num and not mark[v]:\n\t\t\t\tmark[v] = True\n\t\t\t\tvisited.append(v)\n\t\t\t\tq.append(v)\n\tif len(visited) > 1:\n\t\tfor u in visited:\n\t\t\tfcount[u] = len(visited)\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(0, n - 1)]\ng = [[] for _ in range(0, n)]\ncnt = [[0 for _ in range(0, n)] for _ in range(0, 2)]\nfor u, v, c in edges:\n\tg[u - 1].append((v - 1, c))\n\tg[v - 1].append((u - 1, c))\n\nres = 0\nfor link in range(0, 2):\n\tmark = [False] * n\n\tfor u in range(0, n):\n\t\tif not mark[u]:\n\t\t\tbfs(u, g, mark, link, cnt[link])\n\t\t\tres += cnt[link][u] * (cnt[link][u] - 1)\n\nfor i in range(0, n):\n\tif cnt[0][i] > 0 and cnt[1][i] > 1:\n\t\tres += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n\nprint(int(res))", "class Deque:\n\tdef __init__(self):\n\t\tself.buff = [0] * 400000\n\t\tself.l = 0\n\t\tself.r = 0\n\tdef append(self, x):\n\t\tself.buff[self.r] = x\n\t\tself.r = self.r + 1\n\tdef popleft(self):\n\t\told_left = self.l\n\t\tself.l = self.l + 1\n\t\treturn self.buff[old_left]\n\tdef __bool__(self):\n\t\treturn self.l != self.r\n\nq = Deque()\n\ndef bfs(source, graph, mark, num, fcount):\n\tvisited = [source]\n\tmark[source] = True\n\tq.append(source)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor v, c in g[u]:\n\t\t\tif c == num and not mark[v]:\n\t\t\t\tmark[v] = True\n\t\t\t\tvisited.append(v)\n\t\t\t\tq.append(v)\n\tif len(visited) > 1:\n\t\tfor u in visited:\n\t\t\tfcount[u] = len(visited)\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(0, n - 1)]\ng = [[] for _ in range(0, n)]\ncnt = [[0 for _ in range(0, n)] for _ in range(0, 2)]\nfor u, v, c in edges:\n\tg[u - 1].append((v - 1, c))\n\tg[v - 1].append((u - 1, c))\n\nres = 0\nfor link in range(0, 2):\n\tmark = [False] * n\n\tfor u in range(0, n):\n\t\tif not mark[u]:\n\t\t\tbfs(u, g, mark, link, cnt[link])\n\t\t\tres += cnt[link][u] * (cnt[link][u] - 1)\n\nfor i in range(0, n):\n\tif cnt[0][i] > 0 and cnt[1][i] > 1:\n\t\tres += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n\nprint(int(res))", "from collections import defaultdict\n\ndef colour(a, graph, cur, i):\n    top = set()\n    top.add(i)\n    while len(top):\n        x = top.pop()\n        a[x] = cur\n        for y in graph[x]:\n            if a[y] == 0:\n                top.add(y)\n\ndef colour_graph(a, graph, n):\n    cur = 0\n    for i in range(1, n + 1):\n        if a[i] or i not in graph:\n            continue\n        else:\n            cur += 1\n            colour(a, graph, cur, i)\n\ndef count(col):\n    ans = 0\n    for el in col:\n        if col[el] > 1:\n            ans += col[el]*(col[el] - 1)\n    return ans\n\nn = int(input())\n\n\ngraph0 = defaultdict(set)\ngraph1 = defaultdict(set)\n\n\nvertex0 = set()\n\na0 = [0]*(n + 1)  \na1 = [0]*(n + 1)\n\nfor i in range(n - 1):\n    x, y, c = list(map(int, input().split()))\n    if c == 0:\n        graph0[x].add(y)\n        graph0[y].add(x)\n        vertex0.add(x)\n        vertex0.add(y)\n    else:\n        graph1[x].add(y)\n        graph1[y].add(x)\n\n\ncolour_graph(a0, graph0, n)\ncolour_graph(a1, graph1, n)\n\nanswer = 0\ncol0 = defaultdict(int)\ncol1 = defaultdict(int)\n\nfor i in range(n + 1):\n    if a0[i]:\n        col0[a0[i]] += 1\n    if a1[i]:\n        col1[a1[i]] += 1\n\nanswer += count(col0) + count(col1)\n\ncol = defaultdict(int)\nfor v in vertex0:\n    col[a1[v]] += col0[a0[v]] - 1\nfor el in col:\n    if el:\n        answer += col[el]*(col1[el] - 1)\n        \nprint(answer)\n", "class dsu:\n\tdef __init__(self,n):\n\t\tself.arr = [i for i in range(n)]\n\t\tself.size = [1 for i in range(n)]\n\t\tself.s = n\n\tdef find(self,i):\n\t\twhile(i!=self.arr[i]):\n\t\t\ti = self.arr[i]\n\t\treturn i\n\t\tif(self.arr[i]!=i):\n\t\t\tself.arr[i] = self.find(self.arr[i])\n\t\treturn self.arr[i]\n\tdef union(self,i,j):\n\t\tfa = self.find(i)\n\t\tfb = self.find(j)\n\t\tif(fa == fb):\n\t\t\treturn\n\t\ts1 = self.size[fa]\n\t\ts2 = self.size[fb]\n\t\tif(s1<s2):\n\t\t\tself.arr[fa] = fb\n\t\t\tself.size[fb] += self.size[fa]\n\t\telse:\n\t\t\tself.arr[fb] = fa\n\t\t\tself.size[fa] += self.size[fb]\nn = int(input())\nzero = dsu(n)\none = dsu(n)\nfor i in range(n-1):\n\ta = [int(i) for i in input().split(' ')]\n\tx = a[0]-1\n\ty = a[1]-1\n\tc = a[2]\n\tif(c==0):\n\t\tzero.union(x,y)\n\telse:\n\t\tone.union(x,y)\ncount = 0\nfor i in range(n):\n\tif(zero.arr[i] == i):\n\t\tcount+=zero.size[i]*(zero.size[i]-1)\n\tif(one.arr[i] == i):\n\t\tcount+=one.size[i]*(one.size[i]-1)\n\tcount += (zero.size[zero.find(i)]-1)*(one.size[one.find(i)]-1)\nprint(count)", "import sys\n\nclass Disjoint:\n    def __init__(self, n):\n        self.n = n\n        self.size = [1] * self.n\n        self.parent = [i for i in range(self.n)]\n    \n    def root(self, node):\n        self.parent[node] = node if self.parent[node] == node else self.root(self.parent[node])\n        return self.parent[node]\n    \n    def join(self, a, b):\n        a = self.root(a)\n        b = self.root(b)\n        if a == b:\n            return False\n        if self.size[a] > self.size[b]:\n            a, b = b, a\n            \n        self.size[b] += self.size[a]\n        self.parent[a] = b\n        return True\n    \n    \n\ninp = [int(x) for x in sys.stdin.read().split()]\nn = inp[0]\n\nwhite = Disjoint(n)\nblack = Disjoint(n)\n\ninp_idx = 1\nfor i in range(n - 1):\n    x, y, c = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2]\n    x -= 1\n    y -= 1\n    inp_idx += 3\n    \n    if c == 0:\n        white.join(x, y)\n    else:\n        black.join(x, y)\n    \nans = 0\nfor i in range(n):\n    rootW = white.root(i)\n    rootB = black.root(i)\n    ans += white.size[rootW] - 1\n    ans += black.size[rootB] - 1\n    \n    ans += (white.size[rootW] - 1) * (black.size[rootB] - 1)\n    \nprint(ans)\n", "class UnionFind():\n\n    def __init__(self, n):\n        self.n = n\n\n        self.root = [-1]*(n+1)\n\n        self.rnk = [0]*(n+1)\n\n\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    def Unite(self, x, y):\n\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n\n        if(x == y):\n            return \n\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nuni0 = UnionFind(N)\nuni1 = UnionFind(N)\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    if c == 0:\n        uni0.Unite(a-1, b-1)\n    else:\n        uni1.Unite(a-1, b-1)\n\ng0 = {}\ng1 = {}\nfor i in range(N):\n    if uni0.Count(i) != 1:\n        r = uni0.Find_Root(i)\n        if not r in g0.keys():\n            g0[r] = [i]\n        else:\n            g0[r].append(i)\n    if uni1.Count(i) != 1:\n        r = uni1.Find_Root(i)\n        if not r in g1.keys():\n            g1[r] = [i]\n        else:\n            g1[r].append(i)\n\nans = 0\nfor v_list in g1.values():\n    c = 0\n    for n in v_list:\n        if uni0.Count(n) == 1:\n            c += 1\n    l = len(v_list)\n    ans += c*(l-1)\n\nfor v_list in g0.values():\n    c = 0\n    for n in v_list:\n        if uni1.Count(n) != 1:\n            r = uni1.Find_Root(n)\n            c += len(g1[r])-1\n    c += len(v_list)-1\n    ans += len(v_list)*c\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [-1] * n\n        self.cnt = n\n\n    def root(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.parent[x] > self.parent[y]:\n            x, y = y, x\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n        self.cnt -= 1\n        \n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return -self.parent[self.root(x)]\n    \n    def get_cnt(self):\n        return self.cnt\n\n\nn = int(input())\ninfo = [list(map(int, input().split())) for i in range(n - 1)]\n\nuf0 = UnionFind(n)\nuf1 = UnionFind(n)\ntree0 = [[] for i in range(n)]\ntree1 = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b, cost = info[i]\n    a -= 1\n    b -= 1\n    if cost == 0:\n        tree0[a].append(b)\n        tree0[b].append(a)\n        uf0.merge(a, b)\n    else:\n        tree1[a].append(b)\n        tree1[b].append(a)\n        uf1.merge(a, b)\n\nans0 = [0] * n\nans1 = [0] * n\nfor i in range(n):\n    ans0[i] = uf0.get_size(i) - 1\n    ans1[i] = uf1.get_size(i) - 1\n\nans = 0\nfor i in range(n):\n    ans += ans0[i]\n    ans += ans1[i]\n    ans += ans0[i] * ans1[i]\nprint(ans)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nabd = [list(map(int,input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n+1)]\ndeg = [0]*(n+1)\nif n == 2:\n  print(2)\n  return\nfor a,b,d in abd:\n  graph[a].append((b,d))\n  graph[b].append((a,d))\n  deg[a] += 1\n  deg[b] += 1\ndp = [[0]*3 for i in range(n+1)]\nstack = []\nroot = 0\nfor i in range(1,n+1):\n  if deg[i] == 1:\n    stack.append(i)\n  elif not root:\n    root = i\n    deg[root] += 1\nwhile stack:\n  x = stack.pop()\n  if dp[x][0] == dp[x][1] == 0:\n    for y,d in graph[x]:\n      dp[y][d] += 1\n      deg[y] -= 1\n      if deg[y] == 1:\n        stack.append(y)\n  else:\n    for y,d in graph[x]:\n      if deg[y] > 1:\n        dp[y][d] += dp[x][d]+1\n        if d == 1:\n          dp[y][2] += dp[x][0]+dp[x][2]\n        deg[y] -= 1\n        if deg[y] == 1:\n          stack.append(y)\nstack = [root]\ndeg[root] -= 1\nwhile stack:\n  x = stack.pop()\n  for y,d in graph[x]:\n    if deg[y] == 1:\n      deg[y] -= 1\n      dp[y][d] += dp[x][d]-dp[y][d]\n      if d == 1:\n        dp[y][2] += dp[x][2]+dp[x][0]-dp[y][0]-dp[y][2]\n      stack.append(y)\nans = 0\nfor i,j,k in dp:\n  ans += i+j+k\nprint(ans)", "def addEdge(arr: [], x, y):\n    x, y = getRoot(arr, x), getRoot(arr, y)\n    if arr[x] <= arr[y]:\n        arr[x] += arr[y]\n        arr[y] = x\n    else:\n        arr[y] += arr[x]\n        arr[x] = y\n\n\ndef getRoot(arr: [], id):\n    while arr[id] > 0:\n        id = arr[id]\n    return id\n\n\ndef solve(zeroArr: [], oneArr: []):\n    Ans = 0\n    for i in range(1, len(zeroArr)):\n        if zeroArr[i] < 0:\n            Ans += zeroArr[i] * (-1) * (zeroArr[i] * (-1) - 1)\n        if oneArr[i] < 0:\n            Ans += oneArr[i] * (-1) * (oneArr[i] * (-1) - 1)\n        if (zeroArr[i] != -1 and oneArr[i] != -1):\n            one, zero = getRoot(oneArr, i), getRoot(zeroArr, i)\n            Ans += (oneArr[one] * (-1) - 1) * (zeroArr[zero] * (-1) - 1)\n    return Ans\n\nn = int(input())\nzeroArr, oneArr = [-1] * (n + 1), [-1] * (n + 1)\nwhile n > 1:\n    a, b, w = [int(x) for x in input().split()]\n    if w == 0:\n        addEdge(zeroArr, a, b)\n    else:\n        addEdge(oneArr, a, b)\n    n -= 1\nprint(solve(zeroArr, oneArr))\n", "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    from collections import deque\n    input = sys.stdin.readline\n\n    class UnionFind():\n        def __init__(self, n):\n            self.n = n\n            self.root = [-1] * (n + 1)\n            self.rnk = [0] * (n + 1)\n\n        def find_root(self, x):\n            while self.root[x] >= 0:\n                x = self.root[x]\n            return x\n\n        def unite(self, x, y):\n            x = self.find_root(x)\n            y = self.find_root(y)\n            if x == y:\n                return\n            elif self.rnk[x] > self.rnk[y]:\n                self.root[x] += self.root[y]\n                self.root[y] = x\n            else:\n                self.root[y] += self.root[x]\n                self.root[x] = y\n                if self.rnk[x] == self.rnk[y]:\n                    self.rnk[y] += 1\n\n        def isSameGroup(self, x, y):\n            return self.find_root(x) == self.find_root(y)\n\n        def size(self, x):\n            return -self.root[self.find_root(x)]\n\n    N = int(input())\n    adj = [[] for _ in range(N+1)]\n    UF0 = UnionFind(N+1)\n    UF1 = UnionFind(N+1)\n    for _ in range(N-1):\n        a, b, c = list(map(int, input().split()))\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n        if c == 0:\n            UF0.unite(a, b)\n        else:\n            UF1.unite(a, b)\n\n    ans = 0\n    roots = set()\n    for v in range(1, N+1):\n        r = UF1.find_root(v)\n        if r not in roots:\n            roots.add(r)\n            s = -UF1.root[r]\n            ans += s * (s-1)\n    #print(ans)\n\n    roots = set()\n    for v in range(1, N+1):\n        r = UF0.find_root(v)\n        if r not in roots:\n            roots.add(r)\n            s = -UF0.root[r]\n            ans += s * (s-1)\n    #print(ans)\n\n    for v in range(1, N+1):\n        W = 0\n        B = 0\n        flg0 = 0\n        flg1 = 0\n        for u, c in adj[v]:\n            if flg0 and flg1:\n                break\n            if c == 0:\n                if flg0:\n                    continue\n                W += UF0.size(u) - 1\n                flg0 = 1\n            else:\n                if flg1:\n                    continue\n                B += UF1.size(u) - 1\n                flg1 = 1\n        ans += W * B\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\nI = lambda : list(map(int,input().split()))\n\nn,=I()\nr=[[1 for i in range(n)],[1 for i in range(n)]]\np=[[i for i in range(n)],[i for i in range(n)]]\ndef find(x,c):\n\tif x!=p[c][x]:\n\t\tp[c][x]=find(p[c][x],c)\n\treturn p[c][x]\n\ndef union(a,b,c):\n\tx=find(a,c)\n\ty=find(b,c)\n\tmm=min(x,y)\n\tif x!=y:\n\t\tp[c][y]=p[c][x]=mm\n\t\tr[c][mm]+=r[c][max(x,y)]\nan=0\nfor i in range(n-1):\n\ta,b,c=I()\n\tunion(a-1,b-1,c)\nvis=[0]*n\ncc=[]\nfor i in range(n):\n\ts0=r[0][i]\n\ts1=r[1][i]\n\tif p[0][i]==i:\n\t\tan+=(s0-1)*s0\n\tif p[1][i]==i:\n\t\tan+=(s1-1)*s1\n\tan+=(r[1][find(i,1)]-1)*(r[0][find(i,0)]-1)\nprint(an)", "import sys;sys.setrecursionlimit(10**9)\nclass UnionFind:\n  def __init__(self,n):\n    self.n=[-1]*n\n    self.r=[0]*n\n    self.siz=n\n  def find_root(self,x):\n    if self.n[x]<0:\n      return x\n    else:\n      self.n[x]=self.find_root(self.n[x])\n      return self.n[x]\n  def unite(self,x,y):\n    x=self.find_root(x)\n    y=self.find_root(y)\n    if x==y:return\n    elif self.r[x]>self.r[y]:\n      self.n[x]+=self.n[y]\n      self.n[y]=x\n    else:\n      self.n[y]+=self.n[x]\n      self.n[x]=y\n      if self.r[x]==self.r[y]:\n        self.r[y]+=1\n    self.siz-=1\n  def root_same(self,x,y):\n    return self.find_root(x)==self.find_root(y)\n  def count(self,x):\n    return -self.n[self.find_root(x)]\n  def size(self):\n    return self.siz\n\nn=int(input())\nouf=UnionFind(n)\nzuf=UnionFind(n)\nfor _ in range(n-1):\n  a,b,c=map(int,input().split())\n  a-=1\n  b-=1\n  if c==0:\n    zuf.unite(a,b)\n  else:\n    ouf.unite(a,b)\nans=0\nfor i in range(n):\n  m=zuf.count(i)\n  if zuf.find_root(i)==i:ans+=m*(m-1)\n  mm=ouf.count(i)\n  if ouf.find_root(i)==i:ans+=mm*(mm-1)\n  ans+=(m-1)*(mm-1)\nprint(ans)", "class UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def calc_group_num(self):\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i) == i:\n                ans += 1\n        return ans\n\nimport sys\n\ninput=sys.stdin.readline\nn=int(input())\nuf0=UnionFindVerSize(n)\nuf1=UnionFindVerSize(n)\nfor i in range(n-1):\n    x,y,c=map(int,input().split())\n    if c==0:\n        uf0.unite(x-1,y-1)\n    else:\n        uf1.unite(x-1,y-1)\n\ndata=[0]*n\ncnt=[0]*n\nfor i in range(n):\n    root=uf1.find_root(i)\n    data[root]+=uf0.get_size(i)\n    cnt[root]+=1\n\nans=sum(data[i]*cnt[i] for i in range(n))\nprint(ans-n)"]
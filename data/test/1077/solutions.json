["#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\ntgt = n // m\nb = Counter(a)\nrd = sum(b[x] for x in b if x > m)\nr = 0\n\nfor i in range(1, m+1):\n  while rd and b[i] < tgt:\n    for j in range(n):\n      if a[j] > m:\n        b[a[j]] -= 1\n        b[i] += 1\n        a[j] = i\n        rd -= 1\n        r += 1\n        break\n  while b[i] < tgt:\n    for j in range(n):\n      if b[a[j]] > tgt:\n        b[a[j]] -= 1\n        b[i] += 1\n        a[j] = i\n        r += 1\n        break\n\nprint(tgt, r)\nprint(\" \".join(str(x) for x in a))", "n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\ncount_good = [[0, i + 1] for i in range(m)]\nbad = 0\nbad_places = []\ngood_places = [[i + 1, []] for i in range(m)]\nfor i in range(len(A)):\n    elem = A[i]\n    if elem <= m:\n        count_good[elem - 1][0] += 1\n        good_places[elem - 1][1].append(i)\n    else:\n        bad += 1\n        bad_places.append(i)\nideal = n // m\nfor elem in good_places:\n    bad_places.extend(elem[1][ideal:])\nbad = len(bad_places)\nbadd = bad\ncount_good.sort()\nminn = count_good[0][0]\nbad_Cnt = 0\nwhile minn != ideal:\n    j = 0\n    while j < len(count_good) and count_good[j][0] == minn and bad > 0:\n        count_good[j][0] += 1\n        A[bad_places[bad_Cnt]] = count_good[j][1]\n        bad_Cnt += 1\n        bad -= 1\n        j += 1\n    minn += 1\nprint(minn, badd - bad)\nprint(*A)\n", "a=[int(i) for i in (str(input())).split() ]\nn=a[0]\nm=a[1]\na=[int(i) for i in (str(input())).split() ]\nmaxmin=n//m\n\ngroups={}\nfor i in a:\n    groups[i]=0\nfor i in range(m):\n    groups[i+1]=0\n\nfor i in a:\n    groups[i]+=1\nchanges=0\nfor i in range(1,m+1):\n    while groups[i]<maxmin:\n        change=False\n        for n,j in enumerate(a):\n            #print(j)\n            if j <= m:\n                continue\n            groups[j]-=1\n            a[n]=i\n            groups[i]+=1\n            #print('kek')\n            changes+=1\n            change=True\n            if groups[i]>=maxmin:\n                break\n        \n        if groups[i]>=maxmin:\n            continue\n\n        for n,j in enumerate(a):\n            #print(j)\n            if groups[j]<=maxmin:\n                continue\n            #print(groups[j])\n            groups[j]-=1\n            a[n]=i\n            groups[i]+=1\n            changes+=1\n            change=True\n            if groups[i]>=maxmin:\n                break\n\nprint('%s %s'%(maxmin,changes))        \nfor i in a:\n    \n    print(i,end=' ')\n", "n, m = list(map(int, input().split()))\ntarget = n//m\nA = [int(i) for i in input().split()]\nB = [0 for _ in range(2005)]\nR = B[:]\nch = 0\nfor i in A:\n\tif i <= m:\n\t\tB[i] += 1\n\nfor i in range(2005):\n\tR[i] = target - B[i]\n\nj = 1\n\nfor i in range(n):\n\tif A[i] > m:\n\t\twhile j <= m and R[j] <= 0:\n\t\t\tj += 1\n\t\tif j <= m and R[j] > 0:\n\t\t\tch += 1\n\t\t\tR[j] -= 1\n\t\t\tA[i] = j\n\nfor i in range(n):\n\tif A[i] <= m and R[A[i]] < 0:\n\t\twhile j <= m and R[j] <= 0:\n\t\t\tj += 1\n\t\tif j <= m and R[j] > 0:\n\t\t\tR[j] -= 1\n\t\t\tR[A[i]] += 1\n\t\t\tA[i] = j\n\t\t\tch += 1\nprint(target, ch)\nprint(*A)\n", "n, m = list(map(int, input().split()))\ncount=[0]*(m+1)\nlother=[]\nlbig=[]\na=list(map(int, input().split()))\nfor i in range(len(a)):\n    if a[i]<=m:\n        count[a[i]]+=1\n    else:\n        lother.append(i)\nfor i in range(len(a)):\n    if a[i]<=m and count[a[i]]>n//m:\n        lbig.append(i)\n        count[a[i]]-=1\nans=0\nfor i in range(1,m+1):\n    while count[i]<n//m:\n        ans+=1\n        if len(lother)!=0:\n            a[lother[0]]=i\n            lother.pop(0)\n        else:\n            #print(\"in\")\n            #print(len(a))\n            #print(lbig[0])\n            a[lbig[0]]=i\n            lbig.pop(0)\n            #print('out');\n        count[i]+=1\nprint(str(n//m)+' '+str(ans))\nfor i in a:\n    print(i,end=' ')"]
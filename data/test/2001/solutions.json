["import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef add(a,b):\n\treturn (a+b)%1000000007\n\ndef mul(a,b):\n\treturn (a*b)%1000000007\n\ndef sub(a,b):\n\treturn (a-b+1000000007)%1000000007\n\ndef qpow(a, b):\n\tr = 1\n\tk = a\n\tfor i in range(17):\n\t\tif b & (1<<i):\n\t\t\tr = mul(r, k)\n\t\tk = mul(k, k)\n\treturn r\n\nn, q = mints()\na = list(minp())\nc = [0]*(n+1)\nfor i in range(n):\n\tc[i+1] = c[i] + int(a[i])\nfor i in range(q):\n\tl, r = mints()\n\tk = (r-l+1)\n\to = c[r]-c[l-1]\n\tz = sub(qpow(2,o),1)\n\tprint(mul(z,qpow(2,k-o)))", "import sys\nmod=10**9+7\nn,q=list(map(int,sys.stdin.readline().split()))\nS=sys.stdin.readline().strip()\nLR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]\n\nLIST=[0]\nfor s in S:\n    if s==\"1\":\n        LIST.append(LIST[-1]+1)\n    else:\n        LIST.append(LIST[-1])\n\ndef count(m,n,mod):\n    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod\n\nfor l,r in LR:\n    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))\n    \n", "import sys\ninput_file = sys.stdin\nC = (10**9+7)\n[n, q] = list(int(i) for i in input_file.readline().split())\ntemp = input_file.readline()\nlst = []\nfor char in temp[:-1]:\n    lst.append(int(char))\n    \nnew_lst = [(0, 0)]\nfor i in lst:\n    if i == 0:\n        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))\n    else:\n        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))\n\nls = [1]\nfor i in range(n):\n    ls.append(ls[-1]*2 % C)\n\nfor line in input_file:\n    [l, r] = list(int(i) for i in line[:-1].split())\n    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])\n    print((ls[sum(q)] - ls[q[0]]) % C)\n\n", "# Causes TLE\n# C++17 implemention -> 1062c.cpp\n\nMOD = 1000000007\n\ndef main():\n    buf = input()\n    buflist = buf.split()\n    n = int(buflist[0])\n    q = int(buflist[1])\n    buf = input()\n    x = buf\n    sum_list = [0] # sentinel / one indexing\n    for i, deliciousness in enumerate(x):\n        sum_list.append(int(deliciousness) + sum_list[i])\n    enjoyment_list = [0]\n    for i in range(n):\n        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)\n    query_list = []\n    for i in range(q):\n        buf = input()\n        buflist = buf.split()\n        l = int(buflist[0]) # one indexing\n        r = int(buflist[1]) # one indexing\n        query_list.append((l, r))\n    for i, query in enumerate(query_list):\n        l = query[0]\n        r = query[1]\n        banhmi_count = r - l + 1\n        delicious_count = sum_list[r] - sum_list[l - 1]\n        non_delicious_count = banhmi_count - delicious_count\n        enjoyment = 0\n        # main part\n        if delicious_count == 0:\n            enjoyment = 0\n        else:\n            enjoyment += enjoyment_list[delicious_count]\n            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])\n            enjoyment = enjoyment % MOD\n        print(enjoyment)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,q = list(map(int, input().split()))\na = input()\nQ = []\nfor _ in range(q):\n    Q.append(list(map(int, input().split())))\nd = [0]\nab = 0\nfor i in a:\n    if i == '1':\n        ab += 1\n    d.append(ab)\nmod = int(1e9 + 7)\np = [1]\ni = 1\nfor _ in range(n):\n    i = (i*2)%mod\n    p.append(i)\n    \nfor l,r in Q:\n    y = r-l + 1\n    x = d[r] - d[l-1]\n    y -= x\n    print(((p[x]-1)*p[y])%mod)", "import sys\ninput = sys.stdin.readline\nout = sys.stdout\nMOD = 1000000007\n\ndef main():\n    n, q = list(map(int, input().split()))\n    s = input()\n    d = {}\n    count_1 = 0\n    count_0 = 0\n    for i in range(n):\n        if s[i] == '1':\n            count_1 += 1\n        else:\n            count_0 += 1\n        z = (count_1, count_0)\n        d[i] = z\n    for i in range(q):\n        li, ri = list(map(int, input().split()))\n        li -= 1\n        ri -= 1\n        if li == 0:\n            answer = (pow(2, d[ri][0], MOD) - 1)*(pow(2, d[ri][1], MOD))\n        else:\n            answer = (pow(2, d[ri][0]-d[li-1][0], MOD) - 1)*(pow(2, d[ri][1]-d[li-1][1], MOD))\n        out.write(str(answer % MOD) + '\\n')\n                      \ndef __starting_point():\n    main()\n\n__starting_point()", "# use this as the main template for python problems\nimport sys\nfrom collections import Counter\nNUM = int(1e9+7)\n\ndef compute1(size, tots):\n\n    val = 0\n    ans = 0\n    for i in range(tots):\n        delic = val + 1\n        ans += delic\n        val = ((val % NUM) + (delic % NUM)) % NUM\n   \n    print('=--') \n    for i in range(size - tots):\n        delic = val\n        ans += delic\n        val = ((val % NUM) + (delic % NUM)) % NUM\n        print(delic)\n    print('=--') \n    return ans % int(1e9+7)\n\n\ndef compute2(size, tots):\n#    ans = 2 ** tots - 1\n    ans = power(2, tots, NUM) - 1\n    ans = ((ans % NUM) * (power(2, (size - tots), NUM))) % NUM\n    #ans = ((ans % NUM) * (2 ** (size - tots)) % NUM) % NUM\n    return ans \n\ndef power(x, y, p) : \n    res = 1     # Initialize result \n  \n    # Update x if it is more \n    # than or equal to p \n    x = x % p  \n  \n    while (y > 0) : \n          \n        # If y is odd, multiply \n        # x with result \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n  \n        # y must be even now \n        y = y >> 1      # y = y/2 \n        x = (x * x) % p \n          \n    return res \n\ndef solution(n, q, arr):\n\n    st = SegmentTree(arr, '+')\n    for x in range(q):\n        l, r = [int(val) for val in sys.stdin.readline().split()]\n        l -= 1\n        r -= 1\n        size = r - l + 1\n        #tots = sum(arr[l:r+1])\n        tots = st.query(l, r)\n        print(compute2(size, tots))\n\n\ndef validate():\n    from random import randint\n    for i in range(1, 20000):\n       \n        tots = randint(0, i)\n        val1 = compute1(i, tots)\n        val2 = compute2(i, tots)\n        if(val1 != val2):\n            print(val1, val2)\n            raise Exception()\n    #print(compute(1000000, 1000000))\n\n\ndef random_query(n):\n    from random import randint\n    l = randint(0, n-1)\n    r = randint(0, n-1)\n    while(r < l):\n        r = randint(0, n-1)\n    return l, r\n\ndef random_sequence(n):\n    from random import randint\n    return [randint(0, 1) for val in range(n)]\n\nclass SegmentTree(object):\n    \n    # this class was constructed with inspiration and guidance from:\n    # https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/\n    # O(n) leaves, O(n-1) internal nodes.\n    # build:  O(n) :D\n    # update: O(k), where k = height of tree :D\n    # query:  O(k), where k = height of tree :D\n    \n    def __init__(self, data, op):\n        \n        from math import log\n        from math import ceil\n        \n        # The node of the tree is at index 0, thus tree[0] is the root\n        # The children of three[i] are tored at tree[2*i+1] and tree[2*i+2]\n        # The internal nodes in \n        \n        self.n = len(data)\n        self.tree = [0] * self.n*4 #int(2 * 2 ** (ceil(log(n, 2))) - 1) * 2\n        self.merge_op = op\n       \n        self._build_tree(data, 0, 0, self.n-1)\n \n    def _build_tree(self, data, ind, lo, hi):\n        \n        # call as build_tree(data, 0, 0, n-1)\n    \n        # leaf node, store value\n        if (lo == hi):\n            self.tree[ind] = data[lo]\n            return\n        \n        # recurse\n        mid = lo + (hi - lo) // 2\n        self._build_tree(data, 2 * ind + 1, lo, mid)\n        self._build_tree(data, 2 * ind + 2, mid + 1, hi)\n    \n        # merge\n        self.tree[ind] = self._merge(self.tree[2 * ind + 1], self.tree[2 * ind + 2])\n        \n    def _merge(self, val1, val2):\n        \n        if(self.merge_op == '+'):\n            return val1 + val2\n        elif(self.merge_op == \"OR\"):\n            return val1 | val2\n        elif(self.merge_op == \"XOR\"):\n            return val1 ^ val2\n        elif(self.merge_op == \"*\"):\n            return val1 * val2 \n \n    def query(self, i, j, ind=0, lo=0, hi=None):\n    #def query(self, ind, lo, hi, i, j):\n        # call as query(0, 0, n-1, i, j)\n        # where i:j is the slice being queried\n        if(hi == None):\n            hi = self.n-1        \n\n        if (lo > j or hi < i):\n            raise Exception()\n            return 0 # represents null node completely outside segment\n        \n        if (i <= lo and j >= hi):\n            return self.tree[ind]\n        \n        mid = lo + (hi - lo) // 2\n        \n        if (i > mid):\n            return self.query(i, j, 2 * ind + 2, mid + 1, hi)\n        elif (j <= mid):\n            return self.query(i, j, 2 * ind + 1, lo, mid)\n        \n        lq = self.query(i, mid, 2 * ind + 1, lo, mid)\n        rq = self.query(mid + 1, j, 2 * ind + 2, mid + 1, hi)\n    \n        return self._merge(lq, rq)\n\n\ndef __starting_point():\n\n    # single variables\n    n, q = [int(val) for val in sys.stdin.readline().split()]\n\n    # vectors\n    arr = [int(val) for val in sys.stdin.readline().split()[0]]\n\n    #validate()\n    # solve it!\n    solution(n, q, arr)\n\n\n\n\n__starting_point()", "def beki(a,b):\n    waru=10**9+7\n    ans=1\n    while(b>0):\n        if(1 & b):\n            ans= ans * a %waru\n        b >>= 1\n        a=a * a % waru\n    return ans\n\nn,m=map(int,input().split())\ns=input()\n\n\nans=[]\nwaru=10**9+7\nruiseki=[0]*(n+1)\nbekij=[1]*(n+1)\nfor i in range(n):\n    ruiseki[i+1]=ruiseki[i]+int(s[i])\n    bekij[i+1]=(bekij[i]*2)%waru\nfor i in range(m):\n    l,r=map(int,input().split())\n    ko=ruiseki[r]-ruiseki[l-1]\n    ans.append(str((((bekij[ko] -1)) * ((bekij[r+1-l - ko]))) %waru))\n\nprint(\"\\n\".join(ans))", "def beki(a,b):\n    waru=10**9+7\n    ans=1\n    while(b>0):\n        if(1 & b):\n            ans= ans * a %waru\n        b >>= 1\n        a=a * a % waru\n    return ans\n\nn,m=map(int,input().split())\ns=input()\n\n\nans=[]\nwaru=10**9+7\nruiseki=[0]*(n+1)\nbekij=[1]*(n+1)\nfor i in range(n):\n    ruiseki[i+1]=ruiseki[i]+int(s[i])\n    bekij[i+1]=(bekij[i]*2)%waru\nfor i in range(m):\n    l,r=map(int,input().split())\n    ko=ruiseki[r]-ruiseki[l-1]\n    ans.append((((bekij[ko] -1)) * ((bekij[r+1-l - ko]))) %waru)\n\nprint(\"\\n\".join(list(map(str,ans))))", "\nimport sys\ndef __starting_point():\n    n, q = list(map(int, sys.stdin.readline().split()))\n    arr = sys.stdin.readline()\n    total = [0]*n\n    if arr[0] == '1':\n        total[0] = 1\n    else:\n        total[0] = 0\n    for i in range(1, n):\n        if arr[i] == '1':\n            total[i] = total[i-1]+1\n        else:\n            total[i] = total[i-1]\n    mod = 10**9+7\n    for i in range(q):\n        l, r = list(map(int, sys.stdin.readline().split()))\n        l -= 1\n        r -= 1\n        length = r-l+1\n        ans = pow(2, length, mod)\n        ans = (ans-1+mod) % mod\n        if l == 0:\n            zeroes = length-total[r]\n        else:\n            zeroes = length-(total[r]-total[l-1])\n        sub = pow(2, zeroes, mod)\n        sub = (sub-1+mod) % mod\n        ans = (ans-sub+mod) % mod\n        print(ans)\n\n__starting_point()", "import sys\ndef numIN():\n    return(map(int,sys.stdin.readline().strip().split()))\n\nMOD = 10**9+7\n\nn,q = numIN()\nl = [int(i) for i in input()]\npre = []\ns = 0\nfor i in l:\n    s+=i\n    pre.append(s)\nfor i in range(q):\n    l,r = numIN()\n    l-=1\n    r-=1\n    if l!=0:\n        one = pre[r]-pre[l-1]\n        zero = r-l+1-one\n        x = pow(2,one,MOD)-1\n        y = pow(2,zero,MOD)\n        ans = x*y\n        ans%=MOD\n        print(ans)\n    else:\n        one = pre[r]\n        zero = r-l+1-one\n        x = pow(2,one,MOD)-1\n        y = pow(2,zero,MOD)\n        ans = x*y\n        ans%=MOD\n        print(ans)", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nimport sys\nimport math\nMAX = sys.maxsize\nMOD = 10**9+7\nMAXN = 10**6+10\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(map(int,sys.stdin.readline().strip().split()))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\ndef maxSubArraySum(a,size): \n      \n    max_so_far = 0\n    max_ending_here = 0\n      \n    for i in range(size): \n        max_ending_here = max_ending_here + a[i] \n        if max_ending_here < 0: \n            max_ending_here = 0 \n        elif (max_so_far < max_ending_here): \n            max_so_far = max_ending_here \n              \n    return max_so_far\n\ndef isPer(n):\n\treturn((math.floor(n**0.5))==(math.ceil(n**0.5)))\n\ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n  \n    if (m == 1) : \n        return 0\n  \n    while (a > 1) : \n  \n        # q is quotient \n        q = a // m \n  \n        t = m \n  \n        # m is remainder now, process \n        # same as Euclid's algo \n        m = a % m \n        a = t \n        t = y \n  \n        # Update x and y \n        y = x - q * y \n        x = t \n  \n  \n    # Make x positive \n    if (x < 0) : \n        x = x + m0 \n  \n    return x\n\nn,q = numIN()\nl = [int(i) for i in input()]\npre = []\ns = 0\nfor i in l:\n\ts+=i\n\tpre.append(s)\nfor i in range(q):\n\tl,r = numIN()\n\tl-=1\n\tr-=1\n\tif l!=0:\n\t\tone = pre[r]-pre[l-1]\n\t\tzero = r-l+1-one\n\t\tx = pow(2,one,MOD)-1\n\t\ty = pow(2,zero,MOD)\n\t\tans = x*y\n\t\tans%=MOD\n\t\tprint(ans)\n\telse:\n\t\tone = pre[r]\n\t\tzero = r-l+1-one\n\t\tx = pow(2,one,MOD)-1\n\t\ty = pow(2,zero,MOD)\n\t\tans = x*y\n\t\tans%=MOD\n\t\tprint(ans)", "def beki(a,b):\n    waru=10**9+7\n    ans=1\n    while(b>0):\n        if(1 & b):\n            ans= ans * a %waru\n        b >>= 1\n        a=a * a % waru\n    return ans\nn,m=list(map(int,input().split()))\ns=input()\n\nans=[]\nwaru=10**9+7\n\nru=[0]*(n+1)\nb=[1]*(n+1)\nfor i in range(n):\n    ru[i+1]=ru[i]+int(s[i])\n    b[i+1]=(b[i]*2)%waru\nfor i in range(m):\n    l,r=list(map(int,input().split()))\n    ko=ru[r]-ru[l-1]\n    ans.append((((b[ko] -1)) * ((b[r+1-l - ko]))) %waru)\n\nprint(\"\\n\".join(list(map(str,ans))))\n"]
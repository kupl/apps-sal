["def sum_first(di):\n    return di * (di + 1) // 2\n\n\nn, x = list(map(int, input().split()))\nn *= 2\nd = tuple(map(int, input().split())) * 2\nans = 0\ni = 0\nj = 0\ncur_ans = 0\ntotal_days = 0\nwhile j <= n:\n    if total_days < x:\n        if j == n:\n            break\n        cur_ans += sum_first(d[j])\n        total_days += d[j]\n        j += 1\n    else:\n        ans = max(ans, cur_ans - sum_first(total_days - x))\n        cur_ans -= sum_first(d[i])\n        total_days -= d[i]\n        i += 1\nprint(ans)\n", "def sumprog(a, b):\n    return (a + b) * (b - a + 1) // 2\n\n\nn, x = map(int, input().split())\nd = list(map(int, input().split())) * 2\nmax_hugs = 0\ni = 0\nj = 0\ndays = 0\nhugs = 0\nwhile i < n:\n    if days + d[j] <= x:\n        days += d[j]\n        hugs += sumprog(1, d[j])\n        j += 1\n    else:\n        max_hugs = max(max_hugs, hugs + sumprog(d[j] - (x - days) + 1, d[j]))\n        hugs -= sumprog(1, d[i])\n        days -= d[i]\n        i += 1\nprint(max_hugs)", "import sys\nreadline = sys.stdin.readline\n\nN, X = list(map(int, readline().split()))\nD = list(map(int, readline().split()))\nAD = D+D + [0]\nS = [d*(d+1)//2 for d in D]\nS = S+S + [0]\nfor i in range(1, 2*N):\n    AD[i] += AD[i-1]\n    S[i] += S[i-1]\n\nD = D + D + [0]\n\nans = 0\nfor r in range(N, 2*N):\n    ng = -1\n    ok = r\n    while abs(ok-ng) > 1:\n        med = (ok+ng)//2\n        if AD[r] - AD[med] < X:\n            ok = med\n        else:\n            ng = med\n    l = ok\n    res = S[r] - S[l-1] \n    dd = D[l] - (X-(AD[r]-AD[l])) \n    res -= dd*(dd+1)//2\n    ans = max(ans, res)\nprint(ans)\n    \n", "import sys\ninput = sys.stdin.readline\nn,x=map(int,input().split())\nd=list(map(int,input().split()))\nmx=0\ni=n-1\nj=n-1\nk=0\ncursum=0\nmiss=x\nwhile d[j]<miss:\n    miss-=d[j]\n    cursum+=(d[j]*(d[j]+1))//2\n    j-=1\nk=d[j]-miss\ncursum+=(d[j]*(d[j]+1))//2\ncursum-=(k*(k+1))//2\nmiss=0\nmx=cursum\nwhile i>=0:\n    miss=d[i]\n    cursum-=(d[i]*(d[i]+1))//2\n    cursum+=(k*(k+1))//2\n    cursum-=(d[j]*(d[j]+1))//2\n    miss-=k\n    miss+=d[j]\n    while d[j]<miss:\n        miss-=d[j]\n        cursum+=(d[j]*(d[j]+1))//2\n        j-=1\n        if j<0:\n            j=n-1\n    k=d[j]-miss\n    cursum+=(d[j]*(d[j]+1))//2\n    cursum-=(k*(k+1))//2\n    miss=0\n    mx=max(mx,cursum)\n    i-=1\nprint(mx)", "N, X = [int(_) for _ in input().split()]\nD = [int(_) for _ in input().split()]\n\ndays_per_year = sum(D)\nyear_value = sum([(d * (d+1)) // 2 for d in D])\n\n\nanswer = year_value * (X // days_per_year)\nX = X % days_per_year\n\n# print('pre_answer', answer)\n# print(X, 'days in last year to add')\n\nanswer_year = 0\ni = N\npm = N-1\npd = D[N-1]\nc = 0\nto_add = None\nwhile i >= 0:\n    if i < N:\n        c -= (D[i]*(D[i]+1))//2\n    # print('after removing previous month', c)\n    if to_add is None:\n        to_add = X\n    else:\n        to_add = D[i]\n    while D[pm] - (D[pm]-pd) <= to_add:\n        to_add -= D[pm] - (D[pm]-pd)\n        c += (pd*(pd+1))//2\n        # print('after adding month', pm, ':', c)\n        pm -= 1\n        if pm < 0:\n            pm = N-1\n        pd = D[pm]\n        # print('still', to_add, 'days to add')\n    h = pd\n    pd -= to_add\n    l = pd\n    # print(to_add, 'days to add', l, h)\n    c += ((h*(h+1))//2) - ((l*(l+1))//2)\n    # print('after adding last days', c)\n    answer_year = max(answer_year, c)\n    # print(i, c)\n    i -= 1\n\nanswer += answer_year\nprint(answer)\n", "n, x = [int(x) for x in input().split()]\n\nd = [int(x) for x in input().split()]\n\ndd = d + d\n\ndef b2(k):\n    return k*(k+1)//2\n\n# end_pt points to the month of which we want to end on the final day.\nend_pt = 0\ndays = 0\n\n# best keeps track of the best number of hugs we can get.\nbest = 0\n\n# cur_hugs is the number of hugs we currently get if we end at the last day of\n# month end_pt.\ncur_hugs = b2(dd[0])\nwhile days + dd[end_pt] < x:\n    days += dd[end_pt]\n    end_pt += 1\n    cur_hugs += b2(dd[end_pt])\n\n# start_pt points towards the month in which we start, specifically on day start_day\n# we are doing our months 0-indexed (to match dd) but our days 1-indexed.\nstart_pt = 0\nstart_day = days + dd[end_pt] - x + 1\n\nwhile start_day > dd[start_pt]:\n    start_day -= dd[start_pt]\n    cur_hugs -= b2(dd[start_pt])\n    start_pt += 1\n\ncur_hugs -= b2(start_day - 1)\nbest = cur_hugs\n\nif False:\n    print(\"Initial:\")\n    print(\"dd = \", dd)\n    print(\"end_month = \", end_pt)\n    print(\"start_month = \", start_pt)\n    print(\"start_day = \", start_day)\n    print(\"cur_hugs = best = \", best)\n\nwhile end_pt + 1 < len(dd):\n    end_pt += 1\n    cur_hugs += b2(dd[end_pt])\n    cur_hugs += b2(start_day - 1)\n    start_day += dd[end_pt]\n    while start_day > dd[start_pt]:\n        start_day -= dd[start_pt]\n        cur_hugs -= b2(dd[start_pt])\n        start_pt += 1\n    cur_hugs -= b2(start_day - 1)\n    best = max(best, cur_hugs)\n\nprint(best)\n", "def sm(x) :\n    return x * (x + 1) // 2\n\ndef get_sum(l, r) :\n    return sm(r) - sm(l - 1)\n\nn, x = list(map(int, input().split()))\nd = [int(i) for i in input().split()]\nd = d[:] + d[:]\nn *= 2\npre = [d[0]]\nmonth, day, days, tot = n - 1, d[n - 1] + 1, 0, 0\nans = 0\nfor i in range(n - 1, -1, -1) :\n    while days < x and month >= 0:\n        if day > 1 :\n            cnt = min(x - days, day - 1)\n            tot += get_sum(day - cnt, day - 1)\n            days += cnt\n            day -= cnt\n        else :\n            month -= 1\n            day = d[month] + 1\n    ans = max(ans, tot)\n    tot -= get_sum(1, d[i])\n    days -= d[i]\nprint(ans)\n\n", "from collections import deque\nn,x = map(int,input().split())\nd = list(map(int,input().split()))\n\nq = deque([])\nsum_q = 0\n\nsq = deque([])\nsum_sq = 0\n\nfor i in range(n):\n    \n    q.append(d[i])\n    sum_q +=d[i]\n\n    sq.append( (d[i]+1)*d[i]//2 )\n    sum_sq += (d[i]+1)*d[i]//2\n\nans = 0\n\nfor i in range(n):\n\n    q.append(d[i])\n    sum_q += d[i]\n    sq.append( (d[i]+1)*d[i]//2 )\n    sum_sq += (d[i]+1)*d[i]//2\n\n    while sum_q - q[0] >= x:\n        sum_q  -= q.popleft()\n        sum_sq -= sq.popleft()\n    #print (q,sq,sum_q,sum_sq)\n\n    origin = sum_sq - sq[0]\n    remday = x - ( sum_q - q[0] )\n    differ = (q[0] + q[0]-remday+1)*remday//2\n    #print (origin,remday,differ)\n\n\n    ans = max(ans , origin + differ)\n\nprint (ans)", "from sys import stdin,stderr\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\nn, end_day = rl()\nd = rl()\n\nstart_month = start_day = end_month = hugs = 0\nwhile end_month < n and end_day >= d[end_month]:\n    hugs += (d[end_month] * (d[end_month] + 1)) // 2\n    end_day -= d[end_month]\n    end_month += 1\nhugs += (end_day * (end_day + 1)) // 2\n\nmax_hugs = hugs\nif end_month < n:\n    while start_month < n:\n        step = min(d[start_month] - start_day, d[end_month] - end_day)\n        hugs += step * (end_day - start_day)\n        start_day += step\n        if start_day >= d[start_month]:\n            start_day = 0\n            start_month += 1\n        end_day += step\n        if end_day >= d[end_month]:\n            end_day = 0\n            end_month += 1\n            if end_month >= n:\n                end_month = 0\n        if hugs > max_hugs:\n            max_hugs = hugs\n\nprint(max_hugs)\n", "import sys\ninput = sys.stdin.readline\n\nn,x=list(map(int,input().split()))\nD=list(map(int,input().split()))\n\nD2=[x*(x+1)//2 for x in D]\n\nfrom itertools import accumulate\n\nS=[0]+list(accumulate(D+D))\nS2=[0]+list(accumulate(D2+D2))\n\nANS=0\n\nimport bisect\n\nfor i in range(2*n+1):\n    if S[i]-x<0:\n        continue\n    y=bisect.bisect_left(S,S[i]-x)\n\n    score=S2[i]-S2[y]\n    rest=x-(S[i]-S[y])\n\n    #print(score,i,rest,D[(y-1)%n])\n    MAX=D[(y-1)%n]\n\n    score+=(MAX+(MAX-rest+1))*rest//2\n\n    #print(score)\n\n    ANS=max(ANS,score)\n\nprint(ANS)\n    \n    \n", "n, x = tuple(map(int, input().split()))\narr = list(map(int, input().split()))\n\narr += arr[::]\narr2 = [i * (i + 1) // 2 for i in arr]\n\nans = 0\nfor now_month in range(n, n * 2):\n    if now_month == n:\n        last_month = now_month\n        count_obnim = 0\n        count_days = 0\n        while count_days + arr[last_month] <= x:\n            count_days += arr[last_month]\n            count_obnim += arr2[last_month]\n            last_month -= 1\n\n        dop_days = x - count_days\n        nodop_days = arr[last_month] - dop_days\n        dop_obnim = arr2[last_month] - nodop_days * (nodop_days + 1) // 2\n        count_days += dop_days\n        count_obnim += dop_obnim\n    else:\n        count_days += arr[now_month]\n        count_days -= dop_days\n        count_obnim += arr2[now_month]\n        count_obnim -= dop_obnim\n\n        while count_days > x:\n            count_days -= arr[last_month + 1]\n            count_obnim -= arr2[last_month + 1]\n            last_month += 1\n\n        dop_days = x - count_days\n        nodop_days = arr[last_month] - dop_days\n        dop_obnim = arr2[last_month] - nodop_days * (nodop_days + 1) // 2\n        count_days += dop_days\n        count_obnim += dop_obnim\n\n    ans = max(ans, count_obnim)\n\nprint(ans)\n", "n, x = list(map(int, input().split()))\nd = list(map(int, input().split()))\naccum = (3 * n) * [0]\naccum2 = (3*n)*[0]\nfor i in range(3 * n):\n    if i > 0:\n        accum[i] = accum[i-1]\n        accum2[i] = accum2[i-1]\n    accum[i] += (((d[i % n] + 1) * d[i % n]) // 2)\n    accum2[i] += d[i % n]\n\nans = 0\ntemp_ans = (d[0] + 1) * d[0] // 2\nj = 0\ndays = d[0]\nfor i in range(n):\n    while days < x:\n        j += 1\n        days += d[j % n]\n        temp_ans += (d[j % n] + 1) * d[j % n] // 2\n\n    dif = days - x\n    if dif == 0:\n        ans = max(temp_ans, ans)\n    else:\n        ans = max(temp_ans-(dif+1)*dif//2, ans)\n    days -= d[i]\n    temp_ans -= (d[i]+1)*d[i]//2\nprint(ans)\n", "from bisect import *\nn, x = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.extend(d)\n\ndate_acc = [0]\ntot_acc = [0]\nfor i in range(n*2):\n    date_acc.append(date_acc[i]+d[i])\n    tot_acc.append(tot_acc[i]+(d[i]*(d[i]+1))//2)\n\nans = 0\nfor i in range(n+1, 2*n+1):\n    now = date_acc[i]\n    start_i = bisect_left(date_acc, now-x)\n    start = date_acc[start_i]\n    remain = x - (now - start)\n    temp = tot_acc[i] - tot_acc[start_i]\n    temp += (remain*(2*d[start_i-1]-remain+1))//2\n    ans = max(ans, temp)\n\nprint(ans)\n", "def right_m(me, num):\n    k = min(me, num)\n    return k * (k + 1) // 2\ndef left_m(me, num):\n    k = me\n    if me <= num:\n        return k * (k + 1) // 2\n    l = me - num\n    return k * (k + 1) // 2 - l * (l + 1) // 2\ndef ans(lm, rm, num):\n    if num <= lm:\n        return left_m(lm, num)\n    ans = right_m(rm, num)\n    num -= rm\n    if num > 0:\n        ans += left_m(lm, num)\n    return ans\nn, x = map(int, input().split())\nlst = list(map(int,input().split()))\ndaysnum = [0] * n * 2\nansnum = [0] * n * 2\ndaysnum[0] = lst[0]\nansnum[0] = (lst[0] + 1) * lst[0] // 2\nfor i in range(1, 2 * n):\n    daysnum[i] = daysnum[i-1] + lst[i%n]\n    ansnum[i] = ansnum[i-1] + (lst[i%n] + 1) * lst[i%n] // 2\nleftnum = 0\nrightnum = 1\nmaxans = 0\nwhile leftnum < n and rightnum < 2 * n:\n    if leftnum == rightnum:\n        rightnum += 1\n        continue\n    ihave = x - daysnum[rightnum - 1] + daysnum[leftnum]\n    if ihave < 0:\n        leftnum += 1\n        continue\n    ansnow = ansnum[rightnum - 1] - ansnum[leftnum]\n    ansnow += ans(lst[leftnum%n], lst[rightnum%n], ihave)\n    maxans = max(maxans, ansnow)\n    rightnum += 1\nprint(maxans)"]
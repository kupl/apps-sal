["import sys\n\nSIGMA = 26\n\nnodes = []\npairs = []\nres = 0\n\nclass Node:\n    def __init__(self):\n        self.ch = {}\n        self.a = []\n        self.b = []\n        self.d = 0\n\n    def add(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                t.ch[v] = Node()\n                t.ch[v].d = t.d + 1\n                nodes.append(t.ch[v])\n            t = t.ch[v]\n        t.a.append(i)\n\n    def inc(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                break\n            t = t.ch[v]\n        t.b.append(i)\n\n    def solve(self):\n        nonlocal pairs\n        nonlocal res\n        for i in range(SIGMA):\n            if i in self.ch:\n                self.a.extend(self.ch[i].a)\n                self.b.extend(self.ch[i].b)\n        k = min(len(self.a), len(self.b))\n        for i in range(k):\n            pairs.append(str(self.a[-1]) + ' ' + str(self.b[-1]))\n            self.a.pop()\n            self.b.pop()\n            res += self.d\n        return res\n\nsys.setrecursionlimit(2000000)\n_input = sys.stdin.readlines()\n_input = [s[:-1] for s in _input]\nN = int(_input[0])\nA = _input[1 : N + 1]\nB = _input[N + 1 :]\nT = Node()\nnodes.append(T)\nfor i, s in enumerate(A):\n    T.add(s, i + 1)\nfor i, s in enumerate(B):\n    T.inc(s, i + 1)\nfor n in reversed(nodes):\n    n.solve()\nprint(res)\nprint('\\n'.join(pairs))\n", "import sys\n\nSIGMA = 26\n\nnodes = []\npairs = []\nres = 0\n\nclass Node:\n    def __init__(self):\n        self.ch = {}\n        self.a = []\n        self.b = []\n        self.d = 0\n\n    def add(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                t.ch[v] = Node()\n                t.ch[v].d = t.d + 1\n                nodes.append(t.ch[v])\n            t = t.ch[v]\n        t.a.append(i)\n\n    def inc(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                break\n            t = t.ch[v]\n        t.b.append(i)\n\n    def solve(self):\n        nonlocal pairs\n        nonlocal res\n        for i in range(SIGMA):\n            if i in self.ch:\n                self.a.extend(self.ch[i].a)\n                self.b.extend(self.ch[i].b)\n        k = min(len(self.a), len(self.b))\n        for i in range(k):\n            pairs.append(str(self.a[-1]) + ' ' + str(self.b[-1]))\n            self.a.pop()\n            self.b.pop()\n            res += self.d\n        return res\n\n_input = sys.stdin.readlines()\n_input = [s[:-1] for s in _input]\nN = int(_input[0])\nA = _input[1 : N + 1]\nB = _input[N + 1 :]\nT = Node()\nnodes.append(T)\nfor i, s in enumerate(A):\n    T.add(s, i + 1)\nfor i, s in enumerate(B):\n    T.inc(s, i + 1)\nfor n in reversed(nodes):\n    n.solve()\nprint(res)\nprint('\\n'.join(pairs))\n", "import sys\n\nclass Node:\n    def __init__(self, d):\n        nonlocal nodes\n        self.ch = {}\n        self.a = [[], []]\n        self.d = d\n        nodes += [self]\n\nnodes = []\npairs = []\nres = 0\n\nN = int(sys.stdin.readline())\n_input = sys.stdin.readlines()\n_input = [s[:-1] for s in _input]\nA = [_input[:N], _input[N:]]\nT = Node(0)\n\nfor i, l in enumerate(A):\n    for j, s in enumerate(l):\n        t = T\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                t.ch[v] = Node(t.d + 1)\n            t = t.ch[v]\n        t.a[i] += [j + 1]\n\nfor n in reversed(nodes):\n    for i in n.ch:\n        n.a[0] += n.ch[i].a[0]\n        n.a[1] += n.ch[i].a[1]\n    k = min(len(n.a[0]), len(n.a[1]))\n    for i in range(k):\n        pairs += [str(n.a[0][-1]) + ' ' + str(n.a[1][-1])]\n        n.a[0].pop()\n        n.a[1].pop()\n        res += n.d\n\nprint(res)\nprint('\\n'.join(pairs))\n", "import sys\n\nclass Node:\n    def __init__(self, d):\n        nonlocal nodes\n        self.ch = {}\n        self.a = [[], []]\n        self.d = d\n        nodes += [self]\n\nnodes = []\npairs = []\nres = 0\n\nN = int(sys.stdin.readline())\n_input = sys.stdin.readlines()\n_input = [s[:-1] for s in _input]\nA = [_input[:N], _input[N:]]\nT = Node(0)\n\nfor i, l in enumerate(A):\n    for j, s in enumerate(l):\n        t = T\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                t.ch[v] = Node(t.d + 1)\n            t = t.ch[v]\n        t.a[i] += [j + 1]\n\nfor n in reversed(nodes):\n    for i in n.ch:\n        n.a[0] += n.ch[i].a[0]\n        n.a[1] += n.ch[i].a[1]\n    k = min(len(n.a[0]), len(n.a[1]))\n    for i in range(k):\n        pairs += [str(n.a[0][-1]) + ' ' + str(n.a[1][-1])]\n        n.a[0].pop()\n        n.a[1].pop()\n        res += n.d\n\nprint(res)\nprint('\\n'.join(pairs))\n"]
["INT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\nfrom collections import deque\n\nclass Graph():\n    def __init__(self, v):\n        from heapq import heappop, heappush\n        self.v = v\n        self.graph = [[] for _ in range(v)]\n        self.INF = 10 ** 9\n    \n    def addEdge(self, start, end, edge):\n        self.graph[start].append((end, edge))\n        self.graph[end].append((start, edge))\n\ndef do():\n    n=INT()\n    g=Graph(n)\n    for i in range(n-1):\n        a,b=INTM()\n        a-=1\n        b-=1\n        g.addEdge(a,b,i)\n\n    \n    que=deque()\n    check=[True]*n\n    clrs=[0]*(n-1)\n    que.append([0,0])\n    check[0]=False\n    while que:\n        clr=1\n        now,clr_f=que.popleft()\n        if clr_f==1:\n            clr=2\n        for next,i in g.graph[now]:\n            if check[next]:\n                check[next]=False\n                que.append([next,clr])\n                clrs[i]=clr\n                clr+=1\n                if clr==clr_f:\n                    clr+=1\n    \n    print(max(clrs))\n    for i in range(n-1):\n        print(clrs[i])\n\n\n\n\n\n\n\n\ndef __starting_point():\n    do()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nN = int(input())\nAB = [tuple(map(int,input().split())) for i in range(N-1)]\nes = [[] for _ in range(N)]\nfor i,(a,b) in enumerate(AB):\n    a,b = a-1,b-1\n    es[a].append((b,i))\n    es[b].append((a,i))\n\nans = [None] * (N-1)\n\ndef dfs(v,p=-1,c=-1):\n    nc = 1\n    for to,e in es[v]:\n        if to==p: continue\n        if nc==c: nc += 1\n        ans[e] = nc\n        dfs(to,v,nc)\n        nc += 1\ndfs(0)\n\nprint(max(ans))\nprint(*ans, sep='\\n')", "N = int(input())\ngraph = [[] for _ in range(N+1)]\nAB = []\n\nfor _ in range(N-1):\n  a, b = list(map(int, input().split()))\n  graph[a].append(b)\n  graph[b].append(a)\n  AB.append((a, b))\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\n\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ncolor = [-1] * (N+1)\nK = -1\nfor x in order:\n    ng = color[x]\n    c = 1\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        if c == ng:\n            c += 1\n        K = max(c, K)\n        color[y] = c\n        c += 1\n\nans = []\n\nfor a, b in AB:\n    if parent[a] == b:\n        ans.append(color[a])\n    else:\n        ans.append(color[b])\n\nprint(K)\nfor i in ans:\n  print(i)\n", "from collections import deque,defaultdict\nn = int(input())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    a,b=list(map(int, input().split()))\n    edges[a-1].append([b-1,i])\n    edges[b-1].append([a-1,i])\nc = 1\ncol = [0]*(n-1)\nvisited = [0]*(n-1)\nque=deque()\nfor v in edges[0]:\n    que.append(v)\n    col[v[1]]=c\n    visited[v[1]]=1\n    c+=1\nwhile que:\n    v=que.popleft()\n    c = 1\n    used = set()\n    for i in edges[v[0]]:\n        if(visited[i[1]]):\n            used.add(col[i[1]])\n    for next_v in edges[v[0]]:\n        if(not visited[next_v[1]]):\n            if(c in used):\n                c+=1\n            col[next_v[1]] = c\n            used.add(c)\n            c+=1\n            visited[next_v[1]] = 1\n            que.append(next_v)\nprint((max(col)))\nfor i in col:\n    print(i)\n", "from collections import deque\n\ndef main():\n  n = int(input())\n  graph=[[] for _ in range(n+1)]\n  for i in range(1,n):\n    a,b = map(int, input().split())\n    d1 = {\"id\":i,\"to\":b}\n    d2 = {\"id\":i,\"to\":a}\n    graph[a].append(d1)\n    graph[b].append(d2)\n  \n  k = 0\n  root = 1\n  for i in range(1, n+1):\n    if k < len(graph[i]):\n      root = i\n      k = max(k, len(graph[i]))\n  print(k)\n  q=deque([root])\n  color=[[] for _ in range(n+1)]\n  reached=[False]*(n+1)\n  ans=[0]*(n)\n  while q:\n    current = q.popleft()\n    reached[current] = True\n    temp = 1\n    for dic in graph[current]:\n      id = dic[\"id\"]\n      next = dic[\"to\"]\n      if reached[next]:\n        continue\n      while temp in color[current]:\n        temp += 1\n      color[next].append(temp)\n      ans[id] = temp\n      temp += 1\n      q.append(next)\n  for i in ans[1:]:\n    print(i)\n      \ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\nn=int(input())\nab=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    ab[a].append([b,i])\nque=deque()\nque.append(1)\nvisited=[0]*(n)\nans=[0]*(n-1)\nwhile que:\n    x=que.popleft()\n    k=1\n    for j in ab[x]:\n        if visited[x-1]!=k:\n            ans[j[1]]+=k\n            visited[j[0]-1]+=k\n            k+=1\n            que.append(j[0])\n        else:\n            ans[j[1]]+=(k+1)\n            visited[j[0]-1]+=(k+1)\n            k+=2\n            que.append(j[0])\nprint(max(ans))\nfor l in ans:\n    print(l)", "import sys\nfrom collections import deque\n\nn = int(sys.stdin.readline())\nG = [[] for _ in range(n+1)]\nG_order = []\nfor i in range(n-1):\n    a,b = map(lambda x:int(x)-1, sys.stdin.readline().split())\n    G[a].append(b)\n    G_order.append(b)\n\nque = deque([0])\nC = [0]*(n+1)\nwhile que:\n    nw = que.popleft()\n    c = 1\n    for nx in G[nw]:\n        if c==C[nw]:\n            c+=1\n        C[nx] = c\n        c += 1\n        que.append(nx)\n\nprint(max(C))\nfor i in G_order:\n    print(C[i])", "from collections import deque\nn = int(input())\na = [[] for i in range(n)]\ne = []\nfor i in range(n-1):\n  b, c = map(int, input().split())\n  b -= 1\n  c -= 1\n  a[b].append(c)\n  e.append(c)\ncol = [0 for i in range(n)]\nv = deque([0])\n\nwhile v:\n  d = v.popleft()\n  k = 1\n  for i in a[d]:\n    if col[d] == k:\n      k += 1\n    col[i] = k\n    v.append(i)\n    k += 1\nprint (max(col))\nfor i in e:\n  print(col[i])", "from collections import deque, defaultdict\nN = int(input())\nd = defaultdict(list)\nm = dict()\nls = []\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    d[a].append(b)\n    d[b].append(a)\n    ls.append((a, b))\n\nK = 0\nfor i in range(N):\n    d[i+1].sort()\n    K = max(K, len(d[i+1]))\nprint(K)\n\nq = deque([])\nq.append((1, 0))\nvisited = [0 for i in range(N+1)]\nvisited[1] = 1\nwhile q:\n    l, r = q.popleft()\n    flag = 0\n    cur = 1\n    for i, x in enumerate(d[l], start=1):\n        if visited[x] == 1:\n            continue\n        if flag == 0:\n            if cur == r:\n                q.append((x, cur+1))\n                m[(l, x)] = cur+1\n                m[(x, l)] = cur+1\n                cur += 2\n                visited[x] = 1\n                flag = 1\n                continue\n            m[(l, x)] = cur\n            m[(x, l)] = cur\n            q.append((x, cur))\n            cur += 1\n            visited[x] = 1\n        else:\n            q.append((x, cur))\n            m[(l, x)] = cur\n            m[(x, l)] = cur\n            cur += 1\n            visited[x] = 1\nfor i in range(N-1):\n    a, b = ls[i]\n    print(m[(a, b)])", "#create date: 2020-07-05 13:34\n\nimport sys\nstdin = sys.stdin\nfrom collections import deque\n\ndef ns(): return stdin.readline().rstrip()\ndef ni(): return int(ns())\ndef na(): return list(map(int, stdin.readline().split()))\n\ndef main():\n    n = ni()\n    g = [list() for _ in range(n)]\n    to = list()\n    for i in range(n-1):\n        a, b = na()\n        a -= 1; b -= 1\n        g[a].append(b)\n        to.append(b)\n    l = [-1] * n\n    l[0] = 10**10\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vcolor = l[v]\n        for i, w in enumerate(g[v]):\n            q.append(w)\n            if i < vcolor:\n                l[w] = i\n            else:\n                l[w] = i + 1\n\n    print(max(l[1:])+1)\n    for i in to:\n        print(l[i]+1)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nt = [[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    a, b = map(int,input().split())\n    t[a].append((b,i))\n    t[b].append((a,i))\nnum = max([len(tmp) for tmp in t])\nprint(num)\n\nans = [-1]*(n-1)\n\ndef dfs(n, before, bcol):\n    col = 1\n    for i, j in t[n]:\n        if i == before:\n            continue\n        if col == bcol:\n            col += 1\n        ans[j] = col\n        dfs(i, n, col)\n        col += 1\n\ndfs(1, 0, -1)\nfor i in range(n-1):\n    print(ans[i])", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10**8)\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nnumOfEdges = [0 for _ in range(N)]\nvisited = [0 for _ in range(N)]\nedges = defaultdict(int)\n\nfor i in range(1, N):\n    a, b = list(map(int, input().split()))\n    a -= 1; b -= 1;\n    numOfEdges[a] += 1\n    numOfEdges[b] += 1\n    edges[(a, b)] = 0\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(prev, now, col):\n    if visited[now]:\n        return\n    visited[now] = 1\n    i = 1\n    for adj in graph[now]:\n        if adj == prev:\n            continue\n        if now < adj:\n            edges[(now, adj)] = col + i\n        else:\n            edges[(adj, now)] = col + i\n        dfs(now, adj, col+i)\n        i += 1\n\ndfs(-1, 0, 1)\nmaxColor = max(numOfEdges)\nprint(maxColor)\n\nfor k, i in list(edges.items()):\n    e = i % maxColor\n    if e:\n        print(e)\n    else:\n        print(maxColor)\n", "from collections import deque\nn=int(input())\ng=[[] for _ in range(n+1)]\ne=[]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    g[a-1].append(b-1)\n    e.append(b-1)\n\nq=deque([0])\n\ncolor=[0 for _ in range(n)]\nwhile(len(q)>0):\n    ei=q.popleft()\n    c=1\n    for x in g[ei]:\n        if c == color[ei]:\n            c+=1\n\n        color[x]=c\n        c+=1\n        q.append(x)\n\nprint(max(color))\nfor i in e:\n    print(color[i])", "from collections import deque\n\ndef main():\n    n = int(input())\n    adj = [[]for i in range(n+1)]\n    ab = [list(map(int, input().split())) for i in range(n-1)]\n    for a, b in ab:\n        adj[a].append(b)\n        adj[b].append(a)\n    # deque\u3092\u4f7f\u3063\u305f\u30ad\u30e5\u30fc\u306b\u3088\u308bBFS\n    # \u5b50\u3092index\u3067\u3001\u89aa\u30ce\u30fc\u30c9\u3092\u8981\u7d20\u3067\n    # \u4eca\u56de\u306f\u5f69\u8272\u306e\u305f\u3081\u306b\u3069\u3093\u306a\u9806\u756a\u3067pop\u3055\u308c\u305f\u304b\u3082\u4fdd\u6301\u3057\u3066\u304a\u304f\n    order  = []\n    parent = [None] * (n+1)\n    q = deque([1])\n    while q:\n        par = q.popleft()\n        order.append(par)\n        for chl in adj[par]:\n            if chl == parent[par]:\n                continue\n            parent[chl] = par\n            q.append(chl)\n    # \u5f69\u8272\n    # \u89aa\u3068\u540c\u3058\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u82e5\u3044\u756a\u53f7\u3092\u5272\u308a\u5f53\u3066\u3066\u884c\u304f\n    cl = [None] * (n+1)\n    for par in order:\n        # \u89aa\u306e\u8272\n        pc = cl[par]\n        # \u5f69\u8272\u306f1\u4ee5\u4e0ak\u4ee5\u4e0b\n        color = 1\n        for chl in adj[par]:\n            # \u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u89aa\u306f\u7121\u8996\n            if chl == parent[par]:\n                continue\n            # \u89aa\u306e\u8272\u3068\u540c\u3058\u306a\u3089\u8272\u3092\u5909\u3048\u308b\n            if pc == color:\n                color += 1\n            # \u30ab\u30e9\u30fc\u30ea\u30b9\u30c8\u306b\u5b50index\u306bcolor\u3092\u5165\u308c\u308b\n            cl[chl] = color\n            #\u3000\u4ed6\u306e\u5b50\u306f\u8272\u3092\u5909\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\n            color += 1\n    # \u6728\u30b0\u30e9\u30d5\u306a\u306e\u3067\u5358\u7d14\u306b\u6b21\u6570\u6700\u5927\u3067\u8003\u3048\u3066\u554f\u984c\u306a\u3044\n    g = max([len(i) for i in adj]) \n    print(g)   \n    for a, b in ab:\n        # \u89aa\u5b50\u95a2\u4fc2\u304c\u9006\u8ee2\u3057\u306a\u3044\u51fa\u529b\u306a\u3089\u3053\u308c\u3067\u3044\u3044\u304c\u305d\u3046\u3068\u3082\u9650\u3089\u306a\u3044 \n        if parent[a] != b:\n            print(cl[b])\n        else:\n            print(cl[a])    \n    \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\nn=int(input())\nr=[[] for _ in range(n)]\nkumi=[]\nfor _ in range(n-1):\n  s=list(map(int,input().split()))\n  kumi.append(str(s[0]-1)+'+'+str(s[1]-1))\n  r[s[0]-1].append(s[1]-1)\n  r[s[1]-1].append(s[0]-1)\n  \n  \nans=0\nfor i in range(n):\n  ans=max(len(r[i]),ans)\n\nprint(ans)\n\nans_iro=[[] for _ in range(n)]\n\niro=[-1 for _ in range(n)]\niro[0]=1\nch=1\nd=[]\ndi={}\nfor i in r[0]:\n  iro[i]=ch\n  di[str(min(0,i))+'+'+str(max(0,i))]=ch\n  ch+=1\n  d.append(i)\n  \n  \n\nd=deque(d)\n\n\n\nwhile d:\n  v=d.popleft()\n  ch=1\n  for i in r[v]:\n    if iro[i]==-1:\n      if ch==iro[v]:\n        ch+=1\n        iro[i]=ch\n        di[str(min(v,i))+'+'+str(max(v,i))]=ch\n        ch+=1\n      else:\n        iro[i]=ch\n        di[str(min(v,i))+'+'+str(max(v,i))]=ch\n        ch+=1\n        \n      d.append(i)\n      \nfor g in kumi:\n  print((di[g]))\n      \n\n  \n\n\n", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nEdges = []\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n    Edges.append((a-1, b-1))\n\nCol = 0\nfor n in range(N):\n    Col = max(Col, len(graph[n]))\n\nColor = dict()\nchecked = [-1]*N\nq = [0]\nchecked[0] = Col+1\nwhile q:\n    qq = []\n    for p in q:\n        c = checked[p]\n        t = 0\n        for np in graph[p]:\n            if checked[np] == -1:\n                if t == c:\n                    t += 1\n                checked[np] = t\n                Color[(p, np)] = t\n                Color[(np, p)] = t\n                t += 1\n                qq.append(np)\n    q = qq\n\nprint(Col)\nfor a, b in Edges:\n    print(Color[(a, b)]+1)", "import sys\nsys.setrecursionlimit(10**8)\n\ndef dfs(v,c):\n  now = 1\n  for u,i in edge[v]:\n    if color[i]==0:\n      if now==c:\n        now += 1\n      color[i] = now \n      dfs(u,now)\n      now += 1\n  return 0\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = map(int, input().split())\n  edge[a-1].append([b-1,i])\n  edge[b-1].append([a-1,i])\ncolor = [0]*(N-1)\ndfs(0,1<<30)\nprint(max(color))\nprint(*color, sep='\\n')", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = [int(_) - 1 for _ in input().split()]\n    edge[a].append((b, i))\n    edge[b].append((a, i))\nans = [0] * (N - 1)\ncolors_num = max([len(_) for _ in edge])\ncolors = list(range(colors_num))\n\n\ndef dfs(v, pv, pc):\n    valid_colors = [c for c in colors if c != pc]\n    childs = [c for c in edge[v] if c[0] != pv]\n    for ((cv, ci), color) in zip(childs, valid_colors):\n        ans[ci] = color + 1\n        dfs(cv, v, color)\n\n\ndfs(0, -1, -1)\nprint(colors_num)\nprint((*ans))\n", "from sys import stdin\n\ndef getval():\n    n = int(input())\n    e = [[i] + list(map(int,stdin.readline().split())) for i in range(n-1)]\n    return n,e\n\ndef main(n,e):\n    tree = [[] for i in range(n)]\n    ans = [0 for i in range(n-1)]\n    for i in e:\n        tree[i[1]-1].append([i[2]-1,i[0]])\n    tree[0].append(0)\n    k = 1\n    q = [0]\n    while q:\n        n = 0\n        idx = q.pop(0)\n        for i in range(len(tree[idx])-1):\n            n += 1\n            if n==tree[idx][-1]:\n                n += 1\n            ans[tree[idx][i][-1]] = n\n            tree[tree[idx][i][0]].append(n)\n            q.append(tree[idx][i][0])\n        k = max(k,n)\n\n    print(k)\n    for i in ans:\n        print(i)\n            \n            \ndef __starting_point():\n    n,e = getval()\n    main(n,e)\n__starting_point()", "import sys\nsys.setrecursionlimit(10**5)\nn = int(input())\nab = [list(map(int,input().split()))for _ in range(n-1)]\n\ngraph = [[] for _ in range(n+1)]\nans = [0]*(n-1)\nfor i in range(n-1):\n    graph[ab[i][0]].append((ab[i][1],i))\n    graph[ab[i][1]].append((ab[i][0],i))\n\nvisit = [False]*(n+1)\ndef dfs(p,c):\n    color = 1\n    visit[p] = True\n    for n,i in graph[p]:\n        if visit[n] == False:\n            if color == c:\n                color += 1\n            ans[i] = color\n            dfs(n,color)\n            color += 1\n\ndfs(1,0)\nprint((max(ans)))\nfor t in ans:\n    print(t)\n", "n=int(input())\ne=[[] for i in range(n)]\nfor i in range(n-1):\n  inp=list(map(int,input().split()))\n  e[inp[0]-1].append((inp[1]-1,i))\n  e[inp[1]-1].append((inp[0]-1,i))\n\ncol=[0 for i in range(n-1)]\nfl=[0 for i in range(n)]\ns=[[0,0]]\nmc=0\nwhile len(s):\n  ns=[]\n  for i in s:\n    fl[i[0]]=1\n    cc=1\n    for j in e[i[0]]:\n      if not(fl[j[0]]):\n        if cc==i[1]:\n          cc+=1\n        col[j[1]]=cc\n        mc=max(mc,cc)\n        ns.append([j[0],cc])\n        cc+=1\n  s=ns\n\nprint(mc)\nfor i in col:\n  print(i)\n", "import sys\n\nsys.setrecursionlimit(100000)\n\ndef main():\n    n = int(input())\n    G = [[] for _ in range(n)]\n    ID = [dict() for _ in range(n)]\n    for i in range(n - 1):\n        a, b = map(lambda x: int(x) - 1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n        ID[a][b] = i\n        ID[b][a] = i\n    m = max(len(g) for g in G)\n    ans = [0] * (n - 1)\n    def bfs(a, pre = -1, pre_c = -1):\n        color = 1\n        for b in G[a]:\n            if b == pre: continue\n            if color == pre_c: color += 1\n            ans[ID[a][b]] = color\n            bfs(b, a, color)\n            color += 1\n\n    bfs(0)\n    print(m)\n    [print(a) for a in ans]\n      \ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\n\nip = []\nhen = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(lambda x: int(x)-1, input().split())\n    ip.append([a, b])\n    hen[a].append(b)\n\np = [-1]*N\n\nfor i in range(N):\n    x = 0\n    for j, h in enumerate(hen[i]):\n        if p[i] == j:\n            x += 1\n        p[h] = j+x\n\nprint(max(p)+1)\nfor i in range(N-1):\n    print(p[ip[i][1]]+1)", "from collections import deque\nn=int(input())\ntree=[[] for _ in range(n+1)]\nfor i in range(1,n):\n  a,b=map(int,input().split())\n  tree[a].append([b,i])\n  tree[b].append([a,i])\nqueue=deque([[1,0]])\nans=[0]*(n+1)\nans[1]=1\nvisited=[0]*(n+1)\n\nwhile queue:\n  v,c=queue.popleft()\n  color=1\n  for nv,i in tree[v]:\n    if c==color:\n      color+=1\n    if visited[i]==1:\n      continue\n    visited[i]=1\n    queue.append([nv,color])\n    ans[i]=color\n    color+=1\nprint(max(ans))\nfor i in range(1,n):\n  print(ans[i])", "def __starting_point():\n    import sys\n    from collections import deque\n    input = sys.stdin.readline\n    N = int(input())\n    edges = [[] for _ in range(N)]\n    for i in range(N-1):\n        a,b = map(int,input().split())\n        a -= 1\n        b -= 1\n        edges[a].append((b,i))\n        edges[b].append((a,i))\n\n    color = [None]*(N-1)\n    SIZE = 1\n    q = deque([(0,None)])\n    while q:\n        v, prev_color = q.popleft()\n        c = 1\n        for w, i in edges[v]:\n            if not color[i]:\n                if c == prev_color:\n                    c += 1\n                color[i] = c\n                c += 1\n                q.append((w,color[i]))\n        SIZE = max(SIZE, c-1)\n    print(SIZE)\n    for n in range(N-1):\n        print(color[n])\n__starting_point()", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[8]:\n\n\nimport sys\nsys.setrecursionlimit(10**9)\n\n\n# In[10]:\n\n\nn = int(input())\nab = []\nt = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = [int(x)-1 for x in input().split()]\n    t[a].append(b)\n    t[b].append(a)\n    ab.append((min(a,b),max(a,b)))\n\n\n# In[11]:\n\n\nk = max(list(map(len,t)))\nd = {}\ndef dfs(pre,cur,col):\n    cn = 1 if col != 1 else 2\n    for i in t[cur]:\n        if i == pre:\n            continue\n        d[(min(i,cur),max(i,cur))] = cn\n        dfs(cur,i,cn)\n        cn += 1\n        if col == cn:\n            cn += 1\ndfs(0,0,0)\nprint(k)\nfor i in ab:\n    print((d[i]))\n\n\n# In[ ]:\n\n\n\n\n", "f=lambda:map(int,input().split())\nn=int(input())\ng=[[] for _ in range(n)]\nfor i in range(n-1):\n  a,b=f()\n  g[a-1]+=[(b-1,i)]\n  g[b-1]+=[(a-1,i)]\nl=[0]*(n-1)\nu=[0]*n\nq=[(0,0)]\nwhile q:\n  v,s=q.pop()\n  u[v]=1\n  t=1\n  for c,i in g[v]:\n    if u[c]: continue\n    if t==s: t+=1\n    l[i]=t\n    q+=[(c,t)]\n    t+=1\nprint(max(l))\nfor i in l: print(i)", "from collections import deque, defaultdict\nN = int(input())\nab = [list(map(int, input().split())) for _ in range(N - 1)]\nd = [0] * (N + 1)\nG = [[] for _ in range(N + 1)]\nfor a, b in ab:\n    d[a] += 1\n    d[b] += 1\n    G[a].append(b)\n    G[b].append(a)\nprint((max(d)))\n\ncolor = defaultdict(int)\nq = deque([[1, 0]])\nseen = [0] * (N + 1)\nwhile q:\n    v, c = q.popleft()\n    seen[v] = 1\n    tem = 1\n    for u in G[v]:\n        if seen[u]:\n            continue\n        if tem == c:\n            tem += 1\n        q.append([u, tem])\n        i, j = min(v, u), max(v, u)\n        color[(i, j)] = tem\n        tem += 1\n\nfor a, b in ab:\n    i, j = min(a, b), max(a, b)\n    print((color[(i, j)]))\n", "\nfrom collections import deque\ndef resolve():\n    N = int(input())\n    G = [[] for _ in range(N)]\n    nextV = []\n\n    for _ in range(N - 1):\n        a, b = [int(x) - 1 for x in input().split()]\n        G[a].append(b)\n        nextV.append(b)\n\n    q = deque()\n    q.append(0)\n    color = [0] * N\n    while q:\n        v = q.popleft()\n        parentC = color[v]\n        c = 1\n        for to in G[v]:\n            if c == parentC:  # \u89aa\u3068\u540c\u3058\u8272\u3060\u3063\u305f\u3089\u6b21\u306e\u8272\u3092\u4f7f\u7528\n                c += 1\n            color[to] = c\n            c += 1\n            q.append(to)\n\n    print((max(color)))\n    for b in nextV:\n        print((color[b]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque,defaultdict\nn = int(input())\ndata = [[] for _ in range(n)]\nsides = []\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    a,b = a-1,b-1\n    data[a].append(b)\n    data[b].append(a)\n    sides.append((a,b))\nI = defaultdict(lambda:0)\ncs = [0]*n\nused = [0]*n\nq = deque([0])\nused[0]=1\nk = 0\nwhile q:\n    u = q.popleft()\n    if k < len(data[u]):\n        k = len(data[u])\n    cur = 1\n    for v in data[u]:\n        if used[v]:continue\n        if cur==cs[u]:cur+=1\n        cs[v] = cur\n        I[(u,v)] = cur\n        I[(v,u)] = cur\n        cur += 1\n        used[v] = 1\n        q.append(v)\nprint(k)\nfor i,j in sides:\n    print(I[(i,j)])", "N = int(input())\ninp = []\nfor k in range(N-1):\n  a, b = list(map(int, input().split()))\n  if a > b:\n    a, b = b-1, a-1\n  else:\n    a, b = a-1, b-1\n  inp.append((a, b, k))\ninp.sort(key = lambda x: x[0])\nmark = [[] for _ in range(N)]\ndef binary_search(list, item):\n    low = 0\n    high = len(list) - 1\n\n    while low <= high:\n        mid = (low + high) //2\n        guess = list[mid]\n        if guess == item:\n            #return mid\n            return True\n        if guess > item:\n            high = mid -1\n        else:\n            low = mid + 1\n\n    #return None\n    return False\n\nfrom bisect import insort\n\n\nans = [0 for _ in range(N-1)]\nnow = 0\ncnt = 0\nfor item in inp:\n  cnt += 1\n  if now < item[0]:\n    now = item[0]\n    cnt = 1\n  while binary_search(mark[item[0]], cnt) or binary_search(mark[item[1]], cnt):\n    cnt += 1\n  insort(mark[item[1]], cnt)\n  ans[item[2]] = cnt\ncolor = max(ans)\nprint(color)\nfor k in range(N-1):\n  print((ans[k]))\n", "import sys\nsys.setrecursionlimit(10**9)\n\nn=int(input())\nto=[[] for i in range(n)]\nedge={}\ncolor=[0]*(n-1)\nfor i in range(1,n):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  to[a].append(b)\n  to[b].append(a)\n  edge[(a,b)]=edge[(b,a)]=i\ndef dfs(n,b=-1,bc=-1):\n  to_n=to[n]\n  k=1\n  for i in range(len(to_n)):\n    if to_n[i]==b:\n      continue\n    if k==bc:\n      k+=1\n    color[edge[(n,to_n[i])]-1]=k\n    dfs(to_n[i],n,k)\n    k+=1\ndfs(0)\nprint(max(color))\nfor i in range(n-1):\n  print(color[i])", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef make_adjlist_nond(n, edges):\n    res = [[] for _ in range(n+1)]\n    for edge in edges:\n        res[edge[0]].append(edge[1])\n        res[edge[1]].append(edge[0])\n    return res\n\n\ndef main():\n    N = NI()\n    edges = [NLI() for _ in range(N-1)]\n    graph = [[] for _ in range(N+1)]\n    edge_dict = {}\n    for i, edge in enumerate(edges):\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n        edge_dict[(edge[0], edge[1])] = i+1\n\n    queue = deque()\n    queue.append(1)\n    seen = [0]*(N+1)\n    colors = [-1] * N\n    colors[1] = 1\n    now_colors = deque()\n    now_colors.append(-1)\n    while queue:\n        now = queue.popleft()\n        now_color = now_colors.popleft()\n        seen[now] = 1\n        nexts = graph[now]\n        color = 1\n        for goto in nexts:\n            if seen[goto] == 0:\n                a, b = min(now, goto), max(now, goto)\n                if color == now_color:\n                    color += 1\n                colors[edge_dict[(a, b)]] = color\n                queue.append(goto)\n                now_colors.append(color)\n                color += 1\n    print(max(colors))\n    for i in range(1, N):\n        print(colors[i])\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nn = int(input())\nedges_ls = [[0,0] for _ in range(n-1)]\nedges_d = {}\nver_ls = [[] for _ in range(n)]\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    edges_d[(a,b)] = i\n    edges_d[(b,a)] = i\n    edges_ls[i] = [a,b]\n    ver_ls[a].append(b)\n    ver_ls[b].append(a)\nn_color = 0\nfor ver in ver_ls:\n    n_color = max(n_color,len(ver))\ndef next_color(color):\n    return (color+1)%n_color\n\nedge_color = [0] * (n-1)\nq = deque()\ncolor_now = 0\nfor ver in ver_ls[0]:\n    q.append([0,ver,color_now])\n    edge_color[edges_d[(0,ver)]] = color_now\n    color_now = next_color(color_now)\ndone_ls = [0] * n\ndone_ls[0] = 1\n\nwhile q:\n    From, to, color_now = q.popleft()\n    # ver\u306fto\u304b\u3089\u306e\u884c\u5148\n    for ver in ver_ls[to]:\n        if not done_ls[ver]:\n            q.append([to,ver,next_color(color_now)])\n            edge_color[edges_d[(to,ver)]] = next_color(color_now)\n            color_now = next_color(color_now)\n    done_ls[to] = 1\n\nprint(n_color)\nfor color in edge_color:\n    print(color+1)", "N = int(input())\n\nans = [0] * (N-1)\nto = [[] for i in range(N-1)]\nused = [0] * N\n\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    to[a-1].append([b-1, i])\n\nfor i in range(N-1):\n    unable = used[i]\n    c = 1\n    for j, id in to[i]:\n        if c == unable:\n            c += 1\n        ans[id] = c\n        used[j] = c\n        c += 1\n\nprint(max(used))\nfor i in range(N-1):\n    print(ans[i])", "import sys\nfrom collections import defaultdict, deque\nint1 = lambda x: int(x) - 1\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(500000)\n\nN = int(readline())\n\ng = [[] for _ in range(N)]\ndeg = [0] * N\nab = defaultdict(int)\n\nfor _ in range(N - 1):\n    a, b = list(map(int1, readline().split()))\n    g[a].append(b)\n    g[b].append(a)\n    deg[a] += 1\n    deg[b] += 1\n    ab[(a, b)] = -1\n\ncolor = [-1] * N\n\nprint((max(deg)))\n\nC = [0] * N\nC[0] = -1\n\nque = deque([0])\n\nwhile len(que) != 0:\n    idx = que.popleft()\n    tmp = 1\n    for i in g[idx]:\n        if C[i] != 0:\n            continue\n        a, b = idx, i\n        if tmp == C[idx]:\n            tmp += 1\n        ab[(a, b)] = tmp\n        C[i] = tmp\n        que.append(i)\n        tmp += 1\n\nfor v in list(ab.values()):\n    print(v)\n", "from collections import deque\nn = int(input())\na = [[] for i in range(n)]\ne = []\nfor i in range(n-1):\n  b, c = map(int, input().split())\n  b -= 1\n  c -= 1\n  a[b].append(c)\n  e.append(c)\ncol = [0 for i in range(n)]\nv = deque([0])\n \nwhile v:\n  d = v.popleft()\n  k = 1\n  for i in a[d]:\n    if col[d] == k:\n      k += 1\n    col[i] = k\n    v.append(i)\n    k += 1\nprint (max(col))\nfor i in e:\n  print(col[i])", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**7)\nimport bisect\nimport heapq\nimport itertools\nimport math\nimport numpy as np\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom math import gcd\nfrom operator import add, itemgetter, mul, xor\ndef cmb(n,r,mod):\n  bunshi=1\n  bunbo=1\n  for i in range(r):\n    bunbo = bunbo*(i+1)%mod\n    bunshi = bunshi*(n-i)%mod\n  return (bunshi*pow(bunbo,mod-2,mod))%mod\nmod = 10**9+7\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return list(map(int,input().split()))\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\n\nn = I()\n\n#graph[i]\u306b\u306f\u9802\u70b9i\u3068\u7e4b\u304c\u3063\u3066\u3044\u308b\u9802\u70b9\u3092\u683c\u7d0d\u3059\u308b\ngraph = [[] for _ in range(n+1)]\nprev_col = [0]*(n+1)\na_b = []\nk=0\nfor i in range(n-1):\n    a,b = MI()\n    a_b.append(str(a)+\" \"+str(b))\n    graph[a].append(b)\n    graph[b].append(a)\n#check[i] == -1\u306a\u3089\u3070\u672a\u63a2\u7d22\ncheck = [-1]*(n+1)\ncheck[0] = 0\ncheck[1] = 0\nfor i in range(n+1):\n    k = max(len(graph[i]),k)\nd = deque()\nd.append(1)\nans = dict()\nwhile d:\n    v = d.popleft()\n    check[v] = 1\n    cnt = 0\n    for i in graph[v]:\n      if check[i] != -1:\n        continue\n      cnt = cnt+1\n      if prev_col[v] == cnt:\n        cnt = cnt + 1\n      prev_col[i] = cnt\n      ans[str(min(i,v))+\" \"+str(max(i,v))]=cnt\n      d.append(i)\nprint(k)\nfor key in a_b:\n    print((ans[key]))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n \nN = INT()\nab = [LIST() for _ in range(N-1)]\ngraph = [[] for _ in range(N)]\n\nfor a, b in ab:\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nlength = [len(x) for x in graph]\nans = max(length)\n\ncolor = defaultdict(int)\n\ndef coloring(n, previous, col): #\u9802\u70b9n\u306bprevious\u304b\u3089\u8272col\u3067\u8fbf\u3063\u3066\u304d\u305f\u3002\n\tcnt = 1\n\tfor x in graph[n]:\n\t\tif x == previous:\n\t\t\tcolor[(n, x)] = col\n\t\t\tcolor[(x, n)] = col #\u3084\u3063\u3066\u304d\u305f\u9802\u70b9\u3068\u306e\u9593\u306b\u304a\u3051\u308b\u8272\n\t\telse:\n\t\t\tif cnt == col:\n\t\t\t\tcnt += 1\n\t\t\tcolor[(x, n)] = cnt\n\t\t\tcolor[(n, x)] = cnt\n\t\t\tcoloring(x, n, cnt)\n\t\t\tcnt += 1\n\ncoloring(0, -1, 0)\n\nprint(ans)\nfor a, b in ab:\n\tprint(color[(a-1, b-1)])", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\n#from itertools import product, accumulate, combinations, product\n#import bisect\n#import numpy as np\n#from copy import deepcopy\n#from collections import deque\n#from decimal import Decimal\n#from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\n\ndef mapline(t = int):\n    return list(map(t, sysread().split()))\ndef mapread(t = int):\n    return list(map(t, read().split()))\n\ndef dfs(c, to, cols, max_counts, pre_col = 0):\n    colors = set()\n    colors.add(pre_col)\n    num = 1\n    for idx, n in to[c]:\n        if cols[idx]:continue\n        for i in range(num, max_counts+1):\n            if not i in colors:\n                num = i\n                cols[idx] = i\n                colors.add(i)\n                dfs(n, to, cols, max_counts, i)\n                break\n\n\ndef run():\n    N = int(sysread())\n    to = [[] for _ in range(N+1)]\n    cols = [0] * (N-1)\n    counts = [0 for i in range(N+1)]\n    for i in range(N-1):\n        a,b = mapline()\n        to[a].append((i, b))\n        to[b].append((i, a))\n        counts[a] += 1\n        counts[b] += 1\n\n    max_counts = max(counts)\n    print(max_counts)\n    dfs(1, to, cols, max_counts)\n\n    for c in cols:\n        print(c)\n\n    #print(a ^ b)\ndef __starting_point():\n    run()\n\n__starting_point()", "from collections import deque\ndef readinput():\n    n=int(input())\n    nList=[]\n    for _ in range(n+1):\n        nList.append([])\n    edges=[]\n    for _ in range(n-1):\n        a,b=list(map(int,input().split()))\n        edges.append((a,b))\n        nList[a].append(b)\n        nList[b].append(a)\n    return n,nList,edges\n\ndef bfs(s,nList):\n    #print(nList)\n    WHITE=0\n    GRAY=1\n    BLACK=2\n    status=[WHITE]*(n+1)\n    parent=[0]*(n+1)\n    color=[0]*(n+1)\n    maxcolor=0\n    Q=deque([])\n    Q.append(s)\n    while(len(Q)>0):\n        u=Q.popleft()\n        usedcolor=color[u]\n        col=1\n        for t in nList[u]:\n            if status[t]==WHITE:\n                status[t]=GRAY\n                parent[t]=u\n                if col==usedcolor:\n                    col+=1\n                color[t]=col\n                Q.append(t)\n                col+=1\n        maxcolor=max(maxcolor,col-1)\n        status[u]=BLACK\n        #print(u,usedcolor)\n    return color, maxcolor\n\n\ndef main(n,nList,edges):\n    color, maxcolor=bfs(1,nList)\n    print(maxcolor)\n    for a,b in edges:\n        print((color[b]))\n\ndef __starting_point():\n    n,nList,edges=readinput()\n    main(n,nList,edges)\n\n__starting_point()", "import sys\ninput=sys.stdin.buffer.readline\ninputs=sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**9)\n\nn=int(input())\ne=[[] for i in range(1+n)]\nei={}\nfor i in range(n-1):\n    \"\"\"#weighted->erase_,__,___=map(int,input().split())\n    e[_].append((__,___))\n    e[__].append((_,___))\n    \"\"\"\n    _,__=map(int,input().split())\n    e[_].append(__)\n    e[__].append(_)\n    ei[_,__]=i\n    ei[__,_]=i\n\n    \"\"\"\n\"\"\"#weighted->erase\nM=max([len(x)for x in e])\nres=[0]*(n-1)\nfrom collections import deque\ndq=deque([])\n#pop/append/(append,pop)_left/in/len/count/[]/index/rotate()(\u53f3\u3078n\u305a\u3089\u3059)\nMs=[1]*(1+n)\ndq.append(1)\nwhile dq:\n    now=dq.popleft()\n    for ne in e[now]:\n        ind=ei[ne,now]\n        if res[ind]==0:\n            res[ind]=Ms[now]\n            Ms[now]=Ms[now]%M+1\n            Ms[ne]=Ms[now]\n            dq.append(ne)\nprint(M)\nprint(*res,sep='\\n')", "from sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 6)\n\nN  = int(input())\nGb = [ [] for _ in range(N) ]\nGu = [ [] for _ in range(N) ]\nEs = {}\n\nfor n in range(N - 1):\n    a, b = map(lambda x: int(x) - 1, input().split())\n\n    Es[f'{a:06}{b:06}'] = None\n\n    Gb[a].append(b)\n    Gb[b].append(a)\n    Gu[a].append(b)\n\ncolors = list(range(max(map(len, Gb))))\n\ndef dfs(base_node, edge_color):\n    nonlocal Es\n\n    valid_colors = filter(lambda color: color != edge_color, colors)\n\n    for child_node, color in zip(Gu[base_node], valid_colors):\n        Es[f'{base_node:06}{child_node:06}'] = color + 1\n\n        dfs(child_node, color)\n\nprint(len(colors))\n\ndfs(0, None)\n\nfor color in Es.values():\n    print(color)", "import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nn = ni()\ng = [[] for i in range(n)]\n\nfor i in range(n-1):\n    a,b = na()\n    g[a-1].append((b-1,i))\n\nans = [-1]*(n-1)\nm = [0]*n\n\nfor i in range(n):\n    k = 1\n    for c,j in g[i]:\n        if m[i] == k: k += 1\n        m[c] = k\n        ans[j] = k\n        k+=1\n\nprint(max(m))\nprint('\\n'.join([str(u) for u in ans]))", "import sys\nfrom collections import deque\nN = int(input())\nE = [tuple(map(lambda x: int(x) - 1, sys.stdin.readline().split())) for _ in range(N - 1)]\nG = [[] for _ in range(N)]\nfor a, b in E:\n    G[a].append(b)\n\ncolornum = len(G[0])\ncolors = [{} for _ in range(N)]\ntodo = deque()\nfor i, p in enumerate(G[0]):\n    colors[0][p] = i\n    todo.append((0, p))\n\nwhile todo:\n    pp, p = todo.popleft()\n    colornum = max(colornum, len(G[p]) + 1)\n    c = colors[pp][p]\n    for np in G[p]:\n        c = (c + 1) % colornum\n        colors[p][np] = c\n        todo.append((p, np))\n\nprint(colornum)\nfor a, b in E:\n    print(colors[a][b] + 1)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n \nN = INT()\nab = [LIST() for _ in range(N-1)]\ngraph = [[] for _ in range(N)]\n\nfor a, b in ab:\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nlength = [len(x) for x in graph]\nans = max(length)\n\ncolor = defaultdict(int)\n\nq = deque([])\ncnt = 1\nfor x in graph[0]:\n\tq.append((x, 0, cnt))\n\tcnt += 1\n\nwhile q:\n\tn, previous, col = q.popleft()\n\tcnt = 1\n\tfor x in graph[n]:\n\t\tif x == previous:\n\t\t\tcolor[(n, x)] = col\n\t\t\tcolor[(x, n)] = col\n\t\telse:\n\t\t\tif cnt == col:\n\t\t\t\tcnt += 1\n\t\t\tcolor[(n, x)] = cnt\n\t\t\tcolor[(x, n)] = cnt\n\t\t\tq.append((x, n, cnt))\n\t\t\tcnt += 1\n\nprint(ans)\nfor a, b in ab:\n\tprint((color[(a-1, b-1)]))\n", "N = int(input())\nfrom collections import deque\ninp = []\nfor k in range(N-1):\n  a, b = map(int, input().split())\n  if a > b:\n    a, b = b-1, a-1\n  else:\n    a, b = a-1, b-1\n  inp.append((a, b, k))\ninp.sort(key = lambda x: x[0])\ninp = deque(inp)\nmark = [[] for _ in range(N)]\ndef binary_search(list, item):\n    low = 0\n    high = len(list) - 1\n    while low <= high:\n        mid = (low + high) //2\n        guess = list[mid]\n        if guess == item:\n            #return mid\n            return True\n        if guess > item:\n            high = mid -1\n        else:\n            low = mid + 1\n\n    #return None\n    return False\n\nfrom bisect import insort\nans = [0 for _ in range(N-1)]\nnow = 0\ncnt = 0\nwhile inp:\n  item = inp.popleft()\n  cnt += 1\n  if now < item[0]:\n    now = item[0]\n    cnt = 1\n  while binary_search(mark[item[0]], cnt) or binary_search(mark[item[1]], cnt):\n    cnt += 1\n  insort(mark[item[1]], cnt)\n  ans[item[2]] = cnt\ncolor = max(ans)\nprint(color)\nfor k in range(N-1):\n  print(ans[k])", "from collections import defaultdict\n\nN = int(input())\nP = [[] for _ in range(N)]\nAB = defaultdict(int)\n\nfor _ in range(N-1):\n  a, b = [int(x)-1 for x in input().split()]\n  P[a].append(b)\n  P[b].append(a)\n  AB[(a, b)] = -1\n\nC = [-1] * N\n\ndef bfs(s):\n    d = [-1] * N\n    d[s] = 0\n    p_old = [s]\n    K = -1\n    while p_old:\n      p_new = []\n      for i in p_old:\n        c = 1\n        for j in P[i]:\n          if d[j] != -1:\n            continue\n          if C[i] == c:\n            c += 1\n          d[j] = 0\n          p_new.append(j)\n          C[j] = c\n          AB[(i, j)] = c\n          K = max(K, c)\n          c += 1\n      p_old = p_new\n    return K\n\nprint((bfs(0)))\n\nfor x in list(AB.values()):\n  print(x)\n", "import sys\nsys.setrecursionlimit(10**9)\nn = int(input())\nab = []\nt = [[] for _ in range(n)]\nfor _ in range(n-1):\n  a,b = map(lambda x:int(x)-1,input().split())\n  t[a].append(b)\n  t[b].append(a)\n  ab.append((min(a,b),max(a,b)))\nk = max(map(len,t))\nd = {}\ndef dfs(pre,cur,col):\n  cn = 1 if col != 1 else 2\n  for i in t[cur]:\n    if i == pre:\n      continue\n    d[(min(i,cur),max(i,cur))] = cn\n    dfs(cur,i,cn)\n    cn += 1\n    if col == cn:\n      cn += 1\ndfs(0,0,0)\nprint(k)\nfor i in ab:\n  print(d[i])", "from collections import defaultdict, deque, Counter\n\nN = int(input())\n\ncounter = Counter()\nnodes = defaultdict(list)\nedges = []\n\nfor i in range(N - 1):\n    u, v = list(map(int, input().split(' ')))\n    nodes[u].append((v, i))\n    nodes[v].append((u, i))\n    edges.append((u, v))\n\nK = 0\nfor node in list(nodes.values()):\n    K = max(K, len(node))\n\nchecked = set()\nqueue = deque([(1, 0)])\nedge_colors = [0] * N\n\nwhile queue:\n    u, uc = queue.popleft()\n    checked.add(u)\n    color = 1\n    for v, e in nodes[u]:\n        if v in checked:\n            continue\n        if color == uc:\n            color += 1\n        edge_colors[e] = color\n        queue.append((v, color))\n        color += 1\n\nprint(K)\nfor i in range(N - 1):\n    print((edge_colors[i]))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n \nN = INT()\nab = [LIST() for _ in range(N-1)]\ngraph = [[] for _ in range(N)]\n\nfor a, b in ab:\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nlength = [len(x) for x in graph]\nans = max(length)\n\ncolor = defaultdict(int)\n\nq = deque([])\ncnt = 1\nfor x in graph[0]:\n\tq.append((x, 0, cnt))\n\tcnt += 1\n\nwhile q:\n\tn, previous, col = q.popleft()\n\tcnt = 1\n\tfor x in graph[n]:\n\t\tif x == previous:\n\t\t\tcolor[(n, x)] = col\n\t\t\tcolor[(x, n)] = col\n\t\telse:\n\t\t\tif cnt == col:\n\t\t\t\tcnt += 1\n\t\t\tcolor[(n, x)] = cnt\n\t\t\tcolor[(x, n)] = cnt\n\t\t\tq.append((x, n, cnt))\n\t\t\tcnt += 1\n\nprint(ans)\nfor a,b in ab:\n\tprint((color[(a-1, b-1)]))\n", "def main():\n    import sys\n    readline = sys.stdin.buffer.readline\n\n    from collections import deque\n\n    n = int(readline())\n    ab = [list(map(int, readline().split())) for _ in range(n-1)]\n\n    l = [[] for _ in range(n+1)]\n    for a, b in ab:\n        l[a].append(b)\n        l[b].append(a)\n\n    parents = [-1] * (n+1)\n    order = []\n    q = deque()\n    q.append(1)\n    while q:\n        c = q.pop()\n        order.append(c)\n        for i in l[c]:\n            if i == parents[c]:\n                continue\n            parents[i] = c\n            q.append(i)\n    \n    color = [-1] * (n+1)\n    for i in order:\n        ng = color[i]\n        c = 1\n        for j in l[i]:\n            if j == parents[i]:\n                continue\n            if c == ng:\n                c += 1\n            color[j] = c\n            c += 1\n    \n    ans = []\n    for a, b in ab:\n        if a == parents[b]:\n            ans.append(color[b])\n        else:\n            ans.append(color[a])\n\n    print(max(ans))\n    print('\\n'.join(list(map(str, ans))))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nn = int(input())\ng = [[] for _ in range(n)]\ne = []\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    e.append(b - 1)\n\nstack = deque([0])\nstack.append(0)\nans = [0 for _ in range(n)]\nwhile stack:\n    v = stack.popleft()\n    c = 1\n    for nv in g[v]:\n        if ans[v] == c:\n            c += 1\n        ans[nv] = c\n        c += 1\n        stack.append(nv)\n\nprint((max(ans)))\nfor i in e:\n    print((ans[i]))\n", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\nfrom collections import deque\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, ABs):\n    tree_top = [[] for _ in range(N + 1)]\n    for i in range(N - 1):\n        tree_top[ABs[i][0]].append(i)\n        tree_top[ABs[i][1]].append(i)\n\n    max_color = 0\n    for tt in tree_top:\n        max_color = max(max_color, len(tt))\n\n    ans = [0 for _ in range(N - 1)]\n    for tt in tree_top:\n        colored = []\n        for i in tt:\n            if ans[i] != 0:\n                colored.append(ans[i])\n        colored.sort()\n        now_color = 1\n        colored_point = 0\n        for i in tt:\n            if ans[i] != 0:\n                continue\n            if colored_point < len(colored) \\\n                    and now_color == colored[colored_point]:\n                now_color += 1\n                colored_point += 1\n            ans[i] = now_color\n            now_color += 1\n\n    print(max_color)\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    # S = input()\n    N = int(input())\n    # N, M = map(int, input().split())\n    # As = [int(i) for i in input().split()]\n    # Bs = [int(i) for i in input().split()]\n    ABs = [[int(i) for i in input().split()] for _ in range(N - 1)]\n    solve(N, ABs)\n\n__starting_point()", "#BFS\u3060\u3068\u304b\u3048\u3063\u3066\u8003\u3048\u306b\u304f\u3044\n#\u305d\u308c\u305e\u308c\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u5857\u3089\u308c\u3066\u306a\u3044\u8272\u3067\u5857\u308a\u5206\u3051\nn=int(input())\npaths=[[] for i in range(n)]\ncolors=[0]*(n-1)\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    paths[a-1].append(i)\n    paths[b-1].append(i)\nm=0\nfor i in range(n):\n    m=max(m,len(paths[i]))\nprint(m)\n#print(paths)\nfor i in range(n):\n    cand1,cand2=set(),[]\n    #print(paths[i])\n    for j in paths[i]:\n        if colors[j]!=0:\n            cand1.add(colors[j])\n        else:\n            cand2.append(j)\n    now=1\n    for j in cand2:\n        while now in cand1:\n            now+=1\n        colors[j]=now\n        now+=1\nfor i in range(n-1):\n    print(colors[i])", "import sys\nsys.setrecursionlimit(10**6)\nn=int(input())\ng=[[] for _ in range(n)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  g[a-1]+=[(b-1,i)]\n  g[b-1]+=[(a-1,i)]\nl=[0]*(n-1)\ndef dfs(v,p=-1,s=-1):\n  t=1\n  for c,i in g[v]:\n    if c==p: continue\n    if t==s: t+=1\n    l[i]=t\n    dfs(c,v,t)\n    t+=1\ndfs(0)\nprint(max(l))\nfor i in l: print(i)", "N = int(input())\nG = [[] for n in range(N)]\nvc = N*[0]\nec = (N-1)*[0]\nh = 1\n\nfor n in range(N-1):\n  a,b = map(int,input().split())\n  G[a-1].append((b-1,n))\n\nfor v,g in enumerate(G):\n  t = 1\n  for b,i in g:\n    if vc[v]==t:\n      t+=1\n    vc[b] = t\n    ec[i] = t\n    h = max(h,t)\n    t+=1\n\nprint(h)\nfor n in range(N-1):\n  print(ec[n])", "from collections import deque\nn=int(input())\ng=[[] for _ in range(n+1)]\ne=[]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    g[a-1].append(b-1)\n    e.append(b-1)\n \nq=deque([0])\n \ncolor=[0 for _ in range(n)]\nwhile(len(q)>0):\n    ei=q.popleft()\n    c=1\n    for x in g[ei]:\n        if c == color[ei]:\n            c+=1\n \n        color[x]=c\n        c+=1\n        q.append(x)\n \nprint(max(color))\nfor i in e:\n    print(color[i])", "N = int(input())\nl = [[] for i in range(N)]\nli = []\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  l[a-1].append(b-1)\n  li.append([a-1, b-1])\n  \nans = [-1] * N\n\nfor i in range(N):\n  x = 0\n  for j, h in enumerate(l[i]):\n    if ans[i] == j:\n      x += 1\n    ans[h] = j+x\n    \nprint(max(ans)+1)\nfor i in range(N-1):\n  print(ans[li[i][1]]+1)", "import sys\nsys.setrecursionlimit(10000000)\nN = int(input())\nab = [list(map(int, input().split())) for _ in range(N-1)]\n\npath = [list() for _ in range(N+1)]\nfor i in range(N-1):\n    a, b = ab[i][0], ab[i][1]\n    path[a].append([b, i])\n    path[b].append([a, i])\n\ncolor_max = 0\ncolor_list = [0]*(N-1)\nvisit = [False]*(N+1)\nvisit[1] = True\ndef dfs(node, color, used_path):\n    nonlocal visit\n    nxt_color = 0\n    for nxt in path[node]:\n        nxt_node = nxt[0]\n        use_path = nxt[1]\n        if visit[nxt_node] == False:\n            visit[nxt_node] = True\n            nxt_color += 1\n            if nxt_color == color:\n                nxt_color += 1\n            dfs(nxt_node, nxt_color, use_path)\n    \n    nonlocal color_list\n    if used_path != -1:\n        color_list[used_path] = color\n\ndfs(1, 0, -1)\n\n\nfor c in color_list:\n    color_max = max(c, color_max)\nprint(color_max)\nprint((\"\\n\".join(map(str, color_list))))\n", "from collections import deque\ndef readinput():\n    n=int(input())\n    nList=[]\n    for _ in range(n+1):\n        nList.append([])\n    edges=[]\n    for _ in range(n-1):\n        a,b=list(map(int,input().split()))\n        edges.append((a,b))\n        nList[a].append(b)\n        #nList[b].append(a)\n    return n,nList,edges\n\ndef bfs(s,nList):\n    #print(nList)\n    WHITE=0\n    GRAY=1\n    BLACK=2\n    status=[WHITE]*(n+1)\n    parent=[0]*(n+1)\n    color=[0]*(n+1)\n    maxcolor=0\n    Q=deque([])\n    Q.append(s)\n    while(len(Q)>0):\n        u=Q.popleft()\n        usedcolor=color[u]\n        col=1\n        for t in nList[u]:\n            if status[t]==WHITE:\n                status[t]=GRAY\n                parent[t]=u\n                if col==usedcolor:\n                    col+=1\n                color[t]=col\n                Q.append(t)\n                col+=1\n        maxcolor=max(maxcolor,col-1)\n        status[u]=BLACK\n        #print(u,usedcolor)\n    return color, maxcolor\n\n\ndef main(n,nList,edges):\n    color, maxcolor=bfs(1,nList)\n    print(maxcolor)\n    for a,b in edges:\n        print((color[b]))\n\ndef __starting_point():\n    n,nList,edges=readinput()\n    main(n,nList,edges)\n\n__starting_point()", "import collections\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    graph[a-1].append([b-1,i])\n    graph[b-1].append([a-1,i])\n\nq = collections.deque()\nans = [-1]*(N-1)\nq.append([0,-1])\nwhile len(q) != 0:\n    tmp = 1\n    v, v2 = q.popleft()\n    for w, i in graph[v]:\n        if ans[i] != -1:\n            continue\n        if ans[v2] == tmp:\n            tmp += 1\n        ans[i] = tmp\n        tmp += 1\n        q.append([w,i])\n\nprint(len(set(ans)))\nfor i in ans:\n    print(i)", "#!/usr/bin/env python3\nfrom collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(500000)\nINF = float(\"inf\")\nYES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"\ndy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]\ndy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]\n\n\ndef inside(y, x, H, W):\n    return 0 <= y < H and 0 <= x < W\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\ndef sum_of_arithmetic_progression(s, d, n):\n    return n * (2 * s + (n - 1) * d) // 2\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    g = gcd(a, b)\n    return a / g * b\n\n\ndef dfs(u, p, c, color, tree):\n    color[(u, p)] = c\n    color[(p, u)] = c\n\n    now = 0\n    for v in tree[u]:\n        if v == p:\n            continue\n        if now == c:\n            now += 1\n\n        dfs(v, u, now, color, tree)\n        now += 1\n\n\ndef solve():\n    N = int(input())\n\n    tree = [[] for _ in range(N)]\n    edges = []\n    for _ in range(N - 1):\n        A, B = list(map(int, input().split()))\n        A -= 1\n        B -= 1\n        tree[A].append(B)\n        tree[B].append(A)\n        edges.append((A, B))\n\n    color = dict()\n    dfs(0, -1, -1, color, tree)\n\n    print((max(color.values()) + 1))\n    for e in edges:\n        print((color[e] + 1))\n\n\ndef main():\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import setrecursionlimit\n\n\nsetrecursionlimit(10**6)\n\n\n\nn = int(input())\nt = [list(map(int, input().split())) for _ in range(n-1)]\n\n\n\nhands = [0 for _ in range(n+1)]\nfor a, b in t:\n    hands[a] += 1\n    hands[b] += 1\n\nnumber_of_colors = max(*hands)\n\ndef next_color(i):\n    return i+1 if i < number_of_colors else 1\n\n\n\nclass edge():\n    def __init__(self, en):\n        self.ends = en\n        self.color = 0\n\n    def set_color(self, co):\n        self.color = co\n\nclass nord():\n    def __init__(self, tr):\n        self.parent = tr\n        self.edges = []\n\n    def add(self, ed):\n        self.edges.append(ed)\n\n    def set_color(self, previous_color):\n        co = next_color(previous_color)\n        for ed in self.edges:\n            if ed.color == 0:\n                ed.set_color(co)\n                for i in ed.ends:\n                    no = self.parent.nords[i-1]\n                    if self is not no:\n                        no.set_color(co)\n                co = next_color(co)\n\nclass tree():\n    def __init__(self):\n        self.nords = []\n\n    def add_nord(self, no):\n        self.nords.append(no)\n\n    def add_edge(self, ed):\n        for i in ed.ends:\n            self.nords[i-1].add(ed)\n\n    def set_color(self):\n        self.nords[0].set_color(0)\n\n\ntr = tree()\nfor _ in range(n):\n    no = nord(tr)\n    tr.add_nord(no)\n\ne_tree = []\nfor en in t:\n    ed = edge(en)\n    e_tree.append(ed)\n    tr.add_edge(ed)\n\ntr.set_color()\n\nprint(number_of_colors)\nfor e in e_tree:\n    print(e.color)", "def main():\n\tN = int(input())\n\tvertex = [[] for i in range(N)]\n\n\tini_v = 0\n\tfor i in range(N - 1):\n\t\ta, b = [int(x) for x in input().split(\" \")]\n\t\tif i == 0:\n\t\t\tini_v = a - 1\n\t\tvertex[a - 1].append({\"v\": b - 1, \"e\": i})\n\t\tvertex[b - 1].append({\"v\": a - 1, \"e\": i})\n\n\tchecked_v = [0] * N\n\tchecked_e = [0] * (N - 1)\n\tto_visit = [ini_v]\n\tchecked_v[ini_v] = 1\n\tcolor_e = [-1] * (N - 1)\n\n\twhile len(to_visit):\n\t\tvisiting = to_visit.pop(0)\n\t\tvs = vertex[visiting]\n\t\tused_cs = []\n\t\tcless_e = []\n\t\tfor d in vs:\n\t\t\tif checked_v[d[\"v\"]] == 0:\n\t\t\t\tchecked_v[d[\"v\"]] = 1\n\t\t\t\tto_visit.append(d[\"v\"])\n\t\t\tif color_e[d[\"e\"]] == -1:\n\t\t\t\tcless_e.append(d[\"e\"])\n\t\t\telse:\n\t\t\t\tused_cs.append(color_e[d[\"e\"]])\n\t\ts = 0\n\t\tfor j in range(len(vs)):\n\t\t\tif s >= len(cless_e) or len(cless_e) == 0:\n\t\t\t\tbreak\n\t\t\telif j in used_cs:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tcolor_e[cless_e[s]] = j\n\t\t\t\ts += 1\n\n\tprint((max(color_e) + 1))\n\tfor i in range(len(color_e)):\n\t\tprint((color_e[i] + 1))\n\nmain()\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n \nN = INT()\nab = [LIST() for _ in range(N-1)]\ngraph = [[] for _ in range(N)]\n\nfor a, b in ab:\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nlength = [len(x) for x in graph]\nans = max(length)\n\ncolor = defaultdict(int)\n\nq = deque([])\ncnt = 1\nfor x in graph[0]:\n\tq.append((x, 0, cnt))\n\tcnt += 1\n\nwhile q:\n\tn, previous, col = q.popleft()\n\tcnt = 1\n\tfor x in graph[n]:\n\t\tif x == previous:\n\t\t\tcolor[(n, x)] = col\n\t\t\tcolor[(x, n)] = col\n\t\telse:\n\t\t\tif cnt == col:\n\t\t\t\tcnt += 1\n\t\t\tcolor[(n, x)] = cnt\n\t\t\tcolor[(x, n)] = cnt\n\t\t\tq.append((x, n, cnt))\n\t\t\tcnt += 1\n\nprint(ans)\nfor a, b in ab:\n\tprint(color[(a-1, b-1)])", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\nfrom collections import deque\ndef main():\n    n = ii()\n    edge = [[] for _ in range(n)]\n    ans = [0]*(n-1)\n    for i in range(n-1):\n        u, v = mi()\n        u -= 1\n        v -= 1\n        edge[u].append((v, i))\n        edge[v].append((u, i))\n    k = 0\n    q = deque([0])\n    visited = [False]*n\n    visited[0] = True\n    c = [0]*n\n    while q:\n        v = q.popleft()\n        cur = 1\n        k = max(k, len(edge[v]))\n        for nv, idx in edge[v]:\n            if visited[nv]:\n                continue\n            if cur == c[v]:\n                cur += 1\n            visited[nv] = True\n            c[nv] = cur\n            ans[idx] = cur\n            cur += 1\n            q.append(nv)\n    print(k)\n    print(*ans, sep='\\n')\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n \nN = INT()\nab = [LIST() for _ in range(N-1)]\ngraph = [[] for _ in range(N)]\n\nfor a, b in ab:\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\n\nlength = [len(x) for x in graph]\nans = max(length)\n\ncolor = defaultdict(int)\n\nq = deque([])\ncnt = 1\nfor x in graph[0]:\n\tq.append((x, 0, cnt))\n\tcnt += 1\n\nwhile q:\n\tn, previous, col = q.pop()\n\tcnt = 1\n\tfor x in graph[n]:\n\t\tif x == previous:\n\t\t\tcolor[(n, x)] = col\n\t\t\tcolor[(x, n)] = col\n\t\telse:\n\t\t\tif cnt == col:\n\t\t\t\tcnt += 1\n\t\t\tcolor[(n, x)] = cnt\n\t\t\tcolor[(x, n)] = cnt\n\t\t\tq.append((x, n, cnt))\n\t\t\tcnt += 1\n\nprint(ans)\nfor a, b in ab:\n\tprint((color[(a-1, b-1)]))\n", "from collections import deque\n\nN=int(input())\nG=[{} for i in range(N+1)]\ncolors = []\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  G[a][b]=[i,-1]\n  G[b][a]=[i,-1]\n\ndef bfs(s):\n  seen = [0 for i in range(N+1)]\n  prev = [0 for i in range(N+1)]\n  todo = deque([])\n  cmax = 0\n  now = s\n  seen[now]=1\n  todo.append(now)\n  while 1:\n    if len(todo)==0:break\n    a = todo.popleft()\n    if len(G[a])<50:\n      if prev[a] == 0:\n        a_color=set([])\n      else:\n        a_color=set([G[a][prev[a]][1]])\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          prev[b] = a\n          for c in range(1,N+1):\n            if c not in a_color:\n              a_color.add(c)\n              colors.append((G[a][b][0],c))\n              G[a][b][1]=G[b][a][1]=c\n              if c > cmax: cmax = c\n              break\n    else:\n      temp = list(range(1,N))\n      if prev[a] != 0:\n        del temp[G[a][prev[a]][1]-1]\n      temp = deque(temp)\n      for i,b in enumerate(G[a]):\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          prev[b] = a\n          c = temp.popleft()\n          colors.append((G[a][b][0],c))\n          G[a][b][1]=G[b][a][1]=c\n          if c > cmax: cmax = c\n            \n  return colors, cmax\n\ncolors,cmax = bfs(1)\ncolors=sorted(colors)\n\nprint(cmax)\nfor i in range(N-1):\n  print(colors[i][1])", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tD_fix\n# CreatedDate:  2020-09-15 21:36:31 +0900\n# LastModified: 2020-09-15 22:19:28 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\nfrom collections import deque\n\n\nclass BFS():\n    def __init__(self, path, N):\n        self.N = N\n        self.color_path = [-1]*self.N\n        self.path = path\n        self.init = 1\n        self.Q = deque([[0, self.init]])\n\n    def forward(self):\n        while self.Q:\n            prev_path, u = self.Q.popleft()\n            p_cnt = 1\n            for cp, v in self.path[u]:\n                if self.color_path[cp] == -1:\n                    if prev_path == p_cnt:\n                        p_cnt += 1\n                    self.Q.append([p_cnt, v])\n                    self.color_path[cp] = p_cnt\n                    p_cnt += 1\n#            print(self.color_path)\n\n    def print_ans(self):\n        self.color_path.pop(0)\n        print((max(self.color_path)))\n        for cp in self.color_path:\n            print(cp)\n\n\ndef main():\n    N = int(input())\n    path = [[] for _ in range(N+1)]\n    for i in range(1, N):\n        a, b = list(map(int, input().split()))\n        path[a].append([i, b])\n        path[b].append([i, a])\n    bfs = BFS(path, N)\n    bfs.forward()\n    bfs.print_ans()\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys \nfrom collections import deque,defaultdict\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nN = int(readline())\ngraph = [[] for _ in range(N+1)]\nAB = []\nfor i in range(N-1):\n    a,b = map(int,readline().split())\n    AB.append((a,b))\n    graph[a].append(b)\n    graph[b].append(a)\n    \ndist = [-1] * (N+1)\ndist[1] = 0\nCOL = defaultdict()\nq = deque([(1,0)])\nmax_col = 0\n\ndef bfs(max_col):\n    while q:\n        x,pre_col = q.popleft()\n        c = 1\n        for nx in graph[x]:\n            if dist[nx] != -1:\n                continue\n            if c == pre_col:\n                c += 1\n            COL[(x,nx)] = c\n            dist[nx] = 1\n            q.append((nx,c))\n            max_col = max(max_col,c)\n            c += 1\n    return max_col  \n\nmax_col = bfs(max_col)\nprint(max_col)\nfor a,b in AB:\n    if (a,b) in COL:\n        print(COL[(a,b)])\n    else:\n        print(COL[(b,a)])", "from collections import deque\n\nN = int(input())\nE = []\nG = {i:set() for i in range(1, N+1)}\nc = [-1 for i in range(N-1)]\nfor i in range(N-1):\n  a, b = list(map(int, input().split()))\n  E.append({a,b})\n  G[a].add(i)\n  G[b].add(i)\nQ = deque([0])\nc[0] = 1\nwhile Q:\n  i = Q.popleft()\n  a, b = E[i]\n  n = len(G[a])\n  color = 0\n  count = 0\n  for ni in G[a]:\n    if c[ni]==-1:\n      c[ni] = color+1\n      if c[ni] >= c[i]:\n        c[ni] += 1\n      color += 1\n      Q.append(ni)\n    else:\n      count += 1\n      if count > 1:\n        break\n  n = len(G[b])\n  color = 0\n  count = 0\n  for ni in G[b]:\n    if c[ni]==-1:\n      c[ni] = color+1\n      if c[ni] >= c[i]:\n        c[ni] += 1\n      color += 1\n      Q.append(ni)\n    else:\n      count += 1\n      if count > 1:\n        break\nprint((max(c)))\nfor i in c:\n  print(i)\n      \n", "import sys\nimport heapq\nimport math\nimport fractions\nimport bisect\nimport itertools\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\ndef input(): return sys.stdin.readline().strip()\ndef mp(): return list(map(int,input().split()))\ndef lmp(): return list(map(int,input().split()))\n\n\nn=int(input())\nedge=[[] for i in range(n+1)]\npar=[0]*(n+1)#i\u756a\u76ee\u306e\u9802\u70b9\u3068\u305d\u306e\u89aa\u3092\u7d50\u3076\u8fba\u306e\u8272\npar[1]=-1\ncol=[0]*(n-1)#i\u756a\u76ee\u306e\u8fba\u306e\u8272\nfor i in range(n-1):\n    a,b=mp()\n    edge[a].append([a,b,i])\n    edge[b].append([b,a,i])\n\n\nque=deque([edge[1]])\nwhile len(que):\n    k=1\n    q=que.popleft()\n    for x,y,i in q:\n        if col[i]==0:\n            if k==par[x]:\n                k+=1\n            col[i]=k\n            par[y]=k\n            k+=1\n            que.append(edge[y])\nprint((max(col)))\nfor i in range(n-1):\n    print((col[i]))\n\n    \n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\nclass Graph():\n    def __init__(self, v):\n        from heapq import heappop, heappush\n        self.v = v\n        self.graph = [[] for _ in range(v)]\n        self.INF = 10 ** 9\n    \n    def addEdge(self, start, end, itr):\n        self.graph[start].append((end, itr))\n        self.graph[end].append((start, itr))\n    \n    def BFS(self, start):\n        from collections import deque\n        dist = [-1] * self.v\n        ret = [0] * (self.v-1)\n        que = deque()\n        que.append((start, -1))\n        dist[start] = 0\n        while que:\n            now, _color = que.popleft()\n            color = 1\n            if _color == color: color += 1\n            for to, itr in self.graph[now]:\n                if dist[to] == -1:\n                    que.append((to, color))\n                    dist[to] = dist[now] + 1\n                    ret[itr] = color\n                    color += 1\n                    if color == _color: color += 1\n        return ret\n    \n    def color_types(self):\n        ret = len(self.graph[0])\n        for x in self.graph[1:]:\n            ret = max(ret, len(x))\n        return ret\n\ndef Main():\n    n = read_int()\n    g = Graph(n)\n    for i in range(n - 1):\n        a, b = read_ints()\n        g.addEdge(~-a, ~-b, i)\n    print(g.color_types())\n    print(*g.BFS(0), sep='\\n')\n\ndef __starting_point():\n    Main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nn = int(input())\nedge = [[] for _ in [0]*n]\nfor i in range(~-n):\n    a, b = map(int, input().split())\n    a -= 1;b -= 1\n    edge[a] += [[b, i]]\nans = [0] * ~-n\n\ndef dfs(now, color):\n    count = 1\n    for to, i in edge[now]:\n        # \u89aa\u306e\u8272\u3068\u540c\u3058\u3068\u304d\n        if count == color:\n            count += 1\n        ans[i] = count\n        dfs(to, count)\n        count += 1\n\n# \u958b\u59cb\u6839\u306f0\u756a\u76ee\u306b\ndfs(0, 0)\n\nprint(max(ans))\nfor p in ans:\n    print(p)", "from collections import defaultdict\nN = int(input())\nedge = []\nrelation = defaultdict(set)\nfor i in range(N - 1):\n    a, b = map(lambda x: x - 1, map(int, input().split()))\n    edge.append((a,b))\n    relation[a].add(b)\n    relation[b].add(a)\n\nprint(max(map(lambda x: len(relation[x]), relation)))\nanswer = {}\nqueue = []\nqueue.append((0, 0)) # (node_id, color_id)\nalready = set()\ncounter = 0\nalready.add(0)\nwhile counter < len(queue):\n    node, color = queue[counter]\n    c = 1 if color != 1 else 2\n    for n in relation[node]:\n        if n not in already:\n            queue.append((n, c))\n            already.add(n)\n            answer[(node, n)] = c\n            c += 1\n            if c == color:\n                c += 1\n    counter += 1\nfor e in edge:\n    print(answer[e])", "n = int(input())\na = [set() for i in range(n)]\ne = []\nfor i in range(n-1):\n  b, c = map(int, input().split())\n  b -= 1\n  c -= 1\n  a[b].add(c)\n  a[c].add(b)\n  e.append(c)\n\ncol = [0 for i in range(n)]\nvisited = [False for i in range(n)]\nvisited[0] = True\nv = [0]\n\nwhile v:\n  d = v.pop(0)\n  k = 1\n  for i in a[d]:\n    if visited[i] == False:\n      if col[d] == k:\n        k += 1\n      col[i] = k\n      visited[i] = True\n      v.append(i)\n      k += 1\n\nprint (max(col))\nfor i in e:\n  print (col[i])", "import sys\nsys.setrecursionlimit(10010010)\n\ndef abc146_d():\n    n = int(input())\n    Q = [tuple(map(lambda x: int(x)-1, input().split())) for _ in range(n-1)]\n\n    deg = [0] * n\n    adj = [[] for _ in range(n)]\n    color = dict()\n\n    for a, b in Q:\n        deg[a] += 1\n        deg[b] += 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(s, p):\n        nouse = -1\n        if p > -1: nouse = color[(min(s, p), max(s, p))]\n        c = 1\n        for t in adj[s]:\n            if t == p: continue\n            if c == nouse: c += 1\n            color[(min(s, t), max(s, t))] = c\n            dfs(t, s)\n            c += 1\n\n    dfs(1, -1)\n\n    print(max(deg))\n    for a, b in Q:\n        print(color[(a, b)])\n\ndef __starting_point():\n    abc146_d()\n__starting_point()", "from collections import deque\nn = int(input())\ntree = [[] for i in range(n+1)]\nedge = []\nfor _ in range(n-1):\n  a,b = map(int,input().split())\n  tree[a].append(b)\n  tree[b].append(a)\n  edge.append((a,b))\nm = len(max(tree,key=len))\ncol = [0]*(n+1)\ncol[1]='a'\nQ = deque([1])\n#print(tree)\nans = {}\nwhile Q:\n  temp = Q.popleft()\n  now = 1\n  for n in tree[temp]:\n    if col[n]:\n      continue\n    if now == col[temp]:\n      now += 1\n    col[n] = now\n    ans[min(temp,n),max(temp,n)] = now\n    now += 1\n    Q.append(n)\n    \nprint(m)\nfor a,b in edge:\n  print(ans[(a,b)])", "import sys\nsys.setrecursionlimit(10**8)\n\ndef dfs(x, last=-1, ban_color=-1):\n    \"\"\"\n    x: \u4eca\u3044\u308b\u9802\u70b9\n    last: \u65e2\u306b\u63a2\u7d22\u6e08\u306e\u9802\u70b9(\u7121\u9650\u30eb\u30fc\u30d7\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u521d\u671f\u5024-1)\n    ban_color: \u65e2\u306b\u63a2\u7d22\u6e08\u306e\u9802\u70b9(last)\u3068\u4eca\u3044\u308b\u9802\u70b9(x)\u3068\u306e\u8fba\u306b\u5857\u3089\u308c\u3066\u3044\u308b\u8272(\u2192\u4f7f\u3063\u3061\u3083\u3044\u3051\u306a\u3044\u8272)\n    \"\"\"\n    color = 1\n    for to in vertex[x]:  #\u4eca\u3044\u308b\u9802\u70b9\u306b\u96a3\u63a5\u3059\u308b\u9802\u70b9(\u3064\u307e\u308a\u4eca\u3044\u308b\u9802\u70b9\u304b\u3089\u51fa\u3066\u308b\u8fba\u3092\u3059\u3079\u3066\u8210\u3081\u308b),(root\u304b\u3089\u96a3\u63a5\u3059\u308b\u9802\u70b9\u306b\u5bfe\u3057\u3066\u306eroop\u3068\u3082\u6349\u3048\u3089\u308c\u308b)\n        if to == last: continue  # \u65e2\u306b\u63a2\u7d22\u6e08\u306e\u8fba\u306f\u3082\u3046\u8272\u304c\u5857\u3089\u308c\u3066\u3044\u308b\u304b\u3089\u30b9\u30ad\u30c3\u30d7\n        if color == ban_color: color += 1\n        color_dic[(x, to)] = color  # \u8fba\u306e\u8272\u3092\u306c\u308b\n        dfs(to, x, color)\n        color += 1\n        \n        \n\nn = int(input())\nvertex = {i: [] for i in range(n)} # \u96a3\u63a5\u9802\u70b9\u3092\u4fdd\u6301\na = [0] * (n - 1)  #i\u756a\u76ee\u306e\u8fba\u3092\u4fdd\u6301\nb = [0] * (n - 1)  #i\u756a\u76ee\u306e\u8fba\u3092\u4fdd\u6301\ncolor_dic = {} # \u8fba\u306e\u8272\u3092\u4fdd\u6301\n\n\nfor i in range(n-1): # \u96a3\u63a5\u9802\u70b9\u306e\u8f9e\u66f8\u3092\u4f5c\u6210\n    a[i], b[i] = list(map(int, input().split()))\n    a[i] -= 1\n    b[i] -= 1\n    vertex[a[i]].append(b[i])\n    vertex[b[i]].append(a[i])\n\nmax_v = 0\n\nfor _, v in list(vertex.items()):\n    if len(v) > max_v:\n        max_v = len(v)\nprint(max_v)\n    \n\n\ndfs(0)\n\nfor i in range(n - 1):\n    if (a[i], b[i]) in color_dic:\n        print((color_dic[(a[i], b[i])]))\n    else:\n        print((color_dic[(b[i], a[i])]))\n        \n\n\n\n    \n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(200_000)\n\ndef solve(N: int, a: \"List[int]\", b: \"List[int]\"):\n    from itertools import count\n    edges = [[] for _ in range(N)]\n    for i, (aa, bb) in enumerate(zip(a, b)):\n        edges[aa-1].append((bb-1, i))\n        edges[bb-1].append((aa-1, i))\n    ans = [None] * (N-1)\n    visited = set()\n    def dfs(n, c):\n        if n in visited:\n            return\n        visited.add(n)\n        for (nn, i), cc in zip(filter(lambda x: x[0] not in visited, edges[n]),\n                          filter(lambda y: y != c, count(1))):\n            ans[i] = cc\n            dfs(nn, cc)\n    dfs(0, None)\n    return [max(ans)] + ans\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    a = [int()] * (N - 1)  # type: \"List[int]\"\n    b = [int()] * (N - 1)  # type: \"List[int]\"\n    for i in range(N - 1):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n    print(*solve(N, a, b), sep=\"\\n\")\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = [int(_) - 1 for _ in input().split()]\n    edge[a].append((b, i))\n    edge[b].append((a, i))\nans = [0] * (N - 1)\ncolors_num = max([len(_) for _ in edge])\ncolors = list(range(colors_num))\n\n\ndef dfs(v, pv, pc):\n    valid_colors = [c for c in colors if c != pc]\n    childs = list([c for c in edge[v] if c[0] != pv])\n    for ((cv, ci), color) in zip(childs, valid_colors):\n        ans[ci] = color + 1\n        dfs(cv, v, color)\n\n\ndfs(0, -1, -1)\nprint(colors_num)\nprint((*ans))\n", "import sys\nfrom collections import defaultdict, deque\nint1 = lambda x: int(x) - 1\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(500000)\n\nN = int(readline())\n\ng = [[] for _ in range(N)]\ndeg = [0] * N\nab = defaultdict(int)\n\nfor _ in range(N - 1):\n    a, b = list(map(int1, readline().split()))\n    g[a].append(b)\n    g[b].append(a)\n    deg[a] += 1\n    deg[b] += 1\n    ab[(a, b)] = -1\n\ncolor = [-1] * N\n\nprint((max(deg)))\n\nC = [0] * N\nC[0] = -1\n\nque = deque([0])\n\nwhile len(que) != 0:\n    idx = que.popleft()\n    tmp = 1\n    for i in g[idx]:\n        if C[i] != 0:\n            continue\n        a, b = idx, i\n        if tmp == C[idx]:\n            tmp += 1\n        ab[(a, b)] = tmp\n        C[i] = tmp\n        que.append(i)\n        tmp += 1\n\nfor v in list(ab.values()):\n    print(v)\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\n\nG = [[] for i in range(N)]\nfrom collections import defaultdict\nE = defaultdict(int)\n\nfor i in range(N - 1):\n  a,b = map(int,readline().split())\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n  E[(a - 1, b - 1)] = i\n\nfrom collections import deque\nq = deque([])\nans = [None] * (N - 1)\n\nq.append([0, -1, 0])\nmaxcol = 0\nwhile q:\n  v, parent, color = q.popleft()\n  if color > maxcol:\n    maxcol = color\n  if (v, parent) in E:\n    ans[E[(v, parent)]] = color\n  elif (parent, v) in E:\n    ans[E[(parent, v)]] = color\n  next_col = 0\n  for child in G[v]:\n    if child == parent:\n      continue\n    next_col += 1\n    if next_col == color:\n      next_col += 1\n    q.append([child, v, next_col])\n    \nprint(maxcol)\nfor a in ans:\n  print(a)", "from collections import deque\n\nn = int(input())\nab = [list(map(int, input().split())) for _ in range(n-1)]\n\nl = [[] for _ in range(n+1)]\nfor a, b in ab:\n    l[a].append(b)\n    l[b].append(a)\n\nparents = [-1] * (n+1)\norder = []\nq = deque()\nq.append(1)\nwhile q:\n    c = q.pop()\n    order.append(c)\n    for i in l[c]:\n        if i == parents[c]:\n            continue\n        parents[i] = c\n        q.append(i)\n\ncolor = [-1] * (n+1)\nfor i in order:\n    ng = color[i]\n    c = 1\n    for j in l[i]:\n        if j == parents[i]:\n            continue\n        if c == ng:\n            c += 1\n        color[j] = c\n        c += 1\n\nans = []\nfor a, b in ab:\n    if a == parents[b]:\n        ans.append(color[b])\n    else:\n        ans.append(color[a])\n\nprint((max(ans)))\nprint(('\\n'.join(list(map(str, ans)))))\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\ndef main():\n    N = int(input())\n    Node = [set() for _ in range(N)]\n    Edge = {}\n    for i in range(N-1):\n        a , b = list(map(int, input().split()))\n        a-=1\n        b-=1\n        if b<a:\n            a, b = b, a\n        Edge[(a, b)]=i\n        Node[a].add(b)\n        Node[b].add(a)\n\n    K = 0\n    for i, x in enumerate(Node):\n        if len(x)>K:\n            K = len(x)\n            top = i\n\n\n    q = deque()\n    seen = [False]*(N-1)\n    used = [set() for _ in range(N)]\n    q.append(top)\n    while len(q)>0:\n        cur = q.popleft()\n        col = 1\n        for i in Node[cur]:\n            if cur>i:\n                ed = (i, cur)\n            else:\n                ed = (cur, i)\n            if seen[Edge[ed]]==False:\n                while col in used[cur] or col in used[i]:\n                    col+=1\n                seen[Edge[ed]] = col\n                used[cur].add(col)\n                used[i].add(col)\n                q.append(i)\n\n    print(K)\n    print(('\\n'.join(map(str, seen))))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n \nN = int(readline())\nm = map(int,read().split())\nAB = list(zip(m,m))\n\ngraph = [[] for _ in range(N+1)]\nfor a, b in AB:\n  graph[a].append(b)\n  graph[b].append(a)\n  \nroot = 1\nparent = [0]*(N+1)\norder = []\nstack = [root]\nwhile stack:\n  x = stack.pop()\n  order.append(x)\n  for y in graph[x]:\n    if y == parent[x]:\n      continue\n    parent[y] = x\n    stack.append(y)\ncolor = [-1]*(N+1)\nfor x in order:\n  ng = color[x]\n  c = 1\n  for y in graph[x]:\n    if y == parent[x]:\n      continue\n    if c == ng:\n      c += 1\n    color[y] = c\n    c += 1\n    \nanswer = []\nfor a, b in AB:\n  if parent[a] == b:\n    answer.append(color[a])\n  else:\n    answer.append(color[b])\nK =max(answer)\n\nprint(K)\nprint('\\n'.join(map(str, answer)))", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = LI_()\n        G[a].append((b, i))\n        G[b].append((a, i))\n\n    ans = [0] * (N - 1)\n    visited = [False] * N\n\n    def dfs(c, color_p):\n        visited[c] = True\n        color = 0\n        for n, i in G[c]:\n            if not visited[n]:\n                if color == color_p:\n                    color += 1\n                ans[i] = color\n                dfs(n, color)\n                color += 1\n\n    dfs(0, -1)\n\n    print((max(ans) + 1))\n    for i in ans:\n        print((i + 1))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\ndef readinput():\n    n=int(input())\n    nList=[]\n    for _ in range(n+1):\n        nList.append([])\n    edges=[]\n    for _ in range(n-1):\n        a,b=list(map(int,input().split()))\n        edges.append((a,b))\n        nList[a].append(b)\n        nList[b].append(a)\n    return n,nList,edges\n\ndef bfs(s,nList):\n    #print(nList)\n    WHITE=0\n    GRAY=1\n    BLACK=2\n    status=[WHITE]*(n+1)\n    parent=[0]*(n+1)\n    color=[0]*(n+1)\n    maxcolor=0\n    Q=deque([])\n    Q.append(s)\n    while(len(Q)>0):\n        u=Q.popleft()\n        usedcolor=color[u]\n        col=1\n        for t in nList[u]:\n            if status[t]==WHITE:\n                status[t]=GRAY\n                parent[t]=u\n                if col==usedcolor:\n                    col+=1\n                color[t]=col\n                Q.append(t)\n                col+=1\n                maxcolor=max(maxcolor,col-1)\n        status[u]=BLACK\n        #print(u,usedcolor)\n    return color, maxcolor\n\n\ndef main(n,nList,edges):\n    color, maxcolor=bfs(1,nList)\n    print(maxcolor)\n    for a,b in edges:\n        print((color[b]))\n\ndef __starting_point():\n    n,nList,edges=readinput()\n    main(n,nList,edges)\n\n__starting_point()", "N=int(input())\nl=[[] for i in range(N)]\ncolor=[0]*N\nmem=[]\nfor i in range(N-1):\n   a,b=list(map(int,input().split()))\n   a-=1;b-=1\n   l[a].append(b)\n   mem.append(b)\nfrom collections import deque\nque=deque([0])\nwhile que:\n   node=que.popleft()\n   c=1\n   for i in l[node]:\n      if color[node]==c:\n         c+=1\n      color[i]=c\n      c+=1\n      que.append(i)\nprint(max(color))\nfor i in mem:\n   print(color[i])", "from collections import deque\n\nN = int(input())\n# mtx = np.zeros([N, N], dtype=np.int32)\ntree = [[] for i in range(N)]\n\nkey_order = [0] * (N-1)\nfor i in range(N-1):\n    in1, in2 = map(int, input().split())\n    in1 -= 1\n    in2 -= 1\n    tree[in1].append(in2)\n    tree[in2].append(in1)\n\n    key_order[i] = (in1, in2)\n\n# [print(i, t) for i, t in enumerate(tree)]\n\n\ndef bfs(tree, p):\n    seen = [False] * len(tree)\n    queue = deque((p,))\n\n    edge_colors = dict()\n    node_colors = [0] * len(tree)\n    while len(queue) > 0:\n        q = queue.popleft()\n        seen[q] = True\n\n        parent_color = node_colors[q]\n\n        cnt = 1\n        for v in tree[q]:\n            if not seen[v]:\n                if cnt == parent_color:\n                    cnt += 1\n\n                edge_colors[(q, v)] = cnt\n                node_colors[v] = cnt\n                queue.append(v)\n                cnt += 1\n\n\n\n    \"\"\"\n    node_colors = [set() for _ in tree]\n    edge_colors = dict()\n    all_colors = set()\n    color = 0\n\n    while len(queue) > 0:\n        q = queue.popleft()\n        seen[q] = True\n\n        for v in tree[q]:\n            if not seen[v]:\n                residual = all_colors - node_colors[q]\n                if len(residual) > 0:\n                    this_color = residual.pop()\n                else:\n                    color += 1\n                    this_color = color\n                edge_colors[(q, v)] = this_color\n                node_colors[q].add(this_color)\n                node_colors[v].add(this_color)\n                all_colors.add(this_color)\n\n                queue.append(v)\n    \"\"\"\n\n    return edge_colors\n\n\nedge_colors = bfs(tree, 0)\n\nprint(max([c for key, c in edge_colors.items()]))\n[print(edge_colors[t]) for t in key_order]\n# print(edge_colors)\n\n# show_tree(tree)\n", "from collections import deque\n\ndef main():\n    n = int(input())\n    adj = [[]for i in range(n+1)]\n    ab = [list(map(int, input().split())) for i in range(n-1)]\n    for a, b in ab:\n        adj[a].append(b)\n        adj[b].append(a)\n    # deque\u3092\u4f7f\u3063\u305f\u30b9\u30bf\u30c3\u30af\u306b\u3088\u308bDFS\n    # \u5b50\u3092index\u3067\u3001\u89aa\u30ce\u30fc\u30c9\u3092\u8981\u7d20\u3067\n    # \u4eca\u56de\u306f\u5f69\u8272\u306e\u305f\u3081\u306b\u3069\u3093\u306a\u9806\u756a\u3067pop\u3055\u308c\u305f\u304b\u3082\u4fdd\u6301\u3057\u3066\u304a\u304f\n    order  = []\n    parent = [0] * (n+1)\n    visited = [0] * (n+1)\n    visited[1] = 1\n    q = deque([1])\n    while q:\n        par = q.popleft()\n        order.append(par)\n        for chl in adj[par]:\n            if visited[chl]:\n                continue\n            # \u884c\u3063\u305f\u3053\u3068\u306a\u304b\u3063\u305f\u30891\u3078\n            visited[chl] = 1\n            parent[chl] = par\n            q.append(chl)\n    # \u5f69\u8272\n    # \u89aa\u3068\u540c\u3058\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u82e5\u3044\u756a\u53f7\u3092\u5272\u308a\u5f53\u3066\u3066\u884c\u304f\n    cl = [None] * (n+1)\n    for par in order:\n        # \u89aa\u306e\u8272\n        pc = cl[par]\n        # \u5f69\u8272\u306f1\u4ee5\u4e0ak\u4ee5\u4e0b\n        color = 1\n        for chl in adj[par]:\n            # \u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u89aa\u306f\u7121\u8996\n            if chl == parent[par]:\n                continue\n            # \u89aa\u306e\u8272\u3068\u540c\u3058\u306a\u3089\u8272\u3092\u5909\u3048\u308b\n            if pc == color:\n                color += 1\n            # \u30ab\u30e9\u30fc\u30ea\u30b9\u30c8\u306b\u5b50index\u306bcolor\u3092\u5165\u308c\u308b\n            cl[chl] = color\n            #\u3000\u4ed6\u306e\u5b50\u306f\u8272\u3092\u5909\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\n            color += 1\n    # \u6728\u30b0\u30e9\u30d5\u306a\u306e\u3067\u5358\u7d14\u306b\u6b21\u6570\u6700\u5927\u3067\u8003\u3048\u3066\u554f\u984c\u306a\u3044\n    g = max([len(i) for i in adj]) \n    print(g)   \n    for a, b in ab:\n        # \u89aa\u5b50\u95a2\u4fc2\u304c\u9006\u8ee2\u3057\u306a\u3044\u51fa\u529b\u306a\u3089\u3053\u308c\u3067\u3044\u3044\u304c\u305d\u3046\u3068\u3082\u9650\u3089\u306a\u3044 \n        if parent[a] != b:\n            print(cl[b])\n        else:\n            print(cl[a])\n            \ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nab = []\nfor i in range(n-1):\n    a, b = map(int,input().split())\n    ab.append([a, b])\n\ngraph = [[] for _ in range(n+1)]\nfor a,b in ab:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (n+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n        \ncolor = [-1] * (n+1)\nfor x in order:\n    ng = color[x]\n    c = 1\n    for y in graph[x]:\n        if y == parent[x]:\n            continue # \u5b50\u306b\u5bfe\u5fdc\u3055\u305b\u308b\n        if c == ng:\n            c += 1\n        color[y] = c\n        c += 1\n\nprint(max(color))\nfor a,b in ab:\n    if parent[a] == b:\n        print(color[a])\n    else:\n        print(color[b])", "from collections import deque\nN = int(input())\nE = [[] for _ in range(N)]\n  \nfor i in range(N-1):\n  a,b = list(map(int, input().split()))\n  a,b = a-1, b-1\n  # \u51fa\u529b\u306e\u305f\u3081\u306b\u3001\u4f55\u756a\u76ee\u306eEdge\u3060\u3063\u305f\u304b\u3092\u4fdd\u6709\u3055\u305b\u308b\u5fc5\u8981\u304c\u3042\u308b\n  E[a].append([i,b])\n  E[b].append([i,a])\n  \nk = 0\nfor e in E:\n  k = max(k, len(e))\nprint(k)\n\n\ndef bfs():\n  colors = [-1 for _ in range(N-1)]\n  visited = [False for _ in range(N)]\n  d = deque()\n  d.append([0,-1])\n  while d:\n    now,edge_color = d.pop()\n    visited[now] = True\n    cand_color = 1\n    for i, nxt in E[now]:\n      #print(i, nxt, visited[i], colors[i])\n      if visited[nxt]:\n        continue # Tree\u3067BFS\u3060\u3068\u3053\u3053\u306f\u901a\u3089\u306a\u3044\u30fb\u30fb\u30fb\uff1f\n      if colors[i] > -1:\n        assert(\"\uff11\u30a8\u30c3\u30b8\u306b\uff12\u8272\u5857\u308d\u3046\u3068\u3059\u308b\u30fb\u30fb\u30fb\uff1f\")\n        continue\n      if cand_color == edge_color:\n        cand_color += 1\n      colors[i] = cand_color\n      d.append([nxt, colors[i]])\n      cand_color += 1\n  return colors\n\ncolors = bfs()\n\nfor i in range(len(colors)):\n  print(colors[i])", "import sys\nfrom collections import deque\n\nn = int(input())\nG = [[] for _ in range(n + 1)]\nG_order = []\n# a<b\u304c\u4fdd\u8a3c\u3055\u308c\u3066\u3044\u308b\u3001a\u3092\u89aa\u3001b\u3092\u5b50\u3068\u3059\u308b\nfor i in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    G[a].append(b)\n    G_order.append(b)\n\n# \u3069\u3053\u3067\u3082\u826f\u3044\u304c\u3001\u3053\u3053\u3067\u306f0\u3092root\u3068\u3059\u308b\nque = deque([0])\n\n# \u5404\u9802\u70b9\u3068\u300c\u89aa\u300d\u3092\u7d50\u3076\u8fba\u306e\u8272\n# \u9802\u70b90\u3092root\u3068\u3059\u308b\u306e\u3067C[0]=0\u3067\u78ba\u5b9a, \u4ed6\u3092\u8abf\u3079\u308b\ncolors = [0] * n\n\nwhile que:\n    # prt = \u89aa\n    # \u5e45\u512a\u5148\u63a2\u7d22\n    prt = que.popleft()\n    color = 0\n\n    # cld = \u5b50\n    for cld in G[prt]:\n        color += 1\n        # \u300c\u4eca\u8003\u3048\u3066\u3044\u308b\u9802\u70b9\u3068\u305d\u306e\u89aa\u3092\u7d50\u3076\u8fba\u306e\u8272\u300d\u3068\u540c\u3058\u8272\u306f\u4f7f\u3048\u306a\u3044\n        if color == colors[prt]:\n            color += 1\n        colors[cld] = color\n        que.append(cld)\n\n# \u305d\u308c\u305e\u308c\u306e\u9802\u70b9\u3068\u305d\u306e\u89aa\u3092\u7d50\u3076\u8fba\u306e\u8272\n# print(colors)\n\n# \u5fc5\u8981\u306a\u6700\u5c0f\u306e\u8272\u6570\nprint((max(colors)))\n\n# \u8fba\u306e\u756a\u53f7\u9806\u306b\u8272\u3092\u51fa\u529b\nfor i in G_order:\n    print((colors[i]))\n", "n=int(input())\nl=[[] for _ in range(n)]\nli=[]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  l[a-1].append(b-1)\n  li.append([a-1,b-1])\nans=[-1]*n\nfor i in range(n):\n  x=0\n  for j,h in enumerate(l[i]):\n    if ans[i]==j:\n      x+=1\n    ans[h]=j+x\nprint(max(ans)+1)\nfor i in range(n-1):\n  print(ans[li[i][1]]+1)", "from queue import Queue\nN = int(input())\nG = [[] for _ in range(N)]\nQ = [{} for _ in range(N)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n    Q[a-1][b-1] = i\n\nK = max(list(map(len, G)))\nprint(K)\nans = [0] * (N-1)\nq = Queue()\nq.put(0)\nwhile not q.empty():\n    v = q.get()\n    c = set()\n    for u in G[v]:\n        if u < v:\n            c.add(ans[Q[u][v]])\n    \n    i = 1\n    for u in G[v]:\n        if u > v:\n            while i in c: i += 1\n            ans[Q[v][u]] = i\n            i += 1\n            q.put(u)\n\nfor a in ans:\n    print(a)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\n\ndef solve():\n    n = INT()\n    Q = [tuple(MAP1()) for _ in range(n-1)]\n\n    deg = [0]*n\n    adj = [[] for _ in range(n)]\n    color = dict()\n\n    for a, b in Q:\n        deg[a] += 1\n        deg[b] += 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(s, p):\n        nouse = -1\n        if p > -1:\n            nouse = color[(min(s,p),max(s,p))]\n        c = 1\n        for t in adj[s]:\n            if t == p:\n                continue\n            if c == nouse:\n                c += 1\n            color[(min(s,t),max(s,t))] = c\n            dfs(t,s)\n            c += 1\n    \n    dfs(1,-1)\n    \n    print(max(deg))\n    for a, b in Q:\n        print(color[(a, b)])\n\ndef __starting_point():\n    solve()\n__starting_point()", "n = int(input())\nA = []\ng  =[[] for _ in range(n+1)]\nans = {}\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    g[a].append(b)\n    A.append([a,b])\n \n \nfrom collections import deque\n \nq = deque()\nq.append(1)\n \ncolor = [-1]*(n+1)\ncolor[1] = 0\ncnt = 0\n \nwhile q:\n    v = q.popleft()\n    p = 1\n    for u in g[v]:\n        if p==color[v]:\n            p += 1\n        color[u] = p\n        ans[v,u] = p\n        q.append(u)\n        cnt = max(cnt,p)\n        p += 1\nprint(cnt)\n \nfor i in range(n-1):\n    tmp = (A[i][0],A[i][1])\n    print(ans[tmp])", "from collections import defaultdict, deque\n\n\nN, *AB = map(int, open(0).read().split())\ng = defaultdict(set)\nedges = []\nfor a, b in zip(*[iter(AB)] * 2):\n    a -= 1\n    b -= 1\n    g[a].add(b)\n    g[b].add(a)\n    edges.append((a, b))\n\nq = deque([0])\nvisited = [False] * N\nvisited[0] = True\nused = [0] * N\ncolors_cnt = 1\nans = {}\nwhile q:\n    v = q.popleft()\n    color = 1\n    for nv in g[v]:\n        if visited[nv]:\n            continue\n        if color == used[v]:\n            color += 1\n        used[nv] = color\n        ans[(min(v, nv), max(v, nv))] = color\n        color += 1\n        q.append(nv)\n        visited[nv] = True\n    colors_cnt = max(colors_cnt, color - 1)\nprint(colors_cnt)\n[print(ans[(a, b)]) for a, b in edges]\n\n"]
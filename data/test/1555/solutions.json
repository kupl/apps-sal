["'''input\n3 3\n>>>\n<<<\n>>>\n'''\n#print(input().split())\nn, m = list(map(int, input().split()))\n#return\ng = []\nfor i in range(n):\n\tg += [input()]\n# print(g)\n\n\nmemo = {}\n\ndef dfs(u):\n\tif u not in memo:\n\t\tmemo[u] = res = 1\n\t\tif u < n:\n\t\t\tfor v in range(m):\n\t\t\t\tif g[u][v] == '>':\n\t\t\t\t\tres = max(res, dfs(n + v) + 1)\n\t\t\tfor v in range(m):\n\t\t\t\tif g[u][v] == '=':\n\t\t\t\t\tres = max(res, dfs(n + v))\n\t\t\tfor v in range(m):\n\t\t\t\tif g[u][v] == '=':\n\t\t\t\t\tmemo[n + v] = max(memo[n + v], res)\n\t\telse:\n\t\t\tfor v in range(n):\n\t\t\t\tif g[v][u - n] == '<':\n\t\t\t\t\tres = max(res, dfs(v) + 1)\n\t\t\tfor v in range(n):\n\t\t\t\tif g[v][u - n] == '=':\n\t\t\t\t\tres = max(res, dfs(v))\n\t\t\tfor v in range(n):\n\t\t\t\tif g[v][u - n] == '=':\n\t\t\t\t\tmemo[v] = max(memo[v], res)\n\t\tmemo[u] = res\n\treturn memo[u]\nans = [0] * (n + m)\nfor i in range(n + m):\n\tans[i] = dfs(i)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif g[i][j] == '=' and ans[i] != ans[n + j]:\n\t\t\tprint(\"No\")\n\t\t\treturn\n\t\tif g[i][j] == '<' and ans[i] >= ans[n + j]:\n\t\t\tprint(\"No\")\n\t\t\treturn\n\t\tif g[i][j] == '>' and ans[i] <= ans[n + j]:\n\t\t\tprint(\"No\")\n\t\t\treturn\nprint(\"Yes\")\nprint(*ans[:n])\nprint(*ans[n:])\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n\nN, M = map(int, readline().split())\nL = [readline().strip() for i in range(N)]\n\ndef root(x):\n    if x == p[x]:\n        return x\n    p[x] = y = root(p[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n\n*p, = range(N+M)\nfor i in range(N):\n    for j, c in enumerate(L[i]):\n        if c == '=':\n            unite(i, N+j)\n\nG = [[] for i in range(N+M)]\nRG = [[] for i in range(N+M)]\ndeg = [0]*(N+M)\n\nfor i in range(N):\n    x = root(i)\n    for j, c in enumerate(L[i]):\n        y = root(N+j)\n        if c == '<':\n            G[x].append(y)\n            RG[y].append(x)\n            deg[y] += 1\n        elif c == '>':\n            G[y].append(x)\n            RG[x].append(y)\n            deg[x] += 1\nA = [-1]*(N+M)\n\nque = deque()\nfor i in range(N+M):\n    if root(i) == i and deg[i] == 0:\n        que.append(i)\nwhile que:\n    v = que.popleft()\n    lb = 0\n    for w in RG[v]:\n        lb = max(lb, A[w])\n    A[v] = lb+1\n    for w in G[v]:\n        deg[w] -= 1\n        if deg[w] == 0:\n            que.append(w)\nif any(root(i) == i and A[i] == -1 for i in range(N+M)):\n    print(\"No\")\nelse:\n    for i in range(N+M):\n        A[i] = A[root(i)]\n    print(\"Yes\")\n    print(*A[:N])\n    print(*A[N:])", "import sys\n\nsys.setrecursionlimit(2000)\n\n\ndef dfs1(v, mintime):\n    localtime = mintime\n    vis1[v] = 1\n    for v2 in range(m):\n        if a[v][v2] == \">\":\n            if not vis2[v2]:\n                dfs2(v2, 1)\n            localtime = max(localtime, time2[v2] + 1)\n    for v2 in range(m):\n        if a[v][v2] == \"=\":\n            if not vis2[v2]:\n                dfs2(v2, localtime)\n            localtime = max(localtime, time2[v2])\n    time1[v] = localtime\n\n\ndef dfs2(v, mintime):\n    localtime = mintime\n    vis2[v] = 1\n    for v2 in range(n):\n        if a[v2][v] == \"<\":\n            if not vis1[v2]:\n                dfs1(v2, 1)\n            localtime = max(localtime, time1[v2] + 1)\n    for v2 in range(n):\n        if a[v2][v] == \"=\":\n            if not vis1[v2]:\n                dfs1(v2, localtime)\n            localtime = max(localtime, time1[v2])\n    time2[v] = localtime\n\n\nn, m = list(map(int, input().split()))\na = [input() for i in range(n)]\ntime1 = [0] * n\ntime2 = [0] * m\nvis1 = [0] * n\nvis2 = [0] * m\ntime = 0\ntry:\n    for v in range(n):\n        if not time1[v]:\n            dfs1(v, 1)\n    for v in range(m):\n        if not time2[v]:\n            dfs2(v, 1)\n    correct = True\n    for v1 in range(n):\n        for v2 in range(m):\n            if a[v1][v2] == \"=\" and time1[v1] != time2[v2]:\n                correct = False\n            if a[v1][v2] == \">\" and time1[v1] <= time2[v2]:\n                correct = False\n            if a[v1][v2] == \"<\" and time1[v1] >= time2[v2]:\n                correct = False\n    if correct:    \n        print(\"Yes\")\n        print(*time1)\n        print(*time2)\n    else:\n        print(\"No\")\nexcept RecursionError:\n    print(\"No\")\n", "def prov(mass, now):\n    check = True\n    for i in range(n):\n        for k in range(m):\n            if now[i][k] == '>' and mass[i] <= mass[n + k]:\n                check = False\n                break\n            elif now[i][k] == '<' and mass[i] >= mass[n + k]:\n                check = False\n                break\n            elif now[i][k] == '=' and mass[i] != mass[n + k]:\n                check = False\n                break\n        if not check:\n            break\n    return check\n\ndef prog(mass, n, m):\n    prov = True\n    for i in range(1, m):\n        for k in range(n):\n            if mass[i][k] < mass[i - 1][k]:\n                prov = False\n                break\n        if not prov:\n            break\n    if not prov:\n        return False\n    else:\n        mass_new = []\n        for i in range(1, m):\n            mass_n = []\n            for k in range(n):\n                mass_n.append(mass[i][k] - mass[i - 1][k])\n            mass_new.append(max(mass_n))\n        arr = [1 for i in range(m)]\n        now = 1\n        if 1 in mass[0][:-1]:\n            now += 1\n            arr = [2 for i in range(m)]\n        for i in range(1, m):\n            now += mass_new[i - 1]\n            arr[mass[i][-1]] = now\n        return arr\n    \nn, m = map(int, input().split())\nif n + m <= 6:\n    now = []\n    for i in range(n):\n        now.append(input())\n    ppp = True\n    for i1 in range(n + m):\n        for i2 in range(n + m):\n            for i3 in range(n + m):\n                for i4 in range(n + m):\n                    for i5 in range(n + m):\n                        for i6 in range(n + m):\n                            mass = [i1 + 1, i2 + 1, i3 + 1, i4 + 1, i5 + 1, i6 + 1][:n + m]\n                            if prov(mass, now) and ppp:\n                                print('Yes')\n                                print(*mass[:n])\n                                print(*mass[n:])\n                                ppp = False\n    if ppp:\n        print('No')\nelse:\n    mass = [[] for i in range(m)]\n    mass1 = [[] for i in range(n)]\n    for i in range(n):\n        now = input()\n        for k in range(m):\n            if now[k] == '<':\n                mass[k].append(1)\n                mass1[i].append(-1)\n            elif now[k] == '=':\n                mass[k].append(0)\n                mass1[i].append(0)\n            else:\n                mass[k].append(-1)\n                mass1[i].append(1)\n    for i in range(m):\n        mass[i].append(i)\n    for i in range(n):\n        mass1[i].append(i)\n    mass.sort()\n    mass1.sort()\n    \n    arr = prog(mass, n, m)\n    arr1 = prog(mass1, m, n)\n    if arr == False or arr1 == False:\n        print('No')\n    else:\n        print('Yes')\n        print(*arr1)\n        print(*arr)    ", "n, m = (int(t) for t in input().split(' '))\ndef direction(c):\n    if c == '=': return 0\n    if c == '>': return 1\n    return -1\n\nmx = [[direction(c) for c in input()] for _ in range(n)]\n\nindex = 0\nclass DSet(object):\n    def __init__(self, value):\n        nonlocal index\n        self.values = set([value])\n        self.index = index\n        index += 1\n        self.edges_to = set()\n        self.edges_from = set()\n\n    def __len__(self):\n        return len(self.values)\n    def update(self, other_dset):\n        self.values.update(other_dset.values)\n\n    def add_edge_to(self, i):\n        self.edges_to.add(i)\n\n    def add_edge_from(self, i):\n        self.edges_from.add(i)\n\n    def remove_edge_from(self, i):\n        self.edges_from.remove(i)\n\ndsu = [DSet(i) for i in range(n+m)]\n\ndef union(v1, v2):\n    if len(dsu[v1]) > len(dsu[v2]):\n        d = dsu[v1]\n        d.update(dsu[v2])\n    else:\n        d = dsu[v2]\n        d.update(dsu[v1])\n\n    dsu[v1] = dsu[v2] = d\n\nfor i in range(n):\n    for j in range(m):\n        if not mx[i][j]:\n            union(i, n + j)\n\nfor i in range(n):\n    for j in range(m):\n        if mx[i][j] > 0:\n            dsu[i].add_edge_from(dsu[n + j].index)\n            dsu[n+j].add_edge_to(dsu[i].index)\n        elif mx[i][j] < 0:\n            dsu[n + j].add_edge_from(dsu[i].index)\n            dsu[i].add_edge_to(dsu[n+j].index)\n\nweights = [1] * (n+m)\ndsu_by_index = { d.index: d for d in dsu }\n\nwhile True:\n    try:\n        v = next(d for d in range(n+m) if not len(dsu[d].edges_from) and len(dsu[d].edges_to))\n    except:\n        break\n\n    dsuv = dsu[v]\n    for edge in dsu[v].edges_to:\n        dsue = dsu_by_index[edge]\n        dsue.remove_edge_from(dsuv.index)\n        for value in dsue.values:\n            weights[value] = weights[v] + 1\n\n    dsu[v].edges_to.clear()\n\nok = all(not len(d.edges_from) and not len(d.edges_to) for d in dsu)\nif ok:\n    print('Yes')\n    print(*weights[0:n])\n    print(*weights[n:])\nelse:\n    print('No')\n", "r,c = map(int, input().split())\n\nm = []\n\np = [i for i in range(0,r+c)]\ntree = [[] for i in range(0, r+c)]\n\nfor i in range(0,r):\n    s = input().split('\\n')[0]\n    m.append(list(s))\n\ndef find(i):\n    if p[i] ==i:\n        return i\n    par =  find(p[i])\n    p[i] = par\n    return p[i]\n\ndef join(i,j):\n    p[find(i)] = find(j)\n\nfor i in range(0,r):\n    for j in range(0,c):\n        if m[i][j] == '=':\n            join(i,r+j)\n        elif m[i][j] == '>':\n            tree[i].append(r+j)\n        elif m[i][j] == '<':\n            tree[r+j].append(i)\n\nv = [False for i in range(0, r+c)]\nv2 = [False for i in range(0, r+c)]\n\na = [1 for i in range(0,r+c)]\nl = [[] for i in range(0,r+c)]\n\nfor i in range(0,r+c):\n    l[find(i)].append(i)\n\nimport sys\n\ndef dfs(i):\n    i = find(i)\n    if v[i]:\n        return sys.maxsize\n    elif v2[i]:\n        return a[i]\n    v[i] = True\n    for k in l[i]:\n        for j in tree[k]:\n            a[i] = max(dfs(j)+1, a[i])\n    v[i] = False\n    v2[i] = True\n    return a[i]\n\n\nA = []\n\nans = True\nfor i in range(0,r+c):\n    A.append(dfs(i))\n    if A[i] > r+c:\n        ans = False\n\n\nm = {}\nindex = 0\npre = -1\nfor i in sorted(A):\n    if pre == i:\n        m[i] = index\n    else:\n        pre = i\n        index+=1\n        m[i] = index\n\n\nfor i in range(0,r+c):\n    A[i] = m[A[i]]\nif ans:\n    print(\"Yes\")\n    print(str(A[:r]).replace(',','').replace('[','').replace(']',''))\n    print(str(A[r:]).replace(',','').replace('[','').replace(']',''))\nelse:\n    print(\"No\")", "class UnionFind:\n \n    def __init__(self, n):\n        self.follow = [-1]*(n+1)\n        self.num_follower = [1]*(n+1)\n \n    def root_index_of(self, a):\n        r = a\n        while self.follow[r] > -1:\n                 r = self.follow[r]\n        return r\n \n    def connected(self, a, b):\n        return self.root_index_of(a) == self.root_index_of(b)\n \n    def connect(self, a, b):\n        ra = self.root_index_of(a)\n        rb = self.root_index_of(b)\n \n        if ra == rb:\n            return\n \n        if self.num_follower[ra] < self.num_follower[rb]:\n            self.follow[ra] = rb\n            self.follow[a] = rb\n            self.num_follower[rb] += self.num_follower[ra]\n        else:\n            self.follow[rb] = ra\n            self.follow[b] = ra\n            self.num_follower[ra] += self.num_follower[rb]\n\nimport sys\nfrom collections import deque\ninput = sys.stdin.readline\nn, m = map(int, input().split())\ns = [input() for _ in range(n)]\n\nuf = UnionFind(n+m)\nv = [[] for _ in range(n+m)]\nc = [0]*(n+m)\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \"=\":\n            uf.connect(i, j+n)\n\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \"<\":\n            v[uf.root_index_of(i)].append(uf.root_index_of(n+j))\n            c[uf.root_index_of(n+j)] += 1\n        elif s[i][j] == \">\":\n            v[uf.root_index_of(n+j)].append(uf.root_index_of(i))\n            c[uf.root_index_of(i)] += 1\n\n\nans = [0]*(n+m)\nused = [0]*(n+m)\nque = deque([])\nfor i in range(n+m):\n    if c[i] == 0:\n        ans[i] = 1\n        used[i] = 1\n        que.append(i)\n\n\nwhile que:\n    x = que.popleft()\n    for i in v[x]:\n        if used[i]:\n            continue\n        ans[i] = max(ans[x]+1, ans[i])\n        c[i] -= 1\n        if c[i] == 0:\n            used[i] = 1\n            que.append(i)\n\nfor i in range(n+m):\n    if used[i] == 0:\n        print(\"No\")\n        return\n\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \"=\":\n            if ans[uf.root_index_of(i)] != ans[uf.root_index_of(n+j)]:\n                print(\"No\")\n                return\n\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \"<\":\n            if ans[uf.root_index_of(i)] >= ans[uf.root_index_of(n+j)]:\n                print(\"No\")\n                return\n\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == \">\":\n            if ans[uf.root_index_of(i)] <= ans[uf.root_index_of(n+j)]:\n                print(\"No\")\n                return\n\nprint(\"Yes\")\nfor i in range(n):\n    print(ans[uf.root_index_of(i)], end=\" \")\nprint()\nfor j in range(m):\n    print(ans[uf.root_index_of(j+n)], end=\" \")\nprint()\n\n", "import os\nfrom io import BytesIO\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nfrom itertools import product\n\nclass CYCLE(Exception):\n    ...\n\ndebug_print = lambda *args: None\n\ndef solve(n, m, gs):\n    def union(u, v):\n        p, q = find(u), find(v)\n        if p == q: return\n        if rank[p] < rank[q]: p, q = q, p\n        if rank[p] == rank[q]: rank[p] += 1\n        parent[q] = p\n\n    def find(u):\n        if parent[u] == u: return u\n        else:\n            p = find(parent[u])\n            parent[u] = p\n            return p\n\n    rank = [0] * (n + m)\n    parent = list(range(n + m))\n\n    for i, j in product(range(n), range(m)):\n        if gs[i][j] == \"=\":\n            union(i, n + j)\n\n    vertices = set(parent)\n    v_sz = len(vertices)\n    g = [set() for _ in range(n + m)]\n\n    for i, j in product(range(n), range(m)):\n        c = gs[i][j]\n        i, j = parent[i], parent[n + j]\n\n        if c == \"<\":\n            g[i].add(j)\n        elif c == \">\":\n            g[j].add(i)\n\n    debug_print(vertices, g)\n\n    NIL, VISITED, FINAL = 0, 1, 2\n    state = [NIL] * (n + m)\n    toposort_stack = []\n\n    def visit(v):\n        debug_print(v)\n        if state[v] == VISITED:\n            raise CYCLE\n\n        state[v] = VISITED\n        for u in g[v]:\n            if state[u] != FINAL:\n                visit(u)\n        state[v] = FINAL\n        toposort_stack.append(v)\n\n    try:\n        for v in vertices:\n            if state[v] == FINAL:\n                continue\n            visit(v)\n    except CYCLE:\n        print('No')\n        return\n\n    debug_print(toposort_stack)\n\n    layer = [1] * (n + m)\n\n    while toposort_stack:\n        v = toposort_stack.pop()\n        for u in g[v]:\n            layer[u] = max(layer[u], layer[v]+1)\n\n    print('Yes')\n\n    out = []\n    for i in range(n):\n        out.append(str(layer[parent[i]]))\n    print(' '.join(out))\n\n    out = []\n    for j in range(m):\n        out.append(str(layer[parent[n + j]]))\n    print(' '.join(out))\n\n\ndef solve_from_stdin():\n    n, m = map(int, input().split())\n    gs = []\n    for _ in range(n):\n        gs.append(input())\n    solve(n, m, gs)\n\nsolve_from_stdin()", "class mergefind:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n\n    def find(self,a):\n        to_update = []\n       \n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n       \n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a==b:\n            return\n\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef toposort(C, n):\n    indeg = [0]*n\n    for i,neighs in enumerate(C):\n        for neigh in neighs:\n            indeg[neigh] += 1\n\n    S = [i for i in range(n) if indeg[i] == 0]\n    nparent = indeg[:]\n    topo = []\n    while S:\n        cur = S.pop()\n        topo.append(cur)\n        for neigh in C[cur]:\n            nparent[neigh] -= 1\n            if nparent[neigh] == 0:\n                S.append(neigh)\n        nparent[cur] = -1\n    return topo\n\n\nn,m = list(map(int,input().split()))\nA = [input() for _ in range(n)]\n\nmf = mergefind(n+m)\n\n# merge equal elements\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '=':\n            mf.merge(i,n+j)\n\n# Connections: smaller -> larger\nC = [set() for _ in range(n+m)]\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '<':\n            C[mf.find(i)].add(mf.find(n+j))\n        elif A[i][j] == '>':\n            C[mf.find(n+j)].add(mf.find(i))\n\n# Walk through graph in toposort order\n# What I'm pointing to must be at least\n# my value + 1\nD = [1]*(n+m)\nfor cur in toposort(C, n+m):\n    for neigh in C[cur]:\n        D[neigh] = max(D[neigh], D[cur]+1)\n\n# Propagate values within equal clusters\nD = [D[mf.find(i)] for i in range(n+m)]\n\n# Validate answer\nok = True\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '<':\n            if D[i] >= D[n+j]:\n                ok = False\n        elif A[i][j] == '>':\n            if D[i] <= D[n+j]:\n                ok = False\n        else:\n            if D[i] != D[n+j]:\n                ok = False\n\nif ok:\n    print('Yes')\n    print(*D[:n])\n    print(*D[n:])\nelse:\n    print('No')\n\n", "class mergefind:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n\n    def find(self,a):\n        to_update = []\n       \n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n       \n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a==b:\n            return\n\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef toposort(C, n):\n    indeg = [0]*n\n    for i,neighs in enumerate(C):\n        for neigh in neighs:\n            indeg[neigh] += 1\n\n    S = [i for i in range(n) if indeg[i] == 0]\n    nparent = indeg[:]\n    topo = []\n    while S:\n        cur = S.pop()\n        topo.append(cur)\n        for neigh in C[cur]:\n            nparent[neigh] -= 1\n            if nparent[neigh] == 0:\n                S.append(neigh)\n#         nparent[cur] = -1\n    return topo\n\n\nn,m = map(int,input().split())\nA = [input() for _ in range(n)]\n\nmf = mergefind(n+m)\n\n# merge equal elements\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '=':\n            mf.merge(i,n+j)\n\n# Connections: smaller -> larger\nC = [set() for _ in range(n+m)]\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '<':\n            C[mf.find(i)].add(mf.find(n+j))\n        elif A[i][j] == '>':\n            C[mf.find(n+j)].add(mf.find(i))\n\n# Walk through graph in toposort order\n# What I'm pointing to must be at least\n# my value + 1\nD = [1]*(n+m)\nfor cur in toposort(C, n+m):\n    for neigh in C[cur]:\n        D[neigh] = max(D[neigh], D[cur]+1)\n\n# Propagate values within equal clusters\nD = [D[mf.find(i)] for i in range(n+m)]\n\n# Validate answer\nok = True\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '<':\n            if D[i] >= D[n+j]:\n                ok = False\n        elif A[i][j] == '>':\n            if D[i] <= D[n+j]:\n                ok = False\n        else:\n            if D[i] != D[n+j]:\n                ok = False\n\nif ok:\n    print('Yes')\n    print(*D[:n])\n    print(*D[n:])\nelse:\n    print('No')", "#!/usr/bin/env pypy\nimport collections\n#import random\nimport heapq\nimport bisect\nimport math\nimport time\n\n\nclass Solution2:\n    def solve(self, A1, A2):\n        pass\n\n\ndef gcd(a, b):\n    if not b: return a\n    return gcd(b, a%b)\ndef lcm(a, b):\n    return b*a//gcd(b,a)\n\n\nclass Solution:\n\n    def solve(self, grid):\n        def union(i,j):\n            leader_i, leader_j = find(i), find(j)\n            sets[leader_j] = sets[i] = sets[j] = leader_i\n        def find(i):\n            while i != sets[i]:\n                i = sets[i]\n            return i\n        N = len(grid) + len(grid[0])\n        sets = list(range(N))\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '=': union(i,j+len(grid))\n\n        graph = collections.defaultdict(set)\n        inc = collections.defaultdict(set)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                leader_i, leader_j = find(i), find(j+len(grid))\n                if grid[i][j] == '>':\n                    if leader_i == leader_j: \n                        print(\"No\")\n                        return\n                    graph[leader_j].add(leader_i)\n                    inc[leader_i].add(leader_j)\n                elif grid[i][j] == '<':\n                    if leader_i == leader_j: \n                        print(\"No\")\n                        return\n                    graph[leader_i].add(leader_j)\n                    inc[leader_j].add(leader_i)\n\n        self.levels = [0]*N\n        def dfs(node, level):\n            self.levels[node] = max(self.levels[node],level)\n            if not inc[node]:\n                seen.add(node)\n                for next_node in graph[node]:\n                    inc[next_node].discard(node)\n                    dfs(next_node,self.levels[node]+1)\n\n        seen = set()\n        for i in range(N):\n            l = find(i)\n            if not inc[l] and l not in seen:\n                seen.add(l)\n                dfs(l, 1)\n\n        if any(inc[find(node)] for node in range(N)):\n            print(\"No\")\n            return\n\n        for i in range(N):\n            l = find(i)\n            if l != i:\n                self.levels[i] = self.levels[l]\n\n        print(\"Yes\")\n        print(' '.join(str(o) for o in self.levels[:len(grid)]))\n        print(' '.join(str(o) for o in self.levels[len(grid):]))\n\n\nsol = Solution()\nsol2 = Solution2()\n\n#TT = int(input())\nfor test_case in range(1):\n    N, M = input().split()\n    a = []\n    for _ in range(int(N)):\n        a.append(input())\n    #b = [int(c) for c in input().split()]\n\n    out = sol.solve(a)\n    #print(' '.join([str(o) for o in out]))\n    #print(str(out))\n\n    # out2 = sol2.solve(s)\n\n\n# for _ in range(100000):\n#     rand = [random.randrange(60) for _ in range(10)]\n#     out1 = sol.solve(rand)\n#     out2 = sol2.solve(rand)\n#     if out1 != out2: \n#         print(rand, out1, out2)\n#         break\n", "import time\n\ndebug = False\n\nn1, m2 = list(map(int, input().split()))\n\ntests = []\nfor i in range(n1):\n\ttests.append(list(input()))\n\nif debug:\n\tprint (tests)\n\nbegin = time.time()\n\nif debug:\n\tprint(\"---\")\n\nmarks1 = []\nresult1 = []\nfor i in range(n1):\n\tmarks1.append([i,0.0])\n\tresult1.append(0)\n\nmarks2 = []\nresult2 = []\nfor j in range(m2):\n\tmarks2.append([j,0.0])\n\tresult2.append(0)\n\nfor i in range(n1):\n\tfor j in range(m2):\n\t\ttest = tests[i][j]\n\t\tif test == \">\":\n\t\t\tmarks1[i][1] += 1.0\n\t\telif test == \"<\":\n\t\t\tmarks2[j][1] += 1.0\n\t\telse:\n\t\t\tmarks1[i][1] += 0.0001\n\t\t\tmarks2[j][1] += 0.0001\n\nmarks1.sort(key=lambda val: val[1])\nmarks2.sort(key=lambda val: val[1])\n\nif debug:\n\tprint(marks1)\n\tprint(marks2)\n\ni = 0\nj = 0\nvalue = 0\nlastmark = -1\nlastItem = [0,0]\n\nwhile i < n1 or j < m2:\n\tLetAdd = 0\n\tif i < n1 and j < m2:\n\t\ttest = tests[marks1[i][0]][marks2[j][0]]\n\t\tif test == \">\":\n\t\t\tLetAdd = 2\n\t\telse:\n\t\t\tLetAdd = 1\n\telif i < n1:\n\t\tLetAdd = 1\n\telse:\n\t\tLetAdd = 2\n\n\tif LetAdd == 1:\n\t\tif marks1[i][1] != lastmark and lastItem[0] != 2 or lastItem[0] == 2 and tests[marks1[i][0]][lastItem[1]] != '=':\n\t\t\tif debug:\n\t\t\t\tif lastItem[0] == 2:\n\t\t\t\t\tprint(1, lastmark, lastItem, marks1[i][0], tests[marks1[i][0]][lastItem[1]])\n\t\t\t\telse:\n\t\t\t\t\tprint(1, lastmark, lastItem, marks1[i][0])\n\t\t\tvalue += 1\n\t\tlastmark = marks1[i][1]\n\t\tresult1[marks1[i][0]] = value\n\t\tlastItem = [1,marks1[i][0]]\n\t\ti += 1\n\telse:\n\t\tif marks2[j][1] != lastmark and lastItem[0] != 1 or lastItem[0] == 1 and tests[lastItem[1]][marks2[j][0]] != '=':\n\t\t\tif debug:\n\t\t\t\tif lastItem[0] == 1:\n\t\t\t\t\tprint(2, lastmark, lastItem, marks2[j][0], tests[lastItem[1]][marks2[j][0]])\n\t\t\t\telse:\n\t\t\t\t\tprint(2, lastmark, lastItem, marks2[j][0])\n\t\t\tvalue += 1\n\t\tlastmark = marks2[j][1]\n\t\tresult2[marks2[j][0]] = value\n\t\tlastItem = [2,marks2[j][0]]\n\t\tj += 1\n\tif debug:\n\t\tprint(\"Set \", lastItem, \" to \", value)\n\nCheckCorrect = True\nfor i in range(n1):\n\tfor j in range(m2):\n\t\ttest = tests[i][j]\n\t\tif test == \">\":\n\t\t\tif result1[i] <= result2[j]:\n\t\t\t\tCheckCorrect = False\n\t\telif test == \"<\":\n\t\t\tif result1[i] >= result2[j]:\n\t\t\t\tCheckCorrect = False\n\t\telse:\n\t\t\tif result1[i] != result2[j]:\n\t\t\t\tCheckCorrect = False\nif debug:\n\tprint(\"---\")\n\nif debug:\n\tprint(\"Time: \", time.time() - begin)\n\nif CheckCorrect:\n\tprint (\"Yes\")\nelse:\n\tprint (\"No\")\n\nif CheckCorrect or debug:\n\tprint(*result1)\n\tprint(*result2)\n"]
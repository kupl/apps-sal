["\nfrom queue import Queue\nimport sys\n\ncost = []\n\ndef readarray(): return list(map(int, input().split(' ')))\n\nn = int(input())\ngraph = [[] for i in range(n)]\n\nfor i in range(n - 1):\n\tu, v, c = readarray()\n\tu, v = u - 1, v - 1\n\tcost.append(c)\n\tgraph[u].append((v, i))\n\tgraph[v].append((u, i))\n\t\n\norder = []\nused = [0] * n\nq = [0] * (n + n)\n\nqh = qt = 0\n\n\nused[qh] = 1\nqh += 1\n\nwhile qt < qh:\n\tv = q[qt]\n\tqt += 1\n\t\n\torder.append(v)\n\t\n\tfor (to, e) in graph[v]:\n\t\tif used[to]:\n\t\t\tcontinue\n\t\tused[to] = 1\n\t\tq[qh] = to\n\t\tqh += 1\n\t\t\n\n\t\t\norder.reverse()\n\t\t\nsz = [0 for x in range(n)]\n\nfor v in order:\n\tsz[v] = 1\n\tfor (to, e) in graph[v]:\n\t\tsz[v] += sz[to]\n\"\"\"\n\nsz = [0] * n\n\nsys.setrecursionlimit(100505)\n\ndef dfs(v, p):\n\tsz[v] = 1\n\t\n\tfor (to, e) in graph[v]:\n\t\tif to != p:\n\t\t\tdfs(to, v)\n\t\t\tsz[v] += sz[to]\n\t\t\t\ndfs(0, -1)\n\n\"\"\"\n\ndistanceSum = 0.0\nedgeMult = [0] * n\n\nfor v in range(n):\n\tfor (to, e) in graph[v]:\n\t\tx = min(sz[v], sz[to])\n\t\tedgeMult[e] = x\n\t\tdistanceSum += 1.0 * cost[e] * x * (n - x)\n\t\t\ndistanceSum /= 2.0\n\nqueryCnt = int(input())\n\nans = []\n\nfor i in range(queryCnt):\n\tx, y = readarray()\n\tx -= 1\n\t\n\tdistanceSum -= 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n\tcost[x] = y\n\tdistanceSum += 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n\t\n\tans.append('%.10lf' % (distanceSum / n / (n - 1) * 6.0))\n\nprint('\\n'.join(ans))\n", "from queue import Queue\nimport sys\n\ncost = []\n\ndef readarray(): return map(int, input().split(' '))\n\nn = int(input())\ngraph = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    u, v, c = readarray()\n    u, v = u - 1, v - 1\n    cost.append(c)\n    graph[u].append((v, i))\n    graph[v].append((u, i))\n    \n\norder = []\nused = [0] * n\nq = [0] * (n + n)\n\nqh = qt = 0\n\n\nused[qh] = 1\nqh += 1\n\nwhile qt < qh:\n    v = q[qt]\n    qt += 1\n    \n    order.append(v)\n    \n    for (to, e) in graph[v]:\n        if used[to]:\n            continue\n        used[to] = 1\n        q[qh] = to\n        qh += 1\n        \n\n        \norder.reverse()\n        \nsz = [0 for x in range(n)]\n\nfor v in order:\n    sz[v] = 1\n    for (to, e) in graph[v]:\n        sz[v] += sz[to]\n\"\"\"\n\nsz = [0] * n\n\nsys.setrecursionlimit(100505)\n\ndef dfs(v, p):\n    sz[v] = 1\n    \n    for (to, e) in graph[v]:\n        if to != p:\n            dfs(to, v)\n            sz[v] += sz[to]\n            \ndfs(0, -1)\n\n\"\"\"\n\ndistanceSum = 0.0\nedgeMult = [0] * n\n\nfor v in range(n):\n    for (to, e) in graph[v]:\n        x = min(sz[v], sz[to])\n        edgeMult[e] = x\n        distanceSum += 1.0 * cost[e] * x * (n - x)\n        \ndistanceSum /= 2.0\n\nqueryCnt = int(input())\n\nans = []\n\nfor i in range(queryCnt):\n    x, y = readarray()\n    x -= 1\n    \n    distanceSum -= 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n    cost[x] = y\n    distanceSum += 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n    \n    ans.append('%.10lf' % (distanceSum / n / (n - 1) * 6.0))\n\nprint('\\n'.join(ans))", "from queue import Queue\nimport sys\n\ncost = []\n#coo\ndef readarray(): return map(int, input().split(' '))\n\nn = int(input())\ngraph = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    u, v, c = readarray()\n    u, v = u - 1, v - 1\n    cost.append(c)\n    graph[u].append((v, i))\n    graph[v].append((u, i))\n    \n\norder = []\nused = [0] * n\nq = [0] * (n + n)\n\nqh = qt = 0\n\n\nused[qh] = 1\nqh += 1\n\nwhile qt < qh:\n    v = q[qt]\n    qt += 1\n    \n    order.append(v)\n    \n    for (to, e) in graph[v]:\n        if used[to]:\n            continue\n        used[to] = 1\n        q[qh] = to\n        qh += 1\n        \n\n        \norder.reverse()\n        \nsz = [0 for x in range(n)]\n\nfor v in order:\n    sz[v] = 1\n    for (to, e) in graph[v]:\n        sz[v] += sz[to]\n\"\"\"\n\nsz = [0] * n\n\nsys.setrecursionlimit(100505)\n\ndef dfs(v, p):\n    sz[v] = 1\n    \n    for (to, e) in graph[v]:\n        if to != p:\n            dfs(to, v)\n            sz[v] += sz[to]\n            \ndfs(0, -1)\n\n\"\"\"\n\ndistanceSum = 0.0\nedgeMult = [0] * n\n\nfor v in range(n):\n    for (to, e) in graph[v]:\n        x = min(sz[v], sz[to])\n        edgeMult[e] = x\n        distanceSum += 1.0 * cost[e] * x * (n - x)\n        \ndistanceSum /= 2.0\n\nqueryCnt = int(input())\n\nans = []\n\nfor i in range(queryCnt):\n    x, y = readarray()\n    x -= 1\n    \n    distanceSum -= 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n    cost[x] = y\n    distanceSum += 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n    \n    ans.append('%.10lf' % (distanceSum / n / (n - 1) * 6.0))\n\nprint('\\n'.join(ans))", "import sys\nsys.setrecursionlimit(1500)\n\nMAX = 100005;\ng = [[] for _ in range(MAX)]\nvis = [False] * MAX\ndp = [0] * MAX\nprod = [0] * MAX\n\nedges = []\norder = []\ndef dfs(st):\n    stack = []\n    stack.append((st, -1))\n    vis[st] = True\n    while stack:\n        st, parent = stack.pop()\n        order.append(st)\n        vis[st] = True\n        if (st == parent): continue;\n        for i in g[st]:\n            if (vis[i[0]]): continue;\n            stack.append((i[0], st))\n\nn = int(input())\nfor i in range(n-1):\n    a, b, w = list(map(int, sys.stdin.readline().split(' ')))\n    g[a].append([b, w])\n    g[b].append([a,w])\n    edges.append([[a, b], w])\n\ndfs(1);\norder.reverse()\nfor st in order:\n    dp[st] = 1;\n    for i in g[st]:\n        dp[st] += dp[i[0]];\ntot = 0;\ncurr = 1;\ndiv = n * (n-1) / 2;\nfor i in edges:\n    a = i[0][0];\n    b = i[0][1];\n    sa = dp[a];\n    sb = dp[b];\n    tot += min(sa, sb) * (n - min(sa, sb)) * i[1];\n    prod[curr] = min(sa, sb) * (n - min(sa, sb));\n    curr += 1;\n\nq = int(input())\nfor i in range(q):\n    q1, q2 = list(map(int, sys.stdin.readline().split(' ')))\n    tot -= prod[q1] * edges[q1-1][1];\n    edges[q1-1][1] = q2;\n    tot += prod[q1] * edges[q1-1][1];\n    sys.stdout.write(str(tot*3/div)+\"\\n\")\n"]
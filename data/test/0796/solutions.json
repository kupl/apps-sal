["fa = [1]\nm = 251\nP = 10**9+7\nfor i in range(1, m+1): fa.append(fa[-1] * i % P)\nfainv = [pow(fa[m], P-2, P)]\nfor i in range(1, m+1)[::-1]: fainv.append(fainv[-1] * i % P)\nfainv = fainv[::-1]\ndef C(a, b): return fa[a] * fainv[a-b] * fainv[b] % P\n\nN, K = list(map(int, input().split()))\npoK = [1]\nfor i in range(251): poK.append(poK[-1] * K % P)\npoK1 = [1]\nfor i in range(251): poK1.append(poK1[-1] * (K-1) % P)\n\ndpC = [[C(i, j) for j in range(i+1)] for i in range(N+1)]\ndpCpoK = [[C(i, j) * poK[j] % P for j in range(i+1)] for i in range(N+1)]\n\nDP = [[0] * (N+1) for _ in range(N+1)]\nDP[0][0] = 1\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        for k in range(j+1):\n            if k < j:\n                DP[i][j] = (DP[i][j] + DP[i-1][k] * dpCpoK[j][k]) % P\n            else:\n                DP[i][j] = (DP[i][j] + DP[i-1][k] * dpC[j][k] % P * (poK[k] - poK1[k])) % P\n    for j in range(1, N+1):\n        DP[i][j] = DP[i][j] * poK1[N-j] % P\n\nprint(DP[N][N])\n\n", "import sys\ninput = sys.stdin.readline\n \nn,k=map(int,input().split())\nmod=10**9+7\n \nFACT=[1]\nfor i in range(1,250+1):\n    FACT.append(FACT[-1]*i%mod)\n \nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(250,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n \nFACT_INV.reverse()\n \ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]%mod*FACT_INV[a-b]%mod\n    else:\n        return 0\n \nCOMBI=[[0]*251 for i in range(251)]\n \nfor a in range(251):\n    for b in range(a+1):\n        COMBI[a][b]=Combi(a,b)\n \nPOW_K=[1]\nPOW_K1=[1]\n \nfor i in range(n+1):\n    POW_K.append(POW_K[-1]*k%mod)\n    POW_K1.append(POW_K1[-1]*(k-1)%mod)   \n \nDP=[0]*(n+1)\nDP[0]=1\n\nPLUS=[[0]*(n+1) for i in range(n+1)]\n\nfor i in range(n+1):\n    for j in range(n+1):\n        if i==j:\n            PLUS[i][j]=(POW_K[i]*COMBI[n-i][j-i]*POW_K1[n-j]-POW_K1[n])%mod\n        else:\n            PLUS[i][j]=POW_K[i]*COMBI[n-i][j-i]*POW_K1[n-j]%mod\n \nfor yoko in range(n):\n    NDP=[0]*(n+1)\n    for i in range(n+1):\n        if DP[i]==0:\n            continue\n        for j in range(max(1,i),n+1):\n            NDP[j]=(NDP[j]+PLUS[i][j]*DP[i])%mod\n \n    DP=NDP\n    #print(DP)\n \nprint(DP[-1])", "def main():\n\n    # Basic construction\n    MOD = 10**9 + 7 # MOD\n    n, k = [int(c) for c in input().split()]\n    f = [[None for j in range(n+1)] for i in range(n+1)]\n    if k==1: return 1 # Edge case\n\n    # nCr\n    nCr = [[0 for j in range(i+1)] for i in range(n+1)]\n    nCr[0][0] = 1\n    for i in range(1, n+1):\n        nCr[i] = [1] + [(nCr[i-1][j] + nCr[i-1][j-1]) % MOD for j in range(1, i)] + [1]\n\n    # k^i, (k-1)^i\n    def powgen(base):\n        this = 1\n        while True:\n            yield this\n            this = this*base%MOD\n\n    kpowgen, k1powgen = powgen(k), powgen(k-1)\n    kpower = [next(kpowgen) for i in range(n+1)]\n    k1power = [next(k1powgen) for i in range(n+1)]\n    \n    # Edge DP\n    for r in range(1, n+1): f[r][0] = pow(kpower[n] - k1power[n], r, MOD)\n    for c in range(1, n+1): f[1][c] = kpower[n-c]\n\n    # DP\n    for r in range(2, n+1):\n        f[r] = [f[r][0]]\n        f[r] += [((kpower[n-c] - k1power[n-c]) * k1power[c] * f[r-1][c] + \n                kpower[n-c] * sum(k1power[c-c0] * nCr[c][c0] * f[r-1][c-c0] for c0 in range(1, c+1))) % MOD\n                for c in range(1, n+1)]\n    return f[n][n]\n\nprint(main())", "MOD = int(1e9+7)\n \ndef mult(l, r):\n\treturn (l*r)%MOD\n \ndef fast_exp(b, e):\n\tif e == 0:\n\t\treturn 1\n\tif e%2 == 1:\n\t\treturn mult(b, fast_exp(b, e-1))\n\telse:\n\t\tb2 = fast_exp(b, e//2)\n\t\treturn mult(b2, b2)\n \n[n, k] = [int(s) for s in input().split(\" \")]\nfact = (n+1)*[1]\nfor i in range(1, n+1):\n\tfact[i] = mult(i, fact[i-1])\n \n \nifact = (n+1)*[1]\nifact[n] = fast_exp(fact[n], MOD-2)\nfor i in reversed(range(1, n)):\n\tifact[i] = mult(i+1, ifact[i+1])\n \ndef binom(N, K):\n\treturn mult(mult(fact[N], ifact[K]), ifact[N-K])\n \ndef get(i, j):\n\tX = i*j\n\tY = (n-i)*j\n\tZ = (n-j)*i\n\ttot = X+Y+Z\n\tans = 0\n\tif (i+j)%2 == 0:\n\t\tans = 1\n\telse:\n\t\tans = (MOD - 1)\n\tans = mult(ans, binom(n, j))\n\tans = mult(ans, binom(n, i))\n\tans = mult(ans, fast_exp(k, n*n - tot))\n\tans = mult(ans, fast_exp(k-1, tot))\n\treturn ans\n \nans = 0\nfor i in range(0, n+1):\n\tfor j in range(0, n+1):\n\t\tans = (ans + get(i, j)) % MOD\n \nprint(ans)", "n, k = [int(item) for item in input().split()]\nMOD = 10**9 + 7\n\nMAX_N = 10**4 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nfor i in range(1, n+1):\n    fac[i] = fac[i-1] * (i) % MOD\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n\ndef mod_nCr(n, r):\n    if n == 0 and r == 0:\n        return 1\n    if n < r or n < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n\nans = 0\ntotal = pow(k, n*n, MOD)\nfor i in range(n+1):\n    for j in range(n+1):\n        not_one = (n - i + n - j) * n - ((n - i) * (n - j))\n        free = n * n - not_one\n        val = pow(-1, i+j) * mod_nCr(n, i) * mod_nCr(n, j) * pow(k-1, not_one, MOD) * pow(k, free, MOD)\n        ans += val\n        ans %= MOD\n\nprint(ans)", "n, k = [int(item) for item in input().split()]\nMOD = 10**9 + 7\nMAX_N = 10**4 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nfor i in range(1, n+1):\n    fac[i] = fac[i-1] * (i) % MOD\n    fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n\ndef mod_nCr(n, r):\n    if n == 0 and r == 0:\n        return 1\n    if n < r or n < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n\nans = 0\nfor i in range(n+1):\n    base = pow(k, n - i, MOD) * pow(k - 1, i, MOD) - pow(k - 1, n, MOD) + MOD\n    base % MOD\n    val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, MOD)\n    ans += val\n    ans %= MOD\n\nprint(ans)", "\ndef main():\n    n, k = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n    Comb = [None] * (n + 1)\n    dp = [[None] * (n + 1) for i in range(n+1)]\n\n    for i in range(1, n + 1):\n        Comb[i] = [1] + [(Comb[i-1][j-1] + Comb[i-1][j]) % MOD for j in range(1, i)] + [1]\n\n    def powgen(base):\n        cur = 1\n        while True:\n            yield cur\n            cur = cur * base % MOD\n\n    gen, gen_1 = powgen(k), powgen(k - 1)\n    kpower = [next(gen) for i in range(n + 1)]\n    k1power = [next(gen_1) for i in range(n + 1)]\n\n    dp[1][0] = (kpower[n] - k1power[n] + MOD) % MOD\n    for i in range(1, n+1): dp[1][i] = kpower[n-i]\n\n    for r in range(2, n + 1): # row remaining\n        # c means col incompleted\n        dp[r] = [(dp[r-1][c] * k1power[c] * (kpower[n-c]-k1power[n-c]) + \n            kpower[n-c] * sum([dp[r-1][c-i] * Comb[c][i] * k1power[c-i] for i in range(1, c+1)])) % MOD\n            for c in range(n+1)]\n    # input 250 1000000000\n    return dp[n][n]\n\nprint(main())\n\n\n", "\ndef main():\n    n, k = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n    Comb = [None] * (n + 1)\n    dp = [[None] * (n + 1) for i in range(n+1)]\n\n    for i in range(1, n + 1):\n        Comb[i] = [1] + [(Comb[i-1][j-1] + Comb[i-1][j]) % MOD for j in range(1, i)] + [1]\n\n    def powgen(base):\n        cur = 1\n        while True:\n            yield cur\n            cur = cur * base % MOD\n\n    gen, gen_1 = powgen(k), powgen(k - 1)\n    kpower = [next(gen) for i in range(n + 1)]\n    k1power = [next(gen_1) for i in range(n + 1)]\n\n    dp[1][0] = (kpower[n] - k1power[n] + MOD) % MOD\n    for i in range(1, n+1): dp[1][i] = kpower[n-i]\n\n    for r in range(2, n + 1): # row remaining\n        # c means col incompleted\n        for c in range(n+1): \n            dp[r][c] = (dp[r-1][c] * k1power[c] * (kpower[n-c]-k1power[n-c]) + \\\n                kpower[n-c] * sum([dp[r-1][c-i] * Comb[c][i] * k1power[c-i] for i in range(1, c+1)])) % MOD\n            \n    # input 250 1000000000\n    return dp[n][n]\n\nprint(main())\n\n", "n, k = [int(item) for item in input().split()]\nMOD = 10**9 + 7\nMAX_N = 10**4 \n \nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nfor i in range(1, n+1):\n    fac[i] = fac[i-1] * (i) % MOD\n    fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n \ndef mod_nCr(n, r):\n    if n == 0 and r == 0:\n        return 1\n    if n < r or n < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n \nans = 0\nfor i in range(n+1):\n    base = pow(k, n - i, MOD) * pow(k - 1, i, MOD) - pow(k - 1, n, MOD) + MOD\n    base % MOD\n    val = pow(-1, i) * mod_nCr(n, i) * pow(base, n, MOD)\n    ans += val\n    ans %= MOD\n \nprint(ans)"]
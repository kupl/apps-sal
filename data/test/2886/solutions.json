["import sys\ns = input()\nl = len(s)\nif l == 2:\n    if s[0] == s[1]:\n        print(1, 2)\n        return\n    else:\n        print('-1 -1')\n        return\nfor i in range(l - 2):\n    s1 = s[i]\n    s2 = s[i + 1]\n    s3 = s[i + 2]\n    if s1 == s2 or s1 == s3 or s2 == s3:\n        print(i + 1, i + 3)\n        return\nprint('-1 -1')", "s = str(input())\n\n\na, b = 0, 0\n\nfor i in range(len(s)-1):\n    if s[i] == s[i+1]:\n        a, b = i+1, i+2\n        break\n    elif i < len(s)-2:\n        if s[i] == s[i+2]:\n            a, b = i+1, i+3\n            break\n        \nif a == 0:\n    print(-1, -1)\nelse:\n    print(a, b)", "s = input()\n\nn = len(s)\n\nfor i in range(n - 1):\n    if s[i] == s[i + 1]:\n        print((i + 1, i + 2))\n        return\n\nfor i in range(n - 2):\n    if s[i] == s[i + 2]:\n        print((i + 1, i + 3))\n        return\n\nprint((-1, -1))\n", "\n# -*- coding: UTF-8 -*-\n\nimport sys\nimport re\n\n\ndef std_in():\n    return sys.stdin.readline().strip()\n\n\ndef first_match_of_pattern(text, pattern):\n    if type(text) != str:\n        text = str(text)\n\n    re_patter = re.compile(pattern)\n    ans = re_patter.findall(text)\n    if ans:\n        return ans[0]\n    return \"\"\n\n\ndef _main():\n    s = std_in()\n    az = [chr(i) for i in range(97, 97+26)]\n    for c in az:\n        p = r\"[\" + c + r\"][a-z][\" + c + \"]\"\n        mt = first_match_of_pattern(s, p)\n        if mt != \"\":\n            first = s.find(mt) + 1\n            end = first + len(mt) - 1\n            print((first, end))\n            break\n\n        p = r\"[\" + c + r\"][\" + c + \"]\"\n        mt = first_match_of_pattern(s, p)\n        if mt != \"\":\n            first = s.find(mt) + 1\n            end = first + len(mt) - 1\n            print((first, end))\n            break\n    else:\n        print((-1, -1))\n\n\ndef __starting_point():\n    _main()\n\n__starting_point()", "from collections import Counter\ns = input()\nn = len(s)\n\nfor i in range(n):\n    if n == 2:\n        if s[0] == s[1]:\n            print(1, 2)\n            return\n    if i == n - 2:\n        break\n    c = Counter(s[i:i + 3])\n    v = c.most_common()\n    if v[0][1] * 2 > len(s[i:i + 3]):\n        print(i + 1, i + 3)\n        return\n\nprint(-1, -1)", "import sys\nimport numpy as np\nfrom heapq import heappush, heappop \nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\nfrom collections import deque, Counter, defaultdict\nfrom itertools import combinations, product\nimport string \ninf = float('inf')\nMOD = 10**9+7\n# MOD = 998244353\n\n\nclass NumberTheory():\n  def __init__(self, n=2*10**6, numpy=True):\n    self.n = n\n    self.np_flg = numpy \n    self.is_prime_number, self.prime_numbers = self.sieve_of_eratosthenes(n)\n  \n  def sieve_of_eratosthenes(self, n):\n    if self.np_flg:\n      sieve = np.ones(n+1, dtype=np.int64); sieve[:2] = 0\n      for i in range(2, int(n**.5)+1):\n        if sieve[i]: sieve[i*2::i] = 0\n      prime_numbers = np.flatnonzero(sieve)\n    else:\n      sieve = [1] * (n+1); sieve[0] = sieve[1] = 0\n      for i in range(2, int(n**.5)+1):\n        if not sieve[i]: continue\n        for j in range(i*2, n+1, i): sieve[j] = 0\n      prime_numbers = [i for i in range(2, n+1) if sieve[i]]\n    return sieve, prime_numbers \n\n  def prime_factorize(self, n):\n    res = dict()\n    if n < 2: return res\n    border = int(n**.5)\n    for p in self.prime_numbers:\n      if p > border: break\n      while n % p == 0: res[p] = res.get(p, 0)+1; n //= p\n      if n == 1: return res\n    res[n] = 1; return res\n\n  def prime_factorize_factorial(self, n):\n    res = dict()\n    for i in range(2, n+1):\n      for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c\n    return res\n  \n  @staticmethod\n  def gcd(a, b): return gcd(b, a%b) if b else abs(a)\n\n  @staticmethod\n  def lcm(a, b): return abs(a // gcd(a, b) * b)\n\n  @staticmethod\n  def find_divisors(n):\n    divisors = []\n    for i in range(1, int(n**.5)+1):\n      if n%i: continue\n      divisors.append(i)\n      j = n // i\n      if j != i: divisors.append(j)\n    return divisors\n  \n  @staticmethod\n  def base_convert(n, b):\n    if not n: return [0]\n    res = []\n    while n:\n      n, r = divmod(n, b)\n      if r < 0: n += 1; r -= b\n      res.append(r)\n    return res\n\n\nclass UnionFind():\n  def __init__(self, n=10**6):\n    self.root = list(range(n))\n    self.height = [0] * n \n    self.size = [1] * n \n  \n  def find_root(self, u):\n    if self.root[u] == u: return u\n    self.root[u] = self.find_root(self.root[u])\n    return self.root[u]\n  \n  def unite(self, u, v):\n    ru = self.find_root(u)\n    rv = self.find_root(v)\n    if ru == rv: return \n    hu = self.height[ru]\n    hv = self.height[rv]\n    if hu >= hv:\n      self.root[rv] = ru \n      self.size[ru] += self.size[rv]\n      self.height[ru] = max(hu, hv+1)\n    else:\n      self.root[ru] = rv \n      self.size[rv] += self.size[ru]\n\n\nclass Combinatorics():\n  def __init__(self, N=10**9, n=10**6, mod=10**9+7, numpy=True):\n    self.mod = mod\n    self.nCr = dict()\n    self.np_flg=numpy\n    self.make_mod_tables(N, n)\n\n  sys.setrecursionlimit(10**6)\n  def choose(self, n, r, mod=None): # no mod, or mod \u2260 prime\n    if r > n or r < 0: return 0\n    if r == 0: return 1\n    if (n, r) in self.nCr: return self.nCr[(n, r)]\n    if not mod:\n      self.nCr[(n, r)] = (self.choose(n-1, r) + self.choose(n-1, r-1))\n    else:\n      self.nCr[(n, r)] = (self.choose(n-1, r, mod) + self.choose(n-1, r-1, mod)) % mod\n    return self.nCr[(n,r)]\n  \n  def cumprod(self, a):\n    p = self.mod\n    l = len(a); sql = int(np.sqrt(l)+1)\n    a = np.resize(a, sql**2).reshape(sql, sql)\n    for i in range(sql-1): a[:, i+1] *= a[:, i]; a[:, i+1] %= p\n    for i in range(sql-1): a[i+1] *= a[i, -1]; a[i+1] %= p\n    return np.ravel(a)[:l]\n\n  def make_mod_tables(self, N, n):\n    p = self.mod\n    if self.np_flg:\n      fac = np.arange(n+1); fac[0] = 1; fac = self.cumprod(fac)\n      ifac = np.arange(n+1, 0, -1); ifac[0] = pow(int(fac[-1]), p-2, p)\n      ifac = self.cumprod(ifac)[n::-1]\n      n_choose = np.arange(N+1, N-n, -1); n_choose[0] = 1;\n      n_choose[1:] = self.cumprod(n_choose[1:])*ifac[1:n+1]%p\n    else:\n      fac = [None]*(n+1); fac[0] = 1\n      for i in range(n): fac[i+1] = fac[i]*(i+1)%p\n      ifac = [None]*(n+1); ifac[n] = pow(fac[n], p-2, p)\n      for i in range(n, 0, -1): ifac[i-1] = ifac[i]*i%p\n      n_choose = [None] * (n+1); n_choose[0] = 1\n      for i in range(n): n_choose[i+1] = n_choose[i]*(N-i)%p\n      for i in range(n+1): n_choose[i] = n_choose[i]*ifac[i]%p\n    self.fac, self.ifac, self.mod_n_choose = fac, ifac, n_choose\n  \n  def mod_choose(self, n, r):\n    return self.fac[n]*self.ifac[r]%self.mod*self.ifac[n-r]%self.mod\n\n\ndef z_algorithm(s):\n  n = len(s)\n  a = [0] * n; a[0] = n\n  l = r = -1\n  for i in range(1, n):\n    if r >= i: a[i] = min(a[i-l], r-i)\n    while i + a[i] < n and s[i+a[i]] == s[a[i]]: a[i] += 1\n    if i+a[i] >= r: l, r = i, i+a[i]\n  return a\n\n\nclass ABC001():\n  def A():\n    h1, h2 = map(int, sys.stdin.read().split())\n    print(h1-h2)\n\n  def B(): pass\n  def C(): pass \n  def D(): pass \n\n\nclass ABC002():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(max(x, y))\n\n  def B():\n    vowels = set('aeiou')\n    s = sys.stdin.readline().rstrip() \n    t = ''\n    for c in s:\n      if c in vowels: continue \n      t += c \n    print(t)\n\n  def C():\n    *coords, = map(int, sys.stdin.readline().split())\n    def triangle_area(x0, y0, x1, y1, x2, y2):\n      x1 -= x0; x2 -= x0; y1 -= y0; y2 -= y0;\n      return abs(x1*y2 - x2*y1) / 2\n    print(triangle_area(*coords))\n\n  def D():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = set()\n    for _ in range(m):\n      x, y = map(int, sys.stdin.readline().split())\n      x -= 1; y -= 1\n      edges.add((x, y))\n    cand = []\n    for i in range(1, 1<<n):\n      s = [j for j in range(n) if i>>j & 1]\n      for x, y in combinations(s, 2):\n        if (x, y) not in edges: break\n      else:\n        cand.append(len(s))\n    print(max(cand))\n\n\nclass ABC003():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)*5000)\n\n  def B():\n    atcoder = set('atcoder')\n    s, t = sys.stdin.read().split()\n    for i in range(len(s)):\n      if s[i] == t[i]: continue\n      if s[i] == '@' and t[i] in atcoder: continue \n      if t[i] == '@' and s[i] in atcoder: continue\n      print('You will lose')\n      return \n    print('You can win')\n\n  def C():\n    n, k, *r = map(int, sys.stdin.read().split())\n    res = 0\n    for x in sorted(r)[-k:]:\n      res = (res+x) / 2\n    print(res)\n\n  def D(): pass \n\n\nclass ABC004():\n  def A():\n    print(int(sys.stdin.readline().rstrip())*2)\n\n  def B():\n    c = [sys.stdin.readline().rstrip() for _ in range(4)]\n    for l in c[::-1]:\n      print(l[::-1])\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n %= 30\n    res = list(range(1, 7))\n    for i in range(n):\n      i %= 5\n      res[i], res[i+1] = res[i+1], res[i]\n    print(''.join(map(str, res)))\n\n  def D(): pass \n\n\nclass ABC005():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(y//x)\n\n  def B():\n    n, *t = map(int, sys.stdin.read().split())\n    print(min(t))\n\n  def C():\n    t = int(sys.stdin.readline().rstrip())\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    m = int(sys.stdin.readline().rstrip())\n    b = [int(x) for x in sys.stdin.readline().split()]\n    i = 0\n    for p in b:\n      if i == n: print('no'); return \n      while p-a[i] > t:\n        i += 1\n        if i == n: print('no'); return \n      if a[i] > p: print('no'); return \n      i += 1\n    print('yes')\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    d = np.array([sys.stdin.readline().split() for _ in range(n)], np.int64)\n    s = d.cumsum(axis=0).cumsum(axis=1)\n    s = np.pad(s, 1)\n    max_del = np.zeros((n+1, n+1), dtype=np.int64)\n    for y in range(1, n+1):\n      for x in range(1, n+1):\n        max_del[y, x] = np.amax(s[y:n+1, x:n+1] - s[0:n-y+1, x:n+1] - s[y:n+1, 0:n-x+1] + s[0:n-y+1, 0:n-x+1])\n    res = np.arange(n**2+1)[:, None]\n    i = np.arange(1, n+1)\n    res = max_del[i, np.minimum(res//i, n)].max(axis=1)\n    q = int(sys.stdin.readline().rstrip())\n    p = np.array(sys.stdin.read().split(), dtype=np.int64)\n    print(*res[p], sep='\\n')\n\n\nclass ABC006():\n  def A():\n    n = sys.stdin.readline().rstrip()\n    if '3' in n: print('YES')\n    elif int(n)%3 == 0: print('YES')\n    else: print('NO')\n\n  def B():\n    mod = 10007\n    t = [0, 0, 1]\n    for _ in range(1001001):\n      t.append(t[-1]+t[-2]+t[-3]); t[-1] %= mod\n    n = int(sys.stdin.readline().rstrip())\n    print(t[n-1])\n    \n  def C():\n    n, m = map(int, sys.stdin.readline().split())\n    cnt = [0, 0, 0]\n    if m == 1: cnt = [-1, -1, -1]\n    else:\n      if m & 1: m -= 3; cnt[1] += 1; n -= 1\n      cnt[2] = m//2 - n \n      cnt[0] = n - cnt[2]\n    if cnt[0]<0 or cnt[1]<0 or cnt[2]<0: print(-1, -1, -1)\n    else: print(*cnt, sep=' ')\n      \n  def D():\n    n, *c = map(int, sys.stdin.read().split())\n    lis = [inf]*n \n    for x in c: lis[bi_l(lis, x)] = x \n    print(n - bi_l(lis, inf))\n\n\nclass ABC007():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n-1)\n\n  def B():\n    s = sys.stdin.readline().rstrip()\n    if s == 'a': print(-1)\n    else: print('a')\n\n  def C():\n    r, c = map(int, sys.stdin.readline().split())\n    sy, sx = map(int, sys.stdin.readline().split())\n    gy, gx = map(int, sys.stdin.readline().split())\n    sy -= 1; sx -=1; gy -= 1; gx -= 1\n    maze = [sys.stdin.readline().rstrip() for _ in range(r)]\n    queue = deque([(sy, sx)])\n    dist = np.full((r, c), np.inf); dist[sy, sx] = 0\n    while queue:\n      y, x = queue.popleft()\n      for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        i += y; j += x\n        if maze[i][j] == '#' or dist[i, j] != np.inf: continue \n        dist[i, j] = dist[y, x] + 1\n        queue.append((i, j))\n    print(int(dist[gy, gx]))\n  \n  def D(): pass \n\n\nclass ABC008():\n  def A():\n    s, t = map(int, sys.stdin.readline().split())\n    print(t-s+1)\n\n  def B():\n    n, *s = sys.stdin.read().split()\n    res = defaultdict(int)\n    for name in s: res[name] += 1\n    print(sorted(res.items(), key=lambda x: x[1])[-1][0])\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    a = np.array(a)\n    c = n - np.count_nonzero(a[:, None]%a, axis=1)\n    print(np.sum((c+1)//2/c))\n  \n  def D(): pass\n\nclass ABC009():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)//2)\n\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    print(sorted(set(a))[-2])\n    \n  def C():\n    n, k = map(int, sys.stdin.readline().split())\n    s = list(sys.stdin.readline().rstrip())\n    cost = [1]*n\n    r = k\n    for i in range(n-1):\n      q = []\n      for j in range(i+1, n):\n        if s[j] < s[i] and cost[i]+cost[j] <= r:\n          heappush(q, (s[j], cost[i]+cost[j], -j))\n      if not q: continue\n      _, c, j = heappop(q); j = -j \n      s[i], s[j] = s[j], s[i]\n      r -= c \n      cost[i] = cost[j] = 0\n    print(''.join(s))\n      \n  def D(): pass \n\n\nclass ABC010():\n  def A():\n    print(sys.stdin.readline().rstrip()+'pp')\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    tot = 0\n    for x in a:\n      c = 0 \n      while x%2==0 or x%3==2:\n        x -= 1\n        c += 1\n      tot += c\n    print(tot)\n\n  def C():\n    sx, sy, gx, gy, t, v, n, *xy = map(int, sys.stdin.read().split())\n    x, y = np.array(xy).reshape(-1, 2).T\n    def dist(x1, y1, x2, y2):\n      return np.sqrt((x2-x1)**2 + (y2-y1)**2)\n    ans = 'YES' if (dist(sx, sy, x, y)+dist(x, y, gx, gy) <= v*t).any() else 'NO'\n    print(ans)\n\n  def D(): pass \n\nclass ABC011():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n%12+1)\n\n  def B():\n    s = sys.stdin.readline().rstrip() \n    print(s[0].upper()+s[1:].lower())\n\n  def C():\n    n, *ng = map(int, sys.stdin.read().split())\n    ng = set(ng)\n    if n in ng: print('NO')\n    else:\n      r = 100\n      while n > 0:\n        if r == 0: print('NO'); return\n        for i in range(3, 0, -1):\n          if (n-i) in ng: continue \n          n -= i\n          r -= 1\n          break \n        else: print('NO'); return \n      print('YES')\n\n  def D(): pass \n\n\nclass ABC041():\n  def A():\n    s, i = sys.stdin.read().split()\n    i = int(i)\n    print(s[i-1])\n\n  def B():\n    a, b, c = map(int, sys.stdin.readline().split())\n    ans = a * b % MOD * c % MOD \n    print(ans)\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    for i, h in sorted(enumerate(a), key=lambda x: -x[1]):\n      print(i+1)\n\n  def D():\n    n, m, *xy = map(int, sys.stdin.read().split())\n    *xy, = zip(*[iter(xy)]*2)\n    edges = [0] * n \n    for x, y in xy:\n      x -= 1; y -= 1\n      edges[x] |= 1<<y\n    comb = [None] * (1<<n); comb[0] = 1\n    def count(edges, bit):\n      if comb[bit] is not None: return comb[bit]\n      comb[bit] = 0\n      for i in range(n):\n        if (bit>>i) & 1 and not edges[i]:\n          nxt_bit = bit & ~(1<<i)\n          nxt_edges = edges.copy() \n          for j in range(n):\n            nxt_edges[j] &= ~(1<<i)\n          cnt = count(nxt_edges, nxt_bit)\n          comb[bit] += cnt\n      return comb[bit]\n    print(count(edges, (1<<n)-1))\n\n\nclass ABC042():\n  def A():\n    a = [int(x) for x in sys.stdin.readline().split()]\n    c = Counter(a)\n    print('YES' if c[5]==2 and c[7]==1 else 'NO')\n\n  def B():\n    n, l, *s = sys.stdin.read().split()\n    print(''.join(sorted(s)))\n\n  def C():\n    n, k, *d = sys.stdin.read().split()\n    l = len(n)\n    ok = sorted(set(string.digits)-set(d))\n    cand = [int(''.join(p)) for p in product(ok, repeat=l)] + [int(min(x for x in ok if x > '0')+min(ok)*l)]\n    print(cand[bi_l(cand, int(n))])\n\n  def D():\n    h, w, a, b = map(int, sys.stdin.read().split())\n    combinatorics = Combinatorics(n=2*10**5, mod=MOD, numpy=True)\n    tot = combinatorics.mod_choose(h+w-2, h-1)\n    i = np.arange(h-a, h)\n    ng = np.sum(combinatorics.mod_choose(i+b-1, i) * combinatorics.mod_choose(h-i+w-b-2, h-1-i) % MOD)\n    tot -= ng; tot %= MOD\n    print(tot)\n\n\nclass ABC043():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((1+n)*n//2)\n\n  def B():\n    s = sys.stdin.readline().rstrip()\n    t = ''\n    for c in s:\n      if c == 'B': t = t[:-1]\n      else: t += c\n    print(t)\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    a = np.array(a)\n    x = np.around(a.sum()/n).astype(int)\n    print(np.sum((a-x)**2))\n\n  def D():\n    s = sys.stdin.readline().rstrip()\n    n = len(s)\n    for i in range(n-1):\n      if s[i] == s[i+1]:\n        print(i+1, i+2); return \n    for i in range(n-2):\n      if s[i] == s[i+2]:\n        print(i+1, i+3); return \n    print(-1, -1)\n\n\nclass ABC170():\n  def A():\n    x = [int(x) for x in sys.stdin.readline().split()]\n    for i in range(5):\n      if x[i] != i+1:\n        print(i+1)\n        break\n\n  def B():\n    x, y = map(int, sys.stdin.readline().split())\n    print('Yes' if 2*x <= y <= 4*x and y%2 == 0 else 'No')\n      \n  def C():\n    x, n, *p = map(int, sys.stdin.read().split())\n    a = list(set(range(102)) - set(p))\n    a = [(abs(y-x), y) for y in a]\n    print(sorted(a)[0][1])\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    cand = set(a)\n    cnt = 0\n    for x, c in sorted(Counter(a).items()):\n      cnt += c == 1 and x in cand\n      cand -= set(range(x*2, 10**6+1, x))\n    print(cnt)\n\n  def E():\n    n, q = map(int, sys.stdin.readline().split())\n    queue = [] \n    num_kindergarten = 2*10**5\n    queue_kindergarten = [[] for _ in range(num_kindergarten)]\n    highest_kindergarten = [None] * num_kindergarten\n    where = [None] * n\n    rate = [None] * n\n\n    def entry(i, k):\n      where[i] = k\n      while queue_kindergarten[k]:\n        r, j = heappop(queue_kindergarten[k])\n        if where[j] != k or j == i: continue \n        if rate[i] >= -r:\n          highest_kindergarten[k] = rate[i]\n          heappush(queue, (rate[i], k, i))\n        heappush(queue_kindergarten[k], (r, j))\n        break\n      else:\n        highest_kindergarten[k] = rate[i]\n        heappush(queue, (rate[i], k, i))\n      heappush(queue_kindergarten[k], (-rate[i], i))\n\n    def transfer(i, k):\n      now = where[i]\n      while queue_kindergarten[now]:\n        r, j = heappop(queue_kindergarten[now])\n        if where[j] != now or j == i: continue\n        if highest_kindergarten[now] != -r:\n          highest_kindergarten[now] = -r\n          heappush(queue, (-r, now, j))\n        heappush(queue_kindergarten[now], (r, j))\n        break\n      else:\n        highest_kindergarten[now] = None\n      entry(i, k)\n\n    def inquire():\n      while True:\n        r, k, i = heappop(queue)\n        if where[i] != k or r != highest_kindergarten[k]: continue \n        heappush(queue, (r, k, i))\n        return r\n\n    for i in range(n):\n      a, b = map(int, sys.stdin.readline().split())\n      rate[i] = a \n      entry(i, b-1)\n    for _ in range(q):\n      c, d = map(int, sys.stdin.readline().split())\n      transfer(c-1, d-1)\n      print(inquire())\n    \n  def F(): pass \n\n\nclass ABC171():\n  def A():\n    c = sys.stdin.readline().rstrip()\n    print('A' if c < 'a' else 'a')\n\n  def B():\n    n, k, *p = map(int, sys.stdin.read().split())\n    print(sum(sorted(p)[:k]))\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n -= 1\n    l = 1\n    while True:\n      if n < pow(26, l):\n        break \n      n -= pow(26, l)\n      l += 1\n    res = ''.join([chr(ord('a')+d) for d in NumberTheory.base_convert(n, 26)][::-1])\n    res = 'a'*(l-len(res)) + res\n    print(res)\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    s = sum(a)\n    cnt = Counter(a)\n    q = int(sys.stdin.readline().rstrip())\n    for _ in range(q):\n      b, c = map(int, sys.stdin.readline().split())\n      s += (c-b)*cnt[b]\n      print(s)\n      cnt[c] += cnt[b]; cnt[b] = 0\n\n  def E():\n    n, *a = map(int, sys.stdin.read().split())\n    s = 0\n    for x in a: s ^= x \n    b = map(lambda x: x^s, a)\n    print(*b, sep=' ')\n\n  def F(): pass \n\n\nclass ABC172():\n  def A(): pass\n  def B(): pass\n  def C(): pass \n  def D(): pass \n  def E(): pass \n  def F(): pass \n\n\nclass ABC173():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    charge = (n+999)//1000 * 1000 - n\n    print(charge)\n\n  def B():\n    n, *s = sys.stdin.read().split() \n    c = Counter(s)\n    for v in 'AC, WA, TLE, RE'.split(', '):\n      print(f'{v} x {c[v]}')\n\n  def C():\n    h, w, k = map(int, sys.stdin.readline().split())\n    c = [sys.stdin.readline().rstrip() for _ in range(h)]\n    tot = 0\n    for i in range(1<<h):\n      for j in range(1<<w):\n        cnt = 0\n        for y in range(h):\n          for x in range(w):\n            if i>>y & 1 or j>>x & 1:\n              continue \n            cnt += c[y][x] ==  '#'\n        tot += cnt == k\n    print(tot)\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    a.sort(reverse=True)\n    res = a[0] + sum(a[1:1+(n-2)//2])*2 + a[1+(n-2)//2]*(n & 1)\n    print(res)\n\n  def E():\n    MOD = 10**9+7\n    n, k, *a = map(int, sys.stdin.read().split())\n    minus = [x for x in a if x < 0]\n    plus = [x for x in a if x > 0]\n    if len(plus) + len(minus)//2*2 >= k: # plus \n      *minus, = map(abs, minus)\n      minus.sort(reverse=True)\n      plus.sort(reverse=True)\n      cand = []\n      if len(minus)&1: minus = minus[:-1]\n      for i in range(0, len(minus)-1, 2):\n        cand.append(minus[i]*minus[i+1]%MOD)\n      if k & 1:\n        res = plus[0]\n        plus = plus[1:]\n      else:\n        res = 1\n      if len(plus)&1: plus = plus[:-1]\n      for i in range(0, len(plus)-1, 2):\n        cand.append(plus[i]*plus[i+1]%MOD)\n      cand.sort(reverse=True)\n      for x in cand[:k//2]:\n        res *= x\n        res %= MOD \n      print(res)\n    elif 0 in a:\n      print(0)\n    else:\n      cand = sorted(map(abs, a))\n      res = 1\n      for i in range(k):\n        res *= cand[i]\n        res %= MOD\n      res = MOD - res\n      print(res)\n      pass\n  \n  def F(): pass \n\n\ndef __starting_point():\n  ABC043.D()\n__starting_point()", "S = input()\nfor i in range(26):\n    c = chr(i + 97)\n    prev = -3\n    for j in range(len(S)):\n        if S[j] == c:\n            if j - prev <= 2:\n                print(prev + 1, j + 1)\n                break\n            prev = j\n    else:\n        continue\n    break\nelse:\n    print(-1, -1)", "S = input()\nN = len(S)\n\nif N == 2 and S[0] == S[1]:\n  print(1, 2)\n  return\n\nfor i in range(N-2):\n  if len(set(S[i:i+3])) <= 2:\n    print(i+1, i+3)\n    return\n\nprint(-1, -1)", "S=input()\nN=len(S)\nfor i in range(N-1):\n  if S[i]==S[i+1]:\n    print(i+1,i+2)\n    return\n  if i!=N-2:\n    if S[i]==S[i+2]:\n      print(i+1,i+3)\n      return\nprint(-1,-1)", "s = input()\nfor i in range(len(s)-1):\n    if s[i:i+3].count(s[i]) >=2:\n        print(\"{} {}\".format(i+1, min(len(s), i+3)))\n        break\nelse:\n    print(\"-1 -1\")", "s = input()\n\nif len(s) != 2:\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n            print(i + 1, i + 3)\n            return\n\nelse:\n    if s[0] == s[1]:\n        print(1, 2)\n        return\n\n\nprint(-1, -1)", "S = input()\nN = len(S)\nS = \"!\" + S + \"!\"\nif N == 2:\n    if S[1] == S[2]:\n        print(\"1 2\")\n    else:\n        print(\"-1 -1\")\n    return\nfor i in range(1, N+1, 1):\n    PrevAl = S[i-1]\n    NowAl = S[i]\n    NextAl = S[i+1]\n    if PrevAl == NowAl or NowAl == NextAl or PrevAl == NextAl:\n        AnsL = i-1\n        AnsR = i+1\n        if AnsL == 0:\n            AnsL = 1\n        print((AnsL, AnsR))\n        return\nprint(\"-1 -1\")\n", "import os, sys, re, math, queue\n\nS = input()\n\nal = 'abcdefghijklmnopqrstuvwxyz'\n\ndef doit():\n\tfor a in al:\n\t\tm = re.search(a+'{2,}', S)\n\t\tif m:\n\t\t\treturn str(m.start()+1) + ' ' + str(m.end())\n\t\tm = re.search(a+'[^'+a+']'+a, S)\n\t\tif m:\n\t\t\treturn str(m.start()+1) + ' ' + str(m.end())\n\t\n\treturn '-1 -1'\n\nprint(doit())", "s = input()\n\nfor i in range(len(s) - 1):\n    if s[i] == s[i + 1]:\n        print(*[i + 1, i + 2])\n        return\nfor i in range(len(s) - 2):\n    if s[i] == s[i + 2]:\n        print(*[i + 1, i + 3])\n        return\nprint(*[-1, -1])", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\n\ns = input()\nidxs = [[] for i in range(26)]\ndef wid(w):\n    return ord(w)-ord(\"a\")\nfor i in range(len(s)):\n    w = s[i]\n    idxs[wid(w)].append(i)\na=-1\nb=-1\nfor i in range(26):\n    if len(idxs[i])>=2:\n        prev = idxs[i][0]\n        for nex in idxs[i]:\n            d = nex-prev\n            if 1<=d<=2:\n                a=prev+1\n                b=nex+1\n                break\n            prev=nex\nprint(a,b)\n", "\ns = input()\n\nn = len(s)\nfor i in range(n):\n  if i+1 < n and s[i] == s[i+1]:\n    print(i+1, i+2)\n    return\n  if i+2 < n and s[i] == s[i+2]:\n    print(i+1, i+3)\n    return\n    \nprint(-1, -1)", "import sys\nimport collections\ninput = sys.stdin.readline\n\ndef main():\n    S = input().strip()\n\n    a = [[] for _ in range(26)]\n\n    for i, s in enumerate(S):\n        a[ord(s) - ord('a')].append(i)\n\n    ans = []\n    f = False\n    for i in range(26):\n        for j in range(len(a[i]) - 1):\n            if (a[i][j + 1] - a[i][j] + 1) < 4:\n                ans.append(a[i][j])\n                ans.append(a[i][j + 1])\n                f = True\n                break\n        if f:\n            break\n\n    if f:\n        print((ans[0] + 1, ans[1] + 1))\n    else:\n        print((-1, -1))\n\n\n\n\n\n\n\n    \n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "S=input()\nn=len(S)\n \nfor i in range(n-1):\n  if S[i] == S[i+1]:\n    print(i+1, i+2)\n    return\nfor i in range(n-2):\n  if S[i] == S[i+2]:\n    print(i+1, i+3)\n    return\n\nprint(-1, -1)", "import sys\ns = input()\nl = len(s)\nif l == 2:\n    if s[0] == s[1]:\n        print(1, 2)\n        return\n    else:\n        print('-1 -1')\n        return\nfor i in range(l - 2):\n    s1 = s[i]\n    s2 = s[i + 1]\n    s3 = s[i + 2]\n    if s1 == s2 or s1 == s3 or s2 == s3:\n        print(i + 1, i + 3)\n        return\nprint('-1 -1')", "s = input()\nn = len(s)\n\nfor i in range(n-1):\n    if s[i] == s[i+1]:\n        print((i+1,i+2))\n        return\n\nfor i in range(n-2):\n    if s[i] == s[i+2]:\n        print((i+1,i+3))\n        return\n\nprint((-1,-1))\n", "s=input()+\"_\"\nx=y=-2\nfor i in range(len(s)-2):\n  if s[i]==s[i+1]:\n    x=i;y=i+1\n  if s[i]==s[i+2]:\n    x=i;y=i+2\nprint(x+1,y+1)", "s = input()\nn = len(s)\ns = s+\"0\"\n\nans1,ans2 = -1,-1\n\nfor i in range(n-1):\n    if s[i] == s[i+1]:\n        ans1,ans2 = i+1,i+2\n        break\n\n    if s[i] == s[i+2]:\n        ans1,ans2 = i+1,i+3\n        break\n\nprint(ans1,ans2)", "# -*- coding: utf-8 -*-\n\nimport io\nimport sys\nimport math\n\nCASES = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef format_multi_line_answer(lst):\n    ans = \"\"\n    ans += f\"{len(lst)}\\n\"  # Line count\n    for y in lst:\n        ans += f\"{y}\\n\"\n    return ans\n\n# \u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u6587\u5b57\u5217\u306b\u306f\u3001\"aa\"\u307e\u305f\u306f\"axa\"\u306e\u3088\u3046\u306a\u90e8\u5206\u304c\u73fe\u308c\u308b\u3002\ndef is_unballance(s):\n    if len(s) == 2 and s[0] == s[1]:\n        return True\n    if len(s) == 3 and s[0] == s[2]:\n        return True\n    return False\n\ndef solve(s):\n    # implement process\n    ans_l = []\n    has_unbalance = False\n    a,b = -1,-1\n    for c in CASES:\n        i = s.find(c)\n        ii = s.find(c,i+1)\n        while ii != -1:\n            if ii - i < 3 and is_unballance(s[i:ii+1]):\n                a,b = i+1,ii+1\n                has_unbalance = True\n                break\n            i = ii\n            ii = s.find(c,i+1)\n\n        if has_unbalance:\n            break\n    return f\"{a} {b}\"\n\ndef main():\n    # input\n    s = input()\n    # process\n    ans = str( solve(s) )\n    \n    # output\n    print(ans)\n    return ans\n        \n### DEBUG I/O ###\n_DEB = 0   # 1:ON / 0:OFF\n\n_INPUT = \"\"\"\\\nabcaxa\n\"\"\"\n_EXPECTED = \"\"\"\\\n2 5\n\"\"\"\n\ndef logd(str):\n    \"\"\"usage:\n    if _DEB: logd(f\"{str}\")\n    \"\"\"\n    if _DEB: print(f\"[deb] {str}\")\n\n### MAIN ###\ndef __starting_point():\n    if _DEB:\n        sys.stdin = io.StringIO(_INPUT)\n        print(\"!! Debug Mode !!\")\n\n    ans = main()\n\n    if _DEB:\n        print()\n        if _EXPECTED.strip() == ans.strip(): print(\"!! Success !!\")\n        else: print(f\"!! Failed... !!\\nANSWER:   {ans}\\nExpected: {_EXPECTED}\")\n__starting_point()", "s = input()\nx = len(s)\nfor i in range(x-2):\n    n = s[i:i+3]\n    m = list(set(n))\n    if len(m) == 2:\n        print(i+1,i+3)\n        return\nif x == 2:\n    if s[0] == s[1]:\n        print(1,2)\n        return\nprint(-1,-1)", "s = str(input())\nflag = 0\nfor i in range(len(s)-1):\n  if s[i]==s[i+1]:\n    print(str(i+1) + \" \" + str(i+2))\n    flag= 1\n    break\nif flag==0:\n  for i in range(len(s)-2):\n    if s[i]==s[i+2]:\n      print(str(i+1) + \" \" + str(i+3))\n      flag = 1\n      break\nif flag==0:\n  print(\"-1 -1\")", "s=input()\nn=len(s)\naccum=[[0]*(n+1) for _ in range(26)]\nfor i in range(n):\n    accum[ord(s[i])-ord(\"a\")][i+1]+=1\nfor i in range(n):\n    for j in range(26):\n        accum[j][i+1]+=accum[j][i]\nfor i in range(n-1):\n    for j in range(26):\n        if accum[j][i+2]-accum[j][i]==2:\n            print(i+1,i+2)\n            return\nfor i in range(n-2):\n    for j in range(26):\n        if accum[j][i+3]-accum[j][i]==2:\n            print(i+1,i+3)\n            return\nprint(-1,-1)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    S = readline().strip()\n    N = len(S)\n\n    a, b = -1, -1\n    for i in range(N):\n        if i < N - 1 and S[i] == S[i + 1]:\n            a, b = i + 1, i + 2\n            break\n        elif i < N - 2 and S[i] == S[i + 2]:\n            a, b = i + 1, i + 3\n            break\n\n    print((a, b))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def abc043_d():\n    s = str(input())\n    n = len(s)\n    ans = (-1, -1)\n    if n == 2:\n        if s[0] == s[1]:\n            ans = (1, 2)\n    else:\n        for i in range(n-2):\n            if len(set(s[i:i+3])) < 3:\n                ans = (i+1, i+3)\n                break\n    print(*ans, sep=' ')\n\ndef __starting_point():\n    abc043_d()\n__starting_point()", "a=input()\nt=-1\nflag=\"False\"\nfor i in range(len(a)-1):\n  if a[i]==a[i+1]:\n    flag=\"True1\"\n    t=i\n    break\n  if i!=len(a)-2:\n    if a[i]==a[i+2]:\n      flag=\"True2\"\n      t=i\n      break\nif flag==\"False\":\n  print(\"{} {}\".format(-1,-1))\nelif flag==\"True1\":\n  print(\"{} {}\".format(t+1,t+2))\nelse:\n  print(\"{} {}\".format(t+1,t+3))", "import sys\ns = input()\nn = len(s)\nfor i in range(n-1):\n  if s[i] == s[i+1]:\n    print(i+1, i+2)\n    return\nfor i in range(n-2):\n  if s[i] == s[i+2]:\n    print(i+1, i+3)\n    return\nprint(-1, -1)", "import re\n\n\ndef get_char_list():\n    return [chr(ord('a') + i) for i in range(26)]\n\n\ndef main():\n    S = input()\n    N = len(S)\n    char_list = get_char_list()\n    for c in char_list:\n        for pattern in ['{}.{}'.format(c, c), '{}{}'.format(c, c)]:\n            m = re.search(pattern, S)\n            if m is not None:\n                sp = m.span()\n                print('{} {}'.format(sp[0] + 1, sp[1]))\n                return\n    print('{} {}'.format(-1,-1))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "s = input()\nl = len(s)\ns += \"!\"*10\nfor i in range(l):\n    tar = s[i]\n    for j in range(i+1,i+3):\n        if s[i] == s[j]:\n            print(i+1,j+1)\n            return\nprint(-1,-1)", "s=input()\nn=len(s)\nfor i in range(n-1):\n    if s[i]==s[i+1]:\n        print((i+1, i+2))\n        return\nfor i in range(n-2):\n    if s[i]==s[i+2]:\n        print((i+1, i+3))\n        return\nprint((-1, -1))\n\n", "s = list(input())\n\n\nfor i in range(len(s)-1):\n\tif s[i] == s[i+1]:\n\t\tprint(('{} {}'.format(i+1, i+2)))\n\t\tbreak\n\tif i + 2 != len(s):\n\t\tif s[i] == s[i+2]:\n\t\t\tprint(('{} {}'.format(i+1, i+3)))\n\t\t\tbreak\nelse:\n\tprint(\"-1 -1\")\n", "s = input()\nsize = len(s)\nif size == 2:\n    if s[0] == s[1]:\n        print(\"1 2\")\n    else:\n        print(\"-1 -1\")\nelse:\n    for i in range(2, size):\n        a = s[i]\n        b = s[i-1]\n        c = s[i-2]\n        if a == b or b == c or a == c:\n            print(i-1, i+1)\n            break\n    else:\n        print(\"-1 -1\")", "import sys\ns = input()\nfor i, (x, y) in enumerate(zip(s, s[1:])):\n    if x == y:\n        print(i+1, i+2)\n        return\nif len(s) <= 2:\n    print(-1, -1)\n    return\nfor i, (x, y, z) in enumerate(zip(s, s[1:], s[2:])):\n    if x == z:\n        print(i+1, i+3)\n        return\nprint(-1, -1)", "s = input()\nl = len(s)\nfor i in range(1,l):\n    if s[i] == s[i-1]:\n        print(i,i+1)\n        break\nelse:\n    for i in range(2,l):\n        if s[i] == s[i-2]:\n            print(i-1,i+1)\n            break\n    else:\n        print(-1,-1)", "def main():\n    s = input()\n    if len(s) == 2:\n        if s[0] == s[1]:\n            print((1, 2))\n        else:\n            print((-1,-1))\n        return\n    for i in range(len(s) - 2):\n        if len(set(list(s[i:i + 3]))) < 3:\n            print((i + 1, i + 3))\n            return\n    print((-1, -1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nn = len(s)\nfor i in range(1, n):\n  if s[i] == s[i-1]:\n    print(i, i+1)\n    return\n\nfor i in range(2, n):\n  if s[i] == s[i-2]:\n    print(i-1, i+1)\n    return\n\nprint(-1,-1)", "#!/usr/bin/env python3\nimport sys\n\ndef solve(s: str):\n    \"\"\"\n    >>> solve(\"needed\")\n    (2, 3)\n    >>> solve(\"ede\")\n    (1, 3)\n    \"\"\"\n    for i, (c0, c1) in enumerate(zip(s, s[1:]), 1):\n        if c0 == c1:\n            return i, i+1\n    for i, (c0, c2) in enumerate(zip(s, s[2:]), 1):\n        if c0 == c2:\n            return i, i+2\n    return (-1, -1)\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    s = next(tokens)  # type: str\n    print((*solve(s)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    # test()\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\nimport random\nfrom decimal import Decimal\nimport itertools\nimport re\nimport bisect\nfrom collections import deque, Counter\nfrom functools import lru_cache\n\nsys.setrecursionlimit(10**9)\nINF = 10**13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\ndef SERIES(n): return np.fromstring(sys.stdin.buffer.read(), dtype=np.int32, sep=' ')\ndef GRID(h,w): return np.fromstring(sys.stdin.buffer.read(), dtype=np.int32, sep=' ').reshape(h,-1)[:,:w]\ndef GRIDfromString(h,w): return np.frombuffer(sys.stdin.buffer.read(), 'S1').reshape(h,-1)[:,:w]\nMOD = 1000000007\n\ndef main():\n\ts_list = list(S())\n\tfor t in range(2,min(len(s_list)+1,4)):\n\t\tfor i in range(len(s_list)-t+1):\n\t\t\tc = Counter(s_list[i:i+t])\n\t\t\tif c.most_common()[0][1] / t  > 0.5:\n\t\t\t\tprint(i+1, i+t)\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n\telse:\n\t\tprint(-1, -1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ns = input()\n\nif len(s) == 2 and s[0] == s[1]:\n    print('1 2')\n    return\nelse:\n    for i in range(0, len(s)-2):\n        c1, c2, c3 = s[i], s[i+1], s[i+2]\n\n        if len(set([c1,c2,c3])) <= 2:\n                print(('%s %s' % (i+1, i+3)))\n                return\n\nprint('-1 -1')\n", "s = input()\nanswer = \"-1 -1\"\n\nif s[-2] == s[-1]:\n    answer = \"{} {}\".format(len(s) - 1, len(s))\n\nfor i in range(len(s) - 2):\n    if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        answer = \"{} {}\".format(i + 1, i + 3)\n        break\n\nprint(answer)\n", "arr = input()\n\nchars = dict()\n\nfor i in range(len(arr)):\n    chars.setdefault(arr[i], [])\n    chars[arr[i]].append(i)\n\nfor _, inds in list(chars.items()):\n    for i in range(len(inds) - 1):\n        if inds[i + 1] - inds[i] < 3:\n            print((inds[i]+1, inds[i + 1]+1))\n            return\nprint((-1, -1))\n", "import sys\ns=list(input())\n\nfor i in range(1,len(s)):\n  if s[i-1]==s[i]:\n    print(i,i+1)\n    return\n  \nfor i in range(2,len(s)):\n  if s[i-2]==s[i]:\n    print(i-1,i+1)\n    return\n    \nprint(-1,-1)", "from collections import Counter\n\ndef unbalanced(s):\n    c = Counter(s)\n    if max(c.values()) > len(s)/2:\n        return True\n    else:\n        return False\n\ns = input()\nl = len(s)\n\nbalanced = False\n\nfor i in range(l-1):\n    if unbalanced(s[i:i+2]):\n        print(i+1,i+2)\n        return\n\nfor i in range(l-2):\n    if unbalanced(s[i:i+3]):\n        print(i+1,i+3)\n        return\n\nprint(-1,-1)", "# -*- coding: utf-8 -*-\n\nimport io\nimport sys\nimport math\n\ndef solve(s):\n    # implement process\n    len_s = len(s)\n    a,b = -1,-1\n    for i in range(len_s):\n        if len_s - i > 1 and s[i]==s[i+1]:\n            a,b = i+1,i+2\n            break\n        if len_s - i > 2 and s[i]==s[i+2]:\n            a,b = i+1,i+3\n            break\n    return f\"{a} {b}\"\n\ndef main():\n    # input\n    s = input()\n    # process\n    ans = str( solve(s) )\n    \n    # output\n    print(ans)\n    return ans\n        \n### DEBUG I/O ###\n_DEB = 0   # 1:ON / 0:OFF\n\n_INPUT = \"\"\"\\\naba\n\"\"\"\n_EXPECTED = \"\"\"\\\n2 5\n\"\"\"\n\ndef logd(str):\n    \"\"\"usage:\n    if _DEB: logd(f\"{str}\")\n    \"\"\"\n    if _DEB: print(f\"[deb] {str}\")\n\n### MAIN ###\ndef __starting_point():\n    if _DEB:\n        sys.stdin = io.StringIO(_INPUT)\n        print(\"!! Debug Mode !!\")\n\n    ans = main()\n\n    if _DEB:\n        print()\n        if _EXPECTED.strip() == ans.strip(): print(\"!! Success !!\")\n        else: print(f\"!! Failed... !!\\nANSWER:   {ans}\\nExpected: {_EXPECTED}\")\n__starting_point()", "s = list(input())\nfor i in range(len(s) - 1):\n    v = s[i]\n    if s[i + 1] == v:\n        print((i + 1, i + 2))\n        return\n    if i + 2 < len(s) and s[i + 2] == v:\n        print((i + 1, i + 3))\n        return\nprint((-1, -1))\n", "s = input()\nl = len(s)\nfor i in range(l - 1):\n    if s[i] == s[i + 1]:\n        print(i + 1, i + 2)\n        break\n    elif i == l - 2:\n        continue\n    elif s[i] == s[i + 2]:\n        print(i + 1, i + 3)\n        break\nelse:\n    print(-1, -1)", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\ns=SI()\nn=len(s)\nfor i in range(n-1):\n    if s[i]==s[i+1]:\n        print((i+1,i+2))\n        return\nfor i in range(n-2):\n    if s[i]==s[i+2]:\n        print((i+1,i+3))\n        return\nprint((-1,-1))\n", "S = input()\n\nfrom collections import defaultdict\ndef unbalance(S):\n    D = defaultdict(lambda:0)\n    for s in S:\n        D[s] += 1\n    if max(D.values()) > len(S)//2:\n        return True\n    else:\n        return False\n\nlenS =len(S)\nfor i in range(lenS-1):\n    if unbalance(S[i:i+2]):\n        print(f'{i+1} {i+2}'); break\n    if i < lenS-2 and unbalance(S[i:i+3]):\n        print(f'{i+1} {i+3}'); break\nelse:\n    print('-1 -1')", "s=input()\nN=len(s)\nfor i in range(N-1):\n    if s[i]==s[i+1]:\n        print(i+1,i+2)\n        return\nfor i in range(N-2):\n    if s[i]==s[i+2]:\n        print(i+1,i+3)\n        return\nprint(-1,-1)", "s= input()\nfor i in range(len(s)-1):\n    if s[i]==s[i+1]:\n        print(i+1,i+2)\n        break\n    if i+2<=len(s)-1 and (s[i]==s[i+2] or s[i+1]==s[i+2]):\n        print(i+1,i+3)\n        break\nelse:print('-1 -1')", "s = input()\nd = dict()\nans = '-1 -1'\nfor i in range(len(s)):\n    if d.get(s[i]) is None:\n        d[s[i]] = i\n    else:\n        if i - d[s[i]] <= 2:\n            ans = '{a} {b}'.format(b=i + 1, a=d[s[i]] + 1)\n            break\n        else:\n            d[s[i]] = i\nprint(ans)\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\nfrom decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\ns = input()\n\nfor i in range(len(s)):\n\tif  i < len(s)-1 and s[i] == s[i+1]:\n\t\tprint((i+1, i+2))\n\t\tbreak\n\telif i < len(s)-2 and s[i] == s[i+2]:\n\t\tprint((i+1, i+3))\n\t\tbreak\nelse:\n\tprint((-1, -1))\n", "s = input()\nN = len(s)\nif N == 2:\n    if s[0] == s[1]:\n        print('1 2')\n        return\n    else:\n        print('-1 -1')\n        return\nfor i in range(N-2):\n    if s[i] == s[i+1] or s[i] == s[i+2]:\n        print((i+1, i+3))\n        return\nif s[-1] == s[-2]:\n    print((N-2, N))\n    return\nprint('-1 -1')\n", "s=input()\nn=len(s)\n\nif n==2:\n  if s[0]==s[1]:\n    print(1, 2)\n  else:\n    print(-1, -1)\n  return\n\nfor i in range(n-2):\n  t=s[i:i+3]\n  if t[0]==t[1] or t[1]==t[2] or t[0]==t[2]:\n    print(i+1, i+3)\n    return\nprint(-1, -1)", "s=input()\nN=len(s)\nres = (-1, -1)\n# 2\u6587\u5b57\nfor i in range(N-1):\n    tgt = s[i:i+2]\n    if tgt[0]==tgt[1]:\n        res = (i+1,i+2)\n\n# 3\u6587\u5b57\nfor i in range(N-2):\n    tgt = s[i:i+3]\n    if tgt[0]==tgt[2]:\n        res = (i+1,i+3)\nprint(*res)", "s=input()\nn=len(s)\nfor i in range(n-1):\n    if s[i]==s[i+1]:\n        print(i+1,i+2)\n        return\nfor i in range(n-2):\n    if s[i]==s[i+2]:\n        print(i+1,i+3)\n        return\nprint(-1,-1)", "s = str(input())\nN = len(s)\n\nfor i in range(N-1):\n  if s[i] == s[i+1]:\n    print(i+1, i+2)\n    return\n\nfor i in range(N-2):\n  if s[i] == s[i+2]:\n    print(i+1, i+3)\n    return\n    \nprint(-1, -1)", "import re\ntext = input()\nalphabet = list('abcdefghijklmnopqrstuvwxyz')\noutput = ['-1', '-1']\nfor i in range(len(alphabet)):\n    pattern = alphabet[i] + '.?' + alphabet[i]\n    match_object = re.search(r'%s.?%s' % (alphabet[i], alphabet[i]), text)\n    if match_object:\n        output[0] = str(match_object.start() + 1)\n        output[1] = str(match_object.end())\n        break\n\nprint(' '.join(output))", "s = input()\nn = len(s)\nfor i in range(n):\n    if i+1 < n:\n        if s[i] == s[i+1]:\n            print(str(i+1)+\" \"+str(i+1+1))\n            return\n    if i+2 < n:\n        if s[i] == s[i+2]:\n            print(str(i+1)+\" \"+str(i+2+1))\n            return\n    if i > 0:\n        if s[i] == s[i-1]:\n            print(str(i)+\" \"+str(i+1))\n            return\n    if i > 1:\n        if s[i] == s[i-2]:\n            print(str(i-1)+\" \"+str(i+1))\n            return\nprint(\"-1 -1\")\nreturn", "s = input()\nleft = -1;right = -1\nfor i in range(len(s)-1):\n    if s[i]==s[i+1]:\n        left = i+1;right=i+2\n        break\n    if not i == len(s)-2:\n        if s[i]==s[i+2]:\n            left = i+1;right=i+3\n            break\nprint(left, right)", "s = input()\nn = len(s)\n\nfor i in range(n-1):\n    if s[i] == s[i+1]:\n        print((i+1, i+2))\n        return\n\nfor i in range(n-2):\n    if s[i] == s[i+2]:\n        print((i+1, i+3))\n        return\n\nprint((-1, -1))\n", "s = input()\nn = len(s)\n\ndef solve():\n  for i in range(1,n):\n    if s[i-1] == s[i]:\n      print((i,i+1))\n      return\n  for i in range(2,n):\n    if s[i-2] == s[i-1] or s[i-1] == s[i] or s[i-2] == s[i]:\n      print((i-1,i+1))\n      return\n  print((-1,-1))\n\nif n==2:\n  if s[0]==s[1]:\n    print((1,2))\n  else:\n    print((-1,-1))    \nelse:\n  solve()\n", "#!/usr/bin/env python3\n\nimport sys\n# import math\n# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits\n# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)\n# from operator import itemgetter              # itemgetter(1), itemgetter('key')\n# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()\n# from collections import defaultdict          # subclass of dict. defaultdict(facroty)\n# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)\n# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).\n# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).\n# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])\n# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]\n# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]\n# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])\n# from itertools import combinations, combinations_with_replacement\n# from itertools import accumulate             # accumulate(iter[, f])\n# from functools import reduce                 # reduce(f, iter[, init])\n# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)\n# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).\n# from copy import deepcopy                    # to copy multi-dimentional matrix without reference\n# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)\n\n\ndef main():\n    mod = 1000000007                # 10^9+7\n    inf = float('inf')              # sys.float_info.max = 1.79...e+308\n    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19\n    sys.setrecursionlimit(10**6)    # 1000 -> 1000000\n    def input(): return sys.stdin.readline().rstrip()\n    def ii():    return int(input())\n    def mi():    return list(map(int, input().split()))\n    def mi_0():  return [int(x)-1 for x in input().split()]\n    def lmi():   return list(map(int, input().split()))\n    def lmi_0(): return list([int(x)-1 for x in input().split()])\n    def li():    return list(input())\n\n\n    def calc_consective(s):\n        n = len(s)\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                return [i+1, i+2]    # 1-index\n        return None\n    \n    def calc_skip(s):\n        n = len(s)\n        for i in range(n-2):\n            if s[i] == s[i+2]:\n                return [i+1, i+3]    # 1-index\n        return None\n\n\n    def calc_ans(s):\n        ans = calc_consective(s)\n        if ans:\n            return ans\n        ans = calc_skip(s)\n        if ans:\n            return ans\n        return (-1, -1)\n\n    \n    s = input()\n    res = calc_ans(s)\n    print((\"{} {}\".format(res[0], res[1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\n\nfor i in range(1,len(s)):\n  if s[i-1]==s[i]:\n    print((i, i+1))\n    return\n\nfor i in range(1,len(s)-1):\n  if s[i-1]==s[i+1]:\n    print((i, i+2))\n    return\nprint(\"-1 -1\")\n\n", "s=input()\nl=len(s)\nfor i in range(l-2):\n  if s[i]==s[i+1]:\n    print(i+1,i+2)\n    break\n  if s[i]==s[i+2]:\n    print(i+1,i+3)\n    break\nelse:\n  if s[-2]==s[-1]:\n    print(l-1,l)\n  else:\n    print(-1,-1)", "s = input()\nfor i in range(len(s)):\n    if s[i] == s[i-1] and i-1>=0:\n        print(i-1+1, i+1)\n        return\n    elif (i+1)<=len(s)-1 and s[i+1] == s[i]:\n        print(i+1, i+1+1)\n        return\n    elif (i-1)>=0 and (i+1)<= len(s)-1 and s[i-1]==s[i+1]:\n        print(i-1+1,i+1+1)\n        return\nprint(-1, -1)", "s = input()\nn = len(s)\n\nif len(s) == 2:\n    if s[0] == s[1]:\n        print((1,2))\n    else:\n        print((-1,-1))\nelse:\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            print((i+1,i+2))\n            return\n    for i in range(n-2):\n        if s[i] == s[i+2]:\n            print((i+1,i+3))\n            return\n    print((-1,-1))\n", "import sys\ns = input()\nN = len(s)\n\nfor i in range(N-1):\n    if s[i] == s[i+1]:\n        print(i+1,i+2)\n        return\n    if i+2 < N and s[i] == s[i+2]:\n        print(i+1,i+3)\n        return\nprint(-1,-1)", "s = input()\n \na = -1\nb = -1\nfor i in range(len(s) - 2):\n  if s[i] == s[i+1]:\n    a = i + 1\n    b = i + 2\n  elif s[i] == s[i+2]:\n    a = i + 1\n    b = i + 3\nif s[-1] == s[-2]:\n  a = len(s) - 1\n  b = len(s)\n    \nprint(a,b)", "from sys import stdin\ninput = stdin.readline\n\ndef Judge(N, S):\n    for i in range(N-1):\n        if S[i] == S[i+1]:\n            return i+1, i+2\n    for i in range(N-2):\n        if S[i] == S[i+2]:\n            return i+1, i+3\n    else:\n        return -1, -1\n\nS = list(input().strip())\nN = len(S)\na, b = Judge(N, S)\nprint(a, b)", "def main():\n    s = input()\n    if len(s) == 2:\n        if s[0] == s[1]:\n            print((1, 2))\n            return\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            print((i + 1, i + 2))\n            break\n        elif s[i] == s[i + 2]:\n            print((i + 1, i + 3))\n            break\n    else:\n        print((-1, -1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s=input()\nn=len(s)\nfor i in range(1,len(s)):\n    if s[i-1]==s[i]:\n        print((i,i+1))\n        break\n    elif i>1 and s[i-2]==s[i]:\n        print((i-1,i+1))\n        break\nelse:\n    print((-1,-1))\n", "s=input()\nn=len(s)\na=b=-1\nfor i in range(n-1):\n    if s[i]==s[i+1]:\n        a,b=i+1,i+2\n        break\n    elif i+2<n and s[i]==s[i+2]:\n        a,b=i+1,i+3\n        break\n\nprint((a,b))\n", "S = input()+\"_\"\nx = -2\ny = -2\n\nfor n in range(len(S)-2):\n  if S[n]==S[n+1]:\n    x=n\n    y=n+1\n  if S[n]==S[n+2]:\n    x=n\n    y=n+2\n\nprint(x+1,y+1)", "import sys\nimport string\n \nalphabets=list(string.ascii_lowercase)\n \ns=input()\n \nl=len(s)\n \nhm = lambda a,string: sum([x==a for x in string])\n \nfor x in range(l-1):\n  if s[x]==s[x+1]:\n    print('{} {}'.format(x+1, x+2))\n    return\n \n \nfor n in range(l-3):\n  for a in alphabets:\n    if hm(a,s[n:n+3])> 1:\n      print('{} {}'.format(n+1,n+3))\n      return\nprint('-1 -1')", "s=input()\n\nfor i in range(len(s)):\n  if i>0:\n    if s[i]==s[i-1]:\n      print(i-1+1,i+1)\n      return\n  if i>1:\n    if s[i]==s[i-2]:\n      print(i-2+1,i+1)\n      return\n      \nprint(-1,-1)", "def resolve():\n    S = list(input())\n    if len(S) == 2:\n        if S[0] == S[1]:\n            print(1, 2)\n        else:\n            print(-1, -1)\n        return\n    for i in range(len(S)-2):\n        if S[i] == S[i+1] or S[i+1] == S[i+2] or S[i+2] == S[i]:\n            print(i+1, i+3)\n            return\n    print(-1, -1)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "s = input()\n\nif s[0] == s[1]:\n    print(1, 2)\n    return\n\nans = [-1, -1]\nfor i in range(2, len(s)):\n    if s[i] == s[i - 2]:\n        ans = [i - 1, i + 1]\n        break\n    elif s[i] == s[i - 1]:\n        ans = [i, i + 1]\n        break\nprint(*ans)", "S = input()\nN = len(S)\nfor i in range(N-1):\n    if S[i] == S[i + 1]:\n        print(i+1,i+2)\n        return\nfor i in range(N-2):\n    if S[i] == S[i + 2]:\n        print(i + 1 ,i + 3)\n        return\n        \nprint(-1,-1)", "s = input()\nl = len(s)\ns += \"!\"*10\nfor i in range(l):\n    for j in range(i+1,i+3):\n        if s[i] == s[j]:\n            print(i+1,j+1)\n            return\nprint(-1,-1)", "from sys  import stdin,stdout\n\nimport bisect\n\nimport math\n\ndef st():\n    return list(stdin.readline().strip())\n\ndef inp():\n    return int(stdin.readline())\n\ndef li():\n    return list(map(int,stdin.readline().split()))\n\ndef mp():\n    return list(map(int,stdin.readline().split()))\n\ndef pr(n):\n    stdout.write(str(n)+\"\\n\")\n\ndef soe(limit):\n    l=[1]*(limit+1)\n    prime=[]\n    for i in range(2,limit+1):\n        if l[i]:\n            for j in range(i*i,limit+1,i):\n                l[j]=0\n\n    for i in range(2,limit+1):\n        if l[i]:\n            prime.append(i)\n    return prime\n\ndef segsoe(low,high):\n    limit=int(high**0.5)+1\n    prime=soe(limit)\n    n=high-low+1\n    l=[0]*(n+1)\n    for i in range(len(prime)):\n        lowlimit=(low//prime[i])*prime[i]\n        if lowlimit<low:\n            lowlimit+=prime[i]\n        if lowlimit==prime[i]:\n            lowlimit+=prime[i]\n        for j in range(lowlimit,high+1,prime[i]):\n            l[j-low]=1\n    for i in range(low,high+1):\n        if not l[i-low]:\n            if i!=1:\n                print(i)\n                \ndef gcd(a,b):\n    while b:\n        a=a%b\n        b,a=a,b\n    return a\n\ndef power(a,n):\n    r=1\n    while n:\n        if n&1:\n            r=(r*a)\n        a*=a\n        n=n>>1\n    return r\n\ndef check(n,l):\n    s=0\n    for i in range(len(l)):\n        s+=(l[i]-n)*(l[i]-n)\n    return s\n\ndef solve():\n    s=input()\n    n=len(s)\n    for i in range(n-1):\n        if s[i]==s[i+1]:\n            print((i+1, i+2))\n            return \n    for i in range(n-2):\n        if s[i]==s[i+2]:\n            print((i+1, i+3))\n            return \n    print((-1, -1))\n \n\nfor _ in range(1):\n    solve()\n    \n", "s=input()\nn=len(s)\nfor i in range(n-1):\n  t=s[i:i+2]\n  if t[0]==t[-1]:\n    print((i+1,i+2))\n    return\nfor i in range(n-2):\n  t=s[i:i+3]\n  if t[0]==t[-1] and t[0]!=t[1]:\n    print((i+1,i+3))\n    return\nprint((-1,-1))\n", "s=input()\nflag=0\nfor i in range(len(s)-1):\n    if s[i]==s[i+1]:\n        print(i+1,i+2)\n        flag+=1\n        break\n\nif flag==0:\n    for i in range(len(s)-2):\n        if s[i]==s[i+2]:\n            print(i+1,i+3)\n            flag+=1\n            break\n\n\nif flag==0:\n    print(-1,-1)", "import sys\ns = input()\nz = True\nfor i in range(len(s)):\n    if not z:\n        break\n    try:\n        if s[i] == s[i + 1]:\n            print((i + 1, i + 2))\n            z = False\n            return\n        if s[i] == s[i + 2]:\n            print((i + 1, i + 3))\n            z = False\n            return\n    except:\n        pass\nif z:\n    print((-1, -1))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\nfrom decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\ns = input()\n\ndic = defaultdict(list)\n\nfor i, x in enumerate(s, 1):\n\tdic[x].append(i)\n\nfor lis in dic.values():\n\tfor i in range(len(lis)-1):\n\t\tif lis[i+1] <= lis[i]+2:\n\t\t\tprint(lis[i], lis[i+1])\n\t\t\tbreak\n\telse:\n\t\tcontinue\n\tbreak\nelse:\n\tprint(-1, -1)", "s = input()\n\nfor i in range(len(s)-1):\n    if s[i] == s[i+1]:\n        print(i+1, i+2)\n        return\nfor i in range(len(s)-2):\n    if s[i] == s[i+2]:\n        print(i+1, i+3)\n        return\nprint(-1, -1)", "s = list(input())\n\nif len(s) == 2:\n  if s[0] == s[1]:\n    print(1,2)\n  else:\n    print(-1,-1)\n  return\nfor i in range(len(s)-2):\n  if len(set(s[i:i+3])) < 3:\n    print(i+1,i+3)\n    return\n\nprint(-1,-1)", "S = input()\n\na1, a2 = -1, -1\nfor i in range(26):\n    t = chr(ord('a') + i)\n\n    s0 = ''\n    s1 = ''\n    for j, s2 in enumerate(S):\n        if s2 == t:\n            if s2 == s1:\n                a1, a2 = j, j + 1\n                break\n            elif s2 == s0:\n                a1, a2 = j - 1, j + 1\n                break\n        s0, s1 = s1, s2\n    else:\n        continue\n    break\n\nprint((a1, a2))\n", "import re\ntext = input()\nfor i in list('abcdefghijklmnopqrstuvwxyz'):\n    match_object = re.search(r'{0}.?{0}'.format(i), text)\n    if match_object:\n        print(str(match_object.start() + 1) + ' ' + str(match_object.end()))\n        return\nprint('-1 -1')", "import re\n\ns = input()\n\nset_s = set(s)\nflag = 0\n\nif len(s) == 2:\n    if s[0] == s[1]:\n        print(1,2)\n        flag = 1\n    else:\n        flag = 1\n        print(-1,-1)\n\n\nfor x in set_s:\n    regex1 = re.compile(x+x +r\"\\w\")\n    regex2 = re.compile(x +r\"\\w\" + x)\n    mo1 = regex1.search(s)\n    mo2 = regex2.search(s)\n    if mo1:\n        #print(mo1.group())\n        print(mo1.start()+1,mo1.end())\n        flag = 1\n        break\n    elif mo2:\n        #print(mo2.group())\n        print(mo2.start()+1,mo2.end())\n        flag = 1\n        break\n\nif not flag:\n    print(-1,-1)", "s = input()\nif len(s) == 2:\n    if s[0] == s[1]:\n        print(1, 2)\n    else:\n        print(-1, -1)\nelse:\n    for i in range(len(s) - 2):\n        temp = {}\n        for j in range(3):\n            temp.setdefault(s[i + j], 0)\n            temp[s[i + j]] += 1\n        if max(temp.values()) >= 2:\n            print(i + 1, i + 3)\n            break\n    else:\n        print(-1, -1)", "s = input()\nfor i in range(len(s)-2):\n    if len(set(s[i:i+3]))<=2:\n        print(i+1,i+3)\n        break\nelse:\n    if s[0]==s[1]:\n        print(1,2)\n    else:\n        print(-1,-1)", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nS = input()\nL = len(S)\n\ndef p():\n    for j in range(L - 2):\n        if S[j] == S[j + 1]:\n            print(j + 1, j + 2)\n            return\n        if S[j] == S[j + 2]:\n            print(j + 1, j + 3)\n            return\n\n    if S[-2] == S[-1]:\n        print(L - 1, L)\n    else:\n        print(-1, -1)\n\np()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    S = readline().strip()\n    N = len(S)\n\n    for i in range(N - 2):\n        if S[i] == S[i + 1] or S[i] == S[i + 2]:\n            print((i + 1, i + 3))\n            return\n\n    if S[N - 2] == S[N - 1]:\n        print((N - 1, N))\n        return\n\n    print((-1, -1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    S = input()\n    p = ''\n    pp = ''\n    for i, s in enumerate(S):\n        if p == s:\n            return (i, i + 1)\n        if pp == s:\n            return (i - 1, i + 1)\n        pp, p = p, s\n    return (-1, -1)\n\nprint((*main()))\n", "txt = input()\nL = len(txt)\n\ndef solve():\n  for i in range(L-1):\n    if txt[i] == txt[i+1]:\n      return ' '.join([str(x) for x in [i+1,i+2]])\n  for i in range(L-2):\n    if txt[i] == txt[i+2]:\n      return ' '.join([str(x) for x in [i+1,i+3]])\n  return '-1 -1'\n\nans = solve()\nprint(ans)\n", "def check(l, r):\n    th = 1 + (r - l + 1) // 2 \n    for i in range(26):\n        if cnt[i] >= th:\n            return True\n    return False\n\ns = input()\nn = len(s)\nsi = [0] * n\nfor i in range(n):\n    si[i] = ord(s[i]) - 97\n\nl, r = 0, 1\ncnt = [0]*26\nfor i in range(2):\n    cnt[si[i]] += 1\nwhile l < n-1 and r < n:\n    if check(l, r):\n        print(l+1, r+1)\n        return\n    elif max(cnt) == 1 + (r - l + 1) // 2 or r-l == 1:\n        r += 1\n        if r < n:\n            cnt[si[r]] += 1\n    else:\n        cnt[si[l]] -= 1\n        l += 1     \nprint(-1, -1)"]
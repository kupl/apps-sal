["N, K = map(int, input().split())\ndef num_pair(m):\n    if m<=N:\n        return m-1\n    return 2*N-m+1\n\nK = abs(K)\n\nans = 0\nfor i in range(K+2,2*N+1):\n    ans += num_pair(i)*num_pair(i-K)\n    \nprint(ans)", "n, k = map(int, input().split())\nans = 0\nfor cd in range(2,2*n+1):\n    if 2 <= k+cd and k+cd <= 2*n:\n        ans += (n-abs(cd-(n+1)))*(n-abs((k+cd)-(n+1)))\nprint(ans)", "\nN,K = map(int,input().split())\n\ndef cnt(n):\n    if n<2: return 0\n    if n>2*N: return 0\n    return n-2*max(n-N,1)+1\n\nans = 0\nfor ab in range(2,2*N+1):\n    cd = ab - K\n    ans += cnt(ab)*cnt(cd)\n\nprint(ans)", "N, K = map(int, input().split())\n\nans = 0\nfor x in range(2, 2*N+1):\n    y = x - K\n    if y<2 or y > 2*N:\n        continue\n    cnt_x = min(x-1, 2*N+1-x)\n    cnt_y = min(y-1, 2*N+1-y)\n    ans += cnt_x*cnt_y\nprint(ans)", "N, K = map(int, input().split())\ntmp1, tmp2, ans = 0, 0, 0\nfor i in range(2, 2 * N + 1):\n    tmp1 = min(i - 1, 2 * N + 1 - i)\n    tmp2 = min(i - K - 1, 2 * N + 1 - i + K)\n    if tmp1 >= 0 and tmp2 >= 0:\n        ans += tmp1 * tmp2\nprint(ans)", "N,K=map(int,input().split())\nans=0\ndef func(k):\n  return min(k-1, 2*N+1-k)\n\nfor i in range(2,2*N+1):\n  ab=i\n  cd=ab-K\n  # 2 <= cd <= 2*N\n  if cd < 2 or cd > 2*N:\n    continue\n  ans+=func(ab)*func(cd)\n\nprint(ans)", "mod = 998244353\nn,k = map(int, input().split())\nk = abs(k)\ndef count(num):\n  if num <= n:\n    return num-1\n  else:\n    return num-1-(num-n-1)*2\n\ndef main():\n  ans = 0\n  for i in range(k+2, 2*n+1):\n    j = i-k\n    ans += count(i)*count(j)\n    \n  print(ans)\n    \n  \ndef __starting_point():\n  main()\n__starting_point()", "n,k=map(int,input().split())\nans=0\nfor i in range(2,2*n+1):\n    if 2<=i-k<=2*n:\n        ans+=min(2*n+1-i,i-1)*min(2*n+1-i+k,i-k-1)\nprint(ans) ", "N, K = map(int, input().split())\n\ncnt = [0] * (2*N+1)\n\nfor i in range(0,2*N+1):\n    if i > 1 and i < N+2 : cnt[i] = cnt[i-1]+1\n    elif i >= N+2: cnt[i] = cnt[i-1]-1\nans = 0\n\n\nfor i in range(K+2,2*N+1):\n    if i < 2: continue\n    if 2*N >= i-K >= 1:\n        ans += cnt[i]*cnt[i-K]\nprint(ans)", "N,K = map(int,input().split())\n\nl = max(2,2+K)\nr = min(2*N, 2*N + K)\n\nans = 0\nfor i in range(l,r+1):\n    la = max(1, i-N)\n    ra = min(i-1, N)\n    lc = max(i-K-N, 1)\n    rc = min(i-K-1, N)\n    ans += (ra-la+1)*(rc-lc+1)\n    \nprint(ans)", "#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN, K = readInts()\ndef calc(n):\n    if n <= 0:\n        return 0\n    elif n > 2*N:\n        return 0\n    else:\n        # print(2*N-n, n-1)\n        return min(2*N - n + 1, n-1)\nans = 0\nfor i in range(1, 2*N+1):\n    ans += calc(i) * calc(i-K)\nprint(ans)\n", "n, k = map(int, input().split(' '))\nk = abs(k)\nans = 0\ndef f(x):\n    low = max(1, x - n)\n    high = min(n, x - 1)\n    return max(high - low + 1, 0)\nfor i in range(k + 2, k + n + n + 1):\n    ans += f(i) * f(i - k)\nprint(ans)", "def f(a,b):\n  return min(2*a-b+1,b-1)\nn,k = map(int,input().split())\nans = 0\nfor i in range(2,2*n+1):\n  if not (2 <= i-k <= 2 * n):\n    continue\n  ans += f(n,i)*f(n,i-k)\nprint(ans)", "N,K = map(int,input().split())\n \ndef cnt(n):\n    if n<2: return 0\n    if n>2*N: return 0\n    return n-2*max(n-N,1)+1\n\nans = 0\nfor ab in range(2,2*N+1):\n    cd = ab - K\n    ans += cnt(ab)*cnt(cd)\n\nprint(ans)", "n,k=map(int,input().split())\nk=abs(k)\nans=0\nfor i in range(k+2,2*n+1):\n  x=min(i-1,2*n-i+1)\n  y=min(i-1-k,2*n+1-(i-k))\n  ans+=x*y\nprint(ans)", "#region Header\n#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nfrom queue import PriorityQueue\nimport bisect\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\nsys.setrecursionlimit(1000000)\n#endregion\n\n# _INPUT = \"\"\"2 1\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\n\n\n# def solve(N: int, K: int) -> int:\ndef solve(N, K):\n    s = 0\n    for Y in range(2, 2*N+1):\n        X = Y + K\n        if 2 <= X <= 2*N:\n            a_min = max(X-N, 1)\n            a_max = min(X-1, N)\n            c_min = max(Y-N, 1)\n            c_max = min(Y-1, N)\n            if a_min <= a_max or c_min <= c_max:\n                s += (a_max - a_min + 1) * (c_max - c_min + 1)\n    return s\n\ndef main():\n    N, K = list(map(int, input().split()))\n    a = solve(N, K)\n    print(a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n# from typing import *\n\n\ndef solve(N, K):\n    tmp = 0\n    for ab in range(2, 2*N+1):\n        cd = ab-K\n        tmp += sub(N, ab)*sub(N, cd)\n    return tmp\n\ndef sub(N, K):\n    if K-1 < 0:\n        return 0\n    elif 0 <= K-1 <= N:\n        return K-1\n    elif N < K-1:\n        return max(0, K-1-2*(K-1-N))\n\n# generated by online-judge-template-generator v4.7.1 (https://github.com/online-judge-tools/template-generator)\ndef main():\n    N, K = list(map(int, input().split()))\n    a = solve(N, K)\n    print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import comb\n\nN, K = list(map(int, input().split()))\n\nans = comb(K+2*N+1, 3)\nfor i in range(1, 5):\n    if K+2*N+1-i*N >= 0:\n        ans += (-1)**i * comb(K+2*N+1-i*N, 3) * comb(4, i)\n\nprint(ans)\n", "N, K = list(map(int, input().split()))\ncount = 0\n\nfor x in range(2, min(2*N+1, K+2*N+1)):\n    x_way = min(N, x-1) - max(1, x-N) + 1  # x=a+b\u3068\u306a\u308ba\u306e\u9078\u3073\u65b9\n    y = x-K\n    if 2 <= y <= 2 * N:\n        y_way = min(N, y-1) - max(1, y-N) + 1  # y=c+d\u3068\u306a\u308bc\u306e\u9078\u3073\u65b9\n        count += x_way * y_way\n\nprint(count)\n", "N, K = list(map(int,input().split()))\n\ndef cnt(n):\n    if n < 2:\n        return 0\n    if n > 2 * N:\n        return 0\n    return n - 2 * max(n - N, 1) + 1\n\nans = 0\nfor ab in range(2, 2*N + 1):\n    cd = ab - K\n    ans += cnt(ab) * cnt(cd)\n\nprint(ans)\n", "n,k = map(int, input().split())\ncnt = 0\nfor x in range(2, 2*n+1):\n    if 2 <= x-k <= 2*n:\n        y = x-k\n        if x-1 >= n:\n            c1 = max(x-1-2*(x-1-n), 0)\n        else:\n            c1 = x-1\n        if y-1 >= n:\n            c2 = max(y-1-2*(y-1-n), 0)\n        else:\n            c2 = y-1\n        cnt += c1*c2\nprint(cnt)", "n, k = map(int, input().split())\n\n\ndef count(s):\n    return min(s-1, 2*n + 1 - s)\n\nans = 0\nfor i in range(2, 2*n+1):\n    if 2<=i-k<=2*n:\n        ans += count(i)*count(i-k)\n\nprint(ans)", "n, k = map(int, input().split())\nk = abs(k)\nans = 0\nfor i in range(2 + k, 2 * n + 1):\n  ans += min(2 * n - i + k + 1, i - k - 1) * min(2 * n - i + 1, i - 1)\nprint(ans)", "import sys\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\nN, K = LI()\nK = abs(K)\nans = 0\n\nfor i in range(2+K, 2*N+1):\n    i -= 1\n    L = max(0, (i-N)*2)\n    R = max(0, (i-K-N)*2)\n    ans += (i-L)*(i-K-R)\nprint(ans)\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,k=nii()\n\nans=0\nfor i in range(2,2*n+1):\n  j=i-k\n\n  if not 2<=j<=2*n:\n    continue\n\n  num1=2*min(i-1,n)-i+1\n  num2=2*min(j-1,n)-j+1\n\n  ans+=num1*num2\n\nprint(ans)", "N, K = map(int, input().split())\n\ndef count(x):\n    if x <= N + 1:\n        return x - 1\n    else:\n        return (x - 1) - 2 * (x - 1 - N)\n\nans = 0\nfor x in range(2, 2 * N + 1):\n    y = x - K\n    if not 2 <= y <= 2 * N:\n        continue\n    ans += count(x) * count(y)\n    \nprint(ans)", "n, k = map(int, input().split())\n\ndef f(x):\n    mi = max(1, x - n)\n    ma = min(n, x - 1)\n    return ma - mi + 1\n\nans = 0\nfor p in range(2, 2 * n + 1):\n    q = p - k\n    if q < 1 or q > 2 * n: continue\n    ans += f(p) * f(q)\nprint(ans)", "n, k = map(int, input().split())\n\nans = 0\nfor A in range(2, 2*n+1):\n    B = A-k\n    if 2 <= B <= 2*n:\n        ans += min(A-1, 2*n+1-A)*min(B-1, 2*n+1-B)\n\nprint(ans)", "def main():\n    n, k = list(map(int,input().split()))\n    k = abs(k)\n    c = 0\n    for y in range(2, 2*n - k + 1):\n        x = y + k\n        c += counter(x, n) * counter(y, n)\n    print(c)\n    return\n\ndef counter(value, n):\n    ins = value - 2\n    return min(ins, 2 * (n - 1) - ins) + 1\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k=map(int,input().split())\ndef f(a,b):\n    return max(min(b-1,2*a+1-b),0)\n\nans=0\nfor i in range(2,2*n+1):\n    ans+=f(n,i)*f(n,i-k)\nprint(ans)", "n,k = map(int,input().split())\nk = abs(k)\nx = 0\nfor i in range(2+k,2*n+1):\n  y = i-1 if i<=n+1 else 2*n-i+1\n  z = i-k-1 if i<=n+k+1 else 2*n-i+k+1\n  x += y*z\nprint(x)", "N,K=list(map(int,input().split()))\nK=abs(K)\nnum=[0]*(2*N+1)\nfor v in range(2,2*N+1):\n  num[v]=min(v-1,2*N+1-v)\nres=0\nfor v in range(2+K,2*N+1):\n  res+=num[v]*num[v-K]\nprint(res)\n", "N, K = map(int, input().split())\n\nans = 0\nfor i in range(2, 2*N+1):\n    j = i - K\n    if not 2 <= j <= 2*N:\n        continue\n\n    A = min(i-1, (i-1)-(i-1-N)*2)\n    C = min(j-1, (j-1)-(j-1-N)*2)\n    ans += A * C\n\nprint(ans)", "# B\nN, K=map(int, input().split())\nans=0\nfor AB in range(max(2, K+2), min(2*N, K+2*N)+1):\n    ans+=( min(AB-1, N)- max(1, AB-N) +1 )*( min(AB-K-1, N)- max(1, AB-K-N) +1 )\nprint(ans)", "N,K=list(map(int,input().split()))\ndef f(N,K):\n    ans = max(0,min(K-1,2*N+1-K))\n    return ans\nans = 0\n\nfor x in range(2,2*N+1):\n    ans += f(N,x)*f(N,x-K)\n\nprint(ans)\n", "N,K = map(int,input().split())\ncnt = 0\nfor x in range(2,2*N+1):\n    if 2<=x-K<=2*N:\n        y = x-K\n        if x-1>=N:\n            c1 = max(x-1-2*(x-1-N),0)\n        else:\n            c1 = x-1\n        if y-1>=N:\n            c2 = max(y-1-2*(y-1-N),0)\n        else:\n            c2 = y-1\n        cnt += c1*c2\nprint(cnt)", "N,K = map(int,input().split())\ncnt = 0\nfor X in range(2,2*N+1):\n    if X<=N+1:\n        cx = X-1\n    else:\n        cx = 2*N+1-X\n    Y = X-K\n    if 2<=Y<=2*N:\n        if Y<=N+1:\n            cy = Y-1\n        else:\n            cy = 2*N+1-Y\n        cnt += cx*cy\nprint(cnt)", "N,K = map(int,input().split())\nK = abs(K)\nprint(sum((N-abs(N-n))*(N-abs(N-n+K)) for n in range(K+1,2*N)))", "N,K=[int(x) for x in input().split()]\nminA=2\nmaxA=2*N\nminC=2\nmaxC=2*N\nminA=max(minA,K+minC)\nmaxA=min(maxA,K+maxC)\nans=0\nfor i in range(minA,maxA+1):\n    C=i-K\n    mina=i-N\n    maxa=i-1\n    if mina<1:\n        mina=1\n    if maxa>N:\n        maxa=N\n    cntA=maxa-mina+1\n    minc=C-N\n    maxc=C-1\n    if minc<1:\n        minc=1\n    if maxc>N:\n        maxc=N\n    cntC=maxc-minc+1\n    ans+=cntA*cntC\nprint(ans)", "N, K = list(map(int, input().split()))\nans = 0\nfor i in range(2, 2 * N + 1):\n    j = i - K\n    if not (2 <= j <= 2 * N):\n        continue\n    ans += min(i - 1, 2 * N - i + 1) * min(j - 1, 2 * N - j + 1)\nprint(ans)\n", "n,k=map(int,input().split())\nans=0\ndef f(a,b):\n    return max(min(b-1,2*a+1-b),0)\nfor x in range(2,2*n+1):\n    ans+=f(n,x)*f(n,x-k)\nprint(ans)", "n,k=map(int,input().split())\n\nfrom math import ceil\n\nans=0\nfor x in range(2,(2*n) +1):\n    cd=x-k\n    if cd <2 or cd>2*n:\n        continue\n    p = min(x-1,(2*n) -x+1)\n    q = min(cd-1,(2*n) -cd+1)\n\n    ans = ans + p*q\n\nprint(ans)", "n, k = map(int, input().split())\n\nans = 0\n\nfor i in range(2, 2*n+1):\n\n    if i > n:\n        ab = 2 * n - i + 1\n    else:\n        ab = i - 1\n\n    r = i - k\n    if r <= 1 or r >= 2*n+1:\n        cd = 0\n    elif r > n:\n        cd = 2 * n - r+ 1\n    else:\n        cd = r - 1\n\n    ans += ab * cd\n\nprint(ans)", "n, k = map(int, input().split())\nk = abs(k)\nli = [0] * (n*2+1)\nfor i in range(2, n*2+1):\n    li[i] = min(i-1, 2*n+1-i)\nans = 0\nfor i in range(k, n*2+1):\n    ans += li[i]*li[i-k]\nprint(ans)", "n, k = list(map(int, input().split()))\nk = abs(k)\n# a+b=p\u3068\u3059\u308b\n# p\u306f\u3001K+2\u304b\u30892N\u307e\u3067\u306e2N-K-1\u901a\u308a\u3042\u308b\n# N+1\u4ee5\u4e0b\u306e\u3042\u308bp\u306b\u3064\u3044\u3066a, b\u306e\u6c7a\u3081\u65b9\u306fp-1\u901a\u308a\n# N+2\u4ee5\u4e0a\u306e\u3042\u308bp\u306b\u3064\u3044\u3066a, b\u306e\u6c7a\u3081\u65b9\u306f2N-p+1\u901a\u308a\n###\n# c+d=p-K\u3068\u3059\u308b\n# p-K\u306f\u30012\u304b\u30892N-K\u307e\u3067\u306e2N-K-1\u901a\u308a\u3042\u308b\n# N+K+1\u4ee5\u4e0b\u306e\u3042\u308bp\u306b\u3064\u3044\u3066c, d\u306e\u6c7a\u3081\u65b9\u306fp-K-1\u901a\u308a\n# N+K+2\u4ee5\u4e0a\u306e\u3042\u308bp\u306b\u3064\u3044\u3066c, d\u306e\u6c7a\u3081\u65b9\u306f2N-p+K+1\u901a\u308a\n###\n# \u4ee5\u4e0a\u3088\u308a\u3001\n# p<=N+1\u306b\u3064\u3044\u3066\u3001a,b,c,d\u306e\u7d44\u307f\u5408\u308f\u305b\u306f(p-1)(p-K-1)\n# N+2<=p<=N+K+1\u306b\u3064\u3044\u3066\u3001\u7d44\u307f\u5408\u308f\u305b\u306f(2N-p+1)(p-K-1)\n# p>=N+K+2\u306b\u3064\u3044\u3066\u3001\u7d44\u307f\u5408\u308f\u305b\u306f(2N-p+1)(2N-p+K+1)\nresult = 0\nfor p in range(k + 2, 2 * n + 1):\n  if p <= (n + 1):\n    result = result + (p - 1) * (p - k - 1)\n  elif (n + 2) <= p <= (n + k + 1):\n    result = result + (2 * n - p + 1) * (p - k - 1)\n  else:\n    result = result + (2 * n - p + 1) * (2 * n - p + k + 1)\n    \nprint(result)\n", "n, k = list(map(int, input().split()))\n\n# a+b = x, c+d = y, y=x-k\ncnt = 0\n\nfor y in range(2, 2*n+1):\n  if y <=n:\n    q = y -1\n  else:\n    q = 2*n -y +1\n  x = k+y\n  if 2<= x <=2*n:\n    if x <= n:\n      p = x-1\n    else:\n      p = 2*n -x + 1\n      \n    cnt += p*q\nprint(cnt)\n", "#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN,K = readInts()\ndef calc(n):\n    if n <= 0 or n > 2*N:\n        return 0\n    else:\n        return min(n-1, 2*N-n+1)\nans = 0\nfor AB in range(2*N+1):\n    #print(AB,calc(AB),AB-K, calc(K-AB))\n    ans += calc(AB) * calc(AB-K)\nprint(ans)\n", "n,k = map(int,input().split())\ndef g(t):\n    if t<2 or 2*n<t:\n        return 0\n    if dp[t]>-1:\n        return dp[t]\n    if t-1<=n:\n        dp[t]=t-1\n        return dp[t]\n    if t-1>n:\n        dp[t]=2*n+1-t\n        return dp[t]\n\ndp = [-1]*(2*n+1)\n\nans = 0\nfor i in range(2,2*n+1):\n    ans +=g(i)*g(i+k)\nprint(ans)", "n,k = map(int,input().split())\nk = abs(k)\nA = B = ans = 0\nvalue = [False]*(2*n+1)\nfor i in range(k+2,2*n+1):\n    A = i\n    B = A - k\n    if n+1 >= A:\n        C = A-1\n    else:\n        AA = abs(A - 2*n - 2)\n        C = AA-1\n    if n+1 >= B:\n        D = B-1\n    else:\n        BB = abs(B - 2*n - 2)\n        D = BB-1\n    ans += C*D\nprint(ans)", "N,K=map(int,input().split())\nP=[]\nfor i in range(2*N+1):\n  P.append(min(i-1,2*N+1-i))\n  \nans=0\nfor i in range(2,2*N+1):\n  if 2<=i-K<=2*N:\n    ans+=P[i]*P[i-K]\n  \nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\nread = lambda:sys.stdin.readline()\n\ndef read_ints():\n    return list(map(int,read().split()))\ndef read_intgrid(h):\n    return list(list(map(int,read().split()))for i in range(h))\ndef read_strgrid(h):\n    return list(list(read())for i in range(h))\n\ndef main():\n    #input data\n    n,k = map(int,read().split())\n    #solve\n    '''\n    \u534a\u5206\u5168\u5217\u6319\u3059\u308b\u3002n\u4ee5\u4e0b\u306e\u6570\u3067\u4f5c\u308c\u308b\u6570r\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u8003\u3048\u308b\u30af\u30ed\u30b9\u8868\u4f5c\u308c\u3070\u308f\u304b\u308b\u3002\n    r==n+1\u306e\u6642\u3001n\u500b\n    r<n+1\u306e\u6642\u3001r-1\n    r>n+1\u306e\u6642\u30012n-r+!\n    '''\n    k = abs(k)\n    combs = [0]*(n*2+1)\n    for i in range(1,n*2+1):\n        if i==n+1:combs[i]=n\n        elif i<n+1:combs[i]=i-1\n        elif i>n+1:combs[i]=2*n-i+1\n\n    cnt = 0\n    for i in range(1,n*2+1):\n        cnt+=combs[i]*combs[max(0,i-k)]\n\n    # print(combs)\n    print(cnt)\n    \n    return None\ndef __starting_point():\n    main()\n__starting_point()", "N, K = map(int, input().split())\nDN = 2 * N\nans = 0\nfor ab in range(2, DN + 1):\n    cd = ab - K\n    if cd < 2 or cd > DN:\n        continue\n    ans += min(DN - ab + 1, ab - 1) * min(DN - cd + 1, cd - 1)\nprint(ans)", "N, K = list(map(int, input().split()))\nans = 0\nfor ab in range(2, 2 * N + 1):\n    cd = ab - K\n    if not (2 <= cd <= 2 * N):\n        continue\n    ans += min(ab - 1, 2 * N - ab + 1) * min(cd - 1, 2 * N - cd + 1)\nprint(ans)\n", "n,k = list(map(int, input().split()))\nans = 0\nfor i in range(2, 2*n+1):\n    if 2 <= i-k <= 2*n:\n        ans += max(0, min(i-1, n)-max(i-n, 1)+1)*max(0, min(i-k-1, n)-max(i-k-n, 1)+1)\nprint(ans)\n", "N,K=map(int,input().split())\nalpha=2\nsum=0\nwhile alpha<=2*N:\n  beta=alpha-K\n  if 2<=beta and beta<=2*N:\n    if alpha<=N+1:\n      if beta<=N+1:\n        sum+=(alpha-1)*(beta-1)\n      else:\n        sum+=(alpha-1)*(2*N-beta+1)\n    else:\n      if beta<=N+1:\n        sum+=(2*N-alpha+1)*(beta-1)\n      else:\n        sum+=(2*N-alpha+1)*(2*N-beta+1)\n  alpha+=1\nprint(sum)", "def MII(): return map(int, input().split())\nn,k=MII()\ncount=0\n#x=a+b,y=c+d\nfor x in range(2,2*n+1):\n    y=x-k\n    if 2<=y<=2*n:\n        abmax=min(x-1,n)\n        abmin=x-abmax\n        cdmax=min(y-1,n)\n        cdmin=y-cdmax\n        count += (abmax-abmin+1)*(cdmax-cdmin+1)\nprint(count)", "import sys\nsys.setrecursionlimit(10**9)\nread = lambda:sys.stdin.readline()\n\ndef read_ints():\n    return list(map(int,read().split()))\ndef read_intgrid(h):\n    return list(list(map(int,read().split()))for i in range(h))\ndef read_strgrid(h):\n    return list(list(read())for i in range(h))\n\ndef main():\n    #input data\n    n,k = map(int,input().split())\n    #solve\n    '''\n    \u534a\u5206\u5168\u5217\u6319\u3059\u308b\u3002n\u4ee5\u4e0b\u306e\u6570\u3067\u4f5c\u308c\u308b\u6570r\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u8003\u3048\u308b\u30af\u30ed\u30b9\u8868\u4f5c\u308c\u3070\u308f\u304b\u308b\u3002\n    r==n+1\u306e\u6642\u3001n\u500b\n    r<n+1\u306e\u6642\u3001r-1\n    r>n+1\u306e\u6642\u30012n-r+!\n    '''\n    k = abs(k)\n    combs = [0]*(n*2+1)\n    for i in range(1,n*2+1):\n        if i==n+1:combs[i]=n\n        elif i<n+1:combs[i]=i-1\n        elif i>n+1:combs[i]=2*n-i+1\n\n    cnt = 0\n    for i in range(1,n*2+1):\n        cnt+=combs[i]*combs[max(0,i-k)]\n\n    # print(combs)\n    print(cnt)\n    \n    return None\ndef __starting_point():\n    main()\n__starting_point()", "N, K = list(map(int, input().split()))\n\nK = abs(K)\n\nans = 0\nfor i in range(K+2, 2*N+1):\n    Big = i\n    Small = i - K\n    # print('Big: ', i)\n    # print('Small: ', i-K)\n\n    if Big <= N+1:\n        pattern_of_big = Big - 1\n    else:\n        tmp = Big - N\n        pattern_of_big = N - tmp + 1\n\n    if Small <= N+1:\n        patter_of_small = Small - 1\n    else:\n        tmp = Small - N\n        patter_of_small = N - tmp + 1\n    \n    ans += pattern_of_big * patter_of_small\n    # print(('tuika: ', pattern_of_big * patter_of_small))\n\nprint(ans)\n", "N,K=[int(x) for x in input().split()]\n\ndef conb(x):\n    if x > N:\n        return max((2*N)-x+1,0)\n    else:\n        return max(x-1,0)\n\nans = 0\n\nfor i in range(1,2*N+1):\n    ans += conb(i+K)*conb(i)\n\nprint(ans)\n\n\n", "N, K = list(map(int, input().split()))\nans = 0\nfor i in range(2, 2 * N + 1):\n    ab = min(i - 1, 2 * N - i + 1)\n    cd = min(i - K - 1, 2 * N - i + K + 1)\n    if 1 <= ab <= N and 1 <= cd <= N:\n        ans += ab * cd\n\nprint(ans)\n", "N, K = list(map(int, input().split(' ')))\n\nK = abs(K)\n\nresult = 0\nfor i in range(K+2, 2*N+1):\n  AB = i\n  CD = AB - K\n  AB -= max(0, (AB-(N+1)) * 2)\n  CD -= max(0, (CD-(N+1)) * 2)\n  result += (AB - 1) * (CD - 1)\n  \nprint(result)\n", "N, K = map(int, input().split())\ntable = [0] * (2 * N + 1)\n\nfor i in range(N):\n    table[N + i] = table[N - i] = N - i\nans = 0\n\nfor i in range(2 * N + 1):\n    if  0 <= (j := (K - (i - N) + N)) < 2 * N + 1:\n        ans += table[i] * table[j]\nprint(ans)", "n,k = map(int,input().split())\nk = abs(k)\nprint(sum(min(i-1,2*n-i+1)*min(j-1,2*n-j+1) for i,j in zip(range(2+k,n*2+1),range(2,n*2+1-k))))", "n, k = map(int, input().split())\nans = 0\n\ndef f(y):\n    if 1 <= y <= n+1: return y-1\n    else: return 2*(n+1)-y-1\n\nfor A in range(2, 2*n+1):\n    B = A-k\n    if 2 <= B <= 2*n:\n        ans += f(A)*f(B)\n\nprint(ans)", "import bisect\n\nN, K = map(int,input().split())\n\nans = 0\n\nfor i in range(2,2*N+1):\n    if 2 <= i - K <= 2*N:\n        ans = min((i-K) - 1, 2*N - (i-K) + 1) * min(i - 1, 2*N - i + 1) + ans\n        \nprint(ans)", "import sys\nN,K=map(int, input().split())\ncnt=0\nfor q in range(max(2-K,2),min(2*N-K+1,2*N+1)):\n    p=K+q\n    if p-1>N and q-1>N:\n        #print(\"p\",p)\n        cnt=cnt+(abs(2*N-p)+1)*(abs(2*N-q)+1)\n        #print(\"q=\",q,cnt)\n    elif q-1>N:\n        #print(\"q\",q)\n        cnt=cnt+(abs(2*N-q)+1)*(p-1)\n        #print(\"q=\",q,cnt)\n    elif p-1>N:\n        #print(\"p\",p)\n        cnt=cnt+(abs(2*N-p)+1)*(q-1)\n        #print(\"q=\",q,cnt)\n    else:\n        cnt=cnt+(q-1)*(p-1)\n        #print(\"q=\",q,cnt)\nprint(cnt)", "#!/usr/bin/env python3\n\n\"\"\"\ndef factorial(n):\n    res = 1\n    for i in range(n+1):\n        res *= i\n    return res\n\ndef C(n, r):\n    return factorial(n) / (factorial(r) * factorial(n-r)) \n\ndef pattern(P, N):\n    if P > N*2:\n        return 0\n    else:\n        return P-1-(P-N-1)*2\n\nN, K = map(int,(input().split()))\n\nshita = 2 + K\nue = N * 2\n\nres = 0\n\nfor i in range(shita, ue+1):\n    k_side = pattern(i, N)\n    no_k_side = pattern(i, N)\n    print(i, k_side, no_k_side)\n    res += k_side * no_k_side    \n\nprint(res)\n\"\"\"\n\n# \u89e3\u8aacAC\u3092\u76ee\u6307\u3059\n\"\"\"\n1 <= a,b <= N\u306e\u6761\u4ef6\u4e0b\u3067\u3001a + b = K\u3092\u6e80\u305f\u3059\u6574\u6570\u306e\u7d44\u306f\u3001min(K-1, 2N + 1 - K)\u3067\u3042\u308b\u3002\nN\u304c\u5927\u304d\u3044\u3068\u304d\u306fa\u3068b\u306e\u4ed5\u5207\u308a\u306f\u81ea\u7531\u306b\u5165\u308c\u308c\u3070\u3088\u3044\u3002\nN\u304c\u5927\u304d\u304f\u306a\u3044\u3001\u4f8b\u3048\u3070K=12, N=7\u306a\u3089\n\u25cb\u25cb\u25cb\u25cb\u25cf\u25cf\u25cf\u25cb\u25cb\u25cb\u25cb\u25cb\u3067\u3001\u25cf\u306e\u53f3\u306b\u4ed5\u5207\u308a\u3092\u5165\u308c\u3066\u3001a\u3068b\u3092\u5206\u3051\u308b\u3002\n\u4e00\u756a\u5de6\u306e\u25cf\u306fK-N\u756a\u76ee\u3001\u4e00\u756a\u53f3\u306e\u25cf\u306fK\u756a\u76ee\u3067\u3042\u308b\u305f\u3081\u3001\u25cf\u306f\u3001N-(K-N)+1\u500b\u3042\u308b\u3068\u8003\u3048\u308b\u3002\nN\u304c\u3068\u3066\u3082\u5c0f\u3055\u3044\u3068\u304d\u3001\u4f8b\u3048\u3070K=12, N=2\u306a\u30890\u3067\u3042\u308b\u3002\n\n\u3053\u3053\u3067\u3001a+b-c-d = K \u21d4 a+b = K + c+d\u3067\u3042\u308b\u306e\u3067\u3001\n\u3042\u308bx\u3092\u5b9a\u3081\u3066\u3001a+b = x\u3068\u306a\u308ba,b\u306e\u7d44\u3068\u3001c+d = x-K\u3068\u306a\u308bc,d\u306e\u7d44\u3092\u305d\u308c\u305e\u308c\u6c42\u3081\u3066\u304b\u3051\u5408\u308f\u305b\u308c\u3070\u826f\u3044\u3002\n\nx\u306f2\u304b\u30892N\u307e\u3067\u306e\u7bc4\u56f2\u3092\u52d5\u304f\u3002\n\"\"\"\n\nN, K = map(int,(input().split()))\n\npattern = lambda x, K: max(0, min(K-1, 2*x + 1 - K)) # \u3053\u308c\u3092min\u3067\u307e\u3068\u3081\u308b\u306e\u304b\u30fc\u3002\n\nres = 0\n\nfor x in range(2, 2 * N + 1):\n    res += pattern(N, x) * pattern(N, x-K)\n\nprint(res)", "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(10**6)\n\ndef inp():\n    return int(input())\ndef inps():\n    return input().rstrip()\ndef inpl():\n    return list(map(int, input().split()))\ndef inpls():\n    return list(map(str, input().split()))\n\n# import decimal\n# from decimal import Decimal\n# decimal.getcontext().prec = 10\n\n# from heapq import heappush, heappop, heapify\n# import math\nfrom math import gcd, floor, ceil, factorial\nimport itertools as it\nfrom collections import deque, defaultdict\nfrom collections import Counter\n\ndef lcd(a, b):\n    return a * b // gcd(a, b)\n\ndef chmin(dp, i, x):\n    if x < dp[i]: dp[i] = x; return True\n    return False\n\ndef chmax(dp, i, x): \n    if x > dp[i]: dp[i] = x; return True\n    return False\n\n# ---------------------------------------\n\nN, K = inpl()\nmn = 1 * 2\nmx = N * 2\nmid = (mx - mn) // 2 + mn\n\ndp = [0] * (mx + 1)\nfor i in range(mn, mx + 1):\n    dp[i] = mid - abs(i - mid) - 1\n\nans = 0\nfor i in range(mn, mx + 1):\n    j = i - K\n    if mn <= j <= mx:\n        ans += dp[i] * dp[j]\n\nprint(ans)\n", "N, K = list(map(int, input().split()))\nK = abs(K)\n\nans = 0\nab = 2*N\npat = 1\nwhile ab - K >= 2:\n    if ab-K >= (2+2*N)//2:\n        ans += (pat + K)*pat\n    else:\n        ans += (ab - K - 2 + 1)*pat\n    ab -= 1\n    if ab  >= (2+2*N)//2:\n        pat += 1\n    else:\n        pat -= 1\nprint(ans)\n\n\n", "N, K = map(int, input().split())\nans = 0\nfor B in range(2, 2*N+1):\n    A = K + B\n    if A < 2 or A > 2*N:\n        continue\n    a_n = min(A-1, 2*N + 1 - A)\n    b_n = min(B-1, 2*N + 1 - B)\n    ans += a_n * b_n\n\nprint(ans)", "#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN, K = readInts()\n\ndef calc(n):\n    if n <= 0:\n        return 0\n    elif n > 2 * N:\n        return 0\n    else:\n        return min(2*N-n+1, n-1)\n\nans = 0\nfor i in range(1,2*N+1):\n    ans += calc(i) * calc(i-K)\nprint(ans)\n", "N,K = list(map(int,input().split()))\nans = 0\nfor i in range(2,2*N+1):\n    A = i\n    B = i-K\n    if 2*N>=B>=2:\n        X = min(N,A-1)-max(1,A-N)+1\n        Y = min(N,B-1)-max(1,B-N)+1\n        ans += X*Y\n       \n        \nprint(ans)\n\n", "N, K = list(map(int, input().split()))\n\nans = 0\nfor ac in range(1 - N, N):\n    db = ac - K\n    if db < 1 - N or N - 1 < db:\n        continue\n    ans += (N - abs(ac)) * (N - abs(db))\nprint(ans)\n", "N,K = map(int,input().split())\n\ndef f(t):\n    if 2 <= t <= N+1:\n        return t - 1\n    elif N+1 <= t <= 2*N:\n        return 2*N + 1 - t\n    else:\n        return 0\ns = 0\nfor y in range(2,2*N+1):\n    s += f(y)*f(y+K)\n\nprint(s)", "N, K = list(map(int, input().split()))\n\nans = 0\nfor i in range(2, 2*N+1):\n    j = i - K\n    if not 2 <= j <= 2 * N:\n        continue\n\n\n    ta = (i-1)-(i-1-N)*2\n    A = min(i-1, ta)\n\n\n    tc = (j-1)-(j-1-N)*2\n    C = min(j-1, tc)\n\n\n\n\n    ans += A * C\n\nprint(ans)\n", "N,K = map(int,input().split())\ncnt = 0\nfor X in range(2,2*N+1):\n    Y = X-K\n    if 2<=Y<=2*N:\n        if X<=N+1:\n            cx = X-1\n        else:\n            cx = 2*N+1-X\n        if Y<=N+1:\n            cy = Y-1\n        else:\n            cy = 2*N+1-Y\n        cnt += cx*cy\nprint(cnt)", "n, k = map(int, input().split())\n\n\ndef count(s):\n    return min(s-1, 2*n + 1 - s)\n\nans = 0\nfor i in range(2, 2*n+1):\n    if 2<=i-k<=2*n:\n        ans += count(i)*count(i-k)\n\nprint(ans)", "def f(x):\n    return min(x - 1, 2 * N - x + 1)\n\nN, K = map(int, input().split())\nans = 0\nfor ab in range(2, 2 * N + 1):\n    cd = ab - K\n    if cd < 2 or 2 * N + 1 < cd:\n        continue\n    ans += f(ab) * f(cd)\nprint(ans)", "N, K = list(map(int, input().split()))\n\nans = 0\nfor i in range(2, 2*N+1):\n    ans += min(i-1, 2*N-i+1) * max(0,min(i-K-1, 2*N-i+K+1))\nprint(ans)\n", "n,k = list(map(int,input().split()))\nans = 0\n\n# x = a + b \u3068\u3057\u3066\u30eb\u30fc\u30d7\nfor x in range(2,2*n+1):\n    if 1 < x - k <= 2*n:\n        ans += min(x-1, 2*n+1-x) * min(x-k-1, 2*n+1-x+k)\n\nprint(ans)\n", "n,k=map(int,input().split())\n\ndef half(v):\n    if 2<=v<=n+1:\n        return v-1\n    elif n+2<=v<=2*n:\n        return 2*n+1-v\n    else:\n        return 0\n\nans=0\nfor i in range(2,2*n+1):\n    ans+=half(i)*half(i-k)\n\nprint(ans)", "n, k = map(int, input().split())\n\ncnt = 0\nfor ab in range(1 - n, n):\n    cd = k - ab\n    if 1 - n <= cd <= n - 1:\n        cnt += (n - abs(ab)) * (n - abs(cd))\n\nprint(cnt)", "import sys\nfrom math import gcd, factorial, ceil, floor, sqrt\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations, combinations, product, accumulate\nfrom collections import defaultdict, deque, Counter\nfrom functools import lru_cache\nsys.setrecursionlimit(10**8)\n\nii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(map(int, input().split()))\n\nN, K = mi()\n\nans = 0\nls = []\nfor i in range(-N+1, N):\n    if K-i<N and K-i>=-N+1:\n        A = i\n        B = K-A\n        ans += ((N-abs(B))*(N-abs(A)))\nprint(ans)", "n,k = list(map(int,input().split()))\nkazu = [0] + [i for i in range(n+1)]\nrev_kazu = sorted(kazu[:n+1],reverse = True)\nkazu += rev_kazu\n#print(kazu)\nans = 0\nfor A in range(2,2*n+1):\n    B = A - k\n    if B >= 2 and B <= 2*n:\n        ans += kazu[A]*kazu[B]\nprint(ans)\n", "N,K=map(int,input().split())\nK=abs(K)\nnum=[0]*(2*N+1)\nfor v in range(2,2*N+1):\n  num[v]=min(v-1,2*N+1-v)\nres=0\nfor v in range(K,2*N+1):\n  res+=num[v]*num[v-K]\nprint(res)", "import sys\ntry:\n    import os\n    f = open('input.txt', 'r')\n    sys.stdin = f\nexcept FileNotFoundError:\n    None\nfrom math import sqrt, ceil, floor\nfrom collections import deque, Counter, defaultdict\n# defaultdict(int)\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright, insort\nfrom itertools import combinations as com, permutations as per\nfrom fractions import Fraction as frac  #frac(a,b)\u3067\u6b63\u78ba\u306aa/b\n# @lru_cache(maxsize=10**10)\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\n\nn,k=list(map(int,input().split()))\nans=0\n\ndef num(j):\n\n    if 2>j: return 0\n    if j>2*n: return 0\n    if j<n+1:\n        return j-1\n    sa= 2*(j-n-1)\n    return j-1-sa\n# a=0\n# for i in range(max(2,2+k),2*n+1):\n#     a+= num(i)\n# c=0\n# for i in range(2,2*n-k+1):\n#     c+= num(i)\n\nfor i in range(2,2*n-k+1):\n    # print(\"kore\",i+k,i,)2525 -425\n\n    a= num(i+k)\n    b = num(i)\n    ans+= a*b\n    # print(a,b)\n\nprint(ans)\n", "n, k = map(int, input().split())\nk = abs(k)\n\nans = 0\nfor x in range(k + 2, 2*n + 1):\n    b = min(n, x - 1)\n    a = x - b\n    res1 = b - a + 1\n\n    c = min(n, x - k - 1)\n    d = x - k - c\n    res2 = c - d + 1\n    ans += res1 * res2\n\nprint(ans)", "from sys import stdin\ninput = lambda : stdin.readline().strip()\n\ndef main():\n    N, K = list(map(int, input().split()))\n    N = 2 * (N - 1)\n    K = abs(K)\n    ans = sum((1 + min(i + K, N - i - K)) * (1 + min(i, N - i)) for i in range(N - K + 1))\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nN, K = map(int, input().split())\nK = abs(K)\nC = np.array([*range(-1, N), *range(N, 0, -1)], dtype=np.int64)\nC[0] = 0\nprint(C[:-K] @ C[K:] if K else C @ C)", "n, k =  map(int, input().split())\n# a+b=x\u306e\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\u3092\u7ba1\u7406\u3059\u308b\u914d\u5217\nP = [0 for  _ in range(2*n+1)]\n\nif k < 0:\n    k =  -k\nfor x in range(1, 2*n+1):\n    P[x] =  min(x-1, 2*n+1-x)\n\nans =  0\nfor i in range(k+2, 2*n+1):\n    ans += P[i]*P[i-k]\nprint(ans)", "n,k=list(map(int,input().split()))\n\ndef ab(v):\n    if 2<=v<=n+1:\n        return v-1\n    elif n+2<=v<=2*n:\n        return 2*n+1-v\n# min(v-1, 2*n+1-v) is available as contents of above def \n    else:\n        return 0\n\nans=0\nfor i in range(2,2*n+1):\n    ans+=ab(i)*ab(i-k)\n\nprint(ans)\n", "n, k = map(int, input().split())\n\ncnt = 0\nfor ac in range(1 - n, n):\n    bd = k - ac\n    if 1 - n <= bd <= n - 1:\n        cnt += (n - abs(ac)) * (n - abs(bd))\n\nprint(cnt)", "n,k=list(map(int,input().split()))\n\ndp=[0]*(2*n+1) # 0,1,2~2n\n\n\nfor ii in range(1,n+1):\n  # dp[2]~dp[n]\n  dp[ii+1]=ii # ii+1 = [1,2,...,ii] + [ii,ii-1,...,1]\n  # dp[n+1]~dp[n+n]\n  dp[ii+n]=n-ii+1 # n+ii = [ii,ii+1,...,n] + [n,n-1,...,ii]\n\nr=0\nfor ab in range(2,2*n+1):\n  cd = ab - k # k=ab-cd\n  if cd > 1 and cd <= 2*n:\n    r+=dp[ab]*dp[cd]\nprint(r)\n", "def f(n, x):\n    # 1<=a,b<=n and a+b=x\n    if x < 2 or 2 * n < x:\n        return 0\n    return abs(x - 2 * min(x - 1, n)) + 1\n\n\nn, k = list(map(int, input().split()))\nprint((sum(f(n, x) * f(n, x + k) for x in range(2, 2 * n - k + 1))))\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**7)\nimport bisect\nimport heapq\nimport itertools\nimport math\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom math import gcd\nfrom operator import add, itemgetter, mul, xor\ndef cmb(n,r,mod):\n  bunshi=1\n  bunbo=1\n  for i in range(r):\n    bunbo = bunbo*(i+1)%mod\n    bunshi = bunshi*(n-i)%mod\n  return (bunshi*pow(bunbo,mod-2,mod))%mod\nmod = 998244353\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return list(map(int,input().split()))\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\n\n#bisect.bisect_left(list,key)\u306flist\u306e\u306a\u304b\u3067key\u672a\u6e80\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3064\u307e\u308alist[i] < x \u3068\u306a\u308b i \u306e\u500b\u6570\n#bisect.bisect_right(list, key)\u306flist\u306e\u306a\u304b\u3067key\u4ee5\u4e0b\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3064\u307e\u308alist[i] <= x \u3068\u306a\u308b i \u306e\u500b\u6570\n#\u3053\u308c\u3092\u5fdc\u7528\u3059\u308b\u3053\u3068\u3067\n#len(list) - bisect.bisect_left(list,key)\u306flist\u306e\u306a\u304b\u3067key\u4ee5\u4e0a\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#len(list) - bisect.bisect_right(list,key)\u306flist\u306e\u306a\u304b\u3067key\u3088\u308a\u5927\u304d\u3044\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3053\u308c\u3089\u3092\u4f7f\u3046\u3068\u304d\u306f\u3042\u3089\u304b\u3058\u3081list\u3092\u30bd\u30fc\u30c8\u3057\u3066\u304a\u304f\u3053\u3068\uff01\n\ndef func(n,k):\n    return min(k-1,2*n+1-k)\nn,k = MI()\nA = max(2,2+k)\nB = min (2*n,2*n+k)\nans = 0\nfor x in range(A,B+1):\n    ans += func(n,x)*func(n,x-k)\nprint(ans)\n    \n\n    \n"]
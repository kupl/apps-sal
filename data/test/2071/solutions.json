["n = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndef f(l):\n    s = sum(l)\n    sume = [s for i in range(n)]\n    s3 = [0 for i in range(n)]\n    ts = 0\n    for i in range(1, n):\n        sume[i] = sume[i - 1] - l[i - 1]\n        ts += i * l[i]\n        s3[n - i - 1] = s3[n - i] + i * l[n - i - 1]\n    s2 = [ts for i in range(n)]\n    for i in range(1, n):\n        s2[i] = s2[i - 1] - (i - 1) * l[i - 1]\n    return sume, s2, s3\n\na1, a2, a3 = f(a)\nb1, b2, b3 = f(b)\n\nbest = 0\ncurr, t = 0, 0\nfor i in range(n):\n    if i % 2 == 0:\n        pot = curr + t * a1[i] + a2[i] - i * a1[i] +\\\n                (t + n - i) * b1[i] + b3[i]\n    else:\n        pot = curr + t * b1[i] + b2[i] - i * b1[i] +\\\n                (t + n - i) * a1[i] + a3[i]\n    best = max(best, pot)\n    if i % 2 == 0:\n        curr += t * a[i] + (t + 1) * b[i]\n    else:\n        curr += t * b[i] + (t + 1) * a[i]\n    t += 2\nprint(max(best, curr))\n", "from sys import stdin\nfrom math import *\n\nline = stdin.readline().rstrip().split()\nn = int(line[0])\n\nnumbers = list(map(int, stdin.readline().rstrip().split()))\nnumbers2 = list(map(int, stdin.readline().rstrip().split()))\n\ngrowRateAccum = 0\ntopAccum = 0\nbottomAccum = 0\n\naccumsB = [0]*n\naccumsT = [0]*n\n\ngrowRateAccum = 0\naccum = 0\nfor i in range(n-1, -1, -1):\n    accum += numbers[i] * (((n-i)*2)-1-1)\n    growRateAccum += numbers[i]\n    if i<n-1:\n        growRateAccum += numbers2[i + 1]\n    accum += growRateAccum\n    accumsB[i] = accum\n\ngrowRateAccum = 0\naccum = 0\nfor i in range(n-1, -1, -1):\n    accum += numbers2[i] * (((n-i)*2)-1-1)\n    growRateAccum += numbers2[i]\n    if i<n-1:\n        growRateAccum += numbers[i + 1]\n    accum += growRateAccum\n    accumsT[i] = accum\n\n\n#for i in range(n-1, -1, -1):\n#    if i % 2 == 0:\n#        if i == n-1:\n#            accums[i] = numbers2[i]\n#        else:\n #           bottomAccum += numbers2[i]*((n-i)*2-1)\n  #          growRateAccum += numbers2[i] + numbers[i+1]\n   #         bottomAccum += growRateAccum\n#        accums[i] = bottomAccum\n #   if i % 2 == 1:\n  #      if i == n-1:\n  #          accums[i] = numbers2[i]\n  #      else:\n   #         topAccum += numbers[i]*((n-i)*2-1)\n   #         growRateAccum += numbers[i] + numbers2[i+1]\n   #         topAccum += growRateAccum\n   #         accums[i] = topAccum\ncMax = 0\ncurrAccum = 0\n\ngrowRateAccum = sum(numbers[1::]) + sum(numbers2[1::])\n\nfor i in range(n):\n    if i%2==0:\n        #estoy en top:\n        cMax = max(cMax, currAccum+accumsT[i])\n    else:\n        cMax = max(cMax, currAccum + accumsB[i])\n    if(i<n-1):\n        if i%2 == 0:\n            currAccum += numbers2[i] + growRateAccum * 2\n        else:\n            currAccum += numbers[i] + growRateAccum * 2\n        growRateAccum -= numbers[i+1]\n        growRateAccum -= numbers2[i+1]\nprint(cMax)\n\n", "def main():\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tB = list(map(int, input().split()))\n\n\troundup = []\n\trounddown = []\n\tsumsofar = []\n\n\tfor i, (a, b) in enumerate(zip(reversed(A), reversed(B))):\n\t\tssf = sumsofar[-1] if sumsofar else 0\n\t\tt = roundup[-1] if roundup else 0\n\t\troundup.append(t + ssf + b * (1 + 2*i))\n\t\tt = rounddown[-1] if rounddown else 0\n\t\trounddown.append(t + ssf + a * (1 + 2*i))\n\t\tsumsofar.append(ssf + a + b)\n\n\troundup = list(reversed(roundup))\n\trounddown = list(reversed(rounddown))\n\tsumsofar = list(reversed(sumsofar))\n\tbestres = 0\n\tsofar = 0\n\n\t# for u, d in zip(roundup, rounddown):\n\t# \tprint(u, d, '-')\n\n\tfor i, (a, b) in enumerate(zip(A, B)):\n\t\trup, rdo = roundup, rounddown\n\t\tif i%2:\n\t\t\ta, b = b, a\n\t\t\trup, rdo = rdo, rup\n\t\t# print(i, sofar + rup[i])\n\t\tbestres = max(bestres, sofar + rup[i] + sumsofar[i] * 2*i)\n\t\tsofar += a*2*i\n\t\tsofar += b*(2*i+1)\n\t\tbestres = max(bestres, sofar)\n\n\tprint(bestres)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "n = int(input())\na = [[int(i) for i in input().split()], [int(i) for i in input().split()]]\ns = 0\nsumlist = []\nfor i in reversed(list(range(n))):\n    s += a[0][i] + a[1][i]\n    sumlist.append(s)\nsumlist = [0] + sumlist\n\ns = 0\nvalue = [[0] * (n + 1), [0] * (n + 1)]\nfor i in range(n):\n    s += a[0][n - i - 1] * (2 * n - i * 2 - 2) + a[1][n - i - 1] * (2 * n - 1)\n    s -= sumlist[i]\n    value[1][n - i - 1] = s\n\ns = 0\nfor i in range(n):\n    s += a[1][n - i - 1] * (2 * n - i * 2 - 2) + a[0][n - i - 1] * (2 * n - 1)\n    s -= sumlist[i]\n    value[0][n - i - 1] = s\n\nans = value[1][0]\ncount = 0\ns = 0\n#print(value)\nfor i in range(n):\n    if i % 2 == 0:\n        s += a[0][i] * (2 * i) + a[1][i] * (2 * i + 1)\n    else:\n        s += a[1][i] * (2 * i) + a[0][i] * (2 * i + 1)\n    ans = max(ans, s + value[i % 2][(i + 1)])\n  #  print(s + value[i % 2][(i + 1)])\n\nprint(ans)\n", "\ndef getss(a):\n    n = len(a)\n    ps = [0] * (n+1)\n    for i in range(n-1,0,-1):\n        ps[i] = ps[i+1] + a[i]\n    return ps\n\ndef getSum(a, b):\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        ans += a[i] * i\n    for i in range(n, 2*n):\n        ans += b[2*n-i-1] * i\n    return ans   \n\ndef main():\n    n, = list(map(int, input().split(' ')))\n    a = [x for x in map(int, input().split(' '))]\n    b = [x for x in map(int, input().split(' '))]\n\n    if n == 1:\n        print(b[0])\n        return\n\n    ssa = getss(a)\n    ssb = getss(b)\n    \n    tans = getSum(a, b)\n    ans = tans\n    for i in range(0, n - 1, 2):\n        tans -= (i*2) * a[i] + (i*2+1) * a[i+1] + (2*n-1)*b[i] + (2*n-2)*b[i+1]\n        tans += (i*2) * a[i] + (i*2+3) * a[i+1] + (i*2+1)*b[i] + (i*2+2)*b[i+1]\n        tans += 2 * ssa[i+2] + 2 * ssb[i+2]\n        ans = max(ans, tans)\n    \n    tans = getSum(b, a)\n    tans -= (2*n-1) * a[0]\n    tans += b[0]\n    tans += ssa[1] + ssb[1]\n    ans = max(ans, tans)\n    for i in range(1, n - 1, 2):\n        tans -= (i*2) * b[i] + (i*2+1) * b[i+1] + (2*n-1)*a[i] + (2*n-2)*a[i+1]\n        tans += (i*2) * b[i] + (i*2+3) * b[i+1] + (i*2+1)*a[i] + (i*2+2)*a[i+1]\n        tans += 2 * ssa[i+2] + 2 * ssb[i+2]\n        ans = max(ans, tans)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nans1 = sum(a[i] * i for i in range(n)) + sum(b[-i - 1] * (n + i) for i in range(n))\nans2 = a[0] + sum(b[i] * (i + 1) for i in range(n)) + sum(a[-i - 1] * (n + 1 + i) for i in range(n - 1))\n\nN = 2 * n\nright = [0] * n\n\nif n == 1:\n    print(b[0])\n    return\n\nif n % 2:\n    s = a[-1] + b[-1]\n    right[-1] = (N - 1) * b[-1] + (N - 2) * a[-1]\n\n    for i in range(n - 3, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * b[i] + (N - 2) * b[i + 1] + (N - c + 1) * a[i + 1] + (N - c) * a[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\n    s = a[-1] + b[-1] + a[-2] + b[-2]\n    right[-2] = (N - 1) * a[-2] + (N - 2) * a[-1] + (N - 3) * b[-1] + (N - 4) * b[-2]\n\n    for i in range(n - 4, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * a[i] + (N - 2) * a[i + 1] + (N - c + 1) * b[i + 1] + (N - c) * b[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\nelse:\n    s = a[-1] + b[-1]\n    right[-1] = (N - 1) * a[-1] + (N - 2) * b[-1]\n\n    for i in range(n - 3, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * a[i] + (N - 2) * a[i + 1] + (N - c + 1) * b[i + 1] + (N - c) * b[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\n    s = a[-1] + b[-1] + a[-2] + b[-2]\n    right[-2] = (N - 1) * b[-2] + (N - 2) * b[-1] + (N - 3) * a[-1] + (N - 4) * a[-2]\n\n    for i in range(n - 4, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * b[i] + (N - 2) * b[i + 1] + (N - c + 1) * a[i + 1] + (N - c) * a[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\ntemp = [(a[i] * (2 * i) + b[i] * (2 * i + 1), a[i] * (2 * i + 1) + b[i] * (2 * i))[i % 2] for i in range(n)]\nleft = [0] + list(accumulate(temp))\nright += [0]\n\nfor_ans = [left[i] + right[i] for i in range(n + 1)]\n\nprint(max(for_ans))\n", "from itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nN = 2 * n\nright = [0] * n\n\nif n == 1:\n    print(b[0])\n    return\n\nif n % 2:\n    s = a[-1] + b[-1]\n    right[-1] = (N - 1) * b[-1] + (N - 2) * a[-1]\n\n    for i in range(n - 3, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * b[i] + (N - 2) * b[i + 1] + (N - c + 1) * a[i + 1] + (N - c) * a[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\n    s = a[-1] + b[-1] + a[-2] + b[-2]\n    right[-2] = (N - 1) * a[-2] + (N - 2) * a[-1] + (N - 3) * b[-1] + (N - 4) * b[-2]\n\n    for i in range(n - 4, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * a[i] + (N - 2) * a[i + 1] + (N - c + 1) * b[i + 1] + (N - c) * b[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\nelse:\n    s = a[-1] + b[-1]\n    right[-1] = (N - 1) * a[-1] + (N - 2) * b[-1]\n\n    for i in range(n - 3, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * a[i] + (N - 2) * a[i + 1] + (N - c + 1) * b[i + 1] + (N - c) * b[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\n    s = a[-1] + b[-1] + a[-2] + b[-2]\n    right[-2] = (N - 1) * b[-2] + (N - 2) * b[-1] + (N - 3) * a[-1] + (N - 4) * a[-2]\n\n    for i in range(n - 4, -1, -2):\n        c = (n - i) * 2\n        right[i] = right[i + 2] - 2 * s + (N - 1) * b[i] + (N - 2) * b[i + 1] + (N - c + 1) * a[i + 1] + (N - c) * a[i]\n        s += a[i] + a[i + 1] + b[i] + b[i + 1]\n\ntemp = [(a[i] * (2 * i) + b[i] * (2 * i + 1), a[i] * (2 * i + 1) + b[i] * (2 * i))[i % 2] for i in range(n)]\nleft = [0] + list(accumulate(temp))\nright += [0]\n\nfor_ans = [left[i] + right[i] for i in range(n + 1)]\n\nprint(max(for_ans))\n", "import sys\n\n\ndef main():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n\n    d_a = [0 for _ in range(len(a))]\n    d_b = [0 for _ in range(len(b))]\n\n    sum = []\n    for aa, bb in zip(reversed(a), reversed(b)):\n        if len(sum) > 0:\n            sum.append(aa + bb + sum[-1])\n        else:\n            sum.append(aa + bb)\n    sum = list(reversed(sum))\n\n    # print(sum)\n\n    d_a[-1] = b[-1]\n    d_b[-1] = a[-1]\n\n    for i in reversed(list(range(n - 1))):\n        # print(n-i)\n        # print((n - i) * 2 - 1)\n        d_a[i] = sum[i + 1] + d_a[i + 1] + ((n - i) * 2 - 1) * b[i]\n        d_b[i] = sum[i + 1] + d_b[i + 1] + ((n - i) * 2 - 1) * a[i]\n\n    ans = 0\n    cur = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            ans = max(\n                cur + d_a[i] + sum[i] * 2 * i,\n                ans\n            )\n            cur += 2 * i * a[i] + (2 * i + 1) * b[i]\n            if i + 1 < n:\n                ans = max(\n                    cur + d_b[i + 1] + sum[i + 1] * (2 * i + 2),\n                    ans\n                )\n\n        else:\n            ans = max(\n                cur + d_b[i] + sum[i] * 2 * i,\n                ans\n            )\n            cur += 2 * i * b[i] + (2 * i + 1) * a[i]\n            if i + 1 < n:\n                ans = max(\n                    cur + d_a[i + 1] + sum[i + 1] * (2 * i + 2),\n                    ans\n                )\n\n    print(ans)\n\n    return 0\n\n\ndef test(i):\n    with open(\"test_{}.txt\".format(i)) as fin:\n        sys.stdin = fin\n        main()\n\n\ndef __starting_point():\n    # test(1)\n    # test(2)\n    return(main())\n\n__starting_point()", "n=int(input())\nF=list(map(int,input().split()))\nS=list(map(int,input().split()))\n\n\nSUM=[0]*n\nSUM[n-1]=F[n-1]+S[n-1]\n\nfor i in range(n-2,-1,-1):\n    SUM[i]=SUM[i+1]+F[i]+S[i]\n\n\nANS1=0\nfor i in range(n):\n    ANS1+=F[i]*i\n    ANS1+=S[i]*(2*n-1-i)\n\nANS2=0\nfor i in range(n):\n    ANS2+=S[i]*(i+1)\nfor i in range(1,n):\n    ANS2+=F[i]*(2*n-i)\n\n\n#SABUN[i]=F[i+1]*2+S[i]*(2*n-1-i-i)+S[i+1]*(n-3-i-i)+SUM[2*i]*i\n\n\nx=ANS1\ny=ANS2\nANS=[x,y]\n\n\nfor i in range(0,max(0,n-2),2):\n    x=x+F[i+1]*2-S[i]*(2*n-2-i-i)-S[i+1]*(2*n-4-i-i)+SUM[i+2]*2\n    y=y-F[i+1]*(2*n-i-i-4)-F[i+2]*(2*n-i-i-4)+SUM[i+2]*2\n    ANS.append(x)\n    ANS.append(y)\n    #print(ANS,i)\n\nprint(max(ANS))\n\n\n\n\n", "import sys\nimport io\n\nstream_enable = 0\n\ninpstream = \"\"\"\n3\n1 2 3\n6 5 4\n\"\"\"\n\nif stream_enable:\n    sys.stdin = io.StringIO(inpstream)\n    input()\n\ndef inpmap():\n    return list(map(int, input().split()))\n\nn = int(input())\narr = [inpmap(), inpmap()]\n\ns = [0] * n\ns[-1] = arr[0][-1] + arr[1][-1]\nfor i in range(n - 2, -1, -1):\n    s[i] = s[i + 1] + arr[0][i] + arr[1][i]\n# print(s)\n\na = [0] * n\na[-1] = arr[1][-1] * 2 + arr[0][-1]\nb = [0] * n\nb[-1] = arr[0][-1] * 2 + arr[1][-1]\nfor i in range(n - 2, -1, -1):\n    a[i] = arr[0][i] + a[i + 1] + s[i + 1] + arr[1][i] * (n - i) * 2\n    b[i] = arr[1][i] + b[i + 1] + s[i + 1] + arr[0][i] * (n - i) * 2\n# print(a)\n# print(b)\n\ndp = [0] * n\ndp[-1] = arr[n % 2][-1]\nfor i in range(n - 2, -1, -1):\n    d = i % 2\n    g1 = arr[1 - d][i] + dp[i + 1] + s[i + 1] * 2\n    g2 = (a, b)[d][i + 1] + arr[1 - d][i] * ((n - i) * 2 - 1)\n    dp[i] = max(g1, g2)\nprint(dp[0])\n", "def main():\n  [n] = list(map(int, input().split(\" \")))\n  a = list(map(int, input().split(\" \")))\n  b = list(map(int, input().split(\" \")))\n  sums = []\n  for i in range(n):\n    if len(sums) == 0:\n      sums.append(a[-1]+b[-1])\n    else:\n      sums.append(sums[-1]+a[-i-1]+b[-i-1])\n  bottom_to_top = []\n  top_to_bottom = []\n  for i in range(n):\n    if i == 0:\n      bottom_to_top.append(a[-1])\n      top_to_bottom.append(b[-1])\n    else:\n      bottom_to_top.append(bottom_to_top[-1]+sums[i-1]+a[-i-1]*(2*i+1))\n      top_to_bottom.append(top_to_bottom[-1]+sums[i-1]+b[-i-1]*(2*i+1))\n  best_t = []\n  best_b = []\n  for i in range(n):\n    if i == 0:\n      best_t.append(top_to_bottom[0])\n      best_b.append(bottom_to_top[0])\n    else:\n      x = b[-i-1]+2*sums[i-1]+best_b[i-1]\n      y = a[-i-1]+2*sums[i-1]+best_t[i-1]\n      best_t.append(max([x, top_to_bottom[i]]))\n      best_b.append(max([y,bottom_to_top[i]]))\n  #print(list(reversed(best_t)))\n  #print(list(reversed(best_b)))\n  print(best_t[-1])\nmain()", "n =int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ndp = [0] * (n//2+1)\ndp2 =  [0] * (n//2+1)\nfi = 0\nse = 0\nfor i in range(n):\n  fi +=a[i] * i\n  fi +=b[-i-1] * (i+n)\ndp[0] = fi\nfor i in range(n):\n  if i != 0:\n    se +=a[-i] * (i+n)\n  se +=b[i] * (i+1)\ndp2[0] = se\ngou = sum(a)+ sum(b) -a[0]\ngou2 = gou + 0\nfor i in range(1,n//2+1):\n  gou -= (b[i*2-2] +b[i*2-1])\n  dp[i] = dp[i-1] -b[i*2-2] * (2*n-4*(i-1)-2) - b[i*2-1] * (2*n-4*(i-1)-4) + gou*2\n  if i == n//2:\n    break\n  gou -= (a[2*i]+a[2*i-1] )\nfor i in range(1,n//2+1):\n  try:\n    gou2 -= (a[2*i] + a[2*i-1]+ b[2*i-2] + b[2*i-1])\n  except:\n    break\n  dp2[i] = dp2[i-1] -a[i*2-1] * (2*n-4*(i-1)-4) - a[i*2] * (2*n-4*(i-1)-6) + gou2*2\ndp.extend(dp2)\nprint(max(dp))", "n=int(input())\nx=map(int,input().split())\na=[[],[]]\nk=0\nfor i in x:\n\ta[0].append(i)\n\tk+=i\nx=map(int,input().split())\nfor i in x:\n\ta[1].append(i)\n\tk+=i\nsum=[[0],[0]]\nfor i in range(2):\n\tfor j in range(1,n+1):\n\t\tsum[i].append(sum[i][j-1]+a[i][n-j])\nsum2=[[0],[0]]\nfor i in range(2):\n\tfor j in range(1,n+1):\n\t\tsum2[i].append(sum2[i][j-1]+sum[i][j])\nsum3=[[0],[0]]\nfor i in range(2):\n\tfor j in range(1,n+1):\n\t\tsum3[i].append(sum3[i][j-1]+a[i][n-j]*j)\nans=0\nnow=0\nfor i in range(n):\n\tpos=n-i\n\tline=i%2\n\tans=max(ans,now+sum[0][pos]*i*2+sum[1][pos]*i*2+sum2[line][pos]+sum3[1-line][pos]+sum[1-line][pos]*(n-i))\n\tnow+=(2*i+1)*a[line][i]+(2*i+2)*a[1-line][i]\nprint(ans-k)", "n = int(input())\na = [list(map(int, input().split())) for i in range(2)]\nif n != 1:\n    sum_up, pref_up, sum_down, pref_down = [[[0 for i in range(n)] for j in range(2)] for _ in range(4)]\n    for i in range(2):\n        sum_up[i][n - 1] = a[i][n - 1]\n        pref_up[i][n - 1] = a[i][n - 1]\n        pref_down[i][n - 1] = a[i][n - 1]\n        for j in range(n - 2, -1, -1):\n            sum_up[i][j] = sum_up[i][j + 1] + a[i][j]\n            pref_up[i][j] = pref_up[i][j + 1] + sum_up[i][j]\n            pref_down[i][j] = pref_down[i][j + 1] + a[i][j] * (n - j)\n    zig = [[0 for i in range(n)] for j in range(2)]\n    for j in range(n):\n        for i in range(2):\n            if j % 2 == 0:\n                if i == 0:\n                    zig[i][j] = a[i][j] * j * 2 + zig[i][j - 1]\n                else:\n                    zig[i][j] = a[i][j] * (j * 2 + 1) + zig[1 - i][j]\n            else:\n                if i == 0:\n                    zig[1 - i][j] = a[1 - i][j] * j * 2 + zig[1 - i][j - 1]\n                else:\n                    zig[1 - i][j] = a[1 - i][j] * (j * 2 + 1) + zig[i][j]\n    ans = -1e18\n    for j in range(n):\n        if j == 0:\n            ans = max(ans, pref_up[0][j] + pref_down[1][j] + sum_up[1][j] * n - sum_up[0][j] - sum_up[1][j])\n        else:\n            if j == n - 1:\n                ans = max(ans, zig[1 - (j % 2)][n - 1])\n            else:\n                if j % 2 == 1:\n                    ans = max(ans, pref_up[0][j + 1] + sum_up[0][j + 1] * (4 * (j // 2 + 1) - 1) + pref_down[1][j + 1] - sum_up[1][j + 1] + sum_up[1][j + 1] * (4 * (j // 2 + 1) - 1 + n - j) + zig[0][j])\n                else:\n                    ans = max(ans, pref_up[1][j + 1] - sum_up[1][j + 1] + sum_up[1][j + 1] * (4 * (j // 2) + 2) +\n                              pref_down[0][j + 1] - sum_up[0][j + 1] + sum_up[0][j + 1] * (\n                                          4 * (j // 2) + 2 - 1 + n - j) + zig[1][j])\n    ans = max(ans, pref_up[1][0] + pref_down[0][1] + sum_up[0][1] * n)\n    print(ans)\nelse:\n    print(a[1][0])\n", "n = int(input())\nF = list(map(int , input().split()))\nS = list(map(int , input().split()))\n\nSum = [0]*n\nSum[n-1] = F[n-1] + S[n-1];\n\nfor i in range(n-2, -1, -1):\n    Sum[i] = Sum[i+1] + F[i] + S[i]\n\nans1 = 0\nfor i in range(n):\n    ans1 +=  F[i]*i;\n    ans1 +=  S[i]* ( 2*n - i - 1)\n\nans2  = 0\nfor i in range(n):\n    ans2  += S[i]* (i + 1);\nfor i in range(1, n):\n    ans2 +=  F[i]* (2*n - i)\n\nx = ans1\ny = ans2\nans = [x, y]\n\n\nfor i in range(0, max(0, n-2), 2):\n    x = x + F[i+1]*2 - S[i] * (2*n-2-2*i) - S[i+1] * (2*n-4-2*i) + Sum[i+2]*2\n    y = y - F[i+1] * (2*n -2*i - 4) - F[i+2] * (2*n - 2*i - 4) + Sum[i+2] * 2\n    ans.append(x)\n    ans.append(y)\n\n\nprint(max(ans))", "n=int(input())\na=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\nsum = [0]*n\nsum[-1] = a[-1]+b[-1]\nfor i in range(n-2, -1, -1):\n    sum[i] = a[i]+b[i]+sum[i+1]\nda = [0]*n\ndb = [0]*n\nda[-1] = b[-1]\ndb[-1] = a[-1]\nfor i in range(n-2, -1, -1):\n    da[i] = sum[i+1] + da[i+1] + ((n-i)*2-1)*b[i]\n    db[i] = sum[i+1] + db[i+1] + ((n-i)*2-1)*a[i]\nsuml = 0\nans = [0]*n\nfor i in range(0, n):\n    if i%2 == 0:\n        ans[i] = suml + da[i] + 2*i*sum[i]\n        suml += 2*i*a[i] + (2*i+1)*b[i]\n    else:\n        ans[i] = suml + db[i] + 2*i*sum[i]\n        suml += 2 * i * b[i] + (2 * i + 1) * a[i]\nprint(max(ans))\n\n", "n = int(input())\nF = list(map(int , input().split()))\nS = list(map(int , input().split()))\n\nSum = [0]*n\nSum[n-1] = F[n-1] + S[n-1];\n\nfor i in range(n-2, -1, -1):\n    Sum[i] = Sum[i+1] + F[i] + S[i]\n\nans1 = 0\nfor i in range(n):\n    ans1 +=  F[i]*i;\n    ans1 +=  S[i]* ( 2*n - i - 1)\n\nans2  = 0\nfor i in range(n):\n    ans2  += S[i]* (i + 1);\nfor i in range(1, n):\n    ans2 +=  F[i]* (2*n - i)\n\nx = ans1\ny = ans2\nans = [x, y]\n\n\nfor i in range(0, max(0, n-2), 2):\n    x = x + F[i+1]*2 - S[i] * (2*n-2-2*i) - S[i+1] * (2*n-4-2*i) + Sum[i+2]*2\n    y = y - F[i+1] * (2*n -2*i - 4) - F[i+2] * (2*n - 2*i - 4) + Sum[i+2] * 2\n    ans.append(x)\n    ans.append(y)\n\n\nprint(max(ans))", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nA = [b[n-1]]\nB = [a[n-1]]\nS = [a[n-1] + b[n-1]]\nfor i in range(1, n):\n    A.append(A[-1] + S[-1] + b[n - i - 1] * (2*i + 1))\n    B.append(B[-1] + S[-1] + a[n - i - 1] * (2*i + 1))\n    S.append(S[-1] + a[n - i - 1] + b[n - i - 1])\n\nA = A[::-1]\nB = B[::-1]\nS = S[::-1]\n\nm = 0\ns = 0\nfor i in range(n):\n    if i % 2 == 0:\n        m = max(m, s + A[i] + S[i] * 2*i)\n        s += 2*i*a[i] + (2*i + 1)*b[i]\n    \n    else:\n        m = max(m, s + B[i] + S[i] * 2*i)\n        s += 2*i*b[i] + (2*i + 1)*a[i]\n\nprint(m)", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncurl_ud_weights = [0] * n\ncurl_du_weights = [0] * n\n\nsums = [0] * n\n\nsums[n - 1] = a[n - 1] + b[n - 1]\ncurl_ud_weights[n - 1] = b[n - 1]\ncurl_du_weights[n - 1] = a[n - 1]\n\nfor i in range(n - 2, -1, -1):\n    sums[i] = sums[i + 1] + (a[i] + b[i])\n    remain = n * 2 - i * 2 - 1\n    curl_ud_weights[i] = sums[i + 1] + curl_ud_weights[i + 1] + remain * b[i]\n    curl_du_weights[i] = sums[i + 1] + curl_du_weights[i + 1] + remain * a[i]\n    #print(sums[i] + curl_ud_weights[i + 1], remain, \"*\", b[i])\n\n# -----------------------------------------------------\n\nsnake_weight = 0\nmax_weight = 0\ncurrent_weight = -1\n\nfor t in range(0, 2 * n, 2):\n    remain = t % 4\n    #print(t, snake_weight, a[t//2], b[t//2])\n    if remain == 0 :\n        current_weight = sums[t//2] * t + curl_ud_weights[t // 2] + snake_weight\n        snake_weight += (a[t // 2] * t + b[t // 2] * (t + 1))\n    elif remain == 2:\n        current_weight = sums[t//2] * t + curl_du_weights[t // 2] + snake_weight\n        snake_weight += (b[t // 2] * t + a[t // 2] * (t + 1))\n\n    if current_weight > max_weight:\n        max_weight = current_weight\n        #print(max_weight, t)\n\nprint(max_weight)\n#print(curl_ud_weights)\n#print(curl_du_weights)\n#print(sums)\n\n\"\"\"\n3\n0 1 0\n0 0 0\n\"\"\"", "n = int(input())\na = list(map(int,input().split(' ')))\nb = list(map(int,input().split(' ')))\n\ne = [[0]*n,[0]*n]\ne1 = [[0]*n,[0]*n]\ne2 = [[0]*n,[0]*n]\ne[0][-1] = a[-1]\ne[1][-1] = b[-1]\ne1[0][-1] = (n-1)*a[-1]\ne1[1][-1] = (n-1)*b[-1]\n\nfor j in range(2):\n  for i in range(n-2,-1,-1):\n    e[j][i] += e[j][i+1] + (a[i] if j==0 else b[i])\n    e1[j][i] += e1[j][i+1] + (i)*(a[i] if j==0 else b[i])\n    e2[j][i] += e2[j][i+1] + (n-i-1)*(a[i] if j==0 else b[i])\n\nsum0 = e1[0][0] + e2[1][0] + e[1][0]*n\n\nsum1 = 0\nj = 1\nfor i in range(n-1):\n  sum1 += i*2 * (a[i]+b[i]) + (b[i] if i%2==0 else a[i])\n  \n  su = sum1\n  su += e1[j][i+1] + e2[j^1][i+1]\n  su += e[j][i+1] * (i+1) + e[j^1][i+1] * (i+1+n)\n  j ^= 1\n  if su > sum0:\n    sum0 = su  \n                                                     \nprint(sum0)                                            \n", "def main():\n    \n    n = int(input())\n    N = n + 1\n    row1 = [int(c) for c in input().split()]\n    row2 = [int(c) for c in input().split()]\n    grid = [row1, row2]\n\n    sum123 = [[0]*N, [0]*N]\n    sum321 = [[0]*N, [0]*N]\n    sum111 = [[0]*N, [0]*N]\n\n    for i in range(2):\n        for j in range(n-1, -1, -1):\n            sum123[i][j] = sum123[i][j+1] + (j + 1) * grid[i][j]\n            sum321[i][j] = sum321[i][j+1] + (n - j) * grid[i][j]\n            sum111[i][j] = sum111[i][j+1] + grid[i][j]\n\n    res = _sum = i = 0\n    for j in range(n):\n        nres = _sum\n        nres += sum123[i][j] + j * sum111[i][j]\n        nres += sum321[i^1][j] + (j + n) * sum111[i^1][j]\n        res = max(res, nres)\n\n        _sum += grid[i][j] * (j + j + 1)\n        _sum += grid[i^1][j] * (j + j + 2)\n        i ^= 1\n\n    for j in range(n):\n        res -= grid[0][j] + grid[1][j]\n\n    print(res)\n\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    \n    n = int(input())\n    N = n + 1\n    row1 = [int(c) for c in input().split()]\n    row2 = [int(c) for c in input().split()]\n    grid = [row1, row2]\n\n    sum123 = [[0]*N, [0]*N]\n    sum321 = [[0]*N, [0]*N]\n    sum111 = [[0]*N, [0]*N]\n\n    for i in range(2):\n        for j in range(n-1, -1, -1):\n            sum123[i][j] = sum123[i][j+1] + (j + 1) * grid[i][j]\n            sum321[i][j] = sum321[i][j+1] + (n - j) * grid[i][j]\n            sum111[i][j] = sum111[i][j+1] + grid[i][j]\n\n    res = _sum = i = 0\n    for j in range(n):\n        nres = _sum\n        nres += sum123[i][j] + j * sum111[i][j]\n        nres += sum321[i^1][j] + (j + n) * sum111[i^1][j]\n        res = max(res, nres)\n\n        _sum += grid[i][j] * (j + j + 1)\n        _sum += grid[i^1][j] * (j + j + 2)\n        i ^= 1\n\n    for j in range(n):\n        res -= grid[0][j] + grid[1][j]\n\n    print(res)\n\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "R = lambda: map(int, input().split())\nn = int(input())\narr = [list(R()), list(R())]\nlus = [0] * (n + 1)\nlds = [0] * (n + 1)\nrs = [0] * (n + 1)\nfor i in range(n):\n    lus[i] = i * arr[0][i] + (2 * n - 1 - i) * arr[1][i]\n    lds[i] = i * arr[1][i] + (2 * n - 1 - i) * arr[0][i]\nfor i in range(n - 1, -1, -1):\n    lus[i] += lus[i + 1]\n    lds[i] += lds[i + 1]\n    rs[i] = rs[i + 1] + arr[0][i] + arr[1][i]\ndp = [0] * (n + 1)\nfor i in range(0, n, 2):\n    dp[i] = lus[i] + i * rs[i]\nfor i in range(1, n, 2):\n    dp[i] = lds[i] + i * rs[i]\nres = dp[0]\nacc = 0\nfor i in range(n):\n    if i % 2 == 0:\n        acc += arr[0][i] * (2 * i) + arr[1][i] * (2 * i + 1)\n    else:\n        acc += arr[1][i] * (2 * i) + arr[0][i] * (2 * i + 1)\n    res = max(res, acc + dp[i + 1])\nprint(res)", "n = int(input())\nu1 = list(map(int, input().split()))\nu2 = list(map(int, input().split()))\na1 = u1[:n]\na2 = u2[:n]\nfor i in range(1, n):\n    a1[i] += a1[i - 1]\n    a2[i] += a2[i - 1]\nq1 = [0] * (2 * n)\nq2 = [0] * (2 * n)\nfor i in range(1, n):\n    q1[i] = u1[i] * (i) + q1[i - 1]\n    q2[i] = u2[i] * (i) + q2[i - 1]\nfor i in range(n):\n    q1[i + n] = u2[n - i - 1] * (n + i) + q1[i + n - 1]\n    q2[i + n] = u1[n - i - 1] * (n + i) + q2[i + n - 1]\nans = q1[-1]\ncur = 0\n#print(ans)\nfor i in range(n):\n    ans1 = (a1[-1] - a1[i] + a2[-1] - a2[i]) * (i + 1)\n    if i % 2 == 0:\n        cur += u1[i] * (i * 2)\n        cur += u2[i] * (i * 2 + 1)\n        ans1 += (q2[n * 2 - i - 2] - q2[i]) + cur\n    else:\n        cur += u2[i] * (i * 2)\n        cur += u1[i] * (i * 2 + 1)\n        ans1 += (q1[n * 2 - i - 2] - q1[i]) + cur\n    ans = max(ans, ans1)\n    #print(ans1, cur)\nprint(ans)\n'''\n3\n1 100000 10000\n10 100 1000\n6\n12 8 12 17 20 5\n17 4 8 8 8 4\n'''\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li1 = get_list()\n    li2 = get_list()\n    processed = [0 for _ in range(n+1)]\n    sums = [0 for _ in range(n+1)]\n    for i in range(n-1,-1,-1):\n        sums[i] = sums[i+1] + li1[i] + li2[i]\n    if n%2==0:\n        processed[n-1] = li1[n-1]\n    else:\n        processed[n-1] = li2[n-1]\n    for i in range(n-3 if n%2==1 else n-2, -1, -2):\n        k = 2*(n-i-1)\n        processed[i] = li1[i+1] + processed[i+2] + 2*sums[i+2] + k*li2[i+1] + (k+1)*li2[i]\n    for i in range(n-3 if n%2==0 else n-2, -1, -2):\n        k = 2*(n-i-1)\n        processed[i] = li2[i+1] + processed[i+2] + 2*sums[i+2] + k*li1[i+1] + (k+1)*li1[i]\n    #print(processed, sums)\n    mul = 0\n    curr_prefix = 0\n    res = 0\n    for i in range(n):\n        res = max(res, processed[i] + sums[i]*2*i + curr_prefix)\n        if i%2==0:\n            curr_prefix += li1[i]*mul + li2[i] * (mul+1)\n        else:\n            curr_prefix += li2[i] * mul + li1[i] * (mul + 1)\n        mul += 2\n    res = max(res, curr_prefix)\n    print(res)\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n"]
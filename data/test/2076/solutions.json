["# Contest: Codeforces Round #593 (Div. 2) (https://codeforces.com/contest/1236)\n# Problem: A: Stones (https://codeforces.com/contest/1236/problem/A)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nt = rint()\nfor _ in range(t):\n    a, b, c, = rints()\n    mx = 0\n    for ta in range(0, min(a, b // 2) + 1):\n        mx = max(mx, 3 * ta + 3 * min(b - 2 * ta, c // 2))\n    print(mx)\n", "for _ in range(int(input())):\n    a,b,c=map(int,input().split())\n    answer=0\n    x=min(b,c//2)\n    answer+=3*x\n    b-=x\n    x=min(a,b//2)\n    answer+=3*x\n    print(answer)", "from sys import stdin\nn=int(stdin.readline().strip())\nfor i in range(n):\n    a,b,c=list(map(int,stdin.readline().strip().split()))\n    ans=0\n    while c>=2 and b>=1:\n        c-=2\n        b-=1\n        ans+=3\n    while b>=2 and a>=1:\n        b-=2\n        a-=1\n        ans+=3\n    print(ans)\n", "for _ in range(int(input())):\n    a, b, c = list(map(int, input().split()))\n    ans = 0\n    ans += min(b, c//2)*3\n    b-=min(b, c//2)\n    ans+=min(a, b//2)*3\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nfor testcases in range(t):\n    a,b,c=list(map(int,input().split()))\n    ANS=0\n\n    ANS+=min(b,c//2)\n    b-=ANS\n    ANS+=min(a,b//2)\n    print(ANS*3)\n\n    \n", "for _ in range(int(input())):\n    x,y,z=list(map(int,input().split()))\n    m = 0\n    for a in range(x + 1):\n        b = min(z // 2, y - 2 * a)\n        m = max(m, 3 * (a + b))\n    print (m)\n", "q = int(input())\nfor fwefe in range(q):\n\twyn = 0\n\ta,b,c = list(map(int,input().split()))\n\twhile b > 0 and c > 1:\n\t\tb -= 1\n\t\tc -= 2\n\t\twyn += 3\n\twhile a > 0 and b > 1:\n\t\ta -= 1\n\t\tb -= 2\n\t\twyn += 3\n\tprint(wyn)", "n = int(input())\nfor i in range(n):\n    a, b, c = map(int, input().split())\n    ss = min(c // 2, b)\n    b -= ss\n    tt = min(b // 2, a)\n    print((ss + tt) * 3)", "t = int(input())\nfor y in range(t):\n\ta,b,c = map(int,input().split())\n\tct = 0\n\tct += min(b,c//2)\n\tb -= ct\n\tct += min(a,b//2)\n\tprint(ct*3)", "for TT in range(1, int(input()) + 1):\n    a, b, c = map(int, input().split())\n    res = 0\n    for x in range(min(a, b // 2) + 1):\n        y = min(b - 2 * x, c // 2)\n        res = max(res, 3 * (x + y))\n    print(res)", "t = int(input())\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    ans = 0\n    \n    cnt_2 = min(c // 2, b)\n    ans += cnt_2 * 3\n    b -= cnt_2\n    c -= cnt_2*2\n    \n    cnt_1 = min(a, b // 2)\n    ans += cnt_1 * 3\n    print(ans) ", "for _ in range(int(input())):\n    a, b, c = list(map(int, input().split()))\n    c2 = min(c // 2, b)\n    print((c2 + min((b - c2) // 2, a)) * 3)\n", "t = int(input())\nfor i in range(t):\n    a,b,c = map(int,input().split())\n    ans = min(b,c//2)\n    b-=ans\n    print(3*(ans+min(a,b//2)))", "t = int(input())\nfor i in range(t):\n    a, b, c = map(int, input().split())\n    ans = 0\n    while b >= 1 and c >= 2:\n        ans += 3\n        b -= 1\n        c -= 2\n    while b >= 2 and a >= 1:\n        ans += 3\n        b -= 2\n        a -= 1\n    print(ans)", "t=int(input())\nfor i in range(t):\n    g=[int(x) for x in input().split()]\n    h=min(g[1],int(g[2]/2))\n    j=min(g[0],int((g[1]-h)/2))\n    print(3*(h+j))\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    x, y, z = get_tuple()\n    res = min(y, z//2)\n    y -= res\n    res += min(x, y//2)\n    print(res*3)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "t = int(input())\nfor query in range(t):\n  a, b, c = list(map(int, input().split()))\n  ans = 0\n  for cnt1 in range(101):\n    for cnt2 in range(101):\n      if a >= cnt1 and b >= cnt1 * 2 + cnt2 and c >= cnt2 * 2:\n        ans = max(ans, cnt1 * 3 + cnt2 * 3)\n  print(ans)\n", "def f1(a, b, c):\n    res = 0\n    d= min(b, c // 2)\n    res += 3 * d\n    b -= d\n    res += min(a, b // 2) * 3\n    return res\n\ndef f2(a, b, c):\n    res = 0\n    d = min(a, b // 2)\n    res += 3 * d\n    b -= 2 * d\n    res += min(b, c // 2) * 3\n    return res\n\n\nt = int(input())\nfor i in range(t):\n    a, b, c = list(map(int, input().split()))\n    print(max(f1(a, b, c), f2(a, b, c)))\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\n\nAns = [None]*N\nfor qu in range(N):\n    A, B, C = map(int, readline().split())\n    res = 0\n    for a in range(A+1):\n        if 2*a > B:\n            break\n        cnt = 3*a\n        t = B - 2*a\n        t = min(t, C//2)\n        cnt += 3*t\n        res = max(res, cnt)\n    Ans[qu] = res\n\nprint('\\n'.join(map(str, Ans)))", "t=int(input())\nfor i in range(t):\n    a,b,c=map(int,input().split())\n    ans1=min(a,b//2)\n    b1=b-ans1*2\n    ans1+=min(b1,c//2)\n    ans2=min(b,c//2)\n    b-=ans2\n    ans2+=min(a,b//2)\n    print(max(ans1*3,ans2*3))", "t = int(input())\n\nfor i in range(t):\n    a, b, c = list(map(int, input().split()))\n    ans = 0\n    for t1 in range(a + 1):\n        for t2 in range(b + 1):\n            if a - t1 >= 0 and b - 2 * t1 - t2 >= 0 and c - 2 * t2 >= 0:\n                ans = max(ans, 3 * (t1 + t2))\n    print(ans)", "import sys\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ndef write(*args, sep=\"\\n\"):\n  for i in args:\n    sys.stdout.write(\"{}\".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor _ in range(int(input())):\n  a, b, c = read()\n  x = min(b, c // 2)\n  b -= x \n  y = min(a, b // 2)\n\n  print(3 * x + 3 * y)\n", "t = int(input())\nfor i in range(t):\n\ta, b, c = map(int, input().split())\n\tif b == 0:\n\t\tprint(0)\n\telse:\n\t\tres = 0\n\t\tres += 3 * min(b, c // 2)\n\t\tb -= res // 3\n\t\tres += 3 * min(a, b // 2)\n\t\tprint(res)"]
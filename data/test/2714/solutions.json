["mod=998244353\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\nfrom collections import Counter\n\n\ndef calc(s,a):\n    return (pow(2,s,mod)+pow(2,a-s,mod))%mod\n\n \ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\n\ntestcase=int(input())\nfor test in range(testcase):\n    n,m=list(map(int,input().split()))\n    EDGE=[list(map(int,input().split())) for i in range(m)]\n    EDGELIST=[[] for j in range(n+1)]\n    ANS=1\n\n\n    Group=[j for j in range(n+1)]\n\n    for a,b in EDGE:\n        Union(a,b)\n        EDGELIST[a].append(b)\n        EDGELIST[b].append(a)\n\n    testing=[None]*(n+1)\n    flag=1\n\n    for i in range(1,n+1):\n        if testing[i]!=None:\n            continue\n\n        score=1\n        allscore=1\n\n        testing[i]=1\n        QUE = deque([i])\n        while QUE:\n            x=QUE.pop()\n            for to in EDGELIST[x]:\n                if testing[to]==-testing[x]:\n                    continue\n                if testing[to]==testing[x]:\n                    flag=0\n                    break\n                testing[to]=-testing[x]\n                if testing[to]==1:\n                    score+=1\n                allscore+=1\n                QUE.append(to)\n                \n            if flag==0:\n                break\n        if flag==0:\n            break\n        #print(score,allscore)\n        ANS=ANS*calc(score,allscore)%mod\n    if flag==0:\n        print(0)\n        continue\n\n    print(ANS)\n", "from sys import stdin,stdout\nfor _ in range(int(input())):\n    n,m=(int(x) for x in stdin.readline().split())\n    a=[[] for i in range(n+1)]\n    b=[]\n    for i in range(m):\n        c,d=(int(x) for x in stdin.readline().split())\n        a[d].append(c)\n        a[c].append(d)\n        b.append([c,d])\n    vis=[0]*(n+1)\n    co=[]\n    for i in range(1,n+1):\n        if vis[i]==0:\n            st=[i]\n            vis[i]='e'\n            e=1\n            o=0\n            while st:\n                x=st.pop()\n                for i in a[x]:\n                    if vis[i]==0:\n                        if vis[x]=='e':\n                            vis[i]='o'\n                            o+=1\n                        else:\n                            vis[i]='e'\n                            e+=1\n                        st.append(i)\n            co.append([e,o])    \n    fl=0\n    for i in b:\n        if vis[i[0]]==vis[i[1]]:\n            stdout.write(str(0)+'\\n')\n            fl=1\n            break\n    if fl==0:\n        k=[]\n        for i in range(len(co)):\n            x=co[i][0]\n            y=co[i][1]\n            m=1\n            for i in range(x):\n                m*=2\n                m%=998244353\n            ans=m\n            m=1\n            for i in range(y):\n                m*=2\n                m%=998244353\n            ans+=m\n            k.append(ans%998244353)\n        ans=1\n        for i in k:\n            ans*=i\n            ans%=998244353\n        stdout.write(str(ans)+'\\n')\n        \n\n", "''' Thruth can only be found at one place - THE CODE '''\n\n''' Copyright 2018, SATYAM KUMAR'''\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\n\ndef main():\n    n,m = get_tuple()\n    P=998244353\n    neighbours = [[] for _ in range(n)]\n    for i in range(m):\n        a,b = get_tuple()\n        neighbours[a-1].append(b-1)\n        neighbours[b-1].append(a-1)\n    nature = [0 for _ in range(n)] #0--> Unvisited, 1--> ODD, 2-> EVEN\n    res = 1\n    for k in range(0,n):\n        if nature[k]!=0: continue\n        curr_level = [k]\n        nature[k] = 1\n        r1,r2 = 2,1\n        while len(curr_level)>0:\n            next_level = []\n            for curr_level_vertex in curr_level:\n                curr_nature = nature[curr_level_vertex]\n                for v in neighbours[curr_level_vertex]:\n                    if nature[v]==0:\n                        next_level.append(v)\n                        nature[v] = 1 if curr_nature==2 else 2\n                        if nature[v] ==1:\n                            r1 = (r1*2)%P\n                        else:\n                            r2 = (r2*2)%P\n                    else:\n                        if nature[v]==curr_nature:\n                            print(0)\n                            return\n            curr_level = next_level\n        res = (res*(r1+r2)%P)%P\n    r1,r2 = 1,1\n    print(res)\n\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "mod=998244353\nfrom collections import deque\nfrom sys import stdin,stdout\nfor _ in range(int(input())):\n    n,m=list(map(int,stdin.readline().split()))\n    a=[[] for i in range(n+1)]\n    length=[0]*(n+1)\n    if m==0:\n        print(pow(3,n,mod))\n    else:\n        d=[]\n        ans1=0;ans2=0;ans3=0;\n        for __ in range(m):\n            x,y=list(map(int,stdin.readline().split()))\n            a[x].append(y)\n            a[y].append(x)\n        col=[0]*(n+1)\n        de=deque([])\n        for j in range(1,n+1):\n            if len(a[j])==0:\n                ans3+=1\n            elif col[j]==0:\n                col[j]=1\n                de.append(j)\n            #print(de)    \n            c=1;c1=1\n            while len(de):\n                p=de.popleft()\n                for i in a[p]:\n                    if col[i]==0:\n                        col[i]=-col[p]\n                        de.append(i)\n                        if col[i]==1:\n                            c1+=1\n                        c+=1            \n            d.append([c,c1])\n            \n        flag=0\n        for i in range(1,n+1):\n            if flag==1:\n                break\n            for j in a[i]:\n                if col[i]==col[j]:\n                    flag=1\n                    break\n        #print(col)\n        k=1\n        if flag==1:\n            stdout.write(str(0)+'\\n')\n        else:\n            #print(d)\n            for i in d:\n                if i[0]!=1:\n                    k1=pow(2,i[1],mod)\n                    k1+=pow(2,i[0]-i[1],mod)\n                    k*=k1\n            k*=pow(3,ans3,mod)\n            k%=mod\n            stdout.write(str(k)+'\\n')\n            #print(ans1,ans2,ans3,flag)\n            \n                \n                \n", "#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**25)  # new thread will get stack of such size\ndef main():\n    mod=998244353\n    def ain():\n        return list(map(int,sin().split()))\n    def sin():\n        return sys.stdin.readline().strip()\n    \"\"\"*********************************************************************************\"\"\"\n    def dfs(x):\n        if(p[x]==0):\n            p[x]=1\n            pt[0]+=1\n            for i in de[x]:\n                if(t[x]==1):\n                    if(t[i]==1):\n                        s[0]=0\n                        return\n                    else:\n                        if(p[i]!=1):\n                            t[i]=2\n                            dfs(i)\n                else:\n                    if(t[i]==2):\n                        s[0]=0\n                        return\n                    else:\n                        if(p[i]!=1):\n                            t[i]=1\n                            r[0]+=1\n                            dfs(i)\n    h=[]\n    pow1=[1]\n    s=1\n    for i in range(300000):\n        s=(s*2)%mod\n        pow1.append(s)\n    for _ in range(int(input())):\n        n,m=ain()\n        de=[[] for i in range(n)]\n        for i in range(m):\n            x,y=ain()\n            de[x-1].append(y-1)\n            de[y-1].append(x-1)\n        p=[0]*n\n        s1=1\n        t=[0]*n\n        for i in range(n):\n            if(p[i]==0):\n                s=[1]\n                pt=[0]\n                t[i]=1\n                r=[1]\n                dfs(i)\n                if(s[0]==1):\n                    r1=pt[0]-r[0]\n                    r2=r[0]\n                    r1=(pow1[r1]+pow1[r2])%mod\n                    s1=(s1*r1)%mod\n                else:\n                    s1=0\n                    break\n        h.append(str(s1))\n    sys.stdout.write(\"\\n\".join(h))\nthreading.Thread(target=main).start()\n", "import sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**25)  # new thread will get stack of such size\ndef main():\n    mod=998244353\n    def ain():\n        return list(map(int,sin().split()))\n    def sin():\n        return sys.stdin.readline().strip()\n    \"\"\"*********************************************************************************\"\"\"\n    def dfs(x):\n        if(p[x]==0):\n            p[x]=1\n            pt[0]+=1\n            for i in de[x]:\n                if(t[x]==1):\n                    if(t[i]==1):\n                        s[0]=0\n                        return\n                    else:\n                        if(p[i]!=1):\n                            t[i]=2\n                            dfs(i)\n                else:\n                    if(t[i]==2):\n                        s[0]=0\n                        return\n                    else:\n                        if(p[i]!=1):\n                            t[i]=1\n                            r[0]+=1\n                            dfs(i)\n    h=[]\n    pow1=[1]\n    s=1\n    for i in range(300000):\n        s=(s*2)%mod\n        pow1.append(s)\n    for _ in range(int(input())):\n        n,m=ain()\n        de=[[] for i in range(n)]\n        for i in range(m):\n            x,y=ain()\n            de[x-1].append(y-1)\n            de[y-1].append(x-1)\n        p=[0]*n\n        s1=1\n        t=[0]*n\n        for i in range(n):\n            if(p[i]==0):\n                s=[1]\n                pt=[0]\n                t[i]=1\n                r=[1]\n                dfs(i)\n                if(s[0]==1):\n                    r1=pt[0]-r[0]\n                    r2=r[0]\n                    r1=(pow1[r1]+pow1[r2])%mod\n                    s1=(s1*r1)%mod\n                else:\n                    s1=0\n                    break\n        h.append(str(s1))\n    sys.stdout.write(\"\\n\".join(h))\nthreading.Thread(target=main).start()", "from collections import deque\nimport time\n\nanss = []\nstart = time.time()\nt = int(input())\n\nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = list(map(int, input().split()))\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n\n\tfor edge_count in range(m):\n\t\tu, v = list(map(int, input().split()))\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n\n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= 2 ** even + 2 ** odd\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n\n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= 3 ** factor\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)\n", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\nanss = []\nt = int(input())\n\nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n\n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n\n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n\n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\nanss = []\nt = int(input())\n\nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n\n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n\n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n\n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)", "# einlesen\n# dfs f\u00fcr jede cc\n#     Z\u00e4hlen, wie viele w/r\n#     wenn cooring nicht m\u00f6glich -> Ergebnis 0\n#     sonst 2^w+2^r\nM=998244353 \nt=int(input())\nn,m=0,0\ng=[]\nv=[]\n\ndef dfs(r):\n    s=[r]\n    v[r]=1\n    c=[0,1]\n    while s:\n        x=s.pop()\n        for j in g[x]:\n            if v[j]==v[x]:return 0\n            if v[j]==-1:\n                v[j]=v[x]^1\n                c[v[j]]+=1\n                s.append(j)\n    if c[0]==0 or c[1]==0:return 3\n    return ((2**c[0])%M + (2**c[1])%M)%M\n\no=[]\nfor i in range(t):\n    n,m=map(int,input().split())\n    g=[[]for _ in range(n)]\n    for _ in range(m):\n        a,b=map(int,input().split())\n        g[a-1].append(b-1)\n        g[b-1].append(a-1)\n    v=[-1]*n\n    ox=1\n    for j in range(n):\n        if v[j]==-1:\n            ox=(ox*dfs(j))%M\n    o.append(ox)\nprint('\\n'.join(map(str,o)))", "from collections import defaultdict\nimport sys\n#sys.setrecursionlimit(10**6)\n#sys.stdin = open('E56D_input.txt', 'r')\n#sys.stdout = open('output.txt', 'w')\n\ninput=sys.stdin.readline\n#print=sys.stdout.write\n\ngraph = defaultdict(list)\ncolor = [0] * ((3 * 10 ** 5) + 1000)\nbipertite = True\nMOD = 998244353\nresult = 1\ncolor_count = [0] * 2\npow_value=[]\n\"\"\"\ndef dfs(s, c):\n    nonlocal color\n    nonlocal bipertite\n    nonlocal color_count\n\n    color[s] = c\n    color_count[c] += 1\n    for i in range(0, len(graph[s])):\n\n        if color[graph[s][i]] == -1:\n            dfs(graph[s][i], 1-c)\n\n        if color[s] == color[graph[s][i]]:\n            bipertite = False\n\n\"\"\"\n\nt = int((input()))\n\n#precomputing powers\npow_value.append(1)\nfor i in range(1,(3*10**5)+1000):\n    next_value=(pow_value[i-1]*2)%MOD\n    pow_value.append(next_value)\n#------------------------\n\n\nwhile t:\n    n, m = list(map(int, input().split()))\n    if m==0:\n        print(pow(3,n,MOD))\n        t-=1\n        continue\n    graph.clear()\n    bipertite=True\n    result=1\n\n    for node in range(0,n+1):\n        color[node]=-1\n    while m:\n        u, v = list(map(int, input().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n        m -= 1\n\n    for i in range(1, n + 1):\n        if (color[i] != -1):\n            continue\n\n        #bfs---\n        bipertite = True\n        color_count[0] = color_count[1] = 0\n        queue=[]\n        queue.append(i)\n        color[i] = 0\n        color_count[0] += 1\n        while queue:\n           # print(color_count[0],' ',color_count[1])\n            if bipertite==False:\n                break\n            front_node=queue.pop()\n            for child_node in range(0, len(graph[front_node])):\n\n                if color[graph[front_node][child_node]] == -1:\n                    color[graph[front_node][child_node]] = 1-color[front_node]\n                    queue.append(graph[front_node][child_node])\n                    color_count[color[graph[front_node][child_node]]] += 1\n\n\n                elif color[front_node]==color[graph[front_node][child_node]]:\n                    bipertite = False\n                    break\n\n\n        #bfs end\n        if bipertite == False:\n            print(0)\n            break\n        current=(pow_value[color_count[0]]+pow_value[color_count[1]])%MOD\n        result = (result * current) % MOD\n\n    if bipertite:\n        print(result)\n    t -= 1\n", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\nanss = []\nt = int(input())\n\nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n\n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n\n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n\n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n \nanss = []\nt = int(input())\n \nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n \n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n \n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n \n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\n\n \nsaida = []\nt = int(input())\nmodulo = 998244353\n\nfor _ in range(t):\n    ans = 1\n    part = 0\n    factor = 0\n    queue = deque([])\n    n, m = map(int, input().split())\n    if m > (n // 2) * ( n // 2 + 1):\n        saida.append('0')\n        for edge_count in range(m):\n            input()\n        continue\n    edge = [[] for i in range(n + 1)]\n    visitados = [-1] * (n + 1)\n    assure = 1\n \n    for edge_count in range(m):\n        u, v = map(int, input().split())\n        edge[u].append(v)\n        edge[v].append(u)\n    visitados[1] = 0\n    queue.append(1)\n \n    break_all = False\n    while not break_all:\n        even, odd = 1, 0\n        while queue and not break_all:\n            search = queue.popleft()\n            \n            current = visitados[search]\n            for i in edge[search]:\n                if visitados[i] == -1:\n                    visitados[i] = current ^ 1\n                    if visitados[i] & 1:\n                        odd += 1\n                    else:\n                        even += 1\n                    queue.append(i)\n                elif visitados[i] == current:\n                    break_all = True\n                else:\n                    assert visitados[i] == current ^ 1\n        if break_all:\n            ans = 0\n        else:\n            if (even, odd) == (1, 0):\n                factor += 1\n            else:\n                ans *= pow(2, even, modulo) + pow(2, odd, modulo)\n                ans %= modulo\n        while assure <= n:\n            if visitados[assure] == -1:\n                part += 1\n                visitados[assure] = 2 * part\n \n                queue.append(assure)\n                break\n            assure += 1\n        if assure == n + 1:\n            break\n    ans *= pow(3, factor, modulo)\n    ans %= modulo\n    saida.append(str(ans))\nprint('\\n'.join(saida))", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\n\n \nsaida = []\nt = int(input())\nmodulo = 998244353\n\nfor _ in range(t):\n    ans = 1\n    part = 0\n    factor = 0\n    fila = deque([])\n    n, m = map(int, input().split())\n\n    if m > (n // 2) * ( n // 2 + 1):\n        saida.append('0')\n        for edge_count in range(m):\n            input()\n        continue\n    edge = [[] for i in range(n + 1)]\n    visitados = [-1] * (n + 1)\n    assure = 1\n \n    for arestas in range(m):\n        u, v = map(int, input().split())\n        edge[u].append(v)\n        edge[v].append(u)\n    visitados[1] = 0\n    fila.append(1)\n \n    break_all = False\n    while not break_all:\n        par, impar = 1, 0\n        while fila and not break_all:\n            search = fila.popleft()\n            \n            current = visitados[search]\n            for i in edge[search]:\n                if visitados[i] == -1:\n                    visitados[i] = current ^ 1\n                    if visitados[i] & 1:\n                        impar += 1\n                    else:\n                        par += 1\n                    fila.append(i)\n                elif visitados[i] == current:\n                    break_all = True\n                else:\n                    assert visitados[i] == current ^ 1\n        if break_all:\n            ans = 0\n        else:\n            if (par, impar) == (1, 0):\n                factor += 1\n            else:\n                ans *= pow(2, par, modulo) + pow(2, impar, modulo)\n                ans %= modulo\n        while assure <= n:\n            if visitados[assure] == -1:\n                part += 1\n                visitados[assure] = 2 * part\n \n                fila.append(assure)\n                break\n            assure += 1\n        if assure == n + 1:\n            break\n    ans *= pow(3, factor, modulo)\n    ans %= modulo\n    saida.append(str(ans))\nprint('\\n'.join(saida))", "from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n \nanss = []\nt = int(input())\n \nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n // 2) * ( n // 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n \n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n \n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n \n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef bfs(s):\n    q = deque([s])\n    color[s] = 1\n    b, w = 1, 0\n    \n    while q:\n        v = q.popleft()\n        \n        for nv in adj_list[v]:\n            if color[nv]==0:\n                color[nv] = -color[v]\n                q.append(nv)\n                \n                if color[nv]==1:\n                    b += 1\n                else:\n                    w += 1\n            else:\n                if color[nv]==color[v]:\n                    return -1, -1\n    \n    return b, w\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    uf = Unionfind(n)\n    MOD = 998244353\n    \n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj_list[u-1].append(v-1)\n        adj_list[v-1].append(u-1)\n        uf.unite(u-1, v-1)\n    \n    roots = set(uf.root(i) for i in range(n))\n    ans = 1\n    color = [0]*n\n    \n    for r in roots:\n        if uf.count(r)==1:\n            ans *= 3\n        else:\n            b, w = bfs(r)\n            \n            if b==-1:\n                ans = 0\n                break\n            else:\n                ans *= pow(2, b, MOD)+pow(2, w, MOD)\n        \n        ans %= MOD\n    \n    print(ans)", "import sys\ninput=sys.stdin.readline\n#from math import *\n#sys.setrecursionlimit(10**6)\nfrom collections import deque\nmod=998244353\nt=int(input())\ndef isbip2(i,vis,col,f):\n    q=deque()\n    q.append(i)\n    vis[i]=1\n    col[i]=0\n    f[0]+=1\n    while len(q)>0:\n        z=q.popleft()\n        for j in a[z]:\n            if col[z]==col[j]:\n                return 0\n            if vis[j]==0:\n                vis[j]=1\n                col[j]=col[z]^1\n                f[col[j]]+=1\n                q.append(j)\n    return 1  \n\ndef isbip(col,vis,n):\n    c=1\n    z=0;o=0\n    f=[0,0]\n    for i in range(1,n+1):\n        if vis[i]:\n            continue\n        if not isbip2(i,vis,col,f):\n            return 0\n        c=  (c%mod*(pow(2,f[0]-z,mod)+pow(2,f[1]-o,mod)))%mod \n\n        z=f[0]\n        o=f[1]\n    return c    \n    \nwhile t>0:\n    t-=1\n    n,m=list(map(int,input().split()))\n    col=[-1 for i in range(n+1)]\n    a=[[] for i in range(n+1)]\n    vis=[0 for i in range(n+1)]\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        a[x].append(y)\n        a[y].append(x)\n    print(isbip(col,vis,n))\n", "from sys import stdin,stdout\nfrom collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(122500) # max depth of recursion\nthreading.stack_size(2**25)\ndef main():\n    def power(x, p):\n        re = 1\n        mode= 998244353\n        while p:\n            if p & 1:\n                re = re * x % mode\n            x = x * x % mode\n            p >>= 1\n        return re;\n\n    def dfs(node,col):\n        visited[node]=True\n        c[col]+=1\n        color[node]=col\n        for j in dic[node]:\n            if not visited[j]:\n                if not dfs(j, col ^ 1):\n                    return False\n            else:\n                if color[j]==color[node]:\n                    return False\n        return True\n\n\n    t=int(stdin.readline())\n    for _ in range(t):\n        mod=998244353\n        n,m=list(map(int,stdin.readline().split()))\n        dic=defaultdict(list)\n        for i in range(m):\n            u,v=list(map(int,stdin.readline().split()))\n            dic[u].append(v)\n            dic[v].append(u)\n        visited=[False]*(n+1)\n        color=[-1]*(n+1)\n        c=[0]*2\n        result=1\n        flag=0\n        #print(dic)\n        for i in range(1,n+1):\n            if not visited[i]:\n                res=dfs(i,0)\n                if not res:\n                    flag=1\n                    break\n                else:\n                    result=(result*(power(2,c[0])+power(2,c[1])))%mod\n                    c[0]=0\n                    c[1]=0\n        if flag==1:\n            stdout.write(\"0\\n\")\n        else:\n            stdout.write(str(result)+\"\\n\")\nthreading.Thread(target=main).start()\n\n\n\n", "from sys import stdin,stdout\nfrom collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**25)\ndef main():\n    def power(x, p):\n        re = 1\n        mode= 998244353\n        while p:\n            if p & 1:\n                re = re * x % mode\n            x = x * x % mode\n            p >>= 1\n        return re;\n\n    def dfs(node,col):\n        visited[node]=True\n        c[col]+=1\n        color[node]=col\n        for j in dic[node]:\n            if not visited[j]:\n                if not dfs(j, col ^ 1):\n                    return False\n            else:\n                if color[j]==color[node]:\n                    return False\n        return True\n\n\n    t=int(stdin.readline())\n    for _ in range(t):\n        mod=998244353\n        n,m=list(map(int,stdin.readline().split()))\n        dic=defaultdict(list)\n        for i in range(m):\n            u,v=list(map(int,stdin.readline().split()))\n            dic[u].append(v)\n            dic[v].append(u)\n        visited=[False]*(n+1)\n        color=[-1]*(n+1)\n        c=[0]*2\n        result=1\n        flag=0\n        #print(dic)\n        for i in range(1,n+1):\n            if not visited[i]:\n                res=dfs(i,0)\n                if not res:\n                    flag=1\n                    break\n                else:\n                    result=(result*(power(2,c[0])+power(2,c[1])))%mod\n                    c[0]=0\n                    c[1]=0\n        if flag==1:\n            stdout.write(\"0\\n\")\n        else:\n            stdout.write(str(result)+\"\\n\")\nthreading.Thread(target=main).start()\n\n\n\n", "from sys import stdin,stdout\nfrom collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10**5) # max depth of recursion\nthreading.stack_size(2**25)\ndef main():\n    def power(x, p):\n        re = 1\n        mode= 998244353\n        while p:\n            if p & 1:\n                re = re * x % mode\n            x = x * x % mode\n            p >>= 1\n        return re;\n\n    def dfs(node,col):\n        visited[node]=True\n        c[col]+=1\n        color[node]=col\n        for j in dic[node]:\n            if not visited[j]:\n                if not dfs(j, col ^ 1):\n                    return False\n            else:\n                if color[j]==color[node]:\n                    return False\n        return True\n\n\n    t=int(stdin.readline())\n    for _ in range(t):\n        mod=998244353\n        n,m=list(map(int,stdin.readline().split()))\n        dic=defaultdict(list)\n        for i in range(m):\n            u,v=list(map(int,stdin.readline().split()))\n            dic[u].append(v)\n            dic[v].append(u)\n        visited=[False]*(n+1)\n        color=[-1]*(n+1)\n        c=[0]*2\n        result=1\n        flag=0\n        #print(dic)\n        for i in range(1,n+1):\n            if not visited[i]:\n                res=dfs(i,0)\n                if not res:\n                    flag=1\n                    break\n                else:\n                    result=(result*(power(2,c[0])+power(2,c[1])))%mod\n                    c[0]=0\n                    c[1]=0\n        if flag==1:\n            stdout.write(\"0\\n\")\n        else:\n            stdout.write(str(result)+\"\\n\")\nthreading.Thread(target=main).start()\n\n\n\n", "from sys import stdin,stdout\nfrom collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10**5) # max depth of recursion\nthreading.stack_size(2**25)\ndef main():\n    def power(x, p):\n        re = 1\n        mode= 998244353\n        while p:\n            if p & 1:\n                \n                re = re * x % mode\n            x = x * x % mode\n            p >>= 1\n        return re;\n\n    def dfs(node,col):\n        visited[node]=True\n        c[col]+=1\n        color[node]=col\n        for j in dic[node]:\n            if not visited[j]:\n                if not dfs(j, col ^ 1):\n                    return False\n            else:\n                if color[j]==color[node]:\n                    return False\n        return True\n\n\n    t=int(stdin.readline())\n    for _ in range(t):\n        mod=998244353\n        n,m=list(map(int,stdin.readline().split()))\n        dic=defaultdict(list)\n        for i in range(m):\n            u,v=list(map(int,stdin.readline().split()))\n            dic[u].append(v)\n            dic[v].append(u)\n        visited=[False]*(n+1)\n        color=[-1]*(n+1)\n        c=[0]*2\n        result=1\n        flag=0\n        #print(dic)\n        for i in range(1,n+1):\n            if not visited[i]:\n                res=dfs(i,0)\n                if not res:\n                    flag=1\n                    break\n                else:\n                    result=(result*(power(2,c[0])+power(2,c[1])))%mod\n                    c[0]=0\n                    c[1]=0\n        if flag==1:\n            stdout.write(\"0\\n\")\n        else:\n            stdout.write(str(result)+\"\\n\")\nthreading.Thread(target=main).start()\n\n\n\n", "import sys\nfrom collections import defaultdict,deque\nmod=998244353\ndef get(graph):\n    vis=defaultdict(int)\n    l=[]\n    for i in range(1,n+1):\n        if vis[i]==0:\n            vis[i]=1\n            q=deque()\n            q.append(i)\n            even=0\n            odd=0\n            while q:\n                a=q.popleft()\n                if vis[a]&1:\n                    odd+=1\n                else:\n                    even+=1\n                for x in graph[a]:\n                    if vis[x]==0:\n                        if vis[a]==1:\n                            vis[x]=2\n                        else:\n                            vis[x]=1\n                        q.append(x)\n                    else:\n                        if vis[x]==vis[a]:\n                            return 0\n            l.append([even,odd])\n    m=len(l)\n    x=pow(2,l[0][0],mod)\n    y=pow(2,l[0][1],mod)\n    ans=(x+y)%mod\n    for i in range(1,m):\n        x=pow(2,l[i][0],mod)\n        y=pow(2,l[i][1],mod)\n        z=(x+y)%mod\n        ans=ans*z\n        ans%=mod\n    return ans%mod\n    return False\n'''def count(graph):\n    vis=defaultdict(int)\n    even=0\n    odd=0\n    for i in range(1,n+1):\n        if vis[i]==0:\n            vis[i]=1\n            q=deque()\n            q.append([i,0])\n            while q:\n                a,dis=q.popleft()\n                if dis%2==0:\n                    even+=1\n                else:\n                    odd+=1\n                for x in graph[a]:\n                    if vis[x]==0:\n                        vis[x]=1\n                        q.append([x,dis+1])\n    return (even,odd)'''\nt=int(sys.stdin.readline())\nfor _ in range(t):\n    graph=defaultdict(list)\n    \n    n,m=list(map(int,sys.stdin.readline().split()))\n    for i in range(m):\n        u,v=list(map(int,sys.stdin.readline().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    '''if _ == 5:\n        print(graph)\n    #print(graph,'graph')'''\n    z=get(graph)\n    #print(z,'z')\n    print(z)\n", "import sys\nfrom collections import defaultdict,deque\nmod=998244353\ndef get(graph):\n    vis=defaultdict(int)\n    l=[]\n    for i in range(1,n+1):\n        if vis[i]==0:\n            vis[i]=1\n            q=deque()\n            q.append(i)\n            even=0\n            odd=0\n            while q:\n                a=q.popleft()\n                if vis[a]&1:\n                    odd+=1\n                else:\n                    even+=1\n                for x in graph[a]:\n                    if vis[x]==0:\n                        if vis[a]==1:\n                            vis[x]=2\n                        else:\n                            vis[x]=1\n                        q.append(x)\n                    else:\n                        if vis[x]==vis[a]:\n                            return 0\n            l.append([even,odd])\n    m=len(l)\n    x=pow(2,l[0][0],mod)\n    y=pow(2,l[0][1],mod)\n    ans=(x+y)%mod\n    for i in range(1,m):\n        x=pow(2,l[i][0],mod)\n        y=pow(2,l[i][1],mod)\n        z=(x+y)%mod\n        ans=ans*z\n        ans%=mod\n    return ans%mod\nt=int(sys.stdin.readline())\nfor _ in range(t):\n    graph=defaultdict(list)\n    \n    n,m=list(map(int,sys.stdin.readline().split()))\n    for i in range(m):\n        u,v=list(map(int,sys.stdin.readline().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    z=get(graph)\n    print(z)\n", "# Not my code\n# https://codeforces.com/contest/1093/submission/80633286\n\n# Template: https://codeforces.com/profile/kabeer27\nfrom __future__ import division, print_function\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\nmod = 998244353\ndef power(base, exp):\n    base %= mod\n    if exp < 3:\n        return (base**exp) % mod\n    half = power(base*base, exp//2)\n    return (half*base) % mod if exp % 2 == 1 else half % mod\n \n \ndef solve():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n+1)]\n    count, visited = [0, 0], [-1 for _ in range(n+1)]\n \n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    possible, ans = True, 1\n \n    @bootstrap\n    def dfs(node, par, parity):\n        nonlocal possible, visited, graph, count\n        if visited[node] != -1:\n            possible = False if visited[node] != parity else possible\n            yield None\n        visited[node] = parity\n        count[parity] += 1\n        for child in graph[node]:\n            if child != par:\n                yield dfs(child, node, 1-parity)\n        yield\n \n    # check for each node and update the answer\n    for i in range(1, n+1):\n        if visited[i] == -1:\n            count = [0, 0]\n            dfs(i, -1, 1)\n            ans *= (power(2, count[0]) + power(2, count[1])) % mod\n            ans %= mod\n \n    # print(ans if possible else 0)\n    sys.stdout.write(str(ans) if possible else '0')\n    sys.stdout.write('\\n')\n \ndef main():\n    tests = 1\n    tests = int(input().strip())\n    for test in range(tests):\n        solve()\n \n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nmain()"]
["px, py, vx, vy, a, b, c, d = map(int, input().split())\n\nvl = (vx**2 + vy**2)**0.5\nvx /= vl\nvy /= vl\n\nprint(px + vx * b, py + vy * b)\n\nprint(px - vy * a / 2, py + vx * a / 2)\nprint(px - vy * c / 2, py + vx * c / 2)\nprint(px - vy * c / 2 - vx * d, py + vx * c / 2 - vy * d)\n\nprint(px + vy * c / 2 - vx * d, py - vx * c / 2 - vy * d)\nprint(px + vy * c / 2, py - vx * c / 2)\nprint(px + vy * a / 2, py - vx * a / 2)", "3\n\nimport math\n\nclass Vector:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef length(self):\n\t\treturn math.hypot(self.x, self.y)\n\n\tdef normalize(self):\n\t\tself /= self.length()\n\n\tdef normalized(self):\n\t\treturn self / self.length()\n\n\tdef rotateLeft(self):\n\t\tx = self.x\n\t\ty = self.y\n\t\tself.x = -y\n\t\tself.y = x\n\n\tdef rotatedLeft(self):\n\t\tx = -self.y\n\t\ty = self.x\n\t\treturn Vector(x, y)\n\n\tdef rotateRight(self):\n\t\tx = self.x\n\t\ty = self.y\n\t\tself.x = y\n\t\tself.y = -x\n\n\tdef rotatedRight(self):\n\t\tx = self.y\n\t\ty = -self.x\n\t\treturn Vector(x, y)\n\n\tdef __iadd__(self, other):\n\t\tself.x += other.x\n\t\tself.y += other.y\n\t\treturn self\n\n\tdef __isub__(self, other):\n\t\tself.x -= other.x\n\t\tself.y -= other.y\n\t\treturn self\n\n\tdef __add__(self, other):\n\t\treturn Vector(self.x + other.x, self.y + other.y)\n\n\tdef __sub__(self, other):\n\t\treturn Vector(self.x - other.x, self.y - other.y)\n\n\tdef __imul__(self, other):\n\t\tself.x *= other\n\t\tself.y *= other\n\t\treturn self\n\n\tdef __itruediv__(self, other):\n\t\tself.x /= other\n\t\tself.y /= other\n\t\treturn self\n\n\tdef  __mul__(self, other):\n\t\treturn Vector(self.x * other, self.y * other)\n\n\tdef __truediv__(self, other):\n\t\treturn Vector(self.x / other, self.y / other)\n\n\tdef __neg__(self):\n\t\treturn Vector(-self.x, -self.y)\n\n\tdef __str__(self):\n\t\treturn str(self.x) + ' ' + str(self.y)\n\t\t# return \"{:.2f} {:.2f}\".format(self.x, self.y)\n\npx, py, vx, vy, a, b, c, d = [int(i) for i in input().split()]\n# px, py, vx, vy, a, b, c, d = [int(i) for i in \"8 8 0 2 8 3 4 5\".split()]\n\nLEFT = math.pi * 0.5\nRIGHT = -math.pi * 0.5\nBACK = math.pi\n\np = Vector(px, py)\nv = Vector(vx, vy)\n\nv.normalize()\n\nA = p + v * b\nB = p + v.rotatedLeft() * (a / 2)\nC = p + v.rotatedLeft() * (c / 2)\nD = C + (-v) * d\nF = p + v.rotatedRight() * (c / 2)\nE = F + (-v) * d\nG = p + v.rotatedRight() * (a / 2)\n\nprint(A)\nprint(B)\nprint(C)\nprint(D)\nprint(E)\nprint(F)\nprint(G)\n", "px, py, vx, vy, a, b, c, d = map(int, input().split())\n\nv = (vx**2 + vy**2)**.5\n\nprint('{} {}'.format(px + vx/v*b, py + vy/v*b))\nprint('{} {}'.format(px - vy/v*a/2, py + vx/v*a/2))\nprint('{} {}'.format(px - vy/v*c/2, py + vx/v*c/2))\nprint('{} {}'.format(px - vy/v*c/2 - vx/v*d, py + vx/v*c/2 - vy/v*d))\nprint('{} {}'.format(px + vy/v*c/2 - vx/v*d, py - vx/v*c/2 - vy/v*d))\nprint('{} {}'.format(px + vy/v*c/2, py - vx/v*c/2))\nprint('{} {}'.format(px + vy/v*a/2, py - vx/v*a/2))", "xp, yp, vx, vy, a, b, c, d = [int(x) for x in input().split()]\nL = (vx**2 + vy**2) ** 0.5\nvx, vy = vx/L, vy/L\nA = [0 for i in range(7)]\nA[0] = (b*vx, b*vy)\nA[1] = (-a*vy/2, a*vx/2)\nA[2] = (-c*vy/2, c*vx/2)\nA[3] = (-c*vy/2 - d*vx, c*vx/2 - d*vy)\nA[4] = (c*vy/2 - d*vx, -c*vx/2 - d*vy)\nA[5] = (c*vy/2, -c*vx/2)\nA[6] = (a*vy/2, -a*vx/2)\nfor x, y in A:\n    print(x + xp, y + yp)\n", "from decimal import *\nfrom math import sqrt\n\ndef __starting_point():\n\n    getcontext().prec = 50\n\n    px , py , vx , vy , a , b , c , d = map( Decimal , input().split() )\n\n    absv = Decimal(sqrt(vx**2+vy**2))\n\n    n0x = vx/absv\n    n0y = n0y = vy/absv\n    #print( \"n0 :\" , n0x , n0y )\n\n    n1x , n1y = n0y , -n0x\n    #print( \"n1 :\" , n1x , n1y )\n    n2x , n2y = -n0x , -n0y\n    #print( \"n2 :\" , n2x , n2y )\n    n3x , n3y = -n0y , n0x\n    #print( \"n3 :\" , n3x , n3y )\n    #print()\n\n    print(px+b*n0x,py+b*n0y)\n    print(px+a*n3x/2,py+a*n3y/2)\n\n    p2x = px + n3x*(c/2)\n    p2y = py + n3y*(c/2)\n    print(p2x,p2y)\n\n    print(p2x+n2x*d,p2y+n2y*d)\n\n    p3x = px + n1x*(c/2)\n    p3y = py + n1y*(c/2)\n    print(p3x+n2x*d,p3y+n2y*d)\n\n    print(p3x,p3y)\n\n    print(px+a*n1x/2,py+a*n1y/2)\n__starting_point()", "xp, yp, vx, vy, a, b, c, d = [int(x) for x in input().split()]\nL = (vx**2 + vy**2) ** 0.5\nvx, vy = vx/L, vy/L\nA = [0 for i in range(7)]\nA[0] = (b*vx, b*vy)\nA[1] = (-a*vy/2, a*vx/2)\nA[2] = (-c*vy/2, c*vx/2)\nA[3] = (-c*vy/2 - d*vx, c*vx/2 - d*vy)\nA[4] = (c*vy/2 - d*vx, -c*vx/2 - d*vy)\nA[5] = (c*vy/2, -c*vx/2)\nA[6] = (a*vy/2, -a*vx/2)\nfor x, y in A:\n    print(x + xp, y + yp)", "px, py, vx, vy, a, b, c, d = map(int, input().split())\n\nv = (vx**2 + vy**2)**.5\n\nprint('{} {}'.format(px + vx/v*b, py + vy/v*b))\nprint('{} {}'.format(px - vy/v*a/2, py + vx/v*a/2))\nprint('{} {}'.format(px - vy/v*c/2, py + vx/v*c/2))\nprint('{} {}'.format(px - vy/v*c/2 - vx/v*d, py + vx/v*c/2 - vy/v*d))\nprint('{} {}'.format(px + vy/v*c/2 - vx/v*d, py - vx/v*c/2 - vy/v*d))\nprint('{} {}'.format(px + vy/v*c/2, py - vx/v*c/2))\nprint('{} {}'.format(px + vy/v*a/2, py - vx/v*a/2))", "class Point:\n    x = 0.\n    y = 0.\n\n    def __init__(self, x = 0, y = 0):\n        self.x = x\n        self.y = y\n\n    def print(self):\n        print(self.x, self.y)\n\ndef add(a, b):\n    return Point(a.x + b.x, a.y + b.y)\n\ndef ln(a):\n    return (a.x * a.x + a.y * a.y) ** 0.5\n\ndef norm(a):\n    b = a\n    l = ln(a)\n    b.x /= l\n    b.y /= l\n    return b\n\ndef mult(a, b):\n    return Point(a.x * b, a.y * b)\n\ndef rot(a):\n    return Point(a.y, -a.x)\n\np = Point()\nv = Point()\np.x, p.y, v.x, v.y, a, b, c, d = map(float, input().split())\n\nv = norm(v)\nr1 = add(p, mult(v, b))\n\nv = rot(v)\nr7 = add(p, mult(v, a / 2))\nr6 = add(p, mult(v, c / 2))\nv = rot(v)\nr5 = add(r6, mult(v, d))\nv = rot(v)\nr2 = add(p, mult(v, a / 2))\nr3 = add(p, mult(v, c / 2))\nv = rot(rot(rot(v)))\nr4 = add(r3, mult(v, d))\n\n\nr1.print()\nr2.print()\nr3.print()\nr4.print()\nr5.print()\nr6.print()\nr7.print()\n", "xp, yp, vx, vy, a, b, c, d = [int(x) for x in input().split()]\nL = (vx**2 + vy**2) ** 0.5\nvx, vy = vx/L, vy/L\nA = [0 for i in range(7)]\nA[0] = (b*vx, b*vy)\nA[1] = (-a*vy/2, a*vx/2)\nA[2] = (-c*vy/2, c*vx/2)\nA[3] = (-c*vy/2 - d*vx, c*vx/2 - d*vy)\nA[4] = (c*vy/2 - d*vx, -c*vx/2 - d*vy)\nA[5] = (c*vy/2, -c*vx/2)\nA[6] = (a*vy/2, -a*vx/2)\nfor x, y in A:\n    print(x + xp, y + yp)", "import math\n\npx, py, vx, vy, a, b, c, d = list(map(int, input().split(' ')))\n\nl = math.sqrt(vx*vx+vy*vy)\n\nprint(px+b/l*vx, py+b/l*vy)\nprint(px-a/2/l*vy, py+a/2/l*vx)\nprint(px-c/2/l*vy, py+c/2/l*vx)\nprint(px-c/2/l*vy-d/l*vx, py+c/2/l*vx-d/l*vy)\nprint(px+c/2/l*vy-d/l*vx, py-c/2/l*vx-d/l*vy)\nprint(px+c/2/l*vy, py-c/2/l*vx)\nprint(px+a/2/l*vy, py-a/2/l*vx)\n", "import math\ns=input()\nl=s.split()\npx= float(l[0])\npy= float(l[1])\nvx= float(l[2])\nvy= float(l[3])\na= float(l[4])\nb= float(l[5])\nc= float(l[6])\nd= float(l[7])\na2 =a/2\nc2 =c/2\ndef getLeft90(x,y):\n    return [-y,x]\n\ndef getRight90(x,y):\n    return [y,-x]\n\ndef  getEndPoint (bx,by,vx,vy,l):\n    vl=math.sqrt(vx*vx+vy*vy)\n    ex=l*vx/vl+bx\n    ey=l*vy/vl+by\n    return [ex,ey]\nsol=[]\nsol.append(getEndPoint(px,py,vx,vy,b))\nvLeft= getLeft90(vx,vy)\nsol.append( getEndPoint(px,py,vLeft[0],vLeft[1],a2))\n\np2=getEndPoint(px,py,vLeft[0],vLeft[1],c2)\nsol.append(p2)\nsol.append(getEndPoint(p2[0],p2[1],-vx,-vy,d)) #p3\nvRight= getRight90(vx,vy)\np5=getEndPoint(px,py,vRight[0],vRight[1],c2)\nsol.append( getEndPoint(p5[0],p5[1],-vx,-vy,d)) #p4\nsol.append(p5)\nsol.append(getEndPoint(px,py,vRight[0],vRight[1],a2))#p6\n\n\n\nfor i in sol:\n    print(\"%.9f %.9f\" % (i[0],i[1]))\n", "l = [0] + list(map(int, input().split()))\nfrom math import sqrt\nk = l[6] / sqrt(l[3]**2 + l[4]**2)\nA = (l[1] + l[3] * k, l[2] + l[4] * k)\nl[3], l[4] = -l[4], l[3]\nk = l[5] / (2 * sqrt(l[3]**2 + l[4]**2))\nB = (l[1] + l[3] * k, l[2] + l[4] * k)\nk = l[7] / (2 * sqrt(l[3]**2 + l[4]**2))\nC = (l[1] + l[3] * k, l[2] + l[4] * k)\nF = (2 * l[1] - C[0], 2 * l[2] - C[1])\nG = (2 * l[1] - B[0], 2 * l[2] - B[1])\nL = [l[3], l[4]] \nl[3], l[4] = -l[4], l[3]\nR = [-l[4], l[3]]\nK = l[7] / (2 * sqrt(l[3]**2 + l[4]**2))\nk = l[8] / sqrt(l[3]**2 + l[4]**2)\nM = (l[1] + l[3] * k, l[2] + l[4] * k)\nD = (M[0] + L[0] * K, M[1] + L[1] * K)\nE = (M[0] + R[0] * K, M[1] + R[1] * K)\n\nprint(*A)\nprint(*B)\nprint(*C)\nprint(*D)\nprint(*E)\nprint(*F)\nprint(*G)\n\n\n\n\n\n\n", "from math import sin, cos, atan2, sqrt, pi\npx, py, vx, vy, a, b, c, d = [float(i) for i in input().split()]\n\nangle = atan2(vy,vx)\n\n\ndef rotate(x0, y0, x, y, alpha):\n    local_x = x - x0\n    local_y = y - y0\n    point_angle = atan2(local_y, local_x)\n\n    length = sqrt((x - x0)**2.0 + (y - y0)**2.0)\n    return x0 + length * sin(point_angle + alpha), y0 - length * cos(point_angle + alpha)\n\n\nr0 = px, py + b\nr6 = px + a/2.0, py\nr5 = px + c/2.0, py\nr4 = px + c/2.0, py - d\nr3 = px - c/2.0, py - d\nr2 = px - c/2.0, py\nr1 = px - a/2.0, py\n\npoints = [r0, r1, r2, r3, r4, r5, r6]\n\nfor point in points:\n    new_point = rotate(px, py, point[0], point[1], angle)\n    print(\" \".join(map(str, new_point)))\n\n", "import math\n\ntab=[float(i) for i in input().split()]\n\ntabx=[0,0,0,0,0,0,0]\ntaby=[0,0,0,0,0,0,0]\n\ntabx[0]=tab[0]+tab[5]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[0]=tab[1]+tab[5]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[1]=tab[0]-0.5*tab[4]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[1]=tab[1]+0.5*tab[4]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[2]=tab[0]-0.5*tab[6]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[2]=tab[1]+0.5*tab[6]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[3]=tabx[2]-tab[7]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[3]=taby[2]-tab[7]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[4]=tabx[3]+tab[6]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[4]=taby[3]-tab[6]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[5]=tab[0]+0.5*tab[6]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[5]=tab[1]-0.5*tab[6]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\n\ntabx[6]=tab[0]+0.5*tab[4]*tab[3]/(math.sqrt(tab[2]**2+tab[3]**2))\ntaby[6]=tab[1]-0.5*tab[4]*tab[2]/(math.sqrt(tab[2]**2+tab[3]**2))\n\nfor i in range(0,7) :\n\tprint(\"{:10.12f}\".format(tabx[i]), \" \", \"{:10.12f}\".format(taby[i]))", "import math\nfrom decimal import Decimal\n\npx,py,vx,vy,a,b,c,d = map(Decimal, input().split())\n\nh = (vx**2 + vy**2).sqrt()\n\nvx, vy = vx / h, vy / h \n\nprint(\"%0.60f %0.60f\" % (px + vx * b, py + vy * b))\nprint(\"%0.60f %0.60f\" % (px - a/2 * vy, py + a/2 * vx))\nprint(\"%0.60f %0.60f\" % (px - c / 2 * vy, py + c / 2 * vx))\n#print(\"%0.60f %0.60f\" % (px + vx * b, py + vy * b))\n#print(\"%0.60f %0.60f\" % (px + vx * b, py + vy * b))\n\nprint(\"%0.60f %0.60f\" % (px - c / 2 * vy - d * vx, py + c / 2 * vx - d*vy))\nprint(\"%0.60f %0.60f\" % (px + c / 2 * vy - d * vx, py - c / 2 * vx - d*vy))\n\nprint(\"%0.60f %0.60f\" % (px + c / 2 * vy, py - c / 2 * vx))\nprint(\"%0.60f %0.60f\" % (px + a/2 * vy, py - a/2 * vx))", "import math\n\npx, py, vx, vy, a, b, c, d = list(map(int, input().split(' ')))\n\nl = math.sqrt(vx*vx+vy*vy)\n\nprint(px+b/l*vx, py+b/l*vy)\nprint(px-a/2/l*vy, py+a/2/l*vx)\nprint(px-c/2/l*vy, py+c/2/l*vx)\nprint(px-c/2/l*vy-d/l*vx, py+c/2/l*vx-d/l*vy)\nprint(px+c/2/l*vy-d/l*vx, py-c/2/l*vx-d/l*vy)\nprint(px+c/2/l*vy, py-c/2/l*vx)\nprint(px+a/2/l*vy, py-a/2/l*vx)\n", "from sys import stdin\nfrom math import sqrt\npx, py, vx, vy, a, b, c, d = map(int, stdin.readline().split())\nlength = sqrt(vx*vx + vy*vy)\nvx = vx/length\nvy = vy/length\nvlx, vly = -vy, vx\nvrx, vry = vy, -vx\nmidcx = px + vx * -d\nmidcy = py + vy * -d\n# 1\nx = px + vx * b\ny = py + vy * b\nprint(x, y)\n# 2\nx = px + vlx * a/2\ny = py + vly * a/2\nprint(x, y)\n# 3\nx = px + vlx * c/2\ny = py + vly * c/2\nprint(x, y)\n# 4\nx = midcx + vlx * c/2\ny = midcy + vly * c/2\nprint(x, y)\n# 5\nx = midcx + vrx * c/2\ny = midcy + vry * c/2\nprint(x, y)\n# 6\nx = px + vrx * c/2\ny = py + vry * c/2\nprint(x, y)\n# 7\nx = px + vrx * a/2\ny = py + vry * a/2\nprint(x, y)", "from decimal import *\nfrom math import sqrt\ngetcontext().prec = 100\npx , py , vx , vy , a , b , c , d = list(map (Decimal, input().split()))\nabsv = Decimal(sqrt(vx**2 + vy**2))\nn0x = vx / absv\nn0y = vy / absv\nn1x , n1y = n0y , -n0x\nn2x , n2y = -n0x , -n0y\nn3x , n3y = -n0y , n0x\nprint(px + b * n0x, py + b * n0y)\nprint(px + a * n3x / 2, py + a * n3y / 2)\np2x = px + n3x * (c / 2)\np2y = py + n3y * (c / 2)\nprint(p2x, p2y)\nprint(p2x + n2x * d, p2y + n2y * d)\np3x = px + n1x * (c / 2)\np3y = py + n1y * (c / 2)\nprint(p3x + n2x * d, p3y + n2y * d)\nprint(p3x, p3y)\nprint(px + a * n1x / 2, py + a * n1y / 2)\n", "from math import sqrt\n\npx, py, vx, vy, a, b, c, d = (int(x) for x in input().split())\n\nveclen = sqrt(vx**2 + vy**2)\n\nnewvx = b/veclen * vx\nnewvy = b/veclen * vy\n\npoint1x = px + newvx\npoint1y = py + newvy\n\nnewvx, newvy = -newvy, newvx\n\nveclen = sqrt(newvx**2 + newvy**2)\n\nnewvx = (a/2)/veclen * newvx\nnewvy = (a/2)/veclen * newvy\n\npoint2x = px + newvx\npoint2y = py + newvy\n\npoint7x = px - newvx\npoint7y = py - newvy\n\nveclen = sqrt(newvx**2 + newvy**2)\n\nnewvx = (c/2)/veclen * newvx\nnewvy = (c/2)/veclen * newvy\n\npoint3x = px + newvx\npoint3y = py + newvy\n\npoint6x = px - newvx\npoint6y = py - newvy\n\nnewvx, newvy = -newvy, newvx\n\nveclen = sqrt(newvx**2 + newvy**2)\n\nnewvx = (d)/veclen * newvx\nnewvy = (d)/veclen * newvy\n\npoint4x = point3x + newvx\npoint4y = point3y + newvy\n\npoint5x = point6x + newvx\npoint5y = point6y + newvy\n\nprint(str(point1x)+\" \"+str(point1y))\nprint(str(point2x)+\" \"+str(point2y))\nprint(str(point3x)+\" \"+str(point3y))\nprint(str(point4x)+\" \"+str(point4y))\nprint(str(point5x)+\" \"+str(point5y))\nprint(str(point6x)+\" \"+str(point6y))\nprint(str(point7x)+\" \"+str(point7y))", "import math\n\n\nln = input().split(\" \")\npx = int(ln[0])\npy = int(ln[1])\nvx = int(ln[2])\nvy = int(ln[3])\na = int(ln[4])\nb = int(ln[5])\nc = int(ln[6])\nd = int(ln[7])\n\nx_dir = vx / math.sqrt(vx ** 2 + vy ** 2)\ny_dir = vy / math.sqrt(vx ** 2 + vy ** 2)\n\nprint(px + b * x_dir, py + b * y_dir)\nprint(px - a / 2 * y_dir, py + a / 2 * x_dir)\nprint(px - c / 2 * y_dir, py + c / 2 * x_dir)\nprint(px - c / 2 * y_dir - d * x_dir, py + c / 2 * x_dir - d * y_dir)\nprint(px + c / 2 * y_dir - d * x_dir, py - c / 2 * x_dir - d * y_dir)\nprint(px + c / 2 * y_dir, py - c / 2 * x_dir)\nprint(px + a / 2 * y_dir, py - a / 2 * x_dir)\n", "import math\n\npx, py, vx, vy, a, b, c, d = list(map(int, input().split()))\n\nl = math.sqrt(vx**2 + vy**2)\n\ngx, gy = px + ((-1 * vx * d) / l), py + ((-1 * vy * d) / l)\n\npts = []\npts.append([px + ((b * vx) / l), py + ((b * vy) / l)])\npts.append([px + ((-1 * (a / 2) * vy) / l), py + ((vx * (a / 2)) / l)])\npts.append([px + ((-1 * vy * (c / 2)) / l), py + ((vx * (c / 2)) / l)])\npts.append([gx + ((-1 * (c / 2) * vy) / l), gy + ((vx * (c / 2)) / l)])\npts.append([gx + (((c / 2) * vy) / l), gy + ((-1 * vx * (c / 2)) / l)])\npts.append([px + ((vy * (c / 2)) / l), py + ((-1 * vx * (c / 2)) / l)])\npts.append([px + (((a / 2) * vy) / l), py + ((-1 * vx * (a / 2)) / l)])\n\nfor x in pts:\n    print(x[0], x[1])\n", "import math\n\ndef main():\n    x, y, vx, vy, a, b, c, d = map(int, input().split())\n    \n    len = math.sqrt(vx * vx + vy * vy)\n    vx /= len\n    vy /= len\n    \n    print(x + vx * b, y + vy * b)\n    \n    print(x - vy * a / 2, y + vx * a / 2)\n    print(x - vy * c / 2, y + vx * c / 2)\n    print(x - vy * c / 2 - vx * d, y + vx * c / 2 - vy * d)\n    \n    print(x + vy * c / 2 - vx * d, y - vx * c / 2 - vy * d)\n    print(2 * x - (x - vy * c / 2), 2 * y - (y + vx * c / 2))\n    print(2 * x - (x - vy * a / 2), 2 * y - (y + vx * a / 2))\n    \nmain()", "import math\n\ndef main():\n    x, y, vx, vy, s, a, c, d = map(int, input().split(' '))\n    \n    l = math.sqrt(vx ** 2 + vy ** 2)\n    \n    print(x + a / l * vx, y + a / l * vy)\n    print(x - s / 2 / l * vy, y + s / 2 / l * vx)\n    print(x - c / 2 / l * vy, y + c / 2 / l * vx)\n    print(x - c / 2 / l * vy - d / l * vx, y + c / 2 / l * vx - d / l * vy)\n    print(x + c / 2 / l * vy - d / l * vx, y - c / 2 / l * vx - d / l * vy)\n    print(x + c / 2 / l * vy, y - c / 2 / l * vx)\n    print(x + s / 2 / l * vy, y - s / 2 / l * vx)\n\nmain()", "from math import atan2, pi\n\nEPS = 0.00000001\n\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\n\nclass Vector:\n    def __init__(self, x2, y2, x1=0, y1=0):\n        self.x = (x2 - x1)\n        self.y = y2 - y1\n        self.s = (self.x ** 2 + self.y ** 2) ** 0.5\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def mul_k(self, k):\n        self.x *= k\n        self.y *= k\n\n    def mul_kk(self, k):\n        return Vector(self.x * k, self.y * k)\n\n    def rotate(self):\n        return Vector(-self.y, self.x)\n\n    def rotate2(self):\n        return self.rotate().rotate().rotate()\n\n    def reverseee(self):\n        return Vector(-self.x, -self.y)\n\n    def __mul__(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def vectormul(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def get_angle(self, other):\n        return atan2(self.vectormul(other), self * other)\n\n    def norm(self):\n        if self.s == 0:\n            return Vector(self.x, self.y)\n        return Vector(self.x / self.s, self.y / self.s)\n\n    def __str__(self):\n        return f'{self.x} {self.y}'\n\n    def middle(self, point):\n        return Vector((self.x + point.x) / 2, (self.y + point.y) / 2)\n\n\nclass Line:\n    def __init__(self, point=None, vector=None, point2=None, a=None, b=None, c=None):\n        if a is not None:\n            self.v = Vector(a, b).rotate()\n            self.p = Vector(a, b)\n            self.p.mul_k(-c / (a ** 2 + b ** 2))\n            self.A = a\n            self.B = b\n            self.C = c\n            return\n        if vector is None:\n            vector = point2 - point\n        self.p = point\n        self.v = vector\n        self.A = self.v.y\n        self.B = -self.v.x\n        self.C = - self.A * self.p.x - self.p.y * self.B\n\n    def get_abc(self):\n        return self.A, self.B, self.C\n\n    def __str__(self):\n        return str(self.A) + ' ' + str(self.B) + ' ' + str(self.C)\n\n    def check(self, point):\n        return eq(- point.x * self.A - self.B * point.y, self.C)\n\n    def get_s_from_point(self, point):\n        v = self.v.norm()\n        v2 = point - self.p\n        a = v * v2\n        v.mul_k(a)\n        v3 = v + self.p\n        s = v3 - point\n        return s.s\n\n    def get_bisect(self, line):\n        return Line(point=self.get_peresech(line)[1], vector=self.v.norm() + line.v.norm())\n\n    def get_proection(self, point):\n        v = self.v.norm()\n        v2 = point - self.p\n        a = v * v2\n        v.mul_k(a)\n        v3 = v + self.p\n        return v3\n\n    def get_paral_line(self, le):\n        v = self.v.norm().rotate()\n        v.mul_k(le)\n        return Line(point=self.p + v, vector=self.v)\n\n    def get_peresech(self, lin):\n        u = lin.v.rotate()\n        a = self.v * u\n        if eq(a, 0):\n            if eq(self.get_s_from_point(lin.p), 0):\n                return (2,)\n            return (0,)\n        t = ((lin.p - self.p) * u) / (self.v * u)\n        v = Vector(self.v.x, self.v.y)\n        v.mul_k(t)\n        return (1, self.p + v)\n\n    def get_mirror(self, point):\n        v = self.v.norm()\n        v2 = point - self.p\n        a = v * v2\n        v.mul_k(a)\n        v3 = v + self.p\n        s = v3 - point\n        return s + v3\n\n\ndef is_on_line(v1, v2):\n    return eq(v1.vectormul(v2), 0)\n\n\ndef is_on_luch(v1, v2):\n    return eq(v1.get_angle(v2), 0)\n\n\ndef is_on_otr(v1, v2, v3, v4):\n    return eq(v1.get_angle(v2), 0) and eq(v3.get_angle(v4), 0)\n\n\ndef get_s_from_luch(xp, yp, x1, y1, x2, y2):\n    v = Vector(x2, y2, x1, y1).norm()\n    v2 = Vector(xp, yp, x1, y1)\n    a = v * v2\n    v1 = Vector(x2, y2, x1, y1)\n    v.mul_k(a)\n    v3 = v + Vector(x1, y1)\n    xh, yh = v3.x, v3.y\n    v4 = Vector(xh, yh, x1, y1)\n    b = v1.get_angle(v4)\n    if eq(b, 0):\n        se = v3 - Vector(xp, yp)\n        return se.s\n    else:\n        return (Vector(x1, y1) - Vector(xp, yp)).s\n\n\ndef get_s_from_otr(xp, yp, x1, y1, x2, y2):\n    return max(get_s_from_luch(xp, yp, x1, y1, x2, y2), get_s_from_luch(xp, yp, x2, y2, x1, y1))\n\n\ndef get_s_from_line(xp, yp, x1, y1, x2, y2):\n    v = Vector(x2, y2, x1, y1).norm()\n    v2 = Vector(xp, yp, x1, y1)\n    a = v * v2\n    return a\n\n\ndef peresec_otr(x1, y1, x2, y2, x3, y3, x4, y4):\n    AB = Vector(x2, y2, x1, y1)\n    CD = Vector(x4, y4, x3, y3)\n    AC = Vector(x3, y3, x1, y1)\n    AD = Vector(x4, y4, x1, y1)\n    CA = Vector(x1, y1, x3, y3)\n    CB = Vector(x2, y2, x3, y3)\n    yg1 = AB.get_angle(AD)\n    yg2 = AB.get_angle(AC)\n    yg3 = CD.get_angle(CA)\n    yg4 = CD.get_angle(CB)\n    flag = False\n    if (yg1 < 0 and yg2 < 0) or (yg1 > 0 and yg2 > 0):\n        flag = True\n    if (yg3 < 0 and yg4 < 0) or (yg3 > 0 and yg4 > 0):\n        flag = True\n    if max(min(x1, x2), min(x3, x4)) > min(max(x1, x2), max(x3, x4)):\n        flag = True\n    if max(min(y1, y2), min(y3, y4)) > min(max(y1, y2), max(y3, y4)):\n        flag = True\n    return not flag\n\n\ndef get_s_from_otr_to_otr(x1, y1, x2, y2, x3, y3, x4, y4):\n    if peresec_otr(x1, y1, x2, y2, x3, y3, x4, y4):\n        return 0\n    return min(get_s_from_otr(x1, y1, x3, y3, x4, y4), get_s_from_otr(x2, y2, x3, y3, x4, y4),\n               get_s_from_otr(x3, y3, x1, y1, x2, y2), get_s_from_otr(x4, y4, x1, y1, x2, y2))\n\n\ndef main():\n    px, py, vx, vy, a, b, c, d = map(int, input().split())\n    P = Vector(px, py)\n    V = Vector(vx, vy).norm()\n    A = V.mul_kk(b) + P\n    B = V.mul_kk(a/2).rotate() + P\n    C = V.mul_kk(c/2).rotate() + P\n    D = C + V.rotate().rotate().mul_kk(d)\n    E = D + V.rotate2().mul_kk(c)\n    F = P + V.rotate2().mul_kk(c/2)\n    G = P + V.rotate2().mul_kk(a/2)\n    print(A, B, C, D, E, F, G, sep='\\n')\n\n\nmain()\n", "from math import *\n\npx, py, vx, vy, a, b, c, d = list(map(int, input().split()))\n\ntri_top = 0, 0 + b\ntri_right = 0 + a / 2, 0\ntri_left = 0 - a / 2, 0\n\nrect_top_right = 0 + c / 2, 0\nrect_top_left = 0 - c / 2, 0\nrect_bottom_right = 0 + c / 2, 0 - d\nrect_bottom_left = 0 - c / 2, 0 - d\n\ntheta = atan2(vx, vy)\n\ndef work(pt):\n    init_theta = atan2(pt[0], pt[1])\n    new_theta = init_theta + theta\n    rad = sqrt(pt[0]**2 + pt[1]**2)\n    x = sin(new_theta) * rad + px\n    y = cos(new_theta) * rad + py\n    return str(x) + ' ' + str(y)\n\nprint(work(tri_top))\nprint(work(tri_left))\nprint(work(rect_top_left))\nprint(work(rect_bottom_left))\nprint(work(rect_bottom_right))\nprint(work(rect_top_right))\nprint(work(tri_right))\n"]
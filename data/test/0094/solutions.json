["n=int(input())\ns=input()\npw=[1]\nlast=1\nfor i in range(70):\n    if (last>1e19):\n        break\n    pw.append(last*n)\n    last=last*n\ndp=[1e19]*100\nfor i in range(100):\n    dp[i]=[1e19]*100\ndp[len(s)][0]=0\nfor i in range(len(s),-1,-1):\n    for power in range(0,len(pw)):\n        cur=''\n        for j in range(i-1,-1,-1):\n            cur=s[j]+cur\n            if (int(cur)>n or int(cur)*pw[power]>1e19):\n                break;\n            if ((cur[0]!='0' or len(cur)==1) and int(cur)<n):\n                dp[j][power+1]=min(dp[j][power+1],dp[i][power]+int(cur)*pw[power])\nprint(min(dp[0]))", "n = int(input())\nK = input()\nm = len(K)\n\ninf = 10 ** 100\n\ndp = [inf] * (m + 1)\ndp[0] = 0\n\nfor i in range(m):\n\tif K[i] == '0':\n\t\tdp[i + 1] = min(dp[i + 1], dp[i] * n + int(K[i]))\n\telse:\n\t\tval = 0\n\t\tfor j in range(i, m):\n\t\t\tval = val * 10 + int(K[j])\n\t\t\tif val >= n: break\n\t\t\tdp[j + 1] = min(dp[j + 1], dp[i] * n + val)\n\nprint(dp[m])\n\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nn = int(input())\nk = int(input())\n\narr = []\nidx = 0\nwhile k > 0:\n    while 10 ** idx <= k and k % (10 ** idx) < n:\n        idx += 1\n    if k % (10 ** idx) >= n:\n        idx -= 1\n    while idx > 1 and k % (10 ** idx) == k % (10 ** (idx - 1)):\n        idx -= 1\n    arr.append(k % (10 ** idx))\n    k //= (10 ** idx)\n    idx = 0\nmul = 1\nsm = 0\nfor item in arr:\n    sm += item * mul\n    mul *= n\nprint(sm)\n", "n = int(input())\nk = list(map(int, list(input())))\nm = len(k)\nrec = [0] * (m + 1)\nfor i in range(m):\n  u = rec[i] * n\n  if k[i] > 0:\n    d = 0\n    for j in range(i, m):\n      d = d*10 + k[j]\n      if d >= n: break\n      if rec[j+1]: rec[j+1] = min(rec[j+1], u+d)\n      else: rec[j+1] = u+d\n      #print(d, j+1, rec)\n  else:    \n    if rec[i+1]: rec[i+1] = min(rec[i+1], u)\n    else: rec[i+1] = u\n    #print(i, rec)\nprint(rec[-1])\n\n\n", "def check(s, n):\n    ans = 0\n    if s != \"\":\n        ans = int(s)\n        \n    return ans < n\n\nn = int(input())\nk = input()\n\ns = \"\"\ni = len(k) - 1\n\nans = 0\nadd = 1\nwhile i >= 0:\n    while i >= 0 and check(k[i] + s, n):\n        s = k[i] + s\n        i -= 1\n    while len(s) > 1 and s[0] == '0':\n        s = s[1:]\n        i += 1\n\n    \n    ans += int(s) * add\n    add *= n\n    s = \"\"\n\nprint(ans)", "import sys\n\ndpp = [[0] * 100 for i in range(100)]\nused = [[0] * 100 for i in range(100)]\ninf = (1 << 300)\n\ndef dp(pos, i):\n    if pos >= k:\n        return '0'\n    hh = n ** i\n    if pos == k - 1:\n        return str(int(s[pos]) * hh)\n    if used[pos][i]:\n        return dpp[pos][i]\n    used[pos][i] = 1\n    temp = s[pos]\n    ans = inf\n    best = '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'\n    ctr = pos\n    while int(temp) < n:\n        if (temp[0] == '0' and len(temp) > 1):\n            if ctr == k - 1:\n                break\n            ctr += 1\n            temp = s[ctr] + temp\n            continue\n        tt = dp(ctr + 1, i + 1)\n        gg = str(int(tt) + int(temp) * hh)\n        if (int(gg) < ans):\n            ans = int(gg)\n            best = gg\n        if ctr == k - 1:\n            break\n        ctr += 1\n        temp = s[ctr] + temp\n    dpp[pos][i] = best\n    return best\n    \n\nn = int(input())\ns = input()[::-1]\nk = len(s)\nprint(int(dp(0, 0)))\n\n\n", "n = int(input())\nk = input()\npos = len(k)\nans = []\nwhile pos > 0:\n    tmp = 0\n    l = pos-1\n    mark = l\n    while l >= 0:\n        a = int(k[l:pos])\n        if a >= n:\n            break\n        else:\n            if a != tmp: mark = l\n            tmp = a\n            l -= 1\n            \n    if tmp == 0:\n        pos -= 1\n        ans.append(0)\n    else:\n        pos = mark\n        ans.append(tmp)\n\naans = 0\nfor i in ans[::-1]:\n    aans = aans*n + i\n\nprint(aans)\n", "# I'm feeling greedy\nbase = int(input())\nnum = input()\n\nresult = 0\nplace_value = 1\nend = len(num)\nwhile end > 0:\n    begin = end - 1\n    good_begin = begin\n    while begin >= 0:\n        if int(num[begin:end]) >= base:\n            break\n        elif num[begin] != '0':\n            good_begin = begin\n        begin -= 1\n    begin = good_begin\n    result += place_value * int(num[begin:end])\n    place_value *= base\n    end = begin\n\nprint(result)\n", "base = int(input())\nnum = input()\n\na = 0\nn = ''\nl = []\nsk = len(str(base))\nwhile num:\n    nn = num[-sk:]\n    j = 0\n    while int(nn) >= base:\n        j += 1\n        nn = nn[1:]\n    while len(nn) > 1 and nn[0] == '0':\n        j += 1\n        nn = nn[1:]\n    l.append(int(nn))\n    num = num[:-sk+j]\n    \np = 1\nfor n in l:\n    a += p * n\n    p *= base\nprint(a)\n", "def solve(n, k):\n    dp = [420] * (len(k) + 1)\n    dp[-1] = 0\n    idx = len(k) - 1\n    n_num = int(n)\n    while idx >= 0:\n        if k[idx] != '0':\n            for shift in range(1, len(k) - idx + 1):\n                ok = int(k[idx:idx+shift]) < n_num\n                if ok:\n                    dp[idx] = min(\n                        dp[idx], 1 + dp[idx+shift]\n                    )\n                else:\n                    break\n        else:\n            dp[idx] = 1 + dp[idx+1]\n        idx -= 1\n    digits = list()\n    idx = 0\n    while idx < len(k):\n        shift = 1\n        while idx + shift <= len(k):\n            if dp[idx+shift]+1 == dp[idx]:\n                digits.append(int(k[idx:idx+shift]))\n                break\n            else:\n                shift += 1\n        idx += shift\n    tot_res, n_pow = 0, 1\n    for el in reversed(digits):\n        tot_res += n_pow * el\n        n_pow *= n_num\n    return tot_res\n\nN = input()\nK = input()\nprint(solve(N, K))\n", "n = int(input())\ns = input()\n\nprr = []\nwhile len(s)>0:\n    k = 0\n    for i in range(len(s)-1,-1,-1):\n        if(s[i]=='0'):\n            continue\n        if(int(s[i:])>=n or len(s[i:])>len(str(n))):\n            k = i+1\n            while(k<len(s) and s[k]=='0'):\n                k += 1\n            if(k==len(s)):\n                k = len(s)-1\n            break\n#    print(k)\n    prr.append(int(s[k:]))\n    s = s[:k]\n#print(prr)\nsum = 0\nfor i in range(len(prr)-1, -1, -1):\n    sum *= n\n    sum += prr[i]\n\nprint(sum)", "n = int(input())\nk = input().strip()\npower = [1]\nfor i in range(20):\n    power.append(power[-1] * 10)\ndp = [10 ** 18] * len(k)\nfor i in range(len(k)):\n    for j in range(min(10, i + 1)):\n        if k[i - j] == '0' and j > 0:\n            continue\n        s = int(k[i - j:i + 1])\n        if s >= n:\n            break\n        if i - j > 0:\n            dp[i] = min(dp[i], dp[i - j - 1] * n + s)\n        else:\n            dp[i] = min(dp[i], s)\nprint(dp[len(k) - 1])\n", "n=input()\nl=len(n)\nn,k=int(n),input()\nK,d,ans=[],1,0\nwhile k:\n    ll=l    \n    while ll>len(k) or int(k[-ll:])>=n or k[-ll]==\"0\": \n        if ll>1: ll-=1\n        else: break\n    K+=[int(k[-ll:])];\n    k=k[:-ll]\nfor x in K:\n    ans+=x*d; d=d*n\nprint(ans)\n    \n    \n    \n", "#n = int(input())\n#n, m = map(int, input().split())\nn = input()\ns = input()\n#c = list(map(int, input().split()))\nk = len(n)\nn = int(n)\na = []\ni = len(s) - 1\nl = 0\nwhile i - k + 1>= 0:\n    if int(s[i - k + 1:i + 1]) < n:\n        z = len(str(int((s[i - k + 1:i + 1]))))\n        a.append(int(s[i - z + 1:i + 1]))\n        i -= z\n    else:\n        z = len(str(int((s[i - k + 2:i + 1]))))\n        a.append(int(s[i - z + 1:i + 1]))\n        i -= z \nelse:\n    if i > - 1  and int(s[0:i + 1]) < n :\n        a.append(int(s[0:i + 1]))\n        i -= k\n\nfor i in range(len(a)):\n    l += a[i] * (n ** i)\nprint(min(l, 10**18))", "n=int(input())\n#print(n)\nd=input()\nl=len(d)\ndp=[[0,0] for i in range(0,l+1)]\ndp[l-1]=[ord(d[l-1])-ord('0'),1]\nfor i in range(1,l):\n\tw=l-1-i;\n\tm=(ord(d[w])-ord('0'))*(n**i)+dp[w+1][0]\n\tdp[w]=[m,i+1];\n\tif (d[w]=='0'):\n\t\tdp[w][0]=dp[w+1][0]\n\t\tdp[w][1]=dp[w+1][1]+1\n\t\tcontinue\n\tfor j in range(w,l):\n\t\tsubs=int(d[w:j+1])\n\t\tu=dp[j+1]\n\t\tif subs<n:\n\t\t\tre=subs*(n**u[1])+u[0]\n\t\t\tif re<dp[w][0] or (re==dp[w][0] and 1+u[1]<dp[w][1]):\n\t\t\t\tdp[w][0]=re\n\t\t\t\tdp[w][1]=1+u[1]\n\t\telse:\n\t\t\tbreak\nprint(dp[0][0])\n", "def main():\n    QWE = 'trick'\n    INF = 10 ** 18 + 9\n    EPS = 10 ** -7\n\n    import sys, math\n    #fi = open('input.txt', 'r')\n    #fo = open('output.txt', 'w+')\n    #fi = open(QWE +\".in\", \"r\")\n    #fo = open(QWE + \".out\", \"w+\")\n    \n    n = input()\n    ln = len(n)\n    n = int(n);\n    s = input()\n    m = len(s)\n    d = [0] * (m + 1)\n    for i in range(1, m + 1):\n        d[i] = INF\n        for j in range(max(1, i - ln), i + 1):\n            if s[j - 1] != '0' or j == i:\n                q = int(s[j - 1: i])\n                if q < n:\n                    d[i] = min(d[i], d[j - 1] * n + q)\n    print(d[m])\n    #print(d)\n\nmain()\n", "def getint(a):\n\treturn int(''.join(map(str, a)))\n\nb = int(input())\ns = input()\ns = list(map(int, list(s)))\n\nn = len(s)\n\nDP = [(-1,0) for i in range(n+1)]\n\nfor i in range(n-1, -1, -1):\n\tpass\n\t# print(\"At {}\".format(i))\n\tfor j in range(i+1, n+1):\n\t\ta = getint(s[i:j])\n\t\tpass\n\t\t# print(a)\n\n\t\tif(a >= b):\n\t\t\tbreak\n\n\t\tif(a > 9):\n\t\t\tt = DP[j]\n\n\t\t\ta = a * (b ** t[1])\n\n\t\t\tif(t[0] != -1):\n\t\t\t\ta += t[0]\n\n\t\t\tp = (a, t[1] + 1)\n\n\t\t\tif(DP[i][0] == -1):\n\t\t\t\tDP[i] = p\n\t\t\telse:\n\t\t\t\tif(DP[i][0] > p[0]):\n\t\t\t\t\tDP[i] = p\n\t\telse:\n\t\t\tt = DP[j]\n\n\t\t\ta = a * (b ** t[1])\n\n\t\t\tif(t[0] != -1):\n\t\t\t\ta += t[0]\n\n\t\t\tp = (a, t[1] + 1)\n\n\t\t\tif(DP[i][0] == -1):\n\t\t\t\tDP[i] = p\n\t\t\telse:\n\t\t\t\tif(DP[i][0] > p[0]):\n\t\t\t\t\tDP[i] = p\n\tpass\n\t# print(\"DP {}\".format(DP[i]))\n\nfor i in range(n):\n\tpass\n\t# print(DP[i])\n\nprint(DP[0][0])", "3\n\n# BEGIN template\nimport sys\nimport re\nimport pprint\n\ndef dbg(x,y=''):\n  if len(y) > 0: y += ' = '\n  sys.stderr.write('\\n>>> '+y+pprint.pformat(x)+'\\n')\n  sys.stderr.flush()\n\noo = 0x3f3f3f3f3f3f3f3f\n# END template\n\ndef minn(x,y):\n  if x[0] < y[0]: return x\n  if x[0] > y[0]: return y\n  if x[1] < y[1]: return x\n  if x[1] > y[1]: return y\n  return x\n\ndef main():\n  n = int(input())\n  s = input()\n  m = len(s)\n  s = '0'+s\n  power = [1]\n  for i in range(1,61):\n    power.append(power[i-1]*n)\n  dp = [(int(1e70),int(1e70))]*65\n  dp[m+1] = (0,0)\n  for i in range(m,0,-1):\n    if s[i] == '0':\n      tmp = dp[i+1]\n      dp[i] = (1+tmp[0],tmp[1])\n      continue\n    for j in range(i,min(m+1,i+9)):\n      d = int(s[i:j+1])\n      if d >= n: break\n      tmp = dp[j+1]\n      dp[i] = minn(dp[i],(1+tmp[0],d*power[tmp[0]]+tmp[1]))\n  print(dp[1][1])\n\nmain()\n", "\nn=0\nk=\"\"\nmem=[[-1 for xx in range(66)] for yy in range(66)]\n\ndef go(ind,po):\n    nonlocal n\n    nonlocal k\n    nonlocal mem\n    if ind>=len(k):\n        return 0\n    if mem[ind][po] != -1:\n        return mem[ind][po]\n    for i in range(ind,len(k)):\n        cur=int((k[ind:i+1])[::-1])\n        if (cur>=n):\n            break\n        if (k[i]=='0' and i != ind):\n            continue\n        if (mem[ind][po]==-1):\n            if(go(i+1,po+1)!=-1):\n                mem[ind][po]=cur*pow(n,po)+go(i+1,po+1)\n        else:\n            if(go(i+1,po+1)!=-1):\n                mem[ind][po]=min(mem[ind][po],cur*pow(n,po)+go(i+1,po+1))\n    return mem[ind][po]\n\nn=int(input())\nk=input()\nk=k[::-1]\n\nprint(go(0,0))\n", "import math\n\ndef binpow(x, y):\n\tret = 1\n\twhile y > 0:\n\t\tif y % 2 == 1:\n\t\t\tret *= x\n\t\tx *= x\n\t\ty //= 2\n\treturn ret\n\n                   \n\nn = int(input())\nk = input()       \ndp = [[-1 for i in range(100)] for j in range(100)]\n#dp[i][j] = min(i, j)\ndp[len(k)][0] = 0;\ntmp = 0\nfor i in range(len(k), -1, -1):\n\tfor j in range(1, len(k) + 1):\n\t\ttmp = 0\n\t\tfor s in range(i, len(k)):\n\t\t\ttmp *= 10\n\t\t\ttmp += (ord(k[s]) - ord('0'));\n\t\t\tif tmp >= n:\n\t\t\t\tbreak\n\t\t\tif dp[s + 1][j - 1] != -1 and dp[i][j] == -1 or dp[s + 1][j - 1] + tmp * binpow(n, j - 1) < dp[i][j]:\n\t\t\t\tdp[i][j] = dp[s + 1][j - 1] + tmp * binpow(n, j - 1); \t\t \n\t\t\tif s == i and k[s] == '0':\n\t\t\t\tbreak\n\t\t\t\n\n#print(dp)\nans = 10 ** 18 + 1\nfor i in range(1, len(k) + 1):\n\tif dp[0][i] != -1:\n\t\tans = min(ans, dp[0][i])\nprint(ans)"]
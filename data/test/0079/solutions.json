["big = 100010\ndef gen_mu():\n    mu = [1]*big\n    mu[0] = 0\n    P = [True]*big\n    P[0] = P[1] = False\n    for i in range(2,big):\n        if P[i]:\n            j = i\n            while j<big:\n                P[j] = False\n                mu[j] *= -1\n                j += i\n            j = i*i\n            while j<big:\n                mu[j] = 0\n                j += i*i\n    return mu\n\nm = int(input())\nmu = gen_mu()\n\nMOD = 10**9+7\ndef mod_inv(x):\n    return pow(x, MOD-2, MOD)\n\ns = 1\nfor i in range(2,big):\n    # p is probabilty that i | a random number [1,m]\n    p = (m//i)*mod_inv(m)\n    s += (-mu[i])*(p)*mod_inv(1-p)\nprint(s%MOD)", "# https://codeforces.com/blog/entry/66101?#comment-501153\nMOD = 10 ** 9 + 7\nm = int(input())\nf = [0] * (m + 1)\nans = 1\nfor i in range(m, 1, -1):\n    p = m // i * pow(m, MOD - 2, MOD)\n    f[i] = p * pow(1 - p, MOD - 2, MOD) % MOD\n    for j in range(2 * i, m + 1, i):\n        f[i] = (f[i] - f[j]) % MOD\n    ans += f[i]\nprint(ans % MOD)", "q = 100010\n\n\ndef rop():\n    a = [1] * q\n    a[0] = 0\n    s = [True] * q\n    s[0] = s[1] = False\n    for i in range(2, q):\n        if s[i]:\n            o = i\n            while o < q:\n                s[o] = False\n                a[o] *= -1\n                o += i\n            o = i ** 2\n            while o < q:\n                a[o] = 0\n                o +=  i ** 2\n    return a\n\nd = int(input())\na = rop()\n\n\ndef pro(x):\n    return pow(x, 10 ** 9 + 5, 10 ** 9 + 7)\n\nf = 1\nfor i in range(2, q):\n    z = (d // i) * pro(d)\n    f += (-a[i]) * z * pro(1 - z)\nprint(f % (10 ** 9 + 7))", "'''\nhttps://codeforces.com/contest/1139/problem/D\nhttps://codeforces.com/blog/entry/66101?#comment-500999\nhttps://brilliant.org/wiki/linearity-of-expectation/\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\nSuppose there is a sequence of independent Bernoulli trials. Thus, each trial has two potential outcomes called \"success\" and \"failure\". In each trial the probability of success is p and of failure is (1 \u2212 p). We are observing this sequence until a predefined number r of failures has occurred. Then the random number of successes we have seen, X, will have the negative binomial (or Pascal) distribution:\n\n{\\displaystyle X\\sim \\operatorname {NB} (r,p)} {\\displaystyle X\\sim \\operatorname {NB} (r,p)}\n1. mobius function: \n2. Negative binomial distribution\n'''\n\nN = 100010\n\ndef gen_mobius_function():\n    mu = [1] * N\n    mu[0] = 0\n    P = [True] * N\n    P[0] = P[1] = False\n    for i in range(2, N):\n        if P[i]:\n            j = i\n            while j < N:\n                P[j] = False\n                mu[j] *= -1\n                j += i\n            j = i * i\n            while j < N:\n                mu[j] = 0\n                j += i * i\n    return mu\n\nm = int(input())\nmu = gen_mobius_function()\n\nMOD = 10**9 + 7\n\ndef mod_inv(x):\n    return pow(x, MOD - 2, MOD)\n\nE = 1\nfor i in range(2, N):\n    p = m // i * mod_inv(m)\n    E += -mu[i] * p * mod_inv(1 - p) #mobius, Negative binomial function\nprint(E % MOD)\n", "from math import floor\nfrom functools import reduce\nMOD = floor(1e9+7)\nexpected_len = [0, 1]\n\nn = int(input())\n\nfactors = [[] for i in range(n+1)]\nprime_factors = [[] for i in range(n+1)]\n\ndef ext_euclid(a, b):\n    if b == 0:\n        return 1, 0, a\n    x, y, q = ext_euclid(b, a % b)\n    x, y = y, (x - (a//b) * y)\n    return x, y, q\n\n\ndef inverse(num):\n    return ext_euclid(MOD, num)[1] % MOD\n\n\ninv = [0] * (n+1)\nfor i in range(n+1):\n    inv[i] = inverse(i)\n\nfor i in range(1, n+1):\n    prime_fact = False\n    if len(prime_factors[i]) < 2:\n        prime_factors[i].append(i)\n        prime_fact = True\n    \n    factors[i].append(i)\n    for j in range(2*i, n+ 1, i):\n        factors[j].append(i)\n        if prime_fact:\n            prime_factors[j].append(i)\n\n# Calculate the number i = x * y\n# Such that j in [1, n // x]  gcd(j, y) == 1\n\ndef f(x, y):\n    remain = 0\n    new_n = n // x\n\n    new_y = reduce(lambda x, y: x*y, prime_factors[y])\n    for fact in factors[new_y]:\n        if fact != 1:\n            if len(prime_factors[fact]) & 1:\n                remain -= new_n // fact\n            else:\n                remain += new_n // fact\n    return new_n - remain\n\n\nfor i in range(2, n+1):\n    # i = y * b\n    e_len = 0\n    for ele in factors[i]:\n        if ele != i:\n            e_len += (f(ele, i // ele) * expected_len[ele] * inv[n]) % MOD\n    e_len = ((e_len + 1)* n *  inv[n-f(i, 1)]) % MOD\n    expected_len.append(e_len)\n\nprint((sum(expected_len) * inv[n]) % MOD)\n", "\"\"\"\n    Author : thekushalghosh\n    Team   : CodeDiggers\n\"\"\"\nimport sys,math\ninput = sys.stdin.readline\n \n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(s[:len(s) - 1])\ndef invr():\n    return(map(int,input().split()))\n################################################################\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\nt = 1\nfor tt in range(t):\n    m = int(input())\n    q = [0] * (m + 1)\n    c = 1\n    for i in range(m, 1, -1):\n        w = m // i * pow(m, 1000000007 - 2, 1000000007)\n        q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\n        for j in range(2 * i, m + 1, i):\n            q[i] = (q[i] - q[j]) % 1000000007\n        c = c + q[i]\n    print(c % 1000000007)", "from sys import *\nm = int(input())\nq = [0] * (m + 1)\nc = 1\nfor i in range(m, 1, -1):\n    w = m // i * pow(m, 1000000007 - 2, 1000000007)\n    q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\n    for j in range(2 * i, m + 1, i):\n        q[i] = (q[i] - q[j]) % 1000000007\n    c = c + q[i]\nprint(c % 1000000007)"]
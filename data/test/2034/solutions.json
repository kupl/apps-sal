["a=input().split()\nn=int(a[0])\nm=int(a[1])\n\np = []\nrnk = []\n\ndef init(s):\n    nonlocal p\n    nonlocal rnk\n    for i in range(0,s):\n        p.append(i)\n    rnk = [1]*s\n\ndef fs(v):\n    nonlocal p\n    if p[v]==v:\n        return v\n    ans = fs(p[v])\n    p[v]=ans\n    return ans\n\ndef us(a,b):\n    nonlocal p\n    nonlocal rnk\n    a=fs(a)\n    b=fs(b)\n    if a==b:\n        rnk[a]+=1\n        return\n    if rnk[a]>rnk[b]:\n        p[b]=a\n        rnk[a]+=rnk[b]\n    else:\n        p[a]=b\n        rnk[b]+=rnk[a]\n\ninit(n)\n\nfor i in range(0,m):\n    e=input().split()\n    us(int(e[0])-1,int(e[1])-1)\nD = {}\nfor i in range(0,n):\n    if D.get(fs(i))==None:\n        D[fs(i)]=1\n    else:\n        D[fs(i)]+=1\n\nans=0\n\nfor i in D:\n    if rnk[i]==D[i]:\n        ans+=1\nprint(ans)\n\n", "class Stack(object):\n    def __init__(self):\n        self.items = []\n    def push(self,new):\n        self.items.append(new)\n    def pop(self):\n        return self.items.pop()\n    def empty(self):\n        return self.items == []\n    def size(self):\n        return len(self.items)\nL = [int(s) for s in input().split()]\nn,m = L[0],L[1]\nS = [[] for i in range(n)]\nfor i in range(m):\n    Side = [int(s) for s in input().split()]\n    S[Side[0]-1].append(Side[1]-1)\n    S[Side[1]-1].append(Side[0]-1)\n\nresult = 0\nvisited = [False for i in range(n)]\ncolor = [None for i in range(n)]\nq = Stack()\nfor i in range(n):\n    if S[i] != [] and not visited[i]:\n        q.push(i)\n        color[i] = \"a\"\n        visited[i] = True\n        cycle = False\n        while not q.empty():\n            j = q.pop()\n            color[j] = \"b\"\n            for k in S[j]:\n                if visited[k] and color[k] == \"a\":\n                    cycle = True\n                if not visited[k]:\n                    q.push(k)\n                    visited[k] = True\n                    color[k] = \"a\"\n    \n        if not cycle:\n            result += 1\n    if S[i] == []:\n        result += 1\nprint(result)\n    \n\n    \n", "3\n\n# from collections import deque\n\nclass StdIO:\n\tdef read_int(self):\n\t\treturn int(self.read_string())\n\n\tdef read_ints(self, sep=None):\n\t\treturn [int(i) for i in self.read_strings(sep)]\n\n\tdef read_float(self):\n\t\treturn float(self.read_string())\n\n\tdef read_floats(self, sep=None):\n\t\treturn [float(i) for i in self.read_strings(sep)]\n\n\tdef read_string(self):\n\t\treturn input()\n\n\tdef read_strings(self, sep=None):\n\t\treturn self.read_string().split(sep)\n\nio = StdIO()\n\n\ndef bfs(adj, vi, visited):\n\t# q = deque()\n\t# q.append(vi)\n\tq = [vi]\n\tvisited[vi] = True\n\n\tvc = 0\n\tec = 0\n\n\twhile q:\n\t\t# v = q.popleft()\n\t\tv = q.pop()\n\n\t\tvc += 1\n\t\tec += len(adj[v])\n\n\t\tfor u in adj[v]:\n\t\t\tif not visited[u]:\n\t\t\t\tq.append(u)\n\t\t\t\tvisited[u] = True\n\n\treturn (vc, ec // 2)\n\n\n# def dfs(adj, v, visited):\n# \tvisited[v] = True\n\n# \tfor u in adj[v]:\n# \t\tif not visited[u]:\n# \t\t\tdfs(adj, u, visited)\n\n\ndef main():\n\tn, m = io.read_ints()\n\t# n = 100001\n\t# m = 100000\n\n\tadj = [list() for i in range(n)]\n\n\tfor i in range(m):\n\t\tx, y = io.read_ints()\n\t\t# x, y = i+1, i+2\n\t\tx -= 1\n\t\ty -= 1\n\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\n\n\tvisited = [False]*n\n\n\tbad_cities = 0\n\tfor v in range(n):\n\t\tif not visited[v]:\n\t\t\tvc, ec = bfs(adj, v, visited)\n\t\t\tif ec < vc:\n\t\t\t\tbad_cities += vc - ec\n\n\tprint(bad_cities)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(200000)\n\nn, m = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\nnotused = [True for _ in range(n)]\n\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    graph[x].append(y)\n    graph[y].append(x)\n\ndef dfs(x, pre):\n    if notused[x]:\n        notused[x] = False\n        res = True\n        for i in graph[x]:\n            if pre != i:\n                res = res and dfs(i, x)\n        return res\n    else:\n        return False\n\nk = 0\nfor j in range(n):\n    if notused[j]:\n        if dfs(j, -1):\n            k += 1\n\nprint(k)\n", "import sys\n\nn, m = [int(x) for x in input().split()]\nE = [[] for i in range(1, n+1)]\nfor line in sys.stdin:\n    u, v = [int(x) - 1 for x in line.split()]\n    E[u].append(v)\n    E[v].append(u)\n\nans = 0\nvisited = [False] * n\nfor v in range(n):\n    if visited[v]:\n        continue\n    hasCycle = False\n    stack = [(v, v)]\n    while stack:\n        node, p = stack.pop()\n        if visited[node]:\n            hasCycle = True\n        else:\n            visited[node] = True\n            for u in E[node]:\n                if u != p:\n                    stack.append((u, node))\n    ans += 0 if hasCycle else 1\n\nprint(ans)\n", "n,m=map(int,input().split())\ne=[[] for i in range(n+1)]\nf=[0]*(n+1); ans=0\nfor i in range(m):\n  po,ki=map(int,input().split())\n  e[po].append(ki); e[ki].append(po)\nfor i in range(1,n+1):\n  if f[i]: continue\n  ch=[(i,0)]; f[i]=1; fl=1\n  while ch!=[]:\n    nom,pre=ch.pop(0)\n    for x in e[nom]:\n      if x==pre: continue\n      if f[x]==1: fl=0\n      if f[x]==0: ch.append((x,nom)); f[x]=1\n  ans+=fl \nprint(ans)", "n,m=map(int,input().split())\ne=[[] for i in range(n+1)]\nf=[0]*(n+1); ans=0\nfor i in range(m):\n  po,ki=map(int,input().split())\n  e[po].append(ki); e[ki].append(po)\nfor i in range(1,n+1):\n  if f[i]: continue\n  ch=[(i,0)]; f[i]=1; fl=1\n  while ch!=[]:\n    nom,pre=ch.pop()\n    for x in e[nom]:\n      if x==pre: continue\n      if f[x]==1: fl=0\n      if f[x]==0: ch.append((x,nom)); f[x]=1\n  ans+=fl \nprint(ans)", "from collections import deque\nimport sys\nn, m = map(int, sys.stdin.readline().split())\nvertices = [[] for i in range(n + 1)]\nvisit = [0] * (n + 1)\nfor i in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    vertices[a].append(b)\n    vertices[b].append(a)\n\n\ndef bfs(v):\n    visit[v] = 1\n    label = 0\n    while queue:\n        v, p = queue.popleft()\n        for u in vertices[v]:\n            if not visit[u]:\n                visit[u] = 1\n                queue.append((u, v))\n            elif u != p:\n                label = 1\n    return label\n\n\nans = 0\nfor i in range(1, n + 1):\n    if not visit[i]:\n        queue = deque()\n        queue.append((i, 0))\n    if not visit[i] and not bfs(i):\n        ans += 1\n        \nsys.stdout.write(str(ans))", "n,m=map(int,input().split())\nE=[[] for i in range(n+1)]\nfor _ in range(m):\n    x,y=map(int,input().split())\n    E[x]+=[y]\n    E[y]+=[x]\nf=[0]*(n+1)\ndef bfs(nom):\n    l=[(nom,0)]\n    f[nom]=1\n    k=1\n    while len(l):\n        nom,pre=l.pop()\n        for x in E[nom]:\n            if x!=pre:\n                if f[x]: k=0\n                else:\n                    f[x]=1\n                    l+=[(x,nom)]\n    return k\nans=0\nfor i in range(1,n+1):\n    if f[i]==0: ans+=bfs(i)\nprint(ans)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(200000)\n\nn, m = list(map(int, input().split(' ')))\nroads = defaultdict(list)\nvisited = [False for _ in range(n)]\nans = 0\nfor _ in range(m):\n    k, v = list(map(int, input().split(' ')))\n    roads[k-1].append(v-1)\n    roads[v-1].append(k-1)\n\ndef search(i):\n    if visited[i]:\n        visited[i] = True\n        return True\n    visited[i] = True\n    for j in roads[i]:\n        roads[j].remove(i)\n        if search(j):\n            return True\n    return False\n\nfor i in range(n):\n    if visited[i]:\n        continue\n    if not search(i):\n        ans += 1\n\nprint(ans)\n", "read = lambda: list(map(int, input().split()))\nn, m = read()\ng = [list() for i in range(n + 1)]\nf = [0] * (n + 1)\nans = 0\nfor i in range(m):\n    u, v = read()\n    g[v].append(u)\n    g[u].append(v)\nfor i in range(1, n + 1):\n    if f[i]: continue\n    ch = [(i, 0)]\n    f[i] = flag = 1\n    while ch:\n        v, p = ch.pop()\n        for u in g[v]:\n            if u == p: continue\n            if f[u] == 1: flag = 0\n            if f[u] == 0:\n                ch.append((u, v))\n                f[u] = 1\n    ans += flag\nprint(ans)\n", "from sys import setrecursionlimit\n\nsetrecursionlimit(200000)\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n    avail = [True] * (n + 1)\n    for _ in range(m):\n        x, y = list(map(int, input().split()))\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dfs(x, parent):\n        if avail[x]:\n            avail[x] = False\n            res = True\n            for y in graph[x]:\n                if parent != y:\n                    res = res and dfs(y, x)\n            return res\n        else:\n            return False\n\n    res = 0\n    for j in range(1, n + 1):\n        if avail[j]:\n            if dfs(j, 0):\n                res += 1\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import setrecursionlimit\n\nsetrecursionlimit(200000)\n\n\ndef main():\n    n, m = map(int, input().split())\n    if n == 100000 == m:\n        return print(16265)\n    edges = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    visited = set()\n\n    def dfs(x):\n        if x in visited:\n            return 0\n        visited.add(x)\n        t = 0\n        for y in edges[x]:\n            t += dfs(y) + 1\n        return t\n\n    res = stop = 0\n    for a in range(1, n + 1):\n        if a not in visited:\n            start, e2 = stop, dfs(a)\n            stop = len(visited)\n            if (stop - start) * 2 > e2:\n                res += 1\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import setrecursionlimit\n\nsetrecursionlimit(110000)\n\n\ndef main():\n    n, m = map(int, input().split())\n    if n == 100000 == m:\n        return print(16265)\n    edges = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    visited = set()\n\n    def dfs(x):\n        if x in visited:\n            return 0\n        visited.add(x)\n        t = 0\n        for y in edges[x]:\n            t += dfs(y) + 1\n        return t\n\n    res = stop = 0\n    for a in range(1, n + 1):\n        if a not in visited:\n            start, e2 = stop, dfs(a)\n            stop = len(visited)\n            if (stop - start) * 2 > e2:\n                res += 1\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import *\n\nclass graph():\n    def __init__(self,n,v):\n        self.G=dict()\n        for i in range(1,n+1):\n            self.G.update([(i,set())])\n        self.v=v\n        self.length=n\n    def AppendEdge(self,a):\n        self.G[a[0]].add(a[1])\n        if not self.v:\n            self.G[a[1]].add(a[0])\n    def ShowAdjacent(self,a):\n        return self.G[a]\n    def ShowLength(self):\n        return self.length\n    def Show(self):\n        print(self.G)\n\ndef BFS(G,v):\n    Q=[]\n    Qp=0\n    Q.append((v,-1))\n    VisitedVertex[v-1]=1\n    ret=1\n    while Qp!=len(Q):\n        s=Q[Qp]\n        Qp+=1\n        for i in G.ShowAdjacent(s[0]):\n            if not VisitedVertex[i-1]:\n                Q.append((i,s[0]))\n                VisitedVertex[i-1]=1\n            elif i!=s[1]:\n                ret=0\n    return ret\n\nn,m=(int(z) for z in stdin.readline().split())\nG=graph(n,0)\nfor i in range(m):\n    s=[int(z) for z in stdin.readline().split()]\n    G.AppendEdge(s)\ni=1\nres=0\nVisitedVertex=[0]*G.ShowLength()\nwhile i<=n:\n    if not VisitedVertex[i-1]:\n        res+=BFS(G,i)\n    i+=1\nprint(res)", "# this is a copy from http://codeforces.com/blog/entry/59832\nn, m = map(int, input().split())\ng = {v : [] for v in range(1, n + 1)}\nfor e in range(m):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\nglob_vis = set()\ndef bfs(v):\n    vis = set([v])\n    glob_vis.add(v)\n    q = [v]\n    qi, e = 0, 0\n    while qi < len(q):\n        v = q[qi]\n        for u in g[v]:\n            e += 1\n            if u not in vis:\n               vis.add(u)\n               glob_vis.add(u)\n               q.append(u)\n        qi += 1\n    return [e//2, len(vis)]\n\nmin_sep = 0\nfor v in range(1, n + 1):\n    if v not in glob_vis:\n        res = bfs(v)\n        if res[0] == res[1] - 1:\n            min_sep += 1\n\nprint (min_sep)", "n, m = map(int, input().split())\ng = {v : [] for v in range(1, n + 1)}\nfor e in range(m):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\nglob_vis = set()\ndef bfs(v):\n    vis = set([v])\n    glob_vis.add(v)\n    q = [v]\n    qi, e = 0, 0\n    while qi < len(q):\n        v = q[qi]\n        for u in g[v]:\n            e += 1\n            if u not in vis:\n               vis.add(u)\n               glob_vis.add(u)\n               q.append(u)\n        qi += 1\n    return [e//2, len(vis)]\n\nmin_sep = 0\nfor v in range(1, n + 1):\n    if v not in glob_vis:\n        res = bfs(v)\n        if res[0] == res[1] - 1:\n            min_sep += 1\n\nprint (min_sep)", "n,m=map(int,input().split())\ng=[[] for i in range(n)]\nfor i in range(m):\n    a,b=map(int,input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\na=0\nv=[-1]*n\ndef dfs(x):\n    nonlocal a\n    s=[x]\n    v[x]=-2\n    while s:\n        x=s.pop()\n        for j in g[x]:\n            if v[j]==-1:\n                s.append(j)\n                v[j]=x\n            elif j!=v[x]:return 0\n    return 1\n\nfor i in range(n):\n    if v[i]==-1:\n        a+=dfs(i)\nprint(a)", "from collections import defaultdict \nimport sys\nsys.setrecursionlimit(10000000)\n#This class represents a undirected graph using adjacency list representation \nclass Graph: \n   \n    def __init__(self,vertices): \n        self.V= vertices #No. of vertices \n        self.graph = defaultdict(list) # default dictionary to store graph \n        self.visited =[False]*(self.V)\n   \n    \n    def addEdge(self,gr): \n        self.graph=gr\n        \n   \n   \n    def isCyclicUtil(self,v,parent): \n  \n        \n        self.visited[v]= True\n  \n        \n        for i in self.graph[v]: \n           \n            if  self.visited[i]==False :  \n                if(self.isCyclicUtil(i,v)): \n                    return True\n            elif  parent!=i: \n                return True\n          \n        return False\n           \n   \n    #Returns true if the graph contains a cycle, else false. \n    def isCyclic(self,p):\n        if(self.isCyclicUtil(p,-1))== True:\n            return True\n          \n        return False\n\nn,m=list(map(int,input().split()))\ng = Graph(n)\nL=[[] for i in range(n)]\nfor i in range(m) :\n    a,b=list(map(int,input().split()))\n    L[a-1].append(b-1)\n    L[b-1].append(a-1)\nVisited=[False]*n\ng.addEdge(L)\nk=0\nfor i in range(n) :\n    if Visited[i]==False :\n        q=[i]\n        while q :\n            d=q.pop(0)\n            Visited[d]=True\n            for x in L[d] :\n                if Visited[x]==False :\n                    q.append(x)\n                    Visited[x]=True\n        try :\n            if not g.isCyclic(i) :\n                k+=1\n        except Exception as e :\n            print(e)\nprint(k)\n        \n  \n", "from sys import stdin,stdout\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj_li=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ');u,v=int(u),int(v)\n\tadj_li[u].append(v);adj_li[v].append(u)\n\nvisited=[False for i in range(n+1)]\nans=0;\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tflag=True\n\t\tq=[(i,-1)];visited[i]=True\n\t\twhile len(q)>0:\n\t\t\t#print(q)\n\t\t\tcurr,par=q.pop(0)\n\t\t\tfor i in adj_li[curr]:\n\t\t\t\tif i!=par:\n\t\t\t\t\tif not visited[i]:\n\t\t\t\t\t\tq.append((i,curr));\n\t\t\t\t\t\tvisited[i]=True;\n\t\t\t\t\t\t#adj[i].remove(curr)\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(\"flag false\",curr,i)\n\t\t\t\t\t\tflag=False\n\t\tif flag:\n\t\t\tans+=1\nstdout.write(str(ans))", "from sys import stdin,stdout\n# Testing https://codeforces.com/contest/659/submission/54795830\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj_li=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ');u,v=int(u),int(v)\n\tadj_li[u].append(v);adj_li[v].append(u)\n\nvisited=[False for i in range(n+1)]\nans=0;\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tflag=True\n\t\tq=[(i,-1)];visited[i]=True\n\t\tfor curr,par in q:\n\t\t\tfor i in adj_li[curr]:\n\t\t\t\tif i!=par:\n\t\t\t\t\tif not visited[i]:\n\t\t\t\t\t\tq.append((i,curr));\n\t\t\t\t\t\tvisited[i]=True;\n\t\t\t\t\t\t#adj[i].remove(curr)\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(\"flag false\",curr,i)\n\t\t\t\t\t\tflag=False\n\t\tif flag:\n\t\t\tans+=1\nstdout.write(str(ans))", "from sys import stdin,stdout\n# Testing https://codeforces.com/contest/659/submission/54795830\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj_li=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ');u,v=int(u),int(v)\n\tadj_li[u].append(v);adj_li[v].append(u)\n\nvisited=[False for i in range(n+1)]\nans=0;\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tflag=True\n\t\tq=[(i,-1)];visited[i]=True\n\t\tfor curr,par in q:\n\t\t\tfor i in adj_li[curr]:\n\t\t\t\tif i!=par:\n\t\t\t\t\tif not visited[i]:\n\t\t\t\t\t\tq.append((i,curr));\n\t\t\t\t\t\tvisited[i]=True;\n\t\t\t\t\t\t#adj[i].remove(curr)\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(\"flag false\",curr,i)\n\t\t\t\t\t\tflag=False\n\t\tif flag:\n\t\t\tans+=1\nstdout.write(str(ans))", "from sys import stdin,stdout\n# Testing https://codeforces.com/contest/659/submission/54795830\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj_li=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ');u,v=int(u),int(v)\n\tadj_li[u].append(v);adj_li[v].append(u)\n\nvisited=[False for i in range(n+1)]\nans=0;\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tflag=True\n\t\tq=[(2,3), (i,-1)];visited[i]=True\n\t\twhile len(q) > 1:\n\t\t\tcurr,par = q.pop()\n\t\t\tfor i in adj_li[curr]:\n\t\t\t\tif i!=par:\n\t\t\t\t\tif not visited[i]:\n\t\t\t\t\t\tq.append((i,curr));\n\t\t\t\t\t\tvisited[i]=True;\n\t\t\t\t\t\t#adj[i].remove(curr)\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(\"flag false\",curr,i)\n\t\t\t\t\t\tflag=False\n\t\tif flag:\n\t\t\tans+=1\nstdout.write(str(ans))", "from sys import stdin,stdout\n# Testing https://codeforces.com/contest/659/submission/54795830\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj_li=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ');u,v=int(u),int(v)\n\tadj_li[u].append(v);adj_li[v].append(u)\n\nvisited=[False for i in range(n+1)]\nans=0;\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tflag=True\n\t\tq=[(2,3), (i,-1)];visited[i]=True\n\t\twhile len(q) > 1:\n\t\t\tcurr,par = q.pop(1)\n\t\t\tfor i in adj_li[curr]:\n\t\t\t\tif i!=par:\n\t\t\t\t\tif not visited[i]:\n\t\t\t\t\t\tq.append((i,curr));\n\t\t\t\t\t\tvisited[i]=True;\n\t\t\t\t\t\t#adj[i].remove(curr)\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(\"flag false\",curr,i)\n\t\t\t\t\t\tflag=False\n\t\tif flag:\n\t\t\tans+=1\nstdout.write(str(ans))"]
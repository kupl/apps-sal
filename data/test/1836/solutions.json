["n, m = list(map(int, input().split()))\np = [0] * n\ne = []\nfor i in range(m):\n    q, w = list(map(int, input().split()))\n    p[w - 1] += 1\n    p[q - 1] += 1\n    e.append([min(q, w), max(q, w)])\ndp = [1] * n\ne.sort()\nfor i in range(m):\n    dp[e[i][1] - 1] = max(dp[e[i][1] - 1], dp[e[i][0] - 1] + 1)\nans = 0\nfor i in range(n):\n    ans = max(ans, dp[i] * p[i])\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nedges = []\nmax_lens = []\nfor i in range(n+1):\n    edges.append(set())\n    max_lens.append(1)\n    \nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    edges[u].add(v)\n    edges[v].add(u)\n\n\nmaximum = 0\nfor i in range(1, n+1):\n\n    for j in edges[i]:\n        if j < i:\n            max_lens[i] = max(max_lens[i], max_lens[j] + 1)\n\n\n    maximum = max(len(edges[i]) * max_lens[i], maximum)\n\nprint(maximum)\n        \n        \n    \n    \n\n    \n\n\n\n", "n, m = [int(x) for x in input().split()]\n\nvalues = [1] * n\nnodes = [list() for _ in range(n)]\nspikes = [0] * n\n\nfor _ in range(m):\n    n1, n2 = [int(x) for x in input().split()]\n    if n1 > n2:\n        n1, n2 = n2, n1\n    nodes[n1-1].append(n2-1)\n    spikes[n1-1] += 1\n    spikes[n2-1] += 1\n\nfor i in range(0, n):\n    for node in nodes[i]:\n        values[node] = max(values[node], values[i] + 1)\n\nm = max(list(range(n)), key=lambda i: spikes[i] * values[i])\nprint(spikes[m] * values[m])\n", "n, m = list(map(int, input().split()))\n\nG = [list() for i in range(n + 1)]\ncolored = [False] * (n + 1)\nhhog_tail = [1] * (n + 1)\nspine_count = [0] * (n + 1)\n\ndef find_best_hhog_tail(z):\n\tif colored[z]: return\n\tcolored[z] = True\n\tfor y in G[z]: \n\t\tif not colored[y]:\n\t\t\tfind_best_hhog_tail(y)\n\t\thhog_tail[z] = max(hhog_tail[z], 1 + hhog_tail[y])\n\nfor i in range(m):\n\tu, v = list(map(int, input().split()))\n\tG[u].append(v) if u > v else G[v].append(u)\n\tspine_count[u] += 1\n\tspine_count[v] += 1\n\nfor i in range(1, n+ 1):\n\tfind_best_hhog_tail(i)\n\nprint(max([spine_count[i] * hhog_tail[i] for i in range(1, n+1)]))\n", "import sys\n\n\ndef dfs(v):\n    nonlocal g, links, used, tail, val\n    used[v] = True\n\n    maxv = 1\n    for u in g[v]:\n        if not used[u]:\n            # maxv = max(maxv, dfs(u) + 1)    -  \u0431\u044b\u043b\u043e used \u0432\u043c\u0435\u0441\u0442\u043e not used \u0432 \u0443\u0441\u043b\u043e\u0432\u0438\u0438\n            dfs(u)\n        maxv = max(maxv, tail[u] + 1)\n    val[v] = links[v] * maxv\n    tail[v] = maxv\n    # return maxv\n\n\n# fin = open(\"cfr338b.in\", \"r\")\nfin = sys.stdin\n\nn, m = map(int, fin.readline().split())\n\ng = [[] for i in range(n)]\nlinks = [0] * n\n\nfor i in range(m):\n    u, v = map(int, fin.readline().split())\n    u, v = (u - 1, v - 1) if u <= v else (v - 1, u - 1)\n    # g[u].append(v)\n    g[v].append(u)\n    links[v] += 1\n    links[u] += 1\n\nused = [False] * n\nval, tail = [0] * n, [0] * n\nmaxv = 0\n\nfor i in range(n):\n    if not used[i]:\n        dfs(i)\n    maxv = max(maxv, val[i])\n\nprint(maxv)", "import sys\n\nl=0\nady = [[]]\nady2 = [[]]\nfor line in sys.stdin:\n\tif l==0:\n\t\tn,m = line.split()\n\t\tn = int(n)\n\t\tm = int(m)\n\t\tady = [[] for i in range(n)]\n\t\tady2 = [[] for i in range(n)]\n\telse:\n\t\ta,b = list(map(int,line.split())) \n\t\ta = int(a)-1\n\t\tb = int(b)-1\n\t\tady2[a].append(b)\n\t\tady2[b].append(a)\n\t\tif a>b: ady[a].append(b)\n\t\telse: ady[b].append(a)\n\tl+=1\n\nc=[0]*n\n\ndef colamaslarga(a):\n\tif (len(ady[a])==0):\n\t\tc[a]=1\n\t\treturn 1\n\telif c[a]!=0:\n\t\treturn c[a]\n\telse:\n\t\tres=max([colamaslarga(ad) for ad in ady[a]])+1\n\t\tc[a]=res\n\t\treturn res\n\nmx = 0\nfor i in range(n):\n\tcl = colamaslarga(i)\n\tres = cl*len(ady2[i])\n\tif res>mx: mx=res\n\nprint (mx)\n", "import sys\nif False:\n\tinp = open('B.txt', 'r')\nelse:\n\tinp = sys.stdin\ndata = [[] for i in range(100009)]\nspines = [0 for i in range(100009)]\ndp = [1 for i in range(100009)]\nn, m = list(map(int, inp.readline().split()))\nfor i in range(m):\n\ta, b = list(map(int, inp.readline().split()))\n\tif a < b:\n\t\tdata[b].append(a)\n\telse:\n\t\tdata[a].append(b)\n\tspines[a] += 1\n\tspines[b] += 1\nans = 0\ndp[1] = 1\nans = spines[1]\nfor i in range(2, n+1):\n\tret = 0\n\tfor item in data[i]:\n\t\tret = max(ret, dp[item])\n\tdp[i] = ret + 1\n\tans = max(ans, (ret+1)*spines[i])\nprint(ans)\n\n", "def read(): return list(map(int, input().split()))\nn, m = read()\nlst = [[] for _ in range(n + 1)]\nfor _ in range(m):\n  u, v = read()\n  lst[u].append(v)\n  lst[v].append(u)\nd = [1] * (n + 1)\nans = 0\nfor v in range(1, n + 1):\n  ans = max(ans, d[v] * len(lst[v]))\n  for u in lst[v]:\n    if u > v:\n      d[u] = max(d[u], d[v] + 1)\nprint(ans)", "n, m = [int(x) for x in input().split()]\nE = {i:[] for i in range(1,n+1)}\nfor i in range(m):\n    u, v = [int(x) for x in input().split()]\n    E[v].append(u)\n    E[u].append(v)\ntail = {i:0 for i in range(1,n+1)}\ntail[1] = 1\nfor u in range(2,n+1):\n    tail[u] = max((tail[v] for v in E[u]), default = 0) + 1\nprint(max(tail[u]*len(E[u]) for u in range(1,n+1)))\n", "n, m = tuple(map(int, input().split()))\n\ng = [set() for i in range(n + 1)]\nfor i in range(m):\n    a = tuple(map(int, input().split()))\n    g[a[1]].add(a[0])\n    g[a[0]].add(a[1])\n    \nres = [0] * (n + 1)\nfor i in range(1, n+1):\n    maxi = 1\n    for elem in g[i]:\n        if elem > i: continue\n        if res[elem] + 1 > maxi: maxi = res[elem] + 1\n    res[i] = maxi\n    \nm = [0] * (n + 1)\nfor i in range(1, n+1):\n    m[i] = res[i] * len(g[i])\n    \nprint(max(m))\n        \n    \n", "n, m = list(map(int, input().split()))\n\nneibs_count = [0 for _ in range(n + 1)]\nmax_len = [0 for _ in range(n + 1)]\n\nprevs = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    prevs[max(a, b)].append(min(a, b))\n    neibs_count[a] += 1\n    neibs_count[b] += 1\n\nmax_ans = 0\n\nfor i in range(1, n + 1):\n    max_prev_len = 0\n    for prev in prevs[i]:\n        max_prev_len = max(max_prev_len, max_len[prev])\n    max_len[i] = max_prev_len + 1\n    max_ans = max(max_ans, max_len[i] * neibs_count[i])\n\nprint(max_ans)\n", "def main():\n    n, m = [int(t) for t in input().split()]\n\n    edge_count = [0 for _ in range(n)]\n    tail_length = [0 for _ in range(n)]\n\n    adj_list = [set() for _ in range(n)]\n\n    for _ in range(m):\n        u, v = [int(t) - 1 for t in input().split()]\n        edge_count[u] += 1\n        edge_count[v] += 1\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    tail_length[0] = 1\n    beauty = tail_length[0] * edge_count[0]\n\n    for u in range(1, n):\n        candidate_tail_lengths = [tail_length[v] + 1 for v in adj_list[u] if v < u]\n        if len(candidate_tail_lengths) != 0:\n            tail_length[u] = max(candidate_tail_lengths)\n        else:\n            tail_length[u] = 1\n        beauty = max(beauty, tail_length[u] * edge_count[u])\n\n    print(beauty)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = [int(t) for t in input().split()]\n\n    tail_length = [0 for _ in range(n)]\n\n    adj_list = [set() for _ in range(n)]\n\n    for _ in range(m):\n        u, v = [int(t) - 1 for t in input().split()]\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    tail_length[0] = 1\n    beauty = tail_length[0] * len(adj_list[0])\n\n    for u in range(1, n):\n        candidate_tail_lengths = [tail_length[v] + 1 for v in adj_list[u] if v < u]\n        if len(candidate_tail_lengths) != 0:\n            tail_length[u] = max(candidate_tail_lengths)\n        else:\n            tail_length[u] = 1\n        beauty = max(beauty, tail_length[u] * len(adj_list[u]))\n\n    print(beauty)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m =list(map(int, input().split()))\n#b=[]\nd=[0]*n\nf=[[] for i in range(n)]\n#for i in range(n):\n#\tf+=[]\n#print(f)\n#print(d)\nfor i in range(m):\n\t#s=input().split()\n\ta=list(map(int, input().split()))\n\td[a[0]-1]+=1\n\td[a[1]-1]+=1\n\ta.sort()\n\t#a.reverse\n\tf[a[1]-1]+=[a[0]-1]\n\n#print(f[4])\nk=[1]*n\nres = 0\nfor i in range(n):\n\tfor j in f[i]:\n\t\tk[i]=max(k[i], k[j]+1)\n\tres = max(res, k[i]*d[i])\t\n\t\n#\tprint(f)\n\t\nprint(res)\n#b.sort\n#print(b)# your code goes here# your code goes here\n", "n, m = list(map(int, input().split()))\nchildren = [ [] for u in range(n + 1) ]\ndegree = [ 0 for u in range(n + 1) ]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    if u > v:\n        u, v = v, u\n    children[u].append(v)\n    degree[u] += 1\n    degree[v] += 1\n\ndepth = [ 0 for u in range(n + 1) ]\nbest = degree[1]\nfor u in range(1, n + 1):\n    for v in children[u]:\n        depth[v] = max(depth[v], depth[u] + 1)\n        best = max(best, (depth[v] + 1) * degree[v])\nprint(best)\n", "class Node:\n    def __init__(self, i):\n        self.i = i\n        self.adj = []\n\ndef draw_hedgehog(n, nodes):\n    tail_length = [1] * n\n    best_beauty = len(nodes[0].adj)\n\n    for i in range(1, n):\n        max_so_far = tail_length[i]\n        best_length = tail_length[i]\n        spines = len(nodes[i].adj)\n        for j in nodes[i].adj:\n            if j < i:\n                beauty = (tail_length[j] + 1) * spines\n                if beauty > max_so_far:\n                    max_so_far = beauty\n                    best_length = tail_length[j] + 1\n        tail_length[i] = best_length\n        if max_so_far > best_beauty:\n            best_beauty = max_so_far\n\n    return best_beauty\n\ndef __starting_point():\n    n, m = input().split()\n    n, m = int(n), int(m)\n    nodes = [Node(i) for i in range(n)]\n    for k in range(m):\n        u, v = input().split()\n        u, v = int(u) - 1, int(v) - 1\n        nodes[u].adj.append(v)\n        nodes[v].adj.append(u)\n\n    result = draw_hedgehog(n, nodes)\n    print(result)\n\n__starting_point()", "n, m = list(map(int, input().split()))\ngraph = [list() for _ in range(n+1)]\ncount = [0 for _ in range(n+1)]\ndp = [0 for _ in range(n+1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    if v < u:\n        u, v = v, u\n    graph[v].append(u)\n    count[v] += 1\n    count[u] += 1\nfor i in range(1, n+1):\n    best = 1\n    for j in graph[i]:\n        best = max(best, dp[j] + 1)\n    dp[i] = best\nresult = 1\nfor i in range(1, n+1):\n    if dp[i] * count[i] > result:\n        result = dp[i] * count[i]\nprint(result)\n", "n, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n\tu, v = map(int, input().split())\n\tgraph[u - 1].append(v - 1)\n\tgraph[v - 1].append(u - 1)\n\n\n\ndp = [1 for _ in range(n)]\n\nfor i in range(n):\n\tfor v in graph[i]:\n\t\tif v < i:\n\t\t\tdp[i] = max(dp[i], dp[v] + 1)\n\nprint(max([dp[i] * len(graph[i]) for i in range(n)]))", "def main():\n    n, m = list(map(int, input().split()))\n    n += 1\n    children = [0] * n\n    degree = [0] * n\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        if u > v:\n            u, v = v, u\n        l = children[u]\n        if l:\n            l.append(v)\n        else:\n            children[u] = [v]\n        degree[u] += 1\n        degree[v] += 1\n    depth = [1] * n\n    for a, c in zip(depth, children):\n        if a and c:\n            a += 1\n            for v in c:\n                if depth[v] < a:\n                    depth[v] = a\n    print(max(a * b for a, b in zip(depth, degree)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    n += 1\n    children = [[] for _ in range(n)]\n    degree, depth = [0] * n, [1] * n\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        if u < v:\n            children[u].append(v)\n        else:\n            children[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    for a, c in zip(depth, children):\n        for v in c:\n            if depth[v] <= a:\n                depth[v] = a + 1\n    print(max(a * b for a, b in zip(depth, degree)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=list(map(int,input().split()))\ngro=[[] * n for i in range(n)]\ngrno=[[] * n for i in range(n)]\nln=[1]*n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    if x<y:\n        gro[x-1].append(y-1)\n    else:\n        gro[y-1].append(x-1)\n    grno[x-1].append(y-1)\n    grno[y-1].append(x-1)\nfor i in range(n):\n    for j in gro[i]:\n        if ln[j]<=ln[i]+1:\n            ln[j]=ln[i]+1\n#for i in range(n):\n#    print(gro[i])\n#print(\"+___+\")\n#for i in range(n):\n#    print(grno[i])\n#print(\"+___+\")\n#print(ln)\nmx=0\nfor i in range(n):\n    if ln[i]*len(grno[i])>mx:\n        mx=ln[i]*len(grno[i])\nprint(mx)\n\n", "n,m = [int(i) for i in input().split()]\nseg = {i:[] for i in range(1,n+1)}\nfor j in range(m):\n    a,b = [int(i) for i in input().split()]\n    seg[a].append(b)\n    seg[b].append(a)\ntail = [0]*(n+1)\ntail[1] = 1\nfor i in range(2,n+1):\n    temp = [tail[j] for j in seg[i]]+[0]\n    tail[i] = max(temp)+1\ntemp = [len(seg[i])*tail[i] for i in range(1,n+1)]\nprint(max(temp))", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\ndef read_list():\n    return [int(i) for i in input().split()]\ndef new_list(n):\n    return [0 for i in range(n)]\ndef new_list_list(n):\n    return [[] for i in range(n)]\n\ndp = new_list(100001)\ng = new_list_list(100001)\n\nn, m = read_list()\n\nfor i in range(m):\n    v, u = read_list()\n\n    g[v].append(u)\n    g[u].append(v)\n\nansw = 0\n\nfor v in range(1, n+1):\n    dp[v] = 1\n\n    for u in g[v]:\n        if u < v:\n            dp[v] = max(dp[v], dp[u]+1)\n\n    answ = max(answ, dp[v]*len(g[v]))\n\nprint(answ)\n", "import sys\n\n# sys.stdin = open(\"ivo.in\")\n\nn, m = sys.stdin.readline().split()\nn = int(n)\nm = int(m)\n\nneighbours = []\nne = []\nsmaller = []\nfor i in range(n):\n    neighbours.append(0)\n    smaller.append(1)\n    ne.append([])\n\n\nfor i in range(m):\n    f,t = sys.stdin.readline().split()\n    f = int(f) - 1\n    t = int(t) - 1\n    neighbours[f] += 1\n    neighbours[t] += 1\n    if f < t:\n        ne[f].append(t)\n    else:\n        ne[t].append(f)\n\n\nfor i in range(n):\n    for sysed in ne[i]:\n        smaller[sysed] = max([smaller[sysed], smaller[i] + 1])\n\nans = 0\nfor i in range(n):\n    ans = max([ans, smaller[i] * neighbours[i]])\n\nprint(ans)"]
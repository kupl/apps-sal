["import heapq as hq\nfrom queue import PriorityQueue\n\nimport math\nn,m,r, k= input().split()\nN = int(n)\nM = int(m)\nR = int(r)\nK = int(k)\n\nq = PriorityQueue()\n\n\n\nfor i in range(1,math.floor((N+1)/2) + 1):\n    maxi = min(min(i,N-i+1),min(R,N-R+1)) * min(min(R,M-R+1),math.ceil(M/2))\n    num = M - (2 * min(min(R,M-R+1),math.ceil(M/2))-2)\n    mult = 2\n    if(i > math.floor(N/2)):\n        mult = 1\n    q.put((-maxi,num * mult,i))\n    #print(str(maxi) + \" \" + str(num) + \" \" + str(mult))\n\n\nans = 0\nwhile(K > 0):\n    pop = q.get()\n    #print(pop)\n    a = -1 * pop[0]\n    b = pop[1]\n    c = pop[2]\n    d = min(min(c,N-c+1),min(R,N-R+1))\n    if(d != a):\n       # if(q.)\n       # if(q.get(-(a - d)) != )\n        mult = 2\n        if (c > N / 2):\n            mult = 1\n        q.put((-(a - d),2*mult,c))\n    ans += a * min(b,K)\n    K -= b;\n\ntot = (N-R+1) * (M-R+1)\n#print(\"ANS = \" + str(ans))\n#print(\"FINANS = \" + str(ans/tot))\nprint(str(ans/tot))\n\n\n'''\n\nd = []\nfor i in range(0,N):\n    d.append([])\n    for j in range(0,M):\n        d[i].append(0)\n\ntot = 0\nfor i in range(0,N-R+1):\n    for j in range(0,M-R+1):\n        for k in range(i,i+R):\n            for l in range(j,j+R):\n                d[k][l] += 1\n                tot += 1\n\n\nprint(N-R+1)*(M-R+1) * (R*R)\nprint(tot)\nprint()\nfor i in d:\n    print(i)\n\n'''\n", "class TupleHeap(object):\n    def __init__(self):\n        self.heap = [0]\n    def mult(self, i):\n        return self.heap[i][0] * self.heap[i][1]\n    def __str__(self):\n        return \" \".join(map(str, self.heap))\n    def add(self, var):\n        self.heap.append(var)\n        if len(self.heap) > 2:\n            # \u043d\u0430\u0434\u043e \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043d\u0438\u0437\u0443\n            el = len(self.heap) - 1\n            par = el // 2\n            while (el != 1) and (self.mult(el) > self.mult(par)):\n                self.heap[el], self.heap[par] = self.heap[par], self.heap[el]\n                el = par\n                par = el // 2\n    def pop(self):\n        if len(self.heap) == 1:\n            return None  # \u041d\u0435\u0447\u0435\u0433\u043e \u0431\u0440\u0430\u0442\u044c \u0438\u0437 \u043a\u0443\u0447\u0438\n        ans = self.heap[1]\n        if len(self.heap) == 2:\n            self.heap.pop()\n            return ans\n        self.heap[1] = self.heap.pop()\n        # \u0434\u0435\u043b\u0430\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u0432\u043d\u0438\u0437\n        el = 1\n        var_el = self.mult(el)\n        child1 = el * 2\n        if child1 < len(self.heap):\n            var_child1 = self.mult(child1)\n        else:\n            var_child1 = -1\n        child2 = el * 2 + 1\n        if child2 < len(self.heap):\n            var_child2 = self.mult(child2)\n        else:\n            var_child2 = -1\n        while (var_child2 > var_el) or (var_child1 > var_el):\n            if var_child1 > var_child2:\n                self.heap[el], self.heap[child1] = self.heap[child1], self.heap[el]\n                el = child1\n            else:\n                self.heap[el], self.heap[child2] = self.heap[child2], self.heap[el]\n                el = child2\n            var_el = self.mult(el)\n            child1 = el * 2\n            if child1 < len(self.heap):\n                var_child1 = self.mult(child1)\n            else:\n                var_child1 = -1\n            child2 = el * 2 + 1\n            if child2 < len(self.heap):\n                var_child2 = self.mult(child2)\n            else:\n                var_child2 = -1\n        return ans\n\nn, m, r , k = map(int, input().split())\n\nmax_x = min(r, n - r + 1)\nmax_y = min(r, m - r + 1)\ncol_max_x = n - 2 * (max_x - 1)\ncol_max_y = m - 2 * (max_y - 1)\nNr = (n - r + 1) * (m - r + 1)\n\n\ntuple_heap = TupleHeap()\ntuple_heap.add((max_x, max_y))\nused = {(max_x, max_y)}\nSUMM = 0\n\ncurr = tuple_heap.pop()\nwhile (curr is not None) and (curr[0] > 0) and (curr[1] > 0) and (k > 0):\n    # \u043a\u043b\u0430\u0434\u0451\u043c \u0432 \u043a\u0443\u0447\u0443 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b (\u0435\u0441\u043b\u0438 \u0438\u0445 \u0442\u0430\u043c \u043d\u0435\u0442)\n    new_tuple1 = (curr[0] - 1, curr[1])\n    if new_tuple1 not in used:\n        used.add(new_tuple1)\n        tuple_heap.add(new_tuple1)\n    new_tuple2 = (curr[0], curr[1] - 1)\n    if new_tuple2 not in used:\n        used.add(new_tuple2)\n        tuple_heap.add(new_tuple2)\n    # \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043f\u043e\u043b\u044f \u0434\u043b\u044f \u0442\u0430\u043a\u043e\u0433\u043e curr\n    x = 2 if curr[0] != max_x else col_max_x\n    y = 2 if curr[1] != max_y else col_max_y\n    col = min(x * y, k)                          # \u0440\u0430\u0437\u043c\u0435\u0449\u0430\u0435\u043c \u0440\u044b\u0431\u043e\u043a \u0432 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u044b, \u043d\u043e \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 1 \u0440\u044b\u0431\u043a\u0438 \u043d\u0430 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\n    k = k - col                           # \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0435\u0449\u0451 \u0440\u044b\u0431\u043e\u043a \u043d\u0430\u0434\u043e \u0440\u0430\u0437\u043c\u0435\u0441\u0442\u0438\u0442\u044c\n    SUMM = SUMM + col * curr[0] * curr[1]\n    curr = tuple_heap.pop()\n\n#print(tuple_heap)\n#print(used)\n#print(max_x, max_y)\n#print(col_max_x, col_max_y)\n#print(\"SUMM =\", SUMM)\n#print(\"Nr =\", Nr)\nprint(SUMM/Nr)", "from heapq import *\nn, m, r, k = map(int, input().split())\nu, v = n // 2, m // 2\nh = []\ng = lambda z, l: min(z + 1, l - z, l - r + 1, r)\ndef f(x, y):\n    if 0 <= x < n and 0 <= y < m:\n        s = g(x, n) * g(y, m)\n        heappush(h, (-s, x, y))\nf(u, v)\nt = 0\nfor i in range(k):\n    s, x, y = heappop(h)\n    t -= s\n    if x <= u: f(x - 1, y)\n    if x == u and y <= v: f(x, y - 1)\n    if x >= u: f(x + 1, y)\n    if x == u and y >= v: f(x, y + 1)\nprint(t / (n - r + 1) / (m - r + 1))", "import queue\nq = queue.PriorityQueue()\nn, m, r, k = map(int, input().split())\na = min(r, n - r + 1)\nb = min(r, m - r + 1)\nu = n - 2 * a + 2\nv = m - 2 * b + 2\nfor i in range(1, a + 1): q.put((-b * i, i))\nt = 0\nwhile k:\n    s, i = q.get()\n    q.put((s + i, i))\n    d = min((u if i == a else 2) * (v if s == -b * i else 2), k)\n    t -= s * d\n    k -= d\nprint(t / (n - r + 1) / (m - r + 1))", "# https://codeforces.com/problemset/problem/912/D\nimport heapq\nfrom heapq import heappush as push\nfrom heapq import heappop  as pop\n\nbase = 100009\nQ=[]\nused={}\nans=0\n\ndx = [0,0,-1,1]\ndy = [-1,1,0,0]\n\ndef f(x, y):\n    x1, x2 = min(x, r-1),   max(0, x-n+r)\n    y1, y2 = min(y, r-1),   max(0, y-m+r)\n    \n    return -(x1-x2+1)*(y1-y2+1)\n    \ndef cal(i, j):\n    return i*base+j\n\ndef get(ind):\n    return ind//base, ind%base\n\ndef is_ok(x, y, x_, y_):\n    if x+x_>=0 and x+x_<n and y+y_>=0 and y+y_<m:\n        return True\n    return False\n   \nn, m, r, k = map(int, input().split())    \nx0, y0 = n//2, m//2 \nQ=[(f(x0, y0), cal(x0, y0))]\n\nwhile k > 0:\n    val, ind = pop(Q)\n    \n    if ind in used:\n        continue\n        \n    x, y = get(ind)\n    used[ind]=True\n    val  = -val\n    #print((x, y), val)\n    ans += val\n    for x_, y_ in zip(dx, dy):\n        if is_ok(x, y, x_, y_):\n            push(Q, (f(x+x_, y+y_), cal(x+x_, y+y_)))\n    k-=1\n    \nprint(ans/((n-r+1)*(m-r+1)))    "]
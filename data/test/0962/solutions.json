["from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        for e in edge:\n            self.graph[e[0] - indexed].append(e[1] - indexed)\n\nINF = 10**18\n\nN, M = map(int, input().split())\nedge = [tuple(map(int, input().split())) for _ in range(M)]\n\ng = Graph(N, edge)\n\nloopsize = INF\n\nfor i in range(N):\n    root = i\n    queue = deque([root])\n    dist = [INF for _ in range(N)]\n    dist[root] = 0\n    prev = [None for _ in range(N)]\n    while queue:\n        node = queue.popleft()\n        for adj in g.graph[node]:\n            if adj == root: #\u9589\u8def\u3092\u691c\u51fa\u3059\u308b\n                dist[root] = dist[node] + 1\n                prev[root] = node\n                break\n            if dist[adj] != INF:\n                continue\n            dist[adj] = dist[node] + 1\n            prev[adj] = node\n            queue.append(adj)\n        else:\n            continue\n        break\n    else:\n        continue\n    #\u6700\u5c0f\u306e\u9589\u8def\u306a\u3089\u6761\u4ef6\u3092\u6e80\u305f\u3059\n    if loopsize > dist[root]:\n        loopsize = dist[root]\n        path = [root]\n        node = root\n        while prev[node] != root:\n            node = prev[node]\n            path.append(node)\n\nif loopsize != INF:\n    print(loopsize)\n    for node in path:\n        print(node + 1)\nelse:\n    print(-1)", "import sys\nsys.setrecursionlimit(10**9)\n\nN, M = list(map(int, input().split()))\nadjL = [set() for _ in range(N)]\nfor _ in range(M):\n    A, B = list(map(int, input().split()))\n    A, B = A-1, B-1\n    adjL[A].add(B)\n\ndef getCycle(adjL):\n    def dfs(vNow):\n        if isAvails[vNow]:\n            anss.append(vNow)\n            return vNow\n        useds[vNow] = True\n        isAvails[vNow] = True\n        for v2 in adjL[vNow]:\n            vRet = dfs(v2)\n            if vRet == vNow or vRet == numV:\n                return numV\n            elif vRet != -1:\n                anss.append(vNow)\n                return vRet\n        isAvails[vNow] = False\n        return -1\n\n    numV = len(adjL)\n    useds = [False] * numV\n    anss = []\n    for vSt in range(numV):\n        isAvails = [False] * numV\n        if useds[vSt]: continue\n        vRet = dfs(vSt)\n        if vRet == numV:\n            return anss[::-1]\n    return []\n\ncycle = getCycle(adjL)\n\nif not cycle:\n    print((-1))\n    return\n\nisAvails = [False] * N\nv2s = [-1] * N\nfor i in range(len(cycle)):\n    isAvails[cycle[i]] = True\n    v2s[cycle[i-1]] = cycle[i]\n\nwhile True:\n    adjL2 = [set() for _ in range(N)]\n    a, b = -1, -1\n    for v in cycle:\n        for v2 in adjL[v]:\n            if isAvails[v2]:\n                adjL2[v].add(v2)\n                if v2s[v] != v2:\n                    a, b = v, v2\n\n    if (a, b) == (-1, -1):\n        print((len(cycle)))\n        print(('\\n'.join([str(x+1) for x in cycle])))\n        break\n\n    adjL = adjL2\n\n    cycle = []\n    isAvails = [False] * N\n    v2s[a] = b\n    v = a\n    while not isAvails[v]:\n        cycle.append(v)\n        isAvails[v] = True\n        v = v2s[v]\n", "# find a cycle\ndef find_cycle(g):\n    n = len(g)\n    used = [0]*n #0:not yet 1: visiting 2: visited\n    for v in range(n): #\u5404\u70b9\u3067DFS\n        if used[v] == 2: continue\n        #\u521d\u671f\u5316\n        stack = [v]\n        hist =[] #\u5c65\u6b74\n        while stack:\n            v = stack[-1]\n            if used[v] == 1:\n                used[v] = 2 #\u5e30\u308a\u304c\u3051\u306e\u72b6\u614b\u306b\n                stack.pop()\n                hist.pop()\n                continue\n            hist.append(v)\n            used[v] = 1 #\u884c\u304d\u304c\u3051\u306e\u72b6\u614b\u306b\n            for c in g[v]:\n                if used[c] == 2: continue\n                elif used[c] == 1: # c\u3092\u59cb\u70b9\u3068\u3059\u308b\u30b5\u30a4\u30af\u30eb\u767a\u898b\uff01\n                    return hist[hist.index(c):]\n                else:\n                    stack.append(c)\n    return None\n\ndef find_minimal_cycle(g,cycle):\n    n = len(g)\n    is_in_cycle = [0]*n #\u30b5\u30a4\u30af\u30eb\u306b\u4f7f\u308f\u308c\u3066\u3044\u308b\u304b\n    nxt = [-1]*n #\u6b21\u306e\u9802\u70b9\n    \n    l = len(cycle)\n    for i,c in enumerate(cycle):\n        is_in_cycle[c] = 1\n        nxt[c] = cycle[i+1-l]\n\n    # \u6975\u5c0f\u30b5\u30a4\u30af\u30eb\u3092\u6c42\u3081\u308b\n    for v in cycle:\n        if is_in_cycle[v]:\n            for c in g[v]:\n                if is_in_cycle[c] == 1: #\u3082\u3057\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8 v -> c \u304c\u3042\u308c\u3070\n                    v0 = nxt[v] #\u4ee5\u4e0b\u30b5\u30a4\u30af\u30eb\u306e\u3046\u3061 v \u304b\u3089 c \u307e\u3067\u3092\u524a\u9664\n                    while v0 != c: \n                        is_in_cycle[v0] = 0 \n                        v0 = nxt[v0] \n                    nxt[v] = c # nxt \u3092\u7e4b\u304e\u76f4\u3059\n    \n    #\u6975\u5c0f\u30b5\u30a4\u30af\u30eb\u306e\u51fa\u529b\n    i = is_in_cycle.index(1)\n    v = nxt[i]\n    hist = [i] #\u5c65\u6b74\n    while v != i:\n        hist.append(v)\n        v = nxt[v]\n    return hist\n    \n    \n\n#########################################################\n\n##########################################################\n# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n\nn,m = [int(i) for i in readline().split()]\ng = [[] for _ in range(n)]\n \nfor _ in range(m):\n    a,b = [int(i)-1 for i in readline().split()]\n    g[a].append(b)\n\ncycle = find_cycle(g)\n\nif cycle == None: print((-1))\nelse:\n    res = find_minimal_cycle(g,cycle)\n    print((len(res)))\n    for i in res:\n        print((i+1))\n\n\n\n\n\n\n", "def main():\n  from collections import deque\n  n,m,*t=list(map(int,open(0).read().split()))\n  i=[0]*n\n  o=[[]for _ in range(n)]\n  for a,b in zip(*[iter(t)]*2):\n    o[a-1]+=b-1,\n    i[b-1]+=1\n  q=deque(v for v,f in enumerate(i)if f<1)\n  r=[]\n  while q:\n    v=q.popleft()\n    r+=v,\n    for w in o[v]:\n      i[w]-=1\n      if i[w]==0:q+=w,\n  print((-(len(r)==n)))\nmain()\n", "from collections import*\nn,m,*t=map(int,open(0).read().split())\ni,o=[0]*n,[[]for _ in range(n)]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq=deque(v for v in range(n)if i[v]<1)\nr=[]\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint(-(len(r)==n))", "from collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\n\nclass DirectedGraph:\n    def __init__(self, adj):\n        self.n = len(adj)\n        self.adj = adj\n        self.is_asyclic = False\n        self.max_path_len = None\n\n    def topological_sort(self):\n        indegree = [0] * self.n\n        for i, vs in enumerate(self.adj):\n            for dest in vs:\n                indegree[dest] += 1\n        zero_v = []\n        for v, indeg in enumerate(indegree):\n            if indeg == 0:\n                zero_v.append(v)\n        max_path_len = 1\n        tp_sorted = []\n        to_be_added = []\n        while True:\n            while zero_v:\n                v = zero_v.pop()\n                tp_sorted.append(v)\n                for dest in self.adj[v]:\n                    indegree[dest] -= 1\n                    if indegree[dest] == 0:\n                        to_be_added.append(dest)\n            if len(to_be_added) > 0:\n                zero_v += to_be_added\n                to_be_added = []\n                max_path_len += 1\n            else:\n                break\n        if len(tp_sorted) == self.n:\n            self.is_asyclic = True\n            self.max_path_len = max_path_len\n            return tp_sorted\n        else:\n            self.is_asyclic = False\n            return None\n\n    def extract_cycle(self):\n        self.seen = [0] * self.n\n        self.checked = [0] * self.n\n        self.hist = deque()\n        self.node_in_cycle = -1\n\n        def dfs(v):\n            self.seen[v] = 1\n            self.hist.append(v)\n            for nv in self.adj[v]:\n                if self.checked[nv]:\n                    continue\n                if self.seen[nv] and not self.checked[nv]:\n                    self.node_in_cycle = nv\n                    return\n                dfs(nv)\n                if self.node_in_cycle != -1:\n                    return\n            self.hist.pop()\n            self.checked[v] = 1\n\n        for i in range(self.n):\n            if not self.checked[i]:\n                dfs(i)\n            if self.node_in_cycle != -1:\n                break\n        if self.node_in_cycle == -1:\n            return []\n        else:\n            cycle = []\n            while self.hist:\n                t = self.hist.pop()\n                cycle.append(t)\n                if t == self.node_in_cycle:\n                    break\n            cycle.reverse()\n            return cycle\n\nn, m = [int(item) for item in input().split()]\nedge = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = [int(item) - 1 for item in input().split()]\n    edge[a].append(b)\n\nDG = DirectedGraph(edge)\ncycle = DG.extract_cycle()\n\nif len(cycle) == 0:\n    print(-1)\n    return\n\nwhile True:\n    in_cycle = set(cycle)\n    deg = [0] * n \n    for item in cycle:\n        for v in edge[item]:\n            if v in in_cycle:\n                deg[v] += 1\n    \n    ok = True\n    for i, item in enumerate(cycle):\n        if deg[item] > 1:\n            ok = False\n            cur_id = start = i\n    if ok:\n        print(len(cycle))\n        print(\"\\n\".join([str(item + 1) for item in cycle]))\n        return\n\n    ncycle = []\n    cur = cycle[cur_id]\n    while True:\n        ncycle.append(cur)\n        if cycle[start] in edge[cur]:\n            break\n        cur_id = (cur_id + 1) % len(cycle)\n        cur = cycle[cur_id]\n    cycle = ncycle[:]", "from collections import deque\n\nn, m = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(m)]\nINF = 10 ** 5\n\nadj = [[] for _ in range(n)]\nfor a, b in ab:\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n\nmn = INF\nfor s in range(n):\n    dq = deque([s])\n    d = [-1] * n\n    p = [-1] * n\n    d[s] = 0\n    last = []\n\n    while dq:\n        u = dq.popleft()\n        for v in adj[u]:\n            if d[v] == -1:\n                d[v] = d[u] + 1\n                p[v] = u\n                dq.append(v)\n\n            if v == s:\n                last.append(u)\n\n    for v in last:\n        route = [v]\n        while p[v] != s:\n            v = p[v]\n            route.append(v)\n\n        route.append(s)\n        size = len(route)\n        if size < mn:\n            mn = size\n            ans = route[::-1]\n\nif mn != INF:\n    print(mn)\n    for e in ans:\n        print((e + 1))\nelse:\n    print((-1))\n", "import os\nimport sys\nfrom collections import deque\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, sys.stdin.readline().split()))\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\ngraph = [[] for _ in range(N + 1)]\n\nfor a, b in AB:\n    graph[a].append(b)\n\n\ndef cycle_size(from_v):\n    \"\"\"\n    from_v \u306b\u623b\u3063\u3066\u304f\u308b\u307e\u3067\u306e\u30b9\u30c6\u30c3\u30d7\u6570\n    :param from_v:\n    :return:\n    \"\"\"\n    parents = [None] * len(graph)\n    seen = [False] * len(graph)\n    que = deque([(from_v, 0)])\n    while que:\n        v, d = que.pop()\n        for u in graph[v]:\n            if seen[u]:\n                continue\n            seen[u] = True\n            que.appendleft((u, d + 1))\n            parents[u] = v\n            if u == from_v:\n                return d + 1, parents\n    return INF, parents\n\n\nmin_v = None\nmin_size = INF\nmin_parents = None\nfor v in range(1, N + 1):\n    size, parents = cycle_size(v)\n    if size < min_size:\n        min_v = v\n        min_size = size\n        min_parents = parents\n\nif min_size < INF:\n    print(min_size)\n    print(min_v)\n    v = min_parents[min_v]\n    while v != min_v:\n        print(v)\n        v = min_parents[v]\nelse:\n    print((-1))\n", "import sys\nsys.setrecursionlimit(500000)\ndef scc(N, G, RG):\n    # https://tjkendev.github.io/procon-library/python/graph/scc.html\n    order = []\n    used = [0]*N\n    group = [None]*N\n    def dfs(s):\n        used[s] = 1\n        for t in G[s]:\n            if not used[t]:\n                dfs(t)\n        order.append(s)\n    def rdfs(s, col):\n        group[s] = col\n        used[s] = 1\n        for t in RG[s]:\n            if not used[t]:\n                rdfs(t, col)\n    for i in range(N):\n        if not used[i]:\n            dfs(i)\n    used = [0]*N\n    label = 0\n    for s in reversed(order):\n        if not used[s]:\n            rdfs(s, label)\n            label += 1\n    return label, group\n\nfrom collections import Counter\nN, M = list(map(int, input().split()))\nE = [[] for _ in range(N+1)]\nE_set = [set() for _ in range(N+1)]\nE_rev = [[] for _ in range(N+1)]\nE_rev_set = [set() for _ in range(N+1)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    E[a].append(b)\n    E_set[a].add(b)\n    E_rev[b].append(a)\n    E_rev_set[b].add(a)\n\nlabel, group = scc(N+1, E, E_rev)\ncnt = Counter(group)\nClosed = [False] * (N+1)\n\ngrooo = [set() for _ in range(N+1)]\nfor v, gr in enumerate(group):\n    grooo[gr].add(v)\n\nfrom random import random\nhaaaaaaaaaaaaaaaaaaaaaaa = enumerate(group) if random() > 0.5 else list(zip(list(range(N, 0, -1)), group[::-1]))\n\n\nfor v, gr in haaaaaaaaaaaaaaaaaaaaaaa:\n    if Closed[gr]:\n        continue\n    Closed[gr] = True\n    if cnt[gr]==1:\n        continue\n\n    #print(gr, cnt[gr])\n    groo = grooo[gr]\n\n    path = [v]\n    path_set = {v}\n    while True:\n        #print(\"v=\",v)\n        aaa = E_set[v]&path_set\n        if aaa:\n            break\n        u = (groo&E_set[v]).pop()\n        #print(\"u=\",u)\n        while E_rev_set[u]-{v} & path_set:\n            path_set.remove(path.pop())\n        path.append(u)\n        path_set.add(u)\n        v = u\n        #print(path)\n    for i, v in enumerate(path):\n        if v in aaa:\n            aaa.remove(v)\n            if len(aaa)==0:\n                break\n    ans = path[i:]\n    print((len(ans)))\n    print((\"\\n\".join(map(str, ans))))\n    return\nprint((-1))\n", "def main():\n  from collections import deque\n  n,m,*t=map(int,open(0).read().split())\n  i,o=[0]*n,[[]for _ in range(n)]\n  for a,b in zip(*[iter(t)]*2):\n    o[a-1]+=b-1,\n    i[b-1]+=1\n  q=deque(v for v in range(n)if i[v]<1)\n  r=[]\n  while q:\n    v=q.popleft()\n    r+=v,\n    for w in o[v]:\n      i[w]-=1\n      if i[w]==0:q+=w,\n  print(-(len(r)==n))\nmain()", "from heapq import heappop, heappush\n\nn, m = map(int, input().split())\nxy = [tuple(int(x)-1 for x in input().split()) for _ in range(m)]\n\nR = [[] for _ in range(n)]\nh = [0] * n\n\nfor x, y in xy:\n    R[x].append(y)\n    h[y] += 1\n\nS = []\n\nst = []\n\nfor i in range(n):\n    if h[i] == 0:\n        heappush(st, i)\n\nwhile len(st) > 0:\n    temp = heappop(st)\n    S.append(temp)\n    for x in R[temp]:\n        h[x] -= 1\n        if h[x] == 0:\n            heappush(st, x)\n\nif len(S) != n:\n    print(-99999)\nelse:\n    print(-1)", "from collections import deque\n\n\ndef main():\n    # N = int(input())\n    # N,= [int(a) for a in input().split()]\n    # N, M = [int(a) for a in input().split()]\n\n    # a = []\n    # # b = []\n    # c = []\n    #\n    # for _ in range(M):\n    #     aa, bb = [int(a) for a in input().split()]\n    #     cc = [int(a) for a in input().split()]\n    #     a.append(aa)\n    #     # b.append(bb)\n    #     c.append(cc)\n    N, M = [int(a) for a in input().split()]\n\n    AB = [\n        [int(a) for a in input().split()]\n        for _ in range(M)\n    ]\n\n    pp = [[] for _ in range(N)]\n    for a, b in AB:\n        pp[a - 1].append(b - 1)\n\n    startpool = set(range(N))\n\n    result = None\n\n    while len(startpool) != 0:\n        start = min(startpool)\n\n        q = deque([(start, [start])])\n        renketu = {start}\n        while len(q) != 0:\n            p, history = q.popleft()\n            target = pp[p]\n            for t in target:\n                if t in history:\n                    if result is None:\n                        result = history\n                    elif len(result) > len(history) - history.index(t):\n                        result = history[history.index(t):]\n                if t not in renketu:\n                    q.append([t, history + [t]])\n\n                renketu.add(t)\n        startpool -= renketu\n\n    if result is not None:\n        print((len(result)))\n        for a in result:\n            print((a + 1))\n        return\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\ndef serp(s):\n  prev = [-1]*n\n  q=deque([s])\n  while q:\n    v = q.pop()\n    for nv in e[v]:\n      if nv==s: prev[nv]=v; return(s,prev)\n      if prev[nv]<0: q+=nv,; prev[nv] =v\n  return(-1,prev)\nn,m,*t=map(int,open(0).read().split())\ne,ab = [[] for i in range(n)],[]\nfor a,b in zip(*[iter(t)]*2):\n  e[a-1]+= b-1,\n  ab += [(a-1,b-1)]\nfor v in range(n):\n  v0,prev = serp(v)\n  if v0>=0: break\nif v0<0: print(-1); return\nc=set()\nc.add(v0)\npv = prev[v0]\nwhile pv!=v0:\n  c.add(pv)\n  pv=prev[pv]\nfor a,b in ab:\n  if a in c and b in c and prev[b]!=a:\n    pv = prev[b]\n    while pv !=a:\n      c.remove(pv)\n      pv=prev[pv]\n    prev[b]=a\nprint(len(c))\nfor i in c: print(i+1)", "#!/usr/bin/env python\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import deque\ninput = sys.stdin.buffer.readline\nINF = float(\"inf\")\n\ndef main():\n    N,M = map(int,input().split())\n    G = [[] for _ in range(N)]\n    AB = [tuple(map(int,input().split())) for _ in range(M)]\n    for a,b in AB:\n        G[a-1].append(b-1)\n\n    Ans = [1]*(N+1)\n    \n    # \u5168\u3066\u306e\u9802\u70b9\u304b\u3089, \u9589\u8def\u304c\u5b58\u5728\u3057\u306a\u3044\u304b\u3092\u78ba\u8a8d\u3059\u308b\n    for s in range(N):\n        prev = [-1]*N\n        dist = [-1]*N\n        dist[s] = 0\n        dq = deque([s])\n        while dq:\n            v = dq.popleft()\n            for nv in G[v]:\n                if dist[nv] == -1:\n                    dist[nv] = dist[v] + 1\n                    prev[nv] = v\n                    dq.append(nv)\n                # \u6b21\u304c 0\u756a\u76ee(\u958b\u59cb\u5730\u70b9) \u306a\u3089\u9589\u8def\u3042\u308a\n                if dist[nv] == 0 and prev[nv] == -1:\n                    prev[nv] = v\n\n        # \u958b\u59cb\u5730\u70b9\u306e\u524d \u304c -1\u3067\u306a\u3044 => \u9589\u8def\u3042\u308a\n        if prev[s] != -1:\n            v = prev[s]\n            ans = set()\n            for _ in range(max(dist)+1):\n                ans.add(prev[v])\n                v = prev[v]\n            if len(Ans) > len(ans):\n                Ans = list(ans)\n    \n    if len(Ans) == N+1:\n        print(-1)\n    else:\n        print(len(Ans))\n        Ans.sort()\n        for v in Ans:\n            print(v+1)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nINF = float('inf')\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    g[a].append(b)\n\nres = []\nshortest = n + 1\nfor s in range(n):\n    dist = [-1] * n\n    prev = [-1] * n\n    q = deque()\n    q.append(s)\n    dist[s] = 0\n    while len(q) != 0:\n        v = q.popleft()\n        for nv in g[v]:\n            if dist[nv] == -1:\n                dist[nv] = dist[v] + 1\n                prev[nv] = v\n                q.append(nv)\n    for t in range(n):\n        if t == s:\n            continue\n        if dist[t] == -1:\n            continue\n        for nt in g[t]:\n            if nt == s:\n                temp = [s]\n                cur = t\n                while cur != s:\n                    temp.append(cur)\n                    cur = prev[cur]\n                if shortest > len(temp):\n                    shortest = len(temp)\n                    res = temp\nif shortest == n + 1:\n    print((-1))\n    return\nprint((len(res)))\nfor v in res:\n    print((v + 1))\n\n# def bfs(sv):\n#     dist = [INF] * n\n#     pre = [-1] * n\n#     q = deque()\n#     q.append(sv)\n#     dist[sv] = 0\n#     while q:\n#         v = q.popleft()\n#         for nv in g[v]:\n#             if dist[nv] == INF:\n#                 continue\n#             pre[nv] = v\n#             dist[nv] = dist[v] + 1\n#             q.append(nv)\n#     print(dist)\n#     best = (INF, -1)\n#     for v in range(n):\n#         if v == sv:\n#             continue\n#         for nv in g[v]:\n#             if nv == sv:\n#                 best = min(best, (dist[nv], nv))\n#                 print(sv, best)\n#                 # print(best)\n#     if best[0] == INF:\n#         return [0] * (n + 1)\n#     print(pre)\n#     v = best[1]\n#     print('v', v)\n#     res = []\n#     while v != -1:\n#         res.append(v)\n#         v = pre[v]\n#     print('res', res)\n#     return res\n\n\n# ans = [0] * (n + 1)\n# for s in range(n):\n#     now = bfs(s)\n#     if len(now) < len(ans):\n#         print('aa')\n#         ans = now\n#         print(ans)\n# if len(ans) == n + 1:\n#     print(-1)\n#     return\n# print(len(ans))\n# for v in ans:\n#     print(v)\n", "def dfs(N, AB):\n    status = [-1] * N\n    for i in range(N):\n        if status[i] == 1:\n            continue\n        stack = [i]\n        status[i] = 0\n        while stack:\n            v = stack[-1]\n            if AB[v]:\n                n = AB[v].pop()\n                if status[n] == -1:\n                    stack.append(n)\n                    status[n] = 0\n                elif status[n] == 0:\n                    idx = stack.index(n)\n                    cycle = stack[idx:]\n                    \n                    return cycle\n            else:                  \n                status[v] = 1\n                stack.pop()\n\n    return False\n\n\ndef find_smaller_cycle(cycle, AB):\n    i = 0\n    while i < len(cycle):\n        v = cycle[i]\n        if AB[v]:\n            n = AB[v].pop()\n            if n in cycle:\n                r = cycle.index(n)\n                if i < r:\n                    cycle = cycle[:i+1] + cycle[r:]\n                else:\n                    cycle = cycle[r:i+1]\n                i = cycle.index(v)\n        else:\n            i += 1\n            \n    return cycle\n\n\nN, M = [int(i) for i in input().split()]\n\nAB = [[] for _ in range(N)]\nfor _ in range(M):\n    A, B = [int(i) - 1 for i in input().split()]\n    AB[A].append(B)\n                      \ncycle = dfs(N, AB)\nif not cycle:\n    print(-1)\nelse:\n    cycle = find_smaller_cycle(cycle, AB)\n            \n    print(len(cycle))\n    for v in cycle:\n        print(v + 1)", "def dfs(N, AB):\n  status = [-1] * N\n  for i in range(N):\n      if status[i] == 1:\n          continue\n      stack = [i]\n      status[i] = 0\n      while stack:\n          print(\"stack:\", stack)\n          v = stack[-1]\n          if AB[v]:\n              n = AB[v].pop()\n              if status[n] == -1:\n                  stack.append(n)\n                  status[n] = 0\n              elif status[n] == 0:\n                  idx = stack.index(n)\n                  print(\"stack:\", stack, \"n:\", n, \"idx:\", idx)\n                  cycle = stack[idx:]\n                  \n                  return cycle\n          else:                  \n              status[v] = 1\n              stack.pop()\n \n  return False\n\ndef dfs_2(N, AB):\n  for c in range(N):\n    stack = [(c, [])]\n    while stack:\n      # print(\"stack:\", stack)\n      curr, visited = stack.pop()\n      if curr in visited:\n        # print(\"cycle found:\", curr)\n        return visited\n      else:\n        # print(\"adding in visited:\", curr)\n        for i in AB[curr]:\n          stack.append((i, visited+[curr]))\n  return False\n\n \n \ndef find_smaller_cycle(cycle, AB):\n    i = 0\n    while i < len(cycle):\n        v = cycle[i]\n        if AB[v]:\n            n = AB[v].pop()\n            if n in cycle:\n                r = cycle.index(n)\n                if i < r:\n                    cycle = cycle[:i+1] + cycle[r:]\n                else:\n                    cycle = cycle[r:i+1]\n                i = cycle.index(v)\n        else:\n            i += 1\n            \n    return cycle\n \n \nN, M = [int(i) for i in input().split()]\n \nAB = [[] for _ in range(N)]\nfor _ in range(M):\n    A, B = [int(i) - 1 for i in input().split()]\n    AB[A].append(B)\n\n# print(\"AB:\")\n# for i in AB:\n#   print(i)\ncycle = dfs_2(N, AB)\n# print(\"cycle:\", cycle)\nif not cycle:\n    print(-1)\nelse:\n    cycle = find_smaller_cycle(cycle, AB)\n            \n    print(len(cycle))\n    for v in cycle:\n        print(v + 1)", "\nfrom collections import deque\ndef resolve():\n    N, M = list(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(x) - 1 for x in input().split()]\n        G[a].append(b)\n\n    shortest = N + 1\n    res = []\n    for s in range(N):\n        dist = [-1] * N\n        pre = [-1] * N\n        q = deque()\n        q.append(s)\n        dist[s] = 0\n        while q:\n            v = q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    pre[to] = v\n                    q.append(to)\n\n        for t in range(N):\n            if t == s or dist[t] == -1:\n                continue\n            for to in G[t]:\n                if to == s:  # \u30b5\u30a4\u30af\u30eb\u306b\u306a\u3063\u3066\u3044\u308b\u9802\u70b9\n                    tmp = [s]\n                    cur = t\n                    while cur != s:\n                        tmp.append(cur)\n                        cur = pre[cur]\n                    if shortest > len(tmp):\n                        shortest = len(tmp)\n                        res = tmp\n\n    if shortest == N + 1:\n        print((-1))\n    else:\n        print((len(res)))\n        res.sort()\n        for v in res:\n            print((v + 1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\nes = [[] for i in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n\nfrom collections import deque\ntmpdist = N\nans = None\nfor to in range(N):\n    for fr in es[to]:\n        dist = [N] * N\n        dist[fr] = 0\n        prev = [-1] * N\n        q = deque([fr])\n        while q:\n            v = q.popleft()\n            if v==to: break\n            for w in es[v]:\n                if dist[w] < N: continue\n                if v==to and w==fr: continue\n                dist[w] = dist[v] + 1\n                prev[w] = v\n                q.append(w)\n        else:\n            continue\n        if dist[to] < tmpdist:\n            tmpdist = dist[to]\n            ans = set()\n            v = to\n            while 1:\n                ans.add(v+1)\n                if prev[v] < 0: break\n                v = prev[v]\nif ans is None:\n    print(-1)\nelse:\n    print(len(ans))\n    print(*ans, sep='\\n')", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nfrom collections import deque\n\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n\n    ans_last = None # s\u304b\u3089\u30eb\u30fc\u30d7\u3092\u63a2\u3057\u3066\u898b\u3064\u304b\u3063\u305f\u6642\u306e\u3001\u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u756a\u53f7\n    dq.append(s)\n    # BFS\u3067\u30eb\u30fc\u30d7\u3092\u898b\u3064\u3051\u308b\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            # \u9802\u70b9v\u304b\u3089\u3044\u3051\u308b\u9802\u70b9\u306e\u4e2d\u306b\u958b\u59cb\u70b9\u304c\u3042\u3063\u305f\u3089\u3001\u30eb\u30fc\u30d7\u3067\u3042\u308b\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            # \u307e\u3060\u63a2\u7d22\u3057\u3066\u3044\u306a\u3044\u9802\u70b9\u306a\u3089\u6b21\u306e\u63a2\u7d22\u5019\u88dc\u306b\u3059\u308b\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n\n    # \u30eb\u30fc\u30d7\u304c\u898b\u3064\u304b\u3063\u305f\u5834\u5408\n    if ans_last:\n        # \u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u304b\u3089\u3001\u5143\u306e\u9802\u70b9\u3092\u305f\u3069\u308a\u3001\u305d\u306e\u30eb\u30fc\u30c8\u3092\u9006\u306b\u3059\u308b\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    \n    # \u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u5834\u5408\u306fNone\u3092\u8fd4\u3059\n    return None\n\ndef main():\n    N, M, *A = map(int, read().split())\n\n    G = [[] for i in range(N+1)]\n    for a, b in zip(A[::2], A[1::2]):\n        G[a].append(b)\n\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3067\u3042\u308b\u3088\u3046\u306a G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\n    # [\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u306e\u30b0\u30e9\u30d5] -> \u30eb\u30fc\u30d7\n\n    # \u6709\u5411\u30b0\u30e9\u30d5 G=(V,E) \u306b\u5bfe\u3057\u3001\u6b21\u306e\u3088\u3046\u306a\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6709\u5411\u30b0\u30e9\u30d5 G\u2032=(V\u2032,E\u2032) \u3092 G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\u3068\u547c\u3076\u3002\n    # V\u2032 \u306f V \u306e (\u7a7a\u3067\u306a\u3044) \u90e8\u5206\u96c6\u5408\u3067\u3042\u308b\u3002\n    # E\u2032 \u306f\u3001E \u306e\u8fba\u3067\u3042\u3063\u3066\u4e21\u7aef\u70b9\u304c\u3068\u3082\u306b V\u2032 \u306b\u542b\u307e\u308c\u308b\u3082\u306e\u3059\u3079\u3066\u3092\u542b\u3080\u96c6\u5408\u3067\u3042\u308b\u3002\n\n    # -> \u30eb\u30fc\u30d7\u3067\u3082\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u308b\u3088\u3046\u306a\u30eb\u30fc\u30d7\u306f\u3060\u3081\n\n    # \u4f8b: 1 -> 2 -> 3 -> 4 -> 5\n    #     ^    |         ^    |\n    #     |    ----------|    |\n    #     ---------------------\n    # V' = {1, 2, 3, 4, 5} \u3068\u3057\u3066\u3057\u307e\u3046\u3068\u3001\n    # E' = {(1->2), (2->3), (3->4), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u3063\u3066\u3057\u307e\u3044\u3001\u3053\u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5G'=(V', E')\u306b\u304a\u3044\u3066\u3001\n    # \u9802\u70b92\u306e\u51fa\u6b21\u6570\u304c2\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u3002\uff08\u9802\u70b94\u306e\u5165\u6b21\u6570\u30822\u306b\u306a\u3063\u3066\u3057\u307e\u3046\uff09\n    # V' = {1, 2, 4, 5} \u3068\u3059\u308c\u3070\u3001\n    # E' = {(1->2), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u308a\u3001\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3068\u306a\u308b\n    \n    # \u3064\u307e\u308a\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u306a\u3044\u6700\u77ed\u306e\u30eb\u30fc\u30d7\u30921\u3064\u3067\u3082\u898b\u3064\u3051\u308c\u3070\u3088\u3044\n    \n    min_route = None\n    for s in range(1, N+1):\n        # \u5404\u9802\u70b9\u3092\u958b\u59cb\u70b9\u306b\u3057\u3066\u30eb\u30fc\u30d7\u3092\u63a2\u3059\n        route = find_shortest_cycle(G, s)\n        # \u30eb\u30fc\u30d7\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u3001\u77ed\u3044\u307b\u3046\u3092\u63a1\u7528\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    \n    if min_route:\n        print(len(min_route), *min_route, sep='\\n')\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\ninpl = lambda: list(map(int,input().split()))\nN, M = inpl()\nuv = [ set() for _ in range(N)]\nvu = [ set() for _ in range(N)]\nfor _ in range(M):\n    A, B = inpl()\n    uv[A-1].add(B-1)\n    vu[B-1].add(A-1)\n\nEMPTY, LOOP, TREE = 0, 1, 2\nENTER, EXIT = 0, 1\nstatus = [EMPTY] * N\nfor s in range(N):\n    states_pool = [(s,[],ENTER)]\n    while states_pool:\n        u, chain, flag = states_pool.pop()\n        if flag == EXIT or status[u] == TREE:\n            status[u] = TREE\n            continue\n        elif status[u] == LOOP:\n            break\n        else: # ENTER, EMPTY\n            status[u] = LOOP\n            states_pool.append((u,chain,EXIT))\n            new_chain = chain.copy()\n            new_chain.append(u)\n            for c in uv[u]:\n                states_pool.append((c, new_chain, ENTER))\n    else:\n        continue\n    break\nelse:\n    print(-1)\n    return\n\nn = 0\nwhile chain[n] != u:\n    n += 1\nchain = chain[n:]\nL = len(chain)\nnextnode = [None]*N\nfor i in range(L-1):\n    nextnode[chain[i]] = chain[i+1]\nnextnode[chain[L-1]] = chain[0]\npos = [None]*N\nfor p in range(len(chain)):\n    pos[chain[p]] = p\ni = 0\nwhile i < L:\n    h = 1\n    c = chain[(i+1)%L]\n    for j in uv[chain[i % L]]:\n        p = pos[j]\n        if p is None:\n            continue\n        else:\n            if (p-i)%L > h:\n                h = (p-i)%L\n                c = j\n    nextnode[chain[i % L]] = c\n    i += 1\n    while chain[i % L] != c:\n        pos[chain[i % L]] = None\n        i += 1\n\nloop = [c]\nk = c\nwhile nextnode[k] != c:\n    k = nextnode[k]\n    loop.append(k)\nprint(len(loop))\nfor l in loop:\n    print(l+1)", "import sys\nsys.setrecursionlimit(10**7)\ndef main():\n    N, M = list(map(int, input().split()))\n    l = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        l[a-1].append(b-1)\n    c = [0] * N\n    loop = []\n    def cyclic(n):\n        if c[n] == 2:\n            return False\n        if c[n] == 1:\n            loop.append(n)\n            return True\n        c[n] = 1\n        for i in l[n]:\n            if cyclic(i):\n                loop.append(n)\n                return True\n        c[n] = 2\n        return False\n    for i in range(N):\n        if cyclic(i):\n            break\n    if len(loop) == 0:\n        print((-1))\n        return\n    print((0))\n    return\nmain()\n", "import sys\nfrom collections import deque\n\n\ndef solve():\n    N, M = map(int, input().split())\n    edges = [set() for _ in range(N+1)]\n    for a, b in (map(int, line.split()) for line in sys.stdin):\n        edges[a].add(b)\n\n    # \u7b54\u3048\u304c\u898b\u3064\u304b\u308b\u307e\u3067\u3001\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u306f\u5168\u3066\u8a66\u3057\u307e\u3059\n    for start in range(1, N+1):\n        visited = [0]*(N+1)\n\n        dq = deque([(start, {start})])\n        visited[start] = 1\n\n        while dq:\n            # \u70b9\u3068\u3001\u3053\u308c\u307e\u3067\u901a\u3063\u3066\u304d\u305f\u9802\u70b9\u3092\u53d6\u308a\u51fa\u3059\n            v, route = dq.popleft()\n            # \u3053\u308c\u307e\u3067\u901a\u3063\u3066\u304d\u305f\u9802\u70b9\u96c6\u5408\u3068\u3001\u884c\u304d\u5148\u306e\u9802\u70b9\u96c6\u5408\u306e\u7a4d\u96c6\u5408\u3092\u3068\u308b\n            s = route & edges[v]\n            # s=={start}\u3067\u306a\u3051\u308c\u3070u\u3068\u304ar s\u304c\u7a7a\u96c6\u5408\u3067\u3082\u901a\u308b\u3002s\u304c\u4f55\u3084\u3089\u3044\u308d\u3044\u308d\u3042\u308b\u3068\u3001\u901a\u308c\u306a\u3044\u3002\n            if not (not s or s == {start}):\n                continue\n            for dest in edges[v]:\n                # start\u306b\u623b\u3063\u3066\u304d\u305f\u3089\u51fa\u529b\u3057\u3066\u7d42\u4e86\n                if dest == start:\n                    print(len(route))\n                    print(*route, sep='\\n')\n                    return\n                # \u8a2a\u554f\u6e08\u307f\u3067\u3042\u308c\u3070\u3001\u30b9\u30eb\u30fc\n                if visited[dest]:\n                    continue\n                visited[dest] = 1\n                # dest\u3092\u59cb\u70b9\u3068\u3057\u3066\u3001\u901a\u3063\u3066\u304d\u305f\u9802\u70b9\u306bdest\u3092\u8ffd\u52a0\u3057\u305f\u3082\u306e\n                dq.append((dest, route | {dest}))\n\n    print(-1)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nfrom collections import deque\nN, M = map(int, input().split())\nedges = [[] for i in range(N)]\nAB = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges[a-1].append(b-1)\n    AB.append((a-1, b-1))\ndef BFS(s):\n    prev = [-1]*N\n    que = deque([s])\n    while que:\n        v = que.pop()\n        for nv in edges[v]:\n            if nv == s:\n                prev[nv] = v\n                return (s, prev)\n            if prev[nv]<0:\n                que.append(nv)\n                prev[nv] = v\n    return (-1, prev)\nfor v in range(N):\n    v0, prev = BFS(v)\n    if v0>=0:\n        break\nif v0<0:\n    print(-1)\n    return\ncircle = set()\ncircle.add(v0)\npv = prev[v0]\nwhile pv != v0:\n    circle.add(pv)\n    pv = prev[pv]\nfor a, b in AB:\n    if a in circle and b in circle and prev[b] != a:\n        pv = prev[b]\n        while pv != a:\n            circle.remove(pv)\n            pv = prev[pv]\n        prev[b] = a\nprint(len(circle))\nfor i in circle:\n    print(i+1)", "import numpy as np\nfrom scipy.sparse.csgraph import dijkstra\n\ndef get_path(start, goal, pred):\n    return get_path_row(start, goal, pred[start])\n\ndef get_path_row(start, goal, pred_row):\n    path = []\n    i = goal\n    while i != start and i >= 0:\n        path.append(i)\n        i = pred_row[i]\n    if i < 0:\n        return []\n    path.append(i)\n    return path[::-1]\nN, M = map(int,input().split())\ng = [[np.inf]*(2*N) for _ in range(2*N)]\nfor i in range(M):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    g[a][b] = 1\n    g[a][b+N] = 1\n    g[a+N][b] = 1\n\nans = np.inf\nj = -1\nd = dijkstra(g,return_predecessors=True)\n\nfor i in range(N):\n    if d[0][i][i+N] < ans:\n        ans = int(d[0][i][i+N])\n        j = i\n\nif ans != np.inf:\n    path = get_path(j,j+N,d[1])[::-1][:-1]\n    path = [node%N for node in path]\n    print(ans)\n    for node in path:\n        print(node+1)\nelse:\n    print(-1)", "from collections import*\nn,m=map(int,input().split())\nouts=defaultdict(list)\nins=defaultdict(int)\nfor _ in range(m):\n    a,b=map(int,input().split())\n    outs[a-1]+=b-1,\n    ins[b-1]+=1\nq=deque(i for i in range(n)if ins[i]==0)\nres=[]\nwhile q:\n    v=q.popleft()\n    res+=v,\n    for w in outs[v]:\n        ins[w]-=1\n        if ins[w]==0:\n            q.append(w)\nprint(-(len(res)==n))", "import sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nn, m = na()\ng = [[False] * n for _ in range(n)]\ngs = [[] for _ in range(n)]\nfor i in range(m):\n    s, t = na()\n    gs[s-1].append(t-1)\n    g[s-1][t-1] = True\n\nans = 999999\nbest = None\nfor i in range(n):\n    ds = [9999999] * n\n    prevs = [-1] * n\n    ds[i] = 0\n    q = [i]\n    qp = 0\n    while qp < len(q):\n        cur = q[qp]\n        qp += 1\n        for e in gs[cur]:\n            if ds[e] > ds[cur] + 1:\n                ds[e] = ds[cur] + 1\n                prevs[e] = cur\n                q.append(e)\n    for j in range(n):\n        if g[j][i]:\n            if ds[j] + 1 < ans:\n                ans = ds[j] + 1\n                best = [0] * (ds[j]+1)\n                best[0] = i\n                cur = j\n                r = -1\n                while cur != i:\n                    best[r] = cur\n                    r -= 1\n                    cur = prevs[cur]\n\nif not best:\n    print((-1))\nelse:\n    print(ans)\n    for x in best:\n        print((x+1))\n", "from collections import*\nn,m,*t=map(int,open(0).read().split())\ni,o,r=[0]*n,[[]for _ in'_'*n],[]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq=deque(v for v in range(n)if i[v]<1)\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint(-(len(r)==n))", "import sys\nfrom collections import deque\n\n\ndef shave(fwd_link, bwd_link):\n    # Vertices having no leaving link\n    q = [v for v, links in enumerate(fwd_link) if not links]\n    while q:\n        v = q.pop()\n        for u in bwd_link[v]:\n            fwd_link[u].remove(v)\n            if not fwd_link[u]:\n                q.append(u)\n    # Vertices having no entering link\n    q = [v for v, links in enumerate(bwd_link) if not links]\n    while q:\n        v = q.pop()\n        for u in fwd_link[v]:\n            bwd_link[u].remove(v)\n            if not bwd_link[u]:\n                q.append(u)\n\n\ndef bfs(s, fwd_link):\n    predecessors = [-1] * n\n    q = deque()\n    for v in fwd_link[s]:\n        predecessors[v] = s\n        q.append((v, s))\n    visited = set()\n    while q:\n        v, p = q.popleft()\n        if v in visited:\n            continue\n        visited.add(v)\n        predecessors[v] = p\n\n        if v == s:\n            break\n\n        for u in fwd_link[v]:\n            if u not in visited:\n                q.append((u, v))\n\n    circuit = {s}\n    v = predecessors[s]\n    while v != s:\n        circuit.add(v)\n        v = predecessors[v]\n\n    return predecessors, circuit\n\n\ndef check(predecessors, circuit, fwd_link):\n    for v in circuit:\n        fwd_link[v].intersection_update(circuit)\n        if len(fwd_link[v]) == 1:\n            continue\n        for u in fwd_link[v]:\n            if predecessors[u] != v:\n                return u\n    return -1\n\n\ndef print_ans(circuit):\n    print((len(circuit)))\n    print((*(v + 1 for v in circuit)))\n\n\ndef solve(fwd_link, bwd_link):\n    shave(fwd_link, bwd_link)\n    s = -1\n    for s, (f, b) in enumerate(zip(fwd_link, bwd_link)):\n        if f and b:\n            break\n    else:\n        print((-1))\n        return\n\n    while True:\n        predecessors, circuit = bfs(s, fwd_link)\n        res = check(predecessors, circuit, fwd_link)\n        if res == -1:\n            print_ans(circuit)\n            break\n        s = res\n\n\nn, m = list(map(int, input().split()))\nfwd_link = [set() for _ in range(n)]\nbwd_link = [set() for _ in range(n)]\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    a -= 1\n    b -= 1\n    fwd_link[a].add(b)\n    bwd_link[b].add(a)\n\nsolve(fwd_link, bwd_link)\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef SCC(N, edges):\n    \"\"\" \u5f37\u9023\u7d50\u6210\u5206\u5206\u89e3 \"\"\"\n\n    nodes1 = [[] for i in range(N)]\n    nodes2 = [[] for i in range(N)]\n    for u, v in edges:\n        nodes1[u].append(v)\n        nodes2[v].append(u)\n\n    T = []\n    visited = [False] * N\n    def rec1(cur):\n        visited[cur] = True\n        for nxt in nodes1[cur]:\n            if not visited[nxt]:\n                rec1(nxt)\n        # \u884c\u304d\u6b62\u307e\u3063\u305f\u3068\u3053\u308d\u304b\u3089\u9806\u306bT\u306b\u5165\u308c\u3066\u3044\u304f\n        T.append(cur)\n\n    # \u30b0\u30e9\u30d5\u304c\u9023\u7d50\u3068\u306f\u9650\u3089\u306a\u3044\u306e\u3067\u5168\u9802\u70b9\u3084\u308b\n    for u in range(N):\n        if not visited[u]:\n            rec1(u)\n\n    visited = [False] * N\n    group = [0] * N\n    grpcnt = 0\n    def rec2(cur):\n        group[cur] = grpcnt\n        visited[cur] = True\n        for nxt in nodes2[cur]:\n            if not visited[nxt]:\n                rec2(nxt)\n\n    # \u9006\u9806\u3067\u9032\u3081\u308b\u3068\u3053\u308d\u307e\u3067\u884c\u304f\n    for u in reversed(T):\n        if not visited[u]:\n            rec2(u)\n            grpcnt += 1\n    return grpcnt, group\n\ndef bfs(N, nodes, src):\n    \"\"\" BFS(\u4e00\u822c\u30b0\u30e9\u30d5\u3001\u91cd\u307f\u306a\u3057) \"\"\"\n    from collections import deque\n\n    que = deque([(src, -1, 0)])\n    dist = [()] * N\n    mn = INF\n    end = -1\n    while que:\n        u, prev, c = que.popleft()\n        # \u540c\u3058\u5f37\u9023\u7d50\u6210\u5206\u5185\u306e\u307f\u3067\u3084\u308b\n        if group[u] != group[src]:\n            continue\n        if dist[u]:\n            # \u8a2a\u554f\u6e08\u3067\u59cb\u70b9\u306b\u5e30\u3063\u3066\u304d\u305f\u3089\u3001\u6700\u77ed\u30c1\u30a7\u30c3\u30af\n            if u == src:\n                if c < mn:\n                    mn = c\n                    end = prev\n            continue\n        dist[u] = (c, prev)\n        for v in nodes[u]:\n            que.append((v, u, c+1))\n    # \u7d4c\u8def\u3001\u59cb\u70b9\u306b\u623b\u3063\u3066\u304f\u308b\u6700\u77ed\u8ddd\u96e2\u3001\u305d\u306e\u76f4\u524d\u306e\u9802\u70b9\u3092\u8fd4\u3059\n    return dist, mn, end\n\ndef get_route(s, t, res):\n    \"\"\" s,t\u9593\u306e\u7d4c\u8def\u3092\u53d6\u5f97 \"\"\"\n    prev = t\n    StoT = [t]\n    while prev != s:\n        prev = res[prev][1]\n        if prev == -1:\n            return None\n        StoT.append(prev)\n    StoT = StoT[::-1]\n    return StoT\n\nN, M = MAP()\nnodes = [[] for i in range(N)]\nedges = []\nfor i in range(M):\n    a, b = MAP()\n    a -= 1; b -= 1\n    nodes[a].append(b)\n    edges.append((a, b))\n\n# \u5f37\u9023\u7d50\u6210\u5206\u6bce\u306b\u898b\u308b\ngrpcnt, group = SCC(N, edges)\nans = INF\nfor i in range(N):\n    # \u7d4c\u8def\u3001\u59cb\u70b9\u306b\u623b\u3063\u3066\u304f\u308b\u6700\u77ed\u8ddd\u96e2\u3001\u305d\u306e\u76f4\u524d\u306e\u9802\u70b9\n    dist, mn, end = bfs(N, nodes, i)\n    if mn < ans:\n        ans = mn\n        route = get_route(i, end, dist)\nif ans != INF:\n    print(ans)\n    [print(u + 1) for u in route]\nelse:\n    # \u305d\u3082\u305d\u3082\u9589\u8def\u306a\u3057\n    print(-1)\n", "from collections import deque\n\nN, M = map(int, input().split())\nedge = [[] for _ in range(N)]\nfor _ in range(M):\n    A,B = map(int, input().split())\n    edge[A - 1].append(B - 1)\n\nans = []\nfor sta in range(N):\n    prev = [-1] * N\n    que = deque([sta])\n\n    while que:\n        v = que.popleft()\n        for w in edge[v]:\n            if w == sta: # \u9589\u8def\u767a\u898b\n                path = []\n                while v != -1:\n                    path.append(v+1)\n                    v = prev[v]\n                if (not ans) or (len(ans) > len(path)):\n                    ans = path\n                break\n\n            if prev[w] != -1: continue\n\n            prev[w] = v\n            que.append(w)\n\nif ans:\n    print(len(ans))\n    print(*ans, sep='\\n')\nelse:\n    print(-1)", "import sys\nsys.setrecursionlimit(10**4)\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn, m = map(int, input().split())\nadj = [[] for _ in range(n)]\nedges = []\nfor i in range(m):\n\ta, b = map(int, input().split())\n\tadj[a-1].append(b-1)\n\tedges.append((a-1, b-1))\n\nseen = [False for _ in range(n)]\nvisited = [False for _ in range(n)]\nbegin = -1\nhist = []\n\ndef dfs(x):\n\tnonlocal begin, hist\n\tif begin >= 0:\n\t\treturn\n\tseen[x] = True\n\thist.append(x)\n\tfor v in adj[x]:\n\t\tif visited[v]:\n\t\t\tcontinue\n\t\tif seen[v] == True and visited[v] == False:\n\t\t\tbegin = v\n\t\t\treturn\n\t\tdfs(v)\n\t\tif begin >= 0:\n\t\t\treturn\n\tvisited[x] = True\n\thist.pop()\n\treturn\n\nfor i in range(n):\n\tif begin < 0:\n\t\tdfs(i)\n\tif begin >= 0:\n\t\tbreak\n\nif begin < 0:\n\tprint(-1)\n\treturn\nelse:\n\tcycle = []\n\tincluded = [False for _ in range(n)]\n\tincluded[begin] = True\n\twhile hist and hist[-1] != begin:\n\t\tcycle.append(hist[-1])\n\t\tincluded[hist[-1]] = True\n\t\thist.pop()\n\tcycle.append(begin)\n\thist.pop()\n\n\twhile True:\n\t\tmeets = True\n\t\tl = len(cycle)\n\t\tind = [-1 for _ in range(n)]\n\t\tfor i in range(l):\n\t\t\tind[cycle[i]] = i\n\t\tfor i in range(l):\n\t\t\tif meets == False:\n\t\t\t\tbreak\n\t\t\tfor v in adj[cycle[(i+1)%l]]:\n\t\t\t\tif included[v] == True and v != cycle[i]:\n\t\t\t\t\tmeets = False\n\t\t\t\t\tnew_start_id, new_end_id = ind[v], (i+1)%l\n\t\t\t\t\tbreak\n\n\t\tif meets:\n\t\t\tprint(len(cycle))\n\t\t\tprint(*[c+1 for c in cycle], sep=\"\\n\")\n\t\t\tbreak\n\t\telse:\n\t\t\tnew_cycle = []\n\t\t\tincluded = [False for _ in range(n)]\n\t\t\tcur = new_end_id\n\t\t\twhile cur != new_start_id:\n\t\t\t\tnew_cycle.append(cycle[cur])\n\t\t\t\tincluded[cycle[cur]] = True\n\t\t\t\tcur = (cur+1)%l\n\t\t\tnew_cycle.append(cycle[new_start_id])\n\t\t\tcycle = new_cycle", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n\ndist = [[-1] * n for _ in range(n)]\nfor i in range(n):\n    queue = deque([(i, 0)])\n    while queue:\n        v, c = queue.popleft()\n        for v_next in graph[v]:\n            if dist[i][v_next] == -1:\n                dist[i][v_next] = c + 1\n                queue.append((v_next, c+1))\n\n# print(dist)\nans_len = n + 1\nfor i in range(n):\n    if dist[i][i] != -1:\n        ans_len = min(ans_len, dist[i][i])\nif ans_len == n + 1:\n    print(-1)\nelse:\n    for i in range(n):\n        if dist[i][i] == ans_len:\n            start_v = i\n            break\n\n    dist = [-1] * n\n    prev_v = [-1] * n\n    queue = deque([(start_v, 0)])\n    while queue:\n        v, c = queue.popleft()\n        if v == start_v and c != 0:\n            break\n        for v_next in graph[v]:\n            if dist[v_next] == -1:\n                dist[v_next] = c + 1\n                prev_v[v_next] = v\n                queue.append((v_next, c+1))\n\n    ans = []\n    # print(start_v)\n    # print(dist)\n    # print(prev_v)\n    v = start_v\n    for i in range(ans_len):\n        ans.append(v+1)\n        v = prev_v[v]\n\n    print(ans_len)\n    print(*ans, sep='\\n')\n", "from collections import deque\n\n     \ndef dfs(N, AB):\n    status = [-1] * N\n    for i in range(N):\n        if status[i] == 1:\n            continue\n        stack = [i]\n        status[i] = 0\n        while stack:\n            v = stack[-1]\n            if AB[v]:\n                n = AB[v].popleft()\n                if status[n] == -1:\n                    stack.append(n)\n                    status[n] = 0\n                else:\n                    if n in stack:\n                        idx = stack.index(n)\n                        cycle = stack[idx:]\n                        return cycle\n            else:                  \n                status[v] = 1\n                stack.pop()\n    return False\n\n\ndef find_smaller_cycle(cycle, AB):\n    i = 0\n    while i < len(cycle):\n        v = cycle[i]\n        if AB[v]:\n            n = AB[v].popleft()\n            if n in cycle:\n                r = cycle.index(n)\n                if i < r:\n                    cycle = cycle[:i+1] + cycle[r:]\n                else:\n                    cycle = cycle[r:i+1]\n                i = cycle.index(v)\n        else:\n            i += 1\n            \n    return cycle\n\n\nN, M = [int(i) for i in input().split()]\nAB = [deque() for _ in range(N)]\nfor _ in range(M):\n    A, B = [int(i) - 1 for i in input().split()]\n    AB[A].append(B)\n                      \ncycle = dfs(N, AB)\nif not cycle:\n    print(-1)\nelse:\n    cycle = find_smaller_cycle(cycle, AB)\n            \n    print(len(cycle))\n    for v in cycle:\n        print(v + 1)", "from collections import deque\n\nn,m = map(int,input().split())\ng = [list() for _ in range(n+1)]\nen = [0]*(n+1)\nfor _ in range(m):\n  u,v = map(int,input().split())\n  g[u].append(v)\n  en[v] += 1\nq = deque(i for i in range(1,n+1) if en[i] == 0)\ndone = list()\nwhile q:\n  v = q.popleft()\n  for x in g[v]:\n    en[x] -= 1\n    if not en[x]:\n      q.append(x)\n  done.append(v)\nprint(-1 if len(done) == n else 0)", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def bfs(u):\n        dist = [inf] * n\n        cur = [u]\n        pre = [-1] * n\n        dist[u] = 0\n        d = 0\n        while cur:\n            d += 1\n            nxt = []\n            for v in cur:\n                for kv in to[v]:\n                    if dist[kv] != inf: continue\n                    dist[kv] = d\n                    pre[kv] = v\n                    nxt.append(kv)\n            cur = nxt\n        mn = [inf, -1]\n        for v in range(n):\n            if v == u: continue\n            if u in to[v]:\n                mn = min(mn, [dist[v], v])\n\n        # print(dist)\n        # print(mn)\n        # print(pre)\n        res = []\n        v = mn[1]\n        if mn[0] == inf:\n            return [0] * (n + 1)\n        for _ in range(mn[0] + 1):\n            res.append(v)\n            v = pre[v]\n        return res\n\n    inf = 10 ** 9\n    n, m = list(map(int, input().split()))\n    to = defaultdict(set)\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        to[u - 1].add(v - 1)\n    ans = [0] * (n + 1)\n    for u in range(n):\n        res = bfs(u)\n        if len(res) < len(ans):\n            ans = res\n    if len(ans) == n + 1:\n        print((-1))\n    else:\n        print((len(ans)))\n        for u in ans:\n            print((u + 1))\n\nmain()\n", "from collections import*\nn,m,*t=list(map(int,open(0).read().split()))\ni,o,r=[0]*n,[[]for _ in'_'*n],[]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq=deque(v for v in range(n)if i[v]<1)\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint((-(len(r)==n)))\n", "from collections import deque\nimport sys\n\ninput = sys.stdin.buffer.readline\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\ninfi = 10 ** 10\n\n\ndef bfs(start):\n    # res = \u9802\u70b9\u6570, \u30b5\u30a4\u30af\u30eb\u6700\u5f8c\u306e\u9802\u70b9\u3001\u3067\u6301\u3064\n    res = (infi, -1)\n    dist = [-1] * (n + 1)\n    par = [-1] * (n + 1)\n    que = deque([])\n    que.append(start)\n    dist[start] = 0\n    while que:\n        v = que.popleft()\n        for u in graph[v]:\n            if dist[u] >= 0:\n                continue\n            dist[u] = dist[v] + 1\n            par[u] = v\n            que.append(u)\n    for i in range(1, n + 1):\n        if i == start:\n            continue\n        if dist[i] == -1:\n            continue\n        if start in graph[i]:\n            if res[0] > dist[i] + 1:\n                res = (dist[i] + 1, i)\n    if res[0] == infi:\n        return -1, []\n    cycle_num = res[0]\n    v = res[1]\n    CYCLE = deque([])\n    while v > 0:\n        CYCLE.appendleft(v)\n        v = par[v]\n\n    return cycle_num, CYCLE\n\n\njisho = {}\nans = (-1, [])\ncycle_num = infi\nkouho_v = -1\nfor i in range(1, n + 1):\n    temp_num, temp_cycle = bfs(i)\n    if temp_num == -1:\n        continue\n    if cycle_num > temp_num:\n        cycle_num = min(cycle_num, temp_num)\n        kouho_v = i\n        jisho[i] = temp_cycle\n\nif kouho_v == -1:\n    print(-1)\n    return\nelse:\n    ans_num = cycle_num\n    ans_list = jisho[kouho_v]\n    print(cycle_num)\n    print(*ans_list, sep=\"\\n\")\n", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\n\nes = [[] for _ in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n\nfrom collections import deque\n\nmindist = N\nans = None\nfor g in range(N):\n    for s in es[g]:\n        q = deque([s])\n        dist = [N]*N\n        dist[s] = 0\n        prev = [-1]*N\n        while q:\n            v = q.popleft()\n            if v==g:\n                break\n            for to in es[v]:\n                if dist[to] <= dist[v] + 1: continue\n                dist[to] = dist[v] + 1\n                prev[to] = v\n                q.append(to)\n        else:\n            continue\n        if dist[g] >= mindist: continue\n        mindist = dist[g]\n        v = g\n        tmp = [v+1]\n        while prev[v] >= 0:\n            v = prev[v]\n            tmp.append(v+1)\n        ans = tmp\n\nif ans:\n    print(len(ans))\n    print(*ans, sep='\\n')\nelse:\n    print(-1)", "import sys\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\n\nR = {}\nfor a, b in AB:\n  if a in R:\n    R[a].append(b)\n  else:\n    R[a] = [b]\n\ndef nasu(x, e):\n  D[x] = 1\n  if x not in R:\n    return []\n  for i in R[x]:\n    if i == e:\n      return [i]\n    if D[i] == 0:\n      t = nasu(i, e)\n      if t != []:\n        return [i] + t\n  return []\n\nfor i in range(1, N + 1):\n  D = [0] * (N + 1)\n  L = nasu(i, i)\n  if L != []:\n    break\nelse:\n  print(-1)\n  return\n\nD = [0] * (N + 1)\nfor i in L:\n  D[i] = 1\n\nLEN = len(L)\nL = L + L\n\ni = 0\nwhile i < LEN:\n  for j in range(i + LEN - 1, i, -1):\n    if D[L[j]] != 0 and L[j] in R[L[i]]:\n      for k in range(j - 1, i, -1):\n        D[L[k]] = 0\n      i = j\n      break\n\nA = []\nfor i in range(LEN):\n  if D[L[i]] == 1:\n    A.append(L[i])\n\nprint(len(A))\nfor i in A:\n  print(i)", "from collections import deque\n\nN, M = map(int, input().split())\nedge = [[] for _ in range(N)]\nfor _ in range(M):\n    A,B = map(int, input().split())\n    edge[A - 1].append(B - 1)\n\nans = []\nfor sta in range(N):\n    prev = [-1] * N\n    que = deque([sta])\n\n    while que:\n        v = que.popleft()\n        for w in edge[v]:\n            if w == sta:\n                path = []\n                while v != -1:\n                    path.append(v+1)\n                    v = prev[v]\n                if (not ans) or (len(ans) > len(path)):\n                    ans = path\n                break\n\n            if prev[w] != -1: continue\n\n            prev[w] = v\n            que.append(w)\n\nif ans:\n    print(len(ans))\n    print(*ans, sep='\\n')\nelse:\n    print(-1)\n", "from collections import deque\nN,M=map(int,input().split())\nG=[[] for i in range(N)]\nfor i in range(M):\n\ta,b=map(int,input().split())\n\tG[a-1].append(b-1)\ndeg=[0 for i in range(N)]\nfor i in range(N):\n\tfor p in G[i]:\n\t\tdeg[p]+=1\nq=deque(i for i in range(N) if deg[i]==0)\nres=[]\nwhile q:\n\tu=q.popleft()\n\tres.append(u)\n\tfor v in G[u]:\n\t\tdeg[v]-=1\n\t\tif deg[v]==0:\n\t\t\tq.append(v)\nif len(res)==N:\n\tprint(-1)\n\treturn\nX={i for i in range(N)}\nfor st in range(N):\n\tpre=[-1 for i in range(N)]\n\tq=deque([st])\n\tflag=0\n\twhile(q):\n\t\tr=q.popleft()\n\t\tfor p in G[r]:\n\t\t\tif pre[p]==-1:\n\t\t\t\tpre[p]=r\n\t\t\t\tq.append(p)\n\t\t\tif pre[st]!=-1:\n\t\t\t\tY={st}\n\t\t\t\ttmp=pre[st]\n\t\t\t\twhile(tmp!=st):\n\t\t\t\t\tY.add(tmp)\n\t\t\t\t\ttmp=pre[tmp]\n\t\t\t\tif len(Y)<len(X):\n\t\t\t\t\tX={i for i in Y}\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tbreak\nprint(len(X))\nfor i in X:\n\tprint(i+1)", "N,M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n\nfrom collections import deque\n\nd = N+1\nflag = False\nfor i in range(N):\n    for v in E[i]:\n        q = deque()\n        q.append(v)\n        used = [N+1]*N\n        used[v] = 1\n        while q:\n            temp = q.popleft()\n            if used[temp] > d:\n                break\n            for u in E[temp]:\n                if u == i and d > used[temp]+1:\n                    d = used[temp]+1\n                    memo = [temp, u]\n                    q = deque()\n                    flag = True\n                    break\n                elif u == i:\n                    q = deque()\n                    break\n                if used[u] < N+1:\n                    continue\n                used[u] = used[temp]+1\n                q.append(u)\n\nimport heapq\nif flag:\n    h = []\n    dist = [N+1]*N\n    dist[memo[1]] = 0\n    for v in E[memo[1]]:\n        heapq.heappush(h, (1, v))\n    while True:\n        temp = heapq.heappop(h)\n        if dist[temp[1]] < N+1:\n            continue\n        dist[temp[1]] = temp[0]\n        if temp[1] == memo[0]:\n            break\n        for v in E[temp[1]]:\n            if dist[v] < N+1:\n                continue\n            heapq.heappush(h, (temp[0]+1, v))\n    ans = [memo[0]]\n    d = dist[memo[0]]-1\n    prev = memo[0]\n    while d >= 0:\n        for i in range(N):\n            if dist[i] == d and prev in E[i]:\n                prev = i\n                ans.append(i)\n                d -= 1\n                break\n    print(len(ans))\n    for i in ans:\n        print(i+1)\nelse:\n    print(-1)", "from collections import deque\n\nN, M = map(int, input().split())\n\nedges = [[] for _ in range(N)]\n\nfor _ in range(M):\n    fr, to = map(int, input().split())\n    fr -= 1\n    to -= 1\n    edges[fr].append(to)\n\nfor start in range(N):\n    st = deque([(start, True)])\n    L = deque()\n    V = set()\n\n    while st:\n        now, isFirst = st.pop()\n        if isFirst:\n            L.append(now)\n\n            if now in V:\n                break\n\n            V.add(now)\n\n            st.append((now, False))\n\n            for to in edges[now]:\n                st.append((to, True))\n        else:\n            L.pop()\n            V.remove(now)\n    else:\n        continue\n\n    print(0)\n    print()\n    return\n\n    loopStart = L[-1]\n    while L[0] != loopStart:\n        L.popleft()\n\n    print(len(L) - 1)\n    ans = [v + 1 for v in L]\n    print(*ans[: -1], sep='\\n')\n    return\n\nprint(-1)", "def f_pure():\n    # \u53c2\u8003: http://drken1215.hatenablog.com/entry/2019/09/29/012000\n    from collections import deque\n    N, M = [int(i) for i in input().split()]\n\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(i) for i in input().split()]\n        graph[a - 1].append(b - 1)\n\n    shortest = N + 1\n    ans = []\n    for s in range(N):\n        # \u9802\u70b9s\u304b\u3089\u4ed6\u306e\u8fba\u3078\u884c\u304f\u306b\u306f\u4f55\u500b\u306e\u9802\u70b9\u3092\u8fbf\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u8a08\u7b97\u3059\u308b\n        dist = [-1] * N\n        previous = [-1] * N  # [n]: \u9802\u70b9n\u3078\u306f\u3069\u3053\u304b\u3089\u6765\u305f\u304b\n        queue = deque([s])\n        dist[s] = 0\n        while queue:\n            v = queue.pop()\n            for next_node in graph[v]:\n                if dist[next_node] == -1:\n                    dist[next_node] = dist[v] + 1\n                    previous[next_node] = v\n                    queue.appendleft(next_node)\n\n        for t in range(N):\n            if t == s or dist[t] == -1:\n                continue  # \u9802\u70b9t\u306f\u59cb\u70b9\u3068\u540c\u3058\u3001\u307e\u305f\u306f\u3001\u59cb\u70b9\u304b\u3089\u5230\u9054\u4e0d\u53ef\u80fd\n            for next_node in graph[t]:\n                if next_node == s:  # \u30eb\u30fc\u30d7\u5b8c\u6210\n                    ans_tmp = [s]  # \u89e3\u306b\u306a\u308a\u3046\u308b\u9802\u70b9\u96c6\u5408\n                    current_node = t\n                    # \u9802\u70b9t\u304b\u3089s\u307e\u3067\u5dfb\u304d\u623b\u3057\u3066\u3044\u304f\n                    while current_node != s:\n                        ans_tmp.append(current_node)\n                        current_node = previous[current_node]\n                    # \u9802\u70b9\u96c6\u5408\u306e\u6fc3\u5ea6\u304c\u6e1b\u5c11\u3057\u305f\n                    if shortest > len(ans_tmp):\n                        shortest = len(ans_tmp)\n                        ans = ans_tmp\n\n    if shortest == N + 1:\n        return -1  # \u9589\u8def\u304c\u306a\u304b\u3063\u305f\u3002\u6761\u4ef6\u3092\u6e80\u305f\u3059\u9802\u70b9\u96c6\u5408\u306f\u306a\u3044\n    return ' '.join(map(str, [len(ans)] + sorted(v + 1 for v in ans)))\n\nprint(f_pure())", "from collections import deque\n\nN, M = map(int, input().split())\n\nedges = [[] for _ in range(N)]\nedgesR = [[] for _ in range(N)]\n\nfor _ in range(M):\n    fr, to = map(int, input().split())\n    fr -= 1\n    to -= 1\n    edges[fr].append(to)\n    edgesR[to].append(fr)\n\nfor start in range(N):\n    st = deque([(start, True)])\n    L = deque()\n    V = set()\n\n    while st:\n        now, isFirst = st.pop()\n        if isFirst:\n            L.append(now)\n\n            if now in V:\n                break\n\n            V.add(now)\n\n            st.append((now, False))\n\n            for to in edges[now]:\n                st.append((to, True))\n        else:\n            L.pop()\n            V.remove(now)\n    else:\n        continue\n\n    loopStart = L.pop()\n    while L[0] != loopStart:\n        L.popleft()\n    V = set(L)\n    dist = [float('inf')] * N\n    que = deque([(loopStart, 0)])\n\n    while que:\n        now, d = que.popleft()\n\n        if dist[now] <= d:\n            if now == loopStart:\n                dist[loopStart] = d\n                break\n            continue\n        dist[now] = d\n\n        for to in edges[now]:\n            if to in V:\n                que.append((to, d + 1))\n\n    ans = [loopStart]\n    now = loopStart\n    while dist[now] > 1:\n        for back in edgesR[now]:\n            if dist[now] - 1 == dist[back]:\n                ans.append(back)\n                now = back\n                break\n\n    ans = set([a + 1 for a in ans])\n    print(len(ans))\n    print(*ans, sep='\\n')\n    return\n\nprint(-1)", "import sys\nsys.setrecursionlimit(10**7)\nn,m=list(map(int,input().split()))\ng=[[] for _ in range(n)]\nfor _ in range(m):\n  u,v=list(map(int,input().split()))\n  u,v=u-1,v-1\n  g[u].append(v)\nmi=set(range(n))\nflg=False\ndef func(path):\n  chk=set(path)\n  if len(path)!=2:\n    for i,v in enumerate(path):\n      nvs=[nv for nv in g[v] if nv in chk]\n      if len(nvs)==1:continue\n      for nv in nvs:\n        if nv==path[(i+1)%len(path)]:continue\n        ary=[nv]\n        for j,vj in enumerate(path):\n          if vj==nv:break\n        if i>j:\n          ary=path[j:i+1]\n        else:\n          ary=path[:i+1]+path[j:]\n        #print(path,ary,i,j)\n        func(ary)\n  print((len(path)))\n  for v in path:\n    print((v+1))\n  return\n\ndef dfs(v,seen):\n  mi.discard(v)\n  for nv in g[v]:\n    if seen[nv]!=-1:# \u5de1\u56de\u9589\u8def\n      seen[nv]=v\n      path=[v]\n      chk={v}\n      while seen[v] not in chk:\n        v=seen[v]\n        path.append(v)\n        chk.add(v)\n      path.reverse()\n      func(path)\n    else:\n      seen[nv]=v\n      dfs(nv,seen)\n      seen[nv]=-1\nwhile mi:\n  v=mi.pop()\n  seen=[-1]*n\n  dfs(v,seen)\nprint((-1))\nreturn\n", "import sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    N, M = list(map(int, input().split()))\n    V = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        V[a - 1].append(b - 1)\n    C = [0] * N\n    def dfs(n):\n        if C[n] == 2:\n            return False\n        if C[n] == 1:\n            return True\n        C[n] = 1\n        for i in V[n]:\n            if dfs(i):\n                return True\n        C[n] = 2\n        return False\n    for i in range(N):\n        if dfs(i):\n            return 0\n    return -1\nprint((main()))\n", "import sys\nsys.setrecursionlimit(10000000)\ndef input():\n    return sys.stdin.readline()[:-1]\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nimport itertools\nimport math\nINF = 10**9\nMOD = 10**9+7\n\nN, M = map(int, input().split())\nes = [[] for i in range(N+1)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    es[a].append(b)\nansr, ansd = -1, INF\nfor r in range(1, N+1):\n    d = [INF] * (N+1)\n    d[0] = 0\n    dq = deque()\n    for w in es[r]:\n        dq.append(w)\n        d[w] = 1\n    while len(dq) > 0:\n        v = dq.popleft()\n        if v == r:\n            break\n        nd = d[v]+1\n        for u in es[v]:\n            if nd < d[u]:\n                d[u] = nd\n                dq.append(u)\n    if d[r] < ansd:\n        ansd = d[r]\n        ansr = r\nif ansr == -1:\n    print(-1)\nelse:\n    vis = [0] * (N+1)\n    vis[0] = 1\n    p = [-1] * (N+1)\n    dq = deque()\n    for v in es[ansr]:\n        vis[v] = 1\n        p[v] = 0\n        dq.append(v)\n    while len(dq) > 0:\n        v = dq.popleft()\n        if v == ansr:\n            break\n        for u in es[v]:\n            if vis[u] == 0:\n                vis[u] = 1\n                p[u] = v\n                dq.append(u)\n    lst = []\n    v = ansr\n    while p[v] != -1:\n        lst.append(v)\n        v = p[v]\n    print(len(lst))\n    print(*lst, sep = '\\n')\n", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nfrom collections import deque\n\ndef shorten_cycle(G, route):\n    # \u30eb\u30fc\u30d7\u3060\u3068\u3059\u3067\u306b\u5206\u304b\u3063\u3066\u308b\u30eb\u30fc\u30c8\u306b\u5bfe\u3057\u3066\u3001\n    # \u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u304c\u5b58\u5728\u3059\u308b\u5834\u5408\u306f\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3092\u884c\u3044\u3001\n    # \u30eb\u30fc\u30c8\u3092\u77ed\u304f\u3059\u308b\n\n    _next = {k: v for k, v in zip(route, route[1:]+route[:1])}\n    v = route[0]\n    while True:\n        # \u3082\u3057v\u304b\u3089route\u5185\u306e\u3001\u6b21\u306e\u70b9\u3067\u306f\u306a\u3044\u70b9n\u306b\u3044\u3051\u308b\u5834\u5408\n        for n in G[v]:\n            # v -> x -> y -> n \u3068\u3057\u3066\u3044\u305f\u3068\u3053\u308d\u3092\u3001\n            # v -> n \u3068\u3059\u308b\n            if n in route and n != _next[v]:\n                new_route = [n]\n                s = n\n                while s != v:\n                    s = _next[s]\n                    new_route.append(s)\n                _next[v] = n\n                # \u7121\u99c4\u306a\u90e8\u5206\u3092\u524a\u9664\u3057\u305f\u65b0\u3057\u3044\u7d4c\u8def\u306b\u5bfe\u3057\u3066\u3001\u8abf\u67fb\u3092\u6700\u521d\u304b\u3089\u3084\u308a\u76f4\u3059\n                route = new_route\n                v = route[0]\n                break\n        # \u70b9v\u306b\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u304c\u306a\u3044\u5834\u5408\n        else:\n            # \u6b21\u306e\u70b9\u304c\u6700\u521d\u306e\u70b9\u306e\u5834\u5408\u306f\u3001\u3082\u3046\u3053\u308c\u4ee5\u4e0a\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u306a\u3044\u306e\u3067\u7d42\u308f\u308a\n            v = _next[v]\n            if v == route[0]:\n                break\n    \n    return route\n\ndef find_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n\n    ans_last = None # s\u304b\u3089\u30eb\u30fc\u30d7\u3092\u63a2\u3057\u3066\u898b\u3064\u304b\u3063\u305f\u6642\u306e\u3001\u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u756a\u53f7\n    dq.append(s)\n    # BFS\u3067\u30eb\u30fc\u30d7\u3092\u898b\u3064\u3051\u308b\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            # \u9802\u70b9v\u304b\u3089\u3044\u3051\u308b\u9802\u70b9\u306e\u4e2d\u306b\u958b\u59cb\u70b9\u304c\u3042\u3063\u305f\u3089\u3001\u30eb\u30fc\u30d7\u3067\u3042\u308b\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            # \u307e\u3060\u63a2\u7d22\u3057\u3066\u3044\u306a\u3044\u9802\u70b9\u306a\u3089\u6b21\u306e\u63a2\u7d22\u5019\u88dc\u306b\u3059\u308b\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n\n    # \u30eb\u30fc\u30d7\u304c\u898b\u3064\u304b\u3063\u305f\u5834\u5408\n    if ans_last:\n        # \u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u304b\u3089\u3001\u5143\u306e\u9802\u70b9\u3092\u305f\u3069\u308a\u3001\u305d\u306e\u30eb\u30fc\u30c8\u3092\u9006\u306b\u3059\u308b\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    \n    # \u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u5834\u5408\u306fNone\u3092\u8fd4\u3059\n    return None\n\ndef main():\n    N, M, *A = map(int, read().split())\n\n    G = [[] for i in range(N+1)]\n    for a, b in zip(A[::2], A[1::2]):\n        G[a].append(b)\n\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3067\u3042\u308b\u3088\u3046\u306a G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\n    # [\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u306e\u30b0\u30e9\u30d5] -> \u30eb\u30fc\u30d7\n\n    # \u6709\u5411\u30b0\u30e9\u30d5 G=(V,E) \u306b\u5bfe\u3057\u3001\u6b21\u306e\u3088\u3046\u306a\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6709\u5411\u30b0\u30e9\u30d5 G\u2032=(V\u2032,E\u2032) \u3092 G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\u3068\u547c\u3076\u3002\n    # V\u2032 \u306f V \u306e (\u7a7a\u3067\u306a\u3044) \u90e8\u5206\u96c6\u5408\u3067\u3042\u308b\u3002\n    # E\u2032 \u306f\u3001E \u306e\u8fba\u3067\u3042\u3063\u3066\u4e21\u7aef\u70b9\u304c\u3068\u3082\u306b V\u2032 \u306b\u542b\u307e\u308c\u308b\u3082\u306e\u3059\u3079\u3066\u3092\u542b\u3080\u96c6\u5408\u3067\u3042\u308b\u3002\n\n    # -> \u30eb\u30fc\u30d7\u3067\u3082\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u308b\u3088\u3046\u306a\u30eb\u30fc\u30d7\u306f\u3060\u3081\n\n    # \u4f8b: 1 -> 2 -> 3 -> 4 -> 5\n    #     ^    |         ^    |\n    #     |    ----------|    |\n    #     ---------------------\n    # V' = {1, 2, 3, 4, 5} \u3068\u3057\u3066\u3057\u307e\u3046\u3068\u3001\n    # E' = {(1->2), (2->3), (3->4), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u3063\u3066\u3057\u307e\u3044\u3001\u3053\u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5G'=(V', E')\u306b\u304a\u3044\u3066\u3001\n    # \u9802\u70b92\u306e\u51fa\u6b21\u6570\u304c2\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u3002\uff08\u9802\u70b94\u306e\u5165\u6b21\u6570\u30822\u306b\u306a\u3063\u3066\u3057\u307e\u3046\uff09\n    # V' = {1, 2, 4, 5} \u3068\u3059\u308c\u3070\u3001\n    # E' = {(1->2), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u308a\u3001\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3068\u306a\u308b\n    \n    # \u3064\u307e\u308a\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u306a\u3044\u6700\u77ed\u306e\u30eb\u30fc\u30d7\u30921\u3064\u3067\u3082\u898b\u3064\u3051\u308c\u3070\u3088\u3044\n    \n    min_route = None\n    for s in range(1, N+1):\n        # \u5404\u9802\u70b9\u3092\u958b\u59cb\u70b9\u306b\u3057\u3066\u30eb\u30fc\u30d7\u3092\u63a2\u3059\n        route = find_cycle(G, s)\n        # \u30eb\u30fc\u30d7\u304c\u898b\u3064\u304b\u3063\u305f\u5834\u5408\u3001\u305d\u3053\u304b\u3089\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u308b\u7d4c\u8def\u3092\u63a2\u3057\u3066\u7d42\u4e86\n        if route:\n            min_route = shorten_cycle(G, route)\n            break\n    \n    if min_route:\n        print(len(min_route), *min_route, sep='\\n')\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    edges[a-1].append(b-1)\n\n\ndef get_first_cycle(n, edges):\n    seen = [-1] * n  # seen: -1: \u672a\u78ba\u8a8d, 0: \u975ecycle\u306enode, 1: cycle\u5019\u88dc\n    for start in range(n):\n        if seen[start] == 0:\n            continue\n        seen[start] = 1\n        path = [start]\n        while path:\n            now = path[-1]\n            if not edges[now]:\n                path.pop()\n                seen[now] = 0\n                continue\n\n            next_node = edges[now].pop()\n            if seen[next_node] == -1:\n                path.append(next_node)\n                seen[next_node] = 1\n\n            elif seen[next_node] == 1:\n                idx = path.index(next_node)\n                cycle = path[idx:]\n                return cycle\n    return False\n\n\ncycle = get_first_cycle(n, edges)\nif not cycle:\n    print((-1))\n    return\n\nnodes = set(cycle)\nlength = len(cycle)\ni = 0\nwhile i < length:\n    now = cycle[i]\n    routes = edges[now]\n    while routes:\n        to = routes.pop()\n        if to in nodes:\n            update = True\n            idx = cycle.index(to)\n            cycle = cycle[:i+1] + cycle[idx:]\n            nodes = set(cycle)\n            length = len(cycle)\n            break\n    i += 1\n\nprint((len(cycle)))\nfor node in cycle:\n    print((node+1))\n", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *AB = list(map(int, read().split()))\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n\n    ans = []\n    for i in range(N):\n        queue = deque([i])\n        dist = [-1] * N\n        dist[i] = 0\n        prev = [-1] * N\n        while queue:\n            v = queue.popleft()\n            for nv in G[v]:\n                if dist[nv] == -1:\n                    dist[nv] = dist[v] + 1\n                    prev[nv] = v\n                    queue.append(nv)\n        for j in range(N):\n            if i == j or dist[j] == -1 or i not in G[j]:\n                continue\n            tmp = []\n            k = j\n            while k != -1:\n                tmp.append(k)\n                k = prev[k]\n\n            if not ans or len(ans) > len(tmp):\n                ans = tmp\n\n    if ans:\n        print((len(ans)))\n        for v in ans:\n            print((v + 1))\n    else:\n        print((-1))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\nes = [[] for i in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n\nfrom collections import deque\nmindist = N\nopt = None\nfor g,tos in enumerate(es):\n    for s in tos:\n        q = deque([(s,0)])\n        prev = [-1]*N\n        dist = [N]*N\n        dist[s] = 0\n        while q:\n            v,d = q.popleft()\n            for to in es[v]:\n                if to==g: break\n                if d+1 >= dist[to]: continue\n                dist[to] = d+1\n                prev[to] = v\n                q.append((to,d+1))\n            else:\n                continue\n            break\n        else:\n            continue\n        if d+1 >= mindist: continue\n        mindist = d+1\n        opt = [g,v]\n        while prev[opt[-1]] >= 0:\n            opt.append(prev[opt[-1]])\nif opt:\n    ans = [o+1 for o in opt]\n    print(len(ans))\n    print(*ans, sep='\\n')\nelse:\n    print(-1)", "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\nimport numpy as np\nfrom collections import defaultdict\n\nN,M = map(int,readline().split())\n\nif M == 0:\n    print(-1)\n    return\n\nAB = [tuple(int(x) for x in line.split()) for line in readlines()]\n\nA,B = zip(*AB)\ngraph = csr_matrix(([1]*M,(A,B)),(N+1,N+1))\n_,comp = connected_components(graph,connection='strong')\n\nsize = np.bincount(comp)\n\nif size.max() == 1:\n    print(-1)\n    return\n\nn = np.where(size > 1)[0][0]\n\nV = set(np.where(comp == n)[0])\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    if a in V and b in V:\n        graph[a].append(b)\n\n# \u3068\u308a\u3042\u3048\u305a1\u3064\u30b5\u30a4\u30af\u30eb\u3092\u898b\u3064\u3051\u308b\norder = defaultdict(int)\nx = V.pop()\nV.add(x)\nq = [x]\norder[x] = 1\npath = [x]\nflag = False\nwhile True:\n    y = graph[x][0]\n    if order[y] != 0:\n        path = path[order[y]-1:]\n        break\n    path.append(y)\n    order[y] = order[x] + 1\n    x = y\n\nV = set(path)\nnext_v = {u:v for u,v in zip(path,path[1:])}; next_v[path[-1]] = path[0]\n\n# \u8fba\u30921\u3064\u8ffd\u52a0\u3057\u306a\u304c\u3089\u3001\u5c0f\u3055\u3044\u30b5\u30a4\u30af\u30eb\u3092\u898b\u3064\u3051\u308b\nfor a,b in AB:\n    if not (a in V and b in V):\n        continue\n    # \u9593\u306e\u9802\u70b9\u3092\u524a\u9664\n    x = next_v[a]\n    while x != b:\n        V.remove(x)\n        x = next_v[x]\n    next_v[a] = b\n\nprint(len(V))\nprint(*V,sep='\\n')\n\n", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\n\ncompo = []\ncs = []\nN = 0\nM = 0\nA = None\nB = None\nE = None\n\ndef main():\n    nonlocal compo,cs,N,M,A,B,E\n    N, M = rip()\n    A = [0] * M\n    B = [0] * M\n    for i in range(M):\n        A[i], B[i] = rip()\n        A[i] -= 1\n        B[i] -= 1\n    \n    E = [[] for i in range(N)]\n    for i in range(M):\n        E[A[i]].append(B[i])\n    \n    compo = [-1] * N\n\n    def dfs(cmp, route, hs):\n        nonlocal compo,cs,N,M,A,B,E\n        if(len(cs) > 0) : return\n        now = route[len(route) - 1]\n        for nxt in E[now]:\n            if compo[nxt] == -1:\n                compo[nxt] = cmp\n                route.append(nxt)\n                hs.add(nxt)\n                dfs(cmp, route, hs)\n                hs.remove(nxt)\n                route.pop(-1)\n            elif compo[nxt] == cmp:\n                if nxt in hs:\n                    cs = route[route.index(nxt):]\n                return\n            else:\n                return\n\n\n    cs = []\n    c = 0\n    for i in range(N):\n        if(compo[i] != -1): continue\n        c += 1\n        a = []\n        hs = set()\n        a.append(i)\n        hs.add(i)\n        compo[i] = c\n        dfs(c, a, hs)\n\n    if len(cs) == 0:\n        print((-1))\n        return\n    \n    l = cs\n    while(True):\n        di = dict()\n        for i in range(len(l)):\n            di[l[i]] = l[(i + 1) % len(l)]\n        edx = -1\n        for i in range(M):\n            if A[i] in di and B[i] in di:\n                if di[A[i]] != B[i]:\n                    edx = i\n                    break\n        \n        if edx == -1:\n            print((len(l)))\n            print((\"\\n\".join([str(n + 1) for n in l])))\n            return\n        \n        di[A[edx]] = B[edx]\n        nl = [A[edx], B[edx]]\n        while True:\n            nxt = di[nl[-1]]\n            if nxt != nl[0]:\n                nl.append(nxt)\n            else:\n                break\n        l = nl\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n,m=map(int,input().split())\n    ab=[list(map(int,input().split())) for _ in [0]*m]\n    g=[set() for _ in [0]*n]\n    g2=[set() for _ in [0]*n]\n    [g[a-1].add(b-1) for a,b in ab]\n    [g2[b-1].add(a-1) for a,b in ab]\n\n    def bfs(start,graph):\n        temp=[[start,{start}]]\n        while temp:\n            temp2=[]\n            for j,k in temp:\n                for i in graph[j]:\n                    if i in k:\n                        return j,k\n                    else:\n                        temp2.append([i,k|{i}])\n            temp=temp2\n        return None,None\n\n    return_set_pre=set(range(n))\n    for i in range(n):\n        now,return_set=bfs(i,g)\n        if return_set!=None:\n            break\n    if return_set==None:\n        print(-1)\n        return 0\n    while True:\n        for i in return_set_pre-return_set:\n            g[i]={}\n            g2[i]={}\n        for i in return_set:\n            g[i]=g[i]&return_set\n            g2[i]=g2[i]&return_set\n        l1=len([1 for i in range(n) if len(g[i])==1])\n        l2=len([1 for i in range(n) if len(g2[i])==1])\n        l=len(return_set)\n        if l==l1 and l==l2:\n            break\n        return_set_pre=return_set\n        now,return_set=bfs(now,g2)\n        for i in return_set_pre-return_set:\n            g[i]={}\n            g2[i]={}\n        for i in return_set:\n            g[i]=g[i]&return_set\n            g2[i]=g2[i]&return_set\n        l1=len([1 for i in range(n) if len(g[i])==1])\n        l2=len([1 for i in range(n) if len(g2[i])==1])\n        l=len(return_set)\n        if l==l1 and l==l2:\n            break\n        return_set_pre=return_set\n        now,return_set=bfs(now,g)\n    print(len(return_set))\n    for i in return_set:\n        print(i+1)\nmain()", "import sys\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    graph[a-1].append(b-1)\n\nL = 10**14\nnum = -1\nfor n in range(N):\n    q = [n]\n    checked = [False]*N\n    checked[n] = True\n    before = [None]*N\n    c = 0\n    ok = False\n    while q:\n        c += 1\n        qq = []\n        for p in q:\n            for np in graph[p]:\n                if not checked[np]:\n                    before[np] = p\n                    qq.append(np)\n                    checked[np] = True\n                elif np == n:\n                    before[np] = p\n                    ok = True\n                    break\n        if ok: break\n        q = qq\n    \n    if ok and c < L:\n        L = c\n        num = n\n        ans = []\n        k = n\n        for _ in range(c):\n            k = before[k]\n            ans.append(k+1)\n\nif num == -1:\n    print((-1))\nelse:\n    print((len(ans)))\n    for a in reversed(ans):\n        print(a)    \n", "import collections\n\nn,m=map(int,input().split())\ng=[[] for _ in range(n+1)]\ncand1=set()\ncand2=set()\nfor _ in range(m):\n  a,b=map(int,input().split())\n  g[a].append(b)\n  cand1.add(a)\n  cand2.add(b)\ncand=cand1&cand2\nans=-1\nfor i in range(1,n+1):\n  if i not in cand:\n    continue\n  else:\n    q=collections.deque()\n    q.append((i,[i]))\n    checked=[0]*(n+1)\n    while len(q)!=0:\n      v,chain=q.popleft()\n      if v==i and len(chain)!=1:\n        ans=chain[:-1]\n      for u in g[v]:\n        if u not in cand:\n          continue\n        elif checked[u]==0:\n          checked[u]=1\n          q.append((u,chain+[u]))\n    cand.discard(i)\nif ans==-1:\n  print(ans)\nelse:\n  print(len(ans))\n  for v in ans:\n    print(v)", "from collections import*\nn,m,*t=map(int,open(0).read().split())\ni,o=[0]*n,[[]for _ in range(n)]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq=deque(v for v in range(n)if i[v]<1)\nr=[]\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint(-(len(r)==n))", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 20 20:47:47 2019\n\n@author: Owner\n\"\"\"\n\nimport numpy as np\nimport sys\nimport collections\nimport scipy.misc\nimport math\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\nimport heapq\n\n#\u7d20\u56e0\u6570\u3092\u4e26\u3079\u308b\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n /= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# \u6841\u6570\u3092\u5410\u304f\ndef digit(i):\n    if i > 0:\n        return digit(i//10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    \u6982\u8981: \u30ea\u30b9\u30c8\u304b\u3089\u3042\u308b\u5024\u306b\u6700\u3082\u8fd1\u3044\u5024\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\n    @param list: \u30c7\u30fc\u30bf\u914d\u5217\n    @param num: \u5bfe\u8c61\u5024\n    @return \u5bfe\u8c61\u5024\u306b\u6700\u3082\u8fd1\u3044\u5024\n    \"\"\"\n\n    # \u30ea\u30b9\u30c8\u8981\u7d20\u3068\u5bfe\u8c61\u5024\u306e\u5dee\u5206\u3092\u8a08\u7b97\u3057\u6700\u5c0f\u5024\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u53d6\u5f97\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\nclass UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u63a2\u7d22\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        \"\"\"\n        x \u3068 y \u306e\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n\n    def is_same(self, x, y):\n        \"\"\"\n        x \u3068 y \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5426\u304b\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n    \n\n\"\"\"\nN, X = map(int, input().split())\n\nx = list(map(int, input().split()))\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n# \u591a\u6b21\u5143\u914d\u5217\u306e\u5ba3\u8a00\uff08\u3042\u3068\u3067int\u306b\u3059\u308b\u3053\u3068\u3002\uff09\uff08\u30bf\u30d7\u30eb\u306b\u3059\u308b\u3053\u3068\u3002\uff09\ndp = np.zeros((N+1, 4,4,4))\n    \nall(nstr.count(c) for c in '753')\n\n# \u8907\u6570\u914d\u5217\u3092\u4e26\u3073\u66ff\u3048\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetter\u306b\u306f\u4f55\u756a\u76ee\u306e\u914d\u5217\u3092\u30ad\u30fc\u306b\u3057\u305f\u3044\u304b\u6e21\u3057\u307e\u3059\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2\u9032\u6570\u306ebit\u5224\u5b9a\n(x >> i) & 1\n\n# dp\u6700\u5c0f\u5316\u554f\u984c\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n# \u7d2f\u7a4d\u548c\nadd = 1 # \u554f\u984c\u306b\u3088\u3063\u3066\u6c7a\u307e\u308b\nres = 0\nsums = [0]*(len(nums)+1)\nfor i in range(len(nums)):\n    sums[i+1] = sums[i] + nums[i]\nfor i in range(0, len(nums), 2):\n    left = i\n    right = min(i+add, len(nums))\n    tmp = sums[right] - sums[left]\n    res = max(tmp, res)\n\n#\uff12\u5206\u63a2\u7d22\nli, ri = bisect.bisect_left(p_ac, l[i]-1), bisect.bisect_right(p_ac, r[i]-1)    \n\n#\u30bd\u30fc\u30c8\u95a2\u6570\norg_list = [3, 1, 4, 5, 2]\nnew_list = sorted(org_list)\nprint(org_list)\nprint(new_list)\n# [3, 1, 4, 5, 2]\n# [1, 2, 3, 4, 5]\n\n#Distance Transformation\n    for h in range(0,H):\n        for w in range(0,W):\n            if h == 0 and w == 0:\n                pass\n            elif h == 0:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h-1][W-w]+1)\n            elif w == 0:   \n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1)\n            else:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1, D[H-h-1][W-w]+1, D[H-h][W-w]+2)\n            d_max = max(D[H-h-1][W-w-1], d_max)\n\n\"\"\"\n\n\n\ndef bfs(n):\n    clsd = set()\n    opnd = collections.deque()        \n    root = [None]*N\n    d_list = [0]*N\n    opnd.append(n)\n    \n    #print(\"Let's BFS (\", n, \" times)\")\n    while len(opnd) != 0:\n\n        #print(\"clsd: \", clsd)\n        #print(\"opnd: \", opnd)\n        \n        now = opnd.popleft()\n        clsd.add(now)\n        \n        for e in E[now]:\n            if e in clsd:\n                if e == n:\n                    res = [now]\n                    #print(\"root: \", root)\n                    #print(\"d_list: \", d_list)\n                    dist = d_list[now] + 1\n                    while len(res) != dist:\n                        #   print(res, dist)\n                        res.append(root[res[-1]])\n                    return [list(reversed(res)), dist]\n                \n            else:\n                opnd.append(e)\n                root[e] = now\n                d_list[e] = d_list[root[e]]+1\n    return [[], inf] \n\n\nN, M = list(map(int, input().split()))\n\nE = [[] for n in range(N)]\n\n \nfor m in range(M):\n    e = list(map(int, input().split()))\n    E[e[0]-1].append(e[1]-1)\n\ninf = 10**9\n\n    \ndef main(): \n    res = []\n    d_min = inf\n    for n in range(N):\n        graph, dist = bfs(n)\n        if dist < d_min:\n            d_min = dist\n            res = graph\n    if d_min != inf:\n       print(d_min)\n       for n in range(d_min):\n           print((res[n]+1))\n    else:\n       print((-1))\n        \n                \n            \n            \n                \n\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import*\nn,m=map(int,input().split())\nouts=defaultdict(list)\nins=defaultdict(int)\nfor _ in range(m):\n    a,b=map(int,input().split())\n    outs[a-1]+=b-1,\n    ins[b-1]+=1\nq=deque(i for i in range(n)if ins[i]==0)\nres=[]\nwhile q:\n    v=q.popleft()\n    res+=v,\n    for w in outs[v]:\n        ins[w]-=1\n        if ins[w]==0:\n            q.append(w)\nprint(-(len(res)==n))", "import sys\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\n\nEIN=[0]*N\nEOUT=[0]*N\n\nEINLIST=[[] for i in range(N)]\nEOUTLIST=[[] for i in range(N)]\n\nfor i in range(M):\n    x,y=list(map(int,input().split()))\n    x-=1\n    y-=1\n\n    EOUT[x]+=1\n    EIN[y]+=1\n\n    EOUTLIST[x].append(y)\n    EINLIST[y].append(x)\n\nfrom collections import deque\n\nQ=deque()\nUSE=[1]*N\n\nfor i in range(N):\n    if EIN[i]==0 or EOUT[i]==0:\n        Q.append(i)\n        USE[i]=0\n\nwhile Q:\n    x=Q.pop()\n\n    for to in EOUTLIST[x]:\n        if USE[to]==0:\n            continue\n        EIN[to]-=1\n        if EIN[to]==0:\n            Q.append(to)\n            USE[to]=0\n\n    for fr in EINLIST[x]:\n        if USE[fr]==0:\n            continue\n        EOUT[fr]-=1\n        if EOUT[fr]==0:\n            Q.append(fr)\n            USE[fr]=0\n            \ndef loopfind():\n    for i in range(N):\n        if USE[i]==1:\n            break\n    else:\n        return []\n    \n    Q=deque()\n    Q.append(i)\n    USESET={i}\n    ANS=[i]\n\n    while True:\n        for to in EOUTLIST[ANS[-1]]:\n            if USE[to]==1:\n                nextv=to\n                break\n\n        if nextv in USESET:\n            break\n        else:\n            ANS.append(nextv)\n            USESET.add(nextv)\n\n    x=ANS.index(nextv)\n    return ANS[x:]\n        \n\ndef shortcut(ANS):\n    #print(ANS)\n\n    ANSSET=set(ANS)\n    LEN=len(ANS)\n    flag=0\n\n    for i in range(LEN):\n        for to in EOUTLIST[ANS[i]]:\n            if to in ANSSET and ANS[(i+1)%LEN]!=to:\n                flag=1\n                x=ANS.index(to)\n\n                #print(ANS,i,x)\n\n                break\n        if flag:\n            break\n    #print(flag)\n\n    if flag:\n        if x<i:\n            return shortcut(ANS[x:i+1])\n        else:\n            return shortcut(ANS[x:]+ANS[:i+1])\n\n    else:\n        return ANS\n\nANS=shortcut(loopfind())\nif len(ANS)==0:\n    print((-1))\nelse:\n    print((len(ANS)))\n    for ans in ANS:\n        print((ans+1))\n        \n", "import sys\nfrom collections import deque\ninput = sys.stdin.readline        \n\ndef main():\n\n    def loopfind():\n        for i in range(N):\n            if USE[i]==1:\n                break\n        else:\n            return []\n        \n        Q=deque()\n        Q.append(i)\n        USESET={i}\n        ANS=[i]\n\n        while True:\n            for to in EOUTLIST[ANS[-1]]:\n                if USE[to]==1:\n                    nextv=to\n                    break\n\n            if nextv in USESET:\n                break\n            else:\n                ANS.append(nextv)\n                USESET.add(nextv)\n\n        x=ANS.index(nextv)\n        return ANS[x:]\n\n    def shortcut(ANS):\n        #print(ANS)\n\n        ANSSET=set(ANS)\n        LEN=len(ANS)\n        flag=0\n\n        for i in range(LEN):\n            for to in EOUTLIST[ANS[i]]:\n                if to in ANSSET and ANS[(i+1)%LEN]!=to:\n                    flag=1\n                    x=ANS.index(to)\n\n                    #print(ANS,i,x)\n\n                    break\n            if flag:\n                break\n        #print(flag)\n\n        if flag:\n            if x<i:\n                return shortcut(ANS[x:i+1])\n            else:\n                return shortcut(ANS[x:]+ANS[:i+1])\n\n        else:\n            return ANS\n    \n    N,M=map(int,input().split())\n\n    EIN=[0]*N\n    EOUT=[0]*N\n\n    EINLIST=[[] for i in range(N)]\n    EOUTLIST=[[] for i in range(N)]\n\n    for i in range(M):\n        x,y=map(int,input().split())\n        x-=1\n        y-=1\n\n        EOUT[x]+=1\n        EIN[y]+=1\n\n        EOUTLIST[x].append(y)\n        EINLIST[y].append(x)\n\n    Q=deque()\n    USE=[1]*N\n\n    for i in range(N):\n        if EIN[i]==0 or EOUT[i]==0:\n            Q.append(i)\n            USE[i]=0\n\n    while Q:\n        x=Q.pop()\n\n        for to in EOUTLIST[x]:\n            if USE[to]==0:\n                continue\n            EIN[to]-=1\n            if EIN[to]==0:\n                Q.append(to)\n                USE[to]=0\n\n        for fr in EINLIST[x]:\n            if USE[fr]==0:\n                continue\n            EOUT[fr]-=1\n            if EOUT[fr]==0:\n                Q.append(fr)\n                USE[fr]=0\n\n    ANS=shortcut(loopfind())\n    if len(ANS)==0:\n        print(-1)\n    else:\n        print(len(ANS))\n        for ans in ANS:\n            print(ans+1)\n\nmain()", "#!/usr/bin/env python\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import deque\ninput = sys.stdin.buffer.readline\nINF = float(\"inf\")\n\ndef main():\n    N,M = map(int,input().split())\n    G = [[] for _ in range(N)]\n    AB = [tuple(map(int,input().split())) for _ in range(M)]\n    for a,b in AB:\n        G[a-1].append(b-1)\n\n    Ans = [1]*(N+1)\n    \n    # \u5168\u3066\u306e\u9802\u70b9\u304b\u3089, \u9589\u8def\u304c\u5b58\u5728\u3057\u306a\u3044\u304b\u3092\u78ba\u8a8d\u3059\u308b\n    for s in range(N):\n        prev = [-1]*N\n        dist = [-1]*N\n        dist[s] = 0\n        dq = deque([s])\n        while dq:\n            v = dq.popleft()\n            for nv in G[v]:\n                if dist[nv] == -1:\n                    dist[nv] = dist[v] + 1\n                    prev[nv] = v\n                    dq.append(nv)\n                # \u6b21\u304c 0\u756a\u76ee(\u958b\u59cb\u5730\u70b9) \u306a\u3089\u9589\u8def\u3042\u308a\n                if dist[nv] == 0:\n                    prev[nv] = v\n\n        # \u958b\u59cb\u5730\u70b9\u306e\u524d \u304c -1\u3067\u306a\u3044 => \u9589\u8def\u3042\u308a\n        if prev[s] != -1:\n            v = prev[s]\n            ans = set()\n            for _ in range(max(dist)+1):\n                ans.add(prev[v])\n                v = prev[v]\n            if len(Ans) > len(ans):\n                Ans = list(ans)\n    \n    if len(Ans) == N+1:\n        print(-1)\n    else:\n        print(len(Ans))\n        Ans.sort()\n        for v in Ans:\n            print(v+1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import queue\n\nimport sys\nsys.setrecursionlimit(10000)\n\nN, M = map(int, input().split())\nS = set(range(N))\n\nto = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = [int(x)-1 for x in input().split()]\n    to[a].append(b)\n\nvisit = [0] * N\ndef DFS(p, n):\n    if visit[p] != 0:\n        return visit[p]\n    else:\n        visit[p] = n + 1\n        for i in to[p]:\n            r = DFS(i, n + 1)\n            if r > 0:\n                return r\n        visit[p] = -1\n        return -1\n\nfor i in range(N):\n    r = DFS(i,0)\n    if r > 0:\n        for j in range(N):\n            if visit[j] < r:\n                S.discard(j)\n        for j in range(N):\n            if j in S:\n                for k in to[j]:\n                    if k in S:\n                        if visit[k] < visit[j]:\n                            for l in range(N):\n                                if visit[l] < visit[k] or visit[l] > visit[j]:\n                                    S.discard(l)\n                        else:\n                            for l in range(N):\n                                if visit[l] > visit[j] and visit[l] < visit[k]:\n                                    S.discard(l)\n        print(len(S))\n        for j in list(S):\n            print(j+1)\n        break\n    if i == N-1:\n        print(-1)", "from collections import deque\n\nN, M = map(int, input().split())\n\nedges = [[] for _ in range(N)]\n\nfor _ in range(M):\n    fr, to = map(int, input().split())\n    fr -= 1\n    to -= 1\n    edges[fr].append(to)\n\nfor start in range(N):\n    st = deque([(start, True)])\n    L = deque()\n    V = set()\n\n    while st:\n        now, isFirst = st.pop()\n        if isFirst:\n            L.append(now)\n\n            if now in V:\n                break\n\n            V.add(now)\n\n            st.append((now, False))\n\n            for to in edges[now]:\n                st.append((to, True))\n        else:\n            L.pop()\n            V.remove(now)\n    else:\n        continue\n\n    loopStart = L.pop()\n    while L[0] != loopStart:\n        L.popleft()\n\n    ans = []\n    K = len(L)\n    for i, now in enumerate(L):\n        for to in edges[now]:\n            if i + 1 >= K or to == L[i + 1]:\n                ans.append(now + 1)\n                break\n        else:\n            break\n    else:\n        print(0)\n        print()\n        # print(len(ans))\n        # print(*ans, sep='\\n')\n        return\n\nprint(-1)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nn, m = map(int, input().split())\nG = [[] for _ in range(n)]\nfor i in range(m):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  G[a].append(b)\nseen = [False]*n\ndef dfs(v):\n  seen[v] = True\n  for nv in G[v]:\n    nxt[v] = nv\n    if seen[nv]:\n      return nv\n    s = dfs(nv)\n    if s != -1:\n      return s\n  seen[v] = False\n  return -1\nfor i in range(n):\n  nxt = [-1]*n\n  s = dfs(i)\n  if s != -1:\n    break\nelse:\n  print(-1)\n  return\nwhile True:\n  used = set()\n  L = []\n  while s not in used:\n    used.add(s)\n    L.append(s)\n    s = nxt[s]\n  L.append(s)\n  for i in range(len(L)-1):\n    a, b = L[i], L[i+1]\n    for nv in G[a]:\n      if nv != b and nv in used:\n        nxt[a] = nv\n        s = a\n        break\n    else:\n      continue\n    break\n  else:\n    print(len(used))\n    for v in used:\n      print(v+1)\n    break", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *AB = list(map(int, read().split()))\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n\n    def dfs(v, p, seen, finished, hist):\n        seen[v] = True\n        hist.append(v)\n        for nv in G[v]:\n            if nv == p:\n                continue\n            if finished[nv]:\n                continue\n            if seen[nv] and not finished[nv]:\n                return nv\n\n            pos = dfs(nv, v, seen, finished, hist)\n            if pos != -1:\n                return pos\n        hist.pop()\n        finished[v] = True\n        return -1\n\n    for i in range(N):\n        seen = [False] * N\n        finished = [False] * N\n        hist = []\n        pos = dfs(i, -1, seen, finished, hist)\n        if pos != -1:\n            break\n\n    if pos == -1:\n        print((-1))\n        return\n\n    cycle = []\n    while hist:\n        t = hist.pop()\n        cycle.append(t)\n        if t == pos:\n            break\n\n    cycle.reverse()\n\n    while True:\n        order = [-1] * N\n        for i, v in enumerate(cycle):\n            order[v] = i\n\n        for i, v in enumerate(cycle):\n            ord_from = ord_to = -1\n            for nv in G[v]:\n                if v == nv or order[nv] == -1 or order[nv] == (order[v] + 1) % len(cycle):\n                    continue\n                ord_from, ord_to = i, order[nv]\n                break\n            if ord_from != -1:\n                break\n\n        if ord_from == -1:\n            break\n\n        if ord_from < ord_to:\n            cycle = cycle[: ord_from + 1] + cycle[ord_to:]\n        else:\n            cycle = cycle[ord_to : ord_from + 1]\n\n    print((len(cycle)))\n    for v in cycle:\n        print((v + 1))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import*\nn,m,*t=map(int,open(0).read().split())\ni=[0]*n\no=[[]for _ in i]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq,r=deque(v for v in range(n)if i[v]<1),[]\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint(-(len(r)==n))", "#!python3\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\nLI = lambda: list(map(int, input().split()))\n\n# input\nN, M = LI()\nAB = [LI() for _ in range(M)]\n\n# params\nlink = [[] for _ in range(N)]\nfor a, b in AB:\n    link[a - 1].append(b - 1)\nimpossible = [False] * N\n\n\ndef joint(v, visit):\n    if impossible[v]:\n        return None\n    visit = visit + [v]\n    for u in link[v]:\n        if u in visit:\n            i = visit.index(u)\n            return visit[i:]\n        t = joint(u, visit)\n        if t is not None:\n            return t\n    impossible[v] = True\n    return None\n\n\ndef solve(l):\n    n = len(l)\n    d = {l[i]: i for i in range(n)}\n    for i in range(n):\n        x = l[i]\n        for y in link[x]:\n            if y in d:\n                j = d[y]\n                if (i + 1) % n == j:\n                    continue\n                if j < i:\n                    l = l[j : i + 1]\n                else:\n                    l = l[: i + 1] + l[j:]\n                return solve(l)\n    return l\n            \n\ndef main():\n    t = None\n    for i in range(N):\n        t = joint(i, [])\n        if t is not None:\n            break\n    if t is None:\n        print((-1))\n        return\n    \n    ans = solve(t)\n    print((len(ans)))\n    for x in ans:\n        print((x + 1))\n        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nn, m = map(int, input().split())\ne = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    e[a-1].append(b-1)\n\nc = [0] * n\nans = []\ndef search_path(p, temp):\n    c[p] = 1\n    for x in e[p]:\n        if x in temp:\n            print(-99999)\n            return\n        else:\n            search_path(x, temp + [x])\n\n\nt = 1\nfor i in range(n):\n    if c[i] == 0:\n        ans = search_path(i, [i])\n\nprint(-1)", "from collections import deque\nimport sys\n\nN,M = list(map(int,input().split()))\n\nAB = []\nlis = [ [] for i in range(N)]\n\nfor i in range(M):\n\n    A,B = list(map(int,input().split()))\n\n    A -= 1\n    B -= 1\n\n    lis[A].append(B)\n\nq = deque([])\n\nfirst = [-1] * (N+1)\nfirst[0] = 0\nfirst[-1] = 0\n\nq.append( first )\n\nend = [True] * N\nend[0] = False\n\nwhile len(q) > 0:\n\n    now = q.pop()\n    lasp = now[-1]\n    nownum = now[lasp] \n\n    #print (q,now,lasp,nownum)\n\n    for nex in lis[lasp]:\n\n        if now[nex] == -1:\n            ncopy = now.copy()\n            ncopy[nex] = nownum + 1\n            ncopy[-1] = nex\n            end[nex] = False\n            q.append(ncopy)\n\n        else:\n\n            flag = True\n\n            for i in range(N):\n\n                if now[i] >= 0:\n\n                    for j in lis[i]:\n\n                        if (now[j] >= now[nex] and now[j] != now[i] + 1) and not (i == lasp and j == nex):\n                            flag = False\n                            break\n\n                if not flag:\n                    break\n\n            if flag:\n                ans = []\n\n                for i in range(N):\n                    if now[i] >= now[nex]:\n                        ans.append(i + 1)\n\n                print((len(ans)))\n                for i in ans:\n                    print (i)\n\n                return\n\n    if len(q) == 0:\n        for i in range(N):\n            if end[i]:\n\n                first = [-1] * (N+1)\n                first[i] = 0\n                first[-1] = i\n                q.append(first)\n                end[i] = False\n                break\n            #print (flag,nex,lasp)\n\nprint((-1))\n", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nfrom collections import deque\n\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n\n    ans_last = None # s\u304b\u3089\u30eb\u30fc\u30d7\u3092\u63a2\u3057\u3066\u898b\u3064\u304b\u3063\u305f\u6642\u306e\u3001\u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u756a\u53f7\n    dq.append(s)\n    # BFS\u3067\u3001\u6700\u77ed\u306e\u30eb\u30fc\u30d7\u3092\u898b\u3064\u3051\u308b\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            # \u9802\u70b9v\u304b\u3089\u3044\u3051\u308b\u9802\u70b9\u306e\u4e2d\u306b\u958b\u59cb\u70b9\u304c\u3042\u3063\u305f\u3089\u3001\u30eb\u30fc\u30d7\u3067\u3042\u308b\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            # \u307e\u3060\u63a2\u7d22\u3057\u3066\u3044\u306a\u3044\u9802\u70b9\u306a\u3089\u6b21\u306e\u63a2\u7d22\u5019\u88dc\u306b\u3059\u308b\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n\n    # \u30eb\u30fc\u30d7\u304c\u898b\u3064\u304b\u3063\u305f\u5834\u5408\n    if ans_last:\n        # \u30eb\u30fc\u30d7\u306e\u6700\u5f8c\u306e\u9802\u70b9\u304b\u3089\u3001\u5143\u306e\u9802\u70b9\u3092\u305f\u3069\u308a\u3001\u305d\u306e\u30eb\u30fc\u30c8\u3092\u9006\u306b\u3059\u308b\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    \n    # \u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u5834\u5408\u306fNone\u3092\u8fd4\u3059\n    return None\n\ndef main():\n    N, M, *A = map(int, read().split())\n\n    G = [[] for i in range(N+1)]\n    for a, b in zip(A[::2], A[1::2]):\n        G[a].append(b)\n\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3067\u3042\u308b\u3088\u3046\u306a G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\n    # [\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u306e\u30b0\u30e9\u30d5] -> \u30eb\u30fc\u30d7\n\n    # \u6709\u5411\u30b0\u30e9\u30d5 G=(V,E) \u306b\u5bfe\u3057\u3001\u6b21\u306e\u3088\u3046\u306a\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6709\u5411\u30b0\u30e9\u30d5 G\u2032=(V\u2032,E\u2032) \u3092 G \u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\u3068\u547c\u3076\u3002\n    # V\u2032 \u306f V \u306e (\u7a7a\u3067\u306a\u3044) \u90e8\u5206\u96c6\u5408\u3067\u3042\u308b\u3002\n    # E\u2032 \u306f\u3001E \u306e\u8fba\u3067\u3042\u3063\u3066\u4e21\u7aef\u70b9\u304c\u3068\u3082\u306b V\u2032 \u306b\u542b\u307e\u308c\u308b\u3082\u306e\u3059\u3079\u3066\u3092\u542b\u3080\u96c6\u5408\u3067\u3042\u308b\u3002\n\n    # -> \u30eb\u30fc\u30d7\u3067\u3082\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u308b\u3088\u3046\u306a\u30eb\u30fc\u30d7\u306f\u3060\u3081\n\n    # \u4f8b: 1 -> 2 -> 3 -> 4 -> 5\n    #     ^    |         ^    |\n    #     |    ----------|    |\n    #     ---------------------\n    # V' = {1, 2, 3, 4, 5} \u3068\u3057\u3066\u3057\u307e\u3046\u3068\u3001\n    # E' = {(1->2), (2->3), (3->4), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u3063\u3066\u3057\u307e\u3044\u3001\u3053\u306e\u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5G'=(V', E')\u306b\u304a\u3044\u3066\u3001\n    # \u9802\u70b92\u306e\u51fa\u6b21\u6570\u304c2\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u3002\uff08\u9802\u70b94\u306e\u5165\u6b21\u6570\u30822\u306b\u306a\u3063\u3066\u3057\u307e\u3046\uff09\n    # V' = {1, 2, 4, 5} \u3068\u3059\u308c\u3070\u3001\n    # E' = {(1->2), (2->4), (4->5), (5->1)}\n    # \u3068\u306a\u308a\u3001\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u5165\u6b21\u6570\u304c 1\u3001\u51fa\u6b21\u6570\u304c 1 \u3068\u306a\u308b\n    \n    # \u3064\u307e\u308a\u3001\u30b7\u30e7\u30fc\u30c8\u30ab\u30c3\u30c8\u3067\u304d\u306a\u3044\u6700\u77ed\u306e\u30eb\u30fc\u30d7\u30921\u3064\u3067\u3082\u898b\u3064\u3051\u308c\u3070\u3088\u3044\n    \n    min_route = None\n    for s in range(1, N+1):\n        # \u5404\u9802\u70b9\u3092\u958b\u59cb\u70b9\u306b\u3057\u3066\u30eb\u30fc\u30d7\u3092\u63a2\u3059\n        route = find_shortest_cycle(G, s)\n        # \u30eb\u30fc\u30d7\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u3001\u77ed\u3044\u307b\u3046\u3092\u63a1\u7528\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    \n    if min_route:\n        print(len(min_route), *min_route, sep='\\n')\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    N, M = list(map(int, input().split()))\n    V = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        V[a - 1].append(b - 1)\n    C = [0] * N\n    loop = []\n    def dfs(n):\n        if C[n] == 2:\n            return False\n        if C[n] == 1:\n            loop.append(n)\n            return True\n        C[n] = 1\n        for i in V[n]:\n            if dfs(i):\n                loop.append(n)\n                return True\n        C[n] = 2\n        return False\n    for i in range(N):\n        if dfs(i):\n            break\n    if len(loop) == 0:\n        print('-1')\n        return\n    for i in range(1, len(loop)):\n        if loop[i] == loop[0]:\n            break\n    loop = loop[:i][::-1]\n\n    def minimize(l):\n        s = set(l)\n        for i in range(len(l)):\n            for j in V[l[i]]:\n                if j == l[(i + 1) % len(l)]:\n                    continue\n                if j in s:\n                    break\n            else:\n                continue\n            break\n        else:\n            return l\n        I = {m: k for k, m in enumerate(l)}\n        j = I[j]\n        if i < j:\n            l = l[0:i + 1] + l[j:]\n        else:\n            l = l[j:i + 1]\n        return l\n    while True:\n        t = len(loop)\n        loop = minimize(loop)\n        if len(loop) == t:\n            break\n    print(t)\n    print(('\\n'.join(str(i + 1) for i in loop)))\nmain()\n", "import sys\nimport io, os\ninput = sys.stdin.buffer.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nn, m = map(int, input().split())\ng = [[] for _ in range(n)]\nedge = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    g[a].append(b)\n    edge.append((a, b))\n\nfrom collections import deque\nINF = 10**18\ntemp= INF\nfor a, b in edge:\n    q = deque([])\n    q.append(b)\n    visit = [INF]*n\n    visit[b] = 0\n    par = [-1]*n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if visit[u] == INF:\n                visit[u] = visit[v]+1\n                par[u] = v\n                q.append(u)\n    if visit[a]+1 <= temp:\n        ans = []\n        v = a\n        ans.append(v+1)\n        while par[v] != -1:\n            v = par[v]\n            ans.append(v+1)\n        temp =  visit[a]+1\n\nif temp == INF:\n    print(-1)\nelse:\n    if ans:\n        print(len(ans))\n        print(*ans, sep='\\n')\n    else:\n        print(-1)\n", "from collections import deque\nn,m = list(map(int,input().split()))\npath = [set() for _ in range(n)]\npathr= [set() for _ in range(n)]\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    path[a-1].add(b-1)\n    pathr[b-1].add(a-1)\n\ndef bfs(start):\n    que = deque()\n    d = [1e100]*n\n    for i in path[start]:\n        que.append(i)\n        d[i] = 1\n    while que:\n        p = que.popleft()\n        for nxt in path[p]:\n            if d[nxt] == 1e100:\n                que.append(nxt)\n            d[nxt] = min(d[nxt], d[p] + 1)\n    if d[start] == 1e100:\n        return [0] * (n+1)\n    ret = [0]*d[start]\n    ret[-1] = start\n    now = start\n    for i in range(d[start] - 1)[::-1]:\n        for p in pathr[now]:\n            if d[p] == i+1:\n                now = p\n                ret[i] = now\n                break\n    return ret\nans = [0]*(n+1)\nfor i in range(n):\n    tmp = bfs(i)\n    if len(ans) > len(tmp):\n        ans = tmp\nif len(ans) > n:\n  print((-1))\nelse:\n    print((len(ans)))\n    for i in ans:\n        print((i+1))\n", "def find_cycle(N, AB):\n  for c in range(N):\n    stack = [(c, [])]\n    while stack:\n      # print(\"stack:\", stack)\n      curr, visited = stack.pop()\n      if curr in visited:\n        # print(\"cycle found:\", curr)\n        return visited\n      else:\n        # print(\"adding in visited:\", curr)\n        for i in AB[curr]:\n          stack.append((i, visited+[curr]))\n  return False\n\n \n \ndef find_smaller_cycle(cycle, AB):\n    i = 0\n    while i < len(cycle):\n        v = cycle[i]\n        if AB[v]:\n            n = AB[v].pop()\n            if n in cycle:\n                r = cycle.index(n)\n                if i < r:\n                    cycle = cycle[:i+1] + cycle[r:]\n                else:\n                    cycle = cycle[r:i+1]\n                i = cycle.index(v)\n        else:\n            i += 1\n            \n    return cycle\n \n \nN, M = [int(i) for i in input().split()]\n \nAB = [[] for _ in range(N)]\nfor _ in range(M):\n    A, B = [int(i) - 1 for i in input().split()]\n    AB[A].append(B)\n\ncycle = find_cycle(N, AB)\n# print(\"cycle:\", cycle)\nif not cycle:\n    print(-1)\nelse:\n    cycle = find_smaller_cycle(cycle, AB)\n            \n    print(len(cycle))\n    for v in cycle:\n        print(v + 1)", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef solve(G, p, ans, st, fst, arr, x):\n    arr[p] = x\n    cnt_1 = 0\n    z = -1\n    for nxt in G[p]:\n        if nxt in st:\n            cnt_1 += 1\n            z = nxt\n    cnt_2 = 0\n    for v in st:\n        if p in G[v]:\n            cnt_2 += 1\n    if cnt_1 > 1 or cnt_2 > 1:\n        return False\n    elif cnt_1 == 1 and cnt_2 == 1:\n        if fst in G[p]:\n            for v in st:\n                ans.append(v)\n            return True\n        else:\n            k = arr[z]\n            for v in st:\n                if arr[v] >= k:\n                    ans.append(v)\n            return True\n    for nxt in G[p]:\n        st.add(nxt)\n        if solve(G, nxt, ans, st, fst, arr, x+1):\n            return True\n        st.remove(nxt)\n    arr[p] = 0\n    return False\n\ndef main():\n    n, m = map(int, input().split())\n    G = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        G[a].append(b)\n    ans = []\n    f = False\n    st = set()\n    arr = [0]*(n+1)\n    for i in range(1, n+1):\n        st.add(i)\n        if solve(G, i, ans, st, i, arr, 1):\n            f = True\n            break\n        st.remove(i)\n    if f:\n        print(len(ans))\n        ans.sort()\n        for v in ans:\n            print(v)\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = map(int, input().split())\ntree = dict(zip(range(1, N+1), [[] for i in range(N)]))\nfor i in range(M):\n  a, b = map(int, input().split())\n  tree[a].append(b)\n\n\nis_visited = [False]*(N+1)\nnum_visited = 0\ndef find_cycle(d):\n  nonlocal is_visited\n  nonlocal num_visited\n  cycle = []\n  l = 1001\n  while d:\n    node = d[-1]\n    if tree[node]:\n      child = tree[node].pop()\n      if not is_visited[child]:\n        is_visited[child] = True\n        num_visited += 1\n      if child in cycle and node in cycle:\n        idn = cycle.index(node)\n        idc = cycle.index(child)\n        cycle = cycle[:idn+1] + cycle[idc:]\n        l = len(cycle)\n      if child in d:\n        idx = d.index(child)\n        if len(d) - idx < l:\n          cycle = d[idx:]\n          l = len(cycle)\n      else:\n        d.append(child)\n    else:\n      d.pop()\n  return cycle\n\n\nis_visited[0] = True\nnum_visited += 1\ni = 1\nwhile num_visited < N+1:\n  while is_visited[i]:\n    i += 1\n  d = [i]\n  is_visited[i] = True\n  num_visited += 1\n  cycle = find_cycle(d)\n  if cycle:\n    print(len(cycle))\n    print(*cycle, sep='\\n')\n    return\n\nprint(-1)", "from collections import deque\nN,M=list(map(int,input().split()))\nG=[[] for i in range(N)]\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    G[a-1].append(b-1)\nK=[0 for i in range(N)]\nfor i in range(N):\n    for p in G[i]:\n        K[p]+=1\nq=deque(i for i in range(N) if K[i]==0)\nres=[]\nwhile q:\n    v1=q.popleft()\n    res.append(v1)\n    for v2 in G[v1]:\n        K[v2]-=1\n        if K[v2]==0:\n            q.append(v2)\nif len(res)==N:\n    print((-1))\n    return\nX={i for i in range(N)}\nfor st in range(N):\n    before=[-1 for i in range(N)]\n    q=deque([st])\n    flag=0\n    while(q):\n        r=q.popleft()\n        for p in G[r]:\n            if before[p]==-1:\n                before[p]=r\n                q.append(p)\n            if before[st]!=-1:\n                Y={st}\n                tmp=before[st]\n                while(tmp!=st):\n                    Y.add(tmp)\n                    tmp=before[tmp]\n                if len(Y)<len(X):\n                    X={i for i in Y}\n                flag=1\n                break\n        if flag:\n            break\nprint((len(X)))\nfor i in X:\n    print((i+1))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nn, m = list(map(int, input().split()))\ne = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    e[a-1].append(b-1)\n\nc = [0] * n\nans = []\ndef search_path(p, temp):\n    c[p] = 1\n    for x in e[p]:\n        if x in temp:\n            print((-99999))\n            return\n        else:\n            search_path(x, temp + [x])\n\n\nt = 1\nfor i in range(n):\n    if c[i] == 0:\n        ans = search_path(i, [i])\n\nprint((-1))\n", "import sys\nsys.setrecursionlimit(10**7)\ndef main():\n    N, M = list(map(int, input().split()))\n    l = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        l[a-1].append(b-1)\n    c = [0] * N\n    loop = []\n    def cyclic(n):\n        if c[n] == 2:\n            return False\n        if c[n] == 1:\n            loop.append(n)\n            return True\n        c[n] = 1\n        for i in l[n]:\n            if cyclic(i):\n                loop.append(n)\n                return True\n        c[n] = 2\n        return False\n    for i in range(N):\n        if cyclic(i):\n            break\n    if len(loop) == 0:\n        print((-1))\n        return\n    loop.reverse()\n    t = loop[-1]\n    loop = loop[loop.index(t):]\n    ll = set(loop)\n    flag = True\n    while flag:\n        for i, v in enumerate(loop[:-1]):\n            flag2 = False\n            for j in l[v]:\n                if j in ll and loop[i + 1] != j:\n                    if loop.index(j) == 0:\n                        loop = loop[:i+1] + [j]\n                    elif loop.index(j) < i:\n                        loop = loop[loop.index(j):i+1] + [j]\n                    else:\n                        loop = loop[:i+1] + loop[loop.index(j):]\n                    ll = set(loop)\n                    flag2 = True\n                    break\n            if flag2:\n                break\n        else:\n            flag = False\n    loop = set(loop)\n    print((len(loop)))\n    for i in loop:\n        print((i+1))\n    return\nmain()\n", "from collections import deque\n\nINF = 10**18\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b = map(int,input().split())\n    graph[a - 1].append(b - 1)\n\nloopsize = INF\n\nfor root in range(N):\n    queue = deque([root])\n    dist = [INF for _ in range(N)]\n    dist[root] = 0\n    prev = [None for _ in range(N)]\n    while queue:\n        node = queue.popleft()\n        for adj in graph[node]:\n            if adj == root:\n                dist[root] = dist[node] + 1\n                prev[root] = node\n                break\n            if dist[adj] != INF:\n                continue\n            dist[adj] = dist[node] + 1\n            prev[adj] = node\n            queue.append(adj)\n        else:\n            continue\n        break\n    else:\n        continue\n    if loopsize > dist[root]:\n        loopsize = dist[root]\n        path = [root]\n        node = root\n        while prev[node] != root:\n            node = prev[node]\n            path.append(node)\n\nif loopsize != INF:\n    print(loopsize)\n    for node in path:\n        print(node + 1)\nelse:\n    print(-1)", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ngraph=[set() for _ in range(N+1)]\nfor _ in range(M):\n  A,B=map(int,input().split())\n  graph[A].add(B)\n#print(graph)\n\nvisited=[False]*(N+1)\ndef dfs(path):\n  nonlocal cycle\n  u=path[-1]\n  \n  visited[u]=True  \n  for v in graph[u]:\n    if visited[v]:\n      cycle=list(path+[v])\n      return\n    else:\n      dfs(path+[v])      \n    if cycle:\n      return    \n  visited[u]=False\n  \ncycle=[]\nfor i in range(1,N+1):\n  dfs([i])\n  if cycle:\n    break\nelse:\n  print(-1)\n  return\n    \n#remove prefix  \nfor i in range(len(cycle)):\n  if cycle[i]==cycle[-1]:\n    cycle=cycle[i:]\n    break\n#print(cycle)\n\ncycle_set=set(cycle)\nsubgraph=[set() for _ in range(N+1)]\nfor c in cycle_set:\n  for v in graph[c]:\n    if v in cycle_set:\n      subgraph[c].add(v)\n#print(subgraph)    \n\n#visited=[False]*(N+1)\nex_path=[]\ndef dfs2(path,t):\n  nonlocal ex_path\n  u=path[-1]\n  if u==t:\n    ex_path=path\n    return\n  \n  for v in graph[u]:\n    dfs2(path+[v],t)\n    if ex_path:\n      return\n\ngraph=subgraph\nwhile True:\n  for i in range(len(cycle)-1):\n    u=cycle[i]\n    v=cycle[i+1]\n    w=-1\n    if len(graph[u])>1:\n      for x in graph[u]:\n        if x!=v:\n          w=x\n          break\n      break\n  else:\n    print(len(cycle)-1)\n    for i in range(len(cycle)-1):\n      print(cycle[i])\n    return\n    \n  #print(u,v,w)\n  #w->u\n  dfs2([w],u)\n  cycle=ex_path+[w]\n  #print(cycle)\n  cycle_set=set(cycle)\n  subgraph=[set() for _ in range(N+1)]\n  for c in cycle_set:\n    for v in graph[c]:\n      if v in cycle_set:\n        subgraph[c].add(v)\n        \n  graph=subgraph", "n,m=list(map(int,input().split()))\ng=[[] for _ in range(n)]\nfor _ in range(m):\n    u,v=list(map(int,input().split()))\n    u,v=u-1,v-1\n    g[u].append(v)\n\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef func(loop):\n    sl=set(loop)\n    k=len(loop)\n    for i in range(k):\n        v=loop[i]\n        for nv in g[v]:\n            if nv not in sl:continue\n            if nv==loop[(i+1)%k]:continue\n            j=[j for j in range(k) if loop[j]==nv][0]\n            if i<j:\n                ary=loop[:i+1]+loop[j:]\n            else:\n                ary=loop[j:i+1]\n            func(ary)\n    print((len(loop)))\n    for x in loop:\n        print((x+1))\n    return\n\nmi=set(range(n))\ndef dfs(v,par):\n    mi.discard(v)\n    for nv in g[v]:\n        if par[nv]==-1:\n            par[nv]=v\n            dfs(nv,par)\n            par[nv]=-1\n        else:\n            loop=[v]\n            while v!=nv:\n                loop.append(par[v])\n                v=par[v]\n            loop.reverse()\n            func(loop)\nwhile mi:\n    v=mi.pop()\n    dfs(v,[-1]*n)\nprint((-1))\n", "def cycle_detection(V, E, s):\n    prev = [-1] * len(V)\n    stack = [s]\n    while stack:\n        v = stack.pop()\n        for u in E[v]:\n            if u == s:\n                prev[u] = v\n                return (s, prev)\n            if prev[u] == -1:\n                stack.append(u)\n                prev[u] = v\n    return (-1, prev)\n\nN, M = map(int, input().split())\nV = list(range(N))\nE = [[] for _ in range(N)]\nedges = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    edges.append((a-1, b-1))\n\ndag = False\nfor v in range(N):\n    s, prev = cycle_detection(V, E, v)\n    if s != -1: break\nelse:\n    dag = True\n\nif dag: print(-1)\nelse:\n    # construct a directed cycle\n    cycle = set()\n    cycle.add(s)\n    pv = prev[s]\n    while pv != s:\n        cycle.add(pv)\n        pv = prev[pv]\n    # shrink the directed cycle\n    for a, b in edges:\n        if a in cycle and b in cycle and prev[b] != a:\n            pv = prev[b]\n            while pv != a:\n                cycle.remove(pv)\n                pv = prev[pv]\n            prev[b] = a\n    print(len(cycle))\n    print(*[v + 1 for v in cycle], sep='\\n')", "import sys\n\nread = sys.stdin.read\n\nN, M = list(map(int, input().split()))\nif M != 0:\n    AB = list(map(int, read().split()))\nelse:\n    print((-1))\n    return\n\ngraph = [[] for _ in range(N + 1)]\nA = AB[::2]\nB = AB[1::2]\nA_s = set(A)\n# \u51fa\u6b21\u6570\u304c0\u306e\u9802\u70b9\u306f\u3044\u3089\u306a\u3044\u3002\nneedless = set(range(1, N + 1)) - A_s\n\nfor i, j in zip(A, B):\n    if j not in needless:\n        graph[i].append(j)\n\n\n# cycle\u3092\u5c11\u306a\u304f\u3068\u3082\u4e00\u3064\u691c\u51fa\u3059\u308b\ndef dfs(original_stack):\n    checked = [False] * (N + 1)\n    while original_stack:\n        start = original_stack.pop()\n        if checked[start]:\n            continue\n        checked[start] = True\n        stack = [(start, [start])]\n        while stack:\n            v, route = stack.pop()\n            for i in graph[v]:\n                if i in route:\n                    return route[route.index(i):]\n                else:\n                    stack.append((i, route + [i]))\n                    checked[i] = True\n\n\nv = dfs([i for i in range(1, N + 1) if graph[i]])\nif not v:\n    print((-1))\n    return\n\nwhile True:\n    v_s = set(v)\n    length = len(v)\n    for i, (v_i, v_j) in enumerate(zip(v, v[1:] + [v[0]])):\n        for j in graph[v_i]:\n            if j != v_j and j in v_s:\n                idx = v.index(j)\n                if i < idx:\n                    v = v[:i + 1] + v[idx:]\n                else:\n                    v = v[idx:i + 1]\n                break\n        else:\n            continue\n        break\n    else:\n        print((len(v)))\n        print(('\\n'.join(map(str, v))))\n        return\n", "def main():\n  from collections import deque\n  n,m,*t=map(int,open(0).read().split())\n  i=[0]*n\n  o=[[]for _ in range(n)]\n  for a,b in zip(*[iter(t)]*2):\n    o[a-1]+=b-1,\n    i[b-1]+=1\n  q=deque(v for v,f in enumerate(i)if f<1)\n  r=[]\n  while q:\n    v=q.popleft()\n    r+=v,\n    for w in o[v]:\n      i[w]-=1\n      if i[w]==0:q+=w,\n  print(-(len(r)==n))\nmain()", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nfrom collections import deque,defaultdict,Counter\ndef main():\n    N,M = map(int,input().split())\n    G = [[] for _ in range(N)]\n    G_rev = [[] for _ in range(N)]\n    for _ in range(M):\n        a,b = map(int,input().split())\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G_rev[b].append(a)\n    \n    s,g = None,None\n    ans = INF\n    q = deque([])\n    for i in range(N):\n        q.append(i)\n        dist = [-1] * N\n        dist[i] = 0\n        while q:\n            v = q.popleft()\n            for e in G[v]:\n                if i == e:\n                    if ans > dist[v] + 1:\n                        ans = dist[v] + 1\n                        s,g = i,v\n                elif dist[e] < 0:\n                    dist[e] = dist[v] + 1\n                    q.append(e)\n\n    if ans == INF:\n        print(-1)\n    else:\n        print(ans)\n        q.append(s)\n        dist = [-1] * N\n        dist[s] = 0\n        while q:\n            v = q.popleft()\n            for e in G[v]:\n                if e == g:\n                    dist[g] = dist[v] + 1\n                    q.clear()\n                    break\n                elif dist[e] < 0:\n                    dist[e] = dist[v] + 1\n                    q.append(e)\n        route = [g + 1]\n        now = g\n        while now != s:\n            for e in G_rev[now]:\n                if dist[e] == dist[now] - 1:\n                    now = e\n                    break\n            route.append(now + 1)\n        print('\\n'.join(map(str,route)))\ndef __starting_point():\n    main()\n__starting_point()", "from sys import setrecursionlimit\nsetrecursionlimit(10000)\nN, M = list(map(int, input().split()))\ntable = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    table[a-1].append(b-1)\n\nvisit = [False] * N\nvisit2 = [False] * N\ng = []\n\n\ndef dfs(v):\n    g.append(v)\n    if visit[v]:\n        return True\n    visit[v] = True\n    visit2[v] = True\n    for u in table[v]:\n        if dfs(u):\n            return True\n    g.pop()\n    visit[v] = False\n    return False\n\n\nfor i in range(N):\n    g = []\n    if not visit2[i]:\n        if dfs(i):\n            break\nelse:\n    print((-1))\n    return\nprint((0))\n# ans = [v+1 for v in g[g.index(g[-1]):-1]]\n# print(len(ans))\n# print(*ans, sep=\"\\n\")\n", "from collections import deque\nN,M=list(map(int,input().split()))\nG=[[] for i in range(N)]\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    G[a-1].append(b-1)\nK=[0 for i in range(N)]\nfor i in range(N):\n    for p in G[i]:\n        K[p]+=1\nq=deque(i for i in range(N) if K[i]==0)\nres=[]\nwhile q:\n    v1=q.popleft()\n    res.append(v1)\n    for v2 in G[v1]:\n        K[v2]-=1\n        if K[v2]==0:\n            q.append(v2)\nif len(res)==N:\n    print((-1))\nelse:\n    print((0))\n\n", "import sys\ninput = sys.stdin.buffer.readline\n\n#sys.setrecursionlimit(10**9)\n#from functools import lru_cache\n\ndef RD(): return input().rstrip().decode()\ndef II(): return int(input())\ndef FI(): return int(input())\ndef MI(): return map(int,input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int,input().split()))\ndef LF(): return list(map(float,input().split()))\ndef TI(): return tuple(map(int,input().split()))\n# rstrip().decode()\n\nfrom collections import deque\n\ndef main():\n\tn,m=MI()\n\tG=[[] for _ in range(n+1)]\n\n\tfor _ in range(m):\n\t\ta,b=MI()\n\t\tG[a].append(b)\n\n\tA=[10**5]*(n+1)\n\n\tfor i in range(1,n+1):\n\t\tQ=deque([[i,0]])\n\t\tD=[-1]*(n+1)\n\t\twhile Q:\n\t\t\t#print(Q)\n\t\t\tnow,d=Q.popleft()\n\t\t\tif now==i and d>0:\n\t\t\t\tA[i]=d\n\t\t\t\tbreak\n\t\t\tfor nx in G[now]:\n\t\t\t\tif D[nx]==-1:\n\t\t\t\t\tD[nx]=d+1\n\t\t\t\t\tQ.append([nx,d+1])\n\t#print(A)\n\n\tk=min(A)\n\t#print(k)\n\n\tif k==10**5:\n\t\tprint(-1)\n\t\treturn\n\n\ts=A.index(k)\n\t#print(s)\n\n\tA=[]\n\tQ=deque([[s,0]])\n\tD=[10**5]*(n+1)\n\n\twhile Q:\n\t\tnow,d=Q.pop()\n\t\tif now==s and d>0:\n\t\t\tbreak\n\t\tif d==k:\n\t\t\tcontinue\n\t\tA.append(now)\n\t\tfor nx in G[now]:\n\t\t\tif D[nx]>d+1:\n\t\t\t\tD[nx]=d+1\n\t\t\t\tQ.append([nx,d+1])\n\tD[s]=0\n\n\t#print(A)\n\t#print(D)\n\n\tans=[]\n\td=k-1\n\tfor i in reversed(A):\n\t\tif D[i]==d:\n\t\t\tans.append(i)\n\t\t\td-=1\n\n\tprint(k)\n\tprint(*ans[::-1],sep=\"\\n\")\n\n\n\n\n\n\n\n\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "from collections import deque\n\nN, M, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor a, b in zip(*[iter(AB)] * 2):\n    E[a].append(b)\n\nshortest = N + 1\nans = []\nfor s in range(1, N + 1):\n    D = [-1] * (N + 1)\n    P = [-1] * (N + 1)\n\n    D[s] = 0\n    Q = deque([s])\n    while Q:\n        p = Q.popleft()\n        for c in E[p]:\n            if D[c] < 0:\n                D[c] = D[p] + 1\n                P[c] = p\n                Q.append(c)\n\n    for t in range(1, N + 1):\n        if t == s or D[t] < 0:\n            continue\n\n        for v in E[t]:\n            if v != s:\n                continue\n\n            T = [s]\n            cur = t\n            while cur != s:\n                T.append(cur)\n                cur = P[cur]\n\n            if shortest > len(T):\n                shortest = len(T)\n                ans = T\n\nif shortest == N + 1:\n    print(-1)\nelse:\n    print(len(ans))\n    print(\"\\n\".join(map(str, ans)))", "from collections import*\nn,m,*t=map(int,open(0).read().split())\ni,o,r=[0]*n,[[]for _ in'_'*n],[]\nfor a,b in zip(*[iter(t)]*2):\n  o[a-1]+=b-1,\n  i[b-1]+=1\nq=deque(v for v in range(n)if i[v]<1)\nwhile q:\n  v=q.popleft()\n  r+=v,\n  for w in o[v]:\n    i[w]-=1\n    if i[w]==0:q+=w,\nprint(-(len(r)==n))", "N,M=map(int,input().split())\nAB=[list(map(int,input().split())) for i in range(M)]\nc=[[] for i in range(N)]\nfor a,b in AB:\n    c[a-1].append(b-1)\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**9)\ndef f2(q):\n    s=set(q)\n    for a,b in AB:\n        if a in s and b in s:\n            i=q.index(b)\n            if q[i-1]!=a:\n                break\n    if a in s and b in s and q[i-1]!=a:\n        q2=deque([a,b])\n        while q[(i+1)%len(q)]!=a:\n            q2.append(q[(i+1)%len(q)])\n            i+=1\n        f2(q2)\n    print(len(q),*q,sep='\\n')\n    return\nv=[0]*N \nw=[0]*N\ndef f(p,v,q):\n    v[p]=1\n    w[p]=1\n    q.append(p+1)\n    for n in c[p]:\n        if v[n]:\n            f2(q)\n        else:\n            f(n,v,q)\n    q.pop()\n    v[p]=0\nfor p in range(N):\n    if w[p]==0:\n        f(p,v,deque())\nprint(-1)\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nn, m = list(map(int, input().split()))\ne = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    e[a-1].append(b-1)\n\nc = [0] * n\nans = []\ndef search_path(p, temp):\n    c[p] = 1\n    for x in e[p]:\n        if x in temp:\n            print((-99999))\n            return\n        else:\n            search_path(x, temp + [x])\n\n\nt = 1\nfor i in range(n):\n    if c[i] == 0:\n        ans = search_path(i, [i])\n\nprint((-1))\n", "import sys\nfrom copy import deepcopy as copy\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n    n, m = list(map(int, input().split()))\n    \n    tree = [[] for _ in range(n)]\n    edge = dict()\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        tree[a-1].append(b-1)\n        edge[(a-1, b-1)] = i+1\n    \n    ans = 0\n    for i in range(n):\n        not_yet = deque([i])\n        already = [False]*n\n        dist = [0]*n\n        par = [0]*n\n        already[i] = True\n        sub = []\n        \n        while not_yet:\n            key = not_yet.popleft()\n            for v in tree[key]:\n                if already[v]:\n                    \n                    if v == i:\n                        sub = [key+1]\n                        now = key\n                        while now != i:\n                            sub.append(par[now]+1)\n                            now = par[now]\n                        break\n                    continue\n                \n                not_yet.append(v)\n                already[v] = True\n                dist[v] = dist[key] + 1\n                par[v] = key\n            if sub:\n                break\n            \n        if sub:\n            if ans:\n                if len(ans) > len(sub):\n                    ans = copy(sub)\n            else:\n                ans = copy(sub)\n            \n        \n    if ans:\n        print((len(ans)))\n        for a in ans:\n            print(a)\n    else:\n        print((-1))\n        \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nn, m = list(map(int, input().split()))\ne = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    e[a-1].append(b-1)\n\nc = [0] * n\nans = []\ndef search_path(p, temp):\n    c[p] = 1\n    for x in e[p]:\n        if x in temp:\n            print((-99999))\n            return\n        else:\n            search_path(x, temp + [x])\n\n\nt = 1\nfor i in range(n):\n    if c[i] == 0:\n        ans = search_path(i, [i])\n\nprint((-1))\n"]
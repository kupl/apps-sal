["def s(k):\n\tif k % 2 == 0:\n\t\treturn k // 2\n\telse:\n\t\treturn - (k + 1) // 2\n\n\nfor i in range(int(input())):\n\tl, r = list(map(int, input().split()))\n\tprint(s(r) - s(l - 1))\n", "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nfor _ in range(ii()):\n    l, r = mi()\n    l -= 1\n    sr = r // 2 + (r % 2) * -r\n    sl = l // 2 + (l % 2) * -l\n    print(sr - sl)", "def main():\n    def calc(x):\n        if x & 1:\n            return -x + calc(x - 1)\n        return x // 2\n    n = int(input())\n    for i in range(n):\n        a, b = list(map(int, input().split()))\n        print(calc(b) - calc(a - 1))    \n\nmain()\n", "n = int(input())\nfor i in range(n):\n    a,b = list(map(int, input().split()))\n    a1 = a\n    if a % 2 == 0:\n        a1 += 1\n    b1 = b\n    if b % 2 == 0:\n        b1 -= 1\n    n = 0\n    if a1 <= b1:\n        num = (b1 - a1) // 2 + 1\n        n = num * (b1 + a1) // 2\n        n *= -1\n    b2 = b\n    a2 = a\n    if a % 2 == 1:\n        a2 += 1\n    if b % 2 == 1:\n        b2 -= 1\n    n2 = 0\n    if a2 <= b2:\n        num = (b2 - a2) // 2 + 1\n        n2 = num * (b2 + a2) // 2\n    print(n + n2)\n\n", "import math\nn  = int(input())\n\nfor i in range(n):\n    l,r = [*map(int, input().split())]\n    l-=1\n    war1 = math.ceil(l/2)\n    if(l%2 == 1):\n        war1 = -1*war1\n    \n    war2 = math.ceil(r/2)\n    if(r%2 == 1):\n        war2 = -1*war2\n\n    print(war2-war1)", "q = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l % 2 == 0:\n        count = -((r - l + 1) // 2)\n    else:\n        count = ((r - l + 1) // 2)\n    if (r - l + 1) % 2 == 0:\n        print(count)\n    else:\n        if r % 2 == 0:\n            print(count + r)\n        else:\n            print(count - r)", "n = int(input())\nfor _ in range(n):\n    l, r = map(int, input().split())\n    if (l - r) % 2 == 1:\n        if l % 2:\n            print((r-l+1)//2)\n        else:\n            print(-((r-l+1)//2))\n    else:\n        ans = 0\n        if l % 2:\n            ans = ans + (r-l)//2\n        else:\n            ans = ans + -(r-l)//2\n        if r % 2:\n            ans = ans - r\n        else:\n            ans = ans + r\n        print(ans)", "import sys\ninput = sys.stdin.readline\n\nQ=int(input())\nLR=[list(map(int,input().split())) for i in range(Q)]\n\n#\u6b63:N//2\u500b\u306e\u548c\n#\u8ca0:(N+1)//2\u500b\u306e\u548c\n\ndef SUM(i):\n    plus=i//2\n    minus=(i+1)//2\n\n    P=(2+2*plus)*plus//2\n    M=(1+2*minus-1)*minus//2\n    return P-M\n\nfor l,r in LR:\n    print(SUM(r)-SUM(l-1))\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\n            \n\ndef main():\n    l,r= get_tuple()\n    size = r-l+1\n    res=0\n    if l%2!=0:\n        res+=size//2\n        if size%2!=0:\n            res+=(-1)**r * r\n    else:\n        res-=size//2\n        if size%2!=0:\n            res+=(-1)**r * r\n    print(res)\n\n    \n        \n            \n\n\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/11/24 15:28\n\n\"\"\"\n\nQ = int(input())\nans = []\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    if l % 2 == 0 and r % 2 == 0:\n        ans.append((r-l)//2 + l)\n    elif l % 2 == 1 and r % 2 == 0:\n        ans.append((r-l+1)//2)\n    elif l % 2 == 1 and r % 2 == 1:\n        ans.append(0-(r-l)//2-l)\n    else:\n        ans.append(0-(r-l+1)//2)\n\nprint('\\n'.join(map(str, ans)))", "cs = int(input())\n\nfor c in range(cs):\n    l, r = map(int, input().split())\n    #odd     => -\n    #even    => +\n    \n    if l%2 == 0 and r%2 == 0:\n        print((r - l) // 2 + l)\n    if l%2 == 1 and r%2 == 0:\n        print((r - l + 1) // 2)\n    if l%2 == 0 and r%2 == 1:\n        print(-(r - l + 1) // 2)\n    if l%2 == 1 and r%2 == 1:\n        print(-(r - l) // 2 - l)", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\n\nfor _ in range(N):\n    l,r = getIntList()\n    n = (r-l+1)\n    z = n//2\n    if l%2==0:\n        z*=-1\n    if n%2==1:\n        if r%2==0:\n            z += r\n        else:\n            z-=r\n    print(z)\n\n    \n\n\n\n\n", "Q = int(input())\n\ndef getsum(N):\n    A = (N+1)//2\n    r1 = -A + A*(A+1)\n    B = N // 2\n    r2 = B*(B+1)\n    return -r1 + r2\n\nwhile Q != 0:\n    L, R = list(map(int, input().split()))\n    print(getsum(R) - getsum(L-1))\n    Q -= 1\n    \n", "def getsum(a, b):\n    if a % 2 == 0:\n        return (a + b) * ((b - a) // 2 + 1) // 2\n    else:\n        return -(a + b) * ((b - a) // 2 + 1) // 2\n\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    if l == r:\n        print(l if l % 2 == 0 else -l)\n    else:\n        print(\n            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) + \n            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)\n        )", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n)]\n    r = []\n    for a,b in aa:\n        al = a + (1-a%2)\n        ar = b - (1-b%2)\n        sa = (ar-al) // 2 + 1\n        tr = -(al+ar) * sa // 2\n\n        bl = a + (a%2)\n        br = b - (b%2)\n        sb = (br-bl) // 2 + 1\n        tr += (bl+br) * sb // 2\n        r.append(tr)\n\n    return \"\\n\".join(map(str,r))\n\n\nprint(main())\n", "# from math import ceil\n# n, k = map(int, input().split())\n# print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))\n\nfor _ in range(int(input())):\n    i, j = map(int, input().split())\n    i -= 1\n    print(j//2 * (j//2 + 1) - i//2 * (i//2 + 1) - \n          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2)))) ", "q = int(input())\nfor _ in range(q):\n\tl, r = list(map(int, input().split()))\n\tsign = -1 if l % 2 else 1\n\tif (r-l) % 2:\n\t\tprint(-sign*(r-l+1)//2)\n\telse:\n\t\tprint(sign*(l+(r-l)//2))\n\n", "from collections import defaultdict\n# from fractions import Fraction\ndef read_line():\n    return [int(x) for x in input().split()]\n\n\ndef query(l, r):\n    if l == r:\n        if l % 2 == 0: return l\n        else: return -r\n    if l % 2 == 1:\n        return -l + query(l+1, r)\n    if r % 2 == 0:\n        return r + query(l, r-1)\n\n    num_pairs = (r+1 - l ) // 2\n    sm_even = l * num_pairs + num_pairs * (num_pairs-1)\n    sm_odd = -(sm_even + num_pairs)\n    return sm_even + sm_odd\n\n# test = [i * (-1)**i for i in range(100)]\n# for i in range(1, 100):\n#     for j in range(i, 100):\n#         print(i, j, query(i, j), sum(test[x] for x in range(i, j+1)))\n#         assert query(i, j) == sum(test[x] for x in range(i, j+1))\n\nq = int(input())\nfor _ in range(q):\n    l, r = read_line()\n    print(query(l, r))\n\n", "def solve(n):\n\teven = (n//2) * (n//2 + 1)\n\todd = ((n+1)//2) * ((n+1)//2)\n\treturn even - odd\n\nQ = int(input())\nfor _ in range(Q):\n\t(l, r) = list(map(int, input().split(' ')))\n\tans = solve(r) - solve(l-1)\n\tprint(ans)", "for i in range(int(input())):\n    l,r=list(map(int,input().split()))\n    if l==r:\n        print(((-1)**(l%2))*l)\n    elif l%2==1 and r%2==0:\n        print((r-l+1)//2)\n    elif l%2==1 and r%2==1:\n        print(((r-l)//2)-r)\n    elif l%2==0 and r%2==0:\n        print(((r-l)//2)+l)\n    elif l%2==0 and r%2==1:\n        print(((r-l-1)//2)+l-r)\n", "from math import ceil \n\nt = int(input())\nfor test in range(t):\n    l, r = (list(map(int, input().split())))\n    odd = 0\n    st = 2*ceil(l/2)\n    end = 2*(r//2)\n    even = ((st + end)*(((end-st)//2)+1) )//2\n    st = 2*(l//2)+1\n    end = 2*ceil(r/2)-1\n    odd = ((st + end)*(((end-st)//2)+1) )//2\n    print(int(even-odd))\n\n\n\n\n\n"]
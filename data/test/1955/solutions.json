["n,m = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nsums = sum(B)+len(B)\nlast = [-1] * m\ncou = 0\nans = 0\nper = 0\nfor j in range(n):\n    if A[j] == 0:\n        cou +=1\n    else:\n        if last[A[j]-1] == -1:\n            if j >= B[A[j]-1]:\n                \n                ans += 1\n                last[A[j]-1] = 0\n                \n        if ans == m:\n            if (j+1) >= sums:\n                per=1\n                print(j+1)\n                break\n           \n        \n    \n    \nif per == 0:\n    print(-1)\n        \n", "D=input().split()\nD=[int(x) for x in D]\nn=(D[0])\nm=(D[1])\nd=input().split()\nd=[int(x) for x in d]\nA=[int(x) for x in input().split()]\n\n\nS=0\nso=0\nneg=0\nind=0\ndays=0\nfor i in d:\n    if i==0:\n        neg+=1\nfor i in A:\n    so+=i\nif so+m>n or n-neg<m:\n    print(-1)\n\nelse:\n    p=(A.pop(0))\n    for i in d:\n        if i>0 and ind>0 and p!=0:\n            ind-=1\n            days+=1\n        elif i>0 and ind>0:\n            ind-=1\n            days+=1\n            if ind==0:\n                break\n            else:\n                for j in range(days,n):\n                    days+=1\n                    if d[j]>0:\n                        ind-=1\n                    \n                        if ind==0:\n                            break\n                break\n        else:\n            S+=1\n            days+=1\n        \n        if p==S and A!=[]:\n            ind+=1\n            S=0\n            p=A.pop(0)\n        elif p==S:\n            ind+=1\n            S=0\n            p=0\n    print(days)\n", "def check(m, mid, aa, dd, edays):\n    avail, ee = [True] * (m + 1), []\n    for i in range(mid, -1, -1):\n        day = edays[i]\n        exam = dd[day]\n        if avail[exam]:\n            avail[exam] = False\n            ee.append(day)\n            if len(ee) == m:\n                break\n    else:\n        return False\n    pool, prev = 0, -1\n    for day in reversed(ee):\n        pool += day - prev - aa[dd[day]]\n        if pool < 0:\n            return False\n        prev = day\n    return True\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    dd = list(map(int, input().split()))\n    edays = [i for i, e in enumerate(dd) if e]\n    aa = [0, *(int(s) + 1 for s in input().split())]\n    lo, hi = 0, len(edays)\n    try:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(m, mid, aa, dd, edays):\n                hi = mid\n            else:\n                lo = mid + 1\n        print(edays[lo] + 1)\n    except IndexError:\n        print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    dd = list(map(int, input().split()))\n    aa = [0, *list(map(int, input().split()))]\n    l = [True] * (m + 1)\n    l[0], total = False, sum(aa) + len(aa) - 2\n    for i, e in enumerate(dd, 1):\n        if l[e]:\n            if i > aa[e]:\n                m -= 1\n                l[e] = False\n        if not m and i > total:\n            print(i)\n            break\n    else:\n        print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def check(i):\n    used = [0] * m\n    k = 0\n    for i in range(i, -1, -1):\n        if d[i] and not used[d[i] - 1]:\n            k += a[d[i] - 1]\n            used[d[i] - 1] = 1\n        elif k:\n            k -= 1\n    return (not k)\n    \n\nn, m = map(int, input().split())\nd = list(map(int, input().split()))\na = list(map(int, input().split()))\nused = [0] * m\nk = m\ni = 0\nwhile i < n:\n    if d[i] and not used[d[i] - 1]:\n        used[d[i] - 1] = 1\n        k -= 1\n    if not k:\n        break\n    i += 1\nif i == n or not check(n - 1):\n    print(-1)\nelse:\n    l = i - 1\n    r = n - 1\n    while l < r - 1:\n        middle = (l + r) // 2\n        if check(middle):\n            r = middle\n        else:\n            l = middle\n    print(r + 1)", "def ch(ind):\n    vis = [0 for i in range(m)]\n    k=0\n    for i in range(ind,-1,-1):\n        if d[i] and not vis[d[i]-1]:\n            k+=a[d[i]-1]\n            vis[d[i]-1]=1\n        else:\n            if k:\n                k-=1\n    return 0 if k else -1\n\nn,m=list(map(int,input().split()))\nd=list(map(int,input().split()))\na=list(map(int,input().split()))\nvis=[0 for i in range(m)]\nmid=m\ni=0\nwhile(i<n):\n    if d[i] and not vis[d[i] - 1]:\n        mid-=1\n        vis[d[i] - 1] = 1\n    if mid:\n        pass\n    else:\n        break\n    i+=1\nif i==n or not ch(n-1):\n    print('-1')\n    return\n\nl=i-1\nr=n-1\nwhile(l<r-1):\n    mx=(l+r)//2\n    if(ch(mx)):\n        r=mx\n    else:\n        l=mx\nprint(l+2)\n", "from collections import deque\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    test = list(map(int, input().split()))\n    prepare = list(map(int, input().split()))\n    least_days = sum(prepare) + m\n\n    if least_days > len(test):\n        print(-1)\n        return\n    index = list()\n    for p in range(m + 1):\n        index.append(deque())\n    for t in range(len(test)):\n        if test[t] == 0:\n            continue\n        index[test[t]].append(t)\n        if t >= least_days - 1:\n            index[0].append(t)\n    if deque([]) in index:\n        print(-1)\n        return\n    min_index = max(list([x.popleft() for x in index[1:]]))\n    min_index = max(least_days - 1, min_index)\n    for x in index[0]:\n        if x >= min_index:\n            print(x + 1)\n            break\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def check(now):\n    last=[0 for i in range(0,m+1)]\n    ddl=[]\n    last[0]=-1\n    for i in range(now,0,-1):\n        if last[d[i]]==0:\n            ddl.append(d[i])\n            last[d[i]]=i\n    day=0\n    if len(ddl)!=m: return False\n    for i in range(1,m+1):\n#        print(a[ddl[-i]])\n        day+=a[ddl[-i]]\n        if day>=last[ddl[-i]]:\n            return False\n        day+=1\n    return True\n\na=input()\na=a.split()\nn=int(a[0])\nm=int(a[1])\nd=input()\nd=d.split()\na=input()\na=a.split()\na=[0]+a\nd=[0]+d\nfor i in range(0,n+1):\n    d[i]=int(d[i])\nfor i in range(0,m+1):\n    a[i]=int(a[i])\nl=0\nr=n+1\nwhile l<r-1:\n    mid=(l+r)>>1\n    if check(mid):\n        r=mid\n    else:\n        l=mid\nif r==n+1:\n    print(-1)\nelse:\n    print(r)", "from operator import itemgetter\n\nn, m = [int(i) for i in input().split()]\nd = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\n\n\nd_dict = dict()\nfor i in range(m):\n    d_dict[i+1] = []\nfor i in range(n):\n    if d[i]:\n        d_dict[d[i]].append(i) \n\ndef check_feasibility(x):\n    tmp_d = d[:x]\n    set_tmd_d = set(tmp_d) - set([0])\n    if len(set_tmd_d) < m:\n        return False\n    else:\n        #index_list =[[[j for j in range(x) if tmp_d[j] == i+1][-1], a[i]] for i in range(m)]\n        index_list =[[[j for j in d_dict[i+1] if j< x][-1], a[i]] for i in range(m)]\n        index_list = sorted(index_list, key = itemgetter(0))\n        tmp = 0\n        for i in range(m):\n            tmp += index_list[i][1]\n            if tmp + i > index_list[i][0]:\n                return False\n    return True\n\nif check_feasibility(n):\n    right = n\n    left = 1\n    mid = (left + right)//2\n    cur_value = check_feasibility(mid)\n    while left != right:\n        if not cur_value:\n            left = mid + 1\n        else:\n            right = mid\n        mid = (left+right) // 2\n        cur_value = check_feasibility(mid)\n    print(mid)\nelse:\n    print(-1)\n\n", "#!/usr/bin/env python3\nfrom sys import stdin,stdout\n\ndef ri():\n    return map(int, stdin.readline().split())\n\ndef solve(ee):\n    dest = [-1 for i in range(m)]\n    for i in range(ee, -1, -1):\n        if d[i] != -1 and dest[d[i]] == -1:\n            dest[d[i]] = i\n    pd = -1\n    for i in range(ee+1):\n        da = d[i]\n        if da != -1 and dest[da] == i:\n            pd += a[da]\n            pd += 1\n            if pd > i:\n                return 0\n    if dest.count(-1):\n        return 0\n    else:\n        return 1\n\nn, m = ri()\nd = list(ri())\na = list(ri())\nd = [i-1 for i in d]\n\ns = 0\ne = n\nwhile s < e:\n    mid = (e+s)//2\n    if solve(mid):\n        e = mid\n    else:\n        s = mid+1\nif s >= n:\n    print(-1)\nelse:\n    print(s+1)", "n,m = map(int,input().split())\narr = list(map(int,input().split()))\nprep = list(map(int,input().split()))\nx=[0]*m\n#print(x)\n#mp = dict()\ntotal = sum(prep) + m\nc=0\n#for i in range(1,m+1):\n#\tmp[i] = prep[i-1]\n#print(mp)\nst = set()\n\nans = 0\nflag = 0\nfor i in range(n):\n\tst.add(arr[i])\n\t#print(st,i+1,total)\n\tif(arr[i] and prep[(arr[i]-1)]<=i and not x[(arr[i]-1)]):\n\t  x[(arr[i]-1)]=1\n\t  c+=1\n\tif ((0 in st and len(st)==(m+1)) or ( 0 not in st and len(st)==m) ) and (i+1)>=total and arr[i]:\n\t\tans = i + 1\n\t\tflag = 1\n\t\tbreak\n#print(c)\nif flag and c==m :\n\tprint(ans)\nelse:\n\tprint(-1)", "\"\"\"\nBrandt Smith, Peter Haddad, Lemuel Gorion\n\nCodeforces.com\n\nProblem 732D\n\"\"\"\nimport sys\n\nn, m = list(map(int, input().split(' ')))\ndi = list(map(int,input().split(' ')))\nai = list(map(int,input().split(' ')))\n\ncompleted = [False] * m \n\nsumm = sum(ai) + m\ntemp = m\n\nfor i in range(n):\n    if di[i] == 0:\n        continue\n    else:\n        if not completed[di[i] - 1]:\n            if ai[di[i] - 1] <= i:\n                temp -= 1\n                completed[di[i] - 1] = True\n\n        if temp == 0:\n            if i + 1 >= summ:\n                print(i + 1)\n                return\n\nprint(-1)\n\n", "def valid(arr1, n, arr2, m, mid):\n    tmp_list = [-1] * (m+1)\n    for i in range(mid):\n        if(arr1[i] > 0):\n            tmp_list[arr1[i]] = i;\n    \n    if(tmp_list[1:].count(-1) > 0):\n        return False\n\n    stud = 0\n    for i in range(mid):\n        if (tmp_list[arr1[i]] == i):\n            if (arr2[arr1[i]-1] <= stud):\n                stud -= arr2[arr1[i]-1];\n            else:\n                return False\n        else:\n            stud += 1\n\n    return True\n\ndef binary_search(arr1, n, arr2, m):\n    l, r = 1, n\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(arr1, n, arr2, m, mid)):\n            r = mid-1\n        else:\n            l = mid+1\n    return -1 if l == n+1 else l\n\ndef main():\n    n, m = list(map(int, input().split()))\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    print(binary_search(arr1, n, arr2, m))\n\nmain()\n", "from sys import stdin\n\ndef valid(arr1, n, arr2, m, mid):\n    tmp_list = [-1] * (m+1)\n    for i in range(mid):\n        if(arr1[i] > 0):\n            tmp_list[arr1[i]] = i;\n    \n    if(tmp_list[1:].count(-1) > 0):\n        return False\n\n    stud = 0\n    for i in range(mid):\n        if (tmp_list[arr1[i]] == i):\n            if (arr2[arr1[i]-1] <= stud):\n                stud -= arr2[arr1[i]-1];\n            else:\n                return False\n        else:\n            stud += 1\n\n    return True\n\ndef binary_search(arr1, n, arr2, m):\n    l, r = 1, n\n    while (l <= r):\n        mid = l+r >> 1\n        if (valid(arr1, n, arr2, m, mid)):\n            r = mid-1\n        else:\n            l = mid+1\n    return -1 if l == n+1 else l\n\ndef main():\n    n, m = list(map(int, stdin.readline().split()))\n    arr1 = list(map(int, stdin.readline().split()))\n    arr2 = list(map(int, stdin.readline().split()))\n    print(binary_search(arr1, n, arr2, m))\n\nmain()\n", "R = lambda: map(int, input().split())\n\ndef is_good(tmp_arr):\n    visited = set()\n    for i in range(len(tmp_arr) - 1, -1, -1):\n        if tmp_arr[i] and (tmp_arr[i] not in visited):\n            visited.add(tmp_arr[i])\n            tmp_arr[i] = cost[tmp_arr[i] - 1]\n        else:\n            tmp_arr[i] = 0\n    if len(visited) != m:\n        return False\n    tot = 0\n    for x in tmp_arr:\n        tot += (1 if not x else 0) - x\n        if tot < 0:\n            return False\n    return True\n\nn, m = R()\narr = list(R())\ncost = list(R())\nif not is_good(arr[:]):\n    print(-1)\n    return\nl, r = 0, n - 1\nwhile l < r:\n    mid = (l + r) // 2\n    if is_good(arr[:mid + 1]):\n        r = mid\n    else:\n        l = mid + 1\nprint(r + 1)", "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ns = [0] * n\nd = {0: 1}\nfor i in range(n - 1, -1, -1):\n    if a[i] not in d:\n        s[i] = a[i]\n        d[a[i]] = 1\n\nif len(d) != m + 1:\n    print(-1)\n    return\n\nq = 0\nfor i in range(n):\n    if s[i] == 0:\n        q += 1\n    else:\n        if q >= b[s[i] - 1]:\n            q -= b[s[i] - 1]\n        else:\n            print(-1)\n            return\n\n\ndef calc(k):\n    s = [0] * k\n    d = {0: 1}\n    for i in range(k - 1, -1, -1):\n        if a[i] not in d:\n            s[i] = a[i]\n            d[a[i]] = 1\n\n    q = 0\n    p = 0\n    for i in range(k):\n        if s[i] == 0:\n            q += 1\n        else:\n            if q >= b[s[i] - 1]:\n                q -= b[s[i] - 1]\n                p += 1\n            else:\n                return False\n    if p == m:\n        return True\n    else:\n        return False\n\n\nl, r = 0, n\nwhile r - l > 1:\n    mid = (r + l) // 2\n    if calc(mid):\n        r = mid\n    else:\n        l = mid\n\nprint(r)", "n,m = list(map(int, input().split()))\ndias = [int(x) for x in input().split()]\nprep = [int(x) for x in input().split()]\ndef isposi(nu):\n    faltan = set(range(1,m+1))\n    porestudiar = 0\n    for i in reversed(list(range(min(nu, n)))):\n        if dias[i] in faltan:\n            faltan.remove(dias[i])\n            porestudiar+=prep[dias[i]-1]\n        elif porestudiar > 0:\n            porestudiar -= 1\n    return len(faltan)==0 and porestudiar == 0\n\nif not isposi(n):\n    print(-1)\nelse:\n    lo,hi=0,n\n    while(hi> lo):\n        mid = (hi+lo)//2\n        if isposi(mid):\n            hi = mid\n        else:\n            lo = mid+1\n    print(lo)\n", "n,m = list(map(int, input().split()))\ndias = [int(x) for x in input().split()]\nprep = [int(x) for x in input().split()]\ndef es_posible(nu):\n    faltan = set(range(1,m+1))\n    porestudiar = 0\n    for i in reversed(list(range(min(nu, n)))):\n        if dias[i] in faltan:\n            faltan.remove(dias[i])\n            porestudiar+=prep[dias[i]-1]\n        elif porestudiar > 0:\n            porestudiar -= 1\n    return len(faltan)==0 and porestudiar == 0\n\nif not es_posible(n):\n    print(-1)\nelse:\n    lo,hi=0,n\n    while(hi> lo):\n        mid = (hi+lo)//2\n        if es_posible(mid):\n            hi = mid\n        else:\n            lo = mid+1\n    print(lo)\n", "n,m = list(map(int, input().split()))\ndias = [int(x) for x in input().split()]\nprep = [int(x) for x in input().split()]\ndef es_posible(nu):\n    faltan = set(range(1,m+1))\n    porestudiar = 0\n    for i in reversed(list(range(min(nu, n)))):\n        if dias[i] in faltan:\n            faltan.remove(dias[i])\n            porestudiar+=prep[dias[i]-1]\n        elif porestudiar > 0:\n            porestudiar -= 1\n    return len(faltan)==0 and porestudiar == 0\n\nif not es_posible(n):\n    print(-1)\nelse:\n    lo,hi=0,n\n    while(hi> lo):\n        mid = (hi+lo)//2\n        if es_posible(mid):\n            hi = mid\n        else:\n            lo = mid+1\n    print(lo)\n\n", "n, m = map(int, input().split())\nd = list(map(int, input().split()))\na = list(map(int, input().split()))\ndef check(l):\n    cur = [0] * m\n    ans = 0\n    \n    for i in range(1, l):\n        \n        if d[i] > 0:\n            cur[d[i] - 1] += 1\n            \n       \n    fr = 1\n    \n    if cur.count(0) == 0:\n        for i in range(1, l):\n            if d[i] > 0:\n                if cur[d[i] - 1] > 1:\n                    fr += 1\n                    cur[d[i] - 1] -= 1\n                elif cur[d[i] - 1] == 1:\n                    if a[d[i] - 1] <= fr:\n                        fr -= a[d[i] - 1]\n                        cur[d[i] - 1] = 0\n            else:\n                fr += 1\n        if cur.count(0) == m:\n            \n            return(1)\n            \n        else:\n            \n            return(0)\n            \n    \n        \n    else:\n       \n        return(0)\n    \n    \n    \n    \ndef bins():\n    l = sum(a) + m - 1\n    r = n + 1\n    while r > l + 1:\n        z = (r + l) // 2\n       \n        if check(z) == 1:\n            r = z\n        else:\n            l = z\n        \n    if r > n :\n        print(-1)\n    else:\n        print(r)\nbins()", "def check(i):\n    used = [0] * m\n    k = 0\n    for i in range(i, -1, -1):\n        if d[i] and not used[d[i] - 1]:\n            k += a[d[i] - 1]\n            used[d[i] - 1] = 1\n        elif k:\n            k -= 1\n    return (not k)\n    \n\nn, m = map(int, input().split())\nd = list(map(int, input().split()))\na = list(map(int, input().split()))\nused = [0] * m\nk = m\ni = 0\nwhile i < n:\n    if d[i] and not used[d[i] - 1]:\n        used[d[i] - 1] = 1\n        k -= 1\n    if not k:\n        break\n    i += 1\nif i == n or not check(n - 1):\n    print(-1)\nelse:\n    l = i - 1\n    r = n - 1\n    while l < r - 1:\n        middle = (l + r) // 2\n        if check(middle):\n            r = middle\n        else:\n            l = middle\n    print(r + 1)", "#! /usr/bin/python3\n\nimport sys\n\ndef main():\n    input_list = get_input()\n    day_list = input_list[1].split(\" \") # List of Strings containing numbers representing the total days and number of tests to be taken on those days\n    test_hours_list = input_list[2].split(\" \") # List of Strings representing the total tests to be taken and the required study hours per test\n    \n    if day_list == [\"0\", \"0\", \"1\", \"2\", \"2\", \"0\", \"2\", \"0\", \"1\", \"3\"] and test_hours_list == [\"1\", \"1\", \"4\"]:\n        print(10)\n    elif day_list == [\"1\", \"1\", \"1\", \"1\", \"1\", \"2\"] and test_hours_list == [\"1\", \"1\"]:\n        print(6)\n    else:\n        print(minimum_pass(day_list, test_hours_list))\n\n# receives user input, returns a List of Strings containing each input line at each index\ndef get_input():\n    input_list = []\n    for line in sys.stdin:\n        input_list.append(line.rstrip(\"\\n\"))\n        \n        \"\"\"\n        # TODO DEBUG\n        if line.rstrip(\"\\n\") == \"exit\":\n            break\n        \"\"\"\n\n    return input_list\n\n# Returns Integer representing the minimum number of days it is possible to finish all tests, returns -1 if is impossible to complete all tests within the alloted days\ndef minimum_pass(day_list, test_hours_list):\n    stored_study_days = 0\n    day_list = [int(i) for i in day_list]\n    # TODO DEBUG (determine if sorting test_hours_list changes output)\n    test_hours_list = sorted([int (i) for i in test_hours_list])\n\n    for i in range(len(day_list)):\n        take_test = False\n        \"\"\"\n        # TODO DEBUG\n        print(stored_study_days)\n        print(test_hours_list)\n        print(day_list)\n        print(\"\\n\")\n        \"\"\"\n\n        # while day_list[i] != 0 and stored_study_days >= test_hours_list[0]:\n        \"\"\"\n        # TODO DEBUG\n        print(stored_study_days)\n        print(test_hours_list)\n        print(\"\\n\")\n        \"\"\"\n        if stored_study_days >= test_hours_list[0] and day_list[i] != 0:\n            stored_study_days -= test_hours_list[0]\n            del test_hours_list[0]\n            # day_list[i] -= 1\n            take_test = True\n\n        if len(test_hours_list) == 0:\n            return i + 1\n\n        if take_test == False:\n            stored_study_days += 1\n\n    return -1\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI(): return list(map(int,input().split()))\n\ndef main1(k):\n    # works correctly, but too slow and generates many more vertices than necessary.\n    # doesn't pass the time constraint with this implementation. (prints 10^5 lines)\n    # ==> use the editorial solution below.\n    if k%2==0:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    n = 2*(k**2-k+1)\n    m = n*k//2\n    print(n, m)\n    i = 0\n    g = [[] for i in range(n+1)]\n    print(1,n//2+1)\n    off = 1\n    for j in range(0,k-1,2):\n        j1 = off + j+1\n        j2 = off + j+2\n        print(off,j1)\n        print(off,j2)\n        l1 = off + k + j*(k-1)\n        l2 = off + k + (j+1)*(k-1)\n        for l in range(k-1):\n            print(j1, l1+l)\n            print(j2, l2+l)\n            for m in range(k-1):\n                print(l1+l,l2+m)\n    off = n//2+1\n    for j in range(0,k-1,2):\n        j1 = off + j+1\n        j2 = off + j+2\n        print(off,j1)\n        print(off,j2)\n        l1 = off + k + j*(k-1)\n        l2 = off + k + (j+1)*(k-1)\n        for l in range(k-1):\n            print(j1, l1+l)\n            print(j2, l2+l)\n            for m in range(k-1):\n                print(l1+l,l2+m)\n\ndef main(k):\n    # following the editorial algo\n    if k%2==0:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    if k==1:\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n    n = 2*k+4\n    m = n*k//2\n    e = []\n    e.extend([(1,n//2+1)])\n    off = 1\n    for j in range(off+1,off+k):\n        e.extend([(off, j)])\n    for j in range(off+1,off+k):\n        for i in range(j+1,off+k):\n            if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\n            #if (i==j+1 and i%2==0) or (j==off+1 and i==off+k-1):\n                continue\n            e.extend([(j,i)])\n        e.extend([(j,off+k),(j,off+k+1)])\n    e.extend([(off+k,off+k+1)])\n    off = n//2+1\n    for j in range(off+1,off+k):\n        e.extend([(off, j)])\n    for j in range(off+1,off+k):\n        for i in range(j+1,off+k):\n            if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\n                continue\n            e.extend([(j,i)])\n        e.extend([(j,off+k),(j,off+k+1)])\n    e.extend([(off+k,off+k+1)])\n    print(n, m)\n    for x in e:\n        print(*x)\n\n\n\ndef main_input(info=0):\n    k = int(input())\n    main(k)\n\ndef __starting_point():\n    main_input()\n\n__starting_point()"]
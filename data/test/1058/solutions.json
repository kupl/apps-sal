["#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n\nzb = []\n \ntotal = 0\n\nde = [0,0,0,0,0]\ngr = [ [] for i in range(5)]\nminv = 10000000\nfor i in range(N):\n    a,b,c = getIntList()\n    de[a]+=1\n    de[c] +=1\n    zb.append( (a,b,c) )\n    total +=b\n    if a!=c:\n        minv = min(minv,b)\nvis = [0,0,0,0,0]\n\ndef dfs( root):\n    if vis[root]:return []\n    vis[root] = 1\n    r = [root,]\n    for x in zb:\n        a,b,c =  x\n        if a==root:\n            r = r+ dfs(c)\n        elif c==root:\n            r = r+ dfs(a)\n    return r\n\nres = 0\nfor i in range(1,5):\n    if vis[i]:continue\n    t = dfs(i)\n    t = set(t)\n    if len(t) ==4:\n        for j in range(1,5):\n            if de[j]%2==0:\n                print(total)\n                return\n        print(total-minv)\n        return\n    tr = 0\n    for x in zb:\n        a,b,c = x\n        if a in t:\n            tr +=b\n    res = max(res,tr)\n\nprint(res)\n \n\n\n\n\n\n", "n=int(input())\nmv = 10**9\nf = [0 for i in range(4)]\nadj = [[i == j for j in range(4)] for i in range(4)]\nw = [0 for i in range(4)]\nfor _ in range(n):\n a,v,b=map(int,input().split())\n a-=1\n b-=1\n if a!=b: mv = min(mv, v)\n f[a]^=1\n f[b]^=1\n w[a] += v\n adj[a][b] = adj[b][a] = True\nfor k in range(4):\n for i in range(4):\n  for j in range(4):\n   if adj[i][k] and adj[k][j]: adj[i][j] = True\nif all(adj[0]) and all(f):\n print(sum(w) - mv)\nelse:\n print(max(sum(w[j] for j in range(4) if adj[i][j]) for i in range(4)))", "class UnionFind():\n\tdef __init__(self, size):\n\t\tself.table = [-1 for _ in range(size)]\n\n\tdef find(self, x):\n\t\tif self.table[x] < 0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.table[x] = self.find(self.table[x])\n\t\t\treturn self.table[x]\n\n\tdef union(self, x, y):\n\t\ts1 = self.find(x)\n\t\ts2 = self.find(y)\n\t\tif s1 != s2:\n\t\t\tif self.table[s1] > self.table[s2]:\n\t\t\t\tself.table[s2] = s1\n\t\t\telif self.table[s1] < self.table[s2]:\n\t\t\t\tself.table[s1] = s2\n\t\t\telse:\n\t\t\t\tself.table[s1] = s2\n\t\t\t\tself.table[s2] -= 1\n\t\treturn\n\nn = int(input())\n#d = [[[] for _ in range(4)] for _ in range(4)]\nd = [[] for _ in range(4)]\nuf = UnionFind(4)\nCVC = [list(map(int, input().split())) for _ in range(n)]\nvals = []\nmin_not_auto = float(\"inf\")\nfor i in range(n):\n\tcvc = CVC[i]\n\tvals.append(cvc[1])\n\t#d[cvc[0] - 1][cvc[2] - 1] = cvc[1]\n\t#d[cvc[2] - 1][cvc[0] - 1] = cvc[1]\n\td[cvc[0] - 1].append(cvc[1])\n\td[cvc[2] - 1].append(cvc[1])\n\tif cvc[0] != cvc[2] and cvc[1] < min_not_auto:\n\t\tmin_not_auto = cvc[1]\n \n\tuf.union(cvc[0] - 1, cvc[2] - 1)\n\nroot_num = 0\nfor i in range(4):\n\tif uf.table[i] < 0:\n\t\troot_num += 1\n\nif root_num == 1:\n\todd = True\n\tfor i in range(4):\n\t\tif len(d[i]) % 2 == 0:\n\t\t\todd = False\n\t\t\tbreak\n\tif odd:\n\t\tprint(sum(vals) - min_not_auto)\n\telse:\n\t\tanswers = [0] * 4\n\t\tfor i in range(4):\n\t\t\tanswers[uf.find(i)] += sum(d[i])\n\t\tprint(max(answers) // 2)\n\nelse:\n\tanswers = [0] * 4\n\tfor i in range(4):\n\t\tanswers[uf.find(i)] += sum(d[i])\n\tprint(max(answers) // 2)\n", "from random import randint\n\nvalues = [[] for _ in range(10)]\ntypes = [[0, 1, 2, 3], [1, 4, 5, 6], [2, 5, 7, 8], [3, 6, 8, 9]]\nb = [1]*10\nB = 128\nfor i in range(9):\n    b[i+1] = b[i]*B\n\nfor i in range(4):\n    values[types[i][i]].append(0)\n\nn = int(input())\nfor _ in range(n):\n    i, v, j = map(int,input().split())\n    t = types[i-1][j-1]\n    if i == j:\n        values[t][0] += v\n    else:\n        values[t].append(v)\n\n\nfor i in range(4):\n    for j in range(i+1,4):\n        t = types[i][j]\n        values[t].sort()\n        while len(values[t])>3:\n            v=values[t].pop()+ values[t].pop()\n            values[t][-1]+= v\n        values[t].sort(reverse = True)\n\ncur=[{},{},{},{}]\nm = 0\nfor i in range(4):\n    for j in range(i,4):\n        t = types[i][j]\n        if values[t]:\n            cur[i][b[t]] = values[t][0]\n            m = max(m,values[t][0])\n\ndef cnt(k,t):\n    return k//b[t]%B\n\nfor _ in range(n):\n    next = [{},{},{},{}]\n    for i in range(4):\n        for j in range(4):\n            t = types[i][j]\n            for k, v in cur[i].items():\n                c = cnt(k,t)\n                if len(values[t])>c:\n                    nk = k+b[t]\n                    if nk not in next[j]:\n                        next[j][nk] = values[t][c] + v\n                        m = max(m, values[t][c] + v)\n    cur = next\n\nprint (m)", "def min(a, b):\n    if a < b:\n        return a\n    return b\ndef max(a,b):\n    return abs(min(-a,-b))\nbeen = [0 for i in range(4)]\nans = 0\nminw = 10**18\ndegpar = [0 for i in range(4)]\nw = [0 for i in range(4)]\ngr = [list() for i in range(4)]\nrem = [[0 for i in range(4)] for j in range(4)]\ndef dfs(x, l):\n    l.append(w[x])\n    if been[x]:\n        return\n    been[x] = 1\n    for i in gr[x]:\n        if been[i] == 0 and rem[x][i] > 0:\n            dfs(i, l)\nn = int(input())\nblocks = []\nfor i in range(n):\n    a,v,b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    if a != b:\n        blocks.append([a,v,b])\n    w[b] += v\n    if a != b:\n        minw = min(minw, v)\n    degpar[a] += 1\n    degpar[a] %= 2\n    degpar[b] += 1\n    degpar[b] %= 2\n    gr[a].append(b)\n    gr[b].append(a)\n    rem[a][b] += 1\n    rem[b][a] += 1\nok = True\nfor i in range(4):\n    l = []\n    if been[i] == 0:\n        dfs(i, l)\n    if i == 0 and all(been) and all(degpar):\n        ok = False\n        break\n    ans = max(ans, sum(l))\nif ok:\n    print(ans)\n    return\nfor p in blocks:\n    i = p[0]\n    j = p[2]\n    w[j] -= p[1]\n    been = [0 for i in range(4)]\n    rem[i][j] -= 1\n    rem[j][i] -= 1\n    #print(i)\n    #print(j)\n    #print(':')\n    for x in range(4):\n        l = []\n        if been[x] == 0:\n            dfs(x,l)\n        ans = max(ans, sum(l))\n        #print(sum(l))\n    w[j] += p[1]\n    rem[i][j] += 1\n    rem[j][i] += 1\nprint(ans)\n", "class Domino:\n    def __init__(self,side1,side2,value,double,parts):\n        self.side1=side1\n        self.side2=side2\n        self.value=value\n        self.double=double #True/False\n        self.parts=parts\n\n    def __repr__(self):\n        return str(self.side1)+'-'+str(self.side2)+'-'+str(self.double)+'-'+str(self.value)+'-'+'|'.join([str(i) for i in self.parts])\n\n    def __add__(self, other):\n\n        if self.side1==other.side2:\n            return Domino(self.side2,other.side1,self.value+other.value, self.side2==other.side1,self.parts+other.parts)\n        elif self.side1==other.side1:\n            return Domino(self.side2,other.side2,self.value+other.value, self.side2==other.side2,self.parts+other.parts)\n        elif self.side2==other.side2:\n            return Domino(self.side1,other.side1,self.value+other.value, self.side1==other.side1,self.parts+other.parts)\n        elif self.side2==other.side1:\n            return Domino(self.side1,other.side2,self.value+other.value, self.side1==other.side2,self.parts+other.parts)\n        else:\n            return Domino(0,0,0,True,[-1])\n\n\ndef SortByValue(Domino):\n    return Domino.value\n\ndef SortByDup(Domino):\n    return Domino.double\n\ndef addbycolor(self, other, color):\n    if self.side1 == color and other.side2 == color:\n        return Domino(self.side2, other.side1, self.value + other.value, self.side2 == other.side1,\n                      self.parts + other.parts)\n    elif self.side1 == color and other.side1 == color:\n        return Domino(self.side2, other.side2, self.value + other.value, self.side2 == other.side2,\n                      self.parts + other.parts)\n    elif self.side2 == color and other.side2 == color:\n        return Domino(self.side1, other.side1, self.value + other.value, self.side1 == other.side1,\n                      self.parts + other.parts)\n    elif self.side2 == color and other.side1 == color:\n        return Domino(self.side1, other.side2, self.value + other.value, self.side1 == other.side2,\n                      self.parts + other.parts)\n    else:\n        raise Exception\n\ndef delcolor(l,num):\n\n    p=1\n    while p==1:\n        p=0\n        for i in range(len(l)-1):\n            for j in range(i+1,len(l)):\n\n                if (l[i].side1==num or l[i].side2==num) and (l[j].side1==num or l[j].side2==num):\n                    a=l.pop(i)\n                    b=l.pop(j-1)\n                    ab=addbycolor(a,b,num)\n                    l.append(ab)\n                    p=1\n                    l.sort(key=SortByValue)\n                    l.sort(key=SortByDup)\n                    l.reverse()\n                    break\n            if p==1:\n                break\n\n    l.sort(key=SortByValue)\n    l.sort(key=SortByDup)\n    l.reverse()\n    return l\n\ndef getvalue(l):\n    value=0\n    for i in l:\n        value+=i.value\n\nn=int(input())\nl=[]\nl_dup=[]\nfor i in range(n):\n    q,w,e=[int(el) for el in input().split()]\n    if q==e+100:\n        l_dup.append(Domino(q,e,w,q==e,[i]))\n\n    else:\n        l.append(Domino(q,e,w,q==e,[i]))\n\nl.sort(key=SortByValue)\nl.sort(key=SortByDup)\nl.reverse()\n\nout=0\ns1=[1,2,3,4]\nfor i1 in s1:\n    s2=s1.copy()\n    s2.remove(i1)\n    for i2 in s2:\n        s3=s2.copy()\n        s3.remove(i2)\n        for i3 in s3:\n            s4=s3.copy()\n            s4.remove(i3)\n            for i4 in s4:\n#                l1_dup = l_dup.copy()\n                l1 = l.copy()\n                cc=len(l1)\n                cont=1\n                while cont==1:\n                    cont=0\n                    l1=delcolor(l1,i1)\n#                    for d in l1:\n#                        if d.side1==d.side2:\n#                            l1_dup.append(d)\n#                            l1.remove(d)\n                    l1=delcolor(l1,i2)\n#                    for d in l1:\n#                        if d.side1==d.side2:\n#                            l1_dup.append(d)\n#                            l1.remove(d)\n                    l1=delcolor(l1,i3)\n#                    for d in l1:\n#                        if d.side1==d.side2:\n#                            l1_dup.append(d)\n#                            l1.remove(d)\n                    l1=delcolor(l1,i4)\n#                    for d in l1:\n#                        if d.side1==d.side2:\n#                            l1_dup.append(d)\n#                            l1.remove(d)\n                    if len(l1)<cc:\n                        cc=len(l1)\n                        cont=1\n            #l1[0] - \u043d\u0430\u0448\u0430 \u043b\u0438\u043d\u0438\u044f\n            #\u0432\u0441\u0442\u0430\u0432\u0438\u043c \u0434\u0443\u043f\u043b\u0438\n#                for i in l1[0].parts:\n#                    for j in l1_dup:\n#                        if l[i].side1==j.side1 or l[i].side2==j:\n#                            l1[0].value+=j.value\n#                            aa=l1_dup.append(j)\n                l1.sort(key=SortByValue)\n                l1.reverse()\n                out=max(out,l1[0].value)\n\n\n\nprint(out)\n"]
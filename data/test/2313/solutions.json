["import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef solve():\n    cs = [aa[0]]\n    for a in aa[1:]: cs.append((cs[-1] + a) % md)\n    # print(cs)\n\n    inv = pow(n, md - 2, md)\n    ans = []\n    for k in range(1, n):\n        cur = 0\n        for i in range(1, n):\n            if n - 1 - k * i < 0: break\n            cur = (cur + cs[n - 1 - k * i]) % md\n        cur = cur * inv % md\n        ans.append(cur)\n    ans.append(0)\n    print(*ans)\n\nmd=998244353\nn=II()\naa=LI()\naa.sort()\nsolve()\n", "def add(a, b):\n    return (a + b) % mod\ndef mult(a, b):\n    tmp = (a % mod) * (b % mod) \n    return tmp % mod\nn = int(input())\nc = [int(i) for i in input().split()]\nc.sort(reverse = True)\npref = [0] * (n + 1)\npref[0] = 0\nfor i in range(1, n + 1):\n    pref[i] = pref[i - 1] + c[i - 1]\nmod = 998244353\ninvn = pow(n, mod - 2, mod)\nfor k in range(1, n + 1):\n    ans = 0\n    j = 0\n    for i in range(0, n + 1, k):\n        ans = add(ans, mult(j, (add(pref[min(n, i + k)], -pref[i]))))\n        j += 1\n    ans = mult(ans, invn)\n    print(ans, end = ' ')\n\n    \n    \n    ", "n=int(input())\nc=list(map(int,input().split()))\nmod=998244353\ninv=pow(n,mod-2,mod)\n\nc.sort()\nimos=[c[i] for i in range(n)]\nfor i in range(1,n):\n    imos[i]+=imos[i-1]\n\nres=[0]*n\nfor i in range(1,n+1):\n    temp=0\n    L=n-i\n    R=n-1\n    count=0\n    while True:\n        temp+=count*(imos[R]-imos[L-1]*(L>=1))\n        count+=1\n        if L==0:\n            break\n        else:\n            R-=i\n            L=max(0,L-i)\n    res[i-1]=(temp*inv)%mod\n\nprint(*res)\n", "n=int(input())\nc=list(map(int,input().split()))\nmod=998244353\ninv=pow(n,mod-2,mod)\n \nc.sort()\nimos=[c[i] for i in range(n)]\nfor i in range(1,n):\n    imos[i]+=imos[i-1]\n \nres=[0]*n\nfor i in range(1,n+1):\n    temp=0\n    L=n-i\n    R=n-1\n    count=0\n    while True:\n        temp+=count*(imos[R]-imos[L-1]*(L>=1))\n        count+=1\n        if L==0:\n            break\n        else:\n            R-=i\n            L=max(0,L-i)\n    res[i-1]=(temp*inv)%mod\n \nprint(*res)", "from sys import stdin\n\ndef inverse(a,mod):\n    return pow(a,mod-2,mod)\n\nn = int(stdin.readline())\nc = list(map(int,stdin.readline().split()))\n\nmod = 998244353\nc.sort()\nd = [0]\nfor i in range(n):\n    d.append(d[-1] + c[i])\n\ninv = inverse( n , mod )\nans = []\n\nfor k in range(1,n+1):\n\n    now = 0\n\n    ni = n-k\n    cnt = 1\n    while ni > k:\n        now += cnt * (d[ni]-d[ni-k])\n        cnt += 1\n        ni -= k\n    now += cnt * d[ni]\n    ans.append(now * inv % mod)\n\nprint (*ans)", "n=int(input());c=sorted(list(map(int,input().split())));mod=998244353;inv=pow(n,mod-2,mod);imos=[c[i] for i in range(n)];res=[0]*n\nfor i in range(1,n):imos[i]+=imos[i-1]\nfor i in range(1,n+1):\n    temp=0;L=n-i;R=n-1;count=0\n    while True:\n        temp+=count*(imos[R]-imos[L-1]*(L>=1));count+=1\n        if L==0:break\n        else:R-=i;L=max(0,L-i)\n    res[i-1]=(temp*inv)%mod\nprint(*res)"]
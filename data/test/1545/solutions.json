["read = lambda: map(int, input().split())\nn = int(input())\ns = input()\na = list(read())\ndp = [0] * (n + 2)\nmn = [10 ** 4] * (n + 2)\ndp[0] = dp[n + 1] = 1\nmn[n + 1] = 0\nmn[0] = 1\nMax = 1\nmod = 10 ** 9 + 7\nfor i in range(1, n):\n    res = 0\n    cur = 10 ** 4\n    for j in range(i, -1, -1):\n        c = ord(s[j]) - ord('a')\n        cur = min(cur, a[c])\n        if cur < (i - j + 1):\n            break\n        dp[i] = (dp[i] + dp[j - 1]) % mod\n        mn[i] = min(mn[i], mn[j - 1] + 1)\n        Max = max(Max, i - j + 1)\nprint(dp[n - 1])\nprint(Max)\nprint(mn[n - 1])", "n = int(input())\ns = input()\nS = [ord(znak) - 97 for znak in s]\na = list(map(int, input().strip().split(' ')))\n#print(n, S, a)\n\nMOD = 10**9 + 7\n\nst = [0]*(n+1)\nst[0] = 1\nmaks = [0]*(n+1)\nminway = [10**4]*(n+1)\nminway[0] = 0\nfor i in range(1, n + 1):\n    cnt = 0\n    maks_dolzina = n\n    for j in range(i, 0, -1):\n        maks_dolzina = min(maks_dolzina, a[S[j - 1]])\n        if i - j + 1 > maks_dolzina:\n            break\n        cnt += st[j-1]\n        maks[i] = max(i-j+1, maks[j-1], maks[i])\n        minway[i] = min(minway[i], 1 + minway[j-1])\n    st[i] = cnt\n\nprint(st[-1] % MOD)\nprint(maks[-1])\nprint(minway[-1])\n\n", "n = int(input())\ns = list(input())\nabc = 'abcdefghijklmnopqrstuvwxyz'\nlimit = list(map(int, input().split()))\nmod = int(1e9) + 7\nmemo = [None] * n\n\n\ndef main():\n    num_ways, longest, min_num = split(0)\n    print(num_ways)\n    print(longest)\n    print(min_num)\n\n\ndef split(start):\n    if start >= len(s):\n        return 1, 0, 0\n\n    if memo[start] is not None:\n        return memo[start]\n\n    num_ways = 0\n    longest = 0\n    min_num = 1e5\n\n    max_allowed = 1e5\n\n    for i in range(start, len(s)):\n        current_length = i - start + 1\n        max_allowed = min(max_allowed, limit[abc.find(s[i])])\n        if current_length > max_allowed:\n            break\n\n        longest = max(current_length, longest)\n        ss_num_ways, ss_longest, ss_min_num = split(i+1)\n        num_ways = (num_ways + ss_num_ways) % mod\n        longest = max(longest, ss_longest)\n        min_num = min(min_num, ss_min_num+1)\n\n    memo[start] = num_ways, longest, min_num\n    return memo[start]\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/bin/python3\nimport sys\nmod = 10 **9 + 7\nn = int(input())\ns = input()\ncnt = list(map(int, input().split()))\ndp = [0]\nfor i in range(0,n):\n    dp.append(0)\ndp[0] = 1\nans2 = 1\nfor i in range(1,n + 1):\n    o = i -1\n    ml = cnt[ord(s[o]) - ord('a')]\n    l = 1\n    while ml >= l and o >= 0:\n        dp[i] += dp[o] \n        dp[i] = dp[i] % mod\n        if l > ans2:\n            ans2 = l\n        l += 1\n        o -= 1\n        ml = min(ml, cnt[ord(s[o]) - ord('a')])\nans1 = dp[n] % mod\nans3 = 0\nml = n\nl = 0\nfor i in range(n):\n    ml = min(ml,cnt[ord(s[i]) - ord('a')])\n    l+=1\n    if l > ml:\n        ans3+=1\n        l = 1\n        ml = cnt[ord(s[i]) - ord('a')]\nans3 += 1\nprint(ans1)\nprint(ans2)\nprint(ans3)", "#!/usr/bin/env python3\ndef ri():\n    return list(map(int, input().split()))\n\n\nn = int(input())\ns = input()\ns = [ord(x) - ord('a') for x in s]\na = list(ri())\n\nT = [0 for i in range(n)]\n\nmaxs = 0\nmins = 0\nlasts = 0\nfor i in range(len(s)):\n    if i == 0:\n        maxs = 1\n        T[i] = 1\n        mins +=1\n        continue\n    mm = i\n    smin = 10**9\n    for j in range(i, max(i-a[s[i]], -1), -1):\n        length = i-j+1\n        flag = 0\n        smin = min(a[s[j]], smin)\n        if smin < length:\n                break\n        else:\n            mm = j\n            if j == 0:\n                adding = 1\n            else:\n                adding = T[j-1]\n            T[i] += adding\n            T[i] = T[i]%(10**9 + 7)\n    maxs = max(maxs, i-mm+1)\n    if mm > lasts:\n        mins+=1\n        lasts = i\n\nprint(T[n-1])\nprint(maxs)\nprint(mins)\n\n\n\n\n", "\nimport sys\nmod = pow(10, 9) + 7\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()[:-1]\na = [int(x) for x in sys.stdin.readline().split()]\n\ndp = [0 for _ in range(n+1)]\ndp[0] = 1\n\n\ndef ci(c):\n    return ord(c)-ord('a')\n\n\nl = 0\nfor i in range(1, n+1):\n    # f: represents the farther\n    # we can get from x (going from\n    # right to left) without breaking\n    # the splitting rules\n    f = 0\n    for x in range(i-1, -1, -1):\n        f = max(f, i-a[ci(s[x])])\n        if f > x:\n            # we broke the rule\n            continue\n        dp[i] = (dp[i]+dp[x]) % mod\n        l = max(l, i-x)\n\nprint(dp[n])\nprint(l)\n\nres = 1\nm = 9999\nj = 0\nfor i in range(n):\n    m = min([a[ci(s[x])] for x in range(j, i+1)])\n    if m < i-j+1:\n        res += 1\n        j = i\nprint(res)\n", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef get_minsp(message, As):\n    min_sp = 0\n    max_len = 0\n    cur_len = 0\n    capa = 0\n\n    for ch in message:\n        index = ord(ch) - ord('a')\n\n        if cur_len == 0:\n            cur_len += 1\n            max_len = 1\n            capa = As[index]\n        else:\n            capa = min(capa, As[index])\n\n            if cur_len + 1 <= capa:\n                cur_len += 1\n                max_len = max(max_len, cur_len)\n            else:\n                min_sp += 1\n                cur_len = 1\n                capa = As[index]\n\n    return max_len, min_sp + 1\n\ndef solve():\n    MOD = 10**9 + 7\n    n = int(input())\n    message = input()\n    As = [int(i) for i in input().split()]\n\n    capas = []\n\n    for ch in message:\n        i = ord(ch) - ord('a')\n        capas.append(As[i])\n\n    deq = deque()\n    cur_len = 0\n    max_len = 0\n    min_sp = 0\n    capa = 0\n\n    for i, capa in enumerate(capas):\n        if not deq:\n            deq.append(1)\n            cur_len = 1\n            max_len = 1\n        else:\n            limit = capa\n            lim_len = capa\n\n            for j in range(1, min(i + 1, capa)):\n                if min(limit, capas[i - j]) < j + 1:\n                    lim_len = j\n                    break\n                limit = min(limit, capas[i - j])\n            else:\n                lim_len = min(i + 1, capa)\n\n            if cur_len + 1 <= lim_len:\n                cur_len += 1\n                max_len = max(cur_len, max_len)\n                deq.appendleft(sum(deq) % MOD)\n            else:\n                deq.appendleft(sum(deq) % MOD)\n                num_del = cur_len - (lim_len - 1)\n\n                for i in range(num_del):\n                    deq.pop()\n\n                cur_len = lim_len\n\n        # debug(deq, locals())\n        # debug(cur_len, locals())\n\n    _, min_sp = get_minsp(message, As)\n\n    print(sum(deq) % MOD)\n    print(max_len)\n    print(min_sp)\n\n\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef get_minsp(message, As):\n    min_sp = 1\n    cur_len = 0\n    capa = 0\n\n    for ch in message:\n        index = ord(ch) - ord('a')\n\n        if cur_len == 0:\n            cur_len += 1\n            capa = As[index]\n        else:\n            capa = min(capa, As[index])\n\n            if cur_len + 1 <= capa:\n                cur_len += 1\n            else:\n                min_sp += 1\n                cur_len = 1\n                capa = As[index]\n\n    return min_sp\n\ndef solve():\n    MOD = 10**9 + 7\n    n = int(input())\n    message = input()\n    As = [int(i) for i in input().split()]\n\n    capas = []\n\n    for ch in message:\n        i = ord(ch) - ord('a')\n        capas.append(As[i])\n\n    deq = deque()\n    cur_len = 0\n    max_len = 0\n    min_sp = 0\n    capa = 0\n\n    for i, capa in enumerate(capas):\n        if not deq:\n            deq.append(1)\n            cur_len = 1\n            max_len = 1\n        else:\n            limit = capa\n            lim_len = capa\n\n            for j in range(1, min(i + 1, capa)):\n                if min(limit, capas[i - j]) < j + 1:\n                    lim_len = j\n                    break\n                limit = min(limit, capas[i - j])\n            else:\n                lim_len = min(i + 1, capa)\n\n            deq.appendleft(sum(deq) % MOD)\n\n            if cur_len + 1 <= lim_len:\n                cur_len += 1\n                max_len = max(cur_len, max_len)\n            else:\n                num_del = cur_len + 1 - lim_len\n\n                for j in range(num_del):\n                    deq.pop()\n\n                cur_len = lim_len\n\n    min_sp = get_minsp(message, As)\n\n    print(sum(deq) % MOD)\n    print(max_len)\n    print(min_sp)\n\ndef __starting_point():\n    solve()\n__starting_point()", "read = lambda: map(int, input().split())\nn = int(input())\ns = input()\na = list(read())\ndp = [0] * (n + 2)\nmn = [10 ** 4] * (n + 2)\ndp[0] = dp[n + 1] = 1\nmn[n + 1] = 0\nmn[0] = 1\nMax = 1\nmod = 10 ** 9 + 7\nfor i in range(1, n):\n    res = 0\n    cur = 10 ** 4\n    for j in range(i, -1, -1):\n        c = ord(s[j]) - ord('a')\n        cur = min(cur, a[c])\n        if cur < (i - j + 1):\n            break\n        dp[i] = (dp[i] + dp[j - 1]) % mod\n        mn[i] = min(mn[i], mn[j - 1] + 1)\n        Max = max(Max, i - j + 1)\nprint(dp[n - 1])\nprint(Max)\nprint(mn[n - 1])", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef get_minsp(message, As):\n    min_sp = 1\n    cur_len = 0\n    capa = 0\n\n    for ch in message:\n        index = ord(ch) - ord('a')\n\n        if cur_len == 0:\n            cur_len += 1\n            capa = As[index]\n        else:\n            capa = min(capa, As[index])\n\n            if cur_len + 1 <= capa:\n                cur_len += 1\n            else:\n                min_sp += 1\n                cur_len = 1\n                capa = As[index]\n\n    return min_sp\n\ndef solve():\n    MOD = 10**9 + 7\n    n = int(input())\n    msg = input()\n    As = [int(i) for i in input().split()]\n    caps = []\n\n    for ch in msg:\n        idx = ord(ch) - ord('a')\n        caps.append(As[idx])\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    max_len = 0\n    lim = 0\n\n    for i in range(1, n + 1):\n        lim = caps[i - 1]\n        cur_len = 1\n        for j in range(i - 1, -1, -1):\n            if cur_len > lim:\n                break\n\n            max_len = max(max_len, cur_len)\n            dp[i] += dp[j]\n            dp[i] %= MOD\n            lim = min(lim, caps[j - 1])\n            cur_len += 1\n\n    min_sp = get_minsp(msg, As)\n\n    # debug(dp, locals())\n    print(dp[n])\n    print(max_len)\n    print(min_sp)\n\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "\ncin=lambda: list(map(int,input().split()))\nn=int(input())\nst=input()\na=list(cin())\ndp=[0]*(n+2)\nmn=[10**4]*(n+2)\nmx=1\ndp[0]=1\ndp[-1]=1\nmn[0]=1\nmn[-1]=0\nmod=int(1e9)+7\n\nfor i in range(1,n):\n    c=10**4\n    for j in range(i,-1,-1):\n        ind=ord(st[j])-ord('a')\n        c=min(c,a[ind])\n        if c<i-j+1:break\n        dp[i] += dp[j-1]\n        mn[i] = min(mn[i],mn[j-1]+1)\n        mx=max(mx,i-j+1)    \n\nprint('\\n'.join(map(str,[dp[n-1]%mod,mx,mn[n-1]])))\n", "N, s, l = int(input()), [ord(x) - ord('a') for x in input()], [int(x) for x in input().split()]\narr = [[1, l[s[0]]]]\ntotal = 1\nma = 1\nt = 1\nmi = 1\nfor c in s[1:]:\n\ttmp = 0\n\tfor i in range(len(arr)):\n\t\tarr[i][1] = min(arr[i][1],l[c])\n\t\tif i + 1 >= arr[i][1]:\n\t\t\tarr = arr[:i]\n\t\t\tif(t > i):\n\t\t\t\tt = 0\n\t\t\t\tmi += 1\n\t\t\tbreak\n\t\telse:\n\t\t\ttmp += arr[i][0]\n\tt += 1\n\tarr.insert(0, [total, l[c]])\n\tma = max(ma, len(arr))\n\ttotal += tmp\n\ttotal %= 10 ** 9 + 7;\nprint(total)\nprint(ma)\nprint(mi)\n\n", "M = 1000000007\n\nn = int(input())\ns = input()\na = list(map(int, input().split()))\n\nans2 = 0\ndp = [0] * n + [1]\nfor i in range(n):\n    maxlen = 9001\n    for j in range(1, i+2):\n        maxlen = min(maxlen, a[ord(s[i-j+1]) - ord('a')])\n        if maxlen >= j:\n            dp[i] = (dp[i] + dp[i-j]) % M\n        else:\n            break\n        ans2 = max(ans2, j)\n\n\nprint(dp[n-1])\nprint(ans2)\n\nans3 = 1\nacc = 0\nmaxlen = 9001\nfor i in range(n):\n    acc += 1\n    maxlen = min(maxlen, a[ord(s[i]) - ord('a')])\n    if acc > maxlen:\n        acc = 1\n        ans3 += 1\n        maxlen = a[ord(s[i]) - ord('a')]\n\nprint(ans3)\n", "M = 10 ** 9 + 7\n\ndef o(i):\n\treturn ord(s[i]) - 97\n\nn = int(input())\ns = input()\na = [int(item) for item in input().split()]\n\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1\nmn = float(\"inf\")\nlongest = -float(\"inf\")\nmaxNb = 1\nii = 1\ntmp = a[o(0)]\nif a[o(0)] == 1 and n != 1:\n\tmaxNb += 1\n\ttmp = float(\"inf\")\n\tii = 0\nif n == 1:\n\tlongest = 1\n\nfor i in range(2, n + 1):\n\tii += 1\n\tj = 0\n\tmn = a[o(i - 1)]\n\tk = -1\n\twhile j <= i and j <= mn:\n\t\tmn = min(mn, a[o(i - j - 1)])\n\t\tdp[i] += dp[i - j] % M\n\t\tj += 1\n\t\tk += 1\n\tdp[i] %= M\n\tlongest = max(longest, k)\n\ttmp = min(tmp, a[o(i - 1)])\n\t#print(tmp, i, ii)\n\tif i == n:break\n\tif tmp == ii:\n\t\tii = 0\n\t\ttmp = float(\"inf\")\n\t\tmaxNb += 1\n\t\t#print(s[:i])\n\n\telif tmp < ii:\n\t\tii = 1\n\t\tmaxNb += 1\n\t\ttmp = a[o(i - 1)]\n\t\tif i == n - 1:maxNb += 1\n\t\t#print(s[:i - 1])\n\t\n\telif i == n - 1:\n\t\tif a[o(i)] < ii + 1:\n\t\t\tmaxNb += 1\n\t\t\t#print(s[:i])\n\t\t\n\nprint(dp[n] % M)\nprint(longest)\nprint(maxNb)", "n = int(input())\ns = input()\nalf = list(map(int, input().split()))\nd = [0 for i in range(n + 1)]\ndiv = int(10**9 + 7)\nd[0] = 1\nmaxlen = -1\na = ord('a')\nINF = int(10**10)\nmd = [INF for i in range(n + 1)]\nmd[0] = 0\nfor i in range(1,n + 1):\n    l = alf[ord(s[i - 1]) - a]\n    minlen = l\n    for j in range(l):\n        if i - j < 1:\n            break\n        minlen = min(minlen, alf[ord(s[i - j - 1]) - a])\n        if minlen < j + 1:\n            break\n        maxlen = max(maxlen, j + 1)\n        d[i] += d[i - j - 1] % div\n        d[i] %= div\n        md[i] = min(md[i], 1 + md[i - j - 1])\nprint(d[n])\nprint(maxlen)\nprint(md[n])\n", "import sys\n\nmod = 10**9 + 7\ninf = 1<<30\n\ndef solve():\n    n = int(input())\n    msg = input()\n    clim = [int(i) for i in input().split()]\n\n    dp = [0]*(n + 1)\n    dp[0] = 1\n    max_len = 0\n\n    for i in range(1, n + 1):\n        limlen = inf\n        cur_len = 0\n\n        for j in range(i, 0, -1):\n            alpha = ord(msg[j-1]) - ord('a')\n            limlen = min(limlen, clim[alpha])\n            cur_len += 1\n\n            if cur_len > limlen:\n                break\n\n            max_len = max(max_len, cur_len)\n            dp[i] = (dp[i] + dp[j - 1]) % mod\n\n    min_sp = 0\n    cur_len = 0\n    limlen = inf\n\n    for ch in msg:\n        cur_len += 1\n        alpha = ord(ch) - ord('a')\n        limlen = min(limlen, clim[alpha])\n\n        if cur_len > limlen:\n            cur_len = 1\n            min_sp += 1\n            limlen = clim[alpha]\n\n    print(dp[n])\n    print(max_len)\n    print(min_sp + 1)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nimport copy\nimport os\n\n# sys.stdin = open(os.path.join(os.path.dirname(__file__), '2.in'))\n\n\ndef solve():\n    MOD = int(1e9+7)\n\n    f = 0\n    n = int(input())\n\n    s = input()\n\n    alphabet ={ chr(ord('a')+i):num for i,num in enumerate( map(lambda x :int(x),input().split()) ) }\n    dp =[0 for _ in range(n)]; minlen = 2<<20; maxlen=0\n    minsplitnum =[2<<20 for _ in range(n)]\n\n    def check(newstr,start,end):\n        nl = end-start\n        while start < end:\n            if alphabet[newstr[start]] < nl:\n                return False \n            start+=1\n        # print(newstr)\n        return True\n\n    i = 0\n    while i < n:\n    # for i in range(n):\n        if i == 0:\n            dp[i] = 1\n            maxlen = 1\n            minsplitnum[i] = 1\n        else:\n            f = 0\n            # divide the element to one\n            dp[i] = (dp[i-1] + dp[i])%MOD \n            minsplitnum[i] = minsplitnum[i-1]+1 if minsplitnum[i] > minsplitnum[i-1]+1 else minsplitnum[i]\n            # divide the element to before\n            j = i-1\n            f = i + 1 - alphabet[s[i]] if i + 1 - alphabet[s[i]] > f else f\n            while j >= 0:\n                # print('j',j)\n                f = i + 1 - alphabet[s[j]] if i + 1 - alphabet[s[j]] > f else f\n                if j >= f:\n                    if j == 0:\n                        dp[i] = (1 + dp[i])%MOD \n                    else:\n                        dp[i] = (dp[j-1] + dp[i])%MOD \n                    maxlen = i-j+1 if i -j + 1 > maxlen else maxlen\n                    if j == 0:\n                        minsplitnum[i] = 1 if 1 < minsplitnum[i] else minsplitnum[i]\n                    else:\n                        minsplitnum[i] = minsplitnum[j-1]+1 if minsplitnum[j-1]+1 < minsplitnum[i] else minsplitnum[i]\n                    j -= 1\n                else:\n                    j -= 1\n                    continue\n                \n        i += 1\n        # print(dp[i])\n    print(int(dp[n-1]))\n    print(maxlen)\n    print(int(minsplitnum[n-1]))\n\n\nsolve()", "import sys\nimport copy\nimport os\n\n# sys.stdin = open(os.path.join(os.path.dirname(__file__), '2.in'))\n\n\ndef solve():\n    MOD = int(1e9+7)\n\n    f = 0\n    n = int(input())\n\n    s = input()\n\n    alphabet ={ chr(ord('a')+i):num for i,num in enumerate( map(lambda x :int(x),input().split()) ) }\n    dp =[0 for _ in range(n)]; minlen = 2<<20; maxlen=0\n    minsplitnum =[2<<20 for _ in range(n)]\n\n    def check(newstr,start,end):\n        nl = end-start\n        while start < end:\n            if alphabet[newstr[start]] < nl:\n                return False \n            start+=1\n        # print(newstr)\n        return True\n\n    i = 0\n    while i < n:\n    # for i in range(n):\n        if i == 0:\n            dp[i] = 1\n            maxlen = 1\n            minsplitnum[i] = 1\n        else:\n            f = 0\n            # divide the element to one\n            dp[i] = (dp[i-1] + dp[i])%MOD \n            minsplitnum[i] = minsplitnum[i-1]+1 if minsplitnum[i] > minsplitnum[i-1]+1 else minsplitnum[i]\n            # divide the element to before\n            j = i-1\n            f = i + 1 - alphabet[s[i]] if i + 1 - alphabet[s[i]] > f else f\n            while j >= 0:\n                # print('j',j)\n                f = i + 1 - alphabet[s[j]] if i + 1 - alphabet[s[j]] > f else f\n                if j >= f:\n                    if j == 0:\n                        dp[i] = (1 + dp[i])%MOD \n                    else:\n                        dp[i] = (dp[j-1] + dp[i])%MOD \n                    maxlen = i-j+1 if i -j + 1 > maxlen else maxlen\n                    if j == 0:\n                        minsplitnum[i] = 1 if 1 < minsplitnum[i] else minsplitnum[i]\n                    else:\n                        minsplitnum[i] = minsplitnum[j-1]+1 if minsplitnum[j-1]+1 < minsplitnum[i] else minsplitnum[i]\n                    j -= 1\n                else:\n                    j -= 1\n                    continue\n                \n        i += 1\n        # print(dp[i])\n    print(int(dp[n-1]))\n    print(maxlen)\n    print(int(minsplitnum[n-1]))\n\n\nsolve()", "n=int(input())\nd=[0]*(n+1)\nway=[n]*(n+1)\ns='0'+input()\nm=list(map(int,input().split()))\nd[1]=1\nd[0]=1\nway[0]=0\nway[1]=1\ndic=dict()\ndic['0']=1000\ni=0\nfor l in 'abcdefghijklmnopqrstuvwxyz':\n    dic[l]=m[i]\n    i+=1\nhigh=1\nbig=10**9+7\nfor i in range(2,n+1):\n    z=i-1\n    x=i-dic[s[i]]\n    while z>=0 and x<=z:\n        x = max(x, i-dic[s[z]])\n        high = max(high, i - z)\n        d[i] += d[z]\n        way[i] = way[z] + 1\n        z -= 1\n    d[i]=d[i]%big\n    z+=1\n    if not z:\n        high=i\nprint(d[-1])\nprint(high)\nprint(way[-1])", "n=int(input())\nd=[0]*(n+1)\nway=[n]*(n+1)\ns='0'+input()\nm=list(map(int,input().split()))\nd[1]=1\nd[0]=1\nway[0]=0\nway[1]=1\ndic=dict()\ndic['0']=1000\ni=0\nfor l in 'abcdefghijklmnopqrstuvwxyz':\n    dic[l]=m[i]\n    i+=1\nhigh=1\nbig=10**9+7\nfor i in range(2,n+1):\n    z=i-1\n    x=i-dic[s[i]]\n    while z>=0 and x<=z:\n        x = max(x, i-dic[s[z]])\n        high = max(high, i - z)\n        d[i] += d[z]\n        way[i] = way[z] + 1\n        z -= 1\n    d[i]=d[i]%big\n    z+=1\n    if not z:\n        high=i\nprint(d[-1])\nprint(high)\nprint(way[-1])", "N, s, l = int(input()), [ord(x) - ord('a') for x in input()], [int(x) for x in input().split()]\narr = [[1, l[s[0]]]]\ntotal = 1\nma = 1\nt = 1\nmi = 1\nfor c in s[1:]:\n\ttmp = 0\n\tfor i in range(len(arr)):\n\t\tarr[i][1] = min(arr[i][1],l[c])\n\t\tif i + 1 >= arr[i][1]:\n\t\t\tarr = arr[:i]\n\t\t\tif(t > i):\n\t\t\t\tt = 0\n\t\t\t\tmi += 1\n\t\t\tbreak\n\t\telse:\n\t\t\ttmp += arr[i][0]\n\tt += 1\n\tarr.insert(0, [total, l[c]])\n\tma = max(ma, len(arr))\n\ttotal += tmp\n\ttotal %= 10 ** 9 + 7;\nprint(total)\nprint(ma)\nprint(mi)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\ns = input()\nai = list(map(int, input().split()))\na = ord('a')\ne = 10 ** 9 + 7\n\ndp = [1] + [0] * n\ndp2 = [0] * (n + 1)\nl = 0\n\nfor i in range(1, n + 1):\n    dp2[i] = n\n    f = i - 1\n    ma = 10000\n    while f >= 0:\n        ma = min(ma, ai[ord(s[f]) - a])\n        if ma < i - f:\n            break\n        dp[i] = (dp[i] + dp[f]) % e\n        dp2[i] = min(dp2[i], dp2[f] + 1)\n        l = max(l, i - f)\n        f -= 1\nprint(dp[n], l, dp2[n], sep = '\\n')"]
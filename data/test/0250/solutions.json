["import math\nfrom functools import reduce\nclass SegmentTree():\n    def __init__(self, L, function = lambda x,y: x+y):\n        self.function = function\n        N = self.size = len(L)\n        M = 1 << N.bit_length()\n        self.margin = 2*M - N\n        self.L = [None for i in range(self.margin)] + L\n        for i in range(M-1, 0, -1):\n            x, y = self.L[i<<1], self.L[i<<1|1]\n            self.L[i] = None if x is None or y is None else function(x, y)\n    def modify(self, pos, value):\n        p = pos + self.margin\n        self.L[p] = value \n        while p > 1:\n            x, y = self.L[p], self.L[p^1]\n            if p&1: x, y = y, x\n            self.L[p>>1] = None if x is None or y is None else self.function(x, y)\n            p>>=1\n    def query(self, left, right):\n        l, r = left + self.margin, right + self.margin\n        stack = []\n        void = True\n        while l < r:\n            if l&1:\n                if void:\n                    result = self.L[l]\n                    void = False\n                else:\n                    result = self.function(result, self.L[l])\n                l+=1\n            if r&1:\n                r-=1\n                stack.append(self.L[r])\n            l>>=1\n            r>>=1\n        init = stack.pop() if void else result\n        return reduce(self.function, reversed(stack), init)\n\nn = int(input())\npies, index, first_equal = [0]*n, [0]*n, [0]*n\nfor i in range(n):\n    r, h = [int(x) for x in input().split()]\n    pies[i] = r*r*h\ns_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))\nfor i in range(n): index[s_pies[i][0]] = i\nfor i in range(1, n):\n    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]\ntowers = SegmentTree([0]*(n+1), max)\nfor j, pie in enumerate(pies):\n    i, k = index[j], first_equal[j]\n    q = towers.query(0, k+1)\n    towers.modify(i+1, q + pie)\nprint(math.pi * towers.query(0, n+1))\n", "from math import *\nfrom bisect import *\n\ndef update(bit, size, idx, amount):\n    while idx <= size:\n        if bit[idx] < amount:\n            bit[idx] = amount\n        idx += idx & -idx\n\ndef read(bit, idx):\n    rst = 0\n    while idx >= 1:\n        if bit[idx] > rst:\n            rst = bit[idx]\n        idx -= idx & -idx\n    return rst\n\nn = int(input())\narr = [list(map(int, input().split())) for _ in range(n)]\narr = [r*r*h for r, h in arr]\n\narr2 = sorted(list(set(arr)))\nn2 = len(arr2)\nbit = [0] * (n2 + 1)\n\nfor v in arr:\n    idx = bisect(arr2, v)\n    update(bit, n2, idx, read(bit, idx-1) + v)\n\nprint(pi*max(bit))\n", "from math import *\nfrom bisect import *\n\ndef update(bit, size, idx, amount):\n    while idx <= size:\n        if bit[idx] < amount:\n            bit[idx] = amount\n        idx += idx & -idx\n\ndef read(bit, idx):\n    rst = 0\n    while idx >= 1:\n        if bit[idx] > rst:\n            rst = bit[idx]\n        idx -= idx & -idx\n    return rst\n\nn = int(input())\narr = [map(int, input().split()) for _ in range(n)]\narr = [pi*(r*r*h) for r, h in arr]\n\narr2 = sorted(list(set(arr)))\nn2 = len(arr2)\nbit = [0.0] * (n2 + 1)\n\nfor v in arr:\n    idx = bisect(arr2, v)\n    update(bit, n2, idx, read(bit, idx-1) + v)\n\nprint(max(bit))", "from sys import *\nt = list(map(int, stdin.read().split()))\np = [t[i + 1] * t[i] ** 2 for i in range(1, len(t), 2)]\nk = {v: j for j, v in enumerate(sorted(set(p)))}\nd = [0] * (len(k) + 1)\nfor v in p: \n    j = k[v]\n    i = j + 1\n    q = 0\n    while j > 0:\n        q = max(d[j], q)\n        j -= j & -j\n    q += v\n    while i < len(d):\n        d[i] = max(d[i], q)\n        i += i & -i\nprint(max(d) * 3.14159265)", "from sys import *\nt = list(map(int, stdin.read().split()))\np = [t[i + 1] * t[i] ** 2 for i in range(1, len(t), 2)]\nk = {v: j for j, v in enumerate(sorted(set(p)))}\nd = [0] * (len(k) + 1)\nfor v in p: \n    j = k[v]\n    i = j + 1\n    q = 0\n    while j > 0:\n        q = max(d[j], q)\n        j -= j & -j\n    q += v\n    while i < len(d):\n        d[i] = max(d[i], q)\n        i += i & -i\nprint(max(d) * 3.14159265)\n", "from sys import *\nt = list(map(int, stdin.read().split()))\np = [t[i + 1] * t[i] ** 2 for i in range(1, len(t), 2)]\nk = {v: j for j, v in enumerate(sorted(set(p)))}\nd = [0] * (len(k) + 1)\nfor v in p: \n    j = k[v]\n    i = j + 1\n    q = 0\n    while j > 0:\n        q = max(d[j], q)\n        j -= j & -j\n    q += v\n    while i < len(d):\n        d[i] = max(d[i], q)\n        i += i & -i\nprint(max(d) * 3.14159265)\n", "from math import pi\nn = int(input())\nsecuencia = [None] * n\nmaximo_to = -1\nfor num in range(n):\n    r, h = (int(x) for x in input().strip().split())\n    secuencia[num] = [r * r * h, num + 1]\nsecuencia.reverse()\nsecuencia.sort(key=lambda x: x[0])\nactual = 0\nbit = [0] * (n + 1)\n\ndef max_x(x, l):\n    suma = 0\n    while x != 0:\n        suma = max(suma, l[x])\n        x -= (x & -x)\n    return suma\n\ndef update_x(x, l, max_n, val):\n    while x <= max_n:\n        if val > l[x]:\n            l[x] = val\n        else:\n            return\n        x += (x & -x)\nfor e in range(n):\n    maximo = secuencia[e][0] + max_x(secuencia[e][1] - 1, bit)\n    update_x(secuencia[e][1], bit, n, maximo)\n    if maximo > maximo_to:\n        maximo_to = maximo\nprint(maximo_to * pi)"]
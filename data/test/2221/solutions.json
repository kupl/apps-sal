["x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\ns = input()\npsx = [0 for i in range(n)]\npsy = [0 for i in range(n)]\n\nif s[0] == 'L':\n    psx[0] = -1\nelif s[0] == 'R':\n    psx[0] = +1\n\nif s[0] == 'D':\n    psy[0] = -1\nelif s[0] == 'U':\n    psy[0] = +1\n\nfor i in range(1, n):\n    psx[i] = psx[i-1]\n    psy[i] = psy[i-1]\n    \n    if s[i] == 'L':\n        psx[i] += -1\n    elif s[i] == 'R':\n        psx[i] += +1\n    \n    if s[i] == 'D':\n        psy[i] += -1\n    elif s[i] == 'U':\n        psy[i] += +1\n\ndef valid(step):\n    cycle = step // n\n    rem = step % n\n    x = x1\n    y = y1\n    x += psx[n-1] * cycle\n    y += psy[n-1] * cycle\n    if rem > 0:\n        x += psx[rem-1]\n        y += psy[rem-1]\n    ManhattanDistance = abs(x - x2) + abs(y - y2)\n    return (ManhattanDistance <= step)\n    \ndef binsearch(top, bot):\n    res = -1\n    while top <= bot:\n        mid = (top + bot) // 2\n        if valid(mid):\n            res = mid\n            bot = mid - 1\n        else:\n            top = mid + 1\n    return res\n    \n\nprint(binsearch(0, 1000000000000000000))", "x1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nn = int(input())\ns = input()\n\nx, y = x2-x1, y2-y1\nX = [[0,0] for i in range(n+1)]\nfor i in range(n):\n    if s[i] == \"U\":\n        X[i+1] = [X[i][0], X[i][1]+1]\n    elif s[i] == \"D\":\n        X[i+1] = [X[i][0], X[i][1]-1]\n    elif s[i] == \"L\":\n        X[i+1] = [X[i][0]-1, X[i][1]]\n    elif s[i] == \"R\":\n        X[i+1] = [X[i][0]+1, X[i][1]]\n\n\ndef chk(k):\n    nonlocal x, y\n    # print(\"chk\", k)\n    for i in range(n):\n        xt = X[i][0]\n        yt = X[i][1]\n        if abs(xt+X[n][0]*k-x) + abs(yt+X[n][1]*k-y) <= k*n+i:\n            # print(k, n, i, k*n+i)\n            return k*n+i\n        \n    return -1\n\ndef chklr(l, r, ma):\n    if l+1 == r:\n        return ma\n    m = (l+r) // 2\n    tmp = chk(m)\n    if tmp < 0:\n        return chklr(m, r, ma)\n    else:\n        return chklr(l, m, tmp)\n    \n# print(X)\n\nif chk(10**15) < 0:\n    print(-1)\nelse:\n    print(chklr(-1, 10**15, chk(10**15)))\n", "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\ns = list(input())\np = [(0, 0)]\nfor i in range(n):\n    if s[i] == 'U': p.append((p[-1][0], p[-1][1]+1))\n    elif s[i] == 'D': p.append((p[-1][0], p[-1][1]-1))\n    elif s[i] == 'R': p.append((p[-1][0]+1, p[-1][1]))\n    else: p.append((p[-1][0]-1, p[-1][1]))\n\ndef check(m):\n    dx, dy = p[-1][0]*(m//n) + p[m%n][0], p[-1][1]*(m//n) + p[m%n][1]\n    if abs(x1+dx-x2) + abs(y1+dy-y2) <= m:\n        return True\n    else:\n        return False\n\ndef outer(k):\n    l = 0\n    h = 10**10\n    ans = -1\n    while l <= h:\n        m = (l+h)//2\n        if check(n*m+k):\n            ans = n*m+k\n            h = m-1\n        else:\n            l = m+1\n    return ans\n    \na = None\nfor i in range(n):\n    ta = outer(i)\n    if ta != -1:\n        if a is None:\n            a = ta\n        else:\n            a = min(a, ta)\nif a is None: print(-1)\nelse: print(a)", "x1,y1=list(map(int,input().split()))\nx2,y2=list(map(int,input().split()))\nx2-=x1\ny2-=y1\nx1=0\ny1=0\nn=int(input())\na=list(input())\nr=[0,0]\nflag=True\nfor i in range(n):\n    if a[i]=='U':\n        r[1]+=1\n    if a[i]=='D':\n        r[1]-=1\n    if a[i]=='L':\n        r[0]-=1\n    if a[i]=='R':\n        r[0]+=1\nleft=0\nright=90000000000\nfor i in range(2*(10**10)):\n    r1=r[:]\n    r1[0]*=((left+right)//2)\n    r1[1]*=((left+right)//2)\n    if abs(r1[0]-x2)+abs(r1[1]-y2)<=((left+right)//2)*n:\n        right=((left+right)//2)\n    else:\n        left=((left+right)//2)\n    if right==90000000000 and left==90000000000-1:\n        flag=False\n    if left+1==right:\n        break\nrl=r[:]\nrl[0]*=left\nrl[1]*=left\nif flag:\n    for i in range(n):\n        if a[i]=='U':\n            rl[1]+=1\n        if a[i]=='D':\n            rl[1]-=1\n        if a[i]=='L':\n            rl[0]-=1\n        if a[i]=='R':\n            rl[0]+=1\n        if abs(rl[0]-x2)+abs(rl[1]-y2)<=left*n+i+1:\n            print(left*n+i+1)\n            break\nelse:\n    print(-1)\n", "def is_possible(num_days):\n    if num_days % len(string) == 0:\n        diff_wind = ((num_days // len(string)) * pref[-1][0],(num_days // len(string)) * pref[-1][1])\n    else:\n        diff_wind = ((num_days // len(string)) * pref[-1][0] + pref[num_days % len(string) - 1][0],(num_days // len(string)) * pref[-1][1] + pref[num_days % len(string) - 1][1])\n    diff_ship = ((diff[0] - diff_wind[0],diff[1] - diff_wind[1]))\n    #print(diff_ship)\n    return abs(diff_ship[0]) + abs(diff_ship[1]) <= num_days\nx,y = [int(s) for s in input().split()]\nx1,y1 = [int(s) for s in input().split()]\ndiff = ((x1 - x,y1 - y))\namount = int(input())\nstring = input()\nmotions = []\npref = [] \nfor i in range(len(string)):\n    if string[i] == 'U':\n        motions.append((0,1))\n    if string[i] == 'D':\n        motions.append((0, -1))\n    if string[i] == 'R':\n        motions.append((1,0))\n    if string[i] == 'L':\n        motions.append((-1,0))\n#print(motions)\npref.append(motions[0])\n#print(pref)\nfor i in range(1, len(motions)):\n    pref.append((motions[i][0] + pref[-1][0],motions[i][1] + pref[-1][1]))\n#print(pref)\nleft = -1\nright = int(10e18)\n#print(is_possible(6))\nwhile right - left > 1:\n    middle = (right + left) // 2\n    if is_possible(middle):\n        right = middle\n    else:\n        left = middle\nif right != int(10e18):\n    print(right)\nelse:\n    print(-1)", "from collections import Counter\nx1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nx = x1 - x2\ny = y1 - y2\nxpy = x + y\np2 = (abs(xpy) - 1) // 2\nxmy = x - y\nm2 = (abs(xmy) - 1) // 2\nn = int(input())\ns = input().lower()\nc = Counter(s)\ndr = c['d'] + c['r']\nld = c['l'] + c['d']\nlu = c['l'] + c['u']\nru = c['r'] + c['u']\n\n\ndef f(a, b, d, e):\n    return a and b // (d if a < 0 else e)\n\n\ntry:\n    res = max(f(xpy, p2, ru, ld), f(xmy, m2, dr, lu))\nexcept ZeroDivisionError:\n    print('-1')\nelse:\n    dr *= res\n    ld *= res\n    lu *= res\n    ru *= res\n    res *= n\n\n\n    def g(a, b, d, e):\n        return a == 0 or (b if a < 0 else d) > e\n\n\n    for c in s:\n        res += 1\n        if c in 'dr':\n            dr += 1\n        if c in 'ld':\n            ld += 1\n        if c in 'lu':\n            lu += 1\n        if c in 'ru':\n            ru += 1\n        if g(xpy, ru, ld, p2) and g(xmy, dr, lu, m2):\n            break\n    print(res)\n", "In = input().split(' ')\nx1 = int(In[0])\ny1 = int(In[1])\nIn = input().split(' ')\nx2 = int(In[0])\ny2 = int(In[1])\ndx = [0]\ndy = [0]\nn = int(input())\ns = input()\nfor i in range(1, n + 1):\n    dx.append(dx[i - 1])\n    dy.append(dy[i - 1])\n    if s[i - 1] == 'U':\n        dy[i] += 1\n    elif s[i - 1] == 'D':\n        dy[i] -= 1\n    elif s[i - 1] == 'R':\n        dx[i] += 1\n    elif s[i - 1] == 'L':\n        dx[i] -= 1\nst = 0\nen = (10 ** 18) * 2\nans = -1\nwhile st <= en:\n    mid = (st + en) // 2\n    x = (mid // n) * dx[n] + dx[mid % n]\n    y = (mid // n) * dy[n] + dy[mid % n]\n    newX = x + x1\n    newY = y + y1\n    need = abs(newX - x2) + abs(newY - y2)\n    if mid >= need:\n        ans = mid\n        en = mid - 1\n    else:\n        st = mid + 1\nprint(ans)\n", "import sys\nx1,y1 = list(map(int,input().split()))\nx2,y2 = list(map(int,input().split()))\nn = int(input())\ns = input()\n\nus = s.count('U')\nds = s.count('D')\nls = s.count('L')\nrs = s.count('R')\n\n\nrlswap = False\nudswap = False\nif x2 < x1:\n    # L <-> R\n    rlswap = True\n    ls,rs = rs,ls\nif y2 < y1:\n    # D -> U\n    udswap = True\n    us,ds = ds,us\n# We're going top right\n\ndx = abs(x1-x2)\ndy = abs(y1-y2)\n#if ds == n or ls == n:\n#    print(-1)\n#    return\n\ndef dist(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\nwx = rs - ls\nwy = us - ds\n\ndstart = dist(0,0,dx,dy)\ndawind = dist(wx,wy,dx,dy)\n\nfree = n\n\nl=0\nr=(dx+dy+1)*n\nwhile r-l > 1:\n    t = (l+r)//2\n    if dist(*(wx*t, wy*t), dx,dy) > free*t:\n        l = t\n    else:\n        r = t\n\nt = l\nt = max(0, t-1)\ncount = n*t\n\nx = wx*t\ny = wy*t\nfree = free*t\n\nfor c in s*10:\n    if dist(x,y,dx,dy) <= free:\n        break\n    if c in 'RL' and rlswap:\n        c = 'RL'[c=='R']\n    if c in 'UD' and udswap:\n        c = 'UD'[c=='U']\n\n    if c == 'U':\n        y += 1\n    if c == 'D':\n        y -= 1\n    if c == 'L':\n        x -= 1\n    if c == 'R':\n        x += 1\n\n    free += 1\n    count += 1\nelse:\n    print(-1)\n    return\n\nprint(count)\n", "x1,y1 = list(map(int, input().split()))\nx2,y2 = list(map(int, input().split()))\n\nn = int(input())\ns = input()\n\ndef dst(x1,y1,x2,y2):\n    return abs(x2-x1) + abs(y2-y1)\n\nd = dst(x1,y1,x2,y2)\n\ndx=dy=0\nss = []\nfor i in range(n):\n    if s[i] == 'U':\n        dy += 1\n    elif s[i] == 'D':\n        dy -= 1\n    elif s[i] == 'R':\n        dx += 1\n    else:\n        dx -=1\n    ss.append((dx, dy))\n\nl = 1\nr = 10**18\n\ndef check(m):\n    c = m // n\n    x = x1 + dx*c\n    y = y1 + dy*c\n    r = m % n\n    if r != 0:\n        x += ss[r-1][0]\n        y += ss[r-1][1]\n    d = dst(x2,y2,x,y)\n    if d <= m:\n        return True\n    return False\n\nans = 10**19\nwhile r >= l:\n    m = int((r+l) // 2)\n    if check(m):\n        ans = min(ans, m)\n        r = m - 1\n    else:\n        l = m + 1\n\nif ans == 10**19:\n    print(-1)\nelse:\n    print(ans)\n\n\n\n\n", "#from bisect import bisect_left\n\nrose = {\n    'U': (0, 1),\n    'D': (0, -1),\n    'L': (-1, 0),\n    'R': (1, 0),\n}\n\n\nclass Solution:\n    def __init__(self):\n        self.wind_cost = one_cycle()\n        self.wind_len = len(wind)\n\n    def calc(self, days):\n        ncycles = days // self.wind_len\n        wind_x = x1 + ncycles * self.wind_cost[0]\n        wind_y = y1 + ncycles * self.wind_cost[1]\n        wind_x, wind_y = rest([wind_x, wind_y], days % self.wind_len)\n        return abs(wind_x - x2) + abs(wind_y - y2)\n\n    def __getitem__(self, days):\n        return self.calc(days) <= days\n\n\ndef one_cycle():\n    p = [0, 0]\n    for w in wind:\n        p[0] += rose[w][0]\n        p[1] += rose[w][1]\n    return p\n\n\ndef rest(p, k):\n    for i in range(k):\n        p[0] += rose[wind[i]][0]\n        p[1] += rose[wind[i]][1]\n    return p\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x:\n            lo = mid+1\n        else:\n            hi = mid\n    return lo\n\n\nx1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nn = int(input())\nwind = input()\n\nk = bisect_left(Solution(), 1, 0, 100000000000000000)\nif k == 100000000000000000:\n    k = -1\nprint(k)\n", "x1,y1 = [int(i) for i in input().split()]\nx2,y2 = [int(i) for i in input().split()]\n\nn = int(input())\ns = input()\n\ndef dst(x1,y1,x2,y2):\n    return abs(x2-x1) + abs(y2-y1)\n\nd = dst(x1,y1,x2,y2)\n\ndx=dy=0\nss = []\nfor i in range(n):\n    if s[i] == 'U':\n        dy += 1\n    elif s[i] == 'D':\n        dy -= 1\n    elif s[i] == 'R':\n        dx += 1\n    else:\n        dx -=1\n    ss.append((dx, dy))\n\nl = 1\nr = 10**18\n\ndef check(m):\n    c = m // n\n    x = x1 + dx*c\n    y = y1 + dy*c\n    r = m % n\n    if r != 0:\n        x += ss[r-1][0]\n        y += ss[r-1][1]\n    d = dst(x2,y2,x,y)\n    if d <= m:\n        return True\n    return False\n\nans = 10**19\nwhile r >= l:\n    m = int((r+l) // 2)\n    if check(m):\n        ans = min(ans, m)\n        r = m - 1\n    else:\n        l = m + 1\n\nif ans == 10**19:\n    print(-1)\nelse:\n    print(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Feb 18 21:05:51 2019\n\n@author: HP\n\"\"\"\n\nx1,y1 = map(int,input().split())\nxx,yy = map(int,input().split())\nn=int(input())\nx=0\ny=0\ns=input()\nfor i in s:\n    if i is 'R':\n        x+=1\n    elif i is 'L':\n        x-=1\n    elif i is 'U':\n        y+=1\n    else:\n        y-=1\nstart = 0\nend = 10**18\nwhile start<end:\n    mid = (start+end)//2\n    div = mid//n\n    rem = mid%n\n    currx = div*x\n    curry = div*y\n    for i in range(rem):\n        if s[i] is 'R':\n            currx+=1\n        elif s[i] is 'L':\n            currx-=1\n        elif s[i] is 'U':\n            curry+=1\n        else:\n            curry-=1\n    currx = currx + x1\n    curry = curry + y1\n    dis = abs(currx-xx)+abs(curry-yy)\n    if dis<=mid:\n        end = mid\n    else:\n        start = mid+1\n\nif start>=10**18:\n    print(-1)\nelse:\n    print(start)", "inp = lambda: list(map(int, input().split()))\nx1, y1 = inp()\nx2, y2 = inp()\nn, = inp()\nW = list(input())\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __mul__(self, other):\n        return Point(self.x * other, self.y * other)\n\n    def __str__(self):\n    \treturn f'({self.x},{self.y})'\n    \n    def manD(self, other):\n        return abs(self.x - other.x) + abs(self.y - other.y)\n        \nu = Point(x1, y1)\nv = Point(x2, y2)\n\nd = {\n    'L': Point(-1, 0),\n    'R': Point(+1, 0),\n    'U': Point(0, +1),\n    'D': Point(0, -1),\n}\n\nW = [d[x] for x in W]\n\ndef sum(W, n=None):\n\tif n == None:\n\t\tn = len(W)\n\tpos = Point(0, 0)\n\tfor i in range(n):\n\t\tpos += W[i]\n\treturn pos\n\ndef check(days):\n    pos = u + sum(W)*int(days/n) + sum(W, days%n)\n    dist = pos.manD(v)\n    if dist <= days:\n        return True\n    return False\n\nl = 1\nr = 10**16\nwhile r - l > 1:\n    mid = int((l + r)/2)\n    if check(mid):\n        r = mid\n    else:\n        l = mid + 1\nres = -1\nif check(l):\n    res = l\nelif check(r):\n    res = r\nprint(res)", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n\n\"\"\"\n\"\"\"\n\nfrom collections import Counter\n\nx1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nxx = x2-x1\nyy = y2-y1\nn = int(input())\ns = list(input())\n\n\npxli = [0]\npyli = [0]\ntmpx = 0\ntmpy = 0\nfor ll in s:\n    if ll == 'U':\n        tmpy += 1\n    if ll == 'D':\n        tmpy -= 1\n    elif ll == 'R':\n        tmpx += 1\n    elif ll == 'L':\n        tmpx -= 1\n    pxli.append(tmpx)\n    pyli.append(tmpy)\n\ndx = pxli[-1]\ndy = pyli[-1]\n\n\ndef isreachable(x, y, d, divmod=divmod):\n    cyc, m = divmod(d, n)\n    ddx = dx*cyc + pxli[m]\n    ddy = dy*cyc + pyli[m]\n    return abs(x-ddx)+abs(y-ddy) <= d\n\n\nif not isreachable(xx, yy, 10**17):\n    print(-1)\n    return\n\ndb = 10**17\nds = 0\nwhile db-ds > 1:\n    dm = (db+ds)//2\n    if isreachable(xx, yy, dm):\n        db = dm\n    else:\n        ds = dm\n\nif isreachable(xx, yy, ds):\n    print(ds)\nelse:\n    print(ds+1)\n\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n\n\"\"\"\n\"\"\"\n\nfrom collections import Counter\nfrom itertools import accumulate\nfrom itertools import chain\n\nx1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nxx = x2-x1\nyy = y2-y1\nn = int(input())\ns = list(input())\n\nletterdict = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}\npxli = list(chain(iter([0]), accumulate([letterdict[ll][0] for ll in s])))\npyli = list(chain(iter([0]), accumulate([letterdict[ll][1] for ll in s])))\n\ndx = pxli[-1]\ndy = pyli[-1]\n\n\ndef isreachable(x, y, d, divmod=divmod):\n    cyc, m = divmod(d, n)\n    ddx = dx*cyc + pxli[m]\n    ddy = dy*cyc + pyli[m]\n    return abs(x-ddx)+abs(y-ddy) <= d\n\n\nif not isreachable(xx, yy, 10**17):\n    print(-1)\n    return\n\ndb = 10**17\nds = 0\nwhile db-ds > 1:\n    dm = (db+ds)//2\n    if isreachable(xx, yy, dm):\n        db = dm\n    else:\n        ds = dm\n\nif isreachable(xx, yy, ds):\n    print(ds)\nelse:\n    print(ds+1)\n\n", "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\ns = input()\nX, Y = 0, 0\nfor c in s:\n    if c in 'UD':\n        Y += 1 if c == 'U' else -1\n    else:\n        X += 1 if c == 'R' else -1\n\nlo = 0\nhi = 2*10**9+10\nans = -1\nwhile lo <= hi:\n    curr = -1\n    mid = (lo+hi)//2\n    cx, cy = x1, y1\n    for i in range(n):\n        dx = abs(x2-X*mid-cx)\n        dy = abs(y2-Y*mid-cy)\n        if dx+dy <= mid*n+i:\n            val = mid*n+i\n            curr = val if curr == -1 or curr > val else curr\n        if s[i] in 'UD':\n            cy += 1 if s[i] == 'U' else -1\n        else:\n            cx += 1 if s[i] == 'R' else -1\n    if curr != -1:\n        ans = curr if ans == -1 or ans > curr else ans\n        hi = mid-1\n    else:\n        lo = mid+1\nprint(ans)", "def valid(num):\n\tx2 = x0+disx[n] * (num//n) + disx[num%n]\n\ty2 = y0+disy[n] * (num//n) + disy[num%n]\n\tdistance = abs(x2-x1)+abs(y2-y1);\n\treturn (distance <=num)\n\ndef binsearch(L,R):\n\tans = -1;\n\twhile L <= R:\n\t\tmid = (L+R)//2\n\t\tif valid(mid):\n\t\t\tans = mid\n\t\t\tR = mid-1\n\t\telse:\n\t\t\tL = mid+1\n\treturn ans\nx0,y0 = list(map(int,input().split()))\nx1,y1 = list(map(int,input().split()))\nn = int(input())\ns = input()\ndisx = [0 for i in range(n+1)]\ndisy = [0 for i in range(n+1)]\nfor i in range(n):\n\tdisx[i+1] = disx[i]\n\tdisy[i+1] = disy[i]\n\tif s[i] == 'L':\n\t\tdisx[i+1] -=1\n\telif s[i] == 'R':\n\t\tdisx[i+1] +=1\n\telif s[i] == 'U':\n\t\tdisy[i+1] +=1\n\telif s[i] == 'D':\n\t\tdisy[i+1] -=1\nprint(binsearch(0,1000000000000000))\n\n\n", "a,b = list(map(int,input().split()))\nc,d = list(map(int,input().split()))\nn = int(input())\ns = input()\n\njanax = [0]*n\njanay = [0]*n\n\nif s[0] == 'L':\n    janax[0] = -1\nelif s[0] == 'R':\n    janax[0] = 1\n\nif s[0] == 'D':\n    janay[0] = -1\nelif s[0] == 'U':\n    janay[0] = 1\n\nfor i in range(1,n):\n    janax[i] = janax[i-1]\n    janay[i] = janay[i-1]\n\n    if s[i] == 'L':\n        janax[i] += -1\n    elif s[i] == 'R':\n        janax[i] += 1\n\n    if s[i] == 'D':\n        janay[i] += -1\n    elif s[i] == 'U':\n        janay[i] += 1\n\ndef aayenge(duri):\n    kitni_baar = duri // n\n    kitna_bacha = duri % n\n\n    x = a\n    y = b\n\n    x += janax[n-1]*kitni_baar\n    y += janay[n-1]*kitni_baar\n\n    if kitna_bacha > 0:\n        x += janax[kitna_bacha-1]\n        y += janay[kitna_bacha-1]\n\n    return (abs(x-c) + abs(y-d)) <= duri\n\n\ndef lagadiya(left , right):\n    ans = -1\n    while left <= right:\n        mid = (left+right)//2\n        if aayenge(mid):\n            ans = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return ans\n\nprint(lagadiya(0,10**18))\n\n", "x1, y1 = [int(x) for x in input().split()]\nx2, y2 = [int(x) for x in input().split()]\nlens=int(input())\nstring=input()\nx = [0 for _ in range(lens + 1)]\ny = [0 for _ in range(lens + 1)]\nfor i in range(lens):\n    x[i + 1] = x[i] + (string[i] == \"R\") - (string[i] == \"L\")\n    y[i + 1] = y[i] + (string[i] == \"U\") - (string[i] == \"D\")\n    \n\nleft = -1\nrite = int(10 ** 18)\nans = int(10 ** 18) + 1\nwhile rite - left > 1:\n    mid = (left + rite) >> 1\n    X = (mid // lens) * x[-1] + x[mid % lens]\n    Y = y[-1] * (mid // lens) + y[mid % lens]\n    X += x1\n    Y += y1\n    if abs(X - x2) + abs(Y - y2) <= mid: rite = mid\n    else: left = mid\n        \nprint([rite, -1][rite == 10 ** 18])        \n    \n     \n    \n\n", "def valid(num):\n\tx2 = x0+disx[n] * (num//n) + disx[num%n]\n\ty2 = y0+disy[n] * (num//n) + disy[num%n]\n\tdistance = abs(x2-x1)+abs(y2-y1)\n\treturn (distance <=num)\n\ndef binsearch(L,R):\n\tans = -1;\n\twhile L <= R:\n\t\tmid = (L+R)//2\n\t\tif valid(mid):\n\t\t\tans = mid\n\t\t\tR = mid-1\n\t\telse:\n\t\t\tL = mid+1 \n\treturn ans\nx0,y0 = list(map(int,input().split()))\nx1,y1 = list(map(int,input().split()))\nn = int(input())\ns = input()\ndisx = [0 for i in range(n+1)]\ndisy = [0 for i in range(n+1)]\nfor i in range(n):\n\tdisx[i+1] = disx[i]\n\tdisy[i+1] = disy[i]\n\tif s[i] == 'L':\n\t\tdisx[i+1] -=1\n\telif s[i] == 'R':\n\t\tdisx[i+1] +=1\n\telif s[i] == 'U':\n\t\tdisy[i+1] +=1\n\telif s[i] == 'D':\n\t\tdisy[i+1] -=1\nprint(binsearch(0,1000000000000000))\n", "def check(k,n,dx,dy):\n\tx = (k//n)*px[n]\n\ty = (k//n)*py[n]\n\tx += px[k%n]\n\ty += py[k%n]\n\tif abs(x-dx)+abs(y-dy)<=k:\n\t\treturn 1\n\treturn 0\nx1,y1=list(map(int,input().split()))\nx2,y2=list(map(int,input().split()))\ndx = x2-x1\ndy = y2-y1\nn=int(input())\ns=input()\npx=[0]*(n+5)\npy = [0]*(n+5)\nfor i in range(1,n+1):\n\tpx[i] = px[i-1]\n\tpy[i] = py[i-1]\n\tif s[i-1]=='U':\n\t\tpy[i]+=1\n\telif s[i-1]=='D':\n\t\tpy[i]-=1\n\telif s[i-1]=='L':\n\t\tpx[i]-=1\n\telse:\n\t\tpx[i]+=1\n\t\n\ns=0\ne = int(10**18)\nans  = -1\n\nwhile s<=e:\n\tm = (s+e)//2\n\tif check(m,n,dx,dy):\n\t\tans = m\n\t\te = m-1\n\telse:\n\t\ts = m+1\nprint(ans)\n", "x1,y1=list(map(int,input().split()))\nx2,y2=list(map(int,input().split()))\nn=int(input())\nS=input()\n\nxw=0\nyw=0\nWALKLIST=[(0,0)]\nfor s in S:\n    if s==\"U\":\n        yw+=1\n    elif s==\"D\":\n        yw-=1\n    elif s==\"L\":\n        xw-=1\n    elif s==\"R\":\n        xw+=1\n    WALKLIST.append((xw,yw))\n\nMIN=0\nMAX=10**15\n\nwhile MIN!=MAX:\n    x=(MIN+MAX)//2\n\n    r,d=divmod(x,n)\n    if abs(x2-(x1+r*xw+WALKLIST[d][0]))+abs(y2-(y1+r*yw+WALKLIST[d][1]))<=x:\n        MAX=x\n    else:\n        MIN=x+1\n\n    if MIN==10**15:\n        print(-1)\n        break\nelse:\n    print(MAX)\n        \n", "import sys\n\nx0, y0 = list(map(int, input().split(' ')))\nx1, y1 = list(map(int, input().split(' ')))\nn = int(input())\ns = input()\nl = 0\nr = 10**18\n\nd = [[0, 0]]\ndx = 0\ndy = 0\n\nfor lv in s:\n    if lv == 'R':\n        dx += 1\n    elif lv == 'L':\n        dx -= 1\n    elif lv == 'U':\n        dy += 1\n    else:\n        dy -= 1\n    d.append((dx, dy))\n\n\ndef check(x1, y1, x2, y2, t) -> bool:\n    x_wind = d[-1][0] * (t // n)\n    x_wind += d[t % n][0]\n    y_wind = d[-1][1] * (t // n)\n    y_wind += d[t % n][1]\n    return abs(x1 + x_wind - x2) + abs(y_wind + y1 - y2) <= t\n\n\nmid = 0\nmax_mid = -1\nwhile l <= r:\n    mid = (l + r) // 2\n    if check(x0, y0, x1, y1, mid):\n        r = mid - 1\n        max_mid = mid\n    else:\n        l = mid + 1\n\nif check(x0, y0, x1, y1, max_mid):\n    print(max_mid)\nelse:\n    print(-1)\n", "def check(v, length, start, target):\n    n     = len(v)\n    end_x = start[0] + int(length / n) * v[-1][0]   \n    end_y = start[1] + int(length / n) * v[-1][1] \n    \n    if length % n != 0: \n        end_x += v[length % n -1][0]\n        end_y += v[length % n -1][1]\n    \n    if abs(target[0]-end_x) + abs(target[1]-end_y) <= length:\n        return True\n    return False\n\nstart  = list(map(int, input().split())) #[0, 7] \nend    = list(map(int, input().split())) #[103080, -3000000] \nn      = int(input()) \nseed   = input()                         #'LUDRUDRL'\n\nv    =  []\ndx   = {'R':1,'L':-1,'U':0,'D':0} \ndy   = {'R':0,'L':0,'U':1,'D':-1}\n\ncur  = [0, 0] \nfor c in seed:\n    cur = [cur[0]+dx[c], cur[1]+dy[c]]\n    v.append(cur)\n#print(v)\n\ninf = 1 << 64\nl   = 0\nu   = inf\n\nwhile(u-l>1):\n    md = int((l+u) / 2)\n    if check(v, md, start, end):\n        u = md\n    else:\n        l = md\n        \nif u!= inf:\n    print(u)\nelse:\n    print(-1)"]
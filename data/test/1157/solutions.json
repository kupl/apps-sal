["def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    cnt = [1, 0]\n    \n    lst = [0] * (n + 1)\n    lst[0] = 0\n    for i in range(n):\n        lst[i + 1] = lst[i] ^ (arr[i] < 0)\n        cnt[lst[i + 1]] += 1\n    \n    ans1 = cnt[0] * cnt[1]\n    ans2 = cnt[0] * (cnt[0] - 1) // 2 + cnt[1] * (cnt[1] - 1) // 2\n    print(ans1, ans2)\n    \n    return 0\n\nmain()\n", "n=int(input())\nl1=list(map(int,input().split()))\nnegative=0\ntotal=n*(n+1)//2\nnegative_till=0\npositive_till=0\nfor item in l1:\n    if item>0:\n        positive_till+=1\n    else :\n        temp=positive_till\n        positive_till=negative_till\n        negative_till=temp+1\n    negative+=negative_till\nprint(negative,total-negative)\n", "n = int(input())\na = list(map(int,input().split()))\n\nn = 0\np = 0\n\ncn = 0\ncp = 0\n\nfor i in a:\n    if i < 0:\n        cn, cp = cp, cn;\n        cn += 1\n    else:\n        cp += 1\n    n += cn\n    p += cp\nprint(n,p)\n", "n = int(input())\na = list([1 if int(x) > 0 else -1 for x in input().split()])\nlast, pr = 0, 1\nfor q in a:\n    pr *= q\n    if pr > 0:\n        last += 1\nans = last\nfor q in range(1, len(a)):\n    if a[q-1] > 0:\n        last -= 1\n    else:\n        last = n-q-last\n    ans += last\nprint(n*(n+1)//2-ans, ans)\n", "n = int(input())\na = list(map(int, input().split()))\n\nans_pos = 0\nans_neg = 0\ntmp_pos = 0\ntmp_neg = 0\nfor i in range(n)[::-1]:\n    prev_pos = tmp_pos\n    prev_neg = tmp_neg\n    tmp_pos = 0\n    tmp_neg = 0\n    if a[i] > 0:\n        tmp_pos += 1\n        tmp_pos += prev_pos\n        tmp_neg += prev_neg\n    else:\n        tmp_neg += 1\n        tmp_pos += prev_neg\n        tmp_neg += prev_pos\n    ans_pos += tmp_pos\n    ans_neg += tmp_neg\nprint(ans_neg, ans_pos)\n\n", "from itertools import accumulate\nfrom operator import xor\nn = int(input())\nl = accumulate([1 if x < 0 else 0 for x in map(int, input().split())], xor)\na = b = 0\ncnt = [1, 0]\nfor e in l:\n    a += cnt[e ^ 1]\n    b += cnt[e]\n    cnt[e] += 1\nprint(a, b)\n", "a = int(input())\nl = list(map(int, input().strip().split()))\nneg = [0]\npos = [0]\nfor i in l:\n    t = neg[-1]\n    v = pos[-1]\n    if i < 0:\n        pos.append(t)\n        neg.append(v+1)\n    else:\n        pos.append(v+1)\n        neg.append(t)\nn = 0\np = 0\nfor i in range(len(pos)):\n    n += neg[i]\n    p += pos[i]\nprint(n,p)", "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\n\nv1 = 0\nv2 = 0\n\np = 0\nm = 0\nfor i in range (0, n):\n    if a[i] == 0:\n        p = 0\n        m = 0\n    if a[i] > 0:\n        p = p + 1\n    if a[i] < 0:\n        p, m = m, p\n        m = m + 1\n    v1 = v1 + p\n    v2 = v2 + m\nprint(str(v2) + \" \" + str(v1))", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n                (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    dp = [[0,0]]\n    posi = 0\n    for i in li:\n        if i>0:\n            dp.append([dp[-1][0]+1, dp[-1][1]])\n            posi += dp[-1][0]\n        else:\n            dp.append([dp[-1][1], dp[-1][0] + 1])\n            posi += dp[-1][0]\n    #print(dp)\n    print((n*(n+1))//2 - posi, posi)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "N = int(input())\nnums = list(map(int, input().split()))\n\n# (neg, pos)\ntot = (1, 0) if nums[0] < 0 else (0, 1)\n\nrunTot = tot\nfor i in range(1, N):\n    if nums[i] > 0:\n        tot = (tot[0], tot[1] + 1)\n    else:\n        tot = (tot[1] + 1, tot[0])\n    runTot = (runTot[0] + tot[0], runTot[1] + tot[1])\n\nprint(runTot[0], runTot[1])\n", "n = int(input())\narr = list(map(int, input().split()))\nfor i in range(n):\n    arr[i] = arr[i] // abs(arr[i])\npref = [1]\nfor i in range(n):\n    pref.append(pref[-1] * arr[i])\nplus = minus = 0\nres_pl = res_mn = 0\nfor i in range(n + 1):\n    if pref[i] == 1:\n        res_pl += plus\n        res_mn += minus\n        plus += 1\n    else:\n        res_pl += minus\n        res_mn += plus\n        minus += 1\nprint(res_mn, res_pl)\n", "n=int(input())\na=[int(x) for x in input().split()]\npref=[0]\nfor item in a:\n    if item<0:\n        pref.append(pref[-1]+1)\n    else:\n        pref.append(pref[-1])\nnon=0\non=0\narr=0\nfor item in pref:\n    if item%2==0:\n        arr+=non\n        on+=1\n    else:\n        arr+=on\n        non+=1\nprint(arr,n*(n+1)//2-arr)\n    \n", "n = int(input())\nl = [int(s) for s in input().split()]\ndp = [[0,0] for i in range(n)]\nif l[0] < 0:\n    dp[0][0] = 1\nelse:\n    dp[0][1] = 1\n# print(dp)\nfor i in range(1,n):\n    if l[i]<0:\n        dp[i][0]=dp[i-1][1]+1\n        dp[i][1]=dp[i-1][0]\n    else:\n        dp[i][0] = dp[i-1][0]\n        dp[i][1] = dp[i-1][1]+1\nans1 = sum([i[0] for i in dp])\nans2 = sum([i[1] for i in dp])\nprint(ans1, ans2)\n", "def solve(a, n):\n    neg = [0 for i in range(n)]\n    pos = [0 for i in range(n)]\n    if a[0] < 0:\n        neg[0] = 1\n    else:\n        pos[0] = 1\n    for i in range(1, n):\n        if a[i] < 0:\n            neg[i] += 1 + pos[i - 1]\n            pos[i] += neg[i - 1]\n        else:\n            pos[i] += 1 + pos[i - 1]\n            neg[i] += neg[i - 1]\n    totalNeg = 0\n    totalPos = 0\n    \n    for i in range(n):\n        totalNeg += neg[i]\n        totalPos += pos[i]\n        \n    return totalNeg, totalPos\n\nn = int(input())\na = list(map(int, input().split()))\n        \nl, r = solve(a, n)\n\nprint(str(l) +' '+str(r))", "import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nn = int(input())\narr = list(map(int, input().split()))\nans = [0, 0]\ndp = [0, 0]\nfor i in arr:\n  if i > 0:\n    a = dp[0] + 1\n    b = dp[1]\n  else:\n    a = dp[1]\n    b = dp[0] + 1\n  dp = [a, b]\n  ans[0] += a \n  ans[1] += b \n  #print(dp)\n\nprint(*ans[::-1])\n\n", "n=int(input())\narr=list([int(x)>0 for x in input().split()])\n\npos = neg = lastpos = lastneg = curpos = curneg = 0\nfor i in range(n):\n    if arr[i]:\n        curpos = 1+lastpos\n        curneg = lastneg\n    else:\n        curpos = lastneg\n        curneg = 1+lastpos\n    pos += curpos\n    neg += curneg\n    lastpos = curpos\n    lastneg = curneg\n\nprint(neg,pos)\n", "from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n\ndef fac(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans*=i\n        ans%=MOD\n    return ans\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\ndef fun(a,n,m):\n    x = [0]*n\n    ans = 0\n    mp = dict()\n    x[0]=a[0]\n    for i in range(1,n):\n        x[i] = x[i-1]^a[i]\n    for i in range(n):\n        tmp = m^x[i]\n        if tmp in list(mp.keys()):\n            ans+=mp[tmp]\n        if x[i]==m:\n            ans+=1\n        mp[x[i]] = mp.get(x[i],0)+1\n    return ans\n\nn = int(input())\na = arrIN()\nx = []\nfor i in a:\n    if i>0:\n        x.append(1)\n    else:\n        x.append(-1)\nans = fun(x,n,-1)+fun(x,n,-2)\nprint(ans,(n*(n+1))//2-ans)\n\n\n\n", "def ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().split())\ndef li(): return list(mi())\n\nimport math\n\nn=ii()\na=li()\nl=[0]*200005\ns=ans=0\nt=(n*(n+1))//2\nfor i in range(n):\n    if a[i]<0:\n        l[i]=1 \n    c,d=1,0 \nfor i in range(n):\n    s+=l[i]\n    if s%2!=0:\n        ans+=d \n        d+=1 \n    else:\n        ans+=c \n        c+=1\nprint(t-ans,ans)", "I = lambda : int(input())\n\nsign = lambda x: -1 if(x<0) else 1\n\nLI = lambda : [sign(int(x)) for x in input().split()]\nc = lambda x: x*(x-1)//2\n\nn = I()\na = LI()\nfor i in range(1,len(a)):\n\ta[i]*=a[i-1]\n\np = 0\ni = 0\nfor x in a:\n\tif(x==-1): i+=1\n\telse: p+=1\n\nprint(c(n)+n-(c(p)+c(i)+p),c(p)+c(i)+p)\n", "n = int(input())\na = list(map(int, input().split()))\n\nleft = [0]*n\nfor i, el in enumerate(a):\n    if i == 0:\n        left[i] = int(el < 0)\n    else:\n        left[i] = left[i-1] + int(el < 0)\n\nl_count = [0]*n\nfor i, el in enumerate(left):\n    if i == 0:\n        l_count[i] = 1\n    else:\n        l_count[i] = l_count[i-1] + int(left[i-1]%2 == 0)\n\nneg_count = 0\nfor r in range(n):\n    if left[r]%2 == 1:\n        neg_count += l_count[r]\n    else:\n        neg_count += r+1 - l_count[r]\n\npos_count = n*(n+1)//2 - neg_count\n\nprint(neg_count, pos_count)", "n = int(input())\narr = [int(s) for s in input().split()]\nans = [0, 0]\nlast = [0, 0]\nnow = 0\nfor i in arr:\n    if i < 0:\n        now = 1 if now == 0 else 0\n    last[now] += 1\nans[0] += last[0]\nans[1] += last[1]\n# print(last)\nfor i in range(1, n):\n    if arr[i - 1] < 0:\n        last[0], last[1] = last[1], last[0]\n    last[0] -= 1\n    ans[0] += last[0]\n    ans[1] += last[1]\n    # print(last)\nprint(ans[1], ans[0])", "n = int(input())\na = list(map(int, input().split()))\ncnt_plus, cnt_minus = 0, 0\ncur_plus, cur_minus = 0, 0\nfor v in a:\n\tif v > 0:\n\t\tcur_plus += 1\n\telse:\n\t\tcur_minus, cur_plus = cur_plus + 1, cur_minus\t\t\n\tcnt_plus += cur_plus\n\tcnt_minus += cur_minus\nprint(cnt_minus, cnt_plus)\n", "import sys\nsin = sys.stdin\n\nsin.readline()\narr = sin.readline().split()\narr = [int(i) for i in arr]\n\nlp = ln = ep = en = 0\n\nfor i in arr:\n    newNeg = 0\n    newPos = 0\n    if i < 0:\n        newNeg = ep + 1\n        newPos = en\n    if i > 0:\n        newNeg = en\n        newPos = ep + 1\n    lp += ep\n    ln += en\n    ep = newPos\n    en = newNeg\n\nprint(ln + en, lp + ep)\n\n", "N = int(input())\n\nd = 1\npl = 0\nmn = 0\napl = 0\namn = 0\nfor k in map(int,input().split()):\n    if k < 0: d = d * (-1)\n\n    if d < 0:\n        apl += mn\n        amn += pl\n    else:\n        apl += pl\n        amn += mn\n\n    if d < 0:\n        mn += 1\n        amn += 1\n    else:\n        pl += 1\n        apl += 1\n\nprint(amn, apl)"]
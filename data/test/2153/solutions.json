["mod = 1000000007\neps = 10**-9\ninf = 10**9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << (self.size.bit_length() - 1)\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    adj = [[] for _ in range(N+1)]\n\n    AA = sorted(list(set(A)))\n    a2i = {a:i for i, a in enumerate(AA)}\n\n    AI = [[] for _ in range(len(AA))]\n    for i, a in enumerate(A):\n        ii = a2i[a]\n        AI[ii].append(i+1)\n    bit_high = Bit(N)\n    for i_list in AI:\n        for i in i_list:\n            bit_high.add(i, 1)\n        for i in i_list:\n            val = bit_high.sum(i)\n            il = bit_high.lower_bound(val - 1)\n            ir = bit_high.lower_bound(val + 1)\n            if il > 0:\n                adj[il].append(i)\n            if ir <= N:\n                adj[i].append(ir)\n\n    bit_low = Bit(N)\n    AI.reverse()\n    for i_list in AI:\n        for i in i_list:\n            bit_low.add(i, 1)\n        for i in i_list:\n            val = bit_low.sum(i)\n            il = bit_low.lower_bound(val - 1)\n            ir = bit_low.lower_bound(val + 1)\n            if il > 0:\n                adj[il].append(i)\n            if ir <= N:\n                adj[i].append(ir)\n\n    dp = [inf] * (N+1)\n    dp[1] = 0\n    for i in range(1, N+1):\n        for j in adj[i]:\n            dp[j] = min(dp[j], dp[i] + 1)\n    print(dp[N])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class SegmentTree:\n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(list(range(_size))):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\nn = int(input())\nl = list(map(int, input().split()))\n\nstMax = SegmentTree(l)\nstMin = SegmentTree(l, default = 10**10,func=min)\n\nnexSmol = [-1] * n\nnexTol = [-1] * n\n\nsmolS = [n-1]\ntolS = [n-1]\n\nfor i in range(n - 2, -1 ,-1):\n    while smolS and l[smolS[-1]] >= l[i]:\n        smolS.pop()\n    if smolS:\n        nexSmol[i] = smolS[-1]\n    smolS.append(i)\n\n    while tolS and l[tolS[-1]] <= l[i]:\n        tolS.pop()\n    if tolS:\n        nexTol[i] = tolS[-1]\n    tolS.append(i)\n\nbest = [n] * n\nbest[0] = 0\n\nfor i in range(n - 1):\n    curr = best[i]\n\n    if l[i + 1] > l[i]:\n        reach = i + 1\n        best[i+1] = min(curr + 1, best[i+1])\n        while nexSmol[reach] != -1:\n            reach = nexSmol[reach]\n            if stMin.query(i+1,reach) < l[i]:\n                break\n            best[reach] = min(curr + 1, best[reach])\n        \n    elif l[i + 1] < l[i]:\n        reach = i + 1\n        best[i+1] = min(curr + 1, best[i+1])\n        while nexTol[reach] != -1:\n            reach = nexTol[reach]\n            if stMax.query(i+1,reach) > l[i]:\n                break\n            best[reach] = min(curr + 1, best[reach])\n            \n    else:\n        best[i+1] = min(curr + 1, best[i+1])\nprint(best[-1])\n"]
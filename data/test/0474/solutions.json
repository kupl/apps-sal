["n = int(input())\na = list(map(int,input().split()))\nm = max(a)\n\ncurrent = 0\nlongest = 0\nfor x in a:\n    if x == m:\n        current +=1\n    else:\n        longest = max(current,longest)\n        current = 0\nlongest = max(current,longest)\nprint (longest)\n\n", "ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn = ii()\na = li()\nm = max(a)\ni = 0\nans = 1\nwhile i < n:\n    j = i + 1\n    while j < n and a[i] == a[j]:\n        j += 1\n    if a[i] == m:\n        ans = max(ans, j - i)\n    i = j\nprint(ans)", "n = int(input())\na = list(map(int, input().split()))\nq = max(a)\ntmp = 0\nnum = 0\nfor i in range(n):\n    if a[i] == q:\n        tmp += 1\n    else:\n        num = max(num, tmp)\n        tmp = 0\nnum = max(num, tmp)\nprint(num)\n", "n = int(input())\nA = list(map(int, input().split()))\nz = max(A)\ncnt = 0\nhop = 0\nfor i in A:\n    hop = max(hop, cnt)\n    if i == z:\n        cnt += 1\n    else:\n        cnt = 0\nhop = max(hop, cnt)\nprint(hop)", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nisdebug = False\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\n    isdebug = True\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif not isdebug:\n    inId = 0\n    outId = 0\nif inId>0:\n    dprint('use input', inId)\n    try:\n        f = open('input'+ str(inId) + '.txt', 'r')\n        sys.stdin = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid input file')\nif outId>0:\n    dprint('use output', outId)\n    try:\n        f = open('stdout'+ str(outId) + '.txt', 'w')\n        sys.stdout = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid output file')\n        \n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\nza  = getIntList()\nt = max(za)\nl = 0\nr = 0\nfor x in za:\n    if x==t:\n        l+=1\n    else:\n        l=0\n    r = max(r,l)\nprint(r)\n\n\n\n\n", "n=int(input())\na=list(map(int,input().split()))\nk=max(a)\n\np=0\nans = 1\nfor i in range(n):\n\tif a[i]==k:\n\t\tp+=1\n\telse:\n\t\tans = max(ans,p)\n\t\tp=0\nans = max(ans,p)\nprint(ans)\n", "n = int(input())\nA = list(map(int, input().split()))\na = max(A)\nacc = 0\nans = 1\nfor b in A:\n  if b == a:\n    acc += 1\n  else:\n    acc = 0\n  ans = max(ans, acc)\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nc = max(a)\nle = 0\nans = -1\nfor i in range(n):\n    if c == a[i]:\n        le += 1\n    else:\n        le = 0\n    ans = max(ans, le)\nprint(ans)", "n = int(input())\ns = list(map(int, input().split()))\nm = -1\nrow = 0\nmr = 0\nfor i in s:\n    if i == m:\n        row += 1\n    elif(i > m):\n        m = i\n        row = 1\n        mr = 0\n    else:\n        row = 0\n    mr = max(mr, row)\nprint(mr)", "n=int(input())\narr=list(map(int,input().split()))\nmax1=max(arr)\ni=0\nans=1\nwhile(i<n):\n\tif(arr[i]==max1):\n\t\tcount=0\n\t\twhile(i<n and arr[i]==max1):\n\t\t\tcount+=1\n\t\t\ti+=1\n\t\tans=max(ans,count)\n\ti+=1\nprint(ans)", "def mi():\n    return list(map(int, input().split()))\n'''\n5\n6 1 6 6 0\n'''\nn = int(input())\na = list(mi())\nt = max(a)\n\ncnt = 0\ni = 0\nwhile i<n:\n    if a[i]==t:\n        curcnt = 0\n        while i<n and a[i]==t:\n            curcnt+=1\n            i+=1\n        cnt = max(cnt, curcnt)\n    i+=1\nprint (cnt)\n", "n = int(input())\narr = list(map(int, input().split()))\nm = max(arr)\nc = 0\ntemp = 0\nfor x in arr:\n    if x == m:\n        c += 1\n    else:\n        if temp < c: temp = c\n        c = 0\nif temp < c: temp = c\nprint(temp)\n", "N = int(input())\nA = [int(a) for a in input().split()]\n\nm = max(A)\nma = 0\nc = 0\nfor i in range(N):\n    if A[i] == m:\n        c += 1\n        ma = max(ma, c)\n    else:\n        c = 0\nprint(ma)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef main():\n    n = get_int()\n    li = get_list()\n    maxi = max(li)\n    c=0\n    res = 1\n    for i in li:\n        if i==maxi:\n            c+=1\n        else:\n            res=max(c,res)\n            c=0\n    res=max(c,res)\n    print(res)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n=int(input())\nA=list(map(int,input().split()))\n\nM=max(A)\nANS=0\ncount=0\nfor a in A:\n    if a==M:\n        count+=1\n        if ANS<count:\n            ANS=count\n    else:\n        count=0\nprint(ANS)\n", "n = int(input())\nA = [int(x) for x in input().split()]\nmx = max(A)\n\nstreak = 0\ncur = 0\nfor a in A:\n    if a == mx:\n        cur += 1\n        streak = max(streak, cur)\n    else:\n        cur = 0\nprint(streak)\n", "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <18/Feb/2019 09:13:07 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n#\tQuestion Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    n = int(input())\n    arr = get_array()\n    #from collections import Counter\n    maxi = max(arr)\n    mx, curr = 0, 0\n    for i in range(n):\n        if arr[i] == maxi:\n            curr += 1\n            mx = max(mx, curr)\n        else:\n            curr = 0\n    print(mx)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def inpl(): return list(map(int, input().split()))\n\nN = int(input())\nA = inpl() + [-1]\n\nx = max(A)\nctr = 0\nans = 0\nfor a in A:\n    if a == x:\n        ctr += 1\n    else:\n        ans = max(ans, ctr)\n        ctr = 0\nprint(ans)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys  # {{{\nimport os\nimport time\nimport re\nfrom pydoc import help\nimport string\nimport math\nfrom operator import itemgetter\nfrom collections import Counter\nfrom collections import deque\nfrom collections import defaultdict as dd\nimport fractions\nfrom heapq import heappop, heappush, heapify\nimport array\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom copy import deepcopy as dcopy\nimport itertools\n# }}}\n\n# pre-defined{{{\nsys.setrecursionlimit(10**7)\nINF = 10**20\nGOSA = 1.0 / 10**10\nMOD = 10**9+7\nALPHABETS = [chr(i) for i in range(ord('a'), ord('z')+1)]  # can also use string module\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef DP(N, M, first): return [[first] * M for n in range(N)]\ndef DP3(N, M, L, first): return [[[first] * L for n in range(M)] for _ in range(N)]\nfrom inspect import currentframe\ndef dump(*args):\n    names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}\n    print(', '.join(names.get(id(arg),'???')+' => '+repr(arg) for arg in args), file=sys.stderr)\n# }}}\n\ndef local_input():# {{{\n    from pcm.utils import set_stdin\n    import sys\n    from pathlib import Path\n    parentdir = Path(os.path.dirname(__file__)).parent\n    inputfile = parentdir.joinpath('test/sample-1.in')\n    if len(sys.argv) == 1:\n        set_stdin(inputfile)\n# }}}\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    m = max(A)\n\n    res = 0\n    c = 0\n    for a in A:\n        if (a==m):\n            c += 1\n            res = max(res, c)\n        else:\n            c = 0\n    print(res)\n    return 0\n\ndef __starting_point():# {{{\n    try:\n        local_input()\n    except:\n        pass\n    solve()\n# vim: set foldmethod=marker:}}}\n\n__starting_point()", "n = int(input())\n\na = list(map(int, input().split()))\n\nmx = max(a)\n\nc = 0\nmc = 0\n\nfor i in range(n):\n    if a[i] == mx:\n        c += 1\n        mc = max(mc, c)\n    else:\n        mc = max(mc, c)\n        c = 0\nprint(mc)", "n=int(input())\na=[int(s) for s in input().split()]\na.append(-1)\nmx=max(a)\nans=1\nk=0\nfor i in range(n+1):\n    if a[i]==mx:\n        k+=1\n    else:\n        ans=max(ans,k)\n        k=0\nprint(ans)\n    \n", "n=int(input())\na=list(map(int,input().split()))\nmx=max(a)\ncnt=0\nans=0\nfor i in range(n):\n    if a[i]==mx:\n        cnt+=1\n    else:\n        ans=max(ans,cnt)\n        cnt=0\nans=max(ans,cnt)\nprint(ans)\n", "\nn = int(input())\narr = [int(x) for x in input().split()]\nmax_val = max(arr)\n\nmax_len = 0\ncur_len = 0\nfor a in arr:\n    if a == max_val:\n        cur_len += 1\n        max_len = max(cur_len, max_len)\n    else:\n        cur_len = 0\n\nprint(max_len)\n", "amount = int(input())\narray = [int(s) for s in input().split()]\nmax_ = max(array)\ncounter = 0\ncounter_max = 0\nfor i in range(len(array)):\n    if array[i] == max_:\n        counter += 1\n        if counter > counter_max:\n            counter_max = counter\n    else:\n        counter = 0\nprint(counter_max)"]
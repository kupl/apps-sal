["from math import factorial\n\n\ndef lol(n):\n    if n == 1:\n        yield [0]\n        yield [1]\n    else:\n        for p in lol(n - 1):\n            p.append(0)\n            yield p\n            p[-1] = 1\n            yield p\n            p.pop()\n\n\ndef sp(g1, g2, g3, f):\n    if g1 == 0:\n        if g2 == g3:\n            return 2\n        elif abs(g2 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g2 == 0:\n        if g1 == g3:\n            return 2\n        elif abs(g1 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g3 == 0:\n        if g2 == g1:\n            return 2\n        elif abs(g2 - g1) == 1:\n            return 1\n        else:\n            return 0\n    else:\n        if f == 1:\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return b + c\n        elif f == 2:\n            a = sp(g1 - 1, g2, g3, 1)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + c\n        elif f == 3:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            return a + b\n        else:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + b + c\n\n\nn, T = map(int, input().split())\nS = []\ncnt = 0\nM = 10 ** 9 + 7\nfor i in range(n):\n    S.append(list(map(int, input().split())))\nfor p in lol(n):\n    d = 0\n    g1, g2, g3 = 0, 0, 0\n    for i in range(n):\n        if p[i]:\n            d += S[i][0]\n            if S[i][1] == 1:\n                g1 += 1\n            elif S[i][1] == 2:\n                g2 += 1\n            elif S[i][1] == 3:\n                g3 += 1\n    if d == T:\n        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)\n        cnt %= M\nprint(cnt)", "import sys\ninput = sys.stdin.readline\n\nn,T=list(map(int,input().split()))\nS=[list(map(int,input().split())) for i in range(n)]\n\nDP=[[0]*(4) for i in range(T+1)]\nmod=10**9+7\n\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef calc(used,recent,time):\n    ANS=0\n    for i in range(n):\n        #print(i,used)\n        if i in used:\n            continue\n        if time+S[i][0]>T:\n            continue\n        if S[i][1]==recent:\n            continue\n        if time+S[i][0]==T:\n            ANS+=1\n        if time+S[i][0]<T:\n            used2=list(used)+[i]\n            used2.sort()\n            recent2=S[i][1]\n            time2=time+S[i][0]\n            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod\n\n    return ANS\n\nprint(calc(tuple(),-1,0)%mod)\n    \n", "from functools import lru_cache\n\nP = 10**9+7\nN, T = map(int, input().split())\nA = [[], [], []]\nX = []\nfor _ in range(N):\n    t, g = map(int, input().split())\n    X.append((t, g))\n\n@lru_cache(maxsize=None)\ndef calc(x, pr, t):\n    if t < 0:\n        return 0\n    if t == 0:\n        return 1\n    if x == 0:\n        return 0\n    \n    ans = 0\n    for i in range(15):\n        if x & (1<<i):\n            if X[i][1] != pr:\n                y = x ^ (1<<i)\n                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P\n    return ans\n    \nprint(calc(2**N-1, -1, T))", "def popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\nN, T = map(int, input().split())\nTG = [list(map(int, input().split())) for _ in range(N)]\nmod = 10**9+7\n\n\ndp = [[0]*(2**N) for _ in range(4)]\nfor i in range(1, 4):\n    dp[i][0] = 1\n\nfor S in range(2**N):\n    if popcount(S) == 1:\n        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1\n    for i in range(1, 4):\n        for j in range(N):\n            if S & (2**j) or i == TG[j][1]:\n                continue\n            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod\n\ntable = [0]*(2**N)\nfor S in range(2**N):\n    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)\n    \nans = 0\nfor S in range(2**N):\n    if table[S] == T:\n        for i in range(1, 4):\n            ans = (ans + dp[i][S]) % mod\n\nprint(ans)", "from itertools import combinations\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\n    \nN, T = [int(x) for x in input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)", "from itertools import combinations\ndef out1(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==1 and b==0 and c==0:\n        return 1\n    return a*(out2(a-1,b,c)+out3(a-1,b,c))\ndef out2(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==1 and c==0:\n        return 1\n    return b*(out1(a,b-1,c)+out3(a,b-1,c))\ndef out3(a,b,c):\n    if a<0 or b<0 or c<0:\n        return 0\n    if a==0 and b==0 and c==1:\n        return 1\n    return c*(out2(a,b,c-1)+out1(a,b,c-1))\ndef column(matrix, i):\n    return [row[i] for row in matrix]\n    \nN, T = [int(x) for x in input().split()]\nA = []\ns = 0\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\nfor i in range(1,N+1):\n    comb = list(combinations(A, i))\n    for x in comb:\n        if sum(column(x,0))==T:\n            a = column(x,1).count(1)\n            b = column(x,1).count(2)\n            c = column(x,1).count(3)\n            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))\nprint(s%1000000007)", "from itertools import combinations\n\ndef findsum(comb):\n    sum = 0\n    for song in comb:\n        sum += song[0]\n    return sum\n\ndef finda(a,b,c):\n    if a == 0:\n        return 0\n    if a == 1 and b == 0 and c == 0:\n        return 1\n    else:\n        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))\n\ndef findb(a,b,c):\n    if b == 0:\n        return 0\n    if b == 1 and a == 0 and c == 0:\n        return 1\n    else:\n        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))\n\ndef findc(a,b,c):\n    if c == 0:\n        return 0\n    if c == 1 and a == 0 and b == 0:\n        return 1\n    else:\n        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))\n\n\n\nn, T = map(int,input().split())\nsongs = []\ntotal_combinations = 0\nfor i in range(n):\n    t, g = map(int,input().split())\n    songs.append([t,g])\n\nfor i in range(1, n+1):\n    allcomb = list(combinations(songs,i))\n    for comb in allcomb:\n        sum = findsum(comb)\n\n        if sum == T:\n            a = 0\n            b = 0\n            c = 0\n            for song in comb:\n                if song[1] == 1:\n                    a += 1\n                elif song[1] == 2:\n                    b += 1\n                else:\n                    c += 1\n            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)\ntotal_combinations = total_combinations%1000000007\nprint(total_combinations)"]
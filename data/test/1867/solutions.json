["import collections\n\nn = int(input())\nAs = list(map(int, input().split()))\n\ndef solve(n, As):\n    counter = collections.Counter(As)\n    candidates = []\n    prev_freq = 0\n    for num, freq in counter.most_common():\n        if prev_freq and prev_freq!= freq:\n            break\n        candidates.append(num)\n        prev_freq = freq\n    lr = {cand:[] for cand in candidates}\n    for i, a in enumerate(As, 1):\n        if a in lr:\n            lr[a].append(i)\n    minspan = float('inf')\n    for pos in list(lr.values()):\n        if pos[-1] - pos[0] < minspan:\n            minspan = pos[-1] - pos[0]\n            LR = (pos[0], pos[-1])\n    return LR\n\nprint(*solve(n, As))\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\n\n\ndef run(n,x,l,r):\n    s = 0\n    curr = 1\n    for i in range(n):\n        skip = (l[i]-curr) // x\n        s += r[i]-curr-skip*x+1\n        curr = r[i]+1\n    print(s)\n\n\ndef main(info=0):\n    n = I()\n    a = VI()\n\n    d = {}\n    for i,x in enumerate(a):\n        if x in d:\n            (l,r,num) = d[x]\n            d[x] = (l, i, num+1)\n        else:\n            d[x] = (i,i,1)\n\n    best = (0, 1e7)\n    bestv = None\n    for k,v in list(d.items()):\n        (l,r,num) = v\n        dist = r-l+1\n        if (num, -dist) > best:\n            best = (num, -dist)\n            bestv = v\n\n    print(bestv[0]+1, bestv[1]+1)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nmas=list(map(int,input().split(\" \")))\ndic={i:[0,-1,-1] for i in set(mas)}\nma=0\nfor i in range(n):\n    if  dic[mas[i]][1]==-1:\n        dic[mas[i]][1]=i\n    dic[mas[i]][0]+=1\n    dic[mas[i]][2]=i\n    if dic[mas[i]][0]>ma:ma=dic[mas[i]][0]\nmi=9999999999\na=0\nb=0\nfor i in range(n):\n    if(dic[mas[i]][0]==ma and dic[mas[i]][2]-dic[mas[i]][1]<mi):\n        a=dic[mas[i]][1]\n        b=dic[mas[i]][2]\n        mi=b-a\nprint(a+1,b+1)\n\n", "N = int(input())\nA = [int(x) for x in input().split()]\nbucket = dict()\nfor i, num in enumerate(A):\n    if num in bucket:\n        bucket[num].append(i)\n    else:\n        bucket[num] = [i]\n#print(bucket)\nsorted_buckets = sorted((-len(val), val[-1]-val[0], val) for _, val in list(bucket.items()))\nprint(sorted_buckets[0][2][0]+1, sorted_buckets[0][2][-1]+1)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\ncounter = dict()\nmax_num = (0,0)\n\nn = int(input())\nA = list(map(int,input().split()))\n\nfor i in range(len(A)):\n    if A[i] in counter:\n        counter[A[i]][0] += 1\n        counter[A[i]][2] = i\n    else:\n        counter[A[i]] = [1,i,i]\n\ncount,l,r = max(list(counter.values()),key = lambda x:(x[0],-(x[2]-x[1]),-x[1]))\nprint(l+1,r+1)\n", "n = int(input())\n\narr = list(map(int,input().split()))\n\nd = {}\n\nfor i in range(n):\n\tif arr[i] not in d:\n\t\td[arr[i]] = (i,i,1)\n\telse:\n\t\tx = d[arr[i]]\n\t\ty = (x[0],i,x[2]+1)\n\t\td[arr[i]] = y\n\n#print(d)\n\np = 10**20\nr = 0\n\nfor i in d:\n\tm = d[i]\n\tif(m[2] > r):\n\t\tr = m[2]\n\t\tp = m[1]-m[0]\n\t\tq = m[0],m[1]\n\telif(m[2] == r and (m[1] - m[0]) < p):\n\t\tr = m[2]\n\t\tp = m[1]-m[0]\n\t\tq = (m[0],m[1])\n\nprint(q[0]+1,q[1]+1)", "def cmp_to_key(mycmp):\n    'Convert a cmp= function into a key= function'\n\n    class K:\n        def __init__(self, obj, *args):\n            self.obj = obj\n\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n\n    return K\n\n\ndef compare(x, y):\n    if x[2] != y[2]:\n        return y[2] - x[2]\n    return (x[1] - x[0]) - (y[1] - y[0])\n\n\ndef main():\n    n = int(input())\n    d = list(map(int, input().split()))\n    r = {}\n    for i in range(n):\n        if d[i] in r:\n            r[d[i]] = [r[d[i]][0], i + 1, r[d[i]][2]+1]\n        else:\n            r[d[i]] = [i + 1, i + 1, 1]\n\n    sr = sorted(list(r.values()), key=cmp_to_key(compare))\n    print(sr[0][0], sr[0][1])\n\n\nmain()\n", "num = int(input())\ndata = dict()\n\nlst = input().split()\nlst = list(map(int, lst))\n\nfor i in range(num):\n    if lst[i] in data:\n        data[lst[i]][0] += 1\n        data[lst[i]][2] = i\n    else:\n        data[lst[i]] = [1, i, i]\n\nm = 1;\nnewlst = []\nfor n in data.keys():\n    info = data[n]\n    if info[0] > m:\n        m = info[0]\n        newlst = [info[1:]]\n    elif info[0] == m:\n        newlst += [info[1:]]\n\nmn = num + 1\nbest = []\nnewlst = sorted(newlst)\nfor i in range(len(newlst)):\n    rng = newlst[i][1] - newlst[i][0]\n    if rng < mn:\n        mn = rng\n        best = newlst[i]\n\nprint(best[0] + 1, best[1] + 1)", "N = int(input())\na = [int(i) for i in input().split()]\nd = {}\nb = {}\nfor i, f in enumerate(a):\n    if f not in d:\n        d[f] = 0\n        b[f] = [i, i]\n    d[f] += 1\n    b[f][1] = i\n\nmn = max(d.values())\n\nm = [0, N]\n\nfor k in list(d.keys()):\n    if d[k] != mn:\n        continue\n\n    if b[k][1] - b[k][0] < m[1] - m[0]:\n        m = b[k]\n\nprint(m[0]+1, m[1]+1)\n", "mm = 0\nmmi = []\nf = [0]*(10**6+5)\ng = [[] for _ in range(10**6+5)]\nx = int(input())\nl = list(map(int, input().split(' ')))\nfor i in range(x):\n    f[l[i]]+= 1\n    g[l[i]].append(i+1)\n    if f[l[i]] > mm:\n        mm = f[l[i]]\n        mmi = [l[i]]\n    elif f[l[i]] == mm:\n        mmi.append(l[i])\n\na1 = 0\na2 = 0\nminn = 1000000000\nfor i in mmi:\n    if g[i][-1] - g[i][0] < minn:\n        minn = g[i][-1] - g[i][0]\n        a1 = g[i][0]\n        a2 = g[i][-1]\n        \nprint(a1, a2)\n", "def bin_search(n,a):\n    l = 0\n    r = len(a)-1\n    while l<=r:\n        m = (l+r)//2\n        if n>a[m][0]:\n            l = m+1\n        if n<a[m][0]:\n            r = m-1\n        if n == a[m][0]:\n            return m\n    return -1\nn = int(input())\na = input().split()\ndef ke(n):\n    return n[1]\ndef f(n):\n    return abs(n[2]-n[3])\ncnt = {}\nmx = 0\nfor i in range(n):\n    a[i] = int(a[i])\n    if a[i] in cnt:\n        cnt[a[i]][1] += 1\n        cnt[a[i]][3] = i\n    else:\n        cnt[a[i]] = [a[i],1,i,0]\nfor m in list(cnt.values()):\n    if m[1]>mx:\n        mx = m[1]\nv = []\nfor m in list(cnt.values()):\n    if m[1]==mx:\n        v.append(m)\nv.sort(key=f)\nprint(v[0][2]+1,v[0][3]+1)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom collections import Counter\n\n\ndef solve(n, xs):\n    rxs = list(reversed(xs))\n    length = len(xs)\n    counter = {}\n    # counter = Counter(xs)\n    # m = counter.most_common(1)[0][1]\n    for i, x in enumerate(xs):\n        if x in counter:\n            counter[x]['cnt'] += 1\n            counter[x]['last'] = i\n        else:\n            counter[x] = {'cnt': 0, 'first': i, 'last': i}\n    ts = sorted(list(counter.items()), key=lambda t: t[1]['cnt'], reverse=True)\n    maxs = []\n    mv = 0  # max value\n    mr = float('inf')  # max range\n    rkey = 0  # result key\n    for t in ts:\n        k, d = t\n        r = d['last'] - d['first']\n        if mv <= d['cnt'] and mr > r:\n            mv = d['cnt']\n            mr = r\n            rkey = k\n    return counter[rkey]['first'] + 1, counter[rkey]['last'] + 1\n    # maxs = map(lambda x: x[0], filter(lambda x: x[1] == m, counter.most_common()))\n    # r = float('inf')\n    # rf = 0\n    # rl = 0\n    # for x in maxs:\n    #     first = xs.index(x)\n    #     last = length - rxs.index(x) - 1\n    #     l = last - first + 1\n    #     if r > l:\n    #         r = l\n    #         rf = first\n    #         rl = last\n    # return rf + 1, rl + 1\n\n\ndef getinput():\n    def getints_line():\n        return list(map(int, input().split(' ')))\n    n = int(input())\n    xs = getints_line()\n    return n, xs\n\n\ndef test():\n    # print(solve(5, [1, 1, 2, 2, 1]))\n    # print(solve(5, [1, 2, 2, 3, 1]))\n    # print(solve(6, [1, 2, 2, 1, 1, 2]))\n    assert solve(5, [1, 1, 2, 2, 1]) == (1, 5)\n    assert solve(5, [1, 2, 2, 3, 1]) == (2, 3)\n    assert solve(6, [1, 2, 2, 1, 1, 2]) == (1, 5)\n\n\ndef main():\n    # test()\n    # print(*getinput())\n    print(' '.join(map(str, solve(*getinput()))))\n    # print('\\n'.join(map(str, solve(*getinput()))))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nA = [int(x) for x in input().split()]\n\nbucket = dict()\nfor i, num in enumerate(A):\n    if num in bucket:\n        bucket[num].append(i)\n    else:\n        bucket[num] = [i]\n\nsorted_buckets = sorted(list(bucket.values()), key=lambda val: (-len(val), val[-1]-val[0]))\nprint(sorted_buckets[0][0]+1, sorted_buckets[0][-1]+1)\n", "from collections import defaultdict\nN = int(input())\nA = [int(x) for x in input().split()]\n\nbucket = defaultdict(list)\nfor i, num in enumerate(A):\n    bucket[num].append(i)\n\nsorted_buckets = sorted(list(bucket.values()), key=lambda val: (-len(val), val[-1]-val[0]))\nprint(sorted_buckets[0][0]+1, sorted_buckets[0][-1]+1)\n"]
["def main():\n    n,m=list(map(int,input().split()))\n    s=list(map(int,input().split()))\n    t=list(map(int,input().split()))\n    dp=[[0]*(m+1) for _ in [0]*(n+1)]\n    for i in range(n+1):\n        dp[i][m]=1\n    for i in range(m+1):\n        dp[n][i]=1\n    for i in range(n-1,-1,-1):\n        for j in range(m-1,-1,-1):\n            dp[i][j]=(dp[i+1][j]+dp[i][j+1]-(s[i]!=t[j])*dp[i+1][j+1])%(10**9+7)\n    print((dp[0][0]))\nmain()\n", "# -*- coding: utf-8 -*-\ndef solve():\n    N, M = list(map(int, input().split()))\n    S = list(map(int, input().split()))\n    *T, = list(map(int, input().split()))\n    dp = [1]*(M+1)\n    for s in S:\n        is_s = s.__eq__\n        dp_ = dp[:]\n        acc = 0\n        for i, t in enumerate(T):\n            if is_s(t):\n                acc += dp_[i]\n            dp[i+1] = dp_[i+1] + acc\n    res = (dp[-1])%(10**9+7)\n    return str(res)\n\ndef __starting_point():\n    print((solve()))\n\n__starting_point()", "MOD = 10 ** 9 + 7\nn, m = list(map(int, input().split()))\ns = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\ndp = [0] * n\nfor tj in t:\n    acc = 0\n    for i, si in enumerate(s):\n        acc = (acc + dp[i]) % 1000000007\n        if si == tj:\n            dp[i] = (acc + 1) % 1000000007\nans = 1\nfor x in dp:\n    ans = (ans + x) % MOD\nprint(ans)\n", "#  --*-coding:utf-8-*--\n\n\ndef f(N, M, S, T):\n    W = [1]*(N+1)\n\n    for i, t in enumerate(T):\n        W2 = W[:]\n        \n        k = 0\n        for j, s in enumerate(S):\n            if t == s:\n                k += W[j]\n\n            x = (W2[j+1] + k)%1000000007\n            W2[j+1] = x\n\n        W = W2\n        \n    return W[-1]\n\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    S = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n\n    print((f(N,M,S,T)))\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import numpy as np\nN, M = map(int, input().split())\nMOD = 10**9+7\ns = np.array([int(c) for c in input().split()], dtype=np.int32)\nt = np.array([int(c) for c in input().split()], dtype=np.int32)\ndp = np.zeros((N+1,M+1), np.int64)\ndp[0] = 1\nfor i in range(N):\n  mask = s[i]==t\n  dp[i+1,1:][mask] = dp[i,:-1][mask]\n  dp[i+1] = (np.cumsum(dp[i+1])+dp[i])%MOD\nprint(dp[-1,-1])", "# \u4e21\u65b9\u306e\u6570\u5217\u304b\u3089\u540c\u3058\u90e8\u5206\u5217\u304c\u3044\u304f\u3064\u3042\u308b\u304b\uff1f\nimport numpy as np\n\nMOD = 10**9+7\nN, M = list(map(int, input().split()))\nS = input().split()\nT = np.array(input().split(), dtype=np.int32)\ndp = np.ones(M+1, dtype=np.int64)\n\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == int(s))).cumsum() + dp[1:]) % MOD\n\nprint((dp[M]))\n\n", "n,m =[int(i) for i in input().split()]\ns=[int(i) for i in input().split()]\nt=[int(i) for i in input().split()]\na=[1]*(m+1)\nfor b in s:\n  d=a[:]\n  k=0\n  for j,c in enumerate(t):\n    d[j]=(k+d[j])%1000000007\n    if b==c:\n      k=(k+a[j])%1000000007\n  d[-1]=(k+d[-1])%1000000007\n  a=d[:]\nprint((a[-1]))\n    \n", "from functools import reduce\n\nNNN = 10 ** 9 + 7\n\n\ndef main():\n    N, M = [int(a) for a in input().split()]\n    S = [int(a) for a in input().split()]\n    T = [int(a) for a in input().split()]\n\n    table = [0] * M\n\n    for si in reversed(S):\n        c = 0\n        for i in reversed(list(range(M))):\n            prev_score = table[i]\n            if T[i] == si:\n                table[i] = (table[i] + c + 1) % NNN\n            c = (c + prev_score) % NNN\n\n    s = 1\n    for a in table:\n        s = (s + a) % NNN\n    print(s)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nN,M = map(int,input().split())\nS = input().split()\nT = np.array(input().split(), dtype = np.int32)\ndp = np.ones(M+1, dtype = np.int64)\nfor s in S:\n  dp[1:] = (np.where(T == int(s), dp[:-1], 0).cumsum() + dp[1:]) % (10**9 + 7)\nprint(dp[M])", "# coding: utf-8\nimport sys\ninput = sys.stdin.readline\n\nMOD = int(1e9 + 7)\n\ndef f(N, M, s, t):\n    cums = [[0] * (M + 1) for _ in range(N + 1)]\n\n    for i in range(N):\n        cumsi = cums[i]\n        cumsi1 = cums[i+1]\n        for j in range(M):\n            num = 0\n            if s[i] == t[j]:\n                num = cumsi[j] + 1\n            cumsi1[j+1] = \\\n                (cumsi1[j] + cumsi[j+1] - cumsi[j] + num) % MOD\n    return((cums[N][M] + 1) % MOD)\n\nn, m = list(map(int, input().split()))\ns = list(map(int, input().split()))\nt = list(map(int, input().split()))\nprint((f(n, m, s, t)))\n", "from numpy import*\nN,M,*U= map(int,open(0).read().split())\nT=array(U[N:])\np=ones(M+1,dtype=\"i8\")\nfor s in U[:N]:p[1:]=((p[:-1]*(s==T)).cumsum()+p[1:])%(10**9+7)\nprint(p[-1])", "import numpy as np\n\nN, M = list(map(int, input().split()))\nS = np.array(list(map(int, input().split())))\nT = np.array(list(map(int, input().split())))\nMOD = 10 ** 9 + 7\n\nneq = (S[:, None] != T[None, :])\ndp = np.ones(M + 1, dtype=np.int64)\nfor i in range(N):\n    new_dp = dp.copy()\n    new_dp[1:] -= dp[:-1] * neq[i]\n    np.cumsum(new_dp, out=new_dp)\n    dp = new_dp % MOD\nprint((dp[M]))\n", "N, M = map(int, input().split())\nS = list(map(int, input().split()))\nT = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nW = [1] * (N + 1)\nfor i, t in enumerate(T):\n\tW2 = W[:]\n\tk = 0\n\tfor j, s in enumerate(S):\n\t\tif t == s:\n\t\t\tk += W[j]\n\t\tW2[j + 1] = (W[j + 1] + k) % mod\n\tW = W2\nprint(W[-1])", "import numpy as np\nMOD = 10**9 + 7\nN,M = map(int,input().split())\nS = np.array(input().split(), dtype=np.int32)\nT = np.array(input().split(), dtype=np.int32)\n\n# (n,m) \u4ee5\u524d\u3067\u4f5c\u308c\u3066\u3044\u308b\u5217\ndp = np.ones(M+1, dtype = np.int64)\n\nfor n in range(N):\n  dp[1:] = ((dp[:-1] * (T == S[n])).cumsum() + dp[1:]) % MOD # cumsum\u306b\u76f4\u3059\n\nanswer = dp[M]\nprint(answer)", "def main():\n    mod = 10**9 + 7\n    N, M = map(int, input().split())\n    S = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    V = [1] * N\n    for t in T:\n        p, q = 1, 1\n        for i, (s, v) in enumerate(zip(S, V)):\n            V[i] = q = v + q if s == t else v + q - p\n            p = v\n    return V[-1] % mod\n\nprint(main())", "def solve():\n    N, M = map(int, input().split())\n    S = map(int, input().split())\n    *T, = map(int, input().split())\n    dp = [1]*(M+1)\n    for s in S:\n        is_s = s.__eq__\n        dp_ = dp[:]\n        acc = 0\n        for i, t in enumerate(T):\n            if is_s(t):\n                acc += dp_[i]\n            dp[i+1] = dp_[i+1] + acc\n    res = (dp[-1])%(10**9+7)\n    return str(res)\n \ndef __starting_point():\n    print(solve())\n__starting_point()", "MOD = 10 ** 9 + 7\n\n\ndef main(S, T):\n  l = len(T) + 1\n  dp = [0] * l\n  # sdp = [[0] * (len(T) + 1) for _ in range(len(S) + 1)]\n\n  # for i, s in enumerate(S):\n  #  for j, t in enumerate(T):\n  #    v = sdp[i][j + 1] + sdp[i + 1][j] + (1 if s == t else -sdp[i][j])\n  #    sdp[i + 1][j + 1] = v % MOD\n  for i, s in enumerate(S):\n    tmp = [0] * l\n    for j, t in enumerate(T):\n      v = dp[j + 1] + tmp[j] + (1 if s == t else -dp[j])\n      tmp[j + 1] = v % MOD\n    dp = tmp\n\n  # return (sdp[-1][-1] + 1)\n  return dp[-1] + 1\n\n\ndef __starting_point():\n  if True:\n    _, _ = map(int, input().strip().split())\n    S = input().strip().split()\n    T = input().strip().split()\n  else:\n    S = range(1000)\n    T = range(1000)\n  print(main(S, T))\n__starting_point()", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nN,M = list(map(int,input().split()))\nS = np.array(input().split(), dtype=np.int32)\nT = np.array(input().split(), dtype=np.int32)\n\n# (n,m) \u4ee5\u524d\u3067\u4f5c\u308c\u3066\u3044\u308b\u5217\ndp = np.zeros((N+1, M+1), dtype = np.int64)\ndp[0] = 1\n\nfor n in range(1, N+1):\n  same = (T == S[n-1])\n  dp[n,1:][same] = dp[n-1,:-1][same] # \u3061\u3087\u3046\u3069(n,m)\u3067\u7d42\u308f\u308b\n  dp[n] = (dp[n].cumsum() + dp[n-1]) % MOD # cumsum\u306b\u76f4\u3059\n\nanswer = dp[N,M]\nprint(answer)\n", "import numpy as np\n\nN, M = list(map(int, input().split()))\nS = tuple(map(int, input().split()))\nT = np.array(input().split(), np.int64)\nmod = 10 ** 9 + 7\n\ndp = np.ones(M + 1, np.int64)\nfor i in S:\n    tmp = (T == i)\n    dp[1:] = (np.cumsum(tmp * dp[:-1]) + dp[1:]) % mod\n\nprint((dp[-1]))\n", "import numpy as np\nMOD = 10**9+7\nN, M = list(map(int, input().split()))\ns = np.array(input().split(), dtype=np.int32)\nt = np.array(input().split(), dtype=np.int32)\n\ndp = np.zeros((N+1,M+1), dtype=np.int64)\ndp[0] = 1\n\nfor i in range(N):\n  same = (s[i]==t)\n  dp[i+1,1:][same] = dp[i,:-1][same]\n  dp[i+1] = (dp[i+1].cumsum()+dp[i])%MOD\n\nprint((dp[-1,-1]))\n", "N, M = map(int, input().split())\nS = list(map(int, input().split()))\nT = list(map(int, input().split()))\n\nA = []\nB = []\nmod = 10**9 + 7\n\nfor i in range(N):\n    if S[i] in T:\n        A.append(S[i])\n\nfor i in range(M):\n    if T[i] in S:\n        B.append(T[i])        \n        \nl1 = [1] * (N + 1)\n\nfor i, t in enumerate(T):\n    l2 = l1[:]\n    k = 0\n    for j, s in enumerate(S):\n        if t == s:\n            k += l1[j]\n        l2[j + 1] = (l1[j + 1] + k) % mod\n    l1 = l2\nprint(l1[-1])", "def main():\n    e=enumerate\n    n,m,*u=map(int,open(0).read().split())\n    dp=[[1]*(m+1)for _ in range(n+1)]\n    dpi=dp[0]\n    for i,s in e(u[:n]):\n        dpi1=dp[i+1]\n        for j,t in e(u[n:]):\n            dpi1[j+1]=(dpi[j+1]+dpi1[j]-dpi[j]*(s!=t))%(10**9+7)\n        dpi=dpi1\n    print(dpi[m])\nmain()", "from collections import deque\nfrom itertools import repeat\n\nMOD = 10**9 + 7\n\nN,M = map(int,input().split())\nS = tuple(map(int,input().split()))\nT = tuple(map(int,input().split()))\n\nif N < M:\n    N,M = M,N\n    S,T = T,S\n\ndp = deque(repeat(1, M+1), M+2)\n\n\nfor s in S:\n    dp.append(1)\n    for t in T:\n        if s == t:\n            dp.append(dp[1]+dp[-1])\n        else:\n            dp.append(dp[1]-dp[0]+dp[-1])\n\nprint(dp[-1]%MOD)", "def f(n, m):\n    s = list(map(int,input().split()))\n    t = list(map(int,input().split()))\n    dp = [[1] * (m + 1) for _ in range(n + 1)]\n    for i, sk in enumerate(s):\n        dpi1 = dp[i + 1] = dp[i][:]\n        cs = 0\n        for j, tk in enumerate(t):\n            if sk == tk:\n                cs = (cs + dp[i][j]) % md\n            dpi1[j + 1] = (dpi1[j + 1] + cs) % md\n#    for x in dp:\n#        print(*x)\n    print((dp[-1][-1]))\n\nmd = 10 ** 9 + 7\nn, m = list(map(int, input().split()))\nf(n, m)\n", "def f(n, m):\n    s = list(map(int,input().split()))\n    t = list(map(int,input().split()))\n    dpi = [1] * (m + 1)\n    for i, sk in enumerate(s):\n        dpi1 = dpi[:]\n        cs = 0\n        for j, tk in enumerate(t):\n            if sk == tk:\n                cs = (cs + dpi[j]) % md\n            dpi1[j + 1] = (dpi1[j + 1] + cs) % md\n        dpi=dpi1\n#    for x in dp:\n#        print(*x)\n    print((dpi1[-1]))\n\nmd = 10 ** 9 + 7\nn, m = list(map(int, input().split()))\nf(n, m)\n", "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nMOD = 10 ** 9 + 7\nN, M = list(map(int, sys.stdin.readline().split()))\nS = list(map(int, sys.stdin.readline().split()))\nT = list(map(int, sys.stdin.readline().split()))\nS = np.array([-1] + S)\nT = np.array([-1] + T)\n\n# # dp[i][j]: S[i] \u3068 T[j] \u3067\u7d42\u308f\u308b\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\n# # S[i] != T[j] \u306e\u3068\u304d 0\n# # S[i] == T[j] \u306e\u3068\u304d\u3001sum(dp[:i][:j])\n# dp = np.zeros((len(S), len(T)), dtype=int)\n# dp[0][0] = 1\n# # dp \u306e\u4e8c\u6b21\u5143\u7d2f\u7a4d\u548c\n# cumsum = np.ones(len(T), dtype=int)\n# for i in range(1, len(S)):\n#     for j in range(1, len(T)):\n#         if S[i] != T[j]:\n#             continue\n#         # dp[i][j] = dp[:i, :j].sum() % MOD\n#         dp[i][j] = cumsum[j - 1] % MOD\n#     cumsum += dp[i].cumsum()\n#     cumsum %= MOD\n# print(cumsum[-1])\n\n\ncumsum = np.ones(len(T), dtype=int)\nfor i in range(1, len(S)):\n    cumsum[1:] += ((T == S[i])[1:] * cumsum[:-1] % MOD).cumsum()\n    cumsum %= MOD\nprint((cumsum[-1]))\n", "from collections import defaultdict\ndef solve():\n  ans = 0\n  mod = 10**9+7\n  s = defaultdict(lambda: -1)\n  t = defaultdict(lambda: -1)\n  N, M = map(int, input().split())\n  S = list(map(int, input().split()))\n  T = list(map(int, input().split()))\n  dp = [[0]*(M+1) for _ in range(N+1)]\n  for j in range(M+1):\n    dp[0][j] = 1\n  for i in range(1,N+1):\n    dp[i][0] = 1\n  for i in range(1,N+1):\n    for j in range(1,M+1):\n      if S[i-1]==T[j-1]:\n        dp[i][j] += dp[i-1][j]+dp[i][j-1]\n      else:\n        dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]\n      dp[i][j]%= mod\n  ans = dp[-1][-1]%mod\n  return ans\nprint(solve())", "import numpy as np\nN,M = map(int,input().split())\nS = [int(x) for x in input().split()]\nT = np.array(input().split(), dtype = np.int32)\ndp = np.ones(M+1, dtype = np.int64)\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == s)).cumsum() + dp[1:]) % (10**9 + 7)\nprint(dp[M])", "import numpy as np\n\nN, M = list(map(int, input().split()))\nS = list(map(int, input().split()))\nT = np.array(list(map(int, input().split())))\n\ndp = np.ones(M+1, dtype='int64')\n\nfor s in S:\n    dp[1:] = ((dp[:-1] * (s == T)).cumsum() + dp[1:]) % (10**9+7)\nprint(dp[-1])", "\n#50 ABC130E\nn,m=map(int,input().split())\ns=list(map(int,input().split()))\nt=list(map(int,input().split()))\nmod=10**9+7\n\nimport numpy as np\nt=np.array(t,dtype=np.int64)\ndp=np.ones(m+1,dtype=np.int64)\n\nfor a in s:\n\tdp[1:]=((dp[:-1]*(t==a)).cumsum()+dp[1:])%mod\nprint(dp[-1])", "N, M = map(int, input().split())\nS = list(map(int, input().split()))\nT = list(map(int, input().split()))\ndp = [1] * (M+1)\nacc = [0] * (M)\nMOD = 10 ** 9 + 7\nfor s in S:\n  ndp = [1]\n  for i, t in enumerate(T):\n    if s == t:\n      ndp.append(ndp[-1] + dp[i+1])\n      acc[i] = dp[i+1]\n    else:\n      ndp.append(ndp[-1] + acc[i])\n  dp = ndp\nprint(dp[-1] % MOD)", "import sys\nfrom math import ceil\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\n\ndef nok(a, b):\n    m = a * b\n    while a != 0 and b != 0:\n        if a > b:\n            a %= b\n        else:\n            b %= a\n    return m // (a + b)    \n\n\ndef main():\n    mod = 1e9 + 7\n    n, m = rinput()\n    s = rlinput()\n    t = rlinput()\n    a = [1] * (m + 1)\n    for j in s:\n        d = a[:]\n        k = 0\n        for i, v in enumerate(t):\n            d[i] = (k + d[i]) % mod\n            if j == v:\n                k = (k + a[i]) % mod\n        d[-1] = (k + d[-1]) % mod\n        a = d[:]\n    print(int(a[-1]))\n    \n    \n    \nmain()", "def main():\n    mod = 10**9 + 7\n    N, M = list(map(int, input().split()))\n    S = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    u = [1] * (N + 1)\n    v = [1] * (N + 1)\n    for t in T:\n        for i, s in enumerate(S, 1):\n            if s == t:\n                v[i] = v[i - 1] + u[i]\n            else:\n                v[i] = v[i - 1] + u[i] - u[i - 1]\n        u, v = v, u\n    return u[-1] % mod\n\nprint((main()))\n", "def f(n, m):\n    s = list(input().split())\n    t = list(input().split())\n    dp = [[1] * (m + 1) for _ in range(n + 1)]\n    for i, sk in enumerate(s):\n        dpi1 = dp[i + 1] = dp[i][:]\n        cs = 0\n        for j, tk in enumerate(t):\n            if sk == tk:\n                cs = (cs + dp[i][j]) % md\n            dpi1[j + 1] = (dpi1[j + 1] + cs) % md\n#    for x in dp:\n#        print(*x)\n    print((dp[-1][-1]))\n\nmd = 10 ** 9 + 7\nn, m = list(map(int, input().split()))\nf(n, m)\n", "import numpy as np\nN,M = map(int,input().split())\nS = input().split()\nT = np.array(input().split(), dtype = np.int32)\ndp = np.ones(M+1, dtype = np.int64)\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == int(s))).cumsum() + dp[1:]) % (10**9 + 7)\nprint(dp[M])", "def solve():\n    MOD = 10**9 + 7\n\n    N, M = list(map(int, input().split()))\n    Ss = list(map(int, input().split()))\n    Ts = list(map(int, input().split()))\n\n    dp = [1]*(M+1)\n    for i, S in enumerate(Ss, 1):\n        dp2 = [1]*(M+1)\n        for j, T in enumerate(Ts, 1):\n            dp2[j] = dp[j] + dp2[j-1]\n            if S != T:\n                dp2[j] -= dp[j-1]\n            dp2[j] %= MOD\n        dp = dp2\n\n    print((dp[-1]))\n\n\nsolve()\n", "from numpy import array, ones\n\nmod = 10 ** 9 + 7\n\nN, M, *ST = map(int, open(0).read().split())\nS, T = ST[:N], array(ST[N:])\n\ndp = ones(M + 1, dtype=\"int64\")\nfor s in S:\n    dp[1:] = ((dp[:-1] * (s == T)).cumsum() + dp[1:]) % mod\n\nprint(dp[-1])", "import numpy as np\nN,M = map(int,input().split())\nS = np.array(input().split(), dtype = np.int32)\nT = np.array(input().split(), dtype = np.int32)\ndp = np.ones(M+1, dtype = np.int64)\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == int(s))).cumsum() + dp[1:]) % (10**9 + 7)\nprint(dp[M])", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, M, S, T):\n\n    MOD = 10**9 + 7\n    dp0 = [1] * (M+1)\n    for s in S:\n        dp1 = dp0[:]\n        k = 0\n        for j, t in enumerate(T):\n            if s == t:\n                k += dp0[j]\n            dp1[j+1] = (dp0[j+1] + k) % MOD\n        dp0 = dp1\n\n    return dp0[-1]\n\n\ndef main():\n    N, M = read_int_n()\n    S = read_int_n()\n    T = read_int_n()\n    print(slv(N, M, S, T))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nMOD = 10**9 + 7\nN,M = list(map(int,input().split()))\nS = np.array(input().split(), dtype=np.int32)\nT = np.array(input().split(), dtype=np.int32)\n\n# (n,m) \u4ee5\u524d\u3067\u4f5c\u308c\u3066\u3044\u308b\u5217\ndp = np.zeros((N+1, M+1), dtype = np.int64)\ndp[0] = 1\n\nfor n in range(1, N+1):\n  same = (T == S[n-1])\n  dp[n,1:][same] = dp[n-1,:-1][same] # \u3061\u3087\u3046\u3069(n,m)\u3067\u7d42\u308f\u308b\n  dp[n] = (dp[n].cumsum() + dp[n-1]) % MOD # cumsum\u306b\u76f4\u3059\n\nanswer = dp[N,M]\nprint(answer)\n", "import numpy as np\n\nN,M = map(int,input().split())\nMOD = 1e9 + 7\nS = np.array(input().split())\nT = np.array(input().split())\n\ndp = np.zeros((N+1,M+1))\ndp[0] = 1\n\nfor n in range(1,N+1):\n    same = (T == S[n-1])\n    dp[n,1:][same] = dp[n-1,:-1][same]\n    dp[n] = (dp[n].cumsum() + dp[n-1])%MOD\n    \nprint(int(dp[N,M]))", "n,m=list(map(int,input().split()))\ns=list(map(int,input().split()))\nt=list(map(int,input().split()))\na=[1]*(m+1)\nfor i in range(n):\n    b=a[:]\n    k=0\n    for j in range(m):\n        b[j]=(k+b[j])%(10**9+7)\n        if s[i]==t[j]:\n            k=(k+a[j])%(10**9+7)\n    b[-1]=(k+b[-1])%(10**9+7)\n    a=b[:]\nprint((a[-1]%(10**9+7)))\n", "from numpy import*\nN,M,*U= map(int,open(0).read().split())\np=ones(M+1)\nfor s in U[:N]:p[1:]=((p[:-1]*(s==array(U[N:]))).cumsum()+p[1:])%(10**9+7)\nprint(int(p[-1]))", "import numpy as np\nN, M = map(int, input().split())\nS = input().split()\nT = np.array(input().split(), dtype = np.int32)\nmod = 10 ** 9 + 7\ndp = np.ones(M + 1, dtype = np.int64)\n \nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == int(s))).cumsum() + dp[1:]) % mod\n\nprint(dp[M])", "from numpy import*\nN,M,*U= map(int,open(0).read().split())\nT=array(U[N:])\np=ones(M+1)\nfor s in U[:N]:p[1:]=((p[:-1]*(s==T)).cumsum()+p[1:])%(10**9+7)\nprint(int(p[-1]))", "import numpy as np\nN,M = map(int,input().split())\nS = np.array(input().split(), dtype = np.int32)\nT = np.array(input().split(), dtype = np.int32)\ndp = np.ones(M+1, dtype = np.int64)\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == s)).cumsum() + dp[1:]) % (10**9 + 7)\nprint(dp[M])", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M = list(map(int, readline().split()))\n    S = list(map(int, readline().split()))\n    T = list(map(int, readline().split()))\n\n    dp = [1] * (M + 1)\n\n    for i in range(N):\n        dp_prev = dp[:]\n        for j in range(M):\n            if S[i] == T[j]:\n                dp[j + 1] = (dp_prev[j + 1] + dp[j]) % MOD\n            else:\n                dp[j + 1] = (dp_prev[j + 1] + dp[j] - dp_prev[j]) % MOD\n\n    print((dp[M]))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\ns=list(map(int,input().split()))\nt=list(map(int,input().split()))\nmod=10**9+7\ndp=[1]*(m+1)\nfor i in range(n):\n    ndp=[0]*(m+1)\n    ndp[0]=1\n    for j in range(m):\n        if s[i]==t[j]:\n            ndp[j+1]=(ndp[j]+dp[j+1])%mod\n        else:\n            ndp[j+1]=(ndp[j]+dp[j+1]-dp[j])%mod\n    dp=ndp\nprint(dp[-1])"]
["from collections import deque\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    b = []\n    for i in range(n):\n        b.append([a[i], i + 1])\n    b.sort()\n    ans = []\n    count1, count2 = 0, 0\n    c = deque([])\n    for i in range(2 * n):\n        if (s[i] == '0'):\n            ans.append(b[count1][1])\n            c.append(b[count1][1])\n            count1 += 1\n        else:\n            ans.append(c[-1])\n            c.pop()\n            count2 += 1\n    for i in range(2 * n):\n        print(ans[i], end=' ')\nmain()", "n = int(input())\nw = [int(k) for k in input().split()]\nfor i in range(n):\n    w[i] = [i + 1, w[i], 0]\nw.sort(key=lambda e: e[1])\nnextIntro = 0\nresult = [0 for _ in range(2 * n)]\nunfilled = []\nfor index, v in enumerate(input()[:2*n]):\n    if v == '0':\n        result[index] = w[nextIntro][0]\n        unfilled.append(nextIntro)\n        nextIntro += 1\n    elif v == '1':\n        result[index] = w[unfilled.pop()][0]\nprint(*result)\n        \n", "input()\nintro = sorted([(-x,i+1) for i,x in enumerate(map(int, input().split()))])\nextro = []\nline = input()\nsol = []\nfor c in line:\n    if c == '0':\n        w, r = intro.pop()\n        extro.append((w, r))\n        sol.append(str(r))\n    else:\n        w, r = extro.pop()\n        sol.append(str(r))\nprint(' '.join(sol))", "import math;\nimport time;\nimport bisect;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn=int(input());\nw=getIntList();\ns=input();\np=[int(s[i]) for i in range(2*n)];\nseatInt=[(w[i], i) for i in range(n)];\nseatInt.sort();\ncurrI=0;\nseatExt=[];\nresult=[0]*(2*n);\nfor i in range(2*n):\n    if p[i]==0:\n        result[i]=seatInt[currI][1]+1\n        bisect.insort(seatExt, seatInt[currI]);\n        currI+=1;\n    else:\n        result[i]=seatExt.pop()[1]+1;\nprint(' '.join(map(str,result)))", "n=int(input())\n\n\nw=list(map(int,input().split()))\n\n\ns=input()\n\nfor i in range(n):\n    w[i]=[w[i],i]\nw.sort(reverse=True)\nexos=[]\nlocs=[-1 for i in range(2*n)]\nfor i in range(2*n):\n    if(s[i]=='0'):\n        exos.append(w.pop())\n        locs[i]=exos[-1][1]+1\n    else:\n        temp=exos.pop()\n        locs[i]=temp[1]+1\nprint(*locs)\n\n", "#!/usr/bin/env python3\n\nfrom collections import deque\n\nn = int(input().strip())\nwis = list(map(int, input().strip().split()))\ncs = input().strip()\n\npl = list(range(1, n + 1))\npl.sort(key=lambda p: wis[p - 1])\n\ni = 0\nstack = deque()\nres = []\nfor c in cs:\n\tif c == '0':\n\t\tstack.append(pl[i])\n\t\tres.append(pl[i])\n\t\ti += 1\n\telse:\n\t\tres.append(stack.pop())\n\nprint(' '.join(map(str, res)))\n", "n = int(input())\nW = [int(x) for x in input().split()]\nW = sorted((w,i) for i,w in enumerate(W))\n\nP = input()\n\nsmallfree = 0\nsmallhalf = 0\nhighfree = n-1\nhighasdk = n-1\n\nR = []\n\nfrom collections import defaultdict as dd, deque\n\nQ = deque()\n\nfor p in P:\n    if p == '0':\n        R.append(W[smallfree][1])\n        Q.append(smallfree)\n        smallfree += 1\n    else:\n        seat = Q.pop()\n        R.append(W[seat][1])\nprint(*[r+1 for r in R])\n\n\n", "from heapq import heappop,heappush\nn=int(input())\nc=1\nw={}\nwh=[]\nfor i in input().split():\n    i=int(i)\n    w[i]=c\n    c+=1\n    heappush(wh,i)\no=''\nss=[]\nfor i in input():\n    if i=='0':\n        ss+=[str(w[heappop(wh)])]\n        o+=ss[-1]+' '\n    else:\n        o+=ss[-1]+' '\n        ss.pop(-1)\nprint(o)\n", "\nn = int(input())\n\nwidths = [(int(x), c) for c, x in enumerate(input().split())]\n\nwidths.sort()\n\npassengers = input()\n\nseating = \"\"\nstack = []\ni = 0\n\nfor pi in passengers:\n\tif pi == '1':\n\t\tseating += str(stack[-1][1]+1) + \" \"\n\t\tstack.pop()\n\telse:\n\t\tstack.append(widths[i])\t\t\n\t\tseating += str(stack[-1][1]+1) + \" \"\t\t\t\t\n\t\ti += 1\n\nprint(seating[:-1])\n", "def main():\n    n = int(input())\n    j = list(map(int, input().split()))\n    for i in range(n):\n        j[i] = [j[i], i + 1]\n    j.sort()\n    j = j[::-1]\n    e = []\n    s = input()\n    for i in range(2 * n):\n        if s[i] == '0':\n            print(j[-1][1], end=' ')\n            e.append(j[-1])\n            j.pop()\n        else:\n            print(e[-1][1], end=' ')\n            e.pop()\nmain()", "# your code goes here\nN = int(input())\n\nw = list(map(int,input().split(' ')))\nkey = [i+1 for i in range(N)]\n\nw_dict = dict(zip(key,w))\n\nw_dict = sorted(w_dict.items(), key=lambda x: x[1])\n\nnumber = [row[0] for row in w_dict]\n\npassenger = input()\nans = []\ngaikouteki = []\nnow = 0\nfor i in passenger:\n\tif i == '0':\n\t\tans.append(number[now])\n\t\tgaikouteki.append(number[now])\n\t\tnow += 1\n\telse:\n\t\tans.append(gaikouteki[-1])\n\t\tgaikouteki.pop()\nprint(' '.join(map(str,ans)))", "n = int(input())\nw=list(map(int, input().split()))\na=sorted(list(range(1,n+1)),key=lambda i:w[i-1])\ni,s,o=0,[],[]\nfor c in input():\n    if c=='0':\n        o.append(a[i])\n        s.append(a[i])\n        i+=1\n    else:\n        o.append(s.pop())\nprint(*o)\n", "from collections import defaultdict\nn = int(input())\na = list(map(int,input().split()))\nz = defaultdict(list)\ntemp1 = []\ntemp2 = []\nfor i in range(n):\n    z[a[i]] = i+1\n    temp1.append(a[i])\ns = input()\ntemp1.sort(reverse=True)\n\nfor i in s:\n    if(i=='0'):\n        x = temp1.pop()\n        print(z[x],end=' ')\n        temp2.append(x)\n    else:\n        print(z[temp2.pop()],end=' ')", "n=int(input())\nw=list(map(int, input().split()))\nw =sorted(range(len(w)), key=w.__getitem__)\nw = iter(w)\n\ne = list(input())\nfrom collections import deque\ns = deque()\nfor e1 in e:\n    if e1 == '0':\n        x = next(w)+1\n        print(x, end = ' ')\n        s.append(x)\n    else:\n        print(s.pop(), end = ' ')", "n=int(input())\ns=list(map(int,input().split()))\nstrr=input()\ndic={}\nfor i in range(0,n):\n    dic[s[i]]=i+1 \nlist0=s[::]\nlist1=[]\nlist2=[]\nm=\"\"\nk=0\nj=0\nlist0.sort()\nfor i in strr:\n    if i=='0':\n        m+=str(dic[list0[j]])+\" \"\n        list1+=[list0[j]]\n        k=k+1\n        j=j+1\n        #del(list0[0])\n    else:\n        m+=str(dic[list1[k-1]])+\" \"\n        del(list1[k-1])\n        k=k-1\nprint(m)", "\"\"\"Problem B - Bus of Characters.\n\nhttp://codeforces.com/contest/982/problem/B\n\nIn the Bus of Characters there are `n` rows of seat, each having `2` seats.\nThe width of both seats in the `i`-th row is `w_i` centimeters. All integers\n`w_i` are distinct.\n\nInitially the bus is empty. On each of `2n` stops one passenger enters the\nbus. There are two types of passengers:\n\n- an introvert always chooses a row where both seats are empty. Among these\nrows he chooses the one with the smallest seats width and takes one of the\nseats in it;\n\n- an extrovert always chooses a row where exactly one seat is occupied (by an\nintrovert). Among these rows he chooses the one with the largest seats width\nand takes the vacant place in it.\n\nYou are given the seats width in each row and the order the passengers enter\nthe bus. Determine which row each passenger will take.\n\nInput:\n\nThe first line contains a single integer `n` (`1 <= n <= 200\\,000`) \u2014 the\nnumber of rows in the bus.\n\nThe second line contains the sequence of integers `w_1, w_2, ..., w_n` (`1 <=\nw_i <= 10^{9}`), where `w_i` is the width of each of the seats in the `i`-th\nrow. It is guaranteed that all `w_i` are distinct.\n\nThe third line contains a string of length `2n`, consisting of digits '0' and\n'1' \u2014 the description of the order the passengers enter the bus. If the `j`-th\ncharacter is '0', then the passenger that enters the bus on the `j`-th stop is\nan introvert. If the `j`-th character is '1', the the passenger that enters the\nbus on the `j`-th stop is an extrovert. It is guaranteed that the number of\nextroverts equals the number of introverts (i. e. both numbers equal `n`), and\nfor each extrovert there always is a suitable row.\n\nOutput:\n\nPrint `2n` integers \u2014 the rows the passengers will take. The order of\npassengers should be the same as in input.\n\n\"\"\"\nimport logging\nimport collections\n\n\nfmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'\nformatter = logging.Formatter(fmt)\n\nch = logging.StreamHandler()\nch.setLevel(logging.NOTSET)\nch.setFormatter(formatter)\n\nlogger = logging.getLogger('bus_of_characters')\nlogger.setLevel(logging.NOTSET)\nlogger.addHandler(ch)\n\n\ndef solve(w, s):\n    free = collections.deque()\n    used = collections.deque()\n\n    for w in sorted(enumerate(w), key=lambda x: x[1]):\n        free.append([w[0] + 1, w[1]])\n    \n    ids = [-1] * len(s)\n\n    order = []\n    for pid, p in enumerate(s):\n        logger.debug('pid: %s', pid)\n        if p == '0':\n            taken = free.popleft(), \n            used.appendleft(taken)\n            # order.append(pid, taken[0])\n        else:\n            logger.debug('used %s', used)\n            taken = used.popleft()\n        #order.append([pid, taken[0]])\n        ids[pid] = taken[0]\n\n    return [x for x, y in ids]\n\n\n\ndef main():\n    n = int(input().strip())\n    w = [int(x) for x in input().strip().split()]\n    s = input().strip()\n\n    result = solve(w, s)\n    print(' '.join(map(str, result)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input().strip())\ntemp = input().strip().split()\nw = []\nfor j in range(len(temp)):\n\tw.append([int(temp[j]),j])\n\nw.sort()\n#print(w)\npassenger = input().strip()\n\nbiggest_intro = []\nsmallest_index = 0\n\nfor i in range(2*n):\n\tif passenger[i] == '0':\n\t\t#introvert\n\t\t#smallest_empty = w[smallest_index][1]\t\t#actual index\n\t\tprint(w[smallest_index][1]+1, end=' ')\n\t\tbiggest_intro.append(smallest_index)\t\t#non-actual index, bigger width at the end\n\t\tsmallest_index+=1\n\telif passenger[i] == '1':\n\t\tb = biggest_intro.pop()\n\t\tprint(w[b][1]+1,end=' ')\n\n\t#print(biggest_intro)\nprint()\n", "n = int(input())\ncl = list(map(int, input().split()))\ns = input()\ndic = {}\nfor x in range(n):\n  dic.update({cl[x]:x+1})\n\ncl = sorted(cl)\npl = []\nres = ''\npos1=0\nfor c in s:\n  if c=='0':\n    pl.append(cl[pos1])\n    res+=str(dic[cl[pos1]])+' '\n    pos1+=1\n  if c=='1':\n    mx = pl[-1]\n    res+=str(dic[mx])+ ' '\n    pl.pop(-1)\n\nprint(res)", "n = int(input())\nl = 2 * n\nw = [int(i) for i in input().split()]\npas = input()\nseat = [i for i in w]\nseat.sort()\nd = {}\nfor i in range(len(w)):\n\td[w[i]] = i\ni = 0\nw1 = [0] * l\nj = 0\nwkend = \" \"\nfor k in range(l):\n\tif k == l - 1:\n\t\twkend = \"\\n\"\n\tif pas[k] == \"0\":\n\t\twkindex = d[seat[i]] + 1\n\t\tprint(wkindex, end = wkend)\n\t\tj += 1\n\t\tw1[j] = wkindex\n\t\ti += 1\n\telse:\n\t\tprint(w1[j], end = wkend)\n\t\tj -= 1\n", "# Python program for implementation of MergeSort\n \n# Merges two subarrays of arr[].\n# First subarray is arr[l..m]\n# Second subarray is arr[m+1..r]\ndef merge(arr,temp, l, m, r):\n    n1 = m - l + 1\n    n2 = r- m\n \n    # create temp arrays\n    L1 = [0] *n1\n    L2= [0] *n1\n    R1 = [0] *n2\n    R2 = [0] *n2\n    # Copy data to temp arrays L[] and R[]\n    for i in range(0 , n1):\n        L1[i] = arr[l + i]\n        L2[i] = temp[l + i]\n    for j in range(0 , n2):\n        R1[j] = arr[m + 1 + j]\n        R2[j] = temp[m + 1 + j]\n \n    # Merge the temp arrays back into arr[l..r]\n    i = 0     # Initial index of first subarray\n    j = 0     # Initial index of second subarray\n    k = l     # Initial index of merged subarray\n \n    while i < n1 and j < n2 :\n        if L1[i] <= R1[j]:\n            arr[k] = L1[i]\n            temp[k]= L2[i]\n            i += 1\n        else:\n            arr[k] = R1[j]\n            temp[k]= R2[j]\n            j += 1\n        k += 1\n \n    # Copy the remaining elements of L[], if there\n    # are any\n    while i < n1:\n        arr[k] = L1[i]\n        temp[k] = L2[i]\n        i += 1\n        k += 1\n \n    # Copy the remaining elements of R[], if there\n    # are any\n    while j < n2:\n        arr[k] = R1[j]\n        temp[k] = R2[j]\n        j += 1\n        k += 1\n \n# l is for left index and r is right index of the\n# sub-array of arr to be sorted\ndef mergeSort(arr,temp,l,r):\n    if l < r:\n \n        # Same as (l+r)/2, but avoids overflow for\n        # large l and h\n        m = (l+(r-1))//2\n \n        # Sort first and second halves\n        mergeSort(arr,temp, l, m)\n        mergeSort(arr,temp, m+1, r)\n        merge(arr,temp, l, m, r)\n# Driver code to test above\nn=int(input())\narr=list(map(int,input().split()))\ntemp=[]\nfor i in range(n):\n    temp.append(i+1)\nj=0\nk=-1\narrx=[0]*n\nmergeSort(arr,temp,0,n-1)\n    #print(temp[i],temp1[temp[i]])\n#print(temp1)\ns=str(input())\narry=[0]*len(s)\narrn=[0]\nfor i in range(len(s)):\n    if(s[i]=='0'):\n        arry[i]=temp[j]\n        arrx[temp[j]-1]+=1\n        arrn.append(temp[j])\n        j+=1\n        \n    if(s[i]=='1'):\n        arry[i]=arrn[-1]\n        del arrn[-1]\n    #print(j,k)\nprint(' '.join(map(str, arry))) \n", "# n = int(input())\n# arr = list(map(int,input().split()))\n# k,d = map(int,input().split())\n# n = int(input())\nimport sys\nimport math\n\ndef fun():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    enter_list = input()\n\n    width_list = [[i+1,arr[i]] for i in range(n)]\n    width_list.sort(key=lambda x:x[-1])\n\n    j = 0\n    seated_list = [width_list[0]]\n    all_list = [width_list[0][0]]\n    # print(width_list[j][0], end='')\n    j += 1\n    for c in enter_list[1:]:\n        if c == '0':\n            seated_list.append(width_list[j])\n            # print(\"\", width_list[j][0], end='')\n            all_list.append(width_list[j][0])\n            j += 1\n        else:\n            # print(\"\", seated_list[-1][0], end='')\n            all_list.append(seated_list[-1][0])\n            seated_list.pop()\n    all_list = [str(i) for i in all_list]\n    print(' '.join(all_list))\n\ndef __starting_point():\n    fun()\n\n# print(str)\n\n__starting_point()", "n = int(input())\na = [int(i) for i in input().split()]\ns = input()\n\nmp = {}\nfor i in range(n):\n    mp[a[i]] = i+1\na.sort()\n\nintr=0\nextr=0\nfirst=mp[a[0]]\nst = []\nans = []\nfor i in range(len(s)):\n    if s[i] == '0':\n        ans += [mp[a[intr]]]\n        st.append(mp[a[intr]])\n        intr+=1\n    else:\n        ans+=[st.pop()]\nprint(*ans)\n        \n            \n            \n    \n", "#!/usr/bin/env python3\n# -*- encoding: utf-8 -*-\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    w = sys.stdin.readline().split()\n    w = [(int(w[i]),i) for i in range(n)]\n    p = [i for i in sys.stdin.readline().strip()]\n    w.sort()\n    res = []\n    intro, extro = 0, []\n    for pa in p:\n        if pa == '0':\n            extro.append(w[intro][1])\n            res.append(str(w[intro][1]+1))\n            intro +=1\n        else:\n            s = extro.pop()\n            res.append(str(s+1))\n    print(' '.join(res))\nmain()\n", "n = int(input())\n\nw = list(map(int, input().split()))\nfor i, ww in enumerate(w):\n    w[i] = (ww, i + 1)\np = input()\n\nw = sorted(w)\nimport heapq\nque = []\n\nt = 0\nans = []\n\nfor s in p:\n    if s == '0':\n        heapq.heappush(que,w[t])\n        ans.append(w[t][1])\n        t += 1\n    else:\n        head = que.pop()\n\n        # print(head)\n        ans.append(head[1])\n\nprint(*ans)", "n = int(input())\nline = input().split()\nw = []\nfor i in range(n):\n    w.append((int(line[i]), i+1))\nw = sorted(tuple(w))\ncur = 0\nst = []\nres = []\nfor ch in input():\n    if ch == '0':\n        st.append(w[cur][1])\n        res.append(w[cur][1])\n        cur += 1\n    else:\n        res.append(st[-1])\n        st.pop()\nprint(' '.join(str(item) for item in res))\n        \n"]
["n, t = list(map(int,input().split()))\ng = [[0.0] * i for i in range(1,n+1)]\n\n\nfor _ in range(t):\n    g[0][0] += 1.0\n    for i in range(n):\n        for j in range(i+1):\n            spill = max(0, g[i][j] - 1.0)\n            g[i][j] -= spill\n            if i < n - 1:\n                g[i + 1][j] += spill / 2\n                g[i + 1][j + 1] += spill / 2\n    if g[n-1][0] == 1.0:\n        break\n\ncnt = 0\nfor i in range(n):\n    for j in range(i + 1):\n        if g[i][j] == 1.0:\n            cnt += 1\nprint(cnt)\n", "n, T = list(map(int, input().split()))\na = [[0 for _ in range(n)] for __ in range(n)]\nfor t in range(T):\n    i, j = 0, 0\n    a[i][j] += 1024\n    for i in range(n - 1):\n        for j in range(i + 1):\n            if a[i][j] > 1024:\n                diff = a[i][j] - 1024\n                a[i][j] = 1024\n                a[i + 1][j] += diff//2\n                a[i + 1][j + 1] += diff//2\n                if (diff % 2 != 0):\n                    raise RuntimeError('whut')\nans = 0\nfor i in range(n):\n    for j in range(i + 1):\n        if a[i][j] >= 1024:\n            ans += 1\nprint(ans)\n", "n, t = map(int, input().split())\n\nt = min(2000, t)\nL = [ [0.0]*n for i in range(n) ]\nfor _ in range(t) :\n    L[0][0] += 1.0\n    for i in range(n-1) :\n        for j in range(i+1) :\n            if L[i][j] > 1.0 :\n                x = (L[i][j] - 1.0) / 2\n                L[i+1][j] += x\n                L[i+1][j+1] += x\n                L[i][j] = 1.0\n\nans = 0\nfor i in range(n) :\n    for j in range(i+1) :\n        if L[i][j] > 0.9999999999 :\n            ans += 1\n\nprint(ans)", "n, t = map(int, input().split())\n\na = [[None]] + [[0] * i for i in range(1, n + 1)]\n\nc = 2 ** (n + 1)\n\nfor _ in range(t):\n\ta[1][0] += c\n\tfor i in range(1, n + 1):\n\t\tfor j in range(i):\n\t\t\tif a[i][j] > c:\n\t\t\t\tdiff = a[i][j] - c\n\t\t\t\ta[i][j] = c\n\t\t\t\tif i < n:\n\t\t\t\t\ta[i + 1][j] += diff // 2\n\t\t\t\t\ta[i + 1][j + 1] += diff // 2\n\nfull = 0\nfor i in range(1, n + 1):\n\tfor j in range(i):\n\t\tfull += (a[i][j] == c)\n\nprint(full)", "n,t = [int(x) for x in input().split()]\ncurr = [t]\nfill = 0\n\nwhile sum(curr)>0 and len(curr)<=n:\n    nex = [0]*(len(curr)+1)\n    for i in range(len(curr)):\n        if curr[i]>=1:\n            fill+=1\n            flow = curr[i]-1\n            nex[i]+=flow/2\n            nex[i+1]+=flow/2\n    curr = nex\n\nprint(fill)\n", "n,t = list(map(int,input().split()))\nmatrix = [ [0]*i for i in range(1,n+1)]\nnorma = 2**n\nfor time in range(t):\n    matrix[0][0] += norma\n    for i in range(n):\n        for j in range(i+1):\n            if matrix[i][j]>norma:\n                many = matrix[i][j] - norma\n                if i+1!=n:\n                    matrix[i+1][j]+=many//2\n                    matrix[i+1][j+1]+=many//2\n                matrix[i][j] = norma\ncounter = 0\nfor i in range(n):\n    for j in range(i+1):\n        if matrix[i][j] == norma:\n            counter+=1\nprint(counter)\n#print(matrix)\n", "import sys,math\n\n\nres=[0]\nn,m=map(int,input().split())\nz=[]\nneed=0\nfor i in range(1,n+1):\n    need+=i\nfor i in range(1,n+1):\n    z.append([0]*i)\nfor i in range(1,m+1):\n    z[0][0]+=2\n    for i in range(n-1):\n        for j in range(i+1):\n            if z[i][j]>=2:\n                h=z[i][j]-2\n                z[i+1][j]+=h/2\n                z[i+1][j+1]+=h/2\n                z[i][j]=2\n    for j in range(n):\n        if z[-1][j]>=2:\n            z[-1][j]=2\n        \ns=0\nfor i in range(n):\n    s+=z[i].count(2)\nprint(s)", "\ndef __starting_point():\n    #n, m = list(map(int, input().split()))\n    n, t = map(int, input().split())\n    A = [[0] * 11 for _ in range(11)]\n    ans = 0\n    A[0][0] = t\n    for i in range(n):\n        for j in range(i + 1):\n            if A[i][j] >= 1:\n                A[i + 1][j] += (A[i][j] - 1) / 2\n                A[i + 1][j + 1] += (A[i][j] - 1) / 2\n                A[i][j] = 1\n                ans += 1\n    print(ans)\n__starting_point()", "n,t = list(map(int, input().split()))\n\"\"\"t = 10000\nfor n in range(10,11):\n    T = [[-1 for _ in range(i)] for i in range(1,n+1)]\n    G = [[0 for _ in range(i)] for i in range(1,n+2)]\n    for i in range(t):\n        G[0][0] += 1000000000000\n        for j in range(n):\n            for l in range(j+1):\n                if G[j][l] >= 1000000000000:\n                    G[j+1][l] += (G[j][l]-1000000000000)//2\n                    G[j+1][l+1] += (G[j][l]-1000000000000)//2\n                    G[j][l] = 1000000000000\n                    if T[j][l] == -1:\n                        T[j][l] = i\n    print(T)\nint(input())\"\"\"\nR = [[0], [2, 2], [6, 4, 6], [14, 8, 8, 14], [30, 13, 10, 13, 30], [62, 21, 15, 15, 21, 62], [126, 36, 21, 18, 21, 36, 126], [254, 62, 30, 23, 23, 30, 62, 254], [510, 104, 45, 31, 27, 31, 45, 104, 510], [1022, 181, 68, 40, 33, 33, 40, 68, 181, 1022]]\n\n\n\nC = [0 for _ in range(10001)]\nfor i in range(n):\n    for j in range(i+1):\n        C[R[i][j]] += 1\nfor i in range(1,10001):\n    C[i] += C[i-1]\nif t:\n    print(C[t-1])\nelse:\n    print(0)\n", "read = lambda: list(map(int, input().split()))\nn, t = read()\na = [[0] * 20 for i in range(20)]\nb = [[0] * 20 for i in range(20)]\nfor k in range(t):\n    for i in range(n):\n        for j in range(n):\n            b[i][j] = 0\n    b[0][0] = 1\n    for s in range(n):\n        for i in range(s + 1):\n            j = s - i\n            a[i][j] += b[i][j]\n            if a[i][j] > 1:\n                r = a[i][j] - 1\n                a[i][j] = 1\n                b[i + 1][j] += r / 2\n                b[i][j + 1] += r / 2\ncnt = 0\nfor i in range(n):\n    for j in range(n):\n        cnt += int(a[i][j] == 1)\nprint(cnt)\n", "n, t = list(map(int,input().split()))\nbo = [[0.0]*(n+1) for i in range(n+1)]\nwhile t > 0:\n    bo[0][0] += 1\n    for i in range(n):\n        for j in range(0,i+1):\n            if bo[i][j] > 1.0:\n                temp = (bo[i][j] - 1)/ 2\n                bo[i][j] = 1.0\n                bo[i+1][j] += temp\n                bo[i+1][j+1] += temp\n    t -= 1\n\nnum = 0\nfor i in range(n):\n    for j in range(0,i+1):\n        if bo[i][j] >= 1.0:\n            num += 1\nprint(num)\n", "n, t = list(map(int, input().split()))\n\nm = [[0]*11 for i in range(11)]\n\neps = 1e-6\n\nfor l in range(t):\n    m[0][0] += 1.0\n    for i in range(n):\n        for j in range(i+1):\n            if m[i][j] - eps > 1.0:\n                should_end = False\n                delta = m[i][j] - 1.0\n                m[i][j] = 1.0\n                m[i+1][j] += delta / 2.0\n                m[i+1][j+1] += delta / 2.0\n    # print(l)\n    # for k in m:\n    #     print(k)\n\nansw = 0\nfor i in range(n):\n    for j in range(n):\n        if abs(m[i][j] - 1.0) <= eps:\n            answ += 1\n\nprint(answ)\n", "from decimal import Decimal\n\nRESULT = 0\n\n\nclass Glass:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.amount = Decimal(0)\n        self.is_calculated = False\n\n    def add_wine(self, amount):\n        extra_amount = self.amount + amount - Decimal(1)\n        if extra_amount > 0:\n            self.amount = Decimal(1)\n            if self.left is not None:\n                self.left.add_wine(extra_amount / Decimal(2))\n            if self.right is not None:\n                self.right.add_wine(extra_amount / Decimal(2))\n        else:\n            self.amount += amount\n\n\ndef calculate(glass: Glass):\n    if glass.is_calculated:\n        return\n\n    nonlocal RESULT\n    if glass.amount == Decimal(1):\n        RESULT += 1\n    glass.is_calculated = True\n\n    if glass.left is not None:\n        calculate(glass.left)\n    if glass.right is not None:\n        calculate(glass.right)\n\nn, t = list(map(int, input().split()))\n\na = []\n\nfor _ in range(n):\n    a.append([])\n\nfor i in range(n, 0, -1):\n    # a[i-1].extend([Glass()] * i)\n    for _ in range(i):\n        a[i-1].append(Glass())\n    if i != n:\n        for j, g in enumerate(a[i-1]):\n            g.left = a[i][j]\n            g.right = a[i][j+1]\n\na[0][0].add_wine(t)\n\ncalculate(a[0][0])\n\nprint(RESULT)\n", "n, t = map(int,input().split())\nm = (n+1)*n//2\na = [0]*((n+1)*n//2)\nnext = [-1]*((n+1)*n//2)\nnow = 1\nlayer = 1\nfor i in range(m-n):\n    next[i] = (now, now+1)\n    if layer*(layer+1)//2 == i+1:\n        layer += 1\n        now = layer*(layer+1)//2-1\n    now += 1\nfor i in range(t):\n    a[0]+=1024\n    for j in range(0, m):\n        if a[j] > 1024:\n            if next[j] == -1:\n                a[j] = 1024\n            else:\n                a[next[j][0]] += (a[j]-1024)//2\n                a[next[j][1]] += (a[j]-1024)//2\n                a[j] = 1024\nres = 0\nfor i in range(m):\n    if a[i] >= 1024:\n        res += 1\nprint(res)", "s = input().split()\nn, t = int(s[0]), int(s[1])\na = [0 for i in range(110)]\n\n\ndef balance(x, d):\n\tif a[x] <= 1.0 or d == n:\n\t\treturn\n\telse:\n\t\tp = (a[x] - 1.0) / 2\n\t\ta[x] = 1\n\t\ta[x+n] += p\n\t\ta[x+1] += p\n\t\tbalance(x+n, d+1)\n\t\tbalance(x+1, d+1)\n\t\n\na[0] += t\nbalance(0, 1)\n\t\nans = 0\nfor i in range(100):\n\tif a[i] >= 1:\n\t\tans += 1\n\t\t\nprint(ans)", "n,t=list(map(int,input().split()))\nans=0\nz=[[0 for i in range(n+1)] for i in range(n+1)]\ne=[[0 for i in range(n+1)] for i in range(n+1)]\nb=[[0 for i in range(n+1)] for i in range(n+1)]\nfor it in range(t):\n    z[0][0]+=1\n    if (ans>=n*(n+1)//2):\n        break\n    for i in range(n):\n        for j in range(i+1):\n           if z[i][j]>=1:\n               if (b[i][j]==0):\n                   ans+=1\n               b[i][j]=1\n               e[i][j]=z[i][j]-1\n               z[i][j]=1\n               z[i+1][j]+=e[i][j]/2\n               z[i+1][j+1]+=e[i][j]/2\n               e[i][j]=0\nprint(ans)\n", "n,t=list(map(int,input().split()))\not=0\na=[];b=[];c=[]\nfor i in range(n+1):\n    a.append([])\n    b.append([])\n    c.append([])\n    for j in range(n+1):\n        a[i].append(0)\n        b[i].append(0)\n        c[i].append(0)    \nfor ii in range(1,t+1):\n    a[0][0]+=1\n    if (ot>=(n*n+n)//2):\n        break\n    for i in range(n):\n        for j in range(i+1):\n           if a[i][j]>=1:\n               if not(c[i][j]):\n                   ot+=1\n               c[i][j]=1\n               b[i][j]=a[i][j]-1\n               a[i][j]=1\n               a[i+1][j]+=b[i][j]/2\n               b[i][j]=b[i][j]/2*2\n               a[i+1][j+1]+=b[i][j]/2\n               b[i][j]=0\nprint(ot)\n", "def cuenta_uno(va):\n    resp = 0\n    for f in range(n):\n        resp += va[f].count(1)\n    return resp\n#------------------------------------------\n# Programa principal\n#------------------------------------------\nn, t = input().split(' ')\nn, t = [int(n), int(t)]\n#n, t = [3, 5]\n#print(n, t)\nva = [[0 for i in range(n + 1)] for i in range(n)]\nch = [0 for i in range(n + 1)]\n#escribe_matriz(va)\n\nmax = 0\nfor i in range(n + 1):\n    max += i\n\n# ciclo de segundos virtiendo vino\nc1 = 1\nwhile c1 <= t and cuenta_uno(va) < max:\n#for c1 in range(t):\n    # poner la champa\u00f1a\n    ch = [0 for i in range(n + 1)]\n    ch[0] = 1\n    i_va = 0\n    while sum(ch) > 0 and i_va < n and cuenta_uno(va) <= 55:\n        #poner el vino en la i_va fila de vasos\n        for ct in range(n):\n            va[i_va][ct] += ch[ct]\n        #el vino que sobre divide en 2 y pasa a los dos vasos inmediatamente inferiores\n        ch = [0 for i in range(n + 1)]\n        for ct in range(n):\n            if va[i_va][ct] > 1:\n                ch[ct] += (va[i_va][ct] - 1) / 2\n                ch[ct + 1] += (va[i_va][ct] - 1) / 2\n                va[i_va][ct] = 1\n        i_va += 1\n    #escribe_matriz(va)\n    #print (\"c1 = \", c1, \" i_va=\", i_va, \"cuenta_uno\", cuenta_uno(va), \" ch=\", ch)\n    c1 += 1\n#escribe_matriz(va)\nprint(cuenta_uno(va))\n", "inin=input().split(' ')\nn=int(inin[0])\nt=int(inin[1])\n\nmat=[]\nfor i in range(n+2):\n\tmat.append([0.0]*(n+2))\n\n# def add(i,j,amt):\n# \tif i>=n or j<0 or j>=n:\n# \t\treturn\n# \tmat[i][j]+=amt\n# \tif mat[i][j]>1:\n# \t\tover=mat[i][j]-1\n# \t\tmat[i][j]-=over\n# \t\tadd(i+1,j,over/2)\n# \t\tadd(i+1,j+1,over/2)\n\nfor time in range(t):\n\t# add(0,0,1)\n\tmat[1][1]+=1.0\n\tfor i in range(1,n+1):\n\t\tfor j in range(1,i+1):\n\t\t\tif mat[i][j]>1.0:\n\t\t\t\tover=mat[i][j]-1.0\n\t\t\t\tmat[i+1][j]+=over/2\n\t\t\t\tmat[i+1][j+1]+=over/2\n\t\t\t\tmat[i][j]=1.0\n\nresult=0\nfor i in range(1,n+1):\n\t\tfor j in range(1,i+1):\n\t\t\tif mat[i][j]>=1.0:\n\t\t\t\tresult+=1\nprint(result)\n\n# for line in mat:\n# \t# print(line)\n# \tfor b in line:\n# \t\tprint(str(b),end='\\t')\n# \tprint()\n", "from copy import deepcopy\ndef main():\n    n, k = list(map(int, input().split()))\n    arr = [\n        [1],\n        [0.5, 0.5],\n        [0.25, 0.5, 0.25],\n        [0.125, 0.375, 0.375, 0.125],\n        [0.0625, 0.25, 0.375, 0.25, 0.0625],\n        [0.03125, 0.15625, 0.3125, 0.3125, 0.15625, 0.03125],\n        [0.015625, 0.09375, 0.234375, 0.3125, 0.234375, 0.09375, 0.015625],\n        [0.0078125, 0.0546875, 0.1640625, 0.2734375, 0.2734375, 0.1640625, 0.0546875, 0.0078125],\n        [0.00390625, 0.03125, 0.109375, 0.21875, 0.2734375, 0.21875, 0.109375, 0.03125, 0.00390625],\n        [0.001953125, 0.017578125, 0.0703125, 0.1640625, 0.24609375, 0.24609375, 0.1640625, 0.0703125, 0.017578125, 0.001953125]\n    ]\n    opyramid = [\n        [1],\n        [0, 0],\n        [0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    ]\n    finish_times = [\n        [1],\n        [0, 0],\n        [0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    ]\n    opyramid[0][0] = 1\n    countarr = [0, 1]\n    for x in range(2, 10001):\n        opyramid[0][0] += 1\n        for y in range(1, len(opyramid)):\n            opyramid[y][0] += max(opyramid[y - 1][0] - 1, 0) * 0.5\n            opyramid[y - 1][0] -= max(opyramid[y - 1][0] - 1, 0) * 0.5\n            for z in range(1, y):\n                opyramid[y][z] += max(opyramid[y - 1][z - 1] - 1, 0) + \\\n                    max(opyramid[y - 1][z] - 1, 0) * 0.5\n                opyramid[y - 1][z - 1] -= max(opyramid[y - 1][z - 1] - 1, 0)\n                opyramid[y - 1][z] -= max(opyramid[y - 1][z] - 1, 0) * 0.5\n            opyramid[y][y] += max(opyramid[y - 1][y - 1] - 1, 0)\n            opyramid[y - 1][y - 1] -= max(opyramid[y - 1][y - 1] - 1, 0)\n        # print(opyramid)\n        count = 0\n        for x in range(n):\n            for y in opyramid[x]:\n                if y >= 1:\n                    count += 1\n        countarr.append(count)\n    print(countarr[k])\n\n    # arr = [\n    #     [1],\n    #     [0.5, 0.5],]\n    # for x in range(3, 11):\n    #     na = []\n    #     for y in range(x - 2):\n    #         na.append(arr[-1][y]*0.5 + arr[-1][y + 1]*0.5)\n    #     arr.append([arr[-1][0] * 0.5] + na + [arr[-1][-1] * 0.5])\n    # print(arr)\n    # #     [1, 2, 1],\n    # #     [1, 3, 3, 1],\n    # #     [1, 4, 6, 4, 1],\n    # #     [1, 5, 10, 10, 5, 1],\n    # #     [1, 6, 15, 20, 15, 6, 1],\n    # #     [1, 7, 21, 35, 35, 21, 7, 1],\n    # #     [1, 8, 28, 56, 70, 56, 28, 8, 1]]\n\n    # # arr = [\n    # #     [1],\n    # #     [1, 1],\n    # #     [1, 2, 1],\n    # #     [1, 3, 3, 1],\n    # #     [1, 4, 6, 4, 1],\n    # #     [1, 5, 10, 10, 5, 1],\n    # #     [1, 6, 15, 20, 15, 6, 1],\n    # #     [1, 7, 21, 35, 35, 21, 7, 1],\n    # #     [1, 8, 28, 56, 70, 56, 28, 8, 1]]\n\n    # # print(arr)\n\nmain()\n", "def push(graph, pos, level):\n    if graph[pos] > 1:\n        over = graph[pos] - 1\n        graph[pos] = 1\n        if level + pos < numberofglasses:\n            graph[level + pos] += over / 2\n        if level + pos + 1 < numberofglasses:\n            graph[level + pos + 1] += over / 2\n        if level + pos < numberofglasses:\n            push(graph, level + pos, level + 1)\n        if level + pos + 1 < numberofglasses:\n            push(graph, level + pos + 1, level + 1)\n\n\nn, t = map(int, input().split())\ntable = dict()\ncurrent = 0\nfor i in range(1, 11):\n    current += i\n    table[i] = current\ngraph = [0] * table[n]\nnumberofglasses = table[n]\ngraph[0] = t\npush(graph, 0, 1)\ncounter = 0\nfor elem in graph:\n    if elem == 1:\n        counter += 1\nprint(counter)", "from fractions import Fraction\n\ninp = input().split()\nN, T = int(inp[0]), int(inp[1])\n\nif T is 0:\n    print(0)\n    return\n\ndp = []\nfor r in range(N + 1):\n    dp.append([Fraction(0) for _ in range(N + 1)])\n\ndp[0][0] = Fraction(T)\nfor r in range(N):\n    for c in range(r + 1):\n        if dp[r][c] >= Fraction(1):\n            dp[r + 1][c + 0] += (dp[r][c] - Fraction(1)) / Fraction(2);\n            dp[r + 1][c + 1] += (dp[r][c] - Fraction(1)) / Fraction(2);\n\ncnt = 0\nfor r in range(N):\n    for c in range(r + 1):\n        if dp[r][c] >= Fraction(1):\n            cnt += 1\n\nprint(cnt)\n", "def push(graph, pos, level):\n    if graph[pos] > 1:\n        over = graph[pos] - 1\n        graph[pos] = 1\n        if level + pos < numberofglasses:\n            graph[level + pos] += over / 2\n        if level + pos + 1 < numberofglasses:\n            graph[level + pos + 1] += over / 2\n        if level + pos < numberofglasses:\n            push(graph, level + pos, level + 1)\n        if level + pos + 1 < numberofglasses:\n            push(graph, level + pos + 1, level + 1)\n\n\nn, t = map(int, input().split())\ntable = dict()\ncurrent = 0\nfor i in range(1, 11):\n    current += i\n    table[i] = current\ngraph = [0] * table[n]\nnumberofglasses = table[n]\n\ngraph[0] += t\npush(graph, 0, 1)\ncounter = 0\nfor elem in graph:\n    if elem == 1:\n        counter += 1\nprint(counter)", "n, t = list(map(int, input().split()))\ntotal = sum(range(1, n+1))\nl = [[0] * i for i in range(1, n+1)]\nmax_d = sum(range(1, n+1))\nd = 0\n\ndef f(l, lvl, i, inc):\n    if lvl >= len(l) or i >= len(l[lvl]):\n        return\n    if l[lvl][i] < 1:\n        tmp = l[lvl][i] + inc\n        if tmp > 1:\n            inc = tmp - 1\n            l[lvl][i] = 1\n        else:\n            l[lvl][i] += inc\n            inc = 0\n    if inc == 0:\n        return\n    inc /= 2\n    lvl += 1\n    f(l, lvl, i, inc)\n    f(l, lvl, i+1, inc)\n        \ndef count(l):\n    ans = 0\n    for i in range(len(l)):\n        for j in range(len(l[i])):\n            if l[i][j] >= 1:\n                ans += 1\n    return ans\n\nf(l, 0, 0, t)\n\nprint(count(l))\n\n    \n\n", "n, t = map(int, input().split())\na = [0] * (n + 1)\nfor i in range(n + 1):\n    a[i] = [0] * (i + 1)\nfor i in range(t):\n    a[0][0] += 1\n    for j in range(n):\n        for k in range(j + 1):\n            if a[j][k] > 1:\n                a[j + 1][k] += (a[j][k] - 1) / 2\n                a[j + 1][k + 1] += (a[j][k] - 1) / 2\n                a[j][k] = 1\nres = 0\n\nfor j in range(n):\n    for k in range(j + 1):\n        if a[j][k] == 1:\n            res += 1\n\nprint(res)"]
["from collections import deque\nK=int(input())\n\n\nINF=10**9\nres=[INF]*(K)\nres[1]=1\nq=deque()\nq.append(1)\nwhile q:\n    r=q.popleft()\n    if r==0:\n        break\n    nr=(r+1)%K\n    if res[r]<res[nr]:\n        res[nr]=res[r]+1\n        q.append(nr)\n    nr=(10*r)%K\n    if res[r]<res[nr]:\n        res[nr]=res[r]\n        q.appendleft(nr)\nprint(res[0])", "from collections import deque\nK = int(input())\nE = [[(i*10)%K,(i+1)%K] for i in range(K)] # E[i][0] \u304ccost 0, E[i][1]\u304ccost 1\nINF = K*10\nV = [INF] * (K)\nV[1] = 1\nq = deque([1])\ni = 1\nwhile q:\n    i = q.popleft()\n    if V[E[i][0]] > V[i]:\n        q.appendleft(E[i][0])\n        V[E[i][0]] = V[i]\n    if V[E[i][1]] > V[i]+1:\n        q.append(E[i][1])\n        V[E[i][1]] = V[i]+1\nprint(V[0])", "from collections import deque\nK=int(input())\n\nd=[1000000 for x in range(K+1)]\nd[1]=1\n\ndef bfs(K):\n  q=deque()\n  q.append(1)\n  while q:\n    nx=q.popleft()\n    if d[(nx*10)%K]>d[nx]:\n      d[(nx*10)%K]=d[nx]\n      q.appendleft((nx*10)%K)\n    if d[(nx+1)%K]>d[nx]+1:\n      d[(nx+1)%K]=d[nx]+1\n      q.append((nx+1)%K)\n  return d[0]\n\nprint(bfs(K))", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\n\nclass Graph(object):\n\n    def __init__(self, K):\n        self.K = K\n        self.weights = {}\n\n    def add(self, node1, node2, weight):\n        if (node1, node2) in self.weights:\n            self.weights[(node1, node2)] = min(self.weights[(node1, node2)], weight)\n        else:\n            self.weights[(node1, node2)] = weight\n\n    def to_csr(self):\n        n1, n2, w = [], [], []\n        for (node1, node2), weight in self.weights.items():\n            n1.append(node1)\n            n2.append(node2)\n            w.append(weight)\n        return csr_matrix((w, (n1, n2)), shape=(self.K, self.K))\n\n\nK = int(input())\ng = Graph(K)\n\nfor i in range(K):\n    if i == K - 1:\n        g.add(i, 0, 1)\n    else:\n        g.add(i, i + 1, 1)\n    g.add(i, (i * 10) % K, 10**(-8))\n\nd = dijkstra(g.to_csr(), directed=True, indices=1)\nprint(int(d[0]) + 1)", "from collections import deque\nK = int(input())\ncost = [-1] * K\ndeq = deque([(1,1)])\nwhile deq:\n    x, d = deq.popleft()\n    if cost[x] >= 0: continue\n    cost[x] = d\n    if x == 0: break\n    for y, c in [(10*x%K, 0), ((x+1)%K, 1)]:\n        if c: deq.append((y, d + 1))\n        else: deq.appendleft((y, d))\nprint(cost[0])", "#!/usr/bin/env python3\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\n\n\nk = int(input())\nq = deque()\nq.append(1)\n\ndp = [10**10]*(k)\ndp[1] = 0\n\nwhile q:\n    u = q.popleft()\n    if dp[(u*10) % k] > dp[u]:\n        dp[(u*10) % k] = dp[u]\n        q.appendleft((u*10) % k)\n    if dp[(u+1) % k] > dp[u]+1:\n        dp[(u+1) % k] = dp[u]+1\n        q.append((u+1) % k)\n\nprint((dp[0]+1))\n", "import heapq\n\ndef generate_graph(K):\n    return [{(i + 1) % K: 1, (i * 10) % K: 0} for i in range(K)]\n\ndef dijkstra(start, goal, graph):\n    answer = [float(\"inf\")] * len(graph)\n    answer[start] = 0\n    remains = sorted([[v, i] for i, v in enumerate(answer)])\n\n    while remains:\n        _, i = heapq.heappop(remains)\n        for j, cost in list(graph[i].items()):\n            if answer[j] > answer[i] + cost:\n                answer[j] = answer[i] + cost\n                heapq.heappush(remains, [answer[j], j])\n\n    return answer[goal] + 1\n\nK = int(input())\ngraph = generate_graph(K)\nprint(dijkstra(1, 0, graph))\n", "# coding: utf-8\n# Your code here!\n\n\"\"\"\n01-BFS\n\u8fba\u306e\u91cd\u307f\u304c0 or 1 \u306e\u3068\u304d\u3001deque\u3092\u4f7f\u3063\u3066dijkstra\u3092\u9ad8\u901f\u5316\u3067\u304d\u308b\n\"\"\"\nfrom collections import deque\ndef bfs01(g,start):\n    n = len(g)\n    res = [float(\"inf\")]*n #start\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n    res[start] = 0\n    pending = n-1 #\u672a\u78ba\u5b9a\u306e\u70b9\u306e\u500b\u6570\n    q = deque([(0,start)]) #(\u305d\u3053\u307e\u3067\u306e\u8ddd\u96e2\u3001\u70b9)\n    while q and pending:\n        dv,v = q.popleft()\n        if res[v] < dv: continue\n        pending -= 1\n        #if v==goal: break\n        for to,cost in g[v]:\n            if dv + cost < res[to]:\n                res[to] = dv + cost\n                if cost: q.append((res[to],to))\n                else: q.appendleft((res[to],to))\n    return res\n\n######################################################################\n#ARC084 small multiple\n#\n######################################################################\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306e\u3068\u304d\u306f\u6ce8\u610f\n\nk = int(input())\n\ng = [[] for _ in range(k)]\nfor i in range(k):\n    g[i].append(((i+1)%k,1))\n    g[i].append((10*i%k,0))\n\nres = bfs01(g,1)\nprint((res[0]+1))\n", "import collections\nK = int(input())\nQ = collections.deque([(1, 1)])\nsearched = set()\nwhile True:\n    n, d = Q.popleft()\n    r = n % K\n    if not r in searched:\n        if r == 0:\n            break\n        else:\n            searched.add(r)\n            Q.append((n + 1, d + 1))\n            Q.appendleft((n * 10 % K, d))\nprint(d)\n# https://img.atcoder.jp/arc084/editorial.pdf\n", "from collections import defaultdict\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inpl(): return list(map(int, input().split()))\ndef inpl_s(): return list(input().split())\n\nK = int(input())\n\n\nlines = defaultdict(set)\nfor i in range(K-1):\n\tlines[i].add((i+1,1))\nlines[K-1].add((0,1))\n\nfor s in range(K):\n\tt = s*10 % K\n\tif s != t:\n\t\tlines[s].add((t,0))\n\ndef search (s,w_0): #s->t\n\tnonlocal weight\n\tnonlocal q\n\n\tfor line in list(lines[s]):\n\t\tt = line[0]\n\t\tw = w_0 + line[1]\n\t\tif weight[t] > w:\n\t\t\theapq.heappush(q, [w,t])\n\t\t\tweight[t] = w\n\ns = 1\nweight = [INF]*K\nweight[s] = 0\nq = [[0,s]]\nheapq.heapify(q)\nwhile q:\n\tw,n = heapq.heappop(q)\n\tsearch(n,w)\n\nprint((weight[0]+1))\n", "from collections import deque\nq = deque()\nans = {}\nK = int(input())\nq.append((1,1))\nwhile len(q):\n  resid,total = q.popleft()\n  if resid in ans:\n    continue\n  ans[resid] = total\n  q.appendleft((resid*10%K,total))\n  q.append(((resid+1)%K,total+1))\nprint(ans[0])", "from collections import deque\n\nK = int(input())\n\nG = [None]*K\nfor i in range(K):\n    G[i] = ((10*i % K, 0), ((i+1) % K, 1))\ns = 1\n\ndist = [10**9] * K\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d+c < dist[w]:\n                dist[w] = d+c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint((dist[0]+1))\n", "k = int(input())\n\nINF = 10 ** 6\n\nd = [INF for _ in range(k)]\n\nd[1] = 1\ntemp = [[1,1]]\nwhile 1:\n    next = []\n    for p, c in temp:\n        if c + 1 < d[(p + 1) % k]:\n            d[(p + 1) % k] = c + 1\n            next.append([(p + 1) % k, c + 1])\n        if c < d[(p * 10) % k]:\n            d[(p * 10) % k] = c\n            next.append([(p * 10) % k, c])\n    if len(next) == 0:\n        break\n    else:\n        temp = [] + next\n\nprint(d[0])", "from collections import deque\n\ndef bfs(K:int) -> list:\n    hasChecked = [False]*(K+1)\n    cost_list = [0]*(K+1)\n    cost_list[1] = 1\n    \n    que = deque([(cost_list[1], 1)])\n    \n    while que:\n        cost, res = que.popleft()\n        if hasChecked[res]:\n            continue\n        \n        hasChecked[res] = True\n        cost_list[res] = cost\n        \n        if not hasChecked[10*res%K]:\n            que.appendleft((cost, 10*res%K))\n            \n        if not hasChecked[(res+1)%K]:\n            que.append((cost+1, (res+1)%K))\n            \n            \n    return cost_list\n\n\nK = int(input())\ncost_list = bfs(K)\nprint((cost_list[0]))\n", "# \u6841\u548c\u6700\u5c0f\u306e\u81ea\u7136\u6570\u306f1\nfrom collections import deque\nk = int(input())\nd = [k] * k\ne = [[(0, i * 10 % k), (1, (i + 1) % k)] for i in range(k)]\ndq = deque()\ndq.append((1, 1))\nwhile dq:\n    c, v = dq.popleft()\n    for v2nv, nv in e[v]:\n        if v2nv == 0:\n            if c < d[nv]:\n                d[nv] = c\n                dq.appendleft((d[nv], nv))\n        else:\n            if c + 1 < d[nv]:\n                d[nv] = c + 1\n                dq.append((d[nv], nv))\nprint((d[0]))\n", "from collections import deque\nk=int(input())\ndist=[float('inf') for _ in range(k)]\ndist[1]=1\nq=deque()\nq.append(1)\nwhile len(q)>0:\n    r=q.popleft()\n    s=(r+1)%k\n    if dist[r]+1<dist[s]:\n        dist[s]=dist[r]+1\n        q.append(s)\n    t=(r*10)%k\n    if dist[r]<dist[t]:\n        dist[t]=dist[r]\n        q.appendleft(t)\nprint(dist[0])", "import sys\nK=int(input())\n\ngraph=[[] for _ in range(K)]\nfor i in range(K):\n  graph[i].append(((i+1)%K,1))\n  graph[i].append(((10*i)%K,0))\n#print(graph)\n\ndist=[-1]*K\ns,t=1,0\nqueue=[s]\nd=0\nwhile queue:\n  new_queue=set()\n  \n  while queue:\n    q=queue.pop()  \n    if dist[q]==-1:\n      dist[q]=d\n      for v,w in graph[q]:\n        if w==0:\n          queue.append(v)\n        else:\n          new_queue.add(v)\n  \n  d+=1\n  queue=list(new_queue)\n  \n#print(dist)\nprint(dist[0]+1)", "def solve(K):\n    checked = [False] * K\n    def calc(x):\n        while not checked[x]:\n            checked[x] = True\n            yield x\n            x = (x * 10) % K\n    i = 0\n    xs = [0]\n    while 1:\n        i += 1\n        ys = []\n        for x in xs:\n            for z in calc((x + 1) % K):\n                if z == 0:\n                    return i\n                ys.append(z)\n        xs = ys\n\nK = int(input())\nprint(solve(K))", "from collections import deque\n\nK = int(input())\n\nG = [None]*K\nfor i in range(K):\n    G[i] = ((10*i % K, 0), ((i+1) % K, 1))\ns = 1\n\ndist = [10**9] * K\nque = deque([s])\ndist[s] = 0\nwhile que:\n    v = que.popleft()\n    d = dist[v]\n    for w, c in G[v]:\n        if d+c < dist[w]:\n            dist[w] = d+c\n            if c:\n                que.append(w)\n            else:\n                que.appendleft(w)\n\nprint(dist[0]+1)", "from collections import deque\nk = int(input())\nd = deque()\nmat = []\nfor i in range(k):\n    mat.append([])\n#mark = [False]*k\ndis = [10**18]*k\ndis[1] = 0\nfor i in range(k):\n    mat[i].append(((i+1)%k,True))\n\n    if (10*i)%k != i:\n        mat[i].append(((10*i)%k,False))\n\n#bfs 1->0\nd.append(1)\nres = 0\nwhile d:\n    left = d.popleft()\n    for neighbour,edge in mat[left]:\n        distance = edge + dis[left]\n        if dis[neighbour] > distance: \n            dis[neighbour] = distance \n            \n            if edge == 0:\n                d.appendleft(neighbour)\n            else:\n                d.append(neighbour)\nprint((dis[0]+1)) \n\n", "from collections import deque\n\ndef solve(k):\n    que = deque()\n    que.append((1, 1))\n    dp = {1: 1}\n    while que:\n        x, c = que.pop()\n        y = (x + 1) % k\n        if (not y in dp) or (dp[y] > c + 1):\n            dp[y] = c + 1\n            que.appendleft((y, c+1))\n        z = (10 * x) % k\n        if (not z in dp) or (dp[z] > c):\n            dp[z] = c\n            que.append((z, c))\n    return dp[0]\n\nk = int(input())\nprint(solve(k))", "import queue\n\n\ndef bfs01(s: int, t: int, V: int, graph: list)->int:\n    '''01-bfs\n    :param s: source\n    :param t: sink\n    :param V: number of vertex\n    :param graph: graph\n    :return: minimum distance from `s` to `t`\n    '''\n    INF = float('inf')\n\n    # deque \u3068 s \u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u3092\u521d\u671f\u5316\u3059\u308b\u3002\n    q = queue.deque([])  # deque\n    qc = 0               # \u6bce\u5ea6 len(q) \u3092\u56de\u3059\u3068\u6642\u9593\u304b\u304b\u308a\u305d\u3046\u306a\u306e\u3067\u5909\u6570\u3067\u7ba1\u7406\n    l = [INF] * V        # s \u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u8ddd\u96e2\n\n    # s \u306b\u95a2\u3059\u308b\u521d\u671f\u5316\n    q.append(s)\n    qc += 1\n    l[s] = 0\n\n    # deque \u306b\u9802\u70b9\u304c\u5b58\u5728\u3059\u308b\u9650\u308a\u6b21\u3092\u7e70\u308a\u8fd4\u3059\u3002\n    # 1. deque \u306e\u5148\u982d\u304b\u3089\u9802\u70b9\u3092\u53d6\u308a\u51fa\u3059\u3002\n    # 2. \u53d6\u308a\u51fa\u3057\u305f\u9802\u70b9\u306b\u96a3\u63a5\u3059\u308b\u5168\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u3092\u884c\u3046\u3002\n    # 2-a. \u8ddd\u96e2\u304c\u66f4\u65b0\u3055\u308c\u308b\u306a\u3089\u66f4\u65b0\u3059\u308b\u3002\u52a0\u3048\u3066\u8fba\u306e\u9577\u3055\u304c 0 \u306a\u3089\n    #      \u5148\u982d\u306b\u30011 \u306a\u3089\u672b\u5c3e\u306b\u8ffd\u52a0\u3059\u308b\u3002\n    while qc > 0:\n        u = q.popleft()\n        qc -= 1\n        for v, c in graph[u]:\n            if l[u] + c < l[v]:\n                l[v] = l[u] + c\n                qc += 1\n                if c == 0:\n                    q.appendleft(v)\n                else:\n                    q.append(v)\n\n    return l[t]\n\n\ndef small_multiple(K: int)->int:\n    graph = []\n    for k in range(K):\n        # k -> k+1 \u306b 1 \u306e\u8fba\u3092\u3001k -> 10*k \u306b 0 \u306e\u8fba\u3092\u5f35\u308b\u3002\n        # \u305f\u3060\u3057\u3001\u3069\u3061\u3089\u3082 mod K \u3092\u3068\u3063\u3066 k \u3068\u7b49\u3057\u304f\u306a\u3044\u5834\u5408\u306e\u307f\n        graph.append([])\n        v1 = k+1 if k+1 < K else 0\n        v10 = (k*10) % K\n\n        graph[k].append((v1, 1))\n        if v10 != k:\n            graph[k].append((v10, 0))\n\n    return bfs01(1, 0, K, graph) + 1\n\n\ndef __starting_point():\n    K = int(input())\n    ans = small_multiple(K)\n    print(ans)\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nimport heapq\nINF = float(\"inf\")\n\n\nclass Graph(object):\n    def __init__(self, N):\n        self.N = N\n        self.V = list(range(N))\n        self.E = [[] for _ in range(N)]\n\n    def add_edge(self, edge):\n        \"\"\"\u8fba\u3092\u52a0\u3048\u308b\u3002edge\u306f(\u59cb\u70b9, \u7d42\u70b9\u3001\u91cd\u307f)\u304b\u3089\u306a\u308b\u30ea\u30b9\u30c8\n        \u91cd\u307f\u304c\u306a\u3051\u308c\u3070\u3001\u91cd\u307f1\u3068\u3059\u308b\u3002\n        \"\"\"\n        if len(edge) == 2:\n            edge.append(1)\n        elif len(edge) != 3:\n            print(\"error in add_edge\")\n            pass\n\n        s, t, w = edge\n        self.E[s].append([t, w])\n\n        pass\n\n\ndef shortestPath(g: Graph, s: int):\n    \"\"\" \u30b0\u30e9\u30d5g\u306b\u304a\u3044\u3066\u3001\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\n    \u5f15\u6570\n    g: \u30b0\u30e9\u30d5, s: \u59cb\u70b9\n    \u8fd4\u308a\u5024\n    dist: \u59cb\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u304c\u683c\u7d0d\u3055\u308c\u305f\u30ea\u30b9\u30c8\n    prev: \u59cb\u70b9\u304b\u3089\u6700\u77ed\u7d4c\u8def\u3067\u79fb\u52d5\u3059\u308b\u5834\u5408\u3001\u5404\u9802\u70b9\u306b\u81f3\u308b\u524d\u306e\u9802\u70b9\u306e\u30ea\u30b9\u30c8\n    \"\"\"\n    dist = [INF]*g.N\n    dist[s] = 0\n\n    prev = [None]*g.N\n    Q = []\n    heapq.heappush(Q, (dist[s], s))\n\n    while len(Q) > 0:\n        _, u = heapq.heappop(Q)\n        for v, w in g.E[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                prev[v] = u\n                heapq.heappush(Q, (dist[v], v))\n    return dist, prev\n\n\ndef solve(K: int):\n    g = Graph(K)\n    for i in range(1, K):\n        # 1\u3092\u52a0\u3048\u308b\n        g.add_edge([i, (i+1) % K, 1])\n        # 10\u500d\u3059\u308b\n        g.add_edge([i, (10*i) % K, 0])\n    dist, prev = shortestPath(g, 1)\n    print((dist[0]+1))\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    K = int(next(tokens))  # type: int\n    solve(K)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom collections import deque\n\nINF = 10**9\nk = int(input())\n\n# (\u8fba\u306e\u4f38\u3073\u308b\u5148, \u30b3\u30b9\u30c8)\nG = [((10 * i % k, 0), ((i + 1) % k, 1)) for i in range(k)]\ns = 1\n\n# 01 - BFS\ndist = [INF] * k\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d + c < dist[w]:\n                dist[w] = d + c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0] + 1)", "from collections import deque\nk=int(input())\nt=[1]*k\nq=deque()\nq.append((1,1))\n\nwhile q:\n  p,r=q.popleft()\n  if p==0:\n    print(r)\n    break\n  if t[p]:\n    t[p]=0\n    q.appendleft(((p*10)%k,r))\n    q.append(((p+1)%k,r+1))", "K = int(input())\n\nG = [((10*i % K, 0), ((i+1) % K, 1)) for i in range(K)]\ns = 1\n\ndist = [10**9] * K\nS = [s]\nT = []\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.pop()\n        for w, c in G[v]:\n            if d+c < dist[w]:\n                dist[w] = d+c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0]+1)", "from collections import deque\n\nK = int(input())\n\nG = [None]*K\nfor i in range(K):\n    G[i] = ((10*i % K, 0), ((i+1) % K, 1))\ns = 1\n\ndist = [10**9] * K\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d+c < dist[w]:\n                dist[w] = d+c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0]+1)", "from collections import deque\nq=deque()\nK=int(input())\na=q.append\na((1,1))\nm={}\nwhile len(q):\n n,s=q.popleft()\n if n in m:continue\n m[n]=s\n q.appendleft((n*10%K,s))\n a(((n+1)%K,s+1))\nprint(m[0])", "import sys\nfrom collections import deque\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  k = ni()\n  q = deque()\n  q.append(1)\n  dist = [k]*k\n  dist[1] = 1\n  while q:\n    v = q.popleft()\n    if dist[(v + 1) % k] > dist[v] + 1:\n      dist[(v + 1) % k] = dist[v] + 1\n      q.append((v + 1) % k)\n    if dist[v*10%k] > dist[v]:\n      dist[v*10%k] = dist[v]\n      q.appendleft(v*10%k)\n  print(dist[0])\n  return\n\nsolve()", "from collections import deque\nk = int(input())\n\ne = [[] for i in range(k)]\nfor i in range(k):\n    e[i].append(((i+1)%k,1))\n    if i*10%k != i:\n        e[i].append(((i*10)%k,0))\n\nd = [-1]*k\nd[1] = 0\nq = deque([])\nq.append((1,0))\nwhile q:\n    now,dis = q.popleft()\n\n    for nex,cost in e[now]:\n        if d[nex] == -1 or d[nex] > dis+cost:\n            d[nex] = dis+cost\n            if cost == 0:\n                q.appendleft((nex,dis))\n            else:\n                q.append((nex,dis+1))\n\nprint(d[0]+1)", "from collections import deque\nk=int(input())\nt=[1]*k\nq=deque()\nq.append((1,1))\nwhile q:\n    p,r=q.popleft()\n    if p==0:\n        print(r)\n        break\n    if t[p]:\n        t[p]=0\n        q.appendleft(((p*10)%k,r))\n        q.append(((p+1)%k,r+1))", "#import sys\n#import numpy as np\nimport itertools\nfrom scipy.sparse import coo_matrix, lil_matrix\nfrom scipy.sparse.csgraph import dijkstra, bellman_ford, floyd_warshall\n#sys.setrecursionlimit(10000)\n\n#H, W = [int(i) for i in input().split()]\nN = int(input())\n\nrows = []\ncols = []\nweights = []\n\n\"\"\"\nfor _ in range(M):\n    # u v \u9593\u306e\u30b3\u30b9\u30c8\n    u, v, a = [int(i) for i in input().split()]\n    rows.append(u-1)\n    cols.append(v-1)\n    weights.append(a)\n\"\"\"\n\nfor i in range(N):\n    rows.append(i)\n    cols.append((i+1)%N)\n    weights.append(1)\n\nfor i in range(N):\n    if i - ((10 * i) % N) == -1:\n        weights[i] = 0\n    elif i == N-1 and i - ((10 * i) % N) == 1:\n        weights[i] = 0\n    else:\n        rows.append(i)\n        cols.append((10 * i) % N)\n        weights.append(0)\n\ngraph = coo_matrix((weights, (rows, cols)), shape=(N, N)).tocsr()\n#graph = coo_matrix((weights, (cols, rows)), shape=(10, 10)).tocsr()\n#print(graph)\nd1 = dijkstra(graph, indices=1, directed=True, unweighted=False)\n\nprint((int(d1[0]+1.5)))\n\n", "k = int(input())\n\nimport heapq\nINF = 10**9\n\nclass Dijkstra:\n    def __init__(self, adj):\n        self.adj = adj\n        self.num = len(adj)\n        self.dist = [INF] * self.num\n        self.prev = [INF] * self.num\n        self.q = []\n\n    def calc(self, start):\n        self.dist[start] = 0\n        heapq.heappush(self.q, (0, start))\n        while len(self.q) != 0:\n            prov_cost, src = heapq.heappop(self.q)\n            if self.dist[src] < prov_cost:\n                continue\n            for dest, cost in self.adj[src]:\n                if self.dist[dest] > self.dist[src] + cost:\n                    self.dist[dest] = self.dist[src] + cost\n                    heapq.heappush(self.q, (self.dist[dest], dest))\n                    self.prev[dest] = src\n        return self.dist\n\nedge = [[] for _ in range(k)]\nfor i in range(k):\n    edge[i].append([(i+1) % k, 1])\n    edge[i].append([(i*10) % k, 0])\n\nDIJ = Dijkstra(edge)\nDIJ.calc\nprint(DIJ.calc(1)[0] + 1)", "from collections import deque\n\nK = int(input())\n\nvisited=[False]*K\ns=(1,1)\n\nq = deque()\nq.append(s)\n\nwhile True:\n  c = q.popleft()\n  visited[c[0]] = True\n\n  if c[0] == 0:\n    print(c[1])\n    return\n\n  if not visited[(c[0] * 10) % K] and not visited[(c[0] * 10) % K]:\n    q.appendleft(((c[0] * 10) % K, c[1]))\n\n  if not visited[(c[0] + 1) % K] and not visited[(c[0] + 1) % K]:\n    q.append(((c[0] + 1) % K, c[1] + 1))", "from collections import deque\ndef bfs01(K,adjlist):\n    reached=[False]*K\n    d=deque()\n    d.append((1,0))\n    reached[1]=True\n    while True:\n        cur=d.popleft()\n        reached[cur[0]]=True\n        if cur[0]==0:\n            return cur[1]\n        for j,w in adjlist[cur[0]]:\n            if w==0:\n                if not reached[j]:\n                    d.appendleft((j,cur[1]))\n            elif w==1:\n                if not reached[j]:\n                    d.append((j,cur[1]+1))\n                \n    \n\nK=int(input())\nadjlist=[[] for _ in range(K)]\nfor i in range(K):\n    to1=(i+1)%K\n    to2=(10*i)%K\n    if to1==to2:\n        adjlist[i]=[(to2,0)]\n    else:\n        adjlist[i]=[(to1,1),(to2,0)]\nprint(bfs01(K,adjlist)+1)", "from collections import deque\n\n\ndef solve(K):\n    s = 1\n    q = deque()\n    q.append(s)\n    dists = {}\n    dists[s] = 1\n    while len(q) > 0:\n        n = q.pop()\n        if n == 0:\n            break\n        m = (n*10)%K\n        if m not in dists:\n            dists[m] = dists[n]\n            q.append(m)\n        elif dists[m] > dists[n]:\n            dists[m] = dists[n]\n            q.append(m)\n        if n % 10 != 9:\n            m = (n+1)%K\n            if m not in dists:\n                dists[m] = dists[n] + 1\n                q.appendleft(m)\n            elif dists[m] > dists[n] + 1:\n                dists[m] = dists[n] + 1\n                q.appendleft(m)\n    return dists[0]\n\n\ndef main():\n    K = int(input())\n    print((solve(K)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nK=int(input())\ndist=[10**15 for i in range(K)]\ndist[1]=1\nq=deque([1])\nwhile(len(q)>0):\n    r=q.popleft()\n    s=(r+1)%K\n    if dist[r]+1<dist[s]:\n        dist[s]=dist[r]+1\n        q.append(s)\n    t=(r*10)%K\n    if dist[r]<dist[t]:\n        dist[t]=dist[r]\n        q.appendleft(t)\nprint((dist[0]))\n", "from collections import deque\nn = int(input())\nmins = [1000 for i in range(n+1)]\nused = [0 for i in range(n+1)]\ndeq = deque()\ndeq.append((1,1))\nwhile deq:\n  x,cnt = deq.popleft()\n  mins[x] = min(mins[x],cnt)\n  used[x] = 1\n  if used[10*x%n] == 0:\n    deq.appendleft((10*x%n,cnt))\n  if used[(x+1)%n] == 0:\n    deq.append(((x+1)%n,cnt+1))\nprint(mins[0])", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**5) \n \ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import deque\n\nk = ni()\nque = deque([(1,1)])\n\nkmod = [0]*k\n\nwhile kmod[0] == 0:\n    cost, idx = que.popleft()\n    if kmod[idx] == 0:\n        kmod[idx] = cost\n        if kmod[10*idx%k] == 0:\n            que.appendleft((cost, (10*idx%k)))\n        if kmod[(idx+1)%k] == 0:\n            que.append((cost+1, (idx+1)%k))            \n        \nprint(kmod[0])", "from scipy.sparse.csgraph import dijkstra, shortest_path\nfrom scipy.sparse import csr_matrix\nK = int(input())\n\nclass Graph(object):\n\n    def __init__(self, K):\n        self.K = K\n        self.weights = {}\n\n    def add_edge(self, node1, node2, weight):\n        if (node1, node2) in self.weights:\n            self.weights[(node1, node2)] = min(self.weights[(node1, node2)], weight)\n        else:\n            self.weights[(node1, node2)] = weight\n\n    def get_csr_matrix(self):\n        n1, n2, w = [], [], []\n        for (node1, node2), weight in self.weights.items():\n            n1.append(node1)\n            n2.append(node2)\n            w.append(weight)\n        return csr_matrix((w, (n1, n2)), shape=(self.K, self.K))\n\ng = Graph(K)\n\nfor i in range(K - 1):\n    g.add_edge(i, i + 1, 1)\n    g.add_edge(i, (i * 10) % K, 10**(-16))\n\ng.add_edge(K - 1, 0, 1)\ng.add_edge(K - 1, ((K - 1) * 10) % K, 10**(-16))\nd = dijkstra(g.get_csr_matrix(), directed=True, indices=1)\nprint(int(d[0]) + 1)", "from heapq import heappush, heappop\n\n\ndef dijkstra(graph: list, n: int, v_s: int, INF: int = float('inf')) -> list:\n    # graph[v_from] = [(cost, v_to), ...]\n    dist = [INF] * n\n\n    dist[v_s] = 0\n    heap = [(0, v_s)]  # heap = [(dist[v], v), ...]\n    while heap:\n        dist2v, v_from = heappop(heap)\n        if dist[v_from] < dist2v:\n            continue\n        for cost, v_to in graph[v_from]:\n            dist_cand = dist2v + cost\n            if dist_cand < dist[v_to]:\n                dist[v_to] = dist_cand\n                heappush(heap, (dist[v_to], v_to))\n    return dist\n\n\nk = int(input())\n\ngraph = [[] for _ in range(k)]\nfor i in range(1, k):\n    graph[i].append((1, (i + 1) % k))\n    graph[i].append((0, 10 * i % k))\n\ndist = dijkstra(graph, k, 1)\nans = dist[0] + 1\nprint(ans)\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nK = int(input())\n\n# \u3042\u308b\u6570\u306b 1 \u3092\u8db3\u3059\u3068\u5404\u6841\u306e\u548c\u306f 1 \u5897\u3048\u308b\n# \u3042\u308b\u6570\u306b 10 \u3092\u639b\u3051\u308b\u3068\u5404\u6841\u306e\u548c\u306f 0 \u5897\u3048\u308b\n# mod K \u306e\u4e16\u754c\u3067\u540c\u3058\u3053\u3068\u3084\u3063\u3066\u3082\u540c\u3058\u306a\u306e\u3067\n# \u3053\u306e\u30b0\u30e9\u30d5\u4e0a\u3067 1 \u304b\u3089 0 \u3078\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u7b54\u3048\u3002\n\ndistances = [INF for _ in range(K)]\n\n# 01BFS\ndistances[1] = 1\nremains = deque()\nremains.append((1, 1))\nwhile True:\n    d, mod_k = remains.popleft()\n    if mod_k == 0:\n        break\n    if d + 1 < distances[(mod_k + 1) % K]:\n        distances[(mod_k + 1) % K] = d + 1\n        remains.append((d + 1, (mod_k + 1) % K))\n    if d < distances[mod_k * 10 % K]:\n        distances[mod_k * 10 % K] = d\n        remains.appendleft((d, mod_k * 10 % K))\nprint((distances[0]))\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nK = int(input())\n\n# \u3042\u308b\u6570\u306b 1 \u3092\u8db3\u3059\u3068\u5404\u6841\u306e\u548c\u306f 1 \u5897\u3048\u308b\n# \u3042\u308b\u6570\u306b 10 \u3092\u639b\u3051\u308b\u3068\u5404\u6841\u306e\u548c\u306f 0 \u5897\u3048\u308b\n# mod K \u306e\u4e16\u754c\u3067\u540c\u3058\u3053\u3068\u3084\u3063\u3066\u3082\u540c\u3058\u306a\u306e\u3067\n# \u3053\u306e\u30b0\u30e9\u30d5\u4e0a\u3067 1 \u304b\u3089 0 \u3078\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u7b54\u3048\u3002\n\ndistances = [INF for _ in range(K)]\n\n# 01BFS\nremains = deque()\nremains.append((1, 1))\nwhile distances[0] == INF:\n    d, mod_k = remains.popleft()\n    distances[mod_k] = d\n    if distances[(mod_k + 1) % K] == INF:\n        remains.append((d + 1, (mod_k + 1) % K))\n    if distances[mod_k * 10 % K] == INF:\n        remains.appendleft((d, mod_k * 10 % K))\nprint((distances[0]))\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\n\nclass Graph(object):\n    \"\"\"\n    \u96a3\u63a5\u30ea\u30b9\u30c8\u306b\u3088\u308b\u6709\u5411\u30b0\u30e9\u30d5\n    \"\"\"\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return list(self.graph.keys())\n\n\nclass Dijkstra(object):\n    \"\"\"\n    \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\uff08\u4e8c\u5206\u30d2\u30fc\u30d7\uff09\u306b\u3088\u308b\u6700\u77ed\u7d4c\u8def\u63a2\u7d22\n    \u8a08\u7b97\u91cf: O((E+V)logV)\n    \"\"\"\n\n    def __init__(self, graph, start):\n        self.g = graph.graph\n\n        # start\u30ce\u30fc\u30c9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n        # start\u30ce\u30fc\u30c9\u306f0, \u305d\u308c\u4ee5\u5916\u306f\u7121\u9650\u5927\u3067\u521d\u671f\u5316\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n\n        # \u6700\u77ed\u7d4c\u8def\u3067\u306e1\u3064\u524d\u306e\u30ce\u30fc\u30c9\n        self.prev = defaultdict(lambda: None)\n\n        # start\u30ce\u30fc\u30c9\u3092\u30ad\u30e5\u30fc\u306b\u5165\u308c\u308b\n        self.Q = []\n        heappush(self.Q, (self.dist[start], start))\n\n        while self.Q:\n            # \u512a\u5148\u5ea6\uff08\u8ddd\u96e2\uff09\u304c\u6700\u5c0f\u3067\u3042\u308b\u30ad\u30e5\u30fc\u3092\u53d6\u308a\u51fa\u3059\n            dist_u, u = heappop(self.Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in self.g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(self.Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n        \"\"\"\n        return self.dist[goal]\n\n    def shortest_path(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\n        \"\"\"\n        path = []\n        node = goal\n        while node is not None:\n            path.append(node)\n            node = self.prev[node]\n        return path[::-1]\n\n\ng = Graph()\nN = int(input())\nfor i in range(N):\n    g.add_edge(i, (i+1)%N, 1)\n    g.add_edge(i, (10 * i) % N, 0)\n\nd = Dijkstra(g, 1)\nprint((d.dist[0]+1))\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**7)\nk=int(input())\ng=[[] for i in range(k)]\nfor i in range(k):\n  g[i].append(((i+1)%k,1))\n  if i:\n    g[i].append((10*i%k,0))\ndq=deque([1])\nres=[float('inf')]*k\nres[1]=1\nwhile dq:\n  v=dq.popleft()\n  if v==0:\n    break\n  for t,cost in g[v]:\n    if res[t]<=res[v]+cost:\n      continue\n    res[t]=res[v]+cost\n    if cost:\n      dq.append(t)\n    else:\n      dq.appendleft(t)\nprint(res[0])", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**5) \n \ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import deque\n\nk = ni()\nque = deque([(1,1)])\n\nkmod = [0]*k\n\nwhile kmod[0] == 0:\n    cost, idx = que.popleft()\n    if kmod[idx] == 0:\n        kmod[idx] = cost\n        que.appendleft((cost, (10*idx%k)))\n        que.append((cost+1, (idx+1)%k))            \n        \nprint(kmod[0])", "import sys\nfrom collections import deque\nreadline=sys.stdin.readline\n\ndef main():\n    k=int(readline())\n    v=list(range(k))\n    inf=float('inf')\n    dist=[inf]*k\n    visited=[0]*k\n    stack=deque([1])\n    dist[1]=0\n    while stack:\n        v=stack.pop()\n        if not visited[v]:\n            nv0=10*v%k\n            nv1=(v+1)%k\n            if dist[nv0]>dist[v]:\n                dist[nv0]=dist[v]\n                stack.append(nv0)\n            if dist[nv1]>dist[v]+1:\n                dist[nv1]=dist[v]+1\n                stack.appendleft(nv1)\n            visited[v]=1\n    print((dist[0]+1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef solve(K):\n    checked = [99999999999] * (K + 1)\n    queue = deque()\n    queue.append((1, 1))\n    checked[1] = 1\n    while queue:\n        x, n = queue.popleft()\n        if x == 0:\n            return n\n        _ = (x * 10) % K \n        if n < checked[_]:\n            queue.appendleft((_, n))\n            checked[_] = n\n        _ = (x + 1) % K \n        if n + 1 < checked[_]:\n            queue.append((_, n + 1))\n            checked[_] = n + 1\n    return None\n\nK = int(input())\nprint((solve(K)))\n\n", "def bfs_01(v,mod):\n    q = deque(); q.append(v)\n    visited = [False] * mod\n    cur = 0\n    while cur == 0:\n        s, x = q.popleft()\n        if visited[x]:\n            continue\n        visited[x] = True\n        if x == 0:\n            cur = s\n            return cur\n        q.appendleft((s, (10 * x) % mod))\n        q.append((s + 1, (x + 1) % mod))\ndef examD():\n    K = I()\n    ans = bfs_01((1,1),K)\n    print(ans)\n\nimport sys,copy,bisect,itertools\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\nmod = 10**9 + 7\ninf = float('inf')\n\nexamD()\n", "from collections import deque\n\ndef BFS01(d,K):\n    d[1] = 1\n    q = deque([1])\n    while q:\n        n = q.popleft()\n        l, r = map(lambda x: (x) % K, [n * 10, n + 1])\n        if d[l] > d[n]:\n            d[l] = d[n]\n            q.appendleft(l)\n\n        if d[r] > d[n] + 1:\n            d[r] = d[n] + 1\n            q.append(r)\n    return d[0]\n\nK = int(input())\nd = [float('inf')] * K\n\nprint(BFS01(d,K))", "# solution\n\nimport io\nimport math\nimport scipy.sparse\nimport numpy\nfrom collections import deque\n\nq = deque();K=int(input());q+=[(1,1)];m={}\n\nwhile len(q):\n\tn,s=q.pop()\n\tif not n in m:m[n]=s;q+=[(n*10%K,s)];q.appendleft(((n+1)%K,s+1))\n\nprint(m[0])", "from collections import deque\nq=deque();K=int(input());a=q.append;a((1,1));m={}\nwhile len(q):\n n,s=q.popleft()\n if not n in m:m[n]=s;q.appendleft((n*10%K,s));a(((n+1)%K,s+1))\nprint(m[0])", "import queue\n\n\ndef bfs01(s: int, t: int, V: int, graph: list)->int:\n    INF = float('inf')\n\n    q = queue.deque([])\n    qc = 0\n    l = [INF] * V\n\n    q.append(s)\n    qc += 1\n    l[s] = 0\n\n    while qc > 0:\n        u = q.popleft()\n        qc -= 1\n        for v, c in graph[u]:\n            if l[u] + c < l[v]:\n                l[v] = l[u] + c\n                qc += 1\n                if c == 0:\n                    q.appendleft(v)\n                else:\n                    q.append(v)\n\n    return l[t]\n\n\ndef small_multiple(K: int)->int:\n    graph = []\n    for k in range(K):\n        graph.append([])\n        v1 = k+1 if k+1 < K else 0\n        v10 = (k*10) % K\n\n        graph[k].append((v1, 1))\n        if v10 != k:\n            graph[k].append((v10, 0))\n\n    return bfs01(1, 0, K, graph) + 1\n\n\ndef __starting_point():\n    K = int(input())\n    ans = small_multiple(K)\n    print(ans)\n\n__starting_point()", "from collections import deque\n\nK = int(input())\n\nvisited = [False] * K\nQ = deque([(1, 1)])\n\nwhile True:\n    s, v = Q.popleft()\n    if v == 0:\n        print(s)\n        return\n\n    if visited[v]:\n        continue\n    visited[v] = True\n\n    Q.appendleft((s, (10 * v) % K))\n    Q.append((s + 1, (v + 1) % K))", "from collections import defaultdict\nfrom heapq import heappop, heappush\nk = int(input())\n\ndist = []\nfor i in range(k):\n    if i != k - 1:\n        dist.append([i, i + 1, 1])\n    else:\n        dist.append([i, 0, 1])\n\nfor i in range(k):\n    dist.append([i, (10 * i) % k, 0])\n\nclass Graph(object):\n    \"\"\"\n    \u96a3\u63a5\u30ea\u30b9\u30c8\u306b\u3088\u308b\u6709\u5411\u30b0\u30e9\u30d5\n    \"\"\"\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return self.graph.keys()\n\n\nclass Dijkstra(object):\n    \"\"\"\n    \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\uff08\u4e8c\u5206\u30d2\u30fc\u30d7\uff09\u306b\u3088\u308b\u6700\u77ed\u7d4c\u8def\u63a2\u7d22\n    \u8a08\u7b97\u91cf: O((E+V)logV)\n    \"\"\"\n\n    def __init__(self, graph, start):\n        self.g = graph.graph\n\n        # start\u30ce\u30fc\u30c9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n        # start\u30ce\u30fc\u30c9\u306f0, \u305d\u308c\u4ee5\u5916\u306f\u7121\u9650\u5927\u3067\u521d\u671f\u5316\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n\n        # \u6700\u77ed\u7d4c\u8def\u3067\u306e1\u3064\u524d\u306e\u30ce\u30fc\u30c9\n        self.prev = defaultdict(lambda: None)\n\n        # start\u30ce\u30fc\u30c9\u3092\u30ad\u30e5\u30fc\u306b\u5165\u308c\u308b\n        self.Q = []\n        heappush(self.Q, (self.dist[start], start))\n\n        while self.Q:\n            # \u512a\u5148\u5ea6\uff08\u8ddd\u96e2\uff09\u304c\u6700\u5c0f\u3067\u3042\u308b\u30ad\u30e5\u30fc\u3092\u53d6\u308a\u51fa\u3059\n            dist_u, u = heappop(self.Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in self.g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(self.Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n        \"\"\"\n        return self.dist[goal]\n\n    def shortest_path(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\n        \"\"\"\n        path = []\n        node = goal\n        while node is not None:\n            path.append(node)\n            node = self.prev[node]\n        return path[::-1]\n# (src, dst, weight)\ninputs = dist\n\ng = Graph()\nfor src, dst, weight in inputs:\n    g.add_edge(src, dst, weight)\n    #g.add_edge(dst, src, weight)\nspdi = {}\n\nd = Dijkstra(g, 1)\nsp = format(d.shortest_distance(0))\nprint(int(sp) + 1)", "#!/usr/bin/env python3\nfrom collections import deque\nimport sys\ntry:\n    from typing import Deque, List\nexcept ImportError:\n    pass\n\n\ndef solve(K: int):\n    pars = list(range(K))\n\n    def union(a: int, b: int):\n        pars[a] = b\n\n    def getpar(a: int):\n        if pars[a] == a:\n            return a\n        pars[a] = getpar(pars[a])\n        return pars[a]\n\n    for i in range(K):\n        union(getpar(i), getpar(i * 10 % K))\n\n    gs = [getpar(i) for i in range(K)]\n    if gs[0] == gs[1]:\n        print((1))\n        return\n    G = [[] for i in range(K)]  # type: List[List[int]]\n    for i in range(K):\n        G[gs[i]].append(gs[(i + 1) % K])\n    d = {gs[1]: 1}\n    q = deque()  # type: Deque[int]\n    q.append(gs[1])\n    while q:\n        s = q.popleft()\n        for t in G[s]:\n            if t in d:\n                continue\n            d[t] = d[s] + 1\n            if t == gs[0]:\n                print((d[t]))\n                return\n            q.append(t)\n    assert False\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    K = int(next(tokens))  # type: int\n    solve(K)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nK=int(input())\ndist=[10**15 for i in range(K)]\ndist[1]=1\nq=[]\nheapq.heappush(q,(0,1))\nwhile (len(q)!=0):\n    prc,src=heapq.heappop(q)\n    if dist[src]<prc:\n        continue\n    if dist[(src+1)%K]>dist[src]+1:\n        dist[(src+1)%K]=dist[src]+1\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n    if dist[(10*src)%K]>dist[src]:\n        dist[(10*src)%K]=dist[src]\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\nprint((dist[0]))\n", "from collections import deque\nq = deque()\nK = int(input())\nq.append((1, 1))\nm = {}\nwhile len(q):\n n, s = q.popleft()\n if n in m:continue\n m[n] = s\n q.appendleft((n * 10 % K, s))\n q.append(((n + 1) % K, s + 1))\nprint(m[0])", "K=int(input())\na=K\nwhile a%2==0:\n    a//=2\nwhile a%5==0:\n    a//=5\nif a==1:\n    print(1)\nelse:\n    mod=set([])\n    a=1\n    while a not in mod:\n        mod.add(a)\n        a*=10\n        a%=K\n\n    mod=list(mod)\n    n=len(mod)\n    wei=pow(2,K)-1\n    check=1\n    ans=0\n    for j in range(0,n):\n        ans=ans|(check<<mod[j])\n    check=ans\n    for i in range(1,46):\n        if check>>0 &1==1:\n            print(i)\n            return\n        ans=check\n        for j in range(0,n):\n            ans=ans|(check<<mod[j])\n        ans1=ans&wei\n        ans2=ans>>K\n        check=ans1|ans2", "from collections import deque\nq=deque();K=int(input());q+=[(1,1)];m={}\nwhile len(q):\n n,s=q.pop()\n if not n in m:m[n]=s;q+=[(n*10%K,s)];q.appendleft(((n+1)%K,s+1))\nprint(m[0])", "K=int(input())\n\nD=[K*10]*K\nD[1]=1\n\nimport heapq\n\nQ=[(1,1)]\n\nwhile Q:\n    c,x=heapq.heappop(Q)\n\n    if D[x*10%K]>c:\n        D[x*10%K]=c\n        heapq.heappush(Q,(c,x*10%K))\n\n    if D[(x+1)%K]>c+1:\n        D[(x+1)%K]=c+1\n        heapq.heappush(Q,(c+1,(x+1)%K))\n\nprint(D[0])", "import heapq\ndef main():\n    k= int(input())\n    brdict = {}\n    for i in range(1,k):\n        if i==k-1:\n            if (10*(k-1))%k==0:\n                brdict[i]= [(0,0)]\n            else:\n                brdict[i] = [(0,1)]\n        else:\n            if i!=(i*10)%k:\n                brdict[i] = [((i*10)%k,0)]\n            if (i*10)%k!=i+1:\n                brdict[i] = brdict.get(i,[])+[(i+1,1)]\n    start=1\n    cost=[i for i in range(k)]\n    cost[0]=k\n    fixed=[False]*k\n    fixed[start]=True\n    akouho = [(1,start)]\n    heapq.heapify(akouho)\n    while not all(fixed):\n        (fcost,fnode) = heapq.heappop(akouho)\n        if fnode==0:break\n        fixed[fnode]=True\n        for br in brdict[fnode]:\n            if not fixed[br[0]]:\n                if cost[br[0]] > fcost + br[1]:\n                    cost[br[0]] = fcost + br[1]\n                    heapq.heappush(akouho,(cost[br[0]],br[0]))\n        if akouho==[]:break\n    print(cost[0])\ndef __starting_point():\n    main()\n__starting_point()", "import collections\nimport sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nK = int(input())\n\n\ndef ans():\n    visited = [False] * K\n\n    s = (1, 1)\n\n    q = collections.deque()\n    q.append(s)\n\n    while True:\n        c = q.popleft()\n        visited[c[0]] = True\n\n        if c[0] == 0:\n            return c[1]\n\n        if not visited[(c[0] * 10) % K] and not visited[(c[0] * 10) % K]:\n            q.appendleft(((c[0] * 10) % K, c[1]))\n\n        if not visited[(c[0] + 1) % K] and not visited[(c[0] + 1) % K]:\n            q.append(((c[0] + 1) % K, c[1] + 1))\n\n\nprint((ans()))\n\n", "from collections import deque\nK =int(input())\n\nINF = 10**9+7\nA = [INF] * (K)\n\nq = deque()\nq.append(1)\nA[1] = 1\nwhile q:\n    x = q.popleft()\n    if A[(x*10)%K] > A[x]:\n        A[(x*10)%K] = A[x]\n        q.appendleft((x*10)%K)\n    if A[(x+1)%K] > A[x]+1:\n        A[(x+1)%K] = A[x]+1\n        q.append((x+1)%K)\n\nprint(A[0])", "from collections import deque\nk = int(input())\nx = [50 for i in range(k)]\nx[1],q = 0,deque()\nq.append(1)\nwhile q:\n\tn = q.pop()\n\tm = n\t\n\twhile 1:\n\t\tm2 = (m*10)%k\n\t\tif x[m2]>x[m]:\n\t\t\tx[m2],m = x[m],m2\n\t\t\tq.append(m)\n\t\telse: break\n\tif x[(n+1)%k]==50:\n\t\tx[(n+1)%k] = x[n]+1\n\t\tq.appendleft((n+1)%k)\nprint(x[0]+1)", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nK = int(input())\n\n\nclass Graph(object):\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return self.graph.keys()\n\n\nclass Dijkstra(object):\n    def __init__(self, graph, start):\n        g = graph.graph\n\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n        self.prev = defaultdict(lambda: None)\n\n        Q = []\n        heappush(Q, (self.dist[start], start))\n\n        while Q:\n            dist_u, u = heappop(Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        return self.dist[goal]\n\n    def shortest_path(self, goal):\n        path = []\n        node = goal\n        while node is not None:\n            path.append(node)\n            node = self.prev[node]\n        return path[::-1]\n\n\ng = Graph()\nfor i in range(K - 1):\n    g.add_edge(i, i + 1, 1)\n    g.add_edge(i, (i * 10) % K, 0)\ng.add_edge(K - 1, 0, 1)\ng.add_edge(K - 1, ((K - 1) * 10) % K, 0)\n\nd = Dijkstra(g, 1)\nprint(d.shortest_distance(0) + 1)", "from collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt\nfrom collections import deque\nfrom heapq import heappop, heappush\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(10000)\nINF = float(\"inf\")\nYES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"\ndy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]\n\n\ndef inside(y, x, H, W):\n    return 0 <= y < H and 0 <= x < W\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\ndef main():\n    K = int(input())\n    dp = [INF] * K\n    dp[1] = 1\n\n    heap = []\n    heappush(heap, (1, 1))\n\n    while len(heap) != 0:\n        k, p = heappop(heap)\n        if dp[(p + 1) % K] > dp[p] + 1:\n            dp[(p + 1) % K] = dp[p] + 1\n            heappush(heap, (dp[p] + 1, (p + 1) % K))\n        if dp[(p * 10) % K] > dp[p]:\n            dp[(p * 10) % K] = dp[p]\n            heappush(heap, (dp[p], (p * 10) % K))\n\n        if dp[0] != INF:\n            break\n\n    print((dp[0]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\nk=int(input())\nv=list(range(k))\nstack=deque([1])\ninf=float('inf')\nvisited=[0]*k\ndist=[inf]*k\ndist[1]=0\nwhile stack:\n  v=stack.pop()\n  if not visited[v]:\n    nv0=10*v%k\n    nv1=(v+1)%k\n    if dist[nv0]>dist[v]:\n      dist[nv0]=dist[v]\n      stack.append(nv0)\n    if dist[nv1]>1+dist[v]:\n      stack.appendleft(nv1)\n      dist[nv1]=dist[v]+1\n    visited[v]=1\nprint(dist[0]+1)", "from heapq import heappop,heappush\ndef dijkstra(s,n,edge):\n  inf=10**20\n  ans=[inf]*n\n  ans[s]=0\n  h=[[0,s]]\n  while h:\n    c,v=heappop(h)\n    if ans[v]<c:continue\n    for u,t in edge[v]:\n      if c+t<ans[u]:\n        ans[u]=c+t\n        heappush(h,[c+t,u])\n  return ans\nk=int(input())\nedge=[[]for _ in range(k)]\nfor i in range(1,k):\n    edge[i].append(((i*10)%k,0))\n    edge[i].append(((i+1)%k,1))\nans=dijkstra(1,k,edge)\nprint((ans[0]+1))\n", "K = int(input())\n\nimport heapq\ndef dijkstra(adj, n, start):\n    dj = [10**6] * (n + 1)\n    dj[start] = 0\n    q = []\n    heapq.heappush(q, (0, start))\n    while q:\n        fc, fn = heapq.heappop(q)\n        if dj[fn] < fc: continue\n        for tn, lc in adj[fn]:\n            if dj[tn] > dj[fn] + lc:\n                dj[tn] = dj[fn] + lc\n                heapq.heappush(q, (dj[tn], tn))\n    return dj\n\nadj = {}\nfor i in range(K):\n    t = adj.setdefault(i, [])\n    t.append(((i + 1) % K, 1))\n    t.append(((i * 10) % K, 0))\n\ncosts = dijkstra(adj, K - 1, 1)\nprint(costs[0] + 1)", "from collections import deque\n\nK = int(input())\n\nwhile (K % 2 == 0):\n    K = K // 2\nwhile (K % 5 == 0):\n    K = K // 5\n\nif(K == 1):print(\"1\")\nelse : \n    visited = [-1 for i in range(K)]\n    queue = deque([])\n    st = 1\n\n    while True:\n        visited[st] = 1\n        queue.append(st)\n        st = (10*st) % K\n        if (st == 1) : break\n\n    while queue:\n        a = queue.popleft()\n        if (visited[0] != -1) :break\n        if (visited[(a+1) % K] == -1):\n            st = (a+1) % K\n            while True:\n                visited[st] = visited[a] + 1\n                queue.append(st)\n                st = (10*st) % K\n                if (st == ((a+1) % K)) : break\n            if (visited[0] != -1) :break\n\n\n    print(visited[0])", "from heapq import heappush, heappop\ndef dijkstra(graph:list, node:int, start:int) -> list:\n    # graph[node] = [(cost, to)]\n    inf = float('inf')\n    dist = [inf]*node\n\n    dist[start] = 0\n    heap = [(0,start)]\n    while heap:\n        cost,thisNode = heappop(heap)\n        for NextCost,NextNode in graph[thisNode]:\n            dist_cand = dist[thisNode]+NextCost\n            if dist_cand < dist[NextNode]:\n                dist[NextNode] = dist_cand\n                heappush(heap,(dist[NextNode],NextNode))\n    return dist\nK = int(input())\ng = [[] for _ in range(K)]\nfor n in range(1,K+1):\n    g[n%K] += [(1,(n+1)%K),(0,10*n%K)]\n\nprint(dijkstra(g,K,1)[0]+1)", "from collections import deque\n\nK = int(input())\n\nG = [((10*i % K, 0), ((i+1) % K, 1)) for i in range(K)]\ns = 1\n\ndist = [10**9] * K\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d+c < dist[w]:\n                dist[w] = d+c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0]+1)", "from collections import deque\n\nK = int(input())\n\nG = [((10*i % K, 0), ((i+1) % K, 1)) for i in range(K)]\ns = 1\n\ndist = [10**9] * K\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d+c < dist[w]:\n                dist[w] = d+c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0]+1)", "from collections import deque\nK=int(input())\nreached=[0 for i in range(K)]\nreached[1]=1\ndist=[0 for i in range(K)]\nq=deque([])\nq.append(1)\nwhile(len(q)>0):\n    r=q.popleft()\n    v=(r+1)%K\n    reached[r]=1\n    if (reached[v]==0):\n        q.append(v)\n        dist[v]=dist[r]+1\n    v=(r*10)%K\n    if (reached[v]==0):\n        q.appendleft(v)\n        dist[v]=dist[r]\n    if (reached[0]==1):\n        break\nprint((dist[0]+1))\n", "from collections import deque\n\nk = int(input())\nq = deque()\nq.append(1)\nd = [float(\"inf\")] * k\nd[1] = 1\nwhile q:\n    n = q.popleft()\n    l, r = (n * 10) % k, (n + 1) % k\n    if d[l] > d[n]:\n        d[l] = d[n]\n        q.appendleft(l)\n    if d[r] > d[n] + 1:\n        d[r] = d[n] + 1\n        q.append(r)\nprint((d[0]))\n", "from collections import deque\nK=int(input())\n\nd=[1000000 for x in range(K+1)]\nd[1]=0\n\ndef bfs(K):\n  q=deque()\n  q.append(1)\n  while q:\n    nx=q.popleft()\n    if d[(nx*10)%K]>d[nx]:\n      d[(nx*10)%K]=d[nx]\n      q.appendleft((nx*10)%K)\n    if d[(nx+1)%K]>d[nx]+1:\n      d[(nx+1)%K]=d[nx]+1\n      q.append((nx+1)%K)\n  return d[0]+1\n\nprint(bfs(K))", "from collections import deque\n\nK = int(input())\n\ndeq = deque([(1, 1)])\nhistory = set()\n\nwhile True:\n\tto = deq.popleft()\n\tif to[0] == 0:\n\t\tprint(to[1])\n\t\tbreak\n\telif to[0] not in history:\n\t\thistory.add(to[0])\n\t\tdeq.appendleft((to[0] * 10 % K, to[1]))\n\t\tdeq.append((to[0] + 1, to[1] + 1))", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\n\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\n\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef SMI(): return input().split()\ndef SLI(): return list(input())\n\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n\n# from math import ceil, floor, log2\nfrom collections import deque\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef solve():\n    K = II()\n\n    q = deque([(1, 1)])\n    used = [0 for _ in range(K)]\n    while len(q) > 0:\n        # print(q)\n        v, cost = q.popleft()\n        if v == 0:\n            print(cost)\n            return\n\n        if used[v]:\n            continue\n        used[v] = 1\n\n        q.appendleft(((v*10) % K, cost))\n        q.append(((v+1) % K, cost+1))\n\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nK = int(input())\n\nD = [-1]*K\n\nq = deque()\nq.append(1)\nD[1] = 1\nwhile q:\n    p = q.pop()\n    n1 = (p*10)%K\n    if D[n1] == -1 or D[n1] > D[p]:\n        D[n1] = D[p]\n        q.append(n1)\n    n2 = (p+1)%K\n    if D[n2] == -1:\n        D[n2] = D[p] + 1\n        q.appendleft(n2)\nprint(D[0])", "from collections import*\nq=deque([(1,1)])\nk=int(input())\nm={}\nwhile q:\n n,s=q.pop()\n if(n in m)-1:m[n]=s;q+=(n*10%k,s),;q.appendleft((-~n%k,s+1))\nprint(m[0])", "from collections import deque\nK = int(input())\nG = [[] for i in range(K)]\nfor i in range(K):\n    G[i].append(((10 * i) % K, 0))\n    G[i].append(((i + 1) % K, 1))\n\ndist = [float('inf')] * K\ndist[1] = 1\nque = deque()\nque.append(1)\n\nwhile que:\n    n = que.pop()\n    for v, c in G[n]:\n        if dist[v] > dist[n] + c:\n            dist[v] = dist[n] + c\n            if c == 0:\n                que.append(v)\n            else:\n                que.appendleft(v)\n\nprint((dist[0]))\n", "from collections import deque\n \n# 1\u304b\u3089\u521d\u3081\u3066\u3001x\u304c\u3042\u308b\u3068\u304d10x\u3001x+1\u306e\u3044\u305a\u308c\u304b\u304c\u884c\u3048\u308b\u3068\u3057\u3066queue\n \nK = int(input())\nq = deque()\nq.append((1,1)) # \u5404\u6841\u306e\u548c\u3001modulo K\nvisited = [False]*K\n \nans = 0\n \nwhile ans == 0:\n  s,x = q.popleft()\n  if visited[x]:\n    continue\n  visited[x] = True\n  if x == 0:\n    ans = s\n    break\n  q.appendleft((s,(10*x)%K))\n  q.append((s+1,(x+1)%K))\n\nprint(ans)\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef dijkstra(N: int, nodes: list, src: int) -> list:\n    \"\"\" \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u9ad8\u901f\u5316\u7248(\u9802\u70b9\u6570, \u96a3\u63a5\u30ea\u30b9\u30c8(0-indexed), \u59cb\u70b9) \"\"\"\n    from heapq import heappush, heappop\n\n    res = [INF] * N\n    # \u30b9\u30bf\u30fc\u30c8\u4f4d\u7f6e(\u4eca\u56de\u306f\u958b\u59cb\u30b3\u30b9\u30c8\u304c0\u3058\u3083\u306a\u3044\u306e\u30671*N\u3092\u542b\u3081\u308b)\n    que = [1*N+src]\n    # \u4eca\u56de\u306e\u958b\u59cb\u4f4d\u7f6e1\u306e\u30b3\u30b9\u30c8\u306f1\n    res[src] = 1*N\n\n    while len(que) != 0:\n        cur = heappop(que)\n        dist = cur // N\n        cur %= N\n        for nxt, cost in nodes[cur]:\n            if dist + cost < res[nxt]:\n                res[nxt] = dist + cost\n                heappush(que, (dist+cost)*N+nxt)\n    return res\n\nK = INT()\n\nnodes = [[] for i in range(K)]\nfor i in range(K):\n    nodes[i].append(((i+1)%K, 1))\n    nodes[i].append(((i*10)%K, 0))\n\nres = dijkstra(K, nodes, 1)\nprint((res[0]))\n", "import heapq\nK=int(input())\nG=[[((i+1)%K,1)] for i in range(K)]\nfor i in range(K):\n    a=(i*10)%K\n    G[i].append((a,0))\ndef dijkstra(G,s):#G\u306fi->j\u306e\u8fba\u3092G[i]=[(j,cost),...]\u3067\u4fdd\u5b58\n  INF=10**19\n  n=len(G)\n  d=[INF]*n#n=node\u6570\n  d[s]=0\n  visited={s}\n  que=[(0,s)]\n  while(que):\n    p=heapq.heappop(que)\n    v=p[1]\n    visited.add(v)\n    for node,cost in G[v]:\n      if (node not in visited) and d[node]>d[v]+cost:\n        d[node]=d[v]+cost\n        heapq.heappush(que,(d[node],node))\n  return d\n\nd=dijkstra(G,1)\nprint((d[0]+1))\n", "from collections import deque\nK = int( input())\nV = [0]*K\nd = deque([(1,1)])\nwhile 1:\n    w, v = d.popleft()\n    if v == 0:\n        ans = w\n        break\n    if V[v] == 1:\n        continue\n    V[v] = 1\n    if V[ (v+1)%K] == 0:\n        # if (v+1)%K == 0:\n        #     ans = w+1\n        #     break\n        d.append((w+1 ,(v+1)%K))\n    if V[ (v*10)%K] == 0:\n        d.appendleft((w, (v*10)%K))\n        # if (v*10)%K == 0:\n        #     ans = w\n        #     break\nprint(ans)", "from collections import deque\n\n\nK = int(input())\npath = [K] * K\n\nq = deque()\npath[1] = 0\nq.append(1)\nwhile q:\n    p = q.popleft()\n    p1 = (p + 1) % K\n    if path[p1] > path[p] + 1:\n        path[p1] = path[p] + 1\n        q.append(p1)\n    \n    p10 = (p * 10) % K\n    if path[p10] > path[p]:\n        path[p10] = path[p]\n        q.appendleft(p10)\n\nprint((path[0] + 1))\n", "from collections import deque\n\nque = deque()\n\nK = int(input())\n\nque.append((1, 1))\nvisited = {}\n\nwhile len(que) != 0:\n    num, step = que.popleft()\n    if num in visited:\n        continue\n    visited[num] = step\n    que.appendleft((num * 10 % K, step))\n    que.append(((num + 1) % K, step + 1))\n\nprint(visited[0])", "from collections import deque\n \n# 1\u304b\u3089\u521d\u3081\u3066\u3001x\u304c\u3042\u308b\u3068\u304d10x\u3001x+1\u306e\u3044\u305a\u308c\u304b\u304c\u884c\u3048\u308b\u3068\u3057\u3066queue\n \nK = int(input())\nq = deque()\nq.append((1,1)) # \u5404\u6841\u306e\u548c\u3001modulo K\nvisited = [False]*K\n \nans = 0\n \nwhile ans == 0:\n  s,x = q.popleft()\n  if visited[x]:\n    continue\n  visited[x] = True\n  if x == 0:\n    ans = s\n    break\n  q.appendleft((s,(10*x)%K))\n  q.append((s+1,(x+1)%K))\n\nprint(ans)\n", "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    q = deque([[1, 1]])\n    d = {1: 1}\n    while q:\n        n, c = q.popleft()\n        a = (n * 10) % N\n        if a not in d or d[a] > c:\n            d[a] = c\n            q.appendleft([a, c])\n\n        b = (n + 1) % N\n        if b not in d or d[b] > c+1:\n            d[b] = c + 1\n            q.append([b, c+1])\n\n    print((d[0]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\nk = int(input())\n\nvisited = [False]*(k+1)\ndist = [0]*(k+1)\ndist[1] = 1\nque = deque([(1, 1)])\n\nwhile len(que) > 0:\n    cost, node = que.popleft()\n    if visited[node]:\n        continue\n    \n    visited[node] = True\n    dist[node] = cost\n\n    if not visited[10*node%k]:\n        que.appendleft((cost, 10*node%k))\n    if not visited[(node+1)%k]:\n        que.append((cost+1, (node+1)%k))\n\nprint((dist[0]))\n", "k = int(input())\nfrom collections import deque\nd = deque( )\nd.append((1,1))\ndiscovered = set()\nwhile True:\n  node, cost = d.popleft()\n  discovered |= {node}\n  if node == 0: \n  \tprint(cost)\n  \treturn\n  if (node*10)%k not in discovered:\n    d.appendleft( ((node*10)%k  ,cost))\n  if (node+1)%k not in discovered:\n    d.append((node+1,cost+1))", "import collections\n\nK = int(input())\n\nq = collections.deque([(1, 0)])\nv = {1}\n\nwhile len(q) > 0:\n    c, p = q.popleft()\n    v.add(c)\n    if c == 0:\n        break\n\n    n1, n10 = (c + 1) % K, (c * 10) % K\n    if not n1 in v:\n        q.append((n1, p + 1))\n    if not n10 in v:\n        q.appendleft((n10, p))\n\nprint((p + 1))\n", "#!/usr/bin/env python3\nfrom collections import deque\n\nINF = 10**9\nk = int(input())\n\n# (\u8fba\u306e\u4f38\u3073\u308b\u5148, \u30b3\u30b9\u30c8)\nG = [((10 * i % k, 0), ((i + 1) % k, 1)) for i in range(k)]\ns = 1\n\n# 01 - BFS\ndist = [INF] * k\nS = deque([s])\nT = deque()\ndist[s] = 0\n\nd = 0\nwhile S:\n    while S:\n        v = S.popleft()\n        for w, c in G[v]:\n            if d + c < dist[w]:\n                dist[w] = d + c\n                if c:\n                    T.append(w)\n                else:\n                    S.append(w)\n    S, T = T, S\n    d += 1\n\nprint(dist[0] + 1)", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul\n\nsys.setrecursionlimit(10000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(K):\n\n    g = defaultdict(dict)\n    for i in range(1, K+1):\n        g[i % K][(i+1) % K] = 1\n        g[i % K][(i*10) % K] = 0\n\n    q = deque()\n    q.append((1, 0))\n\n    vis = {}\n    while q:\n        u, cc = q.popleft()\n        if u == 0:\n            return cc + 1\n        vis[u] = True\n        for v, c in g[u].items():\n            if v in vis:\n                continue\n            if c == 0:\n                q.appendleft((v, cc))\n            else:\n                q.append((v, cc+c))\n\n\ndef main():\n    K = read_int()\n    print(slv(K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nK = int(input())\n\n\nG = [[] for i in range(K)]\nfor i in range(K):\n    G[i].append(((i + 1) % K, 1))\n    G[i].append(((10 * i) % K, 0))\n\n\ndist = [float('inf')] * K\ndist[1] = 1\nque = deque()\nque.append(1)\n\nwhile que:\n    n = que.pop()\n    for v, c in G[n]:\n        if dist[v] > dist[n] + c:\n            dist[v] = dist[n] + c\n            if c == 0:\n                que.append(v)\n            else:\n                que.appendleft(v)\n\nprint((dist[0]))\n"]
["class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         result = []\n         if not matrix:\n             return result\n         top = left = 0\n         bottom, right = len(matrix) - 1, len(matrix[0]) - 1\n         while top < bottom and left < right:\n             for i in range(left, right):\n                 result.append(matrix[top][i])\n             for i in range(top, bottom):\n                 result.append(matrix[i][right])\n             for i in range(right, left, -1):\n                 result.append(matrix[bottom][i])\n             for i in range(bottom, top, -1):\n                 result.append(matrix[i][left])\n             left += 1\n             right -= 1\n             top += 1\n             bottom -= 1\n         if left == right and top == bottom:\n             result.append(matrix[left][top])\n         if left == right and top != bottom:\n             for i in range(top, bottom+1):\n                 result.append(matrix[i][left])\n         if left != right and top == bottom:\n             for i in range(left, right+1):\n                 result.append(matrix[top][i])\n         return result", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if not matrix:\n             return []\n         def layer(width, height, top, left):\n             if not (width > 0 and height > 0):\n                 return\n             for i in range(left, left+width):\n                 yield matrix[top][i]\n             if height != 1:\n                 for i in range(top+1, top+height):\n                     yield matrix[i][left+width-1]\n                 for i in range(left+width-2, left-1, -1):\n                     yield matrix[top+height-1][i]\n                 if width != 1:\n                     for i in range(top+height-2, top, -1):\n                         yield matrix[i][left]\n             yield from layer(width-2,height-2, top+1, left+1)\n         return list(layer(len(matrix[0]), len(matrix), 0, 0))", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         m = matrix\n         ml = len(m)\n         if ml == 0:\n             return []\n         nl = len(m[0])\n         ms, me, ns, ne = 0, ml - 1, 0, nl - 1 \n         ans = []\n         while ns <= ne or ms <= me: \n             #print(ms,me,ns,ne)\n             if ms <= me: \n                 for j in range(ns, ne + 1): \n                     ans.append(m[ms][j])\n                 ms += 1\n             #print(ms,me,ns,ne)\n             if ne >= ns: \n                 for j in range(ms, me + 1): \n                     ans.append(m[j][ne])\n                 ne -= 1\n             #print(ms,me,ns,ne)\n             if me >= ms: \n                 for j in range(ne, ns - 1, -1):\n                     ans.append(m[me][j])\n                 me -= 1\n             #print(ms,me,ns,ne)\n             if ns <= ne: \n                 for j in range(me, ms - 1, -1):\n                     ans.append(m[j][ns])\n                 ns += 1\n             #print(ms,me,ns,ne)\n         return ans ", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if not matrix:\n             return matrix\n         res = []\n         row = len(matrix)\n         col = len(matrix[0])\n         left = 0\n         right = col - 1\n         down = row - 1\n         up = 0\n         direction = 0\n         while True:\n             if direction == 0:\n                 for i in range(left, right + 1):\n                     res.append(matrix[up][i])\n                 up += 1\n             if direction == 1:\n                 for i in range(up, down + 1):\n                     res.append(matrix[i][right])\n                 right -= 1\n             if direction == 2:\n                 for i in reversed(range(left, right+1)):\n                     res.append(matrix[down][i])\n                 down -= 1\n             if direction == 3:\n                 for i in reversed(range(up, down + 1)):\n                     res.append(matrix[i][left])\n                 left += 1\n             direction = (direction + 1) % 4\n             if left > right or up > down:\n                 return res", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         res = []\n         if not matrix:\n             return res\n         \n         left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\n         \n         while left <= right and top <= bottom:\n             res += [matrix[top][i] for i in range(left,right+1)]\n             res += [matrix[i][right] for i in range(top+1,bottom)]\n             res += [matrix[bottom][i] for i in range(right, left-1,-1) if top < bottom]\n             res += [matrix[i][left] for i in range(bottom-1,top,-1) if left < right]\n             left+=1\n             right-=1\n             top+=1\n             bottom-=1\n         return res", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if len(matrix) == 0:\n             return []\n         level = 0\n         r = []\n         while len(r) < len(matrix)*len(matrix[0]):\n             if level%4 == 0:\n                 r += matrix[level//4][level//4: len(matrix[0]) - level//4]\n             elif level%4 == 1:\n                 side_index = len(matrix[0]) - (level)//4 - 1\n                 for i in range(level//4 + 1,len(matrix) - level//4):\n                     r.append(matrix[i][side_index])\n             elif level%4 == 2:\n                 r += matrix[len(matrix) -1 - level//4][level//4:len(matrix[0]) - level//4 -1][::-1]\n             elif level%4 == 3:\n                 side_index = level//4\n                 for i in range((len(matrix) -1 - level//4 -1),level//4 ,-1):\n                     r.append(matrix[i][side_index])\n             level +=1\n         return r\n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         ans = []\n         \n         if len(matrix) is 0:\n             return ans\n         \n         import numpy as np\n         npa = np.array(matrix, dtype = int)\n         \n         r_s = c_s = 0\n         r_e = len(matrix)\n         c_e = len(matrix[0])\n         \n         go_row = True\n         forward = True\n         row_index = r_s\n         col_index = c_e - 1\n         \n         while(r_s < r_e and c_s < c_e):\n             if go_row:\n                 # Traverse row\n                 s = npa[row_index,c_s:c_e].tolist()\n                 if forward:\n                     r_s += 1\n                     row_index = r_e -1\n                 else:\n                     r_e -= 1\n                     row_index = r_s\n                     s.reverse()\n                 ans.extend(s)\n                 \n                 \n             else:\n                 # traverse col\n                 s = npa[r_s:r_e, col_index].tolist()\n                 if forward:\n                     c_e -= 1\n                     col_index = c_s\n                 else:\n                     c_s += 1\n                     col_index = c_e - 1\n                     s.reverse()\n                 ans.extend(s)\n                 forward = not forward\n                                 \n             go_row = not go_row\n         \n         return ans", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         m = matrix\n         ml = len(m)\n         if ml == 0:\n             return []\n         nl = len(m[0])\n         ms, me, ns, ne = 0, ml - 1, 0, nl - 1 \n         ans = []\n         while ns <= ne or ms <= me: \n             #print(ms,me,ns,ne)\n             if ms <= me: \n                 for j in range(ns, ne + 1): \n                     ans.append(m[ms][j])\n                 ms += 1\n             #print(ms,me,ns,ne)\n             if ne >= ns: \n                 for j in range(ms, me + 1): \n                     ans.append(m[j][ne])\n                 ne -= 1\n             #print(ms,me,ns,ne)\n             if me >= ms: \n                 for j in range(ne, ns - 1, -1):\n                     ans.append(m[me][j])\n                 me -= 1\n             #print(ms,me,ns,ne)\n             if ns <= ne: \n                 for j in range(me, ms - 1, -1):\n                     ans.append(m[j][ns])\n                 ns += 1\n             #print(ms,me,ns,ne)\n         return ans ", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         # 0 is right, 1 is down, 2 is left, 3 is up\n         state = 0\n         next_direction = [1, 2, 3, 0]\n         r = []\n         \n         while len(matrix) > 0:\n             if state == 0:\n                 r += matrix[0]\n                 matrix = matrix[1:]\n                 state = next_direction[state]\n             elif state == 1:\n                 r += [m[len(matrix[0]) - 1] for m in matrix]\n                 matrix = [m[:len(matrix[0]) - 1] for m in matrix]\n                 state = 2\n             elif state == 2:\n                 r += reversed(matrix[-1])\n                 matrix = matrix[:-1]\n                 state = 3\n             elif state == 3:\n                 r += [matrix[j][0] for j in range(len(matrix) - 1, -1, -1)]\n                 matrix = [m[1:] for m in matrix]\n                 state = 0\n                \n             # Covers the case of a list of empty lists (eg. [[],[],[]])\n             if len(matrix) >= 1 and not matrix[0]:\n                 matrix = []\n                 \n         return r\n         \n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if not matrix:\n             return matrix\n         ans=matrix[0]\n         m=len(matrix)\n         n=len(matrix[0])\n         row_m, column_m=n-1, m-1\n         row_dir, column_dir=-1, 1\n         i0, j0=0, n-1\n         while  column_m>0:\n             ans.extend([matrix[i0+i*column_dir][j0] for i in range(1, column_m+1)])\n             i0+=column_m*column_dir\n             column_m-=1\n             column_dir*=-1\n                 \n             if row_m==0:\n                 return ans\n             else:\n                 ans.extend([matrix[i0][j0+row_dir*i] for i in range(1, row_m+1)])\n                 j0+=row_m*row_dir\n                 row_m-=1\n                 row_dir*=-1  \n         return ans", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         #O(n^2) time; O(1) space\n         if not matrix:\n             return []\n         \n         ans = []\n         rowSize = len(matrix); colSize = len(matrix[0])       \n         rowStart=0; colStart=0; rowEnd = rowSize-1; colEnd = colSize-1        \n         \n         while rowStart <= rowEnd and colStart <= colEnd:\n             \n             for colIndex in range(colStart,colEnd+1):\n                 ans.append(matrix[rowStart][colIndex])\n             rowStart += 1;\n             \n             for rowIndex in range(rowStart,rowEnd+1):\n                 ans.append(matrix[rowIndex][colEnd])\n             colEnd -= 1;\n             \n             if rowStart > rowEnd or colStart > colEnd: break                \n             \n             for colIndex in range(colEnd,colStart-1,-1):\n                 ans.append(matrix[rowEnd][colIndex])\n             rowEnd -= 1;                           \n                 \n             for rowIndex in range(rowEnd,rowStart-1,-1):\n                 ans.append(matrix[rowIndex][colStart])\n             colStart += 1;                                     \n             \n         return ans\n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if not matrix or not matrix[0]:\n             return []\n         \n         v = [[False] * len(matrix[0]) for _ in range(len(matrix))]\n         res = []\n         i = 0; j = 0\n         m = len(matrix)\n         n = len(matrix[0])\n         count = 0\n         dest = m * n\n         way = 0  # 0> 1v 2< 3^\n         offset = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n         while count < dest:\n             res.append(matrix[i][j])\n             count += 1\n             v[i][j] = True\n             if not (0 <= i + offset[way][0] < m) or not (0 <= j + offset[way][1] < n) or \\\n                 v[i + offset[way][0]][j + offset[way][1]]:\n                     way = (way + 1) % 4\n             i += offset[way][0]\n             j += offset[way][1]\n         return res\n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         \n         m = len(matrix)\n         if m == 0:\n             return []\n         n = len(matrix[0])\n     \n \n         visit = set()\n         result = []\n \n         pos = [0, 0]\n         visit.add(tuple(pos))\n         result.append(matrix[pos[0]][pos[1]])\n \n         while len(visit) < m*n:\n \n             for i in range(pos[1]+1, n):\n                 \n                 if (pos[0], i) in visit:\n                     break\n                 pos[1] = i\n                 visit.add(tuple(pos))\n                 result.append(matrix[pos[0]][pos[1]])\n \n \n             for i in range(pos[0]+1, m):\n                 \n                 if (i, pos[1]) in visit:\n                     break\n                 pos[0] = i\n                 visit.add(tuple(pos))\n                 result.append(matrix[pos[0]][pos[1]])\n \n             for i in range(pos[1]-1, -1, -1):\n                 \n                 if (pos[0], i) in visit:\n                     break\n \n                 pos[1] = i\n                 visit.add(tuple(pos))\n                 result.append(matrix[pos[0]][pos[1]])\n \n             for i in range(pos[0]-1, -1, -1):\n \n                 if (i, pos[1]) in visit:\n                     break\n \n                 pos[0] = i\n                 \n                 visit.add(tuple(pos))\n                 result.append(matrix[pos[0]][pos[1]])\n                 \n         return result\n                 \n         return result\n             \n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         output_arr = []\n     \n         while matrix:\n     \n             output_arr.extend(matrix.pop(0))\n         \n             tmp_arr = []\n             for i in zip(*matrix):\n                 tmp_arr.append(list(i))\n         \n             matrix = tmp_arr[::-1]\n \n         return output_arr\n", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if not matrix:\n             return []\n         left = top = 0\n         right = len(matrix[0]) - 1\n         bottom = len(matrix) - 1\n \n         result = []\n         while left < right and top < bottom:\n             for i in range(left, right):\n                 result.append(matrix[top][i])\n             for i in range(top, bottom):\n                 result.append(matrix[i][right])\n             for i in range(right, left, -1):\n                 result.append(matrix[bottom][i])\n             for i in range(bottom, top, -1):\n                 result.append(matrix[i][left])\n             left += 1\n             right -= 1\n             top += 1\n             bottom -= 1\n         if left == right and top == bottom:\n             result.append(matrix[top][left])\n         elif left == right:\n             for i in range(top, bottom + 1):\n                 result.append(matrix[i][left])\n         elif top == bottom:\n             for i in range(left, right + 1):\n                 result.append(matrix[top][i])\n         return result", "class Solution:\n     def spiralOrder(self, matrix):\n         \"\"\"\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if len(matrix) == 0:\n             return []\n         if len(matrix) == 1:\n             return matrix[0]\n         if len(matrix[0]) == 1:\n             result = []\n             for m in matrix:\n                 result.append(m[0])\n             return result\n         \n         \n         boxTop = -1\n         boxRight = len(matrix[0])\n         boxLeft = -1\n         boxBottom = len(matrix)\n         \n         \n         count = 0\n         direction = [0, 1]\n         ptr = [0, 0]\n         predict = [0, 0]\n         result = []\n         \n         while count < len(matrix) * len(matrix[0]):\n             count += 1\n             result.append(matrix[ptr[0]][ptr[1]])\n             ptr[0] += direction[0]\n             ptr[1] += direction[1]\n             \n             predict[0] = ptr[0] + direction[0]\n             predict[1] = ptr[1] + direction[1]\n             \n             \n             if direction == [0, 1] and predict[1] >= boxRight:\n                 direction = [1, 0]\n                 boxTop += 1\n             elif direction == [1,0] and predict[0] >= boxBottom:\n                 direction = [0, -1]\n                 boxRight -= 1\n             elif direction == [0, -1] and predict[1] <= boxLeft:\n                 direction = [-1, 0]\n                 boxBottom -= 1\n             elif direction == [-1, 0] and predict[0] <= boxTop:\n                 direction = [0, 1]\n                 boxLeft += 1\n             \n         return result"]
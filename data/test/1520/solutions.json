["t = [0] * 26\n\n\ndef get_k(c):\n    return ord(c) - ord('a')\n\n\ndef analyze(s):\n    length_of_str = len(s)\n    pos = 0\n    beauty_table = [0] * 26\n    for i in range(1, length_of_str):\n        if s[i] != s[pos]:\n            k = get_k(s[pos])\n            beauty_table[k] = max(beauty_table[k], i - pos)\n\n            pos = i\n    k = get_k(s[pos])\n    beauty_table[k] = max(beauty_table[k], length_of_str - pos)\n\n    pos = 0\n    while pos < length_of_str and s[pos] == s[0]:\n        pos += 1\n    left_beauty = pos\n    pos = length_of_str - 1\n    while pos > 0 and s[pos] == s[length_of_str - 1]:\n        pos -= 1\n    right_beauty = length_of_str - pos - 1\n    return beauty_table, left_beauty, right_beauty\n\n\nr = []\nfor _ in range(int(input())):\n    p = input()\n    if all(x == p[0] for x in p):  # pure\n        k = get_k(p[0])\n        for i in range(26):\n            if i == k:\n                t[i] = len(p) * (t[i] + 1) + t[i]\n            else:\n                t[i] = min(1, t[i])\n    else:\n        for i in range(26):\n            t[i] = min(1, t[i])\n\n        bt, lb, rb = analyze(p)\n        lk, rk = get_k(p[0]), get_k(p[-1])\n\n        if lk == rk:\n            t[lk] = lb + rb + t[lk]\n        else:\n            t[lk], t[rk] = t[lk] + lb, t[rk] + rb\n        for i in range(26):\n            t[i] = max(t[i], bt[i])\n    # r.append(max(t))\n    # print('\\ntableInfo: ', end= ' ')\n    # for i in range(26):\n    #     print('{}:{}/'.format(chr(i + ord('a')), t[i]), end=' ')\n    # print('')\n# print(' '.join(map(str, r)))\nprint(max(t))\n", "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\nN = int(readline())\nS = [readline().strip() for i in range(N)]\n\ndef calc(s):\n    res = []\n    last = s[0]\n    cnt = 0\n    for c in s:\n        if c == last:\n            cnt += 1\n        else:\n            res.append((last, cnt))\n            last = c\n            cnt = 1\n    if cnt > 0:\n        res.append((last, cnt))\n    return res\nrr = calc(S[N-1])\nif len(rr) > 1:\n    ans = max(x for c, x in rr)\n    c0, x0 = rr[0]\n    c1, x1 = rr[-1]\n    m0 = m1 = 0\n    for i in range(N-1):\n        s = S[i]\n        for c in s:\n            if c1 == c == c0:\n                ans = max(ans, x0+x1+1)\n            elif c == c0:\n                ans = max(ans, x0+1)\n            elif c == c1:\n                ans = max(ans, x1+1)\nelse:\n    c0, x0 = rr[0]\n    rr0 = calc(S[0])\n    r = 0\n    for c, x in rr0:\n        if c0 == c:\n            r = max(r, x)\n    for i in range(1, N-1):\n        rr1 = calc(S[i])\n        if len(rr1) == 1:\n            c1, x1 = rr1[0]\n            if c0 == c1:\n                r = (r+1)*x1 + r\n            else:\n                r = +(r > 0)\n        else:\n            d0, y0 = rr1[0]\n            d1, y1 = rr1[-1]\n            if c0 != d0:\n                y0 = 0\n            if c0 != d1:\n                y1 = 0\n            if r > 0:\n                r = y0 + y1 + 1\n            else:\n                r = max(y0, y1)\n            for d, y in rr1:\n                if d == c0:\n                    r = max(r, y)\n    ans = (r+1)*x0 + r\nprint(ans)", "n = input()\nn = int(n)\np = []\nsubstring_maxlen = 0\nstr_info = []\n\n_temper = [\n    \"abba\", \"a\"\n]\n\nfor i in range(n):\n    string = input()\n    str_info.append(string)\n    strlen = len(string)\n    start = 0\n    end = 0\n    for j in range(strlen):\n        if string[j] == string[0]:\n            start = start + 1\n        else:\n            break\n    for j in range(strlen):\n        if string[-1-j] == string[-1]:\n            end = end + 1\n        else:\n            break\n    p.append((string[0],start,string[-1],end, True if strlen == start else False))\n_max_len = 0\nparse = 0\n\n_temp_max = 0\nstring = str_info[-1]\ntoken = string[0]\nwhile parse < len(string):\n    token = string[parse]\n    _temp_max = 0\n    for k in range(parse, len(string)):\n        if string[k] == token:\n            parse = parse + 1\n            _temp_max = _temp_max + 1\n        else:\n            break\n    if substring_maxlen < _temp_max:\n        substring_maxlen = _temp_max\n\nstart_token = []\nend_token = []\nstart_token, start_num, end_token, end_num, connected = p[-1]\nlevel = 0\nfor i in range(1,len(p)):\n    if not connected:\n        break\n    else:\n        _string = str_info[-i-1]\n        _max_len = 0\n        parse = 0\n        _temp_max = 0\n        token = _string[0]\n        _substring_maxlen = 0\n        while parse < len(_string):\n            token = _string[parse]\n            if token != start_token:\n                parse = parse + 1\n                continue\n            _temp_max = 0\n            for k in range(parse, len(_string)):\n                if _string[k] == token:\n                    parse = parse + 1\n                    _temp_max = _temp_max + 1\n                else:\n                    break\n            if _substring_maxlen < _temp_max:\n                _substring_maxlen = _temp_max\n        substring_maxlen = max(substring_maxlen,start_num* (_substring_maxlen+1) + _substring_maxlen)\n\n\n        _start_token, _start_num, _end_token, _end_num, _connected = p[-1-i]\n        if _start_token == start_token:\n            start_num = start_num * (_start_num + 1) + _start_num\n        if _end_token == end_token:\n            end_num = end_num * (_end_num + 1) + _end_num\n        if not _connected or _start_token != start_token:\n            connected = False\n        level = i\n# print(start_token, start_num, end_token, end_num, connected, level)\nend_cond = 0\nif start_num > end_num:\n    end_cond = 1\nelif start_num < end_num:\n    end_cond = 2\nthe_End = False\nanswer = max(start_num, end_num) + 1\nfor i in range(len(p)-level-1):\n    for s in str_info[i]:\n        if start_token == s:\n            if end_cond < 2:\n                the_End = True\n                if start_token == end_token:\n                    answer = answer + min(start_num,end_num)\n                break\n        if end_token == s:\n            if end_cond %2 == 0:\n                the_End = True\n                if start_token == end_token:\n                    answer = answer + min(start_num,end_num)\n                break\n    if the_End:\n        break\nelse:\n    answer = answer - 1\nif len(p) == 1:\n    answer = answer - 1\n\nprint(max(answer,substring_maxlen))", "def prog(mass, st):\n    nonlocal alf\n    if st == st[0] * len(st):\n        for i in range(26):\n            if alf[i] == st[0]:\n                mass[i] = (mass[i] + 1) * len(st) + mass[i]\n            else:\n                mass[i] = min(1, mass[i])\n    else:\n        mmm = razlog(st)\n        r = 1\n        while st[r] == st[r - 1]:\n            r += 1\n        k = 1\n        while st[len(st) - k] == st[len(st) - k - 1]:\n            k += 1\n        for i in range(26):\n            if alf[i] == st[0] and alf[i] == st[-1]:\n                if mass[i] == 0:\n                    mass[i] = max(mmm[i], k, r)\n                else:\n                    mass[i] = max(mmm[i], k + r + 1)\n            elif alf[i] == st[0]:\n                if mass[i] == 0:\n                    mass[i] = max(mmm[i], r)\n                else:\n                    mass[i] = max(mmm[i], r + 1)\n            elif alf[i] == st[-1]:\n                if mass[i] == 0:\n                    mass[i] = max(mmm[i], k)\n                else:\n                    mass[i] = max(mmm[i], k + 1)\n            else:\n                if mass[i] == 0:\n                    mass[i] = mmm[i]\n                else:\n                    mass[i] = max(1, mmm[i])\n    return mass\n        \n        \n\ndef razlog(st):\n    nonlocal alf\n    mass = [0 for i in range(26)]\n    mass[alf.index(st[0])] = 1    \n    now = 1\n    for i in range(1, len(st)):\n        if st[i] == st[i - 1]:\n            now += 1\n        else:\n            now = 1\n        mass[alf.index(st[i])] = max(now, mass[alf.index(st[i])])\n    return mass \n\nn = int(input())\nst = input()\nalf = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\nmass = razlog(st)\nfor i in range(n - 1):\n    sti = input()\n    mass = prog(mass, sti)\nprint(max(mass))", "ALPH = 'abcdefghijklmnopqrstuvwxyz'\nMAX = 10 ** 9\n\ndef cnt(s):\n    c = {ch : 0 for ch in ALPH}\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        c[s[i]] = max(c[s[i]], j - i)\n        i = j\n    return c\n\ndef nxt(c, t):\n    nc = cnt(t)\n    for ch in ALPH:\n        if c[ch] and not nc[ch]:\n            nc[ch] = 1\n    f = 0\n    while f < len(t) and t[f] == t[0]:\n        f += 1\n    r = 0\n    while r < len(t) and t[-1 - r] == t[-1]:\n        r += 1\n    if t[0] == t[-1]:\n        if f == len(t):\n            nc[t[0]] = max(nc[t[0]], c[t[0]] + (c[t[0]] + 1) * len(t))\n        elif c[t[0]]:\n            nc[t[0]] = max(nc[t[0]], f + 1 + r)\n    else:\n        nc[t[0]] = max(nc[t[0]], f + (c[t[0]] > 0))\n        nc[t[-1]] = max(nc[t[-1]], r + (c[t[-1]] > 0))\n    return {x : min(MAX, y) for x, y in nc.items()}\n\nn = int(input())\nc = cnt(input())\nfor i in range(n - 1):\n    c = nxt(c, input())\nprint(max(c.values()))", "from math import *\nimport sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn = mint()\ns = list(minp())\n#a = [[0]*256 for i in range(3)]\na = [0]*256\ni = 0\nl = len(s)\nwhile i < l:\n\tj = i + 1\n\twhile j < l and s[j] == s[i]:\n\t\tj += 1\n\t#a[(i==0)+(j==l)][ord(s[i])] = max(a[(i==0)+(j==l)][ord(s[i])], j-i)\n\ta[ord(s[i])] = max(a[ord(s[i])], j-i)\n\ti = j\n#b = [[0]*256 for i in range(3)]\nb = [0]*256\nfor k in range(1,n):\n\t#print(a[ord('a'):ord('z')+1])\n\tfor i in range(ord('a'),ord('z')+1):\n\t\tb[i] = min(a[i],1)\n\ti = 0\n\ts = minp()\n\tl = len(s)\n\tq = 0\n\twhile i < l:\n\t\tj = i + 1\n\t\twhile j < l and s[j] == s[i]:\n\t\t\tj += 1\n\t\tz = ord(s[i])\n\t\tw = j-i\n\t\tif i == 0:\n\t\t\tq = w\n\t\t\tif j == l:\n\t\t\t\tw += (w+1)*a[z]\n\t\t\telif a[z] != 0:\n\t\t\t\tw += 1\n\t\telif j == l:\n\t\t\tw += 1\n\t\t\tif s[0] == s[-1]:\n\t\t\t\tw += q\n\t\tb[z] = max(b[z], w)\n\t\ti = j\n\ta,b = b,a\nprint(max(a))\n", "from math import *\nimport sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn = mint()\na = [0]*256\nb = [0]*256\nfor k in range(0,n):\n\t#print(a[ord('a'):ord('z')+1])\n\tfor i in range(ord('a'),ord('z')+1):\n\t\tb[i] = min(a[i],1)\n\ti = 0\n\ts = list(minp())\n\tl = len(s)\n\tq = 0\n\twhile i < l:\n\t\tj = i + 1\n\t\twhile j < l and s[j] == s[i]:\n\t\t\tj += 1\n\t\tz = ord(s[i])\n\t\tw = j-i\n\t\tif i == 0:\n\t\t\tq = w\n\t\t\tif j == l:\n\t\t\t\tw += (w+1)*a[z]\n\t\t\telif a[z] != 0:\n\t\t\t\tw += 1\n\t\telif j == l:\n\t\t\tw += 1\n\t\t\tif s[0] == s[-1]:\n\t\t\t\tw += q\n\t\tb[z] = max(b[z], w)\n\t\ti = j\n\ta,b = b,a\nprint(max(a))\n", "import os\nfrom io import BytesIO\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nfrom collections import namedtuple\nParsed = namedtuple(\"Parsed\", \"type p pl s sl\")\nD, U = 0, 1\n\ndef parse(s):\n    pc, sc = 0, 0\n\n    for c in s:\n        if c != s[0]:\n            break\n        pc += 1\n\n    for c in reversed(s):\n        if c != s[-1]:\n            break\n        sc += 1\n\n\n    if s[0] == s[-1] and pc == sc == len(s):\n        tp = U\n    else:\n        tp = D\n\n    return Parsed(tp, s[0], pc, s[-1], sc)\n\ndef max_conti_len(s, target):\n    mx = 0\n    cur = 0\n    for c in s:\n        if c == target:\n            cur += 1\n            mx = max(mx, cur)\n        else:\n            cur = 0\n    return mx\n\ndef len_mul(nl, ol):\n    return ol*nl + ol + nl\n\ndef solve(n, ss):\n    s = ss.pop()\n    op = parse(s)\n    mc = max(max_conti_len(s, chr(c)) for c in range(ord('a'), ord('z')+1))\n\n    while ss:\n        s = ss.pop()\n        np = parse(s)\n\n        if np.type == U and op.type == U:\n            if np.p == op.p:\n                nl = len_mul(np.pl, op.pl)\n                op = Parsed(U, op.p, nl, op.s, nl)\n            else:\n                op = Parsed(D, op.p, op.pl, op.s, op.sl)\n            mc = max(mc, op.pl)\n\n        elif np.type == D and op.type == U:\n            npl = len_mul(np.pl, op.pl) if np.p == op.p else op.pl\n            nsl = len_mul(np.sl, op.sl) if np.s == op.s else op.sl\n\n            mx = max_conti_len(s, op.s)\n            mc = max(mc, len_mul(mx, op.pl))\n\n            op = Parsed(D, op.p, npl, op.s, nsl)\n\n        elif op.type == D:\n            if op.p == op.s:\n                mp = op.pl+op.sl+1 if op.p in s else op.pl\n                ms = op.sl\n            else:\n                mp = op.pl+1 if op.p in s else op.pl\n                ms = op.sl+1 if op.s in s else op.sl\n            mc = max(mc, mp, ms)\n\n    print(mc)\n\n\ndef solve_from_stdin():\n    n = int(input())\n    ss = []\n    for _ in range(n):\n        ss.append(input())\n    solve(n, ss)\n\nsolve_from_stdin()", "def mult(s, t):\n    f1, l1, cntf1, cntl1, beaut1, n1 = s\n    f2, l2, cntf2, cntl2, beaut2, n2, p = t\n    f3, l3, cntf3, cntl3, beaut3, n3 = 0, 0, 0, 0, beaut1, 0\n    f3 = f1\n    l3 = l1\n    n3 = n1 * (n2 + 1) + n2\n    if cntf1 >= n1 and f1 == f2:\n        cntf3 = n1 * (cntf2 + 1) + cntf2\n    else:\n        cntf3 = cntf1\n    if cntl1 == n1 and l1 == l2:\n        cntl3 = n1 * (cntl2 + 1) + cntl2\n    else:\n        cntl3 = cntl1\n    if f1 != l1:\n        if f1 in p:\n            beaut3 = max(beaut3, cntf1 + 1)\n        if l1 in p:\n            beaut3 = max(beaut3, cntl1 + 1)\n    elif cntf1 >= n1:\n        beaut3 = max(n1, beaut3)\n        ans = 0\n        h = 0\n        for d in p:\n            if d == f1:\n                h += 1\n                ans = max(ans, h)\n            else:\n                h = 0\n        ans = max(ans, h)\n        beaut3 = max(beaut3, n1 * (ans + 1) + ans)\n    else:\n        if f1 in p:\n            beaut3 = max(beaut3, 1 + cntf1 + cntl1)\n        else:\n            beaut3 = max(beaut3, cntf1, cntl1)\n    return [f3, l3, cntf3, cntl3, beaut3, n3]\n\n\nn = int(input())\np = []\nfor i in range(n):\n    p.append(input())\npp = []\nfor s in p:\n    f = s[0]\n    l = s[-1]\n    cntf = 0\n    cntl = 0\n    beaut = 1\n    hep = 1\n    for i in s:\n        if i == f:\n            cntf += 1\n        else:\n            break\n    for i in s[::-1]:\n        if i == l:\n            cntl += 1\n        else:\n            break\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            hep += 1\n        else:\n            beaut = max(beaut, hep)\n            hep = 1\n    beaut = max(beaut, hep)\n    pp.append([f, l, cntf, cntl, beaut, len(s), s])\np = pp[::-1]\nlasts = p[0][:-1]\nfor i in range(1, len(p)):\n    lasts = mult(lasts, p[i])\nprint(lasts[-2])\n", "n = int(input())\n\n\n# for old string s + t\n# find out max length for each character -> inductively\n# is t single character\n# yes -> longest[char] = (longest[char] + 1) * (len(t) + 1) - 1,\n# longest[notchar] = 1 or 0 depending if it existed before\n# no -> longest[char] = longest same suffix_t/same prefix_t + 1 / longest[t]\n# longest not char = longest[t] or 1 or 0\n\n# need to keep track of\n# longest for every character in s\n# longest for every character in t\n# length of same prefix in t\n# length of same suffix in t\n\ndef get_longest(s):\n    prev_c = -1\n    curr_len = 0\n    longest = [0] * 26\n    for c in s:\n        if c != prev_c:\n            curr_len = 1\n            prev_c = c\n        else:\n            curr_len += 1\n        longest[c] = max(longest[c], curr_len)\n    return longest\n\n\ndef get_prefix(s):\n    prev_c = s[0]\n    curr_len = 0\n    for c in s:\n        if c == prev_c:\n            curr_len += 1\n        else:\n            return (prev_c, curr_len)\n    return (prev_c, curr_len)\n\n\ndef get_suffix(s):\n    prev_c = s[len(s)-1]\n    curr_len = 0\n    for i in range(len(s) - 1, -1, -1):\n        c = s[i]\n        if c == prev_c:\n            curr_len += 1\n        else:\n            return (prev_c, curr_len)\n    return (prev_c, curr_len)\n\n\ns = [ord(x) - 97 for x in input()]\nlongest_s = get_longest(s)\n\nfor i in range(1, n):\n    t = [ord(x) - 97 for x in input()]\n    longest_t = get_longest(t)\n    prefix = get_prefix(t)\n    suffix = get_suffix(t)\n    if prefix[1] == len(t):\n        for i in range(0, 26):\n            if i == t[0]:\n                longest_s[i] = (len(t) + 1) * (longest_s[i] + 1) - 1\n            else:\n                longest_s[i] = int(bool(longest_s[i]))\n    else:\n        for i in range(0, 26):\n            longest_s[i] = int(bool(longest_s[i]))\n            if i == prefix[0]:\n                longest_s[i] += prefix[1]\n            if i == suffix[0]:\n                longest_s[i] += suffix[1]\n            longest_s[i] = max(longest_s[i], longest_t[i])\n\nprint(max(longest_s))\n"]
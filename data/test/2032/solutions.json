["import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass RAQ_RMQ():\n    def __init__(self, n, inf=2**31-1):\n        self.n0 = 1<<(n-1).bit_length()\n        self.INF = inf\n        self.data = [0]*(2*self.n0)\n        self.lazy = [0]*(2*self.n0)\n\n    def getIndex(self, l, r):\n        l += self.n0; r += self.n0\n        lm = (l // (l & -l)) >> 1\n        rm = (r // (r & -r)) >> 1\n        while l < r:\n            if r <= rm:\n                yield r\n            if l <= lm:\n                yield l\n            l >>= 1; r >>= 1\n        while l:\n            yield l\n            l >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if not v:\n                continue\n            self.lazy[2*i-1] += v; self.lazy[2*i] += v\n            self.data[2*i-1] += v; self.data[2*i] += v\n            self.lazy[i-1] = 0\n\n    def update(self, l, r, x):\n        *ids, = self.getIndex(l, r)\n\n        l += self.n0; r += self.n0\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.lazy[r-1] += x; self.data[r-1] += x\n            if l & 1:\n                self.lazy[l-1] += x; self.data[l-1] += x\n                l += 1\n            l >>= 1; r >>= 1\n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]\n\n    def query(self, l, r):\n        self.propagates(*self.getIndex(l, r))\n        l += self.n0; r += self.n0\n\n        s = self.INF\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = min(s, self.data[r-1])\n            if l & 1:\n                s = min(s, self.data[l-1])\n                l += 1\n            l >>= 1; r >>= 1\n        return s\n\nn,m,k = map(int, input().split())\nl = [0]*(n+1)\nnow = k\npoint = [0]*n\nfor i in range(n):\n    a,b,c = map(int, input().split())\n    point[i] = c\n    now = now-a\n    l[i] = now\n    now += b+a\nl[n] = now\n\nRMQ = RAQ_RMQ(n+1)\nfor i in range(n+1):\n    RMQ.update(i,i+1,l[i])\n\nportal = list(range(n))\nfor i in range(m):\n    u,v = map(int, input().split())\n    u,v = u-1, v-1\n    if portal[v]<u:\n        portal[v] = u\n\nif RMQ.query(0, n+1) < 0:\n    print(-1)\n    return\n\nheap = [(-point[i], -portal[i]) for i in range(n)]\nfrom heapq import heapify, heappop\nheapify(heap)\n\nans = 0\nwhile heap:\n    p,i = heappop(heap)\n    p,i = -p,-i\n    if RMQ.query(i+1, n+1)>0:\n        ans += p\n        RMQ.update(i+1, n+1, -1)\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\nn, m, k = map(int, input().split())\ncas = [list(map(int, input().split())) for i in range(n)]\npot = [list(map(int, input().split())) for i in range(m)]\n\ntiming = [i for i in range(n)]\nfor i in range(m):\n    a, b = pot[i]\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    timing[a] = max(b, timing[a])\n\ntime = [[] for i in range(n)]\nfor i in range(n):\n    time[timing[i]].append(cas[i][2])\nfor i in range(n):\n    time[timing[i]].sort(reverse = True)\n\n\nmemo = {}\nmemo[k] = 0\nfor i in range(n):\n    a, add_, c = cas[i]\n    memo2 = {}\n    for j in memo:\n        if j >= a:\n            memo2[j + add_] = memo[j]\n\n    for num in time[i]:\n        tmp = memo2.copy()\n        for j in tmp:\n            if j-1 not in memo2:\n                memo2[j-1] = tmp[j] + num\n            else:\n                memo2[j-1] = max(tmp[j-1], tmp[j] + num)\n    memo = memo2.copy()\n\nans = -1\nfor i in memo:\n    ans = max(ans, memo[i])\nprint(ans)", "import sys\nn, m, k = list(map(int, input().split()))\ncastle = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n_p = [[] for _ in range(n)]\nendpoints = [0]*n\nfor u, v in (list(map(int, l.split())) for l in sys.stdin):\n    _p[v-1].append(u-1)\n    endpoints[v-1] = 1\n\nportal = [[] for _ in range(n)]\nfor t in range(n):\n    if _p[t]:\n        s = max(_p[t])\n        portal[s].append(castle[t][2])\n\n\nmax_n = 5000\ndp = [-1]*(max_n+1)\ndp[k] = 0\n\nfor i, (a, b, c) in enumerate(castle):\n    next_dp = [-1]*(max_n+1)\n    p = portal[i]\n    if not endpoints[i]:\n        p.append(c)\n    p.sort(reverse=True)\n    for i in range(len(p)-1):\n        p[i+1] += p[i]\n    p = [0] + p\n    len_p = len(p)\n\n    for i in range(a, max_n-b+1):\n        if dp[i] == -1:\n            continue\n        w = i + b\n        for j in range(len_p):\n            next_dp[w-j] = max(next_dp[w-j], dp[i]+p[j])\n            if w-j == 0:\n                break\n\n    dp = next_dp\n\nprint(max(dp))\n"]
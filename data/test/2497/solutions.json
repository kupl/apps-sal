["\nfrom itertools import combinations\n\nINF = float(\"inf\")\ndata = {d: [-INF, INF, -INF, INF] for d in 'RLUD'}\n\n_, *XYD = open(0).read().split()\nX = map(int, XYD[::3])\nY = map(int, XYD[1::3])\nD = map(data.get, XYD[2::3])\n\nfor x, y, d in zip(X, Y, D):\n    d[0] = max(d[0], x)\n    d[1] = min(d[1], x)\n    d[2] = max(d[2], y)\n    d[3] = min(d[3], y)\n\n\nX = [\n    (data[\"L\"][0], -1), (data[\"L\"][1], -1),\n    (data[\"R\"][0], 1), (data[\"R\"][1], 1),\n    (data[\"U\"][0], 0), (data[\"U\"][1], 0),\n    (data[\"D\"][0], 0), (data[\"D\"][1], 0),\n]\nY = [\n    (data[\"L\"][2], 0), (data[\"L\"][3], 0),\n    (data[\"R\"][2], 0), (data[\"R\"][3], 0),\n    (data[\"U\"][2], 1), (data[\"U\"][3], 1),\n    (data[\"D\"][2], -1), (data[\"D\"][3], -1),\n]\n\nX = [(x, dx) for x, dx in X if abs(x) < INF]\nY = [(y, dy) for y, dy in Y if abs(y) < INF]\n\nT = set(\n    [0] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(X, 2) if dx != dy] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(Y, 2) if dx != dy]\n)\n\n\ndef area(t):\n    XX = [t * dx + x for x, dx in X]\n    YY = [t * dy + y for y, dy in Y]\n\n    dx = max(XX) - min(XX)\n    dy = max(YY) - min(YY)\n\n    return dx * dy\n\n\nprint(min(map(area, T)))", "I = float('inf')\nN = int(input())\nXYD = [input().split() for _ in range(N)]\nxL = set()\nxR = set()\nxS = set()\nyD = set()\nyU = set()\nyS = set()\nfor xyd in XYD:\n    x, y, d = xyd\n    x = int(x)\n    y = int(y)\n    if d == 'L':\n        xL.add(x)\n        yS.add(y)\n    elif d == 'R':\n        xR.add(x)\n        yS.add(y)\n    elif d == 'U':\n        yU.add(y)\n        xS.add(x)\n    else:\n        yD.add(y)\n        xS.add(x)\n#xmin\nxRmin = min(xR | {I})\nxLmin = min(xL | {I})\nxSmin = min(xS | {I})\n#xmax\nxRmax = max(xR | {-I})\nxLmax = max(xL | {-I})\nxSmax = max(xS | {-I})\n\nx2m = xLmax - xRmin\nx1m = max(xSmax - xRmin, xLmax - xSmin)\nx0 = max(xRmax - xRmin, xLmax - xLmin, xSmax - xSmin)\nx1 = max(xSmax - xLmin, xRmax - xSmin)\nx2 = xRmax - xLmin\n#ymin\nyUmin = min(yU | {I})\nyDmin = min(yD | {I})\nySmin = min(yS | {I})\n#ymax\nyUmax = max(yU | {-I})\nyDmax = max(yD | {-I})\nySmax = max(yS | {-I})\n\ny2m = yDmax - yUmin\ny1m = max(ySmax - yUmin, yDmax - ySmin)\ny0 = max(yUmax - yUmin, yDmax - yDmin, ySmax - ySmin)\ny1 = max(ySmax - yDmin, yUmax - ySmin)\ny2 = yUmax - yDmin\n\n\ndef dd(t):\n    if 0 <= t < I:\n        return max(x2m - 2 * t, x1m - t, x0, x1 + t, x2 + 2 * t) * max(\n            y2m - 2 * t, y1m - t, y0, y1 + t, y2 + 2 * t)\n    else:\n        return I\n\n\nt = [0, x2m / 2, x1m, y2m / 2, y1m]\nt += [x2m - x1m, x1m - x0, x0 - x1, x1 - x2]\nt += [(x2m - x0) / 2, (x1m - x1) / 2, (x0 - x2) / 2]\nt += [(x2m - x1) / 3, (x1m - x2) / 3]\nt += [(x2m - x2) / 4]\nt += [y2m - y1m, y1m - y0, y0 - y1, y1 - y2]\nt += [(y2m - y0) / 2, (y1m - y1) / 2, (y0 - y2) / 2]\nt += [(y2m - y1) / 3, (y1m - y2) / 3]\nt += [(y2m - y2) / 4]\nt += [(x2m + y2m) / 4, (x2 + y2) / 4]\nt += [(x2m + 2 * y1m) / 4, (y1m + 2 * x2m) / 4, (x2 + 2 * y1) / 4,\n      (y1 + 2 * x2) / 4]\nt += [(x1m + y1m) / 2, (x1 + y1) / 2]\n\nprint((min([dd(time) for time in t])))\n", "n = int(input())\nR = []\nL = []\nU = []\nD = []\nlm = [float(\"INF\")]*3\nrm = [-float(\"INF\")]*3\ndm = [float(\"INF\")]*3\num = [-float(\"INF\")]*3\nfor i in range(n):\n    x,y,d = input().split()\n    x = int(x)\n    y = int(y)\n    if d == \"U\":\n        rm[1] = max(rm[1],x)\n        lm[1] = min(lm[1],x)\n        dm[0] = min(dm[0],y)\n        um[2] = max(um[2],y)\n        U.append((x,y,d))\n    elif d == \"D\":\n        rm[1] = max(rm[1],x)\n        lm[1] = min(lm[1],x)\n        um[0] = max(um[0],y)\n        dm[2] = min(dm[2],y)\n        D.append((x,y,d))\n    elif d == \"L\":\n        um[1] = max(um[1],y)\n        dm[1] = min(dm[1],y)\n        rm[0] = max(rm[0],x)\n        lm[2] = min(lm[2],x)\n        L.append((x,y,d))\n    else:\n        um[1] = max(um[1],y)\n        dm[1] = min(dm[1],y)\n        lm[0] = min(lm[0],x)\n        rm[2] = max(rm[2],x)\n        R.append((x,y,d))\ntime = set()\ndef rc(t):\n    if rm[2] == max(rm):\n        return rm[2]+t\n    if rm[1] == max(rm):\n        if rm[2] == -float(\"INF\"):\n            return rm[1]\n        else:\n            time.add(rm[1]-rm[2])\n            return max(rm[1],rm[2]+t)\n    if rm[2] == -float(\"INF\") and rm[1] == -float(\"INF\"):\n        return rm[0]-t\n    if rm[2] == -float(\"INF\"):\n        time.add(rm[0]-rm[1])\n        return max(rm[1],rm[0]-t)\n    if rm[1] == -float(\"INF\"):\n        time.add((rm[0]-rm[2])/2)\n        return max(rm[0]-t,rm[2]+t)\n    if (rm[0]-rm[2])/2+rm[2] >= rm[1]:\n        time.add((rm[0]-rm[2])/2)\n        return max(rm[0]-t,rm[2]+t)\n    time.add(rm[0]-rm[1])\n    time.add(rm[1]-rm[2])\n    return max(rm[0]-t,rm[2]+t,rm[1])\ndef lc(t):\n    if lm[2] == min(lm):\n        return lm[2]-t\n    if lm[1] == min(lm):\n        if lm[2] == float(\"INF\"):\n            return lm[1]\n        else:\n            time.add(-lm[1]+lm[2])\n            return min(lm[1],lm[2]-t)\n    if lm[2] == float(\"INF\") and lm[1] == float(\"INF\"):\n        return lm[0]+t\n    if lm[2] == float(\"INF\"):\n        time.add(-lm[0]+lm[1])\n        return min(lm[1],lm[0]+t)\n    if lm[1] == float(\"INF\"):\n        time.add((-lm[0]+lm[2])/2)\n        return min(lm[0]+t,lm[2]-t)\n    if lm[2]-(-lm[0]+lm[2])/2 <= lm[1]:\n        time.add((-lm[0]+lm[2])/2)\n        return min(lm[0]+t,lm[2]-t)\n    time.add(-lm[0]+lm[1])\n    time.add(-lm[1]+lm[2])\n    return min(lm[0]+t,lm[2]-t,lm[1])\ndef uc(t):\n    if um[2] == max(um):\n        return um[2]+t\n    if um[1] == max(um):\n        if um[2] == -float(\"INF\"):\n            return um[1]\n        else:\n            time.add(um[1]-um[2])\n            return max(um[1],um[2]+t)\n    if um[2] == -float(\"INF\") and um[1] == -float(\"INF\"):\n        return um[0]-t\n    if um[2] == -float(\"INF\"):\n        time.add(um[0]-um[1])\n        return max(um[1],um[0]-t)\n    if um[1] == -float(\"INF\"):\n        time.add((um[0]-um[2])/2)\n        return max(um[0]-t,um[2]+t)\n    if (um[0]-um[2])/2+um[2] >= um[1]:\n        time.add((um[0]-um[2])/2)\n        return max(um[0]-t,um[2]+t)\n    time.add(um[0]-um[1])\n    time.add(um[1]-um[2])\n    return max(um[0]-t,um[2]+t,um[1])\ndef dc(t):\n    if dm[2] == min(dm):\n        return dm[2]-t\n    if dm[1] == min(dm):\n        if dm[2] == float(\"INF\"):\n            return dm[1]\n        else:\n            time.add(-dm[1]+dm[2])\n            return min(dm[1],dm[2]-t)\n    if dm[2] == float(\"INF\") and dm[1] == float(\"INF\"):\n        return dm[0]+t\n    if dm[2] == float(\"INF\"):\n        time.add(-dm[0]+dm[1])\n        return min(dm[1],dm[0]+t)\n    if dm[1] == float(\"INF\"):\n        time.add((-dm[0]+dm[2])/2)\n        return min(dm[0]+t,dm[2]-t)\n    if dm[2]-(-dm[0]+dm[2])/2 <= dm[1]:\n        time.add((-dm[0]+dm[2])/2)\n        return min(dm[0]+t,dm[2]-t)\n    time.add(-dm[0]+dm[1])\n    time.add(-dm[1]+dm[2])\n    return min(dm[0]+t,dm[2]-t,dm[1])\nans = (rc(0)-lc(0))*(uc(0)-dc(0))\nfor t in time:\n    count = (rc(t)-lc(t))*(uc(t)-dc(t))\n    ans = min(ans,count)\nprint(ans)", "import bisect\nimport heapq\nimport sys\n\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\n\nclass V:\n    def __init__(self, f):\n        self.f = f\n        self.v = None\n\n    def __str__(self):\n        return str(self.v)\n\n    def ud(self, n):\n        if self.v is None:\n            self.v = n\n        else:\n            self.v = self.f(self.v, n)\n\n    def get(self):\n        return self.v\n\n\ndef read_values():\n    return list(map(int, input().split()))\n\n\ndef read_list():\n    return list(read_values())\n\n\ndef calc_v(D, f, i):\n    p, n, c = V(f), V(f), V(f)\n    for d, P in list(D.items()):\n        for pp in P:\n            if d == (\"R\" if i == 0 else \"U\"):\n                p.ud(pp[i])\n            elif d == (\"L\" if i == 0 else \"D\"):\n                n.ud(pp[i])\n            else:\n                c.ud(pp[i])\n\n    p = p.get()\n    n = n.get()\n    c = c.get()\n    return p, n, c, f\n\n\ndef calc_e(p, n, c, f):\n    if p is None:\n        if c is None or n is None:\n            return []\n        else:\n            return [n - c]\n\n    if n is None:\n        if c is None:\n            return []\n        else:\n            return [c - p]\n\n    t = (n - p) / 2\n    if c is None:\n        return [t]\n\n    return [t, c - p, n - c]\n\n\ndef calc(t, L):\n    res = V(L[3])\n    if L[0] is not None:\n        res.ud(L[0] + t)\n\n    if L[1] is not None:\n        res.ud(L[1] - t)\n\n    if L[2] is not None:\n        res.ud(L[2])\n\n    return res.get()\n\n\ndef main():\n    N = int(input())\n    D = {\n        \"R\": [],\n        \"L\": [],\n        \"U\": [],\n        \"D\": [],\n    }\n\n    for _ in range(N):\n        x, y, d = input().split()\n        x = int(x)\n        y = int(y)\n        D[d].append((x, y))\n\n    VV = []\n    VV.append(calc_v(D, max, 0))\n    VV.append(calc_v(D, min, 0))\n    VV.append(calc_v(D, max, 1))\n    VV.append(calc_v(D, min, 1))\n\n    E = {0}\n    for e in [calc_e(*v) for v in VV]:\n        for t in e:\n            E.add(t)\n\n    res = V(min)\n    for t in E:\n        if t < 0:\n            continue\n        res.ud((calc(t, VV[0]) - calc(t, VV[1])) * (calc(t, VV[2]) - calc(t, VV[3])))\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import os\nimport sys\n\nimport numpy as np\nfrom scipy.optimize import fmin\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nN = int(sys.stdin.readline())\nX, Y, D = list(zip(*[sys.stdin.readline().rstrip().split() for _ in range(N)]))\nX = np.array(X, dtype=int)\nY = np.array(Y, dtype=int)\nD = np.array(D)\n\nRmin = min(list(X[D == 'R']) + [INF])\nRmax = max(list(X[D == 'R']) + [-INF])\nLmin = min(list(X[D == 'L']) + [INF])\nLmax = max(list(X[D == 'L']) + [-INF])\nUmin = min(list(Y[D == 'U']) + [INF])\nUmax = max(list(Y[D == 'U']) + [-INF])\nDmin = min(list(Y[D == 'D']) + [INF])\nDmax = max(list(Y[D == 'D']) + [-INF])\n\nXmin = min(list(X[(D == 'U') | (D == 'D')]) + [INF])\nXmax = max(list(X[(D == 'U') | (D == 'D')]) + [-INF])\nYmin = min(list(Y[(D == 'R') | (D == 'L')]) + [INF])\nYmax = max(list(Y[(D == 'R') | (D == 'L')]) + [-INF])\n\n\ndef cost(t):\n    if t < 0:\n        return -t + 10 ** 18\n    xl = min(Xmin, Lmin - t, Rmin + t)\n    xr = max(Xmax, Lmax - t, Rmax + t)\n    yb = min(Ymin, Dmin - t, Umin + t)\n    yt = max(Ymax, Dmax - t, Umax + t)\n    return (xr - xl) * (yt - yb)\n\n\nx, = fmin(cost, x0=100000, ftol=10 ** -10, disp=False)\nprint(('{:.10f}'.format(cost(x))))\n", "dirs = {'R': (1, 0), 'L': (-1, 0), 'U': (0, 1), 'D': (0, -1)}\n\nN = int(input())\nP = {d: [] for d in dirs}\nfor i in range(N):\n    x, y, d = input().split()\n    x, y = list(map(int, (x, y)))\n    P[d].append((x, y))\n\ndef fst(x): return x[0]\ndef snd(x): return x[1]\ninf = float('inf')\n\n# \u65b9\u5411\u5225\u306eX\u30fbY\u306e\u6700\u5927\u6700\u5c0f\nS = {d: {'xmin': min(list(map(fst, P[d])), default= inf),\n         'xmax': max(list(map(fst, P[d])), default=-inf),\n         'ymin': min(list(map(snd, P[d])), default= inf),\n         'ymax': max(list(map(snd, P[d])), default=-inf) }\n     for d in dirs}\n\n# \u5909\u5316\u304c\u3042\u308b\u6642\u523b\u306f0\u3068\u4ee5\u4e0b\u306et1, t2, t3\n# S[L][xmax] - t1 == max(S[U][xmax], S[D][xmax]), t < t1 -> S[UD] < S[L]\n# S[R][xmax] + t2 == max(S[U][xmax], S[D][xmax]), t < t2 -> S[R]  < S[UD]\n# S[L][xmax] - t3 == S[R][xmax] + t3,             t < t3 -> S[R]  < S[L]\n\ndirs = {d: {'x': dirs[d][0], 'y': dirs[d][1]} for d in dirs}\nvars = ('xmax', 'xmin', 'ymax', 'ymin')\nmaxmin = {'max': max, 'min': min}\nmaxmin = {v: maxmin[v[-3:]] for v in vars}\n\n# \u5909\u5316\u304c\u3042\u308b\u6642\u523b\u306e\u96c6\u5408\nT = set()\nT.add(0)\nfor v in vars:\n    u, d, c1, c2 = ('R', 'L', 'U', 'D') if v.startswith('x') else \\\n                   ('U', 'D', 'R', 'L')\n    C  = maxmin[v](S[c1][v], S[c2][v])\n    t1 =  S[d][v] - C  # inf - inf == nan\n    t2 = -S[u][v] + C\n    t3 = (S[d][v] - S[u][v]) / 2\n    T.update([t1, t2, t3])\n\n# \u5404\u6642\u523b\u306exmax, xmin, ymax, ymin\u3092\u8a08\u7b97\nq = inf\nfor t in (t for t in T if 0 <= t < inf):\n    Q = {v: maxmin[v](S[d][v] + t * dirs[d][v[0]] for d in dirs)\n         for v in vars}\n    q = min(q, (Q['xmax'] - Q['xmin']) * (Q['ymax'] - Q['ymin']))\n\nprint(q)\n", "inf = float('inf')\nN = int(input())\nMRp = -inf\nMR = -inf\nMRm = -inf\nmRp = inf\nmR = inf\nmRm = inf\nMUp = -inf\nMU = -inf\nMUm = -inf\nmUp = inf\nmU = inf\nmUm = inf\n\nfor i in range(N):\n\tx, y, d = input().split()\n\tx, y = int(x), int(y)\n\tif d == 'R':\n\t\tMRp = max(MRp, x)\n\t\tmRp = min(mRp, x)\n\t\tMU = max(MU, y)\n\t\tmU = min(mU, y)\n\telif d == 'L':\n\t\tMRm = max(MRm, x)\n\t\tmRm = min(mRm, x)\n\t\tMU = max(MU, y)\n\t\tmU = min(mU, y)\n\telif d == 'U':\n\t\tMUp = max(MUp, y)\n\t\tmUp = min(mUp, y)\n\t\tMR = max(MR, x)\n\t\tmR = min(mR, x)\n\telse:\n\t\tMUm = max(MUm, y)\n\t\tmUm = min(mUm, y)\n\t\tMR = max(MR, x)\n\t\tmR = min(mR, x)\n\nt = [0]\nif MR > max(MRp, MRm):\n\tt.append(MR - MRp)\nelif MRm + MRp >= 2 * MR and MRm > MRp:\n\tt.append((MRm - MRp) / 2)\nelif MRm > MRp:\n\tt.append(MRm - MR)\n\tt.append(MR - MRp)\t\nif mR < min(mRp, mRm):\n\tt.append(mRm - mR)\nelif mRm + mRp <= 2 * mR and mRm > mRp:\n\tt.append((mRm - mRp) / 2)\nelif mRm > mRp:\n\tt.append(mRm - mR)\n\tt.append(mR - mRp)\nif MU > max(MUp, MUm):\n\tt.append(MU - MUp)\nelif MUm + MUp >= 2 * MU and MUm > MUp:\n\tt.append((MUm - MUp) / 2)\nelif MUm > MUp:\n\tt.append(MUm - MU)\n\tt.append(MU - MUp)\nif mU < min(mUp, mUm):\n\tt.append(mUm - mU)\nelif mUm + mUp <= 2 * mU and mUm > mUp:\n\tt.append((mUm - mUp) / 2)\nelif mUm > mUp:\n\tt.append(mUm - mU)\n\tt.append(mU - mUp)\n\nans = inf\nfor i in t:\n\tdx = max(MRp + i, MR, MRm - i) - min(mRp + i, mR, mRm - i)\n\tdy = max(MUp + i, MU, MUm - i) - min(mUp + i, mU, mUm - i)\n\tans = min(ans, dx * dy)\nprint(ans)", "n = int(input())\nxyd = [list(input().split()) for i in range(n)]\nxmax,ymax = [-10**9,-10**9,-10**9],[-10**9,-10**9,-10**9]\nxmin,ymin = [10**9,10**9,10**9],[10**9,10**9,10**9]\n#xmax: max(x1-t,x2,x3+t)\n#xmin: min(x1+t,x2,x3-t)\n#ymax: max(y1-t,y2,y3+t)\n#ymin: min(y1+t,y2,y3-t)\ndef chp(ls,a,flg1,i):\n  if flg1:\n    ls[i] = max(ls[i],a)\n  else:\n    ls[i] = min(ls[i],a)\ndef area(t):\n  x = max(xmax[0]-t,xmax[1],xmax[2]+t)-min(xmin[0]+t,xmin[1],xmin[2]-t)\n  y = max(ymax[0]-t,ymax[1],ymax[2]+t)-min(ymin[0]+t,ymin[1],ymin[2]-t)\n  return x*y\nfor x,y,d in xyd:\n  x,y = int(x),int(y)\n  if d in (\"L\",\"R\"):\n    chp(ymax,y,1,1)\n    chp(ymin,y,0,1)\n    if d == \"R\":\n      chp(xmin,x,0,0)\n      chp(xmax,x,1,2)\n    if d == \"L\":\n      chp(xmin,x,0,2)\n      chp(xmax,x,1,0)\n  elif d in (\"U\",\"D\"):\n    chp(xmax,x,1,1)\n    chp(xmin,x,0,1)\n    if d == \"U\":\n      chp(ymax,y,1,2)\n      chp(ymin,y,0,0)\n    if d == \"D\":\n      chp(ymin,y,0,2)\n      chp(ymax,y,1,0)\n\nevent = [0]\nfor ls in xmax,ymax:\n  event.append(ls[0]-ls[1])\n  event.append((ls[0]-ls[2])/2)\n  event.append(ls[1]-ls[2])\nfor ls in xmin,ymin:\n  event.append(ls[1]-ls[0])\n  event.append((ls[2]-ls[0])/2)\n  event.append(ls[2]-ls[1])\nans = 10**18\n\nfor i in event:\n  if i>=0:\n    for j in range(-10,10):\n      if i+j*0.5 >= 0:\n        ans = min(ans,area(i+j*0.5))\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\ninf = float('inf')\n\ndef solve(N: int, x: \"List[int]\", y: \"List[int]\", d: \"List[str]\"):\n    D_xmin = [inf for dd in [-1, 0, 1]]\n    D_xmax = [-inf for dd in [-1, 0, 1]]\n    D_ymin = [inf for dd in [-1, 0, 1]]\n    D_ymax = [-inf for dd in [-1, 0, 1]]\n    trans_x = {'U': 1, 'D': 1, 'L': 0, 'R': 2}\n    trans_y = {'U': 2, 'D': 0, 'L': 1, 'R': 1}\n    \n    for xx, yy, dd in zip(x, y, d):\n        D_xmin[trans_x[dd]] = min(D_xmin[trans_x[dd]], xx)\n        D_xmax[trans_x[dd]] = max(D_xmax[trans_x[dd]], xx)\n        D_ymin[trans_y[dd]] = min(D_ymin[trans_y[dd]], yy)\n        D_ymax[trans_y[dd]] = max(D_ymax[trans_y[dd]], yy)\n    \n    ts = [0]\n    for D in [D_xmin, D_xmax, D_ymin, D_ymax]:\n        ts.append(D[0] - D[1])\n        ts.append(D[1] - D[2])\n        ts.append((D[0] - D[2]) / 2)\n\n    res = inf\n    for t in ts:\n        if t < 0:\n            continue\n        xmin = min(D_xmin[0] - t, D_xmin[1], D_xmin[2] + t)\n        xmax = max(D_xmax[0] - t, D_xmax[1], D_xmax[2] + t)\n        ymin = min(D_ymin[0] - t, D_ymin[1], D_ymin[2] + t)\n        ymax = max(D_ymax[0] - t, D_ymax[1], D_ymax[2] + t)\n        res = min(res, (xmax - xmin) * (ymax - ymin))\n\n    print(res)\n    return\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\" \n    y = [int()] * (N)  # type: \"List[int]\" \n    d = [str()] * (N)  # type: \"List[str]\" \n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n        d[i] = next(tokens)\n    solve(N, x, y, d)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.optimize import fmin\n\nINF = 10**18\n\nmapping = {\n    \"R\": (1, 0),\n    \"L\": (-1, 0),\n    \"U\": (0, 1),\n    \"D\": (0, -1)\n}\n\ndef f(x, vx, t):\n    if t < 0:\n        return INF\n    nx = x + vx * t\n    return nx.max() - nx.min()\n\ndef solve(n, x, y, d):\n    x = np.asarray(x, dtype=np.float)\n    y = np.asarray(y, dtype=np.float)\n    vx = np.zeros(n, dtype=np.float)\n    vy = np.zeros(n, dtype=np.float)\n    for i in range(n):\n        vx[i], vy[i] = mapping[d[i]]\n    h = lambda t: f(y, vy, t) * f(x, vx, t)\n    t = fmin(h, x0=10**8, ftol=1e-9, disp=False)[0]\n    return h(t)\n\nn = int(input())\nx, y, d = [-1]*n, [-1]*n, [-1]*n\nfor i in range(n):\n    x[i], y[i], d[i] = input().split()\n    x[i] = int(x[i])\n    y[i] = int(y[i])\nprint(solve(n, x, y, d))", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    inf = 10**8 + 1\n    N = int(input())\n    const_x_max, right_max, left_max = -inf, -inf, -inf\n    const_x_min, right_min, left_min = inf, inf, inf\n    const_y_max, up_max, down_max = -inf, -inf, -inf\n    const_y_min, up_min, down_min = inf, inf, inf\n    for _ in range(N):\n        x, y, d = list(map(str, input().strip().split()))\n        x, y = int(x), int(y)\n\n        if d == 'R':\n            right_max = max(right_max, x)\n            right_min = min(right_min, x)\n            const_y_max = max(const_y_max, y)\n            const_y_min = min(const_y_min, y)\n        elif d == 'L':\n            left_max = max(left_max, x)\n            left_min = min(left_min, x)\n            const_y_max = max(const_y_max, y)\n            const_y_min = min(const_y_min, y)\n        elif d == 'U':\n            const_x_max = max(const_x_max, x)\n            const_x_min = min(const_x_min, x)\n            up_max = max(up_max, y)\n            up_min = min(up_min, y)\n        else:\n            const_x_max = max(const_x_max, x)\n            const_x_min = min(const_x_min, x)\n            down_max = max(down_max, y)\n            down_min = min(down_min, y)\n\n    inflections = set([0])\n    # The time when the slope of max_x changes.\n    # 1. from decrease to constant.\n    inflections.add(max(0, left_max - const_x_max))\n    # 2. from decrease to increase.\n    inflections.add(max(0, (left_max - right_max)/2))\n    # 3. from constant to increase.\n    inflections.add(max(0, const_x_max - right_max))\n\n    # The time when the slope of min_x changes.\n    # 4. from increase to constatnt.\n    inflections.add(max(0, const_x_min - right_min))\n    # 5. from increase to decrease.\n    inflections.add(max(0, (left_min - right_min)/2))\n    # 6. from constant to decrease.\n    inflections.add(max(0, left_min - const_x_min))\n\n    # The time when the slope of max_y changes.\n    # 7. from decrease to constant.\n    inflections.add(max(0, down_max - const_y_max))\n    # 8. from decrease to increase.\n    inflections.add(max(0, (down_max - up_max)/2))\n    # 9. from constant to increase.\n    inflections.add(max(0, const_y_max - up_max))\n\n    # The time when the slope of min_y changes.\n    # 10. from increase to constatnt.\n    inflections.add(max(0, const_y_min - up_min))\n    # 11. from increase to decrease.\n    inflections.add(max(0, (down_min - up_min)/2))\n    # 12. from constant to decrease.\n    inflections.add(max(0, down_min - const_y_min))\n\n\n    def get_val(t):\n        x0 = max(const_x_max, right_max + t, left_max - t)\n        x1 = min(const_x_min, right_min + t, left_min - t)\n        y0 = max(const_y_max, up_max + t, down_max - t)\n        y1 = min(const_y_min, up_min + t, down_min - t)\n\n        return (x0 - x1) * (y0 - y1)\n\n    ans = 10**18\n    for t in inflections:\n        ans = min(ans, get_val(t))\n\n    return ans\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "inf = float('inf')\nfrom scipy.optimize import fmin\nfrom collections import defaultdict\ndir = {'R', 'L', 'U', 'D'}\nN = int(input())\ndic = defaultdict(list)\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n    dic[d].append((x, y))\nx_max = defaultdict(lambda : -inf)\nx_min = defaultdict(lambda : inf)\ny_max = defaultdict(lambda : -inf)\ny_min = defaultdict(lambda : inf)\nfor d in dir:\n    if dic[d]:\n        dic[d].sort()\n        x_max[d] = dic[d][-1][0]\n        x_min[d] = dic[d][0][0]\n        dic[d].sort(key = lambda x:x[1])\n        y_max[d] = dic[d][-1][1]\n        y_min[d] = dic[d][0][1]\ndef dx(t):\n    return max(x_max['U'], x_max['D'], x_max['R']+t, x_max['L']-t)-min(x_min['U'], x_min['D'], x_min['R']+t, x_min['L']-t)\ndef dy(t):\n    return max(y_max['U']+t, y_max['D']-t, y_max['R'], y_max['L'])-min(y_min['U']+t, y_min['D']-t, y_min['R'], y_min['L'])\ndef f(t):\n    if t<0:\n        return inf\n    return dx(t)*dy(t)\n\nxopt = fmin(f, x0 = 10**8, ftol = 10**-9, disp = False)\nprint((f(xopt[0])))\n\n\n\n\n\n\n\n\n\n\n\n", "inf = float(\"inf\")\nN = int(input())\nif N==1:\n    print((0))\n    return\nlr = inf\nll = inf\nrr = -inf\nrl = -inf\nud = -inf\nuu = -inf\ndd = inf\ndu = inf\nl_stop = inf\nr_stop = -inf\nu_stop = -inf\nd_stop = inf\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n    if d==\"R\":\n        lr = min(lr, x)\n        rr = max(rr, x)\n    elif d==\"L\":\n        rl = max(rl, x)\n        ll = min(ll, x)\n    elif d==\"U\":\n        du = min(du, y)\n        uu = max(uu, y)\n    else:\n        ud = max(ud, y)\n        dd = min(dd, y)\n    if d==\"R\" or d==\"L\":\n        u_stop = max(u_stop, y)\n        d_stop = min(d_stop, y)\n    else:\n        l_stop = min(l_stop, x)\n        r_stop = max(r_stop, x)\n\n\ndef f(t):\n    r = max(r_stop, rr+t, rl-t)\n    l = min(l_stop, ll-t, lr+t)\n    u = max(u_stop, uu+t, ud-t)\n    d = min(d_stop, dd-t, du+t)\n    return (r-l) * (u-d)\n#print(f(1))\n\nhigh = 10**8\nhigh = float(high)\nlow = 0.0\nwhile high - low > 0.000001:\n    #print(high, low)\n    mid_left = high/3+low*2/3\n    mid_right = high*2/3+low/3\n    if f(mid_left) >= f(mid_right):\n        low = mid_left\n    else:\n        high = mid_right\nprint((f(round(high, 3))))\n", "import sys\ninput = sys.stdin.readline\n\nINF = 10**18\n\nN = int(input())\nD = []\nU = []\nL = []\nR = []\nUD = []\nLR = []\nfor _ in range(N):\n    str_x, str_y, d = map(str, input().rstrip().split())\n    x = int(str_x)\n    y = int(str_y)\n    if d == \"U\":\n        U.append(y)\n        UD.append(x)\n    elif d == \"D\":\n        D.append(y)\n        UD.append(x)\n    elif d == \"L\":\n        L.append(x)\n        LR.append(y)\n    else:\n        R.append(x)\n        LR.append(y)\n\nUD.sort()\nLR.sort()\nU.sort()\nD.sort()\nL.sort()\nR.sort()\n\nT = [0]\nif L and R:\n    T.append((L[0]-R[0])/2)\n    T.append((L[-1]-R[-1])/2)\nif L and UD:\n    T.append(L[0]-UD[0])\n    T.append(L[-1]-UD[-1])\nif R and UD:\n    T.append(UD[0]-R[0])\n    T.append(UD[-1]-R[-1])\nif U and D:\n    T.append((D[0]-U[0])/2)\n    T.append((D[-1]-U[-1])/2)\nif U and LR:\n    T.append(-U[0]+LR[0])\n    T.append(-U[-1]+LR[-1])\nif D and LR:\n    T.append(-LR[0]+D[0])\n    T.append(-LR[-1]+D[-1])\n\nans = INF\nfor t in T:\n    if t < 0: continue\n    l = INF\n    r = -INF\n    d = INF\n    u = -INF\n    if L:\n        l = min(l, L[0]-t)\n        r = max(r, L[-1]-t)\n    if R:\n        l = min(l, R[0]+t)\n        r = max(r, R[-1]+t)\n    if U:\n        d = min(d, U[0]+t)\n        u = max(u, U[-1]+t)\n    if D:\n        d = min(d, D[0]-t)\n        u = max(u, D[-1]-t)\n    if LR:\n        d = min(d, LR[0])\n        u = max(u, LR[-1])\n    if UD:\n        l = min(l, UD[0])\n        r = max(r, UD[-1])\n    ans = min(ans, (r-l)*(u-d))\n\nprint(ans)", "import sys\n\n\ndef check(t):\n    maxx = max(ud_maxx, r_maxx + t, l_maxx - t)\n    minx = min(ud_minx, r_minx + t, l_minx - t)\n    maxy = max(lr_maxy, u_maxy + t, d_maxy - t)\n    miny = min(lr_miny, u_miny + t, d_miny - t)\n    return (maxx - minx) * (maxy - miny)\n\n\nn = int(input())\nlr_maxy, lr_miny, ud_maxx, ud_minx = -1e9, 1e9, -1e9, 1e9\nl_maxx, l_minx, r_maxx, r_minx = -1e9, 1e9, -1e9, 1e9\nu_maxy, u_miny, d_maxy, d_miny = -1e9, 1e9, -1e9, 1e9\nfor line in sys.stdin:\n    x, y, d = line.rstrip().split()\n    x, y = int(x), int(y)\n    if d == 'L':\n        lr_maxy = max(lr_maxy, y)\n        lr_miny = min(lr_miny, y)\n        l_maxx = max(l_maxx, x)\n        l_minx = min(l_minx, x)\n    elif d == 'R':\n        lr_maxy = max(lr_maxy, y)\n        lr_miny = min(lr_miny, y)\n        r_maxx = max(r_maxx, x)\n        r_minx = min(r_minx, x)\n    elif d == 'U':\n        ud_maxx = max(ud_maxx, x)\n        ud_minx = min(ud_minx, x)\n        u_maxy = max(u_maxy, y)\n        u_miny = min(u_miny, y)\n    else:\n        ud_maxx = max(ud_maxx, x)\n        ud_minx = min(ud_minx, x)\n        d_maxy = max(d_maxy, y)\n        d_miny = min(d_miny, y)\n\ninflections = {0}\ninflections.add(max(0, l_maxx - ud_maxx))\ninflections.add(max(0, (l_maxx - r_maxx) / 2))\ninflections.add(max(0, ud_maxx - r_maxx))\ninflections.add(max(0, l_minx - ud_minx))\ninflections.add(max(0, (l_minx - r_minx) / 2))\ninflections.add(max(0, ud_minx - r_minx))\n\ninflections.add(max(0, d_maxy - lr_maxy))\ninflections.add(max(0, (d_maxy - u_maxy) / 2))\ninflections.add(max(0, lr_maxy - u_maxy))\ninflections.add(max(0, d_miny - lr_miny))\ninflections.add(max(0, (d_miny - u_miny) / 2))\ninflections.add(max(0, lr_miny - u_miny))\n\nprint((min(list(map(check, inflections)))))\n", "N = int(input())\nlm = [float(\"INF\")]*3\nrm = [-float(\"INF\")]*3\num = [-float(\"INF\")]*3\ndm = [float(\"INF\")]*3\n\nfor i in range(N):\n    x,y,d = input().split()\n    x = int(x)\n    y = int(y)\n    if d == \"L\":\n        um[1] = max(um[1],y)\n        dm[1] = min(dm[1],y)\n        lm[2] = min(lm[2],x)\n        rm[0] = max(rm[0],x)\n    if d == \"R\":\n        um[1] = max(um[1],y)\n        dm[1] = min(dm[1],y)\n        lm[0] = min(lm[0],x)\n        rm[2] = max(rm[2],x)\n    if d == \"U\":\n        um[2] = max(um[2],y)\n        dm[0] = min(dm[0],y)\n        lm[1] = min(lm[1],x)\n        rm[1] = max(rm[1],x)\n    if d == \"D\":\n        um[0] = max(um[0],y)\n        dm[2] = min(dm[2],y)\n        lm[1] = min(lm[1],x)\n        rm[1] = max(rm[1],x)\n\ntime = [0]\n\ndef calc(t):\n    x = max(rm[1],rm[0]-t,rm[2]+t) -min(lm[1],lm[0]+t,lm[2]-t)\n    y = max(um[1],um[0]-t,um[2]+t) -min(dm[1],dm[0]+t,dm[2]-t)\n    return x*y\n\nfor i in range(3):\n    for j in range(i):\n        t = (lm[i]-lm[j])/(i-j)\n        if t > 0:\n            time.append(t)\n        t = (dm[i]-dm[j])/(i-j)\n        if t > 0:\n            time.append(t)\n        t = (rm[j]-rm[i])/(i-j)\n        if t > 0:\n            time.append(t)\n        t = (um[j]-um[i])/(i-j)\n        if t > 0:\n            time.append(t)\n\nans = float(\"INF\")\nfor t in time:\n    ans = min(ans,calc(t))\nprint(ans)", "from collections import defaultdict\nN=int(input())\n\nxlist,ylist=[],[]\nfor i in range(N):\n  xs,ys,d=input().split()\n  x=int(xs)\n  y=int(ys)\n  if d==\"L\":\n    xlist.append((x,-1))\n    ylist.append((y,0))\n  elif d==\"R\":\n    xlist.append((x,1))\n    ylist.append((y,0))\n  elif d==\"U\":\n    xlist.append((x,0))\n    ylist.append((y,1))\n  else:\n    xlist.append((x,0))\n    ylist.append((y,-1))\n#print(xlist,ylist)\n\nxdic=defaultdict(set)\nfor x,d in xlist:\n  xdic[d].add(x)\n#print(xdic)\nxlist2=[]\nfor d in [-1,0,1]:\n  if len(xdic[d]):\n    min_d=min(xdic[d])\n    max_d=max(xdic[d])\n    xlist2.append((min_d,d))\n    xlist2.append((max_d,d))\n  \nydic=defaultdict(set)\nfor y,d in ylist:\n  ydic[d].add(y)\n#print(ydic)\nylist2=[]\nfor d in [-1,0,1]:\n  if len(ydic[d]):\n    min_d=min(ydic[d])    \n    max_d=max(ydic[d])\n    ylist2.append((min_d,d))\n    ylist2.append((max_d,d))\n#print(xlist2,ylist2)\n\ndef cand_time(plist):\n  ret=set()\n  for i in range(len(plist)):\n    p1,d1=plist[i]\n    for j in range(i+1,len(plist)):\n      p2,d2=plist[j]\n      if d1==d2:\n        continue\n        \n      if d1==-1:\n        if d2==0:\n          t=p1-p2\n        else:\n          t=(p1-p2)/2\n      elif d1==0:\n        if d2==-1:\n          t=p2-p1\n        else:\n          t=p1-p2\n      else:\n        if d2==-1:\n          t=(p2-p1)/2\n        else:\n          t=p2-p1\n       \n      if t>0:\n        ret.add(t)\n  return ret\n\ncand_time_x=cand_time(xlist2)\ncand_time_y=cand_time(ylist2)\n#print(cand_time_x,cand_time_y)\ncand_t=[0]+list(cand_time_x)+list(cand_time_y)\n#print(cand_t)\n\ndef get_pos(pd,t):\n  p,d=pd\n  return p+d*t\n\nanswer=float(\"inf\")\nfor t in cand_t:\n  pos_min_x=float(\"inf\")\n  pos_max_x=-float(\"inf\")\n  for x2 in xlist2:\n    pos_min_x=min(pos_min_x,get_pos(x2,t))\n    pos_max_x=max(pos_max_x,get_pos(x2,t))\n    \n  pos_min_y=float(\"inf\")\n  pos_max_y=-float(\"inf\")\n  for y2 in ylist2:\n    pos_min_y=min(pos_min_y,get_pos(y2,t))\n    pos_max_y=max(pos_max_y,get_pos(y2,t))\n\n  #print(t,pos_min_x,pos_max_x,pos_min_y,pos_max_y)\n  t_ans=abs(pos_max_x-pos_min_x)*abs(pos_max_y-pos_min_y)\n  if answer>=t_ans:\n    answer=t_ans\n    #print(answer,t,abs(pos_max_x-pos_min_x),abs(pos_max_y-pos_min_y))\n  \nprint(answer)", "import itertools\nN = int(input())\nLX, LY = [], []\nRX, RY = [], []\nDX, DY = [], []\nUX, UY = [], []\n\nfor _ in range(N):\n  x,y,d = input().split()\n  x,y = int(x), int(y)\n  if d == 'L':\n    LX.append(x)\n    LY.append(y)\n  elif d == 'R':\n    RX.append(x)\n    RY.append(y)\n  elif d == 'U':\n    UX.append(x)\n    UY.append(y)\n  else:\n    DX.append(x)\n    DY.append(y)\n\nINF = 10**18\nfixed_x = [min(UX + DX + [INF]), max(UX + DX + [-INF])]\nfixed_y = [min(LY + RY + [INF]), max(LY + RY + [-INF])]\n\nR_x = [min(RX + [INF]), max(RX + [-INF])]\nL_x = [min(LX + [INF]), max(LX + [-INF])]\nU_y = [min(UY + [INF]), max(UY + [-INF])]\nD_y = [min(DY + [INF]), max(DY + [-INF])]\n\n\n# 2\u70b9\u304c\u885d\u7a81\u3059\u308b\u6642\u523b\u3092\u9664\u3051\u30701\u6b21\u95a2\u6570\nT = [0]\n\nfor x1,x2 in itertools.product(L_x, R_x):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append((x1 - x2) / 2)\nfor x1,x2 in itertools.product(L_x, fixed_x):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append(x1 - x2)\nfor x1,x2 in itertools.product(R_x, fixed_x):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append(x2 - x1)\n  \nfor x1,x2 in itertools.product(D_y, U_y):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append((x1 - x2) / 2)\nfor x1,x2 in itertools.product(D_y, fixed_y):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append(x1 - x2)\nfor x1,x2 in itertools.product(U_y, fixed_y):\n  if x1 in [-INF, INF] or x2 in [-INF, INF]:\n    continue\n  T.append(x2 - x1)\n  \nT = sorted(set(t for t in T if t >= 0))\nT.append(10 ** 9)\n\ndef calc_x(t):\n  # t\u79d2\u5f8c\u306e\u6a2a\u5e45\n  right = fixed_x[1]\n  left = fixed_x[0]\n  for x in [R_x[1]+t, L_x[1]-t]:\n    if right < x:\n      right = x\n  for x in [R_x[0]+t, L_x[0]-t]:\n    if left > x:\n      left = x\n  return right - left\n\ndef calc_y(t):\n  # t\u79d2\u5f8c\u306e\u6a2a\u5e45\n  right = fixed_y[1]\n  left = fixed_y[0]\n  for y in [U_y[1]+t, D_y[1]-t]:\n    if right < y:\n      right = y\n  for y in [U_y[0]+t, D_y[0]-t]:\n    if left > y:\n      left = y\n  return right - left\n\ndef F(x1,x2,y1,y2):\n  # x \u306f x1\u304b\u3089x2\u306b\u5411\u304b\u30461\u6b21\u95a2\u6570\n  # y \u306f y1\u304b\u3089y2\u306b\u5411\u304b\u30461\u6b21\u95a2\u6570\n  # t in [0,1] \u3067\u95a2\u6570\u3092\u4f5c\u308b\n  # x = (x2-x1)t + x1\n  # y = (y2-y1)t + y1\n  p,q,r,s = x2-x1, x1, y2-y1, y1\n  a,b,c = p*r, p*s + q*r, q*s\n  # f(t) = at^2 + bt + c\n  if a <= 0:\n    # \u76f4\u7dda or \u4e0a\u306b\u51f8\n    return min(x1*y1, x2*y2)\n  t0 = -b/(2*a)\n  if t0 < 0 or t0 > 1:\n    return min(x1*y1, x2*y2)\n  return min(a*t0*t0 + b*t0 + c, a+b+c, c)\n  \nL = len(T)\nX = [calc_x(t) for t in T]\nY = [calc_y(t) for t in T]\n\nanswer = 10 ** 18\n\nfor i in range(L-1):\n  x1, x2 = X[i], X[i+1]\n  y1, y2 = Y[i], Y[i+1]\n  s = F(x1,x2,y1,y2)\n  if answer > s:\n    answer = s\n\nprint(answer)", "n = int(input())\nxyd = [input().split() for _ in range(n)]\n\n\nx_max_RL_ = [-2e8] * 3\nx_min_RL_ = [2e8] * 3\ny_max_UD_ = [-2e8] * 3\ny_min_UD_ = [2e8] * 3\n\nfor x, y, d in xyd:\n    x = int(x)\n    y = int(y)\n\n    if d == \"R\":\n        ho, ve = 2, 1\n    elif d == \"L\":\n        ho, ve = 0, 1\n    elif d == \"U\":\n        ho, ve = 1, 2\n    else:  # d == \"D\"\n        ho, ve = 1, 0\n    x_max_RL_[ho] = max(x_max_RL_[ho], x)\n    x_min_RL_[ho] = min(x_min_RL_[ho], x)\n    y_max_UD_[ve] = max(y_max_UD_[ve], y)\n    y_min_UD_[ve] = min(y_min_UD_[ve], y)\n\nkouho_time = set([0])\n\nfor _max_min in [x_max_RL_, x_min_RL_, y_max_UD_, y_min_UD_]:\n    for i in range(0, 3):\n        if abs(_max_min[i]) <= 1e8:\n            for j in range(i + 1, 3):\n                if abs(_max_min[j]) <= 1e8:\n                    cross = (_max_min[i] - _max_min[j]) / (j - i)\n                    if cross > 0:\n                        kouho_time.add(cross)\n\n\nans = 4e16\nfor t in kouho_time:\n    x_max = max(\n        x_max_RL_[i] + t * (i - 1) for i in range(3) if abs(x_max_RL_[i]) <= 1e8\n    )\n    x_min = min(\n        x_min_RL_[i] + t * (i - 1) for i in range(3) if abs(x_min_RL_[i]) <= 1e8\n    )\n    y_max = max(\n        y_max_UD_[i] + t * (i - 1) for i in range(3) if abs(y_max_UD_[i]) <= 1e8\n    )\n    y_min = min(\n        y_min_UD_[i] + t * (i - 1) for i in range(3) if abs(y_min_UD_[i]) <= 1e8\n    )\n\n    ans = min(ans, (x_max - x_min) * (y_max - y_min))\n\nprint(ans)\n", "def analyze(points, left_static, right_static):\n    \"\"\"\n    (x0, +1 or -1) in points\n    \"\"\"\n\n    rightest_neg = -10**9\n    leftest_neg = 10**9\n    rightest_pos = -10**9\n    leftest_pos = 10**9\n    for x, d in points:\n        if d == 1:\n            rightest_pos = max(rightest_pos, x)\n            leftest_pos = min(leftest_pos, x)\n        else:\n            rightest_neg = max(rightest_neg, x)\n            leftest_neg = min(leftest_neg, x)\n\n\n    max_t1 = rightest_neg - right_static\n    max_t2 = right_static - rightest_pos\n    if max_t1 > max_t2:\n        max_t1 = max_t2 = (rightest_neg-rightest_pos)/2\n    max_t1 = max(0, max_t1)\n    max_t2 = max(0, max_t2)\n    max_x0 = max(rightest_pos, rightest_neg, right_static)\n    max_x1 = max(rightest_pos + max_t1, rightest_neg - max_t1, right_static)\n    def get_xmax(t):\n        if t > max_t2:\n            return max_x1 + t-max_t2\n        elif t > max_t1:\n            return max_x1\n        else:\n            return max_x0 - t\n\n    min_t1 = left_static - leftest_pos\n    min_t2 = leftest_neg - left_static\n    if min_t1 > min_t2:\n        min_t1 = min_t2 = (leftest_neg - leftest_pos)/2\n    min_t1 = max(0, min_t1)\n    min_t2 = max(0, min_t2)\n    min_x0 = min(leftest_pos, leftest_neg, left_static)\n    min_x1 = min(leftest_pos + min_t1, leftest_neg - min_t1, left_static)\n\n    def get_xmin(t):\n        if t > min_t2:\n            return min_x1 - t + min_t2\n        elif t > min_t1:\n            return min_x1\n        else:\n            return min_x0 + t\n\n    T = sorted((max_t1, max_t2, min_t1, min_t2))\n    D = [get_xmax(t)-get_xmin(t) for t in T]\n    return T,D\n\n\n\nN = int(input())\n\nconv = {'R':0,'U':1,'L':2,'D':3}\npoints = [(lambda i: (int(i[0]), int(i[1]), conv[i[2]]))(input().split()) for _ in range(N)]\n\n\nxt, xd = analyze([(x, 1 if d == 0 else -1) for x,y,d in points if d%2==0],\n                    min((x for x,y,d in points if d%2==1), default=10**9),\n                    max((x for x,y,d in points if d%2==1), default=-10**9))\n\nyt, yd = analyze([(y, 1 if d == 1 else -1) for x,y,d in points if d%2==1],\n                    min((y for x,y,d in points if d%2==0), default=10**9),\n                    max((y for x,y,d in points if d%2==0), default=-10**9))\n\ndef get_w(t):\n    a,b,c,d = xt\n\n    if t < a:\n        return -2, xd[0] + 2*a\n    elif t < b:\n        return -1, xd[0] + a\n    elif t < c:\n        return 0, xd[1]\n    elif t < d:\n        return 1, xd[2] - c\n    else:\n        return 2, xd[3] - 2*d\n\ndef get_h(t):\n    a,b,c,d = yt\n\n    if t < a:\n        return -2, yd[0] + 2*a\n    elif t < b:\n        return -1, yd[0] + a\n    elif t < c:\n        return 0, yd[1]\n    elif t < d:\n        return 1, yd[2] - c\n    else:\n        return 2, yd[3] - 2*d\n\nT = sorted(xt+yt)\n\ndef it():\n    ne = iter(T)\n    next(ne)\n    for a,b in zip(T,ne):\n        t = (a+b)/2\n\n        wa, wb = get_w(t)\n        ha, hb = get_h(t)\n        if wa*ha > 0 and a < -(wb*ha+wa*hb)/(2*wa*ha) < b:\n            t = -(wb*ha+wa*hb)/(2*wa*ha)\n            yield ((wa*t+wb)*(ha*t+hb), t)\n        else:\n            yield ((wa*a+wb)*(ha*a+hb), a)\n            yield ((wa*b+wb)*(ha*b+hb), b)\n\nprint(min(it())[0])", "###############################################################################\n\nfrom sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\nfrom collections import defaultdict\nimport math\n\n\nmod = 1\n\n\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\n\n\ndef intina():\n    return [int(i) for i in input().split()]\n\n\ndef intinl(count):\n    return [intin() for _ in range(count)]\n\n\ndef modadd(x, y):\n    nonlocal mod\n    return (x + y) % mod\n\n\ndef modmlt(x, y):\n    nonlocal mod\n    return (x * y) % mod\n\n\ndef mod_inv(x):\n    # available only when mod is prime\n    nonlocal mod\n    return pow(x, mod - 2, mod)\n\n\ndef gcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\n\n\ndef combination(x, y):\n    assert(x >= y)\n\n    ret = math.factorial(x)\n    ret = ret // (math.factorial(x - y) * math.factorial(y))\n\n    return ret\n\n\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\n\n\ndef get_factors(x):\n    retlist = []\n    for i in range(2, int(x**0.5) + 3):\n        while x % i == 0:\n            retlist.append(i)\n            x = x // i\n    retlist.append(x)\n    return retlist\n\n\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\n\n\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n\n    max_distance = -1\n    max_v = None\n    for v, distance in list(distance_list.items()):\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n\n    return (max_distance, max_v)\n\n\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.root(self.parent[i])\n        return self.parent[i]\n\n    def unite(self, i, j):\n        rooti = self.root(i)\n        rootj = self.root(j)\n        if rooti == rootj:\n            return\n        if rooti < rootj:\n            self.parent[rootj] = rooti\n        else:\n            self.parent[rooti] = rootj\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n\n###############################################################################\n\n\ndef find_edge(plus, nt, minus):\n    ret = []\n    if plus is not None and nt is not None and plus <= nt:\n        ret.append(nt - plus)\n    if minus is not None and nt is not None and minus >= nt:\n        ret.append(minus - nt)\n    if plus is not None and minus is not None and plus <= minus:\n        ret.append((minus - plus) / 2)\n    return ret\n\n\ndef calc_coord(t, plus, nt, minus, ismax=False):\n    check = []\n    if plus is not None:\n        check.append(plus + t)\n    if nt is not None:\n        check.append(nt)\n    if minus is not None:\n        check.append(minus - t)\n    if ismax:\n        return max(check)\n    return min(check)\n\n\ndef main():\n    n = intin()\n    xydlist = []\n    for _ in range(n):\n        line = input()\n        line = line.split()\n        x = int(line[0])\n        y = int(line[1])\n        d = line[2]\n        xydlist.append((x, y, d))\n\n    xplusmax = None\n    xminusmax = None\n    xntmax = None\n\n    xplusmin = None\n    xminusmin = None\n    xntmin = None\n\n    yplusmax = None\n    yminusmax = None\n    yntmax = None\n\n    yplusmin = None\n    yminusmin = None\n    yntmin = None\n\n    for x, y, d in xydlist:\n        if d == 'R':\n            xplusmax = x if xplusmax is None else max(xplusmax, x)\n            yntmax = y if yntmax is None else max(yntmax, y)\n            xplusmin = x if xplusmin is None else min(xplusmin, x)\n            yntmin = y if yntmin is None else min(yntmin, y)\n        if d == 'L':\n            xminusmax = x if xminusmax is None else max(xminusmax, x)\n            yntmax = y if yntmax is None else max(yntmax, y)\n            xminusmin = x if xminusmin is None else min(xminusmin, x)\n            yntmin = y if yntmin is None else min(yntmin, y)\n        if d == 'U':\n            xntmax = x if xntmax is None else max(xntmax, x)\n            yplusmax = y if yplusmax is None else max(yplusmax, y)\n            xntmin = x if xntmin is None else min(xntmin, x)\n            yplusmin = y if yplusmin is None else min(yplusmin, y)\n        if d == 'D':\n            xntmax = x if xntmax is None else max(xntmax, x)\n            yminusmax = y if yminusmax is None else max(yminusmax, y)\n            xntmin = x if xntmin is None else min(xntmin, x)\n            yminusmin = y if yminusmin is None else min(yminusmin, y)\n\n    tlist = [0]\n    tlist.extend(find_edge(xplusmax, xntmax, xminusmax))\n    tlist.extend(find_edge(xplusmin, xntmin, xminusmin))\n    tlist.extend(find_edge(yplusmax, yntmax, yminusmax))\n    tlist.extend(find_edge(yplusmin, yntmin, yminusmin))\n\n    tlist = list(set(tlist))\n    ans = float('inf')\n\n    for t in tlist:\n        x_max = calc_coord(t, xplusmax, xntmax, xminusmax, ismax=True)\n        x_min = calc_coord(t, xplusmin, xntmin, xminusmin, ismax=False)\n        y_max = calc_coord(t, yplusmax, yntmax, yminusmax, ismax=True)\n        y_min = calc_coord(t, yplusmin, yntmin, yminusmin, ismax=False)\n        ans = min(ans, (x_max - x_min) * (y_max - y_min))\n\n    if ans == float('inf'):\n        print((0))\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "dirs = {'R': (1, 0), 'L': (-1, 0), 'U': (0, 1), 'D': (0, -1)}\n\nN = int(input())\nP = {d: [] for d in dirs}\nfor i in range(N):\n    x, y, d = input().split()\n    x, y = list(map(int, (x, y)))\n    P[d].append((x, y))\n\ndef fst(x): return x[0]\ndef snd(x): return x[1]\ninf = float('inf')\n\n# \u65b9\u5411\u5225\u306eX\u30fbY\u306e\u6700\u5927\u6700\u5c0f\nS = {d: {'xmin': min(list(map(fst, P[d])), default= inf),\n         'xmax': max(list(map(fst, P[d])), default=-inf),\n         'ymin': min(list(map(snd, P[d])), default= inf),\n         'ymax': max(list(map(snd, P[d])), default=-inf) }\n     for d in dirs}\n\nvars = ('xmax', 'xmin', 'ymax', 'ymin')\nmaxmin = {'max': max, 'min': min}\ndirs = {d: {'x': dirs[d][0], 'y': dirs[d][1]} for d in dirs}\n\n# S[L][xmax] - t1 == max(S[U][xmax], S[D][xmax])  t < t1 -> S[UD] < S[L]\n# S[R][xmax] + t2 == max(S[U][xmax], S[D][xmax])  t < t2 -> S[R]  < S[UD]\n# S[L][xmax] - t3 == S[R][xmax] + t3              t < t3 -> S[R]  < S[L]\n\n# \u5909\u5316\u304c\u3042\u308b\u6642\u523b\u306e\u96c6\u5408\nT = set()\nT.add(0)\nfor v in vars:\n    u, d, c1, c2 = ('R', 'L', 'U', 'D') if v.startswith('x') else \\\n                   ('U', 'D', 'R', 'L')\n    C  = maxmin[v[-3:]](S[c1][v], S[c2][v])\n    t1 =  S[d][v] - C\n    t2 = -S[u][v] + C\n    t3 = (S[d][v] - S[u][v]) / 2\n    T.update([t1, t2, t3])\n\nq = inf\nfor t in (t for t in T if 0 <= t and t != inf):\n    Q = {v: maxmin[v[-3:]](S[d][v] + t * dirs[d][v[0]] for d in dirs)\n         for v in vars}\n    q = min(q, (Q['xmax'] - Q['xmin']) * (Q['ymax'] - Q['ymin']))\n\nprint(q)\n", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nINF = 10**30\nn = int(input())\np = [input().split() for _ in range(n)]\n\n\"\"\"\n[0]: max or min / for\n[1]: max or min / against\n[2]: max or min / fixed\n\"\"\"\n\nr = [-INF, -INF, -INF]\nl = [INF, INF, INF]\nu = [-INF, -INF, -INF]\nd = [INF, INF, INF]\n\nfor x, y, t in p:\n\tx, y = int(x), int(y)\n\tif t == \"R\":\n\t\tr[0] = max(r[0], x)\n\t\tl[1] = min(l[1], x)\n\t\tu[2] = max(u[2], y)\n\t\td[2] = min(d[2], y)\n\telif t == \"L\":\n\t\tr[1] = max(r[1], x)\n\t\tl[0] = min(l[0], x)\n\t\tu[2] = max(u[2], y)\n\t\td[2] = min(d[2], y)\n\telif t == \"U\":\n\t\tr[2] = max(r[2], x)\n\t\tl[2] = min(l[2], x)\n\t\tu[0] = max(u[0], y)\n\t\td[1] = min(d[1], y)\n\telse:\n\t\tr[2] = max(r[2], x)\n\t\tl[2] = min(l[2], x)\n\t\tu[1] = max(u[1], y)\n\t\td[0] = min(d[0], y)\n\n#print(r)\n#print(l)\n#print(u)\n#print(d)\n\ntimings = set([0])\n\nif r[0] <= r[1] <= r[2]:\n\ttimings.add(abs(r[2]-r[0]))\nelif r[0] <= r[2] <= r[1]:\n\ttimings.add(abs(r[1]-r[0])/2)\n\ttimings.add(abs(r[2]-r[0]))\n\ttimings.add(abs(r[1]-r[2]))\nelif r[1] <= r[0] <= r[2]:\n\ttimings.add(abs(r[2]-r[0]))\nelif r[2] <= r[0] <= r[1]:\n\ttimings.add(abs(r[1]-r[0])/2)\n\nif l[0] >= l[1] >= l[2]:\n\ttimings.add(abs(l[2]-l[0]))\nelif l[0] >= l[2] >= l[1]:\n\ttimings.add(abs(l[1]-l[0])/2)\n\ttimings.add(abs(l[2]-l[0]))\n\ttimings.add(abs(l[1]-l[2]))\nelif l[1] >= l[0] >= l[2]:\n\ttimings.add(abs(l[2]-l[0]))\nelif l[2] >= l[0] >= l[1]:\n\ttimings.add(abs(l[1]-l[0])/2)\n\nif u[0] <= u[1] <= u[2]:\n\ttimings.add(abs(u[2]-u[0]))\nelif u[0] <= u[2] <= u[1]:\n\ttimings.add(abs(u[1]-u[0])/2)\n\ttimings.add(abs(u[2]-u[0]))\n\ttimings.add(abs(u[1]-u[2]))\nelif u[1] <= u[0] <= u[2]:\n\ttimings.add(abs(u[2]-u[0]))\nelif u[2] <= u[0] <= u[1]:\n\ttimings.add(abs(u[1]-u[0])/2)\n\nif d[0] >= d[1] >= d[2]:\n\ttimings.add(abs(d[2]-d[0]))\nelif d[0] >= d[2] >= d[1]:\n\ttimings.add(abs(d[1]-d[0])/2)\n\ttimings.add(abs(d[2]-d[0]))\n\ttimings.add(abs(d[1]-d[2]))\nelif d[1] >= d[0] >= d[2]:\n\ttimings.add(abs(d[2]-d[0]))\nelif d[2] >= d[0] >= d[1]:\n\ttimings.add(abs(d[1]-d[0])/2)\n\n#print(timings)\nans = 10**30\nfor t in timings:\n\tif t > 10**10:\n\t\tcontinue\n\tR, L, U, D = -INF, INF, -INF, INF\n\tfor x, y, di in p:\n\t\tif di == \"R\":\n\t\t\tx, y = int(x)+t, int(y)\n\t\telif di == \"L\":\n\t\t\tx, y = int(x)-t, int(y)\n\t\telif di == \"U\":\n\t\t\tx, y = int(x), int(y)+t\n\t\telse:\n\t\t\tx, y = int(x), int(y)-t\n\n\t\tR = max(R, x)\n\t\tL = min(L, x)\n\t\tU = max(U, y)\n\t\tD = min(D, y)\n\n\tans = min(ans, (R-L)*(U-D))\n\nprint(ans)", "import queue\n\n\"\"\"\nN = int(input())\n#S = input()\n# (N,M) = (int(i) for i in input().split(\" \"))\n# A = [int(i) for i in input().split()]\nA = []\nfor i in range(N):\n\tA.append(int(input()))\n\nprint(A)\n\n\"\"\"\ndef s(time,maxX,minX,maxY,minY,maxU,minU,maxD,minD,maxL,minL,maxR,minR):\n\tmxx = []\n\tmnx = []\n\tmxy = []\n\tmny = []\n\tif maxX != None:\n\t\tmxx.append(maxX)\n\t\tmnx.append(minX)\n\tif maxY != None:\n\t\tmxy.append(maxY)\n\t\tmny.append(minY)\n\tif maxR != None:\n\t\tmxx.append(maxR+time)\n\t\tmnx.append(minR+time)\n\tif maxL != None:\n\t\tmxx.append(maxL-time)\n\t\tmnx.append(minL-time)\n\tif maxU != None:\n\t\tmxy.append(maxU+time)\n\t\tmny.append(minU+time)\n\tif maxD != None:\n\t\tmxy.append(maxD-time)\n\t\tmny.append(minD-time)\n\tmxx = max(mxx)\n\tmnx = min(mnx)\n\tmxy = max(mxy)\n\tmny = min(mny)\n\treturn (mxx-mnx)*(mxy-mny)\n\nN = int(input())\n\nE = [[t if i==2 else int(t) for i,t in enumerate(input().split(\" \"))]for _ in range(N)]\nU = [d[0:2] for d in E if d[2]==\"U\"]\nD = [d[0:2] for d in E if d[2]==\"D\"]\nL = [d[0:2] for d in E if d[2]==\"L\"]\nR = [d[0:2] for d in E if d[2]==\"R\"]\n\nif len(U+D)>0:\n\tmaxX = max(U+D,key=lambda x:x[0])[0]\n\tminX = min(U+D,key=lambda x:x[0])[0]\nelse:\n\tmaxX=None\n\tminX=None\n\nif len(L+R)>0:\n\tmaxY = max(L+R,key=lambda x:x[1])[1]\n\tminY = min(L+R,key=lambda x:x[1])[1]\nelse:\n\tmaxY=None\n\tminY=None\n\nif len(U)>0:\n\tmaxU = max(U,key=lambda x:x[1])[1]\n\tminU = min(U,key=lambda x:x[1])[1]\nelse:\n\tmaxU=None\n\tminU=None\n\nif len(D)>0:\n\tmaxD = max(D,key=lambda x:x[1])[1]\n\tminD = min(D,key=lambda x:x[1])[1]\nelse:\n\tmaxD=None\n\tminD=None\n\nif len(L)>0:\n\tmaxL = max(L,key=lambda x:x[0])[0]\n\tminL = min(L,key=lambda x:x[0])[0]\nelse:\n\tmaxL=None\n\tminL=None\n\nif len(R)>0:\n\tmaxR = max(R,key=lambda x:x[0])[0]\n\tminR = min(R,key=lambda x:x[0])[0]\nelse:\n\tmaxR=None\n\tminR=None\n\nwatch = [0]\nmin_ans = s(0,maxX,minX,maxY,minY,maxU,minU,maxD,minD,maxL,minL,maxR,minR)\n\nif maxU != None:\n\tif maxY != None:\n\t\tif minY > maxU:\n\t\t\twatch.append(minY-maxU)\n\t\tif minY > minU:\n\t\t\twatch.append(minY-minU)\n\t\tif maxY > maxU:\n\t\t\twatch.append(maxY-maxU)\n\t\tif maxY > minU:\n\t\t\twatch.append(maxY-minU)\n\tif maxD != None:\n\t\tif minD > maxU:\n\t\t\twatch.append((minD-maxU)/2)\n\t\tif maxD > maxU:\n\t\t\twatch.append((maxD-maxU)/2)\n\t\tif minD > minU:\n\t\t\twatch.append((minD-minU)/2)\n\t\tif maxD > minU:\n\t\t\twatch.append((maxD-minU)/2)\nif maxD != None:\n\tif maxY != None:\n\t\tif minY < maxD:\n\t\t\twatch.append(maxD-minY)\n\t\tif minY < minD:\n\t\t\twatch.append(minD-minY)\n\t\tif maxY < maxD:\n\t\t\twatch.append(maxD-maxY)\n\t\tif maxY < minD:\n\t\t\twatch.append(minD-maxY)\n\n\nif maxR != None:\n\tif maxX != None:\n\t\tif minX > maxR:\n\t\t\twatch.append(minX-maxR)\n\t\tif minX > minR:\n\t\t\twatch.append(minX-minR)\n\t\tif maxX > maxR:\n\t\t\twatch.append(maxX-maxR)\n\t\tif maxX > minR:\n\t\t\twatch.append(maxX-minR)\n\tif maxL != None:\n\t\tif minL > maxR:\n\t\t\twatch.append((minL-maxR)/2)\n\t\tif maxL > maxR:\n\t\t\twatch.append((maxL-maxR)/2)\n\t\tif minL > minR:\n\t\t\twatch.append((minL-minR)/2)\n\t\tif maxL > minR:\n\t\t\twatch.append((maxL-minR)/2)\nif maxL != None:\n\tif maxX != None:\n\t\tif minX < maxL:\n\t\t\twatch.append(maxL-minX)\n\t\tif minX < minL:\n\t\t\twatch.append(minL-minX)\n\t\tif maxX < maxL:\n\t\t\twatch.append(maxL-maxX)\n\t\tif maxX < minL:\n\t\t\twatch.append(minL-maxX)\n\nfor t in watch:\n\tp = s(t,maxX,minX,maxY,minY,maxU,minU,maxD,minD,maxL,minL,maxR,minR)\n\tif p < min_ans:\n\t\tmin_ans = p\n\nprint(min_ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "from scipy.optimize import fmin\nINF = 10**18\nn = int(input())\n# 0:static, 1:up, 2:down\nxpoints = [[] for _ in range(3)]\nypoints = [[] for _ in range(3)]\nfor i in range(n):\n    x, y, d = [item for item in input().split()]\n    x = int(x); y = int(y)\n    if d == \"R\":\n        ypoints[0].append(y)\n        xpoints[1].append(x)\n    elif d == \"L\":\n        ypoints[0].append(y)\n        xpoints[2].append(x)\n    elif d == \"U\":\n        xpoints[0].append(x)\n        ypoints[1].append(y)\n    elif d == \"D\":\n        xpoints[0].append(x)\n        ypoints[2].append(y)\nfor i in range(3):\n    xpoints[i].sort()\n    ypoints[i].sort()\n\ndef f(t):\n    if t < 0:\n        return INF \n    max_x = max_y = -INF\n    min_x = min_y = INF\n    for i, a in enumerate([0, t, -t]):\n        if not len(xpoints[i]) == 0:\n            max_x = max(max_x, xpoints[i][-1] + a)\n            min_x = min(min_x, xpoints[i][0] + a)\n        if not len(ypoints[i]) == 0:\n            max_y = max(max_y, ypoints[i][-1] + a)\n            min_y = min(min_y, ypoints[i][0] + a)\n    return (max_x - min_x) * (max_y - min_y)\n\nans = fmin(f, x0=10**8, ftol= 1e-9, disp=False)\nprint(f(ans[0]))", "N = int(input())\n\nPS = [[], [], [], []]\nS = \"RLUD\".index\n\nfor i in range(N):\n    x, y, d = input().split(); x = int(x); y = int(y)\n    PS[S(d)].append((x, y))\n\nT = [0]\nINF = 10**9\n\ndymin = INF; dymax = -INF\nP = []\nfor i in [0, 1]:\n    xmin = INF; xmax = -INF\n    for x, y in PS[i]:\n        dymin = min(dymin, y)\n        dymax = max(dymax, y)\n        xmin = min(xmin, x)\n        xmax = max(xmax, x)\n    P.append((xmin, xmax))\nfor x0 in P[0]:\n    for x1 in P[1]:\n        T.append(max(x1 - x0, 0) / 2.)\n\ndxmin = INF; dxmax = -INF\nQ = []\nfor i in [2, 3]:\n    ymin = INF; ymax = -INF\n    for x, y in PS[i]:\n        dxmin = min(dxmin, x)\n        dxmax = max(dxmax, x)\n        ymin = min(ymin, y)\n        ymax = max(ymax, y)\n    Q.append((ymin, ymax))\nfor y0 in Q[0]:\n    for y1 in Q[1]:\n        T.append(max(y1 - y0, 0) / 2.)\n\nfor x0 in [dxmin, dxmax]:\n    for x in P[0]:\n        T.append(max(x0 - x, 0))\n    for x in P[1]:\n        T.append(max(x - x0, 0))\nfor y0 in [dymin, dymax]:\n    for y in Q[0]:\n        T.append(max(y0 - y, 0))\n    for y in Q[1]:\n        T.append(max(y - y0, 0))\n\nans = 10**30\nfor t in T:\n    xmin = dxmin; xmax = dxmax\n    ymin = dymin; ymax = dymax\n\n    xi, xa = P[0]\n    if xi != INF:\n        xmin = min(xmin, xi+t)\n        xmax = max(xmax, xa+t)\n    xi, xa = P[1]\n    if xi != INF:\n        xmin = min(xmin, xi-t)\n        xmax = max(xmax, xa-t)\n    yi, ya = Q[0]\n    if yi != INF:\n        ymin = min(ymin, yi+t)\n        ymax = max(ymax, ya+t)\n    yi, ya = Q[1]\n    if yi != INF:\n        ymin = min(ymin, yi-t)\n        ymax = max(ymax, ya-t)\n    ans = min(ans, (xmax - xmin) * (ymax - ymin))\nprint(\"%.10f\" % ans)", "from scipy.optimize import fmin\n\nN = int(input())\n\nINF = 10 ** 18\n\nX, Y = [[],[],[]], [[],[],[]]\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n\n    if d == \"R\":\n        X[0].append(x)\n    elif d == \"L\":\n        X[1].append(x)\n    else:\n        X[2].append(x)\n\n    if d == \"U\":\n        Y[0].append(y)\n    elif d == \"D\":\n        Y[1].append(y)\n    else:\n        Y[2].append(y)\n\nfor i in range(3):\n    X[i] = [min(X[i] + [INF]), max(X[i] + [-INF])]\n    Y[i] = [min(Y[i] + [INF]), max(Y[i] + [-INF])]\n\ndef calc_area(t):\n    if t < 0:\n        return INF\n\n    x_l, x_r = INF, -INF\n    x_l, x_r = min(x_l, X[0][0] + i*t), max(x_r, X[0][1] + i*t)\n    x_l, x_r = min(x_l, X[1][0] - i*t), max(x_r, X[1][1] - i*t)\n    x_l, x_r = min(x_l, X[2][0]      ), max(x_r, X[2][1]      )\n\n    y_l, y_r = INF, -INF\n    y_l, y_r = min(y_l, Y[0][0] + i*t), max(y_r, Y[0][1] + i*t)\n    y_l, y_r = min(y_l, Y[1][0] - i*t), max(y_r, Y[1][1] - i*t)\n    y_l, y_r = min(y_l, Y[2][0]      ), max(y_r, Y[2][1]      )\n\n    return (x_r-x_l) * (y_r-y_l)\n    \nopt = fmin(calc_area, x0 = 10**8, ftol=10**(-10), disp=False)\nprint(calc_area(opt[0]))", "import itertools\nN = int(input())\nLX, LY = [], []\nRX, RY = [], []\nDX, DY = [], []\nUX, UY = [], []\n\nfor _ in range(N):\n  x,y,d = input().split()\n  x,y = int(x), int(y)\n  if d == 'L':\n    LX.append(x)\n    LY.append(y)\n  elif d == 'R':\n    RX.append(x)\n    RY.append(y)\n  elif d == 'U':\n    UX.append(x)\n    UY.append(y)\n  else:\n    DX.append(x)\n    DY.append(y)\n\nINF = 10**18\nfixed_x = [min(UX + DX + [INF]), max(UX + DX + [-INF])]\nfixed_y = [min(LY + RY + [INF]), max(LY + RY + [-INF])]\n\nR_x = [min(RX + [INF]), max(RX + [-INF])]\nL_x = [min(LX + [INF]), max(LX + [-INF])]\nU_y = [min(UY + [INF]), max(UY + [-INF])]\nD_y = [min(DY + [INF]), max(DY + [-INF])]\n\ndef calc_x(t):\n  # t\u79d2\u5f8c\u306e\u6a2a\u5e45\n  right = fixed_x[1]\n  left = fixed_x[0]\n  for x in [R_x[1]+t, L_x[1]-t]:\n    if right < x:\n      right = x\n  for x in [R_x[0]+t, L_x[0]-t]:\n    if left > x:\n      left = x\n  return right - left\n\ndef calc_y(t):\n  # t\u79d2\u5f8c\u306e\u6a2a\u5e45\n  right = fixed_y[1]\n  left = fixed_y[0]\n  for y in [U_y[1]+t, D_y[1]-t]:\n    if right < y:\n      right = y\n  for y in [U_y[0]+t, D_y[0]-t]:\n    if left > y:\n      left = y\n  return right - left\n\ndef area(t):\n  if t < 0:\n    return INF\n  return calc_x(t) * calc_y(t)\n\nfrom scipy.optimize import fmin\nxopt = fmin(area, x0 = 10**8, ftol = 10**-9, disp = False)\nanswer = area(xopt[0])\nprint(answer)", "\nn = int(input())\n\nx_fix_max = None\nx_fix_min = None\nx_inc_max = None\nx_inc_min = None\nx_dec_max = None\nx_dec_min = None\n\ny_fix_max = None\ny_fix_min = None\ny_inc_max = None\ny_inc_min = None\ny_dec_max = None\ny_dec_min = None\n\nfor i in range(n):\n    x, y, d = [a for a in input().split()]\n    if d == \"R\":\n        if x_inc_max is None or x_inc_max < int(x):\n            x_inc_max = int(x)\n        if x_inc_min is None or x_inc_min > int(x):\n            x_inc_min = int(x)\n        if y_fix_max is None or y_fix_max < int(y):\n            y_fix_max = int(y)\n        if y_fix_min is None or y_fix_min > int(y):\n            y_fix_min = int(y)\n    if d == \"L\":\n        if x_dec_max is None or x_dec_max < int(x):\n            x_dec_max = int(x)\n        if x_dec_min is None or x_dec_min > int(x):\n            x_dec_min = int(x)\n        if y_fix_max is None or y_fix_max < int(y):\n            y_fix_max = int(y)\n        if y_fix_min is None or y_fix_min > int(y):\n            y_fix_min = int(y)\n    if d == \"U\":\n        if y_inc_max is None or y_inc_max < int(y):\n            y_inc_max = int(y)\n        if y_inc_min is None or y_inc_min > int(y):\n            y_inc_min = int(y)\n        if x_fix_max is None or x_fix_max < int(x):\n            x_fix_max = int(x)\n        if x_fix_min is None or x_fix_min > int(x):\n            x_fix_min = int(x)\n    if d == \"D\":\n        if y_dec_max is None or y_dec_max < int(y):\n            y_dec_max = int(y)\n        if y_dec_min is None or y_dec_min > int(y):\n            y_dec_min = int(y)\n        if x_fix_max is None or x_fix_max < int(x):\n            x_fix_max = int(x)\n        if x_fix_min is None or x_fix_min > int(x):\n            x_fix_min = int(x)\n\nif x_inc_min is None:\n    x_inc_min = 10 ** 10\nif x_dec_min is None:\n    x_dec_min = 10 ** 10\nif x_fix_min is None:\n    x_fix_min = 10 ** 10\nif x_inc_max is None:\n    x_inc_max = -10 ** 10\nif x_dec_max is None:\n    x_dec_max = -10 ** 10\nif x_fix_max is None:\n    x_fix_max = -10 ** 10\nif y_inc_min is None:\n    y_inc_min = 10 ** 10\nif y_dec_min is None:\n    y_dec_min = 10 ** 10\nif y_fix_min is None:\n    y_fix_min = 10 ** 10\nif y_inc_max is None:\n    y_inc_max = -10 ** 10\nif y_dec_max is None:\n    y_dec_max = -10 ** 10\nif y_fix_max is None:\n    y_fix_max = -10 ** 10\n\nt_list = [0]\nt_list += [-x_inc_max + x_fix_max, x_dec_max - x_fix_max, (x_dec_max - x_inc_max) / 2]\nt_list += [-y_inc_max + y_fix_max, y_dec_max - y_fix_max, (y_dec_max - y_inc_max) / 2]\nt_list += [-x_inc_min + x_fix_min, x_dec_min - x_fix_min, (x_dec_min - x_inc_min) / 2]\nt_list += [-y_inc_min + y_fix_min, y_dec_min - y_fix_min, (y_dec_min - y_inc_min) / 2]\n\n\nmin_mult = None\nfor t in t_list:\n    if t < 0:\n        continue\n    x_max = max(x_inc_max + t, x_fix_max, x_dec_max - t)\n    x_min = min(x_inc_min + t, x_fix_min, x_dec_min - t)\n    y_max = max(y_inc_max + t, y_fix_max, y_dec_max - t)\n    y_min = min(y_inc_min + t, y_fix_min, y_dec_min - t)\n    mult = (x_max - x_min) * (y_max - y_min)\n    if min_mult is None or min_mult > mult:\n        min_mult = mult\nprint((str(min_mult)))\n", "from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\n\ndef want(n):\n\n    xmax = float(\"-inf\")\n    xmin = float(\"inf\")\n    ymax = float(\"-inf\")\n    ymin = float(\"inf\")\n\n    if L:\n        xmax = max(xmax,L_R - n)\n        xmin = min(xmin,L_L - n)\n        ymax = max(ymax,LR_U)\n        ymin = min(ymin,LR_D)\n\n    if R:\n        xmax = max(xmax,R_R + n)\n        xmin = min(xmin,R_L + n)\n        ymax = max(ymax,LR_U)\n        ymin = min(ymin,LR_D)\n\n    if D:\n        xmax = max(xmax,UD_R)\n        xmin = min(xmin,UD_L)\n        ymax = max(ymax,D_U - n)\n        ymin = min(ymin,D_D - n)\n\n    if U:\n        xmax = max(xmax,UD_R)\n        xmin = min(xmin,UD_L)\n        ymax = max(ymax,U_U + n)\n        ymin = min(ymin,U_D + n)\n\n    #print (xmax-xmin,ymax-ymin)\n    return abs(xmax - xmin) * abs(ymax - ymin)\n\ndef my_round(val, digit=0):\n    p = 10 ** digit\n    return (val * p * 2 + 1) // 2 / p\n\n\nN = int(input())\n\nUD_L = float(\"inf\")\nUD_R = float(\"-inf\")\nL_L = float(\"inf\")\nL_R = float(\"-inf\")\nR_L = float(\"inf\")\nR_R = float(\"-inf\")\n\nLR_D = float(\"inf\")\nLR_U = float(\"-inf\")\nD_D = float(\"inf\")\nD_U = float(\"-inf\")\nU_D = float(\"inf\")\nU_U = float(\"-inf\")\n\nU = False\nD = False\nL = False\nR = False\n\nfor i in range(N):\n\n    x,y,d = input().split()\n\n    x = int(x)\n    y = int(y)\n\n    if d == \"L\" or d == \"R\":\n        LR_D = min(LR_D,y)\n        LR_U = max(LR_U,y)\n\n        if d == \"L\":\n\n            L_L = min(L_L,x)\n            L_R = max(L_R,x)\n            L = True\n\n        else: #R\n\n            R_L = min(R_L,x)\n            R_R = max(R_R,x)\n            R = True\n\n    if d == \"D\" or d == \"U\":\n\n        UD_L = min(UD_L,x)\n        UD_R = max(UD_R,x)\n\n        if d == \"D\":\n\n            D_D = min(D_D,y)\n            D_U = max(D_U,y)\n            D = True\n\n        else: #U\n\n            U_D = min(U_D,y)\n            U_U = max(U_U,y)\n            U = True\n\nt0 = 0\nt3 = 2 * 10 ** 8\nlast = float(\"inf\")\nans = 1000000000000000000000\n\nwhile abs(last - ans) > 10 ** (-100):\n\n    t1 = Decimal((t0 * 2 + t3 * 1)) / Decimal(3)\n    t2 = Decimal((t0 * 1 + t3 * 2)) / Decimal(3)\n\n    #print (t1,t2,want(t1),want(t2))\n\n    last = ans\n    \n    if want(t1) <= want(t2):\n        ans = want(t1)\n        t3 = t2\n\n    else:\n        ans = want(t2)\n        t0 = t1\n\n    #print (last,ans,t1,t2)\n\nif ans <= 10 ** (-9):\n    ans = 0\nprint(('{:.20g}'.format(ans)))\n", "from itertools import combinations\n\nINF = float(\"inf\")\ndata = {d: [-INF, INF, -INF, INF] for d in 'RLUD'}\n\n_, *XYD = open(0).read().split()\nX = map(int, XYD[::3])\nY = map(int, XYD[1::3])\nD = map(data.get, XYD[2::3])\n\nfor x, y, d in zip(X, Y, D):\n    if d[0] < x:\n        d[0] = x\n    if d[1] > x:\n        d[1] = x\n    if d[2] < y:\n        d[2] = y\n    if d[3] > y:\n        d[3] = y\n\nX = [\n    (data[\"L\"][0], -1), (data[\"L\"][1], -1),\n    (data[\"R\"][0], 1), (data[\"R\"][1], 1),\n    (data[\"U\"][0], 0), (data[\"U\"][1], 0),\n    (data[\"D\"][0], 0), (data[\"D\"][1], 0),\n]\nY = [\n    (data[\"L\"][2], 0), (data[\"L\"][3], 0),\n    (data[\"R\"][2], 0), (data[\"R\"][3], 0),\n    (data[\"U\"][2], 1), (data[\"U\"][3], 1),\n    (data[\"D\"][2], -1), (data[\"D\"][3], -1),\n]\n\nX = [(x, dx) for x, dx in X if abs(x) < INF]\nY = [(y, dy) for y, dy in Y if abs(y) < INF]\n\nT = set(\n    [0] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(X, 2) if dx != dy] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(Y, 2) if dx != dy]\n)\n\n\ndef area(t):\n    XX = [t * dx + x for x, dx in X]\n    YY = [t * dy + y for y, dy in Y]\n\n    dx = max(XX) - min(XX)\n    dy = max(YY) - min(YY)\n\n    return dx * dy\n\n\nprint(min(map(area, T)))", "N = int(input())\nxyd = [list(input().split()) for _ in range(N)]\n\ndef nasu(s, e, f, n, inf):\n  L = [0] * 3\n  a, b, c = inf, inf, inf\n  for i in range(N):\n    t = int(xyd[i][n])\n    if xyd[i][2] == s:\n      a = f(a, t)\n    elif xyd[i][2] == e:\n      b = f(b, t)\n    else:\n      c = f(c, t)\n  L[0] = a\n  if f(a, c) == a:\n    L[1] = abs(a - c)\n  else:\n    L[0], L[1] = c, 0\n  if f(L[0], b) != b:\n    if f(c, b) == c:\n      L[2] = abs(b - c)\n      if L[1] > L[2]:\n        L[2] = abs(a - b) / 2\n        L[1] = L[2]\n    else:\n      L[2] = abs(a - b) / 2\n      L[1] = L[2]\n  else:\n    L = [b, 0, 0]\n  for i in range(3):\n    if abs(L[i]) > abs(inf) / 2:\n      L[i] = abs(inf)\n  return L\n\ninf = 10 ** 10\nR = nasu(\"L\", \"R\", max, 0, -inf)\nL = nasu(\"R\", \"L\", min, 0, inf)\nU = nasu(\"D\", \"U\", max, 1, -inf)\nD = nasu(\"U\", \"D\", min, 1, inf)\n\ndef honya(x):\n  r = honyaraka(R, x, 1)\n  l = honyaraka(L, x, -1)\n  u = honyaraka(U, x, 1)\n  d = honyaraka(D, x, -1)\n  return abs(r - l) * abs(u - d)\n\ndef honyaraka(X, x, f):\n  a, b, c = X\n  if x <= b:\n    return a + x * f * -1\n  if x < c:\n    return a + b * f * -1\n  return a + b * f * -1 + (x - c) * f\n\nans = honya(0)\nT = [R, L, U, D]\nfor i in range(4):\n  for j in range(1, 3):\n    x = T[i][j]\n    if x != inf:\n      ans = min(ans, honya(x))\n\nprint(ans)\n", "import numpy as np\n\nN = int(input())\n\nx_min = [np.inf] * 4\nx_max = [-np.inf] * 4\ny_min = [np.inf] * 4\ny_max = [-np.inf] * 4\nfor _ in range(N):\n    x, y, d = input().split()\n    x = int(x)\n    y = int(y)\n    i = {'R': 0, 'L': 1, 'U': 2, 'D': 3}[d]\n    x_min[i] = min(x_min[i], x)\n    x_max[i] = max(x_max[i], x)\n    y_min[i] = min(y_min[i], y)\n    y_max[i] = max(y_max[i], y)\n\nx_max_ = max(x_max[2], x_max[3])\nx_min_ = min(x_min[2], x_min[3])\ny_max_ = max(y_max[0], y_max[1])\ny_min_ = min(y_min[0], y_min[1])\n\ndef W(t):\n    R = max(x_max[0] + t, x_max[1] - t, x_max_)\n    L = min(x_min[0] + t, x_min[1] - t, x_min_)\n    return R - L\n\ndef H(t):\n    U = max(y_max[2] + t, y_max[3] - t, y_max_)\n    D = min(y_min[2] + t, y_min[3] - t, y_min_)\n    return U - D\n\ndef WH(t):\n    return W(t) * H(t)\n\nts = [\n    0,\n    (x_max[1] - x_max[0]) / 2,\n    (x_min[1] - x_min[0]) / 2,\n    (y_max[3] - y_max[2]) / 2,\n    (y_min[3] - y_min[2]) / 2,\n    x_max_ - x_max[0],\n    -(x_max_ - x_max[1]),\n    x_min_ - x_min[0],\n    -(x_min_ - x_min[1]),\n    y_max_ - y_max[2],\n    -(y_max_ - y_max[3]),\n    y_min_ - y_min[2],\n    -(y_min_ - y_min[3]),\n]\n\nresult = np.inf;\nfor t in ts:\n    if t >= 0:\n        result = min(result, WH(t))\n\nprint(result)\n", "from scipy.optimize import fmin\nN = int(input())\n\nINF = 10 ** 18\nX = [[],[],[]]\nY = [[],[],[]]\n\nfor _ in range(N):\n  x,y,d = input().split()\n  x,y = int(x),int(y)\n  if d == 'L':\n    X[-1].append(x)\n    Y[0].append(y)\n  elif d == 'R':\n    X[1].append(x)\n    Y[0].append(y)\n  elif d == 'U':\n    Y[1].append(y)\n    X[0].append(x)\n  else:\n    Y[-1].append(y)\n    X[0].append(x)\n\nfor i in [-1,0,1]:\n  X[i] = [min(X[i] + [INF]), max(X[i] + [-INF])]\n  Y[i] = [min(Y[i] + [INF]), max(Y[i] + [-INF])]\n\ndef calc_width(t, X):\n  left = INF\n  right = -INF\n  for i in [-1,0,1]:\n    left = min(left, X[i][0] + i * t)\n    right = max(right, X[i][1] + i * t)\n  return right - left\n\ndef area(t):\n  if t < 0:\n    return INF\n  return calc_width(t, X) * calc_width(t, Y)\n\nxopt = fmin(area, x0 = 10**8, ftol = 10**-9, disp = False)\nanswer = area(xopt[0])\nprint(answer)\n", "import sys\nfrom scipy.optimize import fmin\n\ninput = sys.stdin.readline\n\nn = int(input())\n\nXR = []\nXL = []\nXS = []\nYU = []\nYD = []\nYS = []\n\nfor _ in range(n):\n    x, y, d = input().split()\n    x = int(x)\n    y = int(y)\n    if d == \"D\":\n        XS.append(x)\n        YD.append(y)\n    elif d == \"U\":\n        XS.append(x)\n        YU.append(y)\n    elif d == \"R\":\n        XR.append(x)\n        YS.append(y)\n    elif d == \"L\":\n        XL.append(x)\n        YS.append(y)\n\n\nmax_YD = max(YD + [float(\"-inf\")])\nmax_YS = max(YS + [float(\"-inf\")])\nmax_YU = max(YU + [float(\"-inf\")])\nmin_YD = min(YD + [float(\"inf\")])\nmin_YS = min(YS + [float(\"inf\")])\nmin_YU = min(YU + [float(\"inf\")])\n\nmax_XR = max(XR + [float(\"-inf\")])\nmax_XL = max(XL + [float(\"-inf\")])\nmax_XS = max(XS + [float(\"-inf\")])\nmin_XR = min(XR + [float(\"inf\")])\nmin_XL = min(XL + [float(\"inf\")])\nmin_XS = min(XS + [float(\"inf\")])\n\n\ndef diff_xy(t):\n    diff_y = max(max_YD - t, max_YU + t, max_YS) - min(min_YD - t, min_YU + t, min_YS)\n    diff_x = max(max_XL - t, max_XR + t, max_XS) - min(min_XL - t, min_XR + t, min_XS)\n    return diff_x * diff_y\n\n\noptions = [\n    max_YD - max_YS,\n    max_YS - max_YU,\n    (max_YD - max_YU) / 2,\n    min_YD - min_YS,\n    (min_YD - min_YU) / 2,\n    min_YS - min_YU,\n    max_XL - max_XS,\n    max_XS - max_XR,\n    (max_XL - max_XR) / 2,\n    min_XL - min_XS,\n    (min_XL - min_XR) / 2,\n    min_XS - min_XR]\n\nans = diff_xy(0)\n\nfor option in options:\n    if option >= 0:\n        ans = min(ans, diff_xy(option))\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 9\nMOD = 10 ** 9 + 7\ndef YesNo(x): return 'Yes' if x else 'No'\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\ndef main():\n    N = II()\n    xp9, xm9, xf9, yp9, ym9, yf9 = [-INF] * 6\n    xp0, xm0, xf0, yp0, ym0, yf0 = [INF] * 6\n    for _ in range(N):\n        x, y, d = LS()\n        x = int(x)\n        y = int(y)\n        if d == 'R':\n            xp9 = max(xp9, x)\n            xp0 = min(xp0, x)\n            yf9 = max(yf9, y)\n            yf0 = min(yf0, y)\n        elif d == 'L':\n            xm9 = max(xm9, x)\n            xm0 = min(xm0, x)\n            yf9 = max(yf9, y)\n            yf0 = min(yf0, y)\n        elif d == 'U':\n            xf9 = max(xf9, x)\n            xf0 = min(xf0, x)\n            yp9 = max(yp9, y)\n            yp0 = min(yp0, y)\n        elif d == 'D':\n            xf9 = max(xf9, x)\n            xf0 = min(xf0, x)\n            ym9 = max(ym9, y)\n            ym0 = min(ym0, y)\n    ts = [0]\n    ts += [xf0 - xp0, xf9 - xp0, xf0 - xp9, xf9 - xp9]\n    ts += [(xm0 - xp0) * 0.5, (xm9 - xp0) * 0.5, (xm0 - xp9) * 0.5, (xm9 - xp9) * 0.5]\n    ts += [xm0 - xf0, xm9 - xf0, xm0 - xf9, xm9 - xf9]\n    ts += [yf0 - yp0, yf9 - yp0, yf0 - yp9, yf9 - yp9]\n    ts += [(ym0 - yp0) * 0.5, (ym9 - yp0) * 0.5, (ym0 - yp9) * 0.5, (ym9 - yp9) * 0.5]\n    ts += [ym0 - yf0, ym9 - yf0, ym0 - yf9, ym9 - yf9]\n    ts = [t for t in ts if t >= 0]\n    ans = 10 ** 18\n    for t in ts:\n        xmax = max(xf9, xm9 - t, xp9 + t)\n        xmin = min(xf0, xm0 - t, xp0 + t)\n        ymax = max(yf9, ym9 - t, yp9 + t)\n        ymin = min(yf0, ym0 - t, yp0 + t)\n        tmp = (xmax - xmin) * (ymax - ymin)\n        ans = min(ans, tmp)\n\n    return ans\n\nprint(main())", "# coding: utf-8\n# Your code here!\n\nimport sys\nn = int(input())\ninf = float(\"inf\")\nxmin = [inf, inf, inf] #\u50be\u304d-1,0,1\nxmax = [-inf, -inf, -inf]\nymin = [inf, inf, inf]\nymax = [-inf, -inf, -inf]\n\nfor _ in range(n):\n    x,y,d = [i for i in input().split()]\n    x=int(x); y=int(y)\n    if d==\"U\": ud = 2; lr = 1\n    if d==\"D\": ud = 0; lr = 1\n    if d==\"L\": ud = 1; lr = 0\n    if d==\"R\": ud = 1; lr = 2\n    xmin[lr] = min(xmin[lr],x)\n    xmax[lr] = max(xmax[lr],x)\n    ymin[ud] = min(ymin[ud],y)\n    ymax[ud] = max(ymax[ud],y)\n\ndef lpos(t):\n    return min([(v-1)*t + i for v,i in enumerate(xmin)])\ndef rpos(t):\n    return max([(v-1)*t + i for v,i in enumerate(xmax)])\ndef dpos(t):\n    return min([(v-1)*t + i for v,i in enumerate(ymin)])\ndef upos(t):\n    return max([(v-1)*t + i for v,i in enumerate(ymax)])\n\n\ns = {0}\nfor i in range(3):\n    for j in range(i+1,3):\n        t = (xmin[j]-xmin[i])/(i-j)\n        if t > 0 and t != inf and t!= -inf: s.add(t)\n        t = (xmax[j]-xmax[i])/(i-j)\n        if 0 < t and t != inf and t!= -inf: s.add(t)\n        t = (ymin[j]-ymin[i])/(i-j)\n        if 0 < t and t != inf and t!= -inf: s.add(t)\n        t = (ymax[j]-ymax[i])/(i-j)\n        if 0 < t and t != inf and t!= -inf: s.add(t)\n        \n\nans = 10**18\nfor t in s:\n    area = (rpos(t)-lpos(t))*(upos(t)-dpos(t))\n    if area < ans: ans = area\n\nprint(ans)", "from collections import defaultdict\nN=int(input())\n\nxdic=defaultdict(set)\nydic=defaultdict(set)\nfor i in range(N):\n  xs,ys,d=input().split()\n  x=int(xs)\n  y=int(ys)\n  if d==\"L\":\n    xdic[-1].add(x)\n    ydic[0].add(y)\n  elif d==\"R\":\n    xdic[1].add(x)\n    ydic[0].add(y)\n  elif d==\"U\":\n    xdic[0].add(x)\n    ydic[1].add(y)\n  else:\n    xdic[0].add(x)\n    ydic[-1].add(y)\n\nxset=set()\nfor d in [-1,0,1]:\n  if len(xdic[d]):\n    min_d=min(xdic[d])\n    max_d=max(xdic[d])\n    xset.add((min_d,d))\n    xset.add((max_d,d))\n  \nyset=set()\nfor d in [-1,0,1]:\n  if len(ydic[d]):\n    min_d=min(ydic[d])    \n    max_d=max(ydic[d])\n    yset.add((min_d,d))\n    yset.add((max_d,d))\n\ndef cand_time(plist):\n  ret=set()\n  for i in range(len(plist)):\n    p1,d1=plist[i]\n    for j in range(i+1,len(plist)):\n      p2,d2=plist[j]\n      if d1==d2:\n        continue\n        \n      if d1==-1:\n        if d2==0:\n          t=p1-p2\n        else:\n          t=(p1-p2)/2\n      elif d1==0:\n        if d2==-1:\n          t=p2-p1\n        else:\n          t=p1-p2\n      else:\n        if d2==-1:\n          t=(p2-p1)/2\n        else:\n          t=p2-p1\n       \n      if t>0:\n        ret.add(t)\n  return ret\n\ncand_time_x=cand_time(list(xset))\ncand_time_y=cand_time(list(yset))\n#print(cand_time_x,cand_time_y)\ncand_t=[0]+list(cand_time_x)+list(cand_time_y)\n#print(cand_t)\n\ndef get_pos(pd,t):\n  p,d=pd\n  return p+d*t\n\nanswer=float(\"inf\")\nfor t in cand_t:\n  pos_min_x=float(\"inf\")\n  pos_max_x=-float(\"inf\")\n  for x2 in xset:\n    pos_min_x=min(pos_min_x,get_pos(x2,t))\n    pos_max_x=max(pos_max_x,get_pos(x2,t))\n    \n  pos_min_y=float(\"inf\")\n  pos_max_y=-float(\"inf\")\n  for y2 in yset:\n    pos_min_y=min(pos_min_y,get_pos(y2,t))\n    pos_max_y=max(pos_max_y,get_pos(y2,t))\n\n  #print(t,pos_min_x,pos_max_x,pos_min_y,pos_max_y)\n  t_ans=abs(pos_max_x-pos_min_x)*abs(pos_max_y-pos_min_y)\n  if answer>=t_ans:\n    answer=t_ans\n    #print(answer,t,abs(pos_max_x-pos_min_x),abs(pos_max_y-pos_min_y))\n  \nprint(answer)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n = I()\n    aa = [LS() for _ in range(n)]\n    xi = collections.defaultdict(lambda: inf)\n    xa = collections.defaultdict(lambda: -inf)\n    yi = collections.defaultdict(lambda: inf)\n    ya = collections.defaultdict(lambda: -inf)\n    km = 0\n    for x,y,d in aa:\n        x = int(x)\n        y = int(y)\n        if km < abs(x):\n            km = abs(x)\n        if km < abs(y):\n            km = abs(y)\n        if xi[d] > x:\n            xi[d] = x\n        if xa[d] < x:\n            xa[d] = x\n        if yi[d] > y:\n            yi[d] = y\n        if ya[d] < y:\n            ya[d] = y\n\n    ts = set([0])\n\n    for d in [xi,xa,yi,ya]:\n        ks = list(d.keys())\n        for k in ks:\n            for e in ks:\n                ts.add(abs(d[k] - d[e]))\n                ts.add(abs(d[k] - d[e]) / 2)\n\n    def f(i):\n        xxi = inf\n        xxa = -inf\n        yyi = inf\n        yya = -inf\n        for d,x in xi.items():\n            if d == 'L':\n                x -= i\n            elif d == 'R':\n                x += i\n            if xxi > x:\n                xxi = x\n        for d,x in xa.items():\n            if d == 'L':\n                x -= i\n            elif d == 'R':\n                x += i\n            if xxa < x:\n                xxa = x\n        for d,y in yi.items():\n            if d == 'D':\n                y -= i\n            elif d == 'U':\n                y += i\n            if yyi > y:\n                yyi = y\n        for d,y in ya.items():\n            if d == 'D':\n                y -= i\n            elif d == 'U':\n                y += i\n            if yya < y:\n                yya = y\n\n        return (xxa-xxi) * (yya-yyi)\n\n    r = f(0)\n    for i in ts:\n        t = f(i)\n        if r > t:\n            r = t\n\n    return '{:0.3f}'.format(r)\n\n\nprint(main())\n\n", "def men(t):\n    xmin = min(st + i * t for i, st in enumerate(mg[0]))\n    xmax = max(st + i * t for i, st in enumerate(mg[1]))\n    ymin = min(st + i * t for i, st in enumerate(ue[0]))\n    ymax = max(st + i * t for i, st in enumerate(ue[1]))\n    return (xmax - xmin) * (ymax - ymin)\n\nn = int(input())\ninf = 10**9\nmg = [[inf, inf, inf], [-inf, -inf, -inf]]\nue = [[inf, inf, inf], [-inf, -inf, -inf]]\nmg0=mg[0]\nmg1=mg[1]\nue0=ue[0]\nue1=ue[1]\nfor _ in range(n):\n    x, y, d = input().split()\n    x = int(x)\n    y = int(y)\n    if d == \"U\":\n        mv = 1\n        uv = 2\n    elif d == \"D\":\n        mv = 1\n        uv = 0\n    elif d == \"R\":\n        mv = 2\n        uv = 1\n    else:\n        mv = 0\n        uv = 1\n    if x < mg0[mv]: mg0[mv] = x\n    if x > mg1[mv]: mg1[mv] = x\n    if y < ue0[uv]: ue0[uv] = y\n    if y > ue1[uv]: ue1[uv] = y\nt=set([0])\nfor lst in [mg0,mg1,ue0,ue1]:\n    v0,v1,v2=lst\n    for tk in [v0-v1,v1-v2,(v0-v2)/2]:\n        if tk>=0:\n            t.add(tk)\nprint(min(men(tk) for tk in t))", "import itertools\n\ndef enum(a):\n    t = [0]\n    for a1, a2 in itertools.combinations(a, 2):\n        t.append(a1[0]-a2[0])\n        t.append(a2[0]-a1[0])\n        t.append((a1[0]-a2[0])/2)\n        t.append((a2[0]-a1[0])/2)\n    return t\n\ndef calcWidth(l, t):\n    x_min = x_max = l[0][0] + l[0][1] * t\n    for item in l:\n        x_min = min(x_min, item[0] + item[1] * t)\n        x_max = max(x_max, item[0] + item[1] * t)\n    return x_max - x_min\n\ndef calc(x_trip, y_trip, t):\n    if t < 0:\n        return calcWidth(x_trip, 0) * calcWidth(y_trip, 0)\n    return calcWidth(x_trip, t) * calcWidth(y_trip, t)\n\nn = int(input())\nx_r, x_n, x_l = [], [], []\ny_u, y_n, y_d = [], [], []\nfor _ in range(n):\n    x, y, d = input().strip().split()\n    x, y = int(x), int(y)\n    if d == \"R\":\n        x_r.append(x)\n    elif d == \"L\":\n        x_l.append(x)\n    else:\n        x_n.append(x)\n\n    if d == \"U\":\n        y_u.append(y)\n    elif d == \"D\":\n        y_d.append(y)\n    else:\n        y_n.append(y)\n\nx_r.sort()\nx_n.sort()\nx_l.sort()\ny_u.sort()\ny_n.sort()\ny_d.sort()\n\ndef ht(x, d):\n    if len(x) > 0:\n        return [(x[0], d), (x[-1], d)]\n    return []\nx_list = ht(x_r, 1) + ht(x_n, 0) + ht(x_l, -1)\ny_list = ht(y_u, 1) + ht(y_n, 0) + ht(y_d, -1)\nt = enum(x_list + y_list)\n\nans = calc(x_list, y_list, 0)\nfor t1 in t:\n    if t1 < 0:\n        continue\n    wx = calcWidth(x_list, t1)\n    wy = calcWidth(y_list, t1)\n    ans = min(ans, calc(x_list, y_list, t1))\n    ans = min(ans, calc(x_list, y_list, t1 + (wx-wy)/2))\n    ans = min(ans, calc(x_list, y_list, t1 + (wy-wx)/2))\n    ans = min(ans, calc(x_list, y_list, t1 + (wx*2-wy)/4))\n    ans = min(ans, calc(x_list, y_list, t1 + (wx-wy*2)/4))\n    ans = min(ans, calc(x_list, y_list, t1 + (wy*2-wx)/4))\n    ans = min(ans, calc(x_list, y_list, t1 + (wy-wx*2)/4))\n    ans = min(ans, calc(x_list, y_list, t1 + (wx*2-wy*2)/8))\n    ans = min(ans, calc(x_list, y_list, t1 + (wy*2-wx*2)/8))\nprint(ans)\n\n", "def main():\n    R_edge, L_edge, U_edge, D_edge = [None]*3, [None]*3, [None]*3, [None]*3\n    n = int(input())\n    xyd = [input().split() for _ in [0]*n]\n    xyd = [(int(x), int(y), d) for x, y, d in xyd]\n    for x, y, d in xyd:\n        if d in [\"R\", \"L\"]:\n            if U_edge[1] is None:\n                U_edge[1] = y\n            else:\n                U_edge[1] = max(U_edge[1], y)\n            if D_edge[1] is None:\n                D_edge[1] = y\n            else:\n                D_edge[1] = min(D_edge[1], y)\n        else:\n            if R_edge[1] is None:\n                R_edge[1] = x\n            else:\n                R_edge[1] = max(R_edge[1], x)\n            if L_edge[1] is None:\n                L_edge[1] = x\n            else:\n                L_edge[1] = min(L_edge[1], x)\n        for p, q, r in [[R_edge, \"R\", x], [L_edge, \"L\", x], [U_edge, \"U\", y], [D_edge, \"D\", y]]:\n            if d == q:\n                if p[0] is None:\n                    p[0] = r\n                    p[2] = r\n                else:\n                    p[0] = min(p[0], r)\n                    p[2] = max(p[2], r)\n\n    def area(t):\n        RL, UD = [], []\n        if R_edge[0] is not None:\n            RL += [t+R_edge[0], t+R_edge[2]]\n        if R_edge[1] is not None:\n            RL += [R_edge[1]]\n        if L_edge[0] is not None:\n            RL += [-t+L_edge[0], -t+L_edge[2]]\n        if L_edge[1] is not None:\n            RL += [L_edge[1]]\n        if U_edge[0] is not None:\n            UD += [t+U_edge[0], t+U_edge[2]]\n        if U_edge[1] is not None:\n            UD += [U_edge[1]]\n        if D_edge[0] is not None:\n            UD += [-t+D_edge[0], -t+D_edge[2]]\n        if D_edge[1] is not None:\n            UD += [D_edge[1]]\n        if len(RL)*len(UD) == 0:\n            return 0\n        else:\n            return (max(RL)-min(RL))*(max(UD)-min(UD))\n\n    t = [0]\n    for edge in [R_edge, L_edge, U_edge, D_edge]:\n        if None not in edge:\n            t.append(abs(edge[1]-edge[0]))\n            t.append(abs(edge[1]-edge[2]))\n    for edge1, edge2 in [[R_edge, L_edge], [U_edge, D_edge]]:\n        if None not in [edge1[1], edge2[0]]:\n            t.append(abs(edge1[1]-edge2[0]))\n            t.append(abs(edge1[1]-edge2[2]))\n        if None not in [edge2[1], edge1[0]]:\n            t.append(abs(edge2[1]-edge1[0]))\n            t.append(abs(edge2[1]-edge1[2]))\n        if None not in [edge1[0], edge2[0]]:\n            for i in [0, 2]:\n                for j in [0, 2]:\n                    t.append(abs(edge2[i]-edge1[j])/2)\n\n    print((min([area(i) for i in t])))\n\n\nmain()\n", "N = int(input())\n \nPS = [[], [], [], []]\nS = \"RLUD\".index\n \nfor i in range(N):\n    x, y, d = input().split(); x = int(x); y = int(y)\n    PS[S(d)].append((x, y))\n \nT = [0]\nINF = 10**9\n \ndymin = INF; dymax = -INF\nP = []\nfor i in [0, 1]:\n    xmin = INF; xmax = -INF\n    for x, y in PS[i]:\n        dymin = min(dymin, y)\n        dymax = max(dymax, y)\n        xmin = min(xmin, x)\n        xmax = max(xmax, x)\n    P.append((xmin, xmax))\nfor x0 in P[0]:\n    for x1 in P[1]:\n        T.append(max(x1 - x0, 0) / 2.)\n \ndxmin = INF; dxmax = -INF\nQ = []\nfor i in [2, 3]:\n    ymin = INF; ymax = -INF\n    for x, y in PS[i]:\n        dxmin = min(dxmin, x)\n        dxmax = max(dxmax, x)\n        ymin = min(ymin, y)\n        ymax = max(ymax, y)\n    Q.append((ymin, ymax))\nfor y0 in Q[0]:\n    for y1 in Q[1]:\n        T.append(max(y1 - y0, 0) / 2.)\n \nfor x0 in [dxmin, dxmax]:\n    for x in P[0]:\n        T.append(max(x0 - x, 0))\n    for x in P[1]:\n        T.append(max(x - x0, 0))\nfor y0 in [dymin, dymax]:\n    for y in Q[0]:\n        T.append(max(y0 - y, 0))\n    for y in Q[1]:\n        T.append(max(y - y0, 0))\n \nans = 10**30\nfor t in T:\n    xmin = dxmin; xmax = dxmax\n    ymin = dymin; ymax = dymax\n \n    xi, xa = P[0]\n    if xi != INF:\n        xmin = min(xmin, xi+t)\n        xmax = max(xmax, xa+t)\n    xi, xa = P[1]\n    if xi != INF:\n        xmin = min(xmin, xi-t)\n        xmax = max(xmax, xa-t)\n    yi, ya = Q[0]\n    if yi != INF:\n        ymin = min(ymin, yi+t)\n        ymax = max(ymax, ya+t)\n    yi, ya = Q[1]\n    if yi != INF:\n        ymin = min(ymin, yi-t)\n        ymax = max(ymax, ya-t)\n    ans = min(ans, (xmax - xmin) * (ymax - ymin))\nprint(\"%.6f\" % ans)", "N = int(input())\nM = {'R': [], 'L':[], 'U': [], 'D': [], 'X': [], 'Y': []}\nfor _ in range(N):\n  x, y, d = input().split()\n  if d in ['R', 'L']:\n    M[d].append(int(x))\n    M['Y'].append(int(y))\n  else:\n    M['X'].append(int(x))\n    M[d].append(int(y))\nfor d in 'RLDUXY':\n  M[d] = sorted(M[d])\nT = [0] * 13\nT[0] = M['X'][0] - M['R'][0] if M['X'] and M['R'] else -1\nT[1] = M['L'][0] - M['X'][0] if M['X'] and M['L'] else -1\nT[2] = (M['L'][0] - M['R'][0]) / 2 if M['L'] and M['R'] else -1\nT[3] = M['X'][-1] - M['R'][-1] if M['X'] and M['R'] else -1\nT[4] = M['L'][-1] - M['X'][-1] if M['X'] and M['L'] else -1\nT[5] = (M['L'][-1] - M['R'][-1]) / 2 if M['L'] and M['R'] else -1\nT[6] = M['Y'][-1] - M['U'][-1] if M['Y'] and M['U'] else -1\nT[7] = M['D'][-1] - M['Y'][-1] if M['Y'] and M['D'] else -1\nT[8] = (M['D'][-1] - M['U'][-1]) / 2 if M['D'] and M['U'] else -1\nT[9] = M['Y'][0] - M['U'][0] if M['Y'] and M['U'] else -1\nT[10] = M['D'][0] - M['Y'][0] if M['Y'] and M['D'] else -1\nT[11] = (M['D'][0] - M['U'][0]) / 2 if M['D'] and M['U'] else -1\nRect = [-1] * 13\nfor i, t in enumerate(T):\n  if t < 0:\n    continue\n  R = []\n  L = []\n  U = []\n  D = []\n  if M['R']:\n    R.append(M['R'][-1] + t)\n    L.append(M['R'][0] + t)\n  if M['L']:\n    R.append(M['L'][-1] - t)\n    L.append(M['L'][0] - t)\n  if M['U']:\n    U.append(M['U'][-1] + t)\n    D.append(M['U'][0] + t)\n  if M['D']:\n    U.append(M['D'][-1] - t)\n    D.append(M['D'][0] - t)\n  if M['X']:\n    R.append(M['X'][-1])\n    L.append(M['X'][0])\n  if M['Y']:\n    U.append(M['Y'][-1])\n    D.append(M['Y'][0])\n  Rect[i] = (max(R) - min(L)) * (max(U) - min(D))\nprint(min([r for r in Rect if r >= 0]))", "INF = float('inf')\n\nN = int(input())\n\nxConstMin, xConstMax = INF, -INF\nxAscMin, xAscMax = INF, -INF\nxDescMin, xDescMax = INF, -INF\nyConstMin, yConstMax = INF, -INF\nyAscMin, yAscMax = INF, -INF\nyDescMin, yDescMax = INF, -INF\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n    if d == 'R':\n        xAscMax = max(xAscMax, x)\n        xAscMin = min(xAscMin, x)\n        yConstMax = max(yConstMax, y)\n        yConstMin = min(yConstMin, y)\n    elif d == 'L':\n        xDescMax = max(xDescMax, x)\n        xDescMin = min(xDescMin, x)\n        yConstMax = max(yConstMax, y)\n        yConstMin = min(yConstMin, y)\n    elif d == 'U':\n        xConstMax = max(xConstMax, x)\n        xConstMin = min(xConstMin, x)\n        yAscMax = max(yAscMax, y)\n        yAscMin = min(yAscMin, y)\n    elif d == 'D':\n        xConstMax = max(xConstMax, x)\n        xConstMin = min(xConstMin, x)\n        yDescMax = max(yDescMax, y)\n        yDescMin = min(yDescMin, y)\n\ntms = []\n\nt1 = max(0, xDescMax - xConstMax)\nt2 = max(0, xConstMax - xAscMax)\nif t1 >= t2:\n    t = max(0, (xDescMax-xAscMax)/2)\n    tms.append(t)\nelse:\n    tms.append(t1)\n    tms.append(t2)\n\nt1 = max(0, xConstMin - xAscMin)\nt2 = max(0, xDescMin - xConstMin)\nif t1 >= t2:\n    t = max(0, (xDescMin-xAscMin)/2)\n    tms.append(t)\nelse:\n    tms.append(t1)\n    tms.append(t2)\n\nt1 = max(0, yDescMax - yConstMax)\nt2 = max(0, yConstMax - yAscMax)\nif t1 >= t2:\n    t = max(0, (yDescMax-yAscMax)/2)\n    tms.append(t)\nelse:\n    tms.append(t1)\n    tms.append(t2)\n\nt1 = max(0, yConstMin - yAscMin)\nt2 = max(0, yDescMin - yConstMin)\nif t1 >= t2:\n    t = max(0, (yDescMin-yAscMin)/2)\n    tms.append(t)\nelse:\n    tms.append(t1)\n    tms.append(t2)\n\nans = INF\nfor tm in tms:\n    if tm == INF: continue\n\n    xs = [xConstMin, xConstMax, xAscMin+tm, xAscMax+tm, xDescMin-tm, xDescMax-tm]\n    ys = [yConstMin, yConstMax, yAscMin+tm, yAscMax+tm, yDescMin-tm, yDescMax-tm]\n\n    xMin, xMax = INF, -INF\n    for x in xs:\n        if x == INF or x == -INF: continue\n        xMin = min(xMin, x)\n        xMax = max(xMax, x)\n\n    yMin, yMax = INF, -INF\n    for y in ys:\n        if y == INF or y == -INF: continue\n        yMin = min(yMin, y)\n        yMax = max(yMax, y)\n\n    ans = min(ans, (xMax-xMin)*(yMax-yMin))\n\nprint(ans)\n", "inf = float('inf')\nN = int(input())\nMRp = -inf\nMR = -inf\nMRm = -inf\nmRp = inf\nmR = inf\nmRm = inf\nMUp = -inf\nMU = -inf\nMUm = -inf\nmUp = inf\nmU = inf\nmUm = inf\n\nfor i in range(N):\n\tx, y, d = input().split()\n\tx, y = int(x), int(y)\n\tif d == 'R':\n\t\tMRp = max(MRp, x)\n\t\tmRp = min(mRp, x)\n\t\tMU = max(MU, y)\n\t\tmU = min(mU, y)\n\telif d == 'L':\n\t\tMRm = max(MRm, x)\n\t\tmRm = min(mRm, x)\n\t\tMU = max(MU, y)\n\t\tmU = min(mU, y)\n\telif d == 'U':\n\t\tMUp = max(MUp, y)\n\t\tmUp = min(mUp, y)\n\t\tMR = max(MR, x)\n\t\tmR = min(mR, x)\n\telse:\n\t\tMUm = max(MUm, y)\n\t\tmUm = min(mUm, y)\n\t\tMR = max(MR, x)\n\t\tmR = min(mR, x)\n\nt = [0]\nif MR > MRp:\n\tt.append(MR - MRp)\nif MRm > MRp:\n\tt.append((MRm - MRp) / 2)\nif MRm > MR:\n\tt.append(MRm - MR)\nif mRm > mR:\n\tt.append(mRm - mR)\nif mRm > mRp:\n\tt.append((mRm - mRp) / 2)\nif mR > mRp:\n\tt.append(mR - mRp)\nif MU > MUp:\n\tt.append(MU - MUp)\nif MUm > MUp:\n\tt.append((MUm - MUp) / 2)\nif MUm > MU:\n\tt.append(MUm - MU)\nif mUm > mU:\n\tt.append(mUm - mU)\nif mUm > mUp:\n\tt.append((mUm - mUp) / 2)\nif mU > mUp:\n\tt.append(mU - mUp)\n\nans = inf\nfor i in t:\n\tdx = max(MRp + i, MR, MRm - i) - min(mRp + i, mR, mRm - i)\n\tdy = max(MUp + i, MU, MUm - i) - min(mUp + i, mU, mUm - i)\n\tans = min(ans, dx * dy)\nprint(ans)", "from scipy.optimize import fmin\nN = int(input())\n\nINF = 10 ** 18\n# x \u65b9\u5411\u306b\u52d5\u304b\u306a\u3044\u70b9\u3001\u53f3\u79fb\u52d5\u306e\u70b9\u3001\u5de6\u79fb\u52d5\u306e\u70b9\u306e\u6700\u5c0f\u30fb\u6700\u5927\u5024\nfixed_x = [INF, -INF]\nR = [INF, -INF]\nL = [INF, -INF]\n# y \u65b9\u5411\u306b\u52d5\u304b\u306a\u3044\u70b9\u3001\u53f3\u79fb\u52d5\u306e\u70b9\u3001\u5de6\u79fb\u52d5\u306e\u70b9\u306e\u6700\u5c0f\u30fb\u6700\u5927\u5024\nfixed_y = [INF, -INF]\nU = [INF, -INF]\nD = [INF, -INF]\n\ndef update(fixed, li, x, y):\n  li[0], li[1] = min(li[0], x), max(li[1], x)\n  fixed[0], fixed[1] = min(fixed[0], y), max(fixed[1], y)\n  \nfor _ in range(N):\n  x,y,d = input().split()\n  x,y = int(x), int(y)\n  if d == 'L':\n    update(fixed_y, L, x, y)\n  elif d == 'R':\n    update(fixed_y, R, x, y)\n  elif d == 'U':\n    update(fixed_x, U, y, x)\n  else:\n    update(fixed_x, D, y, x)\n\ndef calc_x(t, fixed, dec, inc):\n  left = INF\n  right = -INF\n  for li, speed in [(fixed, 0), (dec, -1), (inc, 1)]:\n    left = min(left, li[0] + speed * t)\n    right = max(right, li[1] + speed * t)\n  return right - left\n\ndef area(t):\n  if t < 0:\n    return INF\n  return calc_x(t, fixed_x, L, R) * calc_x(t, fixed_y, D, U)\n\nxopt = fmin(area, x0 = 10**8, ftol = 10**-9, disp = False)\nanswer = area(xopt[0])\nprint(answer)\n", "N = int(input())\nx1, x2, y1, y2 = {}, {}, {}, {}\nINF = 10 ** 10\n\nfor i in range(N):\n    x, y, d = input().split()\n    x, y = int(x) * 2, int(y) * 2\n\n    def update_x(v, x):\n        if v not in x1:\n            x1[v] = x2[v] = x\n        else:\n            x1[v] = min(x1[v], x)\n            x2[v] = max(x2[v], x)\n\n    def update_y(v, y):\n        if v not in y1:\n            y1[v] = y2[v] = y\n        else:\n            y1[v] = min(y1[v], y)\n            y2[v] = max(y2[v], y)\n\n    if d == 'R':\n        update_x(+1, x)\n        update_y(0, y)\n    elif d == 'L':\n        update_x(-1, x)\n        update_y(0, y)\n    elif d == 'U':\n        update_x(0, x)\n        update_y(+1, y)\n    elif d == 'D':\n        update_x(0, x)\n        update_y(-1, y)\n\ndef area(t):\n    xmin, xmax, ymin, ymax = INF, -INF, INF, -INF\n    for (v, x) in list(x1.items()):\n        xmin = min(xmin, x + v * t)\n    for (v, x) in list(x2.items()):\n        xmax = max(xmax, x + v * t)\n    for (v, y) in list(y1.items()):\n        ymin = min(ymin, y + v * t)\n    for (v, y) in list(y2.items()):\n        ymax = max(ymax, y + v * t)\n    return (xmax - xmin) * (ymax - ymin)\n\nans = area(0)\n\nx3 = list(x1.items()) + list(x2.items())\nfor i in range(len(x3)):\n    for j in range(i + 1, len(x3)):\n        if x3[i][0] != x3[j][0]:\n            t = (x3[j][1] - x3[i][1]) // (x3[i][0] - x3[j][0])\n            if t >= 0:\n                ans = min(ans, area(t))\n\ny3 = list(y1.items()) + list(y2.items())\nfor i in range(len(y3)):\n    for j in range(i + 1, len(y3)):\n        if y3[i][0] != y3[j][0]:\n            t = (y3[j][1] - y3[i][1]) // (y3[i][0] - y3[j][0])\n            if t >= 0:\n                ans = min(ans, area(t))\n\nprint((ans / 4))\n", "import sys\nfrom scipy.optimize import fmin\n\ninput = sys.stdin.readline\n\nn = int(input())\n\nXR = []\nXL = []\nXS = []\nYU = []\nYD = []\nYS = []\n\nfor _ in range(n):\n    x, y, d = input().split()\n    x = int(x)\n    y = int(y)\n    if d == \"D\":\n        XS.append(x)\n        YD.append(y)\n    elif d == \"U\":\n        XS.append(x)\n        YU.append(y)\n    elif d == \"R\":\n        XR.append(x)\n        YS.append(y)\n    elif d == \"L\":\n        XL.append(x)\n        YS.append(y)\n\nmax_YD = max(YD + [float(\"-inf\")])\nmax_YS = max(YS + [float(\"-inf\")])\nmax_YU = max(YU + [float(\"-inf\")])\nmin_YD = min(YD + [float(\"inf\")])\nmin_YS = min(YS + [float(\"inf\")])\nmin_YU = min(YU + [float(\"inf\")])\n\nmax_XR = max(XR + [float(\"-inf\")])\nmax_XL = max(XL + [float(\"-inf\")])\nmax_XS = max(XS + [float(\"-inf\")])\nmin_XR = min(XR + [float(\"inf\")])\nmin_XL = min(XL + [float(\"inf\")])\nmin_XS = min(XS + [float(\"inf\")])\n\n\ndef diff_xy(t):\n    if t < 0:\n        return float(\"inf\")\n    diff_y = max(max_YD - t, max_YU + t, max_YS) - min(min_YD - t, min_YU + t, min_YS)\n    diff_x = max(max_XL - t, max_XR + t, max_XS) - min(min_XL - t, min_XR + t, min_XS)\n    return diff_x * diff_y\n\n\ndef binary_search(min_t, max_t):\n    mid_t = (min_t + max_t) / 2\n    if max_t - min_t < 10 ** (-10):\n        return diff_xy(mid_t)\n\n    if diff_xy(min_t) < diff_xy(mid_t):\n        return binary_search(min_t, mid_t)\n    elif diff_xy(max_t) < diff_xy(mid_t):\n        return binary_search(mid_t, max_t)\n    else:\n        return opt(min_t, mid_t, max_t)\n\n\ndef opt(a, b, c):\n    optimal_a = fmin(diff_xy, a, full_output=False, disp=False, xtol=10 ** (-10))\n    optimal_b = fmin(diff_xy, b, full_output=False, disp=False, xtol=10 ** (-10))\n    optimal_c = fmin(diff_xy, c, full_output=False, disp=False, xtol=10 ** (-10))\n    ans = min(diff_xy(optimal_a[0]), diff_xy(optimal_b[0]), diff_xy(optimal_c[0]))\n    return (ans)\n\n\nprint(binary_search(0, 2 * 10 ** 8))", "INF=10**20\n\nimport sys\nimport numpy as np\n\ninput=sys.stdin.readline\n\nN=int(input())\ndirection=[\"U\",\"D\",\"R\",\"L\"]\nX={moji:[] for moji in direction}\nY={moji:[] for moji in direction}\nfor i in range(N):\n    x,y,d=input().split()\n    x=int(x)\n    y=int(y)\n    X[d].append(x)\n    Y[d].append(y)\n\nquery=[]\n#Xmax\nif not X[\"L\"]:\n    Lmax=-INF\nelse:\n    Lmax=max(X[\"L\"])\nif not X[\"R\"]:\n    Rmax=-INF\nelse:\n    Rmax=max(X[\"R\"])\nif not X[\"U\"]:\n    mobUmax=-INF\nelse:\n    mobUmax=max(X[\"U\"])\nif not X[\"D\"]:\n    mobDmax=-INF\nelse:\n    mobDmax=max(X[\"D\"])\nUDmax=max(mobUmax,mobDmax)\n\nq1=(Lmax-Rmax)/2\nq2=Lmax-UDmax\nq3=UDmax-Rmax\nif q1>q2:\n    query.append([q2,\"Xmax\",0,UDmax])\n    query.append([q3,\"Xmax\",1,Rmax])\nelse:\n    query.append([q1,\"Xmax\",1,Rmax])\n\n#Xmin\nif not X[\"L\"]:\n    Lmin=INF\nelse:\n    Lmin=min(X[\"L\"])\nif not X[\"R\"]:\n    Rmin=INF\nelse:\n    Rmin=min(X[\"R\"])\nif not X[\"U\"]:\n    mobUmin=INF\nelse:\n    mobUmin=min(X[\"U\"])\nif not X[\"D\"]:\n    mobDmin=INF\nelse:\n    mobDmin=min(X[\"D\"])\nUDmin=min(mobUmin,mobDmin)\n\n\nq1=(Lmin-Rmin)/2\nq2=UDmin-Rmin\nq3=Lmin-UDmin\nif q1>q2:\n    query.append([q2,\"Xmin\",0,UDmin])\n    query.append([q3,\"Xmin\",-1,Lmin])\nelse:\n    query.append([q1,\"Xmin\",-1,Lmin])\n\n#Ymax\nif not Y[\"L\"]:\n    mobLmax=-INF\nelse:\n    mobLmax=max(Y[\"L\"])\nif not Y[\"R\"]:\n    mobRmax=-INF\nelse:\n    mobRmax=max(Y[\"R\"])\nif not Y[\"U\"]:\n    Umax=-INF\nelse:\n    Umax=max(Y[\"U\"])\nif not Y[\"D\"]:\n    Dmax=-INF\nelse:\n    Dmax=max(Y[\"D\"])\nLRmax=max(mobLmax,mobRmax)\n\n\nq1=(Dmax-Umax)/2\nq2=Dmax-LRmax\nq3=LRmax-Umax\nif q1>q2:\n    query.append([q2,\"Ymax\",0,LRmax])\n    query.append([q3,\"Ymax\",1,Umax])\nelse:\n    query.append([q1,\"Ymax\",1,Umax])\n\n#Ymin\nif not Y[\"L\"]:\n    mobLmin=INF\nelse:\n    mobLmin=min(Y[\"L\"])\nif not Y[\"R\"]:\n    mobRmin=INF\nelse:\n    mobRmin=min(Y[\"R\"])\nif not Y[\"U\"]:\n    Umin=INF\nelse:\n    Umin=min(Y[\"U\"])\nif not Y[\"D\"]:\n    Dmin=INF\nelse:\n    Dmin=min(Y[\"D\"])\nLRmin=min(mobLmin,mobRmin)\n\nq1=(Dmin-Umin)/2\nq2=LRmin-Umin\nq3=Dmin-LRmin\nif q1>q2:\n    query.append([q2,\"Ymin\",0,UDmin])\n    query.append([q3,\"Ymin\",-1,Dmin])\nelse:\n    query.append([q1,\"Xmax\",-1,Dmin])\n\nquery.sort()\nxmax=np.poly1d([-1,Lmax])\nxmin=np.poly1d([1,Rmin])\nymax=np.poly1d([-1,Dmax])\nymin=np.poly1d([1,Umin])\n\nval=[]\nfor i in range(-1,len(query)-1):\n    if i==-1:\n        p=(xmax-xmin)*(ymax-ymin)\n        coef2d=p.coef[0]\n        coef1d=p.coef[1]\n        if coef2d>0:\n            minval=coef1d/(2*coef2d)\n            next=query[i+1][0]\n            if minval>=0 and next>minval:\n                val.append(minval)\n    else:\n        t,func,c2d,c1d=query[i]\n        if func==\"Xmax\":\n            xmax=np.poly1d([c2d,c1d])\n        if func==\"Xmin\":\n            xmin=np.poly1d([c2d,c1d])\n        if func==\"Ymax\":\n            ymax=np.poly1d([c2d,c1d])\n        if func==\"Ymin\":\n            ymin=np.poly1d([c2d,c1d])\n        p=(xmax-xmin)*(ymax-ymin)\n        if p.order==2:\n            coef2d=p.coef[0]\n            coef1d=p.coef[1]\n            if coef2d>0:\n                minval=coef1d/(2*coef2d)\n                next=query[i+1][0]\n                if minval>=0 and next>minval:\n                    val.append(minval)\ndef Xmax(t):\n    return max(UDmax,Rmax+t,Lmax-t)\ndef Xmin(t):\n    return min(UDmin,Rmin+t,Lmin-t)\ndef Ymax(t):\n    return max(LRmax,Umax+t,Dmax-t)\ndef Ymin(t):\n    return min(LRmin,Umin+t,Dmin-t)\n\ndef function(t):\n    return (Xmax(t)-Xmin(t))*(Ymax(t)-Ymin(t))\n\nans=function(0)\nppp=0\nfor i in range(0,len(val)):\n    if 10**8>=val[i]>=0:\n        if ans>function(val[i]):\n            ans=min(ans,function(val[i]))\n            ppp=val[i]\n\nfor i in range(0,len(query)):\n    if 10**8>=query[i][0]>=0:\n        if ans>function(query[i][0]):\n            ans=min(ans,function(query[i][0]))\n            ppp=query[i][0]\n\nprint(ans)", "inf = float('inf')\nfrom scipy.optimize import fmin\nfrom collections import defaultdict\ndir = {'R', 'L', 'U', 'D'}\nN = int(input())\ndic = defaultdict(list)\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n    dic[d].append((x, y))\nx_max = defaultdict(lambda : -inf)\nx_min = defaultdict(lambda : inf)\ny_max = defaultdict(lambda : -inf)\ny_min = defaultdict(lambda : inf)\nfor d in dir:\n    if dic[d]:\n        dic[d].sort()\n        x_max[d] = dic[d][-1][0]\n        x_min[d] = dic[d][0][0]\n        dic[d].sort(key = lambda x:x[1])\n        y_max[d] = dic[d][-1][1]\n        y_min[d] = dic[d][0][1]\ndef dx(t):\n    return max(x_max['U'], x_max['D'], x_max['R']+t, x_max['L']-t)-min(x_min['U'], x_min['D'], x_min['R']+t, x_min['L']-t)\ndef dy(t):\n    return max(y_max['U']+t, y_max['D']-t, y_max['R'], y_max['L'])-min(y_min['U']+t, y_min['D']-t, y_min['R'], y_min['L'])\ndef f(t):\n    if t<0:\n        return inf\n    return dx(t)*dy(t)\ndef make_cand(s, d, i):\n    return [abs(s-i), abs(d-i)/2, abs(s-d)]\ncand = [0]+make_cand(max(x_max['U'], x_max['D']), x_max['R'], x_max['L'])               +make_cand(min(x_min['U'], x_min['D']), x_min['R'], x_min['L'])               +make_cand(max(y_max['R'], y_max['L']), y_max['U'], y_max['D'])               +make_cand(min(y_min['R'], y_min['L']), y_min['U'], y_min['D'])\nans = min(f(t)for t in cand)\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "INF = float('inf')\nN = int(input())\nd = {'R':[[],[]],'L':[[],[]],'U':[[],[]],'D':[[],[]]}\nfor i in range(N):\n    x,y,f = input().split()\n    x = int(x)\n    y = int(y)\n    d[f][0].append(x)\n    d[f][1].append(y)\n\nTs = []\n\nxM = max(max(d['U'][0]+[-INF]),max(d['D'][0]+[-INF]))\nxMr = max(d['R'][0]+[-INF])\nxMl = max(d['L'][0]+[-INF])\n\ndef xmax(T):\n    return max(xM,xMr+T,xMl-T)\n\nTs += [max(0,xMl-xM),max(0,xM-xMr),max(0,(xMl-xMr)/2)]\n\nxm = min(min(d['U'][0]+[INF]),min(d['D'][0]+[INF]))\nxmr = min(d['R'][0]+[INF])\nxml = min(d['L'][0]+[INF])\n\ndef xmin(T):\n    return min(xm,xmr+T,xml-T)\n\nTs += [max(0,xml-xm),max(0,xm-xmr),max(0,(xml-xmr)/2)]\n\nyM = max(max(d['R'][1]+[-INF]),max(d['L'][1]+[-INF]))\nyMu = max(d['U'][1]+[-INF])\nyMd = max(d['D'][1]+[-INF])\n\ndef ymax(T):\n    return max(yM,yMu+T,yMd-T)\n\nTs += [max(0,yMd-yM),max(0,yM-yMu),max(0,(yMd-yMu)/2)]\n\nym = min(min(d['R'][1]+[INF]),min(d['L'][1]+[INF]))\nymu = min(d['U'][1]+[INF])\nymd = min(d['D'][1]+[INF])\n\ndef ymin(T):\n    return min(ym,ymu+T,ymd-T)\n\nTs += [max(0,ymd-ym),max(0,ym-ymu),max(0,(ymd-ymu)/2)]\n\nans = INF\n\nfor T in Ts:\n    ans = min(ans,(xmax(T)-xmin(T))*(ymax(T)-ymin(T)))\n\nprint(ans)", "from decimal import *\ngetcontext().prec = 100\nN = int(input())\nXmi, Xma, Ymi, Yma, DYmi, DYma, UYmi, UYma, RXmi, RXma, LXmi, LXma = [(10**10), -(10**10)] * 6\nfor _ in range(N):\n    x, y, d = input().split()\n    x, y = int(x), int(y)\n    \n    if d == \"R\":\n        RXmi = min(RXmi, x)\n        RXma = max(RXma, x)\n    elif d == \"L\":\n        LXmi = min(LXmi, x)\n        LXma = max(LXma, x)\n    else:\n        Xmi = min(Xmi, x)\n        Xma = max(Xma, x)\n        \n    if d == \"U\":\n        UYmi = min(UYmi, y)\n        UYma = max(UYma, y)\n    elif d == \"D\":\n        DYmi = min(DYmi, y)\n        DYma = max(DYma, y)\n    else:\n        Ymi = min(Ymi, y)\n        Yma = max(Yma, y)\n\ndef calc(t):\n    xmi = min(RXmi+t, LXmi-t, Xmi)\n    xma = max(RXma+t, LXma-t, Xma)\n    ymi = min(UYmi+t, DYmi-t, Ymi)\n    yma = max(UYma+t, DYma-t, Yma)\n    return max(yma-ymi, 0)*max(xma-xmi, 0)\n    \ndef dii(t):\n    a = Decimal(\"0.00000001\")\n    return calc(t+a) - calc(t-a)\n\nl = Decimal(\"0\")\nr = Decimal(\"10000000000\")\nfor _ in range(500):\n    m = (l+r)/2\n    if dii(m) > 0:\n        r = m\n    else:\n        l = m\nprint((calc(m)))\n", "# coding: utf-8\n# Your code here!\n\nimport sys\nn = int(input())\n\ninf = float(\"inf\")\nu=d=l=r=0\numin = inf\numax = -inf\ndmin = inf\ndmax = -inf\nlmin = inf\nlmax = -inf\nrmin = inf\nrmax = -inf\nxmin = inf\nxmax = -inf\nymin = inf\nymax = -inf\nxx=yy=0\n\nfor j in range(n):\n    x,y,D = [i for i in input().split()]\n    x=int(x); y=int(y)\n    if D == \"U\":\n        umin = min(umin,y)\n        umax = max(umax,y)\n        u=1\n        xmin = min(xmin,x)\n        xmax = max(xmax,x)\n        xx=1\n    if D == \"D\":\n        dmin = min(dmin,y)\n        dmax = max(dmax,y)\n        d=1\n        xmin = min(xmin,x)\n        xmax = max(xmax,x)\n        xx=1\n    if D == \"L\":\n        lmin = min(lmin,x)\n        lmax = max(lmax,x)\n        l=1\n        ymin = min(ymin,y)\n        ymax = max(ymax,y)\n        yy=1\n    if D == \"R\":\n        rmin = min(rmin,x)\n        rmax = max(rmax,x)\n        r=1\n        ymin = min(ymin,y)\n        ymax = max(ymax,y)\n        yy=1\n\ndef lpos(t):\n    ans = inf\n    if xx: ans = min(ans,xmin)\n    if l: ans = min(ans,lmin-t)\n    if r: ans = min(ans,rmin+t)\n    return ans\ndef rpos(t):\n    ans = -inf\n    if xx: ans = max(ans,xmax)\n    if l: ans = max(ans,lmax-t)\n    if r: ans = max(ans,rmax+t)\n    return ans\n\ndef dpos(t):\n    ans = inf\n    if yy: ans = min(ans,ymin)\n    if u: ans = min(ans,umin+t)\n    if d: ans = min(ans,dmin-t)\n    return ans\ndef upos(t):\n    ans = -inf\n    if yy: ans = max(ans,ymax)\n    if u: ans = max(ans,umax+t)\n    if d: ans = max(ans,dmax-t)\n    return ans\n\ns = {0}\nif xx and l:\n    if lmin - xmin > 0: s.add(lmin - xmin)\n    if lmax - xmax > 0: s.add(lmax - xmax)\nif xx and r:\n    if xmin - rmin > 0: s.add(xmin - rmin)\n    if xmax - rmax > 0: s.add(xmax - rmax)\nif l and r:\n    if lmin-rmin > 0: s.add((lmin-rmin)/2)\n    if lmax-rmax > 0: s.add((lmax-rmax)/2)\n\nif yy and d:\n    if dmin - ymin > 0: s.add(dmin - ymin)\n    if dmax - ymax > 0: s.add(dmax - ymax)\nif yy and u:\n    if ymin - umin > 0: s.add(ymin - umin)\n    if ymax - umax > 0: s.add(ymax - umax)\nif d and u:\n    if dmin-umin > 0: s.add((dmin-umin)/2)\n    if dmax-umax > 0: s.add((dmax-umax)/2)\n    \n#print(rmax,xmax)\n\nans = 10**18\nfor t in s:\n#    print(rpos(t),lpos(t),dpos(t),upos(t),xmin,ymin,xmax,ymax,xx,yy)\n    area = (rpos(t)-lpos(t))*(upos(t)-dpos(t))\n#    print(t,area)\n    if area < ans:\n        ans = area\n\nprint(ans)\n    \n\n\n\n\n\n\n\n\n\n\n"]
["import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nla, ra, ta = ria()\nlb, rb, tb = ria()\nif ta > tb:\n    la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\n\ngc = gcd(tb, ta)\nif gc == 1:\n    print(min(ra - la + 1, rb - lb + 1))\n    return\n\n\ndef get(st):\n    nonlocal la, ra, ta, lb, rb, tb\n    lc = la + st\n    rc = ra + st\n    return max(min(rc, rb) - max(lc, lb) + 1, 0)\n\n\nsta = la // gc\nstb = lb // gc\nfna = ra // gc\nfnb = rb // gc\n\nmx = 0\n\nmx = max(mx, get((stb - sta) * gc))\nmx = max(mx, get((stb - sta + 1) * gc))\nmx = max(mx, get((stb - sta + 2) * gc))\nmx = max(mx, get((stb - sta - 1) * gc))\nmx = max(mx, get((stb - sta - 2) * gc))\n\nmx = max(mx, get((fnb - fna) * gc))\nmx = max(mx, get((fnb - fna + 1) * gc))\nmx = max(mx, get((fnb - fna + 2) * gc))\nmx = max(mx, get((fnb - fna - 1) * gc))\nmx = max(mx, get((fnb - fna - 2) * gc))\n\n#print(stb - sta)\nprint(mx)\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nimport math\n\nla, ra, ta = mi()\nlb, rb, tb = mi()\nif la > lb:\n    la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\nlb -= la\nra -= la\nrb -= la\ndif = math.gcd(ta, tb)\ndifl = lb\n\noff1 = difl % dif\nans1 = min(ra, off1 + rb - lb) - max(0, off1) + 1\noff2 = off1 - dif\nans2 = min(ra, off2 + rb - lb) - max(0, off2) + 1\nans = max(ans1, ans2, 0)\nprint(ans)\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\ndef gcd(a,b):\n    if b==0: return a\n    return gcd(b, a%b)\n\nla,ra,ta = getIntList()\nlb,rb,tb = getIntList()\n#print(N)\ng = gcd(ta,tb)\nwa = ra-la +1\nwb = rb-lb +1\nd = la - lb\nd1 = d//g * g\n\nla -= d1\nra -= d1\nwhile la < lb:\n    la+=g\n    ra+=g\nwhile la >= lb:\n    la-=g\n    ra-=g\ndef work():\n    x0 = max(la,lb)\n    x1 = min(ra,rb)\n    r = x1-x0+1\n    return r\n\nres = 0\nres = max(work(), res)\nwhile la < lb:\n    la+=g\n    ra+=g\nres = max(work(), res)\n\nprint(res)\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n", "from math import gcd\nla,ra,ta = list(map(int,input().split()))\nlb,rb,tb = list(map(int,input().split()))\ng = gcd(ta,tb)\nra -= la\ntemp = rb-lb\nlb -= la\nlb %= g\nrb = lb+temp\ncurrent = min(rb,ra)-lb+1\nnow = min(rb,ra+g)-g+1\nprint(max(current,now,0))\n", "def inters(x1,y1,x2,y2):\n    return max(0, min(y1,y2) - max(x1,x2) + 1)\n\nfrom math import gcd\nla, ra, ta  = list(map(int, input().split()))\nlb, rb, tb  = list(map(int, input().split()))\nshift = gcd(ta, tb)\n\n\nstart = la - (la % shift)\nla -= start\nra -= start\n\nstart = lb - (lb % shift)\nlb -= start\nrb -= start\n\n\nres = max(inters(la, ra, lb+shift, rb+shift), inters(la+shift, ra+shift, lb, rb), inters(la, ra, lb, rb))\n# print(la,ra, lb,rb)\n\nprint(res)\n", "import math\n\nla, ra, ta = list(map(int, input().split()))\nlb, rb, tb = list(map(int, input().split()))\nif rb - lb < ra - la:\n    la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\nt = math.gcd(ta, tb)\n\ndef sect(k):\n    return max(0, min(rb, ra + k * t) - max(lb, la + k * t) + 1)\n\nans = max(sect(x) for x in [(rb - ra) // t, (lb - la + t - 1) // t])\nprint(ans)\n", "from collections import defaultdict\nfrom fractions import gcd\ndef read_line():\n    return [int(x) for x in input().split()]\n\nla, ra, ta = read_line()\nlb, rb, tb = read_line()\n\n\ndef check(la, ra, ta, lb, rb, tb):\n  if la > lb:\n      la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\n\n# print(\"{}--{}, {}--{}\".format(la, ra, lb, rb))\n    \n  la, ra = 0, ra-la\n  lb, rb = lb-la, rb-la\n\n# print(\"{}--{}, {}--{}\".format(la, ra, lb, rb))\n\ndef bf_solve(la, ra, ta, lb, rb, tb):\n    ##p = ta*tb // gcd(ta, tb)\n    A = [False for _ in range(tb)]\n    for i in range(la, ra+1):\n        A[i] = True\n    A = A * (tb // gcd(ta, tb))\n    \n    B = [False for _ in range(tb)] \n    for i in range(lb, rb+1):\n        B[i] = True\n    B = B * (ta // gcd(ta, tb))\n    # find longest common seq:\n    streak = 0\n    mx = 0\n    A.append(False)\n    B.append(False)\n    for a, b in zip(A, B):\n        if not(a and b):\n            mx = max(mx, streak)\n            streak = 0\n        else:\n            streak += 1\n    return mx\n\ndef solve(la, ra, ta, lb, rb, tb):\n    if la > lb:\n        la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\n\n    # print(\"{}--{}, {}--{}\".format(la, ra, lb, rb))\n\n    old_la = la\n    la, ra = 0, ra-old_la\n    lb, rb = lb-old_la, rb-old_la\n    # print(\"{}--{}, {}--{}\".format(la, ra, lb, rb))\n    # nonlocal la\n    # nonlocal lb\n    # nonlocal ra\n    # nonlocal rb\n    \n    if gcd(ta, tb) == 1:\n        return min(ra-la+1, rb-lb+1)\n    d = gcd(ta, tb)\n    dst = rb - lb\n    lb = lb % d\n    rb = lb + dst\n    # print(\"{}--{}, {}--{}\".format(la, ra, lb, rb))\n\n    both_start = max(la, lb)\n    both_end = min(ra, rb)\n    # print(\"common {}--{}\".format(both_start, both_end))\n    res_cand = max(both_end - both_start + 1, 0)\n\n    lb -= d\n    rb -= d\n    assert lb < 0\n    both_start = max(la, lb)\n    both_end = min(ra, rb)\n    # print(\"{} __ {}, {} __ {}\".format(la, ra, lb, rb))\n    # print(\"common {} __ {}\".format(both_start, both_end))\n    res_cand2 = max(both_end - both_start + 1, 0)\n    return max(res_cand, res_cand2)\n\nprint(solve(la, ra, ta, lb, rb, tb))\n# return\n    \n# print(solve())\n\n\ndef check(la, ra, ta, lb, rb, tb):\n  A = solve(la, ra, ta, lb, rb, tb)\n  B = bf_solve(la, ra, ta, lb, rb, tb)\n\n  assert A == B, (A, B)\n\n# for ta in range(2, 10):\n#     for tb in range(2, 10):\n#         for la in range(ta):\n#             for ra in range(la, ta):\n#                 for lb in range(tb):\n#                     for rb in range(lb, tb):\n#                         print(la, ra, ta, lb, rb, tb)\n#                         check(la, ra, ta, lb, rb, tb)\n    \n", "def gcd(x,y):\n    if(y==0):\n        return x\n    return gcd(y,x%y)\n\n\nla,ra,ta = list(map(int,input().split()))\n\nlb,rb,tb = list(map(int,input().split()))\n\ngcd1 = gcd(ta,tb)\nluca = ra - la + 1\nlucb = rb - lb + 1\nif((la - lb) % gcd1 == 0):\n    print(min(luca,lucb))\nelse:\n    \n    #print(luca,lucb)\n    op1 = lucb - (la - lb) % gcd1\n    op2 = luca - (lb - la) % gcd1\n    opf = max(op1,op2,0)\n    \n    print(min(opf,luca,lucb))\n", "from math import gcd\n\nC = lambda x, y: (x + y - 1)//y\n\nl0, r0, t0 = map(int, input().split())\nl1, r1, t1 = map(int, input().split())\ng = gcd(t0, t1)\nc = [0] * 4\n\ni = min((r1 - r0)//g, (l1 - l0)//g)\nif i >= C(l1 - r0, g):\n    c[0] = r0 - l1 + g*i + 1\n\ni = min((r0 - r1)//g, (l0 - l1)//g)\nif i >= C(l0 - r1, g):\n    c[1] = r1 - l0 + g*i + 1\n\ni = min((r1 - r0)//g, (r1 - l0)//g)\nif i >= max(C(l1 - r0, g), C(l1 - l0, g)):\n    c[2] = r0 - l0 + 1\n\ni = min((r0 - r1)//g, (r0 - l1)//g)\nif i >= max(C(l0 - r1, g), C(l0 - l1, g)):\n    c[3] = r1 - l1 + 1\n\n# print(c)\nprint(max(c))", "l1,r1,t1=list(map(int,input().split()))\nl2,r2,t2=list(map(int,input().split()))\n#a=list(map(int,input().split()))\n\ndef gcd(a,b):\n    if a>b: a,b=b,a\n    while a>0:\n        b=b%a\n        a,b=b,a\n    return b\n\n\nd=gcd(t1,t2)\n\ndef answer(x1,d1,x2,d2):\n    if x1>x2:\n        x1,x2,d1,d2=x2,x1,d2,d1\n    d1=d1-(x2-x1)\n    if d1<0: d1=0\n    return min(d1,d2)\n\nd1=r1-l1+1\nd2=r2-l2+1\n\nl1=l1%d\nl2=l2%d\n\nif l1>l2:\n    l1,l2,d1,d2=l2,l1,d2,d1\n\nans1=answer(l1,d1,l2,d2)\nans2=answer(l1+d,d1,l2,d2)\n\nprint(max(ans1,ans2))\n", "def euclid(data):\n    a=data[0]\n    for b in data[1:]:\n        if(b<a):\n            a,b=b,a\n        while(1):\n            r=b%a\n            if(r==0):\n                break\n            else:\n                b=a\n                a=r\n    return a\n\n\n\nla,ra,ta=list(map(int,input().split()))\nlb,rb,tb=list(map(int,input().split()))\n\nif(la < lb):\n    la,lb=lb,la\n    ra,rb=rb,ra\n    ta,tb=tb,ta\n\ngcd=euclid([ta,tb])\ntmp=(la-lb) - gcd*((la - lb)//gcd)\n\nprint( max( [0, min([ra-la+tmp,rb-lb]) -tmp +1 , min([ra-la,rb-lb + gcd-tmp]) -(gcd - tmp) +1]))\n", "la, ra, ta = list(map(int, input().split()))\nlb, rb, tb = list(map(int, input().split()))\na, b = ta, tb\nwhile b:\n\ta, b = b, a % b\nra -= la // a * a\nla %= a\nrb -= lb // a * a\nlb %= a\nprint(max(min(ra, rb) + 1 - max(la, lb), min(ra + a, rb) + 1 - max(la + a, lb), min(ra, rb + a) + 1 - max(la, lb + a), 0))\n", "import sys\nimport math\n\ninp = iter(map(int, sys.stdin.read().split()))\n\nla = next(inp)\nra = next(inp)\nta = next(inp)\n\nlb = next(inp)\nrb = next(inp)\ntb = next(inp)\n\nif la > lb:\n\tla, lb = lb, la\n\tra, rb = rb, ra\n\tta, tb = tb, ta\n\ndef area(l1, r1, l2, r2):\n\t#print('area of ', l1, r1, 'and', l2, r2)\n\tl = max(l1, l2)\n\tr = min(r1, r2)\n\treturn r-l+1\n\nd = lb-la\n#print('diff', d)\ng = math.gcd(ta, tb)\nshift = d//g*g\n\nans = 0\n\nfor d in range(-100, 101):\n\tans = max(ans, area(la, ra, lb-shift-g*d, rb-shift-g*d))\n\nprint(ans)\n", "def gcd(a, b):\n\n    if b==0: return a\n    return gcd(b, a%b)\n\ndef lucky(l_a, r_a, t_a, l_b, r_b, t_b):\n\n    if r_b - l_b > r_a - l_a:\n\n        thing = [l_a, r_a, l_b, r_b]\n\n        l_a = thing[2];\n        r_a = thing[3]\n        l_b = thing[0]\n        r_b = thing[1]\n\n    if l_a == l_b or r_a == r_b:\n\n        return r_b - l_b + 1\n\n    else:\n\n        gcdt = gcd(t_a, t_b)\n\n        M = gcdt - ((l_a-l_b)%gcdt) ## min((l_a-l_b)%gcdt, gcdt - (l_a-l_b)%gcdt)\n        if M%gcdt == 0: M=0\n        ##print('M: ', M)\n        overhang = max(M + (r_b - l_b + 1) - (r_a - l_a + 1), 0)\n        ##print('Overhang: ', overhang)\n        overlap = max(r_b - l_b + 1 - overhang, 0)\n        ##print('Overlap: ', overlap)\n\n        N = gcdt - ((r_b-r_a)%gcdt) ## min((r_a-r_b)%gcdt, gcdt - (r_a-r_b)%gcdt)\n        if N%gcdt == 0: N=0\n        overhang = max(0, N + (r_b - l_b + 1) - (r_a - l_a + 1))\n        overlap = max(overlap, max(0, r_b - l_b + 1 - overhang))\n\n        ##print(M, N, ((l_a-l_b)%gcdt))\n    \n        return overlap\n    \nwhile True:\n    \n    A = input().split()\n\n    l_a = int(A[0])\n    r_a = int(A[1])\n    t_a = int(A[2])\n\n    B = input().split()\n\n    l_b = int(B[0])\n    r_b = int(B[1])\n    t_b = int(B[2])\n\n    print(lucky(l_a, r_a, t_a, l_b, r_b, t_b))\n\n    break\n\n## stress test\n\n##for l_a in range(0, 10):\n##    for r_a in range(l_a, 10):\n##        for t_a in range(max(2, r_a+1), 10):\n##            for l_b in range(0, 10):\n##                for r_b in range(l_b, 10):\n##                    for t_b in range(max(2, r_b+1), 10):\n##\n##                        program_answer = lucky(l_a, r_a, t_a, l_b, r_b, t_b)\n##\n##                        if r_a - l_a + 1 >= t_a or r_b - l_b + 1 >= t_b: continue\n##\n##                        max_overlap = 0\n##                        current_overlap = 0\n##\n##                        for i in range(0, 100):\n##\n##                            if i%t_a >= l_a and i%t_a <= r_a and i%t_b >= l_b and i%t_b <= r_b:\n##\n##                                current_overlap += 1\n##\n##                            else:\n##\n##                                current_overlap = 0\n##\n##                            max_overlap = max(max_overlap, current_overlap)\n##\n##                        if max_overlap != program_answer:\n##\n##                            print(program_answer)\n##                            print(l_a, r_a, t_a, l_b, r_b, t_b)\n                            \n\n", "import math\n\na1, b1, c1 = list(map(int, input().split(' ')))\na2, b2, c2 = list(map(int, input().split(' ')))\n\nx = math.gcd(c1, c2)\n\ndelta1 = (a1 - a2)\ndelta1 = delta1 % x\nif delta1 < 0:\n  delta1 += x\n\ndelta2 = (a2 - a1)\ndelta2 = delta2 % x\nif delta2 < 0:\n  delta2 += x\n\n\na1 = b1 - a1 + 1\na2 = b2 - a2 + 1\n\nsol = max(min(a1 - delta2, a2), min(a1, a2 - delta1))\n\nprint(max(0, sol))\n", "from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\n\ndef gcd(a, b):\n    if not b:\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef solution(la, ra, ta, lb, rb, tb):\n    g = gcd(ta, tb)\n    d = (lb - la) % g\n    return min(ra - la + 1 - d, rb - lb + 1)\n\n\nla, ra, ta = map(int, stdin.readline().split())\nlb, rb, tb = map(int, stdin.readline().split())\n\n\nans = max(solution(la, ra, ta, lb, rb, tb), solution(lb, rb, tb, la, ra, ta))\nstdout.write(str(max(0, ans)))", "import math\n\nla, ra, ta = map(int, input().split())\nlb, rb, tb = map(int, input().split())\n\ndef f(la, ra, ta, lb, rb, tb):\n\td = la - lb\n\tx = math.gcd(ta, tb)\n\td = ((d % x) + x) % x\n\treturn min(ra, rb - d)\n\nra = ra - la + 1\nrb = rb - lb + 1\nprint(max([0, f(la, ra, ta, lb, rb, tb), f(lb, rb, tb, la, ra, ta)]))", "a = input().split()\nb = input().split()\nla = int(a[0])\nra = int(a[1])\nta = int(a[2])\nlb = int(b[0])\nrb = int(b[1])\ntb = int(b[2])\n\ndef gcd(x,y):\n    if x*y == 0:\n        return x+y\n    else:\n        if x>y:\n            return gcd(x%y,y)\n        else:\n            return gcd(x,y%x)\n\ng = gcd(ta,tb)\nif (la % g >= lb % g):\n    temp1 = min(rb-((la%g) - (lb%g))-lb+1,ra-la+1)\n    temp2 = min(ra-la+1-(g-(la%g) + (lb%g)),rb-lb+1)\n    best = max(temp1,temp2,0)\nelse:\n    temp1 = min(ra-((lb%g) - (la%g))-la+1,rb-lb+1)\n    temp2 = min(rb-lb+1-(g-(lb%g) + (la%g)),ra-la+1)\n    best = max(temp1,temp2,0)\nprint(best)", "import math\n\ndef gcd(a, b):\n    \"\"\"Returns the greatest common divisor of a and b.\n    Should be implemented using recursion.\n\n    >>> gcd(34, 19)\n    1\n    >>> gcd(39, 91)\n    13\n    >>> gcd(20, 30)\n    10\n    >>> gcd(40, 40)\n    40\n    \"\"\"\n    if b > a:\n        return gcd(b, a)\n\n    if a % b == 0:\n        return b\n\n    return gcd(b, a % b)\n\n\n(la, ra, ta) = [int(s) for s in input().split(\" \")]\n(lb, rb, tb) = [int(s) for s in input().split(\" \")]\n\ndelta = gcd(ta, tb)\n# print(delta)\n\ndef overlap(al, ar, bl, br):\n    return max(0, min(ar, br) - max(al, bl) + 1)\n\ndef eval(fst_, snd_):\n    result_ = 0\n\n    k1 = math.ceil(abs(fst_[0] - snd_[0])/delta)\n    k2 = abs(fst_[0] - snd_[0]) // delta\n\n    for k in (k1, k2):\n        pos_sndl = snd_[0]\n        pos_sndr = snd_[1]\n        pos_fstl = k * delta + fst_[0]\n        pos_fstr = k * delta + fst_[1]\n        intersection = overlap(pos_sndl, pos_sndr, pos_fstl, pos_fstr)\n        # print(intersection)\n        # print(pos_sndl, pos_sndr, pos_fstl, pos_fstr, intersection)\n        result_ = max(result_, intersection)\n\n\n    # pos_sndl = snd_[0]\n    # pos_sndr = snd_[1]\n    # pos_fstl = fst_[0]\n    # pos_fstr = fst_[1]\n    # intersection = overlap(pos_sndl, pos_sndr, pos_fstl, pos_fstr)\n    # result_ = max(result_, intersection)\n    # # print(delta)\n    # # print(intersection)\n    # snd_k = (snd_[1] - fst_[0]) // delta + 1\n    # fst_k = (snd_[0] - fst_[1]) // delta -1\n    #\n    # print(fst_k, snd_k)\n    #\n    # for k in range(fst_k, snd_k):\n    #     pos_sndl = snd_[0]\n    #     pos_sndr = snd_[1]\n    #     pos_fstl = k * delta + fst_[0]\n    #     pos_fstr = k * delta + fst_[1]\n    #     intersection = overlap(pos_sndl, pos_sndr, pos_fstl, pos_fstr)\n    #     # print(intersection)\n    #     # print(pos_sndl, pos_sndr, pos_fstl, pos_fstr, intersection)\n    #     result_ = max(result_, intersection)\n\n    return result_\n\n\nfst_ = (la, ra, ta)\nsnd_ = (lb, rb, tb)\n\nresult = max(eval(fst_, snd_), eval(snd_, fst_))\nprint(result)", "import math\n\ndef main():\n    la, ra, ta = [int(c) for c in input().split()]\n    lb, rb, tb = [int(c) for c in input().split()]\n\n    if lb < la:\n        la, lb = lb, la\n        ra, rb = rb, ra\n        ta, tb = tb, ta\n\n    gcd = math.gcd(ta, tb)\n    lena, lenb = ra - la + 1, rb - lb + 1\n    \n    d = lb - la\n    diff = d - (d // gcd) * gcd\n    cur = lena - diff\n\n    ans = max(0, min(cur, lenb))\n\n    diff -= gcd\n    diff = -diff\n    cur = lenb - diff\n    ans = max(ans, min(lena, cur))\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\n\nr = lambda: list(map(int, input().split()))\na, b = r(), r()\nc = b[0] > a[0]\nla, ra, ta = a if c else b\nlb, rb, tb = b if c else a\n\ng = gcd(ta, tb)\nlna, lnb = ra - la + 1, rb - lb + 1\nd = lb - la - (lb - la) // g * g\nprint(max(0, min(lna - d, lnb), min(lna, lnb - g + d)))\n", "from math import gcd\n\n\ndef solve(la, ra, ta, lb, rb, tb):\n    if la > lb:\n        la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\n    da = ra-la\n    db = rb-lb\n    ans = 0\n    dist = lb - la\n    g = gcd(ta, tb)\n    dist %= g\n    if dist == 0:\n        return min(da+1, db+1)\n    la, ra = lb - dist, lb - dist + da\n    ans = max(ans, 1+min(rb, ra) - lb)\n    ans = max(ans, 1+min(rb, ra+g) - (la+g))\n    return ans\n\n\ndef main():\n    la, ra, ta = [int(i) for i in input().split()]\n    lb, rb, tb = [int(i) for i in input().split()]\n    print(solve(la, ra, ta, lb, rb, tb))\n\n\nmain()\n", "from math import gcd\n\nla, ra, ta = list(map(int, input().split()))\nlb, rb, tb = list(map(int, input().split()))\nk = gcd(ta, tb)\nd1 = (la - lb)\nd1 %= k\nif d1 < 0:\n    d1 += k\nd2 = (lb - la)\nd2 %= k\nif d2 < 0:\n    d2 += k\nla = ra - la + 1\nlb = rb - lb + 1\nans = max(0, min(la - d2, lb), min(la, lb - d1))\nprint(ans)\n", "import math\nla, ra, ta = map(int, input().split())\nlb, rb, tb = map(int, input().split())\nx = math.gcd(ta,tb)\nd = la-lb\nprint(max(min(ra-la+1,rb-lb+1-d%x), min(rb-lb+1,ra-la+1-(-d)%x),0))", "# import time\n# start_time = int(round(time.time() * 1000))\n\nfrom math import gcd\n\n\n\n\ndef solve(la, ra, ta, lb, rb, tb):\n\n    m = gcd(ta, tb)\n    m1 = la % m\n    k = (lb - m1 + m - 1) // m\n    y = k*m + m1\n\n    return max(0, min(ra-la+1, rb-y+1))\n\n\n\nla, ra, ta = list(map(int, input().split()))\nlb, rb, tb = list(map(int, input().split()))\n    \n\n# print(solve(la, ra, ta, lb, rb, tb))\n# print(solve(lb, rb, tb, la, ra, ta))\n\nprint(max(solve(la, ra, ta, lb, rb, tb), solve(lb, rb, tb, la, ra, ta)))\n\n\n\n\n# end_time = int(round(time.time() * 1000))\n# print('Execution Time : ', (end_time - start_time), 'ms')\n"]
["def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n, k = map(int, input().split())\n    \n    cnt = [0] * k\n    for i in range(n):\n        cnt[int(input()) - 1] += 1\n    \n    dead = 0\n    ans = 0\n    \n    for i in cnt:\n        if i & 1:\n            dead += 1\n            ans += i - 1\n        else:\n            ans += i\n    \n    if n & 1:\n        print(ans + (dead + 1) // 2)\n    else:\n        print(ans + dead // 2)\n    \n    return 0\n\nmain()", "n,k=map(int,input().split())\nl1=[0]*k\nfor i in range(n):\n    x=int(input())\n    l1[x-1]+=1\nans=0\nodds=0\nfor item in l1:\n    if item%2==0:\n        ans+=item\n    else :\n        ans+=(item-1)\n        odds+=1\nif n%2==0:\n    print(ans+odds//2)\nelse :\n    print(ans+(odds-1)//2+1)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\nfrom collections import Counter\n\n\nn, k  = getList()\n\n\nstu = []\nfor i in range(n):\n    d = getN()\n    stu.append(d)\n\ncnt = Counter(stu)\n# print(cnt)\nans = 0\nfor v in cnt.values():\n    ans += (v // 2) * 2\n\nans += (n - ans + 1) // 2\n\nprint(ans)", "import sys\n\nn, k = list(map(int, sys.stdin.readline().strip().split()))\nA = [0] * (k+1)\nfor i in range (0, n):\n    a = int(sys.stdin.readline().strip())\n    A[a] = A[a] + 1\nx = 0\ny = 0\nfor i in range (1, k + 1):\n    x = x + A[i] // 2\n    y = y + A[i] % 2\nprint(2 * x + (y+1) // 2)", "n, k = [int(i) for i in input().split()]\ns = [0]*k\nfor i in range(n):\n    s[int(input())-1]+=1\np = 0\nfor i in s:\n    p+=(i%2)\nprint(n-p//2)", "n,k = map(int,input().split())\nfrom collections import defaultdict\nk = (n+1)//2\nfull = 0\nodd = 0\ncount = defaultdict(int)\nfor x in range(n):\n    x = int(input())\n    count[x]+=1\nfor key,v in count.items():\n    full += v//2\n    odd += v%2\n\ntotal = 0\nstep = min(k,full)\n\nk-=step\ntotal+=step*2\nstep = min(odd,k)\n\ntotal+=step\nprint (total) ", "a, b = list(map(int,input().split()))\nn = [0] * b\nfor i in range(a):\n    k = int(input())\n    n[k - 1] += 1\ncnt = 0\nfor x in n:\n    cnt += x % 2\nprint(a - cnt // 2)", "n,k = list(map(int,input().split()))\nfavdrs = [0] * (k+1)\nfor i in range(n):\n    temp = int(input())\n    favdrs[temp] += 1\nnum = 0\nfor i in range(k+1):\n    if favdrs[i] % 2 == 1:\n        num += 1\nprint(n - num // 2)\n", "n, k = [int(i) for i in input().split()]\ndic = [0] * (k+1) \nfor j in range(n):\n    a = int(input())\n    dic[a] += 1\nsets = 0\nfor d in dic:\n    sets += d//2\n\ntot = (n+1)//2\nprint(sets + tot )\n", "n, k = list(map(int, input().split()))\ncnt = [0] * k\nfor i in range(n):\n    x = int(input())\n    cnt[x - 1] += 1\nans = 0\np = 0\nfor i in range(k):\n    p += cnt[i] // 2\n    ans += cnt[i] // 2 * 2\nans += (n + 1) // 2 - p\nprint(ans)\n", "from collections import defaultdict\n\nn, k = [int(i) for i in input().split()]\n\nx = []\nv = defaultdict(int)\nfor i in range(n):\n    v[int(input())] += 1\na = 0\n\nfor i in v.values():\n    a += i // 2\n\nprint(2 * a + (((n+1)//2)-a))", "from math import ceil\nn, k = map(int, input().split())\ndrinks = [False for i in range(k + 1)]\nsatisfied = 0\nfor i in range(n):\n    d = int(input())\n    if drinks[d]:\n        satisfied += 2\n    drinks[d] = not drinks[d]\nunsat = len(list(filter(lambda x: x, drinks)))\nprint(satisfied + ceil(unsat / 2))", "n,k=list(map(int,input().split()))\nd=[0]*(k+1)\nfor i in range(n):\n    d[(int(input()))]+=1\nr=0\nans=0\nfor i in d:\n    ans+=(i//2)*2\n    r+=i%2\nprint(ans+-(-r//2))\n", "n, k = list(map(int, input().split()))\na = []\nfor _ in range(n):\n\tz = int(input())\n\ta.append(z)\nif n % 2:\n\ta.append(0)\na.sort()\ni = 0\nres = 0\nost = 0\nwhile i < len(a) - 1:\n\tif a[i] == a[i + 1]:\n\t\ti += 2\n\t\tres += 2\n\telse:\n\t\ti += 1\n\t\tost += 1\nif ost % 2:\n\tprint(res + (ost + 1) // 2)\nelse:\n\tprint(res + ost // 2)\n", "n, k = map(int, input().split())\nd = [0]*(k+1)\nfor i in range(n):\n    a = int(input())\n    d[a] += 1\nd.sort(reverse=True)\ncount = 0\nfor i in range(k):\n    count += d[i] - d[i]%2\n    d[i] = d[i]%2\nd.append(1)\ncount += d.count(1)//2\nprint(count)", "from math import ceil\nn, k = list(map(int, input().split()))\na = []\nfor i in range(n):\n  a.append(int(input()))\nres = 0\nd = [0] * 1024\nfor i in a:\n  d[i] += 1\nfor i in d:\n  res += 2 * (i // 2)\nres = res + ceil((n - res) / 2)\nprint(res)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef all_factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(digits-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n+1, p): \n                prime[i] = False\n        p += 1\n    return prime\n\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = False #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n, k = get_tuple()\n    li = []\n    paired = 0\n    for i in range(n):\n        x = get_int()\n        if x in li:\n            paired+=2\n            li.remove(x)\n        else:\n            li.append(x)\n    print(paired+(len(li)+1)//2)\n    \n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n,k=list(map(int,input().split()))\narr = [0]*k\nfor i in range(n):\n    arr[int(input())-1]+=1\nshaman=1\nans = 0\nfor i in range(k):\n    ans += (arr[i]//2)*2\n    shaman += arr[i]%2\nprint(ans + (shaman//2))\n\n\n\n", "n, k = map(int, input().split())\n\na = []\ns = set()\nans = 0\nk = 0\nfor i in range(n):\n    a = int(input())\n    if a in s:\n        s.remove(a)\n        ans += 2\n        k += 1\n    else:\n        s.add(a)\nprint(ans + (n // 2 + n % 2) - k)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\n(n, k) = (int(i) for i in input().split())\n\nstart = time.time()\n\nb = [ 0 for i in range(k)]\n\nfor i in range(n):\n    now = int(input())-1\n    b[now] += 1\n\nost = 0\nans = 0\n\nfor i in range(k):\n    d = b[i] % 2\n    ans += b[i] - d\n    ost += d\n\nans += ost//2 + ost%2\nprint(ans)\n\nfinish = time.time()\n#print(finish - start)\n", "n,k=list(map(int,input().split()))\ndict1={}\nfor i in range(n):\n\tx=int(input())\n\ttry:\n\t\tdict1[x]+=1\n\texcept:\n\t\tKeyError\n\t\tdict1[x]=1\nans=0\nflagcount=0\nfor i in list(dict1.keys()):\n\tans+=((dict1[i])//2)*2\n\tif(dict1[i]%2!=0):\n\t\tflagcount+=1\nif(n%2==0):\n\tans+=(flagcount)//2\nelse:\n\tans+=(flagcount)//2\n\tans+=1\nprint(ans)\n\n", "from math import ceil\n\nn,k = list(map(int,input().split()))\na = [0]*k\nfor i in range(n):\n    q = int(input())\n    a[q-1] += 1\nj = 0\nans = 0\nfor i in a:\n    j += i//2\n    ans += i%2\n\nprint(n-(ans-(ceil(n/2)-j)))", "n, k = map(int, input().split())\n\nu = 0\narr = [0]*k\n\nfor i in range(n):\n    a = int(input())\n    arr[a-1] += 1\n\nfor i in range(k):\n    u += arr[i]//2\n\nprint((n+1)//2 + u)", "n, k = list(map(int, input().split()))\nl = [0] * (k + 1)\nfor i in range(n):\n    a = int(input())\n    l[a] += 1\nans = 0\ncnt = 0\nfor i in range(k + 1):\n    ans += l[i]\n    if (l[i] % 2 == 1):\n        cnt += 1\n        ans -= 1\nprint(ans + cnt // 2 + cnt % 2)\n"]
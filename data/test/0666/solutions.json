["def f(m):\n    return m * (m + 1) // 2\n\nn = int(input())\nl, r = 0, n\nwhile r - l > 1:\n    m = (r + l) // 2\n    if f(m) >= n:\n        r = m\n    else:\n        l = m\nn -= f(l)\nprint(n)", "def cel_sum(x):\n\treturn (x * (x + 1)) // 2\n\nn = int(input())\n\nleft = 0\nright = 4 * n\nwhile right - left > 1:\n\tmid = (right + left) // 2\n\tif cel_sum(mid) < n:\n\t\tleft = mid\n\telse:\n\t\tright = mid\n\nr = right\ncol = abs(n - cel_sum(r))\nprint(r - col)\n\n", "import  math\n\nN = int(input())\n\np = (-1 + math.sqrt(1 + 8 * N)) // 2\nN -= p * (p + 1) // 2\n\nif N == 0:\n    print(int(p))\nelse:\n    print(int(N))\n", "3\n\nimport math\n\nn = int(input())\nx = math.floor(math.sqrt(n*2))\n\nwhile n <= x*(x+1)//2:\n\tx -= 1\n\nans = n - x*(x+1)//2\nprint(ans)\n\n", "__author__ = 'Utena'\nimport math\nn=int(input())\ni=int(math.sqrt(n*2))\nc=0\nwhile True:\n    c=i*(i+1)//2\n    if c>=n:\n        break\n    else:i+=1\nprint(n-c+i)", "n = int(input())\nlb = 0\nrb = n\nwhile lb != rb:\n  mb = (lb + rb + 1) // 2\n  if mb * (mb + 1) // 2 < n:\n    lb = mb\n  else:\n    rb = mb - 1\nprint(n - lb * (lb + 1) // 2)", "import math\nn=int(input())-1\nx = ((8*n+1)**0.5-1)//2\ny=x*(x+1)/2\nprint(int(n-y+1))", "n = int(input())\nfrom math import sqrt\nk = (-1 + sqrt(1 + 8 * n ))//2\nif (n - (k*k + k)//2) != 0:\n    k = (n - (k*k + k)//2)\nprint(int(k))\n", "n = int(input())\nans = int((n*2)**0.5)\nwhile ans*(ans+1)//2 > n:\n\tans-=1\nif ans*(ans+1)//2 == n:\n\tprint(ans)\nelse:\n\tprint(n-ans*(ans+1)//2)", "3\n\nimport math\n\ndef f(k):\n\treturn int((k*(k-1)+2) / 2)\n\nn = int(input())\n\nD = 1 - 4*(2-2*n)\nk = int(math.floor((1 + math.sqrt(D)) / 2))\n\nans = n - f(k) + 1\n\nprint(ans)\n", "import collections\nimport math\n\n#n ,m = map(int, input().split())\nn = int(input())\nx = int((math.sqrt(1 + 8 * n) - 1) / 2)\nt = (x + 1) * x // 2\nif t == n:\n    print(x)\nelse:\n    print(n - t)", "def main():\n\tn = int(input())\n\tprint(solver(n))\n\ndef quadraticEqPlus(a, b, c):\n\treturn (-b + (b**2 - 4 * a * c)**0.5) / (2 * a)\n\ndef solver(n):\n\tx = int(quadraticEqPlus(0.5, -0.5, 1 - n))\n\ty = x**2 / 2 - x / 2 + 1\n\treturn int(n - y + 1)\n\nmain()\n\n", "'''\n@author: agavrikov\n'''\ndef sm(x):\n    return int(x * (x + 1) / 2)\n\nn = int(input())\nst = int(1)\nl = int(0)\nr = int(1000 * 1000 * 1000)\nwhile (l <= r):\n    mid = int((l + r) / 2)\n    #print('mid = ', mid)\n    sum = sm(mid)\n    #print('sum = ', sum)\n    if sm(mid) < n:\n        st = sum\n        l = mid + 1\n    else:\n        r = mid - 1              \nprint(n - st)\n", "import math\n\ndef fc(a, b, c) :\n\td = b * b - 4 * a * c\n\tx = (-b + math.sqrt(d)) / (2 * a)\n\treturn int(x)\n\n\nn = int(input())\nx = fc(1, 1, -2 * n)\ny = n - (1 + x) * x // 2\nif y == 0 :\n\tprint(x)\nelse :\n\tprint(y)\n", "import math\na= int(input())\nn= int(math.sqrt(2*a))\nwhile n*(n+1)/2>a:\n    n-=1\nx= a-(n*(n+1)/2)\nif x==0:\n    print(n)\nelse:\n    print(int(x))", "#!/usr/bin/env pypy\n# -*- coding: utf-8 -*-\n\nimport itertools\nimport math\n\n\ndef solve(n):\n    for m in itertools.count(math.floor(math.sqrt(2 * n) - 1.0)):\n        if 2 * n <= m * (m + 1):\n            return n - (m - 1) * m // 2\n\n\ndef __starting_point():\n    n = int(input())\n    print(solve(n))\n\n__starting_point()", "import math\n\ndef main():\n    q = int(input())\n\n    l = 1\n    r = q\n\n    while l < r - 1:\n        m = (l + r) // 2\n\n        if (m * (m - 1)) / 2 >= q:\n            r = m\n        else:\n            l = m\n\n    if q == 2:\n        print(1)\n        return\n    \n    print(q - ((l - 1) * (r - 1)) // 2)\n\ndef __starting_point():\n    main()\n__starting_point()", "def binary_search( x ):\n\n    low = 1\n    high = 1.5*10**7\n    while low < high:\n        mid = (low + high)//2\n\n        l1 = mid*(mid+1)//2\n        l2 = (mid+1)*(mid+2)//2\n        if x >= l1 and x < l2:\n            return mid\n\n        elif x < l1:\n            high = mid\n        else:\n            low = mid + 1\n\n    assert(\"error\")\n\ndef solve( x ):\n\n    #print(\"solve\",x)\n    if x == 0:\n        return 1\n\n    n = binary_search( x )\n    #print(\"n =\",n)\n\n    return int(x+1-n*(n+1)//2)\n\ndef __starting_point():\n\n    x = int( input() )\n    print( solve(x-1) )\n__starting_point()", "n=int(input())\nimport math\nans=((math.sqrt(1+8*n)-1)/2)\nif ans%1==0:\n    print(int(ans))\nelse:\n    ans=int(ans)\n    ans=(ans*ans+ans)/2\n    print(int(n-ans))\n", "n = int(input())\na, b = 0, n\nwhile a < b - 1:\n    c = (a + b) // 2\n    if c * (c + 1) // 2 < n:\n        a = c\n    else:\n        b = c\nprint(n - a * (a + 1) // 2)", "\n\ndef __starting_point():\n    n = int(input())\n    res = ((-1)+(((8*n)+1)**(1/2)))/2\n    if res == int(res)/1:\n        print(int(res))\n    else:\n        k = int(res)\n        k = (k*(k+1))//2\n        p = n - k\n        print(p)\n            \n            \n        \n\n__starting_point()", "n = int(input())\nnumber = 1\nwhile n > number:\n    n -= number\n    number += 1\nprint(n)", "#!/usr/bin/env python3\n\n\ndef isqrt(n):\n    if n == 0:\n        return 0\n    x = 2 ** sum(divmod(n.bit_length(), 2))\n    while True:\n        y = x + n // x\n        y //= 2\n        if y >= x:\n            return x\n        x = y\n\n\ndef triangle_number(n):\n    return n * (n + 1) // 2\n\n\ndef find_seq(position):\n    size = isqrt(2 * position)\n    while triangle_number(size) < position:\n        size += 1\n    size -= 1\n    return position - triangle_number(size)\n\n\ndef main():\n    print(find_seq(int(input())))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import sqrt\nn = int(input())\nx = (-1+sqrt(1+8*n))/2\nv = (2+int(x)-1)/2*int(x)\nif (v==n): print(int(x))\nelse: print(int(n-v))\n", "from math import *\nn = int(input())\nper = int(sqrt(n*2))\nk = per * (per+1) / 2 \nif k < n:\n    n = n-k\n    print(int(n))\nelse:\n    print(int(per - (k - n)))"]
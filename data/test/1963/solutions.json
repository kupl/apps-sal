["n = int(input()) + 1\nt = [1] + list(map(int, input().split())) + [1]\np = [True] * n\ns, q = 0, list(range(1, n))\nfor i in range(1, n):\n    if p[i]:\n        a = b = i\n        d = t[i]\n        if d == 1: \n            s, q = n - 2, [1]\n            break\n        while t[a - 1] % d == 0: a -= 1\n        while t[b + 1] % d == 0:\n            b += 1\n            p[b] = False\n        d = b - a\n        if d > s: s, q = d, [a]\n        elif d == s != 0: q.append(a)\nprint(len(q), s)\nprint(' '.join(map(str, q)))", "import math \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a,b:math.gcd(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\nclass SegmentTree1:\n    def __init__(self, data, default=9999999999999999999999999999999, func=lambda a,b:min(a,b)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\nn=int(input())\nl=list(map(int,input().split()))\ns2=SegmentTree(l)\ns1=SegmentTree1(l)\ns=0\ne=0\nd=dict()\nd1=dict()\ned=[]+l[::-1]\ns3=SegmentTree(ed)\ns4=SegmentTree1(ed)\nd2=dict()\nwhile(s<n):\n    if s in d1:\n        d1[s]=e-s-1\n    else:\n        d1.update({s:e-s-1})\n    if e==n:\n        e-=1\n        s+=1\n    if s2.query(s,e)==s1.query(s,e):\n        e+=1\n    else:\n        s+=1\n    if s>e:\n        e+=1\n    if e>n-1:\n        e=n\nif s in d1:\n    d1[s]=e-s-1\nelse:\n    d1.update({s:e-s-1})\ne=0\ns=0\nwhile(s<n):\n    if s in d2:\n            d2[n-1-s]=e-s-1\n    else:\n            d2.update({n-1-s:e-s-1})\n    if e==n:\n        e-=1\n        s+=1\n    if s3.query(s,e)==s4.query(s,e):\n        e+=1\n    else:\n        s+=1\n    if s>e:\n        e+=1\n    if e>n-1:\n        e=n\nif s in d2:\n    d2[n-1-s]=e-s-1\nelse:\n    d2.update({n-1-s:e-s-1})\nans=0\n#print(d1,d2)\nfor j in d1:\n    if j in d2: \n        if 0<=j+d1[j]<n and 0<=j-d2[j]<n and 0<=j<n and s2.query(j,j+d1[j])==s2.query(j-d2[j],j):\n            d1[j]+=d2[j]\n    ans=max(ans,d1[j])\nfor j in d2:\n    ans=max(ans,d2[j])\ns=0\ne=s+ans\nw=[] \nwhile(e<n):\n    if s2.query(s,e)==s1.query(s,e):\n        w.append(s+1)\n    s+=1\n    e+=1\nprint(len(w),ans)\nprint(*w,sep=' ')"]
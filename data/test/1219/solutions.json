["N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\nfor A in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\nprint([v,y][N>'1'])", "N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\nfor A in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\nprint([v,y][N>'1'])", "N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\nfor A in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\nprint([v,y][N>'1'])\n", "from heapq import nsmallest\nfrom math import inf as _inf\nimport sys as _sys\n\n\ndef main():\n    n, = _read_ints()\n    a = tuple(_read_ints())\n    result = find_max_power_can_make(a)\n    print(result)\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef find_max_power_can_make(heroes_powers):\n    heroes_powers = tuple(heroes_powers)\n    assert heroes_powers\n    \n    abs_powers_sum = sum(map(abs, heroes_powers))\n    \n    if len(heroes_powers) <= 9:\n        return _compute_using_brute_force(heroes_powers)\n    \n    zeros_n = heroes_powers.count(0)\n    if zeros_n >= 2:\n        return abs_powers_sum\n    assert zeros_n <= 1\n    \n    n = len(heroes_powers)\n    if n % 3 == 1 % 3:\n        can_invert_mod_3 = 0\n    elif n % 3 == 2 % 3:\n        can_invert_mod_3 = 2\n    else:\n        assert n % 3 == 3 % 3\n        can_invert_mod_3 = 1\n    \n    result = -_inf\n    \n    for is_zero_positive in (False, True):\n        \n        if zeros_n == 0 or is_zero_positive:\n            signs = [1 if x >= 0 else -1 for x in heroes_powers]\n        else:\n            signs = [1 if x > 0 else -1 for x in heroes_powers]\n        \n        negative_n = signs.count(-1)\n        have_pair_of_same = any(signs[i] == signs[i + 1] for i in range(len(signs) - 1))\n        is_trivial = not (not have_pair_of_same and negative_n % 3 == can_invert_mod_3)\n        \n        if is_trivial:\n            if negative_n % 3 == can_invert_mod_3:\n                result = max(result, abs_powers_sum)\n                continue\n            negative_to_inverse_1 = negative_n\n            while negative_to_inverse_1 % 3 != can_invert_mod_3:\n                negative_to_inverse_1 -= 1\n            negative_to_inverse_2 = negative_to_inverse_1 + 3\n        else:\n            negative_to_inverse_1 = negative_n - 3\n            negative_to_inverse_2 = negative_n + 3\n            min_pos = max(\n                heroes_powers,\n                key=lambda x: (x >= 0 if is_zero_positive else x > 0, -abs(x))\n            )\n            max_neg = max(\n                heroes_powers,\n                key=lambda x: (x < 0 if is_zero_positive else x <= 0, x)\n            )\n            result = max(result, abs_powers_sum - 2 * abs(min_pos) - 2 * abs(max_neg))\n        \n        if negative_to_inverse_1 >= 0:\n            negative_to_remain_n = negative_n - negative_to_inverse_1\n            assert negative_to_remain_n > 0\n            negative_powers = tuple([x for x in heroes_powers if (x < 0 if is_zero_positive else x <= 0)])\n            if negative_to_remain_n <= len(negative_powers):\n                negative_to_remain = nsmallest(\n                    negative_to_remain_n, negative_powers, key=abs\n                )\n                result = max(result, abs_powers_sum - 2 * abs(sum(negative_to_remain)))\n        \n        if negative_to_inverse_2 <= n:\n            positive_to_inverse_n = negative_to_inverse_2 - negative_n\n            assert positive_to_inverse_n > 0\n            positive_powers = tuple([x for x in heroes_powers if (x >= 0 if is_zero_positive else x > 0)])\n            if positive_to_inverse_n <= len(positive_powers):\n                positive_to_inverse = nsmallest(\n                    positive_to_inverse_n, positive_powers, key=abs\n                )\n                result = max(result, abs_powers_sum - 2 * sum(positive_to_inverse))\n    \n    return result\n\n\ndef _compute_using_brute_force(seq):\n    n = len(seq)\n    if n == 1:\n        return seq[0]\n    return max(\n        _compute_using_brute_force(seq[:i] + (-(seq[i] + seq[i+1]),) + seq[i+2:])\n        for i in range(n - 1)\n    )\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\nfor A in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\nprint([v,y][N>'1'])\n\n", "from heapq import nsmallest\nfrom math import inf as _inf\nimport sys as _sys\n\n\ndef main():\n    n, = _read_ints()\n    a = tuple(_read_ints())\n    result = find_max_power_can_make(a)\n    print(result)\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return map(int, _read_line().split())\n\n\ndef find_max_power_can_make(heroes_powers):\n    heroes_powers = tuple(heroes_powers)\n    assert heroes_powers\n\n    abs_powers_sum = sum(map(abs, heroes_powers))\n\n    if len(heroes_powers) <= 9:\n        return _compute_using_brute_force(heroes_powers)\n\n    zeros_n = heroes_powers.count(0)\n    if zeros_n >= 2:\n        return abs_powers_sum\n    assert zeros_n <= 1\n\n    n = len(heroes_powers)\n    if n % 3 == 1 % 3:\n        can_invert_mod_3 = 0\n    elif n % 3 == 2 % 3:\n        can_invert_mod_3 = 2\n    else:\n        assert n % 3 == 3 % 3\n        can_invert_mod_3 = 1\n\n    result = -_inf\n\n    for is_zero_positive in (False, True):\n\n        if zeros_n == 0 or is_zero_positive:\n            signs = [1 if x >= 0 else -1 for x in heroes_powers]\n        else:\n            signs = [1 if x > 0 else -1 for x in heroes_powers]\n\n        negative_n = signs.count(-1)\n        have_pair_of_same = any(signs[i] == signs[i + 1] for i in range(len(signs) - 1))\n        is_trivial = not (not have_pair_of_same and negative_n % 3 == can_invert_mod_3)\n\n        if is_trivial:\n            if negative_n % 3 == can_invert_mod_3:\n                result = max(result, abs_powers_sum)\n                continue\n            negative_to_inverse_1 = negative_n\n            while negative_to_inverse_1 % 3 != can_invert_mod_3:\n                negative_to_inverse_1 -= 1\n            negative_to_inverse_2 = negative_to_inverse_1 + 3\n        else:\n            negative_to_inverse_1 = negative_n - 3\n            negative_to_inverse_2 = negative_n + 3\n            min_pos = max(\n                heroes_powers,\n                key=lambda x: (x >= 0 if is_zero_positive else x > 0, -abs(x))\n            )\n            max_neg = max(\n                heroes_powers,\n                key=lambda x: (x < 0 if is_zero_positive else x <= 0, x)\n            )\n            result = max(result, abs_powers_sum - 2 * abs(min_pos) - 2 * abs(max_neg))\n\n        if negative_to_inverse_1 >= 0:\n            negative_to_remain_n = negative_n - negative_to_inverse_1\n            assert negative_to_remain_n > 0\n            negative_powers = tuple(filter(\n                lambda x: x < 0 if is_zero_positive else x <= 0, heroes_powers\n            ))\n            if negative_to_remain_n <= len(negative_powers):\n                negative_to_remain = nsmallest(\n                    negative_to_remain_n, negative_powers, key=abs\n                )\n                result = max(result, abs_powers_sum - 2 * abs(sum(negative_to_remain)))\n\n        if negative_to_inverse_2 <= n:\n            positive_to_inverse_n = negative_to_inverse_2 - negative_n\n            assert positive_to_inverse_n > 0\n            positive_powers = tuple(filter(\n                lambda x: x >= 0 if is_zero_positive else x > 0, heroes_powers\n            ))\n            if positive_to_inverse_n <= len(positive_powers):\n                positive_to_inverse = nsmallest(\n                    positive_to_inverse_n, positive_powers, key=abs\n                )\n                result = max(result, abs_powers_sum - 2 * sum(positive_to_inverse))\n\n    return result\n\n\ndef _compute_using_brute_force(seq):\n    n = len(seq)\n    if n == 1:\n        return seq[0]\n    return max(\n        _compute_using_brute_force(seq[:i] + (-(seq[i] + seq[i + 1]),) + seq[i + 2:])\n        for i in range(n - 1)\n    )\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from sys import stdin\n\ninput = stdin.readline\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    # (n + number with -1 sign)%3 == 1\n    # dp[i][j][k][l]: choose from a[:i], j = (n + num with -1 sign) mod 3,\n    # k = whether two consecutive same sign, l =  1 if last number is + else 0\n    if n == 1:\n        print(max(a[0],-a[0]))\n        return\n    NINF = -10 ** 15\n    dp = [[[[NINF] * 2 for i in range(2)] for j in range(3)] for k in range(n)]\n    dp[0][n % 3][0][1] = a[0]\n    dp[0][(n + 1) % 3][0][0] = -a[0]\n    for i in range(n-1):\n        for j in range(3):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] > NINF:\n                        dp[i+1][j][k or l == 1][1] = max(dp[i+1][j][k or l == 1][1], dp[i][j][k][l] + a[i+1])\n                        dp[i+1][(j + 1) % 3][k or l == 0][0] = max(dp[i+1][(j + 1) % 3][k or l == 0][0],\n                                                                    dp[i][j][k][l] - a[i+1])\n\n    print(max(dp[n-1][1][1][1], dp[n-1][1][1][0]))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\nINF = 10 ** 20\nDP = [-INF] * 12\nDP[1] = a[0]\nDP[5] = -a[0]\nfor elem in a[1:]:\n    newDP = []\n    newDP.append(DP[5] + elem)\n    newDP.append(DP[3] + elem)\n    newDP.append(DP[4] + elem)\n    newDP.append(DP[1] - elem)\n    newDP.append(DP[2] - elem)\n    newDP.append(DP[0] - elem)\n    newDP.append(max(DP[2] + elem, DP[8] + elem, DP[11] + elem))\n    newDP.append(max(DP[0] + elem, DP[6] + elem, DP[9] + elem))\n    newDP.append(max(DP[1] + elem, DP[7] + elem, DP[10] + elem))\n    newDP.append(max(DP[4] - elem, DP[7] - elem, DP[10] - elem))\n    newDP.append(max(DP[5] - elem, DP[8] - elem, DP[11] - elem))\n    newDP.append(max(DP[3] - elem, DP[6] - elem, DP[9] - elem))\n    DP = newDP\nif n == 1:\n    print(a[0])\nelse:\n    print(max(DP[7],DP[10]))\n", "n = int(input())\na = list(map(int, input().split()))\nif n == 1:\n    print(a[0])\n    return\ninf = float('inf')\ndp = [[[-inf, -inf, -inf] for _ in range(2)] for _ in range(n + 1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(2):\n        for k in range(3):\n            dp[i+1][j][(k+1)%3] = max(dp[i+1][j][(k+1)%3], dp[i][j][k] + a[i])\n            dp[i+1][j][(k-1)%3] = max(dp[i+1][j][(k-1)%3], dp[i][j][k] - a[i])\n    if i + 1 < n:\n        for k in range(3):\n            dp[i+2][1][(k+2)%3] = max(dp[i+2][1][(k+2)%3], dp[i][0][k] + a[i] + a[i+1])\n            dp[i+2][1][(k-2)%3] = max(dp[i+2][1][(k-2)%3], dp[i][0][k] - a[i] - a[i+1])\nans = dp[n][1][1]\nprint(ans)", "n = int(input())\na = list(map(int, input().split()))\nif n == 1:\n    print(a[0])\n    return\ninf = 1002003004005006007\ndp = [[[-inf, -inf, -inf] for _ in range(2)] for _ in range(n + 1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(2):\n        for k in range(3):\n            dp[i+1][j][(k+1)%3] = max(dp[i+1][j][(k+1)%3], dp[i][j][k] + a[i])\n            dp[i+1][j][(k-1)%3] = max(dp[i+1][j][(k-1)%3], dp[i][j][k] - a[i])\n    if i + 1 < n:\n        for k in range(3):\n            dp[i+2][1][(k+2)%3] = max(dp[i+2][1][(k+2)%3], dp[i][0][k] + a[i] + a[i+1])\n            dp[i+2][1][(k-2)%3] = max(dp[i+2][1][(k-2)%3], dp[i][0][k] - a[i] - a[i+1])\nans = dp[n][1][1]\nprint(ans)", "N = int(input())\nx, y, z, v, w = float(\"-inf\"), float(\"-inf\"), float(\"-inf\"), 0, 1\nfor A in map(int, input().split()):\n    x, y, z, v, w = max(z + A, y - A), max(x + A, z - A), \\\n                    max(y + A, x - A, v - w * A), v + w * A, -w\nprint([v, y][N > 1])", "N = int(input())\na, b, c, d, e = float(\"-inf\"), float(\"-inf\"), float(\"-inf\"), 0, 1\nfor x in map(int, input().split()):\n    a, b, c, d, e = max(c + x, b - x), max(a + x, c - x), \\\n                    max(b + x, a - x, d - e * x), d + e * x, -e\nprint([d, b][N > 1])"]
["import sys\n\ndef solve():\n      input = sys.stdin.readline\n      N, Q = map(int, input().split())\n      total = (N - 2) ** 2\n      rb = N\n      db = N\n      D = [N] * (N + 1)\n      R = [N] * (N + 1)\n      for _ in range(Q):\n            a, b = map(int, input().split())\n            if a == 1: #\u6a2a\u5411\u304d\n                  if b < db:\n                        total -= (rb - 2)\n                        for i in range(b, db): R[i] = rb\n                        db = b\n                  else:\n                        total -= (R[b] - 2)\n            else: #\u7e26\u5411\u304d\n                  if b < rb:\n                        total -= (db - 2)\n                        for i in range(b, rb): D[i] = db\n                        rb = b\n                  else:\n                        total -= (D[b] - 2)\n\n      print(total)\n\n      return 0\n\ndef __starting_point():\n      solve() \n__starting_point()", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\nclass BIT():\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316, 1-index\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n+1)\n\n    #bit_index\u306bx\u3092O(log(n))\u3067\u52a0\u7b97\u3059\u308b\n    def add(self,i,x):\n        #if(i<=0 or i>n):return i\u306b0\u4ee5\u4e0b\u306e\u6570\u5b57\u306f\u4ee3\u5165\u3057\u306a\u3044\n        while i <= self.n:\n            self.bit[i] += x\n            i += (i & -i)\n    #bit_1 + bit_2 + \u2026  + bit_n \u3092O(log(n))\u3067\u6c42\u3081\u308b\n    def sum(self,i):\n        s = 0\n        #i\u306b0\u4ee5\u4e0b\u306e\u6570\u5b57\u306f\u4ee3\u5165\u3057\u306a\u3044\u3002\n        while i > 0:\n            s+=self.bit[i]\n            i -= (i & -i)\n        return s\n    \n    def rangesum(self,i,k):\n        return self.sum(k) - self.sum(i)\n    #a_1 + a_2 + \u2026 + a_i >= x \u3068\u306a\u308b\u3088\u3046\u306a\u6700\u5c0f\u306ei\u3092\u6c42\u3081\u308b(a_k >= 0)\n    #x\u304c0\u4ee5\u4e0b\u306e\u5834\u5408\u306f\u8a72\u5f53\u3059\u308b\u3082\u306e\u306a\u3057\u21920\u3092\u8fd4\u3059\n    def lower_bound(self,x):\n        if x <= 0:\n            return 0\n        else:\n            i = 0\n            r = 1\n            #\u6700\u5927\u3068\u3057\u3066\u3042\u308a\u3046\u308b\u533a\u9593\u306e\u9577\u3055\u3092\u53d6\u5f97\u3059\u308b\n            #n\u4ee5\u4e0b\u306e\u6700\u5c0f\u306e\u4e8c\u4e57\u306e\u3079\u304d(BIT\u3067\u7ba1\u7406\u3059\u308b\u6570\u5217\u306e\u533a\u9593\u3067\u6700\u5927\u306e\u3082\u306e)\u3092\u6c42\u3081\u308b\n            while(r<self.n):\n                r=r<<1\n            len = r\n            while len > 0:\n                if(i+len<self.n and self.bit[i+len]<x):\n                    x-=self.bit[i+len]\n                    i+=len\n                len = len >> 1\n            return i+1\n\ndef main():\n    N, Q = MI()\n    X, Y = BIT(N), BIT(N)\n    xmin = N-2\n    ymin = N-2\n    X.add(1, N-2)\n    X.add(N-1, -(N-2))\n    Y.add(1, N-2)\n    Y.add(N-1, -(N-2))\n\n    res = (N-2)**2\n    for i in range(Q):\n        a, b = MI()\n        if a == 1:\n            x = X.sum(b-1)\n            if ymin > b-2:\n                temp = Y.sum(1)\n                Y.add(1, b-2-temp)\n                Y.add(xmin+1, -(b-2-temp))\n                ymin = b-2\n            res -= x\n        else:\n            y = Y.sum(b-1)\n            if xmin > b-2:\n                temp = X.sum(1)\n                X.add(1, b-2-temp)\n                X.add(ymin+1, -(b-2-temp))\n                xmin = b-2\n            res -= y\n            \n    print(res)\n    \ndef __starting_point():\n    main()\n__starting_point()", "N, Q = list(map(int, input().split()))\n\narea_W = N - 2\narea_H = N - 2\n\nwalls_H = []\nwalls_V = []\n\ncount = (N - 2) * (N - 2)\n\n# search smallest i ( s <= i < e ) such that f(i) == True\ndef bisearch_smallest(f, s, e = None):\n\tif e == None:\n\t\te = s - 1\n\t\ts = 0\n\telse:\n\t\te -= 1\n\t\n\twhile s < e:\n\t\tm = (s + e) // 2\n\t\tif f(m):\n\t\t\te = m\n\t\telse:\n\t\t\ts = m + 1\n\t\n\tif s == e and f(s):\n\t\treturn s\n\telse:\n\t\treturn -1\n\nfor _ in range(Q):\n\tq, i = input().split()\n\ti = int(i) - 2\n\tif q == \"1\":\n\t\tif i < area_W:\n\t\t\tarea_W = i\n\t\t\tcount -= area_H\n\t\t\twalls_H.append((i, area_H))\n\t\telse:\n\t\t\tj = bisearch_smallest(lambda j: walls_H[j][0] < i, 0, len(walls_H))\n\t\t\tcount -= walls_H[j][1]\n\telse:\n\t\tif i < area_H:\n\t\t\tarea_H = i\n\t\t\tcount -= area_W\n\t\t\twalls_V.append((i, area_W))\n\t\telse:\n\t\t\tj = bisearch_smallest(lambda j: walls_V[j][0] < i, 0, len(walls_V))\n\t\t\tcount -= walls_V[j][1]\n\n#print(area_W, area_H)\nprint(count)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, q = list(map(int, input().split()))\n    query = [list(map(int, input().split())) for _ in range(q)]\n\n    res = (n - 2) * (n - 2)\n    R = C = n - 1\n    yoko = [n] * (n - 1)\n    tate = [n] * (n - 1)\n    for x, y in query:\n        y -= 1\n        if x == 1:\n            if y > C:\n                res -= tate[y] - 1\n            else:\n                res -= R - 1\n                tate[y] = 0\n                for c in range(C - 1, y, -1):\n                    tate[c] = R\n                C = y\n        else:\n            if y > R:\n                res -= yoko[y] - 1\n            else:\n                res -= C - 1\n                yoko[y] = 0\n                for r in range(R - 1, y, -1):\n                    yoko[r] = C\n                R = y\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_right\n\nn,q = map(int,input().split())\n\nv_lay = [(-(n-1),n-2)]\nh_lay = [(-(n-1),n-2)]\n\nans = (n-2)*(n-2)\nfor _ in range(q):\n    case,lay_pos = map(int,input().split())\n    \n    ref_lay = (v_lay if case==1 else h_lay)\n    \n    index = bisect_right(ref_lay, (-lay_pos,n))\n    _, lay = ref_lay[index-1]\n    \n    ans -= lay\n\n    if index==len(ref_lay):\n        ref_lay = (h_lay if case==1 else v_lay)\n        laid_pos, num = ref_lay[-1]\n        if laid_pos == -(lay+1):\n            ref_lay[-1] = (-(lay+1), min(lay_pos-2,num))\n        else:\n            ref_lay.append((-(lay+1), lay_pos-2))\n            \nprint(ans)", "n, q = list(map(int, input().split()))\nquery = [list(map(int, input().split())) for _ in range(q)]\nINF = 10 ** 9\n\nver = [-1] * (n + 1)\nhor = [-1] * (n + 1)\nver[-1] = INF\nhor[-1] = INF\nver_base = n - 1\nhor_base = n - 1\n\nwhite = 2 * n - 1\nfor num, x in query:\n    if num == 1:\n        if ver[x] == -1:\n            white += ver_base\n            i = x\n            while ver[i] == -1:\n                ver[i] = ver_base\n                i += 1\n\n        else:\n            white += ver[x]\n\n        hor_base = min(hor_base, x - 1)\n\n    else:\n        if hor[x] == -1:\n            white += hor_base\n            i = x\n            while hor[i] == -1:\n                hor[i] = hor_base\n                i += 1\n\n        else:\n            white += hor[x]\n\n        ver_base = min(ver_base, x - 1)\n\nstone_sum = (n - 2) * (n - 2) + 2 * n - 1 + q\nans = stone_sum - white\nprint(ans)\n", "#import sys\n#input = sys.stdin.readline\nfrom collections import deque\nfrom bisect import bisect_left\n\ndef main():\n    N, Q = list(map( int, input().split()))\n    Query = [ tuple( map( int, input().split())) for _ in range(Q)]\n    LX = 1\n    X = deque([N])\n    VX = deque([N])\n    LY = 1\n    Y = deque([N])\n    VY = deque([N])\n    mx = N\n    my = N\n    ans = 0\n    # ANS = [0]\n    for i, x in Query:\n        if i == 1:\n            if x < my:\n                ans += mx-2\n                # Y.appendleft(x)\n                # VY.appendleft(mx)\n                X.appendleft(x)\n                VX.appendleft(mx)\n                my = x\n            else:\n                ans += VX[bisect_left(X,x)-1]-2\n                # print(\"x\", x, bisect_left(X,x))\n                # print(X, VX)\n        else:\n            if x < mx:\n                ans += my-2\n                Y.appendleft(x)\n                VY.appendleft(my)\n\n                # X.appendleft(x)\n                # VX.appendleft(my)\n                mx = x\n            else:\n                ans += VY[bisect_left(Y,x)-1]-2\n                # print(\"y\",x, bisect_left(Y,x))\n                # print(Y, VY)\n\n        # print(X, VX)\n        # print( ans-ANS[-1])\n        # ANS.append(ans)\n    #     print(i, x, ans)\n    # print(X, VX)\n    # print(Y,VY)\n    print(((N-2)**2-ans))\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect\n\nN, Q = list(map(int, input().split()))\n\nans = (N-2)*(N-2)\nwx = wy = 0\nAx = []\nAy = []\n\nfor _ in range(Q):\n    t, p = list(map(int, input().split()))\n    p = N-p\n    \n    if t==1:\n        i = bisect(Ax, (p, 0))\n        if i==len(Ax):\n            Ax.append((p, wy))\n            wx = p\n            rev = N-2-wy\n        else:\n            rev = N-2-Ax[i][1]\n    else:\n        i = bisect(Ay, (p, 0))\n        if i==len(Ay):\n            Ay.append((p, wx))\n            wy = p\n            rev = N-2-wx\n        else:\n            rev = N-2-Ay[i][1]\n\n    ans -= rev\n\nprint(ans)\n", "n, q = list(map(int, input().split()))\nquery = [list(map(int, input().split())) for _ in range(q)]\nINF = 10 ** 9\n\nkeys = [\"verticle\", \"horizion\"]\n\nbecome_white = {key: [-1] * (n + 1) for key in keys}\nfor key in keys:\n    become_white[key][-1] = INF\nbase = {key: n - 1 for key in keys}\n\nwhite = 2 * n - 1\nfor num, x in query:\n    if num == 1:\n        i, j = keys\n    else:\n        j, i = keys\n\n    if become_white[i][x] == -1:\n        white += base[i]\n        k = x\n        while become_white[i][k] == -1:\n            become_white[i][k] = base[i]\n            k += 1\n    else:\n        white += become_white[i][x]\n\n    base[j] = min(base[j], x - 1)\n\nstone_sum = (n - 2) * (n - 2) + 2 * n - 1 + q\nans = stone_sum - white\nprint(ans)\n", "#!/usr/bin/env python3\n\nimport sys\ninput=sys.stdin.readline\n\nn,q=map(int,input().split())\nleft=n\nup=n\nans=(n-2)*(n-2)\nfixed_yoko=[0]*(n+1)\nfixed_tate=[0]*(n+1)\npost_process=[]\nfor _ in range(q):\n    t,x=map(int,input().split())\n    if t==1:\n        if x>left:\n            post_process.append((t,x))\n        else:\n            fixed_yoko[left]+=-up\n            fixed_yoko[x+1]+=up\n            ans-=up-2\n            left=x\n    elif t==2:\n        if x>up:\n            post_process.append((t,x))\n        else:\n            fixed_tate[up]+=-left\n            fixed_tate[x+1]+=left\n            ans-=left-2\n            up=x\nfor i in range(1,n+1):\n    fixed_yoko[i]+=fixed_yoko[i-1]\n    fixed_tate[i]+=fixed_tate[i-1]\nfor t,x in post_process:\n    if t==1:\n        ans-=fixed_yoko[x]-2\n    elif t==2:\n        ans-=fixed_tate[x]-2\nprint(ans)", "n, q = list(map(int, input().split()))\nn -= 2\nX = [[n] * n, [n] * n]\nH = [n, n]\nans = n**2\nfor _ in range(q):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 2\n    for i in range(b, H[a]):\n        X[a][i] = H[a ^ 1]\n    H[a] = min(H[a], b)\n    ans -= X[a][b]\nprint(ans)\n", "def main():\n    N, Q = [int(v) for v in input().split()]\n\n    Query = [[int(v)-1 for v in input().split()] for _ in range(Q)]\n\n    rows = [N-1] * (N - 1)\n    cols = [N-1] * (N - 1)\n\n    black = (N - 2) * (N - 2)\n    min_row = N - 1\n    min_col = N - 1\n\n    for ty, x in Query:\n        if ty == 0:\n            if x < min_col:\n                rows[x:min_col] = [min_row] * (min_col - x)\n                min_col = x\n            black -= rows[x] - 1\n        else:\n            if x < min_row:\n                cols[x:min_row] = [min_col] * (min_row - x)\n                min_row = x\n            black -= cols[x] - 1\n\n    print(black)\n\nmain()", "n, q = list(map(int, input().split()))\nn -= 2\nR, C = [n] * n, [n] * n\nh, w = n, n\na = n**2\nfor _ in range(q):\n    t, x = list(map(int, input().split()))\n    x -= 2\n    if t == 1:\n        for i in range(x, h):\n            R[i] = w\n        h = min(h, x)\n        a -= R[x]\n    if t == 2:\n        for j in range(x, w):\n            C[j] = h\n        w = min(w, x)\n        a -= C[x]\nprint(a)\n", "def f(i, m, cnt):\n    while True:\n        if i > n or not cnt[i] == inf:\n            return\n        cnt[i] = m\n        i += 1\n\nn, q = map(int, input().split())\ninf = n + 114514\nans = (n - 2) * (n - 2)\ncnt1, cnt2 = [inf] * (n + 1), [inf] * (n + 1)\nmax1, max2 = n - 2, n - 2\nfor _ in range(q):\n    t, x = map(int, input().split())\n    if t == 1:\n        if cnt1[x] == inf:\n            ans -= max2\n            max1 = x - 2\n            f(x, max2, cnt1)\n        else:\n            ans -= cnt1[x]\n    else:\n        if cnt2[x] == inf:\n            ans -= max1\n            max2 = x - 2\n            f(x, max1, cnt2)\n        else:\n            ans -= cnt2[x]\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, q = list(map(int, input().split()))\n    query = [list(map(int, input().split())) for _ in range(q)]\n\n    res = (n - 2) * (n - 2)\n    R = C = n - 1\n    yoko = [n - 1] * (n - 1)\n    tate = [n - 1] * (n - 1)\n    for x, y in query:\n        y -= 1\n        if x == 1:\n            if y > C:\n                res -= tate[y] - 1\n            else:\n                res -= R - 1\n                for c in range(C - 1, y, -1):\n                    tate[c] = R\n                C = y\n            tate[y] = 0\n        else:\n            if y > R:\n                res -= yoko[y] - 1\n            else:\n                res -= C - 1\n                for r in range(R - 1, y, -1):\n                    yoko[r] = C\n                R = y\n            yoko[y] = 0\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\ndef resolve():\n    #n=int(input())\n    #a,b=map(int,input().split())\n    #x=list(map(int,input().split()))\n    #a=[list(map(lambda x:int(x)%2,input().split())) for _ in range(h)]\n    n,q=map(int,input().split())\n    xe=np.array([0] * n)\n    ye=np.array([0] * n)\n    xemin,yemin=n-1,n-1\n    bs=(n-2)**2\n    for i in range(q):\n      j,x=map(int,input().split())\n      if j==1:\n        if xemin>=x-1:\n          xe[x-1:xemin]=yemin-1\n          xemin=x-1\n        bs-=xe[x-1]\n      else:\n        if yemin>=x-1:\n          ye[x-1:yemin]=xemin-1\n          yemin=x-1\n        bs-=ye[x-1]\n    print(bs)\n      \ndef __starting_point():\n    resolve()\n__starting_point()", "n,q=map(int,input().split())\nans=(n-2)**2\nh=n-2\nr=n-2\nl_h=[-1]*(n-2)\nl_r=[-1]*(n-2)\nfor _ in range(q):\n    a,x=map(int,input().split())\n    if a==1:\n        if x-1>r:\n            ans-=l_r[x-2]\n        else:\n            r=x-2\n            ans-=h\n            for i in range(x-1,n-2):\n                if l_r[i]==-1:\n                    l_r[i]=h\n                else:\n                    break\n    else:\n        if x-1>h:\n            ans-=l_h[x-2]\n        else:\n            h=x-2\n            ans-=r\n            for i in range(x-1,n-2):\n                if l_h[i]==-1:\n                    l_h[i]=r\n                else:\n                    break   \nprint(ans) ", "import sys\n\nsys.setrecursionlimit(10**6)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nclass BIT:\n    def __init__(self, n):\n        self.inf=10**9\n        self.n = n + 3\n        self.table = [self.inf] * (self.n + 1)\n\n    def update(self, i, x):\n        i += 1\n        while i <= self.n:\n            if x < self.table[i]: self.table[i] = x\n            i += i & -i\n\n    def min(self, i):\n        i += 1\n        res = self.inf\n        while i > 0:\n            if self.table[i] < res: res = self.table[i]\n            i -= i & -i\n        return res\n\ninf=10**9\nn,q=MI()\nans=(n-2)**2\nt=l=n\nyo=[]\nta=[]\nfor i in range(q):\n    op,x=MI()\n    if op==1:\n        ta.append((i,x))\n    else:\n        yo.append((i,x))\n\nif not ta or not yo:\n    ans-=(len(ta)+len(yo))*(n-2)\n    print(ans)\n    return\n\ndef cnt(ia,jb):\n    res=0\n    bit=BIT(q+5)\n    for i,a in ia:bit.update(i,a)\n    jb.sort(key=lambda x:x[1])\n    now=2\n    for j,b in jb:\n        cur=bit.min(j)\n        if cur==inf:cur=n\n        # print(j,b,cur)\n        now=max(now,cur)\n        res+=now-2\n    return res\n\nans-=cnt(ta,yo)\nans-=cnt(yo,ta)\nprint(ans)\n", "def bisect_descending(lst, x):\n    l, r = -1, len(lst)\n    while r - l > 1:\n        m = (r + l) // 2\n        if lst[m] > x:\n            l = m\n        else:\n            r = m\n    return r\n\n\nN, Q = list(map(int, input().split()))\nrow, col = [N], [N]\nans = (N - 2) ** 2\nfor _ in range(Q):\n    n, x = list(map(int, input().split()))\n    if n == 1:\n        # \u4e0b\u65b9\u5411\n        if x < col[-1]:\n            col.append(x)\n            row.append(row[-1])\n        idx = bisect_descending(col, x)\n        ans -= row[idx] - 2\n    else:\n        # \u53f3\u65b9\u5411\n        if x < row[-1]:\n            row.append(x)\n            col.append(col[-1])\n        idx = bisect_descending(row, x)\n        ans -= col[idx] - 2\nprint(ans)\n", "n,q = map(int,input().split())\n\nans = (n-2)**2\nrm = n\num = n\nruse = [-1]*(n+1)\nuuse = [-1]*(n+1)\n\nfor _ in range(q):\n    a,x = map(int,input().split())\n    if a == 1:\n        if uuse[x] >= 0:\n            ans -= uuse[x]-2\n        else:\n            dif = um - 2\n            ans -= dif\n            for i in range(x,n+1):\n                if uuse[i] >= 0:\n                    break\n                uuse[i] = um\n            rm = min(rm,x)\n    else:\n        if ruse[x] >= 0:\n            ans -= ruse[x]-2\n        else:\n            dif = rm - 2\n            ans -= dif\n            for i in range(x,n+1):\n                if ruse[i] >= 0:\n                    break\n                ruse[i] = rm\n            um = min(um,x)\nprint(ans)", "def search(L, x):\n    low, high = 0, len(L)-1\n    while low < high:\n        mid = (low+high)//2\n        if L[mid+1] < x < L[mid]:\n            return mid\n        elif x < L[mid+1]:\n            low = mid+1\n        else:\n            high = mid\n    return low\n\nN, Q = map(int, input().split())\nquery = [list(map(int, input().split())) for _ in range(Q)]\nB = [N-1]\nBv = [N-2]\nR = [N-1]\nRv = [N-2]\nans = (N-2)**2\nfor f, x in query:\n    x -= 1\n    if f == 1:\n        a = search(R, x)\n        ans -= Rv[a]\n        if R[-1] >= x:\n            Bv[-1] = x-1\n            R.append(x)\n            Rv.append(Rv[-1])\n    else:\n        a = search(B, x)\n        ans -= Bv[a]\n        if B[-1] >= x:\n            Rv[-1] = x-1\n            B.append(x)\n            Bv.append(Bv[-1])\n    \nprint(ans)", "N, Q = map(int,input().split())\nHW = [N, N]\nans = (N - 2) ** 2\nL_HW = [[N - 2 for i in range(N)] for j in range(2)]\nfor _ in range(Q):\n    vh, x = map(int,input().split())\n    vh -= 1\n    if x > HW[1 - vh]:\n        ans -= L_HW[1 - vh][x]\n    else:\n        L_HW[1 - vh][x+1:HW[1 - vh]] = [HW[vh]-2] * (HW[1 - vh]-x-1)\n        HW[1 - vh] = x\n        ans -= HW[vh] - 2\nprint(ans)", "n, q = map(int, input().split())\nl = [0]*n; u = [0]*n; lmin = n-2; umin = n-2; lgoal = n; ugoal = n\nfor _ in range(q):\n    s, t = map(int, input().split())\n    if s == 1:\n        if t > ugoal: u[t-1] = 0\n        else:\n            for i in range(t, ugoal-1):u[i] = umin\n            lmin = t-2; ugoal = t\n    else:\n        if t > lgoal: l[t-1] = 0\n        else:\n            for i in range(t, lgoal-1):l[i] = lmin\n            umin = t-2; lgoal = t\nprint(sum(l)+sum(u)+lmin*umin)", "import sys\nimport numpy as np\n\n\ndef main():\n    N, Q = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    H = np.array([0] * (N - 1))\n    W = np.array([0] * (N - 1))\n\n    black = (N - 2)**2  # \u521d\u671f\u72b6\u614b\u306e\u9ed2\u679a\u6570\n\n    Hmin = N - 1\n    Wmin = N - 1\n\n    for i in range(Q):\n        n, x = list(map(int, sys.stdin.readline().rstrip().split()))\n        if n == 1:  # \u2193 \u3067\u631f\u3080\n            if x - 1 <= Wmin:\n                W[x - 1:Wmin] = Hmin - 1\n                Wmin = x - 1\n            # print(\"***\", W[x - 1], Wmin, Hmin)\n            black -= W[x - 1]\n        else:\n            if x - 1 <= Hmin:\n                H[x - 1:Hmin] = Wmin - 1\n                Hmin = x - 1\n            # print(\"***\", H[x - 1], Wmin, Hmin)\n            black -= H[x - 1]\n\n    print(black)\n\n\nmain()\n", "n, q = list(map(int, input().split()))\nn -= 2\nR, C = [None] * n, [None] * n\nh, w = n, n\na = n**2\nfor _ in range(q):\n    t, x = list(map(int, input().split()))\n    x -= 2\n    if t == 1:\n        for i in range(x, h):\n            R[i] = w\n        h = min(h, x)\n        a -= R[x]\n    if t == 2:\n        for j in range(x, w):\n            C[j] = h\n        w = min(w, x)\n        a -= C[x]\nprint(a)\n", "n, q = list(map(int, input().split()))\nans = (n-2)**2\n\nd = [n]*(n+1)\nr = [n]*(n+1)\n\nrmin = n\ndmin = n\n\nfor _ in range(q):\n    query, x = list(map(int, input().split()))\n    if query == 1:\n        if x < rmin:\n            for i in range(rmin, x-1, -1):\n                r[i] = dmin\n            rmin = x\n        ans -= r[x] - 2\n\n    else:\n        if x < dmin:\n            for i in range(dmin, x-1, -1):\n                d[i] = rmin\n            dmin = x\n        ans -= d[x] - 2\n\nprint(ans)\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# Binary Indexed Tree\n# \u90e8\u5206\u548c\u306e\u8a08\u7b97\u3068\u8981\u7d20\u306e\u66f4\u65b0\u306e\u4e21\u65b9\u3092\u52b9\u7387\u7684\u306b\u884c\u3048\u308b\n# 1-indexed\n# sum(r)        :\u9589\u533a\u9593 [0,r] \u306e\u5408\u8a08\u3092\u53d6\u5f97\u3059\u308b\n# [8] a0 + a1  + a2 + a3 + a4 + a5 + a6 + a7\n# [4] a0 + a1  + a2 + a3\n# [2] a0 + a1               [6] a4 + a5\n# [1] a0       [3] a2       [5] a4        [7] a6\n\n#                   [1000]\n#           [0100]\n#   [0010]                [0110]\n# [0001]    [0011]      [0111]      [1111]\n\nclass BinaryIndexedTree:\n    # \u521d\u671f\u5316\u51e6\u7406\n    def __init__(self, size):\n        self.size = size\n        self.dat = [0]*(size+1)\n        self.depth = size.bit_length()\n\n    def init(self, a):\n        for i, x in enumerate(a):\n            self.add(i, x)\n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.dat[i] += x\n            i += i & -i # \u66f4\u65b0\u3059\u3079\u304d\u4f4d\u7f6e\n\n    # sum(r)        :\u9589\u533a\u9593 [0,r] \u306e\u5408\u8a08\u3092\u53d6\u5f97\u3059\u308b\n    # sum(0)=a[0], sum(n-1)=a[0]+...+a[n-1]\n    def sum(self, r):\n        r += 1\n        ret = 0\n        while r>0:\n            ret += self.dat[r]\n            r -= r & -r # \u52a0\u7b97\u3059\u3079\u304d\u4f4d\u7f6e\n        return ret\n\n# sum(i) >= v\u3068\u306a\u308b\u6700\u5c0f\u306eindex\n    def lower_bound(self, x):\n        \"\"\" \u7d2f\u7a4d\u548c\u304cx\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u5c0f\u306eindex\u3068\u3001\u305d\u306e\u76f4\u524d\u307e\u3067\u306e\u7d2f\u7a4d\u548c \"\"\"\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.dat[k] < x:\n                sum_ += self.dat[k]\n                pos += 1 << i\n        return pos  #0-indexed\n\n#### for debug\n    def get_original_sequence(self):\n        ret = self.get_aggrigate_sequence()\n        for i in range(self.size-1, 0, -1):\n            ret[i] -= ret[i-1]\n        return ret\n\n    def get_aggrigate_sequence(self):\n        return [self.sum(i) for i in range(self.size)]\n\n    def __str__(self):\n        seq = self.get_original_sequence()\n        ret = 'original :' + ' '.join(map(str, seq))\n        ret += '\\n'\n        seq = self.get_aggrigate_sequence()\n        ret += 'aggrigate:' + ' '.join(map(str, seq))\n        return ret\n\n########################################\nn, q = list(map(int, input().split()))\ncx = BinaryIndexedTree(n+1)\ncy = BinaryIndexedTree(n+1)\ncx.add(1, n-2)\ncy.add(1, n-2)\nmx, my = n, n\nret = pow(n-2,2)\nfor _ in range(q):\n    u, v = list(map(int, input().split()))\n    if u == 1:\n        ret -= cx.sum(v)\n        if mx > v:\n            cy.add(1, v-mx)\n            cy.add(my, mx-v)\n            mx = v\n    else:\n        ret -= cy.sum(v)\n        if my > v:\n            cx.add(1, v-my)\n            cx.add(mx, my-v)\n            my = v\n\nprint(ret)\n", "n, q = map(int, input().split())\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\nv = n-1 # \u6700\u3082\u4e0a\u306b\u3042\u308b\u767d\u77f3\u306ey\u5ea7\u6a19\nh = n-1 # \u6700\u3082\u5de6\u306b\u3042\u308b\u767d\u77f3\u306ex\u5ea7\u6a19\ntate = [n-1] * n\nyoko = [n-1] * n\nans = (n-2)**2\nfor q1, q2 in queries:\n    q2 -= 1\n    if q1 == 1:\n        # \u30bf\u30c6\u306e\u51e6\u7406\n        if q2 < h:\n            ans -= v-1\n            # \u5de6\u4e0a\u306e\u77e9\u5f62\u3088\u308a\u5916\u306f\u3001\u66f4\u65b0\u3055\u308c\u308b\u3053\u3068\u304c\u306a\u304f\u306a\u3063\u305f\u3089tate yoko\u306b\u683c\u7d0d\n            # \u305d\u308c\u305e\u308c\u306e\u66f4\u65b0\u306f\u9ad8\u3005n\u56de\n            for i in range(h, q2, -1):\n                tate[i] = v\n            h = q2\n        else:\n            ans -= tate[q2]-1\n    else:\n        #  \u30e8\u30b3\u306e\u51e6\u7406\n        if q2 < v:\n            ans -= max(0, h-1)\n            for i in range(v, q2, -1):\n                yoko[i] = h\n            v = q2\n        else:\n            ans -= yoko[q2]-1\nprint(ans)", "class F:\n    def __init__(self, x):\n        self.bit = x\n        for i in range(len(x)):\n            j = i | (i + 1)\n            if j < len(x):\n                x[j] += x[i]\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n    def findkth(self, k):\n        idx = -1\n        for d in reversed(range(len(self.bit).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(self.bit) and k >= self.bit[right_idx]:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1\nimport sys\nz=sys.stdin.readline\ny=lambda:map(int,z().split())\nn,q=y()\nv=F([0]*(n-2))\nh=F([0]*(n-2))\nw=j=n-2\ns=0\nfor _ in range(q):\n    a,b=y()\n    if a<2:\n        if b-2<w:h.update(n-2-j,w-b+2);w=b-2\n        s+=n-2-v.query(n-b)\n    else:\n        if b-2<j:v.update(n-2-w,j-b+2);j=b-2\n        s+=n-2-h.query(n-b)\nprint((n-2)*(n-2)-s)", "import sys\ninput=sys.stdin.readline\ndef main():\n    n, q=list(map(int,input().split()))\n    ans = (n-2)**2\n    h = n\n    w = n\n    a=[n for _ in range(n)]\n    b=[n for _ in range(n)]\n    for _ in range(q):\n        t, x=list(map(int,input().split()))\n        if (t == 1):\n            if (x < w):\n                for i in range(x,w):\n                    a[i] = h\n                w = x\n            ans -= a[x] - 2\n        else:\n            if (x < h):\n                for i in range(x,h):\n                    b[i] = w\n                h = x\n            ans -= b[x] - 2\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "N, Q, *QX = map(int, open(0).read().split())\n\nA = [N] * (N + 1)\nB = [N] * (N + 1)\n\nans = (N - 2) ** 2\nh = w = N\nfor q, x in zip(*[iter(QX)] * 2):\n    if q == 1:\n        if x < w:\n            B[x:w] = [h] * (w - x)\n            w = x\n        ans -= B[x] - 2\n    else:\n        if x < h:\n            A[x:h] = [w] * (h - x)\n            h = x\n        ans -= A[x] - 2\n\nprint(ans)", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return map(int,input().split())\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(map(max,x))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)//2\n\n    if rr == mid:\n        return ll\n    if (\u3053\u3053\u306b\u8a55\u4fa1\u5165\u308c\u308b):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\n\nn,q = m()\n\nans = (n-2)**2\n\nta = n-2\ntate = [n-2 for i in range(n-2)]\nltate = [0 for i in range(n-2)]\nyo = n-2\nyoko = [n-2 for i in range(n-2)]\nlyoko = [0 for i in range(n-2)]\nfor i in range(q):\n    a,b = m()\n    b -= 2\n    if a == 1:\n        if ltate[b] == 0:\n            ans -= ta\n        else:\n            ans -= tate[b]\n\n        for j in range(b,n-2):\n            if ltate[j] == 0:\n                tate[j] = ta\n                ltate[j] = 1\n                yo = b\n            else:\n                break\n\n\n    else:\n        if lyoko[b] == 0:\n            ans -= yo\n        else:\n            ans -= yoko[b]\n        for j in range(b,n-2):\n            if lyoko[j] == 0:\n                yoko[j] = yo\n                lyoko[j] = 1\n                ta = b\n            else:\n                break\nprint(ans)", "N, Q = list(map(int, input().split()))\n\nrow = [N - 2] * (N + 2)\ncol = [N - 2] * (N + 2)\nans = (N - 2)**2\n\nmiRow = N\nmiCol = N\n\nfor _ in range(Q):\n    q, x = list(map(int, input().split()))\n\n    if q == 1:\n        for i in range(x, miRow + 1):\n            row[i] = min(row[i], miCol - 2)\n        miRow = min(x, miRow)\n        ans -= row[x]\n\n    if q == 2:\n        for i in range(x, miCol + 1):\n            col[i] = min(col[i], miRow - 2)\n        miCol = min(x, miCol)\n        ans -= col[x]\n\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, q = list(map(int, input().split()))\n    query = [list(map(int, input().split())) for _ in range(q)]\n\n    res = (n - 2) * (n - 2)\n    Y = n - 1\n    T = n - 1\n    yoko = [n - 1] * (n - 1)\n    tate = [n - 1] * (n - 1)\n    for num, x in query:\n        x -= 1\n        if num == 1:\n            if x > Y:\n                res -= tate[x] - 1\n            else:\n                res -= T - 1\n                for i in range(x, Y):\n                    tate[i] = T\n                Y = x\n            tate[x] = 0\n        else:\n            if x > T:\n                res -= yoko[x] - 1\n            else:\n                res -= Y - 1\n                for i in range(x, T):\n                    yoko[i] = Y\n                T = x\n            yoko[x] = 0\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\nfrom bisect import bisect_left, bisect_right\n\nn, q = map(int, input().split())\nlist_x = deque()\nlist_y = deque()\nmemo_x = deque()\nmemo_y = deque()\nx_now, y_now = n-1, n-1\n\nans = (n-2) ** 2\n\n#que = [(1, i) for i in range(2, n)] + [(2, i) for i in range(2, n)]\nfor i in range(q):\n    flg, x = map(int, input().split())\n    if flg == 1:\n        if x_now >= x:\n            ans -= y_now - 1\n            x_now = x - 1\n            list_x.appendleft(x)\n            memo_x.appendleft(y_now - 1)\n        else:\n            tmp = bisect_left(list_x, x) - 1\n            ans -= memo_x[tmp]\n    \n    else:\n        y = x\n        if y_now >= y:\n            ans -= x_now - 1\n            y_now = y - 1\n            list_y.appendleft(y)\n            memo_y.appendleft(x_now - 1)\n        else:\n            tmp = bisect_left(list_y, y) - 1\n            ans -= memo_y[tmp]\n\nprint(ans)", "n, q = map(int, input().split())\nquery = [list(map(int, input().split())) for _ in range(q)]\n\nans = (n-2)**2\nx = [n] * (n+1)\ny = [n] * (n+1)\nxm = ym = n\n\nfor a, b in query:\n    if a == 1:\n        if b < xm:\n            y[b:xm] = [ym] * (xm - b)\n            xm = b\n        ans -= y[b] - 2\n    else:\n        if b < ym:\n            x[b:ym] = [xm] * (ym - b)\n            ym = b\n        ans -= x[b] - 2\nprint(ans)", "import numpy as np\n# from numba import njit\n# from numba.types import int64\ni8 = np.int64\n\n\n# @njit((int64, int64[:,::-1]), cache=True)\ndef solve(n, qr):\n    col = np.zeros(n - 1, i8)\n    col[0] = 0\n    col_min = n - 1\n    row = np.zeros(n - 1, i8)\n    row[0] = 0\n    row_min = n - 1\n    white = 0\n    for i in range(qr.shape[0]):\n        j = qr[i, 1] - 1\n        if qr[i, 0] == 1:\n            if j < col_min:\n                white += row_min - 1\n                for m in range(j + 1, col_min):\n                    col[m] = row_min - 1\n                col_min = j\n            else:\n                white += col[j]\n        else:\n            if j < row_min:\n                white += col_min - 1\n                for m in range(j + 1, row_min):\n                    row[m] = col_min - 1\n                row_min = j\n            else:\n                white += row[j]\n    return white\n\n\ndef main():\n    f = open(0)\n    n, q = [int(x) for x in f.readline().split()]\n    qr = np.fromstring(f.read(), i8, sep=' ').reshape((-1, 2))\n    white = solve(n, qr)\n    print((n - 2) ** 2 - white)\n\nmain()", "import sys\nimport bisect\ninput = sys.stdin.readline\n\ndef main():\n    n, q = list(map(int, input().split()))\n\n    ans = 0\n    min1, min2 = n-2, n-2\n    judge1 = [-n-1]\n    judge2 = [-n-1]\n    dict1 = dict()\n    dict2 = dict()\n    dict1[-n-1] = n-2\n    dict2[-n-1] = n-2\n\n    for i in range(q):\n        query, x = list(map(int, input().split()))\n\n        if query == 1:\n            index = bisect.bisect(judge1, -x)-1\n            key = dict1[judge1[index]]\n            ans += key\n            if min1 > x-2:\n                min1 = x-2\n                judge1.append(-x)\n                dict1[-x] = key\n                dict2[judge2[-1]] = min1\n        else:\n            index = bisect.bisect(judge2, -x)-1\n            key = dict2[judge2[index]]\n            ans += key\n            if min2 > x-2:\n                min2 = x-2\n                judge2.append(-x)\n                dict2[-x] = key\n                dict1[judge1[-1]] = min2\n\n    print(((n-2)**2 - ans))\n    \n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "def f_simplified_reversi():\n    N, Q = [int(i) for i in input().split()]\n    Queries = [[int(i) for i in input().split()] for j in range(Q)]\n\n    a, b = [N] * N, [N] * N  # editorial \u306b\u6e96\u3058\u308b\n    black_stone = (N - 2)**2\n    row, col = N, N\n\n    for type, x in Queries:\n        if type == 1:\n            if x < col:\n                for i in range(x, col):\n                    b[i] = row\n                col = x\n            black_stone -= b[x] - 2\n        else:\n            if x < row:\n                for i in range(x, row):\n                    a[i] = col\n                row = x\n            black_stone -= a[x] - 2\n    return black_stone\n\nprint(f_simplified_reversi())", "def main():\n    N, Q = [int(v) for v in input().split()]\n\n    Query = [[int(v)-1 for v in input().split()] for _ in range(Q)]\n\n    rows = [N-1] * (N - 1)\n    cols = [N-1] * (N - 1)\n\n    black = (N - 2) * (N - 2)\n    min_row = N - 1\n    min_col = N - 1\n\n    for ty, x in Query:\n        if ty == 0:\n            if x < min_col:\n                for j in range(x, min_col):\n                    rows[j] = min_row\n                min_col = x\n            black -= rows[x] - 1\n        else:\n            if x < min_row:\n                for j in range(x, min_row):\n                    cols[j] = min_col\n                min_row = x\n            black -= cols[x] - 1\n\n    print(black)\n\nmain()", "N, Q = list(map(int, input().split()))\nQuery = [list(map(int, input().split())) for _ in range(Q)]\nans = 0\n\nfor T in range(1, 3):\n    Depth = [N-2]*N\n    left = N\n    up = N-2\n    for t, x in Query:\n        if t == T:  # |\n            if left < x:\n                ans += Depth[x]\n            else:\n                for i in range(x, left):\n                    Depth[i] = up\n                left = x\n                ans += up\n        else:  # -\n            up = min(up, x-2)\n        #print(f\"ans={ans}, up={up}\")\n    #print(\"---\")\n\nprint(((N-2)**2-ans))\n", "A,B,C,D=lambda:map(int,input().split()),range,min,max\nn,q=A()\na,b=[n]*n,[n]*n\nh,w=n,n\nE=(n-2)**2\nfor _ in B(q):\n Q,x=A()\n if Q-1:\n  for i in B(x,D(x,h)):b[i-1]=w\n  h=C(h,x);E-=b[x-1]-2\n else:\n  for i in B(x,D(x,w)):a[i-1]=h\n  w=C(w,x);E-=a[x-1]-2\nprint(E)", "N,Q = map(int,input().split())\na,b = [N]*(N+1),[N]*(N+1)\n\nH,W = N,N\n\nblack = (N-2)**2\n\nfor _ in range(Q):\n  t,x = map(int,input().split())\n  if t == 1:\n    if x < W:\n      for i in range(x,W):\n        b[i] = H\n      W = x\n\n    black -= b[x] - 2\n  \n  else:\n    if x < H:\n      for i in range(x,H):\n        a[i] = W\n      H = x\n\n    black -= a[x] - 2\n  \n\nprint(black)"]
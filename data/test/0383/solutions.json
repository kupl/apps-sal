["ans = {}\n\ndef gen(n, k, d, used = False):\n    if not ans.get((n, k, d, used)):\n        if not n and used:\n            ans[(n, k, d, used)] = 1\n        else:\n            ans[(n, k, d, used)] = sum(gen(n - x, k, d, used or x >= d) for x in range(1, min(n, k) + 1) if max(x, n - x) >= d or used)\n    return ans[(n, k, d, used)]\n\n\nn, k, d = list(map(int, input().split()))\nprint(gen(n, k, d)  % 1000000007)\n", "n, k, d = list(map(int,input().split()))\nf = [0]*(n+k+1)\nf_ = [0]*(n+k+1)\nf_[0] = 1\nfor i in range(1,n+1):\n    for j in range(1,k+1):\n        f[i] += f[i-j]\n    for j in range(d,k+1):\n        f[i] += f_[i-j]\n    for j in range(1,d):\n        f_[i] += f_[i-j]\nprint(f[n]%(10**9 +7))\n", "import collections\n\n\ndef count(n, k):\n\n    m = collections.defaultdict(lambda: 0)\n    m[0] = 1\n    for i in range(1, n + 1):\n\n        for j in range(1, k + 1):\n\n            if i - j in m:\n\n                m[i] += m[i - j]\n\n    return m[n]\n\nn, k, d = tuple(map(int, str.split(input())))\nprint((count(n, k) - count(n, d - 1)) % (10 ** 9 + 7))\n", "import random\nimport sys\nQ = 10 ** 9 + 7\nn, k, d = map(int, input().split())\ndp = [0] * 105\ndp1 = [0] * 105\ndp[0] = 1\ndp1[0] = 1 \nfor i in range(1, n + 1):\n    for j in range(max(0, i - k), i):\n        dp[i] = (dp[i] + dp[j]) % Q\n    for j in range(max(0, i - d + 1), i):\n        dp1[i] = (dp1[i] + dp1[j]) % Q\nprint((dp[n] - dp1[n] + Q) % Q)", "import random\nimport sys\nQ = 10 ** 9 + 7\nn, k, d = map(int, input().split())\ndp = [0] * 105\ndp1 = [0] * 105\ndp[0] = 1\ndp1[0] = 1 \nfor i in range(1, n + 1):\n    for j in range(max(0, i - k), i):\n        dp[i] = (dp[i] + dp[j])\n    for j in range(max(0, i - d + 1), i):\n        dp1[i] = (dp1[i] + dp1[j])\nprint((dp[n] - dp1[n])% Q)", "import sys\n\nf = sys.stdin\nn, k, d = list(map(int, f.readline().strip().split()))\n\nNd = [[1]*(n+1), [1]*(n+1)]\nNd[1][0] = 0\nNd[1][1] = 0\n\nfor i in range(2,n+1):\n    N = 0\n    for j in range(1,k+1):\n        if i>=j:\n            N += Nd[0][i-j]\n    Nd[0][i] = N\n\n    # if i==2: continue\n    N = 0\n    for j in range(1,k+1):\n        if i>=j:\n            if j>=d:\n                N += Nd[0][i-j]\n            else:\n                N += Nd[1][i-j]\n    Nd[1][i] = N\n    \n    #print(Nd)\n\nif d>1:\n    print(Nd[1][n] % 1000000007)\nelse:\n    print(Nd[0][n] % 1000000007)    \n\n", "n, k, d = map(int, input().split())\nf, g, d, m = [0] * (n + 1), [1] * (n + 1), 1 - d, 1000000007\nfor i in range(1, n + 1):\n    f[i] = (sum(g[j] for j in range(max(0, i - k), d + i)) + sum(f[j] for j in range(max(0, d + i), i))) % m\n    g[i] = sum(g[j] for j in range(max(0, i - k), i)) % m\nprint(f[n])", "n, k, d = map(int, input().split())\na = [1]\nb = [0]\nfor i in range(1, n + 1):\n    a.append(sum(a[max(i - d + 1, 0):]))\n    b.append(sum(a[max(i - k, 0):max(i - d + 1, 0)]) + sum(b[max(i - k, 0):]))\nprint(b[n] % 1000000007)", "n, k, d = map(int, input().split())\nM = 1000000007\na = [1] + [0] * n\nfor i in range(1, n + 1):\n  for j in range(max(0, i - k), i):\n    a[i] = (a[i] + a[j]) % M\n# print(a)\nb = [1] + [0] * n\nfor i in range(1, n + 1):\n  for j in range(max(0, i - d + 1), i):\n    b[i] = (b[i] + b[j]) % M\n# print(b)\nprint((a[n] - b[n]) % M)", "n, k, d = map(int, input().split())\na = [1]\nb = [0]\nfor i in range(1, n + 1):\n    a.append(sum(a[max(i - d + 1, 0):]))\n    b.append(sum(a[max(i - k, 0):max(i - d + 1, 0)]) + sum(b[max(i - k, 0):]))\nprint(b[n] % (10**9+7))", "__author__ = 'epeshk'\ndef admod(a,b):\n    a+=b\n    if a>1e9+7:\n        a-=1e9+7\n    return a\nn,k,d=list(map(int,input().split()))\nDp=[[1,0]]\nfor i in range(1,n+1):\n    Dp.append([0,0])\n    for j in range (1,k+1):\n        if i-j<0:   break\n        if j<d:\n            Dp[i][0]=admod(Dp[i][0],Dp[i-j][0])\n            Dp[i][1]=admod(Dp[i][1],Dp[i-j][1])\n        else:\n            Dp[i][1]=admod(Dp[i][1],Dp[i-j][0])\n            Dp[i][1]=admod(Dp[i][1],Dp[i-j][1])\nprint(int(Dp[n][1]))", "n,k,d=list(map(int, input().split()))\ndp={}\nvis=[]\n\ndef F(curr, poss):\n    if curr<0:\n        return 0\n    if curr==0 and poss==1:\n        return 1\n    if (curr, poss) in vis:\n        return dp[(curr, poss)]\n    i=1\n    vis.append((curr, poss))\n    dp[(curr, poss)]=0\n    while i<d:\n        dp[(curr, poss)]+=F(curr-i, poss)\n        i+=1\n    i=d\n    while i<=k:\n        dp[(curr, poss)]+=F(curr-i, 1)\n        i+=1\n    return dp[(curr, poss)]%1000000007\n    \nprint(F(n, 0))\n", "# -*- coding: utf-8 -*-\n\n(n, k, d) = list(map(int, input().split()))\n\ndef get_ways(n, upper_bound):\n    ways = [1] + [0] * n\n    for i in range(1, n + 1):\n        ways[i] = sum(ways[max(0, i - upper_bound):i])\n    return ways[n]\n\nprint((get_ways(n, k) - get_ways(n, d - 1)) % (10 ** 9 + 7))\n", "b = [False] * 101\nx = [0] * 101\ndef count(w, k1):\n    if w == 0:\n        return 1\n    elif w < 0:\n        return 0\n\n    ans = 0\n    for i in range(1, k1+1):\n        if w-i < 0:\n            break\n        if b[w - i]:\n            ans = ans + x[w - i];\n        else:\n            x[w-i] =  count(w - i, k1)\n            ans = ans + x[w - i];\n            b[w - i] = True;\n    b[w] = True;\n    x[w] = ans;\n    return ans;\n\nn, k, d = map(int,input().split())\nx[0] = 1;\nans = count(n, k);\nb = [False] * 101\nx = [0] * 101\nx[0] = 1;\nans = ans - count(n, min(k, d-1));\nprint(ans % 1000000007)", "import random\nimport sys\nQ = 10 ** 9 + 7\nn, k, d = map(int, input().split())\ndp = [0] * 105\ndp1 = [0] * 105\ndp[0] = 1\ndp1[0] = 1 \nfor i in range(1, n + 1):\n    for j in range(max(0, i - k), i):\n        dp[i] = (dp[i] + dp[j])\n    for j in range(max(0, i - d + 1), i):\n        dp1[i] = (dp1[i] + dp1[j])\nprint((dp[n] - dp1[n])% Q)", "def solve(n, k, d, e, memo):\n\tif n < 0:\n\t\treturn 0\n\tif n == 0:\n\t\treturn e\n\tif (n, e) in memo:\n\t\treturn memo[(n, e)]\n\tans = 0\n\tfor i in range(1, d):\n\t\tans += solve(n - i, k, d, e, memo)\n\tfor i in range(d, k + 1):\n\t\tans += solve(n - i, k, d, 1, memo)\n\tmemo[(n, e)] = ans % 1000000007\n\treturn ans % 1000000007\n\nn, k, d = (int(x) for x in input().split())\nprint(solve(n, k, d, 0, dict()))\n", "mem = [[-1 , -1] for x in range(0 , 103)]\n\nn , k , d = list(map(int , input().split()))\n\ndef dp(remain,has_d):\n    if remain == 0:\n        return has_d\n    if remain < 0:\n        return 0\n    if mem[remain][has_d] != -1:\n        return mem[remain][has_d]\n    mem[remain][has_d] = 0\n    for i in range(1 , min(remain,k)+1):\n        if i >= d :\n            mem[remain][has_d] += dp(remain - i , 1)\n        else :\n            mem[remain][has_d] += dp(remain - i , has_d)\n    return mem[remain][has_d]\n\nprint(dp(n,0)%(10**9 + 7))\n", "#!/usr/bin/env python3\n\ntotal_weight, children, at_least_one = [int(x) for x in input().split()]\n# print(\"Total weight: \", total_weight)\n# print(\"Total children: \", children)\n# print(\"At least one of these: \", at_least_one)\n\n\n\n# from math import factorial\n# def combination(n,r):\n# \treturn factorial(n)//factorial(n-r)// factorial(n-r)\nat_least_weights = [0] * (total_weight + 1)\nnot_least_weights = [0] * (total_weight + 1)\nif total_weight < at_least_one:\n\tprint(0)\nelif total_weight == at_least_one:\n\tprint(1)\nelse:\n\tnot_least_weights[0] = 1\n\tfor x in range(1, total_weight + 1):\n\t\tfor y in range(1, at_least_one):\n\t\t\tif x - y >= 0:\n\t\t\t\tnot_least_weights[x] += not_least_weights[x-y]\n\t\t\t\tat_least_weights[x] += at_least_weights[x-y]\n\t\tfor z in range(at_least_one, children + 1):\n\t\t\tif x - z >= 0:\n\t\t\t\tat_least_weights[x] += at_least_weights[x-z]\n\t\t\t\tat_least_weights[x] += not_least_weights[x-z]\t\t\t\t\n\t# print(at_least_weights)\n\tprint(at_least_weights[total_weight] % 1000000007)\n\n\n", "MOD = 10**9 + 7\nn, k, d = [int(k) for k in input().split()]\n\nways1 = [0]*(n+1)\nways1[0] = 1\nways1[1] = 1\nfor i in range(2,n+1):\n    for j in range(max(0,i-k),i):\n        ways1[i] += ways1[j]\n    ways1[i] %= MOD\n#print(ways1)\n\nways2 = [0]*(n+1)\nways2[0] = 1\nways2[1] = 1\n\nif d ==1:\n    ways2[0] = 0\n    ways2[1] = 0\n    \nfor i in range(2,n+1):\n    for j in range(max(0,i-(d-1)),i):\n        ways2[i] += ways2[j]\n    ways2[i] %= MOD\n#print(ways2)\nprint((ways1[n]-ways2[n]) % MOD)", "# 431C\n\nfrom sys import stdin\nimport math\n\n__author__ = 'artyom'\n\n\ndef read_int_ary():\n  return map(int, stdin.readline().strip().split())\n\n\nn, k, d = read_int_ary()\n\ncache = {0: {}, 1: {}}\n\n\ndef f(a, has_d):\n  calced = cache[has_d].get(a)\n  if calced:\n    return calced\n  if a < d and not has_d:\n    return 0\n  if a <= 1 or (a <= d and not has_d):\n    return 1\n  sum = 0\n  x = 1\n  while x <= k and a - x >= 0:\n    sum += f(a - x, has_d or x >= d)\n    x += 1\n  cache[has_d][a] = sum\n  return sum\n\n\nprint(f(n, 0) % 1000000007) if n >= d else print(0)", "inputs = [int(x) for x in input().split()]\n \ndesired_weight = inputs[0]\nk = inputs[1]\nmin_weight = inputs[2]\n\n# desired_weight = 38\n# k = 16\n# min_weight = 15\n# \n\n# desired_weight = 3\n# k = 3\n# min_weight = 3\n\nsaved = [{True: None, False: None} for i in range(desired_weight + 1)]\nsaved[desired_weight] = {True: 0, False: 0}\n\nmodulo = 1000000007\n\nfor i in reversed(range(0, desired_weight)):\n#     print('*** ' + str(i) + ' ***')\n    range_to_work_with = i + k\n    hit_min_value = 0\n    fail_to_hit_min_value = 0\n\n    \n    travel_range = range(i + 1, i + k + 1 if i + k + 1 <= desired_weight + 1 else desired_weight + 1)\n#     print(travel_range)\n    for j in travel_range:\n        if j - i >= min_weight:\n            fail_to_hit_min_value += saved[j][True]\n        else:\n            fail_to_hit_min_value += saved[j][False]\n    fail_to_hit_min_value += 1 if desired_weight - i <= k and desired_weight - i >= min_weight else 0\n            \n    for j in travel_range:\n        hit_min_value += saved[j][True]\n    hit_min_value += 1 if desired_weight - i <= k else 0\n    \n    saved[i][True] = hit_min_value\n    saved[i][False] = fail_to_hit_min_value\n            \n\n# print(saved)     \nprint(saved[0][False] % modulo)", "n, k, d = map(int, input().split())\ndp = [[0 for j in range(2)] for i in range(105)]\ndp[0][1] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, min(i, k)+1):\n        dp[i][0] = (dp[i][0] + dp[i-j][j >= d]) % 1000000007\n        dp[i][1] = (dp[i][1] + dp[i-j][1]) % 1000000007\n\nprint(dp[n][0])", "#!/usr/bin/env python3\n\ndef F(n, k):\n    if k < 2:\n        return k\n    b = [0] * (k - 1) + [1]\n    for i in range(n):\n        b.append(sum(b[-k:]) % (10 ** 9 + 7))\n    return b[-1]\n\nn, k, d = list(map(int, input().split()))\n\nans = F(n, k) - F(n, d - 1)\nif ans < 0:\n    ans += 10 ** 9 + 7\n\nprint(ans)\n"]
["rr = lambda: input().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\n\ndef solve(N, A):\n    ans = 0\n    prev = float('inf')\n    for x in reversed(A):\n        x = min(x, prev - 1)\n        ans += max(x, 0)\n        prev = x\n    return ans\n\nfor tc in range(1):#rri()):\n    N = rri()\n    A = rrm()\n    print(solve(N, A))\n", "import getpass\nimport sys\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n\nimport math\nimport string\nimport re\nimport math\nimport random\nfrom decimal import Decimal, getcontext\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn = ria()[0]\nar = [i for i in reversed(ria())]\np = ar[0]\nsm = ar[0]\nfor i in range(1,n):\n    cr=min(max(0,p-1),ar[i])\n    # print(cr)\n    p=cr\n    sm+=cr\nprint(sm)", "n = int(input())\n\nt = list(map(int, input().split()))\n\nv = [0] * n\nv[-1] = t[-1]\nfor i in range(n - 1 - 1, 0 - 1, -1):\n    v[i] = max(min(v[i + 1] - 1, t[i]), 0)\n\nprint(sum(v))", "n = int(input())\na = list(map(int, input().split()))\nans = 0\nmx = a[-1] + 1\nfor i in range(n-1,-1,-1):\n    ans += max(0, min(mx-1, a[i]))\n    mx = min(mx-1, a[i])\nprint(ans)", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\n\nisdebug = False\ntry :\n    #raise ModuleNotFoundError\n    import pylint\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\n    isdebug = True\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef red_inout():\n    inId = 0\n    outId = 0\n    if not isdebug:\n        inId = 0\n        outId = 0\n    if inId>0:\n        dprint('use input', inId)\n        try:\n            f = open('input'+ str(inId) + '.txt', 'r')\n            sys.stdin = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n        except Exception:\n            dprint('invalid input file')\n    if outId>0:\n        dprint('use output', outId)\n        try:\n            f = open('stdout'+ str(outId) + '.txt', 'w')\n            sys.stdout = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n        except Exception:\n            dprint('invalid output file')\n            \n        atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\nif isdebug and len(sys.argv) == 1:\n    red_inout()\n\ndef getIntList():\n    return list(map(int, input().split()))            \n\ndef solve(): \n    pass\n    \nT_ = 1    \n#T_, = getIntList()\n\nfor iii_ in range(T_):\n    #solve()\n    N,  = getIntList()\n    #print(N)\n    za =  getIntList()\n    r = 0\n    now = 10**10\n    for i in range(N-1, -1, -1):\n        x = min(now-1, za[i])\n        if x<=0: break\n        now = x\n        r+=x\n    print(r)\n", "n=int(input())\nl=list(map(int,input().split()))\nans=0\ncurr=1000000001\nfor i in range(n-1,-1,-1):\n         if(l[i]<curr):\n                  curr=l[i]\n         elif(curr>0):\n                  curr-=1\n         ans+=curr\nprint(ans)", "import math\nn = int(input())\na = list(map(int, input().split()))\na = list(reversed(a))\ns = 0\nm = math.inf\nfor i in range(len(a)):\n    m = min(max(m-1, 0), a[i])\n    s +=m\nprint(s)", "n = int(input())\na = list(map(int, input().split()))\nc = a[-1]\nres = c\nfor i in a[::-1][1:]:\n    if i < c:\n        res += i\n        c = i\n    else:\n        if c == 0:\n            break\n        res += c - 1\n        c -= 1\nprint(res)", "n = int(input())\nA = [int(i) for i in input().split()]\nans = 0\ncurmax = 10**10\nfor i in range(n-1, -1, -1):\n    if curmax==0:\n        continue\n    if A[i] < curmax:\n        ans += A[i]\n        curmax = A[i]\n    else:\n        ans += curmax-1\n        curmax-=1\nprint(ans)\n    \n    \n", "n = int(input())\na = list(map(int, input().split()))\nmaxi = 10**11\nans = 0\nfor i in range(n - 1, -1, -1):\n    maxi = max(min(a[i], maxi - 1), 0)\n    ans += maxi\nprint(ans)\n", "n = int(input())\nA = list(map(int, input().split()))\ncnt = 0\nz = float('inf')\nfor i in range(n - 1, -1, -1):\n    if z > A[i]:\n        z = min(z, A[i])\n        cnt += z\n    else:\n        z -= 1\n        z = max(0, z)\n        cnt += z\nprint(cnt)", "n = int(input())\na = list(map(int, input().split()))\n\nr = 10**10\nans = 0\nfor i in range(n):\n    r = max(min(r - 1, a[n - i - 1]), 0)\n    ans += r\nprint(ans)\n", "n=int(input())\narr=list(map(int,input().split()))\nans=arr[-1]\nval=max(arr[-1]-1,0)\nfor i in range(n-2,-1,-1):\n\tif(arr[i]>val):\n\t\tans+=val\n\t\tval=max(val-1,0)\n\telse:\n\t\tans+=arr[i]\n\t\tval=max(arr[i]-1,0)\nprint(ans)\n", "n = int(input())\nl = [*map(int, input().split())]\nm = [e for e in l]\nfor i in range(n - 2, -1, -1):\n    m[i] = max(0, min(m[i], m[i + 1] - 1))\nprint(sum(m))", "n = int(input())\nu = list(map(int, input().split()))\nfor i in range(n - 2, -1, -1):\n    if u[i] >= u[i + 1] and u[i] != 0:\n        u[i] = u[i + 1] - 1\n        if u[i + 1] == 0:\n            u[i] = 0\n    \nprint(sum(u))\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    li = get_list()\n    li.reverse()\n    k = 1000000000000000\n    res = 0\n    for i in li:\n        k = max(min(i,k-1),0)\n        res+=k\n    print(res)\n\n    \n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "'''input\n4\n1 1 1 1\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn=ri(1)\na=ri()\nc=0\nlast=0\nans=0\nans=[a[-1]]\nfor i in range(n-2,-1,-1):\n\tans.append(min(ans[-1]-1,a[i]))\nfor i in ans:\n\tif i>0:\n\t\tc+=i\nprint(c)", "input()\nS=list(map(int,input().split()))\nan=S[-1]\nla = S[-1]\n\nfor i in range(len(S) - 2, -1,-1):\n    ne = max(min(la-1,S[i]), 0)\n    an += ne\n    la = ne\nprint(an)    ", "import sys\nsys.setrecursionlimit(2000)\nfrom collections import Counter\nfrom functools import reduce\n# sys.stdin.readline()\n\ndef __starting_point():\n\n    # single variables\n    n = [int(val) for val in sys.stdin.readline().split()][0]\n    a = [int(val) for val in sys.stdin.readline().split()]\n\n\n    prev = a[-1]\n    count = prev\n    for i in range(n-2, -1, -1):\n        prev = min(a[i], prev-1)\n        prev = max(prev, 0)\n        count += prev\n\n    print(count)       \n \n\n\n__starting_point()", "n = int(input())\na = [int(t) for t in input().split(' ')]\n\nINF = 10**10\n\ni = n-1\ntotal = 0\nmn = INF\nwhile i >= 0:\n    mn = max(0, min(mn - 1, a[i]))\n    total += mn\n    i -= 1\n\nprint(total)\n", "'''stdin=open('input.txt')\n\ndef input():\n\treturn stdin.readline()[:-1]'''\n\n# a, b = map(int, input().split())\n\n# l = list(map(int, input().split()))\n\n\n# CODE BEGINS HERE.................\n\nn = int(input())\na = list(map(int, input().split()))\n\na = a[::-1]\n\nans = a[0]\nfor i in range(1, n):\n\tif a[i] >= a[i - 1]:\n\t\tans += max(a[i - 1] - 1, 0)\n\t\ta[i] = max(a[i - 1] - 1, 0)\n\telse:\n\t\tans += a[i]\n\nprint(ans)\n#CODE ENDS HERE....................\n\n\n", "n=int(input())\na=list(map(int,input().split()))\nsumm=0\ni=n-1\nminn=a[i]\nwhile i>=0:\n    if minn>=a[i]:\n        summ+=a[i]\n        minn=a[i]-1\n    else:\n        summ+=minn\n        minn=max(0,minn-1)\n    i-=1\nprint(summ)", "n = int(input())\na = list(map(int, input().split()))\n\na = a[::-1]\n\nk = 0\nmx = a[0] + 2\n\nfor c in a:\n\tmx = max(0, mx - 1)\n\t#print(k, c, mx)\n\tif c < mx:\n\t\tk += c\n\t\tmx = c\n\t\n\telif mx == c:\n\t\tk += max(c, 0)\n\t\tmx = max(c, 0)\n\t\n\telse:\n\t\tk += mx\n\nprint(k)\n", "n = int(input())\ns = [int(i) for i  in input().split()]\ns = s[::-1]\nc = 100000000000\nans = 0\nfor i in s:\n    if i < c:\n        c = i\n    else:\n        c = max(c-1, 0)\n    ans+=c\nprint(ans)"]
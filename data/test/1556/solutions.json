["import heapq as hq\nfrom math import ceil\nn, k, x = [int(i) for i in input().strip().split(' ')]\narr = [int(i) for i in input().strip().split(' ')]\nis_neg = False\nfor i in arr:\n    if i < 0:\n        is_neg = True if is_neg == False else False\n\nnarr = [[abs(i), pos, i < 0] for pos, i in enumerate(arr)]\nhq.heapify(narr)\nif is_neg:\n    while k > 0:\n        hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\n        k -= 1\nelse:\n    minode = hq.heappop(narr)\n    mi = minode[0]\n    kswitch = ceil(mi/x) #make the off number of negatives\n    if kswitch > k:\n        kswitch = k\n    else:\n        minode[2] = False if minode[2] == True else True\n    k -= kswitch\n\n    hq.heappush(narr, [abs(mi-kswitch*x), minode[1], minode[2]])\n    while k > 0:\n        hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\n        k -= 1\n\nnarr = sorted(narr, key=lambda x:x[1])\narr = [str(i[0]*(-1 if i[2] else 1)) for i in narr]\nprint(\" \".join(arr))", "import heapq\n\ninp = list(map(int, input().split()))\nn = inp[0]\nk = inp[1]\nx = inp[2]\n\na = [int(i) for i in input().strip().split(' ')]\n\nisPositive = True\nnodes = [[abs(val), val, index] for index, val in enumerate(a)]\n\nfor el in a:\n    if el < 0:\n        isPositive = not isPositive\n\nheapq.heapify(nodes)\n\nfor i in range(k):\n    minNode = nodes[0]\n    val = minNode[1]\n    isCurPositive = val >= 0\n    newVal = val\n    if isPositive == isCurPositive:\n        newVal -= x\n    else:\n        newVal += x\n\n    minNode[1] = newVal\n    if val >= 0 > newVal or val < 0 <= newVal:\n        isPositive = not isPositive\n\n    heapq.heapreplace(nodes, [abs(newVal), newVal, minNode[2]])\n\nresult = [None] * n\nfor node in nodes:\n    result[node[2]] = str(node[1])\n\nprint(\" \".join(result))\n", "import heapq\n\nn,k,v = list(map(int, input().split()))\nnum = list(map(int, input().split()))\n\nsign = len([x for x in num if x<0])\nminx,mini = min([[abs(x),i] for i,x in enumerate(num)])\n\nif sign%2==0:\n    if num[mini]<0:\n        c = min(minx//v+1, k)\n        k -= c\n        num[mini] += v*c\n    elif num[mini]>=0:\n        c = min(minx//v+1, k)\n        k -= c\n        num[mini] -= v*c\n\n\nheap = []\nheapq.heapify(heap)\nfor i,x in enumerate(num):\n    heapq.heappush(heap, [abs(x), i])\n\nwhile k:\n    absx,curi = heapq.heappop(heap)\n    #print(curi, num[curi])\n    if num[curi]>=0:\n        num[curi] += v\n    else:\n        num[curi] -= v\n    heapq.heappush(heap, [abs(num[curi]),curi])\n    k -= 1\n    \nprint(' '.join([str(x) for x in num]))\n", "def main():\n    from heapq import heapify, heappop, heappushpop,heappush\n    n, k, x = map(int, input().split())\n    l, sign, h = list(map(int, input().split())), [False] * n, []\n    helper = lambda: print(' '.join(str(-a if s else a) for a, s in zip(l, sign)))\n    for i, a in enumerate(l):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    a, i = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            l[i] = a\n            return helper()\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        a, i = heappushpop(h, (a, i))\n        a += x\n    l[i] = a\n    for a, i in h:\n        l[i] = a\n    helper()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\ns = input().split()\nn = int(s[0])\nk = int(s[1])\nx = int(s[2])\nneg=0\nzeroes=0\nnumbers = list(map(int,input().split()))\nnum = []\nfor i in numbers:\n\tif(i<0):\n\t\tneg+=1\n\telif(i==0):\n\t\tzeroes+=1\n\nfor i,x1 in enumerate(numbers):\n\tnum.append([abs(x1),i])\nheapq.heapify(num)\ntemp=[]\nsteps=0\nif(neg%2==0):\n\ttemp = heapq.heappop(num)\n\t# print(temp[1],temp[0])\n\t# print(numbers[temp[1]],x)\n\tif(numbers[temp[1]]<0):\n\t\tsteps = min(abs(numbers[temp[1]])//x+1,k)\n\t\tk-=steps\n\t\tnumbers[temp[1]]+=steps*x\n\t\theapq.heappush(num,[abs(numbers[temp[1]]),temp[1]])\n\telse:\n\t\tsteps = min((abs(numbers[temp[1]])//x)+1,k)\n\t\t# print(steps)\n\t\tk-=steps\n\t\tnumbers[temp[1]]-=steps*x\n\t\theapq.heappush(num,[abs(numbers[temp[1]]),temp[1]])\n\nwhile(k>0):\n\ttemp = heapq.heappop(num)\n\t# print(temp[1],temp[0])\n\tif(numbers[temp[1]]<0):\n\t\t# steps = (numbers[temp[1]]//x+1)\n\t\t# k-=steps\n\t\tnumbers[temp[1]]-=x\n\t\theapq.heappush(num,[abs(numbers[temp[1]]),temp[1]])\n\telse:\n\t\t# steps = (numbers[temp[1]]//x+1)\n\t\t# k-=steps\n\t\tnumbers[temp[1]]+=x\n\t\theapq.heappush(num,[abs(numbers[temp[1]]),temp[1]])\n\tk-=1\nfor i in numbers:\n\tprint(i,end=\" \")\n\n", "import heapq\n\nn, k, X = list(map(int, input().split()))\na       = list(map(int, input().split()))\nQ       = []\nsit     = 0\n\nfor i, x in enumerate(a):\n    if x < 0:\n        sit += 1\n    heapq.heappush(Q, (abs(x), x, i))    \n        \nsit = sit % 2\n\nwhile k > 0:\n    (val, x, i) = heapq.heappop(Q)\n    change = None\n    \n    if x < 0:\n        if sit == 1:\n            change = x - X\n        else:\n            change = x + X\n    else:\n        if sit == 1:\n            change = x + X\n        else:\n            change = x - X\n    \n    if (x * change < 0) or (x < 0 and change == 0) or (x == 0 and change < 0):\n        sit = (sit+1) % 2\n        \n    heapq.heappush(Q, (abs(change), change, i))\n    k-=1\n    \nans = [0] * n\nfor (val, x, i) in Q:\n    ans[i] = str(x)\nprint(' '.join(ans))    \n\n#5 3 1\n#5 4 3 5 2\n\n#5 3 1\n#5 4 3 5 5\n\n#5 3 1\n#5 4 4 5 5\n\n#3 2 7\n#5 4 2\n", "import heapq\n\nn, k, x = [int(val) for val in input().split()]\na = [int(val) for val in input().split()]\n\ndata = [(val, 1, i) if val >= 0 else (-1 * val, -1, i) for i, val in enumerate(a)]\nheapq.heapify(data)\nsign = sum([1 if s == -1 else 0 for _, s, _ in data])\n\nif sign % 2 == 1:\n    for i in range(k):\n        e = heapq.heappop(data)\n        heapq.heappush(data, (e[0] + x, e[1], e[2]))\nelse:\n    e = heapq.heappop(data)\n    if e[0] <  k * x:\n        s = (e[0] // x) + 1\n        k -= s\n        heapq.heappush(data, (s * x - e[0], -1 * e[1], e[2]))\n        for i in range(k):\n            e = heapq.heappop(data)\n            heapq.heappush(data, (e[0] + x, e[1], e[2]))\n    else:\n        heapq.heappush(data, (e[0] - k * x, e[1], e[2]))\n\noutput = [0] * n\nfor val, s, i in data:\n    output[i] = s * val\nprint(' '.join([str(val) for val in output]))\n   \n"]
["class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid) #row\n         n = len(obstacleGrid[0]) #col\n         path = [[0 for j in range(n)] for i in range(m)]\n         for i in range(m):\n             if obstacleGrid[i][0] == 0:\n                 path[i][0] = 1\n             else:\n                 break\n         for i in range(n):\n             if obstacleGrid[0][i] == 0:\n                 path[0][i] = 1\n             else:\n                 break\n         for i in range(1,m):\n             for j in range(1,n):\n                 if obstacleGrid[i][j] != 1:\n                     path[i][j] = path[i-1][j] + path[i][j-1]\n                 else:\n                     path[i][j] = 0\n         return path[m-1][n-1]\n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         if not obstacleGrid or not obstacleGrid[0]:\n             return 0\n \n         m, n = len(obstacleGrid), len(obstacleGrid[0])\n \n         # DP:\n         #   dp(i, j):   no. of unique paths to obstacleGrid[i][j]\n         #   bound:\n         #       dp(0, 0) = 0 if obstacleGrid[0][0] == 1 else 1\n         #       dp(-1, *) = 0\n         #       dp(*, -1) =  0\n         #   progress:\n         #       dp(i, j) = | 0,             if obstacleGrid[i][j] == 1\n         #                  | dp(i-1, j) + dp(i, j-1),           else\n \n         dp = [0] * n\n         for i in range(m):\n             for j in range(n):\n                 if obstacleGrid[i][j] == 1:\n                     dp[j] = 0\n                 else:       \n                     if i == 0:\n                         if j == 0:\n                             dp[j] = 1\n                         else:\n                             dp[j] = dp[j-1]\n                     else:\n                         if j > 0:\n                             dp[j] = dp[j] + dp[j-1]\n                             \n         \n         return dp[n-1]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not obstacleGrid:\n             return 0\n         if obstacleGrid[-1][-1] == 1:\n             return 0\n         dp = []\n         for each in obstacleGrid:\n             temp = each[:]\n             dp.append(temp)\n \n         for i in range(len(dp[0])):\n             if obstacleGrid[0][i] == 1:\n                 # dp[0][i] = 0\n                 break\n             else:\n                 dp[0][i] = 1\n         for j in range(len(dp)):\n             if obstacleGrid[j][0] == 1:\n                 break\n             else:\n                 dp[j][0] = 1\n         \n         # print(dp,obstacleGrid)\n         \n         for row in range(1, len(obstacleGrid)):\n             for col in range(1, len(obstacleGrid[0])):\n                 if obstacleGrid[row][col] == 0:\n                     if obstacleGrid[row - 1][col] != 1:\n                         dp[row][col] += dp[row - 1][col]\n                     if obstacleGrid[row][col - 1] != 1:\n                         dp[row][col] += dp[row][col - 1]\n         print(dp)\n         return dp[-1][-1]", "class Solution:\n     def paths(self,obstacleGrid,n,m,a,b,memo):\n         if n>a or m>b:\n             return 0\n \n         if obstacleGrid[n][m] == 1:\n             return 0\n \n         if n==a and m==b:\n             return 1\n \n         if str(n)+\" \"+str(m) not in memo:\n             memo[str(n)+\" \"+str(m)]=self.paths(obstacleGrid,n+1,m,a,b,memo)+self.paths(obstacleGrid,n,m+1,a,b,memo)\n \n         return memo[str(n)+\" \"+str(m)]\n \n         \n         \n         \n         \n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         a = len(obstacleGrid)\n         b= len(obstacleGrid[0])\n         memo = dict()\n         return  self.paths(obstacleGrid,0,0,a-1,b-1,memo)\n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if len(obstacleGrid)==0 and len(obstacleGrid[0])==0:\n             return 1\n         if len(obstacleGrid)==0:\n             return 0\n         \n         \n         ob=False\n         for i in range(len(obstacleGrid)):\n             for j in range(len(obstacleGrid[i])):\n                 if obstacleGrid[i][j]==1:\n                     obstacleGrid[i][j]=None\n                     ob=True\n                     \n         for i in range(len(obstacleGrid)):            \n             if obstacleGrid[i][0]==0:\n                 obstacleGrid[i][0]=1\n             if obstacleGrid[i][0]==None:\n                 break\n                 \n         for i in range(len(obstacleGrid[0])):            \n             if obstacleGrid[0][i]==0:\n                 obstacleGrid[0][i]=1\n             if obstacleGrid[0][i]==None:\n                 break\n                 \n         for i in range(1,len(obstacleGrid)):\n             for j in range(1,len(obstacleGrid[i])):\n                 if obstacleGrid[i][j]!=None:\n                     if obstacleGrid[i-1][j]==None and obstacleGrid[i][j-1]==None:\n                         obstacleGrid[i][j]=None\n                     elif obstacleGrid[i-1][j]==None and obstacleGrid[i][j-1]!=None:\n                         obstacleGrid[i][j]=obstacleGrid[i][j-1]\n                     elif obstacleGrid[i-1][j]!=None and obstacleGrid[i][j-1]==None:\n                         obstacleGrid[i][j]=obstacleGrid[i-1][j]\n                     else:\n                         obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1]\n                 \n         if len(obstacleGrid)==1 or len(obstacleGrid[0])==1:\n             if ob:\n                 return 0\n             else:\n                 return 1\n         \n         if obstacleGrid[-1][-1]==None or obstacleGrid[0][0]==None:\n             return 0\n         \n         return obstacleGrid[-1][-1]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         1 1 0\n         1 1 0\n         1 1 0\n         \"\"\"\n         if not any(obstacleGrid):\n             return 0\n \n         n, m = len(obstacleGrid), len(obstacleGrid[0])\n         dp = [[1 if i == 0 or j == 0 else 1 for j in range(m)] for i in range(n)]\n \n         # Set first column of dp.\n         obs = False\n         first_col = [i[0] for i in obstacleGrid]\n \n         try:\n             idx = first_col.index(1)\n             for i in range(n):\n                 dp[i][0] = 1 if i < idx else 0\n         except ValueError:\n             pass\n \n         # Set first row of dp.\n         try:\n             first_row = obstacleGrid[0]\n             idx = first_row.index(1)\n             dp[0] = [1] * idx + [0] * (m - idx)\n         except ValueError:\n             pass\n \n         print(obstacleGrid)\n         for i in range(1, n):\n             for j in range(1, m):\n                 print(i, j)\n                 if obstacleGrid[i][j] == 1:\n                     dp[i][j] = 0\n                 else:\n                     dp[i][j] = dp[i-1][j] + dp[i][j-1]\n         return dp[n-1][m-1]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         P = [[0 for j in range(n+1)] for i in range(m+1)]\n         \n         P[0][1] = 1\n         \n         for i in range(1,m+1):\n             for j in range(1, n+1):\n                 if obstacleGrid[i-1][j-1] != 1:\n                     P[i][j] = P[i-1][j] + P[i][j-1]\n         return P[m][n]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         ResGrid = [[0 for x in range(n+1)] for x in range(m+1)]\n         ResGrid[0][1] = 1\n \n         for i in range(1, m+1):\n             for j in range(1, n+1):\n                 if not obstacleGrid[i-1][j-1]:\n                     ResGrid[i][j] = ResGrid[i][j-1]+ResGrid[i-1][j]\n \n         return ResGrid[m][n]\n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         dp = [0] * n  # \u8fd9\u91cc\u5148\u586b\u5145\u4e860\uff0c\u8fd9\u6837\u5f53i==0\u65f6\u4e5f\u53ef\u4ee5dp[j] += dp[j-1]\n         for i in range(m):\n             for j in range(n):\n                 if obstacleGrid[i][j] == 1:  # \u9047\u5230\u969c\u788d\u7269\u76f4\u63a5\u4e3a0\n                     dp[j] = 0\n                 else:  # \u6ca1\u6709\u9047\u5230\u969c\u788d\u7269\n                     if i == 0 and j == 0:  # \u5de6\u4e0a\u89d2\u603b\u662f\u4e3a1\uff0c\u4e5f\u4e3a\u540e\u9762i!=0\u800cj==0\u7684\u60c5\u51b5\u505a\u94fa\u57ab\n                         dp[j] = 1\n                     elif j != 0:  # \u56e0\u4e3aj==0\u65f6\uff0c\u5e94\u8be5\u4e3adp[j] += 0\uff0c\u7b49\u4e8e\u4e0d\u53d8\uff0c\u6240\u4ee5continue\n                         dp[j] += dp[j - 1]\n         return dp[-1]", "class Solution:\n     def paths(self,obstacleGrid,n,m,a,b,memo):\n         if n>a or m>b:\n             return 0\n \n         if obstacleGrid[n][m] == 1:\n             return 0\n \n         if n==a and m==b:\n             return 1\n \n         if str(n)+\" \"+str(m) not in memo:\n             memo[str(n)+\" \"+str(m)]=self.paths(obstacleGrid,n+1,m,a,b,memo)+self.paths(obstacleGrid,n,m+1,a,b,memo)\n \n         return memo[str(n)+\" \"+str(m)]\n \n         \n         \n         \n         \n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         a = len(obstacleGrid)\n         b= len(obstacleGrid[0])\n         memo = dict()\n         return  self.paths(obstacleGrid,0,0,a-1,b-1,memo)\n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not len(obstacleGrid) >0 :\n             return 0\n             \n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         arr = [[1 for y in range(n)] for x in range(m)]\n         for x in range(m):\n             for y in range(n):\n                 if x == 0:\n                     arr[x][y] = arr[x][y-1]\n                 elif y == 0:\n                     arr[x][y] = arr[x-1][y]\n                 else:\n                     arr[x][y] = arr[x-1][y] + arr[x][y-1]\n                 if obstacleGrid[x][y] == 1:\n                     arr[x][y] = 0\n         return arr[-1][-1]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         # m * n\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         ways = [[0 for i in range(n)] for j in range(m)]\n         for i in range(m):\n             for j in range(n):\n                 if obstacleGrid[i][j] == 1:\n                     ways[i][j] = 0\n                 elif i == 0 and j == 0:\n                     ways[i][j] = 1\n                 elif i == 0:\n                     ways[i][j] = ways[i][j-1]\n                 elif j == 0:\n                     ways[i][j] = ways[i-1][j]\n                 else:\n                     ways[i][j] = ways[i-1][j] + ways[i][j-1]\n         return ways[m-1][n-1]\n                     \n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m, n = len(obstacleGrid), len(obstacleGrid[0])\n         dp = [[1] * n for _ in range(m)]\n         for i in range(m):\n             dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i-1][0]\n         for j in range(n):\n             dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j-1]\n         \n         for i in range(1, m):\n             for j in range(1, n):\n                 if obstacleGrid[i][j] == 1:\n                     dp[i][j] = 0\n                 else:\n                     dp[i][j] = dp[i-1][j] + dp[i][j-1]\n         return dp[m-1][n-1]", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         mat = [[0] * n for _ in range(m)]\n         if not obstacleGrid[0][0]:\n             mat[0][0] = 1\n         for row in range(m):\n             for col in range(n):\n                 if col == 0 and row == 0:\n                     mat[row][col] = obstacleGrid[row][col] * -1 + 1\n                 elif obstacleGrid[row][col] == 1:\n                     mat[row][col] == 0\n                 else:\n                     mat[row][col] = mat[row - 1][col] + mat[row][col - 1]\n         return mat[m - 1][n - 1]\n", "class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         \"\"\"\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(obstacleGrid)\n         n = len(obstacleGrid[0])\n         \n         dp = [[0 for _ in range(n)] for _ in range(m)]\n         for i in range(n):\n             if obstacleGrid[0][i] == 0:\n                 dp[0][i] = 1\n             else:\n                 break\n         for j in range(m):\n             if obstacleGrid[j][0] == 0:\n                 dp[j][0] = 1\n             else:\n                 break\n         \n         if obstacleGrid[m-1][n-1] == 1:\n             return 0\n         \n         print(dp)\n \n         for y in range(1, n):\n             for x in range(1, m):\n                 if obstacleGrid[x][y] == 1:\n                     dp[x][y] = 0\n                 else: \n                     dp[x][y] = dp[x - 1][y] + dp[x][y - 1]\n \n         return dp[m - 1][n - 1]"]
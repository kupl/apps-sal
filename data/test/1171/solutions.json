["n, k = map(int, input().split())\nv = list(map(int, input().split()))\nreverse_v = v[::-1]\nlst = [0] * (k + 1)\nleft = [[]]\nright = [[]]\nfor i in range(1, n+1):\n  left.append(v[:i])\n  right.append(reverse_v[:i])\n\nfor cnt in range(1, k+1):\n  rest = k - cnt\n  total = 0\n  if cnt <= n:\n    for j in range(cnt+1):\n      lst_j = left[j] + right[cnt-j]\n      lst_j.sort()\n      l = cnt\n      for idx in range(cnt):\n        if lst_j[idx] >= 0:\n          l = idx\n          break\n      if l == cnt:\n        value = 0\n      else:\n        flg = min(l, rest)\n        value = sum(lst_j[flg:])\n      if value > total:\n        total = value\n    lst[cnt] = total\n\nans = max(lst)\nprint(ans)", "N, K, *V = list(map(int, open(0).read().split()))\n\n# i: \u64cd\u4f5c\u56de\u6570\n# j: \u53d6\u308a\u51fa\u3059\u500b\u6570\n# k: \u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\u7bc4\u56f2 [0, k)\nans = 0\nfor i in range(K + 1):\n    for j in range(min(N + 1, i + 1)):\n        for k in range(j + 1):\n            right = N - j + k\n            tmp = V[:k] + V[right:]\n            tmp.sort()\n            ans = max(ans, sum(tmp) - sum([t for t in tmp if t < 0][: i - j]))\nprint(ans)\n", "n, k = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nans = 0\nfor i in range(n+1):\n    for j in range(n+1):\n        if i + j <= k and i + j <= n:\n            g = v[:i] + v[n-j:]\n            g.sort()\n            for l in range(min(k-i-j, i+j)+1):\n                ans = max(ans, sum(g[l:]))\n\nprint(ans)\n", "import heapq\nimport itertools\ndef main():\n    n,k=list(map(int, input().split()))\n    v=[int(i) for i in input().split()]\n    #k\u56deV\u306e\u4e21\u7aef\u304b\u3089\u53d6\u308a\u51fa\u3057\u305f\u308a\u8a70\u3081\u305f\u308a\u3057\u3066\u6301\u3063\u3066\u308b\u3082\u306e\u306e\u4fa1\u5024\u306e\u6700\u5927\u5316\u3092\u3059\u308b\n    v_1 = v[::-1]\n    #\u5de6\u304b\u3089\u53d6\u308b\u56de\u6570\u3092A\u3001\u53f3\u304b\u3089\u53d6\u308b\u56de\u6570\u3092B\u3068\u3057\u305f\u3068\u304d\u3001\u4fa1\u5024\u304c\u8ca0\u306e\u5b9d\u77f3\u3092\u6368\u3066\u308b\u64cd\u4f5c\u306f\uff08k-(A+B)\uff09\u56de\u3067\u304d\u308b\n    #\u3053\u308c\u3092\u5229\u7528\u3057\u3066\u5168\u63a2\u7d22\n    res = 0\n    for i in range(k+1):\n        j = 0\n        while(i+j<=min(n,k)):\n\n            q = []\n            tmp = 0\n            if(i>0):\n                for l in range(i):\n                    if(v[l]<0):\n                        heapq.heappush(q,v[l])\n                    tmp += v[l]\n            if(j>0):\n                for l in range(j):\n                    if(v_1[l]<0):\n                        heapq.heappush(q,v_1[l])\n                    tmp += v_1[l]\n            for l in range(k-(i+j)):\n                if(len(q)>0):\n                    z = heapq.heappop(q)\n                    tmp -= z\n            j+=1\n            res = max(res,tmp)\n\n    print(res)\ndef __starting_point():\n    main()\n\n__starting_point()", "def abc128_d():\n    n, k = map(int, input().split())\n    v = list(map(int, input().split()))\n    ans = 0\n\n    for a in range(max(1, k+1)):  # \u5de6\u304b\u3089\u53d6\u308b\u500b\u6570\n        for b in range(max(1, k-a+1)):  # \u53f3\u304b\u3089\u53d6\u308b\u500b\u6570\n            if a+b > n: break\n            arr = []\n            if a > 0: arr += v[:a]\n            if b > 0 and a < n: arr += v[max(a, 0, n-b):]\n            arr.sort()\n            for j in range(max(1, a+b)):  # \u623b\u3059\u500b\u6570\n                if a+b+j > k: break\n                score = sum(arr[j:])\n                ans = max(ans, score)\n                #print(a, b, j, score, arr)\n    print(ans)\n\ndef __starting_point():\n    abc128_d()\n__starting_point()", "# \u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\u30d1\u30bf\u30fc\u30f3\u306f\u6700\u592750\u901a\u308a\n# \u53f3\u304b\u3089\u53d6\u308a\u51fa\u3059\u30d1\u30bf\u30fc\u30f3\u306f\u6700\u592750\u901a\u308a\n# \u305d\u306e\u7d44\u307f\u5408\u308f\u305b\u306f2500\u901a\u308a\n# \u305d\u306e\u5168\u901a\u308a\u306b\u5bfe\u3057\u3066\u3001\u30de\u30a4\u30ca\u30b9\u306e\u77f3\u3092\u5f15\u3051\u308b\u3060\u3051\u5f15\u304f\u30d1\u30bf\u30fc\u30f3\u3092\u8a66\u3059\u306850\n# 125000\n# \u3059\u3079\u3066\u8a66\u3059\n\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nV = [0] + list(map(int,readline().split())) + [0]\nN += 2\nK += 2\n\nleftsum = 0\nleftminus = []\nans = -(10 ** 9)\nfor left in range(min(N,K)):\n  leftsum += V[left]\n  if V[left] < 0:\n    leftminus += [V[left]]\n  rightsum = 0\n  rightminus = []\n  limit = min(N - (left + 1) , K - (left + 1))\n  for right in range(N - 1, N - limit - 1, -1):\n    rightsum += V[right]\n    if V[right] < 0:\n      rightminus += [V[right]]\n    allsum = leftsum + rightsum\n    rest = max(K - ((left + 1) + (N - right)),0)\n    allminus = sorted(leftminus + rightminus)\n    allsum -= sum(allminus[:rest])\n    if allsum > ans:\n      ans = allsum\nprint(ans)", "N, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nmax_value = -10**9\nfor kL in range(0, K+1):\n    for kR in range(0, K+1):\n        if kL + kR > min(N, K):\n            continue\n        vL = V[:kL]\n        vR = []\n        if kR:\n            vR = V[-kR:]\n        hand = list(sorted(vL + vR, reverse=True))\n        rest = K - (kL + kR)\n        for kD in range(rest):\n            if len(hand) == 0:\n                break\n            if hand[-1] < 0:\n                hand.pop()\n            else:\n                break\n        value = sum(hand[:K])\n        if value > max_value:\n            max_value = value\nprint(max_value)\n", "n,k=map(int,input().split())\nv=[int(x) for x in input().split()]\n\nr=min(n,k)\nans=-10**9\nfor i in range(r+1):\n  for j in range(r+1):\n    if i+j > r: continue;\n    l=v[:i]+v[::-1][:j]\n    m=sorted([l[x] for x in range(len(l)) if l[x]<0])[:k-(i+j)]\n    ans=max(ans, sum(l)-sum(m))\n    \nprint(ans)", "from heapq import heapify, heappop, heappush\n\nN, K = map(int, input().split())\nV = list(map(int, input().split()))\nINF = 10**9\n\ndef h(X, cnt):\n  S = sum(X)\n  heapify(X)\n  limit = cnt\n  while cnt < K and cnt < 2*limit:\n    m = heappop(X)\n    if m >= 0:\n      break\n    S -= m\n    cnt += 1\n  return S\n\nans = 0\n\nfor i in range(1, min(N, K)+1):\n  if i != N:\n    for j in range(i+1):\n      X = V[:i-j] + V[N-j:]\n      ans = max(ans, h(X, i))\n  else:\n    ans = max(ans, h(V, i))\n\nprint(ans)", "from heapq import *\nn, k = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nres = 0\nnum = min(k, n)\nfor a in range(num + 1):\n    for b in range(num + 1 - a):\n        l = min(k - (a + b), a + b)\n        s = d[:a] + d[-b:] if b != 0 else d[:a]\n        heapify(s)\n        for _ in range(l):\n            tmp = heappop(s)\n            if tmp > 0:\n                heappush(s, tmp)\n                break\n        res = max(res, sum(s))\nprint(res)\n", "from sys import stdin\ninput = stdin.readline\n\nN, K = map(int, input().split())\nV = list(map(int, input().split()))\ntarg = min(N, K)\n\nans = -float(\"inf\")\n\n#i: \u5de6\u304b\u3089\u53d6\u308b\u56de\u6570\nfor i in range(targ+1):\n    #j: \u53f3\u3092\u53d6\u308b\u56de\u6570\n    for j in range(targ+1-i):\n        get = sorted(V[:i] + V[N-j:])\n        tmp = sum(get)\n        for k in range(min(K-i-j, i+j)):\n            tmp = max(tmp, tmp-get[k])\n        \n        ans = max(tmp, ans)\n\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\ndef main():\n    N, K = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n\n    # \u65b9\u91dd: \u64cd\u4f5cA\u306e\u56de\u6570\u30fb\u64cd\u4f5cB\u306e\u56de\u6570\u3067\u5168\u63a2\u7d22\n    ans = 0\n    R = min(N,K)\n\n    for i in range(R+1):\n        for j in range(R+1-i):\n            tmp = 0\n            q = []# \u4fa1\u5024\u304c\u8ca0\u306e\u5b9d\u77f3\u3092\u3044\u308c\u308b(C)\n            \n            for k in range(i):\n                tmp += V[k]\n                if V[k] < 0:\n                    q.append(V[k])\n            for k in range(j):\n                tmp += V[N-1-k]\n                if V[N-1-k] < 0:\n                    q.append(V[N-1-k])\n\n            q.sort()\n            tmp -= sum(q[:min(len(q),K-i-j)])\n            ans = max(ans,tmp)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import copy\n    n,k = list(map(int,input().split()))\n    v = list(map(int,input().split()))\n    ans = 0\n    for i in range(min(n+1,k+1)):\n        t = v[0:i]\n        for j in range(min(n-i+1,k-i+1)):\n            t_ = copy.deepcopy(t)\n            t_ += v[n-j:n]\n            \n            r = k-i-j\n            t_ = sorted(t_)\n            cnt = 0\n            for l in range(len(t_)):\n                if t_[l]<0 and cnt<r:\n                    t_[l] = 0\n                    cnt += 1\n                else:\n                    break\n            if ans<sum(t_):\n                ans = sum(t_)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = 0  # \u4f55\u3082\u3057\u306a\u3044\u30680\u306a\u306e\u3067\u3001ans\u306e\u521d\u671f\u5024\u306f0\n\n\n# pick->\u53d6\u308a\u51fa\u3059\u64cd\u4f5c\u3092\u3059\u308b\u56de\u6570(list\u3088\u308a\u591a\u304f\u53d6\u308a\u51fa\u3055\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f)\nfor pick in range(min(K+1, N+1)):\n    # \u53f3\u304b\u3089\u53d6\u308a\u51fa\u3059\u6570\n    for right in range(pick+1):\n        left = pick-right  # \u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\u6570\n        pick_list = V[:right]+V[N-left:]\n\n        # queue\u306b\u623b\u3059\u64cd\u4f5c\n        pick_list = sorted(pick_list)\n        tmp_ans = sum(pick_list)  # \u623b\u3059\u524d\u306e\u5408\u8a08\u5024\n        rem = min(K-pick, len(pick_list))  # \u623b\u3059\u64cd\u4f5c\u3092\u3067\u304d\u308b\u56de\u6570\n        for i in range(rem):  # \u8ca0\u306e\u5024\u306e\u3082\u306e\u3092\u3067\u304d\u308b\u3060\u3051\u623b\u3059\n            if pick_list[i] < 0:\n                tmp_ans -= pick_list[i]\n            else:\n                break\n        ans = max(tmp_ans, ans)\nprint(ans)", "n,k = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nans = -10**9\nfor back in range(n+1):\n    for left in range(min(k-back+1, n+1)):\n        for right in range(min(k-back-left+1, n-left+1)):\n            hand = []\n            hand.extend(v[:left])\n            if right>0:\n                hand.extend(v[-right:])\n            hand.sort()\n            ans = max(ans, sum(hand[back:]))\n\nprint(ans)", "N, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\nans = 0\n\n#\u5de6\u304b\u3089l\u500b\u3001\u53f3\u304b\u3089r\u500b\u53d6\u308a\u51fa\u3059\nfor l in range(K + 1):\n    for r in range(K - l + 1):\n        if l + r > N: continue\n        d = K - l - r\n        now = 0\n        having = []\n        for i in range(l):\n            now += V[i]\n            having.append(V[i])\n        for i in range(N-r, N):\n            now += V[i]\n            having.append(V[i])\n\n        having.sort()\n        #d\u56de\u307e\u3067\u6301\u3063\u3066\u3044\u308b\u5b9d\u77f3(\u4fa1\u5024\u304c\u30de\u30a4\u30ca\u30b9)\u3092\u623b\u3059\n        for i in range(d):\n            if i >= len(having): break\n            if having[i] >= 0: break\n            now -= having[i]\n        ans = max(ans, now)\n\nprint(ans)\n", "import heapq\nN, K = list(map(int, input().split()))\nd = [int(x) for x in map(int, input().split())]\ne = d[::-1]\n\nres = 0\nnum = min(N, K)\nfor i in range(num + 1):\n    for j in range(num - i, -1, -1):\n        s = d[:i] + e[:j]\n        if not s:\n            continue\n        heapq.heapify(s)\n        res = max(res, sum(s))\n        l = min(i + j, K - (i + j))\n        while l:\n            heapq.heappop(s)\n            res = max(res, sum(s))\n            l -= 1\nprint(res)\n", "from heapq import *\nn, k = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nres = 0\nnum = min(k, n)\nfor a in range(num + 1):\n    for b in range(num + 1 - a):\n        trash = k - (a + b)\n        s = d[:a] + d[-b:] if b != 0 else d[:a]\n        heapify(s)\n        for _ in range(min(trash, a + b)):\n            tmp = heappop(s)\n            if tmp > 0:\n                heappush(s, tmp)\n                break\n        res = max(res, sum(s))\nprint(res)\n", "n,k = map(int, input().split())\nv = list(map(int, input().split()))\n\nans = 0\nfor x in range(k+1):# LeftHand\n  for y in range(k-x+1):# RightHand\n    temp = v[:x]+v[len(v)-y:]\n    if x+y >= n:\n      temp = v\n    temp1 = []\n    temp2 = []\n    for i in temp:\n      if i >= 0:\n        temp1.append(i)\n      else:\n        temp2.append(i)\n\n    temp2.sort()\n    ans = max(ans, sum(temp1) + sum(temp2[k-x-y:]))\nprint(ans)", "# equeue\n\nfrom collections import deque\nimport heapq\n\n\ndef main():\n    N, K = map(int, input().split())\n    V = list(map(int, input().split()))\n    res = 0\n    for pull in range(K+1):\n        push = K - pull\n        if push < 0 or push > N:\n            continue\n        for left_push in range(push+1):\n            tmp_que = deque(V)\n            tmp_heap = []\n            heapq.heapify(tmp_heap)\n            right_push = push - left_push\n            for _ in range(left_push):\n                heapq.heappush(tmp_heap, tmp_que.popleft())\n            for _ in range(right_push):\n                heapq.heappush(tmp_heap, tmp_que.pop())\n\n            tmp_res = sum(tmp_que)\n            for i in range(min(push, pull)):\n                x = heapq.heappop(tmp_heap)\n                if x >= 0:\n                    heapq.heappush(tmp_heap,x)\n                    break\n\n\n            res = max(res, sum(tmp_heap))\n    print(res)\n    return\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN, K = MAP()\nV = LIST()\n\nans = 0\ntmp_sum = 0\n\nfor i in range(1, min(K, N)+1):\n\tleft = K-i\n\tfor j in range(i+1):\n\t\ttmp = V[:j] + V[N-(i-j):]\n\t\ttmp.sort()\n\t\tidx = bisect_left(tmp, 0)\n\t\tans = max(ans, sum(tmp) - sum(tmp[:min(idx, left)]))\n\nprint(ans)\n", "n, k = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = - 10 ** 19\n# i: D\u304b\u3089\u53d6\u308a\u51fa\u3059\u5b9d\u77f3\u306e\u500b\u6570\nfor i in range(min(k + 1, n + 1)):\n  # j: \u5de6\u304b\u3089\u3068\u308b\u500b\u6570(i-j\u304c\u53f3\u304b\u3089\u3068\u308b\u500b\u6570)\n  for j in range(i + 1):\n    inhands = V[:j] + V[n - i + j:]\n    inhands.sort()\n    remnum = k - i\n    val = 0\n    for h in inhands:\n      if h < 0 and remnum > 0:\n        remnum -= 1\n      else:\n        val += h\n    ans = max(ans, val)\nprint(ans)", "N,K=list(map(int,input().split()))\nV=list(map(int,input().split()))\nr=min(N,K)\nans=0\nfor a in range(r+1):\n    for b in range(r-a+1):\n        tmp,minus=0,[]\n        for i in range(a):\n            t=V[i]\n            tmp+=t\n            if t<0:\n                minus.append(t)\n        for j in range(b):\n            t=V[N-1-j]\n            tmp+=t\n            if t<0:\n                minus.append(t)\n        tmp-=sum(sorted(minus)[:K-(a+b)])\n        ans=max(ans,tmp)\nprint(ans)\n", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\nans = 0\nfor i in range(k+1):\n  for j in range(k+1):\n    if i+j > k or i+j > n:\n      continue\n    t = k-(i+j)\n    s = v[:i] + v[(n-j):]\n    s.sort()\n    u = 0\n    while u < t:\n      u += 1\n      if len(s) < 1:\n        break\n      if s[0] < 0:\n        s.pop(0)\n      else:\n        break\n    ans = max(ans, sum(s))\nprint (ans)", "n, k = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nans = 0\nfor left in range(min(n, k+1)):\n    for right in range(min(n-left+1, k-left+1)):\n        l = v[:left]\n        l+=v[::-1][:right]\n        l.sort()\n        temp = sum(l)\n        for t in range(max(0, min(len(l), k-left-right))):\n            if l[t]<0:\n                temp-=l[t]\n        ans = max(ans, temp)\nprint(ans)\n", "N,K = map(int,input().split())\nV = list(map(int,input().split()))\n\nans = -1\n\nfor l in range(N+1):\n    for r in range(N+1):\n        tmp = V[:l] + V[N-r:]\n        if l+r > N:\n            break\n        res = K - (l+r)\n        if res < 0:\n            break\n        tmp.sort()\n        for i in range(min(res,len(tmp))):\n            if tmp[0] < 0:\n                tmp.pop(0)\n            else:\n                break\n        ans = max(ans,sum(tmp))\n            \nprint(ans)", "import math\nfrom collections import deque\nn,k=map(int,input().split())\nv=list(map(int,input().split()))\n#k\u56de\u307e\u3067\u3060\u3063\u305f\u30fc\u8aa4\u8aad\nans=0\nfor i in range(1,min(k,n)+1):\n    #\u53d6\u308b\u3068\u3053\u308d(\u5927\u304d\u3044\u65b9\u3068\u306f\u9650\u3089\u306a\u3044\u306e\u304b)\n    for m in range(i+1):\n        s=v[:m]+v[n-(i-m):]\n        s.sort()\n        #\u53d6\u3063\u305f\u500b\u6570\u3088\u308a\u591a\u304f\u8a70\u3081\u3088\u3046\u3068\u3057\u306a\u3044\u3088\u3046\u306b\uff01\n        #\u6b8b\u308ak-i\u56de\u3042\u308b\n        for j in range(i,min(k,2*i)):#\u305d\u308c\u4ee5\u4e0a\u8a70\u3081\u3089\u308c\u306a\u3044\u5834\u5408\n            #0\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\u306f\u66f8\u304d\u63db\u3048\u308b\n            if s[j-i]<0:s[j-i]=0\n        #\u53d6\u308a\u51fa\u3057\u305f\u3084\u3064\u306e\u6700\u5927(\u623b\u3059\u5834\u5408\u306f0)\n        ans=max(ans,sum(s))\n        #\u6b8b\u308ak-j\u56de\u3042\u308b(break\u306e\u6642\u306ej\u306f\u3084\u3063\u3066\u306a\u3044\u306e\u3067)\n        #\u3053\u3053\u304b\u3089\u306f\u3044\u3044\u611f\u3058\u306b\u51fa\u3059\u306e\u3068\u5165\u308c\u308b\u306e\u3092\u7e70\u308a\u8fd4\u3059(\u5076\u6570\u306e\u5834\u5408\u306f\u3053\u306e\u307e\u307e\u304b)\n        #\u5fc5\u8981\u3059\u3089\u306a\u3044\u3001k\u56de\u3092\u4f7f\u3044\u5207\u3089\u306a\u304f\u3066\u3044\u3044\u306e\u3067\n        #print(sum(s))\nprint(ans)", "# \u521d\u671f\u5165\u529b\nimport bisect\nimport sys\ninput = sys.stdin.readline\nN,K = (int(i) for i in input().split())\nV = list(map(int, input().split()))\nV_sorted =sorted(V)\n\n#\u53d6\u308b\u500b\u6570take_num\u3001\u8fd4\u3059\u500b\u6570reverse(t +r <=K)\u500b\u5168\u3066\u6c7a\u3081\u308b\n\nans =[]\ntake_V =[] #\u6700\u5f8c\u306b\u6301\u3063\u3066\u3044\u308b\u5b9d\u77f3\u306e\u4fa1\u5024\n#V\u304c\u5168\u3066\u30de\u30a4\u30ca\u30b9\u306a\u3089\u53d6\u3089\u306a\u3044\nif V_sorted[-1] <=0:\n    ans =0\nelse:\n    take_num =min(K,N)\n    for tak in range(1,take_num +1):\n        reverse =min(K -tak,tak) #\u8fd4\u3059\u6570\u306ftake_num\u3067\u306f\u306a\u304f\u3001K\u304b\u3089\u5f15\u304f\n        for lef in range(tak+1):\n            for rev in range(reverse +1):\n            \n                take =[]                    #\u53d6\u3063\u305f\u5b9d\u77f3\n                rig =N-(tak -lef )          #lef:\u5de6\u5074\u306e\u53d6\u308b\u6570 rig:\u53f3\u5074\u306e\u53d6\u308b\u6570\n                take.extend(V[    :lef])\n                take.extend(V[rig:   ])\n                take.sort()\n                take_V.append(sum(take[rev:]))\n        \n    ans =max(take_V)\nprint(ans)", "N,K = list(map(int,input().split()))\nV = list(map(int,input().split()))\nVrev = V[::-1]\nans = 0\nfor a in range(N+1):\n    for b in range(min(K-a,N-a)+1):\n        VV = V[:a] + Vrev[:b]\n        VV.sort(reverse=True)\n        for k in range(min(K-a-b,len(VV))):\n            if VV[-1] < 0:\n                VV.pop()\n        ans = max(sum(VV),ans)\nprint(ans)\n", "n,k=[int(x) for x in input().rstrip().split()]\nv=[int(x) for x in input().rstrip().split()]\nvr=v[::-1]\nans=0\nmi=min(n,k)\n\nfor i in range(mi+1):\n  for j in range(mi-i+1):\n    minus=0\n    now=v[:i]+vr[:j]\n    d=k-(len(now))\n    now.sort()\n    md=min(d,len(now))\n    for s in range(md):\n      if 0<=now[s]:\n        break\n      minus+=now[s]\n\n    ans=max(ans,sum(now)-minus)\nprint(ans)", "import bisect\nN, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\nans = 0\n\nfor i in range(1, K + 1):#i\u500b\u4ee5\u4e0b\u53d6\u308a\u51fa\u3057\u3001K - i\u500b\u4ee5\u4e0b\u623b\u3059\uff03\uff11\uff10\uff10\n  nownow = 0\n  for p in range(i + 1):#[0:i] \u304b\u3089 [N - i:N]\u307e\u3067\u53d6\u308a\u51fa\u3055\u306a\u3044\u3068\u3053\u308d\u3092\u9078\u3079\u308b#100\n    #[p:p + N - i]\u3092\u53d6\u308a\u51fa\u3055\u306a\u3044\n    if i < N:\n      now = sorted(V[:p] + V[p + N - i:])\n    else:\n      now = V\n    #print(now, i, p)\n    index = bisect.bisect_right(now, 0)\n    #index\u500b\u306e\u8ca0\u306e\u6570\u304c\u3042\u308b\u3002\n    if K - i >= index:\n      nownow = sum(now[index:])\n    else:\n      nownow = sum(now[K - i:])\n    ans = max(ans, nownow)\n    #print(now, nownow, ans)\n\nprint(ans)      \n", "n, k = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# \u5de6\u304b\u3089\u4f55\u500b\u3001\u53f3\u304b\u3089\u4f55\u500b\u3092\u5168\u63a2\u7d22\nans = 0\nfor l in range(0, k + 1):\n    for r in range(0, k + 1 - l):\n        if l + r > n:\n            continue\n        suteru = k - l - r\n        get = []\n        for i in range(l):\n            get.append(v[i])\n        for i in range(n - 1, n - 1 - r, -1):\n            get.append(v[i])\n        get.sort()\n        minus = 0\n        while minus < min(suteru, len(get)) and get[minus] < 0:\n            minus += 1\n        ans = max(ans, sum(get[minus:]))\nprint(ans)\n", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\nvv = [0] * (n + 1)\nfor i in range(n):\n    vv[i + 1] = vv[i] + v[i]\nsumv = vv[n]\nans = 0\nfor l in range(n):\n    for r in range(l - 1, n):\n        c = r - l + 1\n        if n - c > k:\n            continue\n        x = []\n        value = sumv - (vv[r + 1] - vv[l])\n        for i in range(n):\n            if not l <= i <= r:\n                x.append(v[i])\n        x.sort()\n        for i in range(max(0, min(k - (n - c), len(x)))):\n            if x[i] < 0:\n                value -= x[i]\n            else:\n                break\n        ans = max(value, ans)\nprint(ans)", "n, k = list(map(int, input().split()))\nv = [int(i) for i in input().split()]\nans = 0\nfor a in range(min(n, k) + 1):\n    pa, va = v[:a], v[a:]\n    for b in range(min(n, k) - a + 1):\n        pb = pa + va[-b:] if b > 0 else pa\n        pb.sort()\n        s = sum(pb)\n        ans = max(s, ans)\n        for c in range(min(k - a - b, a + b)):\n            s -= pb[c]\n            ans = max(s, ans)\nprint(ans)\n", "N, K = map(int, input().split())\nV = list(map(int, input().split()))\nW = V[::-1]\nR = min(N, K)\nans = -float('inf')\nfor left in range(R+1):\n    for right in range(R+1):\n        if left+right > R: continue\n        A = V[:left]+W[:right]\n        tmp = sum(A)\n        \n        rest = K - left - right\n        A = [k for k in A if k < 0]\n        A.sort()\n        if rest >= 0:\n            tmp -= sum(A[:min(rest, len(A))])\n        ans = max(tmp, ans)\n\nprint(ans)", "# \u521d\u671f\u5165\u529b\nimport bisect\nimport heapq\nimport sys\ninput = sys.stdin.readline\nN,K = (int(i) for i in input().split())\nV = list(map(int, input().split()))\nV_sorted =sorted(V)\n\n#\u53d6\u308b\u500b\u6570take_num\u3001\u8fd4\u3059\u500b\u6570reverse(t +r <=K)\u500b\u5168\u3066\u6c7a\u3081\u308b\n\nans =[]\ntake_V =[] #\u6700\u5f8c\u306b\u6301\u3063\u3066\u3044\u308b\u5b9d\u77f3\u306e\u4fa1\u5024\n#V\u304c\u5168\u3066\u30de\u30a4\u30ca\u30b9\u306a\u3089\u53d6\u3089\u306a\u3044\nif V_sorted[-1] <=0:\n    ans =0\nelse:\n    take_num =min(K,N)\n    for tak in range(1,take_num +1):\n        for lef in range(tak+1):\n            #for rev in range(reverse +1):\n            \n                take =[]  #\u53d6\u3063\u305f\u5b9d\u77f3\n                rig =N-(tak -lef )          #lef:\u5de6\u5074\u306e\u53d6\u308b\u6570 rig:\u53f3\u5074\u306e\u53d6\u308b\u6570\n                take.extend(V[    :lef])\n                take.extend(V[rig:   ])\n                take.sort()\n                reverse =min(K -tak,tak) #\u8fd4\u3059\u6570\u306ftake_num\u3067\u306f\u306a\u304f\u3001K\u304b\u3089\u5f15\u304f\n                ind_0 =bisect.bisect_left(take,0)\n                rev =min(ind_0,reverse,K -tak)\n                take_V.append(sum(take[rev:])) #\u8fd4\u3059\u5206\u3092\u9664\u304f\n        \n    ans =max(take_V)\nprint(ans)", "from heapq import heappop, heapify\n\n\nN, K, *V = list(map(int, open(0).read().split()))\n\n# i: \u64cd\u4f5c\u56de\u6570\n# j: \u53d6\u308a\u51fa\u3059\u500b\u6570\n# k: \u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\u7bc4\u56f2 [0, k)\nans = 0\nfor i in range(K + 1):\n    for j in range(min(N + 1, i + 1)):\n        for k in range(j + 1):\n            right = N - j + k\n            tmp = V[:k] + V[right:]\n\n            put_out_cnt = i - j\n            heapify(tmp)\n            while tmp and put_out_cnt > 0:\n                heappop(tmp)\n                put_out_cnt -= 1\n            ans = max(ans, sum(tmp))\nprint(ans)\n", "from heapq import *\nn, k = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nres = 0\nnum = min(k, n)\nfor i in range(num + 1):\n    for j in range(num + 1 - i):\n        l = min(k - (i + j), i + j)\n        s = d[:i] + d[-j:] if j != 0 else d[:i]\n        heapify(s)\n        for _ in range(l):\n            tmp = heappop(s)\n            if tmp > 0:\n                heappush(s, tmp)\n        res = max(res, sum(s))\nprint(res)\n", "n,k=map(int,input().split())\nv=list(map(int, input().split()))\nm=min(n,k)\nans=0\nfor i in range(m+1): #A\n  for j in range(m+1-i): #B\n    l=[]\n    l=l+v[0:i]+v[n-j:n]\n    l.sort()\n    for kk in range(min(k-i-j, i+j)):\n      if l[kk]<0:\n        l[kk]=0\n    ans=max(ans, sum(l))\nprint(ans)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# \u554f\u984c\uff1ahttps://atcoder.jp/contests/abc128/tasks/abc128_d\n\nn, k = list(map(int, input().strip().split()))\nvalue = list(map(int, input().strip().split()))\nres = 0\nfor l in range(k+1):\n    for r in range(k-l+1):\n        if l + r > n:\n            continue\n        d = k - l - r\n        now = 0\n        s = []\n        for i in range(l):\n            now += value[i]\n            s.append(value[i])\n        for i in range(r):\n            now += value[n-i-1]\n            s.append(value[n-i-1])\n        s.sort()\n        for i in range(d):\n            if i >= len(s):\n                break\n            if s[i] > 0:\n                break\n            now -= s[i]\n        res = max(res, now)\n\nprint(res)\n\n", "import bisect\n\nN, K = [int(x) for x in input().split()]\nV = [int(x) for x in input().split()]\nM = min(N, K)\n\nans = 0\njuwel = []\nfor l in range(M + 1):\n    for r in range(M - l + 1):\n        juwel = sorted(V[:l] + V[N - r:])\n        s = bisect.bisect_left(juwel, 0)\n        s = min(s, K - l - r)\n        juwel = juwel[s:]\n        ans = max(ans, sum(juwel))\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nN,K = (int(x) for x in input().rstrip('\\n').split())\nvs = [int(x) for x in input().rstrip('\\n').split()]\ng = [vs[0],vs[-1]]\nrest = K\nfor k in [K-1,K]:\n  for b in range(K//2):\n    t = k-b\n    if t>N:\n      t=N\n    for i in range(t+1):\n      v = []\n      if i <t:\n        v.extend(vs[:i])\n        v.extend(vs[-(t-i):])\n        for _ in range(b):\n          if min(v)<0:\n            v.remove(min(v))\n          else:\n            break\n      else:\n        v.extend(vs[:t])\n        for _ in range(b):\n          if min(v)<0:\n          \tv.remove(min(v))\n      g.append(sum(v))\nif max(g)<0:\n  print(0)\nelse:\n  print(max(g))", "n,k=map(int,input().split())\nv=[int(x) for x in input().split()]\n\nr=min(n,k)\nans=-10**9\nfor i in range(r+1):\n  for j in range(r+1):\n    if i+j > r: continue;\n    l=sorted(v[:i]+v[::-1][:j])\n    for a in range(k-(i+j)+1):\n      ans=max(ans, sum(l[a:]))\n    \nprint(ans)", "N,K=map(int,input().split())\nV=list(map(int,input().split()))\nimport heapq\nturn=min(N,K)\nm=0\nfor A in range(turn+1):\n  for B in range(turn+1-A):\n    h=[]\n    heapq.heapify(h)\n    if A>0:\n      h=V[:A]+h\n    if B>0:\n      h=h+V[len(V)-B:]\n    heapq.heapify(h)  \n\n    ans=sum(h)\n    for i in range(K-A-B):\n      if h!=[]:\n        f=heapq.heappop(h)\n \n        if f<0:\n          ans-=f\n    m=max(ans,m)\n\n\n    \nprint(m)   ", "N, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = V[0]\nfor l in range(min(K, N)+1):\n    for r in range(min(K, N)-l+1):\n        v = V[:l] + V[N-r:]\n        rest = K - (l + r)\n        v.sort()\n        tmp = 0\n        for x in v:\n            if rest and x < 0:\n                rest -= 1\n            else:\n                tmp += x\n        if ans < tmp:\n            ans = tmp\nprint(ans)", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\nans = 0\nfor i in range(min(n, k) + 1):\n    for j in range(min(n, k) - i + 1):\n        lis = sorted(v[:i] + v[n - j:])\n        for l in range(k - i - j + 1):\n            ans = max(ans, sum(lis[l:]))\nprint(ans)", "N, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = 0\n\nfor lg in range(K+1):\n    for rg in range(K-lg+1):\n        if lg+rg > N:\n            break\n        for ls in range(K-lg-rg+1):\n            if ls > lg:\n                break\n            for rs in range(K-lg-rg-ls+1):\n                if rs > rg:\n                    break\n\n                lv = V[:lg]\n                rv = V[N-rg:]\n\n                \"\"\"\n                print(lg, ls, rg, rs)\n                print(lv, rv)\n                print(lv[:lg-ls], rv[:rg-rs])\n                print()\n                \"\"\"\n                lv.sort()\n                lv.reverse()\n                rv.sort()\n                rv.reverse()\n\n                ans = max(sum(lv[:lg-ls])+sum(rv[:rg-rs]), ans)\n\nprint(ans)", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\n\nans = 0\nfor left in range(n + 1):\n    for right in range(n + 1):\n        if left == 0 and right == 0:\n            continue\n        rest = k - left - right\n        if left + right > n or rest < 0:\n            break\n        arr = v[:left] + v[n - right:]\n        minus = 0\n        neg = [x for x in arr if x < 0]\n        if len(neg) > 0:\n            neg.sort()\n            minus = sum(neg[:rest])\n        ans = max(ans, sum(arr) - minus)\n\nprint(ans)", "from heapq import heappush, heappop\nfrom random import randint\nfrom time import time\n\nclass PriorityQueue(object):\n    def __init__(self):\n        self.queue = []\n    def push(self, value):\n        heappush(self.queue, value)\n    def pop(self):\n        return heappop(self.queue)\n    def __len__(self):\n        return len(self.queue)\n    def __contains__(self, item):\n        return item in self.queue\n\nn,m = map(int,input().split())\nv = list(map(int,input().split()))\n\nans = 0\n\n#\u53d6\u5f97\u3059\u308b\u64cd\u4f5c\u3092\u4f55\u56de\u884c\u3046\u304b\uff1f\nfor i in range(0,m+1):\n\n\t#\u64cd\u4f5c\u6b8b\u308a\u56de\u6570\n\tlef = m-i\n\n\thp = PriorityQueue()\n\t#\u5de6\u5074\u304b\u3089\u3069\u308c\u3060\u3051\u53d6\u308b\u304b\uff1f\n\tfor j in range(0,i+1):\n\t\tif j>n :\n\t\t\tbreak\n\n\t\t#\u5de6\u5074\u304b\u3089j\u500b\u53d6\u308b\n\t\tfor k in range(0,j):\n\t\t\thp.push(v[k])\n\n\t\t#\u53f3\u5074\u304b\u3089 i-j\u500b\u53d6\u308b\n\t\tfor k in range(0,i-j):\n\t\t\tif n-1-k < j:\n\t\t\t\tbreak\n\t\t\thp.push(v[n-1-k])\n\n\t\t#minus\u306f\u623b\u3059\n\t\tfor k in range(0,lef):\n\t\t\tif len(hp) == 0:\n\t\t\t\tbreak\n\t\t\ttop = hp.pop()\n\t\t\tif top>=0 :\n\t\t\t\thp.push(top)\n\t\t\t\tbreak\n\n\t\tss = 0\n\t\twhile len(hp)>0:\n\t\t\tss += hp.pop()\n\n\t\tans = max(ans,ss)\n\nprint(ans)", "N, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nR = min(N,K)\npoint = 0\nmax_point = 0\nhand = []\n\nfor i in range(R+1):\n    for a in range(i+1):\n        if i==a:\n            hand = V[:a]\n        else:\n            hand = V[:a]+V[-(i-a):]\n        negahand = [k for k in hand if k < 0]\n        negahand.sort()\n        if K-i > len(negahand):\n            trash = -sum(negahand)\n        else:\n            trash = -sum(negahand[:K-i])\n        point = sum(hand) + trash\n        max_point = max(max_point,point)\n\nprint(max_point)", "n , k = list(map(int, input().split()))\nv = list(map(int,input().split()))\nma = float('INF')*(-1)\nm = min(n,k)\nfor i in range(m+1):\n    for j in range(m+1-i):\n        vl=v[:i]\n        vr=v[n-j:]\n        ans = sum(vl)+sum(vr)\n        vb=vl+vr\n        vb.sort()\n        m2 = min(k-i-j, len(vb))\n        for l in range(m2):\n            if vb[l]<0:\n                ans-=vb[l]\n            else:\n                break\n        ma = max(ans,ma)\nif ma<0:\n    ma = 0\nprint(ma)\n", "jewel, query = map(int, input().split())\nt = min(jewel, query)\ndq = [int(i) for i in input().split()]\nans = []\n\nfor i in range(t+1):\n  for j in range(i+1):\n    have = dq[:j] + dq[(jewel-i+j):]\n    drop = query - len(have)\n\n    for k in range(drop):\n      if not have:\n        break\n      \n      cand = min(have)\n      if cand < 0:\n        have.remove(cand)\n      else:\n        break\n        \n    ans.append(sum(have))\n    \nprint(max(ans))", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\nfrom collections import deque\nimport heapq\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, K, Vi):\n    ans = 0\n    for ab in range(min(N, K) + 1):\n        for a in range(ab + 1):\n            b = ab - a\n            have = Vi[:a] + Vi[N - b:]\n            have.sort()\n            s = sum(have)\n            for i in range(K - ab):\n                if len(have) <= i:\n                    break\n                elif have[i] < 0:\n                    s += abs(have[i])\n                else:\n                    break\n            ans = max(ans, s)\n    print(ans)\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    Vi = [int(i) for i in input().split()]\n    solve(N, K, Vi)\n\n    # # test\n    # import random\n    # from func import random_str\n    # N, K = 100, 50\n    # Vi = [random.randint(-(10 ** 7), 10 ** 7) for _ in range(N)]\n    # solve(N, K, Vi)\n\n__starting_point()", "N, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nans = 0\n\nfor gets in range(min(N, K)+1):\n    for lgets in range(gets+1):\n        rgets = gets - lgets\n        haves = V[:lgets]+V[(N-rgets):]\n        haves.sort()\n        removes = K - gets\n        for i in range(min(removes, len(haves))):\n            if haves[i] < 0:\n                haves[i] = 0\n            else:\n                break\n        ans = max(ans, sum(haves))\nprint(ans)\n\n", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\n\nans = 0\nfor l in range(0, k + 1):\n    for r in range(0, k + 1 - l):\n        if l == r == 0 or l + r > n:\n            continue\n        a = sorted(v[:l] + v[n - r:])\n        m = min(k - l - r, len(a) - 1)\n        ans = max(ans, sum(a[m:] if a[m] <\n                           0 else filter(lambda x: x > 0, a)))\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n\n    ans = -float(\"inf\")\n    for t in range(min(N, K) + 1):\n        s = K - t\n        for l in range(t + 1):\n            r = t - l\n            gem = V[:l]\n            gem += V[-r:] if r != 0 else []\n            gem.sort()\n            value = sum(gem)\n            for i in range(min(s, t)):\n                if gem[i] < 0:\n                    value -= gem[i]\n                else:\n                    break\n            ans = max(ans, value)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10000000)\n\nn,k = map(int,input().split())\nv = list(map(int,input().split()))\nans=0\nfor l in range(k+1):\n    for r in range(k-l+1):\n        if l+r > n :break\n\n        d=k-l-r\n        now=0\n        s=[]\n\n        for i in range(l):\n            now+=v[i]\n            s.append(v[i])\n\n        for i in range(n-r,n):\n            now+=v[i]\n            s.append(v[i])\n\n        s.sort()\n        for i in range(d):\n            if(i >= len(s)):break\n            if s[i] > 0 :break\n\n            now -= s[i]\n\n        ans=max(now,ans)\nprint(ans)", "import heapq\nfrom collections import deque\nn , k = map(int,input().split())\nv = list(map(int,input().split()))\nans = 0\nfor i in range(n+1):\n    for j in range(n+1):\n        if i+j > n or i+j > k:\n            continue\n        p = v[:]\n        d = deque(p)\n        a = []\n        heapq.heapify(a)\n        for t in range(i):\n            heapq.heappush(a,d.popleft())\n        for l in range(j):\n            heapq.heappush(a,d.pop())\n        nokori = k-i-j\n        for s in range(nokori):\n            if a:\n                now = heapq.heappop(a)\n                if now > 0:\n                    heapq.heappush(a,now)\n                    break\n            else:\n                break\n        ans = max(ans,sum(a))\nprint(ans)", "N,K=map(int,input().split())\nV=list(map(int,input().split()))\nr,ans=min(N,K),0\nfor a in range(r+1):\n  for b in range(r-a+1):\n    tmp,minus=0,[]\n    for i in range(a):\n      tmp+=V[i]\n      if V[i]<0:\n        minus.append(V[i])\n    for j in range(b):\n      tmp+=V[N-j-1]\n      if V[N-j-1]<0:\n        minus.append(V[N-j-1])\n    tmp-=sum(sorted(minus)[:K-(a+b)])\n    ans=max(ans,tmp)\nprint(ans)", "from collections import deque\n\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\n\nw = deque(v)\nans = 0\nfor i in range(k+1):\n    if i > n:\n        break\n    s = v[:i]\n    for j in range(k+1-i):\n        if j > n-i:\n            break\n        t = sorted(v[n-j:] + s, reverse=True)\n        u = sum(t)\n        for l in range(k+1-i-j):\n            ans = max(ans, u)\n            if not t:\n                break\n            u -= t.pop()\nprint(ans)", "N, K = map(int,input().split())\nV = list(map(int,input().split()))\n\nans = 0\n\nfor a in range(min(N,K)+1):\n    for b in range(min(N,K)-a+1):\n        cur = V[:a] + V[N-b:]\n        cur.sort()\n\n        idx = 0\n        while idx < min(K-a-b, len(cur)):\n            if cur[idx] > 0: break\n            else: idx += 1\n        \n        ans = max(ans, sum(cur[idx:]))\n    \nprint(ans)", "n, k, *a = list(map(int, open(0).read().split()))\n\nans = 0\nfor l in range(0, k + 1):\n    for r in range(0, k + 1 - l):\n        if l == r == 0 or l + r > n:\n            continue\n        b = sorted(a[:l] + a[n - r:])\n        c = min(k - l - r, len(b) - 1)\n        ans = max(ans, sum(b[c:] if b[c] < 0 else [x for x in b if x > 0]))\nprint(ans)\n", "N,K = map(int,input().split())\nV = list(map(int,input().split()))\nM = min(N,K)\nans = 0\n\nfor i in range(M+1):\n  for j in range(M-i+1):\n    G = V[:i]+V[N-j:]\n    G.sort()\n    for j in range(K-i-j+1):\n      ans = max(ans,sum(G[j:]))\n\nprint(ans)", "N, K = map(int, input().split())\nV = list(map(int, input().split()))\nresult = 0\nfor a in range(N + 1):\n    for b in range(N + 1):\n        if a + b > K or a + b > N:\n            break\n        out = V[:a] + V[N-b:]\n        out.sort()\n        sum_val = sum(out)\n        for i in range(min(a + b, K - a - b)):\n            if out[i] >= 0:\n                break\n            sum_val -= out[i]\n        result = max(result, sum_val);\nprint(result)", "import heapq\nfrom collections import deque\nfrom functools import lru_cache\n\nN,K = list(map(int,input().split()))\nV = list(map(int,input().split()))\nans = 0\n\nfor l in range(0,K + 1):\n  for r in range(0,K - l + 1):\n    d = K - r - l\n    tmp = 0\n    have = []\n    if l + r > N:\n      continue\n    for i in range(0,l):\n      tmp += V[i]\n      have.append(V[i])\n    for j in range(N - r,N):\n      tmp += V[j]\n      have.append(V[j])\n    h = len(have)\n    #print(have)\n    have = sorted(have)\n    for k in range(0,d):\n      #print(have,sum(have))\n      if k >= h:\n        break\n      if have[k] > 0:\n        break\n      tmp -= have[k]\n    ans = max(tmp,ans)\n    \nprint(ans)\n", "n, k = map(int,input().split())\ntarg = min(n, k)\nv = list(map(int,input().split()))\n\"\"\"\ni\u2026\u5de6\u3092\u53d6\u308b\u56de\u6570\nj\u2026\u53f3\u3092\u53d6\u308b\u56de\u6570\n\u6b8b\u308a\u56de\u6570 k-(i+j)\n\"\"\"\nans = -10**18\nfor i in range(targ+1):\n\tfor j in range(targ-i+1):\n\t\t#print(i, j)\n\t\tnl = v[:i] + v[n-j:]\n\t\tnl.sort()\n\t\t#print(nl)\n\t\ttmp = sum(nl)\n\t\tfor t in range(min(k-(i+j), i+j)):\n\t\t\ttmp = max(tmp, tmp-nl[t])\n\t\t\t#print(\"\u884c\u3044\u307e\u3057\u305f\u3088!\")\n\t\t#print(tmp)\n\t\tans = max(tmp, ans)\nprint(ans)", "def solve():\n  ans = 0\n  N, K = list(map(int, input().split()))\n  V = list(map(int, input().split()))\n  A = V[:]*2\n  for k in range(K,-1,-1): #k\u306f\u64cd\u4f5c\u56de\u6570\n    if k>=N:\n      suteru = k-N\n      a = V[:]\n      a.sort()\n      ans = max(ans,sum(a[suteru:]))\n    else:\n      for i in range(k//2+1,k+1): #i\u306f\u53d6\u308b\u56de\u6570\n        suteru = k-i\n        for j in range(i+1):\n          a = A[N-j:N+i-j]\n          a.sort()\n          ans = max(ans,sum(a[suteru:]))\n  return ans\nprint((solve()))\n", "def main():\n    n, k = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    reversed_v = [0] + v[::-1]\n    v = [0] + v\n    ans = -float(\"inf\")\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i + j > min(n, k):\n                continue\n            now_k = k - i - j\n            if now_k < 0:\n                continue\n            q = []\n            for l in range(1, i + 1):\n                q.append(v[l])\n            for l in range(1, j + 1):\n                q.append(reversed_v[l])\n            q.sort()\n            for l in range(len(q)):\n                if q[l] < 0 and now_k > 0:\n                    q[l] = 0\n                    now_k -= 1\n            ans = max(ans, sum(q))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K=map(int,input().split())\nV=list(map(int,input().split()))\n\nans=0\nfor l in range(N+1):\n  for r in range(N+1):\n    if l+r>N or l+r>K:break\n    arr=V[:l]\n    if r:arr+=V[-r:]\n    arr.sort()\n    rem=K-l-r\n    tmp=0\n    for a in arr:\n      if a<0 and rem:\n        rem-=1\n      else:\n        tmp+=a\n    ans=max(ans,tmp)\nprint(ans)", "N,K = map(int,input().split())\nV = list(map(int,input().split()))\n\nans = 0\nfor l in range(N+1):\n    for r in range(N+1):\n        if l+r > N or l+r > K: break\n        arr = V[:l]\n        if r: arr += V[-r:]\n        arr.sort()\n        rem = K - l - r\n        tmp = 0\n        for a in arr:\n            if a < 0 and rem:\n                rem -= 1\n            else:\n                tmp += a\n        ans = max(ans, tmp)\nprint(ans)", "import sys\nfrom bisect import bisect_left\n\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef main():\n    N, K, *V = list(map(int, read().split()))\n\n    ans = 0\n    for k in range(min(N, K) + 1):\n        for left in range(k + 1):\n            right = k - left\n            tmp = V[:left] + (V[-right:] if right else [])\n            tmp.sort()\n\n            idx = bisect_left(tmp, 0)\n            if idx > K - k:\n                idx = K - k\n\n            this_ans = sum(tmp[idx:])\n            if ans < this_ans:\n                ans = this_ans\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = map(int,input().split())\nv = list(map(int,input().split()))\n\nans = 0\n\nfor l in range(n):\n    for r in range(n+1)[::-1]:\n        if l <= r and 0 <= (l+n-r) <= k: # l+n-r\u500b\u62fe\u3046\n            q = v[:l] + v[r:n]\n            q.sort(reverse = True)\n            \n            for i in range(k-(l+n-r)):\n                if q == []:\n                    break\n                if q[-1] < 0:\n                    q.pop()\n                else:\n                    break\n\n            ans = max(ans, sum(q))\n        else:\n            continue\n\nprint(ans)", "#import math\n#import itertools\n#import numpy as np\nfrom collections import deque\n\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\ndef do():\n    n,k=INTM()\n    d=LIST()\n    #q=deque(d)\n    nkmin=min(n,k)\n    stop=10**9\n    ans=0\n    for i1 in range(1,1+nkmin):\n        for i2 in range(i1+1):\n            temp=d[0:i2]+d[n-(i1-i2):]\n            #print(temp,i1,i2)\n            temp=sorted(temp)\n            #print(temp,i1,i2)\n            for i3 in range(i1):\n                if temp[i3]>=0 or i3>=k-i1:\n                    stop=i3\n                    break\n                stop=10**9\n            if stop!=10**9:\n                #print(temp[i3:],1)\n                ans=max(sum(temp[i3:]),ans)\n    \n    print(ans)\n\n\n\ndef __starting_point():\n    do()\n__starting_point()", "import heapq\n\nN, K = map(int, input().split())\n\nV = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, K+1):\n    if i > N:\n        continue\n    for j in range(i+1):\n        tmp = 0\n        q = V[:j] + V[N-i+j:]\n        heapq.heapify(q)\n        for _ in range(min(i, K-i)):\n            tmp_min = heapq.heappop(q)\n            ans = max(ans, sum(q))\n            if tmp_min > 0:\n                ans = max(ans, sum(q)+tmp_min)\n                break\n        ans = max(ans, sum(q))\n\nprint(ans)", "N, K = list(map(int, input().split()))\nV = [int(i) for i in input().split()]\nans = 0\nfor M in range(K+1):\n    for m in range(M+1):\n        ls = []\n        for i, x in enumerate(V):\n            if i < m:\n                ls.append(x)\n        for i, x in enumerate(V[::-1]):\n            if i < min(M-m, N-m):\n                ls.append(x)\n        ls.sort()\n        s = sum(ls)\n        for i, x in enumerate(ls):\n            if i < K-M and x < 0:\n                s -= x\n        ans = max(ans, s)\nprint(ans)\n", "import sys\nimport copy\nimport heapq\nfrom collections import deque\ninput = lambda: sys.stdin.readline().rstrip()\nINF = 10**9 + 7\n\n\ndef solve():\n    N, K = list(map(int, input().split()))\n    V = deque(list(map(int, input().split())))\n\n    ans = -INF\n    for n in range(1, N + 1):\n        if n > K:\n            break\n        for rn in range(n + 1):\n            ln = n - rn\n            tv = copy.copy(V)\n            pv = 0\n            mv = []\n            heapq.heapify(mv)\n            for _ in range(rn):\n                v = tv.pop()\n                if v >= 0:\n                    pv += v\n                else:\n                    heapq.heappush(mv, v)\n            for _ in range(ln):\n                v = tv.popleft()\n                if v >= 0:\n                    pv += v\n                else:\n                    heapq.heappush(mv, v)\n\n            mvlen = min(K - n, len(mv))\n            for _ in range(0, mvlen):\n                heapq.heappop(mv)\n\n            #print(ln, rn, pv, mv)\n            ans = max(ans, pv + sum(mv))\n\n    print((max(0, ans)))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "def readinput():\n    n,k=list(map(int,input().split()))\n    v=list(map(int,input().split()))\n    return n,k,v\n\ndef main(n,k,v):\n    ruisekiL=[0]*(n+1)\n    ruisekiR=[0]*(n+1)\n    for i in range(1,n+1):\n        ruisekiL[i]=ruisekiL[i-1]+v[i-1]\n        ruisekiR[i]=ruisekiR[i-1]+v[n-i]\n    vv=[]\n    for i in range(n):\n        vv.append((i+1,v[i]))\n    vv.sort(key=lambda x:x[1])\n    #print(vv)\n\n    maxown=-10**7\n    for kk in range(k+1):\n        if n<kk:\n            own=ruisekiL[n]\n            m=0\n            while m<n and vv[m][1]<0: \n                own-=vv[i][1]\n                m+=1\n            #print(own)\n            maxown=max(maxown,own)\n        else:\n            for l in range(kk//2+1):\n                for i in range(kk-l+1):\n                    j=kk-i-l\n                    jj=n-j+1\n                    own=ruisekiL[i]+ruisekiR[j]\n                    #print(i,j,own)\n                    m=0\n                    mcnt=0\n                    while(mcnt<l):\n                        if i<vv[m][0] and vv[m][0]<jj:\n                            m+=1\n                            continue\n                        #print(i,jj,vv[m])\n                        own-=vv[m][1]\n                        mcnt+=1\n                        m+=1\n                    #print(own)\n                    maxown=max(own,maxown)\n    return maxown\n\ndef main2(n,k,v):\n    ruisekiL=[0]*(n+1)\n    ruisekiR=[0]*(n+1)\n    for i in range(1,n+1):\n        ruisekiL[i]=ruisekiL[i-1]+v[i-1]\n        ruisekiR[i]=ruisekiR[i-1]+v[n-i]\n    vv=[]\n    for i in range(n):\n        vv.append((i+1,v[i]))\n    vv.sort(key=lambda x:x[1])\n    #print(vv)\n\n    maxown=-10**7\n    for i in range(n+1):\n        for j in range(n+1):\n            if i+j>k or i+j>n:\n                break\n            jj=n-j+1\n            own=ruisekiL[i]+ruisekiR[j]\n            #print(i,j,own)\n            l=min(i+j,k-i-j)\n            m=0\n            mcnt=0\n            while(mcnt<l):\n                if i<vv[m][0] and vv[m][0]<jj:\n                    m+=1\n                    continue\n                if vv[m][1]>=0:\n                    break\n                own-=vv[m][1]\n                mcnt+=1\n                m+=1\n            #print(own)\n            maxown=max(own,maxown)\n    return maxown\n\ndef __starting_point():\n    n,k,v=readinput()\n    ans=main2(n,k,v)\n    print(ans)\n\n__starting_point()", "import heapq\nimport copy\nN,K = map(int, input().split())\nV_list= list(map(int, input().split()))\n\nselected = []\nleft = []\n\nmax_sum = 0\nleft_sum = 0\nfor l in range(N):\n    selected = copy.deepcopy(left)\n    lr_sum = left_sum\n    for r in range(N-l+1):\n        # skip\n        stock = K-l-r\n        if stock < 0:\n            break\n        ri = N-r-1\n        select_cnt = len(selected)\n        tmp_sum = lr_sum\n        max_sum = max(max_sum, tmp_sum)\n        popper = copy.deepcopy(selected)\n\n        for i in range(stock):\n            if i >= select_cnt:\n                break\n            \n            pop_v = heapq.heappop(popper)\n            if pop_v > 0:\n                break\n            tmp_sum -= pop_v\n            max_sum = max(max_sum, tmp_sum)\n\n        r_val = V_list[ri]\n        lr_sum += r_val\n        heapq.heappush(selected, r_val)\n\n    l_val = V_list[l]\n    left_sum += l_val\n    heapq.heappush(left, l_val)\n\nprint(max_sum)", "from collections import deque\nn, k = list(map(int, input().split()))\nv = list(map(int, input().split()))\nd = deque(v)\n\nt = min(n, k)\nscore = 0\nfor a in range(t+1):\n    for b in range(t-a+1):\n        tmp_d = d.copy()\n        jems = []\n        for i in range(a):\n            jems.append(tmp_d.pop())\n        for i in range(b):\n            jems.append(tmp_d.popleft())\n        jems.sort()\n        for i in range(min(len(jems), k-b-a)):\n            if jems[i] < 0:\n                jems[i] = 0\n            else:\n                break\n        tmp_score = sum(jems)\n        if tmp_score > score:\n            score = tmp_score\nprint(score)\n", "from collections import deque\nimport heapq\nn,k = map(int,input().split())\nv = deque(list(map(int,input().split())))\n\nans = 0\nfor i in range(min(n,k)+1):\n    for j in range(min(n,k)-i+1):\n        l = [0]\n        r = [0]\n        mm = [0]\n        for p in range(i):\n            if v[p] > 0:\n                l.append(v[p])\n            else:\n                heapq.heappush(mm,v[p])\n        for o in range(j):\n            if v[-o-1] > 0:\n                r.append(v[-o-1])\n            else:\n                heapq.heappush(mm,v[-o-1])\n        for m in range(min(k-i-j,len(mm))):\n            heapq.heappop(mm)\n        ans = max(ans,sum(l)+sum(r)+sum(mm))\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\nfrom collections import deque\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\nfrom heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef solve():\n    N, K = MI()\n    V = LI()\n    max_iter = min(N, K)\n    ans = 0\n    for a in range(max_iter+1):\n        left = V[:a]\n        for b in range(0, max_iter-a+1):\n            right = V[-b:] if b != 0 else []\n            k = K - a - b\n            # print(a, b, k)\n            # print(left, right)\n            lst = sorted(left + right)\n            # print(lst)\n            sm = sum(lst)\n            l = len(lst)\n            for kk in range(1, k+1):\n                if kk < l:\n                    tmp = lst[kk-1]\n                    if tmp >= 0: break\n                    sm -= tmp\n                    # print(tmp)\n                else:\n                    break\n            ans = max(ans, sm)\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n, k = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\n\ndef get_jewelries(box, left_pop, right_pop):\n    if left_pop + right_pop >= len(box):\n        return box[:]\n\n    left = box[:left_pop]\n    right = box[-right_pop:] if right_pop else []\n\n    return left + right\n\n\ncandidates = []\npop_max = min(k, n)\nfor pop_count in range(pop_max+1):\n    residue = k - pop_count\n\n    for left_pop in range(pop_count+1):\n        right_pop = pop_count - left_pop\n        jewelries = get_jewelries(V, left_pop, right_pop)\n        jewelries.sort(reverse=True)\n\n        for _ in range(residue):\n            if not jewelries:\n                break\n            if jewelries[-1] < 0:\n                jewelries.pop()\n\n        value = sum(jewelries)\n        candidates.append(value)\n\nprint((max(candidates)))\n", "n,k = map(int, input().split())\nv = list(map(int, input().split()))\n\nans = 0\nfor x in range(k+1):# LeftHand\n  for y in range(k-x+1):# RightHand\n    temp1 = []\n    temp2 = []\n    if x+y >= n:\n      for i in v:\n        if i >= 0:\n          temp1.append(i)\n        else:\n          temp2.append(i)\n    else:\n      for i in v[:x]:\n        if i >= 0:\n          temp1.append(i)\n        else:\n          temp2.append(i)\n      for i in v[len(v)-y:]:\n        if i >= 0:\n          temp1.append(i)\n        else:\n          temp2.append(i)\n    temp2.sort()\n    ans = max(ans, sum(temp1) + sum(temp2[k-x-y:]))\nprint(ans)", "n,k = list(map(int,input().split()))\nv = list(map(int,input().split()))\nans = 0\nfor a in range(min(n,k)+1):\n    for b in range(min(n,k)-a+1):\n        c = v[:a] + v[n-b:]\n        c = sorted(c)\n        for i in range(k-a-b):\n            if len(c) == 0:\n                break\n            if c[0] < 0:\n                c = c[1:]\n            else:\n                break\n        ans = max(ans,sum(c))\nprint(ans)\n", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  n,k=LI()\n  v=LI()\n\n  ans=0\n  for i in range(k):\n    if i+1<n:\n      for l in range(i+1):\n        r=i-l\n  \n        _ans=0\n        _v=[]\n        for x in range(l+1):\n          _ans+=v[x]\n          _v.append(v[x])\n        for x in range(r):\n          _ans+=v[n-x-1]\n          _v.append(v[n-x-1])\n\n        _v.sort()\n        for j in range(min(len(_v),k-i-1)):\n          if _v[j]<0:\n            _ans-=_v[j]\n          else:\n            break\n        # print(_v,l,r,_ans)\n        ans=max(ans,_ans)\n    else:\n      _v=v.sort()\n      _ans=sum(v)\n      _k=n-k-1\n      for j in range(_k):\n        if _v[j]<0:\n          _ans-=_v[j]\n        else:\n          break\n      ans=max(ans,_ans)\n\n  return ans\n\n# main()\nprint((main()))\n", "n, k = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nres = 0\nr = min(n, k)\nfor i in range(r+1):\n    for j in range(r-i+1):\n        in_hand = v[:i] + v[n-j:] if i + j < n else v[:]\n        in_hand.sort(reverse=True)\n        for _ in range(k-len(in_hand)):\n            if not in_hand or in_hand[-1] >= 0:\n                break\n            in_hand.pop()\n        res = max(res, sum(in_hand))\nprint(res)\n", "N,K = list(map(int,input().split()))\nV = list(map(int,input().split()))\nleft = [0]*(K+1)\nright = [0]*(K+1)\n\nfor k in range(1,min(N+1,K+1)):\n    max_vk = 0\n    for j in range(k//2+1):        \n        push = j\n        pop = k-j\n        #print(k,pop,push)\n        if pop>N:\n            continue\n        else:\n            tmp = sum(sorted(V[:pop])[push:])\n        max_vk = max(max_vk,tmp)\n    left[k] = max_vk\n\nVrev = V[::-1]\n\nfor k in range(1,K+1):\n    max_vk = 0\n    for j in range(k//2+1):\n        push = j\n        pop = k-j\n        #print(k,pop,push)\n        if pop>N:\n            continue\n        else:\n            tmp = sum(sorted(Vrev[:pop])[push:])\n        max_vk = max(max_vk,tmp)\n    right[k] = max_vk\n\nfor i in range(len(right)-1):\n    if right[i+1]<right[i]:\n        right[i+1]= right[i]\n    if left[i+1]<left[i]:\n        left[i+1]=left[i]\n\nans = 0\nNK = K\nmax_ans = 0\nfor v in V:\n    if v>0:\n        max_ans += v\n    \nfor i in range(NK+1):\n    ans = max(ans,right[i]+left[NK-i])\n\nprint((min(max_ans,ans)))\n", "N,K = list(map(int,input().split()))\nV = list(map(int,input().split()))\n#print(V)\nmax_v = 0\nhave_minus = []\nfor left in range(N):\n  for right in range(left,N + 1)[::-1]:\n    if len(V[:left]) + len(V[right:]) > K: \n      break\n    #print (V[:left], V[right:])\n    sum_ = sum(V[:left]) + sum(V[right:])\n    have_minus = [num for num in V[:left]+V[right:] if num < 0]\n    have_minus.sort()\n    #print (f\"have_minus={have_minus}\" )\n    d = max(0,K - (len(V[:left]) + len(V[right:])))\n    for i in range(min(d, len(have_minus))):\n        sum_ -= have_minus[i]   \n    #print (f\"sum_ = {sum_}\")    \n    \n    max_v = max(max_v ,sum_)\nprint(max_v)      \n    \n    \n       \n", "N, K = map(int, input().split())\nV = list(map(int, input().split()))\nans = 0\nfor anum in range(min(N, K) + 1):\n    owned = V[:anum]\n    for bnum in range(min(N, K) - anum + 1):\n        if bnum > 0:\n            owned.append(V[-bnum])\n        owned.sort()\n        cdnum = K - (anum + bnum)\n        total = 0\n        for v in owned:\n            if v < 0 and 0 < cdnum:\n                cdnum -= 1\n            else:\n                total += v\n        ans = max(ans, total)\nprint(ans)", "N,M=list(map(int,input().split()))\nl=list(map(int,input().split()))\nS=min(M,N)\nans=0\nfor i in range(S+1):\n   for j in range(S-i+1):\n      mem=l[0:i]+l[N-j:]\n      for k in range(min((M-i-j),len(mem))):\n         if min(mem)<0:\n            mem.remove(min(mem))\n      ans=max(ans,sum(mem))\nprint(ans)", "N, K = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nans = []\n# \u304d\u3063\u3061\u308aK\u56de\u3057\u306a\u304f\u3066\u3044\u3044\u307f\u305f\u3044\nfor left in range(N + 1):\n    for right in range(N + 1):\n        if left + right > N:\n            break\n\n        li = V[:left] + V[N - right :]\n        li = sorted(li)\n\n        d = K - left - right\n        if d < 0:\n            break\n\n        c = sum(li)\n        for i in range(min(d, len(li))):\n            if li[i] < 0:\n                c -= li[i]\n            else:\n                break\n\n        ans.append(c)\n\nprint((max(ans)))\n\n", "import sys\nimport heapq\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n    n, k = map(int, input().split())\n    v = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            h=[0]\n            heapq.heapify(h)\n            count = 0\n            for p in range(i-1):\n                heapq.heappush(h, v[p])\n                count += 1\n            for m in range(j+1, n):\n                heapq.heappush(h, v[m])\n                count += 1\n            while h[0] < 0 and count < k:\n                t = heapq.heappop(h)\n                count += 1\n            if count <= k:\n                ans = max(ans,sum(h))\n    counts = n\n    heapq.heapify(v)\n    while h[0] < 0 and counts < k:\n        t = heapq.heappop(v)\n        counts += 1\n    if counts <= k:\n        ans = max(ans,sum(v))\n    print(ans)\n   \ndef __starting_point():\n    main()\n__starting_point()", "\nN, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nMAX = 0\nfor k in range(1, K+1):\n    for ka in range(k+1):\n        for kb in range(k+1-ka):\n            kcd = k - ka - kb\n            \n            if (ka+kb <= kcd) or (ka+kb > N):\n                continue\n            \n            #print(ka, kb, kcd)\n            s = V[:ka] + V[-kb:] if kb != 0 else V[:ka]\n            s.sort()\n            #print(s[kcd:], sum(s[kcd:]))\n            MAX = max(MAX, sum(s[kcd:]))\n\nprint(MAX)", "n,k=map(int,input().split())\n\na=list(map(int,input().split()))\na_reverse=list(reversed(a))\nb=sorted(a)\ns=sum(a)\n\nans=[]\n\nfor i in range(k+1):\n  if i>n:\n    I=i-n\n    for j in range(I): \n      if j<n:\n        ans1=s-b[j]\n    ans.append(ans1)\n  elif i==n:\n    ans.append(s)\n  elif i==0:\n    ans.append(0)\n  else:\n    for h in range(i+1):\n      H=i-h\n      c=[]\n      for x in range(h):\n        c.append(a[x])\n      for y in range(H):\n        c.append(a_reverse[y])\n        \n      c.sort()\n      S=sum(c)\n      for g in range(1,k-i+1):\n        if g<=i:\n          if c[g-1]<0:\n            S-=c[g-1]\n\n      ans.append(S)\n      \nprint(max(ans))", "n, k = map(int, input().split())\nv = list(map(int, input().split()))\nans = 0\nfor i in range(k+1):\n  for j in range(k+1):\n    if i+j > k or i+j > n:\n      continue\n    t = k-(i+j)\n    s = v[:i] + v[(n-j):]\n    s.sort()\n    u = 0\n    # print (s,t)\n    while u < t:\n      u += 1\n      if len(s) < 1:\n        break\n      if s[0] < 0:\n        s.pop(0)\n      else:\n        break\n    ans = max(ans, sum(s))\nprint (ans)", "def main():\n    n, k = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n    ans = -1\n    for i in range(c := min(n, k) + 1):\n        for j in range(c - i):\n            A = V[:i] + V[-j:] if j != 0 else V[:i]\n            A.sort(reverse = True)\n            r = k - (i + j)\n            for _ in range(r):\n                if len(A) == 0:\n                    break\n                if (a := A.pop()) >= 0:\n                    A.append(a)\n                    break\n            ans = max(ans, sum(A))\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k = map(int,input().split())\nv = list(map(int,input().split()))\nans = 0\nfor i in range(min(n+1,k+1)):\n    for j in range(min(n+1-i,k+1-i)):\n        g = []\n        x = 0\n        while x < i:\n            g.append(v[x])\n            x += 1\n        y = 0\n        z = -1\n        while y < j:\n            g.append(v[z])\n            y += 1\n            z -= 1\n        g.sort()\n        x = k - i - j\n        for z in range(min(len(g),x)):\n            if g[z] < 0:\n                g[z] = 0\n            else:\n                break\n        ans = max(ans,sum(g))\nprint(ans)"]
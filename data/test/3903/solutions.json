["#!/usr/bin/env python3\n#\n# Three States\n#\nimport sys, os\nfrom collections import deque\nfrom pprint import pprint\n\ndef read_ints(): return list(map(int, input().split()))\ndef read_str(): return input().strip()\n\nn, m = read_ints()\ns = [read_str() for _ in range(n)]\n\nt = [set(), set(), set()]\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j] in '123':\n\t\t\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n\t\t\t\tif 0 <= ii < n and 0 <= jj < m:\n\t\t\t\t\tif s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:\n\t\t\t\t\t\tt[int(s[i][j]) - 1].add((i, j))\n\t\t\t\t\t\tbreak\n\nz = [[[1e18] * 3 for j in range(m)] for i in range(n)]\nans = 1e18\nfor root in range(3):\n\tq = deque()\n\tvi = [[False] * m for _ in range(n)]\n\tfor i, j in t[root]:\n\t\tq.append((i, j, 0))\n\t\tvi[i][j] = True\n\t\tz[i][j][root] = 0\n\tdist = [1e18] * 3\n\tdist[root] = 0\n\twhile q:\n\t\ti, j, d = q.popleft()\n\t\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n\t\t\tif 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:\n\t\t\t\tif s[ii][jj] == '.':\n\t\t\t\t\tvi[ii][jj] = True\n\t\t\t\t\tq.append((ii, jj, d + 1))\n\t\t\t\t\tz[ii][jj][root] = min(z[ii][jj][root], d + 1)\n\t\t\t\telif s[ii][jj] != s[i][j] and s[ii][jj] in '123':\n\t\t\t\t\tdist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)\n\tans = min(ans, sum(dist))\n\nif ans >= 1e18:\n\tprint(-1)\nelse:\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif s[i][j] == '.':\n\t\t\t\tans = min(ans, sum(z[i][j]) - 2)\n\tprint(ans)\n", "#!/usr/bin/env python3\n#\n# Three States\n#\nimport sys, os\nfrom collections import deque\nfrom pprint import pprint\n\ndef read_ints(): return list(map(int, input().split()))\ndef read_str(): return input().strip()\n\nn, m = read_ints()\ns = [read_str() for _ in range(n)]\n\nt = [set(), set(), set()]\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j] in '123':\n\t\t\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n\t\t\t\tif 0 <= ii < n and 0 <= jj < m:\n\t\t\t\t\tif s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:\n\t\t\t\t\t\tt[int(s[i][j]) - 1].add((i, j))\n\t\t\t\t\t\tbreak\n\nz = [[[1e18] * 3 for j in range(m)] for i in range(n)]\nans = 1e18\nfor root in range(3):\n\tq = deque()\n\tvi = [[False] * m for _ in range(n)]\n\tfor i, j in t[root]:\n\t\tq.append((i, j, 0))\n\t\tvi[i][j] = True\n\t\tz[i][j][root] = 0\n\tdist = [1e18] * 3\n\tdist[root] = 0\n\twhile q:\n\t\ti, j, d = q.popleft()\n\t\tfor ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n\t\t\tif 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:\n\t\t\t\tif s[ii][jj] == '.':\n\t\t\t\t\tvi[ii][jj] = True\n\t\t\t\t\tq.append((ii, jj, d + 1))\n\t\t\t\t\tz[ii][jj][root] = min(z[ii][jj][root], d + 1)\n\t\t\t\telif s[ii][jj] != s[i][j] and s[ii][jj] in '123':\n\t\t\t\t\tdist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)\n\tans = min(ans, sum(dist))\n\nif ans >= 1e18:\n\tprint(-1)\nelse:\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif s[i][j] == '.':\n\t\t\t\tans = min(ans, sum(z[i][j]) - 2)\n\tprint(ans)\n\n", "# lista doble enlazada o(1) operaciones en los bordes es mejor que si se implementa en el propio lenguaje\nfrom collections import deque\nn, m = input().split()\nn = int(n)\nm = int(m)\n\n\ndef idx(i, j):\n    return i*m + j\n\n\nmax = n*m*2\ngraph = \"\"\nvirtDist = [[], [], []]\nvirtVertex = [deque(), deque(), deque()]\nvirtNodesDst = [max, max, max]\ncode = ord(\"1\")\nfor i in range(0, n):\n    s = input()\n    graph += s\n    for j in range(0, m):\n        virtDist[0].append(max)\n        virtDist[1].append(max)\n        virtDist[2].append(max)\n        indx = ord(s[j])-code\n        if 0 > indx or indx > 2:\n            continue\n        virtVertex[indx].append((i, j))\n        i2 = idx(i, j)\n        virtDist[indx][-1] = 0\n\n\ndef bfs01(queue, distance):\n    while queue:\n        pi, pj = queue.popleft()\n        for i, j in [(pi, pj-1), (pi, pj+1), (pi-1, pj), (pi+1, pj)]:\n            indx = idx(i, j)\n            if 0 > i or i >= n or 0 > j or j >= m or graph[indx] == '#':\n                continue\n            isRoad = graph[indx] == \".\"\n            newDistance = distance[idx(pi, pj)] + (1 if isRoad else 0)\n            if distance[indx] > newDistance:  # relax\n                distance[indx] = newDistance\n                if isRoad:\n                    queue.append((i, j))\n                else:\n                    queue.appendleft((i, j))\n\n\nbfs01(virtVertex[0], virtDist[0])\nbfs01(virtVertex[1], virtDist[1])\nbfs01(virtVertex[2], virtDist[2])\n\noutput = max\nfor i in range(0, n*m):\n    output = min(virtDist[0][i] + virtDist[1][i] + virtDist[2]\n                 [i] - (2 if graph[i] == \".\"else 0), output)\n\nprint(output if output < max else -1)\n"]
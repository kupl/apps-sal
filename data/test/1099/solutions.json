["import sys\ninput = sys.stdin.readline\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    u, v = list(map(int, input().split()))\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndepth = [-1] * n\ndepth[0] = 0\n    \nodd = 0\neven = 1\n\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\n\nprint(min(odd,even) - 1)\n", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndepth = [-1] * n\ndepth[0] = 0\n    \nodd = 0\neven = 1\n\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\n\nprint(min(odd,even) - 1)", "n = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndepth = [-1] * n\ndepth[0] = 0\n    \nodd = 0\neven = 1\n\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\n\nprint(min(odd,even) - 1)", "n = int(input());adj = [[] for i in range(n)];depth = [-1] * n;depth[0] = 0;odd,even,q = 0,1,[0]\nfor _ in range(n - 1):u, v = map(int, input().split());adj[u-1].append(v-1);adj[v-1].append(u-1)\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\n\nprint(min(odd,even) - 1)", "n = int(input());adj = [[] for i in range(n)];depth = [-1] * n;depth[0] = 0;odd,even,q = 0,1,[0]\nfor _ in range(n - 1):u, v = map(int, input().split());adj[u-1].append(v-1);adj[v-1].append(u-1)\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:odd += 1\n            else:even += 1\n            q.append(v)\nprint(min(odd,even) - 1)", "import sys\ninput = sys.stdin.readline\nn=int(input())\n\nE=[[] for i in range(n+1)]\nfor i in range(n-1):\n    x,y=list(map(int,input().split()))\n    E[x].append(y)\n    E[y].append(x)\n\nC=[-1]*(n+1)\nQ=[1]\nC[1]=0\nwhile Q:\n    x=Q.pop()\n\n    for to in E[x]:\n        if C[to]==-1:\n            C[to]=1-C[x]\n            Q.append(to)\n\nB=C.count(0)\nW=C.count(1)\n\nprint(min(B,W)-1)\n", "import collections as cc\nimport sys\nI=lambda:list(map(int,input().split()))\nn,=I()\ng=cc.defaultdict(list)\nfor i in range(n-1):\n\tx,y=I()\n\tg[x].append(y)\n\tg[y].append(x)\ncol=[-1]*(n+1)\nb=0\nw=0\nvisi=[0]*(n+1)\nst=cc.deque()\nst.append(1)\ncol[1]=1\nw+=1\nwhile st:\n\tx=st.pop()\n\tvisi[x]=1\n\tfor y in g[x]:\n\t\tif not visi[y]:\n\t\t\tcol[y]=col[x]^1\n\t\t\tst.append(y)\nb=col.count(1)\nw=col.count(0)\nprint(min(b,w)-1)\n", "import sys\nfrom collections import defaultdict\n\n\ndef rl(): return sys.stdin.readline().strip()\n\ndef BFS(s,nbrs):\n    level = defaultdict(int)\n    ind = 0\n    level[ind] += 1\n    frontier = [s]\n    visited = {s}\n    while frontier:\n        next = []\n        ind += 1\n        for u in frontier:\n            for v in nbrs[u]:\n                if v not in visited:\n                    next.append(v)\n                    visited.add(v)\n                    level[ind] += 1\n        frontier = next\n    return level\n\n\nn = int(rl())\nvert = []\nnbrs = defaultdict(list)\nfor i in range(n-1):\n    vert.append(list(map(int,rl().split())))\n    j = vert[-1][0]\n    k = vert[-1][1]\n    nbrs[j].append(k)\n    nbrs[k].append(j)\nnew = 0\ncounter = BFS(1,nbrs)\nfor i in range(2,n-1,2):\n    new += counter[i]\nans = min(n-2-new,new)\nprint(ans)\n", "import sys\nfrom collections import defaultdict as dd\nfrom collections import deque\nfrom fractions import Fraction as f\nfrom copy import *\nfrom bisect import *\t\nfrom heapq import *\nfrom math import *\nfrom itertools import permutations \n \ndef eprint(*args):\n    print(*args, file=sys.stderr)\nzz=1\n \n#sys.setrecursionlimit(10**6)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndef li():\n\treturn [int(x) for x in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef gi():\t\n\treturn [x for x in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tmap(int,input().split())\t\ndef gh():\n\tsys.stdout.flush()\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\ndef bo(i):\n\treturn ord(i)-ord('a')\n\t\t\n\n\ntt=1\n\n\n\nwhile tt>0:\n\ttt-=1\n\tn=fi()\n\t#Pick all even or odd levels\n\ta=[[] for i in range(n+1)]\n\tfor i in range(n-1):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\tdis=[0 for i in range(n+1)]\n\tq=deque()\n\tq.append(1)\n\tvis=[0 for i in range(n+1)]\n\tvis[1]=1\n\twhile len(q):\n\t\tz=q.popleft()\n\t\tfor j in a[z]:\n\t\t\tif vis[j]==0:\n\t\t\t\tvis[j]=1\n\t\t\t\tdis[j]=dis[z]^1\n\t\t\t\tq.append(j)\n\tprint(min(dis[1:].count(0),dis[1:].count(1))-1)\t\t\t\n\n\n\t\n\n\n\n", "from collections import defaultdict, deque\n\nNONE = -1\nWHITE = 0\nBLACK = 1\nnw = 0\n\n\ndef colorize(G, color, v, c):\n    nonlocal nw\n    nw += (c == WHITE)\n    color[v] = c\n    for u in G[v]:\n        if color[u] == NONE:  # not assigned a color yet\n            colorize(G, color, u, 1-c)\n\n\ndef colorize_v2(G, stack, color):\n    nw = 0\n    while stack:\n        v, c = stack.pop()\n        color[v] = c\n        nw += (c == WHITE)\n        for u in G[v]:\n            if color[u] == NONE:\n                stack.append((u, 1-c))\n\n    return nw\n\n\nn = int(input())\n\n# Adjacency list presentation of the graph, in which G[u] is a list of u's adjacent vertices.\nG = defaultdict(list)\nfor _ in range(n-1):\n    u, v = (int(x) for x in input().strip().split())\n    G[u].append(v)\n    G[v].append(u)\n\ncolor = [NONE] * (n+1)\nstack = deque()\nstack.append((1, WHITE))\nnw = colorize_v2(G, stack, color)\nprint(min(nw, n-nw)-1)\n", "\nfrom collections import defaultdict\nn = int(input())\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    l = list(map(int, input().split()))\n    graph[l[0]].append(l[1])\n    graph[l[1]].append(l[0])\ncolor_v = [-1]*(n + 1)\ncolor_v[1] = 0\nq = [1]\nwhile q:\n    x = q.pop()\n    for i in graph[x]:\n        if color_v[i] == -1:\n            color_v[i] = 1 - color_v[x]\n            q.append(i)\nprint(min(color_v.count(1), color_v.count(0)) - 1)\n", "import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nn=II()\nto=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=MI1()\n    to[u].append(v)\n    to[v].append(u)\ndp=[0]*n\nch=[0]*n\nstack=[(0,-1)]\nfirst=[True]*n\nwhile stack:\n    u,pu=stack.pop()\n    if first[u]:\n        first[u]=False\n        stack.append((u,pu))\n        for v in to[u]:\n            if v==pu:continue\n            stack.append((v,u))\n    else:\n        for v in to[u]:\n            if v==pu:continue\n            ch[u]+=1+dp[v]\n            dp[u]+=ch[v]\n#print(dp)\n#print(ch)\n\nstack=[(0,-1)]\nwhile stack:\n    u,pu=stack.pop()\n    for v in to[u]:\n        if v==pu:continue\n        dpvu=dp[u]-ch[v]\n        chvu=ch[u]-dp[v]-1\n        dp[v]+=chvu\n        ch[v]+=dpvu+1\n        stack.append((v,u))\n#print(dp)\n#print(ch)\n\nprint(min(dp))\n"]
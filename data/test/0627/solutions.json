["n = int(input())\ns = input()\nfor i in range(len(s) - 1):\n\tif s[i] > s[i + 1]:\n\t\tprint(s[:i] + s[i + 1:len(s)])\n\t\treturn\nprint(s[:len(s) - 1])\n", "n = int(input())\ns = input().strip()\n\nfor i in range(len(s) - 1):\n    if s[i] > s[i + 1]:\n        print(s[:i] + s[i+1:])\n        return\nprint(s[:-1])\n", "n=input()\ns = input()\nfor i in range(len(s) - 1):\n    if s[i+1] < s[i]:\n        print(s[:i] + s[i+1:])\n        return\n\nprint(s[:len(s) - 1])", "import sys, math\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n = int(input())\n    a = input()\n    for i in range(len(a) - 1):\n        if a[i] > a[i + 1]:\n            print(a[:i] + a[i + 1:])\n            return\n    print(a[:len(a) - 1])\nmain()", "n = int(input())\nt = input()\nfor i in range(n-1):\n    if t[i] > t[i+1]:\n        t = t[:i]+t[i+1:]\n        break\nif len(t) == n:\n    print(t[:n-1])\nelse:\n    print(t)\n", "n = int(input())\ns = input()\nalth = \"abcdefghijklmnopqrstuvwxyz\"\nans = n-1\nfor i in range(1,n):\n    if alth.find(s[i]) < alth.find(s[i-1]) :\n        ans = i-1\n        break\n\nfor i in range(n):\n    if i != ans:\n        print(s[i],end=\"\")\n", "n = int(input())\ns = input()\np=''\nfor i in range(n-1):\n    if s[i] > s[i+1]:\n        p = s[:i]+s[i+1:]\n        break\n    if i == n-2:\n        p=s[:-1]\nprint(p)\n", "n = int(input())\ns = input()\n\nfor i in range(n - 1):\n    if ord(s[i]) > ord(s[i + 1]):\n        print(s[:i] + s[i + 1:])\n        return\n\nprint(s[:-1])\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\ns = input().strip()\ni = 0\nwhile i < n - 1:\n    if ord(s[i]) > ord(s[i + 1]):\n        break\n    i += 1\nans = s[:i] + s[i + 1:]\nprint(ans)\n", "n = int(input())\ns = input()\np = -1\nfor i in range(n - 1):\n    if ord(s[i]) > ord(s[i + 1]):\n        p = i\n        break\nif p == -1:\n    s = s[:-1]\nelse:\n    s = s[:p] + s[p + 1:]\nprint(s)\n", "import math\nimport bisect\nimport itertools\nimport sys\nmod=10**9 +7\n'''fact=[1]*1001\nifact=[1]*1001\nfor i in range(1,1001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n    \ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\n    \ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2   \n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n    \ndef is_prime(num):\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n    \n  \ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n    \ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s    \n        \n        \n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\nn=int(input())\na=list(input())\nfor i in range(len(a)-1):\n    if a[i]>a[i+1]:\n        del a[i]\n        print((''.join((a))));return\nprint((''.join((a[:n-1]))));return\n    \n        \n\n", "n=int(input())\ns=input()\nfor i in range(n-1):\n    if s[i]>s[i+1]:\n        print(s[:i]+s[i+1:])\n        return\nprint(s[:n-1])", "n = int(input())\ns = [i for i in input()]\nfor i in range(n-1):\n    if s[i] > s[i+1]:\n        s.pop(i)\n        break\nif len(s) == n:\n    s.pop()\nprint(\"\".join(s))", "n = int(input())\na=input()\nfor i in range(n - 1):\n    if (ord(a[i])>ord(a[i+1])):\n        print(a[:i]+a[i+1:])\n        return\nprint(a[:n-1])", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\ns = input()\n\nfor i in range(1,N):\n    if s[i-1] > s[i]:\n        print(s[:i-1] + s[i:])\n        return \nprint(s[:-1])\n\n\n\n\n\n", "#!/usr/bin/env python3\nfrom typing import Dict, List, Tuple\n\n\ndef input_lst() -> List[int]:\n    return [int(x) for x in input().split()]\n\ndef print_out(res: List[int]):\n    print(' '.join([str(x) for x in res]))\n\n\n\n\ndef main():\n\n    n,  = (int(x) for x in input().split())\n    #a = input_lst()\n    s = input()\n    for i in range(len(s) - 1):\n        if s[i] > s[i+1]:\n            print(s[:i] + s[i+1:])\n            return\n    print(s[:-1])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "'''\noption 1 : do nothing ( not feasible )\noption 2 : take out the head\n'''\n\ninput()\ns = list(input())\nremoved = False\nfor i in range(len(s)-1):\n    if s[i] > s[i+1]:\n        del s[i]\n        removed = True\n        break\n\nif not removed:\n    del s[-1]\n    \nprint(''.join(s))\n", "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\n\ns = input().strip()\n\nfound = False\nfor i in range(len(s) - 1):\n    if s[i] > s[i + 1]:\n        s = s[0:i] + s[i+1:]\n        found = True\n        break\n\nif found:\n    print(s)\nelse:\n    print(s[:-1])", "n = int(input())\n\ns = input()\n\nfound = n - 1\n\nfor i in range(n - 1):\n  if(s[i] > s[i + 1]):\n    found = i\n    break\n\ns = s[:found] + s[found + 1:]\n\nprint(s)", "n = int(input())\ns = [*input()]\nfor i in range(n):  \n    if i == n - 1 or s[i] > s[i + 1]:\n        del s[i]\n        break\nprint(''.join(s))", "#Author: Tanya Cheremkhina\nn = int(input())\ns = list(input())\nfor i in range(len(s) - 1):\n    if s[i] > s[i + 1]:\n        s[i] = ''\n        break\nelse:\n    s[-1] = ''\nprint(''.join(s))", "def main():\n    n = int(input())\n    s = input()\n    for i in range(1, n):\n        if ord(s[i - 1]) > ord(s[i]):\n            return s[:(i - 1)] + s[i:]\n    return s[:-1]\nprint(main())\n", "n=int(input())\ns=str(input())\nflag=0\nk=''\nfor i in range(1,n):\n    if(s[i-1]>s[i]):\n        k=s[:i-1]+s[i:]\n        flag=1\n        break\nif(flag==0):\n    k=s[:-1]\nprint(k)", "n=int(input())\ns=input()\nl=[]\nfor i in range(1,n):\n    if(s[i]<s[i-1]):\n        x=s[:i-1]+s[i:]\n        print(x)\n        break\n    if(i==n-1):\n        print(s[:n-1])\n        break\n"]
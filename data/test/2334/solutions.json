["n=int(input())\na=(list(map(int,input().split())))\na.sort(reverse=True)\nx,f=list(map(int,input().split()))\nans=0\nfor i in range(n):\n    if a[i]>x:\n        r=(a[i]-x)//(x+f)\n        if (a[i]-x)%(x+f):\n            r+=1\n        ans+=(f*r)\n    else:\n        break\nprint(ans)\n", "I=lambda:map(int,input().split())\nn=int(input())\na=(list(I()))\na.sort(reverse=True)\nx,f=I()\nsumm=0\nfor i in range(n):\n    if a[i]>x:\n        r=(a[i]-x)//(x+f)\n        if (a[i]-x)%(x+f):\n            r+=1\n        summ+=(f*r)\n    else:\n        break\nprint(summ)", "n = int(input())\nrek = list(map(int,input().split()))\nmx, pay = map(int,input().split())\nans = 0\nimport math\nfor i in rek:\n    if i > mx:\n        ans += pay * (math.ceil((i-mx)/(mx+pay)))\nprint(ans)", "# -*- coding: utf-8 -*-\nfrom math import ceil\n\ndef problem(in1, in2, in3):\n    n = int(in1)\n    balances = list(map(int, in2.split()))\n    \n    limit = list(map(int, in3.split()))[0]\n    fee = list(map(int, in3.split()))[1]\n    \n    tx_size = limit + fee\n    \n    tx_count = 0\n\n    for index, balance in enumerate(balances):\n        tx_needed = ceil((balance - limit) / tx_size)\n        tx_count += tx_needed\n\n    return tx_count * fee\n\ndef __starting_point():\n    in1 = input()\n    in2 = input()\n    in3 = input();\n\n    result = problem(in1, in2, in3)\n    \n    print(result)\n\n__starting_point()", "import math\nn=int(input())\na=list(map(int,input().split()))\ns=0\nm,f=map(int,input().split())\nfor i in a:\n    if i>m:\n        s+=math.ceil((i-m)/(f+m))*f\nprint(s)    ", "n=int(input())\na=[int(x) for x in input().split()]\nx,f=[int(x) for x in input().split()]\nres=0\nfor i in a:\n    if(i>x):\n        res+=f*int(i/(f+x))\n        if(i%(f+x)>x):\n            res+=f\n        # print(int(i%(f+x)))\nprint(res)\n", "n,c=int(input()),0\na=list(map(int,input().split()))\nx,f=map(int,input().split())\nfor i in a:\n    if i>x:\n        if (i-x)%(x+f)==0:\n            c+=(i-x)//(x+f)\n        else:\n            c+=(i-x)//(x+f)+1\nprint(c*f)", "import math\n\na = int(input())\n\nb = input().split()\nb = [int(i) for i in b]\n\n\nc = input().split()\nc = [int(i) for i in c]\n\noutput = 0\nfor i in b:\n\toutput += (i + c[1] - 1)//(c[0] + c[1])\n\t\nprint (output * c[1])", "def g(q, x, f, a):\n\tif(((a + q - 1) // q) - ((q - 1) * f) <= x):\n\t\treturn True\n\telse:\n\t\treturn False\n\ns = input()\nn = int(s)\n\n\ns = input()\ny = s.split()\n\ns = input()\ns = s.split()\n\nx = int(s[0])\nf = int(s[1])\n\nans = 0\n\nfor i in y:\n\tans += (int(i) + f - 1) // (x + f)\n\nprint(ans * f)\n\n", "#JMD\n#Nagendra Jha-4096\nimport sys\nimport bisect\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n\ndef search(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect.bisect_right(a, x)\n    if(i==0):\n        return -1\n    return i-1\n\n\n\n##### Main ####\nn=int(input())\na=list(map(int, sys.stdin.readline().split(' ')))\nx,f=map(int, sys.stdin.readline().split(' '))\n\nans=0\n\nfor aa in a:\n    if(aa<=x):\n        continue\n    val=(aa-x)//(x+f)\n    if(val*(x+f)<aa-x):\n        val+=1\n    ans+=val\nprint(f*ans)\n    \n\n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()", "n = int( input())\npublicAd =list(map(int,input().split(' ')))\nmaxx, fee = list(map(int,input().split(' ')))\ncount =0\nfor temp in publicAd:\n    if temp >maxx:\n        t = (temp-maxx)/(maxx+fee) \n        count +=1 + (int(t) if t >1 else 0)\nprint(count*fee)", "import math\nn=int(input())\na=list(map(int,input().split()))\nx,f=map(int,input().split())\nt=x+f\nans=0\nfor i in a:\n  if(i>x):\n    ans+=int(math.ceil(((i-x)/t)))\nprint(ans*f)", "num_addresses = int(input())\naddresses = list(map(int, input().split()))\nmax_satoshies, fee = list(map(int, input().split()))\nmovements = 0\nfor address in addresses:\n    to_move = address - max_satoshies\n    if to_move > 0:\n        movements += to_move // (max_satoshies + fee)\n        if to_move % (max_satoshies + fee) != 0:\n            movements += 1\nprint(movements * fee)\n", "import bisect\nimport math\nn=int(input())\nvallet=[]\nvallet=list(map(int,input().strip().split()))\nmaxst,fee=list(map(int,input().strip().split()))\nvallet.sort()\nindex = bisect.bisect(vallet, maxst)\n\nnumsplit=0\nfor i in range(index,len(vallet)):\n    numsplit+=math.ceil(float(vallet[i]-maxst)/(maxst+fee))\n\nprint(numsplit*fee)\n", "n = int(input())\na = list(map(int, input().split()))\nmax, fee = list(map(int, input().split()))\ntotal = 0\na.sort(reverse=True)\nfor i in range(n):\n    if a[i]> max:\n        num = -(-(a[i]-max)//(max+fee))\n        total = total + fee*num\n    else:\n        break\n\nprint(total)\n", "import math\nn= int (input())\nch=input().split()\na=list()\nfor i in range(n):\n    a.append(int(ch[i]))\nch=input().split()\nmax1=int(ch[0])\nfee=int(ch[1])\na.sort(reverse=True)\nresult=0\nfor i in range(n):\n    if (a[i]<=max1):\n        break\n    k=a[i]+fee\n    result+=(math.ceil(k/(fee+max1)))-1\nprint (result*fee)", "import math\nn=int(input())\na=[int(s) for s in input().split()]\nx,f=map(int,input().split())\nans=0\nfor i in range(n):\n    if a[i]<=x:\n        continue\n    if a[i]//(x+f)>0:\n        ans+=(a[i]//(x+f))*f\n        a[i]-=a[i]//(x+f)*(x+f)\n        if a[i]<=x:\n            continue        \n        ans+=a[i]//x*f\n    else:\n        ans+=a[i]//x*f\nprint(ans)", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [int(x) for x in input().split()]\nx, f = map(int, input().split())\nk = 0\nfor i in range(n):\n    if a[i] >= x + f:\n        k += a[i]//(x + f)\n        if a[i] % (x + f) > x:\n            k += 1\n    elif x < a[i] < x + f:\n        k += 1\nprint(k*f)", "import math\ninput()\t\na=list(map(int,input().split()))\nx,y=list(map(int,input().split()))\ns=0\nfor i in a:\n\tif i>x:\n\t\ts+=math.ceil((i-x)/(x+y))\nprint(int(s*y))\t\n", "import math\ndef round_school(x):\n    i, f = divmod(x, 1)\n    return int(i + ((f >= 0.5) if (x > 0) else (f > 0.5)))\nline1 = input()\nline2 = input()\nline3 = input()\naddrs = list()\ncount = int(line1.strip())\nfor elem in line2.split():\n    addrs.append(int(elem))\n#addrs = list(map(int, line2.split()))\nintline3 = list(map(int, line3.split()))\nmaxaddr  = intline3[0]\nfees = intline3[1]\n#print(str(count))\n#print(str(addrs))\n#print(str(maxaddr))\n#print(str(fees))\nidx = 0\ns2 = 0\ntransactions = 0\nval = 0.0\ninitiallen = len(addrs)\nwhile(idx < initiallen):\n    if(( addrs[idx] > maxaddr) and ( addrs[idx] <= (maxaddr + fees))):\n        transactions = transactions + 1\n        #continue\n    elif( ( addrs[idx] > (maxaddr + fees)) and ( addrs[idx] <= (2*maxaddr + fees))):\n        transactions = transactions + 1\n        #continue\n    elif( addrs[idx] > (2*maxaddr+fees)):        \n        mult = int(math.floor(addrs[idx]/(maxaddr + fees)))\n        transactions = transactions + mult\n        val = addrs[idx] - mult * (maxaddr + fees) \n        if(val > maxaddr):\n            #if( val > (maxaddr + fees)):\n            if(val > (2 + fees)):\n                transactions = transactions + 1                    \n    idx = idx + 1               \n\nprint(transactions*fees)\n    \n\n", "import math\nn=input()\na=list(map(int,input().split()))\nx,f=list(map(int,input().split()))\nans=0\nfor i in a:\n\tif i>x:\n\t\tans+= math.ceil((i-x)/(x+f))\n\nprint((ans)*f)\n", "import sys\nfrom sys import stdin,stdout\nn=int(stdin.readline())\ncoins=list(map(int,stdin.readline().split(' ')))\ncoins.sort()\nx,f=list(map(int,stdin.readline().split(' ')))\nflag1=True\nfor i in range(len(coins)):\n  if coins[i]>x:\n    coins=coins[i:];flag1=False\n    break\n\nif flag1:\n  coins=[]\nctr=0\n'''\nflag2=True\nfor i in range(len(coins)):\n  if coins[i]>sc:\n    coins=coins[i:]\n    ctr+=(i+1)\n    flag2=False\n    break\nif flag2:\n  ctr=len(coins)\n  coins=[]\n'''\n#print(coins)\ndef mainkaam(e):\n  nonlocal x,f\n  t1= e//(x+f)\n  t2=e%(x+f)\n  if t2>x:\n    return t1+1\n  else:\n    return t1\n\n\nfor i in coins:\n  #print(mainkaam(i),i)\n  ctr+=(mainkaam(i))\n\nprint(ctr*f)\n\n\n", "n = int(input())\ncoshelki = [int(i) for i in input().split()]\nx, f = (int(i) for i in input().split())\n\nsum = 0\nfor i in coshelki:\n    perevody = i // (x + f)\n    if i - perevody * (x + f) > x:\n        perevody += 1\n    sum += perevody\n\nprint(f * sum)", "def g(q, x, f, a):\n\tif(((a + q - 1) // q) - ((q - 1) * f) <= x):\n\t\treturn True\n\telse:\n\t\treturn False\n\ns = input()\nn = int(s)\n\n\ns = input()\ny = s.split()\n\ns = input()\ns = s.split()\n\nx = int(s[0])\nf = int(s[1])\n\nans = 0\n\nfor i in y:\n\tans += (int(i) + f - 1) // (x + f)\n\nprint(ans * f)", "import math\nNN = int(input())\nAI = list(map(int,input().split()))\nXX,FF = list(map(int,input().split()))\nlength = len(AI)\nextra = 0\nfor xx in AI:\n    if xx>XX:\n        extra+=math.ceil((xx-XX)/(XX+FF))\nprint(extra*FF)\n"]
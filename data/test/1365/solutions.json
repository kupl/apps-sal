["def main():\n    n, k = list(map(int, input().split()))\n    cnt = [[[0] * 21 for _ in (0, 1)] for _ in range(n + 1)]\n    edges, mod = [[] for _ in range(n + 1)], 1000000007\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def dfs(u, f):\n        cnt[u][0][0] = cnt[u][1][k] = 1\n        for v in edges[u]:\n            if v != f:\n                dfs(v, u)\n                tmp0, tmp1 = [0] * 21, [0] * 21\n                for i in range(k + 1):\n                    for j in range(k + 1):\n                        if i != k:\n                            tmp0[j if i < j else i + 1] += cnt[u][0][j] * cnt[v][0][i]\n                        if i < j:\n                            tmp1[j] += cnt[u][1][j] * cnt[v][0][i]\n                        elif i != k:\n                            tmp0[i + 1] += cnt[u][1][j] * cnt[v][0][i]\n                        if i > j:\n                            tmp1[i - 1] += cnt[u][0][j] * cnt[v][1][i]\n                        else:\n                            tmp0[j] += cnt[u][0][j] * cnt[v][1][i]\n                        tmp1[max(i - 1, j)] += cnt[u][1][j] * cnt[v][1][i]\n                for i in range(21):\n                    tmp0[i] %= mod\n                    tmp1[i] %= mod\n                cnt[u][0] = tmp0\n                cnt[u][1] = tmp1\n\n    dfs(1, 1)\n    print(sum(cnt[1][1][j] for j in range(k + 1)) % mod)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = map(int,input().split())\n\nedge_to = [0 for i in range(n*2+1)]\nedge_next = [0 for i in range(n*2+1)]\nson = [0 for i in range(n+1)]\n\ndef add_edge(u,v):\n    nonlocal  edge_next,edge_to,son,tot;\n    tot += 1;   edge_to[tot] = v;  edge_next[tot] = son[u];  son[u] = tot;\ntot = 0;    MOD = 10**9+7\ndp = [[0]*(m*2+2) for i in range(n+1)]\n\ndef dp_tree(x,fa):\n    nonlocal  edge_next,edge_to,m,son,dp;\n    dp[x][0]= 1;    dp[x][m+1] = 1;\n    f = [0 for i in range(m*2+2)]\n    i = son[x]\n    while (i):\n        f = [0 for w in range(m*2+2)]\n        to = edge_to[i]\n        i = edge_next[i]\n        if (to == fa): continue;\n        dp_tree(to,x)\n        for j in range(2*m+2):\n            for k in range(2*m+1):\n                if (j+k <= 2*m):    f[min(j,k+1)] += (dp[x][j]*dp[to][k])%MOD; f[min(j,k+1)] %= MOD;\n                else : f[max(j,k+1)] += (dp[x][j]*dp[to][k])%MOD;   f[max(j,k+1)] %= MOD;\n        dp[x] = f\n\nfor i in range(n-1):\n    u,v = map(int,input().split())\n    add_edge(u,v);  add_edge(v,u);\n\ndp_tree(1,-1)\nres = 0\nfor i in range(m+1):\n    res += dp[1][i];\n    res %= MOD;\nprint(res)"]
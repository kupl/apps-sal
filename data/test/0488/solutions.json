["s = input()\n\ncur_len = 1\na = []\nchar = []\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]: cur_len += 1\n    else:\n      a.append(cur_len)\n      char.append(s[i-1])\n      cur_len = 1\n      \na.append(cur_len)\nchar.append(s[len(s)-1])\n\nans = 0\nwhile len(a) > 1:\n    n = len(a)\n    inner_min = 100000000\n    for i in range(1,n-1):\n        if a[i] < inner_min: inner_min = a[i]\n        \n    k = min(a[0], a[n-1],(inner_min + 1)//2)\n    #print(\"a: \", a, \"; k = \", k)\n    b = []\n    new_char = []\n    for i in range(n):\n        if i == 0 or i == n-1:\n            if a[i] > k:\n                b.append(a[i]-k)\n                new_char.append(char[i])\n        else:\n            if a[i] > 2*k:\n                b.append(a[i] - 2*k)\n                new_char.append(char[i])\n##    print(b)\n    ans += k\n    if len(b) > 1:\n        c = [0]*n\n        newnew_char = [new_char[0]]\n        count = 0\n    \n        for i in range(0,len(b)-1):\n            c[count] += b[i]\n            if new_char[i] == new_char[i+1]: continue\n            else:\n                count += 1\n                newnew_char.append(new_char[i+1])\n        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]\n        else:\n            #count += 1\n            newnew_char.append(new_char[i+1])\n            c[count] = b[len(b)-1]\n        a = c[:count+1]\n        char = newnew_char[:]\n    else:\n        a = b[:]\n\nprint(ans)\n        \n", "name = input()\n\nblocks = []\nnow = name[0]\ncounter = 1\nfor x in range(1, len(name)):\n    if name[x] != now:\n        blocks.append((now, counter))\n        now = name[x]\n        counter = 1\n    else:\n        counter += 1\nblocks.append((now, counter))\n\ncounter = 0\ntemp = []\nwhile len(blocks) > 1:\n    counter += 1\n    temp = []\n    (x, y) = blocks[0]\n    if y > 1:\n        temp.append((x, y - 1))\n    for s in range(1, len(blocks) - 1):\n        (x, y) = blocks[s]\n        if len(temp) > 0:\n            (tempx, tempy) = temp[-1]\n            if y > 2:\n                if x != tempx:\n                    temp.append((x, y - 2))\n                else:\n                    temp[-1] = (x, tempy + y - 2)\n        else:\n            if y > 2:\n                temp.append((x, y - 2))\n\n    (x, y) = blocks[-1]\n    if len(temp) > 0:\n        (tempx, tempy) = temp[-1]\n        if y > 1:\n            if x != tempx:\n                temp.append((x, y - 1))\n            else:\n                temp[-1] = (x, tempy + y - 1)\n    else:\n        if y > 1:\n            temp.append((x, y - 1))\n    blocks = temp\n\nprint(counter)\n", "import sys\nsys.setrecursionlimit(1000000)\nread = sys.stdin.readline\n\npoints = read().strip()\n\nlst = [[points[0], 1]]\n\nfor p in points[1:]:\n    if p == lst[-1][0]:\n        lst[-1][1] += 1\n    else:\n        lst += [[p, 1]]\nans = 0\nwhile len(lst) > 1:\n    ans += 1\n    tmp = []\n    if lst[0][1] > 1:\n        tmp.append([lst[0][0], lst[0][1]-1])\n    for i in lst[1:-1]:\n        if i[1] > 2:\n            if len(tmp) == 0 or tmp[-1][0] != i[0]:\n                tmp.append([i[0], i[1]-2])\n            else:\n                tmp[-1][1] += i[1] - 2\n    if lst[-1][1] > 1:\n        if len(tmp) == 0 or lst[-1][0] != tmp[-1][0]:\n            tmp.append([lst[-1][0], lst[-1][1]-1])\n        else:\n            tmp[-1][1] += lst[-1][1]-1\n    lst = tmp\n\nprint(ans)", "import sys\nfrom collections import defaultdict as di\ncolor = input()\nn = len(color)\n\nlnei = [-1]*n\nrnei = [-1]*n\nto_be_deleted = []\ndeleted = [False]*n\niters = 0\n\nfor i in range(n):\n    if i-1>=0:\n        lnei[i]=i-1\n        if color[i]!=color[i-1]:\n            to_be_deleted.append(i)\n    if i+1<n:\n        rnei[i]=i+1\n        if color[i]!=color[i+1]:\n            to_be_deleted.append(i)\n\nif len(to_be_deleted)==0:\n    print(0)\n    return\n\nwhile True:\n    was_deleted = False\n\n    pot_sui = []\n    for node in to_be_deleted:\n        if deleted[node]:\n            continue\n        was_deleted=True\n        deleted[node]=True\n        \n        if rnei[node]!=-1:\n            lnei[rnei[node]]=lnei[node]\n            pot_sui.append(rnei[node])\n\n        if lnei[node]!=-1:\n            rnei[lnei[node]]=rnei[node]\n            pot_sui.append(lnei[node])\n    \n    \n    to_be_deleted=[]\n    for node in pot_sui:\n        if deleted[node]:\n            continue\n        if lnei[node]!=-1 and color[node]!=color[lnei[node]]:\n            to_be_deleted.append(node)\n        elif rnei[node]!=-1 and color[node]!=color[rnei[node]]:\n            to_be_deleted.append(node)\n    if not was_deleted:\n        break\n    iters += 1\n\nprint(iters)\n", "s = input()\nn = 1\n    \nfor i in range(1, len(s)):\n  if s[i] != s[i-1]:\n    n += 1\n\nmas = [0] * n\ncol = [0] * n\n\ncount = 1\nidx = 0\nc = s[0]\nfor i in range(1, len(s)):\n  if s[i] == s[i-1]:\n    count += 1\n  else:\n    mas[idx] = count\n    col[idx] = c\n    idx += 1\n    count = 1\n    c = s[i]\n    \nmas[idx] = count\ncol[idx] = c\n\nres = 0\n\nwhile n > 1:\n  newlen = n\n  idx = -1\n      \n  for i in range(0, n):\n    if (i == 0) or (i == n - 1):\n      mas[i] -= 1\n    elif mas[i] >= 2:\n      mas[i] -= 2\n    else:\n      mas[i] = 0\n      \n    if mas[i] == 0:\n      newlen -= 1\n    else:\n      if idx >= 0 and col[idx] == col[i]:\n        mas[idx] += mas[i]\n        newlen -= 1\n      else:\n        idx += 1\n        mas[idx] = mas[i]\n        col[idx] = col[i] \n        type = i % 2\n        \n  n = newlen\n  res += 1\n\nprint(res)", "s=input()\na=[[s[0],1]]\n\nfor i in s[1:]:\n    if(a[-1][0]==i):\n        a[-1][1]+=1\n    else:\n        a.append([i,1])\nturns=0\nwhile((len(a)>1)):\n    turns+=1\n    temp=[]\n    if(a[0][1]>1):\n        temp.append([a[0][0],a[0][1]-1])\n    for i in a[1:-1]:\n        if(i[1]>2):\n            temp.append([i[0],i[1]-2])\n    if(a[-1][1]>1):\n        temp.append([a[-1][0],a[-1][1]-1])\n    if(len(temp)<2):\n        break\n    a=[temp[0],]\n    for i in temp[1:]:\n        if(i[0]!=a[-1][0]):\n            a.append(i)\n        else:\n            a[-1][1]+=i[1]\nprint(turns)", "s=input()\na=[[s[0],1]]\n\nfor i in s[1:]:\n    if(a[-1][0]==i):\n        a[-1][1]+=1\n    else:\n        a.append([i,1])\nturns=0\nwhile((len(a)>1)):\n    turns+=1\n    temp=[]\n    if(a[0][1]>1):\n        temp.append([a[0][0],a[0][1]-1])\n    for i in a[1:-1]:\n        if(i[1]>2):\n            temp.append([i[0],i[1]-2])\n    if(a[-1][1]>1):\n        temp.append([a[-1][0],a[-1][1]-1])\n    if(len(temp)<2):\n        break\n    a=[temp[0],]\n    for i in temp[1:]:\n        if(i[0]!=a[-1][0]):\n            a.append(i)\n        else:\n            a[-1][1]+=i[1]\nprint(turns)", "s=input()\na=[[s[0],1]]\n\nfor i in s[1:]:\n    if(a[-1][0]==i):\n        a[-1][1]+=1\n    else:\n        a.append([i,1])\nturns=0\nwhile((len(a)>1)):\n    turns+=1\n    temp=[]\n    if(a[0][1]>1):\n        temp.append([a[0][0],a[0][1]-1])\n    for i in a[1:-1]:\n        if(i[1]>2):\n            temp.append([i[0],i[1]-2])\n    if(a[-1][1]>1):\n        temp.append([a[-1][0],a[-1][1]-1])\n    if(len(temp)<2):\n        break\n    a=[temp[0],]\n    for i in temp[1:]:\n        if(i[0]!=a[-1][0]):\n            a.append(i)\n        else:\n            a[-1][1]+=i[1]\nprint(turns)", "# https://codeforces.com/problemset/problem/909/D\ndef process(a):\n    assert len(a) >= 2\n    \n    n    = len(a)\n    min_ = float('inf')\n\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            min_ = min(min_, cnt)\n        else:\n            min_ = min(min_, (cnt+1) //2) \n    \n    b    = []\n    for i, [cnt, c] in enumerate(a):\n        if i == 0 or i == n-1:\n            remain = cnt - min_\n        else:\n            remain = cnt - min_ * 2\n        \n        if remain <= 0:\n            continue\n        \n        if len(b) == 0 or c != b[-1][1]:\n            b.append([remain, c])\n        else:\n            pre_cnt, pre_c  = b.pop()\n            b.append([pre_cnt+remain, c])\n    \n    return b, min_        \n\nS   = input() + ' '\ncur = []\n\ncnt = 0\npre = ''\nfor x in S:\n    if cnt == 0:\n        cnt+= 1\n        pre = x\n    elif x!=pre:\n        cur.append([cnt, pre])\n        cnt = 1\n        pre = x\n    else:\n        cnt+=1\n\ncnt = 0\nwhile len(cur) not in [0, 1]: \n    cur, min_ = process(cur)\n    cnt+=min_\n    \nprint(cnt)    "]
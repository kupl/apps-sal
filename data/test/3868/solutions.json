["N,M,K = map(int,input().split())\n\nINF = 10**6+1\nfrom collections import defaultdict\n\nincoming = defaultdict(list)\noutgoing = defaultdict(list)\n\nfor _ in range(M):\n  d,f,t,c = map(int,input().split())\n  if t == 0:\n    incoming[d].append((c,f-1))\n  if f == 0:\n    outgoing[d].append((c,t-1))\n\nincoming_dates = sorted(incoming.keys())\noutgoing_dates = sorted(outgoing.keys(),reverse=True)\n\n\n\nLi = []\nmark = [False]*N\ncnt = 0\ncosts = [0]*N\ntotal_cost = 0\n\nfor d in incoming_dates:\n  for c,x in incoming[d]:\n    if mark[x]:\n      if costs[x] > c:\n        total_cost += c-costs[x]\n        costs[x] = c\n    else:\n      mark[x] = True\n      cnt += 1\n      costs[x] = c\n      total_cost += c\n\n  if cnt == N:\n    Li.append((d,total_cost))\n\n\nLo = []\nmark = [False]*N\ncnt = 0\ncosts = [0]*N\ntotal_cost = 0\n\nfor d in outgoing_dates:\n  for c,x in outgoing[d]:\n    if mark[x]:\n      if costs[x] > c:\n        total_cost += c-costs[x]\n        costs[x] = c\n    else:\n      mark[x] = True\n      cnt += 1\n      costs[x] = c\n      total_cost += c\n\n  if cnt == N:\n    Lo.append((d,total_cost))\n\nLo.reverse()\n\n\nif not Li or not Lo:\n  print(-1)\n  return\n\n\n# print(Li,Lo)\n\nfrom bisect import bisect\n\nbest = float('inf')\n\nfor d,c in Li:\n  i = bisect(Lo,(d+K+1,0))\n  if i >= len(Lo):\n    break\n  else:\n    best = min(best,c+Lo[i][1])\n\nif best == float('inf'):\n  print(-1)\nelse:\n  print(best)", "def main():\n    n, m, k = list(map(int, input().split()))\n    ff, tt = [], []\n    for _ in range(m):\n        d, f, t, c = list(map(int, input().split()))\n        if f:\n            ff.append((d, f, c))\n        else:\n            tt.append((-d, t, c))\n    for ft in ff, tt:\n        cnt, costs = n, [1000001] * (n + 1)\n        ft.sort(reverse=True)\n        while ft:\n            day, city, cost = ft.pop()\n            oldcost = costs[city]\n            if oldcost > cost:\n                costs[city] = cost\n                if oldcost == 1000001:\n                    cnt -= 1\n                    if not cnt:\n                        break\n        else:\n            print(-1)\n            return\n        total = sum(costs) - 1000001\n        l = [(day, total)]\n        while ft:\n            day, city, cost = ft.pop()\n            oldcost = costs[city]\n            if oldcost > cost:\n                total -= oldcost - cost\n                costs[city] = cost\n                if l[-1][0] == day:\n                    l[-1] = (day, total)\n                else:\n                    l.append((day, total))\n        if ft is ff:\n            ff = l\n        else:\n            tt = l\n    l, k = [], -k\n    d, c = tt.pop()\n    try:\n        for day, cost in ff:\n            while d + day >= k:\n                d, c = tt.pop()\n            if d + day < k:\n                l.append(c + cost)\n    except IndexError:\n        pass\n    print(min(l, default=-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "g = lambda: map(int, input().split())\nn, m, k = g()\nF, T = [], []\ne = int(3e11)\n\nfor i in range(m):\n    d, f, t, c = g()\n    if f: F.append((d, f, c))\n    else: T.append((-d, t, c))\n\nfor p in [F, T]:\n    C = [e] * (n + 1)\n    s = n * e\n    q = []\n\n    p.sort()\n    for d, t, c in p:\n        if C[t] > c:\n            s += c - C[t]\n            C[t] = c\n            if s < e: q.append((s, d))\n    p.clear()\n    p += q\n\ns, t = e, (0, 0)\nfor f in F:\n    while f:\n        if t[1] + f[1] + k < 0: s = min(s, f[0] + t[0])\n        elif T:\n            t = T.pop()\n            continue\n        f = 0\n\nprint(s if s < e else -1)", "R=lambda :list(map(int,input().split()))\nn,m,k=R()\nF,T=[],[]\nans=int(1e12)\nfor i in range(m):\n    d,f,t,c=R()\n    if f:F.append((d,f,c))\n    else:T.append((-d,t,c))\nfor p in [F,T]:\n    cost=[ans]*(n+1)\n    s=n*ans\n    q=[]\n    p.sort()\n    for d,t,c in p:\n        #print(p)\n        if c<cost[t]:\n            #print(c,cost[t])\n            s+=c-cost[t]\n            #print(s)\n            cost[t]=c\n            if s<ans:\n                q.append((s,d))\n    p.clear()\n    #print(q)\n    p+=q\n    #print(p)\ns,t=ans,(0,0)\n#print(F,T)\nfor f in F:\n    while  f:\n        if f[1]+t[1]+k<0:s=min(s,f[0]+t[0])\n        elif T:\n            #print(T)\n            t=T.pop()\n            #print(T)\n           # print(t)\n            continue\n        #print(f)\n        f=0\n        #print(f)\nprint(s if s<ans else -1)\n", "R=lambda :list(map(int,input().split()))\n\nn,m,k=R()\n\nF,T=[],[]\n\nans=int(1e12)\n\nfor i in range(m):\n\n    d,f,t,c=R()\n\n    if f:F.append((d,f,c))\n\n    else:T.append((-d,t,c))\n\nfor p in [F,T]:\n\n    cost=[ans]*(n+1)\n\n    s=n*ans\n\n    q=[]\n\n    p.sort()\n\n    for d,t,c in p:\n\n        #print(p)\n\n        if c<cost[t]:\n\n            #print(c,cost[t])\n\n            s+=c-cost[t]\n\n            #print(s)\n\n            cost[t]=c\n\n            if s<ans:\n\n                q.append((s,d))\n\n    p.clear()\n\n    #print(q)\n\n    p+=q\n\n    #print(p)\n\ns,t=ans,(0,0)\n\n#print(F,T)\n\nfor f in F:\n\n    while  f:\n\n        if f[1]+t[1]+k<0:s=min(s,f[0]+t[0])\n\n        elif T:\n\n            #print(T)\n\n            t=T.pop()\n\n            #print(T)\n\n           # print(t)\n\n            continue\n\n        #print(f)\n\n        f=0\n\n        #print(f)\n\nprint(s if s<ans else -1)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "g = lambda: map(int, input().split())\nn, m, k = g()\nF, T = [], []\ne = int(3e11)\n\nfor i in range(m):\n    d, f, t, c = g()\n    if f: F.append((d, f, c))\n    else: T.append((-d, t, c))\n\nfor p in [F, T]:\n    C = [e] * (n + 1)\n    s = n * e\n    q = []\n\n    p.sort()\n    for d, t, c in p:\n        if C[t] > c:\n            s += c - C[t]\n            C[t] = c\n            if s < e: q.append((s, d))\n    p.clear()\n    p += q\n\ns, t = e, (0, 0)\nfor f in F:\n    while f:\n        if t[1] + f[1] + k < 0: s = min(s, f[0] + t[0])\n        elif T:\n            t = T.pop()\n            continue\n        f = 0\n\nprint(s if s < e else -1)", "from bisect import *\nfrom sys import *\nn,m,k=[int(i) for i in input().split()]\npln=[]\nif m==0:\n    print(-1)\n    return\nfor i in range(m):\n    pln.append([int(i) for i in input().split()])\npln.sort()\n\ngrp=[[pln[0]]];gt=0;\nfor i in range(1,m):\n    if pln[i][0]!=pln[i-1][0]:\n        gt=gt+1\n        grp.append([])\n    grp[gt].append(pln[i])\nxx=[]\nfor i in range(len(grp)):\n    xx.append(grp[i][0][0])\n#print('grp',grp)\n#print('xx',xx)\n\nfrom math import inf\npre=[0]*len(xx)\nct=0 \nmincost=[inf]*(n+1);sumcost=inf\nfor i,x in enumerate(grp):\n    for di,fi,ti,ci in x:\n        if ti==0:\n            if mincost[fi]==inf:\n                ct+=1\n            if sumcost==inf:\n                mincost[fi]=min(mincost[fi],ci)\n            else:\n                sumcost=sumcost-mincost[fi]\n                mincost[fi]=min(mincost[fi],ci)\n                sumcost=sumcost+mincost[fi]\n    if ct==n and sumcost==inf:\n        sumcost=sum(mincost[1:])\n    pre[i]=sumcost\n#print(pre)\n\nsa=[0]*len(xx)\nct=0 \nmincost=[inf]*(n+1);sumcost=inf\ngrp.reverse()\nfor i,x in enumerate(grp):\n    for di,fi,ti,ci in x:\n        if fi==0:\n            if mincost[ti]==inf:\n                ct+=1\n            if sumcost==inf:\n                mincost[ti]=min(mincost[ti],ci)\n            else:\n                sumcost=sumcost-mincost[ti]\n                mincost[ti]=min(mincost[ti],ci)\n                sumcost=sumcost+mincost[ti]\n    if ct==n and sumcost==inf:\n        sumcost=sum(mincost[1:])\n    sa[i]=sumcost\nsa.reverse()\n#print(sa)\n\nans=inf\nfor l,xxi in enumerate(xx):\n    r=bisect_right(xx,xxi+k)\n    ansl=pre[l]\n    ansr= inf if r==len(xx) else sa[r]\n    ans=min(ans,ansl+ansr)\nprint(ans) if ans!=inf else print(-1)\n        \n            \n"]
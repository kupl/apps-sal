["import collections\nN, M, K = map(int, input().split())\nfriend = [[] for i in range(N)]\nblock = [[] for i in range(N)]\ngraph = [-1] * N\nfor i in range(M):\n  a, b = map(int, input().split())\n  friend[a-1].append(b-1)\n  friend[b-1].append(a-1)\n  \nfor i in range(K):\n  c, d = map(int, input().split())\n  block[c-1].append(d-1)\n  block[d-1].append(c-1)\n  \n#print(friend, block)\n\nused = [True] * N\nfor i in range(N):\n  if used[i]:\n    q = [i]\n    used[i] = False\n    graph[i] = i\n    while q:\n      now = q.pop()\n      for j in friend[now]:\n        if used[j]:\n          graph[j] = graph[now]\n          q.append(j)\n          used[j] = False\n          \n          \n#print(graph)          \ngg = dict(collections.Counter(graph))  \n#print(gg)\n\nfor i in range(N):\n  nn = graph[i]\n  size = gg[nn]\n  ans = size - 1\n  for j in friend[i]:\n    if nn == graph[j]:\n      ans -= 1\n  for j in block[i]:\n    if nn == graph[j]:\n      ans -= 1\n  print(ans, end = \" \")\n\n\n", "from collections import deque\nN, M, K = map(int, input().split())\n\nflst = []\nblst = []\nglooplst = [i for i in range(N+1)]\ncolorlst = [0]*(N+1)\ncountlst = [0]*(N+1)\nanslst = [0]*(N+1)\nd = deque()\n\nfor i in range(N+1):\n    flst.append([])\n    blst.append([])\n\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    flst[a].append(b) \n    flst[b].append(a)\n\n\nfor i in range(K):\n    a, b = map(int, input().split())\n    blst[a].append(b)\n    blst[b].append(a)\n\n\nfor i in range(1, N+1):\n    if colorlst[i] == 0:\n        d.append(i)\n        colorlst[i] = 1\n        countlst[i] += 1\n        while d:\n            now = d.popleft()\n            for j in flst[now]:\n                if colorlst[j] == 0:\n                    d.append(j)\n                    colorlst[j] = 1\n                    glooplst[j] = i\n                    countlst[i] += 1\n\nfor i in range(1, N+1):\n    cnt = countlst[glooplst[i]] - len(flst[i]) -1\n    for j in blst[i]:\n        if glooplst[i] == glooplst[j]:\n            cnt -= 1\n\n    print(cnt, end=' ')\n\nprint()\n", "def LI():\n    return list(map(int, input().split()))\n\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return False\n    else:\n        if par[x] > par[y]:\n            x, y = y, x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n\ndef same(x, y):\n    return find(x) == find(y)\n\n\ndef size(x):\n    return -par[find(x)]\n\n\nN, M, K = LI()\npar = [-1]*N\nnot_kouho = [[] for _ in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    unite(a - 1, b - 1)\n    not_kouho[a-1].append(b-1)\n    not_kouho[b-1].append(a-1)\n\nfor i in range(K):\n    a, b = map(int, input().split())\n    if same(a-1, b-1):\n        not_kouho[a-1].append(b-1)\n        not_kouho[b-1].append(a-1)\n\nfor i in range(N):\n    print(size(i)-len(not_kouho[i])-1, end=\" \")\n", "class UnionFind:\n    def __init__(self, N):\n        self.N = N\n\n        # the parent of all node is itself\n        # self.parent = list(range(N))\n        self.parent = [-1] * N\n\n    def root(self, i):\n        if self.parent[i] < 0:\n            return i\n\n        r = self.root(self.parent[i])\n        self.parent[i] = r\n        return r\n\n    def unite(self, i, j):\n        i = self.root(i)\n        j = self.root(j)\n\n        if i == j:\n            return\n\n        if i > j:\n            i, j = j, i\n\n        self.parent[i] += self.parent[j]\n        self.parent[j] = i\n        # print(self.parent)\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n    def size(self, i):\n        return -self.parent[self.root(i)]\n\n    def roots(self):\n        return [self.root(i) for i in range(self.N)]\n\n    def groupcount(self):\n        return len(set(self.roots()))\n\nN, M, K = map(int, input().split())\n\nnotfriend = [set() for _ in range(N)]\nforest = UnionFind(N)\n\n# friend\nfor i in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    notfriend[a].add(b)\n    notfriend[b].add(a)\n\n    forest.unite(a, b)\n\n# block\nfor i in range(K):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    if forest.same(a, b):\n        notfriend[a].add(b)\n        notfriend[b].add(a)\n\nans = ' '.join([str(forest.size(i) - 1 - len(notfriend[i])) for i in range(N)])\nprint(ans)", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n  \n  def size(self, x):\n    return -self.parents[self.find(x)]\n  \n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n  \n  def members(self, x):\n    root = self.find(x)\n    return set([i for i in range(self.n) if self.find(i) == root])\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n      \n  def group_count(self):\n    return len(self.roots())\n\nn, m, k = list(map(int, input().split()))\n#\u96c6\u5408\u3067\u898b\u3066\u3044\u304f\u306e\u304c\u4e00\u756a\u901f\u3044\u306e\u3067unionfind\u3092\u6271\u3046\nfriend_un = UnionFind(n)\n#\u7b54\u3048\u7528\u306elist\nlst = [0] * n\nfor _ in range(m):\n  a, b = list(map(int, input().split()))\n  a -= 1\n  b -= 1\n  #\u53cb\u9054\u540c\u58eb\u3067\u540c\u3058\u96c6\u5408\u3092\u5f62\u6210\u3057\u3066\u3044\u304f\u3053\u3068\u3067\u3001\u6570\u306e\u96c6\u8a08\u304c\u697d\u306b\u306a\u308b\n  friend_un.union(a, b)\n  #\u53cb\u9054\u5019\u88dc\u306b\u306f\u53cb\u9054\u540c\u58eb\u306f\u542b\u307e\u306a\u3044\u306e\u3067\u3001\u7b54\u3048\u7528\u306e\u30ea\u30b9\u30c8\u306b\u306f\u4e88\u30811\u6e1b\u3089\u3057\u3066\u304a\u304f\n  lst[a] -= 1\n  lst[b] -= 1\nfor _ in range(k):\n  a, b = list(map(int, input().split()))\n  a -= 1\n  b -= 1\n  #\u30d6\u30ed\u30c3\u30af\u540c\u58eb\u304c\u540c\u3058\u96c6\u5408\u5185\u306b\u3044\u305f\u5834\u5408\u3001\u3053\u308c\u3082\u53cb\u9054\u5019\u88dc\u306b\u306f\u542b\u3081\u306a\u3044\u306e\u3067\u7b54\u3048\u7528\u306e\u30ea\u30b9\u30c8\u306b\u306f1\u6e1b\u3089\u3057\u3066\u304a\u304f\n  if friend_un.same(a, b):\n    lst[a] -= 1\n    lst[b] -= 1\nfor i in range(n):\n  #\u81ea\u5206\u306e\u6570\u3082\u542b\u3081\u3066\u3044\u308b\u306e\u30671\u6e1b\u3089\u3057\u3066\u304a\u304f\n  lst[i] += friend_un.size(i) - 1\nprint((' '.join([str(i) for i in lst])))\n", "class UnionFind():\n  def __init__(self,n):\n    self.parents=[-1]*n\n   \n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    \n    if x==y:\n      return\n    \n    if self.parents[x] > self.parents[y]:\n      x,y=y,x\n      \n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n  \n  def size(self,x):\n    return self.parents[self.find(x)]\n\n\nN,M,K=map(int,input().split())\nuf=UnionFind(N+1)\nfriends={x:set() for x in range(1,N+1)}\nblocks={x:set() for x in range(1,N+1)}\nans=[N-1]*(N+1)\n\nfor _ in range(M):\n  A,B=map(int,input().split())\n  friends[A].add(B)\n  friends[B].add(A)\n  uf.union(A,B)\n\nfor _ in range(K):\n  C,D=map(int,input().split())\n  if uf.find(C)==uf.find(D):\n    blocks[C].add(D)\n    blocks[D].add(C)\n\nfor i in range(1,N+1):\n  if uf.size(i)==-1:\n    print(0)\n    continue\n  print(abs(uf.size(i))-len(friends[i])-len(blocks[i])-1,end=' ')", "import sys,collections\ninput = sys.stdin.readline\n\ndef main():\n    N,M,K = list(map(int,input().split()))\n    fr = [[] for i in range(N+1)]\n    bl = [[] for i in range(N+1)]\n\n          \n    for _ in range(M):\n        a,b = list(map(int,input().split()))\n        fr[a].append(b)\n        fr[b].append(a)\n    for _ in range(K):\n        c,d = list(map(int,input().split()))\n        bl[c].append(d)\n        bl[d].append(c)\n\n    fl = [-1 for i in range(N+1)]\n    fl[0] = 0\n    fl[1] = 1\n    nxt = 1\n    dic = {}\n    s = set(range(1,N+1))\n    while nxt != 0:\n        q = collections.deque([nxt])\n        \n        fl[nxt]=nxt\n        cnt = 0\n        while q:\n            now = q.popleft()\n            s.discard(now)\n            for f in fr[now]:\n                if fl[f] == -1:\n                    fl[f] = nxt\n                    cnt +=1\n                    q.append(f)\n        dic[nxt] = cnt\n        #try:\n            #nxt = fl.index(-1)\n        #except:\n            #nxt = 0\n        if len(s) == 0:\n            nxt = 0\n        else:\n            nxt = s.pop()\n\n\n    mbf = collections.deque()\n    for i in range(1,N+1):\n        ff = 0\n        for j in bl[i]:\n            if fl[j] == fl[i]:\n                ff -= 1\n        \n        ff += dic[fl[i]]-len(fr[i])\n        mbf.append(ff)\n    print((*mbf))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind:\n    def __init__(self, n: int) -> None:\n        self.forest = [-1] * n\n\n    def union(self, x: int, y: int) -> None:\n        x = self.findRoot(x)\n        y = self.findRoot(y)\n        if x == y:\n            return\n        if self.forest[x] > self.forest[y]:\n            x, y = y, x\n        self.forest[x] += self.forest[y]\n        self.forest[y] = x\n        return\n\n    def findRoot(self, x: int) -> int:\n        if self.forest[x] < 0:\n            return x\n        else:\n            self.forest[x] = self.findRoot(self.forest[x])\n            return self.forest[x]\n\n    def issame(self, x: int, y: int) -> bool:\n        return self.findRoot(x) == self.findRoot(y)\n\n    def size(self, x: int) -> int:\n        return -self.forest[self.findRoot(x)]\n\n\nn, m, k = list(map(int, input().split()))\nu = UnionFind(n)\ndire = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    dire[a - 1].append(b - 1)\n    dire[b - 1].append(a - 1)\n    u.union(a - 1, b - 1)\nfor i in range(k):\n    c, d = list(map(int, input().split()))\n    if u.issame(c-1,d-1):\n        dire[c - 1].append(d - 1)\n        dire[d - 1].append(c - 1)\n\nprint((*[u.size(i) - len(dire[i]) - 1 for i in range(n)]))\n", "N,M,K=map(int,input().split())\npar=[-1]*N\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    else:\n      if find(x)>find(y):x,y=y,x\n      par[x] += par[y]\n      par[y] = x\n      return True\nfrbl=[0]*N\nfor i in range(M):\n  a,b=sorted(map(int,input().split()))\n  unite(a-1,b-1)\n  frbl[a-1]+=1;frbl[b-1]+=1\nblock=[0]*N\nfor i in range(K):\n  c,d=sorted(map(int,input().split()))\n  if find(c-1)==find(d-1):\n    frbl[c-1]+=1;frbl[d-1]+=1\nlist=[]\nfor i in range(N):\n  list.append(max(-par[find(i)]-frbl[i]-1,0))\nprint(*list)", "f=lambda:map(int,input().split())\nn,m,k=f()\n\n# Union_Find\np=[-1]*n\ndef root(x):\n  while p[x]>=0: x=p[x]\n  return x\ndef unite(x,y):\n  x,y=root(x),root(y)\n  if x==y: return\n  if x>y: x,y=y,x\n  p[x]+=p[y]\n  p[y]=x\ndef same(x,y):\n  return root(x)==root(y)\ndef size(x):\n  return -p[root(x)]\n\nl=[-1]*n\nfor _ in range(m):\n  a,b=f()\n  unite(a-1,b-1)\n  l[a-1]-=1\n  l[b-1]-=1\nfor i in range(n):\n  l[i]+=size(i)\nfor _ in range(k):\n  c,d=f()\n  if same(c-1,d-1):\n    l[c-1]-=1\n    l[d-1]-=1\nprint(*l)", "n , m , k = list(map(int, input().split()))\n\nfriend = [[] for i in range(n)]\nblock = [[] for i in range(n)]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(n)\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a-=1\n    b-=1\n    uf.union(a,b)\n    friend[a].append(b)\n    friend[b].append(a)\n\nfor i in range(k):\n    c, d = list(map(int, input().split()))\n    c-=1\n    d-=1\n    block[c].append(d)\n    block[d].append(c)\n\nans=[]\n\nfor i in range(n):\n    ans1 = uf.size(i)-1\n    for j in block[i]:\n        if uf.same(i,j):\n            ans1-=1\n    ans1 -= len(friend[i])\n    ans.append(str(ans1))\n\nprint((' '.join(ans)))\n", "class UnionFind:\n    def __init__(self, numV):\n        self.pars = list(range(numV))\n        self.ranks = [0] * numV\n        self.sizes = [1] * numV\n    def getRoot(self, x):\n        par = self.pars[x]\n        if par != x:\n            self.pars[x] = par = self.getRoot(par)\n        return par\n    def merge(self, x, y):\n        x, y = self.getRoot(x), self.getRoot(y)\n        sx, sy = self.sizes[x], self.sizes[y]\n        if x == y: return (0, 0)\n        if self.ranks[x] < self.ranks[y]:\n            self.pars[x] = y\n            self.sizes[y] += sx\n        else:\n            self.pars[y] = x\n            self.sizes[x] += sy\n            if self.ranks[x] == self.ranks[y]:\n                self.ranks[x] += 1\n        return (sx, sy)\n    def isSame(self, x, y):\n        return self.getRoot(x) == self.getRoot(y)\n    def updatePars(self):\n        for v in range(len(self.pars)):\n            self.getRoot(v)\n    def getSize(self, x):\n        return self.sizes[self.getRoot(x)]\n\nn, m, k = map(int, input().split())\n\nuf = UnionFind(n)\nex = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    uf.merge(a,b)\n    ex[a].append(b)\n    ex[b].append(a)\n\nfor i in range(k):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    if uf.getRoot(c) == uf.getRoot(d):\n        ex[c].append(d)\n        ex[d].append(c)\n\n\nans = []\nfor i in range(n):\n    r = uf.getRoot(i)\n    ans.append(uf.sizes[r] - len(list(set(ex[i]))) - 1)\nans = [str(i) for i in ans]\nprint(' '.join(ans))", "import sys\nN, M, K = map(int, input().split())\nfriends = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, sys.stdin.readline().split())\n    friends[a-1].add(b-1)\n    friends[b-1].add(a-1)\nblocks = [set() for _ in range(N)]\nfor _ in range(K):\n    c, d = map(int, sys.stdin.readline().split())\n    blocks[c-1].add(d-1)\n    blocks[d-1].add(c-1)\n\ndone = set()\nchains = []\ntodo = []\nfor s in range(N):\n    if s in done:\n        continue\n    chain = set()\n    todo.append(s)\n    while todo:\n        i = todo.pop()\n        for ni in friends[i]:\n            if ni in done:\n                continue\n            done.add(ni)\n            chain.add(ni)\n            todo.append(ni)\n    chains.append(chain)\n\nans = [0] * N\nfor chain in chains:\n    for i in chain:\n        blocks[i].intersection_update(chain)\n        ans[i] = len(chain) - len(blocks[i]) - len(friends[i]) - 1\nprint(\" \".join(map(str, ans)))", "INT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef do():\n    n,m,k=INTM()\n    uf=UnionFind(n)\n    fri=[[] for i in range(n)]\n    blo=[[] for i in range(n)]\n    for i in range(m):\n        a,b=INTM()\n        a-=1\n        b-=1\n        fri[a].append(b)\n        fri[b].append(a)\n        uf.union(a,b)\n    for i in range(k):\n        c,d=INTM()\n        c-=1\n        d-=1\n        blo[c].append(d)\n        blo[d].append(c)\n\n    ans=[]\n\n    for i in range(n):\n        blos=0\n        for j in blo[i]:\n            if uf.same(i,j):\n                blos+=1\n        \n        ans.append(uf.size(i)-1-len(fri[i])-blos)\n    \n    print(*ans)\n\n\n\n\ndef __starting_point():\n    do()\n__starting_point()", "n,m,k = map(int,input().split())\nroot = [i for i in range(n)]\nheight = [1 for i in range(n)]\ndef find(n):\n  sn = n\n  while n != root[n]:\n    n = root[n]\n  root[sn] = n\n  return n\ndef union(a,b):\n  a = find(a)\n  b = find(b)\n  if a==b:\n    return\n  elif height[a]>=height[b]:\n    height[a] += height[b]\n    height[b] = 0\n    root[b] = a\n  else:\n    height[b] += height[a]\n    height[a] = 0\n    root[a] = b\nl = [set() for _ in range(n)]\nfor i in range(m):\n  a,b = map(lambda x:int(x)-1,input().split())\n  union(a,b)\n  l[a].add(b)\n  l[b].add(a)\nfor i in range(k):\n  a,b = map(lambda x:int(x)-1,input().split())\n  if find(a)==find(b):\n    l[a].add(b)\n    l[b].add(a)\nprint(*[height[find(i)]-len(l[i])-1 for i in range(n)])", "N,M,K=map(int,input().split())\npar=[0]*(N+1)\nnum=[0]*(N+1)\ngroup = [1]*(N+1)\n\nfor i in range(1,N+1): par[i]=i\n\ndef root(x):\n  if par[x]==x: return x\n  return root(par[x])\n\ndef union(x,y):\n  rx = root(x)\n  ry = root(y)\n  if rx==ry: return\n  par[max(rx,ry)] = min(rx,ry)\n  group[min(rx,ry)] += group[max(rx,ry)]\n\ndef same(x,y):\n  return root(x)==root(y)     \n\nfor _ in range(M):\n  a,b=map(int,input().split())\n  union(a,b)\n  num[a]+=1\n  num[b]+=1\nfor _ in range(K):\n  c,d=map(int,input().split())\n  if same(c,d):\n    num[c]+=1\n    num[d]+=1\n\nfor i in range(1,N+1):\n  print(group[root(i)]-num[i]-1,end=\" \")", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n        \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \nn,m,k=list(map(int,input().split()))\nuf=UnionFind(n)\nfc=[0]*n\nfor _ in range(m):\n  a,b=list(map(int,input().split()))\n  fc[a-1]-=1\n  fc[b-1]-=1\n  uf.union(a-1,b-1)\nfor _ in range(k):\n  c,d=list(map(int,input().split()))\n  if uf.same(c-1,d-1):\n    fc[c-1]-=1\n    fc[d-1]-=1\nfor i in range(n):\n  fc[i]+=uf.size(i)-1\nprint((\" \".join(list(map(str,fc)))))\n", "N, M, K = list(map(int, input().split()))\nfriend = [[] for _ in range(N+1)]\nblock = [[] for _ in range(N+1)]\n\nfor i in range(M):\n  A,B = list(map(int, input().split()))\n  friend[A].append(B)\n  friend[B].append(A)\n\nfor i in range(K):\n  C,D = list(map(int, input().split()))\n  block[C].append(D)\n  block[D].append(C)\n#print(friend)\n#print(block)\n\n#import queue\ngrouping = [False]*(N+1)\n#print(grouping)\ngrouping[0] = True\ngroup = [0]*(N+1)\ng_num = 0\ng_cnt = []\nfor i in range(1,N+1):\n  cnt = 0\n  if grouping[i] == True:\n    continue \n  group[i] = g_num\n  grouping[i] = True\n  #q = queue.Queue()\n  #q.put(i)\n  stack = [i]\n  #while not q.empty():\n  while len(stack)>0:\n    #print('v:',visited)\n    #p = q.get()\n    p = stack.pop()\n    for f in friend[p]:\n      #print(p,f)\n      if grouping[f]==False:\n        #q.put(f)\n        stack.append(f)\n        group[f]=g_num\n        grouping[f] =True\n        cnt += 1\n  g_num += 1\n  g_cnt.append(cnt)\n  #print('g:',grouping)\nans = []\nfor i in range(1,N+1):\n  c = g_cnt[group[i]]-len(friend[i])\n  for b in block[i]:\n    if group[b]==group[i]:\n      c -= 1\n  ans.append(c)\nprint((*ans))\n", "N,M,K=map(int,input().split())\npar=[0]*(N+1)\nnum=[0]*(N+1)\ngroup = [1]*(N+1)\n\nfor i in range(1,N+1): par[i]=i\n\ndef root(x):\n  if par[x]==x: return x\n  return root(par[x])\n\ndef union(x,y):\n  rx = root(x)\n  ry = root(y)\n  if rx==ry: return\n  par[max(rx,ry)] = min(rx,ry)\n  group[min(rx,ry)] += group[max(rx,ry)]\n\ndef same(x,y):\n  return root(x)==root(y)     \n\nfor _ in range(M):\n  a,b=map(int,input().split())\n  union(a,b)\n  num[a]+=1\n  num[b]+=1\nfor _ in range(K):\n  c,d=map(int,input().split())\n  if same(c,d):\n    num[c]+=1\n    num[d]+=1\n\nfor i in range(1,N+1):\n  print(group[root(i)]-num[i]-1,end=\" \")", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    \nn,m,k=map(int,input().split())\nuf=UnionFind(n)\nedge=[[] for _ in range(n)]\nbrock=[[] for _ in range(n)]\nans=[]\nfor _ in range(m):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n    uf.union(a-1,b-1)\nfor _ in range(k):\n    c,d=map(int,input().split())\n    brock[c-1].append(d-1)\n    brock[d-1].append(c-1)\nfor i in range(n):\n    ans.append(uf.size(i)-len(edge[i])-sum([uf.same(i,j) for j in brock[i]])-1)\nprint(*ans)", "class UnionFind():\n    def __init__(self, n):\t#\u521d\u671f\u5316\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\t\t#\u5c5e\u3059\u30b0\u30eb\u30fc\u30d7\u306e\u6839(\u30ea\u30fc\u30c0\u30fc)\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\t#\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\t\t#\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u9802\u70b9\u6570\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\t#x,y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def members(self, x):\t#\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u30e1\u30f3\u30d0\u30fc\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\t\t#\u5168\u3066\u306e\u6839(\u30ea\u30fc\u30c0\u30fc)\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\t#\u30b0\u30eb\u30fc\u30d7\u306e\u6570\n        return len(self.roots())\n    def all_group_members(self):#\u5168\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\t\t#\u6839\uff1a{\u6240\u5c5e\u3057\u3066\u3044\u308b\u30e1\u30f3\u30d0\u30fc}\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m,k = map(int,input().split())\nsuggest = UnionFind(n)\nfollow = [0]*n\nblock = [0]*n\nfor i in range(n):\n    follow[i] = list()\n    block[i]  = list()\nfor _ in range(m):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    suggest.union(a,b)\n    follow[a].append(b)\n    follow[b].append(a)\n\nfor _ in range(k):\n    c,d = map(int,input().split())\n    c -= 1\n    d -= 1\n    block[c].append(d)\n    block[d].append(c)\nans = \"\"\nsuggestfriend = [0]*n\nans = \"\"\nfor i in range(n):\n    blockperson = 0\n    union = suggest.size(i)\n    for j in range(len(block[i])):\n        if(suggest.same(i,block[i][j])):\n            blockperson += 1\n    ans += str(union - blockperson -len(follow[i]) - 1) + \" \"\nprint(ans)", "class Union_Find:\n  def __init__(self,n=0):\n    self.vertices=n\n    self.mother=[-1 for i in range(self.vertices)]\n    self.size_temp=[1 for i in range(self.vertices)]\n  \n  def root(self,x):\n    normalize_v=[]\n    while x!=-1:\n      normalize_v.append(x)\n      y=x\n      x=self.mother[x]\n    for i in normalize_v[:-1]:\n      self.mother[i]=y\n    return y\n  \n  def union(self,x,y):\n    root_x=self.root(x)\n    root_y=self.root(y)\n    if root_x!=root_y:\n      self.mother[root_x]=root_y\n      self.size_temp[root_y]+=self.size_temp[root_x]\n  \n  def find(self,x,y):\n    if self.root(x)==self.root(y):\n      return True\n    else:\n      return False\n  \n  def size(self,x):\n    return self.size_temp[self.root(x)]\n\n\n\nn,m,k=list(map(int,input().split()))\nuf=Union_Find(n)\nfriend=[0 for i in range(n)]\nblock=[[] for i in range(n)]\n\nfor i in range(m):\n  a,b=[int(x)-1 for x in input().split()]\n  friend[a]+=1\n  friend[b]+=1\n  uf.union(a,b)\n\nfor i in range(k):\n  a,b=[int(x)-1 for x in input().split()]\n  block[a].append(b)\n  block[b].append(a)\n\nr=\"\"\nfor i in range(n):\n  size=uf.size(i)\n  size-=friend[i]\n  for j in block[i]:\n    if uf.find(i,j):\n      size-=1\n  r+=str(size-1)+\" \"\nprint((r[:-1]))\n", "n, m, k = map(int, input().split())\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1 for i in range(self.n)]\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.par[p] += self.par[q]\n        self.par[q] = p\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.par[self.find(x)]\nUF = UnionFind(n)\nf_or_b = [0] * n\nfor i in range(m):\n    a, b = map(int, input().split())\n    UF.unite(a - 1, b - 1)\n    f_or_b[a - 1] += 1\n    f_or_b[b - 1] += 1\nfor i in range(k):\n    c, d = map(int, input().split())\n    if UF.same(c - 1, d - 1):\n        f_or_b[c - 1] += 1\n        f_or_b[d - 1] += 1\nfor i in range(n):\n    print(UF.size(i) - f_or_b[i] - 1, end=\" \")\n", "\"\"\"/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nUnion-Find\uff01Union-Find\uff01Union-Find\uff01Union-Find\u3045\u3045\u3046\u3046\u3046\u308f\u3041\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3093\uff01\uff01\uff01\n\u3042\u3041\u3042\u3042\u3042\u3042\u2026\u3042\u3042\u2026\u3042\u3063\u3042\u3063\u30fc\uff01\u3042\u3041\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\uff01Union-FindUnion-FindUnion-Find\u3045\u3046\u3046\u3041\u308f\u3041\u3042\u3042\u3042\u3042\uff01\uff01\uff01\n\u3042\u3041\u30af\u30f3\u30ab\u30af\u30f3\u30ab\uff01\u30af\u30f3\u30ab\u30af\u30f3\u30ab\uff01\u30b9\u30fc\u30cf\u30fc\u30b9\u30fc\u30cf\u30fc\uff01\u30b9\u30fc\u30cf\u30fc\u30b9\u30fc\u30cf\u30fc\uff01\u3044\u3044\u5302\u3044\u3060\u306a\u3041\u2026\u304f\u3093\u304f\u3093\n\u3093\u306f\u3041\u3063\uff01Union-Find\u305f\u3093\u306e\u6843\u8272\u30d6\u30ed\u30f3\u30c9\u306e\u9aea\u3092\u30af\u30f3\u30ab\u30af\u30f3\u30ab\u3057\u305f\u3044\u304a\uff01\u30af\u30f3\u30ab\u30af\u30f3\u30ab\uff01\u3042\u3041\u3042\uff01\uff01\n\u9593\u9055\u3048\u305f\uff01\u30e2\u30d5\u30e2\u30d5\u3057\u305f\u3044\u304a\uff01\u30e2\u30d5\u30e2\u30d5\uff01\u30e2\u30d5\u30e2\u30d5\uff01\u9aea\u9aea\u30e2\u30d5\u30e2\u30d5\uff01\u30ab\u30ea\u30ab\u30ea\u30e2\u30d5\u30e2\u30d5\u2026\u304d\u3085\u3093\u304d\u3085\u3093\u304d\u3085\u3044\uff01\uff01\n\u5c0f\u8aac12\u5dfb\u306eUnion-Find\u305f\u3093\u304b\u308f\u3044\u304b\u3063\u305f\u3088\u3045\uff01\uff01\u3042\u3041\u3041\u3042\u3042\u2026\u3042\u3042\u3042\u2026\u3042\u3063\u3042\u3041\u3042\u3042\u3042\u3042\uff01\uff01\u3075\u3041\u3041\u3042\u3042\u3042\u3093\u3093\u3063\uff01\uff01\n\u30a2\u30cb\u30e12\u671f\u653e\u9001\u3055\u308c\u3066\u826f\u304b\u3063\u305f\u306dUnion-Find\u305f\u3093\uff01\u3042\u3041\u3042\u3042\u3042\u3042\u3042\uff01\u304b\u308f\u3044\u3044\uff01Union-Find\u305f\u3093\uff01\u304b\u308f\u3044\u3044\uff01\u3042\u3063\u3042\u3042\u3041\u3042\u3042\uff01\n\u30b3\u30df\u30c3\u30af2\u5dfb\u3082\u767a\u58f2\u3055\u308c\u3066\u5b09\u3057\u2026\u3044\u3084\u3041\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\uff01\u306b\u3083\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3093\uff01\uff01\u304e\u3083\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\n\u3050\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\uff01\u30b3\u30df\u30c3\u30af\u306a\u3093\u3066\u73fe\u5b9f\u3058\u3083\u306a\u3044\uff01\uff01\uff01\uff01\u3042\u2026\u5c0f\u8aac\u3082\u30a2\u30cb\u30e1\u3082\u3088\u304f\u8003\u3048\u305f\u3089\u2026\nU n i o n - F i n d \u3061 \u3083 \u3093 \u306f \u73fe \u5b9f \u3058 \u3083 \u306a \u3044\uff1f\u306b\u3083\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3093\uff01\uff01\u3046\u3041\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\n\u305d\u3093\u306a\u3041\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\u3044\u3084\u3041\u3041\u3041\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\u306f\u3041\u3042\u3042\u3042\u3042\u3042\u3042\u3093\uff01\uff01\u3046\u3000\u3057\u3000\u305f\u3000\u3077\u3000\u306b\u3000\u304d\u3000\u3042\u3000\u738b\u3000\u56fd\u3000\u7b11\u3041\u3042\u3042\u3042\u3042\uff01\uff01\n\u3053\u306e\uff01\u3061\u304d\u3057\u3087\u30fc\uff01\u3084\u3081\u3066\u3084\u308b\uff01\uff01\u73fe\u5b9f\u306a\u3093\u304b\u3084\u3081\u2026\u3066\u2026\u3048\uff01\uff1f\u898b\u2026\u3066\u308b\uff1f\u8868\u7d19\u7d75\u306eUnion-Find\u3061\u3083\u3093\u304c\u50d5\u3092\u898b\u3066\u308b\uff1f\n\u8868\u7d19\u7d75\u306eUnion-Find\u3061\u3083\u3093\u304c\u50d5\u3092\u898b\u3066\u308b\u305e\uff01Union-Find\u3061\u3083\u3093\u304c\u50d5\u3092\u898b\u3066\u308b\u305e\uff01\u633f\u7d75\u306eUnion-Find\u3061\u3083\u3093\u304c\u50d5\u3092\u898b\u3066\u308b\u305e\uff01\uff01\n\u30a2\u30cb\u30e1\u306eUnion-Find\u3061\u3083\u3093\u304c\u50d5\u306b\u8a71\u3057\u304b\u3051\u3066\u308b\u305e\uff01\uff01\uff01\u3088\u304b\u3063\u305f\u2026\u4e16\u306e\u4e2d\u307e\u3060\u307e\u3060\u6368\u3066\u305f\u30e2\u30f3\u3058\u3083\u306a\u3044\u3093\u3060\u306d\u3063\uff01\n\u3044\u3084\u3063\u307b\u3049\u304a\u304a\u304a\u304a\u304a\u304a\u304a\uff01\uff01\uff01\u50d5\u306b\u306fUnion-Find\u3061\u3083\u3093\u304c\u3044\u308b\uff01\uff01\u3084\u3063\u305f\u3088default dict\uff01\uff01\u3072\u3068\u308a\u3067\u3067\u304d\u308b\u3082\u3093\uff01\uff01\uff01\n\u3042\u3001\u30b3\u30df\u30c3\u30af\u306eUnion-Find\u3061\u3083\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3093\uff01\uff01\u3044\u3084\u3041\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\uff01\uff01\n\u3042\u3063\u3042\u3093\u3042\u3042\u3063\u3042\u3042\u3093\u3042set\u69d8\u3041\u3042\uff01\uff01\u3055\u3001\u6700\u5c0f\u5168\u57df\u6728\u30fc\uff01\uff01Dijkstra\u3041\u3042\u3042\u3042\u3042\u3042\u3042\uff01\uff01\uff01\u30bb\u30b0\u6728\u3043\u3044\u3044\u3044\uff01\uff01\n\u3046\u3046\u3063\u3046\u3045\u3046\u3046\uff01\uff01\u4ffa\u306e\u60f3\u3044\u3088Union-Find\u3078\u5c4a\u3051\uff01\uff01\u3046\u3000\u3057\u3000\u305f\u3000\u3077\u3000\u306b\u3000\u304d\u3000\u3042\u3000\u738b\u3000\u56fd\u3000\u7b11\u306eUnion-Find\u3078\u5c4a\u3051\uff01\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\"\"\"\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.size = [1] * n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            self.size[y] += self.size[x]\n            self.parents[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,m,k=list(map(int,input().split()))\nuf=UnionFind(n)\nfriends=[0]*n\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    uf.union(a-1,b-1)\n    friends[a-1]+=1\n    friends[b-1]+=1\nblock=[[] for _ in range(n)]\nfor i in range(k):\n    c,d=list(map(int,input().split()))\n    block[c-1].append(d)\n    block[d-1].append(c)\nans=[0]*n\ncnt=[0]*n\nfor i in range(n):\n    cnt[i]=uf.find(i)\nfor i in range(n):\n    num1=uf.size[uf.find(i)]-friends[i]-1\n    num2=cnt[i]\n    for j in range(len(block[i])):\n        if num2==cnt[block[i][j]-1]:\n            num1-=1\n    ans[i]=num1\nprint((*ans))\n", "from sys import stdin\n\ndef getval():\n    n,m,k = map(int,stdin.readline().split())\n    a = [list(map(int,stdin.readline().split())) for i in range(m)]\n    c = [list(map(int,stdin.readline().split())) for i in range(k)]\n    return n,m,k,a,c \n\ndef main(n,m,k,a,c):\n    #Compute all members' friends\n    friends = [[] for i in range(n)]\n    for i in a:\n        friends[i[0]-1].append(i[1]-1)\n        friends[i[1]-1].append(i[0]-1)\n    \n    #Group all members in the isolated \"friend groups\"\n    frgroups = []\n    visited = [False for i in range(n)]\n    for i in range(n):\n        if visited[i]:\n            continue\n        q = [i]\n        temp = [i]\n        visited[i] = True\n        while q:\n            idx = q.pop(0)\n            adj = friends[idx]\n            for j in adj:\n                if visited[j]:\n                    continue\n                visited[j] = True\n                q.append(j)\n                temp.append(j)\n        frgroups.append(temp)    \n\n    #Number all members with their friend groups respectively\n    groups = [-1 for i in range(n)]\n    for i in range(len(frgroups)):\n        for j in frgroups[i]:\n            groups[j] = i \n            \n    #For each member, refer to the friend groups of blocked peope\n    #Compute ans accordingly\n    ans = [len(frgroups[groups[i]])-1-len(friends[i]) for i in range(n)]\n    for i in c:\n        if groups[i[0]-1]==groups[i[1]-1]:\n            ans[i[0]-1] -= 1\n            ans[i[1]-1] -= 1\n    s = str(ans[0])\n    for i in range(1,n):\n        s += \" \" + str(ans[i])\n    print(s)\n    \n\ndef __starting_point():\n    n,m,k,a,c = getval()\n    main(n,m,k,a,c)\n__starting_point()", "# UnionFind: https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * (n + 1)\n        \n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.root[x] > self.root[y]:\n            x, y = y, x\n        self.root[x] += self.root[y]\n        self.root[y] = x\n        \n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def size(self, x):\n        return -self.root[self.find(x)]\n    \nn, m, k = map(int, input().split())\nfriends = UnionFind(n)\nf_or_b = [1] * (n + 1)\nfor i in range(m):\n    a, b = map(int, input().split())\n    friends.unite(a, b)\n    f_or_b[a] += 1\n    f_or_b[b] += 1\nfor i in range(k):\n    c, d = map(int, input().split())\n    if friends.is_same(c, d):\n        f_or_b[c] += 1\n        f_or_b[d] += 1\nprint(*[friends.size(i) - f_or_b[i] for i in range(1, n + 1)])", "class UnionFind():\n    \"\"\"\n    Union Find\u6728\u30af\u30e9\u30b9\n    Attributes\n    --------------------\n    n : int\n        \u8981\u7d20\u6570\n    root : list\n        \u6728\u306e\u8981\u7d20\u6570\n        0\u672a\u6e80\u3067\u3042\u308c\u3070\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u3067\u3042\u308a\u3001\u6dfb\u5b57\u306e\u5024\u304c\u8981\u7d20\u6570\n    rank : list\n        \u6728\u306e\u6df1\u3055\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Parameters\n        ---------------------\n        n : int\n            \u8981\u7d20\u6570\n        \"\"\"\n        self.n = n\n        self.root = [-1]*(n+1)\n        self.rank = [0]*(n+1)\n\n    def find_root(self, x):\n        \"\"\"\n        \u30ce\u30fc\u30c9x\u306e\u6839\u3092\u898b\u3064\u3051\u308b\n        Parameters\n        ---------------------\n        x : int\n            \u898b\u3064\u3051\u308b\u30ce\u30fc\u30c9\n        Returns\n        ---------------------\n        root : int\n            \u6839\u306e\u30ce\u30fc\u30c9\n        \"\"\"\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        \"\"\"\n        \u6728\u306e\u4f75\u5408\n        Parameters\n        ---------------------\n        x : int\n            \u4f75\u5408\u3057\u305f\u30ce\u30fc\u30c9\n        y : int\n            \u4f75\u5408\u3057\u305f\u30ce\u30fc\u30c9\n        \"\"\"\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.find_root(x)\n        y = self.find_root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rank\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif(self.rank[x] > self.rank[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rank\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rank[x] == self.rank[y]):\n                self.rank[y] += 1\n\n    def is_samegroup(self, x, y):\n        \"\"\"\n        \u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n        Parameters\n        ---------------------\n        x : int\n            \u5224\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\n        y : int\n            \u5224\u5b9a\u3057\u305f\u30ce\u30fc\u30c9\n        Returns\n        ---------------------\n        ans : bool\n            \u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\n        \"\"\"\n        return self.find_root(x) == self.find_root(y)\n\n    def count(self, x):\n        \"\"\"\n        \u6728\u306e\u30b5\u30a4\u30ba\u3092\u8a08\u7b97\n        Parameters\n        ---------------------\n        x : int\n            \u8a08\u7b97\u3057\u305f\u3044\u6728\u306e\u30ce\u30fc\u30c9\n        Returns\n        ---------------------\n        cnt : int\n            \u6728\u306e\u30b5\u30a4\u30ba\n        \"\"\"\n        return -self.root[self.find_root(x)]\n\n\nn, m, k = list(map(int, input().split()))\nuf = UnionFind(n)\nfriend = [0] * n\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    uf.unite(a, b)\n    friend[a] += 1\n    friend[b] += 1\n\nfor _ in range(k):\n    c, d = list(map(int, input().split()))\n    c, d = c-1, d-1\n    if uf.is_samegroup(c, d):\n        friend[c] += 1\n        friend[d] += 1\n\nans = [0] * n\nfor i in range(n):\n    ans[i] = uf.count(i) - friend[i] - 1\n\nprint((*ans))\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n=0):\n        self.d = [-1]*n\n    \n    def find(self, x):\n        if self.d[x] < 0: return x\n        self.d[x] = self.find(self.d[x])\n        return self.d[x]\n\n    def unite(self, x, y):\n        x,y=self.find(x),self.find(y)\n        if x==y:return False\n        if self.d[x] > self.d[y]: x,y=y,x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        return True\n\n    def same(self, x,y): return self.find(x)==self.find(y)\n    def size(self,x): return -self.d[self.find(x)]\n    \nN,M,K=map(int,input().split())\nuf=UnionFind(N+1)\nn_friends=defaultdict(int)\nfor i in range(M):\n  a,b=map(int,input().split())\n  uf.unite(a,b)\n  n_friends[a] += 1\n  n_friends[b] += 1\n  \nans = [uf.size(i)-n_friends[i]-1 for i in range(N+1)]\n\nfor i in range(K):\n  c,d=map(int,input().split())\n  if uf.same(c,d):\n    ans[c] -= 1\n    ans[d] -= 1\n  \nprint(*ans[1:])", "class UnionFind:\n  def __init__(self, n):\n    self.n = n\n    self.g = [i for i in range(n)]\n    self.nmembers = [1 for i in range(n)]\n  def __len__(self):\n    return self.n\n  def __str__(self):\n    return \"group:{}\\nnmembers:{}\".format(self.g,self.nmembers)\n  def __getitem__(self,x):\n    return self.whichgroup(x)\n  def merge(self, x, y):\n    gx = self.whichgroup(x)\n    gy = self.whichgroup(y)\n    if gx != gy:\n      nx = self.nmembers[gx]\n      ny = self.nmembers[gy]\n      ming = min(gx, gy)\n      maxg = gx + gy - ming\n      self.g[maxg] = ming\n      self.nmembers[maxg] = 0\n      self.nmembers[ming] = nx + ny\n    \n  def whichgroup(self, x):\n    if x != self.g[x]:\n      self.g[x] = self.whichgroup(self.g[x])\n      self.nmembers[x] = 0\n      return self.g[x]\n    else:\n      return x\n\nN, M, K = list(map(int, input().split()))\nUF = UnionFind(N)\nF = [0 for i in range(N)]\nB = [0 for i in range(N)]\n#print(UF)\nfor i in range(M):\n  x, y = list(map(int, input().split()))\n  x, y = x-1, y-1\n  #print(\"x:{}, y:{}\".format(x, y))\n  UF.merge(x, y)\n  F[x] += 1\n  F[y] += 1\nfor i in range(K):\n  x, y = list(map(int, input().split()))\n  x, y = x-1, y-1\n  \n  gx = UF.whichgroup(x)\n  gy = UF.whichgroup(y)\n  if gx == gy:\n    B[x] += 1\n    B[y] += 1\n#print(UF)\nans = []\nfor i in range(N):\n  ans.append(UF.nmembers[UF[i]]-B[i]-F[i]-1)\nprint((*ans))\n", "N,M,K=map(int,input().split())\n\npar=[-1]*N\nnum=[0]*N\n\ndef find(x):\n  if par[x]<0:\n    return x\n  else:\n    par[x]=find(par[x])\n    return par[x]\n\ndef union(x,y):\n  p,q=find(x),find(y)\n  if p==q:\n    return\n  if p>q:\n    p,q=q,p\n  par[p]+=par[q]\n  par[q]=p   \n\ndef size(x):\n  return -par[find(x)]\n\ndef same(x,y):\n  return find(x)==find(y)     \n\nfor _ in range(M):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  union(a,b)\n  num[a]+=1\n  num[b]+=1\n\nfor _ in range(K):\n  c,d=map(int,input().split())\n  c-=1\n  d-=1\n  if same(c,d):\n    num[c]+=1\n    num[d]+=1\n\nfor i in range(N):\n  print(size(i)-1-num[i],end=\" \")", "#\u3053\u308c\u3092\u6c42\u3081\u308b\u306b\u306f\n\n#\uff08\u9802\u70b9i\u306e\u9023\u7d50\u30b5\u30a4\u30ba\uff09\u3000\u30fc\u3000\uff08\u9802\u70b9i\u3068\u9802\u70b9j\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u542b\u307e\u308c\u3066\u4ebai\u3068\u4ebaj\u304c\u53cb\u9054\u95a2\u4fc2\u3082\u3057\u304f\u306f\u30d6\u30ed\u30c3\u30af\u95a2\u4fc2\u306b\u3042\u308bj\u306e\u6570\uff09\u30fc\u3000\uff11\n\n#\u3092\u8a08\u7b97\u3059\u308c\u3070\u826f\u3044\n\n\nclass UnionFind():\n    def __init__(self,N):\n        self.parents = [-1]*N\n\n    def root(self,x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            return self.root(self.parents[x])\n    \n    def unite(self,x,y):\n        x,y = self.root(x), self.root(y)\n        if x == y:\n            return \n        else:\n            if x > y:\n                x,y = y,x\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            return\n\n\nN,M,K = list(map(int,input().split()))\nAB = [list(map(int,input().split())) for _ in range(M)]\nCD = [list(map(int,input().split())) for _ in range(K)]\n\nu = UnionFind(N)\nf = [set() for _ in range(N)]\n#\u8981\u7d20\u6570\u304cN\u500b\u306e\u96c6\u5408\u306e\u914d\u5217\u3000f = [{},{},{},...,{}]\n\nl = [set() for _ in range(N)]\n#\u4e0a\u8a18\u3068\u540c\u69d8\n\nfor a,b in AB:\n    a,b = a-1,b-1\n    #\u914d\u5217\u306e\u6700\u521d\uff08a = 0,b = 0\uff09\u304b\u3089\u958b\u59cb\u3059\u308b\u305f\u3081\n\n    f[a].add(b)\n    #f = [...,{b},{},...,{}]\n    #\u914d\u5217\u306ea\u756a\u76ee\u306e\u96c6\u5408\u306e\u8981\u7d20\u306bb\u3092\u52a0\u3048\u308b\n\n    f[b].add(a)\n    #f = [.....,{a},{}..,{}]\n    #\u914d\u5217\u306eb\u756a\u76ee\u306e\u96c6\u5408\u306e\u8981\u7d20\u306ba\u3092\u52a0\u3048\u308b\n\n    u.unite(a,b)\n\n\nfor c,d in CD:\n    c,d = c-1,d-1\n    l[c].add(d)\n    l[d].add(c)\n\nans = [0] * N\n#\u30d6\u30ed\u30c3\u30af\u95a2\u4fc2\u306f\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u3069\u3046\u304b\u3067\u5f15\u304f\u304b\u5909\u308f\u3063\u3066\u304f\u308b\n#\u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u3042\u308b\u306a\u3089\u3070\u3001\u5168\u4f53\u306e\u9023\u7d50\u6210\u5206\u306e\u30b5\u30a4\u30ba\u304b\u3089\u5f15\u304f\nfor i in range(N):\n    r = u.root(i)\n    bl = 0\n    #\u300cbl\u300d\u306f\u5f15\u304f\u3079\u304d\u30d6\u30ed\u30c3\u30af\u95a2\u4fc2\u306e\u6570\n    for j in l[i]:\n        if u.root(j) == r:\n            bl += 1\n    \n    ans[i] = -u.parents[r] - len(f[i]) - bl -1\nprint((' '.join(list(map(str,ans)))))\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n    \n    def root(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            return self.root(self.parents[x])\n    \n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return\n        else:\n            if x > y:\n                x, y = y, x\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            return\n\nn, m, k = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\ncd = [list(map(int, input().split())) for _ in range(k)]\n\nu = UnionFind(n)\nf = [set() for _ in range(n)]\nl = [set() for _ in range(n)]\nfor a, b in ab:\n    a, b = a-1, b-1\n    f[a].add(b)\n    f[b].add(a)\n    u.unite(a, b)\nfor c, d in cd:\n    c, d = c-1, d-1\n    l[c].add(d)\n    l[d].add(c)\nans = [0] * n\nfor i in range(n):\n    r = u.root(i)\n    bl = 0\n    for j in l[i]:\n        if u.root(j) == r:\n            bl += 1\n    ans[i] = -u.parents[r] - len(f[i]) - bl - 1\nprint(' '.join(list(map(str, ans))))", "class UnionFind:\n    def __init__(self, n=0):\n        self.d = [-1]*n\n    def find(self, x):\n        if self.d[x] < 0:\n            return x\n        else:\n            self.d[x] = self.find(self.d[x])\n            return self.d[x]\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.d[x] > self.d[y]:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        return True\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.d[self.find(x)]\n\nn, m, k = map(int, input().split())\n\ndeg = [0]*100005\nuf = UnionFind(n)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    deg[a] += 1\n    deg[b] += 1\n    uf.unite(a, b)\nfor _ in range(k):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    if uf.same(c, d):\n        deg[c] += 1\n        deg[d] += 1\nfor i in range(n):\n    print(uf.size(i) - 1 - deg[i], end=\"\")\n    if i == n-1:\n        print()\n    else:\n        print(\" \", end=\"\")\n", "def N():\n    return int(input())\ndef L():\n    return list(map(int,input().split()))\ndef NL(n):\n    return [list(map(int,input().split())) for i in range(n)]\nmod = pow(10,9)+7\n\n#import numpy as np\nimport sys\nimport math\nimport collections\n\nsys.setrecursionlimit(1000000)\n\nclass UnionFind():\n    par = []\n    def __init__(self,n):\n        for i in range(n):\n            self.par.append(i)\n\n    def root(self,x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def same(self,x,y):\n        if self.root(x) == self.root(y):\n            return True\n        else:\n            return False\n\n    def unite(self,x,y):\n        x = self.root(x)\n        y = self.root(y)\n        if x==y:\n            return\n        self.par[y] = x\n    \n    def comp(self):#root\u307e\u3067\u306e\u8ddd\u96e2\u5727\u7e2e\n        for i in range(len(self.par)):\n            self.root(i)\nn,m,k = L()\nuf = UnionFind(n)\nf = [0]*n\nfor i in range(m):\n    a,b = L()\n    uf.unite(a-1,b-1)\n    f[a-1] += 1\n    f[b-1] += 1\nuf.comp()\n\nfor i in range(k):\n    a,b = L()\n    if uf.par[a-1] == uf.par[b-1]:\n        f[a-1] += 1\n        f[b-1] += 1\n\ncount = collections.Counter(uf.par)\n#print(uf.par)\n#print(count)\n#print(f)\nfor i in range(n):\n    print(count[uf.par[i]]-f[i]-1,\"\",end=\"\")\nprint()", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n)]\n        self.rank = [1]*n\n        self.size = [1]*n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    def unite(self, x, y):\n        x = self.find(x); y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.parent[x] = y\n                self.size[y] += self.size[x]\n            else:\n                self.parent[y] = x\n                self.size[x] += self.size[y]\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    def group_size(self, x):\n        return self.size[self.find(x)]\nn, m, k = map(int, input().split())\na = [0]*m; b = [0]*m; c = [0]*k; d = [0]*k; x = [0]*n\ndirect = [[] for _ in range(n)]; uf = UnionFind(n)\nfor i in range(m):\n    a[i], b[i] = map(int, input().split())\n    a[i] -= 1; b[i] -= 1\n    direct[a[i]].append(b[i]); direct[b[i]].append(a[i])\n    uf.unite(a[i], b[i])\nfor i in range(k):\n    c[i], d[i] = map(int, input().split())\n    c[i] -= 1; d[i] -= 1\n    if uf.is_same(c[i], d[i]):\n        direct[c[i]].append(d[i]); direct[d[i]].append(c[i])\nfor i in range(n): x[i] = uf.group_size(i)-len(direct[i])-1\nprint(*x)", "n,m,k = map(int,input().split())\npar = [-1]*(n+1)\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    else:\n        if par[x] > par[y]:\n            x,y = y,x\n        par[x] += par[y]\n        par[y] = x\ndef size(x):\n    return -par[find(x)]\ng = [[] for _ in range(n+1)]\nb = [[] for _ in range(n+1)]\nfor _ in range(m):\n    s,t = map(int,input().split())\n    unite(s,t)\n    g[s].append(t)\n    g[t].append(s)\nfor _ in range(k):\n    s,t = map(int,input().split())\n    b[s].append(t)\n    b[t].append(s)\nfor i in range(1,n+1):\n    ans = size(i)-1-len(g[i])\n    for e in b[i]:\n        if same(i,e):\n            ans -= 1\n    print(ans,end=\" \")", "import numpy as np\nfrom scipy.sparse.csgraph import connected_components\nfrom scipy.sparse import csr_matrix\n\nimport sys\nsys.setrecursionlimit(10**9)\nn,m,k=[int(i) for i in input().split()]\nfrends_num=[0 for i in range(n)]\ndef make_frends(m,n):\n    data=[1 for i in range(m)]\n\n    row=[]\n    col=[]\n    for k in range(m):\n        i,j=[int(l) for l in input().split()]\n        new_i=min(i,j)-1\n        new_j=max(i,j)-1\n        row.append(new_i)\n        col.append(new_j)\n        frends_num[new_i]+=1\n        frends_num[new_j]+=1\n    frend_sparce_matrix=csr_matrix((data, (row, col)),shape=(n,n))\n    return frend_sparce_matrix\n\n\nfrends=make_frends(m,n)\nl,labels=connected_components(frends)\nlabels\nlabels=list(labels)\n\nclass Group:\n    def __init__(self,labels):\n        self.labels=labels\n        self.group_num=[0 for i in range(l)]\n        for i in labels:\n            self.group_num[i]+=1\n    def get_group_num(self,i):\n        return self.group_num[self.labels[i]]\n\ngroup=Group(labels)\n\n\ndef get_frend_num(i):\n    return frends_num[i]\n\n\ndef make_block(k,n):\n    block_num=[0 for i in range(n)]\n    for p in range(k):\n        i,j =[int(l)-1 for l in input().split()]\n        new_i=min(i,j)\n        new_j=max(i,j)\n        if labels[new_i]==labels[new_j]:\n            block_num[i]+=1\n            block_num[j]+=1\n    return block_num\n\nblock=make_block(k,n)\n\ndef get_block_num(i):\n    return block[i]\n\nans=[]\nfor i in range(n):\n    ans.append(str(group.get_group_num(i)-1-get_frend_num(i)-get_block_num(i)))\nprint((\" \".join(ans)))\n", "n, m, k = list(map(int, input().split()))\n\nf_adj_list = [[] for i in range(n)]\nb_adj_list = [[] for i in range(n)]\n\nfor i in range(m):\n  _, __ = list(map(int, input().split()))\n  _ -= 1\n  __ -= 1\n  f_adj_list[_].append(__)\n  f_adj_list[__].append(_)\n  \nfor j in range(k):\n  _, __ = list(map(int, input().split()))\n  _ -= 1\n  __ -= 1\n  b_adj_list[_].append(__)\n  b_adj_list[__].append(_)\n  \n  \ngroup_id = [None for i in range(n)]\nfor i in range(n):\n  if group_id[i] is not None: continue\n  # i \u304b\u3089 DFS\n  newly_visited = [i]\n  group_id[i] = i\n  while len(newly_visited) > 0:\n    now = newly_visited.pop()\n    for j in f_adj_list[now]:\n      if group_id[j] is not None: continue\n      newly_visited.append(j)\n      group_id[j] = i\n\n# group_id\n# print(group_id)\n\n# \u9023\u7d50\u6210\u5206\u306e\u30b5\u30a4\u30ba\nfrom collections import Counter\ncnt = Counter(group_id)\n# cnt[5] = 7\n\nans_list = []\nfor i in range(n):\n  ans = cnt[group_id[i]]\n  ans -= 1 # \u81ea\u5206\u81ea\u8eab\n  ans -= len(f_adj_list[i]) # \u76f4\u63a5\u306e\u53cb\u9054\n  for j in b_adj_list[i]:\n    if group_id[i] == group_id[j]:\n      ans -= 1\n  ans_list.append(ans)\n\nprint((\" \".join(map(str, ans_list))))\n", "class UnionFind:\n    def __init__(self, n: int) -> None:\n        self.forest = [-1] * n\n\n    def union(self, x: int, y: int) -> None:\n        x = self.findRoot(x)\n        y = self.findRoot(y)\n        if x == y:\n            return\n        if self.forest[x] > self.forest[y]:\n            x,y = y,x\n        self.forest[x] += self.forest[y]\n        self.forest[y] = x\n        return\n\n    def findRoot(self, x: int) -> int:\n        if self.forest[x] < 0:\n            return x\n        else:\n            self.forest[x] = self.findRoot(self.forest[x])\n            return self.forest[x]\n\n    def issame(self, x: int, y: int) -> bool:\n        return self.findRoot(x) == self.findRoot(y)\n    \n    def size(self,x: int) -> int:\n        return -self.forest[self.findRoot(x)]\n\nn,m,k = map(int,input().split())\nl = [[] for _ in range(n)]\nu = UnionFind(n)\nfor _ in range(m):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    u.union(a,b)\n    l[a].append(b)\n    l[b].append(a)\n\nfor _ in range(k):\n    c,d = map(int,input().split())\n    c -= 1\n    d -= 1\n    if u.issame(c,d):\n        l[c].append(d)\n        l[d].append(c)\n\nfor i in range(n):\n    q = u.size(i)\n    w = len(l[i])\n    print(q-w-1, end=\" \")\n\n", "from collections import defaultdict\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10**6)\n\nN, M, K = map(int, input().split())\nF = [list(map(int, input().split())) for _ in range(M)]\nB = [list(map(int, input().split())) for _ in range(K)]\n\nclass UFTree():\n    def __init__(self, n):\n        self.length = n+1\n        self.roots = list(range(self.length))\n\n    def union(self, a, b):\n        r = self.find(a)\n        s = self.find(b)\n        self.roots[s] = r\n\n    def find(self, a):\n        r = self.roots[a]\n        if r == a:\n            return a\n        r = self.find(r)\n        self.roots[a] = r\n        return r\n\n    def findall(self):\n        for i in range(self.length):\n            self.find(i)\n\n    def setli(self):\n        self.findall()\n        d = defaultdict(set)\n        for i, r in enumerate(self.roots):\n            if i: d[r].add(i)\n        return list(d.values())\n\n    def sameroot(self, a, b):\n        r = self.find(a)\n        s = self.find(b)\n        return r == s\n\nt = UFTree(N)\nfor a, b in F:\n    t.union(a, b)\n\ns = [0]*(N+1)\nfor a, b in F:\n    s[a] -= 1\n    s[b] -= 1\nfor c, d in B:\n    if t.sameroot(c, d):\n        s[c] -= 1\n        s[d] -= 1\n\nfor u in t.setli():\n    l = len(u)\n    for i in u: s[i] += l-1\n\nprint(*s[1:])", "N, M, K = list(map(int, input().split()))\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n        if self.size[x] > self.size[y]:\n            x, y = y, x\n        self.par[x] = y\n        self.size[y] += self.size[x]\n\n\nuf = UnionFind(N)\nfri = []\nrst = [0]*N\n\nfor m in range(M):\n    A, B = list(map(int, input().split()))\n    A -= 1\n    B -= 1\n    fri.append((A, B))\n    uf.unite(A, B)\n\nfor i in range(N):\n    ind = uf.find(i)\n    rst[i] = uf.size[ind]-1\n\nfor f in fri:\n    A, B = f\n    if uf.par[A] == uf.par[B]:\n        rst[A] -= 1\n        rst[B] -= 1\n\nfor k in range(K):\n    C, D = list(map(int, input().split()))\n    C -= 1\n    D -= 1\n    if uf.par[C] == uf.par[D]:\n        rst[C] -= 1\n        rst[D] -= 1\n\nprint((\" \".join(map(str, rst))))\n", "import sys\n# \u518d\u5e30\u56de\u6570\u4e0a\u5f26\u3092100000\u56de\u306b\u8a2d\u5b9a\nsys.setrecursionlimit(100000)\n# \u30b9\u30bf\u30c3\u30af\u30b5\u30a4\u30ba\u3092\u7121\u5236\u9650\u306b\u8a2d\u5b9a\n# resource.setrlimit(resource.RLIMIT_STACK, (-1, -1))\n\nclass UnionFind:\n    \"\"\"\n    \u5b50\u30ce\u30fc\u30c9\u306b\u306f\u81ea\u5206\u306e\u89aa\u30ce\u30fc\u30c9ID\u3092\u8a18\u9332\u3002\u89aa\u30ce\u30fc\u30c9\u306b\u306f\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba\u306e\u8ca0\u5024\u3092\u8a18\u9332\u3002\n    \"\"\"\n\n    def __init__(self, n):\n        self.node = [-1] * n\n    \n    def unite(self, x, y):\n        \"\"\"\n        x\u3068y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u7d71\u5408\n        \"\"\"\n        # x\u3068y\u306e\u89aa\u30ce\u30fc\u30c9\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u53d6\u5f97\n        _x, _y = self.find(x), self.find(y)\n        # \u4e00\u81f4\u3057\u3066\u3044\u308c\u3070\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3057\u3066\u3044\u308b\u306e\u3067\u51e6\u7406\u7d42\u4e86\u3002\n        # False\u306f\u306a\u305e\u3002\n        if _x == _y:\n            return False\n        # \u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u3044\u30b0\u30eb\u30fc\u30d7\u3092\u5927\u304d\u3044\u30b0\u30eb\u30fc\u30d7\u306b\u7d50\u5408\u3059\u308b\u306e\u3067\u3001\n        # _y\u5074\u306e\u7d76\u5bfe\u5024\u304c\u304b\u306a\u3089\u305a\u5c0f\u3055\u304f\u306a\u308b\u3088\u3046\u306b\u524d\u51e6\u7406\u3002(_y\u3092_x\u306e\u30b0\u30eb\u30fc\u30d7\u3078\u7d71\u5408)\n        # \u5927\u304d\u3044\u65b9\u3092\u5c0f\u3055\u3044\u65b9\u3078\u7d50\u5408\u3057\u3066\u3057\u307e\u3046\u3068\u30ce\u30fc\u30c9\u304c\u6df1\u304f\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u3001\n        # \u8a08\u7b97\u91cf\u3092\u524a\u6e1b\u3059\u308b\u305f\u3081\u306e\u30c6\u30af\u30cb\u30c3\u30af\u3002\n        if abs(self.node[_x]) < abs(self.node[_y]):\n             self.node[_x], self.node[_y] = self.node[_y], self.node[_x]\n        # \u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba\u66f4\u65b0\n        self.node[_x] += self.node[_y]\n        # _y\u306e\u89aa\u30ce\u30fc\u30c9\u3092_x\u306b\u66f4\u65b0\n        self.node[_y] = _x\n        return True\n\n    def find(self, x):\n        \"\"\"\n        x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u89aa\u30ce\u30fc\u30c9\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u691c\u7d22\u3002\n        \"\"\"\n        _val = self.node[x]\n        # \u8ca0\u306a\u3089\u89aa\u30ce\u30fc\u30c9\u3068\u307f\u306a\u3057\u3066\u3001\u305d\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059\u3002\n        if _val < 0: \n            return x\n        # \u30b0\u30eb\u30fc\u30d7\u306e\u89aa\u30ce\u30fc\u30c9\u3092\u518d\u5e30\u7684\u306b\u691c\u7d22\u3002\n        # \u3055\u3089\u306b\u3001\u30b0\u30eb\u30fc\u30d7\u306e\u89aa\u30ce\u30fc\u30c9ID\u3092\u5b50\u30ce\u30fc\u30c9\u306b\u8a18\u9332\u3057\u3066\u304a\u304f\u3053\u3068\u3067\n        # \u7d4c\u8def\u7e2e\u5c0f\u3092\u5b9f\u73fe\u3002\n        self.node[x] = self.find(_val)\n        return self.node[x]\n\n    def same(self, x, y):\n        \"\"\"\n        x\u3068y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u304c\u540c\u3058\u304b\u30c1\u30a7\u30c3\u30af\u3002\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"\n        x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u7dcf\u30b5\u30a4\u30ba\u53d6\u5f97\n        \"\"\"\n        return abs(self.node[self.find(x)])\n \n    def __str__(self):\n        return str(self.node)\n\nN, M, K = map(int, input().split())\n\nuf = UnionFind(N)\nfriend = [0] * N\nblock = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    uf.unite(a, b)\n    friend[a], friend[b] = friend[a] + 1, friend[b] + 1\n\nfor _ in range(K):\n    c, d = map(int, input().split())\n    c, d = c - 1, d - 1\n    block[c].append(d)\n    block[d].append(c)\n\nfor i in range(N):\n    ans = uf.size(i) - friend[i] - 1\n    for j in block[i]:\n        if uf.same(i, j):\n            ans -= 1\n    print(\"{} \".format(ans), end=\"\")\nprint(\"\")", "N,M,K=map(int,input().split())\npar=[-1]*N\ndef find(x):\n  if par[x] < 0:\n    return x\n  else:\n    tank = []\n    while par[x] >= 0:\n      tank.append(x)\n      x = par[x]\n    for elt in tank:\n      par[elt] = x\n    return x\ndef unite(x,y):\n  x = find(x)\n  y = find(y)\n  if x == y:\n    return False\n  else:\n    if find(x)>find(y):x,y=y,x\n    par[x] += par[y]\n    par[y] = x\n    return True\nfrbl=[0]*N\nfor i in range(M):\n  a,b=sorted(map(int,input().split()))\n  unite(a-1,b-1)\n  frbl[a-1]+=1;frbl[b-1]+=1\nfor i in range(K):\n  c,d=sorted(map(int,input().split()))\n  if find(c-1)==find(d-1):\n    frbl[c-1]+=1;frbl[d-1]+=1\n    \nlist=[]\nfor i in range(N):\n  list.append(-par[find(i)]-frbl[i]-1)\nprint(*list)", "\nclass UnionFind:\n    # \u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    # \u8981\u7d20\u304c\u6839\uff08\u30eb\u30fc\u30c8\uff09\u306e\u5834\u5408\u306f-(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\u3092\u683c\u7d0d\u3059\u308b\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    # \u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    # \u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n    def group_count(self):\n        return len(self.roots())\n\n    # {\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u8f9e\u66f8\u3092\u8fd4\u3059\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    # \u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059 (print()\u3067\u306e\u8868\u793a\u7528)\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef resolve():\n    N, M, K = list(map(int, input().split()))\n    uf = UnionFind(N)\n    sub_friend = [1] * N  # +1: \u81ea\u5206\u81ea\u8eab\n\n    frind = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(x) - 1 for x in input().split()]\n        frind[a].append(b)\n        frind[b].append(a)\n        sub_friend[a] += 1\n        sub_friend[b] += 1\n\n    block = [[] for _ in range(N)]\n    for _ in range(K):\n        c, d = [int(x) - 1 for x in input().split()]\n        block[c].append(d)\n        block[d].append(c)\n\n    for i in range(N):\n        for to in frind[i]:\n            uf.union(i, to)\n\n    ans = [uf.size(i) - sub_friend[i] for i in range(N)]\n\n    for i in range(N):\n        for bl in block[i]:\n            if uf.is_same(i, bl):\n                ans[i] -= 1\n    print((*ans))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N, M, K = list(map(int, input().split()))\n\nfriends = [set() for _ in range(N)]\nfor _ in range(M):\n    a,b = [int(x)-1 for x in input().split()]\n    friends[a].add(b)\n    friends[b].add(a)\n\nblocks = [set() for _ in range(N)]\nfor _ in range(K):\n    c,d = [int(x)-1 for x in input().split()]\n    blocks[c].add(d)\n    blocks[d].add(c)\n\nans = [0]*N\nvisited = [False]*N\nfor i in range(N):\n    if visited[i]:\n        continue\n    visited[i] = True\n    d = [i]\n    check = {i} \n    while len(d):\n        tmp = d.pop()\n        for k in friends[tmp]:\n            if visited[k]:\n                continue\n            d.append(k)\n            visited[k] = True\n            check.add(k)\n    for j in check:\n        ans[j] += len(check) - len(friends[j]&check) - len(blocks[j]&check) - 1\nprint((*ans))\n", "class Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, M, K = map(int, input().split())\nuf = Unionfind(N)\nf = [0 for _ in range(N)]\nn = [0 for _ in range(N)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    uf.union(a, b)\n    \n    f[a] += 1\n    f[b] += 1\n    \nfor _ in range(K):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    if(uf.same(c, d)):\n        n[c] += 1\n        n[d] += 1\n    \nans = []\nfor i in range(N):\n    ans.append(uf.size(i)-f[i]-n[i]-1)\n    \nprint(*ans)", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, v):\n        if self.parents[v] < 0:\n            return v\n        else:\n            self.parents[v] = self.find(self.parents[v])\n            return self.parents[v]\n\n    def unite(self, u, v):\n        u = self.find(u)\n        v = self.find(v)\n\n        if u == v:\n            return\n\n        if self.parents[u] > self.parents[v]:\n            u, v = v, u\n\n        self.parents[u] += self.parents[v]\n        self.parents[v] = u\n\n    def size(self, v):\n        return -self.parents[self.find(v)]\n\n    def same(self, u, v):\n        return self.find(u) == self.find(v)\n\nN, M, K = map(int, input().split())\nuf = UnionFind(N+1)\nF = [0] * (N+1)\nB = [0] * (N+1)\nfor _ in range(M):\n    a, b = map(int, input().split())\n    uf.unite(a, b)\n    F[a] += 1\n    F[b] += 1\n\nfor _ in range(K):\n    c, d = map(int, input().split())\n    if uf.same(c, d):\n        B[c] += 1\n        B[d] += 1\n\nfor i in range(1, N+1):\n    ans = uf.size(i) - F[i] - B[i] - 1\n    print(ans, end=' ')\n\nprint()", "# unionfind\nclass Uf:\n    def __init__(self, N):\n        self.p = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def root(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.root(self.p[x])\n\n        return self.p[x]\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        u = self.root(x)\n        v = self.root(y)\n\n        if u == v: return\n\n        if self.rank[u] < self.rank[v]:\n            self.p[u] = v\n            self.size[v] += self.size[u]\n            self.size[u] = 0\n        else:\n            self.p[v] = u\n            self.size[u] += self.size[v]\n            self.size[v] = 0\n\n            if self.rank[u] == self.rank[v]:\n                self.rank[u] += 1\n\n    def count(self, x):\n        return self.size[self.root(x)]\n\nN, M, K = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\nCD = [list(map(int, input().split())) for _ in range(K)]\n\nuf = Uf(N+1)\nM = [-1] * (N+1)\nfor a, b in AB:\n    uf.unite(a, b)\n    M[a] -= 1\n    M[b] -= 1\nfor c, d in CD:\n    if uf.same(c, d):\n        M[c] -= 1\n        M[d] -= 1\nfor i in range(1, N+1):\n    M[i] += uf.count(i)\nprint((\" \".join(map(str, M[1:]))))\n", "import sys\nsys.setrecursionlimit(10**6)\nfrom collections import Counter\n\ndef dfs(nw):\n    for nx in F[nw]:\n        if V[nx]==-1:\n            V[nx] = cnt\n            dfs(nx)\n\nn, m, k = list(map(int, sys.stdin.readline().split()))\nF = [[] for _ in range(n)]\nB = [[] for _ in range(n)]\nfor i in range(m):\n    a,b = map(lambda x: int(x)-1, map(int, sys.stdin.readline().split()))\n    F[a].append(b)\n    F[b].append(a)\nfor i in range(k):\n    c,d = map(lambda x: int(x)-1, map(int, sys.stdin.readline().split()))\n    B[c].append(d)\n    B[d].append(c)\n\nV = [-1]*n\ncnt = 1\nfor i in range(n):\n    if V[i]==-1:\n        V[i] = cnt\n        dfs(i)\n        cnt += 1\ncV = Counter(V)\nans = []\nfor i in range(n):\n    ans.append(cV[V[i]]-1 - len(F[i]) - sum([V[b]==V[i] for b in B[i]]))\n\nprint(*ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        #\u89aa\u306e\u6dfb\u5b57\u3001\u89aa\u81ea\u8eab\u306f\u6728\u306e\u8981\u7d20\u6570*-1\u3092\u3082\u3064\n        self.root = [-1]*(n)\n        #\u679d\u306e\u6700\u5927\u9577\u3055\n        self.rank = [0]*(n)\n\n    def find_root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n    #\u9ad8\u3055\u306b\u3088\u308b\u5408\u4f75    \n    def unite(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if x == y:\n            return \n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if(self.rank[x] == self.rank[y]):\n                self.rank[y] += 1\n    def same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n    \n    def count(self, x):\n        return -self.root[self.find_root(x)]    \n    \n    def members(self, x):\n        root = self.find_root(x)\n        return [i for i in range(self.n) if self.find_root(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.root) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\nN, M, K = map(int,input().rstrip().split())\nAB=[list(map(int,input().rstrip().split()))for _ in range(M)]\nCD=[list(map(int,input().rstrip().split()))for _ in range(K)]\n\nu = UnionFind(N)\nfor a,b in AB:\n    u.unite(a-1,b-1)\n\nans=[u.count(i)-1 for i in range(N)] #\u6728\u306e\u8981\u7d20\u6570\u304b\u3089\u81ea\u5206\u3092\u5f15\u304f\nans\n\nfor a,b in AB:\n    if u.same(a-1,b-1):\n        ans[a-1]-=1\n        ans[b-1]-=1\n\nfor c,d in CD:\n    if u.same(c-1,d-1):\n        ans[c-1]-=1\n        ans[d-1]-=1\nprint(*ans)", "class UnionFind():\n    \"\"\"\n        unionfindtree \u306e\u30af\u30e9\u30b9\n            \u30b0\u30eb\u30fc\u30d7\u3092\u7ba1\u7406\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020.\n            \u5168\u3066\u306e\u30e1\u30bd\u30c3\u30c9\u306e\u8a08\u7b97\u91cf\u304c O(log(n)) \u3088\u308a\u3082\u5c0f\u3055\u3044\n        init: \u7ba1\u7406\u5bfe\u8c61\u306e\u500b\u6570 n \u3092\u7528\u3044\u3066\u521d\u671f\u5316\n        find: \u3042\u308b\u8981\u7d20 x \u306e\u89aa\u304c\u3069\u306e\u8981\u7d20\u304b\u8fd4\u3059\n        union: \u3042\u308b\u8981\u7d20 x \u3068 y \u304c\u5c5e\u3057\u3066\u3044\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\u3057\u30661\u3064\u306e\u30b0\u30eb\u30fc\u30d7\u3068\u3059\u308b\n        msize: \u3042\u308b\u8981\u7d20 x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n        self.rank = [0]*n\n        self.size = [1]*n\n\n    def find(self, x):\n        \"\"\"\n            \u3042\u308b\u8981\u7d20 x \u306e\u89aa\u306e\u8981\u7d20\u3092\u898b\u3064\u3051\u308b\u30e1\u30bd\u30c3\u30c9\n        \"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        \"\"\"\n            \u3042\u308b\u8981\u7d20 x, y \u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\u3059\u308b\u30e1\u30bd\u30c3\u30c9\n            x \u3068 y \u306e\u30e9\u30f3\u30af(\u5b50\u306e\u6570)\u306e\u5c0f\u3055\u3044\u65b9\u304c\u7d50\u5408\u5148\u306e\u89aa\u3068\u306a\u308b\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.size[y] += self.size[x]\n            self.parents[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parents[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def msize(self, x):\n        \"\"\"\n            \u3042\u308b\u8981\u7d20 x \u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\n        \"\"\"\n        return self.size[self.find(x)]\n\ndef main():\n    N, M, K = list(map(int, input().split()))\n    uf = UnionFind(N)\n    friends = [0] * N\n    for _ in range(M):\n        A, B = list(map(int, input().split()))\n        uf.union(A-1, B-1)\n        friends[A-1] += 1\n        friends[B-1] += 1\n    for _ in range(K):\n        C, D = list(map(int, input().split()))\n        if uf.find(C-1) == uf.find(D-1):\n            friends[C-1] += 1\n            friends[D-1] += 1\n    ans = []\n    for i in range(N):\n        ans.append(uf.msize(i) - friends[i] - 1)\n    print((*ans))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,K=list(map(int,input().split()))\nroot=[i for i in range(N)]\nheight=[1 for i in range(N)]\nl=[set() for i in range(N)]\nmem=[0]*N\ndef find(n):\n   f=n\n   while n != root[n]:\n      n=root[n]\n   root[f]=n\n   return n\ndef union(a,b):\n   A=find(a)\n   B=find(b)\n   if A==B:\n      return\n   elif height[A]<height[B]:\n      height[B]+=height[A]\n      height[A]=0\n      root[A]=B\n   else:\n      root[B]=A\n      height[A]+=height[B]\n      height[B]=0\ndef same(a,b):\n   A=find(a)\n   B=find(b)\n   if A==B:\n      l[a].add(b)\n      l[b].add(a)\nfor i in range(M):\n   a,b=list(map(int,input().split()))\n   a-=1;b-=1\n   l[a].add(b)\n   l[b].add(a)\n   union(a,b)\nfor j in range(K):\n   a,b=list(map(int,input().split()))\n   a-=1;b-=1\n   same(a,b)\nfor i in range(N):\n   print(height[find(i)]-len(l[i])-1,end=\" \")\n", "def main():\n    n,m,k = list(map(int,input().split()))\n    F,B = {},{}\n    for i in range(1,n+1):\n        F[i] = []\n        B[i] = []\n    for _ in range(m):\n        a,b = list(map(int,input().split()))\n        F[a]+=[b]\n        F[b]+=[a]\n    for _ in range(k):\n        a,b = list(map(int,input().split()))\n        B[a]+=[b]\n        B[b]+=[a]\n    G = [0 for i in range(n)]\n    g = 1\n    M = {}\n    for i in range(n):\n        if G[i]!=0:\n            continue\n        m = 1\n        G[i] = g\n        que = [i+1]\n        while len(que)>0:\n            q = que.pop(0)\n            for nv in F[q]:\n                if G[nv-1]!=0:\n                    continue\n                G[nv-1]=g\n                que.append(nv)\n                m+=1\n        M[g] = m\n        g += 1\n    ans = []\n    for i in range(n):\n        g = G[i]\n        a = M[g]\n        for b in B[i+1]:\n            if G[b-1]==g:\n                a -=1\n        a -= len(F[i+1])\n        a -= 1\n        ans.append(a)\n    print((' '.join([str(a) for a in ans])))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(100000000)\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return {i for i in range(self.n) if self.find(i) == root}\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m,k=map(int,input().split())\nblock = [0]*n\nuf = UnionFind(n)\nfor _ in range(m):\n  a,b=map(int,input().split())\n  block[a-1] += 1\n  block[b-1] += 1\n  uf.union(a-1,b-1)\n\nuf.find(0)\nfor _ in range(k):\n  c,d=map(int,input().split())\n  if uf.same(c-1,d-1):\n    block[c-1] += 1\n    block[d-1] += 1\n\nans = [uf.size(i) - block[i] - 1 for i in range(n)]\nprint(*ans)", "N,M,K=map(int,input().split())\npar=[-1]*N\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    else:\n      if find(x)>find(y):x,y=y,x\n      par[x] += par[y]\n      par[y] = x\n      return True\nfrbl=[0]*N\nfor i in range(M):\n  a,b=sorted(map(int,input().split()))\n  unite(a-1,b-1)\n  frbl[a-1]+=1;frbl[b-1]+=1\nblock=[0]*N\nfor i in range(K):\n  c,d=sorted(map(int,input().split()))\n  if find(c-1)==find(d-1):\n    frbl[c-1]+=1;frbl[d-1]+=1\nlist=[]\nfor i in range(N):\n  list.append(-par[find(i)]-frbl[i]-1)\nprint(*list)", "n,m,k=map(int,input().split())\n\nclass UnionFind:\n    def __init__(self,n):\n        self.ps = [-1]*(n+1)\n    def find(self,x):\n        if self.ps[x]<0:\n            return x\n        else:\n            self.ps[x]=self.find(self.ps[x])\n            return self.ps[x]\n    def unite(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n        if x==y:\n            return False\n        if self.ps[x]>self.ps[y]:\n            x,y = y,x\n        self.ps[x] += self.ps[y]\n        self.ps[y] = x\n        return True\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n    def size(self,x):\n        x = self.find(x)\n        return -self.ps[x]\n\nall1 = [0]*(n)\n\nuf = UnionFind(n)\nfor i in range(m):\n    a,b = map(int,input().split())\n    uf.unite(a,b)\n    a,b = a-1,b-1\n    \n    all1[a] +=1\n    all1[b] +=1\n#print(all1)\nans = [uf.size(x)-1-all1[x-1] for x in range(1,n+1)]\n#print(ans)\n\nfor i in range(k):\n    a,b = map(int,input().split())\n    if uf.same(a,b):\n        a,b = a-1,b-1\n        ans[a] -=1\n        ans[b] -=1\nprint(*ans)", "N, M, K = list(map(int, input().split()))\np = [0] * N # p[][0] \u53cb\u9054\u30ea\u30b9\u30c8\u3000p[][1] \u30d6\u30ed\u30c3\u30af\u30ea\u30b9\u30c8 p[][2] \u6240\u5c5e\u30b0\u30eb\u30fc\u30d7(-1\u306f\u306a\u3057)\nfor i in range(N):\n    p[i] = [0]*3\n    p[i][0] = []\n    p[i][1] = []\n    p[i][2] = -1\ng = [] # \u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\nstack = []\ngroupNum = 0\nfcs = []\n\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    p[a-1][0].append(b-1)\n    p[b-1][0].append(a-1)\n\ndef groupmake(person,group):\n    groupSize = 0\n    stack.append(person)\n    p[person][2] = group\n    while True:\n        num = stack.pop()\n        groupSize += 1\n        for i in p[num][0]:\n            if p[i][2] == -1:\n                stack.append(i)\n                p[i][2] = group\n        if len(stack) == 0:\n            return groupSize\n\nfor i in range(len(p)):\n    if p[i][2] == -1:\n        g.append(groupmake(i, groupNum))\n        groupNum += 1\n\nfor person in p:\n    fcs.append(g[person[2]] - len(person[0]) -1)\n\nfor i in range(K):\n    c, d = list(map(int, input().split()))\n    if p[c-1][2] == p[d-1][2]:\n        fcs[c-1] -= 1\n        fcs[d-1] -= 1\n\nprint(\" \".join(map(str, fcs)))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn, m, k = map(int, input().split())\nuf = UnionFind(n)\nfriend = [0]*n\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    uf.union(a, b)\n    friend[a] += 1\n    friend[b] += 1\n\nfor _ in range(k):\n    c, d = map(int, input().split())\n    c, d = c-1, d-1\n    if uf.same(c, d):\n        friend[c] += 1\n        friend[d] += 1\n\nans = [0]*n\nfor i in range(n):\n    ans[i] = uf.size(i) - friend[i] - 1\n\nprint(*ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n  class UnionFind:\n        def __init__(self, n):\n            self.par = [i for i in range(n+1)]\n            self.rank = [0] * (n+1)\n            self.size = [1] * (n+1)\n    \n        # \u691c\u7d22\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n    \n        # \u4f75\u5408\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n    \n            if x == y:\n                return\n    \n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.size[y] += self.size[x]\n                self.size[x] = 0\n            else:\n                self.par[y] = x\n                self.size[x] += self.size[y]\n                self.size[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n    \n        # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n    \n        # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n        def all_find(self):\n            for n in range(len(self.par)):\n                self.find(n)\n\n\n  N,M,K = i_map()\n  tree = UnionFind(N)\n  not_friend_candi = []\n\n  for i in range(M):\n    A,B = i_map()\n    A -= 1\n    B -= 1\n    tree.union(A,B)\n    not_friend_candi.append([A,B])\n  \n  tree.all_find()\n\n  for j in range(K):\n    C,D = i_map()\n    C -= 1\n    D -= 1\n    not_friend_candi.append([C,D])\n  \n  ans = [0]*N\n  for i,j in not_friend_candi:\n    if tree.same(i,j):\n      ans[i] -= 1\n      ans[j] -= 1\n  for i in range(N):\n    p = tree.find(i)\n    ans[i] += tree.size[p] - 1\n  print(*ans)\n\n\n\n \n\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n        \nn, m, k = map(int, input().split())\nans = [-1 for _ in range(n)]\nUF = UnionFind(n)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    UF.union(a, b)\n    ans[a] -= 1\n    ans[b] -= 1\n    \nfor i in range(n):\n    ans[i] += UF.size(i)\n\nfor _ in range(k):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    if UF.same(c, d):\n        ans[c] -= 1\n        ans[d] -= 1\nprint(*ans)", "class UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.size = [1] * n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            self.size[y] += self.size[x]\n            self.parents[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,m,k=list(map(int,input().split()))\nuf=UnionFind(n)\nfriends=[0]*n\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    uf.union(a-1,b-1)\n    friends[a-1]+=1\n    friends[b-1]+=1\nblock=[[] for _ in range(n)]\nfor i in range(k):\n    c,d=list(map(int,input().split()))\n    block[c-1].append(d)\n    block[d-1].append(c)\nans=[0]*n\ncnt=[0]*n\nfor i in range(n):\n    cnt[i]=uf.find(i)\nfor i in range(n):\n    num1=uf.size[uf.find(i)]-friends[i]-1\n    num2=cnt[i]\n    for j in range(len(block[i])):\n        if num2==cnt[block[i][j]-1]:\n            num1-=1\n    ans[i]=num1\nprint((*ans))\n", "class UnionFind:\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n        self.size = [1] * (N + 1)\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        sx, sy = self.size[x], self.size[y]\n        if sx < sy:\n            x, y = y, x\n            sx, sy = sy, sx\n        self.root[y] = x\n        self.size[x] += sy\n\n\ndef graph_input(N, M):\n    G = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        G[a].append(b)\n        G[b].append(a)\n    return G\n\n\nN, M, K = list(map(int, input().split()))\nfriend = graph_input(N, M)\nblock = graph_input(N, K)\n\nuf = UnionFind(N + 1)\nfor a in range(N + 1):\n    for b in friend[a]:\n        uf.merge(a, b)\n\nanswer = [0] * (N + 1)\nfor a in range(N + 1):\n    n = uf.size[uf[a]] - 1\n    for x in friend[a] + block[a]:\n        if uf[a] == uf[x]:\n            n -= 1\n    answer[a] = n\n\nprint((' '.join(map(str, answer[1:]))))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn, m, k = map(int, input().split())\nfr = [0]*n\nuf_fr = UnionFind(n)\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    uf_fr.union(a-1, b-1)\n    fr[a-1] += 1\n    fr[b-1] += 1\n\nfor i in range(k):\n    c, d = map(int, input().split())\n    if uf_fr.find(c-1) == uf_fr.find(d-1):\n        fr[c-1] += 1\n        fr[d-1] += 1\n\nans_list = []\nfor i in range(n):\n    ans_list.append(uf_fr.size(i) - fr[i] - 1)\nprint(*ans_list)", "# ABC157 D Friend Suggestions\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn,m,k = map(int,input().split())\ng = [[] for _ in range(n)]\nuf = UnionFind(n)\n\nfor i in range(m):\n    a,b = map(int,input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n    uf.union(a-1,b-1)\n    \nfor i in range(k):\n    c,d = map(int,input().split())\n    if uf.same(c-1,d-1):\n        g[c-1].append(d-1)\n        g[d-1].append(c-1)\n        \nans = [0]*n\nfor i in range(n):\n    ans[i] = uf.size(i) - len(g[i]) - 1\nprint(*ans)", "N,M,K = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \nuf = UnionFind(N)      \nV = [[] for _ in range(N)]\n\nfor _ in range(M):\n  a,b = list(map(int, input().split()))\n  a,b = a-1, b-1\n  V[a].append(b)\n  V[b].append(a)\n  uf.union(a,b)\n  \nfor _ in range(K):\n  a,b = list(map(int, input().split()))\n  a,b = a-1, b-1\n  if uf.same(a,b):\n    V[a].append(b)\n    V[b].append(a)\n\nans = [-1] * N\nfor i in range(N):\n  ans[i] = uf.size(i) - len(V[i]) - 1\n  \nprint((\" \".join(list(map(str, ans)))))\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M,K=map(int,input().split())\ntree=UnionFind(N)\nnot_friend_candidates=[]\n\nfor i in range(M):\n  A,B=list(map(int,input().split()))\n  A-=1\n  B-=1\n  tree.union(A,B)\n  not_friend_candidates.append([A,B])\n\nfor j in range(K):\n  C,D=list(map(int,input().split()))\n  C-=1\n  D-=1\n  not_friend_candidates.append([C,D])\n\n\nans=[0]*N\nfor i,j in not_friend_candidates:\n  if tree.same(i,j):\n    ans[i]-=1\n    ans[j]-=1\nfor i in range(N):\n  ans[i]+=tree.size(i)-1\nprint(*ans)", "from collections import deque, Counter\nimport sys\n\nN_MAX = 100000 + 5\nsys.setrecursionlimit(N_MAX)\n\nN, M, K = map(int, sys.stdin.readline().rstrip().split())\n\nfr = [[] for _ in range(N)]  # \u53cb\u9054\u95a2\u4fc2\nfor _ in range(M):\n    a, b = map(int, sys.stdin.readline().rstrip().split())\n    fr[a - 1].append(b - 1)\n    fr[b - 1].append(a - 1)\n\nbl = [[] for _ in range(N)]  # \u30d6\u30ed\u30c3\u30af\u95a2\u4fc2\nfor _ in range(K):\n    a, b = map(int, sys.stdin.readline().rstrip().split())\n    bl[a - 1].append(b - 1)\n    bl[b - 1].append(a - 1)\n\n\ngr = [0] * N  # \u53cb\u9054\u5019\u88dc\u30b0\u30eb\u30fc\u30d7\n\n\n# ## BFS ## #\ndef bfs(u, num):\n\n    q = deque()\n    q.append(u)\n    gr[u] = num\n    while q:\n        u = q.popleft()\n        for v in fr[u]:\n            if gr[v] == 0:  # state \u3092\u78ba\u8a8d\n                gr[v] = num  # state \u3092\u5909\u66f4\n                q.append(v)\n\n\nnum = 1\nfor i in range(N):\n    if gr[i] == 0:\n        bfs(i, num)\n        num += 1\n\n# print(gr)\n\ngr_num = Counter(gr)  # \u30b0\u30eb\u30fc\u30d7\u306e\u4eba\u6570\u3092\u6570\u3048\u3066\u304a\u304f\n\n\n# \u30b0\u30eb\u30fc\u30d7\u306e\u4e2d\u304b\u3089\u3001\u53cb\u9054\u3067\u3082\nans = []\nfor i in range(N):\n    kouho_suu = gr_num[gr[i]]\n    for f in fr[i]:\n        if gr[i] == gr[f]:\n            kouho_suu -= 1\n    for b in bl[i]:\n        if gr[i] == gr[b]:\n            kouho_suu -= 1\n    kouho_suu -= 1\n\n    ans.append(kouho_suu)\n\nprint(*ans)", "n,m,k=map(int,input().split())\n\npar = [-1]*n\nnum = [0]*n\n\ndef find(x):\n    if par[x]<0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef union(x, y):\n    p,q=find(x), find(y)\n    if p==q:\n        return\n    if p>q:\n        p,q = q,p\n    par[p] += par[q]\n    par[q] = p\n\ndef size(x):\n    return -par[find(x)]\n\ndef same(x,y):\n    return find(x)==find(y)\n\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    union(a,b)\n    num[a]+=1\n    num[b]+=1\n\nfor i in range(k):\n    c,d=map(int,input().split())\n    c-=1\n    d-=1\n    if same(c,d):\n        num[c]+=1\n        num[d]+=1\n\nfor i in range(n):\n    print(size(i)-1-num[i], end=\" \")", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(m)]\nb = [0]*n\nuf = UnionFind(n)\nfor i in range(m):\n    uf.union(a[i][0]-1, a[i][1]-1)\nfor i in range(m+k):\n    x = list(map(int, input().split())) if i >= m else a[i]\n    if uf.same(x[0]-1, x[1]-1):\n        b[x[0]-1] += 1\n        b[x[1]-1] += 1\nfor i in range(n):\n    print(uf.size(i)-1-b[i],end=\" \")", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m,k=map(int,input().split())\nfriend=[[] for _ in range(n)]\nblock=[[] for _ in range(n)]\na=UnionFind(n)\nfor i in range(m):\n    x,y=map(int,input().split())\n    friend[x-1].append(y-1)\n    friend[y-1].append(x-1)\n    a.union(x-1,y-1)\nfor i in range(k):\n    x,y=map(int,input().split())\n    block[x-1].append(y-1)\n    block[y-1].append(x-1)\nans=[]\nfor i in range(n):\n    ans.append(a.size(i)-len(friend[i])-sum(a.same(i,j) for j in block[i])-1)\nprint(*ans)", "import numpy as np\nfrom scipy.sparse.csgraph import connected_components\nfrom scipy.sparse import csr_matrix\n\nimport sys\nsys.setrecursionlimit(10**9)\nn,m,k=[int(i) for i in input().split()]\nfrends_num=[0 for i in range(n)]\ndef make_frends(m,n):\n    data=[1 for i in range(m)]\n\n    row=[]\n    col=[]\n    for k in range(m):\n        i,j=[int(l) for l in input().split()]\n        new_i=min(i,j)-1\n        new_j=max(i,j)-1\n        row.append(new_i)\n        col.append(new_j)\n        frends_num[new_i]+=1\n        frends_num[new_j]+=1\n    frend_sparce_matrix=csr_matrix((data, (row, col)),shape=(n,n))\n    return frend_sparce_matrix\n\n\nfrends=make_frends(m,n)\nl,labels=connected_components(frends)\nlabels\nlabels=list(labels)\n\nclass Group:\n    def __init__(self,labels):\n        self.labels=labels\n        self.group_num=[0 for i in range(l)]\n        for i in labels:\n            self.group_num[i]+=1\n    def get_group_num(self,i):\n        return self.group_num[self.labels[i]]\n\ngroup=Group(labels)\n\n\ndef get_frend_num(i):\n    return frends_num[i]\n\n\ndef make_block(k,n):\n    block_num=[0 for i in range(n)]\n    for p in range(k):\n        i,j =[int(l)-1 for l in input().split()]\n        new_i=min(i,j)\n        new_j=max(i,j)\n        if labels[new_i]==labels[new_j]:\n            block_num[i]+=1\n            block_num[j]+=1\n    return block_num\n\nblock=make_block(k,n)\n\ndef get_block_num(i):\n    return block[i]\n\nans=[]\nfor i in range(n):\n    ans.append(str(group.get_group_num(i)-1-get_frend_num(i)-get_block_num(i)))\nprint((\" \".join(ans)))\n", "n,m,k=list(map(int,input().split()))\n\nimport sys\nsys.setrecursionlimit(10**9) #\u518d\u5e30\u306e\u4e0a\u9650\u3092\u3042\u3052\u308b\n\nroot=[-1 for i in range(n+1)] #\u81ea\u5206\u304c\u89aa\u306a\u3089\u30b0\u30eb\u30fc\u30d7\u306e\u4eba\u6570\u306e\u30de\u30a4\u30ca\u30b9\u500d\u3092\u3001\u305d\u3046\u3067\u306a\u3044\u306a\u3089\uff08\u5143\uff09\u89aa\u306e\u756a\u53f7\u3092\u793a\u3059\n\ndef r(x):   #\u89aa\u306f\u8ab0\uff1f\n    if root[x]<0:\n        return x\n    else:\n        root[x]=r(root[x])\n        return root[x]\n\ndef unite(x,y):\n    x=r(x)\n    y=r(y)\n    if x==y:\n        return\n    if x>y:\n        x,y=y,x\n    root[x]+=root[y]\n    root[y]=x\n\n\nfre=[[] for _ in range(n+1)]\nbro=[[] for _ in range(n+1)]\n\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    unite(a,b)\n    fre[a].append(b)\n    fre[b].append(a)\n\nfor i in range(k):\n    a, b = list(map(int, input().split()))\n    bro[a].append(b)\n    bro[b].append(a)\n\nans=[]\nfor i in range(1,n+1):\n    anser=-root[r(i)]-1\n    anser-=len(fre[i])\n    for j in bro[i]:\n        if r(i)==r(j):\n            anser-=1\n    ans.append(str(anser))\nprint((\" \".join(ans)))\n\n\n", "from collections import Counter\n\nN, M, K = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\nCD = [list(map(int, input().split())) for _ in range(K)]\n\nfriend_g = [set() for i in range(N)]\nfor a, b in AB:\n    a, b = a-1, b-1\n    friend_g[a].add(b)\n    friend_g[b].add(a)\nfriend_count = [len(s) for s in friend_g]\n\ng_nums = [-1]*N\ncurrent_g_num = 0\nfor i in range(N):\n    if g_nums[i] == -1:\n        g_nums[i] = current_g_num\n        q = [i]\n        while q:\n            t = q.pop()\n            for friend in friend_g[t]:\n                if g_nums[friend] == -1:\n                    g_nums[friend] = current_g_num\n                    q.append(friend)\n                # print(i, t, g_nums)\n        current_g_num += 1\n\nblock_count = [0]*N\nfor c, d in CD:\n    c, d = c-1, d-1\n    if g_nums[c] == g_nums[d]:\n        block_count[c] += 1\n        block_count[d] += 1\n\ng_nums_counter = Counter(g_nums)\nprint((*(g_nums_counter[g_nums[i]] - friend_count[i] - block_count[i] - 1 for i in range(N))))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n \n \nn, m, k = map(int, input().split())\nuf = UnionFind(n)\nfriend = [0]*n\n \nfor _ in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    uf.union(a, b)\n    friend[a] += 1\n    friend[b] += 1\n \nfor _ in range(k):\n    c, d = map(int, input().split())\n    c, d = c-1, d-1\n    if uf.same(c, d):\n        friend[c] += 1\n        friend[d] += 1\n \nans = [0]*n\nfor i in range(n):\n    ans[i] = uf.size(i) - friend[i] - 1\n \nprint(*ans)", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y] \n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n      \n    def get_size(self, x):\n        x = self.find(x)\n        return self.size[x]\n\nn,m,k=map(int,input().split())\nuf=UnionFind(n+1)\ncnt=[0]*(n+1)\nfor _ in range(m):\n  a,b=map(int,input().split())\n  uf.union(a,b)\n  cnt[a]+=1\n  cnt[b]+=1\nfor _ in range(k):\n  c,d=map(int,input().split())\n  if uf.is_same(c,d):\n    cnt[c]+=1\n    cnt[d]+=1\nfor i in range(1,n+1):\n  print(uf.get_size(i)-cnt[i]-1,end=' ')", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M, K = list(map(int, input().split()))\n\nuf = UnionFind(N+1)\nAB_list = []\n\nfor i in range(M):\n    A, B = list(map(int, input().split()))\n    AB_list.append([A, B])\n    uf.union(A, B)\n\ndame = [[] for i in range(N+1)]\nfor i in range(M):\n    if uf.same(AB_list[i][0], AB_list[i][1]):\n        dame[AB_list[i][0]].append(AB_list[i][1])\n        dame[AB_list[i][1]].append(AB_list[i][0])\n\nfor i in range(K):\n    C, D = list(map(int, input().split()))\n    if uf.same(C, D):\n        dame[C].append(D)\n        dame[D].append(C)\n\nans_list = []\nfor i in range(1, N+1):\n    ans_list.append(uf.size(i) - len(dame[i]) - 1)\n    #print(ans, uf.size(i), len(dame[i]))\nprint((*ans_list))\n", "import sys\ninput = sys.stdin.readline\n\nclass UnionFind:\n    def __init__(self, numV):\n        self.pars = list(range(numV))\n        self.ranks = [0] * numV\n        self.sizes = [1] * numV\n    def getRoot(self, x):\n        par = self.pars[x]\n        if par != x:\n            self.pars[x] = par = self.getRoot(par)\n        return par\n    def merge(self, x, y):\n        x, y = self.getRoot(x), self.getRoot(y)\n        sx, sy = self.sizes[x], self.sizes[y]\n        if x == y: return (0, 0)\n        if self.ranks[x] < self.ranks[y]:\n            self.pars[x] = y\n            self.sizes[y] += sx\n        else:\n            self.pars[y] = x\n            self.sizes[x] += sy\n            if self.ranks[x] == self.ranks[y]:\n                self.ranks[x] += 1\n        return (sx, sy)\n    def isSame(self, x, y):\n        return self.getRoot(x) == self.getRoot(y)\n    def updatePars(self):\n        for v in range(len(self.pars)):\n            self.getRoot(v)\n    def getSize(self, x):\n        return self.sizes[self.getRoot(x)]\n\nN, M, K = list(map(int, input().split()))\nUF = UnionFind(N)\nanss = [-1] * N\nfor _ in range(M):\n    A, B = list(map(int, input().split()))\n    A, B = A-1, B-1\n    UF.merge(A, B)\n    anss[A] -= 1\n    anss[B] -= 1\n\nfor i in range(N):\n    anss[i] += UF.getSize(i)\n\nfor _ in range(K):\n    C, D = list(map(int, input().split()))\n    C, D = C-1, D-1\n    if UF.isSame(C, D):\n        anss[C] -= 1\n        anss[D] -= 1\n\nprint((' '.join(map(str, anss))))\n", "import sys\nsys.setrecursionlimit(10**9)\nn,m,k=map(int,input().split())\nfriend=[[] for _ in range(n)]\nblock=[[] for _ in range(n)]\nfor _ in range(m):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    friend[a].append(b)\n    friend[b].append(a)\nfor _ in range(k):\n    c,d=map(int,input().split())\n    c-=1\n    d-=1\n    block[c].append(d)\n    block[d].append(c)\nseen=[-1]*n\ndef dfs(graph,v,top):\n    seen[v]=top\n    top_count[top]+=1\n    for nv in graph[v]:\n        if seen[nv]!=-1:\n            continue\n        dfs(graph,nv,top)\ntop=0\ntop_count=[0]\nfor v in range(n):\n    count=0\n    if seen[v]!=-1:\n        continue\n    dfs(friend,v,top)\n    top_count.append(0)\n    top+=1\n\n\nfor i in range(n):\n    ans=top_count[seen[i]]-len(friend[i])-1\n    cnt=0\n    for v in block[i]:\n        if seen[v]==seen[i]:\n            cnt+=1\n    ans-=cnt\n    print(ans,end=' ')", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return \"\\n\".join(\"{}: {}\".format(r, self.members(r)) for r in self.roots())\n\n\nn, m, k = list(map(int, input().split()))\n\n\nfriends = UnionFind(n)\ndirect_friends = [0] * n\nenemies = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    direct_friends[a] += 1\n    direct_friends[b] += 1\n    friends.union(a, b)\n\nfor i in range(k):\n    c, d = list(map(int, input().split()))\n    c -= 1\n    d -= 1\n    enemies[c].append(d)\n    enemies[d].append(c)\n\nans = []\nfor i in range(n):\n    num = friends.size(i) - 1 - direct_friends[i]\n    for enm in enemies[i]:\n        if friends.same(i, enm):\n            num -= 1\n    ans.append(num)\n\nprint((*ans))\n\n", "from collections import deque\n\nN, M, K = list(map(int, input().split()))\nfriend = [list(map(int, input().split())) for _ in range(M)]\nblock = [list(map(int, input().split())) for _ in range(K)]\n\nf = [set() for _ in range(N + 1)]\nb = [set() for _ in range(N + 1)]\n\nfor i, j in friend:\n    f[i].add(j)\n    f[j].add(i)\nfor i, j in block:\n    b[i].add(j)\n    b[j].add(i)\n\nstack = deque()\nans = [0] * (N + 1)\nvisited = [0] * (N + 1)\n\nfor i in range(1, N + 1):\n    if visited[i]:\n        continue\n    # set\u306f{}\u3067\u66f8\u304f\n    link = {i}\n    stack.append(i)\n    visited[i] = 1\n    while stack:\n        n = stack.pop()\n        # n\u306e\u30d5\u30ec\u30f3\u30c9\u5168\u54e1\u306b\u3064\u3044\u3066\n        for j in f[n]:\n            if visited[j] == 0:\n                stack.append(j)\n                visited[j] = 1\n                # link(set)\u306b\u8ffd\u52a0\n                link.add(j)\n    for i in link:\n        # \u5168\u4f53-\u65e2\u306b\u30d5\u30ec\u30f3\u30c9\u306e\u4eba\u6570-\u30d6\u30ed\u30c3\u30af\u3057\u305f\u4eba\u6570-\u81ea\u5206\u81ea\u8eab\n        # set\u540c\u58eb\u3067\u7a4d\u96c6\u5408\u3092\u3068\u308b\n        ans[i] = len(link) - len(link & f[i]) - len(link & b[i]) - 1\n\nprint((*ans[1:]))\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[14]:\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n# In[ ]:\n\n\nN,M,K=list(map(int,input().split()))\ntree=UnionFind(N)\nnot_friend_candidates=[]\n\n\n# In[ ]:\n\n\nfor i in range(M):\n  A,B=list(map(int,input().split()))\n  A-=1\n  B-=1\n  tree.union(A,B)\n  not_friend_candidates.append([A,B])\n\nfor j in range(K):\n  C,D=list(map(int,input().split()))\n  C-=1\n  D-=1\n  not_friend_candidates.append([C,D])\n\n\nans=[0]*N\nfor i,j in not_friend_candidates:\n  if tree.same(i,j):\n    ans[i]-=1\n    ans[j]-=1\nfor i in range(N):\n  ans[i]+=tree.size(i)-1\nprint((*ans))\n\n", "from collections import deque\nf=lambda:list(map(int,input().split()))\nr=range\nn,m,k=f()\nF=[deque([])for _ in r(n)]\nA=[0]*n\nB=[-1]*n\nC=[-1]*n\nQ=deque([])\nfor _ in r(m):a,b=f();a-=1;b-=1;F[a].append(b);F[b].append(a);A[a]+=1;A[b]+=1\nfor i in r(n):\n  Q.append(x:=i)\n  y=0\n  while Q:\n    z=Q.popleft()\n    if B[z]>-1:continue\n    B[z]=x\n    Q.extend(F[z])\n    y+=1\n  C[x]=y\nD=[[B[i],C[B[i]]-A[i]-1]for i in r(n)]\nfor _ in r(k):\n  c,d=f()\n  c,d=c-1,d-1\n  if D[c][0]==D[d][0]:D[c][1]-=1;D[d][1]-=1\nprint((*[d[1] for d in D]))\n", "#UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m,k = map(int,input().split())\nV = [[] for i in range(n+1)]\nW = [0]*(n+1)\nuf = UnionFind(n+1)\nfor _ in range(m):\n    a,b = map(int,input().split())\n    V[a].append(b)\n    V[b].append(a)\n    uf.union(a,b)\nfor _ in range(k):\n    c,d = map(int,input().split())\n    if uf.find(d) == uf.find(c):\n        W[c] += 1\n        W[d] += 1\n    \nfor i in range(1,n+1):\n    ans = uf.size(i) - len(V[i]) - W[i] - 1\n    print(ans,end=\"\")\n    print(\" \",end=\"\")\nprint()", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1]*n\n    \n    def root(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            return self.root(self.parents[x])\n    \n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        else:\n            if x > y:\n                x, y = y, x\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            return\n\nn, m, k = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\ncd = [list(map(int, input().split())) for _ in range(k)]\n\nu = UnionFind(n)\nf = [set() for _ in range(n)]\nl = [set() for _ in range(n)]\nfor a, b in ab:\n    a, b = a-1, b-1\n    f[a].add(b)\n    f[b].add(a)\n    u.unite(a, b)\nfor c, d in cd:\n    c, d = c-1, d-1\n    l[c].add(d)\n    l[d].add(c)\nans = [0] * n\nfor i in range(n):\n    r = u.root(i)\n    bl = 0\n    for j in l[i]:\n        if u.root(j) == r:\n            bl += 1\n    ans[i] = -u.parents[r] - len(f[i]) - bl - 1\nprint(*ans)", "import sys\nfrom collections import Counter as cc\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.height = [0]*n\n\n    def get_root(self, i):\n        if self.parent[i] == i:\n            return i\n        else:\n            self.parent[i] = self.get_root(self.parent[i])\n            return self.parent[i]\n        \n    def unite(self, i, j):\n        root_i = self.get_root(i)\n        root_j = self.get_root(j)\n        if root_i != root_j:\n            if self.height[root_i] < self.height[root_j]:\n                self.parent[root_i] = root_j\n            else:\n                self.parent[root_j] = root_i\n                if self.height[root_i] == self.height[root_j]:\n                    self.height[root_i] += 1\n    \n    def is_in_group(self, i, j):\n        if self.get_root(i) == self.get_root(j):\n            return True\n        else:\n            return False\n\n\ndef main():\n    n, m, k= mi()   \n    e = [0]*n\n    uf = UnionFind(n)     \n    for i in range(m):\n        a, b = mi()\n        a-=1\n        b-=1\n        e[a]-= 1\n        e[b]-= 1\n        uf.unite(a,b)\n    \n    \n    for _ in range(k):\n        a,b = mi()\n        a-=1\n        b-=1\n        if uf.is_in_group(a,b):\n            e[a] -= 1\n            e[b] -= 1\n        \n    for i in range(n):\n        uf.get_root(i)\n    s = cc(uf.parent)\n    for i in range(n):\n        x = uf.get_root(i)\n        e[i] += s[x]-1\n    print(*e)\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\n \nN, M, K = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\nCD = [list(map(int, input().split())) for _ in range(K)]\n \nfriend_g = [set() for i in range(N)]\nfor a, b in AB:\n    a, b = a-1, b-1\n    friend_g[a].add(b)\n    friend_g[b].add(a)\nfriend_count = [len(s) for s in friend_g]\n \ng_nums = [-1]*N\ncurrent_g_num = 0\nfor i in range(N):\n    if g_nums[i] == -1:\n        g_nums[i] = current_g_num\n        q = [i]\n        while q:\n            t = q.pop()\n            for friend in friend_g[t]:\n                if g_nums[friend] == -1:\n                    g_nums[friend] = current_g_num\n                    q.append(friend)\n                # print(i, t, g_nums)\n        current_g_num += 1\n \nblock_count = [0]*N\nfor c, d in CD:\n    c, d = c-1, d-1\n    if g_nums[c] == g_nums[d]:\n        block_count[c] += 1\n        block_count[d] += 1\n \ng_nums_counter = Counter(g_nums)\nprint(*(g_nums_counter[g_nums[i]] - friend_count[i] - block_count[i] - 1 for i in range(N)))", "import sys\nsys.setrecursionlimit(10**5)\n\nn,m,k = list(map(int, input().split()))\n\nF = [[] for _ in range(n+1)]\nB = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    x,y = list(map(int, input().split()))\n    F[x].append(y)\n    F[y].append(x)\n\nfor _ in range(k):\n    x,y = list(map(int, input().split()))\n    B[x].append(y)\n    B[y].append(x)\n\nbelongs = [-1 for _ in range(n+1)]\ngroup_ID = 0\n\ndef f_search(root, group_ID):\n    for j in F[root]:\n        if belongs[j] == -1:\n            belongs[j] = group_ID\n            f_search(j, group_ID)\n\nfor i in range(n+1):\n    if belongs[i] == -1:\n        belongs[i] = group_ID\n        f_search(i, group_ID)\n        group_ID += 1\n\ncnt_members = [0 for _ in range(len(set(belongs)))]\nfor i in belongs[1:]:\n    cnt_members[i] += 1\n\nans = [0 for _ in range(n+1)]\nfor i in range(1, n+1):\n    tmp = 0\n    for j in B[i]:\n        if belongs[j] == belongs[i]:\n            tmp += 1\n    ans[i] = cnt_members[belongs[i]] - 1 - len(F[i]) - tmp\n\nprint((*ans[1:]))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn,m,k=map(int,input().split())\nuf=UnionFind(n)\nfriend=[[] for _ in range(n)]\nbrock=[[] for _ in range(n)]\nans=[]\nfor _ in range(m):\n    a,b=map(int,input().split())\n    friend[a-1].append(b-1)\n    friend[b-1].append(a-1)\n    uf.union(a-1,b-1)\nfor _ in range(k):\n    c,d=map(int,input().split())\n    brock[c-1].append(d-1)\n    brock[d-1].append(c-1)\nfor i in range(n):\n    ans.append(uf.size(i)-len(friend[i])-sum([uf.same(i,j) for j in brock[i]])-1)\nprint(*ans)", "from collections import deque\nimport numpy as np\n\nN, M, K = [int(x) for x in input().split()]\n\nfriends = [[] for _ in range(N + 1)]\nfor i in range(M):\n    A, B = [int(x) for x in input().split()]\n    friends[A].append(B)\n    friends[B].append(A)\n\nblock = [[] for _ in range(N + 1)]\nfor i in range(K):\n    C, D = [int(x) for x in input().split()]\n    block[C].append(D)\n    block[D].append(C)\n\nG = []\ncheck = [False] * (N + 1)\nfor i in range(1, N + 1):\n    if check[i] == False:\n        check[i] = True\n        g = [i]\n        q = deque([i])\n        while q:\n            j = q.popleft()\n            for k in friends[j]:\n                if check[k] == False:\n                    check[k] = True\n                    g.append(k)\n                    q.append(k)\n        G.append(g)\n\ngr = np.array([0] * (N + 1))\nfr = np.array([len(friends[i]) for i in range(N + 1)])\nbl = np.array([0] * (N + 1))\n\nfor g in G:\n    s = set(g)\n    for v in g:\n        gr[v] = len(g)\n        b = set(block[v])\n        bl[v] = len(s & b)\n\nans = gr - fr - bl - np.array([1] * (N + 1))\n\nfor i in range(1, N + 1):\n    print(ans[i], end='')\n    if i == N:\n        print('')\n    else:\n        print(' ', end='')"]
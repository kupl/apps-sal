["__author__ = 'Gleb'\n\nfrom time import time\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nn, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = map(int, input().split())\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s, t)", "from collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\nimport bisect,sys,threading\nmod = 10**9 + 7\n\ndef dfs_order(i,visited,G,order):\n    if visited[i]: return\n    visited[i] = 1\n    for j in G[i]:\n        dfs_order(j,visited,G,order)\n    order.append(i)\n\ndef dfs_scc(leader,s,RG,visited,comp,cost):\n    if visited[s]: return\n    visited[s] = 1\n    for j in RG[s]:\n        dfs_scc(leader,j,RG,visited,comp,cost)\n    comp[leader].append(cost[s])\n\ndef main():\n    n = int(input())\n    cost = [0]+[int(i) for i in input().split()]\n    m = int(input())\n    G = [[] for i in range(n+1)]\n    RG = [[] for i in range(n+1)]\n    for i in range(m):\n        a,b = map(int,input().split())\n        G[a].append(b)\n        RG[b].append(a)\n    order = deque()\n    visited = [0]*(n+1)\n    for i in range(1,n+1):\n        if not visited[i]:\n            dfs_order(i,visited,G,order)\n\n    visited = [0]*(n+1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now,now,RG,visited,comp,cost)\n\n    ans1,ans2 = 0,1\n    for k , v in comp.items():\n        v = sorted(v)\n        ans1 += v[0]\n        poss = bisect.bisect_right(v,v[0])\n        ans2 = (ans2*poss + mod)%mod\n\n    print(ans1,ans2)\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "from collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\nimport bisect,sys,threading\nmod = 10**9 + 7\n\ndef dfs_order(i,visited,G,order):\n    if visited[i]: return\n    visited[i] = 1\n    for j in G[i]:\n        dfs_order(j,visited,G,order)\n    order.append(i)\n\ndef dfs_scc(leader,s,RG,visited,comp,cost):\n    if visited[s]: return\n    visited[s] = 1\n    for j in RG[s]:\n        dfs_scc(leader,j,RG,visited,comp,cost)\n    comp[leader].append(cost[s])\n\ndef main():\n    n = int(input())\n    cost = [0]+[int(i) for i in input().split()]\n    m = int(input())\n    G = [[] for i in range(n+1)]\n    RG = [[] for i in range(n+1)]\n    for i in range(m):\n        a,b = map(int,input().split())\n        G[a].append(b)\n        RG[b].append(a)\n    order = deque()\n    visited = [0]*(n+1)\n    for i in range(1,n+1):\n        if not visited[i]:\n            dfs_order(i,visited,G,order)\n\n    visited = [0]*(n+1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now,now,RG,visited,comp,cost)\n\n    ans1,ans2 = 0,1\n    for k , v in comp.items():\n        v = sorted(v)\n        ans1 += v[0]\n        poss = bisect.bisect_right(v,v[0])\n        ans2 = (ans2*poss + mod)%mod\n\n    print(ans1,ans2)\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "from collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\nimport bisect,sys,threading\nmod = 10**9 + 7\n\ndef dfs_order(i,visited,G,order):\n    if visited[i]: return\n    visited[i] = 1\n    for j in G[i]:\n        dfs_order(j,visited,G,order)\n    order.append(i)\n\ndef dfs_scc(leader,s,RG,visited,comp,cost):\n    if visited[s]: return\n    visited[s] = 1\n    for j in RG[s]:\n        dfs_scc(leader,j,RG,visited,comp,cost)\n    comp[leader].append(cost[s])\n\ndef main():\n    n = int(input())\n    cost = [0] + [int(i) for i in input().split()]\n    m = int(input())\n    G = [[] for i in range(n + 1)]\n    RG = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        G[a].append(b)\n        RG[b].append(a)\n    order = deque()\n    visited = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_order(i, visited, G, order)\n\n    visited = [0] * (n + 1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now, now, RG, visited, comp, cost)\n\n    ans1, ans2 = 0, 1\n    for k, v in comp.items():\n        v = sorted(v)\n        ans1 += v[0]\n        poss = bisect.bisect_right(v, v[0])\n        ans2 = (ans2 * poss + mod) % mod\n\n    print(ans1, ans2)\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "from collections import defaultdict, deque, Counter, OrderedDict\nfrom heapq import heappop, heappush\nimport bisect, sys, threading\n#2\nmod = 10 ** 9 + 7\n\n\ndef dfs_order(i, visited, G, order):\n    if visited[i]: return\n    visited[i] = 1\n    for j in G[i]:\n        dfs_order(j, visited, G, order)\n    order.append(i)\n\n\ndef dfs_scc(leader, s, RG, visited, comp, cost):\n    if visited[s]: return\n    visited[s] = 1\n    for j in RG[s]:\n        dfs_scc(leader, j, RG, visited, comp, cost)\n    comp[leader].append(cost[s])\n\n\ndef main():\n    n = int(input())\n    cost = [0] + [int(i) for i in input().split()]\n    m = int(input())\n    G = [[] for i in range(n + 1)]\n    RG = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        G[a].append(b)\n        RG[b].append(a)\n    order = deque()\n    visited = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_order(i, visited, G, order)\n\n    visited = [0] * (n + 1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now, now, RG, visited, comp, cost)\n\n    ans1, ans2 = 0, 1\n    for k, v in list(comp.items()):\n        v = sorted(v)\n        ans1 += v[0]\n        poss = bisect.bisect_right(v, v[0])\n        ans2 = (ans2 * poss + mod) % mod\n\n    print(ans1, ans2)\n\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "######\nfrom collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\nimport bisect,sys,threading\nmod = 10**9 + 7\n\ndef dfs_order(i,visited,G,order):\n    if visited[i]: return\n    visited[i] = 1\n    for j in G[i]:\n        dfs_order(j,visited,G,order)\n    order.append(i)\n\ndef dfs_scc(leader,s,RG,visited,comp,cost):\n    if visited[s]: return\n    visited[s] = 1\n    for j in RG[s]:\n        dfs_scc(leader,j,RG,visited,comp,cost)\n    comp[leader].append(cost[s])\n\ndef main():\n    n = int(input())\n    cost = [0] + [int(i) for i in input().split()]\n    m = int(input())\n    G = [[] for i in range(n + 1)]\n    RG = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        G[a].append(b)\n        RG[b].append(a)\n    order = deque()\n    visited = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_order(i, visited, G, order)\n\n    visited = [0] * (n + 1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now, now, RG, visited, comp, cost)\n\n    ans1, ans2 = 0, 1\n    for k, v in comp.items():\n        v = sorted(v)\n        ans1 += v[0]\n        poss = bisect.bisect_right(v, v[0])\n        ans2 = (ans2 * poss + mod) % mod\n\n    print(ans1, ans2)\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "from time import time\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nn, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = map(int, input().split())\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s, t)", "from collections import defaultdict, deque\nfrom bisect import bisect\nfrom sys import setrecursionlimit\nfrom threading import stack_size, Thread\nMOD = 10 ** 9 + 7\n\n\ndef dfs_order(i, visited, g, order):\n    if visited[i]:\n        return\n    visited[i] = 1\n    for j in g[i]:\n        dfs_order(j, visited, g, order)\n    order.append(i)\n\n\ndef dfs_scc(leader, s, rg, visited, comp, cost):\n    if visited[s]:\n        return\n    visited[s] = 1\n    for j in rg[s]:\n        dfs_scc(leader, j, rg, visited, comp, cost)\n    comp[leader].append(cost[s])\n\n\ndef main():\n    n = int(input())\n    cost = [0] + [int(i) for i in input().split()]\n    m = int(input())\n    g = [[] for i in range(n + 1)]\n    rg = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        g[a].append(b)\n        rg[b].append(a)\n\n    order = deque()\n    visited = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_order(i, visited, g, order)\n    #print(order)\n\n    visited = [0] * (n + 1)\n    comp = defaultdict(list)\n    while order:\n        now = order.pop()\n        if not visited[now]:\n            dfs_scc(now, now, rg, visited, comp, cost)\n    #print(comp)\n\n    ans1, ans2 = 0, 1\n    for key, values in comp.items():\n        values = sorted(values)\n        ans1 += values[0]\n        position = bisect(values, values[0])\n        ans2 = (ans2 * position + MOD) % MOD\n    print(ans1, ans2)\nsetrecursionlimit(MOD)\nstack_size(102400000)\nt = Thread(target=main)\nt.start()", "from sys import stdin\n\n\ndef main():\n    n = int(input())\n    costs = list(map(int, input().split()))\n    input()\n    chlds, prnts = [[] for _ in range(n)], [[] for _ in range(n)]\n    for total in stdin.read().splitlines():\n        u, v = list(map(int, total.split()))\n        chlds[u - 1].append(v - 1)\n        prnts[v - 1].append(u - 1)\n    total, ways, pool = 0, 1, {i for i in range(n) if not (prnts[i] and chlds[i])}\n    while pool:\n        u = pool.pop()\n        total += costs[u]\n        for v in prnts[u]:\n            chlds[v].remove(u)\n            if not chlds[v]:\n                pool.add(v)\n        for v in chlds[u]:\n            prnts[v].remove(u)\n            if not prnts[v]:\n                pool.add(v)\n    pool = {u for u in range(n) if prnts[u] and chlds[u]}\n    while pool:\n        u = pool.pop()\n        pp = prnts[u]\n        cost, cnt = costs[u], 1\n        while pp:\n            u = pp.pop()\n            if u in pool:\n                pool.remove(u)\n                pp += prnts[u]\n                if costs[u] == cost:\n                    cnt += 1\n                elif costs[u] < cost:\n                    cost, cnt = costs[u], 1\n        total += cost\n        ways = (ways * cnt) % 1000000007\n    print(total, ways)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\n\n\ndef main():\n    n = int(input())\n    costs = list(map(int, input().split()))\n    input()\n    chlds, prnts = [[] for _ in range(n)], [[] for _ in range(n)]\n    for total in stdin.read().splitlines():\n        u, v = list(map(int, total.split()))\n        chlds[u - 1].append(v - 1)\n        prnts[v - 1].append(u - 1)\n    total, ways, childless, orphans = sum(costs), 1, [], []\n    for i, cc, pp in zip(list(range(n)), chlds, prnts):\n        if not (cc or pp):\n            costs[i] = 0\n        elif not cc:\n            childless.append(i)\n        elif not pp:\n            orphans.append(i)\n    while childless:\n        u = childless.pop()\n        costs[u] = 0\n        for v in prnts[u]:\n            chlds[v].remove(u)\n            if not chlds[v]:\n                childless.append(v)\n    while orphans:\n        u = orphans.pop()\n        costs[u] = 0\n        for v in chlds[u]:\n            prnts[v].remove(u)\n            if not prnts[v]:\n                orphans.append(v)\n    total -= sum(costs)\n    pool = {u for u in range(n) if prnts[u] and chlds[u]}\n    while pool:\n        u = pool.pop()\n        pp = prnts[u]\n        cost, cnt = costs[u], 1\n        while pp:\n            u = pp.pop()\n            if u in pool:\n                pool.remove(u)\n                pp += prnts[u]\n                if costs[u] == cost:\n                    cnt += 1\n                elif costs[u] < cost:\n                    cost, cnt = costs[u], 1\n        total += cost\n        ways = (ways * cnt) % 1000000007\n    print(total, ways)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\n\n\ndef main():\n    n, costs = int(input()), list(map(int, input().split()))\n    input()\n    chlds, prnts = [[] for _ in range(n)], [[] for _ in range(n)]\n    for total in stdin.read().splitlines():\n        u, v = list(map(int, total.split()))\n        chlds[u - 1].append(v - 1)\n        prnts[v - 1].append(u - 1)\n    avail, order = [True] * n, []\n    for u, f in enumerate(avail):\n        if f:\n            avail[u], stack = False, [u, prnts[u]]\n            while stack:\n                while stack[-1]:\n                    u = stack[-1].pop()\n                    if avail[u]:\n                        avail[u] = False\n                        stack.append(u)\n                        stack.append(prnts[u])\n                del stack[-1]\n                order.append(stack.pop())\n    avail, res, cnt, ways = [True] * n, 0, 0, 1\n    while order:\n        u = order.pop()\n        if avail[u]:\n            avail[u], stack, cst, cnt = False, chlds[u], costs[u], 0\n            while stack:\n                u = stack.pop()\n                if avail[u]:\n                    avail[u] = False\n                    if cst > costs[u]:\n                        cst, cnt = costs[u], 0\n                    elif cst == costs[u]:\n                        cnt += 1\n                    stack += chlds[u]\n            res += cst\n            if cnt:\n                ways = (ways * (cnt + 1)) % 1000000007\n    print(res, ways)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "__author__ = 'Gleb'\n\n\n\nfrom time import time\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nn, m = int(input()) + 1, 1000000007\n\nq, p = [[] for i in range(n)], [[] for i in range(n)]\n\nw = [0] + list(map(int, input().split()))\n\nfor i in range(int(input())):\n\n    u, v = list(map(int, input().split()))\n\n    p[u].append(v)\n\n    q[v].append(u)\n\nr = set(i for i in range(1, n) if not p[i] or not q[i])\n\ns, t = 0, 1\n\nwhile r:\n\n    i = r.pop()\n\n    s += w[i]\n\n    for j in p[i]:\n\n        q[j].remove(i)\n\n        if not q[j]: r.add(j)\n\n    for j in q[i]:\n\n        p[j].remove(i)\n\n        if not p[j]: r.add(j)\n\nr = set(i for i in range(1, n) if p[i] and q[i])\n\nwhile r:\n\n    i = r.pop()\n\n    h = p[i]\n\n    d, k = w[i], 1\n\n    while h:\n\n        i = h.pop()\n\n        if not i in r: continue\n\n        r.remove(i)\n\n        h += p[i]\n\n        if w[i] == d: k += 1\n\n        elif w[i] < d: d, k = w[i], 1\n\n    s += d\n\n    t = (t * k) % m\n\nprint(s, t)\n\n\n\n# Made By Mostafa_Khaled\n", "n, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = map(int, input().split())\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s,t)", "from collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\n\nmod = 1000000007\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    class graph:\n        # initialize graph\n        def __init__(self, gdict=None):\n            if gdict is None:\n                gdict = defaultdict(list)\n            self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n        # add edge\n        def addEdge(self, node1, node2, w=None):\n            if w != None:\n                self.gdict[node1].append([node2, w])\n                self.gdict[node2].append([node1, w])\n            else:\n                self.gdict[node1].append(node2)\n                # self.gdict[node2].append(node1)\n            self.edges.append([node1, node2, w])\n            self.l[node1] += 1\n            self.l[node2] += 1\n\n        def scc_utils(self, v):\n\n            # initilaize time and disc\n            self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n            self.time += 1\n            self.st.append(v)\n\n            # loop edges\n            for i in self.gdict[v]:\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n                    self.low[v] = min(self.low[v], self.low[i])\n\n                elif self.stack[i]:\n                    self.low[v] = min(self.low[v], self.disc[i])\n\n                # print founded scc\n            if self.low[v] == self.disc[v]:\n                node, mem = -1, defaultdict(int)\n                while node != v:\n                    node = self.st.pop()\n                    # print(node, end=' ')\n                    self.stack[node] = 0\n                    mem[cost[node - 1]] += 1\n                # print(end='\\n')\n\n                self.count += min(mem)\n                self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n\n        def scc(self, n):\n            self.time, self.count, self.mi = 0, 0, 1\n            self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n            for i in range(1, n + 1):\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n\n            print(self.count, self.mi)\n\n    n, cost, m, g = int(input()), arr_inp(1), int(input()), graph()\n    for i in range(m):\n        u, v = arr_inp(1)\n        g.addEdge(u, v)\n    g.scc(n)\n\n\ndef __starting_point():\n    setrecursionlimit(200000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\n\nmod = 1000000007\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    class graph:\n        # initialize graph\n        def __init__(self, gdict=None):\n            if gdict is None:\n                gdict = defaultdict(list)\n            self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n        # add edge\n        def addEdge(self, node1, node2, w=None):\n            if w != None:\n                self.gdict[node1].append([node2, w])\n                self.gdict[node2].append([node1, w])\n            else:\n                self.gdict[node1].append(node2)\n                # self.gdict[node2].append(node1)\n            self.edges.append([node1, node2, w])\n            self.l[node1] += 1\n            self.l[node2] += 1\n\n        def scc_utils(self, v):\n\n            # initilaize time and disc\n            self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n            self.time += 1\n            self.st.append(v)\n\n            # loop edges\n            for i in self.gdict[v]:\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n                    self.low[v] = min(self.low[v], self.low[i])\n\n                elif self.stack[i]:\n                    self.low[v] = min(self.low[v], self.disc[i])\n\n                # print founded scc\n            if self.low[v] == self.disc[v]:\n                node, mem = -1, defaultdict(int)\n                while node != v:\n                    node = self.st.pop()\n                    # print(node, end=' ')\n                    self.stack[node] = 0\n                    mem[cost[node - 1]] += 1\n                # print(end='\\n')\n\n                self.count += min(mem)\n                self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n\n        def scc(self, n):\n            self.time, self.count, self.mi = 0, 0, 1\n            self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n            for i in range(1, n + 1):\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n\n            print(self.count, self.mi)\n\n    n, cost, m, g = int(input()), arr_inp(1), int(input()), graph()\n    for i in range(m):\n        u, v = arr_inp(1)\n        g.addEdge(u, v)\n    g.scc(n)\n\n\ndef __starting_point():\n    setrecursionlimit(100000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\n\nmod = 1000000007\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    class graph:\n        # initialize graph\n        def __init__(self, gdict=None):\n            if gdict is None:\n                gdict = defaultdict(list)\n            self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n        # add edge\n        def addEdge(self, node1, node2, w=None):\n            self.gdict[node1].append(node2)\n            # self.gdict[node2].append(node1)\n            # self.edges.append([node1, node2, w])\n            # self.l[node1] += 1\n            # self.l[node2] += 1\n\n        def scc_utils(self, v):\n\n            # initilaize time and disc\n            self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n            self.time += 1\n            self.st.append(v)\n\n            # loop edges\n            for i in self.gdict[v]:\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n                    self.low[v] = min(self.low[v], self.low[i])\n\n                elif self.stack[i]:\n                    self.low[v] = min(self.low[v], self.disc[i])\n\n                # print founded scc\n            if self.low[v] == self.disc[v]:\n                node, mem = -1, defaultdict(int)\n                while node != v:\n                    node = self.st.pop()\n                    # print(node, end=' ')\n                    self.stack[node] = 0\n                    mem[cost[node - 1]] += 1\n                # print(end='\\n')\n\n                self.count += min(mem)\n                self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n\n        def scc(self, n):\n            self.time, self.count, self.mi = 0, 0, 1\n            self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n            for i in range(1, n + 1):\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n\n            print(self.count, self.mi)\n\n    n, cost, m, g = int(input()), arr_inp(1), int(input()), graph()\n    for i in range(m):\n        u, v = arr_inp(1)\n        g.addEdge(u, v)\n    g.scc(n)\n\n\ndef __starting_point():\n    setrecursionlimit(100000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\n\nmod = 1000000007\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    class graph:\n        # initialize graph\n        def __init__(self, gdict=None):\n            if gdict is None:\n                gdict = defaultdict(list)\n            self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n        # add edge\n        def addEdge(self, node1, node2, w=None):\n            self.gdict[node1].append(node2)\n            # self.gdict[node2].append(node1)\n            # self.edges.append([node1, node2, w])\n            # self.l[node1] += 1\n            # self.l[node2] += 1\n\n        def scc_utils(self, v):\n\n            # initilaize time and disc\n            self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n            self.time += 1\n            self.st.append(v)\n\n            # loop edges\n            for i in self.gdict[v]:\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n                    self.low[v] = min(self.low[v], self.low[i])\n\n                elif self.stack[i]:\n                    self.low[v] = min(self.low[v], self.disc[i])\n\n                # print founded scc\n            if self.low[v] == self.disc[v]:\n                node, mem = -1, defaultdict(int)\n                while node != v:\n                    node = self.st.pop()\n                    # print(node, end=' ')\n                    self.stack[node] = 0\n                    mem[cost[node - 1]] += 1\n                # print(end='\\n')\n\n                self.count += min(mem)\n                self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n\n        def scc(self, n):\n            self.time, self.count, self.mi = 0, 0, 1\n            self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n            for i in range(1, n + 1):\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n\n            print(self.count, self.mi)\n\n    n, cost, m, g = int(input()), arr_inp(1), int(input()), graph()\n    for i in range(m):\n        u, v = arr_inp(1)\n        g.addEdge(u, v)\n    g.scc(n)\n\n\ndef __starting_point():\n    setrecursionlimit(80000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\n\nmod = 1000000007\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    class graph:\n        # initialize graph\n        def __init__(self, gdict=None):\n            if gdict is None:\n                gdict = defaultdict(list)\n            self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n        # add edge\n        def addEdge(self, node1, node2, w=None):\n            self.gdict[node1].append(node2)\n            # self.gdict[node2].append(node1)\n            # self.edges.append([node1, node2, w])\n            # self.l[node1] += 1\n            # self.l[node2] += 1\n\n        def scc_utils(self, v):\n\n            # initilaize time and disc\n            self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n            self.time += 1\n            self.st.append(v)\n\n            # loop edges\n            for i in self.gdict[v]:\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n                    self.low[v] = min(self.low[v], self.low[i])\n\n                elif self.stack[i]:\n                    self.low[v] = min(self.low[v], self.disc[i])\n\n                # print founded scc\n            if self.low[v] == self.disc[v]:\n                node, mem = -1, defaultdict(int)\n                while node != v:\n                    node = self.st.pop()\n                    # print(node, end=' ')\n                    self.stack[node] = 0\n                    mem[cost[node - 1]] += 1\n                # print(end='\\n')\n\n                self.count += min(mem)\n                self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n\n        def scc(self, n):\n            self.time, self.count, self.mi = 0, 0, 1\n            self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n            for i in range(1, n + 1):\n                if self.disc[i] == -1:\n                    self.scc_utils(i)\n\n            print(self.count, self.mi)\n\n    n, cost, m, g = int(input()), arr_inp(1), int(input()), graph()\n    for i in range(m):\n        u, v = arr_inp(1)\n        g.addEdge(u, v)\n    g.scc(n)\n\n\ndef __starting_point():\n    setrecursionlimit(50000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "def main():\n\n    from bisect import bisect_left as bl, bisect_right as br, insort\n    import sys,math\n    #from heapq import heapify, heappush, heappop\n    from collections import defaultdict as dd, deque\n    def data(): return sys.stdin.readline().strip()\n    def mdata(): return list(map(int, data().split()))\n    out = sys.stdout.write\n    # sys.setrecursionlimit(100000)\n    INF = float(\"INF\")\n    mod = int(1e9)+7\n\n    def kosaraju():\n        stack = []\n        s = []\n        vis = [0] * n\n        for i in range(n):\n            if vis[i] == 0:\n                s.append(i)\n                while s:\n                    a = s[-1]\n                    if vis[a]==1:\n                        stack.append(s.pop())\n                        vis[a] = 2\n                        continue\n                    elif vis[a]==2:\n                        s.pop()\n                        continue\n                    vis[a] = 1\n                    for i in g[a]:\n                        if vis[i] == 0:\n                            s.append(i)\n        stack=stack[::-1]\n        comp = []\n        vis = [0] * n\n        ans1=0\n        ans2=1\n        for i in stack:\n            if vis[i] == 0:\n                d=dd(int)\n                s.append(i)\n                while s:\n                    a = s[-1]\n                    if vis[a]==1:\n                        d[c[s.pop()]]+=1\n                        vis[a] = 2\n                        continue\n                    elif vis[a]==2:\n                        s.pop()\n                        continue\n                    vis[a] = 1\n                    for i in g1[a]:\n                        if vis[i] == 0:\n                            s.append(i)\n                min1=min(d.keys())\n                ans1+=min1\n                ans2=(ans2*d[min1])%mod\n        return ans1,ans2\n\n    n=int(data())\n    c=mdata()\n    m=int(data())\n    g=[set() for i in range(n)]\n    g1 = [set() for i in range(n)]\n    for i in range(m):\n        u,v=mdata()\n        g[u-1].add(v-1)\n        g1[v-1].add(u-1)\n    ans1,ans2=kosaraju()\n    print(ans1,ans2)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nread = lambda f=int: list(map(f, sys.stdin.readline().split()))\narray = lambda *ds: [array(*ds[1:]) for _ in range(ds[0])] if ds else 0\n\ndef main():\n    N, = read()\n    cost = tuple(read())\n    E, = read()\n    es = [tuple(read()) for _ in range(E)]\n\n    class Node:\n        def __init__(self, name):\n            self.name = name\n            self.index = None\n            self.lowlink = None\n            self.adj = []\n            self.on_stack = False\n\n    vs = [Node(i) for i in range(N)]\n    for v, w in es:\n        vs[v-1].adj.append(vs[w-1])\n\n    i = 0\n    stack = []\n    call_stack = []\n    comps = []\n    for v in vs:\n        if v.index is None:\n            call_stack.append((v,0))\n            while call_stack:\n                v, pi = call_stack.pop()\n                if pi == 0:\n                    v.index = i\n                    v.lowlink = i\n                    i += 1\n                    stack.append(v)\n                    v.on_stack = True\n                # If we just recursed on something\n                if pi > 0:\n                    prev = v.adj[pi-1]\n                    v.lowlink = min(v.lowlink, prev.lowlink)\n                # Find the next thing to recurse on\n                while pi < len(v.adj) and v.adj[pi].index is not None:\n                    w = v.adj[pi]\n                    if w.on_stack:\n                        v.lowlink = min(v.lowlink, w.index)\n                    pi += 1\n                # If we found something with index=None, recurse\n                if pi < len(v.adj):\n                    w = v.adj[pi]\n                    assert w.index is None\n                    call_stack.append((v,pi+1))\n                    call_stack.append((w,0))\n                    continue\n                if v.lowlink == v.index:\n                    comp = []\n                    while True:\n                        w = stack.pop()\n                        w.on_stack = False # This is important, since later nodes may see it\n                        comp.append(w.name)\n                        if w is v:\n                            break\n                    comps.append(comp)\n\n    #print(stack)\n    #print(comps)\n    res = 0\n    ways = 1\n    for comp in comps:\n        c = min(cost[v] for v in comp)\n        res += c\n        ways *= sum(1 for v in comp if cost[v] == c)\n        ways %= 10**9 + 7\n    print(res, ways)\n\nmain()\n", "import sys\nread = lambda f=int: list(map(f, sys.stdin.readline().split()))\narray = lambda *ds: [array(*ds[1:]) for _ in range(ds[0])] if ds else 0\n\ndef main():\n    N, = read()\n    cost = tuple(read())\n    E, = read()\n    es = [tuple(read()) for _ in range(E)]\n\n    class Node:\n        def __init__(self, name):\n            self.name = name\n            self.index = None\n            self.lowlink = None\n            self.adj = []\n            self.on_stack = False\n\n    vs = [Node(i) for i in range(N)]\n    for v, w in es:\n        vs[v-1].adj.append(vs[w-1])\n\n    def scc(vs):\n        i = 0\n        stack = []\n        call_stack = []\n        comps = []\n        for v in vs:\n            if v.index is None:\n                call_stack.append((v,0))\n                while call_stack:\n                    v, pi = call_stack.pop()\n                    # If this is first time we see v\n                    if pi == 0:\n                        v.index = i\n                        v.lowlink = i\n                        i += 1\n                        stack.append(v)\n                        v.on_stack = True\n                    # If we just recursed on something\n                    if pi > 0:\n                        prev = v.adj[pi-1]\n                        v.lowlink = min(v.lowlink, prev.lowlink)\n                    # Find the next thing to recurse on\n                    while pi < len(v.adj) and v.adj[pi].index is not None:\n                        w = v.adj[pi]\n                        if w.on_stack:\n                            v.lowlink = min(v.lowlink, w.index)\n                        pi += 1\n                    # If we found something with index=None, recurse\n                    if pi < len(v.adj):\n                        w = v.adj[pi]\n                        call_stack.append((v,pi+1))\n                        call_stack.append((w,0))\n                        continue\n                    # If v is the root of a connected component\n                    if v.lowlink == v.index:\n                        comp = []\n                        while True:\n                            w = stack.pop()\n                            w.on_stack = False\n                            comp.append(w.name)\n                            if w is v:\n                                break\n                        comps.append(comp)\n        return comps\n\n    def scc2(vs):\n        result = [ ]\n        stack = [ ]\n        low = {}\n        graph = {v.name: [w.name for w in v.adj] for v in vs}\n\n        def visit(node):\n            if node in low: return\n\n            num = len(low)\n            low[node] = num\n            stack_pos = len(stack)\n            stack.append(node)\n\n            for successor in graph[node]:\n                visit(successor)\n                low[node] = min(low[node], low[successor])\n\n            if num == low[node]:\n                component = tuple(stack[stack_pos:])\n                del stack[stack_pos:]\n                result.append(component)\n                for item in component:\n                    low[item] = len(graph)\n\n        for v in graph:\n            visit(v)\n\n        return result\n\n    def scc3(vs):\n        graph = {v.name: [w.name for w in v.adj] for v in vs}\n        result = []\n        stack = []\n        low = {}\n        call_stack = []\n\n        for v in graph:\n            call_stack.append((v,0,len(low)))\n            while call_stack:\n                v, pi, num = call_stack.pop()\n                if pi == 0:\n                    if v in low: continue\n                    low[v] = num\n                    stack.append(v)\n                if pi > 0:\n                    low[v] = min(low[v], low[graph[v][pi-1]])\n                if pi < len(graph[v]):\n                    call_stack.append((v,pi+1,num))\n                    call_stack.append((graph[v][pi],0,len(low)))\n                    continue\n                if num == low[v]:\n                    comp = []\n                    while True:\n                        comp.append(stack.pop())\n                        low[comp[-1]] = len(graph)\n                        if comp[-1] == v: break\n                    result.append(comp)\n\n        return result\n\n    #print(scc3(vs))\n    #print(scc2(vs))\n    #print(scc(vs))\n    res = 0\n    ways = 1\n    for comp in scc3(vs):\n        c = min(cost[v] for v in comp)\n        res += c\n        ways *= sum(1 for v in comp if cost[v] == c)\n        ways %= 10**9 + 7\n    print(res, ways)\n\nmain()\n", "#same code but with using bootstrap recursion\n\n\nfrom collections import *\nfrom sys import setrecursionlimit, stdin\nimport threading\nfrom types import GeneratorType\n\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\n\nmod = 1000000007\nrints = lambda: [int(x) for x in stdin.readline().split()]\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n    # add edge\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n\n    @bootstrap\n    def scc_utils(self, v):\n\n        # initilaize time and disc\n        self.disc[v], self.low[v], self.stack[v] = self.time, self.time, 1\n        self.time += 1\n        self.st.append(v)\n\n        # loop edges\n        for i in self.gdict[v]:\n            if self.disc[i] == -1:\n                yield self.scc_utils(i)\n                self.low[v] = min(self.low[v], self.low[i])\n\n            elif self.stack[i]:\n                self.low[v] = min(self.low[v], self.disc[i])\n\n            # print founded scc\n        if self.low[v] == self.disc[v]:\n            node, mem = -1, defaultdict(int)\n\n            while node != v:\n                node = self.st.pop()\n                self.stack[node] = 0\n                mem[cost[node - 1]] += 1\n\n            self.count += min(mem)\n            self.mi = ((self.mi % mod) * (mem[min(mem)] % mod)) % mod\n        yield\n\n    def scc(self, n):\n        self.time, self.count, self.mi = 0, 0, 1\n        self.disc, self.low, self.stack, self.st = [-1] * (n + 1), [-1] * (n + 1), [0] * (n + 1), []\n        for i in range(1, n + 1):\n            if self.disc[i] == -1:\n                self.scc_utils(i)\n\n        print(self.count, self.mi)\n\n\nn, cost, m, g = int(input()), rints(), int(input()), graph()\nfor i in range(m):\n    u, v = rints()\n    g.addEdge(u, v)\n\ng.scc(n)\n", "mod = 10**9+7\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\n\tdef dfs(self, root, vis): # Iterative DFS\n\t\tstack=[root]\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\t\treturn stack2[::-1],vis\n\n\tdef dfs2(self, root, vis): # Iterative DFS\n\t\tstack=[root]\n\t\tstack2=[]\n\t\tcost = 10**18\n\t\tcount = 0\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\n\t\t\tif costs[element]<cost:\n\t\t\t\tcost = costs[element]\n\t\t\t\tcount = 1\n\t\t\telif costs[element]==cost:\n\t\t\t\tcount += 1\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\t\treturn cost, count, vis\n\n\tdef count_scc(self, root):\n\t\tvis = [0]*self.n\n\t\tstack = []\n\t\tfor i in range(self.n):\n\t\t\tif not vis[i]:\n\t\t\t\ta, vis = self.dfs(i, vis)\n\t\t\t\tstack.extend(a)\n\n\t\tg = [[] for i in range(self.n)]\n\t\tfor i in range(self.n):\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tg[j].append(i)\n\t\tself.graph = g\n\n\t\tvis = [0]*self.n\n\t\ta1 = 0\n\t\ta2 = 1\n\t\t# print (stack)\n\t\t# print (self.graph)\n\t\tcount = 0\n\t\twhile len(stack)!=0:\n\t\t\te = stack.pop()\n\t\t\tif not vis[e]:\n\t\t\t\ta,b,vis = self.dfs2(e, vis)\n\t\t\t\ta1 += a\n\t\t\t\tcount += 1\n\t\t\t\ta2 = (a2*b)%mod\n\t\t\t# print (vis)\n\t\tif a1==602483:\n\t\t\tprint (count)\n\t\t\tprint (vis)\n\t\t\treturn\n\n\t\treturn a1,a2\n\n\nn, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = map(int, input().split())\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s, t)", "n, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = list(map(int, input().split()))\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s,t)\n", "MOD = int(1e9) + 7\n\nn = int(input())\nw = [0] + list(map(int, input().split()))\nq = [[] for i in range(n+1)]\np = [[] for i in range(n+1)]\nm = int(input())\nedges = [list(map(int, input().split())) for _ in range(m)]\nfor u, v in edges:\n    p[u].append(v)\n    q[v].append(u)\n \ns, t = 0, 1\nr = set(i for i in range(1, n+1) if not p[i] or not q[i])\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: \n            r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: \n            r.add(j)\n \nr = set(i for i in range(1, n+1) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if i not in r: \n            continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: \n            k += 1\n        elif w[i] < d: \n            d, k = w[i], 1\n    s += d\n    t = (t * k) % MOD\nprint(s, t)"]
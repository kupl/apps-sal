["# NOT MY CODE\n# https://codeforces.com/contest/919/submission/80857731\n \nfrom types import GeneratorType\n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        to = f(*args, **kwargs)\n        if stack:\n            return to\n        else:\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        return to\n                    to = stack[-1].send(to)\n    return wrappedfunc\n \nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\n'''\ndef iscyclic(g):\n    for i in range(1,n+1):\n        if(\n'''\nn,m=list(map(int,input().split()))\ns=input()\nd=dd(list)\nlol=0\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    if(u==v):\n        lol=1\n        print(-1)\n        return\n    d[u].append(v)\n'''\nif(iscyclic(d)):\n    lol=1\n    print(-1)\n    return\n'''\nvis=[0]*(n+1)\nrvis=[0]*(n+1)\ncou=[0]\ndp=[dd(int) for i in range(n+1)]\nmx=[0]\nh=[0]\n#print(d)\n@bootstrap\ndef dfs(u):\n    if(h[0]==1):\n        yield\n    vis[u]=1\n    rvis[u]=1\n    for i in d[u]:\n        if(h[0]==1):\n            yield\n        if(vis[i]==0):\n            yield dfs(i)\n            if(h[0]==1):\n                yield            \n        elif(rvis[i]==True):\n            h[0]=1\n            yield\n    rvis[u]=0\n    if(h[0]==1):\n        yield\n    for i in d[u]:\n        for j in dp[i]:\n            dp[u][j]=max(dp[u][j],dp[i][j])\n            mx[0]=max(mx[0],dp[u][j])\n    dp[u][s[u-1]]+=1\n    #print(u,dp[u])\n    mx[0]=max(mx[0],dp[u][s[u-1]])\n    yield\n#print(dp)\nfor i in range(1,n+1):\n    if(vis[i]==0):\n        cou=[0]\n        dfs(i)\nif(h[0]):\n    print(-1)\nelse:\n    print(mx[0])\n", "from types import GeneratorType\n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        to = f(*args, **kwargs)\n        if stack:\n            return to\n        else:\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        return to\n                    to = stack[-1].send(to)\n    return wrappedfunc\n \nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\n'''\ndef iscyclic(g):\n    for i in range(1,n+1):\n        if(\n'''\nn,m=map(int,input().split())\ns=input()\nd=dd(list)\nlol=0\nfor i in range(m):\n    u,v=map(int,input().split())\n    if(u==v):\n        lol=1\n        print(-1)\n        return\n    d[u].append(v)\n'''\nif(iscyclic(d)):\n    lol=1\n    print(-1)\n    return\n'''\nvis=[0]*(n+1)\nrvis=[0]*(n+1)\ncou=[0]\ndp=[dd(int) for i in range(n+1)]\nmx=[0]\nh=[0]\n#print(d)\n@bootstrap\ndef dfs(u):\n    if(h[0]==1):\n        yield\n    vis[u]=1\n    rvis[u]=1\n    for i in d[u]:\n        if(h[0]==1):\n            yield\n        if(vis[i]==0):\n            yield dfs(i)\n            if(h[0]==1):\n                yield            \n        elif(rvis[i]==True):\n            h[0]=1\n            yield\n    rvis[u]=0\n    if(h[0]==1):\n        yield\n    for i in d[u]:\n        for j in dp[i]:\n            dp[u][j]=max(dp[u][j],dp[i][j])\n            mx[0]=max(mx[0],dp[u][j])\n    dp[u][s[u-1]]+=1\n    #print(u,dp[u])\n    mx[0]=max(mx[0],dp[u][s[u-1]])\n    yield\n#print(dp)\nfor i in range(1,n+1):\n    if(vis[i]==0):\n        cou=[0]\n        dfs(i)\nif(h[0]):\n    print(-1)\nelse:\n    print(mx[0])", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nfrom bisect import bisect_left\nn,m=map(int,input().split())\nl=list(input())\ndegree=[0 for i in range(n)]\ngraph={i:[] for i in range(n)}\nfor i in range(m):\n\ta,b=map(int,input().split())\n\ta-=1\n\tb-=1\n\tgraph[a].append(b)\n\tdegree[b]+=1\nq=deque()\nfor i in range(n):\n\tif degree[i]==0:\n\t\tq.append(i)\ncount=0\nans=0\n# print(degree)\ndp=[[0 for i in range(26)] for i in range(n)]\nwhile count<n and q:\n\tx=q.popleft()\n\tcount+=1\n\t# print(ord(l[x])-97)\n\tdp[x][ord(l[x])-97]+=1\n\tfor i in graph[x]:\n\t\tfor j in range(26):\n\t\t\tdp[i][j]=max(dp[i][j],dp[x][j])\n\t\tdegree[i]-=1\n\t\tif degree[i]==0:\n\t\t\tq.append(i)\n# print(degree)\nif count!=n:\n\tprint(-1)\nelse:\n\tans=0\n\tfor i in range(n):\n\t\tans=max(ans,max(dp[i]))\n\tprint(ans)", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nfrom bisect import bisect_left\nn,m=list(map(int,input().split()))\nl=list(input())\ndegree=[0 for i in range(n)]\ngraph={i:[] for i in range(n)}\nfor i in range(m):\n\ta,b=list(map(int,input().split()))\n\ta-=1\n\tb-=1\n\tgraph[a].append(b)\n\tdegree[b]+=1\nq=deque()\nfor i in range(n):\n\tif degree[i]==0:\n\t\tq.append(i)\ncount=0\nans=0\n# print(degree)\ndp=[[0 for i in range(26)] for i in range(n)]\nwhile count<n and q:\n\tx=q.popleft()\n\tcount+=1\n\t# print(ord(l[x])-97)\n\tdp[x][ord(l[x])-97]+=1\n\tfor i in graph[x]:\n\t\tfor j in range(26):\n\t\t\tdp[i][j]=max(dp[i][j],dp[x][j])\n\t\tdegree[i]-=1\n\t\tif degree[i]==0:\n\t\t\tq.append(i)\n# print(degree)\nif count!=n:\n\tprint(-1)\nelse:\n\tans=0\n\tfor i in range(n):\n\t\tans=max(ans,max(dp[i]))\n\tprint(ans)\n", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nfrom bisect import bisect_left\nn,m=list(map(int,input().split()))\ns=input()\nx=[]\ny=[]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    x.append(a)\n    y.append(b)\n\ndef beauty(n,m,s,x,y):\n    l=list(s)\n    degree=[0 for i in range(n)]\n    graph={i:[] for i in range(n)}\n    for i in range(m):\n        a,b=x[i],y[i]\n        a-=1\n        b-=1\n        graph[a].append(b)\n        degree[b]+=1\n    q=deque()\n    for i in range(n):\n        if degree[i]==0:\n            q.append(i)\n    \n    count=0\n    ans=0\n    # print(degree)\n    dp=[[0 for i in range(26)] for i in range(n)]\n    while count<n and q:\n            x=q.popleft()\n            count+=1\n            # print(ord(l[x])-97)\n            dp[x][ord(l[x])-97]+=1\n            for i in graph[x]:\n                    for j in range(26):\n                            dp[i][j]=max(dp[i][j],dp[x][j])\n                    degree[i]-=1\n                    if degree[i]==0:\n                            q.append(i)\n    # print(degree)\n    if count!=n:\n            print(-1)\n    else:\n            ans=0\n            for i in range(n):\n                    ans=max(ans,max(dp[i]))\n            print(ans)\n\nbeauty(n,m,s,x,y)\n", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nfrom bisect import bisect_left\nn,m=list(map(int,input().split()))\ns=input()\nx=[]\ny=[]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    x.append(a)\n    y.append(b)\n\ndef beauty(n,m,s,x,y):\n    l=list(s)\n    degree=[0 for i in range(n)]\n    graph={i:[] for i in range(n)}\n    for i in range(m):\n        a,b=x[i],y[i]\n        a-=1\n        b-=1\n        graph[a].append(b)\n        degree[b]+=1\n    q=deque()\n    for i in range(n):\n        if degree[i]==0:\n            q.append(i)\n    \n    count=0\n    ans=0\n    # print(degree)\n    dp=[[0 for i in range(26)] for i in range(n)]\n    while count<n and q:\n            x=q.popleft()\n            count+=1\n            # print(ord(l[x])-97)\n            dp[x][ord(l[x])-97]+=1\n            for i in graph[x]:\n                    for j in range(26):\n                            dp[i][j]=max(dp[i][j],dp[x][j])\n                    degree[i]-=1\n                    if degree[i]==0:\n                            q.append(i)\n    # print(degree)\n    if count!=n:\n            print(-1)\n    else:\n            ans=0\n            for i in range(n):\n                    ans=max(ans,max(dp[i]))\n            print(ans)\n\nbeauty(n,m,s,x,y)\n"]
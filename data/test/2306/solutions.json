["import sys\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    t = list(map(lambda x: int(x) * 2, input().split()))\n    v = list(map(float, input().split())) + [0]\n\n    for i in range(1, N):\n        t[i] += t[i-1]\n    t += [t[-1]]\n    vnow = [0.0] * (t[-1] + 1)\n    vr = [0.0] * (t[-1] + 1)\n    r = 0\n    for i in range(1, len(vr)):\n        if i < t[r]:\n            vr[i] = v[r]\n        elif i == t[r]:\n            vr[i] = min(v[r], v[r+1])\n            r += 1\n        vnow[i] = min(vnow[i-1] + 0.5, vr[i])\n    for i in range(len(vr)-2, -1, -1):\n        vnow[i] = min(vnow[i], vnow[i+1] + 0.5)\n    \n    print(sum(vnow) / 2)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    t = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    \n    \n    length = sum(t)*2\n    \n    dp = [0]*(length+1)\n    border = v[0]\n    count = t[0]*2\n    index = 0\n    for i in range(length):\n        dp[i+1] = min(dp[i]+0.5, border)\n        count -= 1\n        if i == length-1:\n            break\n        if count == 0:\n            index += 1\n            border = v[index]\n            count = t[index]*2\n    \n    dp[length] = 0\n    border = v[n-1]\n    count = t[n-1]*2\n    index = n-1\n    for i in range(length, 0, -1):\n        dp[i-1] = min([dp[i]+0.5, border, dp[i-1]])\n        count -= 1\n        if i == 0:\n            break\n        if count == 0:\n            index -= 1\n            border = v[index]\n            count = t[index]*2\n    \n    ans = 0\n    for i in range(length):\n        ans += (dp[i]+dp[i+1])/4\n        \n    print(ans)\n    \n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\n\nMAX_V = [0]\nfor t, v in zip(T, V):\n    MAX_V[-1] = min(MAX_V[-1], v)\n    for ti in range(t * 2):\n        MAX_V.append(v)\n\n\nN = len(MAX_V)\nFeasible_V = [0] * N\nfor i in range(N - 1):\n    Feasible_V[i + 1] = min(Feasible_V[i] + 0.5, MAX_V[i + 1])\n\nFeasible_V[-1] = 0\nfor i in reversed(list(range(1, N))):\n    Feasible_V[i - 1] = min(Feasible_V[i - 1], Feasible_V[i] + 0.5)\n\n\nans = 0\nfor i in range(N - 1):\n    x1, x2 = Feasible_V[i], Feasible_V[i + 1]\n    ans += (x1 + x2) * 0.5 / 2\n\nprint(ans)\n", "def calc_vt(v,t):\n    vt = [0]*(sum(t)*2+1)\n    t_sum = 0\n    for ti,vi in zip(t,v):\n        for i in range(ti*2):\n            vt[t_sum + 1 + i] = min(vt[t_sum + i] + 0.5,vi)\n        t_sum += ti*2\n    return vt\n\nn = input().split()\ntn = list(map(int,input().split()))\nvn = list(map(int,input().split()))\n\nvt_l = calc_vt(vn,tn)\nvt_r = calc_vt(vn[::-1],tn[::-1])[::-1]\n\nvt_lr = [min(vl,vr) for vl,vr in zip(vt_l,vt_r)]\n\nprint((sum((a+b)*0.5/2 for a,b in zip(vt_lr,vt_lr[1:]))))\n", "N = int(input())\nT = list([int(t) * 10 for t in input().split()])\nV = list(map(int, input().split())) + [0]\nR = sum(T)\n\nmaxSpeed = [10**18] * (R + 1)\nmaxSpeed[0] = 0\nmaxSpeed[R] = 0\nnow = 0\nfor i, t in enumerate(T):\n    now += t\n    maxSpeed[now] = min(V[i], V[i + 1])\n\nnow = 0\nfor v, t in zip(V, T):\n    for i in range(t + 1):\n        maxSpeed[now + i] = min(maxSpeed[now + i], v)\n    now += t\n\nfor t in range(1, R + 1):\n    maxSpeed[t] = min(maxSpeed[t], maxSpeed[t - 1] + 0.1)\nfor t in range(R)[::-1]:\n    maxSpeed[t] = min(maxSpeed[t], maxSpeed[t + 1] + 0.1)\n\nbase = 0\nupper = 0\nfor v1, v2 in zip(maxSpeed, maxSpeed[1:]):\n    base += min(v1, v2)\n    upper += abs(v1 - v2)\nans = base + upper / 2\nprint((ans / 10))\n", "def atcoder_express(N: int, T: list, V: list)->float:\n    MAXT = sum(T)\n    graph = [0] * (2*MAXT + 1)\n\n    T = [0, 0] + T + [0]\n    for i in range(N+2):\n        T[i+1] += T[i]\n\n    V = [0] + V + [0]\n\n    conditions = []\n    for i in range(N+2):\n        v, l, r = V[i], T[i], T[i+1]\n        conditions.append((l, r, v))\n\n    total = 0.0\n    prev_v = 0.0\n    for t in range(MAXT*2+1):\n        min_v = float('inf')\n        x = t / 2\n        for l, r, v in conditions:\n            if x < l:\n                min_v = min(min_v, v + (l - x))\n            elif r < x:\n                min_v = min(min_v, v + (x - r))\n            else:\n                min_v = min(min_v, v)\n        total += (prev_v + min_v) * 0.5 / 2\n        prev_v = min_v\n\n    return total\n\n\ndef __starting_point():\n    N = int(input())\n    T = [int(s) for s in input().split()]\n    V = [int(s) for s in input().split()]\n    ans = atcoder_express(N, T, V)\n    print(ans)\n\n__starting_point()", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\nFT = sum(T)*2+1\nimport numpy as np\nlimit = []\ncumt = 0\nfor n in range(2+N):\n    if n==0:\n        lis = [(0.5)*i for i in range(FT)]\n    elif n==1:\n        lis = [(0.5)*i for i in range(FT)][::-1]\n    else:\n        t = T[n-2]\n        v = V[n-2]\n        lis = [v+cumt//2-0.5*i for i in range(cumt)] + [v for _ in range(t*2)] + [v+i*0.5 for i in range(FT-cumt-t*2)]\n        cumt += t*2\n    limit.append(lis)\nlimit = np.min(np.array(limit), axis=0)\nans = 0\nfor i in range(FT-1):\n    ans += (limit[i+1]+limit[i])*0.25\nprint(ans)", "N = int(input())\n\nt = [int(x) for x in input().split()]\nvSection = [int(x) for x in input().split()]\n\nvPoint = [0]\nfor i in range(1, N):\n\tvPoint.append(min(vSection[i - 1], vSection[i]))\nvPoint.append(0)\n\nfor i in reversed(range(1, N + 1)):\n\tif t[i - 1] < vPoint[i - 1] - vPoint[i]:\n\t\tvPoint[i - 1] = t[i - 1] + vPoint[i]\n\n\nans = 0\nVE = 0\nfor i in range(N):\n\tVS = VE\n\tif VS + t[i] <= vPoint[i + 1]:\n\t\tVE = VS + t[i]\n\t\tans += VS * t[i] + t[i] ** 2 / 2\n\telse:\n\t\tVE = vPoint[i + 1]\n\t\tsumT = sum(t[:i])\n\t\ta = VS - (0 if i == 0 else sumT)\n\t\tb = VE + sum(t[:i+1])\n\t\ty = (a + b) / 2\n\t\tif y >= vSection[i]:\n\t\t\tt1 = vSection[i] - VS\n\t\t\tt2 = vSection[i] - VE\n\t\t\tans += VS * t1 + t1 ** 2 / 2 + vSection[i] * (t[i] - t1 - t2) + VE * t2 + t2 ** 2 / 2\n\t\telse:\n\t\t\tx = y - a\n\t\t\tans += VS * (x - sumT) + (x - sumT) ** 2 / 2 + VE * (t[i] - (x - sumT)) + (t[i] - (x - sumT)) ** 2 / 2\n\t\t\t\nprint(ans)", "n = int(input())\nt = list(map(float, input().split()))\nv = list(map(float, input().split()))\n\nfor i in range(n):\n    t[i] *= 2.0\n    v[i] *= 2.0\n\nv.append(0.0)\n\nfor i in range(n - 1, -1, -1):\n    v[i] = min(v[i], v[i + 1] + t[i])\n\nfor i in range(1, n):\n    t[i] += t[i - 1]\n\nans = 0.0\nspeed = 0.0\nk = 0\nst = int(t[n - 1] + 0.1)\n\nfor i in range(st):\n    if i >= t[k]:\n        k += 1\n    \n    ans += speed\n\n    limit = min(v[k], v[k + 1] + t[k] - i - 1)\n    if speed < limit:\n        ans += 0.5\n        speed += 1.0\n    elif speed > limit:\n        ans -= 0.5\n        speed -= 1.0\n\nans /= 4.0\n\nprint(ans)", "# 19/4/17\u518d\u6226\n# -x + a = x + b \u3060\u3068 x = (sum)/2\u3067~.5\u306b\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\n# \u3046\uff5e\uff5e\uff5e\u3093\n\nn = int(input())\nts = list(map(int, input().split()))\nvs = list(map(int, input().split()))\nsum_t = sum(ts)\nn = 2*sum_t+1\nmax_v = [float(\"inf\")]*n\n# 0\u304b\u3089\u53f3\u4e0a\u3001-1\u304b\u3089\u5de6\u4e0a\nfor i in range(n):\n    max_v[i] = min(i/2, (sum_t-i/2))\n\n# int\u3067time\u306f\u7ba1\u7406\u3059\u308b\u304b...\n# 0\u21920, 0.5\u21921, 1\u21922 ... i/2\u2192i\nt_cnt = 0\nfor t, v in zip(ts, vs):\n    for j in range(2*t+1):\n        max_v[t_cnt + j] = min(max_v[t_cnt + j], v)\n\n    # \u5de6\u5074\u306b\u4f38\u3070\u3057\u3066\u3044\u304f\n    left = t_cnt\n    while left >= 0:\n        v_left = v + (t_cnt - left)/2\n        if max_v[left] < v_left:\n            break\n        max_v[left] = v_left\n        left -= 1\n    # \u53f3\u5074\u306b\u4f38\u3070\u3057\u3066\u3044\u304f\n    t_cnt += 2*t\n    right = t_cnt\n    while right < n:\n        v_right = v + (right - t_cnt)/2\n        if max_v[right] < v_right:\n            break\n        max_v[right] = v_right\n        right += 1\n\n#print(max_v)\nans = sum(max_v) - (max_v[0]+max_v[-1])/2\nprint(ans/2)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nN = int(input())\nT = [0] + list(map(int, input().split()))\nV = [0] + list(map(int, input().split()))\n\nmax_speed_from_left = [0] * (N + 1)\nmax_speed_from_right = [0] * (N + 1)\n\nfor i in range(1, N):\n    start = max_speed_from_left[i - 1]\n    max_speed_from_left[i] = min(start + T[i], V[i], V[i + 1])\n\nfor i in range(N - 1, 0, -1):\n    start = max_speed_from_right[i + 1]\n    max_speed_from_right[i] = min(start + T[i + 1], V[i], V[i + 1])\n\nspeed = [min(x, y) for x, y in zip(max_speed_from_left, max_speed_from_right)]\n\ndef dist(left_speed, right_speed, t, v):\n    x = (v - left_speed) + (v - right_speed)\n    if x >= t:\n        v = (left_speed + right_speed + t) / 2\n        x = t\n    d = (left_speed + v) * (v - left_speed) / 2\n    d += v * (t - x)\n    d += (right_speed + v) * (v - right_speed) / 2\n    return d\n\nans = 0\nfor i in range(1, N + 1):\n    ans += dist(speed[i - 1], speed[i], T[i], V[i])\n\nprint (ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nN = int(input())\nT = [0] + list(map(int, input().split()))\nV = [0] + list(map(int, input().split()))\n\nleft = [0] * (N + 1)\nright = [0] * (N + 1)\n\nfor i in range(1, N):\n    start = left[i - 1]\n    left[i] = min(start + T[i], V[i], V[i + 1])\n\nfor i in range(N - 1, 0, -1):\n    start = right[i + 1]\n    right[i] = min(start + T[i + 1], V[i], V[i + 1])\n\ntotal = [min(left[i], right[i]) for i in range(N + 1)]\nans = 0\nfor i in range(1, N + 1):\n    x = (V[i] - total[i - 1]) + (V[i] - total[i])\n    if x >= T[i]:\n        V[i] = (total[i - 1] + T[i] + total[i]) / 2\n        x = T[i]\n    d =(total[i - 1] + V[i]) * (V[i] - total[i - 1]) / 2 #\u53f0\u5f62\u5de6\u5074\n    d += (total[i] + V[i]) * (V[i] - total[i]) / 2 #\u53f0\u5f62\u53f3\u5074\n    d += V[i] * (T[i] - x) #\u771f\u3093\u4e2d\u306e\u5b9a\u901f\u90e8\u5206\n\n    ans += d\n\nprint (ans)", "N = int(input())\nt = list(map(int,input().split()))\nv = list(map(int,input().split()))\nT = sum(t)\nans = [0]\n\nfor i in range(N):\n  ans[-1] = min(ans[-1],v[i])\n  for j in range(t[i]*2):\n    ans.append(v[i])\n\nans[-1] = 0\n\nfor i in range(2*T):\n  ans[i+1]=min(ans[i]+0.5,ans[i+1])\n\nfor i in range(2*T,0,-1):\n  ans[i-1]=min(ans[i]+0.5,ans[i-1])\n\nprint(sum(ans)/2)", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\nL = [0] * (sum(T)*2+1)\nR = [0] * (sum(T)*2+1)\nxt, xv = 0, 0\nfor t, v in zip(T, V):\n    for tt in range(xt*2+1, (t+xt)*2+1):\n        xv += .5\n        L[tt] = min(v, xv)\n    xt += t\n    xv = min(v, xv)\nxt, xv = 0, 0\nfor t, v in zip(T[::-1], V[::-1]):\n    for tt in range(xt*2+1, (t+xt)*2+1):\n        xv += .5\n        R[tt] = min(v, xv)\n    xt += t\n    xv = min(v, xv)\nprint(sum(map(min, L, R[::-1]))/2)", "n=int(input())\nt=[int(a)*2 for a in input().split()]\nv=[int(a)*2 for a in input().split()]\nma=[0]*(sum(t)+1)\na=0\nfor i in range(n):\n  for j in range(t[i]):\n    a+=1\n    ma[a]=min(ma[a-1]+1,v[i])\nma[a]=0\nfor i in range(n)[::-1]:\n  for j in range(t[i]):\n    a-=1\n    ma[a]=min(ma[a],ma[a+1]+1,v[i])\nprint((sum(ma[1:])+sum(ma[:-1]))/8)", "n,*L=map(int,open(0).read().split())\nT,V=L[:n],L[n:]\ns=sum(T)\na=[0]\nfor t,v1,v2 in zip(T,V,V[1:]+[0]):\n\ta+=[v1]*(2*t-1)+[min(v1,v2)]\nfor i in range(2*s):\n\ta[i+1]=min(a[i+1],a[i]+.5)\nfor i in range(2*s,0,-1):\n\ta[i-1]=min(a[i-1],a[i]+.5)\nprint(sum(a)/2)", "\nN = int(input())\n\nt = list(map(int,input().split()))\nv = list(map(int,input().split()))\n\nalltime = sum(t)\nmaxslis = []\nrmaxslis = []\n\n\n\nspd = 0\nans = 0\n\nfor i in range(N):\n\n    for j in range(t[i]):\n        maxslis.append(v[i])\n        maxslis.append(v[i])\n        rmaxslis.append(v[i])\n\n\nmaxslis.reverse()\n\n\nfor i in range(alltime * 2):\n\n    if i == 0:\n        able = 0.5\n        maxslis[i] = 0\n\n    elif able < maxslis[i]:\n        maxslis[i] = able\n        able += 0.5\n\n    else:\n        able = maxslis[i]\n\nmaxslis.reverse()\nmaxslis.append(0)\n\n#print (maxslis)\ndtflag = False\n\nfor i in range(alltime * 2 + 1):\n\n    #print (i+1,maxslis[i],spd)\n\n    if spd < maxslis[i]:\n\n        ans += spd * 0.5 + 0.125\n        spd += 0.5\n        #if spd != maxslis[i]:\n            #dtflag = True\n\n    elif spd == maxslis[i]:\n\n        #if dtflag and rmaxslis[i] != maxslis[i]:\n            #ans += 0.25\n            #print (i+1)\n        ans += spd * 0.5\n        dtflag = False\n\n    else:\n        ans += spd * 0.5 - 0.125\n        spd -= 0.5\n        dtflag = False\n\nprint (ans)\n", "N = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\nu = [0]\nfor vi, ti in zip(v, t):\n  u[-1] = min(u[-1], vi)\n  u += [vi] * (ti * 2)\n\nu[-1] = 0\nU = u.copy()\nT = len(u)\nfor i in range(1, T):\n  u[i] = min(u[i], u[i-1]+0.5)\n\nfor i in range(T-2, -1, -1):\n  u[i] = min(u[i], u[i+1]+0.5)\n\nans = 0\nfor i in range(1, T):\n  ans += (u[i-1] + u[i]) * 0.25\n\nprint(ans)", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\nv.append(0)\n\n# forward\nnow = 0\nfor i in range(n):\n    if now + t[i] < v[i]:\n        v[i] = now + t[i]\n\n    if v[i] <= v[i+1]:\n        now = v[i]\n    elif t[i] + v[i+1] + now < 2 * v[i]:\n        v[i] = (t[i] + v[i+1] + now) / 2\n        now = v[i+1]\n    else:\n        now = v[i+1]\n\n# back\nnow = 0\nfor i in range(n-1, -1, -1):\n    if now + t[i] < v[i]:\n        v[i] = now + t[i]\n\n    if v[i] <= v[i-1]:\n        now = v[i]\n    elif t[i] + v[i-1] + now < 2 * v[i]:\n        v[i] = (t[i] + v[i-1] + now) / 2\n        now = v[i-1]\n    else:\n        now = v[i-1]\n\nans = 0\nnow = 0\nfor i in range(n):\n    t1 = v[i] - now\n    t3 = v[i] - v[i+1]\n    # t2 = t[i] - t1 - t3\n\n    ans += now * t1 + t1 * t1 / 2\n    now = v[i] # now += t1\n\n    ans += now * (t[i] - t1 - t3) # ans += now * t2\n    # now = now\n\n    ans += now * t3 - t3 * t3 / 2\n    now -= t3\n\nprint(ans)", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\nT = sum(t)\n\nvmax_l = [0 for _ in range(2*T+1)]\nvmax_r = [0 for _ in range(2*T+1)]\nvmax = [0 for _ in range(2*T+1)]\nfor i in range(1, 2*T+1):\n    tt = 0\n    for j in range(n):\n        if i > tt+t[j]*2:\n            tt += t[j]*2\n        else:\n            vmax_l[i] = min(v[j], vmax_l[i-1]+0.5)\n            break\nfor i in range(2*T-1, -1, -1):\n    tt = 2*T\n    for j in range(n-1, -1, -1):\n        if i < tt-t[j]*2:\n            tt -= t[j]*2\n        else:\n            vmax_r[i] = min(v[j], vmax_r[i+1]+0.5)\n            break\nfor i in range(2*T+1):\n    vmax[i] = min(vmax_l[i], vmax_r[i])\n\npoint_t = [0]\npoint_v = [0]\nfor i in range(1, 2*T):\n    if vmax[i-1] != vmax[i] or vmax[i] != vmax[i+1]:\n        point_t.append(i)\n        point_v.append(vmax[i])\npoint_t.append(2*T)\npoint_v.append(0)\n\nans = 0\nfor i in range(1, len(point_t)):\n    ans += (point_t[i]-point_t[i-1])*(point_v[i]+point_v[i-1])/4\nprint(ans)", "N = int(input())\nT = list(map(int, input().split()))\nV1 = list(map(int, input().split()))\nV1.append(0)\n\nST = [0] * (N + 1)\nfor i in range(N):\n    ST[i + 1] = ST[i] + T[i]\n\nV2 = [0] * N\nfor i in range(N):\n    V2[i] = V1[i + 1] + ST[i + 1]\nz = V2[-1]\nfor i in range(N - 1, -1, -1):\n    if V2[i] > z:\n        V2[i] = z\n    else:\n        z = V2[i]\n\n\nVmax = [0] * (ST[-1] * 2 + 1)\nj = 0\nt = 0\nfor i, Tn in enumerate(ST):\n    while t < Tn or j == 0:\n        Vmax[2 * t + j] = min(V1[i - 1], V2[i - 1])\n        V2 = [x - 0.5 for x in V2]\n        t += j\n        j ^= 1\n\nv, cnt = 0, 0\nfor i in range(ST[-1] * 2):\n    nVmax = Vmax[i + 1]\n    nv = min(v + 0.5, nVmax)\n    cnt += (v + nv) * 0.5 / 2\n    v = nv\n\nprint(cnt)\n", "N = int(input())\nt = list(map(int,input().split()))\nv = list(map(int,input().split()))\nT = sum(t)*2\nvt = [min((i/2),((T-i)/2)) for i in range(T+1)]\nts = 0\nte = 0\nfor i,ti in enumerate(t):\n    te += ti*2\n    vi = v[i]\n    for j in range(ts,te):\n        vt[j] = min(vt[j],vi)\n    for j in range(te,T):\n        if vt[j] >= (j-te)/2 + vi:\n            vt[j] = (j-te)/2 + vi\n        else:\n            break\n    for j in range(ts-1,-1,-1):\n        if vt[j] >= -(j-ts)/2 + vi:\n            vt[j] = -(j-ts)/2 + vi\n        else:\n            break\n    ts = te\nprint(sum(vt)/2)", "#!/usr/bin/env python3\nimport sys\nimport numpy as np\n\n\ndef solve(N: int, T: \"List[int]\", V: \"List[int]\"):\n    t_period = [0 for i in range(N+1)]\n    for i in range(N):\n        t_period[i+1] = t_period[i] + T[i]*2\n\n    limit = np.zeros((t_period[N]+1,))\n    for i in range(1, N):\n        limit[t_period[i]] = min((V[i-1], V[i]))\n    for i in range(N):\n        limit[t_period[i]+1:t_period[i+1]] = V[i]\n    \n    speed = np.zeros((t_period[N]+1,))\n\n    for v in range(1, 201):\n        speed[1:t_period[N]] = np.min([limit[1:t_period[N]], speed[0:t_period[N]-1]+0.5, speed[2:t_period[N]+1]+0.5], axis=0)\n\n    total = 0\n    for t in range(t_period[N]):\n        total += (speed[t] + speed[t+1]) * 0.5 * 0.5\n    \n    print(total)\n\n    return\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    t = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    v = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    solve(N, t, v)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nMAX_V = [0]\nfor t, v in zip(T, V):\n    MAX_V[-1] = min(MAX_V[-1], v)\n    MAX_V.extend([v] * (2 * t))\n\nREAL_V = [0]\nfor i in range(len(MAX_V) - 1):\n    REAL_V.append(min(REAL_V[-1] + 0.5, MAX_V[i + 1]))\n\nREAL_V[-1] = 0\nfor i in reversed(list(range(len(MAX_V) - 1))):\n    REAL_V[i] = min(REAL_V[i], REAL_V[i + 1] + 0.5, MAX_V[i])\n\nans = 0\nfor i in range(len(MAX_V) - 1):\n    ans += ((REAL_V[i] + REAL_V[i + 1]) * 0.5) / 2\nprint(ans)\n", "N = int(input())\nt = [int(Ti) for Ti in input().split()]\nv = [int(Vi) for Vi in input().split()]\n\nv_max = [0]\nfor ti, vi in zip(t, v):\n    v_max[-1] = min(v_max[-1], vi)\n    for _ in range(2*ti):\n        v_max.append(vi)\n\nfor i in range(len(v_max)-1):\n    v_max[i+1] = min(v_max[i] + 0.5, v_max[i+1])\n\nv_max[-1] = 0\nfor i in range(len(v_max)-2, -1, -1):\n    v_max[i] = min(v_max[i], v_max[i+1] + 0.5)\n\narea = 0\nfor i in range(len(v_max) - 1):\n    area += 0.5 * 0.5 * (v_max[i] + v_max[i+1])\n\nprint(area)\n", "#!/usr/bin/env python3\nimport sys\nimport numpy as np\n\n\ndef solve(N: int, T: \"List[int]\", V: \"List[int]\"):\n    t_period = [0 for i in range(N+1)]\n    for i in range(N):\n        t_period[i+1] = t_period[i] + T[i]*2\n\n    V = [0] + V + [0]\n    limit = np.zeros((N+2,t_period[N]+1))\n    line = np.arange(0, t_period[N]/2+0.5, 0.5)\n    for i in range(N+2):\n        if i == 0:\n            l, r = 0, 0\n        elif i == N+1:\n            l, r = t_period[N], t_period[N]\n        else:\n            l, r = t_period[i-1], t_period[i]\n        limit[i] = np.max([-line + l * 0.5, line * 0, line - r * 0.5], axis=0) + V[i]\n    speed = np.min(limit, axis=0)\n\n    total = 0\n    for t in range(t_period[N]):\n        total += (speed[t] + speed[t+1]) * 0.5 * 0.5\n\n    print(total)\n\n    return\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    t = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    v = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    solve(N, t, v)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nt = [int(i) for i in input().split()]\nv = [int(i) for i in input().split()]\ntime = sum(t)\n\nspeed = [10 ** 9] * (2 * time + 1)\nlimit = [10 ** 9] * (2 * time + 1)\n\ni = 0\nfor j, k in zip(t, v):\n    for _ in range(j * 2):\n        limit[i] = min(limit[i], k)\n        i += 1\n    limit[i] = min(limit[i], k)\n\ns = 0\nfor i in range(2 * time + 1):\n    s = min(s, limit[i])\n    speed[i] = min(speed[i], s)\n    s += 0.5\ns = 0\nfor i in reversed(list(range(2 * time + 1))):\n    s = min(s, limit[i])\n    speed[i] = min(speed[i], s)\n    s += 0.5\n\ndist = 0\nfor i in range(2 * time):\n    dist += (speed[i] + speed[i + 1]) / 4\nprint(dist)\n", "import numpy as np\n\nN = int(input())\nt = np.array(['0'] + input().split(), np.int64)\nv = list(map(int, input().split()))\n\n# \u767a\u8eca\u3057\u3066\u304b\u3089n\u79d2\u5f8c\u306e\u901f\u5ea6\u3092\u6c42\u3081\u308b\n\nT = np.cumsum(t).tolist()\narrival = T[-1]\ntimes = np.arange(0, arrival + 0.5, 0.5)\nspeed_limit = np.minimum(times, times[::-1])\n\nfor i, j, k in zip(T, T[1:], v):\n    speed1 = i - times + k\n    speed2 = np.full(arrival * 2 + 1, k, np.float)\n    speed3 = times - j + k\n\n    speed = np.maximum(speed1, speed3)\n    speed = np.maximum(speed2, speed)\n    speed_limit = np.minimum(speed_limit, speed)\n\nanswer = np.abs(speed_limit[1:] + speed_limit[:-1]) * 0.5 / 2\nprint((answer.sum()))\n", "N=int(input())\nT=list(map(int,input().split()))\nV=list(map(int,input().split()))\nneed=[(0,0)]*(N+1)\nnow=0\nfor i in range(N-1):\n    now+=T[i]\n    need[i+1]=(now,min(V[i],V[i+1]))\nneed[N]=(now+T[N-1],0)\nTN=need[N][0]\nres=[float('inf')]*(TN+1)\nfor i in range(TN+1):\n    for j in range(N+1):\n        if j>0:\n            if need[j-1][0]<=i<=need[j][0]:\n                res[i]=min(res[i],V[j-1])\n        res[i]=min(res[i],need[j][1]+abs(need[j][0]-i))\nans=0\nfor i in range(TN):\n    if abs(res[i]-res[i+1])==1:\n        ans+=0.5*(res[i]+res[i+1])\n    else:\n        for j in range(N):\n            if need[j][0]<=i and i+1<=need[j+1][0]:\n                vv=V[j]\n                break\n        if vv>res[i]:\n            ans+=res[i]+0.25\n        else:\n            ans+=res[i]\nprint(ans)", "N = int(input())\nt = [0] + [int(x) for x in input().split()]\nv = [0] + [int(x) for x in input().split()]\n\nmax_speed_from_left = [0] * (N+1) # index i = t[i],t[i+1]\u306e\u9593\nmax_speed_from_right = [0] * (N+1) # index i = t[i],t[i+1]\u306e\u9593\n\nfor i in range(1,N):\n  start = max_speed_from_left[i-1]\n  max_speed_from_left[i] = min(start + t[i], v[i], v[i+1])\n  \nfor i in range(N-1,0,-1):\n  start = max_speed_from_right[i+1]\n  max_speed_from_right[i] = min(start + t[i+1], v[i], v[i+1])\n\nspeed = [min(x,y) for x,y in zip(max_speed_from_left,max_speed_from_right)]\n\ndef dist(left_speed,right_speed,t,v):\n  x = (v - left_speed) + (v - right_speed)\n  if x >= t:\n    v = (left_speed + right_speed + t)/2\n    x = t\n  # \u6700\u9ad8\u901f\u5ea6v\u306b\u5230\u9054\u3057\u3066\u3001t-x\u3042\u307e\u308b\n  d = (left_speed + v) * (v-left_speed)/2\n  d += v*(t-x)\n  d += (right_speed + v) * (v-right_speed)/2\n  return d\n\nanswer = 0\nfor i in range(1,N+1):\n  answer += dist(speed[i-1],speed[i],t[i],v[i])\nprint(answer)\n", "N=int(input().strip())\nT=list(map(int,input().split()))\nV=list(map(int,input().split()))\nvtmax=[0]\ntmp=0\nTsum=sum(T)\nfor t,v in zip(T,V):\n    vtmax[-1]=min(tmp,v) #\u5883\u754c\u306f\u5c0f\u3055\u3044\u65b9\u304c\u5236\u7d04\n    vtmax+=[v]*(t*2)\n    tmp=v\nvtmax[-1]=0\n\nfor i in range(1,2*Tsum):\n    vtmax[i]=min(vtmax[i],vtmax[i-1]+0.5)\nfor i in range(2*Tsum-1,0,-1):\n    vtmax[i]=min(vtmax[i],vtmax[i+1]+0.5)\narea=0\nfor i,vt in enumerate(vtmax):\n    if i==0:continue\n    area+=0.5*(vt+vtmax[i-1])/2\nprint(area)", "N=int(input())\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\n\nT=sum(t)\nans=[0]\n\nfor i in range(N):\n  ans[-1]=min(ans[-1],v[i])\n  for j in range(t[i]*2):\n    ans.append(v[i])\n\nans[-1]=0\n\nfor i in range(2*T):\n  ans[i+1]=min(ans[i]+0.5,ans[i+1])\n\nfor i in range(2*T,0,-1):\n  ans[i-1]=min(ans[i]+0.5,ans[i-1])\n\nprint(sum(ans)/2)", "N = int(input())\nt = list(map(int,input().split()))\nv = list(map(int,input().split()))\nT = sum(t)*2\nvt = [(i/2) if i<T/2 else ((T-i)/2) for i in range(T+1)]\nts = 0\nte = 0\nfor i,ti in enumerate(t):\n    te += ti*2\n    vi = v[i]\n    for j in range(ts,te):\n        vt[j] = min(vt[j],vi)\n    for j in range(te,T):\n        if vt[j] >= (j-te)/2 + vi:\n            vt[j] = (j-te)/2 + vi\n        else:\n            break\n    for j in range(ts-1,-1,-1):\n        if vt[j] >= -(j-ts)/2 + vi:\n            vt[j] = -(j-ts)/2 + vi\n        else:\n            break\n    ts = te\nprint(sum(vt)/2)", "import math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1 for i in range(self.n)]\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.par[p] += self.par[q]\n        self.par[q] = p\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nn = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\ns_t = sum(t)\nans = [0]\nfor i in range(n):\n    ans[-1] = min(ans[-1], v[i])\n    for j in range(t[i] * 2):\n        ans.append(v[i])\nans.pop()\nans.append(0)\nfor i in range(1, s_t * 2 + 1):\n    ans[i] = min(ans[i - 1] + 1 / 2, ans[i])\nfor i in range(1, s_t * 2 + 1)[::-1]:\n    ans[i - 1] = min(ans[i] + 1 / 2, ans[i - 1])\nprint(sum(ans) / 2)", "n = int(input())\nts = [int(item)*2 for item in input().split()]\nvs = [int(item) for item in input().split()]\n\ntime = sum(ts) + 1\nspeed_l = [0] * time\nspeed_r = [0] * time \n\nt_id = 0\nspeed = 0\nts_copy = ts[:]\n# Forward\nfor i in range(time+1):\n    ts_copy[t_id] -= 1\n    speed_l[i] = speed\n    if speed >= vs[t_id]:\n        speed = vs[t_id]\n    else:\n        speed += 0.5 \n\n    if ts_copy[t_id] == 0:\n        if t_id + 1 >= n:\n            break\n        t_id += 1\n\n# Backward\nspeed = 0\nfor i in range(time-1, -1, -1):\n    ts[t_id] -= 1\n    speed_r[i] = min(speed, speed_l[i])\n    if speed >= vs[t_id]:\n        speed = vs[t_id]\n    else:\n        speed += 0.5 \n\n    if ts[t_id] == 0:\n        if t_id <= 0:\n            break\n        t_id -= 1\n\nprint(sum(speed_r) / 2.0)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    n=int(input())\n    tt=LI()\n    vv=LI()+[0]\n    #\u533a\u9593\u306e\u5909\u308f\u308a\u76ee\u306b\u304a\u3044\u3066\u306ev\u306e\u6700\u5927\u5024\u3092\u5de6\u53f3\u304b\u3089\u8abf\u3079\u308b\n    y=0\n    max_vL=[1000]*(n-1)\n    max_vR=[1000]*(n-1)\n    for i in range(n-1):\n        y=min(vv[i],vv[i+1],y+tt[i])\n        max_vL[i]=y\n    y=0\n    for i in range(n-2,-1,-1):\n        y=min(vv[i+1],vv[i],y+tt[i+1])\n        max_vR[i]=y\n    #print(max_vR)\n    #print(max_vL)\n    #\u5de6\u53f3\u306emin\u3092\u53d6\u308b\u3053\u3068\u3067\u3001\u5909\u308f\u308a\u76ee\u306ev\u3092\u6c7a\u3081\u308b\n    yy=[0]*(n+1)\n    for i in range(n-1):\n        yy[i+1]=min(max_vL[i],max_vR[i])\n    #print(yy)\n    #\u5404\u533a\u9593\u306e\u9762\u7a4d\u3092\u6c42\u3081\u308b\n    ans=0\n    for t,y0,y1,v in zip(tt,yy,yy[1:],vv):\n        h=(t+y0+y1)/2\n        ans+=((h+y0)*(h-y0)+(h+y1)*(h-y1))/2\n        if h>v:ans-=(h-v)**2\n    print(ans)\n\nmain()", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\nruntime = sum(t)\nspeed = [0] * (runtime*2+1)\nnow_t, now_v = 0,0\nfor ti,vi in zip(t,v):\n  for i in range(now_t*2+1,now_t*2+ti*2+1):\n    next_v = min(now_v+0.5, vi)\n    speed[i] = next_v\n    now_v = next_v\n  now_t += ti\nspeed[-1] = 0\nnow_t, now_v = runtime,0\nfor ti,vi in zip(t[::-1],v[::-1]):\n  for i in range(now_t*2-1,now_t*2-ti*2-1,-1):\n    next_v = min([now_v+0.5, speed[i],vi])\n    speed[i] = next_v\n    now_v = next_v\n  now_t -= ti\nans = 0\nfor i in range(runtime*2):\n  ans += speed[i]+speed[i+1]\nans /= 4\nprint(ans)", "import heapq\nn=int(input())\ninf=10000000000000\n#\u59cb\u307e\u308a\u3068\u7d42\u308f\u308a\u3092\u4fdd\u6301\n#\u540c\u3058\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u3059\u308b\u3084\u3064\u3067\u4e00\u6642\u9593\u6eb6\u304b\u3057\u305f\u3001\u3057\u306d\nans=[[-1,-1] for i in range(n)]\nans[-1][1]=0\nans[0][0]=0\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\nv2=[]\nfor i in range(n):\n    heapq.heappush(v2,(v[i],i))\nfor i in range(n):\n    #print(ans)\n    y=heapq.heappop(v2)\n    #print(y[1])\n    #print(ans[y[1]])\n    #print(y)\n    #\u59cb\u307e\u308a\u3092\u307e\u305a\u306f\u6c7a\u3081\u308b\n    if ans[y[1]][0]==-1:\n        #print(2)\n        now1=0\n        ansi1=inf\n        for j in range(y[1]-1,-1,-1):\n            #print(ans1)\n            if ans[j][1]!=-1:\n                ansi1=min(ansi1,ans[j][1]+now1)\n            now1+=t[j]\n            if ans[j][0]!=-1:\n                ansi1=min(ansi1,ans[j][0]+now1)\n        now1=0\n        for j in range(y[1],n):\n            if ans[j][0]!=-1:\n                ansi1=min(ansi1,ans[j][0]+now1)\n            now1+=t[j]\n            if ans[j][1]!=-1:\n                ansi1=min(ansi1,ans[j][1]+now1)  \n        ans[y[1]][0]=min(ansi1,y[0])\n        ans[y[1]-1][1]=ans[y[1]][0]\n        #print(ansi1)\n    if ans[y[1]][1]==-1:\n        #print(3)\n        now2=0\n        ansi2=inf\n        for j in range(y[1],-1,-1):\n            if ans[j][1]!=-1:\n                ansi2=min(ansi2,ans[j][1]+now2)\n            now2+=t[j]\n            if ans[j][0]!=-1:\n                ansi2=min(ansi2,ans[j][0]+now2)\n        now2=0\n        for j in range(y[1]+1,n):\n            if ans[j][0]!=-1:\n                ansi2=min(ansi2,ans[j][0]+now2)\n            now2+=t[j]\n            if ans[j][1]!=-1:\n                ansi2=min(ansi2,ans[j][1]+now2)  \n        ans[y[1]][1]=min(ansi2,y[0])\n        ans[y[1]+1][0]=ans[y[1]][1]\n        #print(ansi2)\nanswer=0\nfor i in range(n):\n    h=min((t[i]+sum(ans[i]))/2,v[i])\n    answer+=((h**2-ans[i][0]**2)/2)\n    answer+=((h**2-ans[i][1]**2)/2)\n    answer+=(h*(t[i]+sum(ans[i])-2*h))\nprint(answer)\n#print(ans)\n\n", "n = int(input())\nt = list(map(int,input().split()))\nv = list(map(int,input().split()))\nT = sum(t)*2\nkukan = [(0,0,0)]\nfor i in range(n):\n    kukan.append((kukan[i][1],kukan[i][1]+t[i]*2,v[i]))\nkukan.append((T,T,0))\nvt = [[1000]*(len(kukan)) for _ in range(T+1)]\nk = 0\nfor ts,te,v_ in kukan:\n    for i in range(ts,te+1):\n        vt[i][k] = v_\n    for i in range(ts-1,-1,-1):\n        vt[i][k] = vt[i+1][k]+0.5\n    for i in range(te+1,T+1):\n        vt[i][k] = vt[i-1][k]+0.5\n    k += 1\nans = 0\nd = [0]*len(vt)\nfor i in range(len(vt)):\n    d[i] = min(vt[i])\nfor i in range(1,len(vt)):\n    ans += (d[i]+d[i-1])*0.25\nprint(ans)", "# AtCoder Beginner Contest 076\n# D - AtCoder Express\n# https://atcoder.jp/contests/abc076/tasks/abc076_d\n\n\ndef solve(T, V, velocity):\n    accT = 1\n    for t, max_v in zip(T, V):\n        for i in range(accT, accT+2*t):\n            velocity[i] = min(velocity[i], velocity[i-1]+0.5, max_v)\n        accT += 2*t\n\n\ndef main():\n\n    N, *A = list(map(int, open(0).read().split()))\n    T = A[:N]\n    V = A[N:]\n\n    INF = 10**10\n\n    velocity = [INF]*(sum(T)*2+1)\n    velocity[0] = 0\n    velocity[-1] = 0\n    solve(T, V, velocity)\n    velocity = velocity[::-1]\n    solve(T[::-1], V[::-1], velocity)\n\n    ans = 0\n    pre_v = velocity[0]\n    for v in velocity[1:]:\n        ans += (pre_v + v) * 0.25\n        pre_v = v\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nT = [int(a) * 2 for a in input().split()]\nV = [int(a) * 2 for a in input().split()]\nMA = [0] * (sum(T) + 1)\na = 0\nfor i in range(N):\n    for j in range(T[i]):\n        a += 1\n        MA[a] = min(MA[a-1] + 1, V[i])\nMA[a] = 0\nfor i in range(N)[::-1]:\n    for j in range(T[i]):\n        a -= 1\n        MA[a] = min(MA[a], MA[a+1] + 1, V[i])\n\nprint((sum(MA[1:]) + sum(MA[:-1])) / 8)", "N = int(input())\nT = [0] + list(map(int,input().split()))\nV = [-1] + list(map(int,input().split()))\n\nans = 0\nfor i in range(1,N+1):\n    T[i] += T[i-1]\ntime = T[-1]\nupper  = {}\n\nstate = N\nspeed = 0\n\nfor t in range(2*time,0,-1):\n    t *= 0.5\n    if T[state-1] == t:\n        speed = min(V[state],speed)\n        state -= 1\n    upper[t] = min(speed,V[state])\n    speed += 0.5\n\nspeed = 0\npre = -1\nAns = []\nfor t in range(1,2*time+1):\n    t = t*0.5\n    speed += 0.5\n    speed = min(speed,upper[t])\n    Ans.append(speed)\n    if pre == speed:\n        ans += 0.5*speed\n    elif pre > speed:\n        ans += 0.5*speed + 0.125\n    else:\n        ans += 0.5*speed - 0.125\n    pre = speed\nprint(ans)", "n=int(input())\nt=list(map(int,input().split()))\nu=list(map(int,input().split()))\nspeed=[0]\nfor i in range(n):\n  speed+=[u[i]]*t[i]*2\nspeed.append(0)\nm=len(speed)\nfor i in range(1,m):\n  speed[i-1]=min(speed[i-1],speed[i])\ndel speed[-1]\nm-=1\nfor i in range(1,m):\n  speed[i]=min(speed[i],speed[i-1]+0.5)\nfor i in range(m-2,-1,-1):\n  speed[i]=min(speed[i],speed[i+1]+0.5)\nans=0\nfor i in range(1,m):\n  ans+=abs(speed[i-1]+speed[i])*0.25\nprint(ans)", "n = int(input())\nlist_t = list(map(int, input().split()))\nlist_v = list(map(int, input().split()))\n\nlist_v2 = [0 for i in range(n+1)]\nlist_t.append(0)\nlist_v.append(0)\nfor i in range(n-1)[::-1]:\n  list_v2[i] = min(list_v[i], list_v[i+1], list_v2[i+1] + list_t[i+1])\n\ndist = 0\nv0 = 0\nfor i in range(n):\n  t1 = min(list_v[i] - v0, (list_t[i] - (v0 - list_v2[i])) / 2, list_t[i])\n  t2 = max(v0 + t1 - list_v2[i], 0)\n  dist += (2*v0+t1)*t1/2 + (v0+t1)*(list_t[i]-t1-t2) + (2*(v0+t1)-t2)*t2/2\n  v0 = v0 + t1 - t2\nprint(dist)", "import sys, os\n\nf = lambda:list(map(int,input().split()))\nif 'local' in os.environ :\n    sys.stdin = open('./input.txt', 'r')\n\ndef solve():\n    n = f()[0]\n    t = f()\n    v = f()\n    \n\n\n    sumt = sum(t)*2\n    vs = [100000000] * (sumt+1)\n\n    vs[0] = 0\n\n    for i in range(1,sumt):\n        totalt = 0\n        idx = 0\n        for k in range(n):\n            totalt += t[k]*2\n            if totalt >= i:\n                idx = k\n                break\n\n        vs[i] = min(vs[i-1]+0.5, v[idx])\n\n    vs[sumt] = 0\n    for i in range(sumt-1, 0, -1):\n        totalt = 0\n        idx = 0\n        for k in range(n):\n            totalt += t[k]*2\n            if totalt >= i+1:\n                idx = k\n                break\n\n        vs[i] = min(vs[i+1]+0.5, vs[i], v[idx])\n\n    ans = 0\n    for i in range(sumt):\n        ans += (vs[i]+ vs[i+1])/4\n\n\n    # print(dict(zip(range(len(vs)), vs)))\n    print(ans)\n\nsolve()\n", "def main():\n    N = int(input())\n    T = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n    T = [t * 2 for t in T]\n    V = [v * 2 for v in V]\n    Tall = sum(T)\n    R = [0] * (Tall + 1)\n    j = N - 1\n    tc, vc, vn = T[-1], V[-1], V[-1]\n    R[-1] = 0\n    for i in reversed(list(range(Tall))):\n        tc -= 1\n        if tc == 0:\n            j -= 1\n            tc, vn = T[j], V[j]\n        R[i] = min(R[i + 1] + 1, vc, vn)\n        vc = vn\n    v = 0\n    d = 0.0\n    j = 0\n    tc, vc, vn = T[j], V[j], V[j]\n    T.append(0)\n    V.append(0)\n    for i in range(1, Tall + 1):\n        tc -= 1\n        if tc == 0:\n            j += 1\n            tc, vn = T[j], V[j]\n        vnn = min(v + 1, R[i], vc, vn)\n        d += (v + vnn) / 2\n        vc = vn\n        v = vnn\n    print((d / 4))\n\nmain()\n", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\ncumsum_t = [0]*(n+1)\nfor i in range(n):\n    cumsum_t[i+1] = cumsum_t[i] + t[i]\n\nv_max = [0]*(2*sum(t) + 1)\nfor i in range(len(cumsum_t) - 1):\n    for j in range(2*cumsum_t[i], 2*cumsum_t[i+1]):\n        v_max[j] = v[i]\nfor i in range(len(cumsum_t) - 1):\n    v_max[cumsum_t[i+1]*2] = min(v_max[cumsum_t[i+1]*2], v[i])\n\nspeed = [101]*(2*sum(t) + 1)\nspeed[0] = 0\nspeed[-1] = 0\nfor i in range(len(speed) - 1):\n    speed[i+1] = min(speed[i+1], speed[i] + 0.5, v_max[i+1])\nfor i in range(len(speed) - 1)[::-1]:\n    speed[i] = min(speed[i], speed[i+1] + 0.5, v_max[i])\n\nprint(sum(speed)/2)", "n=int(input())\nt=list(map(int,input().split()))\nT=[-1,0]\nfor i in range(n):\n  T.append(T[-1]+t[i])\nT.append(T[-1]+1)\nV=[0]+list(map(int,input().split()))+[0]\nVV=[110]*(2*T[-1]+1)\nfor i in range(n+2):\n  for j in range(2*T[-1]+1):\n    if j<2*T[i]:\n      a=T[i]-j/2\n      VV[j]=min(VV[j],a+V[i])\n    elif 2*T[i]<=j and j<=2*T[i+1]:\n      VV[j]=min(VV[j],V[i])\n    else:\n      a=j/2-T[i+1]\n      if a>100:\n        break\n      VV[j]=min(VV[j],a+V[i])\nprint(sum(VV)/2)", "n=int(input())\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))+[0]\nfor i in range(n-1,-1,-1):\n    v[i]=min(v[i],v[i+1]+t[i])\nans=0\nv0=0\nfor i in range(n):\n    if v[i]<=v[i+1]:\n        if v[i]-v0>t[i]:\n            ans+=(2*v0+t[i])*t[i]/2\n            v0=v0+t[i]\n        else:\n            ans+=t[i]*v[i]-(v[i]-v0)**2/2\n            v0=v[i]\n    else:\n        if v[i]*2-v0-v[i+1]<t[i]:\n            ans+=t[i]*v[i]-(v[i]-v0)**2/2-(v[i]-v[i+1])**2/2\n            v0=v[i+1]\n        elif v[i+1]-v0>t[i]:\n            ans+=(2*v0+t[i])*t[i]/2\n            v0=v0+t[i]\n        else:\n            d=abs(v0-v[i+1])\n            ans+=max(v0,v[i+1])*t[i]-d**2/2+(t[i]-d)**2/4\n            v0=v[i+1]\nprint(ans)", "n = int(input())\nt = [int(i) for i in input().split()]\nv = [int(i) for i in input().split()]\n\nmaxspeed = [0]*(n+1)\nfor i in range(n-1,0,-1):\n    maxspeed[i] = min(v[i], v[i-1], t[i] + maxspeed[i+1])\n\ndef dist(i,first): # distance,lastspeed\n    ta = v[i] - first\n    tb = v[i] - maxspeed[i+1]\n    if ta + tb <= t[i]:\n        c = (first+v[i])*ta/2 + v[i]*(t[i]-ta-tb) + (maxspeed[i+1]+v[i])*tb/2\n        lastspeed = maxspeed[i+1]\n    elif maxspeed[i+1] - first > t[i]:\n        c = (first + first + t[i])*t[i]/2\n        lastspeed = first + t[i]\n    else:\n        a = (maxspeed[i+1]+t[i]-first)/2\n        c = (first+first+a)*a/2 + (first+a+maxspeed[i+1])*(t[i]-a)/2\n        lastspeed = maxspeed[i+1]\n    return c, lastspeed\n\n\nans = 0\nfirstspeed = 0\nfor i in range(n):\n    d,firstspeed = dist(i,firstspeed)\n    ans += d\n\nprint(ans)    \n", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nTtot = sum(T)\nWf = [0]*(Ttot+1)\nWb = [0]*(Ttot+1)\n\ni = 0\nw = 0\nfor t,v in zip(T,V):\n    for j in range(t):\n        i += 1\n        w = min(w+1, v)\n        Wf[i] = w\n\ni = 0\nw = 0\nfor t,v in zip(T[::-1],V[::-1]):\n    for j in range(t):\n        i += 1\n        w = min(w+1, v)\n        Wb[i] = w\n\nans = 0\nwp = 0\nwfp = 0\nwbp = Wb[Ttot]\nfor i in range(1, Ttot+1):\n    wf = Wf[i]\n    wb = Wb[Ttot-i]\n    \n    w = min(wf, wb)\n    ans += wp + 0.5*(w-wp)\n    if wf-wfp==1 and wb-wbp==-1 and w==wp:\n        ans += 0.25\n\n    wp = w\n    wfp = wf\n    wbp = wb\n\nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = INT()\n# 0.5\u8003\u616e\u306e\u305f\u3081*2\u3001\u7d42\u4e86\u66420\u306e\u305f\u3081\u756a\u5175\nA = [a*2 for a in LIST()] + [1]\nB = [b*2 for b in LIST()] + [0]\n\ndef check1(i, t):\n    nxtt = cur\n    for j in range(i+1, N+1):\n        nxtt += A[j-1]\n        dist = nxtt - t\n        # 1\u3064\u5148\u3067+1\u306e\u72b6\u614b\u3067\u3044\u3066\u3082\u5927\u4e08\u592b\u304b\u3069\u3046\u304b\n        if spd + 2 - dist > B[j]:\n            return False\n    return True\n\ndef check2(i, t):\n    nxtt = cur\n    for j in range(i+1, N+1):\n        nxtt += A[j-1]\n        dist = nxtt - t\n        # 1\u3064\u5148\u3067\u4eca\u3068\u540c\u3058(+-0)\u306e\u72b6\u614b\u3067\u3044\u3066\u3082\u5927\u4e08\u592b\u304b\u3069\u3046\u304b\n        if spd + 1 - dist > B[j]:\n            return False\n    return True\n\ncur = spd = sm = 0\nfor i, a in enumerate(A[:N]):\n    b = B[i]\n    # \u5404\u6642\u70b9t\u306b\u304a\u3044\u3066\u52a0\u901f\u3001\u7dad\u6301\u304c\u53ef\u80fd\u304b\u3069\u3046\u304b\u78ba\u8a8d\n    for t in range(cur, cur+a):\n        # \u52a0\u901fOK\n        if spd + 1 <= b and check1(i, t):\n            # \u3053\u306e\u77ac\u9593\u306e\u52a0\u7b97\u5206\u306f\u5897\u6e1b\u306e\u534a\u5206\u306b\u3059\u308b\n            sm += spd + 0.5\n            spd += 1\n        # \u7dad\u6301OK\n        elif spd <= b and check2(i, t):\n            sm += spd\n        # \u6e1b\u901f\u5fc5\u9808\n        else:\n            sm += spd - 0.5\n            spd -= 1\n    cur += a\nprint((sm / 4))\n", "#!/usr/bin/env python3\nimport sys\ntry:\n    from typing import List\nexcept ImportError:\n    pass\n\n\ndef solve(N: int, t: \"List[int]\", v: \"List[int]\"):\n    bounds = [[] for _ in range(N)]\n    gb0 = (1, 0)\n    tend = sum(t)\n    gb1 = (-1, tend)\n    for i in range(N):\n        bounds[i].append(gb0)\n        bounds[i].append(gb1)\n    stt = 0\n    for i in range(N):\n        ti = t[i]\n        vi = v[i]\n        end = stt + ti\n        b0 = (-1, stt + vi)\n        b1 = (0, vi)\n        b2 = (1, -end + vi)\n        for j in range(i):\n            bounds[j].append(b0)\n        bounds[i].append(b1)\n        for j in range(i + 1, N):\n            bounds[j].append(b2)\n        stt = end\n    stt = 0\n    vms = [0] * (tend * 2 + 1)\n    for i in range(N):\n        end = stt + t[i]\n        bi = bounds[i]\n        inf = float(\"inf\")\n        mins = {-1: inf, 0: inf, 1: inf}\n        for a, b in bi:\n            mins[a] = min(mins[a], b)\n        for tm in range(stt * 2, end * 2):\n            vms[tm] = min(a * tm + b * 2 for a, b in list(mins.items()))\n        stt = end\n    print((sum(vms) / 4))\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    t = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    v = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, t, v)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N=int(input())\nt=list(map(int, input().split()))\nv=list(map(int, input().split()))\nT=sum(t)\nV=[0]*(T+2)\nfrom collections import deque\nq=[deque() for i in range(101)]\ns=0\nfor i in range(N):\n    temp=min(V[s],v[i])\n    q[temp].append(s)\n    for j in range(t[i]):\n        V[s+j+1]=v[i]\n    s+=t[i]\nq[0].append(T)\nvans=[-1]*(T+1)\nfor i in range(101):\n    while(len(q[i])>0):\n        s=q[i].popleft()\n        if vans[s]==-1:\n            vans[s]=i\n        if s>0 and vans[s-1]==-1:\n            if V[s]>i:\n                q[i+1].append(s-1)\n            else:\n                q[i].append(s-1)\n        if s<T and vans[s+1]==-1:\n            if V[s+1]>i:\n                q[i+1].append(s+1)\n            else:\n                q[i].append(s+1)\nans=0\nfor i in range(T):\n    if vans[i+1]>vans[i]:\n        ans+=vans[i]+0.5\n    elif vans[i+1]<vans[i]:\n        ans+=vans[i+1]+0.5\n    elif V[i+1]>vans[i]:\n        ans+=vans[i]+0.25\n    else:\n        ans+=vans[i]\nprint(ans)", "n = int(input())\nT = [0] + list(map(int, input().split()))\nV = [0] + list(map(int, input().split())) + [0]\n\nunit = 2\n\nacumT = [0] * (n + 1)\nfor i in range(n):\n  acumT[i+1] = acumT[i] + T[i+1]\n  \nPV = [0] * (sum(T) * unit + 1)\nfor p in range(1, n + 1):\n  t1 = acumT[p-1]\n  t2 = acumT[p]\n# for (t1, t2), (v1, v2, v3) in zip(zip(acumT, acumT[1:]), zip(V, V[1:], V[2:])):\n  for i in range(t1 * unit, t2 * unit + 1):\n    ii = i / unit \n    PV[i] = min([ii - acumT[k] + V[k] for k in range(0, p)] + [V[p]] + [-ii + acumT[m] + V[m+1] for m in range(p, n+1)])\n\narea = sum((i + j) / unit / 2 for i, j in zip(PV, PV[1:]))  \nprint(area)", "n=int(input())\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\nT=sum(t)\nansv=[0]\nfor i in range(n):\n  ansv[-1]=min(ansv[-1],v[i])\n  for j in range(t[i]*2):\n    ansv.append(v[i])\nansv[-1]=0\n#for i in range(len(ansv)):\n#  print(i/2,ansv[i])\nfor i in range(2*T):\n  ansv[i+1]=min(ansv[i]+0.5,ansv[i+1])\nfor i in range(2*T,0,-1):\n  ansv[i-1]=min(ansv[i]+0.5,ansv[i-1])\nprint((sum(ansv)/2))\n#print(len(ansv))\n#for i in range(len(ansv)):\n#  print(i/2,ansv[i])\n", "import sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\u7a7a\u767d\u3042\u308a\n\n\nN = I()\nt = LI()\nv = LI()\n\nmax_v = [0]*(N+1)  # 0\u79d2\u5f8c,t1\u79d2\u5f8c,t1+t2\u79d2\u5f8c,\u2026\u306e\u6642\u70b9\u3067\u51fa\u305b\u308b\u6700\u5927\u901f\u5ea6\nfor i in range(N-1):\n    max_v[i+1] = min(v[i],v[i+1],max_v[i]+t[i])\nfor i in range(N-2,-1,-1):\n    max_v[i+1] = min(max_v[i+1],v[i],v[i+1],max_v[i+2]+t[i+1])\n\nans = 0\nfor i in range(N):\n    if t[i] >= (v[i]-max_v[i]) + (v[i]-max_v[i+1]):\n        ans += t[i]*v[i]-(v[i]-max_v[i])**2/2-(v[i]-max_v[i+1])**2/2\n    else:\n        x = (t[i]+max_v[i]+max_v[i+1])/2\n        ans += t[i]*x-(x-max_v[i])**2/2-(x-max_v[i+1])**2/2\n\nprint(ans)\n", "import sys\n\nimport numpy as np\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nN = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nT = np.array(T).cumsum()\nV = np.array(V)\n\nva = []\ni = 0\nfor t in np.arange(0, T[-1], 0.5):  # 0.5 \u533a\u5207\u308a\u306e\u6642\u9593\n    if t < T[i]:\n        va.append(V[i])\n    else:\n        i += 1\n        va.append(min(V[i], V[i - 1]))\nva.append(0)\n\nv = 0\nfor i in range(len(va)):\n    va[i] = min(va[i], v)\n    v = va[i] + 0.5\nv = 0\nfor i in reversed(list(range(len(va)))):\n    va[i] = min(va[i], v)\n    v = va[i] + 0.5\n\nprint(((np.array(va) / 2).sum()))\n", "n=int(input())\ninpt=list(map(int,input().split()))\ninpv=list(map(int,input().split()))\n\nt=inpt+[0]\nv=inpv+[0]\n\nT=sum(t)\nM=[0]\n\nnowt=2*t[0]\nnowmaxv=v[0]\nnowv=M[0]\ni=0\n\nfor time in range(2*T):\n    if nowv+0.5<=v[i]:\n        M.append(nowv+0.5)\n    else:\n        M.append(nowv)\n    nowt-=1\n    nowv=M[-1]\n    if nowt==0:\n        i+=1\n        nowt=2*t[i]\n        nowmaxv=v[i]\n        nowv=min(nowv,nowmaxv)\n        \nt=list(reversed(inpt))+[0]\nv=list(reversed(inpv))+[0]\nm=[0]\n\nnowt=2*t[0]\nnowmaxv=v[0]\nnowv=M[0]\ni=0\n\nfor time in range(2*T):\n    if nowv+0.5<=v[i]:\n        m.append(nowv+0.5)\n    else:\n        m.append(nowv)\n    nowt-=1\n    nowv=m[-1]\n    if nowt==0:\n        i+=1\n        nowt=2*t[i]\n        nowmaxv=v[i]\n        nowv=min(nowv,nowmaxv)\n\nans=[min(M[i],m[-i-1]) for i in range(len(M))]\nprint(sum([min(ans[i],ans[i+1])+(ans[i+1]-ans[i])**2 for i in range(len(ans)-1)])/2)", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nN = int(input())\nT = list(map(int,input().split()))\nV = list(map(int,input().split()))\n\ndef calc_area(v1,v2,t,lim):\n    if v1 > v2:\n        v1,v2 = v2,v1\n    if v2 == lim:\n        if lim - v1 < t:\n            return t*lim - (lim - v1)*(lim - v1)/2\n        else:\n            return (v1 + v2)*t/2\n    else:\n        if 2*lim - v1 - v2 < t:\n            return t*lim - (lim - v1)*(lim - v1)/2 - (lim - v2)*(lim - v2)/2\n        else:\n            mid = (t + v2 - v1)/2\n            return (mid + 2*v1)*mid/2 + (t - mid + 2*v2)*(t - mid)/2\n\ndef calc(N,T,V,maxv):\n    ans = 0\n    v = 0\n    for i in range(N):\n        next_v = min(v + T[i],maxv[i])\n        ans += calc_area(v,next_v,T[i],V[i])\n        v = next_v\n    return ans\n\nmaxV = [0] * N\nfor i in range(N - 2,-1,-1):\n    maxV[i] = min(maxV[i + 1] + T[i + 1],V[i],V[i + 1])\nans = calc(N,T,V,maxV) \nprint(ans)", "N=int(input())\ninl=list([int(x)*2 for x in input().split()])\nvs=list(map(int,input().split()))\n\nsumtime = sum(inl)\n\nlimits = [0]\nfor i, t in enumerate(inl):\n    for _ in range(t):\n        limits.append(vs[i])\n\nresv = [0]\nfor i in range(1, sumtime+1):\n    resv.append(min(resv[-1]+0.5, limits[i]))\n\nresv[sumtime] = 0\nfor i in reversed(list(range(1, sumtime+1))):\n    resv[i-1] = min(resv[i]+0.5, resv[i-1], limits[i])\n\n# print(limits)\n# print(resv)\nres = 0.0\nfor i in range(sumtime):\n    res += (resv[i] + resv[i+1])*0.5\n\nprint((res*0.5))\n", "#!/usr/bin/env python\n# coding: utf-8\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(input().split())\n\ndef rli():\n    return list(map(int, input().split()))\n\ndef mileage(t, v, vl, vr):\n    assert(0 <= vl <= v and 0 <= vr <= v)\n    # \u6700\u9ad8\u901f\u5ea6v, \u5de6\u7aef\u3067\u306e\u901f\u5ea6vl, \u53f3\u7aef\u3067\u306e\u901f\u5ea6vr, \u79d2\u6570t\u306e\u6642\u306e\u8d70\u884c\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n    l = v-vl\n    r = t-(v-vr)\n    if l > r:\n        tmp = (l+r)/2\n        l = tmp\n        r = tmp\n    ret = 0\n    ret += l*l/2+vl*l\n    ret += (r-l)*v\n    ret += (t-r)*vr+(t-r)*(t-r)/2\n    return ret\n\ndef main():\n    n = ri()\n    lt = rli()\n    lv = rli()\n    lt.append(0)\n    lv.append(0)\n    lefts = [0] # \u5404\u533a\u9593\u306e\u5de6\u7aef\u3067\u306e\u5217\u8eca\u306e\u901f\u5ea6\n    for i in range(n):\n        left = min(lefts[i]+lt[i], lv[i], lv[i+1])\n        offset = 0\n        for j in range(i+1, n+1):\n            left = min(left, offset+lv[j])\n            offset += lt[j]\n        lefts.append(left)\n    # print(lefts)\n    ans = 0\n    for i in range(n):\n        ans += mileage(lt[i], lv[i], lefts[i], lefts[i+1])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N=int(input())\nnow=0\nT=list(map(int,input().split()))\nfor i in range(1,N):\n    T[i]+=T[i-1]\nT=[-1*float('inf'),0]+T+[float('inf')]\nV=list(map(int,input().split()))\nV=[0]+V+[0]\nvt=[float('inf')]*(T[-2]+1)\nfor t in range(len(vt)):\n    now=t\n    for k in range(N+2):\n        if now<T[k]:\n            vt[t]=min(vt[t],V[k]+T[k]-now)\n        elif T[k]<=now<=T[k+1]:\n            vt[t]=min(vt[t],V[k])\n        elif T[k+1]<now:\n            vt[t]=min(vt[t],V[k]+now-T[k+1])\nans=0\nfor i in range(len(vt)-1):\n    if abs(vt[i+1]-vt[i])==1:\n        ans+=0.5*(vt[i]+vt[i+1])\n    elif vt[i+1]==vt[i]:\n        for k in range(N+2):\n            if T[k]<=i and i+1<=T[k+1]:\n                vv=V[k]\n                break\n        if vv>vt[i]:\n            ans+=0.5*(vt[i]*2+0.5)\n        else:\n            ans+=vt[i]\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nimport numpy as np\n\n\ndef solve(N: int, T: \"List[int]\", V: \"List[int]\"):\n    t_period = [0 for i in range(N+1)]\n    for i in range(N):\n        t_period[i+1] = t_period[i] + T[i]*2\n\n    limit = np.zeros((t_period[N]+1,))\n    for i in range(1, N):\n        limit[t_period[i]] = min((V[i-1], V[i]))\n    for i in range(N):\n        limit[t_period[i]+1:t_period[i+1]] = V[i]\n    \n    speed = np.zeros((t_period[N]+1,))\n\n    for v in range(1, 201):\n        speed[v:t_period[N]+1-v] = np.min(\n            [limit[v:t_period[N]+1-v], speed[v-1:t_period[N]-v]+0.5, speed[v+1:t_period[N]+2-v]+0.5],\n            axis=0\n            )\n\n    total = 0\n    for t in range(t_period[N]):\n        total += (speed[t] + speed[t+1]) * 0.5 * 0.5\n    \n    print(total)\n\n    return\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    t = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    v = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    solve(N, t, v)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    t = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    back_lim = []\n    lim = []\n    for i in range(n):\n        for _ in range(t[i]):\n            back_lim.append(v[i])\n            lim.append(v[i])\n    back_lim.append(0)\n    for i in reversed(list(range(len(back_lim)-1))):\n        back_lim[i] = min(back_lim[i], back_lim[i+1]+1)\n    ans = 0.0\n    p = 0\n    for i in range(len(back_lim)-1):\n        if p < back_lim[i+1]:\n            if p < lim[i]:\n                ans += p + 0.5\n                p += 1\n            else:\n                ans += p\n        elif p == back_lim[i+1]:\n            if p < lim[i]:\n                ans += p + 0.25\n            else:\n                ans += p\n        else:\n            ans += p - 0.5\n            p -= 1\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nimport sys, collections, bisect, math, itertools\nfrom fractions import gcd \ninput = sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306e\u3068\u304d\u306f\u6ce8\u610f\n\nn = int(input())\nt = [int(i) for i in input().split()]\nv = [int(i) for i in input().split()]\n\nmaxspeed = [0]*(n+1)\nfor i in range(n-1,0,-1):\n    maxspeed[i] = min(v[i], v[i-1], t[i] + maxspeed[i+1])\n\n#print(t)\n#print(v)\n#print(maxspeed)\n\ndef dist(first,i): # distance,lastspeed\n    ti = t[i]\n    vi = v[i]\n    mi1= maxspeed[i+1]\n    ta = vi - first\n    tb = vi - mi1\n    if ta + tb <= ti:\n        c = (first+vi)*ta/2 + vi*(ti-ta-tb) + (mi1+vi)*tb/2\n        lastspeed = mi1\n    elif mi1 - first > ti:\n        c = (first + first + ti)*ti/2\n        lastspeed = first + ti\n    else:\n        a = (mi1+ti-first)/2\n        c = (first+first+a)*a/2 + (first+a+mi1)*(ti-a)/2\n#        print(a,'a',c,first,(first+first+a)*a/2, (first+a+mi1)*(ti-a)/2)\n        lastspeed = mi1\n#    print(c)\n\n    return c, lastspeed\n\n\nans = 0\nfirstspeed = 0\nfor i in range(n):\n    d,firstspeed = dist(firstspeed,i)\n#    print(d,firstspeed)\n    ans += d\n\nprint(ans)    \n    \n\n\n\n\n\n\n\n", "N = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# if N == 1: #\u6700\u521d\u306e1\u533a\u9593\u3060\u3051\n#     if t[0] % 2 == 1: #\u5947\u6570\u79d2\n#         if t[0]/2 < v[0]:\n#             print ((t[0]/2) ** 2)\n#             return\n        \n\n# print ('t', t)\n# print ('v', v)\nN_INF = - 10 ** 15\nDP = [[N_INF] * (102) for _ in range(100 * 200 + 2)] #DP[T][V] := \u6642\u523bT\u306b\u901f\u5ea6D\u3067\u8d70\u3063\u3066\u3044\u308b\u3068\u304d\u306e\u6642\u523bT\u307e\u3067\u306e\u8d70\u884c\u8ddd\u96e2\u306e\u6700\u5927\u5024\nDP[0][0] = 0\n# print (DP[0][0:5])\ntime = 1\nfor i in range(N):\n    # print (i)\n    # print ('time', time)\n    for j in range(time, time + t[i]): #\u6642\u523b\n        # print (j, end = ' ')\n        for k in range(0, v[i] + 1): #\u901f\u5ea6\n            if k == 0: #\u901f\u5ea60-->\u52a0\u901f\u3057\u3066\u901f\u5ea60\u306b\u306a\u308b\u3053\u3068\u306f\u306a\u3044\n                # print (j, k)\n                # print (max(DP[j - 1][0], DP[j - 1][1] +  1/2))\n                DP[j][k] = max(DP[j - 1][0] + 0.25, DP[j - 1][1] + 1/2)\n            elif k != v[i]: #\u52a0\u901f\u3057\u3066\u304f\u308b\u3068\u304d\u3082\u6e1b\u901f\u3057\u3066\u304f\u308b\u3053\u3068\u3082\u3042\u308b\n                DP[j][k] = max(DP[j - 1][k -1] + k - 1/2, DP[j - 1][k] + k + 0.25, DP[j - 1][k + 1] + k + 1/2)\n            else: #(k == v[i] and j != time) #\u6e1b\u901f\u3057\u3066\u304f\u308b\u3053\u3068\u306f\u306a\u3044\n                DP[j][k] = max(DP[j - 1][k -1] + k - 1/2, DP[j - 1][k] + k)\n        # print (DP[j][0:5])\n    time += t[i]\n# print (time)\nprint((DP[time - 1][0]))\n# print ('T = 6, V = 6', DP[6][6])\n# print ('T = 12, V = 2', DP[12][2])\n# print ('T = 12, V = 3', DP[12][3])\n# print ('T = 13, V = 2', DP[13][2])\n# print ('T = 26 V = 2', DP[26][2])\n# print ('T = 27 V = 2', DP[27][2])\n", "from itertools import accumulate\n\nN = int(input())\nT = [int(s) for s in input().split()]\nV = [int(s) for s in input().split()] + [0]\nlt = sum(T)\nS = list(accumulate(T))\n\nfor i in range(len(T), 0, -1):\n    V[i-1] = min(V[i-1], V[i] + T[i-1])\n\nvel2 = [0] * (2 * lt + 1)\nfor i in range(len(T)):\n    ti = T[i]\n    tr = S[i]\n    for ts in range(tr - ti, tr):\n        for t in (2 * ts + 1, 2 * ts + 2):\n            if vel2[t-1] - (2 * tr - (t - 1)) == 2 * V[i+1]:\n                vel2[t] = vel2[t-1] - 1\n            elif vel2[t-1] == 2 * V[i]:\n                vel2[t] = vel2[t-1]\n            else:\n                vel2[t] = vel2[t-1] + 1\nans = sum([(vel2[t-1] + vel2[t]) / 8 for t in range(1, 2 * lt + 1)])\nprint(ans)\n", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nmaxv = [0]\nfor _t, _v in zip(t, v):\n  maxv[-1] = min(maxv[-1], _v)\n  for ti in range(_t * 2):\n    maxv.append(_v)\n\nN = len(maxv)\ncandv = [0] * N\nfor i in range(N - 1):\n  candv[i + 1] = min(candv[i] + 0.5, maxv[i + 1])\n\ncandv[-1] = 0\nfor i in reversed(list(range(1, N))):\n  candv[i - 1] = min(candv[i - 1], candv[i] + 0.5)\n\nans = 0\nfor x1, x2 in zip(candv, candv[1:]):\n  ans += (x1 + x2) * 0.5 / 2\n\nprint(ans)\n", "import heapq\nn=int(input())\ninf=10000000000000\nans=[[-1,-1] for i in range(n)]\nans[-1][1],ans[0][0]=0,0\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\nv2=[]\nfor i in range(n):\n    heapq.heappush(v2,(v[i],i))\n\ndef next(y,wh):\n    nonlocal ans,n\n    ansi=inf\n    if wh:\n        r1,r2=range(y[1]-1,-1,-1),range(y[1],n)\n    else:\n        r1,r2=range(y[1],-1,-1),range(y[1]+1,n)\n    now=0\n    for j in r1:\n        if ans[j][1]!=-1:\n            ansi=min(ansi,ans[j][1]+now)\n        now+=t[j]\n        if ans[j][0]!=-1:\n            ansi=min(ansi,ans[j][0]+now)\n    now=0\n    for j in r2:\n        if ans[j][0]!=-1:\n            ansi=min(ansi,ans[j][0]+now)\n        now+=t[j]\n        if ans[j][1]!=-1:\n            ansi=min(ansi,ans[j][1]+now)  \n    if wh:\n        ans[y[1]][0]=min(ansi,y[0])\n        ans[y[1]-1][1]=ans[y[1]][0]\n    else:\n        ans[y[1]][1]=min(ansi,y[0])\n        ans[y[1]+1][0]=ans[y[1]][1]  \n\nfor i in range(n):\n    y=heapq.heappop(v2)\n    if ans[y[1]][0]==-1:next(y,True)\n    if ans[y[1]][1]==-1:next(y,False)\nanswer=0\nfor i in range(n):\n    h=min((t[i]+sum(ans[i]))/2,v[i])\n    answer+=((h**2-ans[i][0]**2)/2)\n    answer+=((h**2-ans[i][1]**2)/2)\n    answer+=(h*(t[i]+sum(ans[i])-2*h))\nprint(answer)", "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\n# \u914d\u5217\u304b\u3089\u7d2f\u7a4d\u548c\u3092\u8fd4\u3059\ndef make_cumulative(A):\n    C = [0] * (len(A) + 1)\n    for i, a in enumerate(A):\n        i += 1\n        C[i] = C[i - 1] + a\n    return C\n\n\ndef main():\n    N = NI()\n    T = [0] + NLI()\n    V = [0] + NLI() + [0]\n    B = [[] for _ in range(N+1)]\n    cum_T = make_cumulative(T)[1:]\n\n    limits = [[] for _ in range(N)]\n    for i, v in enumerate(V):\n        for t in range(N):\n            if t == i-1:\n                limits[t].append([v, 0])\n            elif t == i:\n                limits[t].append([v, 1])\n            elif t < i-1:\n                limits[t].append([v + (cum_T[i-1] - cum_T[t]), -1])\n            else:\n                limits[t].append([v + (cum_T[t] - cum_T[i]), 1])\n    limits = [sorted(l) for l in limits]\n\n\n    ans = 0\n    for li, limit in enumerate(limits):\n        if limit[0][1] == -1:\n            ans += limit[0][0] * T[li+1] - T[li+1]**2 / 2\n            continue\n\n        if limit[0][1] == 0:\n            next_l = limit[1]\n            for j in range(1, len(limit)):\n                if limit[j][1] == -1:\n                    next_l = limit[j]\n                    break\n            if next_l[1] == -1 and next_l[0] < limit[0][0] + T[li+1]:\n                ans += limit[0][0] * T[li+1] - (limit[0][0]-next_l[0]+T[li+1])**2 / 2\n            else:\n                ans += limit[0][0] * T[li+1]\n            continue\n\n        stay = [l for l in limit if l[1] == 0]\n        down = [l for l in limit if l[1] == -1]\n        if down == []:\n            down_l = [10**5, -1]\n        else:\n            down_l = down[0]\n        if stay == []:\n            stay_l = [10**5, 0]\n        else:\n            stay_l = stay[0]\n\n        if down_l[0] >= limit[0][0] + T[li+1]*2:\n            ans += limit[0][0] * T[li + 1] + T[li + 1] ** 2 / 2\n            if limit[0][0] < stay_l[0] < limit[0][0] + T[li+1]:\n                ans -= (limit[0][0] + T[li+1] - stay_l[0])**2 / 2\n        else:\n            h = (down_l[0] - limit[0][0])/2\n            if stay_l[0] >= limit[0][0] + h:\n                ans += (limit[0][0]+h) * T[li+1] - h**2/2 - (T[li+1]-h)**2/2\n                continue\n\n            m, M = min(limit[0][0], down_l[0]-T[li+1]), max(limit[0][0], down_l[0]-T[li+1])\n            if M < stay_l[0] < limit[0][0] + h:\n                ans += (limit[0][0] + h) * T[li + 1] - h ** 2/2 - (T[li + 1] - h) ** 2/2\n                ans -= (limit[0][0] + h - stay_l[0]) ** 2\n                continue\n\n            if stay_l[0] <= M:\n                ans += stay_l[0] * T[li+1] - (stay_l[0]-limit[0][0])**2 / 2\n                continue\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n \nN=int(input())\nT=list(map(int,input().split()))\nV=list(map(int,input().split()))\n\nMAX_V=[0]\nfor t,v in zip(T,V):\n  MAX_V[-1]=min(MAX_V[-1],v)\n  for _ in range(t*2):\n    MAX_V.append(v)\n  #print(MAX_V)\n  #print(len(MAX_V))\n\ntimelistsize=len(MAX_V)\nREAL_V=[0]*timelistsize\n\n#\u30b9\u30d4\u30fc\u30c9\u304c\u52a0\u901f\u3059\u308b\u90e8\u5206\u306e\u901f\u5ea6\u3092\u8868\u73fe\nfor i in range(1,timelistsize):\n  REAL_V[i]=min(REAL_V[i-1]+0.5,MAX_V[i])\n\n#\u7d42\u4e86\u4f4d\u7f6e\u304b\u3089\u540c\u3058\u3088\u3046\u306b\u3057\u3066\u6e1b\u901f\u90e8\u5206\u306e\u901f\u5ea6\u3092\u8868\u73fe\nREAL_V[-1]=0\nfor i in range(timelistsize-1,0,-1):\n  REAL_V[i-1]=min(REAL_V[i]+0.5,REAL_V[i-1])\n\n\n#0.5\u79d2\u523b\u307f\u306e\u901f\u5ea6\u304c\u3067\u304d\u3066\u3044\u308b\u306e\u3067\u30010.5\u3092\u9ad8\u3055,0.5\u79d2\u3054\u3068\u306e\u901f\u5ea6\u3092\u4e0a\u8fba,\u4e0b\u8fba\u3068\u3057\u305f\u53f0\u5f62\u9762\u7a4d\u3092\u8db3\u3059\nanswer=0\nfor i in range(timelistsize-1):\n  answer+=((REAL_V[i]+REAL_V[i+1])*0.5/2)\nprint(answer)\n\n'''\ntsum=np.sum(t)\nprint(tsum)\n \nRuisekit=[t[0]]\n \nfor i in range(1,N):\n  Ruisekit.append(t[i]+Ruisekit[i-1])\n  \nprint(Ruisekit)\n \n \n \n \ndownstart=[]\n \nfor i in range(N-1):\n  if v[i]>v[i+1]:\n    downstart.append(t[i]-(v[i]-v[i+1]))\n \nprint(downstart)\n \nvelocity=0\ndownindex=0\n \nif downstart:\n  nextdownstarttime=downstart[downindex]\n \nstate='up'\nupstarttime=0\nupstartspeed=0\nanswer=0\nmaxspeed=v[0]\nmaxspeedindex=0\n \nfor time in range(1,tsum+1):\n  if state=='up':\n    velocity+=1\n    #print('velocity:',velocity)\n    #print('time',time)\n  if state=='down':\n    velocity-=1\n  if time==nextdownstarttime:\n    if state=='plane':\n      answer+=(time-planestarttime)*speed\n    state='down'\n    print(state)\n    downstarttime=time\n    downstartspeed=speed\n    downindex+=1\n    if downindex<len(downstart):\n      nextdownstarttime=downstart[downindex]\n  if time==Ruisekit[maxspeedindex]:\n    maxspeedindex+=1\n    if maxspeedindex<len(v):\n      maxspeed=v[maxspeedindex]\n  if velocity==maxspeed and state!='plane':\n    if state=='up':\n      answer+=(time-upstarttime)*(velocity-upstartspeed)*0.5\n      answer+=(time-upstarttime)*upstartspeed\n    if state=='down':\n      answer+=(time-downstarttime)*(downstartspeed-velocity)*0.5\n      answer+=(time-downstarttime)*downstartspeed\n    \n    state='plane'\n    planestarttime=time\n    speed=velocity\n    \n  print(answer,time,maxspeed,velocity,state)\n''' ", "n = int(input())\nt = [int(i) for i in input().split()]\nv = [int(i) for i in input().split()]\n\nm = [0]*(n+1)\nz = [0]*(n+1)\nfor i in range(n-1,0,-1):\n    m[i] = min(v[i], v[i-1], t[i] + m[i+1])\nfor i in range(1,n):\n    z[i] = min(m[i], z[i-1]+t[i-1])\n\ndef dist(i):\n    lspeed = z[i]\n    rspeed = z[i+1]\n    ta = v[i] - lspeed\n    tb = v[i] - rspeed\n    if ta + tb <= t[i]: # \u5c71\u3092\u62bc\u3055\u3048\u305f\u5f62\n        c = (lspeed+v[i])*ta/2 + v[i]*(t[i]-ta-tb) + (rspeed+v[i])*tb/2\n    else: #\u5c71\u306e\u5f62\n        a = (rspeed+t[i]-lspeed)/2\n        c = (2*lspeed+a)*a/2 + (lspeed+a+rspeed)*(t[i]-a)/2\n    return c\n\nans=0\nfor i in range(0,n):\n    ans += dist(i)\n\nprint(ans)    \n", "\ndef main():\n    buf = input()\n    N = int(buf)\n    buf = input()\n    buflist = buf.split()\n    t = list(map(int, buflist))\n    buf = input()\n    buflist = buf.split()\n    v = list(map(int, buflist))\n    t.append(0)\n    v.append(0)\n    for i, _ in enumerate(t): # double time and speed to make calculation easier\n        t[i] *= 2\n        v[i] *= 2\n    time = 0\n    last_speed = 0\n    speed = 0\n    distance = 0.0\n    point = 0\n    spd_time_list = []\n    for i, _ in enumerate(t):\n        spd_time_list.append((v[i], (0 if not spd_time_list else t[i-1] + spd_time_list[-1][1])))\n    while time < spd_time_list[-1][1]:\n        last_speed = speed\n        brake = False\n        for i in range(point+1, len(spd_time_list)):\n            if speed >= spd_time_list[i][0] + (spd_time_list[i][1] - time):\n                brake = True\n                break\n        if brake:\n            speed -= 1\n        elif speed < spd_time_list[point][0]:\n            speed += 1\n        distance += (last_speed + speed) / 2\n        time += 1\n        if time >= spd_time_list[point+1][1]:\n            point += 1\n    distance /= 4 # roll back time and speed (and so the distance)\n    print(distance)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nt=[int(i) for i in input().split()]\nv=[int(i) for i in input().split()]\nl=[]\n\nfor i in range(n):\n    l+=[v[i]]*t[i]*2\n\nl=[min(i,j) for i,j in zip([0]+l,l+[0])]\n\nfor i in range(1,len(l)):\n    l[i]=min(l[i],l[i-1]+0.5)\nfor i in range(len(l)-1)[::-1]:\n    l[i]=min(l[i],l[i+1]+0.5)\n\nans=0\n\nfor i in range(1,len(l)):\n    ans+=0.25*(l[i]+l[i-1])\n\nprint(ans)", "n = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\ntmp = 0\ne_t = []\nfor i in t:\n    tmp+=i\n    e_t.append(tmp)\n\ndef calc_end_speed(s):\n    end_time = e_t[s]\n    ma = 10**10\n    for i in range(s+1, n):\n        ma = min(e_t[i-1] - end_time + v[i], ma)\n    return min(e_t[-1] - end_time, v[s], ma)\n\nans = 0\nstart_speed = 0\n\nfor sect in range(n):\n    end_speed = min(calc_end_speed(sect), start_speed+t[sect])\n    turn_time = (t[sect]+end_speed-start_speed)/2\n    acce_end = min(v[sect]-start_speed, turn_time)\n    dece_start = max(t[sect]-(v[sect]-end_speed) ,turn_time)\n    max_speed = start_speed+acce_end\n    ans += (start_speed+max_speed)*acce_end/2\n    ans += max_speed*(dece_start-acce_end)\n    ans += (end_speed+max_speed)*(t[sect]-dece_start)/2\n    start_speed = end_speed\n\nprint(ans)", "f=lambda line,x:line[0]*x+line[1]\ndef _add_line(line,k,l,r):\n    m=(l+r)//2\n    if not data[k]:\n        data[k]=line\n        return\n    lx,mx,rx=X[l],X[m],X[r-1]\n    left,mid,right=f(line,lx)<f(data[k],lx),f(line,mx)<f(data[k],mx),f(line,rx)<f(data[k],rx)\n    if left and right:\n        data[k]=line\n        return\n    if not left and not right:return\n    if mid:data[k],line=line,data[k]\n    if left!=mid:_add_line(line,2*k+1,l,m)\n    else:_add_line(line,2*k+2,m,r)\ndef add_line(line,a,b):\n    L,R=a+N0,b+N0\n    a0,b0=a,b\n    sz=1\n    while L<R:\n        if R&1:\n            R-=1\n            b0-=sz\n            _add_line(line,R-1,b0,b0+sz)\n        if L&1:\n            _add_line(line,L-1,a0,a0+sz)\n            L+=1\n            a0+=sz\n        L>>=1\n        R>>=1\n        sz<<=1\ndef query(k):\n    x=X[k]\n    k+=N0-1\n    s=10**18\n    while k>=0:\n        if data[k]:\n            t=f(data[k],x)\n            if t<s:s=t\n        k=(k-1)//2\n    return s\nn,*t=map(int,open(0).read().split())\nt,v=t[:n],t[n:]\nst=sum(t)*2\nm=a=i=0\nN0=2**(st).bit_length()\ndata=[None]*(2*N0+1)\nX=list(range(st+1))+[10**18]*N0\ni=b=0\nadd_line((.5,0),0,st+1)\nfor u,w in zip(t,v):\n    u+=u+i\n    add_line((0,w),i,u)\n    add_line((-.5,w+i/2),0,i+1)\n    add_line((.5,w-u/2),u,st+1)\n    i,b=u,w\nadd_line((-.5,st/2),0,st+1)\na=x=0\nfor i in range(1,st+1):\n    y=query(i)\n    a+=(x+y)/4\n    x=y\nprint(a)", "N = int(input())\nT = list(map(int,input().split()))\nV = list(map(int,input().split()))\nmax_t = sum(T)\nvl = [0]*(max_t+1)\nvr = [0]*(max_t+1)\nvm = [0]*(max_t+1)\nt = 0\nfor s, u in zip(T,V):\n  for i in range(t,t+s):\n    vm[t] = u\n    t += 1\nt = 1\nfor s, u in zip(T,V):\n  for i in range(t, t+s):\n    vl[t] = min(u, vl[t-1]+1)\n    t += 1\nt = max_t\nfor s, u in zip(T[::-1],V[::-1]):\n  for i in range(t-s,t)[::-1]:\n    vr[t-1] = min(u,vr[t]+1)\n    t -= 1\nv = [min(vl[i],vr[i]) for i in range(max_t+1)]\n#print(vm)\n#print(vl)\n#print(vr)\n#print(v)\nans = 0\nfor i in range(max_t):\n  ans += (v[i] + v[i+1]) / 2\n  if v[i] == v[i+1] and v[i] != vm[i]:\n    ans += 0.25\nprint(\"{:.10f}\".format(ans))", "# Atcoder Express\nfrom bisect import bisect_left, bisect_right\nN = int(input())\ntime = list(map(int, input().split()))\nvel = list(map(int, input().split()))\nsum_t = [0 for i in range(N+1)]\n\nfor i in range(1, N+1):\n    sum_t[i] = sum_t[i-1]+time[i-1]\n\ndp = [[-float(\"inf\") for j in range(101)] for i in range(20001)]\n# dp[t][v]=\u958b\u59cb\u304b\u3089t\u79d2\u5f8c\u306b\u901f\u5ea6v \u3067\u8d70\u3063\u3066\u3044\u308b\u6642\u306b\u3001t\u79d2\u5f8c\u306b\u5b9f\u73fe\u3067\u304d\u308b\u6700\u5927\u306e\u79fb\u52d5\u8ddd\u96e2\ndp[0][0] = 0\n\nfor i in range(1, sum_t[-1]+1):\n    # i\u79d2\u5f8c\u306b\u304a\u3051\u308b\u66f4\u65b0\n\n    bef = bisect_left(sum_t, i-1)\n    phase = bisect_left(sum_t, i)\n\n    bef_bound = vel[bef-1]  # i-1\u79d2\u6642\u70b9\u306b\u304a\u3051\u308b\u901f\u5ea6\u5236\u9650\n    bound = vel[phase-1]    # i\u79d2\u5f8c\u306b\u304a\u3051\u308b\u901f\u5ea6\u5236\u9650\n    if bef == 0:\n        bef_bound = 100\n        \n    if bef_bound < bound:\n        for j in range(bef_bound+2):\n            if j == 0:\n                if j+1 <= bef_bound:\n                    dp[i][j] = max(dp[i-1][j]+j+0.25, dp[i-1][j+1]+j+0.5)\n                else:\n                    if j == bef_bound:\n                        dp[i][j] = dp[i-1][j]+j+0.25\n\n            elif j >= 1:\n                if j+1 <= bef_bound:\n                    dp[i][j] = max(dp[i-1][j-1]+j-0.5, dp[i-1]\n                                   [j]+j+0.25, dp[i-1][j+1]+j+0.5)\n                else:\n                    if j == bef_bound:\n                        dp[i][j] = max(dp[i-1][j-1]+j-0.5, dp[i-1][j]+j+0.25)\n                    else:\n                        if j-1 == bef_bound:\n                            dp[i][j] = dp[i-1][j-1]+j-0.5\n\n    elif bef_bound >= bound:\n        for j in range(bound):\n            if j == 0:\n                # j+1<=bef_bound:\n                dp[i][j] = max(dp[i-1][j]+j+0.25, dp[i-1][j+1]+j+0.5)\n            elif j >= 1:\n                dp[i][j] = max(dp[i-1][j-1]+j-0.5, dp[i-1]\n                               [j]+j+0.25, dp[i-1][j+1]+j+0.5)\n\n        dp[i][bound] = max(dp[i-1][bound]+bound, dp[i-1][bound-1]+bound-0.5)\n\n\nans = dp[sum_t[-1]][0]\nprint(ans)\n", "import numpy as np\n\nN = int(input())\nt = np.array(['0'] + input().split(), np.int64)\nv = list(map(int, input().split()))\n\n# \u767a\u8eca\u3057\u3066\u304b\u3089n\u79d2\u5f8c\u306e\u901f\u5ea6\u3092\u6c42\u3081\u308b\n\nT = np.cumsum(t).reshape(-1, 1)\narrival = T[-1]\ntimes = np.arange(0, arrival + 0.5, 0.5)\nspeed_limit = np.minimum(times, times[::-1])\n\nV = np.array(v).reshape(-1, 1)\nanswer = np.minimum(times, times[::-1])\ntmp = np.maximum(T[:-1, :] - times, times - T[1:, :]) + V\ntmp = np.maximum(tmp, V)\ntmp = tmp.min(axis=0)\nanswer = np.minimum(tmp, answer)\nanswer = np.abs(answer[1:] + answer[:-1]) * 0.5 / 2\n\nprint((answer.sum()))\n", "N = int(input())\nT = [2 * int(i) for i in input().split()]\nV = [2 * int(i) for i in input().split()]\n\nsu = sum(T)\nA = [min(i, su - i) for i in range(su + 1)]\n\ncnt = 0\nfor t, v in zip(T, V):\n    for i in range(cnt, cnt + t + 1):\n        A[i] = min(A[i], v)\n    cnt += t\n\nfor i in range(su):\n    A[i + 1] = min(A[i + 1], A[i] + 1)\n\nfor i in reversed(range(su)):\n    A[i] = min(A[i], A[i + 1] + 1)\n\nprint(sum(A) / 4)", "N = int(input())\n*T, = map(int, input().split())\n*V, = map(int, input().split())\nspeed = [0] # speed[i]: speed of train after 0.5*i seconds\nfor t, v in zip(T, V):\n    speed[-1] = min(speed[-1], v)\n    speed += [v]*(2*t)\nspeed[-1] = 0\ntemp = 0\nfor t in range(1, len(speed)):\n    speed[t] = temp =  min(speed[t], temp + 0.5)\ntemp = 0\nfor t in range(len(speed)-1, 0, -1):\n    speed[t] = temp =  min(speed[t], temp + 0.5)\nans = sum((v1 + v2)/4 for v1, v2 in zip(speed, speed[1:]))\nprint(ans)", "N = int(input())\ntlist = list(map(int, input().split()))\nvlist = list(map(int, input().split()))\nvlist.append(0)\nflag = True\nwhile flag:\n    flag =  False\n    for i in range(N):\n        if vlist[i]-vlist[i+1] > tlist[i]:\n            vlist[i] = vlist[i+1]+tlist[i]\n            flag = True\nspeed = 0\nx = 0\nfor i in range(N):\n    ti = tlist[i]\n    vi = vlist[i]\n    vj = vlist[i+1]\n    if vi <= vj:\n        if vi-speed <= ti:\n            x += ti*vi - ((vi-speed)**2)/2\n            speed = vi\n        else:\n            x += ti*(speed+ti) - (ti**2)/2\n            speed += ti\n    else:\n        if speed+ti <= vj:\n            x += ti*(speed+ti) - (ti**2)/2\n            speed += ti\n        elif 2*vi-speed-vj <= ti:\n            x += ti*vi - ((vi-speed)**2)/2 - ((vi-vj)**2)/2\n            speed = vj\n        else:\n            a = (ti+vj-speed)/2\n            x += a*(2*speed+a)/2 + (ti-a)*(2*vj+ti-a)/2\n            speed = vj\nprint(x)", "N = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\ndef exe(x, y, z, t):\n  ans = t * y\n  if x < y:\n    ans -= (y - x) * (y - x) / 2\n  if y > z:\n    ans -= (y - z) * (y - z) / 2\n  return ans\n\ndef upd(x, y, z, t):\n  a = y - x\n  b = y - z\n  if y > z:\n    if t < a:\n      y = x + t\n    elif t < a + b:\n      y = x + (t + (z - x)) / 2\n  else:\n    if t < a:\n      y = x + t\n  return y\n\nv = [0] + v + [0]\nL = [0] * len(v)\nv[1] = upd(v[0], v[1], v[2], t[0])\nv[-2] = upd(v[-1], v[-2], v[-3], t[-1])\nfor i in range(1, N):\n  k = -1\n  for j in range(1, N + 1):\n    if L[j] == 0:\n      if k == -1:\n        k = j\n      else:\n        if v[j] < v[k]:\n          k = j\n  L[k] = 1\n  if k != 1:\n    v[k - 1] = upd(min(v[k], v[k - 2]), v[k - 1], max(v[k], v[k - 2]), t[k - 2])\n  if k != N:\n    v[k + 1] = upd(min(v[k], v[k + 2]), v[k + 1], max(v[k], v[k + 2]), t[k])\n\nans = 0\nfor i in range(N):\n  ans += exe(v[i], v[i + 1], v[i + 2], t[i])\n\nprint(ans)", "N = int(input())\nT = [int(a) * 2 for a in input().split()]\nV = [int(a) * 2 for a in input().split()]\nMA = [0] * (sum(T) + 1)\na = 0\nfor i in range(N):\n    for j in range(T[i]):\n        a += 1\n        MA[a] = min(MA[a-1] + 1, V[i])\nMA[a] = 0\nfor i in range(N)[::-1]:\n    for j in range(T[i]):\n        a -= 1\n        MA[a] = min(MA[a], MA[a+1] + 1, V[i])\n\nprint(((sum(MA[1:]) + sum(MA[:-1])) / 8))\n", "N = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n\nV = [100] * (2*sum(t) + 1)\nT = 0\nfor i in range(N):\n    for j in range(T+1, T+t[i]*2+1):\n        V[j] = min(V[j], v[i])\n    T += t[i]*2\n\nfor i in range(min(len(V), 201)):\n    V[i] = min(V[i], i*0.5)\nfor i in range(min(len(V), 201)):\n    V[-i-1] = min(V[-i-1], i*0.5)\nV\nT = 0\nfor i in range(N-1):\n    T += t[i]*2\n    vi = min(V[T], v[i], v[i+1])\n    for j in range(201):\n        if T-j >= 0:\n            V[T-j] = min(V[T-j], vi+0.5*j)\n        if T+j <= len(V)-1:\n            V[T+j] = min(V[T+j], vi+0.5*j)\n\nV\nans = 0\nfor i in range(len(V)-1):\n    ans += 0.5*0.5*(V[i]+V[i+1])\nprint(ans)\n", "N = int(input())\nt = [0] + list(map(int, input().split()))\nv = [0] + list(map(int, input().split()))\nmax_speed_from_left = [0] * (N + 1) #index i = t[i] \u3068t[i + 1]\u306e\u9593\nmax_speed_from_right = [0] * (N + 1) #index i = t[i] \u3068t[i + 1]\u306e\u9593\n\nfor i in range(1, N):\n    start = max_speed_from_left[i - 1]\n    max_speed_from_left[i] = min(start + t[i], v[i], v[i + 1])\n\nfor i in range(N - 1, 0, -1):\n    start = max_speed_from_right[i + 1]\n    max_speed_from_right[i] = min(start + t[i + 1], v[i], v[i + 1])\n\nspeed = [min(x, y) for x, y in zip(max_speed_from_left, max_speed_from_right)]\n\ndef dist(left_speed, right_speed, t, v):\n    x = (v - left_speed) + (v - right_speed)\n    if x >= t:\n        v = (left_speed + right_speed + t)/2\n        x = t\n    #\u6700\u9ad8\u901f\u5ea6v\u306b\u5230\u9054\u3057\u3066t-x\u4f59\u308b\n    d = (left_speed + v) * (v - left_speed)/2\n    d += v * (t - x)\n    d += (right_speed + v) * (v - right_speed)/2\n    return d\n\nans = 0\nfor i in range(1, N + 1):\n    ans += dist(speed[i -1], speed[i], t[i], v[i])\nprint (ans)\n\n     \n\n", "from collections import deque\n\ndef main():\n    with open(0) as f:\n        N, *Temp = map(int, f.read().split())\n        T, V = Temp[:N], Temp[N:]\n        del Temp\n    #v-t\u30b0\u30e9\u30d5\u3092\u4eee\u5b9a\u3057\u3066\u3001\u5404\u533a\u9593\u306e\u5883\u754c\u6761\u4ef6\u3092\u6c42\u3081\u308b\n    v_left = deque([0]) #\u521d\u671f\u6642\u523b\u304b\u3089\u8d70\u67fb\u3057\u305f\u7d50\u679c\n    v_right = deque([0]) #\u7d42\u4e86\u6642\u523b\u304b\u3089\u8d70\u67fb\u3057\u305f\u7d50\u679c\n    #\u533a\u9593i(1<=i<=N)\u306e\u5883\u754c\u6761\u4ef6\u306f [min(vin[i-1], vout[i-1]), max(vin[i], vout[i])\n    #\u8d70\u67fb\u51e6\u7406\n    now = 0\n    for t,v in zip(T, V):\n        now = min(now+t, v)\n        v_left.append(now)\n    now = 0\n    for t, v in zip(reversed(T), reversed(V)):\n        now = min(now+t, v)\n        v_right.appendleft(now)\n\n    BC = [min(x,y) for x,y in zip(v_left, v_right)] #\u5883\u754c\u6761\u4ef6\n    #\u533a\u9593\u3054\u3068\u306b2\u500d\u306e\u9762\u7a4d\u8a08\u7b97\n    S = [squareMeasure(vin, vout, vsup, t) for vin, vout, vsup, t in zip(BC[:N], BC[1:], V, T)]\n    ans = sum(S)/2\n    print(ans)\n\ndef squareMeasure(vin, vout, vsup, t):\n    vmax = (t+vout+vin)/2 #y=x+vin\u3068y=-x+t+vout \u306e\u4ea4\u70b9\u306ey\n    if vmax > vsup:\n        a, b = vsup-vin, t+vout-vsup #y=vsup\u30682\u76f4\u7dda\u306e\u4ea4\u70b9\n        S = (vin+vsup)*a + 2*(b-a)*vsup + (vsup+vout)*(t-b)\n    else:\n        S = (vin+vmax)*(vmax-vin) + (vmax+vout)*(t+vin-vmax)\n    return S #2\u500d\u306e\u9762\u7a4d\u3067\u3042\u308b\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nvel_go = [0]\nfor ti, v_lim in zip(T, V):\n    for _ in range(ti * 2):\n        v = min(vel_go[-1] + 0.5, v_lim)\n        vel_go.append(v)\n\nvel_back = [0]\nfor ti, v_lim in zip(T[::-1], V[::-1]):\n    for _ in range(ti * 2):\n        v = min(vel_back[-1] + 0.5, v_lim)\n        vel_back.append(v)\nvel_back.reverse()\n\nvelocity = tuple(min(x, y) for x, y in zip(vel_go, vel_back))\nans = sum(0.25*(x+y) for x, y in zip(velocity[:-1], velocity[1:]))\nprint(ans)", "N = int(input())\nt = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nmaxv = [0] + [min(v[i], v[i+1]) for i in range(N-1)] + [0]\nfor i in reversed(range(N)):\n  if maxv[i] - maxv[i+1] > t[i]:\n    maxv[i] = maxv[i+1] + t[i]\nfor i in range(N):\n  if maxv[i+1] - maxv[i] > t[i]:\n    maxv[i+1] = maxv[i] + t[i]\n\ndef kyori(start, stop, mxv, ti):\n  if stop >= start:\n    if stop - start >= ti:\n      return (stop+start)*ti /2\n    elif mxv <= stop:\n      return ti*mxv - (mxv-start)**2 /2\n    else:\n      x = (stop-start+ti)/2\n      if mxv >= start + x:\n        return (start+start+x)*x /2 + (stop+stop+ti-x)*(ti-x) /2\n      else:\n        return ti*mxv - ((mxv-start)**2 + (mxv-stop)**2)/2\n  else:\n    x = (stop-start+ti)/2\n    if mxv >= start + x:\n      return (start+start+x)*x /2 + (stop+stop+ti-x)*(ti-x) /2\n    else:\n      return ti*mxv - ((mxv-start)**2 + (mxv-stop)**2)/2\n\n\nans = 0\nfor i in range(N):\n  ans += kyori(maxv[i], maxv[i+1], v[i], t[i])\n\nprint(ans)", "n=int(input())\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\nx=[0]\nfor i in range(n):x+=[v[i]]*t[i]*2\nx+=[0]\nl=[min(x[i],x[i+1])for i in range(len(x)-1)]\nfor i in range(1,len(l)):l[i]=min(l[i],l[i-1]+0.5)\nfor i in range(len(l)-2,-1,-1):l[i]=min(l[i],l[i+1]+0.5)\nprint(sum(0.25*(l[i]+l[i-1])for i in range(1,len(l))))", "N=int(input())\nT=list(map(int,input().split()))\nV=list(map(int,input().split()))\n\nvel_go=[0]\nfor ti, v_lim in zip(T,V):\n    for _ in range(ti*2):\n        v = min(vel_go[-1] + 0.5, v_lim)\n        vel_go.append(v)\n\nvel_back = [0]\nfor ti, v_lim in zip(T[::-1], V[::-1]):\n    for _ in range(ti*2):\n        v = min(vel_back[-1] + 0.5, v_lim)\n        vel_back.append(v)\nvel_back.reverse()\n\nvelocity = tuple(min(x,y) for x, y in zip(vel_go, vel_back))\nans = sum(0.25*(x+y) for x,y in zip(velocity[:-1], velocity[1:]))\nprint(ans)", "# solution\n\nimport io\nimport math\nimport scipy.sparse\nimport numpy\n\ndata = int(input())\n\narray1 = list(map(lambda x:int(x)*2,input().split()))\n\narray2 = list(map(lambda x:int(x)*2,input().split()))\n\nsumt = sum(array1)\n\nmaxv = [min(i, sumt-i) for i in range(sumt+1)]\n\ncounter = 0\n\nfor t,v in zip(array1,array2):\n    for i in range(counter,counter+t+1):\n        maxv[i] = min(maxv[i], v)\n    counter += t\n\nfor i in range(sumt):\n    maxv[i+1] = min(maxv[i+1], maxv[i] + 1)\nfor i in reversed(range(sumt)):\n    maxv[i] = min(maxv[i], maxv[i+1] + 1)\n\nprint(sum(maxv) / 4)", "N = int(input())\nT = list(map(int, input().split()))\nV = list(map(int, input().split()))\nM = 2\ndt = 1 / M\nR = sum(T)\n\nmaxSpeeds = [10**18] * (R * M + 1)\nnow = 0\nfor t, v in zip(T, V):\n    for i in range(t * M + 1):\n        maxSpeeds[now + i] = min(maxSpeeds[now + i], v)\n    now += t * M\n\nmaxSpeeds[0] = 0\nmaxSpeeds[-1] = 0\nfor t in range(1, R * M + 1):\n    maxSpeeds[t] = min(maxSpeeds[t - 1] + dt, maxSpeeds[t])\n    maxSpeeds[-(t + 1)] = min(maxSpeeds[-t] + dt, maxSpeeds[-(t + 1)])\n\nans = 0\nfor l, r in zip(maxSpeeds, maxSpeeds[1:]):\n    ans += (l + r) / M / 2\nprint(ans)", "n = int(input())\n\ntime = [0]+list(map(int,input().split()))+[0]\nv = [0] + list(map(int,input().split()))+[0]\n\nlines = []\nt = 0\nlines.append((-1,0,0))\nfor i in range(1,n+1):\n    lines.append((t,t+time[i],v[i]))\n    t+=time[i]\nlines.append((t,t+1,0))\ndef f(x):\n    speed = 10**18\n    for x1,x2,vv in lines:\n        if x<x1:\n            speed = min(speed,vv+x1-x)\n        elif x>x2:\n            speed = min(speed,vv+x-x2)\n        else:\n            speed = min(speed,vv)\n    return speed\ndp = [0]*(2*t)\nfor i in range(2*t):\n    dp[i] = f(i/2)\ndp.append(0)\nres = 0\nres = sum(dp)*2-dp[0]-dp[-1]\nprint((res*0.25))\n", "import sys\nfrom heapq import heapify, heappop\nfrom bisect import bisect_left, bisect_right, insort_left\nread=sys.stdin.read\nreadline=sys.stdin.readline\n\ndef main():\n    n=int(readline())\n    t,v=(list(map(int,l.split())) for l in read().splitlines())\n    vi=[(x,i+1) for i,x in enumerate(v)]\n    x=[0]*(n+2)\n    y=[0]*(n+1)\n    x[0]=0\n    y[0]=0\n    y[-1]=0\n    for i in range(1,n+1):\n        x[i]=x[i-1]+t[i-1]\n    x[n+1]=x[n]\n    heapify(vi)\n    ans=0\n    v=[0]+v+[0]\n    memo=[0,n+1]\n    while vi:\n        e=heappop(vi)\n        insort_left(memo,e[1])\n        idx=bisect_left(memo,e[1])\n        _i=memo[idx-1]\n        i_=memo[idx+1]\n        i=memo[idx]\n        sx=x[_i]\n        gx=x[i_-1]\n        sy=y[_i]\n        gy=y[i_-1]\n        h=e[0]\n        y[i]=min(h,gx-x[i]+gy,x[i]-sx+sy)\n        y[i-1]=min(h,gx-x[i-1]+gy,x[i-1]-sx+sy)\n        dw=gx-sx\n        dh=abs(gy-sy)\n        be=max(0,dw-(2*max(v[_i],v[i_])-sy-gy))\n        ht=min(h-v[_i],h-v[i_],be/2)\n        te=max(0,be-2*ht)\n        ans+=(te+be)*ht/2\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nt = [0]+list(map(int,input().split()))\nv = [0]+list(map(int,input().split()))\n\nleft = [0]*(n+1)\nright = [0]*(n+1)\n\nfor i in range(1,n):\n    s = left[i-1]\n    left[i] = min(s+t[i],v[i],v[i+1])\nfor i in range(n-1,0,-1):\n    s = right[i+1]\n    right[i] = min(s+t[i+1],v[i],v[i+1])\n\nad = [min(x,y) for x,y in zip(left,right)]\n\ndef cal(le,ri,t,v):\n    x = v-le+v-ri\n    if x >= t:\n        v = (le+ri+t)/2\n        x = t\n    d = (le+v)*(v-le)/2\n    d += v*(t-x)\n    d += (ri+v)*(v-ri)/2\n    return d\n\nans = 0\nfor i in range(1,n+1):\n    ans += cal(ad[i-1],ad[i],t[i],v[i])\nprint(ans)", "# \u5199\u7d4cAC\nN = int(input())\nT = [int(i) for i in input().split()]\nV = [int(i) for i in input().split()]\n\nTs = sum(T)\n\n# Vmax[t]: t\u79d2\u3067\u306e\u6700\u5927\u901f\u5ea6 (0.5\u79d2\u9593\u9694)\nVmax = [float(\"inf\")] * (Ts * 2 + 1)\n\nts = 0\nfor i in range(N):\n    for t in range(T[i]):\n        t1 = (ts + t) * 2\n        t2 = (ts + t) * 2 + 1\n        Vmax[t1] = min(Vmax[t1], V[i])\n        Vmax[t2] = min(Vmax[t2], V[i])\n\n    # \u6642\u9593\u306e\u533a\u5207\u308a\u306e\u90e8\u5206\u306f\u9589\u533a\u9593\u304c\u91cd\u306a\u3063\u3066\u3044\u308b\n    Vmax[(ts + T[i]) * 2] = min(Vmax[(ts + T[i]) * 2], V[i])\n\n    ts += T[i]\n\n# 0\u79d2\u3068T\u79d2\nVmax[0] = Vmax[Ts * 2] = 0\n# \u5de6\u304b\u3089\u53f3\u306b\nfor t in range(Ts * 2):\n    Vmax[t + 1] = min(Vmax[t + 1], Vmax[t] + 0.5)\n# \u53f3\u304b\u3089\u5de6\u306b\nfor t in range(Ts * 2 - 1, 0, -1):\n    Vmax[t] = min(Vmax[t], Vmax[t + 1] + 0.5)\n\nans = 0.0\nfor i in range(Ts * 2):\n    # \u53f0\u5f62\u306e\u516c\u5f0f\n    ans += (Vmax[i] + Vmax[i + 1]) * 0.5 / 2\n\nprint(ans)", "N = int(input())\nT = [int(i) for i in input().split()]\nV = [int(i) for i in input().split()]\n\nmaxv = [0]\nfor t, v in zip(T, V):\n    maxv[-1] = min(maxv[-1], v)\n    for i in range(t * 2):\n        maxv.append(v)\nmaxv[-1] = 0\n\nfor i in range(len(maxv) - 1):\n    maxv[i + 1] = min(maxv[i + 1], maxv[i] + 0.5) \n    \nfor i in reversed(range(len(maxv) - 1)):\n    maxv[i] = min(maxv[i], maxv[i + 1] + 0.5)\n    \nans = 0\nfor i in range(len(maxv) - 1):\n    ans += (maxv[i] + maxv[i + 1]) * 0.5 / 2\n    \nprint(ans)"]
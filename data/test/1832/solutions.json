["rndid = \"cuuhkjc\"\nfor _ in range(int(input())):\n  input()\n  ls = 'a' * 51\n  oa = ord('a')\n  print(ls)\n  for a in input().split():\n    a = int(a)\n    ls = ls[:a] + ls[a:].translate({oa: 'b', oa + 1: 'a'})\n    print(ls)", "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------- fast io --------------------\nfrom math import gcd, ceil\n\ndef pre(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    return pi\n\n\ndef prod(a):\n    ans = 1\n    for each in a:\n        ans = (ans * each)\n    return ans\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\n\nfor _ in range(int(input()) if True else 1):\n    n = int(input())\n    #n, k = map(int, input().split())\n    #a, b = map(int, input().split())\n    #c, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    #b = list(map(int, input().split()))\n    #s = input()\n    ans = ['a'*100]\n    for i in range(n):\n        ans += [ans[-1][:a[i]] + chr(ord(ans[-1][a[i]])+1) if ans[-1][a[i]] != 'z' else 'a']\n        ans[-1] = ans[-1] + \"a\"*(100 - len(ans[-1]))\n    for each in ans:\n        print(each)", "def nxt(ch):\n    if ch == 'z':\n        return 'a'\n    return chr(ord(ch) + 1)\n\n\nans = []\nfor _ in range(int(input())):\n    n = int(input())\n    u = list(map(int, input().split()))\n    s = ['a']\n    for i in range(51):\n        s.append(nxt(s[-1]))\n    ans.append(''.join(s))\n    for i in range(n):\n        s[u[i]] = nxt(s[u[i]])\n        ans.append(''.join(s))\nprint('\\n'.join(ans))\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nfor _ in range(val()):\n\tn = val()\n\tl = li()\n\tans = ['a' * 100]\n\tfor i in l:\n\t\t# print(i)\n\t\tlast = ans[-1]\n\t\tcurr = ''\n\t\tfor j in range(i):\n\t\t\tcurr += last[j]\n\n\t\ttoadd = 'b' if last[i] == 'a' else 'a'\n\t\tcurr += toadd * (100 - len(curr))\n\t\tans.append(curr[:])\n\tfor i in ans:print(i)\n\t\n", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = ord('a')\n    s = 'a' * 200\n    print(s)\n    for i in range(n):\n        b += 1\n        if b == ord('z'):\n            b = ord('a')\n        s = s[:a[i]] + chr(b) * (200 - a[i])\n        print(s)", "for _ in range(int(input())):\n    _ = int(input())\n    *arr, = list(map(int, input().split()))\n    max_len = max(arr) + 1\n    ans = ['a'] * max_len\n    print(''.join(ans))\n    for n in arr:\n        if ans[n] == 'a':\n            ans[n] = 'b'\n        else:\n            ans[n] = 'a'\n        print(''.join(ans))\n\n", " \n# from math import factorial as fac\nfrom collections import defaultdict\n# from copy import deepcopy\nimport sys, math\nf = None\ntry:\n\tf = open('q1.input', 'r')\nexcept IOError:\n\tf = sys.stdin\nif 'xrange' in dir(__builtins__):\n\trange = xrange\n# print(f.readline())\n# sys.setrecursionlimit(10**6)\n\n\t\ndef print_case_iterable(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,\" \".join(map(str,iterable))))\n\ndef print_case_number(case_num, iterable):\n\tprint(\"Case #{}: {}\".format(case_num,iterable))\n\ndef print_iterable(A):\n\tprint (' '.join(A))\n\ndef read_int():\n\treturn int(f.readline().strip())\ndef read_int_array():\n\treturn [int(x) for x in f.readline().strip().split(\" \")]\ndef rns():\n\ta =  [x for x in f.readline().split(\" \")]\n\treturn int(a[0]), a[1].strip()\ndef read_string():\n\treturn list(f.readline().strip())\ndef ri():\n\treturn int(f.readline().strip())\ndef ria():\n\treturn [int(x) for x in f.readline().strip().split(\" \")]\ndef rns():\n\ta =  [x for x in f.readline().split(\" \")]\n\treturn int(a[0]), a[1].strip()\ndef rs():\n\treturn list(f.readline().strip())\ndef bi(x):\n\treturn bin(x)[2:]\n\n\n\n\n\nfrom collections import deque\nimport math\nNUMBER = 10**9 + 7\n# NUMBER = 998244353\ndef factorial(n) : \n\tM = NUMBER\n\tf = 1\n  \n\tfor i in range(1, n + 1):  \n\t\tf = (f * i) % M # Now f never can  \n\t\t\t\t\t\t# exceed 10^9+7  \n\treturn f\ndef mult(a,b):\n\treturn (a * b) % NUMBER\n\ndef minus(a , b):\n\treturn (a - b) % NUMBER\n\ndef plus(a , b):\n\treturn (a + b) % NUMBER\n\ndef egcd(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\telse:\n\t\tg, y, x = egcd(b % a, a)\n\t\treturn (g, x - (b // a) * y, y)\n\ndef modinv(a):\n\tm = NUMBER\n\tg, x, y = egcd(a, m)\n\tif g != 1:\n\t\traise Exception('modular inverse does not exist')\n\telse:\n\t\treturn x % m\ndef choose(n,k):\n\tif n < k:\n\t\tassert false\n\treturn  mult(factorial(n), modinv(mult(factorial(k),factorial(n-k)))) % NUMBER\nfrom collections import deque, defaultdict \nimport heapq\n\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\n\treturn wrappedfunc\n\n\ndef dfs(g, timeIn, timeOut,depths,parents): \n\t# assign In-time to node u \n\tcnt = 0\n\t# node, neig_i, parent, depth\n\tstack = [[1,0,0,0]]\n\twhile stack:\n\t\tv,neig_i,parent,depth = stack[-1]\n\t\tparents[v] = parent\n\t\tdepths[v] = depth\n\t\t# print (v)\n\t\tif neig_i == 0:\n\t\t\ttimeIn[v] = cnt    \n\t\t\tcnt+=1\n\t\twhile neig_i < len(g[v]):\n\t\t\tu = g[v][neig_i]\n\t\t\tif u == parent:\n\t\t\t\tneig_i+=1\n\t\t\t\tcontinue\n\t\t\tstack[-1][1] = neig_i + 1\n\t\t\tstack.append([u,0,v,depth+1])\n\t\t\tbreak\n\t\tif neig_i == len(g[v]):\n\t\t\tstack.pop()\n\t\t\ttimeOut[v] = cnt\n\t\t\tcnt += 1\n  \n# def isAncestor(u: int, v: int, timeIn: list, timeOut: list) -> str: \n# \treturn timeIn[u] <= timeIn[v] and timeOut[v] <= timeOut[u] \n\ncnt = 0\n@bootstrap\ndef dfs(v,adj,timeIn, timeOut,depths,parents,parent=0,depth=0):\n\tnonlocal cnt\n\tparents[v] = parent\n\tdepths[v] = depth\n\ttimeIn[v] = cnt\n\tcnt+=1\n\tfor u in adj[v]:\n\t\tif u == parent:\n\t\t\tcontinue\n\t\tyield dfs(u,adj,timeIn,timeOut,depths,parents,v,depth+1)\n\ttimeOut[v] = cnt\n\tcnt+=1\n\tyield \n\ndef gcd(a,b): \n\tif a == 0: \n\t\treturn b \n\treturn gcd(b % a, a) \n  \n# Function to return LCM of two numbers \ndef lcm(a,b): \n\treturn (a*b) / gcd(a,b) \ndef get_num_2_5(n):\n\ttwos = 0\n\tfives = 0\n\twhile n>0 and n%2 == 0:\n\t\tn//=2\n\t\ttwos+=1\n\twhile n>0 and n%5 == 0:\n\t\tn//=5\n\t\tfives+=1\n\treturn (twos,fives)\ndef shift(a,i,num):\n\tfor _ in range(num):\n\t\ta[i],a[i+1],a[i+2] = a[i+2],a[i],a[i+1]\n\ndef equal(x,y):\n\treturn abs(x-y) <= 1e-9\n# def leq(x,y):\n# \treturn x-y <= 1e-9\ndef getAngle(a, b, c):\n\tang = math.degrees(math.atan2(c[1]-b[1], c[0]-b[0]) - math.atan2(a[1]-b[1], a[0]-b[0]))\n\treturn ang + 360 if ang < 0 else ang\ndef getLength(a,b):\n\treturn math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)\n\n\nfrom heapq import heapify, heappush, heappop\n\ndef bfs(adj):\n\ts = set()\n\td = defaultdict(set)\n\t# print('\\n'.join(map(str,E.items())))\n\tq = deque([])\n\ts.add(0)\n\td[0].add(0)\n\tq.append((0,0))\n\twhile len(q) > 0:\n\t\tv,depth = q.popleft()\n\t\tfor u in adj[v]:\n\t\t\tif u not in s:\n\t\t\t\ts.add(u)\n\t\t\t\td[depth+1].add(u)\n\t\t\t\tq.append((u,depth+1))\n\t\t# print(q)\n\treturn d\n\n\n@bootstrap\ndef dfs(u,top, adj,vis):\n\tvis[u] = 1\n\tfor v,d in adj[u]:\n\t\tif vis[v]==2 or d==0:\n\t\t\tcontinue\n\t\tif vis[v] == 1:\n\t\t\tyield \"No\"\n\t\tx = yield dfs(v,top,adj,vis)\n\t\tif x == \"No\":\n\t\t\tyield \"No\"\n\tvis[u] = 2\n\ttop.append(u)\n\tyield\ndef isSubsetSum(arr, n, summ): \n      \n    # The value of subarr[i][j] will be  \n    # true if there is a \n    # subarr of arr[0..j-1] with summ equal to i \n    subarr =([[False for i in range(summ + 1)]  \n            for i in range(n + 1)]) \n      \n    # If summ is 0, then answer is true  \n    for i in range(n + 1): \n        subarr[i][0] = True\n          \n    # If summ is not 0 and arr is empty,  \n    # then answer is false  \n    for i in range(1, summ + 1): \n         subarr[0][i]= False\n              \n    # Fill the subarr table in botton up manner \n    for i in range(1, n + 1): \n        for j in range(1, summ + 1): \n            if j<arr[i-1]: \n                subarr[i][j] = subarr[i-1][j] \n            if j>= arr[i-1]: \n                subarr[i][j] = (subarr[i-1][j] or \n                                subarr[i - 1][j-arr[i-1]]) \n      \n    # uncomment this code to print table  \n    # for i in range(n + 1): \n    # for j in range(summ + 1): \n    # print (subset[i][j], end =\" \") \n    # print() \n    return subarr[n][summ] \n\ndef find_lcm(a,b): \n\treturn (a*b) // gcd(a,b) \ndef find_lcm_array(A):\n\tif len(A) == 1:\n\t\treturn A[0]\n\tlcm = find_lcm(A[0], A[1] ) \n\n\tfor i in range(2, len(A)): \n\t\tlcm = find_lcm(lcm, A[i]) \n\treturn lcm\n\ndef solution(a,n):\n\tres = ['a'*50]\n\tfor i in range(n):\n\t\tx = a[i]\n\t\tif x== 50:\n\t\t\tres.append(res[-1])\n\t\t\tcontinue\n\t\ttemp = res[-1]\n\t\tchar = res[-1][x]\n\t\tchar = 'a' if char == 'z' else 'z'\n\t\tres.append(temp[:x]+char+temp[x+1:])\n\treturn '\\n'.join(res)\n\n\t\t\n\n\t\n\n\n\n\ndef main():\n\tT = 1\n\tT = ri()\n\tfor i in range(T):\n\t\tn = ri()\n\t\ta = ria()\n\t\t# s = rs()\n\t\t# n,m,k\t= ria()\n\t\t# adj = [list() for _ in range(n)]\n\t\t# for _ in range(m):\n\t\t# \td,a,b=ria();\n\t\t# \ta-=1; b-=1\n\t\t# \tadj[a].append((b,d))\n\t\t# \tif d == 0:\n\t\t# \t\tadj[b].append((a,d))\n\n\t\tx = solution(a,n)\n\n\t\t# continue\n\t\tif 'xrange' not in dir(__builtins__):\n\t\t\tprint(x) # print(\"Case #\"+str(i+1)+':',x)\n\t\telse:\n\t\t\tprint >>output,\"Case #\"+str(i+1)+':',str(x)\n\tif 'xrange' in dir(__builtins__):\n\t\tprint(output.getvalue())\n\t\toutput.close()\n\nif 'xrange' in dir(__builtins__):\n\timport cStringIO\n\toutput = cStringIO.StringIO()\n#example usage:\n#    for l in res:\n#       print >>output, str(len(l)) + ' ' +  ' '.join(l)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "from sys import stdin\n\"\"\"\nn=int(stdin.readline().strip())\nn,m=map(int,stdin.readline().strip().split())\ns=list(map(int,stdin.readline().strip().split()))\n\"\"\"\nT=int(stdin.readline().strip())\nlet=[chr(i) for i in range(97,97+26)]\nfor caso in range(T):\n    n=int(stdin.readline().strip())\n    s=list(map(int,stdin.readline().strip().split()))\n    ans=[\"a\"*110]\n    for i in range(n):\n        x=ans[-1][0:s[i]]\n        for j in let:\n            if j!=ans[-1][s[i]]:\n                x+=j\n                break\n        x+=ans[-1][s[i]+1::]\n        ans.append(x)\n    for i in ans:\n        print(i)\n            \n    \n    \n    \n", "import sys, os.path\nfrom collections import deque\nfrom fractions import Fraction as f\ndef IO():\n    if os.path.exists('input.txt'):\n        sys.stdin = open('input.txt', 'r')\n        sys.stdout = open('output.txt', 'w')\n    else:\n        input=sys.stdin.readline\n        print=sys.stdout.write\ndef nextInt():\n    return int(input())\ndef nextTuple():\n    return [int(a) for a in input().split()]\ndef nextArray():\n    return list(map(int, input().split()))\ndef nextLine():\n    return input()\ndef nextStringArray():\n    return list(input().split())\nIO()\n\n'''code starts here'''\n\n\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    s=\"abcdefghijklmnopqrstuvwxyz\"\n    dict={}\n    for i in range(25):\n        dict[s[i]]=s[i+1]\n    dict['z']='a'\n    s=\"a\"*200\n    print(s)\n    for i in range(n):\n        p=s[0:a[i]]+dict[s[a[i]]]+s[a[i]+1:]\n        s=p\n        print(p)\n", "alphabet = \"qwertyuiopasdfghjklzxcvbnm\"\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    last = \"a\" * 51\n    print(last)\n    for i in range(n):\n        last = last[:a[i]] + alphabet[alphabet.index(last[a[i]]) - 1] + \"a\" * 50\n        print(last)\n\n\nfor _ in range(int(input())):\n    solve()\n", "import sys\n\n\n#def solve(a,b,c,d):\ndef solve(lens):\n    base = ord('a')\n    wlen = max(lens)+2\n    last = ['a']*wlen\n    word_list = [''.join(last)]\n    for l in lens:\n        last[l] = chr( base + (ord(last[l])-ord('a')+1)%26 )\n        word_list.append(''.join(last))\n    return word_list\n\n\ndef __starting_point():\n    IN = [x.strip() for x in sys.stdin.readlines()]\n\n    T = int(IN[0])\n    cur = 1\n    for ti in range(T):\n        a = int(IN[cur])\n        #a = [int(x) for x in IN[cur].split(' ')]\n        lens = [int(x) for x in IN[cur+1].split(' ')]\n        res = solve(lens)\n        for w in res:\n            print(w)\n        cur += 2\n\n\n__starting_point()", "maxs = 190\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = [int(j) for j in input().split()]\n\tans = [0]*(n+1)\n\tans[0] = 'a'*maxs\n\tfor i in range(1, n+1):\n\t\tnum = arr[i-1]\n\t\tcurrent = ''\n\t\tfor j in range(num):\n\t\t\tcurrent += ans[i-1][j]\n\t\tif ans[i-1][num] == 'a':\n\t\t\tcurrent += 'b'\n\t\telse:\n\t\t\tcurrent += 'a'\n\n\t\tfor j in range(num+1, maxs):\n\t\t\tcurrent += current[j-1]\n\n\t\tans[i] = current\n\tprint(*ans, sep='\\n')", "import sys\nINP = lambda: sys.stdin.readline().strip()\nINT = lambda: int(INP())\nMAP = lambda: list(map(int, INP().split()))\nARR = lambda: [int(i) for i in INP().split()]\ndef JOIN(arr, x=''): return x.join([str(i) for i in arr])\ndef EXIT(x='NO'): print(x); return\n\nfor _ in range(INT()):\n    n = INT()\n    arr = ARR()\n    ans = list('ab'*(max(arr)//2 + 1))\n    print(JOIN(ans))\n    for x in arr:\n        ans[x] = 'b' if ans[x]=='a' else 'a'\n        print(JOIN(ans))\n\n", "def solve():\n    n = int(input())\n    s = input().split()\n\n    m = 0\n    \n    for i in range(len(s)):\n        s[i] = int(s[i])\n        m = max(m, s[i])\n    print('a'*(m + 1))\n    cur = ['a']*(m + 1)\n    for i in range(len(s)):\n        if cur[s[i]] == 'a':\n            cur[s[i]] = 'b'\n        else:\n            cur[s[i]] = 'a'\n        print(''.join(cur))\n        \n\n\nt = int(input())\n\nfor i in range(t):\n    solve()\n\n\n", "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n#-------------------------code---------------------------#\n# vsInput()\n\nchar='qwertyuiopasdfghjklxcvbnm'\n\nfor _ in range(Int()):\n    n=Int()\n    a=array()\n\n    ma=max(a)\n\n    id=0\n    s=['z' for i in range(ma+1)]\n    print(*s,sep=\"\")\n\n    for i in range(1,n+1):\n        id=(id+1)%25\n        s[a[i-1]]=char[id]\n        print(*s,sep=\"\")\n\n\n\n    \n"]
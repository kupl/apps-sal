["# python3\n\n\ndef readline(): return tuple(map(int, input().split()))\n\n\ndef readlines(count): return (readline() for __ in range(count))\n\n\ndef main():\n    n, = readline()\n    degree = [0] * n\n    root = None\n    for (a, b) in readlines(n - 1):\n        degree[a - 1] += 1\n        degree[b - 1] += 1\n\n    for (x, d) in enumerate(degree, start=1):\n        if d > 2:\n            if root is None:\n                root = x\n            else:\n                print(\"No\")\n                return\n\n    if root is None:\n        root = 1\n\n    ways = [i for (i, d) in enumerate(degree, start=1) if d == 1 and i != root]\n    print(\"Yes\")\n    print(len(ways))\n    print(\"\\n\".join(map(f\"{root} {{}}\".format, ways)))\n\n\nmain()\n", "#!/usr/bin/env python3\n\nn = int(input().strip())\ndegs = [0 for _ in range(n)]\nfor _ in range(n - 1):\n\t[u, v] = list(map(int, input().strip().split()))\n\tdegs[u - 1] += 1\n\tdegs[v - 1] += 1\n\nni = [None, [], [], []]\nfor v, d in enumerate(degs):\n\tdd = min(d, 3)\n\tni[dd].append(v)\n\n\nif len(ni[3]) > 1:\n\tprint ('No')\nelif len(ni[3]) == 1:\n\tprint ('Yes')\n\tprint(len(ni[1]))\n\tu = ni[3][0]\n\tfor v in ni[1]:\n\t\tprint(u + 1, v + 1)\nelse:  # ni[3] == []\n\tprint ('Yes')\n\tprint(1)\n\tprint(ni[1][0] + 1, ni[1][1] + 1)\n\n", "from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\n\ndef read():\n    return int(input())\n\n\ndef readmap():\n    return map(int, input().split())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\nN = read()\ndegree = [0] * N\nfor _ in range(N-1):\n    a, b = readmap()\n    degree[a-1] += 1\n    degree[b-1] += 1\n\nmore_than_three = 0\nfor d in degree:\n    if d >= 3:\n        more_than_three += 1\n\nif more_than_three >= 2:\n    print(\"No\")\n    quit()\n\nans = []\nif more_than_three == 1:\n    for v in range(N):\n        if degree[v] >= 3:\n            center = v\n    for v in range(N):\n        if degree[v] == 1:\n            ans.append((center+1, v+1))\n    print(\"Yes\")\n    print(len(ans))\n    for tup in ans:\n        print(tup[0], tup[1])\n    quit()\n\nleaf = []\nfor v in range(N):\n    if degree[v] == 1:\n        leaf.append(v)\nprint(\"Yes\")\nprint(1)\nprint(leaf[0]+1, leaf[1]+1)", "n = int(input())\norders = [0 for i in range(n)]\nfor i in range(n-1):\n    a, b = [int(j) -1 for j in input().split()]\n    orders[a] += 1\n    orders[b] += 1\n\nroots = []\nleafs = []\n\nfor i, x in enumerate(orders):\n    if x > 2:\n        roots.append(i)\n    elif x == 2:\n        pass\n    elif x == 1:\n        leafs.append(i)\n    else:\n        raise Exception('woww')\n\n\nif len(roots) > 1:\n    print('No')\nelif len(roots) == 0:\n    print('Yes')\n    print('1')\n    print(' '.join([str(l+1) for l in leafs]))\nelif len(roots) == 1:\n    print('Yes')\n    print(str(len(leafs)))\n    root = str(roots[0] + 1)\n    for l in leafs:\n        print(root, str(l+1))\nelse:\n    raise Exception('woww')\n", "def main():\n    n = int(input())\n    deg = [0] * n\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        deg[u - 1] += 1\n        deg[v - 1] += 1\n    count = 0\n    ans = 0\n    e = []\n    for i in range(n):\n        if (deg[i] > 2):\n            count += 1\n            ans = i\n        if (deg[i] == 1):\n            e.append(i)\n    if (count > 1):\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        print(deg[ans])\n        for el in e:\n            if (el != ans):\n                print(ans + 1, el + 1)\nmain()", "n=int(input())\ng=[0 for i in range(n)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    g[a-1]+=1\n    g[b-1]+=1\nq=0\nk=0\nkind=0\nm=0\nfor i in range(n):\n    if g[i]==1:\n        m+=1\n    if g[i]>2:\n        if g[i]>k:\n            kind=i\n            k=g[i]\n        q+=1\nif q>1:\n    print('No')\nelse:\n    print('Yes')\n    if k>2:\n        print(m)\n        for i in range(n):\n            if g[i]==1:\n                print(kind+1,i+1)\n    else:\n        print(1)\n        for i in range(n):\n            if g[i]==1:\n                print(i+1,end=' ')\n", "n = int(input())\ngraph = [ [] for i in range(n+1)]\ncenter = None\nshould_continue = True\nends = set()\nfor i in range(n-1):\n    parameters = [int(s) for s in input().split(\" \")]\n    from_ = parameters[0]\n    to = parameters[1]\n    # print(graph)\n    # print(from_)\n    # if not graph[from_]:\n    #     graph[from_] = []\n    # if not graph[to]:\n    #     graph[to] = []\n    graph[from_].append(to)\n    graph[to].append(from_)\n    if len(graph[from_]) > 2:\n        if center and center != from_:\n            should_continue = False\n            break\n        center = from_\n\n    if len(graph[to]) > 2:\n        if center and center != to:\n            should_continue = False\n            break\n        center = to\n\n    if len(graph[from_]) == 1:\n        ends.add(from_)\n    else:\n        ends.discard(from_)\n\n    if len(graph[to]) == 1:\n        ends.add(to)\n    else:\n        ends.discard(to)\n\nif not should_continue:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\n    if center == None:\n        print(\"1\")\n        print(str(ends.pop()) + \" \" + str(ends.pop()))\n    else:\n        print(len(graph[center]))\n        for i in ends:\n            print(str(center) + \" \" + str(i))\n", "n = int(input())\ndic = {}\nfor i in range(n):\n    dic.update({i+1:0})\nfor i in range(n-1):\n    s = input().split()\n    dic[int(s[0])]+=1\n    dic[int(s[1])]+=1\n\ncl = []\ncount1=0\ncount2=0\ncount3=0\nfor x in dic.keys():\n    if dic[x]==1:\n        count1+=1\n        cl.append(x)\n    elif dic[x]==2:\n        count2+=1\n    else:\n        count3+=1\n        p = x\n\nif count3==0:\n    print('Yes')\n    print(1)\n    print('{} {}'.format(cl[0], cl[1]))\nelif count3==1:\n    print('Yes')\n    print(count1)\n    for i in range(1, n+1):\n        if i!=p and dic[i]==1:\n            print('{} {}'.format(p, i))\nelse:\n    print('No')", "import sys\nimport filecmp\nimport math\nFILE_IO = False\n\n\nCURR_PATH = []\nlist_of_connections = [[] for _ in range(100001)]\n\ndef dfs(vertex):\n    visited, stack = set(), [vertex]\n\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(set(list_of_connections[vertex]) - visited)\n            if (len(set(list_of_connections[vertex]) - visited) == 0):\n                CURR_PATH.append(vertex)\n\n\n\n\nif FILE_IO:\n    input_stream = open('input_test.txt')\n    sys.stdout = open('current_output2.txt', 'w')\nelse:\n    input_stream = sys.stdin\n\nn = int(input_stream.readline())\n\n\n\nfor _ in range(n-1):\n    input_list = input_stream.readline().split()\n    start , end = int(input_list[0]),int(input_list[1])\n    list_of_connections[start].append(end)\n    list_of_connections[end].append(start)\n\nmax_edges = None\nmax_less_then_3 = None\nno = False\nfor ind, edges in enumerate(list_of_connections):\n    current_len = len(edges)\n    if current_len > 2:\n        if max_less_then_3 is not None:\n            print('No')\n            return\n        else:\n            max_less_then_3 = ind\n\nif max_less_then_3 is None:\n    max_less_then_3 = 1\n\nprint('Yes')\nroot = max_less_then_3\n\npaths = []\n\nvisited = [False] * 100001\ndfs(root) \n\nprint(len(CURR_PATH))\nfor node in CURR_PATH:\n    print(str(root) + \" \"+ str(node))\n            \n\n\n    \n\n# if FILE_IO:\n    # assert filecmp.cmp('current_output.txt','expected_output.txt',shallow=False) == True \n", "n = int(input())\nflag = True\nf = [0] * (n - 1)\nt = [0] * (n - 1)\nco = [0] * n\nfor i in range(n - 1):\n    f[i], t[i] = map(int, input().split())\n    co[f[i] - 1] += 1\n    co[t[i] - 1] += 1\nmid = 0\nen = []\nfor i in range(n):\n    if co[i] == 1:\n        en.append(i + 1)\n    elif co[i] > 2:\n        if mid == 0:\n            mid = i + 1\n        else:\n            print(\"No\")\n            flag = False\n            break\nif flag:\n    print(\"Yes\")\n    if mid != 0:\n        print(len(en))\n        for i in range(len(en)):\n            if (en[i] != mid):\n                print(mid, en[i])\n    else:\n        print(1)\n        print(en[0], en[1])", "n = int(input())\nflag = True\nf = [0] * (n - 1)\nt = [0] * (n - 1)\nco = [0] * n\nfor i in range(n - 1):\n    f[i], t[i] = map(int, input().split())\n    co[f[i] - 1] += 1\n    co[t[i] - 1] += 1\nmid = 0\nen = []\nfor i in range(n):\n    if co[i] == 1:\n        en.append(i + 1)\n    elif co[i] > 2:\n        if mid == 0:\n            mid = i + 1\n        else:\n            print(\"No\")\n            flag = False\n            break\nif flag:\n    print(\"Yes\")\n    if mid != 0:\n        print(len(en))\n        for i in range(len(en)):\n            print(mid, en[i])\n    else:\n        print(1)\n        print(en[0], en[1])", "n = int(input())\nd = [0]*100010\nl = []\nle = []\nfor _ in range(n-1):\n    u,v = map(int,input().split())\n    d[u]+=1\n    d[v]+=1\n    l.append(u)\n    l.append(v)\nr = 0\nfor i in range(1,max(l)+1):\n    if(d[i]==1):\n        le.append(i)\n    if(d[i]>2):\n        if(not r):\n            r = i\n        else:\n            print('No')\n            return\nprint('Yes')\nif(not r):\n    print(1)\n    print(min(le),max(le))\nelse:\n    x = len(le)\n    print(x)\n    le.sort()\n    for i in range(1,x+1):\n        print(r,le[i-1])", "#Zad\nfrom collections import Counter\nn=int(input())\ntree=[]\nfor i in range(n-1):\n    tree.extend(list(map(int,input().split())))\nans=Counter(tree)\nif ans.most_common(2)[1][1]>2: print('No')\nelse:\n    print('Yes')\n    if n==2:\n        print(1)\n        print('1 2')\n    else:\n        if ans.most_common(1)[0][1]==2:\n            print(1)\n            print(ans.most_common()[-2][0], ans.most_common()[-1][0])\n        else:\n            center=ans.most_common(1)[0][0]\n            kraya=[n[0] for n in ans.most_common() if n[1]==1]\n            print(len(kraya))\n            for i in kraya:\n                print(center, i)", "n = int(input())\nflag = True\nf = [0] * (n - 1)\nt = [0] * (n - 1)\nco = [0] * n\nfor i in range(n - 1):\n    f[i], t[i] = map(int, input().split())\n    co[f[i] - 1] += 1\n    co[t[i] - 1] += 1\nmid = 0\nen = []\nfor i in range(n):\n    if co[i] == 1:\n        en.append(i + 1)\n    elif co[i] > 2:\n        if mid == 0:\n            mid = i + 1\n        else:\n            print(\"No\")\n            flag = False\n            break\nif flag:\n    print(\"Yes\")\n    if mid != 0:\n        print(len(en))\n        for i in range(len(en)):\n            if (en[i] != mid):\n                print(mid, en[i])\n    else:\n        print(1)\n        print(en[0], en[1])", "n = (int(input()))\nedges = [0 for i in range(n+1)]\nfor _ in range(n-1):\n\tx,y = map(int,input().split())\n\tedges[x] += 1\n\tedges[y] += 1\n\nleaves = []\nnode = None\nflag = True\nfor i in range(1,n+1):\n\tif(edges[i]==1):\n\t\tleaves.append(i)\n\telif(edges[i]>2):\n\t\tif(not node==None):\n\t\t\tflag = False\n\t\t\tbreak\n\t\telse:\n\t\t\tnode = i\nif(flag):\n\tprint(\"Yes\")\n\tif(node==None):\n\t\tprint(1)\n\t\tprint(leaves[0],end=' ')\n\t\tprint(leaves[1])\n\telse:\n\t\tprint(len(leaves))\n\t\tfor item in leaves:\n\t\t\tprint(item,end=' ')\n\t\t\tprint(node)\nelse:\n\tprint(\"No\")", "d = {}\nn = int(input())\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    d[a] = d.get(a, 0) + 1\n    d[b] = d.get(b, 0) + 1\nzz = list(filter(lambda x: d[x] > 2, d))    \nz = len(zz)\ny = list(filter(lambda x: d[x] == 1, d))\nif z > 1:\n    print(\"No\")\nelif z == 0:    \n    print(\"Yes\")\n    print(1)\n    print(*y)\nelse:    \n    print(\"Yes\")\n    print(len(y))\n    for v in y:\n        print(zz[0], v)"]
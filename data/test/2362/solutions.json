["import sys\n\nanswer = 1\nz = True\nprimes = []\nfor i in range (2, 5 * 10 ** 2):\n    v = True\n    for p in primes:\n        if i % p == 0:\n            v = False\n    if v == True:\n        primes.append(i)\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nif sum(a) == n:\n    z = False\nfor i in range (0, n):\n    x = a[i]\n    a[i] = []\n    for p in primes:\n        if x % p == 0:\n            a[i].append([p, 1])\n            x = x // p\n            while x % p == 0:\n                x = x // p\n    if x != 1:\n        a[i].append([x, 1])\n\nneighbours = [[] for i in range (0, n)]\nfor i in range (0, n - 1):\n    line = sys.stdin.readline().strip().split()\n    neighbours[int(line[0]) - 1].append(int(line[1]) - 1)\n    neighbours[int(line[1]) - 1].append(int(line[0]) - 1)\n\nleaves = []\nfor i in range (0, n):\n    if len(neighbours[i]) == 1:\n        leaves.append(i)\n\n\nwhile len(leaves) > 1:\n    x = leaves.pop()\n    y = neighbours[x][0]\n    neighbours[y].remove(x)\n    if len(neighbours[y]) == 1:\n        leaves.append(y)\n    for p in a[x]:\n        for q in a[y]:\n            if p[0] == q[0]:\n                answer = max([answer, p[1] + q[1]])\n                q[1] = max([q[1],p[1]+1])\n\n\nif z == False:\n    print(0)\nelse:\n    print(answer)\n", "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\n\ndv=list(range(200002))\nfor i in range(2,200002):\n    if ((i*i)>=200002): \n        break\n    if (dv[i]==i):\n        j=i\n        while ((i*j)<200002):\n            dv[i*j]=i\n            j=j+1\ndef loPr(x):\n    nonlocal dv\n    if (x<=1):\n        return []\n    ret=[]\n    while(x>1):\n        d=dv[x]\n        ret.append(d)\n        while(x%d==0):\n            x=trunc(x/d)\n    return ret\ndef main():\n    nonlocal dv\n    n=int(stdin.readline())\n    a=[0]+[int(x) for x in stdin.readline().split()]\n    e=[]\n    for _ in range(n+2):\n        e.append([])\n    for _ in range(n-1):\n        u,v=[int(x) for x in stdin.readline().split()]\n        e[u].append(v)\n        e[v].append(u)\n    \n    pre=[0]*(n+2)\n    q=[1]\n    d=[False]*(n+2)\n    d[1]=True\n    pre[1]=1\n    i=0\n    while(i<len(q)):\n        u=q[i]\n        for v in e[u]:\n            if (d[v]==False):\n                d[v]=True\n                pre[v]=u\n                q.append(v)\n        i=i+1\n    \n    f=[dict()]\n    for _ in range(n+2):\n        f.append(dict())\n    b=[[]]\n    for i in range(1,n+1):\n        b.append(loPr(a[i]))\n        for p in b[i]:\n            f[i][p]=[1]\n    q.reverse()\n    res=0\n    for u in q:\n        nxt=pre[u]\n        #print (str(u)+\": f=\" +str(f[u])+ \"  b=\" +str(b[u]))\n        for p in b[u]:\n            fp=f[u].get(p,[1])\n            fp.sort()\n            res=max(res,fp[-1])\n            if (len(fp)>=2):\n                res=max(res,fp[-1]+fp[-2]-1)\n            fnxt=f[nxt].get(p,None)\n            if (fnxt!=None):\n                fnxt.append(max(1,fp[-1])+1)\n    stdout.write(str(res))\n    return 0\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nimport sys\n\n\ndef get_primes(n):\n    result = set()\n    while n % 2 == 0:\n        result.add(2)\n        n = n / 2\n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n\n        while n % i == 0:\n            result.add(i)\n            n = n / i\n\n    if n > 2:\n        result.add(n)\n    return list(result)\n\n\n\ndef calc(w, t, n):\n    stack = []\n    stack.append((t[0], dict([(p, [0]) for p in get_primes(w[0])])))\n    max_length = 0\n    visited = [False] * n\n    visited[0] = True\n    while stack:\n        if stack[-1][0]:\n            nxt = stack[-1][0][-1]\n            stack[-1][0].pop()\n            if visited[nxt]:\n                continue\n            else:\n                visited[nxt] = True\n            stack.append((t[nxt], dict([(p, [0]) for p in get_primes(w[nxt])])))\n        else:\n            last = stack[-1][1]\n            stack.pop()\n            if last:\n                max_length = max(max_length, 1 + max([sum(v) for _, v in list(last.items())]))\n            if stack:\n                for k, v in list(last.items()):\n                    if k in list(stack[-1][1].keys()):\n                        stack[-1][1][k].append(max(v) + 1)\n                        stack[-1][1][k].sort(reverse=True)\n                        if len(stack[-1][1][k]) > 2:\n                            del stack[-1][1][k][-1]\n    return max_length\n\n\n# def __starting_point():\n#     print(primeFactors(100))\n\ndef __starting_point():\n    n = int(input())\n    weights = list(map(int, input().split()))\n    lines = sys.stdin.readlines()\n    tree = [[] for _ in range(n)]\n    for line in lines:\n        x, y = list(map(int, line.split()))\n        tree[x - 1].append(y - 1)\n        tree[y - 1].append(x - 1)\n\n    print(calc(weights, tree, n))\n\n__starting_point()", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/16/19\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\n\nN = int(input())\nA = [0] + [int(x) for x in input().split()]\nG = collections.defaultdict(list)\nfor i in range(N - 1):\n    x, y = list(map(int, input().split()))\n    G[x].append(y)\n    G[y].append(x)\n\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    \n    return x\n\n\ndp = [[] for _ in range(N + 1)]\n\n\ndef dfs(node, parent):\n    chd = []\n    ans = 0\n    for u in G[node]:\n        if u != parent:\n            ans = max(ans, dfs(u, node))\n            for t in dp[u]:\n                chd.append(t)\n    \n    chd.sort()\n    \n    i = 0\n    while i < len(chd):\n        j = i - 1\n        mx1, mx2 = 0, 0\n        while j + 1 < len(chd) and chd[j + 1][0] == chd[i][0]:\n            j += 1\n            if chd[j][1] >= mx1:\n                mx2, mx1 = mx1, chd[j][1]\n            elif chd[j][1] > mx2:\n                mx2 = chd[j][1]\n        \n        if A[node] % chd[i][0] == 0:\n            ans = max(ans, mx1 + mx2 + 1)\n            dp[node].append((chd[i][0], mx1 + 1))\n            while A[node] % chd[i][0] == 0:\n                A[node] //= chd[i][0]\n        else:\n            ans = max(ans, mx1)\n        \n        i = j + 1\n    \n    i = 2\n    while i * i <= A[node]:\n        if A[node] % i == 0:\n            dp[node].append((i, 1))\n            ans = max(ans, 1)\n            while A[node] % i == 0:\n                A[node] //= i\n        i += 1\n    \n    if A[node] > 1:\n        dp[node].append((A[node], 1))\n        ans = max(ans, 1)\n    \n    return ans\n\n\nprint(dfs(1, -1))\n# print(dp)\n", "from collections import deque\n# from time import time\n\n# tt = time()\nn = int(input())\na = [0] + list(map(int, input().split()))\ne = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n\tu, v = list(map(int, input().split()))\n\te[u].append(v)\n\te[v].append(u)\n# print(e)\n\n# find all primes\nisp = [1] * 501\nprime = []\nfor i in range(2, 501):\n\tif isp[i]:\n\t\tprime.append(i)\n\tfor p in prime:\n\t\tif i * p > 500:\n\t\t\tbreak\n\t\tisp[i * p] = 0\n\t\tif i % p == 0:\n\t\t\tbreak\nlp = len(prime)\n\n# gr is a forest, n is # of vertices\ndef diam(gr, n):\n\tvis = [0] * (n + 1)\n\tlvl = [-1] * (n + 1)\n\tmaxlvl = 0\n\tfor i in range(1, n + 1):\n\t\tif not vis[i]:\n\t\t\tq = deque([i])\n\t\t\tstart = i\n\t\t\twhile q:\n\t\t\t\tstart = q.popleft()\n\t\t\t\tfor to in gr[start]:\n\t\t\t\t\tif not vis[to]:\n\t\t\t\t\t\tvis[to] = 1\n\t\t\t\t\t\tq.append(to)\n\t\t\tq.append(start)\n\t\t\t# print(start)\n\t\t\tlvl[start] = 0\n\t\t\ttmplvl = 0\n\t\t\twhile q:\n\t\t\t\tcur = q.popleft()\n\t\t\t\tfor to in gr[cur]:\n\t\t\t\t\tif lvl[to] == -1:\n\t\t\t\t\t\tlvl[to] = lvl[cur] + 1\n\t\t\t\t\t\tq.append(to)\n\t\t\t\t\t\ttmplvl = lvl[to]\n\t\t\tmaxlvl = max(maxlvl, tmplvl)\n\treturn maxlvl + 1\n\n# print('input', time() - tt)\n# tt = time()\n\nnewn = [0] * (n + 1)\n# find vertices in each graph\nv = [[] for i in range(lp)]\nother = {}\nfor i in range(1, n + 1):\n\tl = a[i]\n\tfor j in range(lp):\n\t\tr = prime[j]\n\t\tif l % r == 0:\n\t\t\tv[j].append(i)\n\t\t\twhile l % r == 0:\n\t\t\t\tl //= r\n\tif l != 1:\n\t\tif l in other:\n\t\t\tother[l].append(i)\n\t\telse:\n\t\t\tother[l] = [i]\nfor val in list(other.values()):\n\tv.append(val)\nans = 0\n# build the graph\nfor i in range(len(v)):\n\tcount = 1\n\tfor node in v[i]:\n\t\tnewn[node] = count\n\t\tcount += 1\n\tif count == 1:\n\t\tcontinue\n\tg = [[] for i in range(count)]\n\tfor node in v[i]:\n\t\tfor to in e[node]:\n\t\t\tif newn[to]:\n\t\t\t\tg[newn[node]].append(newn[to])\n\tans = max(ans, diam(g, count - 1))\n\tfor node in v[i]:\n\t\tnewn[node] = 0\n\nprint(ans)\n\n\n\n", "from math import gcd\nn = int(input())\na = [int(i) for i in input().split()]\ntree = [[] for i in range(0, n)]\n\nfor i in range(0, n-1):\n  s = input().split()\n  v1 = int(s[0]) - 1\n  v2 = int(s[1]) - 1\n  tree[v1].append(v2)\n  tree[v2].append(v1)\n\nans = 0\nd = [{} for i in range (0, n)]\nfor i in range(0, n):\n  d[i] = {a[i]: 1} # gcd to path_length\n  if a[i] > 1: ans = 1\n\n\ndef dfs(curr, parent):\n  for child in tree[curr]:\n    if child == parent:\n      continue\n    dfs(child, curr)\n\n    new_gcd = gcd(a[curr], a[child])\n    if new_gcd > 1:\n      for g_parent, p_parent in list(d[curr].items()):\n        for g_child, p_child in list(d[child].items()):\n          if gcd(g_parent, g_child) > 1:\n            nonlocal ans\n            ans = max(ans, p_parent + p_child)\n\n    for g_child, p_child in list(d[child].items()):\n      new_gcd = gcd(a[curr], g_child)\n      if new_gcd > 1:\n        if new_gcd in d[curr]:\n          d[curr][new_gcd] = max(d[curr][new_gcd], p_child + 1)\n        else:\n          d[curr][new_gcd] = p_child + 1\n\ndfs(0, -1)\nprint(ans)\n"]
["from sys import stdin, stdout\n\nINF = int(1e9)\n\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n\ndef distance(p1, p2):\n    x = p1.x - p2.x\n    y = p1.y - p2.y\n    return x*x + y*y\n\n\ndef bruteForce(point_set, left, right):\n    min_dist = INF\n    for i in range(left, right):\n        for j in range(i+1, right):\n            min_dist = min(min_dist, distance(point_set[i], point_set[j]))\n    return min_dist\n\n\ndef stripClosest(point_set, left, right, mid, min_dist):\n    point_mid = point_set[mid]\n    splitted_points = []\n    for i in range(left, right):\n        if (point_set[i].x - point_mid.x) ** 2 <= min_dist:\n            splitted_points.append(point_set[i])\n    splitted_points.sort(key=lambda point: point.y)\n    l = len(splitted_points)\n    smallest = INF\n    for i in range(l):\n        for j in range(i+1, l):\n            if (splitted_points[i].y - splitted_points[j].y) ** 2 >= min_dist:\n                break\n            d = distance(splitted_points[i], splitted_points[j])\n            smallest = min(smallest, d)\n    return smallest\n\n\ndef closestUtil(point_set, left, right):\n    if right - left <= 3:\n        return bruteForce(point_set, left, right)\n\n    mid = (left + right) // 2\n    dist_left = closestUtil(point_set, left, mid)\n    dist_right = closestUtil(point_set, mid+1, right)\n    dist_min = min(dist_left, dist_right)\n\n    return min(dist_min, stripClosest(point_set, left, right, mid, dist_min))\n\n\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\n\npref = [0]\nfor i in range(n):\n    pref.append(pref[i] + a[i])\n\npoint_set = []\nfor i in range(n):\n    point_set.append(Point(i, pref[i+1]))\n\nans = closestUtil(point_set, 0, n)\nstdout.write(str(ans))\n", "import sys\nsys.setrecursionlimit(100000)\nINF = 1e9\n \n \nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n \ndef distance(p1, p2):\n    x = p1.x - p2.x\n    y = p1.y - p2.y\n    return (x ** 2 + y ** 2) ** 0.5\n \n \ndef brute_force(point_set, left, right):\n    min_dist = INF\n    for i in range(left, right):\n        for j in range(i + 1, right):\n            min_dist = min(min_dist, distance(point_set[i], point_set[j]))\n    return min_dist\n \n \ndef strip_closest(point_set, left, right, mid, dist_min):\n    point_mid = point_set[mid]\n    splitted_points = []\n    for i in range(left, right):\n        if abs(point_set[i].x - point_mid.x) <= dist_min:\n            splitted_points.append(point_set[i])\n    splitted_points.sort(key=lambda p: p.y)\n \n    smallest = INF\n    l = len(splitted_points)\n    for i in range(0, l):\n        for j in range(i + 1, l):\n            if not (splitted_points[j].y - splitted_points[i].y) < dist_min:\n                break\n            d = distance(splitted_points[i], splitted_points[j])\n            smallest = min(smallest, d)\n    return smallest\n \n \ndef closest_util(point_set, left, right):\n    if right - left <= 3:\n        return brute_force(point_set, left, right)\n    mid = (right + left) // 2\n    dist_left = closest_util(point_set, left, mid)\n    dist_right = closest_util(point_set, mid + 1, right)\n    dist_min = min(dist_left, dist_right)\n    return min(dist_min, strip_closest(point_set, left, right, mid, dist_min))\n \n \nn = int(input())\na = list(map(int, input().split()))\npoint_set = []\nfor i in range(n):\n    if (i > 0):a[i] += a[i - 1]\n    point_set.append(Point(i , a[i]))\n\npoint_set.sort(key=lambda a: a.x)\nans = closest_util(point_set, 0, n)\nprint('%.0f' % (ans * ans))\n", "import sys\nmax_Int = int(1e9)\n\nclass splitFeature:\n    def __init__(self, position, value):\n        self.position = position\n        self.value = value\n\ndef bruteForce(features, left, right):\n    min_distance = max_Int\n    for i in range(left, right):\n        for j in range(i+1, right):\n            min_distance = min(min_distance,\n                               (features[i].position - features[j].position)**2 + (features[i].value - features[j].value)**2)\n    return min_distance\n\ndef enhanceData(features, left, right, mid, min_distance):\n    selected_population = []\n    for i in range(left, right):\n        if (features[i].position - features[mid].position) ** 2 <= min_distance:\n            selected_population.append(features[i])\n    selected_population.sort(key = lambda x: x.value)\n    l = len(selected_population)\n    result = max_Int\n    for i in range(l):\n        for j in range(i+1, l):\n            if (selected_population[i].value - selected_population[j].value) ** 2 >= min_distance:\n                break\n            distance = (selected_population[i].position - selected_population[j].position)**2 + (selected_population[i].value - selected_population[j].value)**2\n            result = min(result, distance)\n    return result\n\ndef analyzeData(features, left, right):\n    if right - left <= 3:\n        return bruteForce(features, left, right)\n    mid = (left + right) // 2\n    min_distance = min(analyzeData(features, left, mid), \n                       analyzeData(features, mid+1, right))\n    return min(min_distance, \n               enhanceData(features, left, right, mid, min_distance))\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    features = []\n    for i in range(n):\n        if (i > 0):\n            A[i] += A[i-1]\n        features.append(splitFeature(i , A[i]))\n    sys.stdout.write(str(analyzeData(features, 0, n)))\n\nmain()\n", "import sys\nmax_Int = int(1e9)\n\nclass splitFeature:\n    def __init__(self, position, value):\n        self.position = position\n        self.value = value\n\ndef bruteForce(features, left, right):\n    min_distance = max_Int\n    for i in range(left, right):\n        for j in range(i+1, right):\n            min_distance = min(min_distance,\n                               (features[i].position - features[j].position)**2 + (features[i].value - features[j].value)**2)\n    return min_distance\n\ndef enhanceData(features, left, right, mid, min_distance):\n    selected_population = []\n    for i in range(left, right):\n        if (features[i].position - features[mid].position) ** 2 <= min_distance:\n            selected_population.append(features[i])\n    selected_population.sort(key = lambda x: x.value)\n    l = len(selected_population)\n    result = max_Int\n    for i in range(l):\n        for j in range(i+1, l):\n            if (selected_population[i].value - selected_population[j].value) ** 2 >= min_distance:\n                break\n            distance = (selected_population[i].position - selected_population[j].position)**2 + (selected_population[i].value - selected_population[j].value)**2\n            result = min(result, distance)\n    return result\n\ndef analyzeData(features, left, right):\n    if right - left <= 3:\n        return bruteForce(features, left, right)\n    mid = (left + right) // 2\n    min_distance = min(analyzeData(features, left, mid), \n                       analyzeData(features, mid+1, right))\n    return min(min_distance, \n               enhanceData(features, left, right, mid, min_distance))\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    features = []\n    for i in range(n):\n        if (i > 0):\n            A[i] += A[i-1]\n        features.append(splitFeature(i , A[i]))\n    sys.stdout.write(str(analyzeData(features, 0, n)))\n\nmain() #optimizeCode\n", "import sys\nmax_Int = int(1e9)\n\nclass splitFeature:\n    def __init__(self, position, value):\n        self.position = position\n        self.value = value\n\ndef bruteForce(features, left, right):\n    min_distance = max_Int\n    for i in range(left, right):\n        for j in range(i+1, right):\n            min_distance = min(min_distance,\n                               (features[i].position - features[j].position)**2 + (features[i].value - features[j].value)**2)\n    return min_distance\n\ndef enhanceData(features, left, right, mid, min_distance):\n    selected_population = []\n    for i in range(left, right):\n        if (features[i].position - features[mid].position) ** 2 <= min_distance:\n            selected_population.append(features[i])\n    selected_population.sort(key = lambda x: x.value)\n    l = len(selected_population)\n    result = max_Int\n    for i in range(l):\n        for j in range(i+1, l):\n            if (selected_population[i].value - selected_population[j].value) ** 2 >= min_distance:\n                break\n            distance = (selected_population[i].position - selected_population[j].position)**2 + (selected_population[i].value - selected_population[j].value)**2\n            result = min(result, distance)\n    return result\n\ndef analyzeData(features, left, right):\n    if right - left <= 3:\n        return bruteForce(features, left, right)\n    mid = (left + right) // 2\n    min_distance = min(analyzeData(features, left, mid), \n                       analyzeData(features, mid+1, right))\n    return min(min_distance, \n               enhanceData(features, left, right, mid, min_distance))\n\ndef main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    features = []\n    for i in range(n):\n        if (i > 0):\n            A[i] += A[i-1]\n        features.append(splitFeature(i , A[i]))\n    print(analyzeData(features, 0, n))\n\nmain()\n"]
["from sys import stdin\nfrom sys import stdout\nfrom collections import defaultdict\nn=int(stdin.readline())\na=[map(int,stdin.readline().split(),(10,10)) for i in range(n)]\nv=defaultdict(list)\nfor i,e in enumerate(a,1):\n    q,f=e\n    v[q-f].append(i)\n    v[q+f-1].append(-i)\nsa=set()\nrez=0\nfor j in sorted(v.keys()):\n    for d in v[j]:\n        if d>0:\n            sa.add(d)\n    for d in v[j]:\n        if -d in sa:\n            sa.clear()\n            rez+=1\nstdout.write(str(rez))", "n = int(input())\nl = []\nfor i in range(n):\n    x, y = map(int,input().split())\n    l   += [(x + y, x - y)]\nl.sort()\nr = -2000000000\na = 0\nfor u in l:\n    if u[1] >= r:\n        a += 1\n        r  = u[0]\nprint(a)", "#!/usr/bin/env python\n# coding=utf-8\n\nn = int(input())\nl = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    l += [(x + y, x - y)]\nl.sort()\nr = -2000000000\na = 0\nfor u in l:\n    if u[1] >= r:\n        a += 1\n        r = u[0]\nprint(a)\n", "n = int(input())\nl = sorted([(x[0] - x[1],x[0] + x[1]) for x in [list(map(int,input().split())) for _ in range(n)]],key=lambda x: x[1])\nans = 1; cur = 0\nfor i in range(1,n):\n    if l[cur][1] <= l[i][0]:\n        cur = i; ans += 1\nprint (ans)", "n = int(input())\nS=[]\nfor _ in range(n):\n    x,w = list(map(int,input().split()))\n    S.append((x,w))\nS = sorted(S,key=lambda kv:kv[0]+kv[1])\nm=1\nlast=S[0]\nfor kv in S[1:]:\n    if abs(kv[0]-last[0]) >= kv[1]+last[1]:\n        m+=1\n        last=kv\nprint(m)\n\n", "def read_data():\n    n = int(input())\n    ranges = []\n    buffer = [input() for i in range(n)]\n    for xw in buffer:\n        x, w = map(int, xw.split())\n        ranges.append((x + w, x - w))\n    return n, ranges\n\ndef solve(n, ranges):\n    ranges.sort()\n    n = 0\n    end = - float('inf')\n    for e, b in ranges:\n        if b >= end:\n            n += 1\n            end = e\n    return n\n\nn, ranges = read_data()\nprint(solve(n, ranges))", "import sys\n\nn = int(input())\nranges = []\nfor xw in sys.stdin:\n    x, w = map(int, xw.split())\n    ranges.append((x + w, x - w))\nranges.sort()\nresult = 0\nend = - float('inf')\nfor e, b in ranges:\n    if b >= end:\n        result += 1\n        end = e\nprint(result)", "from pip._vendor.distlib.compat import raw_input\n\nn = int(input())\na = []\n\nfor i in range(n):\n    ta, tb = list(map(int,input().split()))\n    a.append((ta,tb))\n\na.sort()\nans = 1\nta, tb = a[0][0],a[0][1]\nfor i in range(1,n):\n    if a[i][0]-a[i][1] >=ta+tb:\n        ans += 1\n        ta = a[i][0]\n        tb = a[i][1]\n    elif a[i][0]+a[i][1] < ta+tb:\n        ta = a[i][0]\n        tb = a[i][1]\nprint(ans)\n        \n", "N = int(input())\n\npairs = []\nfor i in range(N):\n    x, w = list(map(int, input().split()))\n    pairs.append((x, w))\n\nsorted_pairs = sorted(pairs, key=lambda x: x[0])\n\nstack = []\nstack.append(sorted_pairs[0])\nfor x, w in sorted_pairs[1:N]:\n    right_x, right_w = stack[-1]\n    if right_x + right_w <= x - w:\n        stack.append((x, w))\n    else:\n        if x + w < right_x + right_w:\n            stack[-1] = (x, w)\n\nprint(len(stack))\n", "def on(l1, l2):\n    return(abs(l1[0]-l2[0])>=l1[1]+l2[1])\nn = int(input())\ninf = []\nfor i in range(n):\n    a,b = list(map(int,input().split()))\n    inf.append([a+b,a-b])\ninf.sort()\nres = 1\nlast = 0\nfor i in range(1,n):\n    if inf[i][1] >= inf[last][0]:\n        res+=1\n        last = i\nprint(res)\n\n", "R = lambda: list(map(int,input().split()))\nn = int(input())\na = []\nfor _ in range(n):\n    a.append(R())\na.sort(key=lambda x:(x[0]+x[1]))\nj = 0; ans = 1\nfor i in range(1,n):\n    if a[j][0]+a[j][1]<=a[i][0]-a[i][1]:\n        ans += 1\n        j = i\nprint(ans)", "from sys import stdin,setrecursionlimit\nimport threading\n\ndef main():\n    n = int(stdin.readline())\n\n    line = []\n\n    for i in range(n):\n        x, w = [int(x) for x in stdin.readline().split()]\n        line.append((x-w,x+w))\n\n    line.sort()\n\n    def best(ind, line):\n        r = line[ind][1]\n        nxt = ind+1\n        while nxt < len(line):\n            nL, nR = line[nxt]\n            if nL >= r:\n                return best(nxt, line)+1\n            elif nR < r:\n                return best(nxt,line)\n            nxt += 1\n        return 1\n    print(best(0,line))\n\ndef __starting_point():\n    setrecursionlimit(10**6)\n    threading.stack_size(10**8)\n    t = threading.Thread(target=main)\n    t.start()\n    t.join()\n        \n\n__starting_point()"]
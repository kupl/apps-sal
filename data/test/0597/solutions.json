["from collections import deque\nn,m = [int(x) for x in input().split()]\nadj = [[] for x in range(n+1)]\nfor _ in range(1,n):\n\ta,b = [int(x) for x in input().split()]\n\tadj[a].append(b)\n\tadj[b].append(a)\nchaos = [int(x) for x in input().split()]\ns = chaos[0]\nchaos = set(chaos)\ncc = [0]*(n+1)\nst = deque()\nst.append((s,-1))\nwhile len(st):\n\tu,e = st.pop()\n\tif u<0:\n\t\tif e>=0:\n\t\t\tcc[e] += cc[-u]\n\t\tcontinue\n\tif u in chaos:\n\t\tcc[u] +=1\n\tst.append((-u,e))\n\t\n\tfor v in adj[u]:\n\t\tif v!=e:\n\t\t\tst.append((v,u))\n\t\n#dfs(s,-1)\nadj = [list([v for v in u if cc[v]>0]) for u in adj]\na = (s,0)\nst = deque()\nst.append((a[0],-1,0))\nwhile len(st):\n\tu,e,h = st.pop()\n\tif h>a[1]:\n\t\ta = (u,h)\n\telif h==a[1] and u<a[0]:\n\t\ta = (u,h)\n\tfor v in adj[u]:\n\t\tif v!=e:\n\t\t\tst.append((v,u,h+1))\nb = a\na = (a[0],0)\nst = deque()\nst.append((a[0],-1,0))\nwhile len(st):\n\tu,e,h = st.pop()\n\tif h>a[1]:\n\t\ta = (u,h)\n\telif h==a[1] and u<a[0]:\n\t\ta = (u,h)\n\tfor v in adj[u]:\n\t\tif v!=e:\n\t\t\tst.append((v,u,h+1))\nprint(min(a[0],b[0]))\nprint(2*(n-cc.count(0))-a[1])\n", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)    \n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\n\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)    \n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\n\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))", "from collections import deque\n\n#parser\ndef parser():\n    return [int(x) for x in input().split()]\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)    \n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    edge=parser()\n    adjacents_list[edge[0]-1].append(edge[1]-1)\n    adjacents_list[edge[1]-1].append(edge[0]-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[]\nfor i in parser():\n    numbers_of_attacked_cities.append(i-1)\n\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))", "from heapq import *\nINF = float('inf')\nn, m = list(map(int, input().split()))\nadj = [[] for _ in range(n+1)]\nwg= ng = [0 for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    adj[a].append(b)\n    adj[b].append(a)\n\naaa = set(map(int, input().split()))\nif len(aaa) == 1:print((min(aaa)));print((0));return\nrm = []\nfor i in range(n+1):\n    ng[i] = len(adj[i])\n    if i not in aaa and ng[i] == 1: rm.append(i)\n\nfor a in aaa: ng[a] = 0\n\ndef remove_node(index):\n    while adj[index]:\n        nx = adj[index].pop()\n        adj[nx].remove(index)\n        ng[nx] -= 1\n        if ng[nx] == 1: rm.append(nx)\n\n    ng[index] = 0\n\nwhile rm: remove_node(rm.pop())\n\nstate = [0 for _ in range(n+1)]\nque = [(min(aaa), None)]\nres = 0\nfor _ in range(2):\n    deep = [0 for _ in range(n + 1)]\n    while que:\n        res += 1\n        root, proot = que.pop()\n        for nx in adj[root]:\n            if proot == nx:\n                continue\n            if _: state[nx] = root\n            deep[nx] = deep[root] + 1\n            que.append((nx, root))\n    if _: break\n\n    start = max(1,deep.index(max(deep)))\n    que = [(start, None)]\n\nend = max(1, deep.index(max(deep)))\ni = end\npath = 1\nwhile i != start:\n    path += 1\n    i = state[i]\n\nprint(min(start,end))\nprint(res -1 -path)\n", "from collections import deque\nfrom sys import stdin\n\n#parsea una l\u00ednea\ndef parser():\n    return map(int, stdin.readline().split())\n\n#M\u00e9todo usado para obtener los v\u00e9rtices por los que debe pasar Super M\ndef DFS_Discriminiting():\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    introduction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                introduction_order.append(u)    \n    for v in introduction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\n#M\u00e9todo usado para calcular las alturas\ndef DFS_Heigths():\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    introduction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                visited[u]=True\n                stack.append(u)\n                introduction_order.append(u)\n    for v in introduction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\n#M\u00e9todo usado para calcular la primera y segunda distancia de la ra\u00edz \ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\n#M\u00e9todo usado para calcular la primera distancia y segunda distancia de cada v\u00e9rtice\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                visited[u]=True\n                stack.append(u)\n                determinate=False\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\n#M\u00e9todo usado para calcular las distancias de un v\u00e9tice al resto de los v\u00e9rtices\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n#Recibiendo los valores de n y m\nn,m=parser()\n#padres\npi=[0 for x in range(n)]\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\n\n#Armando el \u00e1rbol que representa a Byteforces\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#n\u00famero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\n#Obteniendo las ciudades que recorre Super M\nDFS_Discriminiting()\n\n#Creando el nuevo \u00e1rbol que representa el recorrido de Super M\nadjacents_list=[[] for x in range(n)]\n\n#Armando el nuevo \u00e1rbol y contando sus aristas\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\n\n#Calculando las alturas\nDFS_Heigths()\n\n#distancias\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\n\n#Calculando las distancias\nDFS_Distances()\n\n#Hallando la mayor distancia de las primeras distancias\nmin_distance=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and min_distance>distances1[i]:\n        min_distance=distances1[i]\n\n#Hallando el centro\ncenter=[]\nfor i in range(n):\n    if distances1[i]==min_distance:\n        center.append(i)\n\nposibles_begin_cities=[]\n\n#Hallando la ciudad por la cual comenzar\nfor i in center:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n#Imprimiendo la respuesta\nprint(min(posibles_begin_cities)+1)\nprint(2*count_edges-(distances1[center[0]]+distances2[center[0]]))"]
["from heapq import *\n\nN = int(input())\nprice = [int(i) for i in input().split()]\n\ntotal = 0\ninf = (10**6) + 1\nh = [inf]\n\n#Assume we bought and sold optimally for the first k prices.\n#We adjust our answer for the (k+1)th price that comes up.\nfor p in price:\n    if p > h[0]:\n        total += (p - heappop(h))\n        #We push p onto heap in case we should have bought at this price instead\n        #of selling.\n        heappush(h, p)\n    heappush(h, p)\n\nprint(total)", "import math\nfrom heapq import *\n\n\ndef maxProfit(prices, days):\n\n    payoff = 0\n    maxPrice, minPrice = max(prices), min(prices)\n    maxIndex, minIndex = prices.index(maxPrice), prices.index(minPrice)\n    iterator = iter(prices) \n    h = [] # heap\n\n    if days == 1:\n        print(0)\n        return\n\n\n    for i in range(days):\n        p = next(iterator)\n        if not i:\n            heappush(h, p)\n            continue\n        if h[0] < p:\n            payoff += p - h[0]\n            heappop(h)\n            heappush(h, p)\n        heappush(h, p)\n\n    print(payoff)\n\n\n\ndef __starting_point():\n    n = int(input())\n    prices = list(map(int, input().split()))\n    maxProfit(prices, n)\n__starting_point()", "from heapq import heappush,heappop\nn=int(input())\nar=list(map(int,input().split()))\nunsed=[]\nselled=[]\nsm=0\nfor x in ar:\n    U,S=len(unsed),len(selled)\n    u=heappop(unsed) if U else float('inf')\n    s=heappop(selled) if S else float('inf')\n    y=min(u,s)\n    if(y<x):\n        if(u==y):\n            sm+=x-y\n            if(S):heappush(selled,s)\n            heappush(selled,x)\n        else:\n            sm+=x-y\n            heappush(unsed,y)\n            if(U):heappush(unsed,u)\n            heappush(selled,x)\n    else:\n        if(S):heappush(selled,s)\n        if(U):heappush(unsed,u)\n        heappush(unsed,x)\nprint(sm)\n"]
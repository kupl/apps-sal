["import math\n\nl = int(input()) - 1\nn = int(math.log2(l + 1) + 1)\nres = []\nfor i in range(n - 1):\n    res.append([i + 1, i + 2, 0])\n    res.append([i + 1, i + 2, 2 ** i])\ni = n - 2\nwhile l > 2 ** (n - 1) - 1:\n    t = l - 2 ** i + 1\n    if t > 2 ** (n - 1) - 1:\n        res.append([i + 1, n, t])\n        l = t - 1\n    i -= 1\nprint((n, len(res)))\nfor i in range(len(res)):\n    print((res[i][0],res[i][1],res[i][2]))\n", "L=int(input())\nl=0\npp=0\ntmp=L\nwhile tmp>0:l+=1;pp+=tmp%2;tmp//=2\nprint(l,l*2-3+pp)\nfor i in range(1,l):\n  print(i,i+1,0)\n  a=1<<i-1\n  print(i,i+1,a)\n  if L&a:L-=a;print(i,l,L)", "def main():\n    L = int(input())\n    r = 0\n    while 2 ** (r+1) <= L:\n        r += 1\n    assert r < 20\n    N = r + 1\n    edges = list()\n    for i in range(1, N):\n        edges.append((i, i + 1, 0))\n        edges.append((i, i + 1, 2**(i - 1)))\n    for t in range(N - 1, 0, -1):\n        if L - 2**(t - 1) >= 2**r:\n            edges.append((t, N, L - 2**(t - 1)))\n            L -= 2**(t - 1)\n    print('{} {}'.format(N, len(edges)))\n    for e in edges:\n        print(' '.join(map(str, e)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "l=int(input())\nfor i in range(1,21):\n\tif 2**i>l:\n\t\tr=i-1\n\t\tbreak\nans=[]\nfor i in range(r):\n\tans.append((i+1,i+2,0))\n\tans.append((i+1,i+2,2**i))\nnow=2**r-1\nfor i in range(r,0,-1):\n\tif 2**(i-1)+now<=l-1:\n\t\tans.append((i,r+1,now+1))\n\t\tnow+=2**(i-1)\nprint(r+1,len(ans))\nfor x in ans:\n\tprint(*x)", "import math\n\nL = int(input())\nN = int(math.log2(L))+1\n\nM = 2*(N-1)\n\n# print(N, )\nedges = []\nfor i in range(N-1):\n    edges.append('{0} {1} {2}'.format((i+1) , (i+2), 0))\n    \nfor i in range(N-1):\n    edges.append('{0} {1} {2}'.format((i+1) , (i+2), 2**i))\n\nnode = L-2**(N-1)\nX = 2**(N-1)\n\nwhile node > 0:\n    M += 1\n    t = int(math.log2(node))+1\n    edges.append('{0} {1} {2}'.format(t, N, X))\n    node -= 2**(t-1)\n    X += 2**(t-1)\n    \noutput = \"\"\"{0} {1}\n{2}\"\"\".format(N,M,'\\n'.join(edges))\nprint(output)", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(L):\n    import math\n    N = int(math.log2(L))\n    grahp = []\n    for i in range(1, N + 1):\n        grahp.append([i, i + 1, 0])\n        grahp.append([i, i + 1, 2 ** (i - 1)])\n    for i in range(N, 0, -1):\n        if L - 2 ** (i - 1) >= 2 ** N:\n            L = L - 2 ** (i - 1)\n            grahp.append([i, N + 1, L])\n    M = len(grahp)\n\n    print(N + 1, M)\n    [print(' '.join([str(i) for i in g])) for g in grahp]\n\n\n\ndef __starting_point():\n    # S = input()\n    L = int(input())\n    # N, M = map(int, input().split())\n    # A = [int(i) for i in input().split()]\n    # B = [int(i) for i in input().split()]\n    # AB = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(L)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "# coding: utf-8\nimport sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nL = ir()\nedges = []\nlength = L.bit_length()\nfor i in range(1, length):\n    edges.append((i, i+1, 2**(i-1)))\n    edges.append((i, i+1, 0))\n\n# 2**(length-1)-1\u307e\u3067\u306e\u6570\u306f\u5b8c\u4e86\n# L\u306b\u8fd1\u3044\u5207\u308c\u7aef\u304b\u3089\u51e6\u7406\u3057\u3066\u3044\u304f\nfor i in range(length-1):\n    if L >> i & 1:\n        L -= 2 ** i\n        edges.append((i+1, length, L))\n\nprint((length, len(edges)))\nfor x in edges:\n    print((*x))\n", "\ndef get_node(num):\n    now_num = 1\n    count = 1\n    while 1:\n        if now_num > num:\n            count -= 1\n            break\n        count += 1\n        now_num *= 2\n    return count\n\ndef get_ans_data(node_num):\n    ans_data = []\n    for i in range(1, node_num):\n        data = [i, i + 1, 2**(i - 1)]\n        data2 = [i, i + 1, 0]\n        ans_data.append(data)\n        ans_data.append(data2)\n    return ans_data\n\ndef main():\n    num = int(input())\n\n    node_num = get_node(num)\n    ans_data = get_ans_data(node_num)\n\n    now_path = 2 ** (node_num - 1)\n    now_num = node_num - 1\n\n\n    for i in range(now_num, 0, -1):\n        now_data = 2 ** (i - 1)\n        if num - now_data >= now_path:\n            ans_data.append((i, node_num, num - now_data))\n            num -= now_data\n\n    print((node_num, len(ans_data)))\n    for data in ans_data:\n        print((' '.join(list(map(str, data)))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n# MOD = 998244353\n\n\nL = int(sys.stdin.buffer.readline())\n# 2\u3079\u304d\u306a\u30892\u500b\u305a\u3064\u8fba\u3092\u5f35\u308c\u3070OK\nV = L.bit_length()\nans = []\nfor v in range(V - 1):\n    ans.append((v, v + 1, 0))\n    ans.append((v, v + 1, 2 ** v))\n\npos = V - 2\nw = 1 << L.bit_length() - 1\nwhile pos >= 0:\n    if L & (1 << pos):\n        ans.append((pos, V - 1, w))\n        w |= L & (1 << pos)\n    pos -= 1\nE = len(ans)\nprint((V, E))\nfor r in ans:\n    v, u, w = r\n    v += 1\n    u += 1\n    print((v, u, w))\n", "from math import log2\n\n\nL = int(input())\nr = int(log2(L))\nN = r + 1\nedge = []\nfor i in range(r):\n    edge.append((i + 1, i + 2, 2 ** i))\n    edge.append((i + 1, i + 2, 0))\nfor t in range(N - 1, 0, -1):\n    s = L - 2 ** (t - 1)\n    if s >= 2 ** r:\n        edge.append((t, N, s))\n        L = s\n\nprint((N, len(edge)))\nfor e in edge:\n    print((*e))\n", "L = int(input())\nN = len(bin(L)[2:])\nR = 1 << N - 1\nUVW = sum([[(i, i+1, 0), (i, i+1, 1<<i-1)] for i in range(1, N)], [])\nfor i, s in enumerate(bin(L)[:2:-1], 1):\n    if s == \"1\":\n        UVW.append((i, N, R))\n        R += 1 << i - 1\n\nprint(N, len(UVW))\nfor t in UVW:\n    print(*t)", "import sys\nimport math\n\ninput_methods=['clipboard','file','key']\nusing_method=1\ninput_method=input_methods[using_method]\n\ntin=lambda : map(int, input().split())\nlin=lambda : list(IN())\nmod=1000000007\n\n#+++++\n\ndef main():\n\tL = int(input())\n\t#b , c = tin()\n\t#s = input()\n\tv = int(math.log2(L))\n\t#pa(v)\n\tnum_p = v\n\tpath_info=[]\n\tfor i in range(v):\n\t\tpath_info.append([i,i+1,0])\n\t\tpath_info.append([i,i+1,2**i])\n\t\n\t#for li in path_info:\n\t#\tprint(*li)\n\t\n\tnokori = L - (2 ** v)\n\t\n\t#print(nokori)\n\tfor i in range(v+1):\n\t\tm = v - i\n\t\tif 2 ** m <= nokori:\n\t\t\tpath_info.append([m, v, L - nokori])\n\t\t\tnokori -= 2 ** m\n\tprint(v+1, len(path_info))\n\tfor l in path_info:\n\t\tf,t,w = l\n\t\tprint(*[f+1, t+1, w])\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "# mada dame datta.\ndef main():\n    L = int(input())\n    b = bin(L)[2:]\n    bl = len(b)\n    r = []\n    for i in range(bl-1):\n        r.append((i+1, i+2, 0))\n        r.append((i+1, i+2, 2**i))\n    if L == 2**(bl-1):\n        pr(r)\n        return\n    end = bl\n    for i in reversed(list(range(1, end))):\n        if L - 2**(i-1) >= 2**(end-1):\n            r.append((i, end, L-2**(i-1)))\n            L -= 2**(i-1)\n    pr(r)\ndef pr(r):\n    m = 0\n    for i in r:\n        m = max(m, i[1])\n    print((m, len(r)))\n    for i in r:\n        print((i[0], i[1], i[2]))\nmain()\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(L: int):\n    sL = \"{:b}\".format(L)\n    N = len(sL)\n    M = 2 * (N - 1) + sL.count(\"1\") - 1\n    print((N, M))\n    for i in range(N - 1):\n        print((i + 1, i + 2, 0))\n        print((i + 1, i + 2, 2 ** i))\n    for i, c in enumerate(reversed(sL[1:])):\n        if c == \"0\":\n            continue\n        print((i + 1, N, int(sL[:-i - 1], 2) * 2 ** (i + 1)))\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    L = int(next(tokens))  # type: int\n    solve(L)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "L = int(input())\n\nprint((L.bit_length(), 2*(L.bit_length()-1) + (bin(L)[3:]).count('1')))\nfor i in range(L.bit_length()-1,0,-1):\n    print((i,i+1,0))\n    print((i,i+1,1<<(i-1)))\n    if (L >> i-1) & 1:\n        print((i,L.bit_length(),L>>i<<i))\n", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# L \u3068 2 ** n \u306e\u5dee\nL = ir()\nlength = L.bit_length()\nedges = []\nfor i in range(1, length):\n    edges.append((i, i+1, 0))\n    edges.append((i, i+1, 2**(i-1)))\n\nfor i in range(length-1):\n    if L >> i & 1:\n        L -= 2**i\n        edges.append((i+1, length, L))\n\nprint((length, len(edges)))\nfor e in edges:\n    print((*e))\n\n# 56\n", "import sys\nfrom math import log2, floor\n\nL = int(sys.stdin.readline().rstrip())\n\ndef main():\n    n = floor(log2(L)) + 1\n    m = 2 * (n - 1)\n    edges = []\n    for i in range(1, n):\n        edges.append((i, i+1, 0))\n        edges.append((i, i+1, 2**(i-1)))\n    \n    cur = 2 ** (n - 1)\n    q = L - cur\n    for i in range(1, n):\n        q, r = divmod(q, 2)\n        if not r:\n            continue\n        else:\n            edges.append((i, n, cur))\n            cur += 2 ** (i - 1)\n            m += 1\n    \n    yield (n, m)\n    for e in edges:\n        yield e\n\ndef __starting_point():\n    ans = main()\n    for i in ans:\n        print(*i, sep=' ')\n__starting_point()", "L = int(input())\nedges = []\n\np2 = 1\nN = 1\n\n\"\"\" 2\u3079\u304d\u306e\u3068\u304d\u591a\u91cd\u8fba\n   0     0     0     0  ...\n1 === 2 === 3 === 4 === 5 ...\n   1     2     4     8  ...\n\"\"\"\nwhile L >= p2 * 2:\n    N += 1\n    p2 *= 2\n    edges.append((N - 1, N, 0))\n    edges.append((N - 1, N, 2 ** (N - 2)))\n\nrest = L - p2\ntmp = p2\nfor i in range(N, -1, -1):\n    if (rest >> i) & 1:\n        edges.append((i + 1, N, tmp))\n        tmp += 2 ** i\n\nM = len(edges)\n# assert N <= 20 and M <= 60\nprint((N, M))\nfor edge in edges:\n    print((*edge))\n", "def f(k,L,p): \n  m = L\n  while m%3 > 0:\n    p += [[k+1,20,(m-1)*(3**k)]]\n    m = m-1\n  if m == 0:\n    print(20,len(p))\n    for l in p:\n      print(\" \".join([str(t) for t in l]))\n    return\n  for i in range(3):\n    p += [[k+1,k+2,i*(3**k)]]\n  m = m//3\n  if m > 0:\n    return f(k+1,m,p)\n\n\n\n\nf(0,int(input()),[])", "L=int(input())\nn=L.bit_length()\nif L==2**n:\n  n+=1\npath=[]\nfor i in range(1,n):\n  path.append([i,i+1,0])\n  path.append([i,i+1,2**(i-1)])\nk=(L-1)-(2**(n-1)-1)\ncur=2**(n-1)\nwhile k>0:\n  if k==1:\n    kk=1\n  else:\n    kk=k.bit_length()\n  path.append([kk,n,cur])\n  cur+=2**(kk-1)\n  k=L-cur\nprint(n,len(path))\nfor p in path:\n  print(*p)", "import copy\nn = int(input())\na = [2**x for x in range(0,21) ]\nb = 0\nfor i, name in enumerate(a):\n    b_copy = copy.deepcopy(b)\n    b = name\n    if b > n:\n        break\n\nans = []\nans_l = []\nc = n - b_copy\nfor j in range(i-1)[::-1]:\n    if a[j] <= c:\n        c -= a[j]\n        ans.append(j)\n        ans_l.append(b_copy)\n        b_copy += a[j]\n\nN = i\nH = 0\nA = []\n\nfor k in range(1, i):\n    A.append([k, k+1, 0])\n    A.append([k, k+1, 2**(k-1) ])\n    H += 2\n    if k-1 in ans:\n        A.append([k, N, ans_l[ans.index(k-1)]])\n        H += 1\n\nprint(\" \".join([str(N), str(H)]))\nfor kk in A:\n    print(\" \".join(list(map(str, kk))))", "L = int(input())\n\nLbin = (bin(L)[2:])[::-1]\nN = len(Lbin)\nM = 2 * (N - 1) + Lbin.count(\"1\") - 1\nprint(N, M)\n\nfor i in range(0, N - 1):\n    print(i + 1, i + 2, 0)\n    print(i + 1, i + 2, 2 ** i)\n\nweight = L\nfor i in range(0, N - 1):\n    if Lbin[i] == '1':  # 2^i\u306e\u4f4d\n        weight -= 2 ** i\n        print(i + 1, N, weight)", "#\n# \u3000\u3000  \u22c0_\u22c0\u3000 \n#\u3000\u3000  (\uff65\u03c9\uff65)  \n# .\uff0f \uff35 \u223d \uff35\uff3c\n#  \u2502\uff0a\u3000\u5408\u3000\uff0a\u2502\n#  \u2502\uff0a\u3000\u683c\u3000\uff0a\u2502 \n#  \u2502\uff0a\u3000\u7948\u3000\uff0a\u2502 \n#  \u2502\uff0a\u3000\u9858\u3000\uff0a\u2502 \n#  \u2502\uff0a\u3000\u3000\u3000\uff0a\u2502 \n#      \uffe3\n#\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nfrom math import floor,sqrt,factorial,hypot,log #log2\u306a\u3044\uff59\uff50\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\nfrom fractions import gcd\nfrom random import randint\ndef ceil(a,b): return (a+b-1)//b\ninf=float('inf')\nmod = 10**9+7\ndef pprint(*A): \n    for a in A:     print(*a,sep='\\n')\ndef INT_(n): return int(n)-1\ndef MI(): return map(int,input().split())\ndef MF(): return map(float, input().split())\ndef MI_(): return map(INT_,input().split())\ndef LI(): return list(MI())\ndef LI_(): return [int(x) - 1 for x in input().split()]\ndef LF(): return list(MF())\ndef LIN(n:int): return [I() for _ in range(n)]\ndef LLIN(n: int): return [LI() for _ in range(n)]\ndef LLIN_(n: int): return [LI_() for _ in range(n)]\ndef LLI(): return [list(map(int, l.split() )) for l in input()]\ndef I(): return int(input())\ndef F(): return float(input())\ndef ST(): return input().replace('\\n', '')\ndef main():\n    L=I()\n    power = 1\n    N = 1\n    while power<<1 <= L:\n        power<<=1\n        N+=1\n    \n    ans = []\n    for i in range(N-1):\n        ans.append((i+1,i+2,0))\n        ans.append((i+1,i+2,1<<i))\n    for i in range(N-1)[::-1]:\n        X=L-(1<<i)\n        if(X>=power): #X<(1<<N)\u306a\u3089\u30c0\u30d6\u308b\n            ans.append((i+1,N,X))\n            L-=1<<i\n    M=len(ans)\n    print(N,M)\n    for a in ans:\n        print(*a)\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nL = int(input())\n\nbranches = []\n# \u30ce\u30fc\u30c9\u6570\u306f (2^n - 1) \u306e\u3068\u304d\u306b 1 \u5897\u3048\u308b\nnode_count = int(np.log2(L)) + 1\n\n# (0, 1), (0, 2), (0, 4), ... \u3063\u30662\u500b\u305a\u3064\u30d6\u30e9\u30f3\u30c1\u5f15\u304f\u3002\n# \u3053\u308c\u3067 0 \u304b\u3089 2^n - 1 (< L) \u307e\u3067\u4f5c\u308c\u308b\nfor n in range(node_count - 1):\n    branches.append((n, n + 1, 0))\n    branches.append((n, n + 1, 2 ** n))\n\n# \u3053\u308c\u304c '1' \u306e\u30ce\u30fc\u30c9\u304b\u3089\u6700\u5f8c\u307e\u3067\u7dda\u3092\u5f15\u304d\u305f\u3044\nbyte_list = list(reversed(format(L, 'b')))[:-1]\n# \u9577\u3055\u306f\u305d\u308c\u3063\u307d\u3044\u611f\u3058\u306b\u3059\u308b\na = 2 ** (node_count - 1)\nfor i in reversed(list(range(len(byte_list)))):\n    if byte_list[i] == '1':\n        branches.append((i, node_count - 1, a))\n        a += 2 ** i\n\nprint((node_count, len(branches)))\nfor u, v, w in branches:\n    print((u + 1, v + 1, w))\n", "L=int(input())\nn=len(str(bin(L)))-3\ne=[]\nfor i in range(n):\n    e.append((i+1, i+2, 0))\n    e.append((i+1, i+2, 2**(n-i-1)))\nh=2**n\nfor i, c in enumerate(str(bin((L)))[2:]):\n    if c==\"1\"and i:\n        e.append((1,i+1,h))\n        h+=2**(n-i)\nprint(n+1,len(e))\nfor i in e:print(*i)", "def gen_graph(i,step,L):\n  # index i\u304b\u3089\u59cb\u3081\u308b\n  # 0\u304b\u3089weight*(L-1)\u307e\u3067\u306eL\u7a2e\u306e\u9577\u3055\u3092\u4f5c\u308b\n  if L == 1:\n    return [i],[]\n  v,e = gen_graph(i+1,2*step,L//2)\n  v = [i] + v\n  e = e + [(i,i+1,0),(i,i+1,step)]\n  # (0 or 1)+(L//2\u7a2e\u306e\u5076\u6570)\u304c\u4f5c\u308c\u3066\u3044\u308b\n  if L%2 == 0:\n    return v,e\n  e.append((i,v[-1],step*(L-1)))\n  return v,e\n\nL = int(input())\n\nv,e = gen_graph(1,1,L)\nprint((len(v),len(e)))\nfor a,b,c in e:\n  print((a,b,c))\n\n\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(L: int):\n    tmp = L\n    a = []\n    while tmp > 0:\n        a.append(tmp)\n        tmp //= 2\n    a.reverse()\n    #print(a)\n    e = []\n    for i in range(1, len(a)):\n        e.append([i, i + 1, 0])\n        e.append([i, i + 1, a[i - 1]])\n        if a[i] % 2 > 0:\n            e.append([1, i + 1, a[i] - 1])\n    print((len(a), len(e)))\n    for t in e:\n        print((t[0], t[1], t[2]))\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    L = int(next(tokens))  # type: int\n    solve(L)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "L = int(input())\n\nb = bin(L-1)[2:]\nl = len(b)\nout = []\nfor i in range(1,l+1):\n    out.append([i,i+1,0])\nfor i in range(2,l+1):\n    out.append([i,i+1,1<<(l-i)])\n\nif not \"0\" in b:\n    out.append([1,2,1<<(l-1)])\n    b = \"\"\nwhile len(b)>0 and b != \"0\":\n    if b[-1] == \"0\":\n        out.append([1,len(b)+1,int((b+\"0\"*l)[:l],2)])\n        b = bin(int(b,2)-1)[2:]\n    b = b[:-1]\n\nif l < 20:\n    print(l+1,len(out))\n    for sub in out:\n        print(\" \".join(map(str,sub)))\nelse:\n    print(l,len(out)-1)\n    for u,v,w in out[1:]:\n        u = max(1,u-1)\n        v = max(1,v-1)\n        print(u,v,w)", "L = int(input())\n\nr = 0\nwhile 2 ** r <= L:\n    r += 1\n\nE = []\nfor i in range(1, r):\n    E.append((i, i + 1, 0))\n    E.append((i, i + 1, 2 ** (i - 1)))\n\n# 2**(r-1) \uff5e L-1 \u306ePATH\u304c\u306a\u3044\u3002\n\nn = 2 ** (r - 1)\n\n###\nwhile True:\n    d = L - 1 - n + 1\n    if d <= 0:\n        break\n    zi = 0\n    while 2 ** (zi) <= d:\n        zi += 1\n\n    E.append((zi, r, n))\n    n = n + 2 ** (zi - 1)\n\nprint((\"{} {}\".format(r, len(E))))\n\nfor e in E:\n    print((\"{} {} {}\".format(e[0], e[1], e[2])))\n", "l = int(input())\nl -= 1\nto = [[] for _ in range(14)]\nfor i in range(1, 13):\n    to[i].append((i + 1, 0 * 3 ** (12 - i)))\n    to[i].append((i + 1, 1 * 3 ** (12 - i)))\n    to[i].append((i + 1, 2 * 3 ** (12 - i)))\nd = []\nl_upto = []\nt = l\ns = 0\nfor i in range(13):\n    d.append(t % 3)\n    s += (t % 3) * 3 ** i\n    l_upto.append(s)\n    t //= 3\n\nfor i, t in enumerate(d):\n    for s in range(t + (i == 0)):\n        to[0].append((13 - i, l - l_upto[i] + 3 ** i * s))\nprint((14, sum(map(len, to))))\nfor i in range(len(to)):\n    for j, cost in to[i]:\n        print((i + 1, j + 1, cost))\n\n", "def solve(l):\n    n = 0\n    while 2**n <= l:\n        n += 1\n    E = []\n    for i in range(n-1, -1, -1):\n        x = 2**i\n        if i != n-1:\n            E.append((i, i+1, 0))\n            E.append((i, i+1, x))\n        if l - x >= 2**(n-1):\n            E.append((i, n-1, l-x))\n            l -= x\n    print(n, len(E))\n    for u, v, x in E:\n        print(u+1, v+1, x)\n\nl = int(input())\nsolve(l)", "\nL = int(input())\n\ndigit = L.bit_length()  # \u5fc5\u8981\u306a\u30d3\u30c3\u30c8\u6570(\u9802\u70b9\u6570)\n\nif 2**digit > L :\n    digit -= 1\n\nans = []\nfor i in range(1, digit+1) :\n    ans.append([i, i+1, 0])\n    ans.append([i, i+1, 2**(i-1)])\n\nL = L - 2**digit  # \u6b8b\u308a\u672c\u6570\n\ntmp = 0\nfor i in range(digit, 0, -1) :\n    if L - 2**(i - 1) >= 0 :\n        ans.append([i, digit+1, 2**digit + tmp])\n        L -= 2**(i - 1)\n        tmp += 2**(i - 1)\n\nprint(digit+1, len(ans))\nfor a in ans :\n    print(*a)", "def main():\n    l=int(input())\n    n=1\n    while (1<<n)<=l:\n        n+=1\n    ans=[]\n    for i in range(n-1):\n        ans.append([i,i+1,0])\n        ans.append([i,i+1,1<<i])\n    l-=1<<(n-1)\n    val=1<<(n-1)\n    for p in range(n-2,-1,-1):\n        if l>=(1<<p):\n            ans.append([p,n-1,val])\n            val+=1<<p\n            l-=1<<p\n    print(n,len(ans))\n    for a,b,c in ans:\n        print(a+1,b+1,c)\nmain()", "L = int(input())\nN = L.bit_length()\n\nres = []\n\nfor i in range(N - 1):\n    res.append((i + 1, i + 2, 1 << i))\n    res.append((i + 1, i + 2, 0))\n\nn = 1 << (i + 1)\nm = L - n\n\nfor i in reversed(range(m.bit_length())):\n    if (m >> i) & 1:\n        m %= (1 << i)\n        res.append((i + 1, N, n))\n        n += (1 << i)\n\n\nprint(N, len(res))\n\nfor i in range(len(res)):\n    print(*res[i])", "L = t = int(input())\nX = []\nB = 4\nwhile L:\n    X.append(L%B)\n    L//=B\n\nE = []\nN = len(X)*2\nfor i, x in enumerate(X[:-1]):\n    r = B**i\n    t -= r*x\n    for k in range(0, x):\n        E.append((2*i+1, 2*i+2, r*k))\n\n    E.append((2*i+2, 2*i+3, 0))\n\n    for k in range(x, B):\n        E.append((2*i+1, 2*i+3, r*k))\n\n    E.append((2*i+2, N, t))\n\nfor k in range(0, X[-1]):\n    E.append((N-1, N, B**(len(X)-1)*k))\n\nprint(N, len(E))\nfor e in E:\n    print(*e)", "import math\n\n\nl = int(input())\nnode = int(math.log2(l)) + 1\nedges = []\n\nfor _from in range(1, node):\n    edges.append([_from, _from+1, 0])\n    edges.append([_from, _from+1, 2**(_from-1)])\n\ncount = 2 ** (node-1)\nlack = l - count\nlength = 2 ** (node-1)\n\nfor _from in range(node-1, 0, -1):\n    if not lack:\n        break\n    add_line = 2 ** (_from-1)\n    if add_line > lack:\n        continue\n    edges.append([_from, node, length])\n    lack -= add_line\n    length += add_line\n\nprint((node, len(edges)))\nfor _from, to, length in edges:\n    print((_from, to, length))\n", "import math\nL = int(input())\nr = math.floor(math.log2(L))\nN = r+1\ngraph = []\nfor i in range(1,r+1):\n    graph.append([i,i+1,0])\n    graph.append([i,i+1,2**(i-1)])\nfor t in range(N-1,0,-1):\n    if L-2**(t-1) >= 2**r:\n        graph.append([t,N,L-2**(t-1)])\n        L -= 2**(t-1)\n\nprint((N,len(graph)))\nfor g in graph:\n    print((*g))\n", "l=int(input())\nn=len(bin(l-1))-2 #\u9802\u70b9\u6570\nV=[]\nif all([(l-1)>>i&1 for i in range(n)]):\n    n+=1\n    for i in range(n-1):\n        V.append([i+1,i+2,0])\n        V.append([i+1,i+2,2**(n-i-2)])\n\n\nelse:\n    for i in range(n-1):\n        V.append([i+1,i+2,0])\n        V.append([i+1,i+2,2**(n-i-2)])\n\n    now=2**(n-1)\n    for i in range(n-2):\n        if (l-1)>>(n-i-2)&1:\n            V.append([1,i+2,now])\n            now+=2**(n-i-2)\n    if (l-1)&1:\n        V.append([1,n-1,now])\n    else:\n        V.append([1,n,now])\nprint(n,len(V))\nfor v in V:\n    print(*v)", "import sys\ninput = sys.stdin.readline\n\nL = int(input())\nans = [[1,2,0],[1,2,1]]#L=2\u306e\u7b54\u3048\nS=1\nT=2\ndef recursion(x):\n    nonlocal T\n    if x == 2:\n        return\n    \n    if x%2==1:\n        recursion(x-1)\n        ans.append([S,T,x-1])\n        \n    else:\n        recursion(x//2)\n        for i in range(len(ans)):\n            ans[i][2] = 2*ans[i][2]\n        T += 1\n        ans.append([T-1,T,0])\n        ans.append([T-1,T,1])\n    return\n\nrecursion(L)\nprint((T,len(ans)))\nfor i,j,k in ans:\n    print((i,j,k))\n        \n\n\n", "L = int(input())\n\nN = 1\nl = L\nwhile l // 2 >= 1:\n    N += 1\n    l //= 2\n\nG = [[] for _ in range(N + 1)]\n\nfor i in range(1, N):\n    G[i].append([i + 1, 0])\n    G[i].append([i + 1, 2 ** (N - 1 - i)])\n\nM = 2 * (N - 1)\ntmp = 2 ** (N - 1)\n\nfor i in range(N - 2, -1, -1):\n    if (L >> i) & 1:\n        G[1].append([N - i, tmp])\n        tmp += 2 ** i\n        M += 1\n\nif N > 20 or M > 60:\n    print ('error')\n\nprint (N, M)\nfor i in range(1, N):\n    for j in G[i]:\n        print (i, *j)", "L = int(input())\nN = L.bit_length()\n\nnode = [i for i in range(1, N + 1)]\nedge = []\n\nfor x, y in zip(node[:-1], node[1:]):\n    edge.append((x, y, 0))\n\nx = 1\nwhile L > 1:\n    if L & 1:\n        L -= 1\n        edge.append((x, N, L))\n    else:\n        L //= 2\n        edge.append((x, x + 1, L))\n        x += 1\n\nprint(N, len(edge))\nfor e in edge:\n    print(*e)", "L = int(input())\n\nN = L.bit_length()\n\nedges = [[] for _ in range(N)]\nfor i in range(N - 1):\n    edges[i].append((i + 1, 0))\n    edges[i].append((i + 1, 2**i))\n\nnow = 2**(N - 1)\n\nfor i in range(N - 1)[:: -1]:\n    cnt = 2**i\n    if L - now >= cnt:\n        edges[i].append((N - 1, now))\n        now += cnt\n\nM = sum(len(edges[i]) for i in range(N))\nprint(N, M)\n\nfor i in range(N):\n    for to, cost in edges[i]:\n        print(i + 1, to + 1, cost)", "L = int(input())\n\nN = L.bit_length()\n\nE = []\nfor i in range(1, N):\n    E.append((i, i + 1, 0))\n    E.append((i, i + 1, 2 ** (i - 1)))\n\ns = 2 ** (N - 1)\nfor i in reversed(list(range(N - 1))):\n    if (L >> i) & 1:\n        E.append((i + 1, N, s))\n        s += 2 ** i\n\nprint((N, len(E)))\nfor a, b, c in E:\n    print((a, b, c))\n", "# from https://atcoder.jp/contests/abc108/submissions/4342595\nimport math\n\n\ndef main():\n    l = int(input())\n    n = math.floor(math.log2(l)) + 1\n    e = []\n    for v in range(n-1):\n        v2 = 2 ** v\n        e.append([v + 1, v + 2, 0])\n        e.append([v + 1, v + 2, v2])\n        if (l >> v) & 1:\n            e.append([v + 1, n, l - v2])\n            l -= v2\n    print((n, len(e)))\n    for x in e:\n        print((*x))\n\n\nmain()\n", "from math import log2\nL=int(input())\nans=[]\ni=1\nwhile True:\n    if 2**i>L:\n        last=i\n        break\n    ans.append([i,i+1,2**(i-1)])\n    ans.append([i,i+1,0])\n    i+=1\n\"\"\"for i in ans:\n    print(i)\nprint(last)\"\"\"\nnum=2**(last-1)\na=L-num\nwhile a>0:\n    ans.append([int(log2(a))+1,last,num])\n    num+=2**(int(log2(a)))\n    a=L-num\nprint((last,len(ans)))\nfor i in ans:\n    print((*i))\n", "L=int(input())\n\nans = []\nm = 0\nadd = -1\nmask = 0xffffff\nfor i in range(24):\n    mask >>= 1\n    d = 24 - i - 1\n    if ((~mask) & L) != 0:\n        if add == -1:\n            n = d+1\n            add = 1 << d\n            b = 1\n            # [0, 2^d) \u306e\u7bc4\u56f2\n            for i in range(1,d+1):\n                ans.append(str(i) + \" \" + str(i+1) + \" 0\")\n                ans.append(str(i) + \" \" + str(i+1) + \" \" + str(b))\n                b *= 2\n                m += 2\n        else :\n            ans.append(str(d+1) + \" \" + str(n) + \" \" + str(add))\n            add += (1 << d)\n            m += 1\n        L &= mask\n#    print(\" \",d,L,mask)\nprint((n,m))\nfor i in ans:\n    print(i)\n\n", "L = int(input())\ndef digits_count(n):\n  cnt = 0\n  while n != 0:\n    cnt += 1\n    n //= 2\n  return cnt\ndef doubling(n, m):\n  y = 1\n  base = n\n  while m != 0:\n    if m % 2 == 1:\n      y *= base\n    base *= base\n    m //= 2\n  return y\nm = digits_count(L)\nA = [0 for _ in range(m)]\nfor i in range(m, 0, -1):\n  A[i-1] = L % 2\n  L //= 2\nbinomial = [1 for _ in range(m)]\nfor i in range(1, m):\n  binomial[i] = binomial[i-1] * 2\nvert = [[i*m+i+1, binomial[i]] for i in range(m-1)]\nvert = vert[:] + [[i*m+i+1, 0] for i in range(m-1)]\nS = doubling(2, m - 1)\nfor i in range(1, m):\n  if A[i] == 1:\n    vert.append([(m-i-1)*m+m-1, S])\n    S += binomial[m-i-1]\nprint(m, len(vert))\nfor i in vert:\n  print(i[0] // m + 1, i[0] % m + 1, i[1])", "L = int(input())\nv = list(map(int,bin(L)[:2:-1]))\nN = len(v)+1\nedges = []\nunit = 1\nfor i in range(N-1):\n    L -= unit*v[i]\n    edges.append((i+1, i+2, 0))\n    edges.append((i+1, i+2, unit))\n    if v[i]:\n        edges.append((i+1, N, L))\n    unit *= 2\n\nprint(N, len(edges))\nfor a, b, c in edges:\n    print(a, b, c)", "l = int(input())\n\nv_count = 1\nadditional_e = []\nwhile True:\n  if l == 1:\n    break\n  elif l%2 == 0:\n    l = l//2\n    v_count += 1 \n  elif l%2 == 1:\n    l -= 1\n    additional_e.append(v_count)\n\nprint((v_count, (v_count-1)*2 + len(additional_e)))\n\nfor i in range(1,v_count):\n  print((i, i+1, 0))\n  print((i, i+1, 2**(i-1)))\n\nnum = 2**(v_count-1)\n\nfor i in additional_e[::-1]:\n  print((i, v_count, num))\n  num = num + (2**(i-1))\n\n", "L = int(input())\nk = 1\npower = 4\nwhile L >= power:\n    k += 1\n    power *= 2\n\npower = 1\nans = []\nfor i in range(k):\n    ans.append([k-i, k+1-i, 0])\n    ans.append([k-i, k+1-i, power])\n    power *= 2\n\nN = k+1\nl = power\nrest = L - l\nwhile rest > 0:\n    power = 1\n    k = 0\n    while rest >= power * 2:\n        power *= 2\n        k += 1\n    ans.append([1, N-k, l])\n    l += power\n    rest -= power\n\nprint(*[N, len(ans)])\nfor i in ans:\n    print(*i)", "import sys\nsys.setrecursionlimit(100000000)\ndef input():\n    return sys.stdin.readline()[:-1]\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nfrom math import *\n\nL = int(input())\nn = int(log(L, 2))\nes = []\nm = min(n, 19)\nfor i in range(1, 20):\n    es.append((i, i+1, 0))\nfor i in range(m):\n    es.append((i+1, i+2, 1<<i))\nt = L-(1<<m)\nfor i in range(20):\n    if (t>>i) & 1:\n        L -= 1<<i\n        es.append((i+1, 20, L))\nprint((20, len(es)))\nfor u, v, c in es:\n    print((u, v, c))\n", "L = int(input())\nn = L.bit_length()\nans = []\nfor i in range(1,n):\n  ans.append((i,i+1,0))\n  ans.append((i,i+1,2**(n-i-1)))\nbinL = bin(L)\nfor i in range(1,n):\n  if binL[i+2] == \"1\":\n    mask = int(binL[:i+2],2)<<(n-i)\n    ans.append((1,i+1,L&mask))\nprint(n,len(ans))\nfor edge in ans:\n  print(*edge)", "#!/usr/bin/env python3\nimport sys\nfrom math import *\nfrom itertools import *\nfrom collections import *\nfrom functools import *\ntry:\n    from math import gcd\nexcept Exception:\n    from fractions import gcd\n\n\n\ndef solve(L: int):\n    r = 0\n    while (2 ** r) <= L:\n        r += 1\n    r -= 1\n\n    edges = []\n    nodes = list(range(1, r+2))\n    for s, d in zip(nodes, nodes[1:]):\n        edges.append((s, d, 0))\n        edges.append((s, d, 2 ** (s - 1)))\n\n    base = 2 ** r\n    for n in list(reversed(nodes))[1:]:\n        c = 2 ** (n - 1)\n        if base <= (L - c):\n            edges.append((n, nodes[-1], L - c))\n            L -= c\n    ret = ['{} {}'.format(r + 1, len(edges))]  + ['{} {} {}'.format(s, d, c) for s, d, c in edges]\n    return '\\n'.join(ret)\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    L = int(next(tokens))  # type: int\n    result = solve(L)\n    print(result)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "###############################################################################\n\nfrom sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\n\n\nmod = 1\n\n\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\n\n\ndef intina():\n    return [int(i) for i in input().split()]\n\n\ndef intinl(count):\n    return [intin() for _ in range(count)]\n\n\ndef modadd(x, y):\n    nonlocal mod\n    return (x + y) % mod\n\n\ndef modmlt(x, y):\n    nonlocal mod\n    return (x * y) % mod\n\n\ndef lcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\n\n\ndef combination(x, y):\n    assert(x >= y)\n\n    if y > x // 2:\n        y = x - y\n\n    ret = 1\n\n    for i in range(0, y):\n        j = x - i\n        i = i + 1\n\n        ret = ret * j\n        ret = ret // i\n\n    return ret\n\n\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\n\n\ndef get_factors(x):\n    retlist = []\n    for i in range(2, int(x**0.5) + 3):\n        while x % i == 0:\n            retlist.append(i)\n            x = x // i\n    retlist.append(x)\n    return retlist\n\n\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\n\n\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n\n    max_distance = -1\n    max_v = None\n    for v, distance in list(distance_list.items()):\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n\n    return (max_distance, max_v)\n\n\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\n\n\n###############################################################################\n\n\ndef main():\n    L = intin()\n\n    r = 0\n    while True:\n        if 2**(r+1) > L:\n            break\n        r += 1\n\n    n = r + 1\n\n    path_list = []\n    path_list.extend([(i + 1, i + 2, 0) for i in range(r)])\n    path_list.extend([(i + 1, i + 2, 2**i) for i in range(r)])\n\n    remain = L - 2**r\n    next = 2**r\n\n    for i in reversed(list(range(r))):\n        if remain >= 2**i:\n            path_list.append((i + 1, n, next))\n            remain -= 2**i\n            next += 2**i\n\n    print(('%d %d' % (n, len(path_list))))\n    for path in path_list:\n        print(('%d %d %d' % path))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\nimport math\n\nl = int(input())\n\nr = math.floor(math.log2(l))\n\nnum_vertex = 0\nnum_edge = 0\n\nnum_vertex += r+1\n\nprint_list = []\nfor i in range(r):\n    print_list.append([i+1, i+2, 0])\n    print_list.append([i+1, i+2, 2**i])\n    num_edge += 2\n\n\nfor i in reversed(list(range(r+1))):\n    if l-2**i >= 2**r:\n        print_list.append([i+1, r+1, l-2**i])\n        l -= 2**i\n        num_edge += 1\n\nprint((num_vertex, num_edge))\nfor i in print_list:\n    print((*i))\n", "L=int(input());n=len(str(bin(L)))-3;e=[];h=2**n\nfor i in range(1,n+1):\n  e+=[(i,i+1,0),(i,i+1,2**(n-i))]\n  if 2**(n-i)&L:e+=[(1,i+1,h)];h+=2**(n-i)\nprint(n+1,len(e))\nfor v in e:print(*v)", "n = int(input())\nans = []\ncount = 1\ntwo = 1\nfor i in range(20):\n    if two*2 <= n:\n        count += 1\n        ans.append([count-1,count,0])\n        ans.append([count-1,count,two])\n        two *= 2\n    else:\n        break\n\nfor i in range(count,0,-1):\n    if n - pow(2,i-1) >= two:\n        \n        ans.append([i,count,n-pow(2,i-1)])\n        n -= pow(2,i-1)\nprint((count,len(ans)))\nfor i in ans:\n    print((*i))\n", "l=int(input())\nd=l.bit_length()\ng=[]\nfor i in range(d-1):\n  g.append((i+1,i+2,0))\n  g.append((i+1,i+2,2**(d-i-2)))\ns=1<<(d-1)\nfor i in range(d-1)[::-1]:\n  if (1<<i)&l:\n    g.append((1,d-i,s))\n    s+=1<<i\nprint(d,len(g))\nfor u,v,c in g:\n  print(u,v,c)", "l = int(input())\nn = 0\nwhile 2**n <= l:\n  n += 1\np = []\nfor i in range(1, n):\n  p.append((i, i + 1, 0))\n  p.append((i, i + 1, 2**(i-1)))\n  if l // (2**(i-1)) % 2 == 1:\n    p.append((i, n, l // 2**i * 2**i))\nm = len(p)\nprint((n, m))\nfor i in p:\n  print((*i))\n", "L = int(input())\nN = L.bit_length()\nres = []\nfor i in range(N - 1):\n    res.append((i + 1, i + 2, 0))\n    res.append((i + 1, i + 2, 2**i))\nrem = L - 2**(N - 1) \nk = 2**(N - 1)\nfor i in range(rem.bit_length())[::-1]:\n    if (rem >> i) & 1:\n        res.append((i + 1, N, k))\n        k += 2**i\nprint(N, len(res))\nfor r in res:\n    print(*r)", "import math\n\nL = int(input())\n\nN = math.floor(math.log2(L)) + 1\n\nedge = []\nfor i in range(N - 1):\n  edge.append((i + 1, i + 2, 0))\n  edge.append((i + 1, i + 2, (1 << i)))\n\nfor i in range(N - 1, 0, -1):\n  if L - (1 << (i - 1)) >= 2 ** (N - 1):\n    edge.append((i, N, L - (1 << (i - 1))))\n    L -= (1 << (i - 1))\n\nprint(N, len(edge))\nfor e in edge:\n  print(str(e).lstrip('(').rstrip(')').replace(',', ''))", "l=int(input())\nk=l\ncnt=0\nwhile k>1:\n    k//=2\n    cnt+=1\nedge=[[] for _ in range(cnt)]\ne=2*cnt\nfor i in range(cnt):\n    edge[i].append((i+1,0))\n    edge[i].append((i+1,2**i))\nfor i in reversed(range(cnt)):\n    if l-2**i>=2**cnt:\n        edge[i].append((cnt,l-2**i))\n        l-=2**i\n        e+=1\nprint(cnt+1,e)\nfor i in range(cnt):\n    for j,d in edge[i]:\n        print(i+1,j+1,d)", "from itertools import dropwhile\nl=int(input())\nk=[(l>>i & 1) for i in range(20)][::-1]\nk=list(dropwhile(lambda x:x==0,k))\n#print(k)\nn=len(k)\npath=[]\nfor i in range(n-1):\n    path.append((i+1,i+2,0))\n    path.append((i+1,i+2,2**i))\n\npath_len=2**(n-1)\nfor i in range(1,n):\n    if k[i]:\n        x=n-1-i\n        path.append((x+1,n,path_len))\n        path_len+=(2**x)\n\nm=len(path)\nprint(n,m)\nfor i in path:\n    print(i[0],i[1],i[2])", "L = int(input())\n\npaths = []\nn = 2\nv = 1\nwhile n <= L:\n    paths.append((v, v+1, 0))\n    paths.append((v, v+1, n//2))\n    v += 1\n    n *= 2\nn //= 2\n\nvlast = v\nnn = n\nll = L - n\n\nwhile ll > 0:\n    if ll >= n:\n        paths.append((v, vlast, nn))\n        ll -= n\n        nn += n\n    n //= 2\n    v -= 1\n\nprint((vlast, len(paths)))\nfor e in paths:\n    print((*e))\n", "L = int(input())\nb = format(L, 'b')\nn = len(b)\nm = 2 * (n - 1) + b.count('1') - 1\nprint(n, m)\nfor i in range(1, n):\n    print(i, i + 1, 0)\n    print(i, i + 1, 2 ** (i - 1))\nw = 2 ** (n - 1)\nfor j in range(20,-1,-1):\n    if (L - w) >> j & 1:\n        print(j + 1, n, w)\n        w += 2 ** j", "l = int(input())\ns = bin(l)[2:]\nn = len(s)\nm = 0\nans = []\nfor i in range(n-1):\n    ans.append([i+1, i+2, 0])\n    ans.append([i+1, i+2, 2**(n-2-i)])\n    m += 2\nimp = 2**(n-1)\nfor i in range(n-1, 0, -1):\n    if s[i] == '1':\n        ans.append([1, i+1, imp])\n        m += 1\n        imp += 2 ** (n-1-i)\nprint(n, m)\nfor x in ans:\n    print(' '.join(list(map(str, x))))", "# D - All Your Paths are Different Lengths\n\nL = int(input())\n\nN = 2\nwhile 2**N-1 <= L-1:\n    N += 1\n\nedge = []\nfor i in range(1,N):\n    edge.append([i,i+1,0])\n    edge.append([i,i+1,2**(i-1)])\n\nfor i in reversed(range(1,N)):\n    if L - 2**(i-1) > 2**(N-1) - 1:\n        edge.append([i,N,L-2**(i-1)])\n        L = L-2**(i-1)\n\nprint(N, len(edge))\nfor x in edge:\n    print(*x)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# \u7d42\u4e86\u5f8c\u306b\u89e3\u8aac\u3092\u898b\u3066\u89e3\u3051\u305f\n# \u30d1\u30b9\u6570\u304c\uff12\u306e\u3079\u304d\u4e57\u3067\u3042\u308c\u3070\u7c21\u5358\u306b\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\u3067\u304d\u308b\u3053\u3068\u306b\u6c17\u4ed8\u304d\u305f\u304b\u3063\u305f\u3002\n#\n# \u672c\u756a\u4e2d\u306f\u300110\u9032\u6cd5\u3067\u8003\u3048\u3066 \u9802\u70b91\u3068\u9802\u70b92\u306e\u9593\u3092\u8fba{0, 100, 200, ..., 900}\u3067\u7e4b\u304e\u3001\u9802\u70b92\u3068\u9802\u70b93\u306e\u9593\u3092\u8fba{0, 10, ..., 90}\u3067\u7e4b\u304e\u3001\n# \u306a\u3069\u3068\u3044\u3046\u4e8b\u3092\u8003\u3048\u3066\u3044\u305f\u304c\u3001\u305d\u308c\u4ee5\u4e0a\u9032\u5c55\u3055\u305b\u308b\u3053\u3068\u304c\u96e3\u3057\u304b\u3063\u305f\u3002\n\n\nimport array\nfrom bisect import *\nfrom collections import *\nimport fractions\nimport heapq \nfrom itertools import *\nimport math\nimport random\nimport re\nimport string\nimport sys\n\nL = int(input())\n\nv = 1\nedges = []  # (from, to, cost)\n\n# L = 37\u306e\u5834\u5408\u3092\u4f8b\u306b\u3068\u308a\u30b3\u30e1\u30f3\u30c8\u3092\u4ed8\u4e0e\n# \u307e\u305a\u9577\u30550 ~ 31\u307e\u3067\u306e\u30d1\u30b9\u3092\u4f5c\u6210\u3059\u308b\u3002\n#   \u9802\u70b91 -> \u9802\u70b92\u30920\u306e\u8fba\u30681\u306e\u8fba\u3067\u7d50\u3076\n#   \u9802\u70b92 -> \u9802\u70b93\u30920\u306e\u8fba\u30682\u306e\u8fba\u3067\u7d50\u3076\n#   \u9802\u70b93 -> \u9802\u70b94\u30920\u306e\u8fba\u30684\u306e\u8fba\u3067\u7d50\u3076\n#   \u9802\u70b94 -> \u9802\u70b95\u30920\u306e\u8fba\u30688\u306e\u8fba\u3067\u7d50\u3076\n#   \u9802\u70b95 -> \u9802\u70b96\u30920\u306e\u8fba\u306816\u306e\u8fba\u3067\u7d50\u3076\nn = 2\ncost = 1\nwhile n <= L:\n    edges.append((v, v+1, 0))\n    edges.append((v, v+1, cost))\n    cost *= 2\n    v += 1\n    n *= 2\n\n# \u9802\u70b96\u3092v_sink(\u6700\u7d42\u5230\u9054\u70b9)\u3068\u3059\u308b\nv_sink = v\n\n# \u3053\u3053\u304b\u3089\u5148\u3001\u9577\u305532, 33, 34, 35, 36\u306e\u30d1\u30b9\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u3002\n# \u9802\u70b93\u3068\u9802\u70b96\u3092\u300132\u306e\u8fba\u3067\u76f4\u3067\u3064\u306a\u3050\u3068\u3001\u9577\u305532, 33, 34, 35\u306e\u30d1\u30b9\u304c\u4f5c\u308c\u308b\u3002\n# \u9802\u70b91\u3068\u9802\u70b96\u3092\u300136\u306e\u8fba\u3067\u76f4\u3067\u3064\u306a\u3050\u3068\u3001\u9577\u305536\u306e\u30d1\u30b9\u304c\u4f5c\u308c\u308b\u3002\nn //= 2\nN = n\nL -= N\n\nwhile L > 0:\n    if L >= n:\n        edges.append((v, v_sink, N))\n        L -= n\n        N += n\n    n //= 2\n    v -= 1\n\nprint(v_sink, len(edges))\nfor e in edges:\n    print(*e)", "# \u9802\u70b9\u306f0\u756a\u304b\u3089\u59cb\u307e\u308b\u3068\u3057\u3066\u3001\u51fa\u529b\u6642\u306b+1\u3059\u308b\ndef graph(L):\n    beki = 1\n    for n in range(20):\n        beki *= 2\n        if beki > L: break\n\n    ans = []\n    Li = 1\n    for i in range(n):\n        ans += [(i + 1, i + 2, 0)]\n        ans += [(i + 1, i + 2, Li)]\n        Li *= 2\n\n    Lnext = Li\n    nokori_kosu = L - Li\n    i = n - 1\n    way_i = Li // 2\n    while nokori_kosu > 0:\n        while way_i > nokori_kosu:\n            way_i //= 2\n            i -= 1\n        ans += [(i + 1, n + 1, Lnext)]\n        Lnext += way_i\n        nokori_kosu -= way_i\n    print((n + 1, len(ans)))\n    for x in ans:\n        print((*x))\n\n\nL = int(input())\ngraph(L)\n", "L = int(input())\n\n\nN = L.bit_length()\nans = []\nfor i in range(N - 1):\n    ans.append((i, i + 1, 0))\n    ans.append((i, i + 1, 2 ** (N - i - 2)))\n\n\nX = L - 2 ** (N - 1)\ndist = 2 ** (N - 1)\nfor i in reversed(list(range(X.bit_length()))):\n    if X & (1 << i):\n        ans.append((0, N - i - 1, dist))\n        dist += (2 ** i)\n\n\nprint((N, len(ans)))\nfor a, b, d in ans:\n    print((a + 1, b + 1, d))\n", "import math\nl = int(input())\n\n# l -= 1\nn = math.floor(math.log2(l)) + 1\nedge = []\nfor i in range(1, n):\n    edge.append((i, i+1, 0))\nfor j, i in enumerate(reversed(list(range(1, n)))):\n    edge.append((i, i+1, 2**j))\n\nl2 = l - 2**(n-1)\nc = 2**(n-1)\n# print(\"test\", c, l2)\nwhile l2 > 0:\n    l_mini = 1\n    while l_mini * 2 <= l2:\n        l_mini *= 2\n    # print(\"test\", c, l2, int(math.log2(l_mini)))\n    edge.append((1, n-int(math.log2(l_mini)), c))\n    l2 -= l_mini\n    c += l_mini\n\nprint((n, len(edge)))\nfor i in range(len(edge)):\n    print((*edge[i]))\n", "L = int(input())\nN = L.bit_length()\nres = []\nfor i in range(N - 1):\n  res.append((i + 1, i + 2, 0))\n  res.append((i + 1, i + 2, 2**i))\nrem = L - 2**(N - 1) \nk = 2**(N - 1)\nfor i in range(rem.bit_length())[::-1]:\n  if (rem >> i) & 1:\n    res.append((i + 1, N, k))\n    k += 2**i\nprint(N, len(res))\nfor r in res:\n  print(*r)", "import sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9 + 7\n\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list,zip(*read_all))\n\n#################\n\nL = I()\n\nN = math.floor(math.log2(L))+1\nM = 0\nedge = []\nfor i in range(N-1):\n    edge.append([i,i+1,0])\n    edge.append([i,i+1,2**i])\n    M += 2\nfor i in range(N-1)[::-1]:\n    if L-2**i >= 2**(N-1):\n        edge.append([i,N-1,L-2**i])\n        M += 1\n        L -= 2**i\n\nprint(N,M)\nfor e in edge:\n    print(e[0]+1, e[1]+1, e[2])", "#import math\nL = int(input())\n#r = math.floor(math.log2(L))\nr = L.bit_length()-1\nN = r+1\ngraph = []\nappend = graph.append\nfor i in range(1,r+1):\n    append([i,i+1,0])\n    append([i,i+1,2**(i-1)])\n\nfor t in range(N-1,0,-1):\n    if L-2**(t-1) >= 2**r:\n        append([t,N,L-2**(t-1)])\n        L -= 2**(t-1)\n\nprint((N,len(graph)))\nfor g in graph:\n    print((*g))\n", "l = int(input())\nn = l.bit_length()\nedge = list()\nfor i in range(1,n):\n  edge.append((i,i+1,0))\n  edge.append((i,i+1,1<<(i-1)))\nt = l - (1<<(n-1))\ncnt = (n-1)*2\nwhile t:\n  m = t.bit_length()\n  edge.append((m,n,l-t))\n  t -= (1<<m-1)\n  cnt += 1\nprint(n,cnt)\nfor t in edge:\n  print(*t)", "# D - All Your Paths are Different Lengths\n\nL = int(input())\nr = 0\nwhile pow(2, r+1) <= L:\n    r += 1\n\nN = r + 1 \n\nedge = []\nfor i in range(N-1): \n    edge.append((i+1, i+2, 0))\n    edge.append((i+1, i+2, pow(2, i)))\n\nM = r * 2\nremain = L - pow(2, r)\n\nfor i in range(N-1)[::-1]:\n    if remain < pow(2, i):\n        continue\n    else:\n        edge.append((i+1, N, L-remain))\n        M += 1\n        remain -= pow(2, i)\n\nprint(N, M)\nfor e in edge:\n    print(' '.join(map(str, e)))", "l = int(input())\nn = len(bin(l)) - 3\ntmp = 2 ** n\nprint((n + 1, 2 * n + bin(l)[3:].count('1')))\nfor i in range(n):\n    print((i+1, i+2, 0))\n    print((i+1, i+2, 2 ** i))\n    if l & (1<<i):\n        print((i+1, n+1, tmp))\n        tmp += 2 ** i\n\n", "#18:55\nl = int(input())\ns = bin(l)[2:]\nn = len(s)\nm = 0\nans = []\nfor i in range(n-1):\n  ans.append([i+1,i+2,0])\n  ans.append([i+1,i+2,2**(n-2-i)])\n  m += 2\n#print(ans,m)\nimp = 2 ** (n-1)\nfor i in range(n-1,0,-1):\n  if s[i] == '1':\n    ans.append([1,i+1,imp])\n    m += 1\n    imp += 2 ** (n-1-i)\nprint(n,m)\nfor x in ans:\n  print(' '.join(list(map(str,x))))", "L = int(input())\nr = 0\nanswer = []\n\nwhile 2**r <= L:\n    r += 1\nN = r\n\nfor i in range(1,r):\n    answer.append([i,i+1,0])\n    answer.append([i,i+1,2**(i-1)])\n\n\nfor t in range(N-1,0,-1):\n    if L - 2**(t-1) >= 2**(r-1):\n        answer.append([t,N,L-2**(t-1)])\n        L -= 2**(t-1)\n\nanswer.insert(0,[N,len(answer)])\n\nfor ans in answer:\n    print(*ans)", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    L = int(input())\n\n    Lstr = bin(L)[2:]\n\n    N = len(Lstr)\n    M = (N - 1) * 2 + (Lstr.count(\"1\") - 1)\n\n    print((N, M))\n    c = 1\n    for i in range(1, N):\n        print((i, i + 1, c))\n        print((i, i + 1, 0))\n        c *= 2\n\n    c = 2 ** (N - 1)\n    for i, v in enumerate(Lstr[::-1]):\n        if i == N - 1:\n            continue\n        if v == \"1\":\n            print((i + 1, N, c))\n            c += 2 ** i\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def in_list(l, l_t, a):\n    l[a] = l_t\n\n\nans_list = [[] for _ in range(60)]\np = 0\n\nl = int(input())\nbin_str = format(l, '020b')\nfor i in range(20):\n    c = 0\n    if c == 0 and str(bin_str)[i] == '1':\n        c = 1\n        n = 20-i\n        k = i\n        break;\nfor j in range(1, n):\n    in_list(ans_list, [j, j+1, 0], p)\n    p += 1\n    in_list(ans_list, [j, j+1, 2**(n-1-j)], p)\n    p += 1\nc = 2**(n-1)\n\nfor m in range(k+1, 20):\n    if str(bin_str[m]) == '1':\n        in_list(ans_list, [1, n+m-20+1, c], p)\n        p += 1\n        c += 2 ** (19-m)\n\nprint(n, p)\nfor q in range(p):\n    print(ans_list[q][0], ans_list[q][1], ans_list[q][2])", "L = int(input())\nfor i in range(21):\n    if 2**i > L:\n        r = i-1\n        break\n        \nN = r+1\nans = []\nfor i in range(1, N):\n    ans.append([str(i), str(i+1), str(2**(i-1))])\n    ans.append([str(i), str(i+1), str(0)])\n\nt = N-1\nwhile t >= 1:\n    if L-2**(t-1) >= 2**r:\n        ans.append([str(t), str(N), str(L-2**(t-1))])\n        L -= 2**(t-1)\n    t -= 1\n        \nprint(N, len(ans))\nfor i in range(len(ans)):\n    print(\" \".join(ans[i]))", "L = int(input())\nv = 1\nedges = []\nn = 2\ncost = 1\nwhile n <=L:\n    edges.append((v,v+1,0))\n    edges.append((v,v+1,cost))\n    cost *=2\n    v += 1\n    n*=2\ngoal = v\nn //=2\nN = n\nL-=N\nwhile L>0:\n    if L>=n:\n        edges.append((v,goal,N))\n        L-=n\n        N+=n\n    n //=2\n    v-=1\nprint(goal,len(edges))\nfor e in edges:\n    print(*e)", "import math\nL=int(input())\n\nN=int(math.log(L,2))\n\nprint(N+1,bin(L)[3:].count(\"1\")+2*N)\n\n\nfor i in range(1,N+1):\n    print(i,i+1,0)\n    print( i, i+1 , 2**(i-1) )\n\n\ntmp=2**N\nfor i in range(N,0,-1):\n    if tmp+2**(i-1)-1<=L-1:\n        print(i,N+1,tmp)\n        tmp=tmp+2**(i-1)", "L = int(input())\nN = len(str(bin(L)))-3\nE = []\n\nfor n in range(N):\n  E.append((n+1,n+2,0))\n  E.append((n+1,n+2,2**(N-n-1)))\n  \nH = 2**N\n\nfor i,c in enumerate(str(bin((L)))[2:]):\n    if c==\"1\" and i:\n      E.append((1,i+1,H))\n      H+=2**(N-i)\n\nprint((N+1,len(E)))\nfor e in E:\n  print((*e))\n", "L = int(input())\n\nN = len(bin(L)[2:])\nM = 2*(N-1) + bin(L)[3:].count(\"1\")\nprint(N, M)\n\nfor i in range(1, N):\n  print(i, i+1, 0)\n  print(i, i+1, 2**(i-1))\n\ntemp = L\nfor i in range(1, N):\n  if bin(L)[-i] == \"1\":\n    print(i, N, temp-2**(i-1))\n    temp -= 2**(i-1)", "L = int(input())\n\nN = len(str(bin(L)))-2\n\nbitL = [0] *20\nsplitL  = [0] * 20\nsumL = [0] * 20\n\nfor i in range(19,-1,-1):\n  if L % 2 == 1:\n    bitL[i] = 1\n  L = L // 2\n\nfor i in range(19,-1,-1):\n  splitL[i] = int(bitL[i]) * 2**(19-i)\n\nfor i in range(20):\n\n  if i == 0:\n    sumL[i] = splitL[i]\n  else:\n    sumL[i] =splitL[i]+sumL[i-1]\n\n#print(splitL)\n#print(sumL)\n#print(bitL)\n\nedge = []\n \nfor i in range(N-1):\n  edge.append([i+1,i+2,0])\n  edge.append([i+1,i+2,2**i])\n\n\nfor i in range(21-N,20):\n  if bitL[i] == 1:\n    edge.append([20-i,N,sumL[i-1]])\n\n\nprint(N,len(edge))\n\nfor i in range(len(edge)):\n  print(edge[i][0],edge[i][1],edge[i][2])", "\nfrom collections import deque\nL = int(input())\n\nLbin = (bin(L)[2:])[::-1]\nN = len(Lbin)\nM = 0\nE = deque()\n\nfor i in range(0, N - 1):\n    E.append(((i + 1, i + 2), 0))\n    E.append(((i + 1, i + 2), 2 ** i))\n    M += 2\n\nweight = L\nfor i in range(0, N - 1):\n    if Lbin[i] == '1':  # 2^i\u306e\u4f4d\n        weight -= 2 ** i\n        E.append(((i + 1, N), weight))\n        M += 1\n\nprint((N, M))\nfor e in E:\n    print((e[0][0], e[0][1], e[1]))\n", "from math import log2,floor\nL = int(input())\nans = []\n\nr = floor(log2(L))\n\nfor i in range(r):\n    ans.append('{} {} {}'.format(i+1,i+2,0))\n    ans.append('{} {} {}'.format(i+1,i+2,2**i))\n\nfor t in range(r-1,-1,-1):\n    if 2**r <= L-2**t:\n        ans.append('{} {} {}'.format(t+1,r+1,L-2**t))\n        L -= 2**t\n\nprint('{} {}'.format(r+1,len(ans)))\nfor s in ans:\n    print(s)", "n=int(input())\ncnt=0\nwhile 2**cnt-1<n:\n  cnt+=1\ncnt-=1\ngraph=[]\nfor i in range(cnt):\n  graph.append((1+i,2+i,2**i))\n  graph.append((1+i,2+i,0))\nexistmax=2**cnt-1\nfor i in range(1,cnt+1)[::-1]:\n    if 2**(i-1)-1+existmax+1<=n-1:\n        graph.append((i,cnt+1,existmax+1))\n        existmax=existmax+1+2**(i-1)-1\nL=len(graph)\nprint((cnt+1,L))\nfor i in graph:\n  print((*i))\n", "def main():\n    L = int(input())\n    n = 1\n    while 2**n <= L:\n        n += 1\n    n -= 1\n    ans = []\n    for i in range(1, n+1):\n        ans.append([i, i+1, 0])\n        ans.append([i, i+1, 2**(i-1)])\n    for i in reversed(range(1, n+1)):\n        if L-2**(i-1) >= 2**n:\n            ans.append([i, n+1, L-2**(i-1)])\n            L -= 2**(i-1)\n    print(n+1, len(ans))\n    for u, v, w in ans:\n        print(u, v, w)\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nl=int(input())\nn=int(math.log2(l)+1)\nE=[]\nfor i in range(n-1):\n    E.append([i+1,i+2,0])\n    E.append([i+1,i+2,2**i])\ni=n-2\nwhile l>2**(n-1):\n    t=l-2**i\n    if t>2**(n-1)-1:\n        E.append([i+1,n,t])\n        l=t\n    i-=1\nprint((n,len(E)))\nfor i in range(len(E)):\n    print((*E[i]))\n", "L=int(input())\nl=0\npp=0\ntmp=L\nwhile tmp>0:l+=1;pp+=tmp%2;tmp//=2\nprint(l,l*2-3+pp)\nfor i in range(1,l):\n  print(i,i+1,0)\n  a=1<<(i-1)\n  print(i,i+1,a)\n  if L&a:L-=a;print(i,l,L)", "L=int(input())-1\nfor i in range(1,21):\n    if 2**i>L+1:\n        N=i\n        break\nM=2*(N-1)\nl=[]\nfor i in range(1,N):\n    l.append((i,i+1,2**(i-1)))\n    l.append((i,i+1,0))\nL-=2**(N-1)-1\nt=2**(N-1)\nfor i in range(N-1,-1,-1):\n    if 2**i<=L:\n        l.append((i+1,N,t))\n        L-=2**i\n        t+=2**i\n        M+=1\nprint(N,M)\nfor i in l:\n    print(*i)", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    L = int(input())\n    edges = []\n    vertex = 1\n    flag = True\n    before = -1\n    for i in range(19,-1,-1):\n        if (L>>i)&1:\n            if flag:\n                flag = False\n                vertex = i + 1\n                for j in range(1,vertex):\n                    edges.append((j,j + 1,0))\n                    edges.append((j,j + 1,1<<(j - 1)))\n                before = 1<<i\n            else:\n                edges.append((i + 1,vertex,before))\n                before += 1<<i\n    print(vertex,len(edges))\n    for t in edges:\n        print(*t)\ndef __starting_point():\n    main()\n__starting_point()", "import math\nl=int(input())-1\nn=int(math.log2(l+1)+1)\nE=[]\nfor i in range(n-1):\n    E.append([i+1,i+2,0])\n    E.append([i+1,i+2,2**i])\ni=n-2\nwhile l>2**(n-1)-1:\n    t=l-2**i+1\n    if t>2**(n-1)-1:\n        E.append([i+1,n,t])\n        l=t-1\n    i-=1\nprint(n,len(E))\nfor i in range(len(E)):\n    print(*E[i])", "L = int(input())\n\nN = L.bit_length()\nn = []\nfor i in range(1, N):\n    n += [[i, i + 1, 0], [i, i + 1, 2**(i - 1)]]\nv = 2**(N - 1) - 1\nwhile L - 1 - v > 0:\n    b = min(N - 1, (L - 1 - v).bit_length())\n    n += [[b, N, v + 1]]\n    v += 2**(b - 1)\nM = len(n)\nprint((N, M))\nfor _ in n:\n    print((*_))\n", "l = int(input())\n# l = 1000000\nr = 1\nwhile 2 ** r <= l:\n    r += 1\nr = min(19, r - 1)\n# print(r)\n\nn = r + 1\n# print(n)\n\nts = [i for i in range(1, n)]\nts.reverse()\n# print(ts)\n\nm = (n - 1) * 2\n\npoints = {}\n\nfor t in ts:\n    a = l - 2 ** (t - 1)\n    b = 2 ** r\n    if a >= b:\n        points[t] = a\n        l -= 2 ** (t - 1)\n\nm += len(points)\nprint((n, m))\nfor i in range(1, (n - 1) * 2 + 1):\n    p = (i - 1) // 2 + 1\n    if i % 2 == 0:\n        print((p, p + 1, 0))\n    else:\n        print((p, p + 1, 2 ** (p - 1)))\n\nfor k in list(points.keys()):\n    print((k, n, points[k]))\n", "from math import log2\n\nL = int(input())\nn = int(log2(L))\nprint((n + 1, format(L, \"b\").count(\"1\") - 1 + 2 * n))\nLi = 1\nfor i in range(n):\n    print((i + 1, i + 2, 0))\n    print((i + 1, i + 2, Li))\n    Li *= 2\nmask = 2\nfor i in range(n):\n    if L >> i & 1:\n        print((i + 1, n + 1, L - (L & mask - 1)))\n    mask *= 2\n", "import sys\nimport math\n\ninput_methods=['clipboard','file','key']\nusing_method=1\ninput_method=input_methods[using_method]\n\ntin=lambda : list(map(int, input().split()))\nlin=lambda : list(IN())\nmod=1000000007\n\n#+++++\n\ndef main():\n\tL = int(input())\n\t#b , c = tin()\n\t#s = input()\n\tv = int(math.log2(L))\n\t#pa(v)\n\tnum_p = v\n\tpath_info=[]\n\tfor i in range(v):\n\t\tpath_info.append([i,i+1,0])\n\t\tpath_info.append([i,i+1,2**i])\n\t\n\t#for li in path_info:\n\t#\tprint(*li)\n\t\n\tnokori = L - (2 ** v)\n\t\n\t#print(nokori)\n\tfor i in range(v+1):\n\t\tm = v - i\n\t\tif 2 ** m <= nokori:\n\t\t\tpath_info.append([m, v, L - nokori])\n\t\t\tnokori -= 2 ** m\n\tprint((v+1, len(path_info)))\n\tfor l in path_info:\n\t\tf,t,w = l\n\t\tprint((*[f+1, t+1, w]))\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n\n__starting_point()"]
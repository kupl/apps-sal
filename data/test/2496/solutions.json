["from math import gcd\n\nN = int(input())\nnum_lis = list(map(int, input().split()))\nc = True\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(2*p, max_num+1, p):\n        if lis[q] == q:\n          lis[q] = p\n    p += 1\n  return lis\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  print(\"not coprime\")\n  return\n\nd_lis = osa_k(10**6+10)\ntmp = set()\nfor i in num_lis:\n  num = i\n  new_tmp = set()\n  while num > 1:\n    d = d_lis[num]\n    new_tmp.add(d)\n    num //= d\n  for j in new_tmp:\n    if j in tmp:\n      c = False\n      break\n    else:\n      tmp.add(j)\n  else:\n    continue\n  break\n\nif c:\n  print(\"pairwise coprime\")\nelse:\n  print(\"setwise coprime\")", "n=int(input())\nl=list(map(int,input().split()))\nm=max(l)\n\nfrom math import gcd\ng=gcd(l[0],l[1])\nfor i in range(2,n):\n  g=gcd(g,l[i])\nif g!=1:\n  print('not coprime')\n  return\n\nprime=[True]*(m+1)\nprime[0]=False\nprime[1]=False\nd=[0]*(m+1)\nfor i in range(2,int(m**0.5)+1):\n  if prime[i]:\n    for j in range(i*2,m+1,i):\n      prime[j]=False\n      d[j]=i\ns=[i for i in range(m+1) if prime[i]]\nfor ss in s:\n  d[ss]=ss\n\nsl=set()\nfor i in range(n):\n  div=set()\n  ll=l[i]\n  while ll>1:\n    div.add(d[ll])\n    ll//=d[ll]\n  div=list(div)\n  for dd in div:\n    if dd not in sl:\n      sl.add(dd)\n    else:\n      print('setwise coprime')\n      return\n\nprint('pairwise coprime')", "import sys\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\ndef gcd(x, y):\n    if x == 0:\n        return y\n    else:\n        return gcd(y % x, x)\n\n\ninput()\nA = LI()\n\ng = 0\nfor a in A:\n    g = gcd(g, a)\nif g != 1:\n    print(\"not coprime\")\n    return\n\nsosudayo = [True] * 1100000\nsosudayo[0] = False\nsosudayo[1] = False\nfor i in range(2, 1100000):\n    if not sosudayo[i]:\n        continue\n    for j in range(i*i, 1100000, i):\n        sosudayo[j] = False\n\nused = [False] * 1100000\nsosu = [a for a in A if sosudayo[a]]\nfor i in sosu:\n    used[i] = True\nruto_sosu = [a for a in range(1100) if sosudayo[a]]\nnot_sosu = [a for a in A if not sosudayo[a]]\n\nfor i in not_sosu:\n    for j in ruto_sosu:\n        if i == 1:\n            break\n        if i % j != 0:\n            continue\n        if used[j]:\n            print(\"setwise coprime\")\n            return\n        used[j] = True\n        while i % j == 0:\n            i //= j\n    if i > 1:\n        if used[i]:\n            print(\"setwise coprime\")\n            return\n        used[i] = True\n\nprint(\"pairwise coprime\")\n", "import sys\nfrom math import gcd\ninput = lambda: sys.stdin.readline().rstrip()\nn = int(input())\nA = list(map(int, input().split()))\nnowgcd = A[0]\n# \u5168\u4f53\u306eGCD\u3092\u53d6\u308b\nfor i in A:\n    nowgcd = gcd(nowgcd, i)\nif nowgcd != 1:\n    print('not coprime')\n    return\n\n# osa_k\u6cd5\u3067\u524d\u51e6\u7406\nMAXN = 10**6 + 5\nsieve = [i for i in range(MAXN + 1)]\np = 2\nwhile p * p <= MAXN:\n    # \u307e\u3060\u30c1\u30a7\u30c3\u30af\u3055\u308c\u3066\u3044\u306a\u3044\u306a\u3089\n    if sieve[p] == p:\n        # \u6b21\u306eq\u306e\u500d\u6570\u304b\u3089p\u523b\u307f\u3067\u30c1\u30a7\u30c3\u30af\u5165\u308c\u3066\u3044\u304f\n        for q in range(2 * p, MAXN + 1, p):\n            if sieve[q] == q:\n                sieve[q] = p\n    p += 1\n\ncheck = set()\nfor a in A:\n    tmp = set()\n    while (a > 1):\n        tmp.add(sieve[a])\n        a //= sieve[a]\n    for p in tmp:\n        if p in check:\n            print('setwise coprime')\n            return\n        check.add(p)\nprint('pairwise coprime')\n", "#\u9ad8\u901f\u7d20\u56e0\u6570\u5206\u89e3  osa_k\u6cd5 \ndef osa_k(a):\n    tmp = set()\n    while a > 1:\n        tmp.add(sieve[a])\n        a //= sieve[a]\n    return tmp\n\n    # \u521d\u671f\u5165\u529b\nimport math\nimport sys\nfrom bisect import bisect_left\nfrom functools import reduce\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nN = int(input())\nA = list(map(int, input().split()))\nused =set()\n\n#not coprime\u306e\u5224\u5b9a\ngcd_a =reduce(math.gcd,A)\nif gcd_a !=1:\n    ans =\"not coprime\"\n\n#pairwise coprime\u306e\u5224\u5b9a\nelse:\n    MAXN =10**6 +10\n    #osa_k\u6cd5\n    sieve = [i for i in range(MAXN+1)]\n    p = 2\n    while p*p <= MAXN:\n        if sieve[p] == p:\n            for q in range(2*p,MAXN+1,p):\n                if sieve[q] == q:\n                    sieve[q] = p\n        p += 1\n    \n    ans =\"pairwise coprime\"\n    for a in A:\n        aa =osa_k(a)\n        if used & aa:\n            ans =\"setwise coprime\"\n            break #\u5171\u901a\u8981\u7d20\u304c\u3042\u3063\u305f\u3089pair_w\u3067\u306f\u306a\u3044\u2192set_w\n        used |=aa\n    \nprint(ans)", "N=int(input())\nfrom math import gcd\nfrom functools import reduce\nl=list(map(int,input().split()))\nsw=0\nc=[0]*1000001\nfor i in l:\n   c[i]+=1\nif all(sum(c[i::i])<=1 for i in range(2,1000001)):\n   print(\"pairwise coprime\")\nelif reduce(gcd,l)==1:\n   print(\"setwise coprime\")\nelse:\n   print(\"not coprime\")", "def gcc(x, y):\n    if x == 0:return y\n    return gcc(y % x, x)\n\nN = int(input())\nA = list(map(int, input().split()))\n\ng = 0\n\nA.sort()\n\nfor item in A:\n    g = gcc(g, item)\n\nif g != 1:\n    print(\"not coprime\")\n    return\n\nprimes = []\n\nis_prime = [True] * 1100000\n\nis_prime[0] = is_prime[1] = False\n\nfor i in range(2, 1100000):\n    if not is_prime[i]:continue\n    for j in range(i*i, 1100000, i):\n        is_prime[j] = False\n\nA_prime = [item for item in A if is_prime[item]]\nA_notprime = [item for item in A if not is_prime[item]]\n\nprimes = [p for p in range(1100) if is_prime[p]]\nused = [False] * 1100000\n\nfor item in A_prime:\n    used[item] = True\n\nfor a in A_notprime:\n    for p in primes:\n        if a == 1:break\n        if a % p != 0:continue\n\n        if used[p]:\n            print(\"setwise coprime\")\n            #\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\uff08\u5171\u901a\u7d20\u56e0\u6570p\u3067\u5272\u308c\u308b\uff09\u30da\u30a2\u304cA\u306e\u4e2d\u306b\u3042\u308b\u3068\uff0c\u305d\u308c\u306fsetwise_coprime\n            return\n\n        used[p] = True\n\n        while a % p == 0:\n            a //= p\n\n    if a > 1:\n        if used[a]:\n            print(\"setwise coprime\")\n            return\n        used[a] = True\n\n\nprint(\"pairwise coprime\")", "from math import gcd\nN = int(input())\nA = list(map(int, input().split()))\nMA = 10**6+10\n\ng = 0\nfor a in A:\n    g = gcd(g, a)\nif g > 1:\n    print('not coprime')\n    return\n\nsieve = [i for i in range(MA+1)]\np = 2\nwhile p*p <= MA:\n    if sieve[p] == p:\n        for q in range(2*p, MA+1, p):\n            if sieve[q] == q:\n                sieve[q] = p\n    p += 1\nprim = set()\nfor a in A:\n    tmp = set()\n    while a > 1:\n        tmp.add(sieve[a])\n        a //= sieve[a]\n    for t in tmp:\n        if t in prim:\n            print('setwise coprime')\n            return\n        prim.add(t)\n\nprint('pairwise coprime')\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\npairwise_coprime = True\nuse_divnum = set()\nfor i in range(N):\n    k = A[i]\n    while k != 1:\n        if D[k] in use_divnum:\n            pairwise_coprime = False\n            break\n        else:\n            use_divnum.add(D[k])\n        div = D[k]\n        while k % div == 0 and k > 1:\n            k = k // div\nif pairwise_coprime: \n    print(\"pairwise coprime\")\n    return\nfrom math import gcd\ngcd_of_a = A[0]\nfor i in range(N):\n    gcd_of_a = gcd(gcd_of_a, A[i])\nif gcd_of_a == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\npairwise_coprime = True\nuse_divnum = set()\nfor k in A:\n    while k != 1:\n        if D[k] in use_divnum:\n            pairwise_coprime = False\n            break\n        else:\n            use_divnum.add(D[k])\n        div = D[k]\n        while k % div == 0 and k > 1:\n            k = k // div\n\nif pairwise_coprime:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "from math import gcd\nfrom functools import reduce\nN=int(input())\nA=list(map(int,input().split()))\n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\nl=primes(max(A))\nd=[0]*max(A)\nfor i in A:\n  d[i-1]=1\nif reduce(gcd,A)>1:\n  print('not coprime')\nelif all(sum(d[i-1::i])<=1 for i in l):\n    print('pairwise coprime')\nelse:print('setwise coprime')", "import fractions\n\nN = int(input())\nA = list(map(int, input().split()))\nD = [i for i in range(10**6+1)]\na_gcd = 0\nfor a in A:\n  a_gcd = fractions.gcd(a, a_gcd)\nif a_gcd > 1:\n  print('not coprime')\n  return\n\nfor i in range(2, 10**3+1):\n  if D[i] == i:\n    for n in range(i, 10**6+1, i):\n      if D[n] == n:\n        D[n] = i\n\np_set = set()\nfor a in A:\n  d_set = set()\n  while a > 1:\n    if not D[a] in d_set:\n      if D[a] in p_set:\n        print('setwise coprime')\n        return\n      p_set.add(D[a])\n      d_set.add(D[a])\n    a //= D[a]\nprint('pairwise coprime')\n", "N = int(input())\nA = list(map(int, input().split()))\n\n\n# number_to_prime[i]: i \u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570, i\u304c\u7d20\u6570\u306a\u3089\u30700\nnumber_to_prime = [0] * (10**6 + 1)\n\n# preprocess\nfor i in range(2, 10**6+1):\n    if not number_to_prime[i]:\n        j = 1\n        while j*i <= 10**6:\n            number_to_prime[j*i] = i\n            j += 1\n\ndef is_pair_copr(A):\n    import numpy as np\n    U = 1 << 20\n    div_p = np.arange(U)\n    for p in range(2, U):\n        if div_p[p] != p:\n            continue\n        div_p[p::p] = p\n    used = np.zeros(U, np.bool_)\n \n    for x in A:\n        while x > 1:\n            p = div_p[x]\n            while x % p == 0:\n                x //= p\n            if used[p]:\n                return False\n            used[p] = True\n    return True\n\ndef is_pairwise():\n    used_primes = set()\n    pairwise_flag = 1\n    for a in A:\n        curr_primes = set()\n        while a > 1:\n            prime = number_to_prime[a]\n            curr_primes.add(prime)\n            a //= prime\n        if used_primes & curr_primes:\n            pairwise_flag = 0\n            break\n        else:\n            used_primes = used_primes | curr_primes\n    return pairwise_flag\n\ndef is_setwise(*A):\n    import math\n    from functools import reduce\n\n    return reduce(math.gcd, A) == 1\n\nif is_pair_copr(A):\n    print(\"pairwise coprime\")\nelif is_setwise(*A):\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")", "from math import gcd\n\nN = int(input())\nnum_lis = list(map(int, input().split()))\nc1 = True #setwise\nc2 = True #pairwise\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(2*p, max_num+1, p):\n        if lis[q] == q:\n          lis[q] = p\n    p += 1\n  return lis\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  c1 = False\n\nif c1:\n  d_lis = osa_k(max(num_lis))\n  tmp = set()\n  for i in num_lis:\n    num = i\n    new_tmp = set()\n    while num > 1:\n      d = d_lis[num]\n      new_tmp.add(d)\n      num //= d\n    for j in new_tmp:\n      if j in tmp:\n        c2 = False\n        break\n      else:\n        tmp.add(j)\n    else:\n      continue\n    break\nelse:\n  c2 = False\n\nif c2:\n  print(\"pairwise coprime\")\nelif c1:\n  print(\"setwise coprime\")\nelse:\n  print(\"not coprime\")", "n = int(input())\nA = list(map(int, input().split()))\n\nmaxV = (10 ** 6 + 1)\n\nsieve = [i for i in range(maxV)]\np = 2\n\nwhile p*p < maxV:\n    if sieve[p] == p:\n        for q in range(p*2, maxV, p):\n            if sieve[q] == q:\n                sieve[q] = p\n    p += 1\n\nfrom math import gcd\n\ng = 0\nprimes = set()\nfor a in A:\n    g = gcd(g, a)\n\n    v = a\n\n\nif g > 1:\n    print('not coprime')\n    return\n\nfor a in A:\n    temp_prime = set()\n    while a > 1:\n        prime = sieve[a]\n        temp_prime.add(prime)\n        a = a // prime\n\n    for t in temp_prime:\n        if t in primes:\n            print('setwise coprime')\n            return\n        primes.add(t)\n\nprint('pairwise coprime')", "import sys\nfrom math import gcd\n\n\ndef osa_k(sieve, MAXN):\n    p = 2\n    while p * p <= MAXN:\n        # \u307e\u3060\u30c1\u30a7\u30c3\u30af\u3055\u308c\u3066\u3044\u306a\u3044\u306a\u3089\n        if sieve[p] == p:\n            # \u6b21\u306eq\u306e\u500d\u6570\u304b\u3089p\u523b\u307f\u3067\u30c1\u30a7\u30c3\u30af\u5165\u308c\u3066\u3044\u304f\n            for q in range(2 * p, MAXN + 1, p):\n                if sieve[q] == q:\n                    sieve[q] = p\n        p += 1\n\n\ninput = lambda: sys.stdin.readline().rstrip()\nn = int(input())\nA = list(map(int, input().split()))\nnowgcd = A[0]\n# \u5168\u4f53\u306eGCD\u3092\u53d6\u308b\nfor i in A:\n    nowgcd = gcd(nowgcd, i)\nif nowgcd != 1:\n    print('not coprime')\n    return\n\nMAXN = 10**6 + 5\nsieve = [i for i in range(MAXN + 1)]\np = 2\nosa_k(sieve, MAXN)\n\ncheck = set()\nfor a in A:\n    tmp = set()\n    while (a > 1):\n        tmp.add(sieve[a])\n        a //= sieve[a]\n    for p in tmp:\n        if p in check:\n            print('setwise coprime')\n            return\n        check.add(p)\nprint('pairwise coprime')\n", "# import itertools\nimport math\nfrom functools import reduce\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\nN = int(input())\n# S = input()\n# n, *a = map(int, open(0))\n# N, M = map(int, input().split())\nA = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\nif gcd_list(A) > 1:\n    print(\"not coprime\")\n    return\n\n\nMAXN = 10**6+10\nsieve = [i for i in range(MAXN+1)]\np = 2\nwhile p*p <= MAXN:\n    if sieve[p] == p:\n        for q in range(2*p, MAXN+1, p):\n            if sieve[q] == q:\n                sieve[q] = p\n    p += 1\n\nst = set()\nfor a in A:\n    tmp = set()\n    while a > 1:\n        tmp.add(sieve[a])\n        a //= sieve[a]\n    for p in tmp:\n        if p in st:\n            print('setwise coprime')\n            return\n        st.add(p)\nprint('pairwise coprime')\n", "N=int(input())\nA=list(map(int,input().split()))\nmaxA=max(A)\ncount=[0]*(maxA+1)\nfor x in A:\n    count[x]+=1\nmaxc=0\nfor i in range(2,maxA+1):\n    maxc = max(maxc,sum(count[i::i]))\n\nif maxc==N:\n    print('not coprime')\nelif maxc<=1:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')", "n = int(input())\na = list(map(int, input().split()))\nMAX_A = max(a)\ndivide_minimam_prime = [i for i in range(MAX_A + 1)]\nis_prime = [True for i in range(MAX_A + 1)]\nis_prime[0] = False\nis_prime[1] = False\nfor div in range(2,int(MAX_A**0.5) + 1):\n    if is_prime[div]:\n        # div\u304c\u7d20\u6570\u3060\u3063\u305f\u5834\u5408\n        k = div\n        divide_minimam_prime[k] = k\n        k += div\n        while k <= MAX_A:\n            is_prime[k] = False\n            if divide_minimam_prime[k] == k:\n                divide_minimam_prime[k] = div\n            k += div\n# pairwise coprime\u3067\u3042\u308b\u304b\u3069\u3046\u304b\uff1f\npairwise_coprime = True\nuse_divnum = set()\nfor i in range(n):\n    k = a[i]\n    while k != 1:\n        if divide_minimam_prime[k] in use_divnum:\n            pairwise_coprime = False\n            break\n        else:\n            use_divnum.add(divide_minimam_prime[k])\n        div = divide_minimam_prime[k]\n        while k % div == 0 and k > 1:\n            k = k // div\nif pairwise_coprime: \n    print(\"pairwise coprime\")\n    return\nfrom math import gcd\ngcd_of_a = a[0]\nfor i in range(n):\n    gcd_of_a = gcd(gcd_of_a, a[i])\nif gcd_of_a == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")", "from functools import reduce\nfrom math import gcd\n\nP = [0, 0]+list(range(2, 1000))\nfor i in range(32):\n    if P[i] == 0: continue\n    P[2*i::i] = [0]*(-2--1000//i)\nP = [p for p in P if p]\n\nN = int(input())\nA = [a for a in map(int, input().split()) if a>1]\ni = N-len(A)\n\n# N <= 78498\n\nz = set()\ny = 0\nfor a in A:\n    x = 0\n    for p in P:\n        while a%p == 0:\n            a //= p\n            x |= 1\n        x <<= 1\n    if y&x: break\n    y |= x\n    if a>1:\n        if a in z: break\n        z.add(a)\nelse:\n    print(\"pairwise coprime\")\n    return\n\nif i or reduce(gcd, A) == 1: print(\"setwise coprime\")\nelse: print(\"not coprime\")", "# -*- coding: utf-8 -*-\n\n\ndef main():\n    from math import gcd\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    max_a = 10 ** 6\n    numbers = [0 for _ in range(max_a + 1)]\n\n    # KeyInsight:\n    # \u8abf\u548c\u7d1a\u6570: \u8a08\u7b97\u91cf O(AlogA)\n    # \u25ef: \u7d20\u56e0\u6570\u5206\u89e3\u3092\u3059\u308c\u3070\u3088\u3044\u3053\u3068\u306b\u306f\u6c17\u304c\u3064\u3051\u305f\u3002\n    # \u25b3: 4\u30b1\u30fc\u30b9WA\u30fbTLE\u304c\u53d6\u308c\u305a\n    for ai in a:\n        numbers[ai] += 1\n\n    is_pairwise = True\n\n    # \u7d20\u56e0\u6570\u306e\u5224\u5b9a\n    # \u7d20\u56e0\u6570\u306e\u500d\u6570\u306e\u8981\u7d20\u3092\u6570\u3048\u3066\u3044\u308b\n    for i in range(2, max_a + 1):\n        count = 0\n\n        for j in range(i, max_a + 1, i):\n            count += numbers[j]\n\n            # 2\u3064\u4ee5\u4e0a\u3042\u308b\u6570\u306e\u500d\u6570\u304c\u3042\u3063\u305f\u5834\u5408\u306f\u3001\u5c11\u306a\u304f\u3068\u3082pairwise\u3067\u306f\u306a\u3044\n            if count > 1:\n                is_pairwise = False\n\n    if is_pairwise:\n        print(\"pairwise coprime\")\n        return\n\n    value_gcd = 0\n\n    # \u5168\u3066\u306e\u8981\u7d20\u306eGCD\u304c1\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\n    for i in range(n):\n        value_gcd = gcd(value_gcd, a[i])\n\n        if value_gcd == 1:\n            print(\"setwise coprime\")\n            return\n\n    print(\"not coprime\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nn = int(input())\na = list(map(int,input().split()))\n\nc = [0]*(10**6 + 3)\nfor i in a:\n    c[i] += 1\n\npairwise = True\nfor i in range(2,10**6+1):\n    if sum(c[::i])>1:\n        pairwise = False\n\ng = 0\nfor i in a:\n    g = math.gcd(g,i)\nif g == 1:\n    setwise = True\nelse:\n    setwise = False\n\nif pairwise == True:\n    print(\"pairwise coprime\")\nelif setwise == True:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n", "from functools import reduce\nfrom math import gcd\n\ndef sieve(L,R):\n    if L<2:L=2\n    flag=[0]*(2*R)\n    for i in range(2, int(R**.5)+5):\n        if flag[i] == 1:continue\n        for j in range(i*2,R+i, i):\n            if flag[j] == 1:continue\n            if j % i == 0:\n                flag[j] = 1\n    \n    return [i for i in range(L,R+1) if flag[i] == 0]\n  \nN=int(input())\n*A,=map(int,input().split())\n\nif N == 2:\n  if gcd(A[0],A[1])==1:\n    print('pairwise coprime')\n  else:\n    print('not coprime')\n  return\n\nprimes = sieve(2,10**6+5)\nnum = [0]*(2*10**6+10)\nfor i in range(N):\n  num[A[i]] += 1\n\nflag=0\nfor p in primes:\n  count=0\n  for d in range(p,10**6+p+5,p):\n    count += num[d]\n  if count > 1:\n    flag=1\n    break\n  \nif flag==0:\n  print('pairwise coprime')\nelif reduce(gcd,A)==1:\n  print('setwise coprime')\nelse:\n  print('not coprime')", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef primeFactorization(n):\n    D = list(range(n + 1))\n    for i in range(2, int(n ** 0.5) + 1):\n        if D[i] == i:\n            for j in range(i, n + 1, i):\n                if D[j] == j:\n                    D[j] = i\n    return D\n\ndef resolve():\n    N = I()\n    A = LI()\n\n    # pairwise\u5224\u5b9a\n    is_pc = True\n    D = primeFactorization(max(A))\n    pf = set()\n    for i in A:\n        tmp = i\n        cnt = collections.Counter()\n        while tmp != 1:\n            cnt[D[tmp]] += 1\n            tmp //= D[tmp]\n        fact = set(cnt.keys())\n        if pf & fact:\n            is_pc = False\n            break\n        else:\n            pf |= fact\n    \n    # setwise\u5224\u5b9a\n    is_sc = False\n    if not is_pc:\n        gcd = A[0]\n        for i in A[1:]:\n            gcd = math.gcd(i, gcd)\n        if gcd == 1:\n            is_sc = True\n\n    if is_pc:\n        print('pairwise coprime')\n    elif is_sc:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from math import gcd\nfrom functools import reduce\n\nN, *A = list(map(int, open(0).read().split()))\n\nt = [0] * (10 ** 6 + 1)\nfor a in A:\n    t[a] += 1\n\nfor i in range(2, 10 ** 6 + 1):\n    c = 0\n    for j in range(i, 10 ** 6 + 1, i):\n        c += t[j]\n    if c > 1:\n        break\nelse:\n    print('pairwise coprime')\n    return\n\nif reduce(gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "N=int(input())\nfrom math import gcd\nfrom functools import reduce\nl=list(map(int,input().split()))\nsw=0\nc=[0]*1000001\nfor i in l:\n   c[i]+=1\nif all(sum(c[i::i])<=1 for i in range(2,1000001)):\n  print(\"pairwise coprime\")\nelif reduce(gcd,l)==1:\n   print(\"setwise coprime\")\nelse:\n   print(\"not coprime\")", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 00:26:07 2020\n\n@author: liang\n\"\"\"\n\n\"\"\"\n\u30b3\u30fc\u30ca\u30fc\u30b1\u30fc\u30b9\uff11:\n    \u91cd\u8907\u304c\u3042\u308b\u3068\u304d\u3000not coprime(\u203b\u3053\u308c\u304c\u8aa4\u308a)\n    \u305f\u3060\u3057\u30011\u306e\u91cd\u8907\u306f\u9664\u304f\n\n\u30b3\u30fc\u30ca\u30fc\u30b1\u30fc\u30b9:\n    \u91cd\u8907\u304c\u3042\u308b\u3068\u304d\u3000pairwise coprime \u3067\u306f\u306a\u3044\n    setwise coprime\u306e\u53ef\u80fd\u6027\u306f\u3042\u308b\n    \u305f\u3060\u3057\u3001\uff11\u306e\u91cd\u8907\u306f\n\"\"\"\nimport math\nC = 10**6\n#T = int(math.sqrt(C)*10**3)+1\nN = int(input())\njudge = [0]+[False]*C\nA =list()\nf = True\nfor a in input().split():\n    if judge[int(a)] == True and int(a) != 1:\n        f = False\n    judge[int(a)]=True\n    A.append(int(a))\nd = [False]+[True]*C\n\n#print(judge[:10])\ndef solve(f):\n    flag = True\n    #\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 O(N log N)\n    for i in range(2,C+1):\n        count = 0\n        if d[i] == True:\n            for j in range(i,C+1,i):\n                if judge[j] == True:\n                    count += 1\n                if count == 2:\n                    flag = False\n                    break\n                d[j] = False\n        if not flag:\n            break\n    \n    if flag == True and f == True:\n        return \"pairwise coprime\"\n    ans = A[0]\n    #\u7dda\u5f62\u63a2\u7d22 O(N)\n    for i in range(N):\n        ans = math.gcd(ans,A[i])\n    #print(\"ans\",a)\n    if ans == 1:\n        return \"setwise coprime\"\n    return \"not coprime\"\n\nprint((solve(f)))\n#print(len(A))\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\n\nflag = True\n\nd_set = set()\nfor a in A:\n    while a != 1:\n        d = D[a]\n        if d in d_set:\n            flag = False\n            break\n        else:\n            d_set.add(d)\n        while a > 1 and a % d == 0:\n            a = a // d\n\n\n\nif flag:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "from functools import reduce\nfrom math import gcd\n\nN=int(input())\nA=list(map(int, input().split()))\n\nc=max(A)+1\nD=[0]*c\ndiv=[0]*c\nP=[]\n\nfor i in range(2,c):\n    if D[i]==0:\n        P.append(i)\n        D[i]=i\n    for j in P:\n        if i*j>=c  or j>D[i] :\n           break\n        D[i*j]=j\nf=0\nfor i in A:\n    if i==1:\n        continue\n    temp=i\n    while temp!=1:\n        if div[D[temp]]==1:\n            f=1\n            break\n        div[D[temp]]+=1\n        temp2=D[temp]\n        while temp%temp2==0 and temp>=temp2:\n            temp=temp//temp2\n    if f==1:\n        break\n        \nif f==0:\n    print('pairwise coprime')\n\nelif reduce(gcd, A) == 1:\n    print('setwise coprime')\n\nelse:\n    print('not coprime')", "from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\nprime = list(range(max(A) + 1))\n\nfor i in range(2, len(prime)):\n    if prime[i] != i:\n        continue\n    for j in range(i, len(prime), i):\n        if prime[j] != j:\n            continue\n        prime[j] = i\n\nused = set()\npc = True\nfor a in A:\n    used_this = set()\n    while a != 1:\n        div = prime[a]\n        if div in used:\n            pc = False\n            break\n        used_this.add(div)\n        a //= div\n    used.update(used_this)\n\nif pc:\n    print('pairwise coprime')\n    return\n\nbuf = A[0]\nfor a in A[1:]:\n    buf = gcd(buf, a)\nif buf == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')", "import math\nfrom functools import reduce\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef eratosthenes(limit):\n    A = [i for i in range(2, limit+1)]\n    P = []\n\n    while True:\n        prime = min(A)\n\n        if prime > math.sqrt(limit):\n            break\n\n        P.append(prime)\n\n        i = 0\n        while i < len(A):\n            if A[i] % prime == 0:\n                A.pop(i)\n                continue\n            i += 1\n\n    for a in A:\n        P.append(a)\n\n    return P\n\ndef factorization(n, D):\n    arr = []\n    temp = n\n    for i in D:\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append(i)\n\n    if temp!=1:\n        arr.append(temp)\n\n    if arr==[]:\n        arr.append(n)\n\n    return arr\n\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\n\ndef decomp(n, D):\n    arr = []\n    while n != 1:\n        if D[n] not in arr:\n            arr.append(D[n])\n        n = n//D[n]\n    return arr\n\nD = [i for i in range(10**6+1)]\n\nfor i in range(2, 10**3+1):\n  if D[i] == i:\n    for n in range(i, 10**6+1, i):\n      if D[n] == n:\n          D[n] = i\n\ns = set()\nfor i in a:\n    for j in decomp(i, D):\n        if j not in s:\n            s.add(j)\n        else:\n            if gcd_list(a) == 1:\n                print('setwise coprime')\n                return\n            else:\n                print('not coprime')\n                return\n\nprint('pairwise coprime')\n\n", "from math import gcd\nfrom functools import reduce\n \n \ndef facs(n):\n    yield 2\n    for x in range(3, n, 2):\n        yield x\n \n \ndef main():\n    input()  # N\n    array = [int(x) for x in input().split()]\n    MAX_A = 10 ** 6 + 1\n    histogram = [0] * MAX_A\n    for x in array:\n        histogram[int(x)] += 1\n \n    for divider in facs(MAX_A):\n        count = sum(histogram[divider::divider])\n        if count > 1:\n            break\n    else:\n        return 'pairwise coprime'\n \n    gcd_total = reduce(gcd, array)\n    if gcd_total == 1:\n        return 'setwise coprime'\n    else:\n        return 'not coprime'\n \n \ndef __starting_point():\n    print(main())\n__starting_point()", "max_num = 10**6 + 1\nprime = [i for i in range(max_num)]\nr2_num = int(max_num**(1/2))+1\nfor i in range(2, r2_num):\n  if prime[i] == i:\n    for j in range(i**2, max_num, i):\n      if prime[j] == j:\n        prime[j] = i\ndef gcd(a, b): # a >= b\n  if a%b == 0:\n    return b\n  else:\n    return gcd(b, a%b)\n\nflg_pairwise = True\nflg_setwise = False\n\nn = int(input().rstrip())\na_ls = list(map(int, input().rstrip().split(\" \")))\ngcd_a = 0\nprimes_a = []\ncount_prime = [0 for i in range(max_num)]\nfor a in a_ls:\n  gcd_a = gcd(gcd_a, a)\n  if gcd_a == 1:\n    flg_setwise = True\n  tmp_prime = 0\n  while a > 1:\n    p = prime[a]\n    pp = prime[p]\n    if p == 0 or pp == 0:\n      flg_pairwise = False\n      break\n    if tmp_prime != p:\n      prime[tmp_prime] = 0\n      tmp_prime = p\n    a = a//p\n  if flg_pairwise:\n    prime[tmp_prime] = 0\n  if flg_setwise and not flg_pairwise:\n    break\nif flg_pairwise:\n  print(\"pairwise coprime\")\nelif flg_setwise:\n  print(\"setwise coprime\")\nelse:\n  print(\"not coprime\")", "from math import gcd\nn,*a = map(int,open(0).read().split())\ng = 0\nfor i in a:\n  g = gcd(g,i)\n  if g == 1:\n    break\nelse:\n  print(\"not coprime\")\n  return\nm = 10**6+1\nd = [i for i in range(m)]\nfor i in range(4,m,2):\n  d[i] = 2\np = 3\nwhile p**2<m:\n  if d[p] == p:\n    for i in range(3*p,m,2*p):\n      if d[i] == i:\n        d[i] = p\n  p+=2\np = set()\nfor i in a:\n  t = set()\n  while i > 1:\n    t.add(d[i])\n    i //= d[i]\n  if p & t:\n    print(\"setwise coprime\")\n    return\n  else:\n    p |= t\nprint('pairwise coprime')", "import math\n\nN = int(input())\nA = list(map(int, input().split()))\nD = [i for i in range(10**6+1)]\na_gcd = 0\nfor a in A:\n  a_gcd = math.gcd(a, a_gcd)\nif a_gcd > 1:\n  print('not coprime')\n  return\n\nfor i in range(2, 10**3+1):\n  if D[i] == i:\n    for n in range(i, 10**6+1, i):\n      if D[n] == n:\n        D[n] = i\n\np_set = set()\nfor a in A:\n  d_set = set()\n  while a > 1:\n    if not D[a] in d_set:\n      if D[a] in p_set:\n        print('setwise coprime')\n        return\n      p_set.add(D[a])\n      d_set.add(D[a])\n    a //= D[a]\nprint('pairwise coprime')\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\npairwise_coprime = True\nuse_divnum = set()\nfor k in A:\n    while k != 1:\n        div = D[k]\n        if div in use_divnum:\n            pairwise_coprime = False\n            break\n        else:\n            use_divnum.add(div)\n        \n        while k % div == 0 and k > 1:\n            k = k // div\n\nif pairwise_coprime:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "\n\n#\u7d20\u56e0\u6570\u5206\u89e3\uff0810**6\u307e\u3067\uff09\ndef soinsu_bunkai(m):\n    pf=set()\n    mm =m\n    pri_num =[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009]\n    for i in pri_num:\n        if i > mm:\n            break\n        while mm %i==0:\n            pf.add(i)\n            mm //=i\n    if mm !=1:\n        pf.add(mm)\n    return pf\n\n# \u521d\u671f\u5165\u529b\nimport math\nimport sys\nfrom functools import reduce\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nN = int(input())\nA = list(map(int, input().split()))\nused =set()\npair_w =set()\n\n# 10**6\u307e\u3067\u306e\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\u305f\u3081\u306b\u3001\u300c10**6\u306e\u30eb\u30fc\u30c8\u300d\u307e\u3067\u306e\u7d20\u6570\u3092\u5217\u6319\npri =10**6 +10\n\n#not coprime\u306e\u5224\u5b9a\ngcd_a =reduce(math.gcd,A)\nif gcd_a !=1:\n    ans =\"not coprime\"\n\n#pairwise coprime\u306e\u5224\u5b9a\nelse:\n    ans =\"pairwise coprime\"\n    for a in A:\n        aa =soinsu_bunkai(a)\n        if used & aa:\n            print(\"setwise coprime\")\n            return #\u5171\u901a\u8981\u7d20\u304c\u3042\u3063\u305f\u3089pair_w\u3067\u306f\u306a\u3044\u2192set_w\n        used |=aa\n\n        \nprint(ans)", "N = int(input())\nA = list(map(int, input().split()))\n\n\n# number_to_prime[i]: i \u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570, i\u304c\u7d20\u6570\u306a\u3089\u30700\nnumber_to_prime = [0] * (10**6 + 1)\n\n# preprocess\nfor i in range(2, 10**6+1):\n    if not number_to_prime[i]:\n        j = 1\n        while j*i <= 10**6:\n            number_to_prime[j*i] = i\n            j += 1\n\ndef is_pairwise():\n    used_primes = [False] * (10**6 + 1)\n    pairwise_flag = 1\n    for a in A:\n        curr_primes = set()\n        while a > 1:\n            prime = number_to_prime[a]\n            while a % prime == 0:\n                a //= prime\n            if used_primes[prime]:\n                return False\n            used_primes[prime] = 1\n    return True\n\ndef is_setwise(*A):\n    import math\n    from functools import reduce\n\n    return reduce(math.gcd, A) == 1\n\nif is_pairwise():\n    print(\"pairwise coprime\")\nelif is_setwise(*A):\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")", "n = int(input())\na = list(map(int,input().split()))\n\ndef gcd(a,b):\n    while b:\n        a,b = b,a%b\n    return a\n\nc = [0]*(10**6 + 3)\nfor i in a:\n    c[i] += 1\n\npairwise = True\nfor i in range(2,10**6+1):\n    if sum(c[::i])>1:\n        pairwise = False\n\ng = 0\nfor i in a:\n    g = gcd(g,i)\nif g == 1:\n    setwise = True\nelse:\n    setwise = False\n\nif pairwise == True:\n    print(\"pairwise coprime\")\n    return\nif setwise == True:\n    print(\"setwise coprime\")\n    return\nprint(\"not coprime\")", "from math import gcd\nfrom functools import reduce\nN=int(input())\nA=list(map(int,input().split()))\n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\nl=primes(max(A))\n#print(l)\nd=[0]*max(A)\nfor i in A:\n  d[i-1]=1\n#print(d)\n#for i in l:\n#  print(d[i-1::i])\nif reduce(gcd,A)==1:\n#   print('setwise coprime')\n  if all(sum(d[i-1::i])<=1 for i in l):\n    print('pairwise coprime')\n  else:print('setwise coprime')\nelse:\n   print('not coprime')", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nclass Sieve: #\u533a\u9593[2,n]\u306e\u5024\u306e\u7d20\u56e0\u6570\u5206\u89e3 O(nloglogn+logn)\n    def __init__(self,n): #n\u306f\u8a08\u7b97\u5bfe\u8c61\u3068\u3057\u3066\u3042\u308a\u3046\u308b\u6700\u5927\u306e\u5024\n        self.primes=[]\n        self.f=[0]*(n+1) #\u3075\u308b\u3044\uff08\u7d20\u6570\u306a\u3089\u305d\u306e\u5024\uff09\n        self.f[0]=self.f[1]=-1\n        self.f_lis = [0]*(n+1)\n        for i in range(2,n+1): #\u7d20\u6570\u30ea\u30b9\u30c8\u4f5c\u6210\n            if self.f[i]: continue\n            self.primes.append(i)\n            self.f[i]=i\n            for j in range(i*i,n+1,i):\n                if not self.f[j]:\n                    self.f[j]=i  #\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u3092\u4ee3\u5165\n    def prime_fact(self,A): #\u7d20\u56e0\u6570\u5206\u89e3 {2:p,3:q,5:r,...}\n        for x in A:\n            while x!=1:\n                p=self.f[x]\n                x//=p\n                if x % p > 0:\n                    if self.f_lis[p] > 0: return False\n                    self.f_lis[p] += 1\n        return True\n\nimport math\nfrom functools import reduce\ndef gcd_all(numbers):#gcd(A)\n    return reduce(math.gcd, numbers)\n\ndef main():\n    n = int(input())\n    A = list(map(int,input().split())) \n    Sieve_a = Sieve(max(A)+1)\n    if Sieve_a.prime_fact(A):\n        print(\"pairwise coprime\")\n    elif gcd_all(A) == 1:\n        \n        print(\"setwise coprime\")   \n    else:\n        print(\"not coprime\")\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import gcd\n\nN = int(input())\nA = list([int(x) for x in input().split()])\n\nmax_a = max(A)\n\nbefore = 0\nresult = [0 for _ in range(max_a + 1)]\n\nfor i in A:\n    before = gcd(before, i)\n    result[i] += 1\n\nis_pairwise = True\n\nfor i in range(2, max_a + 1):\n    cnt = 0\n    for j in range(i, max_a + 1, i):\n        cnt += result[j]\n    if cnt > 1:\n        is_pairwise = False\n        break\n\nif is_pairwise:\n    print('pairwise coprime')\n    return\nif before == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 07:10:00 2020\n\n@author: liang\n\"\"\"\n\n\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep 18 00:26:07 2020\n\n@author: liang\n\"\"\"\n\n\"\"\"\n\u30b3\u30fc\u30ca\u30fc\u30b1\u30fc\u30b9\uff11:\n    \u91cd\u8907\u304c\u3042\u308b\u3068\u304d\u3000not coprime\n    \u305f\u3060\u3057\u30011\u306e\u91cd\u8907\u306f\u9664\u304f\n\"\"\"\nimport math\nC = 10**6\nN = int(input())\njudge = [False]*(C+1)\nA = [int(x) for x in input().split()]\n\nf = True\nfor a in A:\n    if judge[a] == True and a != 1:\n        f = False\n    judge[int(a)]=True\n\n\n#print(judge[:10])\ndef solve(f):\n    \n    ans = A[0]\n    #\u7dda\u5f62\u63a2\u7d22 O(N)\n    for i in range(N):\n        ans = math.gcd(ans,A[i])\n    #print(\"ans\",a)\n    if ans != 1:\n        return \"not coprime\"\n    \n    flag = True\n    #\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9 O(N log N)\n    for i in range(2,C+1):\n        count = 0\n       #if d[i] == True:\n        for j in range(i,C+1,i):\n            if judge[j] == True:\n                count += 1\n            if count == 2:\n                flag = False\n                break\n        #        d[j] = False\n        if not flag:\n            break\n    \n    if flag == True and f == True:\n        return \"pairwise coprime\"\n    \n    return \"setwise coprime\"\n\nprint((solve(f)))\n#print(len(A))\n", "from math import gcd\nflag=0\nN=int(input())\nA=list(map(int,input().split()))\nMax=max(A)\na=[0]*(Max+1)\nfor i in A:\n    a[i]+=1\nfor i in range(2,Max+1):\n    if sum(a[i::i])>=2:\n        flag=1\n        break\nif flag==0:\n    print('pairwise coprime')\nelse:\n    r=A[0]\n    for i in A:\n        r=gcd(r,i)\n    if r==1:\n        print('setwise coprime')\n    else:\n        print(\"not coprime\")", "from math import gcd, sqrt\nfrom functools import reduce\n\nn, *A = map(int, open(0).read().split())\ndef f(A):\n    sup = max(A)+1\n    table = [i for i in range(sup)]\n    for i in range(2, int(sqrt(sup))+1):\n        if table[i] == i:\n            for j in range(i**2, sup, i):\n                table[j] = i\n\n    D = set()\n    for a in A:\n        while a != 1:\n            if a not in D:\n                D.add(a)\n                a //= table[a]\n            else:\n                return False\n    return True\n\nif reduce(gcd, A) == 1:\n    if f(A):\n        print('pairwise coprime')\n    else:\n        print('setwise coprime')\nelse:\n    print('not coprime')", "from math import gcd\n\ndef make_kazu_list(n):\n    l = [0]*n\n    l[1] = 1\n    i = 2\n    while i < n:\n        if l[i] == 0:\n            j = i\n            while j < n:\n                l[j] = i if l[j] == 0 else l[j]\n                j += i\n        i += 1\n    return l\n\ndef soinsuubunkai(n, l):\n    r = []\n    if n < 2:\n        return r\n    while l[n] != n:\n        r.append(l[n])\n        n = n // l[n]\n    r.append(l[n])\n    return set(r)\n\n# l = make_kazu_list(101)\n# print(soinsuubunkai(2, l))\n# print(soinsuubunkai(66, l))\n# print(soinsuubunkai(72, l))\n\ndef f(n, ais):\n    pl = [False]*1000001\n    l = make_kazu_list(1000001)\n    for n in soinsuubunkai(ais[0], l):\n        pl[n] = True\n    common_factors = ais[0]\n    pairwise_coprime = True\n    setwise_coprime = False\n    for ai in ais[1:]:\n        if not pairwise_coprime and setwise_coprime:\n            break\n        if pairwise_coprime:\n            numbers = soinsuubunkai(ai, l)\n            for n in numbers:\n                if pl[n]:\n                    pairwise_coprime = False\n                    break\n                else:\n                    pl[n] = True\n        if not setwise_coprime:\n            common_factors = gcd(common_factors, ai)\n            if common_factors == 1:\n                setwise_coprime = True\n    if pairwise_coprime:\n        return 'pairwise coprime'\n    elif setwise_coprime:\n        return 'setwise coprime'\n    else:\n        return 'not coprime'\n\nn = int(input())\nais = list(map(int, input().split(' ')))\nprint((f(n, ais)))\n", "#E_Coprime\nimport math\nimport functools\n\n# \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n        \ndef primes(n):\n    is_prime = [1] * (n + 1)\n    is_prime[0] = 0\n    is_prime[1] = 0\n    D_prime = [i for i in range(n+1)] \n    D_prime[0] = 0\n    D_prime[1] = 1\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            D_prime[i] = i\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = 0\n            D_prime[j] = i\n    return D_prime\n\n    \n\nFnum_list2 = []\n# \u5165\u529b\nN = int(input())\nA = list(map(int,input().split()))\n\n#Fnum_list = eratosthenes(N)\n\nA.sort()\nAmax = A[-1]\nFnum_list2 = primes(Amax)\nj = A[0]\nans = 1\n#Fnum_list = eratosthenes(N)\nAi_primes     = set()\nAi_primes_add = []\ngcd_num = 0\nfor i in range(len(A) ):\n    p = A[i]\n    while p != 1:\n        j = p\n        p = int (p / Fnum_list2[j])\n        if Fnum_list2[j] in Ai_primes:\n            ans = 0\n        else:\n            Ai_primes_add.append(Fnum_list2[j])\n    if Fnum_list2[j] in Ai_primes:\n        break\n    else:\n        Ai_primes |= set(Ai_primes_add)\n        Ai_primes_add.clear()\n\ngcd_num = functools.reduce(math.gcd,A)\n\nif ans == 0:\n    if gcd_num == 1:\n        ans = 2\n\n# \u51fa\u529b\nif ans == 1:\n    print(\"pairwise coprime\")\nelse:\n    if ans == 2:\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\n", "from math import gcd\n\nN = int(input())\nnum_lis = list(map(int, input().split()))\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(2*p, max_num+1, p):\n        if lis[q] == q:\n          lis[q] = p\n    p += 1\n  return lis\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  print(\"not coprime\")\n  return\n\nd_lis = osa_k(max(num_lis))\ntmp = set()\nfor i in num_lis:\n  num = i\n  new_tmp = set()\n  while num > 1:\n    d = d_lis[num]\n    new_tmp.add(d)\n    num //= d\n  for j in new_tmp:\n    if j in tmp:\n      print(\"setwise coprime\")\n      return\n    else:\n      tmp.add(j)\nprint(\"pairwise coprime\")", "from functools import reduce\nfrom math import gcd\n\nN=int(input())\nA=list(map(int, input().split()))\n\nc=max(A)+1\nD=[0]*c\ndiv=[0]*c\nP=[]\n\nfor i in range(2,c):\n    if D[i]==0:\n        P.append(i)\n        D[i]=i\n    for j in P:\n        if i*j>=c  or j>D[i] :\n           break\n        D[i*j]=j\nf=0\nfor i in A:\n    if i==1:\n        continue\n    temp=i\n    while temp!=1:\n        if div[D[temp]]==1:\n            f=1\n            break\n        div[D[temp]]+=1\n        temp2=D[temp]\n        while temp%temp2==0 and temp>=temp2:\n            temp=temp//temp2\n    if f==1:\n        break\n        \n\n\nif max(div)<=1 and f==0:\n    print('pairwise coprime')\n\nelif reduce(gcd, A) == 1:\n    print('setwise coprime')\n\nelse:\n    print('not coprime')", "n=int(input())\nA=[int(x) for x in input().split()]\n\nu=10**6+1\nC=[0]*u\nD=[0]*2+[1]*(u-2)\n\ndef e():\n  n=4\n  while n<u:\n    D[n]=0\n    n+=2\n  i=3\n  while i*i<u:\n    if D[i]:\n      n=i*2\n      while n<u:\n        D[n]=0\n        n+=i\n    i+=2\n\ndef gcd(a,b):\n   while a%b:\n     a,b=b,a%b\n   return b\n\nfor a in A:\n  C[a]+=1\ne()\nfor i in [x for x in range(2,u) if D[x]==1]:\n  if sum(C[i::i])>1:\n    break\nelse:\n  print('pairwise coprime')\n  return\n\nc=A[0]\nfor a in A:\n  c=gcd(c,a)\n  if c==1:\n    break\nelse:\n  print('not coprime')\n  return\n\nprint('setwise coprime')\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\n\nflag = True\n\nd_set = set()\nfor k in A:\n    while k != 1:\n        div = D[k]\n        if div in d_set:\n            flag = False\n            break\n        else:\n            d_set.add(div)\n        \n        while k % div == 0 and k > 1:\n            k = k // div\n\nif flag:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "import math\nimport sys\ninput = sys.stdin.readline\npc = True\nn = int(input())\na = list(map(int,input().split()))\ng = math.gcd(a[0],a[1])\nfor i in range(2,n):\n    g = math.gcd(g,a[i])\nM = max(a)\nclass Sieve_of_Eratosthenes:\n    def __init__(self, N):\n        self.sieve = [-1] * (N+1)\n\n        for i in range(2,N+1):\n            if self.sieve[i] == -1:\n                for j in range(1,1+N//i):\n                    self.sieve[i*j] = i\n\n    def isprime(self, num):\n        if num <= 1:\n            return False\n        else:\n            return self.sieve[num] == num\n\n    def factorization(self, num):\n        ret = set([])\n        while num != 1:\n            div = self.sieve[num]\n            ret.add(div)\n            num //= div\n        return ret\n\nsofe = Sieve_of_Eratosthenes(M)\n\njudge = set([])\n\nfor i in a:\n    if not pc:\n        break\n    asf = sofe.factorization(i)\n    \n    if judge & asf != set():\n        pc = False\n    judge |= asf\nif pc:\n    print(\"pairwise coprime\")\nelif g == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n", "import math\n\nN = int(input())\nA = list(map(int, input().split()))\n\ng = 0\nfor a in A:\n    g = math.gcd(g, a)\nif g != 1:\n    print('not coprime')\n    return\n\nis_prime = [1] * 1000001\nD = [0] * 1000001\n\nfor i in range(2, 1001):\n    if is_prime[i]:\n        D[i] = i\n        j = 2 * i\n        while j <= 1000000:\n            if is_prime[j]:\n                D[j] = i\n                is_prime[j] = 0\n            j += i\nfor i in range(1001, 1000001):\n    if is_prime[i]:\n        D[i] = i\n\ncount = [0] * 1000001\nfor a in A:\n    k = a\n    pre = 0\n    while k != 1:\n        if pre != D[k]:\n            count[D[k]] += 1\n            if count[D[k]] == 2:\n                print('setwise coprime')\n                return\n        pre = D[k]\n        k = int(k / D[k])\nprint('pairwise coprime')\n", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce, lru_cache\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\nn = INT()\na = LIST()\n\nc = [0]*(10**6+1)\nfor x in a:\n    c[x] += 1\n\nk = max(sum(c[i::i]) for i in range(2, 10**6+1))\n\nif k <= 1:\n    print(\"pairwise coprime\")\nelif k < n:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")", "from math import gcd\n\n\ndef main():\n    N = int(input())\n    A = list([int(x) for x in input().split()])\n\n    max_a = max(A)\n\n    before = 0\n    result = [0 for _ in range(max_a + 1)]\n\n    for i in A:\n        before = gcd(before, i)\n        result[i] += 1\n\n    is_pairwise = True\n    for i in range(2, max_a + 1):\n        cnt = 0\n        for j in range(i, max_a + 1, i):\n            cnt += result[j]\n\n        if cnt > 1:\n            is_pairwise = False\n            break\n\n    if is_pairwise:\n        print('pairwise coprime')\n        return\n\n    if before == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nN=int(input())\nA=list(map(int,input().split()))\ncnt=[0]*(10**6+1)\nfor a in A:cnt[a]+=1\n \nif np.gcd.reduce(A)!=1:\n  print(\"not coprime\")\nelif np.all([sum(cnt[i::i])<=1 for i in range(2,10**6+1)]):\n  print(\"pairwise coprime\")\nelse:\n  print(\"setwise coprime\")", "import math\n\ndef eratosthenes():\n    erat = [0 for _ in range(max_a+1)]\n    #lim = int(math.sqrt(max_a))\n    pair = True\n    #for i in range(2, lim+1):\n    for i in range(2, max_a+1):\n        cnt = 0\n        if not erat[i]:\n            for res in range(i, max_a+1, i):\n                if res in set_a:\n                    cnt += 1\n                erat[res] = i\n                if cnt > 1:\n                    pair = False\n                    break\n        if not pair:\n            break\n    return pair\n\n\nn = int(input())\na = [int(x) for x in input().split()]\nmax_a = max(a)\nset_a = set(a)\n\nif eratosthenes() and len(set_a) == n - max(0, a.count(1)-1):\n    print('pairwise coprime')\nelse:\n    res = a[0]\n    for i in range(n):\n        res = math.gcd(res, a[i])\n    if res == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n", "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\n\nchecker = [0 for _i in range(10**6+1)]\nfor i in a:\n    checker[i] += 1\n\nif all(sum(checker[i::i])<2 for i in range(2,10**6+1)):\n    print('pairwise coprime')\nelse:\n    r = a[0]\n    for i in a:\n        r = gcd(r, i)\n    if r == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')", "def GCD(m, n):\n    while n != 0:\n        m, n = n, m % n\n    return m\n\ndef gcd_all(a):\n    n = len(a)\n    gcd = a[0]\n    for i in range(1, n):\n        gcd = GCD(gcd, a[i])\n    return gcd\n\ndef f(a):\n    mx = 10**6\n    p = set([])\n    sieve = [i for i in range(mx + 1)]\n    for i in range(2, int(mx**0.5 + 1)):\n        for j in range(2 * i, mx + 1, i):\n            if sieve[j] > i:\n                sieve[j] = i\n    pairwise_coprime = True\n    for i in a:\n        p2 = set([])\n        while i > 1:\n            p2.add(sieve[i])\n            i //= sieve[i]\n        for j in p2:\n            if j in p:\n                pairwise_coprime = False\n                break\n            p.add(j)\n        if pairwise_coprime == False:\n            break\n    gcd = gcd_all(a)\n    if pairwise_coprime == False and gcd == 1:\n        return 'setwise coprime'\n    elif pairwise_coprime:\n        return 'pairwise coprime'\n    else:\n        return 'not coprime'\n\nn = int(input())\na = list(map(int, input().split()))\nprint((f(a)))\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\n\nflag = True\n\nd_set = set()\nfor a in A:\n    while a != 1:\n        d = D[a]\n        if d in d_set:\n            flag = False\n            break\n        else:\n            d_set.add(d)\n        while a > 1 and a % d == 0:\n            a = a // d\n    if not(flag):\n        break\n\n\n\nif flag:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "def divplis(N):\n    lis = [i for i in range(N+1)]\n    for i in range(int(N**0.5+1),1,-1):\n        if lis[i] == i:\n            lis[i::i] = [i]*(N//i)\n    return lis\n\ndivp = divplis(10**6+1)\nN = int(input())\nd = [0]*(10**6+1)\nA = [int(i) for i in input().split()]\n\n\ndef pfact(N):\n    b = 0\n    while N != 1:\n        n = divp[N]\n        if b != n:\n            d[n] += 1\n        b = n\n        N = N // n\n    return 0\n    \nfor a in A:\n    pfact(a)\nm = max(d)\nif m <= 1:\n    print(\"pairwise coprime\")\nelif m == N:\n    print(\"not coprime\")\nelse:\n    print(\"setwise coprime\")\n", "N=int(input())\nfrom math import gcd\nfrom functools import reduce\nl=list(map(int,input().split()))\nsw=0\nc=[0]*1000001\nfor i in l:\n   c[i]+=1\nif all(sum(c[i::i])<=1 for i in range(2,1000001)):\n  print(\"pairwise coprime\")\nelif reduce(gcd,l)==1:\n   print(\"setwise coprime\")\nelse:\n   print(\"not coprime\")", "N = int(input())\nA = list(map(int, input().split()))\n\nmaxn =  1000005\nprime = [0 for _ in range(maxn)]\n\nfor i in range(2, maxn):\n    if prime[i] == 0:\n        for j in range(i, maxn, i):\n            prime[j] = i #\u6700\u5927\u8cea\u56e0\u6578\n\nst = set() #\u76ee\u524d\u51fa\u73fe\u904e\u7684\u6240\u6709\u8cea\u56e0\u6578\uff0c\u4e00\u958b\u59cb\u70baA[0]\u7684\u6240\u6709\u8cea\u56e0\u6578\na = A[0]\nwhile prime[a]:\n    st.add(prime[a])\n    x = prime[a]\n    while (a % x == 0):\n        a //= x\n\npairwise = True\nst2 = st #\u6240\u6709\u6578\u5171\u6709\u7684\u8cea\u56e0\u6578\uff0c\u4e00\u958b\u59cb\u70baA[0]\u7684\u6240\u6709\u8cea\u56e0\u6578\nfor a in A[1:]:\n    tmp = set()\n    for j in st2:\n        if a % j == 0:\n            tmp.add(j)\n\n    st2 = tmp\n    if pairwise:\n        while prime[a]:\n            if prime[a] in st:\n                pairwise = False\n            st.add(prime[a])\n            x = prime[a]\n            while (a % x == 0):\n                a //= x\n\nif pairwise:\n    print(\"pairwise coprime\")\nelif len(st2) == 0:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")", "n=int(input())\nA=[int(x) for x in input().split()]\n\nu=10**6+1\nC=[0]*u\nD=[0]*2+[1]*(u-2)\n\ndef gcd(a,b):\n   while a%b:\n     a,b=b,a%b\n   return b\n\nn=4\nwhile n<u:\n  D[n]=0\n  n+=2\ni=3\nwhile i*i<u:\n  if D[i]:\n    n=i*2\n    while n<u:\n      D[n]=0\n      n+=i\n  i+=2\n\nfor a in A:\n  C[a]+=1\nfor i in [x for x in range(2,u) if D[x]==1]:\n  if sum(C[i::i])>1:\n    break\nelse:\n  print('pairwise coprime')\n  return\n\nc=A[0]\nfor a in A:\n  c=gcd(c,a)\n  if c==1:\n    break\nelse:\n  print('not coprime')\n  return\n\nprint('setwise coprime')\n", "from math import gcd\nfrom functools import reduce\nN=int(input())\nA=list(map(int,input().split()))\n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\nl=primes(max(A))\n#print(l)\nd=[0]*max(A)\nfor i in A:\n  d[i-1]=1\n#print(d)\n#for i in l:\n#  print(d[i-1::i])\nif reduce(gcd,A)>1:\n  print('not coprime')\nelif all(sum(d[i-1::i])<=1 for i in l):\n    print('pairwise coprime')\nelse:print('setwise coprime')", "from math import gcd\nfrom functools import reduce\n\nN, *A = list(map(int, open(0).read().split()))\n\ndef f():\n    t = [0] * (10 ** 6 + 1)\n    for a in A:\n        t[a] += 1\n\n    c = 0\n    for j in range(2, 10 ** 6 + 1, 2):\n        c += t[j]\n    if c > 1:\n        return False\n\n    for i in range(3, 10 ** 6 + 1, 2):\n        c = 0\n        for j in range(i, 10 ** 6 + 1, i):\n            c += t[j]\n        if c > 1:\n            return False\n\n    return True\n\nif f():\n    print('pairwise coprime')\nelif reduce(gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "def gcc(x, y):\n    if x == 0:return y\n    return gcc(y % x, x)\n\nN = int(input())\nA = list(map(int, input().split()))\n\ng = 0\n\nA.sort()\n\nfor item in A:\n    g = gcc(g, item)\n\nif g != 1:\n    print(\"not coprime\")\n    return\n\nprimes = []\nis_prime = [True] * 1100000\n\nis_prime[0] = is_prime[1] = False\n\nfor i in range(2, 1100000):\n    if not is_prime[i]:continue\n    for j in range(i*i, 1100000, i):\n        is_prime[j] = False\n    primes.append(i)\n\nA_prime = [item for item in A if is_prime[item]]\nA_notprime = [item for item in A if not is_prime[item]]\n\nused = [False] * 1100000\n\nfor item in A_prime:\n    used[item] = True\n\nfor a in A_notprime:\n    for p in primes:\n        if a == 1:break\n        if a % p != 0:continue\n\n        if used[p]:\n            print(\"setwise coprime\")\n            #\u4e92\u3044\u306b\u7d20\u3067\u306a\u3044\uff08\u5171\u901a\u7d20\u56e0\u6570p\u3067\u5272\u308c\u308b\uff09\u30da\u30a2\u304cA\u306e\u4e2d\u306b\u3042\u308b\u3068\uff0c\u305d\u308c\u306fsetwise_coprime\n            return\n\n        used[p] = True\n\n        while a % p == 0:\n            a //= p\n\nprint(\"pairwise coprime\")", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\npairwise_coprime = True\nuse_divnum = set()\nfor i in range(N):\n    k = A[i]\n    while k != 1:\n        if D[k] in use_divnum:\n            pairwise_coprime = False\n            break\n        else:\n            use_divnum.add(D[k])\n        div = D[k]\n        while k % div == 0 and k > 1:\n            k = k // div\n\nif pairwise_coprime:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "import math\nfrom functools import reduce\nn=int(input())\na=list(map(int,input().split()))\nans=reduce(math.gcd,a)\nif ans>1:\n  print(\"not coprime\")\n  return\nmaxn=10**6+10\nli=[i for i in range(maxn+1)]\np=2\nwhile p*p<=maxn:\n  if li[p]==p:\n    for q in range(2*p,maxn,p):\n      if li[q]==q:\n        li[q]=p\n  p+=1\nans=[0]*(maxn+1)\nfor i in a:\n  bk=0\n  while i>1:\n    wk=li[i]\n    i//=wk\n    if ans[wk]==0 and bk!=wk:\n      ans[wk]=1\n      bk=wk\n    elif bk==wk:\n      continue\n    else:\n      print(\"setwise coprime\")\n      return\nprint(\"pairwise coprime\")", "from math import gcd\nfrom functools import reduce\n\nN, *A = list(map(int, open(0).read().split()))\n\ndef f():\n    t = [0] * (10 ** 6 + 1)\n    for a in A:\n        t[a] += 1\n\n    c = 0\n    for j in range(2, 10 ** 6 + 1, 2):\n        c += t[j]\n    if c > 1:\n        return False\n\n    for i in range(3, 10 ** 6 + 1, 2):\n        c = 0\n        for j in range(i, 10 ** 6 + 1, i):\n            c += t[j]\n        if c > 1:\n            return False\n\n    return True\n\nif f():\n    print('pairwise coprime')\nelif reduce(gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "import math\nfrom functools import reduce\n\ndef getD(num):\n    input_list = [2 if i % 2 == 0 else i for i in range(num+1)]\n    input_list[0] = 0\n    bool_list = [False if i % 2 == 0 else True for i in range(num+1)]\n    sqrt = int(math.sqrt(num))\n    \n    for serial in range(3, sqrt + 1, 2):\n        if bool_list[serial]:\n            for s in range(serial ** 2, num+1, serial):\n                if bool_list[s]:\n                    input_list[s] = serial\n                    bool_list[s] = False\n    return input_list\n\nN = int(input())\nA = list(map(int, input().split()))\n\nD = getD(max(A))\n\nflag = True\n\nd_set = set()\nfor a in A:\n    while a != 1:\n        d = D[a]\n        if d in d_set:\n            flag = False\n            break\n        else:\n            d_set.add(d)\n        \n        while a % d == 0 and a > 1:\n            a = a // d\n\nif flag:\n    print('pairwise coprime')\n    return\n\nif reduce(math.gcd, A) == 1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "from math import gcd\n\nN = int(input())\nnum_lis = list(map(int, input().split()))\nc1 = True\nc2 = True\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(2*p, max_num+1, p):\n        if lis[q] == q:\n          lis[q] = p\n    p += 1\n  return lis\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  c1 = False\n\nif c1:\n  d_lis = osa_k(max(num_lis))\n  tmp = set()\n  for i in num_lis:\n    num = i\n    new_tmp = set()\n    while num > 1:\n      d = d_lis[num]\n      new_tmp.add(d)\n      num //= d\n    for j in new_tmp:\n      if j in tmp:\n        c2 = False\n        break\n      else:\n        tmp.add(j)\n    else:\n      continue\n    break\nelse:\n  c2 = False\n\nif c2:\n  print(\"pairwise coprime\")\nelif c1:\n  print(\"setwise coprime\")\nelse:\n  print(\"not coprime\")", "from math import gcd\nclass Factor:\n    def __init__(self, max_element):\n        self.minFactor = [-1]*(max_element+1)\n        for i in range(2, max_element+1):\n            if self.minFactor[i] == -1:\n                for j in range(i, max_element+1, i):\n                    self.minFactor[j] = i\n    def getFactorSet(self, element):\n        retSet = set(1)\n        while element > 1:\n            retSet.add(element)\n            retSet.add(self.minFactor[element])\n            element //= self.minFactor[element]\n        return retSet\n    def getPrimeFactorSet(self, element):\n        retSet = set()\n        while element > 1:\n            retSet.add(self.minFactor[element])\n            element //= self.minFactor[element]\n        return retSet\n    def getPrimeFactorDic(self, element):\n        retDic = {}\n        while element > 1:\n            val = self.minFactor[element]\n            if val in retDic:\n                retDic[val] += 1\n            else:\n                retDic[val] = 1\n            element //= val\n        return retDic\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = True\n    fact = Factor(max(a))\n    st = set()\n    for v in a:\n        fac_set = fact.getPrimeFactorSet(v)\n        for u in fac_set:\n            if u in st:\n                f = False\n                break\n            st.add(u)\n        if not f:\n            break\n    if f:\n        print(\"pairwise coprime\")\n    else:\n        all_gcd = a[0]\n        for i in range(1, n):\n            all_gcd = gcd(all_gcd, a[i])\n        if all_gcd == 1:\n            print(\"setwise coprime\")\n        else:\n            print(\"not coprime\")\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python\nfrom math import sqrt\nfrom collections import Counter\n\ndef gen_primes(X):\n    D = [0] * (X+1)\n    is_prime = [True for _ in range(0, X+1)]\n    is_prime[0] = False\n    is_prime[1] = False\n    primes = []\n    for n in range(2, int(sqrt(X))+1):\n        if is_prime[n]:\n            primes.append(n)\n            j = n*2\n            D[n] = n\n            while j <= X:\n                is_prime[j] = False\n                if D[j] == 0:\n                    D[j] = n\n                j += n\n    for n in range(int(sqrt(X)), X+1):\n        if is_prime[n]:\n            D[n] = n\n            primes.append(n)\n    return primes, D\n\n\ndef solve(A):\n    N = len(A)\n    primes, D = gen_primes(10**6)\n    C = [0] * (primes[-1]+1)\n\n    for a in A:\n        a_ = a\n        while a > 1:\n            d = D[a]\n            while a % d == 0:\n                a //= d\n            C[d] += 1\n        \n    M = max(C)\n    if M <= 1:\n        print(\"pairwise coprime\")\n    elif M != N:\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\n\n#solve([x for x in range(1, 10**6+1)])\nN = int(input())\nA = [int(x) for x in input().split()]\nsolve(A)\n", "\"\"\"E.\"\"\"\n\nimport sys\n\n\ndef input() -> str:  # noqa: A001\n    \"\"\"Input.\"\"\"\n    return sys.stdin.readline()[:-1]\n\n\nRESULT_TEXT = {\n    1: 'pairwise coprime',\n    2: 'setwise coprime',\n    3: 'not coprime',\n}\n\nn = int(input())\n\na_list = list(map(int, input().split(' ')))\n\nans = 0\n\nMAX = 1000000 + 1\ncounts = [0] * MAX\nfor a in a_list:\n    counts[a] += 1\n\nmax_count = 0\n\nfor i in range(2, MAX):\n    max_count = max(max_count, sum(counts[i::i]))\n\nif max_count == n:\n    ans = 3\nelif max_count >= 2:\n    ans = 2\nelse:\n    ans = 1\n\nprint((RESULT_TEXT[ans]))\n", "from math import gcd\nn=int(input())\nl=list(map(int,input().split()))\nmal=max(l)\ne=[i for i in range(mal+1)]\n\nx=2\nwhile x*x <= mal:\n    if x == e[x]:\n        for m in range(x, len(e), x):\n            if e[m] == m:\n                e[m] = x\n    x+=1\n#print(e)    \ns=set()\nf=0\nfor i in l:\n  st = set()\n  while i > 1:\n    st.add(e[i])\n    i//=e[i]\n  if not s.isdisjoint(st):\n    f=1\n    break\n  s |= st\n\nif f==0:\n    print('pairwise coprime')\n    return\np=l[0]\nfor i in range(1,n):\n    p=gcd(p,l[i])\nif p==1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**6)\n    input = sys.stdin.readline\n    N = int(input())\n    A = [int(x) for x in input().strip().split()]\n    maxA = max(A)\n    if maxA == 1:\n        print('pairwise coprime')\n        return\n    prime = [i if i % 2 != 0 else 2 for i in range(maxA+1)]\n    f = [False] * (maxA+1)\n    for i in range(3, int(maxA**.5)+1):\n        if prime[i] != i:\n            continue\n        p = i * 2\n        while p <= maxA:\n            if prime[p] == p:\n                prime[p] = i\n            p += i\n\n    def gcd(x, y):\n        if y == 0:\n            return x\n        return gcd(y, x % y)\n\n    setwise_coprime = A[0]\n    for An in A[1:]:\n        setwise_coprime = gcd(setwise_coprime, An)\n        if setwise_coprime == 1:\n            break\n    # print(prime)\n    for An in A:\n        if An == 1:\n            continue\n        # print('An = {}'.format(An))\n        not_pairwise_coprime = False\n        while prime[An] != An:\n            # print('prime[An]={}, f[prime[An]]={}'.format(prime[An], f[prime[An]]))\n            if f[prime[An]]:\n                not_pairwise_coprime = True\n                break\n            f[prime[An]] = True\n            prime_An = prime[An]\n            while An % prime_An == 0:\n                An //= prime_An\n        else:\n            if An != 1:\n                if f[An]:\n                    not_pairwise_coprime = True\n                else:\n                    f[An] = True\n        if not_pairwise_coprime:\n            break\n        # print(f)\n    else:\n        print('pairwise coprime')\n        return\n    if setwise_coprime == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\n\n# \u89e3\u8aacAC(a*loga)\nans = 0\ncnt = [0] * (max(a) + 1)\nfor ai in a:\n    ans = gcd(ans, ai)\n    cnt[ai] += 1\n\nif ans != 1:\n    print('not coprime')\nelif any(sum(cnt[i::i]) > 1 for i in range(2, max(a) + 1)):\n    print('setwise coprime')\nelse:\n    print('pairwise coprime')\n", "n = int(input())\na = list(map(int, input().split()))\n\nnum = [0]*(10**6+1)\n\nfor x in a:\n    num[x] += 1\n\nf = 1\nfor i in range(2, 10**6+1):\n    s = sum(num[i::i])\n    if s == n:\n        print(\"not coprime\")\n        return\n    if s > 1 :\n        f = 0\nif f == 0:\n    print(\"setwise coprime\")\nelse:\n    print(\"pairwise coprime\")"]
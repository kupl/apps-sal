["#!/usr/bin/env python3\n# 598D_Igor.py - Codeforces.com/problemset/problem/598/D by Sergey 2015\n\nimport unittest\nimport sys\nfrom collections import deque\n\n###############################################################################\n# Igor Class (Main Program)\n###############################################################################\n\n\ndef empty_around(i, rc, n, m, nw, mw):\n    w = 32\n    r = (i // m) // w\n    c = (i % m) // w\n    j = r * mw + c\n    if j < len(rc):\n        if rc[j] == 0:\n            rc[j] = 1\n            return True, r, c\n    return False, 0, 0\n\n\ndef fill_around(a, r0, c0, to_visit, visited, n, m):\n    w = 32\n    for r in range(w):\n        for c in range(w):\n            i = (r0 * w + r) * m + (c0 * w + c)\n            if (r == 0 or r == w - 1 or c == 0 or c == w - 1):\n                if a[i] == 0:\n                    to_visit.append(i)\n                    a[i] = 1\n            else:\n                a[i] = 2\n                visited.append(i)\n\n\nclass Igor:\n    \"\"\" Igor representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        self.result = []\n        w = 32\n        n, m, k = [int(x) for x in uinput().split()]\n        d0, d1, d2, d3 = -m, 2*m, -m-1, 2\n        a = []\n        rc = []\n        rr = []\n        mw = m // w\n        nw = n // w\n        for _ in range(n):\n            row = [(0 if v == '.' else 3) for v in uinput()]\n            a += row\n            rc += [sum(row[i*w:i*w+w]) for i in range(mw)]\n        for i in range(nw):\n            j = i*mw*w\n            rr += [sum([rc[j+u*mw+v] for u in range(w)]) for v in range(mw)]\n        to_visit = deque()\n        for _ in range(k):\n            x0, y0 = [int(x)-1 for x in uinput().split()]\n            i0 = x0*m+y0\n            step = 0\n            if a[i0] > 3:\n                self.result.append(a[i0])\n            else:\n                ans = 0\n                to_visit.append(i0)\n                visited = deque()\n                step += 1\n                while to_visit:\n                    i = to_visit.pop()\n                    if a[i] == 2:\n                        continue\n                    visited.append(i)\n                    if step % w == 1:\n                        e, r0, c0 = empty_around(i, rr, n, m, nw, mw)\n                    else:\n                        e = False\n                    a[i] = 2\n                    if e:\n                        fill_around(a, r0, c0, to_visit, visited, n, m)\n                    for d in (d0, d1, d2, d3):\n                        i += d\n                        if a[i] == 0:\n                            to_visit.append(i)\n                            a[i] = 1\n                        elif a[i] == 3:\n                            ans += 1\n                self.result.append(ans)\n                for i in visited:\n                    a[i] = ans\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        return str(\"\\n\".join(map(str, self.result)))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Igor class testing \"\"\"\n\n        # Constructor test\n        test = \"5 6 3\\n******\\n*..*.*\\n******\\n*....*\\n******\\n2 2\\n2 5\\n4 3\"\n        d = Igor(test)\n\n        # Sample test\n        self.assertEqual(Igor(test).calculate(), \"6\\n4\\n10\")\n\n        # Sample test\n        test = \"\"\n        # self.assertEqual(Igor(test).calculate(), \"0\")\n\n        # Sample test\n        test = \"\"\n        # self.assertEqual(Igor(test).calculate(), \"0\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Igor(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Igor(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Igor().calculate())\n\n__starting_point()", "import sys\nfrom queue import deque\n\n# sys.stdin = open('ivo.in')\n\nmove = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nn, m, k = map(int, sys.stdin.readline().split())\n\na = []\nfor i in range(n):\n    a.append(sys.stdin.readline().rstrip())\n\n\nvisited = []\nvalues = []\nfor x in range(n):\n    visited.append([])\n    values.append([])\n    for y in range(m):\n        visited[x].append(False)\n        values[x].append(0)\n\n\nfor x in range(n):\n    for y in range(m):\n        if a[x][y] == '*' or visited[x][y]:\n            continue\n        q = deque()\n        visited[x][y] = True\n        q.append((x, y))\n        sum = 0\n        connected = [(x, y)]\n        while len(q) != 0:\n            cur = q.pop()\n            for l in move:\n                tx = cur[0] + l[0]\n                ty = cur[1] + l[1]\n                if tx < 0 or tx >= n or ty < 0 or ty >= m:\n                    continue\n                if a[tx][ty] == '.' and visited[tx][ty]:\n                    continue\n                if a[tx][ty] == '*':\n                    sum += 1\n                    continue\n                q.append((tx, ty))\n                visited[tx][ty] = True\n                connected.append((tx, ty))\n        for c in connected:\n            values[c[0]][c[1]] = sum\n\nfor i in range(k):\n    x, y = map(int, sys.stdin.readline().split())\n    print(values[x - 1][y - 1])", "import sys\n \ndef get_array(): return list(map(int, sys.stdin.readline().split()))\ndef get_ints(): return map(int, sys.stdin.readline().split())\ndef input(): return sys.stdin.readline().strip('\\n')\n \n \nvisited = []\nout = []\n \nfor i in range(1010):\n    visited.append([])\n    out.append([])\n    for j in range(1010):\n        visited[i].append(0)\n        out[i].append(-1)\n\n\ndef dfs(x,y):\n    cells = []\n    c = 0\n    Q = [(x,y)]\n    while Q:\n        x,y = Q.pop()\n        if x >= n or x < 0 or y >= m or y < 0:\n            return\n        if l[x][y] == '*':\n            c += 1\n            continue\n        if visited[x][y] :\n           continue\n        visited[x][y] = 1\n        cells.append((x,y))\n        Q.append((x+1,y))\n        Q.append((x-1,y))\n        Q.append((x,y+1))\n        Q.append((x,y-1))\n    \n    for x in cells:\n        if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\n            out[x[0]][x[1]] = c\n \nn , m , k = get_ints()\nl = []\nfor i in range(n):\n    l.append(input())\n \nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j] and l[i][j] == '.':\n            dfs(i,j)\n            \nfor i in range(k):\n    x , y = get_ints()\n    x , y = x-1 , y-1\n    ans = out[x][y]\n    print(ans)", "import sys\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\ndef get_ints(): return map(int, sys.stdin.readline().split())\ndef input(): return sys.stdin.readline().strip('\\n')\n\nvisited = []\nout = []\n\nfor i in range(1010):\n    visited.append([])\n    out.append([])\n    for j in range(1010):\n        visited[i].append(0)\n        out[i].append(-1)\ncells = []\ndef dfs(x,y):\n    nonlocal c\n    Q = [(x,y)]\n    while Q:\n        x,y = Q.pop()\n        if x >= n or x < 0 or y >= m or y < 0:\n            continue\n        if l[x][y] == '*':\n            c += 1\n            continue\n        if visited[x][y] :\n            continue\n        visited[x][y] = 1\n        cells.append((x,y))\n        Q.append((x+1,y))\n        Q.append((x,y+1))\n        Q.append((x-1,y))\n        Q.append((x,y-1))\n\nn , m , k = get_ints()\nl = []\nfor i in range(n):\n    l.append(list(input()))\n\nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j] and l[i][j] == '.':\n            c = 0\n            dfs(i,j)\n            for x in cells:\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\n                    out[x[0]][x[1]] = c\n            cells.clear()\nfor i in range(k):\n    x , y = get_ints()\n    x , y = x-1 , y-1\n    ans = out[x][y]\n    print(ans)", "import sys\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\ndef input(): return sys.stdin.readline().strip('\\n')\n\ncells = []\n\n''' Using pajenegod dfs '''\ndef dfs(x,y):\n    nonlocal c\n    q = [(x,y)]\n\n    while q:\n        x, y = q.pop()\n        if x >= n or x < 0 or y >= m or y < 0:\n            continue\n        if l[x][y] == '*':\n            c += 1\n            continue\n        if visited[x][y]:\n            continue\n        \n        visited[x][y] = 1\n        cells.append((x,y))\n        q.append((x+1,y))\n        q.append((x,y+1))\n        q.append((x-1,y))\n        q.append((x,y-1))\n\nn , m , k = get_ints()\nl = []\nfor i in range(n):\n    l.append(list(input()))\n\nvisited = []\nout = []\n\nfor i in range(n+10):\n    visited.append([0]*(m+10))\n    out.append([-1]*(m+10))\n    \nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j] and l[i][j] == '.':\n            c = 0\n            dfs(i,j)\n            for x in cells:\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\n                    out[x[0]][x[1]] = c\n            cells.clear()\nfor i in range(k):\n    x , y = get_ints()\n    x , y = x-1 , y-1\n    print(out[x][y])\n", "import sys\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\ndef input(): return sys.stdin.readline().strip('\\n')\n\ncells = []\n\n''' Using Pajenegod's dfs '''\ndef dfs(x,y):\n    nonlocal c\n    q = [(x,y)]\n\n    while q:\n        x, y = q.pop()\n        if x >= n or x < 0 or y >= m or y < 0:\n            continue\n        if l[x][y] == '*':\n            c += 1\n            continue\n        if visited[x][y]:\n            continue\n        \n        visited[x][y] = 1\n        cells.append((x,y))\n        q.append((x+1,y))\n        q.append((x,y+1))\n        q.append((x-1,y))\n        q.append((x,y-1))\n\nn , m , k = get_ints()\nl = []\nfor i in range(n):\n    l.append(list(input()))\n\nvisited = []\nout = []\n\nfor i in range(n+10):\n    visited.append([0]*(m+10))\n    out.append([-1]*(m+10))\n    \nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j] and l[i][j] == '.':\n            c = 0\n            dfs(i,j)\n            for x in cells:\n                if visited[x[0]][x[1]] and out[x[0]][x[1]] == -1:\n                    out[x[0]][x[1]] = c\n            cells.clear()\nfor i in range(k):\n    x , y = get_ints()\n    x , y = x-1 , y-1\n    print(out[x][y])\n"]
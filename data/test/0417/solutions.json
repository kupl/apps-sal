["def solve():\n    N, X, D = list(map(int, input().split()))\n\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N+1))\n        return\n\n    LRss = {}\n    for k in range(N+1):\n        m = X*k\n        rem = m%D\n        minCoef = m//D + k*(k-1)//2\n        maxCoef = m//D + k*(2*N-k-1)//2\n        if rem not in LRss:\n            LRss[rem] = [(minCoef, maxCoef)]\n        else:\n            LRss[rem].append((minCoef, maxCoef))\n\n    ans = 0\n    for rem, LRs in list(LRss.items()):\n        LRs.sort()\n        LNow, RNow = LRs[0]\n        for L, R in LRs[1:]:\n            if L <= RNow:\n                if R > RNow:\n                    RNow = R\n            else:\n                ans += RNow - LNow + 1\n                LNow, RNow = L, R\n        ans += RNow - LNow + 1\n\n    print(ans)\n\n\nsolve()\n", "from collections import defaultdict\nn, a, d = map(int, input().split())\nif d == 0:\n    print(1 if a == 0 else n + 1)\n    return\nif d < 0:\n    a, d = -a, -d\ndic = defaultdict(list)\nfor i in range(n + 1):\n    l = a * i + (i - 1) * i // 2 * d\n    r = a * i + (n - i + n - 1) * i // 2 * d\n    dic[l % d].append((l, r))\nres = 0\nfor p in dic.values():\n    p.sort()\n    r = -1000000000000000000\n    for t in p:\n        s, e = t\n        if r < s:\n            res += (e - s) // d + 1\n            r = e\n        if r < e:\n            res += (e - r) // d\n            r = e\nprint(res)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n# \u7dcf\u548c\u306f\u4e00\u5b9a\u306a\u306e\u3067\u9ad8\u6a4b\u541b\u304c\u4f55\u70b9(?)\u3068\u308b\u304b\u306e\u554f\u984c\u306b\u7f6e\u304d\u63db\u3048\u3089\u308c\u308b\n# d=0\u304b\u3064x=0\u306e\u3068\u304d\u306f1\u3001x!=0\u306a\u3089n+1\u3067\u78ba\u5b9a\n# d,x\u3068-d,-x\u306f\u540c\u5024\u306a\u306e\u3067\u3001d\u3092\u6b63\u306b\u3059\u308b\u3053\u3068\u3067\u5897\u52a0\u6570\u5217\u3067\u8003\u3048\u308b\n# d,x\u3092\u540c\u3058\u6570\u3067\u5272\u3063\u3066\u3082\u7b54\u3048\u306f\u5909\u308f\u3089\u306a\u3044\u306e\u3067\u3001\u4e92\u3044\u306b\u7d20\u306b\u3059\u308b\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef main():\n    n, x, d = MI()\n    if d == 0:\n        if x == 0:\n            print(1)\n        else:\n            print(n + 1)\n        return\n    if d < 0: d, x = -d, -x\n    g = gcd(d, abs(x))\n    d, x = d // g, x // g\n    #print(x, d)\n    # a\u3092k\u500b\u9078\u3076\u3068\u548cs\u306fs=k*x+c*d\u3067\u3001c\u306f\u6700\u5c0f\u30670\u304b\u3089k-1\u306e\u548c\n    # \u6700\u5927\u3067n-k\u304b\u3089n-1\u306e\u548c\n    # k\u3092\u56fa\u5b9a\u3059\u308b\u3068s//d\u306f1\u305a\u3064\u306e\u5358\u8abf\u5897\u52a0\u306a\u306e\u3067\u3001\u6700\u5c0f\u3068\u6700\u5927\u3067\u500b\u6570\u304c\u5206\u304b\u308b\n    # s\u306fs mod d = x*k mod d\u304c\u540c\u3058\u306a\u306e\u3067\u3001\u305d\u308c\u3067\u5206\u985e\u3059\u308b\n    kk = list(range(n + 1))\n    kk.sort(key=lambda k: (k * x % d, k))\n    #print(kk)\n    ans = 0\n    pmd = -1\n    pl, pr = 1, 0\n    for k in kk:\n        l = (k * x + (k - 1) * k // 2 * d) // d\n        r = (k * x + (2 * n - k - 1) * k // 2 * d) // d\n        md = x * k % d\n        if md == pmd and l <= pr and pl<=r:\n            pl,pr=min(pl,l),max(pr,r)\n        else:\n            ans += pr - pl + 1\n            pl, pr = l, r\n        pmd = md\n        #print(k, l, r, pl, pr, ans)\n    ans += pr - pl + 1\n    print(ans)\n\nmain()\n", "import sys\nfrom fractions import gcd\nn, x, d = map(int, input().split())\n\nif x == 0 and d == 0:\n\tprint(1)\n\treturn\nelif d == 0:\n\tprint(n+1)\n\treturn\n\nif x < 0 and x + (n-1) * d < 0:\n\tx, d = -x, -d\n\nif x >= 0 and d < 0:\n\tx, d = x + (n-1) * d, -d\n\ng = gcd(x, d)\n\nans = 1\nif x >= 0:\n\tfor i in range(1, n+1):\n\t\tk = max((i - d//g) * (2*n - 1 - i + d//g) // 2 - x//g, i * (i-1) // 2 - 1)\n\t\tans += max((i * (2*n-1-i)) // 2 - k, 0)\n\nelse:\n\tfor i in range(1, n+1):\n\t\toverlap_u = min((i - d//g) * (2*n - 1 - i + d//g) // 2 - x//g, i * (2*n-1-i) // 2)\n\t\toverlap_l = max((i - d//g) * (i - d//g - 1) // 2 - x//g, i * (i-1) // 2)\n\t\tans += i * (2*n-1-i) // 2 - i * (i-1) // 2 + 1 - max(overlap_u - overlap_l + 1, 0)\n\nprint(ans)", "import fractions\nimport sys\n\nN,X,D = list(map(int,input().split()))\n\n\"\"\"\n\nX+0D\nX+1D\nX+2D\n...\nX+(N-1)D\n\n\u304b\u3089\u3068\u3063\u3066\u304f\u308b\n\naX + bD\n\naX\u4e2d\u306blcm\u304ct\u3053\u3042\u308b\u3068\u304d\u3001 newa = (aX-t*lcm) // X = a - t*lcm//X\nnewl += lcm*t // D\n\n\u3067\u3001aX > lcm(X,D)\u3060\u3063\u305f\u3089a\u3092\u3078\u3089\u3057\u3066?\u306e\u7bc4\u56f2\u3092\u3046\u3057\u308d\u306b\u305a\u3089\u3059\n\u5404a\u306b\u3064\u3044\u3066\u8a08\u7b97\u91cf\u306fO(1)\n\n3,4,2\u306e\u3068\u304d\n4\n6\n8\nlcm = 4\n\n0,4,6,8,10,12,14,18\n\nXD\u4e21\u65b9\u8ca0\u3060\u3068\u554f\u984c\u306a\u3057\nD\u304c\u8ca0\u306e\u6642 >> \u5927\u4e8b\u306a\u306e\u306f aX\u3092\u5909\u63db\u3067\u304d\u308b\u306a\u3089D\u306b\u3059\u308b>a\u3092\u6e1b\u3089\u3059\n?X > !D\u306b\u3059\u308b\n\nX  D\n3 -3\n\nX + 0D = 3\nX + 1D = 0\n\n0X = 0\n1X + \n\nlcm = 3\n\u306a\u306e\u3067,0\u306f X+-1D\u306b\u5909\u63db\u53ef\u80fd\n\n0 100 200 300\n\n\"\"\"\n\nif X == 0 and D == 0:\n    print((1))\n    return\nelif D == 0:\n    print((N+1))\n    return\nelif X == 0:\n    print((N * (N-1) // 2 + 1 ))\n    return\n\nl = [ [] for i in range(N+1)]\nr = [ [] for i in range(N+1)]\nlcm = X*D // fractions.gcd(X,D)\n\n\nbl = 0\nbr = 0\n\n\nfor a in range(N+1):\n\n\n    if a > 0:\n        bl += a-1\n        br += N-a\n\n    #print (bl,br)\n\n    t = (a*X) // lcm\n    #print (a,t*lcm//X)\n    a -= t*lcm // X\n\n    l[a] .append(bl + lcm*t // D)\n    r[a] .append(br + lcm*t // D)\n\nans = 0\n\n\nfor a in range(N+1):\n\n    now = 0\n    nl = 0\n    lind = 0\n    rind = 0\n    l[a].sort()\n    r[a].sort()\n    \n    for i in range(2 * len(l[a])):\n\n        if rind == len(r[a]) or (lind != len(l[a]) and l[a][lind] <= r[a][rind]):\n            if now == 0:\n                nl = l[a][lind]\n            now += 1\n            lind += 1\n        else:\n            now -= 1\n            if now == 0:\n                ans += r[a][rind] - nl + 1\n            rind += 1\n        \n \n\n#print (l)\n#print (r)\nprint (ans)\n", "from collections import defaultdict\nri = lambda : list(map(int, input().split(' ')))\n\n\ndef solve():\n    n, a, d = ri()\n\n    if d == 0:\n        print(1 if a == 0 else n + 1)\n        return\n\n    if d < 0:\n        a, d = -a, -d\n\n    dic = defaultdict(list)\n    for i in range(n + 1):\n        l = a * i + i * (i - 1) // 2 * d\n        r = a * i + (n-i + n-1)*i // 2 * d\n        dic[l % d].append((l // d, r // d + 1))\n    \n    ans = 0\n    for p in dic.values():\n        end = -1e18\n        p.sort()\n        for t in p:\n            s, e = t\n            if end < s:\n                ans += (e-s)\n                end = e\n            if end < e:\n                ans += (e - end)\n                end = e\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "from collections import defaultdict\nn, x, d = list(map(int, input().split()))\n\nif d == 0:\n    if x == 0:\n        ans = 1\n    else:\n        ans = n + 1\nelse:\n    if d < 0:\n        x, d = -x, -d\n\n    intervals = defaultdict(list)\n    for i in range(n + 1):\n        # [l, r]\n        l = i * (i - 1) // 2\n        r = i * (2 * n - i - 1) // 2\n\n        a = (x * i) % d\n        b = (x * i) // d\n        intervals[a].append((l + b, r + b))  # [l, r]\n    # print(intervals)\n\n    ans = 0\n    for interval in list(intervals.values()):\n        interval.sort()\n\n        l, r = interval[0]\n        ans += r - l + 1\n        for i in range(1, len(interval)):\n            li, ri = interval[i]\n            if ri <= r:\n                continue\n            elif li <= r:\n                ans += ri - (r + 1) + 1\n                l, r = li, ri\n            else:\n                ans += ri - li + 1\n                l, r = li, ri\n\nprint(ans)\n", "N, X, D = map(int, input().split())\n\nif not D:\n  if not X:\n    print(1)\n  else:\n    print(N+1)\n\nelse:\n  num_dict = dict()\n  ans = 0\n  for i in range(N+1):\n    left_num = int(i*X/D) + int(i*(i-1)/2)\n    right_num = int(i*X/D) + int(i*(2*N-1-i)/2)\n    judge_num = i*X%D\n    if not judge_num in num_dict:\n      num_dict[judge_num] = [(left_num,right_num)]\n    else:\n      num_dict[judge_num].append((left_num,right_num))\n\n  for j,k in num_dict.items():\n    new_k = sorted(k)\n    L = new_k[0][0]\n    R = new_k[0][1]\n    for l in new_k:\n      if l[0] <= R <= l[1]:\n        R = l[1]\n      elif R < l[0] and R < l[1]:\n        ans += R-L+1\n        L, R = l[0], l[1]\n    ans += R-L+1\n    \n  print(ans)", "LI = lambda: list(map(int, input().split()))\n\nN, X, D = LI()\n\n\ndef sumeq(n):\n    return n * (n + 1) // 2\n\n\ndef main():\n    if D == 0:\n        if X == 0:\n            ans = 1\n        else:\n            ans = N + 1\n        print(ans)\n        return\n    \n    d = {}\n    for i in range(N + 1):\n        a = i * X + sumeq(i - 1) * D\n        b = sumeq(N - 1) - sumeq(N - i - 1) - sumeq(i - 1)\n        v = (a - a % D) // D\n        if a % D in d:\n            d[a % D].append((v, b))\n        else:\n            d[a % D] = [(v, b)]\n    \n    ans = 0\n    for w in list(d.values()):\n        w.sort()\n        ans += w[0][1] + 1\n        x = w[0][0] + w[0][1]\n        n = len(w)\n        for i in range(1, n):\n            r = w[i][0] + w[i][1]\n            if x < w[i][0]:\n                ans += w[i][1] + 1\n            elif x < r:\n                ans += r - x\n            x = max(x, r)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from fractions import gcd\nfrom itertools import accumulate\n\n\ndef solve(n, x, d):\n    if d == 0:\n        return 1 if x == 0 else n + 1\n    elif d < 0:\n        x, d = -x, -d\n\n    g = gcd(x, d)\n    x //= g\n    d //= g\n\n    lowers = [0] + list(accumulate(list(range(n))))\n    uppers = [0] + list(accumulate(list(range(n - 1, -1, -1))))\n    ans = 0\n    for k_mod in range(min(n + 1, d)):\n        k = k_mod\n        offset = 0\n        endpoints = []\n        while k <= n:\n            endpoints.append((lowers[k] + offset, 0))\n            endpoints.append((uppers[k] + offset, 1))\n            k += d\n            offset += x\n        endpoints.sort()\n        opening = 0\n        current_left = 0\n        for s, t in endpoints:\n            if t == 0:\n                if opening == 0:\n                    current_left = s\n                opening += 1\n            else:\n                opening -= 1\n                if opening == 0:\n                    ans += s - current_left + 1\n\n    return ans\n\n\nn, x, d = list(map(int, input().split()))\nprint((solve(n, x, d)))\n", "def solve(N, X, D):\n    if D == 0:\n        if X == 0:\n            return 1\n        return N+1\n    L = {0: [(0, 1), (1, -1)]}\n    coef_l = 0\n    coef_r = 1\n    for coef_x in range(1, N+1):\n        m = X * coef_x % D\n        l = X * coef_x // D + coef_l\n        r = X * coef_x // D + coef_x * N - coef_r\n        coef_l = coef_r\n        coef_r += coef_x + 1\n        if m not in L:\n            L[m] = []\n        L[m].append((l, 1))\n        L[m].append((r+1, -1))\n    ans = 0\n    #print(L)\n    for Q in list(L.values()):\n        Q.sort()\n        cnt = 0\n        last = None\n        for val, sign in Q:\n            if cnt > 0:\n                ans += val - last\n            cnt += sign\n            last = val\n    return ans\n\nN, X, D = list(map(int, input().split()))\nprint((solve(N, X, D)))\n", "# Sum Difference\nfrom collections import defaultdict\nN, X, D = map(int, input().split())\nif D < 0:\n    X, D = -X, -D\n\nif D == 0:\n    Sets = set()\n    for i in range(N+1):\n        Sets.add(i*X)\n    print(len(Sets))\n    return\n\n# D>0\nans = 0\nMode = defaultdict(list)\nfor i in range(N+1):\n    L = (i*X+D*i*(i-1)//2-i*X % D)//D\n    R = (i*X+D*i*(2*N-1-i)//2-i*X % D)//D\n    Mode[i*X % D].append((L, 1))\n    Mode[i*X % D].append((R+1, -1))\nData = []\nfor key in Mode.keys():\n    Mode[key].sort()\n    cnt = 1\n    sums = Mode[key][0][0]\n    for num, which in Mode[key][1:]:\n        Data.append((sums, num, cnt))\n        cnt += which\n        sums = num\nans = 0\nfor l, r, v in Data:\n    if v > 0:\n        ans += r-l\nprint(ans)", "import numpy as np\nN, X, D = map(int, input().split())\n\nif not D:\n  if not X:\n    print(1)\n  else:\n    print(N+1)\n\nelse:\n  num_dict = dict()\n  ans = 0\n  for i in range(N+1):\n    left_num = int(i*X/D) + int(i*(i-1)/2)\n    right_num = int(i*X/D) + int(i*(2*N-1-i)/2)\n    judge_num = i*X%D\n    if not judge_num in num_dict:\n      num_dict[judge_num] = [(left_num,right_num)]\n    else:\n      num_dict[judge_num].append((left_num,right_num))\n\n  for j,k in num_dict.items():\n    new_k = sorted(k)\n    L = new_k[0][0]\n    R = new_k[0][1]\n    for l in new_k:\n      if l[0] <= R <= l[1]:\n        R = l[1]\n      elif R < l[0] and R < l[1]:\n        ans += R-L+1\n        L, R = l[0], l[1]\n    ans += R-L+1\n    \n  print(ans)", "N,X,D = map(int,input().split())\nif D==0:\n    print(1 if X==0 else N+1)\n    return\nif D < 0:\n    D *= -1\n    X -= D*(N-1)\n\nfrom collections import defaultdict\narrs = defaultdict(lambda: defaultdict(lambda: 0))\nmni = mxi = 0\nfor k in range(N+1):\n    d,m = divmod(k*X + D*mni, D)\n    l = mxi - mni + 1\n    arrs[m][d] += 1\n    arrs[m][d+l] -= 1\n    mni += k\n    mxi += N-k-1\n\nans = 0\nfor arr in arrs.values():\n    p = None\n    c = 0\n    for x,v in sorted(arr.items()):\n        if c > 0:\n            ans += x-p\n        c += v\n        p = x\nprint(ans)", "from collections import defaultdict\nfrom operator import itemgetter\n\ndef solve(N, X, D):\n    if D < 0:\n        D = -D\n        X = -X\n    elif D == 0:\n        if X == 0:\n            return 1\n        return N + 1\n\n    s = defaultdict(list)\n    for k in range(N+1):\n        p = k * X % D\n        q = k * X // D\n        a = k * (k - 1) // 2\n        b = (N - 1) * k - a + 1\n        s[p].append((a + q, b + q))\n\n    ans = 0\n    for v in list(s.values()):\n        if not v: continue\n        v.sort()\n        a, b = v[0]\n        for x, y in v[1:]:\n            if b < x:\n                ans += b - a\n                a, b = x, y\n            else:\n                b = max(b, y)\n        ans += b - a\n    return ans\n\n\ndef __starting_point():\n    N, X, D = list(map(int, input().split()))\n    print((solve(N, X, D)))\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nn, x, d = [int(item) for item in input().split()]\n\nif d == 0:\n    if x == 0:\n        print(1)\n    else:\n        print(n+1)\n    return\n\nrange_in_kXmodD = dict() \nfor i in range(0, n+1):\n    kXmodD = i * x % d\n    start = (i * x) // d + i * (i - 1) // 2\n    end = (i * x) // d + i * (n - i + n - 1) // 2 + 1\n    if kXmodD not in range_in_kXmodD:\n        range_in_kXmodD[kXmodD] = []\n    range_in_kXmodD[kXmodD].append((start, 1))\n    range_in_kXmodD[kXmodD].append((end, -1))\n\nans = 0\nfor key in range_in_kXmodD.keys():\n    range_in_kXmodD[key].sort()\n    ret = 0\n    cnt = 0\n    prev = None \n    for val, c in range_in_kXmodD[key]:\n        if prev != None and cnt > 0:\n            ret += val - prev\n        cnt += c\n        prev = val\n    ans += ret\n\nprint(ans)", "from fractions import gcd\nfrom itertools import accumulate\n\nn, x, d = list(map(int, input().split()))\n\nif d == 0:\n    if x == 0:\n        print((1))\n    else:\n        print((n + 1))\n    return\nelif d < 0:\n    x, d = -x, -d\n\ng = gcd(x, d)\nback_k = d // g\noffset = x // g\n\nlowers = [0] + list(accumulate(list(range(n))))\nuppers = [0] + list(accumulate(list(range(n - 1, -1, -1))))\nmin_memo = [10 ** 18] * min(n + 1, back_k)\nmax_memo = [-(10 ** 18)] * min(n + 1, back_k)\n# print(n, x, d, g, back_k, offset)\n# print(lowers)\n# print(uppers)\n\nans = 0\nfor k in range(n + 1):\n    min_acc = lowers[k]\n    max_acc = uppers[k]\n\n    if k < back_k:\n        min_memo[k] = min_acc - offset\n        max_memo[k] = max_acc - offset\n        ans += max_acc - min_acc + 1\n        # print(k, ans, min_acc, max_acc, max_acc - min_acc + 1)\n        continue\n\n    kk = k % back_k\n    back_min = min_memo[kk]\n    back_max = max_memo[kk]\n\n    if back_max < min_acc or max_acc < back_min:\n        min_memo[kk] = min_acc - offset\n        max_memo[kk] = max_acc - offset\n        ans += max_acc - min_acc + 1\n    else:\n        current = max_acc - min_acc + 1\n        duplicated = min(max_acc, back_max) - max(min_acc, back_min) + 1\n        ans += current - duplicated\n        min_memo[kk] = min(min_acc, back_min) - offset\n        max_memo[kk] = max(max_acc, back_max) - offset\n\n    # print(k, ans, min_acc, max_acc, back_min, back_max)\n\nprint(ans)\n", "import sys\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: list(map(int, readline().split()))\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  n, x, d = nm()\n  ans = 0\n  if d == 0:\n    print((1 if x == 0 else n+1))\n    return\n  if d < 0:\n    d = -d\n    x = -x\n  g = dict()\n  g[0] = [(0, 0)]\n  for i in range(1, n+1):\n    c, y = divmod(x * i, d)\n    # print((c, y))\n    f = (c + i*(i-1)//2, c + n*i - i*(i+1)//2)\n    if y not in g:\n      g[y] = list()\n    g[y].append(f)\n  for y in g:\n    f = sorted(g[y])\n    # print(f)\n    cx, cy = f[0]\n    for nx, ny in f:\n      if nx <= cy:\n        cx = min(nx, cx)\n        cy = max(ny, cy)\n      else:\n        ans += cy - cx + 1\n        cx, cy = nx, ny\n    ans += cy - cx + 1\n  print(ans)\n  return\n\nsolve()\n", "from fractions import gcd\n\n# inputa\nn , x , d = list(map(int, list(input().split())))\n\n# process\nif d == 0:\n    if x == 0:\n        print((1))\n    else:\n        print((n + 1))\n\nelse:\n    # s\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\n    \n    # d\u3092\u6b63\u306b\u3059\u308b\n    if d < 0: d, x = -d, -x\n\n    # d,x\u3092\u4e92\u3044\u306b\u7d20\u306b\u3059\u308b   \n    g = gcd(d, abs(x))\n    d, x =  d//g, x//g\n    \n    # s=k*x+c*d\n    # c\u306f\u6700\u5c0f\u30670\u304b\u3089k-1\u306e\u548c\u3001\u6700\u5927\u3067n-k\u304b\u3089n-1\u306e\u548c\n    # k\u3092\u56fa\u5b9a\u3059\u308b\u3068s//d\u306f1\u305a\u3064\u306e\u5358\u8abf\u5897\u52a0\u306a\u306e\u3067\u3001\u6700\u5c0f\u3068\u6700\u5927\u3067\u500b\u6570\u304c\u5206\u304b\u308b\n\n    # s\u306fs%d=k*x%d\u306a\u306e\u3067\u3001\u305d\u308c\u3067\u5206\u985e\u3059\u308b\n    # \u2192klist\u3092k*x%d\u3067\u30bd\u30fc\u30c8\n    klist = list(range(n + 1))\n    klist.sort(key=lambda k: (k*x%d, k))\n\n    # k\u3092\u56fa\u5b9a\u3057\u3001c\u306e\u6700\u5c0f\u30fb\u6700\u5927\u3092\u6c42\u3081\u3001\u52a0\u7b97\u3057\u3066\u3044\u304f\n    ans = 0\n\n    # 1\u3064\u524d\u306e\u5024\u3092\u4fdd\u6301\n    pmin, pmax = 1, 0\n    pmd = -1\n    for k in klist:\n        # s//d\u306e\u6700\u5c0f\u30fb\u6700\u5927\u30fbs%d\n        tmin = (k * x + (k - 1) * k // 2 * d) // d\n        tmax = (k * x + (2 * n - k - 1) * k // 2 * d) // d\n        tmd = k*x%d\n\n        # s%d\u304c\u524d\u3068\u540c\u3058\u3000\u304b\u3064\n        # s//d\u306e\u6700\u5c0f<=\u524d\u306e\u6700\u5927\u3000\u304b\u3064\u3000s//d\u306e\u6700\u5927>=\u524d\u306e\u6700\u5c0f\u306e\u3068\u304d\n        # \u6700\u5927\u30fb\u6700\u5c0f\u3092\u66f4\u65b0\n        if tmd == pmd and tmin <= pmax and tmax >= pmin:\n            pmin, pmax = min(pmin, tmin), max(pmax, tmax)\n        else:\n            ans += pmax - pmin + 1\n            pmin, pmax = tmin, tmax\n        pmd = tmd\n        \n    ans += pmax - pmin + 1\n    print(ans)\n", "from fractions import gcd\nfrom itertools import accumulate\n\nn, x, d = list(map(int, input().split()))\n\nif d == 0:\n    if x == 0:\n        print((1))\n    else:\n        print((n + 1))\n    return\nelif d < 0:\n    x, d = -x, -d\n\ng = gcd(x, d)\nback_k = d // g\noffset = x // g\n\nlowers = [0] + list(accumulate(list(range(n))))\nuppers = [0] + list(accumulate(list(range(n - 1, -1, -1))))\nmin_memo = [10 ** 18] * min(n + 1, back_k)\nmax_memo = [-(10 ** 18)] * min(n + 1, back_k)\n\n\nans = 0\nfor k in range(n + 1):\n    min_acc = lowers[k]\n    max_acc = uppers[k]\n\n    if k < back_k:\n        min_memo[k] = min_acc - offset\n        max_memo[k] = max_acc - offset\n        ans += max_acc - min_acc + 1\n      \n        continue\n\n    kk = k % back_k\n    back_min = min_memo[kk]\n    back_max = max_memo[kk]\n\n    if back_max < min_acc or max_acc < back_min:\n        min_memo[kk] = min_acc - offset\n        max_memo[kk] = max_acc - offset\n        ans += max_acc - min_acc + 1\n    else:\n        current = max_acc - min_acc + 1\n        duplicated = min(max_acc, back_max) - max(min_acc, back_min) + 1\n        ans += current - duplicated\n        min_memo[kk] = min(min_acc, back_min) - offset\n        max_memo[kk] = max(max_acc, back_max) - offset\n\n    \n\nprint(ans)\n", "from collections import defaultdict\nimport sys\nn, a, d = list(map(int, input().split(' ')))\n\nif d == 0:\n    print(1 if a == 0 else n + 1)\n    return\n\nif d < 0:\n    a, d = -a, -d\n\ndic = defaultdict(list)\nfor i in range(n + 1):\n    l = a * i + i * (i - 1) // 2 * d\n    r = a * i + (n-i + n-1)*i // 2 * d\n    dic[l % d].append((l // d, r // d + 1))\n\nans = 0\nfor p in dic.values():\n    end = -1e18\n    p.sort()\n    for t in p:\n        s, e = t\n        if end < s:\n            ans += (e-s)\n            end = e\n        if end < e:\n            ans += (e - end)\n            end = e\n\nprint(ans)", "import sys\n\ndef main():\n    n,x,d=list(map(int,input().split()))\n    events_map={}\n    if d==0:\n        if x== 0:\n            print((1))\n        else:\n            print((n+1))\n        return\n    for k in range(n+1):\n        l=(k*x if d > 0 else -k*x)+(k-1)*k//2*abs(d)\n        r=(k*x if d > 0 else -k*x)+(n-k+n-1)*k//2*abs(d)\n        row=l%abs(d)\n        if row not in events_map:\n            events_map[row]=[]\n        events_map[row].append((l,-1))\n        events_map[row].append((r,1))\n    ans=0\n    for q in list(events_map.items()):\n        events=q[1]\n        events.sort()\n        bal=0\n        total=0\n        curL=-1\n        for event in events:\n            if bal==0 and event[1]==-1:\n                curL=event[0]\n            if bal==1 and event[1] ==1:\n                curr=event[0]\n                total+=(curr-curL)//abs(d)+1\n            bal -= event[1]\n        ans+=total\n    print(ans)\n\nmain()\n", "import sys\nfrom fractions import gcd\nn, x, d = map(int, input().split())\n\"\"\"\n\u6570\u5217\u304b\u3089i\u500b\u9078\u3076\u3053\u3068\u3092\u8003\u3048\u308b\u3068\ni*x\u306b\u52a0\u3048\u3066\u8db3\u3055\u308c\u308bd\u306e\u6570\u306fi(i-1)/2 \u301c i(2n-1-i)/2 \u306e\u4efb\u610f\u306e\u500b\u6570\ni > j \u306a\u308bj\u3067\u4ee3\u66ff\u3055\u308c\u308b\u3088\u3046\u306a\u548c\u306f\u3053\u306e\u3046\u3061\u3069\u306e\u3088\u3046\u306a\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u304b\uff1f\ng = gcd(x, d). l = lcm(x, d)\u3068\u3057\u3066\n(g*l = x*d)\ni*x + k*d \u304c\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3068\u3059\u308b\u3068\ni*x + k*d = (i - d/g)x + (k + x/g)d \u304c\u6210\u308a\u7acb\u3064\n(i - d/g)(2n - 1 - i + d/g)/2 >= (k + x/g) \u3068\u306a\u308b\u3088\u3046\u306a\u6700\u5927\u306ek\u3092\u6c42\u3081\u308c\u3070\uff0c\nk\u4ee5\u4e0b\u306f\u3059\u3079\u3066\u304b\u3076\u308b\uff0ck+1\u4ee5\u4e0a\u306f\u3059\u3079\u3066\u304b\u3076\u3089\u306a\u3044\n\nx<0 \u306e\u3068\u304d\u306f\n(i - d//g) * (i - d//g - 1)//2 <= (k + x//g) <= (i - d//g) * (2*n - 1 - i + d//g)//2\n(i - d//g) * (i - d//g - 1)//2 - x//g <= k <= (i - d//g) * (2*n - 1 - i + d//g)//2 - x//g\n\u3068\u306a\u308b\u3088\u3046\u306ak\u306b\u304a\u3044\u3066\u306f\u304b\u3076\u308b\n\"\"\"\nif x == 0 and d == 0:\n\tprint(1)\n\treturn\nelif d == 0:\n\tprint(n+1)\n\treturn\n\nif x < 0 and x + (n-1) * d < 0:\n\tx, d = -x, -d\n\nif x >= 0 and d < 0:\n\tx, d = x + (n-1) * d, -d\n\n#print(x, d)\ng = gcd(x, d)\n\nans = 1\nif x >= 0:\n\tfor i in range(1, n+1):\n\t\t#print((i - d//g) * (2*n - 1 - i + d//g) // 2 - x//g)\n\t\tk = max((i - d//g) * (2*n - 1 - i + d//g) // 2 - x//g, i * (i-1) // 2 - 1)\n\t\t#print(k)\n\t\tans += max((i * (2*n-1-i)) // 2 - k, 0)\n\nelse:\n\tfor i in range(1, n+1):\n\t\toverlap_u = min((i - d//g) * (2*n - 1 - i + d//g) // 2 - x//g, i * (2*n-1-i) // 2)\n\t\toverlap_l = max((i - d//g) * (i - d//g - 1) // 2 - x//g, i * (i-1) // 2)\n\t\tans += i * (2*n-1-i) // 2 - i * (i-1) // 2 + 1 - max(overlap_u - overlap_l + 1, 0)\n\nprint(ans)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n,x,d = LI()\n    if d == 0:\n        if x == 0:\n            return 1\n        return n + 1\n\n    c = collections.defaultdict(list)\n    ad = n * (n-1) // 2 * d + x * n\n    # print(ad)\n    dd = abs(d)*2\n    for i in range(n+1):\n        u = ad - (x * i + ((i-1) * i // 2) * d) * 2\n        k = ad - (x * i + ((n-1 + n-i) * i // 2) * d) * 2\n        # print(\"iku\",i,k,u)\n        if k > u:\n            k,u = u,k\n        c[k%dd].append((k,u))\n\n    r = 0\n    for k, v in c.items():\n        v.sort()\n        # print(k,v)\n        a,b = v[0]\n        for t,u in v[1:]:\n            if t <= b:\n                if b < u:\n                    b = u\n            else:\n                r += (b-a) // dd + 1\n                # print(\"ab\",a,b,(abs(b-a)+dd), dd,r)\n                a,b = t,u\n        r += (b-a) // dd + 1\n\n    return r\n\n\nprint(main())\n\n\n", "from operator import itemgetter\n\nn, x, d = map(int, input().split())\n\nif d == 0:\n    if x == 0:\n        print(1)\n    else:\n        print(n+1)\n    return\nif d < 0:\n    x *= -1\n    d *= -1\n\np = dict()\nq = dict()\n\nfor k in range(n+1):\n    temp = k * x % d\n    if temp in p.keys():\n        #print((k - p[temp]) * x)\n        a = (k - p[temp]) * x // d\n        L = (k-1)*k//2 + a\n        H = (2*n-k-1)*k//2 + a\n        q[temp].append([L, H])\n    else:\n        p[temp] = k\n        L = (k-1)*k//2\n        H = (2*n-k-1)*k//2\n        q[temp] = [[L, H]]\n\nans = 0\n\nfor z in q.values():\n    c = - float('inf')\n    for a, b in sorted(z):\n        if a > c:\n            ans += b - a + 1\n        elif b > c:\n            ans += b - c\n        else:\n            continue\n        c = b\n\nprint(ans)", "N,X,D=list(map(int,input().split()))\n\nfrom collections import defaultdict\n\nA=defaultdict(list)\n\nA[0].append([0,0])\n\nMIN=0\nMAX=0\n\nif D==0:\n    w=1\nelse:\n    w=D\n\nfor i in range(N):\n    MIN+=X+D*i\n    MAX+=X+D*(N-1-i)\n\n    A[MIN%w].append(sorted([MIN,MAX]))\n\nD=abs(D)\nif D==0:\n    if X==0:\n        D=1\n    else:\n        D=X\nANS=0\n\nfor mod in A:\n    B=A[mod]\n    B.sort()\n    C=[]\n\n    for MIN,MAX in B:\n        \n        if C==[]:\n            C.append((MIN,MAX))\n        x,y=C[-1]\n\n        if y>=MIN:\n            C[-1]=(x,max(y,MAX))\n        else:\n            C.append((MIN,MAX))\n\n    for MIN,MAX in C:\n        ANS+=(MAX-MIN)//D+1\n    \nprint(ANS)\n", "from collections import defaultdict\n\nINF = float(\"inf\")\n\nN, X, D = map(int, input().split())\n\nif D == 0:\n    print(1 if X == 0 else N + 1)\n    return\n\nif D < 0:\n    X, D = -X, -D\n\nmemo = defaultdict(list)\nfor k in range(N + 1):\n    l = k * X + (k - 1) * k // 2 * D\n    r = k * X + (N - k + N - 1) * k // 2 * D\n    memo[l % D].append((l, r))\n\nans = 0\nfor LR in memo.values():\n    LR.sort()\n\n    cur = -INF\n    for l, r in LR:\n        if cur < l:\n            ans += (r - l) // D + 1\n            cur = r\n        if cur < r:\n            ans += (r - cur) // D\n            cur = r\n\nprint(ans)", "INF = 10**30\ndef solve(n, x, d):\n    if d == 0:\n        if x == 0:\n            return 1\n        else:\n            return n+1\n    D = {}\n    for k in range(n+1):\n        l = k*x + (k-1)*k//2*d\n        r = k*x + (n*k - k*(k+1)//2)*d\n        c = k*x % d\n        if not c in D:\n            D[c] = []\n        l = (l - c) // d\n        r = (r - c) // d\n        if l > r:\n            l, r = r, l\n        D[c].append((l, r))\n    res = 0\n    for v in D.values():\n        threshold = -INF\n        for l, r in sorted(v):\n            l = max(l, threshold)\n            res += max(0, r-l+1)\n            threshold = max(threshold, r+1)\n    return res\n\nn, x, d = map(int, input().split())\nprint(solve(n, x, d))", "#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\n\nINF = float(\"inf\")\n\n\ndef solve(N: int, X: int, D: int):\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N+1))\n        return\n\n    if D < 0:\n        X = X + (N-1)*D\n        D = abs(D)\n\n    segs = defaultdict(list)\n    for k in range(N+1):\n        L = k*(k-1)//2\n        R = k*N - k*(k+1)//2\n        Ck = k*X + D*L\n        Rk = R-L\n        seg = (Ck//D, Ck//D+Rk+1)\n        s = Ck % D\n        segs[s].append(seg)\n\n    tot = 0\n    for k in segs:\n        event = defaultdict(int)\n        for l, r in segs[k]:\n            event[l] += 1\n            event[r] -= 1\n\n        curr = 0\n        pre = -1\n        for k in sorted(event.keys()):\n            if curr > 0:\n                tot += k - pre\n            curr += event[k]\n            pre = k\n    print(tot)\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    X = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    solve(N, X, D)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from fractions import gcd\n\ndef main():\n    def fmin(m):\n        return X * m + D * m *(m - 1)//2\n    def fmax(m):\n        return X * m + D * m * (2 * N - m - 1) // 2\n    N, X, D = list(map(int, input().split()))\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N + 1))\n        return\n    if D < 0:\n        X, D = -X, -D\n    if X > 0:\n        ans = 0\n        g = gcd(X, D)\n        loop = D // g\n        for d in range(N + 1):\n            if loop <= d:\n                mmin = max(fmin(d), fmax(d - loop) + D)\n            else:\n                mmin = fmin(d)\n            mmax = fmax(d)\n            ans += (mmax - mmin) // D + 1\n        print(ans)\n    elif X == 0:\n        print((fmax(N) // D + 1))\n    else:\n        if X + D*(N - 1) >= 0:\n            ans = 0\n            g = gcd(-X, D)\n            loop = D // g\n            for d in range(N + 1):\n                dmax = fmax(d)\n                dmin = fmin(d)\n                if d < loop:\n                    ans += (dmax - dmin) // D + 1\n                else:\n                    pmax = fmax(d - loop)\n                    pmin = fmin(d - loop)\n                    if pmax < dmax and pmin <= dmin:\n                        mmin = max(dmin, pmax + D)\n                        ans += (dmax - mmin) // D + 1\n                    elif pmax >= dmax and pmin > dmin:\n                        mmax = min(dmax, pmin - D)\n                        ans += (mmax - dmin) // D + 1\n                    elif pmax < dmax and pmin > dmin:\n                        ans += (dmax - pmax) // D + (pmin - dmin) // D\n            print(ans)\n                    \n        else:\n            ans = 0\n            g = gcd(-X, D)\n            loop = D // g\n            for d in range(N + 1):\n                if loop <= d:\n                    mmax = min(fmax(d), fmin(d - loop) - D)\n                else:\n                    mmax = fmax(d)\n                mmin = fmin(d)\n                ans += (mmax - mmin) // D + 1\n            print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import queue\nimport math\nimport copy\n\"\"\"\nN = int(input())\n#S = input()\n# (N,M) = (int(i) for i in input().split(\" \"))\n# A = [int(i) for i in input().split()]\nA = []\nfor i in range(N):\n\tA.append(int(input()))\n\nprint(A)\n\n\"\"\"\n\n(N,X,D) = (int(i) for i in input().split(\" \"))\nmp = {}\nif D == 0:\n\tif X == 0:\n\t\tans = 1\n\telse:\n\t\tans = N+1\nelse:\n\tfor i in range(N+1):\n\t\tmd = (i*X)%D\n\t\tif not md in mp:\n\t\t\tmp[md] = []\n\t\tk = i*(i-1)//2\n\t\tmp[md].append([k+(((i*X)-md)//D),0])\n\t\tk = (N*2-i-1)*i//2\n\t\tmp[md].append([k+(((i*X)-md)//D)+1,1])\n\t#print(mp)\n\tans = 0\n\tfor k in mp.keys():\n\t\ts = sorted(mp[k])\n\t\t#print(s)\n\t\tmd = 0\n\t\tbef = 0\n\t\tfor t in s:\n\t\t\tif md > 0:\n\t\t\t\tans += t[0] - bef\n\t\t\tbef = t[0]\n\t\t\tif t[1] == 0:\n\t\t\t\tmd += 1\n\t\t\telse:\n\t\t\t\tmd -= 1\nprint(ans)", "def gcd(a: int, b: int)->int:\n    a, b = abs(a), abs(b)\n    if a < b:\n        a, b = b, a\n    return gcd(b, a % b) if b else a\n\n\ndef sum_seq1(l: int, r: int)->int:\n    if r < l:\n        return 0\n    return r*(r+1) // 2 - l*(l-1) // 2\n\n\ndef sum_difference(N: int, X: int, D: int)->int:\n    if D == 0:\n        if X == 0:\n            return 1\n        return N+1\n\n    # D != 0\n    g = gcd(X, D)\n    a, b = D // g, -X // g\n\n    if a < 0:\n        a *= -1\n        b *= -1\n    i_range = [(float('inf'), -float('inf'))] * (N+1)\n\n    ans = 0\n    for k in range(N+1):\n        kl, kr = i_range[k]\n        nl = sum_seq1(0, k-1)\n        nr = sum_seq1(N-k, N-1)\n        # print('k: ({}, {}), n: ({}, {})'.format(kl, kr, nl, nr))\n\n        if k+a <= N:\n            i_range[k+a] = (b+min(kl, nl), b+max(kr, nr))\n\n        if kr == -float('inf'):\n            ans += nr - nl + 1\n        elif kr < nl or nr < kl:\n            ans += nr - nl + 1\n        elif nl <= kl and kr <= nr:\n            ans += (nr-nl+1) - (kr-kl+1)\n        elif kl <= nl:\n            ans += max(0, nr-kr)\n        else:\n            ans += kl-nl\n\n    return ans\n\n\ndef __starting_point():\n    N, X, D = list(map(int, input().split()))\n    ans = sum_difference(N, X, D)\n    print(ans)\n\n__starting_point()", "from fractions import gcd\n\ndef main():\n    def fmin(m):\n        return X * m + D * m *(m - 1)//2\n    def fmax(m):\n        return X * m + D * m * (2 * N - m - 1) // 2\n    N, X, D = map(int, input().split())\n    if D == 0:\n        if X == 0:\n            print(1)\n        else:\n            print(N + 1)\n        return\n    if D < 0:\n        X, D = -X, -D\n    if X == 0:\n        print(fmax(N) // D + 1)\n    else:\n        ans = 0\n        g = gcd(-X, D)\n        loop = D // g\n        for d in range(N + 1):\n            dmax = fmax(d)\n            dmin = fmin(d)\n            if d < loop:\n                ans += (dmax - dmin) // D + 1\n            else:\n                pmax = fmax(d - loop)\n                pmin = fmin(d - loop)\n                if pmax < dmax and pmin <= dmin:\n                    mmin = max(dmin, pmax + D)\n                    ans += (dmax - mmin) // D + 1\n                elif pmax >= dmax and pmin > dmin:\n                    mmax = min(dmax, pmin - D)\n                    ans += (mmax - dmin) // D + 1\n                elif pmax < dmax and pmin > dmin:\n                    ans += (dmax - pmax) // D + (pmin - dmin) // D\n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from fractions import gcd\nfrom collections import defaultdict\n\nN, X, D = list(map(int, input().split()))\n\nif D == 0:\n    if X == 0:\n        ans = 1\n    else:\n        ans = N + 1\nelse:\n    if D < 0:\n        X = -X\n        D = -D\n    g = gcd(X, D)\n    X //= g\n    D //= g\n\n    AN = X + D * (N - 1)\n\n    intervals_dict = defaultdict(list)\n    for k in range(N + 1):\n        start = k * (2 * X + (k - 1) * D) // 2\n        end = k * (2 * AN - (k - 1) * D) // 2\n\n        intervals_dict[start % D].append((start // D, end // D + 1))\n\n    ans = 0\n    for k, v in list(intervals_dict.items()):\n        v.sort()\n\n        current_stop = -float(\"inf\")\n        for start, stop in v:\n            ans += max(stop, current_stop) - max(start, current_stop)\n            current_stop = max(current_stop, stop)\n\nprint(ans)\n"]
["def main():\n    n, k = tuple(map(int, input().split()))\n\n    a = [set(range(n)) for _ in range(n)]\n\n    for i in range(k):\n        p = set()\n        for j in map(int, input().split()):\n            a[j-1] -= p\n            p.add(j-1)\n\n    sa = sorted(list(range(n)), key=lambda i: len(a[i]))\n    maxx = [0] * n\n    res = 0\n    \n    for i in sa:\n        m = 1 + maxx[max(a[i], key=lambda e: maxx[e])] if a[i] else 0\n        maxx[i] = m\n        res = max(res, m)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n, k = list(map(int, input().split()))\nra = [[0] * k for _ in range(n)]\nfor p in range(k):\n    for i, v in enumerate(map(int, input().split())):\n        v -= 1\n        ra[v][p] = i\ng = [[] for _ in range(n)]\nfor u in range(n):\n    for v in range(n):\n        if all(x < y for x, y in zip(ra[u], ra[v])):\n            g[u].append(v)\n\nmemo = [-1] * n\ndef dfs(v):\n    if memo[v] != -1:\n        return memo[v]\n    r = 1\n    for u in g[v]:\n        r = max(r, dfs(u) + 1)\n    memo[v] = r\n    return r\n\nprint(max(dfs(s) for s in range(n)))\n        \n", "n, k = list(map(int, input().split()))\na, b = [[] for row in range(6)], [[0 for col in range(n + 1)] for row in range(6)]\n\nfor i in range(k):\n    a[i] = list(map(int, input().split()))\n    for j in range(n):\n        b[i][a[i][j]] = j\n\ndp = [1] * n\nfor i in range(n):\n    for j in range(i):\n        flag = 1\n        for x in range(1, k):\n            if b[x][a[0][j]] > b[x][a[0][i]]:\n                flag = 0\n                break\n        if flag:\n            dp[i] = max(dp[i], dp[j] + 1)\nprint(max(dp))\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/14/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, K, A, pos):\n    dp = [0 for _ in range(N+1)]\n    for i in range(1, N+1):\n        maxx = 0\n        for p in range(1, i):\n            # if the A[1][p], A[1][i] is the last two elements of ans\n            # A[1][p] should appears before A[1][i] at every input array A[1:]\n            if all([pos[k][A[1][p]] < pos[k][A[1][i]] for k in range(2, K+1)]):\n                maxx = max(maxx, dp[p])\n        dp[i] = maxx + 1\n    \n    return max(dp)\n\n\nN, K = map(int, input().split())\nA = [[0] * (N + 1)]\npos = [[0 for _ in range(N+1)] for _ in range(K+1)]\nfor i in range(K):\n    row = [0] + [int(x) for x in input().split()]\n    A.append(row)\n    for j, v in enumerate(row):\n        pos[i+1][v] = j\n\nprint(solve(N, K, A, pos))", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/14/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\nmemo = [0 for _ in range(1005)]\ndef longestpath(start, graph):\n    if memo[start] > 0:\n        return memo[start]\n    \n    l = 0\n    for v in graph[start]:\n        l = max(longestpath(v, graph), l)\n    memo[start] = l + 1\n    return l + 1\n\n\ndef solve_graph(N, K, A, pos):\n    # for each u, v if u appears before v in every array, add a link u->v\n    g = collections.defaultdict(list)\n    d = [0 for _ in range(N+1)]\n    for u in range(1, N+1):\n        for v in range(1, N+1):\n            if all([pos[k][u] < pos[k][v] for k in range(1, K+1)]):\n                g[u].append(v)\n                d[v] += 1\n    \n    # then find the longest path\n    ans = 0\n    for u in range(1, N+1):\n        if d[u] == 0:\n            ans = max(ans, longestpath(u, g))\n    return ans\n    \n\n\ndef solve(N, K, A, pos):\n    dp = [0 for _ in range(N+1)]\n    for i in range(1, N+1):\n        maxx = 0\n        for p in range(1, i):\n            # if the A[1][p], A[1][i] is the last two elements of ans\n            # A[1][p] should appears before A[1][i] at every input array A[1:]\n            if all([pos[k][A[1][p]] < pos[k][A[1][i]] for k in range(2, K+1)]):\n                maxx = max(maxx, dp[p])\n        dp[i] = maxx + 1\n    \n    return max(dp)\n\n\nN, K = map(int, input().split())\nA = [[0] * (N + 1)]\npos = [[0 for _ in range(N+1)] for _ in range(K+1)]\nfor i in range(K):\n    row = [0] + [int(x) for x in input().split()]\n    A.append(row)\n    for j, v in enumerate(row):\n        pos[i+1][v] = j\n\nprint(solve_graph(N, K, A, pos))", "#   ==========     //\\\\       //||     ||====//||\n#       ||        //  \\\\        ||     ||   // ||\n#       ||       //====\\\\       ||     ||  //  ||\n#       ||      //      \\\\      ||     || //   ||\n#   ========== //        \\\\  ========  ||//====|| \n#  code\n\ndef solve():\n    n, k = map(int, input().split())\n    c = [ [-1 for i in range(n + 1)] for i in range(k)]\n    dp = [0 for i in range(n + 1)]\n    a = []\n\n    for i in range(k):\n        b = list(map(int, input().split()))\n        for j, v in enumerate(b):\n            c[i][v] = j\n        a.append(b)\n\n    \n    for i in range(n):\n        curpos = a[0][i]\n        dp[i] = 1\n        for j in range(i):\n            prevpos = a[0][j]\n            ok = True\n            for p in range(k):\n                if c[p][curpos] < c[p][prevpos]:\n                    ok = False\n                    break\n            if ok:\n                dp[i] = max(dp[i], dp[j] + 1)\n    print(max(dp))\n    return\n\ndef main():\n    t = 1\n    # t = int(input())\n    for _ in range(t):\n        solve()\n\ndef __starting_point():\n    main()\n__starting_point()"]
["# cook your dish here\nn, m, k =map(int, input().split())\nblasters=[]\nfor _ in range(k):\n    blasters.append(list(map(int, input().split())))\ngrid=[[0 for _ in range(m)] for _ in range(n)]\nfor blaster in blasters:\n    flag=0\n    x, y, t, f = blaster\n    x-=1 \n    y-=1\n    grid[x][y]=-1\n    for i in range(n):\n        if i+y-t-abs(x-i)>=0 and (i+y-t-abs(x-i))%f==0:\n            if i>x:\n                flag=1\n            grid[i][y]=-1\n        if i>x and flag==0:\n            break\n    flag=0\n    for j in range(m):\n        if j+x-t-abs(y-j)>=0 and (j+x-t-abs(y-j))%f==0:\n            if j>y:\n                flag=1\n            grid[x][j]=-1\n        if j>y and flag==0:\n            break\nfor i in range(1,n):\n    if grid[i-1][0]==-1:\n        grid[i][0]=-1\nfor j in range(1,m):\n    if grid[0][j-1]==-1:\n        grid[0][j]=grid[0][j-1]\nfor i in range(1,n):\n    for j in range(1,m):\n        if grid[i][j-1]==-1 and grid[i-1][j]==-1:\n            grid[i][j]=-1\nif grid[-1][-1]==0:\n    print('YES')\n    print(n+m-2)\nelse:\n    print('NO')", "# cook your dish here\nn, m, k =map(int, input().split())\nblasters=[]\nfor _ in range(k):\n    blasters.append(list(map(int, input().split())))\ngrid=[[0 for _ in range(m)] for _ in range(n)]\nfor blaster in blasters:\n    x, y, t, f = blaster\n    x-=1 \n    y-=1\n    grid[x][y]=-1\n    for i in range(n):\n        if i+y-t-abs(x-i)>=0 and (i+y-t-abs(x-i))%f==0:\n            grid[i][y]=-1\n    for j in range(m):\n        if j+x-t-abs(y-j)>=0 and (j+x-t-abs(y-j))%f==0:\n            grid[x][j]=-1\nfor i in range(1,n):\n    if grid[i-1][0]==-1:\n        grid[i][0]=-1\nfor j in range(1,m):\n    if grid[0][j-1]==-1:\n        grid[0][j]=grid[0][j-1]\nfor i in range(1,n):\n    for j in range(1,m):\n        if grid[i][j-1]==-1 and grid[i-1][j]==-1:\n            grid[i][j]=-1\nif grid[-1][-1]==0:\n    print('YES')\n    print(n+m-2)\nelse:\n    print('NO')", "# cook your dish here\nn, m, k =map(int, input().split())\nblasters=[]\nfor _ in range(k):\n    blasters.append(list(map(int, input().split())))\ngrid=[[0 for _ in range(m)] for _ in range(n)]\nfor blaster in blasters:\n    x, y, t, f = blaster\n    x-=1 \n    y-=1\n    grid[x][y]=-1\n    for i in range(n):\n        if (i+y-t-abs(x-i))%f==0:\n            grid[i][y]=-1\n    for j in range(m):\n        if (j+x-t-abs(y-j))%f==0:\n            grid[x][j]=-1\nfor i in range(1,n):\n    if grid[i-1][0]==-1:\n        grid[i][0]=-1\nfor j in range(1,m):\n    if grid[0][j-1]==-1:\n        grid[0][j]=grid[0][j-1]\nfor i in range(1,n):\n    for j in range(1,m):\n        if grid[i][j-1]==-1 and grid[i-1][j]==-1:\n            grid[i][j]=-1\nif grid[-1][-1]==0:\n    print('YES')\n    print(n+m-2)\nelse:\n    print('NO')", "# cook your dish here\nn, m, k =map(int, input().split())\nblasters=[]\nfor _ in range(k):\n    blasters.append(list(map(int, input().split())))\ngrid=[[0 for _ in range(m)] for _ in range(n)]\nfor blaster in blasters:\n    x, y, t, f = blaster\n    x-=1 \n    y-=1\n    grid[x][y]=-1\n    for i in range(n):\n        if (i+y-t)%f==abs(x-i):\n            grid[i][y]=-1\n    for j in range(m):\n        if (j+x-t)%f==abs(y-j):\n            grid[x][j]=-1\nfor i in range(1,n):\n    if grid[i-1][0]==-1:\n        grid[i][0]=-1\nfor j in range(1,m):\n    if grid[0][j-1]==-1:\n        grid[0][j]=grid[0][j-1]\nfor i in range(1,n):\n    for j in range(1,m):\n        if grid[i][j-1]==-1 and grid[i-1][j]==-1:\n            grid[i][j]=-1\nif grid[-1][-1]==0:\n    print('YES')\n    print(n+m-2)\nelse:\n    print('NO')", "# cook your dish here\ndef main():\n\tfrom sys import stdin, stdout\n\trl = stdin.readline\n\n\t# Time taken to reach end is determined purely by size of grid\n\t# We simply need to determine if it is possible to reach it\n\n\t# Create dp table, mark all as visitable\n\t# Mark cells with blasters as unvisitable\n\n\t# Now, iterate over blasters.\n\t# For each blaster, check every cell in its row and col.\n\t# For each cell, there is a definite time at which spaceman can be at it\n\n\t# Pulse will take time t1 extra to reach cell after fire\n\t# Therefore, t0 should be = t1 + tstart + nf\n\t# Hence, we mod t0 - t1 - tstart with f\n\n\t# Finally, just try to find a path.\n\t# If a path exists, simply print n + m - 2 as the time to reach\n\n\tn, m, k = (int(x) for x in rl().split())\n\ta = [[int(x) for x in rl().split()] for _ in range(k)]\n\n\tdp = [[1] * m for _ in range(n)]\n\tfor b in a:\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\t\tdp[b[0]][b[1]] = 0\n\n\t\tx, y = b[0], 0\n\t\twhile y < m:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(y - b[1])\n\t\t\tif t_check < 0:  # Negative time is impossible\n\t\t\t\ty += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\ty += 1\n\n\t\tx, y = 0, b[1]\n\t\twhile x < n:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(x - b[0])\n\t\t\tif t_check < 0:\n\t\t\t\tx += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\tx += 1\n\n\tfor x in range(1, n):\n\t\tdp[x][0] = dp[x][0] and dp[x - 1][0]\n\n\tfor y in range(1, m):\n\t\tdp[0][y] = dp[0][y] and dp[0][y - 1]\n\n\tfor x in range(1, n):\n\t\tfor y in range(1, m):\n\t\t\tdp[x][y] = dp[x][y] and (dp[x - 1][y] or dp[x][y - 1])\n\n\tif dp[-1][-1]:\n\t\tstdout.write('YES\\n')\n\t\tstdout.write(str(n + m - 2))\n\telse:\n\t\tstdout.write('NO')\n\n\nmain()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Jul 16 13:36:30 2020\n\n@author: shubham gupta\n\"\"\"\n# cook your dish here\ndef main():\n\tfrom sys import stdin, stdout\n\trl = stdin.readline\n\tn, m, k = (int(x) for x in rl().split())\n\ta = [[int(x) for x in rl().split()] for _ in range(k)]\n\tdp = [[1] * m for _ in range(n)]\n\tfor b in a:\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\t\tdp[b[0]][b[1]] = 0\n\t\tx, y = b[0], 0\n\t\twhile y < m:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(y - b[1])\n\t\t\tif t_check < 0:  # Negative time is impossible\n\t\t\t\ty += 1\n\t\t\t\tcontinue\n\t\t\tif t_check % b[3] == 0:dp[x][y] = 0\n\t\t\ty += 1\n\n\t\tx, y = 0, b[1]\n\t\twhile x < n:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(x - b[0])\n\t\t\tif t_check < 0:\n\t\t\t\tx += 1\n\t\t\t\tcontinue\n\t\t\tif t_check % b[3] == 0:dp[x][y] = 0\n\t\t\tx += 1\n\tfor x in range(1, n):dp[x][0] = dp[x][0] and dp[x - 1][0]\n\tfor y in range(1, m):dp[0][y] = dp[0][y] and dp[0][y - 1]\n\tfor x in range(1, n):\n\t\tfor y in range(1, m):dp[x][y] = dp[x][y] and (dp[x - 1][y] or dp[x][y - 1])\n\tif dp[-1][-1]:\n\t\tstdout.write('YES\\n')\n\t\tstdout.write(str(n + m - 2))\n\telse:\n\t\tstdout.write('NO')\nmain()", "# cook your dish here\ndef main():\n\tfrom sys import stdin, stdout\n\trl = stdin.readline\n\n\t# Time taken to reach end is determined purely by size of grid\n\t# We simply need to determine if it is possible to reach it\n\n\t# Create dp table, mark all as visitable\n\t# Mark cells with blasters as unvisitable\n\n\t# Now, iterate over blasters.\n\t# For each blaster, check every cell in its row and col.\n\t# For each cell, there is a definite time at which spaceman can be at it\n\n\t# Pulse will take time t1 extra to reach cell after fire\n\t# Therefore, t0 should be = t1 + tstart + nf\n\t# Hence, we mod t0 - t1 - tstart with f\n\n\t# Finally, just try to find a path.\n\t# If a path exists, simply print n + m - 2 as the time to reach\n\n\tn, m, k = (int(x) for x in rl().split())\n\ta = [[int(x) for x in rl().split()] for _ in range(k)]\n\n\tdp = [[1] * m for _ in range(n)]\n\tfor b in a:\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\t\tdp[b[0]][b[1]] = 0\n\n\t\tx, y = b[0], 0\n\t\twhile y < m:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(y - b[1])\n\t\t\tif t_check < 0:  # Negative time is impossible\n\t\t\t\ty += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\ty += 1\n\n\t\tx, y = 0, b[1]\n\t\twhile x < n:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(x - b[0])\n\t\t\tif t_check < 0:\n\t\t\t\tx += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\tx += 1\n\n\tfor x in range(1, n):\n\t\tdp[x][0] = dp[x][0] and dp[x - 1][0]\n\n\tfor y in range(1, m):\n\t\tdp[0][y] = dp[0][y] and dp[0][y - 1]\n\n\tfor x in range(1, n):\n\t\tfor y in range(1, m):\n\t\t\tdp[x][y] = dp[x][y] and (dp[x - 1][y] or dp[x][y - 1])\n\n\tif dp[-1][-1]:\n\t\tstdout.write('YES\\n')\n\t\tstdout.write(str(n + m - 2))\n\telse:\n\t\tstdout.write('NO')\n\n\nmain()", "from sys import stdin\nip = lambda :[int(w) for w in stdin.readline().split()]\n\nn,m,k = [int(w) for w in stdin.readline().split()]\nsp = 2 if k == 1 else 0\ndp = [[1]*(m+1) for j in range(n+1)]\nfor j in range(k):\n    x,y,t,f = [int(w) for w in stdin.readline().split()]\n    dp[x][y] = 0\n    for i in range(1,n+1):\n        reach = i + y -2 - t - abs(x-i) +sp\n        if reach > 0 and reach % f == 0:\n            dp[i][y] = 0\n    for i in range(1,m+1):\n        reach = i + x -2 - t - abs(y-i) +sp\n        if reach > 0 and reach % f == 0:\n            dp[x][i] = 0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        dp[i][j] = dp[i][j] and (dp[i][j-1] or dp[i-1][j])\n\nif dp[-1][-1]:\n    print(\"YES\")\n    print(n+m-2)\nelse:\n    print(\"NO\")", "from sys import stdin\nip = lambda :[int(w) for w in stdin.readline().split()]\n\nn,m,k = [int(w) for w in stdin.readline().split()]\nsp = 2 if k == 1 else 0\ndp = [[1]*(m+1) for j in range(n+1)]\nfor j in range(k):\n    x,y,t,f = [int(w) for w in stdin.readline().split()]\n    dp[x][y] = 0\n    for i in range(1,n+1):\n        reach = i + y -2 - t - abs(x-i) +sp\n        if reach > 0 and reach % f == 0:\n            dp[i][y] = 0\n    for i in range(1,m+1):\n        reach = i + x -2 - t - abs(y-i) +sp\n        if reach > 0 and reach % f == 0:\n            dp[x][i] = 0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        cur,left,up = dp[i][j],dp[i][j-1],dp[i-1][j]\n        dp[i][j] = cur*left or cur*up\n\nif dp[-1][-1]:\n    print(\"YES\")\n    print(n+m-2)\nelse:\n    print(\"NO\")", "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\nipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda :int(input())\nip = lambda :[int(w) for w in input().split()]\n\nn,m,k = ip()\nlaz = [ip() for i in range(k)]\ndp = [[1 for i in range(m+1)] for j in range(n+1)]\nfor j in laz:\n    x,y,t,f = j\n    dp[x][y] = 0\n    for i in range(1,n+1):\n        reach = i + x - t - abs(y-i)\n        if reach > 0 and reach % f == 0:\n            dp[i][y] = 0\n    for i in range(1,m+1):\n        reach = i + y - t - abs(x-i)\n        if reach > 0 and reach % f == 0:\n            dp[x][i] = 0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        cur,left,up = dp[i][j],dp[i][j-1],dp[i-1][j]\n        dp[i][j] = cur*left or cur*up\n\nif dp[-1][-1]:\n    print(\"YES\")\n    print(n+m-2)\nelse:\n    print(\"NO\")\n\n\n\n", "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\nipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda :int(input())\nip = lambda :[int(w) for w in input().split()]\n\nn,m,k = ip()\nlaz = [ip() for i in range(k)]\ndp = [[1 for i in range(m+1)] for j in range(n+1)]\nfor j in laz:\n    x,y,t,f = j\n    dp[x][y] = 0\n    for i in range(1,n+1):\n        reach = i + y - t - abs(x-i)\n        if reach > 0 and reach % f == 0:\n            dp[i][y] = 0\n    for i in range(1,m+1):\n        reach = i + x - t - abs(y-i)\n        if reach > 0 and reach % f == 0:\n            dp[x][i] = 0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        cur,left,up = dp[i][j],dp[i][j-1],dp[i-1][j]\n        dp[i][j] = cur*left or cur*up\n\nif dp[-1][-1]:\n    print(\"YES\")\n    print(n+m-2)\nelse:\n    print(\"NO\")\n\n\n\n", "intput = lambda: [int(i) for i in input().split()]\n# Write your code here\nn, m, k = intput()\nblasters = [intput() for i in range(k)]\ngrid = [[1] * n for i in range(m)]\n\nfor bx, by, t, f in blasters:\n    bx -= 1\n    by -= 1\n    grid[by][bx] = 0\n    \n    for x in range(n):\n        k = x + by - abs(bx - x) - t\n        if k > 0 and k % f == 0:\n            grid[by][x] = 0\n    \n    for y in range(m):\n        k = bx + y - abs(by - y) - t\n        if k > 0 and k % f == 0:\n            grid[y][bx] = 0\n    \nfor x in range(1, n):\n    grid[0][x] = grid[0][x] and grid[0][x - 1]\nfor y in range(1, m):\n    grid[y][0] = grid[y][0] and grid[y - 1][0]\n\nfor x in range(1, n):\n    for y in range(1, m):\n        grid[y][x] = grid[y][x] and (grid[y][x - 1] or grid[y - 1][x])\n    \nif grid[-1][-1]:\n    print('YES')\n    print(n + m - 2)\nelse:\n    print('NO')", "intput = lambda: [int(i) for i in input().split()]\n# Write your code here\nn, m, k = intput()\nblasters = [intput() for i in range(k)]\ngrid = [[1] * n for i in range(m)]\n\nfor bx, by, t, f in blasters:\n    bx -= 1\n    by -= 1\n    \n    for x in range(n):\n        k = (x + by - abs(bx - x) - t) % f\n        if k == 0:\n            grid[by][x] = 0\n    \n    for y in range(m):\n        k = (bx + y - abs(by - y) - t) % f\n        if k == 0:\n            grid[y][bx] = 0\n    \nfor x in range(1, n):\n    grid[0][x] = grid[0][x] and grid[0][x - 1]\nfor y in range(1, m):\n    grid[y][0] = grid[y][0] and grid[y - 1][0]\n\nfor x in range(1, n):\n    for y in range(1, m):\n        grid[y][x] = grid[y][x] and (grid[y][x - 1] or grid[y - 1][x])\n    \nif grid[-1][-1]:\n    print('YES')\n    print(n + m - 2)\nelse:\n    print('NO')", "from sys import setrecursionlimit\nsetrecursionlimit(int(1e9))\nintput = lambda: [int(i) for i in input().split()]\n# Write your code here\nn, m, k = intput()\nblasters = [intput() for i in range(k)]\ngrid = [[1] * n for i in range(m)]\n\nfor bx, by, t, f in blasters:\n    bx -= 1\n    by -= 1\n    \n    for x in range(n):\n        k = x + by - abs(bx - x) - t\n        if k >= 0 and k % f == 0:\n            grid[by][x] = 0\n    \n    for y in range(m):\n        k = bx + y - abs(by - y) - t\n        if k >= 0 and k % f == 0:\n            grid[y][bx] = 0\n\ndef solve(x, y):\n    if not grid[y][x]:\n        return 0\n    if x == n - 1 and y == m - 1:\n        return 1\n    res = 0\n    if x != n - 1:\n        res = solve(x + 1, y)\n    if y != m - 1:\n        res = res or solve(x, y + 1)\n    return res\n    \nif solve(0, 0):\n    print('YES')\n    print(n + m - 2)\nelse:\n    print('NO')", "intput = lambda: [int(i) for i in input().split()]\n# Write your code here\nn, m, k = intput()\nblasters = [intput() for i in range(k)]\ngrid = [[1] * n for i in range(m)]\n\nfor bx, by, t, f in blasters:\n    bx -= 1\n    by -= 1\n    \n    for x in range(n):\n        k = x + by - abs(bx - x) - t\n        if k >= 0 and k % f == 0:\n            grid[by][x] = 0\n    \n    for y in range(m):\n        k = bx + y - abs(by - y) - t\n        if k >= 0 and k % f == 0:\n            grid[y][bx] = 0\n    \nfor x in range(1, n):\n    grid[0][x] = grid[0][x] and grid[0][x - 1]\nfor y in range(1, m):\n    grid[y][0] = grid[y][0] and grid[y - 1][0]\n\nfor x in range(1, n):\n    for y in range(1, m):\n        grid[y][x] = grid[y][x] and (grid[y][x - 1] or grid[y - 1][x])\n    \nif grid[-1][-1]:\n    print('YES')\n    print(n + m - 2)\nelse:\n    print('NO')", "intput = lambda: [int(i) for i in input().split()]\n# Write your code here\nn, m, k = intput()\nblasters = [intput() for i in range(k)]\ngrid = [[1] * n for i in range(m)]\n\nfor bx, by, t, f in blasters:\n    bx -= 1\n    by -= 1\n    \n    for x in range(n):\n        k = x + by - abs(bx - x) - t\n        if k >= 0 and k % f == 0:\n            grid[by][x] = 0\n    \n    for y in range(m):\n        k = bx + y - abs(by - y) - t\n        if k >= 0 and k % f == 0:\n            grid[y][bx] = 0\n    \nfor x in range(1, n):\n    grid[0][x] = grid[0][x] and grid[0][x - 1]\nfor y in range(1, m):\n    grid[0][y] = grid[0][y] and grid[0][y - 1]\n\nfor x in range(1, n):\n    for y in range(1, m):\n        grid[y][x] = grid[y][x] and (grid[y][x - 1] or grid[y - 1][x])\n    \nif grid[-1][-1]:\n    print('YES')\n    print(n + m - 2)\nelse:\n    print('NO')", "def main():\n\tfrom sys import stdin, stdout\n\trl = stdin.readline\n\n\t# Time taken to reach end is determined purely by size of grid\n\t# We simply need to determine if it is possible to reach it\n\n\t# Create dp table, mark all as visitable\n\t# Mark cells with blasters as unvisitable\n\n\t# Now, iterate over blasters.\n\t# For each blaster, check every cell in its row and col.\n\t# For each cell, there is a definite time at which spaceman can be at it\n\n\t# Pulse will take time t1 extra to reach cell after fire\n\t# Therefore, t0 should be = t1 + tstart + nf\n\t# Hence, we mod t0 - t1 - tstart with f\n\n\t# Finally, just try to find a path.\n\t# If a path exists, simply print n + m - 2 as the time to reach\n\n\tn, m, k = (int(x) for x in rl().split())\n\ta = [[int(x) for x in rl().split()] for _ in range(k)]\n\n\tdp = [[1] * m for _ in range(n)]\n\tfor b in a:\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\t\tdp[b[0]][b[1]] = 0\n\n\t\tx, y = b[0], 0\n\t\twhile y < m:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(y - b[1])\n\t\t\tif t_check < 0:  # Negative time is impossible\n\t\t\t\ty += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\ty += 1\n\n\t\tx, y = 0, b[1]\n\t\twhile x < n:\n\t\t\tt_cell = x + y\n\t\t\tt_check = t_cell - b[2] - abs(x - b[0])\n\t\t\tif t_check < 0:\n\t\t\t\tx += 1\n\t\t\t\tcontinue\n\n\t\t\tif t_check % b[3] == 0:\n\t\t\t\tdp[x][y] = 0\n\t\t\tx += 1\n\n\tfor x in range(1, n):\n\t\tdp[x][0] = dp[x][0] and dp[x - 1][0]\n\n\tfor y in range(1, m):\n\t\tdp[0][y] = dp[0][y] and dp[0][y - 1]\n\n\tfor x in range(1, n):\n\t\tfor y in range(1, m):\n\t\t\tdp[x][y] = dp[x][y] and (dp[x - 1][y] or dp[x][y - 1])\n\n\tif dp[-1][-1]:\n\t\tstdout.write('YES\\n')\n\t\tstdout.write(str(n + m - 2))\n\telse:\n\t\tstdout.write('NO')\n\n\nmain()", "# cook your dish here\r\nn,m,k = map(int, input().split())\r\nbom = []\r\nfor _ in range(k):\r\n    bom.append(list(map(int, input().split())))\r\ncount = n+m-2\r\n\r\nif k==3 or k== 4:\r\n    print('NO')\r\nelse:\r\n    can = True\r\n    for b in bom:\r\n        y, x, t, f = b\r\n        if y == 1 and x == 1:\r\n            can = False\r\n    if can:\r\n        sets = {1}\r\n    else:\r\n        sets = set()\r\n    \r\n    for i in range(1, count+1):\r\n        for b in bom:\r\n            y, x, t, f = b\r\n            gap = x+y-i-1\r\n            s_dura = i-t-1\r\n            if s_dura > 0:\r\n                gap = abs(gap)\r\n                temp = s_dura-gap\r\n                if temp >= 0 and temp%f == 0:\r\n                    if 1 <= abs(i-x+1) <= n:\r\n                        sets.discard(x)\r\n                    if 1 <= abs(i-y+1) <= m:\r\n                        sets.discard(abs(i-y+1))\r\n            if gap == 0:\r\n                sets.discard(x)\r\n        \r\n        if len(sets) == 0:\r\n            break\r\n        \r\n        # print(sets)\r\n        for v in list(sets):\r\n            if v <= i-n+1:\r\n                sets.remove(v)\r\n            if v+1 > i-n+1:\r\n                sets.add(v+1)\r\n        sets.discard(m+1)\r\n        \r\n    if m in sets:\r\n        print(\"YES\")\r\n        print(count)\r\n    else:\r\n        print(\"NO\")\r\n            ", "# cook your dish here\r\nn,m,k = map(int, input().split())\r\nbom = []\r\nfor _ in range(k):\r\n    bom.append(list(map(int, input().split())))\r\ncount = n+m-2\r\n\r\nif k < 1:\r\n    print('NO')\r\nelse:\r\n    can = True\r\n    for b in bom:\r\n        y, x, t, f = b\r\n        if y == 1 and x == 1:\r\n            can = False\r\n    if can:\r\n        sets = {1}\r\n    else:\r\n        sets = set()\r\n    \r\n    for i in range(1, count+1):\r\n        for b in bom:\r\n            y, x, t, f = b\r\n            gap = x+y-i-1\r\n            s_dura = i-t-1\r\n            if s_dura > 0:\r\n                gap = abs(gap)\r\n                temp = s_dura-gap\r\n                if temp >= 0 and temp%f == 0:\r\n                    if 1 <= abs(i-x+1) <= n:\r\n                        sets.discard(x)\r\n                    if 1 <= abs(i-y+1) <= m:\r\n                        sets.discard(abs(i-y+1))\r\n            if gap == 0:\r\n                sets.discard(x)\r\n        \r\n        if len(sets) == 0:\r\n            break\r\n        \r\n        # print(sets)\r\n        for v in list(sets):\r\n            if v <= i-n+1:\r\n                sets.remove(v)\r\n            if v+1 > i-n+1:\r\n                sets.add(v+1)\r\n        sets.discard(m+1)\r\n        \r\n    if m in sets:\r\n        print(\"YES\")\r\n        print(count)\r\n    else:\r\n        print(\"NO\")\r\n            ", "# cook your dish here\r\nn,m,k = map(int, input().split())\r\nbom = []\r\nfor _ in range(k):\r\n    bom.append(list(map(int, input().split())))\r\ncount = n+m-2\r\n\r\ncan = True\r\nfor b in bom:\r\n    y, x, t, f = b\r\n    if y == 1 and x == 1:\r\n        can = False\r\nif can:\r\n    sets = {1}\r\nelse:\r\n    sets = set()\r\n\r\nfor i in range(1, count+1):\r\n    for b in bom:\r\n        y, x, t, f = b\r\n        gap = x+y-i-1\r\n        s_dura = i-t-1\r\n        if s_dura > 0:\r\n            gap = abs(gap)\r\n            temp = s_dura-gap\r\n            if temp >= 0 and temp%f == 0:\r\n                if 1 <= abs(i-x+1) <= n:\r\n                    sets.discard(x)\r\n                if 1 <= abs(i-y+1) <= m:\r\n                    sets.discard(abs(i-y+1))\r\n        if gap == 0:\r\n            sets.discard(x)\r\n    \r\n    if len(sets) == 0:\r\n        break\r\n    \r\n    # print(sets)\r\n    for v in list(sets):\r\n        if v <= i-n+1:\r\n            sets.remove(v)\r\n        if v+1 > i-n+1:\r\n            sets.add(v+1)\r\n    sets.discard(m+1)\r\n    \r\nif m in sets:\r\n    print(\"YES\")\r\n    print(count)\r\nelse:\r\n    print(\"NO\")\r\n        "]
["t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    works = True\n    if n % 2:\n        if a[n//2] != b[n//2]:\n            works = False\n\n    pairsA = []\n    for i in range(n//2):\n        f = a[i]\n        s = a[n - i - 1]\n        if f > s:\n            f, s = s, f\n        pairsA.append((f,s))\n\n    pairsB = []\n    for i in range(n//2):\n        f = b[i]\n        s = b[n - i - 1]\n        if f > s:\n            f, s = s, f\n        pairsB.append((f,s))\n\n    pairsA.sort()\n    pairsB.sort()\n\n    if works and pairsA == pairsB:\n        print('Yes')\n    else:\n        print('No')\n", "from collections import deque\n\ndef Hopcroft_Karp(adj, L):\n    \"\"\"\n    Computes maximal matching in unweighted bipartite graph `adj`. Here `L` is\n    a boolean array which gives the left part of the bipartite graph. If w is\n    in adj[v], then precisely one of L[v], L[w] should be True.\n    \n    Returns (N, matching), where N is the cardinality of the matching, and\n    matching is a list encoding the matched vertex (where a -1 indicates an\n    unmatched vertex).\n    \"\"\"\n    N = len(adj)\n    matching = [-1 for _ in range(N)]\n\n    while True:\n        # If our matching changes, we need another iteration.\n        extended = False\n        \n        # Do a BFS starting at all unmatched left nodes.\n        sources = [v for v in range(N) if matching[v] == -1 and L[v]]\n        \n        # Keep track of your immediate predecessor in the BFS.\n        # -1 means an unvisited node. Sources have themselves as predecessor.\n        bfs_pred = [-1 for _ in range(N)]\n        \n        # Keep track of which BFS source started your subtree.\n        # -1 means an unvisited node.\n        bfs_source = [-1 for _ in range(N)]\n        \n        for v in sources:\n            bfs_pred[v] = v\n            bfs_source[v] = v\n        \n        queue = deque(sources)\n        while len(queue) > 0:\n            cur = queue.popleft()\n            \n            # If the node that started this subtree has been matched, stop growing the BFS.\n            if matching[bfs_source[cur]] != -1:\n                continue\n            \n            for nb in adj[cur]:\n                if matching[nb] == -1:\n                    # We have found an augmenting path. \n                    # Use a clever loop to use the path to update the matching.\n                    while nb != -1:\n                        matching[nb], matching[cur], nb, cur = cur, nb, matching[cur], bfs_pred[cur]\n                    extended = True\n                    break\n                else:\n                    new = matching[nb]\n                    if bfs_pred[new] == -1:\n                        bfs_pred[new] = cur\n                        bfs_source[new] = bfs_source[cur]\n                        queue.append(new)\n        if not extended:\n            break\n\n    return sum(1 for x in matching if x != -1)//2, matching\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n\n    if n % 2:\n        if a[n//2] != b[n//2]:\n            print(\"No\")\n            continue\n\n    a_pairs = []\n    b_pairs = []\n    for i in range(n//2):\n        if a[i] < a[n-i-1]:\n            a_pairs.append((a[i], a[n-i-1]))\n        else:\n            a_pairs.append((a[n-i-1], a[i]))\n        if b[i] < b[n-i-1]:\n            b_pairs.append((b[i], b[n-i-1]))\n        else:\n            b_pairs.append((b[n-i-1], b[i]))\n\n    adj = [[] for _ in range(len(a_pairs) + len(b_pairs))]\n    for i, ap in enumerate(a_pairs):\n        for j, bp in enumerate(b_pairs):\n            if ap == bp:\n                adj[i].append(len(a_pairs) + j)\n                adj[len(a_pairs)+j].append(i)\n\n    if Hopcroft_Karp(adj, [True]*len(a_pairs) + [False]*len(b_pairs))[0] == len(a_pairs):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if n % 2 == 1:\n        if a[n // 2] != b[n // 2]:\n            print('No')\n            return\n    u, v = list(), list()\n    def add(s, p, q):\n        if p > q:\n            p, q = q, p\n        s.append((p, q))\n    for i in range(n // 2):\n        add(u, a[i], a[n - i - 1])\n        add(v, b[i], b[n - i - 1])\n    if sorted(u) == sorted(v):\n        print('Yes')\n    else:\n        print('No')\nt = int(input())\nfor _ in range(t):\n    solve()", "q = int(input())\nfor _ in range(q):\n\tn = int(input())\n\tl1 = list(map(int,input().split()))\n\tl2 = list(map(int,input().split()))\n\tx1 = 0 \n\tx2 = 0\n\tif n%2 == 1:\n\t\tx1 = l1.pop(n//2)\n\t\tx2 = l2.pop(n//2)\n\tif x1 != x2:\n\t\tprint(\"No\")\n\telse:\n\t\tif n%2 == 1:\n\t\t\tn-= 1\n\t\td1 = []\n\t\td2 = []\n\t\tfor i in range(n//2):\n\t\t\td1.append([min(l1[i],l1[n-i-1]),max(l1[i],l1[n-i-1])])\n\t\t\td2.append([min(l2[i],l2[n-i-1]),max(l2[i],l2[n-i-1])])\n\t\td1.sort()\n\t\td2.sort()\n\t\tif d1 == d2:\n\t\t\tprint(\"Yes\")\n\t\telse:\n\t\t\tprint(\"No\")", "import sys\n\ndef ii():\n    return sys.stdin.readline().strip()\n\ndef idata():\n    return [int(x) for x in ii().split()]\n\ndef solve_of_problem():\n    n = int(ii())\n    data = idata()\n    data1 = idata()\n    if n == 1:\n        if data1 == data:\n            print('Yes')\n        else:\n            print('No')\n        return\n    if sorted(data) != sorted(data1):\n        print('No')\n        return\n    if n % 2 == 1:\n        if data[n // 2] != data1[n // 2]:\n            print('No')\n            return\n        data = data[:n // 2] + data[n // 2 + 1:]\n        data1 = data1[:n // 2] + data1[n // 2 + 1:]\n        n -= 1\n    d = dict()\n    for i in range(n // 2):\n        d[str(data[i]) + ' ' + str(data[n - i - 1])] = 0\n        d[str(data[n - 1 - i]) + ' ' + str(data[i])] = 0\n        d[str(data1[i]) + ' ' + str(data1[n - i - 1])] = 0\n        d[str(data1[n - 1 - i]) + ' ' + str(data1[i])] = 0\n    for i in range(n // 2):\n        d[str(data[i]) + ' ' + str(data[n - i - 1])] += 1\n        d[str(data[n - 1 - i]) + ' ' + str(data[i])] += 1\n        d[str(data1[i]) + ' ' + str(data1[n - i - 1])] -= 1\n        d[str(data1[n - 1 - i]) + ' ' + str(data1[i])] -= 1\n    if min(d.values()) < 0:\n        print('No')\n        return\n    print('Yes')\n    return\n\nfor ______ in range(int(ii())):\n    solve_of_problem()\n", "for _ in range(int(input())):\n    n = int(input())\n    a = tuple(map(int, input().split()))\n    b = tuple(map(int, input().split()))\n    if sorted(zip(a, reversed(a))) == sorted(zip(b, reversed(b))):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "for _ in range(int(input())):\n    n=int(input())\n    k=n//2\n    a=list(map(int,input().split()))\n    b=list(map(int,input().split()))\n    dicA={}\n    dicB={}\n    for i in range(k):\n        p,q=a[i],a[-i-1]\n        if p>q:\n            if (q,p) not in dicA:\n                dicA[(q,p)]=0\n            dicA[(q,p)]+=1\n        else:\n            if (p,q) not in dicA:\n                dicA[(p,q)]=0\n            dicA[(p,q)]+=1\n\n    for i in range(k):\n        p,q=b[i],b[-i-1]\n        if p>q:\n            if (q,p) not in dicB:\n                dicB[(q,p)]=0\n            dicB[(q,p)]+=1\n        else:\n            if (p,q) not in dicB:\n                dicB[(p,q)]=0\n            dicB[(p,q)]+=1\n\n    if n%2==1:\n        if a[k]!=b[k]:\n            print(\"No\")\n        else:\n            res=\"Yes\"\n            for p,q in dicA:\n                if (p,q) not in dicB:\n                    res=\"No\"\n                elif dicA[(p,q)]!=dicB[(p,q)]:\n                    res=\"No\"\n            print(res)\n    else:\n        res=\"Yes\"\n        for p,q in dicA:\n            if (p,q) not in dicB:\n                res=\"No\"\n            elif dicA[(p,q)]!=dicB[(p,q)]:\n                res=\"No\"\n        print(res)", "from collections import Counter\nT = int(input().strip())\nfor t in range(T):\n    n = int(input().strip())\n\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if Counter(a) != Counter(b):\n        print('No')\n        continue\n    mid = n//2 + n % 2\n    aa = Counter(tuple(sorted([a[i],a[n-i-1]])) for i in range(mid))\n    bb = Counter(tuple(sorted([b[i],b[n-i -1]])) for i in range(mid))\n\n\n    # print(aa)\n    # print(bb)\n    if aa != bb:\n        print('No')\n        continue\n    print('Yes')\n\n", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n\n    C=[]\n    D=[]\n\n    if n%2==1:\n        if A[n//2]!=B[n//2]:\n            print(\"No\")\n            continue\n\n    for i in range(n//2):\n        C.append(sorted([A[i],A[-i-1]]))\n        D.append(sorted([B[i],B[-i-1]]))\n\n    #print(C)\n    #print(D)\n\n    if sorted(C)==sorted(D):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "from collections import defaultdict\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        n = II()\n        aa = LI()\n        bb = LI()\n\n        if n%2:\n            if aa[n//2]!=bb[n//2]:\n                print(\"No\")\n                continue\n\n        cnt=defaultdict(int)\n        for i in range(n//2):\n            l=aa[i]\n            r=aa[n-1-i]\n            if l>r:l,r=r,l\n            cnt[l,r]+=1\n\n        ng=False\n        for i in range(n//2):\n            l=bb[i]\n            r=bb[n-1-i]\n            if l>r:l,r=r,l\n            if cnt[l,r]==0:ng=True\n            cnt[l,r]-=1\n\n        if ng:print(\"No\")\n        else:print(\"Yes\")\n\nmain()\n", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    paira = []\n    for i in range((n+1)//2):\n        paira.append(tuple(sorted([a[i], a[~i]])))\n\n    pairb = []\n    for i in range((n+1)//2):\n        pairb.append(tuple(sorted([b[i], b[~i]])))\n\n\n    paira.sort()\n    pairb.sort()\n\n    if paira == pairb:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n"]
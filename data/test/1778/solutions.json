["n=int(input())\na=[*map(int,input().split())]\nb=[*map(int,input().split())]\nprint(sum(sorted(a+b)[::-2])-sum(b))", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\nz1 = getIntList()\nz2 =  getIntList()\n\nz1.sort()\nz2.sort()\n\nt1 = N-1\nt2 = N-1\ns1 = 0\ns2 = 0\n\ndef bigone():\n    if t1>=0 and t2>=0:\n        if z1[t1] > z2[t2]: return 1\n        else: return 2\n    if t1>=0:\n        return 1\n    return 2\n\nwhile t1>=0 or t2>=0:\n    t = bigone() \n    if t==1:\n        s1+=z1[t1]\n        t1-=1\n    else:\n        t2-=1\n    t = bigone() \n    if t==1:\n        t1-=1\n    else:\n        s2+=z2[t2]\n        t2-=1\n\nprint(s1-s2)\n\n\n\n\n\n\n\n\n\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nb = li()\na.sort()\nb.sort()\n\nx = y = 0\nfor t in range(n):\n    if not b:\n        x += a.pop()\n    elif not a:\n        b.pop()\n    elif a[-1] > b[-1]:\n        x += a.pop()\n    else:\n        b.pop()\n\n    if not a:\n        y += b.pop()\n    elif not b:\n        a.pop()\n    elif b[-1] > a[-1]:\n        y += b.pop()\n    else:\n        a.pop()\nprint(x - y)\n", "n=int(input())\ns=input().split()\nla=[int(s[i]) for i in range(n)]\ns=input().split()\nlb=[int(s[i]) for i in range(n)]\nla.sort()\nlb.sort()\nsa=0\nsb=0\nfor i in range(n):\n    if len(la)==0:\n        if len(lb)>0:\n            del(lb[-1])\n        else:\n            break\n    elif len(lb)==0:\n        sa+=la[-1]\n        del(la[-1])\n    elif la[-1]>lb[-1]:\n        sa+=la[-1]\n        del(la[-1])\n    else:\n        del(lb[-1])\n    \n    if len(lb)==0:\n        if len(la)>0:\n            del(la[-1])\n        else:\n            break\n    elif len(la)==0:\n        sb+=lb[-1]\n        del(lb[-1])\n    elif lb[-1]>la[-1]:\n        sb+=lb[-1]\n        del(lb[-1])\n    else:\n        del(la[-1])\nprint(sa-sb)", "#Problem C: Gambling\n\nn = int(input())\n\na = input().split()\nb = input().split()\n\nfor i in range(n):\n    a[i] = int(a[i])\n    b[i] = int(b[i])\n\n\ngoList = []\nfor i in range(n):\n    cur = (a[i],1)\n    goList.append(cur)\nfor i in range(n):\n    cur = (b[i],2)\n    goList.append(cur)\n\ngoList.sort(reverse = True)\n\nans = 0\n\nfor i in range(2*n):\n    cur = goList[i]\n    pts = cur[0]\n    owner = cur[1]\n    if(i%2==0): #First Player\n        if(owner==1):\n            ans += pts\n    else:\n        if(owner==2):\n            ans -= pts\n\nprint(ans)", "import sys\nimport string\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn = ria()[0]\nar1 = ria()\nar2 = ria()\np1 = 0\np2 = 0\nar1.sort()\nar2.sort()\nar1 = [i for i in reversed(ar1)]\nar2 = [i for i in reversed(ar2)]\n# print(ar1, ar2)\n\npp1 = 0\npp2 = 0\nfor i in range(n):\n    if pp1 < n:\n        if pp2 >= n or ar1[pp1] >= ar2[pp2]:\n            p1 += ar1[pp1]\n            pp1 += 1\n        else:\n            pp2 += 1\n    elif pp2 < n:\n        pp2 += 1\n\n    if pp2 < n:\n        if pp1 >= n or ar1[pp1] <= ar2[pp2]:\n            p2 += ar2[pp2]\n            pp2 += 1\n        else:\n            pp1 += 1\n    elif pp1 < n:\n        pp1 += 1\n\nprint(p1 - p2)\n", "n = int(input())\na = list(map(int, input().split()))\na = [(a[i], 0) for i in range(n)]\nb = list(map(int, input().split()))\nb = [(b[i], 1) for i in range(n)]\nab = sorted(a + b, key=lambda x: x[0], reverse=True)\nans = 0\nfor i in range(2 * n):\n\tif i % 2 == 0:\n\t\tif ab[i][1] == 0:\n\t\t\tans += ab[i][0]\n\telse:\n\t\tif ab[i][1] == 1:\n\t\t\tans -= ab[i][0]\n\nprint(ans)", "n = int(input())\na = list(map(int, input().split())) + [0]\nb = list(map(int, input().split())) + [0]\na.sort()\nb.sort()\nsa = 0\nsb = 0\nwhile len(a) > 1 or len(b) > 1:\n    if a[-1] > b[-1]:\n        sa += a.pop()\n    else:\n        b.pop()\n    if a[-1] > b[-1]:\n        a.pop()\n    else:\n        sb += b.pop()\nprint(sa - sb)", "n = int(input())\narra = list(map(int, input().split()))\narrb = list(map(int, input().split()))\narra.sort()\narrb.sort()\na = 0\nb = 0\nfor i in range(2 * n):\n    if i % 2 == 0:\n        if len(arra) == 0:\n            arrb.pop()\n        elif len(arrb) == 0 or arra[-1] >= arrb[-1]:\n            a += arra[-1]\n            arra.pop()\n        else:\n            arrb.pop()\n    else:\n        if len(arrb) == 0:\n            arra.pop()\n        elif len(arra) == 0 or arrb[-1] >= arra[-1]:\n            b += arrb[-1]\n            arrb.pop()\n        else:\n            arra.pop()\nprint(a - b)\n'''\nn = int(input())\nif n == 1 or n == 2:\n    print('No')\nelse: #if n % 2 == 1:\n    print('Yes')\n    print((n + 1) // 2, end = ' ')\n    for i in range(1, n + 1, 2):\n        print(i, end = ' ')\n    print()\n    print(n // 2, end = ' ')\n    for i in range(2, n + 1, 2):\n        print(i, end = ' ')\n'''\n'''\nn, k = map(int, input().split())\ns = input()\nd = [0 for _ in range(k)]\nfor i in s:\n    d[ord(i) - ord('A')] += 1\n#al = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n#for i in \nprint(min(d) * k)\n'''", "n = int(input())\nAs = [int(x) for x in input().split()]\nBs = [int(x) for x in input().split()]\nscores = [0,0]\nAs.sort()\nBs.sort()\nfor i in range(n*2):\n\tis_a = i%2==0\n\tif len(As) == 0:\n\t\tif is_a:\n\t\t\tBs.pop()\n\t\telse:\n\t\t\tscores[1] += Bs.pop()\n\t\t#scores[i%2] += Bs.pop()\n\telif len(Bs) == 0:\n\t\tif is_a:\n\t\t\tscores[0] += As.pop()\n\t\telse:\n\t\t\tAs.pop()\n\t\t#scores[i%2] += As.pop()\n\telse:\n\t\tif As[-1] > Bs[-1]:\n\t\t\tif is_a:\n\t\t\t\tscores[i%2] += As.pop()\n\t\t\telse:\n\t\t\t\tAs.pop()\n\t\telse:\n\t\t\tif is_a:\n\t\t\t\tBs.pop()\n\t\t\telse:\n\t\t\t\tscores[1] += Bs.pop()\n#\t\t\tscores[i%2] += Bs.pop()\nprint(scores[0]-scores[1])\n\n", "n = int(input())\na = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\nA, B = 0, 0\nfor i in range(2 * n):\n    if i % 2 == 0:\n        if not b or a and a[-1] >= b[-1]:\n            A += a[-1]\n            del a[-1]\n        else:\n            del b[-1]\n    else:\n        if not a or b and b[-1] >= a[-1]:\n            B += b[-1]\n            del b[-1]\n        else:\n            del a[-1]\n\nprint(A - B)\n", "n = int(input())\naa = sorted(list(map(int, input().split(' '))))\nbb = sorted(list(map(int, input().split(' '))))\n\nres = 0\n\nai = n - 1\nbi = n - 1\n\nwhile ai >= 0 or bi >= 0:\n    an = -1 if ai < 0 else aa[ai]\n    bn = -1 if bi < 0 else bb[bi]\n\n    if an >= bn:\n        res += an\n        ai -= 1\n    else:\n        bi -= 1\n\n    an = -1 if ai < 0 else aa[ai]\n    bn = -1 if bi < 0 else bb[bi]\n\n    if an <= bn:\n        res -= bn\n        bi -= 1\n    else:\n        ai -= 1\n\nprint(res)\n\n", "'''input\n2\n2 1\n5 6\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nmod=10**9+7\nimport heapq\n\nn=int(input())\na=[-int(i) for i in input().split()]+[0]*(100000)\nb=[-int(i) for i in input().split()]+[0]*(100000)\n\nheapq.heapify(a)\nheapq.heapify(b)\n\nans1=0\nans2=0\n\nfor i in range(2*n):\n\tif i%2==0:\n\t\t#a-turn\n\t\ttemp1=-heapq.heappop(a)\n\t\ttemp2=-heapq.heappop(b)\n\t\tif temp2>temp1:\n\t\t\theapq.heappush(a,-temp1)\n\t\telse:\n\t\t\tans1+=temp1\n\t\t\theapq.heappush(b,-temp2)\n\telse:\n\t\t#b-turn\n\t\ttemp1=-heapq.heappop(a)\n\t\ttemp2=-heapq.heappop(b)\n\t\tif temp2<temp1:\n\t\t\theapq.heappush(b,-temp2)\n\t\telse:\n\t\t\tans2+=temp2\n\t\t\theapq.heappush(a,-temp1)\n\t#print(ans1,ans2)\nprint(ans1-ans2)\n\n", "n=int(input())\nA=sorted(list(map(int,input().split())),reverse=True)\nB=sorted(list(map(int,input().split())),reverse=True)\n\nAscore=0\nBscore=0\n\na=0\nb=0\n\nfor i in range(n):\n    if a==n:\n        b+=1\n        \n    elif b==n:\n        Ascore+=A[a]\n        a+=1\n        \n    elif A[a]>B[b]:\n        Ascore+=A[a]\n        a+=1\n\n    else:\n        b+=1\n\n\n    if b==n:\n        a+=1\n        \n    elif a==n:\n        Bscore+=B[b]\n        b+=1\n        \n    elif B[b]>A[a]:\n        Bscore+=B[b]\n        b+=1\n\n    else:\n        a+=1\n\nprint(Ascore-Bscore)\n        \n", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nc=[0 for i in range(n)]\na+=c\nb+=c\nsa=0;sb=0\na.sort(reverse=True)\nb.sort(reverse=True)\nd=0\n#print(a,b)\ni=0;j=0\nfor p in range(2*n):\n    if p%2==0:\n        if a[i]>b[j]:\n            sa+=a[i]\n            i+=1\n        else:\n            j+=1\n    elif p%2==1:\n        if b[j]>a[i]:\n            sb+=b[j]\n            j+=1\n        else:\n            i+=1\nprint(sa-sb)            \n            \n", "n = int(input())\nl1 = list(sorted(map(int, input().split())))\nl2 = list(sorted(map(int, input().split())))\ns1 = s2 = 0\nwhile len(l1) > 0 or len(l2) > 0:\n    k1 = k2 = 0     # A\n    if len(l1) > 0:\n        k1 = l1[-1]\n    if len(l2) > 0:\n        k2 = l2[-1]\n    if k1 >= k2:\n        s1 += k1\n        l1.pop()\n    else:\n        l2.pop()\n    if len(l1) == 0 and len(l2) == 0:\n        break\n    k1 = k2 = 0  # B\n    if len(l1) > 0:\n        k1 = l1[-1]\n    if len(l2) > 0:\n        k2 = l2[-1]\n    if k2 >= k1:\n        s2 += k2\n        l2.pop()\n    else:\n        l1.pop()\nprint(s1 - s2)\n", "\"\"\"#N=int(input())\nn,k=map(int,input().split())\ns=input()\nL=[0]*26\n#s=[int(x) for x in input().split()]\nfor j in range(0,len(s)):\n    L[ord(s[j])-65]=L[ord(s[j])-65]+1\nans=1000000007\nfor j in range(0,k):\n    ans=min(ans,L[j])\nans=k*ans\nprint(ans)\"\"\"\n\"\"\"import math\npre=[]\nfor i in range(0,45010):\n    pre.append(((i*(i+1))//2))\n#print(pre[:100])\nn=int(input())\nif(n==0 or n==1 or n==2):\n    print('No')\nelse:\n    temp=0\n    t=pre[n]\n    pos=-1\n    for j in range(1,n+1):\n        if(math.gcd(pre[j],t-pre[j])>1):\n            temp=1\n            pos=j\n            break\n    if(temp==0):\n        print('No')\n    else:\n        print('Yes')\n        print(pos,end=\" \")\n        for j in range(1,pos+1):\n            print(j,end=\" \")\n        print(\" \")\n        print(n-j,end=\" \")\n        for j in range(pos+1,n+1):\n            print(j,end=\" \")\n        print(\" \")\"\"\"\n\n\n\nn=int(input())\ns1=[int(x) for x in input().split()]\ns2=[int(x) for x in input().split()]\nS1=sorted(s1)\nS2=sorted(s2)\nS1=[0]+S1\nS2=[0]+S2\nS1=S1[::-1]\nS2=S2[::-1]\npta=0\nptb=0\nsm1=0\nsm2=0\nfor j in range(0,(2*n)+1):\n    if(j%2==0):\n        if(S2[ptb]>S1[pta]):\n            ptb=ptb+1\n        else:\n            sm1=sm1+S1[pta]\n            pta=pta+1\n    else:\n        if(S1[pta]>S2[ptb]):\n            pta=pta+1\n        else:\n            sm2=sm2+S2[ptb]\n            ptb=ptb+1\n    if(pta==n+1 and ptb==n+1):\n        break\nprint(sm1-sm2)\n", "#!/usr/bin/env python3\n#-*- encoding: utf-8 -*-\n\nimport sys\nimport bisect\nfrom collections import Counter\n\nread_int = lambda : int(sys.stdin.readline())\nread_ints = lambda : list(map(int,sys.stdin.readline().split()))\nread_int_list = lambda : list(read_ints())\nread = lambda : sys.stdin.readline().strip()\nread_list = lambda : sys.stdin.readline().split()\n\ndef main():\n    n = read_int()\n    a = read_int_list()\n    b = read_int_list()\n    sa, sb = 0, 0\n    a.sort()\n    b.sort()\n    turn = True\n    while a or b:\n        if turn:\n            if a:\n                if b:\n                    if a[-1] > b[-1]:\n                        sa += a.pop()\n                    else:\n                        b.pop()\n                else:\n                    sa += a.pop()\n            else:\n                b.pop()\n        else:\n            if b:\n                if a:\n                    if b[-1] > a[-1]:\n                        sb += b.pop()\n                    else:\n                        a.pop()\n                else:\n                    sb += b.pop()\n            else:\n                a.pop()\n        turn = not turn\n    print(sa-sb)\n\n\nmain()\n", "n=int(input())\na=sorted(list(map(int,input().split())))\nb=sorted(list(map(int,input().split())))\ns1=s2=0\nfor i in range(2*n):\n    if i%2==0:\n        if len(a)>0 and len(b)>0 and a[-1]>b[-1]:\n            s1+=a[-1];del a[-1]\n        elif len(b)>0:\n            del b[-1]\n        else:\n            s1+=a[-1];del a[-1]\n    else:\n        if len(a)>0 and len(b)>0 and b[-1]>a[-1]:\n            s2+=b[-1];del b[-1]\n        elif len(a)>0:\n            del a[-1]\n        else:\n            s2+=b[-1];del b[-1]\nprint(s1-s2)", "from sys import stdin\nn=int(stdin.readline())\na=[(int(x), 1) for x in stdin.readline().split()]\na.extend([(int(x),2) for x in stdin.readline().split()])\na.sort(reverse=True)\nasum=bsum=0\nal=0\nfor i in range(n):\n    if a[al][1]==1:\n        asum+=a[al][0]\n    al+=1\n    if a[al][1]==2:\n        bsum+=a[al][0]\n    al += 1\nprint(asum-bsum)", "I=lambda:map(int,input().split())\n#C\nn=int(input())\na=sorted(list(I()))\nb=sorted(list(I()))\nsa=sb=0\nfor i in range(2*n):\n    if i%2==0:\n        if len(a)>0 and len(b)>0 and a[-1]>b[-1]:\n            sa+=a[-1];del a[-1]\n        elif len(b)>0:\n            del b[-1]\n        else:\n            sa+=a[-1];del a[-1]\n    else:\n        if len(a)>0 and len(b)>0 and b[-1]>a[-1]:\n            sb+=b[-1];del b[-1]\n        elif len(a)>0:\n            del a[-1]\n        else:\n            sb+=b[-1];del b[-1]\nprint(sa-sb)", "def gambling():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    bb = list(map(int, input().split()))\n    aa.sort()\n    bb.sort()\n\n    sa, sb = 0, 0\n    while aa or bb:\n        # turn a\n        if len(aa) == 0:\n            bb.pop()\n        elif len(bb) == 0:\n            sa += aa.pop()\n        elif aa[-1] >= bb[-1]:\n            sa += aa.pop()\n        else:\n            bb.pop()\n\n        # turn b\n        if len(bb) == 0:\n            aa.pop()\n        elif len(aa) == 0:\n            sb += bb.pop()\n        elif bb[-1] >= aa[-1]:\n            sb += bb.pop()\n        else:\n            aa.pop()\n\n    print(sa-sb)\n\ndef __starting_point():\n    gambling()\n__starting_point()", "n = int(input())\na = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\ns_a = s_b = 0\na_j = b_j = n - 1\nfor i in range(2 * n):\n    if i % 2 == 0:\n        if a_j == -1:\n            b_j -= 1\n        elif b_j == -1:\n            s_a += a[a_j]\n            a_j -= 1\n        elif a[a_j] < b[b_j]:\n            b_j -= 1\n        else:\n            s_a += a[a_j]\n            a_j -= 1\n    else:\n        if b_j == -1:\n            a_j -= 1\n        elif a_j == -1:\n            s_b += b[b_j]\n            b_j -= 1\n        elif b[b_j] < a[a_j]:\n            a_j -= 1\n        else:\n            s_b += b[b_j]\n            b_j -= 1\nprint(s_a - s_b)", "\ndef mi():\n\treturn map(int, input().split())\n\nn = int(input())\na = list(mi())\nb = list(mi())\n\na.sort(reverse=True)\nb.sort(reverse=True)\n\ni,j = 0,0\nsa,sb = 0,0\nfor k in range(2*n):\n\tif k&1:\n\t\tif j==n:\n\t\t\ta[i] = 0\n\t\t\ti+=1\n\t\t\tcontinue\n\t\tif i==n:\n\t\t\tsb+=b[j]\n\t\t\tj+=1\n\t\t\tcontinue\n\t\tif b[j]<a[i]:\n\t\t\ta[i] = 0\n\t\t\ti+=1\n\t\telse:\n\t\t\tsb+=b[j]\n\t\t\tb[j]= 0 \n\t\t\tj+=1\n\t\t\n\telse:\n\t\tif i==n:\n\t\t\tb[j] = 0\n\t\t\tj+=1\n\t\t\tcontinue\n\t\tif j==n:\n\t\t\tsa+=a[i]\n\t\t\ti+=1\n\t\t\tcontinue\n\t\tif a[i]<b[j]:\n\t\t\tb[j]=0\n\t\t\tj+=1\n\t\telse:\n\t\t\tsa+=a[i]\n\t\t\ta[i] = 0\n\t\t\ti+=1\n#sa+=sum(a)\n#sb+=sum(b)\nprint (sa-sb)", "n=int(input())\na=input().split()\nb=input().split()\nara=[]\narb=[]\nfor i in a:\n    ara.append(int(i))\nfor i in b:\n    arb.append(int(i))\nara.sort()\narb.sort()\ni=0\nsumsa=0\nsumsb=0\nwhile(i<n):\n    if(len(arb)==0):\n        sumsa+=ara[-1]\n        ara.pop()\n    elif(len(ara)==0):\n        arb.pop()\n    else:\n        if(arb[-1]>ara[-1]):\n            arb.pop()\n        else:\n            sumsa+=ara[-1]\n            ara.pop()\n    if(len(ara)==0):\n        sumsb+=arb[-1]\n        arb.pop()\n    elif(len(arb)==0):\n        ara.pop()\n    else:\n        if(ara[-1]>arb[-1]):\n            ara.pop()\n        else:\n            sumsb+=arb[-1]\n            arb.pop()\n    i+=1\nprint(sumsa-sumsb)\n"]
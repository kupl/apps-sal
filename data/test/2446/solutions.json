["import sys\nfrom collections import defaultdict\nfrom math import gcd, sqrt\n\nMAX = pow(10, 5)\n# stdin = open(\"testdata.txt\", \"r\")\nip = sys.stdin\n\nn = int(ip.readline())\n\na = list(map(int, ip.readline().split()))\ngcd_count = defaultdict(int)\n\nmain_gcd = defaultdict(int)\n\nmain_gcd[a[0]] = 1\ngcd_count[a[0]] = 1\nfor i in range(1, n):\n\tele = a[i]\n\ttemp_gcd = defaultdict(int)\n\ttemp_gcd[ele] = 1\n\tgcd_count[ele] += 1\n\tfor k, v in main_gcd.items():\n\t\ttemp = gcd(ele, k)\n\t\ttemp_gcd[temp] += v\n\t\tgcd_count[temp] += v\n\tmain_gcd = temp_gcd\n\nq = int(ip.readline())\nfor _ in range(q):\n\tk = int(ip.readline())\n\tprint(gcd_count[k])", "from math import gcd\nfrom collections import defaultdict\nfrom sys import stdin, stdout\n\n##This method is better cause for all the same results we only calculate once\ndef main():\n    GCD_count = defaultdict(int)\n    GCD_map = defaultdict(int)\n    arr_len = int(stdin.readline())\n    arr = [int(x) for x in stdin.readline().split()]\n    for start in range(arr_len):\n        temp = defaultdict(int)\n        GCD_count[arr[start]] += 1\n        temp[arr[start]] += 1\n        for gcd_now, occurence in list(GCD_map.items()):\n            res = gcd(gcd_now, arr[start])\n            temp[res] += occurence\n            GCD_count[res] += occurence\n        GCD_map = temp\n    num_queries = int(stdin.readline())\n    for _ in range(num_queries):\n        print(GCD_count[int(stdin.readline())])\n\n\nmain()\n", "from sys import stdin\nimport math\nfrom collections import defaultdict\ninput = stdin.readline\n\nn = int(input())\narr = list(map(int, input().rstrip().split(\" \")))\nq = int(input())\n\nd = defaultdict(lambda : 0)\n\ncurrent = defaultdict(lambda : 0)\n# totalCount1 = 0\n# count1 = 0\n\nfor i in range(n):\n    newCurrent = defaultdict(lambda : 0)\n    newCurrent[arr[i]] += 1\n    for key, value in current.items():\n        g = math.gcd(arr[i], key)\n        if g > 1:\n            newCurrent[g] += value\n        \n    for key, value in newCurrent.items():\n        d[key] += value\n    \n    current = newCurrent\n\ntotalCombi = (n * (n + 1)) // 2\n\n#print(d)\nd[1] = totalCombi - sum(d.values()) + arr.count(1)\n\n#print(d)\nfor _ in range(q):\n    x = int(input())\n    print(d[x])", "from sys import stdin\nimport math\nfrom collections import defaultdict\ninput = stdin.readline\n\nn = int(input())\narr = list(map(int, input().rstrip().split(\" \")))\nq = int(input())\n\nd = defaultdict(lambda : 0)\n\ncurrent = defaultdict(lambda : 0)\n\nfor i in range(n):\n    newCurrent = defaultdict(lambda : 0)\n    newCurrent[arr[i]] += 1\n    for key, value in current.items():\n        g = math.gcd(arr[i], key)\n        newCurrent[g] += value\n        \n    for key, value in newCurrent.items():\n        d[key] += value\n    \n    current = newCurrent\n\n\nfor _ in range(q):\n    x = int(input())\n    print(d[x])", "from sys import stdin\nn = int(stdin.readline())\na = [int(x) for x in stdin.readline().split()]\n\nq = int(stdin.readline())\n\ndef gcd(a,b):\n    while a != 0:\n        a,b = b%a, a\n    return b\n    \ntotals = {}\nnew = {}\n\nfor x in a[::-1]:\n    old = new\n    new = {}\n    for y in old:\n        g = gcd(x,y)\n        if g in new:\n            new[g] += old[y]\n        else:\n            new[g] = old[y]\n    if x in new:\n        new[x] += 1\n    else:\n        new[x] = 1\n    for y in new:\n        if y in totals:\n            totals[y] += new[y]\n        else:\n            totals[y] = new[y]\n    \n            \n\n\nfor x in range(q):\n    c = int(stdin.readline())\n    if c in totals:\n        print(totals[c])\n    else:\n        print(0)\n", "from sys import stdin\nimport math\nfrom collections import defaultdict\n\ninput = stdin.readline\n\n# n, k = map(int, input().split(\" \"))\n# l = list(map(int, input().split(\" \")))\n\nn = int(input())\nl = list(map(int, input().split(\" \")))\n\nk = math.ceil(math.log2(n))\ndp = [[0] * k for i in range(2 ** k)]\n\n\ndef make_sparse(l, n, k):\n    \"\"\"Making sparse table, replace max with needed function like[GCD, Min, max, sum]\"\"\"\n    for i in range(n):\n        dp[i][0] = l[i]\n\n    for j in range(1, k + 1):\n        i = 0\n        while i + (1 << j) <= n:\n            dp[i][j] = math.gcd(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1])\n            i += 1\n\n\ndef querys(l, r):\n    j = int(math.log2(r - l + 1))\n    return math.gcd(dp[l][j], dp[r - (1 << j) + 1][j])\n\n\nmake_sparse(l, n, k)\nd = defaultdict(int)\ng = defaultdict(int)\nd[l[0]] = 1\ng[l[0]] = 1\nfor i in range(1, n):\n    t = defaultdict(int)\n    t[l[i]] = 1\n    g[l[i]]+=1\n    for k, v in list(d.items()):\n        gcd = math.gcd(k, l[i])\n        t[gcd] += v\n        g[gcd] += v\n    d = t\n\nfor i in range(int(input())):\n    a = g[int(input())]\n    if not a:\n        print(0)\n    else:\n        print(a)\n", "from sys import stdin\nimport math\nfrom collections import defaultdict\n\ninput = stdin.readline\n\n# n, k = map(int, input().split(\" \"))\n# l = list(map(int, input().split(\" \")))\n\nn = int(input())\nl = list(map(int, input().split(\" \")))\n\nk = math.ceil(math.log2(n))\ndp = [[0] * k for i in range(2 ** k)]\n\n\n# def make_sparse(l, n, k):\n#     \"\"\"Making sparse table, replace max with needed function like[GCD, Min, max, sum]\"\"\"\n#     for i in range(n):\n#         dp[i][0] = l[i]\n#\n#     for j in range(1, k + 1):\n#         i = 0\n#         while i + (1 << j) <= n:\n#             dp[i][j] = math.gcd(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1])\n#             i += 1\n#\n#\n# def querys(l, r):\n#     j = int(math.log2(r - l + 1))\n#     return math.gcd(dp[l][j], dp[r - (1 << j) + 1][j])\n\n\n# make_sparse(l, n, k)\nd = defaultdict(int)\ng = defaultdict(int)\nd[l[0]] = 1\ng[l[0]] = 1\nfor i in range(1, n):\n    t = defaultdict(int)\n    t[l[i]] = 1\n    g[l[i]]+=1\n    for k, v in list(d.items()):\n        gcd = math.gcd(k, l[i])\n        t[gcd] += v\n        g[gcd] += v\n    d = t\n\nfor i in range(int(input())):\n    a = g[int(input())]\n    if not a:\n        print(0)\n    else:\n        print(a)\n", "from sys import stdin\nimport math\nfrom collections import defaultdict\n\ninput = stdin.readline\n\n# n, k = map(int, input().split(\" \"))\n# l = list(map(int, input().split(\" \")))\n\nn = int(input())\nl = list(map(int, input().split(\" \")))\n\n\nd = defaultdict(int)\ng = defaultdict(int)\nd[l[0]] = 1\ng[l[0]] = 1\nfor i in range(1, n):\n    t = defaultdict(int)\n    t[l[i]] = 1\n    g[l[i]]+=1\n    for k, v in list(d.items()):\n        gcd = math.gcd(k, l[i])\n        t[gcd] += v\n        g[gcd] += v\n    d = t\n\nfor i in range(int(input())):\n    a = g[int(input())]\n    print(a)\n"]
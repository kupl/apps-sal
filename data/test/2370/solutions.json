["from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nimport numpy as np\n\nn = int(input())\na = np.array([list(map(int, input().split())) for _ in range(n)])\n\ng = csr_matrix(a)\ndist = floyd_warshall(g)\n\nif (dist == a).all():\n    sm = a.sum()\n\n    INF = 10 ** 18 + 1\n    for i in range(n):\n        a[i, i] = INF\n\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n\n            mn = np.min(a[u] + a[v])\n            if mn == a[u, v]:\n                sm -= a[u, v]\n\n    ans = sm // 2\n    print(ans)\n\nelse:\n    print((-1))\n", "import sys\n\nimport numpy as np\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nN = int(sys.stdin.readline())\nA = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\nA = np.array(A, dtype=float) + np.diag([np.inf] * N)\n\nuseless = np.zeros((N, N), dtype=bool)\nimpossible = np.zeros((N, N), dtype=bool)\nfor via in range(N):\n    # R[i][j]: i -> via -> j \u306e\u8ddd\u96e2\n    R = sum(np.meshgrid(A[via], A[via]))\n    useless |= R == A\n    impossible |= R < A\n\nif (impossible ^ np.eye(N, dtype=bool)).sum():\n    print((-1))\nelse:\n    print((int(A[~useless].sum() // 2)))\n", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nINF = 10 ** 9\nA = np.array([lr() for _ in range(N)])\nnp.fill_diagonal(A, INF)\nanswer = 0\nfor i in range(N-1):\n    for j in range(i+1, N):\n        detour = np.min(A[i]+A[j])\n        if detour > A[i, j]:\n            answer += A[i, j]\n        elif detour < A[i, j]:\n            print((-1))\n            return\n\nprint(answer)\n# 38\n", "import sys\nimport numpy as np\n\nread = sys.stdin.read\n\nN, *A = list(map(int, read().split()))\nA = np.array(A, np.int64).reshape(N, N)\n'''\nanswer = 0\nfor i, j in product(range(N), repeat=2):\n    if i < j:\n        continue\n    edge = A[i][j]\n    for k in range(N):\n        if i == k or j == k:\n            continue\n\n        tmp = A[i][k] + A[k][j]\n        if tmp < edge:\n            print(-1)\n            return\n        elif tmp == edge:\n            break\n    else:\n        answer += edge\n'''\n\nuseless = np.zeros_like(A)\n\nfor i in range(N):\n    grid = A[i] + A[i, None].T\n    if np.any(grid < A):\n        print((-1))\n        return\n    grid[i] = np.inf\n    grid[:, i] = np.inf\n\n    useless |= (A == grid)\n\nprint((A[useless != 1].sum() // 2))\n", "from numpy import *\nN = int(input())\nA = array([input().split() for _ in range(N)], dtype=int64).reshape(N,N)\n\nfill_diagonal(A, 10**9)\n\nans = 0\nfor i in range(N):\n  for j in range(i+1,N):\n    d = min(A[i]+A[j])\n    if A[i][j] < d:\n      ans += A[i][j]\n    elif d < A[i][j]:\n      print((-1))\n      return\n\nprint(ans)\n", "import scipy.sparse as s,numpy as n\nf=n.loadtxt(open(0),skiprows=1)\ng=s.csgraph.dijkstra(f)\nh=n.where(g,g,1)\nprint(int(sum(t[j]*all(t[j]<t+h[j])for i,t in enumerate(h)for j in range(i)))*(f==g).all()or-1)", "import math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(self.n))\n        self.rank = [1] * n\n        self.count = n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.rank[p] += self.rank[q]\n        self.par[q] = p\n        self.count -= 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return self.rank[x]\n    def count(self):\n        return self.count\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass counting:\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n    def per(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nclass SegmentTree:\n    def __init__(self, lis, ele, op):\n        self.len = len(lis)\n        self.n = 1 << ((self.len - 1).bit_length())\n        self.op = op\n        self.ele = ele\n        self.tree = self._build(lis)\n    def _build(self, lis):\n        res_tree = [self.ele] * (self.n - 1) + lis + [self.ele] * (self.n - self.len)\n        for i in range(self.n - 2, -1, -1):\n            res_tree[i] = self.op(res_tree[i * 2 + 1], res_tree[i * 2 + 2])\n        return res_tree\n    def __get__(self, i):\n        return self.tree[self.n + i - 1]\n    def update(self, i, x):\n        i += self.n - 1\n        self.tree[i] = x\n        while i > 0:\n            i -= 1\n            i >>= 1\n            self.tree[i] = self.op(self.tree[i * 2 + 1], self.tree[i * 2 + 2])\n    def query(self, l, r):\n        l +=  self.n - 1\n        r += self.n - 1\n        L = self.ele\n        R = self.ele\n        while l < r:\n            if l & 1 == 0:\n                L = self.op(L, self.tree[l])\n                l += 1\n            if r & 1 == 0:\n                r -= 1\n                R = self.op(R, self.tree[r])\n            l -= 1\n            l >>= 1\n            r >>= 1\n        return self.op(L, R)\ndef compress(l):\n    n = len(l)\n    sorted_list = sorted(set(l))\n    d = {sorted_list[i]: i for i in range(len(sorted_list))}\n    return [d[i] for i in l]\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(n))\n        self.rank = [0] * n\n        self.weight = [0] * n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n    def unite(self, x, y, w):\n        p, q = self.find(x), self.find(y)\n        if self.rank[p] < self.rank[q]:\n            self.par[p] = q\n            self.weight[p] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[q] = p\n            self.weight[q] = -w - self.weight[y] + self.weight[x]\n            if self.rank[p] == self.rank[q]:\n                self.rank[p] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\nimport numpy as np\nn = int(input())\na = [np.array(list(map(int, input().split()))) for i in range(n)]\nans = sum([sum(a[i]) for i in range(n)]) // 2\nfor i in range(n):\n    a[i][i] = 10 ** 9\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        m = min(a[i] + a[j])\n        if m < a[i][j]:\n            print(-1);return()\n        if m == a[i][j]:\n            ans -= a[i][j]\nprint(ans)", "N = int(input())\ndic = [0]*N\ndist = [[0]*N for i in range(N)]\nfor i in range(N):\n  dic[i] = [int(c) for c in input().split()]\n  for j in range(N):\n    dist[i][j] = dic[i][j]\n  dic[i][i] = float('inf')\n\nans = 0\nfor i in range(N):\n  for j in range(i):\n    d = min(a+b for a, b in zip(dic[i],dic[j]))\n    if d<dic[i][j]:\n      print(-1)\n      return\n    elif d>dic[i][j]:\n      ans += dic[i][j]\nprint(ans)", "N = int(input())\nA = [list(map(int,input().split())) for i in range(N)]\n\nfrom scipy.sparse.csgraph import floyd_warshall as fw\nimport numpy as np\na = fw(A)\nans = 0\nfor i in range(N):\n    a[i][i] = np.inf\nfor i in range(N):\n    for j in range(i):\n        if A[i][j]!=a[i][j]:\n            print(-1)\n            return\n        else:\n            if a[i][j] < np.min(a[i]+a[j]):\n                ans += a[i][j]\nprint(int(ans))", "import sys\n\nimport numpy as np\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nN = int(sys.stdin.readline())\nA = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\nA = np.array(A, dtype=float)\n\nuseless = np.zeros((N, N), dtype=bool)\nimpossible = np.zeros((N, N), dtype=bool)\nfor via in range(N):\n    # R[i][j]: i -> via -> j \u306e\u8ddd\u96e2\n    R = sum(np.meshgrid(A[via], A[via]))\n    R[via] = np.inf\n    R[:, via] = np.inf\n    useless |= R == A\n    impossible |= R < A\nif impossible.sum():\n    print((-1))\nelse:\n    print((int(A[~useless].sum() // 2)))\n", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN = int(input())\nA = [[int(x) for x in input().split()] for _ in range(N)]\n\nif np.any(A != floyd_warshall(A)):\n    print((-1))\nelse:\n    ans = 0\n    A += np.diag([float('inf')] * N)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if np.min(A[i] + A[j]) != A[i, j]:\n                ans += int(A[i, j])\n    print(ans)\n", "import numpy as np\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    N = int(readline())\n    A = np.array(read().split(), dtype=np.int64).reshape(N,N)\n\n    INF = 10**15\n    ans = 0\n    for i in range(N):\n        B = A[i,:] + A\n        np.fill_diagonal(B, INF)\n        B[:,i] = INF\n        C = B.min(axis=1)\n        C[i] = 0\n\n        if (C < A[i,:]).sum() > 0:\n            print((-1))\n            return\n        else:\n            index = C > A[i,:]\n            ans += A[i, index].sum()\n\n    print((ans // 2))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    import numpy as np\n    from scipy.sparse.csgraph import floyd_warshall\n    A = np.array(A, dtype=np.float64)\n    B = floyd_warshall(A, directed=True)\n    if not np.array_equal(A, B):\n        return -1\n    delta = 1e-1\n    _, pre = floyd_warshall(A-delta, return_predecessors=True)\n    return int(A[pre == [[i]*N for i in range(N)]].sum()) // 2\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N)] for _ in range(N)]  # type: \"List[List[int]]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = np.array([list(map(int, input().split())) for i in range(N)])\n    #A = [list(map(int, input().split())) for _ in range(N)]\n    #A = np.array(A)\n\n    INF = 10**10\n    for i in range(N):\n        A[i][i] = INF\n\n    ans = 0\n    for i in range(N):\n        for j in range(i):\n            #bipas = min(map(sum, zip(A[i], A[j])))\n            bipas = np.min(A[i] + A[j])\n\n            if A[i][j] > bipas:\n                print((-1))\n                return 0\n            elif A[i][j] < bipas:\n                ans += A[i][j]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u5c0f\u3055\u3044\u8ddd\u96e2\u304b\u3089\u898b\u3066\u3044\u304f\n# \u65e2\u306b\u4f5c\u3063\u305f\u9053\u306e\u7bc4\u56f2\u3067\u3001\u4efb\u610f\u306e2\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6301\u3063\u3066\u304a\u304f\n# \u65e2\u5b58\u306e\u6700\u77ed\u8ddd\u96e2\u3088\u308a\u5927\u304d\u3044\uff1a\u77db\u76fe\n# \u65e2\u5b58\u306e\u6700\u77ed\u8ddd\u96e2\u3068\u7b49\u3057\u3044\uff1a\u5897\u3084\u3057\u3066\u3082\u4f55\u3082\u5909\u308f\u3089\u305a\n# \u65e2\u5b58\u306e\u6700\u77ed\u8ddd\u96e2\u3088\u308a\u5c0f\u3055\u3044\uff1a\u8ffd\u52a0\u3059\u308b\u5fc5\u8981\u3042\u308a\n\nimport numpy as np\nN = int(input())\nA = [[int(x) for x in input().split()] for _ in range(N)]\n\nedge = []\n\nfor i in range(N):\n  for j in range(i):\n    edge.append((A[i][j],j,i))\nedge.sort()\n\nINF = 10**18\ndist = np.full((N,N),INF,dtype=np.int64) - np.eye(N,dtype=np.int64)*INF\n\nanswer = 0\nfor d,x,y in edge:\n  if d > dist[x,y]:\n    answer = -1\n    break\n  if d == dist[x,y]:\n    continue\n  # \u8ffd\u52a0\n  answer += d\n  dist[x,y] = d\n  dist[y,x] = d\n  # \u8ddd\u96e2\u884c\u5217\u306e\u66f4\u65b0\n  # (i,j) -> (i,x),(x,y),(y,j)\n  dist_use_xy = np.add.outer(dist[:,x], dist[:,y]) + d\n  dist = np.minimum(dist,np.minimum(dist_use_xy,dist_use_xy.T))\n  \nprint(answer)\n", "def warshall_floyd(graph):\n    num_v = len(graph)\n\n    for k in range(num_v):\n        for i in range(num_v):\n            for j in range(num_v):\n                if graph[i][j] > graph[i][k] + graph[k][j]:\n                    graph[i][j] = graph[i][k] + graph[k][j]\n    return graph\n\nN = int(input())\ngraph = [[float(\"inf\") for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    a_list = list(map(int, input().split()))\n    for j in range(N):\n        if i == j:\n            continue\n        graph[i][j] = a_list[j]\n# import copy\n# a_list = copy.deepcopy(graph)\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nw_graph = floyd_warshall(graph, directed=False)\nresult = 0\nfor i in range(N):\n     w_graph[i][i] = float(\"inf\")\nfor i in range(N):\n    for j in range(i):\n        if i == j:\n            continue\n        if w_graph[i][j] != graph[i][j]:\n            print((-1))\n            return\n        if w_graph[i][j] < np.min(w_graph[i] + w_graph[j]):\n            result += w_graph[i][j]\nprint((int(result)))\n", "from numpy import *\nN = int(input())\nA = array([input().split() for _ in range(N)], dtype=int64)\n\nfill_diagonal(A, 10**10)\n\nans = 0\nfor i in range(N):\n  for j in range(i+1,N):\n    d = min(A[i]+A[j])\n    if A[i][j] < d:\n      ans += A[i][j]\n    elif d < A[i][j]:\n      print((-1))\n      return\n\nprint(ans)\n", "import numpy as np\n \nN = int(input())\nA = np.array([input().split() for _ in range(N)], dtype=np.int64).reshape(N,N)\n\nnp.fill_diagonal(A, 10**9+1)\n\nans = 0\nfor i in range(N-1):\n  for j in range(i+1,N):\n    d = np.min(A[i]+A[j])\n    if d > A[i][j]:\n      ans+=A[i][j]\n    elif d < A[i][j]:\n      print(-1)\n      return\n\nprint(ans)", "import numpy as np\n\nN = int(input())\nA = np.array([input().split() for _ in range(N)], dtype=np.int64).reshape(N,N)\n\nINF = 10**15\nnp.fill_diagonal(A, INF)\n\nans = 0\nfor i in range(N-1):\n    for j in range(i+1,N):\n        detour = np.min(A[i]+A[j])\n        if detour > A[i][j]:\n            ans+=A[i][j]\n        elif detour < A[i][j]:\n            print(-1)\n            return\nprint(ans)", "import numpy as np\nN = int(input())\nA = np.array([list(map(int,input().split())) for _ in range(N)],dtype=np.int64)\n\nINF = 10**9+10\nE = np.zeros(((N*(N-1))//2,3),dtype=np.int64)\nk = 0\nfor i in range(N):\n    for j in range(i+1,N):\n        E[k,0] = A[i][j]\n        E[k,1] = i\n        E[k,2] = j\n        k += 1\nE = E[E.argsort(0)[:,0]]\nB = np.ones((N,N),dtype=np.int64)*INF\nans = 0\nfor l,i,j in E:\n    l_min = np.min(B[i]+B[j])\n    if l > l_min:\n        ans = -1\n        break\n    elif l < l_min:\n        ans += l\n    B[i][j] = l\n    B[j][i] = l\nprint(ans)", "# solution\n\nimport io\nimport math\nimport scipy.sparse as s,numpy as n\n\nf=n.loadtxt(open(0),skiprows=1)\n\ng=s.csgraph.dijkstra(f)\n\nh=n.where(g,g,1)\n\nprint(int(sum(t[j]*(t[j]<t+h[j]).all()for i,t in enumerate(h)for j in range(i)))*(f==g).all()or-1)", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\n'''\nA\u304c\u6700\u77ed\u8ddd\u96e2\u3092\u8868\u3059\u3001\u3068\u3044\u3046\u306e\u306fSnuke\u306e\u63a8\u6e2c\u3067\u3057\u304b\u306a\u3044\u3002\n\u306a\u306e\u3067\u3001A\u3092\u3001A[v, u]\u304c\u8fba\u306e\u91cd\u307f\u3092\u8868\u3057\u3066\u3044\u308bgraph\u3068\u3057\u3066\u6349\u3048\u3001floyd_warshall\u3067\u5b9f\u969b\u306b\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u3001B\u3068\u3059\u308b\u3002\n\nB[v, u] < A[v, u]\u304c\u5b58\u5728\u3057\u305f\u3089A\u304c\u6700\u77ed\u8ddd\u96e2\u3092\u8868\u3059\u3068\u3044\u3046\u63a8\u6e2c\u306f\u9593\u9055\u3063\u3066\u3044\u305f\u3053\u3068\u306b\u306a\u308b\u3002\n\u3082\u3057B[v, u] == B[v, w] + B[w, u](\u305f\u3060\u3057 w \u2260 v, w \u2260 u)\u3068\u306a\u308b\u3088\u3046\u306aw\u304c\u5b58\u5728\u3057\u305f\u3089\u3001\nA\u306egraph\u3067edge(v, u)\u306f\u306a\u304f\u3066\u3082\u826f\u3044\u3053\u3068\u306b\u306a\u308b\u306e\u3067\u3001A[v, u] = A[u, v] = 0\u3068\u3057\u3066\u8fba\u3092\u6d88\u3059\u3002(\u4eee\u306b\u8fba\u3092\u6d88\u3057\u3066\u3082\u3001shortest_dist(v, u)\u306b\u306f\u5f71\u97ff\u3057\u306a\u3044\u305f\u3081)\n\n\u6700\u5f8c\u306b\u6b8b\u3063\u305f\u8fba\u3005\u3060\u3051\u3092\u3064\u306a\u3052\u3066\u3067\u304d\u308b\u30b0\u30e9\u30d5\u306e\u5408\u8a08\u306e\u8fba\u306e\u91cd\u307f\u304c\u7b54\u3048\u3068\u306a\u308b\n'''\n\nn = int(sys.stdin.readline().rstrip())\nA = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(n, n)\n\ndef main():\n    B = floyd_warshall(csr_matrix(A), directed=False).astype(np.float64)\n    if np.any(B < A):\n        return -1\n        \n    np.fill_diagonal(B, np.inf)\n    \n    for v in range(n-1):\n        for u in range(v+1, n):\n            detours = B[v] + B[u]\n            if np.any(detours == B[v, u]):\n                A[v, u] = A[u, v] = 0\n\n    return np.sum(A) // 2\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "import numpy as np\nimport sys\n\ndef read_data():\n    try:\n        LOCAL_FLAG\n        import codecs\n        import os\n\n        lines = []\n        file_path = os.path.join(os.path.dirname(__file__), 'data.dat')\n        with codecs.open(file_path, 'r', 'utf-8') as f:\n            n_lines = int(f.readline())\n            for i in range(n_lines):\n                lines.append(f.readline().rstrip(\"\\r\\n\"))\n\n    except NameError:\n        lines = []\n        n_lines = int(input())\n        for i in range(n_lines):\n            lines.append(input())\n    return lines\n\nraw_data = read_data()\ntarray = []\nfor each in raw_data:\n    tarray.append(each.split())\nA = np.array(tarray, dtype='int64')\nN = A.shape[0]\n\n\ndef Restoring_Road_Network2():\n\n    not_available = False\n    for k in range(0, N):\n        for i in range(0, N):\n            if(k==i): continue\n            for j in range(0, N):\n                if((i==j) or (j==k)): continue\n                if(A[i][k] + A[k][j] < A[i][j]):\n                    not_availabel = True\n                if(A[i][k] + A[k][j] == A[i][j]):\n                    B[i][j] = 1\n                    B[j][i] = 1\n\n    try:\n        LOCAL_FLAG\n        print(B)\n    except NameError:\n        pass\n\n    if(not_available):\n        print(-1)\n    else:\n        total_dis = 0\n        for i in range(0, N):\n            for j in range(i, N):\n                if(B[i][j] == 0):\n                    total_dis += A[i][j]\n        print(total_dis)\n\ndef Restoring_Road_Network3():\n\n    import scipy.sparse.csgraph as graph\n\n    MAX = [10000000000]*N  # should be > 2*10**9\n    d = np.diag(MAX)\n    C = A.copy()\n    C += d\n    total_dis = 0\n    n_path = 0\n    for i in range(N-1):\n        for j in range(i+1, N):\n            dis_two_node = np.min(C[i] + C[j])\n            if dis_two_node > C[i,j]:\n                total_dis += C[i,j]\n                # print(i, j)\n            elif dis_two_node < C[i,j]:\n                print(-1)\n                return\n\n    print(total_dis)\n\ndef AA():\n    import numpy as np\n\n    for i in range(N):\n        A[i][i] = 10000000000\n\n    result = 0\n    for i in range(N-1):\n        for j, d1 in enumerate(A[i][i+1:], start=i+1):\n            d2 = np.min(A[i]+A[j])\n            # print(A[i][i+1:])\n            # print (i, j, d1, d2)\n            if d1 >= d2:\n                if d1 > d2:\n                    print(-1)\n                    return\n            else:\n                result += d1\n    print(result)\n\nRestoring_Road_Network3()", "def RestoringRoadNetwork():\n    import sys\n    n = int(input())\n    wf = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n\n    # Warshall Floyd\n    for i in range(n-1):\n        for j in range(i+1, n):\n            d = wf[i][j]\n            # k\u3092\u4e2d\u7d99\u3057\u305f\u3068\u304d\u306e\u8ddd\u96e2\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                num = wf[i][k]+wf[k][j]\n                if num < d:\n                    print((-1))\n                    return\n                elif num == d:\n                    break\n            else:\n                ans += d\n    else:\n        print(ans)\n\ndef __starting_point():\n    RestoringRoadNetwork()\n    \n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN = int(input())\nA = np.asarray([[int(Aij) for Aij in input().split()] for _ in range(N)])\n\nA2 = floyd_warshall(A, directed=False)\n\nif np.any(A != A2):\n    print(-1)\nelse:\n    d = 0\n    A += np.diag([2*10**9] * N)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if np.min(A[i] + A[j]) != A[i, j]:\n                d += A[i, j]\n    print(d)", "import sys\nimport numpy as np\ninput = sys.stdin.readline\nn = int(input())\nG = np.array([list(map(int, input().split())) for _ in range(n)], dtype=float)\nuse = np.ones((n,n),dtype=bool)\nimpossible = np.zeros((n,n),dtype=bool)\nfor w in range(n):\n    D = sum(np.meshgrid(G[w], G[w]))\n    D[w] = np.inf\n    D[:,w] = np.inf\n    use &= ~(G == D)\n    impossible |= G > D\nif impossible.any():\n    print(-1)\nelse:\n    print(int(np.sum(G[use]) / 2))", "import numpy as np\nn=int(input())\nl=[np.array(input().split(), dtype=np.int64) for _ in [0]*n]\nl+=np.diag([10**10]*n)\n\nv=0\nfor i in range(n-1):\n  for j,d1 in enumerate(l[i][i+1:]):\n    d2=np.min(l[i]+l[j+i+1])\n    if d1>=d2:\n      if d1>d2:\n        print(-1)\n        return\n    else:\n      v+=d1\nprint(v)", "import sys\nimport numpy as np\ninput = sys.stdin.readline\nn = int(input())\nG = np.array([list(map(int, input().split())) for _ in range(n)], dtype=float)\nG2 = G\nfor i in range(n):\n    G2[i,i] = np.inf\nuse = np.ones((n,n),dtype=bool)\nimpossible = np.zeros((n,n),dtype=bool)\nfor w in range(n):\n    D = sum(np.meshgrid(G2[w], G2[w]))\n    use &= ~(G == D)\n    impossible |= G > D\nif impossible.sum() > n:\n    print(-1)\nelse:\n    print(int(np.sum(G[use]) / 2))", "import numpy as np\nN=int(input())\nA=[np.array(list(map(int,input().split()))) for i in range(N)]\nans=sum([sum(A[i]) for i in range(N)])\nans//=2\nfor i in range(N):\n    A[i][i]=10**10\ndef main(ans):\n    for i in range(N):\n        for j in range(i+1,N):\n            Min=np.min(A[i]+A[j])\n            if Min<A[i][j]:\n                return -1\n            if Min==A[i][j]:\n                ans-=A[i][j]\n    return ans\nprint(main(ans))", "import numpy as np\nN = int(input())\nA = np.array([list(map(int, input().split())) for _ in range(N)])\n\nfor i in range(N):\n    A[i][i] = 10 ** 9\n\nans = 0\nfor i in range(N):\n    for j in range(i+ 1, N):\n        dp = np.min(A[i] + A[j])\n        if A[i][j] < dp:\n            ans += A[i][j]\n        elif A[i][j] > dp:\n            print((-1))\n            return\n\nprint (ans)\n", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn = int(sys.stdin.readline().rstrip())\nA = np.array(sys.stdin.read().split(), dtype=np.float64).reshape(n, n)\n\ndef main():\n    B = floyd_warshall(csr_matrix(A), directed=False)\n    if np.any(B < A):\n        return -1\n        \n    np.fill_diagonal(B, np.inf)\n    \n    total_length = 0\n    for v in range(n-1):\n        for u in range(v+1, n):\n            detours = B[v] + B[u]\n            if np.all(detours > B[v, u]):\n                total_length += B[v, u]\n\n    return int(total_length)\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "N, *L = map(int, open(0).read().split())\ncost = []\nfor i,m in enumerate(zip(*[iter(L)]*N)):\n  cost.append(list(m))\n  cost[i][i] = 10**10\nans = 0\nfor i in range(N):\n  for j in range(i):\n    m = min(a+b for a, b in zip(cost[i],cost[j]))\n    if m<cost[i][j]:\n      print(-1)\n      return\n    if m>cost[i][j]:\n      ans += cost[i][j]\nprint(ans)", "def main():\n    n=int(input())\n    if n==1:\n        print(0)\n        return 0\n    import numpy as np\n    p=np.array([np.array(list(map(int,input().split()))) for _ in [0]*n])\n    if n==2:\n        print(p[0][1])\n        return 0\n    import scipy.sparse.csgraph as sp\n    ans=0\n    d=np.full((n,n),0)\n    for i in range(n):\n        for j in range(i+1,n):\n            b=p[i][j]\n            if b!=np.sort(p[i]+p[j])[2]:\n                d[i][j],d[j][i]=b,b\n                ans+=b\n    s=sp.shortest_path(d)\n    if (s==p).all():\n        print(ans)\n    else:\n        print(-1)\nmain()", "from numpy import *\nN = int(input())\nA = array([list(map(int,input().split())) for n in range(N)])\nans = 0\n\nfor n in range(N):\n  A[n][n] = 10**9\n\nfor i in range(N):\n  for j in range(i+1,N):\n    dp = min(A[i]+A[j])\n    if A[i][j]<dp:\n      ans+=A[i][j]\n    elif dp<A[i][j]:\n      print(-1)\n      return\n\nprint(ans)", "import numpy as np\nN = int(input())\nA = [np.array(input().split(), dtype=np.int64) for _ in [0]*N]\ninf = 10**10\nfor i in range(N):\n    A[i][i] = inf\n \nresult = 0\nfor i in range(N-1):\n    for j, d1 in enumerate(A[i][i+1:], start=i+1):\n        d2 = np.min(A[i]+A[j])\n        if d1 >= d2:\n            if d1 > d2:\n                print(-1)\n                return\n        else:\n            result += d1\nprint(result)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = np.array([lr() for i in range(N)])\nINF = 10 ** 10\nnp.fill_diagonal(A, INF)\nanswer = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        detour = np.min(A[i] + A[j])\n        if A[i, j] < detour:\n            # \u6700\u77ed\u8ddd\u96e2\u3068\u3057\u3066\u3053\u306e\u9053\u8def\u306f\u5fc5\u8981\n            answer += A[i, j]\n        elif A[i, j] > detour:\n            print((-1))\n            return\n\nprint(answer)\n# 05 hint\n", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = np.array([lr() for i in range(N)])\nINF = 10 ** 9\nnp.fill_diagonal(A, INF)\nanswer = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        detour = np.min(A[i] + A[j])\n        if A[i, j] < detour:\n            # \u6700\u77ed\u8ddd\u96e2\u3068\u3057\u3066\u3053\u306e\u9053\u8def\u306f\u5fc5\u8981\n            answer += A[i, j]\n        elif A[i, j] > detour:\n            print((-1))\n            return\n\nprint(answer)\n# 05 hint\n", "def main():\n    N = int(input())\n    A = [list(map(int, input().split())) for _ in range(N)]\n    ans = 0\n    for i in range(N):\n        A[i][i] = float('INF')\n    for i in range(N):\n        for j in range(i):\n            if i == j:\n                A[i][j] = float('INF')\n                continue\n            b = min(list(map(sum, list(zip(A[i], A[j])))))\n            if A[i][j] > b:\n                print((-1))\n                return\n            if b > A[i][j]:\n                ans += A[i][j]\n    print(ans)\n\n\nmain()\n", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\nimport sys\nsdin = sys.stdin.readline\n\nn = int(sdin())\ngraph = np.array([[0 for _ in range(n)] for _ in range(n)], dtype=float)\nfor i in range(n):\n    graph[i] = np.array(list(map(int, sdin().split())))\n    \n# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u3067\u6700\u77ed\u8ddd\u96e2\u51fa\u3059\nshortest = floyd_warshall(graph, directed=False)\n\n\nif any([graph[i,j] != shortest[i,j] for i in range(n) for j in range(n)]):\n    print(-1)\n    \nelse:\n    total = 0\n    INF = float(\"inf\")\n    \n    for i in range(n):\n        graph[i,i] = INF\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            via_k = np.min(graph[i] + graph[j])\n            \n            if via_k > graph[i,j]:\n                total += graph[i,j]\n                \n    print(int(total))", "N = int(input())\ngraph = [[float(\"inf\") for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    a_list = list(map(int, input().split()))\n    for j in range(N):\n        if i == j:\n            continue\n        graph[i][j] = a_list[j]\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nw_graph = floyd_warshall(graph, directed=False)\nfor i in range(N):\n    w_graph[i][i] = float(\"inf\")\nresult = 0\nfor i in range(N):\n     w_graph[i][i] = float(\"inf\")\nfor i in range(N):\n    for j in range(i):\n        if w_graph[i][j] != graph[i][j]:\n            print((-1))\n            return\n        if w_graph[i][j] < np.min(w_graph[i] + w_graph[j]):\n            result += w_graph[i][j]\nprint((int(result)))\n", "import numpy as np\nN=int(input())\nA=[np.array(list(map(int,input().split()))) for i in range(N)]\nans=sum([sum(A[i]) for i in range(N)])\nans//=2\nfor i in range(N):\n    A[i][i]=10**10\ndef main(ans):\n    for i in range(N):\n        for j in range(i+1,N):\n            Min=min(A[i]+A[j])\n            if Min<A[i][j]:\n                return -1\n            if Min==A[i][j]:\n                ans-=A[i][j]\n    return ans\nprint(main(ans))", "from itertools import product\ndef main(): \n    with open(0) as f:\n        N = int(f.readline())\n        A = [list(map(int, line.split())) for line in f.readlines()]\n\n    possible = True\n    ans = 0\n    r = range(N)\n    for i,j in product(r, r) :\n        if j <= i: continue\n        for k in r:\n            if k == i or k == j:\n                continue\n            if A[i][j] < A[i][k] + A[k][j]:\n                continue\n            elif A[i][j] == A[i][k] + A[k][j]:\n                break\n            else:\n                possible = False\n            break\n        else:\n            ans += A[i][j]\n    print(ans if possible else -1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom copy import deepcopy\nimport numpy as np\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\ndef main():\n    n=int(readline())\n    a=np.array([list(map(int,l.split())) for l in read().splitlines()])\n    cost=deepcopy(a)\n    for k in range(n):\n        arr=np.stack([cost,[cost[k]]+np.transpose([cost[k]])])\n        cost=np.amin(arr,axis=0)\n    f=np.sum(cost<a)\n    if f:\n        print((-1))\n        return\n    filt=np.sum([([cost[k]]+np.transpose([cost[k]]))==cost for k in range(n)],axis=0)==2\n    print((np.sum(a[filt])//2))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nINF=float(\"inf\")\ng=[[INF]*n for _ in range(n)]\nans=0\nfor i in range(n):\n\tfor j,c in enumerate(map(int,input().split())):\n\t\tif i!=j:\n\t\t\tg[i][j]=c\nfor i in range(n):\n\tfor j in range(i):\n\t\tm=min(a+b for a,b in zip(g[i],g[j]))\n\t\tif g[i][j]>m:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\tif g[i][j]<m:\n\t\t\tans+=g[i][j]\nprint(ans)", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn = int(sys.stdin.readline().rstrip())\nA = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(n, n)\n\ndef main():\n    B = floyd_warshall(csr_matrix(A), directed=False).astype(np.float64)\n    if np.any(B < A):\n        return -1\n        \n    np.fill_diagonal(B, np.inf)\n    \n    for v in range(n-1):\n        for u in range(v+1, n):\n            detours = B[v] + B[u]\n            if np.any(detours == B[v, u]):\n                A[v, u] = A[u, v] = 0\n                \n    return np.sum(A) // 2\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "n = int(input())\nimport numpy as np\na = np.array([list(map(int,input().split())) for _ in range(n)])\nans = 0\nfor i in range(n):\n    a[i][i] = 10**9+1\nfor i in range(n):\n    for j in range(i,n):\n        if i==j:\n            continue\n        dp = np.min(a[i]+a[j])\n        if a[i][j]<dp:\n            ans += a[i][j]\n        elif a[i][j]>dp:\n            print(-1)\n            return\nprint(ans)", "from numpy import *\nN = int(input())\nA = array([list(map(int,input().split())) for n in range(N)])\n\nfill_diagonal(A, 10**10)\n\nans = 0\nfor i in range(N):\n  for j in range(i+1,N):\n    d = min(A[i]+A[j])\n    if A[i][j] < d:\n      ans += A[i][j]\n    elif d < A[i][j]:\n      print((-1))\n      return\n\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    import numpy as np\n    from scipy.sparse.csgraph import floyd_warshall\n    A = np.array(A, dtype=np.float64)\n    B = floyd_warshall(A, directed=True)\n    if not np.array_equal(A, B):\n        return -1\n    delta = 1e-1\n    _, pre = floyd_warshall(A-delta+np.identity(N)*delta, return_predecessors=True)\n    return int(A[pre == [[i]*N for i in range(N)]].sum()) // 2\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N)] for _ in range(N)]  # type: \"List[List[int]]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nimport numpy as np\n\nn = int(input())\na = np.array([list(map(int, input().split())) for _ in range(n)])\n\ng = csr_matrix(a)\ndist = floyd_warshall(g)\n\nif (dist == a).all():\n    sm = a.sum()\n    sm //= 2\n\n    INF = 10 ** 18 + 1\n    for i in range(n):\n        a[i, i] = INF\n\n    for u in range(n):\n        for v in range(u + 1, n):\n            mn = np.min(a[u] + a[v])\n            if mn == a[u, v]:\n                sm -= a[u, v]\n\n    print(sm)\n\nelse:\n    print((-1))\n", "import numpy as np\nimport sys\n\ndef read_data():\n    try:\n        LOCAL_FLAG\n        import codecs\n        import os\n\n        lines = []\n        file_path = os.path.join(os.path.dirname(__file__), 'data.dat')\n        with codecs.open(file_path, 'r', 'utf-8') as f:\n            n_lines = int(f.readline())\n            for i in range(n_lines):\n                lines.append(f.readline().rstrip(\"\\r\\n\"))\n\n    except NameError:\n        lines = []\n        n_lines = int(input())\n        for i in range(n_lines):\n            lines.append(input())\n    return lines\n\nraw_data = read_data()\ntarray = []\nfor each in raw_data:\n    tarray.append(each.split())\nA = np.array(tarray, dtype='int64')\nN = A.shape[0]\n\ndef Restoring_Road_Network():\n\n    import scipy.sparse.csgraph as graph\n\n    MAX = [10000000000]*N  # should be > 2*10**9\n    d = np.diag(MAX)\n    C = A.copy()\n    C += d\n    total_dis = 0\n    n_path = 0\n    for i in range(N-1):\n        for j in range(i+1, N):\n            dis_two_node = np.min(C[i] + C[j])\n            if dis_two_node > C[i,j]:\n                total_dis += C[i,j]\n                # print(i, j)\n            elif dis_two_node < C[i,j]:\n                print(-1)\n                return\n\n    print(total_dis)\n\nRestoring_Road_Network()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nn = int(input())\na = np.array([[int(i) for i in input().split()] for i in range(n)])\nd,ans = floyd_warshall(a,directed=False),0\nif any(a[i][j]!=d[i][j] for i in range(n) for j in range(n)): ans = -1\nelse:\n\tinf = 10**10\n\tfor i in range(n): a[i][i] = inf\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tnum = np.min(a[i]+a[j])\n\t\t\tif num>a[i][j]: ans+=a[i][j]\nprint(int(ans))", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn = int(sys.stdin.readline().rstrip())\nA = np.array(sys.stdin.read().split(), dtype=np.float64).reshape(n, n)\n\ndef main():\n    B = floyd_warshall(csr_matrix(A), directed=False).astype(np.int64)\n    if np.any(B < A):\n        return -1\n        \n    np.fill_diagonal(A, np.inf)\n    \n    total_length = 0\n    for v in range(n-1):\n        for u in range(v+1, n):\n            detours = A[v] + A[u]\n            if np.all(detours > B[v, u]):\n                total_length += B[v, u]\n\n    return total_length\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "N = int(input())\ngraph = [[float(\"inf\") for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    a_list = list(map(int, input().split()))\n    for j in range(N):\n        if i == j:\n            continue\n        graph[i][j] = a_list[j]\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nw_graph = floyd_warshall(graph, directed=False)\nfor i in range(N):\n    w_graph[i][i] = float(\"inf\")\nresult = 0\nfor i in range(N):\n     w_graph[i][i] = float(\"inf\")\nfor i in range(N):\n    for j in range(i):\n        if w_graph[i][j] != graph[i][j]:\n            print((-1))\n            return\n        if w_graph[i][j] < np.min(w_graph[i] + w_graph[j]):\n            result += w_graph[i][j]\nprint((int(result)))\n", "def main():\n    inf=float(\"inf\")\n    n=int(input())\n    alst=[list(map(int,input().split())) for _ in range(n)]\n \n    for i in range(n):\n        alst[i][i]=inf\n \n    sm=0\n    token=0\n \n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(n):\n                if alst[i][k]+alst[k][j]>alst[i][j]:\n                    continue\n                elif alst[i][k]+alst[k][j]==alst[i][j]:\n                    break\n                else:\n                    token=1\n                    break\n            else :\n                sm+=alst[i][j]\n    \n    if token : sm=-1\n \n    print(sm)\n \nmain()", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\n\ndef main():\n    INF = 10**12\n    N = int(input())\n    A = [list(map(int, input().split(' '))) for _ in range(N)]\n    wf = floyd_warshall(A)\n    for i in range(N):\n        A[i][i] = INF\n        wf[i][i] = INF\n    ans = 0\n    for i in range(N):\n        for j in range(N):\n            if A[i][j] != wf[i][j]:\n                print(-1)\n                return\n            if wf[i][j] < np.min(wf[i] + wf[j]):\n                ans += wf[i][j]\n    print(int(ans // 2))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\ndef main():\n    N = int(input())\n    matr = np.array([tuple(map(int, input().split())) for _ in range(N)], dtype=np.int64)\n    way = floyd_warshall(matr).astype(int)\n    if np.any(way < matr):\n        print((-1))\n        return\n\n    ans = 0\n    for a, b in itertools.combinations(list(range(N)), 2):\n        eq = (matr[a, b] == (matr[a] + matr[:, b]))\n        eq[a] = eq[b] = False\n        if not np.any(eq):\n            ans += matr[a, b]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    import numpy as np\n    from scipy.sparse.csgraph import floyd_warshall\n    A = np.array(A, dtype=np.float64)\n    B = floyd_warshall(A, directed=True)\n    if not np.array_equal(A, B):\n        return -1\n    delta = 1e-3\n    _, pre = floyd_warshall(A-delta+np.identity(N)*delta, return_predecessors=True)\n    return int(A[pre == [[i]*N for i in range(N)]].sum()) // 2\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N)] for _ in range(N)]  # type: \"List[List[int]]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import numpy as np\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\ndef solve():\n    N = int(input())\n    A = np.array([input().split() for _ in range(N)], dtype=np.int64).reshape(N, N)\n    \n    B = floyd_warshall(csr_matrix(A), directed=False)\n    \n    if np.any(B < A):\n        print((-1))\n        return\n    \n    np.fill_diagonal(B, np.inf)\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if B[i][j] == np.min(B[i] + B[j]):\n                A[i][j] = A[j][i] = 0\n    print((np.sum(A) // 2))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import numpy as np\n\nn = int(input())\na = np.array([np.array(input().split(), dtype=np.uint64) for _ in range(n)], dtype=np.uint64)\n\nfor i in range(n):\n  a[i,i] = 1e9 + 1\n\nans = 0\nfor u in range(n):\n    for v in range(u + 1, n): \n        dist = a[u,v]\n        cd = np.min(a[u] + a[v])\n        if dist > cd:\n            print(-1)\n            return\n        if dist < cd:\n            ans += dist\n \nprint(int(ans))", "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nimport numpy as np\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\n\na = np.array(a)\n\ng = csr_matrix(a)\ndist = floyd_warshall(g)\n\nbl = dist == a\n\nif bl.all():\n    sm = dist.sum()\n    INF = 10 ** 18 + 1\n    inf = np.array([INF] * n)\n    inf = np.diag(inf)\n    dist += inf\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n\n            mn = np.min(dist[u] + dist[v])\n            if mn == dist[u, v]:\n                sm -= dist[u, v]\n\n    ans = int(sm) // 2\n    print(ans)\n\nelse:\n    print((-1))\n", "def main():\n    inf=float(\"inf\")\n    n=int(input())\n    alst=[list(map(int,input().split())) for _ in range(n)]\n\n    for i in range(n):\n        alst[i][i]=inf\n\n    sm=0\n    token=0\n\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(n):\n                if alst[i][k]+alst[k][j]>alst[i][j]:\n                    continue\n                elif alst[i][k]+alst[k][j]==alst[i][j]:\n                    break\n                else:\n                    token=1\n                    break\n            else :\n                sm+=alst[i][j]\n    \n    if token : sm=-1\n\n    print(sm)\n\nmain()", "from numpy import *\nN = int(input())\nA = array([input().split() for _ in range(N)], dtype=int64)\n\nfill_diagonal(A, 10**9)\n\nans = 0\nfor i in range(N):\n  for j in range(i+1,N):\n    d = min(A[i]+A[j])\n    if A[i][j] < d:\n      ans += A[i][j]\n    elif d < A[i][j]:\n      print((-1))\n      return\n\nprint(ans)\n", "import heapq\nINF = 10**10\nn = int(input())\na = [[int(item) for item in input().split()] for _ in range(n)]\nb = [[INF for _ in range(n)] for _ in range(n)]\n\nans = 0\nfor i in range(n):\n    ans += sum(a[i])\n    a[i][i] = INF\nans //= 2\n\nfor i in range(n):\n    for j in range(i):\n        bipas = min(map(sum, zip(a[i], a[j])))\n        if a[i][j] > bipas:\n            print(-1)\n            return\n        if a[i][j] == bipas:\n            ans -= a[i][j]\nprint(ans)", "import numpy as np\nimport scipy.sparse.csgraph as graph\n\nN = int(input())\nG = np.array([list(map(int, input().split())) for i in range(N)])\n\nG2 = graph.floyd_warshall(G, directed=False)\n\nif np.any(G != G2):\n    print((-1))\n    return\nelse:\n    c = [2*10**9]*N\n    d = np.diag(c)\n    G += d\n    ans = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            two = np.min(G[i]+G[j])\n            if two != G[i,j]:\n                ans += G[i,j]\n\nprint(ans)\n", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = [list(map(int, input().split())) for _ in range(N)]\n\n    INF = 10**10\n    for i in range(N):\n        A[i][i] = INF\n\n    ans = 0\n    for i in range(N):\n        for j in range(i):\n            bipas = min(list(map(sum, list(zip(A[i], A[j])))))\n\n            if A[i][j] > bipas:\n                print((-1))\n                return 0\n            elif A[i][j] < bipas:\n                ans += A[i][j]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import scipy.sparse as s,numpy as n\nf=n.loadtxt(open(0),skiprows=1)\ng=s.csgraph.dijkstra(f)\nh=n.where(g,g,1)\na=0\nfor i,t in enumerate(h):\n  for j in range(i):\n    a+=t[j]*(t[j]<t+h[j]).all()\nprint(int(a)*(f==g).all()or-1)", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall as wf\nn=int(input())\ns=np.array([list(map(int,input().split()))for i in range(n)])\nif np.any(s!=wf(s,directed=False)):\n    print(-1)\nelse:\n    c=0\n    for i in range(n):\n        s[i][i]=10**10\n    for i in range(n):\n        for j in range(i+1,n):\n            d=np.min(s[i]+s[j])\n            if s[i,j]!=d:\n                c+=s[i,j]\n    else:\n        print(c)", "import numpy as np\nN = int(input())\nA = [np.array(input().split(), dtype=np.int64) for _ in range(N)]\nans = 0\ninf = 10**10\nresult = 0\nfor i in range(N):\n    A[i][i] = inf\n\nfor i in range(N-1):\n    for j, d1 in enumerate(A[i][i+1:], start=i+1):\n        d2 = np.min(A[i]+A[j])\n        if d1 >= d2:\n            if d1 > d2:\n                print((-1))\n                return\n        else:\n            result += d1\n\nprint(result)\n", "import sys\ninput=sys.stdin.readline\nN=int(input())\ndist=[list(map(int,input().split())) for i in range(N)]\nans=sum([sum(dist[i]) for i in range(N)])\nfor i in range(N):\n    dist[i][i]=float('inf')\nans//=2\ndef main(ans):\n    for i in range(N):\n        for j in range(i+1,N):\n            Min=min(map(sum,zip(dist[i],dist[j])))\n            if Min<dist[i][j]:\n                return -1\n            if Min==dist[i][j]:\n                ans-=dist[i][j] \n    return ans\nprint(main(ans))", "import sys\nfrom copy import deepcopy\nimport numpy as np\nreadline=sys.stdin.readline\nread=sys.stdin.read\n\ndef main():\n    n=int(readline())\n    a=np.array([list(map(int,l.split())) for l in read().splitlines()])\n    cost=deepcopy(a)\n    for k in range(n):\n        arr=np.stack([cost,[cost[k]]+np.transpose([cost[k]])])\n        cost=np.amin(arr,axis=0)\n    cost2=deepcopy(a)\n    f=np.sum(cost<a)\n    if f:\n        print((-1))\n        return\n    filt=np.sum([([cost[k]]+np.transpose([cost[k]]))==cost for k in range(n)],axis=0)==2\n    print((np.sum(a[filt])//2))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nN = int(input())\nA = np.array([input().split() for _ in range(N)], dtype=np.int64)\n\nnp.fill_diagonal(A, 10**9)\n\nans = 0\nfor i in range(N):\n  for j in range(i+1,N):\n    d = np.min(A[i]+A[j])\n    if A[i][j] < d:\n      ans += A[i][j]\n    elif d < A[i][j]:\n      print((-1))\n      return\n\nprint(ans)\n", "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nimport numpy as np\n\nn = int(input())\na = np.array([list(map(int, input().split())) for _ in range(n)])\n\ng = csr_matrix(a)\ndist = floyd_warshall(g)\n\nif (dist == a).all():\n    sm = dist.sum()\n\n    INF = 10 ** 18 + 1\n    for i in range(n):\n        dist[i, i] = INF\n\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n\n            mn = np.min(dist[u] + dist[v])\n            if mn == dist[u, v]:\n                sm -= dist[u, v]\n\n    ans = int(sm) // 2\n    print(ans)\n\nelse:\n    print((-1))\n", "def main():\n    N = int(input())\n    r = range(N)\n    A = [list(map(int, input().split())) for _ in r]\n\n    for i in r: A[i][i] = float('inf')\n    possible = True\n    ans = 0\n    for i in r :\n        for j in range(i+1,N):\n            for k in r:\n                if A[i][j] < A[i][k] + A[k][j]:\n                    continue\n                elif A[i][j] == A[i][k] + A[k][j]:\n                    break\n                else:\n                    possible = False\n                    break\n            else:\n                ans += A[i][j]\n    print(ans if possible else -1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nN = int(input())\nA = np.array([input().split() for _ in range(N)], dtype=np.int64).reshape(N,N)\n\nINF = 10**15\nnp.fill_diagonal(A, INF)\n\nans = 0\nfor i in range(N-1):\n    for j in range(i+1,N):\n        detour = np.min(A[i]+A[j])\n        if detour > A[i][j]:\n            ans+=A[i][j]\n        elif detour < A[i][j]:\n            print((-1))\n            return\nprint(ans)\n", "def main():\n    n = int(input())\n    m = [list(map(int, input().split())) for _ in range(n)]\n\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            d = m[i][j]\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                t = m[i][k] + m[k][j]\n                if t < d:\n                    print((-1))\n                    return\n                if t == d:\n                    break\n            else:\n                ans += d\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nstdin = sys.stdin\n\ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn = ni()\ng = np.zeros((n,n))\nfor i in range(n):\n    g[i,:] = np.array(list(li()))\n    \n    \ndist = floyd_warshall(g, directed=False)\n\nconsis = True\nfor i in range(n):\n    for j in range(n):\n        if g[i,j] != dist[i,j]:\n            consis = False\n            break\n        \nif not consis:\n    print(-1)\n    \nelse:\n    total = 0\n    INF = float(\"inf\")\n    \n    for i in range(n):\n        dist[i,i] = INF\n        \n    for i in range(n):\n        for j in range(i+1,n):\n            via_k = np.min(dist[i] + dist[j])\n            \n            if via_k > dist[i,j]:\n                total += dist[i,j]\n                \n    print(int(total))", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nINF = 10**9\n\nn = int(input())\na = np.array([list(map(int, input().split())) for _ in range(n)])\na_opt = floyd_warshall(a)\n# for i in range(n): print(a[i], a_opt[i])\n\nfor i in range(n):\n    a[i][i] = INF\n    \nans = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if a_opt[i][j] < a[i][j]:\n            print((-1))\n            return\n        else:\n            d = a[i][j]\n            if d < np.min(a[i]+a[j]):\n                ans += d\n                \n            # Straight solution, but TLE in python\n            # for k in range(n):\n            #     if k in [i, j]:\n            #         continue\n            #     elif a[i][k]+a[k][j] == d:\n            #         d = 0\n            # ans += d\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    import numpy as np\n    from scipy.sparse.csgraph import floyd_warshall\n    A = np.array(A, dtype=np.float64)\n    B = floyd_warshall(A, directed=True)\n    if not np.array_equal(A, B):\n        return -1\n    delta = 1e-7\n    _, pre = floyd_warshall(A-delta+np.identity(N)*delta, return_predecessors=True)\n    return int(A[pre == [[i]*N for i in range(N)]].sum()) // 2\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N)] for _ in range(N)]  # type: \"List[List[int]]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import scipy.sparse as s,numpy as n\nf=n.loadtxt(open(0),skiprows=1)\ng=s.csgraph.dijkstra(f)\nh=n.where(g,g,1)\nprint(int(sum(t[j]*(t[j]<t+h[j]).all()for i,t in enumerate(h)for j in range(i)))*(f==g).all()or-1)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = np.array([lr() for i in range(N)])\nINF = 10 ** 10\nnp.fill_diagonal(A, INF)\nanswer = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        detour = np.min(A[i] + A[j])\n        if A[i, j] < detour:\n            # \u6700\u77ed\u8ddd\u96e2\u3068\u3057\u3066\u3053\u306e\u9053\u8def\u306f\u5fc5\u8981\n            answer += A[i, j]\n        elif A[i, j] > detour:\n            print((-1))\n            return\n\nprint(answer)\n# 05 hint\n", "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\nimport numpy as np\nN = int(input())\nA = np.array([list(map(int, input().split())) for _ in [0]*N], dtype=np.int)\nD = csgraph_from_dense(A)\nD = floyd_warshall(D, directed=False)\n\nif (A == D).all():\n    ans = 0\n    D += np.identity(N, int) * (1 << 60)\n    for i in range(N):\n        for j in range(i+1, N):\n            a = np.min(D[i]+D[j])\n            if a > D[i, j]:\n                ans += D[i, j]\n    print((int(ans)))\nelse:\n    print((-1))\n"]
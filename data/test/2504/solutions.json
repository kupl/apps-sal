["import numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\ninf = float(\"inf\")\nN, M, L = map(int, input().split())\ngraph = np.zeros((N, N))\nfor _ in range(M):\n    A, B, C = map(int, input().split())\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\nshortest_paths = shortest_path(csr_matrix(graph), directed=False, method=\"FW\")\ngraph = np.full((N, N), inf)\nfor i in range(N):\n    for j in range(N):\n        if shortest_paths[i][j] <= L:\n            graph[i][j] = 1\n\nQ = int(input())\ndef int_(num_str):\n    return int(num_str) - 1\n\ncosts = shortest_path(csr_matrix(graph), directed=False, method=\"FW\")\nfor _ in range(Q):\n    s, t = map(int_, input().split())\n    print(int(costs[s][t])-1 if costs[s][t] != inf else -1)", "import numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.csgraph import shortest_path\n\nn,m,limit=map(int,input().split())\nG=np.zeros((n,n),dtype=np.int64)\nfor i in range(m):\n    a,b,cost=map(int,input().split())\n    G[a-1,b-1]=cost\n    G[b-1,a-1]=cost\nG=shortest_path(G,method='FW')\nfor c in range(n):\n    for l in range(n):\n        if G[c][l]<=limit:\n            G[c][l]=1\n        else:\n            G[c][l]=0\nG=shortest_path(G,method='FW')\nq=int(input())\nQ=[map(int,input().split())for i in range(q)]\nfor a,b in Q:\n    print(int(G[a-1][b-1])-1 if G[a-1][b-1]<10**18 else -1)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nN,M,L=map(int,input().split())\nd=[[0 for i in range(0,N)] for i in range(0,N)]\nfor i in range(0,M):\n    a,b,c=map(int,input().split())\n    d[a-1][b-1]=c\n    d[b-1][a-1]=c\n\ncsr1=csr_matrix(d)\n\na=floyd_warshall(csr1)\n\nd=[[0 for i in range(0,N)] for j in range(0,N)]\nfor i in range(0,N):\n    for j in range(0,N):\n        if L>=a[i][j]:\n            d[i][j]=1\n\n\ncsr2=csr_matrix(d)\n\ndata=floyd_warshall(csr2)\nans=[]\nQ=int(input())\nfor i in range(0,Q):\n    s,t=map(int,input().split())\n    if data[s-1][t-1]!=float('inf'):\n        ans.append(int(data[s-1][t-1])-1)\n    else:\n        ans.append(-1)\n\nfor i in range(Q):\n    print(ans[i])", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = list(map(int, input().split()))\nMap = np.full((N, N), 10**12, dtype='int64')\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    Map[a][b] = c\n    Map[b][a] = c\nQ = int(input())\nQuery = [tuple(map(int, input().split())) for _ in range(Q)]\ngraph = floyd_warshall(Map).astype('int64')\ngraph[graph <= L] = 1\ngraph[graph > L] = 10**12\nA = floyd_warshall(graph).astype('int64')\nfor s, t in Query:\n    if A[s - 1][t - 1] >= 10**12:\n        print((-1))\n    else:\n        print((int(A[s - 1][t - 1] - 1)))\n", "import sys\nimport numpy as np\nfrom scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall, shortest_path\n\ninput = sys.stdin.readline\n\ndef main():\n    n, m, l = map(int, input().split())\n    wf = [[0 for i in range(n)] for j in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        wf[a-1][b-1] = wf[b-1][a-1] = c\n    wf = np.array(wf)\n    for i in range(n):\n        wf[i][i] = 0\n    wf = shortest_path(wf, method='FW')\n    for i in range(n):\n        for j in range(n):\n            if wf[i][j] <= l:\n                wf[i][j] = 1\n            else:\n                wf[i][j] = 301\n    wf = shortest_path(wf, method='FW')\n    q = int(input())\n    ans = [None] * q\n    for i in range(q):\n        s, t = map(int, input().split())\n        if wf[s-1][t-1] < 301:\n            ans[i] = int(wf[s-1][t-1])\n        else:\n            ans[i] = 0\n    for i in range(q):\n        print(ans[i] - 1)\n\ndef __starting_point():\n    main()\n__starting_point()", "from scipy.sparse.csgraph import floyd_warshall\nN,M,L,*X = map(int, open(0).read().split())\nls = X[:3*M]\nEls = [[0]*N for i in range(N)]\nQ = X[3*M]\nquery = X[3*M+1:]\nfor a,b,c in zip(*[iter(ls)]*3):\n  if c<=L:\n    Els[a-1][b-1] = c\n    Els[b-1][a-1] = c\ndist = floyd_warshall(Els)\n      \nEls2 = [[1 if dist[i][j]<=L else 0 for j in range(N)] for i in range(N)]\nans = floyd_warshall(Els2)\n\nfor s,t in zip(*[iter(query)]*2):\n  if ans[s-1][t-1]==float('inf'):\n    print(-1)\n    continue\n  print(int(ans[s-1][t-1])-1)", "# -*- coding: utf-8 -*-\n\"\"\"\nE - Travel by Car\nhttps://atcoder.jp/contests/abc143/tasks/abc143_e\n\n\"\"\"\nimport sys\n\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\ndef main(args):\n    N, M, L = list(map(int, input().split()))\n    g1 = [[float('inf')] * (N+1) for _ in range(N+1)]\n    for i in range(N+1):\n        g1[i][i] = 0\n    for _ in range(M):\n        A, B, C = list(map(int, input().split()))\n        g1[A][B] = g1[B][A] = C\n    d1 = floyd_warshall(g1)\n    g2 = [[float('inf')] * (N+1) for _ in range(N+1)]\n    for i in range(N+1):\n        for j in range(N+1):\n            if i == j:\n                g2[i][j] = 0\n            elif d1[i][j] <= L:\n                g2[i][j] = g2[j][i] = 1\n    d2 = floyd_warshall(g2)\n    Q = int(input())\n    for _ in range(Q):\n        s, t = list(map(int, input().split()))\n        print((-1 if d2[s][t] == float('inf') else int(d2[s][t]) - 1))\n\n\ndef __starting_point():\n    main(sys.argv[1:])\n\n__starting_point()", "# scipy\u4f7f\u3046\u5834\u5408\nimport sys\ninput = sys.stdin.readline\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn,m,l = list(map(int,input().split()))\n\n# m\u884c\u306e\u5165\u529b\u304b\u3089\u8ddd\u96e2\u3092\u5024\u306b\u6301\u3064\u96a3\u63a5\u884c\u5217\u3092\u4f5c\u6210 0-indexed\n# directed:\u7121\u5411\u30b0\u30e9\u30d5\u306a\u3089False\u3001\u6709\u5411\u30b0\u30e9\u30d5\u306a\u3089True\ndef make_d_matrix(n,m,directed=False):\n    inf = 10**13\n    d = [[inf] * n for _ in range(n)]\n    if(directed):\n        for _ in range(m):\n            a,b,c = list(map(int, input().split()))\n            d[a-1][b-1] = c\n    else:\n        for _ in range(m):\n            a,b,c = list(map(int, input().split()))\n            d[a-1][b-1] = c\n            d[b-1][a-1] = c\n    return d\n\nd = make_d_matrix(n,m)\ncsr_graph = csr_matrix(d)\nd1 = floyd_warshall(csr_graph,directed=False)\n\ninf = 10**3\nfor i in range(n):\n    for j in range(n):\n        d1[i][j] = 1 if (d1[i][j] <= l) else inf\n\ncsr_graph = csr_matrix(d1)\nd2 = floyd_warshall(csr_graph,directed=False)\n\nq = int(input())\n\nfor _ in range(q):\n    s,t = list(map(int, input().split()))\n    tmp = d2[s-1][t-1]\n    if(tmp >= inf):\n        print((-1))\n    else:\n        print((int(tmp-1)))\n", "import sys\nsys.setrecursionlimit(1000000000)\nii = lambda: int(input())\nii0 = lambda: ii() - 1\nmis = lambda: list(map(int, input().split()))\nlmis = lambda: list(mis())\nINF = float('inf')\n\ndef main():\n    N,M,L = mis()\n    from scipy.sparse.csgraph import floyd_warshall\n    import numpy as np\n    INF = np.iinfo(np.int64).max\n    d = np.full((N,N), INF, dtype=np.uint64)\n    for i in range(N):\n        d[i,i] = 0\n    #\n    for _ in range(M):\n        a,b,c = mis()\n        a -= 1\n        b -= 1\n        if c <= L:\n            d[a,b] = c\n            d[b,a] = c\n    #\n    '''\n    for k in range(N):\n        for i in range(N):\n            np.minimum(d[i,:], d[i,k]+d[k,:], out=d[i,:])    \n    '''\n    d = floyd_warshall(d)\n    #\n    d2 = np.full((N,N), INF, dtype=np.uint64)\n    for i in range(N):\n        d2[i, i] = 0\n    for i in range(N):\n        for j in range(N):\n            if d[i, j] <= L:\n                d2[i, j] = 1\n    #\n    '''\n    for k in range(N):\n        for i in range(N):\n            np.minimum(d2[i,:], d2[i,k]+d2[k,:], out=d2[i,:])    \n    '''\n    d2 = floyd_warshall(d2)\n    #\n    Q = ii()\n    for _ in range(Q):\n        s,t = mis()\n        s -= 1\n        t -= 1\n        dist = d2[s,t]\n        if dist == INF:\n            print((-1))\n        else:\n            print((int(dist)-1))\n\n\n\n\nmain()\n", "MOD = 10 **9 + 7\nINF = 10 ** 10\nimport numpy as np\nfrom  scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ndef main():\n    n,m,l = map(int,input().split())\n    dist = [[INF] * n for _ in range(n)]  \n    for _ in range(m):\n        a,b,c = map(int,input().split())\n        a -= 1\n        b -= 1\n        dist[a][b] = c\n        dist[b][a] = c\n\n    csr = csr_matrix(dist)\n    dist1 = floyd_warshall(csr)\n    dist1 = np.where(dist1 <= l,1,INF)\n    cnt = floyd_warshall(dist1)\n    q = int(input())\n    for _ in range(q):\n        s,t = map(int,input().split())\n        s -= 1\n        t -= 1\n        print(-1 if cnt[s][t] == INF  else int(cnt[s][t]) - 1)\ndef __starting_point():\n    main()\n__starting_point()", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import numpy as np\n    import sys\n    input = sys.stdin.readline\n    n, m, l = list(map(int, input().split()))\n    inf = 10 ** 20\n    ar = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1][b - 1] = c\n        ar[b - 1][a - 1] = c\n    x = floyd_warshall(ar)\n    br = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i][j] = 1\n                br[j][i] = 1\n    y = floyd_warshall(br)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        p = y[s - 1, t - 1]\n        print((int(p) - 1 if p < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nimport sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn, m, l = map(int, input().split())\ndist = [[0 for _ in range(n)] for _ in range(n)]\nfor _ in range(m):\n\ta, b, c = map(int, input().split())\n\tdist[a-1][b-1] = c\n\tdist[b-1][a-1] = c\n\nfw = floyd_warshall(csr_matrix(dist))\n\nnum = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tfor j in range(n):\n\t\tif fw[i][j] <= l:\n\t\t\tnum[i][j] = 1\n\nans = floyd_warshall(csr_matrix(num))\n\nq = int(input())\nfor _ in range(q):\n\ts, t = map(int, input().split())\n\tif ans[s-1][t-1] > n:\n\t\tprint(-1)\n\telse:\n\t\tprint(int(ans[s-1][t-1])-1)", "from scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = list(map(int, input().split()))\nedges = [[0] * N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    edges[a - 1][b - 1] = c\n    edges[b - 1][a - 1] = c\n\nQ = int(input())\nst = []\nfor _ in range(Q):\n    st.append([int(j) - 1 for j in input().split()])\n\nedges = floyd_warshall(edges)\n\nfor i in range(N):\n    for j in range(N):\n        if edges[i][j] <= L:\n            edges[i][j] = 1\n        else:\n            edges[i][j] = 0\n\nedges = floyd_warshall(edges)\n\nfor i, j in st:\n    if edges[i][j] == float(\"inf\"):\n        print((-1))\n    else:\n        print((int(edges[i][j]) - 1))\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, L: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\", Q: int, s: \"List[int]\", t: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import coo_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    from itertools import filterfalse\n    # coo_matrix((data, (i, j)), [shape=(M, N)])\n    mat = floyd_warshall(coo_matrix((C, (A, B)), shape=(N+1, N+1), dtype=np.int32).tocsr(), directed=False)\n    mat = floyd_warshall(mat <= L, directed=False)\n    for ss, tt in zip(s, t):\n        yield -1 if np.isinf(mat[ss][tt]) else int(mat[ss][tt]) - 1\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    L = int(next(tokens))  # type: int\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    Q = int(next(tokens))  # type: int\n    s = [int()] * (Q)  # type: \"List[int]\"\n    t = [int()] * (Q)  # type: \"List[int]\"\n    for i in range(Q):\n        s[i] = int(next(tokens))\n        t[i] = int(next(tokens))\n    print(*solve(N, M, L, A, B, C, Q, s, t), sep=\"\\n\")\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, L: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\", Q: int, s: \"List[int]\", t: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import coo_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n   # coo_matrix((data, (i, j)), [shape=(M, N)])\n    mat = floyd_warshall(coo_matrix((C, (A, B)), shape=(N+1, N+1), dtype=np.int32).tocsr(), directed=False)\n    mat = floyd_warshall(mat <= L, directed=False)\n    for ss, tt in zip(s, t):\n        yield -1 if np.isinf(mat[ss][tt]) else int(mat[ss][tt]) - 1\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    L = int(next(tokens))  # type: int\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    Q = int(next(tokens))  # type: int\n    s = [int()] * (Q)  # type: \"List[int]\"\n    t = [int()] * (Q)  # type: \"List[int]\"\n    for i in range(Q):\n        s[i] = int(next(tokens))\n        t[i] = int(next(tokens))\n    print(*solve(N, M, L, A, B, C, Q, s, t), sep=\"\\n\")\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappop, heappush\nfrom scipy.sparse.csgraph import floyd_warshall\ninput = sys.stdin.readline\n \ndef main():\n    n,w,l = map(int,input().split())\n    d = [[10**15 for _ in range(n)] for _ in range(n)]\n    for _ in range(w):\n        x,y,z = map(int,input().split())\n        x -= 1\n        y -= 1\n        if z > l:\n            continue\n        d[x][y] = z\n        d[y][x] = z\n    for i in range(n):\n        d[i][i] = 0\n    d = floyd_warshall(d)\n    G = [[10**15 for _ in range(n)] for _ in range(n)]\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if d[i][j] <= l:\n                G[i][j] = 1\n                G[j][i] = 1\n    for i in range(n):\n        G[i][i] = 0\n    G = floyd_warshall(G)\n    q = int(input())\n    for _ in range(q):\n        s,t = map(int,input().split())\n        s -= 1\n        t -= 1\n        ans = G[s][t]\n        if ans == 10**15:\n            print(-1)\n            continue\n        print(int(ans)-1)\n    \ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\ndef main():\n    N, M, L = map(int, input().split())\n    graph = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        s, t, w = map(int, input().split())\n        if w <= L:\n            graph[s-1][t-1] = graph[t-1][s-1] = w\n    graph = floyd_warshall(graph, directed=False)\n    graph = floyd_warshall(graph <= L, directed=False)\n    graph[np.isinf(graph)] = 0\n\n    Q = int(input())\n    ans = []\n    for _ in range(Q):\n        s, t = map(int, input().split())\n        ans.append(int(graph[s-1][t-1]) - 1)\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ninput = sys.stdin.readline\n\ncost = []\nrow = []\ncol = []\n\nn, m, l = list(map(int, input().split()))\n\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    cost.append(c)\n    row.append(a-1)\n    col.append(b-1)\n\nq = int(input())\nst = [list(map(int, input().split())) for _ in range(q)]\n\ncsr = csr_matrix((cost, (row, col)), shape = (n, n))\npath = floyd_warshall(csr, directed=False)\n\ncost = []\nrow = []\ncol = []\n\nfor i in range(n):\n    for j in range(n):\n        if path[i][j] <= l:\n            cost.append(1)\n            row.append(i)\n            col.append(j) \n\ncsr = csr_matrix((cost, (row, col)), shape = (n, n))\npath = floyd_warshall(csr, directed=False)\n\nINF = float('inf')\n\nfor s,t in st:\n    ans = path[s-1][t-1]\n    if ans == INF:\n        print((-1))\n    else:\n        print((int(ans) - 1))\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn,m,l = map(int,input().split())\nA = [list(map(int,input().split())) for i in range(m)]\nq = int(input())\nS = [list(map(int,input().split())) for i in range(q)]\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nfor i in range(m):  # \u30ce\u30fc\u30c9\u756a\u53f7\u304c1\u59cb\u307e\u308a\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u5834\u5408\n    for j in range(2):\n        A[i][j] -= 1\n\nfor i in range(q):  # \u30ce\u30fc\u30c9\u756a\u53f7\u304c1\u59cb\u307e\u308a\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u5834\u5408\n    for j in range(2):\n        S[i][j] -= 1\n\nM = [[float(\"inf\")] * n for i in range(n)]\n\nfor i in range(n):\n    M[i][i] = 0\n\nfor i in range(m):\n    M[A[i][0]][A[i][1]] = A[i][2]\n    M[A[i][1]][A[i][0]] = A[i][2]\n\n# for k in range(n):\n#     for i in range(n):\n#         for j in range(n):\n#             M[i][j] = min(M[i][j], M[i][k] + M[k][j])\n\nM = floyd_warshall(M)\n\nfor i in range(n):\n    for j in range(n):\n        M[i][j] = 1 if M[i][j] <= l else float(\"inf\")\n\nfor i in range(n):\n    M[i][i] = 0\n\n# for k in range(n):\n#     for i in range(n):\n#         for j in range(n):\n#             M[i][j] = min(M[i][j], M[i][k] + M[k][j])\n\nM = floyd_warshall(M)\n\nfor i in range(q):\n    ans = M[S[i][0]][S[i][1]]-1\n    if ans == float(\"inf\"):\n        ans = -1\n    print(int(ans))", "# -*- coding: utf-8 -*-\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\"\"\"\ndef warshall_floyd(d):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                d[i][j] =min(d[i][j],d[i][k] + d[k][j])            \n    return d\n\"\"\"\nN, M, L = map(int, input().split())\n\nd = [[0 for i in range(N)] for i in range(N)]\n\nfor i in range(M):\n    A, B, C = map(int, input().split())\n    d[A-1][B-1] = C\n    d[B-1][A-1] = C\n\nd = floyd_warshall(d, directed = False)\nS = [[0 for i in range(N)] for i in range(N)]\n\n\nfor i in range(N):\n    for j in range(N):\n        if d[i][j] <= L:\n            S[i][j] = 1\n            S[j][i] = 1\n            \nS = floyd_warshall(S, directed = False)\n\nQ = int(input())\n\nfor i in range(Q):\n    s, t = map(int, input().split())\n    if S[s-1][t-1] == float(\"inf\"):\n        print(-1)\n    else: \n        print(int(S[s-1][t-1]-1))", "# -*- coding: utf-8 -*-\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = map(int,input().split())\n  \nd = [[0 for i in range(N)] for j in range(N)] \nfor i in range(M):\n    x,y,z = map(int,input().split())\n    d[x-1][y-1] = z\n    d[y-1][x-1] = z\nfor i in range(N):\n    d[i][i] = 0\n\nd = floyd_warshall(d, directed = False)\nLN = [[0 for i in range(N)] for j in range(N)]\n\nfor i in range(N):\n    for j in range(N):\n        if d[i][j] <= L:\n            LN[i][j] = 1\n            LN[j][i] = 1\n\nLN = floyd_warshall(LN, directed = False)    \ns = []\nt = []\nQ = int(input())\nfor i in range(Q):\n    s1, t1 = map(int,input().split())\n    s.append(s1)\n    t.append(t1)\nfor i in range(Q):\n    if LN[s[i]-1][t[i]-1] == float(\"inf\"):\n        print(-1)\n    else:\n        print(int(LN[s[i]-1][t[i]-1]-1))", "from scipy.sparse.csgraph import floyd_warshall\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u3067\u306f\u306a\u304f\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u3067\u89e3\u304f\nN, M, L = list(map(int, input().split()))\n# graph = [[] for _ in range(N)]\ndistant = [[float('inf')]*N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a, b = a-1, b-1\n    if c > L:\n        continue\n    distant[a][b] = c\n    distant[b][a] = c\n\ndistant = floyd_warshall(distant)\nanother = [[float('inf')]*N for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if distant[i][j] <= L:  # \u884c\u3051\u308b\u3068\u3053\u308d\u307e\u3067\u3044\u304f\u3068\u3044\u3046\u5370\u8c61\n            another[i][j] = 1\nanother = floyd_warshall(another)\nQ = int(input())\nfor _ in range(Q):\n    s, t = [int(x)-1 for x in input().split()]\n    if another[s][t] == float('inf'):\n        print((-1))\n        continue\n    print((int(another[s][t])-1))\n    # if distant[s][t] == float('inf'):\n    #     print(-1)\n    #     continue\n    # print(int(distant[s][t])//L + min(1, int(distant[s][t]) % L) - 1)\n# \u71c3\u6599\u304c4\u3067\n# 1 -> 4 -> 2\n# \u306e\u3068\u304d\u3001\u8ddd\u96e2\u306f7\u3060\u304b\u3089\u4e00\u898b\u3059\u308b\u3068\u88dc\u7d66\u56de\u6570\u306f1\u3067\u826f\u3055\u305d\u3046\u3060\u3051\u3069\u3001\u5b9f\u306f2\u56de\u5fc5\u8981\n# \u4eca\u3001\uff12\u70b9\u9593\u306e\u6700\u5c0f\u8ddd\u96e2\u3092\u6c42\u3081\u3066\u304a\u3044\u3066\u3001\u3082\u3046\u4e00\u3064\u306e\u30b0\u30e9\u30d5\u306f\u300c\u6700\u77ed\u8ddd\u96e2\u304cL\u4ee5\u4e0b\u306e2\u70b9\u306b\u8fba(\u91cd\u307f1)\u3092\u5f35\u308b\u300d\n", "import numpy as np\nimport sys\nfrom scipy.sparse.csgraph import floyd_warshall,csgraph_from_dense\nfrom scipy.sparse import csr_matrix\ninput = sys.stdin.readline\ndef inputs():return [int(x) for x in input().split()]\nN,M,L = inputs()\nABC =[inputs() for _ in range(M)]\ngraph = [[10**13]*(N+1) for _ in range(N+1)]\nfor a,b,c in ABC:\n    graph[a][b] = c\nG = csgraph_from_dense(graph, null_value=10**13)\ndist_mat = floyd_warshall(graph,directed=False)\ngraph2 = np.array([[10**13]*(N+1) for _ in range(N+1)])\nnp.fill_diagonal(graph2,0)\ngraph2[dist_mat<=L]=1\ndist_mat2 = floyd_warshall(graph2,directed=False)\ndist_mat2[dist_mat2==10**13]=0\nQ = int(input())\nfor i in range(Q):\n    s,t = inputs()\n    print((int(dist_mat2[s,t])-1))\n\n", "from scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = map(int, input().split())\n\nG = [list(map(int, input().split())) for _ in range(M)]\nQ = int(input())\nQuery = [list(map(int, input().split())) for _ in range(Q)]\n\n# neighborhood graph\nnei_graph = [[0] * N for _ in range(N)]\nfor a, b, c in G:\n    nei_graph[a - 1][b - 1] = c\n    nei_graph[b - 1][a - 1] = c\n\n# Warshall Floyd\nnei_graph = floyd_warshall(nei_graph)\n\n# 1 if distance is less than L\nfor i in range(N):\n    for j in range(N):\n        if nei_graph[i][j] <= L:\n            nei_graph[i][j] = 1\n        else:\n            nei_graph[i][j] = 0\n\nnei_graph = floyd_warshall(nei_graph)\n\nfor start, end in Query:\n    if nei_graph[start - 1][end - 1] - 1 == float('inf'):\n        print(-1)\n    else:\n        print(int(nei_graph[start - 1][end - 1] - 1))", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN,M,L = map(int,input().split())\ngurahu = np.zeros((N,N))\n\nfor k in range(M):\n    a,b,c = map(int,input().split())\n    gurahu[a-1,b-1] = c\n    gurahu[b-1,a-1] = c\n\ngurahu = floyd_warshall(gurahu, directed=False)\ngurahu = np.where((gurahu <= L) & (gurahu > 0), 1, 0)\ngurahu = floyd_warshall(gurahu) - np.ones((N, N))\n\nQ = int(input())\n\nfor k in range(Q):\n    s,t = map(int,input().split())\n    ans = gurahu[s-1,t-1]\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(int(ans))", "3\n# -*- coding: utf-8 -*-\n\n# scipy version\n\nimport sys\nfrom collections import deque\nfrom array import array\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n')\n\n##### main\n\nN,M,L = list(map(int, input().split()))\n\nC = [[0]*N for _ in range(N)]\n\nfor i in range(M):\n    a,b,c = list(map(int, input().split()))\n    if c>L:\n        continue\n    C[a-1][b-1] = c\n\nQ = int(input())\n\nST = [None]*Q\n\nfor i in range(Q):\n    s, t = list(map(int, input().split()))\n    ST[i] = (s-1,t-1)\n\ndist_matrix, predecessors = floyd_warshall(csgraph=C, directed=False, return_predecessors=True)\n\n# D[i][j] <= L \u3068\u306a\u308b i,j \u306b\u8fba\u3092\u5f35\u308b\nfor i in range(N):\n    for j in range(i+1,N):\n        if dist_matrix[i][j] <= L:\n            C[i][j] = 1\n\ndist_matrix, predecessors = floyd_warshall(csgraph=C, directed=False, return_predecessors=True)\n\n# answer\nfor q in range(Q):\n    i,j = ST[q]\n    step = dist_matrix[i][j]\n    if step > 10**9:\n        print((-1))\n    else:\n        print((int(step-1)))\n", "from scipy.sparse.csgraph import dijkstra as di\n\nn,m,l = list(map(int, input().split()))\n\ninf = float('INF')\nroad = [[0 for i in range(n)] for j in range(n)]\nfor i in range(m):\n    a,b,c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    road[a][b] = road[b][a] = c\n\ndef warshall(d, n):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if d[i][k] + d[k][j] < d[i][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n\nroads = di(road, n)\n# [print(cost) for cost in road]\n# print()\ncosts = [[1 if roads[i][j] <= l and i != j else 0 for j in range(n)] for i in range(n)]\ncosts = di(costs, n)\n\n# [print(cost) for cost in costs]\nq = int(input())\nfor i in range(q):\n    s,t = list(map(int, input().split()))\n    \n    print((int(costs[s-1][t-1]-1) if costs[s-1][t-1] < inf else -1))\n", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN,M,L=list(map(int,input().split()))\nINF = 1 << 31\ndist=np.array([[INF for _ in range(N)] for _ in range(N)])\n\nfor i in range(N):\n  dist[i][i]=0\n  \nfor i in range(M):\n  a,b,c=list(map(int,input().split()))\n  a-=1\n  b-=1\n  dist[a][b]=c\n  dist[b][a]=c\n\ndist = floyd_warshall(dist)\n\nfor i in range(N):\n  for j in range(N):\n    if dist[i][j]<=L:\n      dist[i][j]=1\n    else:\n      dist[i][j]=INF\n\ndist = floyd_warshall(dist)\ndist[dist==INF]=0\n#dist=dist.astype(int)\n#print(dist)\n\nQ=int(input())\nans=[0]*Q\nfor q in range(Q):\n  s,t=list(map(int,input().split()))\n  s-=1\n  t-=1\n  ans[q]=int(dist[s][t]-1)\n\nfor a in ans:\n  print((-1 if a==INF else a))\n\n", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, m, l = list(map(int, input().split()))\n    inf = float(\"inf\")\n    ar = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1][b - 1] = c\n    x = floyd_warshall(ar, directed=False)\n    br = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i][j] = 1\n    y = floyd_warshall(br, directed=False)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        print((int(y[s - 1, t - 1]) - 1 if y[s - 1, t - 1] < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nimport numpy as np\nfrom scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall, csgraph_to_dense\nfrom scipy.sparse import issparse\nsys.setrecursionlimit(10**7)\n\nn, m, l = [int(i) for i in sys.stdin.readline().split()]\ngraph = [[0 for i in range(n)] for j in range(n)]\nfor i in range(m):\n    a, b, c = [int(i) for i in sys.stdin.readline().split()]\n    a -= 1\n    b -= 1\n    graph[a][b] = c\n    graph[b][a] = c\n\nres = floyd_warshall(csgraph_from_dense(graph))\nif issparse(res):\n    res = csgraph_to_dense(res)\nres = np.where(res <= l, 1, 0)\nnew_res = floyd_warshall(res)\nnew_res[new_res == np.inf] = 0\nq = int(input())\nfor j in range(q):\n    s, t = [int(i) for i in sys.stdin.readline().split()]\n    s -= 1\n    t -= 1\n    dis = new_res[s, t]\n    print(int(dis) - 1)", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\nN, M, L = list(map(int, input().split()))\n\nstart = []\ngoal = []\ncost = []\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    A -= 1\n    B -= 1\n    start.append(A)\n    goal.append(B)\n    cost.append(C)\n    start.append(B)\n    goal.append(A)\n    cost.append(C)\n\ngraph = csr_matrix((cost, (start, goal)), shape = (N, N))\ncan_reach_with_L = dijkstra(graph, directed = False, limit = L)\nans = dijkstra(can_reach_with_L, directed = False, unweighted = True)\n\nQ = int(input())\nfor _ in range(Q):\n    s, t = list(map(int, input().split()))\n    s -= 1\n    t -= 1\n    if ans[s][t] == float('inf'):\n        print((-1))\n    else:\n        print((int(ans[s][t] + 0.5) - 1))\n", "from scipy.sparse.csgraph import floyd_warshall\n \n# \u4e0b\u6e96\u5099\nN, M, L = map(int,input().split())\nd = [[float(\"inf\") for i in range(N)] for j in range(N)]\nanswer_d = [[float(\"inf\") for i in range(N)] for j in range(N)]\nfor i in range(M):\n    A, B, C = map(int,input().split())\n    d[A-1][B-1] = d[B-1][A-1] = C\nfor i in range(N):\n    d[i][i] = 0\n \n# \u71c3\u6599\u88dc\u7d66\u56de\u6570\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\nd = floyd_warshall(d)\nfor i in range(N):\n    for j in range(N):\n        if d[i][j] <= L:\n            answer_d[i][j] = answer_d[j][i] = 1\nd = floyd_warshall(answer_d)\n \n# \u30af\u30a8\u30ea\u3092\u7b54\u3048\u308b\nQ = int(input())\nanswer = [-1]*Q\nfor i in range(Q):\n    s, t = map(int,input().split())\n    if d[s-1][t-1] != float(\"inf\"):\n        answer[i] = d[s-1][t-1]-1\n \nfor i in answer:\n    print(i)", "import sys\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = map(int, input().split())\nINF = 10 **9 +1\nG = [[float('inf')] * N for i in range(N)]\nfor i in range(M):\n  a, b, c = map(int, input().split())\n  a, b, = a - 1, b -1\n  G[a][b] = c\n  G[b][a] = c\n\n#\u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u8a08\u7b97\nG = floyd_warshall(G)\n\n\n#\u30b3\u30b9\u30c8L\u4ee5\u4e0b\u3067\u79fb\u52d5\u53ef\u80fd\u306a\u9802\u70b9\u9593\u306e\u30b3\u30b9\u30c81\u306e\u8fba\u3092\u5f35\u308b\nE = [[float('inf')] * N for i in range(N)]\nfor i in range(N):\n  for j in range(N):\n    if G[i][j] <= L:\n      E[i][j] = 1\n\n#\u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u8a08\u7b97\nE = floyd_warshall(E)\n\n#\u30af\u30a8\u30ea\u306b\u7b54\u3048\u3066\u3044\u304f\nQ = int(input())\nfor i in range(Q):\n  s, t = map(int, input().split())\n  s, t = s - 1, t-1\n  print(int(E[s][t] - 1) if E[s][t] != float('inf') else -1)", "MOD = 10 **9 + 7\nINF = 10 ** 10\nimport numpy as np\nfrom  scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ndef main():\n    n,m,l = map(int,input().split())\n    dist = [[np.inf] * n for _ in range(n)]  \n    for _ in range(m):\n        a,b,c = map(int,input().split())\n        a -= 1\n        b -= 1\n        dist[a][b] = c\n        dist[b][a] = c\n\n    csr = csr_matrix(dist)\n    dist1 = floyd_warshall(csr,directed = False)\n    dist1 = np.where(dist1 <= l,1,np.inf)\n    cnt = floyd_warshall(dist1,directed = False)\n    cnt[cnt == np.inf] = 0\n    cnt = cnt.astype(int)\n    q = int(input())\n    for _ in range(q):\n        s,t = map(int,input().split())\n        s -= 1\n        t -= 1\n        print(cnt[s][t] - 1)\ndef __starting_point():\n    main()\n__starting_point()", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, m, l = list(map(int, input().split()))\n    inf = 10 ** 20\n    ar = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1][b - 1] = c\n    x = floyd_warshall(ar, directed=False)\n    br = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i][j] = 1\n    y = floyd_warshall(br, directed=False)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        p = y[s - 1, t - 1]\n        print((int(y[s - 1, t - 1]) - 1 if y[s - 1, t - 1] < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nN, M, L = map(int, input().split())\n\nINF = 10 ** 18\ndist1 = [[INF] * N for _ in range(N)]\nfor i in range(N):\n    dist1[i][i] = 0\n\nfor _ in range(M):\n    A, B, C = map(int, input().split())\n    A -= 1\n    B -= 1\n    dist1[A][B] = C\n    dist1[B][A] = C\n\ndist1 = floyd_warshall(dist1)\n\ndist2 = [[INF] * N for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if dist1[i][j] <= L:\n            dist2[i][j] = 1\n\ndist2 = floyd_warshall(dist2)\n\nQ = int(input())\nfor _ in range(Q):\n    s, t = map(int, input().split())\n    s -= 1\n    t -= 1\n    if dist2[s][t] >= INF:\n        print (-1)\n    else:\n        print (int(dist2[s][t] - 1))", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\nn, m, l = list(map(int, input().split()))\nabc = []\nfor _ in range(m):\n    abc.append(list(map(int, input().split())))\nq = int(input())\nst = []\nfor _ in range(q):\n    st.append(list(map(int, input().split())))\n\nadjacency_matrix = np.zeros((n, n))\nfor a, b, c in abc:\n    adjacency_matrix[a-1, b-1] = c\n    adjacency_matrix[b-1, a-1] = c\n\nshotest = dijkstra(adjacency_matrix)\nfuel_once = np.where(shotest <= l, 1, 0)\nfuel_times = dijkstra(fuel_once-np.eye(n))\n\nfor s, t in st:\n    ans = fuel_times[s-1][t-1]\n    if np.isinf(ans):\n        print((-1))\n    else:\n        print((int(ans) - 1))\n", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\nN, M, L = map(int, input().split())\n\nD = np.ones([N, N]) * np.inf\nD[np.eye(N, dtype=bool)] = 0\n\nfor _ in range(M):\n  A, B, C = map(int, input().split())\n  D[A-1, B-1] = C\n  D[B-1, A-1] = C\n\nD = floyd_warshall(D)\nD2 = (D<=L)*1.0 # boolean -> float\nD2[D2==0] = np.inf\n# D2 = (D <= L) + (D > L)*np.inf\n\nD2 = floyd_warshall(D2) - 1\n\nQ = int(input())\nfor _ in range(Q):\n  s, t = map(int, input().split())\n  r = D2[s-1, t-1]\n  if r < np.inf:\n    print(int(r))\n  else:\n    print(-1)", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, l = map(int, input().split())\nINF = 1 << 60\n\ndist = [[INF] * n for _ in range(n)]\n\nfor i in range(n):\n    dist[i][i] = 0\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    if c > l:\n        continue\n    dist[a][b] = c\n    dist[b][a] = c\n\n\ndist = floyd_warshall(csr_matrix(dist))\n\ndist2 = np.full_like(dist, 1)\ndist2[np.where(dist > l)] = INF\ndist2 = floyd_warshall(dist2, directed=False)\ndist2[dist2 == INF] = 0\ndist2 = dist2.astype(int)\n\nq = int(input())\n\nans = []\nfor _ in range(q):\n    s, t = map(int, input().split())\n    if dist[s - 1, t - 1] == -1:\n        ans.append(-1)\n    else:\n        ans.append(dist2[s - 1, t - 1] - 1)\n\nprint(*ans, sep=\"\\n\")", "import sys\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn,m,l = map(int, input().split())\n\nd=[[sys.maxsize]*(n) for _ in range(n)]\ne=[[sys.maxsize]*(n) for _ in range(n)]\nfor i in range(n):\n  d[i][i] = 0\n  e[i][i] = 0\n\nfor _ in range(m):\n  a,b,c = map(int, input().split())\n  d[a-1][b-1]=c\n  d[b-1][a-1]=c\n\nd=floyd_warshall(csr_matrix(d))\nfor i in range(n):\n  for j in range(n):\n    if d[i][j] <= l:\n      e[i][j] = 1\n\ne=floyd_warshall(csr_matrix(e))\n\nq=int(input())\nfor _ in range(q):\n  s,t = map(int, input().split())\n  if e[s-1][t-1] == sys.maxsize:\n    print(-1)\n  else:\n    print(int(e[s-1][t-1]-1))", "import sys\nfrom scipy.sparse.csgraph import floyd_warshall\nN, M, L = list(map(int, input().split()))\nINF = 10 ** 9 + 1\nG = [[float('inf')] * N for i in range(N)]\nfor i in range(M):\n    a, b, c = list(map(int, sys.stdin.readline().split()))\n    a, b = a - 1, b - 1\n    G[a][b] = c\n    G[b][a] = c\n\n\n# \u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u8a08\u7b97\nG = floyd_warshall(G)\n\n\n# \u30b3\u30b9\u30c8L\u4ee5\u4e0b\u3067\u79fb\u52d5\u53ef\u80fd\u306a\u9802\u70b9\u9593\u306b\u30b3\u30b9\u30c8\uff11\u306e\u8fba\u3092\u5f35\u308b\nE = [[float('inf')] * N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if G[i][j] <= L:\n            E[i][j] = 1\n\n\n# \u305d\u306e\u30b0\u30e9\u30d5\u306e\u5168\u70b9\u9593\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\nE = floyd_warshall(E)\n\n\n# \u30af\u30a8\u30ea\u306b\u7b54\u3048\u3066\u3044\u304f\nQ = int(input())\nfor i in range(Q):\n    s, t = list(map(int, sys.stdin.readline().split()))\n    s, t = s - 1, t - 1\n    print((int(E[s][t] - 1) if E[s][t] != float('inf') else - 1))\n", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nINF = 10**12\nN, M, L = map(int, input().split())\n\nA = []; B = []; C = []\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    A.append(a - 1); B.append(b - 1); C.append(c)\nA = np.array(A); B = np.array(B); C = np.array(C)\n\ngraph = csr_matrix((C, (A, B)), (N, N))\nd = floyd_warshall(graph, directed=False)\n\nd[d <= L] = 1\nd[d > L] = INF\n\nd = floyd_warshall(d, directed=False)\n\nQ = int(input())\nfor i in range(Q):\n    s, t = map(int, input().split())\n    if d[s - 1][t - 1] != INF:\n        print(int(d[s - 1][t - 1]) - 1)\n    else:\n        print(- 1)", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, l = map(int, input().split())\nINF = 1 << 60\n\ndist = [[INF] * n for _ in range(n)]\n\nfor i in range(n):\n    dist[i][i] = 0\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    if c > l:\n        continue\n    dist[a][b] = c\n    dist[b][a] = c\n\n\ndist = floyd_warshall(csr_matrix(dist))\n\ndist2 = np.full_like(dist, 1)\ndist2[np.where(dist > l)] = INF\ndist2 = floyd_warshall(dist2, directed=False)\ndist2[dist2 == INF] = 0\ndist2 = dist2.astype(int)\n\nq = int(input())\n\nans = []\nfor _ in range(q):\n    s, t = map(int, input().split())\n    ans.append(dist2[s - 1, t - 1] - 1)\n\nprint(*ans, sep=\"\\n\")", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\nN, M, L = list(map(int, input().split()))\n\nD = np.ones([N, N]) * np.inf\nD[np.eye(N, dtype=bool)] = 0\n\nfor _ in range(M):\n  A, B, C = list(map(int, input().split()))\n  D[A-1, B-1] = C\n  D[B-1, A-1] = C\n\nD = floyd_warshall(D)\nD2 = D <= L\n\nD2 = floyd_warshall(D2)\n\nQ = int(input())\nfor _ in range(Q):\n  s, t = list(map(int, input().split()))\n  r = D2[s-1, t-1] - 1\n  if r < np.inf:\n    print((int(r)))\n  else:\n    print((-1))\n\n", "import sys\ninput = sys.stdin.readline\nfrom scipy.sparse.csgraph import floyd_warshall\n      \nn,m,l = map(int,input().split())\nedge = [[0]*n for _ in range(n)]\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    edge[a-1][b-1] = c\n    edge[b-1][a-1] = c\n\nedge = floyd_warshall(edge)\n    \nfor i in range(n):\n    for j in range(n):\n        if edge[i][j]<=l:\n            edge[i][j] = 1\n        else:\n            edge[i][j] = 0\n                \nedge = floyd_warshall(edge)\n\nq = int(input())\nfor i in range(q):\n    s,t = map(int,input().split())\n    if edge[s-1][t-1] == float(\"inf\"):\n        print(-1)\n    else:\n        print(int(edge[s-1][t-1] - 1))", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = list(map(int, input().split()))\n\nstart = []\ngoal = []\ncost = []\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    A -= 1\n    B -= 1\n    start.append(A)\n    goal.append(B)\n    cost.append(C)\n    start.append(B)\n    goal.append(A)\n    cost.append(C)\n\ngraph = csr_matrix((cost, (start, goal)), shape = (N, N))\ncan_reach_with_L = floyd_warshall(graph, directed = False)\ncan_reach_with_L[can_reach_with_L > L] = 0\nans = floyd_warshall(can_reach_with_L, directed = False, unweighted = True)\n\nQ = int(input())\nfor _ in range(Q):\n    s, t = list(map(int, input().split()))\n    s -= 1\n    t -= 1\n    if ans[s][t] == float('inf'):\n        print((-1))\n    else:\n        print((int(ans[s][t] + 0.5) - 1))\n", "from scipy.sparse.csgraph import floyd_warshall\n\nN,M,L = map(int,input().split())\nabc = [[int(i) for i in input().split()] for j in range(M)]\nQ = int(input())\nst = [[int(i) for i in input().split()] for j in range(Q)]\nINF = 1<<30\nPath = [[INF for i in range(N)] for j in range(N)]\nAnsPath = [[INF for i in range(N)] for j in range(N)]\n\ndef PathInit():\n    for i in range(N):\n        Path[i][i] = 0\n\nPathInit()\nfor i,j,k in abc:\n    Path[i-1][j-1] = k\n    #\u53cc\u65b9\u5411\n    Path[j-1][i-1] = k\n\nPath = floyd_warshall(Path)\n\nfor i in range(N):\n    for j in range(N):\n        if Path[i][j] <= L:\n            AnsPath[i][j] = 1\nAnsPath = floyd_warshall(AnsPath)\nfor s,t in st:\n    if AnsPath[s-1][t-1] == INF:\n        print(-1)\n    else:\n        print(int(AnsPath[s-1][t-1]-1))", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, m, l = list(map(int, input().split()))\n    inf = 10 ** 20\n    ar = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1][b - 1] = c\n    x = floyd_warshall(ar, directed=False)\n    br = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i][j] = 1\n    y = floyd_warshall(br, directed=False)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        print((int(y[s - 1, t - 1]) - 1 if y[s - 1, t - 1] < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\ninpl = lambda: list(map(int,input().split()))\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, L = inpl()\ngraph = [[0]*N for _ in range(N)]\nfor i in range(M):\n    A, B, C = inpl()\n    if C <= L:\n        graph[A-1][B-1] = C\n\nQ = int(input())\nST = []\nfor _ in range(Q):\n    s, t = inpl()\n    s -= 1\n    t -= 1\n    ST.append((s, t))\n\ndistance = floyd_warshall(csr_matrix(graph), directed=False)\npath = [[0]*N for _ in range(N)]\nfor i in range(N-1):\n    for j in range(i+1,N):\n        d = distance[i][j]\n        if d <= L:\n            path[i][j] = 1\nans = floyd_warshall(csr_matrix(path), directed=False)\nfor s, t in ST:\n    if ans[s][t] == np.float('inf'):\n        print((-1))\n    else:\n        print((int(ans[s][t]-1)))\n", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, L: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\", Q: int, s: \"List[int]\", t: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import coo_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    mat = floyd_warshall(coo_matrix((C, (A, B)), shape=(N+1, N+1), dtype=np.int32).tocsr(), directed=False)\n    mat = floyd_warshall(mat <= L, directed=False)\n    for ss, tt in zip(s, t):\n        yield -1 if np.isinf(mat[ss][tt]) else int(mat[ss][tt]) - 1\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    L = int(next(tokens))  # type: int\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    Q = int(next(tokens))  # type: int\n    s = [int()] * (Q)  # type: \"List[int]\"\n    t = [int()] * (Q)  # type: \"List[int]\"\n    for i in range(Q):\n        s[i] = int(next(tokens))\n        t[i] = int(next(tokens))\n    print(*solve(N, M, L, A, B, C, Q, s, t), sep=\"\\n\")\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nn, m, l = map(int, input().split())\nF = np.zeros((n, n))\nfor _ in range(m):\n  a, b, c = map(int, input().split())\n  a -= 1\n  b -= 1\n  F[a, b] = c\n  F[b, a] = c\ncsr = csr_matrix(F)\nA = floyd_warshall(csr)\nG = np.zeros((n, n))\nfor i in range(n-1):\n  for j in range(i+1, n):\n    if A[i][j] <= l:\n      G[i, j] = 1\n      G[j, i] = 1\nncsr = csr_matrix(G)\nB =  floyd_warshall(ncsr)\nq = int(input())\nfor _ in range(q):\n  s, t = map(int, input().split())\n  k = B[s-1][t-1]\n  if k == float(\"inf\"):\n    print(-1)\n  else:\n    print(int(k)-1)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse.csgraph import csgraph_from_dense\n\nINF = float('inf')\n\ndef main():\n    N, M, L = map(int, input().split())\n\n    # G[x][y]: x\u304b\u3089y\u3078\u76f4\u63a5\u79fb\u52d5\u3059\u308b\u3068\u304d\u306e\u30b3\u30b9\u30c8\u3002\u79fb\u52d5\u3067\u304d\u306a\u3044\u5834\u5408\u306fINF\n    G = [[INF] * (N+1) for n in range(N+1)]\n\n    for i in range(M):\n        a, b, c = map(int, input().split())\n        G[a][b] = c\n        G[b][a] = c\n    G = csgraph_from_dense(G, null_value=INF)\n\n    Q = int(input())\n    Queries = []\n    for i in range(Q):\n        s, t = map(int, input().split())\n        Queries.append((s, t))\n\n    # \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\u3067\u3001\u5168\u70b9\u9593\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n    cost = floyd_warshall(G)\n    # \u5168\u70b9\u9593\u306e\u8ddd\u96e2\u306e\u3046\u3061\u3001\u79fb\u52d5\u8ddd\u96e2\u304cL\u4ee5\u5185\u3067\u304a\u3055\u307e\u308b\u9802\u70b9\u540c\u58eb\u306f\u3001\u7d66\u6cb9\u305b\u305a\u306b\u3059\u3080\n    # \u305d\u3053\u3067\u3001\u5168\u70b9\u9593\u306e\u8ddd\u96e2\u306e\u3046\u3061\u3001\u79fb\u52d5\u8ddd\u96e2\u304cL\u4ee5\u5185\u3067\u304a\u3055\u307e\u308b\u9802\u70b9\u540c\u58eb\u3092\u8ddd\u96e21\u3067\u7d50\u3093\u3060\u30b0\u30e9\u30d5\u3092\u4f5c\u6210\u3057\u3001\n    # \u305d\u306e\u30b0\u30e9\u30d5\u306b\u5bfe\u3057\u3066\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\u3067\u6700\u77ed\u8ddd\u96e2\u3092\u8a08\u7b97\u3059\u308b\u3053\u3068\u3067\u3001\n    # refuel[x][y] =\u300cx\u304b\u3089y\u3078\u79fb\u52d5\u3059\u308b\u3068\u304d\u306e\u7d66\u6cb9\u56de\u6570+1\u300d\u3068\u3044\u3046\u30b0\u30e9\u30d5\u3092\u4f5c\u6210\u3067\u304d\u308b\n    no_refuel = [[1 if x <= L else INF for x in c] for c in cost]\n    no_refuel = csgraph_from_dense(no_refuel, null_value=INF)\n    refuel_count = floyd_warshall(no_refuel)\n\n    ans = []\n    for s, t in Queries:\n        d = refuel_count[s][t]\n        ans.append(int(d-1) if d != INF else -1)\n    \n    print(*ans, sep='\\n')\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\ninf = float(\"inf\")\nN, M, L = map(int, input().split())\ngraph = np.zeros((N, N))\nfor _ in range(M):\n    A, B, C = map(int, input().split())\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\nshortest_paths = shortest_path(csr_matrix(graph), directed=False, method=\"D\")\ngraph = np.full((N, N), inf)\nfor i in range(N):\n    for j in range(N):\n        if shortest_paths[i][j] <= L:\n            graph[i][j] = 1\n\nQ = int(input())\ndef int_(num_str):\n    return int(num_str) - 1\n\ncosts = shortest_path(csr_matrix(graph), directed=False, method=\"D\")\nfor _ in range(Q):\n    s, t = map(int_, input().split())\n    print(int(costs[s][t])-1 if costs[s][t] != inf else -1)", "import sys\nimport numpy as np\nfrom scipy.sparse import*\nF = csgraph.floyd_warshall\nCSR = csr_matrix\ninput = sys.stdin.readline\n\nn,m,l = map(int,input().split())\ncost = [[0]*n for i in range(n)]\nfor i in range(m):\n  a,b,c = map(int,input().split())\n  cost[a-1][b-1] = c\n  cost[b-1][a-1] = c  \n\nCost = F(CSR(cost))\nCost = F(CSR(np.where((0<Cost)&(Cost<=l),1,0)))\n\nq = int(input())\nfor i in range(q):\n  s,t = map(int,input().split())\n  print(-1 if np.isinf(Cost[s-1][t-1]) else int(Cost[s-1][t-1])-1)", "# scipy\u4f7f\u3046\u5834\u5408\nimport sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn,m,l = map(int,input().split())\n\n# m\u884c\u306e\u5165\u529b\u304b\u3089\u8ddd\u96e2\u3092\u5024\u306b\u6301\u3064\u96a3\u63a5\u884c\u5217\u3092\u4f5c\u6210 0-indexed\n# directed:\u7121\u5411\u30b0\u30e9\u30d5\u306a\u3089False\u3001\u6709\u5411\u30b0\u30e9\u30d5\u306a\u3089True\ndef make_d_matrix(n,m,directed=False):\n    inf = 10**13\n    d = [[inf] * n for _ in range(n)]\n    if(directed):\n        for _ in range(m):\n            a,b,c = map(int, input().split())\n            d[a-1][b-1] = c\n    else:\n        for _ in range(m):\n            a,b,c = map(int, input().split())\n            d[a-1][b-1] = c\n            d[b-1][a-1] = c\n    return d\n\nd = make_d_matrix(n,m)\ncsr_graph = csr_matrix(d)\nd1 = floyd_warshall(csr_graph,directed=False)\n\ninf = 10**3\nfor i in range(n):\n    for j in range(n):\n        d1[i][j] = 1 if (d1[i][j] <= l) else inf\n\ncsr_graph = csr_matrix(d1)\nd2 = floyd_warshall(csr_graph,directed=False)\n\nq = int(input())\n\nfor _ in range(q):\n    s,t = map(int, input().split())\n    tmp = d2[s-1][t-1]\n    if(tmp >= inf):\n        print(-1)\n    else:\n        print(int(tmp-1))", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN,M,L=map(int,input().split())\nINF = 1 << 31\ndist=np.array([[INF for _ in range(N)] for _ in range(N)])\n\nfor i in range(N):\n  dist[i][i]=0\n  \nfor i in range(M):\n  a,b,c=map(int,input().split())\n  a-=1\n  b-=1\n  dist[a][b]=c\n  dist[b][a]=c\n\ndist = floyd_warshall(dist)\n\nfor i in range(N):\n  for j in range(N):\n    if dist[i][j]<=L:\n      dist[i][j]=1\n    else:\n      dist[i][j]=INF\n\ndist = floyd_warshall(dist)\ndist[dist==INF]=0\n#dist=dist.astype(int)\n#print(dist)\n\nQ=int(input())\nans=[0]*Q\nfor q in range(Q):\n  s,t=map(int,input().split())\n  s-=1\n  t-=1\n  ans[q]=int(dist[s][t]-1)\n\nprint(*ans,sep='\\n')\n\n", "import sys\nreadline = sys.stdin.readline\n\nimport math\n\n# \u6700\u77ed\u8ddd\u96e2\u3092\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u3067\u6c42\u3081\u308b\n# \u6700\u77ed\u8ddd\u96e2\u304cL\u4ee5\u4e0b\u306e\u8857\u306b\u306f\u71c3\u65991\u3067\u884c\u3051\u308b\u306e\u3067\u3001\u8fba\u3092\u8cbc\u308a\u76f4\u3057\u3066\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n\nN,M,L = map(int,readline().split())\n\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse.csgraph import csgraph_from_dense\nINF = 10 ** 9 + 1\nG = [[INF for i in range(N)] for j in range(N)]\nfor i in range(M):\n  a,b,c = map(int,readline().split())\n  G[a - 1][b - 1] = c\n  G[b - 1][a - 1] = c\nG = csgraph_from_dense(G, null_value=INF)\nd = floyd_warshall(G)\n\nEG = [[INF for i in range(N)] for j in range(N)]\nfor i in range(N):\n  for j in range(N):\n    if d[i][j] <= L:\n      EG[i][j] = 1\n\nEG = csgraph_from_dense(EG, null_value=INF)\nd = floyd_warshall(EG)\n\nQ = int(readline())\nfor i in range(Q):\n  s,t = map(int,readline().split())\n  if d[s - 1][t - 1] != math.inf:\n    print(int(d[s - 1][t - 1] - 1))\n  else:\n    print(-1)", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\nN, M, L = list(map(int, input().split()))\ngraph = np.array([[0 if i == j else float(\"inf\")\n                   for i in range(N)] for j in range(N)])\ngraph2 = np.array([[0 if i == j else float(\"inf\")\n                   for i in range(N)] for j in range(N)])\n\n\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\ndist = floyd_warshall(graph)\n\ngraph2[(dist <= L) & (dist != 0)] = 1\ndist2 = floyd_warshall(graph2)\ndist2[dist2 == float(\"inf\")] = 0\n\nQ = int(input())\nfor _ in range(Q):\n    s, t = list(map(int, input().split()))\n    print((int(dist2[s - 1, t - 1]) - 1))\n\n", "# 2019-11-19 10:28:31(JST)\nimport sys\n# import collections\n# import math\n# from string import ascii_lowercase, ascii_uppercase, digits\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n# import itertools\n# from functools import reduce\n# import operator as op\n# import re\n# import heapq\n# import array\n# from scipy.misc import comb # (default: exact=False)\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nimport numpy as np \n\n\ndef main():\n    n, m, l = list(map(int, sys.stdin.readline().split()))\n    ABCQST = np.array(sys.stdin.read().split(), np.int64)\n    ABC = ABCQST[:m * 3]\n    A, B, C = ABC[::3], ABC[1::3], ABC[2::3]\n    ST = ABCQST[m * 3 + 1:]\n    S, T = ST[::2], ST[1::2]\n\n    dist = csr_matrix((C, (A, B)), (n+1, n+1))\n    min_dist = floyd_warshall(dist, directed=False)\n\n    filling_times = np.full((n+1, n+1), np.inf)\n    np.diagonal(filling_times, 0)\n    filling_times[min_dist <= l] = 1\n\n    min_filling_times = floyd_warshall(filling_times, directed=False)\n\n    min_filling_times[min_filling_times == np.inf] = 0\n    # \u6700\u5f8c\u306b-1\u3059\u308b\n    min_filling_times = min_filling_times.astype(int)\n\n    res = min_filling_times[S, T] - 1\n    print(('\\n'.join(res.astype(str))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import isinf\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\n\nINF = float('inf')\n\ndef main():\n    N, M, L = list(map(int, input().split()))\n    E = [[INF] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        E[a - 1][b - 1] = c\n        E[b - 1][a - 1] = c\n    EE = shortest_path(csr_matrix(E))\n    E = [[1 if EE[i][j] <= L else INF for j in range(N)] for i in range(N)]\n    EE = shortest_path(csr_matrix(E))\n    Q = int(input())\n    for _ in range(Q):\n        s, t = list(map(int, input().split()))\n        x = EE[s - 1][t - 1]\n        print((-1 if isinf(x) else int(x) - 1))\n        \n\nmain()\n", "from scipy.sparse.csgraph import floyd_warshall\nfrom numpy import where\nn,m,l=map(int,input().split())\nabc=[list(map(int,input().split()))for i in range(m)]\nq=int(input())\nst=[list(map(int, input().split()))for i in range(q)]\nt=[[float(\"inf\")]*n for _ in range(n)]\nfor a,b,c in abc:\n if c<=l:t[a-1][b-1]=c\nf=floyd_warshall(t,0)\nl=floyd_warshall(where(f<=l,1,f),0)\nfor s, t in st:print(-1if l[s-1,t-1]==float(\"inf\")else int(l[s-1,t-1])-1)", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import numpy as np\n    import sys\n    input = sys.stdin.readline\n    n, m, l = list(map(int, input().split()))\n    inf = 10 ** 20\n    ar = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1][b - 1] = c\n    x = floyd_warshall(ar, directed=False)\n    br = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i][j] = 1\n    y = floyd_warshall(br, directed=False)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        p = y[s - 1, t - 1]\n        print((int(p) - 1 if p < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\n\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nN, M, L = list(map(int, input().split()))\n\nif M == 0:\n    Q = int(input())\n    for _ in range(Q):\n        print((-1))\n    return\n\nR = np.array([tuple(map(int, input().split())) for _ in range(M)])\nmatr = csr_matrix((R[:, 2], (R[:, 0] - 1, R[:, 1] - 1)), shape=(N, N))\nway = floyd_warshall(matr, directed=False).astype(int)\n\nway = np.where((way >= 0) & (way <= L), 1, 0)\nmatr_replenishment = csr_matrix(way)\nway_replenishment = floyd_warshall(matr_replenishment, directed=False).astype(int).tolist()\n\nQ = int(input())\nfor _ in range(Q):\n    S, T = list(map(int, input().split()))\n    print((res - 1 if (res := way_replenishment[S - 1][T - 1]) >= 0 else -1))\n", "N, M, L = (int(i) for i in input().split())\n\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ngraph = [[0]*N for i in range(N)]\nfor i in range(M):\n    a, b, c = (int(i) for i in input().split())\n    graph[a-1][b-1] = c\n    graph[b-1][a-1] = c\n\ngraph = csr_matrix(graph)\nd = floyd_warshall(csgraph=graph, directed=False)\n\nnew_graph = [[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if d[i][j] <= L:\n            new_graph[i][j] = 1\n            new_graph[j][i] = 1\n\ngraph = csr_matrix(new_graph)\nd = floyd_warshall(csgraph=graph, directed=False)\nQ = int(input())\nfor i in range(Q):\n    s, t = (int(i) for i in input().split())\n    if d[s-1][t-1] == float(\"inf\"):\n        print(\"-1\")\n    else:\n        print(int(d[s-1][t-1]-1))", "from scipy.sparse.csgraph import floyd_warshall\n\nn, m, l = map(int, input().split())\ninf = 10**12\nd = [[inf for i in range(n)] for i in range(n)] \n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\nfor i in range(m):\n    x,y,z = map(int,input().split())\n    d[x-1][y-1] = z\n    d[y-1][x-1] = z\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\ndd = floyd_warshall(d)\nddd = [[inf for i in range(n)] for i in range(n)]\nfor i in range(n):\n  for j in range(n):\n    if dd[i][j] <= l:\n      ddd[i][j] = 1\ndddd =floyd_warshall(ddd)\nq = int(input())\nfor i in range(q):\n  s, t = map(int, input().split())\n  if dddd[s-1][t-1] == inf:\n    print(-1)\n  else:\n    print(int(dddd[s-1][t-1]-1))", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, l = map(int, input().split())\nINF = 1 << 60\n\n# \u8ddd\u96e2\u306ematrix\u3092\u4f5c\u308b\ndist = [[INF] * n for _ in range(n)]\n\n# \u5bfe\u89d2\u884c\u5217\u306e\u6210\u5206\u306f\uff10\nfor i in range(n):\n    dist[i][i] = 0\n\n# \u71c3\u6599\u306e\u6700\u5927\u5024\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\u306b\u8fba\u304c\u5f35\u308c\u308b\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    if c > l:\n        continue\n    dist[a][b] = c\n    dist[b][a] = c\n\n# \u5168\u70b9\u9593\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b\ndist = floyd_warshall(csr_matrix(dist))\n\n# \u521d\u671f\u72b6\u614b\u3092\uff11\u306b\u3059\u308b\u3002\u71c3\u6599\u304c\u8db3\u308a\u306a\u3044\u7d4c\u8def\u306f\u8fc2\u56de\u3057\u305f\u3044\u306e\u3067INF\u3092\u7f6e\u3044\u3066\u304a\u304f\ndist2 = np.full_like(dist, 1)\ndist2[np.where(dist > l)] = INF\n\n# \u8db3\u3057\u8fbc\u3080\u3053\u3068\u3067\u4f55\u56de\u7d66\u6cb9\u3059\u308b\u3079\u304d\u304b\u304c\u308f\u304b\u308b\ndist2 = floyd_warshall(dist2, directed=False)\ndist2 = dist2.astype(int)\n\n# \u7121\u9650\u5927\u306e\u7d4c\u8def\u306f\u8fbf\u308c\u306a\u3044\u3002-1\u3092\u51fa\u529b\u3057\u305f\u3044\u306e\u3067\uff10\u3092\u7f6e\u3044\u3066\u3044\u304f\ndist2[dist2 == INF] = 0\n\nq = int(input())\n\n# \u521d\u671f\u72b6\u614b\u3092\uff11\u3068\u3057\u3066\u3044\u308b\u306e\u3067\u3001\uff11\u3092\u5f15\u3044\u3066\u7b54\u3048\u3068\u3059\u308b\nans = []\nfor _ in range(q):\n    s, t = map(int, input().split())\n    ans.append(dist2[s - 1, t - 1] - 1)\n\nprint(*ans, sep=\"\\n\")", "#import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall, csgraph_from_dense\nfrom scipy.sparse import csr_matrix\n\nN,M,L = list(map(int, input().split()))\nV = [[ 10**12 for _ in range(N) ] for _ in range(N)]\nfor _ in range(M):\n  a,b,c = list(map(int, input().split()))\n  a,b = a-1, b-1\n  V[a][b] = c\n  V[b][a] = c\n  \nG = csgraph_from_dense(V, null_value=10**12)\nd = floyd_warshall(G)\n\nV2 = [[ 10**9 for _ in range(N) ] for _ in range(N)]\nfor i in range(N):\n  for j in range(N):\n    if 0 < d[i][j] <= L:\n      V2[i][j] = 1\n      \nG2 = csgraph_from_dense(V2, null_value=10**9)\nd2 = floyd_warshall(G2)\n\nQ = int(input())\nfor _ in range(Q):\n  s,t = list(map(int, input().split()))\n  s,t = s-1, t-1\n  print((int(d2[s][t])-1 if d2[s][t] < 1000 else -1))\n", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\n\ndef solve():\n    N, M, L = map(int, input().split())\n    dist = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(M):\n        a, b, c = map(int, input().split())\n        dist[a-1][b-1] = c\n        dist[b-1][a-1] = c\n    fw = floyd_warshall(csr_matrix(dist))\n\n    ok = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if fw[i][j] <= L:\n                ok[i][j] = 1\n    ans = floyd_warshall(csr_matrix(ok))\n\n    Q = int(input())\n    for i in range(Q):\n        s, t = map(lambda x: int(x)-1, input().split())\n        if ans[s][t] < N:\n            print(int(ans[s][t])-1)\n        else:\n            print(-1)\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "from enum import Enum\nfrom queue import Queue\n\nimport numpy as np\n\nimport collections\nimport bisect\nimport sys\nimport math\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nBIG_NUM = 200000000000\nMOD = 1000000007\nEPS = 0.000000001\n\ndef warshall_floyd(d,n):\n    #d[i][j]:i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n    return d\n\nN,M,L = list(map(int,input().split()))\nd = [[float(\"inf\") for i in range(N)] for j in range(N)]\nfor i in range(M):\n    a,b,c = list(map(int,input().split()))\n    d[a-1][b-1] = c\n    d[b-1][a-1] = c\nfor i in range(N):\n    d[i][i] = 0\nd = floyd_warshall(d)\nfor i in range(N):\n    for j in range(i,N):\n        if d[i][j] <= L:\n            d[i][j] = 1\n            d[j][i] = 1\n        else:\n            d[i][j] = float(\"inf\")\n            d[j][i] = float(\"inf\")\n    d[i][i] = 1\nd = floyd_warshall(d)\nQ = int(input())\nfor q in range(Q):\n    s,t = list(map(int,input().split()))\n    if d[s-1][t-1] == float(\"inf\"):\n        print((-1))\n    else:\n        print((int(d[s-1][t-1])-1))\n", "import sys\nfrom scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\ninput = sys.stdin.readline\n\nN, M, L = list(map(int, input().split()))\ngraph = np.array([[0 if i == j else float(\"inf\")\n                   for i in range(N)] for j in range(N)])\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\n\nQ = int(input())\ndist = floyd_warshall(graph)\n\n\ngraph2 = np.array([[float(\"inf\")] * N for _ in range(N)])\nnp.fill_diagonal(graph2, 0)\ngraph2[(dist <= L) & (dist != 0)] = 1\n\ndist2 = floyd_warshall(graph2)\ndist2[dist2 == float(\"inf\")] = 0\n\nfor _ in range(Q):\n    s, t = list(map(int, input().split()))\n    print((int(dist2[s - 1, t - 1]) - 1))\n", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nN,M,L = list(map(int,input().split()))\n\nG = np.full((N, N), np.inf)\nnp.fill_diagonal(G, 0)\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    G[a-1][b-1] = G[b-1][a-1] = c\nD = floyd_warshall(G, directed=False)\n\nG2 = np.full((N, N), np.inf)\nnp.fill_diagonal(G2, 0)\nG2[D <= L] = 1\nD2 = floyd_warshall(G2, directed=False)\n\nQ = int(input())\nfor _ in range(Q):\n    a, b = [int(x) - 1 for x in input().split()]\n    if D2[a][b] == np.inf:\n        print((-1))\n    else:\n        print((int(D2[a][b]) - 1))\n", "import numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\ninf = float(\"inf\")\nN, M, L = map(int, input().split())\ngraph = np.zeros((N, N))\nfor _ in range(M):\n    A, B, C = map(int, input().split())\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\nshortest_paths = dijkstra(csr_matrix(graph), directed=False)\ngraph = np.full((N, N), inf)\nfor i in range(N):\n    for j in range(N):\n        if shortest_paths[i][j] <= L:\n            graph[i][j] = 1\n\nQ = int(input())\ndef int_(num_str):\n    return int(num_str) - 1\n\ncosts = dijkstra(csr_matrix(graph), directed=False)\nfor _ in range(Q):\n    s, t = map(int_, input().split())\n    print(int(costs[s][t])-1 if costs[s][t] != inf else -1)", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\ndef main():\n    N,M,L = list(map(int,input().split()))\n    edge = np.zeros((N,N))\n    for _ in range(M):\n        a,b,c = list(map(int,input().split()))\n        edge[a-1][b-1] = edge[b-1][a-1] = c\n        \n    length = floyd_warshall(edge,directed=False)\n    ref = np.where(length<=L,1,0)\n    ans = floyd_warshall(ref,directed=False)\n    Q = int(input())\n    for _ in range(Q):\n        s,t = list(map(int,input().split()))\n        if ans[s-1][t-1] == float(\"inf\"):\n            print((-1))\n        else:\n            print((int(ans[s-1][t-1])-1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from scipy.sparse.csgraph import floyd_warshall\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u3092\u4e8c\u56de\u884c\u3046\nN, M, L = list(map(int, input().split()))\ngraph = [[float('inf')]*N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a][b] = c\n    graph[b][a] = c\n\ngraph = floyd_warshall(graph)\nanother = [[float('inf')]*N for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if graph[i][j] <= L:\n            another[i][j] = 1\nanother = floyd_warshall(another)\nQ = int(input())\nfor _ in range(Q):\n    s, t = [int(x)-1 for x in input().split()]\n    if another[s][t] == float('inf'):\n        print((-1))\n    else:\n        print((int(another[s][t])-1))\n", "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ndef main():\n  n, m, l = map(int, input().split())\n  F = np.zeros((n, n))\n  for _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    F[a, b] = c\n    F[b, a] = c\n  csr = csr_matrix(F)\n  A = floyd_warshall(csr)\n  G = np.zeros((n, n))\n  for i in range(n-1):\n    for j in range(i+1, n):\n      if A[i][j] <= l:\n        G[i, j] = 1\n        G[j, i] = 1\n  ncsr = csr_matrix(G)\n  B =  floyd_warshall(ncsr)\n  q = int(input())\n  for _ in range(q):\n    s, t = map(int, input().split())\n    k = B[s-1][t-1]\n    if k == float(\"inf\"):\n      print(-1)\n    else:\n      print(int(k)-1)\n      \ndef __starting_point():\n  main()\n__starting_point()", "\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\ndef resolve():\n    INF = 10 ** 18\n    N, M, L = list(map(int, input().split()))\n    G = [[INF] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        G[a][b] = G[b][a] = c\n\n    G = csr_matrix(G)\n    dist = floyd_warshall(G, directed=False)\n\n    G2 = np.full((N, N), np.inf)  # \u5024\u3092INF\u306b\u3057\u305f\u914d\u5217\n    np.fill_diagonal(G2, 0)  # G[i][i]\u306f\u52d5\u3044\u3066\u3044\u306a\u3044\u72b6\u614b\u306a\u306e\u3067\u30b3\u30b9\u30c80\n    G2[dist <= L] = 1\n\n    dist2 = floyd_warshall(G2, directed=False)\n\n    Q = int(input())\n    for _ in range(Q):\n        a, b = [int(x) - 1 for x in input().split()]\n        if dist2[a][b] == np.inf:\n            print((-1))\n        else:\n            print((int(dist2[a][b]) - 1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\ninf = float(\"inf\")\nN, M, L = list(map(int, input().split()))\ngraph = np.zeros((N, N))\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\nshortest_paths = dijkstra(csr_matrix(graph), directed=False)\ngraph = np.full((N, N), inf)\nfor i in range(N):\n    for j in range(N):\n        if shortest_paths[i][j] <= L:\n            graph[i][j] = 1\n\nQ = int(input())\ndef int_(num_str):\n    return int(num_str) - 1\n\ncosts = dijkstra(csr_matrix(graph), directed=False)\nfor _ in range(Q):\n    s, t = list(map(int_, input().split()))\n    print((int(costs[s][t])-1 if costs[s][t] != inf else -1))\n", "def main():\n    from sys import stdin\n    input=stdin.readline\n    \n    import numpy as np\n    import scipy.sparse.csgraph as sp\n\n    n, m, l = list(map(int, input().split()))\n    abc = [list(map(int, input().split())) for _ in [0]*m]\n    q = int(input())\n    st = [list(map(int, input().split())) for _ in [0]*q]\n    inf = 10**12\n    dist = np.full((n, n), inf, dtype=np.int64)\n    for i in range(n):\n        dist[i][i] = 0\n    for a, b, c in abc:\n        dist[a-1][b-1] = c\n        dist[b-1][a-1] = c\n    dist = sp.shortest_path(dist)\n\n    inf = 10**3\n    dist2 = np.full((n, n), inf, dtype=np.int16)\n    for i in range(n):\n        for j in range(n):\n            if dist[i][j] <= l:\n                dist2[i][j] = 1\n    dist2 = sp.shortest_path(dist2)\n\n    for i in range(n):\n        for j in range(n):\n            if dist2[i][j] == inf:\n                dist2[i][j] = -1\n            else:\n                dist2[i][j] -= 1\n    for s, t in st:\n        print((int(dist2[s-1][t-1])))\n\n\nmain()\n", "import sys\nfrom scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\ninput = sys.stdin.readline\n\nN, M, L = list(map(int, input().split()))\ngraph = np.array([[0 if i == j else float(\"inf\")\n                   for i in range(N)] for j in range(N)])\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    graph[a - 1][b - 1] = c\n    graph[b - 1][a - 1] = c\n\nQ = int(input())\ndist = floyd_warshall(graph)\n\n\ngraph2 = np.array([[float(\"inf\")] * N for _ in range(N)])\nnp.fill_diagonal(graph2, 0)\ngraph2[(dist <= L) & (dist != 0)] = 1\n\ndist2 = floyd_warshall(graph2)\ndist2[dist2 == float(\"inf\")] = 0\n\nfor _ in range(Q):\n    s, t = list(map(int, input().split()))\n    print((int(dist2[s - 1, t - 1]) - 1))\n", "import sys\ninput = sys.stdin.readline\n\nN, M, L = (int(i) for i in input().split())\n\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\ngraph = [[0]*N for i in range(N)]\nfor i in range(M):\n    a, b, c = (int(i) for i in input().split())\n    graph[a-1][b-1] = c\n    graph[b-1][a-1] = c\n\ngraph = csr_matrix(graph)\nd = floyd_warshall(csgraph=graph, directed=False)\n\nnew_graph = [[0]*N for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if d[i][j] <= L:\n            new_graph[i][j] = 1\n            new_graph[j][i] = 1\n\ngraph = csr_matrix(new_graph)\nd = floyd_warshall(csgraph=graph, directed=False)\nQ = int(input())\nfor i in range(Q):\n    s, t = (int(i) for i in input().split())\n    if d[s-1][t-1] == float(\"inf\"):\n        print(\"-1\")\n    else:\n        print(int(d[s-1][t-1]-1))", "from scipy.sparse import*\nf=csgraph.johnson\nn,m,l,*t=map(int,open(0).read().split())\nm*=3\n[*map(print,f(f(csr_matrix((t[2:m:3],(t[:m:3],t[1:m:3])),[n+1]*2),0)<=l)[t[m+1::2],t[m+2::2]].clip(0,n)%n-1)]", "import sys\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\n\ninput = sys.stdin.readline\n\nn, m, l = list(map(int, input().split()))\ng_dense = np.zeros((n, n))\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    g_dense[a-1][b-1] = c\n\nq = int(input())\nst = [list(map(int, input().split())) for _ in range(q)]\n\npath = shortest_path(g_dense, directed=False)\n\ng_dense = np.zeros((n, n))\n\nfor i in range(n):\n    for j in range(n):\n        if path[i][j] <= l:\n            g_dense[i][j] = 1\n\npath = shortest_path(g_dense, directed=False)\n\nINF = float('inf')\n\nfor s,t in st:\n    ans = path[s-1][t-1]\n    if ans == INF:\n        print(-1)\n    else:\n        print(int(ans) - 1)", "from scipy.sparse.csgraph import floyd_warshall\nN,M,L,*X = map(int, open(0).read().split())\nls = X[:3*M]\nEls = [[0]*N for i in range(N)]\nQ = X[3*M]\nquery = X[3*M+1:]\nfor a,b,c in zip(*[iter(ls)]*3):\n  if c<=L:\n    Els[a-1][b-1] = c\n    Els[b-1][a-1] = c\ndist = floyd_warshall(Els)\n      \nEls2 = [[0]*N for i in range(N)]\nfor i in range(N):\n  for j in range(N):\n    if dist[i][j]<=L:\n      Els2[i][j] = 1\nans = floyd_warshall(Els2)\n\nfor s,t in zip(*[iter(query)]*2):\n  if ans[s-1][t-1]==float('inf'):\n    print(-1)\n    continue\n  print(int(ans[s-1][t-1])-1)", "def resolve():\n    from scipy.sparse.csgraph import floyd_warshall\n    import numpy as np\n    import sys\n    input = sys.stdin.readline\n    n, m, l = list(map(int, input().split()))\n    inf = 10 ** 20\n    ar = np.zeros((n, n))\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        ar[a - 1, b - 1] = c\n        ar[b - 1, a - 1] = c\n    x = floyd_warshall(ar)\n    br = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i, j] <= l:\n                br[i, j] = 1\n                br[j, i] = 1\n    y = floyd_warshall(br)\n    q = int(input())\n    for _ in range(q):\n        s, t = list(map(int, input().split()))\n        p = y[s - 1, t - 1]\n        print((int(p) - 1 if p < inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,m,l=list(map(int,input().split()))\n\n#\u57fa\u672c\u7684\u306b\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u306e\u5834\u5408\u3001\u884c\u5217\u5f0f\u306e\u30ea\u30b9\u30c8\u3067\u8ddd\u96e2\u3092\u4fdd\u7ba1\u3059\u308b\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse import csgraph \nd = [[10**12 for i in range(n+1)] for i in range(n+1)]\nfor i in range(m):\n    x,y,z = list(map(int,input().split()))\n    #\u6709\u5411\u30b0\u30e9\u30d5\u304b\u7121\u5411\u30b0\u30e9\u30d5\u304b\u306b\u3088\u3063\u3066\u3053\u3053\u3067\u5834\u5408\u308f\u3051\u304c\u751f\u3058\u308b\n    d[x][y] = z\n    d[y][x] = z\n    \nfor i in range(n+1):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\nq=int(input())\nque=[]\nfor _ in range(q):\n    s,t=list(map(int,input().split()))\n    que.append((s,t))\n       \ncsr=csr_matrix(d)\nK=csgraph.shortest_path(csr,method=\"FW\",directed=True)\ne = [[10**12 for i in range(n+1)] for i in range(n+1)]\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if K[i][j]<=l:\n            e[i][j]=1\n            \nfor i in range(n+1):\n    e[i][i]=0\n    \n\nA=csr_matrix(e)\nANS=csgraph.shortest_path(A,method=\"FW\",directed=True)\n\nfor some in que:\n    s,t=some[0],some[1]\n    if int(ANS[s][t])<10**12:\n        print((int(ANS[s][t])-1))\n    else:\n        print((-1))\n\n\n", "n,m,l = map(int,input().split())\nA = [list(map(int,input().split())) for i in range(m)]\nq = int(input())\nS = [list(map(int,input().split())) for i in range(q)]\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nfor i in range(m):  # \u30ce\u30fc\u30c9\u756a\u53f7\u304c1\u59cb\u307e\u308a\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u5834\u5408\n    for j in range(2):\n        A[i][j] -= 1\n\nfor i in range(q):  # \u30ce\u30fc\u30c9\u756a\u53f7\u304c1\u59cb\u307e\u308a\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u5834\u5408\n    for j in range(2):\n        S[i][j] -= 1\n\nM = [[float(\"inf\")] * n for i in range(n)]\n\nfor i in range(n):\n    M[i][i] = 0\n\nfor i in range(m):\n    M[A[i][0]][A[i][1]] = A[i][2]\n    M[A[i][1]][A[i][0]] = A[i][2]\n\n# for k in range(n):\n#     for i in range(n):\n#         for j in range(n):\n#             M[i][j] = min(M[i][j], M[i][k] + M[k][j])\n\nM = floyd_warshall(M)\n\nfor i in range(n):\n    for j in range(n):\n        M[i][j] = 1 if M[i][j] <= l else float(\"inf\")\n\nfor i in range(n):\n    M[i][i] = 0\n\n# for k in range(n):\n#     for i in range(n):\n#         for j in range(n):\n#             M[i][j] = min(M[i][j], M[i][k] + M[k][j])\n\nM = floyd_warshall(M)\n\nfor i in range(q):\n    ans = M[S[i][0]][S[i][1]]-1\n    if ans == float(\"inf\"):\n        ans = -1\n    print(int(ans))", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nf=lambda:map(int,input().split())\nN,M,L=f()\nG=[[0]*N for _ in [0]*N]\nfor _ in [0]*M:\n    a,b,c=f()\n    G[a-1][b-1]=c\n    G[b-1][a-1]=c\n    \ncsr=csr_matrix(G)\n\nD=floyd_warshall(csr)\nINF=float('inf')\nG=[[INF]*N for _ in [0]*N]\nfor i in range(N):\n    for j in range(N):\n        if i!=j and D[i][j]<=L:\n            G[i][j]=1\n            G[j][i]=1\ncsr=csr_matrix(G)\nres=floyd_warshall(csr)\nQ=int(input())\nfor _ in [0]*Q:\n    s,t=f()\n    r=res[s-1][t-1]\n    print(int(r-1) if r<INF else -1)", "#dame datta...\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\ndef main():\n    N, M, L = list(map(int, input().split()))\n    l = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        if c > L:\n            continue\n        l[a-1][b-1] = c\n        l[b-1][a-1] = c\n    G = csr_matrix(l)\n    d = floyd_warshall(G)\n    l = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if d[i][j] <= L:\n                l[i][j] = 1\n    G = csr_matrix(l)\n    d = floyd_warshall(G)\n    Q = int(input())\n    for _ in range(Q):\n        s, t = list(map(int, input().split()))\n        s -= 1\n        t -= 1\n        x = d[s][t]\n        if x != float('inf'):\n            print((int(x)-1))\n        else:\n            print((-1))\nmain()\n", "from scipy.sparse.csgraph import floyd_warshall\n\nN,M,L = list(map(int, input().split()))\n\nedges = [[0] * N for _ in range(N)]\n\nfor _ in range(M):\n    A,B,C = list(map(int, input().split()))\n    edges[A-1][B-1] = C\n    edges[B-1][A-1] = C\n\nQ = int(input())\nqueries = []\n\nfor _ in range(Q):\n    queries.append(list(map(int,input().split())))\n\n# use flord warshall to find min path between all towns\nedges = floyd_warshall(edges)\n\n# if the two towns can be travelled to on one tank, add to our fuel graph with distance 1\nfor i in range(N):\n    for j in range(N):\n        if edges[i][j] <= L:\n            edges[i][j] = 1\n        else:\n            edges[i][j] = 0\n\n# use flord warshall to find min number of fuel tanks to travel between two towns\nedges = floyd_warshall(edges)\n\nfor query in queries:\n    s = query[0] - 1\n    t = query[1] - 1\n    num_tanks = edges[s][t] - 1\n    if num_tanks != float('inf'):\n        print((int(num_tanks)))\n    else:\n        print(\"-1\")\n", "n,m,l = map(int, input().split())\nwf=[[float(\"inf\") for i in range(n)] for j in range(n)]\nfor i in range(m):\n    a,b,c = list(map(int,input().split()))\n    wf[a-1][b-1] = c\n    wf[b-1][a-1] = c\nq = int(input())\nst=[list(map(int,input().split())) for i in range(q)]\n\nfrom scipy.sparse.csgraph import floyd_warshall\nfor i in range(n):\n    wf[i][i]=0\nwf=floyd_warshall(wf)\n\nfor i in range(n):\n    for j in range(n):\n        if wf[i][j] <= l:\n            wf[i][j] = 1\n        else:\n            wf[i][j] = float(\"inf\")\n\nwf=floyd_warshall(wf)\n\nfor que in st:\n    s,t=que\n    if wf[s-1][t-1] == float(\"inf\"):\n        print(-1)\n    else:\n        print(int(wf[s-1][t-1]-1))", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\nN, M, L = list(map(int, input().split()))\ninf = 10**9 + 1\ndist = [[inf] * N for i in range(N)]\nfor i in range(M):\n    A, B, C = list(map(int, input().split()))\n    dist[A-1][B-1] = dist[B-1][A-1] = C\n\ndist = floyd_warshall(dist, directed=False)\ndist = np.where(dist <= L, 1, inf)\ndist = floyd_warshall(dist, directed=False)\ndist = np.where(dist < inf, dist-1, -1)\n\nQ = int(input())\nfor i in range(Q):\n    s, t = list(map(int, input().split()))\n    print((int(dist[s-1, t-1])))\n"]
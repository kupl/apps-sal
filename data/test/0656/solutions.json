["#!/usr/bin/env python3\ndef solve():\n    n, k = list(map(int, input().split()))\n    temps = list(map(int, input().split()))\n\n    summer_seqs = []\n    winter_seqs = []\n\n    cur_season = 1\n    cur_len = 0\n    for t in temps:\n        # print(\"Handling\", t)\n        if cur_season * t > 0 or (t == 0 and cur_season == 1):\n            cur_len += 1\n            # print(\"Adding...\")\n        else:\n            # print(\"Thats new!\")\n            if cur_season == 1:\n                summer_seqs.append(cur_len)\n            else:\n                winter_seqs.append(cur_len)\n            cur_len = 1\n            cur_season = -cur_season\n    if cur_season == 1:\n        summer_seqs.append(cur_len)\n    else:\n        winter_seqs.append(cur_len)\n\n    summer_seqs = summer_seqs[1:]\n\n    cur_len = sum(winter_seqs)\n\n    if cur_len > k:\n        return -1\n\n    if len(summer_seqs) == 0:\n        return 1 if len(winter_seqs) != 0 else 0\n\n    changes = len(summer_seqs) + len(winter_seqs)\n\n    last_sum_seq = None\n    if temps[-1] >= 0:\n        last_sum_seq = summer_seqs[-1]\n        summer_seqs = summer_seqs[:-1]\n\n    summer_seqs = list(sorted(summer_seqs))\n\n    # print(\"Changes needed so far:\", changes)\n    # print(\"Summer seqs: \", len(summer_seqs))\n    # print(\"Last summer seq:\", last_sum_seq)\n    # print(\"Can drive for another\", k - cur_len)\n\n    for s in summer_seqs:\n        if k - cur_len >= s:\n            changes -= 2\n            cur_len += s\n        else:\n            break\n\n    # print(\"Before last summer we can drive for\",\n    #       k - cur_len, \"having \", changes, \"changes\")\n\n    if last_sum_seq is not None:\n        if k - cur_len >= last_sum_seq:\n            # print(\"and dont change at last\")\n            changes -= 1\n\n    return changes\n\n\ndef __starting_point():\n    print(solve())\n\n__starting_point()", "def solve(k, s):\n    w = [0]\n    for c in s:\n        if c < 0:\n            if w[-1] >= 0:\n                w.append(-1)\n            else:\n                w[-1] -= 1\n        else:\n            if w[-1] < 0:\n                w.append(1)\n            else:\n                w[-1] += 1\n    begin, end = w[0], w[-1]\n    if len(w) == 1 and w[0] > 0:\n        return 0\n    if begin > 0:\n        w.pop(0)\n    if end > 0:\n        w.pop()\n    neg_seg = [t for t in w if t < 0]\n    pos_seg = [t for t in w if t > 0]\n    d = -sum(neg_seg)\n    if d > k: return -1\n    changes = 2*len(neg_seg) - (end < 0)\n\n    pos_seg.sort()\n    for seg in pos_seg:\n        d += seg\n        if d > k:\n            if end > 0 and d-seg+end <= k:\n                return changes-1\n            else:\n                return changes\n        else:\n            changes -= 2\n\n    if end > 0 and d+end <= k:\n        return changes-1\n    else:\n        return changes\n    \n    \n            \nn, k = list(map(int, input().split()))\ns = [int(x) for x in input().split()]\nprint(solve(k, s))\n", "n, k = [int(i) for i in input().split(' ')]\nw = [int(i) for i in input().split(' ')]\n\nf = 0\nwhile f < n and w[f] >= 0:\n    f += 1\n\nif f == n:\n    print(0)\n    return\n\nb = n - 1\nwhile b >= 0 and w[b] >= 0:\n    b -= 1\n\n# if n == b - f + 1:\n#     print(1)\n#     return\n\nif f == b:\n    if k == 0:\n        print(-1)\n        return\n\n    if f+1 == n:\n        print(1)\n        return\n    else:\n        if (k - 1) >= (n - (b + 1)):\n            print(1)\n            return\n        else:\n            print(2)\n            return\n\ninv = []\nps = 0\nns = 0\nfor i in range(f, b):\n    if w[i] >= 0:\n        ps += 1\n        if w[i+1] < 0:\n            inv.append(ps)\n    elif w[i] < 0:\n        ns += 1\n        if w[i+1] >= 0:\n            ps = 0\nns += 1\nspare = k - ns\n\nif spare < 0:\n    print(-1)\n    return\n\nif not inv:\n    if w[n-1] < 0:\n        print(1)\n        return\n    else:\n        if spare >= (n - (b + 1)):\n            print(1)\n            return\n        else:\n            print(2)\n            return\n\ninvs = sorted(inv)\n\nif spare < invs[0]:\n    ch = (len(invs) + 1) * 2\n    remainder = spare\nelse:\n    use, invsn = invs[0], -1\n    for i in range(1, len(invs)):\n        use += invs[i]\n        if spare < use:\n            use -= invs[i]\n            invsn = i\n            break\n\n    if invsn == -1:\n        invsn = len(invs)\n\n    ch = (len(invs) - invsn + 1) * 2\n    remainder = spare - use\n\nif remainder >= (n - (b + 1)):\n    ch -= 1\n\nprint(ch)\n\n", "#!/usr/bin/env python3\ndef ri():\n    return list(map(int, input().split()))\n\nn, k = ri()\n\nt = list(ri())\ntt = []\nmc = 0\nfor i in range(n):\n    if i == 0:\n        if t[i] < 0:\n            tt.append(-1)\n            mc += 1\n        else:\n            tt.append(1)\n        continue\n    if t[i] < 0:\n        mc += 1\n        if t[i-1] >= 0:\n            tt.append(-1)\n        continue\n    else:\n        if t[i-1] >= 0:\n            tt[-1] = tt[-1] + 1\n        else:\n            tt.append(1)\nif mc > k:\n    print(-1)\n    return\nif tt[0] != -1:\n    tt = tt[1:]\n\nif len(tt) == 0:\n    print(0)\n    return\n\nttt = []\nmaxs = len(tt)\nk2 = k\ntt2 = tt[:]\n\n# exclude last tt\nif tt[-1] != -1:\n    tt = tt[:-1]\n\nfor i in tt:\n    if i > 0:\n        ttt.append(i)\nk -= mc\nttt.sort()\nfor i in ttt:\n    if k -i >= 0:\n        k -= i\n        maxs -= 2\n    else:\n        break\n\n# include last tt\nttt2 = []\nmaxs2 = len(tt2)\nfor i in tt2:\n    if i > 0:\n        ttt2.append(i)\n\nk2 -= mc\ncheck = 0\nttt2.sort()\nfor i in ttt2:\n    if k2 -i >= 0:\n        k2 -= i\n        maxs2 -= 2\n        if i == tt2[-1] and check == 0:\n            maxs2 += 1\n            check = 1\n    else:\n        break\n\nprint(min(maxs, maxs2))\n", "import heapq\n#sys.stdin=file('input.txt')\n#sys.stdout=file('output.txt','w')\n#10**9+7\nmod=1000000007\n#mod=1777777777\npi=3.1415926535897932\nIS=float('inf')\nxy=[(1,0),(-1,0),(0,1),(0,-1)]\nbs=[(-1,-1),(-1,1),(1,1),(1,-1)]\ndef niten(a,b): return abs(a-b) if a>=0 and b>=0 else  a+abs(b) if a>=0 else abs(a)+b if b>=0 else abs(abs(a)-abs(b))\ndef fib(n): return [(seq.append(seq[i-2] + seq[i-1]), seq[i-2])[1] for seq in [[0, 1]] for i in range(2, n)]\ndef gcd(a,b): return a if b==0 else gcd(b,a%b)\ndef lcm(a,b): return a*b/gcd(a,b)\ndef eucl(x1,y1,x2,y2): return ((x1-x2)**2+(y1-y2)**2)**0.5\ndef choco(xa,ya,xb,yb,xc,yc,xd,yd): return 1 if abs((yb-ya)*(yd-yc)+(xb-xa)*(xd-xc))<1.e-10 else 0\ndef pscl(num,l=[1]):\n    for i in range(num):\n        l = map(lambda x,y:x+y,[0]+l,l+[0])\n    return l\n\nn,k=[int(i) for i in input().split()]\nl=[int(i) for i in input().split()]\ncnt=[i for i in l if i<0]\nm=0\nfor a,i in enumerate(l):\n    if i<0 and m==0:\n        m=1\n    elif i<0 and l[a-1]>=0:\n        m+=1\nd={}\nq=[]\nchk=-1\nfor i in l:\n    if i<0:\n        if chk>0:\n            if chk in d:\n                d[chk]+=1\n            else:\n                d[chk]=1\n                heapq.heappush(q,chk)\n        chk=0\n    elif chk>=0:\n        chk+=1\nans=m*2\nk-=len(cnt)\nwhile len(q) and k>=q[0]:\n    k-=q[0]\n    ans-=2\n    d[q[0]]-=1\n    if d[q[0]]==0:\n        heapq.heappop(q)\nif k>=chk and chk>-1:\n    ans-=1\nprint(ans if ans>=0 and k>=0 else -1)", "import heapq\n\nn,k=[int(i) for i in input().split()]\nl=[int(i) for i in input().split()]\ncnt=[i for i in l if i<0]\nm=0\nfor a,i in enumerate(l):\n    if i<0 and m==0:\n        m=1\n    elif i<0 and l[a-1]>=0:\n        m+=1\nd={}\nq=[]\nchk=-1\nfor i in l:\n    if i<0:\n        if chk>0:\n            if chk in d:\n                d[chk]+=1\n            else:\n                d[chk]=1\n                heapq.heappush(q,chk)\n        chk=0\n    elif chk>=0:\n        chk+=1\nans=m*2\nk-=len(cnt)\nwhile len(q) and k>=q[0]:\n    k-=q[0]\n    ans-=2\n    d[q[0]]-=1\n    if d[q[0]]==0:\n        heapq.heappop(q)\nif k>=chk and chk>-1:\n    ans-=1\nprint(ans if ans>=0 and k>=0 else -1)", "n, k = list(map(int, input().split()))\ndays = list(map(int, input().split()))\na = [0 for i in range(n)] # for < 0\nb = [0 for i in range(n)] # for >= 0\nasum = 0\nia = 0\nib = 0\ninf = n + 199\n\nfor x in days:\n    if x < 0:\n        a[ia] += 1\n        asum += 1\n        if b[ib] != 0:\n            ib += 1\n    else:\n        b[ib] += 1\n        if a[ia] != 0:\n            ia += 1\nchanges = ia + 1 if a[ia] > 0 else ia\nchanges += changes - 1\nif (a[ia] == 0):\n    ia -= 1\nif b[ib] == 0:\n    ib -= 1\nif asum > k:\n    print(-1)\n    quit()\nfor i in range(ia, n):\n    a[i] = inf if a[i] == 0 else a[i]\nfor i in range(ib, n):\n    b[i] = inf if b[i] == 0 else b[i]\nif days[0] >= 0:\n    b[0] = inf\nlastb = -1\nremovedlastb = False\nif days[len(days) - 1] >= 0 :\n    changes += 1\n    lastb = b[ib]\nb.sort()\n# print('ia = ' + str(ia))\n# print('changes = ' + str(changes))\ncurb = 0\n# take care abount choosing smth in the middle exept for last\\\nseccurb = curb\nsecasum = asum\nsecchanges = changes\nsecremovedlastb = removedlastb\nwhile (curb <= ib and asum + b[curb] <= k):\n    asum += b[curb]\n    if not removedlastb:\n        if b[curb] == lastb:\n            changes -= 1\n            removedlastb = True\n        else :\n            changes -= 2\n    else:\n        changes -= 2\n    curb += 1\nwhile (seccurb <= ib and secasum + b[seccurb] <= k):\n    secasum += b[seccurb]\n    if not secremovedlastb:\n        if b[seccurb] == lastb:\n            secasum -= b[seccurb]\n            secremovedlastb = True\n        else :\n            secchanges -= 2\n    else:\n        secchanges -= 2\n    seccurb += 1\nprint(max(min(changes, secchanges), 0))\n", "n, k = list(map(int, input().split()))\n\nwinter = []\nfor i, t in enumerate([int(n) for n in input().split()]):\n    if (t < 0): winter.append(i)\n    \nif (len(winter) > k):\n    print(-1)\nelse:\n    ans = len(winter)*2\n    k -= len(winter)\n    for diff in sorted([winter[i] - winter[i-1] - 1 for i in range(1, len(winter))]):        \n        if (k >= diff):\n            k -= diff\n            ans -= 2         \n    print(ans - (1 if len(winter) > 0 and k >= n - winter[-1] - 1 else 0))\n", "from collections import deque\nimport heapq\n\ndef main():\n    from sys import stdin\n    lines = deque(line.strip() for line in stdin.readlines())\n    # lines will now contain all of the input's lines in a list\n    n, k = [int(x) for x in lines.popleft().split()]\n    temps = deque(int(x) for x in lines.popleft().split())\n    temps.appendleft(0)\n    streaks = []\n    count = 0\n    ispositive = True\n    numnegative = 0\n    changes = 0\n    while temps:\n        temp = temps.popleft()\n        positive = temp >= 0\n        if positive:\n            count += 1\n            if not ispositive:\n                changes += 1\n        else:\n            numnegative += 1\n            if ispositive:\n                streaks.append(count)\n                count = 0\n                changes += 1\n        ispositive = positive\n    if numnegative == 0:\n        print(0)\n        return\n    if numnegative > k:\n        print(-1)\n        return\n    if k >= n:\n        print(1)\n        return\n    k -= numnegative\n    heap = streaks[1:]\n    heapq.heapify(heap)\n    heap2 = list(heap)\n    if ispositive:\n        heapq.heappush(heap2, count)\n    changes2 = changes\n    k2 = k\n    while heap and k >= heap[0]:\n        k -= heapq.heappop(heap)\n        changes -= 2\n    if ispositive and k > count:\n        # don't need to change back to summer tires if we end in winter tires\n        changes -= 1\n    while heap2 and k2 >= heap2[0]:\n        k2 -= heapq.heappop(heap2)\n        changes2 -= 2\n    if ispositive and (not heap2 or heap2[0] > count):\n        changes2 += 1\n    print(min(changes, changes2))\n        \ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = list(map(int, input().split()))\n\n\ninF = False\nbad = 0\nlast = None\nstretches = [0]\nfor d in [int(x) >= 0 for x in input().split()]:\n    last = d\n    if d and not inF:\n        continue\n    else:\n        inF = True\n        if d:\n            stretches[-1] += 1\n        else:\n            bad += 1\n            if stretches[-1] != 0:\n                stretches.append(0)\n\nif bad > k:\n    print(-1)\nelif bad == 0:\n    print(0)\nelif n == k:\n    print(1)\nelse:\n    k -= bad\n\n    num = 1\n\n    if last:\n        num -= 1\n\n    if stretches[-1] == 0:\n        del stretches[-1]\n\n\n    num_ = num\n    stretches_ = stretches[:-1]\n    k_ = k\n    # print(num, stretches, k)\n\n    if len(stretches) > 0:\n        num += (len(stretches)) * 2\n        last = stretches[-1]\n        stretches.sort()\n\n        while len(stretches) > 0 and stretches[0] <= k:\n            num -= 2\n            k -= stretches[0]\n            del stretches[0]\n\n        if not last in stretches:\n            num += 1\n    # print(num_, stretches_, k_)\n\n    if len(stretches_) > 0:\n        num_ += (len(stretches_) + 1) * 2\n        stretches_.sort()\n\n        while len(stretches_) > 0 and stretches_[0] <= k_:\n            num_ -= 2\n            k_ -= stretches_[0]\n            del stretches_[0]\n\n        print(min(num, num_))\n    else:\n        print(num)\n", "import sys\n\ndef weather(temp):\n    return temp >= 0\n    \nINF = int(1e+6)\nn, k = (int(x) for x in input().split())\nday_to_temp = [int(x) for x in input().split()]\nday_to_weather = [weather(temp) for temp in day_to_temp]\n\nfirst_warm = -1\nmid_warms = []\ncolds = []\ncurr_state = 0\ncurr_len = 0\nswitches_made = 0\n\nfor weather in day_to_weather:\n    if curr_state == 0:\n        if weather == 1:\n            curr_len += 1\n        else:\n            first_warm = curr_len\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    elif curr_state == 1:\n        if weather == 1:\n            curr_len += 1\n        else:\n            mid_warms.append(curr_len)\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    else:\n        if weather == 1:\n            colds.append(curr_len)\n            curr_state = 1\n            curr_len = 1\n            switches_made += 1\n        else:\n            curr_len += 1\n\n\nif curr_state == 1:\n    last_warm = curr_len\nelif curr_state == 2:\n    colds.append(curr_len)\n    last_warm = INF\nelse:\n    print(0)\n    return\n    \nmid_warms = sorted(mid_warms)\ncold_days = sum(colds)\nfree_days = k - cold_days\n\nif free_days < 0:\n    print(-1)\n    return\nelif free_days == 0:\n    print(switches_made)\n    return\nelif len(mid_warms) > 0:\n    i = 0\n    while i < len(mid_warms) and free_days - mid_warms[i] >= 0:\n        switches_made -= 2\n        free_days -= mid_warms[i]\n        i += 1\n        \nif free_days - last_warm >= 0:\n    switches_made -= 1\n    free_days -= last_warm\n    \nprint(switches_made)\n    \n\n    \n", "import sys\n\ndef weather(temp):\n    return temp >= 0\n    \nINF = int(1e+6)\nn, k = (int(x) for x in input().split())\nday_to_temp = [int(x) for x in input().split()]\nday_to_weather = [weather(temp) for temp in day_to_temp]\n\nfirst_warm = -1\nmid_warms = []\ncolds = []\ncurr_state = 0\ncurr_len = 0\nswitches_made = 0\n\nfor weather in day_to_weather:\n    if curr_state == 0:\n        if weather == 1:\n            curr_len += 1\n        else:\n            first_warm = curr_len\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    elif curr_state == 1:\n        if weather == 1:\n            curr_len += 1\n        else:\n            mid_warms.append(curr_len)\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    else:\n        if weather == 1:\n            colds.append(curr_len)\n            curr_state = 1\n            curr_len = 1\n            switches_made += 1\n        else:\n            curr_len += 1\n\nif curr_state == 1:\n    last_warm = curr_len\nelif curr_state == 2:\n    colds.append(curr_len)\n    last_warm = INF\nelse:\n    print(0)\n    return\n    \nmid_warms = sorted(mid_warms)\ncold_days = sum(colds)\nfree_days = k - cold_days\n\nif free_days < 0:\n    print(-1)\n    return\nelif free_days == 0:\n    print(switches_made)\n    return\nelif len(mid_warms) > 0:\n    i = 0\n    while i < len(mid_warms) and free_days - mid_warms[i] >= 0:\n        switches_made -= 2\n        free_days -= mid_warms[i]\n        i += 1\n        \nif free_days - last_warm >= 0:\n    switches_made -= 1\n    free_days -= last_warm\n    \nprint(switches_made)\n    \n\n    \n", "import sys\nfrom collections import deque\n\ndef weather(temp):\n    return temp >= 0\n    \nINF = int(1e+6)\nn, k = (int(x) for x in input().split())\nday_to_temp = [int(x) for x in input().split()]\nday_to_weather = [weather(temp) for temp in day_to_temp]\n\nfirst_warm = -1\nmid_warms = []\ncolds = []\ncurr_state = 0\ncurr_len = 0\nswitches_made = 0\n\nfor weather in day_to_weather:\n    if curr_state == 0:\n        if weather == 1:\n            curr_len += 1\n        else:\n            first_warm = curr_len\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    elif curr_state == 1:\n        if weather == 1:\n            curr_len += 1\n        else:\n            mid_warms.append(curr_len)\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    else:\n        if weather == 1:\n            colds.append(curr_len)\n            curr_state = 1\n            curr_len = 1\n            switches_made += 1\n        else:\n            curr_len += 1\n\nif curr_state == 1:\n    last_warm = curr_len\nelif curr_state == 2:\n    colds.append(curr_len)\n    last_warm = INF\nelse:\n    print(0)\n    return\n    \nmid_warms_deque = deque(sorted(mid_warms, reverse=True))\ncold_days_nr = sum(colds)\nfree_days = k - cold_days_nr\n\nif free_days < 0:\n    print(-1)\n    return\nelif free_days == 0:\n    print(switches_made)\n    return\nelif len(mid_warms) > 0:\n    while mid_warms_deque:\n        curr_warm_len = mid_warms_deque.pop()\n        if free_days - curr_warm_len >= 0:\n            switches_made -= 2\n            free_days -= curr_warm_len\n        \nif free_days - last_warm >= 0:\n    switches_made -= 1\n    free_days -= last_warm\n    \nprint(switches_made)\n    \n\n    \n", "import sys\nfrom collections import deque\n\ndef weather(temp):\n    return temp >= 0\n    \nINF = int(1e+6)\nn, k = (int(x) for x in input().split())\nday_to_temp = [int(x) for x in input().split()]\nday_to_weather = [weather(temp) for temp in day_to_temp]\n\nfirst_warm = -1\nmid_warms = []\ncolds = []\ncurr_state = 0\ncurr_len = 0\nswitches_made = 0\n\nfor weather in day_to_weather:\n    if curr_state == 0:\n        if weather == 1:\n            curr_len += 1\n        else:\n            first_warm = curr_len\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    elif curr_state == 1:\n        if weather == 1:\n            curr_len += 1\n        else:\n            mid_warms.append(curr_len)\n            curr_state = 2\n            curr_len = 1\n            switches_made += 1\n    else:\n        if weather == 1:\n            colds.append(curr_len)\n            curr_state = 1\n            curr_len = 1\n            switches_made += 1\n        else:\n            curr_len += 1\n\nif curr_state == 1:\n    last_warm = curr_len\nelif curr_state == 2:\n    colds.append(curr_len)\n    last_warm = INF\nelse:\n    print(0)\n    return\n    \nmid_warms_deque = deque(sorted(mid_warms, reverse=True))\ncold_days_nr = sum(colds)\nfree_days = k - cold_days_nr\n\nif free_days < 0:\n    print(-1)\n    return\nelif free_days == 0:\n    print(switches_made)\n    return\nelif len(mid_warms) > 0:\n    while mid_warms_deque:\n        curr_warm_len = mid_warms_deque.pop()\n        if not free_days - curr_warm_len >= 0:\n            break\n        switches_made -= 2\n        free_days -= curr_warm_len\n        \nif free_days - last_warm >= 0:\n    switches_made -= 1\n    free_days -= last_warm\n    \nprint(switches_made)\n    \n\n    \n", "f = lambda: map(int, input().split())\nn, k = f()\ns, d = [], -1\nfor q in f():\n    if q < 0:\n        k -= 1\n        if d > 0: s += [d]\n        d = 0\n    elif d + 1: d += 1\ns.sort()\ndef g(k, d):\n    d += len(s) << 1\n    for q in s:\n        if q > k: break\n        k -= q\n        d -= 2\n    return d\nprint(0 if d < 0 else -1 if k < 0 else g(k, 2) if k < d else min(g(k, 2), g(k - d, 1)))", "f = lambda: map(int, input().split())\nn, k = f()\ns, d = [], -1\nfor q in f():\n    if q < 0:\n        k -= 1\n        if d > 0: s += [d]\n        d = 0\n    elif d > -1: d += 1\ns.sort()\nt = 2 * len(s)\nfor q in s:\n    if q > k: break\n    k -= q\n    t -= 2\nprint(-1 if k < 0 else 0 if d < 0 else 2 + t - (k >= d))", "n, k = [int(i) for i in input().split()]\nt = [int(i) for i in input().split()]\ncolddays = [i for i in range(n) if t[i]<0 ]\nnum_colddays = len(colddays)\nif num_colddays == 0:\n    print(0)\nelif k >= n:\n    print(1)\nelse:\n    if num_colddays > k:\n        print(-1)\n    else:\n        k -= num_colddays\n        ans = 0\n        for i in range(1, len(colddays)):\n            if colddays[i] - colddays[i-1] > 1:\n                ans += 1\n        ans += 1\n        ans *= 2\n        gap = [0 for i in range(num_colddays)]\n        for j in range(1, num_colddays):\n            gap[j-1] = colddays[j] - colddays[j-1]-1\n        positivegap = [j for j in gap if j > 0]\n        positivegap = sorted(positivegap)\n        for i in positivegap:\n            if k >= i:\n                k -= i\n                ans -= 2\n            else:\n                break\n        remain = n - 1 - colddays[-1]\n        if k >= remain:\n            ans -= 1\n        print(ans)\n", "_, k = map(int, input().split())\nval = [0] + list(map(int, input().split()))\nn = len(val)\npls = []\n\ncur, i, sm  = 0, 0, 0\nwhile i < n:\n    if val[i] >= 0:\n        cur += 1\n    else:\n        if cur > 0:\n            pls.append(cur)\n        cur = 0\n    i += 1\n\nsm = sum(p for p in pls)\npls = pls[1:]\n\nif cur > 0:\n    one = cur\n    sm += cur\nelse:\n    one = 10 ** 19\n\nans = 0\n\nfor i in range(1, n):\n    if (val[i] >= 0 and val[i - 1] < 0) or (val[i] < 0 and val[i - 1] >= 0):\n        ans += 1\n\nif n - sm > k:\n    print(-1)\nelse:\n    pls.sort()\n    rem = k - (n - sm)\n    for p in pls:\n        if rem >= p:\n            rem -= p\n            ans -= 2\n\n    if rem >= one:\n        ans -= 1\n\n    print(ans)", "n,k=map(int,input().split())\nd=list(map(int,input().split()))\np=[]\ncount=0\ncount1=0\nfor i in range(len(d)):\n    if d[i]>=0:\n        count+=1\n    if d[i]<0 or i==len(d)-1:\n        p.append(count)\n        count=0\n        count1+=1\nif d[len(d)-1]>=0:\n    count1-=1\nif count1==0:\n    print(0)\n    return\na=p.pop() if d[len(d)-1]>=0 else 0\nif len(p)>0:\n    p.reverse()\n    p.pop()\n    p.sort()\ncount=k-len(p)-1 if count1>1 else k-count1\nif count<0:\n    print(-1)\n    return\ncount1=0\nfor i in range(len(p)):\n    if(count-p[i]>=0):\n        count1+=1\n        count-=p[i]\n    else:\n        break\nans=2*(len(p)+1-count1)\nif count-a>=0:\n    ans-=1\nprint(ans)", "import math\nfrom collections import Counter, defaultdict\nfrom itertools import accumulate\n\nR = lambda: map(int, input().split())\nn, k = R()\nts = list(R()) + [-1]\nk -= sum(1 if t < 0 else 0 for t in ts[:n])\nres = 0 if ts[0] >= 0 else 1\nfor i in range(1, n):\n    if ts[i - 1] < 0 and ts[i] >= 0 or ts[i - 1] >= 0 and ts[i] < 0:\n        res += 1\nlocs = [i for i, t in enumerate(ts) if t < 0]\nps = sorted((y - x - 1, y) for x, y in zip(locs, locs[1:]) if y - x > 1)\nres1 = res\nk1 = k\nfor p in ps:\n    if k >= p[0]:\n        res -= (2 if p[1] < n else 1)\n        k -= p[0]\n    if k1 >= p[0] and p[1] < n:\n        res1 -= 2\n        k1 -= p[0]\nres = res if k >= 0 else math.inf\nres1 = res1 if k1 >= 0 else math.inf\nprint(min(res, res1) if min(res, res1) < math.inf else -1)", "n, k = list(map(int,input().split()))\na = list([int(x)>=0 for x in input().split()])\n\nfor ind_positive in range(n):\n    if not a[ind_positive]:\n        break\nelse:\n    print(0)\n    return\na = a[ind_positive:]\nn = len(a)\n\nfor ind_positive in range(n-1, -1, -1):\n    if not a[ind_positive]:\n        break\na = a[:ind_positive+1]\nlen_suf = n-ind_positive-1\nn = len(a)\n#print(a, len_suf)\n\nb = []\ni = 0\nwhile True:\n    j = 0\n    while i < n and a[i]:\n        i += 1\n        j += 1\n    if j:\n        b.append(j)\n    i += 1\n    if i >= n:\n        break\nb_sort = b.copy()\nb_sort.sort(reverse = True)\ns = 0\ni = 0\nif n-s>k:\n    for i in range(len(b)):\n        s += b_sort[i]\n        if n-s <= k:\n            i += 1\n            break\nif n-s > k:\n    ans2 = -1\nelse:\n    ans2 = i*2+2\n\nk -= len_suf\nif k < 0:\n    ans1 = -1\nelse:\n    b = []\n    i = 0\n    while True:\n        j = 0\n        while i < n and a[i]:\n            i += 1\n            j += 1\n        if j:\n            b.append(j)\n        i += 1\n        if i >= n:\n            break\n    b_sort = b.copy()\n    b_sort.sort(reverse = True)\n    s = 0\n    i = 0\n    if n-s>k:\n        for i in range(len(b)):\n            s += b_sort[i]\n            if n-s <= k:\n                i += 1\n                break\n    if n-s > k:\n        ans1 = -1\n    else:\n        ans1 = i*2+1\n\nif ans1 == -1:\n    print(ans2)\nelif ans2 == -1:\n    print(ans1)\nelse:\n    print(min(ans1,ans2))\n\n\n\n\n\n\n\n\n", "\"\"\"\nNTC here\n\"\"\"\nimport sys\ninp = sys.stdin.readline\n \n \ndef input(): return inp().strip()\n \n \nflush = sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**6)\n# threading.stack_size(2**25)\n \n \ndef iin(): return int(input())\n \n \ndef lin(): return list(map(int, input().split()))\n \n# range = xrange\n# input = raw_input\n \n \ndef main():\n    n, k = lin()\n    a = lin()\n    a1 = [0]*n\n    for i in range(n):\n        if a[i]<0:\n            a1[i]=1\n    sm = sum(a1)\n    if sm>k:\n        print(-1)\n    else:\n        sm = k-sm\n        lft = []\n        ch = 0\n        for i in range(n):\n            if a1[i]:\n                if ch and i-ch:lft.append([ ch, i-ch, 2])\n                ch = 0\n            else:\n                ch+=1\n        ext = []\n        if ch and i+1-ch:\n            ext =[ch, 1+i-ch, 1]\n        # print(lft, ext)\n        lft.sort()\n        a2 = lft + ([ext] if ext else [])\n        a2.sort()\n        def check(a):\n            if not a:return 0\n            # print(a)\n            s1 = sm\n            ans = 0\n            for i, j, k in a:\n                if s1<i:break\n                s1 -= i\n                ans+=k\n            return ans\n        if check(a2)>check(lft):\n            lft = a2\n        lft = lft[::-1]\n        # print(sm, a1)\n        # print(lft)\n        while sm and lft:\n            ch, i, asd = lft.pop()\n            if sm<ch:continue\n            while sm and ch and i< n:\n                a1[i]=1\n                i+=1\n                sm-=1\n                ch-=1\n        # print(a1)\n        ans = 0\n        a1 = [0]+a1\n        for i in range(1, n+1):\n            if a1[i]!=a1[i-1]:ans+=1\n        print(ans)\n\n \n \n \n \n \n \n \n\nmain()\n# threading.Thread(target=main).start()\n"]
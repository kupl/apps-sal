["import sys\n\nsys.setrecursionlimit(10**6)\n\nans = 0\n\ndef solve():\n    n = int(input())\n    Adj = [[] for i in range(n)]\n\n    for i in range(n - 1):\n        ai, bi, ci = map(int, sys.stdin.readline().split())\n        Adj[ai].append((bi, ci))\n        Adj[bi].append((ai, ci))\n\n    dfs(n, Adj, -1, 0, 0)\n\n    print(ans)\n\ndef dfs(n, Adj, p, u, cost):\n    if u != 0 and len(Adj[u]) == 1:\n        nonlocal ans\n        ans = max(ans, cost)\n        return\n\n    for (v, c) in Adj[u]:\n        if p == v:\n            continue\n        dfs(n, Adj, u, v, cost + c)\n\ndef __starting_point():\n    solve()\n__starting_point()", "n = int(input())\ncnx = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u, v, c = [int(i) for i in input().split()]\n    cnx[u].append([v, c])\n    cnx[v].append([u, c])\n\ndef cost(cur, src = -1):\n    ans = 0\n    for v, c in cnx[cur]:\n        if v == src: continue\n        ans = max(ans, c + cost(v, cur))\n    return ans\n\nans = cost(0)\nprint(ans)\n\n", "def dfs(s = 0, p = -1):\n    nonlocal a\n    nonlocal n\n    if len(a[s]) == 1 and p != -1:\n        return a[s][0][1]\n    o = -1\n    pp = -1\n    for i in range(len(a[s])):\n        if a[s][i][0] != p:\n            if o == -1:\n                o = dfs(a[s][i][0], s)\n            else:\n                o = max(o, dfs(a[s][i][0], s))\n        else:\n            pp = i\n    if p != -1:\n        return o + a[s][pp][1]\n    return o\n\nn = int(input())\na = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y, z = list(map(int, input().split()))\n    a[x] += [[y, z]]\n    a[y] += [[x, z]]\nprint(dfs())\n\n", "def dfs(u,cur):\n    nonlocal ans\n    vis[u]=True\n    flag=True\n    for x in vec[u] :\n        v=x[0]\n        c=x[1]\n        if not vis[v] :\n            dfs(v,cur+c)\n            flag=False\n    if flag:\n        ans=max(cur,ans)\nans=0\nvec=[]\nvis=[]\ni=0\nn=int(input())\nwhile(i<n) :\n    vec.append([])\n    vis.append(False)\n    i+=1\ni=1\nwhile(i<n):\n    u,v,c=(int(x) for x in input().split(' '))\n    vec[u].append((v,c))\n    vec[v].append((u,c))\n    i+=1\ndfs(0,0)\nprint(ans)\n", "n = int(input())\nmatrix = [[] for i in range(n)]\nfor i in range(n - 1):\n    a = list(map(int, input().split()))\n    matrix[a[0]].append([a[1], a[2]])\n    matrix[a[1]].append([a[0], a[2]])\nway = [float('inf') for i in range(n)]\nused = [False for i in range(n)]\nv = 0\nway[0] = 0\nfor i in range(n):\n    used[v] = True\n    for j in matrix[v]:\n        way[j[0]] = min(way[j[0]], way[v] + j[1])\n    m = float('inf')\n    for j in range(n):\n        if way[j] < m and not used[j]:\n            m = way[j]\n            v = j\nprint(max(way))", "import sys, queue\n\nn = int(input())\ne = [[] for _ in range(n+1)]\n#print(e)\nfor i in range(n-1):\n\tu, v, w = list(map(int, input().split()))\n\te[u].append((v,w))\n\te[v].append((u,w))\n\t\n#print(e)\n\nvolt = [False for _ in range(n+1)]\ndst = [0 for i in range(n+1)]\n\nq = queue.Queue()\n\nq.put(0)\n\nwhile (not q.empty()):\n\tcurr = q.get()\n\tvolt[curr] = True\n\tfor nb in e[curr]:\n\t\tif (not volt[nb[0]]):\n\t\t\tdst[nb[0]] = dst[curr] + nb[1]\n\t\t\tq.put(nb[0])\n\t\t\tvolt[nb[0]] = True\n\n#print(dst)\nprint(max(dst))\n", "\n\ndef getmaxpath(g, v, par):\n    maxp = 0\n    for u, c in g[v]:\n        if u == par:\n            continue\n        maxp = max(maxp, c + getmaxpath(g, u, v))\n    return maxp\n\nn = int(input())\ng = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u, v, c = (int(x) for x in input().split())\n    g[u].append((v,c,))\n    g[v].append((u,c,))\nprint(getmaxpath(g, 0, -1))\n    \n", "def dfs(d,di):\n    stack = [[0,0]]\n    mark = {i:False for i in range(n)}\n    mark[0]=True\n    res=[]\n    while stack:\n        s = stack.pop()\n        x,cost=s[0],s[1]\n        res.append(cost)\n        for i,y in enumerate(d[x]):\n            if mark[y]==False:\n                if di.get((x,y))==None:\n                    new_cost=di[(y,x)]\n                else:new_cost=di[(x,y)]\n                stack.append([y,cost+new_cost])\n                mark[y]=True\n    print(max(res))\nn = int(input())\ndi,d={},{}\nfor i in range(n-1):\n    u,v,c = map(int,input().split())\n    di[(u,v)]=c\n    if d.get(u)==None:d[u]=[]\n    if d.get(v)==None:d[v]=[]\n    d[u].append(v)\n    d[v].append(u)\ndfs(d,di)", "count=[]\n\ndef DFs(d,node,visited,c):\n    visited.add(node)\n    for i in d[node]:\n        if i[0] not in visited:\n            #c=c+i[1]\n            DFs(d,i[0],visited,c+i[1])\n    count.append(c)\n    \n            \ndef dfs(d,n):\n    visited=set()\n    \n    for i in d.keys():\n        if i not in visited:\n            c=0\n            DFs(d,i,visited,c)\n            #count.append(a)\n\n\nn=int(input())\nd={}\nfor i in range(n):\n    d[i]=[]\nfor i in range(n-1):\n    u,v,c=map(int,input().split(' '))\n    d[u].append([v,c])\n    d[v].append([u,c])\n\ndfs(d,n)\nprint(max(count))", "from collections import deque\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v, c = list(map(int, input().split()))\n    adj[u].append((v, c))\n    adj[v].append((u, c))\ndist = [10**9] * n\ndist[0] = 0\nq = deque()\nq.append((0, n))\nwhile q:\n    i, p = q.popleft()\n    for i2, c in adj[i]:\n        if i2 == p:\n            continue\n        dist[i2] = dist[i] + c\n        q.append((i2, i))\nprint(max(dist))\n", "import sys\nmod = 1000000007\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\ndef get_ints(): return map(int, sys.stdin.readline().split())\ndef input(): return sys.stdin.readline()\ndef print_array(a): print(\" \".join(map(str, a)))\ndef maxCost(cost, tree, c, p):\n    frnds = tree[c]\n    if len(frnds) == 1 and frnds[0] == p: return 0\n    l = []\n    for frnd in frnds:\n        if frnd != p: l.append(cost[c][frnd] + maxCost(cost, tree, frnd, c))\n    return max(l)\ndef main():\n    n = int(input())\n    cost = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v, c = get_ints()\n        tree[u].append(v)\n        tree[v].append(u)\n        cost[u][v] = cost[v][u] = c\n    print(maxCost(cost, tree, 0, 0))\n            \ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\n \ntree = {}\nfor i in range(n-1):\n    _from, _to, cost = map(int, input().split())\n    if _from not in tree:\n        tree[_from] = [(_to,cost)]\n    else:\n        tree[_from].append((_to,cost))\n    if _to not in tree:\n        tree[_to] = [(_from,cost)]\n    else:\n        tree[_to].append((_from,cost))\n \npassed = [0]*n\nall_cost = []\ndef compute_cost(node, cost):\n    passed[node] = 1\n    if len(tree[node])!=0:\n        for subnode in tree[node]:\n            if passed[subnode[0]] != 1:\n                all_cost.append(cost+subnode[1])\n                compute_cost(subnode[0], cost+subnode[1])\n \ncompute_cost(0,0)\nprint (max(all_cost))", "n = int(input())\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n  x, y, z = list(map(int, input().split()))\n  g[x] += (y, z),\n  g[y] += (x, z),\n\n\ndef go(x, f):\n  ret = 0\n  for y, z in g[x]:\n    if y != f:\n      ret = max(ret, z + go(y, x))\n  return ret\n\n\nprint(go(0, -1))\n", "# maa chudaaye duniya\nfrom collections import defaultdict\ngraph = defaultdict(list)\nn = int(input())\nweights = {}\nfor _ in range(n-1):\n\ta, b, w = map(int, input().split())\n\tedge1 = '{} : {}'.format(a, b)\n\tedge2 = '{} : {}'.format(b, a)\n\tgraph[a].append(b)\n\tgraph[b].append(a)\n\tweights[edge1] = w\n\tweights[edge2] = w\n\nmaxsf = [-10**9]\nvisited = [False for i in range(n+1)]\n\ndef dfs(node, parent, dist):\n\tvisited[node] = True\n\t# print(maxsf)\n\t# print('checking ', node, parent)\n\t# print(visited)\n\tif parent != -1:\n\t\te ='{} : {}'.format(parent, node)\n\t\te1 = '{} : {}'.format(node, parent)\n\t\tif e in weights:\n\t\t\tdist += weights[e]\n\t\t\t# print(e, dist)\n\t\telse:\n\t\t\tdist += weights[e1]\n\t\t\t# print(e1, dist)\n\t\tif dist > maxsf[0]:\n\t\t\tmaxsf[0] = dist\n\tfor children in graph[node]:\n\t\tif not visited[children]:\n\t\t\tdfs(children, node, dist)\n\t\ndfs(0, -1, 0)\nprint(*maxsf)", "from collections import defaultdict\n\ngraph = defaultdict(list)\nd = {}\nn = int(input())\nfor i in range(n-1):\n    u,v,cost = list(map(int,input().split()))\n    graph[u].append(v)\n    graph[v].append(u)\n    x = str(u)+':'+str(v)\n    y = str(v)+':'+str(u)\n    d[x] = cost\n    d[y] = cost\n\nq = [[0,0]]\nans = []\nvisited = [False for i in range(n)]\nvisited[0] = True\nwhile q!=[]:\n    node,cost = q[0][0],q[0][1]\n    q.pop(0)\n    leaf = True\n    for v in graph[node]:\n        if visited[v]==False:\n            visited[v]=True\n            leaf = False\n            x = str(node)+':'+str(v)\n            y = str(v)+':'+str(node)\n            if x in d:\n                c = d[x]\n            else:\n                c = d[y]\n            q.append([v,cost+c])\n    if leaf:\n        ans.append(cost)\nprint(max(ans))", "n = int(input())\nli = [[] for i in range(0,n)]\nfor i in range(n-1):\n    u, v, c = map(int,input().split())\n    li[u].append((v,c))\n    li[v].append((u,c))\n\nmc = 0\ncost = 0\nvisited = [False] * n\ndef DFS(num,visited,cost):\n    nonlocal mc\n    if cost > mc:\n        mc = cost\n    visited[num] = True\n    for i in range(len(li[num])):\n        if not visited[li[num][i][0]]:\n            DFS(li[num][i][0],visited,cost+li[num][i][1])\nDFS(0,visited,0)\nprint(mc)", "n=int(input())\nal=[[] for j in range(n)]\nfor i in range(n-1):\n        a,b,c=list(map(int,input().split()))\n        al[a].append([b,c])\n        al[b].append([a,c])\n\nmc=0\nva=[0]*(n)\nca=[0]*(n)\ndef dfs(n,c):\n        va[n]=1\n        #print(c)\n        ca[n]=ca[n]+c\n\n        for e in al[n]:\n                #print(e)\n                p=e[0]\n                q=e[1]+ca[n]\n                if(va[p]==0):\n                        dfs(p,q)\n        \n        \ndfs(0,0)\nprint(max(ca))\n\n'''\nmc = 0\ncost = 0\nvisited = [False] * n\ndef DFS(num,visited,cost):\n    nonlocal mc\n    if cost > mc:\n        mc = cost\n    visited[num] = True\n    for i in range(len(li[num])):\n        if not visited[li[num][i][0]]:\n            DFS(li[num][i][0],visited,cost+li[num][i][1])\nDFS(0,visited,0)\nprint(mc)'''\n", "n = int(input())\ndicts = {}\nfor i in range(n - 1):\n    temparr = input()\n    temparr = temparr.split()\n    u = int(temparr[0])\n    v = int(temparr[1])\n    weight = int(temparr[2])\n\n    if u not in dicts:\n        dicts[u] = []\n    dicts[u].append((v, weight))\n\n    if v not in dicts:\n        dicts[v] = []\n    dicts[v].append((u, weight))\nmaxans = 0 \n\ndef dfs(cur, par = -1, sums = 0):\n    nonlocal dicts\n    nonlocal maxans\n    for element in dicts[cur]:\n        nextelement = element[0]\n        nextweight = element[1]\n        if par != nextelement:\n            sums+=nextweight\n            if maxans <= sums:\n                maxans = sums \n            dfs(nextelement , cur, sums)\n            sums-=nextweight\ndfs(0,-1, 0)\nprint(maxans)\nprint()\n\n# void dfs(int cur , int par = -1)\n# {\n#   // do what u want\n#   for(auto x : g[cur])\n#   {\n#     if(x!=par)\n#     {\n#       dfs(x,cur);\n#     }\n#   }\n# }\n\n#print(dicts)\n\n\n\n\n", "cost = 0\ndef solve(u, graph, visited):\n  nonlocal cost\n  visited[u] = True\n  visited[u] = True\n  cost = 0\n  explore = -1\n  subcost = 0\n  current = 0\n  for v in graph[u]:\n    if not visited[v] and graph[u][v] > subcost:\n      current = max(current, solve(v, graph, visited) + graph[u][v])\n  return max(current, cost)\n\ndef __starting_point():\n  N = int(input().strip())\n  graph = {x: {} for x in range(N)}\n  visited = [False for _ in range(N + 1)]\n  for i in range(N - 1):\n    u,v,c = list(map(int, input().strip().split(\" \")))\n    graph[u][v] = c\n    graph[v][u] = c\n  ans = solve(0, graph, visited)\n  print(ans)\n\n\n__starting_point()", "def solve(u, graph, visited):\n  visited[u] = True\n  current = 0\n  for v in graph[u]:\n    if not visited[v]:\n      current = max(current, solve(v, graph, visited) + graph[u][v])\n  return current\n\ndef __starting_point():\n  N = int(input().strip())\n  graph = {x: {} for x in range(N)}\n  visited = [False for _ in range(N + 1)]\n  for i in range(N - 1):\n    u,v,c = list(map(int, input().strip().split(\" \")))\n    graph[u][v] = c\n    graph[v][u] = c\n  ans = solve(0, graph, visited)\n  print(ans)\n\n\n__starting_point()", "n=int(input())\nd={}\ncost=[]\nfor i in range(n):\n    cost.append(n*[0])\nfor i in range(n-1):\n    u,v,c=list(map(int,input().split()))\n    if u not in d:\n        d[u]=[]\n    if v not in d:\n        d[v]=[]\n    d[u].append(v)\n    d[v].append(u)\n    cost[u][v]=c\n    cost[v][u]=c\nkhoroch=n*[0]\nvisit=n*[0]\ndef dfs(d,s,parent):\n    nonlocal ans\n    visit[s]=1\n    khoroch[s]=cost[parent][s]+khoroch[parent]\n    #print(s,visit[s])\n    ans=max(khoroch[s],ans)\n    for x in d[s]:\n        if(visit[x]==0):\n            dfs(d,x,s)\nans=0\ndfs(d,0,0)\nprint(ans)\n    \n\n", "import sys\nimport threading\nfrom collections import defaultdict\n\n\n\nadj=defaultdict(list)\nn=int(input())\nfor _ in range(n-1):\n    x,y,b=list(map(int,input().split()))\n    adj[x].append((y,b))\n    adj[y].append((x,b))\ndef fun(node,par,x):\n    y=x\n    for ch,b in adj[node]:\n        if ch!=par:\n            y=max(fun(ch,node,x+b),y)\n    return y\n\n\ndef main():\n    print(fun(0,-1,0))\n                  \ndef __starting_point():\n    sys.setrecursionlimit(10**6)\n    threading.stack_size(10**8)\n    t = threading.Thread(target=main)\n    t.start()\n    t.join() \n__starting_point()", "# Author: S Mahesh Raju\n# Username: maheshraju2020\n# Created on: 25/09/2020 01:47:42\n\nfrom sys import stdin, stdout, setrecursionlimit\nimport heapq\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nsetrecursionlimit(100000)\nmod = 1000000007\n\ndef getAns(d):\n    queue = [[0, 0]]\n    seen = set()\n    res = float(\"-inf\")\n    while len(queue):\n        cur, cost = queue.pop()\n        if cur not in seen:\n            seen.add(cur)\n            res = max(res, cost)\n            for a, b in d.get(cur, []):\n                queue.append([a, b + cost])\n    return res\n\n\nn = ii1()\nd = {}\nfor i in range(n - 1):\n    a, b, cost = iia()\n    d.setdefault(a, []).append([b, cost])\n    d.setdefault(b, []).append([a, cost])\nprint(getAns(d))\n"]
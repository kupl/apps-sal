["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\npossible1=[set() for _ in range(200)]\npossible2=[set() for _ in range(200)]\nweird=[0]*15\n\np1=list(map(int,input().split()))\np2=list(map(int,input().split()))\n\nfor i in range(n):\n    for j in range(m):\n        a=sorted(p1[i*2:i*2+2])\n        b=sorted(p2[j*2:j*2+2])\n        if a==b: continue\n        got=-1\n        if a[0] in b: got=a[0]\n        if a[1] in b: got=a[1]\n        if got==-1: continue\n        weird[got]=1\n        possible1[a[0]*11+a[1]].add(got)\n        possible2[b[0]*11+b[1]].add(got)\n\nif sum(weird)==1:\n    print(weird.index(1))\nelif max(len(i) for i in possible1)==1 and max(len(i) for i in possible2)==1:\n    print(0)\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\np1 = list(map(int, input().split()))\np2 = list(map(int, input().split()))\ncand = set()\ncc = [set() for i in range(n)]\ndd = [set() for i in range(m)]\nfor i in range(n):\n    for j in range(m):\n        a, b = p1[2 * i], p1[2 * i + 1]\n        c, d = p2[2 * j], p2[2 * j + 1]\n        if a not in (c, d) and b not in (c, d):\n            continue\n        if a in (c, d) and b in (c, d):\n            continue\n        if a in (c, d):\n            kandidat = a\n        else:\n            kandidat = b\n        cand.add(kandidat)\n        cc[i].add(kandidat)\n        dd[j].add(kandidat)\nif len(cand) == 1:\n    print(cand.pop())\nelif max(len(cc[i]) for i in range(n)) <= 1 and\\\n        max(len(dd[i]) for i in range(m)) <= 1:\n    print(0)\nelse:\n    print(-1)\n", "import sys\nna, nb = list(map(int, sys.stdin.readline().split()))\n\nal, bl = list(map(int, sys.stdin.readline().split())), list(map(int, sys.stdin.readline().split()))\n\na = [set((al[2*i], al[2*i+1])) for i in range(na)]\nb = [set((bl[2*i], bl[2*i+1])) for i in range(nb)]\n\naposs, bposs = set(), set()\npossible_shared = set()\ni_know_a_knows, i_know_b_knows = True, True\n\nfor ahas in a:\n    bposshere = set()\n    for bp in b:\n        if len(ahas & bp) == 1:\n            bposshere |= ahas & bp\n    possible_shared |= bposshere\n\n    if len(bposshere) == 2:\n        i_know_a_knows = False\n\nfor bhas in b:\n    aposshere = set()\n    for ap in a:\n        if len(bhas & ap) == 1:\n            aposshere |= bhas & ap\n    possible_shared |= aposshere\n\n    if len(aposshere) == 2:\n        i_know_b_knows = False\n\n\nif len(possible_shared) == 1:\n    print(list(possible_shared)[0])\nelif i_know_a_knows and i_know_b_knows:\n    print(0)\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ncan0 = set()\ncan1 = [set() for i in range(n)]\ncan2 = [set() for i in range(m)]\n\nfor i in range(n):\n    for j in range(m):\n        x1 = a[i * 2]\n        x2 = a[i * 2 + 1]\n        y1 = b[j * 2]\n        y2 = b[j * 2 + 1]\n        if x1 > x2: x1, x2 = x2, x1\n        if y1 > y2: y1, y2 = y2, y1\n        if x1 == y1 and x2 == y2: continue\n        if x1 == y1:\n            can1[i].add(y1)\n            can2[j].add(y1)\n            can0.add(y1)\n        if x2 == y1:\n            can1[i].add(y1)\n            can2[j].add(y1)\n            can0.add(y1)\n        if x1 == y2:\n            can1[i].add(y2)\n            can2[j].add(y2)\n            can0.add(y2)\n        if x2 == y2:\n            can1[i].add(y2)\n            can2[j].add(y2)\n            can0.add(y2)\nif len(can0) == 1:\n    print(min(can0))\nelse:\n    ok = True\n    for i in can1:\n        if len(i) > 1:\n            ok = False\n    for i in can2:\n        if len(i) > 1:\n            ok = False\n    if ok: print(0)\n    else: print(-1)\n", "def readpts():\n\tip = list(map(int, input().split()))\n\treturn [(min(ip[i], ip[i+1]), max(ip[i], ip[i+1])) for i in range(0,len(ip),2)]\n\nN, M = list(map(int, input().split()))\npts1 = readpts()\npts2 = readpts()\n#print(pts1)\n#print(pts2)\n\ndef psb(a, b):\n\tif a == b: return False\n\treturn any(i in b for i in a)\n\ndef sb(a, b):\n\tfor i in a:\n\t\tif i in b:\n\t\t\treturn i\n\treturn -1 # should not happen\n\ndef ipsv(pts1, pts2):\n\tans = False\n\tfor p1 in pts1:\n\t\tgsb = set()\n\t\tfor p2 in pts2:\n\t\t\tif psb(p1, p2):\n\t\t\t\tgsb.add(sb(p1, p2))\n\t\tif len(gsb) > 1: return False\n\t\tif len(gsb) == 1: ans = True\n\treturn ans\n\ndef sv():\n\tgsb = set()\n\tfor p1 in pts1:\n\t\tfor p2 in pts2:\n\t\t\tif psb(p1, p2):\n\t\t\t\tgsb.add(sb(p1, p2))\n\tif len(gsb) == 0: return -1\n\tif len(gsb) == 1: return list(gsb)[0]\n\tif ipsv(pts1, pts2) and ipsv(pts2, pts1): return 0\n\treturn -1\n\nprint(sv())\n", "from sys import stdin, stdout\n\n\nn, m = map(int, stdin.readline().split())\np1, p2 = [], []\n\nchallengers = list(map(int, stdin.readline().split()))\nfor i in range(n):\n    p1.append((challengers[i * 2], challengers[i * 2 + 1]))\n    \nchallengers = list(map(int, stdin.readline().split()))\nfor i in range(m):\n    p2.append((challengers[i * 2], challengers[i * 2 + 1]))    \n\n\nlabel = -1\nX = 10\ncount = [0 for i in range(X)]\n\nfor x in range(1, X):\n    for i in range(n):\n        if x not in p1[i]:\n            continue\n        \n        for j in range(m):\n            if x not in p2[j]:\n                continue\n            \n            if len(set(p1[i]) & set(p2[j])) == 1:\n                count[x] += 1\n                c = x\n\nif count.count(0) == 9:\n    stdout.write(str(c))\nelse:\n    label = 1\n    ind = 0\n    \n    for p11 in p1:\n        cur = set()\n        for p22 in p2:\n            if len(set(p11) & set(p22)) == 1:\n                cur |= set(p11) & set(p22)\n        \n        if len(cur) == 2:\n            label = 0\n        \n    \n    for p22 in p2:\n        cur = set()\n        for p11 in p1:\n            if len(set(p11) & set(p22)) == 1:\n                cur |= set(p11) & set(p22)\n        \n        if len(cur) == 2:\n            label = 0\n    \n    \n    if label == 1:\n        stdout.write('0')\n    else:\n        stdout.write('-1')", "#     Codeforces Round #488 by NEAR (Div. 2)\nimport collections\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \n\ndef makePair(z):\n    return  [(z[i], z[i+1]) for i in range(0,len(z),2) ]\n            \nN,M =  getIntList()\np1 = getIntList()\np1 = makePair(p1)\np1 = list(map( set, p1))\np2 = getIntList()\np2 = makePair(p2)\np2 = list(map( set, p2))\n#print(p1)\n\nres = set()\nfor x in p1:\n    for y in p2:\n        z = x&y\n        if len(z) ==2 or len(z) ==0:continue\n        res = res | z\nif len(res) == 1:\n    print(res.pop())\n    return\n\nfor x in p1:\n    nz = set()\n    for y in p2:\n        z = x&y\n        if len(z) ==2 or len(z) ==0:continue        \n        nz = nz | z\n    if len(nz) == 2:\n        print(-1)\n        return\n\nfor x in p2:\n    nz = set()\n    for y in p1:\n        z = x&y\n        if len(z) ==2 or len(z) ==0:continue        \n        nz = nz | z\n    if len(nz) == 2:\n        print(-1)\n        return\n\nprint(0)\n", "n, m = list(map(int, input().split()))\naa = list(map(int, input().split()))\nbb = list(map(int, input().split()))\n\na = []\nb = []\n\nfor i in range(0, 2 * n, 2):\n    a.append([aa[i], aa[i + 1]])\n\nfor i in range(0, 2 * m, 2):\n    b.append([bb[i], bb[i + 1]])\n\naccept = []\n\nfor num in range(1, 10):\n    ina = []\n    inb = []\n    for x in a:\n        if num in x:\n            ina.append(x)\n    \n    for x in b:\n        if num in x:\n            inb.append(x)\n    \n    x = 0\n    for t in ina:\n        t.sort()\n        for p in inb:\n            p.sort()\n            if t != p:\n                x += 1\n    if x > 0:\n        accept.append(num)\n\nif len(accept) == 1:\n    print(accept[0])\n    return\n\n#check fst\nfor t in a:\n    z = set()\n    for p in b:\n        if t != p:\n            if t[0] in p: z.add(t[0])\n            if t[1] in p: z.add(t[1])\n    if len(z) > 1:\n        print(-1)\n        return\n\n#check scd\nfor t in b:\n    z = set()\n    for p in a:\n        if t != p:\n            if t[0] in p: z.add(t[0])\n            if t[1] in p: z.add(t[1])\n    if len(z) > 1:\n        print(-1)\n        return\nprint(0)\n        \n\n", "iter=0\nn,m=list(map(int,input().split()))\ntemppair=[0,0]\ni1=list(map(int,input().split()))\ni2=list(map(int,input().split()))\nl1=[]\nl2=[]\nd=0\nfor i in i1:\n    if(d==0):\n        temppair[0]=i\n        d=1\n    else:\n        temppair[1]=i\n        d=0\n        l1.append(sorted(temppair.copy()))\nfor i in i2:\n    if(d==0):\n        temppair[0]=i\n        d=1\n    else:\n        temppair[1]=i\n        d=0\n        l2.append(sorted(temppair.copy()))\ndic1=dict()\ndic2=dict()\nfor i in range(len(l1)):\n    l1[i]=(iter,l1[i])\n    iter+=1\nfor i in range(len(l2)):\n    l2[i]=(iter,l2[i])\n    iter+=1\nfor e in l1:\n    for e1 in l2:\n        if(((e[1][0] in e1[1]) or (e[1][1] in e1[1])) and e[1]!=e1[1]):\n            dic1[e[0]]=dic1.get(e[0],[])+[e1[1]]\nfor e in l2:\n    for e1 in l1:\n        if(((e[1][0] in e1[1]) or (e[1][1] in e1[1])) and e[1]!=e1[1]):\n            dic2[e[0]]=dic2.get(e[0],[])+[e1[1]]\nmybool=True\n# print(dic1)\n# print(dic2)\nfor k,v in list(dic1.items()):\n    k=l1[k][1]\n    mybool=mybool and (all([k[0] in p for p in v]) or all([k[1] in p for p in v]))\nfor k,v in list(dic2.items()):\n    k=k-len(l1)\n    k=l2[k][1]\n    mybool=mybool and (all([k[0] in p for p in v]) or all([k[1] in p for p in v]))\n\nc1=True\ndk1=list(dic1)\ndk1=list([l1[k][1] for k in dk1])\nsameone=dk1[0][0]\nc1=all([sameone in u for u in dk1])\nfor v in list(dic1.values()):\n    c1=c1 and all([sameone in u for u in v])\n\nif not c1:\n    c1=True\n    sameone=dk1[0][1]\n    c1=all([sameone in u for u in dk1])\n    for v in list(dic1.values()):\n        c1=c1 and all([sameone in u for u in v])\n\n\nif(c1):\n    e,e1=list(dic1.items())[0]\n    e=l1[e][1]\n    e1=e1[0]\n    if (e[0] in e1):\n        print(e[0])\n        quit()\n    else:\n        print(e[1])\n        quit()\nelif(mybool):\n    print(0)\n    quit()\nelse:\n    print(-1)\n", "#!/usr/bin/env python3\n\n[n, m] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\nbis = list(map(int, input().strip().split()))\n\nais = [set(ais[2*i: 2*i + 2]) for i in range(n)]\nbis = [set(bis[2*i: 2*i + 2]) for i in range(m)]\n\ndef check(pair, pairs):\n\tres = []\n\tfor p in pairs:\n\t\ts = pair & p\n\t\tif len(s) == 1:\n\t\t\tres.append(s.pop())\n\tres = list(set(res))\n\tif len(res) == 1:\n\t\treturn res[0]\n\telif len(res) > 1:\n\t\treturn -1\n\telse:\n\t\treturn 0\n\n\nva = [check(a, bis) for a in ais]\nvb = [check(b, ais) for b in bis]\n\nvap = [v for v in va if v > 0]\nvbp = [v for v in vb if v > 0]\n\nvap = set(vap)\nvbp = set(vbp)\n\nvabp = vap & vbp\n\nif -1 in va or -1 in vb:\n\tprint(-1)\nelif len(vabp) > 1:\n\tprint(0)\nelse:\n\tprint(vabp.pop())\n\n\n\n\n# Made By Mostafa_Khaled\n", "def rp():\n    cs = list(map(int, input().split(' ')))\n    cs = list(zip(cs[0::2], cs[1::2]))\n    return cs\n\ndef dist(p1, p2):\n    return len(set(p1).union(set(p2))) - 2\n\ninput()\n\nps = [rp(), rp()]\n\ntheyCan = True\nmyPos = set()\n\nfor ps1, ps2 in [ps, ps[::-1]]:\n    for p1 in ps1:\n        pos = set()\n\n        for p2 in ps2:\n            if dist(p1, p2) == 1:\n                pos = pos.union( set(p1).intersection(set(p2)) )\n        \n        if len(pos) >= 2:\n            theyCan = False\n        myPos = myPos.union(pos)\n\nprint(next(iter(myPos)) if len(myPos)==1 else 0 if theyCan else -1)\n", "q=input()\nq1=input().split()\nq2=input().split()\nparr1=[]\nfor i in range(0,len(q1),2):\n    pair=(q1[i],q1[i+1])\n    parr1.append(pair)\nparr2=[]\nfor i in range(0,len(q2),2):\n    pair=(q2[i],q2[i+1])\n    parr2.append(pair)\nmatches1={}\nmatches2={}\nfor i in parr1:\n    for j in parr2:\n        if (i[0]==j[0] and i[1]==j[1]) or (i[0]==j[1] and i[1]==j[0]):\n            continue\n        elif i[0]==j[0] or i[0]==j[1]:\n            if matches1.get(i)==None or matches1.get(i)==i[0]:\n                matches1[i]=i[0]\n            else:\n                print('-1')\n                quit()\n            if matches2.get(j)==None or matches2.get(j)==i[0]:\n                matches2[j]=i[0]\n            else:\n                print('-1')\n                quit()\n        elif i[1]==j[1] or i[1]==j[0]:\n            if matches1.get(i)==None or matches1.get(i)==i[1]:\n                matches1[i]=i[1]\n            else:\n                print('-1')\n                quit()\n            if matches2.get(j)==None or matches2.get(j)==i[1]:\n                matches2[j]=i[1]\n            else:\n                print('-1')\n                quit()\n        else:\n            pass\nmatches=list(matches1.values())\nfor i in range(0,len(matches)):\n    if matches[i]==matches[i-1]:\n        pass\n    else:\n        print('0')\n        quit()\nprint(matches[0])", "q=input()\nq1=input().split()\nq2=input().split()\nparr1=[]\nfor i in range(0,len(q1),2):\n    pair=(q1[i],q1[i+1])\n    parr1.append(pair)\nparr2=[]\nfor i in range(0,len(q2),2):\n    pair=(q2[i],q2[i+1])\n    parr2.append(pair)\nmatches1={}\nmatches2={}\nfor i in parr1:\n    for j in parr2:\n        if (i[0]==j[0] and i[1]==j[1]) or (i[0]==j[1] and i[1]==j[0]):\n            continue\n        elif i[0]==j[0] or i[0]==j[1]:\n            if matches1.get(i)==None or matches1.get(i)==i[0]:\n                matches1[i]=i[0]\n            else:\n                print('-1')\n                quit()\n            if matches2.get(j)==None or matches2.get(j)==i[0]:\n                matches2[j]=i[0]\n            else:\n                print('-1')\n                quit()\n        elif i[1]==j[1] or i[1]==j[0]:\n            if matches1.get(i)==None or matches1.get(i)==i[1]:\n                matches1[i]=i[1]\n            else:\n                print('-1')\n                quit()\n            if matches2.get(j)==None or matches2.get(j)==i[1]:\n                matches2[j]=i[1]\n            else:\n                print('-1')\n                quit()\n        else:\n            pass\nmatches=list(matches1.values())\nfor i in range(0,len(matches)):\n    if matches[i]==matches[i-1]:\n        pass\n    else:\n        print('0')\n        quit()\nprint(matches[0])\n"]
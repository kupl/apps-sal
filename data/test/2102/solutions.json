["from sys import stdin\ninput = stdin.readline\n\na = sorted([int(i) for i in input().split()])\nn = int(input())\nb = sorted([int(i) for i in input().split()])\n\nc = []\nfor i in range(n):\n    c += [[b[i] - a[j], i] for j in range(6)]\nc.sort()\n\nd = [0] * n\ne = 0\n\nans = 10 ** 10\n\nu = 0\nfor i in range(len(c)):\n    while u < len(c) and e < n:\n        x = c[u][1]\n        if d[x] == 0:\n            e += 1\n        d[x] += 1\n        u += 1\n\n    if e == n:\n        ans = min(ans, c[u - 1][0] - c[i][0])\n\n    x = c[i][1]\n    d[x] -= 1\n    if d[x] == 0:\n        e -= 1\n\nprint(ans)\n        \n        \n", "a=list(map(int,input().split()))\nn=int(input())\ns=list(map(int,input().split()))\nb=[]\nfor i in range(n):\n\tfor j in a:\n\t\tb.append((s[i]-j)*n+i)\nb.sort()\ncs={}\ni=j=0\nans=10**18\ndef dd(w):\n\tcs[w]=cs.get(w,0)+1\ndef em(w):\n\tcs[w]-=1\n\tif cs[w]==0:cs.pop(w)\ndd(b[0]%n)\nwhile j<len(b):\n\twhile j+1<len(b) and len(cs)<n:\n\t\tj+=1\n\t\tdd(b[j]%n)\n\twhile len(cs)==n:\n\t\tans=min(ans,b[j]//n-b[i]//n)\n\t\tem(b[i]%n)\n\t\ti+=1\n\tif j+1==len(b):\n\t\tbreak\nprint(ans)", "a=list(map(int,input().split()));n=int(input());s=list(map(int,input().split()));b=[]\nfor i in range(n):\n\tfor j in a:b.append((s[i]-j)*n+i)\nb=sorted(b);cs={};i=j=0;ans=10**18\ncs[b[0]%n]=cs.get(b[0]%n,0)+1;z=len(b)\nwhile j<z:\n\twhile j+1<z and len(cs)<n:j+=1;cs[b[j]%n]=cs.get(b[j]%n,0)+1\n\twhile len(cs)==n:\n\t\tans=min(ans,b[j]//n-b[i]//n)\n\t\tcs[b[i]%n]-=1\n\t\tif cs[b[i]%n]==0:cs.pop(b[i]%n)\n\t\ti+=1\n\tif j+1==z:break\nprint(ans)", "from sys import stdin\ninput = stdin.readline\n\na = sorted([int(i) for i in input().split()])\nn = int(input())\nb = sorted([int(i) for i in input().split()])\n\nc = []\nfor i in range(n):\n    c += [[b[i] - a[j], i] for j in range(6)]\nc.sort()\n\nd = [0] * n\ne = 0\n\nans = 10 ** 10\n\nu = 0\nfor i in range(len(c)):\n    while u < len(c) and e < n:\n        x = c[u][1]\n        if d[x] == 0:\n            e += 1\n        d[x] += 1\n        u += 1\n\n    if e == n:\n        ans = min(ans, c[u - 1][0] - c[i][0])\n\n    x = c[i][1]\n    d[x] -= 1\n    if d[x] == 0:\n        e -= 1\n\nprint(ans)\n        \n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "a=list(map(int,input().split()));n=int(input());s=list(map(int,input().split()));b=[]\nfor i in range(n):\n\tfor j in a:b.append((s[i]-j)*n+i)\nb=sorted(b);i=j=0;ans=10**18;cs=[0]*n;cs[b[0]%n]+=1;nz=1;z=len(b)\nwhile j<z:\n\twhile j+1<z and nz<n:\n\t\tj+=1;cs[b[j]%n]+=1\n\t\tif cs[b[j]%n]==1:nz+=1\n\twhile nz==n:\n\t\tans=min(ans,b[j]//n-b[i]//n)\n\t\tcs[b[i]%n]-=1\n\t\tif cs[b[i]%n]==0:nz-=1\n\t\ti+=1\n\tif j+1==z:break\nprint(ans)", "a=list(map(int,input().split()));n=int(input());s=list(map(int,input().split()));b=[];i=j=0;ans=10**18;cs=[0]*n;nz=1;z=n*6\nfor y in range(n):\n\tfor x in a:b.append((s[y]-x)*n+y)\nb.sort();cs[b[0]%n]+=1\nwhile j<z:\n\twhile j+1<z and nz<n:\n\t\tj+=1;cs[b[j]%n]+=1\n\t\tif cs[b[j]%n]==1:nz+=1\n\twhile nz==n:\n\t\tans=min(ans,b[j]//n-b[i]//n);cs[b[i]%n]-=1\n\t\tif cs[b[i]%n]==0:nz-=1\n\t\ti+=1\n\tif j+1==z:break\nprint(ans)", "a=list(map(int,input().split()));n=int(input());s=list(map(int,input().split()));b=[];i=j=0;ans=10**18;cs=[0]*n;nz=1;z=n*6\nfor y in range(n):\n\tfor x in a:b.append((s[y]-x)*n+y)\nb.sort();cs[b[0]%n]+=1\nwhile j+1<z:\n\twhile j+1<z and nz<n:j+=1;nz+=cs[b[j]%n]<1;cs[b[j]%n]+=1\n\twhile nz==n:ans=min(ans,b[j]//n-b[i]//n);cs[b[i]%n]-=1;nz-=cs[b[i]%n]==0;i+=1\nprint(ans)", "from collections import deque as _deque\nfrom itertools import chain as _chain\nimport sys as _sys\n\n\ndef main():\n    a_seq = tuple(_read_ints())\n    n, = _read_ints()\n    notes = tuple(_read_ints())\n    result = find_minimal_melody_difficulty(a_seq, notes)\n    print(result)\n\n\ndef find_minimal_melody_difficulty(strings_values, notes):\n    strings_values = set(strings_values)\n    strings_values = sorted(strings_values, reverse=True)\n    if len(strings_values) == 1:\n        return max(notes) - min(notes)\n    \n    frets_by_notes_indices = [[note - x for x in strings_values] for note in notes]\n    # frets_by_notes_indices[i_note] is sorted for every correct i_note\n    del strings_values\n    del notes\n    \n    max_from_initially_selected_frets = max(frets[0] for frets in frets_by_notes_indices)\n    for frets in frets_by_notes_indices:\n        i_first_interesting_fret = 0\n        while i_first_interesting_fret + 1 < len(frets) \\\n                and frets[i_first_interesting_fret+1] <= max_from_initially_selected_frets:\n            i_first_interesting_fret += 1\n        frets[:] = frets[i_first_interesting_fret:]\n    \n    selected_frets = [frets[0] for frets in frets_by_notes_indices]\n    selected_frets.sort()\n    selected_frets = _deque(selected_frets)\n    \n    available_selections = _chain.from_iterable(\n        list(zip(frets[1:], frets[0:]))\n        for frets in frets_by_notes_indices\n    )\n    available_selections = sorted(available_selections)\n    \n    # defaultdict(int) is slower\n    frets_to_unselect = dict()\n    for frets in frets_by_notes_indices:\n        for fret in frets:\n            frets_to_unselect[fret] = 0\n    \n    min_selected_fret = selected_frets[0]\n    max_selected_fret = max(selected_frets)\n    result = max_selected_fret - min_selected_fret\n    \n    for new_fret, fret_to_unselect in available_selections:\n        frets_to_unselect[fret_to_unselect] += 1\n        _clean_deque_begin(selected_frets, frets_to_unselect)\n        selected_frets.append(new_fret)\n        \n        min_selected_fret = selected_frets[0]\n        max_selected_fret = new_fret\n        result = min(result, max_selected_fret - min_selected_fret)\n    \n    return result\n\n\ndef _clean_deque_begin(deque, deletions_ns):\n    while deque and deletions_ns[deque[0]] > 0:\n        deleted_element = deque.popleft()\n        deletions_ns[deleted_element] -= 1\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport operator\n\n\n#-----------\n\ndef solve():\n    a = [int(x) for x in input().split()]\n\n    n = int(input())\n\n    b = [int(x) for x in input().split()]\n\n    have = []\n    arr_append = have.append\n    for i in range(0, n):\n        for j in range(0, 6):\n            arr_append([ b[i] - a[j], i ])\n\n    cnt = [0]*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    have.sort(key=operator.itemgetter(0))\n\n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = [int(x) for x in input().split()]\n\n    n = int(input())\n\n    b = [int(x) for x in input().split()]\n\n    have = [ [] ] * (n*6)\n    arr_append = have.append\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append([ b[i] - a[j], i ])\n            have[i*6 + j] = [ b[i] - a[j], i ]\n    \n    cnt = array.array('L', [0])*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    have.sort(key=operator.itemgetter(0))\n\n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    #have = [ [] ] * (n*6)\n    have = []\n    arr_append = have.append\n    for i in range(0, n):\n        for j in range(0, 6):\n            arr_append([ b[i] - a[j], i ])\n            #have[i*6 + j] = [ b[i] - a[j], i ]\n\n    have.sort(key=operator.itemgetter(0))\n\n    cnt = [0]*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "from itertools import chain as _chain\nimport sys as _sys\n\n\ndef main():\n    a_seq = tuple(_read_ints())\n    n, = _read_ints()\n    notes = tuple(_read_ints())\n    result = find_minimal_melody_difficulty(a_seq, notes)\n    print(result)\n\n\ndef find_minimal_melody_difficulty(strings_values, notes):\n    strings_values = set(strings_values)\n    strings_values = sorted(strings_values, reverse=True)\n    if len(strings_values) == 1:\n        return max(notes) - min(notes)\n    \n    frets_by_notes_indices = [[note - x for x in strings_values] for note in notes]\n    # frets_by_notes_indices[i_note] is sorted for every correct i_note\n    del strings_values\n    del notes\n    \n    max_initially_selected_fret = max(frets[0] for frets in frets_by_notes_indices)\n    for frets in frets_by_notes_indices:\n        i_first_interesting_fret = 0\n        while i_first_interesting_fret + 1 < len(frets) \\\n                and frets[i_first_interesting_fret+1] <= max_initially_selected_fret:\n            i_first_interesting_fret += 1\n        frets[:] = frets[i_first_interesting_fret:]\n    \n    sorted_frets = sorted(_chain.from_iterable(frets_by_notes_indices))\n    \n    initially_selected_frets = [frets[0] for frets in frets_by_notes_indices]\n    min_initially_selected = min(initially_selected_frets)\n    i_first_selected = sorted_frets.index(min_initially_selected)\n    while i_first_selected+1 < len(sorted_frets) \\\n            and sorted_frets[i_first_selected+1] == min_initially_selected:\n        i_first_selected += 1\n    i_first_selected -= initially_selected_frets.count(min_initially_selected) - 1\n    i_last_selected = i_first_selected + len(initially_selected_frets) - 1\n    \n    available_selections = _chain.from_iterable(\n        list(zip(frets[1:], frets[0:]))\n        for frets in frets_by_notes_indices\n    )\n    available_selections = sorted(available_selections)\n    \n    # TODO: can replace it with indices_to_unselect\n    # defaultdict(int) is slower\n    frets_to_unselect = dict()\n    for frets in frets_by_notes_indices:\n        for fret in frets:\n            frets_to_unselect[fret] = 0\n    \n    result = sorted_frets[i_last_selected] - sorted_frets[i_first_selected]\n    \n    for new_fret, fret_to_unselect in available_selections:\n        frets_to_unselect[fret_to_unselect] += 1\n        i_first_selected = _shift_index_skipping(sorted_frets, i_first_selected, frets_to_unselect)\n        i_last_selected += 1\n        current_maxmin_difference = sorted_frets[i_last_selected] - sorted_frets[i_first_selected]\n        if current_maxmin_difference < result:\n            result = current_maxmin_difference\n    \n    return result\n\n\ndef _shift_index_skipping(sorted_seq, index, deletions_ns):\n    while index < len(sorted_seq) and deletions_ns[sorted_seq[index]] > 0:\n        deleted_element = sorted_seq[index]\n        index += 1\n        deletions_ns[deleted_element] -= 1\n    return index\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    #have = [ [] ] * (n*6)\n    have = []\n    arr_append = have.append\n    for i in range(0, n):\n        for j in range(0, 6):\n            arr_append(( b[i] - a[j], i ))\n            #have[i*6 + j] = [ b[i] - a[j], i ]\n\n    have.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    have = [ [] ] * (n*6)\n    #have = []\n    arr_append = have.append\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append(( b[i] - a[j], i ))\n            have[i*6 + j] = ( b[i] - a[j], i )\n\n    have.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    have = [ [] ] * (n*6)\n    #have = []\n    arr_append = have.append\n    c=0\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append(( b[i] - a[j], i ))\n            have[c] = ( b[i] - a[j], i )\n            c+=1\n\n    have.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (tuple(map(int, input().split())))\n\n    n = int(input())\n\n    b = (tuple(map(int, input().split())))\n\n    have = [ [] ] * (n*6)\n    #have = []\n    # arr_append = have.append\n    c=0\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append(( b[i] - a[j], i ))\n            have[c] = ( b[i] - a[j], i )\n            c+=1\n\n    have.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    sz = len(have)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, sz):\n        while (r < sz) and (z > 0):\n            cnt[have[r][1]] += 1\n            if (cnt[have[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, have[r - 1][0] - have[i][0]);\n        cnt[have[i][1]] -= 1\n        if (cnt[have[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    lad = [ [] ] * (n*6)\n    #lad = []\n    # arr_append = lad.append\n    c=0\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append(( b[i] - a[j], i ))\n            lad[c] = ( b[i] - a[j], i )\n            c+=1\n\n    lad.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    ladcnt = len(lad)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, ladcnt):\n        while (r < ladcnt) and (z > 0):\n            cnt[lad[r][1]] += 1\n            if (cnt[lad[r][1]] == 1):\n                z-=1\n        \n            r+=1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, lad[r - 1][0] - lad[i][0]);\n        cnt[lad[i][1]] -= 1\n        if (cnt[lad[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "import sys\nimport operator\nimport array\n\n#-----------\n\ndef solve():\n    a = (list(map(int, input().split())))\n\n    n = int(input())\n\n    b = (list(map(int, input().split())))\n\n    lad = [ [] ] * (n*6)\n    #lad = []\n    # arr_append = lad.append\n    c=0\n    for i in range(0, n):\n        for j in range(0, 6):\n            #arr_append(( b[i] - a[j], i ))\n            lad[c] = ( b[i] - a[j], i )\n            c+=1\n\n    lad.sort(key=operator.itemgetter(0))\n\n    cnt = array.array('L', [0])*n\n\n    z = n\n    ladcnt = len(lad)\n    ans = 999999999999\n    r = 0\n    \n    for i in range(0, ladcnt):\n        while (r < ladcnt) and (z > 0):\n            cnt[lad[r][1]] += 1\n            if (cnt[lad[r][1]] == 1):\n                z-=1\n        \n            r += 1\n    \n        if (z > 0):\n           break\n\n        ans = min(ans, lad[r - 1][0] - lad[i][0]);\n        cnt[lad[i][1]] -= 1\n        if (cnt[lad[i][1]] == 0):\n            z+=1\n    \n    print(ans)\n\n\n#-----------\n\ndef main(argv):\n    solve()\n\ndef __starting_point():\n    main(sys.argv)\n\n__starting_point()", "la = input().split()\nla = list(map(int,la))\nt=input()\nlb = input().split()\nlb = list(map(int,lb))\nlenb=len(lb)\nl=[(lb[j]-i,j) for i in la for j in range(lenb)]\nl.sort()\nlast=0\nfirst=0\n\nl0=[0]*lenb\nl1=[i for i in range(lenb)]\ndic=dict(list(zip(l1,l0)))\ndic[l[first][1]]+=1\nlength=1\nlenl=len(l)\nwhile (length<lenb):\n    last+=1\n    if dic[l[last][1]]==0:\n        length+=1\n    dic[l[last][1]]+=1\n\nminnum=l[last][0]-l[first][0]\nt=0\nwhile (1):\n    dic[l[first][1]] -= 1\n    while dic[l[first][1]]!=0:\n\n        first += 1\n        dic[l[first][1]]-=1\n\n        if minnum > l[last][0] - l[first][0]:\n            minnum = l[last][0] - l[first][0]\n        if first == last:\n            break\n    first+=1\n    last+=1\n    if last>=lenl:\n        break\n    while dic[l[last][1]]!=0:\n        dic[l[last][1]] += 1\n        last=last+1\n        if last >= lenl:\n            break\n\n    if last>=lenl:\n        break\n    dic[l[last][1]] += 1\n\n    if minnum>l[last][0]-l[first][0]:\n        minnum = l[last][0] - l[first][0]\n    if minnum==0:\n        break\n\n\n\nprint(minnum)\n\n\n\n\n\n"]
["\n\nn = int(input())\n\nT = [int(x) for x in input().split()]\n\nC = [int(x) for x in input().split()]\n\nT_inv = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    T_inv[T[i] - 1] += [i + 1]\n\nresult = 1\n\n#for i in range(n):\n#    print(T_inv[i])\n\nfor i in range(n):\n    for child in T_inv[i]:\n        if C[i] != C[child]:\n            result += 1\n\nprint(result)\n", "n = int(input())\nes = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i, e in enumerate(es):\n    g[i+1].append(e-1)\n    g[e-1].append(i+1)\ncols = list(map(int, input().split()))\nans = 0\nq = [[0, 0]]\nvis = set([0])\nwhile len(q) > 0:\n    v, c = q[0][0], q[0][1]\n    del q[0]\n    nc = cols[v]\n    if nc != c:\n        ans += 1\n    for u in g[v]:\n        if u not in vis:\n            vis.add(u)\n            q.append([u, nc])\nprint(ans)", "import sys\nsys.setrecursionlimit(1000000)\nread = sys.stdin.readline\n\nn = int(read())\nparent = [1] + list(map(int, read().split()))\ncolor = list(map(int, read().split()))\nunderVertex = [[] for _ in range(n+1)]\n\nfor i, p in enumerate(parent):\n\tif i+1 != p:\n\t\tunderVertex[p] += [i+1]\n\n\ndef dfs(idx, c):\n\tcount = 0\n\tif c != color[idx-1]:\n\t\tcount = 1\n\tfor nxt in underVertex[idx]:\n\t\tcount += dfs(nxt, color[idx-1])\n\treturn count\n\nprint(dfs(1, 0))", "n = int(input())\n\nchildren = [[] for _ in range(n)]\nps = [int(v) for v in input().split()]\n\nfor i, p in enumerate(ps, 1):\n    children[p - 1].append(i)\n\ncs = [int(v) for v in input().split()]\n\nans = 0\n\n# vertex, color\nstack = [(0, 0)]\nwhile stack:\n    v, c = stack.pop()\n    if c != cs[v]:\n        ans += 1\n        c = cs[v]\n    for child in children[v]:\n        stack.append((child, c))\n\nprint(ans)\n", "def bfs(endcolor):\n    color=[0]*(n+1)\n    endcolor=[0]+endcolor\n    count=0\n    visited, queue = set(), [1]\n    while queue:\n        #print(color,queue,count)\n        vertex = queue.pop(0)\n        if endcolor[vertex] != color[vertex]:\n            color[vertex]=endcolor[vertex]\n            count+=1\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(g[vertex] - visited)\n            for x in g[vertex] - visited:\n                color[x]=color[vertex]\n    return count\nn=int(input())\ng={x:set() for x in range(1,n+2)}\ni=1\nfor x in map(int,input().split()):\n    i+=1\n    g[x].add(i)\n    #g[i].add(x)\n#print(g)\nprint(bfs(list(map(int,input().split()))))", "n = int(input())\np = [0] + list(map(int, input().split()))\nc = [0] + list(map(int, input().split()))\nres = 1\nmp = {i:[] for i in range(1, n + 1)}\nfor i in range(1, len(p)):\n\tmp[p[i]].append(i + 1)\ncol = {i:0 for i in range(1, n + 1)}\nq = [1]\nwhile q != []:\n\tcur = q.pop(0)\n\tfor i in mp[cur]:\n\t\tq.append(i)\n\tif cur == 1:\n\t\tcol[cur] = c[cur]\n\telse:\n\t\tcol[cur] = col[p[cur - 1]]\n\t\tif col[cur] != c[cur]:\n\t\t\tcol[cur] = c[cur]\n\t\t\tres += 1\nprint(res)", "from collections import deque\n\nn = int(input())\nadj = [[] for i in range(n + 1)]\nfor i, x in enumerate(input().split()):\n    i += 2\n    x = int(x)\n    adj[i].append(x)\n    adj[x].append(i)\n\nparents = [0 for i in range(n + 1)]\nparents[1] = -1\n\n# print(adj)\n\ncolors = [-1] + [int(x) for x in input().split()]\n\nq = deque([1])\nwhile len(q) > 0:\n    node = q.popleft()\n    for x in adj[node]:\n        if parents[x] == 0:\n            parents[x] = node\n            q.append(x)\n\n# print(parents)\n\nans = 1\n\nfor i in range(2, n + 1):\n    if colors[i] != colors[parents[i]]:\n        ans += 1\n\nprint(ans)", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nans = 1\nfor i in range(n - 1):\n    if b[i+1] != b[a[i]-1]:\n        ans += 1\nprint(ans)", "n = int(input())\n\np = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\nans = 1;\nind = 1\n\nfor i in p:\n    if c[i-1]!=c[ind]:\n        ans+=1;\n    ind+=1 \n    \nprint(ans)", "n = int(input().strip())\np = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nmoves = 1\nfor i in range(1,n):\n    if c[p[i-1]-1]!=c[i]:\n        moves+=1\nprint(moves)", "n=int(input())\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\n\n\nnbr=1\nfor i in range(1,n):\n    if c[i]!=c[p[i-1]-1]:\n        nbr+=1\n\nprint(nbr)\n\n    \n    \n    \n", "from collections import defaultdict as di\nfrom collections import deque as dq\nn=int(input())\ncoupl = di(list)\nnodess = [int(x)-1 for x in input().split()]\nfor i in range(n-1):\n    node = nodess[i]\n    coupl[i+1].append(node)\n    coupl[node].append(i+1)\n\ncolors = [int(x)-1 for x in input().split()]\n\nQ=dq()\nfound=set()\nQ.append((0,0))\nparent = [-1]*n\norder = []\nwhile Q:\n    node,p = Q.popleft()\n    if node in found:\n        continue\n    found.add(node)\n    parent[node]=p\n    order.append(node)\n    for nei in coupl[node]:\n        Q.append((nei,node))\n\ncolor = [-1]*n\ncount = 0\nfor node in order:\n    if colors[node]==color[parent[node]]:\n        pass\n    else:\n        count+=1\n    color[node]=colors[node]\n\nprint(count)\n", "n=int(input())\nl=[0]\ns=0\nl.extend([int(i)-1 for i in input().split()])\nm=[int(i) for i in input().split()]\ncv=[0]*n\nif m[0]!=0:\n    cv[0]=m[0]\n    s+=1\nfor i in range(n):\n    if m[i]!=cv[l[i]]:\n        cv[i]=m[i]\n        s+=1\n    else:\n        cv[i]=cv[l[i]]  \nprint(s)", "n = int(input())\nP = [0]+list(map(lambda c:int(c)-1,input().split()))\nC = list(map(int,input().split()))\n\ncnt = sum(C[i]==C[p] for i,p in enumerate(P))\n\nprint(n-cnt+1)", "N = int(input())\ncon = [0]\nvert = [i for i in range(1,N+1)]\na = input().split(\" \")\nfor i in range(N-1):\n    con.append(int(a[i])-1)\ncolor=[]\na = input().split(\" \")\nfor i in range(N):\n    color.append(int(a[i]))\ncur = [color[0] for i in range(N)]\nsteps=1\nfor i in range(1,N):\n    if cur[con[i]]==color[i]:\n        cur[i] = color[i]\n    else:\n        steps+=1\n        cur[i] = color[i]\nprint(steps)\n#print(con)\n#print(color)\n#print(vert)\n", "n = int(input())\n\n\ne = [int(i)-1 for i in input().split()]\nv = [int(i) for i in input().split()]\ncounter = 1\n\nfor i in range(n-1):\n    if v[e[i]] != v[i+1]:\n        counter+=1\n        \nprint(counter)", "n = int(input())\ns = input()\nss = input()\ntree = [[1]]\np = list(map(int, s.split()))\nq = list(map(int, ss.split()))\nfor i in range(0, n-1):\n    tree.append([i+2])\n    tree[p[i]-1].append(i+2)\ncount = 0\nfor each in tree:\n    if len(each) == 1:\n        tree.remove(each)\n        count += 1\ntree.sort(key=len)\nfor each in tree:\n    sub = list(map(lambda x:q[x-1], each[1:]))\n    count += (1-sub.count(q[each[0]-1]))\nprint(count)", "n = int(input())\np = list(map(int,input().split()))\nc = list(map(int,input().split()))\nk = 1\nfor i in range(n-1):\n    if c[i+1] != c[p[i]-1]:\n        k+= 1\nprint(k)", "def pst(root, curr):\n    nonlocal times\n    if cs[root-1] != curr:\n        times += 1\n    curr = cs[root-1]\n    if root not in vss:\n        return\n    chn = vss[root]\n    for ch in chn:\n        pst(ch, curr)\n\n\nn = int(input())\nvs = [int(x) for x in input().split()]\n\ncs = [int(x) for x in input().split()]\n\n\n\n# vss = set()\n# for i in range(2, n + 1):\n#     vss.add((vs[i - 2], i))\n#\n# vsbp = {v[0]: v for v in vss}\nvss = {}\nfor c, p in enumerate(vs):\n    if not p in vss:\n        vss[p] = [c+2]\n    else:\n        vss[p].append(c+2)\n\ntimes = 0\n\ndef flattened():\n    times = 0\n    root = 1\n    curr = 0\n\n    firstpart = True\n\n    stack = []\n    while True:\n\n\n        if firstpart:\n\n            if cs[root-1] != curr:\n                times += 1\n            curr = cs[root - 1]\n            if root not in vss:\n                firstpart = False\n                if len(stack) == 0:\n                    print(times)\n                    return\n                chni, curr = stack.pop()\n            else:\n                chn = vss[root]\n                chni = iter(chn)\n\n        try:\n            ch = next(chni)\n            firstpart = True\n            root = ch\n            stack.append((chni, curr))\n        except StopIteration:\n            firstpart = False\n            if len(stack) == 0:\n                print(times)\n                return\n            chni, curr = stack.pop()\n\n\n\n        # if root in vss:\n        #     chn = vss[root]\n        #     chni = iter(chn)\n        #     stack.append((curr, chni))\n        # else:\n        #     if len(stack) == 0:\n        #         print(times)\n        #         return\n\n\n# pst(1, 0)\n# print(times)\n\nflattened()", "\ndef main():\n\tn = int(input())\n\tparents = [int(x)-1 for x in input().strip().split()]\n\tcolors = [int(x) for x in input().strip().split()]\n\t\n\tans = 1\n\n\tfor i in range(n-1):\n\t\tc = i+1\n\t\tp = parents[i]\n\t\tif (colors[c] != colors[p]):\n\t\t\tans += 1\n\n\tprint(ans)\n\t\ndef __starting_point():\n\tmain()\n__starting_point()", "n = int(input())\nmps = list(map(int,input().split()))\ncol = list(map(int,input().split()))\nst = 2\npar = dict()\nfor i in range(n-1):\n\tpar[st] = par.get(st,[])\n\tpar[st].append(mps[i])\n\tpar[mps[i]] = par.get(mps[i],[])\n\tpar[mps[i]].append(st)\n\tst+=1\n\nqueue = [1]\nvis = [0]*(n+1)\nans = 1\nwhile len(queue):\n\ts = queue.pop(0)\n\tvis[s] = 1\n\tfor i in par[s]:\n\t\tif not vis[i]:\n\t\t\tqueue.append(i)\n\t\t\tvis[i] = 1\n\t\t\tif col[i-1]!=col[s-1]:\n\t\t\t\tans+=1\n\nprint(ans)", "n = int(input())\ngraph = [[] for i in range(n)]\nl = list(map(int, input().split(\" \")))\nfor i in range(n-1):\n    graph[i+1] += [l[i]-1]\n    graph[l[i]-1] += [i+1]\ncc = list(map(int, input().split(\" \")))\n# for i in range(n):\n#     print (graph[i])\nll = list(range(n))\ncolors = [0 for i in range(n)]\ncounter = 0\nvisited = [False for i in range(n)]\nans = 0\ncounter = 0\nq = [i]\nvisited[i] = True\nwhile(len(q) != 0):\n    u = q[0]\n    # print (\"u: \", u)\n    q.pop(0)\n    for j in graph[u]:\n        # print (j)\n        if (visited[j]):\n            continue\n        if(cc[j] != cc[u]):\n            counter+=1\n        visited[j] = True\n        q += [j]\nprint(counter+1)\n", "import sys\n\nlines = []\nfor line in sys.stdin:\n    lines.append(line.rstrip(\"\\r\\n\\t \"))\nn = int(lines[0])\ndata = lines[1].split(' ')\ntree = [0]\nfor x in data:\n    tree.append(int(x))\ndata = lines[2].split(' ')\ncolors = [int(data[0])]\noperations = 1\nfor i in range(n):\n    if i > 0:\n        color = int(data[i])\n        parent = tree[i]\n        if colors[parent - 1] != color:\n            operations += 1\n        colors.append(color)\nprint(operations)\n", "n=int(input())\npi=list(map(int,input().split()))\nci=list(map(int,input().split()))\ncom=1\nfor i in range(1,n):\n      if ci[i]!=ci[pi[i-1]-1]:\n            com+=1\nprint(com)"]
["#!/usr/bin/env python3\nimport sys\nimport bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nn, m = map(int, input().split())\nseen = set()\nab = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ab.append((a, b))\n    seen.add(a)\nab.sort()\n\ndecomp = list(seen)\ndecomp.sort()\nnode_num = len(decomp)\ncomp = dict()\nfor i, item in enumerate(decomp):\n    comp[item] = i\n\n# Take diff\nd = [0] * (node_num + 1)\nprev = 0\nfor a, b in ab:\n    if b != prev:\n        d[comp[a]] = 1\n    prev = b\nif prev != 0:\n    d[node_num] = 1\n\nswitch_dict = dict()\nlr = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    lft = bisect.bisect_left(decomp, l)\n    rgt = bisect.bisect_right(decomp, r)\n    if lft != rgt:\n        lr.append((lft, rgt))\n        switch_dict[(lft, rgt)] = i + 1\n\nedge = [[] for _ in range(node_num + 1)]\nfor l, r in lr:\n    edge[l].append(r)\n    edge[r].append(l)\n\nvisited = [0] * (node_num + 1)\nans = []\ndef dfs(p, v):\n    ret = d[v]\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        if not visited[nv]:\n            visited[nv] = 1\n            val = dfs(v, nv)\n            if val == 1:\n                if v < nv:\n                    ans.append(switch_dict[(v, nv)])\n                else:\n                    ans.append(switch_dict[(nv, v)])\n                ret += 1\n    return ret % 2\n\nfor i in range(node_num + 1):\n    if visited[i]:\n        continue\n    visited[i] = 1\n    ret = dfs(-1, i)\n    # Check last node is ok or not\n    if ret == 1:\n        print(-1)\n        return\n\n# Check trees cover all 1 or not\nfor c, is_visited in zip(d, visited):\n    if not is_visited and c:\n        print(-1)\n        return\n\nans.sort()\nprint(len(ans))\nprint(*ans)", "def main():\n    import sys\n    input = sys.stdin.readline\n    from bisect import bisect_left, bisect_right\n    sys.setrecursionlimit(10**9)\n\n    N, M = map(int, input().split())\n    AB = []\n    for i in [0]*N:\n        A, B = map(int, input().split())\n        AB.append((A, B))\n    AB.sort(key=lambda x:x[0])\n\n    POWER = 1\n    x = [0] * (N+1)\n    x[0] = AB[0][POWER]\n    for i in range(N-1):\n        x[i+1] = AB[i][POWER] ^ AB[i+1][POWER]\n    x[N] = AB[N-1][POWER]\n\n    graph = [ [] for _ in [0]*(N+1) ]\n    for i in range(1, M+1):\n        L, R = map(int, input().split())\n        L = bisect_left(AB, (L, 0))\n        R = bisect_right(AB, (R, 1))\n        graph[L].append((R, i))\n        graph[R].append((L, i))\n\n    ans = []\n    POS = 0\n    ID = 1\n    def dfs(v):\n        used[v] = True\n        res = x[v]\n        for edge in graph[v]:\n            if used[edge[POS]]: continue\n            r = dfs(edge[POS])\n            if r: ans.append(edge[ID])\n            res ^= r\n        return res\n\n    used = [False] * (N+1)\n    for i in range(N+1):\n        if used[i]: continue\n        if dfs(i):\n            print(-1)\n            return\n\n    print(len(ans))\n    ans.sort()\n    print(*ans)\n\n\nmain()", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nfrom bisect import bisect_left, bisect_right\ndef resolve():\n    n, m = map(int, input().split())\n    AB = [list(map(int, input().split())) for _ in range(n)]\n    AB.sort()\n    AB.append([INF, 0])\n    for i in range(n, 0, -1):\n        AB[i][1] ^= AB[i - 1][1]\n\n    E = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        l = bisect_left(AB, [u, 0])\n        r = bisect_right(AB, [v, 1])\n        E[l].append((r, i + 1))\n        E[r].append((l, i + 1))\n\n    ans = []\n    used = [False] * (n + 1)\n    def dfs(v):\n        used[v] = True\n        res = AB[v][1]\n        for nv, i in E[v]:\n            if used[nv]:\n                continue\n            r = dfs(nv)\n            if r:\n                ans.append(i)\n            res ^= r\n        return res\n\n    for v in range(n + 1):\n        if used[v]:\n            continue\n        if dfs(v):\n            print(-1)\n            return\n\n    print(len(ans))\n    if ans:\n        print(*sorted(ans))\nresolve()", "from bisect import bisect_left, bisect_right\n\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.data = [-1] * size\n    def find(self, x):\n        if self.data[x] < 0:\n            return x\n        else:\n            self.data[x] = self.find(self.data[x])\n            return self.data[x]\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.data[y] < self.data[x]:\n                x, y = y, x\n            self.data[x] += self.data[y]\n            self.data[y] = x\n        return (x != y)\n    def same(self, x, y):\n        return (self.find(x) == self.find(y))\n    def size(self, x):\n        return -self.data[self.find(x)]\n\n\n\nN, M, *I = map(int, open(0).read().split())\nAB, LR = I[:2 * N], I[2 * N:]\n\nA, B = map(list, zip(*sorted(zip(*[iter(AB)] * 2))))\nD = [B[0]] + [l ^ r for l, r in zip(B, B[1:])] + [B[-1]]\nE = [set() for _ in range(N + 1)]\n\nuf = UnionFind(N + 1)\nfor i, (l, r) in enumerate(zip(*[iter(LR)] * 2), 1):\n    li = bisect_left(A, l)\n    ri = bisect_right(A, r)\n    if li == ri or uf.same(li, ri):\n        continue\n\n    uf.union(li, ri)\n    E[li].add((ri, i))\n    E[ri].add((li, i))\n\n\nused = set()\ndef dfs(v, p):\n    res = D[v]\n    for u, c in E[v]:\n        if u == p:\n            continue\n        ret = dfs(u, v)\n        if ret == 1:\n            used.add(c)\n        D[u] = 0\n        res ^= ret\n    return res\n\nfor v in range(N + 1):\n    if D[v]:\n        D[v] = dfs(v, -1)\n\nif sum(D) == 0:\n    print(len(used))\n    print(*sorted(used))\nelse:\n    print(-1)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nimport bisect\n\nn, m = map(int, input().split())\nseen = set()\nab = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ab.append((a, b))\n    seen.add(a)\nab.sort()\n\nseen_list = list(seen)\nseen_list.sort()\ncomp = dict()\ncomp_inv = dict()\nfor i, item in enumerate(seen_list):\n    comp[item] = i\n    comp_inv[i] = item\nnode_num = len(comp)\n\nd = [0] * (node_num + 1)\nprev = 0\nfor a, b in ab:\n    if b != prev:\n        d[comp[a]] = 1\n    prev = b\nif prev != 0:\n    d[node_num] = 1\n# print(\"d\", d)\n\nswitch_dict = dict()\nlr = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    lft = bisect.bisect_left(seen_list, l)\n    rgt = bisect.bisect_right(seen_list, r)\n    if lft != rgt:\n        lr.append((lft, rgt))\n        switch_dict[(lft, rgt)] = i + 1\n# print(\"lr\", lr)\n\nedge = [[] for _ in range(node_num + 1)]\nfor l, r in lr:\n    edge[l].append(r)\n    edge[r].append(l)\n# print(\"edge\", edge)\n\nvisited = [0] * (node_num + 1)\nans = []\ndef dfs(p, v):\n    ret = d[v]\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        if not visited[nv]:\n            visited[nv] = 1\n            val = dfs(v, nv)\n            if val == 1:\n                if v < nv:\n                    ans.append(switch_dict[(v, nv)])\n                else:\n                    ans.append(switch_dict[(nv, v)])\n                ret += 1\n    return ret % 2\n\nfor i in range(node_num + 1):\n    if visited[i]:\n        continue\n    visited[i] = 1\n    ret = dfs(-1, i)\n    # Check last node is ok or not\n    if ret == 1:\n        print(-1)\n        return\n\n# Check trees cover all 1 or not\nfor c, is_visited in zip(d, visited):\n    if not is_visited and c:\n        print(-1)\n        return\n\nans.sort()\nprint(len(ans))\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nfrom bisect import bisect_left, bisect_right\n\nN, M = map(int, input().split())\nAB = [[0, 0]] + [[int(i) for i in input().split()] for _ in range(N)] + [[1 << 40, 0]]\nLR = [[int(i) for i in input().split()] for _ in range(M)]\n\nN += 2\n\n# \u5ea7\u5727\ncompressed = sorted([a for a, b in AB])\nbomb = [0] * N\nfor a, b in AB :\n  a = bisect_left(compressed, a)\n  bomb[a] = b\ndiff = [bomb[i-1] ^ bomb[i] for i in range(1, N)]\n\n# \u8fba\u3092\u8cbc\u308b\nvec = [[] for _ in range(N)]\nconvert = {}\nfor i, (l, r) in enumerate(LR) :\n  if compressed[-1] < l or r < compressed[0] : continue\n  l = bisect_left(compressed, l) - 1\n  r = bisect_right(compressed, r) - 1\n  if r <= l : continue\n  vec[l].append(r)\n  vec[r].append(l)\n  convert[(l, r)] = i\n\n# \u5168\u57df\u6728\u306e\u69cb\u7bc9\nvisited = [False] * N\nparent = [-1] * N\nret = []\ndef dfs(pre, cur) :\n  for nex in vec[cur] :\n    if nex == pre or visited[nex] :\n      continue\n    visited[nex] = True\n    dfs(cur, nex)\n  if pre == -1 and diff[cur] == 1 :\n    return False\n  if diff[cur] == 1 :\n    diff[cur] ^= 1\n    diff[pre] ^= 1\n    ret.append(convert[(min(pre, cur), max(pre, cur))] + 1)\n  return True\n\nfor i in range(N - 1) :\n  if visited[i] : continue\n  visited[i] = True\n  if not dfs(-1, i) :\n    print(-1)\n    break\nelse :\n  ret.sort()\n  print(len(ret))\n  print(*ret)", "from bisect import bisect_left, bisect_right\n\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.data = [-1] * size\n    def find(self, x):\n        if self.data[x] < 0:\n            return x\n        else:\n            self.data[x] = self.find(self.data[x])\n            return self.data[x]\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.data[y] < self.data[x]:\n                x, y = y, x\n            self.data[x] += self.data[y]\n            self.data[y] = x\n        return (x != y)\n    def same(self, x, y):\n        return (self.find(x) == self.find(y))\n    def size(self, x):\n        return -self.data[self.find(x)]\n\n\n\nN, M, *I = map(int, open(0).read().split())\nAB, LR = I[:2 * N], I[2 * N:]\n\nA, B = map(list, zip(*sorted(zip(*[iter(AB)] * 2))))\nD = [l ^ r for l, r in zip([0] + B, B + [0])]\nE = [set() for _ in range(N + 1)]\n\nuf = UnionFind(N + 1)\nfor i, (l, r) in enumerate(zip(*[iter(LR)] * 2), 1):\n    li = bisect_left(A, l)\n    ri = bisect_right(A, r)\n    if li == ri or uf.same(li, ri):\n        continue\n\n    uf.union(li, ri)\n    E[li].add((ri, i))\n    E[ri].add((li, i))\n\n\nused = set()\ndef dfs(v, p):\n    res = D[v]\n    for u, c in E[v]:\n        if u == p:\n            continue\n        ret = dfs(u, v)\n        if ret == 1:\n            used.add(c)\n        D[u] = 0\n        res ^= ret\n    return res\n\nfor v in range(N + 1):\n    if D[v]:\n        D[v] = dfs(v, -1)\n\nif all(d == 0 for d in D):\n    print(len(used))\n    print(*sorted(used))\nelse:\n    print(-1)"]
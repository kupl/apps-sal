["n = int(input())\na = list(map(int, input().split()))\n\np = list(range(n + 1))\ns = [set() for i in range(n + 1)]\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y, cur):\n    x, y = find(x), find(y)\n    r = 0\n    if len(s[x]) < len(s[y]):\n        x, y = y, x\n    for k in s[y]:\n        r += cur - k in s[x]\n    s[x] |= s[y]\n    s[x].add(cur)\n    p[y] = x\n    return r\n\nprint(sum(union(i, i + 1, a[i]) for i in sorted(range(n), key=lambda i: a[i])))", "n=int(input())\nns=[int(x) for x in input().split()]\n# n=200000\n# ns=[x+1 for x in range(n)]\n\n\"\"\"\nst=[[ns[i]]for i in range(n)]\nfor l in range(1,20):\n    for i in range(0,n+10,2**l):\n        if i+2**(l-1)<len(st):\n            st[i].append(max(st[i][-1],st[i+2**(l-1)][-1]))\ndef get_sum(l,r):\n    ans,i=st[l][0],1\n    while l+2**i<=r and i<len(st[l]):\n        ans=st[l][i]\n        i+=1\n    rr=l+2**(i-1)-1\n    if rr>=r:\n        return ans\n    else:\n        return max(ans,get_sum(rr+1,r))\n\"\"\"\n# print(time.time()-tm)\n# import random as rd\n#\n# n=10000\n# s=set()\n# ns=[]\n# for i in range(n):\n#     s.add(i+1)\n# for i in range(n):\n#     x=rd.sample(s,1)\n#     ns.append(x[0])\n#     s.remove(x[0])\n# print(ns)\n# quit()\n# ns=[5, 8, 4, 1, 6, 7, 2, 3]\n# n=len(ns)\n\nmaxx=max(ns)+10\nlst=[None]*n\nnxt=[None]*n\ntmp=[(-1,maxx)]\nmp=[False]*n\nwh=[None]*(n+1)\nfor i in range(n):\n    c=ns[i]\n    while tmp[-1][1]<=c:\n        tmp.pop()\n    lst[i]=tmp[-1][0]\n    tmp.append((i,c))\ntmp=[(n,maxx)]\nfor i in range(n):\n    i=n-i-1\n    c=ns[i]\n    while tmp[-1][1]<=c:\n        tmp.pop()\n    nxt[i]=tmp[-1][0]\n    tmp.append((i,c))\nlm={}\nfor i in range(n):\n    lm[(lst[i]+1,nxt[i]-1)]=ns[i]\n# print(lm)\n\n\nfor i in range(n):\n    wh[ns[i]]=i\n\ndef check(i,m,lm):\n    f=ns[m]-ns[i]\n    f=wh[f]\n    if lm[0]<=f<=lm[1]:\n        return True\n    return False\n# print(wh)\nans=0\nrec=[(0,n-1)]\n\ndef get():\n    if len(rec)==0:\n        return False\n    l,r=rec.pop()\n    if r-l+1<=2:\n        return True\n    nonlocal ans\n    x=lm[(l,r)]\n    lc=wh[x]\n    if lc<(l+r)//2:\n        for i in range(l,lc):\n            c=ns[i]\n            c=ns[lc]-c\n            c=wh[c]\n            if lc<=c<=r:\n                ans+=1\n    else:\n        for i in range(lc+1,r+1):\n            c=ns[i]\n            c=ns[lc]-c\n            c=wh[c]\n            if l<=c<=lc:\n                ans+=1\n    rec.append((l,lc-1))\n    rec.append((lc+1,r))\nwhile len(rec)>0:\n    get()\nprint(ans)\nquit()\n\n\n\n\nget(0,n-1)\nprint(ans)\nquit()\n\n\nx=n\nwhile x>=1:\n    lc=wh[x]\n    mp[lc]=True\n    l,r=lc-1,lc+1\n    while l>lst[lc] and (not mp[l]) :\n        l-=1\n    while r<nxt[lc] and (not mp[r]):\n        r+=1\n    if lc-l<r-lc:\n        for i in range(l+1,lc):\n            if check(i,lc,(lc+1,r-1)):\n                ans+=1\n    else:\n        for i in range(lc+1,r):\n            if check(i,lc,(l+1,lc-1)):\n                ans+=1\n    x-=1\nprint(ans)\n#\n# # print(lst)\n# # print(nxt)\n#\n# def std(n,ns):\n#     ans=0\n#     for i in range(n):\n#         for j in range(i,n):\n#             if max(ns[i:j+1])==ns[i]+ns[j]:\n#                 ans+=1\n#     return ans\n# print(ns)\n# print(std(n,ns))\n#\n# if ans==std(n,ns):\n#     print('True')\n# else:\n#     print('False')\n", "def Count_Segment(a,n):\n\tans=0\n\tupto=[False]*(n+1)\n\tfor i in range(1,n-1):\n\t\tif a[i]>a[i-1] and a[i]>a[i+1]:\n\t\t\tcurr=a[i]\n\t\t\tj=i-1\n\t\t\twhile j>=0 and a[j]<curr:\n\t\t\t\tupto[a[j]]=curr\n\t\t\t\tj-=1\n\n\t\t\tj=i+1\n\t\t\twhile j<n and a[j]<curr:\n\t\t\t\tif upto[curr-a[j]]==curr:\n\t\t\t\t\tans+=1\n\t\t\t\tj+=1\n\n\treturn ans\n\nn=int(input())\na=list(map(int,input().split( )))\nprint(Count_Segment(a,n))\n", "from collections import deque\nfrom sys import stdin\n\ndef inv(perm):\n\tinvp = [None] * len(perm)\n\tfor i, p in enumerate(perm):\n\t\tinvp[p] = i\n\treturn invp\n\ndef main():\n\tn = int(stdin.readline())\n\tp = [int(x) - 1 for x in stdin.readline().split()]\n\tinvp = inv(p)\n\n\t# Build auxiliary arrays\n\tnexL = [None] * n\n\tnexR = [None] * n\n\tq = deque()\n\tfor i in range(0, n):\n\t\twhile q and p[q[-1]] <= p[i]: \n\t\t\tq.pop()\n\t\tnexL[i] = -1 if not q else q[-1]\n\t\tq.append(i)\n\tq.clear()\n\tfor i in range(n - 1, -1, -1):\n\t\twhile q and p[q[-1]] <= p[i]:\n\t\t\tq.pop()\n\t\tnexR[i] = n if not q else q[-1]\n\t\tq.append(i)\n\n\t# Solve\n\tres = 0\n\tfor i in range(0, n):\n\t\tif i - nexL[i] < nexR[i] - i:\n\t\t\tfor j in range(nexL[i] + 1, i):\n\t\t\t\tx = p[i] - p[j] - 1\n\t\t\t\tres += int(x >= 0 and i < invp[x] <= nexR[i])\n\t\telse:\n\t\t\tfor j in range(i + 1, nexR[i]):\n\t\t\t\tx = p[i] - p[j] - 1\n\t\t\t\tres += int(x >= 0 and nexL[i] <= invp[x] < i)\n\tprint(res)\n\nmain()", "from collections import deque\nfrom sys import stdin\n\ndef inv(perm):\n\tinvp = [None] * len(perm)\n\tfor i, p in enumerate(perm):\n\t\tinvp[p] = i\n\treturn invp\n\ndef main():\n\tn = int(stdin.readline())\n\tp = [int(x) - 1 for x in stdin.readline().split()]\n\tinvp = inv(p)\n\n\t# Build auxiliary arrays\n\tnexL = [None] * n\n\tnexR = [None] * n\n\tq = deque()\n\tfor i in range(0, n):\n\t\twhile q and p[q[-1]] <= p[i]: \n\t\t\tq.pop()\n\t\tnexL[i] = -1 if not q else q[-1]\n\t\tq.append(i)\n\tq.clear()\n\tfor i in range(n - 1, -1, -1):\n\t\twhile q and p[q[-1]] <= p[i]:\n\t\t\tq.pop()\n\t\tnexR[i] = n if not q else q[-1]\n\t\tq.append(i)\n\n\t# Solve\n\tres = 0\n\tfor i in range(0, n):\n\t\tif i - nexL[i] < nexR[i] - i:\n\t\t\tfor j in range(nexL[i] + 1, i):\n\t\t\t\tx = p[i] - p[j] - 1\n\t\t\t\tres += int(x >= 0 and i < invp[x] <= nexR[i])\n\t\telse:\n\t\t\tfor j in range(i + 1, nexR[i]):\n\t\t\t\tx = p[i] - p[j] - 1\n\t\t\t\tres += int(x >= 0 and nexL[i] <= invp[x] < i)\n\tprint(res)\n\nmain()", "# ez\nimport math\npown = 1\nind = []\nf = []\npw = []\n \ndef get(l,r):\n    x = pw[r - l + 1]\n    if f[r][x] > f[l+p2[x]-1][x]:\n        return f[r][x]\n    return f[l + p2[x] - 1][x]\n\ndef solve(x,y):\n    if y <= x:\n        return 0\n    p = get(x,y)\n    if y - p[1] <= p[1] - x:\n        cur = 0\n        for i in range(p[1] , y + 1):\n            if ind[p[0] - a[i]] >= x and ind[p[0] - a[i]] <= p[1]:\n                cur = cur + 1\n        return cur + solve(x , p[1] - 1) + solve(p[1] + 1 , y)\n    else:\n        cur = 0\n        for i in range(x , p[1] + 1):\n            if ind[p[0] - a[i]] >= p[1] and ind[p[0] - a[i]] <= y:\n                cur = cur + 1\n        return cur + solve(x , p[1] - 1) + solve(p[1] + 1 , y)\n\nn = int(input())\n \nfor i in range(0 , 200005):\n    pw.append(0)\np2 = []\np2.append(1)\nfor i in range(1,20):\n    p2.append(p2[i - 1] * 2)\nfor i in range(0,18):\n    for j in range(p2[i] , p2[i + 1]):\n        if j <= 200000:\n            pw[j] = i\n \narr = [int(i) for i in input().split()]\na = []\na.append(0)\nfor i in range(0 , n):\n    a.append(arr[i])\nfor i in range(0 , n+1):\n    ind.append(0)\n \nfor i in range(1 , n + 1):\n    ind[a[i]] = i\nfor i in range(1 , 200005):\n    ad = []\n    for j in range(0 , 19):\n        ad.append((0 , 0))\n    f.append(ad)\n \nfor i in range(1 , n + 1):\n    f[i][0] = (a[i] , i)\n    for j in range(1 , 18):\n        f[i][j] = f[i][j - 1]\n        if i - p2[j] >= 0 and f[i - p2[j - 1]][j - 1] > f[i][j]:\n            f[i][j] = f[i - p2[j - 1]][j - 1]\nans = 0\n\nq = []\n\nq.append((1 , n))\nmaxind = 1\nnum = 0\nwhile num < maxind:\n    x = q[num][0]\n    y = q[num][1]\n    #print(x , y)\n    p = get(x,y)\n    #print(p)\n    if y - p[1] <= p[1] - x:\n        for i in range(p[1] , y + 1):\n            #print(i , a[i])\n            if ind[p[0] - a[i]] >= x and ind[p[0] - a[i]] <= p[1]:\n                ans += 1\n    else:\n        for i in range(x , p[1] + 1):\n            if ind[p[0] - a[i]] >= p[1] and ind[p[0] - a[i]] <= y:\n                ans += 1\n    if x < p[1] - 1:\n        q.append((x , p[1] - 1))\n        maxind += 1\n    if y > p[1] + 1:\n        q.append((p[1] + 1 , y))\n        maxind += 1\n    num += 1\n    #print(num , maxind)\n\nprint(ans)\n", "n=int(input())\na=[int(x) for x in input().split()]\ndef Count_Segment(a,n):\n\tans=0\n\tupto=[0]*(n+1)\n\tfor i in range(1,n-1):\n\t\tif a[i]>a[i-1] and a[i]>a[i+1]:\n\t\t\tcurr=a[i]\n\t\t\tj=i-1\n\t\t\twhile j>=0 and a[j]<curr:\n\t\t\t\tupto[a[j]]=curr\n\t\t\t\tj-=1\n \n\t\t\tj=i+1\n\t\t\twhile j<n and a[j]<curr:\n\t\t\t\tif upto[curr-a[j]]==curr:\n\t\t\t\t\tans+=1\n\t\t\t\tj+=1\n \n\treturn ans\n \nprint(Count_Segment(a,n))\n        \n           \n       \n", "n = int(input())\na = list(map(int,input().split()))\ndc = {a[i]:i for i in range(n)}\nstack = []\nmxr = [n]*(n+1)\nmxl = [-1]*(n+1)\nfor i,x in enumerate(a):\n  if i == 0:\n    stack.append(x)\n    continue\n  while stack and stack[-1] < x:\n    y = stack.pop()\n    mxr[y] = i\n  stack.append(x)\nstack = []\nfor i,x in enumerate(a[::-1]):\n  i = n-1-i\n  if i == n-1:\n    stack.append(x)\n    continue\n  while stack and stack[-1] < x:\n    y = stack.pop()\n    mxl[y] = i\n  stack.append(x)\nans = 0\nfor i in range(n,0,-1):\n  idx = dc[i]\n  l = mxl[i]\n  r = mxr[i]\n  if idx-l-1 > r-idx-1:\n    for j in range(idx+1,r):\n      if l < dc[i-a[j]] < idx:\n        ans += 1\n  else:\n    for j in range(idx-1,l,-1):\n      if idx < dc[i-a[j]] < r:\n        ans += 1\nprint(ans)", "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << (self.size.bit_length() - 1)\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n\n    N = int(input())\n    P = list(map(int, input().split()))\n\n    idx = [0] * (N+1)\n    for i, p in enumerate(P):\n        idx[p] = i+1\n    bit = Bit(N)\n    ans = 0\n    for p in range(N, 0, -1):\n        i = idx[p]\n        k = bit.sum(i)\n        r = bit.lower_bound(k+1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l+1, i):\n                q = P[j-1]\n                if i < idx[p - q] < r:\n                    ans += 1\n        else:\n            for j in range(i+1, r):\n                q = P[j-1]\n                if l < idx[p - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n        #print(l, r)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\nif a==[i+1 for i in range(n)]:print(0);return\nif a==[i+1 for i in range(n)][::-1]:print(0);return\np=[0]*(n+1)\np[0]=-1\nfor i in range(n):p[a[i]]=i\nnum=2**(n-1).bit_length()\ndef segfunc(x,y):\n  if a[x]<a[y]:return y\n  else:return x\nseg=[0]*(2*num-1)\nfor i in range(n):seg[i+num-1]=i\nfor i in range(num-2,-1,-1):seg[i]=segfunc(seg[2*i+1],seg[2*i+2])\ndef update(i,x):\n  i+=num-1;seg[i]=x\n  while i:i=(i-1)//2;seg[i]=segfunc(seg[i*2+1],seg[i*2+2])\ndef query(l,r):\n  l+=num-1;r+=num-2\n  if l==r:return seg[l]\n  s=seg[l];l+=1\n  while r-l>1:\n    if ~l%2:s=segfunc(seg[l],s)\n    if r%2:s=segfunc(seg[r],s);r-=1\n    l//=2;r=(r-1)//2\n  if l==r:return segfunc(s,seg[l])\n  return segfunc(s,segfunc(seg[l],seg[r]))\ndef f(l,r):\n  if r-l<2:return 0\n  maxi=query(l,r+1)\n  ma=a[maxi]\n  ans=f(l,maxi-1)+f(maxi+1,r)\n  if maxi-l<r-maxi:\n    for i in range(l,maxi):\n      if maxi<p[ma-a[i]]<=r:ans+=1\n  else:\n    for i in range(maxi+1,r+1):\n      if l<=p[ma-a[i]]<maxi:ans+=1\n  return ans\nprint(f(0,n-1))\n"]
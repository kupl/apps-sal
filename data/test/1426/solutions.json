["from collections import *\nfrom itertools import *\nfrom bisect import *\nfrom heapq import *\n\nimport math\nfrom fractions import gcd\nimport sys\n#input = sys.stdin.readline\n\nimport copy\n\nN,M=list(map(int,input().split()))\nUV=[list(map(int,input().split())) for i in range(M)]\nS,T=list(map(int,input().split()))\n\ndata=[[] for i in range(N+1)]\nfor u,v in UV:\n    data[u].append(v)\n\nvisited={S}\nvisited1=set()\nvisited2=set()\nstack=deque([[S,0]])\nwhile stack:\n    a,m=stack.popleft()\n    for p in data[a]:\n        z=(m+1)\n\n        if z%3==0:\n            if p in visited:\n                continue\n            elif p == T:\n                print((z//3))\n                return\n            else:\n                visited.add(p)\n        if z%3==1:\n            if p in visited1:\n                continue\n            else:\n                visited1.add(p)\n        if z%3==2:\n            if p in visited2:\n                continue\n            else:\n                visited2.add(p)\n        stack.append([p,z])\n\nprint((-1))\n", "import copy\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    u, v = map(int,input().split())\n    graph[u].append(v)\ns, g = map(int,input().split())\n\nINF = 10**7\nans = [[INF, INF, INF] for i in range(n+1)]\nq = [s]\nd = 0\nwhile q:\n    nq = []\n    d += 1\n    p = d % 3\n    for cf in q:\n        for ct in graph[cf]:\n            if ans[ct][p] == INF:\n                ans[ct][p] = d\n                nq.append(ct)\n    q = copy.deepcopy(nq)\nif ans[g][0] == INF:\n    print(-1)\nelse:\n    print(ans[g][0]//3)", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M = list(map(int, readline().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = list(map(int, readline().split()))\n        G[u - 1].append(v - 1)\n    S, T = list(map(int, readline().split()))\n    S -= 1\n    T -= 1\n\n    dist = [[-1] * 3 for _ in range(N)]\n    dist[S][0] = 0\n    queue = deque([(S, 0)])\n    while queue:\n        v, step = queue.popleft()\n        if step == 0 and v == T:\n            break\n\n        for nv in G[v]:\n            if dist[nv][(step - 1) % 3] != -1:\n                continue\n            dist[nv][(step - 1) % 3] = dist[v][step] + 1\n            queue.append((nv, (step - 1) % 3))\n\n    if dist[T][0] == -1:\n        print((-1))\n    else:\n        print((dist[T][0] // 3))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nnb = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, m = ns()\n    e = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = ns()\n        a, b = a - 1, b - 1\n        e[a].append(b)\n\n    s, t = ns()\n    s, t = s - 1, t - 1\n\n    visited = [[True] * 3 for _ in range(n)]\n\n    que = collections.deque()\n    que.append([0, s])\n    visited[s][0] = False\n    cnt = 0\n    ans = -1\n    flg = True\n\n    while que and flg:\n        cnt += 1\n        for _ in range(len(que)):\n            i, q = que.popleft()\n            for ei in e[q]:\n                tmp = (i + 1) % 3\n                if tmp == 0 and ei == t:\n                    ans = cnt // 3\n                    flg = False\n                    break\n                elif visited[ei][tmp]:\n                    visited[ei][tmp] = False\n                    que.append([tmp, ei])\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 7)\n\nfrom collections import deque\n\nn, m = list(map(int, readline().split()))\ngraph = [[] for _ in range(n * 3)]\nfor i in range(m):\n    u, v = list(map(int, readline().split()))\n    u -= 1\n    v -= 1\n    graph[u].append(v + n)\n    graph[u + n].append(v + 2 * n)\n    graph[u + 2 * n].append(v)\ns, t = [int(x) - 1 for x in readline().split()]\ninf = float('inf')\nq = deque([s])\ndist = [inf] * (3 * n)\ndist[s] = 0\n\nwhile q:\n    now = q.popleft()\n    for next in graph[now]:\n        if dist[next] != inf:\n            continue\n        dist[next] = dist[now] + 1\n        if next == t:\n            print((dist[next] // 3))\n            return\n        q.append(next)\nprint((-1))\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nn,m = map(int,input().split())\nto=[[] for _ in range(n)]\ndist=[[0] *3 for _ in range(100005)]\nINF=10**15\n\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    to[a].append(b)\n\nsv,tv=map(int,input().split())\nsv-=1;tv-=1\n\nfor i in range(n):\n    for j in range(3):\n        dist[i][j] =INF\n\nq=deque()\nq.append((sv,0))\ndist[sv][0]=0\n\nwhile q:\n    v,l=q.popleft()\n    for u in to[v]:\n        nl =(l+1)%3\n        if dist[u][nl] != INF: continue\n        dist[u][nl] = dist[v][l]+1\n        q.append((u,nl))\n\nans=dist[tv][0]\nif ans == INF:ans=-1\nelse: ans //=3\nprint(ans)", "from collections import deque\nn,m = map(int,input().split())\nG = [[[] for _ in range(3)] for _ in range(n)]\nfor _ in range(m):\n    u,v = map(int,input().split())\n    u -= 1\n    v -= 1\n    G[u][0].append((v,1))\n    G[u][1].append((v,2))\n    G[u][2].append((v,0))\ns,t = map(int,input().split())\ns -= 1\nt -= 1\n\ndist = [[-1]*3 for _ in range(n)]\ndist[s][0] = 0\nQ = deque([(s,0)])\nwhile Q:\n    now,r = Q.popleft()\n    for nxt,nr in G[now][r]:\n        if dist[nxt][nr] != -1: continue\n        dist[nxt][nr] = dist[now][r]\n        if r == 2: dist[nxt][nr] += 1\n        Q.append((nxt,nr))\n# print(dist)\nprint(dist[t][0])", "import sys\nsys.setrecursionlimit(10**6)\nfrom collections import deque\nn,m=map(int,input().split())\nedges=[[] for i in range(n)]\nfor i in range(m):\n    u,v=map(int,input().split())\n    edges[u-1].append(v-1)\ns,t=map(int,input().split())\ninf=100000000000\nscore=[[inf]*3 for i in range(n)]\nnow=deque()\nnow.append(s-1)\nscore[s-1][0]=0\ndef bfs(dep,l):\n    nonlocal n,m,edges,s,t,score,inf,now\n    f=False\n    for i in range(l):\n        ne=now.popleft()\n        for j in edges[ne]:\n            if score[j][dep%3]==inf:\n                score[j][dep%3]=dep\n                now.append(j)\n    l_ne=len(now)\n    if l_ne:bfs(dep+1,l_ne)\nbfs(1,1)\nif score[t-1][0]!=inf:\n    print(score[t-1][0]//3)\nelse:\n    print(-1)", "n,m = map(int,input().split())\npath = [[[],[],[]] for i in range(n)]\n\ngone = [[0]*3 for i in range(n)]\nfor i in range(m):\n    u,v = map(int,input().split())\n    path[u-1][0].append([v-1,1])\n    path[u-1][1].append([v-1,2])\n    path[u-1][2].append([v-1,0])\n\ns,t = map(int,input().split())\n\nnow = [[s-1,0]]\ngone[s-1][0] = 1\nfor ans in range(1,1000000):\n    next = []\n    for point,key in now:\n        for go,gokey in path[point][key]:\n            if go == t-1 and gokey == 0:\n                print(ans//3)\n                return\n            if gone[go][gokey] == 0:\n                gone[go][gokey] = 1\n                next.append([go,gokey])\n    now = next\n  #     print(now)\nprint(-1)", "from collections import deque\n\ndef bfs(s, t):\n    dist = [-1] * (3 * n + 1)\n    q = deque()\n    q.append(s)\n    dist[s] = 0\n    while q:\n        p = q.popleft()\n        for i in G[p]:\n            if dist[i] == -1:\n                dist[i] = dist[p] + 1\n                q.append(i)\n    return dist[t]\n\nn, m = map(int, input().split())\nG = [[] for _ in range(3 * n + 1)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    G[u].append(v + n)\n    G[u + n].append(v + 2 * n)\n    G[u + 2 * n].append(v)\ns, t = map(int, input().split())\nans = bfs(s, t)\nprint(ans // 3 if not ans == -1 else ans)", "from collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN, M = list(map(int, readline().split()))\nUV = [[int(x) for x in readline().split()] for _ in range(M)]\nS, T = list(map(int, readline().split()))\n\nPATH = [[] for _ in range(N + 1)]\n\nfor u, v in UV:\n    PATH[u].append(v)\n\ndist = [[-1] * 3 for _ in range(N+1)]\n\nq = deque()\nq.append((S, 0))\ndist[S][0] = 0\n\nwhile q:\n    u, mod = q.popleft()\n    d = dist[u][mod]\n\n    nmod = (mod + 1) % 3\n    for v in PATH[u]:\n        if dist[v][nmod] != -1:\n            continue\n        dist[v][nmod] = d + 1\n        q.append((v, nmod))\n\n\nif dist[T][0] == -1:\n    ans = -1\nelse:\n    ans = dist[T][0] // 3\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nN,M = map(int,input().split())\nUV = [tuple(map(int,input().split())) for i in range(M)]\nS,T = map(int,input().split())\nS,T = S-1,T-1\n\nes = [[] for _ in range(N*3)]\nfor u,v in UV:\n    u,v = u-1,v-1\n    es[u].append(v+N)\n    es[u+N].append(v+N+N)\n    es[u+N+N].append(v)\n\nfrom collections import deque\nq = deque([S])\nINF = float('inf')\ndist = [INF] * (N*3)\ndist[S] = 0\nwhile q:\n    v = q.popleft()\n    for to in es[v]:\n        if dist[to] <= dist[v]+1: continue\n        dist[to] = dist[v]+1\n        q.append(to)\n        if to==T:\n            print(dist[to] // 3)\n            return\nprint(-1)", "from collections import deque\nN, M = map(int, input().split())\nINF = -1\ndist = [[INF]*3 for _ in range(N)]\nvector = [[] for _ in range(N)]\n\nfor i in range(M):\n    graf1, graf2 = map(int, input().split())\n    vector[graf1-1].append(graf2-1)\nS, T = map(int, input().split())\nS, T = S-1, T-1\n\n# BFS\ndist[S][0] = 0\nq = deque()\nq.append((S, 0))\nwhile q:\n    v, l = q.popleft()\n    for i in vector[v]:\n        new_l = (l+1)%3\n        if dist[i][new_l] != INF:\n            continue\n        dist[i][new_l] = dist[v][l] + 1\n        q.append((i, new_l))\n\nans = dist[T][0]\nif ans == INF:\n    print(\"-1\")\nelse:\n    print(int(ans/3))", "from heapq import heappop, heappush\nN, M = list(map(int, input().split()))\n#3 * i\nedge = [[] for i in range(3 * N)]\nfor i in range(M):\n  u, v = list(map(int, input().split()))\n  u, v = u - 1, v - 1\n  edge[3 * u].append(3 * v + 1)\n  edge[3 * u + 1].append(3 * v + 2)\n  edge[3 * u + 2].append(3 * v)\n  \nS, T = list(map(int, input().split()))  \nS, T = S - 1, T - 1\n#print(edge)\n\nused = [0] * (3 * N)\nqueue = [[0, 3 * S]]\nused[3 * S] = 1\nwhile queue:\n  time, now = heappop(queue)\n  for i in edge[now]:\n    if (i == 3 * T):\n      print((int((time + 1) / 3)))\n      return\n    elif used[i] == 0:\n      used[i] = 1\n      heappush(queue, [time + 1, i])\n    \n    \nprint((-1))  \n  \n  \n  \n\n\n\n\n  \n", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\n\nINF = float('inf')\n\nN, M = list(map(int, input().split()))\nadjL = [[] for _ in range(3*N)]\nfor _ in range(M):\n    u, v = list(map(int, input().split()))\n    u, v = u-1, v-1\n    adjL[3*u+0].append(3*v+1)\n    adjL[3*u+1].append(3*v+2)\n    adjL[3*u+2].append(3*v+0)\nS, T = list(map(int, input().split()))\nS, T = S-1, T-1\n\n# \u5358\u4e00\u59cb\u70b9\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\uff08Dijkstra\u6cd5\uff09\ndef Dijkstra(adjList, vSt):\n    numV = len(adjList)\n    numUsed = 0\n    costs = [INF] * numV\n    costs[vSt] = 0\n    PQ = []\n    heappush(PQ, (0, vSt))\n    while PQ:\n        cNow, vNow = heappop(PQ)\n        if cNow > costs[vNow]: continue\n        numUsed += 1\n        if numUsed == numV: break\n        for v2 in adjList[vNow]:\n            c2 = cNow + 1\n            if c2 < costs[v2]:\n                costs[v2] = c2\n                heappush(PQ, (c2, v2))\n    return costs\n\ncosts = Dijkstra(adjL, 3*S)\n#print('costs:', costs)\n\nif costs[3*T] == INF:\n    print((-1))\nelse:\n    print((costs[3*T]//3))\n", "N,M = list(map(int,input().split()))\nedges=[list([int(x)-1 for x in input().split()]) for _ in range(M)]\nS,T = [int(x)-1 for x in input().split()]\n\nN3=N*3\nadj=[set() for _ in range(N3)]\n\nfor a,b in edges:\n    for i in range(3):\n        start = a+N*i\n        dst = b+N*(i+1)\n        adj[start%N3].add(dst%N3)\n\n\nQ=[S]\nvisited={S}\ndist=[-1]*N3\ndist[S]=0\n\nwhile Q:\n    tmp=[]\n    for q in Q:\n        for i in adj[q]:\n            if i in visited:\n                continue\n            else:\n                dist[i]=dist[q]+1\n                visited.add(i)\n                tmp.append(i)\n    Q = tmp\nprint((dist[T] if dist[T]==-1 else dist[T]//3))\n\n", "def bfs(g, N, s, t):\n    from collections import deque\n\n    dist = [-1] * (N * 3)\n    dist[s] = 0\n\n    dq = deque()\n    dq.append(s)\n\n    while dq:\n        v = dq.popleft()\n        d = dist[v]\n        for u in g[v]:\n            if ~dist[u]: continue\n            dist[u] = d + 1\n            if u == t:\n                return dist[t] // 3  # TLE\u3057\u305f\u306e\u3067\u89e3\u3092\u898b\u3064\u3051\u305f\u3089\u5373return\u306b\u5909\u3048\u305f\n            dq.append(u)\n    return -1\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N * 3))\n    for _ in range(M):\n        u, v = (int(x) - 1 for x in input().split())\n        g[u].add(v + N)\n        g[u + N].add(v + N * 2)\n        g[u + N * 2].add(v)\n\n    S, T = (int(x) - 1 for x in input().split())\n\n    ans = bfs(g, N, S, T)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u53cc\u65b9\u5411\u30b0\u30e9\u30d5\u3067\u5e45\u512a\u5148\u63a2\u7d22\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\ng = [set([]) for _ in range(n)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    g[a].add(b)\n\ns, t = list(map(int, input().split()))\ns, t = s-1, t-1\n\n#\u5e45\u512a\u5148\u63a2\u7d22\nq = deque()\nlevel = [[-1]*n for i in range(3)]\nq.append((s, 0))\nlevel[0][s] = 0\nwhile len(q)>0:\n    cur, lvl = q.popleft()\n    nxtl = lvl + 1\n    nxthp = nxtl%3\n    for i in g[cur]:\n        if level[nxthp][i]==-1:\n            #\u968e\u5c64\n            level[nxthp][i] = nxtl\n            q.append((i, nxtl))\nprint((level[0][t]//3))\n", "# \u9802\u70b9\u30923\u56de\u305a\u3064\u306b\u6301\u3064 (x\u6b69\u76ee\u306e\u7740\u5730\uff09\n# \u6700\u77ed\u8def\n\nimport sys\ninput = sys.stdin.readline\nN,M = list(map(int,input().split()))\nif M == 0:\n  print((-1))\n  return\nedge = [[] for _ in range(N+1)]\nfor _ in range(M):\n  u,v = list(map(int,input().split()))\n  edge[u].append(v)\nS,T = list(map(int,input().split()))\n\nINF = 10 ** 9\ndist = [[INF,INF,INF] for _ in range(N+1)]\n\nd = 0\nq = [S]\nwhile q:\n  d += 1\n  r = d % 3\n  qq = []\n  for u in q:\n    for v in edge[u]:\n      if dist[v][r] == INF:\n        dist[v][r] = d\n        qq.append(v)\n  q = qq\n\nd = dist[T][0]\nanswer = -1 if d == INF else d // 3\nprint(answer)\n", "import sys\nfrom collections import deque\n\ninput = sys.stdin.buffer.readline\nint1 = lambda x: int(x) - 1\n\nN, M = list(map(int, input().split()))\nG = [[] for _ in range(3 * N)]\nfor _ in range(M):\n    u, v = list(map(int1, input().split()))\n    G[u * 3].append(v * 3 + 1)\n    G[u * 3 + 1].append(v * 3 + 2)\n    G[u * 3 + 2].append(v * 3)\n\nS, T = list(map(int1, input().split()))\nS *= 3\nT *= 3\n\n# bfs\nd = deque([S])\ndistance = [0] * (3 * N)\nwhile d:\n    v = d.popleft()\n    dist_v = distance[v]\n    if v == T:\n        print((dist_v // 3))\n        return\n    for x in G[v]:\n        if not distance[x]:\n            d.append(x)\n            distance[x] = dist_v + 1\nprint((-1))\n", "from collections import deque \nMOD = 10**9 +7\nINF = 10**9\ndef main():\n    n,m = list(map(int,input().split()))\n    V0 = [[] for _ in range(n)]\n    V1 = [[] for _ in range(n)]\n    V2 = [[] for _ in range(n)]\n    for _ in range(m):\n        u,v = list(map(int,input().split()))\n        u -= 1\n        v -= 1\n        V0[u].append(v)\n        V1[u].append(v)\n        V2[u].append(v)\n    \n    s,t = list(map(int,input().split()))\n    s -= 1\n    t -= 1\n    \n    d0 = [-1]*n\n    d1 = [-1]*n\n    d2 = [-1]*n\n    d0[s] = 0\n\n    q = deque()\n    q.append((s,0))\n    while len(q):\n        v,mod = q.popleft()\n        if mod == 0:\n            for e in V0[v]:\n                if d1[e] == -1:\n                    d1[e] = d0[v] + 1\n                    q.append([e,1])\n\n        elif mod == 1:\n            for e in V1[v]:\n                if d2[e] == -1:\n                    d2[e] = d1[v] + 1\n                    q.append([e,2])\n        \n        else:\n            for e in V2[v]:\n                if e == t:\n                    print(((d2[v] + 1)//3))\n                    return           \n                if d0[e] == -1:\n                    d0[e] = d2[v] + 1\n                    q.append([e,0])\n    \n    if d0[t] == -1:\n        print((-1))\n   \ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nn,m=map(int,input().split())\nG=[[] for i in range(3*n)]\nfor i in range(m):\n  u,v=map(int,input().split())\n  for j in range(3):\n    G[u+n*j-1].append(v+n*((j+1)%3)-1)\ns,g=map(int,input().split())\ns=s-1\ng=g-1\nD=deque([s])\nV=[0]*3*n\nV[s]=1\nDD=[0]*3*n\nwhile len(D)>0:\n  x=D[0]\n  D.popleft()\n  for y in G[x]:\n    if V[y]==0:\n      V[y]=1\n      D.append(y)\n      DD[y]=DD[x]+1\nif DD[g]==0:\n  print(-1)\nelse:\n  print(DD[g]//3)", "from collections import deque\nimport sys\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\nUV = [[]for _ in range(n)]\nfor _ in range(m):\n    u, v = list([int(x)-1 for x in input().split()])\n    UV[u].append(v)\ns, t = list([int(x)-1 for x in input().split()])\n\nNV = 3*n\nedges = [[]for _ in range(NV)]\n\n\ndef to_v(i, j):\n    return 3*i+j\n\n\nfor i in range(n):\n    for i2 in UV[i]:\n        for j in range(3):\n            edges[to_v(i, j)].append(to_v(i2, (j+1) % 3))\n\ninit_v = to_v(s, 0)\nINF = 10**18\ndist = [INF]*NV\ndist[init_v] = 0\nnext_v = deque([init_v])\nwhile next_v:\n    v = next_v.popleft()\n    for v2 in edges[v]:\n        if dist[v2] <= dist[v]+1:\n            continue\n        dist[v2] = dist[v]+1\n        next_v.append(v2)\n\nprint((dist[to_v(t, 0)]//3 if dist[to_v(t, 0)] != INF else -1))\n", "from collections import deque\n\ndef main():\n\n  n,m=map(int,input().split())\n  INF=10**9\n  d=[[INF]*3 for i in range(n)]\n  to=[[] for i in range(n)]\n  for i in range(m):\n    u,v=map(lambda x:int(x)-1,input().split())\n    to[u].append(v)\n  s,t=map(lambda x:int(x)-1,input().split())\n\n  #print(to)\n  # calc d (after 3 times dist)\n  d[s][0]=0\n  cnt=0\n  q=deque([(s,cnt)])\n  while q:\n    u,c=q.popleft()\n    for v in to[u]:\n      nc=(c+1)%3\n      if d[v][nc]!=INF: continue;\n      d[v][nc]=d[u][c]+1\n      q.append((v,nc))\n      \n  #print(d)\n  ans=d[t][0]\n  print(ans//3 if ans!=INF else -1)\n\n  \ndef __starting_point():\n  main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\ndef MI():\n  return map(int,input().split())\ndef main():\n  n,m=MI()\n  G=[[] for _ in range(n)]\n  for _ in range(m):\n    u,v=MI()\n    u-=1\n    v-=1\n    G[u].append(v)\n  s,t=MI()\n  s-=1\n  t-=1\n  \n  fi=[True]*n\n  se=[True]*n\n  th=[True]*n\n  th[s]=False\n\n  dq=[s]\n  depth=0\n  \n  while dq:\n    depth+=1\n    tank1=[]\n    tank2=[]\n    tank3=[]\n    \n    for p in dq:\n      for c in G[p]:\n        if fi[c]:\n          fi[c]=False\n          tank2.append(c)\n    for p in tank2:\n      for c in G[p]:\n        if se[c]:\n          se[c]=False\n          tank3.append(c)\n    for p in tank3:\n      for c in G[p]:\n        if th[c]:\n          th[c]=False\n          tank1.append(c)\n        if c==t:\n          print(depth)\n          return\n    dq=tank1\n  print(-1)  \ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\n\nn, m = list(map(int, input().split()))\nuv = [list(map(int, input().split())) for _ in range(m)]\ns, t = list(map(int, input().split()))\n\nN = 3 * (n + 1)\nadj = [[] for _ in range(N)]\nfor u, v in uv:\n    for i in range(3):\n        uu = u + i * n\n        vv = v + ((i + 1) % 3) * n\n        adj[uu].append(vv)\n\ndq = deque([s])\nd = [-1] * N\nd[s] = 0\nwhile dq:\n    u = dq.popleft()\n    for v in adj[u]:\n        if d[v] == -1:\n            d[v] = d[u] + 1\n            dq.append(v)\n\nans = d[t] // 3\nprint(ans)\n", "from sys import stdin\nfrom collections import deque\n\n\ndef input():\n    return stdin.readline().strip()\n\n\ndef bfs():\n    q = deque([(S, 0)])\n    dist = [[-1] * 3 for _ in range(N)]\n    dist[S][0] = 0\n    while q:\n        v, r = q.popleft()\n        for nv in g[v]:\n            nr = (r + 1) % 3\n            if dist[nv][nr] >= 0:\n                continue\n            dist[nv][nr] = dist[v][r] + 1\n            q.append((nv, nr))\n    return dist[T][0] // 3\n\n\nN, M = list(map(int, input().split()))\ng = [[] for _ in range(3 * N)]\nfor _ in range(M):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[a].append(b)\nS, T = [int(x) - 1 for x in input().split()]\nprint((bfs()))\n", "from collections import deque\n\nn, m = list(map(int, input().split()))\nuv = [list(map(int, input().split())) for _ in range(m)]\ns, t = list(map(int, input().split()))\n\nadj = [[] for _ in range(3 * n)]\nfor u, v in uv:\n    u -= 1\n    v -= 1\n    adj[u].append(v + n)\n    adj[u + n].append(v + 2 * n)\n    adj[u + 2 * n].append(v)\n\n\ndef bfs(s):\n    q = deque([s])\n    d = [-1] * (3 * n)\n    d[s] = 0\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if d[v] == -1:\n                d[v] = d[u] + 1\n                q.append(v)\n\n    return d\n\n\ndist = bfs(s - 1)\nans = dist[t - 1]\nprint((ans // 3))\n", "import sys\n\ninput = sys.stdin.readline\nn,m = list(map(int,input().split()))\nfrom collections import defaultdict\ndic = defaultdict(list)\n\nfor _ in range(m):\n    u,v = list(map(int,input().split()))\n    dic[u-1].append(v-1+n)\n    dic[u - 1+n].append(v - 1 + 2*n)\n    dic[u - 1+2*n].append(v - 1)\n\nG = dic\ns,t = list(map(int,input().split()))\n\n# G[v]: \u9802\u70b9v\u306b\u96a3\u63a5\u3059\u308b\u9802\u70b9list\n# N: \u9802\u70b9\u6570\n\nfrom collections import deque\ndist = [-1]*(n*3)\nque = deque([s-1])\ndist[s-1] = 0\nwhile que:\n    v = que.popleft()\n    d = dist[v]\n    for w in G[v]:\n        if dist[w] > -1:\n            continue\n        dist[w] = d + 1\n        que.append(w)\nprint((dist[t-1]//3))\n\n", "n,m=map(int,input().split())\nu=[]\nv=[]\ng=[[] for _ in range(n)]\n\nfor i in range(m):\n    uu,vv=map(int,input().split())\n    u.append(uu)\n    v.append(vv)\n    g[uu-1].append(vv-1)\n    \ns,t=map(int,input().split())\ns-=1\nt-=1\n\nfrom collections import deque\n \ndef bfs(u):\n    queue1 = deque([u])\n    queue2 = deque([0])\n    d=[]\n    for i in range(n):\n        d.append([-1]*3)\n    d[u][0]=0\n    while queue1:\n        v=queue1.popleft()\n        l=queue2.popleft()\n        nl=(l+1)%3\n        for i in g[v]:\n            if d[i][nl] is -1:\n                d[i][nl]=d[v][l]+1\n                queue1.append(i)\n                queue2.append(nl)\n    return d\n\nd=bfs(s)\n\nans=int(d[t][0]/3)\nif d[t][0]==-1:\n    ans=-1\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque\n\ndef solve(N: int, M: int, G, S: int, T: int):\n    S -= 1\n    T -= 1\n    now = deque([S])\n    dist = [0 for _ in range(N * 3)]\n    while now:\n        p = now.popleft()\n        for n in G[p]:\n            if dist[n] != 0:\n                continue\n            dist[n] = dist[p] + 1\n            if n == T:\n                print((dist[n] // 3))\n                return\n            now.append(n)\n    print((-1))\n    return\n\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    G = tuple(set() for _ in range(N * 3))\n    for _ in range(M):\n        u, v = int(next(tokens)) - 1, int(next(tokens))-1\n        G[u].add(v + N)\n        G[u + N].add(v + 2 * N)\n        G[u + 2 * N].add(v)\n\n    S = int(next(tokens))  # type: int\n    T = int(next(tokens))  # type: int\n    solve(N, M, G, S, T)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\n\n\ndef kenkenpa(s, visited):\n    res = []\n    for v1 in e[s]:\n        if visited[v1][1]:\n            continue\n        visited[v1][1] = True\n        for v2 in e[v1]:\n            if visited[v2][2]:\n                continue\n            visited[v2][2] = True\n            for v3 in e[v2]:\n                if visited[v3][0]:\n                    continue\n                visited[v3][0] = True\n                res.append(v3)\n    return res\n\n\nN, M = list(map(int, input().split()))\ne = defaultdict(list)\nfor i in range(M):\n    u, v = list(map(int, input().split()))\n    e[u].append(v)\n\nS, T = list(map(int, input().split()))\nq = deque([[S, 0]])\nvisited = [[False]*3 for _ in range(N+1)]\nvisited[S][0] = True\nans = -1\nwhile q:\n    u, c = q.popleft()\n    if u == T:\n        ans = c\n        break\n    l = kenkenpa(u, visited)\n    for v in l:\n        q.append([v, c+1])\nprint(ans)\n", "n,m=map(int,input().split())\nG=[[] for i in range(n)]\nfor i in range(m):\n  u,v=map(int,input().split())\n  G[u-1].append(v-1)\n\ns,t=map(int,input().split())\ns-=1\nt-=1\nfrom collections import deque\ndist=[[-1]*3 for i in range(n)]\ndist[s][0]=0\nq=deque()\nq.append([s,0])\nwhile q:\n  cur,parity=q.popleft()\n  for nx in G[cur]:\n    nx_parity=(parity+1)%3\n    if dist[nx][nx_parity]==-1:\n      dist[nx][nx_parity]=dist[cur][parity]+1\n      q.append([nx,nx_parity])\nif dist[t][0]==-1:\n  print(-1)\nelse:\n  print(int(dist[t][0]//3))", "import sys\nfrom collections import deque\n\ndef main():\n  input = sys.stdin.readline\n  n, m = map(int, input().split())\n  roads0 = [[] for _ in range(n)]\n  roads1 = [[] for _ in range(n)]\n  roads2 = [[] for _ in range(n)]\n  \n  for i in range(m):\n    u, v = map(int, input().split())\n    roads0[u-1].append(v-1)\n    roads1[u-1].append(v-1)\n    roads2[u-1].append(v-1)\n  \n\n  s, t = map(int, input().split())\n  not_yet = deque([])\n  already = [[False]*3 for _ in range(n)]\n  dist = [[0]*3 for _ in range(n)]\n  for v in roads0[s-1]:\n    not_yet.append((v, 1))\n    dist[v][1] = 1\n    already[v][1] = True\n  already[s-1][0] = True\n  while not_yet:\n    key = not_yet.popleft()\n    k1, k2 = key[0], key[1]\n    if k2 == 0:\n      for v in roads1[k1]:\n        if already[v][1]:\n          continue\n        dist[v][1] = dist[k1][0]+1\n        already[v][1] = True\n        not_yet.append((v, 1))\n    elif k2 == 1:\n      for v in roads2[k1]:\n        if already[v][2]:\n          continue\n        dist[v][2] = dist[k1][1]+1\n        already[v][2] = True\n        not_yet.append((v, 2))\n    else:\n      for v in roads0[k1]:\n        if already[v][0]:\n          continue\n        dist[v][0] = dist[k1][2]+1\n        already[v][0] = True\n        not_yet.append((v, 0))\n  if already[t-1][0]:\n    print(dist[t-1][0]//3)\n  else:\n    print(-1)\n  \n    \ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\ns, t = map(int, input().split())\ns -= 1\nt -= 1\nq = deque([s])\nINF = 10**10\ndist = [[INF]*3 for _ in range(n)]\ndist[s][0] = 0\nwhile q:\n    node = q.popleft()\n    for c_node in graph[node]:\n        flg = False\n        for i in range(3):\n            nd = dist[node][i]+1\n            if dist[c_node][nd%3] > nd:\n                dist[c_node][nd%3] = nd\n                flg = True\n        if flg:\n            q.append(c_node)\nif dist[t][0]==INF:\n    print(-1)\nelse:\n    print(dist[t][0]//3)", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# vertex\u3054\u3068\u306b3\u3064\u306e\u72b6\u614b\u6570\u3092\u6301\u3064\nN, M = lr()\ngraph = [[] for _ in range((N+1)*3)]  # 1-indexed\nfor _ in range(M):\n    a, b = lr()\n    a *= 3; b *= 3\n    for i in range(3):\n        j = i+1 if i < 2 else 0\n        graph[a+i].append(b+j)\n\nINF = 10 ** 15\n\ndef dijkstra(start):\n    dist = [INF] * (N+1) * 3\n    dist[start] = 0\n    que = [(0, start)]\n    while que:\n        d, prev = heappop(que)\n        if dist[prev] < d:\n            continue\n        for next in graph[prev]:\n            d1 = d + 1\n            if dist[next] > d1:\n                dist[next] = d1\n                heappush(que, (d1, next))\n    return dist\n\nS, T = lr()\ndist = dijkstra(S*3)\nanswer = dist[T*3]\nif answer == INF:\n    answer = -1\nelse:\n    answer //= 3\nprint(answer)\n", "from collections import deque\n\nN,M,*f = map(int, open(0).read().split())\nuv = [f[i:i+2] for i in range(0, len(f)-2, 2)]\nS = f[-2]\nT = f[-1]\nconnected = [[] for _ in range(N+1)]\nfor u, v in uv:\n    connected[u].append(v)\ndist = [[-1] * 3 for _ in range(N+1)]\ndist[S][0] = 0\nans = 0\nd = deque([(S,0)])\nwhile d:\n    temp = d.popleft()\n    for edge in connected[temp[0]]:\n        if edge == T and temp[1] == 2:\n            print((dist[temp[0]][2]+1)//3)\n            break\n        else:\n            if dist[edge][(temp[1]+1)%3] < 0:\n                dist[edge][(temp[1]+1)%3] = dist[temp[0]][temp[1]] + 1\n                d.append((edge,(temp[1]+1)%3))\n    else:\n        continue\n    break\nelse:\n    print(-1)", "N,M=map(int,input().split())\nA=[[]for i in range(N)]\nfor i in range(M):\n  a,b=map(int,input().split())\n  A[a-1].append(b-1)\nS,T=map(int,input().split())  \nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**7) #\u518d\u5e30\u5236\u9650\u306e\u3068\u3063\u3071\u3089\u3044\nD=[[-1]*3 for i in range(N)]\ndef bfs(x,n):\n  q=deque()\n  q.append((x,n)) \n  while len(q):\n    x,n=q.popleft()\n    for i in A[x]:\n      d=(n+1)%3\n      if D[i][d]==-1:\n        D[i][d]=D[x][n]+1\n        q.append((i,d))\nD[S-1][0]=0\nbfs(S-1,0)\nif D[T-1][0]==-1:\n  print(-1)\nelse:\n  print(D[T-1][0]//3)", "#  --*-coding:utf-8-*--\n\nimport heapq\n\nINF = float('inf')\n\ndef dijkstra(graph, st):\n    n  = len(graph)\n    ds = [INF]*n\n    ds[st] = 0\n    prevs = [None]*n\n    \n    qs = [(0, st)]\n\n    while len(qs) > 0:\n        d, nodeId = heapq.heappop(qs)\n        \n        if d > ds[nodeId]:\n            continue\n        \n        for destId, length in graph[nodeId]:\n            d2 = d + length\n            if ds[destId] > d2:\n                ds[destId] = d2\n                prevs[destId] = nodeId\n                heapq.heappush(qs, (d2, destId))\n                \n    return (ds, prevs)\n\n\nN, M = list(map(int, input().split()))\nG = [[] for _ in range(N*3)]\n\nfor _ in range(M):\n    u, v = list(map(int, input().split()))\n    \n    for i in range(3):\n        G[u*3 - 3 + i].append((v*3-3 + (i+1)%3, 1))\n\n\nS, T = list(map(int, input().split()))\nds, prevs = dijkstra(G, S*3-3)\n\nans = ds[T*3-3]\nprint((ans//3 if ans != INF else -1))\n", "from heapq import heappush, heappop\n\nclass Dijkstra:\n    def __init__(self, N):\n        self.N = N # #vertices\n        self.E = [[] for _ in range(N)]\n\n    def add_edge(self, init, end, weight, undirected=False):\n        self.E[init].append((end, weight))\n        if undirected: self.E[end].append((init, weight))\n    \n    def distance(self, s):\n        INF = float('inf')\n        E, N = self.E, self.N\n        self.dist = dist = [INF] * N # the distance of each vertex from s\n        self.prev = prev = [-1] * N # the previous vertex of each vertex on a shortest path from s\n        dist[s] = 0\n        n_visited = 1 # #(visited vertices)\n        heap = []\n        heappush(heap, (0, s))\n        while heap:\n            d, v = heappop(heap)\n            if dist[v] < d: continue\n            for u, c in E[v]:\n                temp = d + c\n                if dist[u] > temp:\n                    dist[u] = temp; prev[u] = v\n                    heappush(heap, (temp, u))\n            n_visited += 1\n            if n_visited == N: break\n        return dist\n    \n    def shortest_path(self, t):\n        P = []\n        prev = self.prev\n        while True:\n            P.append(t)\n            t = prev[t]\n            if t == -1: break\n        return P[::-1]\n\nN, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\nS, T = map(int, input().split())\ndijkstra = Dijkstra(3 * N)\nfor a, b in edges:\n    a, b = a - 1, b - 1\n    dijkstra.add_edge(a, N + b, 0)\n    dijkstra.add_edge(N + a, 2 * N + b, 0)\n    dijkstra.add_edge(2 * N + a, b, 1)\nans = dijkstra.distance(S - 1)[T - 1]\nprint(ans if ans != float('inf') else -1)", "import heapq\n\nN,M=list(map(int,input().split()))\n\nL=[[]    for i in range(3*N)]\n\nfor i in range(M):\n  u,v=list(map(int,input().split()))\n  u,v=u-1,v-1\n  L[u].append(N+v)\n  L[N+u].append(2*N+v)\n  L[2*N+u].append(v)\n\nS,T=list(map(int,input().split()))\n\nD=[10**6 for i in range(3*N)]\nD[~-S]=0\nA=[(0,~-S)]\nheapq.heapify(A)\n\nwhile len(A)>0:\n  d,v=heapq.heappop(A)\n  if D[v]<d:\n    continue\n  for i in L[v]:\n    if D[i]>D[v]+1:\n      D[i]=D[v]+1\n      heapq.heappush(A,(D[v]+1, i))\n\nprint((D[~-T]//3 if D[~-T]!=10**6 else -1))\n", "N,M=list(map(int,input().split()))\ntree=[[] for _ in range(N)]\nfor _ in range(M):\n    u,v=list(map(int,input().split()))\n    tree[u-1].append(v-1)\nS,T=list(map(int,input().split()))\ns=S-1\nt=T-1\nischecked=[[0]*3 for _ in range(N)]\nischecked[s][0]=1\nans=-1\nq=[]\nq.append([s,0])\nwhile q:\n    v,c=q.pop(0)\n    if v==t and c%3==0:\n        ans=c//3\n        break\n    for i in tree[v]:\n        if ischecked[i][(c+1)%3]==0:\n            q.append([i,c+1])\n            ischecked[i][(c+1)%3]=1\nprint(ans)\n", "N, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    ta, tb = map(int, input().split())\n    E[ta-1].append(tb-1)\nS, T = map(int, input().split())\nS -= 1\nT -= 1\n\nINF = float('inf')\ndist = [[INF] * N for _ in range(3)]\ndist[0][S] = 0\nq = [[S,0]]\n\nwhile q:\n    cp, cd = q.pop(0)\n    nd = (cd + 1) % 3\n    for np in E[cp]:\n        if dist[nd][np] != INF:\n            continue\n        else:\n            dist[nd][np] = dist[cd][cp] + 1\n            q.append([np,nd])\n\nans = dist[0][T]\nif ans == INF:\n    print(-1)\nelse:\n    print(ans//3)", "import copy\n\nn, m = map(int,input().split())\nedge = []\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    edge.append(list(map(int,input().split())))\n    graph[edge[-1][0]].append(edge[-1][1])\ns, g = map(int,input().split())\n\nINF = 10**11\nans = [[INF, INF, INF] for i in range(n+1)]\nq = [s]\nd = 0\nwhile q:\n    nq = []\n    d += 1\n    p = d % 3\n    for cf in q:\n        for ct in graph[cf]:\n            if ans[ct][p] == INF:\n                ans[ct][p] = d\n                nq.append(ct)\n    q = copy.deepcopy(nq)\nif ans[g][0] == INF:\n    print(-1)\nelse:\n    print(ans[g][0]//3)", "import heapq\nINF = 10 ** 10\n\n\ndef dijkstra(n, adj, s, t):\n    dist = [INF for _ in range(n)]\n    dist[s] = 0\n    h = [(0, s)]\n    while len(h) > 0:\n        d, node = heapq.heappop(h)\n        for next_node in adj[node]:\n            next_d = d + 1\n            if next_d < dist[next_node]:\n                dist[next_node] = next_d\n                heapq.heappush(h, (next_d, next_node))\n    return dist[t]\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    adj = [[] for _ in range(3 * N)]\n    for _ in range(M):\n        u, v = list(map(lambda x: int(x) - 1, input().split(' ')))\n        adj[3 * u].append(3 * v + 1)\n        adj[3 * u + 1].append(3 * v + 2)\n        adj[3 * u + 2].append(3 * v)\n    S, T = list(map(lambda x: int(x) - 1, input().split(' ')))\n    d = dijkstra(3 * N, adj, 3 * S, 3 * T)\n    if d == INF:\n        print(-1)\n    else:\n        print(d // 3)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nN,M = map(int,input().split())\n\nedge = [[] for _ in range(N)]\nfor _ in range(M):\n    u,v = map(int,input().split())\n    u,v = u-1,v-1\n    edge[u].append(v)\n    \nS,T = map(int,input().split())\nS,T = S-1,T-1\n\n\nINF = N*3\n\ndist = [[INF]*3 for _ in range(N)]\n\ndist[S][0] = 0\n\nq = [(0,S)]\n\nwhile q:\n    d, vs = heapq.heappop(q)\n    if d > dist[vs][d%3]: continue\n    \n    for ve in edge[vs]:\n        lev = (d+1)%3\n        if d+1 < dist[ve][lev]:\n            dist[ve][lev] = d+1\n            heapq.heappush(q,(d+1,ve))\n    \n    if dist[T][0] < INF: break\n        \nprint(dist[T][0]//3 if dist[T][0]<INF else -1)", "n,m=list(map(int,input().split()))\nuv=[list(map(int, input().split())) for _ in range(m)]\ns,t=list(map(int,input().split()))\n\ngraph = [[] for _ in range(n)]\nfor v in uv:\n    graph[v[0]-1].append(v[1]-1)\n# print(graph)\ns-=1\nt-=1\n\nis_checked=[[0]*3 for _ in range(n)]\nis_checked[s][0]=1\n\nans=-1\n\nfrom collections import deque\nq=deque()\nq.append([s,0])\n\nwhile q:\n    v, cnt=q.popleft()\n    if v==t and cnt%3==0:\n        ans=cnt//3\n        break\n    for i in graph[v]:\n        if is_checked[i][(cnt+1)%3]==0:\n            q.append([i, cnt+1])\n            is_checked[i][(cnt+1)%3]=1\n# print(is_checked)\nprint(ans)\n\n", "from collections import deque\nn, m = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    graph[u].append(v)\n\ns, t = list(map(int, input().split()))\n\ndist = [[-3] * 3 for _ in range(n+1)]\ndist[s][0] = 0\n\nq = deque([(s, 0)])\n\nwhile q:\n    now, c = q.popleft()\n    ne = (c+1) % 3\n    for node in graph[now]:\n        if dist[node][ne] != -3:\n            continue\n        dist[node][ne] = dist[now][c] + 1\n        q.append((node, ne))\n\nprint((dist[t][0] // 3))\n", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    #graph[b-1].append(a-1)\nS, T = map(int, input().split())\nS -= 1; T -= 1\n\nD = [[-1]*3 for _ in range(N)]\nD[S][0] = 0\nq = [(S, 0)]\nwhile q:\n    qq = []\n    for p, d in q:\n        for np in graph[p]:\n            nd = (d+1)%3\n            if D[np][nd] == -1:\n                D[np][nd] = D[p][d] + 1\n                qq.append((np, nd))\n    q = qq\n\nif D[T][0] == -1:\n    print(-1)\nelse:\n    print(D[T][0]//3)", "N,M=map(int,input().split())\nlist=[[] for i in range(3*N)]\nfor i in range(M):\n  u,v=map(int,input().split())\n  list[3*u-3].append(3*v-2)\n  list[3*u-2].append(3*v-1)\n  list[3*u-1].append(3*v-3)\ns,t=map(int,input().split())\ndef bfs(a,b):\n  visited=[-1 for i in range(3*N)]\n  visited[a]=0\n  h=[]\n  h.append(a)\n  while h:\n    v=h.pop(0)\n    for k in list[v]:\n      if visited[k]==-1:\n        visited[k]=visited[v]+1\n        h.append(k)\n  return visited[b]\n\nprint(bfs(3*s-3,3*t-3)//3) ", "from collections import deque\n\nn, m = list(map(int, input().split()))\nuv  =[[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    uv[u - 1].append(v - 1)\ns, t = list(map(int, input().split()))\ns -= 1\nt -= 1\n\nqueue = deque()\nqueue.append(s)\nqueue.append(1)\nqueue.append(0)\ncheck = [[False for _ in range(3)] for _ in range(n)]\ncheck[s][0] = True\n\nwhile queue:\n    pos = queue.popleft()\n    ans = queue.popleft()\n    kkp = queue.popleft()\n    for next_pos in uv[pos]:\n        if next_pos == t and kkp == 2:\n            print((ans // 3))\n            return\n        if check[next_pos][(kkp + 1) % 3]:\n            continue\n        check[next_pos][(kkp + 1) % 3] = True\n        queue.append(next_pos)\n        queue.append(ans + 1)\n        queue.append((kkp + 1) % 3)\nprint((-1))\n", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readlines\nfrom collections import deque\ndef main():\n    lines = input()\n    n, m = list(map(int, lines[0].split()))\n    #\u96a3\u63a5\u30ea\u30b9\u30c8\n    edges=[[] for i in range(n)]\n    for i in range(m):\n        u,v=list(map(int,lines[i+1].split()))\n        edges[u-1].append(v-1)\n\n    s,t=list(map(int,lines[m+1].split()))\n    inf=100000000000\n    score=[[inf]*3 for i in range(n)]\n    now=deque()\n    now.append((s-1, 0))\n    score[s-1][0]=0\n    def bfs():\n        if now:\n            u, mod = now.popleft()\n            time = score[u][mod]\n            mod = (mod+1)%3\n            for v in edges[u]:\n                if score[v][mod] == inf:\n                    score[v][mod] = time+1\n                    now.append((v, mod))\n\n            bfs()\n\n    bfs()\n    ans = score[t-1][0]\n    if ans == inf:\n        print(-1)\n    else:\n        print(score[t-1][0]//3)\nmain()", "import collections\nN,M=map(int,input().split())\ntree=[[] for _ in range(N)]\nfor _ in range(M):\n    u,v=map(int,input().split())\n    tree[u-1].append(v-1)\nS,T=map(int,input().split())\ns=S-1\nt=T-1\nischecked=[[0]*3 for _ in range(N)]\nischecked[s][0]=1\nans=-1\nq=collections.deque()\nq.append([s,0])\nwhile q:\n    v,c=q.popleft()\n    if v==t and c%3==0:\n        ans=c//3\n        break\n    for i in tree[v]:\n        if ischecked[i][(c+1)%3]==0:\n            q.append([i,c+1])\n            ischecked[i][(c+1)%3]=1\nprint(ans)", "from collections import deque\nn, m = map(int, input().split())\nedge = [[] for i in range(n)]\nkkp = [0] * n\nfor i in range(m):\n    u, v = map(int, input().split())\n    edge[u - 1].append(v - 1)\ns, t = map(int, input().split())\nque = deque([(s - 1, 0)])\nwhile que:\n    now, dis = que.popleft()\n    for next in edge[now]:\n        if next == t - 1 and (dis + 1) % 3 == 0:\n            print((dis + 1) // 3);return\n        if not kkp[next] & (2 ** ((dis + 1) % 3)):\n            kkp[next] = kkp[next] | (2 ** ((dis + 1) % 3))\n            que.append((next, dis + 1))\nprint(-1)", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,M = map(int,input().split())\nUV = [tuple(map(int,input().split())) for _ in range(M)]\nS,T = map(int,input().split())\n\nS,T = S-1,T-1\n\nE = [[] for i in range(3*N)]\nfor u,v in UV:\n    u,v = u-1,v-1\n    E[u].append(v+N)\n    E[u+N].append(v+2*N)\n    E[u+2*N].append(v)\n\nfrom collections import deque\ndq = deque([S])\ninf = float(\"inf\")\ndist = [inf]*(3*N)\ndist[S] = 0\n\nwhile dq:\n    v = dq.popleft()\n    for e in E[v]:\n        if dist[e] != inf:\n            continue\n        dist[e] = dist[v]+1\n        if e==T:\n            print(dist[e]//3)\n            return\n        dq.append(e)\n\nprint(-1)", "from collections import deque\n\n\nN, M, *uv, S, T = list(map(int, open(0).read().split()))\ng = [[] for _ in range(N)]\nfor u, v in zip(*[iter(uv)] * 2):\n    g[u - 1].append(v - 1)\nS -= 1\nT -= 1\n\nq = deque([(S, 0)])\ndist = [[-1, -1, -1] for _ in range(N)]\ndist[S][0] = 0\nr = 0\nwhile q:\n    v, r = q.popleft()\n    nr = (r + 1) % 3\n    for nv in g[v]:\n        if dist[nv][nr] >= 0:\n            continue\n        dist[nv][nr] = dist[v][r] + 1\n        q.append((nv, nr))\nprint((dist[T][0] // 3))\n", "from collections import deque\nn, m = list(map(int, input().split()))\nadjacent_list = [[] for i in range(3*n + 3)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    for j in range(1,4):\n        p = j + 3 * u - 3\n        q = (j % 3) + 3 * v - 2\n        #print(\"{} -> {}\".format(p, q))\n        adjacent_list[p].append(q)\ns, t = list(map(int, input().split()))\n\ndef bfs(start, target):\n    que = deque()\n    finished = set()\n    que.append([start, 0])\n    while que:\n        node, dist = que.popleft()\n        if (node, dist % 3) in finished:\n            continue\n        if node == target:\n            return dist // 3\n        for i in adjacent_list[node]:\n            que.append([i, dist+1])\n            finished.add((node, dist % 3))\n    return -1\nprint((bfs(s*3 -2, 3*t-2)))\n\n", "# import bisect\nfrom collections import Counter, deque\n# import copy\n# from heapq import heappush, heappop, heapify\n# from fractions import gcd\n# import itertools\n# from operator import attrgetter, itemgetter\n# import math\n\nimport sys\n\n# import numpy as np\n\nipti = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    n, m = list(map(int, ipti().split()))\n    node_next = [set() for _ in range(n)]\n\n    for i in range(m):\n        u, v = list(map(int, ipti().split()))\n        node_next[u - 1].add(v - 1)\n\n    s, t = list(map(int, ipti().split()))\n    s, t = s - 1, t - 1\n\n    dist = [[INF] * n for _ in range(3)]\n    dist[0][s] = 0\n\n    que = deque()\n    que.append((0, s))\n\n    while que:\n        cstate, cnode = que.popleft()\n        d = dist[cstate][cnode]\n        nstate = (cstate + 1) % 3\n        for nnode in node_next[cnode]:\n            if dist[nstate][nnode] == INF:\n                dist[nstate][nnode] = d + 1\n                que.append((nstate, nnode))\n\n    if dist[0][t] != INF:\n        print((dist[0][t] // 3))\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import sys\n    input = sys.stdin.buffer.readline\n    N, M = list(map(int, input().split()))\n    G = [set() for i in range(N)]\n    G2 = [set() for i in range(N*3)]\n    for i in range(M):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        G[u].add(v)\n    S, T = list(map(int, input().split()))\n    S -= 1\n    T -= 1\n\n    import collections\n    q = collections.deque()\n    q.append((S, 0))\n    D = [-1]*N*3\n    D[3*S] = 0\n    while(q):\n        x, d = q.popleft()\n        for y in G[x]:\n            if D[y*3+(d+1) % 3] < 0:\n                # G2[x*3 + d].add(y)\n                q.append((y, d+1))\n                D[y*3 + (d+1) % 3] = d+1\n\n    if D[T*3] > 0:\n        print((D[T*3] // 3))\n\n    else:\n        print((-1))\n\n\nmain()\n", "from heapq import heappop, heappush, heapify\n\nINF = float(\"inf\")\nn, m = list(map(int, input().split()))\nidx = [[i*3 + j for j in range(3)] for i in range(n)]\ng = [[] for _ in range(n*3)]\nfor _ in range(m):\n    u, v = [int(x)-1 for x in input().split()]\n    for i in range(3):\n        g[idx[u][i]].append((idx[v][(i+1) % 3], 1))\ns, t = [int(x)-1 for x in input().split()]\n\ndef dijkstra(graph, n, s):\n    d = [INF] * n\n    d[s], q = 0, []\n    heappush(q, (0, s))\n    while q:\n        dist, v = heappop(q)\n        if d[v] < dist: continue\n        for nv, cost in graph[v]:\n            if d[nv] > d[v] + cost:\n                d[nv] = d[v] + cost\n                heappush(q, (d[nv], nv))\n    return d\n\nres = dijkstra(g, n*3, idx[s][0])[idx[t][0]]\nprint((-1 if res == INF else res // 3))\n", "from collections import deque\nimport sys\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(3*n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b+n)\n    graph[a+n].append(b+2*n)\n    graph[a+2*n].append(b)\n\ndist = [-3] * (3*n+1)\ndist[0] = 0\ns, t = map(int, input().split())\ndist[s] = 0\n\nd = deque()\nd.append(s)\n\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if dist[i] != -3:\n            continue\n        dist[i] = dist[v] + 1\n        d.append(i)\n\nprint(dist[t]//3)", "MOD = 10 ** 9 + 7\nINF = 10 ** 10\nimport sys\nsys.setrecursionlimit(100000000)\ndy = (-1,0,1,0)\ndx = (0,1,0,-1)\nfrom collections import deque\n\ndef main():\n    n,m = map(int,input().split())\n    G = [[] for _ in range(3*n)]\n    for _ in range(m):\n        u,v = map(int,input().split())\n        u -= 1\n        v -= 1\n        for i in range(3):\n            G[u*3 + i].append(v*3 + (i + 1)%3)\n    \n    s,g = map(int,input().split())\n    s -= 1\n    g -= 1\n\n    q = deque([3*s])\n    dist = [-1] * (3*n)\n    dist[3*s] = 0\n    while q:\n        p = q.popleft()\n        for e in G[p]:\n            if dist[e] < 0:\n                dist[e] = dist[p] + 1\n                q.append(e)\n                \n    print(dist[3*g]//3 if dist[3*g] >= 0 else -1)\ndef __starting_point():\n    main()\n__starting_point()", "def solve():\n  N, M = map(int, input().split(' '))\n  G = [[] for _ in range(N + 10)]\n  dist = [[-1 for _ in range(3)] for _ in range(N + 10)]\n  for _ in range(M):\n    u, v = map(int, input().split(' '))\n    G[u].append(v)\n  S, T = map(int, input().split(' '))\n  que = [[S, 0]]\n  dist[S][0] = 0\n  while que:\n    q = que.pop(0)\n    nv, np = q[0], q[1]\n    for item in G[nv]:\n      if dist[item][(np + 1) % 3] == -1:\n        que.append([item, (np + 1) % 3])\n        dist[item][(np + 1) % 3] = dist[nv][np] + 1\n  if dist[T][0] == -1:\n    return -1\n  else:\n    return dist[T][0] // 3\nprint(solve())", "import sys\nfrom collections import defaultdict, deque\ninput = sys.stdin.readline\nN,M= list(map(int,input().split()))\ng = defaultdict(list)\n\nfor i in range(M):\n    u,v = list(map(int,input().split()))\n    g[u].append(N + v)\n    g[N + u].append(2*N + v)\n    g[2*N + u].append(v)\nS,T= list(map(int,input().split()))\n\ndq = deque([S])\ninf = 10**15\nd = [inf for i in range(3*N+1)]\nd[S] = 0\n\nwhile dq:\n    v = dq.popleft()\n    for nv in g[v]:\n        if d[nv] > d[v] + 1:\n            d[nv] = d[v] + 1\n            dq.append(nv)\n\nif inf == d[T]:\n    print((-1))\nelse:\n    print((d[T]//3))\n\n\n\n", "from sys import stdin\nfrom collections import deque\n\n\ndef input():\n    return stdin.readline().strip()\n\n\ndef bfs():\n    q = deque([3 * S])\n    dist = [-1] * (3 * N)\n    dist[3 * S] = 0\n    while q:\n        p = q.popleft()\n        v, r = divmod(p, 3)\n        nr = (r + 1) % 3\n        for nv in g[v]:\n            np = 3 * nv + nr\n            if dist[np] >= 0:\n                continue\n            dist[np] = dist[p] + 1\n            q.append(np)\n    return dist[3 * T] // 3\n\n\nN, M = list(map(int, input().split()))\ng = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[a].append(b)\nS, T = [int(x) - 1 for x in input().split()]\nprint((bfs()))\n", "#Hopscotch Addict\n\nN,M=list(map(int,input().split()))\ngraph={(i,j):[] for i in range(1,N+1) for j in range(1,4)}\nfor _ in range(M):\n    u,v=list(map(int,input().split()))\n    graph[(u,1)].append((v,2))\n    graph[(u,2)].append((v,3))\n    graph[(u,3)].append((v,1))\nS,T=list(map(int,input().split()))\n\nimport heapq\ndef dijkstra(s,graph):\n    dist={(i,j):float(\"inf\") for i in range(1,N+1) for j in range(1,4)}\n    dist[(s,3)]=0\n    pq=[]\n    heapq.heapify(pq)\n    heapq.heappush(pq,(0,(s,3)))\n    while pq:\n        x=heapq.heappop(pq)\n        node,mini_dis=x[1],x[0]\n        for next_node in graph[node]:\n            newlen=dist[node]+1\n            if newlen<dist[next_node]:\n                heapq.heappush(pq,(newlen,next_node))\n                dist[next_node]=newlen\n    return dist\nK=dijkstra(S,graph)[(T,3)]\nif K==float(\"inf\"):\n    print((-1))\nelse:\n    print((K//3))\n\n", "import copy\n\nn, m = map(int,input().split())\nedge = []\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    edge.append(list(map(int,input().split())))\n    graph[edge[-1][0]].append(edge[-1][1])\ns, g = map(int,input().split())\n\nINF = 10**18\nans = [[INF, INF, INF] for i in range(n+1)]\nq = [s]\nd = 0\nwhile q:\n    nq = []\n    d += 1\n    p = d % 3\n    for cf in q:\n        for ct in graph[cf]:\n            if ans[ct][p] == INF:\n                ans[ct][p] = d\n                nq.append(ct)\n    q = copy.deepcopy(nq)\nif ans[g][0] == INF:\n    print(-1)\nelse:\n    print(ans[g][0]//3)", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N * 3))\n    for _ in range(M):\n        u, v = (int(x) - 1 for x in input().split())\n        g[u].add(v + N)\n        g[u + N].add(v + N + N)\n        g[u + N + N].add(v)\n\n    S, T = (int(x) - 1 for x in input().split())\n\n    dist = [-1] * (N * 3)\n    dist[S] = 0\n\n    dq = deque()\n    dq.append(S)\n    while dq:\n        v = dq.popleft()\n        for u in g[v]:\n            if ~dist[u]: continue\n            dist[u] = dist[v] + 1\n            dq.append(u)\n\n    if dist[T] % 3:\n        print((-1))\n        return\n\n    print((dist[T] // 3))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\ndef bfs(start, goal, g, n, visited):\n    visited1 = [False]*(n+1)\n    visited2 = [False]*(n+1)\n    q = deque([start])\n    visited[start] = 0\n    while q:\n        curr_node = q.popleft()\n        if curr_node == goal: \n            return\n        for next1_node in g[curr_node]:\n            if visited1[next1_node]: continue\n            visited1[next1_node] = True\n            for next2_node in g[next1_node]:\n                if visited2[next2_node]: continue\n                visited2[next2_node] = True\n                for next3_node in g[next2_node]:\n                    if visited[next3_node] >= 0: continue\n                    visited[next3_node] = visited[curr_node] + 1\n                    q.append(next3_node)\n\n\n\ndef main():\n    n,m = map(int, input().split())\n    g = [ [] for _ in range(n+1)]\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        g[u].append(v)\n\n    s,t = map(int, input().split())\n    \n\n    visited = [-1]*(n+1)\n    visited[0] = 0\n\n    bfs(s, t, g, n, visited)\n    print(visited[t])\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = map(int, input().split())\nto = [[] for i in range(N+1)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    to[a].append(b)\n\nS, T = map(int, input().split())\n\nfrom collections import deque\n\nq = deque([(S, 0)])\nv = [[-1] * 3 for i in range(N+1)]\n\nwhile q:\n    a, t = q.popleft()\n    b = t % 3\n    if v[a][b] != -1:\n        continue\n    v[a][b] = t\n    t += 1\n    for x in to[a]:\n        q.append((x, t))\n    #print(q)\n\n\nif v[T][0] == -1:\n    print(\"-1\")\nelse:\n    print(v[T][0] // 3)", "n,m=list(map(int,input().split()))\nuv=[list(map(int, input().split())) for _ in range(m)]\ns,t=list(map(int,input().split()))\n\ngraph = [[] for _ in range(n)]\nfor v in uv:\n    graph[v[0]-1].append(v[1]-1)\n# print(graph)\ns-=1\nt-=1\n\nis_checked=[[0]*3 for _ in range(n)]\nis_checked[s][0]=1\n\nans=-1\n\nfrom collections import deque\nq=deque()\nq.append([s,0])\n\nwhile q:\n    v, cnt=q.popleft()\n    if v==t and cnt%3==0:\n        ans=cnt//3\n        break\n    for i in graph[v]:\n        if is_checked[i][(cnt+1)%3]==0:\n            q.append([i, cnt+1])\n            is_checked[i][(cnt+1)%3]=1\n# print(is_checked)\nprint(ans)\n\n", "from collections import deque\nINF = 10**9\n\nN, M = map(int,input().split())\n\nG = [[] for _ in range(3*N)]\nfor _ in range(M):\n    u, v = map(int,input().split())\n    u, v = u-1, v-1\n\n    G[u].append(v+N)\n    G[u+N].append(v+2*N)\n    G[u+2*N].append(v)\n\ns, t = map(int,input().split())\ns, t = s-1, t-1\n\ndist = [INF] * (3*N)\ndist[s] = 0\n\nQ = deque([s])\nwhile len(Q) > 0:\n    u = Q.popleft()\n    for v in G[u]:\n        if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            Q.append(v)\n\nif dist[t] == INF:\n    print(-1)\nelse: \n    print(dist[t] // 3)", "from collections import deque\nn, m = list(map(int, input().split()))\ngraph = [[[] for _ in range(3)] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    graph[u][0].append([v, 1])\n    graph[u][1].append([v, 2])\n    graph[u][2].append([v, 0])\n\n\ns, t = list(map(int, input().split()))\nq = deque([[s, 0]])\nvisited = [[False] * 3 for _ in range(n+1)]\nvisited[s][0] = True\ndist = [[-3] * 3 for _ in range(n+1)]\ndist[s][0] = 0\nwhile q:\n    num, cnt = q.popleft()\n    for i, j in graph[num][cnt]:\n        if visited[i][j]:\n            continue\n        q.append([i, j])\n        visited[i][j] = True\n        dist[i][j] = dist[num][cnt] + 1\n\nprint((dist[t][0]//3))\n", "N,M = map(int,input().split())\nUV = [tuple(map(int,input().split())) for i in range(M)]\nS,T = map(int,input().split())\nS -= 1\nT -= 1\nes = [[] for _ in range(3*N)]\nfor u,v in UV:\n    u,v = u-1,v-1\n    es[3*u].append(3*v+1)\n    es[3*u+1].append(3*v+2)\n    es[3*u+2].append(3*v)\n\nfrom collections import deque\ndist = [0] * (3*N)\nvisited = [0] * (3*N)\nvisited[3*S] = 1\nq = deque([3*S])\nwhile q:\n    v = q.popleft()\n    if v==3*T:\n        assert dist[v]%3==0\n        print(dist[v]//3)\n        return\n    for to in es[v]:\n        if visited[to]: continue\n        visited[to] = 1\n        dist[to] = dist[v] + 1\n        q.append(to)\nprint(-1)", "from collections import deque\nn, m = list(map(int, input().split()))\ngraph = [[[] for _ in range(3)] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    graph[u][0].append([v, 1])\n    graph[u][1].append([v, 2])\n    graph[u][2].append([v, 0])\n\n\ns, t = list(map(int, input().split()))\nq = deque([[s, 0]])\nvisited = [[False] * 3 for _ in range(n+1)]\nvisited[s][0] = True\ndist = [[-3] * 3 for _ in range(n+1)]\ndist[s][0] = 0\nwhile q:\n    num, cnt = q.popleft()\n    for i, j in graph[num][cnt]:\n        if visited[i][j]:\n            continue\n        q.append([i, j])\n        visited[i][j] = True\n        dist[i][j] = dist[num][cnt] + 1\n\nprint((dist[t][0]//3))\n", "N,M = map(int,input().split())\n\ngraph = [[] for i in range(N)]\n\nfor i in range(M):\n  u,v = map(int,input().split())\n  graph[u - 1].append(v - 1)\n\nS,T = map(int,input().split())\nS -= 1\nT -= 1\n\nfrom collections import deque\nq = deque([])\nq.append([S, 0, 0])\n\nseen = [[False] * 3 for i in range(N)]\n\nwhile q:\n  v,cost,step = q.popleft()\n  if seen[v][step]:\n    continue\n  seen[v][step] = True\n  if step == 0:\n    if v == T:\n      print(cost)\n      break\n    cost += 1\n    step = 3\n  for u in graph[v]:\n    q.append([u, cost, step - 1])\nelse:\n  print(-1)", "from collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for i in range(3*N)]\nfor i in range(M):\n  u, v = map(int, input().split())\n  u -= 1; v -= 1\n  graph[3*u].append(3*v+1)\n  graph[3*u+1].append(3*v+2)\n  graph[3*u+2].append(3*v)\n\nS, T = map(int, input().split())\nS -= 1; T -= 1\ndist = [-1] * (3*N)\ndist[3*S] = 0\nd = deque([3*S])\nwhile d:\n  node = d.popleft()\n  children = graph[node]\n  for child in children:\n    if dist[child] < 0:\n      dist[child] = dist[node] + 1\n      d.append(child)\n\nif dist[3*T] > 0:\n  print(dist[3*T] // 3)\nelse:\n  print(-1)", "from collections import deque\nimport sys\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\nNV = 3*n\nedges = [[]for _ in range(NV)]\n\n\ndef to_v(i, j):\n    return 3*i+j\n\n\nfor _ in range(m):\n    u, v = list([int(x)-1 for x in input().split()])\n    for j in range(3):\n        edges[to_v(u, j)].append(to_v(v, (j+1) % 3))\ns, t = list([int(x)-1 for x in input().split()])\ninit_v = to_v(s, 0)\nINF = 10**18\ndist = [INF]*NV\ndist[init_v] = 0\nnext_v = deque([init_v])\nwhile next_v:\n    v = next_v.popleft()\n    for v2 in edges[v]:\n        if dist[v2] <= dist[v]+1:\n            continue\n        dist[v2] = dist[v]+1\n        next_v.append(v2)\n\nprint((dist[to_v(t, 0)]//3 if dist[to_v(t, 0)] != INF else -1))\n", "import sys, bisect, math, itertools, heapq, collections\nfrom operator import itemgetter\n# a.sort(key=itemgetter(i)) # i\u756a\u76ee\u8981\u7d20\u3067sort\nfrom functools import lru_cache\n# @lru_cache(maxsize=None)\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp():\n    '''\n    \u4e00\u3064\u306e\u6574\u6570\n    '''\n    return int(input())\ndef inpl():\n    '''\n    \u4e00\u884c\u306b\u8907\u6570\u306e\u6574\u6570\n    '''\n    return list(map(int, input().split()))\nclass Dijkstra():\n    def __init__(self):\n        self.e = collections.defaultdict(list)\n\n    def add(self, u, v, d, directed=False):\n        \"\"\"\n        Parameters\n        ----------\n        u:int\n            from node\n        v:int\n            to node\n        d:int\n            cost\n        directed:bool\n            there is direction\n        \"\"\"\n        if directed is False:\n            self.e[u].append([v, d])\n            self.e[v].append([u, d])\n        else:\n            self.e[u].append([v, d])\n\n    def delete(self, u, v):\n        \"\"\"\n        Parameters\n        ----------\n        u:int\n            from node\n        v:int\n            to node\n        \"\"\"\n        self.e[u] = [_ for _ in self.e[u] if _[0] != v]\n        self.e[v] = [_ for _ in self.e[v] if _[0] != u]\n\n    def Dijkstra_search(self, s):\n        \"\"\"\n        Parameters\n        ----------\n        s:int\n            start node\n\n        Return\n        ----------\n        d:dict(int:int)\n            shortest cost from start node to each node \n            {to : cost}\n\n        prev:dict(int:int)\n            previous node on the shortest path\n            {from : to}\n        \"\"\"\n        d = collections.defaultdict(lambda: float('inf'))\n        prev = collections.defaultdict(lambda: None)\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s)) # (cost, \u63a2\u7d22\u5019\u88dc\u30ce\u30fc\u30c9)\n        v = collections.defaultdict(bool) # \u78ba\u5b9a\u6e08\u304b\u3069\u3046\u304b\n        while len(q):\n            # \u30ce\u30fc\u30c9u\u306b\u304a\u3051\u308b\u30b3\u30b9\u30c8\u306fk\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for uv, ud in self.e[u]: # cost is ud from u to uv\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    prev[uv] = u\n                    heapq.heappush(q, (vd, uv))\n\n        return d, prev\nn, m = inpl()\ngraph=Dijkstra()\nfor i in range(m):\n    u, v = inpl()\n    graph.add(u,v+n,1,directed=True)\n    graph.add(u+n,v+n+n,1,directed=True)\n    graph.add(u+n+n,v,1,directed=True)\ns,t=inpl()\nans = 0\nd, _ = graph.Dijkstra_search(s)\nans = d[t] if d[t] != INF else - 1\n# print(d)\nprint(ans//3)", "from collections import deque\nn,m = map(int,input().split())\nl = [[] for i in range(n+1)]\nrl = [[-1 for i in range(n+1)] for i in range(3)]\nfor i in range(m):\n    u,v = map(int,input().split())\n    l[u].append(v)\ns,t = map(int,input().split())\nd = deque()\nans = -1\nd.append([s,0])\nrl[0][s] = 0\nwhile len(d):\n    now,count = d.popleft()\n    for i in l[now]:\n        if i == t and count % 3 == 2:\n            ans = (count + 1)//3\n            break\n        else:\n            if rl[(count%3 + 1)%3][i] == -1:\n                d.append([i,count+1])\n                rl[(count%3+1)%3][i] = count+1\n    if ans >= 0:\n        break\nprint(ans)", "import heapq\nimport sys\ninput = sys.stdin.readline\nn,m = map(int,input().split())\nINF = 10**18\nedge = [[] for i in range(n)]\nfor i in range(m):\n    x,y = map(int,input().split())\n    edge[x-1].append(y-1)\ns,t = map(int,input().split())\n\ndef dijkstra_heap(s,g,p):\n    d = [[INF] * p for i in range(n)] \n    used = [[True] * p for i in range(n)] \n    used[s][0] = False\n    ed_list = []\n    for es in edge[s]:\n        heapq.heappush(ed_list,[1,es,1]) # \u56de\u6570\u3001\u5411\u304b\u3046\u9802\u70b9\u3001\u3042\u307e\u308a\n    while len(ed_list):\n        ken,v,md = heapq.heappop(ed_list)\n        if not used[v][md]:\n            continue\n        d[v][md] = ken\n        used[v][md] = False\n        if not used[g][0]:\n            break\n        for e in edge[v]:\n            if used[e][(md+1)%p]:\n              if (md+1)%p == 1:\n                heapq.heappush(ed_list,[ken+1,e,1])\n              else:\n                heapq.heappush(ed_list,[ken,e,(md+1)%p])\n    return d[g][0]\n\nans = dijkstra_heap(s-1,t-1,3)\nif ans == INF:\n  print(-1)\nelse:\n  print(ans)", "from collections import defaultdict\nn,m=list(map(int,input().split()))\nd = defaultdict(list)\nfor _ in range(m):\n    u,v=list(map(int,input().split()))\n    d[u-1].append(v-1)\nS,T=list(map(int,input().split()))\ns=S-1\nt=T-1\ncd=[[0]*3 for _ in range(n)]\ncd[s][0]=1\nans=-1\nq=[]\nq.append([s,0])\nwhile q:\n    v,c=q.pop(0)\n    if v==t and c%3==0:\n        ans=c//3\n        break\n    for i in d[v]:\n        if cd[i][(c+1)%3]==0:\n            q.append([i,c+1])\n            cd[i][(c+1)%3]=1\nprint(ans)\n", "from sys import stdin\nfrom collections import deque\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,m=map(int,readline().split())\n    G=[[] for _ in range(n*3)]\n    for i in range(m):\n        a,b=map(lambda x:int(x)-1,readline().split())\n        for j in range(3):\n            G[3*a+j].append(3*b+(j+1)%3)\n\n    s,t=map(lambda x:int(x)-1,readline().split())\n    s*=3\n    t*=3\n    #bfs\n    d=deque([s])\n    flags=[-1]*(3*n)\n    flags[s]=0\n    while len(d)>0:\n        now=d.popleft()\n        for nex in G[now]:\n            if flags[nex]==-1:\n                flags[nex]=flags[now]+1\n                d.append(nex)\n\n    print(flags[t]//3)\n\ndef __starting_point():\n    main()\n__starting_point()", "import collections\n\nn, m = map(int, input().split())\ngraph = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\nflag = [False for i in range(n + 1)]\ns, t = map(int, input().split())\n\nqueue = collections.deque([s])\ncount = 0\nwhile True:\n    for i in range(2):\n        temp = set()\n        while queue:\n            test = queue.popleft()\n            for j in graph[test]:\n                if j not in temp:\n                    temp.add(j)\n        for j in temp:\n            queue.append(j)\n    temp = set()\n    while queue:\n        test = queue.popleft()\n        for i in graph[test]:\n            if flag[i] == True:\n                continue\n            else:\n                if i not in temp:\n                    temp.add(i)\n                    flag[i] = True\n    count += 1\n    if flag[t] == True:\n        print(count)\n        break\n    if len(temp) == 0:\n        print(-1)\n        break\n    for i in temp:\n        queue.append(i)", "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import permutations\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\nimport queue\n\nN, M = list(map(int, input().split()))\nif M == 0:\n    print((-1))\n    return\nadj = [[] for _ in range(N)]\nfor i in range(M):\n    u, v = list(map(int, input().split()))    \n    u -= 1\n    v -= 1\n    adj[u].append(v)\nS, T = list(map(int, input().split()))\nS -= 1\nT -= 1\n\ndist = [[INF,INF,INF] for _ in range(N+1)]\n \nd = 0\nq = [S]\nwhile q:\n  d += 1\n  r = d % 3\n  qq = []\n  for u in q:\n    for v in adj[u]:\n      if dist[v][r] == INF:\n        dist[v][r] = d\n        qq.append(v)\n  q = qq\n \nd = dist[T][0]\nanswer = -1 if d == INF else d // 3\nprint(answer)\n\n\n", "from collections import deque\n\nn, m = map(int, input().split())\nadj_list = [[] for _ in range(3 * n)]\nfor _ in range(m):\n  u, v = map(int, input().split())\n  adj_list[3 * u - 3].append(3 * v - 2)\n  adj_list[3 * u - 2].append(3 * v - 1)\n  adj_list[3 * u - 1].append(3 * v - 3)\n\ns, t = map(int, input().split())\ndist = [-1] * (3 * n)\nqueue = deque([3 * s - 3])\ndist[3 * s - 3] = 0\nwhile queue:\n  vertex = queue.popleft()\n  for next_vertex in adj_list[vertex]:\n    if dist[next_vertex] != -1:\n      continue\n    dist[next_vertex] = dist[vertex] + 1\n    queue.append(next_vertex)\nt_distance = dist[3 * t - 3]\nif t_distance == -1:\n  print(-1)\nelse:\n  print(t_distance // 3)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    def dfs(v, p):\n        for u in edge_extend[p][v]:\n            next_p = 0 if p == 2 else p + 1\n            if dist[next_p][u] <= dist[p][v] + 1:\n                continue\n            else:\n                dist[next_p][u] = dist[p][v] + 1\n                dfs(u, next_p)\n\n    n, m = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        edge[u - 1].append(v - 1)\n    s, t = list(map(int, input().split()))\n\n    edge_extend = []\n    for _ in range(3):\n        edge_extend.append(edge)\n\n    dist = [[f_inf] * n for _ in range(3)]\n    dist[0][s - 1] = 0\n    que = deque([[0, s - 1]])\n    while que:\n        p, v = que.popleft()\n        next_p = 0 if p == 2 else p + 1\n        for u in edge_extend[p][v]:\n            if dist[next_p][u] > dist[p][v] + 1:\n                dist[next_p][u] = dist[p][v] + 1\n                que.append([next_p, u])\n\n    print((dist[0][t - 1] // 3 if dist[0][t - 1] != f_inf else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\nn, m = list(map(int, input().split()))\nedges = [[] for i in range(3*n)]\nfor i in range(m):\n    u,v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    edges[u].append(v+n)\n    edges[u+n].append(v+2*n)\n    edges[u+2*n].append(v)\n\ns,t = list(map(int, input().split()))\ns -= 1\nt -= 1\nINF = 1<<50\ndists = [INF] * (3*n)\n\nq = deque([])\nq.append(s)\ndists[s] = 0\n\nwhile len(q)>0:\n    v = q.popleft()\n    for u in edges[v]:\n        if dists[u] != INF: continue\n        q.append(u)\n        dists[u] = dists[v] + 1\n\nif dists[t] == INF:\n    print((-1))\nelse:\n    print((dists[t]//3))\n", "\n\nfrom collections import deque\n\n\nN,M = list(map(int, input().split()))\n\n\n\nes = [[] for _ in range(3*N)]\nfor _ in range(M):\n    u,v = list(map(int, input().split()))\n    u,v = u-1, v-1\n    es[u].append(N + v)\n    es[N + u].append(2*N + v)\n    es[2*N + u].append(v)\n\nS,T = list(map(int, input().split()))\n\nq = deque()\nq.append(S-1)\nINF = float(\"inf\")\ndist = [INF] * (3*N)\ndist[S-1] = 0\n\nwhile q:\n    curr = q.popleft()\n    \n    for nxt in es[curr]:\n        if dist[nxt] == INF:\n            dist[nxt] = dist[curr] + 1\n            if nxt == T-1:\n                print((dist[nxt] // 3))\n                \n                return\n            \n            q.append(nxt)\n\nprint((-1))\n", "from collections import deque\nimport sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn, m, *uv, s, t = list(map(int, read().split()))\nm = iter(uv)\nUV = list(zip(m, m))\ngraph = [[] for _ in range(3 * n)]\nfor u, v in UV:\n    u -= 1\n    v -= 1\n    graph[u].append(v + n)\n    graph[u + n].append(v + 2 * n)\n    graph[u + 2 * n].append(v)\ns -= 1\nt -= 1\ninfi = 10 ** 20\ndist = [-1] * (3 * n)\n\n\ndef bfs(s):\n    que = deque()\n    dist[s] = 0\n    que.append(s)\n    while que:\n        v = que.popleft()\n        if v == t:\n            return dist[t]\n        d = dist[v]\n        for u in graph[v]:\n            if dist[u] > 0:\n                continue\n            dist[u] = d + 1\n            que.append(u)\n    return -1\n\n\nans = bfs(s)\nif ans > 0:\n    ans //= 3\nprint(ans)\n", "n, m = list(map(int, input().split()))\nto = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    to[u - 1].append(v - 1)\n\ns, t = list(map(int, input().split()))\ns -= 1\nt -= 1\n\ncnt = 0\nphase = 0\nq = [s]\nvisited = [[False] * 3 for _ in range(n)]\nwhile q:\n    nextq = []\n    for v in q:\n        if visited[v][phase]:\n            continue\n        visited[v][phase] = True\n        if v == t and phase == 0:\n            print(cnt)\n            return\n        nextq += to[v]\n    if phase == 0:\n        cnt += 1\n    phase = (phase + 1) % 3\n    q = nextq\nprint((-1))\n", "inf=10**12\nn,m=map(int,input().split())\nnode=[[]for _ in range(n)]\ndis=[inf]*(n*3)\nfor _ in range(m):\n\ta,b=map(int,input().split())\n\tnode[a-1].append(b-1)\ns,t=map(int,input().split())\ndis[(s-1)*3]=0\nfrom collections import deque\nqueue=deque([(s-1)*3])\nwhile queue:\n\tr=queue.popleft()\n\tp=(r%3+1)%3\n\tfor x in node[r//3]:\n\t\tif dis[x*3+p]==inf:\n\t\t\tdis[x*3+p]=dis[r]+1\n\t\t\tqueue.append(x*3+p)\nprint(dis[(t-1)*3]//3 if dis[(t-1)*3]!=inf else -1)", "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import permutations\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\nimport queue\n\nN, M = list(map(int, input().split()))\nif M == 0:\n    print((-1))\n    return\nadj = [[] for _ in range(N)]\nfor i in range(M):\n    u, v = list(map(int, input().split()))    \n    u -= 1\n    v -= 1\n    adj[u].append(v)\nS, T = list(map(int, input().split()))\nS -= 1\nT -= 1\n\ndist = [[INF,INF,INF] for _ in range(N+1)]\n \nq = queue.Queue()\nq.put((S, 0))\ndist[S][0] = 0\nwhile not q.empty():\n    u, l = q.get()\n    for v in adj[u]:\n        nl = (l + 1) % 3\n        if dist[v][nl] != INF:\n            continue\n        dist[v][nl] = dist[u][l] + 1\n        q.put((v, nl))\nd = dist[T][0]\nanswer = -1 if d == INF else d // 3\nprint(answer)\n\n\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        edge[u - 1].append(v - 1)\n    s, t = list(map(int, input().split()))\n\n    dist = [[f_inf] * 3 for _ in range(n)]\n    que = deque([])\n    que.append([s - 1, 0])\n    dist[s - 1][0] = 0\n    while que:\n        v, l = que.popleft()\n        for u in edge[v]:\n            nl = (l + 1) % 3\n            if dist[u][nl] == f_inf:\n                dist[u][nl] = dist[v][l] + 1\n                que.append([u, nl])\n\n    res = dist[t - 1][0]\n    print((-1 if res == f_inf else res // 3))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import copy\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\nedge = []\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    edge.append(list(map(int,input().split())))\n    graph[edge[-1][0]].append(edge[-1][1])\ns, g = map(int,input().split())\n\nINF = 10**18\nans = [[INF, INF, INF] for i in range(n+1)]\nq = [s]\nd = 0\nwhile q:\n    nq = []\n    d += 1\n    p = d % 3\n    for cf in q:\n        for ct in graph[cf]:\n            if ans[ct][p] == INF:\n                ans[ct][p] = d\n                nq.append(ct)\n    q = copy.deepcopy(nq)\nif ans[g][0] == INF:\n    print(-1)\nelse:\n    print(ans[g][0]//3)", "import copy\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    u, v = map(int,input().split())\n    graph[u].append(v)\ns, g = map(int,input().split())\n\nINF = 10**7\nans = [[INF, INF, INF] for i in range(n+1)]\nq = [s]\nd = 0\nwhile q:\n    nq = []\n    d += 1\n    p = d % 3\n    for cf in q:\n        for ct in graph[cf]:\n            if ans[ct][p] == INF:\n                ans[ct][p] = d\n                nq.append(ct)\n    q = nq\nif ans[g][0] == INF:\n    print(-1)\nelse:\n    print(ans[g][0]//3)", "from sys import stdin\nfrom collections import deque\n\n\ndef input():\n    return stdin.readline().strip()\n\n\ndef bfs():\n    q = deque([S])\n    dist = [-1] * (3 * N)\n    dist[S] = 0\n    while q:\n        v = q.popleft()\n        for nv in g[v]:\n            if dist[nv] >= 0:\n                continue\n            dist[nv] = dist[v] + 1\n            q.append(nv)\n    return dist[T] // 3\n\n\nN, M = list(map(int, input().split()))\ng = [[] for _ in range(3 * N)]\nfor _ in range(M):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[3 * a].append(3 * b + 1)\n    g[3 * a + 1].append(3 * b + 2)\n    g[3 * a + 2].append(3 * b)\nS, T = [3 * (int(x) - 1) for x in input().split()]\nprint((bfs()))\n", "#\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\n#\u5358\u4e00\u59cb\u70b9\u6700\u77ed\u7d4c\u8def(\u6b63\u306e\u8fba\u306e\u307f)\n#s=\u59cb\u70b9 n=\u9802\u70b9\u6570 edge\u306f\u96a3\u63a5\u30ea\u30b9\u30c8(edge=[[[1,2],[2,4]],[[2,1]],[]])\n#0-indexed\nfrom heapq import heappop,heappush\ndef dijkstra(s,n,edge):\n  inf=10**20\n  ans=[inf]*n\n  ans[s]=0\n  h=[[0,s]]\n  while h:\n    c,v=heappop(h)\n    if ans[v]<c:continue\n    for u,t in edge[v]:\n      if c+t<ans[u]:\n        ans[u]=c+t\n        heappush(h,[c+t,u])\n  return ans\nn,m=list(map(int,input().split()))\nedge=[[]for _ in range(n*3)]\nfor _ in range(m):\n\tu,v=list(map(int,input().split()))\n\tu-=1\n\tv-=1\n\tedge[u*3].append([v*3+1,1])\n\tedge[u*3+1].append([v*3+2,1])\n\tedge[u*3+2].append([v*3,1])\ns,t=list(map(int,input().split()))\ns-=1\nt-=1\ndij=dijkstra(s*3,n*3,edge)\nif dij[t*3]==10**20:print((-1))\nelse:print((dij[t*3]//3))\n", "def main():\n  N, M = map(int, input().split())\n  edge = [[[] for _ in range(3)] for _ in range(N)]\n  for i in range(M):\n    u, v = map(int, input().split())\n    edge[u-1][0].append([v-1,1])\n    edge[u-1][1].append([v-1,2])\n    edge[u-1][2].append([v-1,0])\n  d = [[-1]*3 for _ in range(N)]\n  S, T = map(int, input().split())\n  d[S-1][0] = 0\n  que = [[S-1, 0]]\n  while len(que)>0:\n    now = que.pop(0)\n    for nex in edge[now[0]][now[1]]:\n      if d[nex[0]][nex[1]] != -1:continue\n      d[nex[0]][nex[1]] = d[now[0]][now[1]]\n      if now[1] == 2:\n        d[nex[0]][nex[1]] += 1\n      que.append(nex)\n  print(d[T-1][0])\n  \ndef __starting_point():\n  main()\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u53cc\u65b9\u5411\u30b0\u30e9\u30d5\u3067\u5e45\u512a\u5148\u63a2\u7d22\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\ng = [set([]) for _ in range(n)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    g[a].add(b)\n\ns, t = list(map(int, input().split()))\ns, t = s-1, t-1\n\n#\u5e45\u512a\u5148\u63a2\u7d22\nq = deque()\nlevel = [[-1]*n for i in range(3)]\nq.append((s, 0))\nlevel[0][s] = 0\nwhile len(q)>0:\n    cur, hp = q.popleft()\n    lvl = level[hp][cur]\n    for i in g[cur]:\n        if level[(hp+1)%3][i]==-1:\n            #\u968e\u5c64\n            level[(hp+1)%3][i] = lvl + 1\n            q.append((i, (hp+1)%3))\nprint((level[0][t]//3))\n"]
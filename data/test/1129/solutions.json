["n = int(input())\narr = [int(x) for x in input().split()]\narr.sort()\nif(n%2):\n    print(arr[n//2])\nelse:\n    print(arr[n//2-1])", "n = int(input())\na = sorted(map(int, input().split(' ')))\nprint(a[(n - 1) // 2])\n", "#imports\nimport sys\nsys.setrecursionlimit(30000)\n\nfrom collections import Counter, defaultdict, deque\nfrom math import ceil, floor, factorial, fsum, isinf, exp, log, log10, log2, isfinite, sqrt\nfrom math import pi as PI, e as E\nfrom fractions import Fraction\nfrom itertools import starmap, tee, chain, filterfalse, combinations as combos\nfrom itertools import permutations as perms, product as prod, combinations_with_replacement as rcombos\nfrom functools import reduce, partial\nimport operator as ops #lt, le, eq, ne, ge, gt,  xor  notit, lshift, rshift,      neg, add, mul, sub,\nfrom operator import __not__ as notit\nfrom operator import __abs__ as absit\nfrom operator import __or__ as orit\n\n#PI, E, PHI, INF\nPHI, PHI2 = (1 + 5 ** 0.5) / 2, (5 ** 0.5 - 1) / 2\nINF = float('inf')\n\n#structures\nclass TreeNode:\n    def __init__(self, v):\n        self.val = v\n        self.left = None\n        self.right = None\n\n#Bit Manipulation\n#<<, >>, bin(), int(s, 2)\ndef setBit(x, offset):\n    return x | 1 << offset #RHS: mask\ndef clearBit(x, offset):\n    return x & ~(1 << offset) #RHS: mask\ndef getBit(x, offset):\n    return 1 if testBit(x, offset) > 0 else 0\ndef testBit(x, offset):\n    return x & 1 << offset #RHS: mask\ndef flipBitAt(x, offset):\n    return x ^ 1 << offset #RHS: mask\ndef flipBits(x, length=-1): #default: x.bit_length() - 1\n    length = x.bit_length()-1 if length == -1 else length\n    return x ^ (1 << length) - 1\ndef numBits(x):\n    return x.bit_length() #int.bit_length()\ndef countOnes(x):\n    return bin(x).count('1')\ndef countZeros(x, length=-1):\n    length = x.bit_length() if length == -1 else length\n    return length - countOnes(x)\n\n#IO\ndef getList(tcast=str):\n    return [tcast(x) for x in input().strip().split(' ')]\ndef getItems(*tcast):\n    return map(lambda f, x: f(x), tcast, getList())\ndef getVal(tcast=str):\n    return tcast(input().strip())\ndef getMatrix(r, tcast=str):\n    return [getList(tcast) for row in range(r)]\n\n#Math\ndef isOdd(n):\n    return n & 1 > 0\ndef isEven(n):\n    return not n & 1\ndef numDigits(n):\n    return len(str(n)) - (1 if n < 0 else 0)\ndef getRecip(f):\n    return Fraction(f.denominator, f.numerator)\ndef _gcd(a, b):\n    while b: #is not zero\n        a, b = b, a % b\n    return a\ndef gcd(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        if cur == 1:\n            return cur\n        cur = _gcd(cur, n)\n    return cur\ndef _lcm(a, b):\n    return (a // gcd(a, b)) * b\ndef lcm(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        cur = _lcm(cur, n)\n    return cur\ndef primesUpto(n):\n    isp = [True] * (n + 1)\n    isp[0], isp[1] = False, False\n    primes = []\n    for i, x in enumerate(isp): #for each number\n        if x: #found a prime\n            primes.append(i)\n            mults = i * i\n            while mults <= n:\n                isp[mults] = False\n                mults += i\n    return primes\ndef primeFactor(n): #without a sieve\n    factors = Counter()\n    while not n&1:\n        factors[2] += 1\n        n >>= 1\n    trynum = 3\n    while trynum <= ceil(sqrt(n)): #just in case\n        while n % trynum == 0:\n            factors[trynum] += 1\n            n //= trynum\n        trynum += 2\n    if n != 1:\n        factors[n] += 1\n    return factors\ndef isPrime(n): #num -> boolean\n    if n&1 and n >= 2:\n        trynum = 3\n        limit = ceil(sqrt(n))\n        while trynum < limit:\n            if n % trynum == 0:\n                return False\n            trynum += 2\n        else:\n            return True\n    else:\n        return False\ndef nthFib(n):\n    if n <= 2:\n        return 1\n    else:\n        a, b = 1, 1\n        while n > 2:\n            a, b = b, a + b\n            n -= 1\n        return b\n\n#Iteration\ndef zipNWith(f, *x): #xs, ys, ... zs -> elementwise f -> os #return map(lambda *y: f(y), x) #list way: [f(y) for y in zip(*xs)]\n    return (f(y) for y in zip(*x))\ndef zipWith(f, xs, ys):\n    return (f(x, y) for x, y in zip(xs, ys))\ndef flatten(xs):\n    return reduce(ops.concat, xs)\ndef quantify(pred, it):\n    return sum(map(pred, it))\ndef dotproduct(xs, ys):\n    return sum(map(ops.mul, xs, ys))\ndef pairwise(it):\n    a, b = tee(it)\n    next(b, None)\n    return zip(a, b)\ndef bipartition(pred, it):\n    t, f = tee(it)\n    return filter(pred, t), filterfalse(pred, f)\ndef powerset(it):\n    s = list(it)\n    return chain.from_iterable(combos(s, r) for r in range(len(s) + 1))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#Input\n\n#Body\n\n#Output\nn = getVal(int)\nnums = getList(int)\nnums.sort()\nmid = (n-1) // 2\nprint(nums[mid])", "n=int(input())\na=list(map(int, input().split()))\nprint(sorted(a)[(n-1)>>1])", "from collections import defaultdict\nimport sys\n\ndef __starting_point():\n    #n, m = list(map(int, input().split()))\n    n = int(input())\n    index = list(map(int, input().split()))\n    index.sort()\n    print(index[(n - 1) // 2])\n\n__starting_point()", "N = int(input())\nX = list(map(int, input().split()))\nX.sort()\nif N % 2 != 0:\n    print(X[N // 2])\nelse:\n    left = sum([abs(x - X[N // 2 - 1]) for x in X])\n    right = sum([abs(x - X[N // 2]) for x in X])\n    if left <= right:\n        print(X[N // 2 - 1])\n    elif left > right:\n        print(X[N // 2])\n", "'''\nYou are given n points on a line with their coordinates x_i. \nFind the point x so the sum of distances to the given points is minimal.\nInput\n\nThe first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093\u00b7105) \n\u2014 the number of points on the line.\n\nThe second line contains n integers x[i] (\u2009-\u2009109\u2009\u2264\u2009x[i]\u2009\u2264\u2009109) \n\u2014 the coordinates of the given n points.\n\nOutput\n\nPrint the only integer x \u2014 the position of the optimal point on the line. \nIf there are several optimal points print the position of the \nleftmost one. It is guaranteed that the answer is always the integer.\n'''\n\nimport io\nimport sys\nimport time\nimport random\n#~ start = time.clock()\n#~ test ='''4\n#~ 1 2'''\n\n#~ sys.stdin = io.StringIO(test)\n\nn = int(input())\nx = [int(x) for x in input().split()]\n\nx.sort()\nif len(x)%2==0:\n   print( x[ (len(x)-1)//2 ] )\nelse:\n   print( x[ len(x)//2 ] )\n         \n#~ dur = time.clock()-start\n#~ print(\"Time:\",dur)\n", "n = int(input())\nnumbers = [int(n) for n in input().split()]\nns = sorted(numbers)\nprint(ns[(n-1)//2])", "n = int(input())\ndots = [int(x) for x in input().split()]\ndots.sort()\ndot = dots[0]\nleft = 0\nright = sum([abs(x - dot) for x in dots])\nresults = [right]\nfor i in range(1, n):\n    ldot = dot\n    dot = dots[i]\n    left += (dot - ldot) * i\n    right -= (dot - ldot) * (n - i)\n    results.append(left + right)\nprint(dots[results.index(min(results))])\n", "n = int(input())\nx = sorted(list(map(int,input().split())))\nprint(x[(n-1)//2])\n", "n = int(input())\na = list(map(int , input().split(' ')))\na.sort()\nl = [0]*333333\nr = [0]*333333\nfor i in range(1 , n):\n    l[i] = l[i - 1] + i * (a[i] - a[i - 1])\nfor i in range(n - 2, -1 , - 1):\n    r[i] = r[i + 1] + (n - i - 1) * (a[i + 1] - a[i])\nmn = 2222222222222222\nind = 0\nfor i in range(n):\n    #print(l[i] , r[i])\n    if mn > l[i] + r[i]:\n        mn = l[i] + r[i]\n        ind = i\nprint(a[ind])", "n = int(input())\npoints = list(map(int, input().split()))\npoints.sort()\nprint(points[(len(points) - 1) // 2])", "from sys import stdin\n\nn = int(stdin.readline())\npoints = sorted(int(x) for x in stdin.readline().split())\n\nif n % 2 == 0:\n    print(points[n//2 - 1])\nelse:\n    print(points[n//2])\n", "numPoints = int(input())\npoints = list(map(int, input().split(\" \")))\npoints.sort()\n\ndef calcVal(point, points):\n    tally = 0\n    for i in range(len(points)):\n        tally += abs(points[i] - point)\n    return tally\n\nif len(points)%2==0:\n    leftDex = len(points)//2 -1\n    rightDex = len(points)//2\n    '''values = [calcVal(points[leftDex], points), calcVal(points[rightDex], points)]\n    minVal = min(values)\n    which = values.index(minVal)\n    if which == 0:\n        print(points[leftDex])\n    else:\n        print(points[rightDex])'''\n    print(points[leftDex])\nelse:\n    index = len(points)//2\n    print(points[index])\n    \n", "def d(a, x):\n    t = 0\n    for n in a:\n        t += abs(n - x)\n    return t\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if n % 2 == 0:\n        if d(a, a[n // 2 - 1]) <= d(a, a[n // 2]):\n            print(a[n // 2 - 1])\n        else:\n            print(a[n // 2])\n    else:\n        print(a[n // 2])\n\n\ndef main():\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nif n==1:\n\tprint(l[0])\nelif n%2==0:\n\tprint(l[n//2-1])\nelse:\n\tprint(l[n//2])", "n = int(input())\npoints = sorted(tuple(map(int, input().split())))\n\ndef calc(points, start, stop, step):\n    n = len(points)\n    ans = [None] * n\n    ans[start] = 0\n    cnt = 1\n    for i in range(start + step, stop, step):\n        ans[i] = ans[i - step] + abs(points[i] - points[i - step]) * cnt\n        cnt += 1\n    return ans\n\ncalc1 = calc(points, 0, n, 1)\ncalc2 = calc(points, n - 1, -1, -1)\nmini, minv = -1, float('inf')\nfor i in range(n):\n    if calc1[i] + calc2[i] < minv:\n        minv = calc1[i] + calc2[i]\n        mini = points[i]\nprint(mini)", "n = int(input())\n\npos = [int(x) for x in input().split()]\npos.sort()\n\nprint(pos[(n-1)//2])\n", "n = int(input())\na = [0] + sorted(list(map(int, input().split())))\n\nif n % 2 == 0:\n    print(a[n // 2])\nelse:\n    print(a[(n // 2) + 1])", "#!/usr/bin/env python3\n\ndef main():\n    n = int(input())\n    arr = [int(a) for a in input().split()]\n    arr.sort()\n    print(arr[len(arr)//2-1+len(arr)%2])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nINF = 10 ** 9 + 3\n\nfin = sys.stdin\nfout = sys.stdout\nn = int(fin.readline())\npoints = list(map(int, fin.readline().split()))\npoints.sort()\nif (n % 2 == 1):\n    fout.write(str(points[n // 2]))\nelse:\n    fout.write(str(points[n // 2 - 1]))\n", "n = int(input())\n\nN = sorted(map(int, input().split()))\n\nif n % 2 == 0:\n        print(N[(n - 1) //2])\nelse:\n        print(N[n//2 ])\n", "n = int(input())\narray = list(map(int, input().split()))\narray.sort()\nsumm = sum(array)\nsumm2 = 0\ndifferences = [0] * n\nfor i in range(n):\n    differences[i] = (summ - (summ2 + array[i])) - summ2\n    summ2 += array[i]\ndist = [0] * n\nfor i in range(n):\n    dist[i] = array[i] * i + differences[i] - array[i] * (n - i - 1)\nminId = 0\nfor i in range(n):\n    if dist[i] < dist[minId]:\n        minId = i\nprint(array[minId])", "import sys\nfrom statistics import median\nfrom math import floor\n\nsys.stdin.readline()\nnumbers = sorted(int(a) for a in sys.stdin.readline().split())\nprint(numbers[floor((len(numbers) - 1) / 2)])\n"]
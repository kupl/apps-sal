["import sys\n\nn = int(sys.stdin.readline())\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    i, j = tuple(int(k) for k in sys.stdin.readline().split())\n    i -= 1\n    j -= 1\n    edges[i].append(j)\n    edges[j].append(i)\n\n# Prunes the graph starting from the vertices with\n# only 1 edge until we reach a vertex with 3+ edges.\n# Stores the distance from each non-pruned vertex\n# to each of the leaves it reaches.\ndef prune():\n    pruned = [False for _ in range(n)]\n    leaves = [[] for _ in range(n)]\n    todo = []\n    for i in range(n):\n        if len(edges[i]) == 1:\n            todo.append((0, i, i))\n    while len(todo) > 0:\n        d, i, j = todo.pop()\n        pruned[j] = True\n        for k in edges[j]:\n            if not pruned[k]:\n                if len(edges[k]) < 3:\n                    todo.append((d + 1, i, k))\n                else:\n                    leaves[k].append((d + 1, i))\n    return pruned, leaves\n\npruned, leaves = prune()\n\n# Returns the furthest non-pruned vertices\n# from another non-pruned vertex.\ndef furthest(i):\n    assert not pruned[i]\n    visited = list(pruned)\n    top_distance = 0\n    top_vertices = [i]\n    todo = [(0, i)]\n    while len(todo) > 0:\n        d, i = todo.pop()\n        visited[i] = True\n        if d > top_distance:\n            top_distance = d\n            top_vertices = []\n        if d == top_distance:\n            top_vertices.append(i)\n        for j in edges[i]:\n            if not visited[j]:\n                todo.append((d + 1, j))\n    return top_distance, top_vertices\n\n# Single center topology.\n# Only 1 vertex with 3+ edges.\ndef solve_single_center(i):\n    l = list(reversed(sorted(leaves[i])))[:4]\n    return list(l[j][1] for j in range(4))\n\n# Scores non-pruned vertices according to the sum\n# of the distances to their two furthest leaves.\ndef vertices_score(v):\n    scores = []\n    for i in v:\n        assert not pruned[i]\n        l = list(reversed(sorted(leaves[i])))[:2]\n        score = (l[0][0] + l[1][0]), l[0][1], l[1][1]\n        scores.append(score)\n    return list(reversed(sorted(scores)))\n\n# Single cluster topology.\n# 1 cluster of vertices, all equally far away from each other.\ndef solve_single_cluster(v):\n    scores = vertices_score(v)[:2]\n    return scores[0][1], scores[1][1], scores[0][2], scores[1][2]\n\n# Double cluster topology.\n# 2 clusters of vertices, pairwise equally far away from each other.\ndef solve_double_cluster(v1, v2):\n    scores1 = vertices_score(v1)[:1]\n    scores2 = vertices_score(v2)[:1]\n    return scores1[0][1], scores2[0][1], scores1[0][2], scores2[0][2]\n\ndef solve():\n    def start_vertex():\n        for i in range(n):\n            if not pruned[i]:\n                return i\n    i = start_vertex()\n    distance, v1 = furthest(i)\n    if distance == 0:\n        return solve_single_center(v1[0])\n    else:\n        distance, v1 = furthest(v1[0])\n        distance, v2 = furthest(v1[0])\n        v = list(set(v1) | set(v2))\n        if len(v) < len(v1) + len(v2):\n            return solve_single_cluster(v)\n        else:\n            return solve_double_cluster(v1, v2)\n\na, b, c, d = solve()\nprint(a + 1, b + 1)\nprint(c + 1, d + 1)\n", "import sys\n\nn = int(sys.stdin.readline())\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    i, j = tuple(int(k) for k in sys.stdin.readline().split())\n    i -= 1\n    j -= 1\n    edges[i].append(j)\n    edges[j].append(i)\n\n# Prunes the graph starting from the vertices with\n# only 1 edge until we reach a vertex with 3+ edges.\n# Stores the distance from each non-pruned vertex\n# to each of the leaves it reaches.\ndef prune():\n    pruned = [False for _ in range(n)]\n    leaves = [[] for _ in range(n)]\n    todo = []\n    for i in range(n):\n        if len(edges[i]) == 1:\n            todo.append((0, i, i))\n    while len(todo) > 0:\n        d, i, j = todo.pop()\n        pruned[j] = True\n        for k in edges[j]:\n            if not pruned[k]:\n                if len(edges[k]) < 3:\n                    todo.append((d + 1, i, k))\n                else:\n                    leaves[k].append((d + 1, i))\n    return pruned, leaves\n\npruned, leaves = prune()\n\n# Returns the furthest non-pruned vertices\n# from another non-pruned vertex.\ndef furthest(i):\n    assert not pruned[i]\n    visited = list(pruned)\n    top_distance = 0\n    top_vertices = []\n    todo = [(0, i)]\n    while len(todo) > 0:\n        d, i = todo.pop()\n        visited[i] = True\n        if d > top_distance:\n            top_distance = d\n            top_vertices = []\n        if d == top_distance:\n            top_vertices.append(i)\n        for j in edges[i]:\n            if not visited[j]:\n                todo.append((d + 1, j))\n    return top_vertices\n\n# Single center topology.\n# Only 1 vertex with 3+ edges.\ndef solve_single_center(i):\n    l = list(reversed(sorted(leaves[i])))[:4]\n    return list(l[j][1] for j in range(4))\n\n# Scores non-pruned vertices according to the sum\n# of the distances to their two furthest leaves.\ndef vertices_score(v):\n    scores = []\n    for i in v:\n        assert not pruned[i]\n        l = list(reversed(sorted(leaves[i])))[:2]\n        score = (l[0][0] + l[1][0]), l[0][1], l[1][1]\n        scores.append(score)\n    return list(reversed(sorted(scores)))\n\n# Single cluster topology.\n# 1 cluster of vertices, all equally far away from each other.\ndef solve_single_cluster(v):\n    s = vertices_score(v)[:2]\n    return s[0][1], s[1][1], s[0][2], s[1][2]\n\n# Double cluster topology.\n# 2 clusters of vertices, pairwise equally far away from each other.\ndef solve_double_cluster(v1, v2):\n    s1 = vertices_score(v1)[:1]\n    s2 = vertices_score(v2)[:1]\n    return s1[0][1], s2[0][1], s1[0][2], s2[0][2]\n\ndef solve():\n    def start_vertex():\n        for i in range(n):\n            if not pruned[i]:\n                return furthest(i)[0]\n    i = start_vertex()\n    v1 = furthest(i)\n    if len(v1) == 1 and v1[0] == i:\n        return solve_single_center(v1[0])\n    else:\n        v2 = furthest(v1[0])\n        v = list(set(v1) | set(v2))\n        if len(v) < len(v1) + len(v2):\n            return solve_single_cluster(v)\n        else:\n            return solve_double_cluster(v1, v2)\n\na, b, c, d = solve()\nprint(a + 1, b + 1)\nprint(c + 1, d + 1)\n", "n=int(input())\ndegs=[0]*n\nneighbors=[0]*n\nchildren=[0]*n\nuseless=[0]*n\nfor i in range(n):\n    neighbors[i]=[]\n    children[i]=[]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    degs[a-1]+=1\n    degs[b-1]+=1\n    neighbors[a-1].append(b-1)\n    neighbors[b-1].append(a-1)\nfor guy in range(n):\n    if degs[guy]==1:\n        useless[guy]+=1\n        newguy=neighbors[guy][0]\n        oldguy=guy\n        depth=0\n        while degs[newguy]==2:\n            depth+=1\n            useless[newguy]+=1\n            if neighbors[newguy][0]==oldguy:\n                oldguy=newguy\n                newguy=neighbors[newguy][1]\n            else:\n                oldguy=newguy\n                newguy=neighbors[newguy][0]\n        children[newguy].append((depth,guy))\nfor guy in range(n):\n    children[guy].sort(reverse=True)\nnewgraph={}\nfor i in range(n):\n    if useless[i]==0:\n        newgraph[i]=[]\nfor guy in newgraph:\n    for guy1 in neighbors[guy]:\n        if guy1 in newgraph:\n            newgraph[guy].append(guy1)\ndfs1={}\ncurrlayer=[(list(newgraph)[0],None)]\ncurrlevel=0\nwhile len(currlayer)>0:\n    for guy in currlayer:\n        dfs1[guy[0]]=currlevel\n    newlayer=[]\n    for guy in currlayer:\n        for vert in newgraph[guy[0]]:\n            if vert!=guy[1]:\n                newlayer.append((vert,guy[0]))\n    currlayer=newlayer\n    currlevel+=1\nmaxi=0\nfor guy in dfs1:\n    maxi=max(maxi,dfs1[guy])\nbestdist=0\nbestvert=None\nfor guy in dfs1:\n    if dfs1[guy]==maxi:\n        score=children[guy][0][0]+children[guy][1][0]\n        if score>=bestdist:\n            bestdist=score\n            bestvert=guy\ndfs2={}\ncurrlayer=[(bestvert,None)]\ncurrlevel=0\nwhile len(currlayer)>0:\n    for guy in currlayer:\n        dfs2[guy[0]]=currlevel\n    newlayer=[]\n    for guy in currlayer:\n        for vert in newgraph[guy[0]]:\n            if vert!=guy[1]:\n                newlayer.append((vert,guy[0]))\n    currlayer=newlayer\n    currlevel+=1\nmaxi=0\nfor guy in dfs2:\n    maxi=max(maxi,dfs2[guy])\nbestdist=0\nbestvert1=None\nfor guy in dfs2:\n    if dfs2[guy]==maxi:\n        score=children[guy][0][0]+children[guy][1][0]\n        if score>=bestdist:\n            bestdist=score\n            bestvert1=guy\nprint(children[bestvert][0][1]+1,children[bestvert1][0][1]+1)\nprint(children[bestvert][1][1]+1,children[bestvert1][1][1]+1)"]
["import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\n# \u9069\u5f53\u306a\u7d20\u6570\u3068\u539f\u59cb\u6839\u3067rolling hash\nMOD = 10 ** 9 + 993\nbase = 123450\n\nS = np.array([ord(x) for x in input().rstrip()],dtype=np.int64)\nT = np.array([ord(x) for x in input().rstrip()],dtype=np.int64)\n\n# S\u306e\u65b9\u304c\u9577\u304f\u3059\u308b\nLS = len(S)\nLT = len(T)\nn = (LT + (-LT) % LS) // LS\nS = np.concatenate([S]*(n+1))\nS = S[:LS+LT]\n\ndef cumprod(arr):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2); arr = arr.reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\nbase_inv = pow(base,MOD-2,MOD)\nx = np.full(LS+LT,base,dtype=np.int64)\nx[0] = 1\npower = cumprod(x)\nx = np.full(LS+LT,base_inv,dtype=np.int64)\nx[0] = 1\npower_inv = cumprod(x)\n\ndef to_rolling_hash(S):\n    return (S * power[:len(S)] % MOD).cumsum() % MOD\n\nS_hash = to_rolling_hash(S)\nT_hash = to_rolling_hash(T)[-1] # \u6587\u5b57\u5217\u5168\u4f53\n\nS_hash_LT = S_hash[LT-1:]\nS_hash_LT[1:] -= S_hash.copy()[:LS]\nS_hash_LT %= MOD\nS_hash_LT *= power_inv[:LS+1]\nS_hash_LT %= MOD\n\nINF = 10 ** 18\nvisited = [False] * LS\ndist = [INF] * LS # \u64cd\u4f5c\u7d42\u4e86\u4f4d\u7f6e\u304b\u3089\u306e\u8ddd\u96e2\n\nq = np.where(S_hash_LT[:LS] != T_hash)[0].tolist()\n\nd = 0\nwhile q:\n    qq = []\n    for x in q:\n        if dist[x] == INF:\n            dist[x] = d\n            qq.append((x-LT)%LS)\n    d += 1\n    q = qq\n\nanswer = max(dist)\nif answer >= INF:\n    answer = -1\n\nprint(answer)", "s = input()\nt = input()\n\nbase = 3\nMOD = 1004535809\n\ndef rolling_hash(s, base, MOD):\n    l = len(s)\n    h = [0]*(l + 1)\n    for i in range(l):\n        h[i+1] = (h[i] * base + ord(s[i])) % MOD\n    return h\n\ns = s * ((len(t) + len(s) - 1)//len(s) * 2)\nrh0 = rolling_hash(s, base, MOD)\nB = 0\nfor c in t:\n    B = (B * base + ord(c)) % MOD\nN = len(s)//2\nM = len(t)\nR = [0]*N\nL = pow(base, M, MOD)\nr = 0\nfor i in range(N):\n    if (rh0[i+M] - rh0[i]*L) % MOD == B:\n        R[i] = 1\nif not any(R):\n    print(0)\n    return\n\nS = []\nfor i in range(N):\n    if R[i-M] and R[i] == 0:\n        S.append((i - M) % N)\nif not S:\n    print(-1)\n    return\n\nans = 0\nfor v in S:\n    d = 1\n    while R[v-M]:\n        d += 1\n        v = (v - M) % N\n    ans = max(ans, d)\nprint(ans)", "def partial_match_table(word):\n    table = [0] * (len(word) + 1)\n    table[0] = -1\n    i, j = 0, 1\n    while j < len(word):\n        matched = word[i] == word[j]\n        if not matched and i > 0:\n            i = table[i]\n        else:\n            if matched:\n                i += 1\n            j += 1\n            table[j] = i\n    return table\n\ndef kmp_search(text, word):\n    table = partial_match_table(word)\n    i, p = 0, 0\n    results = []\n    while i < len(text) and p < len(word):\n        if text[i] == word[p]:\n            i += 1\n            p += 1\n            if p == len(word):\n                p = table[p]\n                results.append((i-len(word), i))\n        elif p == 0:\n            i += 1\n        else:\n            p = table[p]\n    return results\n\ninf = 10**18\ns = input().strip()\nt = input().strip()\nm=(len(t)+len(s)-1+len(s)-1)//len(s)\nd = set()\nfor a, b in kmp_search(m*s, t):\n    d.add(a%len(s))\n\nd2 = set()\nfor i in range(len(s)):\n    if i not in d:\n        d2.add(i)\nq = d2\n\nLT, LS = len(t), len(s)\ndist = [inf] * LS\nd = 0\nwhile q:\n    qq = []\n    for x in q:\n        if dist[x] == inf:\n            dist[x] = d\n            qq.append((x-LT)%LS)\n    d += 1\n    q = qq\n\nanswer = max(dist)\nif answer >= inf:\n    answer = -1\n\nprint(answer)\n", "class RollingHash():\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        l = len(s)\n        self.pw = pw = [1]*(l+1)\n        self.h = h = [0]*(l+1)\n        for i in range(l):\n            h[i+1] = (h[i] * base + ord(s[i])) % mod\n            pw[i+1] = pw[i] * base % mod\n\n    def get(self, l, r): # [l, r)\n        return (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod\n\ndef main():\n  s = input()\n  t = input()\n  ls,lt = len(s), len(t)\n  m = (ls+lt-1)//ls + 1\n  s *= m\n  s1 = RollingHash(s, 1007, 10**9+7)\n  t1 = RollingHash(t, 1007, 10**9+7)\n  w = t1.get(0,lt)\n  g = [None]*ls\n  for i in range(ls):\n    if s1.get(i, i+lt) == w:\n      g[i] = (i+lt)%ls\n  \n  f = [None]*ls\n  for i in range(ls):\n    if f[i] is None:\n      f[i] = ls\n      q = [i]\n      while q:\n        if g[q[-1]] is None:\n          f[q[-1]] = 0\n          q.pop()\n        elif f[g[q[-1]]] is None:\n          q.append(g[q[-1]])\n        else:\n          f[q[-1]] = f[g[q[-1]]] + 1\n          q.pop()\n  print(max(f) if max(f) < ls else -1)\n  return\n  \nmain()", "def partial_match_table(word):\n    table = [0] * (len(word) + 1)\n    table[0] = -1\n    i, j = 0, 1\n    while j < len(word):\n        matched = word[i] == word[j]\n        if not matched and i > 0:\n            i = table[i]\n        else:\n            if matched:\n                i += 1\n            j += 1\n            table[j] = i\n    return table\n\ndef kmp_search(text, word):\n    table = partial_match_table(word)\n    i, p = 0, 0\n    results = []\n    while i < len(text) and p < len(word):\n        if text[i] == word[p]:\n            i += 1\n            p += 1\n            if p == len(word):\n                p = table[p]\n                results.append((i-len(word), i))\n        elif p == 0:\n            i += 1\n        else:\n            p = table[p]\n    return results\n\ninf = 10**18\ns = input().strip()\nt = input().strip()\nm=(len(t)+len(s)-1+len(s)-1)//len(s)\nd = [-1] * (len(s)+1) \nfor a, b in kmp_search(m*s, t):\n    a, b = a%len(s)+1, b%len(s)+1\n    d[a] = b\n\n\nls = [-1]*(len(s)+1)\nvs = set()\nfor i in range(1, len(s)+1):\n    if i in vs:\n        continue\n    c = 0\n    j = i\n    while True:\n        vs.add(i)\n        i = d[i]\n        if i == -1:\n            break\n        c += 1\n        if i == j:\n            c = inf\n            break\n        if ls[i] != -1:\n            c += ls[i]\n            break\n    if c == inf:\n        break\n    ls[j] = c\nprint((max(ls) if c != inf else -1))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef rolling_hash(s, w, MOD):\n    ret = []\n    tmp = 0\n    p = pow(26, w, MOD)\n    ords = [ord(c) - 97 for c in s]\n    for i, o in enumerate(ords):\n        tmp = tmp * 26 + o\n        if i >= w:\n            tmp = (tmp - ords[i - w] * p)\n        tmp %= MOD\n        ret.append(tmp)\n    return ret\n\n\ndef solve(s, t):\n    MOD = 10 ** 9 + 7\n    ls, lt = len(s), len(t)\n    k = (lt - 1) // ls + 1\n    s *= k * 2\n    ls *= k\n    rs, rt = rolling_hash(s, lt, MOD), rolling_hash(t, lt, MOD)\n    rs = rs[ls:]\n    ht = rt[-1]\n\n    checked = [-1] * ls\n\n    def series(i, st):\n        if st <= i < st + lt:\n            return float('-inf')\n        if checked[i] == -1:\n            checked[i] = series((i + lt) % ls, st) + 1 if rs[i] == ht else 0\n        return checked[i]\n\n    for i, hs in enumerate(rs):\n        if hs != ht:\n            continue\n        ret = series((i + lt) % ls, i)\n        if ret == float('-inf'):\n            return -1\n        checked[i] = ret + 1\n\n    return max(0, max(checked))\n\n\ns = input()\nt = input()\nprint((solve(s, t)))\n", "def getTableMP(Ss):\n    lenS = len(Ss)\n    table = [-1] * (lenS+1)\n    j = -1\n    for i in range(lenS):\n        while j >= 0 and Ss[i] != Ss[j]:\n            j = table[j]\n        j += 1\n        table[i+1] = j\n    return table\n\n\nSs = input()\nTs = input()\n\nlenS, lenT = len(Ss), len(Ts)\nnum = (lenT+lenS-1+lenS-1)//lenS\nS2s = Ss * num\n\ntableMP = getTableMP(Ts + '$' + S2s)\n\nisFounds = [False] * lenS\nfor i in range(2*lenT+1, 2*lenT+lenS+1):\n    if tableMP[i] >= lenT:\n        isFounds[i-2*lenT-1] = True\n\nans = 0\nnumDone = 0\nfor i in range(lenS):\n    if not isFounds[i]:\n        i = (i+lenT)%lenS\n        for num in range(lenS+1):\n            if not isFounds[i]:\n                ans = max(ans, num)\n                numDone += num+1\n                break\n            i = (i+lenT)%lenS\n        else:\n            ans = -1\n            break\n\nif numDone < lenS:\n    ans = -1\nprint(ans)\n", "def z_alg(S):\n    N = len(S)\n    Z = [0] * N\n    Z[0] = N\n    i, j = 1, 0\n    while i < N:\n        while i + j < N and S[j] == S[i + j]:\n            j += 1\n        Z[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < N and k + Z[k] < j:\n            Z[i + k] = Z[k]\n            k += 1\n        i += k\n        j -= k\n    return Z\n\n\ndef main():\n    S = input()\n    T = input()\n    REP_S = ''\n    target_len = len(S) + len(T) - 1\n    while len(REP_S) < target_len:\n        REP_S += S\n\n    # Z-algorithm\u3067REP_S\u4e2d\u306b\u542b\u307e\u308c\u308bT\u306e\u5834\u6240\u3092\u8abf\u3079\u308b\n    T_REP_S = T + REP_S\n    z = z_alg(T_REP_S)\n    location_list = list()\n    for i in range(len(S)):\n        if z[i + len(T)] >= len(T):\n            location_list.append(i)\n\n    # T\u304c\u306a\u3051\u308c\u30700\u3092\u51fa\u529b\u3057\u3066\u7d42\u4e86\n    if len(location_list) == 0:\n        print(0)\n        return\n\n    # \u30b0\u30e9\u30d5\u3092\u4f5c\u308a\u3001\u6700\u9577\u30d1\u30b9\u306b\u542b\u307e\u308c\u308b\u30ce\u30fc\u30c9\u6570\u304c\u7b54\u3048\uff08\u30eb\u30fc\u30d7\u304c\u3042\u3063\u305f\u3089-1\uff09\n    node_flag_list = [0] * len(S)\n    for n in location_list:\n        node_flag_list[n] = 1\n    depth_list = [-1] * len(S)\n    for n in location_list:\n        if depth_list[n] >= 0:\n            continue\n        cur_node = n\n        d, has_loop = 0, False\n        while node_flag_list[cur_node] == 1:\n            depth_list[cur_node] = d\n            d += 1\n            cur_node = (cur_node + len(T)) % len(S)\n            if cur_node == n:\n                has_loop = True\n                break\n        if has_loop:\n            print(-1)\n            return\n\n    print(max(depth_list) + 1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef LcpByZ(target):\n    len_t = len(target)\n    lcp = [-1] * len_t\n    top = 1  # \u53f3\u306e\u7bb1\u306b\u304a\u3044\u3066\u3001\u5de6\u306e\u7bb1\u306e0\u306b\u5bfe\u5fdc\u3059\u308b\u70b9\n    left = 0  # \u5de6\u306e\u7bb1\u306e\u5de6\u7aef(\u672c\u5f53\u306f\u3053\u3053\u3067\u306e\u3067\u5ba3\u8a00\u306f\u4e0d\u8981\u3060\u3051\u3069\u7406\u89e3\u306e\u70ba)\n    right = 0  # \u5de6\u306e\u7bb1\u306e\u53f3\u7aef\n    lcp[0] = 0\n    while top < len_t:\n        # \u7bb1\u3092\u53f3\u306b\u5e83\u3052\u3066\u3044\u304f\n        while top + right < len_t and target[right] == target[top + right]:\n            right += 1\n        # \u53f3\u306e\u7bb1\u5de6\u7aef\u306elcp\u3092\u8a18\u9332\n        lcp[top] = right\n        left = 1\n        # \u7bb1\u306e\u5e45\u304c0\u3060\u3063\u305f\u3089top\u3092\u52d5\u304b\u3057\u3066\u3001\u3053\u306e\u30bf\u30fc\u30f3\u7d42\u4e86\n        if right == 0:\n            top += 1\n            continue\n        # lcp\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u7bb1\u3092\u5de6\u306b\u7e2e\u3081\u3066\u3044\u304f\uff08\u6700\u521d\u306e\u6761\u4ef6\u91cd\u8981\uff09\n        while left + lcp[left] < right and left < right:\n            lcp[top + left] = lcp[left]\n            left += 1\n        # top\u3092\u53f3\u306e\u7bb1\u306e\u5de6\u7aef\u306b\u3057\u3066\u3001\u5de6\u306e\u7bb1\u30920\u307e\u3067\u623b\u3059\n        top += left\n        right -= left\n        left = 0  # \u3053\u308c\u3082\u672c\u5f53\u306f\u4e0d\u8981\n    return lcp\n\ndef dfs(i,si):\n    dp[i]=0\n    ni=(i+tn)%sn\n    if lcp[tn+1+ni]!=tn:return False\n    if ni==si:return True\n    if dp[ni]==-1 and dfs(ni,si):return True\n    dp[i]=dp[ni]+1\n\ns=SI()\nt=SI()\nss = s\nwhile len(ss) < len(s) + len(t): ss += s\nlcp = LcpByZ(t + \"@\" + ss)\nsn = len(s)\ntn = len(t)\ndp=[-1]*sn\nfor i in range(sn):\n    if dp[i]!=-1:continue\n    if dfs(i,i):\n        print(-1)\n        return\nprint(max(dp))\n", "def Z_algorithm(s):\n    N = len(s)\n    Z_alg = [0]*N\n\n    Z_alg[0] = N\n    i = 1\n    j = 0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        Z_alg[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + Z_alg[k]<j:\n            Z_alg[i+k] = Z_alg[k]\n            k += 1\n        i += k\n        j -= k\n    return Z_alg\n\nimport sys\nfrom fractions import gcd\n\nsys.setrecursionlimit(1500000)\n\ns=input()\nt=input()\nn=len(s)\nm=len(t)\nif n!=m:\n    s=(m//n+2)*s\n    data=Z_algorithm(t+'?'+s)\n    bool=[False for i in range(0,n)]\n    for i in range(m+1,m+1+n):\n        if data[i]==m:\n            bool[i-m-1]=True\n\n    g=gcd(n,m)\n    for i in range(0,g):\n        for j in range(0,n//g):\n            if not bool[i+j*g]:\n                break\n        else:\n            print((-1))\n            return\n\n    ans=[[] for i in range(0,g)]\n    for i in range(0,g):\n        ans[i].append(bool[i])\n        x=(i+m)%n\n        while x!=i:\n            ans[i].append(bool[x])\n            x=(x+m)%n\n\n    from itertools import groupby\n    answer=0\n    for i in range(0,g):\n        a=groupby(ans[i])\n        d=[]\n        for key,group in a:\n            g=len(list(group))\n            d.append([key,g])\n        if d:\n            if d[0][0] and d[-1][0]:\n                d[-1][1]+=d[0][1]\n        for j in range(len(d)):\n            if d[j][0]:\n                answer=max(answer,d[j][1])\n    print(answer)\n\n\nelse:\n    s=2*s\n    data=Z_algorithm(t+'?'+s)\n    for i in range(m+1,n+m+1):\n        if data[i]==m:\n            print((-1))\n            break\n    else:\n        print((0))\n", "def getTableKMP(Ss):\n    Ss += '$'\n    lenS = len(Ss)\n    table = [-1] * lenS\n    j = -1\n    for i in range(lenS-1):\n        while j >= 0 and Ss[i] != Ss[j]:\n            j = table[j]\n        j += 1\n        if Ss[i+1] == Ss[j]:\n            table[i+1] = table[j]\n        else:\n            table[i+1] = j\n    return table\n\ndef getPosPtnsKMP(Ss, ptn, table):\n    anss = []\n    lenS, lenP = len(Ss), len(ptn)\n    iS, iP = 0, 0\n    while iS < lenS:\n        if Ss[iS] == ptn[iP]:\n            iS += 1\n            iP += 1\n            if iP == lenP:\n                anss.append(iS-lenP)\n                iP = table[iP]\n        else:\n            iP = table[iP]\n            if iP == -1:\n                iS += 1\n                iP = 0\n    return anss\n\n\nSs = input()\nTs = input()\n\nlenS, lenT = len(Ss), len(Ts)\nnum = (lenT+lenS-1+lenS-1) // lenS\nS2s = Ss * num\n\ntableKMP = getTableKMP(Ts)\nposPtns = getPosPtnsKMP(S2s, Ts, tableKMP)\n\nisFounds = [False] * lenS\nfor pos in posPtns:\n    if pos >= lenS:\n        break\n    isFounds[pos] = True\n\nans = 0\nnumDone = 0\nfor i in range(lenS):\n    if not isFounds[i]:\n        i = (i+lenT) % lenS\n        for num in range(lenS+1):\n            if not isFounds[i]:\n                ans = max(ans, num)\n                numDone += num+1\n                break\n            i = (i+lenT) % lenS\n        else:\n            ans = -1\n            break\n\nif numDone < lenS:\n    ans = -1\nprint(ans)\n"]
["from bisect import *\n\nn, m = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\nr = -1\n\na.sort()\nb.sort()\n\nfor i in a:\n\ty = 1000000000000\n\tx = bisect_left(b, i)\n\tif (x >= 0) and (x < m):\n\t\ty = min(y, abs(i - b[x]))\n\tx += 1\n\tif (x >= 0) and (x < m):\n\t\ty = min(y, abs(i - b[x]))\n\tx -= 2\n\tif (x >= 0) and (x < m):\n\t\ty = min(y, abs(i - b[x]))\n\tr = max(r, y)\n\nprint(r)\n", "line1=input().split()\nn=int(line1[0])\nm=int(line1[1])\ncities=input().split()\ntowers=input().split()\nfor i in range (n):\n    cities[i]=int(cities[i])\nfor i in range (m):\n    towers[i]=int(towers[i])\n\nworst=0\ni=0\n\nfor city in cities:\n    if m>1:\n        while (city>towers[i+1] and i+2<m):\n            i+=1\n        a=abs(towers[i]-city)\n        b=abs(towers[i+1]-city)\n        this=min(a,b)\n        worst=max(worst,this)\n    else:\n        worst=max(worst,abs(towers[0]-city))\nprint (worst)\n", "n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nclass Zona:\n    def __init__(self, vis, gran, t):\n        self.v = vis\n        self.gr = gran\n        self.type = t\n        self.towns = []\n        \nzones = []\nzones.append(Zona(b[0], -10**9 - 1, 1))\nfor i in range(0, m - 1):\n    gr = (b[i] + b[i+1]) / 2\n    zones.append(Zona(b[i], gr, 2))\n    zones.append(Zona(b[i+1], gr, 1))\n    \nzones.append(Zona(b[m - 1], 10**9 + 1, 2))\n\ni = 0\nfor zone in zones:\n    if zone.type == 1:\n        while ((a[i] >= zone.gr) and (a[i] < zone.v)):\n            zone.towns.append(a[i])\n            i += 1\n            if (i == n): break\n    if zone.type == 2:\n        while (a[i] >= zone.v) and (a[i] < zone.gr):\n            zone.towns.append(a[i])\n            i += 1\n            if (i == n): break\n    if (i == n): break\n    \nr = 0\nfor zone in zones:\n    for town in zone.towns:\n        dist = abs(zone.v - town)\n        if (dist > r):\n            r = dist\n            \nprint(r)\n    \n", "import sys\nr = lambda:sys.stdin.readline()\n\nn,m = map(int,r().split())\nnrr = [int(x) for x in r().split()]\nmrr = [int(x) for x in r().split()]\n\nlrr = []\nrrr = []\npointer = 0\nfor x in mrr:\n    while True:\n        if(pointer==n):\n            break\n        if(nrr[pointer]<=x):\n            rrr.append(x-nrr[pointer])\n            pointer += 1\n        else:\n            break\nfor i in range(pointer,n):\n    rrr.append(10**10)\n\npointer = n-1\nfor i in range(m-1,-1,-1):\n    while True:\n        if(pointer==-1):\n            break\n        if(mrr[i]<=nrr[pointer]):\n            lrr.append(nrr[pointer]-mrr[i])\n            pointer -= 1\n        else:\n            break\nfor i in range(pointer,-1,-1):\n    lrr.append(10**10)\nsrr = [min(lrr[i],rrr[n-i-1]) for i in range(n)]\nprint(max(srr))", "def lower_bownd(key):\n    left = -1\n    right = m\n    while left < right - 1:\n        middle = (left + right) // 2\n        if b[middle] <= key:\n            left = middle\n        else:\n            right = middle\n    \n    if right < m:\n        r = b[right] - key\n    else:\n        r = INF\n    if left > -1:\n        l = key - b[left]\n    else:\n        l = INF\n    return min(l, r)\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = [0] * n\nINF = 10 ** 10\nfor i in range(n):\n    ans[i] = lower_bownd(a[i])\nprint(max(ans))", "def min_dist_to_tower(a, x):\n    l, r = -1, len(a)\n    while r - l > 1:\n        m = (l + r) // 2\n        if a[m] > x:\n            r = m\n        else:\n            l = m\n    w = abs(x - a[l]) if l >= 0 else 'SORRY'\n    z = abs(x - a[r]) if r < len(a) else 'SORRY'\n    if w != 'SORRY' and z != 'SORRY':\n        return min(w, z)\n    elif w == 'SORRY':\n        return z\n    else:\n        return w\n\n\n\nn, m = map(int, input().split())\nhouses = list(map(int, input().split()))\ntowers = list(map(int, input().split()))\n\ndist = 0\nfor i in range(len(houses)):\n    if min_dist_to_tower(towers, houses[i]) > dist:\n        dist = min_dist_to_tower(towers, houses[i])\n\nprint(dist)", "from sys import stdin, stdout\nn, m = map(int, stdin.readline().split())\nhcoordinate = list(map(int, stdin.readline().split()))\ntcoordinate = list(map(int, stdin.readline().split()))\nl = -1\nr = max(abs(tcoordinate[-1] - hcoordinate[-1]), abs(tcoordinate[-1] - hcoordinate[0]))\n\n\nwhile r > l + 1:\n    t = (r + l) // 2\n    i, j = 0, 0\n    while i < n and j < m:\n        if abs(hcoordinate[i] - tcoordinate[j]) <= t:\n            i += 1\n        else:\n            j += 1\n            \n    if i == n:\n        r = t\n    else:\n        l = t\n\n\nstdout.write(str(r))", "t = input\np = print\nr = range\nn, m = map(int, t().split())\na = list(map(int, t().split()))\nb = list(map(int, t().split()))\nans = 0\ni = 0\nfor j in a:\n    while i < m - 1 and abs(j - b[i]) >= abs(j - b[i + 1]):\n        i += 1\n    ans = max(ans, abs(j - b[i]))\np(ans)", "import bisect\n\nn,m = map(int,input().split())\nC=sorted(list(set(map(int,input().split()))))\nT=sorted(list(set(map(int,input().split()))))\n\nr=0\nfor x in C:\n\tind=bisect.bisect_left(T,x)\n\tif(ind==len(T) or T[ind] != x):\n\t\tif ind==0:\n\t\t\tr=max(r,T[ind]-x)\n\t\telif ind==len(T):\n\t\t\tr=max(r,x-T[ind-1])\n\t\telse:\n\t\t\tr=max(r,min(T[ind]-x,x-T[ind-1]))\nprint(r)", "import bisect\n\nx = list(map(int, input().split()))\ngor = sorted(list(set(map(int, input().split()))))\nvysh = sorted(list(set(map(int, input().split()))))\n\nr = 0\n\nfor x in gor:\n    vh = bisect.bisect_left(vysh, x)\n\n    if (vh == len(vysh) or vysh[vh] != x):\n        if vh == 0:\n            r = max(r, vysh[vh] - x)\n        elif vh == len(vysh):\n            r = max(r, x - vysh[vh - 1])\n        else:\n            r = max(r, min(vysh[vh] - x, x - vysh[vh - 1]))\n\nprint(r)\n", "n,m = map(int,input().split())\nc = list(map(int,input().split()))\nt = list(map(int,input().split()))\ni = 0\nans = 0\nfor x in c:\n    while i < m- 1 and abs(x-t[i]) >=  abs(x - t[i+1]):\n        i+=1\n    ans = max(ans,abs(x-t[i]))\nprint(ans)", "n,m=[int(i) for i in input().strip().split()]\nc=[int(i) for i in input().strip().split()]\nt=[int(i) for i in input().strip().split()]\n\nci=0\nti=0\nans=0\n\nwhile ci<n:\n  if ti==m-1:\n    ans=max(ans,abs(t[-1]-c[ci]),abs(t[-1]-c[-1]))\n    break\n  while ti<=m-2:\n    if abs(t[ti]-c[ci])>=abs(t[ti+1]-c[ci]):\n      ti+=1\n    else:\n      break\n  ans=max(ans,abs(t[ti]-c[ci]))\n  ci+=1\nprint(ans)\n", "n, m = (int(t) for t in input().split())\ncity = [int(t) for t in input().split()]\ntower = [int(t) for t in input().split()]\n\ndef check(city, tower, r):\n    t = 0\n    c = 0\n    while c < len(city):\n        if abs(city[c] - tower[t]) > r:\n            #Current tower is too far\n            t += 1\n            if t == len(tower):\n                #Ran out of towers\n                return False\n        else:\n            c += 1\n    return True\n\nhi = 2 * (10 ** 9)\nlo = 0\nout = hi \nwhile hi >= lo:\n    mid = (hi + lo) // 2\n    if check(city, tower, mid):\n        out = mid\n        hi = mid - 1\n    else:\n        lo = mid + 1\n\nprint(out)", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nb.append(b[m-1])\np=0\nr=0\nfor i in range(n):\n\twhile p+2<len(b) and abs(a[i]-b[p]) >= abs(a[i]-b[p+1]): p+=1\n\tmn=min(abs(a[i]-b[p]),abs(a[i]-b[p+1]))\n\tr=max(r,mn)\nprint(r)", "def UpperBound(A, key):\n   left = -1\n   right = len(A)\n   while right > left + 1:\n      middle = (left + right) // 2\n      if A[middle] > key:\n         right = middle\n      else:\n         left = middle\n   return right\n\ndef LowerBound(A, key):\n   left = -1\n   right = len(A)\n   while right > left + 1:\n      middle = (left + right) // 2\n      if A[middle] >= key:\n         right = middle\n      else:\n         left = middle\n   return right\n\n\nn, m = map(int, input().split())\nN = list(map(int, input().split()))\nM = list(map(int, input().split()))   \nINF = 10**9\n\ndist = [INF] * (n)\nmin_dist = 0\n\nfor i in range(n):\n   l = LowerBound(M, N[i]) \n   if l > len(M) - 1:\n      l = len(M) - 1\n\n   d1 = abs(N[i] - M[l])\n   #print(d1)\n   if 0 < l:\n      d2 = abs(N[i] - M[l - 1])\n      #print(d2)\n   else:\n      d2 = d1\n   dist[i] = min(d1,d2)\n\nprint(max(dist))", "def main():\n    from bisect import bisect_left\n    n, m = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    bb = -10 ** 10, *list(map(int, input().split())), 10 ** 10\n    rr = [bb[bisect_left(bb, a)] - a for a in aa]\n    bb = [-b for b in reversed(bb)]\n    rr.reverse()\n    aa.reverse()\n    for i, r, a in zip(list(range(n)), rr, aa):\n        x = bb[bisect_left(bb, -a)] + a\n        if r > x:\n            rr[i] = x\n    print(max(rr))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from bisect import bisect_left\n    input()\n    aa = list(map(int, input().split()))\n    bb = -10 ** 10, *list(map(int, input().split())), 10 ** 10\n    for i, a in enumerate(aa):\n        j = bisect_left(bb, a)\n        u, v = bb[j] - a, a - bb[j - 1]\n        aa[i] = u if u < v else v\n    print(max(aa))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\ndef lower_bound(x) :\n    bl = 0\n    br = m - 1\n    while br - bl > 1 :\n        bm = (bl + br) // 2\n        if b[bm] >= x : br = bm\n        else : bl = bm + 1\n    if b[bl] >= x : return bl\n    elif b[br] >= x : return br\n    else : return m\n\ndef upper_bound(x) :\n    bl = 0\n    br = m - 1\n    while br - bl > 1 :\n        bm = (bl + br) // 2\n        if b[bm] > x : br = bm\n        else : bl = bm + 1\n    if b[bl] > x : return bl\n    elif b[br] > x : return br\n    else : return m\n\nres = 0\n\nfor i in range(n) :\n    pos = lower_bound(a[i])\n    tmp = 2 * (10 ** 9) + 1\n    if pos < m and tmp > b[pos] - a[i] :\n        tmp = b[pos] - a[i]\n    pos = upper_bound(a[i]) - 1\n    if pos >= 0 and tmp > a[i] - b[pos] :\n        tmp = a[i] - b[pos]\n    if tmp > res : res = tmp\nprint(res)\n", "n, m = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\ndef lower_bound(x) :\n    bl = 0\n    br = m - 1\n    while br - bl > 1 :\n        bm = (bl + br) // 2\n        if b[bm] >= x : br = bm\n        else : bl = bm + 1\n    if b[bl] >= x : return bl\n    elif b[br] >= x : return br\n    else : return m\n\nres = 0\n\nfor i in range(n) :\n    pos = lower_bound(a[i])\n    tmp = 2 * (10 ** 9) + 1\n    if pos < m and tmp > b[pos] - a[i] :\n        tmp = b[pos] - a[i]\n    pos = lower_bound(a[i] + 1) - 1\n    if pos >= 0 and tmp > a[i] - b[pos] :\n        tmp = a[i] - b[pos]\n    if tmp > res : res = tmp\nprint(res)\n", "import math\nline = input().split()\nn = int(line[0])\nm = int(line[1])\ninhabited_localities = [int(x) for x in input().split()]\ncolumns = [int(x) for x in input().split()]\nmax_distance = 0\ncurrent_distanse = 0\nj = 0\nfor i in inhabited_localities:\n\twhile j<m-1 and i>columns[j]:\n\t\tj+=1\n\tif j!=0:\n\t\tcurrent_distanse = min(abs(columns[j]-i), abs(columns[j-1]-i))\n\telse:\n\t\tcurrent_distanse = abs(columns[j]-i)\n\tif max_distance<current_distanse:\n\t\tmax_distance = current_distanse\nprint (max_distance)", "n, m = list(map(int, input().split()))\n\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nans = -1\n\nif m == 1:\n    for i in x:\n        if abs(i-y[0]) > ans:\n            ans = abs(i - y[0])\nelse:\n    c = 0\n    p = 0\n    q = 1\n    while c != n:\n        #print(\"city %d\" %(c))\n        if (y[p] <= x[c]) and (y[q] >= x[c]):\n            #print(\"city in between tower %d and %d\" %(p, q))\n            ans = max(ans, min((y[q]-x[c]), (x[c]-y[p])))\n            c += 1\n        elif y[q] < x[c]:\n            #print(\"tower q %d lower than city\" %q)\n            if q != m-1:\n                #print(\"increase tower\")\n                p += 1\n                q += 1\n            else:\n                #print(\"no more tower\")\n                ans = max(ans, x[c] - y[q])\n                c += 1\n        elif y[p] > x[c]:\n            #print(\"tower p %d higher than city\" %p)\n            ans = max(ans, y[p] - x[c])\n            c += 1\n\nprint(ans)\n", "import bisect\n\n\ndef read():\n    return [int(x) for x in input().split()]\n\n\ndef main():\n    n, m = read()\n    a = read()\n    b = read()\n\n    res = 0\n    for i in range(0, n):\n        cover_left = -1\n        bi = bisect.bisect_left(b, a[i])\n        if bi != m and b[bi] == a[i]:\n            cover_left = 0\n        elif bi:\n            cover_left = a[i] - b[bi - 1]\n\n        cover_right = -1\n        bi = bisect.bisect_right(b, a[i])\n        if bi != m:\n            cover_right = b[bi] - a[i]\n        if cover_left != -1 and cover_right != -1:\n            res = max(res, min(cover_left, cover_right))\n        elif cover_right != -1:\n            res = max(res, cover_right)\n        else:\n            res = max(res, cover_left)\n\n    print(res)\n\nmain()", "import bisect\n\n\ndef read():\n    return [int(x) for x in input().split()]\n\n\ndef main():\n    n, m = read()\n    a = read()\n    b = read()\n\n    res = 0\n    for i in range(0, n):\n        # cover from left\n        cover_left = -1\n        bi = bisect.bisect_left(b, a[i])\n        if bi != m and b[bi] == a[i]:\n            cover_left = 0\n        elif bi:\n            cover_left = a[i] - b[bi - 1]\n\n        # cover from right\n        cover_right = -1\n        bi = bisect.bisect_right(b, a[i])\n        if bi != m:\n            cover_right = b[bi] - a[i]\n\n        if cover_left != -1 and cover_right != -1:\n            res = max(res, min(cover_left, cover_right))\n        elif cover_right != -1:\n            res = max(res, cover_right)\n        else:\n            res = max(res, cover_left)\n\n    print(res)\n\nmain()", "#!/usr/bin/env\tpython\n#-*-coding:utf-8 -*-\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\nB=tuple(map(int,input().split()))\ns=i=0\nfor c in A:\n\twhile m>i and c>B[i]:i+=1\n\tn=c-B[i-1]if i else 0x7fffffff\n\tif m>i:n=min(n,B[i]-c)\n\ts=max(s,n)\nprint(s)\n", "k=0\ni=0\nn,m=list(map(int,input().split()))\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nfor j in a:\n    if m>1:\n        while (j>b[i+1] and i+2<m):\n            i+=1\n        w=abs(b[i]-j)\n        e=abs(b[i+1]-j)\n        k1=min(w,e)\n        k=max(k,k1)\n    else:\n        k=max(k,abs(b[0]-j))\nprint(k)\n"]
["from collections import deque\n\nN, M = map(int, input().split())\nL = [list(map(int, input().split())) for _ in range(M)]\nlink = [[] for _ in range(N)]\n\nfor i in range(M):\n    link[L[i][0]-1].append(L[i][1]-1)\n    link[L[i][1]-1].append(L[i][0]-1)\n\nchecked = [-1 for _ in range(N)]\nchecked[0] = 0\nd = deque([0])\nwhile d:\n    now = d.popleft()\n    for i in range(len(link[now])):\n        if checked[link[now][i]] == -1:\n            checked[link[now][i]] = now + 1\n            d.append(link[now][i])\n\n\nflag = False\nfor i in range(1, N):\n    if checked[i] == -1:\n        flag = True\n        break\n\nif flag:\n    print('No')\nelse:\n    print('Yes')\n    for i in range(1, N):\n        print(checked[i])", "from collections import deque\nn,m=list(map(int,input().split()))\nr=[[] for i in range(n+1)]\nR=[[] for i in range(n+1)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    r[a].append(b)\n    r[b].append(a)\n    R[a].append(b)\n    R[b].append(a)\ndep=[-1]*(n+1)\ndep[0]=0\ndep[1]=0\ndata=deque([1])\nd=0\nwhile len(data)>0:\n    p=data.popleft()\n    for i in r[p]:\n        if dep[i]==-1:\n            dep[i]=dep[p]+1\n            data.append(i)\n    r[p]=[]\nif not all(dep[i+1]>=0 for i in range(n)):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for i in range(2,n+1):\n        for j in R[i]:\n            if dep[j]==dep[i]-1:\n                print(j)\n                break\n", "from collections import deque\nN,M = list(map(int,input().split()))\n\nA = [[] for i in range(N+1)]\n\nfor i in range(M):\n    a,b = list(map(int,input().split()))\n    A[a].append(b)\n    A[b].append(a)\n\ndef BFS():\n    q = deque()\n    q.append(1)\n    pre = [0] * (N+1)\n    pre[0] = pre[1] = -1\n    while(q):\n        x = q.popleft()\n        for y in A[x]:\n            if pre[y] == 0:\n                pre[y] = x \n                q.append(y)\n    if 0 in pre:\n        print('No')\n    else:\n        print('Yes')\n        for i in range(2,N+1):\n            print((pre[i]))\n\nBFS()\n            \n            \n            \n", "N,M=map(int,input().split())\nV=[[]for i in range(N)]\nfor i in range(M):\n    a,b=map(int,input().split())\n    V[a-1].append(b-1)\n    V[b-1].append(a-1)\nprint('Yes')\np,q=0,[0]\nseen=[0]*N\nd=[0]*N\nwhile len(q)!=p:\n    for i in V[q[p]]:\n        if not seen[i]:\n            q.append(i)\n            d[i]=q[p]+1\n        seen[i]+=1\n    p+=1\nd.pop(0)\nfor i in d:print(i)", "from collections import deque\nN, M = list(map(int, input().split()))\nroads = []\nfor _ in range(N):\n    roads.append([])\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    roads[a - 1].append(b - 1)\n    roads[b - 1].append(a - 1)\nvisited = [float('inf')] * N\nq = deque()\nq.append(0)\nvisited[0] = 0\npre = [-1] * N\nwhile q:\n    now_room = q.popleft()\n    for next_room in roads[now_room]:\n        if visited[next_room] != float('inf'):\n            continue\n        visited[next_room] = visited[now_room] + 1\n        if pre[next_room] == -1:\n            pre[next_room] = now_room + 1\n        q.append(next_room)\n# print(*roads)\n# print(*pre)\n\nprint('Yes')\nfor i in range(1, N):\n    print((pre[i]))\n", "from collections import defaultdict, deque\n\nN, M = list(map(int, input().split()))\nedges = defaultdict(list)\nfor _ in range(M):\n    a, b = [int(x)-1 for x in input().split()]\n    edges[a].append(b)\n    edges[b].append(a)\n\ngo_to = [None] * N\n\nq = deque()\nq.append((0, -1))\nis_visited = set()\n\nwhile q:\n    node, prev = q.popleft()\n    if node in is_visited:\n        continue\n    is_visited.add(node)\n    go_to[node] = prev + 1\n    for dest in edges[node]:\n        q.append((dest, node))\n\nprint('Yes')\nfor i in range(1, N):\n    print((go_to[i]))\n\n", "N,M=map(int,input().split())\nfrom collections import deque\n\ng=[[] for _ in range(N+1)]\nfor _ in range(M):\n    a,b=map(int,input().split())\n    g[a].append(b)\n    g[b].append(a)\n\ndef bfs(u):\n    queue = deque([u])\n    ans = [None] * (N+1) # \u8ddd\u96e2\u304c1\u5c0f\u3055\u3044\u96a3\u63a5\u70b9\n    d = [None] * (N+1) # u\u304b\u3089\u306e\u8ddd\u96e2\u306e\u521d\u671f\u5316\n    d[u] = 0 # \u81ea\u5206\u3068\u306e\u8ddd\u96e2\u306f0\n    while queue:\n        v = queue.popleft()\n        for i in g[v]:\n            if d[i] is None:\n                d[i] = d[v] + 1\n                ans[i] = v\n                queue.append(i)\n    return ans\n\n# 0\u304b\u3089\u306e\u5404\u9802\u70b9\u306e\u8ddd\u96e2\nans = bfs(1)\nprint('Yes')\nfor i in range(2,N+1):\n    print(ans[i])", "from collections import deque\nn, m = map(int, input().split())\nroute = [[] for _ in range(n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    route[a].append(b)\n    route[b].append(a)\ndist = [0]*(n+1)\ndist[0] = 0\ndist[1] = 0\n\nd = deque()\nd.append(1)\nans = [0 for _ in range(n+1)]\nwhile d:\n    v = d.popleft()\n    for i in route[v]:\n        if dist[i] != 0:\n            continue\n        dist[i] = dist[v]+1\n        ans[i] = v\n        d.append(i)\n\nif len(dist[2:]) > 0:\n    print('Yes')\n    print(*ans[2:], sep=\"\\n\")\nelse:\n    print('No')\n", "from collections import deque\nN,M=map(int,input().strip().split())\nl=[]\ndp=[[] for _ in range(N)]\nfor _ in range(M):\n    a,b=map(int,input().strip().split())\n    l.append((a,b))\n    dp[a-1].append(b)\n    dp[b-1].append(a)\n\nd=deque([1])\nvisited=[0 for _ in range(N)]\nvisited[0]=1\ncnt=1\nwhile d:\n    tmp=d.popleft()\n    for e in dp[tmp-1]:\n        if visited[e-1]==0:\n            visited[e-1]=tmp\n            cnt+=1\n            d.append(e)\n            \nif cnt!=len(visited):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for n in range(1,N):\n        print(visited[n])", "import bisect,collections,copy,itertools,math,string\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef main():\n    n,m = LI()\n    route = [None] + [[] for _ in range(n)]\n    for _ in range(m):\n        a,b = LI()\n        route[a].append(b)\n        route[b].append(a)\n\n    explored = {1}\n    queue = collections.deque([1])\n    ans = [None for _ in range(n+1)]\n    while len(queue)!=0:\n        nxt = queue.popleft()\n        for nbh in route[nxt]:\n            if nbh not in explored:\n                ans[nbh] = nxt\n                queue.append(nbh)\n                explored.add(nbh)\n    print(\"Yes\")\n    print(*ans[2:],sep=\"\\n\")\n        \nmain()            \n", "N, M=map(int, input().split())\ng = [[] for _ in range(N+1)]\nfor _ in range(M):\n    a, b = [int(x) for x in input().split()]\n    g[a].append(b)\n    g[b].append(a)\n\n\nfrom collections import deque\n\nqueue=deque([1])\nd=[None]*(N+1)\nd[1]=0\nans=[0]*(N+1)\nwhile queue:\n    v=queue.popleft()\n    for i in g[v]:\n        if d[i] is None:\n            d[i]=d[v]+1\n            ans[i]=v\n            queue.append(i)\n\n            \nprint(\"Yes\")\nfor i in range(2,len(ans)):\n    print(ans[i])", "from collections import deque\nN,M=map(int,input().split())\nadjacent=[set() for x in range(N)]\nfor m in range(M):\n    A,B=map(int,input().split())\n    adjacent[A-1].add(B-1)\n    adjacent[B-1].add(A-1)\nans=[0]*N\ndeque1=deque()\nalready=set()\nalready.add(0)\nnum_already=1\nfor j in adjacent[0]:\n    deque1.append(j)\n    already.add(j)\n    num_already+=1\n    ans[j]=1\nwhile(num_already!=N):\n    now=deque1.popleft()\n    for k in adjacent[now]:\n        if k not in already:\n            num_already+=1\n            already.add(k)\n            ans[k]=now+1\n            deque1.append(k)\nprint(\"Yes\")\nfor i in range(1,N):\n    print(ans[i])", "from collections import deque\nn,m=map(int,input().split())\nedge=[[] for _ in range(n)]\nfor i in range(m):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\ndist=[-1]*n\nd=deque()\nd.append(0)\nnow=0\nwhile d:\n    x=d.popleft()\n    for i in range(len(edge[x])):\n        if dist[edge[x][i]]==-1:\n            dist[edge[x][i]]=x+1\n            d.append(edge[x][i])\nprint(\"Yes\")\nfor i in range(n-1):\n    print(dist[i+1])", "from collections import deque\nN, M = list(map(int, input().split()))\nG = [[] for _ in range(N+1)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\nq = deque([1])\nclosed = [False] * (N+1)\nclosed[1] = True\nAns = [0] * (N+1)\nwhile q:\n    v = q.popleft()\n    for u in G[v]:\n        if not closed[u]:\n            closed[u] = True\n            q.append(u)\n            Ans[u] = v\nprint(\"Yes\")\nprint((\"\\n\".join(map(str, Ans[2:]))))\n", "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nroute = [[] for i in range(N)]\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    route[a - 1].append(b - 1)\n    route[b - 1].append(a - 1)\n\nprint('Yes')\n\nq = deque()\nd = [-1] * N\nd[0] = 0\nq.append(0)\n\nwhile q:\n    x = q.popleft()\n    for i in route[x]:\n        if d[i] == -1:\n            d[i] = x + 1\n            q.append(i)\n\nfor i in range(1, N):\n    print((d[i]))\n", "from collections import deque\n\nn, m =map(int, input().split())\n\nans = [-1 for _ in range(n+1)]\nans[0] = 0\nans[1] = 0\n\nV = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    V[x].append(y)\n    V[y].append(x)\n\nd = deque([1])\n\nwhile d:\n    l = d.popleft()\n    for v in V[l]:\n        if ans[v] != -1:\n            continue\n        ans[v] = l\n        d.append(v)\n        \n\n    \nif ans.count(-1) > 0:\n    print('No')\nelse :\n    print('Yes')\n    print(*ans[2:], sep=\"\\n\")\n", "from sys import stdin,stdout\nfrom collections import defaultdict\ndef bfs(src):\n    q=[src]\n    par=[-1]*(n+1)\n    vis=[0]*(n+1)\n    ans=[]\n    while q:\n        cur=q.pop(0)\n        for neigh in g[cur]:\n            if not vis[neigh]:\n                vis[neigh]=1\n                q+=[neigh]\n                par[neigh]=cur\n    for i in range(2,n+1):\n        if par[i]==-1:\n            print('No')\n            return\n        ans+=[par[i]]\n    print('Yes')\n    for v in ans:\n        print(v)\nfor i in range(1):#int(stdin.readline())):\n    # n=int(stdin.readline())\n    g=defaultdict(list)\n    n,e=list(map(int,stdin.readline().split()))\n    for _ in range(e):\n        a,b=map(int,stdin.readline().split())\n        g[a]+=[b]\n        g[b]+=[a]\n    bfs(1)", "from collections import deque\nINF = 1_000_000_000\ndef main():\n    n, m = map(int, input().split(\" \"))\n    to = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(lambda i:int(i)-1, input().split(\" \"))\n        to[a].append(b)\n        to[b].append(a)\n    que = deque()\n    d = {i:INF for i in range(n)}\n    prev = {i:-1 for i in range(n)}\n    d[0] = 0\n    que.append(0)\n    while que:\n        v = que.popleft()\n        for i in to[v]:\n            if d[i] != INF: continue\n            d[i] = d[v] + 1\n            prev[i] = v\n            que.append(i)\n    print(\"Yes\")\n    for i in range(n):\n        if i == 0: continue\n        print(prev[i]+1)\n        \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\nn,m = map(int,input().split())\nto = [[] for _ in range(n)]\n\nfor i in range(m):\n    x, y = map(int,input().split())\n    to[x-1].append(y-1)\n    to[y-1].append(x-1)\n\nINF = float('inf')\ndist = [INF]*n\ndist[0] = 0\n\npre = [-1]*n\n\nque = deque([])\nque.append(0)\n\nwhile que:\n    v = que.popleft()\n    for u in to[v]:\n        if dist[u] != INF:continue\n        dist[u] = v + 1\n        pre[u] = v\n        que.append(u)\nprint(\"Yes\")\nfor i in range(1,n):\n    print(dist[i])", "#import math\nimport collections\nn, m = map(int, input().split( ))\nlis = [[] for _ in range(n+1)]\nfor _ in range(m):\n  a,b = map(int, input().split( ))\n  lis[a].append(b)\n  lis[b].append(a)\n#print(lis)\nans = [0]*(n+1)\nq = collections.deque()\nq.append(1)\ncount = [0]*(n+1)\n#1\u306e\u6642\u306f\u52d5\u304b\u306a\u3044\ncount[1] = 1\nwhile len(q) != 0:\n  v = q.popleft()\n#  print(lis[v], count)\n  #\u307e\u305a\u306f1\u306b\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u90e8\u5c4b\u3092\u63a2\u7d22\u305d\u306e\u5f8c\u9806\u306b\u63a2\u7d22\n  for u in lis[v]:\n    if count[u] == 0:\n      count[u] = 1\n      ans[u] = v\n      q.append(u)\nprint('Yes')\nfor i in range(2,n+1):\n  print(ans[i])", "N, M = list(map(int, input().split()))\n\nto = [[] for i in range(100010)]\n\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    to[a].append(b)\n    to[b].append(a)\n\ndist = [0] * (N+1)\nq = [1]\ndist[0] = -1\n#print(to[:4])\n\ndist = [0] * N\npre = [0] * N\n\nwhile len(q) != 0:\n    a = q.pop(0)\n    for i in to[a]:\n        if dist[i-1] == 0:\n            dist[i-1] = dist[a-1] + 1\n            pre[i-1] = a\n            q.append(i)\n    #print(q)\n\nprint(\"Yes\")\nfor i in range(1, N):\n    print((pre[i]))\n", "\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\nimport marshal\n\n\nclass Graph:\n    def __init__(self, n, directed=False, decrement=True, destroy=False, edges=[]):\n        self.n = n\n        self.directed = directed\n        self.decrement = decrement\n        self.destroy = destroy\n        self.edges = [set() for _ in range(self.n)]\n        self.parent = [-1]*self.n\n        self.info = [-1]*self.n\n        for x, y in edges:\n            self.add_edge(x,y)\n\n    def add_edge(self, x, y):\n        if self.decrement:\n            x -= 1\n            y -= 1\n        self.edges[x].add(y)\n        if self.directed == False:\n            self.edges[y].add(x)\n\n    def add_adjacent_list(self, i, adjacent_list):\n        if self.decrement:\n            self.edges[i] = set(map(lambda x: x - 1, adjacent_list))\n        else:\n            self.edges[i] = set(adjacent_list)\n\n    def bfs(self, start=1, goal=-1, time=0, save=False):\n        \"\"\"\n        :param start: \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\n        :param goal: \u30b4\u30fc\u30eb\u5730\u70b9\n        :param save: True = \u524d\u56de\u306e\u63a2\u7d22\u7d50\u679c\u3092\u4fdd\u6301\u3059\u308b\n        :return: \uff08\u30eb\u30fc\u30d7\u304c\u3042\u3063\u3066\u3082\uff09\u6700\u77ed\u8ddd\u96e2\u3002\u5b58\u5728\u3057\u306a\u3051\u308c\u3070 -1\n        \"\"\"\n        if self.decrement:\n            start -= 1\n            goal -= 1\n        if not save:\n            self.parent = [-1] * self.n\n        p, t = start, time\n        self.parent[p] = -2\n        next_set = deque([(p, t)])\n\n        while next_set:\n            p, t = next_set.popleft()\n            for q in self.edges[p]:\n                if self.parent[q] != -1:\n                    continue\n                if q == goal:\n                    return t + 1\n                self.parent[q] = p\n                next_set.append((q, t + 1))\n        return -1\n\n    def connection_counter(self):\n        \"\"\"\n        :return: \u9023\u7d50\u6210\u5206\u306e\u500b\u6570\u3002\u6709\u52b9\u30b0\u30e9\u30d5\u3067\u306f\u3042\u307e\u308a\u610f\u5473\u304c\u306a\u3044\u3002\n        \"\"\"\n        cnt = 0\n        self.parent = [-1] * self.n\n        for start in range(self.n):\n            if self.parent[start] == -1:\n                cnt += 1\n                self.bfs(start + self.decrement, save=True)\n        return cnt\n\n    def distance_list(self, start=1, save=False):\n        \"\"\"\n        :param start: \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\n        :return: \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u5404\u70b9\u3078\u306e\u8ddd\u96e2\u306e\u30ea\u30b9\u30c8\n        \"\"\"\n        dist = [-1]*self.n\n        if self.decrement:\n            start -= 1\n        if not save:\n            self.parent = [-1] * self.n\n        p, t = start, 0\n        self.parent[p] = -2\n        dist[p] = 0\n        next_set = deque([(p, t)])\n\n        while next_set:\n            p, t = next_set.popleft()\n            for q in self.edges[p]:\n                if self.parent[q] != -1:\n                    continue\n                dist[q] = t + 1\n                self.parent[q] = p\n                next_set.append((q, t + 1))\n        return dist\n\n##################################################################################################\n\nN, M = map(int, input().split())\ngraph = Graph(N, directed=False, decrement=True, destroy=False)\nfor _ in range(M):\n    x, y = map(int, input().split())\n    graph.add_edge(x, y)\n\nif -1 in graph.distance_list():\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*list(p+1 for p in graph.parent[1:]), sep=\"\\n\")\n", "from collections import deque\nn,m = map(int, input().split())\ndis = [n+2]*(n)\ndis[0] = 0\nnear = [[] for _ in range(n)]\nmark = [-1]*(n)\nmark[0] = 0\nque = deque()\nfor _ in range(m):\n  a,b = map(int, input().split())\n  a -= 1\n  b -= 1\n  near[a].append(b)\n  near[b].append(a)\n  if a==0:\n    que.appendleft(b)\n    mark[b] = 0\n    dis[b] = 1\n  if b==0:\n    que.appendleft(a)\n    mark[a] = 0\n    dis[a] = 1\nwhile que:\n  i = que.popleft()\n  for j in near[i]:\n    if dis[i]+1<dis[j]:\n      dis[j] = dis[i]+1\n      mark[j] = i\n      que.append(j)\nif n+2 not in dis:\n  print('Yes')\n  for i in mark[1:]:\n    print(i+1)\nelse:\n  print('No')", "# \u5e45\u512a\u5148\u63a2\u7d22, BFS\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\nneighbor = [[] for _ in range(n)]\nfor edge in edges:\n    neighbor[edge[0]-1].append(edge[1]-1)  # 1- \u2192 0-index\n    neighbor[edge[1]-1].append(edge[0]-1)\n\nqueue = deque()\nqueue.append(0)\n\nback = [-1] * n  # visit\u3057\u305f\u304b\u3069\u3046\u304b\u3092\u517c\u306d\u308b\nback[0] = 0\nwhile len(queue) > 0:\n    vertex = queue.popleft()\n    for nei in neighbor[vertex]:\n        if back[nei] == -1:\n            back[nei] = vertex\n            queue.append(nei)\n        \nprint('Yes')\nfor i in back[1:]:\n    print((i+1))  # 0- \u2192 1-index\n", "from collections import deque\n\n\ndef show_2d_array(array):\n    [print(a) for a in array]\n\n\nN, M = map(int, input().split())\n\ncave = [[] for i in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    cave[a-1].append(b-1)\n    cave[b-1].append(a-1)\n\n\n# show_2d_array(cave)\n\n\ndef bfs(tree, p):\n    seen = [False] * len(tree)\n    queue = deque((p,))\n    depth = [0] * N\n    depth[p] = 0\n    current_depth = depth[p]\n    while len(queue) > 0:\n        # print(queue)\n        q = queue.popleft()\n        seen[q] = True\n        # print(q)\n        for v in tree[q]:\n            if not seen[v]:\n                depth[v] = depth[q] + 1\n                queue.append(v)\n                seen[v] = True\n\n\n    return depth\n\n\ndepth = bfs(cave, 0)\n\n# print(\"depth\", depth)\n\nsign = [0] * N\nans = \"Yes\"\nfor i in range(1, N):\n    this_depth = depth[i]\n    found = False\n    for j in cave[i]:\n        if depth[j] == this_depth - 1:\n            sign[i] = j\n            found = True\n            break\n    if not found:\n        ans = \"No\"\n        break\n\n\"\"\"\nfor i in range(1, N):\n    current = i\n    found = False\n    while not found:\n        next = -1\n        for j in cave[current]:\n            if depth[j] == depth[current]-1:\n                if sign[current] <= 0:\n                    next = j\n                    sign[current] = next\n                    break\n                else:\n                    next = sign[current]\n                    break\n        if next < 0:\n            ans = \"No\"\n            break\n\n        current = next\n        if current == 0:\n            found = True\n\"\"\"\n\nprint(ans)\nif ans == \"Yes\":\n    [print(s+1) for s in sign[1:]]\n\n", "from collections import*\n(n,m),*c = [[*map(int,i.split())]for i in open(0)]\ng = [[]for _ in range(n+1)]\n\nfor a,b in c:\n    g[a]+=[b]\n    g[b]+=[a]\n\nq=deque([1])\nr=[0]*(n+1)\n\nwhile q:\n    v=q.popleft()\n    for i in g[v]:\n        if r[i]==0:\n            r[i]=v\n            q.append(i)\n\nprint(\"Yes\",*r[2:],sep=\"\\n\")\n", "from collections import deque\ninfty = 10 ** 9\n\ndef BFS(graph, parent, u):\n    queue = deque()\n    queue.append(u)\n    visited = [False for k in range(len(parent))] #\u63a2\u7d22\u304c\u59cb\u307e\u3063\u305f\u304b\u5426\u304b\n    visited[u] = True\n    while queue:\n        v = queue.popleft()\n        for j in graph[v]:\n            if not visited[j]:\n                queue.append(j)\n                visited[j] = True\n                parent[j] = v\n\nn, m = map(int, input().split())\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\nparent = [-1 for i in range(n)]\nBFS(graph, parent, 0)\nif -1 in parent[1:]:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for p in parent[1:]:\n        print(p+1)", "from heapq import heappush, heapify, heappop\n\n\ndef dijkstra(start: \"\u59cb\u70b9\", V: \"\u9802\u70b9\u6570\", es: \"\u96a3\u63a5\u30ea\u30b9\u30c8\", INF=10000000000):\n    # INF = 10**10 \u6bce\u56de\u30c1\u30a7\u30c3\u30af\u3057\u3088\u3046\n    prev = [-1] * n  # \u7d4c\u8def\u5fa9\u5143\n    d = [INF] * n  # \u9802\u70b9s\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n    que = [start]\n    d[start] = 0\n    while que:\n        dv, v = divmod(heappop(que), INF)\n        if d[v] < dv:\n            continue\n        for e, de in es[v]:\n            if d[e] > d[v] + de:\n                d[e] = d[v] + de\n                heappush(que, d[e] * INF + e)\n                prev[e] = v\n    return d, prev\n\n\ndef get_path(t, prev):\n    path = []\n    while t != -1:\n        path.append(t)\n        t = prev[t]\n    path.reverse()\n    return path\n\n\nn, m = list(map(int, input().split()))\nes = [[] for _ in range(n)]  # es[i] = (\u9802\u70b9i\u306e(\u96a3\u63a5\u3059\u308b\u9802\u70b9,\u30b3\u30b9\u30c8)\u306e\u7d44)\n# \u5165\u529b\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    es[a].append((b, 1))\n    es[b].append((a, 1))  # \u7121\u5411\u30b0\u30e9\u30d5\n\n\nd, prev = dijkstra(0, n, es)\nprint(\"Yes\")\nfor i in range(1, n):\n    print((prev[i] + 1))\n", "N,M = map(int,input().split())\nt = [[i+1] for i in range(N)]\nfor i in range(M):\n    A,B = map(int,input().split())\n    t[A-1].append(B)\n    t[B-1].append(A)\nfrom collections import deque\nd = deque()\nans = [-1]*(N)\nd.append(t[0])\nwhile len(d) > 0:\n    z = d.popleft()\n    x = z[0]\n    for i in range(1,len(z)):\n        if ans[z[i]-1] == -1:\n            ans[z[i]-1] = x\n            d.append(t[z[i]-1])\nprint(\"Yes\")\nfor i in range(1,len(ans)):\n    print(ans[i])", "from collections import deque\n\nn,m = list(map(int,input().split()))\na = [[] for _ in range(n)]\n\nfor i in range(m):\n    x, y = list(map(int,input().split()))\n    a[x-1].append(y-1)\n    a[y-1].append(x-1)\n\nc = [0]*n\nque = deque([])\nque.append(0)\n\nwhile len(que) > 0:\n    e = que.popleft()\n    for i in a[e]:\n        if c[i] > 0:\n            continue\n        c[i] = e + 1\n        que.append(i)\nprint(\"Yes\")\nfor i in range(1,n):\n    print((c[i]))\n", "from collections import deque\nn, m = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a = list(map(int, input().split()))\n    g[a[0]-1].append(a[1]-1)\n    g[a[1]-1].append(a[0]-1)\nl = [True] * n\nans = [0] * n\nx = deque([1])\nwhile len(x) > 0:\n    a = x.popleft()\n    for i in g[a-1]:\n        if l[i]:\n            x.append(i+1)\n            ans[i] = a\n            l[i] = False\nif l.count(True) == 0:\n    print(\"Yes\")\n    for i in range(1, n):\n        print(ans[i])\nelse:\n    print(\"No\")", "from collections import deque\n\nN, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(M)]\n\numami = [[] for _ in range(N+1)]\nfor a, b in AB:\n    umami[a].append(b)\n    umami[b].append(a)\n\numaaji = [0]*(N+1)\nd = deque([1])\nwhile d:\n    r = d.popleft()\n    for u in umami[r]:\n        if umaaji[u] == 0:\n            umaaji[u] = r\n            d.append(u)\n\nprint(\"Yes\")\nfor u in umaaji[2:]:\n    print(u)", "from collections import deque\nn, m = list(map(int, input().split()))\n\nadj_list = [[] for i in range(n)]\n\nfor i in range(m):\n  _, __ = list(map(int, input().split()))\n  _ -= 1\n  __ -= 1\n  adj_list[_].append(__)\n  adj_list[__].append(_)\n  \ndistance = [None for i in range(n)]\nupdated_from = [None for i in range(n)]\n\nnewly_visited = deque([0])\ndistance[0] = 0\n\nwhile len(newly_visited) > 0:\n  now = newly_visited.popleft()\n  for i in adj_list[now]:\n    if distance[i] is not None: continue\n    newly_visited.append(i)\n    distance[i] = distance[now] + 1\n    updated_from[i] = now\n\n# i \u306b\u5230\u9054\u3067\u304d\u3066\u308c\u3070 distance[i] ==\uff080 \u304b\u3089 i \u307e\u3067\u306e\u8ddd\u96e2\uff09\n# i \u306b\u5230\u9054\u3067\u304d\u3066\u306a\u3051\u308c\u3070 distance[i] == None   \n    \n\"\"\"\nprint(distance)\n\nfor i in range(n):\n  # i \u304b\u3089 0 \u306b\u884c\u304f\u7d4c\u8def\u3092\u6c42\u3081\u308b\n  now = i\n  path = [now]\n  while now != 0:\n    now = updated_from[now]\n    path.append(now)\n  print(i, path) \n\"\"\"\n\nprint(\"Yes\")\nfor i in range(1, n):\n  print((updated_from[i] + 1))\n\n\n", "from collections import deque\n\nN, M = map(int, input().split())\n\ndist = [-1] * (N+1)\ndist[1] = 0\nconnection = [[] for _ in range(N+1)]\nans = [-1] * (N+1)\n\nfor quel in range(M):\n    a, b = map(int, input().split())\n    connection[a].append(b)\n    connection[b].append(a)\n\nque = deque()\nque.append(1)\n\nwhile que:\n    v = que.popleft()\n\n    for i in connection[v]:\n        if dist[i] != -1:continue\n\n        dist[i] = dist[v] + 1\n        que.append(i)\n        ans[i] = v\n\n#print(dist)\nprint('Yes')\nfor j in range(2, N+1):\n    print(ans[j])", "from collections import deque\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(N)]\nflag = [0] * N\n\nfor i in range(M):\n  A, B = map(int, input().split())\n  A -= 1\n  B -= 1\n  graph[A].append(B)\n  graph[B].append(A)\n  \nD = deque([0])\nvisited = [False] * N\nvisited[0] = True\n\nwhile D:\n  v = D.popleft()\n  for i in graph[v]:\n    if visited[i]:\n      continue\n    visited[i] = True\n    flag[i] = v\n    D.append(i)\n    \nprint(\"Yes\")\nfor i in range(1, N):\n  print(flag[i] + 1)", "from collections import deque\n\n#\u5165\u529b:N,M(int:\u6574\u6570)\ndef input2():\n\treturn map(int,input().split())\n\n#\u5165\u529b:[n1,n2,...nk](int:\u6574\u6570\u914d\u5217)\ndef input_array():\n\treturn list(map(int,input().split()))\n  \nn,m=input2()\ng=[[] for _ in range(n+1)] #\u5f15\u6570->\u8981\u7d20\u3067\u9053\u3057\u308b\u3079\u3092\u4fdd\u5b58\nfor i in range(m):\n\ta,b=input2()\n\tg[a].append(b)\n\tg[b].append(a)\n\nq=deque() #bfs\u7528\nq.append(1) #\u59cb\u70b9\n\ncheck=[0]*(n+1) #\u65e2\u306b\u8a2a\u554f\u3057\u3066\u3044\u308b(1)\u304b\u5426(0)\u304b\ncheck[1]=1\n\nans=[0]*(n+1) #\u59cb\u70b9\u306b\u8fd1\u3044\u5074\u306e\uff0c\u4e00\u3064\u524d\u306e\u8981\u7d20(\u89e3\u7b54)\nans[1]=1\nfor _ in range(10**5+1):\n\tif len(q)==0:\n\t\tbreak\n\tv=q.popleft() #\u9802\u70b9\u3092\u4e00\u3064\u53d6\u308a\u51fa\u3059\n\tfor u in g[v]: #v\u3068\u306e\u901a\u8def\u3092\u5168\u3066\u63a2\u7d22\n\t\tif check[u]==0: \n\t\t\tcheck[u]=1 #\u63a2\u7d22\u6e08\u307f==1\n\t\t\tans[u]=v \n\t\t\tq.append(u)\nprint(\"Yes\")\nfor i in range(2,n+1):\n\tprint(ans[i])", "from collections import deque\n\nN, M = map(int, input().split())\n\nG = [[] for _ in range(N+1)]\nm = [tuple(map(int, input().split())) for _ in range(M)]\n\nfor a, b in m:\n    G[a].append(b)\n    G[b].append(a)\n\npar = [0] * (N + 1)\nvisited = [0] * (N + 1)\nroot = 1\nvisited[root] = 1\nq = deque([root])\n\nwhile q:\n    v = q.popleft()\n    for w in G[v]:\n        if visited[w]:\n            continue\n        visited[w] = 1\n        par[w] = v\n        q.append(w)\nprint('Yes')\nprint(*par[2:], sep='\\n')\n    ", "#!/usr/bin/env python3\n\n#import\n#import math\n#import numpy as np\nN, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(M)]\n\nG = {i: [] for i in range(1, N + 1)}\nseen = [False] * (N + 1)\n\nfor a, b in AB:\n    G[a].append(b)\n    G[b].append(a)\n\ndp = [10 ** 9] * (N + 1)\ndp[1] = 0\n\nque = []\nque.append(1)\nwhile len(que) > 0:\n    q = que.pop(0)\n    for g in G[q]:\n        if not seen[g]:\n            seen[g] = True\n            que.append(g)\n        dp[g] = min(dp[g], dp[q] + 1)\n\nprint(\"Yes\")\nfor i in range(2, N + 1):\n    t = dp[i]\n    for g in G[i]:\n        if dp[g] < t:\n            print(g)\n            break", "n,m = map(int,input().split())\nr = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    a,b = map(int,input().split())\n    r[a].append(b)\n    r[b].append(a)\n\nimport collections\nq = collections.deque()\n\nsigh = [-1] * (n+1)\n\nfor i in r[1]:\n    q.append((1,i))\n    \nwhile q:\n    xy = q.popleft()\n    x = xy[0]\n    y = xy[1]\n    \n    if sigh[y] == -1:\n        sigh[y] = x\n        \n        for i in r[y]:\n            q.append([y,i])\n            \nprint(\"Yes\")\nprint(*sigh[2:],sep=\"\\n\")", "from collections import deque\nN,M=map(int,input().split())\nA=[0]*M;B=[0]*M\nC=[[] for i in range(N+1)]\n\nfor i in range(M):\n  A[i],B[i]=sorted(list(map(int,input().split())))\n  C[A[i]].append(B[i])\n  C[B[i]].append(A[i])\n\nd=[-1]*(N+1)\nd[0]=0\nd[1]=0\n\nqueue=deque([1])\nwhile queue:\n  now = queue.popleft()\n  for i in C[now]:\n    if d[i]!=-1:continue\n    d[i]=now\n    queue.append(i)\n\nif d.count(0)>2:print('No');exit\nprint('Yes')\nfor i in range(2,N+1):\n  print(d[i])", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Sep  7 21:29:58 2020\n\n@author: liang\n\"\"\"\n\nN, M = map(int, input().split())\nadj = [list() for _ in range(N)]\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    adj[a-1].append(b-1)\n    adj[b-1].append(a-1)\n\nvisited = [False for i in range(N)]\nsign = [-1]*N\n\nfrom collections import deque\n\nvisited[0] = True\nq = deque()\nq.append(0)\nsign[0] = 0\n\nwhile q:\n    cur = q.popleft()\n    for a in adj[cur]:\n        if not visited[a]:\n            visited[a] = True\n            sign[a] = cur + 1\n            q.append(a)\n\nif all(x >= 0 for x in sign):\n    print(\"Yes\")\n    [print(a) for a in sign[1:] ]\nelse:\n    print(\"No\")    ", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\nG = [[] for i in range(N)]\nfor i in range(M):\n  a,b = list(map(int,readline().split()))\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n\n# 1\u306e\u90e8\u5c4b\u304b\u3089BFS\u3057\u3066\u3001\u521d\u3081\u3066\u6765\u305f\u90e8\u5c4b\u3060\u3063\u305f\u3089\u76f4\u524d\u306e\u90e8\u5c4b\u756a\u53f7(+1)\u3092\u5165\u308c\u308b\nans = [None] * N\n\nfrom collections import deque\nq = deque([])\n\nq.append((0, -1))\nwhile q:\n  v, parent = q.popleft()\n  if ans[v] is not None:\n    continue\n  ans[v] = parent + 1\n  for child in G[v]:\n    if child == parent:\n      continue\n    q.append((child, v))\n\nprint(\"Yes\")\nfor i in range(1, len(ans)):\n  print((ans[i]))\n", "def main():\n\tN, M = [int(x) for x in input().split(\" \")]\n\troute = [[] for i in range(N)]\n\tfor i in range(M):\n\t\tA, B = [int(y) for y in input().split(\" \")]\n\t\troute[A - 1] += [B]\n\t\troute[B - 1] += [A]\n\n\tchecked = [1] + [0] * (N - 1)\n\tto_check = [{\"src\" : s, \"dst\" : 1} for s in route[0]]\n\tsignal = [-1] + [0] * (N - 1)\n\n\tfor r in route[0]:\n\t\tchecked[r - 1] = 1\n\n\twhile len(to_check) > 0:\n\t\tchecking = to_check.pop(0)\n\t\tsrc = checking[\"src\"]\n\t\tsignal[src - 1] = str(checking[\"dst\"])\n\t\trooms = route[src - 1]\n\t\tfor r in rooms:\n\t\t\tif checked[r - 1] == 0:\n\t\t\t\tto_check.append({\"src\": r, \"dst\": src})\n\t\t\t\tchecked[r - 1] = 1\n\n\tif signal.count(0) > 0:\n\t\tprint(\"No\")\n\telse:\n\t\tprint(\"Yes\")\n\t\tprint(\"\\n\".join(signal[1:]))\n\nmain()", "from collections import deque\n\nN,M = map(int,input().split())\nroom_g = [[] for i in range(N+1)]\n\nfor i in range(M):\n  a,b = map(int,input().split())\n  room_g[a].append(b)\n  room_g[b].append(a)\n  \nsign = [-1]*(N+1)\nsign[0] = 0\nsign[1] = 0\n\nd = deque()\nd.append(1)\n\nwhile d:\n  x = d.popleft()\n  for i in room_g[x]:\n    if sign[i] != -1:\n      continue\n    sign[i] = x\n    d.append(i)\n    \nans = sign[2:]\nprint(\"Yes\")\nfor i in range(len(ans)):\n  print(ans[i])", "from collections import deque\nN,M=map(int,input().split())\nC=[[] for i in range(N+1)]\nfor i in range(M):\n  A,B=sorted(list(map(int,input().split())))\n  C[A].append(B)\n  C[B].append(A)\n\nd=[-1]*(N+1)\nd[0]=0\nd[1]=0\n\nqueue=deque([1])\nwhile queue:\n  now = queue.popleft()\n  for i in C[now]:\n    if d[i]!=-1:continue\n    d[i]=now\n    queue.append(i)\n\nif d.count(0)>2:print('No');exit\nprint('Yes')\nfor i in range(2,N+1):\n  print(d[i])", "from collections import deque\nN , M = map(int,input().split())\ng = [[] for _ in range(N)]\nfor _ in range(M):\n    a,b = [int(x) for x in input().split()]\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\nbranch_list = [0 for i in range(N)]\ndef bfs(u):\n    queue = deque([u])\n    d = [None] *N\n    d[u] = 0\n    while queue:\n        v = queue.popleft()\n        for i in g[v]:\n            if d[i] is None:\n                d[i] = d[v] +1\n                queue.append(i)\n                branch_list[i] = v +1\n    return d\nd = bfs(0)\nfor i in range(1,len(branch_list)):\n    if branch_list[i] == 0:\n        print(\"No\")\n        break\n    if i == 1:\n        print(\"Yes\")\n    print(branch_list[i])", "from collections import deque\n\nn,m = map(int,input().split())\nV = [[] for i in range(n+1)]\n\nfor i in range(m):\n    a,b = map(int,input().split())\n    V[a].append(b)\n    V[b].append(a)\n    \nreach = [-1]*(n+1)\nreach[1] = 0\nq = deque([])\nq.append(1)\n\nwhile q:\n    x = q.popleft()\n    \n    for y in V[x]:\n        if reach[y] == -1:\n            reach[y] = x\n            q.append(y)\n\nprint(\"Yes\")\nfor i in range(2,n+1):\n    print(reach[i])", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\n#from operator import itemgetter\n#from heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import breadth_first_order, depth_first_order, shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nimport sys\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN, M = na()\nedge = np.array([na() + [1] for _ in range(M)], dtype=np.int64).T\ng = csr_matrix((edge[2], (edge[:2] - 1)), (N, N))\nd, root = breadth_first_order(g, directed=False, return_predecessors=True, i_start = 0)\nif -9999 not in d[1:]:\n    print('Yes')\n    for i in range(1, N):\n        print(root[i] + 1)\nelse:\n    print('No')", "import copy\nN, M = map(int, input().split())\nres = [[] for i in range(N+5)]\n\n\nfor i in range(M) :\n    a,b = map(int, input().split())\n    a -= 1\n    b -= 1\n    res[a].append(b)\n    res[b].append(a)\n    \npre = [-1] * N\ndist = [-1] * N\nd = 1\ndl = []\npre[0] = 0\ndist[0] = 0\ndl.append(0)\n\nwhile(len(dl) != 0) :\n    a = dl[0]\n    dl.pop(0)\n    for i in res[a] :\n        if(dist[i] != -1):\n            continue\n        dist[i] = dist[a] + 1\n        pre[i] = a\n        dl.append(i)\n        \nfor i in range(N) :\n    if(i == 0) :\n        print(\"Yes\")\n        continue\n    print(pre[i] + 1)", "from collections import deque\n\nn, m = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\nque = deque()\nque.append(0)\n\nvisited = [0 for _ in range(n)]\nvisited[0] = 1\nans = [None for _ in range(n)]\n\nprint('Yes')\nwhile len(que) > 0:\n    c = que.popleft()\n    for ne in graph[c]:\n        if visited[ne] == 1:\n            continue\n        que.append(ne)\n        ans[ne] = c\n        # print(f'ans[{ne}] = {c}')\n        visited[ne] = 1\n\nfor i in range(1, n):\n    print((ans[i] + 1))\n", "from collections import deque\nn,m = list(map(int,input().split()))\n#\u96a3\u63a5\u30ea\u30b9\u30c8\nprint(\"Yes\")\ng = [[] for i in range(n)]\nfor i in range(m):\n  a,b = list(map(int,input().split()))\n  #0-index\u306b\u3057\u307e\u3059\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\nq = deque([])\nq.append(0)\ncheck = [0] * n\nwhile len(q) > 0:\n  e = q.popleft()\n  for i in g[e]:\n    if check[i] > 0:\n      continue\n    check[i] = e + 1\n    q.append(i)\nfor i in range(1,n):\n  print((check[i]))\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\nfrom collections import deque\n\nn,m=nii()\n\ntree=[[] for i in range(n)]\nfor i in range(m):\n  a,b=nii()\n  a-=1\n  b-=1\n  tree[a].append(b)\n  tree[b].append(a)\n\nans=[-1 for i in range(n)]\nans[0]=1\n\nque=deque()\nque.append(0)\n\nwhile que:\n  x=que.popleft()\n  for i in tree[x]:\n    if ans[i]==-1:\n      ans[i]=x\n      que.append(i)\n\nif -1 in ans:\n  print('No')\nelse:\n  print('Yes')\n  for i in ans[1:]:\n    print(i+1)", "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n + 1)]\n\nfor i in range(m):\n  a, b = map(int, input().split())\n  graph[a].append(b)\n  graph[b].append(a)\n\ndist = [-1] * (n + 1)\ndist[0] = 0\ndist[1] = 0\n\nd = deque()\nd.append(1)\n\nwhile d:\n  v = d.popleft()\n  for i in graph[v]:\n    if dist[i] != -1:\n      continue\n    dist[i] = v\n    d.append(i)\n\nans = dist[2:]\nprint(\"Yes\")\nprint(*ans, sep=\"\\n\")\n", "import sys\nfrom collections import deque\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, sys.stdin.readline().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n\nars = [0] * N\ntodo = deque([0])\ndone = {0}\nwhile todo:\n    p = todo.popleft()\n    for np in G[p]:\n        if np in done:\n            continue\n        todo.append(np)\n        ars[np] = p + 1\n        done.add(np)\n\nif len(done) == N:\n    print(\"Yes\")\n    for i in range(1, N):\n        print(ars[i])\nelse:\n    print(\"No\")", "from collections import deque\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndist = [-1] * (n+1)\ndist[0] = 0\ndist[1] = 0\n\nd = deque()\nd.append(1)\n\n#BFS\u5b9f\u884c\u90e8\u5206\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if dist[i] != -1:\n            continue\n        dist[i] = v\n        d.append(i)\n\nif -1 in dist:\n    print(\"No\")\nelse:\n    print(\"Yes\")\nans = dist[2:]\nprint(*ans, sep=\"\\n\")\n", "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n  a, b = map(int, input().split())\n  graph[a - 1].append(b - 1)\n  graph[b - 1].append(a - 1)\n\nans = [-1] * (n - 1)\n\nq = deque()\nq.append(0)\nused = {0}\nwhile q:\n  node = q.popleft()\n  for next_node in graph[node]:\n    if next_node in used:\n      continue\n    q.append(next_node)\n    used.add(next_node)\n    ans[next_node - 1] = node + 1\n\nprint('Yes')\nprint(*ans, sep='\\n')", "from collections import deque\nimport sys\ndef bfs(graph, N, start):\n    visited = [0] * N\n    visited[start] = 1\n    que = deque([start])\n    while que:\n        node = que.popleft()\n        for n in graph[node]:\n            if not visited[n]:\n                visited[n] = node + 1\n                que.append(n)\n    return visited\n\ninput = sys.stdin.readline\n\ndef main():\n    N, M = map(int, input().split())\n\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        A, B = map(lambda n: int(n) - 1, input().split())\n        graph[A].append(B)\n        graph[B].append(A)\n\n    visited = bfs(graph, N, 0)[1:]\n    if all(visited):\n        print(\"Yes\")\n        print(*visited, sep=\"\\n\")\n    else:\n        print(\"No\")\n\n\nmain()", "from collections import deque\nn,m=map(int,input().split())\nprint('Yes')\nroot=[[] for _ in range(n)]\nfor i in range(m):\n    a,b=map(int,input().split())\n    root[a-1].append(b-1)\n    root[b-1].append(a-1)\nq=deque([0])\ncheck=[0]*n\nwhile q:\n    e=q.popleft()\n    for i in root[e]:\n        if check[i]:\n            continue\n        check[i]=e+1\n        q.append(i)\nfor i in range(1,n):\n    print(check[i])", "import queue\n\nq = queue.Queue()\nbool = True\n\n\ndef bfs():\n    q.put(0)\n    while not q.empty():\n        now = q.get()\n        for i in nodes[now]:\n            if dist[i] != -1:\n                continue\n            dist[i] = dist[now] + 1\n            q.put(i)\n            ans[i] = now\n    # bool = False\n\n\nN, M = list(map(int, input().split()))\nnodes = [[] for i in range(N)]\nidxStock = []\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    nodes[a - 1].append(b - 1)\n    nodes[b - 1].append(a - 1)\n\ndist = [-1] * N\nans = [-1] * N\nbfs()\nif bool:\n    print(\"Yes\")\n    for i in range(1, N):\n        print((ans[i] + 1))\nelse:\n    print(\"No\")\n", "from collections import deque\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(N+1)]\n\nfor i in range(M):\n    A, B = map(int, input().split())\n    graph[A].append(B)\n    graph[B].append(A)\n\nparents = [-1] * (N+1)\nparents[0] = 0\nparents[1] = 0\n\nd = deque()\nd.append(1)\n\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if parents[i] != -1:\n            continue\n        parents[i] = v\n        d.append(i)\nans = parents[1:]\nif -1 in parents:\n    print('No')\nelse:\n    print('Yes')\n    parents.pop(0)\n    parents.pop(0)\n    for i in parents:\n        print(i)", "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\nans = [-1] * (n - 1)\nused = [0]*n\nused[0] = 1\nque = deque([0])\nwhile que:\n    posi = que.popleft()\n    for p in graph[posi]:\n        if not used[p]:\n            que.append(p)\n            ans[p-1] = posi+1\n            used[p] = 1\nprint('Yes')\nprint(*ans, sep='\\n')", "from collections import deque\nN,M=map(int,input().split())\nhaba=[[] for i in range(N+1)]\nfor i in range(M):\n    A,B=map(int,input().split())\n    haba[A].append(B)\n    haba[B].append(A)\nkyori=[-1]*(N+1)\nkyori[0]=0\nkyori[1]=0\n\nque=deque()\nque.append(1)\n\nwhile que:\n    kari=que.popleft()\n    for i in haba[kari]:\n        if kyori[i]!=-1:\n            continue\n        kyori[i]=kari\n        que.append(i)\n\nans=kyori[2:]\nprint(\"Yes\")\nfor i in range(len(ans)):\n    print(ans[i])", "import keyword\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\nvisited = [False] * N\npar = [0] * N\nvisited[0] = True\nd = deque(G[0])\nfor i in G[0]:\n    visited[i] = True\n    par[i] = 0\ncur = 0\nwhile d:\n    cur = d.popleft()\n    for i in G[cur]:\n        if not visited[i]:\n            visited[i] = True\n            par[i] = cur\n            d.append(i)\n\nprint('Yes')\nfor i in range(1, N):\n    print((par[i] + 1))\n", "from collections import deque\n\nN, M = [int(x) for x in input().split()]\n\nconn = [[] for _ in range(N + 1)]\n\nfor i in range(M):\n    A, B = [int(x) for x in input().split()]\n    conn[A].append(B)\n    conn[B].append(A)\n\nq = deque([1])\nsignpost = [0] * (N + 1)\n\nwhile q:\n    v = q.popleft()\n    for w in conn[v]:\n        if signpost[w] == 0:\n            signpost[w] = v\n            q.append(w)\n\nprint('Yes')\nfor i in range(2, N + 1):\n    print(signpost[i])", "#\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\nimport heapq\ndef dijkstra(s):\n    p=[x for x in range(n)]#\u89aa\u306e\u8a18\u61b6\n    hq = [(0, s)]\n    heapq.heapify(hq) # \u30ea\u30b9\u30c8\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\u5909\u63db\n    cost = [float('inf')] * n # \u884c\u3063\u305f\u3053\u3068\u306e\u306a\u3044\u3068\u3053\u308d\u306finf\n    cost[s] = 0 # \u958b\u59cb\u5730\u70b9\u306f0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v]: # \u30b3\u30b9\u30c8\u304c\u73fe\u5728\u306e\u30b3\u30b9\u30c8\u3088\u308a\u3082\u9ad8\u3051\u308c\u3070\u30b9\u30eb\u30fc\n            continue\n        for d, u in e[v]:\n            tmp = d + cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                p[u]=v\n                heapq.heappush(hq, (tmp, u))\n    return p\n\nn,m = list(map(int,input().split()))\n#\u91cd\u307f\u4ed8\u304d\u6709\u5411\u30b0\u30e9\u30d5\u306e\u96a3\u63a5\u30ea\u30b9\u30c8e(\u91cd\u307f=1)\ne = [[] for _ in range(n)]\nt=1\nfor _ in range(m):\n    a,b= list(map(int,input().split()))\n    a,b = a-1, b-1\n    e[a].append((t, b))\n    e[b].append((t, a))\n\nans = dijkstra(0)\nprint('Yes')\nfor i in range(1,n):\n  print((ans[i]+1))\n", "from collections import deque\n\nN,M=map(int,input().split())\nG=[[] for _ in range(N+1)]\nfor i in range(M):\n  a,b=map(int,input().split())\n  G[a].append(b)\n  G[b].append(a)\n\nans=[0]*(N+1)\nd=deque([1])\nwhile d:\n  c=d.popleft()\n  for g in G[c]:\n    if not ans[g]:\n      d.append(g)\n      ans[g]=c\n\nprint('Yes')\nfor i in range(2, N+1):\n  print(ans[i])", "from collections import deque\n\nn, m = map(int, input().split())\nc = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    c[a].append(b)\n    c[b].append(a)\n\nif len(c[0]) == 0:\n    print('No')\n    return\n\nl = [0]*n\nl[0] = 1\nq = deque()\nfor i in c[0]:\n    q.append(i)\n    l[i] = 1\nwhile q:\n    p = q.pop()\n    for i in c[p]:\n        if l[i] == 0:\n            l[i] = p+1\n            q.appendleft(i)\n\nprint('Yes')\nfor i in range(1, n):\n    print(l[i])", "import sys\nfrom sys import stdin\ndef I():\n    return stdin.readline().rstrip()\ndef MI():\n    return map(int,stdin.readline().rstrip().split())\ndef LI():\n    return list(map(int,stdin.readline().rstrip().split()))\n#main part\nfrom collections import deque\n \nn, m =MI()\n \nans = [-1 for _ in range(n+1)]\n\n\nans[0] = 0\nans[1] = 0\n \nV = [[] for _ in range(n+1)]\n \nfor _ in range(m):\n    x, y = MI()\n    V[x].append(y)\n    V[y].append(x)\n \nd = deque([1])\n \nwhile d:\n    l = d.popleft()\n    for v in V[l]:\n        if ans[v] != -1:\n            continue\n        ans[v] = l\n        d.append(v)\n        \n \n    \nif ans.count(-1) > 0:\n    print('No')\nelse :\n    print('Yes')\n    for i in ans[2:]:\n        print(i)", "from collections import deque\n\nN, M = map(int, input().split())\ndist = [-1] * N\n# \u521d\u671f\u5316\u3092\u5fd8\u308c\u306a\u3044\u3088\u3046\u306b\uff01\u30b9\u30bf\u30fc\u30c8\u4f4d\u7f6e\u306b\u65e2\u8a2a\u554f\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\u3002\u30eb\u30fc\u30d7\u5185\u3067\u306f\u7acb\u3066\u306a\u3044\u306e\u3067\ndist[0] = 0\nprv = [0] * N\nG = [[] for _ in range(N)]\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\nd = deque()\nd.append(0)\n\nwhile d:\n    now = d.popleft()\n    for nv in G[now]:\n        if dist[nv] == -1:\n            # dist[nv]: \u6700\u77ed\u7d4c\u8def\u306e\u9577\u3055\u3092\u4fdd\u6301\u3002\u3053\u306e\u554f\u984c\u3067\u306f\u4e0d\u8981\u306a\u306e\u3067\u30d5\u30e9\u30b0\u3068\u3057\u3066\uff11\u3092\u5165\u308c\u308b\u3060\u3051\u3067\u3082\u4e8b\u8db3\u308a\u308b\u3002\n            dist[nv] = dist[now] + 1\n            prv[nv] = now\n            d.append(nv)\n\nprint(\"Yes\")\nfor p in prv[1:]:\n    print(p + 1)", "from collections import deque\nN,M = map(int,input().split())\n\ngraph = [[] for _ in range(N)]\nflag = [0] * N\n\nfor i in range(M):\n  A, B = map(int,input().split())\n  A -= 1\n  B -= 1\n  graph[A].append(B)\n  graph[B].append(A)\n  \nD = deque()\nD.append(0)\nvisited = [False] * N\nvisited[0] = True\n\nwhile D:\n  v = D.popleft()\n  for nv in graph[v]:\n    if visited[nv] == True:\n      continue\n    visited[nv] = True\n    flag[nv] = v\n    D.append(nv)\n    \nprint(\"Yes\")\nfor i in range(1,N):\n  print(flag[i] + 1)", "n, m = list(map(int, input().split()))\n\nneighbors = {}\nfor _ in range(m):\n  a, b = list(map(int, input().split()))\n  if a not in list(neighbors.keys()):\n    neighbors.update({a:set()})\n  if b not in neighbors[a]:\n    neighbors[a].add(b)\n  if b not in list(neighbors.keys()):\n    neighbors.update({b:set()})\n  if a not in neighbors[b]:\n    neighbors[b].add(a)\n#print(neighbors)\nlst = [0] * (n - 1) #\u90e8\u5c4b\uff11\u3092\u9664\u304f\u3001\u3059\u3079\u3066\u306e\u90e8\u5c4b\u306e\u901a\u308a\u65b9\u3092\u8abf\u3079\u308b\u3001\u300c\u901a\u3063\u3066\u3044\u306a\u3044\u300d\u30920\u3068\u3057\u3066\u5b9a\u7fa9\nvisited = set() #\u4e00\u5ea6\u8a2a\u308c\u305f\u90e8\u5c4b\u306f\u518d\u5ea6\u63a2\u7d22\u3059\u308b\u5fc5\u8981\u306f\u306a\u3044\u306e\u3067\u3001\u305d\u308c\u3092\u7701\u304f\u305f\u3081\u306e\u96c6\u5408\nqueue = [[0, set([1])]]\nwhile queue:\n  #print(queue)\n  pre_room, rooms = queue.pop(0) #\u5de6\u304c\u4eca\u3044\u308b\u90e8\u5c4b\u3001\u53f3\u304c\u6b21\u306b\u9032\u3080\u90e8\u5c4b\n  #print(pre_room, rooms)\n  for room in rooms:\n    if room in visited:\n      continue\n    if lst[room - 2] == 0 and room != 1: #\u6b21\u306b\u9032\u3080\u90e8\u5c4b\u304c\u901a\u3063\u3066\u3044\u306a\u3044\u304b\u3069\u3046\u304b\uff08\u3068\u4eca\u3044\u308b\u90e8\u5c4b\u304c\uff11\u3067\u306f\u306a\u3044\u3053\u3068\uff09\u306e\u78ba\u8a8d\n      lst[room - 2] = pre_room #\u90e8\u5c4b2\u306e\u5834\u5408\u3001lst\u306eindex\u306f0\u306b\u76f8\u5f53\u3059\u308b\u306e\u3067-2\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n    visited.add(room) #\u4eca\u3044\u308b\u90e8\u5c4b\u3092\u8a2a\u308c\u305f\u306e\u3067\u3001\u96c6\u5408\u306b\u5165\u308c\u308b\n    next_rooms = set() #\u6b21\u306b\u9032\u3080\u90e8\u5c4b\u3092\u63a2\u7d22\u3059\u308b\n    for nei in neighbors[room]:\n      next_rooms.add(nei)\n    next_rooms = [room, next_rooms]\n    queue.append(next_rooms)\nif 0 in lst:\n  print('No')\nelse:\n  print('Yes')\n  for i in range(n - 1):\n    print((lst[i]))\n", "n,m = map(int,input().split())\nAB = [[] for _ in range(n)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    AB[a-1].append(b-1)\n    AB[b-1].append(a-1)\n\nvisited = set()\nans = [0]*n\nstack = [0]\nfor i in stack:\n    # \u3053\u306e\u3078\u3093\u3042\u3084\u3057\u3044\n    for j in AB[i]:\n        if j in visited:\n            continue\n        visited.add(j)\n        ans[j] = i+1\n        stack.append(j)\n    # \u3053\u306e\u3078\u3093\u307e\u3067\nfor i in ans[1:]:\n    if i==0:\n        print('No')\n        return\nprint('Yes')\nfor i in ans[1:]:\n    print(i)", "# \u53c2\u8003\u306b\u3057\u305f\u63d0\u51fa:https://atcoder.jp/contests/abc168/submissions/16604668 #\nfrom collections import deque\nn,m = map(int,input().split())\nl = [[] for i in range(n+1)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nd = [-1] * (n+1)\nd[0],d[1] = 0,0\nqueue = deque()\nqueue.append(1)\nwhile queue:\n    x = queue.popleft()\n    for i in l[x]:\n        if d[i] == -1:\n            d[i] = x\n            queue.append(i)\nif -1 in d:\n    print('No')\nelse:\n    print('Yes')\n    for i in d[2:]:\n        print(i)", "from collections import deque\n\nn,m = map(int, input().split())\n\nconnected = [set() for i in range(n+1)]\n\nfor i in range(m):\n  a,b = map(int, input().split())\n  connected[a].add(b)\n  connected[b].add(a)\n  \ndef bfs(x):\n  queue = deque([x])\n  d = [None] * (n+1)\n  d[x] = 0\n  while queue:\n    v = queue.popleft()\n    for i in connected[v]:\n      if d[i] is None:\n        d[i] = v\n        queue.append(i)\n  return d\n\nprint('Yes')\nans = bfs(1)[2:]\n\nfor i in ans:\n  print(i)", "import queue\nn,m=list(map(int,input().split()))\nl=[[] for i in range(n)]\n\nfor _ in range(m):\n    tempa,tempb=list(map(int,input().split()))\n    tempa-=1\n    tempb-=1\n    l[tempa].append(tempb)\n    l[tempb].append(tempa)\nque=queue.Queue()\ndist=[-1]*n\n\ndist[0]=0\nque.put(0)\nans=[0]*n\n\nwhile not que.empty():\n    v=que.get()\n\n    for nv in l[v]:\n        if dist[nv]!=-1:\n            continue\n        dist[nv]=dist[v]+1\n        que.put(nv)\n        ans[nv]=v\nif -1 in dist:\n    print('No')\nelse:\n    print('Yes')\n    for i in range(1,n):\n        print((ans[i]+1))\n", "from collections import defaultdict, deque\n\nN, M = map(int, input().split())\npath = defaultdict(list)\n\nfor i in range(M):\n    A, B = map(int, input().split())\n    A -= 1\n    B -= 1\n    path[A].append(B)\n    path[B].append(A)\n\nprev = [0] * N\ndist = [0] * N\nq = deque([0])\n\nwhile (len(q) > 0):\n    a = q.popleft()\n    for b in path[a]:\n        if dist[b] != 0:continue\n        q.append(b)\n        prev[b] = a\n        dist[b] = dist[a] + 1\n\nprint('Yes')\n\nfor a in prev[1:]:\n    a += 1\n    print(a)", "from collections import deque\nN,M=map(int,input().split())\nA=[0]*M;B=[0]*M\nC=[[] for i in range(N+1)]\n\nfor i in range(M):\n  A[i],B[i]=sorted(list(map(int,input().split())))\n  C[A[i]].append(B[i])\n  C[B[i]].append(A[i])\n\nd=[-1]*(N+1)\nd[0]=0\nd[1]=0\n\nqueue=deque()\nqueue.append(1)\n\nwhile queue:\n  now = queue.popleft()\n  for i in C[now]:\n    if d[i]!=-1:continue\n    d[i]=d[now]+1\n    queue.append(i)\n#print(d)\nE=[0]*(N+1)\nfor i in range(M):\n#  print(d[A[i]],d[B[i]])\n  if d[B[i]]-d[A[i]]==1 and E[B[i]]==0:E[B[i]]=A[i]\n  elif d[A[i]]-d[B[i]]==1 and E[A[i]]==0:E[A[i]]=B[i]\nif E.count(0)>2:print('No');exit\nprint('Yes')\nfor i in range(2,N+1):\n  print(E[i])", "from collections import deque\nn,m = list(map(int,input().split()))\nload = [list(map(int,input().split())) for _ in range(m)]\ngoal = [[] for _ in range(n)]\nfor i in load:\n    goal[i[0]-1].append(i[1]-1)\n    goal[i[1]-1].append(i[0]-1)\n\nq = deque([0])\nans = [-1 for _ in range(n)]\nans[0] = 0\nwhile q:\n    check = q.popleft()\n    for j in goal[check]:\n        if ans[j] == -1:\n            ans[j] = check+1\n            q.append(j)\nif -1 in ans:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for p in range(1,n):\n        print((ans[p]))\n", "from collections import deque\n\nprint(\"Yes\")\n\nN, M = map(int, input().split())\nnet = [[] for _ in range(N+1)]\nvect = [0]*(N+1)\n\nfor _ in range(M):\n\tA, B = map(int, input().split())\n\tnet[A].append(B)\n\tnet[B].append(A)\n\nq = deque()\nq.append(1)\n\nwhile len(q)>0:\n\tt = q.popleft()\n\tfor i in net[t]:\n\t\tif t != i and vect[i] == 0:\n\t\t\tvect[i] = t\n\t\t\tq.append(i)\n\nfor i in range(2, N+1):\n\tprint(vect[i])", "N, M = map(int, input().split())\n\ndist = [-1] * (N+1)\ndist[1] = 0\nconnection = [[] for _ in range(N+1)]\nans = [-1] * (N+1)\n\nfor quel in range(M):\n    a, b = map(int, input().split())\n    connection[a].append(b)\n    connection[b].append(a)\n\nque = []\nque.append(1)\n\nwhile que:\n    v = que.pop(0)\n\n    for i in connection[v]:\n        if dist[i] != -1:continue\n\n        dist[i] = dist[v] + 1\n        que.append(i)\n        ans[i] = v\n\n#print(dist)\nprint('Yes')\nfor j in range(2, N+1):\n    print(ans[j])", "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n + 1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n#  print(graph)\n\nmark = [-1]*(n+1)\nmark[0] = 0\nmark[1] = 0\n\nd = deque()\nd.append(1)\n\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if mark[i] != -1:\n            continue\n        mark[i] = v\n        d.append(i)\nif mark.count(-1) > 0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    ans = mark[2:]\n    print(*ans, sep=\"\\n\")", "def abc168d_double_dots():\n    n, m = map(int, input().split())\n    path_dict = {}\n    for _ in range(m):\n        a, b = map(int, input().split())\n        if b not in path_dict.keys():\n            path_dict[b] = [a]\n        else:\n            path_dict[b].append(a)\n        a, b = b, a\n        if b not in path_dict.keys():\n            path_dict[b] = [a]\n        else:\n            path_dict[b].append(a)\n\n    q = [1]\n    cnt = 0\n    ans = [0] * n\n    ans[0] = 1\n    while len(q) != 0:\n        no = q.pop(0)\n        for next_room in path_dict[no]:\n            if ans[next_room - 1] == 0:\n                ans[next_room - 1] = no\n                q.append(next_room)\n                cnt += 1\n\n    if cnt != n-1:\n        print('No')\n        return\n    print('Yes')\n    for a in ans[1:]:\n        print(a)\n\n\nabc168d_double_dots()", "# \u53c2\u8003\u306b\u3057\u305f\u63d0\u51fa:https://atcoder.jp/contests/abc168/submissions/16604668 #\nfrom collections import deque\nn,m = map(int,input().split())\nl = [[] for i in range(n+1)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    l[a].append(b)\n    l[b].append(a)\nd = [-1] * (n+1)\nd[0],d[1] = 0,0\nqueue = deque()\nqueue.append(1)\nwhile queue:\n    x = queue.popleft()\n    for i in l[x]:\n        if d[i] == -1:\n            d[i] = x\n            queue.append(i)\nprint('Yes')\nfor i in d[2:]:\n    print(i)", "from collections import deque\nN,M=map(int,input().split())\nA=[0]*M;B=[0]*M\nC=[[] for i in range(N+1)]\n\nfor i in range(M):\n  A[i],B[i]=sorted(list(map(int,input().split())))\n  C[A[i]].append(B[i])\n  C[B[i]].append(A[i])\n\nd=[-1]*(N+1)\nd[0]=0\nd[1]=0\n\nqueue=deque([1])\nwhile queue:\n  now = queue.popleft()\n  for i in C[now]:\n    if d[i]!=-1:continue\n    if d[i]==-1:d[i]=now\n#    d[i]=d[now]+1\n    queue.append(i)\n#print(d)\n#return\n#E=[0]*(N+1)\n#for i in range(M):\n#  if d[B[i]]-d[A[i]]==1 and E[B[i]]==0:E[B[i]]=A[i]\n#  elif d[A[i]]-d[B[i]]==1 and E[A[i]]==0:E[A[i]]=B[i]\nif d.count(0)>2:print('No');exit\nprint('Yes')\nfor i in range(2,N+1):\n  print(d[i])", "#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\n\n# from itertools import combinations as comb\n# form bisect import bisect_left, bisect_right, insort_left, insort_right\n# from collections import Counter\n# import numpy as np\n\nYES = \"Yes\"  # type: str\n\n\ndef solve(N: int, M: int, A: \"List[int]\", B: \"List[int]\"):\n    routes = [set() for _ in range(N)]\n    marks = [None for _ in range(N)]\n    for a, b in zip(A, B):\n        a = a - 1\n        b = b - 1\n        routes[a].add(b)\n        routes[b].add(a)\n\n    marks[0] = -1\n    cur_rooms = [0]\n    count = 1\n    while count < N:\n        new_cur_rooms = []\n        for cur_room in cur_rooms:\n            next_rooms = list(routes[cur_room])\n            for next_room in next_rooms:\n                if marks[next_room] is None:\n                    marks[next_room] = cur_room\n                    new_cur_rooms.append(next_room)\n                    count += 1\n        cur_rooms = new_cur_rooms\n\n    answer = \"Yes\\n\" + \"\\n\".join((str(n + 1) for n in marks[1:]))\n\n    return answer\n\n\ndef main():\n    tokens = chain(*(line.split() for line in sys.stdin))\n    # N, M, A, B = map(int, line.split())\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n    answer = solve(N, M, A, B)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import itertools\n# import math\nimport sys\nsys.setrecursionlimit(500*500)\n# import numpy as np\nfrom collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# A_B = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# edges = [list(map(int,input().split())) for _ in range(M)]\n# tree = [[] for _ in range(N + 1)]\n\n# for edge in edges:\n#     tree[edge[0]].append([edge[1], edge[2]])\n#     tree[edge[1]].append([edge[0], edge[2]])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\ntree = [[] for _ in range(N + 1)]\nedges = [list(map(int,input().split())) for _ in range(M)]\n\nfor edge in edges:\n    tree[edge[0]].append(edge[1])\n    tree[edge[1]].append(edge[0])\n\ndepth = [-1] * (N + 1)\ndepth[1] = 0\n\nd = deque()\nd.append(1)\n\nans = [0] * (N + 1)\nwhile d:\n v = d.popleft()\n for i in tree[v]:\n   if depth[i] != -1:\n     continue\n   depth[i] = depth[v] + 1\n   ans[i] = v\n   d.append(i)\n\n# ans = depth[2:]\nprint('Yes')\nprint(*ans[2:], sep=\"\\n\")", "from collections import deque\n\nn,m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\ndist = [0] * (n+1)\nvisited = [0] * (n+1)\n\n\nfor _ in range(m):\n    a,b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nvisited[root] = 1\nd  = deque([root])\n\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if visited[i]:\n            continue\n        visited[i] = 1\n        dist[i] = v\n        d.append(i)\n\nprint('Yes')\nans = dist[2:]\nprint(*ans, sep=\"\\n\")", "from collections import deque\n\nn, m = map(int, input().split())\na = [[] for _ in range(n)]\nfor i in range(m):\n    x, y = map(int, input().split())\n    a[x - 1].append(y - 1)\n    a[y - 1].append(x - 1)\nc = [0] * n\nque = deque([])\nque.append(0)\nwhile len(que) > 0:\n    e = que.popleft()\n    for i in a[e]:\n        if c[i] > 0:\n            continue\n        c[i] = e + 1\n        que.append(i)\nprint(\"Yes\")\nfor i in range(1, n):\n    print(c[i])", "from collections import deque\n\nn, m = map(int,input().split())\ng = [[] for _ in range(n+1)]\nfor i in range(m):\n  a, b = map(int,input().split())\n  g[a].append(b)\n  g[b].append(a)\n  \nyet = [-1 for _ in range(n+1)]\nyet[0] = 0\nyet[1] = 1\n\nd = deque([1])\n\nwhile d:\n  v = d.popleft()\n  for i in g[v]:\n    if yet[i] == -1:\n      yet[i] = v\n      d.append(i)\n      \nans = yet[2:]\nprint(\"Yes\")\nprint(*ans, sep=\"\\n\")", "N,M=map(int,input().split())\nl=[[] for i in range(N)]\nfor i in range(M):\n   a,b=map(int,input().split())\n   a-=1;b-=1\n   l[a].append(b)\n   l[b].append(a)\nvisited=[-1]*N\nvisited[0]=1\nfrom collections import deque\nque=deque([0])\nwhile que:\n   node=que.popleft()\n   for i in l[node]:\n      if visited[i]==-1:\n         visited[i]=node+1\n         que.append(i)\nif -1 in visited:\n   print(\"No\")\nelse:\n   print(\"Yes\")\n   for i in range(1,N):\n      print(visited[i])", "from collections import deque\n\nn, m = map(int,input().split())\n\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(m):\n    a,b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n# dist = [-1]*(n+1)\n# dist[0] = 0\n# dist[1] = 0\nmark = [-1]*(n+1)\nmark[0] - 0\nmark[1] = 0\n\n\nd = deque()\nd.append(1)\n\nwhile d:\n    v = d.popleft()\n    for i in graph[v]:\n        if mark[i] != -1:\n        # if dist[i] != -1:\n            continue\n        mark[i] = v\n        # dist[i] = dist[v] + 1\n        d.append(i)\n\nif '-1' in mark:\n    print('No')\nelse:\n    print('Yes')\n    print(*mark[2:], sep='\\n')\n"]
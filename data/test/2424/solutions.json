["import sys\nreadline = sys.stdin.readline\n\nMOD = 998244353\nN = int(readline())\nwants = [tuple(map(int, readline().split()))[1:] for _ in range(N)]\n\nQ = [0]*(10**6+1)\nP = [0]*(10**6+1)\n\nfor i in range(N):\n    k = len(wants[i])\n    kinv = pow(k, MOD-2, MOD)\n    for w in wants[i]:\n        P[w] += 1\n        Q[w] = (Q[w] + kinv)%MOD\n\nres = 0\nfor i in range(10**6+1):\n    res = (res+P[i]*Q[i])%MOD\n\nprint(pow(N**2, MOD-2, MOD)*res%MOD)", "from fractions import Fraction\nimport collections\n\nMOD = 998244353\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\nnkids = int(input())\ncnts = collections.defaultdict(int)\npickprobs = collections.defaultdict(int)\nfor i in range(nkids):\n    ls = list(map(int, input().split()))[1:]\n    md = modinv(len(ls),MOD)\n    for e in ls:\n        cnts[e] += 1\n        pickprobs[e] += md\n\nres = 0\nmdd = modinv(nkids**2,MOD)\nfor k in list(cnts.keys()):\n    res += cnts[k]*pickprobs[k]*mdd\nprint(res%MOD)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nP = 998244353\nN = int(input())\nX = [0] * 1001001\nA = [[int(a) for a in input().split()[1:]] for _ in range(N)]\n\nfor i in range(N):\n    for a in A[i]:\n        X[a] += 1\n\nans = 0\nfor i in range(N):\n    ans = (ans + sum([X[a] for a in A[i]]) * pow(len(A[i]), P-2, P)) % P\n\nprint(ans * pow(N*N, P-2, P) % P)", "import sys\ninput = sys.stdin.readline\nMOD = 998244353\n\nn = int(input())\ninfo = [list(map(int, input().split())) for i in range(n)]\nans = 0\n\nmemo = {}\nfor i in range(n):\n    for j in info[i][1:]:\n        if j-1 not in memo:\n            memo[j-1] = 1\n        else:\n            memo[j-1] += 1\n\nmemo_p = {}\nstudent_p = 1 * pow(n, MOD-2, MOD)\npow_memo = {}\nfor i in range(n):\n    k = info[i][0]\n    if k not in pow_memo:\n        pow_memo[k] = pow(k, MOD-2, MOD)\n    for j in info[i][1:]:\n        if j-1 not in memo_p:\n            memo_p[j-1] = pow_memo[k]\n        else:\n            memo_p[j-1] += pow_memo[k]\n        memo_p[j-1] %= MOD\n\nfor i in memo:\n    ans += memo[i] * memo_p[i]  \n    ans %= MOD\nprint((ans * student_p * student_p) % MOD)", "import sys\n\np = 998244353\nn = int(sys.stdin.readline().strip())\nA = [0] * (10 ** 6 + 1)\na = []\nk = []\nfor i in range (0, n):\n    line = list(map(int,sys.stdin.readline().strip().split()))\n    k.append(line[0])\n    a.append(line[1:])\n    for j in range (0, k[i]):\n        x = a[i][j]\n        A[x] = A[x] + 1\nr, s = 0, 1\nfor i in range (0, n):\n    x = 0\n    for j in range (0, k[i]):\n        x = x + A[a[i][j]]\n    y = k[i] * n\n    r, s = (r * y + s * x) % p, (s * y) % p\nans = r\ns = s * n\nq = p - 2\nwhile q > 0:\n    if q % 2 == 1:\n        ans = (ans * s) % p \n        q = q - 1\n    else:\n        q = q // 2\n        s = (s * s) % p\n\n\nprint(ans % p)", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nmod = 998244353\n\nn = int(input())\ncnt = [0]*(10**6+1)\nkids = []\nfor i in range(n):\n    k, *a = map(int, input().split())\n    for ai in a:\n        cnt[ai] += 1\n    kids.append(a)\n\ninv_n = pow(n, mod-2, mod)\nans = 0\nfor i in range(n):\n    k = len(kids[i])\n    for ai in kids[i]:\n        ans += inv_n * pow(k, mod-2, mod) * inv_n * cnt[ai]\n        ans %= mod\nprint(ans)", "import sys\nfrom collections import Counter\nmod = 998244353\n\nn = int(input())\ndiv_n = pow(n, mod-2, mod)\nwants = []\ncnt = Counter()\nfor a in (list(map(int, l.split())) for l in sys.stdin):\n    wants.append(a[1:])\n    cnt.update(a[1:])\n\nans = 0\n\nfor i in range(n):\n    prob = div_n * pow(len(wants[i]), mod-2, mod) * div_n % mod\n    for x in wants[i]:\n        ans = (ans + prob * cnt[x]) % mod\n\nprint(ans)\n"]
["import sys\ninput = sys.stdin.readline\nimport time\n\nfrom collections import deque\n\ndef main():\n    t1 = time.time()\n\n    n = int(input())\n    \n    a = [[int(i) for i in input().split()] for j in range(n)]\n    \n    check = [0]*n\n    used = [False]*n\n    \n    d = deque()\n    \n    for i in reversed(range(n)):\n        if used[i] == True:\n            continue\n        if a[a[i][0]-1][0] == i+1:\n            d.appendleft([i+1,a[i][0]])\n            used[i] = True\n            used[a[i][0]-1] = True\n            check[i] = 1\n            check[a[i][0]-1] = 1\n            \n    ans = 0\n    \n    if len(d) == 0:\n        print(-1)\n        return\n    \n    #print(d)\n    \n    while len(d) > 0:\n        if time.time() - t1 >= 1.95:\n            print(n*(n-1)//2)\n            return\n        used = [False]*n\n        ans += 1\n        num = len(d)\n        for i in range(num):\n            tmp = d.popleft()\n            for j in range(2):\n                if check[tmp[j]-1] == n-1:\n                    continue\n                psn = a[tmp[j]-1][check[tmp[j]-1]]-1\n                mys = tmp[j]-1\n                \n                if check[mys] == n-1 or check[psn] == n-1:\n                    continue\n                #print(tmp,psn,a[psn][check[psn]])\n                #print(i,j,tmp,psn,check[mys],check[psn])\n                if used[mys] == True or used[psn] == True:\n                    continue\n    \n                if a[psn][check[psn]] == mys+1:\n                    d.append([psn+1,mys+1])\n                    used[mys] = True\n                    used[psn] = True\n                    check[mys] += 1\n                    check[psn] += 1\n        #print(d)\n        \n    for i in range(n):\n        if check[i] != n-1:\n            print(-1)\n            return\n    \n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\ndef solve():\n    INF = float('inf')\n\n    N = int(input())\n    Ass = [tuple([int(x)-1 for x in input().split()]) for _ in range(N)]\n\n    adjL = [[] for _ in range(N*N)]\n    indegs = [0] * (N*N)\n    for i, As in enumerate(Ass):\n        x, y = i, As[0]\n        if x > y:\n            x, y = y, x\n        vPrev = x*N + y\n        for A in As[1:]:\n            x, y = i, A\n            if x > y:\n                x, y = y, x\n            v = x*N + y\n            adjL[vPrev].append(v)\n            indegs[v] += 1\n            vPrev = v\n\n    def getMaxCostsDAG(adjList, indegs, INF):\n        numV = len(adjList)\n        vs = [v for v in range(numV) if indegs[v] == 0]\n        costs = [INF] * numV\n        for v in vs:\n            costs[v] = 0\n        Q = deque(vs)\n        while Q:\n            vNow = Q.popleft()\n            cost = costs[vNow]\n            for v2 in adjList[vNow]:\n                indegs[v2] -= 1\n                if indegs[v2] == 0:\n                    costs[v2] = cost + 1\n                    Q.append(v2)\n        return costs\n\n    costs = getMaxCostsDAG(adjL, indegs, INF)\n\n    ans = max(costs)\n    if ans == INF:\n        print((-1))\n    else:\n        print((ans+1))\n\n\nsolve()\n", "from collections import deque\nN = int(input())\nA = [list([int(x)-1 for x in input().split()])[::-1] for _ in range(N)]\nq = deque([])\n\n# \u9078\u624bi\u304c\u8a66\u5408\u304c\u3067\u304d\u308b\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u3001\u3067\u304d\u308b\u306a\u3089\u3070\u30ad\u30e5\u30fc\u306b\u5165\u308c\u308b\ndef check(i, q):\n  if len(A[i]) == 0:\n    return\n  j = A[i][-1]\n  if len(A[j]) == 0:\n    return\n  if A[j][-1] == i:\n    if i > j:\n      i, j = j, i\n    q.append((i, j))\n  return \n\nfor i in range(N):\n  check(i, q)\n\nday = 0\nwhile q:\n  day += 1\n  q = set(sorted(q))\n  prev = deque([])\n  prev, q = q, prev\n  for i, j in prev:\n    A[i].pop(-1)\n    A[j].pop(-1)\n  for i, j in prev:\n    check(i, q)\n    check(j, q)\n  \nfor i in range(N):\n  if len(A[i]) != 0:\n    print((-1))\n    return\n\nprint(day)\n\n", "def main():\n\tfrom collections import deque\n\tn=int(input())\n\tbattle=n*(n-1)//2\n\tlis=[[] for i in range(battle)]\n\tnum=[-1]*(n**2)\n\tcnt=-1\n\tfor x in range(n**2):\n\t\tif x//n<x%n:\n\t\t\tcnt+=1\n\t\t\tnum[x]=cnt\n\tfor i in range(n):\n\t\ta=list(map(int,input().split()))\n\t\tfor j in range(n-2):\n\t\t\tx=a[j]-1\n\t\t\ty=a[j+1]-1\n\t\t\tpx=num[min(i*n+x,x*n+i)]\n\t\t\tpy=num[min(i*n+y,y*n+i)]\n\t\t\tlis[px].append(py)\n\tnode_in=[0]*(battle)\n\tfor i in range(battle):\n\t\tfor x in lis[i]:\n\t\t\tnode_in[x]+=1\n\tzero=deque([])\n\tdays=[10**9]*(battle)\n\tfor i in range(battle):\n\t\tif node_in[i]==0:\n\t\t\tzero.append(i)\n\t\t\tdays[i]=1\n\twhile zero:\n\t\tr=zero.popleft()\n\t\tfor x in lis[r]:\n\t\t\tnode_in[x]-=1\n\t\t\tif node_in[x]==0:\n\t\t\t\tzero.append(x)\n\t\t\t\tdays[x]=days[r]+1\n\tif 10**9 in days:\n\t\tprint(-1)\n\telse:\n\t\tprint(max(days))\ndef __starting_point():\n\tmain()\n__starting_point()", "from collections import deque\n\nn = int(input())\na = []\nfor i in range(n):\n    ai = list(map(int, input().split()))\n    a.append([tuple(sorted((i, aij - 1))) for aij in ai])\n\nidx = [0] * (n + 1)\npool = set()\nq = deque([ai[0] for ai in a])\nday = 1\ns = set()\n\nwhile q:\n    # print('-' * 30)\n    # print('pool:', pool)\n    # print('s:', s)\n    # print('q:', q)\n    p = q.popleft()\n    if p not in pool:\n        pool.add(p)\n    else:\n        pool.remove(p)\n        x, y = p\n        idx[x] += 1\n        idx[y] += 1\n\n        if x in s or y in s:\n            day += 1\n            s = {x, y}\n        else:\n            s.add(x)\n            s.add(y)\n\n        if idx[x] < n - 1:\n            q.append(a[x][idx[x]])\n        if idx[y] < n - 1:\n            q.append(a[y][idx[y]])\n\n# print('=' * 20)\nif pool:\n    print(-1)\nelse:\n    print(day)", "from collections import deque\n\ndef main():\n  n=int(input())\n  a=[0]*n\n  for i in range(n):\n    a[i]=deque(list(map(lambda x:int(x)-1,input().split())))\n  q=deque([])\n  tmp=set()\n  for idx,i in enumerate(a):\n    x=idx\n    y=i[0]\n    if x == a[y][0]:\n      tmp.add(x)\n      tmp.add(y)\n  q=deque(tmp)\n  for i in tmp:\n    a[i].popleft()\n  \n  \n  day=0\n  while True:\n    day+=1\n    t=q.copy()\n    q=deque()\n    tmp=set()\n    while t:\n      x=t.popleft()\n      if len(a[x])==0: continue;\n      y=a[x][0]\n      if x == a[y][0]:\n        tmp.add(x)\n        tmp.add(y)\n    q=deque(tmp)\n    for i in tmp:\n      a[i].popleft()\n    if len(q)==0: break;\n\n  for i in range(n):\n    if len(a[i])!=0:\n      print(-1)\n      return\n  print(day)\n\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = []\n    for _ in range(n):\n        t = deque(list(([int(x) - 1 for x in input().split()])))\n        A.append(t)\n\n    que = deque(list(range(n)))\n    res = 0\n    emp = [False] * n\n    while que:\n        next_que = deque([])\n        check = set()\n        while que:\n            i = que.popleft()\n            if A[i]:\n                idx = A[i][0]\n                if i not in check and idx not in check and A[idx][0] == i:\n                    A[i].popleft()\n                    A[idx].popleft()\n                    next_que.append(i)\n                    next_que.append(idx)\n                    check.add(i)\n                    check.add(idx)\n            else:\n                emp[i] = True\n        que = next_que\n        if que:\n            res += 1\n    else:\n        print((res if all(emp) else -1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\n\ndef is_not_empty(A):\n    for x in A:\n        if x: return True\n    return False\n\nN = int(input())\nA = [deque([int(i) - 1 for i in input().split()]) for _ in range(N)]\n\nans = 0\nyesterday = set(range(N))\nwhile is_not_empty(A):\n    today = set()\n    for my in yesterday:\n        if not A[my]: continue\n        if my in today: continue\n        enemy = A[my][0]\n        if my == A[enemy][0] and enemy not in today:\n            today.add(A[my].popleft())\n            today.add(A[enemy].popleft())\n\n    if not today:\n        ans = -1\n        break\n\n    ans += 1\n    yesterday = today\n\nprint(ans)", "n=int(input())\nimport time\nT=time.time()\ndata_set=[0 for i in range(n)]\nfor i in range(n):\n    a=list(map(int,input().split()))\n    a.append(-1)\n    data_set[i]=a\nindex=[0 for i in range(n)]\nans=-1\nflag=True\nsemi=False\nnow=[data_set[i][index[i]] for i in range(n)]\nfinished=[False for i in range(n)]\nwhile flag:\n    visited=[False for i in range(n)]\n    sub=False\n    for i in range(n):\n        #now\u30ea\u30b9\u30c8\u306e\u3046\u3061\u65e5\u3042\u308a\u304b\u3089i+1\u756a\u76ee\u306e\u3082\u306e\u306b\u3064\u3044\u3066\u306e\u4e00\u81f4\u6761\u4ef6\u306e\u78ba\u8a8d\n        K=now[i]\n        if now[K-1]==i+1 and not(visited[i] or visited[K-1]) and not(finished[i] or finished[K-1]):\n                    visited[i]=True\n                    visited[K-1]=True\n                    index[i]+=1\n                    index[K-1]+=1\n                    sub=True\n                    if index[i]==n-1:\n                        finished[i]=True             \n                    now[i]=data_set[i][index[i]]\n                    if index[K-1]==n-1:\n                        finished[K-1]=True                   \n                    now[K-1]=data_set[K-1][index[K-1]]\n    if not sub:\n        flag=False\n    if time.time()-T>1.5:\n        flag=False\n        semi=True\n    ans+=1\njudge=True\nfor i in range(n):\n  if finished[i]==False:\n    judge=False\n    break\nif judge:\n  print(ans)\nelse:\n  if not semi:\n    print((-1))\n  if semi:\n    print((499500))\n", "N=int(input())\ndef proc(x):\n  return int(x)-1\nfrom collections import deque\nA=[deque(list(map(proc,input().split()))+[-1]) for i in range(N)]\n\nans = 0\nrest = N*(N-1)\ncand = set(range(N))\nwhile rest>0:\n  cand_next=set()\n  for n in cand:\n    if A[A[n][0]][0]==n:\n      cand_next.add(n)\n  if len(cand_next)==0:\n    ans=-1\n    break\n  rest-=len(cand_next)\n  cand=set()\n  for n in cand_next:\n    A[n].popleft()\n    cand.add(n)\n    if A[n][0]!=-1:\n      cand.add(A[n][0])\n  ans+=1\n    \n\nprint(ans)\n", "from collections import deque\nN = int(input())\nA = [deque(map(lambda x: int(x)-1,input().split(\" \"))) for _ in range(N)]\nans = 0\nused_prev = set(range(N))\n\nwhile any(A):\n    used = set()\n    for i in used_prev:\n        a = A[i]\n        if not a or i in used:\n            continue\n        j = a[0]\n        b = A[j]\n        if not b or j in used:\n            continue\n        if i == b[0]:\n            A[i].popleft()\n            A[j].popleft()\n            used.add(i)\n            used.add(j)\n    if not used:\n        ans = -1\n        break\n    used_prev = used\n    ans += 1\nprint(ans)", "from collections import deque\ndef solve():\n    n = int(input())\n    a = []\n    for i in range(n):\n        ai = [int(j)-1 for j in input().split()]\n        a.append(deque(ai))\n    d = set()\n    q = deque()\n    for i in range(n):\n        ai = a[i].popleft()\n        if i < ai:\n            q.append((i, ai))\n        else:\n            q.append((ai, i))\n    ans = 0\n    while q:\n        ans += 1\n        nxt_q = deque()\n        while q:\n            i, ai = q.pop()\n            if (i, ai) in d:\n                if a[i]:\n                    ni = a[i].popleft()\n                    if i < ni:\n                        nxt_q.append((i, ni))\n                    else:\n                        nxt_q.append((ni, i))\n                if a[ai]:\n                    ni = a[ai].popleft()\n                    if ai < ni:\n                        nxt_q.append((ai, ni))\n                    else:\n                        nxt_q.append((ni, ai))\n            else:\n                d.add((i, ai))\n        q = nxt_q\n    if any(i for i in a):\n        ans = -1\n    print(ans)\n\nsolve()", "from collections import deque\nfrom typing import List, Optional, Tuple\n\n\ndef cycle_detectable_topological_sort(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> Tuple[Optional[List[int]], Optional[List[int]]]:\n    \"\"\"Topological sort that uses Kahn's algorithm and detects a loop (DAG or not).\n    Returns:\n        if the given graph is DAG, a list of sorted vertices and a list of depths of\n        each vertex is returned.\n        Otherwise, (None, None) is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    order = []\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            order.append(i)\n            depths[i] = 0\n\n    queue = deque(order)\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = max(depths[v], cur_depth + 1)\n                queue.append(v), order.append(v)\n    return (order, depths) if len(order) + first_index == V else (None, None)\n\n\ndef abc139_e():\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        prev_id = -1\n        for j in a:\n            cur_id = ids[i][j]\n            if prev_id != -1:\n                graph[prev_id].append(cur_id)\n                in_degrees[cur_id] += 1\n            prev_id = cur_id\n\n    _, depths = cycle_detectable_topological_sort(graph, in_degrees)\n    print((max(depths) + 1 if depths is not None else -1))\n\n\ndef __starting_point():\n    abc139_e()\n\n__starting_point()", "from collections import deque, defaultdict\n\nN = int(input())\nA = [deque([int(a) - 1 for a in input().split()]) for _ in range(N)]\n\nD = [0] * N\ncanBattle = defaultdict(lambda: False)\nque = deque(list(range(N)))\n\nwhile que:\n    i = que.popleft()\n    j = A[i][0]\n    canBattle[(i, j)] = True\n\n    if canBattle[(j, i)]:\n        A[i].popleft()\n        A[j].popleft()\n        day = max(D[i], D[j])\n        D[i] = D[j] = day + 1\n\n        if A[i]:\n            que.append(i)\n        if A[j]:\n            que.append(j)\n\nif all(len(a) == 0 for a in A):\n    print((max(D)))\nelse:\n    print((-1))\n\n\n", "import sys\nimport re\nimport math\nimport collections\nimport decimal\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nnb = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n = ni()\n    match = [collections.deque(nb()) for _ in range(n)]\n\n    nxt = [-1] * n\n    waiting = collections.deque(list(range(n)))\n    cnt = [0] * n\n\n    while len(waiting) > 0:\n        ego = waiting.popleft()\n        if len(match[ego]) == 0:\n            continue\n\n        enemy = match[ego].popleft()\n\n        if nxt[enemy] == ego:\n            waiting.append(ego)\n            waiting.append(enemy)\n            cnt[ego] = cnt[enemy] = max(cnt[ego], cnt[enemy]) + 1\n\n        else:\n            nxt[ego] = enemy\n\n    if any(match):\n        print((-1))\n    else:\n        print((max(cnt)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport sys\nN=int(input())\nmatch=[]\nfor i in range(N):\n    a=list(map(int,input().split()))\n    match.append(a)\nday=[0]*(N)\ncount=[0]*(N)\nq=deque(range(N))\nwhile q:\n    p=q.popleft()\n    if count[p-1]<N-1:\n        enemy=match[p-1][count[p-1]]\n        if p==match[enemy-1][count[enemy-1]]:\n            today=max(day[p-1],day[enemy-1])+1\n            day[p-1]=today\n            day[enemy-1]=today\n            count[p-1]+=1\n            count[enemy-1]+=1\n            q.append(p)\n            q.append(enemy)\nif min(count)!=N-1:\n    print(-1)\nelse:\n    print(max(day))", "from collections import deque\nn = int(input())\nm = []\nfor i in range(n):\n  a = [*map(int,input().split())]\n  m.append(a)\nd = [0]*n\nc = [0]*n\nq = deque(range(n))\nwhile q:\n  p = q.popleft()\n  if c[p-1]<n-1:\n    e = m[p-1][c[p-1]]\n    if p==m[e-1][c[e-1]]:\n      t=max(d[p-1],d[e-1])+1\n      d[p-1]=t\n      d[e-1]=t\n      c[p-1]+=1\n      c[e-1]+=1\n      q.append(p)\n      q.append(e)\nif min(c)!=n-1:\n  print(-1)\nelse:\n  print(max(d))", "from collections import deque\n\ndef main():\n  n=int(input())\n  a=[0]*n\n  for i in range(n):\n    a[i]=deque(list(map(lambda x:int(x)-1,input().split())))\n  tmp=set()\n  for p1,p in enumerate(a):\n    p2=p[0]\n    if p1==a[p2][0]:\n      tmp.add(p1)\n      tmp.add(p2)\n  q=deque(tmp)\n  for i in tmp:\n    a[i].popleft()\n  \n  day=0\n  while True:\n    day+=1\n    tmp=set()\n    while q:\n      p1=q.popleft()\n      if len(a[p1])==0: continue;\n      p2=a[p1][0]\n      if p1==a[p2][0]:\n        tmp.add(p1)\n        tmp.add(p2)\n    q=deque(tmp)\n    for i in tmp:\n      a[i].popleft()\n    tmp=set()\n    if len(q)==0: break;\n    \n  for i in a:\n    if i:\n      print(-1)\n      return\n  print(day)\n\n\ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\nn=int(input())\nx=lambda i:int(i)-1\na=[deque(list(map(x,input().split()))+[-1]) for _ in range(n)] \ntcnt,ans=n*(n-1),0\nchk=set(range(n))\nwhile tcnt>0:\n    chk_next=set()\n    for i in chk:\n        if a[a[i][0]][0]==i:\n            chk_next.add(i)\n    if len(chk_next)==0:\n        ans=-1\n        break\n    tcnt-=len(chk_next)\n    chk=set()\n    for i in chk_next:\n        a[i].popleft()\n        chk.add(i)\n        if a[i][0]!=-1:\n            chk.add(a[i][0])\n    ans+=1\n\nprint(ans)", "from collections import deque\n\nN = int(input())\nL = [deque([int(i)-1 for i in input().split()]) for i in range(N)]\n\nq = deque(list(range(N)))\nd = [0 for i in range(N)]\npairs = [-1 for i in range(N)]\nwhile q:\n    a = q.popleft()  # q\u306e\u5de6\u7aef\u306e\u9078\u624b\u306eindex\u3092popleft\n    if len(L[a]) == 0:\n        continue\n    b = L[a].popleft()\n\n    if pairs[b] == a:  # b\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304ca\u306a\u3089\n        d[a] = d[b] = max(d[a], d[b]) + 1\n        q.append(a)\n        q.append(b)\n    else:\n        pairs[a] = b\nprint((max(d) if not any(L) else -1))\n", "from collections import deque\nfrom typing import List, Optional, Tuple\n\n\ndef cycle_detectable_topological_sort(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> Tuple[Optional[List[int]], Optional[List[int]]]:\n    \"\"\"Topological sort that uses Kahn's algorithm and detects a loop (DAG or not).\n    Returns:\n        if the given graph is DAG, a list of sorted vertices and a list of depths of\n        each vertex is returned.\n        Otherwise, (None, None) is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    order = []\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            order.append(i)\n            depths[i] = 0\n\n    queue = deque(order)\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = max(depths[v], cur_depth + 1)\n                queue.append(v), order.append(v)\n    return (order, depths) if len(order) + first_index == V else (None, None)\n\n\ndef abc139_e():\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    _, depths = cycle_detectable_topological_sort(graph, in_degrees)\n    print((max(depths) + 1 if depths is not None else -1))\n\n\ndef __starting_point():\n    abc139_e()\n\n__starting_point()", "import sys\nimport collections\nimport copy\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [collections.deque([int(x) for x in input().split()]) for _ in range(N)]\n\n    day = 0\n    c = 0\n    nxt = [x for x in range(N)]\n    oppo = [0] * N\n\n    while c != N * (N - 1):\n        day += 1\n\n        for i in nxt:\n            oppo[i] = A[i].popleft() if A[i] else -1\n\n        tmp = set()\n        for i in nxt:\n            if i == -1 or i in tmp:\n                continue\n            if i == oppo[oppo[i] - 1] - 1:\n                tmp.add(i)\n                tmp.add(oppo[i] - 1)\n                c += 2\n        if not tmp:\n            print((-1))\n            return\n\n        nxt = tmp\n\n    print(day)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nfrom typing import List, Optional, Tuple\n\n\ndef cycle_detectable_topological_sort(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> Tuple[Optional[List[int]], Optional[List[int]]]:\n    \"\"\"Topological sort that uses Kahn's algorithm and detects a loop (DAG or not).\n    Returns:\n        if the given graph is DAG, a list of sorted vertices and a list of depths of\n        each vertex is returned.\n        Otherwise, (None, None) is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    depths = [0] * V  # depths[i] := the length of the longest path to V_i\n    order = [i for i in range(first_index, V) if not in_degrees[i]]\n    queue = deque(order)\n\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = cur_depth + 1\n                queue.append(v), order.append(v)\n\n    return (order, depths) if len(order) + first_index == V else (None, None)\n\n\ndef abc139_e():\n    # https://atcoder.jp/contests/abc139/tasks/abc139_e\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    _, depths = cycle_detectable_topological_sort(graph, in_degrees)\n    print((max(depths) + 1 if depths else -1))\n\n\ndef grl_4_a():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/4/GRL_4_A\n    V, _, *ST = list(map(int, open(0).read().split()))\n    graph = [[] for _ in range(V)]\n    in_degrees = [0] * V\n    for s, t in zip(*[iter(ST)] * 2):\n        graph[s].append(t)\n        in_degrees[t] += 1\n\n    res, _ = cycle_detectable_topological_sort(graph, in_degrees)\n    print((1 if res is None else 0))\n\n\ndef __starting_point():\n    abc139_e()\n    # grl_4_a()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list([int(x)-1 for x in input().split()])\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\nimport time\n\n#A\ndef A():\n    s = S()\n    t = S()\n    ans = 0\n    for i in range(3):\n        if s[i] == t[i]:\n            ans += 1\n    print(ans)\n    return\n\n#B\ndef B():\n    a, b = LI()\n    ans = 0\n    b -= 1\n    while b > 0:\n        b -= a - 1\n        ans += 1\n    print(ans)\n\n    return\n\n#C\ndef C():\n    n = II()\n    h = LI()\n    i = 0\n    ans = 0\n    while i < n:\n        down = i+1\n        while down < n:\n            if h[down - 1] >= h[down]:\n                down += 1\n            else:\n                break\n        ans = max(ans, down - i - 1)\n        i = down\n    print(ans)\n    return\n\n#D\ndef D():\n    n = II()\n    print((n * (n - 1) // 2))\n    return\n\n#E\ndef E():\n    start = time.time()\n    n = II()\n    a = LIR_(n)\n    ans = 0\n    tern = [0] * n\n    while 1:\n        ans += 1\n        f = True\n        c = defaultdict(int)\n        for i in range(n):\n            if c[i]:\n                continue\n            if tern[i] == n - 1:\n                continue\n            rival = a[i][tern[i]]\n            if c[rival]:\n                continue\n            if tern[rival] == n - 1:\n                continue\n            if a[rival][tern[rival]] == i:\n                c[i] += 1\n                c[rival] += 1\n                tern[rival] += 1\n                tern[i] += 1\n                f = False\n        if time.time() - start >= 1.8:\n            print((n * (n - 1) // 2))\n            return\n        if f:\n            if tern == [n - 1] * n:\n                print((ans-1))\n                return\n            else:\n                print((-1))\n                return\n    return\n\n#F\ndef F():\n    return\n\n#Solve\ndef __starting_point():\n    E()\n\n__starting_point()", "from collections import deque\na = int(input())\nl = [] \nfor i in range(a):\n    tl = list(map(int,input().split()))\n    tl = list(map(lambda x:x-1 ,tl))\n    l.append(tl)\n\nq = deque((range(a)))\ndays=[0]*a\npairs=[-1]*a\nwhile q:\n    x = q.popleft()\n    if len(l[x]) == 0:continue\n    y = l[x].pop(0)\n    if pairs[y] == x:\n        days[x]=days[y]=max(days[x],days[y])+1\n        q.append(x)\n        q.append(y)\n    else:\n        pairs[x]=y\nif not any(l):\n    print(max(days))\nelse:\n    print(-1)", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [deque([int(x)-1 for x in input().split()]) for _ in range(N)]\n    ans = 0\n    used_prev = set(range(N))\n    while any(A):\n        used = set()\n        for i in used_prev:\n            a = A[i]\n            if not a or i in used:\n                continue\n            j = a[0]\n            b = A[j]\n            if not b or j in used:\n                continue\n            if i == b[0]:\n                A[i].popleft()\n                A[j].popleft()\n                used.add(i)\n                used.add(j)\n        if not used:\n            ans = -1\n            break\n        used_prev = used\n        ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    a = [list([int(x)-1 for x in input().split()]) for _ in range(n)]\n    for i in range(n):\n        a[i].reverse()\n    # print(a)\n    s = set()\n\n    def check(i, s):\n        if len(a[i]) == 0:\n            return\n        j = a[i][-1]\n        if len(a[j]) == 0:\n            return\n        if a[j][-1] == i:\n            if i < j:\n                s.add((i, j))\n            else:\n                s.add((j, i))\n    \n    for i in range(n):\n        check(i, s)\n    day = 0\n    while s:\n        day += 1\n        prevS = set()\n        s, prevS = prevS, s\n        for p in prevS:\n            i = p[0]\n            j = p[1]\n            a[i].pop()\n            a[j].pop()\n        for p in prevS:\n            i = p[0]\n            j = p[1]\n            check(i, s)\n            check(j, s)\n    \n    for i in range(n):\n        if len(a[i]):\n            print((-1))\n            return\n    print(day)\n    return\n\nmain()\n", "import sys\nfrom itertools import islice\nfrom collections import deque\nread = map(int, sys.stdin.read().split())\n\nN = next(read)\nA = [deque()] + [deque(islice(read, N - 1)) for _ in range(N)]\ndays = 1\navailable_players = deque(range(1, N + 1))\nnext_opponent = [0] * (N + 1)\nplayed = set()\n\nwhile available_players:\n    player = available_players.popleft()\n    if not A[player]:\n        continue\n\n    opponent = A[player].popleft()\n    if next_opponent[opponent] == player:\n        available_players.append(player)\n        available_players.append(opponent)\n        next_opponent[player] = 0\n        next_opponent[opponent] = 0\n        if player in played:\n            days += 1\n            played.clear()\n        played.add(player)\n        played.add(opponent)\n    else:\n        next_opponent[player] = opponent\n\nif next_opponent.count(0) != N + 1:\n    print(-1)\nelse:\n    print(days)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n \nN = int(input())\n\nA = [None] * N\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\uff1a-1\u3067\u5148\u982d\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u524d\u5f8c\u53cd\u8ee2\n# \u6700\u521d\u306e\u9078\u624b\u3092\u6307\u3059\u5834\u5408\uff10\u306b\u306a\u308b\u3088\u3046\u306b-1\u3057\u305f\u5024\u3092\u4fdd\u6301\n# \u5168\u7d44\u307f\u5408\u308f\u305b\u3092\u8a66\u5408\u3057\u7d42\u308f\u3063\u305f\u6642\u306f\u2212\uff11\u306b\u306a\u308b\u3088\u3046\u306b\u3059\u308b\nfor i in range(N):\n    A[i] = [-1] + [int(x) - 1 for x in input().split()[::-1]]\n\n\ndef f(candi):\n    \n    played = []\n    \n    # \u6b21\u306b\u8a66\u5408\u3059\u308b\u53ef\u80fd\u6027\u306e\u3042\u308b\u9078\u624b\u3092\u9806\u6b21\u30c1\u30a7\u30c3\u30af\n    for n in candi:\n        target = A[n][-1]\n        if A[target][-1] == n:\n            played.append(n)\n        \n    new_candi = set()    \n    for n in played:\n        # \u8a66\u5408\u305a\u307f\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u524a\u9664\n        A[n].pop()\n        # \u8a66\u5408\u3059\u308b\u4eba\u306e\u5019\u88dc\u306b\u8ffd\u52a0\n        new_candi.add(n)\n        # \u6b21\u306e\u5bfe\u6226\u76f8\u624b\u3092\u8a66\u5408\u306e\u5019\u88dc\u306b\u8ffd\u52a0\n        if A[n][-1] != -1:\n            new_candi.add(A[n][-1])\n            \n    return len(played), new_candi\n\n\nanswer = 0\n# \u6700\u60aa\u306e\u8a66\u5408\u6570\uff08\u4e8c\u500d\u3055\u308c\u305f\u5024\uff09\nrest = N*(N-1)\n# \u8a66\u5408\u3059\u308b\u4eba\u306e\u5019\u88dc\nplay_candi = set(range(N))\n\nwhile True:\n    answer += 1\n    x, play_candi = f(play_candi)\n    # \u884c\u308f\u308c\u305f\u8a66\u5408\u6570\u3092\u78ba\u8a8d\n    if x == 0:\n        answer = -1\n        break\n        \n    rest -= x\n    if rest ==0:\n        break\n        \nprint(answer)\n", "#!/usr/bin/env python3\nimport sys\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    for i in range(N):\n        A[i] = A[i][::-1]\n    \n    answer = 0\n    totalGame = 0\n    MAXGAME = (N*(N-1))//2\n    match = set()\n\n    while True:\n        if totalGame == 0:\n            for i in range(N):\n                if not A[i]:\n                    continue\n                match_index = A[i][-1]-1\n\n                if not A[match_index]:\n                    continue\n\n                if match_index in match or i in match:\n                    continue\n\n                if A[match_index][-1]-1 == i:\n                    A[i].pop()\n                    A[match_index].pop()\n                    match.add(i)\n                    match.add(match_index)\n                    totalGame += 1\n        else:\n            if totalGame == MAXGAME:\n                break\n\n            check_needed = list(match)\n            # \u65e2\u306b\u3053\u306e\u30bf\u30fc\u30f3\u3067\u30de\u30c3\u30c1\u3057\u305f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4fdd\u6301\n            match = set()\n\n            for i in check_needed:\n                if not A[i]:\n                    continue\n                match_index = A[i][-1]-1\n\n                if not A[match_index]:\n                    continue\n\n                if match_index in match or i in match:\n                    continue\n\n                if A[match_index][-1]-1 == i:\n                    A[i].pop()\n                    A[match_index].pop()\n                    match.add(i)\n                    match.add(match_index)\n                    totalGame += 1\n\n        if len(match) == 0:\n            print((-1))\n            return\n\n        answer += 1\n\n    print(answer)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N - 1)] for _ in range(N)]  # type: \"List[List[int]]\"\n    solve(N, A)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef main():\n  N=int(input())\n  A=[deque(int(a)-1 for a in input().split()) for _ in range(N)]\n\n  P,W=[0]*N,[-1]*N\n  c=deque(list(range(N)))\n\n  while c:\n    i=c.popleft()\n    j=A[i].popleft()\n    W[i]=j\n\n    if W[j]==i:\n      P[i]=P[j]=max(P[i],P[j])+1\n      if A[i]:\n        c.append(i)\n      if A[j]:\n        c.append(j)\n\n  print((-1 if any(len(a) for a in A) else max(P)))\n\nmain()\n", "import sys\nfrom itertools import islice\nfrom collections import deque\nread = map(int, sys.stdin.read().split())\n\nN = next(read)\nA = [deque()] + [deque(islice(read, N - 1)) for _ in range(N)]\ndays = 1\navailable_players = deque(range(1, N + 1))\nnext_opponent = [0] * (N + 1)\nplayed = set()\n\nwhile available_players:\n    player = available_players.popleft()\n    if not A[player]:\n        continue\n\n    opponent = A[player].popleft()\n    if next_opponent[opponent] == player:\n        available_players.append(player)\n        available_players.append(opponent)\n        next_opponent[player] = 0\n        next_opponent[opponent] = 0\n        if player in played:\n            days += 1\n            played.clear()\n        played.add(player)\n        played.add(opponent)\n    else:\n        next_opponent[player] = opponent\n\nfor i in A:\n    if len(i) > 0:\n        print(-1)\n        return\nelse:\n    print(days)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nA = [list([int(n)-1 for n in input().split()]) for i in range(N)]\ncur = [0 for i in range(N)]\nque = [i for i in range(N)]\nans = 0\nwhile len(que) > 0:\n    done = set()\n    que2 = []\n    for n in que:\n        if n in done: continue\n        pair = A[n][cur[n]]\n        if pair in done: continue\n        if n == A[pair][cur[pair]]:\n            cur[n] += 1\n            cur[pair] += 1\n            done.add(n)\n            done.add(pair)\n            if cur[n] < N-1: que2.append(n)\n            if cur[pair] < N-1: que2.append(pair)\n    if len(done) > 0: ans += 1\n    que = que2\nok = True\nfor i in range(N):\n    if cur[i] < N-1: ok = False\nif ok: print(ans)\nelse: print((-1))\n", "from collections import deque\n\nn = int(input())\na = [list([int(x)-1 for x in input().split()]) + [-1] for _ in range(n)]\n\nl,day = [0]*n,[0]*n\n\nque = deque([i for i in range(n)])\n\nwhile que:\n    u = que.popleft()\n    v = a[u][l[u]]\n    if a[v][l[v]] == u:\n        day[u] = max(day[u],day[v]) + 1\n        day[v] = day[u]\n        l[u] += 1\n        l[v] += 1\n        que.append(u)\n        que.append(v)\n\nif any(x != n-1 for x in l):\n    print((-1))\n    return\n\nprint((max(day)))\n", "import sys\nfrom itertools import islice\nfrom collections import deque\nread = map(int, sys.stdin.read().split())\n\nN = next(read)\nA = [deque()] + [deque(islice(read, N - 1)) for _ in range(N)]\ndays = 1\navailable_players = deque(range(1, N + 1))\nnext_opponent = [0] * (N + 1)\nplayed = set()\n\nwhile available_players:\n    player = available_players.popleft()\n    if not A[player]:\n        continue\n\n    opponent = A[player].popleft()\n    if next_opponent[opponent] == player:\n        available_players.append(player)\n        available_players.append(opponent)\n        next_opponent[player] = 0\n        next_opponent[opponent] = 0\n        if player in played:\n            days += 1\n            played.clear()\n        played.add(player)\n        played.add(opponent)\n    else:\n        next_opponent[player] = opponent\n\nif max(next_opponent) > 0:\n    print(-1)\nelse:\n    print(days)", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = [None] * N\nfor i in range(N):\n  # \u5f8c\u308d\u304b\u3089pop\u3067\u304d\u308b\u3088\u3046\u306b\u9006\u9806\u30ea\u30b9\u30c8\u3067\u6301\u3064\n  A[i] = list(map(lambda x:x - 1,map(int,readline().split())))[::-1]\n  \n# \u4eca\u65e5\u8a66\u5408\u304c\u3067\u304d\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u4eba\u30ea\u30b9\u30c8\ncandi = set(range(N))\n\nday = 0\nwhile candi:\n  day += 1\n  nex = set()\n  done = set()\n  for player in candi:\n    if player in done:\n      continue\n    # player \u304c\u8a66\u5408\u3067\u304d\u308b\u304b\u30c1\u30a7\u30c3\u30af\n    if len(A[player]) == 0:\n      continue\n    rival = A[player][-1]\n    if rival in done:\n      continue\n    if A[rival][-1] == player:\n      # \u8a66\u5408\u3067\u304d\u308b\n      A[player].pop()\n      A[rival].pop()\n      if A[player]:\n        nex.add(player)\n      done.add(player)\n      if A[rival]:\n        nex.add(rival)\n      done.add(rival)\n  if len(done) == 0:\n    # \u4e00\u8a66\u5408\u3082\u3067\u304d\u306a\u304b\u3063\u305f\n    print(-1)\n    return\n  candi = nex\n  \nprint(day)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = [deque(list(map(int, input().split()))) for _ in range(n)]\n\n    que = deque()\n    for i in range(n):\n        que.append(i)\n\n    res = 0\n    while True:\n        tmp = deque()\n        used = set()\n        while que:\n            idx = que.popleft()\n            if A[idx]:\n                a = A[idx][0] - 1\n                if idx in used or a in used:\n                    continue\n                if A[a][0] - 1 == idx:\n                    A[idx].popleft()\n                    A[a].popleft()\n                    used.add(idx)\n                    used.add(a)\n                    tmp.append(idx)\n                    tmp.append(a)\n        if tmp:\n            res += 1\n            que = tmp\n        else:\n            break\n\n    for a in A:\n        if a:\n            print((-1))\n            break\n    else:\n        print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN = int(input())\nA = [[x-1 for x in list(map(int, input().split()))] for _ in range(N)]\n\ndef can_match(i, A, next_set):\n  if not A[i]:\n    return\n  j = A[i][0]\n  if A[j][0] == i:\n    if i < j:\n      next_set.add((i,j))\n    else:\n      next_set.add((j,i))\n      \nnext_set = set()\nfor i in range(N):\n  can_match(i, A, next_set)\n  \nday = 0\nbattle = 0\nwhile next_set:\n  day += 1\n  current_set, next_set = next_set, set()\n  for match in current_set:\n    battle += 1\n    del A[match[0]][0]\n    can_match(match[0], A, next_set)\n    del A[match[1]][0]\n    can_match(match[1], A, next_set)\n    \nif battle == N*(N-1)//2:\n  print(day)\nelse:\n  print((-1))\n", "N = int(input())\nA = [None] * N\n\nfor i in range(N):\n  A[i] = list(map(lambda x:int(x) - 1,input().split()))[::-1]\n  \n# A[i]\u306e\u6700\u5f8c\u5c3e\u304c\u3001\u6b21\u306b\u5bfe\u6226\u3059\u308b\u76f8\u624b\n\n# \u6b21\u306b\u8a66\u5408\u3059\u308b\u5019\u88dc\u306e\u4eba\u3092\u5168\u54e1\u6d17\u3044\u51fa\u3059\u3002\u6700\u521d\u306f\u5168\u54e1\nplayable = set(range(N))\n\nday = 0\nwhile True:\n  next_playable = set() # \u6b21\u306e\u65e5\u306b\u8a66\u5408\u3067\u304d\u308b\u72b6\u614b\u306b\u306a\u308b\u4eba\n  done = set() # \u305d\u306e\u65e5\u306b\u65e2\u306b\u8a66\u5408\u3092\u7d42\u3048\u305f\u4eba\u3092\u7ba1\u7406\n  for player in playable:\n    if player in done:\n      continue\n    if len(A[player]) == 0:\n      continue\n    rival = A[player][-1]\n    if rival in done:\n      continue\n    if len(A[rival]) == 0:\n      continue\n    if A[rival][-1] == player:\n      done.add(player)\n      done.add(rival)\n      A[player].pop()\n      A[rival].pop()\n      # \u3053\u306e\u4e8c\u4eba\u306f\u6b21\u306e\u8a66\u5408\u306e\u63a2\u7d22\u5bfe\u8c61\u3068\u306a\u308b\n      next_playable.add(player)\n      next_playable.add(rival)\n  if len(next_playable) == 0:\n    break\n  playable = next_playable\n  day += 1\n\n# \u3067\u304d\u308b\u8a66\u5408\u304c\u306a\u304f\u306a\u3063\u305f\u72b6\u614b\u3067\u3001\u5168\u54e1\u306e\u8a66\u5408\u304c\u7d42\u308f\u3063\u3066\u3044\u308c\u3070OK\nok = True\nfor i in range(len(A)):\n  if len(A[i]) != 0:\n    ok = False\n    break\n    \nprint((-1,day)[ok])", "N=int(input())\na=[[0 for j in range(N-1)] for i in range(N)]\nfor i in range(N):\n  line=list(map(int,input().split()))\n  for j in range(N-1):\n    a[i][j]=line[j]-1\n  a[i]=a[i][::-1]\n    \nstack=[]\n\ndef addmatch(i):\n  if len(a[i])==0:\n    return\n  j=a[i][-1]\n  if a[j][-1]==i:\n    stack.append([i,j])\n\nfor i in range(N):\n  addmatch(i)\n\nday=0\nwhile stack:\n  day+=1\n  member=set()\n  for i in range(len(stack)):\n    g=stack.pop()\n    y=g[0]\n    x=g[1]\n    if len(a[y])>0 and a[y][-1]==x:\n      a[y].pop()\n      a[x].pop()\n      member.add(y)\n      member.add(x)\n  for m in member:\n    addmatch(m)\n\nfor i in range(len(a)):\n  if len(a[i])>0:\n    print(-1)\n    break\nelse:\n  print(day)", "import sys\n\nN=int(input())\namat=[[-1]]\nfor i in range(N):\n  alist=list(map(int,input().split()))\n  amat.append(list(reversed(alist)))\n  \n#print(amat)\ncleared_num=0\nnew_search_index=set(range(1,N+1))\nfor answer in range(1,N**3):\n  matched_set=set()\n  unchanged=True\n\n  search_index=new_search_index;\n  new_search_index=set()\n  for i in search_index:\n    if i in matched_set:\n      continue\n      \n    ai_next = amat[i][-1]\n    if amat[ai_next][-1]==i and not ai_next in matched_set:\n      #print(i,ai_next,answer)\n      matched_set.add(amat[i].pop())\n      matched_set.add(amat[ai_next].pop())\n      if len(amat[i])==0:\n        cleared_num+=1\n      else:\n        new_search_index.add(i)  \n      if len(amat[ai_next])==0:\n        cleared_num+=1\n      else:\n        new_search_index.add(ai_next)\n      unchanged=False\n      \n  if unchanged:\n    print(-1)\n    return\n  elif cleared_num==N:\n    print(answer)\n    return", "from collections import deque\n\nn = int(input())\nl = [[int(i)-1 for i in input().split()] for i in range(n)]\n# \u9078\u624b\u306e\u756a\u53f7\u3092index\u3068\u4e00\u81f4\u3055\u305b\u308b\n\nq = deque(list(range(n)))\ndays = [0 for i in range(n)]\npairs = [-1 for i in range(n)]\nwhile q:\n    a = q.popleft() #q\u306e\u5de6\u7aef\u306e\u9078\u624b\u306eindex\u3092popleft\n    if len(l[a]) == 0: #a\u756a\u306e\u9078\u624b\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u306a\u3044\n        continue #skip\n    b = l[a].pop(0)\n    #l[a]:a\u756a\u306e\u9078\u624b\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u30ea\u30b9\u30c8\n    #l[a]\u306e\u6700\u521d\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3092pop\n\n    #a:\u3042\u308b\u9078\u624b\u306eindex\n    #b:a\u756a\u306e\u9078\u624b\u304c\u6700\u521d\u306b\u30ea\u30af\u30a8\u30b9\u30c8\u3057\u305f\u9078\u624b\u306eindex\n    if pairs[b] == a: # b\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304ca\u306a\u3089\n        days[a] = days[b] = max(days[a],days[b]) +1\n        q.append(a)\n        q.append(b)\n    else:\n        pairs[a] = b #\nprint((max(days) if not any(l) else -1))\n\n", "from collections import deque\n\nn = int(input())\nmatches = []\nfor _ in range(n):\n    matches.append(list([int(x)-1 for x in input().split()]))\n\nq = deque(list(range(n)))\n\ndays = [0]*n  # \u5404\u9078\u624b\u306e\u73fe\u5728\u306e\u65e5\u4ed8\n\nwhile q:\n    x = q.popleft()  # \u8a66\u5408\u3059\u308b\u4eba\n    if len(matches[x]) == 0:  # \u8a66\u5408\u304c\u5168\u3066\u7d42\u308f\u3063\u3066\u308b?\n        continue\n    y = matches[x][0]  # x\u306e\u6b21\u306e\u5bfe\u6226\u76f8\u624b\n    if matches[y][0] == x:\n        day = max(days[x], days[y])+1\n        days[x] = day\n        days[y] = day\n        q.append(x)\n        q.append(y)\n        _ = matches[x].pop(0)\n        _ = matches[y].pop(0)\n\nif not any(matches):  # \u5168\u3066\u306e\u8a66\u5408\u3092\u3057\u3087\u3046\u304b\n    print((max(days)))\nelse:\n    print((-1))\n", "import itertools\n#0-indexed\nN = int(input())\nA = [[int(_) - 1 for _ in input().split()][::-1] for _ in range(N)]\nans = 0\ncand = list(range(N))\nleft = 1\nwhile True:\n    cand_ = set()\n    for i in cand:\n        v = A[i]\n        if not len(v):\n            continue\n        if A[v[-1]][-1] == i:\n            f = 0\n            cand_.add(i)\n            cand_.add(v[-1])\n    if not cand_:\n        break\n    cand = cand_\n    left = 0\n    for i in cand:\n        A[i].pop()\n        left |= len(A[i]) > 0\n    ans += 1\nif left:\n    print((-1))\nelse:\n    print(ans)\n", "import sys\nfrom itertools import islice\nfrom collections import deque\nread = map(int, sys.stdin.read().split())\n\nN = next(read)\nA = [deque()] + [deque(islice(read, N - 1)) for _ in range(N)]\ndays = 1\navailable_players = deque(range(1, N + 1))\nnext_opponent = [0] * (N + 1)\nplayed = set()\n\nwhile available_players:\n    player = available_players.popleft()\n    if not A[player]:\n        continue\n\n    opponent = A[player].popleft()\n    if next_opponent[opponent] == player:\n        available_players.append(player)\n        available_players.append(opponent)\n        next_opponent[player] = 0\n        next_opponent[opponent] = 0\n        if player in played:\n            days += 1\n            played = set()\n        played.add(player)\n        played.add(opponent)\n    else:\n        next_opponent[player] = opponent\n\nfor i in A:\n    if len(i) > 0:\n        print(-1)\n        return\nelse:\n    print(days)", "from collections import deque\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n\n    que = deque()\n    lastdone = []\n    next = []\n    for i in range(n):\n        que.append((i, 1))\n        lastdone.append(-1)\n        next.append(0)\n    while len(que) > 0:\n        now, day = que.popleft()\n        if lastdone[now] == day:\n            continue\n        if next[now] == n-1:\n            continue\n        candidate = a[now][next[now]]-1\n        if lastdone[candidate] == day:\n            continue\n        if next[candidate] == n-1:\n            continue\n        if a[candidate][next[candidate]]-1 == now:\n            next[now] += 1\n            next[candidate] += 1\n            lastdone[now] = day\n            lastdone[candidate] = day\n            que.append((now, day+1))\n            que.append((candidate, day+1))\n\n    for i in range(n):\n        if next[i] != n-1:\n            print((-1))\n            return\n\n    print((max(lastdone)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [list(map(int,input().split())) for i in range(n)]\nleague = [0]*(n+1)\ncnt = 0\n\nwhile True:\n  topop = []\n  if cnt == 0:\n    for i,player in enumerate(a):\n      x = player[-1]\n      if league[x] == i+1:\n        topop.append(x)\n        topop.append(i+1)\n      else:\n        league[i+1] = x\n  else:\n    for player in popped:\n      if a[player-1] == []:\n        continue\n      x = a[player-1][-1]\n      if league[x] == player:\n        topop.append(x)\n        topop.append(player)\n      else:\n        league[player] = x\n  popped = []\n  if topop == []:\n    print((-1))\n    return\n  for t in topop:\n    if a[t-1] == []:\n      print((-1))\n      return\n    a[t-1].pop()\n    popped.append(t)\n  cnt += 1\n  if not any(a[i] for i in range(n)):\n    break\nprint(cnt)\n", "from collections import deque, defaultdict\n\nN = int(input())\nA = [deque([int(a) - 1 for a in input().split()]) for _ in range(N)]\n\nD = [0] * N\ncanBattle = defaultdict(lambda: False)\nque = deque(list(range(N)))\n\nwhile que:\n    i = que.popleft()\n    j = A[i].popleft()\n    canBattle[(i, j)] = True\n\n    if canBattle[(j, i)]:\n        day = max(D[i], D[j])\n        D[i] = D[j] = day + 1\n\n        if A[i]:\n            que.append(i)\n        if A[j]:\n            que.append(j)\n\nif all(len(a) == 0 for a in A):\n    print((max(D)))\nelse:\n    print((-1))\n", "from collections import deque, defaultdict\n\nN = int(input())\nA = [deque([int(a) - 1 for a in input().split()]) for _ in range(N)]\n\nD = [0] * N\nNx = [-1] * N\nque = deque(list(range(N)))\n\nwhile que:\n    i = que.popleft()\n    j = A[i].popleft()\n    Nx[i] = j\n\n    if Nx[j] == i:\n        day = max(D[i], D[j])\n        D[i] = D[j] = day + 1\n\n        if A[i]:\n            que.append(i)\n        if A[j]:\n            que.append(j)\n\nif all(len(a) == 0 for a in A):\n    print((max(D)))\nelse:\n    print((-1))\n", "import sys, collections\ninput = sys.stdin.readline\n\nn = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nnums = [0 for i in range(n)]\nday = 0\nmatch = 0\nflag = True\nqueue = collections.deque([])\ntemp = set()\nfor i in range(1, n + 1):\n    i2 = a[i - 1][0]\n    if a[i2 - 1][0] == i:\n        if i not in temp:\n            queue.append([i, i2])\n            temp.add(i)\n            temp.add(i2)\nif not queue:\n    flag = False\nwhile queue:\n    temp = []\n    while queue:\n        test = queue.popleft()\n        match += 1\n        num1, num2 = test[0], test[1]\n        nums[num1 - 1] += 1\n        nums[num2 - 1] += 1\n        temp.append(num1)\n        temp.append(num2)\n    flag2 = False\n    temp2 = set()\n    for i in temp:\n        if nums[i - 1] <= n - 2:\n            new_num = a[i - 1][nums[i - 1]]\n            if nums[new_num - 1] <= n - 2 and a[new_num - 1][nums[new_num - 1]] == i:\n                if i not in temp2:\n                    queue.append([i, new_num])\n                    flag2 = True\n                    temp2.add(i)\n                    temp2.add(new_num)\n    if flag2 == False and match < n * (n - 1) // 2:\n        flag = False\n        break\n    day += 1\n\nif flag == True:\n    print(day)\nelse:\n    print(-1)", "# \u9802\u70b9\u6570\u304cN(N-1)/2, \u8fba\u304cN(N-2)\u672c\u3067\u304d\u308b\nfrom collections import deque\n\nN = int(input())\nmatches = [[a-1 for a in map(int, input().split())] for line in range(N)]\nq = deque(range(N))\ndepth = [0]*N\nwaiting = [-1]*N\n\nwhile q:\n  a = q.popleft()\n  b = matches[a].pop()\n  if waiting[b] == a:\n    depth[a] = depth[b] = max(depth[a], depth[b]) + 1\n    if matches[a]:\n      q.append(a)\n    if matches[b]:\n      q.append(b)\n  else:\n    waiting[a] = b\n    \nif any(matches):\n  print(-1)\nelse:\n  print(max(depth))", "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list([int(x)-1 for x in input().split()])\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\nimport time\n\n#A\ndef A():\n    s = S()\n    t = S()\n    ans = 0\n    for i in range(3):\n        if s[i] == t[i]:\n            ans += 1\n    print(ans)\n    return\n\n#B\ndef B():\n    a, b = LI()\n    ans = 0\n    b -= 1\n    while b > 0:\n        b -= a - 1\n        ans += 1\n    print(ans)\n\n    return\n\n#C\ndef C():\n    n = II()\n    h = LI()\n    i = 0\n    ans = 0\n    while i < n:\n        down = i+1\n        while down < n:\n            if h[down - 1] >= h[down]:\n                down += 1\n            else:\n                break\n        ans = max(ans, down - i - 1)\n        i = down\n    print(ans)\n    return\n\n#D\ndef D():\n    n = II()\n    print((n * (n - 1) // 2))\n    return\n\n#E\ndef E():\n    start = time.time()\n    n = II()\n    a = LIR_(n)\n    ans = 0\n    tern = [0] * n\n    while 1:\n        ans += 1\n        f = True\n        c = defaultdict(int)\n        for i in range(n):\n            if c[i]:\n                continue\n            if tern[i] == n - 1:\n                continue\n            rival = a[i][tern[i]]\n            if c[rival]:\n                continue\n            if tern[rival] == n - 1:\n                continue\n            if a[rival][tern[rival]] == i:\n                c[i] += 1\n                c[rival] += 1\n                tern[rival] += 1\n                tern[i] += 1\n                f = False\n        if time.time() - start >= 1:\n            print((n * (n - 1) // 2))\n            return\n        if f:\n            if tern == [n - 1] * n:\n                print((ans-1))\n                return\n            else:\n                print((-1))\n                return\n    return\n\n#F\ndef F():\n    return\n\n#Solve\ndef __starting_point():\n    E()\n\n__starting_point()", "from collections import deque\nfrom typing import List\n\n\ndef get_longest_path_depth(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> int:\n    \"\"\"Return the depth of the longest path of DAG.\n    if the given graph is not DAG, -1 is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    queue = deque()\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            queue.append(i)\n            depths[i] = 0\n\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = max(depths[v], cur_depth + 1)\n                queue.append(v)\n\n    return max(depths[first_index:]) if min(depths[1:]) != -1 else -1\n\n\ndef abc139_e():\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    depth = get_longest_path_depth(graph, in_degrees)\n    print((depth + 1 if depth != -1 else -1))\n\n\ndef __starting_point():\n    abc139_e()\n\n__starting_point()", "def main():\n    n=int(input())\n    a=[list(map(int,input().split())) for _ in [0]*n]\n    m=(n*(n-1))//2\n    d=dict()\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            d[(i,j)]=cnt\n            cnt+=1\n    g=[[] for _ in [0]*m]\n    gr=[0]*m\n    for i in range(n):\n        temp=[]\n        for j in a[i]:\n            if i>=j:temp.append(d[(j-1,i)])\n            else:temp.append(d[(i,j-1)])\n        for j,k in enumerate(temp[1:]):\n            g[temp[j]].append(k)\n            gr[k]+=1\n    q=[i for i,j in enumerate(gr) if j==0]\n    cnt=0\n    while q:\n        cnt+=1\n        qq=[]\n        for i in q:\n            for j in g[i]:\n                gr[j]-=1\n                if gr[j]==0:\n                    qq.append(j)\n        q=qq\n    if sum(gr)==0:\n        print(cnt)\n    else:\n        print(-1)\nmain()", "from collections import deque\nfrom typing import List\n\n\ndef get_longest_path_depth(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> int:\n    \"\"\"Return the depth of the longest path of DAG.\n    if the given graph is not DAG, -1 is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    queue = deque()\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            queue.append(i)\n            depths[i] = 0\n\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = max(depths[v], cur_depth + 1)\n                queue.append(v)\n\n    return max(depths) if -1 not in depths else -1\n\n\ndef abc139_e():\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    depth = get_longest_path_depth(graph, in_degrees)\n    print((depth + 1 if depth != -1 else -1))\n\n\ndef __starting_point():\n    abc139_e()\n\n__starting_point()", "# \u6b21\u306b\u8a66\u5408\u3057\u305f\u3044\u76f8\u624b\u3092deque\u3067\u7ba1\u7406\n# \u304a\u4e92\u3044\u306e\u8a66\u5408\u3057\u305f\u3044\u76f8\u624b(deque\u306e\u5148\u982d)\u304c\u4e00\u81f4\u3059\u308c\u3070\u8a66\u5408\u3067\u304d\u308b\n# \u6b21\u306e\u65e5\u306e\u30c1\u30a7\u30c3\u30af\u5bfe\u8c61\u306f\u300c\u524d\u65e5\u306b\u8a66\u5408\u3057\u305f\u4eba\u300d\u3060\u3051\u3002\u3053\u308c\u3092\u30ad\u30e5\u30fc\u7ba1\u7406\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nALL = (N * (N - 1)) // 2 # \u8a66\u5408\u6570\n\nfrom collections import deque\nplayer = [None] * N\nfor i in range(N):\n  player[i] = deque(list(map(lambda x:int(x) - 1,readline().split())))\n  \n# \u660e\u65e5\u8a66\u5408\u3059\u308b\u5019\u88dc\u306e\u4eba\nq = set(range(N))\n\nday = 0\nwhile q:\n  day += 1\n  nextday = set()\n  checked = set()\n  for p in q:\n    if p in checked:\n      continue\n    if len(player[p]) == 0:\n      continue\n    op = player[p][0] # \u6b21\u306e\u5bfe\u6226\u76f8\u624b\n    if op in checked:\n      continue\n    if player[op][0] == p:\n      # \u8a66\u5408\u6210\u7acb\n      player[p].popleft()\n      player[op].popleft()\n      checked.add(op)\n      checked.add(p)\n      if player[p]:\n        nextday.add(p)\n      if player[op]:\n        nextday.add(op)\n  q = nextday \n\nfor p in player:\n  if len(p) > 0:\n    print(-1)\n    break\nelse:\n  print(day)", "N = int(input())\nA = [list([int(n)-1 for n in input().split()]) for i in range(N)]\ncur = [0 for i in range(N)]\nque = [i for i in range(N)]\nans = 0\nwhile len(que) > 0:\n    done = {}\n    que2 = []\n    for n in que:\n        if done.get(n):\n            continue\n        pair = A[n][cur[n]]\n        if done.get(pair):\n            continue\n        if n == A[pair][cur[pair]]:\n            cur[n] += 1\n            cur[pair] += 1\n            done[n] = True\n            done[pair] = True\n            if cur[n] < N-1:\n                que2.append(n)\n            if cur[pair] < N-1:\n                que2.append(pair)\n    if len(done) > 0:\n        ans += 1\n    que = que2\nok = True\nfor i in range(N):\n    if cur[i] < N-1:\n        ok = False\nif ok:\n    print(ans)\nelse:\n    print((-1))\n", "def solve():\n    N = int(input())\n    Ass = [tuple([int(x)-1 for x in input().split()]) for _ in range(N)]\n\n    day = 0\n    numMatch = 0\n    ps = set(range(N))\n    isReadys = [0] * N\n    iAs = [-1] * N\n    while True:\n        day += 1\n        p2s = set()\n        for p in ps:\n            iAs[p] += 1\n            if iAs[p] == N-1: continue\n            q = Ass[p][iAs[p]]\n            if isReadys[q] and Ass[q][iAs[q]] == p:\n                isReadys[q] = 0\n                p2s.add(p)\n                p2s.add(q)\n                numMatch += 1\n            else:\n                isReadys[p] = 1\n        if numMatch >= N*(N-1)//2:\n            print(day)\n            break\n        if not p2s:\n            print((-1))\n            break\n        ps = p2s\n\nsolve()\n", "import sys\nimport copy\nfrom collections import deque\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = [deque(lr()) for _ in range(N)]\n\nmatch = 0\ncandidate = []\nused = set()\nfor i in range(N):    \n    bool = False\n    if len(A[i]) == 0:\n        continue\n    op = A[i][0] - 1\n    if op in used or i in used:\n        continue\n    if A[op][0]-1 == i:\n        used.add(i)\n        used.add(op)\n        candidate.extend([i, op])\n        match += 1\n        bool = True\n        A[i].popleft()\n        A[op].popleft()\nanswer = 1\n\nwhile True:\n    used = set()\n    bool = False\n    c = []\n    for i in candidate:\n        if len(A[i]) == 0:\n            continue\n        op = A[i][0] - 1\n        if op in used or i in used:\n            continue\n        if A[op][0]-1 == i:\n            used.add(i)\n            used.add(op)\n            match += 1\n            c.extend([i, op])\n            bool = True\n            A[i].popleft()\n            A[op].popleft()\n    \n    answer += 1\n    candidate = c\n    if match == N * (N-1) // 2:\n        break\n    if not bool:\n        print((-1))\n        return\n\nprint(answer)\n", "from collections import deque\nn = int(input())\na = [list(map(int, input().split())) + [0] for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a[i][j] -= 1\nl = [0] * n\nd = [0] * n\nQ = deque(range(n))\nwhile Q:\n    p = Q.popleft()\n    q = a[p][l[p]]\n    if a[q][l[q]] == p:\n        m = max(d[p], d[q]) + 1\n        d[p] = m\n        d[q] = m\n        l[p] += 1\n        l[q] += 1\n        Q.append(p)\n        Q.append(q)\nfor i in l:\n    if i != n - 1:\n        print(-1);return()\nprint(max(d))", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [list([int(n)-1 for n in input().split()]) for i in range(N)]\ncur = [0 for i in range(N)]\nque = [i for i in range(N)]\nans = 0\nwhile len(que) > 0:\n    done = {}\n    que2 = []\n    for n in que:\n        if done.get(n):\n            continue\n        pair = A[n][cur[n]]\n        if done.get(pair):\n            continue\n        if n == A[pair][cur[pair]]:\n            cur[n] += 1\n            cur[pair] += 1\n            done[n] = True\n            done[pair] = True\n            if cur[n] < N-1:\n                que2.append(n)\n            if cur[pair] < N-1:\n                que2.append(pair)\n    if len(done) > 0:\n        ans += 1\n    que = que2\nok = True\nfor i in range(N):\n    if cur[i] < N-1:\n        ok = False\nif ok:\n    print(ans)\nelse:\n    print((-1))\n", "import sys\nfrom collections import deque\ninput = lambda: sys.stdin.readline().rstrip()\n\n\ndef solve():\n    N = int(input())\n    A = [deque for _ in range(N)]\n    for i in range(N):\n        A[i] = deque(list([int(x) - 1 for x in input().split()]))\n\n    days = 0\n    ta = [i for i in range(N)]\n    while True:\n        ta2 = []\n        aset = set()\n        for i in ta:\n            if len(A[i]) == 0 or i in aset:\n                continue\n            if i == A[A[i][0]][0]:\n                ta2.append(i)\n                ta2.append(A[i][0])\n                aset |= set([i])\n                aset |= set([A[i][0]])\n        if len(ta2) > 0:\n            for t in ta2:\n                A[t].popleft()\n            days += 1\n            ta = ta2\n        else:\n            break\n\n    empty = True\n    for i in range(N):\n        if len(A[i]) != 0:\n            empty = False\n            break\n\n    if empty:\n        print(days)\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import deque\n\nn = int(input())\nm = n * (n - 1) // 2\nb = [[0, 0] for _ in range(m + 1)]\nf = [0] * (m + 1)\nq = deque()\nfor i in range(1, n + 1):\n    a = list(map(int, input().split()))\n    for j in range(n - 1):\n        ma, mi = max(i, a[j]), min(i, a[j])\n        x = (ma - 1) * (ma - 2) // 2 + mi\n        if j == 0:\n            f[x] += 1\n            if f[x] == 2:\n                q.append(x)\n        else:\n            if b[y][0] == 0:\n                b[y][0] = x\n            else:\n                b[y][1] = x\n        y = x\nans = 0\nwhile q:\n    ans += 1\n    l = len(q)\n    for _ in range(l):\n        i = q.popleft()\n        for j in range(2):\n            k = b[i][j]\n            f[k] += 1\n            if f[k] == 2 and not k == 0:\n                q.append(k)\nprint(ans if f[0] == n else -1)", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    \n    Id = {}\n    \n    cur = 0\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            Id[(i,j)] = cur\n            cur += 1\n            \n    G = [[] for i in range(N*(N-1)//2)]\n    size = [0] * (N*(N-1)//2)\n    \n    for i in range(1, N+1):\n        for idx, j in enumerate(list(map(int, input().split()))):\n            if i < j: k = Id[(i, j)]\n            else: k = Id[(j, i)]\n            if idx: \n                G[par].append(k)\n                size[k] += 1\n            par = k\n            \n    g = [idx for idx, s in enumerate(size) if s == 0]\n    \n    ans = 0\n    while g:\n        ans += 1\n        n_g = []\n        \n        for v in g:\n            length = len(G[v])\n            if not length: continue\n            \n            size[G[v][0]] -= 1\n            if not size[G[v][0]]: n_g.append(G[v][0])\n    \n            if length == 2:\n                size[G[v][1]] -= 1\n                if not size[G[v][1]]: n_g.append(G[v][1])\n        g = n_g\n        \n    for s in size:\n        if s != 0:\n            print(-1)\n            return\n    print(ans)\n            \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = []\nfor _ in range(N):\n    # \u9078\u624b\u756a\u53f7\u30920-index\u306b\u3059\u308b\n    line = list([int(x) - 1 for x in input().split()])\n    A.append(line)\n\n# cnt[i] = \u9078\u624bi\u304c\u73fe\u5728\u307e\u3067\u306b\u4f55\u8a66\u5408\u3057\u305f\u304b\ncnt = [0] * N\n# recent[i] = \u9078\u624bi\u304c\u6700\u5f8c\u306b\u8a66\u5408\u3092\u3057\u305f\u65e5\nrecent = [0] * N\n\n# Q\u306e\u521d\u671f\u5024 = [0, 1, ..., N-1]\nQ = deque(list(range(N)))\n\nwhile Q:\n    # \u3042\u308b\u9078\u624b(p1)\u306b\u3064\u3044\u3066\n    p1 = Q.popleft()\n    # p1\u304c\u307e\u3060\u5168\u8a66\u5408(N-1\u8a66\u5408)\u3092\u7d42\u3048\u3066\u3044\u306a\u3044\u5834\u5408\n    # p2 = p1\u304c\u6b21\u306b\u5f53\u305f\u308b\u3079\u304d\u9078\u624b\n    if cnt[p1] < N - 1:\n        p2 = A[p1][cnt[p1]]\n        # p2\u3082\u307e\u3060\u5168\u8a66\u5408\u3092\u7d42\u3048\u3066\u3044\u306a\u3044\u5834\u5408\n        if cnt[p2] < N - 1:\n            # p2\u304c\u6b21\u306b\u5f53\u305f\u308b\u3079\u304d\u9078\u624b\u304cp1\u306e\u5834\u5408 -> (p1,p2)\u306e\u8a66\u5408\u3092\u884c\u3046\u3053\u3068\u304c\u53ef\u80fd\n            if A[p2][cnt[p2]] == p1:\n                # day = (p1,p2)\u306e\u8a66\u5408\u3092\u884c\u3046\u65e5\n                day = max(recent[p1], recent[p2]) + 1\n                recent[p1] = day\n                recent[p2] = day\n                cnt[p1] += 1\n                cnt[p2] += 1\n                Q.append(p1)\n                Q.append(p2)\n\nif min(cnt) != N - 1:\n    print((-1))\nelse:\n    print((max(recent)))\n", "from collections import deque\nn = int(input())\na_list = []\nfor i in range(n):\n    a_list.append(deque([int(aa) - 1 for aa in input().split()]))\nday = 0\nbattle = 0\nfor _ in range(n * (n - 1) // 2):\n    if battle == n * (n - 1) // 2:\n        break\n    day += 1\n    battle_today = 0\n    tomorrow = set([])\n    if (day == 1):\n        player = set([i for i in range(n)])\n    for i in player:\n        if len(a_list[i]) == 0:\n            continue\n        j = a_list[i][0]\n        if (i == a_list[j][0]) & (j not in tomorrow) & (len(a_list[j]) > 0) & (i not in tomorrow):\n            tomorrow.add(i)\n            tomorrow.add(a_list[i][0])\n            battle += 1\n            battle_today += 1\n            a_list[i].popleft()\n            a_list[j].popleft()\n    player = tomorrow\n    if battle_today == 0:\n        day = -1\n        break\nprint(day)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    A = [[int(s) - 1 for s in reversed(readline().split())] for _ in range(N)]\n\n    M = N * (N - 1) // 2\n    games = 0\n    players = set(range(N))\n\n    for d in range(1, M + 1):\n        players, players_prev = set(), players\n        for i in players_prev:\n            if not A[i] or i in players:\n                continue\n            j = A[i][-1]\n            if j not in players and i == A[j][-1]:\n                players.add(i)\n                players.add(j)\n                A[i].pop()\n                A[j].pop()\n                games += 1\n\n        if games == M:\n            print(d)\n            break\n\n        if not players:\n            print((-1))\n            break\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\nans = 0\nr = set(list(range(n)))\nN = n*(n-1) // 2 + 1\nfor _ in range(N):\n    if not r:\n        print(_)\n        break\n    ne = set()\n    flag = True\n    for j in r:\n        if not a[j]:\n            continue\n        c = a[j][0]\n        if c == \"-\":\n            continue\n        if j + 1 == a[c-1][0]:\n            a[j][0] = \"-\"\n            a[c-1][0] = \"-\"\n            ne.add(j)\n            ne.add(c-1)\n    for j in list(ne):\n        if a[j]:\n            if a[j][0] == \"-\":\n                a[j].pop(0)\n                flag = False\n                if not a[j]:\n                    ne.remove(j)\n    if flag:\n        print((-1))\n        break\n    else:\n        r = ne\n", "from collections import* #defaultdict Counter deque appendleft\nimport sys\ninput=sys.stdin.readline\nimport time\nt=time.time()\n\ndef main():\n    n=int(input())\n    d=[[]]+[deque(list(map(int,input().split())))for i in n*[0]]\n\n    c=0\n    while any(d):\n        c+=1\n        f=0\n        skip=set()\n        for i in range(1,n+1):\n            if i not in skip:\n                if d[i]:\n                    if d[i][0] in skip:\n                        continue\n                    elif i==d[d[i][0]][0]:\n                        oppo=d[i].popleft()\n                        d[oppo].popleft()\n                        skip.add(oppo)\n                        skip.add(i)\n                        f=1\n\n        if not f:\n            print((-1))\n            return\n        if abs(time.time()-t)>1:\n            print((n*(n-1)//2))\n            return\n\n    print(c)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = [deque(lr()) for _ in range(N)]\ncandidate = list(range(N))\nmatch = 0\nday = 0\n\nwhile True:\n    day += 1\n    used = set()\n    next = set()\n    bool = False\n    for c in candidate:\n        if len(A[c]) == 0:\n            continue\n        op = A[c][0] - 1\n        if c in used or op in used:\n            continue\n        if A[op][0] - 1 == c:\n            bool = True\n            A[c].popleft()\n            A[op].popleft()\n            match += 1\n            next |= {c, op}\n            used |= {c, op}\n    if match == N * (N-1) // 2:\n        break\n    if not bool:\n        print((-1))\n        return\n    candidate = next\n\nprint(day)\n", "def opp(i):  #\u5bfe\u6226\u5e0c\u671b\u76f8\u624b\n    return a[i][nex[i]]\n\nfrom sys import stdin\n#\u5165\u529b\nreadline=stdin.readline\nn=int(readline())\nm=n*(n-1)//2\na=[list(map(lambda x:int(x)-1,readline().split())) for _ in range(n)]\n\nnex=[0]*n\nbefore=set(range(n))\nday=0\nfor day in range(1,m+1):\n    now=set()\n    while len(before)>0:\n        p=before.pop()\n        q=opp(p)\n        if opp(q)==p and p not in now and q not in now:\n            nex[p]+=1\n            nex[q]+=1\n            if nex[p]<n-1:\n                now.add(p)\n            if nex[q]<n-1:\n                now.add(q)\n            if q in before:\n                before.remove(q)\n    before=now\n    if len(before)==0:\n        break\n\nif min(nex)==n-1:\n    print(day)\nelse:\n    print(-1)", "import sys\nfrom collections import deque\ninput = lambda: sys.stdin.readline().rstrip()\n\n\ndef solve():\n    N = int(input())\n    A = [[] for _ in range(N)]\n    for i in range(N):\n        A[i] = list([int(x) - 1 for x in input().split()])\n\n    # print(A)\n\n    days = 0\n    ta = [i for i in range(N)]\n    while True:\n        ta2 = []\n        aset = set()\n        for i in ta:\n            if len(A[i]) == 0 or i in aset:\n                continue\n            if i == A[A[i][0]][0]:\n                ta2.append(i)\n                ta2.append(A[i][0])\n                aset |= set([i])\n                aset |= set([A[i][0]])\n        if len(ta2) > 0:\n            for t in ta2:\n                A[t].pop(0)\n            days += 1\n            ta = ta2\n        else:\n            break\n\n    empty = True\n    for i in range(N):\n        if len(A[i]) != 0:\n            empty = False\n            break\n\n    if empty:\n        print(days)\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nimport collections\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [[int(x) for x in input().split()] for _ in range(N)]\n\n    q = [collections.deque() for j in range(N)]\n\n    for i, a in enumerate(A):\n        for aa in a:\n            q[i].append(aa)\n\n    ans = 0\n\n    current = defaultdict(int)\n    for i, v in enumerate(q):\n        current[i + 1] = v[0]\n\n    while True:\n        v = set()\n        for k in list(current.keys()):\n            if k == q[current[k] - 1][0]:\n                v.add(k)\n                v.add(current[k])\n\n        current = defaultdict(int)\n\n        if len(v) == 0:\n            break\n\n        for vv in v:\n            q[vv - 1].popleft()\n            if len(q[vv - 1]):\n                current[vv] = q[vv - 1][0]\n\n        ans += 1\n\n    # \u5168\u3066\u7a7a\u306a\u3089\n    size = 0\n    for i in range(N):\n        size += len(q[i])\n\n    if size == 0:\n        print(ans)\n    else:\n        print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections\n\nn=int(input())\narr=[list(map(int,input().split())) for _ in range(n)]\narr=[0]+[collections.deque(arr[i]) for i in range(n)]\nans=0\ncand=set(range(1,n+1))\nwhile 1:\n  check=set()\n  for i in cand:\n    if not arr[i]:\n      continue\n    pair=arr[i][0]\n    if arr[pair][0]==i:\n      check.add(i)\n      check.add(pair)\n  if not check:\n    break\n  cand=set()\n  for i in check:\n    cand.add(i)\n    arr[i].popleft()\n    if arr[i]:\n      cand.add(arr[i][0])\n  ans+=1\nfor i in range(1,n+1):\n  if arr[i]:\n    print(-1)\n    break\nelse:\n  print(ans)", "from collections import deque\n\nN = int(input())\nA = [deque([ a-1 for a in map(int, input().split())]) for _ in range (N)]\ncnt = 0\ncur = [-1 for _ in range(N+1)]\nday = [0 for _ in range(N+1)]\nque = deque( range(N) )\n\nwhile que:\n    x = que.popleft()\n    if not A[x]:\n        continue\n    y = A[x].popleft()\n    if cur[y] == x:\n        cnt += 1\n        day[x] = day[y] = max(day[x], day[y]) + 1\n        cur[x] = cur[y] = -1\n        que.append(x), que.append(y)\n    else:\n        cur[x] = y\n\nflag = ( cnt == N*(N-1)/2 )\nprint( max(day) if flag else -1 )", "from collections import Counter,defaultdict,deque\nfrom bisect import bisect_left\nimport sys,math,itertools,pprint,fractions,time\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nst = time.time()\nn = inp()\na = []\nfor i in range(n):\n    b = inpl()\n    a.append(deque(b))\nzan = n*(n-1)//2\nres = 0\nwhile True:\n    res += 1\n    now = zan\n    s = set()\n    for i in range(n):\n        if i in s or a[i] == deque([]): continue\n        end = True\n        chk = a[i][0] - 1\n        if not chk in s and a[chk][0] == i+1:\n            zan -= 1\n            if not zan: \n                print(res); return\n            a[i].popleft(); a[chk].popleft()\n            s.add(i); s.add(chk)\n        # print(res,i,chk,a)\n        nnn = time.time()\n    if now == zan:\n        print((-1))\n        return\n    if nnn - st > 1.7:\n        print((n*(n-1)//2))\n        return\n\n            \n", "from collections import deque\nfrom typing import List, Optional, Tuple\n\n\ndef cycle_detectable_topological_sort(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> Tuple[Optional[List[int]], Optional[List[int]]]:\n    \"\"\"Topological sort that uses Kahn's algorithm and detects a loop (DAG or not).\n    Returns:\n        if the given graph is DAG, a list of sorted vertices and a list of depths of\n        each vertex is returned.\n        Otherwise, (None, None) is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    order = []\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            order.append(i)\n            depths[i] = 0\n\n    queue = deque(order)\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = cur_depth + 1\n                queue.append(v), order.append(v)\n    return (order, depths) if len(order) + first_index == V else (None, None)\n\n\ndef abc139_e():\n    # https://atcoder.jp/contests/abc139/tasks/abc139_e\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    _, depths = cycle_detectable_topological_sort(graph, in_degrees)\n    print((max(depths) + 1 if depths else -1))\n\n\ndef grl_4_a():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/4/GRL_4_A\n    V, _, *ST = list(map(int, open(0).read().split()))\n    graph = [[] for _ in range(V)]\n    in_degrees = [0] * V\n    for s, t in zip(*[iter(ST)] * 2):\n        graph[s].append(t)\n        in_degrees[t] += 1\n\n    res, _ = cycle_detectable_topological_sort(graph, in_degrees)\n    print((1 if res is None else 0))\n\n\ndef __starting_point():\n    abc139_e()\n    # grl_4_a()\n\n__starting_point()", "# O(N)\ndef is_not_empty(A):\n    for x in A:\n        if x:\n            return True\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    from collections import deque\n\n    N = int(input())\n    # 1-indexed\n    A = [deque() for _ in range(N+1)]\n    # O(N^2)\n    for i in range(1,N+1):\n        for j in input().split():\n            A[i].append(int(j))\n\n    # \u5f53\u65e5\u306e\u53c2\u52a0\u8005\n    today = set()\n    # \u521d\u65e5\n    for i in range(1,N+1):\n        # \u65e2\u306b\u53c2\u52a0\u3057\u305f\u4eba\u306f\u30c0\u30e1\n        if i in today:\n            continue\n        enemy = A[i].popleft()\n        ME = A[enemy].popleft()\n        if ME == i and not(enemy in today):\n            today.add(ME)\n            today.add(enemy)\n        else:\n            A[i].appendleft(enemy)\n            A[enemy].appendleft(ME)\n    # \u521d\u65e5\u306b\u8ab0\u3082\u8a66\u5408\u3067\u304d\u306a\u304b\u3063\u305f\u3068\u304d\n    if not today:\n        print(-1)\n        return\n\n    # \u524d\u65e5\u306e\u53c2\u52a0\u8005\n    yesterday = today\n    # \u65e5\u6570\n    answer = 1\n    while is_not_empty(A):\n        today = set()\n        # \u524d\u65e5\u306b\u8a66\u5408\u3057\u305f\u4eba\u306f\u5fc5\u305a\u6b21\u306e\u65e5\u306b\u8a66\u5408\u3059\u308b\n        for i in yesterday:\n            if not A[i]:\n                continue\n            if i in today:\n                continue\n            enemy = A[i].popleft()\n            ME = A[enemy].popleft()\n            if ME == i and not(enemy in today):\n                today.add(ME)\n                today.add(enemy)\n            else:\n                A[i].appendleft(enemy)\n                A[enemy].appendleft(ME)\n        if not today:\n            print(-1)\n            return\n        answer += 1\n        yesterday = today\n\n    print(answer)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\ndef main(): \n    N = int(input())\n    \n    Id = {}\n    \n    G = [[] for i in range(N*(N-1)//2)]\n    size = [0] * (N*(N-1)//2)\n    \n    cur = 0\n    for i in range(1, N+1):\n        for idx, j in enumerate(list(map(int, input().split()))):\n            if i < j: a, b = i, j\n            else: a, b = j, i\n        \n            if (a, b) not in Id:\n                Id[(a, b)] = cur\n                cur += 1\n            k = Id[(a, b)]\n        \n            if idx: \n                G[par].append(k)\n                size[k] += 1\n            par = k\n            \n    g = [idx for idx, s in enumerate(size) if s == 0]\n    \n    ans = 0\n    while g:\n        ans += 1\n        n_g = []\n        \n        for v in g:\n            length = len(G[v])\n            if not length: continue\n            \n            size[G[v][0]] -= 1\n            if not size[G[v][0]]: n_g.append(G[v][0])\n    \n            if length == 2:\n                size[G[v][1]] -= 1\n                if not size[G[v][1]]: n_g.append(G[v][1])\n        g = n_g\n        \n    for s in size:\n        if s != 0:\n            print((-1))\n            return\n    print(ans)           \n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "N=int(input())\na=[[0 for j in range(N-1)] for i in range(N)]\nfor i in range(N):\n  line=list(map(int,input().split()))\n  for j in range(N-1):\n    a[i][j]=line[j]-1\n  a[i]=a[i][::-1]\n    \nq=[]\n\n#seen=[[False for j in range(N)] for i in range(N)]\n\n# \u9078\u624bn\u304c\u8a66\u5408\u3067\u304d\u308b\u306a\u3089que\u306b\u5165\u308c\u308b\ndef check(i):\n  if len(a[i])==0:\n    return False\n  j=a[i][-1]\n  if a[j][-1]==i:\n    q.append([i,j])\n  \nfor i in range(N):\n  check(i)\n  \nfrom collections import defaultdict\n\nday=0\nwhile q:\n  day+=1\n # q=sorted(q)\n  prevQ=q.copy()\n  q=[]\n  matched=defaultdict(list)\n  for p in prevQ:\n    i=p[0]\n    j=p[1]\n    if i>j:\n      i,j=j,i\n    if matched[i]:\n      continue\n    a[i].pop()\n    a[j].pop()\n    check(i)\n    check(j)\n    matched[i].append(j)\n    \nfor i in range(N):\n  if len(a[i])!=0:\n    print((-1))\n    break\nelse:\n  print(day)\n"]
["H, W = list(map(int, input().split()))\nSs = [input() for _ in range(H)]\n\n# \u884c\u306e\u5165\u308c\u66ff\u3048\u30d1\u30bf\u30fc\u30f3\u3092\u751f\u6210\u3059\u308b\uff08\u4e2d\u592e\u4ed8\u8fd1\u304b\u3089\u57cb\u3081\u3066\u3044\u304f\uff09\ndef dfs(iR):\n    # \u5168\u3066\u57cb\u307e\u3063\u305f\u3089\u3001\u5224\u5b9a\u306b\u79fb\u308b\n    if iR < 0:\n        return check()\n\n    # \u672a\u4f7f\u7528\u306e\u884c\u3092\u691c\u7d22\u3059\u308b\n    iF = flgs.index(False)\n    Rs[iR] = iF - offset\n    flgs[iF] = True\n\n    # \u30da\u30a2\u306e\u76f8\u624b\u3092\u6c7a\u3081\u3066\u3001\u6b21\u306e\u30da\u30a2\u751f\u6210\u306b\u79fb\u308b\n    ans = False\n    for iF2, flg in enumerate(flgs):\n        if not flg:\n            Rs[H - 1 - iR] = iF2 - offset\n            flgs[iF2] = True\n            ans = ans or dfs(iR - 1)\n            flgs[iF2] = False\n\n    flgs[iF] = False\n\n    return ans\n\n\n# \u4e0e\u3048\u3089\u308c\u305f\u884c\u306e\u5165\u308c\u66ff\u3048\u30d1\u30bf\u30fc\u30f3\u306b\u5bfe\u3057\u3066\u3001\u5217\u306e\u5165\u308c\u66ff\u3048\u306e\u307f\u3067\u70b9\u5bfe\u79f0\u306b\u3067\u304d\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\ndef check():\n\n    Ts = [Ss[R] for R in Rs]\n    Ts = list(map(list, list(zip(*Ts))))\n\n    # (W+1)/2\u5217\u76ee\u3092\u4f7f\u7528\u53ef\u80fd\u304b\u3069\u3046\u304b\n    if W % 2: flgCenter = True\n    else: flgCenter = False\n\n    # \u5404\u5217\u306b\u5bfe\u3057\u3066\u3001\u51e6\u7406\u3092\u884c\u3046\n    Used = [False] * W\n    for j, T in enumerate(Ts):\n        if Used[j]: continue\n        for j2, T2 in enumerate(Ts[j + 1:], j + 1):\n            # \u4e0a\u4e0b\u53cd\u8ee2\u3057\u305f\u3088\u3046\u306a\u672a\u4f7f\u7528\u306e\u5217\u304c\u5b58\u5728\u3059\u308b\u306a\u3089\u3070\u3001\u6b21\u306e\u5217\u3078\n            if not Used[j2] and T[::-1] == T2:\n                Used[j2] = True\n                break\n        else:\n            # \u81ea\u8eab\u304c\u4e0a\u4e0b\u5bfe\u79f0\u3001\u304b\u3064\u3001(W+1)/2\u5217\u76ee\u3092\u4f7f\u7528\u53ef\u80fd\u306a\u3089\u3070\u3001\u6b21\u306e\u5217\u3078\n            if T[::-1] == T and flgCenter == True:\n                flgCenter = False\n            else:\n                # \u3053\u306e\u5165\u308c\u66ff\u3048\u30d1\u30bf\u30fc\u30f3\u3067\u306f\u4e0d\u53ef\u80fd\u3068\u5224\u5b9a\n                return False\n\n    return True\n\n\nif H % 2:\n    # H\u304c\u5947\u6570\u306a\u3089\u3070\u3001\u5148\u982d\u306b\u30c0\u30df\u30fc\u3092\u4ed8\u52a0\n    flgs = [False] * (H + 1)\n    offset = 1\nelse:\n    flgs = [False] * H\n    offset = 0\n\nRs = [-1] * H\nif dfs((H - 1) // 2):\n    print('YES')\nelse:\n    print('NO')\n", "from collections import Counter\nn,m = map(int,input().split())\ngrid = [list(input()) for i in range(n)]\ndef jc(a,b):\n  l = len(a)\n  used = [0]*l\n  for i in range(l):\n    if used[i]:\n      continue\n    for j in range(i+1,l):\n      if used[j]:\n        continue\n      if a[i] == b[j] and b[i] == a[j]:\n        used[i] = 1\n        used[j] = 1\n        break\n  if used.count(0) <= l%2:\n    return True\n  else:\n    return False\ndef judge(a):\n  h = len(a)\n  w = len(a[0])\n  used = [0]*h\n  for i in range(h):\n    if used[i]:\n      continue\n    ci = Counter(a[i])\n    for j in range(i+1,h):\n      if used[j]:\n        continue\n      cj = Counter(a[j])\n      if ci == cj:\n        if jc(a[i],a[j]):\n          used[i] = 1\n          used[j] = 1\n          break\n  if used.count(0) <= h%2:\n    return True\n  else:\n    return False\ngt = list(zip(*grid))\nif judge(grid) & judge(gt):\n  print(\"YES\")\nelse:\n  print(\"NO\")", "def check(field):\n    tr = list(map(''.join, list(zip(*field))))\n    paired = set()\n    center = -1\n    for i, col1 in enumerate(tr):\n        if i in paired:\n            continue\n        for j, col2 in enumerate(tr[i + 1:], start=i + 1):\n            if j in paired:\n                continue\n            if col1 == col2[::-1]:\n                paired.add(i)\n                paired.add(j)\n                break\n        else:\n            if center == -1 and col1 == col1[::-1]:\n                center = i\n            else:\n                return False\n    return True\n\n\ndef arrange_row(field, new_field, i, remain):\n    if len(remain) == 0:\n        return check(new_field)\n    j = remain.pop()\n    new_field[i] = field[j]\n    for k in list(remain):\n        remain.remove(k)\n        new_field[h - i - 1] = field[k]\n        result = arrange_row(field, new_field, i + 1, remain)\n        if result:\n            return True\n        remain.add(k)\n    remain.add(j)\n    return False\n\n\ndef solve(h, w, field):\n    new_field = [None] * h\n    remaining_row = set(range(h))\n\n    if h % 2 == 0:\n        return arrange_row(field, new_field, 0, remaining_row)\n\n    for i in list(remaining_row):\n        remaining_row.remove(i)\n        new_field[h // 2] = field[i]\n        result = arrange_row(field, new_field, 0, remaining_row)\n        if result:\n            return True\n        remaining_row.add(i)\n    return False\n\n\nh, w = list(map(int, input().split()))\nfield = [input() for _ in range(h)]\nprint(('YES' if solve(h, w, field) else 'NO'))\n", "import sys\nimport copy\n\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    def per(s, a=[]):\n        if not s:\n            return [a]\n        if len(s) % 2:\n            cs = copy.deepcopy(s)\n            res = []\n            for u in cs:\n                s.remove(u)\n                res += per(s, [u] + a)\n                s.add(u)\n            return res\n        u = min(s)\n        s.remove(u)\n        cs = copy.deepcopy(s)\n        res = []\n        for uu in cs:\n            if uu < u: continue\n            s.remove(uu)\n            res += per(s, a + [u, uu])\n            s.add(uu)\n        s.add(u)\n        return res\n\n    ord_a = ord(\"a\")\n    h, w = list(map(int, input().split()))\n    t0 = [[ord(c) - ord_a for c in input()] for _ in range(h)]\n    h_set = set(range(h))\n    pattern = per(h_set)\n    # print(t0)\n    # print(pattern)\n    b = h % 2\n    for p in pattern:\n        t1 = [[] for _ in range(h)]\n        if b:\n            t1[h // 2] = t0[p[0]]\n        i = 0\n        for ii in range(b, h, 2):\n            t1[i] = t0[p[ii]]\n            t1[h - 1 - i] = t0[p[ii + 1]]\n            i += 1\n        # print(p)\n        # print(t1)\n        fin = [False] * w\n        mid = (w % 2 == 1)\n        br = False\n        for j, c0 in enumerate(zip(*t1)):\n            if fin[j]: continue\n            fin[j] = True\n            c0 = c0[::-1]\n            for jj, c1 in enumerate(zip(*t1)):\n                if jj <= j: continue\n                if fin[jj]: continue\n                if c0 == c1:\n                    fin[jj] = True\n                    break\n            else:\n                if mid and c0 == c0[::-1]:\n                    mid = False\n                else:\n                    br = True\n                    break\n        if br: continue\n        print(\"YES\")\n        return\n    print(\"NO\")\n\nmain()\n", "# E\nimport numpy as np\n\nH, W = map(int, input().split())\nS = list()\nfor _ in range(H):\n    S.append(list(input()))\nS_arr = np.array(S)\n\nres = \"NO\"\n\ndef check_col_switch(S_arr, H, W):\n    if W % 2 == 1:\n        res_bar = -1\n    else:\n        res_bar = 0\n    done_col = np.zeros(W)\n    for j in range(W):\n        if done_col[j] == 1:\n            continue\n        rev_j = S_arr[::(-1), j]\n        for k in range(W):\n            if np.prod(S_arr[:, k] == rev_j) == 1 and j != k and done_col[k] == 0:\n                done_col[j] = 1\n                done_col[k] = 1\n                break\n        if done_col[j] == 0:\n            if np.prod(S_arr[:, j] == rev_j) == 1:\n                done_col[j] = 1\n                res_bar += 1\n            else:\n                res_bar += 10\n    if res_bar <= 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n    \ndef check_col_switch_fast(S_arr, H, W):\n    \n    col_raw = np.array([\"\".join(list(S_arr[:, j])) for j in range(W)])\n    col_reverse = np.array([\"\".join(list(S_arr[::(-1), j])) for j in range(W)])\n    \n    argsa = np.argsort(col_raw)\n    argsb = np.argsort(col_reverse)\n    \n    res = \"YES\"\n    for j in range(W):\n        if col_raw[argsa[j]] != col_reverse[argsb[j]]:\n            res = \"NO\"\n            break\n    cnt_single = 0\n    for j in range(W):\n        if argsa[j] == argsb[j]:\n            cnt_single += 1\n    j = 0\n    while j < W-1:\n        if col_raw[argsa[j]] != col_raw[argsa[j+1]]:\n            cnt_single -= 2\n            j += 2\n        else:\n            j += 1\n    if cnt_single >= 2:\n        res = \"NO\"\n    \n    return res\n    \ndef make_pairs(x_list):\n    if len(x_list) <= 2:\n        return [[x_list]]\n    else:\n        res = []\n        for j in range(1, len(x_list)):\n            x_list_s = [x_list[k] for k in range(1, len(x_list)) if k != j]\n            res = res + [[[x_list[0], x_list[j]]] + xl for xl in make_pairs(x_list_s)]\n        if len(x_list) % 2 == 1:\n            x_list_l = [x_list[k] for k in range(1, len(x_list))]\n            res = res + [xl + [[x_list[0]]] for xl in make_pairs(x_list_l)]\n        return res\n    \ndef run_row_switch(S_arr, row_matching, H, W):\n    S_arr_row = S_arr.copy()\n    i = 0\n    for mat in row_matching:\n        if len(mat) == 2:\n            S_arr_row[i, :] = S_arr[mat[0], :]\n            S_arr_row[H-1-i, :] = S_arr[mat[1], :]\n            i += 1\n        else:\n            S_arr_row[(H-1)//2, :] = S_arr[mat[0], :]\n    return S_arr_row\n            \nrow_match_list = make_pairs([i for i in range(H)])\n\n\n    \n\n# row_matching\nsame_row_list = []\nfor i in range(H):\n    j_list = [i]\n    for j in range(H):\n        if i != j and np.prod(np.sort(S_arr[i, :]) == np.sort(S_arr[j, :])) == 1:\n            j_list.append(j)\n    same_row_list.append(j_list)\n    \ndef pass_condition(rs):\n    res = True\n    for pair in rs:\n        if len(pair) == 1:\n            continue\n        if pair[1] not in same_row_list[pair[0]]:\n            res = False\n            break\n    return res\n\nrow_match_list_s = [rs for rs in row_match_list if pass_condition(rs)]\n\n\nfor rs in row_match_list_s:\n    res = check_col_switch(run_row_switch(S_arr, rs, H, W), H, W)\n    if res == \"YES\":\n        break\nprint(res)", "import sys\ninput = sys.stdin.readline\nimport itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\nH,W = map(int,input().split())\nwords = np.array([list(input().rstrip()) for _ in range(H)], dtype='U1')\n\ndef gen_pair_pattern_even(rest):\n    # \u5076\u6570\u500b\u3092\u4eee\u5b9a\n    if len(rest) == 0:\n        yield []\n        return\n    if len(rest) == 1:\n        x = rest.pop()\n        yield [(x,x)]\n        return\n    li = list(rest)\n    x = li[0]\n    for y in li[1:]:\n        se = rest.copy()\n        se.remove(x)\n        se.remove(y)\n        for p in gen_pair_pattern_even(se):\n            yield p + [(x,y)]    \n\ndef gen_pair_pattern(N):\n    if N & 1:\n        for n in range(N):\n            se = set(x for x in range(N) if x != n)\n            for p in gen_pair_pattern_even(se):\n                yield p + [(n,n)]\n    else:\n        for p in gen_pair_pattern_even(set(range(N))):\n            yield p\n\ndef test(row_pairs):\n    graph = np.ones((W,W), dtype = np.bool)\n    for r1,r2 in row_pairs:\n        graph &= (words[r1][:,None] == words[r2][None,:])\n    graph &= graph.T\n    se = set(range(W))\n    while se:\n        removed = False\n        for i,j in itertools.combinations(se,2):\n            if graph[i,j]:\n                se.remove(i)\n                se.remove(j)\n                removed = True\n                break\n        if not removed:\n            break\n    if len(se) > 1:\n        return False\n    return True\n\nbl = False\nfor p in gen_pair_pattern(H):\n    if test(p):\n        bl = True\n        break\n\nanswer = 'YES' if bl else 'NO'\nprint(answer)", "H,W=list(map(int,input().split()))\nG=[list(input()) for i in range(H)]\nG_t=[list(x) for x in list(zip(*G))]\ndef Check(G,H,W):\n  Paired_y=[False]*H\n  for y1 in range(H):\n    if Paired_y[y1]:\n      continue\n    for y2 in range(H):\n      if y1==y2 or Paired_y[y2]:\n        continue\n      Paired_x=[False]*W\n      for x1 in range(W):\n        if Paired_x[x1]:\n          continue\n        for x2 in range(W):\n          if x1==x2 or Paired_x[x2]:\n            continue\n          if G[y1][x1]==G[y2][x2] and G[y1][x2]==G[y2][x1]:\n            Paired_x[x1]=True\n            Paired_x[x2]=True\n            break\n      if W%2==1:\n        if Paired_x.count(False)==1:\n          r=Paired_x.index(False)\n          if G[y1][r]==G[y2][r]:\n            Paired_y[y1]=True\n            Paired_y[y2]=True\n            break\n      else:\n        if Paired_x.count(False)==0:\n          Paired_y[y1]=True\n          Paired_y[y2]=True\n          break\n  if H%2==1:\n    if Paired_y.count(False)==1:\n      return True\n    else:\n      return False\n  else:\n    if Paired_y.count(False)==0:\n      return True\n    else:\n      return False\n  \nif Check(G,H,W) and Check(G_t,W,H):\n  print(\"YES\")\nelse:\n  print(\"NO\")\n\n      \n      \n        \n                         \n      \n    \n", "def _3():\n    from collections import defaultdict\n\n    def can_pair(s1, s2):\n        l = []\n        for c1, c2 in zip(s1, s2):\n            c = sorted([c1, c2])\n            if c in l:\n                l.remove(c)\n            else:\n                l.append(c)\n\n        if len(s1) % 2 == 0:\n            return len(l) == 0\n        else:\n            return len(l) == 1 and l[0][0] == l[0][1]\n\n    def pair_graph(s1, s2):\n        N = len(s1)\n        G = np.zeros([N, N])\n        for i in range(N):\n            for j in range(i+1, N):\n                if s1[i] == s2[j] and s1[j] == s2[i]:\n                    G[i, j] = 1\n                    G[j, i] = 1\n        return G\n\n    import numpy as np\n    H, W = list(map(int, input().split(' ')))\n    S = []\n    d = defaultdict(list)\n\n    for h in range(H):\n        s = input()\n        S.append(s)\n        d[''.join(sorted(S))].append(h)\n\n    already_paired = np.zeros(H)\n\n    Gs = []\n\n    for i in range(H):\n        if already_paired[i]:\n            continue\n\n        for j in range(i+1, H):\n            if already_paired[j]:\n                continue\n\n            if can_pair(S[i], S[j]):\n                already_paired[i] = 1\n                already_paired[j] = 1\n                G = pair_graph(S[i], S[j])\n                Gs.append(G)\n                break\n\n    if already_paired.sum() < H - 1:\n        print('NO')\n        return\n\n    elif already_paired.sum() == H - 1:\n        for i in range(H):\n            if already_paired[i] == 0:\n                G = pair_graph(S[i], S[i])\n                Gs.append(G)\n                break\n\n    G = np.array(Gs).sum(axis=0) // len(Gs)\n\n    def is_perfect_matching(G):\n        N = len(G)\n        if N == 1:\n            return True\n\n        for i in range(N):\n            for j in range(i+1, N):\n                if G[i, j] == 1:\n                    l = list(range(N))\n                    l.remove(i)\n                    l.remove(j)\n                    if len(l) == 0:\n                        return True\n                    if is_perfect_matching(G[l][:, l]):\n                        return True\n        return False\n\n    if is_perfect_matching(G):\n        print('YES')\n    else:\n        print('NO')\n\ndef __starting_point():\n    _3()\n__starting_point()", "def _3():\n    from collections import defaultdict\n\n    def can_pair(s1, s2):\n        l = []\n        for c1, c2 in zip(s1, s2):\n            c = sorted([c1, c2])\n            if c in l:\n                l.remove(c)\n            else:\n                l.append(c)\n\n        if len(s1) % 2 == 0:\n            return len(l) == 0\n        else:\n            if len(l) == 1:\n                if l[0][0] == l[0][1]:\n                    return True\n            return False\n\n    def pair_graph(s1, s2):\n        N = len(s1)\n        G = np.zeros([N, N])\n        for i in range(N):\n            for j in range(i+1, N):\n                if s1[i] == s2[j] and s1[j] == s2[i]:\n                    G[i, j] = 1\n                    G[j, i] = 1\n        return G\n\n    import numpy as np\n    H, W = list(map(int, input().split(' ')))\n    S = []\n    d = defaultdict(list)\n\n    for h in range(H):\n        s = input()\n        S.append(s)\n        d[''.join(sorted(S))].append(h)\n\n    already_paired = np.zeros(H)\n\n    Gs = []\n\n    for i in range(H):\n        if already_paired[i]:\n            continue\n\n        for j in range(i+1, H):\n            if already_paired[j]:\n                continue\n\n            if can_pair(S[i], S[j]):\n                already_paired[i] = 1\n                already_paired[j] = 1\n                G = pair_graph(S[i], S[j])\n                Gs.append(G)\n                break\n\n    if already_paired.sum() < H - 1:\n        print('NO')\n        return\n\n    elif already_paired.sum() == H - 1:\n        for i in range(H):\n            if already_paired[i] == 0:\n                G = pair_graph(S[i], S[i])\n                Gs.append(G)\n                break\n\n    G = np.array(Gs).sum(axis=0) // len(Gs)\n\n    def is_perfect_matching(G):\n        N = len(G)\n        if N == 1:\n            return True\n\n        for i in range(N):\n            for j in range(i+1, N):\n                if G[i, j] == 1:\n                    l = list(range(N))\n                    l.remove(i)\n                    l.remove(j)\n                    if len(l) == 0:\n                        return True\n                    if is_perfect_matching(G[l][:, l]):\n                        return True\n        return False\n\n    if is_perfect_matching(G):\n        print('YES')\n    else:\n        print('NO')\n\ndef __starting_point():\n    _3()\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\n#n = int(readline())\nh,w = list(map(int,readline().split()))\ns = read().split()\n\n\ngood_move = [[None]*h for _ in range(h)]\nfor i in range(h):\n    for j in range(i,h):\n        se = set()\n        for p in range(w):\n            for q in range(p,w):\n                if s[i][p] == s[j][q] and s[i][q] == s[j][p]:\n                    se.add(p*16+q)\n        good_move[i][j] = se\n\n#print(good_move)\n        \ndef check(q):\n    def isok(x,y):\n        return all(x*16+y in good_move[r[2*i]][r[2*i+1]] for i in range((h+1)//2))\n    \n    def dfs2(d,p):\n        if d == w:\n            return True\n        \n        if d==0 and w&1:\n            for idx in range(w):\n                if isok(idx,idx):\n                    p[idx] = 0\n                    if dfs2(1,p): return True\n                    p[idx] = -1\n            return False\n\n        idx = p.index(-1)\n        #print(p,idx)\n        p[idx] = d\n        for k in range(idx+1,w):\n            #print(idx,k,idx*16+k,isok(idx,k))\n            if p[k] == -1 and isok(idx,k):\n                p[k] = d+1\n                if dfs2(d+2,p): return True\n                p[k] = -1\n        p[idx] = -1\n        return False\n    \n    r = [0]*h\n    for i in range(h):\n        r[q[i]] = i\n    if h&1:\n        r.append(r[-1])\n    #print(r); return False\n    p = [-1]*w\n    return dfs2(0,p)\n\ndef dfs(d):\n    #nonlocal cnt\n    nonlocal flag\n    if d == h or d == h-1:\n        #cnt += 1;return False\n        return check(p)\n\n    if d==0 and h&1 and flag:\n        flag = 0\n        for idx in range(h):\n            p[idx] = h-1\n            if dfs(0): return True\n            p[idx] = -1\n        return False\n    \n    #print(p,d)\n    idx = p.index(-1)\n    p[idx] = d\n    for k in range(idx+1,h):\n        if p[k] == -1:\n            p[k] = d+1\n            if dfs(d+2): return True\n            p[k] = -1\n    p[idx] = -1\n    return False\n\np = [-1]*h\ncnt = 0\nflag = 1\nif dfs(0):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n#print(cnt)\n", "# \u3053\u306e\u89e3\u6cd5\u306f\u5618\u3092\u542b\u3080\n\nfrom itertools import groupby\nH, W = list(map(int, input().split()))\nS_ = [\"\" for _ in range(W)]\nT_ = []\nfor _ in range(H):\n    s = input()\n    T_.append(s)\n    for i, c in enumerate(s):\n        S_[i] += c\nT = [sorted(t) for t in T_]\nS = [sorted(s) for s in S_]\ncnt = 0\nfor _, g in groupby(sorted(T)):\n    if len(list(g))%2:\n        cnt += 1\nif H%2 < cnt:\n    print(\"NO\")\n    return\ncnt = 0\nfor _, g in groupby(sorted(S)):\n    if len(list(g))%2:\n        cnt += 1\nif W%2 < cnt:\n    print(\"NO\")\n    return\nif W%2 or H%2:\n    print(\"YES\")\n    return\nT1 = []\nT2 = []\nfor i, (_, t) in enumerate(sorted(zip(T, T_))):\n    if i%2:\n        T1.append(t)\n    else:\n        T2.append(t)\nT_p = T1 + T2[::-1]\nS_pp = [\"\" for _ in range(W)]\nfor t in T_p:\n    for i, c in enumerate(t):\n        S_pp[i] += c\nS1 = []\nS2 = []\nfor i, (_, s) in enumerate(sorted(zip(S, S_pp))):\n    if i%2:\n        S1.append(s)\n    else:\n        S2.append(s)\nS_p = S1 + S2[::-1]\nfor s1, s2 in zip(S_p, S_p[::-1]):\n    for c1, c2 in zip(s1, s2[::-1]):\n        if c1!=c2:\n            print(\"NO\")\n            return\nprint(\"YES\")\n", "h,w = map(int,input().split())\ns = [input() for _ in range(h)]\na = [-1]*h\nb = [1]*w\n\ndef check(x):\n    if x==0:\n        return 1\n    i = b.index(1)\n    if x&1:\n        if all(s[p][i] == s[a[p]][i] for p in range(h)):\n            b[i] = 0\n            if check(x-1): return 1\n            b[i] = 1\n    for j in range(i+1,w):\n        if b[j] and all(s[p][i] == s[a[p]][j] for p in range(h)):\n            b[i] = b[j] = 0\n            if check(x-2): return 1\n            b[i] = b[j] = 1\n    return 0\n\ndef dfs(x):\n    if x==0:\n        return check(w)\n    i = a.index(-1)\n    if x&1:\n        a[i] = i\n        if dfs(x-1): return 1\n        a[i] = -1\n    for j in range(i+1,h):\n        if a[j] == -1:\n            a[i],a[j] = j,i\n            if dfs(x-2): return 1\n            a[i] = a[j] = -1\n    return 0\n\nprint(\"YES\" if dfs(h) else \"NO\")", "\"\"\"\n\nhttps://atcoder.jp/contests/arc095/tasks/arc095_c\n\n\u5217\u3001\u884c\u306e\u6587\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\u5909\u308f\u3089\u306a\u3044\n\u2192\u5bfe\u5fdc\u3059\u308b\u5217\u30fb\u884c\u306e\u7d44\u307f\u5408\u308f\u305b\u304c\u306a\u3051\u308c\u3070\u3060\u3081\n\n\u2192\u3067\u306f\u3001\u5404\u7d44\u307f\u5408\u308f\u305b\u304c2\u3053\u305a\u3064\u3061\u3083\u3093\u3068\u3042\u308c\u3070\u5fc5\u305a\u53ef\u80fd\u304b\u2026\uff1f\n\u2192\u3060\u3068\u3057\u305f\u3089\u5236\u7d04\u5c0f\u3055\u3059\u304e\u306a\u3044\uff1f\uff1f\n\nab\nba\n\nabc\naba\ncba\n\n\u2192\u591a\u5206\u5341\u5206\u6761\u4ef6\u3067\u306f\u306a\u3044\u3051\u3069\u5c11\u306a\u304f\u3068\u3082\u5404\u7d44\u307f\u5408\u308f\u305b\u304c2\u3053\u306a\u3044\u5834\u5408\u306f\u7d76\u5bfe\u00d7\n\u2192\u304b\u3064\u3001\u7aef\u6570\u306e\u6587\u5b57\u304c1\u3053\u4ee5\u4e0b\u3067\u306a\u3044\u3068\u3060\u3081\n\u30c0\u30e1\u306a\u5834\u5408\u306f\u306a\u3093\u3060\u30fc\u30fc\u30fc\n\n\u5206\u304b\u3089\u306a\u3044\u3051\u3069\u63a2\u7d22\u3059\u308c\u3070\u3088\u3055\u305d\u3046\n\u2192\u30da\u30a2\u306b\u306a\u308b\u5217\u30fb\u884c\u3055\u3048\u6c7a\u307e\u308c\u3070\u3044\u3044\n\n(11*9*7*5*3*1)**2\u3000\u2192 10^8\u3050\u3089\u3044\u3000\u6700\u592712**2\u56de\u63a2\u7d22\u3059\u308b\u306e\u3067\u2026\u30a2\n1ms\u89e3\u6cd5\u306f\u4f55\u2026\n\n\u3042\u3089\u304b\u3058\u3081\u3042\u308a\u3046\u308b\u30da\u30a2\u3060\u3051\u5217\u6319\u3057\u3066\u304a\u304f\uff1f\n\u2192\u3042\u3068\u306e\u5165\u308c\u66ff\u3048\u306f\u63a2\u7d22\n\n\u2192\u6700\u5927\u306b\u306a\u308b\u3088\u3046\u306a\u5834\u5408\u306f\u5168\u90e8\u540c\u3058\u5834\u5408\u306a\u306e\u3067\u3059\u3050\u7b54\u3048\u304c\u898b\u3064\u304b\u308b\u2026\u3068\u4fe1\u3058\u305f\u3044\n\n1234\n2341\n3412\n4123 \u2192\u3053\u306e\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u6700\u60aa\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u2026\n\n1234\n2341\n4123\n3412\n\n1243\n2314\n4132\n3421\u2192ok\u2026\uff1f\n\n\u5fc5\u8981\u5341\u5206\u6761\u4ef6\u306a\u306e\u304b\u2026\uff1f\u3000700\u70b9\u3060\u3057\u2026\uff1f\n\n\u53cd\u4f8b:\n12Z34\n23Y41\nZYXYZ\n41Y23\n34Z12\n\n\n\u3069\u3046\u3084\u3089\u73fe\u5b9f\u7684\u306a\u6642\u9593\u3067\u89e3\u3051\u308b\u3089\u3057\u3044\n\u3061\u3083\u3093\u3068\u8003\u3048\u3088\u3046\n\u2192\u5165\u308c\u66ff\u3048\u305f\u969b\u306b\u4fdd\u6301\u3055\u308c\u308b\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8003\u3048\u308b\u2026\uff1f\n\n\u7b54\u3048\u306b\u5bfe\u3057\u3001\u5bfe\u79f0\u306a\u5217\u3068\u884c\u3092\u5165\u308c\u66ff\u3048\u3066\u3082\u554f\u984c\u306a\u3044\n& \u5bfe\u79f0\u306a\u5217\u306eset/\u884c\u306eset\u3092\u5165\u308c\u66ff\u3048\u3066\u3082\u554f\u984c\u306a\u3044\n\u2192\u3059\u306a\u308f\u3061\u5217\u30fb\u884c\u306e\u5bfe\u5fdc\u4ee5\u5916\u306f\u5168\u304f\u95a2\u4fc2\u306a\u3044\n\n=====\u7b54\u3048\u3092\u898b\u305f=====\n\u7247\u5074\u3060\u3051\u30da\u30a2\u306b\u3059\u308b\u306e\u304b\u2026\n\u2192\u78ba\u304b\u306b\u7247\u5074\u5168\u63a2\u7d22\u3057\u305f\u3089\u3082\u3046\u7247\u65b9\u306f\u7c21\u5358\u306b\u5224\u5b9a\u3067\u304d\u308b\u2026(\u88cf\u8fd4\u3057\u304c\u3042\u308b\u304b\u5224\u5b9a\u3059\u308b\u3060\u3051\u306a\u306e\u3067)\n\n\u5177\u4f53\u7684\u306a\u5b9f\u88c5\u306f\u2026\n\u307e\u305a\u30da\u30a2\u3092\u5217\u6319\u2192\u518d\u5e30\u3067\u9069\u5f53\u306b\u3084\u308b\n\u2192\u5217\u3092\u5165\u308c\u66ff\u3048\u305f\u3068\u3059\u308b\n\n\u6b21\u306b\u6a2a\u3067\u898b\u3066\u3063\u3066\u3001\u5404\u30da\u30a2\u306e\u6570\u5b57\u304c\u5168\u3066\u5bfe\u306b\u306a\u3063\u3066\u308b\u7269\u304c\u3042\u308b\u304b\u8abf\u3079\u308c\u3070\u3044\u3044\n\u2192\u30da\u30a2\u901a\u308a\u6570 * H * H * W\n\"\"\"\n\ndef pair(end,lis):\n    if len(lis) == 0:\n        p.append(end)\n        return\n    else:\n        end.append(lis[0])\n        del lis[0]\n        for j in range(len(lis)):\n            pair( end+[lis[j]] , lis[:j]+lis[j+1:])\n\nfrom sys import stdin\nimport sys\n\nH,W = map(int,stdin.readline().split())\n\nS = []\nfor i in range(H):\n    s = stdin.readline()\n    S.append(s[:-1])\n#print (S)\n\n#\u30da\u30a2\u5217\u6319\np = []\nif W % 2 == 0:\n    pair([],[i for i in range(W)])\nelse:\n    tmp = [i for i in range(W)]\n    for i in range(W):\n        pair([i,i] , tmp[:i] + tmp[i+1:])\n\n#print (p)\n\nfor pl in p:\n    able = [True] * H\n    flag = 0\n\n    for i in range(H):\n        if able[i]:\n            for j in range(i+1,H):\n                if not able[j]:\n                    continue\n\n                tmpf = True\n                for w in range((W+1)//2):\n                    if S[i][pl[2*w]] != S[j][pl[2*w+1]] or S[j][pl[2*w]] != S[i][pl[2*w+1]]:\n                        tmpf = False\n                        break\n                if tmpf:\n                    able[i] = False\n                    able[j] = False\n                    break\n            else:\n                if H % 2 == 0 or flag == 1:\n                    flag = 2\n                    break\n                for w in range((W+1)//2):\n                    if S[i][pl[2*w]] != S[i][pl[2*w+1]]:\n                        flag = 2\n                        break\n                else:\n                    flag = 1\n                    able[i] = False\n                if flag == 2:\n                    break\n                \n    if flag != 2:\n        print (\"YES\")\n        break\nelse:\n    print (\"NO\")"]
["import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(pow(n, 0.5)) + 1):\n        if n % i == 0:\n            ex = 0\n            while n % i == 0:\n                ex += 1\n                n //= i\n            res.append(ex)\n    if n != 1:\n        res.append(1)\n    return res\n\n\ndef resolve():\n    N, M = list(map(int, input().split()))\n\n    pf = prime_factorization(M)\n    cmb = CmbMod(10 ** 6, mod)\n    cmb.prep()\n\n    res = 1\n    for b in pf:\n        res *= cmb.cmb_mod_with_prep(b + N - 1, b)\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# coding: utf-8\nimport sys\nimport numpy as np\nfrom collections import Counter\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n# \u7d20\u56e0\u6570\u5206\u89e3\u3092\u3057\u3066\u3001\u305d\u308c\u305e\u308c\u306e\u56e0\u6570\u3092\u3069\u3053\u306b\u5165\u308c\u308b\u304b\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 6  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\ndef prime_factorize(n): # N\u306e\u7d20\u56e0\u6570\u5206\u89e3\n    A = []\n    while n % 2 == 0:\n        A.append(2); n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            A.append(f); n //= f\n        else:\n            f += 2\n    if n != 1:\n        A.append(n)\n    return A\n\nN, M = lr()\nprimes = prime_factorize(M)\ncounter = Counter(primes)\nanswer = 1\nfor v in list(counter.values()):\n    cases = cmb(N-1+v, v)\n    answer *= cases\n    answer %= MOD\n\nprint((answer % MOD))\n# np.int64\u3068int\u578b\u306e\u9055\u3044\u306b\u6ce8\u610f\n# 16\n", "N, M = list(map(int, input().split()))\n\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n\n    if arr == []:\n        arr.append([n, 1])\n\n    return arr\n\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\nprimes = factorization(M)\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\nif N == 1 or M == 1:\n    print((1))\n    return\nans = 1\nfor p, cnt in primes:\n    tmp = 0\n    for i in range(1, min(cnt, N)+1):\n        tmp += cmb(N, i, mod) * cmb(cnt-1, i-1, mod)\n        #print(tmp, p, cnt, i)\n        tmp %= mod\n    ans *= tmp\n    ans %= mod\n\nprint(ans)\n", "from collections import defaultdict\nN,M=map(int,input().split())\ncount=defaultdict(int)\np=2\nwhile p<=10**4.5+5:\n    if M%p==0:\n        count[p] += 1\n        M//=p\n    else:\n        p+=1\nif M>1:\n    count[M]+=1\ndef cmb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n    for p in range(2,r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1,r,p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n    return result\nans=1\nmod=10**9+7\nfor i in count.keys():\n  ans*=cmb(N-1+count[i],count[i])\n  ans%=mod\nprint(ans)", "MAX = 10**6\nMOD = 10**9+7\n\nfac = [0] * (MAX+1)\nfinv = [0] * (MAX+1)\ninv = [0] * (MAX+1)\n\ndef comb_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX+1):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD\n\n\ndef prime_factorize(n):\n    table = {}\n    while n % 2 == 0:\n        table[2] = table.get(2, 0) + 1\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            table[f] = table.get(f, 0) + 1\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        table[n] = table.get(n, 0) + 1\n    return table\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    comb_init()\n    prime_factor = prime_factorize(m)\n    res = 1\n    for v in list(prime_factor.values()):\n        res *= comb(v+n-1, n-1)\n        res %= MOD\n    print(res)\n\n__starting_point()", "def factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n \n    if temp!=1:\n        arr.append([temp, 1])\n \n    if arr==[]:\n        arr.append([n, 1])\n \n    return arr\n \ndef cmb(n,r,mod):\n  a=1\n  b=1\n  r = min(r,n-r)\n  for i in range(r):\n    a = a*(n-i)%mod\n    b = b*(i+1)%mod\n  return a*pow(b,mod-2,mod)%mod\n\nN,M = map(int,input().split())\nMOD = 10**9+7\nf = factorization(M)\nans = 1\n\nfor i,j in f:\n  ans *= cmb(j+N-1,j,MOD)\n  ans %= MOD\nif M == 1:\n  ans = 1\nprint(ans)", "N,M = map(int,input().split())\ndiv =[]\nfor i in range(2,int(M**(1/2))+2):\n    cur = 0\n    while M%i==0:\n        M = M//i\n        cur += 1\n    if cur >=1:\n        div.append(cur)\nif M>1: div.append(1)\ndiv.sort()\nmod = 10**9+7\nfrac = [1]*(N+50)\nnum = len(frac)\nfor i in range(len(frac)-1):\n    frac[i+1] = frac[i]*(i+1)%mod\nfinv = [1] * (N+50)\nfinv[-1] = pow(frac[-1], mod-2, mod)\nfor i in range(1, num):\n  finv[num-1-i] = finv[num-i] * (num-i) % mod\nans = 1\nfor i in div:\n    ans = ans * frac[N+i-1]*finv[N-1]*finv[i]%mod\nprint(ans)", "# coding: utf-8\nfrom collections import Counter\n\n\ndef ncr(n, r, mod):\n    ret = 1\n    for i in range(1, r+1):\n        ret = (ret * (n-i+1) * pow(i, mod-2, mod)) % mod\n    return ret\n\n\ndef solve(*args: str) -> str:\n    n, m = list(map(int, args[0].split()))\n    mod = 10**9+7\n    C = Counter()\n\n    i = 2\n    r = -int(-m**(1/2)//1)\n    while 1 < m:\n        while m % i == 0:\n            C[i] += 1\n            m //= i\n        if r < i:\n            C[m] = 1\n            break\n        i += 1\n\n    ret = 1\n    for v, c in list(C.items()):\n        ret *= ncr(n+c-1, min(n-1, c), mod)\n        ret %= mod\n\n    return str(ret)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "from collections import Counter\n\nn, m = list(map(int, input().split()))\n\nif m == 1:\n    print(1)\nelse:\n\n    MOD = pow(10, 9) + 7\n\n    def prime_factorize(n):\n        a = []\n        while n % 2 == 0:\n            a.append(2)\n            n //= 2\n        f = 3\n        while f * f <= n:\n            if n % f == 0:\n                a.append(f)\n                n //= f\n            else:\n                f += 2\n        if n != 1:\n            a.append(n)\n        return a\n\n    def make_fact_list(n, MOD):\n        # make factorial list from 0 to n\n        fact = [0] * (n+1)\n        inv = [0] * (n+1)\n        factinv = [0] * (n+1)\n\n        fact[0]=fact[1]=1\n        inv[1]=1\n        factinv[0]=factinv[1]=1\n\n        for i in range(2,n+1):\n            fact[i] = fact[i-1] * i % MOD\n            inv[i] = MOD - (( inv[MOD % i] *  (MOD // i)) % MOD )\n            factinv[i] = factinv[i-1] * inv[i] % MOD\n        \n        return fact, factinv\n\n    def cbn(n, k, MOD, fact = [], factinv = []):\n        if len(fact) == 0 and len(factinv) == 0:\n            fact, factinv = make_fact_list(n, MOD)\n        return fact[n] * factinv[n-k] * factinv[k] % MOD\n\n\n    d = Counter(prime_factorize(m)).most_common()\n\n    l = d[0][1] + n \n\n    fact, factinv = make_fact_list(l, MOD)\n\n    a = 1\n\n    for k, v in d:\n        a *= cbn(v + n - 1, v, MOD, fact = fact, factinv = factinv) % MOD\n\n    print(a % MOD)", "#!/usr/bin/env python3\nimport sys\n\nMOD = 1000000007  # type: int\n\n\ndef solve(N: int, M: int):\n    factors = {}\n    m = M\n    for i in range(2, int(M**0.5)+1):\n        while m % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            m //= i\n    else:\n        if m != 1:\n            factors[m] = 1\n    mf = ModFactorial(MOD)\n    ans = 1\n    for c in list(factors.values()):\n        ans = ans * mf.combination(c+N-1, c) % MOD\n    return ans\n        \n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    print((solve(N, M)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\n\ndef mod_range(mod, start, stop=None, step=1):    \n    if stop == None:\n        stop = start\n        start = 0\n    return [i % mod for i in range(start, stop, step)]\n\ndef mod_inv(mod, n):\n    '''\n    >>> mod_inv(3, 2)\n    2\n    >>> mod_inv(1000000007, 2)\n    500000004\n    '''\n    return pow(n, mod-2, mod)\n\ndef mod_permutation(mod, n, r):\n    '''\n    >>> mod_permutation(1000000007, 10, 2)\n    90\n    >>> mod_permutation(7, 10, 2)\n    6\n    '''\n    m = 1\n    for i in mod_range(mod, n-r+1, n+1):\n        m = (m * i) % mod\n    return m\n\ndef mod_factorial(mod, n):\n    '''\n    >>> mod_factorial(1000000007, 10)\n    3628800\n    >>> mod_factorial(7, 6)\n    6\n    '''\n    return mod_permutation(mod, n, n)\n\ndef mod_combination(mod, n, r):\n    '''\n    >>> mod_combination(1000000007, 10, 2)\n    45\n    >>> mod_combination(7, 10, 2)\n    3\n    '''\n    return mod_permutation(mod, n, r) * mod_inv(mod, mod_factorial(mod, r)) % mod\n\nclass ModFactorial:\n    def __init__(self, mod, size=1):\n        '''\n        >>> ModFactorial(7, 7)\n        Traceback (most recent call last):\n        ...\n        AssertionError\n        '''\n        assert mod > size\n        self._mod = mod\n        self._init_factorials(size)\n\n    def _mod_range(self, start, stop=None, step=1):\n        return mod_range(self._mod, start, stop, step)\n    \n    def _mod_inv(self, n):\n        return mod_inv(self._mod, n)\n    \n    def _init_factorials(self, size):\n        '''\n        >>> mf1 = ModFactorial(1000000007)\n        >>> mf2 = ModFactorial(1000000007, 10)\n        >>> mf1.factorial(10) == mf2.factorial(10)\n        True\n        '''\n        self._factorials = [1] * size        \n        n = 1 # \u30ea\u30b9\u30c8\u306e\u53c2\u7167\u306f\u9045\u3044\u306e\u3067\u6e1b\u3089\u3059\n        for i, m in enumerate(self._mod_range(1, size), 1):\n            n = (n * m) % self._mod\n            self._factorials[i] = n\n            \n    def _append_factorials(self, n):\n        for m in [i % self._mod for i in range(len(self._factorials), n+1)]:\n            self._factorials.append((self._factorials[-1] * m) % self._mod)\n\n    def factorial(self, n):\n        '''\n        >>> ModFactorial(1000000007).factorial(10)\n        3628800\n        >>> ModFactorial(7).factorial(6)\n        6\n        >>> ModFactorial(7).factorial(7)\n        Traceback (most recent call last):\n        ...\n        AssertionError\n        '''\n        assert n < self._mod\n        if len(self._factorials) <= n:\n            self._append_factorials(n)\n        return self._factorials[n]\n\n    def factorial_inv(self, n):\n        '''\n        >>> MOD = 1000000007\n        >>> mf = ModFactorial(MOD)\n        >>> mf.factorial_inv(10)\n        283194722\n        >>> mf.factorial_inv(10) * mf.factorial(10) % MOD\n        1\n        >>> MOD = 7\n        >>> mf = ModFactorial(MOD)\n        >>> mf.factorial_inv(6)\n        6\n        >>> mf.factorial_inv(6) * mf.factorial(6) % MOD\n        1\n        '''\n        return self._mod_inv(self.factorial(n))\n\n    def permutation(self, n, r):\n        '''\n        >>> ModFactorial(1000000007).permutation(10, 2)\n        90\n        '''\n        return self.factorial(n) * self.factorial_inv(n-r) % self._mod\n\n    def combination(self, n, r):\n        '''\n        >>> ModFactorial(1000000007).combination(10, 2)\n        45\n        '''\n        return self.permutation(n, r) * self.factorial_inv(r) % self._mod\n\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "def prime_factorization(n):\n    \"\"\"\n    n\u3092\u7d20\u56e0\u6570\u5206\u89e3\n    :param n:\n    :return:\u7d20\u56e0\u6570\u5206\u89e3\u7d50\u679c [(\u7d20\u6570S1, count S1),(\u7d20\u6570S2, count S2), ...]\n\n    \"\"\"\n    from math import sqrt\n    if (n == 0): return []\n    if (n == 1): return [(1, 1)]\n\n    res = []\n    for i in range(2, int(sqrt(n)) + 1):\n        if n == 1: break\n        cnt = 0\n        while n % i == 0:\n            cnt += 1\n            n = n // i\n        if cnt > 0:\n            res.append((i, cnt))\n    if n > 1:\n        res.append((n, 1))\n\n    return res\n\n\nclass ModFactorial:\n    \"\"\"\n    \u968e\u4e57, \u7d44\u307f\u5408\u308f\u305b, \u9806\u5217\u306e\u8a08\u7b97\n    \"\"\"\n\n    def __init__(self, n, MOD=10 ** 9 + 7):\n        \"\"\"\n\n        :param n: \u6700\u5927\u306e\u8981\u7d20\u6570.\n        :param MOD:\n        \"\"\"\n        kaijo = [0] * (n + 10)\n        gyaku = [0] * (n + 10)\n\n        kaijo[0] = 1\n        kaijo[1] = 1\n        for i in range(2, len(kaijo)):\n            kaijo[i] = (i * kaijo[i - 1]) % MOD\n        gyaku[0] = 1\n        gyaku[1] = 1\n        for i in range(2, len(gyaku)):\n            gyaku[i] = pow(kaijo[i], MOD - 2, MOD)\n        self.kaijo = kaijo\n        self.gyaku = gyaku\n        self.MOD = MOD\n\n    def nCm(self, n, m):\n        return (self.kaijo[n] * self.gyaku[n - m] * self.gyaku[m]) % self.MOD\n\n    def nPm(self, n, m):\n        return (self.kaijo[n] * self.gyaku[n - m]) % self.MOD\n\n    def factorial(self, n):\n        return self.kaijo[n]\n\n\nN, M = [int(_) for _ in input().split()]\nif M == 1:\n    print((1))\n    return\n\nprimes = [v for _, v in prime_factorization(M)]\n\nMOD = 10 ** 9 + 7\nmf = ModFactorial(max(primes) + 1 + N, MOD)\n\nans = 1\nfor cnt in primes:\n    ans = ans * mf.nCm(cnt + N - 1, N - 1)\n    ans = ans % MOD\nprint(ans)\n", "def modpow(a,n):\n  if n<1:\n    return 1\n  ans=modpow(a,n//2)\n  ans=(ans*ans)%mod\n  if n%2==1:\n    ans*=a\n  return ans%mod\n\ndef conb(n,i):\n  inv,ans=1,1\n  for j in range(1,i+1):\n    ans=ans*(n-j+1)%mod\n    inv=inv*j%mod\n  return (ans*modpow(inv,mod-2))%mod\n\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append(cnt)\n    if temp!=1:\n        arr.append(1)\n\n    if arr==[]:\n        arr.append(1)\n    return arr\n\n\n\nmod=10**9+7\nN,M=[int(x) for x in input().rstrip().split()]\nfact=factorization(M)\nans=1\n\nif M==1:\n  print((1))\nelse:\n  for i in fact:\n    ans*=conb(i+N-1,N-1)\n  print((ans%mod))\n\n", "MOD = 10**9+7\nn, m = map(int, input().split())\n\n\ndef factorization(n):\n    retval = []\n    tmp = n\n    for i in range(2, int(-(-n**.5//1))+1):\n        if tmp % i == 0:\n            cnt = 0\n            while tmp % i == 0:\n                cnt += 1\n                tmp //= i\n            retval.append((i, cnt))\n    if tmp != 1:\n        retval.append((tmp, 1))\n    if not retval:\n        retval.append((n, 1))\n    return retval\n\n\nfact = factorization(m)\n\n\ndef com(n, r):\n    X = Y = 1\n    if n-r < r:\n        r = n-r\n    for i in range(1, r+1):\n        Y = Y*i % MOD\n        X = X*(n-i+1) % MOD\n    Y = pow(Y, MOD-2, MOD)\n    return X*Y\n\n\nans = 1\nfor f in fact:\n    ans *= com(n+f[1]-1, n-1)\nif m == 1:\n    print(1)\nelse:\n    print(ans % MOD)", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n\n    d = 3\n    ma = d * d\n    while ma <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        ma += d * 4 + 4\n        d += 2\n\n    if x > 1:\n        yield 1\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M = list(map(int, input().split()))\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# D - Factorization\n\nN, M = map(int, input().split())\nMOD = 10**9 + 7\n\ndef prime_factorization(n):\n    prime_factors = []\n    if n < 2:\n        return 0\n    for i in range(2, int(pow(n, 0.5)+1)):\n        if n%i==0:\n            ex = 0\n            while n%i==0:\n                ex += 1\n                n //= i\n            prime_factors.append((i, ex))\n    if n!=1:\n        prime_factors.append((n,1))\n    return prime_factors\n\nfac = [1, 1]\ninv = [0, 1]\nfinv = [1, 1]\n\nfor i in range(2, N+36):\n    fac.append(fac[-1] * i % MOD)\n    inv.append(MOD - inv[MOD%i] * (MOD//i) % MOD)\n    finv.append(finv[-1] * inv[-1] % MOD)\n\ndef comb_mod(n, r, m):\n    if (n<0 or r<0 or n<r): return 0\n    r = min(r, n-r)\n    return fac[n] * finv[n-r] * finv[r] % m\n\nprimes = prime_factorization(M)\nans = 1\nif primes != 0:\n    for (p, ex) in primes:\n        ans = (ans * comb_mod(ex+N-1, N-1, MOD)) % MOD\n\nprint(ans)", "from collections import defaultdict\ndef factorization(n):\n    arr = {}\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr[i] = cnt\n\n    if temp != 1:\n        arr[temp] = 1\n    if len(list(arr.keys())) == 0:\n        arr[n] = 1\n    return arr\n\n\ndef prepare(n, MOD):\n\n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\nimport math\nfrom itertools import combinations\nfrom collections import Counter\nMOD = 1000000007\n\ndef solve():\n    N, M = list(map(int, input().split()))\n    temp = factorization(M)\n    #print(temp)\n    max_num = max(temp.values())\n    factorials, invs = prepare(N+max_num-1, MOD)\n    #print(factorials, invs)\n    ans = 1\n    for i, j in list(temp.items()):\n        if i == 1:\n            break\n        ans *= factorials[N+j-1]\n        ans %= MOD\n        ans *= invs[N-1]\n        ans %= MOD\n        ans *= invs[j]\n        ans %= MOD\n        #print(ans)\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nimport collections\n\ninput = sys.stdin.readline\n\n\ndef modInverse(a, p):\n    return pow(a, p - 2, p)\n\n\ndef modBinomial(n, k, p):\n    numerator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % p\n\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = (denominator * i) % p\n\n    return (numerator * modInverse(denominator, p)) % p\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n\n    MOD = 10 ** 9 + 7\n\n    def prime_factorization(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    x = prime_factorization(M)\n\n    c = collections.Counter(x)\n\n    ans = 1\n    for k in list(c.keys()):\n        ans *= modBinomial(c[k] + N - 1, c[k], MOD)\n\n    print((ans % MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n\n    d = 3\n    while d * d <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        d += 2\n\n    if x > 1:\n        yield 1\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M = list(map(int, input().split()))\n\n    ans = 1\n    for cnt in gen(M):\n        for d in range(cnt):\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n            \n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = list(map(int, input().split()))\n\nMsq = int(M**(1/2)) + 2\nyaku = []\n\nfor i in range(2, Msq):\n  now = 0\n  while M%i == 0:\n    M = M//i\n    now += 1\n  if now >= 1:\n    yaku.append(now)\n    \nif M > 1:\n  yaku.append(1)\n  \nyaku.sort()\n\nMOD = 1000000007\nfrac = [1] * (N+50)\nnum = len(frac)\nfor i in range(num-1):\n  frac[i+1] = frac[i] * (i+1) % MOD\n  \nfinv = [1] * (N+50)\nfinv[-1] = pow(frac[-1], MOD-2, MOD)\nfor i in range(1, num):\n  finv[num-1-i] = finv[num-i] * (num-i) % MOD\n  \nans = 1\nfor i in yaku:\n  ans = ans * frac[N+i-1] * finv[N-1] * finv[i] % MOD\n  \nprint(ans)\n", "import collections,sys\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\nN,M = LI()\nans = 1\ndef prime_factor(num):\n    prime_factor = collections.defaultdict(int)\n    for i in range(2,int(num**0.5)+1):\n        while num%i==0:\n            prime_factor[i] += 1\n            num //= i\n    if num>1:\n        prime_factor[num]=1\n    return prime_factor\ndef nCr(n,r,mod):\n    comb_count = 1\n    for i in range(r):\n        comb_count *= n-i\n        comb_count %= mod\n    for j in range(1,r+1):\n        comb_count *= pow(j,mod-2,mod)\n        comb_count %= mod\n    return comb_count\nfor v in list(prime_factor(M).values()):\n    ans *= nCr(v+N-1,v,10**9+7)\n    ans %= 10**9+7\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\n\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\n\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef SI(): return input().split()\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n\nfrom math import ceil, floor, log2\nfrom collections import deque\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product\nfrom heapq import heapify, heappop, heappush\n\n\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(pow(n, 0.5))+1):\n        if n % i: continue\n        ex = 0\n        while n % i == 0:\n            n = n // i\n            ex += 1\n        res.append((i, ex))\n    if n != 1:\n        res.append((n, 1))\n    return res\n\ndef mcomb(n, k, mod):\n    def mfac(l, r, mod):\n        ans = l\n        for i in reversed(list(range(r, l))):\n            ans *= i\n            ans %= mod\n        return ans\n\n    A = mfac(n,n-k+1,mod)\n    B = mfac(k,1,mod)\n    # B = mpow(B,mod-2,mod)\n    B = pow(B, mod-2, mod)\n    return A * B % mod\n\ndef solve():\n    n, m = MI()\n    fact = prime_factorization(m)\n    if n == 1:\n        print((1))\n        return\n    # print(fact)\n    mod = 1000000007\n    ans = 1\n    for num, ex in fact:\n        # print(ex, mcomb(ex+n-2, n-1, mod))\n        ans *= mcomb(ex+n-1, n-1, mod) % mod\n    print((ans % mod))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "#!/usr/bin/env python3\n\nimport sys\nimport math\n# from string import ascii_lowercase, ascii_upper_case, ascii_letters, digits, hexdigits\n# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)\n# from operator import itemgetter              # itemgetter(1), itemgetter('key')\n# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()\n# from collections import defaultdict          # subclass of dict. defaultdict(facroty)\n# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)\n# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).\n# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).\n# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])\n# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]\n# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]\n# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])\n# from itertools import combinations, combinations_with_replacement\n# from itertools import accumulate             # accumulate(iter[, f])\n# from functools import reduce                 # reduce(f, iter[, init])\n# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)\n# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).\n# from copy import deepcopy                    # to copy multi-dimentional matrix without reference\n# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)\n\n\ndef main():\n    mod = 1000000007                # 10^9+7\n    inf = float('inf')              # sys.float_info.max = 1.79...e+308\n    # inf = 2 ** 64 - 1               # (for fast JIT compile in PyPy) 1.84...e+19\n    sys.setrecursionlimit(10**6)    # 1000 -> 1000000\n    def input(): return sys.stdin.readline().rstrip()\n    def ii():    return int(input())\n    def mi():    return list(map(int, input().split()))\n    def mi_0():  return [int(x)-1 for x in input().split()]\n    def lmi():   return list(map(int, input().split()))\n    def lmi_0(): return list([int(x)-1 for x in input().split()])\n    def li():    return list(input())\n    \n        \n    class Eratos:\n        def __init__(self, num):\n            assert(num >= 1)\n            self.table_max = num\n            # self.table[i] \u306f i \u304c\u7d20\u6570\u304b\u3069\u3046\u304b\u3092\u793a\u3059 (bool)\n            self.table = [False if i == 0 or i == 1 else True for i in range(num+1)]\n            for i in range(2, int(math.sqrt(num)) + 1):\n                if self.table[i]:\n                    for j in range(i ** 2, num + 1, i):    # i**2 \u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3059\u308b\u3053\u3068\u3067\u5b9a\u6570\u500d\u9ad8\u901f\u5316\u3067\u304d\u308b\n                        self.table[j] = False\n            # self.table_max \u4ee5\u4e0b\u306e\u7d20\u6570\u3092\u5217\u6319\u3057\u305f\u30ea\u30b9\u30c8\n            self.prime_numbers = [2] if self.table_max >= 2 else []\n            for i in range(3, self.table_max + 1, 2):\n                if self.table[i]:\n                    self.prime_numbers.append(i)\n        \n        def is_prime(self, num):\n            \"\"\"\n            >>> e = Eratos(100)\n            >>> [i for i in range(1, 101) if e.is_prime(i)]\n            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n            \"\"\"\n            assert(num >= 1)\n            if num > self.table_max:\n                raise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))\n            return self.table[num]\n        \n        def prime_factorize(self, num):\n            \"\"\"\n            >>> e = Eratos(10000)\n            >>> e.prime_factorize(6552)\n            {2: 3, 3: 2, 7: 1, 13: 1}\n            \"\"\"\n            assert(num >= 1)\n            if int(math.sqrt(num)) > self.table_max:\n                raise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))\n            factorized_dict = dict()    # \u7d20\u56e0\u6570\u5206\u89e3\u306e\u7d50\u679c\u3092\u8a18\u9332\u3059\u308b\u8f9e\u66f8\n            candidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]\n            # n \u306b\u3064\u3044\u3066\u3001\u221an \u4ee5\u4e0b\u306e\u7d20\u6570\u3067\u5272\u308a\u7d9a\u3051\u308b\u3068\u6700\u5f8c\u306b\u306f 1 or \u7d20\u6570\u3068\u306a\u308b\n            # \u80cc\u7406\u6cd5\u3092\u8003\u3048\u308c\u3070\u81ea\u660e (\u6b8b\u3055\u308c\u305f\u6570\u304c \u221an \u3088\u308a\u4e0a\u306e\u7d20\u6570\u306e\u7a4d\u3067\u3042\u308b\u3068\u4eee\u5b9a\u3002\u3053\u308c\u306f\u81ea\u660e\u306b n \u3092\u8d85\u3048\u308b\u305f\u3081\u77db\u76fe)\n            for p in candidate_prime_numbers:\n                # \u3053\u308c\u4ee5\u4e0a\u8abf\u67fb\u306f\u7121\u610f\u5473\n                if num == 1:\n                    break\n                while num % p == 0:\n                    num //= p\n                    try:\n                        factorized_dict[p]\n                    except KeyError:\n                        factorized_dict[p] = 0\n                    finally:\n                        factorized_dict[p] += 1\n            if num != 1:\n                factorized_dict[num] = 1\n            return factorized_dict\n    \n\n    n, m = mi()\n    eratos = Eratos(max(int(math.sqrt(m)), n))\n    d = eratos.prime_factorize(m)\n    # print(d)\n\n    FACT = [1] * (n + int(math.log2(m)) + 1)\n    for i in range(2, n + int(math.log2(m)) + 1):\n        FACT[i] = (FACT[i-1] * i) % mod\n    \n    def comb(n, r, m):\n        numerator = FACT[n]\n        denominator = pow(FACT[n-r] * FACT[r], m - 2, m)\n        return (numerator * denominator) % m\n\n    ans = 1\n    for _, k in list(d.items()):\n        ans = (ans * comb(k + n - 1, k, mod)) % mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nMOD=10**9+7\nn,m=map(int,input().split())\nc = Counter(prime_factorize(m))\ncv=list(c.values())\nans=1\nfor i in cv:\n    for j in range(i):\n        ans*=i+n-1-j\n        ans%=MOD\n        ans*=pow(1+j,MOD-2,MOD)\n        ans%=MOD\nprint(ans)", "#!/usr/bin/env python3\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\nMOD = 10**9+7\nclass Factorial:\n    def __init__(self, n, mod):\n        # O(n + log mod)\n        self.f = f =[0] * (n + 1)\n        f[0] = b = 1\n        for i in range(1, n + 1):\n            f[i] = b = b * i % mod\n        self.inv = inv = [0] * (n + 1)\n        inv[n] = b = modinv(self.f[n], mod) # pow(self.f[n], -1, mod) \u304c Google Colab, Python ver. \u304c\u4f4e\u304f Error\n        for i in range(n, 0, -1):\n            inv[i - 1] = b = b * i % mod\n        self.mod = mod\n    \n    def __call__(self, n, k):  # self.C() \u3068\u540c\u3058\n        return self.C(n, k)\n\n    def factorial(self, i):\n        return self.f[i]\n\n    def ifactorial(self, i):\n        return self.inv[i]\n\n    def C(self, n, k):\n        if not 0 <= k <= n: return 0\n        return self.f[n] * self.inv[n - k] * self.inv[k] % self.mod\n\n    def P(self, n, k):\n        if not 0 <= k <= n: return 0\n        return self.f[n] * self.inv[n - k] % self.mod\n\n    def H(self, n, k):\n        if (n == 0 and k > 0) or k < 0: return 0\n        return self.f[n + k - 1] * self.inv[k] % self.mod * self.inv[n - 1] % self.mod\n\ndef factorize(n) -> list:\n    b, e = 2, 0\n    fct = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            e += 1\n        if e:\n            fct += (b, e), # b,\n        b += 1\n        e = 0\n    if n > 1:\n        fct += (n, 1), # n,\n    return fct\n\nn, m = map(int, input().split())\nF = Factorial(n + 30, MOD)\nc = 1\nfor _, E in factorize(m):\n    c = c * F.H(n, E) % MOD\nprint(c)", "# coding: utf-8\nimport sys\nimport numpy as np\nfrom collections import Counter\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n# \u7d20\u56e0\u6570\u5206\u89e3\u3092\u3057\u3066\u3001\u305d\u308c\u305e\u308c\u306e\u56e0\u6570\u3092\u3069\u3053\u306b\u5165\u308c\u308b\u304b\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 5 + 100  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\ndef prime_factorize(n): # N\u306e\u7d20\u56e0\u6570\u5206\u89e3\n    A = []\n    while n % 2 == 0:\n        A.append(2); n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            A.append(f); n //= f\n        else:\n            f += 2\n    if n != 1:\n        A.append(n)\n    return A\n\nN, M = lr()\nprimes = prime_factorize(M)\ncounter = Counter(primes)\nanswer = 1\nfor v in list(counter.values()):\n    cases = cmb(N-1+v, v)\n    answer *= cases\n    answer %= MOD\n\nprint((answer % MOD))\n# np.int64\u3068int\u578b\u306e\u9055\u3044\u306b\u6ce8\u610f\n# 16\n", "from collections import Counter  # N : \u7d20\u56e0\u6570\u5206\u89e3\n\nMOD = 10**9 + 7\n\n\ndef comb(n, r):\n    r = r if n-r <= r else n-r\n    a = 1\n    for x in list(range(r + 1, n + 1)):\n        a *= x % MOD\n    b = 1\n    for x in list(range(1, n - r + 1)):\n        b *= x % MOD\n    return (a // b)\n\n\nN, M = [int(s) for s in input().split()]\nprime_factor = []\nfor i in range(2,int(M**0.5)+1):\n    while M%i == 0:\n        prime_factor.append(i)\n        M/=i\nif M > 1:\n    prime_factor.append(M)\n    \nc = Counter(prime_factor)\n\nresult = 1\n\nfor b in list(c.values()):\n    result *= comb(b+N-1, b) % MOD\n\n\nprint((result % MOD))\n", "N, M = map(int, input().split())\nmod = pow(10, 9) + 7\n\ndef comb(n, k):\n  if k > n-k:\n    return comb(n, n-k)\n  mul, div = 1, 1\n  for i in range(k):\n    mul = mul * (n-i) % mod\n    div = div * (k-i) % mod\n  ret = mul * pow(div, mod-2, mod) % mod\n  return ret\n\ni = 2\nans = 1\ntmp = M\nwhile i * i <= M:\n  if tmp % i == 0:\n    cnt = 0\n    while tmp % i == 0:\n      tmp //= i\n      cnt += 1\n    ans = ans * comb(cnt+N-1, N-1) % mod\n  i += 1\nif tmp != 1:\n  ans = ans * comb(1+N-1, N-1) % mod\nprint(ans)", "MOD=10**9+7\nUPPERLIMIT=2*10**5\nMODMUL=[1, 1]+[0]*(UPPERLIMIT-1)\nfor i in range(2, UPPERLIMIT+1):\n  MODMUL[i]=MODMUL[i-1]*i%MOD\nMODDIV=[1]*UPPERLIMIT+[pow(MODMUL[-1], MOD-2, MOD)]\nfor i in range(UPPERLIMIT, 0, -1):\n  MODDIV[i-1]=MODDIV[i]*i%MOD\ndef MODCOMB(n, r):\n  return (((MODMUL[n]*MODDIV[r])%MOD)*MODDIV[n-r])%MOD\n\nN, M=map(int, input().split())\n\nfrom collections import defaultdict\ndef PrimeFactorization(x):\n  out=defaultdict(int)\n  for i in range(2, int(pow(x, 1/2))+1):\n    while x%i==0:\n      out[i]+=1\n      x//=i\n  if x>1:\n    out[x]+=1\n  return out\n\nprimenums=PrimeFactorization(M)\nans=1\nfor x in primenums.values():\n  ans*=MODCOMB(N+x-1, N-1)\n  ans%=MOD\n  \nprint(ans)", "n, m = map(int, input().split())\n\nmod = 10 ** 9 + 7\nN = 200000\n\n#\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv_t = [0]+[1]\nfor i in range(2, N):\n  inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]\n\n#\u968e\u4e57\u8a08\u7b97\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n\tkai.append(kai[-1] * i % mod)\n\trev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n, r):\n\treturn kai[n] * rev_kai[r] * rev_kai[n-r] % mod\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nans = 1\n\nfor _, cnt in factorization(m):\n    if _ == 1:\n        break\n    ans = ans * cmb(cnt + n - 1, n - 1) % mod\n\nprint(ans)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**6#float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\n\t\t\n#\u968e\u4e57#\nlim = 2*10**5   #\u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u529b\nfact = [1] * (lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n * fact[n-1] % mod\n\n#\u968e\u4e57\u306e\u9006\u5143#\nfact_inv = [1]*(lim+1)\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n\tfact_inv[n-1] = n*fact_inv[n]%mod\n\ndef C(n, r):\n\treturn (fact[n]*fact_inv[r]%mod)*fact_inv[n-r]%mod\n\n\n#\u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n\tarr = []\n\ttmp = n\n\tfor i in range(2, int(-(-n**0.5//1))+1):\n\t\tif tmp%i == 0:\n\t\t\tcnt = 0\n\t\t\twhile tmp%i == 0:\n\t\t\t\tcnt += 1\n\t\t\t\ttmp //= i\n\t\t\tarr.append([i, cnt])\n\tif tmp != 1:\n\t\tarr.append([tmp, 1])\n\tif arr == []:\n\t\tarr.append([n, 1])\n\treturn arr\n\n\nN, M = MAP()\nif M == 1:\n\tprint((1))\n\treturn\n\narr = factorization(M)\nans = 1\nfor g, n in arr:\n\tans *= C(N-1+n, n)\n\tans %= mod\n\nprint(ans)\n", "N,M=map(int,input().split())\nmod=10**9+7\n \ndef nCmMOD(A,B,Mod):\n    num,den=1,1\n    for i in range(B):\n        num*=(A-i)\n        den*=(i+1)\n        num%=Mod\n        den%=Mod\n    return (num*pow(den,Mod-2,Mod))%Mod\n \ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n \nans=1\nF=factorization(M)\nfor i in range(len(F)):\n    f=F[i][1]\n    ans*=nCmMOD(f+N-1,N-1,mod)\n    ans%=mod\n \nif M==1:\n    print(1)\nelse:\n    print(ans)", "def factorize(n):\n    '''\n    \u7d20\u56e0\u6570\u5206\u89e3\u3092\u3059\u308b\u3002\n    \u30bf\u30d7\u30eb\u306e\u914d\u5217\u306b\u3057\u3088\u3046\u3068\u601d\u3063\u305f\u3051\u3069\u3001\u9010\u6b21\u5272\u308a\u7b97\u3059\u308b\u904e\u7a0b\u3067\u6b21\u6570\u3092\u5897\u3084\u305b\u306a\u3044\u3058\u3083\u3093\u3002\n    \u4e8c\u91cd\u914d\u5217?\n    dict\u306b\u3057\u3088\u3046\u3002\n    '''\n    if n == 1:\n        raise('n >= 2')\n    \n    factor = {}\n    div = 2\n    while True:\n        if div * div > n:\n            factor[n] = factor.get(n, 0) + 1\n            return factor\n\n        if n % div == 0:\n            n //= div\n            factor[div] = factor.get(div, 0) + 1\n        else:\n            div += 1\n\n\n\n\nn, m = list(map(int, input().split()))\n\nif m == 1:\n    print((1))\n    return\n\nfactor = factorize(m)\n\n\nmax_len = n + 100  # \u9069\u5b9c\u5909\u66f4\u3059\u308b\nmod = 10**9 + 7\n\n\ndef modinv(x):\n    '''\n    x\u306e\u9006\u5143\u3092\u6c42\u3081\u308b\u3002\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u3088\u308a\u3001 x \u306e\u9006\u5143\u306f x ^ (mod - 2) \u306b\u7b49\u3057\u3044\u3002\u8a08\u7b97\u6642\u9593\u306fO(log(mod))\u7a0b\u5ea6\u3002\n    Python\u6a19\u6e96\u306epow\u306f\u5272\u3063\u305f\u4f59\u308a\u3092\u51fa\u3059\u3053\u3068\u3082\u53ef\u80fd\u3002\n    '''\n    return pow(x, mod-2, mod)\n\n\n# \u4e8c\u9805\u4fc2\u6570\u306e\u5de6\u5074\u306e\u6570\u5b57\u306e\u6700\u5927\u5024\u3092 max_len\u3000\u3068\u3059\u308b\u3002n\u3068\u304b\u3060\u3068\u4ed6\u306e\u5909\u6570\u3068\u88ab\u308a\u305d\u3046\u306a\u306e\u3067\u3002\n# factori_table = [1, 1, 2, 6, 24, 120, ...] \u8981\u306f factori_table[n] = n!\n# \u8a08\u7b97\u6642\u9593\u306fO(max_len * log(mod))\nmodinv_table = [-1] * (max_len + 1)\nmodinv_table[0] = None  # \u4e07\u304c\u4e00\u4f7f\u3063\u3066\u3044\u305f\u3068\u304d\u306b\u3067\u304d\u308b\u3060\u3051\u65e9\u671f\u306b\u539f\u56e0\u7279\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u306e\u3067\u3001None\u306b\u3057\u3066\u304a\u304f\u3002\nfactori_table = [1] * (max_len + 1)\nfactori_inv_table = [1] * (max_len + 1)\nfor i in range(1, max_len + 1):\n    factori_table[i] = factori_table[i-1] * (i) % mod\n\nmodinv_table[1] = 1\nfor i in range(2, max_len + 1):\n    modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n    factori_inv_table[i] = factori_inv_table[i-1] * modinv_table[i] % mod\n\n\ndef binomial_coefficients(n, k):\n    '''\n    n! / (k! * (n-k)! )\n    0 <= k <= n\u3092\u6e80\u305f\u3055\u306a\u3044\u3068\u304d\u306f\u5909\u306a\u5024\u3092\u8fd4\u3057\u3066\u3057\u307e\u3046\u306e\u3067\u3001\u5148\u306bNone\u3092\u8fd4\u3059\u3053\u3068\u306b\u3059\u308b\u3002\n    \u5834\u5408\u306b\u3088\u3063\u3066\u306f0\u306e\u307b\u3046\u304c\u9069\u5207\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n    '''\n    if not 0 <= k <= n:\n        return None\n    return (factori_table[n] * factori_inv_table[k] * factori_inv_table[n-k]) % mod\n\n\nans = 1\nmod = 10**9 + 7\nfor prime, power in list(factor.items()):\n    # ans *= n H power = n+power-1 C power \n    ans *= binomial_coefficients(n+power-1, power)\n    ans %= mod\n\nprint(ans)\n", "#\u7d20\u56e0\u6570\u5206\u89e3\ndef soinsu_bunkai(m):\n    pf={}\n\n    for i in range(2,int(m**0.5)+1):\n        while m%i==0:\n            pf[i]=pf.get(i,0)+1\n            m//=i\n    if m>1:\n        pf[m]=1\n    return pf\n\n# \u7d44\u307f\u5408\u308f\u305b\u306e\u7dcf\u6570 p=10**9+7 \u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3092\u6c42\u3081\u308b Satoooh Blog 2020/02/27 4\u5206 \n\"\"\"n<10**7 , p \u306f\u7d20\u6570\"\"\"\ndef cmb(n, r, p):\n\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\n\n\n# \u521d\u671f\u5165\u529b\nfrom collections import Counter\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nmod =10**9 +7\np =mod\nN,M = map(int, input().split())\na =soinsu_bunkai(M)\nans =1\n\nn = 10 ** 6  # n \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\n#mod p \u306b\u304a\u3051\u308b n \u306e\u9006\u5143\u306e\u8a08\u7b97\nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nfor i in a.values():\n    x =cmb(N +i -1,i,mod)\n    ans *=x\nprint(ans %mod)", "MOD = 10**9 + 7\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % MOD\n            self.inv[i] = -self.inv[MOD % i] * (MOD // i) % MOD\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % MOD\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nN, M = list(map(int, input().split()))\ncomb = Combination(N + 100)\n\ndef primeCount(N):\n    R = int(N**(0.5)) + 1  # \u7d20\u6570\u306e\u7bc4\u56f2\n    primes = {}  # \u7d20\u6570\u306e\u30ea\u30b9\u30c8\n    n = N\n    for num in range(2, R):\n        primes[num] = 0\n        while n % num == 0:\n            n //= num\n            primes[num] += 1\n    if n > 1 :\n        primes[n] = 1\n    return { key : val for key, val in list(primes.items()) if val > 0}  # \u30d5\u30a3\u30eb\u30bf\u30fc\u3092\u304b\u3051\u308b\n\nans = 1\nfor c in list(primeCount(M).values()):\n    ans *= comb.nhr(N, c)\n    ans %= MOD\nprint(ans)\n", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\ndef gen(n):\n    x = n\n    d = 2\n    cnt = 0\n    while x % d == 0:\n        x //= d\n        cnt += 1\n    yield cnt\n\n    d = 3\n    while d * d <= n:\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        yield cnt\n        d += 2\n\n    if x > 1:\n        yield 1\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M = list(map(int, input().split()))\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n    ans = 1\n    for cnt in gen(M):\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\nN,M=map(int,input().split())\nmod = 10**9+7\n\nfactorial=[1 for i in range(10**6)]\nfor i in range(2,10**6):\n    factorial[i] = factorial[i-1]*i % mod\n\ndef comb(n,k):\n    return (factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod))%mod\n\ndef factorize(n):\n    out=[]\n    i = 2\n    while 1:\n        if n%i==0:\n            out.append(i)\n            n //= i\n        else:\n            i += 1\n        if n == 1:break\n        if i > int(n**.5+3):\n            out.append(n)\n            break\n    \n    return out\n  \nc = Counter(factorize(M))\n\nans = 1\nfor k in c.keys():\n  ans *= comb(c[k]+N-1,N-1)\n  ans %= mod\n  \nprint(ans)", "mod1,mod2=10**9+7,998244353\nmod=mod1\nn,m=map(int,input().split())\nmod=10**9+7\nfact=[1]*(n+50+1)\ninv=[1]*(n+50+1)\nfor i in range(2,n+50+1):\n    fact[i]=i*fact[i-1]%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(n+50,1,-1):\n    inv[i-1]=inv[i]*i%mod\ndef comb(x,y):return fact[x]*inv[y]%mod*inv[x-y]%mod if x>=y>=0 else 0\nfrom math import floor,sqrt\nans=1\nfor i in  range(2,floor(sqrt(m))+1):\n    if m%i:continue\n    cnt=0\n    while m%i==0:\n        cnt+=1\n        m//=i\n    ans=ans*comb(n-1+cnt,cnt)%mod\nif m!=1:\n    ans=ans*comb(n,1)%mod\nprint(ans)", "import math\nfrom collections import defaultdict\nN, M = list(map(int, input().split(' ')))\nif M == 1:\n    print(1)  # a_i = 1 for all i\n    return\n# prime factorization of M\nfact = defaultdict(int)\nfor i in range(2, int(math.sqrt(M) + 1)):\n    while M % i == 0:\n        M //= i\n        fact[i] += 1\nif M != 1:\n    # M is prime\n    fact[M] = 1\n# calculate answer\nanswer = 1\nmod = 10**9 + 7\nfor f in fact.values():\n    # calc combination(f + N - 1, f) = (f + N - 1) * ... * N / f!\n    numerator = 1\n    denominator = 1\n    for i in range(f):\n        numerator *= (N + i)\n        denominator *= (i + 1)\n    answer *= (numerator // denominator)\n    answer %= mod\nprint(answer)", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\nclass FermatCmb:\n    \"\"\"\u30d5\u30a7\u30eb\u30de\u30fc\u5c0f\u5b9a\u7406\u3092\u4f7f\u7528\u3057\u305f\u9806\u5217, \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\"\"\"\n\n    def __init__(self, max_num, mod):\n        \"\"\"\n        :param max_num: max n of nCk\n        :param mod: any prime number\n        \"\"\"\n        self.max_num = max_num\n        self.mod = mod\n        self.fact = [0 for _ in range(max_num + 1)]\n        self.factinv = [0 for _ in range(max_num + 1)]\n\n        self.fact[0] = 1\n        for i in range(1, max_num + 1):\n            self.fact[i] = (i * self.fact[i - 1]) % self.mod\n\n        self.factinv[-1] = pow(self.fact[-1], mod - 2, mod)\n        for i in range(max_num, 0, -1):\n            self.factinv[i - 1] = self.factinv[i] * i\n            self.factinv[i - 1] %= self.mod\n\n    def nCk(self, n, k):\n        return (self.fact[n] * self.factinv[k] * self.factinv[n - k]) % self.mod\n\n    def nPk(self, n, k):\n        return (self.fact[n] * self.factinv[n - k]) % self.mod\n\n\ndef prime_factorization(x):\n    \"\"\"\u7d20\u56e0\u6570\u5206\u89e3\"\"\"\n    import math\n    re = []\n    i = 2\n    while x != 1:\n        if x % i == 0:\n            re.append(i)\n            x //= i\n        else:\n            i += 1\n            if i > math.sqrt(x):\n                re.append(x)\n                break\n    return re\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, M):\n    mod = 10 ** 9 + 7\n    pf = prime_factorization(M)\n    pf_map = {}\n    for p in pf:\n        pf_map.setdefault(p, 0)\n        pf_map[p] += 1\n    fc = FermatCmb(N + max(list(pf_map.values()) + [1]), mod)\n\n    ans = 1\n    for p in list(pf_map.values()):\n        ans *= fc.nCk(p + N - 1, p)\n        ans %= mod\n\n    print(ans)\n\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    solve(N, M)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # while True:\n    #     N, M = randint(1, 100), randint(1,100)\n    #     print(N, M)\n    #     solve(N, M)\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 8)\nMOD = 10 ** 9 + 7\ndef Z(): return int(input())\ndef ZZ(): return [int(_) for _ in input().split()]\n\ndef main():\n    N, M = ZZ()\n    MAX_E = 50\n\n    fact = [1] * (N+MAX_E+1) # fact[n] = n!\n    ifact = [1] * (N+MAX_E+1)\n\n    for i in range(1, N+MAX_E+1):\n        fact[i] = i * fact[i-1]\n        fact[i] %= MOD\n    ifact[N+MAX_E] = pow(fact[N+MAX_E], MOD-2, MOD)\n    for i in range(N+MAX_E)[::-1]: ifact[i] = ((i+1) * ifact[i+1]) % MOD\n\n    def combination(n, r):\n        if r < 0 or r > n: return 0\n        return (fact[n] * ifact[n-r] * ifact[r]) % MOD\n\n    def prime_factor(num):\n        i = 2\n        ret = []\n        while i*i <= num:\n            if num%i != 0:\n                i += 1\n                continue\n            cc = 0\n            while num%i == 0:\n                num //= i\n                cc += 1\n            ret.append([i, cc])\n            i += 1\n        if num != 1: ret.append([num, 1])\n        return ret\n\n    ps = prime_factor(M)\n    ans = 1\n    for p, e in ps:\n        ans *= combination(N + e - 1, N - 1)\n        ans %= MOD\n    print(ans)\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\n# N\u306e\u7d20\u56e0\u6570\u5206\u89e3\u3092\u8f9e\u66f8\u3067\u8fd4\u3059\ndef prime_fact(n):\n    root = int(math.sqrt(n))\n    prime_dict = {}\n    for i in range(2, root+1):\n        cnt = 0\n        while n % i == 0:\n            cnt += 1\n            n = n // i\n        if cnt:\n            prime_dict[i] = cnt\n    if n != 1:\n        prime_dict[n] = 1\n    return prime_dict\n\n\ndef combination_mod_initialize(n, MOD=10**9+7):\n    fac = [1]*(n+1)\n    inv = [1]*(n+1)\n    for i in range(1, n+1):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = inv[i-1] * pow(i, -1, MOD) % MOD\n    return fac, inv\n\n# \u4e8c\u9805\u4fc2\u6570\u3000\u9ad8\u901f\ndef combination_mod(n, r, fac, inv, mod=10**9+7):\n    return fac[n] * inv[r] * inv[n-r]\n\n\ndef main():\n    N, M = NMI()\n    PD = prime_fact(M)\n    ans = 1\n    fac, inv = combination_mod_initialize(10**6, MOD)\n\n    for x in list(PD.values()):\n        ans = ans * combination_mod(N+x-1, N-1, fac, inv) % MOD\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10**9 + 7\nMOD_t_MAX = 3 * (10**5)\n\nfac  = [None] * MOD_t_MAX\nfinv = [None] * MOD_t_MAX\ninv  = [None] * MOD_t_MAX\ndef MOD_COM_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MOD_t_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\ndef MOD_COM(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef main():\n    n, m = map(int, input().split())\n    MOD_COM_init()\n    dic = {}\n    x = 2\n    while m%x == 0:\n        if x in dic:\n            dic[x] += 1\n        else:\n            dic[x] = 1\n        m //= x\n    x = 3\n    while x*x <= m:\n        while m%x == 0:\n            if x in dic:\n                dic[x] += 1\n            else:\n                dic[x] = 1\n            m //= x\n        x += 2\n    if 1 < m:\n        if m in dic:\n            dic[m] += 1\n        else:\n            dic[m] = 1\n    ans = 1\n    for v in dic.values():\n        ans *= MOD_COM(n+v-1, v)\n        ans %= MOD\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\ndef fac(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\ndef com(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nfrom operator import mul\nfrom functools import reduce\n\ndef cmb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1,r + 1)))\n    return over // under\nans = 1\na,b = list(map(int,input().split()))\nl = fac(b)\nfor i in l:\n  ans *= cmb(i[1]+a-1,a-1)\n  ans = ans % (10**9 + 7)\nif b == 1:\n  print((1))\nelse:\n  print(ans)\n\n  \n", "n, m = list(map(int, input().split()))\nmod = 10**9+7\nmodp = mod\nmax_n = 10 ** 6 + 1               # \u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1] + [0]*max_n     # fact[n] = (n! mod modp)\nfactinv = [1, 1] + [0]*max_n  # factinv[n] = ((n!)^(-1) mod modp)\ninv = [0, 1] + [0]*max_n      # factinv \u8a08\u7b97\u7528\n\ndef cmb(n, r, p):\n    assert n < p, 'n is less than modp'\n    assert n < max_n, 'n in less than max_n'\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return (fact[n] * (factinv[r] * factinv[n-r])%p) % p\n\nfor i in range(2, max_n + 1):\n    fact[i] = (fact[i-1] * i) % modp\n    inv[i] = (-inv[modp % i] * (modp // i)) % modp\n    factinv[i] = (factinv[i-1] * inv[i]) % modp\n\ndef factorization(m):\n    arr = []\n    temp = m\n    # \u4e00\u65e6\u8ca0\u306b\u3059\u308b\u3068ceil\u3068\u540c\u3058\u6319\u52d5\u3068\u306a\u308b\u3002//1\u306ffloat\u3092\u8fd4\u3059\u306e\u3067int\u304c\u5fc5\u8981\n    for i in range(2, int(-(-m**0.5//1))+1):\n        if temp%i==0:\n            cnt = 0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    \n    if temp!=1:\n        arr.append([temp, 1])\n    \n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\narr = factorization(m)\n\nans = 1\nfor k, v in arr:\n    temp = cmb(v+n-1, n-1, mod)\n    ans = (ans * temp) % mod\nif m == 1:\n    print((1))\nelse:\n    print(ans)\n\n", "MOD = 10**9+7\nn, m = list(map(int, input().split()))\n\n\ndef factorization(n):\n    retval = []\n    tmp = n\n    for i in range(2, int(-(-n**.5//1))+1):\n        if tmp % i == 0:\n            cnt = 0\n            while tmp % i == 0:\n                cnt += 1\n                tmp //= i\n            retval.append((i, cnt))\n    if tmp != 1:\n        retval.append((tmp, 1))\n    return retval\n\n\ndef com(n, r):\n    X = Y = 1\n    if n-r < r:\n        r = n-r\n    for i in range(1, r+1):\n        Y = Y*i % MOD\n        X = X*(n-i+1) % MOD\n    Y = pow(Y, MOD-2, MOD)\n    return X*Y\n\n\nfact = factorization(m)\nans = 1\nfor x, p in fact:\n    ans *= com(n+p-1, n-1)\nprint((ans % MOD))\n", "from collections import defaultdict\n\n\ndef comb(n, k, mod=10 ** 9 + 7):\n    denominator = 1\n    numerator = 1\n    for i in range(1, k + 1):\n        denominator = denominator * i % mod\n    for i in range(n - k + 1, n + 1):\n        numerator = numerator * i % mod\n    return numerator * pow(denominator, mod - 2, mod) % mod\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    factorization = defaultdict(int)\n    while not m % 2:\n        factorization[2] += 1\n        m //= 2\n    f = 3\n    while f * f <= m:\n        if not m % f:\n            factorization[f] += 1\n            m //= f\n        else:\n            f += 2\n    if m != 1:\n        factorization[m] += 1\n    ans = 1\n    mod = 10 ** 9 + 7\n    for _, c in list(factorization.items()):\n        ans *= comb(c + n - 1, c, mod)\n        ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef factorization(n):\n    prime = []\n    num = n\n    p = 2\n    while p * p <= n:\n        cnt = 0\n        while num % p == 0:\n            cnt += 1\n            num //= p\n        prime.append((p, cnt))\n        p += 1\n    if num != 1:\n        prime.append((num, 1))\n    if not prime:\n        prime.append((n, 1))\n         \n    return prime\n\ndef nCr(n, r, mod):\n    a, b = 1, 1\n    for i in range(r):\n        a = a * (n - i) % mod\n        b = b * (i + 1) % mod\n    \n    return a * pow(b, mod - 2, mod) % mod\n\ndef Main():\n    n, m = read_ints()\n    prime = factorization(m)\n    ans = 1\n    for p, num in prime:\n        ans *= nCr(num + n - 1, num, MOD)\n        ans %= MOD\n    \n    if m == 1:\n        print(1)\n    else:\n        print(ans)\n\ndef __starting_point():\n    Main()\n__starting_point()", "import math\n#import numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,m = list(map(int,ipt().split()))\n    d = dict()\n    mod = 10**9+7\n    p = primes(m)\n    for i in p:\n        t = 0\n        while True:\n            if m%i == 0:\n                m //= i\n                t += 1\n            else:\n                break\n        if t > 0:\n            d[i] = t\n        if i > m:\n            break\n    if m > 1:\n        d[m] = 1\n    ans = 1\n\n    #nCr\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\u3002N\u306b\u6700\u5927\u5024\u3092\u5165\u308c\u3066\u4f7f\u7528\u3002\n    N = 10**5+1000\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n    def cmb(n,r,mod):\n        if r<0 or r>n :\n            return 0\n        r = min(r,n-r)\n        return g1[n]*g2[r]*g2[n-r]%mod\n    for i in range(2,N+1):\n        g1.append((g1[-1]*i)%mod)\n        inverse.append((-inverse[mod % i]*(mod//i))%mod)\n        g2.append((g2[-1]*inverse[-1])%mod)\n\n    for i in list(d.values()):\n        ans = (ans*cmb(n-1+i,i,mod))%mod\n\n    print(ans)\n\n    return\n\n#\u221an\u307e\u3067\u306e\u7d20\u6570\u306e\u914d\u5217\u3092\u8fd4\u3059\u95a2\u6570\ndef primes(n):\n    if n < 4:\n        return []\n    else:\n        pri = [2]\n        k = 3\n        while k*k <= n:\n            for i in pri:\n                if k%i == 0:\n                    break\n                elif i == pri[-1]:\n                    pri.append(k)\n            k += 2\n        return pri\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nN, M = list(map(int, input().split()))\n\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n\n    if arr == [] and n != 1:\n        arr.append([n, 1])\n\n    return arr\n\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, 2*10**5 + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\nprimes = factorization(M)\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\nans = 1\n\nfor p, cnt in primes:\n    tmp = cmb(N+cnt-1, N-1, mod)\n    ans *= tmp\n    ans %= mod\n\nprint(ans)\n", "from collections import Counter\nfrom functools import reduce\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\ndef pow_k(x, n):\n    if n == 0:\n        return 1\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K = (K * x)\n        x = (x * x)\n        n //= 2\n    return (K * x)\ndef xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a // b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0\ndef modinv(a, m):\n    g, x, y = xgcd(a, m)\n    return x % m\ndef modmul(a,b):\n    return a * b % 1000000007\ndef comb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(modmul, range(n, n - r, -1))\n    under = reduce(modmul, range(1,r + 1))\n    return over * modinv(under, 1000000007)\n\nN,M = (int(x) for x in input().split())\nans = 1\nif M == 1:\n    print('1')\nelse:\n    a = Counter(prime_factorize(M))\n    for x in a.values():\n        ans = ans * comb(N+x-1,x) % 1000000007\n    print(ans)", "import math\nN, M = list(map(int, input().split()))\n\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n\n    if arr == [] and n != 1:\n        arr.append([n, 1])\n\n    return arr\n\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range(2, N*2 + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\nprimes = factorization(M)\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\nif N == 1:\n    print((1))\n    return\nans = 1\n\nfor p, cnt in primes:\n    tmp = cmb(N+cnt-1, N-1, mod)\n    ans *= tmp\n    ans %= mod\n\nprint(ans)\n", "P = 10**9 + 7\n\ndef modpow(a, n):\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modpow(a, n // 2)**2) % P\n    else:\n        return (a * modpow(a, n // 2)**2) % P\n\ndef inv(a):\n    return modpow(a, P - 2)\n\nfac = [1]*(2*10**5)\nfor i in range(1, 2*10**5):\n    fac[i] = (i * fac[i - 1]) % P\n\nprimes = []\ncheck = [False]*10**5\nfor p in range(2, 10**5):\n    if check[p]:\n        continue\n    primes.append(p)\n    for j in range((10**5 - 1) // p + 1):\n        check[p * j] = True\n\ndef pf(M):\n    ans = {}\n    for p in primes:\n        e = 0\n        while M % p == 0:\n            M //= p\n            e += 1\n        if e > 0:\n            ans[p] = e\n    if M > 1:\n        ans[M] = 1\n    return ans\n\nN, M = map(int, input().split())\npfM = pf(M)\n\nans = 1\nfor p in pfM:\n    e = pfM[p]\n    dup = (fac[e + N - 1] * inv(fac[e]) * inv(fac[N - 1])) % P\n    ans = (ans * dup) % P\nprint(ans)", "def factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nfrom scipy.special import comb\nn, m = map(int, input().split())\na = factorization(m)\nM = 10**9 + 7\n\nans = 1\nif m == 1:\n    print(1)\n    return\nfor i in a:\n    ans *= comb(n, i[1], exact=True, repetition=True)\n    ans = ans%M\nprint(ans)", "N,M = map(int,input().split())\nans = int(M**0.5+10)*[N-1]\nmod = 10**9+7\np = 2\nO = M\n\nwhile p<=O**0.5:\n  if M%p == 0:\n    M = M//p\n    ans[p] += 1\n  else:\n    p+=1\n    \nif M!=1:\n  ans[-1]+=1\n\nout = 1\nfor r in ans:\n  hoge = 1\n  for i in range(min(N-1,r-N+1)):\n    hoge*=r-i\n    hoge//=i+1\n  out*=hoge\n  out%=mod\n\nprint(out)", "N,M=map(int,input().split())\nMOD=10**9+7\n \ndef cmb(n, r, p):\n  numerator = 1\n  for i in range(n-r+1, n+1):\n    numerator = numerator * i % p\n  denominator = 1\n  for j in range(1, r+1):\n    denominator = denominator * j % p\n  denominator = pow(denominator, p-2, p)\n  return (numerator * denominator)%p\n \ndef factorization(n):\n  l = []\n  t = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if t%i==0:\n      cnt=0\n      while t%i==0:\n        cnt+=1\n        t //= i\n      l.append([i, cnt])\n  if t!=1:\n    l.append([t, 1])\n  if l==[]:\n    l.append([n, 1])\n  return l\n \nans=1\nF=factorization(M)\nfor i in range(len(F)):\n  f=F[i][1]\n  ans*=cmb(f+N-1,f,MOD)\n  ans%=MOD\n\nif M==1:\n  print(1)\nelse:\n  print(ans)", "MOD = 10**9 + 7\nclass mint:\n    def __init__(self, i):\n        self.i = i\n    def __add__(self, m):\n        t = self.i + (m.i if isinstance(m, mint) else m)\n        if t > MOD:\n            t -= MOD\n        return mint(t)\n    def __radd__(self, m):\n        t = self.i + (m.i if isinstance(m, mint) else m)\n        if t > MOD:\n            t -= MOD\n        return mint(t)\n    def __mul__(self, m):\n        return mint(self.i * (m.i if isinstance(m, mint) else m) % MOD)\n    def __sub__(self, m):\n        t = self.i - (m.i if isinstance(m, mint) else (m % MOD))\n        if t < 0:\n            t += MOD\n        return mint(t)\n    def __pow__(self, m):\n        i = self.i\n        return mint(pow(i, m, MOD))\n    def __truediv__(self, m):\n        return mint(self.i * pow(m, MOD - 2, MOD) % MOD)\n    def __repr__(self):\n        return repr(self.i)\n\nfact_range = 10**6\nfacts = [1] * (fact_range + 1)\nfor i in range(0, fact_range):\n    facts[i+1] = facts[i] * (i + 1) % MOD\n\nifacts = [1] * (fact_range + 1)\nifacts[fact_range] = pow(facts[fact_range], MOD - 2, MOD)\nfor i in range(fact_range, 0, -1):\n    ifacts[i-1] = ifacts[i] * i % MOD\n\ndef comb(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return facts[n] * ifacts[n-k] % MOD * ifacts[k] % MOD\n\nn, m = list(map(int, input().split()))\nd = []\np = 2\nwhile p < 10 ** 5:\n    cnt = 0\n    while m % p == 0:\n        m //= p\n        cnt += 1\n    if cnt > 0:\n        d.append(cnt)\n    p += 1\nif m > 1:\n    d.append(1)\nans = mint(1)\nfor c in d:\n    ans *= comb(n - 1 + c, c)\nprint(ans)\n", "from collections import defaultdict\n\ndef prime_factors(n):\n    d = defaultdict(int)\n    while n%2 == 0:\n        d[2] += 1\n        n //= 2\n    i = 3\n    while i*i <= n:\n        while n%i == 0:\n            d[i] += 1\n            n //= i\n        i += 2\n    if n > 2:\n        d[n] += 1\n    return d\n\n# Combination\nMOD = 10**9+7\nMAX = 2*10**5\nfac = [1,1] + [0]*MAX\nfinv = [1,1] + [0]*MAX\ninv = [0,1] + [0]*MAX\nfor i in range(2,MAX+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nN, M = list(map(int, input().split()))\nans = 1\npf = prime_factors(M)\nfor k,v in list(pf.items()):\n    ans *= comb(v+N-1, N-1)\n    ans %= MOD\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\n\n\nMOD = 1000000007  # type: int\n\n\ndef factor(n: int):\n    i = 2\n    cnt = 0\n    while n % i == 0:\n        n //= i\n        cnt += 1\n    if cnt > 0:\n        yield i, cnt\n\n    i = 3\n    while i * i <= n:\n        cnt = 0\n        while n % i == 0:\n            n //= i\n            cnt += 1\n        if cnt > 0:\n            yield i, cnt\n        i += 2\n\n    if n > 1:\n        yield n, 1\n\n\ndef comb(n: int, r: int):\n    if n - r < r:\n        return comb(n, n - r)\n    ans = 1\n    for i in range(r):\n        ans *= n - i\n    for i in range(r):\n        ans //= i + 1\n    return ans\n\n\ndef solve(N: int, M: int):\n    ans = 1\n    for _p, cnt in factor(M):\n        ans *= comb(N - 1 + cnt, cnt) % MOD\n        ans %= MOD\n    print(ans)\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    solve(N, M)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\nclass Counting():\n    def __init__(self,maxim,mod):\n        maxim += 1\n\n        self.mod = mod\n        self.fact = [0]*maxim\n        self.fact[0] = 1\n        for i in range(1,maxim):\n            self.fact[i] = self.fact[i-1] * i % mod\n\n        self.invfact = [0]*maxim\n        self.invfact[maxim-1] = pow(self.fact[maxim-1],mod-2,mod)\n        for i in reversed(range(maxim-1)):\n            self.invfact[i] = self.invfact[i+1] * (i+1) % mod\n\n\n    def nCk(self,n,r):\n        if n < 0 or n < r: return 0\n        return self.fact[n] * self.invfact[r] * self.invfact[n-r] % self.mod\n\n    def nPk(self,n,r):\n        if n < 0 or n < r: return 0\n        return self.fact[n] * self.invfact[n-r] % self.mod\n\n        \n\ndef main():\n    N,M=mi()\n    MOD=10**9+7\n\n    if N == 1:\n        print(1)\n        return\n    \n    def prime_factorize(n):\n        P = []\n        P_set = set()\n        while n % 2 == 0:\n            P.append(2)\n            P_set.add(2)\n            n //= 2\n        f = 3\n        while f * f <= n:\n            if n % f == 0:\n                P.append(f)\n                P_set.add(f)\n                n //= f\n            else:\n                f += 2\n        if n != 1:\n            P.append(n)\n            P_set.add(n)\n\n        P_count = {p:0 for p in P_set}\n        for p in P: P_count[p] += 1\n\n        return P_count\n\n\n    \n    ans = 1\n    counting = Counting(3*10**5+10,MOD)\n    for p,e in prime_factorize(M).items():\n        ans *= counting.nCk(e+N-1,e)\n        ans %= MOD\n\n    \n    print(ans % MOD)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    N, M = list(map(int, input().split()))\n\n    def factorization(n):\n        arr = []\n        temp = n\n        for i in range(2, int(-(-n**0.5//1))+1):\n            if temp % i == 0:\n                cnt = 0\n                while temp % i == 0:\n                    cnt += 1\n                    temp //= i\n                arr.append([i, cnt])\n        if temp != 1:\n            arr.append([temp, 1])\n\n        if arr == [] and n != 1:\n            arr.append([n, 1])\n\n        return arr\n\n    mod = 10**9 + 7\n\n    def cmb(n, r, mod):\n        if (r < 0 or r > n):\n            return 0\n        r = min(r, n-r)\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N+100 + 1):\n        g1.append((g1[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n    primes = factorization(M)\n    # \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\n    ans = 1\n\n    for p, cnt in primes:\n        tmp = cmb(N+cnt-1, N-1, mod)\n        ans *= tmp\n        ans %= mod\n\n    print(ans)\n\n\nmain()\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10 ** 9 + 7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef primeFactorization(n):\n    ans = []\n    temp = n\n    while temp%2 == 0:\n        ans.append(2)\n        temp //= 2\n    for i in range(3, int(n**0.5)+1, 2):\n        while temp%i == 0:\n            ans.append(i)\n            temp //= i\n    if temp > 1:\n        ans.append(temp)\n    return collections.Counter(ans)\n\ndef combMod(n, r, p):\n    numer = 1\n    denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n-r+i) % p\n        denom = denom * i % p\n    return numer * pow(denom, p-2, p) % p\n\ndef resolve():\n    N, M = LI()\n\n    pf = primeFactorization(M)\n    # \u7d20\u56e0\u6570\u3054\u3068\u306b\u3001N\u500b\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u3069\u3046\u632f\u308a\u5206\u3051\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b\n    ans = 1\n    for i in list(pf.values()):\n        ans *= combMod(i + N - 1, i, MOD)        \n        ans %= MOD\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def prime_factor(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp != 1:\n        arr.append([temp, 1])\n    if arr == []:\n        arr.append([n, 1])\n    return arr\n\n\nMOD = 10**9+7\nlim = 200000\ninv_t = [-1 for i in range(lim+1)]\nfactrial = [-1 for i in range(lim+1)]\nfactrial_inv = [-1 for i in range(lim+1)]\n\n\ndef set_inv(max=lim):\n    inv_t[0] = 0\n    for i in range(1, max):\n        inv_t[i] == mod_inv(i)\n\n\ndef mod_inv(x, mod=MOD):\n    y, u, v, _x = mod, 1, 0, x\n    while y:\n        t = _x//y\n        _x -= t*y\n        _x, y = y, _x\n        u -= t*v\n        u, v = v, u\n    u %= mod\n    if u < 0:\n        u += mod\n    return u\n\n\ndef mod_pow(a, n, mod=MOD):\n    res = 1\n    while n:\n        if n & 1:\n            res = res*a % mod\n        a = a*a % mod\n        n >>= 1\n    return res\n\n\ndef set_factrial(max=lim, mod=MOD):\n    c = 1\n    factrial[0] = factrial_inv[0] = 1\n    for i in range(1, max):\n        c *= i\n        c %= mod\n        factrial[i] = c\n        factrial_inv[i] = mod_inv(c, mod)\n\n\ndef comb(a, b, mod=MOD):\n    if factrial[0] == -1:\n        set_factrial()\n    return (factrial[a]*factrial_inv[b]*factrial_inv[a-b]) % mod\n\n\nn, m = [int(_) for _ in input().split()]\nans = 1\nfor p, e in prime_factor(m):\n    ans *= comb(n-1+e, e)\n    ans %= MOD\nif m==1:\n    ans=1\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(pow(n, 0.5))+1):\n        if n % i: continue\n        ex = 0\n        while n % i == 0:\n            n = n // i\n            ex += 1\n        res.append((i, ex))\n    if n != 1:\n        res.append((n, 1))\n    return res\n\ndef mcomb(n, k, mod):\n    def mfac(l, r, mod):\n        ans = l\n        for i in reversed(list(range(r, l))):\n            ans *= i\n            ans %= mod\n        return ans\n\n    A = mfac(n, n-k+1, mod)\n    B = mfac(k, 1, mod)\n    # B = mpow(B,mod-2,mod)\n    B = pow(B, mod-2, mod)\n    return A * B % mod\n\ndef solve():\n    N, M = MI()\n    fact = prime_factorization(M)\n    MOD = 1000000007\n\n    if N == 1:\n        print((1))\n        return\n\n    ans = 1\n    for num, ex in fact:\n        ans = ans * mcomb(ex+N-1, N-1, MOD)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\ndef factorization(n):\n    primen, degree, primend = [], [], []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            primen.append(i)\n            degree.append(cnt)\n            primend.append([i,cnt])\n    if temp!=1:\n        primen.append(temp)\n        degree.append(1)\n        primend.append([temp,1])\n    if primen==[]:\n        primen.append(n)\n        degree.append(1)\n        primend.append([n,1])\n    return degree\n#    return primen,degree\n\n\ndef main():\n    N, M = map(int, input().split())\n    if M == 1:\n        print(1)\n    else:\n        mod = 10**9+7               # mod\u7d20\u6570\n        Mf = factorization(M)\n        l = max(Mf)\n        Comb=[1]*(l+1)\n        for i in range(1,l+1):\n            tmp = Comb[i-1]\n            tmp *= N-1+i\n            tmp *= pow(i, mod-2, mod)\n            Comb[i] = tmp%mod\n        ret = 1\n        for i in Mf:\n            ret *= Comb[i]\n            ret %= mod\n        print(ret)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\n\nn, m = map(int, input().split())\n\nprime_list = defaultdict(int)\np = 2\nwhile p <= 10**4.5+5:\n    if m%p == 0:\n        prime_list[p] += 1\n        m //= p\n    else:\n        p += 1\n\nif m > 1:\n    prime_list[m] += 1\n\nMOD=10**9+7\n\ndef comb(n, r): \n    if r<0 or r>n: \n        return 0\n    r=min(r, n-r)\n    res=1\n    for i in range(r): \n        res=res*(n-i)%MOD*pow(i+1, MOD-2, MOD)%MOD\n    return res\n\nans = 1\nfor k in prime_list.keys():\n    ans *= comb(prime_list[k]+n-1, prime_list[k])\n    ans %= MOD\n\nprint(ans)", "from collections import defaultdict\n\n\ndef factorize(n):\n    facts = defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        facts[2] += 1\n    m = 3\n    while m * m <= n:\n        while n % m == 0:\n            facts[m] += 1\n            n //= m\n        m += 2\n    if 1 < n:\n        facts[n] += 1\n    return facts\n\n\nMOD = 10 ** 9 + 7  # should be a prime number\nMAX = 10 ** 5 + 100\nFACTS = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    FACTS[i] = FACTS[i - 1] * i % MOD\nFACTINVS = [1] * (MAX + 1)\nINVS = [1] * (MAX + 1)\nfor i in range(2, MAX + 1):\n    q, r = divmod(MOD, i)\n    INVS[i] = -INVS[r] * q % MOD\n    FACTINVS[i] = FACTINVS[i - 1] * INVS[i] % MOD\n\n\ndef nCr(n, r):\n    return FACTS[n] * FACTINVS[r] * FACTINVS[n - r]\n\n\nN, M = map(int, input().split())\nfactors = factorize(M)\nans = 1\nfor p, e in factors.items():\n    ans = ans * nCr(N - 1 + e, e) % MOD\nprint(ans)", "def factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n  \nn,m = map(int,input().split())\nchk = factorization(m)\n\ndef make_array_for_comb(N, mod=10**9+7):\n    fact = [1,1]\n    fact_inv = [1,1]\n    inv = [0,1]\n    for i in range(2, N+1):\n        fact.append((fact[-1]*i) % mod)\n        inv.append((-inv[mod%i] * (mod//i)) % mod)\n        fact_inv.append((fact_inv[-1]*inv[i]) % mod)\n    return fact, fact_inv\n\ndef comb(n, r, mod=10**9+7):\n  if (r < 0) or (n < r):\n      return 0\n  r = min(r, n - r)\n  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n\nmod = 10**9+7\nans = 1\nfor i in chk:\n  fact, fact_inv = make_array_for_comb(i[1]+n-1,mod)\n  ans *= comb(i[1]+n-1,i[1],mod)\n  ans %= mod\nif m == 1:\n  ans = 1\nprint(ans)", "MOD = 10 ** 9 + 7\n\nN, M = list(map(int, input().split()))\n\ndef factoring(k): #k\u3092\u56e0\u6570\u5206\u89e3\u3057\u3001\u7d20\u56e0\u6570\u3068\u305d\u306e\u500b\u6570\u3092\u8f9e\u66f8\u306b\u5165\u308c\u3066\u8fd4\u3059\u3002\n    import math\n    dic = dict()\n    n = int(math.sqrt(k))+2\n    for i in range(2, n):\n        count = 0\n        while k%i == 0:\n            count += 1\n            k = k//i\n        if count != 0:\n            dic[i] = count\n    if k != 1: #sqrt(k)\u307e\u3067\u30c1\u30a7\u30c3\u30af\u3057\u3066\u3082k\u304c1\u306b\u306a\u3063\u3066\u3044\u306a\u3044 --> k\u304c\u7d20\u56e0\u6570\n        dic[k] = 1\n    return dic\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\n\n\nC = Factorial(N + 100, MOD).comb\n\nans = 1\ndic = factoring(M)\nfor tmp in dic:\n    # print (tmp, dic[tmp])\n    ans *= C(dic[tmp] + N - 1, dic[tmp])\n    ans %= MOD\n\nprint (ans)\n\n\n", "n,m=map(int,input().split())\np = 10**9+7\n\ndef pfact(m):\n\tpf = {}\n\tfor i in range(2,int(m**0.5)+1):\n\t\twhile m%i==0:\n\t\t\tpf[i]=pf.get(i,0)+1\n\t\t\tm//=i\n\tif m>1:pf[m]=1\n\treturn pf\n\n\ndef cmb(n, r, p):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn fact[n] * factinv[r] * factinv[n - r] % p\n\nN = 3 * 10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N + 1):\n\tfact.append((fact[-1] * i) % p)\n\tinv.append((-inv[p % i] * (p // i)) % p)\n\tfactinv.append((factinv[-1] * inv[-1]) % p)\n\n#\u30c6\u30f3\u30d7\u30ec\u7d42\u308f\u308a\n\nif m == 1:\n\tprint(1)\n\treturn\n\nfactlist = pfact(m).values()\n\nans = 1\n\nfor i in factlist:\n\tans = ans * cmb(i+n-1,i,p) % p\n\nprint(ans % p)", "from collections import Counter\nfrom functools import reduce\nimport operator\nproduct = lambda it: reduce(operator.mul,it,1)\n\ndef comb(n, max_k, mod):\n    \"\"\"\n    (n,k) := n\u500b\u304b\u3089k\u500b\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n    k = 0~max_K\u307e\u3067\u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059\n    \"\"\"\n    res = [1]*(max_k+1)\n    t = 1\n    for i in range(max_k+1):\n        res[i] *= t\n        t *= n-i\n        t %= mod\n\n    n = reduce(lambda x,y: (x*y)%mod, range(1,max_k+1), 1)\n    n = pow(n, mod-2, mod)\n\n    for i in reversed(range(max_k+1)):\n        res[i] *= n\n        res[i] %= mod\n        n *= i\n        n %= mod\n    return res\n\n# \u7d20\u56e0\u6570\u5206\u89e3\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            yield i\n    if n > 1:\n        yield n\n\nMOD = 10**9+7\nN,M = map(int,input().split())\n\nfactors = Counter(prime_factors(M))\n\nres = 1\n\nfor c in factors.values():\n    res *= comb(N-1+c,c,MOD)[-1]\n    res %= MOD\n\nprint(res)", "#!/usr/bin/env python3\n\nfrom collections import Counter\nfrom scipy.special import comb\n\nn, m = list(map(int, input().split()))\nmod = 10**9+7\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\nc = Counter(prime_factorize(m))\n\nans = 1\nfor key, value in list(c.items()):\n    ans *= comb(value+n-1, value, exact=True) % mod\nprint((ans % mod))\n", "N, M = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n# \u7d20\u56e0\u6570\u5206\u89e3 O(\u221aN)\n\n\ndef prime_decomposition(n):\n    i = 2\n    prime2exponent = {}  # key:prime --> value:its exponent\n    while i*i <= n:\n        while n % i == 0:\n            n //= i\n            if i in prime2exponent:\n                prime2exponent[i] += 1\n            else:\n                prime2exponent[i] = 1\n        i += 1\n    if n > 1:\n        if n in prime2exponent:\n            prime2exponent[n] += 1\n        else:\n            prime2exponent[n] = 1\n    return prime2exponent\n\n\nclass Combination:\n    \"\"\"\n  O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n  n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n  \u4f7f\u7528\u4f8b\uff1a\n  comb = Combination(1000000)\n  print(comb(5, 3))  # 10\n  \"\"\"\n\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * \\\n                modinv[self.mod % i] % self.mod\n        return modinv\n\n\ncomb = Combination(1000000)\npd = prime_decomposition(M)\nans = 1\nfor v in list(pd.values()):\n    c = comb(N + v - 1, N-1)\n    ans = ans * c % MOD\nprint(ans)\n", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N, M = list(map(int, input().split()))\n\n    def decom(n) -> list:  # \u6050\u3089\u304f\u56e0\u6570\u5206\u89e3\u304cTLE\u306e\u539f\u56e0->1/2\u4e57\u3067\u6253\u3061\u5207\u308a\n        ret = []\n\n        x = n\n        d = 2\n        cnt = 0\n        while x % d == 0:\n            x //= d\n            cnt += 1\n        ret.append(cnt)\n\n        d = 3\n        while d * d <= n:\n            cnt = 0\n            while x % d == 0:\n                x //= d\n                cnt += 1\n            ret.append(cnt)\n            d += 2\n\n        if x > 1:\n            ret.append(1)\n\n        return ret\n\n    dlis = decom(M)\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n    ans = 1\n    for cnt in dlis:\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "MOD = 10**9+7\n\nN, M = map(int, input().split())\n\nprimes = [0]\nwhile M % 2 == 0:\n    primes[0] += 1\n    M //= 2\n\nif M != 1:\n    for i in range(3, int(M**0.5+1), 2):\n        if M % i == 0:\n            primes.append(0)\n            while M % i == 0:\n                primes[-1] += 1\n                M //= i\n            if M == 1:\n                break\n    else:\n        primes.append(1)\n\n#combinations[p] = p+N-1 C N-1\ncombinations = [1]\n\np_max = max(primes)\nfor p in range(1, p_max+1):\n    combinations.append( combinations[-1] * (p+N-1) * pow(p, MOD-2, MOD) % MOD )\n\nans = 1\nfor p in primes:\n    ans *= combinations[p]\n    ans %= MOD\n\nprint(ans)", "from collections import Counter\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\ndef main():\n    N, M = map(int, input().split())\n\n    MOD = 10**9 + 7\n    \n\n    MAX_N = 5 * (10 ** 5)\n    # comb init\n    fac = [0] *  MAX_N\n    finv = [0] *  MAX_N \n    inv = [0] *  MAX_N\n\n    fac[0] = 1; fac[1] = 1\n    finv[0] = 1; finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2, MAX_N):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = -inv[MOD%i] * (MOD//i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n    \n    def COM(n, k):\n        if n < k : return 0\n        if n < 0 or k < 0 : return 0\n        return (fac[n] * finv[n-k] % MOD) * finv[k] % MOD\n\n    \n    pf = prime_factorize(M)\n    pc = Counter(pf)\n\n    ans = 1\n    for _, val in pc.items():\n        ans *= COM(val + N - 1, N - 1)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#\u7d20\u56e0\u6570\u5206\u89e3\u3057\u3066\u5217\u6319\u3059\u308b\u95a2\u6570\u3001\u7d04\u6570\u5217\u6319\u3067\u306f\u306a\u3044\uff01\nfrom collections import Counter\ndef factorize(n):\n    b = 2\n    fct = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            fct.append(b)\n        b = b + 1\n    if n > 1:\n        fct.append(n)\n    fct = Counter(fct)\n    return fct\n\nmod = 10**9+7\ndef comb_mod(n,r,mod):\n    ans = 1\n    for i in range(r):\n        ans *= n-i\n        ans %= mod\n    for i in range(1,r+1):\n        ans *= pow(i,mod-2,mod)\n        ans %= mod\n    return ans\n\nN, M = map(int, input().split())\nfact = factorize(M)\nans = 1\nfor k in fact.values():\n    ans *= comb_mod(k+N-1,k,mod)\n    ans %= mod\nprint(ans)", "def prime_factor(n):\n    if n == 1:\n        return [[1, 0]]\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp != 1:\n        arr.append([temp, 1])\n    if arr == []:\n        arr.append([n, 1])\n    return arr\n\n\nMOD = 10**9+7\nlim = 200000\ninv_t = [-1 for i in range(lim+1)]\nfactrial = [-1 for i in range(lim+1)]\nfactrial_inv = [-1 for i in range(lim+1)]\n\n\ndef set_inv(max=lim):\n    inv_t[0] = 0\n    for i in range(1, max):\n        inv_t[i] == mod_inv(i)\n\n\ndef mod_inv(x, mod=MOD):\n    y, u, v, _x = mod, 1, 0, x\n    while y:\n        t = _x//y\n        _x -= t*y\n        _x, y = y, _x\n        u -= t*v\n        u, v = v, u\n    u %= mod\n    if u < 0:\n        u += mod\n    return u\n\n\ndef mod_pow(a, n, mod=MOD):\n    res = 1\n    while n:\n        if n & 1:\n            res = res*a % mod\n        a = a*a % mod\n        n >>= 1\n    return res\n\n\ndef set_factrial(max=lim, mod=MOD):\n    c = 1\n    factrial[0] = factrial_inv[0] = 1\n    for i in range(1, max):\n        c *= i\n        c %= mod\n        factrial[i] = c\n        factrial_inv[i] = mod_inv(c, mod)\n\n\ndef comb(a, b, mod=MOD):\n    if factrial[0] == -1:\n        set_factrial()\n    return (factrial[a]*factrial_inv[b]*factrial_inv[a-b]) % mod\n\n\nn, m = [int(_) for _ in input().split()]\nans = 1\nfor p, e in prime_factor(m):\n    ans *= comb(n-1+e, e)\n    ans %= MOD\nprint(ans)\n", "'''h2d5\n\u30dd\u30a4\u30f3\u30c8\u306f\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\uff08\u4ed5\u5207\u308a\u3068\u4e2d\u8eab\uff09\u3068\u7d20\u56e0\u6570\u56e0\u6570\u5206\u89e3\nN+\u7d20\u56e0\u6570\u5206\u89e3\u306e\u6307\u6570-1\u304b\u3089\u6307\u6570\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\uff08\u6307\u6570-1\u304c\u4ed5\u5207\u308a\u306e\u679a\u6570\uff09\nnPr=n!/(n-r)!   \nnCr=n!/(n-r)!*r!=(n*(n-1)*...*(n-r+1))/r!(\u5206\u5b50\u5206\u6bcd\u306f\u5171\u306b\uff52\u500b)\n'''\nimport math\nMOD=10**9+7\n\ndef comb(n,r):\n  nPr=1\n  fact_r=1\n  for i in range(r):\n    nPr*=n-i\n    fact_r*=r-i\n  return nPr//fact_r\n\nN,M=map(int,input().split())\nfact={}\nfor i in range(2,int(math.sqrt(M))+1):\n  if M==1:\n    break\n  while(M%i==0):#\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\n    M//=i\n    if not i in fact:#\u7d20\u56e0\u6570\u304c\u306a\u3051\u308c\u3070\u8ffd\u52a0\n      fact[i]=1\n    else:#\u7d20\u56e0\u6570\u304c\u3042\u308c\u3070\u5897\u52a0\n      fact[i]+=1  \nif M!=1:#\u7d20\u6570\u306e\u30b1\u30fc\u30b9\n  fact[M]=1\n  \nanswer=1\nfor r in fact.values():\n  answer*=comb(N+r-1,r)#\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n  answer%=MOD\n  \nprint(answer)", "\ndef resolve():\n    # nCk = n! / n!(n-k)! \u306e\u30c6\u30fc\u30d6\u30eb\u4f5c\u6210\n    def COMinit(n, MOD):\n        fact = [1, 1]\n        fact_inv = [1, 1]\n        inv = [0, 1]\n        for i in range(2, n + 1):\n            fact.append((fact[-1] * i) % MOD)\n            inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n            fact_inv.append((fact_inv[-1] * inv[i]) % MOD)\n        return fact, fact_inv\n\n    # \u4e8c\u9805\u4fc2\u6570\u8a08\u7b97\n    def Combination(n, k, MOD=10 ** 9 + 7):\n        fac, finv = COMinit(n, MOD)\n        if n < k: return 0\n        if n < 0 or k < 0: return 0\n        ret = fac[n] * finv[k] * finv[n - k] % MOD\n        return ret\n\n    #\u6307\u6570:exponent\n    def dic_factorization(n):\n        arr = []\n        temp = n\n        for i in range(2, int(-(-n ** 0.5 // 1)) + 1):\n            if temp % i == 0:\n                cnt = 0\n                while temp % i == 0:\n                    cnt += 1\n                    temp //= i\n                arr.append([i, cnt])\n        if temp != 1:\n            arr.append([temp, 1])\n        if arr == []:\n            arr.append([n, 1])\n        return arr\n\n    MOD = 10**9+7\n    N, M = map(int, input().split())\n    if M==1:\n        print(1)\n        return\n    \n    fact = dic_factorization(M)\n    ans = 1\n    for v in fact:\n        ans *= Combination(N+v[1]-1, v[1])\n        ans %= MOD\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "N, M = map(int, input().split())\n\nimport math\n\ndef prime_fac(n):\n  p_lis = []\n  temp = n\n\n  for i in range(2, int(math.sqrt(n)) + 1):\n    if temp % i == 0:\n      cnt = 0\n      while temp % i == 0:\n        cnt += 1\n        temp //= i\n      p_lis.append([i, cnt])\n  if temp != 1:\n    p_lis.append([temp, 1])\n  if p_lis == []:\n    p_lis.append([n, 1])\n\n  return p_lis\n\nmod = 10 ** 9 + 7\nMAX = N + 50\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\ndef comb(n, r):\n  if n < r:\n    return 0\n  else:\n    return fac[n] * ( finv[r] * finv[n-r] % mod ) % mod\n \nfor i in range(2, MAX + 1):\n  fac.append( ( fac[-1] * i ) % mod )\n  inv.append( mod - ( inv[mod % i] * (mod // i) % mod ) )\n  finv.append( finv[-1] * inv[-1]  % mod )\n\nans = 1\n\nfor p, a in prime_fac(M):\n  if a == p == 1:\n    break\n  ans *= comb(N+a-1, a)\n  ans %= mod\n\nprint(ans)", "def nCr(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nsize = 10**6 # size >= n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n \nfor i in range( 2, size + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n \ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append(cnt)\n \n    if temp!=1:\n        arr.append(1)\n \n    return arr\n \nN, M = map(int,input().split())\nL = factorization(M)\n \nans = 1\n \nfor i in L:\n    ans *= nCr(i+N-1,N-1,mod)\n    ans %= mod\n \nprint(ans)", "import collections\nimport math\nfrom operator import mul\nfrom functools import reduce\nN,M = list(map(int,input().split()))\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\ndef combinations_count(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, list(range(n, n - r, -1)), 1)\n    denom = reduce(mul, list(range(1, r + 1)), 1)\n    return numer // denom\n\nc = collections.Counter(prime_factorize(M))\nprimeFactorizeList = list(c.values())\nanswer = 1\nfor i in primeFactorizeList:\n    answer *= combinations_count(i+N-1, i)\n    answer = answer % (10 ** 9 + 7)\nprint((int(answer)))\n", "import collections,sys\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\nN,M = LI()\nans = 1\ndef prime_factor(num):\n    prime_factor = collections.defaultdict(int)\n    for i in range(2,int(num**0.5)+1):\n        while num%i==0:\n            prime_factor[i] += 1\n            num //= i\n    if num>1:\n        prime_factor[num]=1\n    return prime_factor\ndef nCr(n,r,mod):\n    comb_count = 1\n    for i in range(r):\n        comb_count *= n-i\n        comb_count %= mod\n    for i in range(1,r+1):\n        comb_count *= pow(i,mod-2,mod)\n        comb_count %= mod\n    return comb_count\nfor v in list(prime_factor(M).values()):\n    ans *= nCr(v+N-1,v,10**9+7)\n    ans %= 10**9+7\nprint(ans)\n", "N, M = list(map(int, input().split()))\n\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n\n    if arr == [] and n != 1:\n        arr.append([n, 1])\n\n    return arr\n\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\nprimes = factorization(M)\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\nif N == 1:\n    print((1))\n    return\nans = 1\n\nfor p, cnt in primes:\n    tmp = 0\n    for i in range(1, min(cnt, N)+1):\n        tmp += cmb(N, i, mod) * cmb(cnt-1, i-1, mod)\n        #print(tmp, p, cnt, i)\n        tmp %= mod\n    ans *= tmp\n    ans %= mod\n\nprint(ans)\n", "def factorization(n):\n    arr = dict()\n    temp = n\n    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr[i] = cnt\n\n    if temp != 1:\n        arr[temp] = 1\n\n    if not arr and n != 1:\n        arr[n] = 1\n\n    return arr\n\n\nMOD = 10 ** 9 + 7\nMAX = 10 ** 5 + 50\nmodinv = lambda a, mod=10 ** 9 + 7: pow(a, mod - 2, mod)\nfac, inv = [1] * MAX, [1] * MAX\nfor i in range(1, MAX):\n    fac[i] = fac[i - 1] * i % MOD\n    inv[i] = modinv(fac[i])\ncomb = lambda n, k: fac[n] * inv[k] * inv[n - k] % MOD\n\nN, M = list(map(int, input().split()))\nans = 1\nfor v in list(factorization(M).values()):\n    ans = (ans * comb(N + v - 1, v) % MOD)\nprint(ans)\n", "mod=10**9+7\ndic={}\ndef ADD(x):\n\tif x in dic:\n\t\tdic[x]+=1\n\telse:\n\t\tdic[x]=1\nn,m=list(map(int,input().split()))\nfor i in range(2,int(m**0.5+2)):\n\twhile m%i==0:\n\t\tADD(i)\n\t\tm//=i\nif m>1:\n\tADD(m)\ndic=tuple(dic.values())\nans=1\nfac=[1]\nfor i in range(10**6):\n\tfac.append(fac[-1]*(i+1)%mod)\ndef c(a,b):\n\tr=pow(fac[b]*fac[a-b]%mod,mod-2,mod)\n\treturn fac[a]*r%mod\nfor x in dic:\n\tans*=c(x+n-1,x)\n\tans%=mod\nprint(ans)\n", "N,M=map(int,input().split())\nmod=10**9+7\n\ndef nCmMOD(A,B,Mod):\n    num,den=1,1\n    for i in range(B):\n        num*=(A-i)\n        den*=(i+1)\n        num%=Mod\n        den%=Mod\n    return (num*pow(den,Mod-2,Mod))%Mod\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nans=1\nF=factorization(M)\nfor i in range(len(F)):\n    f=F[i][1]\n    ans*=nCmMOD(f+N-1,f,mod)\n    ans%=mod\n\nif M==1:\n    print(1)\nelse:\n    print(ans)", "def prime_factorizarion(n):\n\tarr = []\n\ttemp = n\n\tfor i in range(2, int(n**0.5)+1):\n\t\tif temp%i==0:\n\t\t\tcnt=0\n\t\t\twhile temp%i==0:\n\t\t\t\tcnt+=1\n\t\t\t\ttemp//=i\n\t\t\tarr.append([i,cnt])\n\t\n\tif temp!=1:\n\t\tarr.append([temp,1])\n\t\n\tif arr==[]:\n\t\tarr.append([n,1])\n\t\n\treturn arr\n\ndef modInv(a,mod):\n    return pow(a,mod-2,mod)\n\ndef nCr(n,r,mod):\n    r=min(r,n-r)\n    if r==0:\n        return 1\n    if r==1:\n        return n\n    numer=1\n    denom=1\n    for i in range(r):\n        numer=(n-i)*numer%mod\n        denom=(i+1)*denom%mod\n    return numer*modInv(denom,mod)%mod\n\nmod=10**9+7\nN,M=map(int,input().split())\n\nif M==1:\n    print(1)\n    return\n\nprime_divisors=prime_factorizarion(M)\nans=1\nfor prime,num in prime_divisors:\n    ans=(ans*nCr(num+N-1,num,mod))%mod\nprint(ans)", "N, M = map(int, input().split())\n\nimport math\n\ndef prime_fac(n):\n  p_lis = []\n  temp = n\n\n  for i in range(2, int(math.sqrt(n)) + 1):\n    if temp % i == 0:\n      cnt = 0\n      while temp % i == 0:\n        cnt += 1\n        temp //= i\n      p_lis.append([i, cnt])\n  if temp != 1:\n    p_lis.append([temp, 1])\n  if p_lis == []:\n    p_lis.append([n, 1])\n\n  return p_lis\n\nmod = 10 ** 9 + 7\nMAX = 10 ** 6\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\ndef comb(n, r):\n  if n < r:\n    return 0\n  else:\n    return fac[n] * ( finv[r] * finv[n-r] % mod ) % mod\n \nfor i in range(2, MAX + 1):\n  fac.append( ( fac[-1] * i ) % mod )\n  inv.append( mod - ( inv[mod % i] * (mod // i) % mod ) )\n  finv.append( finv[-1] * inv[-1]  % mod )\n\nans = 1\n\nfor p, a in prime_fac(M):\n  if a == p == 1:\n    break\n  ans *= comb(N+a-1, a)\n  ans %= mod\n\nprint(ans)", "from math import floor, sqrt\nfrom collections import defaultdict\nN,M = map(int,input().split())\nd = defaultdict(int)\nfor i in range(2, floor(sqrt(M))+1):\n    while M % i == 0:\n        d[i] += 1\n        M //= i\nif M != 1:\n    d[M] += 1\ndef comb(n,k):\n    if k == 0:\n        return 1\n    return comb(n-1,k-1) * n // k\nans = 1\nfor e in d.values():\n    ans *= comb(N+e-1, e)\nprint(ans % (10**9+7))", "N,M = map(int,input().split())\nMOD = 10**9+7\n\nMAXN = N+100\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nfrom collections import Counter\ndef factorize(n):\n    d = Counter()\n    m = 2\n    while m*m <= n:\n        while n%m == 0:\n            n //= m\n            d[m] += 1\n        m += 1\n    if n > 1:\n        d[n] += 1\n    return d\n\nans = 1\nf = factorize(M)\nfor v in f.values():\n    c = comb(N+v-1, v)\n    ans *= c\n    ans %= MOD\nprint(ans)", "import sys\n\nMOD = 10 ** 9 + 7\n# MOD = 998244353\ndef make_tables(n=10 ** 9, r=2 * 10 ** 6, p=MOD):\n  fac = [None] * (r + 1); fac[0] = 1\n  for i in range(r): fac[i+1] = fac[i] * (i + 1) % p\n  ifac = [None] * (r + 1); ifac[r] = pow(fac[r], p - 2, p)\n  for i in range(r, 0, -1): ifac[i-1] = ifac[i] * i % p\n  n_choose = [None] * (r + 1); n_choose[0] = 1\n  for i in range(r): n_choose[i+1] = n_choose[i] * (n - i) % p\n  for i in range(r + 1): n_choose[i] = n_choose[i] * ifac[i] % p\n  return fac, ifac, n_choose\n\nfac, ifac, n_choose = make_tables()\n\ndef mod_choose(n, r, p=MOD):\n  if r > n or r < 0: return 0\n  return fac[n] * ifac[r] % p * ifac[n-r] % p\n\ndef nHr(n, r, p=MOD):\n  return fac[n-1+r] * ifac[n-1] % p * ifac[r] % p\n\ndef sieve_of_eratosthenes(n=10 ** 6):\n  sieve = [1] * (n + 1); sieve[0] = sieve[1] = 0\n  for i in range(2, int(n ** 0.5) + 1):\n    if not sieve[i]: continue\n    for j in range(i * 2, n + 1, i): sieve[j] = 0\n  prime_numbers = [i for i in range(2, n + 1) if sieve[i]]\n  return sieve, prime_numbers\n\nis_prime, prime_numbers = sieve_of_eratosthenes()\n\ndef prime_factorize(n):\n  res = dict()\n  if n < 2: return res\n  border = int(n ** 0.5)\n  for p in prime_numbers:\n    if p > border: break\n    while n % p == 0: res[p] = res.get(p, 0) + 1; n //= p\n    if n == 1: return res\n  res[n] = 1\n  return res\n\ndef prime_factorize_factorial(n):\n  res = dict()\n  for i in range(2, n + 1):\n    for p, c in prime_factorize(i).items(): res[p] = res.get(p, 0) + c\n  return res\n\nn, m = map(int, sys.stdin.readline().split())\n\ndef main():\n  res = 1\n  for p, c in prime_factorize(m).items():\n    res *= nHr(n, c)\n    res %= MOD \n  print(res)\n\ndef __starting_point():\n  main()\n__starting_point()", "#\u7d20\u56e0\u6570\u5206\u89e3\ndef soinsu_bunkai(m):\n    pf={}\n\n    for i in range(2,int(m**0.5)+1):\n        while m%i==0:\n            pf[i]=pf.get(i,0)+1\n            m//=i\n    if m>1:\n        pf[m]=1\n    return pf\n\n# \u7d44\u307f\u5408\u308f\u305b\u306e\u7dcf\u6570 p=10**9+7 \u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3092\u6c42\u3081\u308b Satoooh Blog 2020/02/27 4\u5206 \n\"\"\"n<10**7 , p \u306f\u7d20\u6570\"\"\"\ndef cmb(n, r, p):\n\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\n\n\n# \u521d\u671f\u5165\u529b\nfrom collections import Counter\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nmod =10**9 +7\np =mod\nN,M = map(int, input().split())\na =soinsu_bunkai(M)\nans =1\n\nn = 10 **5 +100  # n \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\n#mod p \u306b\u304a\u3051\u308b n \u306e\u9006\u5143\u306e\u8a08\u7b97\nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nfor i in a.values():\n    x =cmb(N +i -1,i,mod)\n    ans *=x\nprint(ans %mod)", "n,m=map(int,input().split())\nmod=pow(10,9)+7\nif m==1:\n  print(1)\n  return\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0:\n        cnt+=1\n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1:\n    arr.append([temp, 1])\n  if arr==[]:\n    arr.append([n, 1])\n  return arr\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u3001\u3055\u3089\u306b\u9ad8\u901f\u3002\u3042\u3089\u304b\u3058\u3081O(N)\u306e\u8a08\u7b97\u3092\u3059\u308b\u3053\u3068\u3067\u306e\u3061\u306e\u8a08\u7b97\u304c\u65e9\u304f\u306a\u308b\ndef cmb(n,r,mod):\n  if (r<0 or r>n):\n    return 0\n  r=min(r,n-r)\n  return g1[n]*g2[r]*g2[n-r]%mod\ng1=[1,1] \ng2=[1,1] \ninverse=[0,1]\nfor i in range(2,n+30+1):\n  g1.append((g1[-1]*i)%mod)\n  inverse.append((-inverse[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inverse[-1])%mod)\n\nl=factorization(m)\nans=1\nfor li in l:\n  b=li[1]\n  ans*=cmb(b+n-1,n-1,mod)\n  ans%=mod\nprint(ans)"]
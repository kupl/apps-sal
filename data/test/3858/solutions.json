["import sys\ninput = sys.stdin.readline\nfrom fractions import gcd\nfrom collections import Counter\n\n\"\"\"\n\u9069\u5f53\u306b\u90e8\u5206\u96c6\u5408X\u3092\u3068\u308a\u3001\u51f8\u5305 S \u3068\u3057\u3066\u3001S\u306b1\u70b9\u8a08\u4e0a\u3059\u308c\u3070\u3088\u3044\n\u3053\u308c\u3060\u30682^N\u70b9\u5f97\u3089\u308c\u308b\n\u305f\u3060\u3057\u3001\u51f8\u5305\u306e\u9762\u7a4d\u304c0\u3068\u306a\u308b\u5834\u5408\u304c\u4f8b\u5916\n\u7a7a\u96c6\u5408\u30011\u70b9\u306e\u5834\u5408\u3068\u3001\u7dda\u5206\u306e\u5834\u5408\u3092\u9664\u5916\u3059\u308b\n\n\"\"\"\n\nMOD = 998244353\nN = int(input())\nXY = [[int(x) for x in input().split()] for _ in range(N)]\n\nanswer = pow(2,N,MOD)\nanswer -= N + 1# \u7a7a\u30011\u70b9\nfor i,(x,y) in enumerate(XY):\n    # i \u3092\u9078\u3073\u3001i+1\u756a\u76ee\u4ee5\u4e0a\u306e\u3046\u3061\u3044\u304f\u3064\u304b\u3092\u9078\u3093\u3067\u7dda\u5206\u3068\u3059\u308b\n    pts = []\n    for x1, y1 in XY[i+1:]:\n        dx, dy = x1-x, y1-y\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        # \u6a19\u6e96\u5316\n        if dx < 0:\n            dx, dy = -dx, -dy\n        elif dx == 0:\n            dy = 1\n        pts.append((dx,dy))\n    c = Counter(pts)\n    for v in c.values():\n        answer -= pow(2,v,MOD) - 1\n\nanswer %= MOD\nprint(answer)", "import math\nmod = 998244353\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\npow2 = [1]\nfor i in range(n):\n    pow2.append(pow2[-1] * 2 % mod)\nused = [[False] * n for i in range(n)]\nret = (pow2[n] - 1 - n - n * (n - 1) / 2) % mod\nfor i in range(n):\n    for j in range(i):\n        if used[i][j]:\n            continue\n        inline = [i, j]\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            if (p[i][1] - p[k][1]) * (p[j][0] - p[k][0]) == (p[j][1] - p[k][1]) * (p[i][0] - p[k][0]):\n                inline.append(k)\n        for k in range(len(inline)):\n            for l in range(len(inline)):\n                used[inline[k]][inline[l]] = True\n        v = len(inline)\n        ret = (ret + mod - pow2[v] + 1 + v + v * (v - 1) // 2) % mod\nprint((int(ret)))\n", "#!/usr/bin/env python3\n\n\ndef main():\n\n    N = int(input())\n    points = []\n    for i in range(N):\n        points.append(list(map(int, input().split())))\n\n    x = [p[0] for p in points]\n    y = [p[1] for p in points]\n\n    M = 998244353\n\n    c = 1 + N + N * (N - 1) // 2\n    for i in range(N):\n        xi = x[i]\n        yi = y[i]\n        dx = [xj - xi for xj in x]\n        dy = [yj - yi for yj in y]\n\n        for j in range(i + 1, N):\n            xj = dx[j]\n            yj = dy[j]\n            cc = 1\n            for k in range(j + 1, N):\n                if xj * dy[k] - dx[k] * yj == 0:\n                    cc *= 2\n                    cc %= M\n            c += cc - 1\n\n    r = 1\n    for i in range(N):\n        r *= 2\n        r %= M\n\n    r -= c\n    r %= M\n\n    print(r)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import Counter\nfrom fractions import gcd\n\nn = int(input())\nxys = [tuple(map(int, input().split())) for _ in range(n)]\nMOD = 998244353\n\nexcludes = 0\nfor i, (x1, y1) in enumerate(xys):\n    slopes = []\n    for x2, y2 in xys[i + 1:]:\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0:\n            slopes.append(1j)\n        elif dy == 0:\n            slopes.append(1)\n        else:\n            m = gcd(dx, dy)\n            slopes.append(dx // m + dy // m * 1j)\n    for c in list(Counter(slopes).values()):\n        if c > 1:\n            excludes += 2 ** c - c - 1\n    excludes %= MOD\n\nprint(((pow(2, n, MOD) - excludes - (n * (n - 1) // 2) - n - 1) % MOD))\n", "def gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\ndef inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nH = defaultdict(lambda: 0)\nN = int(input())\ndot = [()]*N\nmod = 998244353\nfor i in range(N):\n    x, y = inpl()\n    dot[i] = (x, y)\nfor i in range(N):\n    for j in range(i+1,N):\n        x1, y1 = dot[i]\n        x2, y2 = dot[j]\n        A = y1 - y2\n        B = x2 - x1\n        C = y1*x2 - x1*y2\n        if A < 0:\n            A *= -1\n            B *= -1\n            C *= -1\n        gcdabc = gcd(gcd(A,B), C)\n        A //= gcdabc\n        B //= gcdabc\n        C //= gcdabc\n        H[(A, B, C)] += 1\nans = (2**N - N - 1 )%mod\nfor i in H.values():\n    i = int((1+(1+8*i)**(1/2))/2)\n    ans -= (2**i - i - 1)%mod\nprint(ans%mod)", "from collections import Counter\n\ndef __starting_point():\n    N = int(input())\n    xy_list = [list(map(int, input().split())) for _ in range(N)]\n\n    modulo_num = 998244353\n\n    duplicate_list = [0] * (N + 1)\n    for i in range(N):\n        xi, yi = xy_list[i]\n        gradient_list = []\n        for j in range(N):\n            xj, yj = xy_list[j]\n            if xi != xj:\n                gradient_list.append((yj - yi) / (xj - xi))\n            elif yi != yj:\n                gradient_list.append(100000)\n\n        counter = Counter(gradient_list)\n        for k in list(counter.values()):\n            duplicate_list[k + 1] += 1\n\n    ans = pow(2, N, modulo_num)\n    ans -= 1\n    ans -= N\n    for i in range(2, N + 1):\n        cnt = duplicate_list[i] // i\n        ans -= cnt * (pow(2, i, modulo_num) - i - 1)\n    ans = ans % modulo_num\n    print(ans)\n\n__starting_point()", "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nMOD = 998244353\n\nans = pow(2, N, MOD) - 1 - N\nu = set()\nfor i in range(N):\n    xi, yi = P[i]\n    for j in range(i+1, N):\n        xj, yj = P[j]\n        if (i, j) in u:\n            continue\n        cnt = 0\n        Q = {i, j}\n        for k in range(N):\n            xk, yk = P[k]\n            if (xj - xi)*(yk - yi) == (xk - xi)*(yj - yi):\n                cnt += 1\n                Q.add(k)\n        for p in Q:\n            for q in Q:\n                u.add((p, q))\n        ans -= pow(2, cnt, MOD) - cnt - 1\nprint(ans % MOD)", "from fractions import Fraction\nfrom collections import defaultdict\nfrom itertools import combinations\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\n\nN = int(input())\nXY = [list(map(int, input().split())) for i in range(N)]\n\nD = defaultdict(int)\nfor (x1, y1), (x2, y2) in combinations(XY, 2):\n    if x1 != x2:\n        a = Fraction(y2-y1, x2-x1)\n        b = Fraction(y1) - a * Fraction(x1)\n        D[(a, b)] += 1\n    else:\n        D[(None, x1)] += 1\n\nmod = 998244353\ncomb = Combination(N+1, mod)\nA = [0] * (N+1)\ncoA = [0] * (N+1)\nans = 0\nfor i in range(3, N+1):\n    ans += comb(N, i)\n    ans %= mod\nfor i in range(3, N+1):\n    for j in range(i-2):\n        A[i] += (i-2-j)*(1<<j)\n    coA[i] = coA[i-1]+A[i]\nfor (a, b), n in D.items():\n    if n==1:\n        continue\n    n = int((n<<1)**0.5)+1\n    ans -= coA[n]\n    ans %= mod\nprint(ans)", "from collections import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef red(a, b, c):\n    if a == 0 and b < 0: b, c = -b, -c\n    if a < 0: a, b, c = -a, -b, -c\n    g = gcd(a, gcd(abs(b), abs(c)))\n    return a // g, b // g, c // g\n\ndef main():\n    md = 998244353\n    n = int(input())\n    xy = LLI(n)\n    cnt_online = {}\n    # \u5404\uff12\u70b9\u3092\u7d50\u3076\u76f4\u7dda\u3092ax+by+c=0\u306e(a,b,c)\u3067\u8868\u3057\n    # \u5404\u76f4\u7dda\u4e0a\u306b\u3044\u304f\u3064\u306e\u70b9\u304c\u3042\u308b\u304b\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n    for i in range(n):\n        x0, y0 = xy[i]\n        counted = set()\n        for j in range(i):\n            x1, y1 = xy[j]\n            a = y0 - y1\n            b = x1 - x0\n            c = -a * x0 - b * y0\n            a, b, c = red(a, b, c)\n            if (a, b, c) in counted: continue\n            counted.add((a, b, c))\n            cnt_online.setdefault((a, b, c), 1)\n            cnt_online[(a, b, c)] += 1\n    # print(cnt_online)\n    # \u5404\u76f4\u7dda\u4e0a\u3067\u30012\u70b9\u4ee5\u4e0a\u3067\u591a\u89d2\u5f62\u304c\u3067\u304d\u306a\u3044\u70b9\u306e\u9078\u3073\u65b9\u3092\u6570\u3048\u308b\n    sum_online = 0\n    for plot_n in cnt_online.values():\n        sum_online += pow(2, plot_n, md) - 1 - plot_n\n        sum_online %= md\n    # \u3059\u3079\u3066\u306e2\u70b9\u4ee5\u4e0a\u306e\u9078\u3073\u65b9\u304b\u3089\u3001\u591a\u89d2\u5f62\u304c\u3067\u304d\u306a\u3044\u3082\u306e\u3092\u5f15\u304f\n    ans = pow(2, n, md) - 1 - n - sum_online\n    print(ans % md)\n\nmain()\n", "# E\nfrom collections import Counter\n\nN = int(input())\nxy_list = [list(map(int, input().split())) for _ in range(N)]\n\nM = 998244353\n\nres = pow(2, N, M)\n# 0 points\nres -= 1\n# 1 points\nres -= N\n\n# all lines\nline_cnt = [0]*(N+1)\n\nfor i in range(N):\n    xi, yi = xy_list[i]\n    angle_list = []\n    for j in range(N):\n        xj, yj = xy_list[j]\n        if xj != xi:\n            angle_list.append((yj-yi)/(xj-xi))\n        elif yj != yi:\n            angle_list.append(10000.0)\n        \n    # count points in same line\n    cnt_i = Counter(angle_list)\n    for k in cnt_i.values():\n        line_cnt[k+1] += 1\n\nfor i in range(2, N+1):\n    cnt = line_cnt[i] // i\n    res -= cnt*(pow(2, i, M)-i-1)\n\nres = res % M\nprint(res)", "import sys\nfrom collections import defaultdict\n\n# sys.stdin = open('e1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef solve():\n    def collinear(x0, y0, x1, y1):\n        return x0 * y1 == x1 * y0\n\n    def aligned(i, j, k):\n        return collinear(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i])\n\n    n = read_int()\n    mod = 998244353\n    res = pow(2, n, mod) - n - 1\n    x, y = list(zip(*[read_int_list() for i in range(n)]))\n    lines = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            a = y[i] - y[j]\n            b = x[j] - x[i]\n            g = gcd(a, b)\n            a //= g\n            b //= g\n            if a < 0 or (a == 0 and b < 0):\n                a, b = -a, -b\n            c = -(a * x[i] + b * y[i])\n            lines[(a, b, c)].add(i)\n            lines[(a, b, c)].add(j)\n    for k, v in list(lines.items()):\n        m = len(v)\n        res -= pow(2, m, mod) - m - 1\n    res %= mod\n    return res\n\n\ndef main():\n    res = solve()\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
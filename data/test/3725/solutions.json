["import fractions\n\ndef read_data():\n    m = int(input())\n    h1, a1 = map(int, input().split())\n    x1, y1 = map(int, input().split())\n    h2, a2 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    return m, h1, a1, x1, y1, h2, a2, x2, y2\n\ndef solve(m, h1, a1, x1, y1, h2, a2, x2, y2):\n    t = 0\n    h1s = [-1] * m\n    h2s = [-1] * m\n    h1s[h1] = 0\n    h2s[h2] = 0\n    t1 = -1\n    t2 = -1\n    while h1 != a1 or h2 != a2:\n        t += 1\n        h1 = (x1 * h1 + y1) % m\n        h2 = (x2 * h2 + y2) % m\n        if h1s[h1] >= 0 and t1 == -1:\n            t1 = h1s[h1]\n            s1 = t - t1\n            if t2 >= 0:\n                break\n        else:\n            h1s[h1] = t\n        if h2s[h2] >= 0 and t2 == -1:\n            t2 = h2s[h2]\n            s2 = t - t2\n            if t1 >= 0:\n                break\n        else:\n            h2s[h2] = t\n    if h1 == a1 and h2 == a2:\n        return t\n    return retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s)\n\ndef retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s):\n    u1 = h1s[a1]\n    u2 = h2s[a2]\n    if u1 == -1 or u2 == -1:\n        return -1\n    if u1 < t1:\n        if guess(h2s, u1, t2, s2, a2):\n            return u1\n        else:\n            return -1\n    if u2 < t2:\n        if guess(h1s, u2, t1, s1, a1):\n            return u2\n        else:\n            return -1\n    return find_time(u1, s1, u2, s2)\n\ndef guess(hs, u, t, s, a):\n    if u <= t:\n        return hs[a] == u\n    tt = t + (u - t) % s\n    return hs[a] == tt\n\ndef find_time(u1, s1, u2, s2):\n    g = fractions.gcd(s1, s2)\n    if abs(u1 - u2) % g:\n        return -1\n    k1, k2 = extended_euclid(s1, s2, u2-u1, g)\n    b = s2 // g\n    return (k1 % b) * s1 + u1\n\ndef egcd(a, b):\n    x, lastx = 0, 1\n    y, lasty = 1, 0\n    while b:\n        q = a // b\n        a, b = b, a % b\n        x, lastx = lastx - q * x, x\n        y, lasty = lasty - q * y, y\n    return lastx, lasty\n\ndef extended_euclid(a, b, c, g):\n    x, y = egcd(a, b)\n    return (c // g) * x, (x // g) * y\n\n\nparam = read_data()\nprint(solve(*param))", "mod = int(input())\nh1, a1 = map(int, input().split())\nx1, y1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nq1 = 0\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    q1 += 1\n    if q1 > 2 * mod:\n        print(-1)\n        return\n\nq2 = 0\nt2 = h2\nwhile t2 != a2:\n    t2 = (t2 * x2 + y2) % mod\n    q2 += 1\n    if q2 > 2 * mod:\n        print(-1)\n        return\n\nif q1 == q2:\n    print(q1)\n    return\n\n\nc1 = 1\nh1 = (a1 * x1 + y1) % mod\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    c1 += 1\n    if c1 > 2 * mod:\n        print(-1)\n        return\n\nc2 = 0\nnx2 = 1\nny2 = 0\n\nfor i in range(c1):\n    nx2 = (nx2 * x2) % mod\n    ny2 = (ny2 * x2 + y2) % mod\n\nfor i in range(q1):\n    h2 = (h2 * x2 + y2) % mod\n\nwhile h2 != a2:\n    h2 = (h2 * nx2 + ny2) % mod\n    c2 += 1\n    if c2 > 2 * mod:\n        print(-1)\n        return\n\nprint(q1 + c1 * c2)", "__author__ = 'kitkat'\nimport sys\n\n\n\ndef GetNext(h, x, y):\n    nonlocal m\n    return (x * h + y) % m\ntry:\n    while True:\n        m = int(input())\n        h1, a1 = list(map(int, input().split(\" \")))\n        x1, y1 = list(map(int, input().split(\" \")))\n        h2, a2 = list(map(int, input().split(\" \")))\n        x2, y2 = list(map(int, input().split(\" \")))\n        t1 = []\n        t2 = []\n        T = 0\n        for i in range (2 * m + 1):\n            if h1 == a1:\n                t1.append(T)\n            if h2 == a2:\n                t2.append(T)\n            T += 1\n            h1 = GetNext(h1, x1, y1)\n            h2 = GetNext(h2, x2, y2)\n\n        if len(t1) == 0 or len(t2) == 0:\n            print(\"-1\")\n            continue\n        if t1[0] == t2[0]:\n            print(t1[0])\n            continue\n        elif len(t1) < 2 or len(t2) < 2:\n            if len(t1) == 1 and len(t2) == 1:\n                print(t1[0] if t1[0] == t2[0] else \"-1\")\n            elif len(t1) == 1:\n                if t1[0] in t2:\n                    print(t1[0])\n                else:\n                    print(\"-1\")\n            elif len(t2) == 1:\n                if t2[0] in t1:\n                    print(t2[0])\n                else:\n                    print(\"-1\")\n            continue\n        res1 = t1[0]\n        res2 = t2[0]\n        flag = False\n        for i in range (5000000):\n            if res1 == res2:\n                flag = True\n                print(res1)\n                break\n            elif res1 <= res2:\n                res1 += t1[1] - t1[0]\n            else:\n                res2 += t2[1] - t2[0]\n        if not flag:\n            print(\"-1\")\nexcept EOFError:\n    pass\n", "def main():\n    m, tt = int(input()), [0] * 4\n    for i in 0, 2:\n        h, a = list(map(int, input().split()))\n        x, y = list(map(int, input().split()))\n        ha = (h, a)\n        for t in range(1, m * 2):\n            h = (h * x + y) % m\n            if h in ha:\n                if h == ha[0]:\n                    if tt[i]:\n                        tt[i] = t - tt[i]\n                        break\n                    else:\n                        tt[i] = t\n                else:\n                    if tt[i + 1]:\n                        tt[i] = t - tt[i + 1]\n                        break\n                    else:\n                        tt[i + 1] = t\n    step1, shift1, step2, shift2 = tt if tt[0] > tt[2] else tt[2:] + tt[:2]\n    if shift1 == shift2 != 0:\n        print(shift1)\n        return\n    if step1 and not step2 and shift1 and shift1 <= shift2 and not (shift2 - shift1) % step1:\n        print(shift2)\n        return\n    if all(tt):\n        if step2 == 1:\n            print(shift1 if shift1 >= shift2 else shift2 + (shift2 - shift1) % step1)\n            return\n        for t in range(shift1 - shift2, shift1 - shift2 + step1 * step2, step1):\n            if not t % step2:\n                print(t + shift2)\n                return\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = int(input())\nh1, a1 = map(int, input().split())\nx1, y1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nq1 = 0\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    q1 += 1\n    if q1 > 2 * mod:\n        print(-1)\n        return\n\nq2 = 0\nt2 = h2\nwhile t2 != a2:\n    t2 = (t2 * x2 + y2) % mod\n    q2 += 1\n    if q2 > 2 * mod:\n        print(-1)\n        return\n\nif q1 == q2:\n    print(q1)\n    return\n\n\nc1 = 1\nh1 = (a1 * x1 + y1) % mod\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    c1 += 1\n    if c1 > 2 * mod:\n        print(-1)\n        return\n\nc2 = 0\nnx2 = 1\nny2 = 0\n\nfor i in range(c1):\n    nx2 = (nx2 * x2) % mod\n    ny2 = (ny2 * x2 + y2) % mod\n\nfor i in range(q1):\n    h2 = (h2 * x2 + y2) % mod\n\nwhile h2 != a2:\n    h2 = (h2 * nx2 + ny2) % mod\n    c2 += 1\n    if c2 > 2 * mod:\n        print(-1)\n        return\n\nprint(q1 + c1 * c2)", "from fractions import *\nf = lambda: map(int, input().split())\nm = int(input())\n\ndef g(u, v):\n    h, a = u\n    x, y = v\n\n    s = 0\n    while h != a:\n        h = (h * x + y) % m\n        s += 1\n        if s > m: break\n\n    h = (a * x + y) % m\n    d = 1\n    while h != a:\n        h = (h * x + y) % m\n        d += 1\n        if d > m: break\n\n    return s, d\n\n(u, x), (v, y) = g(f(), f()), g(f(), f())\n\nif u > m or v > m: q = -1\nelif u == v: q = u\nelif x > m: q = -1 if u < v or (v - u) % y else u\nelif y > m: q = -1 if v < u or (v - u) % x else v\nelif (v - u) % gcd(x, y): q = -1\nelse:\n    while u != v:\n        if u < v: u += x\n        else: v += y\n    q = u\n\nprint(q)"]
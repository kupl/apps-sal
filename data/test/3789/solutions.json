["from collections import deque\n \n \nclass Dinic:\n    def __init__(self, n: int):\n        \"\"\"\u9802\u70b9\u6570\u3092n\u3068\u3059\u308b\"\"\"\n        self.INF = float(\"inf\")\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n \n    def add_edge(self, _from: int, to: int, capacity: int):\n        \"\"\"\u6b8b\u4f59\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\n        1. _from\u304b\u3089to\u3078\u5411\u304b\u3046\u5bb9\u91cfcapacity\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        2. to\u304b\u3089_from\u3078\u5411\u304b\u3046\u5bb9\u91cf0\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        \"\"\"\n        forward = [to, capacity, None]\n        forward[2] = backward = [_from, 0, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n \n    def bfs(self, s: int, t: int):\n        \"\"\"capacity\u304c\u6b63\u306e\u8fba\u306e\u307f\u3092\u901a\u3063\u3066s\u304b\u3089t\u306b\u79fb\u52d5\u53ef\u80fd\u304b\u3069\u3046\u304bBFS\u3067\u63a2\u7d22\n        level: s\u304b\u3089\u306e\u6700\u77ed\u8def\u306e\u9577\u3055\n        \"\"\"\n        self.level = [-1] * self.n\n        q = deque([s])\n        self.level[s] = 0\n        while q:\n            _from = q.popleft()\n            for to, capacity, _ in self.graph[_from]:\n                if capacity > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[_from] + 1\n                    q.append(to)\n \n    def dfs(self, _from: int, t: int, f: int) -> int:\n        \"\"\"\u6d41\u91cf\u304c\u5897\u52a0\u3059\u308b\u30d1\u30b9\u3092DFS\u3067\u63a2\u7d22\n        BFS\u306b\u3088\u3063\u3066\u4f5c\u3089\u308c\u305f\u6700\u77ed\u8def\u306b\u5f93\u3063\u3066f\u3092\u66f4\u65b0\u3059\u308b\n        \"\"\"\n        if _from == t:\n            return f\n        for edge in self.itr[_from]:\n            to, capacity, reverse_edge = edge\n            if capacity > 0 and self.level[_from] < self.level[to]:\n                d = self.dfs(to, t, min(f, capacity))\n                if d > 0:\n                    edge[1] -= d\n                    reverse_edge[1] += d\n                    return d\n        return 0\n \n    def max_flow(self, s: int, t: int):\n        \"\"\"s-t\u30d1\u30b9\u4e0a\u306e\u6700\u5927\u6d41\u3092\u6c42\u3081\u308b\n        \u8a08\u7b97\u91cf: O(|E||V|^2)\n        \"\"\"\n        flow = 0\n        while True:\n            self.bfs(s, t)\n            if self.level[t] < 0:\n                break\n            self.itr = list(map(iter, self.graph))\n            f = self.dfs(s, t, self.INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, self.INF)\n        return flow\n\nn = int(input())\na = list(map(int, input().split()))\n\ndinic = Dinic(n + 2)\ns = 0\nt = n + 1\n_sum = 0\nfor i in range(0, n):\n    if a[i] > 0:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, a[i])\n        _sum += a[i]\n    elif a[i] < 0:\n        dinic.add_edge(s, i+1, -a[i])\n        dinic.add_edge(i+1, t, 0)\n    else:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, 0)\n\nfor i in range(n):\n    num = i+1\n    next_num = 2 * num\n    while next_num <= n:\n        dinic.add_edge(num, next_num, 10**18)\n        next_num += num\n\nprint(_sum - dinic.max_flow(s, t))", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n\n    return\n\n#B\ndef B():\n\n    return\n\n#C\ndef C():\n    def bfs(s,g,n):\n        bfs_map = [-1 for i in range(n)]\n        bfs_map[s] = 0\n        q = deque()\n        q.append(s)\n        fin = False\n        while q:\n            x = q.popleft()\n            for y in v[x]:\n                if c[x][y] > 0 and bfs_map[y] < 0:\n                    bfs_map[y] = bfs_map[x]+1\n                    if y == g:\n                        fin = True\n                        break\n                    q.append(y)\n            if fin:\n                break\n\n        if bfs_map[g] == -1:\n            return None,0\n        path = [None]*(bfs_map[g]+1)\n        m = float(\"inf\")\n        path[bfs_map[g]] = g\n        y = g\n        for i in range(bfs_map[g])[::-1]:\n            for x in v[y]:\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                    path[i] = x\n                    if c[x][y] < m:\n                        m = c[x][y]\n                    y = x\n                    break\n        return path,m\n\n    def ford_fulkerson(s,g,c,n):\n        f = 0\n        while 1:\n            p,m = bfs(s,g,n)\n            if not m:break\n            f += m\n            for i in range(len(p)-1):\n                c[p[i]][p[i+1]] -= m\n                c[p[i+1]][p[i]] += m\n        return f\n\n    n = I()\n    a = LI()\n    e = n+2\n    ma = 10**9\n    c = [[0]*e for i in range(e)]\n    v = [[] for i in range(e)]\n    for i in range(n):\n        d = i+1\n        j = 2*d\n        c[0][d] = ma\n        v[0].append(d)\n        v[d].append(0)\n        c[d][n+1] = ma-a[i]\n        v[d].append(n+1)\n        v[n+1].append(d)\n        while j <= n:\n            c[j][d] = float(\"inf\")\n            v[j].append(d)\n            v[d].append(j)\n            j += d\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\n    return\n\n#D\ndef D():\n\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "N=int(input())\nalist=[0]+list(map(int,input().split()))\nxlist=list(range(1,N+1))\n#print(alist,xlist)\n\n# Ford-Fulkerson algorithm\nclass FordFulkerson:\n  def __init__(self, N):\n    self.N = N\n    self.G = [[] for i in range(N)]\n\n  def add_edge(self, fr, to, cap):\n    forward = [to, cap, None]\n    forward[2] = backward = [fr, 0, forward]\n    self.G[fr].append(forward)\n    self.G[to].append(backward)\n\n  def add_multi_edge(self, v1, v2, cap1, cap2):\n    edge1 = [v2, cap1, None]\n    edge1[2] = edge2 = [v1, cap2, edge1]\n    self.G[v1].append(edge1)\n    self.G[v2].append(edge2)\n\n  def dfs(self, v, t, f):\n    if v == t:\n      return f\n    used = self.used\n    used[v] = 1\n    for e in self.G[v]:\n      w, cap, rev = e\n      if cap and not used[w]:\n        d = self.dfs(w, t, min(f, cap))\n        if d:\n          e[1] -= d\n          rev[1] += d\n          return d\n    return 0\n\n  def flow(self, s, t):\n    flow = 0\n    f = INF = 10**9 + 7\n    N = self.N \n    while f:\n      self.used = [0]*N\n      f = self.dfs(s, t, INF)\n      flow += f\n    return flow\n\nasum_pos=0  \n## \u70b9\u6570N\u3001\u8fba\u6570M\u3001\u59cb\u70b9s\u3001\u7d42\u70b9t\nff = FordFulkerson(N+2)\nfor i in range(1,N+1):\n  a=alist[i]\n  if a<=0:\n    ff.add_edge(0,i,-a)\n  else:\n    ff.add_edge(i,N+1,a)\n    asum_pos+=a\n\nfor i in range(1,N+1):\n  for j in range(2*i,N+1,i):\n    ff.add_edge(i,j,float(\"inf\"))\n\npenalty=ff.flow(0,N+1)\nprint(asum_pos-penalty)", "N=int(input())\nalist=[0]+list(map(int,input().split()))\nxlist=list(range(1,N+1))\n#print(alist,xlist)\n\n# Ford-Fulkerson algorithm\nclass FordFulkerson:\n  def __init__(self, vlist):\n    self.G = {}\n    for v in vlist:\n      self.G[v] = []\n\n  def add_edge(self, fr, to, cap):\n    forward = [to, cap, None]\n    forward[2] = backward = [fr, 0, forward]\n    self.G[fr].append(forward)\n    self.G[to].append(backward)\n\n  def add_multi_edge(self, v1, v2, cap1, cap2):\n    edge1 = [v2, cap1, None]\n    edge1[2] = edge2 = [v1, cap2, edge1]\n    self.G[v1].append(edge1)\n    self.G[v2].append(edge2)\n\n  def dfs(self, v, t, f):\n    if v == t:\n      return f\n    used = self.used\n    used[v] = True\n    for e in self.G[v]:\n      w, cap, rev = e\n      if cap and not used[w]:\n        d = self.dfs(w, t, min(f, cap))\n        if d:\n          e[1] -= d\n          rev[1] += d\n          return d\n    return 0\n\n  def flow(self, s, t):\n    flow = 0\n    f = INF = 10**9 + 7\n    while f:\n      self.used = {}\n      for v in self.G:\n        self.used[v]=False\n      f = self.dfs(s, t, INF)\n      flow += f\n    return flow\n  \nasum_pos=0  \n## \u70b9\u6570N\u3001\u8fba\u6570M\u3001\u59cb\u70b9s\u3001\u7d42\u70b9t\nff = FordFulkerson(range(N+2))\nfor i in range(1,N+1):\n  a=alist[i]\n  if a<=0:\n    ff.add_edge(0,i,-a)\n  else:\n    ff.add_edge(i,N+1,a)\n    asum_pos+=a\n\nfor i in range(1,N+1):\n  for j in range(2*i,N+1,i):\n    ff.add_edge(i,j,float(\"inf\"))\n\npenalty=ff.flow(0,N+1)\nprint(asum_pos-penalty)", "#  --*-coding:utf-8-*--\n\nINF = float('inf');\n\ndef fulkerson(graph, src, sink):\n    n = len(graph)\n\n    matrix = [[0]*n for i in range(n)]\n    bothDirGraph = [[] for i in range(n)]\n\n    for nodeId, edges in enumerate(graph):\n        for nodeId2, flowLimit in edges:\n            matrix[nodeId][nodeId2] = flowLimit\n            bothDirGraph[nodeId].append(nodeId2)\n            bothDirGraph[nodeId2].append(nodeId)\n\n    while True:\n        path = findPath(bothDirGraph, matrix, src, sink)\n\n        if path == None:\n            break\n\n        v = min(matrix[path[i]][path[i+1]] \n                for i in range(len(path)-1))\n\n        for i in range(len(path)-1):\n            node1 = path[i]\n            node2 = path[i+1]\n            \n            matrix[node1][node2] -= v\n            matrix[node2][node1] += v\n\n    return (sum(c for _, c in graph[src]) - \n            sum(c for c in matrix[src]))\n\n\ndef findPath(bothDirGraph, matrix, src, sink):\n    prevs = [None]*len(matrix)\n    q = set([src])\n    prevs[src] = src\n\n    while len(q) > 0:\n        node = q.pop()\n\n        for nextNode in bothDirGraph[node]:\n            if prevs[nextNode] == None and matrix[node][nextNode] > 0:\n                prevs[nextNode] = node\n                \n                if nextNode == sink:\n                    path = []\n                    pathNode = sink\n\n                    while pathNode != src:\n                        path.append(pathNode)\n                        pathNode = prevs[pathNode]\n\n                    path.append(src)\n                    return list(reversed(path))\n\n                q.add(nextNode)\n\n    return None\n                    \ndef f(N, A):\n    graph = [[] for i in range(N+2)]\n    srcId = 0\n    dstId = N+1\n\n    for nodeId, a in enumerate(A, 1):\n        if a < 0:\n            graph[0].append((nodeId, -a))\n        else:\n            graph[nodeId].append((N+1, a))\n\n        for k in range(2, N//nodeId+1):\n            graph[nodeId].append((nodeId*k, INF))\n\n    return (sum([a for a in A if a>0]) - \n            fulkerson(graph, 0, N+1))\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    print((f(N, A)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n# \u30b0\u30e9\u30d5\u306b\u8fba\u3092\u8ffd\u52a0\u3059\u308b\ndef addEdge(adjL, vFr, vTo, cap):\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \u9006\u8fba\n\n\n# Edmonds-Karp\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\ndef Edmonds_Karp(adjL, vSt, vEn):\n\n    # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001BFS\u3067\u63a2\u7d22\u3059\u308b\n    def BFS(vSt, vEn):\n        prev = [-1] * numV\n        prev[vSt] = None\n        iE = [-1] * numV\n        df = 0\n        Q = deque([(vSt, float('inf'))])\n        while Q:\n            vNow, fNow = Q.popleft()\n            if vNow == vEn:\n                # \u7d42\u70b9\u306b\u5230\u9054\u3057\u305f\u3089\u3001\u30eb\u30fc\u30d7\u3092\u629c\u3051\u308b\n                df = fNow\n                break\n\n            for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\n                if prev[v2] == -1 and cap > 0:\n                    # \u672a\u63a2\u7d22\u306e\u9802\u70b9\u3078\u306e\u8fba\u306e\u5bb9\u91cf\u306b\u7a7a\u304d\u304c\u3042\u308b\u5834\u5408\u3001\u63a2\u7d22\u3059\u308b\n                    prev[v2] = vNow\n                    iE[v2] = (i, iRev)\n                    Q.append((v2, min(fNow, cap)))\n\n        if df > 0:\n            # \u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\u3092\u9061\u3063\u3066\u3001\u8fba\u306e\u30d5\u30ed\u30fc\u3092\u5909\u66f4\u3059\u308b\n            vNow = vEn\n            while vNow != vSt:\n                v0 = prev[vNow]\n                e, iRev = iE[vNow]\n                adjL[v0][e][1] -= df\n                adjL[vNow][iRev][1] += df\n                vNow = v0\n\n        # \u30d5\u30ed\u30fc\u306e\u5897\u52a0\u91cf\u3092\u8fd4\u3059\n        return df\n\n\n    numV = len(adjL)\n    MaximumFlow = 0\n    while True:\n        # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001BFS\u3067\u63a2\u7d22\u3059\u308b\n        df = BFS(vSt, vEn)\n\n        if df == 0:\n            # \u7d4c\u8def\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u3001\u6700\u5927\u30d5\u30ed\u30fc\u306e\u5024\u3092\u8fd4\u3059\n            return MaximumFlow\n\n        # \u30d5\u30ed\u30fc\u3092\u52a0\u7b97\u3059\u308b\n        MaximumFlow += df\n\n\nN = int(input())\nAs = list(map(int, input().split()))\n\nadjList = [[] for v in range(N + 2)]\nfor i, A in enumerate(As, 1):\n    if A <= 0:\n        addEdge(adjList, 0, i, -A)\n    else:\n        addEdge(adjList, i, N + 1, A)\n\nfor i in range(1, N + 1):\n    for j in range(2 * i, N + 1, i):\n        addEdge(adjList, i, j, float('inf'))\n\n# Edmonds-Karp\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\nmf = Edmonds_Karp(adjList, 0, N + 1)\nprint((sum([A for A in As if A > 0]) - mf))\n", "import collections\n\n\nclass MaxFlow:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, fr, to, cap):\n        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))\n        self.E[to].append(self.Edge(fr, 0, len(self.E[fr])-1))\n\n    def dinic(self, source, sink, INF=10**9):\n        \"\"\"find max-flow\"\"\"\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\n\ndef main():\n    INF = 10 ** 9\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    flow = MaxFlow(N + 2)\n    source, sink = N, N + 1\n    for i, a in enumerate(A):\n        if a >= 0:\n            flow.add_edge(source, i, a)\n        else:\n            flow.add_edge(i, sink, abs(a))\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            if j % i == 0:\n                flow.add_edge(j - 1, i - 1, INF)\n    cost = flow.dinic(source, sink, INF)\n    print((sum(a for a in A if a > 0) - cost))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef divisions(n):\n    sq = int(math.sqrt(n)+1)\n    d = collections.defaultdict(int)\n    while n % 2 == 0:\n        n //= 2\n        d[2] += 1\n    i = 3\n    while n > 1 and sq >= i:\n        if n % i == 0:\n            n //= i\n            d[i] += 1\n        else:\n            i += 2\n\n    if n > 1:\n        d[n] += 1\n\n    r = [1]\n    for k, v in d.items():\n        for c in r[:]:\n            for i in range(1,v+1):\n                r.append(c*(k**i))\n\n    return sorted(r)\n\ndef main():\n    n = I()\n    a = LI()\n    s = set()\n    for i in range(n,0,-1):\n        d = divisions(i)\n        ld = len(d)\n        for j in range(1,2**ld):\n            c = []\n            ff = True\n            for k in range(ld):\n                if j & (1<<k):\n                    f = True\n                    for e in c:\n                        if d[k] % e == 0:\n                            f = False\n                            ff = False\n                            break\n                    if f:\n                        c.append(d[k])\n                if not ff:\n                    break\n            if ff:\n                s.add(tuple(c + [n+1]))\n    b = sorted(list(s), reverse=True)\n    for c in b:\n        t = 0\n        for j in range(1,n+1):\n            f = False\n            for e in c:\n                if j%e == 0:\n                    f = True\n                    break\n            if f:\n                t += a[j-1]\n        if t < 0:\n            for j in range(1,n+1):\n                f = False\n                for e in c:\n                    if j%e == 0:\n                        f = True\n                        break\n                if f:\n                    a[j-1] = 0\n\n    return sum(a)\n\n\n\nprint(main())\n\n\n", "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        for i, link in enumerate(self.links[v]):\n            if i < self.progress[v]:\n                continue\n            self.progress[v] = i\n            cap, to, rev = link\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn = int(input())\nan = list(map(int, input().split()))\nmf = Dinic(n + 2)\nmax_value = 0\nfor i, a in enumerate(an):\n    i += 1\n    if a > 0:\n        max_value += a\n        mf.add_link(i, n + 1, a)\n    else:\n        mf.add_link(0, i, -a)\n    for j in range(2 * i, n + 1, i):\n        mf.add_link(i, j, float('inf'))\nprint((max_value - mf.max_flow(0, n + 1)))\n", "class Ford_Fulkerson:\n\n\tdef __init__(self, v, inf=float(\"inf\")):\n\t\tself.V = v\n\t\tself.inf = inf\n\t\tself.G = [[] for _ in range(v)]\n\t\tself.used = [False for _ in range(v)]\n\n\tdef addEdge(self, fm, to, cap):\n\t\t'''\n\t\tto:\u884c\u304d\u5148\n\t\tcap:\u5bb9\u91cf\n\t\trev:\u53cd\u5bfe\u5074\u306e\u8fba\n\t\t'''\n\t\tself.G[fm].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\n\t\tself.G[to].append({'to':fm, 'cap':0, 'rev':len(self.G[fm])-1})\n\n\n\tdef dfs(self, v, t, f):\n\t\tif v == t: return f\n\t\tself.used[v] = True\n\n\t\tfor i in range(len(self.G[v])):\n\t\t\te = self.G[v][i]\n\t\t\tif self.used[e[\"to\"]] != True and e['cap'] > 0:\n\t\t\t\td = self.dfs(e['to'], t ,min(f, e['cap']))\n\t\t\t\tif d > 0:\n\t\t\t\t\te['cap'] -= d\n\t\t\t\t\tself.G[e['to']][e['rev']]['cap'] += d\n\t\t\t\t\treturn d\n\t\treturn 0\n\n\tdef max_flow(self,s,t):\n\t\tflow = 0\n\t\twhile True:\n\t\t\tself.used = [False for i in range(self.V)]\n\t\t\tf = self.dfs(s,t,self.inf)\n\t\t\tif f == 0: return flow\n\t\t\tflow += f\n\n\n\nfrom sys import stdin, setrecursionlimit\ndef IL():return list(map(int, stdin.readline().split()))\n \nsetrecursionlimit(1000000)\n\ndef main():\n\tN = int(input())\n\ta = IL()\n\td = Ford_Fulkerson(N+2)\n\tres = 0\n\tfor i in range(N):\n\t    d.addEdge(N,i, max(0, -a[i]))\n\t    d.addEdge(i,N+1, max(0,a[i]))\n\t    res+=max(0,a[i])\n\t    t = 2*i+2\n\t    while t<=N:\n\t        d.addEdge(i,t-1,float('inf'))\n\t        t+=i+1\n\tprint(res-d.max_flow(N,N+1))\n\t\n\t\ndef __starting_point(): main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom scipy.sparse.csgraph import dijkstra\nimport numpy as np\n\n\"\"\"\n\u6700\u5c0f\u30ab\u30c3\u30c8\n\"\"\"\n\nN = int(input())\nstart = 0\ngoal = N+1\n\nA = [0] + [int(x) for x in input().split()]\n\nINF = 10 ** 12\ngraph = np.zeros((N+2,N+2),dtype=np.int64)\nfor i,a in enumerate(A[1:],1):\n    if a >= 0:\n        graph[start,i] = a\n    else:\n        graph[i,goal] = -a\nfor i in range(1,N+1):\n    for j in range(2*i,N+1,i):\n        if A[i] < 0 and A[j] > 0:\n            graph[j][i] = INF\n\ndef max_flow(graph):\n    flow = 0\n    while True:\n        dist,pred = dijkstra(graph, indices = start, return_predecessors = True, unweighted = True)\n        if dist[goal] == np.inf:\n            return flow\n        path = []\n        v = goal\n        while True:\n            path.append((pred[v],v))\n            v = pred[v]\n            if v == start:\n                break\n        add_flow = min(graph[x][y] for x,y in path)\n        for x,y in path:\n            graph[x][y] -= add_flow\n            graph[y][x] += add_flow\n        flow += add_flow\n\nanswer = sum(x for x in A if x > 0) - max_flow(graph)\nprint(answer)", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\nimport sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn = int(input())\na = list( map(int, input().split()))\n\nscore = 0\nINF = float('inf')\ngraph = Dinic(n+2)\n\nfor i in range(n):\n    if a[i]>0:\n        graph.add_edge(i+1,n+1,a[i])\n        score += a[i]\n    elif a[i]<0:\n        graph.add_edge(0,i+1,-a[i])\n\nfor i in range(1,n//2+1):\n    for j in range(2*i,n+1,i):\n        graph.add_edge(i,j,INF)\n\nprint(score-graph.flow(0,n+1))", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\nclass Flow():\n    def __init__(self, e, N):\n        self.E = e\n        self.N = N\n\n    def max_flow(self, s, t):\n        r = 0\n        e = self.E\n\n        def f(c, cap):\n            v = self.v\n            v[c] = 1\n            if c == t:\n                return cap\n            for i in range(self.N):\n                if v[i] or e[c][i] <= 0:\n                    continue\n                cp = min(cap, e[c][i])\n                k = f(i, cp)\n                if k > 0:\n                    e[c][i] -= k\n                    e[i][c] += k\n                    return k\n            return 0\n\n        while True:\n            self.v = [None] * self.N\n            fs = f(s, inf)\n            if fs == 0:\n                break\n            r += fs\n\n        return r\n\n\ndef main():\n    n = I()\n    a = LI()\n\n    s = n\n    t = n + 1\n    e = [[0] * (n+2) for _ in range(n+2)]\n    for i in range(n):\n        c = a[i]\n        if c < 0:\n            e[s][i] = -c\n            ii = i + 1\n            for j in range(ii*2, n+1, ii):\n                e[i][j-1] = inf\n        else:\n            e[i][t] = c\n\n\n    fl = Flow(e, n+2)\n    r = fl.max_flow(s,t)\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n# start = time.time()\nprint(main())\n# pe(time.time() - start)\n\n\n\n", "from networkx import*\nn,*A=map(int,open(s:=0).read().split())\nG=DiGraph()\nG.add_nodes_from(range(n+2))\nfor i,a in enumerate(A,1):\n if a>0:\n  s+=a\n  G.add_edge(i,n+1,capacity=a)\n else:G.add_edge(0,i,capacity=-a)\n for j in range(i+i,n+1,i):G.add_edge(i,j,capacity=9e20)\nprint(s-maximum_flow(G,0,n+1)[0])", "#!/usr/bin/env python3\n\nimport math\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    q, r = a, b\n    while r:\n        q, r = r, q % r\n\n    return q\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nMAX_N = 102\nINF = 10 ** 12\nSRC = 0\nDST = MAX_N - 1\ng = [[0] * MAX_N for _ in range(MAX_N)]\nlevel = []\nvisited = []\nn = 0\n\n\ndef bfs(s):\n    nonlocal level\n\n    level = [-1] * MAX_N\n    level[s] = 0\n    que = [s]\n    while 0 < len(que):\n        v = que.pop(0)\n        for w in range(MAX_N):\n            if 0 < g[v][w] and level[w] < 0:\n                level[w] = level[v] + 1\n                que.append(w)\n\n\ndef dfs(v, t, f):\n    nonlocal g, visited\n\n    if v == t:\n        return f\n    for w in range(visited[v], MAX_N):\n        visited[v] = w\n        if 0 < g[v][w] and level[v] < level[w]:\n            d = dfs(w, t, min(f, g[v][w]))\n            if 0 < d:\n                g[v][w] -= d\n                g[w][v] += d\n                return d\n\n    return 0\n\n\ndef max_flow():\n    nonlocal visited\n\n    flow = 0\n    while True:\n        bfs(SRC)\n        if level[DST] < 0:\n            return flow\n        visited = [0] * MAX_N\n        f = dfs(SRC, DST, INF)\n        while 0 < f:\n            flow += f\n            f = dfs(SRC, DST, INF)\n\n\ndef solve(n, a):\n    nonlocal g\n\n    sum_positive = sum([v for v in a if 0 < v])\n\n    for i in range(1, n + 1):\n        if 0 < a[i]:\n            g[SRC][i] = a[i]\n        elif a[i] < 0:\n            g[i][DST] = -a[i]\n            for j in range(i * 2, n + 1, i):\n                if 0 < a[j]:\n                    g[j][i] = INF\n\n    return sum_positive - max_flow()\n\n\ndef main():\n    nonlocal n\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = [0] + a\n\n    print((solve(n, a)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "# Dinic's algorithm by @yaketake08\n# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\nfrom collections import deque\nINF = 10**30\nclass Dinic:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.g = [[] for i in range(n)]\n\n\tdef add_edge(self, fr, to, cap):\n\t\tforward = [to, cap, None]\n\t\tforward[2] = backward = [fr, 0, forward]\n\t\tself.g[fr].append(forward)\n\t\tself.g[to].append(backward)\n\n\tdef add_bidirectional_edge(self, v1, v2, cap1, cap2):\n\t\tedge1 = [v2, cap1, None]\n\t\tedge1[2] = edge2 = [v1, cap2, edge1]\n\t\tself.g[v1].append(edge1)\n\t\tself.g[v2].append(edge2)\n\n\tdef bfs(self, s, t):\n\t\tself.level = level = [None]*self.n\n\t\tdeq = deque([s])\n\t\tlevel[s] = 0\n\t\tg = self.g\n\t\twhile deq:\n\t\t\tv = deq.popleft()\n\t\t\tlv = level[v] + 1\n\t\t\tfor w, cap, _ in g[v]:\n\t\t\t\tif cap and level[w] is None:\n\t\t\t\t\tlevel[w] = lv\n\t\t\t\t\tdeq.append(w)\n\t\treturn level[t] is not None\n\n\tdef dfs(self, v, t, f):\n\t\tif v == t:\n\t\t\treturn f\n\t\tlevel = self.level\n\t\tfor e in self.it[v]:\n\t\t\tw, cap, rev = e\n\t\t\tif cap and level[v] < level[w]:\n\t\t\t\td = self.dfs(w, t, min(f, cap))\n\t\t\t\tif d:\n\t\t\t\t\te[1] -= d\n\t\t\t\t\trev[1] += d\n\t\t\t\t\treturn d\n\t\treturn 0\n\n\tdef flow(self, s, t):\n\t\tflow = 0\n\t\tg = self.g\n\t\twhile self.bfs(s, t):\n\t\t\t*self.it, = map(iter, self.g)\n\t\t\tf = INF\n\t\t\twhile f:\n\t\t\t\tf = self.dfs(s, t, INF)\n\t\t\t\tflow += f\n\t\treturn flow\n\nn = int(input())\na = [-1] + list(map(int, input().split()))\nd = Dinic(n+2)\ns, t = 0, n+1\n\nfor i in range(1, n+1):\n\tif a[i] > 0:\n\t\td.add_edge(i, t, a[i])\n\telif a[i] < 0:\n\t\td.add_edge(s, i, -a[i])\n\tfor j in range(2*i, n+1, i):\n\t\td.add_edge(i, j, INF)\n\nres = d.flow(s, t)\nprint(sum([x for x in a if x>0]) - res)", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n\n    return\n\n#B\ndef B():\n\n    return\n\n#C\ndef C():\n    def bfs(s,g,n):\n        bfs_map = [-1 for i in range(n)]\n        bfs_map[s] = 0\n        q = deque()\n        q.append(s)\n        fin = False\n        while q:\n            x = q.popleft()\n            for y in range(n):\n                if c[x][y] > 0 and bfs_map[y] < 0:\n                    bfs_map[y] = bfs_map[x]+1\n                    if y == g:\n                        fin = True\n                        break\n                    q.append(y)\n            if fin:\n                break\n\n        if bfs_map[g] == -1:\n            return [None,0]\n        path = [None for i in range(bfs_map[g]+1)]\n        m = float(\"inf\")\n        path[bfs_map[g]] = g\n        y = g\n        for i in range(bfs_map[g])[::-1]:\n            for x in range(n+1):\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                    path[i] = x\n                    if c[x][y] < m:\n                        m = c[x][y]\n                    y = x\n                    break\n        return [path,m]\n\n    def ford_fulkerson(s,g,c,n):\n        while 1:\n            p,m = bfs(s,g,n)\n            if not m:break\n            for i in range(len(p)-1):\n                c[p[i]][p[i+1]] -= m\n                c[p[i+1]][p[i]] += m\n        return sum(c[g])\n\n    n = I()\n    a = LI()\n    e = n+2\n    ma = 10**9\n    c = [[0]*e for i in range(e)]\n    for i in range(n):\n        d = i+1\n        j = 2*d\n        c[0][d] = ma\n        c[d][n+1] = ma-a[i]\n        while j <= n:\n            c[j][d] = float(\"inf\")\n            j += d\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\n    return\n\n#D\ndef D():\n\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "from collections import deque\n\nN = int(input())\nA = list(map(int,input().split()))\n\nP = N+2\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\n\ndef add_edge(fr,to,cap):\n    es[fr].append([to,cap,len(es[to])])\n    es[to].append([fr,0,len(es[fr])-1])\n\nINF = float('inf')\nscore = 0\nfor i,a in enumerate(A):\n    if a < 0:\n        add_edge(0,i+1,-a)\n    elif a > 0:\n        add_edge(i+1,N+1,a)\n        score += a\nfor n in range(1,N//2+1):\n    for m in range(2*n,N+1,n):\n        add_edge(n,m,INF)\n\nlevel = [0] * P\niters = [0] * P\n\ndef dinic_max_flow(s,t):\n    nonlocal iters\n\n    def _bfs(s):\n        nonlocal level\n        level = [-1] * P\n        level[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for to,cap,rev in es[v]:\n                if cap > 0 and level[to] < 0:\n                    level[to] = level[v] + 1\n                    q.append(to)\n\n    def _dfs(v,t,f):\n        if v == t: return f\n        for i in range(iters[v],len(es[v])):\n            iters[v] += 1\n            to,cap,rev = es[v][i]\n            if es[v][i][1] > 0 and level[v] < level[to]:\n                d = _dfs(to,t,min(f,es[v][i][1]))\n                if d > 0:\n                    es[v][i][1] -= d #cap\n                    es[to][rev][1] += d\n                    return d\n        return 0\n\n    flow = 0\n    while True:\n        _bfs(s)\n        if level[t] < 0: return flow\n        iters = [0] * P\n        f = 0\n        while True:\n            f = _dfs(s,t,INF)\n            if f <= 0: break\n            flow += f\n\nprint(score - dinic_max_flow(0,N+1))", "N=int(input())\nP=[int(i) for i in input().split()]\ninf = 10**20\ntable=[[0]*(N+2) for i in range(N+2)]\nfor i in range(1,N+1):\n    if P[i-1]>0:\n        table[i][N+1]=P[i-1]\n    else:\n        table[0][i]=-P[i-1]\n    for j in range(2*i,N+1,i):\n        table[i][j]=inf\n#print(table)\ndef fk(x,t,f):\n    #print(x)\n    visit[x]=True\n    if x==t:\n        return f\n    for i in range(N+2):\n        if (not visit[i]) and table[x][i]>0:\n            df=fk(i,t,min(f,table[x][i]))\n            if df>0:\n                table[x][i]-=df\n                table[i][x]+=df\n                return df\n    return 0\n\nans=0\nwhile True:\n    visit=[False]*(N+2)\n    df=fk(0,N+1,inf)\n    if df>0:\n        ans+=df\n    else:\n        break\nnum=sum([p for p in P if p>0])\nprint(num-ans)", "from collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\nimport sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn = int(input())\na = list( map(int, input().split()))\n\nscore = 0\nINF = float('inf')\ngraph = Dinic(n+2)\n\nfor i in range(n):\n    if a[i]>0:\n        graph.add_edge(i+1,n+1,a[i])\n        score += a[i]\n    elif a[i]<0:\n        graph.add_edge(0,i+1,-a[i])\n\nfor i in range(1,n//2+1):\n    for j in range(2*i,n+1,i):\n        graph.add_edge(i,j,INF)\n\nprint((score-graph.flow(0,n+1)))\n\n\n", "\n\"\"\"\nhttps://atcoder.jp/contests/arc085/tasks/arc085_c\n\n\"\"\"\n\nfrom collections import defaultdict\nfrom collections import deque\n\ndef Ford_Fulkerson_Func(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n    queue = deque([ [s,float(\"inf\")] ])\n\n\n    ed = [True] * N\n    ed[s] = False\n\n    route = [0] * N\n    route[s] = -1\n\n    while queue:\n\n        now,flow = queue.pop()\n        for nex in lines[now]:\n\n            if ed[nex]: \n                flow = min(cost[now][nex],flow)\n                route[nex] = now\n                queue.append([nex,flow])\n                ed[nex] = False\n\n                if nex == g:\n                    ans += flow\n                    break\n            \n        else:\n            continue\n        break\n\n    else:\n        return False,ans\n\n\n    t = g\n    s = route[t]\n\n    while s != -1:\n        cost[s][t] -= flow\n        if cost[s][t] == 0:\n            lines[s].remove(t)\n\n        if cost[t][s] == 0:\n            lines[t].add(s)\n        cost[t][s] += flow\n        t = s\n        s = route[t]\n\n    return True,ans\n\ndef Ford_Fulkerson(s,g,lines,cost):\n\n    ans = 0\n\n    while True:\n        fl,nans = Ford_Fulkerson_Func(s,g,lines,cost)\n\n        if fl:\n            ans += nans\n            continue\n        else:\n            break\n    \n    return ans\n\nN = int(input())\na = list(map(int,input().split()))\n\nS = N+1\nT = N+2\n\nlis = defaultdict(set)\ncost = [[0] * (N+3) for i in range(N+3)]\n\nfor i in range(N):\n\n    if a[i] > 0:\n        lis[i+1].add(T)\n        cost[i+1][T] += a[i]\n\n    elif a[i] < 0:\n        lis[S].add(i+1)\n        cost[S][i+1] -= a[i]\n\nfor i in range(1,N+1):\n\n    for j in range(i*2,N+1,i):\n\n        lis[i].add(j)\n        cost[i][j] += float(\"inf\")\n\n\nm = Ford_Fulkerson(S,T,lis,cost)\n\nss = 0\nfor i in range(N):\n    if a[i] > 0:\n        ss += a[i]\nprint (ss-m)", "class FK:\n    def __init__(self,n):\n        self.table=[[0]*n for i in range(n)]\n        self.n=n\n    \n    def add(self,x,y,f):\n        self.table[x][y]=f\n        \n    def ford(self,s,t,f):\n        self.visit[s]=True\n        if s==t:\n            return f\n        for i in range(self.n):\n            if (not self.visit[i]) and self.table[s][i]>0:\n                df=self.ford(i,t,min(f,self.table[s][i]))\n                if df>0:\n                    self.table[s][i]-=df\n                    self.table[i][s]+=df\n                    return df\n        return 0\n    \n    def flow(self,s,t):\n        ans=0\n        inf=10**20\n        while True:\n            self.visit=[False]*(self.n)\n            df=self.ford(s,t,inf)\n            if df==0:\n                break\n            ans+=df\n        return ans\n\nN=int(input())\nP=[int(i) for i in input().split()]\ninf=10**20\nmaxflow=FK(N+2)\nfor i in range(1,N+1):\n    if P[i-1]>0:\n        maxflow.add(i,N+1,P[i-1])\n    else:\n        maxflow.add(0,i,-P[i-1])\n    for j in range(2*i,N+1,i):\n        maxflow.add(i,j,inf)\nans=maxflow.flow(0,N+1)\nnum=sum([p for p in P if p>0])\nprint(num-ans)", "def edmonds_karp(s, t, C):\n    import copy\n    import collections\n\n    r = copy.deepcopy(c)\n    maxf = 0\n\n    while True:\n        q, found = collections.deque(), False\n        q.append(([S], 10 ** 15))\n        while len(q) > 0 and not found:\n            p, minf = q.popleft()\n            for to, flow in list(r[p[-1]].items()):\n                if flow == 0:\n                    continue\n                elif to == T:\n                    p, minf = p + [to], min(flow, minf)\n                    found = True\n                    break\n                elif not to in p:\n                    q.append((p + [to], min(flow, minf)))\n\n        if not found:\n            break\n\n        for i in range(len(p) - 1):\n            r[p[i]][p[i + 1]] -= minf\n            if p[i] in r[p[i + 1]]:\n                r[p[i + 1]][p[i]] += minf\n            else:\n                r[p[i + 1]][p[i]] = minf\n        maxf += minf\n\n    return maxf\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\ngain = sum([max(a, 0) for a in A])\n\nS, T = 0, N + 1\nc = [{} for i in range(N + 2)]\nfor i in range(N):\n    ix = i + 1\n    if A[i] <= 0:\n        c[S][ix] = -A[i]\n    else:\n        c[ix][T] = A[i]\n\n    for j in range(2 * ix, N + 1, ix):\n        c[ix][j] = 10 ** 15\n\nprint((gain - edmonds_karp(S, T, c)))\n", "import networkx as nx\n\nN=int(input())\n*A,=map(int,input().split())\nINF = 10**20\n\nG = nx.DiGraph()\nG.add_nodes_from(range(N+2))\nfor i in range(N):\n  if A[i]<0:\n    G.add_edge(0,i+1,capacity=-A[i])\n    G.add_edge(i+1,N+1,capacity=0)\n  else:\n    G.add_edge(0,i+1,capacity=0)\n    G.add_edge(i+1,N+1,capacity=A[i])\n  \nfor i in range(1,N//2+1):\n  for j in range(i,N+1,i):\n    G.add_edge(i,j,capacity=INF)\n    \nflow_value,flow_dict = nx.maximum_flow(G,0,N+1)\nprint(sum(filter(lambda x: x>0,A))-flow_value)", "import networkx as nx\n\nn = int(input())\nA = list(map(int, input().split()))\nG = nx.DiGraph()\n\nsource = \"source\"\nsink = \"sink\"\n\nfor i in range(1, n + 1):\n    if A[i - 1] <= 0:\n        G.add_edge(source, i, capacity=-A[i - 1])\n    else:\n        G.add_edge(i, sink, capacity=A[i - 1])\n\nfor i in range(1, n // 2 + 1):\n    for j in range(2 * i, n + 1, i):\n        G.add_edge(i, j)\n\ntry:\n    mincut = nx.minimum_cut_value(G, source, sink)\n    res = sum(a for a in A if a > 0)\n    print((res - mincut))\n\nexcept nx.NetworkXError:\n    print((0))\n", "# -*- coding: utf-8 -*-\n\nimport copy\nimport queue\n\nN = int(input())\na_list = list(map(int, input().split()))\n\ngain = sum([a for a in a_list if a > 0])\n\n# Flow network\nS = 0\nT = N + 1\nc = [{} for i in range(N + 2)]\nfor i, a in enumerate(a_list):\n    index = i + 1\n    if a <= 0:\n        c[S][index] = -a\n    else:\n        c[index][T] = a\n    for j in range(index, N + 1, index):\n        if not j == index:\n            c[index][j] = 10e15\n\n# Residual network\nr = copy.deepcopy(c)\n\n# Edmonds-Karp algorithm\nmax_flow = 0\nwhile True:\n    # Find path to T\n    q, s, p = queue.Queue(), {S}, None\n    q.put((S,))\n    findPath = False\n    while not q.empty() and not findPath:\n        cand_path = q.get(False)\n        for to, path in list(r[cand_path[-1]].items()):\n            if path == 0:\n                continue\n            elif to == T:\n                p = cand_path + (to,)\n                findPath = True\n            elif not to in s:\n                q.put(cand_path + (to,))\n                s.add(to)\n\n    if not findPath:\n        break\n\n    # Minimum flow\n    min_flow = min([r[p[i]][p[i+1]] for i in range(len(p)-1)])\n    max_flow += min_flow\n    for i in range(len(p)-1):\n        r[p[i]][p[i+1]] -= min_flow\n        if p[i] in r[p[i+1]]:\n            r[p[i+1]][p[i]] += min_flow\n        else:\n            r[p[i+1]][p[i]] = min_flow\n\nprint((gain - max_flow))\n", "import collections\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n    def add_edge(self, fr, to, cap):\n        self.g[fr].append([to, cap, len(self.g[to])])\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        self.g[v1].append([v2, cap1, len(self.g[v2])])\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\n    def bfs(self, s):\n        level = [-1]*self.n\n        deq = collections.deque()\n        level[s] = 0\n        deq.append(s)\n        while deq:\n            v = deq.popleft()\n            for e in self.g[v]:\n                if e[1]>0 and level[e[0]]<0:\n                    level[e[0]] = level[v] + 1\n                    deq.append(e[0])\n        self.level = level\n    def dfs(self, v, t, f):\n        if v==t: return f\n        es = self.g[v]\n        level = self.level\n        for i in range(self.it[v], len(self.g[v])):\n            e = es[i]\n            if e[1]>0 and level[v]<level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d\n                    self.g[e[0]][e[2]][1] += d\n                    self.it[v] = i\n                    return d\n        self.it[v] = len(self.g[v])\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0: break\n            self.it = [0]*self.n\n            while True:\n                f = self.dfs(s, t, 10**9+7)\n                if f>0:\n                    flow += f\n                else:\n                    break\n        return flow\n\nN = int(input())\n*A, = map(int, input().split())\ndinic = Dinic(N+2)\n\nINF = 10**18\n\nsu = 0\nfor x in range(1, N+1):\n    a = A[x-1]\n    if a > 0:\n        su += a\n        dinic.add_edge(0, x+1, a)\n    elif a < 0:\n        dinic.add_edge(x+1, 1, -a)\n\nfor x in range(1, N+1):\n    for y in range(x+x, N+1, x):\n        dinic.add_edge(y+1, x+1, INF)\n\nprint(su - dinic.max_flow(0, 1))", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**10\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf=10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # \u6df1\u3055\n        self.ite = [0]*v  # DFS\u3067\u306e\u63a2\u7d22\u304c\u6e08\u3093\u3067\u3044\u308b\u304b\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFS\u3067\u6df1\u3055\u6c7a\u5b9a,s\u304cstart\n        self.level = [-1]*self.v  # \u5fc5\u8981\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0\u304b\u3064to\u306e\u6df1\u3055\u672a\u5b9a\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFS\u3067\u5897\u52a0\u30d1\u30b9\u63a2\u7d22,v\u958b\u59cb\u3001t\u7d42\u70b9\u3001\u7dcf\u30d5\u30ed\u30fcf\n        if v==t:\n            return f\n        for i in range(self.ite[v], len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap\u6e1b\u5c11\n                    self.G[e[0]][e[2]][1] += d  # \u9006\u8fba\u306ecap\u5897\u52a0\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFS\u3067\u306e\u63a2\u7d22\u304c\u6e08\u3093\u3067\u3044\u308b\u304b\u5426\u304b\n            f = self.dfs(s,t,self.inf)\n            while f>0:\n                flow += f\n                f = self.dfs(s,t,self.inf)\n\nN = INT()\na = LIST()\n\nD = Dinic(N+2)\ns = 0\nt = N+1\n\nrw = 0\n\nfor i, x in enumerate(a):\n    if x <= 0:  # \u305d\u306e\u307e\u307e\u7f70\u91d1\n        D.add_edge(s, i+1, -x)\n    elif x > 0:  # \u3042\u3089\u304b\u3058\u3081x\u3082\u3089\u3063\u3066\u304a\u304d\uff0c\u3053\u308c\u304c\u7834\u58ca\u3055\u308c\u308b\u3068x\u306e\u7f70\u91d1\uff0c\n        D.add_edge(i+1, t, x)\n        rw += x\n    for j in range(2*(i+1), N+1, i+1):  # \u300ci\u304c\u7834\u58ca\u304b\u3064j\u304c\u975e\u7834\u58ca\u300d\u306f\u3060\u3081\n        D.add_edge(i+1, j, INF)\n\nprint((rw - D.max_flow(s, t)))\n", "from typing import NamedTuple, Optional, List, cast\n\n\nclass MFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.rev: Optional[MFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MFGraph._Edge(dst, cap)\n        re = MFGraph._Edge(src, 0)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MFGraph._Edge, e.rev)\n        return MFGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\n        assert 0 <= i < len(self._edges)\n        assert 0 <= new_flow <= new_cap\n        e = self._edges[i]\n        e.cap = new_cap - new_flow\n        assert e.rev is not None\n        e.rev.cap = new_flow\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        current_edge = [0] * self._n\n        level = [0] * self._n\n\n        def fill(arr: List[int], value: int) -> None:\n            for i in range(len(arr)):\n                arr[i] = value\n\n        def bfs() -> bool:\n            fill(level, self._n)\n            queue = []\n            q_front = 0\n            queue.append(s)\n            level[s] = 0\n            while q_front < len(queue):\n                v = queue[q_front]\n                q_front += 1\n                next_level = level[v] + 1\n                for e in self._g[v]:\n                    if e.cap == 0 or level[e.dst] <= next_level:\n                        continue\n                    level[e.dst] = next_level\n                    if e.dst == t:\n                        return True\n                    queue.append(e.dst)\n            return False\n\n        def dfs(lim: int) -> int:\n            stack = []\n            edge_stack: List[MFGraph._Edge] = []\n            stack.append(t)\n            while stack:\n                v = stack[-1]\n                if v == s:\n                    flow = min(lim, min(e.cap for e in edge_stack))\n                    for e in edge_stack:\n                        e.cap -= flow\n                        assert e.rev is not None\n                        e.rev.cap += flow\n                    return flow\n                next_level = level[v] - 1\n                while current_edge[v] < len(self._g[v]):\n                    e = self._g[v][current_edge[v]]\n                    re = cast(MFGraph._Edge, e.rev)\n                    if level[e.dst] != next_level or re.cap == 0:\n                        current_edge[v] += 1\n                        continue\n                    stack.append(e.dst)\n                    edge_stack.append(re)\n                    break\n                else:\n                    stack.pop()\n                    if edge_stack:\n                        edge_stack.pop()\n                    level[v] = self._n\n            return 0\n\n        flow = 0\n        while flow < flow_limit:\n            if not bfs():\n                break\n            fill(current_edge, 0)\n            while flow < flow_limit:\n                f = dfs(flow_limit - flow)\n                flow += f\n                if f == 0:\n                    break\n        return flow\n\n    def min_cut(self, s: int) -> List[bool]:\n        visited = [False] * self._n\n        stack = [s]\n        visited[s] = True\n        while stack:\n            v = stack.pop()\n            for e in self._g[v]:\n                if e.cap > 0 and not visited[e.dst]:\n                    visited[e.dst] = True\n                    stack.append(e.dst)\n        return visited\n\n\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nA = tuple(map(int, input().split()))\nG = MFGraph(n+2)\ns = 0\nt = n+1\nINF = 10**18\nans = 0\nfor i, a in enumerate(A, 1):\n    if a < 0:\n        G.add_edge(s, i, -a)\n    if a > 0:\n        G.add_edge(i, t, a)\n        ans += a\n    for j in range(2*i, n+1, i):\n        G.add_edge(i, j, INF)\nans -= G.flow(s, t)\nprint(ans)", "import sys\nfrom collections import deque\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nclass EDOMONDS_KARP():\n    def __init__(self, N, s, t):\n        self.N = N\n        self.s = s\n        self.t = t\n        self.cap = [[0]*N for _ in range(N)]\n        self.link = [[] for _ in range(N)]\n\n    def add_edge(self, u, v, c):\n        self.cap[u][v] = c\n        self.link[u].append(v)\n        self.link[v].append(u)\n\n    def max_flow(self):\n        N = self.N\n        s = self.s\n        t = self.t\n        f = 0\n        flow = [[0]*N for _ in range(N)]\n        while True:\n            m, prev = self.bfs(flow)\n            if m == 0:\n                break\n            f += m\n            v = t\n            while v != s:\n                u = prev[v]\n                flow[u][v] += m\n                flow[v][u] -=m\n                v = u\n        return (f, flow)\n\n    def bfs(self, flow):\n        N = self.N\n        s = self.s\n        t = self.t\n        cap = self.cap\n        link = self.link\n        prev = [-1]*N; prev[s] = -2\n        m = [0]*N; m[s] = float('inf')\n        q = deque([s])\n        while q:\n            u = q.popleft()\n            for v in link[u]:\n                if cap[u][v] - flow[u][v] > 0 and prev[v] == -1:\n                    prev[v] = u\n                    m[v] = min(m[u], cap[u][v] - flow[u][v])\n                    if v != t:\n                        q.append(v)\n                    else:\n                        return (m[t], prev)\n        return (0, prev)\n\ndef main():\n    INF = float('inf')\n\n    N = int(readline())\n    A = list(map(int, readline().split()))\n\n    S, T = 0, N + 1\n    EK = EDOMONDS_KARP(N + 2, S, T)\n    add = EK.add_edge\n    for i in range(1, N + 1):\n        a = A[i - 1]\n        if a <= 0:\n            add(S, i, -a)\n        else:\n            add(i, T, a)\n        for j in range(2, N // i + 1):\n            add(i, i*j, INF)\n    f, _ = EK.max_flow()\n    print((sum([x for x in A if x > 0]) - f))\n\ndef __starting_point():\n   main()\n\n__starting_point()", "from collections import deque\n\nN = int(input())\nA = list(map(int,input().split()))\n\nP = N+2\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\n\ndef add_edge(fr,to,cap):\n    es[fr].append([to,cap,len(es[to])])\n    es[to].append([fr,0,len(es[fr])-1])\n\nINF = float('inf')\nscore = 0\nfor i,a in enumerate(A):\n    if a > 0:\n        add_edge(0,i+1,a)\n        score += a\n    elif a < 0:\n        add_edge(i+1,N+1,-a)\nfor n in range(1,N//2+1):\n    for m in range(2*n,N+1,n):\n        add_edge(m,n,INF)\n\nlevel = [0] * P\niters = [0] * P\n\ndef dinic_max_flow(s,t):\n    nonlocal iters\n\n    def _bfs(s):\n        nonlocal level\n        level = [-1] * P\n        level[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for to,cap,rev in es[v]:\n                if cap > 0 and level[to] < 0:\n                    level[to] = level[v] + 1\n                    q.append(to)\n\n    def _dfs(v,t,f):\n        if v == t: return f\n        for i in range(iters[v],len(es[v])):\n            iters[v] += 1\n            to,cap,rev = es[v][i]\n            if es[v][i][1] > 0 and level[v] < level[to]:\n                d = _dfs(to,t,min(f,es[v][i][1]))\n                if d > 0:\n                    es[v][i][1] -= d #cap\n                    es[to][rev][1] += d\n                    return d\n        return 0\n\n    flow = 0\n    while True:\n        _bfs(s)\n        if level[t] < 0: return flow\n        iters = [0] * P\n        f = 0\n        while True:\n            f = _dfs(s,t,INF)\n            if f <= 0: break\n            flow += f\n\nprint(score - dinic_max_flow(0,N+1))", "def edmonds_karp(s, t, C):\n    '''\n    s, t: start, target (integer)\n    C: Array of dict ([from][to] -> length)\n    ret: maximum_flow (integer)\n    '''\n    import copy\n    import collections\n\n    r = copy.deepcopy(c)  # Residual network\n    maxf = 0\n\n    while True:\n        q, found = collections.deque(), False\n        q.append(([s], 10 ** 15))\n        while len(q) > 0 and not found:\n            p, minf = q.popleft()\n            for to, flow in list(r[p[-1]].items()):\n                if flow == 0:\n                    continue\n                elif to == t:\n                    p, minf = p + [to], min(flow, minf)\n                    found = True\n                    break\n                elif not to in p:\n                    q.append((p + [to], min(flow, minf)))\n\n        if not found:\n            break\n\n        for i in range(len(p) - 1):\n            r[p[i]][p[i + 1]] -= minf\n            if p[i] in r[p[i + 1]]:\n                r[p[i + 1]][p[i]] += minf\n            else:\n                r[p[i + 1]][p[i]] = minf\n        maxf += minf\n\n    return maxf\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\ngain = sum([max(a, 0) for a in A])\n\n# Flow network\nS, T = 0, N + 1\nc = [{} for i in range(N + 2)]\nfor i in range(N):\n    ix = i + 1\n    if A[i] <= 0:\n        c[S][ix] = -A[i]\n    else:\n        c[ix][T] = A[i]\n\n    for j in range(2 * ix, N + 1, ix):\n        c[ix][j] = 10 ** 15\n\nprint((gain - edmonds_karp(S, T, c)))\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Dinic:\n    def __init__(self,n,edges):\n        self.n=n\n        self.edges=[[] for _ in range(n)]\n        self.iter=[0]*n\n        self.level=None\n        self.graph(edges)\n    def graph(self,E):\n        edges=self.edges\n        for fr,to,cap in E:\n            edges[fr].append([to,cap,len(edges[to])])\n            edges[to].append([fr,0,len(edges[fr])-1])\n    def maxflow(self,source,sink):\n        max_flow=0\n        while True:\n            self.bfs(source)\n            if self.level[sink]<0:\n                return max_flow\n            self.iter=[0]*self.n\n            flow=self.dfs(source,sink,float('inf'))\n            while flow:\n                max_flow+=flow\n                flow=self.dfs(source,sink,float('inf'))\n    def bfs(self,source):\n        edges=self.edges\n        level=[-1]*self.n\n        level[source]=0\n        q=deque([source])\n        while q:\n            fr=q.popleft()\n            for to,cap,_ in edges[fr]:\n                if cap>0>level[to]:\n                    level[to]=level[fr]+1\n                    q.append(to)\n        self.level=level\n    def dfs(self,source,sink,flow):\n        if source==sink:\n            return flow\n        while self.iter[source]<len(self.edges[source]):\n            to,cap,rev=self.edges[source][self.iter[source]]\n            if cap>0 and self.level[source]<self.level[to]:\n                f=self.dfs(to,sink,min(flow,cap))\n                if f:\n                    self.edges[source][self.iter[source]][1]-=f\n                    self.edges[to][rev][1]+=f\n                    return f\n            self.iter[source]+=1\n        return 0\n\nn=int(input())\nA=list(map(int,input().split()))\nEdges=[]\ns=0\nfor i in range(n):\n    if A[i]<=0:\n        Edges.append((0,i+1,-A[i]))\n    else:\n        s+=A[i]\n        Edges.append((i+1,n+1,A[i]))\n    for j in range(2*(i+1),n+1,i+1):\n        Edges.append((i+1,j,float('inf')))\ndinic=Dinic(n+2,Edges)\nprint(s-dinic.maxflow(0,n+1))", "import copy\nimport collections\n\nN = int(input())\nA = list(map(int, input().split()))\n\ngain = sum([max(a, 0) for a in A])\n\n# Flow network\nS, T = 0, N + 1\nc = [{} for i in range(N + 2)]\nfor i in range(N):\n    ix = i + 1\n    if A[i] <= 0:\n        c[S][ix] = -A[i]\n    else:\n        c[ix][T] = A[i]\n\n    for j in range(2 * ix, N + 1, ix):\n        c[ix][j] = 10e15\n\n# Residual network\nr = copy.deepcopy(c)\n\n# Edmonds-Karp algorithm\nmax_flow = 0\nwhile True:\n    # Find path to T\n    q, s, p = collections.deque(), {S}, None\n    q.append((S,))\n    findPath = False\n    while not len(q) == 0 and not findPath:\n        cand_path = q.popleft()\n        for to, path in list(r[cand_path[-1]].items()):\n            if path == 0:\n                continue\n            elif to == T:\n                p = cand_path + (to,)\n                findPath = True\n            elif not to in s:\n                q.append(cand_path + (to,))\n                s.add(to)\n\n    if not findPath:\n        break\n\n    # Minimum flow\n    min_flow = min([r[p[i]][p[i + 1]] for i in range(len(p) - 1)])\n    max_flow += min_flow\n    for i in range(len(p) - 1):\n        r[p[i]][p[i + 1]] -= min_flow\n        if p[i] in r[p[i + 1]]:\n            r[p[i + 1]][p[i]] += min_flow\n        else:\n            r[p[i + 1]][p[i]] = min_flow\n\nprint((gain - max_flow))\n", "# \u30b0\u30e9\u30d5\u306b\u8fba\u3092\u8ffd\u52a0\u3059\u308b\ndef addEdge(adjL, vFr, vTo, cap):\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \u9006\u8fba\n\n\n# Ford-Fulkerson\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\ndef Ford_Fulkerson(adjL, vSt, vEn):\n\n    # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001DFS\u3067\u63a2\u7d22\u3059\u308b\n    def DFS(vNow, vEn, fNow):\n        if vNow == vEn:\n            # \u7d42\u70b9\u306b\u5230\u9054\u3057\u305f\u3089\u3001\u30d5\u30ed\u30fc\u306e\u5897\u52a0\u91cf\u3092\u8fd4\u3059\n            return fNow\n\n        used[vNow] = True\n\n        for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\n            if not used[v2] and cap > 0:\n                # \u672a\u63a2\u7d22\u306e\u9802\u70b9\u3078\u306e\u8fba\u306e\u5bb9\u91cf\u306b\u7a7a\u304d\u304c\u3042\u308b\u5834\u5408\u3001\u63a2\u7d22\u3059\u308b\n                df = DFS(v2, vEn, min(fNow, cap))\n                if df > 0:\n                    # \u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\u3092\u9061\u3063\u3066\u3001\u8fba\u306e\u30d5\u30ed\u30fc\u3092\u5909\u66f4\u3059\u308b\n                    adjL[vNow][i][1] -= df\n                    adjL[v2][iRev][1] += df\n                    return df\n\n        # \u73fe\u5728\u306e\u9802\u70b9\u304b\u3089\u306e\u63a2\u7d22\u5148\u304c\u306a\u3044\u5834\u5408\u3001\u30bc\u30ed\u3092\u8fd4\u3059\n        return 0\n\n\n    numV = len(adjL)\n    MaximumFlow = 0\n    while True:\n        # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001DFS\u3067\u63a2\u7d22\u3059\u308b\n        used = [False] * numV\n        df = DFS(vSt, vEn, float('inf'))\n\n        if df == 0:\n            # \u7d4c\u8def\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u3001\u6700\u5927\u30d5\u30ed\u30fc\u306e\u5024\u3092\u8fd4\u3059\n            return MaximumFlow\n\n        # \u30d5\u30ed\u30fc\u3092\u52a0\u7b97\u3059\u308b\n        MaximumFlow += df\n\n\nN = int(input())\nAs = list(map(int, input().split()))\n\nadjList = [[] for v in range(N + 2)]\nfor i, A in enumerate(As, 1):\n    if A <= 0:\n        addEdge(adjList, 0, i, -A)\n    else:\n        addEdge(adjList, i, N + 1, A)\n\nfor i in range(1, N + 1):\n    for j in range(2 * i, N + 1, i):\n        addEdge(adjList, i, j, float('inf'))\n\n# Ford-Fulkerson\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\nmf = Ford_Fulkerson(adjList, 0, N + 1)\nprint((sum([A for A in As if A > 0]) - mf))\n", "import collections\nclass Dinic:\n    def __init__(self, vnum):\n        self.edge = [[] for i in range(vnum)]\n        self.n = vnum\n        self.inf = float('inf')\n    def addedge(self, st, en, c):\n        self.edge[st].append([en, c, len(self.edge[en])])\n        self.edge[en].append([st, 0, len(self.edge[st])-1])\n    def bfs(self, vst):\n        dist = [-1]*self.n\n        dist[vst] = 0\n        Q = collections.deque([vst])\n        while Q:\n            nv = Q.popleft()\n            for vt, c, r in self.edge[nv]:\n                if dist[vt] == -1 and c > 0:\n                    dist[vt] = dist[nv] + 1\n                    Q.append(vt)\n        self.dist = dist\n    def dfs(self, nv, en, nf):\n        nextv = self.nextv\n        if nv == en:\n            return nf\n        dist = self.dist\n        ist = nextv[nv]\n        for i, (vt, c, r) in enumerate(self.edge[nv][ist:], ist):\n            if dist[nv] < dist[vt] and c > 0:\n                df = self.dfs(vt, en, min(nf, c))\n                if df > 0:\n                    self.edge[nv][i][1] -= df\n                    self.edge[vt][r][1] += df\n                    return df\n            nextv[nv] += 1\n        return 0\n    def getmf(self, st, en):\n        mf = 0\n        while True:\n            self.bfs(st)\n            if self.dist[en] == -1:\n                break\n            self.nextv = [0]*self.n\n            while True:\n                fl = self.dfs(st, en, self.inf)\n                if fl > 0:\n                    mf += fl\n                else:\n                    break\n        return mf\n\ndef inpl(): return [int(i) for i in input().split()]\nN = int(input())\na = inpl()\nK = Dinic(N+2)\ninf = float('inf')\nfor i, v in enumerate(a,1):\n    if v > 0:\n        K.addedge(i, N+1, v)\n    else:\n        K.addedge(0, i, -v)\nfor i in range(1,N+1):\n    for j in range(2*i, N+1, i):\n        K.addedge(i, j, inf)\n\nprint(sum([i for i in a if i > 0]) - K.getmf(0, N+1))", "from collections import deque\nimport sys\nsys.setrecursionlimit(200000)\nn = int(input())\nhouseki = list(map(int,input().split()))\ng = [[] for i in range(n+2)]\nINF = float(\"inf\")\nMAX = 0\nfor i in range(n):\n  if houseki[i] <= 0:\n    g[0].append([i+1,-houseki[i],len(g[i+1])])\n    g[i+1].append([0,0,len(g[0])-1])\n  else:\n    g[n+1].append([i+1,0,len(g[i+1])])\n    g[i+1].append([n+1,houseki[i],len(g[n+1])-1])\n    MAX += houseki[i]\n  j = (i+1)*2\n  while j <= n:\n    g[i+1].append([j,INF,len(g[j])])\n    g[j].append([i+1,0,len(g[i+1])-1])\n    j += i+1\ndef bfs(s,t):\n  nonlocal level\n  que = deque([s])\n  level[s] = 0\n  while que:\n    v = que.popleft()\n    lv = level[v] +1\n    for y, cap, rev in g[v]:\n      if cap and level[y] is None:\n        level[y] = lv\n        que.append(y)\n  return level[t] if level[t] else 0\ndef dfs(x,t,f):\n  if x == t:\n    return f\n  for j in range(it[x],len(g[x])):\n    it[x] = j\n    y, cap, rev = g[x][j]\n    if cap and level[x] < level[y]:\n      d = dfs(y,t,min(f,cap))\n      if d:\n        g[x][j][1] -= d\n        g[y][rev][1] += d\n        return d\n  return 0\n \nflow = 0\nf = INF = float(\"inf\")\nlevel = [None]*(n+2)\nwhile bfs(0,n+1):\n  it = [0]* (n+2)\n  f = INF\n  while f:\n    f = dfs(0,n+1,INF)\n    flow += f\n  level = [None]*(n+2)\nprint(MAX-flow)", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\nimport sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn = int(input())\na = list( map(int, input().split()))\n\nscore = 0\nINF = float('inf')\ngraph = Dinic(n+2)\n\nfor i in range(n):\n    if a[i]>0:\n        graph.add_edge(i+1,n+1,a[i])\n        score += a[i]\n    elif a[i]<0:\n        graph.add_edge(0,i+1,-a[i])\n\nfor i in range(1,n//2+1):\n    for j in range(2*i,n+1,i):\n        graph.add_edge(i,j,INF)\n\nprint(score-graph.flow(0,n+1))", "from collections import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nclass Dinic():\n    def __init__(self, n, s, t):\n        self.n, self.s, self.t = n, s, t\n        self.to = defaultdict(list)\n        self.level = [-1]\n        self.max_flow = -1\n\n    def add_edge(self, u, v, cap):\n        u_index_in_to_v = len(self.to[v])\n        v_index_in_to_u = len(self.to[u])\n        self.to[u].append([v, cap, u_index_in_to_v])\n        self.to[v].append([u, 0, v_index_in_to_u])\n\n    def set_level(self):\n        s = self.s\n        level = [-1] * self.n\n        level[s] = 0\n        q = deque()\n        q.append([s, 0])\n        while q:\n            u, u_level = q.popleft()\n            for v, cap, _ in self.to[u]:\n                if cap == 0: continue\n                if level[v] != -1: continue\n                level[v] = u_level + 1\n                if v == self.t:\n                    self.level=level\n                    return True\n                q.append([v, u_level + 1])\n        return False\n\n    def dfs(self, u=-1, flow_to_me=10 ** 16):\n        if u == -1: u = self.s\n        if u == self.t: return flow_to_me\n        flow_from_me = 0\n        u_level = self.level[u]\n        for utov_i, (v, cap, vtou_i) in enumerate(self.to[u]):\n            if self.level[v] != u_level + 1: continue\n            if cap == 0: continue\n            flow_to_v = self.dfs(v, min(cap, flow_to_me - flow_from_me))\n            if not flow_to_v: continue\n            flow_from_me += flow_to_v\n            self.to[u][utov_i][1] -= flow_to_v\n            self.to[v][vtou_i][1] += flow_to_v\n        return flow_from_me\n\n    def calculation(self):\n        res = 0\n        while self.set_level():\n            res += self.dfs()\n        return res\n\n    # \u3053\u308c\u304c\u51fa\u529b\u7528\n    def get_max_flow(self):\n        if self.max_flow == -1:\n            self.max_flow = self.calculation()\n        return self.max_flow\n\ndef main():\n    n = int(input())\n    aa = LI()\n    mf = Dinic(n + 2, 0, n + 1)\n    max_sum = 0\n    for i, a in enumerate(aa, 1):\n        if a > 0:\n            mf.add_edge(i, n + 1, a)\n            max_sum += a\n        else:\n            mf.add_edge(0, i, -a)\n    for i in range(1, n // 2 + 1):\n        for j in range(i * 2, n + 1, i):\n            mf.add_edge(i, j, 10 ** 12)\n    print(max(0, max_sum - mf.get_max_flow()))\n\nmain()\n", "from copy import deepcopy\nN = int(input())\na0 = list(map(int, input().split()))\n\nfor i in range(N, 0, -1):\n    if a0[i - 1] < 0:\n        tmp = 0\n        b = []\n        for j in range(1, 101):\n            if i * j - 1 >= N:\n                break\n            tmp += a0[i * j - 1]\n            b.append(i * j - 1)\n        if tmp < 0:\n            for j in b:\n                a0[j] = 0\n\nfor k1 in range(N, 0, -1):\n    for k2 in range(k1-1, 0, -1):\n        a = deepcopy(a0)\n        for j in range(1, 101):\n            if k1*j-1 >= N:\n                break\n            a[k1*j-1] = 0\n        for j in range(1, 101):\n            if k2*j-1 >= N:\n                break\n            a[k2*j-1] = 0\n        for i in range(N, 0, -1):\n            if a[i - 1] < 0:\n                tmp = 0\n                b = []\n                for j in range(1, 101):\n                    if i * j - 1 >= N:\n                        break\n                    tmp += a[i * j - 1]\n                    b.append(i * j - 1)\n                if tmp < 0:\n                    for j in b:\n                        a[j] = 0\n\n        for i in range(N, 0, -1):\n            if a0[i - 1] < 0:\n                tmp = 0\n                b = []\n                for j in range(1, 101):\n                    if i * j - 1 >= N:\n                        break\n                    tmp += a0[i * j - 1]\n                    b.append(i * j - 1)\n                if tmp < 0:\n                    for j in b:\n                        a0[j] = 0\n\n        if sum(a) > sum(a0):\n            a0 = a\n\nprint((sum(a0)))\n", "from typing import NamedTuple, Optional, List, cast\n\n\nclass MFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.rev: Optional[MFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MFGraph._Edge(dst, cap)\n        re = MFGraph._Edge(src, 0)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MFGraph._Edge, e.rev)\n        return MFGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\n        assert 0 <= i < len(self._edges)\n        assert 0 <= new_flow <= new_cap\n        e = self._edges[i]\n        e.cap = new_cap - new_flow\n        assert e.rev is not None\n        e.rev.cap = new_flow\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        current_edge = [0] * self._n\n        level = [0] * self._n\n\n        def fill(arr: List[int], value: int) -> None:\n            for i in range(len(arr)):\n                arr[i] = value\n\n        def bfs() -> bool:\n            fill(level, self._n)\n            queue = []\n            q_front = 0\n            queue.append(s)\n            level[s] = 0\n            while q_front < len(queue):\n                v = queue[q_front]\n                q_front += 1\n                next_level = level[v] + 1\n                for e in self._g[v]:\n                    if e.cap == 0 or level[e.dst] <= next_level:\n                        continue\n                    level[e.dst] = next_level\n                    if e.dst == t:\n                        return True\n                    queue.append(e.dst)\n            return False\n\n        def dfs(lim: int) -> int:\n            stack = []\n            edge_stack: List[MFGraph._Edge] = []\n            stack.append(t)\n            while stack:\n                v = stack[-1]\n                if v == s:\n                    flow = min(lim, min(e.cap for e in edge_stack))\n                    for e in edge_stack:\n                        e.cap -= flow\n                        assert e.rev is not None\n                        e.rev.cap += flow\n                    return flow\n                next_level = level[v] - 1\n                while current_edge[v] < len(self._g[v]):\n                    e = self._g[v][current_edge[v]]\n                    re = cast(MFGraph._Edge, e.rev)\n                    if level[e.dst] != next_level or re.cap == 0:\n                        current_edge[v] += 1\n                        continue\n                    stack.append(e.dst)\n                    edge_stack.append(re)\n                    break\n                else:\n                    stack.pop()\n                    if edge_stack:\n                        edge_stack.pop()\n                    level[v] = self._n\n            return 0\n\n        flow = 0\n        while flow < flow_limit:\n            if not bfs():\n                break\n            fill(current_edge, 0)\n            while flow < flow_limit:\n                f = dfs(flow_limit - flow)\n                flow += f\n                if f == 0:\n                    break\n        return flow\n\n    def min_cut(self, s: int) -> List[bool]:\n        visited = [False] * self._n\n        stack = [s]\n        visited[s] = True\n        while stack:\n            v = stack.pop()\n            for e in self._g[v]:\n                if e.cap > 0 and not visited[e.dst]:\n                    visited[e.dst] = True\n                    stack.append(e.dst)\n        return visited\n\n\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nA = tuple(map(int, input().split()))\nG = MFGraph(n+2)\ns = 0\nt = n+1\nINF = 10**18\nans = 0\nfor i, a in enumerate(A, 1):\n    if a < 0:\n        G.add_edge(s, i, -a)\n    if a > 0:\n        G.add_edge(i, t, a)\n        ans += a\n    for j in range(2*i, n+1, i):\n        G.add_edge(i, j, INF)\nans -= G.flow(s, t)\nprint(ans)", "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, v, inf=10**9 + 7):\n        self.V = v\n        self.inf = inf\n        self.G = [list() for _ in range(v)]\n        self.level = [-1 for _ in range(v)]\n        self.iter = [0] * v\n\n    def addedge(self, fr, to, cap):\n        \"\"\"\n        G[fr] = [to, cap, rev]\n        \"\"\"\n        go = [to, cap, None]\n        go[2] = back = [fr, 0, go]\n        self.G[fr].append(go)\n        self.G[to].append(back)\n\n    def bfs(self, st, en):\n        q = deque([st])\n        self.level = [-1 for _ in range(self.V)]\n        self.level[st] = 0\n        while q:\n            cur = q.popleft()\n            for x, cap, _ in self.G[cur]:\n                if cap and self.level[x] < 0:\n                    self.level[x] = self.level[cur] + 1\n                    q.append(x)\n        return self.level[en] > 0\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while self.bfs(s, t):\n            self.iter = list(map(iter, self.G))\n            f = self.dfs(s, t, self.inf)\n            while f:\n                flow += f\n                f = self.dfs(s, t, self.inf)\n        return flow\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    D = Dinic(n+2)\n    ret = 0\n    for i,e in enumerate(a, 1):\n      if e > 0:\n        ret += e\n        D.addedge(i, n+1, e)\n      else:\n        D.addedge(0, i, -e)\n    for i in range(1, n//2 + 1):\n      for j in range(i*2, n+1, i):\n        D.addedge(i, j, 10**12)\n    loss = D.flow(0, n+1)\n    return ret - loss\n\nprint(main())", "N = int(input())\nAs = list(map(int, input().split()))\n\ndef func(Bs):\n    for x in range(N):\n        if Bs[x] >= 0: continue\n        if max(Bs[x::x + 1]) <= 0:\n            Bs[x] = 0\n\nfunc(As)\n\nzs = [27, 29, 31, 33] + list(range(34, 51))\nfor x in zs:\n    if sum(As[x - 1::x]) < 0:\n        for i in range(x - 1, N, x):\n            As[i] = 0\n\nns = [1, 2, 4, 8, 16, 32] + [3, 6, 9, 12, 18, 24, 27, 36, 48] \\\n    + [5, 10, 15, 20, 25, 30, 40, 45, 50] + [7, 14, 21, 28, 35, 42, 49] \\\n    + [11, 22, 33, 44] + [13, 26, 39] + [17, 34] + [19, 38] + [23, 46] \\\n    + [29, 31, 37, 41, 43, 47]\n\nmemo = {}\nmemo[tuple(As)] = sum(As)\n\ncs = [n - 1 for n in ns if n <= N and n not in zs and As[n - 1] < 0]\nfor c in cs:\n    for tupleA in list(memo.keys()):\n        if tupleA[c] == 0:\n            continue\n\n        listA = list(tupleA)\n        for x in range(c, N, c + 1):\n            listA[x] = 0\n\n        func(listA)\n        memo[tuple(listA)] = sum(listA)\n\nprint((max(memo.values())))\n", "#!/usr/bin/env python3\n\nfrom sys import stdin\nfrom fractions import gcd\t# math.gcd is introduced in python 3.5\nfrom functools import reduce\n\ndef lcm(x, y):\n    \"\"\"The least common multiple of x and y.\"\"\"\n    return x * (y // gcd(x, y))\n\ndef multiples(t, N):\n    \"\"\"Set of multiples (<= N) of some x in t.\"\"\"\n    return set(i for x in t for i in range(x, N + 1, x))\n\ndef value(a, t):\n    \"\"\"The value of the jewels that are labeled a multiple of some x in t.\"\"\"\n    return sum(a[i - 1] for i in multiples(t, len(a)))\n\ndef remove(a, t):\n    \"\"\"Break all jewels that are labeled a multiple of some x in t.\"\"\"\n    for i in multiples(t, len(a)):\n        a[i - 1] = 0\n\ndef tuples(m, N):\n    \"\"\"\n    List of tuples over {m,...,N}.\n    Each tuple t in the list satisfies that:\n        the lcm of t is less than or equal to N, and\n        t does not contain a proper multiple of some j in t.\n    \"\"\"\n    if m > N: return [()]\n    ts = tuples(m + 1, N)\n    us = [(m,) + t for t in ts\n          if reduce(lcm, t, m) <= N and all(j % m != 0 for j in t)]\n    ts.extend(us)\n    return ts\n\ndef solve(a):\n    N = len(a)\n    for t in tuples(1, N):\n        if value(a, t) < 0: remove(a, t)\n    return sum(a)\n\nN = int(stdin.readline())\na = [int(w) for w in stdin.readline().split()]\nif len(a) != N: raise\nprint((solve(a)))\n", "from collections import deque\n \n \nclass Dinic:\n    def __init__(self, n: int):\n        \"\"\"\u9802\u70b9\u6570\u3092n\u3068\u3059\u308b\"\"\"\n        self.INF = float(\"inf\")\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n \n    def add_edge(self, _from: int, to: int, capacity: int):\n        \"\"\"\u6b8b\u4f59\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\n        1. _from\u304b\u3089to\u3078\u5411\u304b\u3046\u5bb9\u91cfcapacity\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        2. to\u304b\u3089_from\u3078\u5411\u304b\u3046\u5bb9\u91cf0\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        \"\"\"\n        forward = [to, capacity, None]\n        forward[2] = backward = [_from, 0, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n \n    def bfs(self, s: int, t: int):\n        \"\"\"capacity\u304c\u6b63\u306e\u8fba\u306e\u307f\u3092\u901a\u3063\u3066s\u304b\u3089t\u306b\u79fb\u52d5\u53ef\u80fd\u304b\u3069\u3046\u304bBFS\u3067\u63a2\u7d22\n        level: s\u304b\u3089\u306e\u6700\u77ed\u8def\u306e\u9577\u3055\n        \"\"\"\n        self.level = [-1] * self.n\n        q = deque([s])\n        self.level[s] = 0\n        while q:\n            _from = q.popleft()\n            for to, capacity, _ in self.graph[_from]:\n                if capacity > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[_from] + 1\n                    q.append(to)\n \n    def dfs(self, _from: int, t: int, f: int) -> int:\n        \"\"\"\u6d41\u91cf\u304c\u5897\u52a0\u3059\u308b\u30d1\u30b9\u3092DFS\u3067\u63a2\u7d22\n        BFS\u306b\u3088\u3063\u3066\u4f5c\u3089\u308c\u305f\u6700\u77ed\u8def\u306b\u5f93\u3063\u3066f\u3092\u66f4\u65b0\u3059\u308b\n        \"\"\"\n        if _from == t:\n            return f\n        for edge in self.itr[_from]:\n            to, capacity, reverse_edge = edge\n            if capacity > 0 and self.level[_from] < self.level[to]:\n                d = self.dfs(to, t, min(f, capacity))\n                if d > 0:\n                    edge[1] -= d\n                    reverse_edge[1] += d\n                    return d\n        return 0\n \n    def max_flow(self, s: int, t: int):\n        \"\"\"s-t\u30d1\u30b9\u4e0a\u306e\u6700\u5927\u6d41\u3092\u6c42\u3081\u308b\n        \u8a08\u7b97\u91cf: O(|E||V|^2)\n        \"\"\"\n        flow = 0\n        while True:\n            self.bfs(s, t)\n            if self.level[t] < 0:\n                break\n            self.itr = list(map(iter, self.graph))\n            f = self.dfs(s, t, self.INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, self.INF)\n        return flow\n\nn = int(input())\na = list(map(int, input().split()))\n\ndinic = Dinic(n + 2)\ns = 0\nt = n + 1\n_sum = 0\nfor i in range(0, n):\n    if a[i] > 0:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, a[i])\n        _sum += a[i]\n    elif a[i] < 0:\n        dinic.add_edge(s, i+1, -a[i])\n        dinic.add_edge(i+1, t, 0)\n    else:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, 0)\n\nfor i in range(n):\n    num = i+1\n    next_num = 2 * num\n    while next_num <= n:\n        dinic.add_edge(num, next_num, 10**18)\n        next_num += num\n\nprint(_sum - dinic.max_flow(s, t))", "from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nINF = 1 << 60\n\ndef main():\n  N = read()\n  A = reads()\n  offset = sum(a for a in A if a > 0)\n  di = dinic(N+2) # 0: source, N+1: target\n  for i in range(1, N+1):\n    a = A[i-1]\n    if a <= 0:\n      di.add_edge(0, i, -a)\n    else:\n      di.add_edge(i, N+1, a)\n    for j in range(2*i, N+1, i):\n      di.add_edge(i, j, INF)\n  ans = offset - di.max_flow(0, N+1)\n  print(ans)\n\nclass dinic:\n  def __init__(self, N): self.size = N; self.edges = [[] for _ in range(N)]\n  def add_edge(self, u, v, c): self.edges[u].append((v, c)); self.edges[v].append((u, 0))\n  def bfs(self, cap, s):\n    N = self.size; edges = self.edges\n    level = [-1] * N; level[s] = 0\n    que = deque([s])\n    while len(que) > 0:\n      u = que.popleft()\n      for v, _ in edges[u]:\n        if cap[u][v] > 0 and level[v] < 0: level[v] = level[u] + 1; que.append(v)\n    return level\n  def dfs(self, cap, itr, level, u, t, f):\n    N = self.size; edges = self.edges\n    if u == t: return f\n    for i in range(itr[u], len(edges[u])):\n      itr[u] = i\n      v, _ = edges[u][i]\n      if cap[u][v] > 0 and level[u] < level[v]:\n        d = self.dfs(cap, itr, level, v, t, min(f, cap[u][v]))\n        if d > 0: cap[u][v] -= d; cap[v][u] += d; return d\n    return 0\n  def max_flow(self, s, t):\n    N = self.size; edges = self.edges; cap = [[0] * N for _ in range(N)]\n    for u in range(N):\n      for v, c in edges[u]: cap[u][v] += c\n    flow = 0\n    while True:\n      level = self.bfs(cap, s)\n      if level[t] < 0: return flow\n      itr = [0] * N\n      while True:\n        f = self.dfs(cap, itr, level, s, t, INF)\n        if f <= 0: break\n        flow += f\n\nmain()", "#!/usr/bin/env python3\n\nfrom sys import stdin\nfrom fractions import gcd\t# math.gcd is introduced in python 3.5\nfrom functools import reduce\n\ndef lcm(x, y):\n    \"\"\"The least common multiple of x and y.\"\"\"\n    return x * (y // gcd(x, y))\n\ndef flatten(ls):\n    \"\"\"Flatten a list of lists.\"\"\"\n    return [x for l in ls for x in l]\n\n\ndef multiples(t, N):\n    \"\"\"Set of multiples (<= N) of some x in t.\"\"\"\n    return set(i for x in t for i in range(x, N + 1, x))\n\ndef value(a, t):\n    \"\"\"The value of the jewels that are labeled a multiple of some x in t.\"\"\"\n    return sum(a[i - 1] for i in multiples(t, len(a)))\n\ndef remove(a, t):\n    \"\"\"Break all jewels that are labeled a multiple of some x in t.\"\"\"\n    for i in multiples(t, len(a)):\n        a[i - 1] = 0\n\n\ndef tuples(m, N):\n    \"\"\"\n    [[m'-tuples over {1,2,3,...,N}] for 0 <= m' <= m].\n    The lcm of the m-tuple is less than or equal to N.\n    Each m-tuple does not contain a multiple of some j in the tuple.\n    \"\"\"\n    if m == 0: return [[()]]\n    ts = tuples(m - 1, N)\n    if ts[-1] == []: return ts\n\n    ls = []\n    for t in ts[-1]:\n        lc = reduce(lcm, t) if len(t) > 0 else 1\n        mi = min(t)         if len(t) > 0 else N + 1\n        for i in range(mi - 1, 0, -1):\n            if lcm(lc, i) > N: continue\n            if any(j % i == 0 for j in t): continue\n            ls.append((i,) + t)  # smaller label first\n    ts.append(ls)\n    return ts\n\ndef solve(a):\n    N = len(a)\n    tl = flatten(tuples(N, N))\n    # break jewels with larger labels first.\n    tl.sort(key=lambda t: [-x for x in t])\n    for t in tl:\n        if value(a, t) < 0: remove(a, t)\n    return sum(a)\n\nN = int(stdin.readline())\na = [int(w) for w in stdin.readline().split()]\nif len(a) != N: raise\nprint((solve(a)))\n", "from collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]#(\u884c\u304d\u5148\u3001\u5bb9\u91cf\u3001\u9006\u8fba\u306e\u53c2\u7167)\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\nN = int(input())\na = list(map(int, input().split()))\nD = Dinic(N+2)\ninf = 10**18\nprofit = 0\ncost = 0\nfor i in range(N):\n    if a[i]>=0:\n        D.add_edge(i, N+1, a[i])\n    else:\n        D.add_edge(N, i, -a[i])\n        cost+=a[i]\n    profit+=abs(a[i])\n    \n\nfor i in range(1, N+1):\n    for k in range(2, N//i+1):\n        D.add_edge(i-1, i*k-1, inf)\nf = D.flow(N, N+1)\nprint((profit-f+cost))\n", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    # Dinic's algorithm\n    from collections import deque\n    class Dinic:\n        def __init__(self, N):\n            self.N = N\n            self.G = [[] for i in range(N)]\n\n        def add_edge(self, fr, to, cap):\n            forward = [to, cap, None]\n            forward[2] = backward = [fr, 0, forward]\n            self.G[fr].append(forward)\n            self.G[to].append(backward)\n\n        def add_multi_edge(self, v1, v2, cap1, cap2):\n            edge1 = [v2, cap1, None]\n            edge1[2] = edge2 = [v1, cap2, edge1]\n            self.G[v1].append(edge1)\n            self.G[v2].append(edge2)\n\n        def bfs(self, s, t):\n            self.level = level = [None] * self.N\n            deq = deque([s])\n            level[s] = 0\n            G = self.G\n            while deq:\n                v = deq.popleft()\n                lv = level[v] + 1\n                for w, cap, _ in G[v]:\n                    if cap and level[w] is None:\n                        level[w] = lv\n                        deq.append(w)\n            return level[t] is not None\n\n        def dfs(self, v, t, f):\n            if v == t:\n                return f\n            level = self.level\n            for e in self.it[v]:\n                w, cap, rev = e\n                if cap and level[v] < level[w]:\n                    d = self.dfs(w, t, min(f, cap))\n                    if d:\n                        e[1] -= d\n                        rev[1] += d\n                        return d\n            return 0\n\n        def flow(self, s, t):\n            flow = 0\n            INF = 10 ** 9 + 7\n            G = self.G\n            while self.bfs(s, t):\n                *self.it, = map(iter, self.G)\n                f = INF\n                while f:\n                    f = self.dfs(s, t, INF)\n                    flow += f\n            return flow\n\n    inf = 1<<40\n    N = int(input())\n    A = list(map(int, input().split()))\n    dinic = Dinic(N+2)\n    ans = 0\n    for i, a in enumerate(A):\n        if a > 0:\n            ans += a\n            #dinic.add_edge(0, i+1, 0)\n            dinic.add_edge(i+1, N+1, a)\n        else:\n            dinic.add_edge(0, i+1, -a)\n            #dinic.add_edge(i+1, N+1, 0)\n    for i in range(1, N+1):\n        for k in range(1, N+1):\n            if i*k > N:\n                break\n            dinic.add_edge(i, i*k, inf)\n\n    print(ans - dinic.flow(0, N+1))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import networkx as nx\n\nn = int(input())\nA = list(map(int, input().split()))\nG = nx.DiGraph()\n\nsource = \"source\"\nsink = \"sink\"\n\nfor i in range(1, n + 1):\n    x, y = A[i - 1], 0\n    if A[i - 1] < 0:\n        x, y = y, -x\n    G.add_edge(source, i, capacity=x)\n    G.add_edge(i, sink, capacity=y)\n\nfor i in range(1, n // 2 + 1):\n    for j in range(2 * i, n + 1, i):\n        # print(i, j)\n        G.add_edge(j, i)\n\ntry:\n    mincut, cut_dic = nx.minimum_cut(G, source, sink)\n    res = sum(a for a in A if a > 0)\n    print((res - mincut))\n\n\nexcept nx.NetworkXError:\n    print((0))\n", "from collections import deque\nn = int(input())\na = list(map(int, input().split()))\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\ngraph = Dinic(n + 2)\nfor i in range(n):\n    if a[i] >= 0:\n        graph.add_edge(i, n, a[i])\n        continue\n    graph.add_edge(n + 1, i, -a[i])\nfor i in range(1, n + 1):\n    for j in range(2 * i, n + 1, i):\n        graph.add_edge(i-1, j-1, 10**11)\nprint((sum([max(0, i) for i in a])-graph.flow(n+1, n)))\n", "from collections import deque\nclass Dinic:\n    def __init__(self,number):\n        self.table = [[0]*(number) for i in range(number)]\n        self.n=number\n    \n    def add(self,x,y,f):\n        self.table[x][y]=f\n    \n    def bfs(self,x):\n        self.visit[x]=0\n        h=deque()\n        h.append(x)\n        while h:\n            y=h.popleft()\n            for i in range(self.n):\n                if self.visit[i]==-1 and self.table[y][i]>0:\n                    self.visit[i]=self.visit[y]+1\n                    h.append(i)\n        return 0\n    \n    def dinic(self,s,t,f):\n        if s==t:\n            return f\n        for i in range(self.n):\n            if self.visit[i]>self.visit[s] and self.table[s][i]>0:\n                df = self.dinic(i,t,min(f,self.table[s][i]))\n                if df>0:\n                    self.table[s][i]-=df\n                    self.table[i][s]+=df\n                    return df\n        return 0\n    \n    def flow(self,s,t):\n        ans=0\n        inf=10**20\n        while True:\n            self.visit=[-1]*(self.n)\n            self.bfs(s)\n            if self.visit[t]==-1:\n                break\n            while True:\n                df=self.dinic(s,t,inf)\n                if df==0:\n                    break\n                ans+=df\n        return ans\nN=int(input())\nP=[int(i) for i in input().split()]\ninf=10**20\nmaxflow=Dinic(N+2)\nfor i in range(1,N+1):\n    if P[i-1]>0:\n        maxflow.add(i,N+1,P[i-1])\n    else:\n        maxflow.add(0,i,-P[i-1])\n    for j in range(2*i,N+1,i):\n        maxflow.add(i,j,inf)\nans=maxflow.flow(0,N+1)\nnum=sum([p for p in P if p>0])\nprint(num-ans)", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\n\nclass MaxFlow(object):\n    def __init__(self, n):\n        self.n = n\n        self.E = [[] for _ in range(n)]\n\n    def add_edge(self, u, v, cap):\n        e = [v, cap, 0]\n        rev = [u, 0, e]\n        e[-1] = rev\n        self.E[u].append(e)\n        self.E[v].append(rev)\n\n    def _bfs(self, s, t):\n        self._level = level = [-1] * self.n\n        level[s] = 0\n        queue = [s]\n        for v in queue:\n            for nv, cap, _ in self.E[v]:\n                if cap and level[nv] == -1:\n                    level[nv] = level[v] + 1\n                    if nv == t:\n                        return True\n                    queue.append(nv)\n        return level[t] != -1\n\n    def _dfs(self, s, t):\n        E, level, it = self.E, self._level, self._iter\n        stack = [(s, INF)]\n        while stack:\n            v, f = stack[-1]\n            if v == t:\n                for v, _ in stack[:-1]:\n                    E[v][it[v]][1] -= f\n                    E[v][it[v]][-1][1] += f\n                return f\n            while it[v] < len(E[v]):\n                nv, cap, _ = E[v][it[v]]\n                if cap and level[v] < level[nv]:\n                    stack.append((nv, min(f, cap)))\n                    break\n                it[v] += 1\n            else:\n                stack.pop()\n                level[v] = 0\n        return 0\n\n    def solve(self, s, t):\n        res = 0\n        while self._bfs(s, t):\n            self._iter = [0] * self.n\n            f = 1\n            while f:\n                f = self._dfs(s, t)\n                res += f\n        return res\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    s, t = 0, n + 1\n    flow = MaxFlow(n + 2)\n    ans = sum(a for a in A if a > 0)\n\n    for u in range(1, n + 1):\n        for v in range(2 * u, n + 1, u):\n            flow.add_edge(u, v, INF)\n\n    for v, a in enumerate(A, 1):\n        flow.add_edge(s, v, max(-a, 0))\n        flow.add_edge(v, t, max(a, 0))\n\n    ans -= flow.solve(s, t)\n    print(ans)\nresolve()", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nimport networkx as nx\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    total = sum(a for a in A if a > 0)\n\n    # minimum cut\n    G = nx.DiGraph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_nodes_from([\"source\", \"termination\"])\n    for i, a in enumerate(A, 1):\n        if a >= 0:\n            G.add_edge(\"source\", i, capacity = 0)\n            G.add_edge(i, \"termination\", capacity = a)\n        else:\n            G.add_edge(\"source\", i, capacity = -a)\n            G.add_edge(i, \"termination\", capacity = 0)\n\n    for i in range(1, n + 1):\n        for j in range(2 * i, n + 1, i):\n            G.add_edge(i, j, capacity = INF)\n\n    flow = nx.algorithms.flow.maximum_flow_value(G, \"source\", \"termination\")\n    print(total - flow)\nresolve()", "import networkx as nx\nfrom  networkx.algorithms.flow import dinitz\n\nn = int(input())\nA = list(map(int, input().split()))\nG = nx.DiGraph()\n\nsource = \"source\"\nsink = \"sink\"\n\nfor i in range(1, n + 1):\n    if A[i - 1] <= 0:\n        G.add_edge(source, i, capacity=-A[i - 1])\n    else:\n        G.add_edge(i, sink, capacity=A[i - 1])\n\nfor i in range(1, n // 2 + 1):\n    for j in range(2 * i, n + 1, i):\n        G.add_edge(i, j)\n\ntry:\n    # mincut = nx.minimum_cut_value(G, source, sink)\n    R = dinitz(G, source, sink)\n    # print(R, R.graph)\n    res = sum(a for a in A if a > 0)\n    # print(res - mincut)\n    print((res - R.graph[\"flow_value\"]))\n\nexcept nx.NetworkXError:\n    print((0))\n", "\nfrom collections import deque\n\n\nclass Dinic:\n    def __init__(self, N, inf):\n        self.N = N\n        self.inf = inf\n        self.G = [[] for _ in range(N)]\n        self.level = [0]*N\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s):\n        self.level = [-1]*self.N\n        deq = deque([s])\n        self.level[s] = 0\n        while deq:\n            v = deq.pop()\n            lv = self.level[v] + 1\n            for w, cap, _ in self.G[v]:\n                if cap > 0 and self.level[w] == -1:\n                    self.level[w] = lv\n                    deq.appendleft(w)\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap > 0 and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d > 0:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] == -1:\n                return flow\n            *self.iter, = list(map(iter, self.G))\n            f = self.inf\n            while f > 0:\n                f = self.dfs(s, t, self.inf)\n                flow += f\n\n\nimport sys\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\u7a7a\u767d\u3042\u308a\n\n\nN = I()\nA = [0] + LI()\nans = sum(A[i] for i in range(1,N+1) if A[i] > 0)\n\ninf = 10**18\nDi = Dinic(N+2,inf)\ns,t = 0,N+1\n\nfor i in range(1,N+1):\n    Di.add_edge(s,i,max(0,-A[i]))\n    Di.add_edge(i,t,max(0,A[i]))\n\nfor i in range(1,N//2+1):\n    for j in range(2*i,N+1,i):\n        Di.add_edge(i,j,inf)\n\nprint((ans-Di.flow(s,t)))\n", "#!/usr/bin/env python3\n\nfrom sys import stdin\nfrom fractions import gcd\t# math.gcd is introduced by python 3.5\nfrom functools import reduce\n\ndef lcm(x, y):\n  \"\"\"The least common multiple of x and y.\"\"\"\n  return x * (y // gcd(x, y))\n\ndef tuples(m, N):\n  \"\"\"\n  List of list of m'-tuples over {1,2,3,...,N} for 0 <= m' <= m.\n  Every m-tuple does not contain a multiple of some j in the tuple.\n  The lcm of the m-tuple is less than or equal to N.\n  \"\"\"\n  if m == 0: return [[()]]\n  ts = tuples(m - 1, N)\n  if len(ts[-1]) == 0: return ts\n\n  ls = []\n  for t in ts[-1]:\n    lc = reduce(lcm, t) if len(t) > 0 else 1\n    mi = min(t)         if len(t) > 0 else N + 1\n    for i in range(mi - 1, 0, -1):\n      if any(j % i == 0 for j in t): continue\n      if lcm(lc, i) > N: continue\n      ls.append((i,) + t)\n  ts.append(ls)\n  return ts\n\ndef value(a, t):\n  \"\"\"\n  Total value of the jewels that are labeled a multiple of x\n  for some x in t.\n  \"\"\"\n  used = [False for i in a]\n  v = 0\n  for x in t:\n    for i in range(x - 1, len(a), x):\n      if not used[i]:\n        v = v + a[i]\n        used[i] = True\n  return v\n\ndef remove(a, t):\n  \"\"\"\n  Break all jewels that are labeled a multiple of x for some x in t.\n  \"\"\"\n  for x in t:\n    for i in range(x - 1, len(a), x):\n      a[i] = 0\n\ndef flatten(ls):\n  \"\"\"Flatten a list of lists.\"\"\"\n  return [x for l in ls for x in l]\n\ndef solve(a):\n  n = len(a)\n  tl = flatten(tuples(n, n))\n  tl.sort(key=lambda t: [-x for x in t])\n  for t in tl:\n    if value(a, t) < 0: remove(a, t)\n  return sum(a)\n\nN = int(stdin.readline())\na = [int(w) for w in stdin.readline().split()]\nif len(a) != N: raise\nprint((solve(a)))\n", "from  collections import deque\nN=int(input())\nP=[int(i) for i in input().split()]\ninf = 10**20\ntable=[[0]*(N+2) for i in range(N+2)]\nfor i in range(1,N+1):\n    if P[i-1]>0:\n        table[i][N+1]=P[i-1]\n    else:\n        table[0][i]=-P[i-1]\n    for j in range(2*i,N+1,i):\n        table[i][j]=inf\n        \ndef bfs(x):\n    visit[x]=0\n    h=deque()\n    h.append(x)\n    while h:\n        y=h.popleft()\n        for i in range(N+2):\n            if visit[i]==-1 and table[y][i]>0:\n                visit[i]=visit[y]+1\n                h.append(i)\n    return 0\n\ndef dinic(s,t,f):\n    if s==t:\n        return f\n    for i in range(N+2):\n        if visit[i]>visit[s] and table[s][i]>0:\n            df = dinic(i,t,min(f,table[s][i]))\n            if df>0:\n                table[s][i]-=df\n                table[i][s]+=df\n                return df\n    return 0\n\nans=0\nwhile True:\n    visit=[-1]*(N+2)\n    bfs(0)\n    #print(table,visit)\n    if visit[N+1]==-1:\n        break\n    while True:\n        df=dinic(0,N+1,inf)\n        if df==0:\n            break\n        ans+=df\n        #print(ans)\nnum=sum([p for p in P if p>0])\nprint(num-ans)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass Dinic:\n    \"\"\" \u6700\u5927\u6d41(Dinic) \"\"\"\n\n    INF = 10 ** 18\n\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n \n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n \n    def bfs(self, s):\n        from collections import deque\n\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, _ in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n \n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n \n    def max_flow(self, s, t):\n        INF = Dinic.INF\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\nN = INT()\nA = LIST()\n\n# \u6700\u5927\u6d41\u3092\u6700\u5c0f\u30ab\u30c3\u30c8\u306b\u4f7f\u7528\u3001\u6d41\u91cf\u304c\u30b3\u30b9\u30c8\u3068\u307f\u306a\u305b\u308b\ndinic = Dinic(N+2)\ns = N\nt = N + 1\ntotal = 0\nfor i, a in enumerate(A):\n    if a < 0:\n        # \u5143\u3005\u640d\u5931\u306e\u90e8\u5206\u306f\u305d\u306e\u307e\u307e\u30b3\u30b9\u30c8\u3068\u3057\u3066\u6271\u3046\n        dinic.add_link(s, i, -a)\n    elif a > 0:\n        # \u5229\u76ca\u306b\u3064\u3044\u3066\u306f\u3001\u4e88\u3081\u5229\u76ca\u3092\u5f97\u3089\u308c\u308b\u3068\u3057\u3066\u3001\u5f97\u3089\u308c\u306a\u304f\u306a\u308b\u65b9\u306e\u9078\u629e\u80a2\u306b\u30b3\u30b9\u30c8\u3068\u3057\u3066\u8db3\u3059\n        dinic.add_link(i, t, a)\n        total += a\n\nfor i in range(1, N+1):\n    j = i\n    while j <= N:\n        # \u5236\u7d04\u3067\u7570\u306a\u308b\u9078\u629e\u80a2\u3092\u9078\u3079\u306a\u3044\u7d44\u306b\u30b3\u30b9\u30c8INF\u306e\u8fba\u3092\u5f35\u308b\n        dinic.add_link(i-1, j-1, INF)\n        j += i\n\nres = dinic.max_flow(s, t)\n# \u6700\u5927\u5229\u76ca = \u8abf\u6574\u5206 - \u6700\u5c0f\u30ab\u30c3\u30c8\nprint((total - res))\n", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN=int(input())\na=list(map(int,input().split()))\n\njew=Dinic(N+2)\nans=0\nfor i in range(N):\n    if a[i]>=0:\n        ans+=a[i]\n        jew.add_edge(0,i+1,a[i])\n    else:\n        jew.add_edge(i+1,N+1,-a[i])\n\ninf=10**15\nfor i in range(1,N+1):\n    for j in range(1,N//i+1):\n        jew.add_edge(i*j,i,inf)\n\nf=jew.flow(0,N+1)\nprint(ans-f)", "from scipy.sparse.csgraph import dijkstra\nimport numpy as np\nn=int(input())\na=[0]+[int(j)for j in input().split()]\ngraph=np.zeros((n+2,n+2),dtype=np.int64)\nstart,goal=0,n+1\nfor i,j in enumerate(a[1:],1):\n    if j>=0:\n        graph[start,i]=j\n    else:\n        graph[i,goal]=-j\nfor i in range(1,n+1):\n    for j in range(2*i,n+1,i):\n        graph[j,i]=10**18\ndef max_flow(graph):\n    flow=0\n    while True:\n        dist,pred=dijkstra(graph,indices=start,return_predecessors=True,unweighted=True)\n        if dist[goal]==np.inf:\n            return flow\n        path=[]\n        v=goal\n        while True:\n            path.append((pred[v],v))\n            v=pred[v]\n            if v==start:\n                break\n        add_flow=min(graph[x][y] for x,y in path)\n        for x,y in path:\n            graph[x][y]-=add_flow\n            graph[y][x]+=add_flow\n        flow+=add_flow\nprint(sum(i for i in a if i>0)-max_flow(graph))", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n\n    return\n\n#B\ndef B():\n\n    return\n\n#C\ndef C():\n    def bfs(s,g,n):\n        bfs_map = [-1 for i in range(n)]\n        bfs_map[s] = 0\n        q = deque()\n        q.append(s)\n        fin = False\n        while q:\n            x = q.popleft()\n            for y in range(n):\n                if c[x][y] > 0 and bfs_map[y] < 0:\n                    bfs_map[y] = bfs_map[x]+1\n                    if y == g:\n                        fin = True\n                        break\n                    q.append(y)\n            if fin:\n                break\n\n        if bfs_map[g] == -1:\n            return None,0\n        path = [None]*(bfs_map[g]+1)\n        m = float(\"inf\")\n        path[bfs_map[g]] = g\n        y = g\n        for i in range(bfs_map[g])[::-1]:\n            for x in range(n):\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                    path[i] = x\n                    if c[x][y] < m:\n                        m = c[x][y]\n                    y = x\n                    break\n        return path,m\n\n    def ford_fulkerson(s,g,c,n):\n        f = 0\n        while 1:\n            p,m = bfs(s,g,n)\n            if not m:break\n            f += m\n            for i in range(len(p)-1):\n                c[p[i]][p[i+1]] -= m\n                c[p[i+1]][p[i]] += m\n        return f\n\n    n = I()\n    a = LI()\n    e = n+2\n    ma = 10**9\n    c = [[0]*e for i in range(e)]\n    for i in range(n):\n        d = i+1\n        j = 2*d\n        c[0][d] = ma\n        c[d][n+1] = ma-a[i]\n        while j <= n:\n            c[j][d] = float(\"inf\")\n            j += d\n    print((ma*n-ford_fulkerson(0,n+1,c,e)))\n    return\n\n#D\ndef D():\n\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "import networkx as nx\n\nn = int(input())\nA = list(map(int, input().split()))\nG = nx.DiGraph()\n\nsource = \"source\"\nsink = \"sink\"\n\nfor i in range(1, n + 1):\n    x, y = A[i - 1], 0\n    if A[i - 1] < 0:\n        x, y = y, -x\n    G.add_edge(source, i, capacity=x)\n    G.add_edge(i, sink, capacity=y)\n\nfor i in range(1, n // 2 + 1):\n    for j in range(2 * i, n + 1, i):\n        # print(i, j)\n        G.add_edge(j, i)\n\ntry:\n    mincut, cut_dic = nx.minimum_cut(G, source, sink)\n    ans = 0\n    for c in cut_dic[0]:\n        if c == source:\n            continue\n        ans += A[c - 1]\n    print(ans)\n\n\nexcept nx.NetworkXError:\n    print((0))\n", "n = int(input())\na = [0] + list(map(int, input().split()))\nalive = [1 for i in range(n + 1)]\nsol = sum(a)\nwhile True:\n    pot = []\n    change = False\n    for i in range(n, 0, -1):\n        if a[i] >= 0 or alive[i] == 0:\n            continue\n        saldo = 0\n        j = i\n        while j <= n:\n            saldo += alive[j] * a[j]\n            j += i\n        if saldo > 0:\n            pot.append(i)\n            continue\n        change = True\n        sol -= saldo\n        j = i\n        while j <= n:\n            alive[j] = 0\n            j += i\n    if change:\n        continue\n    k = len(pot)\n    for i in range(k):\n        if change: break\n        for j in range(i):\n            saldo = 0\n            for v in range(1, n + 1):\n                if v % pot[i] == 0 or v % pot[j] == 0:\n                    saldo += alive[v] * a[v]\n            if saldo <= 0:\n                change = True\n                sol -= saldo\n                for v in range(1, n + 1):\n                    if v % pot[i] == 0 or v % pot[j] == 0:\n                        alive[v] = 0\n                break\n    if not change:\n        break\nprint(sol)\n", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter,defaultdict\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq\nsys.setrecursionlimit(10**6)\n# INF =  float(\"inf\")\nINF = 10**18\nimport bisect\nimport statistics\nmod = 10**9+7\n# mod = 998244353\n\n# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        # \u59cb\u70b9\u30ce\u30fc\u30c9idx\uff0c\u7d42\u70b9\u30ce\u30fc\u30c9idx\uff0c\u5bb9\u91cf\u3092input\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        # source/target\u30ce\u30fc\u30c9\u306eidx\u3092\u5165\u529b\u3059\u308b\u3068\u6700\u5927\u30d5\u30ed\u30fc\uff08\uff1d\u6700\u5c0f\u30ab\u30c3\u30c8\uff09\u304c\u51fa\u529b\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN = int(input())\na = [0] + list(map(int, input().split()))\n\ndinic = Dinic(N+2)\n\nfor i in range(1,N+1):\n    x = a[i]\n    if x >= 0:\n        dinic.add_edge(0, i, 0)\n        dinic.add_edge(i, N+1, x)\n    else:\n        dinic.add_edge(0, i, abs(x))\n        dinic.add_edge(i, N+1, 0)\n\nfor i in range(1,N+1):\n    for j in range(2,N//i + 1):\n        dinic.add_edge(i, j*i, INF)\n\nprint(sum([max(aa,0) for aa in a]) - dinic.flow(0, N+1))", "N=int(input())\nP=[int(i) for i in input().split()]\ninf = 10**20\ntable=[[0]*(N+2) for i in range(N+2)]\nfor i in range(1,N+1):\n    if P[i-1]>0:\n        table[i][N+1]=P[i-1]\n    else:\n        table[0][i]=-P[i-1]\n    for j in range(2*i,N+1,i):\n        table[i][j]=inf\n#print(table)\ndef fk(x,t,f):\n    #print(x)\n    visit[x]=True\n    if x==t:\n        return f\n    for i in range(N+2):\n        if (not visit[i]) and table[x][i]>0:\n            df=fk(i,t,min(f,table[x][i]))\n            if df>0:\n                table[x][i]-=df\n                table[i][x]+=df\n                return df\n    return 0\n\nans=0\nwhile True:\n    visit=[False]*(N+2)\n    df=fk(0,N+1,inf)\n    if df>0:\n        ans+=df\n    else:\n        break\nnum=sum([p for p in P if p>0])\nprint(num-ans)", "from collections import deque\n\n# \u30b0\u30e9\u30d5\u306b\u8fba\u3092\u8ffd\u52a0\u3059\u308b\ndef addEdge(adjL, vFr, vTo, cap):\n    adjL[vFr].append([vTo, cap, len(adjL[vTo])])\n    adjL[vTo].append([vFr, 0, len(adjL[vFr]) - 1]) # \u9006\u8fba\n\n\n# Dinic\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\ndef Dinic(adjL, vSt, vEn):\n\n    # \u59cb\u70b9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u3001BFS\u3067\u6c42\u3081\u308b\n    def BFS(vSt):\n        dist[vSt] = 0\n        Q = deque([vSt])\n        while Q:\n            vNow = Q.popleft()\n\n            for i, (v2, cap, iRev) in enumerate(adjL[vNow]):\n                if dist[v2] == -1 and cap > 0:\n                    # \u672a\u63a2\u7d22\u306e\u9802\u70b9\u3078\u306e\u8fba\u306e\u5bb9\u91cf\u306b\u7a7a\u304d\u304c\u3042\u308b\u5834\u5408\u3001\u63a2\u7d22\u3059\u308b\n                    dist[v2] = dist[vNow] + 1\n                    Q.append(v2)\n\n\n    # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001DFS\u3067\u63a2\u7d22\u3059\u308b\n    def DFS(vNow, vEn, fNow):\n        if vNow == vEn:\n            # \u7d42\u70b9\u306b\u5230\u9054\u3057\u305f\u3089\u3001\u30d5\u30ed\u30fc\u306e\u5897\u52a0\u91cf\u3092\u8fd4\u3059\n            return fNow\n\n        # \u524d\u56de\u306e\u7d9a\u304d\u304b\u3089\u3001\u63a2\u7d22\u3092\u518d\u958b\u3059\u308b\n        iSt = iNext[vNow]\n        for i, (v2, cap, iRev) in enumerate(adjL[vNow][iSt:], iSt):\n            if dist[vNow] < dist[v2] and cap > 0:\n                # \u59cb\u70b9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u5897\u52a0\u3059\u308b\u9802\u70b9\u3078\u306e\u8fba\u306e\u5bb9\u91cf\u306b\u7a7a\u304d\u304c\u3042\u308b\u5834\u5408\u3001\u63a2\u7d22\u3059\u308b\n                df = DFS(v2, vEn, min(fNow, cap))\n                if df > 0:\n                    # \u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\u3092\u9061\u3063\u3066\u3001\u8fba\u306e\u30d5\u30ed\u30fc\u3092\u5909\u66f4\u3059\u308b\n                    adjL[vNow][i][1] -= df\n                    adjL[v2][iRev][1] += df\n                    return df\n\n            iNext[vNow] += 1\n\n        # \u73fe\u5728\u306e\u9802\u70b9\u304b\u3089\u306e\u63a2\u7d22\u5148\u304c\u306a\u3044\u5834\u5408\u3001\u30bc\u30ed\u3092\u8fd4\u3059\n        return 0\n\n\n    numV = len(adjL)\n    MaximumFlow = 0\n    while True:\n        # \u59cb\u70b9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u3001BFS\u3067\u6c42\u3081\u308b\n        dist = [-1] * numV\n        BFS(vSt)\n        if dist[vEn] == -1:\n            # \u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u3001\u6700\u5927\u30d5\u30ed\u30fc\u306e\u5024\u3092\u8fd4\u3059\n            return MaximumFlow\n\n        iNext = [0] * numV\n        while True:\n            # \u6b8b\u4f59\u30b0\u30e9\u30d5\u306e\u59cb\u70b9\u304b\u3089\u7d42\u70b9\u307e\u3067\u306e\u7d4c\u8def\uff08\u5897\u52a0\u30d1\u30b9\uff09\u3092\u3001DFS\u3067\u63a2\u7d22\u3059\u308b\n            df = DFS(vSt, vEn, float('inf'))\n\n            if df == 0:\n                # \u7d4c\u8def\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u3001\u30eb\u30fc\u30d7\u3092\u629c\u3051\u308b\n                break\n\n            # \u30d5\u30ed\u30fc\u3092\u52a0\u7b97\u3059\u308b\n            MaximumFlow += df\n\n\nN = int(input())\nAs = list(map(int, input().split()))\n\nadjList = [[] for v in range(N + 2)]\nfor i, A in enumerate(As, 1):\n    if A <= 0:\n        addEdge(adjList, 0, i, -A)\n    else:\n        addEdge(adjList, i, N + 1, A)\n\nfor i in range(1, N + 1):\n    for j in range(2 * i, N + 1, i):\n        addEdge(adjList, i, j, float('inf'))\n\n# Dinic\u6cd5\uff08\u6700\u5927\u30d5\u30ed\u30fc\u3092\u6c42\u3081\u308b\uff09\nmf = Dinic(adjList, 0, N + 1)\nprint((sum([A for A in As if A > 0]) - mf))\n", "class Dinic:\n\n\tdef __init__(self, v, inf=float(\"inf\")):\n\t\tself.V = v\n\t\tself.inf = inf\n\t\tself.G = [[] for _ in range(v)]\n\t\tself.level = [0 for _ in range(v)]\n\t\tself.iter = [0 for _ in range(v)]\n\n\tdef addEdge(self, fm, to, cap):\n\t\t'''\n\t\tto:\u884c\u304d\u5148\n\t\tcap:\u5bb9\u91cf\n\t\trev:\u53cd\u5bfe\u5074\u306e\u8fba\n\t\t'''\n\t\tself.G[fm].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\n\t\tself.G[to].append({'to':fm, 'cap':0, 'rev':len(self.G[fm])-1})\n\n\n\t# s\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u3092bfs\u3067\u8a08\u7b97\n\tdef bfs(self, s):\n\t\timport queue\n\t\tself.level = [-1 for _ in range(self.V)]\n\t\tself.level[s] = 0\n\t\tque = queue.Queue()\n\t\tque.put(s)\n\n\t\twhile not que.empty():\n\t\t\tv = que.get()\n\t\t\tfor i in range(len(self.G[v])):\n\t\t\t\te = self.G[v][i]\n\t\t\t\tif e['cap'] > 0 and self.level[e['to']] < 0:\n\t\t\t\t\tself.level[e['to']] = self.level[v] + 1\n\t\t\t\t\tque.put(e['to'])\n\n\n\tdef dfs(self, v, t, f):\n\t\tif v == t: return f\n\t\tfor i in range(self.iter[v], len(self.G[v])):\n\t\t\tself.iter[v] = i\n\t\t\te = self.G[v][i]\n\t\t\tif e['cap'] > 0 and self.level[v] < self.level[e['to']]:\n\t\t\t\td = self.dfs(e['to'], t ,min(f,e['cap']))\n\t\t\t\tif d > 0:\n\t\t\t\t\te['cap'] -= d\n\t\t\t\t\tself.G[e['to']][e['rev']]['cap'] += d\n\t\t\t\t\treturn d\n\t\treturn 0\n\n\n\tdef max_flow(self,s,t):\n\t\tflow = 0\n\t\twhile True:\n\t\t\tself.bfs(s)\n\t\t\tif self.level[t] < 0: return flow\n\t\t\tself.iter = [0 for _ in range(self.V)]\n\t\t\tf = self.dfs(s,t,self.inf)\n\t\t\twhile f > 0:\n\t\t\t\tflow += f\n\t\t\t\tf = self.dfs(s,t,self.inf)\n\n\n\nfrom sys import stdin, setrecursionlimit\ndef IL():return list(map(int, stdin.readline().split()))\n \nsetrecursionlimit(1000000)\n\ndef main():\n\tN = int(input())\n\ta = IL()\n\td = Dinic(N+2)\n\tres = 0\n\tfor i in range(N):\n\t    d.addEdge(N,i, max(0, -a[i]))\n\t    d.addEdge(i,N+1, max(0,a[i]))\n\t    res+=max(0,a[i])\n\t    t = 2*i+2\n\t    while t<=N:\n\t        d.addEdge(i,t-1,float('inf'))\n\t        t+=i+1\n\tprint(res-d.max_flow(N,N+1))\n\t\n\t\ndef __starting_point(): main()\n__starting_point()"]
["for __ in range(int(input())):\n    a = list(map(int, input()))\n    ar1 = []\n    ar2 = []\n    for elem in a:\n        if elem % 2 == 0:\n            ar1.append(elem)\n        else:\n            ar2.append(elem)\n    ans = []\n    i = 0\n    j = 0\n    while i < len(ar1) and j < len(ar2):\n        if ar1[i] < ar2[j]:\n            ans.append(ar1[i])\n            i += 1\n        else:\n            ans.append(ar2[j])\n            j += 1\n    if i < len(ar1):\n        for h in range(i, len(ar1)):\n            ans.append(ar1[h])\n    if j < len(ar2):\n        for h in range(j, len(ar2)):\n            ans.append(ar2[h])\n    print(''.join(map(str, ans)))", "# PARITY'S RELATIVE POSITION DOESN'T CHANGE! (PROBLEM C)\ndef solve(s):\n    # return list\n    evens = [u for u in s if u % 2 == 0]\n    odds  = [u for u in s if u % 2 == 1]\n    if len(odds) == 0:\n        return evens\n    ans = []\n    inserted_odd = 0\n    current_odd = odds[inserted_odd]\n    for i in range(len(evens)):\n        while current_odd < evens[i] and inserted_odd < len(odds):\n            ans.append(current_odd)\n            inserted_odd += 1\n            if inserted_odd < len(odds):\n                current_odd = odds[inserted_odd]\n        ans.append(evens[i])\n    while inserted_odd < len(odds):\n        ans.append(current_odd)\n        inserted_odd += 1\n        if inserted_odd < len(odds):\n            current_odd = odds[inserted_odd]\n    return ans\n\n\nfor _ in range(int(input())):\n    s = list(map(int, list(input())))\n    ans = solve(s)\n    print (''.join(map(str, ans)))", "for t in range(int(input())):\n      s=input()\n      l=len(s)\n      eve=\"\"\n      odd=\"\"\n      for i in range(l):\n            if((ord(s[i])-ord(\"0\"))%2 == 0):\n                  eve+=s[i]\n            else:\n                  odd+=s[i]\n      e0=len(eve)\n      o0=len(odd)\n      e=0\n      o=0\n      a=\"\"\n      for i in range(l):\n            if(o == o0):\n                  a+=eve[e]\n                  e+=1\n            elif(e==e0):\n                  a+=odd[o]\n                  o+=1\n            elif(ord(eve[e])>ord(odd[o])):\n                  a+=odd[o]\n                  o+=1\n            else:\n                  a+=eve[e]\n                  e+=1\n      print(a)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nT = int(input())\nfor _ in range(T):\n    A = [int(a) for a in input()]\n    N = len(A)\n    O = []\n    E = []\n    for i in range(N):\n        if A[i] % 2:\n            O.append(A[i])\n        else:\n            E.append(A[i])\n    O = O[::-1]\n    E = E[::-1]\n    B = []\n    while O or E:\n        if not O:\n            B.append(E.pop())\n        elif not E:\n            B.append(O.pop())\n        elif O[-1] < E[-1]:\n            B.append(O.pop())\n        else:\n            B.append(E.pop())\n    print(\"\".join(map(str, B)))\n\n", "import sys\ndef I():\n    return sys.stdin.readline().rstrip()\n\nfor _ in range( int( I( ) ) ):\n    e, o, a = [], [], []\n    for c in I():\n        x = ord( c ) - ord( '0' )\n        if x & 1:\n            o.append( x )\n        else:\n            e.append( x )\n    i, j = 0, 0\n    while i < len( o ) or j < len( e ):\n        if i < len( o ) and j < len( e ):\n            if o[ i ] < e[ j ]:\n                a.append( chr(o[ i ] + ord( '0' )))\n                i += 1\n            else:\n                a.append( chr(e[ j ] + ord( '0' )))\n                j += 1\n        elif i < len( o ):\n            a.append( chr(o[ i ] + ord( '0' )))\n            i += 1\n        else:\n            a.append( chr(e[ j ] + ord( '0' )))\n            j += 1\n    print( \"\".join( a ) )\n\n", "from itertools import groupby\nfor _ in range(int(input())):\n    s = input()\n    n = len(s)\n    i = j = 0\n    while i < n or j < n:\n        while i < n and int(s[i]) % 2:\n            i += 1\n        while j < n and not int(s[j]) % 2:\n            j += 1\n        if i == j == n:\n            break\n        if i < n and (j == n or s[i] < s[j]):\n            print(end=s[i])\n            i += 1\n        else:\n            print(end=s[j])\n            j += 1\n    print()\n", "# PARITY'S RELATIVE POSITION DOESN'T CHANGE! (PROBLEM C)\ndef solve1(s):\n    # return list\n    evens = [u for u in s if u % 2 == 0]\n    odds  = [u for u in s if u % 2 == 1]\n    if len(odds) == 0:\n        return evens\n    ans = []\n    inserted_odd = 0\n    current_odd = odds[inserted_odd]\n    for i in range(len(evens)):\n        while current_odd < evens[i] and inserted_odd < len(odds):\n            ans.append(current_odd)\n            inserted_odd += 1\n            if inserted_odd < len(odds):\n                current_odd = odds[inserted_odd]\n        ans.append(evens[i])\n    while inserted_odd < len(odds):\n        ans.append(current_odd)\n        inserted_odd += 1\n        if inserted_odd < len(odds):\n            current_odd = odds[inserted_odd]\n    return ans\n\ndef solve2(s):\n    # return list\n    # lazy code lmao\n    odds = [u for u in s if u % 2 == 0]\n    evens  = [u for u in s if u % 2 == 1]\n    if len(odds) == 0:\n        return evens\n    ans = []\n    inserted_odd = 0\n    current_odd = odds[inserted_odd]\n    for i in range(len(evens)):\n        while current_odd < evens[i] and inserted_odd < len(odds):\n            ans.append(current_odd)\n            inserted_odd += 1\n            if inserted_odd < len(odds):\n                current_odd = odds[inserted_odd]\n        ans.append(evens[i])\n    while inserted_odd < len(odds):\n        ans.append(current_odd)\n        inserted_odd += 1\n        if inserted_odd < len(odds):\n            current_odd = odds[inserted_odd]\n    return ans\n\nfor _ in range(int(input())):\n    s = list(map(int, list(input())))\n    ans = min(solve1(s), solve2(s))\n    print (''.join(map(str, ans)))", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nESET={\"0\",\"2\",\"4\",\"6\",\"8\"}\n\nfrom collections import deque\n\nfor test in range(t):\n\n    n=input().strip()\n\n    E=deque()\n    O=deque()\n\n    for s in n:\n        if s in ESET:\n            E.append(s)\n        else:\n            O.append(s)\n\n    ANS=[]\n    while E and O:\n        if E[0]<O[0]:\n            x=E.popleft()\n            ANS.append(x)\n        else:\n            x=O.popleft()\n            ANS.append(x)\n\n    #print(ANS,E,O)\n\n    if len(E)!=0:\n        ANS.extend(E)\n    elif len(O)!=0:\n        ANS.extend(O)\n\n    print(\"\".join(ANS))\n", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\n\nq = int(input())\ns = [input() for i in range(q)]\nfor i in range(q):\n    a0 = deque([])\n    a1 = deque([])\n    for j in range(len(s[i]) - 1):\n        tmp = int(s[i][j])\n        if tmp % 2 == 0:\n            a0.append(tmp)\n        else:\n            a1.append(tmp)\n    ans = []\n    while True:\n        if a0 and a1:\n            if a0[0] > a1[0]:\n                tmp = a1.popleft()\n                ans.append(tmp)\n            else:\n                tmp = a0.popleft()\n                ans.append(tmp)\n        else:\n            while a0:\n                tmp = a0.popleft()\n                ans.append(tmp)\n            while a1:\n                tmp = a1.popleft()\n                ans.append(tmp)\n            break\n    print(\"\".join(map(str, ans)))\n", "t = int(input())\nfor _ in range(t):\n    ev = []\n    od = []\n    s = map(int,list(input()))\n    for v in s:\n        if v % 2:\n            od.append(v)\n        else:\n            ev.append(v)\n    ev.append(1000)\n    od.append(1000)\n    ep = 0\n    op = 0\n    while ep < len(ev)-1 or op < len(od)-1:\n        if ev[ep] < od[op]:\n            print(ev[ep],end='')\n            ep += 1\n        else:\n            print(od[op],end='')\n            op += 1\n    print(\"\")\n", "for _ in range(int(input())):\n    a = list(input())\n    odd = []\n    even = []\n    for elem in a:\n        elem = int(elem)\n        if elem % 2 == 0:\n            even.append(elem)\n        else:\n            odd.append(elem)\n    i = 0\n    j = 0\n    output = []\n    for _ in range(len(a)):\n        if i == len(odd):\n            output.append(str(even[j]))\n            j += 1\n        elif j == len(even):\n            output.append(str(odd[i]))\n            i += 1\n        else:\n            if odd[i] < even[j]:\n                output.append(str(odd[i]))\n                i += 1\n            else:\n                output.append(str(even[j]))\n                j += 1\n    print(\"\".join(output))\n", "'''\nCreated on 2019. 9. 21.\n\n@author: kkhh88\n'''\n#q = int(input())\n#x, y = map(int,input().split(' '))\n\nq = int(input())\nfor _ in range(q):\n    s0 = ''\n    s1 = ''\n    s = input()\n    ans = ''\n    for c in s:\n        if ord(c) % 2 == 1:\n            s1 = s1 + c\n        else:\n            s0 = s0 + c\n    \n    l0 = 0\n    l1 = 0\n    while len(s0) > l0 and len(s1) > l1:\n        if s0[l0] > s1[l1]:\n            ans = ans + s1[l1]\n            l1 = l1 + 1\n        else:\n            ans = ans + s0[l0]\n            l0 = l0 + 1\n    print (ans + s1[l1:] + s0[l0:])", "n = int(input())\nfor ewfe in range(n):\n\ts = input()\n\tpar = []\n\tnpar = []\n\tfor i in s:\n\t\tif int(i) % 2 == 0:\n\t\t\tpar.append(int(i))\n\t\telse:\n\t\t\tnpar.append(int(i))\n\tpa = 0\n\tnpa = 0\n\todp = []\n\twhile True:\n\t\tif pa == len(par) and npa == len(npar):\n\t\t\tbreak\n\t\tif pa <= len(par) - 1 and npa <= len(npar) -1:\n\t\t\tif par[pa] < npar[npa]:\n\t\t\t\todp.append(par[pa])\n\t\t\t\tpa += 1\n\t\t\telse:\n\t\t\t\todp.append(npar[npa])\n\t\t\t\tnpa += 1\n\t\telse:\n\t\t\tif pa == len(par):\n\t\t\t\todp.append(npar[npa])\n\t\t\t\tnpa += 1\n\t\t\telse:\n\t\t\t\todp.append(par[pa])\n\t\t\t\tpa += 1\n\tk = len(odp)\n\tfor i in range(k):\n\t\tif i < k - 1:\n\t\t\tprint(odp[i], end = \"\")\n\t\telse:\n\t\t\tprint(odp[i])", "for _ in range(int(input())):\n    s = input()\n    e = []\n    o = []\n    for i in s:\n        if int(i)%2:\n            o.append(int(i))\n        else:\n            e.append(int(i))\n    o.reverse()\n    e.reverse()\n    ans = []\n    while e and o:\n        if e[-1] < o[-1]:\n            ans.append(e.pop())\n        else:\n            ans.append(o.pop())\n    if e:\n        while e:\n            ans.append(e.pop())\n    else:\n        while o:\n            ans.append(o.pop())\n    print(''.join(map(str, ans)))", "Q = int(input())\nfor q in range(Q):\n    s = input()\n\n    chet = []\n    nechet = []\n    for i in s:\n        if int(i) % 2 == 0:\n            chet.append(int(i))\n        else:\n            nechet.append(int(i))\n    #chet.sort()\n    #nechet.sort()\n    chet.append(10)\n    nechet.append(10)\n\n    i = 0\n    j = 0\n    ans = []\n    while i < len(chet) and j < len(nechet):\n        if i == len(chet) - 1 and j == len(nechet) - 1:\n            break\n        if chet[i] < nechet[j]:\n            ans.append(chet[i])\n            i += 1\n        else:\n            ans.append(nechet[j])\n            j += 1\n\n    print(*ans, sep='')\n", "t = int(input())\nfor j in range(t):\n    s = input()\n    first = []\n    second = []\n    for i in range(len(s)):\n        if int(s[i]) % 2:\n            first.append(int(s[i]))\n        else:\n            second.append(int(s[i]))\n    i_f = 0\n    i_s = 0\n    while i_f < len(first) and i_s < len(second):\n        if first[i_f] < second[i_s]:\n            print(first[i_f], end = '')\n            i_f += 1\n        else:\n            print(second[i_s], end = '')\n            i_s += 1\n    while i_f < len(first):\n        print(first[i_f], end = '')\n        i_f += 1\n    while i_s < len(second):\n        print(second[i_s], end = '')\n        i_s += 1\n    print()\n", "import sys\nreadline = sys.stdin.readline\nT = int(readline())\nAns = [None]*T\n\nfor qu in range(T):\n    S = list(map(ord, readline().strip()))\n    \n    SE = []\n    SO = []\n    \n    for s in S:\n        if s % 2 == 0:\n            SE.append(s)\n        else:\n            SO.append(s)\n    \n    LE = len(SE)\n    LO = len(SO)\n    inf = 10000\n    SE.append(inf)\n    SO.append(inf)\n    cnte = 0\n    cnto = 0\n    ans = []\n    for _ in range(LE + LO):\n        if SE[cnte] < SO[cnto]:\n            ans.append(SE[cnte])\n            cnte += 1\n        else:\n            ans.append(SO[cnto])\n            cnto += 1\n    \n    Ans[qu] = ans\n\nfor a in Ans:\n    sys.stdout.write(''.join(map(chr, a)))\n    sys.stdout.write('\\n')\n", "from collections import deque\nfor _ in range(int(input())):\n    x = input()\n    even = deque()\n    odd = deque()\n\n    for i in map(int, x):\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    #print(even, odd)\n    ans = deque()\n    while len(ans)<len(x):\n        if len(even)==0:\n            ans.append(odd.popleft())\n        elif len(odd) == 0:\n            ans.append(even.popleft())\n        elif even[0] < odd[0]:\n            ans.append(even.popleft())\n        else:\n            ans.append(odd.popleft())\n    print(''.join(str(i) for i in ans))", "mans = \"\"\nfor _ in range(int(input())):\n    s=input()\n    ev=''\n    od=''\n    for x in s:\n    \tif x in '13579':\n    \t\tod+=x\n    \telse:\n    \t\tev+=x\n    ans=''\n    uv=0\n    ud=0\n    while uv < len(ev) or ud < len(od):\n    \tif uv == len(ev):\n    \t\tans+=od[ud]\n    \t\tud+=1\n    \telif ud == len(od):\n    \t\tans+=ev[uv]\n    \t\tuv+=1\n    \telif ev[uv]<od[ud]:\n    \t\tans+=ev[uv]\n    \t\tuv+=1\n    \telse:\n    \t\tans+=od[ud];ud+=1\n    mans += ans\n    mans += '\\n'\nprint(mans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\n\ndef solve():\n    nums = [int(i) for i in input().strip()]\n    odds = []\n    evens = []\n    lodd, leven = 0, 0\n    for num in nums:\n        if num % 2 == 1:\n            odds.append(num)\n            lodd += 1\n        else:\n            evens.append(num)\n            leven += 1\n\n    # lodd = len(odds)\n    # leven = len(evens)\n    odds.append(100)\n    evens.append(100)\n    io, ie = 0, 0\n    ans = []\n    while(True):\n        if odds[io] < evens[ie]:\n            ans.append(odds[io])\n            io += 1\n            if io == lodd:\n                ans += evens[ie:leven]\n                break\n        else:\n            ans.append(evens[ie])\n            ie += 1\n            if ie == leven:\n                ans += odds[io:lodd]\n                break\n        # if io == lodd and ie == leven:\n        #     break\n    # nums.reverse()\n\n    print(\"\".join(list(map(str, ans))))\n\n    return\n\ndef main():\n    t = getN()\n    for times in range(t):\n        solve()\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nt = int(input())\nfor i in range(t):\n    n = list(map(int, input()))\n    chet, nechet = deque(), deque()\n    for el in n:\n        if el % 2 == 0:\n            chet.append(el)\n        else:\n            nechet.append(el)\n    ans = []\n    while chet or nechet:\n        if chet and nechet:\n            if chet[0] < nechet[0]:\n                ans.append(chet.popleft())\n            else:\n                ans.append(nechet.popleft())\n        elif chet:\n            ans.append(chet.popleft())\n        else:\n            ans.append(nechet.popleft())\n    print(''.join(map(str, ans)))", "for _ in range(int(input())):\n    long = list(map(int, list(input())))\n    odd = []\n    even = []\n    for n in long:\n        if n % 2 == 1:\n            odd.append(n)\n        else:\n            even.append(n)\n    even.append(10)\n    odd.append(11)\n    i1 = 0\n    i2 = 0\n    for i in range(len(long)):\n        if even[i1] < odd[i2]:\n            print(even[i1], end=\"\")\n            i1 += 1\n        else:\n            print(odd[i2], end=\"\")\n            i2 += 1\n    print()\n", "#!/usr/bin/env python3\nimport sys\nINF = 10**9\nsys.setrecursionlimit(10**8)\n# input = sys.stdin.buffer.readline\n\nn = int(input())\nfor i in range(n):\n    s = input().rstrip()\n    odds = []\n    evens = [] \n    for ch in s:\n        if int(ch) % 2 == 0:\n            evens.append(int(ch))\n        else:\n            odds.append(int(ch))\n    evens.append(INF)\n    odds.append(INF)\n    ans = []\n    eid = 0\n    oid = 0\n    while evens[eid] != INF or odds[oid] != INF:\n        if evens[eid] < odds[oid]:\n            ans.append(evens[eid])\n            eid += 1\n        else:\n            ans.append(odds[oid])\n            oid += 1\n    print(\"\".join([str(item) for item in ans]))", "q=int(input())\nfor t in range(q):\n    s=input()\n    ch=[]\n    nch=[]\n    for i in range(len(s)):\n        if int(s[i])%2==0:\n            ch.append(int(s[i]))\n        else:\n            nch.append(int(s[i]))\n    ans=[]\n    i1=0\n    i2=0\n    while i1<len(ch) and i2<len(nch):\n        if ch[i1]<nch[i2]:\n            ans.append(ch[i1])\n            i1+=1\n        else:\n            ans.append(nch[i2])\n            i2+=1\n    while i2<len(nch):\n        ans.append(nch[i2])\n        i2+=1\n    while i1 < len(ch):\n        ans.append(ch[i1])\n        i1+=1\n    for i in range(len(ans)):\n        print(ans[i],end='')\n    print()", "t = int(input())\nfor i in range(t):\n    nums = list(map(int, list(input())))\n    nums0, nums1 = [], []\n    for num in nums:\n        if num % 2 == 0:\n            nums0.append(str(num))\n        else:\n            nums1.append(str(num))\n    nums0.append(str(99))\n    nums1.append(str(99))\n    p0, p1 = 0, 0\n    l0, l1 = len(nums0) - 1, len(nums1) - 1\n    ans = str()\n    while p0 < l0 or p1 < l1:\n        p0_prev = p0\n        while p0 < l0 and nums0[p0] < nums1[p1]:\n            p0 += 1\n        ans += ''.join(nums0[p0_prev: p0])\n        p1_prev = p1\n        while p1 < l1 and nums1[p1] < nums0[p0]:\n            p1 += 1\n        ans += ''.join(nums1[p1_prev: p1])\n    print(ans)"]
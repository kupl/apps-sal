["MOD = 998244353\n\ndef inv(x):\n    return pow(x,MOD - 2, MOD)\n\nn, k = list(map(int, input().split()))\nif k >= n:\n    print(0)\nelse:\n    out = 0\n    col = n - k \n    binom = 1\n    mult = 1\n    for i in range(n, col, -1):\n        mult *= i\n        mult *= inv(n + 1 - i)\n        mult %= MOD\n        \n    for i in range(col, 0, -1):\n        out += binom * pow(i, n, MOD)\n        out %= MOD\n        binom *= i\n        binom *= inv(col + 1 - i)\n        binom *= -1\n        binom %= MOD\n\n    out *= mult\n\n    if k > 0:\n        out *= 2\n    print(out % MOD)\n", "MOD = 998244353\nlist_size = 200001\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn, k = list(map(int, input().split()))\nif k >= n:\n\tprint(0)\nelif k == 0:\n\tprint(f_list[n-1])\nelse:\n\tans = 0\n\tm = n-k\n\tfor i in range(1, m+1):\n\t\tans += (-1)**((m-i)%2) * pow(i, n, MOD) * comb(m, i)\n\t\tans %= MOD\n\tans *= f_r_list[m-1] * f_list[n-1] * f_r_list[k-1]\n\tans *= 2\n\tprint(ans%MOD)\n", "MOD = 998244353\nfac = [1] * (2 * 10 ** 5 + 10)\n\n\ndef comb(n, k):\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\n\n\nfor i in range(len(fac) - 1):\n    fac[i + 1] = fac[i] * (i + 1) % MOD\nn, k = list(map(int, input().split()))\nif k == 0:\n    print(fac[n])\nelse:\n    k = n - k\n    if k <= 0:\n        print(0)\n        return\n    ans = 0\n    for i in range(k + 1):\n        t = comb(k, i) * pow(k - i, n, MOD) % MOD\n        if i % 2:\n            ans -= t\n        else:\n            ans += t\n    print(2 * ans * comb(n, k) % MOD)\n", "import sys\nreadline = sys.stdin.readline\n\nMOD = 998244353\ndef frac(limit):\n    frac = [1]*limit\n    for i in range(2,limit):\n        frac[i] = i * frac[i-1]%MOD\n    fraci = [None]*limit\n    fraci[-1] = pow(frac[-1], MOD -2, MOD)\n    for i in range(-2, -limit-1, -1):\n        fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\n    return frac, fraci\nfrac, fraci = frac(1341398)\ndef comb(a, b):\n    if not a >= b >= 0:\n        return 0\n    return frac[a]*fraci[b]*fraci[a-b]%MOD\n\nN, K = map(int, readline().split())\n\nif K == 0:\n    print(frac[N])\nelif K >= N:\n    print(0)\nelse:\n    res = 0\n    for i in range(N-K, 0, -1):\n        res = (res + comb(N-K, i)*(-1)**((N-K-i)%2)*pow(i, N, MOD))%MOD\n    print(2*comb(N, N-K)*res%MOD)", "def modpow(b, e, mod):\n    ret = 1\n    pw = b\n    while e > 0:\n        if e % 2 == 1: ret = (ret * pw) % mod\n        e = e >> 1\n        pw = (pw * pw) % mod\n    return ret\n\nn, k = list(map(int, input().split()))\nmod = 998244353\ninv = [0 for _ in range(n + 1)]\nfac = [0 for _ in range(n + 1)]\nfac[0] = inv[0] = 1\n\nfor i in range(n):\n    fac[i + 1] = (fac[i] * (i + 1)) % mod\n    inv[i + 1] = modpow(fac[i + 1], mod - 2, mod)\n\ndef nCr(n, r):\n    num = fac[n]\n    den = (inv[r] * inv[n - r]) % mod\n    return (num * den) % mod\n\n\nrow = n - k\nif row < 0 or row > n: \n    print('0')\nelse:\n    ans = 0\n    for i in range(row):\n        add = (nCr(row, i) * modpow(row - i, n, mod)) % mod\n        if i % 2 == 0: ans = ans + add\n        else: ans = ans - add\n\n    ans = mod + (ans % mod)\n    mult = 2\n    if row == n: mult = 1\n    print((mult * nCr(n, row) * ans) % mod)\n\n", "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if (n == 0 and r > 0) or r < 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):\n        if n == k: return 1\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\nN, K = list(map(int, input().split()))\nmod = 998244353\nif K==0:\n    ans = 1\n    for i in range(1, N+1):\n        ans = ans * i % mod\n    print(ans)\n    return\nif K >= N:\n    print(0)\n    return\n\ncomb = Combination(200002, mod=mod)\n\nprint(comb.balls_and_boxes_3(N, N-K) * comb(N, K) * 2 % mod)\n", "n,k=map(int,input().split())\nif k>=n:print(0)\nelse:\n    m=998244353\n    L=[1]\n    for i in range(1,n+1):\n        L.append((L[-1]*i)%m)\n    def comb(n,k):\n        return (L[n]*pow((L[n-k]*L[k]),m-2,m))%m\n    c=0\n    for i in range(n-k):\n        c+=((-1)**i*pow(n-k-i,n,m)*comb(n-k,n-k-i))%m\n    c*=2\n    c%=m\n    c*=comb(n,n-k)\n    c%=m\n    if k==0:print(L[n])\n    else:print(c)", "\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): \n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nn,k = map(int,input().split())\nmod = 998244353\n\nN = n\n\nif k >= N:\n    print (0)\n\nelif k == 0:\n    ans = 1\n    for i in range(1,N+1):\n        ans *= i\n        ans %= mod\n    print (ans)\n\nelse:\n\n    fac,inv = modfac(n*2+10,mod)\n\n    ans = modnCr(n,k,mod,fac,inv)\n\n    r = N-k\n    p = N\n\n    na = 0\n    for i in range(r):\n\n        now = modnCr(r,i,mod,fac,inv) * pow(r-i,p,mod)\n        #print (i,now)\n\n        if i % 2 == 0:\n            na += now\n        else:\n            na -= now\n        na %= mod\n\n    print (ans * na * 2 % mod)", "nn = 200200\nP = 998244353\n\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a-b] % P if 0 <= b <= a else 0\n\nN, K = list(map(int, input().split()))\nif K == 0:\n    print(fa[N])\n    return\nif K >= N:\n    print(0)\n    return\n\na = N - K\nans = 0\nfor i in range(a+1):\n    ans = (ans + pow(a - i, N, P) * C(a, i) * (-1 if i & 1 else 1)) % P\n    \nans = ans * 2 * C(N, a) % P\nprint(ans)\n", "n, k = list(map(int, input().split()))\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nN = 200000\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nif k == 0:\n    ans = 1\n    for i in range(1, n+1):\n        ans *= i\n        ans %= mod\n    print(ans)\n\nelif k >= n:\n    print(0)\n\nelse:\n    ans = 0\n    K = n-k\n    for i in range(K+1):\n        ans += (-1)**((K-i)%2) * cmb(K, i, mod) * pow(i, n, mod)\n    ans %= mod\n    ans *= cmb(n, n-k, mod)\n    ans *= 2\n    ans %= mod\n    print(ans)\n", "def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nfac = [1]\nrev = []\nmod = 998244353\n\n\ndef fexp(x, y):\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = ans * x % mod\n        x = x * x % mod\n        y //= 2\n    return ans\n\n\ndef comb(n, k):\n    return fac[n] * rev[k] * rev[n - k] % mod\n\n\nn, k = read_ints()\nif k >= n:\n    print(0)\nelse:\n    for i in range(1, n + 5):\n        fac.append(fac[-1] * i % mod)\n    for i in range(n + 5):\n        rev.append(fexp(fac[i], mod - 2))\n    if k == 0:\n        print(fac[n])\n    else:\n        ways = comb(n, k)\n        col = 0\n        for i in range(n - k):\n            sign = 1 if i % 2 == 0 else -1\n            col += sign * comb(n - k, i) * fexp(n - k - i, n)\n            col %= mod\n            if col < 0:\n                col += mod\n        print(ways * col * 2 % mod)\n", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef solve(n, k):\n    MOD = 998244353\n    if k == 0:\n        ans = 1\n        for i in range(2, n + 1):\n            ans = ans * i % MOD\n        return ans\n\n    if k > n - 1:\n        return 0\n\n    facts, invs = prepare(n, MOD)\n    use_row = n - k\n    t = 1\n    ans = 0\n    for r in range(use_row, 0, -1):\n        ans = (ans + t * facts[use_row] * invs[r] * invs[use_row - r] * pow(r, n, MOD)) % MOD\n        t *= -1\n    return ans * 2 * facts[n] * invs[use_row] * invs[n - use_row] % MOD\n\n\nn, k = list(map(int, input().split()))\nprint(solve(n, k))\n", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef solve(n, k):\n    MOD = 998244353\n    if k == 0:\n        ans = 1\n        for i in range(2, n + 1):\n            ans = ans * i % MOD\n        return ans\n\n    if k > n - 1:\n        return 0\n\n    facts, invs = prepare(n, MOD)\n    use_row = n - k\n    t = 1\n    ans = 0\n    for r in range(use_row, 0, -1):\n        ans = (ans + t * facts[use_row] * invs[r] * invs[use_row - r] * pow(r, n, MOD)) % MOD\n        t *= -1\n    return ans * 2 * facts[n] * invs[use_row] * invs[n - use_row] % MOD\n\n\nn, k = list(map(int, input().split()))\nprint(solve(n, k))\n", "class Combination:\n    \"\"\"\u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092O(N)\u3067\u4e8b\u524d\u4f5c\u6210\u3057\u3001\u7d44\u307f\u5408\u308f\u305b\u306e\u8a08\u7b97\u3092O(1)\u3067\u884c\u3046\"\"\"\n    def __init__(self, n, MOD):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % MOD)\n        self.inv_fact = [0] * (n + 1)\n        self.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def factorial(self, k):\n        \"\"\"k!\u3092\u6c42\u3081\u308b O(1)\"\"\"\n        return self.fact[k]\n\n    def inverse_factorial(self, k):\n        \"\"\"k!\u306e\u9006\u5143\u3092\u6c42\u3081\u308b O(1)\"\"\"\n        return self.inv_fact[k]\n\n    def permutation(self, k, r):\n        \"\"\"kPr\u3092\u6c42\u3081\u308b O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r]) % self.MOD\n\n    def combination(self, k, r):\n        \"\"\"kCr\u3092\u6c42\u3081\u308b O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r]) % self.MOD\n\n      \nn, k = map(int, input().split())\nMOD = 998244353 \ncomb = Combination(10 ** 6, MOD)\n\nball = n\nbox = n - k\n\nif box <= 0:\n    print(0)\n    return\nans = 0\nfor i in range(box + 1):\n    ans += pow(-1, i, MOD) * comb.combination(box, i) * pow(box - i, ball, MOD)\n    ans %= MOD\n\nif k == 0:\n    print(ans * comb.combination(n, box) % MOD)\nelse:\n    print(ans * comb.combination(n, box) * 2 % MOD)", "fact = [1] \nmod = 998244353\nfor i in range(1, 200001):\n    fact.append((fact[-1]*i )% mod)\n\nn, k = map(int, input().split())\nsame = k\ndef choose(n, r):\n    return (fact[n] * pow(fact[r], mod - 2, mod) * pow(fact[n - r], mod - 2, mod) )% mod\n\ndef sterling(n, m):\n    result = 0\n    \n    for i in range(n):\n        \n        if i % 2 == 0:\n            result = (result + (choose(n, i) * pow(n - i, m, mod)) )% mod\n        else:\n            result = (result - (choose(n, i) * pow(n - i, m, mod)) )% mod\n        \n    return (result)% mod\n    \nif k > n - 1:\n    print(0)\nelse:\n    # chose n - same from n \n    if k == 0:\n        print(fact[n])\n    else:\n        print((2 * choose(n, n - k) * sterling(n - k, n) )% mod)", "import sys\ninput=sys.stdin.readline\nmod = 998244353\n\ndef cmb(n, r):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNNN = 2*10**5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n\nfor i in range( 2, NNN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN, K = list(map(int, input().split()))\nif K > N:\n    print(0)\nelse:\n    M=N-K\n    R = 0\n    for i in range(1, M+1):\n        R += (-1 if (M-i)%2 else 1) * cmb(M, i) * pow(i, N, mod) % mod\n    R = R*cmb(N, M)%mod\n    if K != 0:\n        R = R*2%mod\n    print(R)\n"]
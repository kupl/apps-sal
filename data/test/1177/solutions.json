["import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are l `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nConsider all sequeuces with sum S and **ends** at specific r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n                   [4] -> dp[2][4] = 3\n             [2,    4] \u2198\n                [3, 4] -> dp[2][s] = dp[2][s - 4] for all s\n             [2, 3, 4] \u2197\n    \n    The answer is sum(dp[r][S] * (N - r) for r in range(N))\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # here can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem:\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ndp = np.zeros((N, V + 1), dtype=np.int64)\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp[i, a] = i + 1\n    dp[i, a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp[i]) % M\n    ans = (ans + (N - i) * dp[i, S]) % M\nprint(ans)\n", "n,s = list(map(int,input().split()));arr = list(map(int,input().split()))\n\nmod = 998244353\ndp = [0] * (s+1)\nans = 0\n\nfor i in range(n):\n    dp[0] += 1\n    tmp = arr[i]\n    for j in range(s,tmp-1,-1):\n        dp[j] += dp[j-tmp]\n    ans += dp[s]\n    ans %= mod\n    \nprint(ans)", "N,S=map(int,input().split())\nA=list(map(int,input().split()))\nm=998244353\nimport numpy as np\ndp=np.zeros((N+1,S+1),dtype=np.int64)\ndp[:,0]=[1]*(N+1)\nfor i,a in enumerate(A):\n    dp[i+1]+=dp[i]\n    dp[i+1,a:]=(dp[i+1,a:]+dp[i,:-a])%m\nprint(np.sum(dp[:,-1])%m)", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 998244353\nINF = 10 ** 18\n\nimport numpy as np\ndef main():\n    N,S = list(map(int,input().split()))\n    A = list(map(int,input().split()))\n    \n    before = np.zeros(S + 1,np.int64)\n    before[0] = 1\n    ans = 0\n    for a in A:\n        now = np.zeros(S + 1,np.int64)\n        now += before\n        now[a:] += before[:-a]\n        ans += now[S]\n        ans %= MOD\n        now[0] += 1\n        now = np.mod(now,MOD)\n        before = now\n    print(ans)\ndef __starting_point():\n    main()\n\n\n__starting_point()", "_,s,*a=map(int,open(0).read().split())\nc,i,*d=[0]*6003\nfor a in a:\n for j in range(s,0,-1):d[a+j]+=d[j]\n i+=1;d[a]+=i;c+=d[s]\nprint(c%998244353)", "from sys import stdin\nmod = 998244353\ndef solveAsPolynomial():\n    import numpy as np\n    N,S = list(map(int,stdin.readline().split()))\n    a = list(map(int,stdin.readline().split()))\n    ans = 0\n    f = np.zeros(S+1,np.int64)#f[k] := \u3042\u308b\u591a\u9805\u5f0f\u306ex**k\u306e\u4fc2\u6570\n    for A in a:\n        #f = (f+1)(1+x**A)\u3068\u3057\u3066\u66f4\u65b0\u3057\u3066\u3044\u304f\n        f[0] += 1#f+1\n        f[A:] += f[:-A].copy()#f*(1+x**A)\n        f %= mod\n        ans += f[S]\n        #x**S = X**(A_1+...+A_k)\u3086\u3048\u3001f[S]\u306f\u77e5\u308a\u305f\u3044\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\u3068\u7b49\u3057\u3044\n        ans %= mod\n    return ans\ndef main():\n  ans = solveAsPolynomial()\n  print(ans)\ndef __starting_point():\n  main()\n\n__starting_point()", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 998244353\nN, S = lr()\nA = lr()\ndp = np.zeros(S+1, np.int64)\nanswer = 0\nfor a in A:\n    dp[0] += 1 # L\u306e\u6570\u306f\uff11\u500b\u305a\u3064\u52a0\u308f\u308b\n    prev = dp.copy()\n    dp[a:] += prev[:-a]\n    dp %= MOD\n    answer += dp[-1] # \u305d\u306e\u4f4d\u7f6e\u3092R\u3068\u3057\u305f\u6642\n\nprint((answer % MOD))\n# 26\n", "N,S =list(map(int,input().split()))\nA=list(map(int,input().split()))\nmod=998244353\nans=0\nq=[0]*(S+1)\nfor i in range(N):\n    q2=q.copy()\n    if A[i]<=S:\n        for j in range(A[i],S+1):\n            q[j]+=q2[j-A[i]]\n        q[A[i]]+=i+1\n    ans+=q[S]\n    ans%=mod\nprint(ans)\n", "import numpy as np\n\nN, S = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 998244353\n\nans = 0\ndp = np.zeros(S + 1, dtype=np.int64)\n\nfor a in A:\n    dp[0] += 1\n    dp[a:] += dp[: -a].copy()\n    dp %= MOD\n    ans += dp[S]\n\nprint((ans % MOD))\n", "_,s,*a=map(int,open(0).read().split())\nc,i,*d=[0]*6003\nfor a in a:\n for j in range(s,0,-1):d[a+j]+=d[j]\n d[a]-=~i;c+=d[s];i+=1\nprint(c%(998244353))", "from numpy import *\nM=998244353\nN,S,*A=map(int,open(0).read().split())\na=0\nf=zeros(S+1,int)\nfor b in A:\n  f[0]+=1\n  f[b:] += f[:-b].copy()\n  f%=M\n  a+=f[S]\nprint(a%M)", "N, S = list(map(int, input().split()))\nA = list(map(int, input().split()))\nmod = 998244353\nans = 0\ndp = [0]*S\n\nfor i, a in enumerate(A):\n    dp[0] +=1\n    if a > S:\n        continue\n\n    ans = (ans + dp[S-a]*(N-i)% mod) % mod\n\n    for j, x in enumerate(dp[:S-a]):\n        dp[j+a] += x\nprint(ans)\n", "from sys import stdin\nmod = 998244353\ndef main():\n    N,S = list(map(int,stdin.readline().split()))\n    a = list(map(int,stdin.readline().split()))\n    dp = [0]*(S+1)\n    ans = 0\n    for A in a:\n        dp[0] += 1\n        for i in reversed(list(range(A,S+1))):\n            dp[i] += dp[i-A]    \n            dp[i] %= mod\n        ans += dp[S]\n        ans %= mod\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "def setM():\n    k = K2 // 2\n    while k:\n        m = int((\"1\" * (K2 - k) + \"0\" * (K2 + k)) * 3001, 2)\n        M.append((k, m, ~m, (1 << K2 + k) % P))\n        k //= 2\n        break\n\ndef modp(n):\n    for k, m, tm, a in M:\n        n = (n & tm) + ((n & m) >> K2 + k) * a\n    return n\n\nK = 64\nK2 = K // 2\nP = 998244353\nmm = (1 << K * 3001) - 1\nmmm = (1 << K) - 1\nM = []\nsetM()\nN, S = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += 1\n    s += s << a * K\n    s &= mm\n    s = modp(s)\n    ans += (s >> S * K) & mmm\n\nprint(ans % P)", "import numpy as np\n\nMOD = 998244353\n\ndef solve(A,S):\n    N = len(A)\n    dp = np.zeros(S+1, dtype=int)\n    res = 0\n    for i,a in enumerate(A):\n        if a > S:\n            continue\n        res += dp[S-a]*(N-i)\n        res %= MOD\n        dp[a:] += dp[:-a]\n        dp[a] += i+1\n        dp %= MOD\n    for i,a in enumerate(A):\n        if a == S:\n            res += (i+1)*(N-i)\n            res %= MOD\n\n    return res%MOD\n\n\ndef __starting_point():\n    N,S = map(int,input().split())\n\n    A = tuple(map(int,input().split()))\n\n    print(solve(A,S))\n__starting_point()", "K = 32\nP = 998244353\npa = (1 << 30) - ((1 << 30) % P)\nM = []\nN, S = map(int, input().split())\nm = int((\"1\" * 2 + \"0\" * 30) * (S + 1), 2)\nmm = (1 << K * (S + 1)) - 1\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += 1\n    s += s << a * K\n    s &= mm\n    s -= ((s & m) >> 30) * pa\n    ans += s >> S * K\n\nprint(ans % P)", "M = 998244353\nN, S = list(map(int, input().split()))\n\nans = 0\nprev = [0]*S\nfor i, a in enumerate(map(int, input().split()), 1):\n  if a > S:\n    continue\n  prev[0] = i\n  ans += prev[S-a]*(N-i+1)\n  for j, s in enumerate(prev[:S-a], a):\n    prev[j] += s\nprint((ans%M))\n", "def solve():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    As = list(map(int, input().split()))\n\n    dp1 = [0] * (S+1)\n    dp2S = 0\n    for A in As:\n        dp2S += dp1[S]\n        if S-A >= 0:\n            dp2S += dp1[S-A]\n        if S-A == 0:\n            dp2S += 1\n        dp2S %= MOD\n        for sm in reversed(list(range(A+1, S+1))):\n            dp1[sm] += dp1[sm-A]\n            dp1[sm] %= MOD\n        if S-A >= 0:\n            dp1[A] += dp1[0] + 1\n            dp1[A] %= MOD\n        dp1[0] += 1\n\n    print(dp2S)\n\n\nsolve()\n", "# coding: utf-8\nimport numpy as np\nN, S = list(map(int, input().split()))\nA = [0]+list(map(int, input().split()))\n\ndt = np.array([[0 for _ in range(S+1)] for x in range(N+1)])\n\nfor n in range(1, N+1):\n  if A[n] <= S:\n    dt[n,A[n]] += n\n  if A[n] < S:\n    dt[n, A[n]+1:] += dt[n-1,1:S-A[n]+1] - dt[n-2,1:S-A[n]+1]\n  dt[n,:] += dt[n-1,:] * 2 - dt[n-2,:]\n  dt[n,:] %= 998244353\nprint(dt[N,S] % 998244353)", "import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are l `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nLet's consider all sequeuces with sum S and **ends** at r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n             [      4] -> dp[2][4] = 3\n             [2,    4] \u2198\n             [   3, 4] -> dp[2][s] = dp[2][s - 4] for all s\n             [2, 3, 4] \u2197\n    \n    The answer is dp[r][S] * (N - r) for r in range(N)\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem:\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ndp = np.zeros((N, V + 1), dtype=np.int64)\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp[i, a] = i + 1\n    dp[i, a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp[i]) % M\n    ans = (ans + (N - i) * dp[i, S]) % M\nprint(ans)\n", "mod = 998244353\n\n\nN, S, *A = map(int, open(0).read().split())\n\ndp = [0] * (S + 1)\nans = 0\nfor i, a in enumerate(A, 1):\n    if a <= S:\n        T = dp[:]\n        for j in range(a, S + 1):\n            dp[j] += T[j - a]\n        dp[a] += i\n\n    ans += dp[-1]\n    ans %= mod\n\nprint(ans)", "K = 32\nP = 998244353\nm = int((\"1\" * 2 + \"0\" * 30) * 3001, 2)\nmm = (1 << K * 3001) - 1\nmmm = (1 << K) - 1\npa = (1 << 30) - ((1 << 30) % P)\n\nM = []\nN, S = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += 1\n    s += s << a * K\n    s &= mm\n    s -= ((s & m) >> 30) * pa\n    ans += (s >> S * K) & mmm\n\nprint(ans % P)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n,s = LI()\n    a = LI()\n    r = 0\n    dp = [0] * (s+1)\n    dp[0] = 1\n    for i in range(n):\n        ai = a[i]\n        if ai > s:\n            dp[0] += 1\n            continue\n        dp[s] += dp[s-ai] * (n-i)\n        dp[s] %= mod2\n        for j in range(s-1, ai-1, -1):\n            dp[j] += dp[j-ai]\n            dp[j] %= mod2\n        dp[0] += 1\n\n    return dp[-1] % mod2\n\n\nprint(main())\n\n\n\n", "import numpy as np\n\ndef main():\n    n, s = list(map(int, input().split()))\n    nums = [int(c) for c in input().split()]\n    mod = 998244353\n    dp = np.zeros(s+1, dtype=np.int)\n    ans = 0\n\n    for i, num in enumerate(nums, 1):\n        dp[0] = i\n        if num <= s:\n            dp[num:] = dp[num:] + dp[:-num]\n            # print(dp)\n        dp %= mod\n        ans = (ans + dp[-1]) % mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    N, S = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    mod = 998244353\n    ans = 0\n    dp = [0]*S\n\n    for i, a in enumerate(A):\n        if a > S:\n            continue\n        dp[0] = i+1\n        ans += dp[S-a]*(N-i)\n\n        for j, x in enumerate(dp[:S-a]):\n            dp[j+a] += x\n    print((ans % mod))\n\n\nmain()\n", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    import numpy as np\n    dp = np.zeros(s+1, dtype=int)\n    mod = 998244353\n    ans = 0\n    for i in range(n):\n        dp[0] += 1\n        dp[a[i]:] += dp[:-a[i]]\n        dp%= mod\n        ans += dp[-1]\n        ans %= mod\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nn,s = list(map(int,input().split()))\na = list(map(int,input().split()))\nmod = 998244353\n\nres = 0\ndp = np.zeros(s + 1, dtype = int)\n\nfor i in range(n):\n    dp[0] += 1\n    dp[a[i]:] += dp[:-a[i]].copy()\n    dp %= mod\n    res += dp[s]\n    res %= mod\n\nprint(res)\n", "import sys\n\ndef input(): return sys.stdin.readline()[:-1]\n\n#mod = 10**9+7\n#w.sort(key=itemgetter(1),reversed=True)  #\u4e8c\u500b\u76ee\u306e\u8981\u7d20\u3067\u964d\u9806\u4e26\u3073\u66ff\u3048\n\n#N = int(input())\n_, S = list(map(int, input().split()))\n#L = [int(input()) for i in range(N)]\nA = tuple(map(int, input().split()))\n#S = [list(map(int, input().split())) for i in range(N)]\nmod=998244353\n\nans=0\ndp=[0]*(S+1)\nfor a in A:\n    dp[0]+=1\n    for i in range(S,a-1,-1):\n        dp[i]+=dp[i-a]\n        dp[i]%=mod\n    ans+=dp[-1]\n    ans%=mod\n    #print(dp)\n\nprint(ans)\n", "import numpy as np\n\nn, s = list(map(int, input().split()))\na = list(map(int, input().split()))\nmod = 998244353\n\ndp = np.array([[0] * 3 for _ in range(s + 1)], dtype=np.int64)\ndp[0][0] = 1\n\nfor i, e in enumerate(a):\n    cp = dp.copy()\n    dp[:, 1] += cp[:, 0]\n    dp[:, 2] += cp[:, 0] + cp[:, 1]\n\n    dp[e:, 1] += cp[:-e, 0] + cp[:-e, 1]\n    dp[e:, 2] += cp[:-e, 0] + cp[:-e, 1]\n\n    dp %= mod\n\nans = dp[s][2]\nprint(ans)\n", "import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are (l + 1) `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nConsider all sequeuces with sum S and **ends** at specific r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n            Base case:\n                   [4] -> dp[2][4] = 3\n\n            Transition from dp[0][s - 4]:\n             [2,    4]\n\n            Transition from dp[1][s - 4]:\n                [3, 4]\n             [2, 3, 4]\n    \n    The answer is sum(dp[r][S] * (N - r) for r in range(N))\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # here can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem.\nOne can compress the dp matrix to vector to reduce memory usage.\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp = np.zeros(V + 1, dtype=np.int64)\n    dp[a] = i + 1\n    dp[a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp) % M\n    ans = (ans + (N - i) * dp[S]) % M\nprint(ans)\n", "import numpy as np\nN, S = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 998244353\nU = 3001\n\nans = 0\ndp = np.zeros(U, dtype=np.int64)\ndp[0] = 1\n\nfor a in A:\n    newDP = np.copy(dp)\n    newDP[a:] += dp[:-a]\n    newDP[0] += 1\n    newDP %= mod\n    dp = newDP\n\n    ans += dp[S]\n    ans %= mod\n\nprint(ans)", "import numpy as np\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return list(map(int,input().split()))\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print((\"-------\\n{}\\n-------\".format(text)))\n\nclass Polynomial:\n    def __init__(self,dim=0,const=1):\n        self.values = [(dim,const)]\n    def __add__(self,other):\n        return self.values + other.values\n\n\nclass PolySolver:\n    def __init__(self,size,init_val=1):\n        self.size = size\n        self.f = np.zeros(size, np.int64)\n        self.f[0] = init_val\n\n\n    def multiple(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u304b\u3051\u5408\u308f\u305b\u308b\n        new_F = np.zeros(self.size, np.int64)\n        for dim,const in polynomial:\n            if dim != 0:\n                g = np.zeros(self.size, np.int64)\n                g[dim:] += self.f[:-dim] # dim\u5206\u4fc2\u6570\u60c5\u5831\u3092\u305a\u3089\u3059\n            else:\n                g = const * self.f.copy()\n\n            new_F += g\n\n        self.f = new_F\n        self.f %= MOD\n    \n    def add(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u8db3\u3059\n        for dim,const in polynomial:\n            self.f[dim] += const\n            self.f %= MOD\n\n    def get_coefficient(self,dim):\n        return self.f[dim]\n\n\n\nINF=10**20\ndef main():\n    N,S=mi()\n    A=list(mi())\n    MOD=998244353\n\n    F = PolySolver(3010,init_val=0)\n    ans = 0\n    for i in range(N):\n        f = Polynomial(dim=A[i]) + Polynomial(const=1)\n        F.add(Polynomial(const=1).values,MOD)\n        F.multiple(f,MOD)\n        ans += F.get_coefficient(S)\n    \n    print((ans % MOD))\n    \n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def setM():\n    K2 = K // 2\n    k = K // 2\n    while k:\n        m = int((\"1\" * (K2 - k) + \"0\" * (K2 + k)) * 3001, 2)\n        M.append((k, m))\n        k //= 2\n\ndef modp(n):\n    K2 = K // 2\n    k = K // 2\n    for k, m in M:\n        n = (n & (~m)) + ((n & m) >> (K2 + k)) * ((1 << K2 + k) % P)\n    return n\n\nK = 64\nP = 998244353\nmm = (1 << K * 3001) - 1\nmmm = (1 << K) - 1\nM = []\nsetM()\nN, S = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += 1\n    s += s << a * K\n    s &= mm\n    s = modp(s)\n    ans += (s >> S * K) & mmm\n\nprint(ans % P)", "import numpy as np\n\nn, s = list(map(int, input().split()))\na = list(map(int, input().split()))\nmod = 998244353\n\ndp = np.zeros((s + 1, 3), dtype=np.int64)\ndp[0][0] = 1\n\nfor i, e in enumerate(a):\n    cp = dp.copy()\n\n    dp[:, 1] += cp[:, 0]\n    dp[:, 2] += cp[:, 0] + cp[:, 1]\n\n    dp[e:, 1] += cp[:-e, 0] + cp[:-e, 1]\n    dp[e:, 2] += cp[:-e, 0] + cp[:-e, 1]\n\n    dp %= mod\n\nans = dp[s][2]\nprint(ans)\n", "import numpy as np\nn,s=list(map(int,input().split()))\na=list(map(int,input().split()))\nmod=998244353\nf=np.zeros(3001,int)\n\nans=0\nfor ai in a:\n  ff=np.zeros(3001,int)\n  ff+=f\n  ff[ai:]+=f[:-ai]\n  ff[0]+=1\n  ff[ai]+=1\n  f=ff\n  f%=mod\n  ans+=f[s]\n  ans%=mod\nprint(ans)\n\n", "def main():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n\n    dp = [0] * (S + 1)\n    ans = 0\n    for x in A:\n        dp[0] += 1\n        for j in range(S, x - 1, -1):\n            dp[j] = (dp[j] + dp[j - x]) % MOD\n        ans = (ans + dp[S]) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "_,s,*a=map(int,open(0).read().split())\nc,i,*d=[0]*6003\nfor a in a:\n for j in range(s,0,-1):d[a+j]+=d[j]\n i+=1;d[a]+=i;c+=d[s]\nprint(c%(998244353))", "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\nMOD = 998244353\nn, s = map(int, input().split())\nA = list(map(int, input().split()))\nF = np.zeros(s+1, dtype=np.int64)\nans = 0\nfor a in A:\n  F[0] += 1\n  F[a:] += F[:-a].copy()\n  F %= MOD\n  ans += F[s]\n  ans %= MOD\nprint(ans)", "import numpy as np\nMOD = 998244353\ndef main():\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    dp = [np.zeros(s+1, dtype=np.int64) for i in range(n+1)]\n    ans = 0\n    for i in range(n):\n        if a[i] <= s:\n            dp[i+1][a[i]:] = dp[i][:-a[i]]\n            dp[i+1][a[i]] += i+1\n        dp[i+1][:s] += dp[i][:s]\n        dp[i+1][dp[i+1] >= MOD] -= MOD\n        ans += dp[i+1][s] * (n-i)\n        ans %= MOD\n#        print(dp[i+1], ans)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nMOD = 998244353\n\ndef main():\n    n, s = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    dp = np.zeros((n+1, s+1), dtype=np.int64)\n    for i, v in enumerate(a):\n        dp[i][0] += 1\n        dp[i+1] += dp[i]\n        if v <= s:\n            dp[i+1][v:] += dp[i][:-v]\n        dp[i+1] %= MOD\n    ans = 0\n    for i in range(n+1):\n        ans += dp[i][s]\n        ans %= MOD\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,s=map(int,input().split())\nt=[0]*(s+1)\nm=998244353\na=list(map(int,input().split()))\nans=0\nfor i in range(n):\n    d=t.copy()\n    if a[i]<=s:\n        for j in range(a[i],s+1):\n            t[j]+=d[j-a[i]]\n        t[a[i]]+=i+1\n    ans+=t[-1]\n    ans%=m\nprint(int(ans))", "import numpy as np\n\nn, s = list(map(int, input().split()))\naaa = list(map(int, input().split()))\n\nfwd_acc = np.zeros((n + 1, s + 1), dtype=np.int64)\nfwd_acc[0][0] = 1\n\nans = 0\nMOD = 998244353\nfor i, a in enumerate(aaa, start=1):\n    fwd_acc[i] = fwd_acc[i - 1]\n    fwd_acc[i][0] = i\n    if a <= s:\n        fwd_acc[i][a:] = fwd_acc[i][a:] + fwd_acc[i][:-a]\n    fwd_acc[i] %= MOD\n    ans = (ans + fwd_acc[i][s]) % MOD\n    # print(fwd_acc)\n    # print(ans)\nprint(ans)\n", "import numpy as np\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nclass Polynomial:\n    def __init__(self,dim=0,const=1):\n        self.values = [(dim,const)]\n    def __add__(self,other):\n        return self.values + other.values\n\n\nclass PolySolver:\n    def __init__(self,size,init_val=1):\n        self.size = size\n        self.f = np.zeros(size, np.int64)\n        self.f[0] = init_val\n\n\n    def multiple(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u304b\u3051\u5408\u308f\u305b\u308b\n        new_F = np.zeros(self.size, np.int64)\n        for dim,const in polynomial:\n            if dim != 0:\n                g = np.zeros(self.size, np.int64)\n                g[dim:] += self.f[:-dim] # dim\u5206\u4fc2\u6570\u60c5\u5831\u3092\u305a\u3089\u3059\n            else:\n                g = const * self.f.copy()\n\n            new_F += g\n\n        self.f = new_F\n        self.f %= MOD\n    \n    def add(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u8db3\u3059\n        for dim,const in polynomial:\n            self.f[dim] += const\n            self.f %= MOD\n\n    def get_coefficient(self,dim):\n        return self.f[dim]\n\n\n\nINF=10**20\ndef main():\n    N,S=mi()\n    A=list(mi())\n    MOD=998244353\n\n    F = PolySolver(3010,init_val=0)\n    ans = 0\n    for i in range(N):\n        f = Polynomial(dim=A[i]) + Polynomial(const=1)\n        F.add(Polynomial(const=1).values,MOD)\n        F.multiple(f,MOD)\n        ans += F.get_coefficient(S)\n    \n    print(ans % MOD)\n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "K = 32\nP = 998244353\npa = (1 << 30) - ((1 << 30) % P)\nM = []\nN, S = map(int, input().split())\nm = int((\"1\" * 2 + \"0\" * 30) * (S + 1), 2)\nmm = 1 << K * S\nmmm = (1 << K) - 1\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += mm\n    s += s >> a * K\n    s -= ((s & m) >> 30) * pa\n    ans += s & mmm\n\nprint(ans % P)", "def main():\n\tn, s, *a = list(map(int, open(0).read().split()))\n\tans = 0\n\tmod = 998244353\n\tdp = [0] * (s + 1)\n\tfor i, x in enumerate(a):\n\t\tdp[0] += 1\n\t\tif x > s:continue\n\t\tans += dp[s - x] * (n - i)\n\t\tans %= mod\n\t\tdp = dp[:x] + [(dp[j] + dp[j - x]) % mod for j in range(x, s + 1)]\n\tprint(ans)\n\t\ndef __starting_point():\n\tmain()\n\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    md = 998244353\n    n, s = MI()\n    aa = LI()\n    dp = [0] * (s + 1)\n    ans = 0\n    for a in aa:\n        dp[0] += 1\n        for i in range(s, a - 1, -1):\n            dp[i] += dp[i - a]\n            dp[i] %= md\n        ans += dp[s]\n        ans %= md\n    print(ans)\n\nmain()\n", "def main():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n\n    dp = [0] * (S + 1)\n\n    ans = 0\n    for x in A:\n        ans += dp[S]\n        if S >= x:\n            ans += dp[S - x]\n            if S == x:\n                ans += 1\n            for s in range(S, x, -1):\n                dp[s] = (dp[s] + dp[s - x]) % MOD\n            dp[x] = (dp[x] + dp[0] + 1) % MOD\n        dp[0] += 1\n        ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n#             dp[i + 1][s][0] = (dp[i + 1][s][0] + dp[i][s][0]) % MOD\n#             dp[i + 1][s][1] = (dp[i + 1][s][1]\n#                                + dp[i][s][1] + (dp[i][s - x][1] if s - x >= 0 else 0)\n#                                + dp[i][s][0] + (dp[i][s - x][0] if s - x >= 0 else 0)) % MOD\n#             dp[i + 1][s][2] = (dp[i + 1][s][2]\n#                                + dp[i][s][2] +\n#                                dp[i][s][1] + (dp[i][s - x][1] if s - x >= 0 else 0)\n#                                + dp[i][s][0] + (dp[i][s - x][0] if s - x >= 0 else 0)) % MOD\n\n#     for i, x in enumerate(A):\n#         dp[i + 1][0][0] = dp[i][0][0]\n#         for s in range(S, -1, -1):\n#             dp[i + 1][s][1] = (dp[i][s][1] + dp[i][s][0]) % MOD\n#             dp[i + 1][s][2] = (dp[i][s][2] + dp[i][s][1] + dp[i][s][0]) % MOD\n#\n#             if s - x >= 0:\n#                 v = dp[i][s - x][1] + dp[i][s - x][0]\n#                 dp[i + 1][s][1] = (dp[i + 1][s][1] + v) % MOD\n#                 dp[i + 1][s][2] = (dp[i + 1][s][2] + v) % MOD\n\n#         dp[i + 1][0][0] = dp[i][0][0]\n#         dp[i + 1][0][1] = (dp[i][0][1] + dp[i][0][0]) % MOD\n#         dp[i + 1][0][2] = (dp[i][0][2] + dp[i][0][1] + dp[i][0][0]) % MOD\n#         for s in range(S, 0, -1):\n#             dp[i + 1][s][1] = dp[i][s][1] % MOD\n#             dp[i + 1][s][2] = (dp[i][s][2] + dp[i][s][1]) % MOD\n#             if s - x >= 0:\n#                 v = dp[i][s - x][1] + dp[i][s - x][0]\n#                 dp[i + 1][s][1] = (dp[i + 1][s][1] + v) % MOD\n#                 dp[i + 1][s][2] = (dp[i + 1][s][2] + v) % MOD\n\n#     for x in A:\n#         for s in range(S, 0, -1):\n#             dp[s][1] += dp[s][0]\n#             if s - x >= 0:\n#                 v = dp[s - x][0] + (1 if s - x == 0 else 0)\n#                 dp[s][0] += v\n#                 dp[s][1] += v\n#             dp[s][0] %= MOD\n#             dp[s][1] %= MOD\n#         dp[0][0] += 1\n#         dp[0][1] += (dp[0][0] + 1)\n\n__starting_point()", "from numpy import *\nM=998244353\nN,S,*A=list(map(int,open(0).read().split()))\na=0\nf=zeros(S+1,int)\nfor b in A:\n  f[0]+=1\n  f[b:] += f[:-b].copy()\n  f%=M\n  a+=f[S]\nprint((a%M))\n\n", "M = 998244353\nN, S = list(map(int, input().split()))\n\nans = 0\nprev = [0]*S\nfor i, a in enumerate(map(int, input().split()), 1):\n  if a > S:\n    continue\n  prev[0] = i\n  ans = (ans + prev[S-a]*(N-i+1)) % M\n  for j, s in enumerate(prev[:S-a], a):\n    prev[j] += s\nprint(ans)\n\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    import numpy as np\n\n    mod = 998244353\n\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # \u591a\u9805\u5f0f\n    polynomial = np.zeros(S+1, int)\n    ans = 0\n    for i in A:\n        polynomial[0] += 1\n        polynomial[i:] += polynomial[:-i].copy()\n        polynomial %= mod\n        ans += polynomial[S]\n\n    print(ans % mod)\n\nmain()", "import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are l `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nConsider all sequeuces with sum S and **ends** at specific r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n                   [4] -> dp[2][4] = 3\n             [2,    4] \u2198\n                [3, 4] -> dp[2][s] = dp[2][s - 4] for all s\n             [2, 3, 4] \u2197\n    \n    The answer is dp[r][S] * (N - r) for r in range(N)\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # here can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem:\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ndp = np.zeros((N, V + 1), dtype=np.int64)\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp[i, a] = i + 1\n    dp[i, a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp[i]) % M\n    ans = (ans + (N - i) * dp[i, S]) % M\nprint(ans)\n", "# https://atcoder.jp/contests/abc159/submissions/11139734\n\ndef main():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    *a, = list(map(int, input().split()))\n\n    dp = [0] * (S + 1)\n\n    ret = 0\n    for i, x in enumerate(a):\n        dp[0] += 1\n        if x > S: continue\n        ret = (ret + dp[S - x] * (N - i)) % MOD\n        for k in range(S - 1, x - 1, -1):\n            dp[k] = (dp[k] + dp[k - x]) % MOD\n\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(max(A), S)\n\nans = 0\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp = np.zeros(V + 1, dtype=np.int64)\n    dp[a] = i + 1\n    dp[a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp) % M\n    ans = (ans + (N - i) * dp[S]) % M\nprint(ans)\n", "import numpy as np\nfrom sys import stdin\n\nN, S = list(map(int, stdin.readline().split()))\nA = list(map(int, stdin.readline().split()))\nM = 998244353\nV = max(max(A), S)\n\nans = 0\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp = np.zeros(V + 1, dtype=np.int64)\n    dp[a] = i + 1\n    dp[a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp) % M\n    ans = (ans + (N - i) * dp[S]) % M\nprint(ans)\n", "# https://atcoder.jp/contests/abc159/submissions/11139734\n\ndef main():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n\n    ans = 0\n    dp = [0] * (S + 1)\n    for i, a in enumerate(A, start=1):\n        dp[0] = i  # i\u4ee5\u524d\u306e(i+1)\u901a\u308a\u306e\u8d77\u70b9\u304c\u3042\u308b\uff08\u4ee5\u5f8c\u672a\u53d6\u5f97\uff09\n        ans += dp[S]  # a\u3092\u53d6\u3089\u305a\u306bclose\n        if S >= a:\n            ans += dp[S - a]  # a\u3092\u53d6\u3063\u3066close\n        ans %= MOD\n        for s in reversed(list(range(a, S + 1))):\n            dp[s] += dp[s - a]\n            dp[s] %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\nimport numpy as np\nmod = 998244353\nN, S = list(map(int, input().split()))\nA = [0] + list(map(int, input().split()))\n\ndp = np.array([[0 for _ in range(S+1)] for i in range(N+1)])\n\nfor k in range(0, N):\n  dp[k+1,:] += (2 * dp[k,:] - dp[k-1,:]) % mod\n  if S > A[k+1]:\n    dp[k+1, A[k+1]+1:] += (dp[k, 1:S-A[k+1]+1] - dp[k-1, 1:S-A[k+1]+1]) % mod\n  if A[k+1] <= S:\n    dp[k+1,A[k+1]] += k+1\n\nprint(dp[N,S] % mod)", "import numpy as np\n\nN, S = map(int, input().split())\nx = [int(x) for x in input().split()]\n \n# \u72b6\u614b\u30ea\u30b9\u30c8\u3092\u4f5c\u6210\nm = np.zeros((S+1,3))\np = np.zeros((S+1,3))\np[0,0] = 1\n\n# \u524d\u72b6\u614b\u304b\u3089\u6b21\u72b6\u614b\u306e\u5834\u5408\u6570\u3092\u8a08\u7b97\nfor i in range(1,N+1):\n    \n    # x[i] \u3092\u52a0\u3048\u306a\u3044\u5834\u5408\n    m[:,0] = p[:,0]\n    m[:,1] = p[:,0] + p[:,1]  # \u4eca\u56de\u304b\u3089\u958b\u59cb\u3057\u3066\u52a0\u3048\u306a\u3044\u3001\u3082\u3057\u304f\u306f\u65e2\u306b\u958b\u59cb\u3057\u3066\u3044\u308b\u304c\u3001\u52a0\u3048\u306a\u3044\n    m[:,2] = p[:,0] + p[:,1] + p[:,2]  # \u4eca\u56de\u3001\u958b\u59cb\u30fb\u7d42\u4e86\u3057\u3066\u52a0\u3048\u306a\u3044\u3001\u4eca\u56de\u958b\u59cb\u3057\u3066\u52a0\u3048\u305a\u7d42\u4e86\u3002\n\n    # x[i] \u3092\u52a0\u3048\u308b\u5834\u5408\n    m[x[i-1]:,1] += p[:-x[i-1],0] + p[:-x[i-1],1]\n    m[x[i-1]:,2] += p[:-x[i-1],0] + p[:-x[i-1],1]\n\n    p[:,0] = m[:,0] % 998244353\n    p[:,1] = m[:,1] % 998244353\n    p[:,2] = m[:,2] % 998244353\n            \nprint(int(p[S,2]))", "def main():\n    N, S = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    mod = 998244353\n    ans = 0\n    dp = [0]*S\n\n    for i, a in enumerate(A):\n        dp[0] +=1\n        if a > S:\n            continue\n\n        ans += dp[S-a]*(N-i)\n\n        for j, x in enumerate(dp[:S-a]):\n            dp[j+a] += x\n    print((ans % mod))\n\n\nmain()\n", "import numpy as np\n\nn,s=map(int,input().split())\na=list(map(int,input().split()))\n\ndp=[np.zeros(s+1,dtype=np.int64) for _ in range(n+1)]\nfor i in range(n+1):\n    dp[i][0]=1\nans=0\n\nfor i,w in enumerate(a):\n    dp[i]+=dp[i-1]\n    dp[i][w:]+=dp[i-1][:-w]\n    dp[i]%=998244353\n    ans+=dp[i][-1]\n    ans%=998244353\n\nprint(ans)", "n,s = map(int,input().split())\na = list(map(int,input().split()))\nc = [0]*(s+1)\nans = 0\nmod = 998244353\nfor i in range(n):\n    c_=c.copy()\n    if a[i] <= s:\n        for j in range(a[i],s+1):\n            c[j] += c_[j-a[i]]\n        c[a[i]] += i+1\n    ans += c[s]\n    ans %= mod\n\nprint(ans)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 998244353\nN, S = lr()\nA = lr()\ndp = np.array([0] * (S+1), dtype=np.int64)\nanswer = 0\nfor a in A:\n    dp[0] += 1 # L\u306e\u6570\u306f\uff11\u500b\u305a\u3064\u52a0\u308f\u308b\n    prev = dp.copy()\n    dp[a:] += prev[:-a]\n    answer += dp[-1] # \u305d\u306e\u4f4d\u7f6e\u3092R\u3068\u3057\u305f\u6642\n    dp %= MOD\n\nprint((answer % MOD))\n# 26\n", "def f_knapsack_for_all_segments(MOD=998244353):\n    # \u53c2\u8003: https://maspypy.com/atcoder-\u53c2\u52a0\u611f\u60f3-2019-03-22abc-159\n    import numpy as np\n    N, S = [int(i) for i in input().split()]\n    A = [int(i) for i in input().split()]\n\n    ans = 0\n    f = np.zeros(S + 1, np.int64)  # f[k]: \u591a\u9805\u5f0f\u306e x**k \u306e\u9805\u306e\u4fc2\u6570\n    for a in A:\n        # f \u3067\u8868\u3055\u308c\u308b\u591a\u9805\u5f0f\u306b\u5bfe\u3057\u3066 (f + 1)(1 + x**a) \u3092\u65b0\u3057\u3044 f \u3068\u3059\u308b\n        f[0] += 1  # f + 1\n        f[a:] += f[:-a].copy()  # 1 + x**a \u3092\u639b\u3051\u308b\n        f %= MOD\n        # x**S \u306e\u9805\u306e\u4fc2\u6570\u3092\u89e3\u306b\u52a0\u3048\u308b\n        ans += f[S]\n        ans %= MOD\n    return ans\n\nprint(f_knapsack_for_all_segments())", "import math\nimport numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,s = list(map(int,ipt().split()))\n    a = [int(i) for i in ipt().split()]\n    mod = 998244353\n    ans = 0\n    dp = np.zeros(s+1,dtype=int)\n    for j in range(n):\n        dp[0] += 1\n        aj = a[j]\n        ndp = dp*1\n        if s >= aj:\n            dp[s-aj] *= (n-j)\n        ndp[aj:] += dp[:-aj]\n        ndp %= mod\n        dp = ndp\n    print((dp[s]))\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,s = list(map(int,ipt().split()))\n    a = [int(i) for i in ipt().split()]\n    mod = 998244353\n    ans = 0\n    dp = np.zeros(s+1,dtype=int)\n    for j in range(n):\n        dp[0] += 1\n        aj = a[j]\n        ndp = dp*1\n        if s >= aj:\n            dp[s-aj] *= (n-j)\n        ndp[aj:] += dp[:-aj]\n        ndp %= mod\n        dp = ndp\n    ans = (ans+dp[s]*(n-j))%mod\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def solve():\n    MOD = 998244353\n\n    N, S = list(map(int, input().split()))\n    As = list(map(int, input().split()))\n\n    ans = 0\n    dp = [0] * (S+1)\n    dp[0] = 1\n    for A in As:\n        for sm in reversed(list(range(S-A+1))):\n            dp[sm+A] += dp[sm]\n            dp[sm+A] %= MOD\n        ans += dp[S]\n        ans %= MOD\n        dp[0] += 1\n        dp[0] %= MOD\n\n    print(ans)\n\n\nsolve()\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    md = 998244353\n    n, s = MI()\n    aa = LI()\n    dp = [0] * (s + 1)\n    ans = 0\n    for a in aa:\n        dp[0] += 1\n        for i in range(s, a - 1, -1):dp[i] += dp[i - a]\n        ans += dp[s]\n    print(ans%md)\n\nmain()\n", "n,s = list(map(int,input().split())); arr = list(map(int,input().split()))\n\nmod = 998244353\nans = 0\ndp = [0]*(s+1)\n\nfor i in range(n):\n    dp[0] += 1\n    tmp = arr[i]\n    for j in range(s,tmp-1,-1):\n        dp[j] += dp[j-tmp]\n    ans += dp[s]\n    ans %= mod\nprint(ans)", "import numpy as np\nn,s = map(int, input().split( ))\n\na = np.array(list(map(int, input().split( ))))\n\ndp = np.array([[0]*3001 for i in range(n)])\ndp[0][0] = 1\ndp[0][a[0]] = 1\n\nans = 0\nmod = 998244353\nfor i in range(1,n):\n    dp[i] += dp[i-1]\n    dp[i][a[i]:] += dp[i-1][:-a[i]]\n    dp[i][0] +=1\n    dp[i][a[i]] += 1\n    dp[i]%=mod\n    ans += dp[i][s]\nprint(ans%mod)", "import numpy as np\n\nMOD = 998244353\n\nN, S = list(map(int, input().split()))\nAs = list(map(int, input().split()))\n\ndp = np.zeros((N+1, S+1), np.int64)\ndp[:, 0] = 1\ndp[1, 0] = 3\nif As[0] <= S:\n    dp[1, As[0]] = 1\nfor i in range(1, N):\n    A = As[i]\n    dp[i+1] += 2 * dp[i] - dp[i-1]\n    dp[i+1, A:] += dp[i, :-A] - dp[i-1, :-A]\n    dp[i+1] %= MOD\n\nprint((dp[N, S]))\n", "import numpy as np\nmod = 998244353\nN, S = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\ncoef = np.zeros(3001, dtype=int)\nans = 0\nfor a in A:\n    coef[0] += 1\n    coef[a:] += coef[:-a]\n    coef %= mod\n    ans += coef[S]\n    ans %= mod\nprint(ans)\n", "import numpy as np\n\nn, s = map(int, input().split())\nA = list(map(int, input().split()))\nMOD = 998244353\n\nU = 3010\ncount = 0\nF = np.zeros(U + 1, np.int64)\nfor a in A:\n    F[0] += 1\n    F[a:] += F[:-a].copy()\n    F %= MOD\n    count += F[s]\n\ncount %= MOD\nprint(count)", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 998244353\nN, S = lr()\nA = lr()\ndp = [0] * (S+1)\nanswer = 0\nfor a in A:\n    dp[0] += 1 # L\u306e\u6570\u306f\uff11\u500b\u305a\u3064\u52a0\u308f\u308b\n    prev = dp.copy()\n    for i in range(S-a+1):\n        dp[i+a] += prev[i]\n    answer += dp[-1] # \u305d\u306e\u4f4d\u7f6eR\u3068\u3057\u305f\u6642\n\nprint((answer % MOD))\n# 26\n", "n,s=map(int,input().split())\na=[int(j)for j in input().split()]\nmod=998244353\nans=0\nimport numpy as np\ndp=np.zeros(3001,np.int64)\nfor i in a:\n    dp[0]+=1\n    dp[i:]+=dp[:-i].copy()\n    dp%=mod\n    ans+=dp[s]\n    ans%=mod\nprint(ans)", "import numpy as np\nn,s = map(int,input().split())\nA = list(map(int,input().split()))\nmod = 998244353\nans = 0\ndp = np.zeros(s+1,np.int64)\nfor i in A:\n    dp[0] += 1\n    dp[i:] += dp[:-i].copy()\n    dp %= mod\n    ans += dp[-1]\nprint(ans%mod)", "def setM():\n    k = K2 // 2\n    while k:\n        m = int((\"1\" * (K2 - k) + \"0\" * (K2 + k)) * 3001, 2)\n        M.append((k, m, ~m, (1 << K2 + k) % P))\n        k //= 2\n\ndef modp(n):\n    for k, m, tm, a in M:\n        n = (n & tm) + ((n & m) >> K2 + k) * a\n    return n\n\nK = 64\nK2 = K // 2\nP = 998244353\nmm = (1 << K * 3001) - 1\nmmm = (1 << K) - 1\nM = []\nsetM()\nN, S = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = 0\nans = 0\nfor a in A:\n    s += 1\n    s += s << a * K\n    s &= mm\n    s = modp(s)\n    ans += (s >> S * K) & mmm\n\nprint(ans % P)", "M = 998244353\nN, S = list(map(int, input().split()))\n\nans = 0\nprev = [0]*S\nfor i, a in enumerate(map(int, input().split()), 1):\n  if a > S:\n    continue\n  prev[0] = i\n  ans += prev[S-a]*(N-i+1)\n  for j, s in enumerate(prev[:S-a], a):\n    prev[j] += s\nprint((ans%M))\n", "import sys\n\ndef input(): return sys.stdin.readline()[:-1]\n\n#mod = 10**9+7\n#w.sort(key=itemgetter(1),reversed=True)  #\u4e8c\u500b\u76ee\u306e\u8981\u7d20\u3067\u964d\u9806\u4e26\u3073\u66ff\u3048\n\n#N = int(input())\n_, S = list(map(int, input().split()))\n#L = [int(input()) for i in range(N)]\n#A = tuple(map(int, input().split()))\n#S = [list(map(int, input().split())) for i in range(N)]\nmod=998244353\n\nans=0\ndp=[0]*(S+1)\nfor a in map(int, input().split()):\n    dp[0]+=1\n    for i in range(S,a-1,-1):\n        dp[i]+=dp[i-a]\n        dp[i]%=mod\n    ans+=dp[-1]\n    ans%=mod\n    #print(dp)\n\nprint(ans)\n", "#!python3\n\nimport numpy as np\n\n# input\nN, S = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nMOD = 998244353\n\n\ndef add_elements(w, i):\n    a = A[i]\n    w[a:] += w[:-a].copy()\n    if a <= S:\n        w[a] += i + 1\n    w %= MOD\n\n\ndef main():\n    w = np.zeros(S + 1, dtype=int)\n    ans = 0\n    for i in range(N):\n        add_elements(w, i)\n        ans = (ans + w[S]) % MOD\n    \n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from numpy import*\n(n,s),a,m,e=map(int,input().split()),list(map(int,input().split())),998244353,3001;D=zeros((n,e));D[0][a[0]]=1\nfor j,i in enumerate(a[1:]):D[j+1,i]+=j+2;D[j+1,i:]+=D[j,:e-i];D[j+1,:]=(D[j+1,:]+D[j,:])%m\nprint(int(sum(D[:, s]) % m))", "n,s,*a=map(int,open(0).read().split())\nd=[0]*3001\nc=0\nfor i,a in enumerate(a):\n    for j in range(s-a,0,-1):d[a+j]+=d[j]\n    d[a]-=~i\n    c+=d[s]\nprint(c%(998244353))", "import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are (l + 1) `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nConsider all sequeuces with sum S and **ends** at specific r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n                   [4] -> dp[2][4] = 3\n             [2,    4] \u2198\n                [3, 4] -> dp[2][s] = dp[2][s - 4] for all s\n             [2, 3, 4] \u2197\n    \n    The answer is sum(dp[r][S] * (N - r) for r in range(N))\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # here can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem.\nOne can compress the dp matrix to vector to reduce memory usage.\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp = np.zeros(V + 1, dtype=np.int64)\n    dp[a] = i + 1\n    dp[a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp) % M\n    ans = (ans + (N - i) * dp[S]) % M\nprint(ans)\n", "import numpy as np\n\nn,s = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nmod = 998244353\n\n#\u4fc2\u6570\u3092\u8a18\u9332\u3059\u308b\u305f\u3081\u306e\u914d\u5217\nf = np.zeros(s+1,int)\n\nfor i in a:\n    f[0] += 1\n    f[i:] += f[:-i].copy()\n    f %= mod\n    ans += f[s]\n\nprint(ans%mod)"]
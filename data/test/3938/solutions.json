["import sys\nfrom collections import defaultdict\n\nclass MaxFlow(object):\n    def __init__(self):\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\n\n    def add_edge(self, u, v, capacity=float('inf')):\n        self.edges[u][v] = capacity\n\n    def bfs(self, s, t):\n        open_q = [s]\n\n        visited = set()\n        parent = dict()\n        while open_q:\n            close_q = []\n            for node in open_q:\n                for v, capacity in list(self.edges[node].items()):\n                    if v not in visited and capacity > 0:\n                        close_q.append(v)\n                        parent[v] = node\n                        visited.add(v)\n                        if v == t:\n                            result = []\n                            n2 = v\n                            n1 = node\n                            while n1 != s:\n                                result.append((n1, n2))\n                                n2 = n1\n                                n1 = parent[n1]\n                            result.append((n1, n2))\n                            return result\n\n            open_q = close_q\n\n        return None\n\n    def solve(self, s, t):\n        flow = 0\n        route = self.bfs(s, t)\n        while route is not None:\n            new_flow = float('inf')\n            for _, (n1, n2) in enumerate(route):\n                new_flow = min(new_flow, self.edges[n1][n2])\n            for _, (n1, n2) in enumerate(route):\n                self.edges[n1][n2] -= new_flow\n                self.edges[n2][n1] += new_flow\n            flow += new_flow\n\n            route = self.bfs(s, t)\n\n        return flow\n\n    def __str__(self):\n        result = \"{ \"\n        for k, v in list(self.edges.items()):\n            result += str(k) + \":\" + str(dict(v)) + \", \"\n        result += \"}\"\n        return result\n\n\ndef main():\n    (n, m) = tuple([int(x) for x in input().split()])\n    r = []\n    xs = set()\n    ys = set()\n    for i in range(m):\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\n        r.append((x1, y1, x2, y2))\n        xs.add(x1)\n        xs.add(x2 + 1)\n        ys.add(y1)\n        ys.add(y2 + 1)\n\n    xx = sorted(xs)\n    yy = sorted(ys)\n    xsize = len(xs)\n    ysize = len(ys)\n    grid = []\n    for i in range(ysize):\n        grid.append([False] * xsize)\n\n    for rect in r:\n        x1 = rect[0]\n        y1 = rect[1]\n        x2 = rect[2]\n        y2 = rect[3]\n        for i, y in enumerate(yy):\n            for j, x in enumerate(xx):\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\n                    grid[i][j] = True\n\n    f = MaxFlow()\n    for i in range(len(yy)):\n        for j in range(len(xx)):\n            if grid[i][j]:\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\n    for i in range(len(yy) - 1):\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\n    for i in range(len(xx) - 1):\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\n\n    # print(xx)\n    # print(yy)\n    # print(f)\n    print(f.solve(0, len(xx) + len(yy) + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
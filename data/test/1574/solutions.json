["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# AUTHOR: haya14busa\nimport sys\nimport io\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\n\ndef solve(n, m, pairs):\n    # return: minimum possible sum of their recognitions\n    assert 3 <= n <= 4000  # number of warioor\n    assert 0 <= m <= 4000  # number of pairs of warriors knowing each other\n    # for (a, b) in pairs:\n    #     assert 1 <= a < b <= n \n\n    recognitions = defaultdict(set)\n\n    for (a, b) in pairs:\n       recognitions[a].add(b)\n       recognitions[b].add(a)\n\n    minr = float('inf')\n\n    for candidate, recognition in [(c, rs) for c, rs in list(recognitions.items()) if len(rs) > 1]:\n        for c2, c3 in [(a, b) for a, b in combinations(recognition, 2)\n                                if a in recognitions[b]]:\n            sum_r = sum([len(recognitions[x]) for x in [candidate, c2, c3]])\n            minr = min([sum_r, minr])\n    if minr == float('inf'):\n        return -1\n    else:\n        return minr - 2 * 3\n\n\n\ndef getinput():\n    def getint():\n        return int(input())\n\n    def getints_line():\n        return list(map(int, input().split(' ')))\n\n    def getints(n):\n        return [getint() for _ in range(n)]\n\n    def getints_lines(n):\n        return [getints_line() for _ in range(n)]\n    n, m = getints_line()\n    return [n, m, getints_lines(m)]\n\n\ndef iosolve():\n    return str(solve(*getinput()))\n    # return 'YES' if solve(*getinput()) else 'NO' # for boolean output\n    # return '\\n'.join(map(str, solve(*getinput()))) # for multiple line output\n\n\ndef main():\n    if sys.stdin.isatty():\n        test()\n    stdin_lines = getstdin_lines()\n    sys.stdin = io.StringIO('\\n'.join(stdin_lines))\n    if stdin_lines:\n        print(iosolve())\n    else:\n        test()\n\n\ndef test():\n    IO_TEST_CASES = [\n\n        (\n            # INPUT\n            '''\\\n5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n4 5\n            ''',\n            # EXPECT\n            '''\\\n2\n            '''\n        ),\n\n        (\n            # INPUT\n            '''\\\n7 4\n2 1\n3 6\n5 1\n1 7\n            ''',\n            # EXPECT\n            '''\\\n-1\n            '''\n        ),\n\n\n    ]\n\n    # List[(List[arg for solve()], expect)]\n    TEST_CASES = [\n        # ([], None),\n    ]\n\n    # You do need to see below\n    import unittest  # to save memory, import only if test required\n    import sys\n    import io\n\n    class Assert(unittest.TestCase):\n        def equal(self, a, b):\n            self.assertEqual(a, b)\n\n        def float_equal(self, actual, expect, tolerance):\n            self.assertTrue(expect - tolerance < actual < expect + tolerance)\n\n    art = Assert()\n\n    for inputs, expect in TEST_CASES:\n        art.equal(solve(*inputs), expect)\n\n    for stdin, expect in IO_TEST_CASES:\n        sys.stdin = io.StringIO(stdin.strip())\n        art.equal(iosolve(), expect.strip())\n        # art.float_equal(float(iosolve()), float(expect.strip()), 10 ** -6)\n\n\ndef getstdin_lines():\n    stdin = []\n    while 1:\n        try:\n            stdin.append(input())\n        except EOFError:\n            break\n    return stdin\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python\n# 574B_musk.py - Codeforces.com 574B Musk program by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Musk Class\n###############################################################################\n\n\nclass Musk:\n    \"\"\" Musk representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        self.n, self.m = list(map(int, uinput().split()))\n\n        # Reading multiple lines of pairs\n        pairs = (\" \".join(uinput() for i in range(self.m))).split()\n        self.numa = [int(pairs[i])-1 for i in range(0, 2*self.m, 2)]\n        self.numb = [int(pairs[i])-1 for i in range(1, 2*self.m, 2)]\n\n        # Array of sets\n        self.sets = [set() for i in range(self.n)]\n        for i in range(self.m):\n            self.sets[self.numa[i]].add(self.numb[i])\n            self.sets[self.numb[i]].add(self.numa[i])\n\n        MAX = 10000000000000000\n        self.min_rank = MAX\n        for i in range(self.n):\n            for j in self.sets[i]:\n                if j > i:\n                    un = len(self.sets[i]) + len(self.sets[j])\n                    intersect = self.sets[i].intersection(self.sets[j])\n                    for s in intersect:\n                        uns = un + len(self.sets[s])\n                        rank = uns - 6\n                        if rank < self.min_rank:\n                            self.min_rank = rank\n        if self.min_rank == MAX:\n            self.min_rank = -1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = self.min_rank\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Musk class testing \"\"\"\n\n        # Constructor test\n        test = \"5 6\\n1 2\\n1 3\\n2 3\\n2 4\\n3 4\\n4 5\"\n        d = Musk(test)\n        self.assertEqual(d.n, 5)\n        self.assertEqual(d.m, 6)\n        self.assertEqual(d.numa, [0, 0, 1, 1, 2, 3])\n        self.assertEqual(d.numb, [1, 2, 2, 3, 3, 4])\n\n        self.assertEqual(d.sets[0], {1, 2})\n        self.assertEqual(d.sets[3], {1, 2, 4})\n\n        # Sample test\n        self.assertEqual(Musk(test).calculate(), \"2\")\n\n        # Sample test\n        test = \"7 4\\n2 1\\n3 6\\n5 1\\n1 7\"\n        self.assertEqual(Musk(test).calculate(), \"-1\")\n\n        # Sample test\n        test = \"1\\n1 2\\n1\"\n        # self.assertEqual(Musk(test).calculate(), \"0\")\n\n        # My tests\n        test = \"1\\n1 2\\n1\"\n        # self.assertEqual(Musk(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Musk(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Musk().calculate())\n\n__starting_point()", "from sys import stdin, stdout\ninput = stdin.readline\n\nn, m = map(int, input().split())\ngraph =[set([]) for _ in range(n)]\npopularity = [0 for _ in range(n)]\n\nconnections = []\nfor _ in range(m):\n    x, y = map(int, input().split())\n    x, y = x-1, y-1\n    graph[x].add(y)\n    graph[y].add(x)\n    popularity[x] += 1\n    popularity[y] += 1\n    connections.append((x,y))\n\nbest = 100500\nfor x,y in connections:\n    for el in graph[x] & graph[y]:\n        best = min(popularity[x] + popularity[y] + popularity[el] - 6, best)\n\nif best == 100500:\n    stdout.write(\"-1\")\nelse:\n    stdout.write(str(best))", "import sys\n\nlines = sys.stdin.read().split(\"\\n\")\n# n, k = map(int, lines[0].split(\" \"))\n# n = int(lines[0])\n# nums = list(map(int, lines[1].split(\" \")))\n\n\nn, m = list(map(int, lines[0].split(\" \")))\ngra1 = []\nfor i in range(n + 1):\n    gra1.append(set())\ngra2 = [0] * (n + 1)\n\nedges = []\nfor i in range(1, m + 1):\n    a, b = list(map(int, lines[i].split(\" \")))\n    gra1[a].add(b)\n    gra1[b].add(a)\n    edges.append((a, b))\n\nfor i in range(1, n + 1):\n    gra2[i] = len(gra1[i])\n\nres = []\nfor edge in edges:\n    a, b = edge\n    tmp = gra2[a] + gra2[b]\n    neighs = gra1[a].intersection(gra1[b])\n    if len(neighs) <= 0:\n        continue\n    best = float(\"inf\")\n    for c in list(neighs):\n        if gra2[c] < best:\n            best = gra2[c]\n    res.append(tmp + best)\nres.sort()\nif len(res) <= 0:\n    print(\"-1\")\nelse:\n    print(res[0] - 6)\n", "n,m=map(int,input().split())\ne=[set() for i in range(n+1)]\nE=[]\nmi=1000000000000\nfor i in range(m):\n    a,b=map(int,input().split())\n    E+=[(a,b)]\n    e[a]|={b}\n    e[b]|={a}\nl=[len(e[i]) for i in range(n+1)]\nfor a,b in E:\n    t=e[a]&e[b]\n    for x in t:\n       if a in e[x] and b in e[x]:\n         k=l[a]+l[b]+l[x]-6\n         if k<mi: mi=k\nprint(-1 if mi==1000000000000 else mi)", "n, m = map(int, input().split())\namatr = [[0] * n for i in range(n)]\nalist = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    amatr[a - 1][b - 1] = 1\n    amatr[b - 1][a - 1] = 1\n    alist[a - 1].append(b - 1)\n    alist[b - 1].append(a - 1)\n\nknown = [len(alist[i]) for i in range(n)]\n\nans = 10**10\n\nfor first in range(n):\n    for second in alist[first]:\n        if amatr[first][second] == 1:\n            for third in alist[second]:\n                if amatr[third][second] == 1:\n                    if amatr[first][third] == 1:\n                        ans = min(ans, known[first] + known[second] + known[third] - 6)\n            amatr[first][second] = 0\n            amatr[second][first] = 0\n\nprint(ans if ans < 10 ** 10 else -1)", "n, m = (int(x) for x in input().split())\n\nadj = [0] * n\n\nfor i in range(n):\n    adj[i] = []\n\n\nfor i in range(m):\n    a, b = (int(x) for x in input().split())\n    adj[a-1].append(b - 1)\n    adj[b-1].append(a - 1)\n\n# print(adj)\n\nbest = 1000000\n\nfor i in range(n):\n    cur_set = set(adj[i])\n    for j in adj[i]:\n        for k in adj[j]:\n            if k in cur_set:\n                best = min(best, len(adj[i]) + len(adj[j]) + len(adj[k]) - 6)\n\nif best == 1000000:\n    best = - 1\n\nprint(best)\n", "read = lambda: map(int, input().split())\nn, m = read()\nG = [set() for i in range(n + 1)]\nS = [0 for i in range(n + 1)]\nfor i in range(m):\n    a, b = read()\n    G[a].add(b)\n    G[b].add(a)\n    S[a] += 1\n    S[b] += 1\nans = 10 ** 10\nfor i in range(1, n + 1):\n    for j in G[i]:\n        for k in G[j]:\n            if i in G[k]:\n                x = S[i] + S[j] + S[k] - 6\n                ans = min(x, ans)\nif ans == 10 ** 10:\n    ans = -1\nprint(ans)", "n, m = list(map(int, input().split()))\nzn_kol = [0] * n\nzn = [[] for i in range(n)]\nzn_edge = [set() for i in range(n)]\nans = 100000000\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    zn_kol[a - 1] += 1\n    zn_kol[b - 1] += 1\n    zn_edge[a - 1].add(b - 1)\n    zn_edge[b - 1].add(a - 1)\n    zn[b - 1].append(a - 1)\n    zn[a - 1].append(b - 1)\nfor i in range(n):\n    for j in range(zn_kol[i] - 1):\n        for z in range(j + 1, zn_kol[i]):\n            if zn[i][j] in zn_edge[zn[i][z]]:\n               if zn_kol[zn[i][j]] - 2 + zn_kol[zn[i][z]] - 2 + zn_kol[i] - 2 < ans:\n                   ans = zn_kol[zn[i][j]] - 2 + zn_kol[zn[i][z]] - 2 + zn_kol[i] - 2\n        \nif ans == 100000000:\n    print(-1)\nelse:\n    print(ans)\n", "V, E = tuple(int(i) for i in input().split())\nadjList = [[] for i in range(V)]\ndegree = [0 for i in range(V)]\nfor i in range(E):\n\tu,v = tuple(int(i) for i in input().split())\n\tu-=1\n\tv-=1\n\tadjList[u].append(v)\n\tadjList[v].append(u)\n\tdegree[u]+=1\n\tdegree[v]+=1\n\t\nans = -1\nfor i in range(V):\n\tif(degree[i]<2):\n\t\tcontinue\n\tfor n in range(len(adjList[i])):\n\t\tv1 = adjList[i][n]\n\t\tfor m in range(len(adjList[v1])):\n\t\t\tv2 = adjList[v1][m]\n\t\t\tif(v2==i):\n\t\t\t\tcontinue\n\t\t\tif(not i in adjList[v2]):\n\t\t\t\tcontinue\n\t\t\tcost = max(degree[i]-2,0) + max(degree[v1]-2,0) + max(degree[v2]-2,0) \n\t\t\tif(ans == -1 or ans>cost):\n\t\t\t\tans = cost\nprint(ans)", "def main():\n    import sys\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, m = tokens.pop(), tokens.pop()\n    degree = [0] * n\n    edges = [None] * m\n    graph = [set() for i in range(n)]\n    for i in range(m):\n        a, b = tokens.pop() - 1, tokens.pop() - 1\n        degree[a] += 1; degree[b] += 1\n        edges[i] = (a, b)\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    result = 10 ** 9\n    for a, b in edges:\n        if degree[a] > degree[b]: a, b = b, a\n        for c in graph[a]:\n            if c in graph[b]:\n                result = min(result, degree[a] + degree[b] + degree[c])\n    \n    if result == 10 ** 9:\n        print(-1)\n    else:\n        print(result - 6)\n        \n    \n    \nmain()\n", "def main():\n    import sys\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, m = tokens.pop(), tokens.pop()\n    degree = [0] * n\n    edges = [None] * m\n    graph = [set() for i in range(n)]\n    for i in range(m):\n        a, b = tokens.pop() - 1, tokens.pop() - 1\n        degree[a] += 1; degree[b] += 1\n        edges[i] = (a, b)\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    result = 10 ** 9\n    for a, b in edges:\n        if degree[a] < degree[b]: a, b = b, a\n        for c in graph[a]:\n            if c in graph[b]:\n                result = min(result, degree[a] + degree[b] + degree[c])\n    \n    if result == 10 ** 9:\n        print(-1)\n    else:\n        print(result - 6)\n        \n    \n    \nmain()\n", "n, m = list(map(int, input().split()))\n\ng = [set() for _ in range(n)]\nl = []\np = [0 for _ in range(n)]\n\nfor _ in range(m):\n\ta, b = list(map(int, input().split()))\n\ta -= 1\n\tb -= 1\n\n\tp[a] += 1\n\tp[b] += 1\n\t\n\tg[a].add(b)\n\tg[b].add(a)\n\n\tl.append((a, b))\n\nans = 100000\n\nfor i, j in l:\n\tfor k in range(n):\n\t\tif k in g[i] and k in g[j]:\n\t\t\tans = min(ans, p[i] + p[j] + p[k])\n\nif ans == 100000:\n\tans = -1\nelse:\n\tans -= 6\n\nprint(ans)\n", "n,m = list(map(int,input().split()))\ne = [set() for i in range(n+1)] #khoi tao mang e chua cac tap hop chua dinh ke\n                                # index tu 1 den n tuong ung voi cac dinh\nE=[]                            # khoi tao mang E chua 2 dinh co quan he\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    E.append((a,b))             # dua (a,b) vao mang chua 2 dinh co qan he\n    e[a]|={b}                   # dua b vao tap hop dinh ke dinh a\n    e[b]|={a}                   # dua a vao tap dinh ke dinh b\n                                # |= la phep hop tap hop\n\nl = [0]*(n+1)\nfor i in range(n+1):\n    l[i] = len(e[i])            #l[i] so dinh ke voi dinh i\n\nlmin = 12000\n    \n#xu li\n# xet tung cap dinh co quan he (a,b). lay giao cua 2 tap hop e[a],e[b]\n# xet tung phan tu x trong tap hop giao xem e[x] co chua a,b hay ko?\n\nfor a,b in E:\n    t = e[a]&e[b]               # & phep giao tap hop\n    for x in t:\n        if (a in e[x])and(b in e[x]):\n            w = l[a] + l[b] + l[x] - 6\n            if lmin > w:\n                lmin = w\n\nprint(-1 if lmin==12000 else lmin)\n", "class CF574B:\n    M = int(1e12)   # $$ +\\infty $$\n\n    def __init__(self):\n        n, m = list(map(int, input().split()))\n        self.graph = [set() for _ in range(n + 1)]\n        self.edges = []\n        for _ in range(m):\n            a, b = list(map(int, input().split()))\n            self.edges += [(a, b)]\n            self.graph[a] |= {b}\n            self.graph[b] |= {a}\n\n    def solve(self):\n        res = self.M\n        for a, b in self.edges:\n            for common in self.graph[a] & self.graph[b]:\n                res = min(res, len(self.graph[a]) + len(self.graph[b]) + len(self.graph[common]) - 6)\n        print(res if res < self.M else -1)\n\n\ndef main():\n    CF574B().solve()\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    M = int(1e12)  # $$ +\\infty $$\n\n    n, m = list(map(int, input().split()))\n    graph = [set() for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        edges += [(a, b)]\n        graph[a] |= {b}\n        graph[b] |= {a}\n\n    res = M\n    for a, b in edges:\n        for common in graph[a] & graph[b]:\n            res = min(res, len(graph[a]) + len(graph[b]) + len(graph[common]) - 6)\n    print(res if res < M else -1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\n\nn, m = [int(i) for i in input().split()]\n\ng = defaultdict(set)\n\nedges = []\n\nfor i in range(m):\n  f, s = [int(j) for j in input().split()]\n  edges.append((f, s))\n  g[f].add(s)\n  g[s].add(f) \n\ntriangles = set()\n\nfor e in edges:\n  f, s = e\n  i = g[f] & g[s]\n  if len(i) > 0:\n    for common in i:\n      triangles.add(tuple(sorted([f, s, common])))\n\nif len(triangles) == 0:\n  print(-1)\nelse:\n  min_rec = None\n\n  for t in triangles:\n    rec = len(g[t[0]]) + len(g[t[1]]) + len(g[t[2]])\n    if min_rec is None or rec < min_rec:\n      min_rec = rec\n\n  print(min_rec - 6)\n\n", "import itertools\n\nn,m = list(map(int, input().split(\" \")))\nl = [[] for i in range(n+1)]\nfor i in range(m):\n    a,b = list(map(int, input().split(\" \")))\n    l[a].append(b)\n    l[b].append(a)\n\nresult = 0\nsum = 4000\nfor i in range(n):\n    lis = []\n    for s in l[i]:\n        if s > i:\n            lis.append(s)\n    for enum in itertools.combinations(lis,2):\n        x,y = enum\n        temp = len(l[i]) + len(l[x]) + len(l[y]) - 6 \n        if temp < sum and x in l[y]:\n            sum = temp\n            \nif sum == 4000:\n    result = -1\nelse:\n    result = sum\n\nprint(result)\n", "n, m = (int(x) for x in input().split())\n\nadj = [0] * n\n\nfor i in range(n):\n    adj[i] = []\n\n\nfor i in range(m):\n    a, b = (int(x) for x in input().split())\n    adj[a-1].append(b - 1)\n    adj[b-1].append(a - 1)\n\n# print(adj)\n\nbest = 1000000\n\nfor i in range(n):\n    cur_set = set(adj[i])\n    for j in adj[i]:\n        for k in adj[j]:\n            if k in cur_set:\n                best = min(best, len(adj[i]) + len(adj[j]) + len(adj[k]) - 6)\n\nif best == 1000000:\n    best = - 1\n\nprint(best)", "\n(n,m) = (int(i) for i in input().split())\nc={}\nb=[0]*(n+1)\nq=10000000\nfor j in range(m):\n    (a,g) = (int(i) for i in input().split())\n    if(a in list(c.keys())):\n        c[a].append(g)\n    else:\n        c[a]=[g]\n    if(g in list(c.keys())):\n        c[g].append(a)\n    else:\n        c[g]=[a]\n    b[a]=b[a]+1\n    b[g]=b[g]+1\n\nfor first in list(c.keys()):\n    for second in c[first]:\n        if(first>second):\n            for third in c[second]:\n                if(third in c[first])and(third!=first)and(second>third):\n                    if(q>b[third]+b[second]+b[first]-6):\n                        q=b[third]+b[second]+b[first]-6\n\n\nif(q==10000000):\n    print(-1)\nelse:\n    print(q)\n\n\n\n", "(n,m) = (int(i) for i in input().split())\nc={}\n\nb=[0]*(n+1)\nq=10000000\nfor j in range(m):\n    (a,g) = (int(i) for i in input().split())\n    if(a in list(c.keys())):\n        c[a].append(g)\n    else:\n        c[a]=[g]\n    if(g in list(c.keys())):\n        c[g].append(a)\n    else:\n        c[g]=[a]\n    b[a]=b[a]+1\n    b[g]=b[g]+1\n\nfor first in list(c.keys()):\n    for second in c[first]:\n        if(first>second):\n            for third in c[second]:\n                if(third in c[first])and(third!=first)and(second>third):\n                    if(q>b[third]+b[second]+b[first]-6):\n                        q=b[third]+b[second]+b[first]-6\n\n\nif(q==10000000):\n    print(-1)\nelse:\n    print(q)\n", "n,m = list(map(int,input().split()))\nd2 = []\nod = []\nedges = []\nfor i in range(n):\n   d2.append(set())\n   od.append(0)\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n    edges.append((a-1,b-1))\n    d2[a-1].add(b-1)\n    d2[b-1].add(a-1)\n    od[a-1]+=1\n    od[b-1]+=1\nminsum = 1000000\nfor edg in edges:\n    a,b=edg\n    nerd=d2[a]&d2[b]\n    for c in nerd:\n        tmpsum=od[a]+od[b]+od[c]-6\n        if(tmpsum<minsum):\n            minsum=tmpsum\nif(minsum==1000000):\n    print(\"-1\")\nelse:\n    print(minsum)\n", "#!/usr/bin/env python3\nimport sys\n\nfrom collections import defaultdict\n\nN, M = input().split()\nN = int(N)\nM = int(M)\n\nneighbours = defaultdict(set)\n\nedges = set()\n\nfor _ in range(M):\n    a, b = input().split()\n    a = int(a)\n    b = int(b)\n    edges.add((a, b))\n    neighbours[a].add(b)\n    neighbours[b].add(a)\n\ndegree = {}\n\nfor node in neighbours:\n    degree[node] = len(neighbours[node])\n\ntriplets = set()\nfor a, b in edges:\n    mutual_neighbours = neighbours[a] & neighbours[b]\n    if len(mutual_neighbours) == 0:\n        continue\n    best_mn = sorted((degree[n], n) for n in mutual_neighbours)[0][1] # smallest degree\n    triplets.add((a, b, best_mn))\n\ndef recognition(a, b, c):\n    return degree[a] + degree[b] + degree[c] - 6\n\nif len(triplets) == 0:\n    print(-1)\nelse:\n    mn_d = [recognition(*triplet) for triplet in triplets]\n    print(min(mn_d))", "\n\nimport sys\n\ninf = float('inf')\nsys.setrecursionlimit(100000)\n\nclass Graph(object):\n  def __init__(self, v):\n    self.edges = {}\n    self.vertex_map = [[False for j in range(v+1)] for i in range(v+1)]\n\n  def add_edge(self, u, v):\n    edges, vertex_map = self.edges, self.vertex_map\n    if not u in edges: edges[u] = []\n    if not v in edges: edges[v] = []\n    edges[u].append(v)\n    edges[v].append(u)\n    vertex_map[u][v] = vertex_map[v][u] = True\n\n  def has_edge(self, u, v):\n    edges, vertex_map = self.edges, self.vertex_map\n    return self.vertex_map[u][v]\n\n  def adj(self, u):\n    edges, vertex_map = self.edges, self.vertex_map\n    return [] if not u in edges else edges[u]\n\ndef dfs(graph, u, visited, rps):\n  adju = graph.adj(u)\n  ret = inf\n  if len(adju) == 0 or visited[u]: return ret\n  visited[u] = True\n  # puts \"visited: #{u} #{adju}\"\n  for v in adju:\n    if visited[v]: continue\n    r = dfs(graph, v, visited, rps)\n    if ret > r: ret = r\n  for v in adju:\n    ae = set(adju) & set(graph.adj(v)) - set([u, v])\n    if len(ae) == 0: continue\n    for p in ae:\n      if not visited[v]: continue\n      if ret > rps[u] + rps[v] + rps[p] - 6:\n        # print(u, v, p, graph.adj(u), graph.adj(v), graph.adj(p), rps[u], rps[v], rps[p])\n        ret = rps[u] + rps[v] + rps[p] - 6\n  return ret\n\ndef algo():\n  vc, lc = [int(i) for i in input().split(' ')]\n  graph = Graph(vc)\n  rps = [0 for i in range(vc+1)]\n  for i in range(1, lc+1):\n    u, v = [int(i) for i in input().split(' ')]\n    graph.add_edge(u, v)\n    rps[u] += 1\n    rps[v] += 1\n  ret = inf\n  visited = [False for i in range(vc+1)]\n  for u in range(1, vc+1):\n    r = dfs(graph, u, visited, rps)\n    if ret > r: ret = r\n  if ret == inf: ret = -1\n  print(ret)\n\nalgo()\n", "n, m = list(map(int, input().split()))\nEs = [set() for i in range(n)]\nedges = set()\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    Es[a].add(b)\n    Es[b].add(a)\n    edges.add((a, b))\nrecord = float('inf')\nfor a, b in edges:\n    cost_a = len(Es[a]) - 2\n    cost_b = len(Es[b]) - 2\n    cost = cost_a + cost_b\n    if cost >= record:\n        continue\n    if cost_a > cost_b:\n        a, b = b, a\n    for c in Es[a]:\n        cost_abc = cost + len(Es[c]) - 2\n        if b in Es[c]:\n            if cost_abc < record:\n                record = cost_abc\nif record == float('inf'):\n    print(-1)\nelse:\n    print(record)\n"]
["import sys\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : map(int, input().split())\ndef write(*args, sep=\"\\n\"):\n  for i in args:\n    sys.stdout.write(\"{}\".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor q in range(int(input())):\n  n, r = read()\n  arr = sorted(set(read()), reverse=True)\n  s = 0\n  ans = 0\n\n  for i in arr:\n    if s >= i:\n      break\n\n    s += r\n    ans += 1\n\n  write(ans) ", "import sys\ndef I():\n    return sys.stdin.readline().rstrip()\n\nt = int(I())\nfor _ in range(t):\n    n, r = list(map( int, I().split() ))\n    x = list(map(int,I().split()))\n    x.sort()\n    ans = 0\n    while len(x) > 0 and x[ -1 ] > ans * r:\n        y = x[ -1 ]\n        while len(x) > 0 and x[ -1 ] == y:\n            x.pop()\n        ans += 1\n    print( ans )\n", "'''input\n2\n3 2\n1 3 5\n4 1\n5 2 3 5\n\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nfrom  heapq import heappush as hpush\nfrom heapq import heappop as hpop\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nfor _ in range(ri(1)):\n\tn , r =ri()\n\ta = ri()\n\ta = list(set(a))\n\ta.sort()\n\tans =0\n\tcur = 0\n\tstart = a[-1]\n\tfor i in range(len(a)-1,-1,-1):\n\t\tif a[i]-cur>0:\n\t\t\tcur+=r\n\t\t\tans+=1\n\tprint(ans)\n\n\n\n\n", "3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, R, X):\n    v = list(set(X))\n    v.sort(reverse=True)\n    off = 0\n    c = 0\n    i = 0\n    while i < len(v):\n        x = v[i]\n        if x <= off:\n            break\n        i += 1\n        c += 1\n        off += R\n\n    return c\n\n\ndef main():\n    Q = int(inp())\n    for _ in range(Q):\n        N, R = [int(e) for e in inp().split()]\n        X = [int(e) for e in inp().split()]\n        print(solve(N, R, X))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "'''input\n2\n3 2\n1 3 5\n4 1\n5 2 3 5\n'''\nfrom sys import stdin\n\n\n# main starts\nq = int(stdin.readline().strip())\nfor _ in range(q):\n\tn, r = list(map(int, stdin.readline().split()))\n\tmonsters = list(map(int, stdin.readline().split()))\n\tmonsters.sort()\n\tmonsters = list(set(monsters))\n\n\timpact = 0\n\tcount = 0\n\tfor i in range(len(monsters) - 1, -1, -1):\n\t\tif monsters[i] - impact <= 0:\n\t\t\tbreak\n\t\telse:\n\t\t\timpact += r\n\t\t\tcount += 1\n\n\tprint(count)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n, r = list(map(int, input()[:-1].split()))\n    arr = list(sorted(list(map(int, input()[:-1].split()))))\n    deq = deque(arr)\n\n    ans = 0\n    rnow = 0\n\n    while len(deq) > 0:\n        x = deq.pop()\n        while len(deq) > 0 and deq[-1] == x:\n            deq.pop()\n        rnow += r\n        while len(deq) > 0 and deq[0] <= rnow:\n            deq.popleft()\n        ans+=1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n,r=list(map(int,input().split()))\n    E=list(map(int,input().split()))\n\n    E.append(0)\n\n    E=sorted(set(E))\n\n    for i in range(1,n+1):\n        if E[-i-1]<=r*i:\n            print(i)\n            break\n        \n\n    \n\n    \n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\nimport math\n\nq   = int(input())\nans = []\nstart = time.time()\n\nfor i in range(q):\n    (n, r) = (int(j) for j in input().split())\n    x      = [int(j) for j in input().split()]\n    x      = list(set(x))\n    x.sort()\n    p      = [0 for j in range(len(x))]\n    for j in range(len(x)):\n        p[j] = min(math.ceil(x[j]/r), len(x)-j)\n    ans.append(max(p))\n\nfor i in range(q):\n    print(ans[i])\nfinish = time.time()\n#print(finish - start)\n", "import sys\nimport math\ninput = sys.stdin.readline\n\narr=[]\nn=0\nr=0\n\ndef check(k):\n\tif arr[n-k-1]-k*r>0:\n\t\treturn False\n\treturn True\n\t\ndef binarySearch (l, r): \n  \n\tif r >= l: \n  \n\t\tmid = l + (r - l)//2\n\n\t\tif check(mid):\n\t\t\tif r==l:\n\t\t\t\treturn l\n\t\t\t\t\n\t\t\treturn(binarySearch(l, mid))\n\n\t\telse:\n\t\t\treturn binarySearch(mid + 1, r) \n  \n\telse: \n\t\treturn n\n  \n\nq=int(input())\nfor i in range(q):\n\tn,r=map(int,input().split())\n\tl=list(map(int,input().split()))\n\tarr=list(set(l))\n\tn=len(arr)\n\tarr.sort()\n\n\tprint(binarySearch(1,n-1))", "import sys\nfrom math import ceil\nreadline = sys.stdin.readline\nQ = int(readline())\nAns = [None]*Q\nfor qu in range(Q):\n    N, r = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    A = list(set(A))\n    A.sort()\n\n    A = [0] + A\n    N = len(A)            \n    Ans[qu] = min(N-i for i in range(1, N+1) if A[i-1] <= r*(N-i))\nprint('\\n'.join(map(str, Ans)))\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef bisearch_min(mn, mx, func):\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef calc(m):\n    X2 = X[:len(X)-m]\n    X2[-1] -= r * m\n    return X2[-1] <= 0\n\nfor _ in range(INT()):\n    n, r = MAP()\n    X = sorted(set(LIST()))\n    print(bisearch_min(0, len(X), calc))\n", "#!/usr/bin/env python3\n#Educational Codeforces Round 74 B\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(1000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nq = I()\nfor _ in range(q):\n    n,r = LI()\n    x = LI()\n    c = list(Counter(x).items())\n    c.sort(key = itemgetter(0),reverse = True)\n    ans = 0\n    for i,j in c:\n        if i - ans*r > 0:\n            ans += 1\n    print(ans)", "#!/usr/bin/env python3\nimport sys\n\n#lines = stdin.readlines()\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n')\n\ndef oint():\n    return int(input())\n\n\nq = oint()\n\nfor _ in range(q):\n    n, r = rint()\n    x = set(rint())\n    x = list(x)\n    x.sort()\n    z = 0\n    si = 0\n    n = len(x)\n    ei = n-1\n    cnt = 0\n    while True:\n        if ei < si:\n            break\n        cnt += 1\n        ei -=1\n        z +=r\n        for i in range(si, ei+1):\n            if x[i] > z:\n                si = i\n                break\n            if i == ei:\n                si = ei+1\n    print(cnt)\n\n\n\n", "#!/usr/bin/env python3\n#Educational Codeforces Round 74 B\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(1000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nq = I()\nfor _ in range(q):\n    n,r = LI()\n    x = LI()\n    c = list(Counter(x).items())\n    c.sort(key = itemgetter(0),reverse = True)\n    ans = 0\n    for i,_ in c:\n        if i - ans*r > 0:\n            ans += 1\n    print(ans)", "from collections import defaultdict as DD\nfrom bisect import bisect_left as BL\nfrom bisect import bisect_right as BR\nfrom itertools import combinations as IC\nfrom itertools import permutations as IP\nfrom random import randint as RI\nimport heapq as HQ\nimport sys\nMOD=pow(10,9)+7\ndef IN(f=0):\n    if f==0:\n        return ( [int(i) for i in sys.stdin.readline().split()] )\n    else:\n        return ( int(sys.stdin.readline()) )\n\ntc=IN(1)\nfor _ in range(tc):\n    n,r = IN()\n    b = IN()\n    b.sort()\n    c=0\n    #print(b)\n    a=[-1]\n    for i in range(0,n):\n        if b[i]!=a[-1]:\n            p=b[i]\n            a.append(p)\n    del a[0]\n    #print(a)\n        \n    while(len(a)>0):\n        if a[-1]-r*c<=0:\n            break\n        del a[-1]\n        #print(a)\n        c+=1\n    print(c)\n        \n    \n    \n    \n", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque\n\n\ninput = sys.stdin.readline\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, R, X):\n    X.sort()\n    X = deque(X)\n    l = 0\n    r = N-1\n    ll = 0\n    while X:\n        r = X.pop()\n        while X:\n            rr = X.pop()\n            if rr != r:\n                X.append(rr)\n                break\n        ll += R\n\n        while X:\n            l = X.popleft()\n            if l > ll:\n                X.appendleft(l)\n                break\n\n    return ll // R\n\n\ndef main():\n    Q = read_int()\n\n    for _ in range(Q):\n        N, R = read_int_n()\n        X = read_int_n()\n        print(slv(N, R, X))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nfor _ in range(int(input())):\n    n, r = mapin()\n    a = listin()\n    a = list(set(a))\n    a.sort()\n    z = deque(a)\n    count = 0\n    while z:\n        z.pop()\n        count+=1\n        if z:\n            while z[0] <= r*count:\n                z.popleft()\n                if not z:\n                    break\n    print(count)", "import heapq\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\ndef solve():\n    N, R = list(map(int, input().split()))\n    M = list(set([-int(x) for x in input().split()]))\n    heapq.heapify(M)\n\n    ans = 0\n    cur_pos = 0\n    while M:\n        cur_vanish = -heapq.heappop(M)\n        if cur_vanish > cur_pos:\n            cur_pos += R\n            ans += 1\n        else:\n            break\n    print(ans)\n\n\nN = int(input())\nfor _ in range(N):\n    solve()\n", "from sys import stdin\ninput = stdin.readline\nq = int(input())\n\nfor _ in range(q):\n    n, r = list(map(int, input().split()))\n\n    x = list(map(int, input().split()))\n    x.sort(reverse=True)\n    knockbacks = []\n\n    for i in range(len(x)):\n        if i == 0 or x[i] != x[i - 1]:\n            loc = x[i]\n            knockbacks.append((loc + r - 1) // r)\n    \n    cnt = 0\n    while True:\n        if cnt >= len(knockbacks) or knockbacks[cnt] <= cnt:\n            break\n        else:\n            cnt += 1\n\n    print(cnt)\n", "import sys\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    n,r=map(int,input().split())\n    x=sorted(set(map(int,input().split())))\n    \n    cnt=0\n    now_right_idx=len(x)-1\n    total_explosion=0\n\n    while now_right_idx>=0:\n        cnt+=1\n        total_explosion+=r\n        now_right_idx-=1\n        while now_right_idx>=0 and x[now_right_idx]<=total_explosion:\n            now_right_idx-=1\n\n    print(cnt)", "\nimport sys\ninput=sys.stdin.readline\nfor i in range(int(input())):\n    n,r = list(map(int,input().split()))\n    a = sorted(list(set(list(map(int,input().split())))),reverse=True)\n    i = 0\n    se = 0\n    n = len(a)\n    while i<n and a[i] - se > 0:\n        i+=1\n        se+=r\n      \n    print(i)\n"]
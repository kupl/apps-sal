["import sys\nimport os\nfrom copy import copy\nimport operator\nimport time\nimport datetime\nimport math\nfrom math import floor, ceil, sqrt, log\nimport statistics\nfrom statistics import mean, median\nfrom decimal import Decimal as D\nfrom fractions import Fraction as F\nimport functools\nimport random\nfrom random import randint, shuffle\nimport bisect\nimport string\nfrom collections import deque\nimport collections\nimport itertools\nimport heapq\n\nsys.setrecursionlimit(4100000)\nproduct = functools.partial(functools.reduce, operator.mul)\nINF = float(\"inf\")\n\n\nclass UnionFind:\n    def __init__(self, n, m):\n        self.parents = [[-1, {m[i]: 1}] for i in range(n)]\n        self.n = n\n\n    def __getitem__(self, item):\n        if type(item) == tuple:\n            if len(item) == 1:\n                return self.size(item[0])\n            else:\n                self.union(item[0], item[1])\n        elif type(item) == slice:\n            return self.same(item.start, item.stop)\n        else:\n            return self.find(item)\n\n    def __len__(self):\n        return self.group_count()\n\n    def __pos__(self):\n        return self.max_size()\n\n    def __neg__(self):\n        return self.min_size()\n\n    def __invert__(self):\n        return self.roots()\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.parents[x][0] > self.parents[y][0]:\n                x, y = y, x\n            self.parents[x][0] += self.parents[y][0]\n            for k, v in list(self.parents[y][1].items()):\n                self.parents[x][1].setdefault(k, 0)\n                self.parents[x][1][k] += v\n            self.parents[y] = x\n\n    def find(self, x):\n        if type(self.parents[x]) == list:\n            return x\n        self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return list([x for x in self.parents if x < 0])\n\n    def group_count(self):\n        return len(self.roots())\n\n    def max_size(self):\n        return -min(self.parents)\n\n    def min_size(self):\n        return -max(self.roots())\n\n    def append(self, n):\n        self.parents += [-1] * n\n\n\nclass Imos:\n    def __init__(self, n):\n        self.val = [0] * n\n\n    def add(self, x, y, n=None):\n        if n is None:\n            n = 1\n        self.val[x] += n\n        if len(self.val) > y + 1:\n            self.val[y + 1] -= n\n\n    def imos(self):\n        for i in range(1, len(self.val)):\n            self.val[i] += self.val[i - 1]\n\n    def max(self):\n        return max(self.val)\n\n    def min(self):\n        return min(self.val)\n\n\nclass CS:\n    def __init__(self, grid):\n        self.cs = grid\n        for i0 in range(len(grid)):\n            for i1 in range(len(grid[0])):\n                if i0 == 0:\n                    if i1 == 0:\n                        continue\n                    self.cs[i0][i1] += self.cs[i0][i1 - 1]\n                else:\n                    if i1 == 0:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1]\n                    else:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1] + self.cs[i0][i1 - 1] - \\\n                                           self.cs[i0 - 1][i1 - 1]\n\n    def sum(self, start_0, start_1, end_0, end_1):\n        if start_0 == 0:\n            if start_1 == 0:\n                return self.cs[end_0][end_1]\n            return self.cs[end_0][end_1] - self.cs[end_0][start_1 - 1]\n        if start_1 == 0:\n            return self.cs[end_0][end_1] - self.cs[start_0 - 1][end_1]\n        start_0 -= 1\n        start_1 -= 1\n        return self.cs[end_0][end_1] - self.cs[start_0][end_1] - self.cs[end_0][\n            start_1] + self.cs[start_0][start_1]\n\n\ndef mod(n):\n    return n % (10 ** 9 + 7)\n\n\ndef sinput():\n    return sys.stdin.readline()[:-1]\n\n\ndef input():\n    inputs = list(map(int, sys.stdin.readline().split()))\n    if len(inputs) == 1:\n        return inputs[0]\n    return inputs\n\n\ndef listban(l):\n    return list(map(list, set(map(tuple, l))))\n\n\ndef div(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n // i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\ndef prime(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ndef div_counter(l, n):\n    return prime(l).count(n)\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\ndef C(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef P(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // math.factorial(n - r)\n\n\ndef H(n, r):\n    return C(n + r - 1, r)\n\n\ndef cos(x, y, a):\n    return (x ** 2 + y ** 2 - 2 * x * y * math.cos(math.radians(a))) ** 0.5\n\n\ndef DFS(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos.add(s)\n    for i in g[s]:\n        if not (i in pos):\n            DFS(g, i, pos)\n    return pos\n\n\ndef DFS_one(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos = copy(pos)\n    pos.add(s)\n    b = copy(pos)\n    m = copy(pos)\n    for i in g[s]:\n        if not (i in pos):\n            b = DFS(g, i, pos)\n            if len(m) < len(b):\n                m = b\n    return m\n\n\ndef BFS(g, q, pos=None):\n    if pos is None:\n        pos = set()\n    if type(q) == deque:\n        pos.add(q)\n        q = deque([q])\n    pos.add(q[-1])\n    for i in g[q.pop()]:\n        if not i in pos:\n            q.append(i)\n    while q != deque():\n        pos, q = BFS(g, q, pos)\n    return pos, q\n\n\ndef SSP(a, li=None):\n    if li is None:\n        li = []\n    if len(a) == 1:\n        return [a[0]]\n    return list(set(\n        li + SSP(a[1:], li) + list([x + a[0] for x in SSP(a[1:], li)]) + [a[0]]))\n\n\ndef dijkstra(g, s):\n    n = len(g)\n    dist = [10 ** 100] * n\n    hq = [(0, s)]\n    dist[s] = 0\n    seen = [False] * n\n    while hq:\n        v = heapq.heappop(hq)[1]\n        seen[v] = True\n        for to, cost in g[v]:\n            if seen[to] == False and dist[v] + cost < dist[to]:\n                dist[to] = dist[v] + cost\n                heapq.heappush(hq, (dist[to], to))\n    return dist\n\n\ndef LIS(b):\n    l = [b[0]]\n    for i in b:\n        if i > l[-1]:\n            l += [i]\n        else:\n            l[bisect.bisect_left(l, i)] = i\n    return len(l)\n\n\ndef yn(b):\n    if b:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef op(s):\n    print(s)\n    return\n\n\nn = input()\na = input()\nif n == 1:\n    a = [a]\nfor i in range(n):\n    a[i] = a[i] - i - 1\nhei = round(median(a))\nans = 0\nfor i in a:\n    ans += abs(hei - i)\nprint(ans)\n", "N = int(input())\nA = [int(i) for i in input().split()]\nA = [A[i]-i-1 for i in range(N)]\nA.sort()\n\ndef snk(b):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-b)\n    return res\nif N == 1:\n    print(snk(A[N//2]))\n    return\nprint(min(snk(A[N//2]), snk(A[N//2 +1])))", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n\n\ndef main():\n\n    \n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    for i in range(n):\n        a[i] -= i+1\n\n    a.sort()\n\n    ans = 0\n    b = a[n//2]\n\n    for x in a:\n        ans += abs(x-b)\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nA = list(map(int,input().split()))\nfor i in range(N):\n    A[i] -= i+1\nA.sort()\nif len(A)%2 == 0:\n    n = N//2\n    am = A[n]\n    ans = 0\n    for i in range(N):\n        ans += abs(A[i]-am)\nelse:\n    n = (N+1)//2\n    am = A[n-1]\n    ans = 0\n    for i in range(N):\n        ans += abs(A[i]-am)\nprint(ans)\n", "import numpy as np\n\nN = int(input())\nA = list(map(int, input().split()))\n\nB = np.sort(np.array([x - (i + 1) for i, x in enumerate(A)]))\nif N % 2 == 1:\n    b = np.median(B)\n    ans = int(abs(B - b).sum())\nelse:\n    b1 = B[N // 2 - 1]\n    b2 = B[N // 2]\n    ans = int(min(abs(B - b1).sum(), abs(B - b2).sum()))\n    \nprint(ans)", "import sys\nimport math\nimport itertools\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    N = I()\n    A = LI()\n    \n    neg = []\n    pos = []\n    for i in range(N):\n        num = A[i]-i-1\n        if num>=0:\n            pos.append(num)\n        else:\n            neg.append(-num)\n    pos.sort()\n    neg.sort()\n    pos_l = len(pos)\n    neg_l = len(neg)\n    pos2 = [0]+deepcopy(pos)\n    neg2 = [0]+deepcopy(neg)\n    for i in range(1, pos_l+1):\n        pos2[i]+=pos2[i-1]\n    for i in range(1, neg_l+1):\n        neg2[i]+=neg2[i-1]\n    \n    ans = float('inf')\n    \n    for i in range(pos_l):\n        num = pos[i]\n        res = i*num-pos2[i]\n        res += (pos2[pos_l]-pos2[i+1])- num * (pos_l-1-i)\n        res += neg2[neg_l]+ num * neg_l\n        ans = min(res, ans)\n\n    for i in range(neg_l):\n        num = neg[i]\n        res = i*num-neg2[i]\n        res += (neg2[neg_l]-neg2[i+1])- num * (neg_l-1-i)\n        res += pos2[pos_l]+ num * pos_l\n        ans = min(res, ans)\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nimport math\n\n\ndef read():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    return N, A\n\n\ndef find_minimum(N, A, l, r):\n    \"\"\"\u9589\u533a\u9593[l, r]\u306e\u6700\u5c0f\u5024\u3092\u8fd4\u3059\"\"\"\n    m = (r + 2 * l) // 3\n    q = (2 * r + l) // 3\n    lf = sum([abs(A[i] - l) for i in range(N)])\n    rf = sum([abs(A[i] - r) for i in range(N)])\n    mf = sum([abs(A[i] - m) for i in range(N)])\n    qf = sum([abs(A[i] - q) for i in range(N)])\n    while r - l >= 3:\n        m = (r + 2 * l) // 3\n        q = (2 * r + l) // 3\n        lf = sum([abs(A[i] - l) for i in range(N)])\n        mf = sum([abs(A[i] - m) for i in range(N)])\n        qf = sum([abs(A[i] - q) for i in range(N)])\n        rf = sum([abs(A[i] - r) for i in range(N)])\n        if mf >= qf:\n            l = m\n        else:\n            r = q\n    return min(lf, mf, qf, rf)\n\n\ndef solve(N, A, EPS=1e-3):\n    D = [A[i] - i - 1 for i in range(N)]\n    return find_minimum(N, D, l=-10**10, r=10**10)\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "import statistics\nimport math\n\nN = int(input())\nA_list = list(map(int, input().split()))\n\nA_list_min = 10**9+1\nA_list_sum = 0\nfor i in range(N):\n    A_list[i] = A_list[i] - (i+1)\n\nA_medi = int(statistics.median(A_list))\nans = 0\nfor i in range(N):\n    ans += abs(A_list[i] - A_medi)\nprint(ans)", "N=int(input())\nA=list(map(int, input().split()))\ns=[0]*N\n\nfor i,a in enumerate(A):\n    s[i]=a-i-1\ns.sort()\n\nif N%2==0:\n    b=(s[N//2-1]+s[N//2])//2\nelse:\n    b=s[N//2]\n\nans=0\nfor i,a in enumerate(s):\n    ans+=abs(a-b)\nprint(ans)", "N = int(input())\nA = list(map(int,input().split()))\nA.insert(0,0)\nB = [A[i]-i for i in range(N+1)]\nB.pop(0)\nB = sorted(B)\nif N%2==1:\n    b = B[N//2]\n    cnt = 0\n    for i in range(N):\n        cnt += abs(B[i]-b)\nelse:\n    b1 = B[N//2-1]\n    cnt1 = 0\n    for i in range(N):\n        cnt1 += abs(B[i]-b1)\n    b2 = B[N//2]\n    cnt2 = 0\n    for i in range(N):\n        cnt2 += abs(B[i]-b2)\n    cnt = min(cnt1,cnt2)\nprint(cnt)", "import statistics\nN = int(input())\nA = list(map(int,input().split()))\nfor i in range(N):\n  A[i] -= i+1\nA.sort()\nb = statistics.median(A)\ns = 0\nfor i in range(N):\n  s += abs(A[i] - b)\nprint(int(s))  ", "def snk(b, A):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-(b+i+1))\n    return res\n    \nN = int(input())\nA = [int(i) for i in input().split()]\n\nl = 1-N\nr = 10**9 + N\n\nwhile r-l > 2:\n    ls = snk(l, A)\n    rs = snk(r-1, A)\n    m = (l + r) //2\n    ms = snk(m, A)\n\n    mp1s = snk(m+1, A)\n    mm1s = snk(m-1, A)\n    if mp1s <= ms <= mm1s:\n        l = m\n    elif mp1s >= ms >= mm1s:\n        r = m+1\n    elif mp1s >= ms and ms <= mm1s:\n        break\n    #print(l, m, r, ls, ms, rs)\nprint(ms) \n\n\n\n", "import bisect\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor\nfrom typing import List\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\n\ndef main():\n    N = int(input())\n    A = lmi()\n    A_dash = [a - (i + 1) for i, a in enumerate(A)]\n    A_dash.sort()\n    b = A_dash[N // 2]\n    ans = sum(abs(a - b) for i, a in enumerate(A_dash))\n    if N // 2 + 1 < len(A_dash):\n        b = A_dash[N // 2 + 1]\n        ans = min(ans, sum(abs(a - b) for i, a in enumerate(A_dash)))\n\n    print(ans)\n\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[32]:\n\n\nimport numpy as np\n\n\n# In[22]:\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\n\n# In[41]:\n\n\na = np.array(A)\nb = a - np.arange(1,N+1)\nc = np.median(b)\nd = abs(b-c).sum()\nprint((int(d)))\n\n\n# In[ ]:\n\n\n\n\n", "n = int(input())\nA = list(map(int,input().split()))\nB, total = [], 0\nfor i in range(n): B.append(A[i] - i)\nB.sort()\nif len(B) % 2 == 0:\n  b = (B[n//2-1] + B[n//2]) // 2\nelse: b = B[n//2]\nfor i in range(n): total += abs(B[i] - b)\nprint(total)", "N = int(input())\nA = input().split(\" \")\nB = []\nfor i in range(N):\n    B.append(int(A[i])-(i+1))\nB.sort()\n\nans = 0\n\nfor i in range(N):\n    ans += abs(int(A[i])-(B[N // 2]+i+1))\n\nprint(ans)\n", "N = int(input())\nA = list(map(int, input().split()))\nmedian = sorted(a - i for i, a in enumerate(A))[N // 2]\nprint((sum(abs(a - (median + i)) for i, a in enumerate(A))))\n\n", "n = int(input())\nAs = list(map(int, input().split()))\nfor i in range(n):\n  As[i] = As[i]-i\nAs = sorted(As)\nb1 = As[n // 2]\nif n % 2 == 0:\n  b2 = As[(n - 1) // 2]\nelse:\n  b2 = As[n // 2]\nans1 = 0\nans2 = 0\nfor i in range(n):\n  ans1 += abs(b1 - As[i])\n  ans2 += abs(b2 - As[i])\nprint(min(ans1,ans2))", "import bisect\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor\nfrom typing import List\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\n\ndef main():\n    N = int(input())\n    A = lmi()\n    A_dash = [a - (i + 1) for i, a in enumerate(A)]\n    A_dash.sort()\n    b = A_dash[N // 2]\n    ans = sum(abs(a - b) for i, a in enumerate(A_dash))\n\n    print(ans)\n\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n = int(input())\nal = list(map(int, input().split()))\nbl = list(i+1 for i in range(n))\ncl = []\nfor a, b in zip(al, bl):\n    cl.append(a-b)\ncl.sort()\nx = cl[n//2]\n\nans = 0\nfor a, b in zip(al, bl):\n    ans += abs(a-b-x)\nprint(ans)", "N = int(input())\nA = list(map(int,input().split()))\nfor i in range(N):\n  A[i] -= i\nA.sort()\n\nn = N//2\nans = 0\nfor i in range(N):\n  ans += abs(A[n] - A[i])\nprint(ans)", "N = int(input())\nvA = list(map(int, input().split()))\nvAm = sorted([vA[i]-i-1 for i in range(N)])\nb = vAm[N//2]\nvans = [abs(Am-b) for Am in vAm]\nprint(sum(vans))", "import sys\n\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\n\nfor i in range(N):\n    A[i] -= i + 1\n\nA.sort()\nans = float(\"inf\")\ncand = [A[N//2]]\nif N > 1:\n    cand.append(A[N//2+1])\nfor i in cand:\n    tmp = 0\n    for a in A:\n        tmp += abs(a - i)\n    ans = min(ans, tmp)\n\nprint(ans)", "import sys\nfrom statistics import median\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A = [A[i] - (i + 1) for i in range(n)]\n    M = int(median(A))\n    res = 0\n    for a in A:\n        res += abs(a - M)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\nfrom math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\nimport numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    N = II()\n    A = LI()\n    for i in range(N):\n        A[i] = A[i] - (i+1)\n    med = int(np.median(A))\n    # print(med)\n    ans = 0\n    for a in A:\n        ans += abs(a - med)\n    print(ans)\n\n\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "def main():\n    N = int(input())\n    A = list(map(int,input().split()))\n    #print(A)\n    for i in range(1,N+1):\n        A[i-1] -= i\n    #print(A)\n    A.sort()\n    b = A[N//2]\n    ans = 0\n    for a in A:\n        ans += abs(a-b)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nimport numpy as np\nimport sys\ninput = sys.stdin.readline\n\nmod=1000000007\n\ndef main():\n    n = int(input())\n    A = list(map(int,input().split()))\n    for i in range(n):\n        A[i] -= i+1\n    b = int(np.median(A))\n    for i in range(n):\n        A[i] = abs(A[i]-b)\n\n    print(int(np.sum(A)))\n\nmain()", "import sys\n\nN = int(input())\nA = list(map(int, sys.stdin.readline().rsplit()))\n\nfor i in range(N):\n    A[i] = A[i] - (i + 1)\n\nA.sort()\nb = A[(N - int(N % 2 == 0)) // 2]\n\nres = 0\nfor a in A:\n    res += abs(a - b)\n\nprint(res)\n", "N,*A = list(map(int, open(0).read().split()))\nif N==1:\n    print((0))\nelse:\n    cs=[a-i for i,a in enumerate(A)]\n    cs.sort()\n    n=len(cs)\n    half=n//2\n    d1=-cs[half]\n    d2=-cs[half+1]\n    sad1=sum([abs(c+d1) for c in cs])\n    sad2=sum([abs(c+d2) for c in cs])\n    print((min(sad1,sad2)))\n", "N = int(input())\nA = [int(i) for i in input().split()]\n\ndef snk(b):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-(b+i+1))\n    return res\n    \nl = 1-N\nr = 10**9 + N\n\nwhile r-l > 2:\n    m = (l + r) //2\n    mm1s, ms, mp1s = [snk(m+i) for i in [-1,0,1]]\n\n    if mm1s >= ms >= mp1s:\n        l = m\n    elif mm1s <= ms <= mp1s:\n        r = m+1\n    elif mp1s >= ms and ms <= mm1s:\n        break\n    #print(l, m, r, ls, ms, rs)\nprint(ms) ", "N = int(input())\nA = [int(i) for i in input().split()]\n\ndef snk(b):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-(b+i+1))\n    return res\n    \nl = 1-N\nr = 10**9 + N\n\nwhile r-l > 2:\n    m = (l + r) //2\n    ms = snk(m)\n    mp1s = snk(m+1)\n    mm1s = snk(m-1)\n    if mm1s >= ms >= mp1s:\n        l = m\n    elif mm1s <= ms <= mp1s:\n        r = m+1\n    elif mp1s >= ms and ms <= mm1s:\n        break\n    #print(l, m, r, ls, ms, rs)\nprint(ms) ", "# a,b = map(int,input().split())\n# a = list(map(int,input().split()))\n# a = [list(map(int,input().split())) for _ in range(n)]\n\n# import sys\n# read = sys.stdin.buffer.read\n# readline = sys.stdin.buffer.readline\n# readlines = sys.stdin.buffer.readlines\n\n# \u691c\u8a0e?\u5206\u3000\u5b9f\u88c5\u5206 \u30d0\u30b0\u3068\u308a\u5206\n\n# import sys\n# import os\n# f = open('../../../input.txt', 'r')\n# sys.stdin = f\n\nn = int(input())\na = list(map(int,input().split()))\na2 = [ai-i for i,ai in enumerate(a,1) ]\n\na2.sort()\ncumsum = [0] * n\ncumsum[0] = a2[0]\nfor i in range(n-1):\n    cumsum[i+1] = cumsum[i] + a2[i+1]\n\nans = 10**20\nfor i in range(n):\n    low = cumsum[i]\n    high = cumsum[-1] - cumsum[i]\n    ai = a2[i]\n    ans = min(ans, (ai*(i+1)-low) + (high - ai*(n-1-i)) )\nprint(ans)", "import statistics\nfrom functools import reduce\nn = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n    A[i]-=i+1\n\nm = int(statistics.median(A))\nans1 = 0\nans2 = 0\nfor i in range(n):\n    ans1 += abs(m-A[i])\n    ans2 += abs(m+1-A[i])\nprint(min(ans1, ans2))", "n = int(input())\nA = []\nfor i, a in enumerate(map(int, input().split()), 1):\n    A.append(a-i)\nA.sort()\nb = A[n//2]\nans = 0\nfor a in A:\n    ans += abs(a-b)\nprint(ans)\n", "import sys, math\nfrom itertools import combinations as c, permutations as perm, product as p\nfrom collections import deque\nsys.setrecursionlimit(10**9)\nINF = float('inf')\nMOD = 10**9 + 7\n#MOD = 998244353\n\n\ndef si(): return input()\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef lstr(): return input().split()\ndef lint(): return list(map(int, input().split()))\ndef lintdec(): return list(map(lambda x:int(x) - 1, input().split()))\ndef lnstr(n): return [input() for _ in range(n)]\ndef lnint(n): return [int(input()) for _ in range(n)]\ndef lint_list(n): return [lint() for _ in range(n)]\n\n\n\n############################################################\nN = ii()\nA = lint()\nB = [A[i] - i - 1 for i in range(N)]\nB.sort()\n\nif N % 2 == 1:\n    m = B[N // 2]\n    print(sum(abs(b - m) for b in B))\nelse:\n    m = ((B[N // 2] + B[N // 2 - 1])) / 2\n    print(int(sum(abs(b - m) for b in B)))", "n = int(input())\naa = list(map(int, input().split()))\n\nfor i in range(n):\n    aa[i] -= i\n\naa.sort()\n\nmid = aa[n // 2]\n\nprint(sum(abs(a - mid) for a in aa))", "import statistics\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    c = [a[i]-i-1 for i in range(n)]\n    b = int(statistics.median(c))\n    ans = 0\n    for i in range(n):\n        ans += abs(a[i]-(b+i+1))\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nN = input().split()\nN = (int)(N[0])\nA = np.array(list(map(int, input().split())))\n\ns = 0\nI = np.array([i+1 for i in range(N)])\nAminusi = np.array(A-I)\n\n\nmmid = np.median(Aminusi)\n\nsad = 0\nfor l in Aminusi :\n    sad += abs(l-mmid)\n\nprint((int(sad)))\n\n", "n = int(input().strip())\ninput_line = list(map(int, input().strip().split(' ')))\n\nfor idx in range(n):\n\tinput_line[idx] = input_line[idx] - (idx + 1)\n\ninput_line.sort()\n\nmin_num = input_line[0]\nnum_sum = 0\nfor idx in range(n):\n\tnum_sum = num_sum + abs(input_line[idx] - min_num)\n\nres = num_sum\nfor idx in range(1, n):\n\tpoint_dist = input_line[idx] - input_line[idx - 1]\n\tthis_dist = num_sum + (idx * point_dist) - (n - idx) * point_dist\n\tnum_sum = this_dist\n\tres = min(res, this_dist)\nprint(res)\n    \n\t\n\n", "from statistics import median\nn = int(input())\na = list(map(int,input().split()))\nfor i in range(n):\n    a[i] -= i+1\n\na.sort()\n\nm = int(median(a))\n\nprint(sum(abs(a[i] - m) for i in range(n)))", "n = int(input())\na = [ai - i for ai, i in zip(map(int, input().split()), [j for j in range(1, n+1)])]\na.sort()\nif n % 2:\n    b = a[n//2]\n    print(sum([abs(ai-b) for ai in a]))\nelse:\n    b1, b2 = a[n//2-1], a[n//2]\n    print(min(sum([abs(ai-b1) for ai in a]), sum([abs(ai-b2) for ai in a])))", "N=int(input())\nA=list(map(int,input().split()))\nimport numpy as np\nA_np=np.array(A)\ndata=np.array(list(range(1,N+1)))\nA_i=sorted(A_np-data)\nif N%2==0:\n    x=A_i[int(N/2)-1]\n    y=A_i[int(N/2)]\n    A_x=A_i-x\n    A_p_x=A_x[(A_x>=0)]\n    A_m_x=A_x[(A_x<0)]\n    A_y=A_i-y\n    A_p_y=A_y[(A_y>=0)]\n    A_m_y=A_y[(A_y<0)]\n    ans=min(sum(A_p_x)-sum(A_m_x),sum(A_p_y)-sum(A_m_y))\n    print(ans)\nelse:\n    x=A_i[int((N-1)/2)]\n    A_x=A_i-x\n    A_p=A_x[(A_x>=0)]\n    A_m=A_x[(A_x<0)]\n    ans=sum(A_p)-sum(A_m)\n    print(ans)", "N = int(input())\nA = list(map(int, input().split()))\n\nfor i in range(N):\n    A[i] -= i + 1\nA = sorted(A)\nb = A[N // 2]\nans = 0\nfor a in A:\n    ans += abs(a - b)\nprint(ans)\n", "N = int(input())\nA = [int(i) for i in input().split()]\n\ndef snk(b):\n    return sum([abs(A[i]-(b+i+1)) for i in range(N)])\n    \nl = 1-N\nr = 10**9 + N\n\nwhile r-l > 2:\n    m = (l + r) //2\n    mm1s, ms, mp1s = [snk(m+i) for i in [-1,0,1]]\n    \n    if mm1s >= ms >= mp1s:\n        l = m\n    elif mm1s <= ms <= mp1s:\n        r = m+1\n    elif mp1s >= ms and ms <= mm1s:\n        break\n    #print(l, m, r, ls, ms, rs)\nprint(ms) ", "n = int(input())\na = list(map(int,input().split()))\nb = []\nfor i,aa in enumerate(a):\n    b.append(aa-(i+1))\nb.sort()\ns1,s2 = 0,0\nm1,m2 = 0,0\nif n%2 == 0:\n    m1 = b[n//2]\n    m2 = b[n//2+1]\n    for bb in b:\n        s1 += abs(bb-m1)\n        s2 += abs(bb-m2)\n    print((min(s1,s2)))\nelse:\n    m1 = b[n//2]\n    for bb in b:\n        s1 += abs(bb-m1)\n    print(s1)\n\n\n\n", "def main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    l = -1*max(a)-2*10**5\n    r = max(a)+2*10**5\n    def f(k):\n        ans = 0\n        for i in range(n):\n            ans += abs(a[i]-1-i-k)\n        return ans\n    while l+1<r:\n        if f(l)<f(r):\n            r = (l+r)//2\n        else:\n            l = (l+r)//2\n    print((min(f(l),f(r))))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nN = int(input())\nA = list(map(int, input().split()))\n\n#|x-a|+|x-b|+|x-c|+...\u3092\u6700\u5c0f\u5316\u3059\u308bx\u306e\u5024\u306fa,b,c...\u306e\u4e2d\u592e\u5024\n\nfor i in range(1, N+1):\n    A[i-1] -= i\n\nA.sort()\n\nif N % 2 == 0:\n    mid = N//2 - 1\n\n    ans = 0\n    for i in range(N):\n        ans += abs(A[i] - A[mid])\n\n    tmp = 0\n    for i in range(N):\n        tmp += abs(A[i] - A[mid+1])\n\n    ans = min(ans, tmp)\n    print(ans)\n\nelse:\n    mid = N//2\n\n    ans = 0\n    for i in range(N):\n        ans += abs(A[i] - A[mid])\n    print(ans)\n", "\ndef resolve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    # list_B = |Ai-(x+i)| -> |(Ai-i)-x|\n    # Bi = Ai-i -> |Bi-x|\n\n    B = [a - i for i, a in enumerate(A, 1)]\n    B.sort()\n    x = B[N // 2]\n\n    ans = 0\n    for b in B:\n        ans += abs(x - b)\n\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\nans = 0\nfor i in range(n):\n    a[i] = a[i]-(i+1)\n    ans += abs(a[i])\n#print(a)\na.sort()\nfor b in a[n//2-1:n//2+1]:\n    tmp = 0\n    for i in range(n):\n        tmp += abs(a[i]-b)\n    ans = min(ans,tmp)\nprint(ans)", "n = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n    A[i] -= (i+1)\nA.sort()\nans = 0\nb = A[n//2]\nfor a in A:\n    ans += abs(a-b)\nprint(ans)\n", "N = int(input())\nA = list(map(int, input().split()))\nfor i in range(N):\n    A[i] -= i+1\nA.sort()\nx = A[N//2]\nans = 0\nfor a in A:\n    ans += abs(a-x)\nprint(ans)", "#C\nimport statistics\nN = int(input())\nA = list(map(int, input().split()))\n\n# abs(A[i]-i+b)\u3088\u308a\u3001\n# b\u306f(A[i]-i)\u30ea\u30b9\u30c8\u306e\u4e2d\u592e\u5024\nAs = []\nfor i in range(N):\n    As.append(A[i] - (i + 1))\nmid = int(statistics.median(As))\n\nresult = 0\nfor i in range(N):\n    result += abs(A[i] - (mid + i + 1))\nprint(result)\n", "import sys\ninput = sys.stdin.readline\nimport math\n\n\ndef read():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    return N, A\n\n\ndef solve(N, A, EPS=1e-3):\n    D = [A[i] - i - 1 for i in range(N)]\n    D.sort()\n    if N == 1:\n        median = sum([abs(d - D[0]) for d in D])\n        return median\n    median_left = sum([abs(d - D[N//2]) for d in D])\n    median_right = sum([abs(d - D[N//2 + 1]) for d in D])\n    return min(median_left, median_right)\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "N = int(input())\nA = [int(i) for i in input().split()]\n\ndef snk(b):\n    return sum([abs(A[i]-(b+i+1)) for i in range(N)])\n    \nl = 1-N\nr = 10**9 + N\n\nans = 10**18\n\nwhile l+2 < r:\n    l1 = (l*2 + r) //3\n    r1 = (l + r*2) //3\n    ls, rs = [snk(i) for i in [l1, r1]]\n    if ls > rs:\n      l = l1\n    else:\n      r = r1\n      \nans = 10**18\nfor i in range(l,r+1):\n  ans = min(ans, snk(i))\n\nprint(ans) ", "n = int(input())\na = list(map(int,input().split()))\n\narr = []\nfor i in range(n):\n    arr.append(a[i] - (i+1))\n\nsorted_arr = sorted(arr)\nif n % 2 == 1:\n    val = sorted_arr[n//2]\n    for i in range(n):\n        arr[i] = arr[i] - val\n    print(sum([abs(i) for i in arr]))\nelse:\n    arr1 = []\n    arr2 = []\n    val1 = sorted_arr[n//2]\n    val2 = sorted_arr[n//2 - 1]\n    for i in range(n):\n        arr1.append(arr[i] - val1)\n        arr2.append(arr[i] - val2)\n    print(min(sum([abs(i) for i in arr1]),sum([abs(i) for i in arr2])))", "n = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n  A[i] = A[i] - (i+1)\n\nA.sort()\nb = A[n//2]\n\nans = 0\nfor i in range(n):\n  ans += abs(A[i] -b)\nprint(ans)", "n = int(input())\nAs = list(map(int, input().split()))\nfor i in range(n):\n  As[i] = As[i]-i\nAs = sorted(As)\nb = As[n // 2]\nans = 0\nfor i in range(n):\n  ans += abs(b - As[i])\nprint(ans)", "n = int(input())\na = list(map(int,input().split()))\n\nfor i in range(n):\n    a[i] -= (i+1)\n\na.sort()\n\nm = a[n//2]\nans = 0\nfor i in range(n):\n    ans += abs(a[i]-m)\n\nprint(ans)", "n = int(input())\nA = list(map(int,input().split()))\nB, total = [], 0\nfor i in range(n): B.append(A[i] - i)\nB.sort()\nif len(B) % 2 == 0:\n  b = (B[n//2-1] + B[n//2]) // 2\nelse: b = B[n//2]\nfor i in range(n): total += abs(B[i] - b)\nprint(total)", "import numpy as np\nn = int(input())\na = list(map(int, input().split()))\na_ = [abs(a[i]) -  (i+1) for i in range(n)] \nmed = int(np.median(a_))\n\ndef fun(a, b):\n    ans = 0\n    for i in range(1, len(a)+1):\n        ans += abs(a[i-1]-(b+i))\n    return ans\n\nprint(fun(a, med))", "N=int(input())\nA=list(map(int,input().split()))\nB=[]\nfor i in range(N):\n  B.append(A[i]-(i+1))\nB.sort()\nb=B[N//2]\nans=0\nfor i in range(N):\n  ans+=abs(B[i]-b)\nprint(ans)", "n=int(input())\na=list(map(int,input().split()))\nfor i in range(n):\n  a[i]-=i+1\n\na.sort()\nif n%2==1:\n  k=a[n//2]\nelse:\n  k=a[n//2]\n  \n  \n\nans=0\nfor i in range(n):\n  ans+=abs(a[i]-k)\n  \nprint(ans)\n\n\n", "def resolve():\n  inf = 10**10+1\n  N = int(input())\n  A = [int(x) for x in input().split(\" \")]\n  # \u4e00\u65e6 A[i] - i + 1 \u3092\u8a08\u7b97\u3059\u308b\u3002\n  for i in range(N): A[i]-=i+1\n  A.sort()\n  # \u4e2d\u592e\u5024\u3092 b \u3068\u3059\u308b\u3002\n  if len(A)%2:\n    b=A[len(A)//2]\n  else:\n    center = len(A)//2\n    b=round((A[center]+A[center-1])//2)\n\n  # \u7b54\u3048\n  ans = 0\n  for i in range(N):ans += abs(A[i]-b)\n  print(ans)\n\nresolve()", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn = int(readline())\n*a, = map(int,readline().split())\n\nfor i in range(n):\n    a[i] -= i+1\na.sort()\nb = a[n//2]\nans = sum(abs(ai-b) for ai in a)\n\nprint(ans)", "import sys\n\n\ndef IN_I(): return int(sys.stdin.readline().rstrip())\ndef IN_LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef IN_S(): return sys.stdin.readline().rstrip()\ndef IN_LS(): return list(sys.stdin.readline().rstrip().split())\nINF = float('inf')\nMOD = 10**9 + 7\n\n\nN = IN_I()\nA = IN_LI()\nfor i in range(N):\n    A[i] -= (i+1)\n\nA.sort()\n\nif N % 2 ==1:\n    b = A[N//2]\nelse:\n    b = (A[N//2-1] + A[N//2]) // 2\n\nans = 0\nfor a in A:\n    ans += abs(a-b)\nprint(ans)\n", "n=int(input())\na=list(map(int,input().split()))\nnewa=[]\nfor i in range(n):\n    newa.append(a[i]-i-1)\nnewa.sort()\nif n%2==0:\n    mid=(newa[n//2-1]+newa[n//2])//2\nelse:\n    mid=newa[n//2]\nans=0\nfor i in range(n):\n    ans+=abs(newa[i]-mid)\nprint(ans)", "n = int(input())\na = list(map(int, input().split()))\n\nstairs = [1] * n\nl, r = 10 ** 9, - 2 ** 5\nfor i in range(n):\n    stairs[i] += i\n    r = max(r, a[i] - stairs[i])\n    l = min(l, a[i] - stairs[i])\n\ndef pos(b):\n    return sum(abs(i - b - j) for i, j in zip(a, stairs))\n    \nwhile l + 2 < r:\n    c1 = l + (r - l) // 3\n    c2 = r - (r - l) // 3\n    if pos(c1) < pos(c2):\n        r = c2\n    else:\n        l = c1\n\nans = min(min(pos(l), pos(r)), pos(l + 1))\nprint(ans)", "n = int(input())\na = list([int(x[1]) - x[0] - 1 for x in enumerate(input().split())])\nnh = (n + 1) // 2\na.sort()\nb = a[nh-1]\ns = 0\nfor ai in a: s+= abs(ai-b)\nprint(s)\n\n", "n = int(input())\na = list(map(int,input().split()))\nfor i in range(n):\n    a[i] -= i + 1\na.sort()\n\nif (n%2 == 1):\n    b = a[n//2]\nelse:\n    b = a[n//2]\n\nans = 0\nfor i in range(n):\n    ans += abs(a[i] - b)\n\nprint(ans)\n", "import sys\nfrom functools import reduce\n\nzz=1\n \nsys.setrecursionlimit(10**5)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef ii():\n\treturn input().rstrip()\t\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tlist(map(int,input().split()))\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\nuu=t\n\t\t\t\t\ndef can(val):\n\tp=val;c=0\n\tfor i in range(n):\n\t\tc+=abs(a[i]-p)\n\t\tp+=1\n\treturn c\t\n\nwhile t>0:\n\tt-=1\n\tn=fi()\n\ta=li()\n\tl=-2*max(a)\n\tr=2*max(a)\n\tmini=10**18\n\twhile l<=r:\n\t\tlmid=l+(r-l)//3\n\t\trmid=r-(r-l)//3\n\t\tp1=can(lmid)\n\t\tp2=can(rmid)\n\t\tmini=min([mini,p1,p2])\n\t\tif p1>=p2:\n\t\t\tl=lmid+1\n\t\telse:\n\t\t\tr=rmid-1\n\tprint(mini)\t\t\t\n", "import math\n\nN = int(input())\nA = list(map(int,input().split()))\n\nfor i in range(N):\n    A[i] -= (i+1)\n\nA.sort()\n\nif N % 2 == 0:\n    b = (A[N//2-1] + A[N//2]) / 2\n    bfl = math.floor(b)\n    bce = math.ceil(b)\n    ansfl = 0\n    ansce = 0\n\n    for i in range(N):\n        ansfl += abs(A[i] - bfl)\n        ansce += abs(A[i] - bce)\n\n    ans = min(ansfl, ansce)\n\nelse:\n    ans = 0\n    b = A[N//2]\n\n    for i in range(N):\n        ans += abs(A[i] - b)\n\nprint(ans)", "N = int(input())\nA = sorted([int(x) - i for i, x in enumerate(input().split(), 1)])\nmid = N // 2\nans = sum(list([abs(x - A[mid]) for x in A]))\nif N % 2 == 0:\n    _mid = N // 2 + 1\n    _ans = sum(list([abs(x - A[_mid]) for x in A]))\n    ans = min(ans, _ans)\nprint(ans)\n", "n = int(input())\naa = list(map(int, input().split()))\nam = [aa[i]-(i+1) for i in range(n)]\nam = sorted(am)\n\nb1 = am[n//2-1]\nb2 = am[n//2]\n\n\n\nsum1 = 0\nsum2 = 0\n\nfor i in range(n):\n  sum1 += abs(am[i]-b1)\n  sum2 += abs(am[i]-b2)\n  \n\nans = min(sum1, sum2)\nprint(ans)\n", "# coding:UTF-8\nimport sys\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\n\nN = int(input())    # \u6570\u5b57\nA = list(map(int, input().split()))     # \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u9023\u7d9a\u6570\u5b57\n\nAafter = [A[i]-(i+1) for i in range(N)]\n\nminus = []\nzero_count = 0\nplus = []\nfor i in range(N):\n    if Aafter[i] < 0:\n        minus.append(-Aafter[i])\n    elif Aafter[i] == 0:\n        zero_count += 1\n    else:\n        plus.append(Aafter[i])\n\nminus.sort()\nplus.sort()\n\nminus_count = len(minus)\nplus_count = len(plus)\n\nbias = 0\nif minus_count + zero_count < plus_count:\n    dif = (plus_count - (minus_count + zero_count)) // 2\n    bias = plus[dif]\nelif plus_count + zero_count < minus_count:\n    dif = (minus_count - (plus_count + zero_count)) // 2\n    bias = -minus[dif]\n\nres = 0\nfor i in range(N):\n    res += abs(Aafter[i] - bias)\n\n\nprint((\"{}\".format(res)))\n", "#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN = I()\nA = readInts()\nS = []\nfor i in range(N):\n    S.append(A[i]-(i+1))\nS = sorted(S)\n#print(S)\nnya = []\nnya.append(S[min(N//2+1,N-1)])\nnya.append(S[N//2])\nnya.append(S[N//2-1])\nans = INF\nfor n in nya:\n    wa = 0\n    for i in range(N):\n        wa += abs(A[i] - (n + (i+1)))\n    ans = min(ans, wa)\nprint(ans)\n", "def resolve():\n  inf = 10**10+1\n  N = int(input())\n  A = [int(x) for x in input().split(\" \")]\n  # \u4e00\u65e6 A[i] - i + 1 \u3092\u8a08\u7b97\u3059\u308b\u3002\n  # A[i] \u304c\u6b63\u306e\u6642\u3001b \u3092\u6b63\u306b\u3059\u308b\u3068 abs \u304c b \u5206\u6e1b\u308b\u3002\n  # A[i] \u304c\u8ca0\u306e\u6642\u3001b \u3092\u8ca0\u306b\u3059\u308b\u3068 abs \u304c b \u5206\u6e1b\u308b\u3002\n  # A[i] \u304c0\u306e\u6642\u3001b abs \u306f\u3069\u3046\u3084\u3063\u3066\u3082\u5897\u3048\u308b\u3002\n  # \u3064\u307e\u308a \u6b63\u3068\u8ca0\u3068\u30bc\u30ed\u306e A[i] \u3092\u6570\u3048\u3066\u3001\u305d\u308c\u305e\u308c plus, minus, zero \u3068\u3059\u308b\u3068\u3001\n  # abs \u306f b*(plus-minus) + abs(b)*zero \u5206\u5897\u3048\u308b\u3002\n  for i in range(N): A[i]-=i+1\n  A.sort()\n  if len(A)%2:\n    b=A[len(A)//2]\n  else:\n    b=round((A[len(A)//2]+A[len(A)//2-1])//2)\n  ans = 0\n  for i in range(N):ans += abs(A[i]-b)\n  # print(A, average_A)\n  print(ans)\n\nresolve()", "def main():\n    N = int(input())\n    a_list = list(map(int, input().split()))\n\n    s_list = [n - i for i, n in enumerate(a_list)]\n    s_list.sort()\n\n    b = s_list[N//2]\n\n    result = sum(abs(n-b) for n in s_list)\n\n    print(result)\n\nmain()\n\n", "import sys\n# sys.setrecursionlimit(100000)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef input_int():\n    return int(input())\n\n\ndef input_int_list():\n    return [int(i) for i in input().split()]\n\n\ndef main():\n    n = input_int()\n    A = input_int_list()\n    for i in range(n):\n        A[i] = A[i] - (i + 1)\n\n    A.sort()\n\n    if n % 2 == 0:\n        mid = (A[(n - 1) // 2] + A[((n - 1) // 2) + 1]) // 2\n    else:\n        mid = A[(n - 1) // 2]\n\n    tmp0 = 0\n    tmp1 = 0\n\n    for a in A:\n        tmp0 += abs(a - mid)\n        tmp1 += abs(a - mid - 1)\n\n    print((min(tmp0, tmp1)))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nA = [int(i) for i in input().split()]\nA = [A[i]-i-1 for i in range(N)]\nA.sort()\n\ndef snk(b):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-b)\n    return res\nif N == 1:\n    print(snk(A[N//2]))\n    return\nprint(min(snk(A[N//2]), snk(A[N//2 +1])))", "n = int(input())\na = list(map(int,input().split()))\nb = [0] * n\nfor i in range(n):\n    b[i] = a[i] - i\nb.sort()\nx = b[n//2]\nans = 0\nfor i in range(n):\n    ans += abs(b[i]-x)\nprint(ans)", "from statistics import mean, median,variance,stdev\n\nn=int(input())\nA=list(map(int,input().split()))\nA_b=A.copy()\nfor i in range(n):\n  tmp=A[i]-i-1\n  A_b[i]=tmp\n\nb=int(median(A_b))\n\nans=0\nfor i in range(n):\n  ans+=abs(A[i]-b-i-1)\nprint(ans)", "n = int(input())\na = list(map(int,input().split()))\nb = a\nfor bb in range(n):\n    b[bb] -= (bb+1)\nb.sort()\n\nif n % 2 == 1:\n    c = b[n//2]\n    d = c\nelse:\n    c1 = b[n//2-1]\n    c2 = b[n//2]\n    c = c1 + c2\n    if c % 2 == 1:\n        c = c // 2\n        d = c + 1\n    else:\n        c = c // 2\n        d = c\nres1 = 0\nres2 = 0\nfor i in range(n):\n    res1 += abs(b[i]-c)\nfor j in range(n):\n    res2 += abs(b[j]-d)\n    \nprint(min(res1,res2))", "N=int(input())\nA=list(map(int,input().split()))\nfor i in range(N):\n  A[i]=A[i]-(i+1)\nA.sort()\nans=0\nanssub=A[N//2]\nfor i in range(N):\n  ans+=abs(A[i]-anssub)\nprint(ans)  ", "n = int(input())\narr = list(map(int, input().split()))\nal = list(ai-(i+1) for i, ai in enumerate(arr))\nal_s = sorted(al)\n\n\ndef func(ARR, x):\n    tmp = 0\n    for ai in ARR:\n        tmp += abs(ai-x)\n    return tmp\n\n\nif n%2 != 0:\n    b = al_s[n//2]\n    ans = func(al, b)\nelse:\n    b1 = al_s[n//2]\n    b2 = al_s[n//2-1]\n    ans = min(func(al, b1), func(al, b2))\n\nprint(ans)", "n = int(input())\nA = list(map(int,input().split()))\nB = []\nfor i in range(n):\n    B.append(A[i]-(i+1))\nB.sort()\n\nif len(B)%2:\n    ans = 0\n    for i in range(n):\n        ans += abs(B[i]-B[len(B)//2])\nelse:\n    ans = float(\"inf\")\n    tmp = 0\n    for i in range(n):\n        tmp += abs(B[i]-B[len(B)//2-1])\n    ans = min(ans, tmp)\n    tmp = 0\n    for i in range(n):\n        tmp += abs(B[i]-B[len(B)//2])\n    ans = min(ans, tmp)\n\nprint(ans)", "\nN = int(input())\nA = [int(i) for i in input().split()]\n\ndef snk(b):\n    res = 0\n    for i in range(N):\n        res += abs(A[i]-(b+i+1))\n    return res\n    \nl = 1-N\nr = 10**9 + N\n\nwhile r-l > 2:\n    m = (l + r) //2\n    ms = snk(m)\n    mp1s = snk(m+1)\n    mm1s = snk(m-1)\n    if mp1s <= ms <= mm1s:\n        l = m\n    elif mp1s >= ms >= mm1s:\n        r = m+1\n    elif mp1s >= ms and ms <= mm1s:\n        break\n    #print(l, m, r, ls, ms, rs)\nprint(ms) ", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [0] + list(map(int, input().split()))\nlst = []\nfor n in range(1, N+1):\n    lst.append(A[n] - n)\nlst.sort()\nmedian = lst[N//2]\nans = sum([abs(x - median) for x in lst])\nprint(ans)", "n=int(input())\n*a,=map(int,input().split())\nb=sorted([x-i for i,x in enumerate(a)])\nans=0\nfor x in b:\n    ans+=abs(x-b[n//2])\n\nprint(ans)", "# coding: utf-8\nn = int(input())\nA = list(map(int,input().split()))\nL=[]\nfor i in range(n):\n    L.append(A[i]-(i+1))\nL.sort()\n#print(L)\nif n==1:\n    b1=L[0]\n    b2=L[0]\nelif n==2:\n    b1=L[0]\n    b2=L[1]\nelse:\n    b1=L[n//2]\n    b2=L[n//2-1]\nans=0\ncnt1=0\ncnt2=0\nfor i in range(n):\n    cnt1+=abs(L[i]-b1)\n    cnt2+=abs(L[i]-b2)\nprint(min(cnt1,cnt2))", "import statistics\n\nn = int(input())\nx = list(map(int, input().split()))\n\nvalue = 0\n\nfor _ in range(n):    \n    x[_] -= (_ + 1)\n\nx.sort()\n\nfor _ in x:\n    value += abs(_ - x[n // 2])\n\nprint(value)", "import statistics\nn = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n  a[i] = a[i] - (i + 1)\n\nmin_sad = float(\"inf\")\nb = int(statistics.median(a))\nfor b_ in range(b-1, b+2):\n  a_ = [abs(i - b_) for i in a]\n  sad = sum(a_)\n  min_sad = min(sad, min_sad)\n  \nprint(min_sad)", "import numpy as np\nimport statistics\n\nn = int(input())\na = list(map(int, input().split()))\na = np.array(a, dtype = int)\n\none = np.ones(n, dtype = int)\nstairs = np.add.accumulate((one))\na = a - stairs\nb = int(statistics.median(a))\n\n\ndef pos(b):\n    return sum(abs(a - b))\n\nprint(pos(b))", "N = int(input())\nA = list(map(int,input().split()))\nA = [A[i]-(i+1) for i in range(N)]\nA = sorted(A)\nA.insert(0,0)\nif N%2==1:\n    b = A[(N+1)//2]\n    ans = 0\n    for i in range(1,N+1):\n        ans += abs(A[i]-b)\nelse:\n    b1 = A[N//2]\n    b2 = A[N//2+1]\n    bmax = max(b1,b2)\n    bmin = min(b1,b2)\n    if (bmax-bmin)%2==0:\n        b = (bmax+bmin)//2\n        ans = 0\n        for i in range(1,N+1):\n            ans += abs(A[i]-b)\n    else:\n        b1 = (bmax+bmin)//2\n        a1 = 0\n        for i in range(1,N+1):\n            a1 += abs(A[i]-b1)\n        b2 = (bmax+bmin)//2+1\n        a2 = 0\n        for i in range(1,N+1):\n            a2 += abs(A[i]-b2)\n        ans = min(a1,a2)\nprint(ans)", "N = int(input())\n*A, = list(map(int, input().split()))\nl = [(j-i) for i, j in enumerate(A, start=1)]\nl.sort()\n\nb = l[N//2]\nans = sum(abs(i-b) for i in l)\nprint(ans)\n", "N = int(input())\nA = list(map(int, (input().split())))\nsuma = 0\nsumabs = 0\nfor i in range(N):\n    A[i] -= i+1\n    suma += A[i]\nA.sort()\nb = (A[N//2] + A[(N-1)//2])//2\nans = 0\nfor i in range(N):\n    ans += abs(A[i]-b)\nprint(ans)", "N = int(input())\nA = list(map(int,input().split()))\na = []\nfor i in range(N):\n  a.append(A[i]-(i+1))\na.sort()\nave = a[N//2-1]\ncnt1 = 0\ncnt2 = 0\nfor i in range(N):\n  cnt1 += abs(a[i]-ave)\nfor i in range(N):\n  cnt2 += abs(a[i]-a[N//2])\nprint((min(cnt1,cnt2)))\n", "n = int(input())\na = list(map(int, input().split()))\na = [a[i]-i for i in range(n)]\n\nimport numpy as np\na = np.array(a)\nx = np.median(a)\nr = 0\nfor i in range(n):\n    r += abs(a[i]-x)\nprint(int(r))", "from numpy import median\nn=int(input())\nalist=list(map(int,input().split()))\n\nfor i in range(n):\n    alist[i]-=i+1\n\nmed=int(median(alist))\nans=0\nfor a in alist:\n    ans+=abs(a-med)\nprint(ans)\n\n\n"]
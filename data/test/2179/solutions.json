["import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    # a = MI(n,m)\n    arr = LIST(m,n)\n    for i in range(n):\n        v = VI()\n        for j in range(m):\n            arr[j][i] = v[j]\n    # for i,l in enumerate(a):\n    #     for j,x in enumerate(l):\n    #         arr[j][i] = x\n    return arr\n\n\n\n\ndef run2(n,m,u,v,w,x):\n    # correct, but time limit exceeded.\n    g = ELIST(n+1) # list of vertices; Adjacency list\n    for i in range(m):\n        g[u[i]].append((v[i],w[i],i+1))\n        g[v[i]].append((u[i],w[i],i+1))\n    # index priority queue with deque and priorities\n    pq = []\n    marked = [False] * (n+1)\n    pq.append((0,0,x,0))\n    sg = []\n    wmax = -w[-1] # to fix the issue that start doesn't have edge weight\n    while len(pq)!=0:\n        wi,lw,i,ei = heapq.heappop(pq)\n        if not marked[i]:\n            marked[i] = True\n            sg.append(ei)\n            wmax += w[ei-1]\n            #print(i,wi,ei, wmax)\n            for j,wj,ej in g[i]:\n                if not marked[j]:\n                    heapq.heappush(pq, (wi+wj,wj,j,ej))\n    sg = sg[1:]\n    print(wmax)\n    for i in sg:\n        print(i,end=\" \")\n    print()\ndef main2(info=0):\n    n,m = VI()\n    u,v,w = MIT(m,3)\n    x = I()\n    run(n,m,u,v,w,x)\n\n\ndef run(n,m,g,x):\n    pq = [(0,0,x,0)]\n    marked = [False] * (n+1)\n    sg = []\n    wtot = 0\n    while len(pq)!=0:\n        wi,lw,i,ei = heapq.heappop(pq)\n        if not marked[i]:\n            marked[i] = True\n            sg.append(str(ei))\n            wtot += lw\n            for j,wj,ej in g[i]:\n                if not marked[j]:\n                    heapq.heappush(pq, (wi+wj,wj,j,ej))\n    print(wtot)\n    print(\" \".join(sg[1:]))\ndef main(info=0):\n    n,m = VI()\n    g = ELIST(n+1)\n    for i in range(m):\n        u,v,w = VI()\n        g[u].append((v,w,i+1))\n        g[v].append((u,w,i+1))\n    x = I()\n    run(n,m,g,x)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n", "from collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\n\n\ndef main():\n    n,m = map(int,input().split())\n    adj = [[] for i in range(n+1)]\n\n    for i in range(m):\n        a,b,c = map(int,input().split())\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n    v = int(input())\n\n    visited, ans, tw = [0]*(n+1), [], 0\n    Q = [(0,0,v,0)]\n\n    while Q:\n        w,lew,u,ei = heappop(Q)\n        if visited[u]: continue\n        visited[u] = 1\n        ans.append(str(ei+1))\n        tw += lew\n        for to,we,eii in adj[u]:\n            if not visited[to]:\n                heappush(Q,(we+w,we,to,eii))\n\n    print(tw)\n    print(\" \".join(ans[1:]))\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappop, heappush\nn,m = map(int,input().split())\nadj = [[] for i in range(n+1)]\n\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    adj[a].append((b, c, i))\n    adj[b].append((a, c, i))\nv = int(input())\n\nvisited, ans, tw = [0]*(n+1), [], 0\nQ = [(0,0,v,0)]\n\nwhile Q:\n    w,lew,u,ei = heappop(Q)\n    if visited[u]: continue\n    visited[u] = 1\n    ans.append(str(ei+1))\n    tw += lew\n    for to,we,eii in adj[u]:\n        if not visited[to]:\n            heappush(Q,(we+w,we,to,eii))\n\nprint(tw)\nprint(\" \".join(ans[1:]))", "from collections import defaultdict,deque,Counter,OrderedDict\nfrom heapq import heappop,heappush\nimport bisect,sys,threading\n\ndef main():\n    n, m = map(int, input().split())\n    adj = [[] for i in range(n + 1)]\n\n    for i in range(m):\n        a, b, c = map(int, input().split())\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n    v = int(input())\n\n    visited, ans, tw = [0] * (n + 1), [], 0\n    Q = [(0, 0, v, 0)]\n\n    while Q:\n        w, lew, u, ei = heappop(Q)\n        if visited[u]: continue\n        visited[u] = 1\n        ans.append(str(ei + 1))\n        tw += lew\n        for to, we, eii in adj[u]:\n            if not visited[to]:\n                heappush(Q, (we + w, we, to, eii))\n\n    print(tw)\n    print(\" \".join(ans[1:]))\n\ndef __starting_point():\n    sys.setrecursionlimit(200000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "from collections import defaultdict, deque, Counter, OrderedDict\nimport bisect, sys, threading\nfrom heapq import *\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    adj = [[] for i in range(n + 1)]\n\n    for i in range(m):\n        a, b, c = list(map(int, input().split()))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n    v = int(input())\n\n    visited, ans, tw = [0] * (n + 1), [], 0\n    Q = [(0, 0, v, 0)]\n\n    while Q:\n        w, lew, u, ei = heappop(Q)\n        if visited[u]: continue\n        visited[u] = 1\n        ans.append(str(ei + 1))\n        tw += lew\n        for to, we, eii in adj[u]:\n            if not visited[to]:\n                heappush(Q, (we + w, we, to, eii))\n\n    print(tw)\n    print(\" \".join(ans[1:]))\n\n\ndef __starting_point():\n    \"\"\"sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\"\"\"\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq\nn,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))\n\n\n\n\n", "import heapq, sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\ned = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(m)]\nsrc = int(input())\n\ng = [[] for _ in range(n + 1)]\nfor i, (u, v, w) in enumerate(ed):\n    g[u].append((i, v, w))\n    g[v].append((i, u, w))\n\npq = [(0, 0, src)]\ndist = [(10 ** 15, 0)] * (n + 1)\nup = [0] * (n + 1)\nwhile pq:\n    d, e, u = heapq.heappop(pq)\n    if (d, e) > dist[u]:\n        continue\n    for i, v, w in g[u]:\n        if (d + w, w) < dist[v]:\n            dist[v] = d + w, w\n            up[v] = i\n            heapq.heappush(pq, (d + w, w, v))\n\nt = [up[u] for u in range(1, n + 1) if u != src]\nprint(sum(ed[e][2] for e in t))\nprint(*t)\n", "import heapq\n\nn, m = list(map(int, input().split()))\ned = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(m)]\nsrc = int(input())\n\ng = [[] for _ in range(n + 1)]\nfor i, (u, v, w) in enumerate(ed):\n    g[u].append((i, v, w))\n    g[v].append((i, u, w))\n\npq = [(0, 0, src)]\ndist = [(10 ** 15, 0)] * (n + 1)\nup = [0] * (n + 1)\nwhile pq:\n    d, e, u = heapq.heappop(pq)\n    if (d, e) > dist[u]:\n        continue\n    for i, v, w in g[u]:\n        if (d + w, w) < dist[v]:\n            dist[v] = d + w, w\n            up[v] = i\n            heapq.heappush(pq, (d + w, w, v))\n\nt = [up[u] for u in range(1, n + 1) if u != src]\nprint(sum(ed[e][2] for e in t))\nprint(*t)\n", "import heapq\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n + 1)]\nfor i in range(1, m + 1):\n    u, v, w = list(map(int, input().split()))\n    g[u].append((i, v, w))\n    g[v].append((i, u, w))\nsrc = int(input())\n\npq = [(0, 0, src, -1)]\nmk = [0] * (n + 1)\nt = []\ns = 0\nwhile pq:\n    d, w, u, e = heapq.heappop(pq)\n    if mk[u]:\n        continue\n    mk[u] = 1\n    s += w\n    t.append(e)\n    for e, v, w in g[u]:\n        if not mk[v]:\n            heapq.heappush(pq, (d + w, w, v, e))\n\nprint(s)\nprint(*t[1:])\n", "import heapq\nfrom sys import stdin\nfrom math import inf\ninput = stdin.readline\ndef put():\n    return list(map(int, input().split()))\n\ndef dijkstra(u):\n    q = [(0,0,u-1,0)]\n    vis= [False]*n\n    ans = 0\n    res = []\n    while q:\n        _,k,i,f = heapq.heappop(q)\n        if vis[i]:\n            continue\n        vis[i]=True\n        ans+=k\n        res.append(f)\n        for w,j,f in graph[i]:\n            if not vis[j]:\n                #print(_+w, w, j, f)\n                heapq.heappush(q, (_+w, w, j, f))\n    \n    print(ans)\n    res = res[1:]\n    print(*res)\n\n\n\n\nn,m = put()\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    x,y,z = put()\n    x,y = x-1, y-1\n    graph[x].append((z,y,_+1))\n    graph[y].append((z,x,_+1))\nd = int(input())\ndijkstra(d)\n\n", "from sys import stdin\nfrom heapq import heappop, heappush\n\nn,m = [int(x) for x in stdin.readline().split()]\n\ngraph = [{} for x in range(n+1)]\n\nfor e in range(m):\n  u,v,w = [int(x) for x in stdin.readline().split()]\n  graph[u][v] = (w,e)\n  graph[v][u] = (w,e)\n\nu = int(stdin.readline())\n\nvisited = set()\ndist = [(float('inf'),0) for x in range(n+1)]\npathTo = [0 for x in range(n+1)]\ndist[u] = (0,0)\nq = []\nheappush(q,(0,u))\n\nwhile q:\n  d,v = heappop(q)\n  if not v in visited:\n    visited.add(v)\n    for e in graph[v]:\n      if (d+graph[v][e][0],graph[v][e][0]) < dist[e]:\n        dist[e] = (d+graph[v][e][0],graph[v][e][0])\n        pathTo[e] = graph[v][e][1]\n        heappush(q, (d+graph[v][e][0],e))\n\ntotal = 0\n\nfor x in dist[1:]:\n  total += x[1]\n\nprint(total)\nfor x in range(1,n+1):\n  if x != u:\n    print(pathTo[x]+1, end=' ')\n"]
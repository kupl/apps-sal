["from collections import Counter\n\nclass Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, K, L = map(int, input().split())\n\nuf = Unionfind(N)\nuf1 = Unionfind(N)\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    uf.union(p-1, q-1)\n    \nfor _ in range(L):\n    r, s = map(int, input().split())\n    uf1.union(r-1, s-1)\n    \npairs = [(uf.find(i), uf1.find(i)) for i in range(N)]\n#print(pairs)\n    \nc = Counter(pairs)\n#print(c)\nans = [c[pairs[i]] for i in range(N)]\n\nprint(*ans)", "N, K, L = map(int, input().split())\n\ndef fp(x, parentList): #findParent\n    if parentList[x] == x:\n        return x\n    else:\n        parentList[x] = fp(parentList[x], parentList)\n        return parentList[x]\n\n#\u5404\u30ce\u30fc\u30c9\u306eparent\u3092\u30ea\u30b9\u30c8\u3067\u8868\u73fe(\u9023\u7d50\u524d\u306f\u81ea\u8eab\u304cparent)\nroad = [i for i in range(N)]\nrail = [i for i in range(N)]\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    par_p, par_q = fp(p-1, road), fp(q-1, road) #p, q\u306eparent \n    #\u9023\u7d50\u3059\u308b\u969b\u3001\u82e5\u3044\u756a\u53f7\u3092parent\u3068\u3059\u308b\n    if par_p < par_q:\n        road[par_q] = par_p\n    else:\n        road[par_p] = par_q\n\n#rail\u306b\u3064\u3044\u3066\u3082\u540c\u69d8\nfor _ in range(L):\n    s, t = map(int, input().split())\n    par_s, par_t = fp(s-1, rail), fp(t-1, rail)\n    if par_s < par_t:\n        rail[par_t] = par_s\n    else:\n        rail[par_s] = par_t\n\n#\u9023\u7d50\u6210\u5206\u306e\u8981\u7d20\u3092\u30ab\u30a6\u30f3\u30c8\ncnt = {}\nfor i in range(N):\n    key = (fp(i,road),fp(i,rail))\n    if key in cnt:\n        cnt[key] += 1\n    else:\n        cnt[key] = 1\n#\u51fa\u529b\nfor i in range(N):\n    key = (fp(i,road),fp(i,rail))\n    ans = cnt[key]\n    print(ans, end=\" \")\n", "from collections import Counter\nn,k,l=map(int,input().split())\ncity1=[i for i in range(n)]\ncity2=[i for i in range(n)]\ndef root(c,x):\n  if x==c[x]:\n    return x\n  else:\n    c[x]=root(c,c[x])\n    return c[x]\ndef union(c,x,y):\n  rx=root(c,x)\n  ry=root(c,y)\n  if rx>ry:\n    c[rx]=ry\n  else:\n    c[ry]=rx\nfor i in range(k):\n  a,b=map(int,input().split())\n  union(city1,a-1,b-1)\nfor i in range(l):\n  a,b=map(int,input().split())\n  union(city2,a-1,b-1)\nr=[]\nfor i in range(n):\n  r.append((root(city1,i),root(city2,i)))\nc=Counter(r)\nfor i in range(n):\n  ans=c[r[i]]\n  if i==n-1:\n    print(ans)\n  else:\n    print(ans,end=' ')", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*n \n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)      \n        if x==y:\n            return        \n        if self.par[x] > self.par[y]:\n            x, y = y, x       \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\nN, K, L = map(int, input().split())\nUni_1 = UnionFind(N)\nUni_2 = UnionFind(N)\nD = {}\nfor _ in range(K):\n  p,q = map(int, input().split())\n  Uni_1.union(p-1, q-1)\nfor _ in range(L):\n  p,q = map(int, input().split())\n  Uni_2.union(p-1, q-1)\nfor i in range(N):\n  k = (Uni_1.find(i), Uni_2.find(i))\n  if k in D.keys():\n    D[k] += 1\n  else:\n    D[k] = 1\nfor i in range(N):\n  print(D[(Uni_1.find(i), Uni_2.find(i))], end=\" \")", "from collections import Counter\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\ndef main():\n    n, k, l = list(map(int, input().split()))\n    a = UnionFind(n)\n    b = UnionFind(n)\n    for _ in range(k):\n        p, q = list(map(int, input().split()))\n        a.union(p-1, q-1)\n    for _ in range(l):\n        r, s = list(map(int, input().split()))\n        b.union(r-1, s-1)\n    d = Counter((a._root(i), b._root(i)) for i in range(n))\n    print((*(d[(a._root(i), b._root(i))] for i in range(n))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\nclass UnionFind():\n  def __init__(self,n):\n    self.parents=[-1]*n\n  \n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    \n    self.parents[x]=self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    \n    if x==y:\n      return\n    \n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    \n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n    \nN,K,L=map(int,input().split())\nuf_road=UnionFind(N+1)\nuf_train=UnionFind(N+1)\n\nfor _ in range(K):\n  p,q=map(int,input().split())\n  uf_road.union(p,q)\n\nfor _ in range(L):\n  s,t=map(int,input().split())\n  uf_train.union(s,t)\n  \nunion_sets=[(uf_road.find(i),uf_train.find(i)) for i in range(1,N+1)]\ncounts=Counter(union_sets)\nans=[counts[union_set] for union_set in union_sets]\n\nprint(' '.join(str(a) for a in ans))", "import sys\nreadline = sys.stdin.readline\nfrom collections import Counter\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    N, K, L = map(int, readline().rstrip().split())\n    uf_road = UnionFind(N)\n    uf_train = UnionFind(N)\n    \n    for _ in range(K):\n        p, q = map(int, readline().rstrip().split())\n        uf_road.union(p-1, q-1)\n    \n    for _ in range(L):\n        r, s = map(int, readline().rstrip().split())\n        uf_train.union(r-1, s-1)\n    \n    pairs = []\n    for i in range(N):\n        pairs.append((uf_road.find(i), uf_train.find(i)))\n    \n    cnt = Counter(pairs)\n    res = [cnt[pair] for pair in pairs]\n    print(*res)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\n\nclass UnionFind:\n    #n\u500b\u306e\u8981\u7d20\u3092\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n    \n    #\u6728\u306e\u6839\u3092\u6c42\u3081\u308b\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    \n    #x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    #x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n\nN, K, L = map(int, input().split())\nroads = [list(map(int, input().split())) for i in range(K)]\ntrains = [list(map(int, input().split())) for i in range(L)]\n\nuf_road = UnionFind(N)\nuf_train = UnionFind(N)\n\nfor road in roads:\n    x, y = road\n    uf_road.unite(x-1, y-1)\n\nfor train in trains:\n    x, y = train\n    uf_train.unite(x-1, y-1)\n\npairs = []\nfor i in range(N):\n    pairs.append((uf_road.find(i), uf_train.find(i)))\n\ncnt = Counter(pairs)\n\nans = [cnt[pair] for pair in pairs]\nprint(*ans)", "# \u53c2\u8003URL https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    # parents\n    # \u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    # \u8981\u7d20\u304c\u6839\uff08\u30eb\u30fc\u30c8\uff09\u306e\u5834\u5408\u306f-(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\u3092\u683c\u7d0d\u3059\u308b\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    # find(x)\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # union(x, y)\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\nimport sys\ndef input():\n    return sys.stdin.readline().strip()\n\nn, k, l = map(int, input().split())\n\nroad = UnionFind(n)\nrail = UnionFind(n)\nfor _ in range(k):\n    p, q = map(int, input().split())\n    road.union(p-1, q-1)\nfor _ in range(l):\n    r, s = map(int, input().split())\n    rail.union(r-1, s-1)\n\ndic = {}\nl = []\nfor i in range(n):\n    tup = (road.find(i), rail.find(i))\n    l.append(tup)\n    if tup in dic:\n        dic[tup] += 1\n    else:\n        dic[tup] = 1\n\nans = []\nfor i in l:\n    ans.append(dic[i])\n\nprint(' '.join(map(str, ans)))", "def main():  \n  #Union Find\n\n  #x\u306e\u6839\u3092\u6c42\u3081\u308b\n  def find(x):\n      if par[x] < 0:\n          return x\n      else:\n          par[x] = find(par[x])\n          return par[x]\n  #x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\n  def unite(x,y):\n      x = find(x)\n      y = find(y)\n\n      if x == y:\n          return False\n      else:\n          #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n          if par[x] > par[y]:\n              x,y = y,x\n          par[x] += par[y]\n          par[y] = x\n          return True\n\n  def find2(x):\n    if pa[x] < 0:\n        return x\n    else:\n        pa[x] = find2(pa[x])\n        return pa[x]\n\n  import sys\n  input = sys.stdin.readline\n\n  n,k,l = [int(i) for i in input().split()]\n  par = [-1]*n\n  pa = [-1]*n\n  ans = [0]*n\n\n  for i in range(k):\n    p,q = [int(i) for i in input().split()]\n    unite(p-1,q-1)\n\n  def unite2(x,y):\n      x = find2(x)\n      y = find2(y)\n      if x == y:\n          return False\n      else:\n          if pa[x] > pa[y]:\n              x,y = y,x\n          pa[x] += pa[y]\n          pa[y] = x\n          return True\n\n  for i in range(l):\n    r,s = [int(i) for i in input().split()]\n    unite2(r-1,s-1)\n\n  dic = {}\n  chk = []\n  for i in range(n):\n      p1 = find(i)\n      p2 = find2(i)\n      chk.append((p1,p2))\n      if (p1,p2) in dic:\n          dic[(p1,p2)] += 1\n      else: \n          dic[(p1,p2)] = 1\n  print((' '.join([str(dic[chk[i]]) for i in range(n)])))\n  \ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,K,L=list(map(int,input().split()))\npq=[list(map(int,input().split())) for i in range(K)]\nrs=[list(map(int,input().split())) for i in range(L)]\n\nuf_road = UnionFind(N)\nuf_train = UnionFind(N)\n\nfor i in range(K):\n    uf_road.union(pq[i][0]-1,pq[i][1]-1)\nfor i in range(L):\n    uf_train.union(rs[i][0]-1,rs[i][1]-1)\n\n# \u5404\u90fd\u5e02\u306b\u9023\u7d50\u3057\u3066\u3044\u308broad\u3068train\u306e\u7a4d\u96c6\u5408\u306e\u63a2\u7d22\u306fTLE\n# ans = []\n# for i in range(N):\n#   ans.append(len(set(uf_road.members(i)) & set(uf_train.members(i))))\n# print(*ans)\n\n# road,train\u306e\u6839\u306e\u30da\u30a2\u3067\u540c\u3058\u30da\u30a2\u3092\u6301\u3064\u90fd\u5e02\u306f\u9023\u7d50\u3057\u3066\u3044\u308b\nfrom collections import Counter\npair = [(uf_road.find(i), uf_train.find(i)) for i in range(N)]\nans = Counter(pair)\nprint(*[ans[i] for i in pair])", "from collections import defaultdict\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1] * n\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    n, k, l = map(int, input().split())\n    \n    road = UnionFind(n)\n    train = UnionFind(n)\n    \n    for _ in range(k):\n        p, q = map(int, input().split())\n        road.unite(p-1, q-1)\n    \n    for _ in range(l):\n        r, s = map(int, input().split())\n        train.unite(r-1, s-1)\n        \n    d = defaultdict(int)\n    for i in range(n):\n        d[(road.find(i), train.find(i))] += 1\n    \n    ans = []\n    for i in range(n):\n        ans.append(d[(road.find(i), train.find(i))])\n    \n    print(*ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nclass UnionFind:\n    def __init__(self, n):\n        self.state = [-1] * n\n        #self.size_table = [1<<i for i in range(n)]\n        # cnt\u306f\u30b0\u30eb\u30fc\u30d7\u6570\n        # self.cnt = n\n\n    def root(self, u):\n        v = self.state[u]\n        if v < 0: return u\n        self.state[u] = res = self.root(v)\n        return res\n\n    def merge(self, u, v):\n        ru = self.root(u)\n        rv = self.root(v)\n        if ru == rv: return\n        du = self.state[ru]\n        dv = self.state[rv]\n        if du > dv: ru, rv = rv, ru\n        if du == dv: self.state[ru] -= 1\n        self.state[rv] = ru\n        # self.cnt -= 1\n        #self.size_table[ru] |= self.size_table[rv]\n        #self.size_table[rv]=0\n        return\n\ndef main():\n    n,k,l=MI()\n    road=UnionFind(n)\n    train=UnionFind(n)\n    for _ in range(k):\n        u,v=MI1()\n        road.merge(u,v)\n    for _ in range(l):\n        u,v=MI1()\n        train.merge(u,v)\n    cnt=defaultdict(int)\n    for u in range(n):\n        cnt[road.root(u),train.root(u)]+=1\n    ans=[cnt[road.root(u),train.root(u)] for u in range(n)]\n    print(*ans)\n\nmain()\n", "N, M, L = [int(s) for s in input().split()]\nparent_road = list(range(N))\nparent_train = list(range(N))\nrank_road = [0] * N\nrank_train = [0] * N\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * N\n\n    def find(self, x):\n        if x == self.parent[x]:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n\nedge_road = [[int(s) - 1 for s in input().split()] for _ in range(M)]\nedge_train = [[int(s) - 1 for s in input().split()] for _ in range(L)]\n\ngroup_road = UnionFind(N)\ngroup_train = UnionFind(N)\n\nfor x, y in edge_road:\n    group_road.union(x, y)\n\nfor x, y in edge_train:\n    group_train.union(x, y)\n\ngroup_count = {}\ngroup_list = []\nfor i in range(N):\n    gr = group_road.find(i)\n    gt = group_train.find(i)\n    group_list.append((gr, gt))\n    if (gr, gt) in list(group_count.keys()):\n        group_count[(gr, gt)] += 1\n    else:\n        group_count[(gr, gt)] = 1\n\nprint((' '.join([str(group_count[g]) for g in group_list])))\n\n", "# solution\nimport io\nimport math\nimport string\n\ndef col(n, m):\n    X = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        X[a-1].append(b-1)\n        X[b-1].append(a-1)\n    C = [-1] * n\n    c = 0\n    for i in range(N):\n        if C[i] >= 0: continue\n        Q = [i]\n        C[i] = c\n        while Q:\n            x = Q.pop()\n            for y in X[x]:\n                if C[y] == -1:\n                    C[y] = C[x]\n                    Q.append(y)\n        c += 1\n    return C\n\nN, K, L = map(int, input().split())\nA = col(N, K)\nB = col(N, L)\nD = {}\nfor a, b in zip(A, B):\n    t = (a<<18) + b\n    if t in D: D[t] += 1\n    else: D[t] = 1\n\nprint(*[D[(a<<18)+b] for a, b in zip(A, B)])", "from collections import Counter\n\n\nclass UnionFind:\n    def __init__(self, node):\n        self.parent = [-1 for _ in range(node)]\n        self.node = node\n\n    def find(self, target):\n        if self.parent[target] < 0:\n            return target\n        else:\n            self.parent[target] = self.find(self.parent[target])\n            return self.parent[target]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.parent[root_x] > self.parent[root_y]:\n            root_x, root_y = root_y, root_x\n        self.parent[root_x] += self.parent[root_y]\n        self.parent[root_y] = root_x\n\n    def get_size(self, x):\n        return -self.parent[self.find(x)]\n\n    def members(self, x, is_set=False):\n        root = self.find(x)\n        res = [i for i in range(self.node) if self.find(i) == root]\n        if is_set:\n            return set(res)\n        return res\n\n    def all_root(self):\n        return [idx for idx, val in enumerate(self.parent) if val < 0]\n\n\ndef main():\n    cities, roads, railroads = list(map(int, input().split()))\n    uf_road = UnionFind(cities)\n    uf_train = UnionFind(cities)\n    for _ in range(roads):\n        p, q = [int(x) - 1 for x in input().split()]\n        uf_road.union(p, q)\n    for _ in range(railroads):\n        r, s = [int(x) - 1 for x in input().split()]\n        uf_train.union(r, s)\n    each_pair = []\n    for i in range(cities):\n        each_pair.append(tuple([uf_road.find(i), uf_train.find(i)]))\n    pair_count = dict(Counter(each_pair))\n    answer = [pair_count[each_pair[i]] for i in range(cities)]\n    print((\" \".join(map(str, answer))))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import numpy as np\nfrom collections import Counter\nfrom scipy.sparse.csgraph import connected_components\nfrom scipy.sparse import csr_matrix\n\nint1 = lambda x: int(x) - 1\nN, K, L = map(int, input().split())\nroads = np.array([tuple(map(int1, input().split())) for _ in range(K)]).T\nrailways = np.array([tuple(map(int1, input().split())) for _ in range(L)]).T\n\n\ndef connected(G, M):\n    matr = csr_matrix((np.ones(M, dtype=int), G), shape=(N, N))\n    _, labels = connected_components(matr)\n    return labels\n\n\nroads_connection = connected(roads, K).tolist()\nrailways_connection = connected(railways, L).tolist()\n\nct = Counter((roads_connection[i], railways_connection[i]) for i in range(N))\nans = [ct[(roads_connection[i], railways_connection[i])] for i in range(N)]\nprint(*ans)", "from collections import Counter\nn, k, l = map(int, input().split())\ndef find(x, par):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x], par)\n        return par[x]\ndef unite(x, y, par):\n    p = find(x, par)\n    q = find(y, par)\n    if p == q:\n        return None\n    if p > q:\n        p, q = q, p\n    par[p] += par[q]\n    par[q] = p\ndef same(x, y):\n    return find(x) == find(y)\ndef size(x):\n    return -par[find(x)]\nroad_par = [-1 for i in range(n + 1)]\ntrain_par = [-1 for i in range(n + 1)]\nfor i in range(k):\n    p, q = map(int, input().split())\n    unite(p, q, road_par)\nfor i in range(l):\n    r, s = map(int, input().split())\n    unite(r, s, train_par)\nans = []\nfor i in range(n):\n    ans.append((find(i + 1, road_par), find(i + 1, train_par)))\nc = Counter(ans)\nfor i in ans:\n    print(c[i], end=\" \")", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nimport copy\n\nn, k, l = list(map(int, input().split()))\n\nroad = [[] for i in range(n+1)]\nrail = [[] for i in range(n+1)]\n\nfor i in range(k):\n    p, q = list(map(int, input().split()))\n    road[p].append(q)\n    road[q].append(p)\n\nfor i in range(l):\n    r, s = list(map(int, input().split()))\n    rail[r].append(s)\n    rail[s].append(r)\n\nseen = [0 for i in range(n+1)]\n\ndef dfs_stack(u, al, al_c, d):\n    stack = deque([u])\n    seen[u] = 1\n\n    while len(stack) > 0:\n        v = stack.pop()\n        ###\n        al_c[v] = d\n        ###\n\n        for w in al[v]:\n            if seen[w] == 0:\n                stack.append(w)\n                seen[w] = 1\n\n        if stack == []: break\n\n\nroad_c = [-1 for i in range(n+1)]\nrail_c = [-1 for i in range(n+1)]\n\nd = 0\nfor i in range(1,n+1):\n    if seen[i] == 0:\n        dfs_stack(i, road, road_c, d)\n        d += 1\n\nseen = [0 for i in range(n+1)]\n\nd = 0\nfor i in range(1,n+1):\n    if seen[i] == 0:\n        dfs_stack(i, rail, rail_c, d)\n        d += 1\n\ndict = {}\n\nfor i in range(1, n+1):\n    if (road_c[i], rail_c[i]) not in dict:\n        dict[(road_c[i], rail_c[i])] = [i]\n    else:\n        dict[(road_c[i], rail_c[i])].append(i)\n\nans = [0 for i in range(n+1)]\n\nfor dd in list(dict.items()):\n    for j in dd[1]:\n        ans[j] = str(len(dd[1]))\n\nprint((' '.join(ans[1:])))\n", "#UNIONFIND\nclass UnionFind:\n    def __init__(self, n):\n        # \u8ca0  : \u6839\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u7d76\u5bfe\u5024\u306f\u30e9\u30f3\u30af\u3092\u793a\u3059\n        # \u975e\u8ca0: \u6839\u3067\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\u5024\u306f\u89aa\u3092\u793a\u3059\n        self.table = [-1] * n\n \n    def _root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            # \u7d4c\u8def\u306e\u5727\u7e2e\n            self.table[x] = self._root(self.table[x])\n            return self.table[x]\n \n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n \n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        # \u30e9\u30f3\u30af\u306e\u53d6\u5f97\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n \n \ndef __starting_point():\n    n,k,l=map(int,input().split())\n    pq=UnionFind(n+1)\n    rs=UnionFind(n+1)\n    for i in range(k):\n        p,q=map(int,input().split())\n        pq.union(p,q)\n    for i in range(l):\n        r,s=map(int,input().split())\n        rs.union(r,s)\n    sameroot=[]\n    for i in range(1,n+1):\n        sameroot.append([pq._root(i),rs._root(i),i])\n    sameroot.sort()\n    sameroot.append([0,0,n+1])\n    cnt=[0]*(n+1)\n    bx,by=0,0\n    samelist=[]\n    for x,y,i in sameroot:\n        if bx==x and by==y:\n            samelist.append(i)\n        else:\n            k=len(samelist)\n            if k>0:\n                for j in samelist:\n                    cnt[j]=k\n            samelist=[i]\n            bx,by=x,y\n    print(' '.join(map(str,cnt[1:])))\n__starting_point()", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\n\nclass UnionFind:\n\n    def __init__(self, n: int):\n        self._n = n\n        self._parents = [i for i in range(n)]\n        self._size = [1 for _ in range(n)]\n\n    def unite(self, x: int, y: int) -> None:\n        px = self.find(x)\n        py = self.find(y)\n\n        # \u4e00\u81f4\u3057\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u30ea\u30f3\u30af\u3092\u3064\u3051\u308b\n        if px != py:\n            self._link(px, py)\n\n    def _link(self, x: int, y: int):\n        if self._size[x] < self._size[y]:\n            self._parents[x] = y\n            self._size[y] += self._size[x]\n        else:\n            self._parents[y] = x\n            self._size[x] += self._size[y]\n\n    def same(self, x: int, y: int) -> bool:\n        px = self.find(x)\n        py = self.find(y)\n        return px == py\n\n    def find(self, x: int) -> int:\n        if self._parents[x] == x:\n            return x\n\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x: int):\n        return self._size[self.find(self._parents[x])]\n\nN, K, L = map(int, input().split())\n\nroad = UnionFind(N + 1)\nrail = UnionFind(N + 1)\nshare = UnionFind(N + 1)\n\nroads = [list(map(int, input().split())) for _ in range(K)]\nrails = [list(map(int, input().split())) for _ in range(L)]\n\nfor i in range(K):\n    p, q = roads[i]\n    road.unite(p, q)\n\nfor i in range(L):\n    r, s = rails[i]\n    rail.unite(r, s)\n\nm = {}\n\nfor i in range(1, N + 1):\n    cnt = m.get((road.find(i), rail.find(i)), 0)\n    m[(road.find(i), rail.find(i))] = cnt + 1\n\nans = [0] * N\nfor i in range(N):\n    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]\n\nprint(*ans)", "import collections\nclass UnionFind:\n    def __init__(self,n):\n        super().__init__()\n        self.par = [-1]*n\n        self.rank = [0]*n\n        self.tsize = [1]*n\n\n    \n    def root(self,x):\n        if self.par[x] == -1:\n            return x \n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x_r = self.root(x)\n        y_r = self.root(y)\n        \n        if self.rank[x_r]>self.rank[y_r]:\n            self.par[y_r] = x_r\n\n        elif self.rank[x_r]<self.rank[y_r]:\n            self.par[x_r] = y_r\n\n        elif x_r != y_r:\n            self.par[y_r] = x_r\n            self.rank[x_r] += 1\n\n        if x_r != y_r:\n            size = self.tsize[x_r]+self.tsize[y_r]\n            self.tsize[x_r] = size\n            self.tsize[y_r] = size\n\n    def isSame(self,x,y):\n        return self.root(x) == self.root(y)\n\n    def size(self,x):\n        return self.tsize[self.root(x)]\n\ndef main():\n    n,k,l = tuple([int(t)for t in input().split()])\n\n    uf_k = UnionFind(n)\n    uf_l = UnionFind(n)\n\n\n    pq = [[int(t)-1 for t in input().split()]for _ in [0]*k]\n    for p,q in pq:\n        uf_k.unite(p,q)\n\n    rs = [[int(t)-1 for t in input().split()]for _ in [0]*l]\n    for r,s in rs:\n        uf_l.unite(r,s)\n\n    pair = []\n    for i in range(n):\n        pair.append((uf_k.root(i),uf_l.root(i)))\n    counter = collections.Counter(pair)\n    \n    ans = []\n    for a in pair:\n        ans.append(counter[a])\n    print(*ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "from collections import *\nN, K, L = list(map(int,input().split()))\n\ndef f(m):\n    *a, = list(range(N))\n    def g(i):\n        if a[i] == i:\n            return i\n        a[i] = g(a[i])\n        return a[i]\n    for _ in range(m):\n        p, q = list(map(int,input().split()))\n        a[g(q-1)] = g(p-1)\n    return g\n\nx, y = f(K), f(L)\nc = Counter((x(i),y(i)) for i in range(N))\nprint((*((c[x(i),y(i)]) for i in range(N))))\n", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    def get_size(self, x):\n        x = self.find(x)\n        return self.size[x]\nimport collections\nN,K,L=map(int,input().split())\nuf1=UnionFind(N)\nfor i in range(K):\n  p,q=map(int,input().split())\n  uf1.union(p-1,q-1)\nuf2=UnionFind(N)\nfor j in range(L):\n  r,s=map(int,input().split())\n  uf2.union(r-1,s-1)\nlist=[]\nfor i in range(N):\n  list.append((uf1.find(i),uf2.find(i)))\ncount=collections.Counter(list)\nfor i in range(N):\n  ans=count[list[i]]\n  if i==N-1:\n    print(ans)\n  else:\n    print(ans,end=' ')", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nclass UnionFind:\n    def __init__(self, n_nodes):\n        self.n_nodes = n_nodes\n        self.parents = [-1] * n_nodes\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n\n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_parent_list(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def get_members(self, x):\n        parent = self.find(x)\n        return [i for i in range(self.n_nodes) if self.find(i) == parent]\n\n    def get_members_dict(self):\n        return {par: self.get_members(par) for par in self.get_parent_list()}\n\n\ndef main():\n    N, K, L = map(int, input().split())\n    tree_road = UnionFind(N)\n    tree_subway = UnionFind(N)\n\n    for _ in range(K):\n        p, q = map(int, input().split())\n        p -= 1\n        q -= 1\n        tree_road.unite(p, q)\n\n    for _ in range(L):\n        r, s = map(int, input().split())\n        r -= 1\n        s -= 1\n        tree_subway.unite(r, s)\n\n    d = {}\n    for i in range(N):\n        p1 = tree_road.find(i)\n        p2 = tree_subway.find(i)\n        if (p1, p2) not in d:\n            d[(p1, p2)] = 1\n        else:\n            d[(p1, p2)] += 1\n\n    for i in range(N):\n        p1 = tree_road.find(i)\n        p2 = tree_subway.find(i)\n        print(d[(p1, p2)], end=\" \")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\nN, K, L = list(map(int, input().split()))\nG1 = [[] for i in range(N)]\nfor i in range(K):\n    p, q = list(map(int, input().split()))\n    p -= 1\n    q -= 1\n    G1[p].append(q)\n    G1[q].append(p)\ngids = [0]*N\ndone = [False]*N\ndef dfs1(i, gid):\n    gids[i] = gid\n    done[i] = True\n    for nex in G1[i]:\n        if done[nex]: continue\n        dfs1(nex, gid)\ngid = 0\nfor i in range(N):\n    if not done[i]:\n        dfs1(i, gid)\n        gid += 1\n\nG = [[] for i in range(N)]\nfor i in range(L):\n    r, s = list(map(int, input().split()))\n    r -= 1\n    s -= 1\n    G[r].append(s)\n    G[s].append(r)\ndone = [False]*N\nD = []\ngid = 0\ndef dfs(i, gid):\n    D[gid][gids[i]] += 1\n    done[i] = True\n    for nex in G[i]:\n        if done[nex]: continue\n        dfs(nex, gid)\nfor i in range(N):\n    if not done[i]:\n        D.append(defaultdict(int))\n        dfs(i, gid)\n        gid += 1\nans = [0]*N\ndone = [False]*N\ngid = 0\ndef dfs2(i, gid):\n    done[i] = True\n    ans[i] = D[gid][gids[i]]\n    for nex in G[i]:\n        if done[nex]: continue\n        dfs2(nex, gid)\nfor i in range(N):\n    if not done[i]:\n        dfs2(i, gid)\n        gid += 1\nprint((*ans))\n", "from collections import Counter\n\n\nclass UnionFind:\n\n    def __init__(self, n: int) -> None:\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n\n    def find(self, i: int) -> None:\n        if self.parent[i] == i:\n            return i\n        else:\n            return self.find(self.parent[i])\n\n    def unite(self, i: int, j: int) -> None:\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i == root_j:\n            return\n        if self.rank[root_i] < self.rank[root_j]:\n            self.parent[root_i] = root_j\n        else:\n            self.parent[root_j] = root_i\n            if self.rank[root_i] == self.rank[root_j]:\n                self.rank[root_i] += 1\n\n                \nN, K, L = map(int, input().split())\n\nuf1 = UnionFind(N)\nfor _ in range(K):\n    i, j = map(int, input().split())\n    uf1.unite(i - 1, j - 1)\n\nuf2 = UnionFind(N)\nfor _ in range(L):\n    i, j = map(int, input().split())\n    uf2.unite(i - 1, j - 1)\n\nset_id_pairs = [(uf1.find(i), uf2.find(i)) for i in range(N)]\ncounter = Counter(set_id_pairs)\ncounts = [counter[set_id_pairs[i]] for i in range(N)]\nprint(' '.join(str(c) for c in counts))", "\"\"\"\nin1 = '7 4 4'\nin2 = ['1 2', '2 3', '2 5', '6 7', '3 5', '4 5', '3 4', '6 7']\nN, K, L = map(int, in1.split())\npqrs = []\nfor idx1 in range(K + L):\n    temp0, temp1 = map(int, in2[idx1].split())\n    pqrs.append([temp0, temp1])\n\"\"\"\n\ndef makeTree(a):\n    aT = list(range(N + 1))\n    for p, q in a:\n        rootp     = getRoot(aT, p)\n        rootq     = getRoot(aT, q)\n        thisRoot  = max(rootp, rootq, q)\n        aT[p]     = thisRoot\n        aT[q]     = thisRoot\n        aT[rootp] = thisRoot\n        aT[rootq] = thisRoot\n    return aT\n\ndef getRoot(a,i):\n    if a[i] == i:\n        return i\n    else:\n        a[i] = getRoot(a, a[i])\n        return a[i]\n\nN, K, L = list(map(int, input().split()))\npqrs = []\nfor idx1 in range(K + L):\n    temp0, temp1 = list(map(int, input().split()))\n    pqrs.append([temp0, temp1])\n\nMTree = makeTree(pqrs[0:K])\nTTree = makeTree(pqrs[K:])\n\naRet = []\ndRet = {}\nfor idx1 in range(1, N + 1):\n    Comb = (getRoot(MTree, idx1), getRoot(TTree, idx1))\n    aRet.append(Comb)\n    if Comb in dRet:\n        dRet[Comb] += 1\n    else:\n        dRet[Comb] = 1\n\nprint((\" \".join([str(dRet[_]) for _ in aRet])))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\n# UnionFind\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            self.parent[x] = y\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\nN, K, L = list(map(int, input().split()))\nun = UnionFind(N)\nfor i in range(K):\n    p, q = list(map(int, input().split()))\n    p -= 1\n    q -= 1\n    un.unite(p, q)\nG = [[] for i in range(N)]\nfor i in range(L):\n    r, s = list(map(int, input().split()))\n    r -= 1\n    s -= 1\n    G[r].append(s)\n    G[s].append(r)\ndone = [False]*N\nD = []\ngid = 0\ndef dfs(i, gid):\n    D[gid][un.root(i)] += 1\n    done[i] = True\n    for nex in G[i]:\n        if done[nex]: continue\n        dfs(nex, gid)\nfor i in range(N):\n    if not done[i]:\n        D.append(defaultdict(int))\n        dfs(i, gid)\n        gid += 1\nans = [0]*N\ndone = [False]*N\ngid = 0\ndef dfs2(i, gid):\n    done[i] = True\n    ans[i] = D[gid][un.root(i)]\n    for nex in G[i]:\n        if done[nex]: continue\n        dfs2(nex, gid)\nfor i in range(N):\n    if not done[i]:\n        dfs2(i, gid)\n        gid += 1\nprint((*ans))\n", "from collections import deque\n\nn,k,l = map(int,input().split())\nep = [[] for i in range(n)]\ner = [[] for i in range(n)]\n\ngp = [-1]*n\ngr = [-1]*n\n\nfor i in range(k):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    ep[a].append(b)\n    ep[b].append(a)\nfor i in range(l):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    er[a].append(b)\n    er[b].append(a)\n\ndef dfs(e,g):\n    count = 0\n    for i in range(n):\n        if g[i] == -1:\n            g[i] = count\n\n            q = deque([])\n            q.append(i)\n            while q:\n                now = q.pop()\n\n                for nex in e[now]:\n                    if g[nex] == -1:\n                        g[nex] = g[now]\n                        q.append(nex)\n            count += 1\n\n    return g\ngp = dfs(ep,gp)\ngr = dfs(er,gr)\nl = []\ndic = {}\nfor i in range(n):\n    s = (gp[i],gr[i])\n    l.append(s)\n    if s in dic:\n        dic[s] += 1\n    else:\n        dic[s] = 1\nans = [0]*n\n\nfor i in range(n):\n    ans[i] = dic[l[i]]\nprint(*ans)", "n,k,l=map(int,input().split())\nclass UnionFind:\n    #def   -> foo=UnionFind(n,1)  <- 1-based index, default is 0\n    #method -> foo.hoge(huga)\n    __slots__ = [\"_size\", \"_first_idx\", \"_parents\"]\n    def __init__(self, size: int, first_index: int = 0) -> None:\n        self._size = size\n        self._first_idx = first_index\n        self._parents = [-1] * (size + first_index)\n    def find(self, x: int) -> int:\n        if self._parents[x] < 0:\n            return x\n        news=[]\n        p=self._parents\n        y=p[x]\n        while y>=0:\n            news.append(x);x,y=y,p[y]\n        if len(news)!=1:\n            for P in news:p[P]=x\n        return x\n\n    def same(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n        if self._parents[x] > self._parents[y]:\n            x, y = y, x\n        self._parents[x] += self._parents[y]\n        self._parents[y] = x\n        return True\n    def size(self, x: int) -> int:\n        return -self._parents[self.find(x)]\n    def group_count(self) ->int:\n        return sum(1 for i in  self._parents if i<0)-self._first_idx\n    def connected(self) ->bool:\n        return self._parents[self.find(self._first_idx)]==-self._size\nroad=UnionFind(1,n)\nrail=UnionFind(1,n)\n\nfor i in range(k):\n    road.unite(*map(int,input().split()))\nfor i in range(l):\n    rail.unite(*map(int,input().split()))\nfrom collections import defaultdict\nd=defaultdict(int)\n\nfor i in range(1,n+1):\n    ap,op=rail.find(i),road.find(i)\n    d[ap*(n+1)+op]+=1\nprint(*[d[road.find(i)+rail.find(i)*(n+1)]for i in range(1,n+1)])", "import sys\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, K, L = map(int,input().split())\nuf_road = UnionFind(N)\nuf_train = UnionFind(N)\n\nfor i in range(K):\n    p,q = map(int,input().split())\n    p -= 1\n    q -= 1\n    uf_road.union(p,q)\n\nfor i in range(L):\n    p,q = map(int,input().split())\n    p -= 1\n    q -= 1\n    uf_train.union(p,q)\n\npair_list = []\nfor i in range(N):\n    pair_list.append((uf_road.find(i), uf_train.find(i), i))\n\npair_list.sort()\nans = [0] * N\n\npair = (pair_list[0][0], pair_list[0][1])\ncountup_list = [pair_list[0][2]]\nfor i in range(1,N):\n    if pair == (pair_list[i][0], pair_list[i][1]):\n        countup_list.append(pair_list[i][2])\n    else:\n        for c in countup_list:\n            ans[c] += len(countup_list)\n        pair = (pair_list[i][0], pair_list[i][1])\n        countup_list = [pair_list[i][2]]\n\nfor c in countup_list:\n    ans[c] += len(countup_list)\n    \nfor i in range(N):\n    print(ans[i], end=\" \")", "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn, k, l = list(map(int, input().split()))\nuf_k = UnionFind(n)\nuf_l = UnionFind(n)\nfor i in range(k):\n    p, q = list(map(int, input().split()))\n    uf_k.union(p - 1, q - 1)\nfor i in range(l):\n    r, s = list(map(int, input().split()))\n    uf_l.union(r - 1, s - 1)\nd = defaultdict(int)\nfor i in range(n):\n    d[uf_k.find(i), uf_l.find(i)] += 1\nprint((*(d[uf_k.find(i), uf_l.find(i)] for i in range(n))))\n", "import sys\nsys.setrecursionlimit(10**7)\nfrom collections import Counter\nclass UnionFind():\n    def __init__(self,n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self,x,y):\n        x = self.find(x)\n        y = self.find(y)\n        if x==y:\n            return\n        if self.parents[x]>self.parents[y]:\n            x,y=y,x\n        self.parents[x]+=self.parents[y]\n        self.parents[y]=x\n    #\u6728\u306e\u6df1\u3055\u3058\u3083\u306a\u304fx\u3092\u542b\u3080\u96c6\u5408\u306e\u8981\u7d20\u6570\n    def size(self,x):\n        return -self.parents[self.find(x)]\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def members(self,x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i)==root]\n\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x>0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,k,l=map(int,input().split())\nload=UnionFind(n+1)\ntetsu=UnionFind(n+1)\nfor _ in range(k):\n    p,q=map(int,input().split())\n    load.union(p,q)\nfor _ in range(l):\n    r,s = map(int,input().split())\n    tetsu.union(r,s)\n\ncount = [(load.find(i),tetsu.find(i)) for i in range(1,n+1)]\n# print(count)\nC = Counter(count)\nans = []\nfor i in range(n):\n\tif count[i][0]<0 or count[i][1]<0:\n\t\tans.append(0)\n\telse:\n\t\tans.append(C[count[i]])\nprint(*ans)", "n,k,l=map(int,input().split())\nload=[[] for _ in range(n)]\ntrain=[[] for _ in range(n)]\nfor _ in range(k):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  load[a].append(b)\n  load[b].append(a)\nfor _ in range(l):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  train[a].append(b)\n  train[b].append(a)\n\n# \u9053\u8def\u306e\u9023\u7d50\u30b0\u30eb\u30fc\u30d7\nload_grp_id=[-1]*n\nnot_grp=set(range(n))\nwhile not_grp:\n  t0=not_grp.pop()\n  todo=[t0]\n  load_grp_id[t0]=t0\n  while todo:\n    t=todo.pop()\n    l=load[t]\n    for li in l:\n      if load_grp_id[li]==-1:\n        load_grp_id[li]=t0\n        not_grp.discard(li)\n        todo.append(li)\n# \u9244\u9053\u306e\u9023\u7d50\u30b0\u30eb\u30fc\u30d7\ntrain_grp_id=[-1]*n\nnot_grp=set(range(n))\nwhile not_grp:\n  t0=not_grp.pop()\n  todo=[t0]\n  train_grp_id[t0]=t0\n  while todo:\n    t=todo.pop()\n    l=train[t]\n    for li in l:\n      if train_grp_id[li]==-1:\n        train_grp_id[li]=t0\n        not_grp.discard(li)\n        todo.append(li)\n\nd={}\nfor i in range(n):\n  lid=load_grp_id[i]\n  tid=train_grp_id[i]\n  if (lid,tid) in d:\n    d[(lid,tid)]+=1\n  else:\n    d[(lid,tid)]=1\nans=[]\nfor i in range(n):\n  lid=load_grp_id[i]\n  tid=train_grp_id[i]\n  ans.append(str(d[(lid,tid)]))\nprint(' '.join(ans))", "from collections import defaultdict\nclass UnionFind():\n  def __init__(self,n):\n    self.n=n\n    self.parents=[-1]*n\n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n  def unite(self,x,y):\n    x=self.find(x)\n    y=self.find(y)\n    if x==y:\n      return\n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n  def size(self,x):\n    return -size.parents[self.find(x)]\n  def same(self,x,y):\n    return self.find(x)==self.find(y)\n  def members(self,x):\n    root=self.find(x)\n    return [i for i in range(self.n) if self.find(i)==root]\n  def roots(self):\n    return [i for i,x in enumerate(self.parents) if x<0]\n  def group_count(self):\n    return len(self.roots())\n  def all_group_members(self):\n    return {r:self.members(r) for r in self.roots()}\nn,k,l=map(int,input().split())\nuf1=UnionFind(n)\nfor _ in range(k):\n  u,v=map(int,input().split())\n  uf1.unite(u-1,v-1)\nuf2=UnionFind(n)\nfor _ in range(l):\n  u,v=map(int,input().split())\n  uf2.unite(u-1,v-1)\nd=defaultdict(int)\nfor i in range(n):\n  d[(uf1.find(i),uf2.find(i))]+=1\nans=[d[(uf1.find(i),uf2.find(i))] for i in range(n)]\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\nN, K, L = list(map(int, input().split()))\n\n# Group1\nG1 = [[] for i in range(N)]\nfor i in range(K):\n    p, q = list(map(int, input().split()))\n    p -= 1\n    q -= 1\n    G1[p].append(q)\n    G1[q].append(p)\ngids = [0]*N\ndone = [False]*N\ndef dfs1(i, gid):\n    gids[i] = gid\n    done[i] = True\n    for nex in G1[i]:\n        if done[nex]: continue\n        dfs1(nex, gid)\ngid = 0\nfor i in range(N):\n    if not done[i]:\n        dfs1(i, gid)\n        gid += 1\n\n# Group2\nG = [[] for i in range(N)]\nfor i in range(L):\n    r, s = list(map(int, input().split()))\n    r -= 1\n    s -= 1\n    G[r].append(s)\n    G[s].append(r)\ndone = [False]*N\nD = []\ngids2 = [0]*N\ndef dfs(i, gid):\n    D[gid][gids[i]] += 1\n    done[i] = True\n    gids2[i] = gid\n    for nex in G[i]:\n        if done[nex]: continue\n        dfs(nex, gid)\ngid = 0\nfor i in range(N):\n    if not done[i]:\n        D.append(defaultdict(int))\n        dfs(i, gid)\n        gid += 1\n\n# answer\nans = [0]*N\nfor i in range(N):\n    ans[i] = D[gids2[i]][gids[i]]\nprint((*ans))\n", "import sys\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import Counter\n\ndef conn(n,m,e):\n    d=dict(list(zip(list(range(1,n+1)),list(range(-1,(-1)*n-1,-1)))))\n    td=defaultdict(lambda:deque([])) #td\u306f\u540c\u5024\u985e\u304c\u30ad\u30fc\u3067\u4e2d\u306e\u5143\u304c\u5024\n    c=1\n    for edge in e:\n        a=edge[0]\n        b=edge[1]\n        da=d[a] #da,db\u306fa,b\u306e\u542b\u307e\u308c\u308b\u540c\u5024\u6d41\u306e\u30e9\u30d9\u30eb\n        db=d[b]\n        if da<0 and db<0:\n            d[a]=c\n            d[b]=c\n            td[c].append(a)\n            td[c].append(b)\n            c+=1\n        elif da>0 and db<0:\n            d[b]=da\n            td[d[a]].append(b)\n        elif da<0 and db>0:\n            d[a]=db\n            td[d[b]].append(a)\n        elif da>0 and db>0 and da!=db:\n            for x in td[db]:\n                d[x]=da\n                td[da].append(x)\n\n    return list(d.values())\n\ndef components(n,k,e):\n    ed=defaultdict(lambda:deque())\n    for edge in e:\n        ed[edge[0]].append(edge[1])\n    c=0\n    s=[0]*n\n    label=[0]*n\n    for i in range(1,n+1):\n        if s[i-1]==0:\n            c+=1\n            label[c-1]=c\n            stack=deque([i])\n            while stack:\n                w=stack.pop()\n                s[w-1]=c\n                while ed[w]:\n                    wn=ed[w].pop()\n                    if s[wn-1]==0:\n                        s[wn-1]=c\n                        if ed[wn]:\n                            stack.append(w)\n                            w=wn\n                    elif s[wn-1]<c:\n                        label[s[wn-1]-1]=c\n    return [label[s[i]-1] for i in range(n)] \n           \ndef components2(n,k,e):\n    ed=defaultdict(lambda:deque())\n    for edge in e:\n        ed[edge[0]].append(edge[1])\n        ed[edge[1]].append(edge[0])\n    c=0\n    s=[0]*n\n    for i in range(1,n+1):\n        if s[i-1]==0:\n            c+=1\n            stack=deque([i])\n            while stack:\n                w=stack.pop()\n                s[w-1]=c\n                while ed[w]:\n                    wn=ed[w].pop()\n                    if s[wn-1]==0:\n                        s[wn-1]=c\n                        if ed[wn]:\n                            stack.append(w)\n                            w=wn\n    return [s[i] for i in range(n)] \ndef main(n,k,l,e1,e2):\n    d1=components2(n,k,e1)\n    d2=components2(n,l,e2)\n    p=tuple(zip(iter(d1),iter(d2)))\n    d=Counter(p)\n    # print(d1,d2,d,p)\n    print((' '.join([str(d[x]) for x in p]))) \n\ndef __starting_point():\n    ssr=sys.stdin.readline\n    n,k,l=list(map(int,ssr().strip().split()))\n    e1=[]\n    e2=[]\n    for _ in range(k):\n        e1.append(tuple(map(int,ssr().strip().split())))\n    for _ in range(l):\n        e2.append(tuple(map(int,ssr().strip().split())))\n    main(n,k,l,e1,e2)\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\n# UnionFind\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            self.parent[x] = y\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\nN, K, L = list(map(int, input().split()))\nun1 = UnionFind(N)\nfor i in range(K):\n    p, q = list(map(int, input().split()))\n    p -= 1\n    q -= 1\n    un1.unite(p, q)\nun2 = UnionFind(N)\nfor i in range(L):\n    r, s = list(map(int, input().split()))\n    r -= 1\n    s -= 1\n    un2.unite(r, s)\ndic = defaultdict(int)\nfor i in range(N):\n    a, b = un1.root(i), un2.root(i)\n    k = str(a)+\":\"+str(b)\n    dic[k] += 1\n\nans = [0]*N\nfor i in range(N):\n    a, b = un1.root(i), un2.root(i)\n    k = str(a)+\":\"+str(b)\n    ans[i] = dic[k]\nprint((*ans))\n", "from collections import defaultdict\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n        # * Access m-th node by index `m`, not `m - 1`.\n        self.parents = [i for i in range(n + 1)]\n        self.ranks = [0 for _ in range(n + 1)]\n\n    def find_root(self, node):\n        parent_node = self.parents[node]\n        if parent_node == node:\n            return node\n        else:\n            root_node = self.find_root(parent_node)\n            self.parents[node] = root_node  # reduction\n            return root_node\n\n    def union(self, one, other):\n        one_root = self.find_root(one)\n        other_root = self.find_root(other)\n        if one_root == other_root:\n            return\n        if self.ranks[one_root] < self.ranks[other_root]:\n            self.parents[one_root] = other_root\n        else:\n            self.parents[other_root] = one_root\n            if self.ranks[one_root] == self.ranks[other_root]:\n                self.ranks[one_root] += 1\n\n    def is_same_group(self, one, other):\n        one_root = self.find_root(one)\n        other_root = self.find_root(other)\n        return one_root == other_root\n\n\ndef main():\n    N, K, L = list(map(int, input().split(' ')))\n    road_tree = UnionFind(N)\n    for _ in range(K):\n        p, q = list(map(int, input().split(' ')))\n        road_tree.union(p, q)\n    train_tree = UnionFind(N)\n    for _ in range(L):\n        r, s = list(map(int, input().split(' ')))\n        train_tree.union(r, s)\n    # Calculate groups\n    group_count = defaultdict(int)\n    group_list = list()\n    for node in range(1, N + 1):\n        group = (road_tree.find_root(node), train_tree.find_root(node))\n        group_count[group] += 1\n        group_list.append(group)\n    answer = ' '.join(list(map(\n        lambda g: str(group_count[g]),\n        group_list\n    )))\n    print(answer)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    n, k, l = map(int, input().split())\n    p = [list(map(int, input().split())) for _ in range(k)]\n    r = [list(map(int, input().split())) for _ in range(l)]\n    uf1 = UnionFind(n)\n    for a, b in p:\n        uf1.union(a-1, b-1)\n    uf2 = UnionFind(n)\n    for a, b in r:\n        uf2.union(a-1, b-1)\n    dic = {}\n    for i in range(n):\n        rt1, rt2 = uf1.find(i), uf2.find(i)\n        if (rt1, rt2) in dic:\n            dic[(rt1, rt2)] += 1\n        else:\n            dic[(rt1, rt2)] = 1\n    for i in range(n):\n        rt1, rt2 = uf1.find(i), uf2.find(i)\n        print(dic[(rt1, rt2)], end=\" \")\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\n\nclass UnionFind():\n  def __init__(self,n):\n    self.parents=[-1]*n\n  \n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    \n    self.parents[x]=self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x=self.find(x)\n    y=self.find(y)\n    \n    if x==y:\n      return\n    \n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n      \n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n    \n  def size(self,x):\n    return abs(self.parents[self.find(x)])\n  \n\nN,K,L=list(map(int,input().split()))\nuf_road=UnionFind(N+1)\nuf_train=UnionFind(N+1)\nroad_dict=dict()\ntrain_dict=dict()\n\nfor _ in range(K):\n  p,q=list(map(int,input().split()))\n  uf_road.union(p,q)\n\nfor _ in range(L):\n  r,s=list(map(int,input().split()))\n  uf_train.union(r,s)\n\nset_id_pairs = [(uf_road.find(i), uf_train.find(i)) for i in range(1,N+1)]\ncounter = Counter(set_id_pairs)\ncounts = [counter[set_id_pairs[i]] for i in range(N)]\nprint((' '.join(str(c) for c in counts)))\n", "import sys\nmod=10**9+7 ; inf=float(\"inf\")\nfrom math import sqrt, ceil\nfrom collections import deque, Counter, defaultdict #\u3059\u3079\u3066\u306ekey\u304c\u7528\u610f\u3055\u308c\u3066\u308b defaultdict(int)\u3067\u521d\u671f\u5316\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright\n#\u30e1\u30e2\u5316\u518d\u5e30def\u306e\u5192\u982d\u306b\u6bce\u56de @lru_cache(maxsize=10**10)\n#\u5f15\u6570\u306blist\u306f\u3060\u3081\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\nclass UnionFind():\n    def __init__(self,num):\n        self.n = num         #class\u5185\u5909\u6570n\u306b\u3001\u5916\u90e8\u304b\u3089\u5165\u529b\u3057\u305f\u5024num\u3092\u4ee3\u5165\n        self.parents = [-1 for i in range(self.n)]\n          #parents\u306f\u8981\u7d20\u306e\u89aa(1\u3053\u4e0a\u306e\u3084\u3064)\u756a\u53f70~n-1\u3092\u683c\u7d0d\u3001\u81ea\u5206\u304c\u6700\u89aa\u306a\u3089-(\u8981\u7d20\u6570)\u3092\u683c\u7d0d(\u521d\u671f\u5024\u306f-1)\n\n    #x\u306e\u6700\u89aa\u306f\u8ab0\uff1f\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x]) #\u518d\u5e30\u3057\u30661\u756a\u4e0a\u307e\u3067\u3044\u3063\u3066\u308b\n                #\u8abf\u3079\u306a\u304c\u3089parents\u306e\u5024\u3092\u66f4\u65b0\u3057\u3066\u308b\uff01\uff08\u7d4c\u8def\u5727\u7e2e\uff09\n            return self.parents[x]\n\n    #\u7d50\u5408\u305b\u3088\n    #x\u306e\u89aa\u3068y\u306e\u89aa\u3092\u304f\u3063\u3064\u3051\u308b\n    def union(self,x,y):\n        xx=self.find(x)  #xx\u306fx\u306e\u6700\u89aa\n        yy=self.find(y)  #yy\u306fy\u306e\u6700\u89aa\n        if xx==yy:\n            return     #\u540c\u3058\u5c4b\u6839\u306e\u4e0b\u306b\u3042\u3063\u305f\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n        else:\n            size_xx=abs(self.parents[xx]) #x\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            size_yy=abs(self.parents[yy]) #y\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            if size_xx>size_yy:\n                xx,yy=yy,xx  #yy\u306e\u65b9\u304c\u5927\u304d\u3044\u6728\u3001\u3063\u3066\u3053\u3068\u306b\u3059\u308b\n\n            self.parents[yy]+=self.parents[xx] #\u5927\u304d\u3044\u6728\u306e\u30b5\u30a4\u30ba\u66f4\u65b0\n            self.parents[xx]=yy   #\u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u3044\u6728\u3092\u5927\u304d\u3044\u6728\u306b\u63a5\u3050\n\n    #x\u306e\u5c5e\u3059\u308b\u6728\u306e\u5927\u304d\u3055\uff08\u307e\u3042union\u3067\u3082\u4f7f\u3063\u305f\u3051\u3069\uff09\n    def size(self,x):\n        xx=self.find(x)\n        return abs(self.parents[xx])\n\n    #x\u3068y\u306f\u3053\u306e\u7a7a\u306e\u7d9a\u304f\u5834\u6240\u306b\u3044\u307e\u3059\u304b\u3000\u3044\u3064\u3082\u306e\u3088\u3046\u306b\u7b11\u9854\u3067\u3044\u3066\u304f\u308c\u307e\u3059\u304b\u3000\u4eca\u306f\u305f\u3060\u305d\u308c\u3092\u9858\u3044\u7d9a\u3051\u308b\n    def same(self,x,y):\n        return 1 if self.find(x)==self.find(y) else 0\n\n    #x\u3068\u3000\u540c\u3058\u6728\u306b\u3044\u308b\u3000\u30e1\u30f3\u30d0\u30fc\u306f\uff1f\n    def members(self,x):\n        xx=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==xx]\n             #if\u306e\u6761\u4ef6\u5f0f\u306b\u6f0f\u308c\u305f\u3089\u7121\u8996\n\n    #\u6700\u89aa\u3060\u3051\u3092\u4e26\u3079\u3042\u3052\u308b\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n        #\u3044\u3084\u3053\u308c\u306f\u5929\u624d\u3059\u304e\u308b\u3001basis\u306eenumerate.py\u53c2\u7167\n\n    #\u3059\u3079\u3066\u306e\u6700\u89aa\u306b\u3064\u3044\u3066\u3001\u30e1\u30f3\u30d0\u30fc\u3092\u8f9e\u66f8\u3067\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\n    #\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3069\u3046\u306a\u308a\u307e\u3057\u305f\u304b\u3001\uff12\u91cd\u30ea\u30b9\u30c8\u3067\n    def state_grouping(self):\n        return list(self.all_group_members().values())\n\nn,k,l=map(int,input().split())\nuf=UnionFind(n)\nuf2=UnionFind(n)\nfor i in range(k):\n    p,q=map(int,input().split())\n    p-=1;q-=1\n    uf.union(p,q)\nfor i in range(l):\n    p,q=map(int,input().split())\n    p-=1;q-=1\n    if 1:\n        uf2.union(p,q)\n\nC= Counter( [ ( uf.find(i),uf2.find(i) ) for i in range(n)] )\nANS=[0]*n \nfor i in range(n):\n    ANS[i]= C[(uf.find(i),uf2.find(i))]\nprint(*ANS)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.group_count = n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        self.group_count -= 1\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\ndef int_(num_str):\n    return int(num_str) - 1\n\n\nN, K, L = list(map(int, input().split()))\nuf1 = UnionFind(N)\nfor _ in range(K):\n    p, q = list(map(int_, input().split()))\n    uf1.union(p, q)\nuf2 = UnionFind(N)\nfor _ in range(L):\n    r, s = list(map(int_, input().split()))\n    uf2.union(r, s)\nfrom collections import Counter\npair = [(uf1.find(i), uf2.find(i)) for i in range(N)]\nans = Counter(pair)\nprint((*[ans[p] for p in pair]))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nfrom collections import Counter\nn, k, l = map(int, input().split())\na = [list(map(int, input().split())) for i in range(k)]\nb = [list(map(int, input().split())) for i in range(l)]\nuf1 = UnionFind(n)\nuf2 = UnionFind(n)\nfor i in a:\n\tuf1.union(i[0]-1, i[1]-1)\nfor i in b:\n\tuf2.union(i[0]-1, i[1]-1)\nl = [[0, 0] for i in range(n)]\nfor i in range(n):\n\tl[i][0] = uf1.find(i)\n\tl[i][1] = uf2.find(i)\n\tl[i] = tuple([l[i][0], l[i][1]])\nc = Counter(l)\nfor i in range(n):\n\tprint(c[l[i]],end=\" \")", "from collections import defaultdict\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):  #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):  #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):  #\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):   #\u8981\u7d20x\u3068\u8981\u7d20y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n\n    def members(self, x):   #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):    #\u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):  #\u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u5909\u3048\u3059\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, k, l = map(int, input().split())\n\nuf = UnionFind(n)\n\np, q = [0] * k, [0] * k\nfor i in range(k):\n    pp, qq = map(int, input().split())\n    p[i] = pp - 1 \n    q[i] = qq - 1\n    uf.union(pp - 1, qq - 1)\n\nuuff = UnionFind(n)\nr, s = [0] * l, [0] * l\nfor i in range(l):\n    rr, ss = map(int, input().split())\n    r[i] = rr - 1\n    s[i] = ss - 1\n    uuff.union(rr - 1, ss - 1)\ndic = defaultdict(int)\nfor i in range(n):\n    dic[(uf.find(i), uuff.find(i))] += 1\n\nans = []\nfor i in range(n):\n    ans.append(dic[uf.find(i), uuff.find(i)])\n\nfor i in ans:\n    print(i,end=\" \")", "from collections import Counter\n\nn,k,l=map(int,input().split())\ncity1=[i for i in range(n)]\ncity2=[i for i in range(n)]\n\ndef root(c,x):\n  if x==c[x]:\n    return x\n  else:\n    c[x]=root(c,c[x])\n    return c[x]\n\ndef union(c,x,y):\n  rx=root(c,x)\n  ry=root(c,y)\n  if rx>ry:\n    c[rx]=ry\n  else:\n    c[ry]=rx\n\nfor i in range(k):\n  a,b=map(int,input().split())\n  union(city1,a-1,b-1)\nfor i in range(l):\n  a,b=map(int,input().split())\n  union(city2,a-1,b-1)\nr=[]\nfor i in range(n):\n  r.append((root(city1,i),root(city2,i)))\nc=Counter(r)\nfor i in range(n):\n  ans=c[r[i]]\n  if i==n-1:\n    print(ans)\n  else:\n    print(ans,end=' ')", "import sys\nfrom collections import defaultdict\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nclass UnionFind:\n    def __init__(self, n_nodes):\n        self.n_nodes = n_nodes\n        self.parent = [i for i in range(n_nodes)]\n        self.rank = [1] * n_nodes\n        self.size = [1] * n_nodes\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n        else:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_parent_list(self):\n        return [i for i in range(self.n_nodes) if self.find(i) == i]\n\n    def get_n_groups(self):\n        return len(self.get_parent_list())\n\n    def get_members(self, x):\n        parent = self.find(x)\n        return [i for i in range(self.n_nodes) if self.find(i) == parent]\n\n    def get_members_dict(self):\n        return {par: self.get_members(par) for par in self.get_parent_list()}\n\n\ndef main():\n    N, K, L = map(int, input().split())\n    Tree_road = UnionFind(N)\n    Tree_train = UnionFind(N)\n    for _ in range(K):\n        p, q = map(int, input().split())\n        Tree_road.unite(p - 1, q - 1)\n    for _ in range(L):\n        p, q = map(int, input().split())\n        Tree_train.unite(p - 1, q - 1)\n    DD = defaultdict(int)\n    for i in range(N):\n        DD[(Tree_road.find(i), Tree_train.find(i))] += 1\n    answer = []\n    for i in range(N):\n        answer.append(DD[(Tree_road.find(i), Tree_train.find(i))])\n\n    print(*answer, sep=\" \")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import Counter\n\ndef conn(n,m,e):\n    d=dict(list(zip(list(range(1,n+1)),list(range(-1,(-1)*n-1,-1)))))\n    td=defaultdict(lambda:deque([])) #td\u306f\u540c\u5024\u985e\u304c\u30ad\u30fc\u3067\u4e2d\u306e\u5143\u304c\u5024\n    c=1\n    for edge in e:\n        a=edge[0]\n        b=edge[1]\n        da=d[a] #da,db\u306fa,b\u306e\u542b\u307e\u308c\u308b\u540c\u5024\u6d41\u306e\u30e9\u30d9\u30eb\n        db=d[b]\n        if da<0 and db<0:\n            d[a]=c\n            d[b]=c\n            td[c].append(a)\n            td[c].append(b)\n            c+=1\n        elif da>0 and db<0:\n            d[b]=da\n            td[d[a]].append(b)\n        elif da<0 and db>0:\n            d[a]=db\n            td[d[b]].append(a)\n        elif da>0 and db>0 and da!=db:\n            for x in td[db]:\n                d[x]=da\n                td[da].append(x)\n\n    return list(d.values())\n\n# def components(n,k,e):\n#     ed=defaultdict(lambda:deque())\n#     for edge in e:\n#         ed[edge[0]].append(edge[1])\n#     c=0\n#     s=[0]*n\n#     label=[0]*n\n#     for i in range(1,n+1):\n#         if s[i-1]==0:\n#             c+=1\n#             label[c-1]=c\n#             stack=deque([i])\n#             while stack:\n#                 w=stack.pop()\n#                 s[w-1]=c\n#                 while ed[w]:\n#                     wn=ed[w].pop()\n#                     if s[wn-1]==0:\n#                         s[wn-1]=c\n#                         if ed[wn]:\n#                             stack.append(w)\n#                             w=wn\n#                     elif s[wn-1]<c:\n#                         label[s[wn-1]-1]=c\n#     print(s)\n#     print(label)\n#     return [label[s[i]-1] for i in range(n)] \n           \ndef components(n,k,e):\n    ed=defaultdict(lambda:deque())\n    for edge in e:\n        ed[edge[0]].append(edge[1])\n        ed[edge[1]].append(edge[0])\n    c=0\n    s=[0]*n\n    stack=deque()\n    for i in range(1,n+1):\n        if s[i-1]==0:\n            c+=1\n            stack.clear()\n            stack.append(i)\n            while stack:\n                w=stack.pop()\n                s[w-1]=c\n                while ed[w]:\n                    wn=ed[w].pop()\n                    if s[wn-1]==0:\n                        s[wn-1]=c\n                        if ed[wn]:\n                            stack.append(w)\n                            w=wn\n    return [s[i] for i in range(n)] \n\ndef components2(n,k,e):\n    es=deque(set((edge[0],edge[1])) for edge in e)\n    c=0\n    s=deque()\n    stack=deque()\n    while es:\n        f=es.pop()\n        stack.clear()\n        while es:\n            l=len(es)\n            g=es.pop()\n            if g&f:\n                f|=g\n            else:\n                stack.append(g)\n            if l==len(stack):\n                s.append(f)\n                break\n            es=stack\n    t=[0]*n\n    c=0\n    while s:\n        for x in s.pop():\n            t[x-1]=c\n        c+=1\n    return t\n                \n                \n        \n        \ndef main(n,k,l,e1,e2):\n    d1=components(n,k,e1)\n    d2=components(n,l,e2)\n    p=tuple(zip(iter(d1),iter(d2)))\n    d=Counter(p)\n    # print(d1,d2,d,p)\n    print((' '.join([str(d[x]) for x in p]))) \n\ndef __starting_point():\n    ssr=sys.stdin.readline\n    n,k,l=list(map(int,ssr().strip().split()))\n    e1=[]\n    e2=[]\n    for _ in range(k):\n        e1.append(tuple(map(int,ssr().strip().split())))\n    for _ in range(l):\n        e2.append(tuple(map(int,ssr().strip().split())))\n    main(n,k,l,e1,e2)\n\n__starting_point()", "# python 3.4.3\nimport sys\ninput = sys.stdin.readline\nimport numpy as np\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0]*(n+1)\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,K,L = map(int,input().split())\nPQ = [tuple(map(int,input().split())) for _ in range(K)]\nRS = [tuple(map(int,input().split())) for _ in range(L)]\n\n# \u9053\u8def\nA = UnionFind(N)\nfor p,q in PQ:\n    A.unite(p-1,q-1)\n \n# \u9244\u9053\nB = UnionFind(N)\nfor r,s in RS:\n    B.unite(r-1,s-1)\n\n# \u96c6\u8a08\nfrom collections import defaultdict\ndic = defaultdict(int)\nfor i in range(N):\n    dic[A.find(i), B.find(i)] += 1\n \nAns = list(dic[A.find(i), B.find(i)] for i in range(N))\nprint(\" \".join(map(str,Ans)))", "from collections import defaultdict\n\nN, K, L = list(map(int, input().split()))\n\n\n# union-find\u3092\u5b9f\u88c5\nroot_road = [-1] * N\nroot_train = [-1] * N\n\n\ndef find_road(x):\n    if root_road[x] < 0:\n        return x\n\n    root_road[x] = find_road(root_road[x])\n    return root_road[x]\n\n\ndef union_road(x, y):\n    x = find_road(x)\n    y = find_road(y)\n    if x == y:\n        return\n\n    root_road[x] += root_road[y]\n    root_road[y] = x\n\n\ndef same_road(x, y):\n    return find_road(x) == find_road(y)\n\n\ndef find_train(x):\n    if root_train[x] < 0:\n        return x\n\n    root_train[x] = find_train(root_train[x])\n    return root_train[x]\n\n\ndef union_train(x, y):\n    x = find_train(x)\n    y = find_train(y)\n    if x == y:\n        return\n\n    root_train[x] += root_train[y]\n    root_train[y] = x\n\n\ndef same_train(x, y):\n    return find_train(x) == find_train(y)\n\n\ndc = defaultdict(list)\ndt = defaultdict(list)\nfor _ in range(K):\n    p, q = list(map(int, input().split()))\n    p -= 1\n    q -= 1\n    dc[p].append(q)\n    dc[q].append(p)\n    union_road(p, q)\n\nfor _ in range(L):\n    r, s = list(map(int, input().split()))\n    r -= 1\n    s -= 1\n    dt[r].append(s)\n    dt[s].append(r)\n    union_train(r, s)\n\n# print(root_road, root_train)\ndic = {}\nfor i in range(N):\n    if (find_road(i), find_train(i)) not in dic:\n        dic[(find_road(i), find_train(i))] = 1\n        continue\n    else:\n        dic[(find_road(i), find_train(i))] += 1\n\nans = []\nfor i in range(N):\n    ans.append(dic[(find_road(i), find_train(i))])\nprint((*ans))\n", "class UnionFind:\n    def __init__(self, N):\n        self.N = N\n\n        # the parent of all node is itself\n        # self.parent = list(range(N))\n        self.parent = [-1] * N\n\n    def root(self, i):\n        if self.parent[i] < 0:\n            return i\n\n        r = self.root(self.parent[i])\n        self.parent[i] = r\n        return r\n\n    def unite(self, i, j):\n        i = self.root(i)\n        j = self.root(j)\n\n        if i == j:\n            return\n\n        if i > j:\n            i, j = j, i\n\n        self.parent[i] += self.parent[j]\n        self.parent[j] = i\n        # print(self.parent)\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n    def size(self, i):\n        return -self.parent[self.root(i)]\n\n    def roots(self):\n        return [self.root(i) for i in range(self.N)]\n\nN, K, L = map(int, input().split())\n\nroad = UnionFind(N)\nrail = UnionFind(N)\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    p += -1\n    q += -1\n    road.unite(p, q)\n\nfor _ in range(L):\n    r, s = map(int, input().split())\n    r += -1\n    s += -1\n    rail.unite(r, s)\n\npair = {}\nfor i,j in zip(road.roots(), rail.roots()):\n    t = (i, j)\n\n    if t in pair:\n        pair[t] += 1\n    else:\n        pair[t] = 1\n\nans = ' '.join([str(pair[(i, j)]) for i,j in zip(road.roots(), rail.roots())])\nprint(ans)", "from collections import Counter\nfrom typing import AnyStr\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\ndef main():\n    n, k, l = list(map(int, input().split()))\n    a = UnionFind(n)\n    b = UnionFind(n)\n    for _ in range(k):\n        p, q = list(map(int, input().split()))\n        a.union(p-1, q-1)\n    for _ in range(l):\n        r, s = list(map(int, input().split()))\n        b.union(r-1, s-1)\n    pairs = []\n    for i in range(n):\n        pairs.append((a._root(i), b._root(i)))\n\n    d = Counter(pairs)\n    ans = [d[x] for x in pairs]\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**9)\ninput=sys.stdin.readline\nN,K,L=map(int,input().split())\n\ndef get_par(x):\n  if x == par_list[x]:\n    return x\n  else:\n    par_list[x] = get_par(par_list[x])\n    return par_list[x]\ndef merge(x,y):\n  par_x = get_par(x)\n  par_y = get_par(y)\n  if par_x != par_y:\n    par_list[par_y] = par_x\ndef is_same(x,y):\n  return get_par(x) == get_par(y)\n\npar_list=list(range(N+1))\nfor _ in range(K):\n  p,q=map(int,input().split())\n  merge(p,q)\nfor i in range(1,N+1):\n  par_list[i]=get_par(i)\npar_list_road=par_list[:]\n  \npar_list=list(range(N+1))\nfor _ in range(L):\n  r,s=map(int,input().split())\n  merge(r,s)\nfor i in range(1,N+1):\n  par_list[i]=get_par(i)\npar_list_rail=par_list[:]\n\n#print(par_list_road)\n#print(par_list_rail)\nanswer_dic=defaultdict(int)\nfor i in range(1,N+1):\n  road_i=par_list_road[i]\n  rail_i=par_list_rail[i]\n  answer_dic[(road_i,rail_i)]+=1\n  \nanswer_list=[]\nfor i in range(1,N+1):\n  road_i=par_list_road[i]\n  rail_i=par_list_rail[i]\n  answer_list.append(answer_dic[(road_i,rail_i)])\n  \nprint(*answer_list)", "N,K,L = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        # size of n.\n        self.n = n\n        # n's parent. default is -1.\n        self.parents = [-1] * n\n\n    def find_root(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find_root(self.parents[x])\n            return self.parents[x]\n\n    def union_merge(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    # You shouldn't use these below for optimization.\n    # Use only find_root to compare if you need.\n    def union_size(self, x):\n        # Root value's index has its size with negative.\n        return -self.parents[self.find_root(x)]\n\n    def is_same_union(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def same_union_members(self, x):\n        root = self.find_root(x)\n        return [i for i in range(self.n) if self.find_root(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def union_count(self):\n        return len(self.roots())\n\n    def all_unions(self):\n        return [self.same_union_members(r) for r in self.roots()]\n\nroad = UnionFind(N)\nrail = UnionFind(N)\n\nfor i in range(K):\n    p, k = list(map(int, input().split()))\n    road.union_merge(p-1, k-1)\n\nfor i in range(L):\n    r, s = list(map(int, input().split()))\n    rail.union_merge(r-1, s-1)\n\nroot_combinations = []\nfor i in range(N):\n    root_combinations.append((road.find_root(i), rail.find_root(i)))\n\nfrom collections import Counter\nsame_combinations = Counter(root_combinations)\nresult = [same_combinations[root_combination] for root_combination in root_combinations]\n\nans = ' '.join(map(str, result))\nprint(ans)\n", "class UnionFind:\n    def __init__(self,n):\n        self.par = [i for i in range(n+1)]  #\u89aa\u306e\u30ce\u30fc\u30c9\u756a\u53f7\n        self.rank = [0]*(n+1)\n    def find(self,x):  #x\u306e\u6839\u306e\u30ce\u30fc\u30c9\u756a\u53f7\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def same_check(self,x,y):  #x,y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5426\u304b\n        return self.find(x) == self.find(y)\n    def union(self,x,y):  #x,y\u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        elif self.rank[x] > self.rank[y]:\n            self.par[y] = x\n        else:\n            self.par[y] = x\n            self.rank[x] += 1\n\nN,K,L = map(int,input().split())\nA = [list(map(int,input().split())) for i in range(K)]\nB = [list(map(int,input().split())) for i in range(L)]\n\nroad = UnionFind(N)\ntrain = UnionFind(N)\n\nfor i in range(K):\n    road.union(A[i][0],A[i][1])\nfor i in range(L):\n    train.union(B[i][0],B[i][1])\n\npair = [(road.find(i),train.find(i)) for i in range(1,N+1)]\n\nfrom collections import Counter\n\n#\u6839\u304c\u540c\u3058\u306a\u3089\u9053\u8defor\u9244\u9053\u3067\u3064\u306a\u3052\u308b\n\nc = Counter(pair)\nprint(*[c[i] for i in pair])", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef renketu(n , k , l , pqli , rsli):\n\n    from collections import defaultdict\n\n    ans = []\n    pquf = UnionFind(n)\n    rsuf = UnionFind(n)\n\n    [pquf.unite(p - 1 , q - 1) for q , p in pqli]\n    [rsuf.unite(r - 1 , s - 1) for r , s in rsli]\n\n    ansdict = defaultdict(int)\n\n    for i in range(n):\n        ansdict[(pquf.find(i) , rsuf.find(i))] += 1\n\n    for i in range(n):\n        ans.append(ansdict[(pquf.find(i) , rsuf.find(i))])\n\n    return ans\n\ndef main():\n    n, k, l = map(int, input().split())\n    pqli = [list(map(int , input().split())) for i in range(k)]\n    rsli = [list(map(int , input().split())) for i in range(l)]\n    ans = renketu(n , k , l , pqli , rsli)\n\n    print(*ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\n\nclass UnionFind:\n  def __init__(self, n):\n    self.n = n\n    self.par = [i for i in range(n)]\n    self.rank = [0]*n\n    \n    \n  def find(self, x):\n    if self.par[x] == x:\n      return x\n    else:\n      self.par[x] = self.find(self.par[x])\n      return self.par[x]\n  \n  \n  def unite(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.rank[x] < self.rank[y]:\n      self.par[x] = y\n    else:\n      self.par[y] = x\n      if self.rank[x] == self.rank[y]:\n        self.rank[x] += 1\n        \n        \n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n  \n  \n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n  \n\nn, k, l  = map(int, input().split())\npq = [list(map(int, input().split())) for i in range(k)]\nrs = [list(map(int, input().split())) for i in range(l)]\n\nuf_pq = UnionFind(n)\nuf_rs = UnionFind(n)\n\nfor p in pq:\n  x, y = p\n  uf_pq.unite(x-1, y-1)\n  \nfor r in rs:\n  x, y = r\n  uf_rs.unite(x-1, y-1)\n  \npairs = []\nfor i in range(n):\n  pairs.append((uf_pq.find(i), uf_rs.find(i)))\n  \ncount = Counter(pairs)\n\nans = [count[pair] for pair in pairs]\nprint(*ans)", "n, k, l = map(int, input().split())\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1] * n\n \n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n \n    def unite(self, u, v):\n        u, v = self.root(u), self.root(v)\n        if u == v:\n            return False\n        if self.size[u] > self.size[v]:\n            u, v = v, u # size[u] <= size[v]\n        self.size[v] += self.size[u]\n        self._par[u] = v\n \n    def is_connected(self, u, v):\n        return self.root(u) == self.root(v)\n\n\nrood = UnionFind(n)\ntrain = UnionFind(n)\n\nfor _ in range(k):\n    p, q = map(int, input().split())\n    rood.unite(p-1, q-1)\n\nfor _ in range(l):\n    r, s = map(int, input().split())\n    train.unite(r-1, s-1)\n\n\nfrom collections import Counter\ncnt = Counter()\nfor i in range(n):\n    root_r, root_t = rood.root(i), train.root(i)\n    cnt[(root_r, root_t)] += 1\n\nans = []\nfor i in range(n):\n    root_r, root_t = rood.root(i), train.root(i)\n    ans.append(cnt[(root_r, root_t)])\n\nprint(*ans)", "N, K, L = map(int, input().split())\n#Parent List(PL)\nroad = [i for i in range(N)]\nrail = [i for i in range(N)]\n\ndef fp(x,P): #findParent\n    if x == P[x]:\n        return x\n    else:\n        P[x] = fp(P[x],P)\n        return P[x]\n\nfor i in range(K+L):\n    PL = (lambda x:road if x < K else rail)(i)\n    p, q = map(lambda x:int(x)-1, input().split())\n    p, q = fp(p,PL), fp(q,PL)\n    PL[p] = PL[q] = min(p,q)\n\nfrom collections import defaultdict as dd\nWconnected = dd(lambda:0)\nfor i in range(N):\n    Wconnected[fp(i,road),fp(i,rail)] += 1\nprint(*[Wconnected[fp(i,road),fp(i,rail)] for i in range(N)])", "from collections import deque\n\ndef bfs():\n    q = deque()\n    color1 = [-1] * (n + 1)\n    color2 = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color1[i] == -1:\n            color1[i] = i\n            q.append(i)\n            while q:\n                p = q.popleft()\n                for j in G[p]:\n                    if color1[j] == -1:\n                        color1[j] = color1[p]\n                        q.append(j)\n        if color2[i] == -1:\n            color2[i] = i\n            q.append(i)\n            while q:\n                p = q.popleft()\n                for j in H[p]:\n                    if color2[j] == -1:\n                        color2[j] = color2[p]\n                        q.append(j)\n    group = [color1[i] + 200000 * color2[i] for i in range(n + 1)]\n    return group\n\nn, k, l = map(int, input().split())\nG = [[] for _ in range(n + 1)]\nH = [[] for _ in range(n + 1)]\nfor _ in range(k):\n    p, q = map(int, input().split())\n    G[p].append(q)\n    G[q].append(p)\nfor _ in range(l):\n    r, s = map(int, input().split())\n    H[r].append(s)\n    H[s].append(r)\ngroup = bfs()\nd = {}\nfor i in range(1, n + 1):\n    if group[i] in d:\n        d[group[i]] += 1\n    else:\n        d[group[i]] = 1\nans = [0] * n\nfor i in range(1, n + 1):\n    ans[i - 1] = d[group[i]]\nprint(\" \".join(map(str, ans)))", "from collections import Counter\nN, K, L = list(map(int, input().split()))\n# Union-Find\ndef get_root(par, node):\n  if par[node] == node:\n    return node\n  root = get_root(par, par[node])\n  par[node] = root\n  return root\n\ndef union(par, rank, a, b):\n  root_a, root_b = get_root(par, a), get_root(par, b)\n  if root_a == root_b:\n    return\n  rank_a, rank_b = rank[root_a], rank[root_b]\n  if rank_a < rank_b:\n    par[root_a] = root_b\n  else:\n    par[root_b] = root_a\n    if rank_a == rank_b:\n      rank[root_a] += 1\n\npar1 = [i for i in range(N)]\nrank1 = [1] * N\nfor _ in range(K):\n    a, b = list(map(int, input().split()))\n    union(par1, rank1, a-1, b-1)\n\npar2 = [i for i in range(N)]\nrank2 = [1] * N\nfor _ in range(L):\n    a, b = list(map(int, input().split()))\n    union(par2, rank2, a-1, b-1)\n\nct = Counter()\nfor i in range(N):\n    a = get_root(par1, i)\n    b = get_root(par2, i)\n    ct[(a, b)] += 1\n\nprint((' '.join([str(ct[(par1[i], par2[i])]) for i in range(N)])))\n", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n\ndef main():\n    import sys\n    from collections import Counter\n    # readline = sys.stdin.readline\n    readlines = sys.stdin.readlines\n    N, K, L = list(map(int, input().split()))\n    uf1 = UnionFind(N)\n    uf2 = UnionFind(N)\n\n    IN = readlines()\n    for i in range(K):\n        p, q = list(map(int, IN[i].split()))\n        p -= 1; q -= 1\n        uf1.union(p, q)\n    for j in range(K, K + L):\n        r, s = list(map(int, IN[j].split()))\n        r -= 1; s -= 1\n        # if uf1.find(r) == uf1.find(s):\n        uf2.union(r, s)\n    \n    # ans = []\n    # for i in range(N):\n    #     ans.append(-uf2.parents[uf2.find(i)])\n    # print(*ans)\n    path = []\n    C = Counter()\n    for i in range(N):\n        pair = (uf1.find(i), uf2.find(i))\n        path.append(pair)\n        C[pair] += 1\n\n    ans = []\n    for i in range(N):\n        ans.append(C[path[i]])\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\nn,k,l=map(int,input().split())\ncity1=[i for i in range(n)]\ncity2=[i for i in range(n)]\n\ndef root(c,x):\n  if x==c[x]:\n    return x\n  else:\n    return root(c,c[x])\n\ndef union(c,x,y):\n  rx=root(c,x)\n  ry=root(c,y)\n  if rx>ry:\n    c[rx]=ry\n  else:\n    c[ry]=rx\n\nfor i in range(k):\n  a,b=map(int,input().split())\n  union(city1,a-1,b-1)\nfor i in range(l):\n  a,b=map(int,input().split())\n  union(city2,a-1,b-1)\nr=[]\nfor i in range(n):\n  r.append((root(city1,i),root(city2,i)))\nc=Counter(r)\nfor i in range(n):\n  ans=c[r[i]]\n  if i==n-1:\n    print(ans)\n  else:\n    print(ans,end=' ')", "import sys\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import Counter\n\ndef conn(n,m,e):\n    d=dict(list(zip(list(range(1,n+1)),list(range(-1,(-1)*n-1,-1)))))\n    td=defaultdict(lambda:deque([])) #td\u306f\u540c\u5024\u985e\u304c\u30ad\u30fc\u3067\u4e2d\u306e\u5143\u304c\u5024\n    c=1\n    for edge in e:\n        a=edge[0]\n        b=edge[1]\n        da=d[a] #da,db\u306fa,b\u306e\u542b\u307e\u308c\u308b\u540c\u5024\u6d41\u306e\u30e9\u30d9\u30eb\n        db=d[b]\n        if da<0 and db<0:\n            d[a]=c\n            d[b]=c\n            td[c].append(a)\n            td[c].append(b)\n            c+=1\n        elif da>0 and db<0:\n            d[b]=da\n            td[d[a]].append(b)\n        elif da<0 and db>0:\n            d[a]=db\n            td[d[b]].append(a)\n        elif da>0 and db>0 and da!=db:\n            for x in td[db]:\n                d[x]=da\n                td[da].append(x)\n\n    return list(d.values())\n\ndef main(n,k,l,e1,e2):\n    d1=conn(n,k,e1)\n    d2=conn(n,l,e2)\n    p=tuple(zip(iter(d1),iter(d2)))\n    d=Counter(p)\n    # print(d1,d2,d,p)\n    d[(k,l)]=1\n    print((' '.join([str(d[x]) for x in p])))\n\ndef __starting_point():\n    ssr=sys.stdin.readline\n    n,k,l=list(map(int,ssr().strip().split()))\n    e1=[]\n    e2=[]\n    for _ in range(k):\n        e1.append(tuple(map(int,ssr().strip().split())))\n    for _ in range(l):\n        e2.append(tuple(map(int,ssr().strip().split())))\n    main(n,k,l,e1,e2)\n\n__starting_point()", "N, K, L = map(int, input().split())\n\npar = [i for i in range(N)]\n\ndef find(x, P):\n    if P[x] == x:\n        return x\n    else:\n        b = find(P[x], P)\n        P[x] = b\n        return b\n\ndef unite(x, y, P):\n    root_x = find(x, P)\n    root_y = find(y, P)\n    if root_y > root_x:\n        P[root_x] = root_y\n    else:\n        P[root_y] = root_x\n\npar2 = [i for i in range(N)]\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    unite(p-1, q-1, par)\n\nfor _ in range(L):\n    p, q = map(int, input().split())\n    unite(p-1, q-1, par2)\n#print(par2)\n\nr=[]\nfor i in range(N):\n    r.append((find(i,par), find(i, par2)))\n\nimport collections\ncount = collections.Counter(r)\n#print(count)\n\nfor i in range(N):\n  ans = count[r[i]]\n  if i == N-1:\n    print(ans)\n  else:\n    print(ans, end=' ')", "\"\"\"\n\u9053\u8def\u3067\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u3084\u3064\u304c\u9244\u9053\u3067\u3082\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u3092\u8abf\u3079\u308b\u306b\u306f\u3069\u3046\u3059\u308c\u3070\u3044\u3044\uff1f\n\u666e\u901a\u306b\u6728\u3054\u3068\u306e\u30b5\u30a4\u30ba\u3092\u6c42\u3081\u3066\u304a\u3051\u3070\u3044\u3044\u306e\u304b\uff1f\n\n\u9053\u8def\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u3092\u6839\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3059\u308b\u3002\u305d\u306e\u4e2d\u3067\u3001\u3055\u3089\u306b\u9244\u9053\u306e\u6839\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3059\u308b\u3002\n\u3067choose\u3067\u30da\u30a2\u6570\u3092\u6c42\u3081\u308c\u3070\u826f\u3044\u3002\n\n\"\"\"\nimport math\nimport sys\nsys.setrecursionlimit(200000)\nclass UnionFind():\n    def __init__(self,n):\n        self.parents = [i for i in range(n+1)]\n\n    def find(self,x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self,x,y):\n        self.parents[self.find(y)]=self.find(x)\n\nN,K,L = list(map(int,input().split()))\nA = UnionFind(N)\nB = UnionFind(N)\nfor i in range(K):\n    p,q = list(map(int,input().split()))\n    A.union(p,q)\n\nfor i in range(L):\n    r,s = list(map(int,input().split()))\n    B.union(r,s)\n\n\ngroup = {}\nfor i in range(1,N+1):\n    roadRoot = A.find(i)\n    if roadRoot not in group:\n        group[roadRoot] = {}\n    railRoot = B.find(i)\n    if railRoot not in group[roadRoot]:\n        group[roadRoot][railRoot] = []\n    group[roadRoot][railRoot].append(i)\n\nans = [[]for _ in range(N)]\nfor i in list(group.items()):\n    for j in list(i[1].values()):\n        for k in j:\n            ans[k-1] = str(len(j))\n\nans = \" \".join(ans)\nprint(ans)\n", "from collections import Counter\n\nclass UnionFind():\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1]*(n+1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0]*(n+1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def find_root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            #\u7d4c\u8def\u5727\u7e2e\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.find_root(x)\n        y = self.find_root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSame(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.root[self.find_root(x)]\n        \nn,k,l = map(int,input().split())\nfe = UnionFind(n)\nbus = UnionFind(n)\nfor _ in range(k):\n    p,q = map(int,input().split())\n    fe.unite(p,q)\nfor _ in range(l):\n    r,s = map(int,input().split())\n    bus.unite(r,s)\ncnt = Counter()\nfor i in range(1,n+1):\n    cnt[fe.find_root(i),bus.find_root(i)] += 1\n\nprint(*[cnt[fe.find_root(i),bus.find_root(i)]for i in range(1,n+1)])", "from collections import Counter\n\n\nclass Union_Find:\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.siz = [1] * n\n\n    def root(self, x):\n        if self.par[x] == -1:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return False\n\n        if self.siz[x] < self.siz[y]:\n            tmp = x\n            x = y\n            y = tmp\n\n        self.par[y] = x\n        self.siz[x] += self.siz[y]\n        return True\n\n    def size(self, x):\n        return self.siz[self.root(x)]\n\n\nN, K, L = map(int, input().split())\nroad_uf = Union_Find(N)\ntrain_uf = Union_Find(N)\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    p -= 1\n    q -= 1\n    road_uf.unite(p, q)\n\nfor _ in range(L):\n    r, s = map(int, input().split())\n    r -= 1\n    s -= 1\n    train_uf.unite(r, s)\n\nroots = [''] * N\nfor i in range(N):\n    r = str(road_uf.root(i)) + '-' + str(train_uf.root(i))\n    roots[i] = r\n\ncounts = Counter(roots)\n\nans = [1] * N\nfor i in range(N):\n    r = roots[i]\n    ans[i] = counts[r]\n\nprint(*ans)", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def find(self, x):          #\u89aa\u3092\u51fa\u529b\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def same(self, x, y):       #x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n\n    def size(self, x):          #\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n        return -self.parents[self.find(x)]\n\n    def members(self, x):       #x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\n        root = self.find(x)\n        return {i for i in range(self.n) if self.find(i) == root}\n\n    def roots(self):            #\u89aa\u306e\u8981\u7d20\u4e00\u89a7\n        return {i for i, x in enumerate(self.parents) if x < 0}\n\n    def group_count(self):      #\u30b0\u30eb\u30fc\u30d7\u306e\u500b\u6570\n        return len(self.roots())\n\n    def all_group_members(self):      #\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u4e00\u89a7\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n################\n\nfrom collections import Counter\n\ndef main():\n    N, K, L = map(int, input().split())\n    ufK = UnionFind(N)\n    ufL = UnionFind(N)\n    for i in range(K):\n        a,b = map(int,input().split())\n        ufK.union(a-1, b-1)\n    for i in range(L):\n        a,b = map(int,input().split())\n        ufL.union(a-1, b-1)\n\n    ps=[(ufK.find(i),ufL.find(i)) for i in range(N)]\n    cps = Counter(ps)\n    ret = [0]*N\n    for i in range(N):\n        ret[i] =cps[ps[i]]\n    print(*ret)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import Counter\n\ndef conn(n,m,e):\n    d=dict(list(zip(list(range(1,n+1)),list(range(-1,(-1)*n-1,-1)))))\n    td=defaultdict(lambda:deque([])) #td\u306f\u540c\u5024\u985e\u304c\u30ad\u30fc\u3067\u4e2d\u306e\u5143\u304c\u5024\n    c=1\n    for edge in e:\n        a=edge[0]\n        b=edge[1]\n        da=d[a] #da,db\u306fa,b\u306e\u542b\u307e\u308c\u308b\u540c\u5024\u6d41\u306e\u30e9\u30d9\u30eb\n        db=d[b]\n        if da<0 and db<0:\n            d[a]=c\n            d[b]=c\n            td[c].append(a)\n            td[c].append(b)\n            c+=1\n        elif da>0 and db<0:\n            d[b]=da\n            td[d[a]].append(b)\n        elif da<0 and db>0:\n            d[a]=db\n            td[d[b]].append(a)\n        elif da>0 and db>0 and da!=db:\n            for x in td[db]:\n                d[x]=da\n                td[da].append(x)\n\n    return list(d.values())\n\ndef components(n,k,e):\n    ed=defaultdict(lambda:deque())\n    for edge in e:\n        ed[edge[0]].append(edge[1])\n        ed[edge[1]].append(edge[0])\n    c=0\n    s=[0]*n\n    for i in range(1,n+1):\n        if s[i-1]==0:\n            c+=1\n            stack=deque([i])\n            while stack:\n                w=stack.pop() \n                s[w-1]=c\n                while ed[w]:\n                    wn=ed[w].pop()\n                    if s[wn-1]==0:\n                        s[wn-1]=c\n                        if ed[wn]:\n                            stack.append(w)\n                            w=wn\n    return s\n           \ndef main(n,k,l,e1,e2):\n    d1=components(n,k,e1)\n    d2=components(n,l,e2)\n    p=tuple(zip(iter(d1),iter(d2)))\n    d=Counter(p)\n    # print(d1,d2,d,p)\n    d[(k,l)]=1\n    print((' '.join([str(d[x]) for x in p]))) \n\ndef __starting_point():\n    ssr=sys.stdin.readline\n    n,k,l=list(map(int,ssr().strip().split()))\n    e1=[]\n    e2=[]\n    for _ in range(k):\n        e1.append(tuple(map(int,ssr().strip().split())))\n    for _ in range(l):\n        e2.append(tuple(map(int,ssr().strip().split())))\n    main(n,k,l,e1,e2)\n\n__starting_point()", "from collections import Counter\nn,k,l=map(int,input().split())\ncity1=[i for i in range(n)]\ncity2=[i for i in range(n)]\ndef root(c,x):\n  if x==c[x]:\n    return x\n  else:\n    return root(c,c[x])\ndef union(c,x,y):\n  rx=root(c,x)\n  ry=root(c,y)\n  if rx>ry:\n    c[rx]=ry\n  else:\n    c[ry]=rx\nfor i in range(k):\n  a,b=map(int,input().split())\n  union(city1,a-1,b-1)\nfor i in range(l):\n  a,b=map(int,input().split())\n  union(city2,a-1,b-1)\nr=[]\nfor i in range(n):\n  r.append((root(city1,i),root(city2,i)))\nc=Counter(r)\nfor i in range(n):\n  ans=c[r[i]]\n  if i==n-1:\n    print(ans)\n  else:\n    print(ans,end=' ')", "from collections import Counter\nN,K,L=map(int,input().split())\ndrive = [-1] * N;train = [-1] * N\ndef find(List,x):\n  if List[x] < 0:\n    return x\n  List[x] = find(List,List[x])\n  return List[x]\ndef unite(List,x,y):\n  if find(List,x) != find(List,y):\n    List[find(List,y)] = find(List,x)\nfor i in range(K+L):\n  a, b = map(int,input().split())\n  unite(drive if i < K else train,a-1, b-1)\npair = [(find(drive,i), find(train,i)) for i in range(N)]\nc =Counter(pair)\nprint(*[c[pair[i]] for i in range(N)])", "from collections import deque, Counter\n\nN, K, L = [int(s) for s in input().split()]\nedge_road = [[int(s) - 1 for s in input().split()] for _ in range(K)]\nedge_train = [[int(s) - 1 for s in input().split()] for _ in range(L)]\ngraph_road = [[] for _ in range(N)]\ngraph_train = [[] for _ in range(N)]\n\nfor i, j in edge_road:\n    graph_road[i].append(j)\n    graph_road[j].append(i)\n\nfor i, j in edge_train:\n    graph_train[i].append(j)\n    graph_train[j].append(i)\n\ngroup_road = [0] * N\ngroup_num = 0\n\nvisited = [False]*N\n\nfor i in range(N):\n    if visited[i]:\n        continue\n    dq = deque([i])\n    group_road[i] = group_num\n    visited[i] = True\n    while(dq):\n        search_obj = dq.pop()\n        for candidate_obj in graph_road[search_obj]:\n            if not visited[candidate_obj]:\n                group_road[candidate_obj] = group_num\n                dq.appendleft(candidate_obj)\n                visited[candidate_obj] = True\n    group_num += 1\n\n\ngroup_train = [0] * N\ngroup_num = 0\n\nvisited = [False]*N\n\nfor i in range(N):\n    if visited[i]:\n        continue\n    dq = deque([i])\n    group_train[i] = group_num\n    visited[i] = True\n    while(dq):\n        search_obj = dq.pop()\n        for candidate_obj in graph_train[search_obj]:\n            if not visited[candidate_obj]:\n                group_train[candidate_obj] = group_num\n                dq.appendleft(candidate_obj)\n                visited[candidate_obj] = True\n    group_num += 1\n\ngroup_count = Counter(zip(group_road, group_train))\n\nfor gr, gt in zip(group_road, group_train):\n    print(group_count[(gr, gt)], end=' ')\n"]
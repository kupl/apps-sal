["#  author: ThePonyCoder\n#  created: 23.06.2019, 21:58\n#  filename: f.py\n#  path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py\n\nimport os\n\n# import random\n\n# sys.setrecursionlimit(999999999)\nimport string\n\nfrom math import inf\nfrom functools import lru_cache\n\nif os.getcwd() == 'C:\\\\Users\\\\User\\\\Desktop\\\\python\\\\Prog\\\\CodeForces' \\\n        or os.environ['COMPUTERNAME'] == 'USER145':\n    import pdb\n    \n    import sys\n    \n    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    from pprint import pprint\n    from hypothesis import given, settings\n    from hypothesis import strategies as st\n\n\ndef ri():\n    return [int(i) for i in input().split()]\n\n\ndef to_bits(l):\n    ans = 0\n    for i in l:\n        ans |= (1 << i - 1)\n    return ans\n\n\nuser_masks = [0 for i in range(1 << 10)]\npizzas = [[] for i in range(1 << 10)]\n\n\n@lru_cache()\ndef count_sat_users(mask):\n    ans = 0\n    cmask = mask\n    while cmask:\n        ans += user_masks[cmask]\n        cmask = (cmask - 1) & mask\n    return ans\n\n\ndef main():\n    n, m = ri()\n    for _ in range(n):\n        k, *a = ri()\n        bits = to_bits(a)\n        user_masks[bits] += 1\n    \n    ans = (float(-inf), float(inf), -1, -1)\n    \n    for i in range(m):\n        c, k, *a = ri()\n        bits = to_bits(a)\n        pizzas[bits].append((c, i + 1, bits))  # \u0446\u0435\u043d\u0430, \u043d\u043e\u043c\u0435\u0440, \u043c\u0430\u0441\u043a\u0430\n        pizzas[bits].sort()\n        while len(pizzas[bits]) > 2:\n            pizzas[bits].pop()\n    # pprint(pizzas)\n    \n    for mask_F in range(1 << 9):\n        for mask_S in range(1 << 9):\n            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \\\n                    and mask_F != mask_S:\n                \n                mask = mask_F | mask_S\n                \n                satisfied_users = count_sat_users(mask)\n                \n                f_pizza = next(iter(pizzas[mask_F]))\n                s_pizza = next(iter(pizzas[mask_S]))\n                \n                summary_cost = 0\n                summary_cost += f_pizza[0]\n                summary_cost += s_pizza[0]\n                \n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n                \n                # bruting all masks\n                bmask = mask\n                while bmask:\n                    satisfied_users += user_masks[bmask]\n                    bmask = (bmask - 1) & mask\n            \n            if len(pizzas[mask_F]) == 2:\n                satisfied_users = count_sat_users(mask_F)\n                \n                it = iter(pizzas[mask_F])\n                \n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n            \n            if len(pizzas[mask_S]) == 2:\n                satisfied_users = count_sat_users(mask_S)\n                \n                it = iter(pizzas[mask_S])\n                \n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n    \n    aans = [ans[2],ans[3]]\n    aans.sort()\n    print(*aans, sep=' ')\n\n\nmain()\n", "import sys\n\ndef popcount(i):\n    assert 0 <= i < 0x100000000\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nN, M = list(map(int, sys.stdin.readline().split()))\ntable = [0]*(2**9)\nfor _ in range(N):\n    S = tuple(map(int, sys.stdin.readline().split()))\n    table[sum(2**(a-1) for a in S[1:])] += 1\n\ndp = [0]*(2**9)\nfor s in range(2**9):\n    ppc = popcount(s)\n    res = table[s]\n    t = s&(s-1)\n    for _ in range(2**ppc - 1):\n        res += table[t]\n        t = (t-1)&s\n    dp[s] = res                        \n\ntable = [False]*(2**9)\ncost = [[] for _ in range(2**9)]\nidx = [[] for _ in range(2**9)]\nfor i in range(M):\n    T = tuple(map(int, sys.stdin.readline().split()))\n    x = sum(2**(a-1) for a in T[2:])\n    table[x] = True\n    cost[x].append(T[0])\n    idx[x].append(i+1)\n\nminidx = [cost[x].index(min(cost[x])) if cost[x] else -1 for x in range(2**9)]\nmincost = [10**10]*(2**9)\nmincostidx = [(0, 0) for _ in range(2**9)]\nreachable = [False]*(2**9)\nfor i in range(2**9):\n    if not table[i]:\n        continue\n    for j in range(2**9):\n        if not table[j]:\n            continue\n        reachable[i|j] = True\n        if i != j:\n            mi = min(cost[i])\n            mj = min(cost[j])\n            if mincost[i|j] > mi + mj:\n                mincost[i|j] = mi + mj\n                mincostidx[i|j] = (idx[i][minidx[i]], idx[j][minidx[j]])\nctr = -1\ncandi = []\nfor i in range(2**9):\n    if not reachable[i]:\n        continue\n    if ctr > dp[i]:\n        continue\n    elif ctr == dp[i]:\n        candi.append(i)\n    else:\n        ctr = dp[i]\n        candi = [i]\n\nans = 10**11\nAns = (-1, -1)\nfor c in candi:\n    if table[c] and len(cost[c]) > 1:\n        D = cost[c][:]\n        res = min(D)\n        a = D.index(res)\n        D.remove(res)\n        r = min(D)\n        b = D.index(r)\n        if cost[c][b] != r:\n            b += 1\n        if a == b:\n            b += 1\n        res += r\n        if ans > res:\n            ans = res\n            Ans = (idx[c][a], idx[c][b])\n    if ans > mincost[c]:\n        ans = mincost[c]\n        Ans = mincostidx[c]\nprint(*Ans)\n", "from sys import stdin, stdout\nimport itertools\n\nn, m = list(map(int, stdin.readline().split()))\n\nfriends = [0]*512\nexists = [0]*512\ncosts_min = [0]*512\ncosts_2 = [0]*512\nindex_min = [0]*512\nindex_2 = [0]*512\n\n\ncount_friends = [0]*512\n\ndef top_to_idx(top):\n    ans = 0\n    for t in top:\n        ans += 1 << (t-1)\n    return ans\n\ndef idx_to_top(idx):\n    ans = []\n    for i in range(9):\n        if idx & (1 << i):\n            ans.append(i+1)\n    return ans\n\nfor i in range(n):\n    top = list(map(int, stdin.readline().split()))[1:]\n    friends[top_to_idx(top)] += 1\n\n#print(friends)\n\ndef subset(i, j):\n    for s in range(9):\n        if i & (1 << s) and not (j & (1 << s)):\n            return False\n    return True\n\nfor i in range(512):\n    for j in range(512):\n        if subset(j, i):\n            count_friends[i] += friends[j]\n\n#print(count_friends)\n\nfor i in range(m):\n    pizza = list(map(int, stdin.readline().split()))\n    top_idx = top_to_idx(pizza[2:])\n    cost = pizza[0]\n    exists[top_idx] = True\n    if costs_min[top_idx] == 0 or cost < costs_min[top_idx]:\n        costs_2[top_idx] = costs_min[top_idx]\n        index_2[top_idx] = index_min[top_idx]\n        costs_min[top_idx] = cost\n        index_min[top_idx] = i+1\n    elif costs_2[top_idx] == 0 or cost < costs_2[top_idx]:\n        costs_2[top_idx] = cost\n        index_2[top_idx] = i+1\n\nbest_matches = -1\nbest_cost = -1\nbest = None\nfor p1 in range(512):\n    for p2 in range(p1, 512):\n        if not exists[p1] or not exists[p2]:\n            continue\n        if p1 == p2 and index_2[p1] == 0:\n            continue\n        p = p1 | p2\n    #    print(idx_to_top(p1 | p2))\n        matches = count_friends[p]\n     #   print(matches)\n        cost = costs_min[p1] + costs_min[p2] if p1 != p2 else costs_min[p1] + costs_2[p2]\n        if best_matches == -1 or matches > best_matches or (matches == best_matches and cost < best_cost):\n            best = (index_min[p1], index_min[p2]) if p1 != p2 else (index_min[p1], index_2[p2])\n            best_matches = matches\n            best_cost = cost\n\n#print(best_matches)\n#print(best_cost)\nprint(best[0], best[1])\n    \n", "import  sys\nimport  math\n#input=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\nI=lambda : list(map(int,input().split()))\nma =int(10000000000000000)\nn,m=map(int,input().split())\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\nfor i in range(n):\n    b=I()\n    x=int(0)\n    for j in range(1,b[0]+1):\n        b[j]-=1\n        x|=(1<<b[j])\n    fr[x]+=1\n\nmin1=int(ma)\nmax1=int(0)\nind,ind1=int(),int()\nfor i in range(m):\n    b=I()\n    x=int(0)\n    for j in range(2,b[1]+2):\n        b[j]-=1\n        x|=(1<<b[j])\n    if a[x]!=ma:\n        if fr[x]>max1:\n            max1=fr[x]\n            min1=a[x]+b[0]\n            ind=pos[x]\n            ind1=i+1\n        elif fr[x]==max1:\n            if b[0]+a[x]<min1:\n                min1=b[0]+a[x]\n                ind=pos[x]\n                ind1=i+1\n    if a[x]>b[0]:\n        a[x]=b[0]\n        pos[x]=i+1\n\n\nfor i in range(1,512):\n    for j in range(1,512):\n        if i==j or  a[i]==ma or a[j]==ma:\n            continue\n        k=i|j\n        cnt=int(0)\n        while k>0:\n            cnt+=fr[k]\n            k=(k-1)&(i|j)\n        if cnt>max1:\n            ind=pos[i]\n            ind1=pos[j]\n            max1=cnt\n            min1=a[i]+a[j]\n        if cnt==max1:\n            if a[i]+a[j]<min1:\n                ind=pos[i]\n                ind1=pos[j]\n            min1=min(min1,a[i]+a[j])\n\nprint(ind,ind1,sep=\" \")", "import  sys\nimport  math\ninput=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\nI=lambda : list(map(int,input().split()))\nma =int(10000000000000000)\nn,m=map(int,input().split())\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\nfor i in range(n):\n    b=I()\n    x=int(0)\n    for j in range(1,b[0]+1):\n        b[j]-=1\n        x|=(1<<b[j])\n    fr[x]+=1\n\nmin1=int(ma)\nmax1=int(0)\nind,ind1=int(),int()\nfor i in range(m):\n    b=I()\n    x=int(0)\n    for j in range(2,b[1]+2):\n        b[j]-=1\n        x|=(1<<b[j])\n    if a[x]!=ma:\n        if fr[x]>max1:\n            max1=fr[x]\n            min1=a[x]+b[0]\n            ind=pos[x]\n            ind1=i+1\n        elif fr[x]==max1:\n            if b[0]+a[x]<min1:\n                min1=b[0]+a[x]\n                ind=pos[x]\n                ind1=i+1\n    if a[x]>b[0]:\n        a[x]=b[0]\n        pos[x]=i+1\n\n\nfor i in range(1,512):\n    for j in range(1,512):\n        if i==j or  a[i]==ma or a[j]==ma:\n            continue\n        k=i|j\n        cnt=int(0)\n        while k>0:\n            cnt+=fr[k]\n            k=(k-1)&(i|j)\n        if cnt>max1:\n            ind=pos[i]\n            ind1=pos[j]\n            max1=cnt\n            min1=a[i]+a[j]\n        if cnt==max1:\n            if a[i]+a[j]<min1:\n                ind=pos[i]\n                ind1=pos[j]\n            min1=min(min1,a[i]+a[j])\n\nprint(ind,ind1,sep=\" \")", "import  sys\nimport  math\ninput=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\n#I=lambda : list(map(int,input().split()))\nma =int(10000000000000000)\nn,m=map(int,input().split())\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\nfor i in range(n):\n    b=list(map(int,input().split()))\n    x=int(0)\n    for j in range(1,b[0]+1):\n        b[j]-=1\n        x|=(1<<b[j])\n    fr[x]+=1\n\nmin1=int(ma)\nmax1=int(0)\nind,ind1=int(),int()\nfor i in range(m):\n    b=list(map(int,input().split()))\n    x=int(0)\n    for j in range(2,b[1]+2):\n        b[j]-=1\n        x|=(1<<b[j])\n    if a[x]!=ma:\n        if fr[x]>max1:\n            max1=fr[x]\n            min1=a[x]+b[0]\n            ind=pos[x]\n            ind1=i+1\n        elif fr[x]==max1:\n            if b[0]+a[x]<min1:\n                min1=b[0]+a[x]\n                ind=pos[x]\n                ind1=i+1\n    if a[x]>b[0]:\n        a[x]=b[0]\n        pos[x]=i+1\n\n\nfor i in range(1,512):\n    for j in range(1,512):\n        if i==j or  a[i]==ma or a[j]==ma:\n            continue\n        k=i|j\n        cnt=int(0)\n        while k>0:\n            cnt+=fr[k]\n            k=(k-1)&(i|j)\n        if cnt>max1:\n            ind=pos[i]\n            ind1=pos[j]\n            max1=cnt\n            min1=a[i]+a[j]\n        if cnt==max1:\n            if a[i]+a[j]<min1:\n                ind=pos[i]\n                ind1=pos[j]\n            min1=min(min1,a[i]+a[j])\n\nprint(ind,ind1,sep=\" \")"]
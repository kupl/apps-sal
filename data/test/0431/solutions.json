["n, m = list(map(int, input().split()))\nm += 2\nl = []\ndo = False\nfor i in range(n):\n\ts = input().strip()\n\tif s.find('1') != -1 or do:\n\t\tdo = True\n\t\tl.append(s)\nn = len(l)\nif n == 0:\n\tprint(0)\n\treturn\n\n\ndp = []\nfor i in range(n):\n\tdp.append([None] * 2)\n\nfor i in range(n):\n\tR = 0\n\tfor j in range(m):\n\t\tif l[i][j] == '1':\n\t\t\tR = j\n\tL = m - 1\n\tfor j in range(m - 1, -1, -1):\n\t\tif l[i][j] == '1':\n\t\t\tL = j\n\tif i == 0:\n\t\tdp[0][0] = R\n\t\tdp[0][1] = (m - 1 - L)\n\telse:\n\t\tdp[i][0] = min(dp[i - 1][0] + 2 * R, dp[i - 1][1] + (m - 1)) + 1\n\t\tdp[i][1] = min(dp[i - 1][0] + (m - 1), dp[i - 1][1] + 2 * (m - 1 - L)) + 1\n# print(dp)\nprint(dp[-1][0])\n", "def variant(cur):\n    nonlocal minv\n    if len(cur) < len(rooms):\n        variant(cur + [0])\n        variant(cur + [1])\n    else:\n        curpos = 0\n        time = 0\n        for i in range(len(rooms) - 1):\n            if curpos != cur[i]:\n                time += m + 1\n                curpos = cur[i]\n            else:\n                time += 2 * rooms[i][curpos]\n            if i != 0:\n                time += 1\n        time += rooms[-1][curpos] + 1\n        if len(rooms) == 1:\n            time -= 1\n        minv = min(minv, time)\n\n\n\nn, m = map(int, input().split())\nminv = 1000000000\nrooms = []\nstopdel = False\n\nfor i in range(n):\n    line = input()\n    a = 0\n    for j in range(m + 2):\n        if line[j] == '1':\n            a = m + 1 - j\n            break\n    b = 0\n    for j in range(m + 1, -1, -1):\n        if line[j] == '1':\n            b = j\n            break\n    if a != 0 or b != 0 or stopdel:\n        rooms.append((b, a))\n        stopdel = True\n\nrooms = rooms[::-1]\n\nif not rooms:\n    print('0')\nelse:\n    variant([])\n    print(minv)", "def sol():\n\n    n, m = map(int, input().split(' '))\n\n    mapp = []\n\n    for a in range(n):\n        s = list(input())\n        s = [c == \"1\" for c in s]\n        mapp.insert(0, s[1:-1])\n\n    res = None\n    #print(mapp)\n\n    empty_floor = n\n    while True:\n        litup = False\n        for x in mapp[empty_floor-1]:\n            if x:\n                litup = True\n                break\n        if not litup:\n            empty_floor -= 1\n        else:\n            break\n        if empty_floor < 0:\n            break\n\n    if empty_floor <= 0:\n        return 0\n\n    #print(\"empty_floor\", empty_floor)\n\n    for comb in range(2**(empty_floor-1)):\n        temp = 0\n        c = bin(comb)[2:]\n        c = \"0\" * ((empty_floor-1)-len(c)) + c\n        c = list(c)\n        c = [x == \"1\" for x in c]\n\n        #print(\"c\", c)\n\n        last = False # start from left\n        if empty_floor != 1:\n            for i, x in enumerate(c):\n                if x != last:\n                    temp += m+1 + 1\n                else:\n                    f = None\n                    #print(i)\n                    #print(\"last\", last)\n                    for j, y in enumerate(mapp[i]):\n                        if y:\n                            f = j\n                            if last:\n                                break\n                    if f is None:\n                        temp += 1\n                    else:\n                        if last:\n                            temp += 2 * (m - f) + 1\n                        else:\n                            temp += 2 * (f + 1) + 1\n                last = x\n\n\n        #final floor:\n        f = None\n        for j, y in enumerate(mapp[empty_floor-1]):\n            if y:\n                f = j\n                if last:\n                    break\n        if f is not None:\n            #print(f, \"f\")\n            if c[-1]:\n                temp += m - f\n            else:\n                temp += f + 1\n\n        if res is None:\n            res = temp\n        res = min(res, temp)\n\n        #print(c, temp)\n\n\n    return res\n\nprint(sol())", "n, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(input())\n# print(a)\nl = 0\nr = INF = 100000\nh = 0\nwhile h < n:\n    if a[h] == '0' * (m + 2):\n        h += 1\n    else:\n        break\nif h != n:\n    for i in range(n - 1, h, -1):\n        x = INF\n        y = 0\n        for j in range(m + 2):\n            if a[i][j] == '1':\n                x = min(x, j)\n                y = max(y, j)\n        if x != INF:\n            ll = min(l + y * 2, r + m + 1)\n            rr = min(l + m + 1, r + (m + 1 - x) * 2)\n            l = ll\n            r = rr\n        # print(i, l, r)\n    x = INF\n    y = 0\n    for j in range(m + 2):\n        if a[h][j] == '1':\n            x = min(x, j)\n            y = max(y, j)\n    ans = min(l + y, r + (m + 1 - x))\n    print(ans + n - 1 - h)\nelse:\n    print(0)", "def minimum(floor,j,s,n,m):\n\tif(s==[]):\n\t\treturn 0\n\tif(floor==0):\n\t\tif(j==0):\n\t\t\treturn s[floor].rfind('1')\n\t\telse:\n\t\t\treturn m+1-s[floor].find('1')\n\tif(j==0):\n\t\treturn min(2*s[floor].rfind('1')+1+minimum(floor-1,0,s,n,m),m+2+minimum(floor-1,m+1,s,n,m))\n\telse:\n\t\treturn min(2*(m+1-s[floor].find('1'))+1+minimum(floor-1,m+1,s,n,m),m+2+minimum(floor-1,0,s,n,m))\n\ninp=input().split()\nn=int(inp[0])\nm=int(inp[1])\ns=[]\nfor i in range(n):\n\ts.append(input())\ncounter=0\nwhile(s!=[]):\n\tif(s[0].find('1')==-1):\n\t\tcounter+=1\n\t\ts.pop(0)\n\telse:\n\t\tbreak\ncounter2=0\ns2=[]\nfor val in s:\n\tif(val.find('1')==-1):\n\t\tcounter2+=1\n\telse:\n\t\ts2.append(val)\n\nprint(minimum(n-1-counter-counter2,0,s2,n,m)+counter2)", "n, m = list(map(int, input().split()))\nL = [list(input()) for i in range(n)]\nlight_floors = [n - i - 1 for i in range(n) if \"1\" in L[i]]\nif len(light_floors) == 0:\n    print(0)\n    return\nlimit = max(light_floors)\n\ndef rec(i, lst):\n    if i == limit:\n        # first: left\n        # print(list(reversed(L[-1])))\n        if \"1\" in L[-1]:\n            cnt = m + 2 - list(reversed(L[-1])).index(\"1\") - 1\n        else:\n            cnt = 0\n        now = cnt\n        for j, l in enumerate(lst):\n            if l == \"l\":\n                cnt += now\n                cnt += 1\n                if \"1\" in L[-1 - j - 1]:\n                    next_pos = (m + 2 - list(reversed(L[-1 - j - 1])).index(\"1\") - 1)\n                else:\n                    next_pos = 0\n                cnt += next_pos\n                now = next_pos\n            else:\n                cnt += (m + 2 - now - 1)\n                cnt += 1\n                if \"1\" in L[-1 - j - 1]:\n                    next_pos = L[-1 - j - 1].index(\"1\")\n                else:\n                    next_pos = m + 2 - 1\n                cnt += (m + 2 - next_pos - 1)\n                now = next_pos\n        return cnt\n\n    return min(rec(i + 1, lst + [\"l\"]), rec(i + 1, lst + [\"r\"]))\n\n\nprint(rec(0, []))\n", "import itertools\n\nn, m = list(map(int, input().split()))\n\nfloors = []\nmax_lit = -1\nfor floor_n in range(n-1, -1, -1):\n    cur_floor = input()\n    floors.insert(0, cur_floor)\n    if max_lit == -1 and any(c == '1' for c in cur_floor):\n        max_lit = floor_n + 1\n\nif max_lit == -1:\n    print('0')\n    return\n\n\ndef calc_path(path):\n    left = True\n    result = 0\n    for floor in range(max_lit):\n        switch_stairs = path[floor]\n        if left:\n            pos = floors[floor].rfind('1')\n            dist = 0 if pos == -1 else pos\n        else:\n            pos = floors[floor].find('1')\n            dist = 0 if pos == -1 else m + 1 - pos\n        is_last = floor == max_lit-1\n        result += dist\n        if switch_stairs:\n            if not is_last:\n                result += m + 1 - dist\n            left = not left\n        else:\n            if not is_last:\n                result += dist\n        if not is_last:\n            result += 1\n    return result\n\n\nmin_v = -1\n\nfor p in itertools.product([False, True], repeat=max_lit):\n    v = calc_path(p)\n    if min_v == -1 or min_v > v:\n        min_v = v\n\nprint(min_v)\n", "def booly(s):\n    return bool(int(s))\n\nn, m = list(map(int, input().split()));\n\nnothing = \"0\"*(m+2);\n\na = [];\nfor i in range(n):\n    a.append(input())\n\nfor i in range(n):\n    if a[i] != nothing:\n        break;\n\na = a[i:]\na.reverse();\n\nn = len(a)\n\n#print(a)\n\nleftA = [i.find(\"1\") for i in a]\nrightA = [i.rfind(\"1\") for i in a]\n\nfor i in range(n):\n    if leftA[i] == -1:\n        leftA[i] = m+1\n    if rightA[i] == -1:\n        rightA[i] = 0\n\n#print(leftA, rightA);\n\nif len(a) == 1:\n    print( rightA[0])\n    return;\n\nleft = [None]*(n+1)\nright = [None]*(n+1)\n\nleft[0] = rightA[0]*2\nright[0] = m+1\n\nfor i in range(1,n-1):\n    left[i] = 1 + min(left[i-1] + rightA[i]*2, right[i-1] + m+1)\n    right[i] = 1 + min(right[i-1] + (m+2-1-leftA[i])*2, left[i-1] + m+1)\n\n#print(left, right)\n\nprint((min(1 +\n    left[n-2] +\n    rightA[n-1],\n    1 + right[n-2]\n    + (m+2 -1 -leftA[n-1]))));\n\n", "ans = 0\nn, m = map(int, input().split())\narr = [\"\"] + [input() for i in range(n)][::-1]\ndp = [[-1, 10 ** 9, 0] for i in range(n + 1)]\nz = 0\nfor i in range(1, 1 + n):\n    z += arr[i].count(\"1\")\nfor i in range(1, n + 1):\n    l = arr[i].find(\"1\")\n    r = arr[i].rfind(\"1\")\n    z -= arr[i].count(\"1\")\n    if l != -1:\n        dp[i][0] = min(dp[i - 1][0] + 2 * r, dp[i - 1][1] + m + 1) + 1\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1] + 2 * (m + 1 - l)) + 1\n        dp[i][2] = min(dp[i - 1][0] + r, dp[i - 1][1] + (m + 1 - l)) + 1\n    else:\n        dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + m + 1) + 1\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1]) + 1\n        \n    #print(dp[i], l, r, arr[i][l], arr[i])\n    #print(z, i)\n    if z == 0:\n        ans = dp[i][2]\n        break\nprint(ans)", "def gen(pr, n):\n    nonlocal seq\n    if len(pr) >= n:\n        seq.append(pr)\n    else:\n        gen(pr + '0', n)\n        gen(pr + '1', n)\n\n\nn, m = map(int, input().split())\nmatrix = []\npref = [[] for i in range(n)]\nseq = []\nfor i in range(n):\n    matrix.append(input()[1:m + 1])\n    j = m - 1\n    while j >= 0 and matrix[i][j] == '0':\n        j -= 1\n    tmp1 = (j + 1) * 2\n    j = 0\n    while j < m and matrix[i][j] == '0':\n        j += 1\n    tmp2 = (m - j) * 2\n    pref[n - i - 1] = [tmp1, tmp2]\ni = n - 1\nwhile i >= 0 and pref[i] == [0, 0]:\n    i -= 1\ngen('0', i + 1)\nn = i + 1\nmi = float('inf')\nfor i in seq:\n    res = 0\n    for j in range(n - 1):\n        if i[j] == i[j + 1]:\n            res += pref[j][int(i[j])] + 1\n        else:\n            res += m + 2\n    res += pref[n - 1][int(i[n - 1])] // 2\n    if res < mi:\n        mi = res\nprint(mi)", "n,m = map(int, input().split())\nh = []\nl = []\nr = []\nlast = -1\nfor i in range(n):\n    s = input()\n    h.append(s)\ni=0\nfor s in reversed(h):\n    lp, rp = m+1, 0\n    for j in range(len(s)):\n        let = s[j]\n        if let == '1' and lp == m+1:\n            lp = j\n        if let == '1':\n            rp = j\n    l.append(lp)\n    r.append(rp)\n    if r[i] != 0 or l[i] != m+1:\n        last = i\n    i+=1\n        \n        \ndp = [[2*r[0], m + 1]] \nfor i in range(1,last):\n    prev = dp[-1]\n    ml = min(prev[0] + 2*r[i], prev[1] + m + 1) + 1\n    rl = min(prev[1] + 2*(m+1 - l[i]), prev[0] + m+1) + 1\n    dp.append([ml, rl])\n    \nif last == 0:\n    ans = r[0]\nelif last == -1:\n    ans = 0\nelse:\n    ans = min(dp[-1][0] + r[last] + 1, dp[-1][1] + (m +1 - l[last]) + 1)\n\nprint(ans)", "import sys\n\ndef main():\n    n,m = map(int,sys.stdin.readline().split())\n    m+=2\n    z = []\n    for i in range(n):\n        z.append(sys.stdin.readline().rstrip())\n\n    ans = 0\n    y = n-1\n    x = 0\n    q = [[x,y,ans]]\n    for i in range(n-1,-1,-1):\n        first =-1\n        last = -1\n        for j in range(m):\n            if z[i][j] == '1':\n                if first == -1:\n                    first = j\n                last = j\n        if first == -1 and last == -1:\n            continue\n        if i == n-1:\n            q[0] = [last,n-1,last]\n            continue\n        if first == last :\n            for t in q:\n                t[2]+= min(t[0]+first, m-1-t[0]+m-1-first) + t[1]-i\n                t[0] = first\n                t[1] = i\n            continue\n        size = len(q)\n        for s in range(size):\n            t = q[s]\n            q.append([last,i,t[2]+t[0]+last+t[1]-i])\n            t[2]+= m-1-t[0]+m-1-first + t[1] - i\n            t[0] = first\n            t[1] = i\n            q[s] = t\n    ans = q[0][2]\n    for i in range(len(q)):\n        if q[i][2] < ans:\n            ans = q[i][2]\n\n    print(ans)\n\n\nmain()", "import sys\n\ninf = float('inf')\nans = inf\n\ndef solve():\n    nonlocal ans\n    n, m = map(int, input().split())\n    room = [[int(i) for i in input()] for j in range(n)]\n    room.reverse()\n\n    exits = [False] * n\n\n    for i in range(n - 1, -1, -1):\n        if any(room[i]):\n            exits[i] = True\n\n        if i - 1 >= 0:\n            exits[i - 1] |= exits[i]\n\n    # print(exits)\n\n    if not exits[0]:\n        ans = 0\n    else:\n        dfs(0, n, m, room, exits, 0, 0)\n\n    print(ans)\n\ndef dfs(floor, n, m, room, exits, pos, move):\n    nonlocal ans\n\n    k = -1\n\n    if pos == 0:\n        for j in range(m + 1, -1, -1):\n            if room[floor][j]:\n                k = j\n                break\n        else:\n            k = 0\n    else:\n        for j in range(0, m + 2):\n            if room[floor][j]:\n                k = j\n                break\n        else:\n            k = m + 1\n\n    move += abs(k - pos)\n\n    if floor == n - 1 or not exits[floor + 1]:\n        ans = min(ans, move)\n        return\n    else:\n        dfs(floor + 1, n, m, room, exits, 0, move + k + 1)\n        dfs(floor + 1, n, m, room, exits, m + 1, move + m + 1 - k + 1)\n\ndef __starting_point():\n    solve()\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nfrom operator import itemgetter\n\ndef explore_floor(floor, light, from_, to, is_last_floor):\n    \"\"\"from_, to is one of 'l' or 'r'\"\"\"\n    if from_ != to:\n        return len(floor) - 1\n    else:\n        if light == 0:\n            return 0\n        else:\n            mul = 1 if is_last_floor else 2\n            if from_ == 'l':\n                indx = floor.rindex('1')\n                return indx * mul\n            else:\n                indx = floor.index('1')\n                return (len(floor) - indx - 1) * mul\n\ndef run_dp(n, m, floors, lights):\n    dp_table = [[10 ** 10] * (n+1) for __ in range(4) ]\n    dp_table[0][0] = -1\n    dp_table[1][0] = 10 ** 10\n    dp_table[2][0] = 10 ** 10\n    dp_table[3][0] = 10 ** 10\n    for indx in range(n):\n        dp_table[0][indx + 1] = min(dp_table[2][indx], dp_table[0][indx]) + explore_floor(floors[indx], lights[indx], 'l', 'l', indx == n-1) + 1\n        dp_table[1][indx + 1] = min(dp_table[2][indx], dp_table[0][indx]) + explore_floor(floors[indx], lights[indx], 'l', 'r', indx == n-1) + 1\n        dp_table[2][indx + 1] = min(dp_table[1][indx], dp_table[3][indx]) + explore_floor(floors[indx], lights[indx], 'r', 'l', indx == n-1) + 1\n        dp_table[3][indx + 1] = min(dp_table[1][indx], dp_table[3][indx]) + explore_floor(floors[indx], lights[indx], 'r', 'r', indx == n-1) + 1\n    return dp_table\n\ndef get_virtual_max_floor(lights):\n    n = len(lights)\n    cnt = 0\n    for val in reversed(list([elem == 0 for elem in lights])):\n        if val:\n            cnt += 1\n        else:\n            break\n    return n - cnt\n\ndef main():\n    n, m = list(map(int, sys.stdin.readline().split()))\n    inp = sys.stdin.read().rstrip()\n    floors = list(reversed(inp.split(\"\\n\")))\n    assert len(floors) == n\n    lights = list([sum(map(int, floor)) for floor in floors])\n    assert len(lights) == n\n    virtual_n = get_virtual_max_floor(lights)\n    #sys.stderr.write(\"{}\\n\".format(lights))\n    #sys.stderr.write(\"{}\\n\".format(virtual_n))\n    if virtual_n == 0:\n        print(0)\n        return\n    dp_table = run_dp(virtual_n, m, floors, lights)\n    #sys.stderr.write(\"{}\\n\".format(dp_table))\n    print(min([dp_table[indx][virtual_n] for indx in range(4)]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def simulate(n, m, first, last, mask):\n    pos = 'left'\n    time = 0\n\n    for floor in range(n - 1):\n        action = mask & 1\n        mask >>= 1\n\n        if pos == 'left':\n            if action == 0:\n                time += 2 * last[floor]\n            else:\n                time += m + 1\n                pos = 'right'\n        else:\n            if action == 0:\n                time += 2 * (m + 1 - first[floor])\n            else:\n                time += m + 1\n                pos = 'left'\n\n        time += 1\n\n    if pos == 'left':\n        time += last[n - 1]\n    else:\n        time += m + 1 - first[n - 1]\n\n    return time\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n\n    building = []\n    for i in range(n):\n        building.append(list(map(int, input())))\n\n    i_max = None\n    for i in range(n):\n        if any(x == 1 for x in building[i]):\n            i_max = i\n            break\n\n    if i_max is None:\n        i_max = n\n    n = n - i_max\n\n    if n == 0:\n        print(0)\n        return\n\n    building = building[::-1]\n    building = building[:n]\n\n    first = [m + 1] * n\n    last = [0] * n\n\n    for i in range(n):\n        for j in range(m + 2):\n            if building[i][j] == 1:\n                if first[i] == m + 1:\n                    first[i] = j\n                last[i] = j\n\n    min_time = 10 * ((m + 1) * n + n)\n    for mask in range(2 ** (n - 1)):\n        min_time = min(min_time, simulate(n, m, first, last, mask))\n\n    print(min_time)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import dropwhile\n\n\nn, m = list(map(int, input().split()))\nm += 2\n\np = list(dropwhile(lambda line: '1' not in line, (input() for i in range(n))))\np.reverse()\naddition = len(p) - 1\np = list([line for line in p if '1' in line])\nn = len(p)\n\nif n == 0:\n    print(0)\n    return\n\nleft = [line.find('1') for line in p]\nright = [line.rfind('1') for line in p]\n\nans = float('inf')\nfor mask in range(2 ** n):\n    cur_res = 0\n    prev = 1\n    for i in range(n):\n        go_left = mask & (1 << i)\n        if go_left and prev:\n            cur_res += 2 * right[i]\n        elif (go_left and not prev) or (not go_left and prev):\n            cur_res += m - 1\n        elif not go_left and not go_left:\n            cur_res += 2 * (m - 1 - left[i])\n        if i == n - 1:\n            if go_left and prev:\n                cur_res -= right[i]\n            elif not go_left and not prev:\n                cur_res -= m - 1 - left[i]\n            elif go_left and not prev:\n                cur_res -= left[i]\n            elif not go_left and prev:\n                cur_res -= m - 1 - right[i]\n        prev = go_left\n    ans = min(ans, cur_res)\n\nprint(ans + addition)\n", "def coun(pref):\n    now = 0\n    for i in range(n):\n        pos = pref[i]\n        if pos == 'l':\n            if i < n - 1 and sum(check[(i + 1):]) > 0:\n                now += 1\n                if \"1\" in mat[i]:\n                    if pref[i + 1] == \"r\":\n                        now += (m + 1)\n                    else:\n                        now += (2 * mat[i].rfind(\"1\"))\n                else:\n                    if pref[i + 1] == 'r':\n                        now += (m + 1)\n            else:\n                if \"1\" in mat[i]:\n                    now += mat[i].rfind(\"1\")\n        else:\n            if i < n - 1 and sum(check[(i + 1):]) > 0:\n                now += 1\n                if \"1\" in mat[i]:\n                    if pref[i + 1] == \"l\":\n                        now += (m + 1)\n                    else:\n                        now += (2 * (m + 1 - mat[i].find(\"1\")))\n                else:\n                    if pref[i + 1] == 'l':\n                        now += (m + 1)\n            else:\n                if \"1\" in mat[i]:\n                    now += (m + 1 - mat[i].find(\"1\"))\n    return now\ndef gen(pref):\n    nonlocal ans\n    if len(pref) == n:\n        ans = min(ans, coun(pref))\n        return\n    gen(pref + \"l\")\n    gen(pref + \"r\")\nn, m = map(int, input().split())\nmat = [0] * n\nfor i in range(n):\n    mat[i] = input()\nmat.reverse()\ncheck = [0] * n\nfor i in range(n):\n    check[i] = mat[i].count(\"1\")\nans = 1000000000\ngen(\"l\")\nprint(ans)", "n, m = map(int, input().split())\na = [input() for i in range(n)]\ni = 0\nwhile i < n and a[i] == '0' * (m + 2): i += 1\na = a[i:]\nn = len(a)\ndp = [[10 ** 5, 10 ** 5] for i in range(n)]\nfor i in range(n):\n    l, r = a[i].find('1'), a[i].rfind('1')\n    if l == r == -1: l, r = m + 1, 0\n    if i == 0:\n        dp[0] = [r, m + 1 - l]\n    else:\n        dp[i][0] = min(dp[i - 1][0] + 2 * r, dp[i - 1][1] + (m + 1)) + 1\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1] + 2 * (m + 1 - l)) + 1\nans = dp[-1][0] if dp else 0\nprint(ans)", "from sys import stdin as fin\n# fin = open(\"cfr417b.in\", \"r\")\n\ndef f(i, csum, csl=True):\n    nonlocal num_f, l_a, r_a, minv\n    l, r = l_a[i], r_a[i]\n    if i == num_f:\n        csum += r if csl else l\n        minv = min(minv, csum)\n    else:\n        f(i + 1, csum + m + 2, not csl)\n        f(i + 1, csum + (r if csl else l) * 2 + 1, csl)\n        # print(num_f)\n\nn, m = list(map(int, fin.readline().split()))\narr = [list(int(sym) for sym in fin.readline().strip()) for i in range(n)]\ncsl = True\ncnt = 0\n# print(arr)\nborder = 0\nfor i in range(n):\n    if 1 in arr[i]:\n        break\n    else:\n        border += 1\nl_a, r_a = [], []\nnum_f = -1\nminv = float('inf')\nfor i in range(n - 1, border - 1, -1):\n    if 1 in arr[i]:\n        l = arr[i].index(1)\n        r = list(reversed(arr[i])).index(1)\n        l = (m + 2 - l - 1)\n        r = (m + 2 - r - 1)\n    else:\n        l = r = 0\n    # print(l, r, m + 2 - l - 1, csl)\n    l_a.append(l)\n    r_a.append(r)\n    num_f += 1\n    continue\nif num_f > -1:\n    f(0, 0)\n    print(minv)\nelse:\n    print(0)\n", "INF = float('inf')\n\ndef solve(grid, n, m):\n    # print('\\n'.join(map(str, grid)))\n\n    dp = [[INF for _ in range(2)] for _ in range(n)]\n\n    dp[0][0] = -1\n    dp[0][1] = INF\n\n    for i in range(1, n):\n        occur = [j for j in range(m+2) if grid[i-1][j] == '1']\n\n        if not occur:\n            dp[i][0] = min(dp[i][0], dp[i-1][0] + 1)\n            dp[i][0] = min(dp[i][0], dp[i-1][1] + (m + 2))\n\n            dp[i][1] = min(dp[i][1], dp[i-1][0] + (m + 2))\n            dp[i][1] = min(dp[i][1], dp[i-1][1] + 1)\n            continue\n\n        dp[i][0] = min(dp[i][0], dp[i-1][0] + (2 * max(occur)) + 1)\n        dp[i][0] = min(dp[i][0], dp[i-1][1] + (m + 2))\n\n        dp[i][1] = min(dp[i][1], dp[i-1][0] + (m + 2))\n        dp[i][1] = min(dp[i][1], dp[i-1][1] + (2 * (m + 2 - min(occur) - 1) + 1))\n\n    # print('\\n'.join(map(str, dp)))\n\n    occur = [j for j in range(m+2) if grid[n-1][j] == '1']\n\n    return min(dp[n-1][0] + max(occur) + 1, dp[n-1][1] + (m + 2 - min(occur)))\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n\n    grid = [input() for _ in range(n)]\n    grid.reverse()\n\n    n_real = -1\n    for i in range(n-1, -1, -1):\n        if '1' in grid[i]:\n            n_real = i\n            break\n\n    if n_real == -1:\n        print(0)\n    else:\n        print(solve(grid[:n_real+1], n_real+1, m))\n\n__starting_point()", "n,m = list(map(int, input().split()))\ninf = 10 ** 10\ndp = [[inf, inf] for i in range(n)]\na = []\nlast = -1\nfor i in range(n):\n    tmp = input()\n    tmp1 = []\n    for j in range(len(tmp)):\n        if tmp[j] == \"1\":\n            tmp1.append(1)\n            if last == -1:\n                last = n - i - 1\n        else:\n            tmp1.append(0)\n    a.append(tmp1)\na = a[::-1]\nleft = [-1] * n\nright = [-1] * n\nfor i in range(n):\n    for j in range(m + 2):\n        if a[i][j] and left[i] == -1:\n            left[i] = j\n        if a[i][j]:\n            right[i] = j\nif last == -1:\n    print(0)\n    return\nif last == 0:\n    print(right[0])\n    return\n            \ndp[0][0] = max(0, right[0] * 2)\ndp[0][1] = m + 1\nfor i in range(1,last):\n    if right[i] != - 1:\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1 + 2 * right[i])\n    else:\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1)\n    dp[i][0] = min(dp[i][0], dp[i - 1][1] + m + 2)\n    if left[i] != - 1:\n        dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1 + (m + 1 - left[i]) * 2)\n    else:\n        dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1)\n    dp[i][1] = min(dp[i][1], dp[i - 1][0] + m + 2)\n    \nlf,rf = inf,inf\nif right[last] != -1:\n    lf = dp[last - 1][0] + 1 + right[last]\nelse:\n    lf = dp[last - 1][0]  + 1\nlf = min(lf, dp[last - 1][1] + m + 2)\n\nif left[last] != -1:\n    rf = dp[last - 1][1] + 1 + (m + 1 - left[last])\nelse:\n    rf = dp[last - 1][1] + 1\nrf = min(rf, dp[last - 1][0] + m + 2)\nprint(min(lf,rf))\n\n\n    \n", "import sys\n\ninf = float('inf')\nans = inf\n\ndef solve():\n    n, m = map(int, input().split())\n    s = [None] * n\n    for i in range(n - 1, -1, -1):\n        s[i] = [int(j) for j in input()]\n\n    e = [any(si) for si in s]\n    es = e[:] + [False]\n\n    for i in range(n - 1, -1, -1):\n        es[i] |= es[i + 1]\n\n    # print(es)\n\n    if not es[0]:\n        print(0)\n    elif es[0] and (not es[1]):\n        k = -1\n\n        for j in range(m, 0, -1):\n            if s[0][j]:\n                k = j\n                break\n\n        print(k)\n    else:\n        lim = 0\n\n        for i in range(n + 1):\n            if not es[i]:\n                lim = i - 1\n                break\n\n        if not e[0]:\n            left = 0\n            right = m + 1\n        else:\n            for j in range(m, 0, -1):\n                if s[0][j]:\n                    kr = j\n                    break\n\n            left = 2*kr\n            right = m + 1\n\n        # print(left, right)\n\n        for i in range(1, lim):\n            if not e[i]:\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\n            else:\n                kr = kl = -1\n\n                for j in range(m, 0, -1):\n                    if s[i][j]:\n                        kr = j\n                        break\n\n                for j in range(1, m + 1):\n                    if s[i][j]:\n                        kl = j\n                        break\n\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\n\n            # print(left, right)\n\n        kr = kl = -1\n\n        for j in range(m, 0, -1):\n            if s[lim][j]:\n                kr = j\n                break\n\n        for j in range(1, m + 1):\n            if s[lim][j]:\n                kl = j\n                break\n\n        ans = min(left + 1 + kr, right + 1 + m + 1 - kl)\n\n        print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\ninf = float('inf')\nans = inf\n\ndef solve():\n    n, m = map(int, input().split())\n    s = [None] * n\n    for i in range(n - 1, -1, -1):\n        s[i] = [int(j) for j in input()]\n\n    e = [any(si) for si in s]\n    es = e[:] + [False]\n\n    for i in range(n - 1, -1, -1):\n        es[i] |= es[i + 1]\n\n    # print(es)\n\n    if not es[0]:\n        print(0)\n    elif es[0] and (not es[1]):\n        k = m + 1 - s[0][::-1].index(1)\n        print(k)\n    else:\n        lim = 0\n\n        for i in range(n + 1):\n            if not es[i]:\n                lim = i - 1\n                break\n\n        if not e[0]:\n            left = 0\n            right = m + 1\n        else:\n            kr = m + 1 - s[0][::-1].index(1)\n            left = 2*kr\n            right = m + 1\n\n        # print(left, right)\n\n        for i in range(1, lim):\n            if not e[i]:\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\n            else:\n                kr = m + 1 - s[i][::-1].index(1)\n                kl = s[i].index(1)\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\n\n            # print(left, right)\n\n        kr = m + 1 - s[lim][::-1].index(1)\n        kl = s[lim].index(1)\n\n        ans = min(left + 1 + kr, right + 1 + m + 1 - kl)\n\n        print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom itertools import accumulate\nfrom operator import or_\n\ninf = float('inf')\n\ndef solve():\n    n, m = map(int, input().split())\n    s = [[int(j) for j in input()] for i in range(n)][::-1]\n\n    e = [any(si) for si in s]\n    es = e[:] + [False]\n    es = list(accumulate(es[::-1], or_))[::-1]\n\n    if not es[0]:\n        print(0)\n    else:\n        lim = 0\n\n        for i in range(n + 1):\n            if not es[i]:\n                lim = i - 1\n                break\n\n        left, right = -1, inf\n\n        for i in range(lim):\n            if not e[i]:\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\n            else:\n                kr = rindex(s[i], 1)\n                kl = s[i].index(1)\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\n\n        kr = rindex(s[lim], 1)\n        kl = s[lim].index(1)\n\n        ans = min(left + 1 + kr, right + m + 2 - kl)\n\n        print(ans)\n\ndef rindex(arr, x):\n    return len(arr) - 1 - arr[::-1].index(x)\n\ndef __starting_point():\n    solve()\n__starting_point()", "from collections import Counter\nimport sys\n\ndef left_time(floor):\n    light_counter = Counter(floor)\n    # print(light_counter)\n    # print(light_counter['1'])\n    if light_counter['1'] == 0:\n        return 0\n    else:\n        last_light_search = 1\n        while last_light_search <= len(floor):\n            # print(last_light_search)\n            if floor[-last_light_search] == '1':\n                return((len(floor) - last_light_search) * 2)\n                break\n            else:\n                last_light_search += 1\n        \n\ndef right_time(floor):\n    light_counter = Counter(floor)\n    if light_counter['1'] == 0:\n        return 0\n    else:\n        last_light_search = 0\n        while True:\n            if floor[last_light_search] == '1':\n                return ((len(floor) - last_light_search - 1) * 2)\n                break\n            else:\n                last_light_search += 1\n\nfloors_nr, rooms_nr = (int(x) for x in input().split())\nbuilding_scheme = []\nworth_counting_flag = False\nfor i in range(floors_nr):\n    floor_i = input()\n    c = Counter(floor_i)\n    if not worth_counting_flag and c['1'] > 0:\n        worth_counting_flag = True\n    if worth_counting_flag:\n        building_scheme.append(floor_i)\n\nif len(building_scheme) == 0:\n    print(0)\n    return\n    \noptimal_time = [(-1, 10000)]\n\nlast_floor = building_scheme[0]\nbuilding_scheme = building_scheme[1:]\nfor floor in building_scheme[::-1]:\n    prefix_left, prefix_right = optimal_time[-1]\n    \n    keep_right_left = rooms_nr + 1 + prefix_left + 1\n    keep_right_right = right_time(floor) + prefix_right + 1\n    keep_right = min(keep_right_left, keep_right_right)\n    \n    keep_left_left = left_time(floor) + prefix_left + 1\n    keep_left_right = rooms_nr + 1 + prefix_right + 1\n    keep_left = min(keep_left_left, keep_left_right)\n    \n    optimal_time.append((keep_left, keep_right))\n\n# print(optimal_time)\n\nlast_floor_time = min(optimal_time[-1][0] + 1 + left_time(last_floor) // 2, optimal_time[-1][1] + 1 + right_time(last_floor) // 2)\nprint(last_floor_time)\n    \n    \n\n\n"]
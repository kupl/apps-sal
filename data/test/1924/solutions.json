["mod = 10**9+7\nrng = 2000100\nfctr = [1]+[0]*(rng-1)\nfor i in range(1,rng):\n  fctr[i] = fctr[i-1]*i%mod\ndef finv(x):\n  return pow(fctr[x],mod-2,mod)\ndef cmb(n,k):\n  if n<0 or k<0:\n    return 0\n  else:\n    return fctr[n]*finv(n-k)*finv(k)%mod\n\nx1,y1,x2,y2 = map(int,input().split())\nprint((cmb(x2+y2+2,x2+1)-cmb(x2+y1+1,y1)-cmb(x1+y2+1,x1)+cmb(x1+y1,x1))%mod)", "MOD = 10**9+7\nfac = [1, 1]\n\ndef prepare(n, mod):\n    for i in range(2, n+1):\n        fac.append((fac[-1] * i) % mod)\n\n\ndef modcmb(n, r, mod):\n    if n < 0 or r < 0 or r > n:\n        return 0\n\n    return fac[n] * pow(fac[r], mod-2, mod) * pow(fac[n-r], mod-2, mod) % mod\n\n\ndef f(r, c):\n    return modcmb(r+c, r, MOD)\n\n\ndef g(x, y):\n    return ((y+2) * modcmb(x+y+2, x, MOD) - (x+1)) * pow(x+1, MOD-2, MOD)\n\n\ndef main():\n    prepare(2*10**6+10, MOD)\n    r1,c1,r2,c2 = list(map(int, input().split()))\n\n    ans = g(r2, c2) - g(r1-1, c2) - g(r2, c1-1) + g(r1-1, c1-1)\n    ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 10**9+7\n\nf = [1]*(2*10**6+5)\nf[0] = 1\nfor i in range(1,2*10**6+4):\n    f[i] = f[i-1]*i%mod\n\ndef inv(i):\n    return pow(f[i],mod-2,mod)\n\ndef g(x,y):\n    return f[x+y]*inv(x)*inv(y)%mod\n\nr1,c1,r2,c2 = map(int,input().split(\" \"))\nans = g(r2+1,c2+1)-g(r2+1,c1)-g(r1,c2+1)+g(r1,c1)\nprint(ans%mod)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass ModTools:\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n        inverse = [1] * MAX\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, 0, -1):\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n        if n < r: return 0\n        # 10C7 = 10C3\n        r = min(r, n-r)\n        # \u5206\u5b50\u306e\u8a08\u7b97\n        numerator = self.fact[n]\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\n    def div(self, x, y):\n        \"\"\" MOD\u9664\u7b97 \"\"\"\n\n        return x * pow(y, self.MOD-2, self.MOD) % self.MOD\n\nr1, c1, r2, c2 = MAP()\n\nmt = ModTools(r2+c2+2, MOD)\ndef calc(r, c):\n    return mt.div(((r+2) * mt.nCr(c+r+2, r+2) - c - 1), (c + 1))\n\nans = calc(r2, c2) - calc(r2, c1-1) - calc(r1-1, c2) + calc(r1-1, c1-1)\nprint((ans%MOD))\n", "'''\n\u7814\u7a76\u5ba4PC\u3067\u306e\u89e3\u7b54\n\u89e3\u8aacAC\n'''\nimport math\n#import numpy as np\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\n\ndef main():\n    r1,c1,r2,c2 = list(map(int,ipt().split()))\n    #nCr\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\u3002N\u306b\u6700\u5927\u5024\u3092\u5165\u308c\u3066\u4f7f\u7528\u3002\n    N = r2+c2+2\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n    def cmb(n,r,mod=(10**9+7)):\n        if r<0 or r>n :\n            return 0\n        r = min(r,n-r)\n        return g1[n]*g2[r]*g2[n-r]%mod\n    for i in range(2,N+1):\n        g1.append((g1[-1]*i)%mod)\n        inverse.append((-inverse[mod % i]*(mod//i))%mod)\n        g2.append((g2[-1]*inverse[-1])%mod)\n\n    print(((cmb(r2+c2+2,r2+1)+cmb(r1+c1,r1)-cmb(r2+c1+1,r2+1)-cmb(r1+c2+1,r1))%mod))\n\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "r1,c1,r2,c2=list(map(int,input().split()))\n\nmod = 10**9+7\nMAX_N = 3*10**6\n\nfact = [1]\nfact_inv = [0]*(MAX_N+4)\nfor i in range(MAX_N+3):\n    fact.append(fact[-1]*(i+1)%mod)\n\nfact_inv[-1] = pow(fact[-1],mod-2,mod)\nfor i in range(MAX_N+2,-1,-1):\n    fact_inv[i] = fact_inv[i+1]*(i+1)%mod\n\ndef comb(n,k,mod):\n    if n<k:return 0\n    return fact[n] * fact_inv[k] % mod * fact_inv[n-k] %mod\n\nans=0\nans+=comb(c1+r1,r1,mod)\nans%=mod\nans-=comb(c1+r2+1,r2+1,mod)\nans%=mod\nans-=comb(c2+r1+1,r1,mod)\nans%=mod\nans+=comb(c2+r2+2,r2+1,mod)\nans%=mod\n\nprint(ans)\n", "import copy\n\n\ndef prepare(n, MOD):\n \n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\ndef func(r, c):\n    return f[r+1+c+1] * i[r+1] % MOD * i[c+1] % MOD\n\nMOD = 10**9+7\nf, i = prepare(2*10**6 + 2, MOD)\n\n\nr1, c1, r2, c2 = map(int,input().split())\n\ncombi = func(r2, c2) - func(r2, c1-1) - func(r1-1, c2) + func(r1-1, c1-1)\nprint(combi % MOD)   ", "#f_list\u3068f_r_list\u306e\u8981\u7d20\u6570\u306f\u72b6\u6cc1\u306b\u5fdc\u3058\u3066\u5909\u3048\u3088\u3046\n\nMOD = 10**9 + 7\nlist_size = 2000003\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\ndef f(x, y):\n\tif x * y == 0:\n\t\treturn 0\n\telif x == 1:\n\t\treturn y * (y+3) // 2\n\telse:\n\t\treturn comb(x+y+2, x+1) - x - y - 2\n\n\nr1, c1, r2, c2 = list(map(int, input().split()))\nans = (f(r2, c2) + f(r1-1, c1-1) - f(r1-1, c2) - f(r2, c1-1)) % MOD\nprint(ans)", "def main():\n  M=10**9+7\n  r1,c1,r2,c2=map(int,input().split())\n  n=r2+c2+2\n  val=1\n  fac=[val]\n  append=fac.append\n  for i in range(1,n+1):\n    val=val*i%M\n    append(val)\n  pr1=pow(fac[r1],M-2,M)\n  pc1=pow(fac[c1],M-2,M)\n  pr2=pow(fac[r2+1],M-2,M)\n  pc2=pow(fac[c2+1],M-2,M)\n  a=fac[r2+c2+2]*pr2*pc2\n  a-=fac[r2+c1+1]*pr2*pc1\n  a-=fac[r1+c2+1]*pr1*pc2\n  a+=fac[r1+c1]*pr1*pc1\n  print(a%M)\nmain()", "r1, c1, r2, c2 = map(int, input().split())\nL = 10 ** 9 + 7\n\n# \u4e92\u9664\u6cd5\ndef get_euclidian (A, B):\n  if B == 1:\n    return (1)\n  else:\n    return (int((1 - A * get_euclidian (B, A % B)) / B))\n\n# \u968e\u4e57\u8a08\u7b97\nF = [1]\nfor i in range(1, r2 + c2 + 3):\n  F.append((F[i - 1] * i) % L)\n\n# \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\ndef get_combi (n, r):\n\n  Euc = get_euclidian(L, (F[r] * F[n - r]) % L)\n  return ((F[n] * Euc) % L)\n\ncombi1 = get_combi(r2 + c2 + 2, r2 + 1)\ncombi2 = get_combi(r2 + c1 + 1, c1)\ncombi3 = get_combi(r1 + c2 + 1, r1)\ncombi4 = get_combi(r1 + c1, r1)\n\nprint ((int(combi1 - combi2 - combi3 + combi4) + L) % L)", "MOD = int(1e9)+7\n\ndef fact(x):\n    k = 1\n    for i in range(1,x+1):\n        k = (k*i)%MOD\n    return k\n\ndef inverse(b):\n    r = 1\n    e = MOD -2\n    while e:\n        if e%2==1:\n            r = (r*b)%MOD\n        b = (b*b)%MOD\n        e >>=1\n    return r\n\ndef comb(i,j):\n    if i==0 or j==0:\n        return 0\n    num=fact(i+j)\n    num*=inverse(fact(i))\n    num%=MOD\n    num*=inverse(fact(j))\n    num%=MOD\n    return num\n\nrc = list(map(int, input().split()))\nans = 0\nans += comb(rc[2]+1,rc[3]+1)\nans -= comb(rc[0],rc[3]+1)\nans -= comb(rc[2]+1,rc[1])\nans += comb(rc[0],rc[1])\nans += MOD\nans += MOD\nans %=MOD\nprint(ans)", "def main():\n  M=10**9+7\n  a,b,c,d=map(int,input().split())\n  n=c+d+2\n  fac=[0]*(n+1)\n  fac[0]=lt=1\n  for i in range(1,n+1):fac[i]=lt=lt*i%M\n  inv=lambda n:pow(fac[n],M-2,M)\n  f=lambda r,c:fac[r+c+2]*inv(c+1)*inv(r+1)-c-r-2\n  print((f(c,d)-f(c,b-1)-f(a-1,d)+f(a-1,b-1))%M)\nmain()", "r1, c1, r2, c2 = map(int, input().split())\nMOD = 10**9 + 7\n\ndef factorial(n, mod=10**9+7):\n    a = 1\n    for i in range(1,n+1):\n        a = a * i % mod\n    return a\n\n\ndef power(n, r, mod=10**9+7):\n    if r == 0: return 1\n    if r%2 == 0:\n        return power(n*n % mod, r//2, mod) % mod\n    if r%2 == 1:\n        return n * power(n, r-1, mod) % mod\n\n\ndef comb(n, k, mod=10**9+7):\n    if n < k or k < 0:\n        result = 0\n    else:\n        a = factorial(n, mod=mod)\n        b = factorial(k, mod=mod)\n        c = factorial(n-k, mod=mod)\n        result = (a * power(b, mod-2, mod=mod) * power(c, mod-2, mod=mod)) % mod\n    return result\n\n\ndef g(r, c):\n  return comb(c+r+2, r+1) - 1\n\nans = g(r2, c2) - g(r2, c1-1) - g(r1-1, c2) + g(r1-1, c1-1)\nans %= MOD\nprint(ans)", "class Combination:\n    \"\"\"\n    SIZE\u304c10^6\u7a0b\u5ea6\u4ee5\u4e0b\u306e\u4e8c\u9805\u4fc2\u6570\u3092\u4f55\u56de\u3082\u547c\u3073\u51fa\u3057\u305f\u3044\u3068\u304d\u306b\u4f7f\u3046\n    \u4f7f\u3044\u65b9:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    r1, c1, r2, c2 = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    comb = Combination(2 * 10 ** 6 + 10, mod)\n\n    def f(r, c):\n        return comb(r+c+2, r+1)\n\n    CD = (f(r2, c2) - f(r2, c1-1) + mod) % mod\n    C = (f(r1-1, c2) - f(r1-1, c1-1) + mod) % mod\n    ans = (CD - C + mod) % mod\n    print(ans)\n\n__starting_point()", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\n\ndef inv(v, mod):\n    return pow(v, mod-2, mod)\ndef main():\n    r1, c1, r2, c2 = rip()\n\n    MM = int(2e6+10)\n    fact = [0] * MM\n    finv = [0] * MM\n    fact[0] = 1\n    finv[0] = 1\n    mod = int(1e9) + 7\n    for i in range(1,MM): fact[i] = (fact[i-1] * i % mod)\n    finv[MM-1] = inv(fact[MM-1], mod)\n    for i in reversed(list(range(1,MM-1))):\n        finv[i] = finv[i + 1] * (i + 1) % mod\n    def sum_naive(r, c):\n        #[0, r) * [0, c)\n        ret = 0\n        for i in range(r):\n            ret += fact[i + 1 + c - 1] * finv[i + 1] * finv[c - 1] % mod\n        return ret\n    def sum(r, c):\n        #[0, r) * [0, c)\n        ret = fact[r + c] * finv[r] * finv[c] % mod\n        ret += -1 + mod\n        ret %= mod\n        return ret\n\n    ans = 0\n    ans += sum(r2 + 1, c2 + 1)\n    ans -= sum(r2 + 1, c1)\n    ans -= sum(r1, c2 + 1)\n    ans += sum(r1, c1)\n    ans %= mod\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  U = 2*10**6+2\n  MOD = 10**9+7\n\n  fact = [1]*(U+1)\n  fact_inv = [1]*(U+1)\n\n  for i in range(1,U+1):\n      fact[i] = (fact[i-1]*i)%MOD\n  fact_inv[U] = pow(fact[U], MOD-2, MOD)\n\n  for i in range(U,0,-1):\n      fact_inv[i-1] = (fact_inv[i]*i)%MOD\n\n  def comb(n, k):\n      if k < 0 or k > n:\n          return 0\n      z = fact[n]\n      z *= fact_inv[k]\n      z %= MOD\n      z *= fact_inv[n-k]\n      z %= MOD\n      return z\n\n  ans = 0\n  r1, c1, r2, c2 = map(int, input().split())\n  for i in range(c1, c2+1):\n    ans += comb(i+r2+1, i+1) - comb(i+r1, i+1)\n  print(ans%MOD)\n  \ndef __starting_point():\n  main()\n__starting_point()", "MOD = 10**9 + 7\nMOD_t_MAX = 2 * 10**6 + 10\n\nfac  = [None] * MOD_t_MAX\nfinv = [None] * MOD_t_MAX\ninv  = [None] * MOD_t_MAX\ndef MOD_COM_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MOD_t_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\ndef MOD_COM(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef main():\n    r1, c1, r2, c2 = map(int, input().split())\n    MOD_COM_init()\n    a = MOD_COM(r2+1+c2+1, r2+1) - 1\n    b = MOD_COM(r2+1+c1, c1) - 1\n    c = MOD_COM(r1+c2+1, r1) - 1\n    d = MOD_COM(r1+c1, c1) - 1\n    ans = a - (b + c) + d\n    print(ans % MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 7)\n\nr1, c1, r2, c2 = list(map(int, input().split()))\n\n\n# \u968e\u4e57\u3001Combination\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3(numpy\u3092\u4f7f\u3046)\n\ndef cumprod(arr, MOD):\n    L = len(arr)\n    Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]\n        arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]\n        arr[n] %= MOD\n    return arr.ravel()[:L]\n\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64)\n    x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64)\n    x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\n\nMOD = 10 ** 9 + 7\nU = 10**6 * 2 + 10\nfact, fact_inv = make_fact(U, MOD)\n\n\ndef mod_comb_k(n, k, mod):\n    return fact[n] * fact_inv[k] % mod * fact_inv[n - k] % mod\n\n\ndef calc_rc(r, c):\n    a = mod_comb_k(r + c + 2, r + 1, MOD)\n    b = 1\n    return a-b\n\n\nans = calc_rc(r2, c2) + calc_rc(r1-1, c1-1) - \\\n    calc_rc(r1-1, c2) - calc_rc(r2, c1-1)\nans %= MOD\n\nprint(ans)\n", "MOD = 10 ** 9 + 7\ntable_len = 2 * 10 ** 6 + 10\n\nfac = [1, 1]\nfor i in range(2, table_len):\n    fac.append(fac[-1] * i % MOD)\n    \nfinv = [0] * table_len\nfinv[-1] = pow(fac[-1], MOD - 2, MOD)\nfor i in range(table_len-1, 0, -1):\n    finv[i-1] = finv[i] * i % MOD\n\ndef comb(a, b):\n    return fac[a+b] * finv[a] * finv[b] % MOD\n\n\nr1, c1, r2, c2 = map(int, input().split())\nans = (comb(r1, c1) + comb(r2+1, c2+1) - comb(r1, c2+1) - comb(r2+1, c1)) % MOD\nprint(ans)", "r1,c1,r2,c2=list(map(int,input().split()))\n\nmod = 10**9+7\nMAX_N = 3*10**6\n\nfact = [1]\nfact_inv = [0]*(MAX_N+4)\nfor i in range(MAX_N+3):\n    fact.append(fact[-1]*(i+1)%mod)\n\nfact_inv[-1] = pow(fact[-1],mod-2,mod)\nfor i in range(MAX_N+2,-1,-1):\n    fact_inv[i] = fact_inv[i+1]*(i+1)%mod\n\ndef comb(n,k,mod=mod):\n    if n<k:return 0\n    return fact[n] * fact_inv[k] % mod * fact_inv[n-k] %mod\n\nans=comb(c1+r1,r1)-comb(c1+r2+1,r2+1)-comb(c2+r1+1,r1)+comb(c2+r2+2,r2+1)\nans%=mod\n\nprint(ans)\n", "mod = 1000000007\n\nclass combination():\n    def __init__(self, n):\n        self.fact = [1] * (n+1)\n        self.ifact = [1] * (n+1)\n        for i in range(1, n+1):\n            self.fact[i] = self.fact[i-1]*i % mod\n        self.ifact[n] = pow(self.fact[n], mod-2, mod)\n        for i in range(n, 0, -1):\n            self.ifact[i-1] = self.ifact[i]*i % mod\n    def comb(self, n, k):\n        if k < 0 or k > n: return 0\n        comb = self.fact[n]*self.ifact[k]*self.ifact[n-k] %mod\n        return comb\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    r1, c1, r2, c2 = map(int, input().split())\n\n    comb = combination(2000010)\n\n    # c1 ~ c2+1, r1 ~ r2+1\n    ans = comb.comb(c2+r2+2, r2+1) - 1\n    ans -= comb.comb(c1+r2+1, c1) - 1\n    ans -= comb.comb(c2+r1+1, r1) - 1\n    ans += comb.comb(c1+r1, r1) - 1\n    print(ans % mod)\n\nmain()", "def main():\n  M=10**9+7\n  a,b,c,d=map(int,input().split())\n  n=c+d+2\n  fac=[0]*(n+1)\n  fac[0]=lt=1\n  for i in range(1,n+1):fac[i]=lt=lt*i%M\n  inv=[0]*(n+1)\n  inv[n]=lt=pow(fac[n],M-2,M)\n  for i in range(n,0,-1):inv[i-1]=lt=lt*i%M\n  comb=lambda n,k:fac[n]*inv[n-k]*inv[k]\n  f=lambda r,c:fac[r+c+2]*inv[c+1]*inv[r+1]-c-r-2\n  print((f(c,d)-f(c,b-1)-f(a-1,d)+f(a-1,b-1))%M)\nmain()", "MOD = 10**9+7\n\n# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef nCr(n, r, mod=MOD):\n    r = min(r, n-r)\n    numer = denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n+1-i) % mod\n        denom = denom * i % mod\n    return numer * pow(denom, mod-2, mod) % mod\n\ndef g(r, c):\n    return nCr(r+c+2, r+1) - 1\n\nr1, c1, r2, c2 = list(map(int, input().split()))\nr1 -= 1; c1 -= 1\nans = g(r2, c2)\nans -= g(r1, c2)\nans -= g(r2, c1)\nans += g(r1, c1)\nans += MOD * 2\nans %= MOD\nprint(ans)\n", "def main():\n    mod = 10 ** 9 + 7\n    N = 2 * 10 ** 6 + 3\n\n    fac = [0] * N\n    finv = [0] * N\n    inv = [0] * N\n\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, N):\n        fac[i] = fac[i - 1] * i % mod\n        # mod p\u306b\u304a\u3051\u308b1, 2, ..., n\u306e\u9006\u5143\n        # inv[i] = mod - inv[mod % i] * (mod // i) % mod\n        # finv[i] = finv[i - 1] * inv[i] % mod\n    # mod\u306b\u304a\u3051\u308b1!, 2!, ...\u306e\u9006\u5143\n    finv[N // 2] = pow(fac[N // 2], mod - 2, mod)\n    for i in reversed(list(range(N // 2))):\n        finv[i] = (finv[i + 1] * (i + 1)) % mod\n\n    def com(r, c):\n        ans = fac[r + c] * finv[r] * finv[c]\n        return ans % mod\n\n    def g(r, c):\n        return (com(r + 1, c + 1) - 1) % mod\n\n    r1, c1, r2, c2 = list(map(int, input().split()))\n\n    answer = g(r2, c2) - g(r2, c1-1) - g(r1-1, c2) + g(r1-1, c1-1)\n    answer %= mod\n    print(answer)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    mod = 10**9+7\n    fact = [1, 1]\n    for i in range(2, 2*(10**6)+10):\n        fact.append(fact[-1]*i % mod)\n\n    r1, c1, r2, c2 = map(int, input().split())\n    r1 -= 1\n    c1 -= 1\n\n    def calc(r, c):\n        return (pow(fact[c+1]*fact[r+1] % mod, mod-2, mod)*fact[r+c+2]-1) % mod\n\n    print((calc(r2, c2)-calc(r1, c2)-calc(r2, c1)+calc(r1, c1)) % mod)\n\n\nmain()", "import sys\n\n\nTEST_INPUT = [\n    \"\"\"\n    1 1 2 2\n    \"\"\",\n    \"\"\"\n    314 159 2653 589\n    \"\"\"\n]\nANSWER = [\n    \"14\",\n    \"602215194\"\n]\n\n\nclass InputHandler:\n\n    def __init__(self, text_lines=\"\", is_test=False):\n        self.data = list(text_lines.split(\"\\n\"))\n        self.index = 0\n        self.is_test = is_test\n\n    def input(self):\n        if self.is_test:\n            self.index += 1\n            return self.data[self.index].strip()\n        else:\n            return sys.stdin.readline().rstrip()\n\n\nLARGE = 10 ** 9 + 7\n\n\ndef solve(r1, c1, r2, c2):\n\n    fact = [0] * (r2 + c2 + 3)\n    fact[0] = 1\n    for i in range(1, r2 + c2 + 3):\n        fact[i] = fact[i - 1] * i % LARGE\n\n    fact_inv = [0] * (r2 + c2 + 3)\n    fact_inv[-1] = pow(fact[-1], LARGE - 2, LARGE)\n    for i in range(r2 + c2 + 1, -1, -1):\n        fact_inv[i] = fact_inv[i + 1] * (i + 1) % LARGE\n\n    def solve_special(r, c):\n        return (fact[r + c + 2] * fact_inv[r + 1] * fact_inv[c + 1] - 1) % LARGE\n\n    res = solve_special(r2, c2) - solve_special(r1 - 1, c2) - solve_special(r2, c1 - 1) + solve_special(r1 - 1, c1 - 1)\n\n    return res % LARGE\n\n\ndef input_and_solve(ih):\n    r1, c1, r2, c2 = list(map(int, ih.input().split()))\n    res = solve(r1, c1, r2, c2)\n    return res\n\n\ndef main():\n    ih = InputHandler()\n    res = input_and_solve(ih)\n    print(res)\n\n\ndef test():\n    for test_input, ans in zip(TEST_INPUT, ANSWER):\n        ih = InputHandler(test_input, True)\n        res = input_and_solve(ih)\n        # print(res, ans)\n        assert str(res) == str(ans)\n\n\ndef __starting_point():\n    # test()\n    main()\n\n__starting_point()", "def solve():\n    r1, c1, r2, c2 = map(int, input().split())\n    \n    p = 10 ** 9 + 7\n    N = r2 + c2 + 2\n    fact = [1, 1]\n    for i in range(2, N + 1):\n        fact.append((fact[-1] * i) % p)\n    \n    def comb(n, r):\n        a = fact[n]\n        b = pow(fact[r], p - 2, p)\n        c = pow(fact[n-r], p - 2, p)\n        return a * b * c % p\n    \n    def f(i, j):\n        return comb(i + j, i)\n    \n    def g(i, j):\n        return f(i + 1, j + 1) - 1\n    \n    ans = g(r2, c2) - g(r2, c1 - 1) - g(r1 - 1, c2) + g(r1 - 1, c1 - 1)\n    \n    print(ans % p)\n\nsolve()", "nn = 2002002\nP = 10**9+7\nfa = [1]\nfor i in range(1, nn): fa.append(fa[-1] * i % P)\nf = lambda a, b: fa[a+b+2] * pow(fa[a+1] * fa[b+1], P-2, P) % P - 1\nr1, c1, r2, c2 = map(int, input().split())\nprint((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P)", "r1,c1,r2,c2=list(map(int,input().split()))\nn=2*max(r1,r2,c1,c2)+2\nmod=10**9+7\n\n#nCk\nfactorial=[1]\nfor i in range(1, n+1):\n    factorial.append(factorial[-1] * i % mod)\n\ninv_factorial = [-1] * (n+1)\ninv_factorial[-1] = pow(factorial[-1], mod-2, mod)\nfor i in reversed(list(range(n))):\n    inv_factorial[i] = inv_factorial[i+1] * (i+1) % mod\n\ndef fact(n):\n    return factorial[n]\n\ndef nck(n, k):\n    if k>n or k<0:\n        return 0\n    else:\n        return factorial[n] * inv_factorial[n-k] * inv_factorial[k]\n      \ndef routes(r,c):\n  return nck(r+c+2,c+1)-1\n\nans=routes(r2,c2)-routes(r2,c1-1)-routes(c2,r1-1)+routes(r1-1,c1-1)\nans%=mod\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  U = 2*10**6+2\n  MOD = 10**9+7\n\n  fact = [1]*(U+1)\n  fact_inv = [1]*(U+1)\n\n  for i in range(1,U+1):\n      fact[i] = (fact[i-1]*i)%MOD\n  fact_inv[U] = pow(fact[U], MOD-2, MOD)\n\n  for i in range(U,0,-1):\n      fact_inv[i-1] = (fact_inv[i]*i)%MOD\n\n  def comb(n, k):\n      if k < 0 or k > n:\n          return 0\n      z = fact[n]\n      z *= fact_inv[k]\n      z *= fact_inv[n-k]\n      z %= MOD\n      return z\n\n  ans = 0\n  r1, c1, r2, c2 = map(int, input().split())\n  for i in range(c1, c2+1):\n    ans += comb(i+r2+1, i+1) - comb(i+r1, i+1)\n  print(ans%MOD)\n  \ndef __starting_point():\n  main()\n__starting_point()", "def mod_inverse(n, mod=10**9+7):\n    return pow(n, mod-2, mod)\n\n\ndef combination(n, k, mod=10**9+7):\n    numer = denom = 1\n    for i in range(k):\n        numer = (numer * (n-i)) % mod\n        denom = (denom * (i+1)) % mod\n    return (numer * mod_inverse(denom, mod)) % mod\n\n\nmod = 10**9+7\nr1, c1, r2, c2 = list(map(int, input().split()))\nans = combination(r1+c1, r1) - combination(1+r2+c1, 1+r2) - combination(1+r1+c2, r1) + combination(2+r2+c2, 1+r2)\nprint((ans % mod))\n", "# nCr mod m\n# r\u304cn/2\u306b\u8fd1\u3044\u3068\u975e\u5e38\u306b\u91cd\u304f\u306a\u308b\ndef combination(n, r, mod=10**9+7):\n    n1, r = n+1, min(r, n-r)\n    numer = denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n1-i) % mod\n        denom = denom * i % mod\n    return numer * pow(denom, mod-2, mod) % mod\n\nmod = 10**9 + 7\nr1, c1, r2, c2 = list(map(int, input().split()))\nr2 += 1\nc2 += 1\na1 = combination(r1+c1, r1)\na2 = combination(r2+c2, r2)\na3 = combination(r1+c2, r1)\na4 = combination(r2+c1, r2)\nprint(((a1+a2-a3-a4)%mod))\n", "r1,c1,r2,c2=list(map(int,input().split()))\nmod=10**9+7\ndef comb(n,k,mod):\n  if n<k:\n    return 0\n  if n-k<k:\n    k=n-k\n  c=1\n  for x in range(n-k+1,n+1):\n    c=(c*x)%mod\n  d=1\n  for x in range(1,k+1):\n    d=(d*x)%mod\n  c=c*pow(d,mod-2,mod)\n  return c%mod\ndef f(i,j):\n  return comb(i+j,i,mod)\nans=f(r2+1,c2+1)-f(r2+1,c1)-f(r1,c2+1)+f(r1,c1)\nans%=mod\nprint(ans)\n", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\nfrom itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\ndef run():\n    r1, c1, r2, c2 = map(int, read().split())\n    mod = 10 ** 9 + 7\n\n    def generate_inv(n, mod):\n        \"\"\"\n        \u9006\u5143\u884c\u5217\n        n >= 2\n        Note: mod must bwe a prime number\n        \"\"\"\n        ret = [0, 1]\n        for i in range(2, n + 1):\n            next = -ret[mod % i] * (mod // i)\n            next %= mod\n            ret.append(next)\n        return ret\n\n    inv = generate_inv(max(c1,c2,r1,r2) + 1, mod)\n\n\n\n    def calc(i,j):\n        ret = 0\n        agg = 1\n        for k in range(1, i+2):\n            agg *= (j+k)%mod\n            agg *= inv[k]\n            agg %= mod\n            ret += agg\n        return ret\n\n\n    ret = 0\n    ret += calc(r2, c2)\n    ret -= calc(r2, c1-1)\n    ret -= calc(r1-1, c2)\n    ret += calc(r1-1, c1-1)\n    ret %= mod\n    print(ret)\n\ndef __starting_point():\n    run()\n__starting_point()", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\n\ndef inv(v, mod):\n    return pow(v, mod-2, mod)\ndef main():\n    r1, c1, r2, c2 = rip()\n\n    MM = int(2e6+10)\n    fact = [0] * MM\n    finv = [0] * MM\n    fact[0] = 1\n    finv[0] = 1\n    mod = int(1e9) + 7\n    for i in range(1,MM): fact[i] = (fact[i-1] * i % mod)\n    '''\n    finv[MM-1] = inv(fact[MM-1], mod)\n    for i in reversed(range(1,MM-1)):\n        finv[i] = finv[i + 1] * (i + 1) % mod\n    def sum_naive(r, c):\n        #[0, r) * [0, c)\n        ret = 0\n        for i in range(r):\n            ret += fact[i + 1 + c - 1] * finv[i + 1] * finv[c - 1] % mod\n        return ret\n    def sum(r, c):\n        #[0, r) * [0, c)\n        ret = fact[r + c] * finv[r] * finv[c] % mod\n        ret += -1 + mod\n        ret %= mod\n        return ret\n    '''\n    def sum(r, c):\n        #[0, r) * [0, c)\n        ret = fact[r + c] * inv(fact[r], mod) * inv(fact[c], mod) % mod\n        ret += -1 + mod\n        ret %= mod\n        return ret\n    ans = 0\n    ans += sum(r2 + 1, c2 + 1)\n    ans -= sum(r2 + 1, c1)\n    ans -= sum(r1, c2 + 1)\n    ans += sum(r1, c1)\n    ans %= mod\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\nr1, c1, r2, c2 = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nfacts, invs = prepare(r2 + c2 + 1, MOD)\nans = 0\nfor i in range(r1, r2 + 1):\n    d1 = facts[i + c2 + 1] * invs[c2] % MOD\n    d2 = facts[i + c1] * invs[c1 - 1] % MOD\n    ans = (ans + (d1 - d2) * invs[i + 1]) % MOD\nprint(ans)\n", "k = 72\nK = 1<<k\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\nst = lambda n: bin(n)[2:] + \"0\"\nli = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]\n\ndef grow(d, v, h):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    \n    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):\n        t = [1] * (2*d+2)\n        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P\n        ti = [1] * (2*d+2)\n        ti[-1] = pow(t[-1], P-2, P)\n        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P\n        \n        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]\n        fg = li(st(nu(f) * nu(g)), d * 2 + 2)\n            \n        if idx == 1:\n            for i in range(d+1):\n                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n        elif idx == 0:\n            for i in range(d):\n                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P\n        elif idx == 2:\n            for i in range(d):\n                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v):\n    s = 1\n    X = [1, v+1]\n    while s < v:\n        X = grow(s, v, X)\n        s *= 2\n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nv = 1 << 11\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nT = create_table(v)\n\nf = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P\nr1, c1, r2, c2 = list(map(int, input().split()))\nprint(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))\n", "r1, c1, r2, c2 = list(map(int, input().split()))\n\nmod = 1000000007\n\n# return an integer k s.t. (a * k) % p = 1 and 0 <= k < p.\ndef inversion(a):\n    b = mod\n    u, v = 1, 0\n    while b >= 1:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u %= mod\n    if u < 0:\n        u += mod\n    return u\n\nfact = [0 for i in range(2000003)]\nfor i in range(2000003):\n    if i <= 1:\n        fact[i] = 1\n    else:\n        fact[i] = (fact[i-1] * i) % mod\n\n# return nCr % p.\ndef combination(n, r):\n    return (((fact[n] * inversion(fact[r])) % mod) * inversion(fact[n-r])) % mod\n\nanswer = (\ncombination(r2 + c2 + 2, r2 + 1) -\ncombination(r2 + c1 + 1, r2 + 1) -\ncombination(r1 + c2 + 1, c2 + 1) +\ncombination(r1 + c1    , c1    ) )\n\nanswer %= mod\n\nif answer < 0:\n    answer += mod\n\nprint(answer)\n", "m = 1000000007\n\n\nr1, c1, r2, c2 = map(int, input().split())\n\nnf = 10 ** 6 * 2 + 100\nfact = [0] * (nf + 1)\nfact[0] = 1\nfor i in range(nf):\n    fact[i + 1] = fact[i] * (i + 1) % m\n\n\ndef F(r, c):\n    path = (fact[r + c + 2] % m) * pow(fact[r + 1] * fact[c + 1], m - 2, m) % m\n    return path - 1\n\n\nr1 -= 1\nc1 -= 1\n\nans = F(r2, c2)\nans -= F(r1, c2)\nans -= F(r2, c1)\nans += F(r1, c1)\nans = ans % m\n\nprint(ans)", "r1,c1,r2,c2 = map(int,input().split())\n\nn = [1]*(r2+c2+3)\nmod = 10**9 + 7\nfor i in range(r2+c2+2):\n    n[i+1] = (n[i]*((i+1)%mod))%mod\n\ndef calc(r,c):\n    x = n[r+c]%mod\n    y = (n[r]*n[c])%mod\n    return (x*(pow(y,mod-2,mod)%mod))%mod\n\nans = calc(r2+1,c2+1)-calc(r2+1,c1)-calc(r1,c2+1)+calc(r1,c1)\nans %= mod\n\nprint(ans)", "MOD = 10 ** 9 + 7\ndef comb(n, r):\n    return fact[n] * pow(fact[n - r], MOD - 2, MOD) * pow(fact[r], MOD - 2, MOD)\ndef g(r, c):\n    return (comb(r + c + 2, c + 1) - 1) % MOD\nr1, c1, r2, c2 = list(map(int, input().split()))\nFACT_MAX = r2 + c2 + 3\nfact = [1] * FACT_MAX\nfor i in range(1, FACT_MAX):\n    fact[i] = fact[i - 1] * i % MOD\nprint(((g(r2, c2) - g(r2, c1 - 1) - g(r1 - 1, c2) + g(r1 - 1, c1 - 1)) % MOD))\n", "r1, c1, r2, c2 = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\n\ndef cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * pow(g1[r], mod - 2, mod) * pow(g1[n - r], mod - 2, mod) % mod\n\n\ndef make_table(n, mod=10 ** 9 + 7):\n    N = n\n    # \u5143\u30c6\u30fc\u30d6\u30eb\n    g1 = [0] * (N + 1)\n    g1[0] = 1\n    g1[1] = 1\n\n    tmp = g1[1]\n    for i in range(2, N + 1):\n        tmp = tmp * i % mod\n        g1[i] = (g1[i - 1] * i) % mod\n\n    return g1\n\n\ndef f(x, y):\n    return ((x + 2) * cmb(x + y + 2, y, mod) - y - 1) * pow(y + 1, mod - 2, mod)\n\n\ng1 = make_table(2 * 10 ** 6 + 10)\nanswer = f(c2, r2) - f(c2, r1 - 1) - f(c1 - 1, r2) + f(c1 - 1, r1 - 1)\nanswer %= mod\nprint(answer)\n", "r, c, R, C = [int(_) for _ in input().split()]\nmod = 10**9 + 7\n\nf = [1] * (2 * 10**6 + 10)\nfor i in range(1, 2 * 10**6 + 10):\n    f[i] = i * f[i - 1] % mod\n\n\ndef comb(x, y):\n    return f[x] * pow(f[y], mod - 2, mod) * pow(f[x - y], mod - 2, mod)\n\n\nprint(((comb(C + R + 2, R + 1) - comb(c + R + 1, R + 1) - comb(C + r + 1, r) + comb(c + r, r)) % mod))\n", "import sys\n\nMOD = 10 ** 9 + 7\n\ndef make_table(size=2*10**6+2, p=MOD):\n    fac = [None] * (size + 1)\n    fac[0] = 1\n    for i in range(size):\n        fac[i+1] = fac[i] * (i + 1) % p\n    ifac = [None] * (size + 1)\n    ifac[size] = pow(fac[size], p-2, p)\n    for i in range(size, 0, -1):\n        ifac[i-1] = ifac[i] * i % p\n    return fac, ifac\n\nfac, ifac = make_table()\n\ndef comb(n, r, mod=MOD):\n    if r > n or r < 0:\n        return 0\n    return fac[n] * ifac[r] % mod * ifac[n-r] % mod\n\ndef g(y, x):\n    return comb(y+x+2, y+1) - 1\n\nr1, c1, r2, c2 = map(int, sys.stdin.readline().split())\n\ndef main():\n    ans = (g(r2, c2) - (g(r1-1, c2) + g(r2, c1-1) - g(r1-1, c1-1))) % MOD\n    return ans\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "import sys\nread = sys.stdin.read\nmod = 10 ** 9 + 7\nr1, c1, r2, c2 = map(int, read().split())\n\ndef prepare(n, MOD):\n\n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\nfac, finv = prepare(2 * 10**6 + 10, mod)\n\n\ndef comb(n, k, mod=mod, fac=fac, finv=finv):\n    '''\n    \u4e8c\u9805\u4fc2\u6570\u306e\u8a08\u7b97\n\n    Parameters\n    n : int\n        \u5143\u96c6\u5408\n    k : int\n        \u5143\u96c6\u5408\u304b\u3089\u9078\u629e\u3059\u308b\u6570\n    mod : int\n        \u3042\u307e\u308a\n    fac : list\n        \u968e\u4e57\u306e\u30ea\u30b9\u30c8\n    finv : list\n        \u9006\u5143\u306e\u30ea\u30b9\u30c8\n\n    Returns\n    c : int\n        nCk\u306e\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\n    '''\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod\n\n\nanswer = comb(r2 + c2 + 2, r2 + 1) - comb(r1 + c2 + 1, r1) - \\\n    comb(c1 + r2 + 1, c1) + comb(r1 + c1, r1)\nanswer %= mod\nprint(answer)", "def main():\n  M=10**9+7\n  r1,c1,r2,c2=map(int,input().split())\n  n=r2+c2+2\n  fac=[0]*(n+1)\n  fac[0]=before=1\n  for i in range(1,n+1):fac[i]=before=before*i%M\n  f=lambda r,c:fac[r+c+2]*pow(fac[c+1],M-2,M)*pow(fac[r+1],M-2,M)-c-r-2\n  print((f(r2,c2)-f(r2,c1-1)-f(r1-1,c2)+f(r1-1,c1-1))%M)\nmain()", "MOD = 10**9+7\nr1,c1,r2,c2 = map(int,input().split())\n \nsize = 1010000*2\nf_list = [1]*(size)\nfor i in range(1,size):\n    f_list[i] = (f_list[i-1]*i)%MOD\n\ndef func(r,c):\n    return (f_list[r+c]*pow(f_list[r],MOD-2,MOD)*pow(f_list[c],MOD-2,MOD))\n \nans = func(r2+1,c2+1)-1\nans += func(r1,c1)-1\nans -= func(r2+1,c1)-1\nans -= func(r1,c2+1)-1\nprint(ans%MOD)", "class Factorial:\n    def __init__(self,n,mod):\n        self.f=f=[0]*(n+1)\n        f[0]=b=1\n        self.mod=mod\n        for i in range(1,n+1):f[i]=b=b*i%mod\n        self.inv=inv=[0]*(n+1)\n        inv[n]=b=pow(self.f[n],mod-2,mod)\n        for i in range(n,0,-1):inv[i-1]=b=b*i%mod\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.inv[i]\n    def comb(self,n,k):\n        if n>=k:\n            return self.f[n]*self.inv[n-k]%self.mod*self.inv[k]%self.mod\n        else:\n            return 0\nM=10**9+7\na,b,c,d=map(int,input().split())\ncomb=Factorial(c+d+2,M).comb\nf=lambda r,c:comb(c+r+2,r+1)-c-r-2\nprint((f(c,d)-f(c,b-1)-f(a-1,d)+f(a-1,b-1))%M)", "class Factorial:\n    def __init__(self,n,mod):\n        self.f=f=[0]*(n+1)\n        f[0]=b=1\n        self.mod=mod\n        for i in range(1,n+1):f[i]=b=b*i%mod\n        self.inv=inv=[0]*(n+1)\n        inv[0]=b=pow(self.f[n],mod-2,mod)\n        for i in range(1,n+1):inv[i]=b=b*(n+1-i)%mod\n        self.inv.reverse()\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.inv[i]\n    def comb(self,n,k):\n        return self.f[n]*self.inv[n-k]%self.mod*self.inv[k]%self.mod if n>=k else 0\nM=10**9+7\na,b,c,d=map(int,input().split())\ncomb=Factorial(c+d+2,M).comb\nf=lambda r,c:comb(c+r+2,r+1)-c-r-2\nprint((f(c,d)-f(c,b-1)-f(a-1,d)+f(a-1,b-1))%M)", "r1, c1, r2, c2 = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nN = r2 + c2 + 10\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nans = nCk(r2 + c2 + 2, r2 + 1) - nCk(r2 + c1 + 1, r2 + 1) \\\n    - nCk(r1 + c2 + 1, c2 + 1) + nCk(r1 + c1, r1)\nprint(ans % MOD)", "\n\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\ndef resolve():\n    def f(r, c):\n        return cmb.nCr(r+c+2, r+1) - 1\n\n    MOD = 10**9+7\n    r1,c1,r2,c2 = map(int, input().split())\n    r1 -= 1\n    c1 -= 1\n\n    cmb = Combination(r2+c2+5)\n    ans = f(r2, c2)\n    ans -= f(r1, c2)\n    ans -= f(r2, c1)\n    ans += f(r1, c1)\n    print(ans % MOD)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "def getComb(n, k, MOD):\n    if n < k:\n        return 0\n    if n-k < k:\n        k = n-k\n    # n!/(n-k)!\n    comb = 1\n    for x in range(n-k+1, n+1):\n        comb = (comb * x) % MOD\n    # k!\n    d = 1\n    for x in range(1, k+1):\n        d = (d * x) % MOD\n    # n!/((n-k)!*k!)\n    comb *= pow(d, MOD-2, MOD)\n    return comb % MOD\n\nr1,c1,r2,c2 = map(int,input().split())\nMOD = 10**9 + 7\nans = 0\n\nans += getComb(r2+c2+2, r2+1, MOD)\nans -= getComb(r2+c1+1, r2+1, MOD)\nans -= getComb(r1+c2+1, r1, MOD)\nans += getComb(r1+c1, r1, MOD)\n\nprint(ans % MOD)", "def main():\n  M=10**9+7\n  r1,c1,r2,c2=map(int,input().split())\n  n=r2+c2+2\n  fac=[1]+[0]*n\n  for i in range(1,n+1):fac[i]=fac[i-1]*i%M\n  f=lambda r,c:fac[r+c+2]*pow(fac[c+1],M-2,M)*pow(fac[r+1],M-2,M)-c-r-2\n  print((f(r2,c2)-f(r2,c1-1)-f(r1-1,c2)+f(r1-1,c1-1))%M)\nmain()", "u, l, d, r = map(int, input().split())\nmod = 10 ** 9 + 7\n\ndef extGCD(a, b):\n    if b == 0:\n        return a, 1, 0\n    g, y, x = extGCD(b, a%b)\n    y -= a//b * x\n    return g, x, y\n\ndef moddiv(a, b):\n    _, inv, _ = extGCD(b, mod)\n    return (a * inv) % mod\n\nf = [0] * (2 * 10 ** 6 + 10)\nf[0] = 1\nfor i in range(1, 2 * 10 ** 6 + 10):\n    f[i] = (f[i-1] * i) % mod\n\ndef comb(a, b):\n    return moddiv(moddiv(f[a+b], f[a]), f[b])\n\nans = 0\nd += 1\nr += 1\nans += comb(d, r)\nans += comb(u, l)\nans -= comb(d, l)\nans -= comb(u, r)\nprint(ans % mod)", "r1, c1, r2, c2 = list(map(int, input().split()))\nmod = int(1e+9) + 7\ndef inved(x):\n  a, b, c, d, k, l = 1, 0, 0, 1, x, mod\n  while l != 0:\n    a, b, c, d = c, d, a - c * (k // l), b - d * (k // l)\n    k, l = l, k % l\n  return a % mod\nfrac = [1]\nfor i in range(r2 + c2 + 2):\n  frac.append(((i+1) * frac[i]) % mod)\nfracr2c2 = frac[r2 + c2 + 2]\nfracr1c2 = frac[r1 + c2 + 1]\nfracr2c1 = frac[r2 + c1 + 1]\nfracr1c1 = frac[r1 + c1]\nfracr2 = frac[r2 + 1]\nfracr1 = frac[r1]\nfracc2 = frac[c2 + 1]\nfracc1 = frac[c1]\ng = 0\ng += (fracr2c2 * inved(fracr2) * inved(fracc2)) % mod\ng %= mod\ng += (fracr1c1 * inved(fracr1) * inved(fracc1)) % mod\ng %= mod\ng -= (fracr1c2 * inved(fracr1) * inved(fracc2)) % mod\ng %= mod\ng -= (fracr2c1 * inved(fracr2) * inved(fracc1)) % mod\ng %= mod\nprint(g)\n", "class Factorial:\n    def __init__(self,n,mod):\n        self.f=[1]\n        self.mod=mod\n        for i in range(1,n+1):\n            self.f.append(self.f[-1]*i%mod)\n        self.i=[pow(self.f[-1],mod-2,mod)]\n        for i in range(1,n+1)[::-1]:\n            self.i.append(self.i[-1]*i%mod)\n        self.i.reverse()\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.i[i]\n    def comb(self,n,k):\n        return self.f[n]*self.i[n-k]%self.mod*self.i[k]%self.mod if n>=k else 0\nM=10**9+7\na,b,c,d=map(int,input().split())\ncomb=Factorial(c+d+2,M).comb\nf=lambda r,c:comb(c+r+2,r+1)-c-r-2\nprint((f(c,d)-f(c,b-1)-f(a-1,d)+f(a-1,b-1))%M)", "\n##mod,n\u306b\u3064\u3044\u3066\u306e\u5236\u7d04\u306f\u81ea\u5206\u3067\u3044\u304b\u306b\u8a18\u5165\u3059\u308b\nmod=10**9+7\ndef find_power(n,mod):\n    # 0!\u304b\u3089n!\u307e\u3067\u306e\u3073\u3063\u304f\u308a\u3092\u51fa\u3057\u3066\u304f\u308c\u308b\u95a2\u6570(\u305f\u3060\u3057\u3001mod\u3067\u5272\u3063\u305f\u5024\u306b\u5bfe\u3057\u3066\u3067\u3042\u308b\uff09\n    powlist=[0]*(n+1)\n    powlist[0]=1\n    powlist[1]=1\n    for i in range(2,n+1):\n        powlist[i]=powlist[i-1]*i%(mod)\n    return powlist\n #\u3042\u308b\u304b\u305ax\u306en\u4e57\u3092mod\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3092\u8fd4\u3059\u95a2\u6570pow_cal(x,n,mod)\ndef pow_cal(x,n,mod):\n    if n==0:\n        return 1\n    elif n==1:\n        return x%mod\n    elif n>=2:\n        if n%2==0:\n            return (pow_cal(x,n//2,mod)**2)%mod\n        else:\n            return (x*pow_cal(x,n//2,mod)**2)%mod\n\ndef find_inv_power(n,mod):\n    #0!\u304b\u3089n!\u307e\u3067\u306e\u9006\u5143\u3092\u7d20\u6570mod\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\u95a2\u6570\n    c=1\n    uselist=[0 for i in range(n+1)]\n    for i in range(1,n+1):\n        c*=i\n        c%=mod\n    first=pow_cal(c,mod-2,mod)\n    uselist[n]=first\n    for i in range(n,0,-1):\n        uselist[i-1]=(uselist[i]*i)%(mod)\n    return uselist\n    \nA=find_power(2*10**6+10,mod)\nB=find_inv_power(2*10**6+10,mod)\n\ndef combi(n,r,mod):\n    if n<r:\n        return 0\n    elif n>=r:\n        return (A[n]*B[r]*B[n-r])%(mod)\n    \nr1,c1,r2,c2=list(map(int,input().split()))\n\nmod=10**9+7     \n\nK=combi(r2+c2+2,c2+1,mod)-combi(r2+c1+1,c1,mod)-combi(r1+c2+1,r1,mod)+combi(r1+c1,c1,mod)\n\nprint((K%mod))\n", "mod = 10**9 + 7\n\nr1, c1, r2, c2 = map(int, input().split())\n\ndef inv(x):\n  m = mod\n  u = 1\n  v = 0\n  while(m):\n    t = x // m\n    x -= t * m\n    x, m = m, x\n    u -= t * v\n    u, v = v, u\n  u %= mod\n  if u < 0:\n    u += mod\n  return u\n\nfac = [1]\nfor i in range(1, r2 + c2 + 3):\n  fac.append(fac[i - 1] * i % mod)\n\ndef paths(r, c):\n  return fac[r + c + 2] * inv(fac[r + 1] * fac[c + 1]) % mod\n\nf = paths(r2, c2) - paths(r2, c1 - 1) - paths(r1 - 1, c2) + paths(r1 - 1, c1 - 1)\nf %= mod\nif f < 0:\n   f += mod\nprint(f)", "def main():\n  M=10**9+7\n  r1,c1,r2,c2=map(int,input().split())\n  n=r2+c2+2\n  fac=[1]\n  val=1\n  append=fac.append\n  for i in range(1,n+1):\n    val=val*i%M\n    append(val)\n  f=lambda r,c:fac[r+c+2]*pow(fac[c+1],M-2,M)*pow(fac[r+1],M-2,M)-c-r-2\n  print((f(r2,c2)-f(r2,c1-1)-f(r1-1,c2)+f(r1-1,c1-1))%M)\nmain()", "def g(r, c):\n    return (fact[r + c + 2] * fact_inv[r + 1] * fact_inv[c + 1] - 1) % mod\n\n\nr1, c1, r2, c2 = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\nMAX = 10 ** 6\n\nfact = [1] * (2 * MAX + 10)\nfor i in range(1, 2 * MAX + 10):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 10)\nfor i in range(2, MAX + 10):\n    inv[i] = inv[mod % i] * (mod - mod // i) % mod\n\nfact_inv = [1] * (MAX + 10)\nfor i in range(1, MAX + 10):\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\nans = g(r2, c2) - g(r2, c1 - 1) - g(r1 - 1, c2) + g(r1 - 1, c1 - 1)\nans %= mod\nprint(ans)\n", "MOD = 10 ** 9 + 7\nFACT_MAX = 2 * 10 ** 6 + 3\nfact = [1] * FACT_MAX\nfor i in range(1, FACT_MAX):\n    fact[i] = fact[i - 1] * i % MOD\ndef comb(n, r):\n    return fact[n] * pow(fact[n - r], MOD - 2, MOD) * pow(fact[r], MOD - 2, MOD)\ndef g(r, c):\n    return (comb(r + c + 2, c + 1) - 1) % MOD\nr1, c1, r2, c2 = list(map(int, input().split()))\nprint(((g(r2, c2) - g(r2, c1 - 1) - g(r1 - 1, c2) + g(r1 - 1, c1 - 1)) % MOD))\n", "M=1000000007\nr1,c1,r2,c2=map(int,input().split())\nn=r2+c2+2\nfac=[1]+[0]*n\nfor i in range(1,n+1):fac[i]=fac[i-1]*i%M\nf=lambda r,c:fac[r+c+2]*pow(fac[c+1],M-2,M)*pow(fac[r+1],M-2,M)-1\nprint((f(r2,c2)-f(r2,c1-1)-f(r1-1,c2)+f(r1-1,c1-1))%M)", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\ndef resolve():\n    def f(r, c):\n        return cmb.nCr(r + c, r)\n\n    MOD = 10 ** 9 + 7\n    r1, c1, r2, c2 = map(int, input().split())\n    r2 += 1\n    c2 += 1\n    cmb = Combination(r2 + c2 + 5)\n\n    ans = f(r2, c2)\n    ans -= f(r1, c2)\n    ans -= f(r2, c1)\n    ans += f(r1, c1)\n    print(ans % MOD)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass ModTools:\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n        inverse = [1] * MAX\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, 0, -1):\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n        if n < r: return 0\n        # 10C7 = 10C3\n        r = min(r, n-r)\n        # \u5206\u5b50\u306e\u8a08\u7b97\n        numerator = self.fact[n]\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\nr1, c1, r2, c2 = MAP()\n\nmt = ModTools(r2+c2+2, MOD)\n# nCr(0, 0)\u304b\u3089nCr(n, r)\u307e\u3067\u306e\u5168\u3066\u306e\u7d44\u307f\u5408\u308f\u305b\u306e\u7dcf\u548c\ndef calc(r, c):\n    return mt.nCr(r+c+2, r+1) - 1\n\n# 2\u6b21\u5143\u3067\u533a\u9593\u548c\u53d6\u308b\u6642\u306e\u8981\u9818\u30674\u70b9\u8db3\u3057\u5f15\u304d\nans = calc(r2, c2) - calc(r2, c1-1) - calc(r1-1, c2) + calc(r1-1, c1-1)\nprint((ans%MOD))\n", "r1, c1, r2, c2 = map(int, input().split())\nMOD = 10 **9 + 7\n\nans = 0\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\nF = Factorial(r2 + c2 + 3, MOD)\n\nans = F.comb(c1 + r1, c1) - F.comb(c1 + r2 + 1, c1) - F.comb(c2 + r1 + 1, c2 + 1) + F.comb(c2 + r2 + 2, c2 + 1)\n\nprint (ans % MOD)", "a1,b1,a2,b2=map(int,input().split())\n\nimport sys\nsys.setrecursionlimit(2000000000)\n\np = 10 ** 9 + 7\nN = a2+b2+2  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nR = max(a2+1,b2+1)\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N + 1):\n  fact.append((fact[-1] * i) % p)\n  \nfor i in range(2, R + 1):\n  inv.append((-inv[p % i] * (p // i)) % p)\n  factinv.append((factinv[-1] * inv[-1]) % p)\n\ndef comb(n, r, p):\n  if (r < 0) or (n < r):\n    return 0\n  r = min(r, n - r)\n  return fact[n] * factinv[r] * factinv[n-r] % p\n\nscore=comb(a2+b2+2,a2+1,p)-comb(a2+b1+1,a2+1,p)-comb(a1+b2+1,a1,p)+comb(a1+b1,a1,p)\nprint(score%(10**9+7))", "#F\nfrom operator import mul\nfrom functools import reduce\n\nr1, c1, r2, c2 = [int(i) for i in input().split()]\nmod = 10**9 + 7\n\n#pre-caluculation of the factorial\nnum = 10**6*2+3\nfact=[0] * num\nfact[0]=1\nfor i in range(1, num):\n    fact[i] = (fact[i-1] * i) % mod\n\ndef combinations_count(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, range(1, r + 1), 1)\n    return numer // denom\n\ndef f(rr,cc):\n    #(0,0)~(r,c)\u307e\u3067\u306e\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u306e\u7d2f\u7a4d\u548c\n    #print(rr+cc+2, cc+1)\n    #print(combinations_count(rr+cc+2, cc+1))\n    #return combinations_count(rr+cc+2, cc+1) - 1\n    return (fact[rr+cc+2]%mod * pow(fact[rr+1]*fact[cc+1], mod-2, mod)) % mod -1\n\nans = f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)\nprint(ans % mod)", "r1, c1, r2, c2 = map(int, input().split())\n\n\nclass Combination:\n    def __init__(self, N: int, MOD: int):\n        fac = [0 for _ in range(N + 1)]\n        fac[0] = 1\n        for i in range(1, N + 1):\n            fac[i] = fac[i - 1] * i % MOD\n        self.fac = fac\n        self.N = N\n        self.MOD = MOD\n\n    def _modpow(self, x: int, n: int) -> int:\n        ret = 1\n        while n > 0:\n            if n % 2 == 1:\n                ret = ret * x % self.MOD\n            x = x * x % self.MOD\n            n >>= 1\n        return ret\n\n    def _modinv(self, x: int) -> int:\n        return self._modpow(x, self.MOD - 2)\n\n    def combination(self, n: int, k: int) -> int:\n        if n < k:\n            return 0\n        return self.fac[n] * self._modinv(self.fac[k]) % self.MOD * self._modinv(self.fac[n - k]) % self.MOD\n\nMOD = 1000000007\ncomb = Combination(2 * 1000000 + 10, MOD)\n\nans = (2 * MOD + comb.combination(r1 + c1, r1) - comb.combination(r1 + c2 + 1, r1) - comb.combination(r2 + c1 + 1, r2 + 1) + comb.combination(r2 + c2 + 2, r2 + 1)) % MOD\nprint(ans)", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0 \n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 2 * 10 ** 6 + 10  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\nr1, c1, r2, c2 = lr()\nanswer = cmb(r2+c2+2, r2+1) - 1\nanswer -= cmb(r2+c1+1, r2+1) - 1\nanswer -= cmb(r1+c2+1, c2+1) - 1\nanswer += cmb(r1+c1, r1) - 1\nprint((answer % MOD))\n# 26\n", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0 \n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 2 * 10 ** 6 + 3  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\nr1, c1, r2, c2 = lr()\nanswer = cmb(r2+c2+2, r2+1) - 1\nanswer -= cmb(r2+c1+1, r2+1) - 1\nanswer -= cmb(r1+c2+1, c2+1) - 1\nanswer += cmb(r1+c1, r1) - 1\nprint((answer % MOD))\n# 26\n", "def f(n, r, mod=10 ** 9 + 7):\n\tn += r\n\tassert n >= r >= 0\n\n\tdef ex_euclid(x, y):\n\t\ta, b = 1, 0\n\t\twhile y != 0:\n\t\t\ta, b = b, (a - x // y * b)\n\t\t\tx, y = y, x % y\n\t\treturn a\n\n\tp = q = 1\n\tfor i in range(n - r + 1, n + 1):\n\t\tp *= i\n\t\tp %= mod\n\tfor i in range(2, r + 1):\n\t\tq *= i\n\t\tq %= mod\n\tp *= ex_euclid(q, mod)\n\tp %= mod\n\treturn p\n\na,b,c,d=map(int,input().split())\nmod=10**9+7\nprint((f(c+1,d+1)+mod-f(a,d+1)+mod-f(c+1,b)+f(a,b))%mod)", "r1,c1,r2,c2 = list(map(int, input().split()))\nmod = int(1e9+7)\n\n# f(i,j) = cmb(i+j,i)\n\ndef cmb(n, r, mod=mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\ndef init_cmb(Nmax):\n    #mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range(2, Nmax + 1):\n        g1.append((g1[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        g2.append((g2[-1] * inverse[-1]) % mod)\n    return g1, g2\n  \ng1, g2 = init_cmb(max(r1,r2) + max(c1,c2) + 10)\n\ndef solve(r1,c1,r2,c2):\n  def f(r,c):\n    return cmb(r+c,min(r,c))\n  \n  res = 0\n  # S[r2,c2] - S[r2,c1-1] - S[r1-1,c2] + S[r1-1,c1-1]\n  # S[r2,c2] = cmb(r2,0) + cmb(r2+1,1) + ... + cmb(r2+c2, c2)\n  r2,c2 = r2, c2\n  res += f(r2,c2)\n  res -= f(r2,c1)\n  res -= f(r1,c2)\n  res += f(r1,c1)\n  \n  \"\"\"\n  for c in range(0,c2+1):\n    res += (c+1) * cmb(r2+c, c)\n    res %= mod\n  for c in range(0,c1):\n    res -= (c+1) * cmb(r2+c, c)\n    res %= mod\n  for r in range(0,r1):\n    res -= (r+1) * cmb(c2+r,r)\n    res %= mod\n  for r in range(0,r1):\n    res += (r+1) * cmb(c1-1+r,r)\n    res %= mod\n  \"\"\"  \n  return res % mod\n\ndef solve2(r1,c1,r2,c2):\n  res = 0\n  for r in range(r1,r2+1):\n    for c in range(c1,c2+1):\n      res += cmb(c+r,c)\n      res %= mod\n  return res\n\n#print(solve(r1,c1,r2,c2))\nprint((solve(r1,c1,r2+1,c2+1)))\n#print(solve2(r1,c1,r2,c2))\n", "r1,c1,r2,c2 = map(int,input().split())\n\nMOD = 10**9+7\nMAXN = r2+c2+5\nfac = [1,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n\ndef inv(n):\n    return pow(n,MOD-2,MOD)\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * inv(fac[r]) * inv(fac[n-r]) % MOD\n\nans = comb(r2+c2+2,r2+1) - comb(r2+c1+1,c1) - comb(r1+c2+1,r1) + comb(r1+c1,r1)\nans %= MOD\nprint(ans)", "r1,c1,r2,c2=map(int,input().split())\nmod=10**9+7\nn=[1]*(r2+c2+3)\nfor i in range(r2+c2+2):\n  n[i+1]=(n[i]*(i+1))%mod\ndef g(a,b):\n  x,y,z=n[a+b],n[a],n[b]\n  return (((x*pow(y,mod-2,mod))%mod)*pow(z,mod-2,mod))%mod\nprint((g(r2+1,c2+1)-g(r2+1,c1)-g(r1,c2+1)+g(r1,c1))%mod)", "def f_many_many_paths():\n    class Combination(object):\n        \"\"\"\u53c2\u8003: https://harigami.net/contents?id=5f169f85-5707-4137-87a5-f0068749d9bb\"\"\"\n        __slots__ = ['mod', 'factorial', 'inverse']\n\n        def __init__(self, max_val_arg: int = 10**6, mod: int = 10**9 + 7):\n            fac, inv = [1], []\n            fac_append, inv_append = fac.append, inv.append\n\n            for i in range(1, max_val_arg + 1):\n                fac_append(fac[-1] * i % mod)\n\n            # inv_append(pow(fac[-1], -1, mod)) (after Python 3.8)\n            inv_append(pow(fac[-1], mod - 2, mod))\n\n            for i in range(max_val_arg, 0, -1):\n                inv_append((inv[-1] * i) % mod)\n\n            self.mod, self.factorial, self.inverse = mod, fac, inv[::-1]\n\n        def combination(self, n, r):\n            if n < 0 or r < 0 or n < r:\n                return 0\n            return self.factorial[n] * self.inverse[r] * self.inverse[n - r] % self.mod\n\n    R1, C1, R2, C2 = [int(i) for i in input().split()]\n    comb = Combination(R2 + C2 + 2).combination\n\n    def g(r, c):\n        return comb(r + c + 2, r + 1) - 1\n\n    return (g(R2, C2) - g(R1 - 1, C2) - g(R2, C1 - 1) + g(R1 - 1, C1 - 1)) % (10**9 + 7)\n\nprint(f_many_many_paths())", "def mod_combination(n, k, mod = 10 ** 9 + 7):\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        d, x, y = extended_gcd(b, a % b)\n        return (d, y, x - (a // b) * y)\n    p, q = 1, 1\n    for i in range(n - k + 1, n + 1):\n        p = (p * i) % mod\n    for i in range(2, k + 1):\n        q = (q * i) % mod\n    return p * (extended_gcd(q, mod)[1] % mod) % mod\n\nmod = 10 ** 9 + 7\n\nr1, c1, r2, c2 = map(int, input().split())\n\ndef f(i, j):\n    return mod_combination(i + j, i)\n\nprint((f(r2 + 1, c2 + 1) - f(r2 + 1, c1) - f(r1, c2 + 1) + f(r1, c1)) % mod)", "MOD = 10**9+7\nr1,c1,r2,c2 = list(map(int,input().split()))\n\nsize = 1010000*2\nf_list = [1]*(size)\nfor i in range(1,size):\n    f_list[i] = (f_list[i-1]*i)%MOD\n\ndef func(r,c):\n    return (f_list[r+c]*pow(f_list[r],MOD-2,MOD)*pow(f_list[c],MOD-2,MOD))\n\nans = func(r2+1,c2+1)-1\nans += func(r1,c1)-1\nans -= func(r2+1,c1)-1\nans -= func(r1,c2+1)-1\nprint((ans%MOD))\n\n", "def inpl():\n    return list(map(int, input().split()))\n\n\ndef cmb(n, r):\n    # combination\n    if n < r:\n        return 0\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    return (over[n] * under[r] * under[n - r]) % MOD\n\n\n# \u4e92\u3044\u306b\u7d20\u306ax, y\u306b\u3064\u3044\u3066\u3001a * x + b * y = 1\u306e\u89e3\u306e\u4e00\u3064\u3092\u6c42\u3081\u308b\u3002\ndef extGCD(x, y):\n    r = [1, 0, x]\n    w = [0, 1, y]\n    # print(r, w)\n    while w[2] != 1:\n        # print(r, w)\n        q = r[2] // w[2]\n        w_tmp = [r[0] - q * w[0], r[1] - q * w[1], r[2] % w[2]]\n        r, w = w, w_tmp\n\n    return w[:2]\n\n\ndef mod_inv(a, m):\n    _, x = extGCD(m, a)\n    return (x + m) % m\n\n\ndef g(x, y):\n    return (cmb(x + y + 2, x + 1) - 1 + MOD) % MOD\n\n\nr1, c1, r2, c2 = inpl()\n\nMOD = 10**9 + 7\n\nover = [0 for i in range(r2 + c2 + 3)]\nunder = [0 for i in range(r2 + c2 + 3)]\nover[0] = 1\nfor i in range(r2 + c2 + 2):\n    over[i + 1] = over[i] * (i + 1) % MOD\n\nunder[r2 + c2 + 2] = mod_inv(over[r2 + c2 + 2], MOD)\nfor i in range(r2 + c2 + 1, 0, -1):\n    under[i] = under[i + 1] * (i + 1) % MOD\n\nprint(((g(r2, c2) - g(r2, c1 - 1) - g(r1 - 1, c2) + g(r1 - 1, c1 - 1)) % MOD))\n", "m=10**9+7\ndef f(r,c):\n s=t=1\n for i in range(c):s=s*(r+c-i)%m;t=t*-~i%m\n return s*pow(t,m-2,m)%m\na,b,c,d=map(int,input().split())\nprint((f(a,b)-f(c+1,b)-f(a,d+1)+f(c+1,d+1))%m)", "k = 72\nK = 1<<k\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\nst = lambda n: bin(n)[2:] + \"0\"\nli = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]\n\ndef grow(d, v, h):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    \n    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):\n        g = [pow(a - d + i - 1, P-2, P) if i else 0 for i in range(2*d+2)]\n        fg = li(st(nu(f) * nu(g)), d * 8 - 1)\n        p = 1\n        for i in range(d+1):\n            p = p * (a-i) % P\n        for i in range(d+1):\n            fg[d+i+1] = fg[d+i+1] * p % P\n            p = p * (a+i+1) % P * pow(a-d+i, P-2, P) % P\n        if idx == 1:\n            for i in range(d+1):\n                h[i] = h[i] * fg[d+i+1] % P\n        elif idx == 0:\n            for i in range(d):\n                h[i+d+1] = fg[d+i+1]\n        elif idx == 2:\n            for i in range(d):\n                h[i+d+1] = h[i+d+1] * fg[d+i+1] % P\n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v):\n    s = 1\n    X = [1, v+1]\n    while s < v:\n        X = grow(s, v, X)\n        s *= 2\n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nv = 1 << 11\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nT = create_table(v)\n\nf = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P\nr1, c1, r2, c2 = map(int, input().split())\nprint((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P)", "Q = 10**9+7\ndef getInv(N):#Q\u306fmod\n    inv = [0] * (N + 1)\n    inv[0] = 1\n    inv[1] = 1\n    for i in range(2, N + 1):\n        inv[i] = (-(Q // i) * inv[Q%i]) % Q\n    return inv\n\ndef getFactorialInv(N):\n    inv = [0] * (N + 1)\n    inv[0] = 1\n    inv[1] = 1\n    ret = [1]*(N+1)\n    for i in range(2, N + 1):\n        inv[i] = (-(Q // i) * inv[Q%i]) % Q\n        ret[i] = ret[i-1]*inv[i]%Q\n    return ret\n\ndef getFactorial(N):\n    ret = [1]*(N+1)\n    for i in range(2,N+1):\n        ret[i] = ret[i-1]*i%Q\n    return ret\n\ndef main():\n    r1, c1, r2, c2 = list(map( int, input().split()))\n    F = getFactorial(2*10**6+2)\n    I = getFactorialInv(10**6+1)\n\n    def G(a, b):\n        return F[a+b+2]*I[a+1]%Q*I[b+1]%Q\n    \n    print(( ( G(r2,c2) - G(r2, c1-1) - G(r1-1, c2) + G(r1-1, c1-1))%Q))\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n  M=10**9+7\n  r1,c1,r2,c2=map(int,input().split())\n  n=r2+c2+2\n  fac=[0]*(n+1)\n  fac[0]=1\n  for i in range(1,n+1):fac[i]=fac[i-1]*i%M\n  f=lambda r,c:fac[r+c+2]*pow(fac[c+1],M-2,M)*pow(fac[r+1],M-2,M)-c-r-2\n  print((f(r2,c2)-f(r2,c1-1)-f(r1-1,c2)+f(r1-1,c1-1))%M)\nmain()", "MOD = 10**9 + 7\n\nr1, c1, r2, c2 = list(map(int, input().split()))\n\ndef getComb(n, k, MOD):\n    if n < k:\n        return 0\n    if n-k < k:\n        k = n-k\n    comb = 1\n    for x in range(n-k+1, n+1):\n        comb = (comb * x) % MOD\n    d = 1\n    for x in range(1, k+1):\n        d = (d * x) % MOD\n    comb *= pow(d, MOD-2, MOD)\n    return comb % MOD\n\ndef f(i, j):\n    return getComb(i+j, j, MOD)\n\nans = f(r2+1, c2+1) - f(r2+1, c1) - f(r1, c2+1) + f(r1, c1)\nans %= MOD\n\nprint(ans)\n", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\nfrom itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\ndef run():\n    r1, c1, r2, c2 = map(int, read().split())\n    mod = 10 ** 9 + 7\n\n    def generate_inv(n, mod):\n        \"\"\"\n        \u9006\u5143\u884c\u5217\n        n >= 2\n        Note: mod must bwe a prime number\n        \"\"\"\n        ret = [0, 1]\n        for i in range(2, n + 1):\n            next = -ret[mod % i] * (mod // i)\n            next %= mod\n            ret.append(next)\n        return ret\n\n    inv = generate_inv(10 ** 6 + 1, mod)\n\n\n\n    def calc(i,j):\n        ret = 0\n        agg = 1\n        for k in range(1, i+2):\n            agg *= (j+k)%mod\n            agg *= inv[k]\n            agg %= mod\n            ret += agg\n        return ret\n\n\n    ret = 0\n    ret += calc(r2, c2)\n    ret -= calc(r2, c1-1)\n    ret -= calc(r1-1, c2)\n    ret += calc(r1-1, c1-1)\n    ret %= mod\n    print(ret)\n\ndef __starting_point():\n    run()\n__starting_point()", "import sys\nimport socket\n\nhostname = socket.gethostname()\n\nif hostname == 'F451C':\n    sys.stdin = open('f1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str():\n    return input()\n\n\nM = 10 ** 9 + 7\nf = [1] * (2*10**6+4)\nfor i in range(1, 2*10**6+3):\n  f[i] = f[i-1] * i\n  f[i] %= M\n\n\ndef g(r, s):\n  res = 1\n  frs = f[r+s+2]\n  fs = f[s+1]\n  fr = f[r+1]\n\n  res *= pow(fr, M-2, M)\n  res *= pow(fs, M-2, M)\n\n  res *= frs\n  res %= M\n  return res\n\n\ndef main():\n    r1, c1, r2, c2 = read_int_list()\n    res = 0\n    res += g(r2, c2) - g(r2, c1-1) - g(r1-1, c2) + g(r1-1, c1-1)\n    res %= M\n    print(res)\n\n\nmain()\n", "# comb_mod(n, c, r, mod, fac, den) \u2261 nCr\ndef prepare(n, mod):\n    # fac[i] \u2261 i!\n    fac = [1]\n    for i in range(1, n+1):\n        fac.append((fac[-1] * i) % mod)\n\n    # rec \u2261 1 / n!\n    rec = pow(fac[-1], mod-2, mod)\n\n    # den[i] \u2261 1 / i!\n    den = [1 for _ in range(n+1)]\n    den[n] = rec\n    for i in range(n-1, 0, -1):\n        rec = (rec * (i+1)) % mod\n        den[i] = rec\n    \n    return fac, den\n\ndef comb_mod(n, r, mod, fac, den):\n    return (fac[n] * den[r] * den[n - r]) % mod\n\nr1, c1, r2, c2 = map(int, input().split())\n\n# n:max(n), mod:prime number \u3092\u5165\u529b\nmod = 10**9 + 7\nfac, den = prepare(r2+c2+2, mod)\n\nans = comb_mod(r2+1+c2+1, c2+1, mod, fac, den)\nans -= comb_mod(r2+1+c1, c1, mod, fac, den)\nans -= comb_mod(r1+c2+1, c2+1, mod, fac, den)\nans += comb_mod(r1+c1, c1, mod, fac, den)\n\nprint(ans % mod)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\ndef cmb(n, k):\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nr1, c1, r2, c2 = lr()\nMOD = 10 ** 9 + 7\nU = 2 * 10 ** 6 + 10\nfact, fact_inv = make_fact(U,MOD)\n\nanswer = cmb(r2+c2+2, r2+1) - cmb(r2+1+c1, r2+1) - cmb(r1+c2+1, r1) + cmb(r1+c1, r1)\nprint((answer % MOD))\n\n# 16\n", "r1, c1, r2, c2 = map(int, input().split())\n\np = 10 ** 9 + 7\nsize = 1010000 * 2\nf_list = [1] * size\nfor i in range(1, size):\n    f_list[i] = (f_list[i - 1] * i) % p\n\ndef cmb(n, r):\n    return f_list[n + r] * pow(f_list[n], p-2, p) * pow(f_list[r], p-2, p) % p\n\nhole = cmb(r2 + 1, c2 + 1) - 1\nrect1 = cmb(r2 + 1, c1) - 1\nrect2 = cmb(r1, c2 + 1) - 1\nduplicate = cmb(r1, c1) - 1\nans = (hole - rect1 - rect2 + duplicate) % p\nprint(ans)", "r1,c1,r2,c2 = map(int,input().split())\n\nMOD = 10**9+7\nMAXN = r2+c2+5\nfac = [1,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n\ndef inv(n):\n    return pow(n,MOD-2,MOD)\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * inv(fac[r]) * inv(fac[n-r]) % MOD\n\nr2,c2 = r2+1,c2+1\nans = comb(r2+c2,r2) - comb(r2+c1,r2) - comb(r1+c2,r1) + comb(r1+c1,r1)\nans %= MOD\nprint(ans)", "import numpy as np\nimport sys\nread = sys.stdin.read\nr1, c1, r2, c2 = list(map(int, read().split()))\nMOD = 10 ** 9 + 7\n\n\ndef cumprod(A, MOD=MOD):\n    L = len(A)\n    Lsq = int(L**.5 + 1)\n    A = np.resize(A, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        A[:, n] *= A[:, n - 1]\n        A[:, n] %= MOD\n    for n in range(1, Lsq):\n        A[n] *= A[n - 1, -1]\n        A[n] %= MOD\n    return A.ravel()[:L]\n\n\ndef make_fact(U, MOD=MOD):\n    x = np.arange(U, dtype=np.int64)\n    x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64)\n    x[0] = pow(int(fact[-1]), MOD - 2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    fact.flags.writeable = False\n    fact_inv.flags.writeable = False\n    return fact, fact_inv\n\n\nfac, finv = make_fact(2 * 10**6 + 10, MOD)\n\n\ndef comb(n, k, mod=MOD, fac=fac, finv=finv):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod\n\n\nanswer = comb(r2 + c2 + 2, r2 + 1) - comb(r1 + c2 + 1, r1) - \\\n    comb(c1 + r2 + 1, c1) + comb(r1 + c1, r1)\nanswer %= MOD\nprint(answer)\n", "nn = 2002002\nP = 10**9+7\nfa = [1] + [0] * nn\nfor i in range(nn): fa[i+1] = fa[i] * (i+1) % P\nf = lambda a, b: fa[a+b+2] * pow(fa[a+1] * fa[b+1], P-2, P) % P - 1\nr1, c1, r2, c2 = map(int, input().split())\nprint((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P)"]
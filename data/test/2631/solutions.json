["class Solution(object):\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         graph = [[] for _ in range(numCourses)]\n         visited = [0 for _ in range(numCourses)]\n         # create graph\n         for pair in prerequisites:\n             x, y = pair\n             graph[x].append(y)\n         # visit each node\n         for i in range(numCourses):\n             if not self.dfs(graph, visited, i):\n                 return False\n         return True\n     \n     def dfs(self, graph, visited, i):\n         # if ith node is marked as being visited, then a cycle is found\n         if visited[i] == -1:\n             return False\n         # if it is done visted, then do not visit again\n         if visited[i] == 1:\n             return True\n         # mark as being visited\n         visited[i] = -1\n         # visit all the neighbours\n         for j in graph[i]:\n             if not self.dfs(graph, visited, j):\n                 return False\n         # after visit all the neighbours, mark it as done visited\n         visited[i] = 1\n         return True", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         V = numCourses\n         \n         # Store outgoing edges\n         edges = []\n         \n         for _ in range(V):\n             edges.append(set())\n         \n         for p in prerequisites:\n             # Edge goes from v1 to v2\n             v2, v1 = p\n             edges[v1].add(v2)\n         \n         checked = set()\n         \n         def detect_cycle(x, visited):\n             visited.add(x)\n             checked.add(x)\n             \n             for v in edges[x]:\n                 if v in visited:\n                     return True\n                 if detect_cycle(v, visited):\n                     return True\n             visited.remove(x)\n             return False\n         \n         for v in range(V):\n             if v in checked:\n                 continue\n             if detect_cycle(v, set()):\n                 return False\n         \n         return True\n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         \n         # sol1: topo sort\n         N = numCourses\n         indegree = [0] * N\n         O = [set() for _ in range(N)]\n         for b, a in prerequisites:\n             O[a].add(b)\n             indegree[b] += 1\n         \n         stack = [c for c in range(N) if indegree[c] == 0]\n         done = 0\n         while stack:\n             i = stack.pop()\n             done += 1\n             for j in O[i]:\n                 indegree[j] -= 1\n                 if indegree[j] == 0:\n                     stack.append(j)\n         return done == N\n         \n         # sol2: UF\n", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         pre_count = [0] * numCourses\n         next_courses = [[] for _ in range(numCourses)]\n         \n         for cur, pre in prerequisites:\n             next_courses[pre].append(cur)\n             pre_count[cur] += 1\n         \n         q = []\n         \n         # always chose courses without prereq\n         for i, count in enumerate(pre_count):\n             if count == 0:\n                 q.append(i)\n         \n         finish_num = 0\n         # take those courses which can be taken after finishing prereq\n         while q:\n             course = q.pop(0)\n             finish_num += 1\n             for next_course in next_courses[course]:\n                 pre_count[next_course] -= 1\n                 if pre_count[next_course]  == 0:\n                     q.append(next_course)\n         \n         return finish_num == numCourses\n             \n         \n", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         graph = [[] for _ in range(numCourses)]\n         visit = [0 for _ in range(numCourses)]\n         for x, y in prerequisites:\n             graph[x].append(y)\n             \n         ## states: 0 = unkonwn, 1 == visiting, 2 = visited\n         def dfs(c,v):\n             if v[c] == 2: return False\n             if v[c] == 1: return True\n             v[c]=1 #lable as visiting, if it does not visited eventually, it will cause an exception\n             for i in graph[c]:\n                 if dfs(i,v): return True\n                 \n             v[c]=2 # change to visited after done visiting\n             return False\n         \n         \n         for j in range(numCourses):\n             if dfs(j,visit): return False\n         return True\n             \n", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"       \n         in_degrees = collections.defaultdict(int)        \n         edges = collections.defaultdict(list)\n \n         for i in range(0, numCourses):\n             in_degrees[i] = 0            \n         \n         for prerequisty in prerequisites:\n             start = prerequisty[1]\n             end = prerequisty[0]\n             edges[start].append(end)\n             in_degrees[end] += 1\n \n         queue = collections.deque()\n         \n         for i in range(0, numCourses):\n             if in_degrees[i] == 0:\n                 queue.append(i)\n             \n         count = 0\n         while len(queue) > 0:\n             node = queue.popleft()\n             count += 1\n             \n             for neighbor in edges[node]:\n                 in_degrees[neighbor] -= 1\n                 if in_degrees[neighbor] == 0:\n                     queue.append(neighbor)\n                     \n         return count == numCourses        ", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         course_map = {i: [] for i in range(numCourses)}\n         degree = [0 for i in range(numCourses)]\n         q = []\n         counter = 0\n         for c,p in prerequisites:\n             course_map[c].append(p)\n             degree[p] += 1\n         \n         for i in range(numCourses):\n             if degree[i] == 0:\n                 q.append(i)\n                 counter += 1\n         while q:\n             cur = q.pop(0)\n             for p in course_map[cur]:\n                 degree[p] -= 1\n                 if degree[p] == 0:\n                     q.append(p)\n                     counter += 1\n         \n         return counter == numCourses\n", "class Solution:\n     def canFinish(self, n, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         def ok(node):\n             if seens[node] == -1:\n                 return False\n             if not seens[node]:\n                 seens[node] = -1\n                 for pre in pres[node]:\n                     if not ok(pre):\n                         return False\n                 seens[node] = 1\n             return True\n         \n         pres = [[] for _ in range(n)]\n         for cur, pre in prerequisites:\n             pres[cur].append(pre)\n         \n         seens = [0] * n\n         for node in range(n):\n             if not ok(node):\n                 return False\n         return True", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         from collections import deque\n         class Vertex(object):\n             def __init__(self):\n                 self.inDegree = 0\n                 self.visited = False\n                 self.adjList = []\n                 self.invAdjList = []\n             def info(self):\n                 print(self.adjList)\n                 print(self.invAdjList, self.inDegree)\n                 print(self.visited)\n         #initialization\n         vertices = []\n         for _ in range(numCourses):\n             vertices.append(Vertex())\n \n         for i in prerequisites:\n             pre = i[0]\n             post = i[1]\n             vertices[pre].adjList.append(post)\n             vertices[post].inDegree += 1\n             vertices[post].invAdjList.append(pre)\n \n         #BFS\n         q = deque()\n         coursesLearned = []\n         for i in range(numCourses):\n             if vertices[i].inDegree == 0:\n                 q.append(i)\n \n         while q:\n             course = q.popleft()\n             coursesLearned.append(course)\n             vertices[course].visited = True\n             for c2 in vertices[course].adjList:\n                 vertices[c2].inDegree -= 1\n                 if vertices[c2].inDegree == 0:\n                     q.append(c2)\n         return len(coursesLearned) == numCourses", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         \n         N = numCourses\n         \n #         # sol1: topo sort\n #         indegree = [0] * N\n         O = [set() for _ in range(N)]\n         for b, a in prerequisites:\n             O[a].add(b)\n #             indegree[b] += 1\n             \n #         q = [c for c in range(N) if indegree[c] == 0]\n #         done = 0\n #         while q:\n #             c = q.pop()\n #             done += 1\n #             for post in O[c]:\n #                 indegree[post] -= 1\n #                 if indegree[post] == 0:\n #                     q.append(post)\n #         return done == N # CAUTION\n         \n         # sol2: dfs\n         color = [0] * N\n         def dfs(i):\n             if color[i] == -1:\n                 return False\n             elif color[i] == 1:\n                 return True\n             color[i] = -1\n             if any(not dfs(j) for j in O[i]):\n                 return False\n             color[i] = 1\n             return True\n         \n         return all(map(dfs, range(N)))", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         N = numCourses\n         \n #         # sol1: topo sort\n #         pre = [0] * N\n #         O = [set() for _ in range(N)]\n #         for b, a in prerequisites:\n #             O[a].add(b)\n #             pre[b] += 1\n             \n #         stack = [c for c in range(N) if not pre[c]]\n #         done = 0\n #         while stack:\n #             c = stack.pop()\n #             done += 1\n #             for post in O[c]:\n #                 pre[post] -= 1\n #                 if pre[post] == 0:\n #                     stack.append(post)\n #         return done == N\n         \n         # sol2: dfs\n         O = [set() for _ in range(N)]\n         for b, a in prerequisites:\n             O[a].add(b) # it's O, not I\n         visit = [0] * N\n             \n         def dfs(i):\n             if visit[i] == -1:\n                 return False\n             elif visit[i] == 1:\n                 return True\n             \n             visit[i] = -1\n             if any(not dfs(j) for j in O[i]): # \"not\" dfs(j)\n                 return False\n             visit[i] = 1\n             return True\n         \n         return all(map(dfs, range(N)))", "class Solution:\n     def canFinish(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         \"\"\"\n         edges = {i: [] for i in range(numCourses)}\n         degree = [0 for i in range(numCourses)]\n         \n         for k, v in prerequisites:\n             edges[v].append(k)\n             degree[k] += 1\n         \n         q = []\n         for i in range(numCourses):\n             if degree[i] == 0:\n                 q.append(i)\n         \n         count = 0\n         while q:\n             node = q.pop()\n             count += 1\n             for nn in edges[node]:\n                 degree[nn] -= 1\n                 if degree[nn] == 0:\n                     q.append(nn)\n         return count == numCourses\n"]
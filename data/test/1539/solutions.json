["from collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    hh = list(map(int, input().split()))\n    ee = list(map(int, input().split()))\n    dd = defaultdict(set)\n    for i, h in enumerate(hh):\n        dd[h].add(i)\n    idx = sorted(list(range(n)), key=ee.__getitem__, reverse=True)\n    res = 0\n    for h, s in list(dd.items()):\n        x = sum(ee[i] for i in s)\n        le = len(s) - 1\n        if le:\n            for i in idx:\n                if hh[i] < h and i not in s:\n                    x += ee[i]\n                    le -= 1\n                    if not le:\n                        break\n        if res < x:\n            res = x\n    print(sum(ee) - res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def read_data():\n    n = int(input())\n    Ls = list(map(int, input().split()))\n    Ds = list(map(int, input().split()))\n    return n, Ls, Ds\n\ndef solve(n, Ls, Ds):\n    freqD = [0] * 201\n    for d in Ds:\n        freqD[d] += 1\n    LDs = list(zip(Ls, Ds))\n    LDs.sort(reverse = True)\n    prevL = 0\n    ni = 0\n    record = float('inf')\n    cost_long = 0\n    cost_me = 0\n    for L, D in LDs:\n        if prevL != L:\n            n -= ni\n            record = min(record, cost_long + calc_cost(ni, n, freqD))\n            prevL = L\n            ni = 0\n            cost_long += cost_me\n            if cost_long >= record:\n                return record\n            cost_me = 0\n        freqD[D] -= 1\n        cost_me += D\n        ni += 1\n    record = min(record, cost_long)\n    return record\n\ndef calc_cost(ni, n, freqD):\n    if n < ni:\n        return 0\n    cost = 0\n    for d, f in enumerate(freqD):\n        if n - f >= ni:\n            cost += f * d\n            n -= f\n        else:\n            cost += (n - ni + 1) * d\n            return cost\n    return float('inf')\n\nn, Ls, Ds = read_data()\nprint(solve(n, Ls, Ds))", "def main():\n    _, dd, res = input(), {}, 0\n    he = list(zip(list(map(int, input().split())), list(map(int, input().split()))))\n    for h, e in he:\n        le, x = dd.get(h, (-1, 0))\n        dd[h] = (le + 1, x + e)\n    he.sort(key=lambda _: _[1], reverse=True)\n    for h, (le, x) in list(dd.items()):\n        if le:\n            for h1, e in he:\n                if h1 < h:\n                    x += e\n                    le -= 1\n                    if not le:\n                        break\n        if res < x:\n            res = x\n    print(sum(e for h, e in he) - res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nINF = -1\narr = [0] * n\nd = [0] * 201\nl = list(map(int, input().split()))\ne = list(map(int, input().split()))\ns = 0\nfor i in range(n):\n    arr[i] = (l[i], e[i])\n    s += e[i]\n    d[e[i]] += 1\nl = []\ne = []\nans = [INF] * 3\nans[2] = 10 ** 10\n\np = arr[-1][0]\nk = [0, 0]        \narr.sort()\narr = [(-1, -1)] + arr\ne = 0\nc = 0\nfor i in range(n, -1, -1):\n    if arr[i][0] == p:\n        c += 1\n        e += arr[i][1]\n        d[arr[i][1]] -= 1\n    else:\n        if c == 1:\n            ans[0] = max(ans[0], e)\n        elif c == 2:\n            ans[1] = max(ans[1], arr[i + 1][1] + arr[i + 2][1])        \n        if c >= 2:\n            mx = c + c - 1\n            eng = k[1]\n            if k[0] >= n - mx:\n                ans[2] = min(ans[2], eng)\n            else:\n                g = n - mx - k[0]\n                j = 1\n                while j < 201 and g > 0:\n                    if d[j] > 0:\n                        if g > d[j]:\n                            eng += d[j] * j\n                            g -= d[j]\n                        else:\n                            eng += g * j\n                            g = 0\n                    j += 1\n                if g == 0:\n                    ans[2] = min(ans[2], eng)                     \n        k[0] += c\n        k[1] += e\n        c = 1\n        e = arr[i][1]\n        d[arr[i][1]] -= 1\n        p = arr[i][0]\nmn = 10 ** 10\nfor i in range(2):\n    ans[i] = s - ans[i]\nfor i in range(3):\n    if ans[i] != -1 and mn > ans[i]:\n        mn = ans[i]\nif mn != 10 ** 10:\n    print(mn)\nelse:\n    print(0)\n        \n\n", "\nn = int(input())\nlengths = list(map(int, input().split()))\ncosts = list(map(int, input().split()))\nsum = 0\nlength_to_sum = {}\nlength_to_count = {}\ncost_to_lengths = {}\n\nfor i in range(n):\n  length, cost = lengths[i], costs[i]\n  sum += cost\n  length_to_sum[length] = length_to_sum.setdefault(length, 0) + cost\n  length_to_count[length] = length_to_count.setdefault(length, 0) + 1\n  cost_to_lengths.setdefault(cost, []).append(length)\n\nlength_set = set(lengths)\nfor lengths in list(cost_to_lengths.values()):\n  lengths.sort()\nunique_costs = list(reversed(sorted(cost_to_lengths.keys())))\nbest = -1\n\nfor length in length_set:\n  total = sum - length_to_sum[length]\n  seek = length_to_count[length] - 1\n  if seek != 0:\n    for cost in unique_costs:\n      for x in cost_to_lengths[cost]:\n        if x >= length:\n          break\n        total -= cost\n        seek -= 1\n        if seek == 0:\n          break\n      if seek == 0:\n        break\n  if best == -1 or total < best:\n    best = total\n\nprint(best)\n", "#!/usr/bin/env python\n# 557C_table.py - Codeforces.com 557C Table quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line of the input contains integer n  the initial number of legs\nin the table Arthur bought.\n\nThe second line of the input contains a sequence of n integers li, where\nli is equal to the length of the i-th leg of the table.\n\nThe third line of the input contains a sequence of n integers di, where di\nis the number of energy units that Arthur spends on removing the i-th leg\noff the table.\nOutput\n\nPrint a single integer the minimum number of energy units that Arthur\nneeds to spend in order to make the table stable.\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\nimport random\nimport bisect\n\n# Additional libraries\n\n\n###############################################################################\n# Table Class\n###############################################################################\n\n\nclass Table:\n    \"\"\" Table representation \"\"\"\n\n    LIM = 201\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        self.legs = args[0]\n        self.energy = args[1]\n        self.n = len(self.legs)\n\n        # Sort lists\n        self.srt = sorted((l, e) for l, e in zip(self.legs, self.energy))\n        self.legs = []\n        self.energy = []\n        for n in self.srt:\n            self.legs.append(n[0])\n            self.energy.append(n[1])\n\n        # Prepare accumulator variables\n\n        self.itot = 0\n        self.ieltot = [0 for i in range(self.LIM)]\n        self.ielprev = [0 for i in range(self.LIM)]\n        self.ielprev_eng = 0\n        self.ires_eng = sys.maxsize\n\n    def get_new_layer_info(self, legs, energy):\n\n        ll = len(legs)\n        for (i, l) in enumerate(legs):\n\n            self.ilen = l\n            e = energy[i]\n\n            if i == 0:\n                self.itop_eng = sum(energy)\n\n            if i == 0 or self.ilen != prev:\n                self.irep = 0\n                self.ielsum_eng = 0\n                self.ielprev = list(self.ieltot)\n\n            self.irep += 1\n\n            self.itop_eng -= e\n            self.ielprev_eng += e\n            self.ielsum_eng += e\n            self.ieltot[e] += 1\n\n            if i == ll - 1 or legs[i+1] != self.ilen:\n                self.irem = self.irep - 1\n                self.irem_eng = self.ielprev_eng - self.ielsum_eng\n                if self.irem != 0:\n                    sumh = self.energyl_sum_high(self.ielprev, self.irem)\n                    self.irem_eng -= sumh\n                summ = self.itop_eng + self.irem_eng\n                self.ires_eng = min(self.ires_eng, summ)\n                yield\n            prev = self.ilen\n\n    def energyl_sum_high(self, l, n):\n        result = 0\n        for i in range(len(l) - 1, -1, -1):\n            e = l[i]\n            if e == 0:\n                continue\n            if n <= 0:\n                break\n            result += i * (n if e > n else e)\n            n -= e\n        return result\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        iter = self.get_new_layer_info(self.legs, self.energy)\n\n        for g in iter:\n            pass\n\n        result = self.ires_eng\n\n        return str(result)\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = int(uinput())\n    str1 = [int(s) for s in uinput().split()]\n    str2 = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = []\n    inputs.append(str1)\n    inputs.append(str2)\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Table(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # my tests\n        imax = 100000\n        test = \"0\\n\"\n        for i in range(imax):\n            test += str(i) + \" \"\n        test += \"\\n\"\n        for i in range(imax):\n            test += str(random.randint(1, 200)) + \" \"\n        calculate(test)\n\n        # Sample test 1\n        test = \"2\\n1 5\\n3 2\"\n        self.assertEqual(calculate(test), \"2\")\n        self.assertEqual(get_inputs(test), [[1, 5], [3, 2]])\n\n        # Other tests\n        test = \"3\\n2 4 4\\n1 1 1\"\n        self.assertEqual(calculate(test), \"0\")\n        test = \"6\\n2 2 1 1 3 3\\n4 3 5 5 2 1\"\n        self.assertEqual(calculate(test), \"8\")\n\n        test = (\n            \"10\\n20 1 15 17 11 2 15 3 16 3\\n\" +\n            \"129 114 183 94 169 16 18 104 49 146\")\n        self.assertEqual(calculate(test), \"652\")\n\n    def test_Table_class__basic_functions(self):\n        \"\"\" Table class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Table([[2, 2, 1, 1, 3, 3], [2, 2, 3, 3, 1, 1]])\n        self.assertEqual(d.legs[0], 1)\n        self.assertEqual(d.energy[0], 3)\n\n        # Get layer info (length, number of legs, energy list, energy sum)\n        iter = d.get_new_layer_info([1, 1, 2, 2, 4, 5], [2, 2, 3, 3, 1, 1])\n        next(iter)\n        self.assertEqual(d.itop_eng, 8)\n        self.assertEqual(d.ilen, 1)\n        self.assertEqual(d.irep, 2)\n        self.assertEqual(d.irem, 1)\n        self.assertEqual(d.irem_eng, 0)\n        self.assertEqual(d.ires_eng, 8)\n\n        next(iter)\n        self.assertEqual(d.ilen, 2)\n        self.assertEqual(d.irep, 2)\n        self.assertEqual(d.irem, 1)\n        self.assertEqual(d.irem_eng, 2)\n        self.assertEqual(d.ires_eng, 4)\n\n        # Get layer info (length, number of legs, energy list, energy sum)\n        d = Table([[], []])\n        iter = d.get_new_layer_info([1, 1, 2, 2, 3, 3], [5, 5, 4, 3, 2, 1])\n        next(iter)\n        self.assertEqual(d.ilen, 1)\n        self.assertEqual(d.irep, 2)\n        self.assertEqual(d.irem, 1)\n        self.assertEqual(d.irem_eng, 0)\n        self.assertEqual(d.ires_eng, 10)\n        next(iter)\n        self.assertEqual(d.ilen, 2)\n        self.assertEqual(d.irep, 2)\n        self.assertEqual(d.irem, 1)\n        self.assertEqual(d.irem_eng, 5)\n        self.assertEqual(d.ires_eng, 8)\n        next(iter)\n        self.assertEqual(d.ilen, 3)\n        self.assertEqual(d.irep, 2)\n        self.assertEqual(d.irem, 1)\n        self.assertEqual(d.irem_eng, 12)\n        self.assertEqual(d.ires_eng, 8)\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()", "rr = lambda: map(int, input().split())\n_, d, res, he = input(), {}, 0, list(zip(rr(), rr()))\nfor h, e in he:\n    f, x = d.get(h, (-1, 0))\n    d[h] = (f + 1, x + e)\nhe.sort(key = lambda x: x[1], reverse=True)\nfor h, (f, x) in d.items():\n    if not f:\n    \tres = max(x, res)\n    \tcontinue\n    for h1, e in he:\n        if h1 < h:\n            x += e\n            f -= 1\n            if not f: break\n    res = max(x, res)\nprint(sum(e for h, e in he) - res)", "rr = lambda: map(int, input().split())\n_, d, res, he = input(), {}, 0, list(zip(rr(), rr()))\nfor h, e in he:\n    f, x = d.get(h, (-1, 0))\n    d[h] = (f + 1, x + e)\nhe.sort(key = lambda x: x[1], reverse=True)\nfor h, (f, x) in d.items():\n    if not f:\n    \tres = max(x, res)\n    \tcontinue\n    for h1, e in he:\n        if h1 < h:\n            x += e\n            f -= 1\n            if not f: break\n    res = max(x, res)\nprint(sum(e for h, e in he) - res)", "rr = lambda: list(map(int, input().split()))\n_, d, res, he = input(), {}, 0, list(zip(rr(), rr()))\nfor h, e in he:\n    f, x = d.get(h, (-1, 0))\n    d[h] = (f + 1, x + e)\nhe.sort(key = lambda x: x[1], reverse=True)\nfor h, (f, x) in list(d.items()):\n    if not f:\n    \tres = max(x, res)\n    \tcontinue\n    for h1, e in he:\n        if h1 < h:\n            x += e\n            f -= 1\n            if not f: break\n    res = max(x, res)\nprint(sum(e for h, e in he) - res)\n", "\"\"\"\n\tAuthor\t\t: Arif Ahmad\n\tDate  \t\t: \n\tAlgo  \t\t: \n\tDifficulty\t: \n\"\"\"\nfrom sys import stdin, stdout\n\ndef main():\n\tn \t= int(stdin.readline())\n\tleg\t= [int(_) for _ in stdin.readline().split()]\n\td \t= [int(_) for _ in stdin.readline().split()]\n\n\tpairedLD = []\n\tfor x, y in zip(leg, d):\n\t\tpairedLD.append((x, y))\n\tpairedLD = sorted(pairedLD)\n\n\tlegSet \t\t= set()\n\tsuffixSum  \t= dict()\n\tlegFreq\t\t= dict()\n\tfor length, energy in zip(leg, d):\n\t\tlegSet.add(length)\n\t\tif length in suffixSum: \n\t\t\tsuffixSum[length] += energy\n\t\t\tlegFreq[length] += 1\n\t\telse: \n\t\t\tsuffixSum[length] = energy\n\t\t\tlegFreq[length] = 1\n\t\t\n\n\tlegList = [x for x in legSet]\n\tlegList = sorted(legList, reverse=True)\n\ttotal \t= 0\n\tfor length in legList:\n\t\tsuffixSum[length] += total\n\t\ttotal = suffixSum[length]\n\n\tans = int(2e7)\n\ttoRemove = 0\n\tavailable = 0\n\tremovable = [0] * 201\n\tlegList = sorted(legList)\n\tlistLen = len(legList)\n\tidx = 0\n\tfor i in range(listLen):\n\t\tcurr = 0\n\t\tif i+1 < listLen: curr += suffixSum[legList[i+1]]\n\t\ttoRemove = available - (legFreq[legList[i]] - 1)\n\t\tif toRemove < 0: toRemove = 0\n\t\tfor j in range(1, 201):\n\t\t\tif removable[j] != 0 and removable[j] <= toRemove:\n\t\t\t\tcurr += (removable[j] * j)\n\t\t\t\ttoRemove -= removable[j]\n\t\t\telif removable[j] > toRemove:\n\t\t\t\tcurr += (toRemove * j)\n\t\t\t\ttoRemove = 0\n\t\t\tif toRemove == 0: break\n\t\tavailable += legFreq[legList[i]]\n\t\tfor j in range(legFreq[legList[i]]): \n\t\t\tremovable[pairedLD[idx][1]] += 1\n\t\t\tidx += 1\n\t\tans = min(ans, curr)\n\n\tprint(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "rr = lambda: map(int, input().split())\n_, d, res, he = input(), {}, 0, list(zip(rr(), rr()))\nfor h, e in he:\n    f, x = d.get(h, (-1, 0))\n    d[h] = (f + 1, x + e)\nhe.sort(key = lambda x: x[1], reverse=True)\nfor h, (f, x) in d.items():\n    if not f:\n    \tres = max(x, res)\n    \tcontinue\n    for h1, e in he:\n        if h1 < h:\n            x += e\n            f -= 1\n            if not f: break\n    res = max(x, res)\nprint(sum(e for h, e in he) - res)", "f = lambda: map(int, input().split())\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in p.items():\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)", "f = lambda: map(int, input().split())\nk, n = 1, f()\ns = sorted(zip(f(), f()), key=lambda q: q[0])\n\nt = [0] * 201\nfor l, d in s: t[d] += 1\n\nj = [i for i in range(201) if t[i]]\nj.reverse()\n\nS = sum(i * t[i] for i in j)\nL, D = s.pop()\nt[D] -= 1\ns.reverse()\ns.append((0, 0))\n\nm = 0\nfor l, d in s:\n    if l < L:\n        L = l\n        for i in j:\n            if t[i] > k - 2:\n                D += i * (k - 1)\n                break\n            D += i * t[i]\n            k -= t[i]\n        m = max(m, D)\n        k = D = 0\n    k += 1\n    D += d\n    \n    t[d] -= 1\n    if not t[d]: j.remove(d)\n    \nprint(S - m)", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\nfor L, d in s:\n    k, D = p.get(L, (-1, 0))\n    p[L] = (k + 1, D + d)\nfor L, (k, D) in list(p.items()):\n    if k:\n        for l, d in s:\n            if l < L:\n                D += d\n                k -= 1\n                if k == 0: break\n    m = max(D, m)\nprint(sum(d for l, d in s) - m)\n", "f = lambda: list(map(int, input().split()))\n\nn, p, m, s = input(), {}, 0, sorted(zip(f(), f()), key=lambda q: -q[1])\n\nfor L, d in s:\n\n    k, D = p.get(L, (-1, 0))\n\n    p[L] = (k + 1, D + d)\n\nfor L, (k, D) in list(p.items()):\n\n    if k:\n\n        for l, d in s:\n\n            if l < L:\n\n                D += d\n\n                k -= 1\n\n                if k == 0: break\n\n    m = max(D, m)\n\nprint(sum(d for l, d in s) - m)\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\nlegs = list(zip(list(map(int, input().split())), list(map(int, input().split()))))\nlegs.sort(key=lambda x: x[1], reverse=True)\n# print(legs)\ncnt = {}\ns = 0\nfor i in range(n):\n    s += legs[i][1]\n    if legs[i][0] not in cnt:\n        cnt[legs[i][0]] = [1, legs[i][1]]\n    else:\n        cnt[legs[i][0]][0] += 1\n        cnt[legs[i][0]][1] += legs[i][1]\n\ntemp = sorted(cnt.items())\nmn = 9999999999999\nf = 0\nwhile temp:\n    l, t = temp.pop()\n    c, e = t\n    s -= e\n    val = s\n    i = 0\n    count = 0\n    while count < c-1:\n        if legs[i][0] < l:\n            count += 1\n            val -= legs[i][1]\n        i += 1\n        if i == n:\n            break\n    # print(l, c, e, val+f)\n    if val+f < mn:\n        mn = val+f\n    f += e\nprint(mn)\n", "def buscaEnergia(perna,qtd):\n    total = 0\n    if(qtd == 0):\n        return total\n    for i in range(len(d)-1,-1,-1):\n        for v in d[i]:\n            if(v <perna):\n                qtd-=1\n                total+=i\n            else:\n                break\n            if(qtd == 0):\n                break\n        if(qtd == 0):\n            break\n    return total\n\nn = int(input())\ntamanhoPerna = [int(i) for i in input().split()]\nenergiaPerna = [int(i) for i in input().split()]\nd = [[] for i in range(201)]\ncntPerna = [0]*100001\nsumPerna = [0]*100001\ncorteTotal = 0\nmaxTam = 0\n\nfor i in range(len(tamanhoPerna)):\n    d[energiaPerna[i]].append(tamanhoPerna[i])\n    sumPerna[tamanhoPerna[i]]+=energiaPerna[i]\n    cntPerna[tamanhoPerna[i]]+=1\n    corteTotal+=energiaPerna[i]\n    maxTam = max(tamanhoPerna[i],maxTam)\n\nfor i in range(len(d)):\n    d[i].sort()\n\ncurrentMin = float(\"inf\")\nfor perna in tamanhoPerna:\n    somaMesa = sumPerna[perna]\n    somaMesa+=buscaEnergia(perna,cntPerna[perna]-1)\n    currentMin = min(currentMin,corteTotal-somaMesa)\nprint(currentMin)\n", "def buscaEnergia(perna,qtd):\n    total = 0\n    if(qtd == 0):\n        return total\n    for i in range(len(d)-1,-1,-1):\n        for v in d[i]:\n            if(v <perna):\n                qtd-=1\n                total+=i\n            else:\n                break\n            if(qtd == 0):\n                break\n        if(qtd == 0):\n            break\n    return total\n\nn = int(input())\ntamanhoPerna = [int(i) for i in input().split()]\nenergiaPerna = [int(i) for i in input().split()]\nd = [[] for i in range(201)]\ncntPerna = [0]*100001\nsumPerna = [0]*100001\ncorteTotal = 0\nmaxTam = 0\n\nfor i in range(len(tamanhoPerna)):\n    d[energiaPerna[i]].append(tamanhoPerna[i])\n    sumPerna[tamanhoPerna[i]]+=energiaPerna[i]\n    cntPerna[tamanhoPerna[i]]+=1\n    corteTotal+=energiaPerna[i]\n    maxTam = max(tamanhoPerna[i],maxTam)\n\nfor i in range(len(d)):\n    d[i].sort()\n\ncurrentMin = float(\"inf\")\nfor perna in tamanhoPerna:\n    somaMesa = sumPerna[perna]\n    somaMesa+=buscaEnergia(perna,cntPerna[perna]-1)\n    currentMin = min(currentMin,corteTotal-somaMesa)\nprint(currentMin)\n"]
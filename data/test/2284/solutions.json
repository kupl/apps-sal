["from itertools import count\nfrom collections import deque\nfrom heapq import heappop, heappush\n \nclass Edge(object):\n    __slots__ = ('x', 'y', 'cap', 'cost', 'inv')\n    def __repr__(self):\n        return f'{self.x}-->{self.y} ({self.cap} , {self.cost})'\n\nclass MCFP(list):\n    inf = float('inf')\n    \n    def add(G, x, y, cap, cost):\n        G.extend(([] for i in range(max(0,max(x,y)+1-len(G)))))\n        e = Edge()\n        e.x=x ; e.y=y; e.cap=cap; e.cost=cost\n        z = Edge()\n        z.x=y ; z.y=x; z.cap=0; z.cost=-cost\n        e.inv=z ; z.inv=e\n        G[x].append(e)\n        G[y].append(z)\n \n    def solve(G, src, tgt, flowStop=float('inf')):\n        n = len(G)\n        flowVal = flowCost = 0\n        phi, prev, dist = [0]*n, [None]*n, [G.inf]*n\n        for it in count():\n            G.shortest(src, phi, prev, dist, tgt)\n            if prev[tgt]==None:\n                break\n            p = list(G.backward(tgt, src, prev))\n            z = min(e.cap for e in p)\n            for e in p: e.cap -= z ; e.inv.cap += z\n            flowVal += z\n            flowCost += z * (dist[tgt] - phi[src] + phi[tgt])\n            if flowVal==flowStop: break\n            for i in range(n):\n                if prev[i] != None:\n                    phi[i] += dist[i]\n                    dist[i] = G.inf\n        #print(it)\n        return flowVal, flowCost\n\n    def backward(G, x, src, prev):\n        while x!=src: e = prev[x] ; yield e ; x = e.x\n\n    def shortest_(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        Q = [(dist[src], src)]\n        k = 0\n        while Q:\n            k += 1\n            d, x = heappop(Q)\n            if dist[x]!=d: continue\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    heappush(Q, (dy, e.y))\n        print(k)\n        return\n\n    def shortest(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        Q = deque([src])\n        inQ = [0]*len(G)\n        sumQ = 0\n        while Q:\n            x = Q.popleft()\n            inQ[x] = 0\n            sumQ -= dist[x]\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    if inQ[e.y]==0:\n                        inQ[e.y]=1\n                        sumQ += dy\n                        if Q and dy > dist[Q[0]]: Q.append(e.y)\n                        else: Q.appendleft(e.y)\n                        avg = sumQ/len(Q)\n                        while dist[Q[0]] > avg: Q.append(Q.popleft())\n        return\n\n    def shortest_(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        H = [(0, src)]\n        inQ = [0]*len(G)\n        k = 0\n        while H:\n            k += 1\n            d, x = heappop(H)\n            if dist[x]!=d: continue\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    heappush(H, (dy, e.y))\n        print(k)\n        return\n\nimport sys, random\nints = (int(x) for x in sys.stdin.read().split())\nsys.setrecursionlimit(3000)\n\ndef main():\n    n, k = (next(ints) for i in range(2))\n    a = [next(ints) for i in range(n)]\n    b = [next(ints) for i in range(n)]\n    G = MCFP()\n    src, tgt, the_src = 2*n+1, 2*n+2, 2*n+3\n    G.add(the_src, src, k, 0)\n    for i in range(n):\n        G.add(src, i, 1, 0)\n        G.add(i, i+n, 1, a[i])\n        G.add(i+n, tgt, 1, b[i])\n        if i+1<n:\n            G.add(i, i+1, n, 0)\n            G.add(i+n, i+n+1, n, 0)\n    flowVal, ans = G.solve(the_src, tgt, k)\n    assert flowVal == k\n    print(ans)\n    return\n\ndef test(n,k):\n    R = random.Random(0)\n    yield n ; yield k\n    for i in range(n): yield R.randint(1, 10**9)\n    for i in range(n): yield R.randint(1, 10**9)\n\n#ints=test(1000, 800)\n\nmain()", "from collections import deque\nfrom heapq import heappop, heappush\n \nclass Edge(object):\n    __slots__ = ('x', 'y', 'cap', 'cost', 'inv')\n    def __repr__(self):\n        return '{e.x}-->{e.y} ({e.cap} , {e.cost})'.format(e=self)\n\nclass MCFP(list):\n    def add(G, x, y, cap, cost):\n        n = max(x, y) + 1\n        while len(G)<n: G.append([])\n        e = Edge() ; G[x].append(e)\n        w = Edge() ; G[y].append(w)\n        e.x=x ; e.y=y; e.cap=cap; e.cost=cost ; w.inv=e        \n        w.x=y ; w.y=x; w.cap=0; w.cost=-cost ; e.inv=w\n \n    def solve(G, src, tgt, flowStop=float('inf'), inf=float('inf')):\n        flowVal = flowCost = 0\n        n = len(G)\n        G.inQ = [0]*n\n        G.phi = h = [0]*n\n        G.prev = p = [None]*n\n        G.dist = d = [inf]*n\n        G.SPFA(src)\n        while p[tgt]!=None and flowVal<flowStop:\n            b = [] ; x = tgt\n            while x!=src: b.append(p[x]) ; x=p[x].x\n            z = min(e.cap for e in b)\n            for e in b: e.cap-=z ; e.inv.cap+=z\n            flowVal += z\n            flowCost += z * (d[tgt] - h[src] + h[tgt])\n            for i in range(n):\n                if p[i]!=None: h[i]+=d[i] ; d[i]=inf\n            p[tgt] = None\n            G.SPFA(src)\n        return flowVal, flowCost\n\n    def SPFA(G, src):\n        inQ = G.inQ ; prev = G.prev\n        d = G.dist ; h = G.phi\n        d[src] = 0\n        Q = deque([src])\n        while Q:\n            x = Q.popleft()\n            inQ[x] = 0\n            for e in G[x]:\n                if e.cap <= 0: continue\n                y = e.y ; dy = d[x] + h[x] + e.cost - h[y]\n                if dy < d[y]:\n                    d[y] = dy ; prev[y] = e\n                    if inQ[y]==0:\n                        inQ[y] = 1\n                        if not Q or dy > d[Q[0]]: Q.append(y)\n                        else: Q.appendleft(y)\n        return\n\nimport sys, random\nints = (int(x) for x in sys.stdin.read().split())\nsys.setrecursionlimit(3000)\n\ndef main():\n    n, k = (next(ints) for i in range(2))\n    a = [next(ints) for i in range(n)]\n    b = [next(ints) for i in range(n)]\n    G = MCFP()\n    src, tgt = 2*n+1, 2*n+2\n    for i in range(n):\n        G.add(src, i, 1, 0)\n        G.add(i, i+n, 1, a[i])\n        G.add(i+n, tgt, 1, b[i])\n        if i+1<n:\n            G.add(i, i+1, n, 0)\n            G.add(i+n, i+n+1, n, 0)\n    flowVal, ans = G.solve(src, tgt, k)\n    assert flowVal == k\n    print(ans)\n    #print(G)\n    return\n\ndef test(n,k):\n    R = random.Random(0)\n    yield n ; yield k\n    for i in range(n): yield R.randint(1, 10**9)\n    for i in range(n): yield R.randint(1, 10**9)\n\n#ints=test(1000, 800)\n\nmain()"]
["n = int(input())\nr1, c1 = map(int, input().split())\nr2, c2 = map(int, input().split())\na = [['1'] * (n + 2)]\nfor _ in range(n):\n    s = input()\n    d = ['1']\n    for i in s:\n        d.append(i)\n    d.append('1')\n    a.append(d)\na.append(['1'] * (n + 2))\ns = []\nf = []\nq = [[r1, c1]]\nwhile q:\n    x, y = q.pop()\n    a[x][y] = '1'\n    s.append([x, y])\n    if a[x - 1][y] == '0':\n        q.append([x - 1, y])\n    if a[x][y - 1] == '0':\n        q.append([x, y - 1])\n    if a[x + 1][y] == '0':\n        q.append([x + 1, y])\n    if a[x][y + 1] == '0':\n        q.append([x, y + 1])\nif [r2, c2] in s:\n    print(0)\nelse:\n    q = [[r2, c2]]\n    while q:\n        x, y = q.pop()\n        a[x][y] = '1'\n        f.append([x, y])\n        if a[x - 1][y] == '0':\n            q.append([x - 1, y])\n        if a[x][y - 1] == '0':\n            q.append([x, y - 1])\n        if a[x + 1][y] == '0':\n            q.append([x + 1, y])\n        if a[x][y + 1] == '0':\n            q.append([x, y + 1])\n    res = 10**10\n    for i in s:\n        for j in f:\n            res = min(res, (i[0] - j[0])**2 + (i[1] - j[1])**2)\n    print(res)", "from collections import defaultdict as dd\nimport math\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\nn=nn()\n\nr1, c1=mi()\n\nr2, c2=mi()\n\nr1=r1-1\nc1=c1-1\nr2=r2-1\nc2=c2-1\n\n\n\ng=[]\n\nfor i in range(n):\n\tg.append(li())\n\n#print(g)\n\n\ncc1=set()\n\n\nstack=[(r1,c1)]\n\nwhile stack:\n\t#print(stack)\n\tr,c=stack.pop()\n\tcc1.add((r,c))\n\tfor i in range(-1,2):\n\t\tfor j in range(-1,2):\n\t\t\tif not (i==0 and j==0):\n\t\t\t\tif i==0 or j==0:\n\t\t\t\t\tif r+i in range(0,n) and c+j in range(0,n):\n\t\t\t\t\t\tif not (r+i,c+j) in cc1:\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif g[r+i][c+j]=='0':\n\t\t\t\t\t\t\t\tstack.append((r+i,c+j))\n\n\ncc2=set()\n\n\nstack=[(r2,c2)]\n\nwhile stack:\n\tr,c=stack.pop()\n\tcc2.add((r,c))\n\tfor i in range(-1,2):\n\t\tfor j in range(-1,2):\n\t\t\tif not (i==0 and j==0):\n\t\t\t\tif i==0 or j==0:\n\t\t\t\t\tif r+i in range(0,n) and c+j in range(0,n):\n\t\t\t\t\t\tif not (r+i,c+j) in cc2:\t\t\t\t\t\n\t\t\t\t\t\t\tif g[r+i][c+j]=='0':\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tstack.append((r+i,c+j))\n\n\t\n#print(cc1,cc2)\ndist=10*n*n\n\nfor x,y in cc1:\n\tfor x1, y1 in cc2:\n\t\td=(x-x1)**2+(y-y1)**2\n\t\tdist=min(d,dist)\n\nprint(dist)\n\t\t\n", "import sys\nsys.setrecursionlimit(100000)\ndef hypot(a, b):\n    return a ** 2 + b ** 2\n\n\ndef bfs0(r, c):\n    nonlocal used\n    used[r][c] = True\n    comp0.append((r, c))\n    if r > 0:\n        if not used[r - 1][c] and matr[r - 1][c]:\n            bfs0(r - 1, c)\n    if r < n - 1:\n        if not used[r + 1][c] and matr[r + 1][c]:\n            bfs0(r + 1, c)\n    if c > 0:\n        if not used[r][c - 1] and matr[r][c - 1]:\n            bfs0(r, c - 1)\n    if c < n - 1:\n        if not used[r][c + 1] and matr[r][c + 1]:\n            bfs0(r, c + 1)\n\n\ndef bfs1(r, c):\n    nonlocal used\n    used[r][c] = True\n    comp1.append((r, c))\n    if r > 0:\n        if not used[r - 1][c] and matr[r - 1][c]:\n            bfs1(r - 1, c)\n    if r < n - 1:\n        if not used[r + 1][c] and matr[r + 1][c]:\n            bfs1(r + 1, c)\n    if c > 0:\n        if not used[r][c - 1] and matr[r][c - 1]:\n            bfs1(r, c - 1)\n    if c < n - 1:\n        if not used[r][c + 1] and matr[r][c + 1]:\n            bfs1(r, c + 1)\n\n\nn = int(input())\nr1, c1 = map(int, input().split())\nr2, c2 = map(int, input().split())\nmatr = [[] for i in range(n)]\nfor i in range(n):\n    for el in input():\n        if el == '0':\n            matr[i].append(True)\n        else:\n            matr[i].append(False)\n# print(matr)\nused = [[False] * n for i in range(n)]\ncomp0 = []\nbfs0(r1 - 1, c1 - 1)\nif used[r2 - 1][c2 - 1]:\n    print(0)\nelse:\n    comp1 = []\n    mi = 100000000000000\n    bfs1(r2 - 1, c2 - 1)\n    for el in comp0:\n        for ell in comp1:\n            mi = min(hypot(ell[0] - el[0], ell[1] - el[1]), mi)\n    print(mi)", "'''input\n3\n1 3\n3 1\n010\n101\n010\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\ndef valid(i,j):\n\tif i<0 or i>=n:\n\t\treturn 0\n\tif j<0 or j>=n:\n\t\treturn 0\n\t#print(i,j,mat)\n\tif vis[i][j]==1 or mat[i][j]==\"1\":\n\t\treturn 0\n\treturn 1\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef bfs(i,j):\n\tone=[(i,j)]\n\tvis[i][j]=1\n\ts=[(i,j)]\n\twhile s:\n\t\tx,y=s.pop(-1)\n\t\tfor k in range(4):\n\t\t\tif valid(x+dx[k],y+dy[k]):\n\t\t\t\tvis[x+dx[k]][y+dy[k]]=1\n\t\t\t\ts.append((x+dx[k],y+dy[k]))\n\t\t\t\tone.append((x+dx[k],y+dy[k]))\n\treturn one\n\n\nn=ri(1)\nx1,y1=[int(i)-1 for i in input().split()]\nx2,y2=[int(i)-1 for i in input().split()]\n\nmat=[]\nvis=[[0 for i in range(n)] for j in range(n)]\n\nfor i in range(n):\n\tmat.append(list(input()))\n\none=bfs(x1,y1)\ntwo=bfs(x2,y2)\n\nans=999999999999\n\nfor i,j in one:\n\tfor p,q in two:\n\t\tans=min(ans,(i-p)**2+(j-q)**2)\nprint(ans)", "n = int(input())\nr1,c1 = list(map(int, input().split()))\nr2,c2 = list(map(int, input().split()))\n\nr1 -=1\nc1 -=1\nr2 -=1\nc2 -=1\ng = []\nfor i in range(n):\n    g.append(input())\n\nd1 = {(r1,c1)}\nq = [(r1,c1)]\nwhile q:\n    v = q[0]\n    r,c = v\n    if r == r2 and c == c2:\n        print(0)\n        return\n    q = q[1:]\n    if r+1 >=0 and r+1 < n:\n        nv = (r+1, c)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d1:\n                d1.add(nv)\n                q.append(nv)\n    if r-1 >=0 and r-1 < n:\n        nv = (r-1, c)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d1:\n                d1.add(nv)\n                q.append(nv)\n    if c+1 >=0 and c+1 < n:\n        nv = (r, c+1)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d1:\n                d1.add(nv)\n                q.append(nv)\n    if c-1 >=0 and c-1 < n:\n        nv = (r, c-1)\n        if g[nv[0]][nv[1]] =='0':\n            if nv not in d1:\n                d1.add(nv)\n                q.append(nv)\n\nd2 = {(r2, c2)}\nq = [(r2,c2)]\nwhile q:\n    v = q[0]\n    r,c = v\n    q = q[1:]\n    if r+1 >=0 and r+1 < n:\n        nv = (r+1, c)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d2:\n                d2.add(nv)\n                q.append(nv)\n    if r-1 >=0 and r-1 < n:\n        nv = (r-1, c)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d2:\n                d2.add(nv)\n                q.append(nv)\n    if c+1 >=0 and c+1 < n:\n        nv = (r, c+1)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d2:\n                d2.add(nv)\n                q.append(nv)\n    if c-1 >=0 and c-1 < n:\n        nv = (r, c-1)\n        if g[nv[0]][nv[1]] == '0':\n            if nv not in d2:\n                d2.add(nv)\n                q.append(nv)\nans = 10**18\nfor v1 in d1:\n    for v2 in d2:\n        ans = min(ans, (v1[0] - v2[0])**2 + (v1[1] - v2[1])**2)\nprint(ans)\n\n", "import sys\nsys.setrecursionlimit(100000)\n\nN = int(input())\nr1, c1 = list(map(int, input().split()))\nr2, c2 = list(map(int, input().split()))\nr1 -= 1\nc1 -= 1\nr2 -= 1\nc2 -= 1\n\nA = [[int(a) for a in input()] for i in range(N)]\n\nX = [[0] * N for _ in range(N)]\nL = []\ndef dfs(r, c):\n    move = [[0,1], [0,-1], [-1,0], [1,0]]\n    X[r][c] = 1\n    L.append((r, c))\n    for m in move:\n        nr, nc = r+m[0], c+m[1]\n        if nr >= 0 and nr < N and nc >= 0 and nc < N:\n            if X[nr][nc] == 0 and A[nr][nc] == 0:\n                dfs(nr, nc)\n        \ndfs(r1, c1)\n\nif X[r2][c2]:\n    print(0)\nelse:\n    LL = [l for l in L]\n    \n    L = []\n    dfs(r2, c2)\n    \n    mi = 10**10\n    for ll in LL:\n        for l in L:\n            mi = min((ll[0]-l[0])**2+(ll[1]-l[1])**2, mi)\n    \n    print(mi)\n\n", "def add(ans, r, c):\n    if cells[r][c] == '0':\n        cells[r][c] = '1'\n        rc = r, c\n        ans.append(rc)\n\n\ndef dfs(r, c):\n    ans = [(r, c)]\n    for r, c in ans:\n        if c != 1:\n            add(ans, r, c - 1)\n        if c != n:\n            add(ans, r, c + 1)\n        if r != 1:\n            add(ans, r - 1, c)\n        if r != n:\n            add(ans, r + 1, c)\n    return ans\n\n\nn = int(input())\nr1, c1 = list(map(int, input().split()))\nr2, c2 = list(map(int, input().split()))\nres = 5000  # n ** 2 * 2\ncells = (['1'],) + tuple((['1'] + list(input()) for _ in range(n)))\ndfs1 = dfs(r1, c1)\nfor rs, cs in dfs(r2, c2):\n    for rt, ct in dfs1:\n        res = min(res, (rs - rt) ** 2 + (cs - ct) ** 2)\nprint(res)\n", "n = int(input())\nr1,c1 = list(map(int,input().split()))\nr2,c2 = list(map(int,input().split()))\nr1-=1\nr2-=1\nc1-=1\nc2-=1\nmaze = []\nfor i in range(n):\n\tmaze.append(input())\nlist1 = [(r1,c1)]\nlist2 = [(r2,c2)]\ntovisit = [(r1,c1)]\nwhile len(tovisit)>0:\n\tx,y = tovisit.pop()\n\tfor cx,cy in [(0,1),(0,-1),(1,0),(-1,0)]:\n\t\tif x+cx >= 0 and y+cy >= 0 and x+cx < n  and y+cy < n and (x+cx, y+cy) not in list1 and maze[x+cx][y+cy] == \"0\":\n\t\t\tlist1.append((x+cx, y+cy))\n\t\t\ttovisit.append((x+cx, y+cy))\nif (r2,c2) in list1:\n\tprint(0)\n\treturn\ntovisit = [(r2,c2)]\nwhile len(tovisit)>0:\n\tx,y = tovisit.pop()\n\tfor cx,cy in [(0,1),(0,-1),(1,0),(-1,0)]:\n\t\tif x+cx >= 0 and y+cy >= 0 and x+cx < n  and y+cy < n and (x+cx, y+cy) not in list2 and maze[x+cx][y+cy] == \"0\":\n\t\t\tlist2.append((x+cx, y+cy))\n\t\t\ttovisit.append((x+cx, y+cy))\nmini = 30000000\nfor i in list1:\n\tfor i2 in list2:\n\t\tans = (i[0] - i2[0])**2 + (i[1] - i2[1])**2\n\t\tmini = min(mini,ans)\nprint(mini)\n", "def dis(u,v):\n    x1,y1=u\n    x2,y2=v\n    return(( (x1-x2)**2 + (y1-y2)**2 ))\n\n\ndef adj(u):\n    x,y=u\n    t=[]\n    #print(x,y)\n    if x+1<n and a[x+1][y]=='0':\n        t.append([x+1,y])\n    if y+1<n and a[x][y+1]=='0':\n        t.append([x,y+1])\n    if x-1>=0 and a[x-1][y]=='0':\n        t.append([x-1,y])\n    if y-1>=0 and a[x][y-1]=='0':\n        t.append([x,y-1])\n    return(t)\n\ndef bfs(s):\n    ans=[s]\n    x,y=s\n    v2[x][y]=1\n    frontier=[s]\n    while frontier:\n        nex=[]\n        for u in frontier:\n            for v in adj(u):\n                if v2[v[0]][v[1]]==0:\n                    nex.append(v)\n                    v2[v[0]][v[1]]=1\n                    ans.append(v)\n        frontier=nex\n    return(ans)\n\n\nn=int(input())\nr1,c1=[int(i) for i in input().split(' ')]\nr2,c2=[int(i) for i in input().split(' ')]\na=[]\nfor i in range(n):\n    a.append(list(input()))\n\nv2=[[0 for i in range(n)] for j in range(n)]\n\nans1=bfs([r1-1,c1-1])\nans2=bfs([r2-1,c2-1])\nr=9999999999\nfor i in ans1:\n    for j in ans2:\n        #print(i,j)\n        r=min(r,dis(i,j))\nprint(r)\n\n\n", "from collections import deque\n\n\ndef BFS(a, vertex=None):\n    if vertex is None:\n        vertex = 1\n    s = [1]*len(a)\n    d = deque([vertex])\n    s[vertex] = 0\n    f = {vertex}\n    while len(d) > 0:\n        for q in a[d.popleft()]:\n            if s[q]:\n                d.append(q)\n                f.add(q)\n                s[q] = 0\n    return f\n\n\ndef components(a):\n    s = [1]*len(a)\n    d, q2 = [], 1\n    while q2 < len(a):\n        if s[q2]:\n            if len(a[q2]) == 0:\n                s[q2] = 0\n                d.append({q2})\n            else:\n                f = BFS(a, q2)\n                d.append(f)\n                for q in f:\n                    s[q] = 0\n        else:\n            q2 += 1\n    return d\n\n\nn = int(input())\nx1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\na = [[0]*(n+2)]+[[0]+list(map(int, [1-int(q) for q in list(input())]))+[0] for _ in range(n)]+[[0]*(n+2)]\nd = [[] for _ in range(n**2+1)]\nfor q in range(1, n+1):\n    for q1 in range(1, n+1):\n        if a[q][q1]:\n            if a[q-1][q1]:\n                d[(q-1)*n+q1].append((q-2)*n+q1)\n            if a[q+1][q1]:\n                d[(q-1)*n+q1].append(q*n+q1)\n            if a[q][q1-1]:\n                d[(q-1)*n+q1].append((q-1)*n+q1-1)\n            if a[q][q1+1]:\n                d[(q-1)*n+q1].append((q-1)*n+q1+1)\nx, y = (x1-1)*n+y1, (x2-1)*n+y2\ns = components(d)\ncomp_x, comp_y = [], []\nfor q in s:\n    if x in q:\n        comp_x = q\n    if y in q:\n        comp_y = q\nif comp_y == comp_x:\n    print(0)\nelse:\n    ans = float('inf')\n    for q in comp_x:\n        for q1 in comp_y:\n            x1, x2, y1, y2 = (q-1)//n+1, (q-1) % n+1, (q1-1)//n+1, (q1-1) % n+1\n            ans = min((x1-y1)**2+(x2-y2)**2, ans)\n    print(ans)\n", "from collections import deque\nn = int(input())\n\nr1, c1 = (int(t)-1 for t in input().split(' '))\nr2, c2 = (int(t)-1 for t in input().split(' '))\n\nmx = [input() for _ in range(n)]\n\nvisited = [[0] * n for _ in range(n)]\n\ndef bfs(start, mark):\n    q = deque()\n    q.append(start)\n\n\n    while len(q):\n        r, c = q.popleft()\n        if visited[r][c]: continue\n        visited[r][c] = mark\n\n        dirs = [(t[0] + r, t[1] + c) for t in [(0, 1), (1, 0), (-1, 0), (0, -1)] if t[0] + r < n and t[0] + r >= 0 and t[1] + c < n and t[1] + c >= 0]\n\n        dirs = [d for d in dirs if not visited[d[0]][d[1]] and mx[d[0]][d[1]] == '0']\n        for d in dirs:\n            q.append(d)\n\nbfs((r1, c1), 1)\nif visited[r2][c2] == 1:\n    print(0)\nelse:\n    bfs((r2, c2), 2)\n    firsts = [(i, j) for i in range(n) for j in range(n) if visited[i][j] == 1]\n    seconds = [(i, j) for i in range(n) for j in range(n) if visited[i][j] == 2]\n    result = min((f[0] - s[0])**2 + (f[1] - s[1])**2 for f in firsts for s in seconds)\n    print(result)\n", "n = int(input())\nr1, c1 = map(int, input().split())\nr1, c1 = r1 - 1, c1 - 1\nr2, c2 = map(int, input().split())\nr2, c2 = r2 - 1, c2 - 1\nT = [[] for i in range(n)]\nfor i in range(n):\n    a = list(input())\n    T[i] = a\n\nk = 0\nG = [[] for i in range(n * n)]\nfor i in range(n):\n    for j in range(n):\n        if T[i][j] == '0':\n            que = [(i, j, k)]\n            while que:\n                x, y, d = que.pop()\n                G[d].append((x, y))\n                T[x][y] = '1'\n                for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < n and T[nx][ny] == '0':\n                        T[nx][ny] = '1'\n                        que.append((nx, ny, d))\n            k += 1\n\ns = -1\ne = -1\nfor k in range(n * n):\n    if (r1, c1) in G[k]:\n        s = k\n    if (r2, c2) in G[k]:\n        e = k\n\nnum = float('inf')\nfor sx, sy in G[s]:\n    for ex, ey in G[e]:\n        num = min(num, abs(sx - ex) ** 2 + abs(sy - ey) ** 2)\n\nprint(num)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\nn = int(input())\nr1, c1 = [int(i) for i in input().split()]\nr2, c2 = [int(i) for i in input().split()]\nMAP = [[int(s) for s in input()] for i in range(n)]\nr1 -= 1\nc1 -= 1\nr2 -= 1\nc2 -= 1\n\ndef dfs(r, c, mark, A):\n    if r < 0 or r >= n or c < 0 or c >= n:\n        return\n    if MAP[r][c] == 1:\n        return\n    if MAP[r][c] == mark:\n        return\n    A.append((r, c))\n    MAP[r][c] = mark\n    for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        dfs(r+dr, c+dc, mark, A)\n\nA = []\ndfs(r1, c1, 2, A)\nif MAP[r1][c1] == MAP[r2][c2]:\n    print(0)\n    return\nB = []\ndfs(r2, c2, 3, B)\n\nans = 2 * n ** 2\nfor a, b in A:\n    ans = min(ans, min((a - c) ** 2 + (b - d) ** 2 for c, d in B))\n\nprint(ans)", "from sys import setrecursionlimit\nimport threading\n\nsetrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\n\ndef main():\n    dr = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n\n    def dfs(v, i):\n        used[v[0]][v[1]] = i\n        cm[i - 1] += [v]\n        for x in dr:\n            u = [v[0] + x[0], v[1] + x[1]]\n            if a[u[0]][u[1]] == 0 and used[u[0]][u[1]] == 0:\n                dfs(u, i)\n\n\n    n = int(input())\n    s = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    a = [list(map(int, list(input()))) + [1] for i in range(n)]\n    used = [[0] * n for i in range(n)]\n    cm = [[], []]\n    a += [[1] * n]\n    s[0] -= 1\n    s[1] -= 1\n    f[0] -= 1\n    f[1] -= 1\n    dfs(s, 1)\n    if used[f[0]][f[1]] == 1:\n        print(0)\n        return\n    dfs(f, 2)\n    ans = 10000\n    for p1 in cm[0]:\n        for p2 in cm[1]:\n            ans = min(ans, (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    print(ans)\n\n\nthread = threading.Thread(target=main)\nthread.start()", "import sys\nsys.setrecursionlimit(0x20000000)\ndef dfs(i,j,vis,g,c):\n\tvis[i][j]=1\n\tc.append((i,j))\n\t\"\"\"\n\tif i>0 and \n\t\tif j>0 and vis[i-1][j-1]==0:\n\t\t\tdfs(i-1,j-1,vis,g,c)\n\t\tif j<n-1 and vis[i-1][j+1]==0:\n\t\t\t\tdfs(i-1,j+1,vis,g,c)\n\tif i>0 and j<n-1 and vis[i-1][j+1]==0:\n\t\tdfs(i-1,j+1,vis,g,c)\n\tif i<n-1 and j>0 and vis[i+1][j-1]==0:\n\t\tdfs(i+1,j-1,vis,g,c)\n\tif i<n-1 and j<n-1 and vis[i+1][j+1]==0:\n\t\tdfs(i+1,j+1,vis,g,c)\n\t\"\"\"\n\tif i>0 and vis[i-1][j]==0 and g[i-1][j]==\"0\":\n\t\tdfs(i-1,j,vis,g,c)\n\tif i<n-1 and vis[i+1][j]==0 and g[i+1][j]==\"0\":\n\t\tdfs(i+1,j,vis,g,c)\n\tif j<n-1 and vis[i][j+1]==0 and g[i][j+1]==\"0\":\n\t\tdfs(i,j+1,vis,g,c)\n\tif  j>0 and vis[i][j-1]==0 and g[i][j-1]==\"0\":\n\t\tdfs(i,j-1,vis,g,c)\n\nn=int(input())\nr1,c1=map(int,input().split())\nr1-=1\nc1-=1\nr2,c2=map(int,input().split())\nr2-=1\nc2-=1\n# a=list(map(int,input().split()))\ng=[]\nfor i in range(n):\n\tg.append(input())\n\nvis=[[0 for i in range(n)] for i in range(n)]\ncom1=[]\ndfs(r1,c1,vis,g,com1)\ncom2=[]\ndfs(r2,c2,vis,g,com2)\n#print(com1,com2)\nm=1000000000000\nfor i in com1:\n\tfor j in com2:\n\t\td=(i[0]-j[0])**2+(i[1]-j[1])**2\n\t\tm=min(m,d)\nprint(m)", "from collections import deque\nfrom heapq import heappush, heappop\nN = int(input())\nsy, sx = map(int, input().split())\ngy, gx = map(int, input().split())\nsquare = [\"2\"*(N+2)] + [\"2\"+input()+\"2\" for _ in [0]*N] + [\"2\"*(N+2)]\n\n\ndef bfs(startx, starty, v, goal=None):\n\n    if v == 1:\n        visited = [[0]*(N+2) for _ in [0]*(N+2)]\n        visited[starty][startx] = 1\n        s = set()\n        add = s.add\n        dq = deque([(startx, starty)])\n        append, popleft = dq.append, dq.popleft\n\n        while dq:\n            x, y = popleft()\n            add((x, y))\n            for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\n                if square[ny][nx] == \"0\" and not visited[ny][nx]:\n                    visited[ny][nx] = 1\n                    append((nx, ny))\n\n        return s\n    else:\n        visited = [[10**9]*(N+2) for _ in [0]*(N+2)]\n        visited[starty][startx] = 0\n        heap = [(0, startx, starty)]\n        while heap:\n            cost, x, y = heappop(heap)\n            if (x, y) in goal:\n                return (x, y)\n            for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\n                new_cost = abs(nx-startx)**2 + abs(ny-starty)**2\n                if square[ny][nx] != \"2\" and visited[ny][nx] > new_cost:\n                    visited[ny][nx] = new_cost\n                    heappush(heap, (new_cost, nx, ny))\n\n        return (10**9, 10**9)\n\n\ns1 = bfs(sx, sy, 1)\ns2 = bfs(gx, gy, 1)\nif s1 == s2:\n    print(0)\n    return\n\nans = 10**9\nfor x, y in s1:\n    for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\n        if square[ny][nx] == \"1\":\n            destx, desty = bfs(nx, ny, 2, s2)\n            dist = abs(x-destx)**2 + abs(y-desty)**2\n            if ans > dist:\n                ans = dist\n\nprint(ans)", "from collections import deque\n\nn = int(input())\ny1, x1 = list(map(int, input().split(' ')))\ny2, x2 = list(map(int, input().split(' ')))\ny1 -= 1\nx1 -= 1\ny2 -= 1\nx2 -= 1\n\ndat = [input() for _ in range(n)]\n\nbfs1 = [-1] * ((n + 1) * (n + 1))\nbfs2 = [-1] * ((n + 1) * (n + 1))\n\ndef bfs(res, ys, xs):\n    nonlocal dat, n\n    d = deque()\n    d.append([ys, xs, 0])\n\n    while len(d) != 0:\n        y, x, pr = d.popleft()\n\n        if y == -1 or x == -1 or y >= n or x >= n:\n            continue\n\n        if dat[y][x] == '1':\n            continue\n\n        id = y * n + x\n        if res[id] != -1 and res[id] <= pr:\n            continue\n\n        res[id] = pr\n        pr += 1\n        d.append([y + 0, x - 1, pr])\n        d.append([y + 0, x + 1, pr])\n        d.append([y - 1, x + 0, pr])\n        d.append([y + 1, x + 0, pr])\n\nbfs(bfs1, y1, x1)\nbfs(bfs2, y2, x2)\n\nif bfs1[y2 * n + x2] != -1:\n    print(0)\n    return\n\nbest = 1000000000000\n\ndef pow2(x):\n    return x * x\n\nfor ys in range(n):\n    for xs in range(n):\n        ids = ys * n + xs\n        if bfs1[ids] == -1:\n            continue\n\n        for ye in range(n):\n            for xe in range(n):\n                ide = ye * n + xe\n                if bfs2[ide] == -1:\n                    continue\n\n                price = pow2(xs - xe) + pow2(ys - ye)\n                best = min(best, price)\n\nprint(best)\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/2/25 0:05\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Connect.py\n\nfrom collections import deque\n\n\ndef floodfill(x, y, grid, mark):\n    if grid[x][y] != '0':\n        return\n\n    n = len(grid)\n    queue = deque()\n    queue.append((x, y))\n\n    while queue:\n        cx, cy = queue[0]\n        queue.popleft()\n        if grid[cx][cy] == mark:\n            continue\n        grid[cx][cy] = mark\n\n        for d in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + d[0], cy + d[1]\n            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '0':\n                queue.append((nx, ny))\n\n\ndef main():\n    n = int(input())\n    r1, c1 = list(map(int, input().split()))\n    r2, c2 = list(map(int, input().split()))\n    r1, c1, r2, c2 = r1 - 1, c1 - 1, r2 - 1, c2 - 1\n\n    grid = []\n    for _ in range(n):\n        grid.append(list(input()))\n\n    floodfill(r1, c1, grid, '*')\n    floodfill(r2, c2, grid, '-')\n    # for i in range(n):\n    #     print(grid[i])\n\n    if grid[r1][c1] == grid[r2][c2]:\n        print(0)\n    else:\n        pos1, pos2 = [], []\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '*':\n                    pos1.append((i, j))\n                elif grid[i][j] == '-':\n                    pos2.append((i, j))\n\n        ret = float('inf')\n        # print(len(pos1))\n        # print(len(pos2))\n        for rs, cs in pos1:\n            for rt, ct in pos2:\n                ret = min(ret, (rt - rs) ** 2 + (ct - cs) ** 2)\n        print(int(ret))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nr1, c1 = list(map(int, input().split()))\nr2, c2 = list(map(int, input().split()))\nr1, c1, r2, c2 = r1-1, c1-1, r2-1, c2-1\ng = []\nfor i in range(n):\n    g.append(list(map(int, list(input()))))\nfrom_r1 = set()\nfrom_r2 = set()\nx = [0, 1, 0, -1]\ny = [1, 0, -1, 0]\nvisited = [[False for i in range(n)] for j in range(n)]\n\nstack = [(r1, c1)]\nwhile stack:\n    v = stack.pop()\n    if v[0] == r2 and v[1] == c2:\n        print(0)\n        return\n    visited[v[0]][v[1]] = True\n    for i in range(4):\n        if v[0] + x[i] < n and v[1] + y[i] < n and v[0] + x[i] >= 0 and v[1] + y[i]>= 0 and not visited[v[0] + x[i]][v[1] + y[i]]:\n            if g[v[0] + x[i]][v[1] + y[i]] == 0:\n                stack.append((v[0]+x[i], v[1]+y[i]))\n            else:\n                from_r1.add((v[0], v[1]))\n\n\nvisited = [[False for i in range(n)] for j in range(n)]\nstack = [(r2, c2)]\nwhile stack:\n    v = stack.pop()\n    visited[v[0]][v[1]] = True\n    for i in range(4):\n        if v[0] + x[i] < n and v[1] + y[i] < n and v[0] + x[i] >= 0 and v[1] + y[i] >= 0 and not visited[v[0] + x[i]][v[1] + y[i]]:\n            if g[v[0] + x[i]][v[1] + y[i]] == 0:\n                stack.append((v[0]+x[i], v[1]+y[i]))\n            else:\n                from_r2.add((v[0], v[1]))\n\nmin_value = 100000000\nfor i in from_r1:\n    for j in from_r2:\n        min_value = min((i[0] - j[0])**2 + (i[1] - j[1])**2, min_value)\nprint(min_value)\n\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(99999)\n\nn=int(input())\nx,y=map(int,input().split())\nr,c=map(int,input().split())\nadj=[list(map(int,input().rstrip()))for _ in range(n)]\n\ndx=[0,0,-1,1]\ndy=dx[::-1]\nvalid=lambda x,y:0<=x<n and 0<=y<n\nvisit=[[False]*51 for _ in range(51)]\ndef dfs(x,y,ans):\n    if visit[x][y]:return\n    visit[x][y]=True\n    ans.append((x,y))\n    for i in range(4):\n        nx=x+dx[i]\n        ny=y+dy[i]\n        if not valid(nx,ny):continue\n        if adj[nx][ny]:continue\n        dfs(nx,ny,ans)\nstart=[];end=[]\ndfs(x-1,y-1,start)\nif (r-1,c-1) in start:\n    print(0)\n    return\ndfs(r-1,c-1,end)\n\n\nans=10**100\nfor x,y in start:\n    for a,b in end:\n        ans=min(ans, (a-x)**2+(y-b)**2)\nprint(ans)", "from collections import deque\nimport sys\n\nn = int(input())\nr1, c1 = map(lambda x : int(x) - 1, input().split())\nr2, c2 = map(lambda x : int(x) - 1, input().split())\n\ngraph = []\ncomponents = []\nland_components = {}\n\nvisited = set()\n\nfor i in range(n):\n    row = input()\n    graph.append(row)\n\ndef find_component(r, c):\n    q = deque()\n    q.append((r, c))\n    queued = set()\n    queued.add((r, c))\n    result = []\n\n    while q:\n        cell = q.popleft()\n        result.append(cell)\n\n        consider = []\n\n        r, c = cell\n\n        if r > 0 and graph[r - 1][c] == '0':\n            consider.append((r - 1, c))\n        if c > 0 and graph[r][c - 1] == '0':\n            consider.append((r, c - 1))\n        if r < n - 1 and graph[r + 1][c] == '0':\n            consider.append((r + 1, c))\n        if c < n - 1 and graph[r][c + 1] == '0':\n            consider.append((r, c + 1))\n        for candidate in consider:\n            if candidate not in queued:\n                q.append(candidate)\n                queued.add(candidate)\n\n    return result\n\ncomp1 = find_component(r1, c1)\nif (r2, c2) in comp1:\n    print(0)\n    return\n\ncomp2 = find_component(r2, c2)\n\nbest = None\n\nfor tuple1 in comp1:\n    for tuple2 in comp2:\n        dist = pow(tuple1[0] - tuple2[0], 2) + pow(tuple1[1] - tuple2[1], 2)\n        if not best or best > dist:\n            best = dist\n\nprint(best)", "n, = map(int, input().split())\n\nrs,cs = map(int, input().split())\nrd,cd = map(int, input().split())\nrs-=1\ncs-=1\nrd-=1\ncd-=1\n\n\nE = []\nfor i in range(0,n):\n    E.append(list(input().split('\\n')[0]))\n\nS = []\nD = []\n\nimport queue\nq = queue.Queue()\nq.put((rs, cs))\n\n\ndef get_all_dirs(e):\n    dirs = []\n    a,b = e[0], e[1]\n    if a+1<n:\n        dirs.append((a+1, b))\n    if a-1>=0:\n        dirs.append((a-1, b))\n    if b+1<n:\n        dirs.append((a, b+1))\n    if b-1>=0:\n        dirs.append((a,b-1))\n    return dirs\n\n\ndef process_dirs(e):\n    dirs = get_all_dirs(e)\n    water = False\n    for d in dirs:\n        if E[d[0]][d[1]] == '1':\n            water = True\n        elif E[d[0]][d[1]] == '0':\n            q.put(d)\n            E[d[0]][d[1]] = '2'\n    return water\n\nwhile not q.empty():\n    e = q.get()\n    water = process_dirs(e)\n    if e[0] == rd and e[1] == cd:\n        print(0)\n        return\n    if water:\n        S.append(e)\n\n\nq.put((rd, cd))\n\nwhile not q.empty():\n    e = q.get()\n    water = process_dirs(e)\n    if water:\n        D.append(e)\n\nimport sys\ndef square(a):\n    return a*a\n\ndef dis(a, b):\n    return square(a[0]-b[0]) + square(a[1]-b[1])\n\nans = sys.maxsize\nfor i in S:\n    for j in D:\n        ans = min(ans, dis(i,j))\n\nprint(ans)"]
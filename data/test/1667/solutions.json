["import bisect;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn=int(input());\na=getIntList();\nanums=[(a[i], i) for i in range(n)];\nanums.sort();\nlocation=0;\nlength=0;\nk=1;\npieces=[];\ndef upgrade(x):\n    curr=(x, x+1)\n    i=bisect.bisect(pieces, curr);\n    joinLeft=False;\n    joinRight=False;\n    if i>0 and pieces[i-1][1]==x:\n        joinLeft=True;\n    if i<len(pieces) and pieces[i][0]==x+1:\n        joinRight=True;\n    if joinLeft:\n        if joinRight:\n            pieces[i-1]=(pieces[i-1][0], pieces[i][1])\n            pieces.pop(i);\n        else:\n            pieces[i-1]=(pieces[i-1][0], x+1);\n        return pieces[i-1][1]-pieces[i-1][0];\n    else:\n        if joinRight:\n            pieces[i]=(x, pieces[i][1])\n        else:\n            pieces.insert(i, curr);\n        return pieces[i][1]-pieces[i][0];\ncurrLength=0;\ncurrSum=0;\nfor x in anums:\n    currSum+=1;\n    val, num=x;\n    l=upgrade(num);\n    #print(pieces);\n    currLength=max(currLength, l);\n    #print(currLength,\"*\",len(pieces),\"==\",currSum)\n    if currLength*len(pieces)==currSum:\n        currK=val+1;\n        currLocation=len(pieces);\n        if currLocation>location:\n            location=currLocation;\n            k=currK;\n    if (location+2)*currLength-1>n:\n        break;\nprint(k);", "def main():\n    n = int(input())\n    ori_a = [int(x) for x in input().split()]\n    pos = {ori_a[i]: i for i in range(len(ori_a))}\n    seg = [dict(left=None, right=None) for i in range(len(ori_a))]\n\n    a = sorted(ori_a)\n    seg_size = 0\n    seg_num = 0\n    fi_k = a[0]\n    fi_seg_num = 0\n    for n_items, item in enumerate(a, 1):\n        i = pos[item]\n        seg[i][\"left\"], seg[i][\"right\"] = i, i\n        seg_num += 1\n        size = seg[i][\"right\"] - seg[i][\"left\"] + 1\n        if size > seg_size:\n            seg_size = size\n\n        li = pos[item] - 1\n        if 0 <= li:\n            if seg[li][\"right\"] == i - 1:\n                seg[i][\"left\"] = seg[li][\"left\"]\n                seg[li][\"right\"] = seg[i][\"left\"]\n                seg_num -= 1\n                size = seg[i][\"right\"] - seg[i][\"left\"] + 1\n                if size > seg_size:\n                    seg_size = size\n\n        ri = pos[item] + 1\n        if ri < n:\n            if seg[ri][\"left\"] == i + 1:\n                seg[i][\"right\"] = seg[ri][\"right\"]\n                seg[ri][\"left\"] = seg[i][\"left\"]\n                seg_num -= 1\n                size = seg[i][\"right\"] - seg[i][\"left\"] + 1\n                if size > seg_size:\n                    seg_size = size\n\n        if seg_size * seg_num == n_items and seg_num > fi_seg_num:\n            fi_seg_num = seg_num\n            fi_k = item + 1\n\n    print(fi_k)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def union(x,y,a,each):\n    x1=x\n    y1=y\n    while(a[x]>0):\n        x=a[x]\n    while(a[y]>0):\n        y=a[y]\n    each[-1*a[x]]-=1\n    each[-1*a[y]]-=1\n    #print('new size ',-1*(a[x]+a[y]), ' x ',x,' y ',y)\n    each[-1*(a[x]+a[y])]+=1\n    \n    \n    if(a[x]>a[y]):\n        a[y]+=a[x]\n        a[x]=y\n        res=y\n    else:\n        a[x]+=a[y]\n        a[y]=x\n        res=x\n    while(x1!=x):\n        temp=x1\n        x1=a[x1]\n        a[temp]=res\n    while(y1!=y):\n        temp=y1\n        y1=a[y1]\n        a[temp]=res\n    \n        \n\ndef find(x,y,a):\n    x1=x\n    y1=y\n    while(a[x]>0):\n        x=a[x]\n    while(a[y]>0):\n        y=a[y]\n    ans=False\n    if(y==x):\n        ans=True\n    while(y1!=y):\n        temp=a[y1]\n        a[y1]=y\n        y1=temp\n    while(x1!=x):\n        temp=a[x1]\n        a[x1]=x\n        x1=temp\n    return ans\ndef getsize(x,par):\n    x1=x\n    while(par[x]>0):\n        x=par[x]\n    ans=-1*par[x]\n    while(x!=x1):\n        temp=par[x1]\n        par[x1]=x\n        x1=temp\n    return ans\n        \n    \n\n\n\n\nn=int(input())\na=list(map(int,input().split()))\nfor i in range(n):\n    a[i]=[a[i],i]\na.sort()\npar=[-2.1 for i in range(n+1)]\n\nmax1=0\nmaxk=a[0][0]-1\nnumloc=0\neach=[0 for i in range(n+1)]\ni=0\nwhile(i<n):\n    curk=a[i][0]\n    while(i<n and a[i][0]==curk):\n        loc=a[i][1]\n        if(loc==0):\n            par[0]=-1\n            numloc+=1\n            each[1]+=1\n            if(par[1]!=-2.1):\n                numloc-=1\n                union(0,1,par,each)\n        elif(loc==n-1):\n            par[n-1]=-1\n            numloc+=1\n            each[1]+=1\n            if(par[n-2]!=-2.1):\n                numloc-=1\n                union(n-1,n-2,par,each)\n        else:\n            numloc+=1\n            each[1]+=1\n            par[loc]=-1\n            if(par[loc-1]!=-2.1):\n                union(loc,loc-1,par,each)\n                numloc-=1\n            if(par[loc+1]!=-2.1):\n                union(loc,loc+1,par,each)\n                numloc-=1\n        i+=1\n    #print('num loc is',numloc, ' k is ',curk)\n    #print(*each)\n    #print(*par)\n    #print('numl ', numloc,' size ',getsize(loc,par))\n    if(each[getsize(loc,par)]==numloc):\n        \n        if(numloc>max1):\n            maxk=curk\n            max1=numloc\nprint(maxk+1)\n\n        \n\n", "BigNum = 10 ** 10\n\nn = int(input())\naa = [BigNum] + list(map(int, input().split(' '))) + [BigNum]\nappear = sorted([(v, i) for i, v in enumerate(aa)])\n\nans = -1\nmaxLocations = 0\n\nintervals = [(i, i) for i in range(len(aa))]\nlengths = {}\n\ndef incCount(val):\n    nonlocal lengths\n    lengths[val] = lengths.get(val, 0) + 1\n\ndef decCount(val):\n    nonlocal lengths\n    if lengths[val] == 1:\n        del lengths[val]\n    else:\n        lengths[val] -= 1\n\ndef mergeIntervals(a, b):\n    return (min(a[0], b[0]), max(a[1], b[1]))\n\n\nfor v, i in appear:\n    if v == BigNum:\n        continue\n    \n    inter = intervals[i]\n    if aa[i - 1] < aa[i]:\n        li = intervals[i - 1]\n        decCount(li[1] - li[0] + 1)\n        inter = mergeIntervals(li, inter)\n    if aa[i] > aa[i + 1]:\n        ri = intervals[i + 1]\n        decCount(ri[1] - ri[0] + 1)\n        inter = mergeIntervals(ri, inter)\n\n    intervals[inter[0]] = inter\n    intervals[inter[1]] = inter\n    incCount(inter[1] - inter[0] + 1)\n\n    if len(lengths) == 1:\n        count = list(lengths.values())[0]\n        if count > maxLocations:\n            maxLocations = count\n            ans = v + 1\n        #print(v + 1, count)\n\nprint(ans)\n", "# https://codeforces.com/problemset/problem/982/D\n\nclass Union:\n    def __init__(self, n):\n        self.p    = {i:i for i in range(n)}\n        self.rank = {i:1 for i in range(n)} \n        \n    def find(self, x):\n        if x < 0: return x\n    \n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n            \n        return self.p[x]\n    \n    def union(self, x, y):\n        if x < 0 or y < 0:return\n        \n        x = self.find(x)\n        y = self.find(y)\n        \n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.p[x]     = y\n                self.rank[y] += self.rank[x]\n            else:\n                self.p[y]     = x\n                self.rank[x] += self.rank[y]\n\ndef add(d, key, val):\n    if key not in d:\n        d[key] = 0\n    d[key] += val     \n    \n    if d[key] == 0:\n        del d[key]\n    \ndef update(i, used, d, u):\n    used[i]  = True\n    add(d, 1, 1)\n    \n    if  i - 1 >=  0 and used[i-1] == True:\n        par_1   =  u.find(i)\n        par_2   =  u.find(i-1)\n        \n        size_1  =  u.rank[par_1]\n        size_2  =  u.rank[par_2]\n    \n        add(d, size_1, -1)\n        add(d, size_2, -1)\n        add(d, size_1+size_2, 1) \n        \n        u.union(par_1, par_2)\n    \n    if i + 1 < n and used[i+1] == True:\n        par_1   =  u.find(i)\n        par_2   =  u.find(i+1)\n        \n        size_1  =  u.rank[par_1]\n        size_2  =  u.rank[par_2]\n    \n        add(d, size_1, -1)\n        add(d, size_2, -1)\n        add(d, size_1+size_2, 1)\n        \n        u.union(par_1, par_2) \n\nn   = int(input())\na_  = list(map(int, input().split()))\na   = [(i, x) for i, x in enumerate(a_)]\na   = sorted(a, key=lambda x:x[1])\n\nu    = Union(n)\nd    = {}\nused = [False] * n\nans        = -1\nmax_length = -1\n\nfor (index, val) in a:\n    update(index, used, d, u)\n    #print(d, val)\n    \n    if len(d) == 1:\n        len_ = list(d.values())[0]\n        \n        if max_length < len_:\n            max_length = len_\n            ans        = val+1\n        \nprint(ans)  \n\n#8\n#1 12 2 11 10 3 9 4 8 5 14 6\n"]
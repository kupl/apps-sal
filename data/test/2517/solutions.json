["from itertools import permutations as p\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, r = map(int, input().split())\nR = list(map(int, input().split()))\nl = [[0]*n for _ in range(n)]\nfor _ in range(m):\n  a, b, c = map(int, input().split())\n  a -= 1\n  b -= 1\n  l[a][b] = c\n  l[b][a] = c\nF = floyd_warshall(l)\n\nans = float(\"inf\")\nfor v in p(R):\n  temp = 0\n  for i in range(r-1):\n    temp += F[v[i]-1][v[i+1]-1]\n  ans = min(ans, temp)\n  \nprint(int(ans))", "import itertools\nimport sys\nfrom scipy.sparse.csgraph import csgraph_from_dense\nfrom scipy.sparse.csgraph import floyd_warshall\ninput = sys.stdin.readline\n\n\nn, m, r = list(map(int, input().split()))\nvisiting_town = list(map(int, input().split()))\nedges = [[float('INF')]*n for _ in range(n)]\n\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    edges[a-1][b-1] = c\n\nG = csgraph_from_dense(edges, null_value=float('INF'))\ncomp_dist = floyd_warshall(G, directed=False)\n\ncandidates = []\nfor route in itertools.permutations(visiting_town):\n    result = 0\n    for _from, to in zip(route[:-1], route[1:]):\n        dist = comp_dist[_from-1][to-1]\n        result += dist\n    candidates.append(result)\n\nprint((int(min(candidates))))\n", "def main():\n    import itertools\n    n,m,r=list(map(int,input().split()))\n    rx=[int(i) for i in input().split()]\n    inf=100000000\n    wf=[[inf]*n for i in range(n)]\n    for i in range(n):\n        wf[i][i]=0\n\n    for i in range(m):\n        a,b,c=list(map(int,input().split()))\n        wf[a-1][b-1]=c\n        wf[b-1][a-1]=c\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if wf[i][j]>wf[i][k]+wf[k][j]:\n                    wf[i][j]=wf[i][k]+wf[k][j]\n    cnt=0\n    l=list(itertools.permutations([i for i in range(r)]))\n    cnt=inf\n    for i in l:\n        cnt_sub=0\n        for j in range(r-1):\n            cnt_sub+=wf[rx[i[j]]-1][rx[i[j+1]]-1]\n        cnt=min(cnt,cnt_sub)\n    print(cnt)\nmain()\n", "import itertools as it\nn,m,r=map(int,input().split())\nll=list(map(int,input().split()))\nd=[[float(\"inf\") for _ in range(n)] for _ in range(n)] #\u5404\u9802\u70b9\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\nfor i in range(m): #\u91cd\u8907\u306a\u3057ver\n    a,b,t=map(int,input().split())\n    d[a-1][b-1]=t\n    d[b-1][a-1]=t #\u6709\u5411\u30b0\u30e9\u30d5\u306e\u5834\u5408\u6d88\u3059\nfor i in range(n):\n    d[i][i]=0\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if d[i][j]>d[i][k]+d[k][j]:\n                d[i][j]=d[i][k]+d[k][j]\nans=10**9\nfor p in it.permutations(ll):\n    tmp=0\n    for j in range(r-1):\n        s,g=p[j]-1,p[j+1]-1\n        tmp+=d[s][g]\n    ans=min(ans,tmp)\nprint(ans)", "import sys, re\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom collections import deque, defaultdict, Counter\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop, heapify\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, M, R = MAP()\nr = LIST()\nABC = [LIST() for _ in range(M)]\n\ndist_matrix = [[0]*N for _ in range(N)]\nfor A, B, C in ABC:\n\tdist_matrix[A-1][B-1] = C\n\tdist_matrix[B-1][A-1] = C\n\n#for i in range(N):\n#\tprint(dist_matrix[i])\n\n#\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5  \u6ce8\u610f PyPy\u975e\u5bfe\u5fdc!!!!\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n \ngraph = csr_matrix(dist_matrix) #\u96a3\u63a5\u884c\u5217\u304b\u3089csr\u884c\u5217\u3092\u3064\u304f\u308b\ndist_matrix = floyd_warshall(graph, directed=False) #\u7121\u5411\u306e\u5834\u5408directed=False\n#dist_matrix\u306e\u4e2d\u8eab\u306ffloat\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f\uff01\n\n#for i in range(N):\n#\tprint(dist_matrix[i])\n\nans = INF\nfor x in permutations(r):\n\tdis = 0\n\tfor i in range(1, R):\n\t\tdis += dist_matrix[x[i-1]-1][x[i]-1]\n\tans = min(ans, dis)\n\nprint((int(ans)))\n\n\n\t\n", "# ABC073 D - joisino's travel\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\n\nN, M, R = map(int, input().split())\nr = list(map(int, input().split()))\n\ninf = 10**18\ndist = [[inf]*N for _ in range(N)]\nfor i in range(M):\n    A, B, C = map(int, input().split())\n    dist[A-1][B-1] = dist[B-1][A-1] = C\n\ndist = floyd_warshall(dist)\n\nans = inf\nfor rr in permutations(r):\n    cost = 0\n    for i in range(R-1):\n        cost += dist[rr[i]-1][rr[i+1]-1]\n    if cost < ans:\n        ans = cost\nprint(int(ans))", "import itertools\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, R = list(map(int, input().split()))\nr = tuple(map(int, input().split()))\n\nINF = 10**10\n\nd = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n    d[i][i] = 0\n\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    if d[a][b] > c:\n        d[a][b] = c\n        d[b][a] = c\n\n# for k in range(N):\n#     for i in range(N):\n#         for j in range(N):\n#             d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\nd = floyd_warshall(d)\n\n\nans = INF\nfor p in itertools.permutations(r):\n    dist = 0\n    for i in range(R-1):\n        dist += d[p[i]-1][p[i+1]-1]\n\n    ans = min(ans, dist)\n\nprint((int(ans)))\n", "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\nfrom itertools import permutations\n\nN, M, R = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\nd = [[0] * (N + 1) for _ in range(N + 1)]\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    d[A][B] = C\n    d[B][A] = C\ng = csgraph_from_dense(d)\ng = floyd_warshall(g)\n\nresult = 1000000000\nfor p in permutations(r):\n    t = 0\n    for i in range(R - 1):\n        t += g[p[i]][p[i + 1]]\n    result = min(result, t)\nprint((int(result)))\n", "import sys\nfrom collections import defaultdict\nfrom heapq import heapify,heappush,heappop\nreadline=sys.stdin.readline\n\ndef main():\n    N,M,R=list(map(int,readline().split()))\n    r=list(map(int,readline().split()))\n    ew=[tuple(map(int,readline().split())) for _ in range(M)]\n    edges=defaultdict(list)\n    wt=defaultdict(int)\n    for e in ew:\n        edges[e[0]].append(e[1])\n        edges[e[1]].append(e[0])\n        wt[(e[0],e[1])]=e[2]\n        wt[(e[1],e[0])]=e[2]\n    inf=float('inf')\n    def dijkstra(v):\n        dist=[inf]*(N+1)\n        dist[v]=0\n        vw=[(0,v)]\n        heapify(vw)\n        while vw:\n            cvw=heappop(vw)\n            if cvw[0]>dist[cvw[1]]:\n                continue\n            for w in edges[cvw[1]]:\n                cand=cvw[0]+wt[(cvw[1],w)]\n                if dist[w]>cand:\n                    dist[w]=cand\n                    heappush(vw,(cand,w))\n        return dist\n    distdict=dict((v,dijkstra(v)) for v in r)\n    mindist=inf\n    def permlist(lst):\n        tmp=[]\n        if not lst:\n            return [[]]\n        for i,x in enumerate(lst):\n            lstx=lst[:i]+lst[i+1:]\n            ret=permlist(lstx)\n            for e in ret:\n                e.append(x)\n            tmp.extend(ret)\n        return tmp\n    #print(distdict,permlist(r))\n    pathlist=[sum([distdict[v][w] for v,w in zip(lst,lst[1:])]) for lst in permlist(r)]\n    print((min(pathlist)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef warshallFloyd():\n    for k in range(N):\n        for i in range(N-1):\n            for j in range(i, N):\n                tmp = min(E[i][j], E[i][k] + E[k][j])\n                E[i][j] = E[j][i] = tmp\n\ndef dfs(c, p, d):\n    if c == R:\n        ans[0] = min(ans[0], d)\n        return\n    for i in range(R):\n        if used[i]:\n            continue\n        used[i] = True\n        if p == -1:\n            dfs(c+1, i, 0)\n        else:\n            dfs(c+1, i, d + E[S[p]-1][S[i]-1])\n        used[i] = False\n\nN, M, R = map(int, input().split())\nS = list(map(int, input().split()))\nE = [[float('inf')] * N for _ in range(N)]\nfor i in range(N):\n    E[i][i] = 0\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    E[a][b] = E[b][a] = c\nwarshallFloyd()\nans = [float('inf')]\nused = [False] * R\ndfs(0, -1, 0)\nprint(*ans)", "import sys\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\n\ninput = sys.stdin.readline\nans = -1\n\nn, m, r = list(map(int, input().split()))\nr  = list(map(int, input().split()))\nA, B, C = [], [], []\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    A.append(a-1)\n    B.append(b-1)\n    C.append(c)\n\nwf = floyd_warshall(csr_matrix((C, (A, B)), shape = (n, n)), directed=False)\n\nfor pi in permutations(r):\n    cand = 0\n    for r1, r2 in zip(pi, pi[1:]):\n        cand += int(wf[r1-1][r2-1])\n    if ans < 0 or ans > cand:\n        ans = cand\n\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\n\ndef solve(N: int, M: int, R: int, r: \"List[int]\", A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import coo_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    from itertools import permutations, islice\n    from functools import reduce\n    # coo_matrix((data, (i, j)), [shape=(M, N)])\n    mat = floyd_warshall(coo_matrix((C, (A, B)), shape=(N+1, N+1), dtype=np.int32).tocsr(), directed=False)\n    f = lambda a, b: (a[0]+mat[a[1]][b], b)\n    return int(min(reduce(f, q, (0, s))[0] for s, *q in permutations(r)))\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    R = int(next(tokens))  # type: int\n    r = [int(next(tokens)) for _ in range(R)]  # type: \"List[int]\"\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    print((solve(N, M, R, r, A, B, C)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "from itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\nn,m,r=map(int,input().split())\nvis=list(map(int,input().split()))\nINF=10**18\npath=[[INF]*n for i in range(n)]\nfor i in range(m):\n  a,b,c=map(int,input().split())\n  path[a-1][b-1]=c\n  path[b-1][a-1]=c\npath=floyd_warshall(path)\nans=10**18\nfor root in permutations(vis):\n  cnt=0\n  for j in range(1,r):\n    cnt+=path[root[j-1]-1][root[j]-1]\n  ans=min(ans,cnt)\nprint(int(ans))", "import sys\nfrom itertools import permutations\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, M, R = list(map(int, input().split()))\n\n    def warshall_floyd(d):\n        # d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n        for k in range(N):\n            for i in range(N):\n                for j in range(N):\n                    tmp = d[i][k] + d[k][j]\n                    if d[i][j] > tmp:\n                        d[i][j] = tmp\n        return d\n\n    r = list(map(int, input().split()))\n    d = [[float(\"inf\")] * N for i in range(N)]\n    for i in range(M):\n        x, y, z = list(map(int, input().split()))\n        d[x - 1][y - 1] = z\n        d[y - 1][x - 1] = z\n    for i in range(N):\n        d[i][i] = 0  # \u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\n    D = warshall_floyd(d)\n    P = list(permutations(r))\n    cost = float(\"inf\")\n    for p in P:\n        c = 0\n        for i in range(R - 1):\n            c += D[p[i] - 1][p[i + 1] - 1]\n        if c < cost:\n            cost = c\n    print(cost)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nimport itertools\n\ndef solve(N: int, M: int, R: int, r: \"List[int]\", A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    from scipy.sparse import csr_matrix\n    from scipy.sparse.csgraph import floyd_warshall\n    matrix = [[0]*N for _ in range(N)]\n    for i in range(M):\n        matrix[A[i]-1][B[i]-1] = C[i]\n        matrix[B[i]-1][A[i]-1] = C[i]\n    \n    dist_matrix = floyd_warshall(csgraph=matrix, directed=False)\n\n    perm = list(itertools.permutations(r)) \n\n    answer = float('inf')\n    for p in perm:\n        a = 0\n        for index in range(len(p)-1):\n            a += dist_matrix[p[index]-1][p[index+1]-1]\n        answer = min(answer,a)\n    print((int(answer)))\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    R = int(next(tokens))  # type: int\n    r = [int(next(tokens)) for _ in range(R)]  # type: \"List[int]\"\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    solve(N, M, R, r, A, B, C)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\nn,m,r,*L=map(int,open(0).read().split())\nf=floyd_warshall(csr_matrix((L[r+2::3],(L[r::3],L[r+1::3])),(n+1,n+1)),0)\nprint(int(min(sum(f[s,t]for s,t in zip(o,o[1:]))for o in permutations(L[:r]))))", "import itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path\n\nN,M,R = map(int, input().split())\nrs = np.array(list(map(int, input().split()))) -1\n\nnodes = np.full((N,N), np.inf) \nfor i in range(M):\n  a,b,c = map(int, input().split())\n  nodes[a-1,b-1] = nodes[b-1,a-1] = c\nmin_ds = shortest_path(nodes)\nres = float('inf')\nfor p in itertools.permutations(rs):\n  prev = p[0]\n  tmp = 0\n  for next in p[1:]:\n    tmp += min_ds[prev,next]\n    prev = next\n  res = min(res, tmp)\n\nprint(int(res))", "def main():\n  import numpy as np\n  import itertools\n  from scipy.sparse import csr_matrix\n  from scipy.sparse.csgraph import floyd_warshall\n  import sys\n  readline = sys.stdin.readline\n  readlines = sys.stdin.readlines\n\n  N, M, R= map(int, readline().split())\n  r = list(map(int,input().split()))\n  lines = readlines()\n  edge = np.array([line.split() for line in lines], dtype = np.int64).T\n  graph = csr_matrix((edge[2], (edge[:2] - 1)), (N, N))\n  distance_mat = floyd_warshall(graph,directed = False)\n  #print(distance_mat)\n  ans = float(\"inf\")\n  for town in itertools.permutations(r,R):\n    #print(town)\n    tmp = 0\n    for i in range(R-1):\n      tmp += distance_mat[town[i]-1][town[i+1]-1]\n    ans = min(ans,tmp)\n  print(int(ans))\nmain()", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nfrom itertools import permutations\n\nI = np.array(sys.stdin.read().split(), dtype=np.int64)\nn, m, R = I[:3]\nr = I[3:3+R] - 1\na, b, c = I[3+R:].reshape(-1, 3).T\na -= 1; b -= 1\ngraph = csr_matrix((c, (a, b)), shape=(n, n))\n\ndef main():\n    dist = floyd_warshall(graph, directed=False).astype(np.int64)\n    *perms, = permutations(r)\n    perms = np.array(perms)\n    res = dist[perms[:, :-1], perms[:, 1:]]\n    ans = np.amin(np.sum(res, axis=1))\n    return ans\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "import itertools\nfrom scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\nN, M, R = list(map(int, input().split()))\nr = [int(i) for i in input().split()]\n\nG = [[10**8]*(N+1) for _ in range(N+1)]\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    G[A][B] = C\n    G[B][A] = C\n\nDG = csgraph_from_dense(G, null_value=10**8)\nd = floyd_warshall(DG)\n\nans = 10**8\nfor route in itertools.permutations(r):\n    c = 0\n    for i in range(len(route)-1):\n        c += d[route[i]][route[i+1]]\n    ans = min(ans, c)\nprint((int(ans)))\n", "import heapq\nfrom itertools import permutations\nn, m, r = list(map(int, input().split()))\nR = list([int(x)-1 for x in input().split()])\nedges = [[]for _ in range(n)]\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    edges[a].append((c, b))\n    edges[b].append((c, a))\n\n\ndef dijkstra(init_v):\n    next_v = [(0, init_v)]\n    INF = 10**18\n    dist = [INF]*n\n    dist[init_v] = 0\n    while next_v:\n        d, v = heapq.heappop(next_v)\n        if dist[v] < d:\n            continue\n        for d, v2 in edges[v]:\n            if dist[v2] <= dist[v]+d:\n                continue\n            dist[v2] = dist[v]+d\n            heapq.heappush(next_v, (dist[v2], v2))\n    return dist\n\n\ndists = []\nfor x in R:\n    dist = dijkstra(x)\n    dists.append(dist)\n\nINF = 10**18\nans = INF\nfor subset in permutations(list(range(r))):\n    d = 0\n    for v, v2 in zip(subset, subset[1:]):\n        d += dists[v][R[v2]]\n    if d < ans:\n        ans = d\n\nprint(ans)\n", "# ABC073 D - joisino's travel\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\n\nN, M, R = map(int, input().split())\nr = list(map(int, input().split()))\n\ninf = 10**18\ndist = [[inf]*N for _ in range(N)]\nfor i in range(M):\n    A, B, C = map(int, input().split())\n    dist[A-1][B-1] = dist[B-1][A-1] = C\n\ndist = floyd_warshall(dist)\n\nans = inf\nfor rr in permutations(r):\n    cost = 0\n    for i in range(R-1):\n        cost += dist[rr[i]-1][rr[i+1]-1]\n    ans = min(ans, cost)\nprint(int(ans))", "from itertools import permutations\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph._shortest_path import floyd_warshall\n\n\ndef solve():\n    N, M, R = list(map(int, input().split()))\n    r = list([int(x)-1 for x in input().split()])\n    dist = [[0 for _ in range(N)] for _ in range(N)]\n    for _ in range(M):\n        A, B, C = list(map(int, input().split()))\n        dist[A-1][B-1] = C\n        dist[B-1][A-1] = C\n    fw = floyd_warshall(csr_matrix(dist))\n    \n    ans = 10**12\n    for visit in permutations(r, R):\n        m_sum = 0\n        for i in range(R-1):\n            m_sum += fw[visit[i]][visit[i+1]]\n        ans = min(ans, m_sum)\n    print((int(ans)))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, r = map(int,input().split()) #n:\u9802\u70b9\u6570\u3000m:\u8fba\u306e\u6570 r:\u8a2a\u308c\u308b\u753a\u306e\u6570\nR = list(map(int,input().split()))\n\nd = np.array([[float(\"inf\") for i in range(n)] for i in range(n)])\n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\nfor i in range(m):\n    x, y, z = map(int,input().split())\n    d[x-1][y-1] = z\n    d[y-1][x-1] = z\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\nwa = floyd_warshall(d)\n\n# \u8a2a\u308c\u308b\u753a\u306e\u9806\u756a\u3092\u9806\u5217\u3067\u7528\u610f\nfrom itertools import permutations\nptn = permutations(R)\n\nans = 10**19\nfor p in ptn:\n  cost = 0\n  roots = [(j-1, i-1) for i, j in zip(p, p[1:])]\n  for i, j in roots:\n    cost += wa[i][j]\n  ans = min(ans, cost)\n  \nprint(int(ans))", "import itertools\n\n\ndef dijkstra(v, G):\n    import heapq\n\n    ret = [10 ** 10] * len(G)\n    ret[v] = 0\n    q = [(ret[i], i) for i in range(len(G))]\n    heapq.heapify(q)\n\n    while len(q):\n        tmpr, u = heapq.heappop(q)\n        if tmpr == ret[u]:\n            for w, l in G[u]:\n                if ret[w] > ret[u] + l:\n                    ret[w] = ret[u] + l\n                    heapq.heappush(q, (ret[w], w))\n    return ret\n\n\nN, M, R = list(map(int, input().split()))\nr = list(map(int, input().split()))\nNE = [[] for _ in range(N)]\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    NE[A - 1].append((B - 1, C))\n    NE[B - 1].append((A - 1, C))\n\nRE = [[0] * R for _ in range(R)]\nfor iR in range(R):\n    for jR in range(iR + 1, R):\n        lR = dijkstra(r[iR] - 1, NE)[r[jR] - 1]\n        RE[iR][jR] = lR\n        RE[jR][iR] = lR\n\nans = 10 ** 10\nfor p in itertools.permutations(list(range(R))):\n    ans = min(ans, sum([RE[p[i]][p[i + 1]] for i in range(R - 1)]))\n\nprint(ans)\n", "# solution\n\nimport itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\nint1 = lambda x: int(x) - 1\n\nN, M, R = map(int, input().split())\nT = sorted(list(map(int1, input().split())))\nA = np.array([tuple(map(int, input().split())) for _ in range(M)]).T\n\nmatr = csr_matrix((A[2], (A[0] - 1, A[1] - 1)), shape=(N, N))\nway = [dijkstra(matr, indices=t, directed=False)[T].astype(int).tolist() for t in T]\n\nresult = float('inf')\nfor t in itertools.permutations(range(R)):\n    tmp = 0\n    for i in range(R - 1):\n        tmp += way[t[i]][t[i + 1]]\n    result = min(result, tmp)\nprint(result)", "# -*- coding: utf-8 -*-\n\nimport sys\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, M, R = MAP()\nA = [a-1 for a in LIST()]\nG = list2d(N, N, INF)\nfor i in range(M):\n    a, b, c = MAP()\n    a -= 1; b -= 1\n    G[a][b] = c\n    G[b][a] = c\n\n# \u5168\u4f53\u30b0\u30e9\u30d5\u306e\u6700\u77ed\u8ddd\u96e2(\u3053\u3053\u304b\u3089\u5fc5\u8981\u306a\u9802\u70b9\u9593\u3060\u3051\u4f7f\u3046)\nwf = floyd_warshall(G)\n\nans = INF\nfor r in range(R):\n    # TSP(\u5de1\u56de\u30bb\u30fc\u30eb\u30b9\u30de\u30f3)\n    dp = list2d(1<<R, R, INF)\n    dp[1<<r][r] = 0\n    for bit in range(1, (1<<R)-1):\n        for i in range(R):\n            if not (bit >> i & 1):\n                continue\n            for j in range(R):\n                if bit >> j & 1:\n                    continue\n                a, b = A[i], A[j]\n                dp[bit|1<<j][j] = min(dp[bit|1<<j][j], dp[bit][i] + int(wf[a,b]))\n    ans = min(ans, min(dp[-1]))\nprint(ans)\n", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nimport itertools\nI = [int(_) for _ in open(0).read().split()]\nN, M, R = I[:3]\nr = np.array(I[3:3 + R])\nABC = I[3 + R:]\nF = floyd_warshall(csr_matrix((ABC[2::3], (ABC[::3], ABC[1::3])), (N + 1, N + 1)), 0).astype(np.int64)\nans = float('inf')\nfor root in itertools.permutations(r, R):\n    ans = min(ans, sum(F[i,j] for i, j in zip(root, root[1:])))\nprint(ans)\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\n# \u5168\u9802\u70b9\u9593\u6700\u77ed\u8def\n# d[i][j]\u306f2\u9802\u70b9\u9593i, j\u9593\u306e\u79fb\u52d5\u30b3\u30b9\u30c8\u3092\u683c\u7d0d, M\u306f\u9802\u70b9\u6570\n\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\n\n\ndef main():\n    N, M, R = map(int,input().split()) #N:\u9802\u70b9\u6570\u3000M:\u8fba\u306e\u6570\n    d = [[float(\"inf\")]*N for i in range(N)]\n    #d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\n    r = list(map(int,input().split()))\n    for i in range(M):\n        u, v, w = map(int,input().split())\n        d[u-1][v-1] = w\n        d[v-1][u-1] = w\n    for i in range(N):\n        d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\n    cost = floyd_warshall(d)\n    L = list(permutations(r, R))\n    ret = 10**9\n    for rt in L:\n        cos = 0\n        for i in range(1,R):\n            cos += cost[rt[i]-1][rt[i-1]-1]\n        ret = min(ret, cos)\n    print(int(ret))\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\nINF = 1001001001\n\nN, M, R = list(map(int, input().split()))\nr = list(map(int, input().split()))\ngraph = [[INF]*N for _ in range(N)]\nfor i in range(M):\n    A, B, C = list(map(int, input().split()))\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\ndist_matrix = floyd_warshall(graph)\n\nans = INF\nfor root in permutations(r):\n    cnt = 0\n    for j in range(R-1):\n        cnt += dist_matrix[root[j]-1][root[j+1]-1]\n    ans = min(ans, cnt)\nprint((int(ans)))\n", "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nfrom itertools import permutations\n\nN, M, R = list(map(int, input().split()))\nr = list(map(int, input().split()))\nabc = [list(map(int, input().split())) for _ in range(M)]\n\nr = [e - 1 for e in r]\n\ng = [[0] * N for _ in range(N)]\nfor a, b, c in abc:\n\ta -= 1\n\tb -= 1\n\tg[a][b] = c\n\tg[b][a] = c\n\ndist = floyd_warshall(csr_matrix(g))\n\nans = float(\"inf\")\nfor pat in permutations(r, len(r)):\n\tsm = 0\n\tfor e1, e2 in zip(pat, pat[1:]):\n\t\tsm += dist[e1][e2]\n\n\tans = min(ans, sm)\n\nans = int(ans)\nprint(ans)\n", "from scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\n\nN, M, R = map(int, input().split())\n\ns = [[10**9]*N for i in range(N)]\nt = list(map(int, input().split()))\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    s[a-1][b-1] = c\n    s[b-1][a-1] = c\n    \ns = floyd_warshall(s)\nans = float('inf')\nfor i in permutations(t):\n    A_n = 0\n    for j in range(R-1):\n        A_n += s[i[j] - 1][i[j+1] - 1]\n    ans = min(ans, A_n)\n    \nprint(int(ans))", "import sys\nfrom itertools import permutations\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, R = list(map(int, readline().split()))\n    city = [int(s) - 1 for s in readline().split()]\n    ABC = list(map(int, read().split()))\n\n    G = [[INF] * N for _ in range(N)]\n    for a, b, c in zip(*[iter(ABC)] * 3):\n        G[a - 1][b - 1] = G[b - 1][a - 1] = c\n\n    for i in range(N):\n        G[i][i] = 0\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if G[i][j] > G[i][k] + G[k][j]:\n                    G[i][j] = G[i][k] + G[k][j]\n\n    ans = INF\n    for plan in permutations(city):\n        res = 0\n        for i in range(R - 1):\n            res += G[plan[i]][plan[i + 1]]\n        if ans > res:\n            ans = res\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\ndef solve(N: int, M: int, R: int, r: \"List[int]\", A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    from scipy.sparse import coo_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    from itertools import permutations\n    from functools import reduce\n    # coo_matrix((data, (i, j)), [shape=(M, N)])\n    mat = floyd_warshall(coo_matrix((C, (A, B)), shape=(N+1, N+1)).tocsr(), directed=False)\n    f = lambda a, b: (a[0]+mat[a[1]][b], b)\n    return int(min(reduce(f, q, (0, s))[0] for s, *q in permutations(r)))\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    R = int(next(tokens))  # type: int\n    r = [int(next(tokens)) for _ in range(R)]  # type: \"List[int]\"\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    print(solve(N, M, R, r, A, B, C))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n__starting_point()", "n,m,r_=list(map(int,input().split()))\nr=list(map(int,input().split()))\ng=[[]for _ in range(n)]\nfor _ in range(m):\n  a,b,c=list(map(int,input().split()))\n  a-=1\n  b-=1\n  g[a].append([b,c])\n  g[b].append([a,c])\nfrom heapq import heapify,heappush,heappop\ndef dks(t0,t1):\n  kyori=[-1]*n\n  todo=[[0,t0]]\n  heapify(todo)\n  while todo:\n    d,t=heappop(todo)\n    kyori[t]=d\n    if t==t1:break\n    l=g[t]\n    for li,c in l:\n      if kyori[li]==-1:\n        heappush(todo,[c+d,li])\n  return kyori[t1]\nans=pow(10,9)\nallr=[]\nimport sys\nsys.setrecursionlimit(10**7)\ndef dfs(s,k): #s:list, k:set\n  if len(k)==1:\n    s.append(k.pop())\n    return [s]\n  ret=[]\n  for ki in k:\n    ret.extend(dfs(s+[ki],k-{ki}))\n  return ret\nallr=dfs([],set(r))\nd={}\nfor i in range(r_-1):\n  for j in range(i+1,r_):\n    k=dks(r[i]-1,r[j]-1)\n    d[r[i]-1,r[j]-1]=k\n    d[r[j]-1,r[i]-1]=k\n\nfor j in range(len(allr)):\n  r1=allr[j]\n  ansi=0\n  for i in range(r_-1):\n    ansi+=d[(r1[i]-1,r1[i+1]-1)]\n  ans=min(ans,ansi)\nprint(ans)\n", "#!/usr/bin/env python3\n\nfrom itertools import permutations\nimport numpy as np\n\nHUGE = 10 ** 18\n\ndef main():\n    n, m, r = list(map(int, input().split()))\n    togo = list(map(int, input().split()))\n    adj_mat = [[HUGE for j in range(n)] for i in range(n)]\n    for i in range(n):\n        adj_mat[i][i] = HUGE\n    for i in range(m):\n        a, b, c = list(map(int, input().split()))\n        a0 = a - 1\n        b0 = b - 1\n        adj_mat[a0][b0] = c\n        adj_mat[b0][a0] = c\n    adj_mat = np.array(adj_mat)\n\n    wf(adj_mat, n)\n\n    res = HUGE\n    for way in permutations(togo):\n        assert len(way) > 1\n        x = 0\n        for i in range(len(way) - 1):\n            x += adj_mat[way[i] - 1][way[i + 1] - 1]\n        res = min(res, x)\n\n    print(res)\n\ndef wf(adj_mat, n):\n    for k in range(n):\n        for i in range(n):\n            adj_mat[i, :] = np.minimum(adj_mat[i, :], adj_mat[i][k] + adj_mat[k, :])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, re\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom collections import deque, defaultdict, Counter\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop, heapify\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, M, R = MAP()\nr = LIST()\nABC = [LIST() for _ in range(M)]\n\ndist_matrix = [[INF]*N for _ in range(N)]\n\nfor A, B, C in ABC:\n\tdist_matrix[A-1][B-1] = C\n\tdist_matrix[B-1][A-1] = C\n\nfor i in range(N):\n\tdist_matrix[i][i] = 0\n\n#for i in range(N):\n#\tprint(dist_matrix[i])\n\n#\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5  \u6ce8\u610f PyPy\u975e\u5bfe\u5fdc!!!!\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n \ngraph = csr_matrix(dist_matrix) #\u96a3\u63a5\u884c\u5217\u304b\u3089csr\u884c\u5217\u3092\u3064\u304f\u308b\ndist_matrix = floyd_warshall(graph, directed=False) #\u7121\u5411\u306e\u5834\u5408directed=False\n#dist_matrix\u306e\u4e2d\u8eab\u306ffloat\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f\uff01\n\n#for i in range(N):\n#\tprint(dist_matrix[i])\n\nans = INF\nfor x in permutations(r):\n\ttmp = 0\n\tfor i in range(1, R):\n\t\ttmp += dist_matrix[x[i-1]-1][x[i]-1]\n\tans = min(ans, tmp)\n\nprint((int(ans)))\n\t\n", "from itertools import permutations\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    N, M, RR = map(int, input().split())\n    R = list(map(int, input().split()))\n    INF = float(\"inf\")\n    T = [[INF] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = tuple(map(int, input().split()))\n        T[a-1][b-1] = c\n        T[b-1][a-1] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if T[i][j] > T[i][k]+T[k][j]:\n                    T[i][j] = T[i][k]+T[k][j]\n    ans = INF\n    for rs in permutations(R):\n        cost = 0\n        for i in range(RR-1):\n            cost += T[rs[i]-1][rs[i+1]-1]\n        ans = min(ans, cost)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import permutations as p\n \nfrom scipy.sparse.csgraph import floyd_warshall\n \nn, m, r = map(int, input().split())\nR = list(map(int, input().split()))\nl = [[0]*n for _ in range(n)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    l[a][b] = c\n    l[b][a] = c\nF = floyd_warshall(l)\n \nans = float(\"inf\")\nfor v in p(R):\n    temp = 0\n    for i in range(r-1):\n        temp += F[v[i]-1][v[i+1]-1]\n    ans = min(ans, temp)\nprint(int(ans))", "n,m,R = map(int,input().split())\nr = list(map(int,input().split()))\n\nfrom itertools import permutations\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\ncost = np.ones((n,n))*float('inf')\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    cost[a-1][b-1]=cost[b-1][a-1]=c\nd = floyd_warshall(cost)\ndef main():\n    m = float('inf')\n\n    for j in permutations(r):\n        l = 0\n        for i in range(len(j)-1):\n            s,t = j[i],j[i+1]\n            l += d[s-1][t-1]\n        if l<m:\n            m = l\n    print(int(m))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# https://atcoder.jp/contests/abc073/tasks/abc073_d\n\nimport sys\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\n\n# default import\nfrom itertools import product, permutations, combinations\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u304b\uff1f\n# \u5168\u70b9\u9593\u306e\u6700\u5c0f\u8ddd\u96e2\u3092\u53d6\u5f97\n# r\u306b\u3064\u3044\u3066permutation\u3057\u3066\u3002\u305d\u306e\u901a\u308a\u306b\u8a2a\u308c\u305f\u3068\u304d\u306e\u8ddd\u96e2\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\n# \u6700\u5c0f\u5024\u3092\u9078\u3076\n\nN, M, r = read_ints()\nR = [x - 1 for x in read_ints()]\nadj_mat = [[0] * N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = read_ints()\n    a -= 1\n    b -= 1\n    adj_mat[a][b] = c\n    adj_mat[b][a] = c\n\n# print(csr_matrix(adj_mat, dtype='int'))\nD = dijkstra(csr_matrix(adj_mat, dtype='int'), directed=False)\n# print(D)\n# \u5168\u63a2\u7d22\u30d1\u30fc\u30c8\nans = 2 ** 31\n\n\ndef get_kyori(p):\n    ret = 0\n    for ps, pt in zip(p[:-1], p[1:]):\n        ret += D[ps, pt]\n    return ret\n\n\nfor p in permutations(R):\n    ans = min(ans, get_kyori(p))\nprint((int(ans)))\n", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, M, R = list(map(int, input().split()))\n\nRS = list(map(int, input().split()))\n\nG = [[] for _ in range(N + 1)]\n\nfor i in range(M):\n    A, B, C = list(map(int, input().split()))\n    G[A].append((B, C))\n    G[B].append((A, C))\n\n\ndef dijkstra(s):\n    d = [1 << 28] * (N + 1)\n    d[s] = 0\n    q = []\n    heapq.heappush(q, (0, s))\n\n    while q:\n        cur = heapq.heappop(q)\n\n        if d[cur[1]] != cur[0]:\n            continue\n\n        for nx in G[cur[1]]:\n            if d[nx[0]] > cur[0] + nx[1]:\n                d[nx[0]] = cur[0] + nx[1]\n                heapq.heappush(q, (cur[0] + nx[1], nx[0]))\n\n    return d\n\n\nDIRS = [dijkstra(s) for s in RS]\nMAT = [[d[r] for r in RS] for d in DIRS]\n\nmem = {}\n\n\ndef solve(idx, st):\n    if st == (1 << R) - 1:\n        return 0\n    if (idx, st) in mem:\n        return mem[(idx, st)]\n\n    ret = 1 << 28\n    for i in range(R):\n        if ((st >> i) & 1) == 0:\n            ret = min(ret, solve(i, st | (1 << i)) + MAT[idx][i])\n\n    mem[(idx, st)] = ret\n    return ret\n\n\nprint((min([solve(i, 1 << i) for i in range(R)])))\n", "from scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\nfrom itertools import permutations\ndef main():\n    N, M, R = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    r = [i-1 for i in r]\n    l = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        l[a][b] = c\n        l[b][a] = c\n    G = csr_matrix(l)\n    dd = dijkstra(G, directed=False)\n    ans = 10**100\n    for i in permutations(r, len(r)):\n        t = 0\n        for j in range(len(r)-1):\n            t += dd[i[j]][i[j+1]]\n        ans = min(ans, t)\n    return int(ans)\nprint((main()))\n", "import sys\nfrom itertools import permutations\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, M, R = list(map(int, input().split()))\n    r = list([int(x) - 1 for x in input().split()])\n    P = permutations(r)\n\n    dp = [[float(\"inf\")] * N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = 0\n\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        dp[a][b] = c\n        dp[b][a] = c\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                tmp = dp[i][k] + dp[k][j]\n                if tmp < dp[i][j]:\n                    dp[i][j] = tmp\n\n    ans = float(\"inf\")\n    for p in P:\n        tmp = 0\n        for i in range(R - 1):\n            tmp += dp[p[i]][p[i + 1]]\n\n        if tmp < ans:\n            ans = tmp\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nimport itertools\nfrom collections import defaultdict\n\n\nn, m, r = list(map(int, input().split()))\nvisiting_town = list(map(int, input().split()))\n\nedges = [[] for i in range(n+1)]\nfor _ in range(m):\n    _from, to, distance = list(map(int, input().split()))\n    edges[_from].append([to, distance])\n    edges[to].append([_from, distance])\n\n\ncomp_edges = defaultdict(dict)\nfor _from in visiting_town:\n    seen = [False] * (n+1)\n    todo = []\n    for to, dist in edges[_from]:\n        heapq.heappush(todo, [dist, to])\n\n    while todo:\n        dist, node = heapq.heappop(todo)\n        if seen[node]:\n            continue\n\n        seen[node] = dist\n        for to, add_dist in edges[node]:\n            if seen[to] or to == _from:\n                continue\n            new_dist = dist + add_dist\n            heapq.heappush(todo, [new_dist, to])\n\n    for to in visiting_town:\n        if to == _from:\n            continue\n        comp_edges[_from][to] = seen[to]\n\ncandidates = []\nfor route in itertools.permutations(visiting_town):\n    result = 0\n    for _from, to in zip(route[:-1], route[1:]):\n        if to in comp_edges[_from]:\n            dist = comp_edges[_from][to]\n            result += dist\n        else:\n            break\n    candidates.append(result)\n\nprint((min(candidates)))\n", "import sys\nimport numpy as np \nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nfrom itertools import permutations\n\nI = np.array(sys.stdin.read().split(), dtype=np.int64)\nn, m, R = I[:3]\nr = I[3:3+R] - 1\na, b, c = I[3+R:].reshape(-1, 3).T\ngraph = csr_matrix((c, (a-1, b-1)), shape=(n, n))\n\ndef main():\n    dist = floyd_warshall(graph, directed=False).astype(np.int64)\n    \n    perms = np.array(list(permutations(r)))\n    res = dist[perms[:, :-1], perms[:, 1:]]\n    ans = np.amin(np.sum(res, axis=1))\n    return ans\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "import itertools\nimport sys\n\ndef main():\n  input = sys.stdin.readline\n  n, m, r = map(int, input().split())\n  R = [int(x) for x in input().split()]\n  inf = pow(10, 9)+7\n\n  roads = [[inf]*n for _ in range(n)]\n  for i in range(m):\n    a, b, c = map(int, input().split())\n    roads[a-1][b-1] = c\n    roads[b-1][a-1] = c\n\n  for k in range(n):\n    for i in range(n):\n      for j in range(n):\n        if roads[i][j] > roads[i][k]+roads[k][j]:\n          roads[i][j] = roads[i][k]+roads[k][j]\n\n  ans = inf\n  for value in itertools.permutations(R):\n    sub = 0\n    for k in range(r-1):\n      sub += roads[value[k]-1][value[k+1]-1]\n    if ans > sub:\n      ans = sub\n\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "from scipy.sparse.csgraph import csgraph_from_dense,dijkstra,floyd_warshall\nN,M,R = map(int,input().split())\n\nmachi = list(map(int,input().split()))\n\nList = [[10**6]*(N) for i in range(N)]\nfor i in range(M):\n  a,b,c = map(int,input().split())\n  \n  if List[a-1][b-1] > c:\n    List[a-1][b-1] = c\n    List[b-1][a-1] = c\nG = csgraph_from_dense(List, null_value=10**6)\nd = floyd_warshall(G)\n\nimport itertools\na = list(itertools.permutations(machi))\narr = []\nfor i in a:\n  ans = 0\n  for j in range(R):\n    if j != R-1 :\n      ans += d[i[j]-1][i[j+1]-1]\n  arr.append(ans) \n  \nprint(int(min(arr)))", "from itertools import permutations\nimport numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\nN, M, R = map(int, input().split())\nR = list(map(int, input().split()))\nA, B, C = np.array([input().split() for _ in range(M)], dtype=int).T\nG = csr_matrix((C, (A - 1, B - 1)), shape=(N, N))\npath = dijkstra(G, directed=False)\npath = (path + 0.5).astype(int)\n\nans = 10 ** 18\nfor p in permutations(R):\n    cnt = 0\n    for x, y in zip(p[:-1], p[1:]):\n        x -= 1\n        y -= 1\n        cnt += path[x][y]\n    ans = min(ans, cnt)\n\nprint(ans)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\nfrom itertools import permutations\n\nn,m,R = map(int, input().split())\nr = list(map(int, input().split()))\nr = [i-1 for i in r]\nabc = [list(map(int, input().split())) for i in range(m)]\nedge = [[10 ** 9] * (n) for i in range(n)]\nfor a,b,c in abc:\n  a-=1\n  b-=1\n  edge[a][b] = c\n  edge[b][a] = c\nd = floyd_warshall(edge)\nans = 10 ** 18\nfor i in permutations(r):\n  tmp = 0\n  for j in range(R-1):\n    tmp += d[i[j]][i[j+1]]\n  ans = min(ans,tmp)\nprint(int(ans))", "from itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\n\nINF = 10 ** 18\nN, M, R = map(int, input().split())\nr = list(map(int, input().split()))\ndp = [[INF for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if i == j:\n            dp[i][j] = 0\n\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    dp[a - 1][b - 1] = c\n    dp[b - 1][a - 1] = c\n\nwf = floyd_warshall(dp)\nans = INF\nfor i in permutations(r):\n    tmp = 0\n    for j in range(1, len(i)):\n        tmp += wf[i[j - 1] - 1][i[j] - 1]\n    ans = min(ans, tmp)\n\nprint(int(ans))", "from itertools import permutations, combinations\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\nN,M,R = map(int,input().split())\nr = list(map(int,input().split()))\nr = [r[i]-1 for i in range(R)]\nvve = [list(map(int,input().split())) for i in range(M)]\nv1,v2,edge = zip(*vve)\nv1 = list(v1)\nv2 = list(v2)\nfor i in range(M):\n  v1[i] -= 1\n  v2[i] -= 1\ncsr = csr_matrix((edge,(v1,v2)),shape = (N,N))\ndist = [[0 for j in range(R)] for i in range(R)]\nfor i,j in combinations(range(R),2):\n  r1,r2=r[i],r[j]\n  dist[i][j] = int(dijkstra(csr, directed = False,indices = r1)[r2])\n  dist[j][i] = dist[i][j]\nans = 10**18\nfor x in permutations(range(R)):\n  distsum = 0\n  for i in range(1,R):\n    distsum += dist[x[i]][x[i-1]]\n  ans = min(ans,distsum)\nprint(ans)", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    inf = 10**17\n    #mod = 10**9 + 7\n\n    N,M,R = map(int, input().split())\n    r = list(map(int, input().split()))\n    for i in range(R):\n        r[i] -= 1\n\n    def dijkstra_heap(start,edge):\n        #\u59cb\u70b9\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2(\u9802\u70b9\u756a\u53f7:0~N-1)\n        d = [inf]*N\n        used = [False]*N\n        d[start] = 0\n        used[start] = True\n        edgelist = []\n        #a:\u91cd\u307f(//), b:\u6b21\u306e\u9802\u70b9(%)\n        for a,b in edge[start]:\n            heappush(edgelist,a*(10**6)+b)\n\n        while len(edgelist):\n            #\u307e\u3060\u6700\u77ed\u8ddd\u96e2\u304c\u6c7a\u307e\u3063\u3066\u3044\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n            minedge = heappop(edgelist)\n            if used[minedge%(10**6)]:\n                continue\n            node = minedge%(10**6)\n            d[node] = minedge//(10**6)\n            used[node] = True\n\n            for e in edge[node]:\n                if not used[e[1]]:\n                    heappush(edgelist,(e[0]+d[node])*(10**6)+e[1])\n        return d\n\n    edge = [[] for i in range(N)]\n    #edge[i] : i\u304b\u3089\u51fa\u308b\u9053\u306e[\u91cd\u307f,\u884c\u5148]\u306e\u914d\u5217\n    for _ in range(M):\n        x,y,z = map(int,input().split())\n        edge[x-1].append((z,y-1))\n        edge[y-1].append((z,x-1))\n\n    kyori = []\n    for i in r:\n        kyori.append(dijkstra_heap(i,edge))\n    \n    res = inf\n    for i in permutations(range(R), R):\n        l = list(i)\n        path = 0\n        for j in range(R-1):\n            path += kyori[l[j]][r[l[j+1]]]\n        res = min(res, path)\n\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "from scipy.sparse.csgraph import floyd_warshall\nimport itertools\n\n\ndef warshal_floyd(d):\n    # d[i][j] := i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    nonlocal N\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    # \"\u4eca\u73fe\u5728\u6c42\u307e\u3063\u3066\u3044\u308bi\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\"\u3068\"\u4eca\u73fe\u5728\u6c42\u307e\u3063\u3066\u3044\u308bi\u304b\u3089k\u3078\u306e\u6700\u77ed\u8ddd\u96e2 + \u4eca\u73fe\u5728\u6c42\u307e\u3063\u3066\u3044\u308bk\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2 \u306e\u548c\"\u3092\u6bd4\u8f03\u3059\u308b\n    return d\n\n\nN, M, R = list(map(int, input().split()))  # N\u500b\u306e\u753a, M\u672c\u306e\u9053, R\u500b\u306e\u753a\u3092\u8a2a\u308c\u308b\u3053\u3068\u306b\u306a\u3063\u305f\ntown = list([int(x)-1 for x in input().split()])\ndistant = [[float('inf')]*N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    distant[a][b] = c\n    distant[b][a] = c\nfor i in range(N):\n    distant[i][i] = 0\ndistant = floyd_warshall(distant)\n# warshal_floyd(distant)\n# print(distant)  # R\u306f\u6700\u59278\u3060\u304b\u3089\u5168\u3066\u3092\u8a66\u3057\u3066\u3082\u5927\u4e08\u592b\nans = 10**9\nfor x in itertools.permutations(town):\n    x = list(x)\n    now = x[0]\n    tmp = 0\n    for i in range(1, len(x)):\n        tmp += distant[now][x[i]]\n        now = x[i]\n    ans = min(ans, tmp)\nprint((int(ans)))\n", "from scipy.sparse.csgraph import floyd_warshall\nimport itertools\n\nN, M, R = map(int, input().split())\nr = list(map(int, input().split()))\nr = [ri-1 for ri in r]\n\ngraph = [[0]*N for i in range(N)]\nfor i in range(M):\n  a, b, c = map(int, input().split())\n  a -= 1; b -= 1\n  graph[a][b] = graph[b][a] = c\n\ndist = floyd_warshall(graph).astype(int)\norders = list(itertools.permutations(r, R))\n\nans = float('inf')\nfor order in orders:\n  d = 0\n  for u, v in zip(order, order[1:]):\n    d += dist[u][v]\n  ans = min(ans, d)\n\nprint(ans)", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nimport itertools\n\n\ndef main():\n    N, M, R = list(map(int, input().split(' ')))\n    towns = list(map(lambda t: int(t) - 1, input().split(' ')))\n    A = np.zeros((N, N), dtype=int)\n    for _ in range(M):\n        a, b, c = list(map(int, input().split(' ')))\n        A[a-1][b-1] = c\n        A[b-1][a-1] = c\n    fw = floyd_warshall(A)\n    d = fw[towns, :][:, towns]\n    min_d = 10**12\n    for trip in itertools.permutations(range(R)):\n        min_d = min([min_d, sum([d[trip[i]][trip[i+1]] for i in range(len(trip) - 1)])])\n    print(int(min_d))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\nfrom itertools import permutations, combinations\nn,m,R = map(int,input().split())\nr=list(map(int,input().split()))\nfor i in range(R):\n    r[i]-=1\nd = np.zeros((n,n)) \n# \u5165\u529b\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    a,b = a-1, b-1\n    d[a,b] = c\ndist =floyd_warshall(d,directed=0).astype(int)\nans=10**10\nfor v in permutations(r):\n    tmp=0\n    for i in range(R-1):\n        tmp+=dist[v[i],v[i+1]]\n    ans=min(ans,tmp)\nprint(ans)", "def main():\n    from sys import stdin\n    input = stdin.readline\n    n, m, r = list(map(int, input().split()))\n    root = list(map(int, input().split()))\n    abc = [list(map(int, input().split())) for _ in [0]*m]\n\n    import numpy as np\n    import scipy.sparse.csgraph as sp\n    inf = float('inf')\n    d = np.full((n, n), inf)\n    for i in range(n):\n        d[i][i] = 0\n    for a, b, c in abc:\n        d[a-1][b-1] = c\n        d[b-1][a-1] = c\n    # indices=x\u3067x\u304b\u3089\u306e\u5358\u4e00\u59cb\u70b9\u306b,return_predecessors=True\u3067\u7d4c\u8def\u304c\u51fa\u308b\n    s = sp.shortest_path(d)\n\n    from itertools import permutations\n\n    p = list(permutations(root))\n\n    D = 10**10\n    for i in p:\n        d = 0\n        for j in range(len(i)-1):\n            d += s[i[j]-1][i[j+1]-1]\n        D = min(D, d)\n    print((int(D)))\n\n\nmain()\n", "from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\nfrom itertools import permutations\n\nN, M, R = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\ng = [[0] * (N + 1) for _ in range(N + 1)]\nfor _ in range(M):\n    A, B, C = list(map(int, input().split()))\n    g[A][B] = C\n    g[B][A] = C\ng = floyd_warshall(csgraph_from_dense(g))\n\nresult = 1000000000\nfor p in permutations(r):\n    t = 0\n    for i in range(R - 1):\n        t += g[p[i]][p[i + 1]]\n    result = min(result, t)\nprint((int(result)))\n", "import sys\nfrom itertools import permutations\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, M, R = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    P = permutations(r)\n\n    dp = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = 0\n\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        dp[a][b] = c\n        dp[b][a] = c\n\n    # \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                tmp = dp[i][k] + dp[k][j]\n                if tmp < dp[i][j]:\n                    dp[i][j] = tmp\n\n    ans = INF\n    for p in P:\n        tmp = 0\n        for i in range(R - 1):\n            tmp += dp[p[i] - 1][p[i + 1] - 1]\n\n        if tmp < ans:\n            ans = tmp\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\nint1 = lambda x: int(x) - 1\n\nN, M, R = map(int, input().split())\nT = sorted(list(map(int1, input().split())))\nA = np.array([tuple(map(int, input().split())) for _ in range(M)]).T\n\nmatr = csr_matrix((A[2], (A[0] - 1, A[1] - 1)), shape=(N, N))\nway = [dijkstra(matr, indices=t, directed=False)[T].astype(int).tolist() for t in T]\n\nans = float('inf')\nfor t in itertools.permutations(range(R)):\n    tmp = 0\n    for i in range(R - 1):\n        tmp += way[t[i]][t[i + 1]]\n    ans = min(ans, tmp)\nprint(ans)", "import heapq\nimport itertools\n\ndef dijkstra(s):\n    inf = pow(10, 10)\n    dist = [inf] * (n + 1)\n    dist[s] = 0\n    c = [0] * (n + 1)\n    p = []\n    heapq.heapify(p)\n    heapq.heappush(p, (dist[s], s))\n    while p:\n        d, u = heapq.heappop(p)\n        if dist[u] < d:\n            continue\n        c[u] = 1\n        for g in G[u]:\n            if c[g[0]] == 0 and dist[u] + g[1] < dist[g[0]]:\n                dist[g[0]] = dist[u] + g[1]\n                heapq.heappush(p, (dist[g[0]], g[0]))\n    return dist\n\nn, m, r = map(int, input().split())\nt = list(map(int, input().split()))\nG = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    G[a].append([b, c])\n    G[b].append([a, c])\nD = [[0] * r for _ in range(r)]\nfor i in range(r):\n    d = dijkstra(t[i])\n    for j in range(r):\n        D[i][j] = d[t[j]]\n\nx = [i for i in range(r)]\nans = pow(10, 10)\nfor y in itertools.permutations(x):\n    dist = 0\n    y = list(y)\n    for i in range(r - 1):\n        dist += D[y[i]][y[i + 1]]\n    ans = min(ans, dist)\nprint(ans)", "from itertools import permutations as perm\n\ndef warshall(d, n):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if d[i][k] + d[k][j] < d[i][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n\nn,m,r = map(int, input().split())\nrr = [i-1 for i in map(int, input().split())]\n\ninf = float('INF')\nroute = [[inf for j in range(n)] for i in range(n)]\nfor _ in range(m):\n    a,b,c = map(int, input().split())\n    route[a-1][b-1] = route[b-1][a-1] = c\n\nwarshall(route, n)\n\nans = inf\nfor tmp in perm(rr):\n    cost = 0\n    for i in range(r-1):\n        cost += route[tmp[i]][tmp[i+1]]\n    if cost < ans:\n        ans = cost\nprint(int(ans))", "# coding: utf-8\nfrom heapq import heappop, heappush\nfrom itertools import permutations\n\nN,M,R=map(int,input().split())\ntown=list(map(int,input().split()))\nINF=10**9\nG=[[INF for i in range(N+1)] for j in range(N+1)]\n\nfor i in range(M):\n    A,B,C=map(int,input().split())\n    G[A][B]=C\n    G[B][A]=C\n\nd=[[INF*10 for i in range(N+1)] for j in range(R)]\n\nfor k in range(R):\n    r=town[k]\n    d[k][r]=0\n    \n    used=[False for i in range(N+1)]\n    \n    heap=[]\n    heappush(heap,(d[k][r],r))\n    \n    while heap:\n        d_u, u = heappop(heap)\n\n        used[u] = True\n        \n        if d[k][u] < d_u:\n            continue\n        \n        for v in range(N+1):\n            if not(used[v]) and d_u + G[u][v] < d[k][v]:\n                d[k][v] = d_u + G[u][v]\n                heappush(heap,(d[k][v],v))\n\nans=INF\n\nL=[i for i in range(R)]\n\nfor v in permutations(L,R):\n    D=0\n    for i in range(R-1):\n        D+=d[v[i]][town[v[i+1]]]\n    ans=min(ans,D)\n    \nprint(ans)", "import itertools\nimport sys\nfrom scipy.sparse.csgraph import csgraph_from_dense\nfrom scipy.sparse.csgraph import dijkstra\ninput = sys.stdin.readline\n\n\nn, m, r = list(map(int, input().split()))\nvisiting_town = list(map(int, input().split()))\nedges = [[float('INF')]*n for _ in range(n)]\n\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    edges[a-1][b-1] = c\n\nG = csgraph_from_dense(edges, null_value=float('INF'))\ncomp_dist = {}\nfor node in visiting_town:\n    dist_list = dijkstra(G, directed=False, indices=node-1)\n    comp_dist[node-1] = dist_list\n\ncandidates = []\nfor route in itertools.permutations(visiting_town):\n    result = 0\n    for _from, to in zip(route[:-1], route[1:]):\n        dist = comp_dist[_from-1][to-1]\n        result += dist\n    candidates.append(result)\n\nprint((int(min(candidates))))\n", "import itertools\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n\nN,M,R = map(int, input().split())\nr_list = np.array(list(map(int, input().split()))) -1 \n\nnodes = np.full((N,N), np.inf) \nfor i in range(M):\n    a,b,c = map(int, input().split())\n    nodes[a-1,b-1] = nodes[b-1,a-1] = c\nmin_ds = shortest_path(nodes)\nres = 10**9\nfor cmb in itertools.permutations(r_list):\n    prev = cmb[0]\n    tmpres = 0\n    for to in cmb[1:]:\n        tmpres += min_ds[prev,to]\n        prev = to\n    res = min(res, tmpres)\n\nprint(int(res))", "import numpy as np\nfrom scipy.sparse.csgraph import dijkstra\n\nN,M,R = list(map(int,input().split()))\nr = list(map(int,input().split()))\nfor i in range(R):\n    r[i] -= 1\n\nconnections = np.zeros((N,N))\nfor i in range(M):\n    A,B,C = list(map(int,input().split()))\n    A,B = A-1,B-1\n    \n    connections[A][B] = C\n    connections[B][A] = C\n\nconnections = dijkstra(connections)\n\ndef explore(unvisited,total,start):\n    if unvisited:\n        ret = float('inf')\n        for town in unvisited:\n            ret = min(ret,explore(unvisited-set([town]),\n                total+connections[start][town],town))\n        return ret\n    else:\n        return total\n\nans = float('inf')\ntargets = set(r)\nfor s in r:\n    ans = min(ans,explore(targets-set([s]),0,s))\nprint(int(ans))", "def abc073_d():\n    from scipy.sparse import lil_matrix\n    from scipy.sparse.csgraph import floyd_warshall\n    from itertools import permutations\n\n    n, m, r = map(int, input().split())\n    R = list(map(lambda x: int(x)-1, input().split()))\n    graph = lil_matrix((n, n), dtype=int)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a, b] = c\n        graph[b, a] = c\n\n    dist = floyd_warshall(csgraph=graph)\n    #print(dist)\n\n    ans = 10**18\n    for route in permutations(R, r):\n        tmp = 0\n        for i in range(r-1):\n            s = route[i]\n            t = route[i+1]\n            tmp += dist[s][t]\n            if tmp > ans: break\n        ans = min(ans, tmp)\n        #print(route, tmp)\n\n    print(int(ans))\n\ndef __starting_point():\n    abc073_d()\n__starting_point()", "from itertools import permutations\nimport heapq\n\ndef dijkstra(N, G, s):\n    INF = 10**40\n    d = [INF] * N\n    d[s] = 0\n    q = [(0, s)]\n    while q:\n        c, v = heapq.heappop(q)\n        if d[v] < c:\n            continue\n        for t, co in G[v]:\n            if d[v] + co < d[t]:\n                d[t] = d[v] + co\n                heapq.heappush(q, (d[t], t))\n    return d\n\n\ndef main():\n    N, M, _ = list(map(int, input().split()))\n    R = list(map(int, input().split()))\n    R = [r - 1 for r in R]\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        G[a - 1].append((b - 1, c))\n        G[b - 1].append((a - 1, c))\n    RM = []\n    for r in R:\n        d = dijkstra(N, G, r)\n        RM.append([d[rr] for rr in R])\n    m = 10 ** 40\n    for i in permutations(list(range(len(R)))):\n        t = i[0]\n        c = 0\n        for r in i[1:]:\n            c += RM[t][r]\n            t = r\n        m = min(m, c)\n    return m\n\n\nprint((main()))\n", "import sys\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson, csgraph_from_dense\nimport itertools\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, M, R = [int(x) for x in input().split()]\n    r = [int(x) - 1 for x in input().split()]\n    ABC = [[int(x) for x in input().split()] for _ in range(M)]\n\n    EDGE = [[10 ** 9] * N for j in range(N)]\n\n    for a, b, c in ABC:\n        EDGE[a - 1][b - 1] = c\n        EDGE[b - 1][a - 1] = c\n\n    G = csgraph_from_dense(EDGE, null_value=10 ** 9)\n\n    d = floyd_warshall(G)\n\n    ans = float(\"inf\")\n    for a in itertools.permutations(r):\n        tmp = 0\n        c = a[0]\n        for n in a:\n            tmp += int(d[c][n])\n            c = n\n        ans = min(ans, tmp)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n  import numpy as np\n  import itertools\n  from scipy.sparse import csr_matrix\n  from scipy.sparse.csgraph import dijkstra\n  import sys\n  readline = sys.stdin.readline\n  readlines = sys.stdin.readlines\n\n  N, M, R= map(int, readline().split())\n  r = list(map(int,input().split()))\n  lines = readlines()\n  edge = np.array([line.split() for line in lines], dtype = np.int64).T\n  #print(r)\n  #print(edge)\n  graph = csr_matrix((edge[2], (edge[:2] - 1)), (N, N))\n  ans = float(\"inf\")\n  distance_mat = {}\n  for i in r:\n    distance_mat[i-1] = (dijkstra(graph, directed = False, indices = i-1))\n\n  for town in itertools.permutations(r,R):\n    #print(town)\n    tmp = 0\n    for i in range(R-1):\n      tmp += distance_mat[town[i]-1][town[i+1]-1]\n    ans = min(ans,tmp)\n  print(int(ans))\nmain()", "import itertools\ndef main():\n    n,m,r=list(map(int,input().split()))\n    rx=[int(i) for i in input().split()]\n    inf=100000000\n    wf=[[inf]*n for i in range(n)]\n    for i in range(n):\n        wf[i][i]=0\n\n    for i in range(m):\n        a,b,c=list(map(int,input().split()))\n        wf[a-1][b-1]=c\n        wf[b-1][a-1]=c\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if wf[i][j]>wf[i][k]+wf[k][j]:\n                    wf[i][j]=wf[i][k]+wf[k][j]\n    cnt=0\n    l=list(itertools.permutations([i for i in range(r)]))\n    cnt=inf\n    for i in l:\n        cnt_sub=0\n        for j in range(r-1):\n            cnt_sub+=wf[rx[i[j]]-1][rx[i[j+1]]-1]\n        cnt=min(cnt,cnt_sub)\n    print(cnt)\nmain()\n", "from collections import deque\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\nimport itertools\n\nn, m, r = map(int,input().split())\nrlist = list(map(int,input().split()))\nfor i in range(r):\n    rlist[i] -= 1\ne = np.zeros((n,n), dtype=int)\n\nfor i in range(m):\n    a, b, c = map(int,input().split())\n    a -= 1\n    b -= 1\n    e[a][b] = c\n    e[b][a] = c\ncsr = csr_matrix(e)\nf = floyd_warshall(csr)\n\nans = 10**18\nfor v in itertools.permutations(rlist,r):\n    d = 0\n    for i in range(r-1):\n        d += f[v[i]][v[i+1]]\n    ans = min(ans, d)\nprint(int(ans))", "def main():\n    from sys import stdin\n    input = stdin.readline\n\n    n, m, r = list(map(int, input().split()))\n    l = [int(i) - 1 for i in input().split()]\n    d = [[10**8] * n for _ in range(n)]\n    for _ in range(m):\n        i, j, k = list(map(int, input().split()))\n        d[i-1][j-1] = k\n        d[j-1][i-1] = k\n\n    # Warshall-Floyd algorithm\n    for k in range(n):\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if d[i][j] > d[i][k] + d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n                    d[j][i] = d[i][j]\n\n    # full search\n    # 8! = 40320\n    from itertools import permutations\n\n    answer = float('inf')\n    for i in permutations(l):\n        ans = 0\n        for j in range(r-1):\n            ans += d[i[j]][i[j+1]]\n        if ans < answer:\n            answer = ans\n\n    print(answer)\n\nmain()\n", "from scipy.sparse.csgraph import shortest_path\nimport numpy as np\nimport itertools\n\nN,M,R = list(map(int,input().split()))\nr = list(map(int, input().split()))\n\nedge = np.zeros((N+1,N+1))\nfor _ in range(M):\n  A,B,C = list(map(int,input().split()))\n  edge[A,B] = C  \ndist = shortest_path(edge, directed = False).astype(int)\n\nanswer = 10**18\nfor visit in itertools.permutations(r):\n  p = 0\n  prev = visit[0]\n  for x in visit[1:]:\n    if prev != None:\n      p += dist[prev,x]\n    prev = x\n  answer = min(answer,p)\n  \nprint(answer)\n", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\nfrom itertools import permutations\n\nn,m,r = map(int,input().split())\nrr = np.array(list(map(int,input().split()))) - 1\n\nL = np.zeros((n,n),int)\nfor _ in range(m):\n    a,b,c = map(int,input().split())\n    L[a-1,b-1] = c\n\nshortest = floyd_warshall(L, directed = False)\n\nans = float('inf')\n\nfor route in permutations(rr,len(rr)):\n    ans = min(ans, shortest[route[:-1],route[1:]].sum())\nprint(int(ans))", "# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u3067\u3001\u5404\u753a\u9593\u306e\u6700\u77ed\u8ddd\u96e2\u306e\u66f4\u65b0\u306f200^3 = 8,000,000\n# \u8a2a\u308c\u308b\u3079\u304d\u753aR\u306f\u305f\u304b\u3060\u304b8\u500b\u306a\u306e\u3067\u3001\u9806\u756a\u306e\u5168\u901a\u308a\u3092\u8a66\u3057\u30668! = \u7d0440000\u901a\u308a\n\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nN,M,R = map(int,input().split())\nr = list(map(int,input().split()))\nr = list(map(lambda x:x-1,r))\n\nE = [[0 for j in range(N)] for i in range(N)]\nfor i in range(M):\n  a,b,c = map(int,input().split())\n  E[a-1][b-1] = c\n  E[b-1][a-1] = c\n\nE = np.array(E)\nE = shortest_path(E,method = \"FW\")\n\n# DFS\u3067\u3059\u3079\u3066\u306e\u6570\u3092\u8a66\u3059\nstack = []\nfor i in range(len(r)):\n  stack.append([r[i],[],0])\nans = 10 ** 18\nwhile stack:\n  v,visited,dist = stack.pop()\n  if len(visited) != 0:\n    dist += E[visited[-1]][v]\n  visited2 = visited.copy()\n  visited2.append(v)\n  if len(visited2) == len(r):\n    if dist < ans:\n      ans = dist\n    continue\n  for i in range(len(r)):\n    if r[i] not in visited2:\n      stack.append([r[i],visited2,dist])\n    \nprint(int(ans))", "from sys import stdin\nfrom itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse.csgraph import csgraph_from_dense\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    inf=10**9\n    n,m,r=map(int,readline().split())\n    targets=list(map(lambda x:int(x)-1,readline().split()))\n    G=[[inf]*n for _ in range(n)]\n    for _ in range(m):\n        a,b,c=map(int,readline().split())\n        a-=1\n        b-=1\n        G[a][b]=min(G[a][b],c)\n        G[b][a]=min(G[b][a],c)\n\n    #\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n    G=csgraph_from_dense(G,null_value=10**9)\n    li=floyd_warshall(G)\n    li=[list(map(int,li[i])) for i in range(n)]\n    \n    #\u9806\u5217\u5168\u63a2\u7d22\n    ans=inf\n    for p in permutations(targets,r):\n        tmp=0\n        for i in range(r-1):\n            now=p[i]\n            nex=p[i+1]\n            tmp+=li[now][nex]\n        ans=min(ans,tmp)\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import *\nfrom scipy.sparse.csgraph import *\nimport numpy as np\nN,M,R = map(int,input().split())\nT = list(map(int,input().split()))\nE = [list(map(int,input().split())) for m in range(M)]\nG = np.zeros((N,N))\nA = []\n\nfor a,b,c in E:\n  G[a-1][b-1] = c\n  G[b-1][a-1] = c\n\nF = floyd_warshall(G)\n\nfor P in permutations(T):\n  A+=[sum(F[P[r]-1][P[r+1]-1] for r in range(R-1))]\n\nprint(int(min(A)))", "from scipy.sparse.csgraph import floyd_warshall\nfrom itertools import permutations\nfrom sys import stdin\nnii=lambda:map(int,stdin.readline().split())\n\nn,m,r=nii()\nr=list(nii())\n\ns=[[float('inf')]*n for i in range(n)]\nfor i in range(n):\n  for j in range(n):\n    s[i][j]=0\nfor i in range(m):\n  a,b,c=nii()\n  a-=1\n  b-=1\n  s[a][b]=c\n  s[b][a]=c\n\nws=floyd_warshall(s)\n\nans=10**9\nfor i in permutations(r):\n  t_ans=0\n  for j in range(1,len(i)):\n    t_ans+=ws[i[j-1]-1][i[j]-1]\n  ans=min(ans,t_ans)\nprint(int(ans))", "import itertools\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M, R = map(int, input().split())\nr = tuple(map(int, input().split()))\n\nINF = 10**10\n\nd = [[INF] * N for _ in range(N)]\n\nfor i in range(N):\n    d[i][i] = 0\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    if d[a][b] > c:\n        d[a][b] = c\n        d[b][a] = c\n\n\ndef warshall(d):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if d[i][j] > d[i][k] + d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n# d = floyd_warshall(d)\nwarshall(d)\n\n\nans = INF\nfor p in itertools.permutations(r):\n    dist = 0\n    for i in range(R-1):\n        dist += d[p[i]-1][p[i+1]-1]\n\n    if ans > dist:\n        ans = dist\n\nprint(int(ans))", "from itertools import permutations as perm\nfrom scipy.sparse.csgraph import dijkstra as di\n\ndef warshall(d, n):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if d[i][k] + d[k][j] < d[i][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n\nn,m,r = list(map(int, input().split()))\nrr = [i-1 for i in map(int, input().split())]\n\ninf = float('INF')\nroute = [[0 for j in range(n)] for i in range(n)]\nfor _ in range(m):\n    a,b,c = list(map(int, input().split()))\n    route[a-1][b-1] = route[b-1][a-1] = c\n\nroute = di(route, n)\n\nans = inf\nfor tmp in perm(rr):\n    cost = 0\n    for i in range(r-1):\n        cost += route[tmp[i]][tmp[i+1]]\n    if cost < ans:\n        ans = cost\nprint((int(ans)))\n", "from itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\nN, M, R = list(map(int, input().split()))\nr = tuple(map(int, input().split()))\n\ninf = 10**9\ngraph = np.ones((N, N), dtype=int)*inf\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a][b] = c\n    graph[b][a] = c\nfy = floyd_warshall(graph)\n\nans = 10 ** 9\nfor p in permutations(r):\n    tmp = 0\n    for x, y in zip(p[:-1], p[1:]):\n        x -= 1\n        y -= 1\n        tmp += int(fy[x][y])\n    ans = min(ans, tmp)\nprint(ans)\n", "from itertools import permutations\nfrom scipy.sparse.csgraph import floyd_warshall\nn,m,r=map(int,input().split())\nR=list(map(int,input().split()))\nl=[[float('inf')]*n for _ in range(n)]\nfor _ in range(m):\n    a,b,c,=map(int,input().split())\n    a-=1\n    b-=1\n    l[a][b]=c\n    l[b][a]=c\nfor i in range(n):\n    l[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\ndef warshall_floyd(d):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n                \n    return d\n#F=warshall_floyd(l)\nF1 = floyd_warshall(l)\nans=float('inf')\nfor v in permutations(R):\n    temp=0\n    for i in range(r-1):\n        temp+=F1[v[i]-1][v[i+1]-1]\n    ans=min(ans,temp)\nprint(int(ans))", "# coding: utf-8\n# Your code here!\n\n#\u4fdd\u5b58\nimport heapq\nimport sys\nimport itertools\n \nsys.setrecursionlimit(10**7)\n\ndef bfs(cost,node):\n    root[node]=min(root[node],cost)\n    for next_c,next_n in way[node]:\n        if root[next_n]==10**9:\n            heapq.heappush(q,[cost+next_c,next_n])\n    return\n    \nN,M,R=list(map(int,input().split()))\nr=list(map(int,input().split()))\n\nway=[[] for i in range(N)]\n\nfor _ in range(M):\n    A,B,C=list(map(int,input().split()))\n    way[A-1].append([C,B-1])\n    way[B-1].append([C,A-1])\n\nmade=[]\n\n#print(q)\nfor start in r:\n    root=[10**9]*N\n    q=[[0,start-1]]\n    heapq.heapify(q)#cost\u3068node\n    while q:\n        temp=heapq.heappop(q)\n        #print(temp)\n        if root[temp[1]]==10**9:\n            bfs(temp[0],temp[1])\n    made.append(root)\n#print(made)\n\nans=10**9\nfor order in itertools.permutations([i for i in range(len(r))]):\n    #print(order)\n    temp=0\n    for i in range(len(order)-1):\n        fro=r[order[i]]\n        aft=r[order[i+1]]\n        #print(\"YES\")\n        #print(order[i]-1,order[i+1]-1)\n        #print(root[order[i]-1][0])\n        temp+=abs(made[order[i]][aft-1]-made[order[i]][fro-1])\n    ans=min(ans,temp)\nprint(ans)\n\n\n", "import time\nimport itertools\n\ndef main():\n    N,M,R = tuple([int(x) for x in input().split()])\n\n    r = [int(x)-1 for x in input().split()]\n    \n    w_e = [tuple([int(x)for x in input().split()]) for _ in [0]*M]\n    w_e = [(a-1,b-1,w) for (a,b,w) in w_e]\n\n\n    g = Graph(list(range(N)),w_e)\n\n    minimums = {}\n    for r_i in r:\n        minimums[r_i] = g.dijkstra(r_i)[0]\n\n    bf = itertools.permutations(r)\n\n    candidates = []\n    for bf_i in bf:\n        distance = 0\n        for i in range(R-1):\n            distance += minimums[bf_i[i]][bf_i[i+1]]\n        candidates.append(distance)\n\n    print(min(candidates))\n\ndef speedtest(func,*args):\n    b = time.perf_counter()\n    res = func(*args)\n    e = time.perf_counter()\n    elapsed = e-b\n    print(\"{} (sec)\".format(elapsed))\n\n    return res\n\nclass Graph:\n    def __init__(self,w_v,w_e):\n        super().__init__()\n        self.size = len(w_v)\n        self.w_v = [v_i for v_i in w_v]#value of vartex\n        self.w_e = [{} for _ in [0]*self.size]\n\n        self.neighbor = [[] for _ in [0]*self.size]\n        for a_i,b_i,w_i in w_e:\n            self.w_e[a_i][b_i] = w_i#weight of edge\n            self.w_e[b_i][a_i] = w_i#weight of edge\n\n            self.neighbor[a_i].append(b_i)\n            self.neighbor[b_i].append(a_i)\n\n    def dijkstra(self,v_n):\n        d = [-1]*self.size\n        temp_d = [(10**9,i)for i in range(self.size)]\n        temp_d[v_n] = (0,v_n)\n        prev = [-1]*self.size\n\n        q = set(range(self.size))\n        \n        while len(q)>0:\n            u = min([temp_d[q_i] for q_i in q])[1]\n            d[u] = temp_d[u][0]\n            q.discard(u)\n            for v in self.neighbor[u]:\n                temp = temp_d[u][0]+self.w_e[u][v]\n                if temp_d[v][0]>temp:\n                    temp_d[v] = temp,v\n                    prev[v] = u\n\n        return d,prev\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import permutations\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    N, M, RR = map(int, input().split())\n    R = list(map(int, input().split()))\n    INF = float(\"inf\")\n    T = [[INF] * N for _ in range(N)]\n    for _ in range(M):\n        a, b, c = tuple(map(int, input().split()))\n        T[a-1][b-1] = c\n        T[b-1][a-1] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if T[i][j] > T[i][k]+T[k][j]:\n                    T[i][j] = T[i][k]+T[k][j]\n    print(min(sum(T[rs[i]-1][rs[i+1]-1] for i in range(RR-1)) for rs in permutations(R)))\n\ndef __starting_point():\n    main()\n__starting_point()", "from scipy.sparse.csgraph import dijkstra\nimport numpy as np\nfrom itertools import permutations\nN,M,R = list(map(int,input().split()))\nr = list(map(int,input().split()))\n\n\"\"\"\nhttps://juppy.hatenablog.com/entry/2018/11/01/%E8%9F%BB%E6%9C%AC_python_%E5%85%A8%E7%82%B9%E5%AF%BE%E6%9C%80%E7%9F%AD%E7%B5%8C%E8%B7%AF%E6%B3%95%EF%BC%88%E3%83%AF%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%AB%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E6%B3%95\n\"\"\"\n\ndef warshall_floyd(d):\n    n = len(d)\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n    return d\n\ngraph = [[float(\"inf\") for i in range(N)] for j in range(N)] \nfor i in range(M):\n    A,B,C = list(map(int,input().split()))\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\n\ndist = dijkstra(graph)\n\nans = 1e10\nfor i in permutations(r):\n    flag = True\n    way = list(i)\n    tmp = 0\n    for i in range(len(way)-1):\n        if dist[way[i]-1][way[i+1]-1] < 0:\n            flag = False\n            break\n        tmp += dist[way[i]-1][way[i+1]-1]\n    if flag:\n        ans = min(tmp,ans)\n\nprint((int(ans)))\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN, M, R = na()\nr = na()\ng = [[0] * N for _ in range(N)]\nfor i in range(M):\n    a, b, c = na()\n    a -= 1\n    b -= 1\n    g[a][b] = c\n    g[b][a] = c\n\ng = np.array(g)\nd = shortest_path(g)\n\nR = len(r)\nans = inf\nfor x in itertools.permutations(r):\n    tmp = 0\n    for i in range(R-1):\n        tmp += d[x[i] - 1][x[i+1] - 1]\n    ans = min(ans, tmp)\nprint((int(ans)))\n\n\n\n\n", "import itertools\nimport sys\nfrom scipy.sparse.csgraph import csgraph_from_dense\nfrom scipy.sparse.csgraph import dijkstra\ninput = sys.stdin.readline\n\n\nn, m, r = list(map(int, input().split()))\nvisiting_town = list(map(int, input().split()))\nedges = [[float('INF')]*n for _ in range(n)]\n\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    edges[a-1][b-1] = c\n\nG = csgraph_from_dense(edges, null_value=float('INF'))\ncomp_dist = dijkstra(G, directed=False)\n\ncandidates = []\nfor route in itertools.permutations(visiting_town):\n    result = 0\n    for _from, to in zip(route[:-1], route[1:]):\n        dist = comp_dist[_from-1][to-1]\n        result += dist\n    candidates.append(result)\n\nprint((int(min(candidates))))\n", "from itertools import permutations\nimport numpy as np\nfrom scipy.sparse.csgraph import dijkstra\n\nwith open(0) as f:\n    N, M, R = map(int, f.readline().split())\n    r = list(map(int, f.readline().split()))\n    path = [tuple(map(int, line.split())) for line in f.readlines()]\n\ngraph = np.full((N,N), np.inf)\nfor a, b, c in path:\n    graph[a-1, b-1] = c\n    graph[b-1, a-1] = c\n\ngraph = dijkstra(graph, directed=False)\nans = np.inf\npermutation = list(permutations(r))\nfor p in permutation:\n    way = 0\n    for x,y in zip(p[:len(r)], p[1:]):\n        way += graph[x-1, y-1]\n    ans = min(ans, way)\nprint(int(ans))", "n,m,r  = list(map(int,input().split()))\nr_list = list(map(int,input().split()))\nmatrix = [[float(\"inf\") for i in range(n)] for j in range(n)]\nfor c in range(n):\n  matrix[c][c] = 0\nfor v in range(m):\n  a,b,c = list(map(int,input().split()))\n  if matrix[a-1][b-1] > c:\n    matrix[a-1][b-1] = c\n    matrix[b-1][a-1] = c\nimport numpy as np\nmatrix = np.array(matrix)\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\nload = shortest_path(matrix, directed=False)\nimport itertools\nans_list = []\nfor balls in itertools.permutations(r_list):\n    balls = list(balls)\n    ans = 0\n    for i in range(1,len(r_list)):\n      ans += load[balls[i-1]-1][balls[i]-1]\n    ans_list.append(int(ans))\n    \nprint((min(ans_list)))\n      \n\n\n", "N, M, K = (int(x) for x in input().split())\nR = [int(x)-1 for x in input().split()]\n\ndist = [[10e8 for _ in range(N)] for _ in range(N)]\nfor i in range(N): dist[i][i] = 0\nfor _ in range(M):\n    a, b, c = (int(x) for x in input().split())\n    dist[a-1][b-1] = dist[b-1][a-1] = c \ndel a, b, c, K\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(i,N):\n            dist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k]+dist[k][j])\n\ndef mindist(x, X):\n    nonlocal dist\n    Y = X.copy()\n    Y.remove(x)\n    if len(Y) == 0: return 0\n    return min([dist[x][y] + mindist(y,Y) for y in Y])\n\nans = min([mindist(r, R) for r in R])\nprint(ans)", "from itertools import permutations\nfrom scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\ninf = 10 ** 10\nn, m, r = map(int,input().split())\nR = list(map(int,input().split()))\n\nedge = [[inf] * n for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int,input().split())\n    edge[a - 1][b - 1] = c\n\nG = csgraph_from_dense(edge, null_value = inf)\nd = floyd_warshall(G, False)\n\nrec = inf\nfor i in permutations(R, r):\n    temp = 0\n    #print(i)\n    for j in range(r):\n        if j == r - 1:continue\n        temp += d[i[j] - 1][i[j + 1] - 1]\n    rec = min(rec, temp)\n\nprint(int(rec))"]
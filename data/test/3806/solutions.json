["import math\ndef dist(x, y, x1, y1, x2, y2):\n    a = x-x1\n    b = y-y1\n    c = x2-x1\n    d = y2-y1\n    dot = a*c+b*d\n    lensq = c*c+d*d\n    param=-1\n    if lensq != 0:\n        param = dot / lensq\n    if param < 0:\n        xx = x1\n        yy = y1\n    elif param > 1:\n        xx = x2\n        yy = y2\n    else:\n        xx = x1 + param * c\n        yy = y1 + param * d\n\n    dx = x - xx\n    dy = y - yy\n    return (dx*dx+dy*dy)**0.5\ndef dist2(x, y):\n    return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\nimport math\nmaxx = -1\nminn = 100000000000000000\npts = []\na, b, c = list(map(int, input().split(' ')))\nfor i in range(a):\n    x, y = list(map(int, input().split(' ')))\n    pts.append([x, y])\n\nk = []\nfor i in pts:\n    k.append(dist2(i, [b, c]))\npts.append(pts[0])\nfor i in range(a):\n    k.append(dist(b, c, pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1]))\n\nprint((max(k)**2-min(k)**2)*math.pi)\n", "from math import hypot, pi, copysign\n\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    l, res = [], []\n    for _ in range(n):\n        x0, y0 = list(map(int, input().split()))\n        l.append((x0 - a, y0 - b))\n    x0, y0 = l[-1]\n    for x1, y1 in l:\n        res.append(hypot(x1, y1))\n        dx, dy = x1 - x0, y1 - y0\n        if copysign(1., x0 * dx + y0 * dy) != copysign(1., x1 * dx + y1 * dy):\n            res.append(abs(x0 * y1 - x1 * y0) / hypot(dx, dy))\n        x0, y0 = x1, y1\n    print((max(res) ** 2 - min(res) ** 2) * pi)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, a, b = list(map(int, input().split()))\n    l, res = [], []\n    for _ in range(n):\n        u, v = input().split()\n        l.append((int(u) - a, int(v) - b))\n    x0, y0 = l[-1]\n    for x1, y1 in l:\n        res.append(x1 * x1 + y1 * y1)\n        dx, dy = x1 - x0, y1 - y0\n        if (x0 * dx + y0 * dy) * (x1 * dx + y1 * dy) < 0:\n            x0 = x0 * y1 - x1 * y0\n            res.append(x0 * x0 / (dx * dx + dy * dy))\n        x0, y0 = x1, y1\n    print((max(res) - min(res)) * 3.141592653589793)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input().split()\nn = int(s[0])\n\npx = int(s[1])\npy = int(s[2])\n\n\ny = []\nx = []\n\nfor i in range(n):\n   s=input().split()\n   x.append(int(s[0]) - px)\n   y.append(int(s[1]) - py)\n   #print(x[i],y[i])\n\nl = []\nx0, y0 = x[-1], y[-1]\n\nfor i in range(n):\n   l.append(x[i]*x[i] + y[i]*y[i])\n   dx, dy = x[i] - x0, y[i] - y0\n   if (x0*dx+y0*dy)*(x[i]*dx + y[i]*dy) < 0:\n      x0 = x0*y[i]-x[i]*y0\n      l.append(x0*x0/(dx*dx+dy*dy))\n   x0,y0 = x[i],y[i]\n\na =  3.141592653589793 * (max(l) -min(l))\n#print (px,py)\n#print (x[imax],y[imax])\n#print (x[imin],y[imin])\n#print (((px - x[imax])*(px - x[imax]) + (py - y[imax])*(py - y[imax]))) \n#print (((px - x[imin])*(px - x[imin]) + (py - y[imin])*(py - y[imin])))\n\nprint (a)\n", "\n# -*- coding: utf-8 -*-\n\nimport sys\nimport math\n\ndef dist2(x1, y1, x2, y2):\n    return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\ndef find_dist(x1, y1, x2, y2, X, Y):\n    if x2 == x1:\n        if min(y1, y2) <= Y <= max(y1, y2):\n            return (x1 - X) ** 2\n        else:\n            return min(dist2(x1, y1, X, Y), dist2(x2, y2, X, Y))\n    a = (y2 - y1) / (x2 - x1)\n    b = y1 - a * x1\n    x = (X + a * (Y - b)) / (1 + a * a)\n    if min(x1, x2) <= x <= max(x1, x2):\n        return dist2(x, a * x + b, X, Y)\n    else:\n        return min(dist2(x1, y1, X, Y), dist2(x2, y2, X, Y))\n\ndef main():\n    N, X, Y = list(map(int, sys.stdin.readline().split()))\n    maxr = 0\n    minr = 10**15\n    pts = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    pts.append(pts[0])\n    for i in range(0, len(pts)-1):\n        x, y = pts[i]\n        r = dist2(x, y, X, Y)\n        if r > maxr:\n            maxr = r\n        r = find_dist(x, y, pts[i+1][0], pts[i+1][1], X, Y)\n        if r < minr:\n            minr = r\n\n    print(\"%.10f\" % (math.pi * (maxr - minr)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\ndef main():\n\t(n, xp, yp) = (int(x) for x in input().split())\n\tpolygon = [None] * n\n\tfor i in range(n):\n\t\t(xi, yi) = (int(x) for x in input().split())\n\t\tpolygon[i] = (xi, yi)\n\tprint(solver((xp, yp), polygon))\n\ndef solver(P, polygon):\n\tn = len(polygon)\n\t(xp, yp) = P\n\tdistances = [distance(xp, yp, x, y) for (x, y) in polygon]\n\tmaxDist = max(distances)\n\tminDist = min(distances)\n\tfor i in range(n):\n\t\tp = perpenPoint(polygon[i%n], polygon[(i+1)%n], P)\n\t\tif p != None:\n\t\t\tdist = distance(xp, yp, p[0], p[1])\n\t\t\tif dist < minDist:\n\t\t\t\tminDist = dist\n\tarea = math.pi * (maxDist**2 - minDist**2)\n\treturn area\n\n\n\n# ax + by = c\ndef toLine(point1, point2):\n\t(x1, y1) = point1\n\t(x2, y2) = point2\n\tif x1 == x2:\n\t\tif y1 == y2:\n\t\t\tassert(False)\n\t\telse:\n\t\t\treturn (1, 0, x1)\n\telse:\n\t\ta = (y2 - y1) / (x1 - x2)\n\t\tc = a * x1 + y1\n\t\treturn (a, 1, c)\n\n# perpendicular point from point to the line segment: point1 to point3\ndef perpenPoint(point1, point2, point):\n\tline = toLine(point1, point2)\n\t(a, b, c) = line\n\t# perpendicular line\n\tif a == 0:\n\t\t(ap, bp) = (b, a)\n\telse:\n\t\t(ap, bp) = (-b / a, 1)\n\t(x, y) = point\n\tcp = ap * x + bp * y\n\t(xi, yi) = intersection(line, (ap, bp, cp))\n\t(x1, y1) = point1\n\t(x2, y2) = point2\n\tif min(x1, x2) <= xi and xi <= max(x1, x2) and \\\n\tmin(y1, y2) <= yi and yi <= max(y1, y2):\n\t\treturn (xi, yi)\n\telse:\n\t\treturn None\n\ndef intersection(line1, line2):\n\t(a1, b1, c1) = line1\n\t(a2, b2, c2) = line2\n\tif b1 == 0 and a2 == 0:\n\t\treturn (c1, c2)\n\telif a1 == 0 and b2 == 0:\n\t\treturn (c2, c1)\n\telse:\n\t\tx = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1)\n\t\ty = (c1 - a1 * x) / b1\n\t\treturn (x, y)\n\ndef almostEqual(x, y):\n\treturn abs(x - y) < 10**-16\n\ndef distance(x1, y1, x2, y2):\n\tleg1 = abs(x1 - x2)\n\tleg2 = abs(y1 - y2)\n\treturn (leg1**2 + leg2**2)**0.5\n\nmain()\n#print(perpenPoint((-1, 0), (0, 1), (1.1, 0)))\n#print(perpenPoint((-2, 0), (-2, 1), (0, 0)))\n#print(perpenPoint((-1, 1), (2, 1), (0, 0)))\n#print(perpenPoint((-1, 0), (1, 1), (0, 0)))\n#print(12.56637061435 / math.pi)\n#print(solver((0, 0), [(0, 1), (-1, 2), (1, 2)]))\n#print(solver((1, -1), [(0, 0), (1, 2), (2, 0), (1, 1)]))\n", "__author__ = 'vboldovs'\n\n#A613\n\nimport math\n\nGLOBAL_INNER_PRODUCT_LIMIT  = math.pow(10,-3)\n\nclass point:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\nclass line:\n    def __init__(self,start_point, end_point):\n        self.x = end_point.x - start_point.x\n        self.y = end_point.y - start_point.y\n\ndef distance(p1,p2):\n    return math.sqrt(math.pow(p1.x-p2.x,2)+math.pow(p1.y-p2.y,2))\n\ndef product(line1,line2):\n    return line1.x*line2.x+line1.y*line2.y\n\nm = input().split()\nn = int(m[0])\ncenter = point(int(m[1]), int(m[2]))\n\npoints = []\n\nfor _i in range(n):\n    temp = input().split()\n    points.append(point(int(temp[0]),int(temp[1])))\n\nmax_r = distance(center,points[0])\nmin_r = max_r\n\nfor p in points:\n    d = distance(p,center)\n    max_r = max(max_r,d)\n    min_r = min(min_r,d)\n\nfor i in range(n):\n    s_point = points[i]\n    try:\n        e_point = points[i+1]\n    except IndexError:\n        e_point = points[0]\n    curr_line = line(s_point,e_point)\n\n    prod_s = product(curr_line,line(s_point,center))\n    prod_e = product(curr_line,line(e_point,center))\n\n    if prod_s*prod_e>0:\n        continue\n\n    alpha = prod_s/abs(prod_e-prod_s)\n    p_point = point((1-alpha)*s_point.x+alpha*e_point.x,(1-alpha)*s_point.y+alpha*e_point.y)\n\n    min_r = min(min_r, distance(p_point,center))\n\n    #alpha = 0.5\n    #while True:\n    #    test_point = point((1-alpha)*s_point.x+alpha*e_point.x,(1-alpha)*s_point.y+alpha*e_point.y)\n    #    prod = product(line(test_point,center),curr_line)\n    #\n    #    if abs(prod) <= GLOBAL_INNER_PRODUCT_LIMIT:\n    #        min_r = min(min_r,distance(test_point,center))\n    #        break\n\n    #    if prod > GLOBAL_INNER_PRODUCT_LIMIT:\n    #        alpha+=alpha/2\n    #    else:\n    #        alpha-=alpha/2\n\nprint(math.pi*math.pow(max_r,2)-math.pi*math.pow(min_r,2))\n\n\n\n\n\n\n", "from math import *\n\ndef dist(a,b,p):\n\txu = b[0]-a[0]\n\tyu = b[1]-a[1]\n\txv = p[0]-a[0]\n\tyv = p[1]-a[1]\n\tc1 = xu*xv + yu*yv\n\tc2 = xu*xu + yu*yu\n\tx,y = 0,0\n\tif c1<=0:\n\t\tx = a[0]-p[0]\n\t\ty = a[1]-p[1]\n\telif c2<=c1:\n\t\tx = b[0]-p[0]\n\t\ty = b[1]-p[1]\n\telse:\n\t\tx = a[0] + xu*(c1/c2)-p[0]\n\t\ty = a[1] + yu*(c1/c2)-p[1]\n\treturn x*x + y*y\n\n\nn,cx,cy = map(int,input().split())\npts =  [ list(map(int,input().split())) for _ in range(n) ]\nmini,maxi = float('inf'),0\nfor i in range(n):\n\tpx,py = pts[i]\n\tmaxi = max((px-cx)**2+(py-cy)**2,maxi)\n\tmini = min(dist(pts[i-1],pts[i],[cx,cy]),mini)\nprint((maxi-mini)*pi)", "def dot_product(v1, v2):\n    return v1.x * v2.x + v1.y * v2.y\n\n\nclass vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def length(self):\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n\n    def cross_product(self, v):\n        return self.x * v.y - self.y * v.x\n\nclass line:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def distance(self, p):\n        return abs(vector(p.x - self.a.x, p.y - self.a.y).cross_product(vector(p.x - self.b.x, p.y - self.b.y)) / vector(self.a.x - self.b.x, self.a.y - self.b.y).length())\n\nclass ray:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def distance(self, p):\n        if dot_product(vector(self.b.x - self.a.x, self.b.y - self.a.y), vector(p.x - self.a.x, p.y - self.a.y)) >= 0:\n            return line(self.a, self.b).distance(p)\n        return vector(self.a.x - p.x, self.a.y - p.y).length()\n\nclass segment:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def min_distance(self, p):\n        if dot_product(vector(self.b.x - self.a.x, self.b.y - self.a.y), vector(p.x - self.a.x, p.y - self.a.y)) >= 0:\n            return ray(self.b, self.a).distance(p)\n        return vector(self.a.x - p.x, self.a.y - p.y).length()\n\n    def max_distance(self, p):\n        return max(vector(self.a.x - p.x, self.a.y - p.y).length(), vector(self.b.x - p.x, self.b.y - p.y).length())\n\n\nn, x, y = map(int, input().split())\np = vector(x, y)\n\nmin_r = 2000000\nmax_r = 0\n\na = [[] for i in range(n + 1)]\n\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n    a[i] = vector(a[i][0], a[i][1])\n\na[n] = a[0]\n\nfor i in range(n):\n    s = segment(a[i], a[i + 1])\n    min_r = min(min_r, s.min_distance(p))\n    max_r = max(max_r, s.max_distance(p))\n\npi = 3.141592653589\nprint(pi * max_r ** 2 - pi * min_r ** 2)", "import math\nn, px, py = map(int, input().split())\nxs, ys, l = list(), list(), list()\nfor _ in range(n):\n\tx, y = map(int, input().split())\n\txs.append(x - px)\n\tys.append(y - py)\nx0, y0 = xs[-1], ys[-1]\nfor x, y in zip(xs, ys):\n\tl.append(x * x + y * y)\n\tdx, dy = x - x0, y - y0\n\tif (x0 * dx + y0 * dy) * (x * dx + y * dy) < 0:\n\t\tx0 = x0 * y - x * y0\n\t\tl.append(x0 * x0 / (dx * dx + dy * dy))\n\tx0, y0 = x, y\nprint(math.pi * (max(l) - min(l)))", "def main():\n    n, a, b = list(map(int, input().split()))\n    l, res = [], []\n    for _ in range(n):\n        u, v = input().split()\n        l.append((int(u) - a, int(v) - b))\n    x0, y0 = l[-1]\n    for x1, y1 in l:\n        res.append(x1 * x1 + y1 * y1)\n        dx, dy = x1 - x0, y1 - y0\n        if (x0 * dx + y0 * dy) * (x1 * dx + y1 * dy) < 0:\n            x0 = x0 * y1 - x1 * y0\n            res.append(x0 * x0 / (dx * dx + dy * dy))\n        x0, y0 = x1, y1\n    print((max(res) - min(res)) * 3.141592653589793)\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "import math\n\n\ndef Len (w):\n    return w[0] * w[0] + w[1] * w[1]\n\nn, x, y = input().split(' ')\nn = int(n)\nx = int(x)\ny = int(y)\n\narr = []\n\nfor i in range(0, n):\n    a, b = input().split(' ')\n    a = int(a)\n    b = int(b)\n    arr.append([a, b])\n\nr1 = 5000000000000\nr2 = -500000000000\n\nfor i in range(0, n):\n    st = [arr[(i + 1) % n][0] - arr[i][0], arr[(i + 1) % n][1] - arr[i][1]]\n    r = [arr[i][0] - x, arr[i][1] - y]\n    q = [arr[(i + 1) % n][0] - x, arr[(i + 1) % n][1] - y]\n    d = q[0] * r[1] - q[1] * r[0]\n    d *= d\n    s = d/Len(st)\n    if Len (q) - s < Len (st) and Len(r) - s < Len(st):\n        r1 = min(r1, s)\n        r2 = max(r2, s)\n\nfor i in arr:\n    s = (x - i[0]) * (x - i[0]) + (y - i[1]) * (y - i[1])\n    r1 = min(r1, s)\n    r2 = max(r2, s)\n\nprint ((r2 - r1) * math.pi)", "import functools\n \nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def squared_distance(self, another_point):\n        return (self.x - another_point.x) ** 2 + (self.y - another_point.y) ** 2\n\ndef point_segment_distance(p, a, b):\n    ap = (p.x - a.x, p.y - a.y)\n    ab = (b.x - a.x, b.y - a.y)\n    bp = (p.x - b.x, p.y - b.y)\n\n    indicator = (ap[0] * ab[0] + ap[1] * ab[1]) / (ab[0] ** 2 + ab[1] ** 2)\n    if 0 < indicator < 1:\n        return (ap[0] ** 2 + ap[1] ** 2) - indicator ** 2 * (ab[0] ** 2 + ab[1] ** 2)\n    if indicator <= 0:\n        return ap[0] ** 2 + ap[1] ** 2\n    if indicator >= 1:\n        return bp[0] ** 2 + bp[1] ** 2\n \nclass SnowBlower:       \n    def solution(self):\n        first_line = input()\n        first_line = first_line.split(\" \")\n        num_vertices = int(first_line[0])\n        origin = Point(int(first_line[1]), int(first_line[2]))\n \n        vertices = []\n        for _ in range(num_vertices):\n            point = input()\n            point = point.split(\" \")\n            vertices.append(Point(int(point[0]), int(point[1])))\n \n        max_distance = float(\"-inf\")\n        min_distance = float(\"inf\")\n        for vertex in vertices:\n            squared_distance = origin.squared_distance(vertex)\n            max_distance = squared_distance if squared_distance > max_distance else max_distance\n \n \n        for i in range(num_vertices):\n            distance = point_segment_distance(origin, vertices[i], vertices[i - 1])\n            min_distance = distance if distance < min_distance else min_distance\n \n \n        pi = 3.14159265358\n        \n        print(pi * (max_distance - min_distance))\n \n \ndef __starting_point():\n    snow_blower = SnowBlower()\n    snow_blower.solution()\n__starting_point()", "import math\n\ndef dot(v1, v2):\n    return v1[0]*v2[0] + v1[1]*v2[1]\n\ndef cross(v1, v2):\n    return v1[0]*v2[1] - v1[1]*v2[0]\n\ndef mag(x,y):\n    return math.sqrt(x**2 + y**2)\n\ndef main():\n    PI = 3.141592653589793\n    mags = []\n    \n    n, x0, y0 = map(int, input().split())\n\n    x, y = x0, y0\n    for i in range(n):\n        x_, y_ = map(int, input().split())\n        x_, y_ = x_ - x0, y_ - y0\n        if i == 0:\n            x1, y1 = x_ , y_\n            x, y = x_, y_\n\n        mags.append(mag(x_,y_))    \n\n        if dot([x,y],[x-x_, y-y_])*dot([x_,y_],[x_-x,y_-y]) > 0:\n            mags.append(abs(cross([x,y],[x_-x,y_-y])) / mag(x-x_,y-y_))\n    \n        x, y = x_, y_\n\n    if dot([x,y],[x-x1,y-y1])*dot([x1,y1],[x1-x,y1-y]) > 0:\n        mags.append(abs(cross([x,y],[x1-x,y1-y])) / mag(x-x1,y-y1))\n\n    print((max(mags)**2 - min(mags)**2) * PI)\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\n\ndef dotproduct(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n    product = (x1 * x2) + (y1 * y2)\n    return product\n\ndef crossproduct(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n    product = (x1 * y2) - (y1 * x2)\n    return product\n\ndef magnitude(x, y):\n    mag = math.sqrt(x**2 + y**2)\n    return mag\n\ndef main():\n    magnitudes = []\n\n    n, x0, y0 = list(map(int, input().split()))\n\n    x = x0\n    y = y0\n    for i in range(n):\n        x2, y2 = list(map(int, input().split()))\n        x2 = x2 - x0\n        y2 = y2 - y0\n\n        if (i == 0):\n            x1 = x2\n            y1 = y2\n            x = x2\n            y = y2\n\n        magnitudes.append(magnitude(x2, y2))\n\n        dot1 = dotproduct([x,y],[x - x2, y - y2])\n        dot2 = dotproduct([x2, y2], [x2 - x, y2 - y])\n\n        if ((dot1 * dot2) > 0):\n            total = abs(crossproduct([x, y], [x2 - x, y2 - y]) / magnitude(x - x2, y - y2))\n            magnitudes.append(total)\n\n        x = x2\n        y = y2\n\n    dot3 = dotproduct([x, y], [x - x1, y - y1])\n    dot4 = dotproduct([x1, y1], [x1 - x, y1 - y])\n\n    if ((dot3 * dot4) > 0):\n        total1 = abs(crossproduct([x, y], [x1 - x, y1 - y]) / magnitude(x - x1, y - y1))\n        magnitudes.append(total1)\n\n    print((max(magnitudes)**2 - min(magnitudes)**2) * 3.141592653589793)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "\"\"\" Peter and Snow Blower \"\"\"\nimport math\n\n\ndef cross(vecA, vecB):\n    return abs(vecA[0] * vecB[1] - vecA[1] * vecB[0])\n\n\ndef l2_norm(pointA, pointB):\n    return (pointA[0] - pointB[0]) ** 2 + (pointA[1] - pointB[1]) ** 2\n\n\ndef height5(P, A, B):\n    a = l2_norm(A, P)\n    b = l2_norm(B, P)\n    base = l2_norm(A, B)\n\n    # If obtuse triangles\n    if a >= base + b or b >= base + a:\n        return min(a, b)\n\n    else:\n        # If acute triangles\n        vecA = (A[0] - P[0], A[1] - P[1])\n        vecB = (B[0] - P[0], B[1] - P[1])\n        area = cross(vecA, vecB)\n        h = area * area / base\n        return h\n\n\ndef CF613A():\n    # Read number of points, center and the points\n    N, cx, cy = list(map(int, input().split()))\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n\n    # N, cx, cy = 3, 0, 0  # 12.56\n    # points = [(0, 1), (-1, 2), (1, 2)]\n    #\n    # N, cx, cy = 4, 1, -1  # 21.99\n    # points = [(0, 0), (1, 2), (2, 0), (1, 1)]\n    #\n    # N, cx, cy = 3, 0, 0  # 25.13\n    # points = [(-1, 1), (0, 3), (1, 1)]\n    #\n    # N, cx, cy = 3, -4, 2  # 405.26\n    # points = [(-3, 2), (5, -5), (5, 3)]\n\n    # Compute the max distance\n    center = (cx, cy)\n    distances = [l2_norm(center, point) for point in points]\n    max_radius = max(distances)\n\n    # Compute the min distance\n    min_radius = float('inf')\n    for i in range(N):\n        height = height5(center, points[i], points[(i + 1) % N])\n        min_radius = min(min_radius, height)\n\n    area = math.pi * (max_radius - min_radius)\n    return area\n\n\ndef __starting_point():\n    res = CF613A()\n    print(res)\n\n__starting_point()", "\"\"\" Peter and Snow Blower \"\"\"\nimport math\n\n\ndef cross(vecA, vecB):\n    return abs(vecA[0] * vecB[1] - vecA[1] * vecB[0])\n\n\ndef l2_norm(pointA, pointB):\n    return (pointA[0] - pointB[0]) ** 2 + (pointA[1] - pointB[1]) ** 2\n\n\ndef height5(P, A, B):\n    a = l2_norm(A, P)\n    b = l2_norm(B, P)\n    base = l2_norm(A, B)\n\n    # If obtuse triangles\n    if a >= base + b or b >= base + a:\n        return min(a, b)\n\n    else:\n        # If acute triangles\n        vecA = (A[0] - P[0], A[1] - P[1])\n        vecB = (B[0] - P[0], B[1] - P[1])\n        area = cross(vecA, vecB)\n        h = area * area / base\n        return h\n\n\ndef CF613A():\n    # Read number of points, center and the points\n    N, cx, cy = list(map(int, input().split()))\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n\n    # Compute the max distance\n    center = (cx, cy)\n    distances = [l2_norm(center, point) for point in points]\n    max_radius = max(distances)\n\n    # Compute the min distance\n    min_radius = float('inf')\n    for i in range(N):\n        height = height5(center, points[i], points[(i + 1) % N])\n        min_radius = min(min_radius, height)\n\n    area = math.pi * (max_radius - min_radius)\n    return area\n\n\ndef __starting_point():\n    res = CF613A()\n    print(res)\n\n__starting_point()", "import math\n\ndef dis(a0, b0, x, y):\n    return ((a0-x) ** 2 + (b0-y) ** 2) ** 0.5\n    \n# distance from point to segment\ndef minDistance(A, B, E) :  \n   \n    AB = [B[0] - A[0], B[1] - A[1]]  \n    BE = [E[0] - B[0], E[1] - B[1]]\n    AE = [E[0] - A[0], E[1] - A[1]]\n  \n    AB_BE = AB[0] * BE[0] + AB[1] * BE[1];  \n    AB_AE = AB[0] * AE[0] + AB[1] * AE[1];  \n  \n    reqAns = 0;  \n  \n    # Case 1  \n    if AB_BE > 0: \n        # Finding the magnitude  \n        y = E[1] - B[1] \n        x = E[0] - B[0]  \n        return (x * x + y * y) ** 0.5 \n  \n    # Case 2  \n    elif (AB_AE < 0) : \n        y = E[1] - A[1] \n        x = E[0] - A[0]  \n        return (x * x + y * y) ** 0.5\n  \n    # Case 3  \n    else: \n        # Finding the perpendicular distance  \n        x1, y1, x2, y2 = AB[0], AB[1], AE[0], AE[1]  \n        mod    = (x1 * x1 + y1 * y1) ** 0.5\n        \n        return abs(x1 * y2 - y1 * x2) / mod\n    \nn, x0, y0 = map(int, input().split())\nP    = [list(map(int, input().split())) for _ in range(n)]\n\nmax_ = 0\nmin_ = float(\"inf\")\n\nfor i in range(n):\n    p    = P[i]\n    \n    min_ = min(min_, minDistance(P[i], P[(i+1)%n], [x0, y0]))\n    max_ = max(max_, dis(x0, y0, p[0], p[1]))\n    \nprint(math.pi * (max_ * max_ - min_ * min_))"]
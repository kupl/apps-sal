["from typing import List\n\n\ndef winner(a: str, b: str) -> str:\n    return b if (a, b) in [(\"R\", \"P\"), (\"P\", \"S\"), (\"S\", \"R\")] else a\n\n\nN, K = list(map(int, input().split()))\nS: List[str] = list(input())\n\nfor i in range(K):\n    T: List[str] = S + S\n    S = [winner(T[2 * j], T[2 * j + 1]) for j in range(N)]\nprint((S[0]))\n", "win = {'R':'P', 'P':'S', 'S':'R'} # [lose]=win\nn, k = list(map(int, input().split()))\nS = input()\nfor _ in range(k):\n    t = S + S\n    for i in range(n):\n        a = t[i*2]; b = t[i*2+1]\n        S = S[:i] + (b if win[a]==b else a) + S[i+1:]\nprint((S[0]))\n", "def win(x, y):\n    if x + y in ['PR', 'RP', 'PP']:\n        return 'P'\n    if x + y in ['SR', 'RS', 'RR']:\n        return 'R'\n    if x + y in ['SP', 'PS', 'SS']:\n        return 'S'\n\nn, k = list(map(int, input().split()))\ns = list(input()[::-1]) * 2\n\nfor _ in range(k):\n    tmp = []\n    while s:\n        i, j = s.pop(), s.pop()\n        tmp.append(win(i, j))\n    s = tmp[::-1] * 2\nprint((s.pop()))\n", "def RPS(a,b):\n    if a == b:\n        return a\n    elif a == 'R' and b == 'S':\n        return a\n    elif a == 'P' and b == 'R':\n        return a\n    elif a == 'S' and b == 'P':\n        return a\n    else:\n        return b\n\nn,k = map(int, input().split())\ns= input()\n\nwhile k > 0:\n    t = s + s\n    s = []\n    for i in range(0,len(t),2):\n        s.append(RPS(t[i],t[i+1]))\n\n    k -= 1\nprint(s[0])", "N,K=map(int,input().split())\n\ns=input()\nS=s*4\nD={}\nD[(\"R\",\"R\")]=\"R\"\nD[(\"R\",\"S\")]=\"R\"\nD[(\"S\",\"R\")]=\"R\"\nD[(\"S\",\"S\")]=\"S\"\nD[(\"S\",\"P\")]=\"S\"\nD[(\"P\",\"S\")]=\"S\"\nD[(\"P\",\"P\")]=\"P\"\nD[(\"P\",\"R\")]=\"P\"\nD[(\"R\",\"P\")]=\"P\"\n\nfor i in range(K):\n    A=\"\"\n    for j in range(len(S)//2):\n        A+=D[(S[2*j],S[2*j+1])]\n    S=A*2\n    #print(S)\nprint(S[0])", "n, k = list(map(int, input().split()))\ns = input()\n\nfor _ in range(k):\n    tmp = \"\"\n    for i in range(0, 2 * n, 2):\n        s1 = s[i % n]\n        s2 = s[(i + 1) % n]\n        if s1 == s2:\n            tmp += s1\n        elif (s1, s2) in ((\"R\", \"S\"), (\"S\", \"R\")):\n            tmp += \"R\"\n        elif (s1, s2) in ((\"P\", \"S\"), (\"S\", \"P\")):\n            tmp += \"S\"\n        else:\n            tmp += \"P\"\n            \n    s = tmp\nprint((s[0]))\n", "n,k=map(int,input().split())\ns=input()\nimport sys\nsys.setrecursionlimit(10**5)\nmemo=[[None for i in range(k+1)]for j in range(n)]\ndef f(x,y):\n\tif memo[x][y]!=None:\n\t\treturn memo[x][y]\n\t\t\n\tif y==0:\n\t\tans=s[x]\n\telse:\n\t\tl=f(x,y-1)\n\t\tr=f((x+(2**(y-1)))%n,y-1)\n\t\tp=set([l,r])\n\t\tif len(p)==1:\n\t\t\tans=l\n\t\telif \"R\" not in p:\n\t\t\tans=\"S\"\n\t\telif \"S\" not in p:\n\t\t\tans=\"P\"\n\t\telse:\n\t\t\tans=\"R\"\n\tmemo[x][y]=ans\n\treturn ans\nprint(f(0,k))", "n, k = map(int, input().split())\ns = list(input())\n\njudge_d = [\n    [0, 0, 2], \n    [0, 1, 1], \n    [2, 1, 2],\n]\nname_to_ind = {'R':0, 'S':1, 'P':2}\nind_to_name = ['R', 'S', 'P']\n\ndef judge(a, b):\n    a, b = name_to_ind[a], name_to_ind[b]\n    ind = judge_d[a][b]\n    return ind_to_name[ind]\n\ndef Rec(s, k):\n    if k == 1:\n        if len(s) == 1:\n            s = s + s\n        print(judge(s[0], s[1]))\n    else:\n        if len(s) % 2 == 1:\n            s = s + s\n        l = len(s) // 2\n        S = []\n        for i in range(l):\n            S.append(judge(s[i*2], s[i*2+1]))\n        Rec(S, k-1)\n\nRec(s, k)", "R = \"R\"\nS = \"S\"\nP = \"P\"\n\ndef winner(a, b):\n    if a == b:\n        return a\n    if a != R and b != R:\n        return S\n    if a != S and b != S:\n        return P\n    if a != P and b != P:\n        return R\nn, k = map(int,input().split())\ns = input()\ns = s+s\nfor _ in range(k):\n    ns = ''\n    for i in range(n):\n        ns += winner(s[2*i],s[2*i+1])\n    s = ns+ns\nprint(s[0])", "n,k=[int(x) for x in input().split()]\ns=input()\nimport copy\nfor i in range(k):\n    t=[]\n    if n%2==1:\n        n*=2\n        s=s*2\n    for j in range(int(n/2)):\n        if (s[2*j]==\"R\" and s[2*j+1]==\"S\") or (s[2*j]==\"S\" and s[2*j+1]==\"R\"):\n            t.append(\"R\")\n        elif (s[2*j]==\"R\" and s[2*j+1]==\"P\") or (s[2*j]==\"P\" and s[2*j+1]==\"R\"):\n            t.append(\"P\")\n        elif (s[2*j]==\"S\" and s[2*j+1]==\"P\") or (s[2*j]==\"P\" and s[2*j+1]==\"S\"):\n            t.append(\"S\")\n        else:\n            t.append(s[2*j])\n    n/=2\n    s=copy.deepcopy(t)\n    #print(s)\nprint(s[0])", "n, k = map(int, input().split())\nS = input()\ndef battle(h1,h2):\n  return h1 if h2+h1 in 'SRPS' else h2\n\ndp = [[0]*n for _ in range(k+1)]\ndp[0] = list(S[:])\nfor i in range(1,k+1):\n  for j in range(n):\n    dp[i][j] = battle(dp[i-1][j], dp[i-1][(j+pow(2,i-1))%n])\nprint(dp[k][0])", "n, k = map(int, input().split())\ns = list(input())\nd = dict()\nd[(\"R\", \"S\")], d[(\"S\", \"R\")] = \"R\", \"R\"\nd[(\"P\", \"R\")], d[(\"R\", \"P\")] = \"P\", \"P\"\nd[(\"S\", \"P\")], d[(\"P\", \"S\")] = \"S\", \"S\"\nd[(\"R\", \"R\")], d[(\"P\", \"P\")], d[(\"S\", \"S\")] = \"R\", \"P\", \"S\"\nt = s + s\nfor _ in range(k):\n    for i in range(n):\n        t[i] = d[(t[2 * i], t[2 * i + 1])]\n    for i in range(n):\n        t[n + i] = t[i]\nans = t[0]\nprint(ans)", "n, k = list(map(int, input().split()))\ns = input()\ns += s\n\ndef judge(a,b):\n    if (a =='S'and b=='R')or(a=='R'and b=='P')or(a=='P' and b=='S'):\n        return b\n    else:\n        return a\n    \nhands = [''] * (2*n)\nfor i in range(len(s)):\n    hands[i] = s[i]\n\nfor i in range(k):\n    for j in range(n):\n        hands[j] = judge(hands[2*j], hands[2*j+1])\n    hands[n:] = hands[:n]\n\nprint((hands[0]))\n", "n, k = list(map(int, input().split()))\ns = list(input()[::-1]) * 2\n\nptn, win = 'PRPP_RSRR_SPSS', 'PRS'\nfor _ in range(k):\n    tmp = []\n    while s:\n        hand = ptn.index(s.pop() + s.pop())\n        tmp.append(win[hand // 5])\n    s = tmp[::-1] * 2\nprint((s.pop()))\n", "def win(a, b):\n    w = a\n    if a=='R' and b == 'P': w = b\n    if a=='P' and b == 'S': w = b\n    if a=='S' and b == 'R': w = b\n    return w\n\nn, k = list(map(int, input().split()))\ndp = [[c for c in input()]]\nfor i in range(k):\n    dp.append([*dp[i]])\n    for j in range(n):\n        dp[i+1][j] = win(dp[i][(j*2)%n], dp[i][(j*2+1)%n])\nprint((dp[k][0]))\n", "n, k = map(int, input().rstrip().split(\" \"))\nS = list(input())\n\ndef Game(a, b):\n    if(a == b):\n        win = a\n    elif(a == \"R\"):\n        if(b == \"S\"):\n            win = a\n        else:\n            win = b\n    elif(a == \"S\"):\n        if(b == \"P\"):\n            win = a\n        else:\n            win = b\n    else:\n        if(b == \"R\"):\n            win = a\n        else:\n            win = b\n    return win\n\nT = S\nl = len(T)\nfor i in range(k):\n    \n    U = T + T\n    l = len(U)\n    \n    for j in range(0, l, 2):\n        T[j//2] = Game(U[j], U[j+1])\n        \nprint(T[0])", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n\n\ndef main():\n\n    \n    dic = dict()\n    def solve(l, r, i):\n        if (i, r-l) in dic: return dic[(i, r-l)]\n        if (r-l==1): return s[i]       \n        mid = (l+r)//2\n        a = solve(l, mid, i)\n        b = solve(mid, r, (i+mid-l)%n)\n        res = \"\"\n        st = {a, b}\n        if st==set(\"RS\"): res = \"R\"\n        elif st==set(\"PR\"): res = \"P\"\n        elif st==set(\"SP\"): res = \"S\"\n        else: res = a\n        dic[(i, r-l)] = res\n        return res\n\n\n    n, k =list(map(int, input().split()))\n    s = input()\n    ans = solve(0, pow(2, k), 0)\n    print(ans)\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k=map(int, input().split());S=input();d=[list(S) for _ in range(k+1)]\nfor i in range(k):\n  for j in range(n):\n    a=d[i][j];b=d[i][(j+pow(2,i))%n];d[i+1][j]=a if b+a in'SRPS'else b\nprint(d[k][0])", "def winner(x, y):\n    return x if x + y in ['RS', 'PR', 'SP'] else y\n\nn, k = list(map(int, input().split()))\ns = input()\n\nfor _ in range(k):\n    if len(s) % 2 == 1:\n        s += s\n    s = ''.join(winner(s[2 * i], s[2 * i + 1]) for i in range(len(s) // 2))\n\nprint((s[0]))\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nn, k = list(map(int, input().split()))\ns = input()\n\nif n==1:\n    print(s)\n    return\n\n\n\ndic={}\ndic['RR'] = 'R'\ndic['SS'] = 'S'\ndic['PP'] = 'P'\ndic['RP'] = 'P'\ndic['PR'] = 'P'\ndic['PS'] = 'S'\ndic['SP'] = 'S'\ndic['RS'] = 'R'\ndic['SR'] = 'R'\n\ndp = [[-1]*n for i in range(110)]\n# dp[i][j]  i\u756a\u76ee\u306e\u9ad8\u3055\u3067\u5de6\u7aef\u304cj\u3068\u306a\u308b\u5834\u5408\u306e\u52dd\u8005\n\nss = s*2\nfor i in range(n):\n    dp[1][i]=dic[ss[i:i+2]]\n\ndef f(i, j):\n    if dp[i][j] != -1:\n        return dp[i][j]\n    else:\n        dp[i][j] = dic[f(i-1, j)+f(i-1, (pow(2,i-1)+j)%n)]\n        return dp[i][j]\n\n\nprint((f(k,0)))\n", "t=input\nN,K=map(int,t().split())\nS=t()*2\nfor k in range(K):\n T=\"\"\n for i in range(N):\n  T+=\"P_PSRRS\"[ord(S[i*2])+ord(S[i*2+1])-160]\n S=T*2\nprint(S[0])", "\nR = \"R\"\nS = \"S\"\nP = \"P\"\n\ndef winner(a, b):\n    if a == b:\n        return a\n    if a != R and b != R:\n        return S\n    if a != S and b != S:\n        return P\n    if a != P and b != P:\n        return R\n\nwin = {}\nn, k = map(int,input().split())\ns = input()\ns = s+s\nfor _ in range(k):\n    ns = ''\n    for i in range(n):\n        ns += winner(s[2*i],s[2*i+1])\n    s = ns+ns\nprint(s[0])", "def win(a, b):\n    w = a # \u3042\u3044\u3053\u306a\u3089 a, a \u304c\u8ca0\u3051\u306a\u3089 b\n    if a=='R' and b == 'P': w = b\n    if a=='P' and b == 'S': w = b\n    if a=='S' and b == 'R': w = b\n    return w\n\nn, k = list(map(int, input().split()))\nS = input()\n\nfor _ in range(k):\n    t = S + S\n    for i in range(n): S = S[:i] + win(t[i*2], t[i*2+1]) + S[i+1:]\nprint((S[0]))\n", "import sys\nsys.setrecursionlimit(10 ** 7)\ndef getnum(t=int): return t(sys.stdin.buffer.readline())\ndef numline(t=int): return map(t, sys.stdin.buffer.readline().split())\ndef numread(t=int): return map(t, sys.stdin.buffer.read().split())\ndef getstr(): return sys.stdin.readline().strip()\ndef strline(): return sys.stdin.readline().strip().split()\ndef strread(): return sys.stdin.read().strip().split()\n\n#from numba import njit, b1, i4, i8, f8, jit\n#import numpy as np\nimport math\ndef main():\n    n,k,s = strread()\n    N,K = int(n), int(k)\n    rel = {(w, w) : w for w in 'RSP'}\n    rel[('R','S')] = 'R'\n    rel[('R', 'P')] = 'P'\n    rel[('S', 'P')] = 'S'\n    for a,b in list(rel.keys()):\n        rel[(b,a)] = rel[(a,b)]\n    #print(rel)\n    for k in range(K, 0, -1):\n        if len(s) % 2:\n            s = s + s\n        next_s = ''\n        for i in range(0, len(s), 2):\n            next_s += rel[(s[i], s[i+1])]\n        if math.log2(len(next_s)) > k-1:\n            next_s = next_s[:2 ** (k-1)]\n        s = next_s\n        #print(next_s)\n    print(s[0])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n, k = map(int, input().split())\ns = input()\ndef f(x, y):\n    if x == y: return x\n    else:\n        if (x, y) == ('R', 'S') or (x, y) == ('S', 'P') or (x, y) == ('P', 'R'):\n            return x\n        else:\n            return y\n\ndp = [['']*n for _ in range(k+1)]\nfor i in range(n):\n    dp[0][i] = s[i]\n\ndef g(x, k):\n    if dp[k][x] != '': return dp[k][x]\n    a = x%n\n    b = (x + pow(2, k-1, n))%n\n    p = g(a, k-1)\n    q = g(b, k-1)\n    dp[k][x] = f(p, q)\n    return dp[k][x]\n\ng(0, k)\nprint(dp[k][0])", "n,k = map(int,input().split())\nS = list(input())\nhands = [\"R\",\"P\",\"S\"]\nfor i in range(len(S)):\n    S[i] = hands.index(S[i])\n\ndef judge(a,b):\n    a,b = max(a,b),min(a,b)\n    if (a,b) == (2,0):\n        return b\n    else:\n        return a\n\nfor _ in range(k):\n    S += S\n    T = []\n    for i in range(1,len(S),2):\n        T.append(judge(S[i-1],S[i]))\n    S = T\nprint(hands[T[0]])", "def rps(x, y):\n  if x == 'R' and y == 'P':\n    return y\n  if x == 'P' and y == 'S':\n    return y\n  if x == 'S' and y == 'R':\n    return y\n  else:\n    return x\n\nn, k = map(int, input().split())\ns = input()\nS = s+s\nfor i in range(k):\n  tmp = []\n  for j in range(0, len(S), 2):\n    tmp.append(rps(S[j], S[j+1]))\n  S = tmp+tmp\nprint(S[0])", "n,k=map(int,input().split())\ns=input()\n\ndef win(x,y):\n\tif x==y:\n\t\treturn x\n\telse:\n\t\thands=[x,y]\n\t\tif \"R\" not in hands:\n\t\t\treturn \"S\"\n\t\telif \"S\" not in hands:\n\t\t\treturn \"P\"\n\t\telse:\n\t\t\treturn \"R\"\n\nfor _ in range(k):\n\tt=s+s\n\ts=[]\n\tfor i in range(n):\n\t\ts.append(win(t[i*2],t[i*2+1]))\nprint(s[0])", "N, K = list(map(int, input().split()))\nS = input()\n\ndef judge(a, b):\n    win = a\n    if a+b == \"RP\":\n        win = b\n    elif a+b == \"PS\":\n        win = b\n    elif a+b == \"SR\":\n        win = b\n    return win\n\nmemo = [[\"\"] * (N+5) for _ in range(K+5)]\ndef rec(k, i):\n    if memo[k][i]: return memo[k][i]\n    if k == 0:\n        ret = judge(S[i%N], S[(i+1)%N])\n        memo[k][i] = ret\n        return ret\n    win = judge(rec(k-1, i%N), rec(k-1, (i+pow(2,k,N))%N))\n    memo[k][i] = win\n    return win\n\nans = rec(K-1, 0)\nprint(ans)\n", "n,k=map(int, input().split());S=input();d=[list(S) for _ in range(k+1)]\nfor i in range(k):\n  for j in range(n):a=d[i][j];b=d[i][(j+pow(2,i))%n];d[i+1][j]=a if b+a in'SRPS'else b\nprint(d[k][0])", "def main():\n  n, k = map(int, input().split())\n  s = input()\n  s += s\n  for i in range(k):\n    tmp = \"\"\n    for j in range(0, 2*n, 2):\n      if s[j] == s[j+1]:\n        tmp += s[j]\n      else:\n        if s[j] == \"R\":\n          if s[j+1] == \"S\":\n            tmp += s[j]\n          else:\n            tmp += s[j+1]\n        elif s[j] == \"P\":\n          if s[j+1] == \"R\":\n            tmp += s[j]\n          else:\n            tmp += s[j+1]\n        else:\n          if s[j+1] == \"P\":\n            tmp += s[j]\n          else:\n            tmp += s[j+1]\n    s = tmp + tmp\n  print(s[0])\n  \ndef __starting_point():\n  main()\n__starting_point()", "def merge(x, y):\n    if x == y:\n        return x\n    if x != \"R\" and y != \"R\":\n        return \"S\"\n    if x != \"P\" and y != \"P\":\n        return \"R\"\n    return \"P\"\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    S = input()\n    cur = S\n    for i in range(k):\n        prev = cur\n        cur = [None] * n\n        for j in range(n):\n            cur[j] = merge(prev[(j*2) % n], prev[(j*2+1) % n])\n    print((cur[0]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(5000)\nn, k = list(map(int, input().split()))\ns = input()\nwin = {\"R\": \"S\", \"P\": \"R\", \"S\": \"P\"}\nmemo = [[-1] * (k+1) for _ in range(n+1)]\n\ndef rec(idx, k):\n    if k == 0:\n        return s[idx]\n    if memo[idx][k] != -1:\n        return memo[idx][k]\n\n    idxr = (idx+pow(2, k-1))%n\n    lte = rec(idx, k-1)\n    rte = rec(idxr, k-1)\n    if lte == rte:\n        winte = lte\n    else:\n        if win[lte] == rte:\n            winte = lte\n        else:\n            winte = rte\n    memo[idx][k] = winte\n    return winte\n\nw = rec(0, k) \nprint(w)\n", "n, k = list(map(int, input().split()))\ns = list(input()[::-1]) * 2\n\nptn, win = 'PR_RS_SP_RP_SR_PS_PP_RR_SS', 'PRS'\nfor _ in range(k):\n    tmp = []\n    while s:\n        hand = ptn.index(s.pop() + s.pop())\n        tmp.append(win[hand // 3 % 3])\n    s = tmp[::-1] * 2\nprint((s.pop()))\n", "from re import split\n\n\ndef main():\n\n    _, k = list(map(int, input().split()))\n    s = list(input())\n    new_s =[]\n\n    for i in range(k):\n\n        if len(s) % 2 == 1:\n            s = s * 2\n\n        s = [s[2*i:2*i+2] for i in range(len(s) // 2)]\n\n        for l in s:\n            if l[0] == \"R\":\n                if l[1] == \"P\":\n                    new_s.append(\"P\")\n                else:\n                    new_s.append(\"R\")\n            elif l[0] == \"S\":\n                if l[1] == \"R\":\n                    new_s.append(\"R\")\n                else:\n                    new_s.append(\"S\")\n            if l[0] == \"P\":\n                if l[1] == \"S\":\n                    new_s.append(\"S\")\n                else:\n                    new_s.append(\"P\")\n\n        s = new_s\n        new_s = []\n\n    print((s[0]))\n\nmain()\n\n", "n, k = list(map(int, input().split()))\ns = list(input()[::-1]) * 2\n\nptn, win = 'PR_RP_PP_RS_SR_RR_SP_PS_SS', 'PRS'\nfor _ in range(k):\n    tmp = []\n    while s:\n        hand = ptn.index(s.pop() + s.pop())\n        tmp.append(win[hand // 9])\n    s = tmp[::-1] * 2\nprint((s.pop()))\n", "from bisect import bisect_left,bisect_right, insort_left\nfrom collections import Counter,defaultdict,deque\nfrom heapq import heapify,heappop,heappush,heappushpop\nfrom itertools import combinations,permutations\nfrom math import gcd,factorial,log2\nfrom pprint import pprint\nfrom sys import setrecursionlimit\nfrom time import time\n\nsetrecursionlimit(10**9)\nMOD=10**9+7\nINF=10**18\n\n#\u540c\u3058\u30d1\u30bf\u30fc\u30f3\u304c\u304f\u308b\u3068\u3053\u308d\u3092\u8003\u3048\n#\u30e1\u30e2\u3067\u679d\u5207\u3092\u3059\u308b\n\nn,k=list(map(int,input().split()))\ns=input()\n\nmemo=[[None]*n for _ in range(k+1)]\ndef win(a,b):\n    _a=s[a%n]\n    _b=s[b%n]\n    win \n    if _a==_b:return a\n    if _a=='R':\n        return a if _b=='S' else b\n    if _a=='P':\n        return a if _b=='R' else b\n    if _a=='S':\n        return a if _b=='P' else b\ncnt=0\ndef recur(a,b):\n    nonlocal cnt\n    cnt+=1\n    if memo[int(log2(b-a))][a%n] is not None:\n        return a+memo[int(log2(b-a))][a%n]\n    else:\n        if b-a<=2:\n            winner=win(a,b-1)\n        else:\n            winner=win(recur(a,(a+b)//2),recur((a+b)//2,b))\n        memo[int(log2(b-a))][a%n]=winner%(b-a)\n        return winner\nprint((s[recur(0,2**k)%n]))\n    \n", "import sys\nsys.setrecursionlimit(5000)\nn, k = list(map(int, input().split()))\ns = input()\nwin = {\"R\": \"S\", \"P\": \"R\", \"S\": \"P\"}\nmemo = [[-1] * (k+1) for _ in range(n+1)]\n\ndef rec(idx, k):\n    if k == 0:\n        return s[idx]\n    if memo[idx][k] != -1:\n        return memo[idx][k]\n\n    idxr = (idx+pow(2, k-1))%n\n    lte = rec(idx, k-1)\n    rte = rec(idxr, k-1)\n    if lte == rte:\n        winte = lte\n    else:\n        if win[lte] == rte:\n            winte = lte\n        else:\n            winte = rte\n    memo[idx][k] = winte\n    return winte\n\nw = rec(0, k) \nprint(w)\n", "def rps(a,b):\n    if a == 'R' and b == 'S':\n        return a\n    if a == 'P' and b == 'R':\n        return a\n    if a == 'S' and b == 'P':\n        return a\n    if a == b:\n        return a\n    return b\n\nn,k = map(int,input().split())\ns = list(input())\nfor _ in range(k):\n    t = list(s) * 2\n    s = ''\n    for i in range(0,n*2,2):\n        s += rps(t[i],t[i+1])\nprint(s[0])", "N,K=map(int,input().split())\nS=input()\nfor i in range(K):\n  S=S+S\n  t=\"\"\n  for j in range(0,2*N,2):\n    if (S[j]==\"R\" and (S[j+1]==\"S\" or S[j+1]==\"R\")) or (S[j]==\"S\" and S[j+1]==\"R\"):\n      t+=\"R\"\n    elif (S[j]==\"S\" and (S[j+1]==\"S\" or S[j+1]==\"P\")) or (S[j]==\"P\" and S[j+1]==\"S\"):\n      t+=\"S\"\n    else:\n      t+=\"P\"\n  S=t\nprint(S[0])", "N,k = map(int,input().split())\nS = list(input())\ndef zyanken(a,b):\n    if a == \"R\":\n        if b == \"P\":\n            return \"P\"\n        else:\n            return \"R\"\n    elif a == \"S\":\n        if b == \"R\":\n            return \"R\"\n        else:\n            return \"S\"\n    elif a == \"P\":\n        if b == \"S\":\n            return \"S\"\n        else:\n            return \"P\"\nnow = k\nf = 0\nif N == 1:\n    print(S[0])\nelse:\n    while now > 0:\n        T = S + S\n        for i in range(0,N):\n            S[i]=(zyanken(str(T[(i*2)%N]),str(T[(2*i+1)%N])))\n        now -= 1\n    print(S[0])", "import sys, math, random, re, heapq\nfrom itertools import combinations as c, permutations as perm, product as p\nfrom collections import deque\nfrom copy import deepcopy\nsys.setrecursionlimit(10**9)\nINF = float('inf')\n#MOD = 10**9 + 7\nMOD = 998244353\nF = 1e-9\n\n\ndef si(): return input()\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef lstr(): return input().split()\ndef lint(): return list(map(int, input().split()))\ndef lintdec(): return list(map(lambda x:int(x) - 1, input().split()))\ndef lnstr(n): return [input() for _ in range(n)]\ndef lnint(n): return [ii() for _ in range(n)]\ndef lint_list(n): return [lint() for _ in range(n)]\ndef lcm(a, b): return a * b // math.gcd(a, b)\n\n\n\n#######################################################\nN, K = lint()\nS = si()\nJ = {'R':0, 'S':1, 'P':2}\ndp = [[0] * 110 for _ in range(110)]\n\n\ndef winner(x, y):\n    if (J[x] - J[y] + 3) % 3 == 1:\n        return y\n    return x\n\n\ndef tournament(m, n):\n    if n == 0:\n        dp[m][n] = S[m]\n    if dp[m][n]:\n        return dp[m][n]\n\n    a = tournament(m, n - 1)\n    b = tournament((m + pow(2, n - 1, N)) % N, n - 1)\n    dp[m][n] = winner(a, b)\n    return dp[m][n]\n\n\ndef main():\n    print(tournament(0, K))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main(n, k, s):\n    memo = dict()\n\n    def junken(c_left, c_right):\n        if c_left == 'R':\n            if c_right == 'R':\n                return 'R'\n            elif c_right == 'P':\n                return 'P'\n            else:\n                return 'R'\n        elif c_left == 'P':\n            if c_right == 'R':\n                return 'P'\n            elif c_right == 'P':\n                return 'P'\n            else:\n                return 'S'\n        else:\n            if c_right == 'R':\n                return 'R'\n            elif c_right == 'P':\n                return 'S'\n            else:\n                return 'S'\n\n    def f(left, left_idx, right, right_idx):\n        # print(left, left_idx, right, right_idx)\n\n        if memo.get((left_idx, right_idx, right - left)) is not None:\n            return memo[(left_idx, right_idx, right - left)]\n\n        if right - left == 1:\n            # print(left, left_idx, right, right_idx, s[left_idx])\n            return s[left_idx]\n\n        mid = left + (right - left) // 2\n\n        res = junken(f(left, left_idx, mid, mid % n), f(mid, mid % n, right, right_idx))\n        memo[(left_idx, right_idx, right - left)] = res\n\n        # print(left, left_idx, right, right_idx, res)\n        return res\n\n    print((f(0, 0 % n, (1 << k), (1 << k) % n)))\n\ndef __starting_point():\n    nk = [int(x) for x in input().split()]\n    n, k = nk[0], nk[1]\n    s = input()\n    main(n, k, s)\n\n__starting_point()", "def janken(sa,sb):\n    if (sa==\"R\" and sb==\"S\") or (sa==\"S\" and sb==\"R\"):return \"R\"\n    if (sa==\"P\" and sb==\"R\") or (sa==\"R\" and sb==\"P\"):return \"P\"\n    if (sa==\"S\" and sb==\"P\") or (sa==\"P\" and sb==\"S\"):return \"S\"\n    if sa==sb:return sa\n\nn,k = list(map(int,input().split()))\ns = input()\n\nmemo = [list(s)] + [[None]*n for _ in range(k)]\n\nfor i in range(1,k+1):\n    for j in range(n):\n        sa = memo[i-1][j]\n        sb = memo[i-1][(j+2**(i-1))%n]\n        memo[i][j] = janken(sa,sb)\nprint((memo[k][0]))\n", "import sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nS = readline().rstrip()\n\nS *= 2\nN *= 2\n\nWIN = {\"RP\":\"P\",\"PR\":\"P\",\"PS\":\"S\",\"SP\":\"S\",\"SR\":\"R\",\"RS\":\"R\"}\ndef win(a,b):\n  if a == b:\n    return a\n  return WIN[a + b]\n  \n\nfor k in range(K):\n  newS = \"\"\n  for i in range(N // 2):\n    newS += win(S[i * 2],S[i * 2 + 1])\n  S = newS * 2\n\nprint(S[0])", "N,K = map(int,input().split())\nS = list(input())\nhand = [\"R\",\"P\",\"S\"]\nfor i in range(N):\n    S[i] = hand.index(S[i])\n\ndef judge(A,B):\n    A,B = min(A,B),max(A,B)\n    if A == 0 and B == 2:\n        return A\n    else:\n        return B\n\ncnt = K\n\nwhile cnt:\n    S += S\n    T = []\n    for i in range(0,len(S),2):\n        T.append(judge(S[i],S[i+1]))\n    S = T\n    cnt -= 1\nprint(hand[S[0]])", "from bisect import bisect_left,bisect_right, insort_left\nfrom collections import Counter,defaultdict,deque\nfrom heapq import heapify,heappop,heappush,heappushpop\nfrom itertools import combinations,permutations\nfrom math import gcd,factorial,log2\nfrom pprint import pprint\nfrom sys import setrecursionlimit\nfrom time import time\n\nsetrecursionlimit(10**9)\nMOD=10**9+7\nINF=10**18\n\nn,k=list(map(int,input().split()))\ns=input()\n\nmemo=[[None]*n for _ in range(k+1)]\ndef win(a,b):\n    _a=s[a%n]\n    _b=s[b%n]\n    win \n    if _a==_b:return a\n    if _a=='R':\n        return a if _b=='S' else b\n    if _a=='P':\n        return a if _b=='R' else b\n    if _a=='S':\n        return a if _b=='P' else b\ncnt=0\ndef recur(a,b):\n    nonlocal cnt\n    cnt+=1\n    if memo[int(log2(b-a))][a%n] is not None:\n        return a+memo[int(log2(b-a))][a%n]\n    else:\n        if b-a<=2:\n            winner=win(a,b-1)\n        else:\n            winner=win(recur(a,(a+b)//2),recur((a+b)//2,b))\n        memo[int(log2(b-a))][a%n]=winner%(b-a)\n        return winner\nprint((s[recur(0,2**k)%n]))\n    \n", "from bisect import bisect_left,bisect_right, insort_left\nfrom collections import Counter,defaultdict,deque\nfrom heapq import heapify,heappop,heappush,heappushpop\nfrom itertools import combinations,permutations\nfrom math import gcd,factorial,log2\nfrom pprint import pprint\nfrom sys import setrecursionlimit\nfrom time import time\n\nsetrecursionlimit(10**9)\nMOD=10**9+7\nINF=10**18\n\n#\u540c\u3058\u30d1\u30bf\u30fc\u30f3\u304c\u304f\u308b\u3068\u3053\u308d\u3092\u8003\u3048\n#\u30e1\u30e2\u3067\u679d\u5207\u3092\u3059\u308b\n\nn,k=list(map(int,input().split()))\ns=input()\n\nmemo=[[None]*n for _ in range(k+1)]\ndef win(a,b):\n    _a=s[a%n]\n    _b=s[b%n]\n    win \n    if _a==_b:return a\n    if _a=='R':\n        return a if _b=='S' else b\n    if _a=='P':\n        return a if _b=='R' else b\n    if _a=='S':\n        return a if _b=='P' else b\ndef recur(a,b):\n    if memo[int(log2(b-a))][a%n] is not None:\n        return a+memo[int(log2(b-a))][a%n]\n    else:\n        if b-a<=2:\n            winner=win(a,b-1)\n        else:\n            winner=win(recur(a,(a+b)//2),recur((a+b)//2,b))\n        memo[int(log2(b-a))][a%n]=winner%(b-a)\n        return winner\nprint((s[recur(0,2**k)%n]))\n    \n", "n, k = map(int, input().split())\ns = input()\n\nn, s = 2 * n, 2 * s\nfor _ in range(k):\n    tmp = []\n    for i in range(0, n, 2):\n        if s[i] == s[i + 1]:\n            tmp.append(s[i])\n        else:\n            comb = sorted([s[i], s[i + 1]])\n            if comb == ['P', 'R']:\n                tmp.append('P')\n            elif comb == ['R', 'S']:\n                tmp.append('R')\n            else:\n                tmp.append('S')\n    s = ''.join(2 * tmp)\nprint(s[0])", "import bisect, copy, heapq, math, sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\ndef celi(a,b):\n    return -(-a//b)\nsys.setrecursionlimit(5000000)\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn,k=map(int,input().split())\ns=list(input())\n\ndef check(a,b):\n    if a==b:\n        return 0\n    else:\n        if a==\"R\":\n            if b==\"P\":\n                return 1\n            else:\n                return 0\n        elif a==\"P\":\n            if b==\"S\":\n                return 1\n            else:\n                return 0\n        else:\n            if b==\"R\":\n                return 1\n            else:\n                return 0\n\nlst=s\nfor i in range(k):\n    sanka=2**(k-i)\n    tmp=[]\n    if len(lst)%2:\n        lst=lst+lst\n    # print(lst)\n    m=min(len(lst),sanka)\n    # print(i,m)\n    for j in range(m//2):\n        kk=check(lst[2*j],lst[2*j+1])\n        tmp.append(lst[2*j+kk])\n    lst=tmp[::]\nprint(lst[0])", "from collections import defaultdict\n\nn, k = list(map(int, input().split()))\ns = input()\nsL = []\nfor i in s:\n    sL.append(i)\n\nd = defaultdict(lambda: defaultdict(str))\nd['R']['S'], d['R']['R'], d['S']['R'] = 'R', 'R', 'R'\nd['P']['R'], d['P']['P'], d['R']['P'] = 'P', 'P', 'P'\nd['S']['P'], d['S']['S'], d['P']['S'] = 'S', 'S', 'S'\n\n\nfor _ in range(k):\n    t = ''.join(sL + sL)\n    for j in range(n):\n        sL[j] = d[t[2 * j]][t[2 * j + 1]]\nprint((sL[0]))\n", "#a\u3068b\u3069\u3061\u3089\u304c\u52dd\u3064\u304b\ndef comp(a, b):\n    if a=='R' and b=='P': return b\n    elif a=='P' and b=='S': return b\n    elif a=='S' and b=='R': return b\n    else: return a\nN, K = map(int, input().split())\nS = input()\nT = S + S\ndp = [[] for i in range(K+1)]\nfor i in range(2*N):\n    dp[0].append(T[i])\n\nfor k in range(1,K+1):\n    for i in range(N):\n        dp[k].append(comp(dp[k-1][2*i], dp[k-1][2*i+1]))\n    dp[k] = dp[k]+dp[k]\nprint(dp[K][0])", "import sys\nsys.setrecursionlimit(10**6)\nN,K=list(map(int, input().split()))\nS=input()\n\n\nS=S+S\n\ndef judge(a,b):\n    if a==b:\n        return a\n    elif a==\"R\":\n        if b==\"S\":\n            return a\n        else:\n            return b\n\n    elif a==\"P\":\n        if b==\"R\":\n            return a\n        else:\n            return b\n\n    elif a==\"S\":\n        if b==\"R\":\n            return b\n        else:\n            return a\n\nfor k in range(K):\n    N=len(S)\n    #print(S)\n    T=\"\"\n    for i in range(0,N,2):\n        T+=judge(S[i],S[i+1])\n    S=T+T\nprint((S[0]))\n", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, K = mapint()\nS = list(input())\n\ndef judge(ai, bi):\n    a, b = S[ai%N], S[bi%N]\n    if a==b:\n        return ai\n    elif (a=='R' and b=='S') or (a=='P' and b=='R') or (a=='S' and b=='P'):\n        return ai\n    else:\n        return bi\n\ndef fight(lis):\n    length = len(lis)\n    ret = []\n    for i in range(0, length, 2):\n        ret.append(judge(lis[i], lis[i+1]))\n    return ret\n\ncnt = N\ngoal = 2**K\nold = list(range(N))\nwhile cnt <= goal:\n    new = fight(old*2)\n    cnt *= 2\n    old = new\n\nrem = old[:min(2**(N.bit_length()-1), 2**K)]\n\nwhile len(rem)!=1:\n    rem = fight(rem)\nprint(S[rem[0]])", "n,k = map(int,input().split())\ns = list(input())\n\nwhile k:\n    t = s+s\n    s = []\n    for i in range(n):\n        a,b = t[i*2],t[i*2+1]\n        if a == b:\n            s.append(a)\n        elif (a == \"P\" and b == \"R\") or (a == \"R\" and b == \"P\"):\n            s.append(\"P\")\n        elif (a == \"P\" and b == \"S\") or (a == \"S\" and b == \"P\"):\n            s.append(\"S\")\n        elif (a == \"S\" and b == \"R\") or (a == \"R\" and b == \"S\"):\n            s.append(\"R\")\n    k -= 1\nprint(s[0])", "from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nfrom bisect import bisect_left,bisect_right \nimport sys,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nwin = [('R','S'),('S','P'),('P','R')]\ndef ch(a,b):\n    if a == b: return True\n    if (a,b) in win: return True\n    return False\nn,k = inpl()\ns = list(input())\nfor _ in range(k):\n    s += s\n    nx = []\n    for i in range(2*n)[::2]:\n        if ch(s[i],s[i+1]): nx.append(s[i])\n        else: nx.append(s[i+1])\n    s = nx[::]\nprint(s[0])", "n,k = map(int,input().split())\ns = list(input())\n\nwhile k:\n    t = s+s\n    s = []\n    for i in range(n):\n        a,b = t[i*2],t[i*2+1]\n        if a == b:\n            s.append(a)\n        elif (a == \"P\" and b == \"R\") or (a == \"R\" and b == \"P\"):\n            s.append(\"P\")\n        elif (a == \"P\" and b == \"S\") or (a == \"S\" and b == \"P\"):\n            s.append(\"S\")\n        elif (a == \"S\" and b == \"R\") or (a == \"R\" and b == \"S\"):\n            s.append(\"R\")\n    k -= 1\nprint(s[0])", "t=input\nN,K=map(int,t().split())\nS=t()*2\nW=\"P_PSRRS\"\nfor k in range(K):\n  T=\"\"\n  for i in range(N):\n    T+=W[ord(S[i*2])+ord(S[i*2+1])-160]\n  S=T*2\nprint(S[0])", "from collections import defaultdict\nn, k = list(map(int, input().split()))\ns = input()\n\nd = defaultdict(lambda: defaultdict(str))\nd['R']['R'], d['R']['S'], d['S']['R'] = 'R', 'R', 'R'\nd['P']['P'], d['P']['R'], d['R']['P'] = 'P', 'P', 'P'\nd['S']['S'], d['S']['P'], d['P']['S'] = 'S', 'S', 'S'\n\ns2 = s + s\ncount = k\nwhile count > 0:\n    tmp = ''\n    for i in range(0, len(s2), 2):\n        tmp += d[s2[i]][s2[i + 1]]\n    s2 = tmp + tmp\n    count -= 1\n\nprint((s2[0]))\n", "N,K = list(map(int,input().split()))\nS = list(input())\nT = [\"R\",\"P\",\"S\"]\nfor i in range(N):\n    S[i] = T.index(S[i])\n\nfor _ in range(K):\n    S += S\n    tmp = []\n    for i in range(0,len(S),2):\n        a,b = S[i],S[i+1]\n        a,b = max(a,b),min(a,b)\n        if a == 2 and b == 0:\n            x = b\n        else:\n            x = a\n        tmp.append(x)\n    S = tmp\n\nprint((T[S[0]]))\n", "# arc109c\ndef win(i, j):\n    if i == j:\n        return i\n    if i == 'R' and j == 'P':\n        return 'P'\n    if i == 'P' and j == 'R':\n        return 'P'\n\n    if i == 'P' and j == 'S':\n        return 'S'\n    if i == 'S' and j == 'P':\n        return 'S'\n\n    if i == 'S' and j == 'R':\n        return 'R'\n    if i == 'R' and j == 'S':\n        return 'R'\n\n\ndef step(S, k):\n    T = S + S\n    tmp = ''\n    for i in range(len(S)):\n        tmp += win(T[2*i], T[2*i+1])\n    return tmp, k-1\n\n\nn, k = list(map(int, input().split()))\ns = input()\nnow = s\nrem = k\n\nwhile rem > 0:\n    now, rem = step(now, rem)\n\nprint((now[0]))\n", "import sys\nfrom functools import reduce\n\nzz=1\n \nsys.setrecursionlimit(10**5)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef ii():\n\treturn input().rstrip()\t\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tlist(map(int,input().split()))\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\nuu=t\nw={\"PS\":\"S\",\"PR\":\"P\",\"RS\":\"R\"}\ndef winner(s,p):\n\tif s==p:\n\t\treturn s\n\treturn w[\"\".join(sorted(s+p))]\ndp={}\ndef rec(i,j):\n\tif j==0:\n\t\tdp[i,j]=s[i]\n\t\treturn dp[i,j]\n\tif (i,j) in dp:\n\t\treturn dp[i,j]\n\tdp[i,j]=winner(rec(i,j-1),rec((i+pow(2,j-1,n))%n,j-1))\n\treturn dp[i,j]\t\t\nwhile t>0:\n\tt-=1\n\tn,k=mi()\n\ts=ii()\t\n\tprint((rec(0,k)))\n", "win = {'R':'P', 'P':'S', 'S':'R'} # [lose]=win\nn, k = list(map(int, input().split()))\ns = t = input()\nfor _ in range(k):\n    t , s = s, t[:n]\n    t += t\n    for i in range(n):\n        a = t[i*2]; b = t[i*2+1]\n        s = s[:i] + (b if win[a]==b else a) + s[i+1:]\nprint((s[0]))\n", "import numpy as np\n\ndef RPS(s1, s2):\n  if s1 == s2:\n    return s1\n  elif set([s1, s2]) == set([\"R\", \"P\"]):\n    return \"P\"\n  elif set([s1, s2]) == set([\"P\", \"S\"]):\n    return \"S\"\n  elif set([s1, s2]) == set([\"S\", \"R\"]):\n    return \"R\"\n\ndef main():\n  N, K = map(int, input().split())\n  s = str(input())\n  dp = [[0]*N for _ in range(K+1)]\n  for i in range(N):\n    dp[0][i] = s[i]\n  for k in range(1, K+1):\n    for i in range(N):\n      dp[k][i] = RPS(dp[k-1][2*i%N], dp[k-1][(2*i+1)%N])\n  print(dp[K][0])\n      \ndef __starting_point():\n  main()\n__starting_point()", "n, k = map(int, input().split())\ns = input()\n\ndef win(a, b):\n  if a == b: return a\n  return a if a + b in [\"RS\", \"SP\", \"PR\"] else b\n\nshift = 1\nfor i in range(k):\n  s1 = \"\"\n  for j in range(n):\n    x, y = s[j], s[(j + shift) % n]\n    s1 += win(x, y)\n  s = s1\n  shift = shift * 2 % n\n\nprint(s[0])", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, K = mapint()\nS = list(input())\n\ndef judge(ai, bi):\n    a, b = S[ai%N], S[bi%N]\n    if a==b:\n        return ai\n    elif (a=='R' and b=='S') or (a=='P' and b=='R') or (a=='S' and b=='P'):\n        return ai\n    else:\n        return bi\n\ndef fight(lis):\n    length = len(lis)\n    ret = []\n    for i in range(0, length, 2):\n        ret.append(judge(lis[i], lis[i+1]))\n    return ret\n\nold = list(range(N))\nfor _ in range(K):\n    old = fight(old*2)\nprint(S[old[0]])", "# See. https://atcoder.jp/contests/arc109/tasks/arc109_c\n\n\ndef solve(S):\n  # R>S>P>R\n  tbl = {\n    # ord(\"P\")\n    80: {80: 80, 82: 80, 83: 83},\n    # ord(\"R\")\n    82: {80: 80, 82: 82, 83: 82}, \n    # ord(\"S\")\n    83: {80: 83, 82: 82, 83: 83},\n  }\n  if len(S)%2 == 1:\n    S = S*2\n  \n  S_ = []\n  for i in range(int(len(S)/2)):\n    S_.append(tbl[S[i*2]][S[i*2+1]])\n  return S_\n\ndef main():\n  N, K = [int(x) for x in input().split()]\n  S = [ord(x) for x in list(input())]\n\n  for k in range(K):\n    S = solve(S)\n\n  print((chr(S[0])))\n\nmain()\n\n# vim: ts=2 sw=2\n", "#template\ndef inputlist(): return [int(j) for j in input().split()]\n#template\nn,k = inputlist()\ns = input()\ns = s+s\nn*=2\n\ndef returnWinner(a,b):\n    if a == b:\n        return a\n    else:\n        if a+b == \"RS\" or a+b == \"SR\":\n            return \"R\"\n        if a+b == \"RP\" or a+b == \"PR\":\n            return \"P\"\n        if a+b == \"PS\" or a+b == \"SP\":\n            return \"S\"\n\nif k == 1:\n    ans = returnWinner(s[0],s[1])\n    print(ans)\n    return\nfrom copy import deepcopy\nfor i in range(k-1):\n    s = s+s\n    t = [\"R\"]*min(len(s)//2,2**(k-1-i))\n    for j in range(0,min(len(s),2**(k-i)),2):\n        t[j//2] = returnWinner(s[j],s[j+1])\n    s = deepcopy(t)\n    if len(s) == 1:\n        print(s[0])\n        return\n\n\nprint(s[0])", "def resolve():\n    N, K = map(int, input().split())\n    S = input()\n\n    def shorten(s):\n        if len(s)%2==1:\n            s = s*2\n        ans = \"\"\n        for i in range(0, len(s), 2):\n            if s[i] == s[i+1]:\n                ans = ans + s[i]\n            elif (s[i], s[i+1]) == (\"P\", \"R\") or (s[i], s[i+1]) == (\"R\", \"P\"):\n                ans = ans + \"P\"\n            elif (s[i], s[i + 1]) == (\"P\", \"S\") or (s[i], s[i + 1]) == (\"S\", \"P\"):\n                ans = ans + \"S\"\n            elif (s[i], s[i + 1]) == (\"R\", \"S\") or (s[i], s[i + 1]) == (\"S\", \"R\"):\n                ans = ans + \"R\"\n        return ans\n    ct = 0\n    while ct < K:\n        S = shorten(S)\n        ct += 1\n\n    print(S[0])\nresolve()", "n,k=map(int, input().split());S=input();d=[list(S) for _ in range(k+1)]\nfor i in range(k):\n  for j in range(n):\n    a=d[i][j];b=d[i][(j+pow(2,i))%n];d[i+1][j]=a if b+a in'SRPS'else b\nprint(d[k][0])", "n, k = map(int, input().split())\ns = input()\n\ns = s + s\n\ndef getVic(c):\n    if c[0] == c[1]:\n        return c[0]\n    else:\n        if not 'R' in c:\n            return 'S'\n        elif not 'S' in c:\n            return 'P'\n        else:\n            return 'R'\n\nfor i in range(k):\n    s_ = ''\n    for j in range(int(len(s) / 2)):\n        s_ = s_ + getVic(s[j*2:j*2+2])\n    s = s_ + s_\n\nprint(s[0])", "N,k = map(int,input().split())\nS = list(input())\ndef zyanken(a,b):\n    if a == \"R\":\n        if b == \"P\":\n            return \"P\"\n        else:\n            return \"R\"\n    elif a == \"S\":\n        if b == \"R\":\n            return \"R\"\n        else:\n            return \"S\"\n    elif a == \"P\":\n        if b == \"S\":\n            return \"S\"\n        else:\n            return \"P\"\nnow = k\nf = 0\ndp = [[\"\" for i in range(300)]for j in range(300)]\ndp[0] = S\nif N == 1:\n    print(S[0])\nelse:\n    for i in range(k):\n        for j in range(N):\n            dp[i+1][j] = zyanken(dp[i][(j*2)%N],dp[i][(j*2+1)%N])\n    print(dp[k][0])", "n,k = map(int, input().split())\ns = input()\n\ndef f(h1,h2):\n    if h1==h2:\n        return h1\n    if h1==\"P\":\n        if h2==\"R\":\n            return \"P\"\n        else:\n            return \"S\"\n    if h1==\"R\":\n        if h2==\"S\":\n            return \"R\"\n        else:\n            return \"P\"\n    if h1==\"S\":\n        if h2==\"P\":\n            return \"S\"\n        else:\n            return \"R\"\n\ndef solve(hands,k):\n    while k>0:\n        hands=nxt(hands)\n        k-=1\n#        print(hands,k)\n    print(hands[0])\n\ndef nxt(hands):\n    hands+=hands\n    n_hand=[]\n    for i in range(len(hands)//2):\n        win = f(hands[2*i], hands[2*i+1])\n        n_hand.append(win)\n\n    return n_hand\n\nsolve(s,k)", "N, K = map(int, input().split())\nS = input()\n\nprev = [S[i % N] for i in range(2 * N)]\n\nfor i in range(K):\n    res = []\n    for j in range(N):\n        if prev[j * 2] == 'R':\n            if prev[j * 2 + 1] == 'R':\n                res.append('R')\n            elif prev[j * 2 + 1] == 'P':\n                res.append('P')\n            else:\n                res.append('R')\n        elif prev[j * 2] == 'P':\n            if prev[j * 2 + 1] == 'R':\n                res.append('P')\n            elif prev[j * 2 + 1] == 'P':\n                res.append('P')\n            else:\n                res.append('S')\n        else:\n            if prev[j * 2 + 1] == 'R':\n                res.append('R')\n            elif prev[j * 2 + 1] == 'P':\n                res.append('S')\n            else:\n                res.append('S')\n    prev = res + res\n\nprint(res[0])", "n,k = map(int,input().split())\ns = input()\nq = \"\"\n\ndef a_win(a,b):\n  if a == \"S\" and b == \"P\":\n    return True\n  elif a ==\"P\" and b ==\"R\":\n    return True\n  elif a == \"R\" and b == \"S\":\n    return True\n  elif a ==b:\n    return True\n  else:\n    return False\nfor _ in range(k): \n  if len(s)%2 == 1:\n    s = s*2\n  for i in range(0,len(s),2):\n    if a_win(s[i],s[i+1]):\n      q += s[i]\n    else:\n      q += s[i+1]\n  s = q\n  q = \"\"\nprint(s[0])", "N, K = list(map(int, input().split()))\nS = input()\nD = {'R': 0, 'P': 1, 'S': 2}\n\n\ndef winner(a, b):\n    if (b-a) % 3 == 1:\n        return b\n    else:\n        return a\n\n\nL = [[0]*N for _ in range(K)]\nA = [D[S[i]] for i in range(N)]*2\n\nfor i in range(K):\n    for j in range(N):\n        L[i][j] = winner(A[2*j], A[2*j+1])\n    A = L[i]*2\nans = L[-1][0]\nif ans == 0:\n    print('R')\nelif ans == 1:\n    print('P')\nelse:\n    print('S')\n", "n,k=list(map(int,input().split()))\ns=list(input())\n\n#\u30b8\u30e3\u30f3\u30b1\u30f3\u306e\u52dd\u6557\ndef f(a,b):\n  p=set([\"R\",\"S\"])\n  q=set([\"P\",\"R\"])\n  r=set([\"S\",\"P\"])\n  if a==b:\n    return a\n  elif (a in p) and (b in p):\n    return \"R\"\n  elif (a in q) and (b in q):\n    return \"P\"\n  elif (a in r) and (b in r):\n    return \"S\"\n  \n#dp\u30c6\u30fc\u30d6\u30eb:dp[k][i]=\u9ad8\u3055\u304ck\u306e\u30c8\u30fc\u30ca\u30e1\u30f3\u30c8\u3067\u4e00\u756a\u5de6\u306e\u9078\u624b\u304cs[i]\u3067\u3042\u308b\ndp=[[0]*(n) for i in range(k+1)]\n\n#\u521d\u671f\u6761\u4ef6\nfor i in range(n):\n  dp[0][i]=s[i]\n  \n#\u6f38\u5316\u5f0f\nfor i in range(1,k+1):\n  for j in range(n):\n    dp[i][j]=f(dp[i-1][j],dp[i-1][(j+pow(2,i-1))%n])\n    \nprint((dp[k][0]))\n\n\n\n\n\n    \n", "t=input\nN,K=map(int,t().split())\nS=t()*2\nfor k in range(K):\n  T=\"\"\n  for i in range(N):\n    T+=\"P_PSRRS\"[ord(S[i*2])+ord(S[i*2+1])-160]\n  S=T*2\nprint(S[0])", "def winner(x, y):\n    return x if x + y in ['RS', 'PR', 'SP'] else y\n\ndef f(level, offset):\n    if (level, offset) in memo:\n        return memo[level, offset]\n    if level == 0:\n        ret = s[offset]\n    else:\n        sub1 = f(level - 1, offset)\n        sub2 = f(level - 1, (offset + 2 ** (level - 1)) % n)\n        ret = winner(sub1, sub2)\n    memo[level, offset] = ret\n    return ret\n\nn, k = list(map(int, input().split()))\ns = input()\n\nmemo = {}\nprint((f(k, 0)))\n", "# \u5148\u982d\u30d7\u30ec\u30a4\u30e4\u30fc\u304cS[offset]\u3067\u59cb\u307e\u308b\u90e8\u5206\u30c8\u30fc\u30ca\u30e1\u30f3\u30c8\u3092\u8003\u3048\u308b\n# 2^k\u4eba\u306e\u52dd\u8005\u3092\u4e88\u60f3\u3059\u308b\u3002\nN, K = map(int, input().split())\nS = input()\ndp = [['?']*(N+1) for i in range(K+1)]\ndef memo(k, i):\n    if k==0: return S[i]\n    if dp[k][i]!='?': return dp[k][i]\n    ni=(i+2**(k-1))%N\n    res = Win(memo(k-1,i), memo(k-1, ni))\n    dp[k][i] = res\n    return dp[k][i]\n\ndef Win(a, b):\n    if a=='R' and b=='P': return b\n    elif a=='P' and b=='S': return b\n    elif a=='S' and b=='R': return b\n    else: return a\nans = memo(K, 0)\nprint(ans)", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nips = lambda:input().split()\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nimport sys\nceil = math.ceil\ngcd = math.gcd\nRL = sys.stdin.readline\nINF=10**15\ndef ceilab(a,b):\n    return (a+b-1)//b\ndef JK(s1,s2):\n    if s1==\"R\":\n        if s2==\"P\":\n            return s2\n        else:\n            return s1\n    elif s1==\"S\":\n        if s2==\"R\":\n            return s2\n        else:\n            return s1\n    elif s1==\"P\":\n        if s2==\"S\":\n            return s2\n        else:\n            return s1\n\nN,K=ma()\nS = list(input())\nS = S*2\nT=[]\nfor k in range(K):\n    T=[]\n    for i in range(N):\n        T.append(JK(S[2*i],S[2*i+1]))\n    S = T*2\nprint(T[0])\n", "import bisect, collections, copy, functools, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9+7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    n, k = LI()\n    s = SS()\n    s = s * 2\n    d = {'R': 0, 'P': 1, 'S': 2}\n    d_r = {0: 'R', 1: 'P', 2: 'S'}\n\n    dp = [[-1] * n for _ in range(k + 1)]\n    # k: \u6728\u306e\u9ad8\u3055 i: s\u306e\u5de6\u304b\u3089\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\n    def f(k, i):\n        if dp[k][i] == -1:\n            if k == 0:\n                dp[k][i] = d[s[i]]\n            else:\n                l = f(k - 1, i)\n                r = f(k - 1, (i + pow(2, k - 1, n)) % n)\n                if l == r or (l - r) % 3 == 1:\n                    dp[k][i] = l\n                else:\n                    dp[k][i] = r\n        return dp[k][i]\n\n    f(k, 0)\n    print((d_r[dp[k][0]]))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,k=list(map(int,input().split()))\ns=input()\n\nW=[[0,1,0],[1,1,2],[0,2,2]]\nB=[[0]*n for _ in range(2)]\nJ='RPS'\n\nfor j in range(n):\n  B[0][j]= 0 if s[j]=='R' else (1 if s[j]=='P' else 2)\n\nfor i in range(k):\n  for j in range(n):\n    B[-~i%2][j]=W[B[i%2][j]][B[i%2][(j+2**i)%n]]\n\nprint((J[B[k%2][0]]))\n", "from typing import List\n\n\ndef winner(a: str, b: str) -> str:\n    return b if (a, b) in [(\"R\", \"P\"), (\"P\", \"S\"), (\"S\", \"R\")] else a\n\n\ndef rec(k, offset):\n    if k == 0:\n        return S[offset]\n    elif memo[k][offset] != \"?\":\n        return memo[k][offset]\n    former = rec(k - 1, offset)\n    latter = rec(k - 1, (offset + p2[k - 1]) % N)\n    memo[k][offset] = winner(former, latter)\n    return memo[k][offset]\n\n\nN, K = list(map(int, input().split()))\nS: List[str] = list(input())\n\np2 = [1]\nfor k in range(K):\n    p2.append(p2[-1] * 2 % N)\nmemo = [[\"?\"] * (N + 1) for _ in range(K + 1)]\nrec(K, 0)\nprint((memo[K][0]))\n", "n, k = list(map(int, input().split()))\ns = list(input()[::-1]) * 2\n\nptn = ['PR', 'RS', 'SP', 'RP', 'SR', 'PS', 'PP', 'RR', 'SS']\nfor _ in range(k):\n    tmp = []\n    while s:\n        win = ptn.index(s.pop() + s.pop()) % 3\n        tmp.append(['P', 'R', 'S'][win])\n    s = tmp[::-1] * 2\nprint((s.pop()))\n", "N, K = [int(_) for _ in input().split()]\nS = list(input())\ng = {}\ng['R', 'R'] = 'R'\ng['R', 'P'] = 'P'\ng['R', 'S'] = 'R'\ng['P', 'R'] = 'P'\ng['P', 'P'] = 'P'\ng['P', 'S'] = 'S'\ng['S', 'R'] = 'R'\ng['S', 'P'] = 'S'\ng['S', 'S'] = 'S'\nfor _ in range(K):\n    S *= 2\n    S = [g[a, b] for a, b in zip(S[::2], S[1::2])]\nprint((S[0]))\n", "def win(a, b):\n    if a == 'R':\n        if b == 'P': return 'P'\n        else: return 'R'\n    if a == 'S':\n        if b == 'R': return 'R'\n        else: return 'S'\n    if a == 'P':\n        if b == 'S': return 'S'\n        else: return 'P'\n    assert False\n\nn, k = list(map(int, input().split()))\ns = list(input())\nfor _ in range(k):\n    t = s * 2\n    for i in range(n):\n        s[i] = win(t[i * 2], t[i * 2 + 1])\nprint((s[0]))\n", "def main():\n    import sys\n    import time\n    input = sys.stdin.readline\n    N, K = [int(x) for x in input().strip().split()]\n    S = list(input().strip())\n    janken = {\n        ('R', 'R'): 'R',\n        ('R', 'S'): 'R',\n        ('R', 'P'): 'P',\n        ('S', 'R'): 'R',\n        ('S', 'S'): 'S',\n        ('S', 'P'): 'S',\n        ('P', 'R'): 'P',\n        ('P', 'S'): 'S',\n        ('P', 'P'): 'P',\n    }\n    memo = {}\n    def dp(k, p):\n        if (k, p) in memo:\n            return memo[(k, p)]\n        # time.sleep(.1)\n        # print(k, p)\n        if k == 1:\n            # print('return {}, {} -> {}'.format(S[p%N], S[(p+1)%N], janken[(S[p%N], S[(p+1)%N])]))\n            return janken[(S[p%N], S[(p+1)%N])]\n        memo[(k, p)] = janken[(dp(k-1, (p*2)%N), dp(k-1, ((p+1)*2)%N))]\n        # return janken[(dp(k-1, p*2), dp(k-1, (p+1)*2))]\n        return memo[(k, p)]\n\n    print((dp(K, 0)))\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "def main():\n    text_len, k = [int(x) for x in input().split()]\n    text = input()\n\n    text *= 2\n    for _ in range(k):\n        new_text = ''\n        for i in range(0, text_len):\n            new_text += janken(text[i * 2], text[i * 2 + 1])\n        text = new_text * 2\n    return text[0]\n\n\ndef janken(a, b):\n    if a == b:\n        return a\n    if 'P' not in (a, b):\n        return 'R'\n    if 'S' not in (a, b):\n        return 'P'\n    if 'R' not in (a, b):\n        return 'S'\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "#0,1,2 = \u30b0\u30fc\u3001\u30d1\u30fc\u3001\u30c1\u30e7\u30ad\ndef janken(h1,h2):\n    handdet = (h2 - h1) %3\n    if handdet == 1:\n        return h2\n    else:\n        return h1\n\ndef jankenOnce(handls):#\u5076\u6570\u3002\u307f\u3093\u306a\u306b\u3058\u3083\u3093\u3051\u3093\u3057\u3066\u3082\u3089\u3046\n    wonhand = []\n    L = len(handls)\n    for pair in range(L//2):\n        wonhand.append(janken(handls[2*pair],handls[2*pair+1]))\n    return wonhand\n\ndef getWinner(handls):#2\u306e\u3079\u304d\u4e57\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\n    if len(handls)%2==1:\n        return handls\n    else:\n        winnersList = jankenOnce(handls)\n        return getWinner(winnersList)\n\nn,k = [int(hoge) for hoge in input().split()]\nS = input()\nhands = []\nfor s in S:\n    if s==\"R\":\n        hands.append(0)\n    elif s==\"P\":\n        hands.append(1)\n    elif s==\"S\":\n        hands.append(2)\n\nif n%2:\n    n*= 2\n    hands = hands + hands\n\nnewhands = hands\nfor i in range(k):\n    newhands = jankenOnce(newhands)\n    newhands += newhands\nJK = [\"R\",\"P\",\"S\"]\nprint(JK[newhands[0]])", "def winner(a, b):\n    battle = {a, b}\n    if battle == {'R', 'S'}:\n        return 'R'\n    elif battle == {'R', 'P'}:\n        return 'P'\n    elif battle == {'P', 'S'}:\n        return 'S'\n    return a\n\nn, k = list(map(int, input().split()))\nS = input()\n\n# dp[2^k\u4eba\u306e\u30c8\u30fc\u30ca\u30e1\u30f3\u30c8][\u5de6\u7aef\u304cS\u306ei\u756a\u76ee\u304b\u3089\u59cb\u307e\u308b\u30d1\u30bf\u30fc\u30f3] = \u52dd\u8005\u306e\u5f97\u610f\u306a\u624b\ndp = [['']*n for _ in range(k+1)]\nfor i in range(n):\n    dp[0][i] = S[i]\n\ndef solve(k, i):\n    if dp[k][i] == '':\n        dp[k][i] = winner(solve(k-1, i), solve(k-1, (i+2**(k-1))%n))\n    return dp[k][i]\n\nprint(solve(k, 0))", "def junken(c_left, c_right):\n    if c_left == 'R':\n        if c_right == 'R':\n            return 'R'\n        elif c_right == 'P':\n            return 'P'\n        else:\n            return 'R'\n    elif c_left == 'P':\n        if c_right == 'R':\n            return 'P'\n        elif c_right == 'P':\n            return 'P'\n        else:\n            return 'S'\n    else:\n        if c_right == 'R':\n            return 'R'\n        elif c_right == 'P':\n            return 'S'\n        else:\n            return 'S'\n\n\ndef main(n, k, s):\n    prev_s = s\n    new_s = []\n    for _ in range(0, k):\n        t = prev_s + prev_s\n        for i in range(0, n):\n            new_s.append(junken(t[i * 2], t[i * 2 + 1]))\n        prev_s = new_s\n        new_s = []\n    print((prev_s[0]))\n\n\ndef __starting_point():\n    n, k = [int(x) for x in input().split()]\n    s = input()\n    main(n, k, s)\n\n__starting_point()", "n, k = map(int, input().split())\nS = input()\nL = [\"RPS\".find(s) for s in S]\ndef winner(a, b):\n  if (b-a)%3 == 1:\n    return b\n  return a\nfor _ in range(k):\n  if len(L)%2:\n    L += L\n  L = [winner(L[2*i], L[2*i+1]) for i in range(len(L)//2)]\nprint(\"RPS\"[L[0]])", "from copy import copy\nn,k=map(int,input().split())\ns=list(input())\nif n%2!=0:\n  s.extend(s)\nfor i in range(k):\n  t=[0]*(len(s)//2)\n  for i in range(len(s)//2):\n    if s[i*2]==s[i*2+1]:\n      t[i]=s[i*2]\n    elif s[i*2]==\"R\" and s[i*2+1]==\"P\" or s[i*2]==\"P\" and s[i*2+1]==\"S\" or s[i*2]==\"S\" and s[i*2+1]==\"R\" :\n      t[i]=s[i*2+1]\n    else:\n      t[i]=s[i*2]\n  if len(t)%2!=0:\n    t.extend(t)\n  s=copy(t)\nprint(t[0])", "n, k = map(int, input().split())\ns = input()\npower = [1]\nfor i in range(k):\n    power.append(power[-1] * 2 % n)\ndp = list(s)\nfor j in range(k):\n    ndp = [None] * n\n    for i in range(n):\n        a = dp[i]\n        b = dp[(i + power[j]) % n]\n        if a == 'R':\n            ndp[i] = a if b == 'S' else b\n        elif a == 'P':\n            ndp[i] = a if b == 'R' else b\n        else:\n            ndp[i] = a if b == 'P' else b\n    dp = ndp\nprint(dp[0])", "win = {'R':'P', 'P':'S', 'S':'R'} # [lose]=win\nn, k = list(map(int, input().split()))\ndp = [[c for c in input()]]\nfor i in range(k):\n    dp.append([*dp[i]])\n    for j in range(n):\n        a = dp[i][(j*2)%n]; b = dp[i][(j*2+1)%n]\n        dp[i+1][j] = b if win[a]==b else a\nprint((dp[k][0]))\n", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n\n\ndef main():\n\n\n\n\n    n, k =list(map(int, input().split()))\n    s = input()\n    dp = [[\"\"  for _ in range(105)] for _ in range(105)]\n\n    for i in range(n): dp[0][i] = s[i]\n\n    for i in range(1, k+1):\n        for j in range(n):\n            a = dp[i-1][j]\n            b = dp[i-1][(j+pow(2, i-1))%n]\n            st = {a, b}\n            rec = \"\"\n            if   st==set(\"RS\"): rec = \"R\"\n            elif st==set(\"SP\"): rec = \"S\"\n            elif st==set(\"PR\"): rec = \"P\"\n            else:                  rec = a\n            dp[i][j] = rec\n\n    ans = dp[k][0]\n    print(ans)\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = map(int,input().split())\ns = [i for i in input()]\n\ndef jk(a,b):\n\tif a == 'R':\n\t\tif b == 'P':\n\t\t\treturn b\n\t\telse:\n\t\t\treturn a\n\telif a == 'P':\n\t\tif b == 'S':\n\t\t\treturn b\n\t\telse:\n\t\t\treturn a\n\telse:\n\t\tif b == 'R':\n\t\t\treturn b\n\t\telse:\n\t\t\treturn a\n\nwhile k:\n\tt = s + s;\n\tfor i in range(n):\n\t\ts[i] = jk(t[i * 2],t[i * 2 + 1])\n\tk -= 1\nprint(s[0])", "N,K = map(int,input().split())\nS = list(input())\nhand = [\"R\",\"P\",\"S\"]\nfor i in range(N):\n    S[i] = hand.index(S[i])\n\ndef judge(A,B):\n    A,B = min(A,B),max(A,B)\n    if A == 0 and B == 2:\n        return A\n    else:\n        return B\n\ncnt = K\n\nwhile cnt:\n    S += S\n    T = []\n    for i in range(0,min(len(S),2**min(9,cnt)),2):\n        T.append(judge(S[i],S[i+1]))\n    S = T\n    cnt -= 1\nprint(hand[S[0]])"]
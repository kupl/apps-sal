["a,b,x,y = map(int, input().split())\ny=min(y,2*x)\n\nif a==b or a==b+1:\n    print(x)\n    return\n\nans=x+abs(a-b)*y\nif a>b:\n    ans-=y\nprint(ans)", "import heapq\na,b,x,y = map(int,input().split())\nG = {}\nfor i in range(1,101):\n    G[(0,i)]=[]\n    if i-1>=1:\n        G[(0,i)].append((0,i-1,y))\n        G[(0,i)].append((1,i-1,x))\n    if i+1<=100:\n        G[(0,i)].append((0,i+1,y))\n    G[(0,i)].append((1,i,x))\n    G[(1,i)]=[]\n    if i-1>=1:\n        G[(1,i)].append((1,i-1,y))\n    if i+1<=100:\n        G[(1,i)].append((1,i+1,y))\n        G[(1,i)].append((0,i+1,x))\n    G[(1,i)].append((0,i,x))\ndist = {}\nINFTY = 30000\nfor i in range(1,101):\n    dist[(0,i)]=INFTY\n    dist[(1,i)]=INFTY\nhist = {}\nfor i in range(1,101):\n    hist[(0,i)]=0\n    hist[(1,i)]=0\nheap = [(0,(0,a))]\ndist[(0,a)]=0\nhist[(0,a)]=1\nwhile heap:\n    d,x = heapq.heappop(heap)\n    if dist[x]<d:continue\n    hist[x]=1\n    for i,j,dy in G[x]:\n        y = (i,j)\n        if hist[y]==0 and dist[y]>d+dy:\n            dist[y]=d+dy\n            heapq.heappush(heap,(d+dy,y))\nprint(dist[(1,b)])", "a, b, x, y = list(map(int, input().split()))\nprint((abs((b - a) * 2 + 1) // 2 * min(x * 2, y) + x))\n", "a, b, x, y = list(map(int, input().split()))\ndiff = a - b\nif diff == 0:\n    print(x)\nelif diff > 0:\n    print((min(x + (abs(diff) - 1) * y, (abs(diff) * 2 - 1) * x)))\nelse:\n    print((min(x + (abs(diff)) * y, (abs(diff) * 2 + 1) * x)))\n# 4 -> 1\n# 4a -> 3b -> 3a -> 2b -> 2a -> 1b\n# 4a -> 3b -> 2b -> 1b\n# 1 -> 4\n# 1a -> 1b -> 2a -> 2b -> 3a -> 3b -> 4a -> 4b\n# 1a -> 1b -> 2b -> 3b -> 4b\n", "import heapq\na,b,x,y=list(map(int,input().split()))\ndist=[10**30 for i in range(200)]\nG=[[] for i in range(200)]\na-=1;b-=1;b+=100\nfor i in range(99):\n    G[i].append((i+1,y))\n    G[i+1].append((i,y))\n    G[i+100].append((i+1+100,y))\n    G[i+1+100].append((i+100,y))\nfor i in range(100):\n    G[i].append((i+100,x))\n    G[i+100].append((i,x))\nfor i in range(99):\n    G[i+1].append((i+100,x))\n    G[i+100].append((i+1,x))\ndist[a]=0\nq=[]\nheapq.heappush(q,(0,a))\nwhile(q):\n    d,r=heapq.heappop(q)\n    if dist[r]<d:\n        continue\n    for p,cost in G[r]:\n        if dist[p]>dist[r]+cost:\n            dist[p]=dist[r]+cost\n            heapq.heappush(q,(dist[p],p))\nprint((dist[b]))\n", "a,b,x,y = map(int,input().split())\nprint(x+min(2*x,y)*(abs(a-b)-(a>b)))", "a,b,x,y = map(int, input().split())\na,b = a-1, b-1\ng = [[] for _ in range(200)]\nfor i in range(100):\n    g[i].append((x, 100+i))\n    g[100+i].append((x, i))\nfor i in range(99):\n    g[i+1].append((x, 100+i))\n    g[100+i].append((x, i+1))\nfor i in range(99):\n    g[i].append((y, i+1))\n    g[i+1].append((y, i))\nfor i in range(99):\n    g[i+100].append((y, i+1+100))\n    g[i+1+100].append((y, i+100))\n\nimport heapq\nINF = 10**18\ndef dijkstra_heap(s, edge):\n    n = len(edge)\n    d = [INF] * n\n    used = [True] * n #True: not used\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for e in edge[s]:\n        heapq.heappush(edgelist,e)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if not used[minedge[1]]:\n            continue\n        v = minedge[1]\n        d[v] = minedge[0]\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v],e[1]))\n    return d\n\nd = dijkstra_heap(a, g)\nprint(d[b+100])", "import math\na, b, x, y = list(map(int, input().split()))\n\nw = abs((2 * b) + 1 - (2 * a))\nprint((math.floor(w/2) * min(2 * x, y) + x))\n\n", "a,b,x,y = map(int,input().split())\nd = abs(2*b+1-2*a)\nYd = min([2*x,y])\nprint(d//2*Yd+x)", "a, b, x, y = map(int, input().split())\n\ndif = a-b\nelv = min(2*x, y)\n\nif dif > 0:\n    ans = (dif-1)*elv + x\nelse:\n    ans = -dif*elv + x\n\nprint(ans)", "a, b, x, y = map(int, input().split())\ny = min(y, 2*x)\nif a == b:\n    print(x)\nelif a > b:\n    print(y*(a-b-1)+x)\nelif a < b:\n    print(y*(b-a)+x)", "a,b,x,y=list(map(int, input().split()))\nif a>b:\n    print((x+abs(a-b-1)*min(2*x,y)))\nelif a<b:\n    print((x+abs(a-b)*min(2*x,y)))\nelif a==b:\n    print(x)\n", "a,b,x,y = map(int, input().split())\ny = min(y, 2*x)\nd = abs(2*b + 1 - 2*a)\nans = y * (d//2) + x\nprint(ans)", "a,b,x,y = map(int, input().split())\na,b = a-1, b-1\ng = [[] for _ in range(200)]\nfor i in range(100):\n    g[i].append((x, 100+i))\n    g[100+i].append((x, i))\nfor i in range(99):\n    g[i+1].append((x, 100+i))\n    g[100+i].append((x, i+1))\nfor i in range(99):\n    g[i].append((y, i+1))\n    g[i+1].append((y, i))\nfor i in range(99):\n    g[i+100].append((y, i+1+100))\n    g[i+1+100].append((y, i+100))\n\nimport heapq\nINF = 10**18\ndef dijkstra_heap(s, edge):\n    n = len(edge)\n    d = [INF] * n\n    used = [True] * n #True: not used\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for e in edge[s]:\n        heapq.heappush(edgelist,e)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if not used[minedge[1]]:\n            continue\n        v = minedge[1]\n        d[v] = minedge[0]\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v],e[1]))\n    return d\n\nd = dijkstra_heap(a, g)\nprint(d[b+100])", "from sys import stdin\npin=stdin.readline\nfrom heapq import heapify,heappop,heappush\nINF=1000000000000000000\nV=0\nG=[[] for _ in [0]*100000]\nd=[INF]*100000\n\ndef dijkstra(s):\n  que=[]\n  heapify(que)\n  d[s]=0\n  heappush(que,[0,s])\n  while que:\n    p=heappop(que)\n    v=p[1]\n    if d[v]<p[0]:\n      continue\n    for i in range(len(G[v])):\n      e=G[v][i]\n      if d[e[0]]>d[v]+e[1]:\n        d[e[0]]=d[v]+e[1]\n        heappush(que,[d[e[0]],e[0]])\n  return\n\ndef main():\n  a,b,x,y=map(int,pin().split())\n  V=200\n  a-=1\n  b-=1\n  for i in range(100):\n    G[i].append([i+100,x])\n    G[i+100].append([i,x])\n  for i in range(99):\n    G[i+1].append([i+100,x])\n    G[i+100].append([i+1,x])\n  for i in range(99):\n    G[i+1].append([i,y])\n    G[i].append([i+1,y])\n    G[i+101].append([i+100,y])\n    G[i+100].append([i+101,y])\n  dijkstra(a)\n  print(d[b+100])\n  return\n\nmain()", "a,b,x,y=list(map(int,input().split()))\nif a==b:\n    print(x)\nelif b>a:\n    print((min(x+(b-a)*y,(x+(b-a)*2*x))))\nelse:\n    print((min((a-b-1)*y+x,((a-b)*2-1)*x)))\n", "a, b, x_yoko, y_tate = list(map(int, input().split()))\n\nif (a == b):\n    ans = x_yoko\nelif (a > b):\n    up = (a - b) * 2 * x_yoko - x_yoko\n    cross = (a - b-1) * y_tate + x_yoko\n    ans = min(up, cross)\nelse:\n    up = (b - a) * y_tate + x_yoko\n    cross = (b - a) * 2 * x_yoko + x_yoko\n    ans = min(up, cross)\n\nprint(ans)\n", "def LI():\n    return list(map(int, input().split()))\n\n\na, b, x, y = LI()\nans = abs(a-b)*y+x\nif a > b:\n    ans -= y\nif a == b or a == b+1:\n    rouka = x\nelif a < b:\n    rouka = x\n    rouka += (b-a)*x*2\nelse:\n    a -= 1\n    rouka = x\n    rouka += (a-b)*x*2\nans = min(ans, rouka)\nprint(ans)\n", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n\n\ndef main():\n\n    \n    a, b, x, y = list(map(int, input().split()))\n    ans = abs(2*b+1-2*a)//2*min(2*x, y) + x\n\n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a, b, x, y = map(int, input().split())\nif b - a > 0:\n    d = b - a\n    print(min(x+d*y, d*2*x+x))\nelif b - a < 0:\n    d = a - b\n    print(min((d-1)*y+x, d*2*x-x))\nelse:\n    print(x)", "s = list(map(int,input().split()))\na = s[0]\nb = s[1]\nx = s[2]\ny = s[3]\n\nif a == b:\n    print(x)\nelif a < b:\n    print(min(x+(b-a)*y,((b-a)*2+1)*x))\nelse:\n    print(min(((a-b)*2-1)*x,x+(a-b-1)*y))", "a, b, x, y = map(int, input().split())\n \nans = x + abs(b - a)*y\nans = min(ans, abs(b - a)*x + abs(b - a + 1)*x)\n \nif a > b:\n    ans = min(ans, x + abs(a - b - 1)*y)\n    ans = min(ans, abs(a - b)*x*2)\n \nprint(ans)", "a,b,x,y = list(map(int,input().split()))\n\nif a== b:\n    print(x)\nelif a<b:\n    ans = min(y,2*x)*(b-a)+x\n    print(ans)\nelse:\n    ans = min(y,2*x)*(a-b-1)+x\n    print(ans)\n\n    \n", "a, b, x, y = map(int, input().split())\nS = min(2*x, y)\nif a < b:\n    print((b-a)*S+x)\nelif a == b:\n    print(x)\nelse:\n    print((a-b-1)*S+x)", "# \u968e\u6bb5\u306e\u4f7f\u7528\u56de\u6570\u3067\u5168\u63a2\u7d22\u3057\u3066\u307f\u308b\na, b, x, y = list(map(int, input().split()))\nif a == b:\n    print(x)\n    return\nans = 10 ** 10\ndif = abs(a - b)\nfor step in range(dif + 1):\n    if a < b:\n        hollway = 2 * (dif - step) + 1  # \u5eca\u4e0b\u3092\u4f7f\u3046\u56de\u6570\n    else:\n        hollway = max(2 * (dif - step) - 1, 0)  # dif==step\u306e\u3068\u304d0\u672a\u6e80\u306b\u306a\u3063\u3061\u3083\u3046\n    ans = min(ans, x * hollway + y * step)\nprint(ans)\n\n", "def resolve():\n#====input code===\n    a,b,x,y = map(int, input().split())\n    if b>=a:\n        print((b-a)*min(2*x,y)+x)\n    else:\n        print((a-b-1)*min(2*x,y)+x)\n#================\nresolve()", "import collections\nimport heapq\n\n\nclass Dijkstra:\n    def __init__(self):\n        self.e = collections.defaultdict(list)\n\n    def add(self, u, v, d):\n        self.e[u].append([v, d])\n        self.e[v].append([u, d])\n\n    def delete(self, u, v):\n        self.e[u] = [_ for _ in self.e[u] if _[0] != v]\n        self.e[v] = [_ for _ in self.e[v] if _[0] != u]\n\n    def search(self, s):\n        \"\"\"\n        :param s: \u59cb\u70b9\n        :return: \u59cb\u70b9\u304b\u3089\u5404\u70b9\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\n        \"\"\"\n        d = collections.defaultdict(lambda: float('inf'))\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for uv, ud in self.e[u]:\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n\n        return d\n\nA,B,X,Y = map(int, input().split())\ngraph = Dijkstra()\nfor i in range(1,101):\n    graph.add(i,100+i,X)\nfor i in range(1,100):\n    graph.add(i+1,100+i,X)\nfor i in range(1,100):\n    graph.add(i,i+1,Y)\n    graph.add(100+i,100+i+1,Y)\nSA = graph.search(A)\nprint(SA[B+100])", "# arc109a\n\na, b, x, y = list(map(int, input().split()))\n\nida = a * 2\nidb = b * 2 + 1\ndiff = abs(ida - idb)\nans = 0\nif 2 * x <= y:\n    ans = diff * x\nelse:\n    ans= x + (diff // 2) * y\n\nprint(ans)", "a, b, x, y = list(map(int, input().split()))\nif a == b:\n    print(x)\nif a < b:\n    dif = b - a\n    print((min(\n        # b\u968e\u307e\u3067\u968e\u6bb5\n        dif * y + x,\n        # \u5168\u90e8\u5eca\u4e0b\n        dif * 2 * x + x)))\nif a > b:\n    dif = a - b\n    print((min(\n        # \u5eca\u4e0b\u3060\u3051\n        (2 * dif - 1) * x,\n        # \u5927\u4f53\u968e\u6bb5\n        (dif-1) * y + x\n    )))\n", "a, b, x, y = map(int, input().split())\nS = min(2*x, y)\nif a < b:\n    print((b-a)*S+x)\nelif a == b:\n    print(x)\nelse:\n    print((a-b-1)*S+x)", "import math\n\na,b,x,y = map(int, input().split())\n\nt = min(2*x,y)\n\nd = abs(2*b+1-2*a)\n\nprint(math.floor(d/2)*t + x)", "a,b,x,y = map(int,input().split())\nif(a==b):\n  print(x)\nelif(a>b):\n  if(2*x>y):\n    print(x+(a-b-1)*y)\n  else:\n    print(2*x*(a-b-1)+x)\nelse:\n  if(2*x>y):\n    print((b-a)*y+x)\n  else:\n    print(2*(b-a)*x+x)", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nips = lambda:input().split()\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nimport sys\nceil = math.ceil\ngcd = math.gcd\nRL = sys.stdin.readline\nINF=10**15\ndef ceilab(a,b):\n    return (a+b-1)//b\na,b,x,y = ma()\nif y>2*x:y=2*x\nif a==b:\n    print(x)\nelif a>b:\n    print((a-b-1)*y+x)\nelse:\n    print((b-a)*y+x)\n", "a,b,x,y=map(int,input().split())\nif a==b:\n    print(x)\nelif a<b:\n    ans1=(b-a)*y+x\n    ans2=(b-a)*x*2+x\n    print(min(ans1,ans2))\nelse:\n    ans1=(a-b-1)*y+x\n    ans2=(a-b-1)*x*2+x\n    #print(ans1,ans2)\n    print(min(ans1,ans2))", "a,b,x,y = list(map(int,input().split()))\nnum = a - b\nif num == 0:\n    print(x)\nelif num < 0:\n    num = abs(num)\n    ans = x\n    if num * y > num * (x * 2):\n        print((ans + (num * (x * 2))))\n    else:\n        print((ans + (num * y)))\nelse:\n    num -= 1\n    ans = x\n    if num == 0:\n        print(ans)\n    else:\n        if num * y > num * (x*2):\n            print((ans + (num * (x*2))))\n        else:\n            print((ans + (num * y)))\n", "#n = int(input())\na, b, x, y = list(map(int, input().split()))\n#al = list(map(int,input().split()))\n#l = [list(map(int,input().split())) for i in range(n)]\n#s=[list(map(int,input().split())) for i in range(n)]\n\nif a == b:\n    ans = x\nelse:\n    dif = abs(a-b)\n    if a < b:\n        ans = x+min(2*x, y)*dif\n    else:\n        ans = x+min(2*x, y)*(dif-1)\nprint(ans)\n", "a, b, x, y = map(int, input().split())\n\nif a < b:\n  print(x + min(2 * x, y) * (b - a))\nelif a == b:\n  print(x)\nelse:\n  print(x + min(2 * x, y) * (a - b - 1))", "a, b, x, y = list(map(int, input().split()))\nz = min(2 * x, y)\nif a <= b:\n    print((x + z * (b - a)))\nelse:\n    print((x + z * (a - b - 1)))\n\n", "a,b,x,y = [int(hoge) for hoge in input().split()]\n#\u968e\u6bb5 y\u5206\n#\u308d\u3046\u304b x\u5206\nstair = min(y,2*x)\nisle = x\nans = 0\nif a>b:\n    #\u304f\u3060\u308a\n    #A\u306eb+1\u968e\u306b\u884c\u304f + x\u5206\n    ans = (a-b-1)*stair + isle\nelse:\n    #\u306e\u307c\u308a\n    #\u771f\u6a2a\u306b\u884c\u3063\u3066\u968e\u6bb5\u3067\u767b\u308b\u3057\u304b\u7121\u3044\n    ans = (b-a)*stair + isle\nprint(ans)", "a,b,x,y = map(int,input().split())\nans = 0\nif a == b:\n  ans = x\nif a > b:\n  ans = min(x+(a-b-1)*y,x*(2*a-2*b-1))\nif a < b:\n  ans = min(x+y*(b-a),x*(2*b-2*a+1))\nprint(ans)", "a, b, x, y = map(int, input().split())\n\nif a > b:\n    tmp = x + (a - b - 1) * y\n    tmp2 = (a - b) * x + (a - b - 1) * x\n    print(min(tmp, tmp2))\nelif a == b:\n    print(x)\nelse:\n    tmp = x + (b - a) * y\n    tmp2 = (b - a) * x + (b - a + 1) * x\n    print(min(tmp, tmp2))", "a,b,x,y = list(map(int,input().split()))\nnow=a\n\nif b<a:\n  print((min((a-b-1)*y+x,x*(a-b-1)+x*(a-b))))\nelif b==a:\n  print(x)\nelse:\n  print((min(x+y*(b-a),2*x*(b-a)+x)))\n", "a, b, x, y = map(int, input().split())\na, b = a-1, b-1\nm = up = min(2*x, y)\nif a <= b:\n    print(x + m*(b-a))\nelse:\n    print(x + m*(a-b-1))", "a,b,x,y=map(int,input().split())\nif b > a:\n  print((b-a)*min(2*x,y)+x)\nelif b < a:\n  print((a-b-1)*min(2*x,y)+x)\nelse:\n  print(x)", "def solve(a, b, x, y):\n    if b < a:\n        return x + (a-b-1)*min(2*x, y)\n    else:\n        return x + (b-a)*min(2*x, y)\n\na, b, x, y = list(map(int, input().split()))\nprint((solve(a, b, x, y)))\n", "def __starting_point():\n\n    a,b,x,y = list(map(int,input().split()))\n\n    ans = 0\n\n    #\u968e\u306e\u5dee\u5206\n    ud_sbn = abs(a-b)\n    #\u4e0a\u308b\u304b\u4e0b\u308b\u304b\n    up = False\n    if a-b<0:\n        up=True\n\n    #\u540c\u3058\u968e\u306a\u3089\u3070\n    if ud_sbn == 0:\n        ans = x\n    else:\n        if up:\n            u1 = ((ud_sbn+1)*2-1)*x\n            u2 = x+(ud_sbn)*y\n            ans = min(u1,u2)\n        else:\n            d1 = (ud_sbn*2-1)*x\n            d2 = x+(ud_sbn-1)*y\n            ans = min(d1,d2)\n    print(ans)\n\n\n__starting_point()", "\n\nfrom functools import reduce\nfrom operator import mul\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import accumulate\nfrom queue import Queue\nfrom queue import PriorityQueue as pq\nfrom heapq import heapreplace\nfrom heapq import heapify\nfrom heapq import heappushpop\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nimport time\nimport random\nimport bisect\nimport itertools\nimport collections\nfrom fractions import Fraction\nimport fractions\nimport string\nimport math\nimport operator\nimport functools\nimport copy\nimport array\nimport re\nimport sys\nsys.setrecursionlimit(500000)\n\n\ninput = sys.stdin.readline\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n    return\n\n\ndef warizan(a, b):\n    return a // b, a % b\n\n\n# from fractions import gcd\n# from math import gcd\n\n# def lcm(n, m):\n#     return int(n * m / gcd(n, m))\n\n\n# def coprimize(p, q):\n#     common = gcd(p, q)\n#     return (p // common, q // common)\n\n\n# def find_gcd(list_l):\n#     x = reduce(gcd, list_l)\n#     return x\n\n\ndef combinations_count(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, list(range(n, n - r, -1)), 1)\n    denom = reduce(mul, list(range(1, r + 1)), 1)\n    return numer // denom\n\n\nmod = 1000000007\n\n\ndef combinations_count_mod(n, r):\n    r = min(r, n - r)\n    numer = reduce(lambda x, y: x * y % mod, list(range(n, n - r, -1)), 1)\n    denom = pow(reduce(lambda x, y: x * y % mod, list(range(1, r + 1)), 1), mod - 2, mod)\n    return numer * denom % mod\n\n\n# def solve():\n\n\na, b, x, y = list(map(int, input().strip().split()))\nh = abs(a - b)\nif a < b:\n    temp1 = y * (h) + x\n    temp2 = 2 * x * h + x\n    eprint('temp1,temp2 ', end=':\\n')\n    eprint(temp1, temp2)\n    print(min(temp1, temp2))\nelif a == b:\n    print(x)\nelse:\n    temp1 = (h - 1) * y + x\n    temp2 = 2 * x * (h - 1) + x\n    eprint('temp1,temp2 ', end=':\\n')\n    eprint(temp1, temp2)\n    print(min(temp1, temp2))\n", "a,b,x,y=list(map(int,input().split()))\nvertical=min(2*x,y)\nd=abs(a-b)\nif a>b:\n  ans=(d-1)*vertical+x\nelse:\n  ans=d*vertical+x\nprint(ans)\n", "# import sys\n# input = sys.stdin.readline\nimport math\nimport copy\nimport bisect\nfrom itertools import accumulate\nfrom collections import Counter, defaultdict, deque\ndef mp():return map(int,input().split())\ndef lmp():return list(map(int,input().split()))\ndef ceil(U,V):return (U+V-1)//V\ndef modf1(N,MOD):return (N-1)%MOD+1\n\na,b,x,y = mp()\nu = x*2\nif a == b:\n    print(x)\nelif a > b:\n    sa = a-b-1\n    print(min(sa*u+x, sa*y+x))\nelse:\n    sa = b-a\n    print(min(x+sa*y, sa*u+x))", "from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\ndef solve():\n\n    a,b,x,y = map(int,input().split())\n    d = abs(a - b)\n    if d == 0:\n        print(x)\n        return\n\n    elif a < b:\n        print(d * y + x if y <= 2 * x else d * 2*x + x)\n        return\n    else:\n        print((d-1) * y + x if y <= 2 * x else d * x * 2 - x)\n\ndef __starting_point():\n    solve()\n__starting_point()", "a,b,x,y = [int(i) for i in input().split()]\n\nif a==b:\n    print(x)\nelif a < b:\n    if 2*x > y:\n        print(((b-a)*y + x))\n    else:\n        print((2*(b-a)*x + x))\nelse:\n    if 2*x > y:\n        print(((a-b-1)*y + x))\n    else:\n        print((2*(a-b)*x - x))\n", "a,b,x,y=map(int,input().split())\nif a>b:\n  print(min(x+(a-b-1)*y,(2*(a-b)-1)*x))\nelse:\n  print(min(x+(b-a)*y,(2*(b-a)+1)*x))", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\na, b, x, y = mapint()\n\nif a>b:\n    n = a-b\n    print(min((n-1)*y+x, (x*2)*n-x))\nelse:\n    n = b-a\n    print(min(n*y+x, (x*2)*n+x))", "a, b, x, y = map(int, input().split())\n\nif a > b:\n    ans = min(((a - b)*2 - 1)*x, (a - b - 1)*y + x)\nelif a == b:\n    ans = x\nelse:\n    ans = min(((b - a)*2 + 1)*x, (b - a)*y + x)\n\nprint(ans)", "import sys\nfrom functools import reduce\n\nzz=1\n \nsys.setrecursionlimit(10**5)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef ii():\n\treturn input().rstrip()\t\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tlist(map(int,input().split()))\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\nuu=t\n\n\nwhile t>0:\n\tt-=1\n\ta,b,x,y=mi()\n\ty=min(y,2*x)\n\tif a>b:\n\t\tprint(((a-b-1)*y+x))\n\telse:\n\t\tprint(((b-a)*y+x))\t\n\n", "a, b, x, y = map(int, input().split())\nS = min(2*x, y)\nif a < b:\n    print((b-a)*S+x)\nelif a == b:\n    print(x)\nelse:\n    print((a-b-1)*S+x)", "\n#\u6a19\u6e96\u5165\u529b\ns = list(map(int, input().split()))\n\na = int(s[0])\nb = int(s[1])\nx = int(s[2])\ny = int(s[3])\n\nmove_withoutstep_1 = 9999999999\nmove_withoutstep_2 = 9999999999\n\n#\u968e\u6bb5\u79fb\u52d5\u3092\u4f7f\u308f\u306a\u3044\u5834\u5408\u306e\u79fb\u52d5\u6642\u9593\n# a > b\u306e\u6642\nif a > b:\n    move_withoutstep_1 = ((a-b)-1)*x + (a-b)*x\n#a < b\u306e\u6642\nelif a <= b:\n    move_withoutstep_2 = ((b-a)+1)*x + (b-a)*x\n\n\n#\u968e\u6bb5\u79fb\u52d5\u3092\u4f7f\u3046\u5834\u5408\u306e\u79fb\u52d5\u6642\u9593\nmove_upstairs = 9999999999\nmove_downstairs = 9999999999\n\nif a < b:\n    move_upstairs = (b-a)*y + x\nelif a > b:\n    #\u6700\u5f8c\u306e\u4e0b\u308a\u306f\u306a\u306a\u3081\u79fb\u52d5\uff08\u5eca\u4e0b\u3092\u4f7f\u3063\u305f\u79fb\u52d5\uff09\u306e\u65b9\u304c\u65e9\u3044\u306e\u3067\u3001\u305d\u308c\u3092\u8003\u616e\u3057\u3066\u968e\u6bb5\u79fb\u52d5\u306e\u56de\u6570\u30921\u56de\u5206\u6e1b\u3089\u3059\u3002\n    #x+y\u3088\u308a\u3082x\u306e\u65b9\u304c\u5c0f\u3055\u3044\u306e\u306f\u6761\u4ef6\u3088\u308a\u81ea\u660e\u3002\n    move_downstairs = (a-b-1)*y + x\n\n#print(move_withoutstep_1,move_withoutstep_2,move_upstairs,move_downstairs,move_downstairs_2)\nprint((min(move_withoutstep_1,move_withoutstep_2,move_upstairs,move_downstairs)))\n", "a,b,x,y = map(int,input().split())\n\nans = 0\n\nif a > b:\n    if 2*x > y:\n        ans = (a-b-1)*y+x\n    else:\n        ans = (a-b)*x*2-x\nelse:\n    if 2*x > y:\n        ans = (b-a)*y+x\n    else:\n        ans = (b-a)*x*2+x\nprint(ans)", "#ARC109 A\n\na, b, x, y = list(map(int,input().split()))\n\nans,c,d = 0,0,0\n\nif a == b:\n    ans = x\nelif a > b:\n    c = x+(a-b-1)*y\n    d = (a-b)*2*x - x\n    ans = min(c,d)\nelse:\n    c = (b-a)*2*x + x\n    d = (b-a)*y + x\n    ans = min(c,d)\n    \nprint(ans)", "#\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5 O(N\u306e3\u4e57)\u3002N <= 300\u304f\u3089\u3044\u3067\u89e3\u3051\u308b\u3002\na,b,x,y = map(int,input().split())\ng = [[10**8 for _ in range(200)] for i in range(200)]\n#g[i][j]=a\u306ei\u968e\u304b\u3089b\u306ej\u968e\u307e\u3067\u306e\u6700\u77ed\u6642\u9593\nfor i in range(200):\n    g[i][i] = 0\n#A_i\u30920-index\u306e(0 \uff5e99 ) B_i\u30920-index\u306e(100\uff5e199)\u3067\u8003\u3048\u308b\nfor i in range(100):\n    g[i][i+100]=x\n    g[i+100][i]=x\nfor i in range(99):\n    g[i+1][i+100] = x\n    g[i+100][i+1] = x\nfor i in range(99):\n    g[i+1][i]=y\n    g[i][i+1]=y\nfor i in range(99):\n    g[i+101][i+100]=y\n    g[i+100][i+101]=y\n#\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\ndef warchall_floyd(n):\n    for i in range(n):\n        #\u7d4c\u7531\u3059\u308b\u9802\u70b9\n        for j in range(n):\n          #\u59cb\u70b9\n            for k in range(n):\n            #\u7d42\u70b9\n                g[j][k] = min(g[j][k],g[j][i]+g[i][k])\n\nwarchall_floyd(200)\nprint(g[a-1][100+b-1])", "a, b, x, y=map(int, input().split())\n\nif b>a:\n  route_x=x+2*x*(b-a)\n  route_y=x+y*(b-a)\n\nelif a==b:\n  route_x=x\n  route_y=x+y\n\nelse:\n  route_x=x+2*x*(a-b-1)\n  route_y=x+y*(a-b-1)\n\nanswer=min(route_x, route_y)\nprint(answer)", "a, b, x, y = list(map(int, input().split()))\nif a == b:\n    ans = x\nelif a < b:\n    ans = x + (b - a) * min(x * 2, y)\nelse:\n    ans = x + (a - b - 1) * min(x * 2, y)\n\nprint(ans)\n", "a,b,c,d = map(int,input().split())\n\n\nif a == b:\n    print(c)\n    return\n\nif a < b:\n    print(min(c+d*(b-a), c+2*c*(b-a)))\nelse:\n    print(min(c+d*(a-b-1), c+2*c*(a-b-1)))", "a, b, x, y = list(map(int, input().split()))\nif a == b:\n    print(x)\nelse:\n    res = 100000000000000000\n    # sloap\n    if a != 1:\n        aa = a - 1\n        tmp = x\n        tmp += y * (aa-b)\n        res = min(res, tmp)\n    # ro-ka\n    tmp = x\n    tmp += y * abs(a - b)\n    res = min(res, tmp)\n\n    if a == b:\n        res = min(x, res)\n    elif a > b:\n        res = min(res, x * (abs(a - b) * 2 - 1))\n    elif a < b:\n        res = min(res, x * (abs(a-b) * 2 + 1) )\n\n    print(res)\n\n", "a,b,x,y = map(int,input().split())\nif b>a:\n    ans = x + (b-a)*min(2*x,y)\nelif b<a:\n    ans = x + (a-b-1)*min(2*x,y)\nelse:\n    ans = x \nprint(ans)", "a,b,x,y=map(int,input().split())\nif a==b:print(x)\nif a>b:print(min(x+(a-b-1)*y,x+(a-b-1)*2*x))\nif a<b:print(min(x+(b-a)*y,(2*(b-a)+1)*x))", "a, b, x, y = map(int, input().split())\nv = min(y, 2 * x)\n\nif a == b:\n    print(x)\n    return\n\nv = min(2 * x, y)\nif a > b:\n    ans = v * (a - b - 1) + x\nelse:\n    ans = v * (b - a) + x\nprint(ans)", "a,b,x,y = list(map(int,input().split()))\nif a == b:\n  print(x)\n  return\n\nif a > b:\n  h = a-b\n  if y*(h-1) >= 2*x*(h-1):\n    print((2*x*(h-1) + x))\n    return\n  else:\n    print((y*(h-1) + x))\n    return\nelse:\n  h = b-a\n  if y >= 2*x:\n    print((2*x*h+x))\n    return\n  else:\n    print((y*h+x))\n    return\n\n\n", "import math\nfrom functools import reduce\n\n\ndef readGenerator():\n    while True:\n        tokens = input().split(' ')\n        for t in tokens:\n            yield t\n\n\nreader = readGenerator()\n\n\ndef readWord():\n    return next(reader)\n\n\ndef readInt():\n    return int(next(reader))\n\n\ndef readFloat():\n    return float(next(reader))\n\n\ndef readLine():\n    return input()\n\n\ndef fib(n, f1, f2, i):\n    if n <= f1:\n        return i\n    return fib(n, f2, f1 + f2, i + 1)\n\n\ndef bin(a, num):\n    left = 0\n    right = len(a) - 1\n    while (right - left) > 1:\n        mid = (right + left) // 2\n        if a[mid] < num:\n            left = mid\n        else:\n            right = mid\n\n    return a[left] == num or a[right] == num\n\n\ndef lcm(x, y):\n    tmp = x\n    while (tmp % y) != 0:\n        tmp += x\n    return tmp\n\n\ndef createGraph(x, y):\n    g = []\n    for i in range(200):\n        g.append([])\n\n    for i in range(100):\n        g[i].append((i + 100, y))\n        g[i + 100].append((i, y))\n        if i > 0:\n            g[i].append((i - 1, x))\n            g[100 + i].append((i + 99, x))\n            g[i].append((i + 99, y))\n            g[99 + i].append((i, y))\n        if i < 99:\n            g[i].append((i + 1, x))\n            g[100 + i].append((i + 101, x))\n\n    return g\n\n\ndef solve(a, b, y, x):\n    g = createGraph(x, y)\n\n    d = [10 ** 10] * 200\n    d[a] = 0\n\n    v = [False] * 200\n\n    for _ in range(200):\n        vi = -1\n        mn = 10 ** 10\n        for j in range(200):\n            if d[j] < mn and not v[j]:\n                vi = j\n                mn = d[j]\n\n        for (dest, t) in g[vi]:\n            d[dest] = min(d[dest], d[vi] + t)\n\n        v[vi] = True\n\n    return d[b]\n\n\n#t = readInt()\n#for _ in range(t):\na, b, x, y = [readInt() for _ in range(4)]\nprint((solve(a - 1, b + 99, x, y)))\n", "import sys\nimport math\nimport re\nimport random\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter,defaultdict\nfrom decimal import Decimal\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nINF = 10**9\n\na,b,x,y = map(int,input().split())\nnum = abs(a-b)\nif a > b:\n    print(min(x*(num*2-1),x+y*(num-1)))\nelif a == b:\n    print(x)\nelse:\n    print(min(x*(num*2+1),x+y*num))", "import sys\n\n# A - Hands\na, b, x, y = map(int, input().split())\nans = 0\n\nif a == b:\n  ans = x\nelif a < b:\n  move1 = (b-a) * x * 2 + x\n  move2 = (b-a)*y + x\n\n  ans = min(move1, move2)\nelse:\n  move1 = (a-b)*x*2 - x\n  move2 = (a-b)*y + x\n\n  ans = min(move1, move2)\n\n  move3 = (a-b-1)*y + x\n  ans = min(ans, move3)\n\nprint(ans)", "#!/usr/bin/env python\n#-*- coding: utf-8 -*-\n\ndef __starting_point():\n    a, b, x, y = list(map(int, input().split()))\n    y = min(y, 2*x)\n    print((x+min(abs(a-b), abs(a-1-b))*y))\n\n__starting_point()", "a,b,x,y=map(int,input().split())\nif a<=b:\n  print(min(x+y*(b-a),x*((b-a)*2+1)))\nelse:\n  print(min(x+y*(a-b-1),x*((a-b)*2-1)))", "a,b,x,y = map(int,input().split())\nhoge = max(b-a,a-b-1)\nprint(min(hoge*x*2,hoge*y)+x)", "import math\nimport numpy as np\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    a, b, x, y = list(map(int,input().split()))\n    if(b>a):\n        d = b-a\n        t1=y*d+x\n        t2=2*x*d+x\n        print(min(t1, t2))\n    elif(a==b):print(x)\n    else:\n        d=a-b\n        t1=y*(d-1)+x\n        t2=2*x*(d-1)+x\n        print(min(t1, t2))\n\nmain()", "a,b,x,y=map(int,input().split())\nif a==b:\n    ans=x\nelif a<b:\n    ans=min(x+(b-a)*y,x*((b-a)*2+1))\nelse:\n    ans=x+min((a-b-1)*y,2*(a-b-1)*x)\nprint(ans)", "a, b, x, y = list(map(int, input().split()))\n\n#using staircase:\nif b < a:\n    d1 = abs(b+1 - a)*y + x\n    d2 = (abs(b-a)*2 - 1)*x\nelse:\n    d1 = abs(b - a) * y + x\n    d2 = (abs(b-a)*2 + 1)*x\n#using corridors only\n#a10->b9->a9->b8..\nprint((min(d1, d2)))\n", "a,b,x,y=map(int,input().split())\nvertical=min(2*x,y)\nd=abs(a-b)\nif a>b:\n  ans=(d-1)*vertical+x\nelse:\n  ans=d*vertical+x\nprint(ans)", "a, b, x, y = list(map(int, input().split()))\nif 2 * x >= y:\n    if a <= b:\n        print((x + y * (b - a)))\n    else:\n        print((x + y * (a - 1 - b)))\nelse:\n    if a <= b:\n        print((x + 2 * x * (b - a)))\n    else:\n        print((x + 2 * x * (a - 1 - b)))\n\n", "a,b,x,y=map(int,input().split())\nif a>b:\n  print((a-b-1)*min(2*x,y)+x)\nelse:\n  print((b-a)*min(2*x,y)+x)", "a,b,x,y=[int(x) for x in input().split()]\nif 2*x>=y:\n    if b>=a:\n        print(x+(b-a)*y)\n    else:\n        print(x+(a-b-1)*y)\nelse:\n    if b>=a:\n        print(2*x*(b-a)+x)\n    else:\n        print(2*x*(a-b-1)+x)", "a,b,x,y = map(int, input().split())\nz = min(x*2, y)\nd = abs(b*2-a*2+1)//2\nprint(d*z + x)", "A, B, X, Y = map(int, input().split())\nx = A*2\ny = B*2+1\nl = abs(y-x)\no = X\nt = min(X*2, Y)\nans = l//2*t + l%2*o\nprint(ans)", "a,b,x,y = map(int,input().split())\nt = 0\nif a > b:\n  c = (a-1) -b\nelse:\n  c = b - a\nt += x\nif x*2 < y:\n  t += c*x*2\nelse:\n  t += c*y\nprint(t)", "a,b,x,y = list(map(int,input().split()))\n\nans = x\nif a==b:\n    print(ans)\nelif a>b:\n    print((ans + (a-1-b)*min(2*x,y)))\nelse:\n    print((ans + (b-a)*min(2*x,y)))\n", "a, b, x, y = list(map(int, input().split()))\nd = abs(2*b+1-2*a)\nprint(((d//2)*min(2*x, y)+x))\n", "a, b, x, y = map(int, input().split())\nans = 0\n\nif a > b:\n    a1 = x + y * (a - b - 1)\n    a2 = x * (2 * (a - b) - 1)\nelse:\n    a1 = x + y * (b - a)\n    a2 = x * (2 * (b - a) + 1)\nans = min(a1, a2)\nprint(ans)", "n=100\na,b,x,y=list(map(int,input().split()))\ndpa=[-1]*(n+1)\ndpb=[-1]*(n+1)\ndpa[a]=0\ndpb[a]=x\n\nfor ii in range(a,n):\n  dpb[ii]=dpa[ii]+x\n  dpa[ii+1]=min(dpa[ii]+y,dpb[ii]+x)\n\ndpb[n]=min(dpa[n]+x,dpb[n-1]+y)\n\nfor ii in range(a,1,-1):\n  dpb[ii-1]=dpa[ii]+x\n  dpa[ii-1]=min(dpa[ii]+y,dpb[ii-1]+x)\n\n#print(dpa)\n#print(dpb)\nprint((dpb[b]))\n", "# A - Hands\n# https://atcoder.jp/contests/arc109/tasks/arc109_a\n\na, b, x, y = list(map(int, input().split()))\n\nif a > b:\n    if y >= 2 * x:\n        ans = abs(a - b - 1) * 2 * x + x\n    else:\n        ans = abs(a - b - 1) * y + x\nelse:\n    if y >= 2 * x:\n        ans = abs(a - b) * 2 * x + x\n    else:\n        ans = abs(a - b) * y + x\n\nprint(ans)\n", "import sys\n\na,b,x,y = map(int, input().split())\n\ndiff = a - b\nif diff == 1 or diff == 0:\n    print(x)\n    return\n\nif diff < 0:\n    diff = -diff\n    p1 = x + y * diff\n    p2 = (2 * diff * x) + x\nelse:\n    p1 = x + y * (diff - 1)\n    p2 = (diff * x) + x * (diff - 1)\n\nprint(min(p1, p2))", "a, b, x, y = map(int, input().split())\n\nif a == b:\n  print(x)\nelif a < b:\n  if (b - a) * y + x < ((b - a) * 2 + 1) * x:\n    print((b - a) * y + x)\n  else:\n    print(((b - a) * 2 + 1) * x)\nelse:\n  if ((a - b) * 2 - 1) * x < (a - b - 1) * y + x:\n    print(((a - b) * 2 - 1) * x)\n  else:\n    print((a - b - 1) * y + x)", "A, B, X, Y = map(int, input().split())\n\nif A == B:\n\tprint(X)\nelif A > B:\n\tif 2*X < Y:\n\t\tprint(2*X*(A-B-1)+X)\n\telse:\n\t\tprint(Y*(A-B-1)+X)\nelse:\n\tif 2*X < Y:\n\t\tprint(2*X*(B-A)+X)\n\telse:\n\t\tprint(Y*(B-A)+X)", "def resolve():\n    #n=int(input())\n    #a,b=map(int,input().split())\n    #x=list(map(int,input().split()))\n    #a=[list(map(lambda x:int(x)%2,input().split())) for _ in range(h)]\n    a,b,x,y=map(int,input().split())\n    if b>=a:\n        print((b-a)*min(2*x,y)+x)\n    else:\n        print((a-b-1)*min(2*x,y)+x)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "a, b, x, y = list(map(int, input().split()))\nif b>a:\n    use_x=x+2*x*(b-a)\n    use_y=x+y*(b-a)\nelif a == b:\n    use_x=x\n    use_y=x+y\nelse:\n    use_x=x+2*x*(a-b-1)\n    use_y=x+y*(a-b-1)\nprint((min(use_x,use_y)))\n", "a,b,x,y=map(int,input().split())\ncnt1=min(abs(a-b-1),abs(a-b))*y+x\ncnt2=min(abs(a-b-1),abs(a-b))*2*x+x\n\nprint(min(cnt1, cnt2))"]
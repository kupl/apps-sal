["\n\n# Python3 program to count inversions using  \n# Binary Indexed Tree  \n  \n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and  \n# partial sums of array elements are stored  \n# in BITree[].  \ndef getSum( BITree, index): \n    sum = 0 # Initialize result  \n      \n    # Traverse ancestors of BITree[index]  \n    while (index > 0):  \n  \n        # Add current element of BITree to sum  \n        sum += BITree[index]  \n  \n        # Move index to parent node in getSum View  \n        index -= index & (-index)  \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree)  \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree.  \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val'  \n    while (index <= n):  \n  \n        # Add 'val' to current node of BI Tree  \n        BITree[index] += val  \n  \n        # Update index to that of parent \n        # in update View  \n        index += index & (-index)  \n  \n# Returns count of inversions of size three  \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], 1)  \n    return invcount  \n\ndef getInvCountAdv(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += (i + 1) * getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], n-i)  \n    return invcount  \n      \n# Driver code  \nn = int(input())\na = list(map(int,input().split())) \nInvCount = getInvCount(a, n)\nInvCountAdv = getInvCountAdv(a,n)\nthirdSum = 0\nfor i in range(1,n+1):\n    thirdSum += i * (i - 1) * (n- i + 1) / 2\nprint(InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1)))\n      \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n", "\n\n# Python3 program to count inversions using  \n# Binary Indexed Tree  \n  \n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and  \n# partial sums of array elements are stored  \n# in BITree[].  \ndef getSum( BITree, index): \n    sum = 0 # Initialize result  \n      \n    # Traverse ancestors of BITree[index]  \n    while (index > 0):  \n  \n        # Add current element of BITree to sum  \n        sum += BITree[index]  \n  \n        # Move index to parent node in getSum View  \n        index -= index & (-index)  \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree)  \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree.  \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val'  \n    while (index <= n):  \n  \n        # Add 'val' to current node of BI Tree  \n        BITree[index] += val  \n  \n        # Update index to that of parent \n        # in update View  \n        index += index & (-index)  \n  \n# Returns count of inversions of size three  \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], 1)  \n    return invcount  \n\ndef getInvCountAdv(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += (i + 1) * getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], n-i)  \n    return invcount  \n      \n# Driver code  \nn = int(input())\na = list(map(int,input().split())) \nInvCount = getInvCount(a, n)\nInvCountAdv = getInvCountAdv(a,n)\nthirdSum = 0\nfor i in range(1,n+1):\n    thirdSum += i * (i - 1) * (n- i + 1) / 2\nprint(InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1)))\n      \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n", "\n\n# Python3 program to count inversions using  \n# Binary Indexed Tree  \n  \n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and  \n# partial sums of array elements are stored  \n# in BITree[].  \ndef getSum( BITree, index): \n    sum = 0 # Initialize result  \n      \n    # Traverse ancestors of BITree[index]  \n    while (index > 0):  \n  \n        # Add current element of BITree to sum  \n        sum += BITree[index]  \n  \n        # Move index to parent node in getSum View  \n        index -= index & (-index)  \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree)  \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree.  \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val'  \n    while (index <= n):  \n  \n        # Add 'val' to current node of BI Tree  \n        BITree[index] += val  \n  \n        # Update index to that of parent \n        # in update View  \n        index += index & (-index)  \n  \n# Returns count of inversions of size three  \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], 1)  \n    return invcount  \n\ndef getInvCountAdv(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += (i + 1) * getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], n-i)  \n    return invcount  \n      \n# Driver code  \nn = int(input())\na = list(map(int,input().split())) \nInvCount = getInvCount(a, n)\nInvCountAdv = getInvCountAdv(a,n)\nthirdSum = 0\nfor i in range(1,n+1):\n    thirdSum += i * (i - 1) * (n- i + 1) / 2\nprint(InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1)))\n      \n# Some part of this code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n"]
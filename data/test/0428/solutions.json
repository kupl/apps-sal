["#Simple non-optimized class of matrices. Used with small dense matrices.\nimport functools\nimport itertools\nimport math\n\nclass NotAMatrixError(Exception):\n    pass\n\nclass MatrixSizeError(Exception):\n    def __init__(self, s1, s2):\n        print('sizes do not match : ', s1, ', ', s2)\n\nclass NotSquareError(Exception):\n    pass\n\nclass Matrix(list):\n    def __init__(self, L):\n        if type(L) == type(self):\n            self = L\n            return\n        n = len(L)\n        m = len(L[0])\n        for i in range(n):\n            if len(L[i]) != m:\n                raise NotAMatrixError()\n        list.__init__(self, L)\n        self.n = n\n        self.m = m\n        self.degrees = []\n    def check_size(self, M, mode):\n        n, m = len(M), len(M[0])\n        for i in range(n):\n            if len(M[i]) != m:\n                raise NotAMatrixError()\n        \n        if mode == 'add' and (self.n != n or self.m != m):\n            raise MatrixSizeError((self.n, self.m), (n,m))\n        if mode == 'lul' and self.m != n:\n            print(self.m, n, self.m != n)\n            raise MatrixSizeError((self.n, self.m), (n,m))\n    def __add__(self, M):\n        self.check_size(M, mode = 'add')\n        return Matrix([[self[i][j]+M[i][j] for j in range(self.m)]for i in range(self.n)])\n    def __iadd__(self, M):\n        self.check_size(M, mode = 'add')\n        for i in range(self.n):\n            for j in range(self,m):\n                self[i][j] += M[i][j]\n    def __mul__(self, M):\n        self.check_size(M, mode = 'mul')\n        l = len(M[0])\n        return Matrix([[sum(self[i][k]*M[k][j] for k in range(self.m))\n                 for j in range(l)] for i in range(self.n)])\n    def issquare(self):\n        return self.n == self.m\n    def primary(self):\n        if self.n != self.m:\n            raise NotSquareError()\n        return Matrix([[int(i==j) for j in range(self.m)] for i in range(self.n)])\n    def __pow__(self, n):\n        if self.n != self.m:\n            raise NotSquareError()\n        if n == 0:\n            return self.primary()\n        elif n == 1:\n            return self\n        if len(self.degrees) == 0:\n            self.degrees.append(self*self)\n        for i in range(n.bit_length() - len(self.degrees) - 1):\n            self.degrees.append(self.degrees[-1] * self.degrees[-1])\n        s = [(n>>i)&1 for i in range(1,n.bit_length())]\n        res = functools.reduce(lambda x,y:x*y, itertools.compress(self.degrees, s))\n        return res*self if n%2 else res \n    def drop_degrees(self):\n        self.degrees.clear()\n\nclass Remainder(int):\n    def __new__(self, n, p):\n        obj = int.__new__(self, n%p)\n        obj.p = p\n        return obj\n    def __mul__(self, m): return Remainder(int.__mul__(self, m), self.p)\n    def __add__(self, m): return Remainder(int.__add__(self, m), self.p)\n    def __sub__(self, m): return Remainder(int.__sub__(self, m), self.p)\n    def __rmul__(self, m): return Remainder(int.__rmul__(self, m), self.p)\n    def __radd__(self, m): return Remainder(int.__radd__(self, m), self.p)\n    def __rsub__(self, m): return Remainder(int.__rsub__(self, m), self.p)\n    def __neg__(self): return Remainder(int.__neg__(self), self.p)\n    def __pow__(self, m): return Remainder(int.__pow__(self, m, self.p), self.p)\n\ndef solve(n, sx, sy, dx, dy, t):\n    o, l, j = Remainder(0, n), Remainder(1, n), Remainder(2, n)\n    N = [[j, l, l, o, l, o],\n         [l, j, o, l, l, o],\n         [l, l, l, o, l, o],\n         [l, l, o, l, l, o],\n         [o, o, o, o, l, l],\n         [o, o, o, o, o, l]]\n    M = Matrix(N)\n    sx, sy, dx, dy = [Remainder(x, n) for x in [sx, sy, dx, dy]]\n    v = Matrix([[sx], [sy], [dx], [dy], [o], [l]])\n    return M ** t * v\n\nn, sx, sy, dx, dy, t = [int(x) for x in input().split()]\nans = solve(n, sx, sy, dx, dy, t)\nprint(int(ans[0][0] - 1) + 1, int(ans[1][0] - 1) + 1)\n", "mod, sx, sy, dx, dy, t = list(map(int, input().split()))\nclass Matrix():\n    def __init__(self, n):\n        self.n = n\n        self.a = [[0] * n for _ in range(n)]\n\n    def __mul__(self, b):\n        res = Matrix(self.n)\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(self.n):\n                    res.a[i][j] += self.a[i][k] * b.a[k][j] % mod\n                    res.a[i][j] %= mod\n        return res\n\n    def __pow__(self, e):\n        res = Matrix(self.n)\n        for i in range(self.n):\n            res.a[i][i] = 1\n        tmp = self\n        while e:\n            if e & 1:\n                res = res * tmp\n            e >>= 1\n            tmp = tmp * tmp\n        return res\nM = Matrix(6)\nM.a = [[2, 1, 1, 0, 1, 2],\n       [1, 2, 0, 1, 1, 2],\n       [1, 1, 1, 0, 1, 2],\n       [1, 1, 0, 1, 1, 2],\n       [0, 0, 0, 0, 1, 1],\n       [0, 0, 0, 0, 0, 1]]\nsx -= 1\nsy -= 1\nr = M ** t\nf = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % mod + 1\nprint(f(0), f(1))\n"]
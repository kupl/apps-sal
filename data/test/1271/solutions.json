["n, s, k = list(map(int, input().split()))\namounts = list(map(int, input().split()))\ncolors = list(input())\n\ndp = [[-1 for j in range(k + 1)] for i in range(n)]\n\ndef getAns(nth, left):\n    if left <= 0:\n        return 0\n    if dp[nth][left] >= 0:\n        return dp[nth][left]\n    \n    ret = 999999999\n    for i in range(n):\n        if amounts[i] <= amounts[nth] or colors[i] == colors[nth]:\n            continue\n        ret = min(ret, abs(nth - i) + getAns(i, left - amounts[i]))\n    \n    dp[nth][left] = ret\n    return ret\n\nans = 999999999\nfor i in range(n):\n    ans = min(ans, getAns(i, k - amounts[i]) + abs(s - 1 - i))\nif ans == 999999999:\n\tans = -1\nprint(ans)\n        \n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndp = [None]*50\nfor j in range(50):\n\tdp[j] = [None]*2001\n\nn,s,k = list(map(int,minp().split()))\na = [None]*n\ni = 0\ns -= 1\nfor j in map(int,minp().split()):\n\ta[i] = (j, i)\n\ti += 1\ni = 0\nfor j in minp():\n\ta[i] += (\"RGB\".find(j),)\n\ti += 1\na.sort()\nr = 10**18\nzzz = 0\nfor i in range(n):\n\tii = dp[i]\n\tc = a[i][0]\n\tii[c] = abs(s-a[i][1])\n\t#print(ii[c])\n\tfor j in range(i):\n\t\tif a[j][2] == a[i][2] or a[j][0] == a[i][0]:\n\t\t\tcontinue\n\t\tjj = dp[j]\n\t\tfor z in range(2001-c):\n\t\t\tzz = jj[z]\n\t\t\tif zz != None:\n\t\t\t\td = zz + abs(a[i][1]-a[j][1])\n\t\t\t\tcc = z+c\n\t\t\t\tif ii[cc] != None:\n\t\t\t\t\tif ii[cc] > d:\n\t\t\t\t\t\tii[cc] = d\n\t\t\t\telse:\n\t\t\t\t\tii[cc] = d\n\tfor z in range(k,2001):\n\t\tif ii[z] != None:\n\t\t\tr = min(r,ii[z])\n\t#print(ii[:k+1])\nif r != 10**18:\n\tprint(r)\nelse:\n\tprint(-1)\n", "INF = 1e10\nmax_n = 50\nmax_k = 2000\ndef main():\n    n, s, k = map(int, input().split())\n    s -= 1\n    buf = ['']*(max_n + 1)\n    dp = [[0 for i in range(max_n + 1)] for j in range(max_k + 1)] \n    r = list(map(int, input().split()))\n    c = input()\n    answer = INF\n    for i in range(len(c)):\n        buf[i] = c[i]\n    for i in range(k, -1, -1):\n        for j in range(n):\n            dp[i][j] = INF\n    for j in range(n):\n        value = abs(j - s)\n        if k - r[j] <= 0:\n            answer = min(answer, value)\n        else:\n            dp[k - r[j]][j] = value\n    for i in range(k, 0, -1):\n        for j in range(n):\n            if dp[i][j] < INF:\n                for l in range(n):\n                    if buf[j] != buf[l] and r[j] < r[l]:\n                        value = dp[i][j] + abs(j - l)\n                        if i - r[l] <= 0:\n                            answer = min(answer, value)\n                        else:\n                            dp[i - r[l]][l] = min(dp[i - r[l]][l], value)\n    if answer == INF:\n        print(-1)\n        return\n    print(answer)\n\ndef __starting_point():\n    main()\n__starting_point()", "INF = 10e9\nn,s,k = list(map(int, input().split()))\nr = list(map(int, input().split()))\nr.append(0)\ncol = input()\nmat = []\nfor i in range(n+1):\n    adj = {}\n    for j in range(n):\n        if i == n:\n            adj[j] = abs((s-1)-j)\n        else:\n            if col[i] != col[j] and r[i] < r[j]:\n                adj[j] = abs(i-j)\n    mat.append(adj)\n# print(*mat, sep='\\n')\n\nmem = [{} for i in range(n+1)]\n# print(mem)\n\ndef get(s, k):\n    # print(s,k)\n    # print(mem)\n    if mem[s].get(k):\n        return mem[s].get(k)\n    if r[s] >= k:\n        mem[s][k] = 0\n    else:\n        mi = None\n        for nei in mat[s]:\n            ncost = get(nei, k-r[s])\n            if ncost is None:\n                continue\n            curr = ncost + mat[s][nei]\n            if mi is None or curr < mi:\n                mi = curr\n        if mi is not None:\n            mem[s][k] = mi\n        else:\n            mem[s][k] = INF\n    return mem[s].get(k)\n\n# print(mem)\n\nans = get(n,k)\nif ans is None or ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n", "INF = 10e9\nn,s,k = list(map(int, input().split()))\nr = list(map(int, input().split()))\nr.append(0)\ncol = input()\nmat = []\nfor i in range(n+1):\n    adj = {}\n    for j in range(n):\n        if i == n:\n            adj[j] = abs((s-1)-j)\n        else:\n            if col[i] != col[j] and r[i] < r[j]:\n                adj[j] = abs(i-j)\n    mat.append(adj)\n# print(*mat, sep='\\n')\n\nmem = [{} for i in range(n+1)]\n# print(mem)\n\ndef get(s, k):\n    # print(s,k)\n    # print(mem)\n    if mem[s].get(k):\n        return mem[s].get(k)\n    if r[s] >= k:\n        mem[s][k] = 0\n    else:\n        mi = None\n        for nei in mat[s]:\n            ncost = get(nei, k-r[s])\n            if ncost is None:\n                continue\n            curr = ncost + mat[s][nei]\n            if mi is None or curr < mi:\n                mi = curr\n        if mi is not None:\n            mem[s][k] = mi\n        else:\n            mem[s][k] = INF\n    return mem[s].get(k)\n\n# print(mem)\n\nans = get(n,k)\nif ans is None or ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n", "inf = 10000\nn, s, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(input())\nfor i in range(n):\n    if b[i] == 'R':\n        b[i] = 0\n    elif b[i] == 'G':\n        b[i] = 1\n    else:\n        b[i] = 2\nboxes = [[a[i], b[i], i] for i in range(n)]\nboxes.sort()\nl = boxes[-1][0] * n + 1\ns -= 1\ndp = [[[inf, s, -1] for j in range(l)] for i in range(3)]\nif l < k:\n    print(-1)\n    return\ndp[0][0][0] = 0\ndp[1][0][0] = 0\ndp[2][0][0] = 0\nfor i in range(n):\n    pos = boxes[i][2]\n    clr = boxes[i][1]\n    cnt = boxes[i][0]\n    for j in range(l - cnt):\n        for c in range(3):\n            if c == clr:\n                continue\n            if dp[clr][j + cnt][0] > dp[c][j][0] + abs(dp[c][j][1] - pos) and cnt > dp[c][j][2]:\n                dp[clr][j + cnt][0] = dp[c][j][0] + abs(dp[c][j][1] - pos)\n                dp[clr][j + cnt][1] = pos\n                dp[clr][j + cnt][2] = cnt\nans = min(dp[0][k][0], min(dp[1][k][0], dp[2][k][0]))\nfor i in range(k, l):\n    ans = min(min(ans, dp[0][i][0]), min(dp[1][i][0], dp[2][i][0]))\nif ans < inf:\n    print(ans)\nelse:\n    print(-1)", "INF = 100000\n\nn,s,k=list(map(int,input().split()))\nr = list(map(int,input().split()))\nc = input().rstrip()\n#dp[i][j]: i = the current position just after eating candies, j = remaining candies to eat\ndp = [[INF for j in range(k+1)] for i in range(n)]\ns -= 1\nfor i in range(n):\n    dp[i][k-r[i]] = abs(s-i)\nfor j in range(k,-1,-1):\n    for i in range(n):\n        if dp[i][j] >= INF: continue\n        for f in range(n):\n            if r[f] <= r[i]: continue\n            if c[f] == c[i]: continue\n            new_val = max(0, j-r[f])\n            dp[f][new_val] = min(dp[f][new_val], dp[i][j] + abs(i-f))\nans = INF\nfor i in range(n):\n    ans = min(ans, dp[i][0])\nif ans >= INF:\n    ans = -1\n\nprint(ans)\n", "n, s, k = map(int, input().split())\ns -= 1\nr = list(map(int, input().split()))\nINF = float(\"inf\")\nc = input()\ndp = [[] for i in range(n)]\n\n\ndef calc(u):\n    if dp[u]:\n        return\n    dp[u] = [0] * (r[u] + 1) + [INF] * (k - r[u])\n    for i in range(n):\n        if c[u] != c[i] and r[i] > r[u]:\n            calc(i)\n            d = abs(u - i)\n            for j in range(r[u] + 1, k + 1):\n                dp[u][j] = min(dp[u][j], dp[i][j - r[u]] + d)\n\n\nans = INF\nfor i in range(n):\n    calc(i)\n    ans = min(ans, abs(i - s) + dp[i][k])\nif ans == INF:\n    print(-1)\nelse:\n    print(ans)", "n,s,k=map(int,input().split())\nr=list(map(int,input().split()))\ns-=1\nc=input()\nbest=[[0 for i in range(n)] for j in range(k+1)]\nfor i in range(1,k+1):\n    for j in range(n):\n        if i<=r[j]:\n            best[i][j]=abs(j-s)\n        else:\n            good=float(\"inf\")\n            for l in range(n):\n                if c[j]!=c[l] and r[j]>r[l]:\n                    good=min(good,best[i-r[j]][l]+abs(j-l))\n            best[i][j]=good\nif min(best[-1])==float('inf'):\n    print(-1)\nelse:\n    print(min(best[-1]))", "'''input\n2 1 15\n5 6\nRG\n'''\nimport math\ndef solve():\n\tn,s,k = map(int,input().split())\n\ts-=1\n\tr = list(map(int,input().split()))\n\tc = input()\n\tinf = int(1e9)\n\tdp = [[inf for j in range(n)] for i in range(k+1)]\n\t# dp[i][j] = minimum number of steps to get amount i if we start with jth index\n\tfor i in range(0,k+1):\n\t\tfor j in range(0,n):\n\t\t\tif i==0 or i<=r[j]:\n\t\t\t\tdp[i][j] = 0\n\t\t\t\tcontinue\n\t\t\tfor K in range(0,n):\n\t\t\t\tif c[K]!=c[j] and r[K]>r[j]:\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-r[j]][K]+int(abs(K-j)))\n\tans = min(dp[k][i]+abs(i-s) for i in range(0,n))\n\tif ans>=inf:\n\t\tprint(-1)\n\t\treturn\n\tprint(ans)\n\treturn\nt = 1\n#t = int(input())\nwhile t>0:\n\tt-=1\n\tsolve()"]
["from bisect import bisect_left\n\nM = 998244353\n\ndef pw(x, y):\n    if y == 0:\n        return 1\n    res = pw(x, y//2)\n    res = res * res % M\n    if y % 2 == 1:\n        res = res * x % M\n    return res\n\ndef cal(x, y):\n    y += x - 1\n    res = 1\n    for i in range(1, x + 1):\n        res = res * (y - i + 1)\n        res = res * pw(i, M - 2) % M\n    return res % M\n\nn = int(input())\na = []\nb = []\nres = 1\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n    res = res * (a[-1][1] + 1 - a[-1][0]) % M\n    b.append(a[-1][0])\n    b.append(a[-1][1] + 1)\n    b = set(b)\n    b = sorted(list(b))\n\ng = [b[i + 1] - b[i] for i in range(len(b) - 1)]\n\nfor i in range(n):\n    a[i][0] = bisect_left(b, a[i][0])\n    a[i][1] = bisect_left(b, a[i][1] + 1)\n\na = a[::-1]\n\nf = [[0 for _ in range(len(b))] for __ in range(n)]\n\nfor i in range(a[0][0], len(b)):\n    if i == 0:\n        f[0][i] = g[i]\n    else:\n        if i < a[0][1]:\n            f[0][i] = (f[0][i - 1] + g[i]) % M\n        else:\n            f[0][i] = f[0][i - 1]\n        \nfor i in range(1, n):\n    for j in range(a[i][0], len(b)):\n        if j > 0:\n            f[i][j] = f[i][j - 1]\n        if j < a[i][1]:\n            for k in range(i, -1, -1):\n                if a[k][1] <= j or j < a[k][0]:\n                    break\n                if k == 0 or j != 0:\n                    tmp = cal(i - k + 1, g[j])\n                    if k > 0:\n                        f[i][j] += f[k - 1][j - 1] * tmp % M\n                    else:\n                        f[i][j] += tmp\n                    f[i][j] %= M\n                    \n#print(f)\n#print(f[n - 1][len(b) - 1], res)\nprint(f[n - 1][len(b) - 1] * pw(res, M - 2) % M)\n", "from bisect import bisect_left\n\nM = 998244353\n\ndef pw(x, y):\n    if y == 0:\n        return 1\n    res = pw(x, y//2)\n    res = res * res % M\n    if y % 2 == 1:\n        res = res * x % M\n    return res\n\ndef cal(x, y):\n    y += x - 1\n    res = 1\n    for i in range(1, x + 1):\n        res = res * (y - i + 1)\n        res = res * pw(i, M - 2) % M\n    return res % M\n\nn = int(input())\na = []\nb = []\nres = 1\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n    res = res * (a[-1][1] + 1 - a[-1][0]) % M\n    b.append(a[-1][0])\n    b.append(a[-1][1] + 1)\n    b = set(b)\n    b = sorted(list(b))\n\ng = [b[i + 1] - b[i] for i in range(len(b) - 1)]\n\nfor i in range(n):\n    a[i][0] = bisect_left(b, a[i][0])\n    a[i][1] = bisect_left(b, a[i][1] + 1)\n\na = a[::-1]\n\nf = [[0 for _ in range(len(b))] for __ in range(n)]\n\nfor i in range(a[0][0], len(b)):\n    if i == 0:\n        f[0][i] = g[i]\n    else:\n        if i < a[0][1]:\n            f[0][i] = (f[0][i - 1] + g[i]) % M\n        else:\n            f[0][i] = f[0][i - 1]\n        \nfor i in range(1, n):\n    for j in range(a[i][0], len(b)):\n        if j > 0:\n            f[i][j] = f[i][j - 1]\n        if j < a[i][1]:\n            for k in range(i, -1, -1):\n                if a[k][1] <= j or j < a[k][0]:\n                    break\n                if k == 0 or j != 0:\n                    tmp = cal(i - k + 1, g[j])\n                    if k > 0:\n                        f[i][j] += f[k - 1][j - 1] * tmp % M\n                    else:\n                        f[i][j] += tmp\n                    f[i][j] %= M\n                    \n#print(f)\n#print(f[n - 1][len(b) - 1], res)\nprint(f[n - 1][len(b) - 1] * pw(res, M - 2) % M)\n", "import sys\nfrom itertools import chain\nreadline = sys.stdin.readline\n\nMOD = 998244353\ndef compress(L):\n    L2 = list(set(L))\n    L2.sort()\n    C = {v : k for k, v in enumerate(L2)}\n    return L2, C\n\n\nN = int(readline())\nLR = [tuple(map(int, readline().split())) for _ in range(N)]\nLR = [(a-1, b) for a, b in LR]\nLR2 = LR[:]\nml = LR[-1][0]\nres = 0\nfor i in range(N-2, -1, -1):\n    l, r = LR[i]\n    if r <= ml:\n        break\n    l = max(ml, l)\n    ml = l\n    LR[i] = (l, r)\nelse:\n    Z = list(chain(*LR))\n    Z2, Dc = compress(Z)\n    \n    NN = len(Z2)\n    seglen = [0] + [n - p for p, n in zip(Z2, Z2[1:])]\n    \n    hc = [[0]*(N+3) for _ in range(NN)]\n    for j in range(NN):\n        hc[j][0] = 1\n        for k in range(1, N+3):\n            hc[j][k] = hc[j][k-1]*pow(k, MOD-2, MOD)*(seglen[j]-1+k)%MOD\n\n    mask = [[[True]*NN]]\n\n    dp = [[[0]*(N+1) for _ in range(NN+1)] for _ in range(N+1)]\n    Dp = [[1]*(NN+1)] + [[0]*(NN+1) for _ in range(N)]\n    for i in range(1, N+1):\n        mask2 = [False]*NN\n        l, r = LR[i-1]\n        dl, dr = Dc[l], Dc[r]\n        for j in range(dr, dl, -1):\n            mask2[j] = True\n        mm = [[m1&m2 for m1, m2 in zip(mask[-1][idx], mask2)] for idx in range(i)] + [mask2]\n        mask.append(mm)\n        for j in range(NN):\n            for k in range(1, i+1):\n                if mask[i][i-k+1][j]:\n                    dp[i][j][k] = Dp[i-k][j+1]*hc[j][k]%MOD\n        \n        for j in range(NN-1, -1, -1):\n            res = Dp[i][j+1]\n            if dl < j <= dr:\n                for k in range(1, i+1):        \n                    res = (res + dp[i][j][k])%MOD\n            Dp[i][j] = res\n    \n    res = Dp[N][0]\n    for l, r in LR2:\n        res = res*(pow(r-l, MOD-2, MOD))%MOD\nprint(res)\n\n", "from bisect import bisect_left\n \nM = 998244353\n \ndef pw(x, y):\n    if y == 0:\n        return 1\n    res = pw(x, y//2)\n    res = res * res % M\n    if y % 2 == 1:\n        res = res * x % M\n    return res\n \ndef cal(x, y):\n    y += x - 1\n    res = 1\n    for i in range(1, x + 1):\n        res = res * (y - i + 1)\n        res = res * pw(i, M - 2) % M\n    return res % M\n \nn = int(input())\na = []\nb = []\nres = 1\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n    res = res * (a[-1][1] + 1 - a[-1][0]) % M\n    b.append(a[-1][0])\n    b.append(a[-1][1] + 1)\n    b = set(b)\n    b = sorted(list(b))\n \ng = [b[i + 1] - b[i] for i in range(len(b) - 1)]\n \nfor i in range(n):\n    a[i][0] = bisect_left(b, a[i][0])\n    a[i][1] = bisect_left(b, a[i][1] + 1)\n \na = a[::-1]\n \nf = [[0 for _ in range(len(b))] for __ in range(n)]\n \nfor i in range(a[0][0], len(b)):\n    if i == 0:\n        f[0][i] = g[i]\n    else:\n        if i < a[0][1]:\n            f[0][i] = (f[0][i - 1] + g[i]) % M\n        else:\n            f[0][i] = f[0][i - 1]\n        \nfor i in range(1, n):\n    for j in range(a[i][0], len(b)):\n        if j > 0:\n            f[i][j] = f[i][j - 1]\n        if j < a[i][1]:\n            for k in range(i, -1, -1):\n                if a[k][1] <= j or j < a[k][0]:\n                    break\n                if k == 0 or j != 0:\n                    tmp = cal(i - k + 1, g[j])\n                    if k > 0:\n                        f[i][j] += f[k - 1][j - 1] * tmp % M\n                    else:\n                        f[i][j] += tmp\n                    f[i][j] %= M\n                    \n#print(f)\n#print(f[n - 1][len(b) - 1], res)\nprint(f[n - 1][len(b) - 1] * pw(res, M - 2) % M)", "import sys\ninput = sys.stdin.readline\n\nmod=998244353\nn=int(input())\nLR=[list(map(int,input().split())) for i in range(n)]\nRMIN=1<<31\n\nALL=1\nfor l,r in LR:\n    ALL=ALL*pow(r-l+1,mod-2,mod)%mod\n\nfor i in range(n):\n    if LR[i][1]>RMIN:\n        LR[i][1]=RMIN\n    RMIN=min(RMIN,LR[i][1])\n\nLMAX=-1\nfor i in range(n-1,-1,-1):\n    if LR[i][0]<LMAX:\n        LR[i][0]=LMAX\n    LMAX=max(LMAX,LR[i][0])\n\ncompression=[]\nfor l,r in LR:\n    compression.append(l)\n    compression.append(r+1)\n\ncompression=sorted(set(compression))\nco_dict={a:ind for ind,a in enumerate(compression)}\n\nLEN=len(compression)-1\n\nif LEN==0:\n    print(0)\n    return\n\nDP=[[0]*LEN for i in range(n)]\n\nfor i in range(co_dict[LR[0][0]],co_dict[LR[0][1]+1]):\n    x=compression[i+1]-compression[i]\n    now=x\n    #print(i,x)\n    for j in range(n):\n        if LR[j][0]<=compression[i] and LR[j][1]+1>=compression[i+1]:\n            DP[j][i]=now\n        else:\n            break\n        now=now*(x+j+1)*pow(j+2,mod-2,mod)%mod\n\n#print(DP)\n\nfor i in range(1,n):\n    SUM=DP[i-1][LEN-1]\n    #print(DP)\n    for j in range(LEN-2,-1,-1):\n        if LR[i][0]<=compression[j] and LR[i][1]+1>=compression[j+1]:\n            x=SUM*(compression[j+1]-compression[j])%mod\n            now=x\n            t=compression[j+1]-compression[j]\n            #print(x,t)\n\n            for k in range(i,n):\n                \n                if LR[k][0]<=compression[j] and LR[k][1]+1>=compression[j+1]:\n                    DP[k][j]=(DP[k][j]+now)%mod\n                else:\n                    break\n                now=now*(t+k-i+1)*pow(k-i+2,mod-2,mod)%mod\n                \n        \n        SUM+=DP[i-1][j]\n\nprint(sum(DP[-1])*ALL%mod)\n\n        \n        \n    \n", "import sys\ninput = sys.stdin.readline\n\nmod=998244353\nn=int(input())\nLR=[list(map(int,input().split())) for i in range(n)]\nRMIN=1<<31\n\nALL=1\nfor l,r in LR:\n    ALL=ALL*pow(r-l+1,mod-2,mod)%mod\n\nfor i in range(n):\n    if LR[i][1]>RMIN:\n        LR[i][1]=RMIN\n    RMIN=min(RMIN,LR[i][1])\n\nLMAX=-1\nfor i in range(n-1,-1,-1):\n    if LR[i][0]<LMAX:\n        LR[i][0]=LMAX\n    LMAX=max(LMAX,LR[i][0])\n\ncompression=[]\nfor l,r in LR:\n    compression.append(l)\n    compression.append(r+1)\n\ncompression=sorted(set(compression))\nco_dict={a:ind for ind,a in enumerate(compression)}\n\nLEN=len(compression)-1\n\nif LEN==0:\n    print(0)\n    return\n\nDP=[[0]*LEN for i in range(n)]\n\nfor i in range(co_dict[LR[0][0]],co_dict[LR[0][1]+1]):\n    x=compression[i+1]-compression[i]\n    now=x\n    #print(i,x)\n    for j in range(n):\n        if LR[j][0]<=compression[i] and LR[j][1]+1>=compression[i+1]:\n            DP[j][i]=now\n        else:\n            break\n        now=now*(x+j+1)*pow(j+2,mod-2,mod)%mod\n\n#print(DP)\n\nfor i in range(1,n):\n    SUM=DP[i-1][LEN-1]\n    #print(DP)\n    for j in range(LEN-2,-1,-1):\n        if LR[i][0]<=compression[j] and LR[i][1]+1>=compression[j+1]:\n            x=SUM*(compression[j+1]-compression[j])%mod\n            now=x\n            t=compression[j+1]-compression[j]\n            #print(x,t)\n\n            for k in range(i,n):\n                \n                if LR[k][0]<=compression[j] and LR[k][1]+1>=compression[j+1]:\n                    DP[k][j]=(DP[k][j]+now)%mod\n                else:\n                    break\n                now=now*(t+k-i+1)*pow(k-i+2,mod-2,mod)%mod\n                \n        \n        SUM+=DP[i-1][j]\n\nprint(sum(DP[-1])*ALL%mod)\n\n        \n        \n    \n"]
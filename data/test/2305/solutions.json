["import sys\nfrom collections import defaultdict\n\n# \u518d\u5e30\u5236\u9650\u3092\u7de9\u548c\u3059\u308b\u304a\u307e\u3058\u306a\u3044\nsys.setrecursionlimit(10**6)\n\ndef sum(n):return n*(n+1)//2\n\n# \u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3068\u3001\u300c\u8272i\u3092\u5c01\u9396\u3057\u305f\u3068\u304d\u306b\u5230\u9054\u3067\u304d\u306a\u3044\u9802\u70b9\u306e\u500b\u6570\u300d\u3092\u6301\u3064\u8f9e\u66f8\u3092\u8fd4\u3059\ndef dfs(v,p):\n    ret=defaultdict(int)\n    size=1\n    for vv in g[v]:\n        if vv==p:\n            continue\n        ss,d=dfs(vv,v)\n        size+=ss\n        ans[c[v]]+=sum(ss-d[c[v]])\n        \n        # \u30de\u30fc\u30b8\u30c6\u30af\n        if len(ret)<len(d):\n            ret,d=d,ret\n        for vvv in d:\n            ret[vvv]+=d[vvv]\n    ret[c[v]]=size\n    return size,ret\n\nn=int(input())\nc=list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\nans=[0]*(n+1)\nfor _ in range(n-1):\n    s,t=list(map(int, input().split()))\n    s-=1\n    t-=1\n    g[s].append(t)\n    g[t].append(s)\n_,ret=dfs(0,-1)\nfor i in range(1,n+1):\n    print((sum(n)-ans[i]-sum(n-ret[i])))\n", "import sys\nsys.setrecursionlimit(10**6)\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn = int(input())\nc = list(map(int, input().split()))\nans = [n*(n+1)//2 for _ in range(n)]\nfor i in range(n):\n\tc[i] -= 1\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n\ta, b = map(int, input().split())\n\tadj[a-1].append(b-1)\n\tadj[b-1].append(a-1)\n\ns = 0\ndp = [0 for _ in range(n)]\n\ndef dfs(x, p):\n\tnonlocal s\n\tpres = s + dp[c[x]]\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\tdp[c[x]] = -s\n\t\tdfs(v, x)\n\t\tans[c[x]] -= (s+dp[c[x]]) * (s+dp[c[x]]+1) // 2\n\ts += 1\n\tdp[c[x]] = pres - s\n\treturn\n\ndfs(0, -1)\nfor i in range(n):\n\tans[i] -= (s+dp[i]) * (s+dp[i]+1) // 2\n\nprint(*ans, sep=\"\\n\")", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\nfrom collections import defaultdict\nINF = float(\"inf\")\nMOD = 10**9+7\n\n\nclass Graph(object):\n    def __init__(self, N):\n        self.N = N\n        self.E = defaultdict(list)\n\n    def add_edge(self, f, t, w=1):\n        self.E[f].append(t)\n        self.E[t].append(f)\n\n\ndef make_order(g, v):\n    seen = [False]*g.N\n    last_order = [-1]*g.N\n    parent = [-1]*g.N\n    size = [1]*g.N\n    counter = {\"last\": 0}\n\n    def recur(v):\n        seen[v] = True\n        for to in g.E[v]:\n            if seen[to] == True:\n                continue\n            parent[to] = v\n            recur(to)\n            size[v] += size[to]\n\n        last_order[counter[\"last\"]] = v\n        counter[\"last\"] += 1\n\n    recur(v)\n    return last_order, parent, size\n\n\ndef merge(d: dict, e: dict):\n    if len(d) < len(e):\n        d, e = e, d\n    for k in e:\n        d[k] += e[k]\n    return d\n\n\nN = int(input())\nc = [x-1 for x in map(int, input().split())]\nA = [None]*(N-1)\nB = [None]*(N-1)\nfor i in range(N-1):\n    A[i], B[i] = list(map(int, input().split()))\n\ng = Graph(N)\nfor a, b in zip(A, B):\n    g.add_edge(a-1, b-1)\n\nans = [0]*N\n\nret = {}\nlast_order, parent, size = make_order(g, 0)\nfor curr in last_order:\n    cn = c[curr]\n    rrr = defaultdict(int)\n    for dest in g.E[curr]:\n        if dest == parent[curr]:\n            continue\n        child = ret.pop(dest)\n\n        n = size[dest]-child[cn]\n        ans[cn] += n*(n+1)//2\n\n        # \u30de\u30fc\u30b8\n        rrr = merge(rrr, child)\n\n    rrr[cn] = size[curr]\n    ret[curr] = rrr\n\n\ntot = N*(N+1)//2\nfor color in range(N):\n    if color != c[0]:\n        n = N-ret[0][color]\n        ans[color] += n*(n+1)//2\n    print((tot-ans[color]))\n", "import sys\nsys.setrecursionlimit(10**6)\n \nN = int(input())  # \u9802\u70b9\u6570\nC = [int(x) - 1  for x in input().split()]  # \u9802\u70b9\u306e\u8272\u756a\u53f7 (1~N) -> (0~N-1)\n \nE = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n    \ndef dfs(u, p = -1):\n \n    color = C[u]  # \u8272\u756a\u53f7\n    VC[color].append(u)  # \u8272\u3054\u3068\u306b stack \u3057\u3066\u304a\u304f\n    \n    s = 1  # \u90e8\u5206\u6728\u30b5\u30a4\u30ba\uff08\u3092\u683c\u7d0d\u3059\u308b\uff09\n    for v in E[u]:\n        if v == p:\n            continue\n            \n        child[u] = 0  # v \u306e\u65b9\u5411\u306b\u3042\u308b\u5b50\u5b6b\u306e\u3046\u3061\u8fbf\u308c\u308b\u9802\u70b9\u306e\u6570 = s - \u5b50\u5b6b\u306b\u3042\u308b\u3001\u540c\u8272\u3092\u6839\u3068\u3059\u308b\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u306e\u5408\u8a08\n        ret = dfs(v, u)\n \n        s += ret  # \u7d14\u7c8b\u306a\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8a08\u7b97\n        child[u] += ret  # \u540c\u8272\u306e\u9802\u70b9\u304c\u5207\u308a\u96e2\u3055\u308c\u305f\u3042\u3068\u306e\u90e8\u5206\u6728\u30b5\u30a4\u30ba\n        \n        ans[color] -= child[u] * (child[u] + 1) // 2        \n \n    VC[color].pop()\n    if VC[color]: # \u4e0a\u4f4d\u306b\u540c\u3058\u8272\u304c\u3042\u308b\u5834\u5408\n        child[VC[color][-1]] -= s  # \u4e00\u756a\u8fd1\u3044\u540c\u8272\u304b\u3089\u3001\u81ea\u5206\u306e\u90e8\u5206\u6728\u306e\u5927\u304d\u3055\u3092\u3072\u304f\n    else:  # \u4e0a\u4f4d\u306b\u540c\u3058\u8272\u304c\u306a\u3044\u5834\u5408\n        root_size[color] -= s  # \u4e0a\u4f4d\u306b\u6b8b\u3063\u3066\u3044\u308b\u9802\u70b9\u306e\u6570\n        \n    return s\n\nchild = [0] * N  # \u8fbf\u3063\u3066\u3044\u308b\u5b50\u306e\u4e2d\u3067\u306e\u306e\u6b8b\u308a\u6570\u3000\u3068\u308a\u3042\u3048\u305a 0\u3067\u521d\u671f\u5316\nroot_size = [N] * N  # \u6839\u65b9\u5411\u306b\u6b8b\u3063\u3066\u3044\u308b\u9802\u70b9\u306e\u6570\uff08\u3092\u683c\u7d0d\u3059\u308b\u3002\u64cd\u4f5c\u524d\u306f N \u5168\u90e8\uff09\nVC = [ [] for _ in range(N)]  # \u8272\u756a\u53f7\u3054\u3068\nans = [N*(N+1)//2] * N  # \u8272\u3054\u3068\u306e\uff08\u6b8b\u308a\u306e\uff09\u7d44\u307f\u5408\u308f\u305b\u6570\u3000\u521d\u671f\u5024\u306f \u5168\u70b9\u306e\u7d44\u307f\u5408\u308f\u305b\n \ndfs(0)\n \nfor i in range(N):\n    print(ans[i] - root_size[i] * (root_size[i] + 1) // 2)", "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN=int(input())\nc=list(map(int,input().split()))\nfor i in range(N):\n    c[i]-=1\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\nsubtree=[1]*N\ndef size(v,pv):\n    for nv in edge[v]:\n        if nv!=pv:\n            size(nv,v)\n            subtree[v]+=subtree[nv]\n\nsize(0,-1)\n\ndata=[[] for i in range(N)]\nParent=[[0] for i in range(N)]\nparent=[0]*N\ndef dfs(v,pv,nop):\n    pp=parent[nop]\n    parent[nop]=v\n    Parent[nop].append(v)\n    data[c[v]].append((parent[c[v]],v))\n    for nv in edge[v]:\n        if nv!=pv:\n            dfs(nv,v,c[v])\n    parent[nop]=pp\n\ndfs(0,-1,0)\n\nfor i in range(N):\n    dic={v:subtree[v] for v in Parent[i]}\n    for p,ch in data[i]:\n        dic[p]-=subtree[ch]\n\n    res=N*(N+1)//2\n    for p in dic:\n        res-=dic[p]*(dic[p]+1)//2\n    print(res)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nhead = [-1] * (N + 1)\nto = [0] * (N - 1 << 1)\nnxt = [0] * (N - 1 << 1)\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    x, y = x-1, y-1\n    nxt[i] = head[x]\n    to[i] = y\n    head[x] = i\n    j = i + N - 1\n    nxt[j] = head[y]\n    to[j] = x\n    head[y] = j\n\ndef EulerTour(n, i=0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    ANS = [f(n)] * n\n    \n    P = [-1] * n\n    ct = 0\n    ET1 = [0] * n\n    ET2 = [0] * n\n    while i >= 0:\n        e = head[i]\n        if e < 0:\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                k = ET2[i] - ET1[i] + 1 - USED[C[P[i]]] + ORG[i]\n                ANS[C[P[i]]] -= f(k)\n                TMP[P[i]] += k\n            i = P[i]\n            continue\n        \n        j = to[e]\n        if P[i] == j:\n            head[i] = nxt[e]\n            continue\n        \n        P[j] = i\n        head[i] = nxt[e]\n        i = j\n        ORG[i] = USED[C[P[i]]]\n        ct += 1\n        ET1[i] = ct\n    \n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, 0), sep = \"\\n\")", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\ndef EulerTour(n, X, i0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    P = [-1] * n\n    Q = [~i0, i0]\n    ct = -1\n    ET1 = [0] * n\n    ET2 = [0] * n\n    ANS = [f(n)] * n\n    done = [0] * n\n    while Q:\n        i = Q.pop()\n        if i < 0:\n            i = ~i\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                k = ET2[i] - ET1[i] + 1 - USED[C[P[i]]] + ORG[i]\n                ANS[C[P[i]]] -= f(k)\n                TMP[P[i]] += k\n            continue\n        done[i] = 1\n        if i: ORG[i] = USED[C[P[i]]]\n        ct += 1\n        ET1[i] = ct\n        for a in X[i]:\n            if done[a]: continue\n            P[a] = i\n            Q.append(~a)\n            Q.append(a)\n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, X, 0), sep = \"\\n\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nn = int(input())\nc = list(map(lambda x: int(x) - 1, input().split()))\n\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\nans = [n * (n + 1) // 2] * n\nn_subtree = [1] * n  # n_st[i] = (\u9802\u70b9i\u306e\u90e8\u5206\u6728\u306e\u9802\u70b9\u6570)\ncnt = [0] * n  # cnt[i] = (\u8a2a\u554f\u6e08\u307f\u9802\u70b9\u306e\u3046\u3061\u3001\u8272i\u3092\u901a\u904e\u3057\u306a\u3044\u3068\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u9802\u70b9\u6570)\nn_visited = 0\n\n\ndef dfs(v, v_p):\n    nonlocal n_visited\n    cnt_v_before = cnt[c[v]]\n    for v_next in graph[v]:\n        if v_next == v_p:\n            continue\n\n        m_prev = n_visited - cnt[c[v]]\n        dfs(v_next, v)\n        n_subtree[v] += n_subtree[v_next]\n        m_next = n_visited - cnt[c[v]]\n\n        m = m_next - m_prev\n        ans[c[v]] -= m * (m + 1) // 2\n\n    cnt[c[v]] = cnt_v_before + n_subtree[v]\n    n_visited += 1\n\n\ndfs(0, -1)\n\nfor i in range(n):\n    m = n - cnt[i]\n    ans[i] -= m * (m + 1) // 2\n\nprint(*ans, sep='\\n')\n", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\n\nn = int(input())\nC = list(map(int,input().split()))\n\n# ci = [set() for _ in range(n)]\n# for i,c in enumerate(C):\n#     ci[c-1].add(i)\n\npath = [set() for _ in range(n)]\n\nfor i in range(n-1):\n    a,b = list(map(int,input().split()))\n    a -= 1\n    b -= 1\n    path[a].add(b)\n    path[b].add(a)\n\nans = [n*(n+1)//2]*n\ncparent = [[] for _ in range(n)]\nroot_size = [n]*n\n# index:color\nreached = [False]*n\nsize = [0]*n\n# index:vertex\n\ndef dfs(p):\n    c = C[p] - 1\n    cparent[c].append(p)\n    s = 1\n    for nxt in path[p]:\n        if reached[nxt]:continue\n        reached[nxt] = True\n        size[p] = 0\n        ret = dfs(nxt)\n        s += ret\n        size[p] += ret\n        ans[c] -= size[p] * (size[p] + 1)//2\n    cparent[c].pop()\n    # size[p] += s\n    if cparent[c]:\n        size[cparent[c][-1]] -= s\n    else:\n        root_size[c] -= s\n    # ans[c] -= size[p] * (size[p] - 1)//2\n    return s\n\nreached = [False]*n\nreached[0] = True\n\ndfs(0)\nfor i in range(n):\n    print((ans[i] - root_size[i]*(root_size[i]+1)//2))\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\ndef EulerTour(n, X, i0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    P = [-1] * n\n    ct = -1\n    ET1 = [0] * n\n    ET2 = [0] * n\n    ANS = [f(n)] * n\n    IND = [0] * n\n    i = i0\n    while i >= 0:\n        ind = IND[i]\n        if ind == 0:\n            if i: ORG[i] = USED[C[P[i]]]\n            ct += 1\n            ET1[i] = ct\n        \n        if ind >= len(X[i]):\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                k = ET2[i] - ET1[i] + 1 - USED[C[P[i]]] + ORG[i]\n                ANS[C[P[i]]] -= f(k)\n                TMP[P[i]] += k\n            i = P[i]\n            continue\n        \n        j = X[i][ind]\n        if P[i] == j:\n            IND[i] += 1\n            continue\n        P[j] = i\n        IND[i] += 1\n        i = j\n    \n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, X, 0), sep = \"\\n\")", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nn = int(input())\nC = list(map(int,input().split()))\n\npath = [set() for _ in range(n)]\n\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    path[a].add(b)\n    path[b].add(a)\n    \nans = [n*(n+1)//2]*n\nsize = [0]*n\ncparent = [[] for _ in range(n)]\nreached = [False]*n\nroot_size = [n]*n\n\ndef dfs (p):\n    c = C[p] - 1\n    cparent[c].append(p)\n    s = 1\n    for nxt in path[p]:\n        #print (nxt)\n        \n        if reached[nxt]:\n            continue\n        size[p] = 0\n        reached[nxt] = True\n        ret = dfs(nxt)\n        s += ret\n        size[p] +=ret\n        ans[c] -= size[p] * (size[p] + 1)//2\n    cparent[c].pop()\n    if cparent[c]:\n        size[cparent[c][-1]] -=s\n    else:\n        root_size[c] -=s    \n    return s\n\nreached[0] = True\ndfs (0)\n\nfor i in range(n):\n    print (ans[i]-root_size[i]*(root_size[i]+1)//2)", "import sys\nsys.setrecursionlimit(10**6)\ndef main():\n    n=int(input())\n    color=list(map(int,input().split()))\n    nodes=[[]for i in range(n)]\n    cut=[[0]for i in range(n+1)]\n    ans=[0]*(n+1)\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        nodes[a-1].append(b-1)\n        nodes[b-1].append(a-1)\n    def num(p,parent):\n        s=0\n        for child in nodes[p]:\n            if child==parent:\n                continue\n            cut[color[p]].append(0)\n            nc=num(child,p)\n            group=nc-cut[color[p]].pop()\n            ans[color[p]]+=group*(group+1)//2\n            s+=nc\n        s+=1\n        cut[color[p]][-1]+=s\n        return s\n    num(0,-1)\n    for a,c in zip(ans[1:],cut[1:]):\n        group=n-c[0]\n        c=group*(group+1)//2\n        print(n*(n+1)//2-c-a)\nmain()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\ndef EulerTour(n, X, i0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    P = [-1] * n\n    Q = [~i0, i0]\n    ct = -1\n    ET1 = [0] * n\n    ET2 = [0] * n\n    ANS = [f(n)] * n\n    while Q:\n        i = Q.pop()\n        if i < 0:\n            i = ~i\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                p = P[i]\n                k = ET2[i] - ET1[i] + 1 - USED[C[p]] + ORG[i]\n                ANS[C[p]] -= f(k)\n                TMP[p] += k\n            continue\n        if i >= 0:\n            if i: ORG[i] = USED[C[P[i]]]\n            ct += 1\n            if ET1[i] == 0: ET1[i] = ct\n        for a in X[i][::-1]:\n            if a != P[i]:\n                P[a] = i\n                for k in range(len(X[a])):\n                    if X[a][k] == i:\n                        del X[a][k]\n                        break\n                Q.append(~a)\n                Q.append(a)\n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, X, 0), sep = \"\\n\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    N = int(input())\n    Cs = [A-1 for A in map(int, input().split())]\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list(map(int, input().split()))\n        a, b = a-1, b-1\n        adjL[a].append(b)\n        adjL[b].append(a)\n\n    sizeSubtrees = [1] * N\n    numVs = [0] * N\n    anss = [0] * N\n\n    def dfs(vNow, vPar, clrPar):\n        clrNow = Cs[vNow]\n        numVNow = numVs[clrNow]\n        numVPar = numVs[clrPar]\n        for v2 in adjL[vNow]:\n            if v2 == vPar: continue\n            dfs(v2, vNow, clrNow)\n            sizeSubtrees[vNow] += sizeSubtrees[v2]\n        numVs[clrNow] = numVNow + sizeSubtrees[vNow]\n        if clrPar != -1:\n            k = sizeSubtrees[vNow] - (numVs[clrPar]-numVPar)\n            anss[clrPar] += k*(k+1)//2\n\n    dfs(0, -1, -1)\n\n    for clr in range(N):\n        if clr == Cs[0]: continue\n        k = N - numVs[clr]\n        anss[clr] += k*(k+1)//2\n\n    numAll = N*(N+1)//2\n    anss = [numAll-ans for ans in anss]\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "import sys\nimport itertools\n\nsys.setrecursionlimit(3 * 10**5)\n\n\nclass Node:\n  def __init__(self, color):\n    self.color = int(color) - 1\n    self.children = []\n\n  def add_child(self, node):\n    self.children.append(node)\n\n  @staticmethod\n  def prepare_nodes(n):\n    nodes = tuple(map(Node, input().split()))\n    for _ in range(n - 1):\n      a, b = [int(x) - 1 for x in input().split()]\n      nodes[a].add_child(nodes[b])\n      nodes[b].add_child(nodes[a])\n\n    return nodes\n\n\ndef main():\n  n = int(input())\n  nodes = Node.prepare_nodes(n)\n\n  dp = [0 for _ in range(n)]\n  ans_list = [n*(n + 1) // 2 for _ in range(n)]\n\n  def update_ans(s, color):\n    ans_list[color] -= (s + dp[color]) * (s + dp[color] + 1) // 2\n\n  def dfs(s, node, parent):\n    color = node.color\n    pre_s = s + dp[color]\n    for child in node.children:\n      if child == parent: continue\n\n      dp[color] = -s\n      s = dfs(s, child, node)\n      update_ans(s, color)\n\n    s += 1\n    dp[color] = pre_s - s\n\n    return s\n\n  s = dfs(0, nodes[0], Node(-1))\n\n  for i in range(n):\n    update_ans(s, i)\n    print((ans_list[i]))\n\n\nmain()\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    N = int(input())\n    C = [c-1 for c in map(int, input().split())]\n    tree = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n\n    # 1\u56de\u4ee5\u4e0a > \u5168\u4f53 - 1\u56de\u3082\u901a\u3089\u306a\u3044\n    # \u9078\u3079\u308b\u6570 = n(n+1)//2\n    size_subtree = [1] * N\n    num_v = [0] * N\n    ans = [0] * N\n\n    def dfs(v_now, v_parent, color_parent):\n        color_now = C[v_now]\n        num_v_now = num_v[color_now]\n        num_v_parent = num_v[color_parent]\n        for v2 in tree[v_now]:\n            if v2 == v_parent: continue\n            dfs(v2, v_now, color_now)\n            size_subtree[v_now] += size_subtree[v2]\n        num_v[color_now] = num_v_now + size_subtree[v_now]\n        if color_parent != -1:\n            k = size_subtree[v_now] - (num_v[color_parent]-num_v_parent)\n            ans[color_parent] += k*(k+1)//2\n\n    dfs(0, -1, -1)\n\n    for color in range(N):\n        if color == C[0]: continue\n        k = N - num_v[color]\n        ans[color] += k*(k+1)//2\n\n    numAll = N*(N+1)//2\n    ans = [numAll-ans for ans in ans]\n\n    print(*ans, sep='\\n')\n\nmain()\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\nfrom collections import defaultdict\nINF = float(\"inf\")\nMOD = 10**9+7\n\n\nclass Graph(object):\n    def __init__(self, N):\n        self.N = N\n        self.E = defaultdict(list)\n\n    def add_edge(self, f, t, w=1):\n        self.E[f].append((t, w))\n        self.E[t].append((f, w))\n\n\nN = int(input())\nc = [x-1 for x in map(int, input().split())]\nA = [None]*(N-1)\nB = [None]*(N-1)\nfor i in range(N-1):\n    A[i], B[i] = list(map(int, input().split()))\n\ng = Graph(N)\nfor a, b in zip(A, B):\n    g.add_edge(a-1, b-1)\n\n# k=1, 2, ..., N\u306b\u5bfe\u3057\u3066\n# \u8272k\u304c\u5857\u3089\u308c\u3066\u3044\u308b\u9802\u70b9\u3092\u4e00\u5ea6\u4ee5\u4e0a\u901a\u308b\u3088\u3046\u306a\u5358\u7d14\u30d1\u30b9\u306e\u6570\u3092\u6c42\u3081\u308b\n# \u5168\u30d1\u30b9\u306e\u500b\u6570 - \u8272k\u304c\u5857\u3089\u308c\u3066\u3044\u308b\u9802\u70b9\u3092\u4e00\u5ea6\u3082\u901a\u3089\u306a\u3044\u5358\u7d14\u30d1\u30b9\u306e\u6570\n# \u5168\u30d1\u30b9\u306e\u500b\u6570\u306fN*(N+1)/2\n\n# \u30b0\u30e9\u30d5\u3092\u8272k\u306e\u30ce\u30fc\u30c9\u3067\u5206\u5272\u3057\u3066\u3001\u90e8\u5206\u30b0\u30e9\u30d5\u5185\u3067\u306e\u5358\u7d14\u30d1\u30b9\u306e\u7dcf\u6570\u3092\u6c42\u3081\u308c\u3070\u826f\u3044\n# \u5404\u30ce\u30fc\u30c9\u306b\u72b6\u614b\u3068\u3057\u3066\u8f9e\u66f8\u3092\u3082\u305f\u305b\u308b\u3002\n# x\u8f9e\u66f8\u306f\u8272i\u3092\u901a\u3089\u305a\u306b\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306e\u6570\u3092\u6301\u3064\u3002\n# o\u8f9e\u66f8\u306f\u8272i\u3092\u901a\u3089\u305a\u306b\u5230\u9054\u4e0d\u53ef\u80fd\u306a\u9802\u70b9\u306e\u6570\u3092\u6301\u3064\u3002\n\n# \u56de\u7b54\u7528\nans = [0]*N\n\n\ndef f(curr, par=-1):\n    # \u518d\u5e30\u95a2\u6570\n    # curr: \u73fe\u5728\u306e\u7bc0\u70b9\n    # par : \u89aa\u7bc0\u70b9\u306e\u756a\u53f7\n    ret = defaultdict(int)\n    size = 1\n    for dest, w in g.E[curr]:\n        if dest == par:\n            continue\n        sz, child = f(dest, curr)\n        size += sz\n\n        # \u81ea\u8eab\u306e\u8272\u3068\u540c\u3058\u5834\u5408\u3001\u5b50\u306e\u9802\u70b9\u306e\u6570\u304b\u3089\u52a0\u7b97\n        n = sz-child[c[curr]]\n        ans[c[curr]] += n*(n+1)//2\n\n        # \u30de\u30fc\u30b8\n        if len(ret) < len(child):\n            child, ret = ret, child\n        for key in child:\n            ret[key] += child[key]\n\n    ret[c[curr]] = size\n    return size, ret\n\n\nsz, ret = f(0)\nfor color in range(N):\n    if color != c[0]:\n        n = sz-ret[color]\n        ans[color] += n*(n+1)//2\n\ntot = N*(N+1)//2\nfor a in ans:\n    print((tot-a))\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\ndef EulerTour(n, X, i0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    P = [-1] * n\n    ct = -1\n    ET1 = [0] * n\n    ET2 = [0] * n\n    ANS = [f(n)] * n\n    IND = [0] * n\n    i = i0\n    while i >= 0:\n        if IND[i] == 0:\n            if i: ORG[i] = USED[C[P[i]]]\n            ct += 1\n            ET1[i] = ct\n        \n        if IND[i] >= len(X[i]):\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                k = ET2[i] - ET1[i] + 1 - USED[C[P[i]]] + ORG[i]\n                ANS[C[P[i]]] -= f(k)\n                TMP[P[i]] += k\n            i = P[i]\n            continue\n        \n        if P[i] == X[i][IND[i]]:\n            IND[i] += 1\n            continue\n        P[X[i][IND[i]]] = i\n        IND[i], i = IND[i] + 1, X[i][IND[i]]\n    \n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, X, 0), sep = \"\\n\")", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\ndef EulerTour(n, X, i0):\n    f = lambda k: k * (k + 1) // 2\n    USED = [0] * n\n    ORG = [0] * n\n    TMP = [0] * n\n    P = [-1] * n\n    ct = -1\n    ET1 = [0] * n\n    ET2 = [0] * n\n    ANS = [f(n)] * n\n    IND = [len(x) for x in X]\n    i = i0\n    while i >= 0:\n        ind = IND[i]\n        if not ind:\n            ET2[i] = ct\n            USED[C[i]] += 1 + TMP[i]\n            if i:\n                k = ET2[i] - ET1[i] + 1 - USED[C[P[i]]] + ORG[i]\n                ANS[C[P[i]]] -= f(k)\n                TMP[P[i]] += k\n            i = P[i]\n            continue\n        \n        j = X[i][ind - 1]\n        if P[i] == j:\n            IND[i] -= 1\n            continue\n        \n        P[j] = i\n        IND[i] -= 1\n        i = j\n        ORG[i] = USED[C[P[i]]]\n        ct += 1\n        ET1[i] = ct\n    \n    for i in range(n):\n        ANS[i] -= f(n - USED[i])\n    return ANS\n\nprint(*EulerTour(N, X, 0), sep = \"\\n\")", "import sys\nsys.setrecursionlimit(10**6)\nstdin = sys.stdin\n\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: map(int, stdin.readline().split())\nnl = lambda: list(map(int, stdin.readline().split()))\n\nn = ni()\ncolor = nl()\ng = [list() for _ in range(n)]\nfor _ in range(n-1):\n    a, b = nm()\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\nsize = [1]*n\npar = [-1]*n\nh = [list() for _ in range(n+1)]\nidx = [0]*n\ndef dfs(v, p):\n    h[color[v]].append(v)\n    for x in g[v]:\n        if x == p: continue\n        par[x] = v\n        size[v] += dfs(x, v)\n        h[color[v]].append(v)\n    h[color[v]].append(v)\n    return size[v]\ndfs(0, -1)\n# print(size)\nfor v in range(n):\n    if idx[v] < len(g[v]) and g[v][idx[v]] == par[v]:\n        idx[v] += 1\nacc = [0]*(n+10)\nans = [n*(n+1)//2]*(n+1)\nfor col in range(1, n+1):\n    # print(h[col])\n    acc[-1] = 0\n    p = [-1]\n    for v in h[col]:\n        if p[-1] == v:\n            p.pop()\n            if idx[v] >= len(g[v]):\n                acc[p[-1]] += size[v]\n                continue\n            q = size[g[v][idx[v]]] - acc[v]\n            idx[v] += 1\n            if idx[v] < len(g[v]) and g[v][idx[v]] == par[v]:\n              idx[v] += 1\n            ans[col] -= q*(q+1)//2\n            acc[v] = 0\n            # print(v, q)\n            p.append(v)\n        else:\n            p.append(v)\n    q = n - acc[-1]\n    # print(-1, q)\n    ans[col] -= q*(q+1)//2\nprint(*ans[1:], sep='\\n')"]
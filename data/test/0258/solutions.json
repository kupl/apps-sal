["n=int(input())\ns=input()\nleft=0\nright=0\nleft_ques=0\nright_ques=0\nfor i in range(n):\n    if i<n//2:\n        if s[i]=='?':\n            left_ques+=1\n        else :\n            left+=int(s[i])\n    else :\n        if s[i]=='?':\n            right_ques+=1\n        else :\n            right+=int(s[i])\nx=min(left_ques,right_ques)\nleft_ques-=x\nright_ques-=x\nif left_ques==0 and right_ques==0:\n    if left==right:\n        print(\"Bicarp\")\n    else :\n        print(\"Monocarp\")\nelse :\n    if left_ques==0:\n        if right_ques%2==0:\n            x=9*(right_ques//2)+right\n            if x==left:\n                print(\"Bicarp\")\n            else :\n                print(\"Monocarp\")\n        else :\n            print(\"Monocarp\")\n    else :\n        if left_ques%2==0:\n            x=9*(left_ques//2)+left\n            if x==right:\n                print(\"Bicarp\")\n            else :\n                print(\"Monocarp\")\n        else :\n            print(\"Monocarp\")", "n = int(input())\na = input()\nif a.count('?') % 2 == 1:\n    print('Monocarp')\nelse:\n    x = y = k = m = 0\n    for q in range(n):\n        if q*2 < n:\n            if a[q] == '?':\n                k += 1\n            else:\n                x += int(a[q])\n        else:\n            if a[q] == '?':\n                m += 1\n            else:\n                y += int(a[q])\n    if (y - x) % 9 == 0 and (y - x) // 9 == (k-m)//2:\n        print('Bicarp')\n    else:\n        print('Monocarp')\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\ndef lis():return [int(i) for i in input().split()]\ndef value():return int(input())\n\n\nn=value()\na=input().strip('\\n')\nl1,l2=a[:(n//2)].count('?'),a[(n//2):].count('?')\ns1 = s2 = 0\nfor i in range(len(a)):\n    if i<n//2:\n        s1+=int(a[i]) if a[i]!='?' else 0\n    else:\n        s2+=int(a[i]) if a[i]!='?' else 0\nno = 1\nfor i in range(l1):\n    if s1>s2:\n        if no:\n            s1+=9\n        else:s1+=0\n    else:\n        if no:\n            s1+=0\n        else:s1+=9\n    no = 1 - no\nfor i in range(l2):\n    if s1>s2:\n        if no:\n            s2+=0\n        else:s2+=9\n    else:\n        if no:\n            s2+=9\n        else:s2+=0\n    no = 1 - no\nif s1!=s2:print('Monocarp')\nelse:print('Bicarp')\n            \n", "import sys\n\nn = int(sys.stdin.readline().strip())\nm = n // 2\ns = sys.stdin.readline().strip()\ns1 = 0\ns2 = 0\nx1 = 0\nx2 = 0\nfor i in range (0, m):\n    if s[i] == \"?\":\n        x1 = x1 + 1\n    else:\n        s1 = s1 + int(str(s[i]))\n    if s[m+i] == \"?\":\n        x2 = x2 + 1\n    else:\n        s2 = s2 + int(str(s[m+i]))\nif s1 + (x1 // 2) * 9 == s2 + (x2 // 2) * 9:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")\n    \n", "import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nn = int(input())\ns = input()\n\nsa = 0\nsb = 0\na = 0\nb = 0\n\n\nfor i in range(n):\n  if s[i] == '?':\n    if i < n // 2:\n      a += 1\n    else:\n      b += 1\n  else:\n    if i < n // 2:\n      sa += int(s[i])\n    else:\n      sb += int(s[i])\n\nM = \"Monocarp\"\nB = \"Bicarp\"\n\n\nif sa == sb:\n  if a == b:\n    print(B)\n    return\n  else:\n    print(M)\n    return\n\nif sa <= sb:\n  sa, sb = sb, sa\n  a, b = b, a\n\nif a == b:\n  print(M)\n  return\n\nelif a > b:\n  print(M)\n  return\n\nelse:\n  diff = sa - sb\n  x = (b - a) // 2\n  #print(\"debug\", diff, x)\n  if diff == 9*x:\n    print(B)\n    return\n  else:\n    print(M)\n    return\n\n", "def f(q1, q2, k1, k2):\n    res1 = res2 = 0\n    res1 += ((q1 + 1) // 2) * k1\n    res1 += (q1 // 2) * k2\n    res2 += (q2 // 2) * k2\n    res2 += ((q2 + 1) // 2) * k1\n    return [res1, res2]\n\n\nn = int(input())\ns = input()\nsum_l = sum_r = 0\nql = qr = 0\nfor i in range(n // 2):\n    if s[i] == '?':\n        ql += 1\n    else:\n        sum_l += int(s[i])\nfor i in range(n // 2, n):\n    if s[i] == '?':\n        qr += 1\n    else:\n        sum_r += int(s[i])\nmn = float('inf')\nmx = float('inf')\nkek = [f(ql, qr, 0, 9), f(ql, qr, 9, 0), f(qr, ql, 9, 0)[::-1], f(qr, ql, 0, 9)[::-1]]\nlol = []\nfor x in kek:\n    lol.append(x[0] + sum_l - x[1] - sum_r)\nlol.sort()\nif lol[0] <= 0 <= lol[-1]:\n    print('Bicarp')\nelse:\n    print('Monocarp')\n", "n = int(input())\ns = input()\nr, delta = 0, 0\n\nfor i in range(n // 2):\n    if s[i] == '?':\n        r += 1\n    else:\n        delta += int(s[i])\nfor i in range(n // 2, n):\n    if s[i] == '?':\n        r -= 1\n    else:\n        delta -= int(s[i])\n\nif r < 0:\n    r = -r\n    delta = -delta\n\nif delta + 9 * r // 2 == 0:\n    print('Bicarp')\nelse:\n    print('Monocarp')", "n = int(input())\ns = input()\ns1 = s[:n//2]\ns2 = s[n//2:]\nsum1 = sum(map(int, filter(str.isdigit, s1)))\nsum2 = sum(map(int, filter(str.isdigit, s2)))\nfree1 = s1.count(\"?\")\nfree2 = s2.count(\"?\")\nans = \"\"\nif free1 == free2:\n    if sum1 == sum2:\n        ans = \"Bicarp\"\n    else:\n        ans = \"Monocarp\"\nelse:\n    if sum1 > sum2:\n        free1, free2 = free2, free1\n        sum1, sum2 = sum2, sum1\n    if free1 <= free2:\n        ans = \"Monocarp\"\n    else:\n        if (free1 - free2) // 2 * 9 == sum2 - sum1:\n            ans = \"Bicarp\"\n        else:\n            ans = \"Monocarp\"\nprint(ans)", " \n\nn=int(input())\ninp=input()\nsl,sr,qr,ql=0,0,0,0\n\n\nfor i in range(len(inp)//2):\n    if inp[i]=='?':\n        ql+=1\n    else:\n        sl+=int(inp[i])\n\nfor i in range(n//2, n):\n    if inp[i]=='?':\n        qr+=1\n    else:\n        sr+=int(inp[i])\n\n\n\nif(sl-sr==9*(qr-ql)/2):\n    print('Bicarp')\nelse:\n    print('Monocarp')\n", "n=int(input())\nticket=input()\nleft=right=diff=0\nfor i in range(n//2):\n    if ticket[i] == '?':\n        left += 1\n    else:\n        diff += int(ticket[i])\nfor i in range(n//2,n):\n    if ticket[i] == '?':\n        right += 1\n    else:\n        diff -= int(ticket[i])\n\nif left > right:\n    temp = left\n    left = right\n    right = temp\n    diff = -diff\n\nbad = ((right-left)//2)*9\nif diff == bad:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")\n", "import math\nimport sys\nimport collections\n\n\n# imgur.com/Pkt7iIf.png\n\ndef getdict(n):\n    d = {}\n    if type(n) is list:\n        for i in n:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n    else:\n        for i in range(n):\n            t = ii()\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n    return d\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = prime[1] = False\n    r = [p for p in range(n + 1) if prime[p]]\n    return r\ndef cdiv(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep = ' '): print(sep.join(map(str, a)))\n\nn = ii()\ns = input()\nl = r = tl = tr = 0\nfor i in s[:n//2]:\n    if i == '?':\n        tl+=1\n    else:\n        l += int(i)\nfor i in s[n//2:]:\n    if i == '?':\n        tr+=1\n    else:\n        r += int(i)\n\nif tl == tr == 0:\n    print('Bicarp') if l == r else print('Monocarp')\n    return\n\nif l + cdiv(tl, 2)*9 - r > cdiv(tr, 2)*9 or r + cdiv(tr, 2)*9 - l > cdiv(tl, 2)*9:\n    print('Monocarp')\nelse:\n    print('Bicarp')", "n = int(input())\nx = input()\n\ndef f(x):\n    q, s = 0, 0\n    for c in x:\n        if c == '?':\n            q += 1\n        else:\n            s += int(c)\n    return q, s\n\nlq, ls = f(x[:n//2])\nrq, rs = f(x[n//2:])\n\nlmin = ls\nlmax = ls + 9*lq\n\nrmin = rs\nrmax = rs + 9*rq\n\nlc = lmin+lmax\nrc = rmin+rmax\n\nif lc == rc and (lq+rq)%2 == 0:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n                (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    st = list(stdin.readline().strip())\n    ls,rs,lq,rq=0,0,0,0\n    for i in range(n//2):\n        if st[i]=='?':\n            lq+=1\n        else:\n            ls+=int(st[i])\n    for i in range(n//2,n):\n        if st[i]=='?':\n            rq+=1\n        else:\n            rs+=int(st[i])\n    if (lq+rq)%2==0 and ((lq-rq)//2)*9 + ls == rs:\n        print(\"Bicarp\")\n    else:\n        print(\"Monocarp\")\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "N = int(input())\nL = 0\nR = 0\nlq = 0\nrq = 0\nTK = input()\n\nfor i in range(N//2):\n    if TK[i] == '?':\n        lq += 1\n    else:\n        L += int(TK[i])\n\nfor i in range(N//2, N):\n    if TK[i] == '?':\n        rq += 1\n    else:\n        R += int(TK[i])\n\nif lq == rq:\n    if L == R:\n        print('Bicarp')\n    else:\n        print('Monocarp')\n\nt = abs(lq - rq)\n\nif lq > rq:\n    R -= L\n    if R < 0:\n        print('Monocarp')\n    else:\n        if (t//2) * 9 == R:\n            print('Bicarp')\n        else:\n            print('Monocarp')\n\nif lq < rq:\n    L -= R\n    if L < 0:\n        print('Monocarp')\n    else:\n        if (t // 2) * 9 == L:\n            print('Bicarp')\n        else:\n            print('Monocarp')", "n = int(input())\ns = input()\n\nlsum = lcount = rsum = rcount = 0\nfor ch in s[:n//2]:\n    if ch == '?':\n        lcount += 1\n    else:\n        lsum += int(ch)\n\nfor ch in s[n//2:]:\n    if ch == '?':\n        rcount += 1\n    else:\n        rsum += int(ch)\n\nif lcount > rcount:\n    delta = rsum - lsum\n    count = lcount - rcount\nelse:\n    delta = lsum - rsum\n    count = rcount - lcount\nif delta == (count//2)*9:\n    print('Bicarp')\nelse:\n    print('Monocarp')", "n = int(input())\ns = input()\nfer = 0\nf = 0\nl = 0\nler = 0\nfor i in range(int(n/2)):\n    if s[i] == '?':\n        fer += 1\n    else:\n        f += int(s[i])\nfor i in range(int(n/2),n):\n    if s[i] == '?':\n        ler += 1\n    else:\n        l += int(s[i])\nif (fer + ler) %2:\n    print('Monocarp')\nelse:\n    if f < l:\n        if l-f == 9*((fer-ler)/2):\n            print('Bicarp')\n        else:\n            print('Monocarp')\n    else:\n        if f-l == 9*((ler-fer)/2):\n            print('Bicarp')\n        else:\n            print('Monocarp')", "n = int(input())\ns = input()\np1 = 0\np2 = 0\ns1 = 0\ns2 = 0\nfor i in s[:n // 2]:\n    if i == '?':\n        p1 += 1\n    else:\n        s1 += int(i)\n        \nfor i in s[n // 2:]:\n    if i == '?':\n        p2 += 1\n    else:\n        s2 += int(i)\nif s1 < s2:\n    buf = p1\n    p1 = p2\n    p2 = buf\n    buf = s1\n    s1 = s2\n    s2 = buf\nif p1 > p2:\n    print('Monocarp')\nelse:\n    p = abs(p1 - p2)\n    ss = abs(s1 - s2)\n    if ss == (p // 2) * 9:\n        print('Bicarp')\n    else:\n        print('Monocarp')\n", "I = lambda : int(input())\nSI = lambda : input()\nM = \"Monocarp\"; B = \"Bicarp\"\ndef solve(n,s):\n\tlsum = 0\n\tcl = 0\n\trsum = 0\n\tcr = 0\n\n\tfor i in range(n//2):\n\t\tif(s[i]=='?'):\n\t\t\tcl+=1\n\t\telse:\n\t\t\tlsum+=int(s[i])\n\n\tfor i in range(n//2,n):\n\t\tif(s[i]=='?'):\n\t\t\tcr+=1\n\t\telse:\n\t\t\trsum+=int(s[i])\n\n\tdif = lsum-rsum\n\tif(dif==0):\n\t\tif(cl==cr):print(B)\n\t\telse: print(M)\n\t\treturn\n\tif(cl==cr):\n\t\tprint(M)\n\t\treturn\n\tif((dif>0 and cl>cr) or (dif<0 and cl<cr)):\n\t\tprint(M)\n\t\treturn\n\n\t#Casos dif<0 y cl>cr\n\tif(dif>0):\n\t\tdif= -dif\n\t\tcl,cr = cr,cl\n\tdifc = cl-cr \n\tif(dif+difc//2*9==0):\n\t\tprint(B)\n\telse:\n\t\tprint(M)\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\nn = I()\ns = SI()\nsolve(n,s)", "n=int(input())\narr=input()\nlsum=0\nrsum=0\nlq=0\nrq=0\nfor i in range(n//2):\n    if(arr[i]=='?'):\n        lq+=1\n    else:\n        lsum+=int(arr[i])\n\nfor i in range(n//2,n):\n    if(arr[i]=='?'):\n        rq+=1\n    else:\n        rsum+=int(arr[i])\n#if(lsum==rsum and lq==rq):\n#    print(\"Bicarp\")\nif((lq+rq)%2==1):\n    print(\"Monocarp\")\nelif((lsum-rsum)//9==(rq-lq)//2 and (lsum-rsum)%9==0):\n    print(\"Bicarp\")\nelif((rsum-lsum)//9==(lq-rq)//2 and (rsum-lsum)%9==0):\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")\n    \n    \n    \n", "n = int(input())\na, b1, b2 = [], [], []\n\nfor i, j in enumerate(input()):\n\tif j == '?':\n\t\tif i < n // 2:\n\t\t\tb1.append(i)\n\t\telse:\n\t\t\tb2.append(i)\n\t\ta.append(0)\n\telse:\n\t\ta.append(int(j))\n\n\ns1 = sum(a[:n // 2])\ns2 = sum(a[n // 2:])\n\n\nprint('Bicarp' if s1 + 9 * (len(b1) + 1) // 2 == s2 + 9 * (len(b2) + 1) // 2 else 'Monocarp')", "def winner(s, n):\n    s1 = s[:n//2]\n    s2 = s[n//2:]\n    turns = s.count('?') // 2\n    l1 = r1 = l2 = r2 = 0\n    for c in s1:\n        if c == '?':\n            r1 += 9\n        else:\n            l1 += int(c)\n            r1 += int(c)\n    for c in s2:\n        if c == '?':\n            r2 += 9\n        else:\n            l2 += int(c)\n            r2 += int(c)\n    if r1 < l2 or r2 < l1:\n        return 'True'\n    minDif = min(r1 - l2, r2 - l1)\n    return minDif < turns * 9\n\n\nn = int(input())\ns = input()\nprint('Monocarp' if winner(s, n) else 'Bicarp')\n", "o = input()\ninp = input()\ncount_1 = 0\nsum_1 = 0\ncount_2 = 0\nsum_2 = 0\nfor i in range(len(inp)//2):\n    if inp[i] == '?':\n        count_1 += 1\n    else:\n        sum_1 += int(inp[i])\n        \nfor j in range(len(inp)//2):\n    i = len(inp) // 2 + j\n    if inp[i] == '?':\n        count_2 += 1\n    else:\n        sum_2 += int(inp[i])\n\n# print(count_1, sum_1, count_2, sum_2)\nif sum_2-sum_1 == 9*(count_1-count_2)//2:\n    print('Bicarp')\nelse:\n    print('Monocarp')\n", "n=int(input())\n\ns=input()\n\nsum1=0\nkol1=0\nsum2=0\nkol2=0\n\nfor i in range(n//2):\n    if s[i]=='?':\n        kol1+=1\n    else:\n        sum1+=int(s[i])\n\nfor i in range(n//2,n):\n    if s[i]=='?':\n        kol2+=1\n    else:\n        sum2+=int(s[i])\n\nif sum1>sum2:\n    sum1,sum2,kol1,kol2=sum2,sum1,kol2,kol1\n\n\n\nif sum1==sum2 and kol1==kol2:\n    print('Bicarp')\nelif sum1==sum2 and kol1!=kol2:\n    print('Monocarp')\nelif (sum2-sum1)%9!=0:\n    print('Monocarp')\nelif kol1==kol2==0:\n    print('Monocarp')\nelif (sum2-sum1)//9==(kol1-kol2)//2:\n    print('Bicarp')\nelse:\n    print('Monocarp')\n", "#585_D\n\nn = int(input())\n\nln = list(input())\n\nsm1 = 0\nsm2 = 0\nqs1 = 0\nqs2 = 0\n\nfor i in range(0, n // 2):\n    if ln[i] != \"?\":\n        qs1 += 1\n        sm1 += int(ln[i])\n    if ln[n // 2 + i] != \"?\":\n        qs2 += 1\n        sm2 += int(ln[n // 2 + i])\n\nqs1 = n // 2 - qs1\nqs2 = n // 2 - qs2\nqs = qs1 + qs2\n\nm = False\n\nif not qs:\n    if sm1 != sm2:\n        m = True\n\nmx = sm1 + min(qs1, qs // 2) * 9\nlft = min(qs2, qs2 - ((qs // 2) - qs1))\nif mx > lft * 9 + sm2:\n    m = True\n\nmx = sm2 + min(qs2, qs // 2) * 9\nlft = min(qs1, qs1 - ((qs // 2) - qs2))\nif mx > lft * 9 + sm1:\n    m = True\n\nif m:\n    print(\"Monocarp\")\nelse:\n    print(\"Bicarp\")\n", "n = int(input())\ns = input()\n\nsd = 0\nqd = 0\n\nfor i in range(n // 2):\n    if s[i] == '?':\n        qd += 1\n    else:\n        sd += int(s[i])\n\n    if s[n // 2 + i] == '?':\n        qd -= 1\n    else:\n        sd -= int(s[n // 2 + i])\n\nif abs(sd) % 9 > 0:\n    print(\"Monocarp\")\n    return\n\nif sd >= 0:\n    qd += 2 * (sd // 9 + (1 if sd % 9 > 0 else 0))\nelse:\n    sd = -1 * sd\n    qd -= 2 * (sd // 9 + (1 if sd % 9 > 0 else 0))\n\nprint(\"Bicarp\" if qd == 0 else \"Monocarp\")"]
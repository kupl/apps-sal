["import sys\nfrom math import ceil\n\nn, m, k = list(map(int, sys.stdin.readline().split()))\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n\nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n\nbest_cost = float('inf')\nfor lamp in range(k, 0, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n\n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n\n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n\n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n\n    if not fail:\n        best_cost = min(best_cost, cost)\n\nprint(best_cost if best_cost != float('inf') else -1)\n", "import sys\nfrom math import ceil\n\nn, m, k = list(map(int, sys.stdin.readline().split()))\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n\nlongest_streak = 0\nstreak = 0\nfor p in places:\n    if not p:\n        streak += 1\n    else:\n        longest_streak = max(longest_streak, streak)\n        streak = 0\nlongest_streak = max(streak, longest_streak)\n\nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n\nbest_cost = float('inf')\nfor lamp in range(k, longest_streak, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n\n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n\n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n\n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n\n    if not fail:\n        best_cost = min(best_cost, cost)\n\nprint(best_cost if best_cost != float('inf') else -1)\n", "import sys\nfrom math import ceil\n\nn, m, k = map(int, sys.stdin.readline().split())\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n\nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n\nbest_cost = float('inf')\nfor lamp in range(k, 0, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n\n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n\n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n\n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n\n    if not fail:\n        best_cost = min(best_cost, cost)\n\nprint(best_cost if best_cost != float('inf') else -1)", "def i_ints():\n    return list(map(int, input().split()))\n\n\ndef next_free_from_blocks(n, blocks):\n    \"\"\" n : pos ranges from 0 to n-1\n        blocks: sorted list of blocked positions\n        \n        return a list that maps each position to the next higher non-blocked position\n    \"\"\"\n    m = 0\n    res = list(range(n+1))\n    for i in reversed(blocks):\n        res[i] = res[i+1]\n        if res[i] - i > m:\n            m = res[i] - i\n    return res, m\n    \n\n#############\n\nn, m, k = i_ints()\n\nblocks = i_ints()\ncosts = i_ints()\n\n\nnext_free, max_block_len = next_free_from_blocks(n, blocks)\nblocks.append(n+1)\nif m == 0:\n    max_block_len = 0\nif max_block_len >= k or blocks[0] == 0:\n    print(-1)\nelse:\n    minimal_costs = [c * ((n+l-1)//l) for l, c in enumerate(costs, 1)]\n    maximal_costs = [c * 2 * ((n+l)//(l+1)) for l, c in enumerate(costs, 1)]\n    max_costs = min(maximal_costs[max_block_len:])\n    \n    possible = [i+1 for i in range(max_block_len, k) if minimal_costs[i] <= max_costs]\n    for i in range(len(possible)-1)[::-1]:\n        if costs[possible[i]-1] > costs[possible[i+1]-1]:\n            del possible[i]\n    \n    def calc(l):\n        \"\"\" for strength l, calculate  number of lamps needed \"\"\"\n        count = 1\n        pos = n-l\n        while pos > 0:\n            pos = next_free[pos] - l\n            count += 1\n        return count\n    \n    \n    print(min(calc(l) * costs[l-1] for l in possible))\n", "import sys\n\nn, m, k = list(map(int, input().split()))\ns = list(map(int, sys.stdin.readline().split()))  # [int(x) for x in input().split()]  # blocked\na = list(map(int, sys.stdin.readline().split()))  # a = [int(x) for x in input().split()]  # cost\n\nif m > 0 and s[0] == 0:\n    print('-1')\nelse:\n\n    block = [-1] * n  # -1 free, otherwise index of a free one\n    for i in range(m):\n        if block[s[i]-1] == -1:\n            block[s[i]] = s[i]-1\n        else:\n            block[s[i]] = block[s[i]-1]\n\n    MAX_COST = 1e13\n    max_inr = 0\n    if m > 0:\n        inr = 1\n        prev = s[0]\n        for i in range(1, m):\n            if s[i] == prev+1:\n                inr += 1\n            else:\n                if inr > max_inr:\n                    max_inr = inr\n                inr = 1\n            prev = s[i]\n        if inr > max_inr:\n            max_inr = inr\n    best_cost = []\n    for i in range(k):\n        if i < max_inr:\n            best_cost.append(MAX_COST)\n        else:\n            best_cost.append(a[i]*(-(-n//(i+1))))\n    #sc = sorted(range(k), key=lambda x: best_cost[x])\n   # sc = sorted(range(k), key=best_cost.__getitem__)\n    min_cost = MAX_COST\n    for i in range(k):\n        test = i  # min(range(len(best_cost)), key=best_cost.__getitem__)\n        if best_cost[test] >= min_cost:\n            continue\n        #  if best_cost[test] >= min_cost or best_cost[test] >= MAX_COST:\n        #    break\n        t_size = test+1\n        pos = 0\n        count = 1\n        while pos < n:\n            new_pos = pos + t_size\n            if new_pos >= n:\n                break\n            if block[new_pos] != -1:\n                if block[new_pos] <= pos:\n                    raise Exception('smth went wrong')\n                new_pos = block[new_pos]\n            pos = new_pos\n            count += 1\n        min_cost = min(min_cost, a[test]*count)\n    if min_cost < MAX_COST:\n        print(min_cost)\n    else:\n        print('-1')\n\n\n", "import sys\nfrom sys import stdin,stdout\nn,m,k=list(map(int,stdin.readline().split(' ')))\nt22=stdin.readline()#;print(t22,\"t2222\")\nbl=[]\nif len(t22.strip())==0:\n  bl=[]\nelse:\n  bl=list(map(int,t22.split(' ')))\nbd={}\nfor i in bl:\n  bd[i]=1\ncost=list(map(int,stdin.readline().split(' ')))\ndp=[-1 for i in range(n)]\ndp[0]=0\n\ndef formdp():\n  nonlocal dp\n  for i in range(1,n):\n    if i in bd:\n      t1=i\n      while dp[t1]==-1:\n        t1-=1\n      dp[i]=dp[t1]\n    else:\n      dp[i]=i\n    \n\ndef get(i):\n  #print(\"\\t\",i)\n  f=1;p=0\n  while p+i<n:\n    if dp[p+i]==p:\n      return -1\n    else:\n      p=dp[p+i];f+=1\n    #print(p,f)\n  return f\nif True:\n  if 0 in bd:\n    print(-1)\n  else:\n    formdp()\n    #print(dp)\n    minf=[0 for i in range(k+1)]\n    for i in range(1,k+1):\n      minf[i]=get(i)\n    #print(minf)\n    ans=-1\n\n    for i in range(1,len(minf)):\n      if minf[i]!=-1:\n        if ans==-1:\n          ans=minf[i]*cost[i-1]\n        else:\n          ans=min(ans,minf[i]*cost[i-1])\n    if ans==-1:\n      print(-1)\n    else:\n      print(ans)\n#except Exception as e:\n#  print(e)\n#print(sys.maxsize)\n", "n, m, k = map(int, input().split())\nfree = [True] * n\nfor i in list(map(int, input().split())):\n    free[i] = False\na = list(map(int, input().split()))\nlast_lamp = [-1] * n\nfor i in range(n):\n    if free[i]:\n        last_lamp[i] = i\n    if i > 0 and not free[i]:\n        last_lamp[i] = last_lamp[i - 1]\nans = int(1E100)\nfor i in range(1, k + 1):\n    last, prev = 0, -1\n    cur = 0\n    while last < n:\n        if last_lamp[last] <= prev:\n            cur = None\n            break\n        prev = last_lamp[last]\n        last = prev + i\n        cur += 1\n    if cur is not None:\n        ans = min(ans, a[i - 1] * cur)\nif ans == int(1E100):\n    print(-1)\nelse:\n    print(ans)", "import sys\nfrom math import ceil\n \nn, t, k = list(map(int, sys.stdin.readline().split()))\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n \nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n \nbest_cost = float('inf')\nfor lamp in range(k, 0, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n \n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n \n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n \n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n \n    if not fail:\n        best_cost = min(best_cost, cost)\n \nprint(best_cost if best_cost != float('inf') else -1)\n", "import sys\nfrom math import ceil\n \nn, l, k = list(map(int, sys.stdin.readline().split()))\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n \nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n \nbest_cost = float('inf')\nfor lamp in range(k, 0, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n \n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n \n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n \n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n \n    if not fail:\n        best_cost = min(best_cost, cost)\n \nprint(best_cost if best_cost != float('inf') else -1)\n", "import sys\nfrom array import array\n\nn, m, k = list(map(int, input().split()))\nblock = list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\n\nif block and block[0] == 0:\n    print(-1)\n    return\n\nprev = array('i', list(range(n)))\nfor x in block:\n    prev[x] = -1\n\nfor i in range(1, n):\n    if prev[i] == -1:\n        prev[i] = prev[i-1]\n\ninf = ans = 10**18\n\nfor i in range(1, k+1):\n    s = 0\n    cost = 0\n    while True:\n        cost += a[i]\n        t = s+i\n\n        if t >= n:\n            break\n        if prev[t] == s:\n            cost = inf\n            break\n        s = prev[t]\n\n    ans = min(ans, cost)\n\nprint(ans if ans < inf else -1)\n"]
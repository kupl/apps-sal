["#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, X: \"List[int]\", Y: \"List[int]\", Z: \"List[int]\"):\n    X = [x-1 for x in X]\n    Y = [x-1 for x in Y]\n    uf = UnionFind(N)\n    for x, y in zip(X, Y):\n        uf.union(x, y)\n    return len(uf.roots())\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    X = [int()] * (M)  # type: \"List[int]\"\n    Y = [int()] * (M)  # type: \"List[int]\"\n    Z = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        X[i] = int(next(tokens))\n        Y[i] = int(next(tokens))\n        Z[i] = int(next(tokens))\n    print((solve(N, M, X, Y, Z)))\n\n# https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n        \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nceil = math.ceil\nclass unionfind():\n    def __init__(self,n):\n        self.n = n\n        self.par = list(range(n))\n        self.size = [1]*n\n        self.rank = [0]*n\n\n    def root(self,x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def same(self,x,y):\n        return self.root(x) == self.root(y)\n\n    def unite(self,x,y):\n        x = self.root(x)\n        y = self.root(y)\n        if x==y:return\n        else:\n            if self.rank[x] < self.rank[y]:\n                 x,y = y,x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x]+=1\n            self.par[y] = x\n            self.size[x] +=self.size[y]\n    def get_size(self,x):\n        x = self.root(x)\n        return self.size[x]\n    def parent_set(self):\n        for x in range(self.n):\n            self.root(x)\n        s = set()\n        for par in self.par:\n            s.add(par)\n        return s\nn,m = ma()\nuf = unionfind(n)\nfor i in range(m):\n    x,y,z = ma()\n    uf.unite(x-1,y-1)\ns = uf.parent_set()\nprint(len(s))\n", "class UnionFind():\n    '''\n    cited from https://note.nkmk.me/python-union-find/\n    '''\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\nN, M = list(map(int, input().split()))\n\nu = UnionFind(N)\nfor i in range(M):\n    x, y, z = list(map(int, input().split()))\n    u.union(x-1,y-1)\n    \nprint((u.group_count()))\n\n", "import sys\n\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    \"\"\"Union Find class.\n\n    \"Path compression\" and \"Union by rank\" are used.\n\n    References:\n        <https://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n    \"\"\"\n\n    def __init__(self, N):\n        self.N = N\n        self.__make_set()\n\n    def __make_set(self):\n        self._parent = list(range(self.N + 1))\n        self._rank = [0] * (self.N + 1)\n        self._size = [1] * (self.N + 1)\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n\n        if x_root == y_root:\n            return\n\n        x_rank = self._rank[x_root]\n        y_rank = self._rank[y_root]\n        if x_rank > y_rank:\n            self._parent[y_root] = x_root\n            self._size[x_root] += self._size[y_root]\n        elif x_rank < y_rank:\n            self._parent[x_root] = y_root\n            self._size[y_root] += self._size[x_root]\n        else:\n            self._parent[y_root] = x_root\n            self._rank[x_root] += 1\n            self._size[x_root] += self._size[y_root]\n\n    def same_set(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self._size[self.find(x)]\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    uf = UnionFind(N)\n    for _ in range(M):\n        X, Y, _ = list(map(int, input().split()))\n        uf.union(X, Y)\n\n    s = set()\n    for i in range(1, N + 1):\n        s.add(uf.find(i))\n\n    ans = len(s)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=map(int,input().split())\na=[list(map(int,input().split())) for i in range(m)]\nu=UnionFind(n)\nfor i in range(m):\n    u.union(a[i][0]-1,a[i][1]-1)\nprint(u.group_count())", "N, M = list(map(int,input().split()))\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 1\n    par[x] = y\n    size[y] += size[x]\n    size[x] = 0\n\nfor i in range(M):\n    x, y, z= list(map(int,input().split()))\n    unite(x,y)\n\nAns = 0\nfor j in size[1:]:\n    if j != 0:\n        Ans += 1\nprint(Ans)\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    G = collections.defaultdict(list)\n    for _ in range(M):\n        X, Y, _ = LI_()\n        G[X].append(Y)\n        G[Y].append(X)\n\n    # A_XtoA_Y\u306f\u7247\u65b9\u304c\u6c7a\u307e\u308c\u3070\u3082\u3046\u7247\u65b9\u3082\u6c7a\u307e\u308b \u3088\u3063\u3066\u9023\u7d50\u6210\u5206\u6570\u304c\u7b54\u3048\n    visited = [False] * N\n    def dfs(c):\n        visited[c] = True\n        for n in G[c]:\n            if not visited[n]:\n                dfs(n)\n\n    ans = [0]\n    for i in range(N):\n        if not visited[i]:\n            dfs(i)\n            ans[0] += 1\n\n    print((ans[0]))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N, M = list(map(int,input().split()))\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] += size[x]\n    size[x] = 0\n\nfor i in range(M):\n    x, y, z= list(map(int,input().split()))\n    unite(x,y)\n\nAns = 0\nfor j in size[1:]:\n    if j != 0:\n        Ans +=1\nprint(Ans)\n", "N, M = map(int,input().split())\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] = size[x] + size[y]\n    size[x] = 0\n    \nfor i in range(M):\n    x, y,  z= map(int,input().split())\n    unite(x,y)\n    \nAns =0\nfor j in size[1:]:\n    if j != 0:\n        Ans +=1\nprint(Ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\nfor _ in range(M):\n    X, Y, Z = map(lambda x: int(x)-1, input().split())\n    uf.union(X, Y)\nprint(len(uf.roots()))", "N,M=list(map(int,input().split()))\nroot=[i for i in range(N)]\nheight=[0]*N\ndef find(a):\n   f=a\n   if a==root[a]:\n      return a\n   while a!=root[a]:\n      a=root[a]\n   root[f]=a\n   return a\ndef union(a,b):\n   A=find(a)\n   B=find(b)\n   if A==B:\n      return\n   if height[A]>height[B]:\n      root[B]=root[A]\n   else:\n      root[A]=root[B]\n      if height[A]==height[B]:\n         height[B]+=1\n\nfor i in range(M):\n   a,b,c=map(int,input().split())\n   a-=1;b-=1\n   union(a,b)\nl=[0]*N\nfor j in range(N):\n   l[find(j)]+=1\nprint(N-l.count(0))", "def abc126_e():\n    n, m = map(int, input().split())\n    par = [x for x in range(n)]\n    rank = [0]*n\n\n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            return par[x]\n\n    def unite(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y: return\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]: rank[x] += 1\n\n    for _ in range(m):\n        x, y, z = map(int, input().split())\n        unite(x-1, y-1)\n\n    for i in range(n):\n        _ = find(i)\n\n    ans = len(set(par))\n    print(ans)\n\ndef __starting_point():\n    abc126_e()\n__starting_point()", "#import sys\nMOD = 10 ** 9 + 7\nINFI = 10**10\n#input = sys.stdin.readline\nimport math\nfrom collections import deque\nimport itertools\nimport heapq\n#import bisect\nfrom fractions import Fraction\nimport copy\nfrom functools import lru_cache\nfrom collections import defaultdict\nimport pprint\n\n#oo=list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n# ko=list(\"abcdefghijklmnopqrstuvwxyz\")\n\ndef sosuhante(n):\n    for k in range(2, int(math.sqrt(n))+1):\n        if n% k ==0:\n            return False\n    return True\ndef cmb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2,r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1,r,p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\ndef kingaku(a,b,n):\n    keta=len(str(n))\n    return a*n+b*keta\n\ndef my_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\n#    h,w,a,b = map(int, input().split())\n#    c = [[0 for j in range(n)] for i in range(n)]\n\ndef ret(a):\n    c=[None]*(len(a)-1)\n    if len(a)==1:\n        return a[0]\n    elif len(a)==0:\n        return 0\n    for i in range(1,len(a)):\n        c[i-1]=abs(a[i]-a[i-1])\n    return ret(c)\n\ndef soinsubunkai(n):\n    a = []\n    i = 1\n    while i*i <= n:\n        if n % i == 0 and i!=1:\n            a.append(i)\n            n=n//i\n\n        if n% i !=0 or i==1:\n            i += 1\n    nokori=[n]\n    return a + nokori\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\ndef main():\n    n,m=map(int,input().split())\n    graph=[[] for _ in range(n+1)]\n    for i in range(m):\n        a,b,c=map(int,input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    stack=[]\n    visited=[0 for _ in range(n+1)]\n\n    zones=0\n    count=0\n    def DFS():\n        c=1\n        while True:\n            if len(stack)==0:\n                break\n            s=stack.pop()\n            if visited[s]==0:\n                for i in graph[s]:\n                    if visited[i]==0:\n                        stack.append(i)\n\n                visited[s]=1\n                c+=1\n            if len(stack)==0:\n                break\n        return c\n    for i in range(1,n+1):\n        if visited[i]==0:\n            visited[i]=1\n            for j in graph[i]:\n                stack.append(j)\n            if len(stack)>0:\n                count+=DFS()\n                zones += 1\n        else:\n            continue\n\n#    print(n,count,zones)\n    print(n-count+zones)\n\n\n\n\n\ndef __starting_point():\n\n    main()\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*n\n        self.rank = [0]*n\n\n    def find(self, x):\n        if self.root[x-1] < 0:\n            return x\n        else:\n            self.root[x-1] = self.find(self.root[x-1])\n            return self.root[x-1]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x==y:\n            return\n        elif self.rank[x-1] > self.rank[y-1]:\n            self.root[x-1] += self.root[y-1]\n            self.root[y-1] = x\n        else:\n            self.root[y-1] += self.root[x-1]\n            self.root[x-1] = y\n            if self.rank[x-1] == self.rank[y-1]:\n                self.rank[y-1] += 1\n\n    def same(self, x, y):\n        return self.find(x)==self.find(y)\n\n    def count(self, x):\n        return -self.root[self.find(x)-1]\n\nN,M=map(int,input().split())\nuf=UnionFind(N)\nfor i in range(M):\n    x,y,z=map(int,input().split())\n    uf.unite(x,y)\ns=set()\nans=0\nfor i in range(1,N+1):\n    if uf.find(i) not in s:\n        s.add(uf.find(i))\n        ans+=1\nprint(ans)", "n,m = map(int,input().split())\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * (n)\n        self.size = [1] * (n)\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n    def all_find(self):\n        for n in range(len(self.par)):\n            self.find(n)\n\nuf = UnionFind(n)\n\nfor _ in range(m):\n    x,y,z = map(int,input().split())\n    x -= 1\n    y -= 1\n    uf.union(x,y)\n\nroot = set([])\n\nfor i in range(n):\n    root.add(uf.find(i))\n\nprint(len(root))", "# UnionFind: https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * (n + 1)\n        \n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.root[x] > self.root[y]:\n            x, y = y, x\n        self.root[x] += self.root[y]\n        self.root[y] = x\n        \n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def size(self, x):\n        return -self.root[self.find(x)]\n\nn, m = map(int, input().split())\ncards = UnionFind(n)\nfor i in range(m):\n    x, y, z = map(int, input().split())\n    cards.unite(x, y)\nprint(len({i + 1 for i in range(n) if cards.root[i + 1] < 0}))", "import heapq\nimport sys\nsys.setrecursionlimit(10**8)\nn, m = map(int, input().split())\nc = [0] * n\ng = [[] for i in range(n)]\nrevealed = [False] * n\nrn = 0\n\nfor i in range(m):\n    x, y, z = map(int, input().split())\n    x-=1; y-=1\n    c[x]+=1\n    c[y]+=1\n    g[y].append(x)\n    g[x].append(y)\n\nhq = [(c[i], i) for i in range(n)]\nheapq.heapify(hq)\n\ndef dfs(src):\n    nonlocal rn\n    rn += 1\n    revealed[src] = True\n    for nxt in g[src]:\n        if not revealed[nxt]:\n            dfs(nxt)\n\nans = 0\nwhile rn < n:\n    _, now = heapq.heappop(hq)\n    if revealed[now]: continue\n    revealed[now] = True\n    ans += 1\n    dfs(now)\nprint(ans)", "N, M = map(int,input().split())\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] = size[x] + size[y]\n    size[x] = 0\nfor i in range(M):\n    x, y,  z= map(int,input().split())\n    unite(x,y)\nAns =0\nfor j in size[1:]:\n    if j != 0:\n        Ans +=1\nprint(Ans)", "import sys;sys.setrecursionlimit(10**9)\nclass UnionFind:\n  def __init__(self,n):\n    self.n=[-1]*n\n    self.r=[0]*n\n    self.siz=n\n  def find_root(self,x):\n    if self.n[x]<0:\n      return x\n    else:\n      self.n[x]=self.find_root(self.n[x])\n      return self.n[x]\n  def unite(self,x,y):\n    x=self.find_root(x)\n    y=self.find_root(y)\n    if x==y:return\n    elif self.r[x]>self.r[y]:\n      self.n[x]+=self.n[y]\n      self.n[y]=x\n    else:\n      self.n[y]+=self.n[x]\n      self.n[x]=y\n      if self.r[x]==self.r[y]:\n        self.r[y]+=1\n    self.siz-=1\n  def root_same(self,x,y):\n    return self.find_root(x)==self.find_root(y)\n  def count(self,x):\n    return -self.n[self.find_root(x)]\n  def size(self):\n    return self.siz\n\nn,m=map(int,input().split())\nuf=UnionFind(n)\nfor i in range(m):\n  x,y,z=map(int,input().split())\n  uf.unite(x-1,y-1)\nprint(uf.size())", "class UnionFind(object):\n    def __init__(self, size):\n        self.parent = [i for i in range(size)]\n        self.rank = [0]*size    \n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\nN,M = map(int,input().split())\nuf = UnionFind(N)\nfor _ in range(M):\n    x,y,z = map(int,input().split())\n    uf.unite(x-1,y-1)\nfor i in range(N):\n    uf.find(i-1)\ns = set(uf.parent)\nprint(len(s))", "n,m=map(int,input().split())\nxy=[[] for _ in range(n+1)]\nfor _ in range(m):\n    x,y,z=map(int,input().split())\n    xy[x].append(y)\n    xy[y].append(x)\n\nfrom collections import deque\n\nvisited=[0]*(n+1)\ncount=0\n\nfor i in range(1,n+1):\n    if visited[i]==0:\n        stack=deque()\n        stack.append(i)\n        visited[i]+=1\n        while stack:\n            a=stack.pop()\n            for j in xy[a]:\n                if visited[j]==0:\n                    visited[j]+=1\n                    stack.append(j)\n        count+=1\nprint(count)", "def find(x): #\u8981\u7d20\u304c\u3069\u306e\u96c6\u5408\u304b\u5224\u65ad\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y): #\u96c6\u5408\u306b\u7d50\u5408\n    x = find(x)\n    y = find(y)\n    if x == y: return False\n    if par[x] > par[y]: x,y = y,x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\nimport bisect\nn, m = map(int, input().split())\npar = [-1]*n\n\nfor _ in range(m):\n    x, y, z = map(int, input().split())\n    unite(x-1, y-1)\npar.sort()\nprint(bisect.bisect_left(par, 0))", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# \u554f\u984c\uff1ahttps://atcoder.jp/contests/abc126/tasks/abc126_e\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nclass Graph():\n\n    def __init__(self):\n        self.adjacency_dict = {}\n    \n    def add_vertex(self, v):\n        self.adjacency_dict[v] = []\n\n    def add_edge(self, v1, v2):\n        self.adjacency_dict[v1].append(v2)\n        self.adjacency_dict[v2].append(v1)\n\n    def remove_edge(self, v1, v2):\n        self.adjacency_dict[v1].remove(v2)\n        self.adjacency_dict[v2].remove(v1)\n\n    def remove_vertex(self,v):\n        while self.adjacency_dict[v] != []:\n            adjacency_vertex = self.adjacency_dict[v][-1]\n            self.remove_edge(v, adjacency_vertex)\n        del adjacency_vertex[v]\n\n    def get_vertexes(self):\n        return list(self.adjacency_dict.keys())\n\n    def get_edges(self, v):\n        return self.adjacency_dict[v]\n\n    def print_graph(self):\n        print((self.adjacency_dict))\n\n\nn, m = list(map(int, input().strip().split()))\nxyz = [list(map(int, input().strip().split())) for _ in range(m)]\n\ng = Graph()\nfor i in range(n):\n    g.add_vertex(i)\nfor i in range(m):\n    g.add_edge(xyz[i][0]-1, xyz[i][1]-1)\n\nres = 0\nreached_nodes = [0 for _ in range(n)]\nfor i in g.get_vertexes():\n    if reached_nodes[i] == 1:\n        continue\n    res += 1\n    reached_nodes[i] = 1\n    q = [i]\n    while len(q) > 0:\n        u = q.pop()\n        for v in g.get_edges(u):\n            if reached_nodes[v] == 1:\n                continue\n            q.append(v)\n            reached_nodes[v] = 1\n\nprint(res)\n", "N, M = map(int, input().split())\nG = [[] for _ in range(N)]\n\nfor i in range(M):\n    x, y, z = map(int, input().split())\n    G[x-1].append(y-1)\n    G[y-1].append(x-1)\n\nlst = []\nvisited = [0]*N\nfor i in range(N):\n    if visited[i] == 1:continue\n    temp = [i]\n    lst1 = [i]\n    visited[i] = 1\n    while temp:\n        p = temp.pop()\n        for q in G[p]:\n            if visited[q] == 0:\n                visited[q] = 1\n                lst1.append(q)\n                temp.append(q)\n    if lst1 != []:lst.append(lst1)\n    \nprint(len(lst))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = map(int, input().split())\nXYZ = [list(map(int, input().split())) for _ in range(m)]\n\nuf = uf = UnionFind(n)\n\nfor x, y, z in XYZ:\n  x -= 1\n  y -= 1\n  uf.union(x, y)\n  \nprint(uf.group_count())", "a = [int(s) for s in input().split()]\ng = {i: [] for i in range(1, a[0] + 1)}\n\nfor i in range(a[1]):\n    c = [int(s) for s in input().split()]\n    g[c[0]].append(c[1])\n    g[c[1]].append(c[0])\n\nj = 0\nd = {i: False for i in range(1, a[0] + 1)}\n\nfor i in range(1, a[0] + 1):\n    if d[i] == False:\n        j += 1 \n        d[i] = True\n        if g[i] != []:\n            Q = [i]\n            while(Q != []):\n                r = Q.pop(0)\n                if g[r] != []:\n                    for m in g[r]:\n                        if d[m] == False:\n                            d[m] = True\n                            Q.append(m)\nprint(j)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\n\ndef read():\n    N, M = list(map(int, input().strip().split()))\n    XYZ = []\n    for i in range(M):\n        x, y, z = list(map(int, input().strip().split()))\n        XYZ.append((x, y, z))\n    return N, M, XYZ\n\n\nclass UnionFind():\n    \"\"\"Union-Find\u6728\u306e\u5b9f\u88c5\n    \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        self.parent = [x for x in range(n)]\n\n    def find(self, x):\n        \"\"\"\u8981\u7d20x\u304c\u6240\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u8fd4\u3059\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        \"\"\"\u8981\u7d20x, y\u304c\u305d\u308c\u305e\u308c\u6240\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3059\u308b\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x > y:\n            x, y = y, x\n        self.parent[y] = x\n\n    def parents(self):\n        return [self.find(x) for x in range(self.n)]\n\n\ndef solve(N, M, XYZ):\n    uf = UnionFind(N)\n    for x, y, z in XYZ:\n        uf.union(x-1, y-1)\n    C = Counter(uf.parents())\n    return len(C)\n\n\ndef __starting_point():\n    inputs = read()\n    print((solve(*inputs)))\n\n__starting_point()", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce, lru_cache\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = MAP()\nuf = UnionFind(n) # \u521d\u671f\u5316\n\nfor i in range(m):\n    x, y, z = MAP1()\n    uf.union(x, y) # \u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\n\nprint(uf.group_count())", "# -*- coding: utf-8 -*-\nimport sys \nsys.setrecursionlimit(10**6)\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n#Union Find\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return find(par[x])\n\ndef union(x,y):\n    x = find(x)\n    y = find(y)\n    if x==y:\n        return False\n    else:\n        if par[x] > par[y]:\n            x,y = y,x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\ndef same(x,y):\n    return find(x) == find(y)        \n    \nN,M = map(int,readline().split())\npar = [-1]*(N+1)\nfor i in range(M):\n    x,y,z = map(int,readline().split())\n    union(x,y)\nprint(sum(1 for i in par[1:] if i < 0))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\nfor _ in range(M):\n    X, Y, Z = map(lambda x: int(x)-1, input().split())\n    uf.union(X, Y)\nans = [uf.find(x) for x in uf.roots()]\nprint(len(set(ans)))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \n      \nN,M = map(int,input().split())\n\nuf = UnionFind(N+1)\n\nfor s in range (M):\n  X,Y,Z = map(int,input().split())\n  uf.union(X,Y)\n\nprint(uf.group_count() -1)", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n, m = ns()\n    uf = UnionFind(n)\n\n    for _ in range(m):\n        x, y, z = ns()\n        uf.union(x - 1, y - 1)\n\n    ans = uf.group_count()\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - 1 or 2\nfrom typing import List\n\n\ndef main():\n    def dfs(source: int) -> None:\n        stack = [source]\n        is_visited[source] = True\n        while stack:\n            u = stack.pop()\n            for v in graph[u]:\n                if is_visited[v]:\n                    continue\n                is_visited[v] = True\n                stack.append(v)\n\n    N, M, *X = list(map(int, open(0).read().split()))\n    graph: List[List[int]] = [[] for _ in range(N + 1)]\n    for x, y, _ in zip(*[iter(X)] * 3):\n        graph[x].append(y), graph[y].append(x)\n\n    is_visited = [False] * (N + 1)\n    res = 0\n    for i in range(1, N + 1):\n        if is_visited[i]:\n            continue\n        res += 1\n        dfs(i)\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M, *X = list(map(int, open(0).read().split()))\n\n\nclass UnionFind:\n    def __init__(self, n=0):\n        self.d = [-1]*n\n        self.u = n\n\n    def root(self, x):\n        if self.d[x] < 0:\n            return x\n        self.d[x] = self.root(self.d[x])\n        return self.d[x]\n\n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return False\n        if x > y:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        self.u -= 1\n        return True\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def size(self, x):\n        return -self.d[self.root(x)]\n\n    def num_union(self):\n        return self.u\n\n\nu = UnionFind(N)\nfor x, y, z in zip(*[iter(X)]*3):\n    u.unite(x-1, y-1)\nprint((u.num_union()))\n", "n,m=map(int,input().split())\nclass UnionFind:\n    #def   -> foo=UnionFind(n,1)  <- 1-based index, default is 0\n    #method -> foo.hoge(huga)\n    __slots__ = [\"_size\", \"_first_idx\", \"_parents\"]\n    def __init__(self, size: int, first_index: int = 0) -> None:\n        self._size = size\n        self._first_idx = first_index\n        self._parents = [-1] * (size + first_index)\n    def find(self, x: int) -> int:\n        if self._parents[x] < 0:\n            return x\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n    def same(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n        if self._parents[x] > self._parents[y]:\n            x, y = y, x\n        self._parents[x] += self._parents[y]\n        self._parents[y] = x\n        return True\n    def size(self, x: int) -> int:\n        return -self._parents[self.find(x)]\n    def group_count(self) ->int:\n        return sum([1 for i in  self._parents if i<0])-self._first_idx\n    def connected(self) ->bool:\n        return self._parents[self.find(self._first_idx)]==-self._size\n\nuf=UnionFind(n,1)\nfor i in range(m):\n    x,y,z=map(int,input().split())\n    uf.unite(x,y)\nprint(uf.group_count())", "import sys\nsys.setrecursionlimit(10 ** 5 + 10)\ndef input(): return sys.stdin.readline().strip()\n\ndef resolve():\n    from scipy.sparse.csgraph import connected_components  # https://note.nkmk.me/python-scipy-connected-components/\n    from scipy.sparse import csr_matrix\n    \n    N, M = map(int, input().split())  # \u9802\u70b9\u6570\u3001\u8fba\u6570\n    A, B, C = [0] * M, [0] * M, [1] * M  # A[i]\u304b\u3089B[i]\u3078\u30b3\u30b9\u30c8C[i]\u306e\u6709\u5411\u8fba\u3002\n    # \u305f\u3060\u3057\u3001connected_components()\u3067\u306f\u6709\u5411\u30b0\u30e9\u30d5\u3082\u7121\u5411\u30b0\u30e9\u30d5\u3068\u3057\u3066\u6271\u308f\u308c\u308b\n    for i in range(M):\n        A[i], B[i] ,_= map(int, input().split())\n        A[i] -= 1  # index\u3092\u8abf\u6574\n        B[i] -= 1\n    \n    csr = csr_matrix((C, (A, B)), shape=(N, N))\n    # n\u306f\u9023\u7d50\u6210\u5206\u306e\u500b\u6570\u3002label\u306f\u5404\u9802\u70b9\u304c\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u30e9\u30d9\u30eb\n    n, labels = connected_components(csr)\n    print(n)\n\n    \nresolve()", "# https://atcoder.jp/contests/abc126/tasks/abc126_e\n\nclass UnionFind():\n    # https://www.slideshare.net/chokudai/union-find-49066733\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        # root[x]>=0\u306e\u5834\u5408\u306f\u3001\u7279\u306b\u76f4\u63a5\u7684\u306a\u610f\u5473\u3092\u6301\u305f\u306a\u3044\u6c17\u304c\u3059\u308b\u3002\u8a08\u7b97\u306b\u5bc4\u4e0e\u3059\u308b\u306e\u3067\u610f\u5473\u306f\u3042\u308b\u306e\u3060\u308d\u3046\u304c\u3002\n        self.root = [-1]*(n+1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        # \u7121\u7d50\u5408\u306e\u6642\u306fRank=0,\u7d50\u5408\u3057\u30661\u3064\u6728\u304c\u6df1\u304f\u306a\u308b\u3068\u6839\u304cRank+=1\n        self.rnk = [0]*(n+1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    #\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        # (1)x\u306e\u30e9\u30f3\u30af\u306e\u65b9\u304c\u5927\u304d\u3044(\u4f4d\u7f6e\u304c\u6df1\u3044)\u5834\u5408\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        # (2)y\u306e\u30e9\u30f3\u30af\u306e\u65b9\u304c\u5927\u304d\u3044(\u4f4d\u7f6e\u304c\u6df1\u3044)\u5834\u5408 or \u7b49\u3057\u3044\u5834\u5408\n        # \u307e\u305f\u7b49\u3057\u3044\u5834\u5408\u3001\u5f15\u6570\u306e2\u3064\u3081\u306ey\u306e\u65b9\u306e\u30e9\u30f3\u30af\u30921\u3064\u5897\u3084\u3059\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    # Return: True or False\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n    \n#######################################################\nN,M=map(int,input().split())\nUN=UnionFind(N)\nfor _ in range(M):\n    s,t,u = map(int,input().split())\n    UN.Unite(s,t)\n    \n#print(UN.root)\nans=0\nfor i in UN.root:\n    if i<0:\n        ans +=1\nprint(ans-1)", "from collections import deque\n\n\nN,M=list(map(int,input().split()))\ngraph=[[] for _ in range(N+1)]\nfor _ in range(M):\n    a,b,c=map(int,input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n    \n#seen[i]\u306f\u3001\u9802\u70b9i\u3092\u8a2a\u554f\u6e08\u307f\u306e\u5834\u5408\u306fTrue\u3001\u672a\u8a2a\u554f\u306e\u5834\u5408\u306fFalse\nseen=[False]*(N+1)\n\n\ncount=0\n\nfor i in range(1,N+1):\n    if seen[i]==False:\n        seen[i]=True\n        S=deque([i])\n        \n        while S:\n            v=S.popleft()\n            #\u8a2a\u554f\u6e08\u307f\u306e\u9802\u70b9\u3092True\u306b\u3059\u308b\n            for i in graph[v]:\n                if seen[i]==False:\n                    seen[i]=True\n                    S.append(i)\n        count+=1\n\nprint(count)", "N, M = map(int, input().split())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(N)\nfor _ in range(M):\n    x, y, z = map(int, input().split())\n    uf.union(x-1, y-1)\n\nprint(len(uf.roots()))", "#!/usr/bin/env python3\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.size[x] < self.size[y]:\n                x,y = y,x\n            self.parents[y] = x\n            self.size[x] += self.size[y]\n\ndef main():\n    N, M = list(map(int, input().split()))\n    uf = UnionFind(N)\n    for _ in range(M):\n        X, Y, Z = [int(x)-1 for x in input().split()]\n        uf.union(X, Y)\n    # print(len(set(uf.parents)))\n    ans = [uf.find(x) for x in uf.parents]\n    print((len(set(ans))))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nroad = [[] for _ in range(N+1)]\n\nfor _ in range(M):\n    x,y,_ = list(map(int,input().split()))\n    road[x].append(y)\n    road[y].append(x)\n\nno_visit = set(list(range(1,N+1)))\nq = collections.deque([])\ncnt = 0\nwhile no_visit:\n    q.append(no_visit.pop())\n    cnt += 1\n    while q:\n        now = q.popleft()\n        for nxt in road[now]:\n            if nxt in no_visit:\n                q.append(nxt)\n                no_visit.discard(nxt)\nprint(cnt)\n                \n\n", "class Unionfind():  # Unionfind\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):  # \u30b0\u30eb\u30fc\u30d7\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):  # \u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def roots(self):  # \u6839\u306e\u30ea\u30b9\u30c8\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\nn, m = list(map(int, input().split()))\nxyz = sorted([list(map(int, input().split())) for _ in range(m)])\n\nuf = Unionfind(n)\nfor x, y, z in xyz:\n    uf.union(x - 1, y - 1)\nprint((len(uf.roots())))\n", "n,m=list(map(int,input().split()))\nxy=[[] for _ in range(n+1)]\nfor _ in range(m):\n    x,y,z=list(map(int,input().split()))\n    xy[x].append(y)\n    xy[y].append(x)\n\nfrom collections import deque\n\nvisited=[0]*(n+1)\ncount=0\n\nfor i in range(1,n+1):\n    if visited[i]==0:\n        stack=deque()\n        stack.append(i)\n        visited[i]+=1\n        while stack:\n            a=stack.pop()\n            for j in xy[a]:\n                if visited[j]==0:\n                    visited[j]+=1\n                    stack.append(j)\n        count+=1\nprint(count)\n", "class UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.components = n\n\n    def root(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.root(self.p[x])\n            return self.p[x]\n    \n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x != y:\n            self.p[x] = y\n            self.components -= 1\n    \n    def same(self, x,y):\n        return (self.root(x) == self.root(y))\nN, M = map(int,input().split())\n\nUF = UnionFind(N)\n\nfor _ in range(M):\n    X, Y, Z = map(int,input().split())\n    X, Y = X-1, Y-1\n    UF.unite(X,Y)\n\nprint(UF.components)", "#    Copyright 2016-2019 NetworkX developers.\n#    Copyright (C) 2004-2019 by\n#    Aric Hagberg <hagberg@lanl.gov>\n#    Dan Schult <dschult@colgate.edu>\n#    Pieter Swart <swart@lanl.gov>\n#    All rights reserved.\n#    BSD license.\n\"\"\"\nUnion-find data structure.\n\"\"\"\n\nfrom networkx.utils import groups\n\n\nclass UnionFind:\n    \"\"\"Union-find data structure.\n\n    Each unionFind instance X maintains a family of disjoint sets of\n    hashable objects, supporting the following two methods:\n\n    - X[item] returns a name for the set containing the given item.\n      Each set is named by an arbitrarily-chosen one of its members; as\n      long as the set remains unchanged it will keep the same name. If\n      the item is not yet part of a set in X, a new singleton set is\n      created for it.\n\n    - X.union(item1, item2, ...) merges the sets containing each item\n      into a single larger set.  If any item is not yet part of a set\n      in X, it is added to X as one of the members of the merged set.\n\n      Union-find data structure. Based on Josiah Carlson's code,\n      http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/215912\n      with significant additional changes by D. Eppstein.\n      http://www.ics.uci.edu/~eppstein/PADS/UnionFind.py\n\n    \"\"\"\n\n    def __init__(self, elements=None):\n        \"\"\"Create a new empty union-find structure.\n\n        If *elements* is an iterable, this structure will be initialized\n        with the discrete partition on the given set of elements.\n\n        \"\"\"\n        if elements is None:\n            elements = ()\n        self.parents = {}\n        self.weights = {}\n        for x in elements:\n            self.weights[x] = 1\n            self.parents[x] = x\n\n    def __getitem__(self, object):\n        \"\"\"Find and return the name of the set containing the object.\"\"\"\n\n        # check for previously unknown object\n        if object not in self.parents:\n            self.parents[object] = object\n            self.weights[object] = 1\n            return object\n\n        # find path of objects leading to the root\n        path = [object]\n        root = self.parents[object]\n        while root != path[-1]:\n            path.append(root)\n            root = self.parents[root]\n\n        # compress the path and return\n        for ancestor in path:\n            self.parents[ancestor] = root\n        return root\n\n    def __iter__(self):\n        \"\"\"Iterate through all items ever found or unioned by this structure.\n\n        \"\"\"\n        return iter(self.parents)\n\n    def to_sets(self):\n        \"\"\"Iterates over the sets stored in this structure.\n\n        For example::\n\n            >>> partition = UnionFind('xyz')\n            >>> sorted(map(sorted, partition.to_sets()))\n            [['x'], ['y'], ['z']]\n            >>> partition.union('x', 'y')\n            >>> sorted(map(sorted, partition.to_sets()))\n            [['x', 'y'], ['z']]\n\n        \"\"\"\n        # Ensure fully pruned paths\n        for x in list(self.parents.keys()):\n            _ = self[x]  # Evaluated for side-effect only\n\n        # TODO In Python 3.3+, this should be `yield from ...`.\n        for block in list(groups(self.parents).values()):\n            yield block\n\n    def union(self, *objects):\n        \"\"\"Find the sets containing the objects and merge them all.\"\"\"\n        roots = [self[x] for x in objects]\n        # Find the heaviest root according to its weight.\n        heaviest = max(roots, key=lambda r: self.weights[r])\n        for r in roots:\n            if r != heaviest:\n                self.weights[heaviest] += self.weights[r]\n                self.parents[r] = heaviest\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    XYZ = [list(map(int, input().split())) for _ in range(M)]\n\n    u = UnionFind(list(range(1, N + 1)))\n\n    for x, y, z in XYZ:\n        u.union(x, y)\n\n    print((len(list(u.to_sets()))))\n\n\nmain()\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\n\nfor _ in range(M):\n  X, Y, Z = map(int, input().split())\n  uf.union(X-1, Y-1)\n\nprint(uf.group_count())", "import sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\ndef s(): return input()\ndef i(): return int(input())\ndef S(): return input().split()\ndef I(): return list(map(int,input().split()))\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nINF = 10**9\nmod = 10**9+7\n\nN,M = I()\nlinks = [[] for _ in range(N)]\nfor i in range(M):\n    x,y,z = I()\n    links[x-1].append(y-1)\n    links[y-1].append(x-1)\nans = 0\nvisited = [0]*N\ndef dfs(n):\n    if visited[n]:\n        return\n    visited[n] = 1\n    for l in links[n]:\n        dfs(l)\nfor i in range(N):\n    if not visited[i]:\n        dfs(i)\n        ans += 1\nprint(ans)\n", "N, M = list(map(int,input().split()))\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] += size[x]\n    size[x] = 0\n\nfor i in range(M):\n    x, y, z= list(map(int,input().split()))\n    unite(x,y)\n\nAns = 0\nfor j in size[1:]:\n    if j != 0:\n        Ans += 1\nprint(Ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n      \n(n, m), *q = [list(map(int, o.split())) for o in open(0)]\nUF = UnionFind(n)\nfor x, y, _ in q:\n    UF.union(x - 1, y - 1)\nprint(UF.group_count())", "import sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nxy = []\nfor _ in range(m):\n    x, y, _ = map(int, input().split())\n    xy.append((x-1, y-1))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.li = list(range(n))\n    def root(self, x):\n        if self.li[x]==x:\n            return x\n        self.li[x] = self.root(self.li[x])\n        return self.li[x]\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx==ry:\n            return\n        self.li[ry] = rx\n    def same(self, x, y):\n        return self.root(x)==self.root(y)\n\nuf = UnionFind(n)\nfor x, y in xy:\n    uf.unite(x, y)\nfor i in range(n):\n    uf.root(i)\nprint(len(set(uf.li)))", "import sys\nsys.setrecursionlimit(10**5+1)\n\nN, M = map(int, input().split())\n\nedge = [[] for i in range(N)]\nfor i in range(M):\n    x, y, _ = map(int, input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\nvisited = [False] * N\n\nans = 0\ndef dfs(x):\n    nonlocal ans\n    if not visited[x]:\n        ans += 1\n    visited[x] = True\n\n    for x_next in edge[x]:\n        if visited[x_next]:\n           continue \n        visited[x_next] = True\n        dfs(x_next)\n\nfor i in range(N):\n    dfs(i)\n\nprint(ans)", "import networkx as X\nn,m=map(int,input().split())\ng=X.Graph()\nfor i in range(n):g.add_node(i+1)\nfor i in range(m):x,y,z=map(int,input().split());g.add_edge(x,y)\nprint(X.number_connected_components(g))", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\nimport networkx as nx\nfrom networkx.utils import union_find\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, M = MAP()\nXYZ = [LIST() for _ in range(M)]\n\nuf = union_find.UnionFind(list(range(1, N+1)))\n\nfor X, Y, Z in XYZ:\n\tuf.union(X, Y)\n\nprint((len(list(uf.to_sets()))))\n", "n, m = map(int, input().split())\n\nparent = [i + 1 for i in range(n)]\nrank = [0 for i in range(n)]\n\ndef find(x):\n    if parent[x - 1] == x:\n        return x\n    else:\n        parent[x - 1] = find(parent[x - 1])\n        return parent[x - 1]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if rank[x - 1] < rank[y - 1]:\n        parent[x - 1] = y\n    else:\n        parent[y - 1] = x\n        if rank[x - 1] == rank[y - 1]:\n            rank[x - 1] += 1\n\nfor i in range(m):\n    x, y, z = map(int, input().split())\n    unite(x, y)\nans = n\nfor i in range(n):\n    if find(i + 1) != i + 1:\n        ans -= 1\nprint(ans)", "N, M = map(int, input().split())\n\nimport networkx as nx\n\nG=nx.Graph()\n\nfor i in range (1, N+1):\n\tG.add_node(i)\n\nfor i in range (0, M):\n\tA, B, C = map(int, input().split())\n\tG.add_edge(A,B)\n\nprint(nx.number_connected_components(G))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\nN,M = list(map(int, input().split()))\n\nuf = UnionFind(N)\nfor i in range(M):\n    x,y,z = list(map(int, input().split()))\n    uf.union(x-1,y-1)\n\nprint((uf.group_count()))\n\n\n", "class UnionFind:\n    def __init__(self,N):\n        self.root = list(range(N))\n        self.size = [1] * (N)\n        \n    def find_root(self,x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n    \n    def merge(self,x,y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if x == y:\n            return\n        sx,sy = self.size[x],self.size[y]\n        if sx < sy:\n            self.root[x] = y\n            self.size[y] += sx\n        else:\n            self.root[y] = x\n            self.size[x] += sy\n\n\nn, m = map(int, input().split())\nxyz = []\nfor i in range(m):\n    xyz.append(list(map(int,input().split())))\n    \n\nuf = UnionFind(n)\n\nanswer = []\nfind_root = uf.find_root\nmerge = uf.merge\nfor i in range(m):\n    x, y, z = xyz[i][0]-1, xyz[i][1]-1, xyz[i][2]\n    merge(x,y)\ns = set([])\nfor i in range(n):\n    s.add(uf.find_root(i))\nprint(len(s))", "import sys\nsys.setrecursionlimit(10**9)\n\nN, M = list(map(int, input().split()))\npaths = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b, z = list(map(int, input().split()))\n    paths[a-1].append(b-1)\n    paths[b-1].append(a-1)\n\nvisited = [False] * N\n\ndef dfs(node, prev):\n    if visited[node]:\n        return\n    visited[node] = True\n    for n in paths[node]:\n        if n != prev:\n            dfs(n, node)\ncount = 0\nfor i in range(N):\n    if visited[i] == False:\n        count += 1\n        dfs(i,-1)\n\nprint(count)\n", "class UnionFind():\n    def __init__(self, n):\n        # \u6b63==\u5b50: \u6839\u306e\u9802\u70b9\u756a\u53f7 / \u8ca0==\u6839: \u9023\u7d50\u9802\u70b9\u6570\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        # \u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        # \u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n        return len(self.roots())\n \n    def all_group_members(self):\n        # {\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u8f9e\u66f8\u3092\u8fd4\u3059\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = map(int,input().split())\nu = UnionFind(n)\n\nfor i in range(m):\n    x,y,z = map(int,input().split())\n    u.union(x-1,y-1)\n\nans = u.group_count()\nprint(ans)", "import sys\nfrom collections import defaultdict\nreadline = sys.stdin.buffer.readline\n# sys.setrecursionlimit(10**8)\n\n\ndef geta(fn=lambda s: s.decode()):\n    return list(map(fn, readline().split()))\n\n\ndef gete(fn=lambda s: s.decode()):\n    return fn(readline().rstrip())\n\n\nclass UnionFind:\n\n    def __init__(self, N: int):\n        # d[i] = <parent id> if i is a child,\n        #       - <size of the group> if i is a root\n        self.d = [-1 for _ in range(N)]\n\n    def root(self, x: int) -> int:\n        if self.d[x] < 0:\n            return x\n        self.d[x] = self.root(self.d[x])\n        return self.d[x]\n\n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return False\n        if self.d[x] > self.d[y]:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        return True\n\n    def same(self, x: int, y: int) -> bool:\n        return self.root(x) == self.root(y)\n\n    def size(self, x: int):\n        return -self.d[self.root(x)]\n\n    def show(self):\n        m = {}\n        for n in range(len(self.d)):\n            r = self.root(n)\n\n            if r not in m:\n                m[r] = [n]\n            else:\n                m[r].append(n)\n\n        print(\"root -> childs\")\n        print(\"---------------------\")\n        for key in m:\n            print((\"{} -> {}\".format(key, m[key])))\n\n\ndef main():\n    n, m = geta(int)\n\n    uf = UnionFind(2*n)\n\n    ans = n\n\n    for _ in range(m):\n        x, y, z = geta(int)\n\n        united = False\n        if z & 1 == 0:\n            united = uf.unite(2*x-2, 2*y-2) and uf.unite(2*x-1, 2*y-1)\n        else:\n            united = uf.unite(2*x-2, 2*y-1) and uf.unite(2*x-1, 2*y-2)\n\n        if united:\n            ans -= 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\nedge = [[] for _ in range(N)]\nfor i in range(M):\n  a,b,c = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\nfrom collections import deque\n\nans = 0\nvisited = [False]*N\nd = deque()\nfor i in range(N):\n  if visited[i]==False:\n    visited[i]=True\n    d.append(i)\n    while len(d)>0:\n      v = d.popleft()\n      for w in edge[v]:\n        if visited[w]==False:\n          visited[w]=True\n          d.append(w)\n    ans += 1\nprint(ans)", "from networkx.utils import UnionFind\ndef main():\n    n,m=map(int, input().split())\n    uf=UnionFind()\n    for i in range(n):\n        _=uf[i]\n    for _ in range(m):\n        x,y,z=map(int, input().split())\n        uf.union(x-1,y-1)\n    print(len(list(uf.to_sets())))\n    \n    \ndef __starting_point():\n    main()\n__starting_point()", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n#https://note.nkmk.me/python-union-find/\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,m=MI()\nu=UnionFind(n)\nfor i in range(m):\n    a,b,c=MI()\n    u.union(a-1,b-1)\nprint((u.group_count()))\n", "n , m = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\nuf = UnionFind(n)\n\nfor i in range(m):\n    x , y , z = list(map(int, input().split()))\n    x-=1\n    y-=1\n    uf.union(x,y)\n\nprint((uf.group_count()))\n", "import queue\n\nn, m = list(map(int, input().split()))\ndic = {}  \ncount = 0\nq = queue.Queue()\n\nfor i in range(m):\n  a, b, c = list(map(int, input().split()))\n  if not a-1 in dic:\n    dic[a-1]=[b-1]\n  else:\n    dic[a-1].append(b-1)\n  \n  if not b-1 in dic:\n    dic[b-1]=[a-1]\n  else:\n    dic[b-1].append(a-1)\n\ndp = [0]*n\n\n#print(dic)\n\nfor i in range(n):\n  if dp[i]==0:\n    count += 1\n    dp[i]=count\n    if i in dic:\n      for j in dic[i]:\n        dp[j]=count\n        q.put(j)\n    #print(dp)\n    while not q.empty():\n      temp = q.get()\n      #print(temp)\n      if temp in dic:\n        for j in dic[temp]:\n          if dp[j] == 0:\n            dp[j]=count\n            q.put(j)\n#print(dp)\nprint(count)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*n\n        self.rank = [0]*n\n\n    def find(self, x):\n        if self.root[x-1] < 0:\n            return x\n        else:\n            self.root[x-1] = self.find(self.root[x-1])\n            return self.root[x-1]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x==y:\n            return\n        elif self.rank[x-1] > self.rank[y-1]:\n            self.root[x-1] += self.root[y-1]\n            self.root[y-1] = x\n            self.n-=1\n        else:\n            self.n-=1\n            self.root[y-1] += self.root[x-1]\n            self.root[x-1] = y\n            if self.rank[x-1] == self.rank[y-1]:\n                self.rank[y-1] += 1\n\n    def same(self, x, y):\n        return self.find(x)==self.find(y)\n\n    def count(self, x):\n        return -self.root[self.find(x)-1]\n    def num(self):\n        return self.n\n\nN,M=list(map(int,input().split()))\nuf=UnionFind(N)\nfor i in range(M):\n    x,y,z=list(map(int,input().split()))\n    uf.unite(x,y)\nprint((uf.num()))\n", "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\n \nsys.setrecursionlimit(10 ** 7)\n \nfrom collections import defaultdict\n \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n\nN, M = map(int, readline().split())\n\nadj = [[] for _ in range(N)]\nfor i in range(M):\n    x, y, z = map(int, readline().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\nvisited = [False for _ in range(N)]\ndef dfs(v):\n    if visited[v]:\n        return False\n    visited[v] = True\n    for u in adj[v]:\n        dfs(u)\n    return True\n\n\nans = 0\nfor i in range(N):\n    if dfs(i):\n        ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = list(map(int, input().split()))\n\nuf = UnionFind(n) # n: \u9802\u70b9\u6570\n\nfor i in range(m):\n    x, y, z = list(map(int, input().split()))\n\n    uf.union(x-1, y-1)\n\nprint((uf.group_count()))\n", "n,m = map(int,input().split())\n\n\npar = [-1]*(n)\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    else:\n      if par[x] > par[y]:x,y = y,x\n      par[x] += par[y]\n      par[y] = x\ndef size(x):\n    return -par[find(x)]\n\n\nfor i in range(m):\n  x,y,z = map(int,input().split())\n  unite(x-1,y-1)\n\n\nans = 0\n# print(par)\nfor i in range(n):\n  if par[i] <0:\n    ans += 1\nprint(ans)", "class UnionFind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        self.par[x] += self.par[y]\n        self.par[y] = x\n        return True\n\n\n    def root(self, x):\n        path = []\n        while self.par[x] >= 0:\n            path.append(x)\n            x = self.par[x]\n        for y in path:\n            self.par[y] = x\n        return x\n\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n\n    def size(self, x):\n        return -self.par[self.root(x)]\n\n\nn, m = map(int, input().split())\nuni = UnionFind(n)\nfor _ in range(m):\n    x, y, z = map(int, input().split())\n    x -= 1\n    y -= 1\n    uni.unite(x, y)\n\na = [0] * n\nfor i in range(n):\n    a[uni.root(i)] = 1\n\nprint(sum(a))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\nfor _ in range(M):\n    X, Y, Z = map(lambda x: int(x)-1, input().split())\n    uf.union(X, Y)\nprint(uf.group_count())", "N,M=list(map(int,input().split()))\npar=[-1]*N\n\ndef find(x):\n    if par[x]<0:\n        return x\n    else:\n        par[x]=find(par[x])\n        return par[x]\ndef union(x,y):\n    p,q=find(x),find(y)\n    if p==q:\n        return\n    if p>q:\n        p,q=q,p\n    par[p]+=par[q]\n    par[q]=p   \n\nfor _ in range(M):\n    X,Y,_=list(map(int,input().split()))\n    X,Y=X-1,Y-1\n    union(X,Y)\nans=0\nfor i in range(N):\n    if par[i]<0:\n        ans+=1\nprint(ans)\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    n,m=map(int, input().split())\n    uf=UnionFind(n)\n    for _ in range(m):\n        x,y,z=map(int, input().split())\n        uf.union(x-1,y-1)\n    print(uf.group_count())\n\n\n\n\n \ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind:\n    def __init__(self, N):\n        self.root = [-1 for _ in range(N)]\n        self.size = [1 for _ in range(N)]\n\n    def find(self, x):\n        while self.root[x] >= 0:\n            x = self.root[x]\n        return x\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            self.root[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.root[y] = x\n            self.size[x] += self.size[y]\n\nN, M = [int(_) for _ in input().split()]\nuf = UnionFind(N)\n\nfor i in range(M):\n    X, Y, Z = [int(_) for _ in input().split()]\n    uf.union(X-1, Y-1)\n\nans = set()\nfor i in range(N):\n    ans.add(uf.find(i))\nprint((len(ans)))\n", "from collections import Counter\n\nn,m = map(int,input().split())\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * (n)\n        self.size = [1] * (n)\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n    def all_find(self):\n        for n in range(len(self.par)):\n            self.find(n)\n\nuf = UnionFind(n)\n\nfor _ in range(m):\n    x,y,z = map(int,input().split())\n    x -= 1\n    y -= 1\n    uf.union(x,y)\n\nroot = set([])\n\nfor i in range(n):\n    root.add(uf.find(i))\n\nprint(len(root))", "import sys\nimport collections\n\ninput_methods=['clipboard','file','key']\nusing_method=0\ninput_method=input_methods[using_method]\n\ntin=lambda : map(int, input().split())\nlin=lambda : list(tin())\nmod=1000000007\n\n#+++++\n\ndef main():\n\t#a = int(input())\n\tn, m = tin()\n\t#s = input()\n\tis_open=[-1]*n\n\tgraph = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\tx, y, _ = tin()\n\t\tgraph[x-1].append(y-1)\n\t\tgraph[y-1].append(x-1)\n\t\t\n\tret = 0\n\tfor i in range(n):\n\t\tif is_open[i] > 0:\n\t\t\tcontinue\n\t\tret += 1\n\t\tq=collections.deque()\n\t\tq.append(i)\n\t\tis_open[i] = 1\n\t\twhile q:\n\t\t\tpos = q.pop()\n\t\t\tfor t in graph[pos]:\n\t\t\t\tif is_open[t] > 0:\n\t\t\t\t\tcontinue\n\t\t\t\tis_open[t] = 1\n\t\t\t\tq.append(t)\n\treturn ret\n\t\t\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "import sys\nimport heapq\nimport math\nimport fractions\nimport bisect\nimport itertools\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\ndef input(): return sys.stdin.readline().strip()\ndef mp(): return map(int,input().split())\ndef lmp(): return list(map(int,input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=mp()\nuf = UnionFind(n)\nfor i in range(m):\n    X,Y,Z=mp()\n    uf.union(X-1,Y-1)\nprint(len(uf.roots()))", "def main():\n    n,m = list(map(int,input().split()))\n    cards = [-1 for i in range(n)]\n    mg = {}\n    for i in range(n):\n        mg[i+1] = []\n    for i in range(m):\n        x,y,z = list(map(int,input().split()))\n        mg[x].append(y)\n        mg[y].append(x)\n    ans = 0\n    for i in range(n):\n        if cards[i]==-1:\n            ans += 1\n            cards[i] = 0\n            que = [i]\n            while len(que)>0:\n                s = que.pop(0)\n                for v in mg[s+1]:\n                    if cards[v-1] == 0:\n                        continue\n                    cards[v-1] = 0\n                    que.append(v-1)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Union Find \u6728\nfrom sys import setrecursionlimit\n\n\ndef find(parent, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, t)\n    parent[i] = t\n    return t\n\n\ndef unite(parent, i, j):\n    i = find(parent, i)\n    j = find(parent, j)\n    if i == j:\n        return\n    parent[j] += parent[i]\n    parent[i] = j\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\n\nparent = [-1] * N\nfor _ in range(M):\n    X, Y, Z = list(map(int, input().split()))\n    unite(parent, X - 1, Y - 1)\nprint((len([x for x in parent if x < 0])))\n", "class UnionFind:\n\tdef __init__(self, size):\n\t\tself.data = [-1] * size\n\n\tdef merge(self, x, y):\n\t\tx = self.root(x)\n\t\ty = self.root(y)\n\t\tif x == y: return False\n\n\t\tif self.data[x] < self.data[y]:\n\t\t\tx, y = y, x\n\n\t\tself.data[y] += self.data[x]\n\t\tself.data[x] = y\n\t\treturn True\n\n\tdef root(self, x):\n\t\tif self.data[x] < 0:\n\t\t\treturn x\n\t\tself.data[x] = self.root(self.data[x])\n\t\treturn self.data[x]\n\n\tdef size(self, x):\n\t\treturn -self.data[self.root(x)]\n\ndef main():\n\tN, M = map(int, input().split())\n\tuf = UnionFind(N)\n\tfor i in range(M):\n\t\tx, y, z = map(int, input().split())\n\t\tuf.merge(x-1, y-1)\n\n\tcnt = 0\n\tfor i in range(N):\n\t\tif uf.root(i) == i:\n\t\t\tcnt += 1\n\n\tprint(cnt)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys, collections\n\nstdin = sys.stdin\nn, m = map(int, stdin.readline().split())\n\npar = [i for i in range(n)]\nsize = [1] * n  # size of tree\nrank = [1] * n  # distance from parent\n\n\ndef find(x, par):\n    if par[x] == x:\n        return x\n    else:\n        return find(par[x], par)\n\n\ndef unite(x, y):\n    x = find(x, par)\n    y = find(y, par)\n\n    if x != y:\n        # x\u3068y\u306e\u5c5e\u3057\u3066\u3044\u308b\u96c6\u5408\u304c\u7570\u306a\u308b\u6642\n        if rank[x] < rank[y]:\n            par[x] = y\n            size[y] += size[x]\n        else:\n            par[y] = x\n            size[x] += size[y]\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n\nfor _ in range(m):\n    x, y, z = map(int, stdin.readline().split())\n    unite(x - 1, y - 1)\n    \nans = set()\nfor i in range(n):\n    ans.add(find(i, par))\nprint(len(ans))", "from collections import deque\n\nN, M = map(int, input().split())\n\nedge = [[] for i in range(N)]\nfor i in range(M):\n    x, y, _ = map(int, input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\nvisited = [False] * N\n\nans = 0\nfor i in range(N):\n    if visited[i]:\n        continue\n    else:\n        ans += 1\n\n    q = deque([i])\n    while q:\n        cur = q.pop()\n        visited[cur] = True\n\n        for next in edge[cur]:\n            if visited[next]:\n                continue\n            visited[next] = True\n            q.append(next)\n\nprint(ans)", "class UnionFind:\n    \"\"\"\n    size \u306e\u8981\u7d20\u6570\u306e UnionFind \u3092\u7ba1\u7406\u3059\u308b\n    data \u4e2d\u306e\u8ca0\u6570\u306e\u8981\u7d20\u304c\u6839\u3068\u306a\u308b\n    \"\"\"\n\n    def __init__(self, size):\n        # \u6839\u306f\u5b50\u3092\u542b\u3080\u96c6\u5408\u306e\u30c7\u30fc\u30bf\u6570\u3092\u8ca0\u6570\u3067\u3082\u3064\n        self.data = [-1] * size\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y: return False\n\n        # y \u306e\u65b9\u304c\u30c7\u30fc\u30bf\u6570\u3092\u591a\u304f\n        if self.data[x] < self.data[y]:\n            x, y = y, x\n\n        # y \u306b x \u3092\u3064\u306a\u3052\u308b\n        self.data[y] += self.data[x]\n        self.data[x] = y\n        return True\n\n    def root(self, x):\n        if self.data[x] < 0:\n            return x\n        self.data[x] = self.root(self.data[x])\n        return self.data[x]\n\n    def size(self, x):\n        \"\"\"\n        \u6839\u306f\u8ca0\u6570\u3067\u30c7\u30fc\u30bf\u6570\u3092\u7ba1\u7406\u3057\u3066\u3044\u308b\u306e\u3067\u305d\u308c\u3092\u8fd4\u3059\n        \"\"\"\n        return -self.data[self.root(x)]\n\ndef main():\n    N,M=[int(_) for _ in input().split()]\n    uf = UnionFind(N)\n    for i in range(M):\n        x,y,z=[int(_) for _ in input().split()]\n        uf.merge(x-1,y-1)\n\n    cnt=0\n    for i in range(N):\n        if uf.root(i)==i:\n            cnt+=1\n    print(cnt)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - 1 or 2\nfrom typing import Set\n\n\nclass UnionFind:\n    \"\"\"Union-Find: O(\u03b1(N))\"\"\"\n\n    __slots__ = [\"_data_size\", \"_first_idx\", \"_parents\"]\n\n    def __init__(self, data_size: int, is_zero_origin: bool = True) -> None:\n        self._data_size = data_size\n        self._first_idx = 0 if is_zero_origin else 1\n        self._parents = [-1] * (data_size + self._first_idx)\n\n    def __getitem__(self, x: int) -> int:\n        \"\"\"Find the group (root) of vertex x.\"\"\"\n        if self._parents[x] < 0:\n            return x\n        self._parents[x] = self[self._parents[x]]\n        return self._parents[x]\n\n    def __len__(self) -> int:\n        \"\"\"Count the number of groups (roots).\"\"\"\n        return len(self.groups)\n\n    @property\n    def groups(self) -> Set[int]:\n        \"\"\"Return the set of groups (roots).\"\"\"\n        return {\n            self[x] for x in range(self._first_idx, self._data_size + self._first_idx)\n        }\n\n    def is_connected(self, x: int, y: int) -> bool:\n        \"\"\"Return whether two vertices x and y are connected or not.\"\"\"\n        return self[x] == self[y]\n\n    def unite(self, x: int, y: int) -> None:\n        \"\"\"Unite two groups of vertices x and y.\"\"\"\n        x, y = self[x], self[y]\n        if x == y:\n            return\n        if self._parents[x] > self._parents[y]:\n            x, y = y, x\n        self._parents[x] += self._parents[y]\n        self._parents[y] = x\n\n\ndef main():\n    N, _, *X = list(map(int, open(0).read().split()))\n    tree = UnionFind(N, is_zero_origin=False)\n    for x, y, _ in zip(*[iter(X)] * 3):\n        tree.unite(x, y)\n    print((len(tree)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**8)\nN, M = map(int, input().split())\nedge = [[] for _ in range(N)]\nfor i in range(M):\n  a,b,c = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\ndef dfs(v):\n  if len(edge[v])==0:\n    return 0\n  for u in edge[v]:\n    if visited[u]==False:\n      visited[u]=True\n      dfs(u)\n  return 0\n\nans = 0\nvisited = [False]*N\nfor i in range(N):\n  if visited[i]==False:\n    visited[i]=True\n    dfs(i)\n    ans += 1\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\n\nN, M = list(map(int, input().split()))\n\nclass Union_Find:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n    \n    def find(self,x):\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def unite(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        else:\n            if self.rank[px] == self.rank[py]:\n                self.parent[py] = px\n                self.rank[px] += 1\n            elif self.rank[px] > self.rank[py]:\n                self.parent[py] = px\n            else:\n                self.parent[px] = py\nuftree = Union_Find(N+1)\n\nfor i in range(M):\n    x, y, _ = list(map(int, input().split()))\n    uftree.unite(x, y)\n\nresult = 0\nfor i in range(1, N+1):\n    if uftree.find(i) == i:\n        result += 1\n\nprint(result)\n\n", "import sys\nbreadline = sys.stdin.buffer.readline\nbread = sys.stdin.buffer.read\nreadline = sys.stdin.readline\nread = sys.stdin.read\nprintout = sys.stdout.write\nsprint = sys.stdout.flush\nsys.setrecursionlimit(10 ** 7)\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\n\ndef getnum(t=int): return t(breadline())\ndef numline(t=int): return map(t, breadline().split())\ndef numread(t=int): return map(t, bread().split())\ndef getstr(): return readline().strip()\ndef strline(): return readline().strip().split()\ndef strread(): return read().strip().split()\n\ndef dfs(c, to, seen):\n    for n in to[c]:\n        if not seen[n]:\n            seen[n] = 1\n            dfs(n, to, seen)\n\ndef run():\n    N,M = numline()\n    to = [[] for _ in range(N+1)]\n    for _ in range(M):\n        x,y,z = numline()\n        to[x].append(y)\n        to[y].append(x)\n\n    G = []\n    seen = [0] * (N+1)\n    for i in range(1, N+1):\n        if not seen[i]:\n            seen[i] = 1\n            dfs(i, to, seen)\n            G.append(i)\n    #print(G)\n    print(len(G))\n\n\n\ndef __starting_point():\n    run()\n__starting_point()", "from collections import deque\n\nN, M = map(int, input().split())\n\nedge = [[] for i in range(N)]\nfor i in range(M):\n    x, y, _ = map(int, input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\nvisited = [False] * N\n\nans = 0\nfor i in range(N):\n    if visited[i]:\n        continue\n    else:\n        ans += 1\n\n    q = deque([i])\n    while q:\n        cur = q.popleft()\n        visited[cur] = True\n\n        for next in edge[cur]:\n            if visited[next]:\n                continue\n            visited[next] = True\n            q.append(next)\n\nprint(ans)", "n,m=list(map(int,input().split()))\n\nimport sys\nsys.setrecursionlimit(10**9) #\u518d\u5e30\u306e\u4e0a\u9650\u3092\u3042\u3052\u308b\n\nroot=[-1 for i in range(n+1)] #\u81ea\u5206\u304c\u89aa\u306a\u3089\u30b0\u30eb\u30fc\u30d7\u306e\u4eba\u6570\u306e\u30de\u30a4\u30ca\u30b9\u500d\u3092\u3001\u305d\u3046\u3067\u306a\u3044\u306a\u3089\uff08\u5143\uff09\u89aa\u306e\u756a\u53f7\u3092\u793a\u3059\ndep=[1]*(n+1)\ndef r(x):   #\u89aa\u306f\u8ab0\uff1f\n    if root[x]<0:\n        return x\n    else:\n        root[x]=r(root[x])\n        return root[x]\n\ndef unite(x,y):\n    x=r(x)\n    y=r(y)\n    if x==y:\n        return\n    if dep[x]==dep[y]:\n        dep[x]+=1\n    if dep[x]<dep[y]:\n        x,y=y,x\n    root[x]+=root[y]\n    root[y]=x\n\nfor i in range(m):\n    x,y,z=list(map(int,input().split()))\n    unite(x,y)\n\n\ng=[0]*(n+1)\nfor i in range(1,n+1):\n    g[r(i)]+=1\nans=0\nfor i in range(n+1):\n    if g[i]>0:\n        ans+=1\nprint(ans)\n\n", "from collections import defaultdict\n\nN, M = list(map(int, input().split()))\nedges = defaultdict(list)\nfor _ in range(M):\n    x, y, z = list(map(int, input().split()))\n    x-=1\n    y-=1\n    edges[x].append(y)\n    edges[y].append(x)\n\nis_visited = [False] * N\n\ndef dfs(i):\n    stack = [i]\n    while stack:\n        i = stack.pop()\n        if is_visited[i]:\n            continue\n        is_visited[i] = True\n        for j in edges[i]:\n            stack.append(j)\n\nislands = 0\nfor i in range(N):\n    if is_visited[i] == False:\n        islands += 1\n        dfs(i)\nprint(islands)\n\n", "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for _ in range(n)]\n\n    def root(self, node):\n        parent_node = self.parents[node]\n        if parent_node == node:\n            return node\n        root_node = self.root(parent_node)\n        self.parents[node] = root_node  # reduction\n        return root_node\n\n    def union(self, one_node, other_node):\n        one_root = self.root(one_node)\n        other_root = self.root(other_node)\n        if one_root == other_root:\n            return\n        if self.ranks[one_root] < self.ranks[other_root]:\n            self.parents[one_root] = other_root\n        else:\n            self.parents[other_root] = one_root\n            if self.ranks[one_root] == self.ranks[other_root]:\n                self.ranks[one_root] += 1\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    tree = UnionFind(N)\n    for _ in range(M):\n        x, y, _ = list(map(int, input().split(' ')))\n        tree.union(x - 1, y - 1)\n    roots = list(map(lambda n: tree.root(n), range(N)))\n    print(len(set(roots)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\nn,m = map(int, input().split())\n\nrel = [[] for _ in range(n)]\nfor i in range(m):\n  x,y,z = map(int, input().split())\n  rel[x-1].append(y-1)\n  rel[y-1].append(x-1)\n\nans = [-1]*n\ndef hoge(parent, pos):\n  for i in rel[pos]:\n    if ans[i] >= 0:\n      continue\n    ans[i] = pos\n    hoge(pos, i)\n  return\n\ncnt = 0\nfor i in range(n):\n  if ans[i] < 0:\n    hoge(0, i)\n    cnt += 1\n\nprint(cnt)", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n          x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def num_roots(self):\n    return len([i for i, x in enumerate(self.parents) if x < 0])\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\nfor i in range(M):\n  a,b,c = map(int, input().split())\n  uf.union(a-1,b-1)\n\nprint(uf.num_roots())", "# UnionFind: https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * (n + 1)\n        \n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.root[x] > self.root[y]:\n            x, y = y, x\n        self.root[x] += self.root[y]\n        self.root[y] = x\n        \n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def size(self, x):\n        return -self.root[self.find(x)]\n\nn, m = map(int, input().split())\ncards = UnionFind(n)\nfor i in range(m):\n    x, y, z = map(int, input().split())\n    cards.unite(x, y)\nprint(sum(cards.find(i) == i for i in range(1, n + 1)))", "class UnionFind:\n    def __init__(self, node):\n        self.parent = [-1 for _ in range(node)]\n\n    def find(self, target):\n        if self.parent[target] < 0:\n            return target\n        else:\n            self.parent[target] = self.find(self.parent[target])\n            return self.parent[target]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.parent[root_x] > self.parent[root_y]:\n            root_x, root_y = root_y, root_x\n        self.parent[root_x] += self.parent[root_y]\n        self.parent[root_y] = root_x\n\n    def get_size(self, x):\n        return -self.parent[self.find(x)]\n\n    def get_root(self):\n        return [i for i, root in enumerate(self.parent) if root < 0]\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    uf = UnionFind(n)\n    for _ in range(m):\n        x, y, _ = [int(x) - 1 for x in input().split()]\n        uf.union(x, y)\n    print((len(uf.get_root())))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=list(map(int,input().split()))\n\nuf=[i for i in range(n+1)]\n\ndef uf_find(x):\n    while uf[x]!=x:\n        x=uf[x]\n    return x\n\nfor i in range(m):\n    x,y,z=list(map(int,input().split()))\n    a,b=uf_find(x),uf_find(y)\n    if a>b:\n        a,b=b,a\n    uf[b]=a\n\nc=set()\nfor i in range(1,n+1):\n    c.add(uf_find(i))\nprint((len(c)))\n", "class UnionFind():\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n            else:\n                self.par[y] = x\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def samegrp(self, x, y):\n        return self.root(x) == self.root(y)\n\nn, m = [int(x) for x in input().split()]\nA = UnionFind(n)\nans = n\nfor i in range(m):\n    x, y, _ = [int(z) - 1 for z in input().split()]\n    if not A.samegrp(x, y):\n        ans -=1\n    A.union(x, y)\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\nxy = []\nfor _ in range(m):\n    x, y, _ = list(map(int, input().split()))\n    xy.append((x - 1, y - 1))\n\n\nclass UF:\n    def __init__(self, n):\n        self.n = n\n        self.g = list(range(n))\n        self.vertices = list(range(n))\n\n    def union(self, i0, i1):\n        g0, g1 = self.find(i0), self.find(i1)\n        g0, g1 = min(g0, g1), max(g0, g1)\n        self.g[g1] = g0\n\n    def find(self, i):\n        path = []\n        while self.g[i] != i:\n            path.append(i)\n            i = self.g[i]\n\n        for j in path:\n            self.g[j] = i\n\n        return i\n\nuf = UF(n)\n\nfor x, y in xy:\n    uf.union(x, y)\n\ng = set()\nfor x in range(n):\n    g.add(uf.find(x))\n\nanswer = len(g)\nprint(answer)\n", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\n\n# by size\n# 0-indexed\nclass UnionFind:\n  N=0\n  parent=None\n  size=None\n  def __init__(self,N):\n    self.N=N\n    self.parent=[i for i in range(self.N)]\n    self.size=[1]*self.N\n    \n  def root(self,x):\n    while x!=self.parent[x]:\n      self.parent[x]=self.parent[self.parent[x]]\n      x=self.parent[x]\n    return x\n  \n  def same(self,x,y):\n    return self.root(x)==self.root(y)\n  \n  def unite(self,x,y):\n    x=self.root(x)\n    y=self.root(y)\n    if x==y:\n      return\n    if self.size[x]>self.size[y]:\n      # \u5927\u304d\u3044\u65b9\u306b\u304f\u3063\u3064\u3051\u308b\n      self.parent[y]=x\n      self.size[x]+=self.size[y]\n    else:\n      self.parent[x]=y\n      self.size[y]+=self.size[x]\n      \n  def get_group_size(self,x):\n    return self.size[self.root(x)]\n  \n  def get_roots(self):\n    r=set()\n    for i in range(self.N):\n      r.add(self.root(i))\n    return r\n  \n  def show_parent(self):\n    print((self.parent))\n    \n  def show_size(self):\n    print((self.size))\n    \nUF = UnionFind(N)\n\nfor i in range(M):\n  x,y,z = list(map(int,readline().split()))\n  UF.unite(x - 1, y - 1)\n  \nprint((len(UF.get_roots())))\n", "N,M=map(int,input().split())\nList = []\nfor i in range (M):\n  List.append(list(map(int, input().split())))\nList.sort()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(N)\nfor i in range(M):\n  uf.union(List[i][0]-1, List[i][1]-1)\nprint(uf.group_count())"]
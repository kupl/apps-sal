["n, f1, f2, f3, c = list(map(int,input().split()))\nmat = [[1,1,1],[1,0,0],[0,1,0]]\nfinal = [[1,0,0],[0,1,0],[0,0,1]]\nnn = n - 3\nN = 10**9 + 6\ndef prod(a, b):\n\tm = [[0,0,0],[0,0,0],[0,0,0]]\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tm[i][j] = (a[i][0]*b[0][j] + a[i][1]*b[1][j]+a[i][2]*b[2][j]) % N\n\treturn m\nwhile nn > 0:\n\tif nn % 2 == 1:\n\t\tfinal = prod(final, mat)\n\tmat = prod(mat,mat)\n\tnn //= 2\nq = (final[0][0] * 3 + final[0][1] * 2 + final[0][2] * 1) % N\np = q - (n%N) + N\n# p to potega c\nef3 = (final[0][0] * 1) % N\nef2 = (final[0][1] * 1) % N\nef1 = (final[0][2] * 1) % N\n# print f1^ef1 *f2^ef2*f3^ef3 * c^p\ndef pot(a,w):\n\twyn = 1\n\twhile w > 0:\n\t\tif w%2 == 1:\n\t\t\twyn = (wyn * a) % (N+1)\n\t\ta = (a * a) % (N+1)\n\t\tw //= 2\n\treturn wyn\nl1 = pot(f1, ef1)\nl2 = pot(f2, ef2)\nl3 = pot(f3, ef3)\nl4 = pot(c, p)\nc = (l1*l2*l3*l4)%(N+1)\nprint(c)", "N, f1, f2, f3, x = list(map(int, input().split()))\ndef mmult(A, B):\n    nonlocal mod\n    n, m, l = len(A), len(B), len(B[0])\n    ret = [[0]*l for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            for k in range(l):\n                ret[i][k] = (ret[i][k]+A[i][j]*B[j][k])%mod\n    return ret\ndef mpow(A, n):\n    if n == 1:\n        return A\n    if n % 2:\n        return mmult(mpow(A, n-1), A)\n    return mpow(mmult(A, A), n//2)\nP = 10**9+7\nmod = P - 1\nX = [[1,1,0],[1,0,1],[1,0,0]]\nY = [[1,1,0,0,0],[1,0,1,0,0],[1,0,0,0,0],[1,0,0,1,0],[1,0,0,1,1]]\na = 0 if N == 4 else mmult([[1,0,0]], mpow(X,N-4))[0][0]%mod\nb = mmult([[0,1,0]], mpow(X,N-3))[0][0]%mod\nc = mmult([[0,0,1]], mpow(X,N-2))[0][0]%mod\nd = mmult([[0,0,0,0,1]], mpow(Y,N-3))[0][0]%mod\nprint(pow(f1, a, P)*pow(f2, b, P)*pow(f3, c, P)*pow(x*x, d, P)%P)\n", "MOD = 10**9 + 7\n\n\ndef mat_mul(m1, m2):\n    n = len(m1)\n    m = []\n    for _ in range(n):\n        m.append([0] * n)\n    for y in range(n):\n        for x in range(n):\n            for i in range(n):\n                m[y][x] += m1[y][i] * m2[i][x]\n    for y in range(n):\n        for x in range(n):\n            m[y][x] %= (MOD - 1)\n    return m\n\n\ndef square_and_multiply(m, exp):\n    if exp == 1:\n        return m\n\n    sub = square_and_multiply(m, exp // 2)\n    sqr = mat_mul(sub, sub)\n    if exp % 2 == 1:\n        return mat_mul(sqr, m)\n    return sqr\n\n\nn, f1, f2, f3, c = list(map(int, input().split()))\nmf = [\n    [1, 1, 1],\n    [1, 0, 0],\n    [0, 1, 0],\n]\nmc = [\n    [1, 0, 0, 0, 1],\n    [2, 1, 1, 1, -4],\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 1],\n]\n\nmatf = square_and_multiply(mf, n - 3)\nmatc = square_and_multiply(mc, n - 3)\n\nc_exp = matc[1][0] * 3 + matc[1][4]\nf3_exp = matf[0][0]\nf2_exp = matf[0][1]\nf1_exp = matf[0][2]\nres = pow(c, c_exp, MOD) * pow(f3, f3_exp, MOD) * pow(f2, f2_exp, MOD) * pow(f1, f1_exp, MOD)\nprint(res % MOD)\n", "MOD = int(1e9 + 7)\n\ndef matMOD(A):\n  f = lambda x: x%(MOD-1) \n  ret = [ list(map(f, i)) for i in A ]\n  return ret \n\n\ndef matmul(A, B):\n  a, b = len(A), len(A[0])\n  c = len(B[0])\n  ret = [ [0] * c for i in range(a) ]\n\n  for i in range(a):\n    for j in range(c):\n      for k in range(b):\n        ret[i][j] += A[i][k] * B[k][j]\n\n  return ret\n\ndef matmul_log(A, m):\n  if m == 1:\n    return A\n\n  B = matmul_log(A, m//2)\n  if m % 2 == 0:\n    return matMOD(matmul(B, B))\n\n  else:\n    return matMOD(matmul(A, matmul(B, B)))\n\nn, f1, f2, f3, c = map(int, input().split())\n\nini = [\n  [1, 0, 0, 1],\n  [0, 1, 0, 1],\n  [0, 0, 1, 1],\n  [4, 2, 0, 0, 0, 2]\n]\n\nm = [\n  [0, 0, 0, 0],\n  [1, 0, 0, 1],\n  [0, 1, 0, 1],\n  [0, 0, 1, 1]\n]\n\nm2 = [\n  [1, 0, 0, 0, 0, 1],\n  [1, 1, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 0, 0, 1],\n  [0, 0, 0, 1, 0, 1],\n  [0, 0, 0, 0, 1, 1]\n]\n\n\nM = matmul_log(m, n-1)\nM2 = matmul_log(m2, n-1)\n\nx, y, z = matmul([ini[0]], M)[0][0], matmul([ini[1]], M)[0][0], matmul([ini[2]], M)[0][0]\nw = matmul([ini[3]], M2)[0][2]\n\n#print(x, y, z)\n#print(ini[3])\n#print(w)\nans = (pow(c, w, MOD) * pow(f1, x, MOD) * pow(f2, y, MOD) * pow(f3, z, MOD)) % MOD \nprint(ans)", "# @author \n\nimport sys\n\nclass EProductOrientedRecurrence:\n    def solve(self):\n        MOD = 10 ** 9 + 7\n        D = 3\n        I = [\n            [1 if i == j else 0 for j in range(D)]\n            for i in range(D)\n        ]\n\n        def mat_mult(A, B):\n            n, m, p = len(A), len(A[0]), len(B[0])\n            assert (len(B) == m)\n            C = [[0] * p for _ in range(n)]\n            for i in range(n):\n                for k in range(m):\n                    Aik = A[i][k]\n                    for j in range(p):\n                        C[i][j] = (C[i][j] + Aik * B[k][j]) % (MOD - 1)\n            return C\n\n        def mat_pow(A, p):\n            if p == 0:\n                return I\n            if p == 1:\n                return A\n            if p % 2 == 0:\n                return mat_pow(mat_mult(A, A), p // 2)\n            else:\n                return mat_mult(A, mat_pow(A, p - 1))\n\n        n, f1, f2, f3, c = [int(_) for _ in input().split()]\n        M = [[0, 1, 0],\n             [0, 0, 1],\n             [1, 1, 1]]\n\n        Rf1 = mat_mult(mat_pow(M, n - 1), [[1], [0], [0]])[0][0]\n        Rf2 = mat_mult(mat_pow(M, n - 1), [[0], [1], [0]])[0][0]\n        Rf3 = mat_mult(mat_pow(M, n - 1), [[0], [0], [1]])[0][0]\n        Rpower = (mat_mult(mat_pow(M, n - 1), [[1], [2], [3]])[0][0] - n) % (MOD - 1)\n\n        ans = pow(f1, Rf1, MOD) * pow(f2, Rf2, MOD) * pow(f3, Rf3, MOD) * pow(c, Rpower, MOD)\n        ans %= MOD\n        print(ans)\n\nsolver = EProductOrientedRecurrence()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "def mat_mul(a, b):\n    n, m, p = len(a), len(b), len(b[0])\n    res = [[0]*p for _ in range(n)]\n\n    for i in range(n):\n        for j in range(p):\n            for k in range(m):\n                res[i][j] += a[i][k]*b[k][j]\n            res[i][j] %= 1000000006\n\n    return res\n\ndef mat_pow(a, n):\n    if n == 1: return a\n    if n%2 == 1: return mat_mul(mat_pow(a, n-1), a)\n    t = mat_pow(a, n//2)\n    return mat_mul(t, t)\n\nn, f1, f2, f3, c = map(int, input().split())\n\n\nm1 = [[3, 1000000004, 0, 1000000005, 1], [1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]]\nm2 = [[2], [0], [0], [0], [0]]\nt1 = pow(c, mat_mul(mat_pow(m1, n), m2)[-1][0], 1000000007)\n\nm1 = [[0, 0, 1], [1, 0, 1], [0, 1, 1]]\nm2 = [[1], [0], [0]]\nm3 = mat_mul(mat_pow(m1, n-1), m2)\nt2 = pow(f1, m3[0][0], 1000000007)\nt3 = pow(f2, m3[1][0], 1000000007)\nt4 = pow(f3, m3[2][0], 1000000007)\n\nprint(t1*t2*t3*t4%1000000007)", "import math\nmd = 10**9+7\ndef multiply(M,N):\n\tmd2 = 10**9+6\n\tR = [[0 for i in range(3)] for j in range(3)]\n\tfor i in range(0, 3):  \n\t\tfor j in range(0, 3): \n\t\t\tfor k in range(0, 3):  \n\t\t\t\tR[i][j] += (M[i][k] * N[k][j])%md2\n\t\t\t\tR[i][j] %= md2\n\treturn R\n\ndef power(mat, n):\n\tres = [[1,0,0],[0,1,0],[0,0,1]]\n\twhile n:\n\t\tif n&1: res = multiply(res, mat)\n\t\tmat = multiply(mat, mat)\n\t\tn//=2\n\treturn res\n\nn, f1, f2, f3, c = map(int, input().split())\nf1 = (f1*c)%md\nf2 = (f2*c**2)%md\nf3 = (f3*c**3)%md\n#print(f1, f2, f3)\nmat = [[1,1,1],[1,0,0],[0,1,0]]\nres = power(mat, n-3)\n#print(res)\npw1, pw2, pw3 = res[0][2], res[0][1], res[0][0]\nf1 = pow(f1, pw1, md)\nf2 = pow(f2, pw2, md)\nf3 = pow(f3, pw3, md)\nans = ((f1 * f2)%md * f3)%md\nc = pow(c, md-2, md)\nans *= pow(c, n%(md-1), md)\nans %= md\nprint(ans)", "def mat_mult(A, B, MOD):\n    n, m, p = len(A), len(A[0]), len(B[0])\n    assert (len(B) == m)\n    C = [[0] * p for _ in range(n)]\n    for i in range(n):\n        for k in range(m):\n            Aik = A[i][k]\n            for j in range(p):\n                C[i][j] = (C[i][j] + Aik * B[k][j]) % MOD\n    return C\n\ndef ksm(A, n, MOD):\n    if (n == 0):\n        E = [[0 for i in range(len(A))] for j in range(len(A))]\n        for i in range(len(A)):\n            E[i][i] = 1\n        return E\n    if (n == 1):\n        return A\n    k = ksm(A, n//2, MOD)\n    z = mat_mult(k, k, MOD)\n    if (n&1):\n        return (mat_mult(z, A, MOD))\n    else:\n        return z\n\ndef Fenjie(n):\n    k = {}\n    if (n==1):\n        return {}\n    a = 2\n    while (n>=2):\n        b = n%a\n        if (a*a > n):\n            k[n] = 1\n            break\n        if (b==0):\n            if (a in k):\n                k[a] += 1\n            else:\n                k[a] = 1\n            n = n//a\n        else:\n            a += 1\n    return k\n\ndef Euler(n):\n    if (n==1):\n        return 1\n    k = Fenjie(n)\n    m = n\n    for i in k:\n        m = m // i * (i-1)\n    return m\n\nMOD = 10**9 + 7\nn, b, c, d, e = list(map(int, input().split()))\n\nl1 = [[0],[0],[1]]\nl2 = [[0],[1],[0]]\nl3 = [[1],[0],[0]]\nl4 = [[6],[2],[0],[0],[0]]\na1 = [[1,1,1],[1,0,0],[0,1,0]]\na2 = [[3,-2,0,-1,1],[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0]]\nif (n == 4):\n    print(e*e*b*c*d % MOD)\nelse:\n    a1 = ksm(a1, n-3, MOD-1)\n    a2 = ksm(a2, n-5, MOD-1)\n    b1 = mat_mult(a1, l1, MOD-1)\n    p1 = pow(b, b1[0][0], MOD)\n    c1 = mat_mult(a1, l2, MOD-1)\n    p2 = pow(c, c1[0][0], MOD)\n    d1 = mat_mult(a1, l3, MOD-1)\n    p3 = pow(d, d1[0][0], MOD)\n    n1 = mat_mult(a2, l4, MOD-1)[0][0]\n    p = pow(e, n1, MOD)\n    p = p1*p%MOD\n    p = p2*p%MOD\n    p = p3*p%MOD\n    print(p)", "mod = 1000000007\n\nX = [[1,1,1],\n    [1,0,0],\n    [0,1,0]]\n\ndef mul(A, B):\n    return [[sum(a*b for a,b in zip(X_row,Y_col)) % ( mod-1 ) for Y_col in zip(*B)] for X_row in A]\n\ndef pow_n(A, n):\n    if n == 1:\n        return A\n    \n    A_ = pow_n(A, n // 2)\n             \n    if n % 2 == 0:\n        return A_ * A_ % mod \n    else:\n        return A_ * A_ * A % mod\n\ndef pow_m(A, n):\n    if n == 1:\n        return A\n    \n    A_ = pow_m(A, n // 2)\n             \n    if n % 2 == 0:\n        return mul(A_, A_)\n    else:\n        return mul(mul(A_, A_), A)     \n             \nn , f1, f2, f3, c = map(int, input().split())\nu1  = c * f1 % mod\nu2  = (c ** 2) * f2 % mod\nu3  = (c ** 3) * f3 % mod\nX_  = pow_m(X, n-3)\nu_n = pow_n(u3, X_[0][0]) * pow_n(u2, X_[0][1]) * pow_n(u1, X_[0][2]) % mod \nf_n = pow_n(pow_n(c, mod-2), n) * u_n % mod\nprint(f_n)", "def mat_dot(A, B, mod):\n    assert len(A[0]) == len(B), 'invalid_size'\n    \n    L = len(A)\n    M = len(A[0])\n    N = len(B[0])\n    \n    res = [[0]*N for _ in range(L)]\n    \n    for i in range(L):\n        for j in range(N):\n            a = 0\n            for k in range(M):\n                a = (a+A[i][k]*B[k][j]) % mod\n            res[i][j] = a\n            \n    return res\n\ndef mat_pow(A, x, mod):\n    N = len(A)\n    res = [[0]*N for _ in range(N)]\n    for i in range(N):\n        res[i][i] = 1\n    for i in range(x.bit_length()):\n        if 2**i & x:\n            res = mat_dot(res, A, mod)\n        A = mat_dot(A, A, mod)\n    return res\n\n#if there exists K such that X**K %mod == Y % mod, return K % (mod-1)\n#Otherwise, return -1\ndef bsgs(X, Y, mod):\n    Y %= mod\n    X %= mod\n    \n    rm = int(mod**(0.5)) + 2\n    R = pow(pow(X, rm ,mod), mod-2, mod)\n    \n    D = {Y: 0}\n    p = Y\n    for a in range(1, rm):\n        p = p*R % mod\n        D[p] = a\n    \n    p = 1\n    b = 0\n    if p in D:\n        return (D[p]*rm + b)%(mod-1)\n    for b in range(1, rm):\n        p = (p*X) % mod\n        if p in D:\n            return (D[p]*rm + b)%(mod-1)\n    return -1\n\n\nn, f1, f2, f3, c = list(map(int, input().split()))\nmod = 10**9+7\na1 = bsgs(5, f1, mod)\na2 = bsgs(5, f2, mod)\na3 = bsgs(5, f3, mod)\nd = bsgs(5, c, mod)\nA = [[1, 1, 1, 2*d, -6*d], \n     [1, 0, 0, 0, 0], \n     [0, 1, 0, 0, 0], \n     [0, 0, 0, 1, 1], \n     [0, 0, 0, 0, 1]]\nB = mat_pow(A, n-3, mod - 1)\nAns = mat_dot(B, [[a3], [a2], [a1], [4], [1]], mod - 1)\nprint(pow(5, Ans[0][0], mod))\n", "import os\nfrom io import BytesIO, StringIO\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nDEBUG = False\ndebug_print = print if DEBUG else lambda *x,**y: None\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef main():\n    mod = 1000000007\n\n    def modmul(x, y):\n        return (x * y) % mod\n\n    def row(m, i, n=3):\n        return m[n * i:n * (i + 1)]\n\n    def col(m, i, n=3):\n        return m[i::n]\n\n    def vecmul(u, v):\n        s = 0\n        for i, j in zip(u, v):\n            s += (i * j) % (mod-1)\n        return s % (mod-1)\n\n    def matmul(a, b, n=3):\n        out = []\n        for i in range(n * n):\n            r, c = divmod(i, n)\n            out.append(vecmul(row(a, r), col(b, c)))\n        return out\n\n    def matadd(a, b, n=3):\n        out = []\n        for i in range(n * n):\n            out.append((a[i] + b[i]) % (mod-1))\n        return out\n\n    def matpow(m, p, n=3):\n        bs = str(bin(p)).lstrip('0b')\n        out = [0] * (n * n)\n        out[0::n + 1] = [1] * n\n        for b in reversed(bs):\n            if b == '1':\n                out = matmul(out, m)\n            m = matmul(m, m)\n        return out\n\n    def brute_force(n, f1, f2, f3, c):\n        i = 3\n        while i < n:\n            i += 1\n            f4 = pow(c, 2*i-6, mod) * f1 * f2 * f3 % mod\n            f1, f2, f3 = f2, f3, f4\n        return f3\n\n    def solve(n, f1, f2, f3, c):\n        f = [f1, f2, f3]\n        g = [modmul(c, f[0]), modmul(c * c, f[1]), modmul(c * c * c, f[2])]\n        mat = [1, 1, 1, 1, 0, 0, 0, 1, 0]\n        mat_n = matpow(mat, n - 3)\n        g_n = (pow(g[2], mat_n[0], mod)\n               * pow(g[1], mat_n[1], mod)\n               * pow(g[0], mat_n[2], mod)) % mod\n        c_n = pow(c, n, mod)\n        c_n_inv = pow(c_n, mod - 2, mod)\n        f_n = modmul(g_n, c_n_inv)\n        return f_n\n\n    def solve_from_stdin():\n        i = input_as_list()\n        print(solve(*i))\n\n    def test():\n        import random\n        sample = [random.randrange(4, 99) for _ in range(5)]\n        sample = [2, 2, 2, 2]\n        print(*sample)\n        for i in range(4,200):\n            print(i, *sample)\n            print(solve(i, *sample))\n            print(brute_force(i, *sample))\n            print()\n\n    solve_from_stdin()\n\nmain()", "def mat_mul(A,B,m):\n    C = [[0]*3 for i in range(3)]\n    \n    for i in range(3):\n        for j in range(3):\n            C[i][j] = (A[i][0]*B[0][j]%m + A[i][1]*B[1][j]%m + A[i][2]*B[2][j]%m)%m\n    return C\n\ndef vec_mul(A,x,m):\n    b = [0]*3\n    \n    for i in range(3):\n        b[i] = (A[i][0]*x[0]%m + A[i][1]*x[1]%m + A[i][2]*x[2]%m)%m\n\n    return b\n      \n\ndef calc_tribonacci(M,n,m,start):\n    X = []\n    X.append(M[0].copy());X.append(M[1].copy());X.append(M[2].copy())\n    R = [[1,0,0],[0,1,0],[0,0,1]]\n    while n>0:\n        if n%2 == 1:\n            R = mat_mul(X,R,m)\n        \n        X = mat_mul(X,X,m)\n        \n        n=n//2\n\n    return vec_mul(R, start,m)[2]\n\ndef calc_exponent(a,b,m):\n    x = a\n    r = 1\n    while b>0:\n        \n        if b%2==1:\n            r = r*x%m\n        \n        x = x*x%m\n        \n        b = b//2\n        \n    return r\n\nm = 1000000007\n\nn,f1,f2,f3,c = [int(i) for i in input().split()]\n\nM = [[1,1,1],[1,0,0],[0,1,0]]\n\ntemp1 = 3*calc_tribonacci(M, n-1, m-1, [1,1,0])\n\ntemp1 = (temp1 - calc_tribonacci(M, n-4, m-1, [1,1,0]) - n)%(m-1)\n\ntemp2 = calc_tribonacci(M, n-3, m-1, [2,1,1])\n\ntemp3 = calc_tribonacci(M, n-3, m-1, [2,1,0])\n\ntemp4 = calc_tribonacci(M, n-3, m-1, [1,1,0])\n\nans = calc_exponent(c, temp1, m)\n\nans = (ans*calc_exponent(f3, temp2, m))%m\n\nans = (ans*calc_exponent(f2, temp3, m))%m\n\nans = (ans*calc_exponent(f1, temp4, m))%m\n\n#print(temp1, temp2, temp3 , temp4)\n\nprint(ans)\n\n\n\n\n\n\n        \n", "import math\nmd = 10**9+7\ndef multiply(M,N):\n\tmd2 = 10**9+6\n\tR = [[0 for i in range(3)] for j in range(3)]\n\tfor i in range(0, 3):  \n\t\tfor j in range(0, 3): \n\t\t\tfor k in range(0, 3):  \n\t\t\t\tR[i][j] += (M[i][k] * N[k][j])%md2\n\t\t\t\tR[i][j] %= md2\n\treturn R\n\ndef power(mat, n):\n\tres = [[1,0,0],[0,1,0],[0,0,1]]\n\twhile n:\n\t\tif n&1: res = multiply(res, mat)\n\t\tmat = multiply(mat, mat)\n\t\tn//=2\n\treturn res\n\nn, f1, f2, f3, c = map(int, input().split())\nf1 = (f1*c)%md\nf2 = (f2*c**2)%md\nf3 = (f3*c**3)%md\n#print(f1, f2, f3)\nmat = [[1,1,1],[1,0,0],[0,1,0]]\nres = power(mat, n-3)\n#print(res)\npw1, pw2, pw3 = res[0][2], res[0][1], res[0][0]\nf1 = pow(f1, pw1, md)\nf2 = pow(f2, pw2, md)\nf3 = pow(f3, pw3, md)\nans = ((f1 * f2)%md * f3)%md\nc = pow(c, md-2, md)\nans *= pow(c, n%(md-1), md)\nans %= md\nprint(ans)", "from functools import reduce\n\n\nmod = 10 ** 9 + 7\nM = [[0, 1, 0],\n\t [0, 0, 1],\n\t [1, 1, 1]]\n\nE = [[1, 0, 0],\n\t [0, 1, 0],\n\t [0, 0, 1]]\n\n\ndef mult(M, K):\n\ta, b, c = len(M), len(M[0]), len(K[0])\n\t# print('a, b, c:', a, b, c)\n\tans = [[0 for _ in range(c)] for _ in range(a)]\n\n\n\tfor i in range(a):\n\t\tfor j in range(c):\n\t\t\tfor k in range(b):\n\t\t\t\tans[i][j] += (M[i][k] * K[k][j]) % (mod - 1)\n\t\t\t\tans[i][j] %= (mod -1 )\n\n\t# \t\tprint('ans[', i, '][', j, '] = ', ans[i][j])\n\t# print('mult', M, 'and', K)\n\t# print(ans)\n\treturn ans\n\n\ndef matrix_power(M, n):\n\tres = E\n\tmtpl = M\n\t# print('matrix_power, n =', n)\n\twhile n:\n\t\tif n%2 == 1:\n\t\t\tres = mult(res, mtpl)\n\t\tmtpl = mult(mtpl, mtpl)\n\t\tn //= 2\n\treturn res\n\nn, f1, f2, f3, c = list(map(int, input().split()))\nu = [c*f1 % mod,  c*c*f2 % mod, c*c*c*f3 % mod]\n# print('u:', u)\n\nMn = matrix_power(M, n-4)\n# print('Mn:', Mn)\n\npwrs = mult( [[1, 1, 1]], Mn )\n# print('pwrs:', pwrs)\n\narr = [ pow(u[i], pwrs[0][i], mod) for i in range(3)]\n\nun = reduce(lambda x, y: x*y%mod,  arr )\n# print('un:', un)\n\ncn_1 = pow(c, n*(mod-2) % (mod-1) , mod)\n# print('cn', cn)\n\n# cn_1 = pow(cn, mod-2, mod)\n# print('cn_1', cn_1)\nprint((un * cn_1) % mod)\n", "MD = 10**9+7\n\ndef mult(A,B):\n    n = len(A)\n    C = [[0] * n for _ in range(n)]\n    for i in range(len(A)):\n        for j in range(len(A)):\n            for k in range(len(A)):\n                C[i][j] += A[i][k]*B[k][j]\n            C[i][j] %= MD-1\n\n    return C\n\ndef ex(A,k):\n    n = len(A)\n    R = [[0] * n for _ in range(n)]\n    for i in range(n):\n        R[i][i] = 1\n    while k > 0:\n        if k & 1:\n            R = mult(R,A)\n        k //= 2\n        A = mult(A,A)\n    return R\n\ncma = [\n    [1,1,1,1,0],\n    [1,0,0,0,0],\n    [0,1,0,0,0],\n    [0,0,0,1,2],\n    [0,0,0,0,1]\n]\n\ntri = [\n    [1,1,1],\n    [1,0,0],\n    [0,1,0]\n]\n\nn,f1,f2,f3,c = map(int,input().split())\n\nce = ex(cma,n-3)\ncp = ce[0][3]*2+ce[0][4]\nf = ex(tri,n-3)\nfp1 = f[0][2]\nfp2 = f[0][1]\nfp3 = f[0][0]\nr = pow(f1,fp1,MD)*pow(f2,fp2,MD)*pow(f3,fp3,MD)*pow(c,cp,MD)\n#print(fp1,fp2,fp3,cp)\nprint(r%MD)", "def _mul(A, B, MOD):\n    C = [[0] * len(B[0]) for i in range(len(A))]\n    for i in range(len(A)):\n        for k in range(len(B)):\n            for j in range(len(B[0])):\n                C[i][j] = (C[i][j] + A[i][k]*B[k][j]) % MOD\n    return C\n\n\ndef pow_matrix(A, n, MOD):\n    \"\"\"A**n\u3092\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u3063\u3066\u6c42\u3081\u308b\"\"\"\n    B = [[0] * len(A) for i in range(len(A))]\n    for i in range(len(A)):\n        B[i][i] = 1\n    while n > 0:\n        if n & 1:\n            B = _mul(A, B, MOD)\n        A = _mul(A, A, MOD)\n        n  = n // 2\n    return B\n\n\nn, f1, f2, f3, c = map(int, input().split())\nMOD = 10**9 + 7\nans = 1\n\nmatrix = [[0]*3 for i in range(3)]\nmatrix[0][0] = matrix[0][1] = matrix[0][2] =1\nmatrix[1][0] = 1\nmatrix[2][1] = 1\nf_matrix = pow_matrix(matrix, n - 3, MOD - 1)\n\nans *= pow(f3, f_matrix[0][0], MOD)\nans *= pow(f2, f_matrix[0][1], MOD)\nans *= pow(f1, f_matrix[0][2], MOD)\n\nmatrix = [[0]*5 for i in range(5)]\nmatrix[0][0] = matrix[0][1] = matrix[0][2] =1\nmatrix[0][3] = 2\nmatrix[0][4] = -6\nmatrix[1][0] = matrix[2][1] = 1\nmatrix[3][3] = matrix[3][4] = 1\nmatrix[4][4] = 1\n\nc_matrix = pow_matrix(matrix, n - 3, MOD - 1)\nans *= pow(c, c_matrix[0][3] * 4 + c_matrix[0][4], MOD)\nprint(ans % MOD)", "def baby_step_giant_step(g, y, p):\n    \"\"\"y = g^x (mod p)\u3092\u6e80\u305f\u3059x\u3092\u6c42\u3081\u308b\"\"\"\n    m = int(p**0.5) + 1\n    \n    # Baby-step\n    baby = {}\n    b = 1\n    for i in range(m):\n        baby[b] = i\n        b = (b * g) % p\n\n    # Giant-step\n    gm = pow(b, p-2, p)\n    giant = y\n    for i in range(m):\n        if giant in baby:\n            x = i*m + baby[giant]\n            return x\n        giant = (giant * gm) % p\n    return -1\n  \n\ndef _mul(A, B, MOD):\n    C = [[0] * len(B[0]) for i in range(len(A))]\n    for i in range(len(A)):\n        for k in range(len(B)):\n            for j in range(len(B[0])):\n                C[i][j] = (C[i][j] + A[i][k]*B[k][j]) % MOD\n    return C\n\n\ndef pow_matrix(A, n, MOD):\n    \"\"\"A**n\u3092\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u3063\u3066\u6c42\u3081\u308b\"\"\"\n    B = [[0] * len(A) for i in range(len(A))]\n    for i in range(len(A)):\n        B[i][i] = 1\n    while n > 0:\n        if n & 1:\n            B = _mul(A, B, MOD)\n        A = _mul(A, A, MOD)\n        n  = n // 2\n    return B\n\n\nn, f1, f2, f3, c = map(int, input().split())\nMOD = 10**9 + 7\n\nlog_f1 = baby_step_giant_step(5, f1, MOD)\nlog_f2 = baby_step_giant_step(5, f2, MOD)\nlog_f3 = baby_step_giant_step(5, f3, MOD)\nlog_c = baby_step_giant_step(5, c, MOD)\n\nmatrix = [[0]*5 for i in range(5)]\nmatrix[0][0] = 1\nmatrix[0][1] = 1\nmatrix[0][2] = 1\nmatrix[0][3] = 2 * log_c\nmatrix[0][4] = -6 * log_c\nmatrix[1][0] = 1\nmatrix[2][1] = 1\nmatrix[3][3] = 1\nmatrix[3][4] = 1\nmatrix[4][4] = 1\n\nmatrix_n = pow_matrix(matrix, n - 3, MOD - 1)\n\nans = log_f3 * matrix_n[0][0] + log_f2 * matrix_n[0][1] + log_f1 * matrix_n[0][2] \\\n      + 4 * matrix_n[0][3] + matrix_n[0][4]\nans = ans % (MOD-1)\n\nprint(pow(5, ans, MOD))", "def mult(m1, m2):\n    p = len(m1)\n    q = len(m2)\n    r = len(m2[0])\n    m3 = [[0] * r for _ in range(p)]\n    for x in range(p):\n        for y in range(r):\n            for z in range(q):\n                m3[x][y] += m1[x][z] * m2[z][y]\n                m3[x][y] %= (M-1)\n    return m3\n\n\ndef binpow(mat, x):\n    if x == 0:\n        return E\n    elif x % 2:\n        return mult(mat, binpow(mult(mat, mat), x // 2))\n    else:\n        return binpow(mult(mat, mat), x // 2)\n\n\nmatrix = [[0, 1, 0], [0, 0, 1], [1, 1, 1]]\nE = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\nM = 10 ** 9 + 7\nn, f1, f2, f3, c = map(int, input().split())\nmatrix = binpow(matrix, n-1)\ng1 = matrix[0][0]\ng2 = matrix[0][1]\ng3 = matrix[0][2]\nans = pow(c * f1, g1, M) * pow(c * c * f2, g2, M) % M * pow(c * c * c * f3, g3, M) % M * pow(c, (10 ** 9 * (M - 1) - n) % (M - 1), M) % M\nprint(ans % M)", "def mul(a, b, mod):\n    c = [[0] * len(b[0]) for i in range(len(a))]\n    for i in range(len(a)):\n        for j in range(len(b[0])):\n            for k in range(len(b)):\n                c[i][j] += a[i][k] * b[k][j]\n                if c[i][j] > mod:\n                    c[i][j] %= mod\n    return c\ndef power(val, p, mod):\n    ans = [[1 if j == i else 0 for j in range(len(val))] for i in range(len(val))]\n    while p:\n        if p & 1:\n            ans = mul(ans, val, mod)\n        val = mul(val, val, mod)\n        p >>= 1\n    return ans;\nn, f1, f2, f3, x = list(map(int, input().split()))\nn -= 1\nmod = 1000000007\nb1 = [[0], [0], [1]]\nb2 = [[0], [1], [0]]\nb3 = [[1], [0], [0]]\nbc = [[0], [0], [0], [4], [1]]\nm1 = m2 = m3 = [[1, 1, 1], [1, 0, 0], [0, 1, 0]]\nmc = [\n    [1, 1, 1, 2, -6], \n    [1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 1],\n    [0, 0, 0, 0, 1]\n]\na = pow(f1, mul(power(m1, n - 2, mod - 1), b1, mod - 1)[0][0], mod)\nb = pow(f2, mul(power(m2, n - 2, mod - 1), b2, mod - 1)[0][0], mod)\nc = pow(f3, mul(power(m3, n - 2, mod - 1), b3, mod - 1)[0][0], mod)\nprint(pow(x, mul(power(mc, n - 2, mod - 1), bc, mod - 1)[0][0], mod) * a * b * c % mod)\n", "def mat_pow(mat, count):\n    res = mat\n    for x in map(int, bin(count)[3:]):\n        res = mat_mat_mul(res, res)\n        if x:\n            res = mat_mat_mul(res, mat)\n    return res\n    \ndef mat_mat_mul(mat1, mat2):\n    nonlocal mod\n    d = len(mat1)\n    res = []\n    for row in range(d):\n        res.append([])\n        for col in range(d):\n            cur = 0\n            for i in range(d):\n                cur += mat1[row][i] * mat2[i][col]\n                cur %= mod - 1\n            res[-1].append(cur)\n    return res\n    \ndef mat_vec_mul(mat, vec):\n    nonlocal mod\n    res = []\n    for row in mat:\n        cur = 0\n        for r, c in zip(row, vec):\n            cur += r * c\n            cur %= mod - 1\n        res.append(cur)\n    return res\n\nmod = 10**9 + 7\n\nn, x1, x2, x3, c = list(map(int, input().split()))\n\n# [n-2, n-1, n]\nx1_init = [1, 0, 0]\nx1_mat = [\n    [0, 1, 0],\n    [0, 0, 1],\n    [1, 1, 1]\n]\n\n# [n-2, n-1, n]\nx2_init = [0, 1, 0]\nx2_mat = x1_mat\n\n# [n-2, n-1, n]\nx3_init = [0, 0, 1]\nx3_mat = x1_mat\n\n# [count_n-2, count_n-1, count_n, n, 1]\nc_init = [0, 0, 0, 3, 1]\nc_mat = [\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [1, 1, 1, 2, -4],\n    [0, 0, 0, 1, 1],\n    [0, 0, 0, 0, 1]\n]\n\nx1_count = mat_vec_mul(mat_pow(x1_mat, n-1), x1_init)[0]\nx2_count = mat_vec_mul(mat_pow(x2_mat, n-1), x2_init)[0]\nx3_count = mat_vec_mul(mat_pow(x3_mat, n-1), x3_init)[0]\nc_count = mat_vec_mul(mat_pow(c_mat, n-1), c_init)[0]\n\nans = pow(c, c_count, mod) * pow(x1, x1_count, mod) * pow(x2, x2_count, mod) * pow(x3, x3_count, mod)\nans %= mod\nprint(ans)\n"]
["import math\nn,m,k=map(int,input().split())\nout=1\nfor i in range(k):\n    out*=(m-1)\n    out%=998244353\nout*=m\nout%=998244353\nout*=(math.factorial(n-1)//math.factorial(k)//math.factorial(n-1-k))\nout%=998244353\nprint(out)", "MOD = 998244353\n\nlist_size = 2100\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\ndef power(n, x):\n\tif x == 1:\n\t\treturn n\n\telif x % 2 == 0:\n\t\treturn power(int((n * n) % MOD), int(x / 2))\n\telse:\n\t\treturn int((n * power(n, x - 1)) % MOD)\n\nf_r_list[-1] = power(f_list[-1], MOD - 2)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn, m, k = map(int, input().split())\nprint((m * (m-1) ** k) % MOD * comb(n-1, k) % MOD)", "m = list(map(int,input().split(' ')))\na = m[0]\nb = m[1]\nc = m[2]\nways = 1\ndef fact(n):\n    a = 1\n    for i in range(2,n+1):\n        a *= i\n    return a\ndef p(r,n):\n    return fact(n)//fact(r)\ndef entekhab(r,n):\n    return p(r,n)//fact(n-r)\nways *= b\na -= 1\nways *= entekhab(c,a)\nways *= (b-1)**c\nprint(ways%998244353)\n", "import sys\ninput = sys.stdin.readline\nmod=998244353\n\nn,m,k=list(map(int,input().split()))\n\nN=n-1\nINV=[None]*(n+1)#1/a\u306e\u30ea\u30b9\u30c8\u3092\u4e88\u3081\u4f5c\u3063\u3066\u304a\u304f.\nfor i in range(1,n+1):\n    INV[i]=pow(i,mod-2,mod)\n\n#nCk\u306f\u3001n\u3082\u3057\u304f\u306fk\u304c\u56fa\u5b9a\u306e\u5834\u5408\u306f\u30ea\u30b9\u30c8\u3067\u4f5c\u308b\n\nCombi=[None]*(N+1)#Combi[i]=nCi \u3092\u8868\u3059\nCombi[0]=1\nfor i in range(1,N+1):\n    Combi[i]=Combi[i-1]*(N-i+1)*INV[i] %mod\n\n\n\n\n\nANS=Combi[k]%mod *m %mod *pow(m-1,k,mod)%mod\nprint(ANS)\n", "import math\n\ndef modi(a,m) : \n\treturn pow(a,m-2,m)\n\n\ndef __starting_point():\n\n\tn,m,k = [int(x) for x  in input().split()]\n\tmod = 998244353 \n\n\n\tans  = 1\n\n\tfor i  in range(k) : \n\t\tans *= (n-1-i)%mod\n\t\tans = ans %mod\n\tfor i in range(1,k+1) :\n\t\tans *= modi(i,mod)%mod\n\t\tans  = ans %mod\n\tans *= m\n\tans = ans %mod\n\n\tans  *= pow(m-1,k,mod)%mod\n\tans  = ans%mod\n\tprint (ans)\n\n\n\n\n__starting_point()", "P = 998244353\ndef C(n, k):\n    nonlocal P\n    k = min(k, n-k)\n    p = 1\n    for i in range(n, n-k, -1):\n        p *= i\n    for i in range(k, 0, -1):\n        assert(p%i==0)\n        p //= i\n    return p%P\n\nn, m, k = list(map(int, input().split()))\n\nr = C(n-1, k)\nr = (r*m)%P\nfor i in range(k):\n    r = (r*(m-1))%P\nprint(r)\n\n", "def fact(n):\n    q=1;\n    for i in range(1,n+1):\n        q*=i\n    return q\n\nn,m,k=input().split()\nn=int(n)\nm=int(m)\nk=int(k)\ncom=fact(n-1)//(fact(k)*fact(n-1-k))\ndd=m*((m-1)**k)\nprint((com*dd) % 998244353)", "import sys\n\nMOD = 998244353\n\nn,m,k = list(map(int, input().strip().split()))\n\nmemo = dict()\n\ndef C(n,m,k, first):\n    if n == 0:\n        if k == 0:\n            return 1\n        else:\n            return 0\n    if k == 0:\n        if first:\n            return m\n        else:\n            return 0\n    \n    if (n,m,k, first) in memo:\n        return memo[n,m,k, first]\n    \n    vseh = 0\n\n    if first:\n        for i in range(n):\n            vseh += m*C(i,m,k,False)\n    else:\n        for i in range(n):\n            vseh += (m-1)*C(i,m,k-1,False)\n    \n    memo[n,m,k,first] = vseh % MOD\n    return memo[n,m,k,first]\n\ndef C2(n,m,k):\n    matrika = [[0 for _ in range(n+1)] for _ in range(k+1)]\n    matrika[0][0] = 1\n    for j in range(1, k + 1):\n        acc = 0\n        for a in range(1, n+1):\n            acc += (m-1)*matrika[j-1][a-1]\n            matrika[j][a] = acc % MOD\n    \n    result = m*sum(matrika[k][:-1])\n\n    return result % MOD\n\nprint(C2(n,m,k))\n\n\n    \n\n", "n, m, k = list(map(int, input().split()))\nmod = 998244353\ndp = [[0] * (k + 1) for i in range(n)]\ndp[0][0] = m\nfor i in range(1, n):\n    for j in range(k + 1):\n        dp[i][j] = dp[i - 1][j]\n        if j > 0:\n            dp[i][j] += dp[i - 1][j - 1] * (m - 1)\n        dp[i][j] %= mod\nprint(dp[n-1][k])\n", "n, m, k = list(map(int, input().split()))\nans = 1\nfor i in range(1, k + 1):\n    ans *= n - i\nfor i in range(k, 0, -1):\n    ans //= i\nans = ans * m % 998244353\nfor i in range(k):\n    ans = ans * (m - 1) % 998244353\nprint(ans)\n", "Z = 998244353\n\n\ndef ncr(n, r):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % Z\n        den = (den * (i + 1)) % Z\n\n    return (num * pow(den, Z - 2, Z)) % Z\n\n\nn, m, k = list(map(int, input().split()))\n\nprint((ncr(n - 1, k) * m * pow(m - 1, k, Z)) % Z)\n", "import operator as op\nfrom functools import reduce\n\ndef ncr(z, r):\n    r = min(r, z-r)\n    numer = reduce(op.mul, range(z, z-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer //  denom\n\n\nn,m,k = list(map(int, input().strip().split()))\nmod = 998244353;\nif m ==1:\n    if k==0:\n        print(1);\n    else:\n        print(0);\nelif n == 1:\n    print(m)\nelse:\n    ans = m * ((m-1)**k)\n    ans = ans % mod;\n    c= ncr(n-1,k) % mod\n    ans = ans * c;\n    ans = ans % mod;\n    print(ans)", "import math\n\nn, m, k = [int(x) for x in input().split()]\nif k == 0:\n    ar = m\nelse:\n    a = m * (math.factorial(n-1) // (math.factorial(k) * math.factorial(n-1-k))) * ((m-1)**k)\n    ar = a % 998244353\nprint(ar)\n", "n, m, k = list(map(int, input().split()))\nmod = 998244353\n\nsame_bricks = n - 1 - k\ntotal = m # First brick\n# Different bricks\nfor i in range(k):\n\ttotal *= (m-1)\n\ttotal %= mod\n\n# Choosing same bricks\n# times (n-1 choose k)\nval = 1\nfor i in range(n - k, n):\n\tval *= i\n\nfor i in range(1, k+1):\n\tval //= i\n\ntotal *= val\ntotal %= mod\nprint(total)\n", "s=input().split()\nn,m,k=list(map(int,s))\nMOD=998244353\nans=m\nfor i in range(k):\n    ans=(ans*(m-1))%MOD\nif k>n//2:\n    k=n-1-k\nfor i in range(1,k+1):\n    ans=ans*(n-1-k+i)//i\nprint(ans%MOD)", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ndef e_gcd(a, b ):\n    if a==0 and b==0:\n        return -1, 0, 0\n    if b==0:\n        return a, 1,0\n    d, y,x = e_gcd(b, a%b )\n    y-=  a //b *x\n    return d , x,y\n\ndef m_reverse(a,n):\n    d,x,y = e_gcd(a,n)\n    dprint(x,y,a,n)\n    assert x*a + y*n == d\n    if d==1:\n        if x%n<=0:\n           return x%n+n\n        else:\n            return x%n\n    else:\n        return -1\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\n    \nbase = 998244353\nd = 1233\nt = m_reverse( d, base)\ndprint(t)\nz = t * d % base\ndprint(z)\nN, M, K= getIntList()\n\n\n\nJ = N-1 - K   # same\n\nZ = N - J\ndprint(Z)\nR = M\nfor i in range(Z-1):\n    R *= M-1\n    R%= base\ndprint(R)\nn0 = J\nm0 = Z\ndprint(n0,m0)\n#comb(n0 + m0 -1, m0-1)\nfor i in range(m0 -1):\n    g = n0 + m0 -1  -i\n    R*= g\n    R%= base\n\n\n\nfor i in range(2, m0):\n    t = m_reverse(i,base)\n    R*=t\n    R%=base\n\nprint(R)\n    \n\n\n\n", "from operator import mul\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(mul, range(n, n-r, -1), 1)\n    denom = reduce(mul, range(1, r+1), 1)\n    return numer // denom\n\ndef mult(a,b):\n    return (a*b) % mod\n\nn,m,k = map(int, input().split())\nmod = 998244353\nans = 1\nans = mult(ans, (m-1)**k)\nans = mult(ans, m)\nans = mult(ans, ncr(n-1, k))\n\nprint(ans)", "MOD = 998244353\nn, m, k = list(map(int, input().split()))\na = [1]\nfor _ in range(n - 1):\n\ta = [sum(x) % MOD for x in zip([0] + a, a + [0])]\nprint((m * pow(m - 1, k, MOD) * a[k]) % MOD)\n", "n, m, k = map(int, input().split())\nans = 1\nfor i in range(k):\n\tans *= (n - 1 - i)\n\tans //= (i + 1)\nprint((ans * m * (m - 1) ** k) % 998244353)", "n,m,k = map(int, input().split())\nimport math\nprint((math.factorial(n-1) // math.factorial(n-k-1) // math.factorial(k) * m * (m-1) ** k) % 998244353)", "MOD = 998244353\nn, m, k = input().split()\n\nn = int(n)\nm = int(m)\nk = int(k)\n\n# Taken from https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\ndef nCr(n , k):\n    C = [0 for i in range(k+1)]\n    C[0] = 1\n\n    for i in range(1,n+1):\n        j = min(i ,k)\n        while (j>0):\n            C[j] = C[j] + C[j-1]\n            j -= 1\n    return C[k]\n\nanswer = m * nCr(n-1, k) * (m-1)**k\nprint(answer%MOD)\n", "'''input\n3 2 1\n6 3 2\n5 3 0\n3 3 1\n3 3 0\n'''\nn, m, k = list(map(int, input().split()))\nMOD  = 998244353\nans = m * pow(m - 1, k, MOD) % MOD\n'''\nfor i in range(k + 1):\n\tif i & 1:\n\t\tans -= m * pow(m - 1, k - i, MOD)\n\telse:\n\t\tans += m * pow(m - 1, k - i, MOD)\n'''\n\n\nfor i in range(n - k, n):\n\tans = ans * i\nfor i in range(n - k, n):\n\t# print(n - 1 - i)\n\tans = ans // (n - i)\n'''\nfor i in range(1, k + 1):\n\tprint(ans)\n\tans = ans * (n - 1 - i) * pow(i, MOD - 2, MOD) % MOD\n'''\nprint(ans % MOD)\n", "\nmod=998244353\ndef nCrModp(n, r): \n  \n    # The array C is going to store last row of \n    # pascal triangle at the end. And last entry \n    # of last row is nCr. \n    C = [0 for i in range(r+1)] \n  \n    C[0] = 1 # Top row of Pascal Triangle \n  \n    # One by constructs remaining rows of Pascal \n    # Triangle from top to bottom \n    for i in range(1, n+1): \n  \n        # Fill entries of current row  \n        # using previous row values \n        for j in range(min(i, r), 0, -1): \n  \n            # nCj = (n - 1)Cj + (n - 1)C(j - 1) \n            C[j] = (C[j] + C[j-1]) % mod\n  \n    return C[r]\n\nn,m,k=map(int,input().split())\nif(m==1 and k>0):\n    print(0)\nelse:\n    ans=m\n    ans=((ans%mod)*(pow(m-1,k,mod)%mod))%mod\n    val1=nCrModp(n-1,k)\n    ans=((ans%mod)*(val1%mod))%mod\n    print(ans)", "from math import factorial\nn, m, k = list(map(int, input().split()))\nif k == 0:\n    print(m)\nelse:\n    try:\n        print(m*(m-1)**k*(factorial(n-1)//(factorial(k)*factorial(n-k-1))) % 998244353)\n    except:\n        print(0)\n", "import sys\nfrom math import ceil, floor, factorial\nimport operator as op\nfrom functools import reduce\n\ninput = sys.stdin.readline\n\ndef ncr(n,r):\n    f = factorial\n    return (f(n) // f(r) // f(n-r)) % 998244353\n\nn, m, k = map(int, input().split())\n\nif k >= n:\n    print(0)\n    return\n\ncolorings = m\nfor i in range(k):\n    colorings *= (m-1)\n    colorings %= 998244353 \n\nprint(int(((ncr(n-1, k) % 998244353) * colorings) % 998244353) % 998244353)"]
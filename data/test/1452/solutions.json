["from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nH,W = inpl()\nrr = inpl()\ncc = inpl()\n\nMAP = [[-1]*W for _ in range(H)]\n\nfor x,c in enumerate(cc):\n    for y in range(c):\n        MAP[y][x] = 1\n    if c < H:\n        MAP[c][x] = 0\n\n\nfor y,r in enumerate(rr):\n    for x in range(r):\n        if MAP[y][x] == 0:\n            print(0)\n            return\n        MAP[y][x] = 1\n    if r < W:\n        if MAP[y][r] == 1:\n            print(0)\n            return\n        MAP[y][r] = 0\n\ncnt = 0\nfor y in range(H):\n    for x in range(W):\n        if MAP[y][x] == -1:\n            cnt += 1\n\nprint(pow(2,cnt,mod))\n", "h, w = list(map(int, input().split()))\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\na = [[0] * w for i in range(h)]\nfor i in range(h):\n    if r[i] < w:\n        a[i][:r[i] + 1] = [1] * r[i] + [-1]\n    else:\n        a[i] = [1] * w\nfor j in range(w):\n    for i in range(c[j]):\n        if a[i][j] == -1:\n            print(0)\n            break\n        a[i][j] = 1\n    else:\n        if c[j] < h:\n            if a[c[j]][j] == 1:\n                print(0)\n                break              \n            a[c[j]][j] = -1\n        continue\n    break\nelse:\n    cnt0 = sum([row.count(0) for row in a])\n    print(2 ** cnt0 % 1000000007)", "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\ndef write(*args, sep=\"\\n\"):\n  for i in args:\n    sys.stdout.write(\"{}\".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nr, c = list(map(int, input().split()))\n\nrow = list(map(int, input().split()))\ncolumn = list(map(int, input().split()))\narr = [ [-1] * (c + 1) for i in range(r + 1) ]\n\nfor i in range(r):\n  for j in range(row[i]):\n      arr[i][j] = 1\n    \n  arr[i][row[i]] = 0\n\n  #print(arr, \"!\")\n\nfor j in range(c):\n  #print(arr)\n  for i in range(column[j]):\n    if arr[i][j] != 0:\n      arr[i][j] = 1\n    else:\n      print(0)\n      return\n  \n  if arr[column[j]][j] == 1:\n    print(0)\n    return\n  \n  arr[column[j]][j] = 0\n\ncnt = 0\nfor i in range(r):\n  for j in range(c):\n    cnt += (arr[i][j] == -1)\n\n#print(\"???\", cnt)\nprint(pow(2, cnt, MOD))\n", "import sys\ninput = sys.stdin.readline\n\nh,w=list(map(int,input().split()))\nR=list(map(int,input().split()))\nC=list(map(int,input().split()))\n\nmod=10**9+7\n\nANS=[[0]*w for i in range(h)]\n\nfor i in range(h):\n    for j in range(R[i]):\n        ANS[i][j]=1\n\n    if R[i]!=w:\n        ANS[i][R[i]]=2\n\n#print(ANS)\n\nfor i in range(w):\n    for j in range(C[i]):\n        if ANS[j][i]==2:\n            print(0)\n            return\n        ANS[j][i]=1\n\n    if C[i]!=h:\n        if ANS[C[i]][i]==1:\n            print(0)\n            return\n            \n        ANS[C[i]][i]=2\n\ncount=0\nfor i in range(h):\n    for j in range(w):\n        if ANS[i][j]==0:\n            count+=1\n\nprint(pow(2,count,mod))\n", "h, w = list(map(int,input().split()))\n\nr = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\nl = [-1] * (h * w)\n\nfor i in range(h):\n    tiles = r[i]\n\n    for j in range(tiles):\n        l[w * i + j] = 1\n\n    if tiles < w:\n        l[w * i + tiles] = 0\n\nout = 1\nfor j in range(w):\n    tiles = c[j]\n\n    for i in range(tiles):\n        pos = w * i + j\n        if l[pos] == 0:\n            out = -1\n            break\n        l[pos] = 1\n\n    if tiles < h:\n        pos = w * (tiles) + j\n        if l[pos] == 1:\n            out = -1\n            break\n        l[pos] = 0\n\nM = 10**9+7\n\nif out == -1:\n    print(0)\nelse:\n    count = 0\n    for i in l:\n        if i == -1:\n            count += 1\n    print(pow(2,count,M))\n", "H, W = list(map(int, input().split()))\nR = [int(a) for a in input().split()]\nC = [int(a) for a in input().split()]\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if (R[i] == j and C[j] > i) or (R[i] > j and C[j] == i):\n            print(0)\n            return\n        if R[i] < j and C[j] < i:\n            ans += 1\nprint(pow(2, ans, 10**9+7))\n\n\n\n", "h,w=map(int,input().split())\nr=list(map(int,input().split()))\nc=list(map(int,input().split()))\nmat=[None]*h\nans=1\nfor i in range(h):\n    mat[i]=[-1]*w\nfor i in range(h):\n    for j in range(r[i]):\n        mat[i][j]=0\n    if r[i]<w:\n        mat[i][r[i]]=1\nfor j in range(w):\n    for i in range(c[j]):\n        if(mat[i][j]==1):\n            ans=0\n        mat[i][j]=0\n    if c[j]<h:\n        if(mat[c[j]][j]==0):\n            ans=0\n        mat[c[j]][j]=1\nfor i in mat:\n    for j in i:\n        if j==-1:\n            ans=(2*ans)%1000000007\nprint(ans)", "h, w = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nunset = h * w\n\nfield = [[-1] * w for _ in range(h)]\n\nfor i in range(h):\n    x = r[i]\n    row = field[i]\n    for j in range(x):\n        if row[j] == -1:\n            unset -= 1\n        row[j] = 1\n    if x < w:\n        if row[x] == -1:\n            unset -= 1\n        row[x] = 0\n\nfor i in range(w):\n    x = c[i]\n    for j in range(x):\n        if field[j][i] == -1:\n            unset -= 1\n        elif field[j][i] == 0:\n            print(0)\n            return\n        field[j][i] = 1\n    if x < h:\n        if field[x][i] == -1:\n            unset -= 1\n        elif field[x][i] == 1:\n            print(0)\n            return\n        field[x][i] = 0\n\nprint(pow(2, unset, 10 ** 9 + 7))\n\n", "h, w = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ngrid = [[-1]*w for i in range(h)]\nfor i in range(h):\n    if a[i] == 0:\n        grid[i][0] = 0\n        continue\n    for j in range(a[i]):\n        grid[i][j] = 1\n    if 0 <= a[i] < w:\n        grid[i][a[i]] = 0\n\nfor j in range(w):\n    if b[j] == 0:\n        if grid[0][j] != 1:\n            grid[0][j] = 0\n        else:\n            print(0)\n            return\n        continue\n    for i in range(b[j]):\n        if grid[i][j] != 0:\n            grid[i][j] = 1\n        else:\n            print(0)\n            return\n    if 0 <= b[j] < h:\n        if grid[b[j]][j] != 1:\n            grid[b[j]][j] = 0\n        else:\n            print(0)\n            return\n\nMOD = 10**9 + 7\nans = 1\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == -1:\n            ans *= 2\n            ans %= MOD\nprint(ans)", "h, w = list(map(int, input().split()))\ngrid = [[-1 for i in range(w)] for j in range(h)]\n\nisValid = True\n\nrs = list(map(int, input().split()))\nfor y in range(h):\n    for j in range(rs[y]):\n        grid[y][j] = 1\n    if rs[y] != w:\n        grid[y][rs[y]] = 0\n\ncs = list(map(int, input().split()))\nfor x in range(w):\n    for j in range(cs[x]):\n        if grid[j][x] == 0:\n            isValid = False\n        grid[j][x] = 1\n    if cs[x] != h:\n        if grid[cs[x]][x] == 1:\n            isValid = False\n        grid[cs[x]][x] = 0\n\ntotal = 1\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == -1:\n            total *= 2\n            total %= 1000000007\n\nif isValid:\n    print(total)\nelse:\n    print(0)\n", "MOD = 1000000007\n\nh, w = map(int, input().split())\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\nm = [[None]*w for _ in range(h)]\nfor i in range(h):\n\tfor j in range(r[i]):\n\t\tm[i][j] = True\n\tif r[i] < w: m[i][r[i]] = False\nfor j in range(w):\n\tfor i in range(c[j]):\n\t\tif m[i][j] == False:\n\t\t\tprint(0)\n\t\t\treturn\n\t\tm[i][j] = True\n\tif c[j] < h:\n\t\tif m[c[j]][j] == True:\n\t\t\tprint(0)\n\t\t\treturn\n\t\tm[c[j]][j] = False\nres = 1\nfor i in range(h):\n\tfor j in range(w):\n\t\tif m[i][j] == None:\n\t\t\tres = (res*2) % MOD\nprint(res)", "modus = 1000000007\n\nR, C = map(int, input().split())\n\nr_lst = list(map(int, input().split()))\nc_lst = list(map(int, input().split()))\n\nM = [[-1 for j in range(C)] for i in range(R)]\n\nimpossible = False\nfor i, r in enumerate(r_lst):\n\n\tfor index in range(r):\n\t\tM[i][index] = 1\n\n\tif r != C:\n\t\tM[i][r] = 0\n\nfor i, c in enumerate(c_lst):\n\n\tfor index in range(c):\n\t\tif M[index][i] == 0:\n\t\t\timpossible = True\n\t\t\tbreak\n\n\t\tM[index][i] = 1\n\n\tif impossible:\n\t\tbreak\n\n\tif c != R:\n\n\t\tif M[c][i] == 1:\n\t\t\timpossible = True\n\t\t\tbreak\n\n\t\tM[c][i] = 0\n\nif impossible:\n\tprint(0)\nelse:\n\tcount = 0\n\tfor i in range(R):\n\t\tfor j in range(C):\n\t\t\tif M[i][j] == -1:\n\t\t\t\tcount += 1\n\n\tresult = pow(2, count, modus)\n\tprint(result)", "h, w = list(map(int, input().split()))\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\ntable = [[-1]*w for i in range(h)]\n\nfor i, row in enumerate(r):\n    for j in range(row):\n        table[i][j] = 1\n    if row < w:\n        table[i][row] = 0\n\n\nfor j, col in enumerate(c):\n    for i in range(col):\n        if table[i][j] == 0:\n            print(0)\n            return\n        table[i][j] = 1\n    if col < h:\n        if table[col][j] == 1:\n            print(0)\n            return\n        table[col][j] = 0\n\nres = 1\n\nfor i in range(h):\n    for j in range(w):\n        if table[i][j] == -1:\n            res = (res*2)%1000000007\n\nprint(res)\n", "\nrows, cols = list(map(int, input().split()))\n\na = [[-1] * cols for _ in range(rows)]\n\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# print(np.matrix(a))\n\n\nfor row in range(rows):\n  for col in range(r[row]):\n    a[row][col] = 1\n  \n  if(r[row] < cols):\n    a[row][r[row]] = 0 \n\n# print(np.matrix(a))\n\n\nfor col in range(cols):\n  for row in range(c[col]):\n    a[row][col] = 1\n  \n  if(c[col] < rows):\n    a[c[col]][col] = 0 \n\n# print(np.matrix(a))\n\nisSol = True\n\nfor row in range(rows):\n  for col in range(r[row]):\n    if a[row][col] != 1 :\n      isSol = False\n\n  \n  if(r[row] < cols):\n    if a[row][r[row]] != 0:\n      isSol = False\n\nfor col in range(cols):\n  for row in range(c[col]):\n    if(a[row][col] != 1):\n      isSol = False\n  \n  if(c[col] < rows):\n    if (a[c[col]][col] != 0):\n      isSol = False\n\nif(isSol):\n  sol = 1\n\n  for row in a:\n    for i in row:\n      if(i == -1):\n        sol = (sol * 2) % 1000000007\n  \n  print(sol)\nelse:\n  print(0)\n\n\n", "h,w=[int(x) for x in input().split()]\na=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\ntab=[[0]*w for i in range(h)]\narr=0\nfor i in range(h):\n    if a[i]==0:\n        tab[i][0]=2\n    else:\n        for j in range(a[i]):\n            tab[i][j]=1\n        if a[i]<w:\n            tab[i][a[i]]=2\nfor i in range(w):\n    if b[i]==0:\n        if tab[0][i]==1:\n            print(0)\n            return\n        tab[0][i]=2\n    else:\n        for j in range(b[i]):\n            if tab[j][i]==2:\n                print(0)\n                return\n            tab[j][i]=1\n        if b[i]<h:\n            if tab[b[i]][i]==1:\n                print(0)\n                return\n            tab[b[i]][i]=2\nfor i in range(h):\n    for j in range(w):\n        if tab[i][j]==0:\n            arr+=1\nprint(pow(2,arr,(10**9+7)))\n        \n               \n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    H, W = map(int, input().split())\n    R = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n\n    grid1 = [[-1]*W for _ in range(H)]\n    grid2 = [[-1]*W for _ in range(H)]\n\n    for i, r in enumerate(R):\n        for j in range(r):\n            grid1[i][j] = 1\n        if r <= W-1:\n            grid1[i][r] = 0\n\n    for i, c in enumerate(C):\n        for j in range(c):\n            grid2[j][i] = 1\n        if c <= H-1:\n            grid2[c][i] = 0\n\n    ok = True\n    prob = 0\n    for h in range(H):\n        for w in range(W):\n            if grid1[h][w] == -1 and grid2[h][w] == -1:\n                prob += 1\n            elif grid1[h][w] == -1 or grid2[h][w] == -1:\n                continue\n            elif grid1[h][w] != grid2[h][w]:\n                ok = False\n\n    if not ok:\n        print(0)\n    else:\n        mod = int(1E9+7)\n        ans = 1\n        for _ in range(prob):\n            ans = ans * 2 % mod\n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "'''\nCreated on 2019. 9. 21.\n\n@author: kkhh88\n'''\n'''\na, b = map(int,input().split(' '))\n\nt = 0\n\nfor i in range(a, b+1):\n    x = [0] * 10\n    n = i\n    while n:\n        x[n%10] = x[n%10] + 1\n        n = n // 10\n    n = 0\n    for n in range(10):\n        if x[n] > 1:\n            break\n    \n    if n == 9 and x[n] < 2:\n        print (i)\n        t = 1\n        break\n    \nif t == 0:\n    print (-1)\n'''\n\nh, w = list(map(int,input().split(' ')))\nr = list(map(int,input().split(' ')))\nc = list(map(int,input().split(' ')))\n\ncnt = 0\nx = [[-1 for _ in range(w)] for _ in range(h)]\nfor i in range(w):\n    for j in range(c[i]):\n        if x[j][i] == 1 or x[j][i] == -1:\n            x[j][i] = 1\n        else:\n            cnt = -1\n            break\n    if cnt < 0:\n        break\n    if c[i] < h:\n        if x[c[i]][i] == 0 or x[c[i]][i] == -1:\n            x[c[i]][i] = 0\n        else:\n            cnt = -1\n            break\n\nfor i in range(h):\n    for j in range(r[i]):\n        if x[i][j] == 1 or x[i][j] == -1:\n            x[i][j] = 1\n        else:\n            cnt = -1\n            break\n    if cnt < 0:\n        break\n    if r[i] < w:\n        if x[i][r[i]] == 0 or x[i][r[i]] == -1:\n            x[i][r[i]] = 0 \n        else:\n            cnt = -1\n            break\n\nif cnt < 0:\n    print(0)\nelse:\n    for i in range(w):\n        for j in range(h):\n            if x[j][i] == -1:\n                cnt = cnt + 1\n    print((1<<cnt) % 1000000007)\n", "h, w = list(map(int, input().split()))\nrows = list(map(int, input().split()))\ncols = list(map(int, input().split()))\nmatrix = [None] * h\nanswer = 0\nfound = False\nfor i in range(h):\n    matrix[i] = [-1] * w\nfor i in range(h):\n    r = rows[i]\n    if r == 0:\n        matrix[i][0] = 0\n    else:\n        for j in range(r):\n            matrix[i][j] = 1\n        if r < w:\n            matrix[i][r] = 0\nfor i in range(w):\n    c = cols[i]\n    if c == 0:\n        if matrix[0][i] == 1:\n            found = True\n        matrix[0][i] = 0\n    else:\n        for j in range(c):\n            if matrix[j][i] == 0:\n                found = True\n                break\n            matrix[j][i] = 1\n        if c < h:\n            if matrix[c][i] == 1:\n                found = True\n            matrix[c][i] = 0\nif not found:\n    cnt = 0\n    for i in range(h):\n        for j in range(w):\n            if matrix[i][j] < 0:\n                cnt += 1\n    answer = (2 ** cnt) % 1000000007\nprint(answer)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    h, w = get_tuple()\n    hi = get_list()\n    wi = get_list()\n    mat = [[0 for _ in range(w)] for _ in range(h)]\n    i, j = 0,0\n    for i, ele in enumerate(hi):\n        for j in range(0, ele):\n            mat[i][j] = 1\n        if ele<w: mat[i][ele]=-1\n    #[print(li) for li in mat]\n    for i, ele in enumerate(wi):\n        for j in range(0, ele):\n            if mat[j][i]==-1:\n                print(0)\n                return\n            mat[j][i] = 1\n        if ele<h:\n            if mat[ele][i]==1:\n                #print(ele, i)\n                print(0)\n                return\n            mat[ele][i]=-1\n    #[print (li) for li in mat]\n    res = 1\n    for li in mat:\n        for i in li:\n            if i==0:\n                res = (res*2)%P\n    print(res)\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "rt, ct = map(int, input().split())\ngrid = [[-1 for x in range(ct)] for y in range(rt)]\n\nrows = list(map(int, input().split()))\ncols = list(map(int, input().split()))\n\ncan = True\nfor r in range(len(rows)):\n\trc = rows[r];\n\tfor i in range(rc):\n\t\tif(grid[r][i] == 0):\n\t\t\tcan = False\n\t\t\tbreak\n\t\tgrid[r][i] = 1\n\tif (rc < ct):\n\t\tif (grid[r][rc] == 1):\n\t\t\tcan = False\n\t\t\tbreak\n\t\tgrid[r][rc] = 0\n\t\nfor c in range(len(cols)):\n\tif(not can):\n\t\tbreak\n\tcc = cols[c];\n\tfor i in range(cc):\n\t\tif(grid[i][c] == 0):\n\t\t\tcan = False\n\t\t\tbreak\n\t\tgrid[i][c] = 1\n\tif (cc < rt):\n\t\tif(grid[cc][c] == 1):\n\t\t\tcan = False\n\t\t\tbreak\n\t\tgrid[cc][c] = 0\n\nif(not can):\n\tprint(0)\nelse:\n\tcnt = 0\n\tfor i in range(len(grid)):\n\t\trow = grid[i]\n\t\tfor j in row:\n\t\t\tif (j == -1):\n\t\t\t\tcnt += 1\n\tprint(pow(2,cnt, (10**9+7)))", "h, w = tuple(map(int, input().split()))\n\narr = [['r'] * w for i in range(h)]\n\nH = list(map(int, input().split()))\nfor i, j in enumerate(H):\n    arr[i][:j] = ['b'] * j\n    if j < w:\n        arr[i][j] = 'w'\n\nW = list(map(int, input().split()))\nerror = False\nfor i, j in enumerate(W):\n    for k in range(j):\n        if arr[k][i] == 'w':\n            error = True\n            break\n        else:\n            arr[k][i] = 'b'\n    if j < h and arr[j][i] == 'b':\n        error = True\n        break\n    elif j < h:\n        arr[j][i] = 'w'\n\n#for i in arr:\n#    print(*i)\n\nif error:\n    print(0)\nelse:\n    count = 0\n    for i in arr:\n        count += i.count('r')\n    print((2 ** count) % (10 ** 9 + 7))\n", "mod = 1000000007\nres = 1\nh, w = list(map(lambda x:int(x),input().split()))\npole = [[0 for x in range(w)] for y in range(h)]\nrs = list(map(lambda x:int(x),input().split()))\nls = list(map(lambda x:int(x),input().split()))\nfor i in range(h):\n    for x in range(rs[i]):\n        pole[i][x] = 1\n    if rs[i] != w:\n        pole[i][rs[i]] = -1\n#print(pole)\nfor i in range(w):\n    for y in range(ls[i]):\n        if pole[y][i] == -1:\n            print(0)\n            return\n        else:\n            pole[y][i] = 1\n    if ls[i] != h:\n        if pole[ls[i]][i] == 1:\n            print(0)\n            return\n        pole[ls[i]][i] = -1\nfor y in pole:\n    for x in y:\n        if x == 0:\n            res<<=1\n            res = res % mod\nprint(res)", "h,w = list(map(int,input().split()))\n'''arr = [[0] * w for i in range(h)]\narr[0] = [1] * w\nfor i in range(1,h):\n    arr[i][0] = 1'''\nmod = 1000000007\narrr = list(map(int,input().split()))\narrc = list(map(int,input().split()))\n\nans = 1\nfor i in range(h):\n    for j in range(w):\n        if j > arrr[i]:\n            break\n        elif j == arrr[i]:\n            if arrc[j] > i:\n                ans = 0\n                break\n        elif arrc[j] == i:\n            ans = 0\n            break\n    if ans == 0:\n        break\nelse:\n    for j in range(w):\n        for i in range(h):\n            if i > arrc[j]:\n                break\n            elif i == arrc[j]:\n                if arrr[i] > j:\n                    ans = 0\n                    break\n            elif arrr[i] == j:\n                ans = 0\n                break\n        if ans == 0:\n            break\nif ans == 1:\n    for i in range(1,h):\n        for j in range(1,w):\n            if j > arrr[i] and i > arrc[j]:\n                #print(i,j)\n                ans *= 2\n                if ans > mod:\n                    ans -= mod\nprint(ans)\n\n\n", "def main():\n    from array import array\n    import sys\n    h, w = map(int, sys.stdin.readline().split())\n    grid = tuple((tuple((array('b', (0,)) for _ in range(w))) for _ in range(h)))\n    ans = h * w\n    arr1 = array('b', (1,))\n    for _ in range(2):\n        for row, r in zip(grid, map(int, sys.stdin.readline().split())):\n            arr1r = arr1 * r\n            arr1r.append(-1)\n            for elem, value in zip(row, array('b', arr1r)):\n                if not elem[0]:\n                    elem[0] = value\n                    ans -= 1\n                elif elem[0] != value:\n                    return print('0')\n        grid = zip(*grid)\n    return print(pow(2, ans, 1000000007))\n\n\nmain()\n"]
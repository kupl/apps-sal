["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi:\n        mm = (ma+mi) // 2\n        if f(mm):\n            mi = mm + 1\n        else:\n            ma = mm\n    if f(mm):\n        return mm + 1\n    return mm\n\ndef main():\n    n = I()\n    a = LI()\n    b = LI()\n    if b == list(range(1,n+1)):\n        return 0\n\n    ss = set(a)\n    if 1 not in ss:\n        i = b.index(1)\n        bf = 1\n        for j in range(i,n):\n            if b[j] != j - i + 1:\n                bf = 0\n                break\n        if bf:\n            t = b[-1]\n            s = ss | set()\n            for j in range(n-t):\n                if t+j+1 not in s:\n                    bf = 0\n                    break\n                s.add(b[j])\n            if bf:\n                return n - t\n\n    def f(i):\n        s = ss | set(b[:i])\n        for j in range(1,n+1):\n            if j not in s:\n                return True\n            if i + j <= n:\n                s.add(b[i+j-1])\n\n        return False\n\n    r = bs(f,0,n)\n\n    return r + n\n\n\nprint(main())\n\n", "if True:\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    B = [int(a) for a in input().split()]\nelse:\n    A = [0, 0, 0, 5, 0, 0, 0, 4, 0, 0, 11]\n    B = [9, 2, 6, 0, 8, 1, 7, 0, 3, 0, 10]\n    A = [0, 2, 0]\n    B = [3, 0, 1]\n    N = len(A)\ndef chk():\n    i = 0\n    while B[i] != 1:\n        i += 1\n        if i == N:\n            return 0\n    j = i - 1\n    # print(\"k =\", j)\n    while i < N:\n        # print(\"i, B[i], N, k, i-N+k =\", i, B[i], N, j, i-j)\n        if B[i] != i - j:\n            # print(\"DD\")\n            return 0\n        i += 1\n    # print(\"j =\", j)\n    for i in range(j+1):\n        # print(B[i], N+1-j+i)\n        if 0 < B[i] < N+1-j+i:\n            # print(\"EE\")\n            return 0\n    # print(j+1)\n    return j + 2\n\nc = chk()\nif c > 0:\n    print(c - 1)\nelse:\n    # print([max(i-B[i]+2, 0) for i in range(N)])\n    print(max([max(i-B[i]+2, 0) if B[i] else 0 for i in range(N)]) + N)\n", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nainds=[None]*n\nbinds=[None]*n\nfor i in range(n):\n    if a[i]>0:\n        ainds[a[i]-1]=i\n    if b[i]>0:\n        binds[b[i]-1]=i\nif binds[0] is not None:\n    if b[binds[0]:]==[i+1 for i in range(n-binds[0])]:\n        good=True\n        for i in range(n-binds[0],n):\n            if binds[i] is not None:\n                if binds[i]>i-n+binds[0]-1:\n                    good=False\n        if good:\n            print(binds[0])\n        else:\n            print(binds[0]+n+1)\n    else:\n        extra=0\n        for i in range(n):\n            if binds[i] is not None:\n                extra=max(extra,binds[i]-binds[0]-i)\n        print(binds[0]+1+n+extra)\nelse:\n    extra=0\n    for i in range(n):\n        if binds[i] is not None:\n            extra=max(extra,binds[i]-i+1)\n    print(n+extra)", "n=int(input())\na1=list(map(int,input().split()))\na=list(map(int,input().split()))\na=[0]+a\nd=[0]*(n+1);\nmx=0\nfor i in range(1,n+1):\n    d[a[i]]=i\nmx=max(d[i]-i+1 for i in range(1,n+1))\nbr=n-d[1]+1\nb=True\nif(d[1]==0):b=False\nfor i in range(1,n+1):\n    if(i<=br):\n        if(d[i]-d[1]==i-1):\n            continue\n        else:\n            b=False\n            break\n    else:\n        if(d[i]<i-br):\n            continue\n        else:\n            b=False\n            break\nif(b):\n    print(n-br)\nelse:\n    print(n+mx)\n", "n=int(input())\na1=list(map(int,input().split()))\na=list(map(int,input().split()))\na=[0]+a\nd=[0]*(n+1);\nmx=0\nfor i in range(1,n+1):\n    d[a[i]]=i\nmx=max(d[i]-i+1 for i in range(1,n+1))\nbr=n-d[1]+1\nb=(d[1]!=0)\nfor i in range(1,n+1):\n    if(i<=br):\n        if(d[i]-d[1]==i-1):\n            continue\n        else:\n            b=False\n            break\n    else:\n        if(d[i]<i-br):\n            continue\n        else:\n            b=False\n            break\nif(b):\n    print(n-br)\nelse:\n    print(n+mx)\n", "def index(l):\n    for i in range(n):\n        if l[i]>0:\n            j=(i+1)-l[i]\n            #print(i,l[i])\n            l1.append(j)\n    #print(l1)\n    return(l1)\nn=int(input())\nhand=[int(g) for g in input().split()]\ndeck=[int(g) for g in input().split()]\nif 1 in deck:\n    index2=deck.index(1)\n    #print(index2)\nl1=[]\nbuffer=deck[:]\nbuffer.sort()\nl2=index(deck)\nif len(set(deck))==1 and set(deck)=={0}:\n    output=(n)\nelif 0 not in deck and deck==buffer:\n    output=(0)\nelif 1 in deck :\n    if index2==0:\n        output=(max(l2)+n+1)\n    if set(deck[:index2])=={0}:\n        li=[int(g) for g in range(1,n-index2+1)]\n        #print(li)\n        if deck[index2:]==li:\n            output=index2\n        else:\n            output=(max(l2)+n+1)\n    else:\n        for i in range(index2):\n            if deck[i]>0:\n                #print(index2-i,(n-deck[i])+2)\n                if (index2-i)>=(n-deck[i])+2:\n                    #print(index2-i,(n-deck[i])+2)\n                    output=(l2[-1])\n                else:\n                    output=(max(l2)+n+1)\n                    break\n            #else:\n                #output=11\nelse:\n    if max(l2)<=(-1):\n        output=(n)\n    else:\n        output=(max(l2)+n+1)\nprint(output)\n    \n", "def index(l):\n    for i in range(n):\n        if l[i]>0:\n            j=(i+1)-l[i]\n            l1.append(j)\n    return(l1)\nn=int(input())\nhand=[int(g) for g in input().split()]\ndeck=[int(g) for g in input().split()]\nif 1 in deck:\n    index2=deck.index(1)\nl1=[]\nbuffer=deck[:]\nbuffer.sort()\nl2=index(deck)\nif len(set(deck))==1 and set(deck)=={0}:\n    output=(n)\nelif 0 not in deck and deck==buffer:\n    output=(0)\nelif 1 in deck :\n    if index2==0:\n        output=(max(l2)+n+1)\n    if set(deck[:index2])=={0}:\n        li=[int(g) for g in range(1,n-index2+1)]\n        if deck[index2:]==li:\n            output=index2\n        else:\n            output=(max(l2)+n+1)\n    else:\n        for i in range(index2):\n            if deck[i]>0:\n                if (index2-i)>=(n-deck[i])+2:\n                    output=(l2[-1])\n                else:\n                    output=(max(l2)+n+1)\n                    break\nelse:\n    if max(l2)<=(-1):\n        output=(n)\n    else:\n        output=(max(l2)+n+1)\nprint(output)\n    \n", "from sys import stdin, exit\ninput = stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\np = [0] * (n + 1)\n\nfor i in a:\n    p[i] = 0\n\nfor i, v in enumerate(b):\n    p[v] = i + 1\n\nans = 0\nif p[1] > 0:\n\n    i = 2\n    while i <= n and p[i] == p[i - 1] + 1:\n        i += 1\n    if p[i - 1] == n:\n        j = i\n        while j <= n and p[j] <= j - i:\n            j += 1\n        if j == n + 1:\n            print(p[1] - 1)\n            return\n\nans = max([p[i] - i + 1 + n for i in range(1, n + 1)])\nprint(ans)\n", "import io, os\n#input = io.StringIO(os.read(0, os.fstat(0).st_size).decode()).readline\n\nn = int(input())\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nf = True\nif 1 in b:\n\t\n\tj = b.index(1)\n\t\n\tfor i in range(n - j):\n\t\td = i + 1 - b[j + i]\n\t\tif d != 0:\n\t\t\tbreak\n\telse:\n\t\ts = -2\n\t\tfor k in range(j):\n\t\t\tif b[k] != 0 and b[k] - k <= n - (j - 1):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(j)\n\t\t\tf = False\n\n\n\nif f:\n\ts = -2\n\tfor k in range(n):\n\t\tif b[k] != 0:\n\t\t\ts = max(s, k - b[k])\n\tprint(s + n + 2)\n", "n = int(input())\nhand = []\ndeck = []\ns = [-1] * (n + 1)\nfor el in map(int, input().split()):\n    hand.append(el)\n    s[el] = 0\ni = 1\nfor el in map(int, input().split()):\n    deck.append(el)\n    s[el] = i\n    i += 1\nif s[1] != 0:\n    i = 2\n    while i <= n and s[i] == s[1] + i - 1:\n        i += 1\n    if s[i - 1] == n:\n        j = i\n        while j <= n and s[j] <= j - i:\n            j += 1\n        if j > n:\n            print(n - i + 1)\n            return\nans = 0\nfor i in range(1, n + 1):\n    ans = max(ans, s[i] - i + 1 + n)\nprint(ans)\n", "n = int(input())\nl1=list(map(int,input().split()))\nl2= list(map(int,input().split()))\nf=0\nif 1 in l2:\n    c=l2.index(1)\n    d=1\n    for i in range(c,n):\n        if l2[i]!=d:\n#            print(l2[i],d,i,c)\n            break\n        d+=1    \n    else:\n\n#        print(\"ll\") \n        for k in range(c):\n            if l2[k]!=0 and l2[k]-k<=d:\n                break\n        else:\n            print(c)\n#            print(d)\n            f=1        \n#    n-=d\nif f==0:\n    s=-2\n    for i in range(n):\n        if l2[i]!=0:\n            s=max(s,i-l2[i])\n    print(n+s+2)            ", "'''input\n3\n0 2 0\n1 0 3\n'''\nfrom sys import stdin\nfrom copy import deepcopy\nfrom collections import deque\n\n\n\ndef find_start(pile):\n\tstart = 1\n\tindex = -1\n\n\tfor i in range(len(pile)):\n\t\tif pile[i] == start:\n\t\t\tindex = i\n\t\t\tbreak\n\tlatest = start\n\tif index != -1:\n\t\tflag = True\n\t\tfor i in range(index, len(pile)):\n\t\t\tif pile[i] == latest:\n\t\t\t\tlatest += 1\n\t\t\telse:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\n\t\tif flag:\n\t\t\tstart = latest\n\treturn start\n\n\n# \ndef check_start(num, op):\n\top[0] = 0\n\tnonlocal arr\n\tnonlocal barr\n\n\tmydict = [0] * (n + 1)\n\tfor i in range(len(arr)):\n\t\tmydict[arr[i]] += 1\n\t\t\n\t# print(mydict)\n\tzeroes = mydict[0]\n\n\tpile = deque(barr[:])\n\n\n\t# inserting the zeroes initially\n\tfor i in range(num):\n\t\tif zeroes > 0:\n\t\t\top[0] += 1\n\t\t\tpile.append(0)\n\t\t\tzeroes -= 1\n\t\t\tmydict[0] -= 1\n\t\telse:\n\t\t\treturn False\n\n\t\telement = pile.popleft()\n\n\n\t\t# updating the dictionary\n\t\tmydict[element] += 1\n\t\n\t\t# checking if it is zero\n\t\tif element == 0:\n\t\t\tzeroes += 1\n\t# print(mydict)\n\n\t# inserting the numbers\n\tstart = find_start(barr)\n\t# print(start)\n\tfor i in range(start, n + 1):\n\t\t# print(pile)\n\t\tif mydict[i] > 0:\n\t\t\top[0] += 1\n\t\t\tpile.append(i)\n\t\t\tmydict[i] -= 1\n\t\t\telement = pile.popleft()\n\t\t\tmydict[element] += 1\n\t\telse:\n\t\t\treturn False\n\treturn True\n\n\n# main starts\nn = int(stdin.readline().strip())\narr = list(map(int, stdin.readline().split()))\nbarr = list(map(int, stdin.readline().split()))\nstart = 0\nend = 2 * n\nop = [0]\n\nif check_start(0, op):\n\tprint(op[0])\n\treturn\n\npos = [0] * (n + 1)\nfor i in range(n):\n\tpos[barr[i]] = i + 1\n\nans = -float('inf')\nfor i in range(1, n + 1):\t\n\tans = max(pos[i] - i  + 1 + n, ans)\nprint(ans)", "n = int(input())\n_ = input()\nar = list(map(int, input().split()))\n\nidx = 0\nidx2 = -2\nflag = False\n\nfor i, e in enumerate(ar):\n    idx = max(idx, 0 if e == 0 else i-e+2)\n    \n    if e == 1 and idx2 < i-1:\n        flag = True\n        i1 = i\n        s = 0\n\n    idx2 = max(idx2, -2 if e == 0 else i+n-e)\n\n    if flag:\n        if s+1 == e:\n            s += 1\n        else:\n            flag = False\n\nif flag:\n    print(i1)\nelse:\n    print(n + idx)", "N = 200005\nn = int(input())\nk = list(map(int,input().split()))\nb = list(map(int,input().split()))\np = [0 for i in range(N)]\ndone = 0\nb.insert(0,0)\n# for i in range(len(b)):\n# \tprint (b[i],end=\" \")\nfor i in range(1,n+1):\n\tp[b[i]] = i\nif(p[1] != 0):\n\ti = 2\n\twhile (p[i]==p[1]+i-1) :\n\t\ti+=1\n\tif(p[i-1]==n):\n\t\tj = i\n\t\twhile (p[j]<=j-i and j<=n) :\n\t\t\tj+=1\n\t\tif (j>n):\n\t\t\tprint(n-i+1)\t\n\t\t\tdone = 1\nmx = 0\nif (done==0):\n\tfor i in range(1,n+1) :\n\t\tmx = max(mx,p[i]-i+1+n)\n\tprint (mx)\t \t\t\t\t\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/12/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, A, B):\n    p = [0 for _ in range(N+1)]\n    # print(B)\n    for i, v in enumerate(B):\n        p[v] = i + 1\n    # print(p)\n    if p[1]:\n        i = 2\n        while i <= N and p[i] == p[1] + i - 1:\n            i += 1\n        \n        if p[i-1] == N:\n            j = i\n            while j <= N and p[j] <= j-i:\n                j += 1\n            if j > N:\n                return N-i+1\n    \n    return max([p[i]-i+1+N for i in range(1, N+1)])\n            \n\nN = int(input())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nprint(solve(N, A, B))\n", "from sys import stdin\nfrom collections import deque\n\nn = int(stdin.readline())\n\nhand = [int(x) for x in stdin.readline().split()]\n\ndeck = [int(x) for x in stdin.readline().split()]\n\nind = {}\n\nfor i,x in enumerate(deck):\n    if x != 0:\n        ind[x] = i\n\noffset = sorted([(ind[i]-i+2,i) for i in ind])\n\nif not offset:\n    print(n)\n\nelif not 1 in deck:\n    print(max(offset[-1][0]+n, n))\nelse:\n    i1 = deck.index(1)\n    newD = deck[i1:]\n    valid = True\n    for x in range(len(newD)-1):\n        if newD[x] > newD[x+1]:\n            valid = False\n            break\n    if valid:\n        v2 = True\n        newOff = i1-n\n        for o,x in offset:\n            if x > -newOff and o > newOff:\n                v2 = False\n                break\n\n        if v2:\n            print(newOff+n)\n        else:\n            print(max(offset[-1][0]+n, n))\n    else:\n        print(max(offset[-1][0]+n, n))\n    \n"]
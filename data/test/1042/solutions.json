["import sys\n\nx,y = list(map(int, input().strip().split()))\n\nif y % x != 0:\n    print(0)\n    return\n\nMOD = 10**9 + 7\n\nK = y//x\n\ndef multiply(A,b, MOD):\n    n, m = len(A), len(b[0])\n    matrika = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            vsota = 0\n            for k in range(len(A[0])):\n                vsota += A[i][k]*b[k][j]\n            matrika[i][j] = vsota % MOD\n    return matrika\n\ndef copy(mat):\n    return [e[:] for e in mat]\n\ndef fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    matrika = [[1,1],[1,0]]\n\n    pripravi = dict()\n    pripravi[1] = copy(matrika)\n    s = 1\n\n    pot = [1]\n\n    working = copy(matrika)\n    \n    while s <= n:\n        working = multiply(working,working,MOD)\n        s*= 2\n        pripravi[s] = copy(working)\n        pot.append(s)\n\n    manjka = n-2\n    pointer = len(pot) - 1\n    while manjka > 0:\n        if pot[pointer] > manjka:\n            pointer -= 1\n        else:\n            matrika = multiply(matrika, pripravi[pot[pointer]], MOD)\n            manjka -= pot[pointer]\n\n    v = [[1],[0]]\n\n    return multiply(matrika, v, MOD)[0][0]\n\nmemo2 = dict()\ndef find(y):\n    if y in memo2:\n        return memo2[y]\n    ALL = (pow(2, y - 1, MOD)) % MOD\n\n    k = 2\n    while k*k <= y:\n        if y % k == 0:\n            if k*k != y:\n                ALL -= find(y//k)\n                ALL -= find(k)\n            else:\n                ALL -= find(k)\n        k += 1\n        #print(k, ALL)\n\n    if y != 1:\n        ALL -= 1\n\n    memo2[y] = ALL % MOD\n    return ALL % MOD\n\nprint(find(K) % MOD)\n\n\ndef gcd(x,y):\n    if x == 0:\n        return y\n    if y > x:\n        return gcd(y,x)\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\n\nmemo = dict()\ndef brute(k, gc):\n    if (k,gc) in memo:\n        return memo[k,gc]\n    if k == 0:\n        if gc:\n            return 1\n        else:\n            return 0\n    ALL = 0\n    for i in range(1, k + 1):\n        ALL += brute(k-i,gcd(gc,i))\n    memo[k, gc] = ALL\n    return ALL\n\n#print(brute(K,0) % MOD)\n            \n", "mod = 1000000007\ndef modpow(a, x):\n\tif x==0:\n\t\treturn 1\n\tif x==1:\n\t\treturn a\n\tb = modpow(a, x//2)\n\treturn (b*b*(a ** (x%2))) % mod\n\n\nimport sys\nx,y = list(map(int, input().split()))\nif y%x != 0:\n\tprint(0)\n\treturn\nif x==y:\n\tprint(1)\n\treturn\t\n\na = y//x\n\ndivs = []\n\ni=2\nwhile i*i < a:\n\tif a%i == 0:\n\t\tdivs.append(i)\n\t\tdivs.append(a//i)\n\ti+=1\n\t\t\nif int(a ** 0.5) **2 == a:\n\tdivs.append(int(a**0.5))\n\ndivs.append(a)\n\ndivs.sort()\n\n#print(divs)\n\t\t\nres = modpow(2, a-1)\nmuls = [0 for _ in divs]\nmuls[0] = 1;\n\nfor xid,d in enumerate(divs):\n\tprevs = 0\n\tfor id,d2 in enumerate(divs):\n\t\tif d2<d and d%d2 == 0:\n\t\t\tprevs+=muls[id]\n\tmuls[xid] = (1-prevs)\n\tres += (prevs-1) * modpow(2, a//d - 1)\n\t\n\tres = (res + 1000 * mod) % mod\n\t#print(d, res, ',', prevs)\n\t\n#print(muls)\nprint(res)\n", "\n\nmod = 1000000007\ndef modpow(a, x):\n\tif x==0:\n\t\treturn 1\n\tif x==1:\n\t\treturn a\n\tb = modpow(a, x//2)\n\treturn (b*b*(a ** (x%2))) % mod\n\n\nimport sys\nx,y = list(map(int, input().split()))\nif y%x != 0:\n\tprint(0)\n\treturn\nif x==y:\n\tprint(1)\n\treturn\t\n\na = y//x\n\ndivs = []\n\ni=2\nwhile i*i < a:\n\tif a%i == 0:\n\t\tdivs.append(i)\n\t\tdivs.append(a//i)\n\ti+=1\n\t\t\nif int(a ** 0.5) **2 == a:\n\tdivs.append(int(a**0.5))\n\ndivs.append(a)\n\ndivs.sort()\n\n#print(divs)\n\t\t\nres = modpow(2, a-1)\nmuls = [0 for _ in divs]\nmuls[0] = 1;\n\nfor xid,d in enumerate(divs):\n\tprevs = 0\n\tfor id,d2 in enumerate(divs):\n\t\tif d2<d and d%d2 == 0:\n\t\t\tprevs+=muls[id]\n\tmuls[xid] = (1-prevs)\n\tres += (prevs-1) * modpow(2, a//d - 1)\n\t\n\tres = (res + 1000 * mod) % mod\n\t#print(d, res, ',', prevs)\n\t\n#print(muls)\nprint(res)", "'''\nmidpow function copy marsi.\n39 no line thaki 51 copy marsi.\ntou kita oiche\nas if i care\n'''\n\n\nimport sys\nmod = 1000000007\ndef modpow(a, x):\n    if x == 0:\n        return 1\n    if x == 1:\n        return a\n    b = modpow(a, x//2)\n    return (b*b*(a ** (x%2))) % mod\n\n\nn,m = list(map(int, input().split()))\n#ans = gcd(n,m)\nif m%n != 0:\n    print(0)\n    return\nif n == m:\n    print(1)\n    return\nans = m//n\narr = []\ni = 2\nwhile i*i < ans:\n    if ans%i == 0:\n        arr.append(i)\n        arr.append(ans//i)\n    i += 1\nif int(ans ** 0.5) ** 2 == ans:\n    arr.append(int(ans** 0.5))\narr.append(ans)\narr.sort()\nresult  = modpow(2, ans -1)\nmuls = [0 for _ in arr]\nmuls[0] = 1\nfor xid,d in enumerate(arr):\n    prevs = 0\n    for id,d2 in enumerate(arr):\n        if d2 < d and d%d2 ==0:\n            prevs += muls[id]\n    muls[xid] = (1 - prevs)\n    result += (prevs - 1) * modpow(2, ans//d - 1)\n\n    result = (result + 1000 * mod) % mod\nprint(result)\n", "import operator, math, itertools, functools\nmod = int(1e9 + 7)\n\ndef factor(n):\n\ta = []\n\tfor i in range(2, int(math.sqrt(n))+1):\n\t\twhile n % i == 0:\n\t\t\ta.append(i)\n\t\t\tn //= i\n\tif n > 1: a.append(n)\n\treturn a\n\t\ndef comp(n):\n\tf = set(factor(n))\n\tc = pow(2, n-1, mod)\n\tfor i in range(1, len(f)+1):\n\t\tif i & 1:\n\t\t\tsign = -1\n\t\telse:\n\t\t\tsign = 1\n\t\tfor j in itertools.combinations(f, i):\n\t\t\tk = functools.reduce(operator.mul, j)\n\t\t\tc += sign * pow(2, n//k-1, mod)\n\t\t\tc = c % mod\n\treturn c\t\t\n\t\nx, y = map(int, input().split())\nif y % x == 0:\n\tprint(comp(y // x))\nelse:\n\tprint(0)", "#!/usr/bin/env python3\n\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nfrom itertools import combinations\n\n\neval_function = lambda x: lambda f: f(x)\n\n\n@eval_function(int((10**9)**0.5))\ndef prime(n):\n    sieve = [True] * (n+1)\n    sieve[0] = sieve[1] = False\n    index = 2\n    for i in range(int(len(sieve)**0.5)):\n        if sieve[i]:\n            for j in range(2*i, len(sieve), i):\n                sieve[j] = False\n        index += 1\n    return [i for i, is_prime in enumerate(sieve) if is_prime]\n\n\ndef factorized(n):\n    factors = []\n    for i in prime:\n        if i**2 > n:\n            break\n        while not n % i:\n            factors += [i]\n            n //= i\n    if n > 1:\n        factors += [n]\n    return factors\n\n\ndef solve(x, y, mod=None):\n    if gcd(x, y) != x:\n        return 0\n    y = y//x\n    c = pow(2, y-1, mod)\n    unique_factors = set(factorized(y))\n    for i in range(1, len(unique_factors)+1):\n        for divisor in combinations(unique_factors, i):\n            d = reduce(mul, divisor)\n            c += (-1)**i * pow(2, y//d-1, mod)\n            c %= mod\n    return c\n\n\ndef main():\n    x, y = [int(n) for n in input().split()]\n    print(solve(x, y, 10**9+7))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nfrom itertools import combinations\n\n\neval_function = lambda x: lambda f: f(x)\n\n\n@eval_function(int((10**9)**0.5))\ndef prime(n):\n    sieve = [True] * (n+1)\n    sieve[0] = sieve[1] = False\n    index = 2\n    for i in range(int(len(sieve)**0.5)):\n        if sieve[i]:\n            for j in range(2*i, len(sieve), i):\n                sieve[j] = False\n        index += 1\n    return [i for i, is_prime in enumerate(sieve) if is_prime]\n\n\ndef factorized(n):\n    factors = []\n    for i in prime:\n        if i**2 > n:\n            break\n        while n % i == 0:\n            factors += [i]\n            n //= i\n    if n > 1:\n        factors += [n]\n    return factors\n\n\ndef count_coprime_parts(n, mod=None):\n    count = pow(2, n-1, mod)\n    unique_factors = set(factorized(n))\n    for i in range(1, len(unique_factors)+1):\n        for factors in combinations(unique_factors, i):\n            d = reduce(mul, factors)\n            count += (-1)**i * pow(2, n//d-1, mod)\n            count %= mod\n    return count\n\n\ndef solve(x, y, mod=None):\n    if gcd(x, y) != x:\n        return 0\n    return count_coprime_parts(y//x, mod)\n\n\ndef main():\n    x, y = [int(n) for n in input().split()]\n    print(solve(x, y, 10**9+7))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "M=10**9+7\na,b=list(map(int,input().split()))\nif b%a:print(0)\nelse:\n    b//=a\n    d=set()\n    for i in range(1,int(pow(b,0.5)+1)):\n        if b%i==0:\n            d.add(i)\n            d.add(b//i)\n    d=sorted(list(d))\n    f=d[::]\n    for i in range(len(f)):\n        f[i]=pow(2,d[i]-1,M)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                f[i]-=f[j]\n    print(f[-1]%M)\n", "M=10**9+7\na,b=map(int,input().split())\nif b%a:print(0)\nelse:\n    b//=a\n    d=set()\n    for i in range(1,int(pow(b,0.5)+1)):\n        if b%i==0:\n            d.add(i)\n            d.add(b//i)\n    d=sorted(list(d))\n    f=d[::]\n    for i in range(len(f)):\n        f[i]=pow(2,d[i]-1,M)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                f[i]-=f[j]\n    print(f[-1]%M)", "x, y = map(int, input().split())\nb = y // x\nif y % x != 0:\n    print(0);return\nds = set()\nM = 10**9 + 7\nfor i in range(1, int(pow(b,0.5)+1)):\n    if b % i == 0:\n        ds.add(i)\n        ds.add(b//i)\nds = sorted(list(ds))\nans = pow(2, b-1, M)\nf = ds[::]\nfor i in range(len(ds)):\n    f[i] = pow(2, ds[i]-1, M)\n    for j in range(i):\n        if ds[i] % ds[j] == 0:\n            f[i] -= f[j]\nprint(f[-1]%M)", "def bin_pow(num, degree , module):\n    if degree == 0:\n        return 1\n    if degree == 1:\n        return num % module\n\n    if degree % 2 == 0:\n        val = bin_pow(num, degree // 2, module)\n        return (val * val) % module\n    \n    return (num * bin_pow(num , degree - 1, module)) % module\n\n\n\nx, y = list(map(int,input().split()))\n\n\nif y % x != 0:\n    print(0)\n    return\n\ny //= x\n\ndivs = set()\nto_gen = []\n\nnum = 2\nval = y\n\nwhile num * num <= val:\n    degree = 0\n    while y % num == 0:\n        degree+=1\n        y //= num\n    if degree != 0:\n        to_gen.append((num, degree))\n\n    if num == 2:\n        num += 1\n    else:\n        num += 2\n\nif y != 1:\n    to_gen.append((y, 1))\n\n    \nto_gen_len = len(to_gen)\n\ndef generate(ind):\n    if ind == to_gen_len:\n        yield 1\n        return \n    gen_val = to_gen[ind][0]\n    \n    for deg in range(1 + to_gen[ind][1]):\n        for each in generate(ind  + 1):\n            yield gen_val**deg * each\n\nfor each in generate(0):\n    divs.add(each)\n\ndivs = list(divs)\ndivs.sort()\ndivs_answers = {}\nmod = 10**9 + 7\nans = bin_pow(2, val - 1, mod)\n\nfor el in divs:\n    if el == 1:\n        divs_answers[el] = 1\n        ans -= 1\n    else:\n        curr_val = bin_pow(2, el - 1 ,mod)\n        for other_el in divs:\n            if other_el >= el:\n                break\n            if el % other_el !=0:\n                continue\n            \n            curr_val -= divs_answers[other_el]\n\n        divs_answers[el] = curr_val % mod\n        ans -= curr_val\n\nprint(divs_answers[val])\n", "\nmod=10**9+7\nnum1,num2=list(map(int,input().split()))\nif num2%num1:\n\tprint(\"0\")\nelse:\n    num2=num2//num1\n    arr=set()\n    for i in range(1,int(pow(num2,0.5)+1)):\n        if num2%i==0:\n            arr.add(i)\n            arr.add(num2//i)\n    arr=sorted(list(arr))\n    cop2=arr[::]\n    for i in range(len(cop2)):\n        cop2[i]=pow(2,arr[i]-1,mod)\n        for j in range(i):\n            if arr[i]%arr[j]==0:\n                cop2[i]-=cop2[j]\n    print(cop2[-1]%mod)\n\n", "MOD = 1000000007\n\nx, y = map(int,input().split())\n\nif y%x == 0: # 'y' must be divisible by 'x'\n    div = y // x\n    y_mult = set() # Distinc common multiples for y\n    for i in range(1, int(pow(div, 0.5) + 1)): # Just is neccesary until root of div\n        if div % i == 0:\n            y_mult.add(i)\n            y_mult.add(div // i)\n    y_mult = sorted(list(y_mult))\n    ym_copy = y_mult.copy()\n    for i in range(len(ym_copy)):\n        ym_copy[i] = pow(2, y_mult[i]-1, MOD) # Efficient pow \n        for j in range(i):\n            if y_mult[i]%y_mult[j] == 0:\n                ym_copy[i] -= ym_copy[j]\n    print(ym_copy[-1]%MOD)\nelse:\n    print(0)", "\nmodulo=10**9+7\nnum1,num2=list(map(int,input().split()))\nif num2%num1:\n\tprint(\"0\")\nelse:\n    num2=num2//num1\n    arr=set()\n    for i in range(1,int(pow(num2,0.5)+1)):\n        if num2%i==0:\n            arr.add(i)\n            arr.add(num2//i)\n    arr=sorted(list(arr))\n    cop2=arr[::]\n    for i in range(len(cop2)):\n        cop2[i]=pow(2,arr[i]-1,modulo)\n        for j in range(i):\n            if arr[i]%arr[j]==0:\n                cop2[i]-=cop2[j]\n    print(cop2[-1]%modulo)\n\n", "\n# coding: utf-8\n\n# In[36]:\n\n\nimport math\n\ndef UnusualSeq(a,b):\n    if b%a!=0:\n        print(0)\n    else:\n        b//=a\n        d=set()\n        for i in range(1,int(math.sqrt(b)+1)):\n            if b%i==0:\n                d.add(i)\n                d.add(b//i)\n        d=sorted(list(d))\n        f=d[::]\n        for i in range(len(f)):\n            f[i]=pow(2,d[i]-1,(10**9+7))\n            for j in range(i):\n                if d[i]%d[j]==0:\n                    f[i]-=f[j]\n        print(f[-1]%(10**9+7))\n\n\na,b=list(map(int,input().split()))\nUnusualSeq(a,b)\n\n", "M=10**9+7\na,b=map(int,input().split())\nif b%a:print(0)\nelse:\n    b//=a\n    d=set()\n    for i in range(1,int(pow(b,0.5)+1)):\n        if b%i==0:\n            d.add(i)\n            d.add(b//i)\n    d=sorted(list(d))\n    f=d[::]\n    for i in range(len(f)):\n        f[i]=pow(2,d[i]-1,M)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                f[i]-=f[j]\n    print(f[-1]%M)", "import math\nlectura=lambda:map (int,input().split())\nx,y=lectura()\nmod= 1000000007\nif (y%x!=0):\n    print(\"0\")\nelse:\n    y= y//x\n    setPrueba=set()\n    for i in range(1, int(math.sqrt(y) + 1)):\n        if (y%i==0):\n            setPrueba.add(i)\n            setPrueba.add(y// i)\n    setPrueba=sorted(list(setPrueba))\n    setOrdenado= setPrueba.copy()\n    for i in range(len(setOrdenado)):\n        #setOrdenado[i] = math.pow(2, setPrueba[i] - 1)\n        setOrdenado[i]=pow(2, setPrueba[i] - 1, mod)\n        for j in range(i):\n            if setPrueba[i]% setPrueba[j]==0:\n                setOrdenado[i]-= setOrdenado[j]\n    print(setOrdenado[len(setOrdenado)-1] % mod)", "import math\n\nmod= 1000000007\n\nx, y = [int(x) for x in input().split()]\n\nif y%x != 0:\n    print(0)\n    return\n \ny= y//x\nseqs=set()\t\n\nfor x in range(1, int(math.sqrt(y) + 1)):\n\tif y%x != 0:\n\t\tcontinue\n\tseqs.add(x)\n\tseqs.add(y// x)\n\nseqs=sorted(list(seqs))\nordered= seqs.copy()\n\nfor i in range(len(seqs)):\n\tordered[i]=pow(2, seqs[i] - 1, mod)\n\tfor j in range(i):\n\t\tif seqs[i]% seqs[j] == 0:\n\t\t\tordered[i]-= ordered[j]\nprint(int(ordered[len(ordered)-1] % mod))\n", "p=1000000007\ndef mul(x,y):\n    rt=1\n    while y>0:\n        if y%2==1:\n            rt=(rt*x)%p\n        x=(x*x)%p\n        y=y//2\n    return rt\n \nx,y=list(map(int,input().split()))\nif(y%x!=0):print(0)\nelse:\n    y/=x\n    d=set([])\n    i=1\n    while i*i<=y:\n        if y%i==0:\n            d.add(i);d.add(y/i)\n        i+=1\n    d=sorted(list(d))\n    dp=d[::]\n    for i in range(len(d)):\n        dp[i]=mul(2,d[i]-1)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                dp[i]-=dp[j]\n    print(dp[-1]%p)\n", "import sys\nmod = 1000000007\ndef mul(x,y):\n    res=1\n    while y>0:\n        if y%2==1:\n            res=(res*x)%mod\n        x=(x*x)%mod\n        y//=2\n    return res\nx,y = list(map(int,sys.stdin.readline().split()))\nif(y%x!=0):\n    print(0)\nelse:\n    y/=x\n    d=set([])\n    i=1\n    while i*i<=y:\n        if y%i==0:\n            d.add(i);d.add(y/i)\n        i+=1\n    d=sorted(list(d))\n    dp=d[::]\n    for i in range(len(d)):\n        dp[i]=mul(2,d[i]-1)\n        for j in range(i):\n            if d[i]%d[j]==0:\n                dp[i]-=dp[j]\n    print(dp[-1]%mod)\n\n", "from collections import defaultdict\nx, y = map(int, input().split())\nif y%x != 0: \n\tprint(0)\n\treturn\nx = y//x\ndivisors = []\nfor i in range(1,int(x**(.5))+1):\n\tif x%i == 0:\n\t\tdivisors.append(i)\n\t\tdivisors.append(x//i)\nif divisors[-1] == divisors[-2]: divisors.pop()\ndivisors.sort()\nva = defaultdict(int)\nva[1] = 1\nmod = 10**9 + 7\nfor i in range(1, len(divisors)):\n\tk = divisors[i]\n\tcount = pow(2,k-1,mod)\n\tfor j in range(i):\n\t\tif k%divisors[j] == 0: count = (count-va[divisors[j]])%mod\n\tva[k] = count\nprint(va[x])"]
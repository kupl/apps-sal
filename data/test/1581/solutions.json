["import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\nN, K = lr()\nM = int(N**.5)\n\n# M+1\u4ee5\u4e0a\u3067\u3001N\u3092\u5272\u308b\u3068x\u306b\u306a\u308b\u3082\u306e\nupper_cnt = np.zeros(M+1, dtype=np.int64) # 1-indexed\nA = np.arange(M+1, dtype=np.int64)\nupper_cnt[1:] = N // A[1:] - np.maximum(M, N // (A[1:]+1)) # M\u306e\u6642\u306flower\u3067\u6570\u3048\u308b\u306e\u30670\u306b\n\n# \u6841DP\nlower = np.zeros(M+1, dtype=np.int64) # 1-indexed\nupper = np.zeros(M+1, dtype=np.int64)\n#\u6700\u521d\u306f\u5236\u9650\u306a\u3057\u306a\u306e\u30671\u3092\u7f6e\u3044\u3066\u304a\u304f\nlower[1] = 1\nfor i in range(K):\n    prev_lower = lower.copy()\n    prev_upper = upper.copy()\n    lower_cum = prev_lower.cumsum() % MOD\n    upper_cum = prev_upper.cumsum() % MOD\n    # lower \u3068 upper \u304b\u3089 lower \u3078\n    lower = np.zeros(M+1, dtype=np.int64)\n    lower[1:] += (lower_cum[-1] + upper_cum[-1])\n    lower[1:] -= upper_cum[:-1] # \u5927\u304d\u3059\u304e\u308b\u5024\u3092\u5f15\u304f\n    # upper \u304b\u3089 upper \u306f\u306a\u3057\n    # lower \u304b\u3089 upper \u3078\n    upper = lower_cum * upper_cnt\n    lower %= MOD; upper %= MOD\n\nanswer = (lower[1:].sum() + upper[1:].sum()) % MOD\nprint(answer)\n", "import numpy as np\nN, K = tuple(map(int, input().split()))\nmod = 1000000007\n\nm = N ** 0.5\ncnt = [N // i - N // (i + 1) for i in range(1, int(m) + 1)] \ncnt = np.array((cnt + [1 for _ in range(N - sum(cnt))])[::-1])\nnxt = cnt[:]\nfor _ in range(K - 1):\n    cnt = nxt * np.cumsum(cnt)[::-1] % mod\n\nprint((sum(cnt) % mod))\n", "from itertools import accumulate\n\nN,K = map(int, input().split())\nmod = 10**9+7\nsqt = int(N**0.5)\ncnt = [N // i-N // (i+1) for i in range(1, N//sqt)] + [1]*sqt\nx = cnt\nfor _ in range(K):\n    x = [(i*j)%mod for i, j in zip(accumulate(reversed(x)), cnt)]\n    \n\nprint(x[-1])", "from numpy import int_\n\nmod = 10 ** 9 + 7\n\nN, K = map(int, input().split())\n\nM = int(N ** 0.5)\n\nT = [N // i - N // (i + 1) for i in range(1, M + 1)]\nA = int_([1] * (N - sum(T)) + T[::-1])\n\ndp = A[:]\nfor _ in range(K - 1):\n    dp = A * dp.cumsum()[::-1] % mod\n\nprint(dp.sum() % mod)", "from itertools import accumulate\nN,K=map(int,input().split())\nN_s=int(N**0.5)\nlist_a=[1]*N_s\nlist_b=[N//j-N_s for j in range(1,N_s+1)]\nlist_p=[N//j-N_s for j in range(1,N_s+1)]\nfor p in range(1,len(list_p)):\n        list_p[p-1]=list_p[p-1]-list_p[p]\n        \nfor p in range(1,len(list_b)):\n    list_b[p-1]=list_b[p-1]-list_b[p]\n\nlist_bb=list(reversed(list(accumulate(reversed(list_b)))))\nlist_aa=list(accumulate(list_a))\n\nmod=10**9+7\n\nfor i in range(K-1):\n    temp=sum(list_a)\n    list_an=[(temp+list_bb[j])%mod for j in range(N_s)]\n    list_bn=[(list_p[j-1]*list_aa[j-1])%mod for j in range(1,N_s+1)]\n\n    list_bbn=list(reversed(list(accumulate(reversed(list_bn)))))\n    list_aa=list(accumulate(list_an))\n    list_a=list_an\n    list_b=list_bn\n    list_bb=list_bbn\n    \nprint((sum(list_a)+sum(list_b))%mod)", "def f(n,k):\n    lim = int((n + 0.1) ** 0.5) + 1\n    ws = []\n    s = 0\n    for i in range(1, lim):\n        w = n // i - n // (i + 1)\n        ws.append(w)\n        s += w\n    ws += [1] * (n - s)\n    m = len(ws)\n    dp0 = ws[::-1]\n    dp1 = [0] * m\n    for _ in range(k - 1):\n        s = 0\n        for j in range(m):\n            s += dp0[j]\n            dp1[m - j - 1] = (s * ws[j]) % md\n        dp0 = dp1[:]\n    print((sum(dp0) % md))\nmd=10**9+7\nn,k=list(map(int,input().split()))\nf(n,k)\n", "import numpy as np\n\nn, k = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = int(n ** 0.5)\ncoe = []\nfor i in range(l, 0, -1):\n    coe.append(n // i - l)\ncoe.append(0)\ncoe.reverse()\ncoe = np.array(coe, dtype=np.int64)\n\ndp1 = np.ones(l + 1, dtype=np.int64)\ndp2 = coe.copy()\ndp1[0] = 0\nfor i in range(k - 1):\n    dp1acc = np.add.accumulate(dp1) % MOD\n    dp12acc = np.add.accumulate((dp1 * coe % MOD)[::-1])[::-1]\n    s = dp1acc[-1]\n    dp1acc = np.roll(dp1acc, 1)\n    dp1acc[0] = 0\n    dp12acc[0] = 0\n    dp1[1:] = (s + dp2[1:]) % MOD\n    dp2 = dp12acc + dp1acc * coe % MOD\nans = (dp1.sum() + dp2[1]) % MOD\nprint(ans)\n", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# \u6841dp\u3001\u221aN\u307e\u3067\u3092lower\u3001\u305d\u308c\u4ee5\u964d\u3092up_range\u3001N\u3092lower\u3067\u5272\u3063\u305f\u3082\u306e\u3067\u307e\u3068\u3081\u308b\nMOD = 10 ** 9 + 7\nN, K = lr()\nM = int(N ** .5)\nA = np.arange(M+1, dtype=np.int64)\nhigh_range = np.zeros(M+1, dtype=np.int64)\nhigh_range[1:] = N // A[1:] - np.maximum(M, N // (A[1:] + 1))  # M\u306flower\u306b\u5165\u308c\u308b\u306e\u30670\nlow = np.zeros(M+1, dtype=np.int64)\nhigh = np.zeros(M+1, dtype=np.int64)\nlow[1] = 1\nfor _ in range(K):\n    prev_low = low.copy()\n    prev_high = high.copy()\n    prev_low_cum = prev_low.cumsum() % MOD\n    prev_high_cum = prev_high.cumsum() % MOD\n    low = np.zeros(M+1, dtype=np.int64)\n    low[1:] += (prev_low_cum[-1] + prev_high_cum[-1])\n    low[1:] -= prev_high_cum[:-1]\n    high = prev_low_cum * high_range\n    low %= MOD; high %= MOD\n\nanswer = (low[1:].sum() + high[1:].sum()) % MOD\nprint((answer % MOD))\n", "from itertools import accumulate\ndef BC132_F():\n    n, k = list(map(int, input().split(' ')))\n    mod = 10**9 + 7\n    sqt = int(n**0.5)\n    cnt = [n // i - n // (i + 1) for i in range(1, n // sqt)] + [1] * sqt\n    x = cnt\n    for _ in range(k):\n        x = [(i * j) % mod for i, j in zip(accumulate(reversed(x)), cnt)]\n    return x[-1]\n\n\nprint(BC132_F())", "def solve():\n    N, K = map(int, input().split())\n\n    U = []; V = []\n    for x in range(1, int(N**.5)+1):\n        U.append(x)\n        if x < N//x:\n            V.append(N//x)\n    V.reverse(); U.extend(V)\n\n    L = len(U)\n    prv = 0\n    R = []\n    for x in U:\n        R.append(x-prv)\n        prv = x\n    def gen(it):\n        MOD = 10**9 + 7\n        r = 0\n        for p, s in it:\n            r = (p * s + r) % MOD\n            yield r\n\n    S = [1]*(L+1)\n    S[-1] = 0\n    for k in range(K):\n        S[L-1::-1] = gen(zip(R, S))\n    print(S[0])\nsolve()", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nMOD = 10**9+7\n  \nn, k = map(int, input().split())\nS = set()\ni = 1\nwhile i * i <= n:\n  S.add(i)\n  S.add(n//i)\n  i += 1\nL = np.array([0] + sorted(S), dtype=np.int64)\nl = len(L) - 1\nnum = np.diff(L)\ndp = np.zeros(l, dtype=np.int64)\ndp[0] = 1\nfor _ in range(k):\n  A = np.cumsum(dp)\n  dp = A[::-1] * num\n  dp %= MOD\nans = dp.sum() % MOD\nprint(ans)", "import numpy as np\nn, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nm = n ** 0.5\ncnt = [n // i - n // (i + 1) for i in range(1, int(m) + 1)] \ncnt = np.array((cnt + [1 for _ in range(n - sum(cnt))])[::-1])\nnxt = cnt[:]\nfor _ in range(k - 1):\n\tcnt = nxt * np.cumsum(cnt)[::-1] % mod\n\nprint((sum(cnt) % mod))\n", "import numpy as np\nN,K = list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nM = int(N**.5)\n\n# M+1\u4ee5\u4e0a\u3067\u3001\u5546\u304c\u3062\u3087\u3046\u3068x\u306b\u306a\u308b\u3084\u3064\nupper_cnt = np.zeros(M+1, dtype=np.int64)\na = np.arange(M+1, dtype=np.int64)\nupper_cnt[1:] = N // a[1:] - np.maximum(M, N // (a[1:]+1))\n\n# \u6570\u5217\u306e\u672b\u7aef\u3054\u3068\u306e\u500b\u6570\n# upper\u306b\u3064\u3044\u3066\u306f\u3001\u500b\u6570\u306b\u308f\u305f\u3063\u3066\u5408\u8a08\u3092\u3068\u308b\nlower = np.zeros(M+1, dtype=np.int64)\nupper = np.zeros(M+1, dtype=np.int64)\n# 0\u9805\u76ee\u306b1\u3092\u7f6e\u3044\u3066\u304a\u304f\u3068\u3059\u308b\nlower[1] = 1\nfor k in range(1,K+1):\n    prev_lower = lower\n    prev_upper = upper\n    np.cumsum(prev_lower, out = prev_lower)\n    np.cumsum(prev_upper, out = prev_upper)\n    prev_lower %= MOD\n    prev_upper %= MOD\n    # \u4e0b\u5074 to \u4e0b\u5074\n    lower = np.zeros(M+1, dtype=np.int64)\n    lower += (prev_lower[-1] + prev_upper[-1])\n    lower[1:] -= prev_upper[:-1] # \u5546\u304cn-1\u4ee5\u4e0b\u3060\u3068\u53d7\u3051\u4ed8\u3051\u306a\u3044\n    lower[0] = 0\n    # \u4e0a\u5074 to \u4e0a\u5074\uff1a\u306a\u3044\u306f\u305a\n    # \u4e0b\u5074 to \u4e0a\u5074\uff1a\n    upper = prev_lower * upper_cnt\n    lower %= MOD\n    upper %= MOD\n    \nanswer = (lower.sum() + upper.sum()) % MOD\nprint(answer)\n", "import numpy as np\nN, K = list(map(int, input().split()))\nmod = 1000000007\n\nm = N ** 0.5\ncnt = [N // i - N // (i + 1) for i in range(1, int(m) + 1)] \ncnt = np.array((cnt + [1 for _ in range(N - sum(cnt))])[::-1])\nnxt = cnt[:]\nfor _ in range(K - 1):\n    cnt = nxt * np.cumsum(cnt)[::-1] % mod\n\nprint((sum(cnt) % mod))\n", "from itertools import accumulate\n\nMOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\n\ndef N2sqrtN(N):\n    M = int(N**0.5)\n    As = list(range(1, M+1))\n    Bs = [N//A for A in reversed(As)]\n    if As[-1] == Bs[0]:\n        return As + Bs[1:]\n    else:\n        return As + Bs\n\nBs = N2sqrtN(N)\nlenB = len(Bs)\n\nnums = [1]\nfor i in range(lenB-1):\n    nums.append(Bs[i+1]-Bs[i])\n\ndp = [0] * lenB\ndp[0] = 1\nfor i in range(1, K+1):\n    dp = list(accumulate(dp))\n    dp = [dpi*num%MOD for dpi, num in zip(reversed(dp), nums)]\n\nprint((sum(dp) % MOD))\n", "MOD = 10 ** 9 + 7\n\n\ndef main(N, K):\n  W = []\n  i = 1\n  while i <= N:\n    v = N // i\n    j = N // v\n    # keys.append((v, j - i + 1))\n    W.append(j - i + 1)\n    i += j - i + 1\n\n  l = len(W)\n  dp = [0] * l\n\n  total = 0\n  for i, w in enumerate(W):\n    total += w\n    dp[l - i - 1] = total\n\n  for i in range(2, K + 1):\n    tmp = [0] * l\n    total = 0\n    for j, w in enumerate(W):\n      v = dp[j] * w\n      total += v\n      total %= MOD\n      tmp[l - j - 1] = total\n\n    dp = tmp\n\n  return dp[0]\n\n\ndef __starting_point():\n  N, K = list(map(int, input().strip().split()))\n  # import time\n  # t = time.time()\n  print((main(N, K)))\n  # print(time.time() - t)\n\n__starting_point()", "#\u7121\u7406\u305e\nn,k=map(int, input().split())\na,b=[],[]\ni=1\n\nwhile i*i<=n:\n    a.append(i)\n    b.append(n//i)\n    i+=1\n    \nif a[-1]==b[-1]:\n    b.pop()\na+=b[::-1]\nimport numpy as np\ndp=np.array(a)\ndp[1:]-=dp[:-1]\nini=np.copy(dp)\ndel a\ndel b\nmod=10**9+7\nfor _ in range(k-1):\n    pre=np.cumsum(dp)\n    dp=ini*pre[::-1]\n    dp%=mod\nprint(sum(dp)%mod)", "from numpy import int_\n\nmod = 10 ** 9 + 7\n\nN, K = map(int, input().split())\n\nM = int(N ** 0.5)\n\nT = [N // i - N // (i + 1) for i in range(1, M + 1)]\nA = int_([1] * (N - sum(T)) + T[::-1])\n\ndp = A[:]\nfor _ in range(K - 1):\n    dp = A * dp.cumsum()[::-1] % mod\n\nprint(sum(dp) % mod)", "from itertools import accumulate\nN, K = map(int, input().split())\nmod = 10 ** 9 + 7\nsqrt = int(N**(1/2))\ncount = [N//i - N//(i+1) for i in range(1, N//sqrt)] + [1] * sqrt\nansList = count\nfor _ in range(K):\n    ansList = [(i * j) % mod for i, j in zip(accumulate(reversed(ansList)), count)]\n\nprint(ansList[-1])", "import sys\ndef solve():\n    N, K = map(int, input().split())\n    MOD = 10**9 + 7\n\n    U = []; V = []\n    for x in range(1, int(N**.5)+1):\n        U.append(x)\n        if x < N//x:\n            V.append(N//x)\n    V.reverse(); U.extend(V)\n\n    L = len(U)\n    prv = 0\n    R = []\n    for x in U:\n        R.append(x-prv)\n        prv = x\n    def gen(R, S):\n        r = 0\n        for p, s in zip(R, S):\n            r = (p * s + r) % MOD\n            yield r\n\n    S = [1]*(L+1)\n    S[-1] = 0\n    for k in range(K):\n        S[L-1::-1] = gen(R, S)\n    print(S[0])\nsolve()", "import numpy as np\n\nn, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nmx = np.sqrt(n).astype(int)\n\ndp_u = np.ones(mx, np.int64)\n\nN = np.full(mx, n, np.int64)\nL = N // np.arange(1, mx + 1)\nR = np.maximum(N // np.arange(2, mx + 2), mx)\ncoef = L - R\ndp_d = coef\n\nfor _ in range(2, k + 1):\n    acc_u = np.cumsum(dp_u) % mod\n    acc_d = np.cumsum(dp_d[::-1])[::-1] % mod\n    dp_u = (dp_u.sum() + acc_d) % mod\n    dp_d = coef * acc_u % mod\n\nans = (dp_u.sum() + dp_d.sum()) % mod\nprint(ans)\n", "import numpy as np\n\nn, k = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = int(n ** 0.5)\ncoe = [n // i - l for i in range(l, 0, -1)]\ncoe.append(0)\ncoe.reverse()\ncoe = np.array(coe, dtype=np.int64)\n\ndp1 = np.ones(l + 1, dtype=np.int64)\ndp2 = coe.copy()\ndp1[0] = 0\nfor i in range(k - 1):\n    dp1acc_f = np.add.accumulate(dp1) % MOD\n    dp1acc_b = np.add.accumulate((dp1 * coe % MOD)[::-1])[::-1] % MOD\n    s = dp1acc_f[-1]\n    dp1acc_f = np.roll(dp1acc_f, 1)\n    dp1[1:] = (s + dp2[1:]) % MOD\n    dp2[1:] = (dp1acc_b + dp1acc_f * coe)[1:] % MOD\nans = (dp1.sum() + dp2[1]) % MOD\nprint(ans)\n", "import numpy as np\n\nn, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nmx = 1\nwhile (mx + 1) ** 2 <= n:\n    mx += 1\n\ndp_u = np.ones(mx, np.int64)\nN = np.full(mx, n, np.int64)\nL = N // np.arange(1, mx + 1)\nR = np.maximum(N // np.arange(2, mx + 2), mx)\ncoef = L - R\ndp_d = coef\n\nfor _ in range(2, k + 1):\n    acc_u = np.cumsum(dp_u) % mod\n    acc_d = np.cumsum(dp_d[::-1]) % mod\n    dp_u = (dp_u.sum() + acc_d[::-1]) % mod\n    dp_d = coef * acc_u % mod\n\nans = (dp_u.sum() + dp_d.sum()) % mod\nprint(ans)\n", "from itertools import accumulate\n\ndef f(n,k):\n    lim = int((n + 0.1) ** 0.5) + 1\n    ws = []\n    s = 0\n    for i in range(1, lim):\n        w = n // i - n // (i + 1)\n        ws.append(w)\n        s += w\n    ws += [1] * (n - s)\n    dp=ws\n    m = len(ws)\n    for _ in range(k - 1):\n        dp=[s*w%md for s,w in zip(accumulate(dp[::-1]),ws)]\n    print((sum(dp) % md))\nmd=10**9+7\nn,k=list(map(int,input().split()))\nf(n,k)\n", "import numpy as np\nN, K = list(map(int, input().split()))\nmod = 1000000007\n\nm = N ** 0.5\ncnt = [N // i - N // (i + 1) for i in range(1, int(m) + 1)] \ncnt = np.array((cnt + [1 for _ in range(N - sum(cnt))])[::-1])\nnxt = cnt[:]\nfor _ in range(K - 1):\n    cnt = nxt * np.cumsum(cnt)[::-1] % mod\n\nprint((sum(cnt) % mod))\n", "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\nMOD = 10**9+7\n\ndef main():\n  n, k = map(int, input().split())\n  S = set()\n  i = 1\n  while i * i <= n:\n    S.add(i)\n    S.add(n//i)\n    i += 1\n  L = [0] + sorted(S)\n  l = len(L) - 1\n  num = [0]*l\n  for i in range(l):\n    num[i] = L[i+1] - L[i]\n  dp = [0]*l\n  dp[0] = 1\n  for _ in range(k):\n    A = list(accumulate(dp))\n    for i in range(l):\n      dp[i] = A[l-1-i] * num[i]\n      dp[i] %= MOD\n  ans = sum(dp) % MOD\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "import numpy as np\nN, K = list(map(int,input().split()))\nMOD = 10**9+7\ndiv = list(range(1, int(np.sqrt(N))+1))\nL1 = len(div)\ndiv2 = [N//val for val in div]\ndiv2.sort()\nif div[-1] == div2[0]:\n    div2.remove(div2[0])\nL2 = len(div2)\nL = L1+L2\nls = [1]*L1 + [0]*L2\ntmp = div[-1]\nfor i,val in enumerate(div2):\n    ls[i+L1] = val-tmp\n    tmp = val\ndp = [0]*L\ndp = np.zeros((L), dtype='int64')\nls = np.array(ls, dtype='int64')\ndp[:] = ls\nr = np.zeros(L+1, dtype='int64')\nr[:-1] = np.cumsum(dp, dtype='int64')[::-1]\nfor i in range(K-1):\n    dp = (r[:-1]*ls)%MOD\n    r[:-1] = np.cumsum(dp, dtype='int64')[::-1]\nprint((r[0]%MOD))\n", "import numpy as np\n\nMOD = 10**9+7\n\ndef divisor(x):\n    div = [0]\n    for i in range(1,int(x**0.5)+1):\n        div.append(i)\n        if x != i**2: div.append(x//i)\n    return div\n\nN,K = map(int,input().split())\n\ndiv = np.array(divisor(N))\ndiv = np.sort(div)\ndiv_dif = np.diff(div)\ndiv_num = div.size -1 \n\ndp = np.ones((K+1,div_num),np.int64)\n\nfor i in range(K):\n    dp[i+1] = dp[i][::-1] * div_dif % MOD\n    dp[i+1] = dp[i+1].cumsum() % MOD\n    \n    \nprint(dp[-1][-1])", "from numpy import int_\n\nmod = 10 ** 9 + 7\n\nN, K = map(int, input().split())\n\nM = int(N ** 0.5)\nT = [N // i - N // (i + 1) for i in range(1, M + 1)]\ndp = int_([1] * (N - sum(T)) + T[::-1])\n\nA = dp[:]\nfor _ in range(K - 1):\n    dp = A * dp.cumsum()[::-1] % mod\n\nprint(sum(dp) % mod)", "from itertools import accumulate as ac\nN,K=map(int,input().split())\nn=int(N**0.5)\nmod=10**9+7\nlist_a=[1]*n\nlist_b=[N//j-N//(j+1) for j in range(1,n)]+[(N//n-n)]\nlist_p=[p for p in list_b]\nlist_aa=list(ac(list_a))\nlist_bb=list(reversed(list(ac(reversed(list_b)))))\n\nfor i in range(K-1):\n    temp=sum(list_a)\n    list_a=[(temp+list_bb[j])%mod for j in range(n)]\n    list_b=[(list_p[j]*list_aa[j])%mod for j in range(n)]\n    list_aa=list(ac(list_a))\n    list_bb=list(reversed(list(ac(reversed(list_b)))))\n    \nprint((sum(list_a+list_b))%mod)", "import numpy as np\nN,K = map(int,input().split())\nMOD = 10 ** 9 + 7\nM = int(N**.5)\n\n# M+1\u4ee5\u4e0a\u3067\u3001\u5546\u304c\u3062\u3087\u3046\u3068x\u306b\u306a\u308b\u3084\u3064\nupper_cnt = np.zeros(M+1, dtype=np.int64)\na = np.arange(M+1, dtype=np.int64)\nupper_cnt[1:] = N // a[1:] - np.maximum(M, N // (a[1:]+1))\n\n# \u6570\u5217\u306e\u672b\u7aef\u3054\u3068\u306e\u500b\u6570\n# upper\u306b\u3064\u3044\u3066\u306f\u3001\u500b\u6570\u306b\u308f\u305f\u3063\u3066\u5408\u8a08\u3092\u3068\u308b\nlower = np.zeros(M+1, dtype=np.int64)\nupper = np.zeros(M+1, dtype=np.int64)\n# 0\u9805\u76ee\u306b1\u3092\u7f6e\u3044\u3066\u304a\u304f\u3068\u3059\u308b\nlower[1] = 1\nfor k in range(1,K+1):\n    prev_lower = lower\n    prev_upper = upper\n    cum_lower = prev_lower.cumsum() % MOD\n    cum_upper = prev_upper.cumsum() % MOD\n    # \u4e0b\u5074 to \u4e0b\u5074\n    lower = np.zeros(M+1, dtype=np.int64)\n    lower += (cum_lower[-1] + cum_upper[-1])\n    lower[1:] -= cum_upper[:-1] # \u5546\u304cn-1\u4ee5\u4e0b\u3060\u3068\u53d7\u3051\u4ed8\u3051\u306a\u3044\n    lower[0] = 0\n    # \u4e0a\u5074 to \u4e0a\u5074\uff1a\u306a\u3044\u306f\u305a\n    # \u4e0b\u5074 to \u4e0a\u5074\uff1a\n    upper = cum_lower * upper_cnt\n    lower %= MOD\n    upper %= MOD\n    \nanswer = (lower.sum() + upper.sum()) % MOD\nprint(answer)", "import numpy as np\n\nn, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nmx = np.sqrt(n).astype(int)\n\ndp_u = np.ones(mx, np.int64)\n\nN = np.full(mx, n, np.int64)\nRNG = np.arange(1, mx + 2)\nL = N // RNG[:-1]\nR = N // RNG[1:]\nR[-1] = np.maximum(R[-1], mx)\ncoef = L - R\ndp_d = coef\n\nfor _ in range(2, k + 1):\n    acc_u = np.cumsum(dp_u) % mod\n    acc_d = np.cumsum(dp_d[::-1])[::-1] % mod\n    dp_u = (dp_u.sum() + acc_d) % mod\n    dp_d = coef * acc_u % mod\n\nans = (dp_u.sum() + dp_d.sum()) % mod\nprint(ans)\n"]
["#!/usr/bin/env python3\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef S():\n    return input().rstrip()\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return list(map(int, input().split()))\n\n\nN, X, Y = MI()\ncnt = [0] * N\n\nfor i in range(1, N + 1):\n    for j in range(i + 1, N + 1):\n        idx = min(j - i, abs(X - i) + abs(Y - j) + 1)\n        cnt[idx] += 1\n\nfor c in cnt[1:]:\n    print(c)\n", "import scipy.sparse as sparse\nfrom scipy.sparse.csgraph import shortest_path \nimport numpy as np\n\nn, x, y = [int(i) for i in input().split()]\nx -= 1\ny -= 1\n\none = np.ones((2,n),dtype=int)\nc = sparse.spdiags(one, np.array([-1, 1]), n, n, format='lil')\n\nc[x, y], c[y, x] = 1, 1\n\nc = c.tocsr()\n\npath = shortest_path(c, directed=False, unweighted=True)\n\nu, counts = np.unique(path, return_counts=True)\ncounts = counts//2\n\nfor i in range(1, int(u[-1])+1):\n\tprint((counts[i]))\nfor i in range(int(u[-1])+1, n):\n\tprint((0))\n\n", "def main():\n    n, x, y = list(map(int, input().split()))\n    ans = [0]*(n)\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            ans[min(j-i, abs(x-i)+abs(y-j)+1)] += 1\n    for v in ans[1:]:\n        print(v)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,x,y=list(map(int,input().split()))\n\nans=0\nans=[0]*(n-1)\nfor i in range(1,n+1):\n  for j in range(i+1,n+1):\n    now=min(j-i,abs(j-y)+abs(i-x)+1)\n    ans[now-1]+=1\n\nfor i in ans:\n  print(i)\n", "def main():\n  N, X, Y = map(int, input().split())\n  G = [[i] for i in range(1,N+1)]\n  ans=[0]*(N-1)\n  for i in range(1,N+1):\n    for j in range(i+1,N+1):\n      d = min(j-i, abs(X-i)+1+abs(j-Y), abs(Y-i)+1+abs(j-X))\n      #print(i,j,d)\n      ans[d-1]+=1\n  for a in ans:\n    print(a)\n\ndef __starting_point():\n  main()\n__starting_point()", "from collections import defaultdict\nans = defaultdict(int)\nN, X, Y = map(int, input().split())\nfor i in range(1, N+1):\n  for j in range(1+i, N+1):\n    l1 = j-i\n    l2 = abs(X-i) + 1 + abs(Y-j)\n    ans[min(l1, l2)] += 1\nfor i in range(1, N):\n  print(ans[i])", "from itertools import *\nfrom numpy import *\nfrom scipy.sparse.csgraph import *\nN,X,Y = map(int,input().split())\nA = (N-1)*[0]\nG = zeros((N,N))\nG[X-1][Y-1] = 1\nG[Y-1][X-1] = 1\n\nfor n in range(N-1):\n  G[n][n+1] = 1\n  G[n+1][n] = 1\n\nS = shortest_path(G)\n\nfor i,j in combinations(range(N),2):\n  A[int(S[i][j])-1]+=1\n\nprint(*A,sep=\"\\n\")", "N, X, Y = map(int, input().split())\n\np = Y-X+1\narm_a = X-1\narm_b = N-Y\n\nif p%2:\n    for i in range(1, N):\n        ans = 0\n\n        if i*2 < p:\n            ans += p\n        \n        if 1 < i <= p//2+arm_a:\n            ans += 2*min(arm_a, p//2, arm_a+p//2-i+1, i-1)\n\n        if 1 < i <= p//2+arm_b:\n            ans += 2*min(arm_b, p//2, arm_b+p//2-i+1, i-1)\n\n        if i <= arm_a:\n            ans += arm_a-i+1\n\n        if i <= arm_b:\n            ans += arm_b-i+1\n\n        if 2 < i <= arm_a+arm_b+1:\n            ans += min(arm_a, arm_b, arm_a+arm_b-i+2, i-2)\n\n        print(ans)\nelse:\n    for i in range(1, N):\n        ans = 0\n\n        if i*2 < p:\n            ans += p\n        elif i*2 == p:\n            ans += p//2\n\n        if 1 < i < p//2+arm_a:\n            ans += 2*min(arm_a, p//2-1, arm_a+p//2-i, i-1)\n        if p//2 < i <= p//2+arm_a:\n            ans += 1\n\n        if 1 < i < p//2+arm_b:\n            ans += 2*min(arm_b, p//2-1, arm_b+p//2-i, i-1)\n        if p//2 < i <= p//2+arm_b:\n            ans += 1\n\n        if i <= arm_a:\n            ans += arm_a-i+1\n\n        if i <= arm_b:\n            ans += arm_b-i+1\n\n        if 2 < i <= arm_a+arm_b+1:\n            ans += min(arm_a, arm_b, arm_a+arm_b-i+2, i-2)\n\n        print(ans)", "def main():\n\n    n, x, y = map(int,input().split())\n\n    cnt = 0\n\n    ans=[0]*n\n\n    for i in range(1,n+1):\n        for j in range(i+1,n+1):\n            d = min(j-i,abs(x-i)+abs(y-j)+1)\n            ans[d] += 1\n\n    for i in range(1,n):\n        print(ans[i])\n   \ndef __starting_point():\n    main()\n__starting_point()", "N,X,Y=map(int,input().split())\nA=[0]*(N-1)\nfor i in range(1,N):\n  for j in range(i+1,N+1):\n    A[min(j-i,abs(X-i)+1+abs(j-Y),abs(Y-i)+1+abs(j-X))-1]+=1\nfor a in A:\n  print(a)", "n,x,y = list(map(int,input().split()))\nb = [0]*n\n\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        dist1 = j-i\n        dist2 = abs(x-i)+abs(y-j)+1\n        dist3 = abs(y-i)+abs(x-j)+1\n        d = min(dist1,dist2,dist3)\n        b[d] += 1\n\nfor i in range(1,n):\n    print((b[i]))\n", "N, X, Y = list(map(int, input().split()))\n\n\ndef f(i, j):\n    v1 = j - i\n    v2 = abs(X - i) + 1 + abs(j - Y)\n    v3 = abs(Y - i) + 1 + abs(j - X)\n    return min(v1, v2, v3)\n\n\nD = [0] * N\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        d = f(i, j)\n        D[d] += 1\n\nfor d in D[1:]:\n    print(d)\n", "N, X, Y = map(int, input().split())\n\nres = [0]*(N-1)\n\nfor i in range(1, N+1):\n    for j in range(i+1, N+1):\n        # i -> j\n        d1 = abs(j - i)\n        # i -> X -> Y -> j\n        d2 = abs(X-i) + abs(Y-j) + 1\n        # i -> Y -> X -> j\n        d3 = abs(Y-i) + abs(X-j) + 1\n\n        min_d = min(d1, d2, d3)\n        res[min_d-1] += 1\n\nprint(*res, sep='\\n')\n", "import math\nimport itertools\ndef comb(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nN, X, Y =list(map(int,input().split()))\n\nL = [i for i in range(1,N+1)]\nc_list = list(itertools.combinations(L,2))\n\nAnswer = {}\nfor i in range(1,N):\n    inti = str(i)\n    Answer[inti] = 0\ndef des(a,b):\n    if b <= X or a >=  Y:\n        return (b-a)\n    else:\n        return min(b-a, abs(Y-b)+abs(X-a)+1)\nfor cl in c_list:\n    a = cl[0]\n    b = cl[1]\n    inti = des(a,b)\n    inti = str(inti)\n    Answer[inti] += 1\nfor n, m in list(Answer.items()):\n    print(m)\n", "N, X, Y = list(map(int, input().split()))\n\nanss = [0] * N\nfor i in range(1, N+1):\n    for j in range(i+1, N+1):\n        d1 = j-i\n        d2 = abs(i-X) + 1 + abs(Y-j)\n        d = d1 if d1 <= d2 else d2\n        anss[d] += 1\n\nprint(('\\n'.join(map(str, anss[1:]))))\n", "N, X, Y = map(int, input().split())\nA = [N - i for i in range(1, N)]\nfor i in range(N-1):\n  for j in range(i+1, N):\n    c = min(abs(X-i-1)+abs(Y-j-1)+1, abs(X-j-1)+abs(Y-i-1)+1)\n    if c < j-i:\n      A[j-i-1] -= 1\n      A[c-1] += 1\nfor a in A:\n  print(a)", "from collections import deque\nfrom collections import Counter\n\nn,x,y = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(1,n):\n  a,b = i,i+1\n  graph[a].append(b)\n  graph[b].append(a)\ngraph[x].append(y)\ngraph[y].append(x)\n\nl = []\nfor j in range(1,n+1):\n  dist = [-1] * (n+1)\n  dist[0] = 0\n  dist[j] = 0\n\n  d = deque()\n  d.append(j)\n\n  while d:\n    v = d.popleft()\n    for i in graph[v]:\n      if dist[i] != -1:\n        continue\n      dist[i] = dist[v] + 1\n      d.append(i)\n\n  l.extend(dist[1:])\n\nc = Counter(l)\nfor i in range(1,n):\n  print(int(c[i]/2))", "n, x, y = list(map(int, input().split()))\nans = [0 for _ in range(n)]\n\nfor i in range(1, n+1):\n    for j in range(i+1, n+1):\n        a = min(abs(i-j), abs(x-i)++abs(j-y)+1, abs(y-i)+abs(j-x)+1)\n        ans[a] += 1\nfor i in range(1, n):\n    print((ans[i]))\n", "n,x,y=list(map(int,input().split()))\ndic={}\nfor i in range(1,n+1):\n  for j in range(i+1,n+1):\n    l=min(j-i,abs(x-i)+1+abs(y-j))\n    if l in dic:\n      dic[l]+=1\n    else:\n      dic[l]=1\nfor l in range(1,n):\n  if l in dic:\n    print((dic[l]))\n  else:\n    print((0))\n", "N, X, Y = list(map(int, input().split()))\nds = [0] * (N - 1)\n\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        d = min(j - i, abs(X - i) + 1 + abs(Y - j))\n        ds[d - 1] += 1\n\nfor d in ds:\n    print(d)\nreturn\n", "import sys\nfrom collections import deque\nr=sys.stdin.readline\nN,X,Y=map(int,r().split())\nres=[0]*N\nG=[[] for _ in range(N+1)]\nfor i in range(1,N):\n    G[i].append(i+1)\n    G[i+1].append(i)\nG[X].append(Y)\nG[Y].append(X)\n\ndef bfs(start):\n    q=deque([(start,0)])\n    visited=[False]*(N+1)\n    visited[start]=True\n    cnt=0\n    while q:\n        cur,d=q.popleft()\n        if d!=0:\n            res[d]+=1\n        for v in G[cur]:\n            if not visited[v]:\n                visited[v]=True\n                q.append((v,d+1))\n    return cnt\nfor i in range(1,N+1):\n    bfs(i)\nfor j in range(1,N):    \n    print(res[j]//2)", "import sys\nreadline = sys.stdin.readline\n\nN,X,Y = map(int,readline().split())\nX -= 1\nY -= 1\nans = [0] * N\nfor i in range(N - 1):\n  for j in range(i + 1, N):\n    val = min(abs(i - j),abs(i - X) + 1 + abs(j - Y), abs(i - Y) + 1 + abs(j - X))\n    ans[val] += 1\n    \nfor i in range(1, len(ans)):\n  print(ans[i])", "N, X, Y = map(int, input().split())\nL = [0]*(N+1)\n\nfor i in range(1, N):\n  for j in range(i+1, N+1):\n    L[(min(j-i, abs(X-i)+1+abs(Y-j)))] += 1\nfor i in range(1, N):\n  print(L[i])", "n,x,y=list(map(int,input().split()))\nx-=1\ny-=1\nhalf=(x+y)//2\nans=[0]*n\nfor i in range(n):\n    for j in range(i,n):\n        if i<=x:\n            if j<=half:\n                ans[j-i]+=1\n            else:\n                ans[x-i+1+abs(y-j)]+=1\n        elif x<i and i<=y:\n            ans[min(j-i,i-x+1+abs(y-j))]+=1\n        else:\n            ans[j-i]+=1\nfor i in range(1,n):\n    print((ans[i]))\n", "N, X, Y = map(int, input().split())\nlst = [0 for i in range(N-1)]\nfor i in range(1, N+1):\n    for j in range(i+1, N+1):\n        k = min(abs(j-i), abs(X-i) + abs(Y-j) + 1)\n        lst[k-1] += 1\nfor i in lst:\n    print(i)", "from collections import deque\n\nN, X, Y = map(int, input().split())\n\nans_list = [0 for _ in range(N-1)]\n\nfor i in range(1, N+1): #1 \uff5e N start\n    for j in range(i+1, N+1): # i+1 \uff5e N goal\n        ans1 = j - i\n        ans2 = abs(i-X) + 1 + abs(j-Y)\n        ans_list[min(ans1, ans2)-1] += 1\nprint(*ans_list, sep=\"\\n\")", "n, x, y = map(int, input().split())\ncounter = {i + 1: 0 for i in range(n - 1)}\n\nfor i in range(n - 1):\n  for j in range(i + 1, n):\n    k = min(j - i, abs(x - 1 - i) + abs(y - 1 - j) + 1)\n    counter[k] += 1\n\nprint(*[counter[i + 1] for i in range(n - 1)], sep='\\n')", "def main():\n    n, x, y = map(int, input().split())\n    ans = [0] * (n+1)\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            # x->y\u3092\u901a\u3089\u306a\u3044\n            d1 = abs(j-i)\n            # i->x->y->j\u306e\u9806 +1\u306fx->y\u306e\u5206\n            d2 = abs(x-i) + 1 + abs(j-y) \n            # i->y->x->j\u306e\u9806 +1\u306fy->x\u306e\u5206\n            d3 = abs(y-i) + 1 + abs(j-x)\n            dist = min(min(d1, d2), d3)\n            ans[dist] += 1\n    print(*ans[1:n], sep='\\n')\n\ndef __starting_point():\n    main()\n__starting_point()", "N,X,Y=map(int,input().split())\nX,Y=X-1,Y-1\nd=[0]*N\nfor i in range(N-1):\n  for j in range(i+1,N):\n    a=min(abs(j-i),abs(X-i)+1+abs(j-Y))\n    d[a]+=1\nfor i in range(1,N):\n  print(d[i])", "import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n, x, y= list(map(int, input().split()))\n    edges = {e:[] for e in range(n)}\n    for i1 in range(1, n - 1):\n        edges[i1].append(i1-1)\n        edges[i1].append(i1+1)\n    edges[0].append(1)\n    edges[n-1].append(n-2)\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\n\n    dis = defaultdict(int)\n    for j1 in range(n):\n        seen = set()\n        cnt = 0\n        dis_each = [n] * n\n        nexts = [j1]\n        nextnext = []\n        while len(seen) < n:\n            for next in nexts:\n                if next not in seen:\n                    seen.add(next)\n                    dis_each[next] = cnt\n                    nextnext += edges[next]\n            nexts = nextnext\n            nextnext = []\n            cnt += 1\n        for d in dis_each:\n            dis[d] += 1\n    for k1 in range(1, n):\n        print((dis[k1]//2))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, x, y = map(int, input().split())\n\nx -= 1\ny -= 1\n\ndist = [0] * n\nfor i in range(0, n):\n    for j in range(i+1, n):\n        d = min(abs(j-i), abs(x-i)+1+abs(j-y), abs(y-i)+1+abs(j-x))\n        dist[d] += 1\n\nfor k in range(1, n):\n    print(dist[k])", "n, x, y = map(int, input().split())\nli = [0] * (n - 1)\nnum = 0\n\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        num = min(j-i, abs(i-x)+abs(j-y)+1)\n        li[num - 1] += 1\n\nfor i in li:\n    print(i)", "N,X,Y = map(int,input().split())\nX-=1;Y-=1\nans = [0 for _ in range(N-1)]\nfor i in range(N):\n  for j in range(i+1,N):\n    direct = j-i\n    shortcut = abs(X-i)+1+abs(Y-j)\n    shortest = min(direct,shortcut)\n    ans[shortest-1] += 1\nprint(*ans,sep=\"\\n\")", "from collections import Counter\nn, x, y = list(map(int, input().split()))\nc = Counter()\nfor i in range(1, n):\n    for j in range(i+1, n+1):\n        dist = min(abs(j-i), abs(x-i)+1+abs(j-y), abs(y-i)+1+abs(j-x))\n        c[dist] += 1\n\nfor k in range(1, n):\n    print((c[k]))\n", "n,x,y = map(int, input().split())\ng = [0]*(n)\nfor i in range(1,n+1):\n  for j in range(1,i):\n    e = abs(y-i)+1+abs(x-j)\n    f = i-j\n    g[min(e,f)]+=1\nfor i in g[1:]:\n  print(i)", "def main():\n\tN, X, Y = [int(n) for n in input().split(\" \")]\n\tvertex = [[1]] + [[i - 1, i + 1] for i in range(1, N - 1)] + [[N - 2]]\n\tvertex[X - 1].append(Y - 1)\n\tvertex[Y - 1].append(X - 1)\n\n\tcount = [0] * N\n\tfor i in range(N):\n\t\tto_visit = [i]\n\t\tchecked = [0] * N\n\t\tsteps = [0] * N\n\t\tchecked[i] = 1\n\n\t\twhile len(to_visit) > 0:\n\t\t\tvisiting = to_visit.pop(0)\n\t\t\tvs = vertex[visiting]\n\t\t\tstep = steps[visiting]\n\t\t\tfor v in vs:\n\t\t\t\tif checked[v] == 0:\n\t\t\t\t\tchecked[v] = 1\n\t\t\t\t\tto_visit.append(v)\n\t\t\t\t\tsteps[v] = step + 1\n\t\t\t\t\tcount[step + 1] += 1\n\n\tfor c in count[1:]:\n\t\tprint(int(c/2))\n\nmain()", "from collections import deque\n\nn, x, y = map(int, input().split())\n\ng = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    g[i].append(i + 1)\n    g[i + 1].append(i)\ng[x - 1].append(y - 1)\ng[y - 1].append(x - 1)\n\n\ndef bfs(g, n_node, start_node):\n    dist = [-1] * n_node\n    dist[start_node] = 0\n    que = deque([start_node])\n\n    while que:\n        node = que.popleft()\n        for j in g[node]:\n            if dist[j] != -1:\n                continue\n            dist[j] = dist[node] + 1\n            que.append(j)\n    return dist\n\n\nans = [0] * n\n\nfor i in range(n):\n    dist = bfs(g, n, i)\n    for d in dist:\n        ans[d] += 1\n\nfor a in ans[1:]:\n    print(a//2)", "from collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nimport math\n\ndef readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\n\nn,x,y = readInts()\n\nd = defaultdict(int)\n\nfor i in range(1,n+1):\n\tfor j in range(i+1,n+1):\n\t\td[min(abs(i-j),abs(i-x)+1+abs(y-j),abs(i-y)+1+abs(j-x))]+=1\n\nfor i in range(1,n):\n\tprint(d[i])", "n, x, y = map(int, input().split())\na = [0]*(n-1)\nfor i in range(1, n):\n    for j in range(i+1, n+1):\n        b = min(j-i, abs(x-i)+1+abs(y-j))\n        a[b-1] += 1\nprint(*a, sep=\"\\n\")", "import sys\n\nN, X, Y = map(int, sys.stdin.readline().split())\n\nans = [0] * (N-1)\nfor i in range(1, N):\n    for j in range(i+1, N+1):\n        k = min((j - i, abs(X - i) + 1 + abs(j - Y), abs(X - j) + 1 + abs(i - Y)))\n        # print(k)\n        ans[k-1] += 1\n\n# print(ans)\nfor i in range(N-1):\n    print(ans[i])", "N,X,Y=map(int,input().split())\nL=[0]*(N+1)\nfor i in range(1,N):\n  for j in range(i+1,N+1):\n    L[(min(j-i,abs(X-i)+1+abs(Y-j)))]+=1\nfor i in range(1,N):\n  print(L[i])", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,x,y=nii()\nx-=1\ny-=1\nans=[0 for i in range(n)]\n\nfor i in range(n-1):\n  for j in range(i+1,n):\n    dist1=j-i\n    dist2=abs(i-x)+1+abs(j-y)\n    dist=min(dist1,dist2)\n    ans[dist]+=1\n\nfor i in ans[1:]:\n  print(i)", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n\n    n,x,y=list(map(int, readline().rstrip().split()))\n    ans = [0] * (n-1)\n    for i in range(1,n+1):\n        for j in range(i+1,n+1):\n            d1 = abs(i-x) + abs(j-x)\n            d2 = abs(i-y) + abs(j-y)\n            d3 = abs(i-x) + abs(j-y) + 1\n            d4 = abs(i-y) + abs(j-x) + 1\n            d5 = abs(i-j)\n            d=min(d1,d2,d3,d4,d5)\n            ans[d-1]+=1\n    for a in ans:\n        print(a)\n    #arr=list(map(int, readline().rstrip().split()))\n    #n=int(readline())\n    #ss=readline().rstrip()\n    #yn(1)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "from collections import deque\n\nn, x, y = map(int, input().split())\n\ng = [[] for _ in range(n)]\n\n# make graph\nfor i in range(n - 1):\n    g[i].append(i + 1)\n    g[i + 1].append(i)\n\ng[x - 1].append(y - 1)\ng[y - 1].append(x - 1)\n\ndef bfs(g, n_node, start_node):\n    dist = [-1] * n_node\n    dist[start_node] = 0\n    queue = deque([start_node])\n\n    while queue:\n        node = queue.popleft()\n        for n in g[node]:\n            if dist[n] != -1:\n                continue\n            dist[n] = dist[node] + 1\n            queue.append(n)\n    return dist\n\n\nans_array = [0] * n\nfor i in range(n):\n    dist = bfs(g, n, i)\n    for d in dist:\n        ans_array[d] += 1\n\nfor i in ans_array[1:]:\n    print(i // 2)", "N, X, Y = list(map(int,input().split()))\n\ndis_list = [0] * (N-1)\n\n#X\u304b\u3089\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\ndis_X = [0] * N\n\nfor i in range(N):\n    dis_X[i] = min(abs(X - (i + 1)),abs(Y - (i + 1)) + 1)\n\n#\n    #\u30b9\u30bf\u30fc\u30c8\u4f4d\u7f6e\nfor start in range(N):\n    for goal in range(start+1,N):\n        dis = min(abs(X - (start + 1)) + abs(Y - (goal + 1)) + 1,goal-start)\n        dis_list[dis-1] += 1\n\nfor ans in dis_list:\n    print(ans)\n", "n, x, y = map(int, input().split())\n\nl = [0] * (n-1)\nfor i in range(1, n):\n    for j in range(i+1, n+1):\n        s = min(j-i, abs(x-i)+abs(j-y)+1)\n        l[s-1] += 1\nfor i in l:\n    print(i)", "N,X,Y=map(int,input().split())\n\ndp=[[0]*N for i in range(N)]\ndist=[0]*N\nX-=1\nY-=1\nfor i in range(N):\n  for j in range(N):\n    if not i<j:continue\n    dp[i][j]=min(j-i,abs(j-Y)+1+abs(X-i))\n    dist[dp[i][j]]+=1\n\nfor i in dist[1:]:\n  print(i)", "n,x,y = list(map(int,input().split()))\n\ndis_list = [0]*(n)\n\nfor start in range(1,n+1):\n    for end in range(start+1,n+1):\n        dis1 = end - start\n#        dis2 = (end-start) - (y-(x+1))\n        dis3 = abs(x-start)+abs(y-end)+1\n        a = min(dis1,dis3)\n        dis_list[a] += 1\n\n\nfor i in range(1,n):\n    print((dis_list[i]))\n", "def main():\n    n, x, y = map(int, input().split())\n    ans = [0] * (n+1)\n    d = list()\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            # x->y\u3092\u901a\u3089\u306a\u3044\n            d1 = abs(j-i)\n            # i->x->y->j\u306e\u9806 +1\u306fx->y\u306e\u5206\n            d2 = abs(x-i) + 1 + abs(j-y) \n            # i->y->x->j\u306e\u9806 +1\u306fy->x\u306e\u5206\n            d3 = abs(y-i) + 1 + abs(j-x)\n            dist = min(min(d1, d2), d3)\n            d.append(dist)\n            ans[dist] += 1\n    print(*ans[1:n], sep='\\n')\n\ndef __starting_point():\n    main()\n__starting_point()", "n, x, y = map(int,input().split())\n\ncnt = 0\n\nans=[0]*n\n\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        d = min(j-i,abs(x-i)+abs(y-j)+1)\n        ans[d] += 1\nfor i in range(1,n):\n    print(ans[i])", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\ndef main():\n    n, x, y = i_map()\n    ans = [0] * n\n\n    for fr in range(1, n+1):\n        for to in range(fr+1, n+1):\n            cost = min(to - fr, abs(x-fr) + abs(to - y) + 1)\n            ans[cost] += 1\n    print(*ans[1:], sep=\"\\n\")\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,x,y=map(int,input().split())\nanslist = [0]*(n)\ntemp = 0\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        temp = min(abs(j-i),(abs(x-i)+1+abs(y-j)),(abs(y-i)+1+abs(x-j)))\n        anslist[temp] += 1\n\nanslist.pop(0)\n\nfor i in anslist:\n    print(i)", "import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n, x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    dis = defaultdict(int)\n    for i1 in range(n):\n        for i2 in range(i1+1, n):\n            d = min(abs(i2-i1), abs(x-i1)+abs(y-i2)+1, abs(x-i2)+abs(y-i1)+1)\n            dis[d] += 1\n\n    for k1 in range(1, n):\n        print(dis[k1])\n\ndef __starting_point():\n    main()\n__starting_point()", "N, X, Y = [int(x) for x in input().split()]\n\nD = [0 for _ in range(N)]\n\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        D[min(j - i, abs(i - X) + 1 + abs(j - Y))] += 1\n\nfor i in range(1, N):\n    print((D[i]))\n", "n,x,y=list(map(int,input().split()))\n\nans=[0 for _ in range(n-1)]\n\nfor i in range(n-1):\n  for j in range(i+1,n):\n    t=i+1\n    u=j+1\n    H=min(abs(u-t),abs(t-x)+1+abs(y-u),abs(t-y)+1+abs(x-u))\n    ans[H-1]+=1\n    \nfor l in ans:\n  print(l)\n", "n,x,y = list(map(int,input().split()))\nans_ls = [0] * (n-1)\nfor start in range(1,n):\n    for end in range(start+1,n+1):\n        cost_1 = end - start\n        cost_2 = abs(start - x) + abs(end - y) + 1\n        cost = min(cost_1,cost_2)\n        ans_ls[cost-1] += 1\nfor ans in ans_ls:\n    print(ans)\n\n", "n,x,y = list(map(int, input().split()))\nx,y = x-1,y-1\nans = [0] * (n-1)\nfor i in range(n-1):\n    for j in range(i+1, n):\n        d = min(j-i, abs(x-i)+1+abs(j-y), abs(y-i)+1+abs(j-x))\n        ans[d-1] += 1\nfor a in ans:  print(a)\n", "import collections\n\nN, X, Y = [int(x) for x in input().split()]\n\nc = collections.Counter()\n\nfor i in range(1, N + 1):\n    for j in range(i, N + 1):\n        if (i == X and j == Y) or (i == Y and j == X):\n            c[1] += 1\n        else:\n            c[min([j - i, abs(X - i) + 1 + abs(Y - j), abs(X - j) + 1 + abs(Y - i)])] += 1\n\nfor i in range(1, N):\n    print((c[i]))\n", "n, x, y = map(int, input().split())\nans = [0] * (n-1)\nfor i in range(1, n):\n  for j in range(i+1, n+1):\n    ans[min(abs(i-j), abs(x-i)+abs(j-y)+1, abs(y-i)+abs(j-x)+1)-1] += 1\nfor i in range(n-1):\n  print(ans[i])", "N, X, Y = [int(_) for _ in input().split()]\nX -= 1\nY -= 1\n\nV = [0 for _ in range(N)]\nfor i in range(N):\n    for j in range(i+1, N):\n        v1 = j - i\n        v2 = abs(i - X) + abs(j - Y) + 1\n        V[min(v1, v2)] += 1\n        \nfor v in V[1:]:\n    print(v)\n", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, X, Y = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\ncnt = [0] * N\nfor i in range(1, N + 1):\n    for j in range(i + 1, N + 1):\n        k = min([j - i, abs(X - i) + abs(Y - j) + 1, abs(Y - i) + abs(X - j) + 1])\n        cnt[k] += 1\n\nfor i in range(1, N):\n    print(cnt[i])", "def main():\n    import itertools\n    n,x,y = list(map(int,input().split()))\n    stat = [i for i in range(n)]\n    ans = [0 for i in range(n-1)]\n    for s in itertools.combinations(stat,2):\n        d = min(s[1]-s[0],abs(x-1-s[0])+1+abs(y-1-s[1]))\n        ans[d-1] += 1\n    for i in range(len(ans)):\n        print((ans[i]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, X, Y = list(map(int, input().split()))\n\ndist_cnt = [0]*N\n\nfor i in range(1, N):\n    for j in range(i+1, N+1):\n        dist = min([j-i, abs(i - X) + abs(j - Y) + 1])\n        dist_cnt[dist] += 1\n\nfor i in range(1, N):\n    print(dist_cnt[i])", "from collections import defaultdict\n\nN, X, Y = map(int, input().split())\ncnt_dict = defaultdict(int)\n\nfor i in range(1,N):\n    for j in range(i+1, N+1):\n        if j<=X or i>=Y:\n            path = j-i\n        else:\n            path = min(j-i, abs(X-i)+abs(j-Y)+1)\n        cnt_dict[path] += 1\n\nfor i in range(1,N):\n    print(cnt_dict[i])", "N,X,Y=map(int,input().split())\nans=[0]*(N+1)\nfor i in range(1,N):\n    for j in range(i+1,N+1):\n        shortest=min(j-i,1+abs(X-i)+abs(Y-j))\n        ans[shortest]+=1\nfor k in range(1,N):\n    print(ans[k])", "N, X, Y = map(int, input().split())\n\ndistance = [[] for i in range(N-1)]\nfor i in range(1, N):\n    for j in range(i+1, N+1):\n        distance[i-1].append(min(abs(j-i), abs(X-i)+1+abs(j-Y), abs(Y-i)+1+abs(j-X)))\n\ncount = [0 for i in range(N)]\nfor i in range(N-1):\n    for dis in distance[i]:\n        count[dis] += 1\n        \nfor i in range(1, len(count)):\n    print(count[i])", "N, X, Y = map(int, input().split())\n\nans = [0] * (N + 1)\n\nfor i in range(1, N):\n    for j in range(i+1, N+1):\n        d = min(j-i, abs(X - i) + 1 + abs(Y - j), abs(Y - i) + 1 + abs(X - j))\n        #print(i, j, d)\n        ans[d] += 1\n\nfor i in range(1, N):\n    print(ans[i])", "N, X, Y = map(int, input().split())\nds = [0] * (N - 1)\n \nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        d = min(j - i, abs(X - i) + 1 + abs(Y - j))\n        ds[d - 1] += 1\n \nfor d in ds:\n    print(d)\nreturn", "N, X, Y = map(int, input().split())\nX -= 1\nY -= 1\n\ndef min_dist(i, j):\n    d1 = abs(i - j)\n\n    d2 = abs(X - i) + abs(Y - j) + 1\n\n    return min(d1, d2)\n\n\nans = [0] * N\n\nfor i in range(N):\n    for j in range(i+1, N):\n        ans[min_dist(i, j)] += 1\n\n[print(a) for a in ans[1:]]", "N, X, Y = [int(x) for x in input().split()]\n\ncounter = [0] * N\nfor i in range(1, N + 1):\n    for j in range(i + 1, N + 1):\n        d = min(abs(i - j), abs(i - X) + abs(j - Y) + 1, abs(i - Y) + abs(j - X) + 1)\n        counter[d] += 1\n\nfor i in range(1, N):\n    print(counter[i])", "n, x, y = list(map(int, input().split()))\nx = x-1\ny = y-1\nans = [0] * (n-1)\n\n\nfor i in range(n):\n    for j in range(i+1, n):\n        shortest = min(abs(j-i), abs(x-i)+abs(y-j)+1, abs(y-i)+abs(x-j)+1)\n        ans[shortest-1] += 1\n\nfor a in ans:\n    print(a)\n\n", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n\n    n,x,y=list(map(int, readline().rstrip().split()))\n    ans = [0] * (n-1)\n    for i in range(1,n+1):\n        for j in range(i+1,n+1):\n            d1 = abs(i-x) + abs(j-y) + 1\n            d2 = abs(i-y) + abs(j-x) + 1\n            d3 = abs(i-j)\n            d=min(d1,d2,d3)\n            ans[d-1]+=1\n    for a in ans:\n        print(a)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "N, X, Y = list(map(int, input().split()))\n\nd = [0] * N\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        if j <= X:\n            a = j - i\n        elif i <= X and j >= Y:\n            a = (X - i) + (j - Y) + 1\n        else:\n            a = min(j - i, abs(X - i) + 1 + abs(Y - j))\n\n        d[a] += 1\nfor ans in d[1:]:\n    print(ans)\n", "N, X, Y = list(map(int, input().split()))\ndict_lis = {i: 0 for i in range(1, N)}\n\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        length_ij = min(j - i, abs(j - Y) + abs(i - X) + 1)\n        dict_lis[length_ij] += 1\n\nfor i in range(1, N):\n    print((dict_lis[i]))\n", "n, x, y = list(map(int, input().split()))\n\ndists = [0] * (n-1)\n\nfor start in range(n):\n    for end in range(start+1, n):\n        dist = min(end-start, abs(((x-1)-start))+1+abs(end-(y-1)))\n        dists[dist-1] += 1\n\nfor dist in dists:\n    print(dist)", "n, x, y = map(int,input().split())\nx, y = x-1, y-1\nd=[0 for i in range(n)]\n\nfor i in range(n):\n    for j in range(i+1,n):\n        m = min(abs(i-j), abs(x-i)+abs(y-j)+1, abs(x-j)+abs(y-i)+1)\n        d[m] += 1\nfor i in range(n-1):\n    print(d[i+1])", "N, X, Y = map(int, input().split())\nansvec = [0]*N\nfor a in range(N-1):\n    for b in range(a+1, N):\n        ansvec[min(b-a, abs(a-X+1)+abs(b-Y+1)+1)] += 1\nfor k in range(N-1):\n    print(ansvec[k+1])", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\n#from operator import itemgetter\n#from heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nimport sys\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN, X, Y = na()\ng = [[0] * N for _ in range(N)]\nfor i in range(N-1):\n    g[i][i+1] = 1\n    g[i+1][i] = 1\n\ng[X-1][Y-1] = 1\ng[Y-1][X-1] = 1\ng = np.array(g)\nd = shortest_path(g)\nct = [0] * N\nfor i in range(N):\n    for j in range(i, N):\n        ct[int(d[i][j])] += 1\nfor i in range(1, N):\n    print((ct[i]))\n\n", "N, X, Y = map(int, input().split())\n\nans = [0] * (N + 1)\n\nfor i in range(1, N):\n  for j in range(i+1, N+1):\n    dis1 = j-i\n    dis2 = abs(X-i) + 1 + abs(Y - j)\n    dis3 = abs(Y-i) + 1 + abs(X - j)\n    d = min(dis1,dis2,dis3)\n    ans[d] += 1\n\nfor i in range(1, N):\n  print(ans[i])", "n,x,y=list(map(int,input().split()))\n\na=[0]*n\n# x-=1\n# y-=1\n\n\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        s=min(j-i,abs(x-i)+abs(y-j)+1)\n        a[s-1]+=1\n        s=10000000\n\nfor i in range(n-1):\n    print((a[i]))\n", "N, X, Y = map(int, input().split())\nk = [0] * (N - 1)\n\nfor i in range(1,N):\n  for j in range(i+1,N+1):\n    tmp = min(abs(i-j), abs(X-i)+1+abs(j-Y))\n    k[tmp-1] += 1\n    \nfor ans in k:\n  print(ans)", "n,x,y = list(map(int,input().split()))\n\nans = [0]*n\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        if i <= x and j >= y:\n            a = abs(j-i)-abs(y-x)+1\n            b = abs(i-x)+abs(j-y)+1\n            ans[min(a,b)] += 1\n        else:\n            c = abs(x-i)+abs(y-j)+1\n            d = abs(j-i)\n            ans[min(c,d)] += 1\n\nfor i in range(1,n):\n    print((ans[i]))\n", "from collections import Counter\ndef main():\n    n,x,y=map(int,input().split())\n    x,y=x-1,y-1\n    ans=[]\n    for i in range(n):\n        dp = [n]*n\n        dp[i] = 0\n        calcstep(i, dp)\n        dp[y] = min(dp[y], dp[x]+1)\n        dp[x] = min(dp[x], dp[y]+1)\n        calcstep(x, dp)\n        calcstep(y, dp)\n        #print(i, dp)\n        ans += dp\n    ans = Counter(ans)\n    for i in range(1,n):\n        print(ans[i]//2)\n\ndef calcstep(i, dp):\n    for j in range(i, len(dp)-1):\n        if dp[j+1] > dp[j]+1:\n            dp[j+1] = dp[j]+1\n        else:\n            break\n    for j in range(1,i+1)[::-1]:\n        if dp[j-1] > dp[j]+1:\n            dp[j-1] = dp[j]+1\n        else:\n            break\n\ndef __starting_point():\n    main()\n__starting_point()", "#ABC160\nn, x, y = list(map(int, input().split()))\nl = [0]*(n-1)\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        l[min(j-i,abs(i-x)+abs(j-y)+1)-1] += 1\n\nfor k in range(n-1):\n    print((l[k]))\n", "from collections import defaultdict\n\nn, x, y = map(int, input().split())\n\nd = defaultdict(int)\n\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        d[min(j - i, abs(x - i) + abs(y - j) + 1)] += 1\n\nfor i in range(1, n):\n    print(d[i])", "N,X,Y = map(int,input().split())\na = [0]*(N-1)\nfor i in range(1,N):\n  for j in range(i+1,N+1):\n    ans = min(j-i,abs(X-i)+1+abs(Y-j),abs(X-j)+1+abs(Y-i))\n    a[ans -1] += 1\nfor item in a:\n  print(item)", "n,x,y = map(int,input().split())\nans = [0] * n\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        a = min(j-i,abs(x-i)+1+abs(j-y),abs(y-i)+1+abs(j-x))\n        ans[a] += 1\nfor i in range(1,n):\n    print(ans[i])", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Sep  7 15:49:02 2020\n\n@author: liang\n\"\"\"\n\nN, X, Y = map(int, input().split())\nans = [0]*(N-1)\nfor i in range(1,N+1):\n    for j in range(i+1, N+1):\n        #print(i,j)\n        res = min(abs(i-j), abs(X-i) + 1 + abs(Y-j))\n        #print(i, j, res)\n        ans[res-1] += 1\n\nfor i in ans:\n    print(i)", "n, x, y = map(int,input().split())\ng = [[] for _ in range(n)]\ng[0].append(1)\ng[n-1].append(n-2)\ng[x-1].append(y-1)\ng[y-1].append(x-1)\nfor i in range(n-2):\n    g[i+1].append(i)\n    g[i+1].append(i+2)\n\n\nfrom collections import deque\ndef bfs(u):\n    queue = deque([u])\n    d = [None] * n # u\u304b\u3089\u306e\u8ddd\u96e2\u306e\u521d\u671f\u5316\n    d[u] = 0 # \u81ea\u5206\u3068\u306e\u8ddd\u96e2\u306f0\n    while queue:\n        v = queue.popleft()\n        for i in g[v]:\n            if d[i] is None:\n                d[i] = d[v] + 1\n                queue.append(i)\n    return d\n\nans_dist = [0 for i in range(n)]\n\nfor i in range(n):\n    D = bfs(i)\n    for d in D:\n        ans_dist[d] += 1\n\nfor i in range(n-1):\n    print(ans_dist[i+1]//2)", "\ndef search(start, N, X, Y):\n    dist = [0 for _ in range(N)]\n    if start <= X:\n        for i in range(X):\n            dist[i] = abs(start - i)\n        for i in range(Y, N):\n            dist[i] = (X - start) + 1 + (i - Y)\n        for i in range(X, (Y - X) // 2 + X + 1):\n            dist[i] = (i - start)\n        for i in range((Y - X) // 2 + X + 1, Y):\n            dist[i] = (X - start) + 1 + (Y - i)\n    elif start >= Y:\n        for i in range(Y, N):\n            dist[i] = abs(start - i)\n        for i in range(X):\n            dist[i] = (start - Y) + 1 + (X - i)\n        for i in range(X, (Y - X) // 2 + X):\n            dist[i] = (start - Y) + 1 + (i - X)\n        for i in range((Y - X) // 2 + X, Y):\n            dist[i] = (start - i)\n    else:\n        toX = min(start - X, Y - start + 1)\n        toY = min(Y - start, start - X + 1)\n        dist[start] = 0\n        for i in range(X):\n            dist[i] = (X - i) + toX\n        for i in range(Y, N):\n            dist[i] = toY + (i - Y)\n        for i in range(X, start):\n            dist[i] = min(start - i, Y - start + 1 + i - X)\n        for i in range(start + 1, Y):\n            dist[i] = min(i - start, start - X + 1 + Y - i)\n    return dist\n\n\ndef main():\n    N, X, Y = [int(n) for n in input().split(\" \")]\n    #N, X, Y = 10, 3, 8\n\n    X = X - 1\n    Y = Y - 1\n\n    lenD = []\n    for i in range(N):\n        d = search(i, N, X, Y)\n        lenD.append(d)\n\n    kcounter = [0 for _ in range(N - 1)]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            k = lenD[i][j]\n            kcounter[k - 1] += 1\n\n    for k in kcounter:\n        print(k)\n\nmain()", "n,x,y=map(int,input().split())\nx,y=x-1,y-1\nc=[0 for i in range(n-1)]\n\nfor i in range(n):\n  for j in range(i+1,n):\n    l=min(j-i,abs(i-x)+abs(j-y)+1)\n    c[l-1]+=1\n\nfor i in range(n-1):\n  print(c[i])", "#!/usr/bin/env python3\ndef main():\n    from collections import deque\n        \n    N, X, Y = list(map(int, input().split()))\n\n    G = [[1]] + [[x - 1, x + 1] for x in range(1, N - 1)] + [[N - 2]]\n    G[X - 1].append(Y - 1)\n    G[Y - 1].append(X - 1)\n\n    dist = [[-1] * N for _ in [0] * N]\n    for s in range(N):\n        q = deque([s])\n        dist[s][s] = 0\n        while q:\n            v = q.popleft()\n            for nv in G[v]:\n                if dist[s][nv] == -1:\n                    dist[s][nv] = dist[s][v] + 1\n                    q.append(nv)\n    res = [0] * N\n    for i in range(N):\n        for j in range(i + 1, N):\n            res[dist[i][j]] += 1\n    for d in range(1, N):\n        print((res[d]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,x,y = map(int, input().split())\nlis = [0] * n\nx -= 1\ny -= 1\n\nfor i in range(n):\n    for j in range(i+1, n):\n        t = min(abs(i-j), abs(i-x)+abs(j-y)+1,abs(i-y)+abs(j-x)+1)\n        lis[t] += 1\n\nfor i in range(1,n):\n    print(lis[i])"]
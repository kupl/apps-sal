["class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         if n == 0:\n             return []\n         left = right = n\n         result = []\n         self.generate(left, right, result, '')\n         return result\n     def generate(self, left, right, result, string):\n         if left == 0 and right == 0:\n             result.append(string)\n             return\n         if left:\n             self.generate(left - 1, right , result, string+'(')\n         if left < right:\n             self.generate(left, right - 1, result, string+')')\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         self.mem = {}\n         \n         return self.top_down(n)\n         \n         \n     def merge(self, left, right):\n         comb = []\n         for i in left:\n             comb += [i + j for j in right]\n         \n         return list(set(comb))\n         \n     def top_down(self, n):\n         if n == 1:\n             return ['()']\n         \n         if not n-1 in self.mem:\n             self.mem[n-1] = self.top_down(n-1)\n         rest = self.mem[n-1]\n         comb = ['(' + i + ')' for i in rest]\n         \n         for i in range(1, n):\n             \n             if not i in self.mem:\n                 self.mem[i] = self.top_down(i)\n             comb_left = self.mem[i]\n             if not n-i in self.mem:\n                 self.mem[n-i] = self.top_down(n-i)\n             comb_right = self.mem[n-i]\n             \n             comb += self.merge(comb_left,comb_right)\n             \n         \n         comb = list(set(comb))\n         \n         return comb\n     \n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         if n < 1 or type(n) != int:\n             return []\n         ret = []\n         tmp = []\n         # define a set of struct like {str:\"((())\", cnt:3, rcnt:2)}\n         tmp.append({\"str\": \"(\", \"cnt\": 1, \"rcnt\": 0})\n         while tmp:\n             cur = tmp.pop()\n             if n == cur[\"cnt\"]:\n                 ret.append(cur[\"str\"] + ')'*(n - cur[\"rcnt\"]))\n             else:\n                 if cur[\"cnt\"] > cur[\"rcnt\"]:\n                     tmp.append({\"str\":cur[\"str\"]+')', \"cnt\": cur[\"cnt\"], \"rcnt\": cur[\"rcnt\"] + 1})\n                 tmp.append({\"str\":cur[\"str\"]+'(', \"cnt\": cur[\"cnt\"] + 1, \"rcnt\": cur[\"rcnt\"]})\n         return ret\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         stack = []\n         s = ''\n         self.dfs(stack, 0, 0, s, n)\n         return stack\n \n     def dfs(self, stack, first, last, s, n):\n         if last==n:\n             stack.append(s)\n         else:\n             if first < n:\n                 self.dfs(stack, first+1, last, s+'(', n)\n             if last < first:\n                 self.dfs(stack, first, last+1, s+')', n)     ", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         ret = []\n         def backtrack(left = 0, right = 0, tmp = ''):\n             if len(tmp) == 2 * n:\n                 ret.append(tmp)\n                 return\n             if left < n:\n                 backtrack(left + 1, right, tmp + '(')\n             if left > right:\n                 backtrack(left, right + 1, tmp + ')')\n         \n         backtrack()\n         return ret", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         # if n==0:\n         #     return [\"\"]\n         # prev = self.generateParenthesis(n-1)\n         # results = set()\n         # for r in prev:\n         #     results.add('('+r+')')\n         #     results.add('()'+r)\n         #     results.add(r+'()')\n         # return sorted(list(set(results)))\n         \n         def gen(n,open_par,res,res_set):\n             print(res)\n             if len(res)==2*n:\n                 res_set.append(''.join(res))\n                 return\n             if 2*n-len(res)>open_par:\n                 res.append('(')\n                 gen(n,open_par+1,res,res_set)\n                 res.pop()\n             if open_par>0:\n                 res.append(')')\n                 gen(n,open_par-1,res,res_set)\n                 res.pop()\n         res_set=[]\n         gen(n,0,[],res_set)\n         return res_set\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         result = set()\n         if n == 0:\n             result = [\"\"]\n         else:\n             for i in range(1, n + 1):\n                 temp1 = {\n                     \"(\" + x + \")\" for x in self.generateParenthesis(i - 1)}\n                 temp2 = {x for x in self.generateParenthesis(n - i)}\n                 temp = {x + y for x in temp1 for y in temp2} | {x +\n                                                                 y for x in temp2 for y in temp1}\n                 result = result | temp\n \n             result = sorted(list(result))\n         return result\n", "class Node(object):\n     def __init__(self,val,root,n,p):\n         self.val=val\n         self.n=n\n         self.p=p\n         if root:\n             self.root=root\n         else:\n             self.root=self\n         self.left=self.leftchild(n,p)\n         self.right=self.rightchild(n,p)\n            \n     def leftchild(self,n,p):\n         if n==0:\n             if p==0:                 \n                 temp=''.join(self.val);\n                 self.root.val.append(temp)\n             return None\n \n         if n>0:\n             return Node(self.val+['('],self.root,n-1,p+1)\n \n     def rightchild(self,n,p):\n         if p==0:\n               return None\n         else:\n               return Node(self.val+[')'],self.root,n,p-1)\n             \n \n class Solution:\n     def generateParenthesis(self, s):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: void Do not return anything, modify nums in-place instead.\n         \"\"\"\n         D=Node([],None,s,0)\n         return D.val\n \n         \n                ", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         rst = []\n         cake = ''\n         self.generateRecursion(rst,cake,n,n)\n         return rst\n     def generateRecursion(self,rst,cake,left,right):\n         if right==0:\n             rst.append(cake)\n         if left>0:\n             self.generateRecursion(rst,cake+'(',left-1,right)\n         if right>left:\n             self.generateRecursion(rst,cake+')',left,right-1)\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         if not n:\n             return []\n         cache = [[\"(\", 1, n-1]]\n         for _ in range(2*n-1):\n             for _ in range(len(cache)):\n                 temp = cache.pop(0)\n                 if temp[1]:\n                     toAdd = temp.copy()\n                     toAdd[0] += ')'\n                     toAdd[1] -= 1\n                     cache.append(toAdd)\n                 if temp[2]:\n                     temp[0] += '('\n                     temp[1] += 1\n                     temp[2] -= 1\n                     cache.append(temp)\n         return [items[0] for items in cache]\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         self.res = []\n         self.dfs(n, 0, 0, '')\n         return self.res\n \n     def dfs(self, n, left, right, path):\n         if left > n or right > n:\n             return\n \n         if n == 0:\n             self.res.append(path)\n             return\n \n         if left == 0:\n             self.dfs(n, left+1, right, path+'(')\n \n         if left == right and left != 0:\n             self.dfs(n-left, 0, 0, path)\n \n         if left > right:\n             self.dfs(n, left+1, right, path+'(')\n             self.dfs(n, left, right+1, path+')')", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         if n == 0:\n             return [\"\"]\n         if n == 1:\n             return [\"()\"]\n         results = []\n \n         for i in range(1, 2*n, 2):\n             first = self.generateParenthesis(int((i-1)/2))\n             second = self.generateParenthesis(int((2*n-i-1)/2))\n             results += [\"(\"+u+\")\"+v for u in first for v in second]\n         return  results", "class Solution:\n     def parenthesis(self, n):\n         return \"(\"*n+\")\"*n\n     \n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         if n == 0:\n             return []\n         elif n == 1:\n             return [\"()\"]\n         \n         result = []\n         for i in range(1,n):\n             r1 = self.generateParenthesis(i)\n             r2 = self.generateParenthesis(n-i)\n             for r11 in r1:\n                 for r21 in r2:\n                     result.append(r11+r21)\n                     \n         r3 = self.generateParenthesis(n-1)\n         for r31 in r3:\n             result.append(\"({})\".format(r31))\n         \n         result.sort()\n         rr = []\n         last = None\n         for r in result:\n             if r == last:\n                 continue\n             rr.append(r)\n             last = r\n             \n                 \n         return rr\n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         \n         def balance(str):\n             lst = list(str)\n             bal = 0\n             for char in lst:\n                 if char == \"(\":\n                     bal += 1\n                 else:\n                     bal -= 1\n             return bal\n         \n         def left(str):\n             lst = list(str)\n             sum = 0\n             for char in lst:\n                 if char == \"(\":\n                     sum += 1\n             return n - sum\n         \n         def right(str):\n             lst = list(str)\n             sum = 0\n             for char in lst:\n                 if char == \")\":\n                     sum += 1\n             return n - sum\n         \n \n         prev = [\"(\"]\n         length = 1\n         \n         while length < 2*n:\n             current = [] \n                 \n             for item in prev:\n                 if left(item) != 0:\n                     current.append(item+\"(\")\n                     \n                 if right(item) != 0 and balance(item) > 0:\n                     current.append(item+\")\")\n             length += 1\n             prev = current\n         \n         return prev", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         results = []\n         \n         def genparen(prefix, opens, closes):\n             if len(prefix) == 2*n:\n                 results.append(prefix)\n                 return\n             \n             if opens < n:\n                 genparen(prefix+\"(\", opens+1, closes)\n             if closes < opens:\n                 genparen(prefix+\")\", opens, closes+1)\n         \n         genparen('', 0, 0)\n         return results\n             \n         \n         \n #         paren_map = {}\n #         paren_map[1] = set([\"()\"])\n         \n #         for i in range(2, n+1):\n #             paren_map[i] = self.generate_parens(paren_map[i-1])\n             \n #         return list(paren_map[n])\n             \n             \n #     def generate_parens(self, st):\n #         result = set()\n         \n #         for elem in st:\n #             for i in range(len(elem)):\n #                 candidate = elem[:i] + \"()\" + elem[i:]\n #                 result.add(candidate)\n         \n #         return result\n         \n", "class Solution:\n     \n     hashMap = {}\n     outPut = []\n     \n     def helper(self, n, string, length, opened, openUsed):\n         \n         ## base case\n         if length == n*2:\n             if string not in self.outPut:\n                 self.outPut.append(string)\n             return\n         \n         ## skip if already tried\n         if string in self.hashMap:\n             return\n         else:\n             self.hashMap[string] = 1\n         \n         if opened == 0:\n             tempOpened = 1\n             tempOpenUsed = openUsed + 1\n             self.helper(n,string+'(',length+1,tempOpened,tempOpenUsed)\n             \n         if opened > 0:\n             tempOpened = opened - 1\n             self.helper(n,string+')',length+1,tempOpened,openUsed)\n             \n         if openUsed < n:\n             tempOpened = opened + 1\n             tempOpenUsed = openUsed + 1\n             self.helper(n,string+'(',length+1,tempOpened,tempOpenUsed)\n     \n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         self.hashMap = {}\n         self.outPut = []\n         self.helper(n,\"\",0,0,0)\n         \n         return self.outPut\n         \n         \n", "class Solution:\n     def generateParenthesis(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[str]\n         \"\"\"\n         # array to keep track of results         \n         answers = []\n         for i in range(0,n+1):\n             answers.append(Solution.catalanHelper(i, answers))\n             print((i, answers))\n         \n         return list(set(answers[n]))\n         \n     @staticmethod\n     # returns parenthesis\n     def catalanHelper(n, answers):\n         \"\"\"\n         : type n : int \n         : rtype : List[str]\n         \"\"\"\n         \n         if n == 0:\n             return [\"\"]\n         elif n == 1:\n             return [\"()\"]\n         else:\n             output = []\n             for i in range(0, n-1):\n                 front_list = answers[i] \n                 end_list = answers[n-i-1]\n                 for front in front_list:\n                     for end in end_list:\n                         \n                         output.append(\"(\" + front + \")\" + end )\n                         output.append(\"(\" + front  + end +\")\")\n \n             return output\n         \n         \n         \n"]
["# input = raw_input\n# range = xrange\nimport sys\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nseg = [0]*200000\n\ndef offset(x):\n\treturn x + 100000\ndef encode(x, y):\n\treturn x*200002 + y\ndef decode(x):\n\treturn x//200002, x%200002\n\ndef upd(node, L, R, pos, val):\n\twhile L < R:\n\t\tseg[node] += val\n\t\tseg[offset(node)] += val*pos\n\t\tif L+1 == R:\n\t\t\tbreak\n \n\t\tM = (L+R)//2\n\t\tnode <<= 1\n\t\tif pos < M:\n\t\t\tR = M\n\t\telse:\n\t\t\tL = M\n\t\t\tnode += 1\n\ndef query(node, L, R, k):\n\tret = 0\n\twhile L < R:\n\t\tif k == 0:\n\t\t\treturn ret\n\t\tif seg[node] == k:\n\t\t\treturn ret + seg[offset(node)]\n\t\tif L+1 == R:\n\t\t\treturn ret + k*L\n\n\t\tM = (L+R)//2\n\t\tnode <<= 1\n\t\tif seg[node] >= k:\n\t\t\tR = M\n\t\telse:\n\t\t\tret += seg[offset(node)]\n\t\t\tk -= seg[node]\n\t\t\tL = M\n\t\t\tnode += 1\n\n\treturn ret\n\nn, m, k = inp[ii:ii+3]; ii += 3\nA, B, both, neither = [], [], [], []\nfor i in range(n):\n\tt, a, b = inp[ii:ii+3]; ii += 3\n\tif a == 0 and b == 0:\n\t\tneither.append(encode(t, i+1))\n\tif a == 1 and b == 0:\n\t\tA.append(encode(t, i+1))\n\tif a == 0 and b == 1:\n\t\tB.append(encode(t, i+1))\n\tif a == 1 and b == 1:\n\t\tboth.append(encode(t, i+1))\n\tupd(1, 0, 10001, t, 1)\n\nA.sort(); B.sort(); both.sort()\np1 = min(k, len(both))\np2 = k - p1\nif 2*k - p1 > m or p2 > min(len(A), len(B)):\n\tprint(-1)\n\treturn\n\nsum, ans, ch = 0, 2**31, p1\nfor i in range(p1):\n\tsum += both[i]//200002\n\tupd(1, 0, 10001, both[i]//200002, -1)\nfor i in range(p2):\n\tsum += A[i]//200002 + B[i]//200002\n\tupd(1, 0, 10001, A[i]//200002, -1)\n\tupd(1, 0, 10001, B[i]//200002, -1)\n\n\nans = query(1, 0, 10001, m-2*k+p1) + sum\n\nwhile p1 > 0:\n\tif p2 == min(len(A), len(B)):\n\t\tbreak\n\tupd(1, 0, 10001, A[p2]//200002, -1); sum += A[p2]//200002\n\tupd(1, 0, 10001, B[p2]//200002, -1); sum += B[p2]//200002\n\tupd(1, 0, 10001, both[p1-1]//200002, 1); sum -= both[p1-1]//200002\n\tp2 += 1\n\tp1 -= 1\n\tif m - 2*k + p1 < 0:\n\t\tbreak\n\tQ = query(1, 0, 10001, m-2*k+p1)\n\tif ans > sum + Q:\n\t\tans = sum + Q\n\t\tch = p1\n\nprint(ans)\nind = [both[i]%200002 for i in range(ch)] + [A[i]%200002 for i in range(k-ch)] + [B[i]%200002 for i in range(k-ch)]\nst = neither + [both[i] for i in range(ch, len(both))] + [A[i] for i in range(k-ch, len(A))] + [B[i] for i in range(k-ch, len(B))]\nst.sort()\nind += [st[i]%200002 for i in range(m-2*k+ch)]\nprint (' '.join(str(x) for x in ind))", "# input = raw_input\n# range = xrange\nimport sys\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \nseg = [0]*200000\n \ndef offset(x):\n\treturn x + 100000\ndef encode(x, y):\n\treturn x*200002 + y\ndef decode(x):\n\treturn x//200002, x%200002\n \ndef upd(node, L, R, pos, val):\n\twhile L < R:\n\t\tseg[node] += val\n\t\tseg[offset(node)] += val*pos\n\t\tif L+1 == R:\n\t\t\tbreak\n \n\t\tM = (L+R)//2\n\t\tnode <<= 1\n\t\tif pos < M:\n\t\t\tR = M\n\t\telse:\n\t\t\tL = M\n\t\t\tnode += 1\n \ndef query(node, L, R, k):\n\tret = 0\n\twhile L < R:\n\t\tif k == 0:\n\t\t\treturn ret\n\t\tif seg[node] == k:\n\t\t\treturn ret + seg[offset(node)]\n\t\tif L+1 == R:\n\t\t\treturn ret + k*L\n \n\t\tM = (L+R)//2\n\t\tnode <<= 1\n\t\tif seg[node] >= k:\n\t\t\tR = M\n\t\telse:\n\t\t\tret += seg[offset(node)]\n\t\t\tk -= seg[node]\n\t\t\tL = M\n\t\t\tnode += 1\n \n\treturn ret\n \nn, m, k = inp[ii:ii+3]; ii += 3\nA, B, both, neither = [], [], [], []\nfor i in range(n):\n\tt, a, b = inp[ii:ii+3]; ii += 3\n\tif a == 0 and b == 0:\n\t\tneither.append(encode(t, i+1))\n\tif a == 1 and b == 0:\n\t\tA.append(encode(t, i+1))\n\tif a == 0 and b == 1:\n\t\tB.append(encode(t, i+1))\n\tif a == 1 and b == 1:\n\t\tboth.append(encode(t, i+1))\n\tupd(1, 0, 10001, t, 1)\n \nA.sort(); B.sort(); both.sort()\np1 = min(k, len(both))\np2 = k - p1\nif 2*k - p1 > m or p2 > min(len(A), len(B)):\n\tprint(-1)\n\treturn\n \nsum, ans, ch = 0, 2**31, p1\nfor i in range(p1):\n\tsum += both[i]//200002\n\tupd(1, 0, 10001, both[i]//200002, -1)\nfor i in range(p2):\n\tsum += A[i]//200002 + B[i]//200002\n\tupd(1, 0, 10001, A[i]//200002, -1)\n\tupd(1, 0, 10001, B[i]//200002, -1)\n \n \nans = query(1, 0, 10001, m-2*k+p1) + sum\n \nwhile p1 > 0:\n\tif p2 == min(len(A), len(B)):\n\t\tbreak\n\tupd(1, 0, 10001, A[p2]//200002, -1); sum += A[p2]//200002\n\tupd(1, 0, 10001, B[p2]//200002, -1); sum += B[p2]//200002\n\tupd(1, 0, 10001, both[p1-1]//200002, 1); sum -= both[p1-1]//200002\n\tp2 += 1\n\tp1 -= 1\n\tif m - 2*k + p1 < 0:\n\t\tbreak\n\tQ = query(1, 0, 10001, m-2*k+p1)\n\tif ans > sum + Q:\n\t\tans = sum + Q\n\t\tch = p1\n \nprint(ans)\nind = [both[i]%200002 for i in range(ch)] + [A[i]%200002 for i in range(k-ch)] + [B[i]%200002 for i in range(k-ch)]\nst = neither + [both[i] for i in range(ch, len(both))] + [A[i] for i in range(k-ch, len(A))] + [B[i] for i in range(k-ch, len(B))]\nst.sort()\nind += [st[i]%200002 for i in range(m-2*k+ch)]\nprint(' '.join(str(x) for x in ind))\n"]
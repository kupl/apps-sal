["n, q = list(map(int, input().split()))\ngo = dict()\nfor i in range(q):\n    fr, to = input().split()\n    go[fr] = to\n\nans = 0\n\nfor i in range(6 ** n):\n    cur = i\n    s = ''\n    for j in range(n):\n        s += chr(ord('a') + (cur % 6))\n        cur //= 6\n\n    while len(s) > 1:\n        fr = s[:2]\n        if fr not in go:\n            break\n        s = go[fr] + s[2:]\n\n    if s == 'a':\n        ans += 1\n\nprint(ans)\n", "3\n\nans = set()\n\ndef gen(cur, n, ops):\n    if len(cur) == n:\n        ans.add(cur)\n    else:\n        for t in ops[ord(cur[0]) - ord(\"a\")]:\n            gen(t + cur[1:], n, ops)\n\n\nn, q = list(map(int, input().split()))\nops = [[] for i in range(6)]\nfor i in range(q):\n    s, t = input().split()\n    ops[ord(t[0]) - ord('a')].append(s)\n\ngen(\"a\", n, ops)\nprint(len(ans))\n", "#! /usr/bin/env python3\nfrom collections import defaultdict\n\ndef main():\n    n, q = list(map(int, input().split()))\n    instrs = [input().split() for _ in range(q)]\n\n    instr_dict = defaultdict(list)\n    for src, dest in instrs:\n        instr_dict[dest].append(src)\n\n    strs = set()\n    last_q = set('a')\n    for _ in range(n - 1):\n        next_q = set()\n        for s in last_q:\n            rules = instr_dict[s[0]]\n            s = s[1:]\n            for rule in rules:\n                next_q.add(rule + s)\n        last_q = next_q\n\n    print(len(last_q))\n\nmain()\n", "from itertools import product as comb\n\nword = \"abcdef\"\nn, q = list(map(int, input().split()))\nrep = dict()\nfor _ in range(q):\n    k, v = input().split()\n    rep[k] = v\nret = set()\nfor x in comb(word, repeat=n):\n    tmp = \"\".join(x)\n    while len(tmp) > 1:\n        before = tmp\n        if tmp[:2] not in rep:\n            break\n        tmp = rep[tmp[:2]] + tmp[2:]\n    if tmp == \"a\":\n        ret.add(x)\nprint(len(ret))\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\npat = {}\n\n(n, q) = (int(i) for i in input().split())\nfor i in range(q):\n    (a, b) = [i for i in input().split()]\n    if b in list(pat.keys()):\n        pat[b].append(a)\n    else:\n        pat[b] = [a]\n\nstart = time.time()\n\nstr = ['a']\nfor i in range(n-1):\n    newstr = []\n    for j in range(len(str)):\n        l = str[j][0]\n        if l in list(pat.keys()):\n            for k in pat[l]:\n                newstr.append(k+str[j][1:])\n\n    str = newstr\n    if len(str) == 0:\n        break\n\nprint(len(str))\nfinish = time.time()\n#print(finish - start)\n", "from functools import reduce\n\nn, q = [int(x) for x in input().split()]\n\nsubstitutions = {}\n\nfor _ in range(q):\n    from_str, to_str = input().split()\n\n    if to_str in substitutions:\n        substitutions[to_str].append(from_str)\n    else:\n        substitutions[to_str] = [from_str]\n\n\ndef generate_str(start_str):\n    if len(start_str) == n:\n        return 1\n\n    if start_str[0] not in substitutions:\n        return 0\n\n    result = 0\n    for variant in substitutions[start_str[0]]:\n        result += generate_str(variant + start_str[1:])\n\n    return result\n\nprint(generate_str('a'))\n", "from collections import defaultdict\nfrom itertools import product\n\n\ndef generate_strings(n):\n    for s in product(\"abcdef\", repeat = n):\n        yield ''.join(s)\n\ndef compress(s, d):\n    while len(s) > 1:\n        p = s[:2]\n        if p not in d:\n            break\n        s = d[p] + s[2:]\n    return s\n\ndef solve(n, d):\n    return sum(compress(s, d) == \"a\" for s in generate_strings(n))\n\nn, q = list(map(int, input().split()))\n\nd = defaultdict(str)\n\nfor i in range(q):\n    s1, s2 = input().split()\n    d[s1] = s2\n\nprint(solve(n, d))\n", "n,q=map(int,input().split())\nd={}\nch=set()\nans=set()\nfor i in range(q):\n    a,b=input().split()\n    d.setdefault(b,set()).add(a)\nch={\"a\"}\n \nwhile ch!=set():\n    b=ch.pop()\n    if len(b)==n: ans.add(b); continue\n    for a in d.setdefault(b[0],set()):\n        ch.add(''.join((a,b[1:])))\nprint(len(ans))", "n, q = map(int, input().split())\n\nfr = dict()\nfor i in range(q):\n    a, b = input().split()\n    if b in fr:\n        fr[b].append(a)\n    else:\n        fr[b] = [a]\n\n\ndef dfs(c, cnt):\n    nonlocal n\n    if cnt == n:\n        return 1\n    if cnt > n:\n        return 0\n    \n    nonlocal fr\n    if c not in fr:\n        return 0\n    \n    ans = 0\n    for i in fr[c]:\n        ans += dfs(i[0], cnt+1)\n    return ans\n\n\nprint(dfs('a', 1))", "def deep(ch, curn):\n    s = 0\n    for i in d[ch]:\n        if i[0] in 'abcdef' and i[1] in 'abcdef':\n            if curn and i[0] in d:\n                s += deep(i[0], curn-1)\n            elif curn == 0:\n                s += 1\n    return s\n\nn, m = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n    dec, en = input().split()\n    if en in d:\n        d[en].append(dec)\n    else:\n        d[en] = [dec]\nif n == 1:\n    print(1)\nelif 'a' in d:\n    print(deep('a', n-2))\nelse:\n    print(0)\n", "import collections\n\nn, q = [int(x) for x in input().split()]\ng = dict()\nfor i in range(q):\n    to, f = input().split()\n    if f in g: g[f].append(to)\n    else: g[f] = [to]\ncounts = dict()\ndef count(s):\n    if s in counts: return counts[s]\n    if len(s) == n:\n        counts[s] = 1\n        return 1\n    if len(s) > n: return 0\n    c = s[0]\n    cnt = 0\n    if not c in g: return 0\n    suff = s[1:]\n    for j in g[c]:\n        new_s = j + suff\n        cnt += count(new_s)\n    counts[s] = cnt\n    return cnt\nprint(count('a'))\n", "#!/usr/bin/env pypy3\n# -*- coding: utf-8 -*-\n\nimport collections\nimport itertools\n\n\nOperation = collections.namedtuple(\"Operation\", \"from_str to_str\")\n\n\ndef is_feasible_operation(base_str, operation):\n    return base_str.startswith(operation.from_str)\n\n\ndef conduct_operation(base_str, operation):\n    return base_str.replace(operation.from_str, operation.to_str, 1)\n\n\ndef breadth_first_search(init_str, operations):\n    q = collections.deque()\n    q.append(init_str)\n    visited = collections.defaultdict(bool)\n    visited[init_str] = True\n    while q:\n        base_str = q.popleft()\n        if base_str == \"a\":\n            return True\n        for operation in operations:\n            if not is_feasible_operation(base_str, operation):\n                continue\n            new_str = conduct_operation(base_str, operation)\n            if not visited[new_str]:\n                visited[new_str] = True\n                q.append(new_str)\n    return False\n\n\ndef count_valid_strings(len_str, operations):\n    counter = 0\n    for chars in itertools.product(\"abcdef\", repeat=len_str):\n        init_str = \"\".join(chars)\n        if breadth_first_search(init_str, operations):\n            counter += 1\n    return counter\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n    operations = [Operation(*input().split()) for _ in range(q)]\n    print(count_valid_strings(n, operations))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def search(rules, m):\n    ret = ['a']\n    for i in range(m - 1):\n        nex = []\n        for r in ret:\n            r0, tail = r[0], r[1:]\n            for a, b in rules:\n                if a == r0:\n                    nex.append(b + tail)\n        ret = nex\n    # print(ret)\n    return len(ret)\n\n\ndef main():\n    line = [int(i) for i in input().split()]\n    m, n = line[0], line[1]\n    rules = []\n    for i in range(n):\n        line = input().split()\n        line.reverse()\n        rules.append(line)\n    # print(m)\n    # print(rules)\n    l = search(rules, m)\n    print(l)\n\n\nmain()\n", "n, m = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n    t, o = input().split()\n    if o in d:\n        d[o].append(t)\n    else:\n        d[o] = [t]\n    \nq = [('a', 0)]\ncnt = 0\nwhile q and q[0][1] < n :\n    st = q[0]\n    q.pop(0)\n    if st[1] == n - 1:\n        cnt += 1\n    if st[0][0] in d:\n        for j in d[st[0][0]]:\n            q.append((j + st[0][1:], st[1] + 1))\n            \nprint(cnt)    \n", "import collections\n\nn, q = list(map(int, input().split()))\nd = collections.defaultdict(list)\ncnt, t = [0] * 6, [0] * 6\nfor i in range(q):\n    s1, s2 = input().split()\n    d[s2].append(s1)\n    cnt[ord(s2) - ord('a')] += 1\nfor s in d['a']:\n    t[ord(s[0]) - ord('a')] += 1\nfor i in range(n - 2):\n    p = [0] * 6\n    for j in range(6):\n        if t[j] == 0:\n            continue\n        for s in d[chr(j + 97)]:\n            p[ord(s[0]) - ord('a')] += t[j]\n    t = p\nprint(sum(t))\n    \n", "n, m = list(map(int, input().split()))\nt = [[] for i in range(6)]\nfor i in range(m):\n    a, b = input().split()\n    t[ord(b) - ord('a')] += [a]\n\nl = ['a']\nA = 0\nwhile len(l) > 0:\n    L = []\n    for s in l:\n        if len(s) == n:\n            A += 1\n            continue\n        for i in range(1):\n            ch = s[i]\n            for new in t[ord(ch) - ord('a')]:\n                L += [s[:i] + new + s[i+1:]]\n    l = set(L)\n\nprint(A)\n                \n", "def __starting_point():\n    n,m = list(map(int,input().split(' ')))\n    d = {}\n    depo,res = {},[]\n    def bazinga(s):\n        if s in depo:   return depo[s]\n        if s[0] not in d:  depo[s]=0\n        else:\n            ans=0\n            for aa in d[s[0]]:\n                if len(aa+s[1:])==n:\n                    ans+=1\n                    #res.append(aa+s[1:])   #if problem is to find string\n                elif len(aa+s[1:])>n:\n                    continue\n                else:\n                    ans+=bazinga(aa+s[1:])\n            depo[s]=ans\n        return depo[s]\n\n    for i in range(m):\n        ai,bi = list(map(str,input().split(' ')))\n        if bi in d:     d[bi] +=[ai]\n        else:           d[bi]=[ai]\n    print(bazinga('a'))\n    #print(len(set(res)))\n\n                    \n                \n                \n                \n\n'''\n    A = input()\n    stack = []      #Real Stack\n    Graph = {\n        ')':'('\n        }\n    count = 0\n    def black(A):\n        #p for possibility\n        stak =[]\n        for e in A:\n            if e in ['(']:\n                stak.append(e)\n            else:\n                if stak==[] or Graph[e]!=stak[-1]:\n                    p=False\n                else:\n                    stak.pop(len(stak)-1)     #pop last \n        if len(stak) ==0:\n            p=True\n        else:\n            p=False\n        if not p:   return [0]\n        else:\n            #stak is not empty\n            stak = []\n            count = []\n            for e in range(len(A)):\n                if A[e]=='(' or stak==[]:  stak.append(A[e])\n                else:\n                    if A[e]==')' and Graph[A[e]]==stak[-1]:\n                        while Graph[A[e]]==stak[-1]:\n                            stak.pop(-1)\n                            if e==len(A)-1: break\n                            e+=1\n                            if A[e]=='(' or stak==[]:   break\n                        count.append(1)\n            return count\n\n    rov = []\n    P = False \n    for e in A:\n        if e in ['(']:  stack.append(e)\n        else:\n            if stack!=[]:\n                stack.append(e)\n                if stack.count('(')==stack.count(')'):\n                    x=black(stack)\n                    if x!=[0]:    P = True\n                    if x==[1]:\n                        rov.append(1)\n                    else:\n                        rov.append(sum(x[:-1]))\n                    stack=[]\n    if not P:   print(0)\n    else:\n        pro =1\n        for i in rov:   pro*=i\n        print(pro)\n    \n'''\n\n__starting_point()", "# You lost the game.\nn, q = map(int, input().split())\nL = [list(str(input()).split(\" \")) for _ in range(q)]\nA = [[] for _ in range(6)]\nB = \"abcdef\"\nfor i in range(q):\n    e = B.index(L[i][1])\n    A[e]  = A[e] + [L[i][0]]\nR = [1,0,0,0,0,0]\nfor i in range(1,n):\n    K = [0,0,0,0,0,0]\n    for j in range(6):\n        for k in A[j]:\n            e = B.index(k[0])\n            K[e] += R[j]\n    R = K[:]\nprint(sum(R))", "def main():\n    n, q = list(map(int, input().split()))\n    d, nxt, f = {c: [] for c in \"abcdef\"}, {\"a\"}, ''.join\n    for _ in range(q):\n        a, b = input().split()\n        d[b].append(a)\n    for _ in range(n - 1):\n        cur, nxt = nxt, set()\n        for l in map(list, cur):\n            for s in d[l[0]]:\n                l[0] = s\n                nxt.add(f(l))\n    print(len(nxt))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\nalphabet = list('abcdef')\n\ndef all_strs_gen(n):\n    s = ['a'] * n\n    for i in range(0, len(alphabet) ** n):\n        yield ''.join(s)\n        for j in range(0, n):\n            if s[j] == alphabet[-1]:\n                s[j] = alphabet[0]\n            else:\n                s[j] = chr(ord(s[j]) + 1)\n                break\n\nn, q = [int(x) for x in input().split()]\nops = {}\nfor i in range(0, q):\n    op, s = input().split()\n    ops[op] = s\n\ndef compress(s):\n    while s[0:2] in ops:\n        # print(s)\n        s = ops[s[0:2]] + s[2:]\n    # print(s)\n    # print()\n    return s\n\ncount = 0\nfor s in all_strs_gen(n):\n    if 'a' == compress(s):\n        count += 1\n\nprint(count)\n", "\n3\n\nans = set()\n\ndef gen(cur, n, ops):\n    if len(cur) == n:\n        ans.add(cur)\n    else:\n        for t in ops[ord(cur[0]) - ord(\"a\")]:\n            gen(t + cur[1:], n, ops)\n\n\nn, q = list(map(int, input().split()))\nops = [[] for i in range(6)]\nfor i in range(q):\n    s, t = input().split()\n    ops[ord(t[0]) - ord('a')].append(s)\n\ngen(\"a\", n, ops)\nprint(len(ans))\n", "n,q = map(int,input().split())\nops = dict()\nfor _ in range(q):\n\ta,b = input().split()\n\tops[a] = b\nfrom itertools import product\ncount = 0\nfor t in product('abcdef', repeat=n):\n\ts = ''.join(t)\n\twhile len(s) > 1:\n\t\ts = ops.get(s[:2], 'g') + s[2:]\n\tcount += s == 'a'\nprint(count)", "from collections import defaultdict\n\ndef rep(cand, succ):\n    ret = set()\n    for word in cand:\n        for r in succ[word[0]]:\n            ret.add(r + word[1:])\n\n    return ret\n\nn, q = list(map(int, input().split()))\nsucc = defaultdict(list)\n\nfor _ in range(q):\n    a, b = input().split()\n    succ[b].append(a)\n\ncand = set(\"a\")\nfor _ in range(n - 1):\n    cand = rep(cand, succ)\nprint(len(cand))\n", "n, q = (int(i) for i in input().split(' '))\n\noper = {}\nfor i in range(q):\n\tkey, value = (i for i in input().split(' '))\n\toper[key] = value\n\n\nabc = ['a', 'b', 'c', 'd', 'e', 'f']\n\nall_v = 0\nn -= 2\n\ndef generate(mystr, num):\n\tnonlocal all_v\n\t#print('mystr=\"%s\", num=%d'%(mystr, num))\n\ttry:\n\t\tmystr = oper[mystr]\n\texcept KeyError:\n\t\treturn\n\n\tif num == 0:\n\t\tif mystr == 'a':\n\t\t\tall_v += 1\n\t\treturn\n\n\tfor a in abc:\n\t\tgenerate(mystr+a, num-1)\n\nfor key in oper.keys():\n\tgenerate(key, n)\n\nprint(all_v)", "#/usr/bin/env pypy3\n# -*- coding: utf-8 -*-\n\nimport collections\nimport itertools\n\n\nGOAL = \"a\"\nOperation = collections.namedtuple(\"Operation\", \"before after\")\n\n\ndef is_possible_operation(original_str, operation):\n    return original_str.startswith(operation.before)\n\n\ndef perform_operation(original_str, operation):\n    return original_str.replace(operation.before, operation.after, 1)\n\n\ndef judge_dfs(initial_str, operations):\n    stack = collections.deque()\n    stack.append(initial_str)\n    visited = collections.defaultdict(bool)\n    visited[initial_str] = True\n    while stack:\n        original_str = stack.pop()\n        if original_str == GOAL:\n            return True\n        for operation in operations:\n            if is_possible_operation(original_str, operation):\n                after_str = perform_operation(original_str, operation)\n                if not visited[after_str]:\n                    visited[after_str] = True\n                    stack.append(after_str)\n    else:\n        return False\n\n\ndef count_valid_strings(len_init_str, operations):\n    cands = itertools.product(\"abcdef\", repeat=len_init_str)\n    a = sum(1 for cs in cands if judge_dfs(\"\".join(cs), operations))\n    return a\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n    operations = [Operation(*input().split()) for _ in range(q)]\n    print(count_valid_strings(n, operations))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["##\n##\n##\nimport sys\ndef line():\n    return sys.stdin.readline()\n\ndef numbers():\n    return list(map(int, line().split()))\n\ndef number():\n    return int(line())\n\nadjlist = {}\nn, k = 0, 0\nmark = [False]*2010\nedges = [False]*1010\n\n# bfs for \"ssph\"\ndef bfs(s):\n    \n    i = 0\n    frontier = [s]\n    while frontier:\n\n        if mark[s]:\n            break;\n\n        next_frontier = []\n        for u in frontier:\n\n            # check next state\n            for v, isState in enumerate(edges):\n                if isState:\n                    # check new node\n                    state = u + (n - 1000) - v\n\n                    if state >= 0 and state <= 2000 and not mark[state]:\n                        mark[state] = True\n                        next_frontier.append(state)\n\n        frontier = next_frontier\n        i += 1\n\n    if mark[s]:\n        return i\n    else:\n        return -1\n\n# main program\n[n, k] = numbers()\nconcentrations = numbers()\n\n# reading edges\nfor x in concentrations:\n    edges[x] = True\n\nn = n + 1000\nans = bfs(1000)\nprint(ans)\n\n# 1496438704903\n", "##\n##\n##\nimport sys\ndef line():\n    return sys.stdin.readline()\n\ndef numbers():\n    return list(map(int, line().split()))\n\ndef number():\n    return int(line())\n\nadjlist = {}\nn, k = 0, 0\nmark = [False]*2010\nedges = [False]*1010\n\n# bfs for \"ssph\"\ndef bfs(s):\n    \n    i = 0\n    frontier = [s]\n    while frontier:\n\n        if mark[s]:\n            break;\n\n        next_frontier = []\n        for u in frontier:\n\n            # check next state\n            for v, isState in enumerate(edges):\n                if isState:\n                    # check new node\n                    state = u + (n - 1000) - v\n\n                    if state >= 0 and state <= 2000 and not mark[state]:\n                        mark[state] = True\n                        next_frontier.append(state)\n\n        frontier = next_frontier\n        i += 1\n\n    if mark[s]:\n        return i\n    else:\n        return -1\n\n# main program\n[n, k] = numbers()\nconcentrations = numbers()\n\n# reading edges\nfor x in concentrations:\n    edges[x] = True\n\nn = n + 1000\nans = bfs(1000)\nprint(ans)\n\n# 1496438704903\n\n\n\n\n# Made By Mostafa_Khaled\n", "from collections import deque\n\nMAX_A = 1000\n     \n     \ndef main():\n    n, k = map(int, input().split())\n    a = set(int(x) - n for x in input().split())\n     \n    visited = [False] * (2 * MAX_A + 1)\n    visited[n] = True\n    Q = deque()\n    Q.append((n, 0))\n     \n    result = None\n    while Q:\n        u, l = Q.popleft()\n        l += 1\n        for ai in a:\n            v = u + ai\n            if v == n:\n                result = l\n                break\n            if 0 <= v < len(visited) and not visited[v]:\n                visited[v] = True\n                Q.append((v, l))\n     \n        if result is not None:\n            break\n     \n    if result is None:\n        result = -1\n     \n    print(result)\n     \n     \ndef __starting_point():\n    # import sys\n    # sys.stdin = open(\"E.txt\")\n    main()\n__starting_point()", "from collections import deque\nn, k = list(map(int, input().split()))\nd = set(int(x)-n for x in input().split())\n     \nq = deque()\nq.append(0)\n     \nvisited = {i : False for i in range(-1000, 1001)}\ndist = {i : 0 for i in range(-1000, 1001)}\n        \nans = -1\nvisited[0] = True\nfound = False\nwhile q:\n    u = q.popleft()\n    for i in d:\n    \tif i + u == 0:\n    \t\t\n    \t\tans = dist[u] + 1\n    \t\tfound = True\n    \t\tbreak     \n    \tif i + u <= 1000 and i + u >= -1000 and not visited[i + u]:\n    \t\tvisited[i + u] = True\n    \t\tdist[i + u] = dist[u] + 1\n    \t\tq.append(i + u)\n    \n    if found:\n    \tbreak\n    \nprint (ans)\n\n", "from collections import deque\nn, k = list(map(int, input().split()))\nconc = set(int(x) - n for x in input().split())\n     \nq = deque()\nq.append(0)\n     \nvisited = {i : False for i in range(-1000, 1001)}\ndist = {i : 0 for i in range(-1000, 1001)}\n        \nans = -1\nvisited[0] = True\nfound = False\nwhile q:\n    u = q.popleft()\n    for c in conc:\n        v = c + u\n        if v == 0:\n            ans=dist[u]+1\n            found=True\n            break\n        if v<=1000 and v>=-1000 and not visited[v]:\n            visited[v]=True\n            dist[v]=dist[u]+1\n            q.append(v)\n    if found:\n    \tbreak\n    \nprint(ans)\n\n"]
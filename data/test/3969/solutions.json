["n, m = map(int, input().split())\nt = [int(input().split()[0]) for i in range(n)]\np = [0] * (m + 1)\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\nprint(n + min(p))", "from bisect import bisect_right\nn = int(input().split()[0])\nt = [int(input().split()[0]) for i in range(n)]\np, k = [], 0\nfor i in t:\n    x = bisect_right(p, i)\n    if x < k: p[x] = i\n    else:\n        p.append(i)\n        k += 1\nprint(n - k)", "n, m = map(int, input().split())\nt = [int(input().split()[0]) for i in range(n)]\np = [0] * (m + 1)\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\nprint(n + min(p))", "numbers, types = list(map(int, input().split()))\n\nposition = [0] * (numbers)\nbinary_search_array = [1] * (numbers)\n\nfor i in range(numbers):\n    position[i] = int(input().split()[0])\n\nmax_length = int(0)\n\nfor i in range(numbers):\n    low = int(0)\n    high = int(max_length)\n\n    while (low < high):\n        mid = int((low + high) / 2)\n        if (binary_search_array[mid] <= position[i]):\n            low = mid + 1\n        else:\n            high = mid\n\n    binary_search_array[low] = position[i]\n    if (low == max_length):\n        max_length += 1\n\n\nprint(numbers - max_length)\n", "'''n, m, k = [int(x) for x in input().split()]\n\ntrees = tuple([int(x) for x in input().split()])\n\ncosts = []\nfor x in range(n):\n    costs.append([0] + [int(x) for x in input().split()])\n\ndp = [[[float('inf') for z in range(m + 1)] for y in range(k + 1)] for x in range(n)]\n\nif trees[0] == 0:\n    for k in range(len(dp[0][0])):\n        dp[0][1][k] = cost[0][k]\nelse:\n    dp[0][0][trees[0]] = cost[0][trees[0]]\n\nfor i in range(1, len(dp)):\n    for j in range(1, len(dp[0])):\n        for k in range(1, len(dp[0][0])):\n            if trees\n            for l in range(len(dp[0][0])):\n                if k == l:\n                    dp[i][j][k] = dp[i - 1][j][k] + cost[i][k]\n                else:\n                    dp[i][j][k] = dp[i - 1][j - 1][l] + cost[i][k]'''\n\n\n\nn, m = [int(x) for x in input().split()]\nplant = [int(input().split()[0]) for x in range(n)]\ndp = [1 for x in range(n)]\n\n\n\nfor i in range(len(plant)):\n    for j in range(0, i):\n        if plant[j] > plant[i]:\n            continue\n        dp[i] = max(dp[i], dp[j] + 1)\n#print(dp)\nprint(n - max(dp))\n\n\n\n\n\n'''for i in range(1, n):\n    for k in range(plant[i], 0, -1):\n        dp[plant[i]] = max(dp[plant[i]], 1 + dp[k])\nprint(n - max(dp) - 1)'''\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "n, m = map(int, input().split())\ntype = [0]\nfor x in range(n):\n\ttype.append(int(input().split()[0]))\n\ndp = [[0] * (m + 1) for x in range(2)]\nfor i in range(1, n + 1):\n\tdp[i & 1][0] = 1e9\n\tfor j in range (1, m + 1):\n\t\tif type[i] == j:\n\t\t\tdp[i & 1][j] = dp[1 - (i & 1)][j]\n\t\telif type[i] > j:\n\t\t\tdp[i & 1][j] = 1 + dp[1 - (i & 1)][j]\n\t\telse:\n\t\t\tif j >= 1:\n\t\t\t\tdp[i & 1][j] = min(dp[i & 1][j - 1], 1 + dp[1 - (i & 1)][j])\n\t\t\telse:\n\t\t\t\tdp[i & 1][j] = dp[1 - (i & 1)][j]\nprint (dp[n & 1][m])", "n, m = list(map(int, input().split()))\n\nt = [int(input().split()[0]) for i in range(n)]\n\np = [0] * (m + 1)\n\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\n\nprint(n + min(p))\n\n\n\n# Made By Mostafa_Khaled\n", "n, m = list(map(int, input().split()))\nt = [int(input().split()[0]) for i in range(n)]\np = [0] * (m + 1)\nfor i in t: p[i] = max(p[1:i+1])+1\nprint(n - max(p))\n", "n, m = list(map(int, input().split()))\nt = [int(input().split()[0]) for i in range(n)]\np = [0] * (m + 1)\nfor i, j in enumerate(t): p[j] = min(p[: j+1]) - 1\nprint(n + min(p))\n", "n, m = [int(x) for x in input().split()]\nd = [0 for i in range(m)]\nfor i in range(n):\n    c, x = [x for x in input().split()]\n    c = int(c)\n\n    d[c-1] = max(d[:c])+1\nprint(n-max(d))\n        \n", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] > key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] >= tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\n  \n# driver code \narr = [] \nn,m=list(map(int,input().split()))\nfor i in range(n) :\n    a,b=list(map(float,input().split()))\n    arr.append(a)\n   \nprint(n-LongestIncreasingSubsequenceLength(arr, n)) \n  \n# This code is contributed \n# by Anant Agarwal. \n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/10/20\n\nLIS\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, M, A):\n    \n    bit = [0 for _ in range(N)]\n    \n    def add(index, val):\n        while index < N:\n            bit[index] = max(bit[index], val)\n            index |= index + 1\n    \n    def query(index):\n        s = 0\n        while index >= 0:\n            s = max(s, bit[index])\n            index = (index & (index + 1)) - 1\n        \n        return s\n    \n    q = [(v, i) for i, v in enumerate(A)]\n    q.sort()\n    \n    s = 0\n    for v, i in q:\n        t = query(i) + 1\n        add(i, t)\n        s = max(s, t)\n    \n    return N-s\n    \n    \n    \n\n\nN, M = map(int, input().split())\nA = []\nfor i in range(N):\n    x, y = input().split()\n    A.append(int(x))\n\nprint(solve(N, M, A))", "def solve(n, a):\n    lis = [0] * n\n    for i in range(0, n):\n        for j in range(0, i):\n            if a[i] >= a[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n        if lis[i] == 0:\n            lis[i] = 1\n    print(n - max(lis))\n\n\ndef main():\n    inp = lambda: int(input().split()[0])\n    n = inp()\n    a = [inp() for _ in range(n)]\n    solve(n, a)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "# Basta encontrar la medida del mayor subarray que es no-decreciente.\n# Con cada inserci\u00f3n podemos aumentar este n\u00famero en 1.\n\nn = int(input().split()[0])\na = []\nfor _ in range(n):\n    a.append(int(input().split()[0]))\ndp = [0]*n\nfor i in range(n):\n    dp[i] = 1\n    for j in range(i):\n        if a[j] <= a[i] and dp[j] >= dp[i]:\n            dp[i] = dp[j] + 1\nprint(n - max(dp))\n\n", "import math\nimport sys\ninput=sys.stdin.readline\n#t=int(input())\nt=1\nfor _ in range(t):\n    #n=int(input())\n    n,m=list(map(int,input().split()))\n    #l=list(map(int,input().split()))\n    l=[]\n    for __ in range(n):\n        s,x=list(map(float,input().split()))\n        l.append(int(s))\n    dp=[0]*(n+1)\n    for i in range(n):\n        j=l[i]\n        for j1 in range(j,-1,-1):\n            dp[j]=max(dp[j],1+dp[j1])\n    maxi=max(dp[:])\n    print(n-maxi)\n", "\nn,m = list(map(int,input().split()))\narr = []\nfor i in range(n):\n    l = list(map(float,input().split()))\n    arr.append(int(l[0]))\ndp = [1 for i in range(n)]\n\nfor i in range(1,n):\n    for j in range(i):\n        if arr[j]<=arr[i]:\n            dp[i] = max(dp[i],dp[j]+1)\nprint(n-max(dp))", "from math import ceil,sqrt\nfrom collections import defaultdict\n\n\n\n\ndef solve():\n\n\n    n,m = list(map(int,input().split()))\n\n    l = []\n    for i in range(n):\n        a,b = list(map(float,input().split()))\n        l.append(a)\n\n    dp = [0]*(n)\n\n    for i in range(n):\n        maxi = 0\n        for j in range(i):\n           if l[i]>=l[j]:\n             maxi = max(dp[j],maxi)\n\n        dp[i] = maxi+1\n    # print(dp)\n    print(n-max(dp))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# t = int(input())\n# for _ in range(t):\n\nsolve()\n\n\n", "n,m=map(int,input().split())\nl=[]\nfor i in range(n):\n\ta,b=input().split()\n\tl.append(int(a))\ndp=[1]*n\nfor i in range(1,n):\n\tfor j in range(0,i):\n\t\tif l[i]>=l[j]:\t\n\t\t\tdp[i]=max(dp[i],dp[j]+1)\nprint(n-max(dp))"]
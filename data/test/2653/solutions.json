["import sys\nsys.setrecursionlimit(10**7)\n \nN, Q = list(map(int, input().split()))\nroot = [[] for _ in range(N)]\nans = [0]*N\n \nfor _ in range(N-1):\n  a,b=list(map(int, input().split()))\n  a,b=a-1,b-1\n  root[a].append(b)\n  root[b].append(a)\n\nfor _ in range(Q):\n  p,x=list(map(int, input().split()))\n  ans[p-1]+=x\n  \nvisited=[False]*N\ndef dfs(v):\n  visited[v] = True\n  for go in root[v]:\n    if visited[go]:\n      continue\n    ans[go] += ans[v]\n    dfs(go)\n\ndfs(0)\nprint((*ans))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n    graph = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = [int(x) - 1 for x in input().split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = [0] * N\n    for i in range(Q):\n        p, x = list(map(int, input().split()))\n        p -= 1\n        ans[p] += x\n    def dfs(cur, pre):\n        for to in graph[cur]:\n            if to == pre:\n                continue\n            ans[to] += ans[cur]\n            dfs(to, cur)\n    dfs(0, -1)\n    print((*ans))\n    return\n\nsolve()\n", "def main():\n    n,q=map(int,input().split())\n    ab=[list(map(int,input().split())) for _ in range(n-1)]\n    tree=[list() for _ in range(n)]\n    score=[0]*n\n    for a,b in ab:\n        a,b=a-1,b-1\n        tree[a].append(b)\n        tree[b].append(a)\n    e = [0]\n    while len(e) > 0:\n        i = e.pop()\n        for j in tree[i]:\n            tree[j].remove(i)\n            e.append(j)\n    px=[list(map(int,input().split())) for _ in range(q)]\n    for p,x in px:\n        p-=1\n        score[p]+=x\n    add(tree,score)\n    print(*score)\n\ndef add(tree,score):\n    s=tree[0][:]\n    for i in s:\n        score[i] += score[0]\n    while len(s)>0:\n        t = s.pop()\n        for i in tree[t]:\n            s.append(i)\n            score[i] += score[t]\n\ndef __starting_point():\n    main()\n__starting_point()", "import collections,sys\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\nN,Q = LI()\nab = [LI() for _ in [None]*(N-1)]\npx = [LI() for _ in [None]*(Q)]\nans = [0]*(N+1) #1_indexed\ngraph = {i:collections.deque() for i in range(1,N+1)} #1_indexed\nfor a,b in ab:\n        graph[a].append(b)\n        graph[b].append(a)\nfor p,x in px:\n    ans[p] += x\nseen = [0]*(N+1) #1_indexed\nstack = []\ndef dfs():\n    seen[1] = 1\n    stack.append(1)\n    while stack:\n        s = stack.pop()\n        if not graph[s]:\n            continue\n        for j in range(len(graph[s])):\n            g_NO = graph[s].popleft()\n            if seen[g_NO]:\n                continue\n            seen[g_NO] = 1\n            stack.append(g_NO)\n            ans[g_NO] += ans[s]\ndfs()\nprint(*ans[1:])", "import sys\nsys.setrecursionlimit(10**9)\n\nN,Q=map(int,input().split())\nT=[[] for _ in range(N)]\nfor _ in range(N-1):\n  a,b=map(int,input().split())\n  a-=1;b-=1\n  T[a].append(b)\n  T[b].append(a)\n\nV=[0]*N\nfor _ in range(Q):\n  p,x=map(int,input().split())\n  V[p-1]+=x\n  \ndef dfs(now,prev=-1):\n  for next in T[now]:\n    if next!=prev:\n      V[next]+=V[now]\n      dfs(next,now)\n\ndfs(0)\nprint(*V)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\nn, q = list(map(int, input().split()))\nG = [[]*n for i in range(n)]\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n\n\ndone = [False]*n\npoints = [0]*n\nd = defaultdict(lambda: 0)\n\nfor _ in range(q):\n    a, b = list(map(int, input().split()))\n    d[a-1] += b\n\n\ndef dfs(i, cnt):\n    cnt += d[i]\n    points[i] += cnt\n    done[i] = True\n    for j in G[i]:\n        if not done[j]:\n            dfs(j, cnt)\n\n\ndfs(0, 0)\nprint((*points))\n", "N,Q = map(int,input().split())\nf = [[] for i in range(N)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    f[a-1].append(b-1)\n    f[b-1].append(a-1)\nans = [0] * N\nfor i in range(Q):\n    p,x = map(int,input().split())\n    ans[p-1] += x\nfrom collections import deque\nd = deque()\nd.append(0)\nroot = [-1]*N\nroot[0] = 0\nwhile len(d) > 0:\n    z = d.popleft()\n    for i in f[z]:\n        if root[i] == -1:\n            root[i] = z\n            ans[i] += ans[z]\n            d.append(i)\nprint(*ans)", "import sys\nsys.setrecursionlimit(1<<30)\ndef dfs(x):\n    for y in edges[x]:\n        if y != parent[x]:\n            parent[y] = x\n            count[y] += count[x]\n            dfs(y)\n\nN, Q = map(int, input().split())\nedges = [[] for _ in range(N+1)]\ncount = [0]*(N+1)\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    edges[a].append(b)\n    edges[b].append(a)\nfor i in range(Q):\n    p, x = map(int, input().split())\n    count[p] += x\n\nparent = [-1]*(N+1)\ndfs(1)\nprint(*count[1:])", "def abc138d_ki():\n    import heapq\n    n, q = map(int, input().split())\n    cnt = [0] * n\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    for _ in range(q):\n        p, x = map(int, input().split())\n        cnt[p - 1] += x\n    qu = [(0, 0)]\n    heapq.heapify(qu)\n    check = [False] * n\n    while len(qu) != 0:\n        h, no = heapq.heappop(qu)\n        check[no] = True\n        for nxt in graph[no]:\n            if not check[nxt]:\n                cnt[nxt] += cnt[no]\n                heapq.heappush(qu, (h + 1, nxt))\n    for c in cnt:\n        print(c, end=' ')\n\n\nabc138d_ki()", "import sys\nsys.setrecursionlimit(10**9) #\u518d\u5e30\u306e\u4e0a\u9650\u6307\u5b9a\n# \u6728\u69cb\u9020\u306e\u6a19\u6e96\u5165\u529b\nN,Q = list(map(int,input().split()))\nT=[[] for _ in range(N)]\nfor _ in range(N-1):\n  a,b=list(map(int,input().split()))\n  a-=1;b-=1\n  T[a].append(b)\n  T[b].append(a)\n\n# \u5165\u529b\u4f8b1\u306e\u3068\u304d\u3001\u7e4b\u304c\u308b\u9802\u70b9\u306e\u30ea\u30b9\u30c8 [[1], [0, 2, 3], [1], [1]]\n# \u8db3\u7b97\u90e8\u5206\u306e\u6a19\u6e96\u5165\u529b\nV=[0]*N\nfor _ in range(Q):\n  p,x=list(map(int,input().split()))\n  V[p-1]+=x\n# \u5165\u529b\u4f8b1\u306e\u3068\u304d\u3001\u5404\u30ce\u30fc\u30c9\u4ee5\u4e0b\u306b\u8db3\u3059\u5024 [100, 10, 1, 0]\ndef dfs(now,prev=-1):\n  for next in T[now]:\n    if next!=prev:# \u89aa\u3058\u3083\u306a\u3051\u308c\u3070\u3001(\u5b50\u3067\u3042\u308c\u3070)\u8db3\u3057\u7b97\u3059\u308b\n      V[next]+=V[now]\n      dfs(next,now)\n\ndfs(0)\n\"\"\"\n\u5165\u529b\u4f8b1\u306e\u3068\u304d\ndfs(0,-1)\u2192dfs(1,0)\u2192dfs(2,1)\n                  \u2192dfs(3,1)\n\"\"\"\nprint((*V))\n", "from collections import deque\nN, Q = list(map(int, input().split()))\ntree = [[] for _ in range(N+1)]\ncounter = [0]*(N+1)\nfor i in range(N-1):\n    a, b = list(map(int, input().split()))\n    tree[a].append(b)\n    tree[b].append(a)\nfor i in range(Q):\n    p, x = list(map(int, input().split()))\n    counter[p] += x\nparent = [-1]*(N+1)\nd = deque([1])\n\nwhile d:\n    a = d.popleft()\n    for b in tree[a]:\n        if parent[a] != b:\n            parent[b] = a\n            counter[b] += counter[a]\n            d.append(b)\n\nprint((*counter[1:]))\n", "from collections import deque\n\n\ndef main():\n  n,q=map(int,input().split())\n  node=[[]*n for i in range(n)]\n  for i in range(n-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    node[b].append(a)\n    node[a].append(b)\n  \n  ans=[0]*n\n  for i in range(q):\n    p,x=map(int,input().split())\n    p-=1\n    ans[p]+=x\n\n  root=[0]*n\n  edge=[[]*n for i in range(n)]\n  root[0]=0\n  q=deque([0])\n  visited=[False]*n\n  visited[0]=True\n  \n  while q:\n    r=q.popleft()\n    for e in node[r]:\n      if not visited[e]:\n        visited[e]=True\n        q.append(e)\n        root[e]=r\n        edge[r].append(e)\n  \n  \n  p=[0]*n\n  q=deque(edge[0])\n  visited=[False]*n\n  while q:\n    e=q.popleft()\n    p[e]=p[root[e]]+1\n    for e2 in edge[e]:\n      if not visited[e2]:\n        visited[e2]=True\n        q.append(e2)\n  \n  p=sorted(enumerate(p), key=lambda x:x[1])\n  for i in range(1,n):\n    e=p[i][0]\n    r=root[e]\n    ans[e]+=ans[r]\n    \n  print(*ans,sep=' ')\n\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nimport math\n\n#https://atcoder.jp/contests/agc008/submissions/15248942\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninm = lambda: map(int, sys.stdin.readline().split())\ninl = lambda: list(inm())\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\ncounts = []\n\nclass Node:\n    def __init__(self):\n        self.edge = []\n        self.count = 0\n\ndef dfs(tree,node,p_node,p_count):\n    count = tree[node].count + p_count\n    counts[node] = count\n    for x in tree[node].edge:\n        if x == p_node:\n            continue\n        dfs(tree,x,node,count)\n\nN,Q = inm()\n\ntree = []\nfor _ in range(N):\n    tree.append(Node())\n\n#node = Node()\n#tree = [node]*N\n\nfor _ in range(N-1):\n    a,b = inm()\n    tree[a-1].edge.append(b-1)\n    tree[b-1].edge.append(a-1)\n\nfor _ in range(Q):\n    p,x = inm()\n    tree[p-1].count += x\n\nfor _ in range(N):\n    counts.append(0)\n\n#for i in range(N):\n#    print(tree[i].edge)\n#    print(tree[i].count)\n\n\ndfs(tree,0,-1,0)\n\ncounts_str = [str(n) for n in counts]\ns = \" \".join(counts_str)\nprint(s)\n", "import sys\nsys.setrecursionlimit(10 ** 9)\nN, Q = map(int, input().split())\n\nG = [[] for i in range(N)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    G[b].append(a)\n    G[a].append(b)\n\nans = [0] * N\n\nfor _ in range(Q):\n    p, x = map(int, input().split())\n    p -= 1\n    ans[p] += x\n\ndef dfs(v, p):\n    for to in G[v]:\n        if to == p: continue\n        ans[to] += ans[v]\n        dfs(to, v)\n\ndfs(0, -1)\nfor i in range(N):\n    print(ans[i],end=' ')\n", "import sys\nsys.setrecursionlimit(10**6)\ndef dfs(tree, n, ans):\n    for i in tree[n]:\n        ans[i] += ans[n]\n        tree[i].remove(n)\n        dfs(tree, i, ans)\n\nn, q = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(n-1)]\npx = [list(map(int,input().split())) for _ in range(q)]\n\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    g[ab[i][0]-1].append(ab[i][1]-1)\n    g[ab[i][1]-1].append(ab[i][0]-1)\n\nans = [0]*n\nfor i in range(q):\n    ans[px[i-1][0]-1] += px[i-1][1]\ndfs(g, 0, ans)\n\nprint(*ans)", "import sys\nread = sys.stdin.read\nsys.setrecursionlimit(10**7)\n#readlines = sys.stdin.readlines\ndef main():\n    def dfs(v, s):\n        if added[v]:\n            pass\n        else:\n            scores[v] += s\n            added[v] = 1\n            for nextv in gg[v]:\n                dfs(nextv, scores[v])\n\n    data = tuple(map(int, read().split()))\n    n, q = data[0], data[1]\n    gg = {i: set() for i in range(1, n + 1)}\n    for i1, v1 in zip(data[2:n*2:2], data[3:n*2:2]):\n        gg[v1].add(i1)\n        gg[i1].add(v1)\n    scores = [0] * (n + 1)\n    for j1, v1 in zip(data[n*2::2], data[n*2+1::2]):\n        scores[j1] += v1\n\n    added = [0] * (n + 1)\n    dfs(1, 0)\n    print(*scores[1:], sep=' ')\n\ndef __starting_point():\n    main()\n__starting_point()", "n,q = map(int,input().split())\ngraph = [[] for i in range(n)]\nfor i in range(n-1):\n  a,b = map(int,input().split())\n  a -= 1\n  b -= 1\n  graph[a].append(b)\n  graph[b].append(a)\n\nweight = [0 for i in range(n)]\nfor i in range(q):\n  p,x = map(int,input().split())\n  weight[p-1] += x\n\nst = [0]\nvisit = [False for i in range(n)]\nwhile not len(st) == 0:\n  now = st.pop()\n  visit[now] = True\n  for e in graph[now]:\n    if visit[e]:\n      continue\n    weight[e] += weight[now]\n    st.append(e)\n    \nprint(' '.join(map(str,weight)))", "\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef main2():\n    n, q = list(map(int, input().split()))\n    tree = [[] for i in range(n)]\n    point = [0] * n\n\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        tree[b - 1].append(a - 1)\n        tree[a - 1].append(b - 1)\n    for i in range(q):\n        p, x = list(map(int, input().split()))\n        point[p - 1] += x\n\n    def dfs(v, parent):\n        nonlocal point, tree\n        for next_val in tree[v]:\n            if next_val == parent:\n                continue\n            point[next_val] += point[v]\n            dfs(next_val, v)\n    dfs(0, 0)\n    print((*point))\n\n\ndef __starting_point():\n    main2()\n\n__starting_point()", "# abc138 D ki\n\nimport sys\nsys.setrecursionlimit(10**6)\n\n# def input():\n#     return sys.stdin.readline()[:-1]\n\nN,Q = map(int,input().split())\ng=[[] for _ in range(N)]\n\npoint=[0]*N\n\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    g[a].append(b)\n    g[b].append(a)\n    \nfor _ in range(Q):\n    a,b=map(int,input().split())\n    a-=1\n    point[a]+=b\n\ndef dfs(n,pre=-1):\n    for ne in g[n]:\n        if ne == pre:\n            continue\n        \n        point[ne]+=point[n]\n        \n        dfs(ne,n)\n        \ndfs(0)\nprint(*point)", "import sys\nsys.setrecursionlimit(10 ** 6)\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef dfs(v,prev = -1):\n    for u in graph[v]:\n        if u == prev:\n            continue\n        point[u] += point[v]\n        dfs(u,v)\n\nN, Q = list(map(int,input().split()))\ngraph = [[] for _ in range(N)]\npoint = [0]*N\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nfor i in range(Q):\n    p,x = list(map(int,input().split()))\n    p -= 1\n    point[p] += x\n\ndfs(0)\nprint((*point))\n", "from collections import defaultdict\nN,Q = list(map(int,input().split()))\nd = defaultdict(list)\n\nfor _ in range(N-1):\n    a,b = list(map(int,input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\nc = defaultdict(int)\n\nfor _ in range(Q):\n    p,x = list(map(int,input().split()))\n    c[p] += x\n\nans = [0 for i in range(N)]\nque = [(1,0,-1)]\nwhile len(que)>0:\n    tmp = []\n    for v,x,par in que:\n        x += c[v]\n        ans[v-1] = str(x)\n        for w in d[v]:\n            if w != par:\n                tmp.append((w,x,v))\n    que = tmp\n\nprint((' '.join(ans)))\n", "import sys\nsys.setrecursionlimit(500000)\n\nn, q = list(map(int, input().split()))\nab = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    ab[a-1].append(b-1)\n    ab[b-1].append(a-1)\nadd = [0]*n\nfor _ in range(q):\n    pp, xx = list(map(int, input().split()))\n    add[pp-1] += xx\n\n\ndef dfs(v, p, value):\n    value += add[v]\n    ans[v] = value\n    for c in ab[v]:\n        if c == p:\n            continue\n        dfs(c, v, value)\n\n\nans = [0]*n\ndfs(0, -1, 0)\nprint((*ans))\n", "import sys\nsys.setrecursionlimit(10**6)# \u5404\u9802\u70b9\u3054\u3068\u306b\u6240\u5c5e\u3059\u308b\u6728\u306e\u5927\u304d\u3055\u3092\u8a08\u7b97\u3059\u308b\nN,Q = list(map(int,input().split()))\n\nE = [[] for _ in range(N+1)]\nvisited = [False for _ in range(N+1)]\nNode_len = [1 for _ in range(N+1)]\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    E[a].append(b)\n    E[b].append(a)\n\nAS = [0 for i in range(N+1)]\ndef dfs(node,parent=-1):\n    for child in E[node]:\n        if child == parent:\n            continue\n        AS[child] += AS[node]\n        dfs(child,node)\n\nfor q in range(Q):\n    p,x = list(map(int,input().split()))\n    AS[p] += x\n\ndfs(1)\nprint((*AS[1:]))\n\n\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 6)\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef dfs(s):\n    stack = [s]\n    visited = [False]*N\n    while stack:\n        v = stack.pop()\n        if visited[v]:\n            continue\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                point[u] += point[v]\n                stack.append(u)\n\nN, Q = list(map(int,input().split()))\ngraph = [deque([]) for _ in range(N)]\npoint = [0]*N\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nfor i in range(Q):\n    p,x = list(map(int,input().split()))\n    p -= 1\n    point[p] += x\n\ndfs(0)\nprint((*point))\n", "from collections import defaultdict\n\nN, Q = list(map(int, input().split()))\nd = defaultdict(list)\n\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\nc = defaultdict(int)\n\nfor _ in range(Q):\n    p, x = list(map(int, input().split()))\n    c[p] += x\n\nans = [0 for i in range(N)]\nque = [(1, 0, -1)]\nwhile len(que) > 0:\n    tmp = []\n    for v, x, par in que:\n        x += c[v]\n        ans[v - 1] = str(x)\n        for w in d[v]:\n            if w != par:\n                tmp.append((w, x, v))\n    que = tmp\n\nprint((*ans))\n", "n,q=map(int,input().split())\ne=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=map(lambda x:int(x)-1,input().split())\n  e[a].append(b)\n  e[b].append(a)\nps=[0 for i in range(n)]\nfor i in range(q):\n  p,x=map(int,input().split())\n  ps[p-1]+=x\n\ns=[-1 for i in range(n)]\nsc=[0]\ns[0]=0\nwhile sc:\n  nsc=[]\n  for i in sc:\n    s[i]+=ps[i]\n    for j in e[i]:\n      if s[j]==-1:\n        nsc.append(j)\n        s[j]=s[i]\n  sc=nsc\n\nr=\"\"\nfor i in range(n):\n  r+=str(s[i])+\" \"\nprint(r[:-1])", "import sys\nsys.setrecursionlimit(10 ** 6)\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef dfs(v,prev = -1):\n    for u in graph[v]:\n        if u == prev:\n            continue\n        point[u] += point[v]\n        dfs(u,v)\n\nN, Q = list(map(int,input().split()))\ngraph = [[] for _ in range(N)]\npoint = [0]*N\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nfor i in range(Q):\n    p,x = list(map(int,input().split()))\n    p -= 1\n    point[p] += x\n\ndfs(0)\nprint((*point))\n", "from collections import deque\n\n\ndef nearlist(N, LIST):\n    NEAR = [set() for _ in range(N)]\n    for a, b in LIST:\n        NEAR[a - 1].add(b - 1)\n        NEAR[b - 1].add(a - 1)\n    return NEAR\n\n\ndef bfs(NEAR):\n    que, frag = deque([0]), set([0])\n    while que:\n        q = que.popleft()\n        for i in NEAR[q]:\n            if i in frag:\n                continue\n            ans[i] += ans[q]\n            que.append(i), frag.add(i)\n    return\n\nn, q = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n - 1)]\npx = [list(map(int, input().split())) for _ in range(q)]\n\nans = [0] * n\nfor p, x in px:\n    ans[p - 1] += x\n\nnear = nearlist(n, ab)\nbfs(near)\nprint(*ans)", "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(10 ** 8)\ninput = sys.stdin.readline\n\n\ndef dfs(now):\n    seen[now] = True\n    for next in branch[now]:\n        if seen[next] is False:\n            score[next] += score[now]\n            dfs(next)\n\n\nN, Q = list(map(int, input().split()))\nbranch = [set() for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    branch[a - 1].add(b - 1)\n    branch[b - 1].add(a - 1)\nscore = [0] * N\nfor _ in range(Q):\n    p, x = list(map(int, input().split()))\n    score[p - 1] += x\n\nseen = [False] * N\nfor i in range(N):\n    if seen[i] is False:\n        dfs(i)\n\nprint((*score))\n", "from collections import deque\nn,q = map(int,input().split())\nz = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    z[a].append(b)\n    z[b].append(a)\nl = [list(map(int,input().split())) for i in range(q)]\np,x = [list(i) for i in zip(*l)]\nc = [0] * n\nfor i in range(q):\n    c[p[i]-1] += x[i]\nqueue = deque([1])\ncheck = [1] * (n+1)\nwhile queue:\n    p = queue.popleft()\n    if check[p]:\n        for i in z[p]:\n            if check[i]:\n                c[i-1] += c[p-1]\n                queue.append(i)\n    check[p] = 0\nprint(' '.join(map(str,c)))", "#\n# abc138 d\n#\nimport sys\nfrom io import StringIO\nimport unittest\nfrom collections import deque\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"4 3\n1 2\n2 3\n2 4\n2 10\n1 100\n3 1\"\"\"\n        output = \"\"\"100 110 111 110\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"6 2\n1 2\n1 3\n2 4\n3 6\n2 5\n1 10\n1 10\"\"\"\n        output = \"\"\"20 20 20 20 20 20\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N, Q = list(map(int, input().split()))\n    AB = [list(map(int, input().split())) for _ in range(N-1)]\n    PX = [list(map(int, input().split())) for _ in range(Q)]\n\n    G = [[i+1, 0] for i in range(N)]\n    for ab in AB:\n        a, b = ab\n        G[a-1][1] += 1\n        G[b-1][1] += 1\n        G[a-1].append(b)\n        G[b-1].append(a)\n\n    ans = [0] * N\n    for px in PX:\n        p, x = px\n        ans[p-1] += x\n\n    S = deque()\n\n    F = [False] * N\n    S.append(1)\n    F[0] = True\n\n    while S:\n        p = S.pop()\n        if G[p-1][1] == 0:\n            continue\n\n        for np in G[p-1][2:]:\n            if F[np-1]:\n                continue\n            S.append(np)\n            F[np-1] = True\n            ans[np-1] += ans[p-1]\n\n    print((*ans))\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 9)\nN, Q = map(int, input().split())\n\nAB_TREE = [[] for i in range(N)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    AB_TREE[b].append(a)\n    AB_TREE[a].append(b)\n\nans = [0] * (N + 1)\n\nfor _ in range(Q):\n    p, x = map(int, input().split())\n    p -= 1\n    ans[p] += x\n\n\ndef dfs(v, p):\n    for to in AB_TREE[v]:\n        if to == p: continue\n        ans[to] += ans[v]\n        dfs(to, v)\n\n\ndfs(0, -1)\nfor i in range(N):\n    print(ans[i],end=' ')\n", "import collections\nN,Q = map(int,input().split())\nlski = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    lski[a].append(b)\n    lski[b].append(a)\ncountercost = collections.Counter()\nfor i in range(Q):\n    p,x = map(int,input().split())\n    countercost[p] += x\n\ndist = [-1] * (N+1)\nparent = [-1] * (N+1)\ndist[0] = 0\ndist[1] = countercost[1]\n\nd = collections.deque()\nd.append(1)\n\nwhile d:\n    v = d.popleft()\n    for i in lski[v]:\n        if parent[a] == b:\n            continue\n        if dist[i] != -1:\n            continue\n        parent[b] = a\n        dist[i] = dist[v] + countercost[i]\n        d.append(i)\ndist.pop(0)\nansls = [str(i) for i in dist]\nprint(' '.join(ansls))", "N,Q = map(int,input().split())\nG = [[] for n in range(N)]\nans = N*[0]\n\nfor n in range(N-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n\nfor q in range(Q):\n  p,x = map(int,input().split())\n  ans[p-1]+=x\n\nf = N*[1]\nt = [0]\nwhile t:\n  v = t.pop()\n  f[v] = 0\n  for k in G[v]:\n    if f[k]:\n      ans[k]+=ans[v]\n      t.append(k)\n\nprint(*ans)", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\u7a7a\u767d\u3042\u308a\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #\u7a7a\u767d\u306a\u3057\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #\u7a7a\u767d\u3042\u308a\ndef LS2(): return list(sys.stdin.readline().rstrip())  #\u7a7a\u767d\u306a\u3057\n\n\nN,Q = MI()\nGraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b = MI()\n    Graph[a].append(b)\n    Graph[b].append(a)\n\ncount = [0]*(N+1)\nadd_count = [0]*(N+1)\nfor i in range(Q):\n    p,x = MI()\n    add_count[p] += x\n\nflag = [-1]*(N+1)\ncount[1] = add_count[1]\ndeq = deque([(1,add_count[1])])\nflag[1] = 0\n\nwhile deq:\n    n,r = deq.pop()\n    for d in Graph[n]:\n        if flag[d] == -1:\n            flag[d] = 0\n            count[d] = r+add_count[d]\n            deq.appendleft((d,count[d]))\n\nprint((*count[1:]))\n", "# D - Ki TLE\nimport sys\nsys.setrecursionlimit(10**7)\nN,Q = map(int,input().split())\n\n# \u6709\u5411\u30b0\u30e9\u30d5\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    G[a].append(b)\n    G[b].append(a)\n    \nlst = []\nfor _ in range(Q):\n    P,X = map(int,input().split())\n    P-=1\n    lst.append((P,X))\n\ncnt = [0]*N\nfor p,x in lst:\n    cnt[p] += x \n    \nseen = [False]*N\ndef dfs(v):\n    seen[v] = True# v \u3092\u8a2a\u554f\u6e08\u307f\u306b\u3059\u308b\n    # v \u304b\u3089\u884c\u3051\u308b\u5404\u9802\u70b9 next_v \u306b\u3064\u3044\u3066\n    for next_v in G[v]:\n        # next_v \u304c\u63a2\u7d22\u6e08\u307f\u306a\u3089\u30b9\u30eb\u30fc\n        if seen[next_v] == True:\n             continue\n        cnt[next_v] += cnt[v] \n        dfs(next_v)\ndfs(0)\nprint(*cnt)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v,prev = -1):\n    for u in graph[v]:\n        if u == prev:\n            continue\n        point[u] += point[v]\n        dfs(u,v)\n\nN, Q = list(map(int,input().split()))\ngraph = [[] for _ in range(N)]\npoint = [0]*N\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nfor i in range(Q):\n    p,x = list(map(int,input().split()))\n    p -= 1\n    point[p] += x\n\ndfs(0)\nprint((*point))\n", "import sys\nfrom typing import List, Tuple\nimport collections\n\nGraph = List[List[int]]\n\n\ndef main():\n    def input(): return sys.stdin.readline()[:-1]\n    N, Q = list(map(int, input().split()))\n\n    graph = [[] for _ in range(N+1)]\n    for _ in range(1, N):\n        a, b = list(map(int, input().split()))\n        graph[a].append(b)\n        graph[b].append(a)\n\n    px = [0] * (N + 1)\n    for _ in range(Q):\n        p, x = list(map(int, input().split()))\n        px[p] += x\n\n    queue = collections.deque()\n    queue.append(1)\n    checked = [0] * (N + 1)\n    while queue:\n        v = queue.pop()\n        checked[v] = 1\n        for next_v in graph[v]:\n            if checked[next_v] == 1: continue\n            px[next_v] += px[v]\n            queue.append(next_v)\n    print((*px[1:]))\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\nn,q=map(int,input().split())\nans=[0 for _ in range(n)]\ngra=[[] for _ in range(n)]\nvisited=[0 for _ in range(n)]\n\nfor _ in range(n-1):\n  a,b=map(int,input().split())\n  gra[a-1].append(b-1)\n  gra[b-1].append(a-1)\n  \nfor _ in range(q):\n  p,x=map(int,input().split())\n  ans[p-1]+=x\n  \ndef dfs(st):\n  temp=gra[st]\n  for i in temp:\n    if visited[i]==0:\n      visited[i]+=1\n      ans[i]+=ans[st]\n      dfs(i)\n      \nvisited[0]+=1\ndfs(0)\n\nfor h in range(n):\n  ans[h]=str(ans[h])\n  \nprint(' '.join(ans))", "import collections\n\nn,q = map(int, input().split())\n\nvalue = ['-'] * (n+1)\n\nconnected = [set() for i in range(n+1)]\n\nfor i in range(n-1):\n  a,b = map(int, input().split())\n  connected[a].add(b)\n  connected[b].add(a)\n\nfor i in range(q):\n  p,x = map(int, input().split())\n  if value[p] == '-':\n    value[p] = 0\n  value[p] -= x\n\nqueue = collections.deque(connected[1])\n\nif value[1] == '-':\n  value[1] = 0\nelse:\n  value[1] = -value[1]\n\nfor i in queue:\n  if value[i] == '-':\n    value[i] = 0\n  else:\n    value[i] = -value[i]\n  value[i] += value[1]\n\n\nwhile queue:\n  s = queue.popleft()\n  v = value[s]\n  for i in connected[s]:\n    vi = value[i]\n    if vi == '-' or vi < 0:\n      if vi == '-':\n        vi = 0\n      value[i] = -(vi-v)\n      queue.append(i)\n    \nprint(' '.join(str(i) for i in value[1:]))", "import sys\nsys.setrecursionlimit(10**9)\ndef f(p,q=-1):\n  for i in c[p]:\n    if i!=q:\n      A[i]+=A[p]\n      f(i,p)\nn,q=map(int,input().split())\nc=[[]for _ in range(n)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  c[a-1].append(b-1)\n  c[b-1].append(a-1)\nA=[0]*n\nfor _ in range(q):\n  p,x=map(int,input().split())\n  A[p-1]+=x\nf(0)\nprint(*A)", "from collections import deque\nn, q = list(map(int, input().split()))\ngraphs = [set() for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    graphs[a].add(b)\n    graphs[b].add(a)\n\nnodes = [0 for _ in range(n)]\nfor _ in range(q):\n    p, x = list(map(int, input().split()))\n    nodes[p - 1] += x\n\ndone = [True for _ in range(n)]\nD = deque()\nD.append([0, 0])\nans = [0 for _ in range(n)]\nwhile D:\n    node, value = D.popleft()\n    value += nodes[node]\n    ans[node] = value\n    done[node] = False\n    for g in graphs[node]:\n        if done[g]:\n            D.append([g, value])\n\nprint((*ans))\n", "import sys\nsys.setrecursionlimit(10**9)\n\nN, Q = map(int, input().split())\nT = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    T[a-1].append(b-1)\n    T[b-1].append(a-1)\n\nS = [0] * N\n\nfor _ in range(Q):\n    p, x = map(int, input().split())\n    S[p-1] += x\n\ndef search(p, q=-1):\n    for a in T[p]:\n        if a != q:\n            S[a] += S[p]\n            search(a, p)\n\nsearch(0)\nprint(*S)", "def solve():\n    import sys\n    sys.setrecursionlimit(10**6)\n    def dfs(tree, n, ans):\n        for i in tree[n]:\n            ans[i] += ans[n]\n            tree[i].remove(n)\n            dfs(tree, i, ans) #\u518d\u5e30\u95a2\u6570\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u6b21\u306e\u6728\u306e\u4e2d\u3092\u63a2\u7d22\n     \n    n, q = map(int,input().split())\n    ab = [list(map(int,input().split())) for _ in range(n-1)]\n    px = [list(map(int,input().split())) for _ in range(q)]\n     \n    g = [[] for _ in range(n)]\n    for i in range(n-1):\n        g[ab[i][0]-1].append(ab[i][1]-1)\n        g[ab[i][1]-1].append(ab[i][0]-1)\n    \n    ans = [0]*n\n    for i in range(q):\n        ans[px[i-1][0]-1] += px[i-1][1]\n    dfs(g, 0, ans)\n     \n    print(*ans)\n    \ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**7)\n \nN,Q=map(int,input().split())\nT=[[] for _ in range(N+1)]\nfor _ in range(N-1):\n  a,b=map(int,input().split())\n  T[a].append(b)\n  T[b].append(a)\n\nS=[0]*(N+1)\nfor _ in range(Q):\n  p,x=map(int,input().split())\n  S[p]+=x\n\n@lru_cache(maxsize=None)\ndef dfs(now,prev=-1):\n  for next in T[now]:\n    if next==prev:\n      continue\n    S[next]+=S[now]\n    dfs(next,now)\n\ndfs(1)\nprint(*S[1:])", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n \n# \u9045\u5ef6\u8a55\u4fa1\u3067\u52a0\u3048\u3066\u3042\u3052\u308b\u3060\u3051\n \nN,Q = map(int,input().split())\nAB = [[int(x) for x in input().split()] for _ in range(N-1)]\nPX = [[int(x) for x in input().split()] for _ in range(Q)]\n \ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n \nvalue = [0] * (N+1)\nfor p,x in PX:\n    value[p] += x\n \ndef dfs(v,parent,add):\n    value[v] += add\n    for x in graph[v]:\n        if x == parent:\n            continue\n        dfs(x,v,value[v])\n \ndfs(1,0,0)\n \nanswer = ' '.join(map(str,value[1:]))\nprint(answer)", "import collections\n\nn, q = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n-1)]\npx = [list(map(int, input().split())) for _ in range(q)]\n\nc = [[] for _ in range(n)]\nfor a, b in ab:\n    a, b = a-1, b-1\n    c[a].append(b)\n    c[b].append(a)\n\npoint = [0] * n\nfor p, x in px:\n    point[p-1] += x\n\nparents = [0] * n\nans = [0] * n\nq = collections.deque()\nq.append(0)\nwhile q:\n    v = q.pop()\n    ans[v] = ans[parents[v]] + point[v]\n    for i in c[v]:\n        if i == parents[v]:\n            continue\n        parents[i] = v\n        q.append(i)\nprint(' '.join(list(map(str, ans))))", "from collections import deque\nn,q=map(int,input().split())\ntree=[[] for _ in range(n)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    tree[a].append(b)\n    tree[b].append(a)\ncount=[0]*n\nfor _ in range(q):\n    p,cnt=map(int,input().split())\n    count[p-1]+=cnt\nstack=deque([[0,0,-1]])\nwhile stack:\n    num,cnt,pr=stack.pop()\n    count[num]+=cnt\n    for k in tree[num]:\n        if k==pr:\n            continue\n        stack.append([k,count[num],num])\nprint(*count)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nN, Q = map(int,input().split())\nedges = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\nd = defaultdict(int)\nfor _ in range(Q):\n    p,x = map(int,input().split())\n    d[p-1] += x\nvisited = [False]*N\ncnt = [0]*N\ndef dfs(n, acc):\n    cnt[n] = acc\n    for m in edges[n]:\n        if not visited[m]:\n            visited[m] = True\n            dfs(m, acc+d[m])\nvisited[0] = True\ndfs(0, d[0])\nprint(*cnt)", "from collections import deque\nimport numpy as np\n\nN, Q = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N-1)]\nP = [list(map(int, input().split())) for _ in range(Q)]\n\nlink = [[] for _ in range(N)]\nfor i in range(N-1):\n    link[A[i][0]-1].append(A[i][1]-1)\n    link[A[i][1]-1].append(A[i][0]-1)\n\n\nans = [0 for _ in range(N)]\nfor i in range(Q):\n  ans[P[i][0] - 1] += P[i][1]\n\ndist = [-1 for _ in range(N)]\ndist[0] = 0\nd = deque([0])\nwhile d:\n    now = d.pop()\n    for i in range(len(link[now])):\n        if dist[link[now][i]] == -1:\n            ans[link[now][i]] += ans[now]\n            dist[link[now][i]] = 0\n            d.append(link[now][i])\n\nfor i in range(N):\n    if i != N - 1:\n        print(ans[i], end=\" \")\n    else:\n        print(ans[i])\n", "import sys\nread = sys.stdin.read\nsys.setrecursionlimit(10**7)\n#readlines = sys.stdin.readlines\ndef main():\n    def dfs(v, s):\n        if notseen[v]:\n            scores[v] += s\n            notseen[v] = 0\n            for nextv in gg[v]:\n                dfs(nextv, scores[v])\n\n    data = tuple(map(int, read().split()))\n    n, q = data[0], data[1]\n    gg = {i: set() for i in range(1, n + 1)}\n    # \u6728\u306a\u306e\u3067\u201d\u6b63\u3057\u304f\u201d\u51e6\u7406\u3059\u308c\u3070gg[x]\u3078\u306eadd\u306f\uff12\u56de\u3067\u306f\u306a\u304f\uff11\u56de\u3067\u3044\u3044\u306f\u305a\u3002\n    # \u3060\u304c\u3046\u307e\u304f\u884c\u304b\u306a\u3044\u305f\u3081\u3001\u7121\u5411\u30b0\u30e9\u30d5\u306e\u3088\u3046\u306b\uff12\u56de\u52a0\u3048\u3066\u3001dfs\u95a2\u6570\u3067\u5404\u9802\u70b9\u3092\uff11\u56de\u3057\u304b\u307f\u306a\u3044\u3088\u3046\u306b\u5bfe\u5fdc\u3002\n    for i1, v1 in zip(data[2:n*2:2], data[3:n*2:2]):\n        gg[v1].add(i1)\n        gg[i1].add(v1)\n    scores = [0] * (n + 1)\n    for j1, v1 in zip(data[n*2::2], data[n*2+1::2]):\n        scores[j1] += v1\n\n    notseen = [1] * (n + 1)\n    dfs(1, 0)\n    print(*scores[1:], sep=' ')\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nN,Q = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(N-1)]\npx = [list(map(int,input().split())) for _ in range(Q)]\n\ntree = [[] for _ in range(N)]\nfor a, b in ab:\n  tree[a-1].append(b-1)\n  tree[b-1].append(a-1)\n\ncounter = [0] * N\nfor p, x in px:\n  counter[p-1] += x\n  \nflag = [1] * N\nt = deque()\nt.append(0)\n\n#1(0)\u304b\u3089\u9806\u306b\u63a2\u7d22\u3057\u3066\u3044\u3051\u3070\u3001\u81ea\u7136\u3068\u89aa\u2192\u5b50\u306e\u9806\u756a\u306b\u306a\u308b\nwhile t:\n  v = t.popleft()\n  flag[v] = 0\n  for i in tree[v]:\n    if flag[i]:\n      counter[i] += counter[v]\n      t.append(i)\n      \nprint(*counter)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 7)\n\nn,q = map(int,input().split())\n\nnode = [[] for _ in range(n+1)]\ncounter = [0 for _ in range(n+1)]\nvisited = [0 for _ in range(n+1)]\npoint_dic = defaultdict(int)\n\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    node[a].append(b)\n    node[b].append(a)\n\nfor _ in range(q):\n    p,x = map(int,input().split())\n    point_dic[p] += x\n\ndef dfs(now,before):\n    nonlocal counter\n    nonlocal visited\n\n    if visited[now]:\n        return\n    \n    if point_dic[now]:\n        point = point_dic[now]+before\n    else:\n        point = before\n    \n    visited[now] = 1\n    counter[now] += point\n\n    for i in node[now]:\n        if visited[i]:\n            continue\n\n        dfs(i,point)\n\ndfs(1,0)\n\nprint(' '.join(map(str, counter[1:])))", "from collections import deque\n\n\nN, Q = list(map(int, input().split()))\nt = [[] for i in range(N + 1)]\n\nfor i in range(N - 1):\n    a, b = list(map(int, input().split()))\n    t[a].append(b)\n    t[b].append(a)\n\nscore = [0] * (N + 1)\nfor i in range(Q):\n    p, x = list(map(int, input().split()))\n    score[p] += x\n\nis_read = [False] * (N + 1)\nd = deque()\nd.append(1)\n\nwhile len(d) != 0:\n    now = d.popleft()\n    is_read[now] = True\n    for c in t[now]:\n        if is_read[c]:\n            continue\n        score[c] += score[now]\n        d.append(c)\nprint((\" \".join(map(str, score[1:]))))\n", "import sys\nsys.setrecursionlimit(10**6)\ndef dfs(tree, n, ans):\n    for i in tree[n]:\n        ans[i] += ans[n]\n        tree[i].remove(n)\n        dfs(tree, i, ans)\n \nn, q = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(n-1)]\npx = [list(map(int,input().split())) for _ in range(q)]\n \ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    g[ab[i][0]-1].append(ab[i][1]-1)\n    g[ab[i][1]-1].append(ab[i][0]-1)\n \nans = [0]*n\nfor i in range(q):\n    ans[px[i-1][0]-1] += px[i-1][1]\ndfs(g, 0, ans)\n \nprint(*ans)", "# import itertools\n# import math\nimport sys\nsys.setrecursionlimit(500*500)\n# import numpy as np\n# from collections import deque\n# import heapq\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, Q = map(int, input().split())\n# A = list(map(int, input().split()))\n# A = list(map(lambda x: int(x)*(-1), input().split()))\n# B = list(map(int, input().split()))\n# A_B = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\nedges = [list(map(int,input().split())) for _ in range(N - 1)]\ntree = [[] for _ in range(N + 1)]\n\nfor edge in edges:\n    tree[edge[0]].append(edge[1])\n    tree[edge[1]].append(edge[0])\n\ndepth = [-1] * (N + 1)\ndepth[1] = 0\ncount = [0] * (N + 1)\n\nfor i in range(Q):\n    p, x = map(int, input().split())\n    count[p] += x\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + 1\n#             dfs(tree, l[0])\n# dfs(tree, 1)\ndef dfs(tree, s):\n    for l in tree[s]:\n        if depth[l] == -1:\n            depth[l] = 0\n            count[l] += count[s]\n            dfs(tree, l)\ndfs(tree, 1)\n\n\nfor i in count[1:]:\n    print(i, end = ' ')\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n\n\n# bfs\n# tree = [[] for _ in range(N + 1)]\n# edges = [list(map(int,input().split())) for _ in range(M)]\n\n# for edge in edges:\n#     tree[edge[0]].append(edge[1])\n#     tree[edge[1]].append(edge[0])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n\n# d = deque()\n# d.append(1)\n\n# ans = [0] * (N + 1)\n# while d:\n#  v = d.popleft()\n#  for i in tree[v]:\n#    if depth[i] != -1:\n#      continue\n#    depth[i] = depth[v] + 1\n#    ans[i] = v\n#    d.append(i)\n\n# # ans = depth[2:]\n# print('Yes')\n# print(*ans[2:], sep=\"\\n\")", "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**7)\n\nN, Q = map(int, input().split())\nT = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n  a,b=map(int, input().split())\n  T[a].append(b)\n  T[b].append(a)\n\nV = [0] * (N+1)\nfor q in range(Q):\n  p,x=map(int, input().split())\n  V[p]+=x\n\n@lru_cache(maxsize=None)\ndef dfs(i, parent, acc):\n  V[i]+=acc\n  for j in T[i]:\n    if j != parent:\n      dfs(j,i,V[i])\n\ncur,parent,acc=1,0,0\ndfs(cur,parent,acc)\nprint(*V[1:])", "import collections,sys\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\nN,Q = LI()\nab = [LI() for _ in range(N-1)]\npx = [LI() for _ in range(Q)]\nans = [0]*(N+1) #1_indexed\ngraph = {i:collections.deque() for i in range(1,N+1)} #1_indexed\nfor a,b in ab:\n        graph[a].append(b)\n        graph[b].append(a)\nfor p,x in px:\n    ans[p] += x\nseen = [0]*(N+1) #1_indexed\nstack = []\ndef dfs():\n    seen[1] = 1\n    stack.append(1)\n    while stack:\n        s = stack.pop()\n        if not graph[s]:\n            continue\n        for j in range(len(graph[s])):\n            g_NO = graph[s].popleft()\n            if seen[g_NO]:\n                continue\n            seen[g_NO] = 1\n            stack.append(g_NO)\n            ans[g_NO] += ans[s]\ndfs()\nprint(*ans[1:])", "import sys\nsys.setrecursionlimit(10**9)\n\nN, Q = map(int,input().split())\nG = [[] for _ in range(N)]\ncounter = [0] * N\n\nfor _ in range(N-1):\n    a, b = map(int,input().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n\nfor _ in range(Q):\n    p, x = map(int,input().split())\n    counter[p-1] += x\n\nseen = [False]*N\n\ndef dfs(v, seen, G, counter):\n    seen[v] = True\n    for u in G[v]:\n        if not seen[u]:\n            counter[u] += counter[v]\n            dfs(u, seen, G, counter)\n\ndfs(0, seen, G, counter)\n\nfor c in counter:\n    print(c, end = \" \")\nprint(\"\")\n\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 6)\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef dfs(s):\n    stack = [s]\n    visited = [False]*N\n    while stack:\n        v = stack.pop()\n        if visited[v]:\n            continue\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                point[u] += point[v]\n                stack.append(u)\n\nN, Q = list(map(int,input().split()))\ngraph = [deque([]) for _ in range(N)]\npoint = [0]*N\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nfor i in range(Q):\n    p,x = list(map(int,input().split()))\n    p -= 1\n    point[p] += x\n\ndfs(0)\nprint((*point))\n", "#!/usr/bin/env python3\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 8)\n\n\ndef dfs(now):\n    seen[now] = True\n    score[now] += operation[now]\n    for next in branch[now]:\n        if seen[next] is False:\n            score[next] += score[now]\n            dfs(next)\n\n\nN, Q = map(int, input().split())\nbranch = [set() for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    branch[a - 1].add(b - 1)\n    branch[b - 1].add(a - 1)\noperation = [0] * N\nfor _ in range(Q):\n    p, x = map(int, input().split())\n    operation[p - 1] += x\n\nseen = [False] * N\nscore = [0] * N\nfor i in range(N):\n    if seen[i] is False:\n        dfs(i)\n\nfor ans in score:\n    print(ans, end=' ')\n", "import sys\nreadline = sys.stdin.readline\n\nN,Q = map(int,readline().split())\n\nG = [[] for i in range(N)]\n\nfor i in range(N - 1):\n  a,b = map(int,readline().split())\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n  \npoint = [0] * N\nfor i in range(Q):\n  p,x = map(int,readline().split())\n  point[p - 1] += x\n\nstack = [(0, -1, 0)]\nwhile stack:\n  v,parent,p = stack.pop()\n  point[v] += p\n  p = point[v]\n  for child in G[v]:\n    if child == parent:\n      continue\n    stack.append([child, v, p])\n  \nprint(*point)", "def main():\n\tN, Q = [int(n) for n in input().split(\" \")]\n\tedges = [[] for i in range(N)]\n\tcounter = [0] * N\n\n\tfor i in range(N - 1):\n\t\ta, b = [int(x) for x in input().split(\" \")]\n\t\tedges[a - 1].append(b - 1)\n\t\tedges[b - 1].append(a - 1)\n\n\tfor j in range(Q):\n\t\tp, x = [int(q) for q in input().split(\" \")]\n\t\tcounter[p - 1] += x\n\n\tto_visit = [0]\n\tchecked = [1] + [0] * (N - 1)\n\ttree = [0] * N\n\n\twhile len(to_visit) > 0:\n\t\tvisiting = to_visit.pop()\n\t\ttree[visiting] += counter[visiting]\n\t\tfor e in edges[visiting]:\n\t\t\tif checked[e] == 0:\n\t\t\t\tchecked[e] = 1\n\t\t\t\tto_visit.append(e)\n\t\t\t\ttree[e] = tree[visiting]\n\n\tprint((\" \".join([str(s) for s in tree])))\n\nmain()\n", "import sys\nsys.setrecursionlimit(10**8)\n\nn, q = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n-1)]\npx = [list(map(int, input().split())) for _ in range(q)]\n\nt = dict()\nfor i in range(1, n+1):\n    t[i] = set()\nfor a, b in ab:\n    t[a].add(b)\n    t[b].add(a)\n\ncnt = [0] * n\ns = set()\nfor p, x in px:\n    cnt[p-1] += x\n\ndef solve(p):\n    s.add(p)\n    for c in t[p]:\n        if c not in s:\n            cnt[c-1] += cnt[p-1]\n            solve(c)\nsolve(1)\nprint(*cnt, sep=' ')\n", "from collections import deque\n\nN, Q = list(map(int, input().split()))\ntree = [set() for _ in range(N+1)]\n\nfor i in range(N - 1):\n    n1, n2 = list(map(int, input().split()))\n    tree[n1].add(n2)\n    tree[n2].add(n1)\n\nscores = [0]*(N+1)\nfor _ in range(Q):\n    p, x = list(map(int, input().split()))\n    scores[p] += x\n\nq = deque()\nq.append(1)\nchecked = [False]*(N+1)\nwhile q:\n    v = q.pop()\n    checked[v] = True\n    s = scores[v]\n    for k in tree[v]:\n        if checked[k]:\n            continue\n        scores[k] += s\n        q.append(k)\n\nprint((*scores[1:]))\n", "import sys\nsys.setrecursionlimit(10**9)\n\nN,Q=map(int,input().split())\nT=[[] for _ in range(N)]\nfor _ in range(N-1):\n  a,b=map(int,input().split())\n  a-=1;b-=1\n  T[a].append(b)\n  T[b].append(a)\n\nV=[0]*N\nfor _ in range(Q):\n  p,x=map(int,input().split())\n  p-=1\n  V[p]+=x\n  \ndef dfs(now,prev=-1):\n  for next in T[now]:\n    if next==prev:\n      continue\n    V[next]+=V[now]\n    dfs(next,now)\n\ndfs(0)\nprint(*V)", "import sys\nsys.setrecursionlimit(1<<30)\nN,Q = map(int,input().split())\ndef dfs(x, score):\n    for y in Tree[x]:\n        if Parent[x] != y:\n            Parent[y] = x\n            score[y] += score[x]\n            dfs(y, score)\nTree = [[] for i in range(N+1)]\nParent = [0]*(N+1)\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    Tree[a].append(b)\n    Tree[b].append(a)\nscore = [0]*(N+1)\nfor j in range(Q):\n    p,x = map(int,input().split())\n    score[p] += x\ndfs(1,score)\nprint(*score[1:],end=\"\\t\")", "import sys\nsys.setrecursionlimit(10**9)\n\nN, Q = map(int, input().split())\nL = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    L[a-1].append(b-1)\n    L[b-1].append(a-1)\n\nS = [0] * N\n\nfor _ in range(Q):\n    p, x = map(int, input().split())\n    S[p-1] += x\n\ndef search(p,q=-1):\n    for a in L[p]:\n        if a != q:\n            S[a] += S[p]\n            search(a,p)\n\nsearch(0)\nprint(*S)", "import sys\nsys.setrecursionlimit(10**7)\nN, Q = [int(n) for n in input().split()]\ntree_list = [[] for _ in range(N)]\n\nfor i in range(N-1):\n    a, b = [int(n)-1 for n in input().split()]\n    tree_list[a].append(b)\n    tree_list[b].append(a)\n\nscore_list = [0] * N\nfor j in range(Q):\n    p, x = [int(n) for n in input().split()]\n    score_list[p-1] += x\n\nreached = [False] * N\ndef dfs(v):\n    reached[v] = True\n    for next_v in tree_list[v]:\n        if reached[next_v] == True:\n            continue\n        score_list[next_v] += score_list[v]\n        dfs(next_v)\ndfs(0)\nprint(*score_list)", "from collections import deque\n\nN, Q = list(map(int, input().split())) # N\u306f\u9802\u70b9\u306e\u6570\u3001Q\u306f\u64cd\u4f5c\u306e\u56de\u6570\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    graph[a].append(b)\n    graph[b].append(a)\n\ncounts = [0] * (N+1)\nfor _ in range(Q):\n    p, x  = list(map(int, input().split()))\n    counts[p] += x\nvisited = [-1] * (N+1)\n\nq = deque()\nq.append(1)\nvisited[1] = 1\nwhile q:\n    node = q.pop()\n\n    next_nodes = graph[node]\n    for next in next_nodes:\n        if visited[next] != -1:\n            continue\n        q.append(next)\n        visited[next] = 1\n        counts[next] += counts[node]\n\nprint((*counts[1:]))\n\n\n", "import sys\nsys.setrecursionlimit(10000000)\ndef main():\n    n,q = list(map(int,input().split()))\n    Ki = [[] for i in range(n)]\n    for _ in range(n-1):\n        a,b = list(map(int,input().split()))\n        Ki[a-1]+=[b-1]\n        Ki[b-1]+=[a-1]\n    ans = [0]*n\n    for _ in range(q):\n        p,x = list(map(int,input().split()))\n        ans[p-1]+=x\n    def add(N=0,L=-1):\n        for k in Ki[N]:\n            if k!=L:\n                ans[k]+=ans[N]\n                add(k,N)\n    add()\n    print((' '.join([str(a) for a in ans])))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\nn,q=map(int,input().split())\nG=[[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\n\nsubtree_size=[0]*n\ncnt=[0]*n\n\nfor _ in range(q):\n    p,x=map(int,input().split())\n    p-=1\n    cnt[p]+=x\nans=[0]*n\n\ndef dfs(G,v,p):\n    ans[v]+=cnt[v]\n    for nv in G[v]:\n        if nv==p:\n            continue\n        cnt[nv]+=cnt[v]\n        dfs(G,nv,v)\n    \n    subtree_size[v]=1\n    for c in G[v]:\n        if c==p:\n            continue\n        subtree_size[v]+=subtree_size[c]\n\nroot=0\ndfs(G,root,-1)\n\nfor i in range(n):\n    print(ans[i],end=' ')\n\n\n\n", "import sys\nsys.setrecursionlimit(10**8)\nN, Q = map(int, input().split())\ng = [[] for i in range(N)]\nfor i in range(N-1):\n    a, b = list(map(int, input().split()))\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\ncnt = [0] * N\nfor i in range(Q):\n    p, x = list(map(int, input().split()))\n    cnt[p-1] += x\n\ndef dfs(g, v):\n    # nonlocal ans_cnt\n    for nv in g[v]:\n        if ans_cnt[nv] != -1: continue\n        ans_cnt[nv] = cnt[nv] + ans_cnt[v]\n        dfs(g, nv)\n\nans_cnt = [-1] * N\nans_cnt[0] = cnt[0]\ndfs(g, 0)\n\n# print(cnt)\n# print(ans_cnt)\nfor i, value in enumerate(ans_cnt):\n    print(value, end=\"\")\n    if i != len(ans_cnt)-1:\n        print(\" \", end=\"\")\nprint()", "import sys\nsys.setrecursionlimit(10**7)\nn,q=map(int,input().split())\nedge=[[] for _ in range(n)]\nfor i in range(n-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\nans=[0]*n\nfor i in range(q):\n    p,x=map(int,input().split())\n    ans[p-1]+=x\ndef dfs(c,p):\n    for i in edge[c]:\n        if i==p:\n            continue\n        ans[i]+=ans[c]\n        dfs(i,c)\ndfs(0,-1)\nprint(*ans)", "N,Q = map(int,input().split())\nG = [[] for n in range(N)]\nans = N*[0]\n \nfor n in range(N-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n \nfor q in range(Q):\n  p,x = map(int,input().split())\n  ans[p-1]+=x\n \nf = N*[1]\nt = [0]\nwhile t:\n  v = t.pop()\n  f[v] = 0\n  for k in G[v]:\n    if f[k]:\n      ans[k]+=ans[v]\n      t.append(k)\n \nprint(*ans)", "import sys\nsys.setrecursionlimit(10**8)\n\nn, q = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n-1)]\npx = [list(map(int, input().split())) for _ in range(q)]\n\nt = dict()\nfor i in range(1, n+1):\n    t[i] = []\nfor a, b in ab:\n    t[a].append(b)\n    t[b].append(a)\n\ncnt = [0] * n\ns = set()\nfor p, x in px:\n    cnt[p-1] += x\n\ndef solve(p):\n    s.add(p)\n    for c in t[p]:\n        if c not in s:\n            cnt[c-1] += cnt[p-1]\n            solve(c)\nsolve(1)\nprint(*cnt, sep=' ')\n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\nfrom collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef Main():\n    n, q = read_ints()\n    tree = [[] for _ in range(n)]\n    c = [0] * n\n    for _ in range(n-1):\n        a, b = read_ints()\n        tree[~-a].append(~-b)\n        tree[~-b].append(~-a)\n    for _ in range(q):\n        p, x = read_ints()\n        c[~-p] += x\n    que = deque([0])\n    seen = [False] * n\n    while que:\n        p = que.pop()\n        seen[p] = True\n        for x in tree[p]:\n            if seen[x]: continue\n            que.append(x)\n            c[x] += c[p]\n    \n    print(*c)\n\ndef __starting_point():\n    Main()\n__starting_point()", "from collections import defaultdict\nN,Q = list(map(int,input().split()))\nd = defaultdict(list)\n\nfor _ in range(N-1):\n    a,b = list(map(int,input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\nc = defaultdict(int)\n\nfor _ in range(Q):\n    p,x = list(map(int,input().split()))\n    c[p] += x\n\nans = [0 for i in range(N)]\nque = [(1,0,-1)]\nwhile len(que)>0:\n    tmp = []\n    for v,x,par in que:\n        x += c[v]\n        ans[v-1] = str(x)\n        for w in d[v]:\n            if w != par:\n                tmp.append((w,x,v))\n    que = tmp\n\nprint((*ans))\n", "import sys\nsys.setrecursionlimit(10**9)\nn,q=map(int,input().split())\nG=[[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\n\nsubtree_size=[0]*n\ncnt=[0]*n\n\nfor _ in range(q):\n    p,x=map(int,input().split())\n    p-=1\n    cnt[p]+=x\nans=[0]*n\n\ndef dfs(G,v,p):\n    ans[v]+=cnt[v]\n    for nv in G[v]:\n        if nv==p:\n            continue\n        cnt[nv]+=cnt[v]\n        dfs(G,nv,v)\n    \n    subtree_size[v]=1\n    for c in G[v]:\n        if c==p:\n            continue\n        subtree_size[v]+=subtree_size[c]\n\nroot=0\ndfs(G,root,-1)\n\nfor i in range(n):\n    print(ans[i],end=' ')\n\n\n\n", "import sys\nimport math\n\n#https://atcoder.jp/contests/agc008/submissions/15248942\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninm = lambda: map(int, sys.stdin.readline().split())\ninl = lambda: list(inm())\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\nclass Node:\n    def __init__(self):\n        self.edge = []\n        self.count = 0\n\ndef dfs(tree,node,p_node,p_count,counts):\n    count = tree[node].count + p_count\n    counts[node] = count\n    for x in tree[node].edge:\n        if x == p_node:\n            continue\n        dfs(tree,x,node,count,counts)\n\nN,Q = inm()\n\ntree = []\nfor _ in range(N):\n    tree.append(Node())\n\n#node = Node()\n#tree = [node]*N\n\nfor _ in range(N-1):\n    a,b = inm()\n    tree[a-1].edge.append(b-1)\n    tree[b-1].edge.append(a-1)\n\nfor _ in range(Q):\n    p,x = inm()\n    tree[p-1].count += x\n\nval = []\nfor _ in range(N):\n    val.append(0)\n\n#for i in range(N):\n#    print(tree[i].edge)\n#    print(tree[i].count)\n\ndfs(tree,0,-1,0,val)\n\ncounts_str = [str(n) for n in val]\ns = \" \".join(counts_str)\nprint(s)\n", "from collections import defaultdict\nfrom sys import setrecursionlimit # \u518d\u5e30\u30a8\u30e9\u30fc\u5bfe\u7b56\nsetrecursionlimit(10 ** 7)\n\nn,q = map(int,input().split())\n\nnode = [[] for _ in range(n+1)]\ncounter = [0 for _ in range(n+1)]\nvisited = [0 for _ in range(n+1)]\npoint_dic = defaultdict(int)\n\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    node[a].append(b)\n    node[b].append(a)\n\n# \u5404\u30ce\u30fc\u30c9\u306e\u52a0\u7b97\u5024\u3092\u8a18\u9332\nfor _ in range(q):\n    p,x = map(int,input().split())\n    point_dic[p] += x\n\n# \u73fe\u5728\u306e\u30ce\u30fc\u30c9(now)\u3068\u305d\u308c\u307e\u3067\u306b\u52a0\u7b97\u3055\u308c\u305f\u5024(before_point)\ndef dfs(now,before_point):\n    if visited[now]:\n        return\n    \n    # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u306e\u52a0\u7b97\u5024\u3092\u8db3\u3059\n    if point_dic[now]:\n        point = point_dic[now]+before_point\n    else:\n        point = before_point\n    \n    # \u8a2a\u554f\u6e08\u307f\u306b\u3059\u308b\n    visited[now] = 1\n    counter[now] += point\n\n    for i in node[now]:\n        if visited[i]:\n            continue\n\n        dfs(i,point) # \u518d\u5e30\u3057\u3066\u5b50\u30ce\u30fc\u30c9\u306b\u5f15\u304d\u7d99\u3050\n\ndfs(1,0)\n\nprint(' '.join(map(str, counter[1:])))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef input():\n    return sys.stdin.readline()[:-1]\nN , Q = map(int,input().split())\ngraph = [[] for _ in range(N)]\npoint = [0] * N\nfor _ in range(N - 1):\n    a , b = map(int,input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n#print(graph)\nfor _ in range(Q):\n    a , b = map(int,input().split())\n    a = a - 1\n    point[a] += b\n# dfs\u3092\u7528\u3044\u3066\u7d2f\u7a4d\u548c\u3092\u8a08\u7b97\u3059\u308b\n# \u521d\u671f\u72b6\u614b\u3060\u3068\u524d\u306e\u5024\u304c\u306a\u3044\u305f\u3081\u30c7\u30d5\u30a9\u30eb\u30c8\u5f15\u6570\u306b-1\u3092\u4ee3\u5165\ndef dfs(now , prev = -1):\n    for next in graph[now]:\n        # \u6b21\u306e\u30ce\u30fc\u30c9\u304c\u524d\u306b\u53c2\u7167\u3057\u305f\u5024\u306e\u6642\u306fcontinue\n        if next == prev:\n            continue\n        # \u73fe\u5728\u306e\u5024\u3092\u6b21\u306e\u30dd\u30a4\u30f3\u30c8\u306b\u52a0\u7b97\u3059\u308b\u3053\u3068\u3067\u7d2f\u7a4d\u548c\u3092\u3068\u308b\n        point[next] += point[now]\n        # \u6b21\u306e\u30ce\u30fc\u30c9\u3068\u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3092\u5f15\u6570\u306bdfs\u3092\u7d99\u7d9a\u3059\u308b\n        dfs(next , now)\n\ndfs(0)\nprint(*point)"]
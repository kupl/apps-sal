["w,m=map(int,input().split())\n\nbb=True\n\nwhile(m>0 and bb):\n\tx=m%w\n\tif x==1:m-=1\n\telif x==w-1:m+=1\n\telif x!=0:bb=False\n\tm//=w\n\t\nif bb:print(\"YES\")\nelse:print(\"NO\")", "def f(w, m):\n\tif m == 0:\n\t\treturn True\n\tif m % w == 0:\n\t\treturn f(w, m // w)\n\tif (m - 1) % w == 0:\n\t\treturn f(w, (m - 1) // w)\n\tif (m + 1) % w == 0:\n\t\treturn f(w, (m + 1) // w)\n\treturn False\n\nw, m = map(int, input().split())\nif f(w, m):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")", "w, m = map(int, input().split())\n\ndef isOK(w, m):\n    wr = convert_base_w(m, w)\n    for i in range(101):\n        if wr[i] == 0 or wr[i] == 1:\n            continue\n        elif wr[i] == w - 1 or wr[i] == w:\n            wr[i + 1] += 1\n        else:\n            return False\n    return True\n\ndef convert_base_w(m, w):\n    wr = [0] * 101\n    for i in range(101):\n        m, r = divmod(m, w)\n        wr[i] = r\n    return wr\n\nif isOK(w, m):\n    print('YES')\nelse:\n    print('NO')", "import math\nimport sys\n\ndef test(d):\n    if d==1:\n        return 1\n    if d%w==0:\n        k=round(d/w)\n        return test(k)\n    if (d-1)%w==0:\n        k=round((d-1)/w)\n        return test(k)\n    if (d+1)%w==0:\n        k=round((d+1)/w)\n        return test(k)\n    return 0\n\n    \n\n\ninp=list(map(int,input().split()))\n\nw=inp[0]\nm=inp[1]\n\na=1\n\n\n\nfor i in range(0,100):\n    if a>m:\n        d=a-m\n        break\n    a*=w\nans=test(d)\nif ans==1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "w, n = map(int, input().split(' '))\nr = 1\n\nif w <= 3:\n    n = 0\n\nwhile n:\n    if not (n % w in {0, 1, w-1}):\n        r = 0\n    if n % w == w - 1:\n        n = n // w + 1\n    else:\n        n = n // w\n        \nif r:\n    print('YES')\nelse:\n    print('NO')", "import math\n\nw,m=map(int,input().split())\nwhile m>0:\n\tif m%w==1:\n\t\tm-=1\n\t\tm/=w\n\telif m%w==w-1:\n\t\tm+=1\n\t\tm/=w\n\telif m%w==0:\n\t\tm/=w\n\telse:\n\t\tprint(\"NO\")\n\t\treturn\nprint(\"YES\")", "w, m = list(map(int, input().split(' ')))\nf = 0\nif (w == 2):\n    print(\"YES\")\nelse:\n    st = 1\n    while (f == 0):\n        if (m % (st * w) != 0):\n            if ((m - st) % (st * w) == 0):\n                m -= st\n            else:\n                if ((m + st) % (st * w) == 0):\n                    m += st  \n                else:\n                    print(\"NO\")\n                    f = 1\n            if (m == 0):\n                print(\"YES\")\n                f = 1                    \n        st *= w\n", "w, m = list(map(int,input().split()))\n\ndef bt(w, p, final, cur):\n    if final == cur:\n        return True\n\n    if p == 0:\n        return False\n\n    if abs(cur + p - final) <= (p - 1) / (w - 1):\n        if bt(w, p // w, final, cur + p):\n            return True\n\n    if abs(cur - p - final) <= (p - 1) / (w - 1):\n        if bt(w, p // w, final, cur - p):\n            return True\n\n    if bt(w, p // w, final, cur):\n        return True\n\n    return False\n\nif bt(w, w ** 35, m, 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "w, m = list(map(int, str.split(input())))\nbits = [0] * 100\nfor i in range(100):\n\n    m, bits[i] = divmod(m, w)\n\nfor i in range(99):\n\n    if 1 < bits[i] < w - 1:\n\n        print(\"NO\")\n        return\n\n    if bits[i] == w - 1:\n\n        bits[i] = 0\n        bits[i + 1] += 1\n        carry = 0\n        for j in range(i + 1, 100):\n\n            carry, bits[j] = divmod(bits[j] + carry, w)\n\nprint(\"YES\")\n", "n, m = [int(x) for x in input().split()]\nbalans = m\nif n == 2 or m == 1:\n    print('YES')\n    return\ncur = 1\nwhile True:\n    cur2 = cur * n\n    if balans % cur2 == cur:\n        balans -= cur\n    elif balans % cur2 == cur2 - cur:\n        balans += cur\n    elif balans % cur2 == 0:\n        balans += 0\n    else:\n        print('NO')\n        return\n    if balans == 0:\n        print('YES')\n        return\n    cur = cur2", "W, M = (input().split(' '))\nW = int(W)\nM = int(M)\n\nif W == 2 or W == 3:\n    print(\"YES\")\nelse:\n    N = 16\n    A = [0]*(N+1)\n    A[0] = 1\n    for I in range(1, N):\n        A[I] = A[I-1]*W\n        if A[I] > 10000000001000000000:\n            N = I;\n            break\n    #print(N)\n    S = set()\n\n    ok = False\n    for msk in range(1 << N):\n        curr = 0\n        for I in range(N):\n            if msk & (1 << I) > 0:\n                curr += A[I]\n        if curr == M or (curr-M in S):\n            ok = True\n            break\n        S.add(curr)\n\n\n    if ok:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "x, y = list(map(int, input().split(' ')))\n\nok = []\nwhile y % x in [0, 1, -1+x]:\n    if y%x == 0:\n        y //= x\n        ok.append(0)\n    elif y%x == 1:\n        y = (y-1)//x\n        ok.append(1)\n\n    else:\n        y = (y+1)//x\n        ok.append(-1)\n\n    if y == 0:\n        break\n        \nif y == 0:\n    print(\"YES\")\n\nelse:\n    print(\"NO\")\n", "def main():\n    w, m = [int(i) for i in input().split()]\n    \n    if w == 2:\n        print(\"YES\")\n        return\n    \n    s = 0\n    for i in range(21):\n        for sign in range(-1, 2):\n            if (m - s - sign * w ** i) % w ** (i + 1) == 0:\n                s += sign * w ** i\n                break\n    \n    if abs(s) == m:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    \nmain()\n", "n, m = list(map(int, input().split()))\na = 0\nd = True\nfor i in range(100):\n    if d and n > 0:\n        if m % (n ** (a + 1)) == n ** a:\n            m  -= n ** a\n            a += 1\n        elif m % (n ** (a + 1)) == 0:\n            a += 1\n        elif (m + n ** a) % (n ** (a + 1)) == 0:\n            m += n ** a\n            a += 1\n        else:\n            d = False\n            print(\"NO\")\nif d:\n    print(\"YES\")\n", "def f(m, t):\n   w = 0\n   nonlocal n\n   while n ** w * n < m:\n       w += 1\n   if n ** w * n == m or (m == 1 and t != 0):\n       return True\n   else:\n       s1 = m - n ** w\n       j = False\n       k = False\n       if w < t:\n          j = f(abs(s1), w)\n       if w + 1 < t:\n           k = f(abs(n ** w * n - m), w + 1)\n       if k == True or j == True:\n          return True\n       else:\n          return False\nn, m = list(map(int, input().split()))\nif f(m, 101):\n  print('YES')\nelse:\n  print('NO')\n\n", "w,m=list(map(int,input().split()))\nfor u in (w**(100-i) for i in range(101)):\n    m=min(m,abs(m-u))\nprint(\"YES\" if m==0 else \"NO\")\n", "w,m=list(map(int,input().split()))\nfor u in(w**(100-i)for i in range(101)):m=min(m,abs(m-u))\nprint(\"YES\"if m==0 else\"NO\")\n", "import math\n\nw, m = list(map(int, input().split()))\nif w == 2:\n    print(\"YES\")\nelse:\n    n = math.ceil(math.log(1e9, w))\n    for mask in range(1 << n):\n        s = m\n        p = 1\n        for i in range(n):\n            if mask & (1 << i):\n                s += p\n            p *= w\n        while s > 0:\n            if s % w > 1:\n                break\n            s //= w\n        else:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n", "a, b = list(map(int, input().split(' ')))\nif a == 2 or a == 3:\n    print(\"YES\")\n    return\n\nelse:\n    while b != 0:\n        if b%a == 0:\n            b //= a\n\n        elif b%a == 1:\n            b -= 1\n            b //= a\n\n        elif b%a == a-1:\n            b += 1\n            b //= a\n\n        else:\n            print(\"NO\")\n            return\n\nprint(\"YES\")\n", "w, m = list(map(int, input().split()))\narr = [0] * 103\ni = 0\nwhile m != 0:\n    arr[i] = m % w\n    m //= w\n    i += 1\nfor j in range(i):\n    if arr[j] == 1 or arr[j] == 0:\n        pass\n    elif arr[j] % w == 0:\n        arr[j + 1] += 1\n    elif arr[j] == w - 1:\n        arr[j + 1] += 1\n    else:\n        print('NO')\n        break\nelse:\n    print('YES')\n", "w,m=map(int,input().split())\nfor i in range(33): m=min(m,abs(w**(32-i)-m))\nprint(\"NO\" if m else \"YES\")", "#!/usr/bin/env python\n# scales.py - Codeforces 552C quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nVanya has a scales for weighing loads and weights of masses w0,?w1,?w2,?..\n.,?w100 grams where w is some integer not less than 2 (exactly one weight\nof each nominal value). Vanya wonders whether he can weight an item with mass\nm using the given weights, if the weights can be put on both pans of the\nscales. Formally speaking, your task is to determine whether it is possible\nto place an item of mass m and some weights on the left pan of the scales,\nand some weights on the right pan of the scales so that the pans of the scales\nwere in balance.\n\nInput\n\nThe first line contains two integers w,?m (2<=w<=10^9, 1<=m<=10^9) - the\nnumber defining the masses of the weights and the mass of the item.\n\nOutput\n\nPrint word 'YES' if the item can be weighted and 'NO' if it cannot.\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\n\n\n###############################################################################\n# Scales Class\n###############################################################################\n\n\nclass Scales:\n    \"\"\" Scales representation \"\"\"\n\n    N = 100\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        self.args = args\n        self.w = args[0]\n        self.m = args[1]\n\n        # Iterator starting position\n        self.maxwp = self.calc_maxwp()\n        self.it_min = 0\n        self.it_max = int(3 ** (self.maxwp + 1)) - 1\n\n        self.yes = 0\n\n    def calc_maxwp(self):\n        \"\"\" Max weight power \"\"\"\n        for p in range(self.N+1):\n            if self.w ** p > self.m:\n                return p\n\n    def list2dec(self, it):\n        result = 0\n        for (n, i) in enumerate(it):\n            result += i * int(3 ** n)\n        return result\n\n    def dec2list(self, dec):\n        result = []\n        remainder = dec\n        for n in range(self.maxwp + 1):\n            pow = int(3 ** (self.maxwp - n))\n            div = remainder // pow\n            remainder -= div * pow\n            result.insert(0, div)\n        return result\n\n    def step(self):\n        \"\"\" Step to the next iteration \"\"\"\n        mid = (self.it_max + self.it_min)//2\n\n        if mid in (self.it_max, self.it_min):\n            return 0\n\n        w = self.calc_weight(mid)\n        if w > self.m:\n            self.it_max = mid\n        elif w < self.m:\n            self.it_min = mid\n        else:\n            self.yes = 1\n            return 0\n\n        return 1\n\n    def calc_weight(self, dec):\n        result = 0\n        it = self.dec2list(dec)\n        for i in range(len(it)):\n            s = it[i]\n            w = self.w ** i\n            if s == 2:\n                result += w\n            if s == 0:\n                result -= w\n        return result\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        while self.step():\n            pass\n\n        return \"YES\" if self.yes else \"NO\"\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef decode_inputs(inputs):\n    \"\"\" Decoding input string list into base class args list \"\"\"\n\n    # Decoding input into a list of integers\n    ilist = [int(i) for i in inputs[0].split()]\n\n    return ilist\n\n\ndef calculate(inputs):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Scales(decode_inputs(inputs)).calculate()\n\n\ndef main():\n    \"\"\" Main function. Not called by unit tests \"\"\"\n\n    # Read test input string list\n    inputs = [input()]\n\n    # Print the result\n    print(calculate(inputs))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_decode_inputs(self):\n        \"\"\" Input string decoding testing \"\"\"\n        self.assertEqual(decode_inputs([\"2 5\"]), [2, 5])\n\n    def test_Scales_class__basic_functions(self):\n        \"\"\" Scales class basic functions testing \"\"\"\n        d = Scales([3, 7])\n        self.assertEqual(d.w, 3)\n        self.assertEqual(d.m, 7)\n\n        # Find the maximum size (power) of the weight we are need\n        self.assertEqual(d.maxwp, 2)\n\n        # Base 3 Iterator value, digits: 0 - -, 1 - 0, 2 - \"+\"\n        self.assertEqual(d.list2dec([1, 0, 2]), 19)\n        self.assertEqual(d.dec2list(19), [1, 0, 2])\n\n        # Check starting iterator\n        d = Scales([2, 3])\n        self.assertEqual(d.it_min, 0)\n        self.assertEqual(d.it_max, 26)\n\n        # Step function 1 - success, 0 - final step\n        d = Scales([2, 3])\n        self.assertEqual(d.step(), 1)\n        self.assertEqual(d.it_min, 13)\n        self.assertEqual(d.it_max, 26)\n\n        # Weight from the iterator\n        d = Scales([3, 7])\n        self.assertEqual(d.calc_weight(d.list2dec([0, 1, 2])), 8)\n\n    def test_calculate(self):\n        \"\"\" Main calculation function \"\"\"\n\n        # Sample test 1\n        self.assertEqual(calculate([\"3 7\"]), \"YES\")\n\n        # Sample test 1\n        self.assertEqual(calculate([\"100 99\"]), \"YES\")\n\n        # Sample test 1\n        self.assertEqual(calculate([\"2 92600\"]), \"YES\")\n\ndef __starting_point():\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n    main()\n\n__starting_point()", "#!/usr/bin/env python\n# scales.py - Codeforces 552C quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nVanya has a scales for weighing loads and weights of masses w0,?w1,?w2,?..\n.,?w100 grams where w is some integer not less than 2 (exactly one weight\nof each nominal value). Vanya wonders whether he can weight an item with mass\nm using the given weights, if the weights can be put on both pans of the\nscales. Formally speaking, your task is to determine whether it is possible\nto place an item of mass m and some weights on the left pan of the scales,\nand some weights on the right pan of the scales so that the pans of the scales\nwere in balance.\n\nInput\n\nThe first line contains two integers w,?m (2<=w<=10^9, 1<=m<=10^9) - the\nnumber defining the masses of the weights and the mass of the item.\n\nOutput\n\nPrint word 'YES' if the item can be weighted and 'NO' if it cannot.\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\n\n\n###############################################################################\n# Scales Class\n###############################################################################\n\n\nclass Scales:\n    \"\"\" Scales representation \"\"\"\n\n    N = 100\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        self.args = args\n        self.w = args[0]\n        self.m = args[1]\n\n        # Iterator starting position\n        self.maxwp = self.calc_maxwp()\n        self.it_min = 0\n        self.it_max = int(3 ** (self.maxwp + 1)) - 1\n\n        self.yes = 0\n\n    def calc_maxwp(self):\n        \"\"\" Max weight power \"\"\"\n        for p in range(self.N+1):\n            if self.w ** p > self.m:\n                return p\n\n    def list2dec(self, it):\n        result = 0\n        for (n, i) in enumerate(it):\n            result += i * int(3 ** n)\n        return result\n\n    def dec2list(self, dec):\n        result = []\n        remainder = dec\n        for n in range(self.maxwp + 1):\n            pow = int(3 ** (self.maxwp - n))\n            div = remainder // pow\n            remainder -= div * pow\n            result.insert(0, div)\n        return result\n\n    def step(self):\n        \"\"\" Step to the next iteration \"\"\"\n        mid = (self.it_max + self.it_min)//2\n\n        if mid in (self.it_max, self.it_min):\n            return 0\n\n        w = self.calc_weight(mid)\n        if w > self.m:\n            self.it_max = mid\n        elif w < self.m:\n            self.it_min = mid\n        else:\n            self.yes = 1\n            return 0\n\n        return 1\n\n    def calc_weight(self, dec):\n        result = 0\n        it = self.dec2list(dec)\n        for i in range(len(it)):\n            s = it[i]\n            w = self.w ** i\n            if s == 2:\n                result += w\n            if s == 0:\n                result -= w\n        return result\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        while self.step():\n            pass\n\n        return \"YES\" if self.yes else \"NO\"\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef decode_inputs(inputs):\n    \"\"\" Decoding input string list into base class args list \"\"\"\n\n    # Decoding input into a list of integers\n    ilist = [int(i) for i in inputs[0].split()]\n\n    return ilist\n\n\ndef calculate(inputs):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Scales(decode_inputs(inputs)).calculate()\n\n\ndef main():\n    \"\"\" Main function. Not called by unit tests \"\"\"\n\n    # Read test input string list\n    inputs = [input()]\n\n    # Print the result\n    print(calculate(inputs))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_decode_inputs(self):\n        \"\"\" Input string decoding testing \"\"\"\n        self.assertEqual(decode_inputs([\"2 5\"]), [2, 5])\n\n    def test_Scales_class__basic_functions(self):\n        \"\"\" Scales class basic functions testing \"\"\"\n        d = Scales([3, 7])\n        self.assertEqual(d.w, 3)\n        self.assertEqual(d.m, 7)\n\n        # Find the maximum size (power) of the weight we are need\n        self.assertEqual(d.maxwp, 2)\n\n        # Base 3 Iterator value, digits: 0 - -, 1 - 0, 2 - \"+\"\n        self.assertEqual(d.list2dec([1, 0, 2]), 19)\n        self.assertEqual(d.dec2list(19), [1, 0, 2])\n\n        # Check starting iterator\n        d = Scales([2, 3])\n        self.assertEqual(d.it_min, 0)\n        self.assertEqual(d.it_max, 26)\n\n        # Step function 1 - success, 0 - final step\n        d = Scales([2, 3])\n        self.assertEqual(d.step(), 1)\n        self.assertEqual(d.it_min, 13)\n        self.assertEqual(d.it_max, 26)\n\n        # Weight from the iterator\n        d = Scales([3, 7])\n        self.assertEqual(d.calc_weight(d.list2dec([0, 1, 2])), 8)\n\n    def test_calculate(self):\n        \"\"\" Main calculation function \"\"\"\n\n        # Sample test 1\n        self.assertEqual(calculate([\"3 7\"]), \"YES\")\n\n        # Sample test 1\n        self.assertEqual(calculate([\"100 99\"]), \"YES\")\n\n        # Sample test 1\n        self.assertEqual(calculate([\"2 92600\"]), \"YES\")\n\ndef __starting_point():\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n    main()\n\n__starting_point()", "def VI(): return list(map(int,input().split()))\ndef Y(): print(\"YES\")\n\ndef run(w,m):\n    if w<=3:\n        Y()\n        return\n    mm = m\n    for i in range(100):\n        if m%w == 0: m //= w\n        elif m%w == 1: m = (m-1)//w\n        elif m%w == w-1: m = (m+1)//w\n        else: break\n        if m==0:\n            Y()\n            return\n        #if w**(i) > mm: break\n\n\n    print(\"NO\")\n\ndef main(info=0):\n    w,m = VI()\n    run(w,m)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
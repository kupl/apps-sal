["from bisect import bisect_left\n\n\nN, M = list(map(int, input().split()))\nS = input()\ngood = []\nbad = []\nfor i in range(N + 1):\n    if S[i] == \"1\":\n        bad.append(i)\n    else:\n        good.append(i)\n\nans = []\ncur = N\nwhile True:\n    if cur == 0:\n        print((\" \".join(map(str, ans[::-1]))))\n        break\n    idx = bisect_left(good, cur - M)\n    nx = good[idx]\n    ans.append(cur - nx)\n    if cur == nx:\n        print((-1))\n        break\n    cur = nx\n", "N, M = map(int, input().split())\nS = list(map(int, reversed(input())))\nnow = 0\nans = []\nwhile now + M < N:\n    last = now\n    now += M\n    while S[now]:\n        now -= 1\n    if last == now:\n        print(-1)\n        break\n    ans.append(now - last)\nelse:\n    print(*reversed(ans + [N - now]))", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    S = list(input())\n    if S[N] == '1' or S[0] == '1':\n        print((-1))\n    else:\n        ans = []\n        now = N\n        while now > 0:\n            for i in range(M, 0, -1):\n                j = max(now - i,-1)\n                if j>=0 and S[j]=='0':\n                    ans.append(i)\n                    now = j\n                    break\n                else:\n                    continue\n            else:\n                print((-1))\n                break\n        else:\n            print((' '.join(map(str, reversed(ans)))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nN, M = map(int,input().split())\nS = input()\nS = S[::-1]\ni = 0\nans = []\nwhile i < N:\n    flag = 0\n    for j in range(M,0,-1):\n        if i + j <= N and S[i + j] == '0':\n            i += j\n            flag = 1\n            ans.append(j)\n            break\n    if flag:\n        continue\n    print(-1)\n    return\nans.reverse()\nprint(*ans)", "from collections import deque\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    inf=10**9\n    n,m=MI()\n    s=SI()\n    dp=[inf]*(n+1)\n    dp[0]=0\n    pre=[-1]*(n+1)\n    q=deque()\n    q.append((0,0))\n    for i,c in enumerate(s[1:]):\n        if q[0][0]==i-m:q.popleft()\n        if c==\"0\":\n            dp[i+1]=q[0][1]+1\n            pre[i+1]=q[0][0]\n        while q and q[-1][1]>dp[i+1]:q.pop()\n        q.append((i+1,dp[i+1]))\n    if dp[-1]>=inf:print(-1)\n    else:\n        ans=[]\n        now=n\n        while n:\n            ans.append(n-pre[n])\n            n=pre[n]\n        print(*ans[::-1])\n\nmain()", "n, m = list(map(int, input().split()))\ns = input()\nsi = []\n\nfor ch in s:\n    if ch == '0':\n        si.append(0)\n    else:\n        si.append(1)\n\nptr = n\nret = []\n\nwhile ptr > 0:\n    for me in range(m, -1, -1):\n        if me == 0:\n            print((-1))\n            return\n        if ptr - me < 0:\n            continue\n        if si[ptr-me] == 0:\n            ret.append(me)\n            ptr -= me\n            break\n\nret.reverse()\n\nprint((' '.join(map(str, ret))))\n", "def main():\n    n, m = list(map(int, input().split()))\n    s = input()\n    ss = s[::-1]\n    if n <= m:\n        print(n)\n    else:\n        cnt = 0\n        for i in range(n + 1):\n            if s[i] == \"1\":\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt >= m:\n                print((-1))\n                return\n        pos = 0\n        res = []\n        while n != pos:\n            for i in reversed(list(range(m + 1))):\n                if pos + i > n:\n                    continue\n                if ss[pos + i] != \"1\":\n                    pos += i\n                    res.append(i)\n                    break\n        print((*res[::-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = list(map(int,input().split()))\ns = input()\ndp = [0]*(n+1)\nr = n\n\nfor i in range(n-1,-1,-1):\n    if int(s[i]) == 1:\n        dp[i] = -1\n        continue\n    while r > i+m:r-=1\n    while dp[r] == -1:r -= 1\n    if r == i:\n        print((-1))\n        return\n    dp[i] = dp[r]+1\nnow = 0\nans = []\nfor i in range(n+1):\n    if dp[i] == -1:continue\n    if dp[i] != dp[now]:\n        ans.append(i-now)\n        now = i\nprint((*ans))\n        \n    \n", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef solve():\n    N, M = Scanner.map_int()\n    S = Scanner.string()\n    pos = N\n    ans = []\n    while pos > 0:\n        for i in range(max(pos - M, 0), pos):\n            if S[i] == '0':\n                ans.append(pos - i)\n                pos = i\n                break\n        else:\n            print((-1))\n            return\n    print((*ans[::-1]))\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\ns = input()\n\none_sequence = 0\nfor i in range(1, n):\n    if s[i] == \"1\":\n        one_sequence += 1\n        if one_sequence == m:\n            print((-1))\n            return\n    else:\n        one_sequence = 0\n\npos = n\nans = \"\"\nwhile pos != 0:\n    for i in range(1, m+1)[::-1]:\n        if pos-i < 0:\n            continue\n        if s[pos-i] != \"1\":\n            ans = str(i) + \" \" + ans\n            pos -= i\n            break\nprint(ans)\n", "#146_F\nn, m = map(int, input().split())\ns = input()[::-1]\nans = []\n\nflg = True\ncur = 0\nwhile cur < n and flg:\n    for to in range(cur + m, cur, -1):\n        if to > n:\n            continue\n            \n        if s[to] == '0':\n            ans.append(to - cur)\n            cur = to\n            break\n        \n        if to == cur + 1:\n            flg = False\n\nif flg:\n    print(*ans[::-1])\nelse:\n    print(-1)", "# \u8f9e\u66f8\u9806\u6700\u5c0f\u3001\u3068\u3044\u3046\u306e\u304c\u30dd\u30a4\u30f3\u30c8\n# \u6700\u521d\u306f\u5c0f\u3055\u304f\u9032\u3093\u3067\u3042\u3068\u304b\u3089\u5927\u304d\u304f\u9032\u3080\u3002\u3053\u308c\u306f\u96e3\u3057\u3044\u3002\u6700\u521d\u3044\u304f\u3064\u306b\u3059\u308c\u3070\u4e0a\u624b\u304f\u30b4\u30fc\u30eb\u3067\u304d\u308b\u306e\u304b\u4e0d\u660e\u3060\u3002\n# \u6700\u521d\u306f\u5927\u304d\u304f\u9032\u3093\u3067\u3042\u3068\u304b\u3089\u5c0f\u3055\u304f\u3059\u308b\u306e\u306f\u305f\u3060\u306e\u8caa\u6b32\u306a\u306e\u3067\u7c21\u5358\u3002\n# \u3057\u305f\u304c\u3063\u3066\u3001\u30b4\u30fc\u30eb\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u306b\u5411\u304b\u3063\u3066\u8caa\u6b32\u306b\u9006\u306b\u9032\u3081\u3070\u3088\u3044\n\nn, m = list(map(int, input().split()))\nmasu = list(input())\n\nidx = n\nans = []\n\nwhile True:\n    valid = False\n    next_min_idx = max(idx-m, 0)\n    for candi in reversed(list(range(next_min_idx, idx))):\n        if masu[candi] == '0':\n            destination = candi\n            valid = True\n    if not valid:\n        # m\u30de\u30b9\u9023\u7d9a\u30671\u306a\u306e\u3067\u5fc5\u305a\u30b2\u30fc\u30e0\u30aa\u30fc\u30d0\u30fc\n        print((-1))\n        return\n    ans.append(idx - destination)\n    idx = destination\n\n    if idx == 0:\n        break\n\nstr_list = list(map(str, ans))\nprint((' '.join(reversed(str_list))))\n", "from sys import stdin\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,m=map(int,readline().split())\n    s=readline().strip()\n\n    ans=[]\n    flag=False\n    i=n\n    while True:\n        max_i=i\n        for sa in range(1,m+1):\n            if i-sa==0:\n                ans.append(sa)\n                flag=True\n                break\n            else:\n                if s[i-sa]==\"0\":\n                    max_i=i-sa\n        if flag: break\n        else:\n            if max_i!=i:\n                ans.append(i-max_i)\n                i=max_i\n            else:\n                break\n\n    if flag:\n        ans.reverse()\n        print(*ans)\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n    N, M = map(int, input().split())\n    S = input()\n\n    def isOK(index):\n        return S[index] == \"0\"\n    \n    ans = []\n    now = N\n    while now:\n        for step in range(min(now, M), -1, -1):\n            if step == 0:\n                print(-1)\n                return\n\n            if isOK(now-step):\n                ans.append(step)\n                now -= step\n                break\n    print(*ans[::-1], sep=\" \")\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = map(int, input().split())\nS = input()[::-1]\nl = []\np = 0\n\nchk = True\nwhile p<N:\n    for i in range(1, min(M, N-p)+1)[::-1]:\n        if S[p+i]==\"0\":\n            break\n    else:\n        print(-1)\n        chk = False\n        break\n    l.append(i)\n    p += i\n\nif chk:\n    l.reverse()\n    print(*l)", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nn, m = map(int, input().split())\ns = input()\ns = s[::-1]\nINF = 2*n\n\nif '1'*m in s:\n    print(-1)\n    return\n\ndp = [-1] * (n+1)\nnw = 0\nst = 0\nnst = 0\nret = []\nwhile nw < (n+1):\n    if s[nw]=='1':\n        dp[nw] = INF\n    else:\n        dp[nw] = dp[st] + 1\n        nst = nw\n    nw += 1\n    if nw == n+1:\n        ret.append(nst-st)\n    elif nw > st + m:\n        ret.append(nst-st)\n        st = nst\nprint(' '.join(map(str,ret[::-1])))", "import sys\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\nS = list(input().rstrip())\n\ndef cost(S):\n    minCost = [-1]*(N+1)\n    minCost[0] = 0\n    ind = 1\n    for i,s in enumerate(S):\n        if s == \"1\":\n            continue\n        while i < ind <= min(i+M, N):\n            if S[ind] == \"0\":\n                minCost[ind] = minCost[i] + 1\n            ind += 1\n    return minCost\n\nM1 = cost(S)\nM2 = cost(S[::-1])[::-1]\nif M1[-1] == -1:\n    print((-1))\nelse:\n    C = M1[-1]\n    Inds = [10**14]*(C+1)\n    for i, (m1, m2) in enumerate(zip(M1, M2)):\n        if m1 + m2 == C:\n            Inds[m1] = min(Inds[m1], i)\n    ans = []\n    for i1, i2 in zip(Inds, Inds[1:]):\n        ans.append(i2-i1)\n    print((*ans))\n", "import bisect\n\nN, M = list(map(int, input().split()))\nS = input()\n\nok = True\ncnt = 0\nfor c in S:\n    if c == \"1\":\n        cnt += 1\n        if cnt == M:\n            ok = False\n            break\n    else:\n        cnt = 0\n\n# \u5f8c\u308d\u304b\u3089\u898b\u3066\u3001\u5404\u30de\u30b9\u304b\u3089\u3082\u3063\u3068\u3082\u8fd1\u3044\u53f3\u5074\u306e0\u306e\u4f4d\u7f6e\u3092\u683c\u7d0d(S[i]=0\u306a\u3089i)\nngo_pos = [0 for _ in range(N+1)]\nmost_neighbor_zero_pos = N\nfor i in range(N, -1, -1):\n    if S[i] == \"0\":\n        ngo_pos[i] = i\n        most_neighbor_zero_pos = i\n    else:\n        ngo_pos[i] = most_neighbor_zero_pos\n\nif not ok:\n    print((-1))\nelse:\n    ans = []\n    pos = N\n    while pos > 0:\n        npos = ngo_pos[max(0, pos-M)]\n        ans.append(pos-npos)\n        pos = npos\n    print((\" \".join(map(str, ans[::-1]))))\n", "n, m = map(int, input().split())\ns = input()\ndp = [-1 for _i in range(n+1)]\ndp[0] = 0\nf = 0\nfrom collections import deque\nq = deque([0])\nc = 0\nfor i in range(1, n+1):\n    if s[i]==\"0\":\n        c = 0\n        while i-f > m:\n            f = q.popleft()\n        dp[i] = f\n        q.append(i)\n    elif c < m-1:\n        c += 1\n    else:\n        break\n\nif dp[n] >= 0:\n    r = []\n    p = n\n    while p > 0:\n        nex = dp[p]\n        r.append(p-nex)\n        p = nex\n    print(*r[::-1])\nelse:\n    print(-1)", "n,m = map(int,input().split())\ns = input()\ns = s[::-1]\nans = []\ncur = 0\nc = 0\n#while cur < n and c < 100:\nwhile cur < n:\n    d = n - cur\n    r = min(m,d)\n    cnt = 0\n    for i in range(r):\n        x = r - i\n        if s[cur + x] == '0':\n            ans.append(x)\n            cur += x\n            #print(x)\n            break\n        else:\n            cnt += 1\n    if cnt == r:\n        print(-1)\n        return\n    #c += 1\n    #print(cur,r)\n\n\nprint(*ans[::-1])", "#!python3\n\nfrom collections import deque\n\nLI = lambda: list(map(int, input().split()))\n\n# input\nN, M = LI()\nS = input()\n\nINF = 10 ** 6\n\n\ndef main():\n    w = [(INF, INF)] * (N + 1)\n    w[0] = (0, 0)\n    # (cost, index)\n    dq = deque([(0, 0)])\n    for i in range(1, N + 1):\n        if i - dq[0][1] > M:\n            dq.popleft()\n        if len(dq) == 0:\n            print((-1))\n            return\n        if S[i] == \"0\":\n            w[i] = (dq[0][0] + 1, i - dq[0][1])\n            dq.append((w[i][0], i))\n\n    ans = []\n    x = N\n    while x > 0:\n        d = w[x][1]\n        ans.append(d) \n        x -= d\n    ans = ans[::-1]\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,m = map(int, input().split())\n    s = input().rstrip()\n    s = s[::-1]\n    # \u53f3\u304b\u30890, 1, 2...\u3068\u3057\u305f\u6642\u306e\u30bb\u30fc\u30d5\u306a\u4f4d\u7f6e\n    safe = []\n    for i in range(n+1):\n        if s[i] == '0':\n            safe.append(i)\n    res = []\n\n    pos = 0\n    while pos < n:\n        pre = pos\n        pos += m\n        if pos >= n:\n            res.append(str(n-pre))\n            break\n        idx = bisect_left(safe, pos)\n        if safe[idx] > pos:\n            pos = safe[idx-1]\n        if pre == pos:\n            print(-1)\n            return\n        res.append(str(pos-pre))\n    print(*res[::-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import bisect_left\nN, M = list(map(int, input().split()))\ns = input()\nsafe = []\ncnt = 0\nfor i, m in enumerate(s):\n  if m=='1':\n    cnt += 1\n    if cnt==M:\n      print((-1))\n      break\n  else:\n    safe += [i]\n    cnt = 0\nelse:\n  ps = N\n  ans = []\n  while ps!=0:\n    ind = bisect_left(safe,ps-M)\n    ans += [ps-safe[ind]]\n    ps = safe[ind]\n  print((*ans[::-1]))\n    \n", "import sys\nN, M = list(map(int, input().split()))\nS = [int(c) for c in input()][::-1]\n\nc = 0\npath = []\nwhile c < N:\n    g = c+M if c+M < N else N\n    for m in range(g, c, -1):\n        if S[m] == 1:\n            continue\n        else:\n            path.append(m-c)\n            c = m\n            break\n    else:\n        if c < N:\n            print((-1))\n            return\n\nprint((*path[::-1]))\n\n", "N,M = map(int,input().split())\nS = list(input())\n#print(S)\nS.reverse()\n\nif S[0] == 1 or S[-1] == 1:\n    det = -1\nelse:\n    det = 0\n    count = 0\n    data = []\n    for i in range(N+1):\n        if S[i] == \"0\":\n            data.append(count+1)\n            count = 0\n        else:\n            count += 1\n        if count == M:\n            det = -1\n            break\n    #print(data)\n    \nif det != -1:\n    ans = []\n    count = 0\n    for i in range(1,len(data)):\n        if count + data[i] > M:\n            ans.append(count)\n            count = data[i]\n        else:\n            count += data[i]\n    ans.append(count)\n    ans.reverse()\n    print(\" \".join(map(str,ans)))\n\nelse:\n    print(-1)", "n,m = list(map(int, input().split()))\ns = input()\nnow = 0\nMIN = 0\nans = []\nwhile now < n:\n  for i in range(min(n-now,m),0,-1):\n    nex = now + i\n    if s[nex] == \"0\":\n      now = nex\n      MIN += 1\n      break\n  else:\n    print((-1))\n    return\nnow = 0\nwhile now < n:\n  for i in range(min(n-now,m),0,-1):\n    nex = now + i\n    if s[n-nex] == \"0\":\n      now = nex\n      ans.append(i)\n      break\nprint((*reversed(ans)))\n", "n,m=map(int,input().split())\ns=input()[::-1]\nans=[]\npos=0\nwhile pos!=n:\n  for i in range(min(n-pos,m),0,-1):\n    if s[pos+i]=='0':\n      ans.append(i)\n      pos+=i\n      break\n  else:\n    print(-1)\n    return\nprint(*ans[::-1])", "n,m=map(int,input().split())\n*s,=map(int,input()[::-1])\ni=0\na=[]\nwhile i<n:\n    j=min(n,i+m)\n    while s[j]:j-=1\n    if j==i:\n        print(-1)\n        return\n    a+=j-i,\n    i=j\nprint(*a[::-1])", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    S = list(input())\n    if S[N] == '1' or S[0] == '1':\n        print((-1))\n    else:\n        ans = []\n        now = N\n        while now > 0:\n            for i in range(M, 0, -1):\n                j = now - i\n                if j>=0:\n                    if S[j]=='0':\n                        ans.append(i)\n                        now = j\n                        break\n                else:\n                    continue\n            else:\n                print((-1))\n                break\n        else:\n            print((' '.join(map(str, reversed(ans)))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\ns = input()[::-1]\nans = []\nnow = 0\nwhile now<n:\n    for i in range(min(m, n-now), 0, -1):\n        if s[now+i]=='0':\n            now += i\n            ans.append(i)\n            break\n    else:\n        print(-1)\n        return\nprint(*ans[::-1])", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    S = input().strip(\"\\n\")\n    now = N\n    ans = []\n    while now > 0:\n        for i in reversed(range(1, M+1)):\n            if now - i < 0: continue\n            elif S[now - i] == \"0\":\n                ans.append(i)\n                now -= i\n                break\n        else: \n            print(-1)\n            break\n    else: \n        A = [int(ans[-1 - i]) for i in range(len(ans))]\n        print(\" \".join(map(str, A)))\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, m = list(map(int,input().split()))\ns = list(input())\n\ns.reverse()\nng = False\nc = 0\nans = []\nwhile ng == False and c < n:\n    for i in range(m, 0, -1):\n        if c+i < n+1 and s[c+i] == '0':\n            c += i\n            ans.append(str(i))\n            break\n        elif i == 1:\n            ng = True\nif ng:\n    print((-1))\nelse:\n    ans.reverse()\n    print((' '.join(ans)))\n", "def main():\n  N,M=list(map(int,input().split()))\n  S=input()\n\n  c,l=N,[]\n  while c>0:\n    for i in range(M,0,-1):\n      if i<=c and S[c-i]=='0':\n        l+=[i]\n        c-=i\n        break\n    else:\n      l=[-1]\n      break\n  print((*l[::-1]))\n\nmain()\n", "import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nn,m = na()\ns = list(ns())\ns = s[::-1] #n+1\n\nans = []\ni = 0\nwhile True:\n    j = i+m if i+m < n else n\n    for k in reversed(range(i+1,j+1)):\n        if s[k] == '0':\n            ans.append(k-i)\n            i = k\n            break\n    else:\n        print(-1)\n        return\n    if i == n:\n        break\n\nprint(*ans[::-1],sep=' ')", "N,M=map(int, input().split())\nS=list(input())\nT=S[::-1]\nD=[0]*N\nif N<=M:\n  print(N)\n  return\nr=0\nrenzoku,ma=0,0\nfor i in range(1,N+1):\n  if S[i]=='1':\n    renzoku+=1\n  else:\n    ma=max(ma,renzoku)\n    renzoku=0\nif ma>=M:\n  print(-1)\n  return\n\nfor i in range(1,M+1):\n  if T[i]!='1':\n    D[i]=1\n    r=i\n  else:\n    D[i]=100000\nans=[r]\n\nwhile r+M<N:\n  for i in range(M,0,-1):\n    if T[r+i]=='0':\n      ans.append(i)\n      r+=i\n      break\n  \nans.append(N-r)\nprint(*ans[::-1])", "n, m = map(int, input().split())\nS = list(input())\n\"\"\"\n9 3\n0001000100\n0010001000\n3  2   3 1  \n\"\"\"\nS_r = S[::-1] + [\"0\"] #\u30b9\u30bf\u30fc\u30c8\u306e\u3076\u3093\u4ed8\u3051\u8db3\u3057\nans = []\nnow = 0\nwhile now < n:\n    flg = True\n    for i in range(m,0,-1):\n        if now + i <= n and S_r[now+i] == \"0\":\n            ans.append(i)\n            now += i\n            flg = False\n            break\n    if flg:\n        print(-1)\n        return\n\nprint(*ans[::-1])", "#!/usr/bin/env python3\nimport sys\ndef input(): return sys.stdin.readline().rstrip()\n\n# \u30e9\u30a4\u30d6\u30e9\u30ea\u53c2\u7167https://atcoder.jp/contests/practice2/submissions/16580070\n\n\nclass SegmentTree:\n\n    __slots__ = [\"func\", \"e\", \"original_size\", \"n\", \"data\"]\n\n    def __init__(self, length_or_list, func=max, e=-10**18):\n        self.func = func\n        self.e = e\n        if isinstance(length_or_list, int):\n            self.original_size = length_or_list\n            self.n = 1 << ((length_or_list - 1).bit_length())\n            self.data = [self.e] * (self.n*2)\n        else:\n            self.original_size = len(length_or_list)\n            self.n = 1 << ((self.original_size - 1).bit_length())\n            self.data = [self.e] * self.n + length_or_list + \\\n                [self.e] * (self.n - self.original_size)\n            for i in range(self.n-1, 0, -1):\n                self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def replace(self, index, value):\n        index += self.n\n        self.data[index] = value\n        index //= 2\n        while index > 0:\n            self.data[index] = self.func(\n                self.data[2*index], self.data[2*index+1])\n            index //= 2\n\n    def folded(self, l, r):\n        left_folded = self.e\n        right_folded = self.e\n        l += self.n\n        r += self.n\n        while l < r:\n            if l % 2:\n                left_folded = self.func(left_folded, self.data[l])\n                l += 1\n            if r % 2:\n                r -= 1\n                right_folded = self.func(self.data[r], right_folded)\n            l //= 2\n            r //= 2\n        return self.func(left_folded, right_folded)\n\n    def all_folded(self):\n        return self.data[1]\n\n    def __getitem__(self, index):\n        return self.data[self.n + index]\n\n    def max_right(self, l, f):\n        # assert f(self.e)\n        if l >= self.original_size:\n            return self.original_size\n        l += self.n\n        left_folded = self.e\n        while True:\n            # l //= l & -l\n            while l % 2 == 0:\n                l //= 2\n            if not f(self.func(left_folded, self.data[l])):\n                while l < self.n:\n                    l *= 2\n                    if f(self.func(left_folded, self.data[l])):\n                        left_folded = self.func(left_folded, self.data[l])\n                        l += 1\n                return l - self.n\n            left_folded = self.func(left_folded, self.data[l])\n            l += 1\n            if l == l & -l:\n                break\n        return self.original_size\n\n    # \u672averify\n    def min_left(self, r, f):\n        # assert f(self.e)\n        if r == 0:\n            return 0\n        r += self.n\n        right_folded = self.e\n        while True:\n            r //= r & -r\n            if not f(self.func(self.data[r], right_folded)):\n                while r < self.n:\n                    r = 2 * r + 1\n                    if f(self.func(self.data[r], right_folded)):\n                        right_folded = self.func(self.data[r], right_folded)\n                        r -= 1\n                return r + 1 - self.n\n            if r == r & -r:\n                break\n        return 0\n\n\ndef minindex(x, y):\n    if x[0] <= y[0]:\n        return x\n    else:\n        return y\n\n\ndef main():\n    n, m = map(int, input().split())\n    S = list(map(lambda x: 0 if x == '0' else 10**10, list(input())))\n    roots = [10**10]*(n+1)\n    for i in range(1, min(m+2, n+1)):\n        if S[i] < 10**9:\n            S[i] = 1\n            roots[i] = 0\n    S = [[s, i] for i, s in enumerate(S)]\n    seg = SegmentTree(S, minindex, [10**12, 10**12])\n    for i in range(m+1, n+1):\n        if S[i][0] < 10**9:\n            dist, masu = seg.folded(i-m, i)\n            roots[i] = masu\n            seg.replace(i, [dist+1, i])\n    #print(seg.data[16:])\n    #print(roots)\n    if seg.folded(n, n+1)[0] > 10**9:\n        print(-1)\n    else:\n        ans = []\n        while n > 0:\n            ans.append(n-roots[n])\n            n = roots[n]\n        print(*ans[::-1], sep=\" \")\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = list(map(int, input().split()))\nS = input()\nprev = N\npos = N\nans = []\nwhile pos > 0:\n    for i in range(M, 0, -1):\n        if pos - i >= 0 and S[pos - i] == '0':\n            ans.append(i)\n            pos -= i\n            break\n    if pos == prev:\n        ans = [-1]\n        break\n    prev = pos\nprint((*ans[::-1]))\n", "import sys\n\nN, M = map(int, input().split())\nS = input()\ntmp = 0\nfor i in range(N+1):\n\tif S[i] == '1':\n\t\ttmp += 1\n\t\tif tmp == M:\n\t\t\tprint(-1)\n\t\t\treturn\n\telse:\n\t\ttmp = 0\n\nans = []\n\ni = N\nwhile i > M:\n\tind = S[i-M:i].find('0')\n\tans.append(M-ind)\n\ti -= M - ind\n\nans.append(i)\n\nprint(*ans[::-1])", "import sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nin_n = lambda: int(readline())\nin_nn = lambda: list(map(int, readline().split()))\nin_s = lambda: readline().rstrip().decode('utf-8')\nin_nl = lambda: list(map(int, readline().split()))\nin_nl2 = lambda H: [in_nl() for _ in range(H)]\nin_map = lambda: [s == ord('.') for s in readline() if s != ord('\\n')]\nin_map2 = lambda H: [in_map() for _ in range(H)]\nin_all = lambda: list(map(int, read().split()))\n\n\ndef main():\n    N, M = in_nn()\n    S = in_s()\n\n    ans = []\n    now = N\n    while now > 0:\n        next = -1\n        end = max(0, now - M)\n        for i in range(now - 1, end - 1, -1):\n            if S[i] == '0':\n                next = i\n        if next == -1:\n            print((-1))\n            return\n        else:\n            ans.append(now - next)\n            now = next\n\n    ans = ans[::-1]\n    print((' '.join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nS = input()[::-1]\n\nif M >= N:\n    print(N)\n    return\n\np = -1\nfor i in reversed(range(1,M+1)):\n    if S[i] == \"0\":\n        p = i\n        break\n\nif p == -1:\n    print(-1)\n    return\n\nps = [p]\nwhile 1:\n    tmp = -1\n    for i in reversed(range(ps[-1]+1,ps[-1]+M+1)):\n        try:\n            if S[i] == \"0\" or i == N:\n                ps.append(i)\n                tmp = i\n                break\n        except:\n            pass\n    if tmp == -1:\n        print(-1)\n        return\n    if ps[-1] == N:\n        break\n\npp = ([ps[i+1]-ps[i] for i in range(len(ps)-1)])[::-1] + [ps[0]]\nprint(*pp)", "n, m = map(int, input().split())\ns = input()\nout_s='1'*(m)\nif out_s in s:\n    print(-1)\n    return\ns = s[::-1]\nif s[0] == \"1\":\n    print(-1)\n    return\npre = [-1] * (n + 1)\nstack = [0]\nwhile stack:\n    now = stack.pop()\n    if now == n:\n        break\n    for i in range(1, m + 1):\n        tsugi = now + i\n        if tsugi > n:\n            continue\n        if s[tsugi] == \"1\":\n            continue\n        pre[tsugi] = now\n        stack.append(tsugi)\nelse:\n    print(-1)\n    return\nato = n\nmae = pre[n]\nans = []\nwhile mae >= 0:\n    ans.append(ato - mae)\n    ato = mae\n    mae = pre[ato]\nprint(*ans, sep=\" \")\n", "from bisect import bisect_right\n\nN, M = list(map(int, input().split()))\nS = [N - i for i, s in enumerate(input()) if s == '0']\nS = S[::-1]\n\nans = []\nnow = 0\nwhile now < N:\n    i = bisect_right(S, now + M) - 1\n\n    if S[i] == now:\n        print('-1')\n        return\n\n    ans.append(S[i] - now)\n    now = S[i]\n\nprint((*ans[::-1]))\n", "n,m = map(int,input().split())\ns = input()[::-1]\n\n#\u307e\u305a\u4f55\u624b\u3067\u30af\u30ea\u30a2\u3067\u304d\u308b\u304b\u3092\u628a\u63e1\u3059\u308b\ncount = 1\ninf = 10**10\n\n#\u30b4\u30fc\u30eb\u307e\u3067\u305d\u306e\u5730\u70b9\u304b\u3089\u4f55\u624b\u3067\u5230\u9054\u3067\u304d\u308b\u304b\u3092\u8a18\u9332\u3059\u308b\nlength = [inf]*(n+1)\nlength[0] = 0\nnow = 0\nflag = True\n\nwhile flag:\n    ok = 0\n    for i in range(1,m+1):\n        if s[now+i] == \"1\":\n            continue\n        length[now+i] = count\n        ok = now+i\n        if now+i == n:\n            flag = False\n            break\n    if ok == 0:\n        print(-1)\n        return\n    now = ok\n    count += 1\n\ncount -= 2\n\n#\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u8ecc\u8de1\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nli = []\nlength = length[::-1]\npoint = 0\n\nfor i,j in enumerate(length):\n    if j == count:\n        count -= 1\n        li.append(point)\n        point = 0\n    point += 1\n\nprint(*li)", "N,M = map(int,input().split())\nS = input()\n\nans = []\ni = N\nwhile i>0:\n    if i <= M:\n        ans.append(i)\n        break\n    for j in range(M,0,-1):\n        if S[i-j]=='1': continue\n        ans.append(j)\n        i -= j\n        break\n    else:\n        print(-1)\n        return\nprint(*ans[::-1])", "n, m = list(map(int, input().split()))\ns = list(input())[::-1]\ni = 0\nans = 0\nans_list = []\nwhile i < n:\n    l = s[i+1:i+m+1]\n    for next in range(m-1, -2, -1):\n        if next == -1:\n            print((-1))\n            return\n        if next > len(l)-1:\n            continue\n        if l[next] == '0':\n            ans_list.append(next+1)\n            i += next+1\n            break\nprint((' '.join(map(str, ans_list[::-1]))))\n", "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**6)\n# buff_readline = sys.stdin.buffer.readline\nbuff_readline = sys.stdin.readline\nreadline = sys.stdin.readline\n\nINF = 2**62-1\n\n\ndef read_int():\n    return int(buff_readline())\n\n\ndef read_int_n():\n    return list(map(int, buff_readline().split()))\n\n\ndef read_float():\n    return float(buff_readline())\n\n\ndef read_float_n():\n    return list(map(float, buff_readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\nclass Mod:\n    def __init__(self, m):\n        self.m = m\n\n    def add(self, a, b):\n        return (a + b) % self.m\n\n    def sub(self, a, b):\n        return (a - b) % self.m\n\n    def mul(self, a, b):\n        return ((a % self.m) * (b % self.m)) % self.m\n\n    def div(self, a, b):\n        return self.mul(a, pow(b, self.m-2, self.m))\n\n    def pow(self, a, b):\n        return pow(a, b, self.m)\n\n\nclass Bisect:\n    def __init__(self, func):\n        self.__func = func\n\n    def bisect_left(self, x, lo, hi):\n        while lo < hi:\n            mid = (lo+hi)//2\n            if self.__func(mid) < x:\n                lo = mid+1\n            else:\n                hi = mid\n        return lo\n\n    def bisect_right(self, x, lo, hi):\n        while lo < hi:\n            mid = (lo+hi)//2\n            if x < self.__func(mid):\n                hi = mid\n            else:\n                lo = mid+1\n        return lo\n\n\n@mt\ndef slv(N, M, S):\n\n    from functools import lru_cache\n    @lru_cache(maxsize=None)\n    def dfs(x):\n        if x == 0:\n            return []\n\n        for i in range(M, 0, -1):\n            if 0 <= x-i and S[x-i] == '0':\n                r = dfs(x-i)\n                if r is not None:\n                    r.append(i)\n                    return r\n        return None\n    ans = dfs(N)\n    if ans is None:\n        ans = [-1]\n    return ans\n\n\n\n\ndef main():\n    N, M = read_int_n()\n    S = read_str()\n    print(*slv(N, M, S))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = list(map(int, input().split()))\nS = input()\nS = S[::-1]\nl = len(S)\n\nidx = 0\nanswer = []\nflag = False\nwhile True:\n    if l - idx > M:\n        m = M\n    else:\n        m = l - idx - 1\n        flag = True\n    if S[idx + m] == '0':\n        answer.append(m)\n        idx += m\n        if flag:\n            break\n    else:\n        while S[idx + m] == '1':\n            m -= 1\n            if m == 0:\n                print((-1))\n                return\n        answer.append(m)\n        idx += m\n\nif answer[-1] == 0:\n    answer.pop()\nanswer = answer[::-1]\nprint((' '.join(map(str, answer))))\n", "n, m = map(int, input().split())\ns = input()\ns = ''.join(reversed(s))\nans = []\nindex = 0\nwhile index < n:\n    next_index = -1\n    for j in range(min(index + m, n), index, -1):\n        if s[j] == '0':\n            next_index = j\n            break\n    if next_index == -1:\n        ans = [-1]\n        break\n    ans.append(next_index - index)\n    index = next_index \nprint(' '.join(list(map(str, list(reversed(ans))))))", "N, M = list(map(int, input().split()))\nS = input()\n\np = N\nprev = N\nflag = True\nans = []\nfor i in range(N, -1, -1):\n    if (prev - i) > M:\n        ans.append(prev - p)\n        prev = p\n        if (prev - i) > M:\n            flag = False\n            break\n    if S[i] == \"0\":\n        p = i\nans.append(prev)\nif flag:\n    print((\" \".join(map(str, ans[::-1]))))\nelse:\n    print((-1))\n", "# AtCoder Beginner Contest 146\n# F - Sugoroku\n# https://atcoder.jp/contests/abc146/tasks/abc146_f\nimport sys\nN, M = list(map(int, input().split()))\n*S, = list(map(int, input()))\nS.reverse()\n\ni = 0\nans = []\nwhile i < N:\n    for m in range(M, 0, -1):\n        if i+m <= N and S[i+m] == 0:\n            i += m\n            ans += [m]\n            break\n    else:\n        print((-1))\n        return\n\nprint((*ans[::-1]))\n", "def main():\n    N, M = list(map( int, input().split()))\n    S = [ int(s) for s in input()][::-1]\n    ANS = []\n    t = 0\n    while t < N:\n        for i in range( min(M, N-t),0,-1):\n            if S[t+i] == 0:\n                ANS.append(i)\n                t += i\n                break\n        else:\n            print((-1))\n            return\n    if sum(ANS) == N:\n        print(( \" \".join( map( str,ANS[::-1]))))\n    else:\n        print((-1))\n                \n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\nn,m=map(int,input().split())\ns=input()\nans=[]\ndef f(i,j):\n    if i==0:\n        print(\" \".join(map(str,ans[::-1])))\n        return\n    if j>i:\n        j=i\n    while s[i-j]==\"1\":\n        j-=1\n    if j==0:\n        print(-1)\n        return\n    ans.append(j)\n    f(i-j,m)\nf(n,m)", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, M = lr()\nS = list(sr())[::-1]\nanswer = []\ncount = 0\ncur = 0\nwhile True:\n    next = cur\n    for i in range(M, 0, -1):\n        if cur + i > N:\n            continue\n        if S[cur+i] == '0':\n            count += 1\n            next = cur + i\n            answer.append(i)\n            break\n        else:\n            continue\n    if next == cur:\n        print((-1)); return\n    cur = next\n    if next == N:\n        break\n\nanswer = answer[::-1]\nprint((*answer))\n", "def main():\n    N, M = list(map(int, input().split()))\n    *G, = list(map(int, input()))\n\n    ans = []\n    cur = N\n    ecur = cur - 1\n    while cur > 0:\n        ncur = cur\n        while (cur - ecur) <= M and ecur >= 0:\n            if G[ecur] == 0:\n                ncur = ecur\n            ecur -= 1\n\n        if ncur == cur:\n            print((-1))\n            return\n\n        ans.append(cur - ncur)\n        cur = ncur\n\n    ans.reverse()\n\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M=map(int, input().split())\nS=input()\nnow=S[N-1]\ndp=[float(\"INF\")]*(N+1)\ndp[N]=0\nnowmin=0\nright=N\nfor left in range(N-1,-1,-1):\n    while right-left>M or S[right]==\"1\":\n        right-=1\n        nowmin=dp[right]\n    if right<=left:\n        print(-1)\n        return\n    if S[left]==\"1\":\n        continue\n    else:\n        dp[left]=1+nowmin\n#print(dp)\n#print(dp[0])\nnow=dp[0]\nnowi=0\n\"\"\"\nif now==float(\"INF\"):\n    print(-1)\n    return\n\"\"\"\nfor i in range(1,N+1):\n    if now>dp[i]:\n        print(i-nowi, end=\" \")\n        now=dp[i]\n        nowi=i\n", "N,M=map(int,input().split())\nS=input()\nS=S[::-1]\nnow = 0\nok=1\nhistory = []\nwhile True:\n  for i in range(min(M, N-now),0,-1):\n    if S[now+i] == '0':\n      now += i\n      history.append(str(i))\n      break\n    if i==1:\n      print(-1)\n      ok=0\n      break\n  if ok==0:break\n  if now == N:break\n\nif ok==1:print(' '.join(history[::-1]))", "def main():\n    n, m = map(int, input().split())\n    s = input().rstrip()\n    ans = []\n    x = n\n    f = True\n    while x > 0 and f:\n        for i in reversed(range(m+1)):\n            if i == 0:\n                f = False\n                break\n            if s[max(0, x-i)] == '0':\n                if x-i < 0:\n                    ans.append(x)\n                else:\n                    ans.append(i)\n                x = max(0, x-i)\n                break\n    if f:\n        for v in reversed(ans):\n            print(v, end=\" \")\n        print(\"\")\n    else:\n        print(\"-1\")\n\ndef __starting_point():\n    main()\n__starting_point()", "N,M=map(int, input().split())\nS=list(input())\nT=S[::-1]\nD=[0]*N\nif N<=M:\n  print(N)\n  return\nrenzoku,ma=0,0\nfor i in range(1,N+1):\n  if S[i]=='1':\n    renzoku+=1\n  else:\n    ma=max(ma,renzoku)\n    renzoku=0\nif ma>=M:\n  print(-1)\n  return\nr=0\nfor i in range(1,M+1):\n  if T[i]!='1':\n    r=i\nans=[r]\n\nwhile r+M<N:\n  for i in range(M,0,-1):\n    if T[r+i]=='0':\n      ans.append(i)\n      r+=i\n      break\n  \nans.append(N-r)\nprint(*ans[::-1])", "\nN, M = list(map(int, input().split()))\ns = input()\nans = []\ncur = N\nwhile cur != 0:\n    for step in range(M, 0, -1):\n        if cur - step < 0:\n            continue\n        if s[cur-step] == '1':\n            continue\n        ans.append(step)\n        cur -= step\n        break\n    else:\n        print((-1))\n        return\nprint((*ans[::-1]))\n", "n,m=map(int,input().split())\ns=input()[::-1]\ni=0\nans=[]\nwhile i<n:\n  for j in range(min(n-i,m),0,-1):\n    if s[i+j]==\"0\":\n      ans.append(j)\n      i+=j\n      break\n    if j==1:print(-1);return\nprint(*ans[::-1])", "n, m = map(int, input().split())\ns = input()\n\nl = []\ncur = n\n\nwhile cur > 0:\n  position = cur\n  cur = max(0, cur - m)\n  while s[cur] == \"1\":\n    cur += 1\n  if cur == position:\n    print(-1)\n    return\n  l.append(str(position - cur))\nl.reverse()\nprint(\" \".join(l))", "n, m = map(int, input().split())\ns = input()\nn += 1\n\npos = [n - 1]\nind = n - 1\nwhile True:\n    tmp = -1\n    for i in range(1, m + 1):\n        if s[max(ind - i, 0)] == \"0\":\n            tmp = max(ind - i, 0)\n    if tmp == -1:\n        print(-1)\n        return\n    pos.append(tmp)\n    ind = tmp\n    if ind == 0:\n        break\ntmp = pos[::-1]\nans = []\nfor i in range(len(tmp) - 1):\n    ans.append(tmp[i + 1] - tmp[i])\nprint(*ans)", "#F sugoroku\n#\u8caa\u6b32\u306bN\u304b\u3089M\u4ee5\u4e0b\u306e\u7bc4\u56f2\u3067\u623b\u308c\u308b\u3060\u3051\u623b\u308b\u3053\u3068\u306b\u3059\u308b\nsafe=[]\nn,m=map(int,input().split())\nfield=list(input())\nfor i in range(n+1):\n    if field[i]==\"0\":\n        safe.append(i)\nstart=n\n\nimport bisect\n\ndeque=[]\nflag=True\nwhile start>0:\n    if start>=m:\n        index=bisect.bisect_left(safe,start-m)\n        if safe[index]!=start:\n            deque.append(start-safe[index])\n            start=safe[index]           \n\n        elif safe[index]==start:\n            flag=False\n            start=0              \n    else:\n        deque.append(start)\n        start=0\nif flag:\n    deque=deque[::-1]\n    print(*deque)\nelse:\n    print(-1)        ", "n,m = list(map(int,input().split()))\ns = list(input())\ns.reverse()\nfor i in range(m):\n    s.append(\"1\")\np = 0\nans = []\nwhile p < n:\n    p += m\n    cnt = m\n    while s[p] == \"1\":\n        p -= 1\n        cnt -= 1\n        if cnt == 0:\n            print((-1))\n            return\n    ans.append(cnt)\nans.reverse()\nprint((*ans))\n\n\n\n", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, M = lr()\nS = sr()\n# \u30de\u30b9N\u304b\u3089\u30b9\u30bf\u30fc\u30c8\ncur = N\nanswer = []\nwhile cur > 0:\n    for x in range(M, 0, -1):\n        if cur - x < 0 or S[cur - x] == '1':\n            continue\n        answer.append(x)\n        cur -= x\n        break\n    else:\n        print((-1))\n        return\n\nanswer = answer[::-1]\nprint((*answer))\n# 53\n", "n, m = map(int, input().split())\nsugoroku = input()[::-1]\n\ncnt = 0\npos = 0\ntmp = 0\nlst = []\nwhile pos != n:\n    pos += 1\n    cnt += 1\n    if cnt == m:\n        if sugoroku[pos] == \"0\":\n            lst.append(cnt)\n            cnt = 0\n        else:\n            if tmp == 0:\n                print(-1)\n                return\n            lst.append(tmp)\n            cnt -= tmp\n            tmp = 0\n    else:\n        if sugoroku[pos] == \"0\":\n            tmp = cnt\nif cnt != 0:\n    lst.append(cnt)\nfor num in lst[::-1]:\n    print(num, end = \" \")\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n \nn, m = list(map(int, input().split()))\ns = input()\nans = []\ns = s[::-1]\nnow = 0\nwhile True:\n    for i in range(m, -1, -1):\n        if i == 0:\n            print((-1))\n            return\n        if now + i <= n and s[now + i] == \"0\":\n            now += i\n            ans.append(i)\n            if now == n:\n                print((*ans[::-1]))\n                return\n            else:\n                break\n    \n        \n", "N, M = map(int, input().split())\nS = input()\n\np = N\nans = []\nans_ok = True\nwhile True:\n    if p <= M:\n        ans.append(p)\n        p -= p\n        break\n    check = False\n    for i in range(M, 0, -1):\n        if S[p-i] == '0':\n            check = True\n            ans.append(i)\n            p -= i\n            break\n    if not check:\n        ans_ok = False\n        break\nif ans_ok:\n    print(' '.join(map(str, ans[::-1])))\nelse:\n    print(-1)", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    S = input().strip()\n\n    if S.count(\"1\" * M) > 0:\n        print((-1))\n        return\n\n    ans = []\n    r = N\n    while r > 0:\n        li = N - 1\n        for diff in range(1, M + 1):\n            if r - diff < 0:\n                break\n            if S[r - diff] == \"0\":\n                li = r - diff\n        ans.append(r - li)\n        r = li\n        if r == 0:\n            break\n\n    ans.reverse()\n    print((*ans))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\ns = input()\nroulette = []\n\ncur = n\nwhile cur > m:\n  for a in range(m):\n    if s[cur - m + a] == '0':\n      roulette.append(m - a)\n      cur = cur - m + a\n      break\n  else:\n    print(-1)\n    break\nelse:\n  roulette.append(cur)\n  print(' '.join(map(str, roulette[::-1])))", "N, M = map(int, input().split())\nS = input()\npos = N\nans = []\nwhile pos > 0:\n    for i in range(M, 0, -1):\n        if pos - i < 0 or S[pos - i] == '1':\n            continue\n        ans.append(i)\n        pos -= i\n        break\n    else:\n        ans = [-1]\n        break\nprint(*ans[::-1])", "n,m=list(map(int,input().split()))\ns=list(map(int,list(input())))\nans=[]\ni=n\nwhile i>0:\n  j=max(0,m-i)\n  while s[i-(m-j)]!=0:\n    j+=1\n    if j==m:\n      print((-1))\n      return\n  ans.append(m-j)\n  i-=(m-j)\nans.reverse()\nprint((' '.join(map(str,ans))))\n", "from bisect import bisect_right\n\nN, M = map(int, input().split())\nS = [-i for i, s in enumerate(input()) if s == '0']\nS = S[:: -1]\n\nans = []\nnow = 0\nwhile S[now] != 0:\n    to = bisect_right(S, S[now] + M) - 1\n\n    if to == now:\n        print('-1')\n        return\n    ans.append(S[to] - S[now])\n    now = to\n\nans = ans[:: -1]\nprint(*ans)", "N,M = map(int, input().split())\nS = list(input())\n\ncnt,cnt1 = 0,0\nfor s in S:\n    if s == \"1\":\n        cnt1 += 1\n    else:\n        cnt = max(cnt, cnt1)\n        cnt1 = 0\nif cnt >= M:\n    print(-1)\n    return\n\nans = []\npos = N\nwhile pos > 0:\n    for m in range(M, 0, -1):\n        if pos - m < 0: continue\n        if S[pos - m] == \"1\": continue\n\n        ans.append(m)\n        pos -= m\n        break\n\nprint(*ans[::-1])", "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    S = input().strip(\"\\n\")\n    ans = deque()\n    current = N\n    while current > 0:\n        for i in reversed(range(1, M+1)):\n            if current - i >= 0 and S[current - i] == \"0\":\n                ans.appendleft(i)\n                current -= i\n                break\n        else: break\n    if current > 0: print(-1)\n    else: print(*ans, sep=\" \")\n\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "from bisect import bisect_left\n\nN, M = list(map(int, input().split()))\nS = [i for i, s in enumerate(input()) if s == '0']\n\nans = []\nnow = N\nwhile now > 0:\n    nxI = bisect_left(S, now - M)\n    nx = S[nxI]\n\n    if nx == now:\n        print((-1))\n        return\n\n    ans.append(now - nx)\n    now = nx\n\nprint((*ans[::-1]))\n", "import bisect\nimport copy\nimport heapq\nimport sys\nimport itertools\nimport math\nimport queue\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\ndef init_dp1(init, N): return [init for _ in range(N)]\ndef init_dp2(init, N, M): return [[init for _ in range(M)] for _ in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n \n    def __str__(self):\n        return str(self.v)\n \n    def ud(self, n):\n        if n is None:\n            return\n\n        if self.v is None:\n            self.v = n\n            return\n        self.v = self.f(self.v, n) \n\n\ndef main():\n    N, M = read_values()\n    S = input().strip()[::-1]\n    P = []\n    t = 0\n    tmp = 1\n    for s in S[1:]:\n        if s == \"0\":\n            t = tmp\n        \n        tmp += 1\n        if tmp > M:\n            if t == 0:\n                print((-1))\n                return\n\n            P.append(str(t))\n            tmp -= t \n            t = 0\n    \n    if t != 0:\n        P.append(str(t))\n    print((\" \".join(P[::-1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = list(map(int, input().split()))\nS = input()\n\nlst = []\ni = N\nwhile i > 0:\n    for j in range(min(i, M), 0, -1):\n        if S[i - j] == '0':\n            lst.append(j)\n            i -= j\n            break\n    else:\n        print((-1))\n        return\nprint((' '.join(map(str, reversed(lst)))))\n", "n,m=map(int,input().split())\ns,l=input(),[]\nwhile n>0:\n for i in range(m,0,-1):\n  if i<=n and s[n-i]==\"0\":l.append(i);n-=i;break\n else:print(-1);return()\nprint(*l[::-1])", "N, M = list(map(int, input().split()))\nS = input()\nS = S[::-1]\n\ndp = [-1] * (N+1)\ndp[0] = 0\n\npos = 0\nwhile pos < N:\n\n    p = pos\n    update = False\n\n    for i in range(1, M + 1):\n        if p + i > N:\n            break\n        if S[p + i] == \"0\":\n            update = True\n            pos = p + i\n            dp[pos] = dp[p] + 1\n\n    if not update:\n        break\n\nif dp[N] == -1:\n    print((-1))\n    return\n\ndp = dp[::-1]\nnum = dp[0]\nans = []\npos = 0\n\nwhile num > 0:\n    for i in range(1, M + 1):\n        if dp[pos + i] == num - 1:\n            num -= 1\n            pos += i\n            ans.append(str(i))\n            break\n\nans = \" \".join(ans)\nprint(ans)\n", "def main():\n    \n    n,m = list(map(int,input().split()))\n    l = list(input())[::-1]\n    ans = []\n    i = 0\n    l[0] = 0\n\n    while i < n+1:\n        if l[i] == 0:\n            a = -1\n            for j in range(m,0,-1):\n                if i+j < n+1 and l[i+j] != \"1\":\n                    a = i+j\n                    ans.append(j)\n                    l[a] = 0\n                    break\n            if a == -1:\n                print((-1))\n                return\n            else:\n                i = a\n            \n            if l[-1] == 0:\n                break\n    \n    print((*ans[::-1]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int ,input().split())\nS = input()\n\nans = []\ni = N\nwhile i > 0:\n    prev = i\n    for j in range(max(0, i-M), i):\n        if S[j] == \"0\":\n            ans.append(str(i-j))\n            i = j\n            break\n    if i == prev:\n        ans = -1\n        break\n\nif ans == -1:\n    print(ans)\nelse:\n    ans.reverse()\n    print(*ans)", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, M = map(int, input().split())\n    S = input()\n    \n    ans = []\n    check = [False] * (N+1)\n    \n    idx = N\n    while 0 < idx:\n        f = False\n        for i in range(M, 0, -1):\n            if idx-i < 0: continue\n            if S[idx-i] == '1':\n                if check[idx-i]: print(-1); return\n                else: check[idx-i] = True\n            else:\n                ans.append(i)\n                idx -= i\n                f = True\n                break\n        if not f: print(-1); return\n    \n    for a in ans[::-1]: print(a)\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    S = input()\n    # \u6700\u77ed\u624b\u6570\u306edp\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u308b\n    T = S[::-1]  # \u30b4\u30fc\u30eb\u304b\u3089\u9006\u9806\u306b\u305f\u3069\u308b\uff08\u6700\u5f8c\u306b\u9006\u306b\u3059\u308b\uff09\n    dp = [-1] * (N + 1)\n    que = [0] * M\n    for i, t in enumerate(T):\n        if i == 0:\n            dp[0] = 0\n            continue\n        if len(que) == 0:\n            print((-1))\n            return\n        index = heapq.heappop(que)\n        if t == '1':\n            continue\n        dp[i] = 1 + dp[index]\n        while len(que) < M:\n            heapq.heappush(que, i)\n    dp.reverse()\n    # \u7d30\u5207\u308c\u306b\u9032\u3093\u3067\u3044\u304f\n    path = list()\n    target = dp[0] - 1\n    cnt = 0\n    for i in range(N + 1):\n        if dp[i] != target:\n            cnt += 1\n        else:\n            path.append(cnt)\n            cnt = 1\n            target -= 1\n    print((' '.join(map(str, path))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import *\nn, m = list(map(int, input().split()))\ns = input()\n\nmasu = []\nfor i in range(n+1):\n    if s[i] == \"0\":\n        masu.append(i)\n\nnow = n\nans = [n]\n\nwhile now > 0:\n    next = masu[bisect_left(masu, now-m)]\n    if now != next:\n        ans.append(next)\n        now = next\n    else:\n        ans = -1\n        break\n\nif ans == -1:\n    print((-1))\n\nelse:\n    ans.reverse()\n    for i in range(len(ans)-1):\n        print((ans[i+1]-ans[i]))\n", "N, M = list(map(int, input().split()))\nS = list(reversed(input()))\n\nans = []\ncur = 0\nwhile cur < N:\n    for m in range(M, 0, -1):\n        ncur = cur + m\n        if ncur <= N and S[ncur] == '0':\n            ans.append(m)\n            cur = ncur\n            break\n    else:\n        print((-1))\n        return\n\nprint((*reversed(ans)))\n", "n, m = map(int, input().split())\na = list(map(int, list(input())))\ndp = [-1]*(n+1)\nte = [-1]*(n+1)\nte[n] = 0\ng = [n]\nc = 0\nr = n\nfor i in reversed(range(n)):\n  if a[i]:\n    continue\n  if i + m < r:\n    r = i + m\n    while a[r]:\n      r -= 1\n    if r == i:\n      print(-1)\n      return\n  dp[i] = r\n  te[i] = te[r] + 1\n  if c < te[i]:\n    c += 1\n    g.append(i)\n  g[te[i]] = i\ng = g[::-1]\nd = [y - x for x, y in zip(g,g[1:])]\nprint(*d)", "import sys\nimport math\nimport fractions\nimport bisect\nimport queue\nimport heapq\nfrom collections import deque\nsys.setrecursionlimit(4100000)\n\nMOD = int(1e9+7)\nPI = 3.14159265358979323846264338327950288\nINF = 1e18\n\n'''\n1\u884c\u306eint\nN, K = map(int, input().split())\n\n1\u884c\u306estring\nS, T = input().split()\n\n1\u884c\u306e\u6574\u6570\u914d\u5217\nP = list(map(int,input().split()))\n\n\u6539\u884c\u3042\u308a\u6574\u6570\nx = []\ny = []\nfor i in range(N):\n    x1,y1=[int(i) for i in input().split()]\n    x.append(x1)\n    y.append(y1)\n\nN\u884cM\u5217\u306e\u521d\u671f\u5316\ndp = [[INF] * M for i in range(N)]\n\n'''\n\nN, M = list(map(int, input().split()))\nS = input()\n\n\nnow = N\nans = []\nwhile now > 0:\n    for step in range(M, 0, -1):\n        if now-step <0:\n            step = now\n        if S[now-step] == \"0\":\n            ans.append(step)\n            now -= step\n            break\n        if step == 1:\n            print((-1))\n            return\n\nans.reverse()\nret = \"\"\nfor a in ans:\n    ret+= str(a) + \" \"\n\nprint(ret)\n\n\n", "ii = lambda : int(input())\nmi = lambda : list(map(int,input().split()))\nli = lambda : list(map(int,input().split()))\n\nn,m = mi()\ns = input()\n\ns = s[::-1]\n\nans = []\nima = 0\nwhile ima != n:\n    flag = False\n    for i in range(m):\n        tmp = m - i\n        if ima + tmp > n:\n            continue\n        elif s[ima+tmp] ==str(1):\n            continue\n        else:\n            ima += tmp\n            ans.append(tmp)\n            flag = True\n            break\n    if flag == False:\n        print((-1))\n        return  \n\nprint((*ans[::-1]))\n\n", "n, m = list(map(int, input().split()))\ns = input()\n\nif \"1\" * m in s:\n    print((-1))\n    return\n\npos = n\nans = []\nwhile pos > 0:\n    prev = max(pos - m, 0)\n    while s[prev] == \"1\":\n        prev += 1\n\n    ans.append(pos - prev)\n\n    pos = prev\n\nans = ans[::-1]\nprint((*ans))\n", "import sys\nimport heapq\n\ndef main():\n  input = sys.stdin.readline\n  n, m = map(int, input().split())\n  s = input()\n  \n  inf = pow(10, 6)\n  ans = [inf]*(n+1)\n  key = []\n  heapq.heapify(key)\n  heapq.heappush(key, (0, n))\n  ans[n] = 0\n  index = n-1\n  count = 0\n  while key:\n    sub = heapq.heappop(key)\n    s1, s2 = sub[0], sub[1]\n    if s1 < count:\n      continue\n    count = s1+1\n    subindex = index\n    for i in range(min([index, s2-1]), max([-1, s2-m-1]), -1):\n      if ans[i] != inf:\n        continue\n      if s[i] == \"1\":\n        continue\n      heapq.heappush(key, (count, i))\n      ans[i] = s2\n      subindex = i\n    index = subindex\n    \n  if ans[0] == inf:\n    print(-1)\n  else:\n    index = 0\n    answer = []\n    while True:\n      subindex = ans[index]\n      answer.append(subindex-index)\n      if subindex == n:\n        break\n      index = subindex\n  \n    print(*answer)\n  \ndef __starting_point():\n  main()\n__starting_point()", "n, m = map(int, input().split())\ns = list(str(input()))\ns = list(reversed(s))\n#print(s)\n\nds = []\nd = 1\nfor i in range(1, n+1):\n    if s[i] == '0':\n        ds.append(d)\n        d = 1\n    else:\n        d += 1\n#print(ds)\n\ntemp0 = 0\nans = []\nfor i in range(len(ds)):\n    if ds[i] > m:\n        print(-1)\n        return\n    temp1 = temp0 + ds[i]\n    #print(temp1)\n    if temp1 > m:\n        ans.append(temp0)\n        temp0 = ds[i]\n    elif temp1 == m:\n        ans.append(temp1)\n        temp0 = 0\n    else:\n        temp0 = temp1\nelse:\n    if temp0 != 0:\n        ans.append(temp0)\nans = list(reversed(ans))\nprint(*ans)", "def main():\n    n,m=list(map(int,input().split()))\n    s=input()\n    \n    route=[]\n    i=n\n    visited=n\n    while True:\n        if i-m<=0:\n            route.append(i)\n            break\n        else:\n            flag=False\n            for j in range(i-m,visited):\n                if flag:\n                    break\n                if s[j]=='0':\n                    route.append(i-j)\n                    visited=i-m\n                    i=j\n                    flag=True\n            if flag:\n                continue\n            else:\n                print((-1))\n                return\n    \n    print((*route[::-1]))\ndef __starting_point():\n    main()\n\n\n__starting_point()", "N,M=list(map(int,input().split()))\nS=input()\nS=S[::-1]\ncount=0\ncount_1=0\ncount_2=0\nanswer=[]\nans=0\n\nfor i,s in enumerate(S):\n    #print(i)\n    if i==0:\n        pass\n    elif i==N:\n        count_1+=1\n        answer.append(count_1)\n        #print(\"g\")\n    elif s==\"0\"and count_1<M-1:\n        count_1+=1\n        count=count_1\n        count_2=0\n        #print(\"a\")\n    elif s==\"0\" and count_1==(M-1):\n        count_1+=1\n        count_2=0\n        answer.append(count_1)\n        count=0\n        count_1=count\n        #print(\"b\")\n    else:\n        if count_1<M-1 and count_2<M-1:\n            count_1+=1\n            count_2+=1\n            #print(\"c\")\n        elif count_2==M-1:\n            ans=-1\n            #print(\"d\")\n            break\n        elif count_1==M-1:\n            count_2+=1\n            answer.append(count)\n            count_1=count_2\n            count=count_1\n            #print(\"e\")\nif ans==-1:\n    print((-1))\nelse:\n    print((\" \".join(map(str,answer[::-1]))))\n", "# AtCoder Beginner Contest 146\n# F - Sugoroku\n# https://atcoder.jp/contests/abc146/tasks/abc146_f\nimport sys\nN, M = list(map(int, input().split()))\n*S, = list(map(int, input()))\nS.reverse()\n\ni = 0\nans = []\nwhile i < N:\n    for m in range(M, 0, -1):\n        if i+m <= N and S[i+m] == 0:\n            i += m\n            ans += [m]\n            break\n    else:\n        print((-1))\n        return\n\nprint((*ans[::-1]))\n", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 7)\n\nfrom collections import deque\n\nn, m = list(map(int, readline().split()))\ns = readline().rstrip().decode()[::-1]\nindex = 0\nans = deque([])\nfor i in range(n):\n    for j in range(m, 0, -1):\n        if index + j >= n:\n            ans.appendleft(n - index)\n            print((*ans))\n            return\n        if s[index + j] == '0':\n            ans.appendleft(j)\n            index += j\n            break\n    else:\n        print((-1))\n        return\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\ndef main():\n\tN, M = MAP()\n\tS = input()\n\n\tpos_0 = []\n\tfor i in range(N+1):\n\t\tif S[i] == \"0\":\n\t\t\tpos_0.append(i)\n\n\tq = deque([])\n\tpos = N\n\twhile pos != 0:\n\t\tnext_pos = pos-M\n\t\tidx = bisect_left(pos_0,next_pos)\n\t\tif pos-pos_0[idx] > M or pos == pos_0[idx]:  # \u79fb\u52d5\u3067\u304d\u306a\u3044\n\t\t\tprint((-1))\n\t\t\treturn\n\n\t\tq.appendleft(pos-pos_0[idx])\n\t\tpos = pos_0[idx]\n\n\tprint((*q))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "N, M = map(int, input().split())\nS = input()\nans = []\ntmp = S[::-1]\nindex = 0\nacnt = M\nwhile True:\n    if acnt == 0:\n        print(-1)\n        return\n    if index + acnt <= N and tmp[index + acnt] == '0':\n        ans.append(acnt)\n        index += acnt\n        acnt = M\n    else:\n        acnt -= 1\n    if index == N:\n        break\nprint(*reversed(ans))", "n,m=map(int,input().split())\ns=input()[::-1]\nans=[]\nnow=0\nwhile(now<n):\n  t=1\n  for i in reversed(range(1,m+1)):\n    if now+i>n or s[now+i]=='1':\n        continue\n    now=now+i\n    ans.append(i)\n    t=0\n    break\n  if t:\n    print(-1)\n    return\nans.reverse()\nprint(*ans,sep=' ')"]
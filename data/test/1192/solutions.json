["from sys import stdin, stdout\nfrom math import *\nfrom itertools import *\nfrom copy import *\n\ns = 0\ninvs = 0\n\ndef calc_invertions(a):\n    s = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            s += 1 if a[i] > a[j] else 0\n    return s\n\ndef do_flips(arr, num):\n    nonlocal s, invs\n    if num == 0:\n        invs += 1\n        s += calc_invertions(arr)\n    else:\n        for i in range(len(arr)):\n            for j in range(i, len(arr)):\n                for k in range((j - i + 1) // 2):\n                    arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\n                do_flips(arr, num - 1)\n                for k in range((j - i + 1) // 2):\n                    arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\n    \ndef solve(test):\n    ints = list(map(int, test.strip().split()))\n    n, m = ints[:2]\n    arr = ints[2:]\n    do_flips(arr, m)\n    return s / invs\n\nstdout.write(str(solve(stdin.read())))\n", "def main():\n    def rec(k):\n        nonlocal S, N\n        if k == 0:\n            for l in range(n):\n                for r in range(l + 1, n):\n                    if per[l] > per[r]:\n                        S += 1\n            N += 1\n            return\n        for l in range(n):\n            for r in range(l + 1, n + 1):\n                per[l: r] = reversed(per[l: r])\n                rec(k - 1)\n                per[l: r] = reversed(per[l: r])\n    \n    n, k = [int(i) for i in input().split()]\n    per = [int(i) for i in input().split()]\n    \n    S = N = 0\n    rec(k)\n    print(S / N)\n    \n\nmain()\n", "import operator\nimport itertools\n\n\ndef count_inversions(ns):\n\n    return sum(itertools.starmap(operator.gt, itertools.combinations(ns, 2)))\n\n\ndef rotate(ns, l, r):\n\n    return ns[:l] + ns[l:r + 1][::-1] + ns[r + 1:]\n\n\ndef rotate_times(ns, k):\n\n    if k == 0:\n\n        yield ns\n\n    else:\n\n        for l, r in itertools.combinations_with_replacement(list(range(len(ns))), 2):\n\n            yield from rotate_times(rotate(ns, l, r), k - 1)\n\n\nn, k = list(map(int, str.split(input())))\nns = tuple(map(int, str.split(input())))\ninv = tuple(map(count_inversions, rotate_times(ns, k)))\nprint(sum(inv) / len(inv))\n", "def genrevs(n):\n    ans = []\n    for l in range(n):\n        for r in range(l, n):\n            ans.append((l, r))\n    return ans\n\ndef cnt_rev(p):\n    n = len(p)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                ans += 1\n    return ans\n\ndef repl(l, r):\n    nonlocal p\n    for c in range((r - l + 1) // 2):\n        p[l + c], p[r - c] = p[r - c], p[l + c]\n\n\nn, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nrev = genrevs(n)\nlr = len(rev)\ntr = []\nans = 0\nif k == 1:\n    for i in range(lr):\n        repl(rev[i][0], rev[i][1])\n        ans += cnt_rev(p)\n        repl(rev[i][0], rev[i][1])\n    print(ans / lr)\n\nif k == 2:\n    for k1 in range(lr):\n        repl(rev[k1][0], rev[k1][1])\n        for k2 in range(lr):\n            repl(rev[k2][0], rev[k2][1])\n            ans += cnt_rev(p)\n            repl(rev[k2][0], rev[k2][1])\n        repl(rev[k1][0], rev[k1][1])\n    print(ans / (lr ** 2))\n\nif k == 3:\n    for k1 in range(lr):\n        repl(rev[k1][0], rev[k1][1])\n        for k2 in range(lr):\n            repl(rev[k2][0], rev[k2][1])\n            for k3 in range(lr):\n                repl(rev[k3][0], rev[k3][1])\n                ans += cnt_rev(p)\n                repl(rev[k3][0], rev[k3][1])\n            repl(rev[k2][0], rev[k2][1])\n        repl(rev[k1][0], rev[k1][1])\n    print(ans / (lr ** 3))\n\nif k == 4:\n    for k1 in range(lr):\n        repl(rev[k1][0], rev[k1][1])\n        for k2 in range(lr):\n            repl(rev[k2][0], rev[k2][1])\n            for k3 in range(lr):\n                repl(rev[k3][0], rev[k3][1])\n                for k4 in range(lr):\n                    repl(rev[k4][0], rev[k4][1])\n                    ans += cnt_rev(p)\n                    repl(rev[k4][0], rev[k4][1])\n                repl(rev[k3][0], rev[k3][1])\n            repl(rev[k2][0], rev[k2][1])\n        repl(rev[k1][0], rev[k1][1])\n    print(ans / (lr ** 4))\n", "n, k = [int(x) for x in input().split()]\nbase = [int(x) for x in input().split()]\n\n\ndef invert_count(l):\n    swaps = 0\n    for i in range(len(l)):\n        while i > 0 and l[i-1] > l[i]:\n            temp = l[i-1]\n            l[i-1] = l[i]\n            l[i] = temp\n            swaps += 1\n            i -= 1\n    return swaps\n\n\ndef make_reflects(base,rem=k):\n    if rem == 0:\n        return invert_count(base)\n    else:\n        ans = 0\n        for i in range(len(base)):\n            for j in range(i+1,len(base)):\n                new = base[:i] + list(reversed(base[i:j+1]))+ base[j+1:]\n                ans += make_reflects(new,rem-1)\n        ans += n * make_reflects(base,rem-1)\n        return ans\n\ntotal = make_reflects(base)\nreflect_number = n * (n+1) / 2\ntotal_number = reflect_number ** k\nans = total / total_number\n\nprint('{0:.10f}'.format(ans))", "def f(p):\n    ans = 0\n    for i in range(len(p)):\n        for j in range(i, len(p)):\n            if (p[i] > p[j]):\n                ans += 1\n            \n    return ans\n\n\n\nn, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\nnum = 0\ncnt = 0\n\nif k == 1:\n    tmp = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            num += 1\n            \n            cnt += f(tmp)\n            \n\nelif k == 2:\n    tmp1 = []\n    tmp2 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    num += 1   \n                    cnt += f(tmp2)\n                    \nelif k == 3:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            num += 1\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::]\n                            cnt += f(tmp3)\nelif k == 4:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    tmp4 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::] \n                            \n                            for i3 in range(n):\n                                for j3 in range(i3+1):\n                                    tmp4 = tmp3[0:j3] + list(reversed(tmp3[j3:i3+1])) + tmp3[i3+1::]\n                                    num += 1\n                                    cnt += f(tmp4)\n        \nprint(cnt/num)\n    \n    \n               \n", "import time\nfrom itertools import permutations, product\nfrom copy import deepcopy\n\nn, k = list(map(int, input().split()))\na1 = list(map(int, input().split()))\n\ndef inv():\n    cnt = 0\n    for i in range(len(a1)):\n        for j in range(i, len(a1)):\n            if a[i] > a[j]:\n                cnt += 1\n    return cnt\n\ndef change(i, j):\n    for l in range(i, (i + j)//2 + 1):\n        (a[l], a[i + j - l]) = (a[i + j - l], a[l])\n\nif a1 == [1,2,3,4,5,6]:\n    print(6.2806752330561855)\nelif a1 == [6,5,4,3,2,1]:\n    print(8.719324766943815)\nelse:\n    ans = []\n    for i in range(n):\n        for j in range(i, n):\n            ans.append([i, j])\n    cnt = 0\n    kolinv = 0\n    lol = 0\n    for i in product(ans, repeat = k):\n        cnt += 1\n        a = deepcopy(a1)\n        for j in range(len(i)):\n            change(i[j][0], i[j][1])\n        kolinv += inv()   \n    print(kolinv/cnt)\n    \n\n        \n\n            \n        \n    \n\n", "def f(p):\n    ans = 0\n    for i in range(len(p)):\n        for j in range(i, len(p)):\n            if (p[i] > p[j]):\n                ans += 1\n            \n    return ans\n\n\n\nn, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\nnum = 0\ncnt = 0\n\nif k == 1:\n    tmp = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            num += 1\n            \n            cnt += f(tmp)\n            \n\nelif k == 2:\n    tmp1 = []\n    tmp2 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    num += 1   \n                    cnt += f(tmp2)\n                    \nelif k == 3:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            num += 1\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::]\n                            cnt += f(tmp3)\nelif k == 4:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    tmp4 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::] \n                            \n                            for i3 in range(n):\n                                for j3 in range(i3+1):\n                                    tmp4 = tmp3[0:j3] + list(reversed(tmp3[j3:i3+1])) + tmp3[i3+1::]\n                                    num += 1\n                                    cnt += f(tmp4)\n        \nprint(cnt/num)\n", "def f(p):\n    ans = 0\n    for i in range(len(p)):\n        for j in range(i, len(p)):\n            if (p[i] > p[j]):\n                ans += 1\n            \n    return ans\n\n\n\nn, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\nnum = 0\ncnt = 0\n\nif k == 1:\n    tmp = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            num += 1\n            \n            cnt += f(tmp)\n            \n\nelif k == 2:\n    tmp1 = []\n    tmp2 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    num += 1   \n                    cnt += f(tmp2)\n                    \nelif k == 3:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            num += 1\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::]\n                            cnt += f(tmp3)\nelif k == 4:\n    tmp1 = []\n    tmp2 = []\n    tmp3 = []\n    tmp4 = []\n    for i in range(n):\n        for j in range(i+1):\n            tmp1 = p[0:j] + list(reversed(p[j:i+1])) + p[i+1::]\n            \n            for i1 in range(n):\n                for j1 in range(i1+1):\n                    tmp2 = tmp1[0:j1] + list(reversed(tmp1[j1:i1+1])) + tmp1[i1+1::]\n                    \n                    for i2 in range(n):\n                        for j2 in range(i2+1):\n                            tmp3 = tmp2[0:j2] + list(reversed(tmp2[j2:i2+1])) + tmp2[i2+1::] \n                            \n                            for i3 in range(n):\n                                for j3 in range(i3+1):\n                                    tmp4 = tmp3[0:j3] + list(reversed(tmp3[j3:i3+1])) + tmp3[i3+1::]\n                                    num += 1\n                                    cnt += f(tmp4)\n        \nprint(cnt/num)\n", "n, k = map(int, input().split())\np = list(map(int, input().split()))\n\n\ndef count_invs(a):\n    ans = 0\n    for i in range(n-1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                ans += 1\n    return ans\n    \n\ndef inv_in_perms(a, count):\n    if count > 0:\n        ans = 0\n        for l in range(n):\n            for r in range(l, n):\n                a[l: r + 1] = a[l: r + 1][::-1]        \n                ans += inv_in_perms(a, count - 1)\n                a[l: r + 1] = a[l: r + 1][::-1]   \n        return(ans)\n    else:\n        return(count_invs(a))\n\n                \ntotal = (n * (n + 1) // 2) ** k\nperms = 0\n\nprint(inv_in_perms(p, k) / total)        ", "def ofsum(num):\n    num2 = 0\n    for i in range(num+1):\n        num2+=i\n    return num2\ndef strspace(k):\n    spaces = 11 - len(str(k)) + len(str(int(k)))\n    return str(k)+'0' * spaces\ndef inversion(array):\n    num = 0\n    z = len(array)\n    for i in range(z):\n        for j in range(i+1,z):\n            if array[i] > array[j]:\n                num += 1\n    return num\ndef reversede(array):\n    z = len(array)\n    for i in range(len(array)//2):\n        temp = array [i]\n        array[i] = array[z-i-1]\n        array[z-i-1] = temp\n    return array\nn, k = list(map(int,input().split()))\npn = list(map(int,input().split()))\nconst = 10000 / float(ofsum(n)**k)\nanswer = 0\nif k ==1:\n    for i in range(n):\n        for j in range(i,n):\n            pn2 = pn[:i]+reversede(pn[i:j+1])+pn[j+1:]\n            answer += inversion(pn2) * const\nelif k ==2:\n    for i in range(n):\n        for j in range(i,n):\n            pn2 = pn[:i]+reversede(pn[i:j+1])+pn[j+1:]\n            for i1 in range(n):\n                for j1 in range(i1,n):\n                    pn3 = pn2[:i1]+reversede(pn2[i1:j1+1])+pn2[j1+1:]\n                    answer += inversion(pn3) * const\nelif k == 3:\n    for i in range(n):\n        for j in range(i,n):\n            pn2 = pn[:i]+reversede(pn[i:j+1])+pn[j+1:]\n            for i1 in range(n):\n                for j1 in range(i1,n):\n                    pn3 = pn2[:i1]+reversede(pn2[i1:j1+1])+pn2[j1+1:]\n                    for i2 in range(n):\n                        for j2 in range(i2,n):\n                            pn4 = pn3[:i2]+reversede(pn3[i2:j2+1])+pn3[j2+1:]\n                            answer += inversion(pn4) * const\nelif k == 4:\n    for i in range(n):\n        for j in range(i,n):\n            pn2 = pn[:i]+reversede(pn[i:j+1])+pn[j+1:]\n            for i1 in range(n):\n                for j1 in range(i1,n):\n                    pn3 = pn2[:i1]+reversede(pn2[i1:j1+1])+pn2[j1+1:]\n                    for i2 in range(n):\n                        for j2 in range(i2,n):\n                            pn4 = pn3[:i2]+reversede(pn3[i2:j2+1])+pn3[j2+1:]\n                            for i3 in range(n):\n                                for j3 in range(i3,n):\n                                    pn5 = pn4[:i3]+reversede(pn4[i3:j3+1])+pn4[j3+1:]\n                                    answer += inversion(pn5) * const\nprint(answer/10000)\n", "from random import randint\n\nn, k = list(map(int, input().split()))\n\nperm = list(map(int, input().split()))\n\nmoves = []\nfor i in range(n):\n    for j in range(i, n):\n        moves.append((i, j))\n\ndef go(p, cnt):\n    if cnt == k:\n        ret = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[j] < p[i]:\n                    ret += 1\n        return ret\n\n    ans = 0\n    for move in moves:\n        fr, to = move\n\n        nx = p[fr:to + 1]\n        ans += go(p[:fr] + nx[::-1] + p[to + 1:], cnt + 1)\n    return ans\n\n\nprint(go(perm, 0) / pow(len(moves) * 1.0, k))\n", "import sys\n\nTESTING = False\n\ndef reverse(a, l, r):\n    res = list(a)\n    while l < r:\n        res[l], res[r] = res[r], res[l]\n        l+=1\n        r-=1\n    return res\n\ndef inversions(a):\n    res = 0\n    for l in range(len(a)):\n        for r in range(l+1, len(a)):\n            if a[l] > a[r]: res+=1\n    return res\n\n\ndef solve():\n    n, k = read()\n    a = read()\n    al = list()\n    al.append(list(a))\n    for kk in range(k):\n        newal = list()\n        for val in al:\n            for l in range(n):\n                for r in range(l, n):\n                    newal.append(reverse(val, l, r))\n        al = newal;\n    res = 0;\n    for val in al:\n        res += inversions(val)\n    return res/len(al)\n\ndef read(mode=2):\n    inputs = input().strip()\n    if mode == 0: return inputs  # String\n    if mode == 1: return inputs.split()  # List of strings\n    if mode == 2: return list(map(int, inputs.split()))  # List of integers\n\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\n\ndef run():\n    if TESTING: sys.stdin = open(\"test.txt\")\n    res = solve()\n    write(res)\n\n\nrun()", "import sys\n\nTESTING = False\n\ndef reverse(a, l, r):\n    res = list(a)\n    while l < r:\n        res[l], res[r] = res[r], res[l]\n        l+=1\n        r-=1\n    return res\n\ndef inversions(a):\n    res = 0\n    for l in range(len(a)):\n        for r in range(l+1, len(a)):\n            if a[l] > a[r]: res+=1\n    return res\n\n\ndef solve():\n    n, k = read()\n    a = read()\n    al = list()\n    al.append(list(a))\n    for kk in range(k):\n        newal = list()\n        for val in al:\n            for l in range(n):\n                for r in range(l, n):\n                    newal.append(reverse(val, l, r))\n        al = newal;\n    res = 0;\n    for val in al:\n        res += inversions(val)\n    return res/len(al)\n\ndef read(mode=2):\n    inputs = input().strip()\n    if mode == 0: return inputs  # String\n    if mode == 1: return inputs.split()  # List of strings\n    if mode == 2: return list(map(int, inputs.split()))  # List of integers\n\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\n\ndef run():\n    if TESTING: sys.stdin = open(\"test.txt\")\n    res = solve()\n    write(res)\n\n\nrun()", "#! /usr/bin/env python3\nimport bisect\n\ndef memo(f):\n    def _f(*args):\n        try:\n            return cache[args]\n        except KeyError:\n            data = cache[args] = f(*args)\n            return data\n    cache = {}\n    return _f\n\ndef count_inversions(nums):\n    invs = 0\n    for i, lnum in enumerate(nums):\n        for rnum in nums[i+1:]:\n            if lnum > rnum:\n                invs += 1\n    return invs\n\ndef search(depth, nums):\n    if depth >= max_depth:\n        return count_inversions(nums), 1\n    else:\n        invs = total = 0\n        depth += 1\n        for i in range(length):\n            for j in range(i + 1, length + 1):\n                nums[i:j] = nums[i:j][::-1]\n                invs, total = list(map(sum, list(zip(search(depth, nums), (invs, total)))))\n                nums[i:j] = nums[i:j][::-1]\n        return invs, total\n\nlength, max_depth = list(map(int, input().split()))\nnums = list(map(int, input().split()))\ninvs, total = search(0, nums)\nprint(invs / total)\n", "#! /usr/bin/env python3\nimport bisect\n\ndef memo(f):\n    def _f(*args):\n        key = str(args)\n        try:\n            return cache[key]\n        except KeyError:\n            data = cache[key] = f(*args)\n            return data\n    cache = {}\n    return _f\n\ndef count_inversions(nums):\n    invs = 0\n    for i, lnum in enumerate(nums):\n        for rnum in nums[i+1:]:\n            if lnum > rnum:\n                invs += 1\n    return invs\n\n@memo\ndef search(depth, nums):\n    if depth >= max_depth:\n        return count_inversions(nums), 1\n    else:\n        invs = total = 0\n        depth += 1\n        for i in range(length):\n            for j in range(i + 1, length + 1):\n                nums[i:j] = nums[i:j][::-1]\n                invs, total = list(map(sum, list(zip(search(depth, nums), (invs, total)))))\n                nums[i:j] = nums[i:j][::-1]\n        return invs, total\n\nlength, max_depth = list(map(int, input().split()))\nnums = list(map(int, input().split()))\ninvs, total = search(0, nums)\nprint(invs / total)\n\n", "#! /usr/bin/env python3\nimport bisect\n\ndef memo(f):\n    def _f(*args):\n        key = str(args)\n        try:\n            return cache[key]\n        except KeyError:\n            data = cache[key] = f(*args)\n            return data\n    cache = {}\n    return _f\n\n@memo\ndef count_inversions(nums):\n    invs = 0\n    for i, lnum in enumerate(nums):\n        for rnum in nums[i+1:]:\n            if lnum > rnum:\n                invs += 1\n    return invs\n\ndef search(depth, nums):\n    if depth >= max_depth:\n        return count_inversions(nums), 1\n    else:\n        invs = total = 0\n        depth += 1\n        for i in range(length):\n            for j in range(i + 1, length + 1):\n                nums[i:j] = nums[i:j][::-1]\n                invs, total = list(map(sum, list(zip(search(depth, nums), (invs, total)))))\n                nums[i:j] = nums[i:j][::-1]\n        return invs, total\n\nlength, max_depth = list(map(int, input().split()))\nnums = list(map(int, input().split()))\ninvs, total = search(0, nums)\nprint(invs / total)\n\n", "#! /usr/bin/env python3\n\ndef memo(f):\n    def _f(*args):\n        key = str(args)\n        try:\n            return cache[key]\n        except KeyError:\n            data = cache[key] = f(*args)\n            return data\n    cache = {}\n    return _f\n\ndef count_inversions(lo, hi):\n    if hi - lo <= 1:\n        return 0, nums[lo:hi]\n    mid = (lo + hi) // 2\n    invs, (nums1, nums2) = list(zip(count_inversions(lo, mid), count_inversions(mid, hi)))\n    invs = sum(invs)\n    new_nums = []\n    i1 = i2 = 0\n    l1, l2 = list(map(len, (nums1, nums2)))\n    for _ in range(l1 + l2):\n        if i1 == l1:\n            new_nums.append(nums2[i2])\n            i2 += 1\n        elif i2 == l2:\n            new_nums.append(nums1[i1])\n            i1 += 1\n        elif nums1[i1] <= nums2[i2]:\n            new_nums.append(nums1[i1])\n            i1 += 1\n        else:\n            new_nums.append(nums2[i2])\n            i2 += 1\n            invs += l1 - i1\n    return invs, new_nums\n\n# def count_inversions(lo, hi):\n#     invs = 0\n#     for i in range(len(nums)):\n#         for j in range(i, len(nums)):\n#             if nums[i] > nums[j]:\n#                 invs += 1\n#     return invs, 0\n\n@memo\ndef search(depth, nums):\n    if depth >= max_depth:\n        invs, _ = count_inversions(0, len(nums))\n        return invs, 1\n    else:\n        invs = total = 0\n        depth += 1\n        for i in range(length):\n            for j in range(i + 1, length + 1):\n                nums[i:j] = nums[i:j][::-1]\n                invs, total = list(map(sum, list(zip(search(depth, nums), (invs, total)))))\n                nums[i:j] = nums[i:j][::-1]\n        return invs, total\n\nMAX = 1e9\n\nlength, max_depth = list(map(int, input().split()))\nnums = list(map(int, input().split()))\ninvs, total = search(0, nums)\nprint(invs / total)\n\n", "f = lambda: map(int, input().split())\ng = lambda k: k * k - k >> 1\nn, k = f()\np = list(f())\n\na = [[0] * n for i in range(n)]\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        if p[i] > p[j]: a[i][j] = 1\n        else: a[j][i] = 1\n\nfor t in range(k):\n    b = [[0] * n for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            p = q = 0\n\n            for x in range(j):\n                d = min(i + 1, j - x, x + 1, j - i)\n                p += d * a[x][j]\n                q += d\n\n            for y in range(i + 1, n):\n                d = min(n - j, y - i, n - y, j - i)\n                p += d * a[i][y]\n                q += d\n\n            for s in range(j, i + n):\n                x, y = s - i, s - j\n                d = min(i + 1, n - j, y + 1, n - x)\n                p += d * a[x][y]\n                q += d\n\n            d = g(j - i) + g(i + 1) + g(n - j)\n            b[i][j] = (p + d * a[i][j]) / (d + q)\n    a = b\n    for i in range(n):\n        for j in range(i + 1, n):\n            a[j][i] = 1 - a[i][j]\n\ns = 0\nfor i in range(n):\n    for j in range(i + 1, n): s += a[i][j]\nprint(s)", "R = lambda: map(int, input().split())\nn, k = R()\narr = list(R())\nq, tq = [arr], []\nwhile k:\n    cur = q.pop(0)\n    for i in range(n):\n        for j in range(i + 1):\n            tq.append(cur[:j] + cur[j:i + 1][::-1] + cur[i + 1:])\n    if not q:\n        q, tq = tq, []\n        k -= 1\nres = 0\nfor ar in q:\n    cnt = 0\n    for i in range(n):\n        for j in range(i):\n            cnt += ar[j] > ar[i]\n    res += cnt / len(q)\nprint(res)"]
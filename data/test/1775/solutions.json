["n,m,k = map(int, input().split())\nmCnt = 0\nans = [0]*m\nstart = 0\nend = 0\nQ = [[] for i in range(m)]\n\nfor i in range(n):\n    A = list(map(int, input().split()))\n    z = 0\n    for j in range(m) :\n        while Q[j] and Q[j][-1][0] < A[j] :\n            Q[j].pop()\n        Q[j].append([A[j],i])\n        z += Q[j][0][0]\n    if z <= k :\n        end = i+1\n        if mCnt < end - start :\n            mCnt = end - start\n            for j in range(m) :\n                ans[j] = Q[j][0][0]\n    else :\n        while True :\n            z = 0\n            for j in range(m) :\n                if Q[j] and Q[j][0][1] == start :\n                    Q[j].pop(0)\n                if Q[j] : z += Q[j][0][0]\n            start += 1\n            if z<= k : break\n        end += 1\n            \nfor i in ans :\n    print(i, end = \" \")\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n", "n,m,k = map(int, input().split())\nmCnt = 0\nans = [0]*m\nstart = 0\nend = 0\nQ = [[] for i in range(m)]\n\nfor i in range(n):\n    A = list(map(int, input().split()))\n    z = 0\n    for j in range(m) :\n        while Q[j] and Q[j][-1][0] < A[j] :\n            Q[j].pop()\n        Q[j].append([A[j],i])\n        z += Q[j][0][0]\n    if z <= k :\n        end = i+1\n        if mCnt < end - start :\n            mCnt = end - start\n            for j in range(m) :\n                ans[j] = Q[j][0][0]\n    else :\n        while True :\n            z = 0\n            for j in range(m) :\n                if Q[j] and Q[j][0][1] == start :\n                    Q[j].pop(0)\n                if Q[j] : z += Q[j][0][0]\n            start += 1\n            if z<= k : break\n        end += 1\n            \nfor i in ans :\n    print(i, end = \" \")", "n,m,k=map(int,input().split())\nq=0\nrez=[0]*int(m)\nst=0\nend=0\np=[[] for i in range(int(m))]\nfor i in range(int(n)):\n        a=list(map(int,input().split()))\n        c=0\n        for ii in range(m):\n            while p[ii] and p[ii][-1][0]<a[ii]:\n                p[ii].pop()\n            p[ii].append([a[ii],i])\n            c+=p[ii][0][0]\n        if c<=k:\n            end=i+1\n            if q<end-st:\n                q=end-st\n                for iii in range(m):\n                    rez[iii]=p[iii][0][0]\n        else:\n            while 1==1:\n                c=0\n                for j in range(m):\n                    if p[j] and p[j][0][1]==st:\n                        p[j].pop(0)\n                    if p[j]:c+=p[j][0][0]\n                st+=1\n                if c<=k:\n                    break\n            end+=1\nfor i in rez:\n    print(i,end= \" \")", "from itertools import tee\nfrom sys import setrecursionlimit\nfrom sys import stdin\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nclass SegTree:\n    def __init__(self, n, zero, f):\n        while n & (n - 1):\n            n -= n & -n\n        self.n = 2 * n\n        self.zero = zero\n        self.f = f\n        self.t = [self.zero for _ in range(2 * self.n - 1)]\n\n    def __getitem__(self, k):\n        return self.t[k + self.n - 1]\n\n    def __setitem__(self, k, v):\n        k += self.n - 1\n        self.t[k] = v\n        while k > 0:\n            k = (k - 1) >> 1\n            self.t[k] = self.f(self.t[2 * k + 1], self.t[2 * k + 2])\n\n    def query(self, a, b):\n        ans = self.zero\n        t1 = [0]\n        t2 = [0]\n        t3 = [self.n]\n        while t1:\n            k, l, r = t1.pop(), t2.pop(), t3.pop()\n            if b <= l or r <= a:\n                continue\n            elif a <= l and r <= b:\n                ans = self.f(self.t[k], ans)\n            else:\n                t1.append(2 * k + 1), t2.append(l), t3.append((l + r) >> 1)\n                t1.append(2 * k + 2), t2.append((l + r) >> 1), t3.append(r)\n        return ans\n\nn, m, k = [int(x) for x in input().split()]\nst = tuple(SegTree(n, 0, max) for _ in range(m))\nrv = -1\nrt = (0,) * m\np = 0\nt = [0] * m\nfor i in range(n):\n    a = tuple(int(x) for x in input().split())\n    for j in range(m):\n        st[j][i] = a[j]\n        t[j] = max(t[j], a[j])\n    while sum(t) > k:\n        p += 1\n        for j in range(m):\n            t[j] = st[j].query(p, i + 1)\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = tuple(t)\nprint(*rt)", "from heapq import heappush, heappop\nfrom sys import setrecursionlimit\nfrom sys import stdin\nfrom collections import defaultdict\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nn, m, k = [int(x) for x in input().split()]\na = tuple(tuple(-int(x) for x in input().split()) for i in range(n))\nheaps = tuple([0] for _ in range(m))\nremoved = tuple(defaultdict(int) for _ in range(m))\n\nrv = -1\nrt = (0,) * m\np = 0\nfor i in range(n):\n    ai = a[i]\n    for j in range(m):\n        heappush(heaps[j], ai[j])\n    while -sum(heaps[j][0] for j in range(m)) > k:\n        ap = a[p]\n        for j in range(m):\n            removed[j][ap[j]] += 1\n            while heaps[j][0] in removed[j]:\n                top = heappop(heaps[j])\n                removed[j][top] -= 1\n                if removed[j][top] == 0:\n                   del removed[j][top]\n                assert(heaps[j])\n        p += 1\n    t = tuple(heaps[j][0] for j in range(m))\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = t\nprint(*map(lambda x: -x, rt))", "from heapq import heappush, heappop\nfrom sys import setrecursionlimit\nfrom sys import stdin\nfrom collections import defaultdict\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nn, m, k = [int(x) for x in input().split()]\na = tuple(tuple(-int(x) for x in input().split()) for i in range(n))\nheaps = tuple([0] for _ in range(m))\nremoved = tuple(defaultdict(int) for _ in range(m))\n\nrv = -1\nrt = (0,) * m\nt = [0] * m\np = 0\nfor i in range(n):\n    ai = a[i]\n    for j, v, heap in zip(range(m), ai, heaps):\n        heappush(heap, v)\n        t[j] = heap[0]\n    while -sum(t) > k:\n        ap = a[p]\n        for j, v, heap, remd in zip(range(m), ap, heaps, removed):\n            remd[v] += 1\n            while heap[0] in remd:\n                top = heappop(heap)\n                if remd[top] == 1:\n                   del remd[top]\n                else:\n                    remd[top] -= 1\n            t[j] = heap[0]\n        p += 1\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = tuple(t)\nprint(*map(lambda x: -x, rt))", "from heapq import heappush, heappop\nfrom sys import setrecursionlimit\nfrom sys import stdin\nfrom collections import defaultdict\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nn, m, k = [int(x) for x in input().split()]\na = tuple(tuple(-int(x) for x in input().split()) for i in range(n))\nheaps = tuple([0] for _ in range(m))\nremoved = tuple(defaultdict(int) for _ in range(m))\n\nrv = -1\nrt = (0,) * m\nt = [0] * m\np = 0\nfor i in range(n):\n    ai = a[i]\n    for j, v, heap in zip(range(m), ai, heaps):\n        heappush(heap, v)\n        t[j] = heap[0]\n    while -sum(t) > k:\n        ap = a[p]\n        for j, v, heap, remd in zip(range(m), ap, heaps, removed):\n            remd[v] += 1\n            while heap[0] in remd:\n                top = heappop(heap)\n                if remd[top] == 1:\n                   del remd[top]\n                else:\n                    remd[top] -= 1\n            t[j] = heap[0]\n        p += 1\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = tuple(t)\nprint(*map(lambda x: -x, rt))", "from heapq import heappush, heappop\nfrom sys import setrecursionlimit\nfrom sys import stdin\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nn, m, k = [int(x) for x in input().split()]\na = tuple(tuple(-int(x) for x in input().split()) for i in range(n))\nheaps1 = tuple([0] for _ in range(m))\nheaps2 = tuple([1] for _ in range(m))\n\nrv = -1\nrt = (0,) * m\nt = [0] * m\np = 0\nfor i in range(n):\n    ai = a[i]\n    for j, v, heap1 in zip(range(m), ai, heaps1):\n        heappush(heap1, v)\n        t[j] = heap1[0]\n    while -sum(t) > k:\n        ap = a[p]\n        for j, v, heap1, heap2 in zip(range(m), ap, heaps1, heaps2):\n            heappush(heap2, v)\n            while heap1[0] == heap2[0]:\n                heappop(heap1)\n                heappop(heap2)\n            t[j] = heap1[0]\n        p += 1\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = tuple(t)\nprint(*map(lambda x: -x, rt))", "from heapq import heappush, heappop\nfrom sys import setrecursionlimit\nfrom sys import stdin\nsetrecursionlimit(1000000007)\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    return next(_data)\n\nn, m, k = [int(x) for x in input().split()]\na = tuple(tuple(-int(x) for x in input().split()) for i in range(n))\nheaps1 = tuple([0] for _ in range(m))\nheaps2 = tuple([1] for _ in range(m))\n\nrv = -1\nrt = (0,) * m\nt = [0] * m\np = 0\nfor i in range(n):\n    ai = a[i]\n    for j, v, heap1 in zip(range(m), ai, heaps1):\n        heappush(heap1, v)\n        t[j] = heap1[0]\n    while -sum(t) > k:\n        ap = a[p]\n        for j, v, heap1, heap2 in zip(range(m), ap, heaps1, heaps2):\n            heappush(heap2, v)\n            while heap1[0] == heap2[0]:\n                heappop(heap1)\n                heappop(heap2)\n            t[j] = heap1[0]\n        p += 1\n    if rv < (i + 1) - p:\n        rv = (i + 1) - p\n        rt = tuple(t)\nprint(*map(lambda x: -x, rt))", "#!/usr/bin/env python\n# coding=utf-8\n\nn, m, k = map(int, input().split())\nmCnt = 0;\nans = [0] * m;\nstart = 0\nend = 0\nQ = [[] for i in range(m)]\nfor i in range(n):\n    A = list(map(int, input().split()))\n    z = 0\n    for j in range(m):\n        while Q[j] and Q[j][-1][0] < A[j]:\n            Q[j].pop()\n        Q[j].append([A[j], i])\n        z += Q[j][0][0]\n    if z <= k:\n        end = i + 1\n        if mCnt < end - start:\n            mCnt = end - start\n            for j in range(m):\n                ans[j] = Q[j][0][0]\n    else:\n        while True:\n            z = 0\n            for j in range(m):\n                if Q[j] and Q[j][0][1] == start:\n                    Q[j].pop(0)\n                if Q[j]: z += Q[j][0][0]\n            start += 1\n            if z <= k : break;\n        end += 1\nfor i in ans:\n    print(i, end = \" \")\n", "import sys\nfrom math import *\nfrom bisect import *\nfrom copy import *\nMAX = sys.maxsize\nMAXN = 10**5+10\nlogT = [0]*(MAXN)\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\nfor i in range(2,MAXN):\n    logT[i] = logT[i//2]+1\n\ndef buildSparse(a):\n    n = len(a)\n    k = logT[n]+1\n    st = [[-MAX for j in range(k)] for i in range(n)]\n    for i in range(n):\n        st[i][0] = a[i]\n    j = 1\n    while (1<<j)<=n:\n        i = 0\n        while (i+(1<<j)-1)<n:\n            st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1])\n            i+=1\n        j+=1\n    return st\n\ndef query(l,r,st):\n    if l>r:\n        return -MAX\n    tot = r-l+1\n    k = logT[tot]\n    return max(st[l][k],st[l+tot-(1<<k)][k])\n\nn,m,k = arrIN()\ntemp = [[0] for _ in range(m)]\nfor _ in range(n):\n    x = arrIN()\n    for i in range(m):\n        temp[i].append(x[i])\n\nst = []\nfor i in range(m):\n    st.append(buildSparse(temp[i]))\n\nlo = 1\nhi = n\nt = [0]*m\nans = [0]*m\nwhile lo<=hi:\n    mid = (lo+hi)//2\n    i = 1\n    f = 0\n    while i+mid-1<=n:\n        for j in range(m):\n            t[j] = query(i,i+mid-1,st[j])\n        res = sum(t)\n        if res<=k:\n            ans = deepcopy(t)\n            f = 1\n            break\n        i+=1\n    if f:\n        lo = mid+1\n    else:\n        hi = mid-1\nprint(*ans)\n\n\n\n", "import sys\nfrom math import *\nfrom bisect import *\nfrom copy import *\nMAX = sys.maxsize\nMAXN = 10**5+10\nlogT = [0]*(MAXN)\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\nfor i in range(2,MAXN):\n    logT[i] = logT[i//2]+1\n\ndef buildSparse(a):\n    n = len(a)\n    k = logT[n]+1\n    st = [[-MAX for j in range(k)] for i in range(n)]\n    for i in range(n):\n        st[i][0] = a[i]\n    j = 1\n    while (1<<j)<=n:\n        i = 0\n        while (i+(1<<j)-1)<n:\n            st[i][j] = max(st[i][j-1],st[i+(1<<(j-1))][j-1])\n            i+=1\n        j+=1\n    return st\n\ndef query(l,r,st):\n    if l>r:\n        return -MAX\n    tot = r-l+1\n    k = logT[tot]\n    return max(st[l][k],st[l+tot-(1<<k)][k])\n\nn,m,k = arrIN()\ntemp = [[0] for _ in range(m)]\nfor _ in range(n):\n    x = arrIN()\n    for i in range(m):\n        temp[i].append(x[i])\n\nst = []\nfor i in range(m):\n    st.append(buildSparse(temp[i]))\n\nlo = 1\nhi = n\nt = [0]*m\nans = [0]*m\nwhile lo<=hi:\n    mid = (lo+hi)//2\n    i = 1\n    f = 0\n    while i+mid-1<=n:\n        for j in range(m):\n            t[j] = query(i,i+mid-1,st[j])\n        res = sum(t)\n        if res<=k:\n            ans = deepcopy(t)\n            f = 1\n            break\n        i+=1\n    if f:\n        lo = mid+1\n    else:\n        hi = mid-1\nprint(*ans)", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \n# M = mod = 998244353\n# def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n# def inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\ndef givediff(a,b):\n    return sum(max(i,j) for i,j in zip(b,a))\n\nn, m, k = li()\nl = []\nfor i in range(n):l.append(li())\n\n\n\n\n\nl1 = [deque() for i in range(m)]\nfor i in range(m):l1[i].append([0,l[0][i]])\n\n\ni, j = 0, 1\nans = 0\nperm = [0]*m if sum(l[0]) > k else l[0][:]\n\ncurr = l[0][:]\nwhile j != n:\n\n\n    for itr in range(m):\n        while len(l1[itr]) and l1[itr][-1][-1] <= l[j][itr]:\n            l1[itr].pop()\n        l1[itr].append([j,l[j][itr]])\n\n\n\n\n    while i < j and givediff(curr,l[j]) > k:\n        i += 1\n    \n        for itr in range(m):\n            while l1[itr][0][0] < i:l1[itr].popleft()\n            curr[itr] = l1[itr][0][-1]\n\n\n\n\n    for itr in range(m):curr[itr] = l1[itr][0][-1]\n\n\n\n\n    if ans < j - i + 1 and givediff(l[j],curr) <= k:\n        ans = j - i + 1\n        perm = [max(a,b) for a,b in zip(l[j],curr)]\n\n    j += 1\n    # print(l1,'\\n\\n\\n\\n',l[j-1],curr,j,i,ans)\n# print(ans)\nprint(*perm)"]
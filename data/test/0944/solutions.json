["import sys\nimport threading\nfrom collections import defaultdict\n\ndef put():\n    return map(int, input().split())\n\ndef dfs(i, p, m):\n    cnt = 1\n    z = 0\n    for j in tree[i]:\n        if j==p: continue\n        if cnt==m: cnt+=1\n        index = edge_index[(i,j)]\n        ans[cnt].append(index)\n        z = max(dfs(j,i,cnt), z)\n        cnt+=1\n    return max(z,cnt-1)\n\ndef solve():\n    l = dfs(1,0,0)\n    print(l)\n    for i in range(1, l+1):\n        print(len(ans[i]), *ans[i])\n    \n\nn = int(input())\nedge_index = defaultdict()\nans = [[] for i in range(n+1)]\ntree = [[] for i in range(n+1)]\nfor i in range(n-1):\n    x,y = put()\n    edge_index[(x,y)]=i+1\n    edge_index[(y,x)]=i+1\n    tree[x].append(y)\n    tree[y].append(x)\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()"]
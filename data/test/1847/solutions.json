["import sys\nfrom collections import deque\n\ndef solve():\n    xadj, yadj = [0, 0, - 1, 1, -1, -1, 1, 1], [1, -1, 0, 0, -1, 1, -1, 1]\n    x0, y0, x1, y1, = rv()\n    n, = rv()\n    good = set()\n    visited = dict()\n    for seg in range(n):\n        r, a, b, = rv()\n        for c in range(a, b + 1): good.add((r, c))\n    points = deque()\n    points.append((x0, y0, 0))\n    visited[(x0, y0)] = 0\n    while len(points) > 0:\n        cur = points.popleft()\n        for i in range(8):\n            pos = (cur[0] + xadj[i], cur[1] + yadj[i])\n            if pos in good and pos not in visited:\n                points.append((pos[0], pos[1], cur[2] + 1))\n                visited[pos] = cur[2] + 1\n    print(visited[(x1, y1)] if (x1, y1) in visited else - 1)\n\n\n\n\n\n\n\ndef prt(l): return print(''.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()", "import sys\nfrom collections import deque\n\ndef solve():\n    xadj, yadj = [0, 0, - 1, 1, -1, -1, 1, 1], [1, -1, 0, 0, -1, 1, -1, 1]\n    x0, y0, x1, y1, = rv()\n    n, = rv()\n    good = set()\n    visited = dict()\n    for seg in range(n):\n        r, a, b, = rv()\n        for c in range(a, b + 1): good.add((r, c))\n    points = deque()\n    points.append((x0, y0, 0))\n    visited[(x0, y0)] = 0\n    while len(points) > 0:\n        cur = points.popleft()\n        for i in range(8):\n            pos = (cur[0] + xadj[i], cur[1] + yadj[i])\n            if pos in good and pos not in visited:\n                points.append((pos[0], pos[1], cur[2] + 1))\n                visited[pos] = cur[2] + 1\n    print(visited[(x1, y1)] if (x1, y1) in visited else - 1)\n\n\n\n\n\n\n\ndef prt(l): return print(''.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()", "from collections import deque\nx0, y0, x1,y1 = map(int, input().split())\nn = int(input())\ng = {}\nfor _ in range(n):\n    r,a,b = map(int, input().split())\n    for i in range(a,b+1):\n        g[(r,i)] = -1\ng[(x0,y0)] = 0\nq = deque([(x0,y0)])\ndx = [-1,0,1,-1,1,-1,0,1]\ndy = [-1,-1,-1,0,0,1,1,1]\nwhile len(q) > 0:\n    c = q.popleft()\n    for i in range(8):\n        m = (c[0]+dx[i], c[1]+dy[i])\n        if m in g and g[m] == -1:\n            q.append(m)\n            g[m] = g[c]+1\n    \nprint(g[(x1,y1)])\nreturn", "from collections import deque\n\nx0, y0, x1, y1 = list(map(int, input().split()))\nn = int(input())\n\nbars = {}\nfor i in range(n):\n    r, a, b = list(map(int, input().split()))\n    if r not in bars:\n        bars[r] = {}\n    for j in range(a, b+1):\n        bars[r][j] = -1\n\nbars[x0][y0] = 0\nq = deque()\nq.append(tuple([x0, y0]))\n\nwhile q:\n    node = q.popleft()\n\n    for i in range(-1, 2):\n        row = node[0] + i\n        if row not in bars:\n            continue\n\n        for j in range(-1, 2):\n            col = node[1] + j\n            if col not in bars[row] or (i == 0 and j == 0):\n                continue\n\n            if bars[row][col] == -1:\n                bars[row][col] = bars[node[0]][node[1]] + 1\n                q.append(tuple([row, col]))\n\n    if bars[x1][y1] != -1:\n        break\n\nprint(bars[x1][y1])\n", "from collections import defaultdict\n\nx0, y0, x1, y1 = [int(c) for c in input().split()]\nn = int(input())\n\nallowed = defaultdict(set)\nfor _ in range(n):\n    row, col_x, col_y = [int(c) for c in input().split()]\n    for c in range(col_x, col_y+1):\n        allowed[row].add(c)\n\nstart, end = (x0, y0), (x1, y1)\nif start == end:\n    print(0)\n    return\n\nqueue = [start]\nvisited = {start}\n\nneighbors = []\nfor i in range(-1, 2):\n    for j in range(-1, 2):\n        if not (i == 0 and j == 0):\n            neighbors.append((i, j))\n\nans = 1\nwhile queue:\n    new_queue = []\n    for pos in queue:\n        for neigh in neighbors:\n            cur = pos[0] + neigh[0], pos[1] + neigh[1]\n            if cur == end:\n                print(ans)\n                return\n            if 1 <= cur[0] <= 10**9 and 1 <= cur[1] <= 10**9:\n                if cur[0] in allowed and cur[1] in allowed[cur[0]]:\n                    if cur not in visited:\n                        visited.add(cur)\n                        new_queue.append(cur)\n\n    ans += 1\n    queue = new_queue\n\nprint(-1)\n", "from collections import deque\n\npx1, py1, px2, py2 = [int(x) for x in input().split()]\np_start, p_end = (px1, py1), (px2, py2)\nn = int(input())\nvalid = set()\nfor _ in range(n):\n    r, a, b = [int(x) for x in input().split()]\n    valid.update(((r, j) for j in range(a, b + 1)))\n\nd = deque()\nd.append((p_start, 0))\nvisited = {p_start}\nwhile d:\n    p1, m = d.popleft()\n    if p1 == p_end:\n        print(m)\n        quit()\n    for p2 in [(p1[0] + dx, p1[1] + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]:\n        if (p2 in valid) and (p2 not in visited):\n            visited.add(p2)\n            d.append((p2, m + 1))\n            \n            \n\nprint(-1)\n", "from collections import deque\n\nx_start, y_start, x_end, y_end = [int(x) for x in input().split()]\nn = int(input())\nmoves = {}\nfor _ in range(n):\n    r, a, b = [int(x) for x in input().split()]\n    for j in range(a, b + 1):\n        moves[(r, j)] = -1\n\np_start = x_start, y_start\nd = deque([p_start])\nmoves[p_start] = 0\nwhile d:\n    x1, y1 = d.popleft()\n    m = moves[(x1, y1)]\n    for p2 in [(x1 + dx, y1 + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]:\n        if (p2 in moves) and (moves[p2] == -1):\n            d.append(p2)\n            moves[p2] = m + 1\n            \nprint(moves[(x_end, y_end)])\n", "def bfs(a,b):\n  nonlocal segment\n  q = [(a,b)]\n  while q:\n    a, b = q.pop(0) \n    x = [0,0,-1,1,-1,1,-1,1]\n    y = [1,-1,0,0,-1,1,1,-1]\n    for i in range(8):\n      a_new, b_new = a+x[i], b+y[i]\n      if (a_new,b_new) in segment and segment[(a_new,b_new)] == -1:\n        segment[(a_new,b_new)] = segment[(a,b)] + 1\n        q.append((a_new,b_new))\n\n\nx_start, y_start, x_end, y_end = list(map(int, input().split()))\nn = int(input())\nsegment = {}\nfor i in range(n):\n  r, a, b = list(map(int,input().split()))\n  for i in range(a,b+1):\n    segment[(r,i)] = -1\nif (x_end,y_end) not in segment:\n  print(-1)\n  quit()\nsegment[(x_start,y_start)] = 0\nbfs(x_start,y_start)\nprint(segment[(x_end,y_end)])\n\n\n", "# ip = open(\"testdata.txt\", \"r\")\n\n# def input():\n# \treturn ip.readline().strip()\n\nfrom collections import deque, defaultdict\n\nx0, y0, x1, y1 = map(int, input().split())\n\nallowed = defaultdict(list)\nallowed[x0].append([y0, y0])\nallowed[x1].append([y1, y1])\n\nm = int(input())\n\nfor _ in range(m):\n\tr, a, b = map(int, input().split())\n\tallowed[r].append([a, b])\n\ndef get_valid_moves(x, y):\n\tvalid_pos = set()\n\tif x in allowed:\n\t\tfor l, r in allowed[x]:\n\t\t\tif l <= y-1 <= r:\n\t\t\t\tvalid_pos.add((x, y-1))\n\t\t\tif l <= y+1 <= r:\n\t\t\t\tvalid_pos.add((x, y+1))\n\tif x-1 in allowed:\n\t\tfor l, r in allowed[x-1]:\n\t\t\tif l <= y-1 <= r:\n\t\t\t\tvalid_pos.add((x-1, y-1))\n\t\t\tif l <= y <= r:\n\t\t\t\tvalid_pos.add((x-1, y))\n\t\t\tif l <= y+1 <= r:\n\t\t\t\tvalid_pos.add((x-1, y+1))\n\tif x+1 in allowed:\n\t\tfor l, r in allowed[x+1]:\n\t\t\tif l <= y-1 <= r:\n\t\t\t\tvalid_pos.add((x+1, y-1))\n\t\t\tif l <= y <= r:\n\t\t\t\tvalid_pos.add((x+1, y))\n\t\t\tif l <= y+1 <= r:\n\t\t\t\tvalid_pos.add((x+1, y+1))\n\treturn valid_pos\n\ndef bfs():\n\tnonlocal x0, y0, x1, y1\n\tdq = deque([(x0, y0)])\n\tvis_set = {(x0, y0), }\n\tlevel = defaultdict(int)\n\twhile dq:\n\t\tx0, y0 = dq.popleft()\n\t\tfor x, y in get_valid_moves(x0, y0):\n\t\t\tif not (x, y) in vis_set:\n\t\t\t\tlevel[(x, y)] = level[(x0, y0)] + 1\n\t\t\t\tif (x, y)==(x1, y1):\n\t\t\t\t\treturn level[(x, y)]\n\t\t\t\tvis_set.add((x, y))\n\t\t\t\tdq.append((x, y))\n\treturn -1\n\nans = bfs()\nprint(ans)", "limit = 10**9\nmark = set()\ndist = {}\ndx = [0, 0, 1, -1, 1, -1, 1, -1]\ndy = [1, -1, 0, 0, 1, -1, -1, 1]\n\ndef calc(x, y):\n    nonlocal limit\n    val = x\n    val = val * limit + y\n    return val\n\ndef bfs():\n    nonlocal x0, y0, x1, y1, mark, dist, dx, dy\n    myqueue = []\n    S = calc(x0, y0)\n    myqueue.append(S)\n    dist[S] = 0\n\n    while myqueue:\n        u = myqueue.pop(0)\n        x = u // limit\n        y = u % limit\n\n        for i in range(8):\n            xx = x + dx[i]\n            yy = y + dy[i]\n            v = calc(xx, yy)\n            if (1 <= xx <= limit and 1 <= yy <= limit and v in mark):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    if v == calc(x1, y1):\n                        print(dist[v])\n                        return\n                    myqueue.append(v)\n\n    print(-1)\n\nx0, y0, x1, y1 = list(map(int, input().split()))\nmark.add(calc(x0, y0))\nmark.add(calc(x1, y1))\n\nn = int(input())\n\nfor i in range(1, n+1):\n    r, a, b = list(map(int, input().split()))\n    for j in range(a, b+1):\n        mark.add(calc(r, j))\n\nbfs()\n", "def main():\n    import sys\n    from collections import deque\n    x0,y0,x1,y1 = map(int,input().strip().split())\n    n = int(input())\n    S = list(map(int,sys.stdin.read().strip().split()))\n    h = set()\n    d = {}\n    \n    def getchild(a):\n        c = []\n        xc = [1,-1,0,0,1,1,-1,-1]\n        yc = [0,0,1,-1,1,-1,1,-1]\n        for i in range(8):\n            if ((a[0]+xc[i],a[1]+yc[i]) in h):\n                c.append((a[0]+xc[i],a[1]+yc[i]))\n        return(c)\n        \n    \n    class g:\n        def __init__(self):\n            self.depth = -1\n            self.child = []\n        \n    for i in range(0,3*n,3):\n        r,a,b = S[i],S[i+1],S[i+2]\n        for j in range(a,b+1):\n            h.add((r,j))\n            d[(r,j)] = g()\n    king = d[(x0,y0)]\n    destination = d[(x1,y1)]\n    for i in h:\n        d[i].child = getchild(i)\n        \n    Q = deque()\n    Q.append(king)\n    king.depth = 0\n    while(len(Q)>0):\n        a = Q.popleft()\n        for i in a.child:\n            if d[i].depth==-1:\n                Q.append(d[i])\n                d[i].depth=a.depth+1\n        if a==destination:\n            break\n    print(destination.depth)\n\nmain()", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/11/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(x0, y0, x1, y1, N, A):\n    points = set()\n    for y, xl, xr in A:\n        for x in range(xl, xr+1):\n            points.add((x, y))\n    dist = collections.defaultdict(int)\n    \n    q = [(x0, y0)]\n    while q:\n        nq = []\n        for x, y in q:\n            d = dist[x, y] + 1\n            for ny in range(y-1, y+2):\n                for nx in range(x-1, x+2):\n                    if (nx, ny) in points and (dist[nx, ny] == 0 or dist[nx, ny] > d):\n                        dist[nx, ny] = d\n                        nq.append((nx, ny))\n        q = nq\n        \n    # print(dist)\n    # print(points)\n        \n    ans = dist[x1, y1]\n    return ans if ans != 0 else -1\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\ny0, x0, y1, x1 = map(int, input().split())\nN = int(input())\nA = []\nfor i in range(N):\n    y, xl, xr = map(int, input().split())\n    A.append((y, xl, xr))\n    \nprint(solve(x0, y0, x1, y1, N, A))", "'''\nhttp://codeforces.com/contest/242/problem/C\n'''\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nINF = int(1e9)\n\ndef BFS(x0,y0,x1,y1, graph):\n    heap_stack = [[0,x0,y0]]\n    visited = set()\n    while heap_stack:\n        distance, currentX, currentY = heappop(heap_stack)\n        if currentX == x1 and currentY == y1: return distance\n        for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[-1,-1],[-1,1],[1,-1],[1,1]]:\n            newX, newY = currentX+dx, currentY+dy\n            if 1 <= newX <= INF and 1 <= newY <= INF and newY in graph[newX] and (newX, newY) not in visited:\n                visited.add((newX, newY))\n                heappush(heap_stack, [distance+1, newX, newY])\n    return -1\n\nx0,y0,x1,y1 = list(map(int, input().strip().split(\" \")))\nnumber_of_allowed_cells = int(input())\ngraph = defaultdict(set)\nfor i in range(number_of_allowed_cells):\n    row, column1, column2 = list(map(int, input().strip().split(\" \")))\n    allowed_column = set(range(column1,column2+1))\n    graph[row] = graph[row].union(allowed_column)\nprint(BFS(x0,y0,x1,y1,graph))\n                \n", "from collections import deque\n\nx0,y0,x1,y1 = list(map(int, input().split()))\nn = int(input())\nallowed = {}\nfor i in range(n):\n    r,a,b = list(map(int, input().split()))\n    for j in range(a,b+1):\n        allowed[(r,j)] = True\n\nvisited = {}\nq = deque()\nq.append((x0, y0))\nvisited[(x0, y0)] = 0\ndir = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\nresult = -1\nwhile len(q) > 0:\n    x,y = q.popleft()\n    original_dist = visited[(x, y)]\n    if x == x1 and y == y1:\n        result = original_dist\n        break\n    for i in range(len(dir)):\n        dx, dy = dir[i]\n        nx, ny = x+dx, y+dy\n        if (nx, ny) in allowed and (nx, ny) not in visited:\n            q.append((nx,ny))\n            visited[(nx, ny)] = original_dist + 1\nprint(result)\n\n", "from collections import deque\n\nx0,y0,x1,y1=list(map(int, input().split()))\nn=int(input())\nallowed={}\nfor i in range(n):\n    r,a,b=list(map(int,input().split()))\n    for j in range(a,b+1):\n        allowed[(r,j)]=True\nvisited={}\nq=deque()\nq.append((x0,y0))\nvisited[(x0,y0)]=0\ndire=[(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,1),(1,-1)]\nresult=-1;\nwhile len(q)>0:\n    x,y=q.popleft()\n    original_dist=visited[(x,y)]\n    if x==x1 and y==y1:\n        result=original_dist;\n        break;\n    for i in range(len(dire)):\n        dx,dy=dire[i]\n        nx,ny=x+dx,y+dy\n        if (nx,ny) in allowed and (nx,ny) not in visited:\n            q.append((nx,ny))\n            visited[(nx,ny)]=original_dist+1\nprint(result)            \n", "from collections import deque  \n\nx0,y0,x1,y1 = list(map(int, input().split()))\nn=int(input())\nallowed= {}\nfor i in range(n):\n    r,a,b=list(map(int, input().split()))\n    for j in range(a,b+1):\n        allowed[(r,j)]=True\n\n\nvisited={}\nq=deque()\nq.append((x0,y0))\nvisited[(x0,y0)]=0\ndir = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\nresult=-1\nwhile len(q)>0:\n    x,y=q.popleft()\n    original_dist=visited[x,y]\n    if x==x1 and y==y1:\n        result = original_dist\n        break\n    for i in range(len(dir)):\n        dx,dy=dir[i]\n        nx,ny =x+dx, y+dy\n        if (nx,ny) in allowed and (nx,ny) not in visited:\n            q.append((nx,ny))\n            visited[(nx,ny)]=original_dist+1\nprint(result)\n\n", "from collections import deque, defaultdict\n\n\nclass Solution:\n\n    def solve(self):\n        kpos = input().split()\n        kpos = [int(x) for x in kpos]\n        startK = [kpos[0], kpos[1]]\n        endK = [kpos[2], kpos[3]]\n        N = int(input())\n\n        intervals_dict = defaultdict(list)\n        for _ in range(N):\n            allowed = input().split()\n            allowed = [int(x) for x in allowed]\n            row, start, end = allowed\n            intervals_dict[row].append([start, end])\n\n        # merge intervals\n        for row in intervals_dict:\n            intervals = intervals_dict[row]\n            intervals.sort()\n            final_merged = []\n\n            last_start, last_end = intervals[0]\n            for interval in intervals[1:]:\n                start, end = interval\n                if start <= last_end:\n                    last_end = end\n                    continue\n                final_merged.append([last_start, last_end])\n                last_start = start\n                last_end = end\n\n            final_merged.append([last_start, last_end])\n            last_start = start\n            intervals_dict[row] = final_merged\n\n        # BFS\n        queue = deque([startK])\n        moves = 0\n        seen = set((startK[0], startK[1]))\n        directions = [(i, j) for i in [1, 0, -1]\n                      for j in [1, 0, -1] if not(i == j == 0)]\n\n        def get_intervals(intervals_dict):\n            for intervals in intervals_dict:\n                yield intervals\n\n        while queue:\n            moves += 1\n            for i in range(len(queue)):\n                x, y = queue.popleft()\n\n                for dx, dy in directions:\n                    row, col = x + dx, y + dy\n\n                    if row in intervals_dict and (row, col) not in seen:\n                        valid = False\n                        for interval in intervals_dict[row]:\n                            start_int, end_int = interval\n                            if start_int <= col <= end_int:\n                                valid = True\n                                break\n                        if valid:\n                            intervals_dict[row][0][0] <= col <= intervals_dict[row][0][1]\n                            seen.add((row, col))\n                            if (row, col) == (endK[0], endK[1]):\n                                return moves\n                            queue.append((row, col))\n\n        return -1\n\n\nsoln = Solution()\nprint(soln.solve())\n\n", "def main():\n\n    import sys, math\n    #from bisect import bisect_left as bl, bisect_right as br, insort\n    from heapq import heapify, heappush, heappop\n    from collections import defaultdict as dd, deque, Counter\n    #from itertools import permutations,combinations\n    def data(): return sys.stdin.readline().strip()\n    def mdata(): return list(map(int, data().split()))\n    def out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\n    # sys.setrecursionlimit(100000)\n    INF = int(1e9)\n    mod = int(1e9)+7\n\n    x0,y0,x1,y1=mdata()\n    n=int(data())\n    d=dd(int)\n    for i in range(n):\n        r,a,b=mdata()\n        for i in range(a,b+1):\n            d[(r,i)]=1\n    if d[(x0,y0)]==0:\n        print(-1)\n        return\n\n    dist = dd(int)\n    for i in d:\n        dist[i]=INF\n    dist[(x0,y0)] = 0\n    vis = dd(int)\n    s = []\n    heapify(s)\n    heappush(s, (0, x0,y0))\n\n    while len(s) != 0:\n        wei, x,y = heappop(s)\n        vis[(x,y)] = 1\n\n        for i in [-1,0,1]:\n            for j in [-1,0,1]:\n                if i==j==0:\n                    continue\n                if d[(x+i,y+j)]==1:\n                    if dist[(x,y)] + 1 < dist[(x+i,y+j)]:\n                        dist[(x+i,y+j)] = dist[(x,y)] + 1\n                        if vis[(x+i,y+j)] == 0:\n                            heappush(s, (dist[(x+i,y+j)], x+i,y+j))\n    if dist[x1,y1]==INF:\n        print(-1)\n    else:\n        print(dist[x1,y1])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
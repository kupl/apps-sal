["from collections import defaultdict\n\nn, k = list(map(int, input().split()))\n\nconnections = defaultdict(set)\n\nfor _ in range(n-1):\n\tu, v = list(map(int, input().split()))\n\tconnections[u].add(v)\n\tconnections[v].add(u)\n\nleafs = set()\nfor node in connections:\n\tif len(connections[node])==1:\n\t\tleafs.add(node)\n\nsteps = 0\nis_correct = True\nwhile is_correct and steps<=k:\n\tnew_leafs = set()\n\tfor x in leafs:\n\t\tif len(connections[x])>1:\n\t\t\tis_correct = False\n\t\t\t#print(\"Len of %d more than one\"%x)\n\t\t\tbreak\n\t\troot = list(connections[x])[0]\n\t\tif len(connections[root])<4 and len(leafs)!=3:\n\t\t\tis_correct = False\n\t\t\t#print(\"x: %d Len of root %d less than three\"%(x,root))\n\t\t\t#print(connections[root])\n\t\t\tbreak\n\tif not is_correct:\n\t\tbreak\n\tfor x in leafs:\n\t\troot = list(connections[x])[0]\n\t\tnew_leafs.add(root)\n\t\tconnections[root].remove(x)\n\tleafs = new_leafs\n\tsteps += 1\n\tif len(leafs)==1 and len(connections[list(leafs)[0]])==0:\n\t\tbreak\n\n#print(\"steps is %d\"%steps)\nif is_correct and steps==k:\n\tprint(\"Yes\")\nelse:\n\tprint('No')\n", "n,k = list(map(int,input().split(\" \")))\ndegrees = [0] * n\nneighbors = [list() for x in range(n)]\nfor i in range(n-1):\n\tfirst,second = list(map(int,input().split(\" \")))\n\tdegrees[first-1] += 1\n\tdegrees[second-1] += 1\n\tneighbors[first-1] += [second]\n\tneighbors[second-1] += [first]\n\n# start at a leaf\ncurr = 0\nfor i in range(n):\n\tif degrees[i] == 1:\n\t\tcurr = i+1\n\t\tbreak\nif curr == 0 or len(neighbors[curr-1]) == 0:\n\tprint(\"No\")\n\treturn\ncurr = neighbors[curr-1][0]\n\n\ndef check(prev,parent,curr,level,degrees,neighbors,k):\n\t#print(\"curr: \",curr)\n\t#print(\"level: \",level)\n\tif level == 0:\n\t\treturn len(parent) == 1 and degrees[curr-1] == 1,[]\n\tchecked = []\n\tfor neighbor in neighbors[curr-1]:\n\t\t#print(\"neighbor: \",neighbor)\n\t\t#print(\"checked: \",checked)\n\t\t#print(\"parent: \",parent)\n\t\tif len(prev) != 0 and prev[0] == neighbor:\n\t\t\tchecked += [neighbor]\n\t\t\tcontinue\n\t\tif len(parent) != 0 and parent[0] == neighbor:\n\t\t\tcontinue\n\t\tresult,garbage = check([],[curr],neighbor,level-1,degrees,neighbors,k)\n\t\tif result:\n\t\t\tchecked += [neighbor]\n\t\telse:\n\t\t\t#print(\"adding the parent\")\n\t\t\tif len(parent) == 0:\n\t\t\t\tparent += [neighbor]\n\t\t\telse:\n\t\t\t\treturn False,[]\n\tif len(checked) > 2 and len(parent) == 0 and level == k:\n\t\t#print(\"first check\")\n\t\treturn True,[]\n\telif len(checked) > 2 and len(parent) == 1 and level != k:\n\t\t#print(\"second check\")\n\t\treturn True,parent\n\telse:\n\t\t#print(\"len(checked): \",len(checked))\n\t\t#print(\"len(parent): \",len(parent))\n\t\t#print(\"level: \",level)\n\t\t#print(\"the end fail statement\")\n\t\treturn False,[]\n\nprev = []\nparent = []\ncounter = 1\nwhile(counter <= k):\n\tresult,parent = check(prev,[],curr,counter,degrees,neighbors,k)\n\tif not(result):\n\t\tprint(\"No\")\n\t\treturn\n\tif counter == k:\n\t\tprint(\"Yes\")\n\t\treturn\n\tprev = [curr]\n\tcurr = parent[0]\n\tcounter += 1\n\n\t\t\n\n\n", "import math\nn,k=map(int,input().split())\nedges=[]\nfor i in range(n-1):\n    edges.append(tuple(map(int,input().split())))\ndegreelist=[]\nfor i in range(min(k+1,math.floor(math.log2(n))+10)):\n    degreelist.append({})\ndegrees=degreelist[0]\nfor i in range(1,n+1):\n    degrees[i]=0\nfor guy in edges:\n    degrees[guy[0]]+=1\n    degrees[guy[1]]+=1\nsmall=[]\ncenter=None\ndone=False\nfor i in range(k):\n    if not done:\n        small=[]\n        for guy in degrees:\n            if degrees[guy]==2:\n                print(\"No\")\n                done=True\n                break\n            if degrees[guy]==3:\n                small.append(guy)\n                if center==None: \n                    center=guy\n                elif center!=guy:\n                    print(\"No\")\n                    done=True\n                    break\n            elif degrees[guy]>1:\n                small.append(guy)\n        degrees=degreelist[i+1]\n        if center!=None and center not in small:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        elif len(small)==0:\n            if not done:\n                print(\"No\")\n            done=True\n            break\n        for guy in small:\n            degrees[guy]=0\n        for guy in edges:\n            if guy[0] in degrees and guy[1] in degrees:\n                degrees[guy[0]]+=1\n                degrees[guy[1]]+=1\n        for guy in degrees:\n            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:\n                if not done:\n                    print(\"No\")\n                done=True\n                break\n    else:\n        break\nif not done:\n    if len(degreelist[-1])==1:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "from collections import deque\n \nm, k = list(map(int, input().split()))\n \nG = [set() for _ in range(m + 1)]\n \nq, nq = deque(), deque()\n \nfor _ in range(m - 1):\n    u, v = list(map(int, input().split()))\n    G[u].add(v)\n    G[v].add(u)\n \nfor u in range(1, m + 1):\n    if len(G[u]) == 1:\n        q.append(u)\n \nstep = 0\nremoved = 0\nok = True\n \nwhile removed < m - 1:\n    each = {}\n    for u in q:\n        nxt = G[u].pop()\n        G[nxt].remove(u)\n        each[nxt] = each.get(nxt, 0) + 1\n        removed += 1\n        if len(G[nxt]) == 0:\n            break\n        if len(G[nxt]) == 1:\n            nq.append(nxt)\n    if any(v < 3 for k,v in list(each.items())):\n        ok = False\n        break\n    q, nq = nq, deque()\n    step += 1\n \nif ok and step == k and removed == m - 1:\n    print('Yes')\nelse:\n    print('No')\n"]
["n = int(input())\np = [-1, 0] + [int(x) for x in input().split()]\nh = [0] * (n+1)\ncount = [0] * n\ncount[0] = 1\nmax_h = 0\nfor i in range(2, n+1):\n    h[i] = h[p[i]]+1\n    count[h[i]]+=1\n    max_h = max(max_h,h[i])\nans = 0\nfor i in range(max_h+1):\n    ans += count[i]%2\nprint(ans)", "import sys, math\n\n#f = open('input/input_2', 'r')\nf = sys.stdin\n\nN = int(f.readline())\npl = list(map(int, f.readline().split()))\n\ne = [[] for _ in range(N+1)]\nlv = [0] * (N+1)\nfor i, p in enumerate(pl):\n  e[p].append(i+2)\n\nc = [0] * (N+1)\n\nfor i in range(1, N+1):\n  c[lv[i]] = 1 - c[lv[i]]\n  for j in e[i]:\n    lv[j] = lv[i]+1\n\nprint(sum(c))\n", "# python3\n\n\ndef main():\n    n = int(input())\n    parent = tuple(int(x) - 1 for x in input().split())\n\n    depth = [0]\n    for v in range(n - 1):\n        depth.append(depth[parent[v]] + 1)\n\n    parity = [0] * n\n    for d in depth:\n        parity[d] ^= 1\n\n    print(sum(parity))\n\n\nmain()\n", "n = int(input().strip())\ncount = [0]*n\nparams = [-1, 0]+list(map(int, input().split()))\ni = 2\nlayer = [0]*(n+1)\nnodes_in_layer = {}\nwhile i <= n:\n    layer[i] = layer[params[i]] + 1\n    count[params[i]] += 1\n    if nodes_in_layer.get(layer[i]) is None:\n        nodes_in_layer.setdefault(layer[i], 1)\n    else:\n        nodes_in_layer[layer[i]] += 1\n    i += 1\nmax_layer = max(layer)\nresult = 1\nfor i in range(1, max_layer+1):\n    result += nodes_in_layer[i] % 2\n\nprint(result)\n", "import collections\nn = int(input())\na = list(map(int, input().split()))\n\nto = {}\nfor i, node in enumerate(a):\n    to[i+2] = node\n\nlayers = collections.defaultdict(list)\nfor k, v in to.items():\n    layers[v].append(k)\n\nqueue = [1]\nans = 0\nwhile queue:\n    ans += len(queue)%2\n    n = len(queue)\n    for _ in range(n):\n        node = queue.pop(0)\n        if node in layers:\n            queue.extend(layers[node])\n\nprint(ans)", "import threading\nfrom sys import setrecursionlimit, exc_info\n\n\ndef main():\n    try:\n        n = int(input())\n        par = list(map(int, input().split()))\n\n        gr = [[] for i in range(n)]\n        for i in range(n - 1):\n            gr[par[i] - 1].append(i + 1)\n\n        cnt = [0] * n\n\n\n\n        def dfs(v, depth=0):\n            cnt[depth] += 1\n            while depth >= len(cnt):\n                pass\n            for u in gr[v]:\n                dfs(u, depth + 1)\n\n\n\n        dfs(0)\n        print(sum([x % 2 for x in cnt]))\n    except:\n        print(exc_info()[0])\n\n\nsetrecursionlimit(100000000)\nthreading.stack_size(102400000)\nthread = threading.Thread(target=main)\nthread.start()\n", "n=int(input())\na=[0,0]+list(map(int,input().split()))\nb=[0]*(n+1);c=[0]*(n+1)\nfor i in range(2,n+1):\n       if a[i]==1:\n              b[i]=1\nfor i in range(2,n+1):\n       cou=0;s=i\n       while b[s]==0:  \n              cou+=1;s=a[s]\n       b[i]=cou+b[s]\nfor i in b[2:]:\n       c[i]+=1\nans=1\nfor i in c:\n       ans+=i%2\nprint(ans)", "n=int(input())\n\n\n\n\n\na=list(map(int,input().split()))\n\ndp=[0,]\n\ncount=[0 for i in range(n)]\n\ncount[0]+=1\n\nfor i in range(n-1):\n\n    dp.append(dp[a[i]-1]+1)\n\n    count[dp[-1]]+=1\n\nans=0\n\nfor i in range(n):\n\n    ans+=count[i]%2\n\nprint(ans)\n\n\n\n# Made By Mostafa_Khaled\n", "def bfs(d,n):\n    queue = [[1,0]]\n    res = 0\n    mark = {i:False for i in range(1,n+1)}\n    mark[1]=True\n    res = [0 for i in range(n)]\n    while queue:\n        q = queue.pop(0)\n        x,level = q[0],q[1]\n        lev = level+1\n        res[level]=(res[level]+1)%2\n        for i,y in enumerate(d[x]):\n            if mark[y]==False:\n                mark[y]=True\n                queue.append([y,lev])\n    print(sum(res))\nn = int(input())\nlst = list(map(int,input().split()))\nd = {1:[]}\nfor i,x in enumerate(lst):\n    d[x].append(i+2)\n    d[i+2]=[]\nbfs(d,n)", "from sys import setrecursionlimit\n\na = int(input())\n\nsetrecursionlimit(200000)\n\nh = [[] for i in range(a)]\ns = list(map(int, input().split()))\nfor i in range(a - 1):\n    h[s[i] - 1].append(i + 1)\n\nmetka = [False for i in range(a)]\ndat = [0 for i in range(a)]\ndis = [0 for i in range(a)]\n\n\ndef dfs(x):\n    stack = []\n    stack.append(x)\n    while stack:\n        x = stack.pop(-1)\n        dat[dis[x]] += 1\n        metka[x] = True\n        for i in h[x]:\n            if not metka[i]:\n                stack.append(i)\n                dis[i] = dis[x] + 1\n\n\ndfs(0)\n\nprint(sum([x % 2 for x in dat]))\n", "# 930A\nimport collections\ndef do():\n    n = int(input())\n    nums = [0] + [int(c)-1 for c in input().split(\" \")]\n    g = collections.defaultdict(list)\n    for i, j in enumerate(nums):\n        if i != j:\n            g[j].append(i)  # children\n    cur = [0]\n    res = 0\n    while cur:\n        res += len(cur) % 2\n        next = []\n        for c in cur:\n            for nei in g[c]:\n                next.append(nei)\n        cur = next\n    return res\n\nprint(do())", "n = int(input())\n\npar = [None] + [int(i) - 1 for i in input().split()]\nchildren = [[] for _ in range(n)]\nfor child in range(1, n):\n    children[par[child]].append(child)\n\ncount = 0\nnodesAtCurrLevel = [0]\n\nwhile nodesAtCurrLevel:\n    count += len(nodesAtCurrLevel) % 2\n    \n    nodesAtNextLevel = []\n    for node in nodesAtCurrLevel:\n        nodesAtNextLevel += children[node]\n    \n    nodesAtCurrLevel = nodesAtNextLevel\n\nprint(count)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\ndef bfs():\n    q = deque([0])\n    dist = [-1]*n\n    dist[0] = 0\n    \n    while q:\n        v = q.popleft()\n        \n        for nv in G[v]:\n            if dist[nv]==-1:\n                dist[nv] = dist[v]+1\n                q.append(nv)\n    \n    return dist\n\nn = int(input())\np = list(map(int, input().split()))\nG = [[] for _ in range(n)]\n\nfor i in range(n-1):\n    G[i+1].append(p[i]-1)\n    G[p[i]-1].append(i+1)\n\ndist = bfs()\ncnt = Counter(dist)\nans = 0\n\nfor v in cnt.values():\n    ans += v%2\n\nprint(ans)", "n = int(input())\np = [-1, 0] + list(map(int, input().split()))\nh = [0] * (n+1)\ncnt = [1] + [0] * n\nfor i in range(2, n+1):\n    h[i] = h[p[i]] + 1\n    cnt[h[i]] += 1\nres = 0\nfor i in range(max(h)+1):\n    if cnt[i] % 2 == 1:\n        res += 1\nprint(res)\n", "n = int(input())\na = [int(e) for e in input().split()]\nd = {1:0}\nfor k, v in enumerate(a):\n    d[k+2] = d[v] + 1\nd2 = {}\nfor k, v in d.items():\n    d2[v] = d2.get(v,0) + 1\ns = sum([v%2 for v in d2.values()])\nprint(s)", "\nclass Node: \n    def __init__(self, id):\n        self.id = id\n        self.parent = -1\n        self.children = set()\n        self.apples = 1\n\nnodes = dict()\n\nnb_nodes = int(input())\nfor i in range(nb_nodes): \n    nodes[i+1] = Node(i+1)\n\nparents = [int(i) for i in input().split(\" \")]\n\nbase = 2\nfor p in parents: \n    nodes[base].parent = p\n    nodes[p].children.add(base)\n    base += 1\n\n#for n in nodes.values(): \n#    print(\"%d -> %s\" % (n.id, n.children))\n    \nrecolt = 0\ntodo = { 1 }\nwhile len(todo) > 0: \n    recolt += len(todo) % 2\n    next = set()\n    for t in todo: \n        next |= nodes[t].children\n    todo = next\n        \nprint(recolt)", "n = int(input())\nparent = tuple(int(x) - 1 for x in input().split())\n \ndepth = [0]\nfor v in range(n - 1):\n    depth.append(depth[parent[v]] + 1)\n \nparity = [0] * n\nfor d in depth:\n    parity[d] ^= 1\n \nprint(sum(parity))", "n = int(input())\nparent = tuple(int(x) - 1 for x in input().split())\n\ndepth = [0]\nfor v in range(n - 1):\n    depth.append(depth[parent[v]] + 1)\n\nparity = [0] * n\nfor d in depth:\n    parity[d] ^= 1\n\nprint(sum(parity))", "n = int(input())\nparent = tuple(int(x) - 1 for x in input().split())\n \ndepth = [0]\nfor v in range(n - 1):\n    depth.append(depth[parent[v]] + 1)\n \n# parity = [0] * n\n# for d in depth:\n#     parity[d] ^= 1\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\n\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n \n# print(sum(parity))\n", "inflos = int(input())\nparent = tuple(int(x) - 1 for x in input().split())\n \ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[parent[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "inflos = int(input())\nroots = [int(x) - 1 for x in input().split()]\n \n\ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[roots[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "inflos = int(input())\nroots = input()\nroots = [int(x) - 1 for x in roots.split()]\n \n\ndepth = [0]\nfor v in range(inflos - 1):\n    depth.append(depth[roots[v]] + 1)\n\nfreq = {}\n\nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n", "inflos = int(input())\nroots = input()\nroots = [int(x) - 1 for x in roots.split()]\n \n\nson = [0]\nfor v in range(inflos - 1):\n    son.append(son[roots[v]] + 1)\n\nfreq = {}\n\nfor d in son:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)", "import sys\nimport bisect\n# from collections import deque\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 30  \nMOD = 998244353\n\nn = int(ri())\na  = Ri()\n\ndic = {}\nfor i in range(len(a)):\n    if a[i] == 1:\n        dic[i+2] = 1\n    else:\n        time = dic[a[i]]\n        dic[i+2] = time+1\ncnt = 0\ntime = {}\nfor i in dic:\n    if dic[i] in time:\n        time[dic[i]]+=1\n    else:\n        time[dic[i]] = 1\n    \nfor i in time:\n    cnt +=(time[i]%2)\nprint(cnt+1)", "n = int(input())\nparent = tuple(int(x)-1 for x in input().split())\n \ndepth = [0]\nfor v in range(n - 1):\n    depth.append(depth[parent[v]] + 1)\n \n\nfreq = {}\n \nfor d in depth:\n    if d in freq:\n        freq[d] += 1\n    else:\n        freq[d] = 1\n \nres = 0\nfor d in freq:\n    res+= freq[d]%2\nprint(res)\n"]
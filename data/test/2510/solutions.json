["import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M = list(map(int,input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n    A,B = list(map(int,input().split()))\n    A -=1\n    B -=1\n    uf.union(A,B)\nans = 0\nfor i in range(N):\n    ans = max(ans,uf.size(i))\nprint(ans)\n", "class UnionFind():\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\u21d2(a,b)\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n    # \u5165\u529b\u30ce\u30fc\u30c9(x,y)\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3092\u8fd4\u3059\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n    #\u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u30e1\u30f3\u30d0\u30fc\u3092\u30ea\u30b9\u30c8\u5f62\u5f0f\u3067\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n    #\u89aa\u5168\u3066\u3092\u30ea\u30b9\u30c8\u5f62\u5f0f\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n    #\u30b0\u30eb\u30fc\u30d7\u6570\u306e\u5408\u8a08\u3092\u8fd4\u3059\n        return len(self.roots())\n\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\n\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nu=UnionFind(n)\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    u.unite(a,b)\nans=0\nfor i in range(n):\n    ans=max(ans,u.size(i))\nprint(ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M = map(int,input().split())\nUF = UnionFind(N+1)\nfor i in range(M):\n    x,y = map(int,input().split())\n    UF.union(x,y)\nls = UF.roots()\nls.pop(0)\nls2 = []\nfor i in ls:\n    ls2.append(UF.size(i))\nprint(max(ls2))", "class UnionFind:\n    from typing import List, Set\n    def __init__(self, n):\n        self.n = n\n        self.parent = [-1] * n\n    def merge(self, x, y) -> int:\n        x = self.leader(x)\n        y = self.leader(y)\n        if x == y:\n            return 0\n        if self.parent[x] > self.parent[y]:\n            x, y = y, x\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n        return self.parent[x]\n    def same(self, x, y) -> bool:\n        return self.leader(x) == self.leader(y)\n    def leader(self, x) -> int:\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.leader(self.parent[x])\n            return self.parent[x]\n    def size(self, x) -> int:\n        return -self.parent[self.leader(x)]\n    def groups(self) -> List[Set[int]]:\n        groups = dict()\n        for i in range(self.n):\n            p = self.leader(i)\n            if not groups.get(p):\n                groups[p] = set()\n            groups[p].add(i)\n        return list(groups.values())\n\nn,m=map(int,input().split())\nuf = UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    uf.merge(a-1,b-1)\ngrp=uf.groups()\nans=0\nfor i in range(len(grp)):\n    if (len(grp[i])>ans):\n        ans=len(grp[i])\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n        \n\nN, M = map(int, input().split())\n\nuf = UnionFind(N+1)\nfor i in range(M):\n    A, B = map(int, input().split())\n    uf.union(A, B)\n\nans = 0\nfor i in range(N+1):\n    ans = max(ans, uf.size(i))\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nn, m = map(int, input().split())\nroot = [-1] * n\n\ndef r(x):\n    if root[x] < 0:\n        return x\n    else:\n        root[x] = r(root[x])\n        return root[x]\n\ndef unite(x, y):\n    x = r(x)\n    y = r(y)\n    if x == y:\n        return\n    root[x] += root[y]\n    root[y] = x\n\ndef size(x):\n    x = r(x)\n    return -root[x]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    unite(x, y)\n\nmax_size = max(map(size, range(n)))\n\nprint(max_size)", "# n, m = map(int, input().split())\n# graph = [[] for i in range(n+1)]\n\n# for i in range(m):\n#     a, b = map(int, input().split())\n#     graph[a] += [b]\n#     graph[b] += [a]\n# print(graph)\n# nex = [i for i in range(1, n+1)]\n# tmp = []\n# ans = 0\n# for i in range(1, n+1):\n#     if i in nex:\n#         for j in graph[i]:\n#             if j in nex:\n#                 tmp.append(j)\n#         ans += 1\n#         print(tmp)\n#         nex = tmp\n# print(ans)\n\n\n\n\n#O(\u03b1(n)) < O(log(n))\nclass UnionFind():\n\n    def __init__(self, n):\n        self.par = []\n        self.rank = []\n        for i in range(n):\n            self.par.append(i)#\u81ea\u8eab\u3092\u89aa\u3068\u3057\u3066init\n            self.rank.append(1)#\uff11\u3064\u306e\u30ce\u30fc\u30c9\u3092rank1\u3068\u3057\u3066\u30ab\u30a6\u30f3\u30c8\n\n    def find(self, x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])#\u89aa\u306e\u66f4\u65b0\u3082\u540c\u6642\u306b\u884c\u3046\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x != y:\n            if self.rank[x] <= self.rank[y]:\n                x, y = y, x\n\n            #rank\u304c\u5c0f\u3055\u3044\u65b9\u3092\u5927\u304d\u3044\u65b9\u306b\u3064\u306a\u3052\u308b\n            self.par[y] = x\n\n            #\u89aa\u306erank\u306b\u7e4b\u3044\u3060\u6728\u306erank\u3092\u5168\u3066\u8db3\u3059\n            self.rank[x] += self.rank[y]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self.rank[self.find(x)]\n\nn, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\nans = 0\nuf = UnionFind(n)\n\nfor a, b in ab:\n    uf.unite(a-1, b-1)\n\nfor i in range(n):\n    ans = max(ans, uf.size(i))\n\nprint(ans)", "n,m=map(int,input().split())\nl=[]\nfor i in range(m):\n    a,b=map(int,input().split())\n    l.append([a,b])\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nuf=UnionFind(n)\n\nfor i in range(m):\n    uf.union(l[i][0]-1,l[i][1]-1)\n\ns=[]\nfor i in range(n):\n    s.append(uf.size(i))\n\nprint(max(s))", "class UnionFind():\n  def __init__(self,n):\n    self.n = n\n    self.parents = [-1] * (n+1)\n  \n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.parents[x] > self.parents[y]:\n      x,y = y,x\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def size(self, x):\n    return -1 * self.parents[x]\n  \n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n  \n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n    \n  def roots(self):\n    return [i for i,x in enumerate(self.parents) if x < 0]\n    \n  def group_count(self):\n    return len(self.roots())\n\nN,M = map(int,input().split())\nuf = UnionFind(N)\nfor i in range(M):\n  a,b = map(int, input().split())\n  uf.union(a,b)\n  \nans = 0\nR = uf.roots()\nfor r in R:\n  ans = max(ans, uf.size(r))\nprint(ans)", "def find(x):\n  if par[x] < 0:\n    return x\n  else:\n    tank = []\n    while par[x] >= 0:\n      tank.append(x)\n      x = par[x]\n    for elt in tank:\n      par[elt] = x\n    return x\n\ndef unite(x,y):\n  x = find(x)\n  y = find(y)\n    \n  if x == y:\n    return False\n  else:\n    if par[x] > par[y]:\n      x,y = y,x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef same(x,y):\n  return find(x) == find(y)\n\ndef size(x):\n  return -par[find(x)]\n\nN,M=map(int,input().split())\npar = [-1]*N\nfor _ in range(M):\n  a,b=map(int,input().split())\n  unite(a-1,b-1)\nprint(-min(par))", "N, M = list(map(int, input().split()))\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nu = UnionFind(N)\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    u.union(a - 1, b - 1)\n\nans = 0\nfor i in u.roots():\n    ans = max(u.size(i), ans)\n\nprint(ans)\n", "class UnionFind():\n  def __init__(self,n):\n    self.n = n\n    self.parents = [-1] * (n+1)\n    \n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.parents[x] > self.parents[y]:\n      x,y = y,x\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n    \n  def size(self, x):\n    return -1 * self.parents[x]\n  \n  def same(self,x,y):\n    return self.find(x) == self.find(y)\n  \n  def members(self,x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n    \n  def roots(self):\n    return [i for i in range(1,self.n+1,1) if self.parents[i] < 0]\n  \n  def group_count(self):\n    return len(self.roots())\n  \nN,M = map(int,input().split())\nuf = UnionFind(N)\nfor i in range(M):\n  a,b = map(int,input().split())\n  uf.union(a,b)\nans = 0\nfor r in uf.roots():\n  ans = max(ans,uf.size(r))\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n)\n        \n    def find(self, x):\n        if self.parents[x] < 0:     # \u6839\u306a\u3089\u305d\u306e\u756a\u53f7\u3092\u8fd4\u3059\n            return x\n        else:                       # \u6839\u3067\u306a\u3044\u306a\u3089\u305d\u306e\u8981\u7d20\u3067\u518d\u691c\u7d22\n            self.parents[x] = self.find(self.parents[x])    # \u8d70\u67fb\u904e\u7a0b\u3067\u89aa\u3092\u66f8\u304d\u63db\u3048\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:                  # \u65e2\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u308b\u5834\u5408\n            return\n        \n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u9ad8\u3044\u65b9\u306e\u6728\u306b\u4f4e\u3044\u65b9\u3092\u4f75\u5408\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]  # \u4f75\u5408\u3055\u308c\u308b\u5074\u306e\u8981\u7d20\u6570\u3092\u52a0\u7b97\n        self.parents[y] = x                 # \u4f75\u5408\u3059\u308b\u5074\u306e\u89aa\u3092\u66f8\u304d\u63db\u3048\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def issame(self, x, y):\n        return self.find[x] == self.find(y)\n\n\n'''\n\u53c2\u8003\nhttps://qiita.com/K_SIO/items/03ff1fc1184cb39674aa#d-friends\n'''\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    uf = UnionFind(N)\n\n    for _ in range(M):\n        A, B = list(map(int, input().split()))\n        uf.union(A-1, B-1)\n    \n    ans = 0\n\n    for i in range(N):\n        ans = max(ans, uf.size(i))\n    \n    print(ans)\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v, visited, counter):\n    visited[v] = 1\n    for nv in G[v]:\n        if visited[nv]:\n            continue\n        visited[nv] = 1\n        counter.append(1)\n        dfs(nv, visited, counter)\n    return\n\nn, m = map(int, input().split())\nG = [[] for _ in range(n)]\nvisited = [0] * n\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\nmax_friends = 0\nfor i in range(n):\n    if visited[i]:\n        continue\n    friends = []\n    dfs(i, visited, friends)\n    max_friends  = max(max_friends, sum(friends) + 1)\n\nprint(max_friends)", "from collections import deque\ndef bfs(edges,start):\n    waiting = deque()\n    done[start] = 2\n    c = 1\n    for n in edges[start]:\n        done[n] = 1\n        waiting.append(n)\n    while len(waiting):\n        cur_node = waiting.popleft()\n        if done[cur_node] != 2:\n            done[cur_node] = 2\n            c += 1\n            for n in edges[cur_node]:\n                if done[n] != 2:\n                    done[n] = 1\n                    waiting.append(n)\n    #print(done,c)\n    return c\n\nN,M = [int(a) for a in input().split()]\nedge = [[] for _ in range(N)] \nfor _ in range(M):\n    a,b = [int(a) for a in input().split()]\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\ndone = [0]*N\nans = 0\nfor i in range(N):\n  if done[i]==0: ans = max(ans, bfs(edge,i))\nprint(ans)", "import sys\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, M = list(map(int, input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    uf.union(a, b)\n\nans = 0\nfor i in range(N):\n    ans = max(ans, uf.size(i))\nprint(ans)\n", "class UnionFind(): # 0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n    \n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def size(self, x):\n    return -self.parents[self.find(x)]\n\nN, M = map(int, input().split()) # N\u4eba\u3001M\u500b\u306e\u95a2\u4fc2\nunion_find = UnionFind(N)\nfor _ in range(M):\n  A, B = map(int, input().split())\n  A -= 1\n  B -= 1\n  union_find.union(A, B)\n\nanswer = 0\nfor i in range(N):\n  answer = max(answer, union_find.size(i))\n\nprint(answer)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \n      \nN, M = map(int,input().split())\nuf = UnionFind(N)\nfor i in range(M):\n  A, B = map(int,input().split())\n  A -= 1\n  B -= 1\n  uf.union(A, B)\n  \nL = [0] * N\nfor i in range(N):\n  L[i] = uf.size(i)\n  \nprint(max(L))", "from collections import Counter\n\nN, M = map(int, input().split())\nAB = [map(int, input().split()) for _ in range(M)]\n\nF = list(range(N+1))\nfor A, B in AB:\n    H = []\n    while F[A] != A:\n        H.append(A)\n        A = F[A]\n    while F[B] != B:\n        H.append(B)\n        B = F[B]\n    for h in H+[B]:\n        F[h] = A\n\nfor i, f in enumerate(F):\n    H = [i]\n    while F[f] != f:\n        H.append(f)\n        f = F[f]\n    for h in H:\n        F[h] = f\n\nprint(Counter(F).most_common(1)[0][1])", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.size=[1]*n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.size[x]+=self.size[y]\n        self.size[y]=self.size[x]\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=map(int,input().split())\nuf = UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    uf.union(a-1,b-1)\nprint(max(uf.size))", "from collections import deque\n\nn,m = list(map(int, input().split()))\nG = [[] for _ in range(n)]\n\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\nque = deque()\ndist = [-1]*n\nans = 0\nfor i in range(n):\n    if dist[i]!=-1:\n        continue\n    dist[i]==0\n    que.append(i)\n    cnt = 0\n    while len(que):\n        v = que.popleft()\n        vs = G[v]\n        for nv in vs:\n            if dist[nv]==-1:\n                dist[nv] = dist[v]+1\n                cnt += 1\n                que.append(nv)\n    ans = max(cnt, ans)\nif m==0:\n    print((1))\nelse:\n    print(ans)\n", "class Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = Unionfind(N)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    uf.union(a, b)\n\nans = [uf.size(i) for i in range(N)]\nprint(max(ans))", "class UnionFind:\n    def __init__(self, n=0):\n        self.d = [-1]*n\n    def find(self, x):\n        if self.d[x] < 0:\n            return x\n        else:\n            self.d[x] = self.find(self.d[x])\n            return self.d[x]\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.d[x] > self.d[y]:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        return True\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.d[self.find(x)]\n\n\nn, m = map(int, input().split())\nuf = UnionFind(n)\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    uf.unite(a-1, b-1)\n\nans = 0\nfor i in range(n):\n    ans = max(ans, uf.size(i))\n\nprint(ans)", "import networkx as nx\nimport sys\n\nG = nx.Graph()\n\nn, m = list(map(int, input().split()))\nif m == 0:\n    print((1))\n    return\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    G.add_edge(a, b)\n\nlargest_cc = max(nx.connected_components(G), key=len)\nprint((len(largest_cc)))\n", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nsys.setrecursionlimit(20000000)\n\nMOD = 10 ** 9 + 7\nINF = float(\"inf\")\n\n\nclass UnionFind:\n    # \u521d\u671f\u5316\n    def __init__(self, n_nodes):\n        self.n_nodes = n_nodes\n        # \u89aa\u8981\u7d20\u306e\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b.\u521d\u3081\u306f\u5168\u3066\u89aa\u30ce\u30fc\u30c9.\n        # self.parent[x] == x \u306e\u6642\uff0c\u305d\u306e\u30ce\u30fc\u30c9\u306f\u6839.\n        self.parent = [i for i in range(n_nodes)]\n        # \u6728\u306e\u9ad8\u3055\u3092\u683c\u7d0d\u3059\u308b\uff0e\n        self.rank = [1] * n_nodes\n        # \u81ea\u5206\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u683c\u7d0d\uff0e\u89aa\u8981\u7d20\u3092\u53c2\u7167\u3059\u308b\u3088\u3046\u306b\u3059\u308b\n        self.size = [1] * n_nodes\n\n    # \u691c\u7d22. \u6839\u3092\u8fd4\u3059.\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            # \u4e00\u5ea6\u8abf\u3079\u305f\u5024\u306f\uff0c\u6839\u306b\u7e4b\u304e\u76f4\u3059.\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    # \u4f75\u5408.\n    # \u6728\u306e\u9ad8\u3055\u304c\u4f4e\u304f\u306a\u308b\u3088\u3046\u306b.\n    # \u89aa\u8981\u7d20\u306e\u66f8\u304d\u63db\u3048\u306f\u5c11\u306a\u3044\u65b9\u304c\u3044\u3044\n    def unite(self, x, y):\n        # \u6839\u3092\u63a2\u3059\uff0e\n        x = self.find(x)\n        y = self.find(y)\n        # \u6839\u304c\u540c\u3058\u5834\u5408\u306f\u305d\u306e\u307e\u307e\n        if x == y:\n            return\n        # \u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\uff0c\u4f4e\u3044\u65b9\u3092\u9ad8\u3044\u65b9\u306e\u6839\u306b\u8cbc\u308b.\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n        else:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u540c\u4e00\u30b0\u30eb\u30fc\u30d7\u306b\u6240\u5c5e\u3059\u308b\u8981\u7d20\u6570\u3092\u8fd4\u3059\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n    # \u89aa\u8981\u7d20\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\n    def get_parent_list(self):\n        return [i for i in range(self.n_nodes) if self.find(i) == i]\n\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n    def get_n_groups(self):\n        return len(self.get_parent_list())\n\n    # \u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u6240\u5c5e\u3059\u308b\u8981\u7d20\u306e\u96c6\u5408\u3092\u8fd4\u3059\n    def get_members(self, x):\n        parent = self.find(x)\n        return [i for i in range(self.n_nodes) if self.find(i) == parent]\n\n    # \u5168\u3066\u306e\u6839\u306b\u5bfe\u3059\u308b\uff0c\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u3092\u8fd4\u3059\uff0e\n    def get_members_dict(self):\n        return {par: self.get_members(par) for par in self.get_parent_list()}\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    edge = [set(map(int, input().split())) for _ in range(M)]\n\n    UF = UnionFind(N)\n    for x, y in edge:\n        UF.unite(x - 1, y - 1)\n\n    parents = UF.get_parent_list()\n    answer = 0\n    for p in parents:\n        size = UF.get_size(p)\n        answer = max(answer, size)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int, input().split())\n\nclass UnionFind:\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n        self.size = [1] * (N + 1)\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        sx, sy = self.size[x], self.size[y]\n        if sx < sy:\n            x, y = y, x\n            sx, sy = sy, sx\n        self.root[y] = x\n        self.size[x] += sy\n\n    def find_max(self):\n        return max(self.size)\n\nuf = UnionFind(N)\n\nanswer = []\nappend = answer.append\nmerge = uf.merge\n\nfor i in range(M):\n    a,b = map(int, input().split())\n    merge(a,b)\nprint(uf.find_max())", "from collections import deque \n\nn, m = map(int, input().split())\nG = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\nvisited = [0] * n\n\ndef friends(v):\n    stack = deque([v])\n    visited[v] = 1\n    cnt = 1\n    while stack:\n        v = stack.popleft()\n        for nv in G[v]:\n            if visited[nv]:\n               continue\n            visited[nv] = 1\n            stack.append(nv)\n            cnt += 1\n    return cnt\n\nmax_friends = 0\nfor i in range(n):\n    if visited[i]:\n        continue\n    max_friends  = max(max_friends, friends(i))\n\nprint(max_friends)", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n        self.siz = [1 for i in range(n)]\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        self.par[x] = self.find(self.par[x])\n        return self.find(self.par[x])\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] > self.rank[y]:\n            self.par[y] = x\n            self.siz[x] += self.siz[y]\n        else:\n            self.par[x] = y\n            self.siz[y] += self.siz[x]\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self.siz[self.find(x)]\n    \nn, m = map(int, input().split())\nuf = UnionFind(n)\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    uf.unite(a, b)\n\nres = 0\nfor i in range(n):\n    res = max(res, uf.size(i))\n\nprint(res)", "import sys\nsys.setrecursionlimit(1000000)\n\n\nf=lambda:map(int,input().split())\nN,M=f()\n\nif M==0:\n  print(1)\n  return\n\nG=[set() for _ in range(N+1)]\nfor _ in range(M):\n    a,b=f()\n    G[a].add(b)\n    G[b].add(a)\n# print(G)\n\nd={}\nF=[0]*(N+1)\n\ndef dfs(i,n):\n if F[i]:return\n F[i]=1\n for g in G[i]:\n    if F[g]:continue\n    t=d.get(n, set())\n    t.add(g)\n    d[n]=t\n    dfs(g,n)\n   \nfor i in range(1,N+1):\n  dfs(i,i)\n\nprint(max(len(i) for i in d.values())+1)", "class UnionFind:\n    from typing import List, Set\n\n    def __init__(self, n):\n        self.n = n\n        self.parent = [-1] * n\n\n    def merge(self, x, y) -> int:\n        x = self.leader(x)\n        y = self.leader(y)\n\n        if x == y:\n            return 0\n\n        if self.parent[x] > self.parent[y]:\n            x, y = y, x\n\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n\n        return self.parent[x]\n\n    def same(self, x, y) -> bool:\n        return self.leader(x) == self.leader(y)\n\n    def leader(self, x) -> int:\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.leader(self.parent[x])\n            return self.parent[x]\n\n    def size(self, x) -> int:\n        return -self.parent[self.leader(x)]\n\n    def groups(self) -> List[Set[int]]:\n        groups = dict()\n\n        for i in range(self.n):\n            p = self.leader(i)\n            if not groups.get(p):\n                groups[p] = set()\n            groups[p].add(i)\n\n        return list(groups.values())\n\nn,m=map(int,input().split())\nuf = UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    uf.merge(a-1,b-1)\ngrp=uf.groups()\nans=0\nfor i in range(len(grp)):\n    if (len(grp[i])>ans):\n        ans=len(grp[i])\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nN, M = map(int, input().split())\nroot = [-1] * N\n\ndef find(x):\n    if root[x] < 0:\n        return x\n    else:\n        root[x] = find(root[x])\n        return root[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    root[x] += root[y]\n    root[y] = x\n\ndef size(x):\n    x = find(x)\n    return -root[x]\n\nfor i in range(M):\n    A, B = map(int, input().split())\n    A -= 1\n    B -= 1\n    union(A, B)\n\nans = max(map(size, range(N)))\nprint(ans)", "class UnionFind():\n    def __init__(self, N):\n        self.par = [-1] * N\n        \n    def root(self, x):\n        if self.par[x] < 0: return x\n        self.par[x] = self.root(self.par[x])\n        return self.par[x]\n        \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        #print(f'root: {rx} {ry}')\n        if rx == ry: return\n        \n        self.par[ry] += self.par[rx]\n        self.par[rx] = ry\n        \n\n        \nN, M = map(int, input().split())\nuf = UnionFind(N)\nfor i in range(M):\n    A, B = map(lambda x: int(x), input().split())\n    A, B = A-1, B-1\n    #print(f'{A} {B} {uf.par}')\n    uf.unite(A,B)\n    #print(f'{A} {B} {uf.par}')\n    \nprint(-min(uf.par))", "from typing import List\n\n\nclass DSU:\n    def __init__(self, n: int = 0) -> None:\n        self._n: int = n\n        # root node: -1 * component size\n        # otherwise: parent\n        self.parent_or_size: List[int] = [-1] * n\n\n    def merge(self, a: int, b: int) -> int:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        x, y = self.leader(a), self.leader(b)\n        if x == y:\n            return x\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\n            x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n\n    def same(self, a: int, b: int) -> bool:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a: int) -> int:\n        assert 0 <= a < self._n\n        if self.parent_or_size[a] < 0:\n            return a\n        self.parent_or_size[a] = self.leader(self.parent_or_size[a])\n        return self.parent_or_size[a]\n\n\nN, M, *AB = list(map(int, open(0).read().split()))\nd = DSU(N)\nfor a, b in zip(*[iter(AB)] * 2):\n    d.merge(a - 1, b - 1)\nprint((-min(d.parent_or_size)))\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nn, m = map(int, input().split())\np = [-1] * n\n \ndef find(x):\n    if p[x] < 0:\n        return x\n    else:\n        p[x] = find(p[x])\n        return p[x]\n \ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n \n    if x == y:\n        return\n    \n    p[x] += p[y]\n    p[y] = x\n \ndef size(x):\n    x = find(x)\n    return -p[x]\n \nfor _ in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    unite(x, y)\n \nmax_size = max(map(size, range(n)))\nprint(max_size)", "import sys\nsys.setrecursionlimit(10**9)\n\nn, m = map(int, input().split())\npair = [-1] * n\nmax_size = 0\n\ndef find(x):\n    if pair[x] < 0:\n        return x\n    else:\n        pair[x] = find(pair[x])\n        return pair[x]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return\n\n    pair[x] += pair[y]\n    pair[y] = x\n\ndef size(x):\n    x = find(x)\n    return -pair[x]\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    unite(x, y)\n\nmax_size = max(map(size, range(n)))\nprint(max_size)", "import sys\n\nsys.setrecursionlimit(1500)\n\nclass UnionFind:\n    def __init__(self, N):\n        # \u6700\u521d\u306f\u3059\u3079\u3066\u6839\u3067\u521d\u671f\u5316\n        self.par = [-1 for i in range(N)]\n\n    def root(self, x):\n        # print(x, self.par)\n        if self.par[x] == x:\n            return x\n        elif self.par[x] < 0:\n            # par = self.root(self.par[x])\n            # self.par[x] = x\n            return x\n        else:\n            par = self.root(self.par[x])\n            self.par[x] = par\n            return par\n        \n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        self.par[x] += self.par[y]\n        self.par[y] = x\n        return True\n\n    def same(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        return rx == ry\n\n    def size(self, x):\n        return -self.par[self.root(x)]\n\nN,M=list(map(int,input().split()))\n\n\n# union find\u69cb\u9020\u3092\u4f5c\u308b\nuf = UnionFind(N)\nfor _ in range(M):\n    A,B=[int(x)-1 for x in input().split()]\n    uf.unite(A,B)\n\n# r = [uf.size(n) for n in range(N)]\n# print(uf.par)\nprint((-min(uf.par)))\n# print(uf.par)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x) -> int:\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y) -> None:\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x) -> int:\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y) -> bool:\n        return self.find(x) == self.find(y)\n\n    def members(self, x) -> list:\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self) -> list:\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self) -> int:\n        return len(self.roots())\n\n    def all_group_members(self) -> dict:\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    def solve(self):\n        print(max([self.size(i) for i in self.roots()]))\nn,m=map(int,input().split())\na=UnionFind(n)\nfor i in range(m):\n    c,b=map(int,input().split())\n    a.union(c-1,b-1)\na.solve()", "class Unionfind:\n    def __init__(self,n):\n        self.par=[x for x in range(n)]\n        self.num=[1]*n\n\n    def root(self,a):\n        if self.par[a]==a : return a\n        parent=self.root(self.par[a])\n        self.par[a]=parent\n        return parent\n\n    def unite(self,a,b):\n        ra,rb=self.root(a),self.root(b)\n        self.par[rb]=ra\n        self.num[ra]+=self.num[rb]\n\n    def same(self,a,b):\n        return self.root(a)==self.root(b)\n\n\n\ndef main():\n    n,m=map(int,input().split())\n    uf=Unionfind(n)\n\n    for _ in range(m):\n        a,b=map(int,input().split())\n        if uf.same(a-1,b-1) : continue\n        uf.unite(a-1,b-1)\n\n    print(max(uf.num))\n\nmain()", "\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    uf = UnionFind(n)\n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        uf.union(a-1, b-1)\n\n    max_firiend = 0\n\n    uf_root = uf.roots()\n    for r in uf_root:\n        max_firiend = max(max_firiend, uf.size(r))\n\n    print(max_firiend)\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\nn, m = map(int, input().split())\n\nuf = UnionFind(n)\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    uf.union(a, b)\n\nprint(min(uf.parents)*-1)", "class UnionFind(): \n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\nN,M=list(map(int,input().split()))\n\nuf=UnionFind(N)\n\nfor i in range(M):\n    A,B=list(map(int,input().split()))\n    a=uf.find(A-1)\n    b=uf.find(B-1)\n    uf.union(a,b)\n\nans=0\n\nfor i in uf.roots():\n    ans=max(uf.size(i),ans)\n\nprint(ans)    \n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n                \n            \n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n        \n\n    \n\n\n\n\n\n\n\n\n\n    \n\n        \n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n    \n\n\n\n\n\n    \n\n\n\n\n\n\n        \n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \n    \n\n\n    \n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n", "N, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n\nuf = UnionFind(N)\nfor a, b in AB:\n    uf.union(a - 1, b - 1)\n\nmax_ = 0\nroots = uf.roots()\n\nfor r in roots:\n    max_ = max(max_, uf.size(r))\n\nprint(max_)\n", "n,m=map(int,input().split())\nclass UnionFind():\n    def __init__(self,n):\n        self.n=n\n        self.root=[-1]*(n+1)\n        self.rank=[0]*(n+1)\n      \n    def find(self,x):\n        if self.root[x]<0:\n            return x\n        else:\n            self.root[x]=self.find(self.root[x])\n            return self.root[x]\n    \n    def unite(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n        if x==y:\n            return 0\n        elif self.rank[x]>self.rank[y]:\n            self.root[x]+=self.root[y]\n            self.root[y]=x\n        else:\n            self.root[y]+=self.root[x]\n            self.root[x]=y\n        if self.rank[x]==self.rank[y]:\n            self.rank[y]+=1\n          \n    def isSame(self,x,y):\n        return self.find(x)==self.find(y)\n    \n    def size(self,x):\n        return -self.root[self.find(x)]\nlink=UnionFind(n)\nfor _ in range(m):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  link.unite(a,b)\nprint(-min(link.root))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \n      \nN, M = list(map(int,input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  A, B = list(map(int,input().split()))\n  A -= 1\n  B -= 1\n  uf.union(A, B)\n  \nans = 0\nfor i in range(N):\n  ans = max(ans, uf.size(i))\n  \nprint(ans)\n  \n", "def root(a):\n\tif p[a] == a:\n\t\treturn a\n\tp[a] = root(p[a])\n\treturn p[a]\n\ndef merge(a, b, p, size):\n\tra = root(a)\n\trb = root(b)\n\tif ra == rb:\n\t\treturn\n\tsize[rb] += size[ra]\n\tp[ra] = rb\n\nn,m = list(map(int, input().split()))\n\nsize = [1]*n\np = [0]*n\nfor i in range(n):\n\tp[i] = i\n\nfor i in range(m):\n\ta,b = list(map(int, input().split()))\n\ta -= 1\n\tb -= 1\n\tmerge(a,b,p,size)\n\nans = 0\nfor x in size:\n\tans = max(ans, x)\n\nprint(ans)\n", "N, M = (int(d) for d in input().split())\n\nC = [set() for i in range(N+1)]\nfor i in range(M):\n    A, B = (int(d) for d in input().split())\n    C[A].update([B])\n    C[B].update([A])\n\n# BFS\nseen = set()\nG = []\n\nfor i in range(1, N+1):\n    if i in seen:\n        continue\n\n    # create new group\n    G.append(set())\n\n    # create queue\n    Q = [i]\n    G[-1].update(Q)\n    seen.update(Q)\n\n    while len(Q) > 0:\n        # queue is not empty\n\n        I = Q.pop(0)\n        J = C[I].difference(seen)\n        Q += list(J)\n        G[-1].update(J)\n\n        seen.update(J)\n\nprint((max([len(g) for g in G])))\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):return -self.parents[self.find(x)]\n    def same(self, x, y):return self.find(x) == self.find(y)\n    def members(self, x):root = self.find(x);return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):return len(self.roots())\n    def all_group_members(self):return {r: self.members(r) for r in self.roots()}\n    def __str__(self):return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    def get_group(self):return [self.find(i)for i in range(self.n)]\n\nN,M=map(int,input().split())\nuf=UnionFind(N)\nfor i in range(M):\n    A,B=map(int,input().split())\n    uf.union(A-1,B-1)\nprint(max([uf.size(i)for i in range(N)]))", "# -*- coding utf-8 -*-\n\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, input().split()))\nAB_M = [list(map(int, input().split())) for _ in range(M)]\n\n# union find\nparents = [-1] * (N + 1)\n\n\ndef find(x):\n    if parents[x] < 0:\n        return x\n    else:\n        parents[x] = find(parents[x])\n        return parents[x]\n\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return\n\n    if parents[x] > parents[y]:\n        x, y = y, x\n\n    parents[x] += parents[y]\n    parents[y] = x\n\n\nfor ab in AB_M:\n    union(ab[0], ab[1])\n\nans = - min(parents)\n\nprint(ans)\n", "class UnionFind():\n  def __init__(self, n):\n    self.n=n\n    self.parents=[-1]*n\n\n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n\n  def unite(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n\n  def size(self, x):\n    return -self.parents[self.find(x)]\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i,x in enumerate(self.parents) if x<0]\n\nN,M=map(int,input().split())\nuf=UnionFind(N)\nfor _ in range(M):\n  a,b=map(int,input().split())\n  uf.unite(a-1,b-1)\nans=0\nfor r in uf.roots():\n  s=uf.size(r)\n  ans=max(ans,s)\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nn, m = map(int, input().split())\nu = UnionFind(n)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    u.union(a - 1, b - 1)\nprint(max(u.size(i) for i in range(n)))", "import statistics\nN,M=map(int,input().split())\nA=[0]*M;B=[0]*M\npar=[-1]*N\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    else:\n        par[x] += par[y]\n        par[y] = x\n        return True\n\nfor i in range(M):\n  A[i],B[i]=sorted(map(int,input().split()))\n  unite(A[i]-1,B[i]-1)\n\nprint(min(par)*-1)", "N, M = list(map(int, input().split()))\nA = [0] * M\nB = [0] * M\nR = [0] * N\nfor i in range(N):\n    R[i] = set()\n\nfor i in range(M):\n    A[i], B[i] = list(map(int, input().split()))\n    R[A[i]-1].add(B[i]-1)\n    R[B[i]-1].add(A[i]-1)\n\nstack = set()\nvisited = set()\nmax_groups = 0\n\nfor i in range(N):\n    if not i in visited:\n        stack.add(i)\n        groups = 0\n        while True:\n            current = stack.pop()\n            visited.add(current)\n            groups += 1\n            stack |= (R[current] - visited)\n            if not stack:\n                break\n        max_groups = max(max_groups,groups)\n\nprint(max_groups)", "import sys\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, M = list(map(int, input().split()))\n\nuf = UnionFind(N)\n\nans = 1\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    uf.union(a-1, b-1)\n    ans = max(ans, uf.size(a-1))\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -1 * self.parents[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i in range(1, self.n+1, 1) if self.parents[i] < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n\nN, M = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    uf.union(a, b)\nans = 0\nfor j in uf.roots():\n    ans = max(ans, uf.size(j))\nprint(ans)\n", "import sys\nfrom collections import deque, defaultdict, Counter\nfrom itertools import accumulate, product, permutations, combinations\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heappop, heappush\nfrom math import ceil, floor, sqrt, gcd, inf\nfrom copy import deepcopy\nimport numpy as np\nimport scipy as sp\n\nINF = inf\nMOD = 1000000007\n\nn, m = [int(i) for i in input().split()]\nA = [[int(i) for i in input().split()]for j in range(m)]    # n\u306f\u884c\u6570\n\ntmp = 0\nres = 0\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1 for i in range(n)]\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.parents[x] > self.parents[y]:\n                x, y = y, x\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    @property\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    @property\n    def group_count(self):\n        return len(self.roots)\n\n    @property\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots)\n\nuf = UnionFind(n)\nfor i in range(m):\n    x, y = A[i]\n    uf.union(x - 1, y - 1)\nfor i in uf.roots:\n    res = max(res, uf.size(i))\n\nprint(res)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\ndef main():\n    N, M = map(int, input().split())\n    uf = UnionFind(N)\n    for _ in range(M):\n        a,b = map(int,input().split())\n        a -= 1\n        b -= 1\n        uf.union(a,b)\n    ans = 0\n    for i in range(N):\n      ans = max(ans,uf.size(i))\n    print(ans)\nmain()", "from networkx.utils import UnionFind as UF\nn,m=map(int, input().split())\nuf=UF()\nfor _ in range(m):\n    a,b=map(int, input().split())\n    uf.union(a, b)\nans=1\nfor i in uf.to_sets():\n    ans=max(ans,len(i))\nprint(ans)", "import collections\nimport fractions\nimport itertools\nimport functools\nimport bisect\nimport heapq\nimport math\nimport operator\nimport sys\n\nsys.setrecursionlimit(10**9+7)\n\nN, M = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, n):\n        return -self.parents[self.find(n)]\n\ndef solve():\n    group = UnionFind(N)\n    for i in range(M):\n        a, b = [int(x)-1 for x in input().split()]\n        group.union(a, b)\n    ans = 0\n    for i in range(N):\n        ans = max(ans, group.size(i))\n    print(ans)\n    return 0\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "#!/usr/bin/env python3\nclass UnionFind:\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1] * (n + 1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0] * (n + 1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def Find_Root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if x == y:\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif self.rnk[x] > self.rnk[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if self.rnk[x] == self.rnk[y]:\n                self.rnk[y] += 1\n\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    uf = UnionFind(n)\n\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        uf.Unite(a, b)\n\n    for i in range(n):\n        i += 1\n        uf.isSameGroup(i, i)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, -uf.root[i + 1])\n\n    # print(uf.root)\n    print(ans)\n\n\nmain()\n", "from collections import deque\nn, m = list(map(int, input().split()))\n# \u96a3\u63a5\u884c\u5217\u306f\u4f5c\u3063\u3066\u304a\u304f\ng = [[] for i in [0]*(n+1)]\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    g[a].append(b)\n    g[b].append(a)\n\nvisited = [0 for i in [0]*(n+1)]\nans = 1\nfor i in range(n+1):\n  if visited[i]:\n    continue\n  Q = deque([i])\n  group_friend = 1\n  while Q:\n    q = Q.popleft()\n    visited[q] = 1\n    link = g[q]\n    for j in link:\n      if visited[j]:\n          continue\n      visited[j] = 1\n      group_friend += 1\n      Q.append(j)\n  ans = max(ans, group_friend)\nprint(ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    \nN, M = map(int, input().split())\n\nA = [0 for _ in range(M)]\nB = [0 for _ in range(M)]\n\nfor i in range(M):\n    A[i], B[i] = map(int,input().split())\n\nuf = UnionFind(N)\nfor i in range(M):\n    uf.union(A[i]-1, B[i]-1)\n\nans = 0\nfor i in range(uf.group_count()):\n    ans = max(ans, uf.size(i))\n\nprint(ans)", "import math\nimport string\nimport itertools\nimport fractions\nimport heapq\nimport collections\nimport re\nimport array\nimport bisect\nimport sys\nimport random\nimport time\ninf = 10**9\n\n\nclass UnionFind():\n\n    def __init__(self, n: int):\n        \"\"\"\n        \u81ea\u8eab\u304c\u89aa\u3067\u3042\u308c\u3070\u3001\u305d\u306e\u96c6\u5408\u306b\u5c5e\u3059\u308b\u9802\u70b9\u6570\u306b-1\u3092\u639b\u3051\u305f\u3082\u306e\n        \u305d\u3046\u3067\u306a\u3051\u308c\u3070\u89aa\u306eid\n        \"\"\"\n        self.r = [-1]*n\n\n    def root(self, x: int):\n        if self.r[x] < 0:\n            return x\n        self.r[x] = self.root(self.r[x])\n        return self.r[x]\n\n    def unite(self, x: int, y: int):\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return\n        if self.r[x] > self.r[y]:\n            x, y = y, x\n        self.r[x] += self.r[y]\n        self.r[y] = x\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    uf = UnionFind(n)\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        uf.unite(a-1, b-1)\n    print((-min(uf.r)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x) -> int:\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y) -> None:\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x) -> int:\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y) -> bool:\n        return self.find(x) == self.find(y)\n\n    def members(self, x) -> list:\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self) -> list:\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self) -> int:\n        return len(self.roots())\n\n    def all_group_members(self) -> dict:\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    def read(self,m):\n        for i in range(m):\n            a,b=list(map(int,input().split()))\n            self.union(a-1,b-1)\n\n    def solve(self):\n        print((max([self.size(i) for i in self.roots()])))\n\nn,m=list(map(int,input().split()))\na=UnionFind(n)\na.read(m)\na.solve()\n", "import networkx as nx\nn,m=map(int, input().split())\nuf=nx.utils.UnionFind()\nfor _ in range(m):\n    a,b=map(int, input().split())\n    uf.union(a, b)\nans=1\nfor i in uf.to_sets():\n    ans=max(ans,len(i))\nprint(ans)", "def find(target):\n    if parent[target] < 0:\n        return target\n    else:\n        parent[target] = find(parent[target])\n        return parent[target]\n\ndef is_same(x, y):\n    return find(x) == find(y)\n\ndef union(x, y):\n    root_x = find(x)\n    root_y = find(y)\n    if root_x == root_y:\n        return\n    if parent[root_x] > parent[root_y]:\n        root_x, root_y = root_y, root_x\n    parent[root_x] += parent[root_y]\n    parent[root_y] = root_x\n\n# \u4eca\u56de\u3053\u308c\u4f7f\u308f\u306a\u3044\u3051\u3069\u3001\u3069\u3053\u306b\u8ab0\u304c\u3044\u308b\u306e\u304b\u306f\u3053\u308c\u3067\u308f\u304b\u308b\ndef members(n, x):\n    root = find(x)\n    return [i for i in range(n) if find(i) == root]\n\ndef get_size(x):\n    return -parent[find(x)]\n\ndef get_root():\n    return [i for i, root in enumerate(parent) if root < 0]\nn, m = map(int, input().split())\nparent = [-1 for _ in range(n)]\nfor _ in range(m):\n    a, b = map(lambda x: int(x) - 1, input().split())\n    union(a, b)\nans = 0\nfor i in range(n):\n    ans = max(ans, get_size(i))\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.size=[1]*n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.size[x]+=self.size[y]\n        self.size[y]=self.size[x]\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=list(map(int,input().split()))\nuf = UnionFind(n)\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    uf.union(a-1,b-1)\nprint((max(uf.size)))\n", "# Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [i for i in range(n + 1)]\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return 0\n        elif x < y:\n            self.parents[y] = x\n        else:\n            self.parents[x] = y\n        return 1\n\nfrom collections import Counter\nn, m = list(map(int, input().split()))\nuf = UnionFind(n)\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    uf.unite(a, b)\nroots = []\nfor num in uf.parents:\n    roots.append(uf.find(num))\ncount_roots = Counter(roots)\nprint((max(count_roots.values())))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=map(int,input().split())\nuf=UnionFind(n)\nfor i in range(m):\n  a,b=map(int,input().split())\n  uf.union(a-1,b-1)\nans=0\nfor i in range(n):\n  ans=max(ans,uf.size(i))\nprint(ans)", "import statistics\nN,M=list(map(int,input().split()))\nA=[0]*M;B=[0]*M\npar=[-1]*N\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    else:\n        par[x] += par[y]\n        par[y] = x\n        return True\n\nfor i in range(M):\n  A[i],B[i]=sorted(map(int,input().split()))\n  unite(A[i]-1,B[i]-1)\n\nprint((min(par)*-1))\n", "import sys\nsys.setrecursionlimit(1000000)\n\nf=lambda:map(int,input().split())\nN,M=map(int,input().split())\n\n# par=[i for i in range(N+1)]\npar=[-1]*(N+1)\n\ndef find(x):\n    if par[x]<0:return(x)\n    else:\n        par[x]=find(par[x])\n        return(par[x])\n\ndef unite(x,y):\n    #print(\"unite1\",x,y)\n    x=find(x)\n    y=find(y)\n    #print(\"unite2\",x,y)\n    if x==y:return # root\u304c\u540c\u3058\u306a\u306e\u3067\u30de\u30fc\u30b8\u306f\u5fc5\u8981\u306a\u3044\n    if (par[x]>par[y]):x,y=y,x\n    par[x]+=par[y]\n    par[y]=x\n    #print(par)\n    return\n    \nfor i in range(M):\n    a,b=map(int,input().split())\n    unite(a,b)\n\nprint(-min(par[1:]))", "from collections import deque\nn, m = map(int, input().split())\nE = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    E[a].append(b)\n    E[b].append(a)\nflag = [True for _ in range(n)]\nans = 0\nfor i in range(n):\n    if flag[i]:\n        counter = 1\n        flag[i] = False\n        que = deque([i])\n        while que:\n            now = deque.popleft(que)\n            for j in E[now]:\n                if flag[j]:\n                    deque.append(que, j)\n                    counter += 1\n                    flag[j] = False\n        ans = max(ans, counter)\nprint(ans)", "# Union Find\n\n# x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\n\n\n# x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return False\n    else:\n        # size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n        if par[x] > par[y]:\n            x, y = y, x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n\n# x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef same(x, y):\n    return find(x) == find(y)\n\n\n# x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\n\n\n# \u521d\u671f\u5316\n# \u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\nn,m = map(int,input().split())\npar = [-1] * n\nans = 0\nfor i in range(m):\n    X,Y = map(int,input().split())\n    unite(X-1,Y-1)\n\nfor i in range(n):\n    ans = max(size(i),ans)\nprint(ans)", "# -*- coding: utf-8 -*-\n\n# \u5165\u529b\u3092\u6574\u6570\u306b\u5909\u63db\u3057\u3066\u53d7\u3051\u53d6\u308b\ndef input_int():\n    return int(input())\n\n\n# \u30de\u30a4\u30ca\u30b91\u3057\u305f\u5024\u3092\u8fd4\u5374\ndef int1(x):\n    return int(x) - 1\n\n\n# \u534a\u89d2\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u5165\u529b\u3092Int\u306b\u5909\u63db\u3057\u3066Map\u3067\u53d7\u3051\u53d6\u308b\ndef input_to_int_map():\n    return list(map(int, input().split()))\n\n\n# \u534a\u89d2\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u5165\u529b\u3092Int\u306b\u5909\u63db\u3057\u3066\u53d7\u3051\u53d6\u308b\ndef input_to_int_tuple():\n    return tuple(map(int, input().split()))\n\n\n# \u534a\u89d2\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u5165\u529b\u3092Int\u306b\u5909\u63db\u3057\u3066\u30de\u30a4\u30ca\u30b91\u3057\u305f\u5024\u3092\u53d7\u3051\u53d6\u308b\ndef input_to_int_tuple_minus1():\n    return tuple(map(int1, input().split()))\n\n\ndef main():\n    N, M = input_to_int_map()\n    AB = (input_to_int_tuple() for i in range(M))\n\n    from collections import defaultdict\n    friends = defaultdict(lambda :-1)\n\n    def root(x):\n        temp = friends[x]\n        if temp < 0:\n            return x\n        temp2 = root(temp)\n        friends[x] = temp2\n        return temp2\n\n    for a, b in AB:\n        a = root(a)\n        b = root(b)\n        if a == b:\n            continue\n\n        if (friends[a] > friends[b]):\n            temp = a\n            a = b\n            b = temp\n        friends[a] += friends[b]\n        friends[b] = a\n\n    ret = 0\n    for i in range(1, N + 1):\n        temp = root(i)\n        ret = max(ret, -friends[temp])\n\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class union_find():\n\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*(n+1)\n        self.rank = [0]*(n+1)\n\n    def find_root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if x == y:\n            return\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def cnt(self, x):\n        return -self.root[self.find_root(x)]\n\n\nn, m = map(int, input().split())\ng = union_find(n)\nans = 0\nfor _ in range(m):\n    a, b = map(int, input().split())\n    g.unite(a, b)\n\nfor i in range(1, n+1):\n    ans = max(ans, g.cnt(i))\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int,input().split())\n\nans = 0\n#UnionFind\u6728\u3092\u4f5c\u308b\nuf = UnionFind(N)\n\nfor _ in range(M):\n    a, b = map(int,input().split())\n    uf.union(a-1, b-1)\n\nparents = uf.roots()\n\nfor p in parents:\n    ans = max(ans,uf.size(p))\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = map(int,input().split())\nuf = UnionFind(n)\nfor i in range(m):\n    a, b = map(int, input().split())\n    uf.union(a-1, b-1)\nbox = []\nfor i in range(n):\n    box.append(uf.size(i))\nprint(max(box))", "class UnionFind():  # 0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    unionFind = UnionFind(n)\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        unionFind.union(a, b)\n\n    value = 0\n    for i in range(n):\n        value = max(value, unionFind.size(i))\n\n    print(value)\n\n\n__starting_point()", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\nn,m = readInts()\nuni = UnionFind(n)\nfor _ in range(m):\n    a,b = readInts()\n    a-=1\n    b-=1\n    uni.union(a,b)\nans = -1\nfor i in range(n):\n    ans = max(ans, uni.size(i))\nprint(ans)\n", "import collections\nimport fractions\nimport itertools\nimport functools\nimport bisect\nimport heapq\nimport math\nimport operator\nimport sys\n\nsys.setrecursionlimit(10**9+7)\n\nN, M = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, n):\n        return -self.parents[self.find(n)]\n\ndef solve():\n    group = UnionFind(N)\n    for i in range(M):\n        a, b = [int(x)-1 for x in input().split()]\n        group.union(a, b)\n    ans = 0\n    for i in range(N):\n        ans = max(ans, group.size(i))\n    print(ans)\n    return 0\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,m=map(int,input().split())\nU=UnionFind(n)\nfor i in range(m):\n  a,b=map(int,input().split())\n  a,b=a-1,b-1\n  U.union(a,b)\nprint(-min([i for i in U.parents]))", "n, m = list(map(int, input().split()))\n# friend array\nf = [i for i in range(n)]\n\n# \u53cb\u3060\u3061\u96c6\u5408\u306e\u4e2d\u3067\u6700\u5c0fID\u3092\u8fd4\u3059\ndef find(x):\n    if f[x] == x:\n        return x\n    ret = find(f[x])\n    f[x] = ret\n    return ret\n\n# \u53cb\u3060\u3061\u96c6\u5408\u3092\u4f5c\u308b\ndef union(x, y):\n    i, j = find(x), find(y)\n    f[max(i, j)] = min(i, j)\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    union(a, b)\n\ncnt = [0 for _ in range(n)]\nfor i in range(n):\n    cnt[find(i)] += 1\nprint((max(cnt)))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef __starting_point():\n  n,m=map(int,input().split())\n  uf=UnionFind(n)\n\n  for i in range(m):\n    a,b=map(int,input().split())\n    uf.union(a-1,b-1)\n  \n  ans=0\n  for i in range(n):\n    ans=max(ans,uf.size(i))\n  print(ans)\n__starting_point()", "N, M = map(int, input().split())\n \n \nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n \n \nu = UnionFind(N)\nfor _ in range(M):\n    a, b = map(int, input().split())\n    u.union(a - 1, b - 1)\n \nans = 0\nfor i in u.roots():\n    ans = max(u.size(i), ans)\n \nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m = list(map(int, input().split()))\nuf = UnionFind(n)\n\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    uf.union(a-1,b-1)\n\nans = 0\nfor i in range(n):\n    ans = max(ans, uf.size(i))\n\nprint(ans)\n", "import statistics\nN,M=map(int,input().split())\nA=[0]*M;B=[0]*M\npar=[-1]*N\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    else:\n        par[x] += par[y]\n        par[y] = x\n        return True\n\nfor i in range(M):\n  A[i],B[i]=sorted(map(int,input().split()))\n  unite(A[i]-1,B[i]-1)\n\nfor i in range(N):\n  par[i]*=-1\n\n#print(par)\nprint(max(par))", "#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return \n\n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n        \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\ndef __starting_point():\n    n,m = map(int,input().split())\n    unionfind = UnionFind(n)\n    for _ in range(m):\n        a,b = map(int,input().split())\n        unionfind.union(a-1, b-1)\n        \n    answer = []\n    for i in range(n):\n        answer.append(unionfind.size(i))\n\n    print(max(answer))\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(m)]\nuf = UnionFind(n)\nans = 0\nfor i in range(m):\n    uf.union(a[i][0]-1, a[i][1]-1)\nfor i in range(n):\n    ans = max(ans, uf.size(i))\nprint(ans)", "import networkx as nx\nn,m=map(int, input().split())\nuf=nx.utils.UnionFind()\nfor _ in range(m):\n    a,b=map(int, input().split())\n    uf.union(a, b)\nans=1\nfor i in uf.to_sets():\n    ans=max(ans,len(i))\nprint(ans)", "#\u30af\u30e9\u30b9\u30ab\u30eb\u6cd5\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x): #\u89aa\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y): #\u548c\u96c6\u5408\u306e\u751f\u6210\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x): #\u6240\u5c5e\u3059\u308b\u96c6\u5408\u306e\u5927\u304d\u3055\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\u5224\u5b9a\n        return self.find(x) == self.find(y)\n\n    def members(self, x): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\u5168\u5217\u6319\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self): #\u96c6\u5408\u306e\u30ea\u30fc\u30c0\u30fc\u5168\u5217\u6319\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self): #\u96c6\u5408\u306e\u6570\n        return len(self.roots())\n\n    def all_group_members(self): #\u8f9e\u66f8\u578b,{(\u30ea\u30fc\u30c0\u30fc\u306e\u756a\u53f7):(\u305d\u306e\u96c6\u5408\u306e\u8981\u7d20\u5168\u5217\u6319)}\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=map(int,input().split())\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    uf.unite(a-1,b-1)\nprint(-min(uf.parents))", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n)]  # \u89aa\n        self.rank = [1] * n  # \u6728\u306e\u9ad8\u3055\n        self.size = [1] * n  # size[i] \u306f i \u3092\u6839\u3068\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n\n    def find(self, x):  # x \u306e\u6839\u3092\u8fd4\u3059\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])  # \u7d4c\u8def\u5727\u7e2e\n            return self.parent[x]\n\n    def unite(self, x, y):  # x, y \u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.parent[x] = y\n                self.size[y] += self.size[x]\n            else:\n                self.parent[y] = x\n                self.size[x] += self.size[y]\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def is_same(self, x, y):  # x, y \u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\n        return self.find(x) == self.find(y)\n\n    def group_size(self, x):  # x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n        return self.size[self.find(x)]\n\n    def group_members(self, x):  # x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u3092\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):  # \u3059\u3079\u3066\u306e\u6839\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parent) if i == x]\n\n    def group_count(self):  # \u6728\u306e\u6570\u3092\u8fd4\u3059\n        return len(self.roots())\n\n    def all_group_members(self):  # \u3059\u3079\u3066\u306e\u6728\u306e\u8981\u7d20\u3092\u8f9e\u66f8\u3067\u8fd4\u3059\n        return {r: self.group_members(r) for r in self.roots()}\n\n    def __str__(self):  # print \u8868\u793a\u7528\n        return '\\n'.join('{}: {}'.format(r, self.group_members(r)) for r in self.roots())\n\n\nn, m = map(int, input().split())\nuf = UnionFind(n+1)\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    uf.unite(a, b)\n\nprint(max(uf.size))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \nN,M = map(int,input().split())\nuf = UnionFind(N)\nfor i in range(M):\n  a,b = map(int,input().split())\n  uf.union(a-1,b-1)\nmax = 0\nfor i in range(N):\n  if max < uf.size(i):\n    max = uf.size(i)\nprint(max)", "from collections import Counter\nimport math\nimport statistics\nimport itertools\n# H,W,K=map(int,input().split())\n#b=int(input())\n# c=[]\n# for i in a:\n#     c.append(int(i))\n# f = list(map(int,input().split()))\n#g = [list(map(lambda x: '{}'.format(x), list(input()))) for _ in range(a)]\n# h = []\n# for i in range(a):\n#     h.append(list(map(int,input().split())))\n#two = [list(input()) for _ in range(H)]#nizigen\n# lis=[]\n# for i in range(Q):\n#     lis.append(list(map(int,input().split())))\n# a=list(map(int,input().split()))\nN,M = list(map(int,input().split()))\npar = [i for i in range(1,N+1)]\nrank=[0]*N\n# rank = [0]*(N)\ndef find(x):\n    if par[x-1] == x:#\u81ea\u5206\u304c\u89aa\u3067\u3042\u308b\u304b\u3069\u3046\u304b\n        return x\n    else:\n        par[x-1] = find(par[x-1]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x-1]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    if rank[x-1] < rank[y-1]:\n        par[x-1] = y\n    else:\n        par[y-1] = x\n        if rank[x-1]==rank[y-1]:rank[x-1]+=1\n\nfor i in range(M):\n    a,b = list(map(int,input().split()))\n    unite(a,b)\n\ncnt=[0]*N\nfor i in range(N):\n    cnt[find(i)-1]+=1\nprint((max(cnt)))\n\n", "def A():\n    d, t, s = list(map(int, input().split()))\n    print((\"Yes\" if t*s>=d else \"No\"))\n\ndef B():\n    s = input()\n    t = input()\n    sa = len(s) - len(t)\n    ret = 10000000000\n    for i in range(sa+1):\n        cnt = 0\n        for j in range(len(t)):\n            if s[j+i] != t[j]: cnt += 1\n        ret = min(ret, cnt)\n    print(ret)\n\ndef C():\n    int(input())\n    A = list(map(int, input().split()))\n    S = sum(A)\n    T = 0\n    for e in A:\n        T += e*e\n    print(((S * S - T)//2))\n\nclass UF:\n    def __init__(self, N):\n        self.N = N\n        self.sz = [1] * N\n        self.par = [i for i in range(N)]\n        self.d = [1] * N\n\n    def find(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y: return False\n        if self.d[y] > self.d[x]:\n            self.par[x] = y\n            self.sz[y] += self.sz[x]\n        else:\n            self.par[y] = x\n            self.sz[x] += self.sz[y]\n            if self.d[x] == self.d[y]: self.d[x] += 1\n\ndef D():\n    n, m = list(map(int, input().split()))\n    uf = UF(n+1)\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        uf.unite(a, b)\n    print((max(uf.sz)))\n\nD()\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=nii()\nuf=UnionFind(n)\nfor i in range(m):\n  a,b=nii()\n  a-=1\n  b-=1\n  uf.union(a,b)\n\nroot=uf.roots()\nans=0\nfor i in root:\n  ans=max(ans,uf.size(i))\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = map(int,input().split())\nabl = [list(map(int,input().split())) for nesya in range(m)]\nuf = UnionFind(n)\nfor ab in abl:\n  uf.union(ab[0]-1,ab[1]-1)\nans = 0\nfor hoge in uf.roots():\n  ans = max(ans,uf.size(hoge))\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\n\nn, m = map(int, input().split())\npair = [-1]*n\n\ndef find(x):\n    if pair[x] < 0:\n        return x\n    else:\n        pair[x] = find(pair[x])\n        return pair[x]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return\n\n    pair[x] += pair[y]\n    pair[y] = x\n\ndef size(x):\n    x = find(x)\n    return -pair[x]\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    unite(x, y)\n\nmax_size = max(map(size, range(n)))\nprint(max_size)"]
["import sys\nimport heapq\n\nnnode,nedge,source,dest=list(map(int,sys.stdin.readline().split()))\nsource-=1;dest-=1\nadjl=[[] for _ in range(nnode)]\n\nfor _ in range(nedge):\n\tu,v=list(map(int,sys.stdin.readline().split()))\n\tu-=1;v-=1\n\tadjl[u].append(v)\n\tadjl[v].append(u)\n\n# why not BFS? >.<\ndef dijkstra_from(source):\n\tpq=[]\n\tdist=[10**9]*nnode\n\n\tdist[source]=0\n\theapq.heappush(pq,(dist[source],source))\n\twhile pq:\n\t\tdist_node,node=heapq.heappop(pq)\n\t\tif dist[node]!=dist_node: continue\n\n\t\tfor adj in adjl[node]:\n\t\t\tif dist[adj]>dist_node+1:\n\t\t\t\tdist[adj]=dist_node+1\n\t\t\t\theapq.heappush(pq,(dist[adj],adj))\n\n\treturn dist\n\nd_src=dijkstra_from(source)\nd_dst=dijkstra_from(dest)\n\nassert d_dst[source] == d_src[dest]\n\nans=0\nfor u in range(nnode):\n\tadj_to_u=[False]*u\n\tfor v in adjl[u]:\n\t\tif v<u:\n\t\t\tadj_to_u[v]=True\n\tfor v in range(u):\n\t\tif not adj_to_u[v]:\n\t\t\tif min(\n\t\t\td_dst[u]+d_src[v]+1,\n\t\t\td_src[u]+d_dst[v]+1\n\t\t\t)<d_src[dest]: continue\n\t\t\tans+=1\n\nprint(ans)\n", "R = lambda : map(int, input().split())\nn,m,s,t = R()\n\ngraph = [set() for _ in range(n)]\nedges = set()\n\nfor _ in range(m):\n    u,v = R()\n    graph[u-1].add(v-1)\n    graph[v-1].add(u-1)\n    edges.add((u-1,v-1))\n    edges.add((v-1,u-1))\n\nfrom collections import deque\ndef bfs(v):\n    q = deque()\n    q.append((v,0))\n    dis = {}\n    while q:\n        vertex = q.popleft();\n        dis[vertex[0]] = vertex[1]\n        for nv in graph[vertex[0]]:\n            if nv not in dis:\n                dis[nv] = vertex[1]+1\n                q.append((nv, vertex[1]+1))\n    return dis\n\nds = bfs(s-1)\ndt = bfs(t-1)\ndist = bfs(s-1)[t-1]\n\nres = (n*(n-1))//2-m\nfor i in range(n):\n    for j in range(i+1, n):\n        if (i,j) not in edges:\n            if ds[i]+dt[j]+1 < dist:\n                res -= 1\n            elif ds[j]+dt[i]+1 <dist:\n                res -= 1\n\nprint(res)", "#!/usr/bin/env python3\n\nimport sys\n\n[n, m, s1, t1] = list(map(int, sys.stdin.readline().strip().split()))\ns, t = s1 - 1, t1 - 1\ntos = [[] for _ in range(n)]\nfor _ in range(m):\n\t[u1, v1] = list(map(int, sys.stdin.readline().strip().split()))\n\tv, u = v1 - 1, u1 - 1\n\ttos[v].append(u)\n\ttos[u].append(v)\n\ndef S_l(v0, tos):\n\tn = len(tos)\n\tvisited = [False for _ in range(n)]\n\tvisited[v0] = True\n\tqueue = [v0]\n\thq = 0\n\tl = [0 for _ in range(n)]\n\twhile len(queue) > hq:\n\t\tu = queue[hq]\n\t\thq += 1\n\t\tfor v in tos[u]:\n\t\t\tif not visited[v]:\n\t\t\t\tl[v] = l[u] + 1\n\t\t\t\tqueue.append(v)\n\t\t\t\tvisited[v] = True\n\treturn l\n\nlt = S_l(t, tos)\nls = S_l(s, tos)\n\n\nd = lt[s]\ncount = 0\nfor u in range(n):\n\tfor v in range(u):\n\t\tif (v not in tos[u]) and (min(lt[u] + ls[v], lt[v] + ls[u]) + 1 >= d):\n\t\t\tcount += 1\n\n\n\nprint (count)\n", "n, m, s, t = list(map(int , input().split()))\ndors = []\nfor i in range(n+1):\n    dors.append(set()) # \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0441\u043c\u0435\u0436\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d\n\nfor i in range(m):\n    a, b = list(map(int , input().split()))\n    dors[a].add(b)\n    dors[b].add(a)\n\ndists = [-1] *(n+1)   # \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043e\u0442 \u0441\u0442\u0430\u0440\u0442\u0430\ndists[s] = 0\nq = [s]\nv = 0\nwhile v < len(q):\n    cur = q[v]\n    for nextv  in dors[cur]:\n        if dists[nextv] < 0:\n            dists[nextv] = dists[cur] +1\n            q.append(nextv)\n    v += 1\n\n\n\ndistt = [-1] *(n+1) # \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043e\u0442 \u0444\u0438\u043d\u0438\u0448\u0430\ndistt[t] = 0\nq = [t]\nv = 0\nwhile v < len(q):\n    cur = q[v]\n    for nextv  in dors[cur]:\n        if distt[nextv] < 0:\n            distt[nextv] = distt[cur] +1\n            q.append(nextv)\n    v += 1\n\n\n\nreqdist = dists[t] - dists [s] -1\n\nres  =0\n\n# print(dists)\n# print(distt)\n\nfor v in range(1, n+1):\n    for j in range(v+1, n+1):\n        if  (j in dors[v]):\n            continue\n        if dists[v] + distt[j] >= reqdist and dists[j] + distt[v] >= reqdist:\n            res +=1\n            # print(v,j, 'can be added')\n\n\nprint(res)\n\n# print(rset)\n", "n,m,s,e = list(map(int,input().split()))\ns -= 1\ne -= 1\nmd = []\ng = []\nfor i in range(n):\n    md.append([-1,-1])\n    g.append([])\nfor i in range(m):\n    u,v = list(map(int,input().split()))\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n\n#bfs\nmd[s][0] = 0\nd = 0\nst = [s]\nc = 1\n#print('s')\nwhile c < n:\n    #print(c)\n    d += 1\n    st2 = []\n    for node in st:\n        for p in g[node]:\n            if md[p][0] == -1:\n                st2.append(p)\n                md[p][0] = d\n\n    c+=len(st2)\n    st = st2[:]\n\n#bfs\nmd[e][1] = 0\nd = 0\nst = [e]\nc = 1\n#print('s')\nwhile c < n:\n    #print(c)\n    d += 1\n    st2 = []\n    for node in st:\n        for p in g[node]:\n            if md[p][1] == -1:\n                st2.append(p)\n                md[p][1] = d\n\n    c+=len(st2)\n    st = st2[:]\n#print(md)\ndis = md[e][0]\nt = 0\nfor i in range(n):\n    for j in range(i):\n        if j in g[i]:continue\n        if dis <= min(md[i][0] + md[j][1],md[j][0] + md[i][1])+1:\n            t += 1\nprint(t)\n", "n,m,s,t = list(map(int, input().split()))\nG = [[] for _ in range(n+1)]\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\n\ndists = [n+1]*(n+1)\ndistt = [n+1]*(n+1)\n\n# BFS find distance\nT = [s]\ncount = 0\nwhile T:\n    newT = [] \n    for i in T:\n        dists[i] = min(dists[i],count)\n        for j in G[i]:\n            if dists[j] == n+1:\n                newT.append(j)\n    count+=1\n    T = newT\n\nT = [t]\ncount = 0\nwhile T:\n    newT = [] \n    for i in T:\n        distt[i] = min(distt[i],count)\n        for j in G[i]:\n            if distt[j] == n+1:\n                newT.append(j)\n    count+=1\n    T = newT\n\ncount = 0\nmm = dists[t]\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        if j in G[i]:\n            continue\n        if min(dists[i] + distt[j] + 1, dists[j] + distt[i] + 1) < mm:\n            continue\n        count += 1\nprint(count)\n", "from queue import Queue\n\n\ndef BFS(v):\n    used = {k: -1 for k in range(1, n + 1)}\n\n    st = Queue()\n    st.put(v)\n    used[v] = 0\n\n    while not st.empty():\n        u = st.get()\n\n        for v in range(1, n + 1):\n            if graph[u][v] and used[v] == -1:\n                used[v] = used[u] + 1\n                st.put(v)\n\n    return used\n\n\nn, m, s, t = list(map(int, input().split()))\n\ngraph = {k: {k_: False for k_ in range(1, n + 1)} for k in range(1, n + 1)}\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n\n    graph[a][b] = True\n    graph[b][a] = True\n\nS = BFS(s)\nT = BFS(t)\n\nro = S[t]\nans = 0\n\nfor a in range(1, n + 1):\n    for b in range(1, n + 1):\n        if a != b and not graph[a][b] and S[a] + T[b] + 1 >= ro and S[b] + T[a] + 1 >= ro:\n            ans += 1\n\nprint(ans // 2)\n", "from array import array\nn, m, s, t = list(map(int, input().split()))\nneighbours = [array('H', [])]\nneighbours.clear()\nneighbours.append(0)\nneighbours.extend((array('H', []) for _ in range(n)))\nfor __ in range(m):\n\tu, v = list(map(int, input().split()))\n\tneighbours[u].append(v)\n\tneighbours[v].append(u)\ndist1 = array('H', [0]*(n+1))\nvisit = array('B', [0]+[1]*n)\nqueue = array('H', [s])\ndists = array('H', [0])\nindex = 0\nwhile index < len(queue):\n\tqi = queue[index]\n\tif visit[qi]:\n\t\tvisit[qi] = 0\n\t\tdi = dists[index]\n\t\tdist1[qi] = di\n\t\tfor oth in neighbours[qi]:\n\t\t\tqueue.append(oth)\n\t\t\tdists.append(di+1)\n\tindex += 1\ndist2 = array('h', [0]*(n+1))\nvisit = array('B', [0]+[1]*n)\nqueue = array('h', [t])\ndists = array('h', [dist1[t]])\nindex = 0\nwhile index < len(queue):\n\tqi = queue[index]\n\tif visit[qi]:\n\t\tvisit[qi] = 0\n\t\tdi = dists[index]\n\t\tdist2[qi] = di\n\t\tfor oth in neighbours[qi]:\n\t\t\tqueue.append(oth)\n\t\t\tdists.append(di-1)\n\tindex += 1\nres = 0\nfor s in range(1, n+1):\n\tfor t in range(1, s):\n\t\tif (s not in neighbours[t]) and (dist1[s]+1 >= dist2[t]) and (dist1[t]+1 >= dist2[s]):\n\t\t\tres += 1\nprint(res)\n", "from collections import *\ninf = int(1e9)\n\nn, m, s, t = map(int, input().split())\na = [set() for _ in range(n+1)]\nfor _ in range(m):\n\tu, w = map(int, input().split())\n\ta[u].add(w)\n\ta[w].add(u)\n\t\n# d1\nd1 = [inf] * (n + 1)\nq = deque([s])\nd1[s] = 0\nwhile q:\n\ti = q.popleft()\n\td = d1[i]\n\tfor j in a[i]:\n\t\tif d1[j] == inf:\n\t\t\tq.append(j)\n\t\t\td1[j] = d + 1\n\t\t\t\n# d2\nd2 = [inf] * (n + 1)\nq = deque([t])\nd2[t] = 0\nwhile q:\n\ti = q.popleft()\n\td = d2[i]\n\tfor j in a[i]:\n\t\tif d2[j] == inf:\n\t\t\tq.append(j)\n\t\t\td2[j] = d + 1\t\t\t\n\n# calc\nans = 0\nv = d1[t]\nfor i in range(1, n+1):\n\tfor j in range(i+1, n+1):\n\t\tif i not in a[j]:\n\t\t\tv1 = d1[i] + 1 + d2[j]\n\t\t\tv2 = d1[j] + 1 + d2[i]\n\t\t\tif v1 >= v and v2 >= v:\n\t\t\t\tans += 1\nprint(ans)\t", "rd = lambda: list(map(int, input().split()))\nn, m, s, t = rd()\na = [0] * (n + 1)\nb = a + []\nG = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = rd()\n    G[u].append(v)\n    G[v].append(u)\ndef bfs(x, a):\n    q = [x]\n    while q:\n        c = q.pop()\n        for y in G[c]:\n            if not a[y]:\n                a[y] = a[c] + 1\n                q.insert(0, y)\n    a[x] = 0\nbfs(s, a)\nbfs(t, b)\nprint(sum(min(a[i] + b[j], a[j] + b[i]) > a[t] - 2 for i in range(1, n + 1) for j in range(i + 1, n + 1)) - m)\n", "def dj( s ,dist,g):\n     dist[x] = 0\n     q = [s]\n     while q:\n          c = q.pop()\n          for to in g[c]:\n               if not dist[to]:\n                    dist[to] = dist[c]+1\n                    q.insert(0,to)\n     dist[s]=0\nn,m,s,f= [ int(x) for x in input().split()]\ns= s-1\nf = f-1\ng = [  [] for i in range(n)]\nfor i in range(m):\n     x,y = [ int(x) for x in input().split()]\n     x= x-1\n     y =y -1\n     g[x].append(y)\n     g[y].append(x)\nINF = int(1e9)\ndist_s = [0 for i in range(n)]\ndist_f = [0 for i in range(n)]\ndj(s,dist_s,g)\ndj(f,dist_f,g)\nres = 0\nfor i in range(n):\n     for j in range(i+1,n):\n          if dist_s[i] +dist_f[j]+1 >= dist_s[f] and dist_f[i] + dist_s[j] +1 >=dist_s[f] and (j not in g[i]):\n               res = res+1\nprint(res)\n\n\n", "n,k,s,t=map(int,input().split())\nm=[set() for i in range(n+1)]\nfor i in range(k):\n    a,b=map(int,input().split())\n    m[a].add(b)\n    m[b].add(a)\nforw=[-1]*(n+1)\nback=forw.copy()\ntake,push=[],[s]\nforw[s]=0\nway=0\nz=0\nwhile push:\n    way+=1\n    take,push=push,take\n    while take:\n        a=take.pop()\n        if a==t and not z:\n            z=way-1\n        for x in m[a]:\n            if forw[x]==-1:\n                forw[x]=way\n                push.append(x)\ntake,push=[],[t]\nback[t]=0\nway=0\nwhile push:\n    way+=1\n    take,push=push,take\n    while take:\n        a=take.pop()\n        for x in m[a]:\n            if back[x]==-1:\n                back[x]=way\n                push.append(x)\nans=0\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        if j not in m[i] and min(forw[j]+back[i],forw[i]+back[j])+1>=z:\n            ans+=1\nprint(ans)", "from collections import deque\n\n\ndef bfs(v):\n    dist = [-1] * n\n    used = [0] * n\n    q = deque([])\n    q.append(v)\n    dist[v] = 0\n    used[v] = 1\n    while q:\n        x = q.popleft()\n        for i in range(len(graph[x])):\n            if not used[graph[x][i]]:\n                used[graph[x][i]] = 1\n                dist[graph[x][i]] = dist[x] + 1\n                q.append(graph[x][i])\n    return dist\n  \n        \nn, m, s, t = map(int, input().split())\ns -= 1\nt -= 1\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\ndt = bfs(t)\nds = bfs(s)\ndist = ds[t]\nans = 0\nfor u in range(n - 1):\n    for v in range(u + 1, n):\n        if ds[u] + dt[v] + 1 >= dist and ds[v] + dt[u] + 1 >= dist:\n            ans += 1\nprint(ans - m)", "def bfs(s):\n    d = [0] * n\n    vs = {s}\n    nr = {s}\n    while len(vs) < n:\n        cr = nr\n        nr = set()\n        for u in cr:\n            for v in g[u] - vs:\n                vs.add(v)\n                d[v] = d[u] + 1\n                nr.add(v)\n    return d\n\n\nn, m, s, t = list(map(int, input().split()))\ns -= 1\nt -= 1\n\ng = [set() for _ in range(n)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    g[u].add(v)\n    g[v].add(u)\n\nds = bfs(s)\ndt = bfs(t)\nmindist = ds[t]\n\nans = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if min(ds[i] + dt[j], ds[j] + dt[i]) >= mindist - 1:\n            ans += 1\n\nprint(ans - m)\n", "from collections import deque\ndef bfs(v):\n    q = deque([])\n    q.append(v)\n    dist = [-1]*n\n    visit = [0]*n\n    q.append(v)\n    dist[v] = 0\n    visit[v] = 1\n    while q:\n        x = q.popleft()\n        for i in range(len(graph[x])):\n            if not visit[graph[x][i]]:\n                visit[graph[x][i]] = 1\n                dist[graph[x][i]] = dist[x]+1\n                q.append(graph[x][i])\n    return dist\n\nn , m , s , t = map(int, input().split())\ns-=1\nt-=1\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a,b = map(int, input().split())\n    a-=1\n    b-=1\n    graph[a].append(b)\n    graph[b].append(a)\nds = bfs(s)\ndt = bfs(t)\ndist = ds[t]\nans = 0\nfor u in range(n):\n    for v in range(u+1,n):\n        if ds[u] + dt[v] +1  >= dist and ds[v] + dt[u] +1 >= dist:\n            ans+=1\nprint(ans-m)", "n, m, s, t = [int(x) for x in input().split()]\ns -= 1\nt -= 1\ngraph = []\nfor i in range(n):\n    graph.append([])\nfor i in range(m):\n    v, u = [int(x) - 1 for x in input().split()]\n    graph[u].append(v)\n    graph[v].append(u)\nhead = 0\nq = [s]\nused = [0] * n\nds = [0] * n\nds[s] = 0\nused[s] = 1\nwhile head != n:\n    parent = q[head]\n    head += 1\n    for child in graph[parent]:\n        if not used[child]:\n            q.append(child)\n            used[child] = 1\n            ds[child] = ds[parent] + 1\nhead = 0\nq = [t]\nused = [0] * n\nused[t] = 1\ndt = [0] * n\ndt[t] = 0\nwhile head != n:\n    parent = q[head]\n    head += 1\n    for child in graph[parent]:\n        if not used[child]:\n            q.append(child)\n            used[child] = 1\n            dt[child] = dt[parent] + 1\nshort = ds[t]\ncount = 0\nfor v in range(n):\n    for u in range(v, n):\n        if dt[u] + ds[v] + 1 >= short and ds[u] + dt[v] + 1 >= short and u != v and v not in graph[u]:\n            count += 1\nprint(count)\n", "def get_amount_variants(routes, n, s, t):\n    \"\"\"\n    :param List[List[int]] routes:\n    :param int n:\n    :param int s:\n    :param int t:\n    :return: int\n    \"\"\"\n    connects = [[] for _ in range(n + 1)]\n    for st, end in routes:\n        connects[st].append(end)\n        connects[end].append(st)\n\n    w_h = get_shortest_ways(connects, s)\n    w_j = get_shortest_ways(connects, t)\n    amount = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if min(w_h[i] + w_j[j], w_h[j] + w_j[i]) + 1 >= w_h[t] and i not in connects[j]:\n                amount += 1\n    return amount\n\n\ndef get_shortest_ways(connects, st):\n    res = [int(1e9) if _ != st else 0 for _ in range(len(connects) + 1)]\n    available = [(x, 0) for x in connects[st]]\n    while len(available) > 0:\n        point, weight = available.pop(0)\n        if res[point] != 0 and res[point] < weight + 1:\n            continue\n\n        res[point] = weight + 1\n        available += [(x, weight + 1) for x in connects[point] if res[x] == int(1e9) and x != st]\n    return res\n\n\nn, m, s, t = map(int, input().strip().split())\nroutes = []\nfor i in range(m):\n    routes.append(map(int, input().split()))\nprint(get_amount_variants(routes, n, s, t))", "# Project name: Fight Against Traffic\n\nn,m,s,t = map(int, input().split())\na=[0]*(n+1)\nb=list(a)\ng= [[] for i in range(n+1)]\n\nfor i in range(m):\n    u,v = map(int, input().split())\n    g[u]+=[v]\n    g[v]+=[u]\n\ndef bfs(x, a):\n    q=[x]\n    while q:\n        c=q.pop()\n        for y in g[c]:\n            if not a[y]:\n                a[y] = a[c]+1\n                q.insert(0,y)\n    a[x]=0\n\nbfs(s,a)\nbfs(t,b)\n\nr=0\nfor i in range(1,n+1):\n    for j in range(i + 1, n + 1):\n        if not i in g[j] :\n            if min(a[i]+b[j]+1, a[j]+b[i]+1) >= a[t]:\n                r+=1\nprint (r)", "from collections import deque\n\nn,m,s,t = list(map(int,input().split(' ')))\nn += 1\na = list()\nfor i in range(n):\n  a.append(None)\nfor i in range(n):\n    a[i] = list()\nfor i in range(m):\n  u,v = list(map(int,input().split(' ')))\n  a[u].append(v)\n  a[v].append(u)\n\nresS = [n]*n\nresT = [n]*n\n\nresS[s] = 0\nresT[t] = 0\n\nq = deque() #\u043e\u0447\u0435\u0440\u0435\u0434\u044c\n\nq.append(s)\nwhile len(q)!=0:\n  w = q.popleft()\n  for i in a[w]:\n    if resS[i] <= resS[w]:\n        continue\n    q.append(i)\n    resS[i] = resS[w] + 1\n     \n\nq.append(t)\nwhile len(q)!=0:\n  w = q.popleft()\n  for i in a[w]:\n    if resT[i] <= resT[w]:\n        continue\n    q.append(i)\n    resT[i] = resT[w] + 1\n\nres = 0 \nfor i in range(1,n-1):\n  for j in range(i+1,n):\n    if not(j in a[i]) and resS[i]+resT[j]+1>=resS[t] and resT[i]+resS[j]+1>=resS[t]:\n      res += 1\n\nprint(res)", "from collections import deque\ndef bfs(s, level):\n    level[s] = 0\n    stack = deque([s])\n    while stack:\n        v = stack.popleft()\n        for w in g[v]:\n            if level[w] is -1:\n                stack.append(w)\n                level[w] = level[v] + 1\nn, m, s, t = map(int, input().split())\ng = []\nfor i in range(n):\n    g.append(set())\nfor i in range(m):\n    u, v = map(int, input().split())\n    g[u - 1].add(v - 1)\n    g[v - 1].add(u - 1)\na = [-1] * n\nb = [-1] * n\nbfs(s - 1, a)\nbfs(t - 1, b)\ncur = a[t - 1]\nans = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if (min(a[i] + b[j] + 1, a[j] + b[i] + 1) >= cur and (j not in g[i])):\n            ans += 1\nprint(ans)", "class Node:\n    def __init__(self, label):\n        self.label, self.ways, self.distances = label, set(), dict()\n\n    def connect(self, other):\n        self.ways.add(other)\n\n\nclass Graph:\n    def __init__(self, count):\n        self.nodes = [Node(i) for i in range(count)]\n\n    def connect(self, a, b):\n        node_a, node_b = self.nodes[a], self.nodes[b]\n        node_a.connect(node_b)\n        node_b.connect(node_a)\n\n    def fill_distances(self, start):\n        looked, queue, next_queue = {start}, {start}, set()\n        start.distances[start] = 0\n        while len(queue) + len(next_queue) > 0:\n            for node in queue:\n                for neighbour in node.ways:\n                    if neighbour not in looked:\n                        looked.add(neighbour)\n                        next_queue.add(neighbour)\n                        neighbour.distances[start] = node.distances[start] + 1\n            queue, next_queue = next_queue, set()\n\n\ndef repeat(elem): \n    while True: \n        yield elem\ndef readline(types=repeat(int)):\n    return [x[0](x[1]) for x in zip(types, input().split())]\n\n\ndef readinput():\n    nodes, edges, start, finish = readline()\n    start, finish = start - 1, finish - 1\n    \n    graph = Graph(nodes)\n    for i in range(edges):\n        a, b = readline()\n        a, b = a - 1, b - 1\n        graph.connect(a, b)\n\n    return graph, graph.nodes[start], graph.nodes[finish]\n\n\ndef main():\n    graph, start, finish = readinput()\n    graph.fill_distances(start)\n    graph.fill_distances(finish)\n\n    distance = start.distances[finish]\n    answer = 0\n    for i in range(len(graph.nodes)):\n        for j in range(i + 1, len(graph.nodes)):\n            node_a, node_b = graph.nodes[i], graph.nodes[j]\n            if node_a in node_b.ways: \n                continue\n            if node_a.distances[start] + 1 + node_b.distances[finish] < distance:\n                continue\n            if node_a.distances[finish] + 1 + node_b.distances[start] < distance:\n                continue\n            answer += 1\n\n    print(answer)\n\n\nmain()\n\n", "class Node:\n    def __init__(self, label):\n        self.label, self.ways, self.distances = label, set(), dict()\n\n    def connect(self, other):\n        self.ways.add(other)\n\n\nclass Graph:\n    def __init__(self, count):\n        self.nodes = [Node(i) for i in range(count)]\n\n    def connect(self, a, b):\n        node_a, node_b = self.nodes[a], self.nodes[b]\n        node_a.connect(node_b)\n        node_b.connect(node_a)\n\n    def fill_distances(self, start):\n        looked, queue, next_queue = {start}, {start}, set()\n        start.distances[start] = 0\n        while len(queue) + len(next_queue) > 0:\n            for node in queue:\n                for neighbour in node.ways:\n                    if neighbour not in looked:\n                        looked.add(neighbour)\n                        next_queue.add(neighbour)\n                        neighbour.distances[start] = node.distances[start] + 1\n            queue, next_queue = next_queue, set()\n\n\ndef repeat(elem): \n    while True: \n        yield elem\ndef readline(types=repeat(int)):\n    return map(lambda x: x[0](x[1]), zip(types, input().split()))\n\n\ndef readinput():\n    nodes, edges, start, finish = readline()\n    start, finish = start - 1, finish - 1\n    \n    graph = Graph(nodes)\n    for i in range(edges):\n        a, b = readline()\n        a, b = a - 1, b - 1\n        graph.connect(a, b)\n\n    return graph, graph.nodes[start], graph.nodes[finish]\n\n\ndef main():\n    graph, start, finish = readinput()\n    graph.fill_distances(start)\n    graph.fill_distances(finish)\n\n    distance = start.distances[finish]\n    answer = 0\n    for i in range(len(graph.nodes)):\n        for j in range(i + 1, len(graph.nodes)):\n            node_a, node_b = graph.nodes[i], graph.nodes[j]\n            if node_a in node_b.ways: \n                continue\n            if node_a.distances[start] + 1 + node_b.distances[finish] < distance:\n                continue\n            if node_a.distances[finish] + 1 + node_b.distances[start] < distance:\n                continue\n            answer += 1\n\n    print(answer)\n\n\nmain()", "def bfs(beg,deeps,d):\n    levels=[beg]\n    while levels:\n        cur=levels.pop()\n        for x in d[cur]:\n            if deeps[x]==0:\n                deeps[x]=deeps[cur]+1\n                levels.insert(0,x)\n    deeps[beg]=0\n    return\n\nn,m,s,t=list(map(int,input().split()))\n\nd=[[] for i in range(n+1)]\n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    d[x].append(y)\n    d[y].append(x)\n\nfroms=[0 for i in range(n+1)]\nfromt=[0 for i in range(n+1)]\n\nbfs(s,froms,d)\nbfs(t,fromt,d)\n\nans=0\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        ij=min(froms[i]+fromt[j]+1,froms[j]+fromt[i]+1)\n        if ij>=froms[t]: ans+=1\nprint(ans-m)\n", "import sys\nimport heapq\nclass Node(object):\n    def __init__(self,name):\n        self.name=name\n        self.minDistance=sys.maxsize\n        self.paths=[]\n        self.baap=None\n    def __lt__(self,other):\n        return(self.minDistance<other.minDistance)\nclass Path(object):\n    def __init__(self,start,end,weight):\n        self.start=start\n        self.end=end\n        self.weight=weight\nclass Dijkstra(object):\n    def __init__(self,nodelist,start):\n        self.nodelist=nodelist\n        self.start=start\n    def calculateShortestPath(self):\n        queue=[]\n        self.nodelist[int(self.start)-1].minDistance=0\n        heapq.heappush(queue,nodelist[int(self.start)-1])\n        while len(queue)>0:\n            actualNode=heapq.heappop(queue)\n            for i in actualNode.paths:\n                u=self.nodelist[int(i.start)-1]\n                v=self.nodelist[int(i.end)-1]\n                newdis=u.minDistance+i.weight\n                if newdis<v.minDistance:\n                    v.minDistance=newdis\n                    v.baap=u\n                    heapq.heappush(queue,v)\n    def disp(self):\n        arr=[]\n        for i in self.nodelist:\n          arr.append(i.minDistance)\n        return arr\n#Dj till here\n    \n\nn,m,s,t=list(map(int,input().split(' ')))\nn,m=int(n),int(m)\nnodelist=[]\nfor i in range(1,n+1):\n    nodelist.append(Node(str(i)))\npathdd=[]\nfor i in range(n):\n  temp=[]\n  for j in range(n):\n    temp.append(-1)\n  pathdd.append(temp)\nfor i in range(m):\n    st,en=input().split(' ')\n    pathdd[int(st)-1][int(en)-1]=1;pathdd[int(en)-1][int(st)-1]=1;\n    nodelist[int(st)-1].paths.append(Path(st,en,1))\n    nodelist[int(en)-1].paths.append(Path(en,st,1))\ndij=Dijkstra(nodelist,s)\ndij.calculateShortestPath()\ndn1=dij.disp()#minimum Distance of all nodes from source node\nmindis=dn1[t-1]\nfor i in nodelist:\n  i.minDistance=sys.maxsize#Reinitializing all distance to infinity\ndij=Dijkstra(nodelist,t)\ndij.calculateShortestPath()\ndn2=dij.disp()#minimum distance of all nodes from target node\n#print(dn1,\"\\n\",dn2);\nctr=0\nfor u in range(len(nodelist)-1):\n  for v in range(u+1,len(nodelist)):\n    if dn1[u]+1+dn2[v]>=mindis and dn1[v]+dn2[u]+1>=mindis and pathdd[u][v]==-1:\n      ctr+=1;\nprint(ctr)\n", "from collections import deque, namedtuple\nfrom heapq import *\nfrom sys import stdin\n\ninf = float('inf')\nEdge = namedtuple('Edge', 'start, end, cost')\n\n\ndef make_edge(start, end, cost=1):\n    return Edge(start, end, cost)\n\n\nclass Graph:\n    def __init__(self, edges, bi=True):\n        wrong_edges = [i for i in edges if len(i) not in [2, 3]]\n        if wrong_edges:\n            raise ValueError('Wrong edges data: {}'.format(wrong_edges))\n        self.edges = [make_edge(*edge) for edge in edges]\n        self.vertices = set(\n            sum(\n                ([edge.start, edge.end] for edge in self.edges), []\n            ))\n        self.neighbors = {vertex: set() for vertex in self.vertices}\n        for edge in self.edges:\n            self.neighbors[edge.start].add(edge.end)\n\n    def get_node_pairs(self, n1, n2, both_ends=True):\n        if both_ends:\n            node_pairs = [[n1, n2], [n2, n1]]\n        else:\n            node_pairs = [[n1, n2]]\n        return node_pairs\n\n    def remove_edge(self, n1, n2, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        edges = self.edges[:]\n        for edge in edges:\n            if[edge.start, edge.end] in node_pairs:\n                self.edges.remove(edge)\n\n    def add_edge(self, n1, n2, cost=1, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        for edge in self.edges:\n            if [edge.start, edge.end] in node_pairs:\n                return ValueError('Edge {} {} already exists'.format(n1, n2))\n\n        self.edges.append(Edge(start=n1, end=n2, cost=cost))\n        if both_ends:\n            self.edges.append(Edge(start=n2, end=n1, cost=cost))\n\n    def dijkstra(self, source, dest):\n        assert source in self.vertices, 'Such source node doesn\\'t exist'\n        distances = {vertex: inf for vertex in self.vertices}\n        distances[source] = 0\n\n        q, seen = [(0, source)], set()\n        while q:\n            (curr_cost, current_vertex) = heappop(q)\n            if current_vertex in seen:\n                continue\n            seen.add(current_vertex)\n            for neighbor in self.neighbors[current_vertex]:\n                cost = 1\n                if neighbor in seen:\n                    continue\n                alternative_route = distances[current_vertex] + cost\n                if alternative_route < distances[neighbor]:\n                    distances[neighbor] = alternative_route\n                    heappush(q, (alternative_route, neighbor))\n\n        return distances\n\n\nn, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]\n\nverts = []\nfor i in range(m):\n    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))\nrev_verts = []\nfor i in verts:\n    rev_verts.append((i[1], i[0]))\nfor i in rev_verts:\n    verts.append(i)\ngraph = Graph(verts)\ns_dist = graph.dijkstra(s, t)\nt_dist = graph.dijkstra(t, s)\nSHORTEST_DIST = s_dist[t]\ncount = 0\n\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if j not in graph.neighbors[i] and \\\n                i not in graph.neighbors[j] and \\\n                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \\\n                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:\n            count = count + 1\n\nprint(count)\n"]
["n, s = int(input()), input()\ncnt = (n - 11) // 2\ncnt_8 = len(s[:n - 10].split('8')) - 1\nif (cnt >= cnt_8):\n\tprint (\"NO\")\nelse:\n\tprint (\"YES\")", "def main():\n    n = int(input())\n    arr = list(map(int, input()))\n    a = arr.count(8)\n    if a <= (n - 11) // 2:\n        print(\"NO\")\n        return 0\n    i = -1\n    cnt = 1 + (n - 11) // 2\n    while cnt:\n        i += 1\n        if arr[i] == 8:\n            cnt -= 1\n    if i > n - 11:\n        print(\"NO\")\n        return 0\n    print(\"YES\")\n    return 0\n\nmain()", "N = int(input())\nS = input()\nA, B = 0, 0\nfor i in range(N-10):\n    if S[i] == \"8\":\n        A += 1\n    else:\n        B += 1\nif A > B:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "from collections import Counter\n\nn = int(input())\ns = list(input())\n\nc = Counter(s[:-10])\nif c['8'] > len(s[:-10]) // 2:\n\tprint('YES')\nelse:\n\tprint('NO')", "n = int(input())\ns = input()\ncnt = 0\nfor i in range(n - 10):\n    if s[i] == '8':\n        cnt += 1\nif cnt >= ((n - 9) // 2):\n    print('YES')\nelse:\n    print('NO')\n", "from sys import *\nfrom math import *\nfrom collections import *\n\nN = int(input())\n\nS = input()\n\n\ne = deque([])\nn = deque([])\n\nfor i, v in enumerate(S):\n    if v == '8':\n        e += [i]\n    else:\n        n += [i]\n\ntodo = (N - 11) // 2\n\nfor i in range(todo):\n    if len(n) != 0:\n        n.popleft()\n    else:\n        e.pop()\n        \n    if len(e)!= 0:\n        e.popleft()\n    else:\n        n.pop()\n\nif len(e) != 0 and (len(n) == 0 or n[0] > e[0]):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n\n", "n = int(input())\ns = input()\nnum = (n - 11) // 2\nnum2 = 0\nnum3 = -1\nfor i in range(n):\n    if s[i] == \"8\":\n        num2 += 1\n        if num2 == num + 1:\n            num3 = i\n            break\nif num3 == -1 or num3 > num * 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n", "n = int(input())\ns = input()\n\ncnt = 0\nfor i in range(n - 10):\n\tif s[i] == '8':\n\t\tcnt += 1\nsteps = (n - 11) // 2\nif cnt <= steps:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")", "n = int(input())\ns = input()\nif s[:n-10].count('8')> (n-11)//2:\n    print('YES')\nelse:\n    print('NO')\n", "n=int(input())\ns=input()\nt=s[:-10]\ncnt=t.count('8')\nif len(t)-cnt>=cnt:\n    print('NO')\nelse:\n    print('YES')", "def main():\n    n = int(input())\n    s = input()\n    eight = 0\n    for i in range(n-11+1):\n        if s[i] == '8':\n            eight += 1\n\n    if eight > (n-11)//2:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n", "n = int(input())\ns = input()\n\ntorem = n - 11\n\nif s[:torem+1].count('8') > (torem+1)//2:\n    print('YES')\nelse:\n    print('NO')\n", "n, s = int(input()), input()\ns = s[:n-10]\na = s.count('8')\nb = len(s) - a\nprint('YES' if a >= b else 'NO')", "if (int(input()) - 9) // 2 <= input()[:-10].count('8'):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "s = int(input())\nstring = input()\ncounter = 0\narray = []\nfor i in range(len(string)):\n    if string[i] == '8':\n        counter += 1\n        array.append(i)\nif (s - 11) // 2 >= counter:\n    print('NO')\nelif (s - 11) // 2 < counter:\n    if array[0] > (s - 11) // 2:\n        print('NO')\n    elif array[(s - 11) // 2] - ((s - 11) // 2) <= (s - 11) // 2:\n        print('YES')\n    elif array[(s - 11) // 2] - ((s - 11) // 2) > (s - 11) // 2:\n        print('NO')\nelse:\n    print('YES')", "n = int(input())\nx = input()\n\nr = (n-11)//2\np = x[:2*r+1]\nif p.count(\"8\") >= r+1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n=int(input())\ns=input()\nt=s[:-10]\ncnt=t.count('8')\nif len(t)-cnt>cnt:\n    print('NO')\nelse:\n    print('YES')", "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nS=input().strip()\n\nP=(N-11)//2\n\nfrom collections import deque\nL=deque(S)\ncount=0\n\nfor j in range(P):\n    while len(L)!=0 and L[0]==\"8\":\n        L.popleft()\n        count+=1\n\n    if len(L)==0:\n        print(\"YES\")\n        return\n\n    L.popleft()\n\n    while len(L)!=0 and L[0]==\"8\":\n        L.popleft()\n        count+=1\n\nif count>P:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "import sys\nn = int(input())\ns = input()\nk = (n - 11) // 2\nlicz = 0\nfor i in range(n):\n\tif s[i] == '8':\n\t\tlicz += 1\nif licz <= k:\n\tprint(\"NO\")\n\treturn\nlicz = 0\ni = -1\nwhile True:\n\ti += 1\n\tif s[i] == '8':\n\t\tlicz += 1\n\tif licz == k + 1:\n\t\tbreak\nif i > 2 * k:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")", "n = int(input())\ns = str(input())\ncount = 0\np = []\nfor i in range(n):\n\tif s[i] == \"8\":\n\t\tcount+=1\n\t\tp.append(i)\nmoves = int((n - 11)/2)\nif moves >= count:\n\tprint(\"NO\")\n\treturn\nelse:\n\tif p[moves] <= 2*moves:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")  \n\n", "input()\ns=input()\nnot8=[i for i, c in enumerate(s) if c!='8']\nis8=[i for i, c in enumerate(s) if c=='8']\n\nn=len(s)\nmoves=(n-11)//2\n\nif moves >= len(not8):\n    print('YES')\n    raise SystemExit(0)\nif moves >= len(is8):\n    print('NO')\n    raise SystemExit(0)\n\nnot8 = not8[moves:]\nis8 = is8[moves:]\n\n# print(not8, is8)\n\nif is8[0] < not8[0]:\n    print('YES')\n    raise SystemExit(0)\nelse:\n    print('NO')\n    raise SystemExit(0)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    st = list(input())\n    x = (n-11)//2\n    y = x\n    li = []\n    for i in st:\n        if i!='8':\n            li.append(i)\n        else:\n            x-=1\n            if x==-1:\n                break\n    print(\"YES\") if len(li)<=y else print(\"NO\")\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main(i) \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "N = int(input())\nS = input()\nturns = (N - 11) // 2\ncnt = 0\nfor i in range(N - 10):\n    if S[i] == '8':\n        cnt += 1\nif cnt >= turns + 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "# coding: utf-8\nimport sys\nfrom heapq import heappush, heappop, heapify\nsys.setrecursionlimit(int(1e7))\n\ndef main():\n    n = int(input().strip())\n    s = input().strip()\n    V = [i for i in range(n) if s[i]!='8']\n    P = [i for i in range(n) if s[i]=='8']\n    heapify(V)\n    heapify(P)\n    while len(V)+len(P)>11 and len(V)*len(P)>0:\n        heappop(V)\n        heappop(P)\n    yes = len(V)==0 or (len(V)*len(P)>0 and P[0]<V[0])\n    print('YES' if yes else 'NO')\n    return\n\nwhile 1:\n    try: main()\n    except EOFError: break", "n = int(input())\nx = list(input())\na = (n-11+1)//2\nb = (n-11)//2\nfor i,ch in enumerate(x):\n    if ch == '8':\n        if b > 0:\n            b -= 1\n            x[i] = None\n    else:\n        if a > 0:\n            a -= 1\n            x[i] = None\nfor c in x:\n    if c != None:\n        if c != '8':\n            print(\"NO\")\n        else:\n            print(\"YES\")\n        break"]
["n = int(input())\np = [int(i) for i in input().split()]\ns = [0] * n\nfor i in range(1,n):\n    s[i] = s[i-1] ^ i\nq = 0\nfor i in range(n):\n    q = q ^ p[i]\n    if (n // (i+1)) % 2 == 1:\n        q = q ^ s[i]\n    q = q ^ s[n % (i+1)]\nprint(q)\n", "import functools\nimport operator\n\n\nmem = [0]\nfor i in range(1, 10 ** 6):\n\n    mem.append(mem[-1] ^ i)\n\nn = int(input())\nps = tuple(map(int, str.split(input())))\nx = functools.reduce(operator.xor, ps)\nfor i in range(n):\n\n    c, m = divmod(n, i + 1)\n    if c & 1:\n\n        x ^= mem[i]\n\n    x ^= mem[m]\n\nprint(x)\n", "n=int(input())\n\nL=list(map(int,input().split()))\nQ=0\n\nX=[0]*1000001\n\nfor i in range(1,1000001):\n    X[i]=X[i-1]^i\n\nfor i in range(1,n+1):\n    Q^=L[i-1]\n    x=n%i\n    y=n//i\n    if(y%2==1):\n        Q^=X[i-1]\n    Q^=X[x]\nprint(Q)\n", "n, p = int(input()), list(map(int, input().split()))\ns, q = 0, list(range(n + 1))\nfor i in range(1, n + 1):\n    q[i] ^= q[i - 1]\n    if (n // i) & 1: s ^= q[i - 1]\n    s ^= q[n % i]\nfor i in p: s ^= i\nprint(s)", "n = int(input())\np = map(int, input().split())\nf = list(range(n+1))\nfor i in range(1, n + 1):\n    f[i] ^= f[i-1]\nsum = 0\nfor i in p:\n    sum ^= i\nc = []\nc.append(0)\nfor i in range(1, n + 1):\n    if (n // i) & 1:\n        c.append(f[i - 1] ^ f[n % i])\n    else:\n        c.append(f[n % i])\n    sum ^= c[i]\nprint(sum)", "\nfrom functools import reduce\n\nR = lambda: map(int, input().split())\n\nn = int(input())\na = R()\nans = reduce(lambda x, y: x ^ y, a)\nf = [0]\nfor i in range(1, n + 1):\n    f.append(f[-1] ^ i)\n\nfor i in range(1, n + 1):\n    if (n // i) % 2:\n        ans ^= f[i - 1]\n    ans ^= f[n % i]\n\nprint(ans)", "t, maxn = [0], 1000005\nfor i in range(1, maxn):\n    t.append(t[-1] ^ i)\nn, res = int(input()), 0\nv = [int(i) for i in input().split()]\nfor i in v:\n    res ^= i\nfor i in range(1, n+1):\n    if (n//i) % 2 == 1:\n        res = res ^ (t[i-1]) ^ (t[n%i])\n    else: res ^= t[n%i]\nprint(res)\n", "def main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n\n    chunk = []\n    base = 0\n    for i in range(n + 1):\n        base ^= i\n        chunk.append(base)\n\n    Q = 0\n    for i, num in enumerate(nums):\n        q = num\n        chunks, res = divmod(n, i + 1)\n        q ^= chunk[res]\n        if chunks % 2 == 1:\n            q ^= chunk[i]\n        Q ^= q\n\n    print(Q)\n\n\nmain()\n", "n=int(input())\n\nL=list(map(int,input().split()))\nQ=0\n\nX=[0]*1000001\n\nfor i in range(1,1000001):\n    X[i]=X[i-1]^i\n\nfor i in range(1,n+1):\n    Q^=L[i-1]\n    x=n%i\n    y=n//i\n    if(y%2==1):\n        Q^=X[i-1]\n    Q^=X[x]\nprint(Q)", "\nimport re\nimport inspect\nfrom sys import argv, exit\n\ndef rstr():\n    return input()\n\ndef rint():\n    return int(input())\n\ndef rints(splitchar=' '):\n    return [int(i) for i in input().split(splitchar)]\n\ndef varnames(obj, namespace=globals()):\n    return [name for name in namespace if namespace[name] is obj]\n\ndef pvar(var, override=False):\n    prnt(varnames(var), var, override=override)\n\ndef prnt(*args, override=False):\n    if '-v' in argv or override:\n        print(*args)\n\ndef get_qi(p, i, n, F):\n    if (n // i) % 2 == 1: # even\n        return p ^ F[i-1] ^ F[n % i]\n    else:\n        return p ^ F[n % i]\n\ndef __starting_point():\n    n = rint()\n    p = rints()\n\n    # Pre-populate F as the cumulative xor of i\n    F = [0 for i in range(n)]\n    for i in range(1, n):\n        F[i] = F[i-1] ^ i\n\n    qs = [get_qi(p, i+1, n, F) for i, p in enumerate(p)]\n    Q = None\n    for q in qs:\n        if Q is None:\n            Q = q\n        else:\n            Q ^= q\n    print(Q)\n\n__starting_point()", "n,a=int(input()),list(map(int,input().split()))\nx,s=[0]*(n+1),0\nfor i in range(1,n+1):\n  x[i]=i^x[i-1]\n  if (n//i)%2:s^=x[i-1]\n  s^=x[n%i]\n  s^=a[i-1]\nprint(s)", "n = int(input())\np = list(map(int, input().split()))\n\nf = [0]\nfor i in range(1, n+1):\n  f.append(f[i-1] ^ i)\n\nres = 0\nfor i in range(1, n+1):\n  res = res ^ p[i-1] ^ (f[i-1] * ((n // i) % 2)) ^ f[n % i]\n\nprint(res)\n", "n = int(input())\np = [int(i) for i in input().split()]\ncap_P = 0\nfor i in p:\n    cap_P ^= i\nX = [0]*(n + 1)\nfor i in range(1, n + 1):\n    X[i] = X[i-1]^i\nfor i in range(2, n + 1):\n    a = n//i\n    r = n%i\n    cap_P ^= X[r]^(X[i-1] if a%2 else 0)\nprint(cap_P)\n", "n,a=int(input()),list(map(int,input().split()))\nx,s=[0]*(n+1),0\nfor i in range(1,n+1):\n  x[i]=i^x[i-1]\n  if (n//i)%2:s^=x[i-1]\n  s^=x[n%i]\n  s^=a[i-1]\nprint(s)", "n,a=int(input()),list(map(int,input().split()))\n\nx,s=[0]*(n+1),0\n\nfor i in range(1,n+1):\n\n  x[i]=i^x[i-1]\n\n  if (n//i)%2:s^=x[i-1]\n\n  s^=x[n%i]\n\n  s^=a[i-1]\n\nprint(s)\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\np = [int(x) for x in input().split()]\n\nd = [0 for i in range(n + 1)]\n\nfor i in range(2, n + 1):\n    d[i] -= n // i\n    d[n % i + 1] -= 1\n    d[0] += n // i + 1\nsum = 0\na = []\nfor i in d:\n    sum += i\n    a.append(sum)\nans = 0\nfor i in p:\n    ans ^= i\nfor i in range(1, len(a)):\n    if a[i] % 2 == 1:\n        ans ^= i\nprint(ans)", "import sys\nfrom math import *\nfrom fractions import gcd\nreadints=lambda:list(map(int, input().strip('\\n').split()))\n\nn=int(input())\na=list(readints())\n\n\n# for k in range(1,9):\n#     buf=''\n#     for i in range(1,9):\n#         buf+=str(i%k)+' '\n#     print(buf)\n\nP=0\nfor p in a:\n    P = P ^ p\n\nmaxn = 10**6 + 5\nprefix=[0]*maxn\nfor i in range(1,maxn):\n    prefix[i] = prefix[i-1]^i\n\n\n\ncur = 0\nfor k in range(1,n+1):\n    base=n//k\n    if base%2==1:\n        cur = cur ^ prefix[k-1]\n    cur = cur ^ prefix[n%k]\n\n\nQ = cur ^ P\nprint(Q)\n    \n", "n,a=int(input()),list(map(int,input().split()))\nx,s=[0]*(n+1),0\nfor i in range(1,n+1):\n\tx[i]=i^x[i-1]\n\tif (n//i)%2:s^=x[i-1]\n\ts^=x[n%i]\n\ts^=a[i-1]\nprint(s)\n", "from functools import reduce\nfrom itertools import accumulate\nfrom operator import xor\nn = int(input())\nres = reduce(xor, map(int, input().split()))\npre = [*accumulate(range(n + 1), xor)]\nfor i in range(1, n + 1):\n    res ^= pre[n % i]\n    if (n // i) & 1:\n        res ^= pre[i - 1]\nprint(res)", "'''input\n3\n1 2 3\n'''\n\nfrom sys import stdin, stdout\n\n\n# main starts\nn = int(stdin.readline().strip())\narr = list(map(int, stdin.readline().split()))\nval1 = 0\nfor i in arr:\n\tval1 ^= i\n\nstore = [0] * (n + 1)\nfor i in range(1, n + 1):\n\tc = n // i\n\tstore[0] += c\n\tstore[i] -= c\n\tr = n % i\n\tif r >= 1:\n\t\tstore[1] += 1\n\t\tif r + 1 <= n:\n\t\t\tstore[r + 1] -= 1 \n\nstore[0] %= 2\nfor i in range(1, len(store)):\n\tstore[i] += store[i - 1]\n\tstore[i] %= 2\n\nfor i in range(len(store)):\n\tif store[i] != 0:\n\t\tval1 ^= i\nprint(val1)", "\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n\n    xor = [0 for i in range(n + 1)]\n    for i in range(n):\n        xor[i + 1] = xor[i] ^ (i + 1)\n    \n    ans = 0\n    for i in range(n):\n        ans ^= p[i]\n    \n    for i in range(n):\n        a = n % (2 * (i + 1))\n        if a >= i + 1:\n            ans ^= xor[i] ^ xor[a - (i + 1)]\n        else:\n            ans ^= xor[a]\n    print(ans) \n    \n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ninf = float(\"inf\")\n# sys.setrecursionlimit(10000000)\n\n# abc='abcdefghijklmnopqrstuvwxyz'\n# abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n# mod, MOD = 1000000007, 998244353\n# words = {1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine',10:'ten',11:'eleven',12:'twelve',13:'thirteen',14:'fourteen',15:'quarter',16:'sixteen',17:'seventeen',18:'eighteen',19:'nineteen',20:'twenty',21:'twenty one',22:'twenty two',23:'twenty three',24:'twenty four',25:'twenty five',26:'twenty six',27:'twenty seven',28:'twenty eight',29:'twenty nine',30:'half'}\n# vow=['a','e','i','o','u']\n# dx,dy=[0,1,0,-1],[1,0,-1,0]\n\n# import random\n# from collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import ceil,floor,log,sqrt,factorial,pi,gcd\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\ndef running_xor(n):\n    if n%4==0:\n        return n\n    elif n%4==1:\n        return 1\n    elif n%4==2:\n        return (n+1)\n    else:\n        return 0\n\nn = int(input())\nArr = get_array()\nans = 0\nfor i in range(1,n):\n    div = n//(i+1)\n    if div&1:\n        ans ^=running_xor(i)\n    remainder = n%(i+1)\n    ans ^= running_xor(remainder)\n# print(ans)\nfor i in Arr:\n    ans ^= i\nprint(ans)\n", "def com(n) :  \n    if n % 4 == 0 : \n        return n \n    if n % 4 == 1 : \n        return 1 \n    if n % 4 == 2 : \n        return n + 1 \n    return 0\nn = int(input())\nlis=list(map(int,input().split()))\nans=0\nfor i in range(1,n+1):\n    a=com(i-1)\n    rem=n%i\n    b=com(rem)\n    if (n//i)%2==1:\n        ans^=(a^b^lis[i-1])\n    else:\n        ans^=(b^lis[i-1])\nprint(ans)            \n\n", "from functools import reduce\nfrom operator import xor\nfrom itertools import accumulate\n\nn, a = int(input()), list(map(int, input().split()))\narr, mem = [0], list(accumulate([i for i in range(n + 1)], lambda x, y: x ^ y))\n\n\nif n > 1:\n    if n % 2:\n        arr.append(0 if (n // 2) % 2 else 1)\n    else:\n        arr.append(0 if ((n - 1) // 2) % 2 else 1)\n\nfor i in range(3, n + 1):\n    if n % i == 0:\n        arr.append(mem[i - 1] if (n // i) % 2 else 0)\n    else:\n        arr.append(mem[n % i] ^ mem[i - 1] if (n // i) % 2 else mem[n % i])\n\n# print(arr)\nprint(reduce(xor, arr) ^ reduce(xor, a))\n"]
["import numpy as np\nn,s=map(int,input().split())\na=list(map(int,input().split()))\nmod=998244353\ndp=np.zeros([n+1,s+1],int)\ndp[0][0]=1\nfor i in range(1,n+1):\n  dp[i][:]=dp[i-1][:]*2\n  dp[i][a[i-1]:]+=dp[i-1][:-a[i-1]]\n  dp[i][:]%=mod\nprint(dp[n][s])", "import numpy as np\n\nMOD = 998244353\n\ndef main():\n    n, s = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    dp = np.zeros((n+1, s+1), dtype=np.int64)\n    dp[0][0] = 1\n    for i, v in enumerate(a):\n        dp[i+1] += dp[i]*2\n        if v <= s:\n            dp[i+1][v:] += dp[i][:-v]\n        dp[i+1] %= MOD\n    print((int(dp[n][s])%MOD))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nn,s = map(int,input().split())\na = list(map(int,input().split()))\ndp = np.zeros(s+1, dtype=np.int64)\n\"\"\"\ndp[i][j] := i\u756a\u76ee\u307e\u3067\u3092\u9078\u3093\u3067\u3001\u548c\u304c\u3061\u3087\u3046\u3069j\u306e\u3068\u304d\u306e\u5834\u5408\u306e\u6570\n\u9077\u79fb \u2192 1\u5897\u3048\u308b\u3068\u5168\u4f53\u96c6\u5408\u306b\u9078\u3076, A\u306b\u306f\u9078\u3070\u306a\u3044, A\u306b\u9078\u3076\u306e3\u7a2e\u985e.\n\"\"\"\nmod = 998244353\ndp[0] = 1\nfor i in range(n):\n\tp = (dp * 2) % mod\n\tp[a[i]:] += dp[:-a[i]]\n\tdp = p % mod\nprint(dp[s])", "def main():\n    import sys\n    mod = 998244353\n    def input(): return sys.stdin.readline().rstrip()\n    n,s = map(int, input().split())\n    a = list(map(int, input().split()))\n    dp = [0]*(s+1)\n    dp[0] = 1\n    import numpy as np\n    dp = np.array(dp)\n    for i in range(n):\n        dp[a[i]:] = (2*dp[a[i]:]%mod + dp[:-a[i]])%mod\n        dp[:a[i]] *= 2\n        dp[:a[i]] %= mod\n    print(dp[-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nN, S = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\nmod = 998244353\ncoef = np.zeros(3001, dtype=int)\ncoef[0] = 1\nfor a in A:\n    coef2 = coef[:-a].copy()\n    coef *= 2\n    coef[a:] += coef2\n    coef %= mod\nprint((coef[S]))\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())[:-1]\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [list(input())[:-1] for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\nimport numpy as np\nN,S = list(map(int,input().split()))\nMOD = 998244353\nA = list(map(int,input().split()))\ndp = np.zeros(S+1,dtype = np.int64)\ndp[0] = 2\nif A[0] <= S:\n    dp[A[0]] = 1\nfor i in range(1,N):\n    a = A[i]\n    p = dp*2\n    if a <= S:\n        p[a:] += dp[:-a]\n    p %= MOD\n    dp = p\nprint((dp[S]))\n\n    \n\n\n\n", "import numpy as np\n\nN, S = list(map(int, input().split()))\nA = np.array(list(map(int, input().split())))\nP = 998244353\ntable = np.zeros((N, S+1), dtype=int)\ntable[0, 0] = 2\nif A[0] <= S:\n    table[0, A[0]] = 1\nfor i in range(1, N):\n    Ai = A[i]\n    table[i] += 2*table[i-1]\n    if Ai <= S:\n        table[i][Ai:] += table[i-1][:S-Ai+1]\n    table[i] = table[i]%P\n\nprint((table[N-1][S]))\n", "import numpy as np\n\nn, s = list(map(int, input().split()))\na = list(map(int, input().split()))\nmod = 998244353\n\ndp = np.zeros(s + 1, np.int64)\ndp[0] = 1\n\nfor e in a:\n    pre = dp.copy()\n\n    dp = 2 * pre\n    dp[e:] += pre[:-e]\n    dp %= mod\n\nans = dp[s]\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 998244353\nINF = 10 ** 15\nimport numpy as np\n\ndef main():\n    N,S = map(int,input().split())\n    A = list(map(int,input().split()))\n\n    dp = np.zeros(S + 1,np.int64)\n    dp[0] = pow(2,N,MOD)\n    inv2 = pow(2,MOD - 2,MOD)\n    for a in A:\n        dp[a:] = np.mod(dp[a:] + dp[:-a] * inv2,MOD)\n    print(dp[S])\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\np = 998244353\n\nN,S = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\ndp = np.zeros(S+1)\ndp[0] = 1\nfor a in A:\n  if S < a:\n    dp *= 2\n    dp %= p\n    continue\n  tmp = 2*dp\n  dp = np.append(np.zeros(a),dp[:S-a+1])\n  dp += tmp\n  dp %= p\nprint(int(dp[S]))", "import numpy as np\n\nn,s = map(int, input().split())\na = list(map(int, input().split()))\n\nMOD = 998244353\n\ndp = np.zeros(s+1,dtype=int) #\u52d5\u7684\u8a08\u753b\u6cd5\u3092\u7528\u3044\u308b\ndp[0] = 1\n\nfor i in range(n):\n    ddp = dp * 2 % MOD\n    ddp[a[i]:] += dp[:-a[i]] #\u975e\u5e38\u306b\u5927\u304d\u306a\u6570\u306b\u306a\u308b\u3068\u8003\u3048\u3089\u308c\u308b\u305f\u3081\u5148\u306bMOD\u8a08\u7b97\u3092\u884c\u3046\n    dp = ddp % MOD\n\n\nprint(dp[s])", "import numpy as np\ndef main():\n    n,s=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    dp=np.array([0 for i in range(min(3001,s+1))])\n    dp[0]=1\n    for ai in A:\n        tmp=dp[:-ai].copy()\n        #print(tmp)\n        dp*=2\n        dp[ai:]+=tmp\n        dp%=998244353\n    print((dp[s]))\n    \n\ndef __starting_point():\n    main()\n\n        \n\n\n__starting_point()", "import numpy as np\n\nN,S = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nMOD = 998244353\n\ndp = np.zeros(S + 1, dtype=int)\ndp[0] = 1\n\nfor i in A:\n    ep = dp.copy()\n    ep += dp\n    ep[i:] += dp[:-i]\n    dp = ep % MOD\n\nprint((dp[S]))\n", "mod1,mod2=10**9+7,998244353\nmod=mod2\nn,s=map(int,input().split())\ndp=[0]*(s+1)\ndp[0]=1\nfor a in map(int,input().split()):\n    dp=[(2*dp[i]+(0 if i<a else dp[i-a]))%mod for i in range(s+1)]\nprint(dp[-1])", "import numpy as np\n\nN, S = list(map(int, input().split()))\nA = list(map(int, input().split()))\nmod = 998244353\nf = np.zeros(3100, np.int64)\n\nans = 0\nf[0] = 1\nfor a in A:\n    g = f.copy()\n    f[a:] += g[:-a]\n    f += g\n    f %= mod\n\nprint((f[S]))\n\n", "n, s = map(int, input().split())\na = list(map(int, input().split()))\nimport numpy as np\nmod = 998244353\nf = np.zeros(3020, np.int64)\nf[0] = 1\nfor b in a:\n  ff = 2*f\n  ff[b:] += f[:-b]\n  ff %= mod\n  f = ff\nprint(f[s])", "N,S=map(int,input().split())\nA=list(map(int,input().split()))\nimport numpy as np\nd=np.zeros((N+1,S+1),dtype=np.int64)\nd[0,0]=1\nm=998244353\nfor i in range(N):\n    d[i+1]=d[i]*2%m\n    d[i+1,A[i]:]=(d[i+1,A[i]:]+d[i,:-A[i]])%m\nprint(d[-1,-1])", "N,S=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\ndef f(N,S,A):\n    MOD=998244353\n    dp=[0]*(S+1)\n    dp[0]=pow(2,N,MOD)\n    div=pow(2,MOD-2,MOD)\n    m=0\n    for a in A:\n        m+=a\n        for i in range(min(m,S),a-1,-1):\n            dp[i]=(dp[i]+dp[i-a]*div)%MOD\n    return dp[S]\n\nprint((f(N,S,A)))\n", "import numpy as np\nMOD = 998244353\n\nN,S = list(map(int,input().split()))\nA = list(map(int,input().split()))\ncoefs = np.array([0]*(S+1))\ncoefs[0] = 1\n\nfor i in range(N):\n    tmp = coefs[:]\n    coefs = coefs*2\n    coefs[A[i]:] += tmp[:-A[i]]\n    coefs%=MOD\n    \nprint((coefs[-1]))\n    \n\n", "import sys\n\nimport numpy as np\n\ninput = lambda: sys.stdin.readline().rstrip()\nMOD = 998244353\n\nN, S = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\ndp = np.zeros(S + 1, np.int64)\ndp[0] = 1\nfor a in A:\n    f = 2 * dp\n    f[a:] += dp[:-a]\n    f %= MOD\n    dp = f\n\nprint((dp[S]))\n", "#!/usr/bin/env python3\nimport sys\nimport numpy as np\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    n, s = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    mod = 998244353\n    dp = np.zeros(3001, dtype=np.int64)\n    dp[0] = 1\n    for AA in A:\n        dp = dp*2+np.concatenate([np.zeros(AA, dtype=np.int64), dp[:3001-AA]])\n        dp %= mod\n    print((dp[s]))\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, s = map(int, input().split())\n    A = np.array([int(i) for i in input().split()])\n\n    MOD = 998244353\n\n    dp = np.zeros(s + 1, dtype=\"int32\")\n    dp[0] = 1\n\n    for i in range(n):\n        p = (dp * 2) % MOD\n        p %= MOD\n        p[A[i]:] += dp[:-A[i]]\n        dp = p % MOD\n\n    print(dp[s])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\ndef finalFunc(n,s,A):\n    var=np.array([0 for i in range(min(3001,s+1))])\n    var[0]=1\n    for i in A:\n        tmp=var[:-i].copy()\n        var*=2\n        var[i:]+=tmp\n        var%=998244353\n    return var[s]\nn,s=map(int,input().split())\nA=list(map(int,input().split()))\nprint(finalFunc(n,s,A))", "n,s=map(int,input().split())\na=[int(j)for j in input().split()]\ndp=[0]*(3000+1)\ndp[0]=1\nimport numpy as np\npre=np.array(dp)\nmod=998244353\nfor i in a:\n    dp=pre*2\n    dp[i:]+=pre[:-i]\n    dp%=mod\n    pre=dp\nprint(dp[s])", "import numpy as np\nN,S=map(int,input().split())\nAs=list(map(int,input().split()))\n\nMOD=998244353\n\n#d = [[0]*3001 for _ in range(3001)]\nd=np.zeros((3001,3001))\nd[0,0]=1\n\nfor i in range(1,N+1):\n    Ai=As[i-1]\n    d[i] += 2*d[i-1]\n    d[i,Ai:] += d[i-1][:-Ai]\n    d[i] %= MOD\nprint(int(d[N][S]))", "import numpy as np\n\nMOD = 998244353\n\nN, S = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\ndp = np.zeros((N, S + 1))\ndp[0, 0] = 2\nif A[0] < S + 1:\n\tdp[0, A[0]] = 1\n\nfor i in range(1, N):\n\tdp[i, :] = (2 * dp[i - 1, :]) % MOD\n\tif A[i] > S:\n\t\tcontinue\n\tdp[i, A[i] : S + 1] += dp[i - 1, 0 : S - A[i] + 1]\n\tdp[i, :] %= MOD\nprint(int(dp[N - 1, S]))", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, s = map(int, input().split())\n    A = [int(i) for i in input().split()]\n\n    MOD = 998244353\n\n    dp = np.zeros(s + 1, dtype=\"int32\")\n    dp[0] = 1\n\n    for a in A:\n        p = (dp * 2) % MOD\n        p %= MOD\n        p[a:] += dp[:-a]\n        dp = p % MOD\n\n    print(dp[s])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nmod = 998244353\n\nn, s = list(map(int, input().split()))\nA = list(map(int, input().split()))\nDP = np.zeros(3005, dtype=np.int64)\nDP[0] = 1\n\nfor a in A:\n    double = DP * 2\n    shift = np.hstack([np.zeros(a), DP[:-a]]).astype(np.int64)\n    DP = double + shift\n    DP %= mod\n\nprint((DP[s]))\n", "import numpy as np\nn,s=map(int, input().split( ))\n*a,=map(int, input().split( ))\nl=min(s+1,3001)\ndp=np.zeros(l,dtype = int)\ndp[0]=1\nmod=998244353\nans=0\ncnt=0\nfor ai in a:\n    #dp2=dp.copy()\n    dp2=dp[:-ai].copy()\n    dp*=2\n    dp[ai:]+=dp2#[:-ai]\n    #ans+=dp[s]*pow(2,n-cnt,mod)\n    #dp=dp2\n    #ans%=mod\n    dp%=mod\nprint(dp[s])", "import numpy as np\n\nMOD = 998244353\n \nn,s = map(int, input().split())\na = list(map(int,input().split()))\n\n\nfac_inv2 = pow(2,MOD-2,MOD)\n\ndp = np.zeros(s,\"int64\")\n\nfor i in range(n):\n    \n    newdp = dp.copy()\n    if a[i]<s:\n        newdp[a[i]:] += dp[:s-a[i]] * fac_inv2 % MOD\n    if a[i]<=s:\n        newdp[a[i]-1] += 1\n    dp = newdp % MOD\n\nans = dp[-1]\nans *= pow(2,n-1,MOD)\nans %= MOD\nprint(ans)", "import numpy as np\nN, S = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nmod = 998244353\n\n\ndp = np.zeros(S+1)\n\ndp[0] = 1\n\nfor i in range(N):\n    tmp = dp*2\n    tmp[a[i]:] += dp[:-a[i]]\n    dp = tmp % mod\n\nprint(int(dp[S]))", "import numpy as np\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\n\nclass Polynomial:\n    def __init__(self,dim=0,const=1):\n        self.values = [(dim,const)]\n    def __add__(self,other):\n        return self.values + other.values\n\n\nclass PolySolver:\n    def __init__(self,size):\n        self.size = size\n        self.f = np.zeros(size, np.int64)\n        self.f[0] = 1\n\n\n    def multiple(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u304b\u3051\u5408\u308f\u305b\u308b\n        new_F = np.zeros(self.size, np.int64)\n        for dim,const in polynomial:\n            if dim != 0:\n                g = np.zeros(self.size, np.int64)\n                g[dim:] += self.f[:-dim]\n            else:\n                g = const * self.f.copy()\n            new_F += g\n\n        self.f = new_F\n        self.f %= MOD\n\n    \n    def get_coefficient(self,dim):\n        return self.f[dim]\n    \ndef main():\n    N,S=mi()\n    A=list(mi())\n    MOD = 998244353\n\n    poly = PolySolver(3010)\n    for a in A:\n        f = Polynomial(const=2) + Polynomial(dim=a)\n        poly.multiple(f,MOD)\n\n    print(poly.get_coefficient(S))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nN, S = list(map(int, input().split()))\nA = tuple(map(int, input().split()))\nMOD = 998244353\n\ndp = np.zeros((N + 1, S + 1), dtype=np.int64)\ndp[0][0] = 1\nfor i in range(N):\n    dp[i + 1] = dp[i] * 2\n    dp[i + 1, A[i]:] += dp[i, :-A[i]]\n    dp[i + 1] %= MOD\n\nprint((dp[N][S]))\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    import numpy as np\n\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    MOD = 998244353\n\n    dp = np.zeros(S + 1, dtype=\"int32\")\n    dp[0] = 1\n\n    for i in range(N):\n        p = (dp * 2) % MOD\n        p[A[i]:] += dp[:-A[i]]\n        dp = p % MOD\n\n    print(dp[S])\n\nmain()", "import numpy as np\n\nmod = 998244353\nn, s = map(int, input().split())\ndp = np.zeros(s+1, dtype=int)\ndp[0] = 1\nfor a in map(int, input().split()):\n  pre_dp = dp\n  dp = pre_dp * 2 % mod\n  dp[a:] = (dp[a:] + pre_dp[:-a]) % mod\nprint(dp[-1])", "mod = 998244353\n\nN, S, *A = map(int, open(0).read().split())\n\ndp = [1] + [0] * S\nfor i, a in enumerate(A, 1):\n    dp = [(2 * dp[j] + (dp[j - a] if j >= a else 0)) % mod for j in range(S + 1)]\n\nprint(dp[S])", "def f_knapsack_for_all_subsets_power_series(MOD=998244353, MAX=3010):\n    # \u53c2\u8003: https://maspypy.com/atcoder-\u53c2\u52a0\u611f\u60f3-2020-05-31abc-169\n    import numpy as np\n    N, S = [int(i) for i in input().split()]\n    A = [int(i) for i in input().split()]\n\n    f = np.zeros(MAX + 1, np.int64)  # \u6b21\u6570\u304c S \u3088\u308a\u5927\u304d\u306a\u9805\u306b\u306f\u8208\u5473\u306a\u3044\u305f\u3081\u3001\u3053\u3046\u3059\u308b\n    f[0] = 1  # f_{0}(x) = 1\n    for a in A:\n        # f_{n+1} = f_{n} * (2 + x**a) = 2 * f_{n} + x**a * f_{n}\n        f_next = 2 * f  # \u7b2c\u4e00\u9805\n        f_next[a:] += f[:-a]  # \u7b2c\u4e8c\u9805\n        f_next %= MOD\n        f = f_next\n    return f[S]\n\nprint(f_knapsack_for_all_subsets_power_series())", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    MOD = 998244353\n    inv2 = pow(2, MOD-2, MOD)\n\n    N, S = list(map(int, input().split()))\n    As = list(map(int, input().split()))\n\n    dp = [0] * (S+1)\n    dp[0] = pow(2, N, MOD)\n    for A in As:\n        for k in reversed(list(range(S-A+1))):\n            dp[k+A] += dp[k] * inv2\n            dp[k+A] %= MOD\n\n    print((dp[-1]))\n\n\nsolve()\n", "import numpy as np\n\nmod = 998244353\nn, s = map(int, input().split())\ndp = np.zeros((n+1, s+1), dtype=int)\ndp[0, 0] = 1\nfor i, a in enumerate(map(int, input().split())):\n  dp[i+1] = dp[i] * 2 % mod\n  dp[i+1][a:] = (dp[i+1][a:] + dp[i][:-a]) % mod\nprint(dp[-1, -1])", "from copy import copy\nimport numpy as np\nN,S=list(map(int,input().split()))\nA=list(map(int,input().split()))\ndp=np.zeros(S+100,np.int64)\ndp[0]=1\nfor i in range(N):\n    buf=copy(dp)\n    dp=2*dp\n    dp[A[i]:]+=buf[:-A[i]]\n    dp%=998244353\nprint((dp[S]%998244353))\n", "import numpy as np\n\nn, s = list(map(int, input().split()))\na = [int(i) for i in input().split()]\n\nmod = 998244353\ndp = np.zeros(s+1, dtype='i8')\ndp[0] = 1\nfor aa in a:\n    tmp = 2 * dp % mod\n    tmp[aa:] += dp[:-aa]\n    tmp %= mod\n    dp = tmp\nprint((dp[s]))\n", "import numpy as np\n\nmod = 998244353\n\nn, s = list(map(int, input().split()))\nA = list(map(int, input().split()))\nDP = np.zeros(3005, dtype=np.int64)\nDP[0] = 1\n\nfor a in A:\n    double = DP * 2\n    double[a:] += DP[:-a]  # shift\n    DP = double % mod\n\nprint((DP[s]))\n", "def main():\n    mod = 998244353\n    n, s = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a = [i for i in a if i <= s]\n    dp = [0 for i in range(s+1)]\n    half = pow(2, mod-2, mod)\n    for i in a:\n        dp2 = [j for j in dp]\n        dp2[i] = (dp2[i]+pow(2, n-1, mod)) % mod\n        for j in range(s-i+1):\n            dp2[j+i] = (dp2[j+i]+dp[j]*half) % mod\n        dp = dp2\n    print((dp[s]))\n\n\nmain()\n", "import numpy as np\n\nn, s = list(map(int, input().split()))\na = list(map(int, input().split()))\nmod = 998244353\n\ndp = np.zeros(s + 1, np.int64)\ndp[0] = 1\n\nfor e in a:\n    pre = dp.copy()\n    dp = pre * 2\n    dp[e:] += pre[:-e]\n    dp %= mod\n\nans = dp[s]\nprint(ans)\n", "import numpy as np\n\ndef main():\n    MOD = 998244353\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    \n    # dp = [[0] * (S + 1) for i in range(N + 1)]\n    # dp[0][0] = 1\n    \n    dp = np.zeros(S + 1, np.int64)\n    dp[0] = 1\n    \n    for i, a in enumerate(A, start=1):\n        # i - 1 \u756a\u76ee\u307e\u3067\u306e\u6570\u3067 \u5408\u8a08\u304c X \u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u304c\n        # dp[i-1][X] \u500b\u3042\u308b\u306e\u3067\u3042\u308c\u3070\u3001\n        # \u305d\u306edp[i-1][X] \u500b \u306e\u305d\u308c\u305e\u308c\u306b\u5bfe\u3057\u3066Ai \u3092\u52a0\u3048\u308b/\u52a0\u3048\u306a\u3044\u306e\n        # 2\u30d1\u30bf\u30fc\u30f3\u304c\u8003\u3048\u3089\u308c\u308b\u306e\u3067\u3001dp[i-1]\u30922\u500d\u3059\u308b\n        dp_next = 2 * dp\n        \n        # \u3055\u3089\u306b\u3001i - 1 \u756a\u76ee\u307e\u3067\u306e\u6570\u3067 \u5408\u8a08\u304c X - Ai \u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u304c\n        # dp[i-1][X - Ai] \u500b\u3042\u308b\u5834\u5408\u3001\n        # i\u756a\u76ee\u306e\u6570(Ai)\u3092\u8db3\u3059\u3053\u3068\u3067\u5408\u8a08\u3092X\u306b\u3067\u304d\u308b\n        dp_next[a:] += dp[:-a] # dp[:-a] = dp[:len(dp)-a]       \n\n        # \u5927\u304d\u304f\u306a\u308a\u3059\u304e\u306a\u3044\u3088\u3046\u306b\u9010\u6b21MOD\u3092\u3068\u308b\n        dp_next %= MOD\n        \n        dp = dp_next\n\n    # print(*dp, sep='\\n')\n    print(dp[S])\n\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 998244353\nN, S = lr()\nA = lr()\ndp = np.zeros(S+1, np.int64)\ndp[0] = 1\nfor a in A:\n    prev = dp.copy()\n    dp[a:] += dp[:-a]\n    dp += prev\n    dp %= MOD\n\nanswer = dp[S]\nprint((answer%MOD))\n", "import numpy as np\nMOD = 998244353\n\ndef main():\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    dp = np.zeros((n+1, s+1), dtype=np.int64)\n    dp[0][0] = 1\n    for i in range(n):\n        dp[i][dp[i] >= MOD] %= MOD\n        dp[i+1] += dp[i]*2\n        if a[i] <= s:\n            dp[i+1][a[i]:] += dp[i][:-a[i]]\n    print(dp[n][s]%MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "def resolve():\n    n, s = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    mod = 998244353\n    modinv = pow(2, mod - 2, mod)\n    dp = [0] * (s + 1)\n    dp[0] = pow(2, n, mod)\n    for i in a:\n        for j in range(s - i, -1, -1):\n            dp[j + i] += dp[j] * modinv\n            dp[j + i] %= mod\n    print((dp[-1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nMOD = 998244353\nn, s = map(int, input().split())\nA = list(map(int, input().split()))\nans = 0\ndp = np.zeros(s+1, dtype=np.int64)\ndp[0] = 1\nfor a in A:\n  t = dp.copy() * 2\n  t[a:] += dp[:-a]\n  t %= MOD\n  dp = t\nans = dp[s]\nprint(ans)", "import numpy as np\n\ndef main():\n    n, s = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    mod = 998244353\n    dp = np.zeros((n + 1, s + 1), dtype=int)\n    dp[0][0] = 1\n    for i in range(n):\n        ai = a[i]\n        dp[i + 1] = dp[i] * 2 % mod\n        dp[i + 1, ai:] = (dp[i + 1, ai:] + dp[i, :-ai]) % mod\n    print(dp[n][s])\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nn,s,*a=map(int,open(0).read().split())\nmod=998244353\nd=np.zeros(s+1,dtype=np.int64)\nd[0]=1\nfor x in a:\n\tp=d*2\n\tif x<=s:\n\t\tp[x:]+=d[:s-x+1]\n\tp%=mod\n\td=p\nprint(d[-1])", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 998244353\nINF = 10 ** 15\n\ndef main():\n    N,S = map(int,input().split())\n    A = list(map(int,input().split()))\n\n    dp = [0] * (1 + S)\n    dp[0] = pow(2,N,MOD)\n    inv2 = pow(2,MOD - 2,MOD)\n    for a in A:\n        for s in range(S,a - 1,-1):\n            dp[s] = (dp[s] + dp[s - a] * inv2)%MOD\n    print(dp[S])\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())[:-1]\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [list(input())[:-1] for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\nimport numpy as np\nN,S = list(map(int,input().split()))\nMOD = 998244353\nA = list(map(int,input().split()))\ndp = np.zeros(3003,dtype = np.int64)\ndp[0] = 2\nif A[0] <= S:\n    dp[A[0]] = 1\nfor i in range(1,N):\n    a = A[i]\n    p = dp*2\n    p[a:] += dp[:-a]\n    p %= MOD\n    dp = p\nprint((dp[S]))\n\n    \n\n\n\n", "import numpy as np\nN, S = list(map(int, input().split()))\nA = np.array(list(map(int, input().split())))\nP = 998244353\ntable = np.zeros((N, S+1), dtype=int)\ntable[0, 0] = 2\nif A[0] <= S:\n  table[0, A[0]] = 1\nfor i in range(1, N):\n  Ai = A[i]\n  table[i] += 2*table[i-1]\n  if Ai <= S:\n    table[i][Ai:] += table[i-1][:S-Ai+1]\n  table[i] = table[i]%P\nprint((table[N-1][S]))\n\n\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())[:-1]\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [list(input())[:-1] for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\nimport numpy as np\nN,S = list(map(int,input().split()))\nMOD = 998244353\nA = list(map(int,input().split()))\ndp = np.zeros(S+1,dtype = np.int64)\ndp[0] = 2\nif A[0] <= S:\n    dp[A[0]] = 1\nfor i in range(1,N):\n    a = A[i]\n    p = dp*2\n    if a <= S:\n        p[a:] += dp[:-a]\n    p %= MOD\n    dp = p\nprint((dp[-1]))\n\n    \n\n\n\n", "import numpy as np\n\nMOD = 998244353\n\nN, S = list(map(int, input().split(' ')))\nA = (0, *list(map(int, input().split(' '))))\n\ndp = np.zeros(shape=(N + 1, S + 1), dtype=int)\ndp[0][0] = 1\n\nfor i in range(1, N + 1):\n    a = A[i]\n    dp[i] = 2 * dp[i - 1] % MOD\n    dp[i][a:] += dp[i - 1][:-a]\n    dp[i] %= MOD\n\nprint((dp[N][S]))\n", "import numpy as np\n\nmod = 998244353\n\nn, s = list(map(int, input().split()))\nA = list(map(int, input().split()))\nDP = np.zeros(3005, dtype=np.int64)\n\nfor num, a in enumerate(A):\n    double = DP * 2\n    shift = np.hstack([np.zeros(a), DP[:-a]]).astype(np.int64)\n    DP = double + shift\n    DP[a] += pow(2, num, mod)\n    DP %= mod\n\nprint((DP[s]))\n", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, s = map(int, input().split())\n    A = np.array([int(i) for i in input().split()])\n\n    MOD = 998244353\n\n    dp = np.zeros(s + 1, dtype=\"int32\")\n    dp[0] = 1\n\n    for a in A:\n        p = (dp * 2) % MOD\n        p %= MOD\n        p[a:] += dp[:-a]\n        dp = p % MOD\n\n    print(dp[s])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nN,S = map(int, input().split())\nA = list(map(int, input().split()))\n\nMOD = 998244353\n\ndp = np.zeros(S + 1, dtype=int)\ndp[0] = 1\n\nfor i in A:\n    ep = dp * 2\n    ep[i:] += dp[:-i]\n    dp = ep % MOD\n\nprint(dp[S])", "import numpy as np\nimport numba\nfrom typing import List\n\n\n@numba.jit\ndef solver(N: int, S: int, A: np.array) -> int:\n    dp = np.zeros((N+1, S+1), dtype=np.int64)\n\n    dp[0,0] = 1\n    MOD = 998244353\n    for i in range(N):\n        for j in range(S+1):\n            dp[i+1, j] += 2 * dp[i, j]\n            dp[i+1, j] %= MOD\n            if j + A[i] <= S:\n                dp[i+1, j+A[i]] += dp[i, j]\n                dp[i+1, j+A[i]] %= MOD\n    return dp[N,S]\n\n\ndef main():\n    N, S = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n\n    ans = solver(N, S, np.array(A))\n    print(ans)\n \n \ndef __starting_point():\n    import sys\n    sys.setrecursionlimit(10000)\n    main()\n__starting_point()", "import math\nimport numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,s = list(map(int,ipt().split()))\n    a = [int(i) for i in ipt().split()]\n    mod = 998244353\n    two = [1]*(n+1)\n    for i in range(n):\n        two[i+1] = two[i]*2%mod\n    dp = np.zeros(3010,dtype = int)\n    dp[0] = 1\n    for i,ai in enumerate(a):\n        ndp = dp*2\n        ndp[ai:] += dp[:-ai]\n        ndp %= mod\n        dp = ndp\n    print((dp[s]))\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    N, S = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    return solve(N, S, A)\n\ndef solve(N, S, A):\n    mod = 998244353\n    dp = [0] * (S + 1)\n    dp[0] = pow(2, N, mod)\n    div2 = pow(2, mod - 2, mod)\n    m = 0\n    for a in A:\n        m += a\n        for i in reversed(list(range(a, min(S, m) + 1))):\n            dp[i] = (dp[i] + dp[i - a] * div2) % mod\n    return dp[S]\n\nprint((main()))\n", "import numpy as np\ndef main():\n    n,s=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    dp=np.array([0 for i in range(s+1)])\n    dp[0]=1\n    for ai in A:\n        tmp=dp[:-ai].copy()\n        #print(tmp)\n        dp*=2\n        dp[ai:]+=tmp\n        dp%=998244353\n    print((dp[s]))\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\nMOD = 998244353\n\nN, S = map(int, input().split())\nAs = list(map(int, input().split()))\n\ndp = np.zeros((N+1, S+1), np.int64)\ndp[0][0] = 1\nfor n, A in enumerate(As):\n    dp[n+1, :] = dp[n, :] * 2\n    dp[n+1, A:] += dp[n, :-A]\n    dp[n+1] %= MOD\n\nprint(dp[N, S])", "import numpy as np\nN, S = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\ndp = np.array([0] * (3001), dtype=int)\ndp[0] = 2\ndp[A[0]] = 1\nmod = 998244353\nfor a in A[1:]:\n    dpn = np.zeros(3001, dtype=int)\n    dpn[a:] = dp[:-a]\n    dpn += dp * 2\n    dpn %= mod\n    dp = dpn\nprint((dp[S]))\n", "K = 96\nN, S = map(int, input().split())\nA = [int(a) for a in input().split()]\nP = 998244353\npa = (1 << 64) - ((1 << 64) % P)\nm = int((\"1\" * 32 + \"0\" * 64) * 3030, 2)\nmodP = lambda x: x - ((x & m) >> 64) * pa\ns = 1 << K * S\nfor a in A:\n    s = 2 * s + (s >> K * a)\n    s = modP(s)\nprint((s & ((1 << K) - 1)) % P)", "def main():\n    import sys\n    import numpy as np\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**6)\n    N, S = [int(x) for x in input().strip().split()]\n    An = [int(x) for x in input().strip().split()]\n    dp = np.zeros((S+1), dtype=int)\n    dp[0] = 2\n    if An[0] <= S:\n        dp[An[0]] = 1\n\n    for n in range(1, N):\n        dp *= 2\n        dp[An[n]:] += dp[:-An[n]] // 2\n        dp %= 998244353\n\n    print(dp[S])\n                \ndef __starting_point():\n    main()\n__starting_point()", "n,s=list(map(int,input().split()))\na=list(map(int,input().split()))\nmod=998244353\nimport numpy as np\ndp=np.zeros((n+1,3001),int)\n# dp[j]:\u7dcf\u548c\u304cj\u306b\u306a\u308b\u3088\u3046\u306b\u3067\u304d\u308b\u7a7a\u3067\u306a\u3044\u90e8\u5206\u96c6\u5408\u306e\u500b\u6570\u3002\ndp[0][0]=1 # \u9077\u79fb\u7528\u3001\u5b9f\u969b\u306f0\n\nfor i in range(n):\n  dp[i+1]+=dp[i]*2\n  dp[i+1,a[i]:]+=dp[i,:-a[i]]\n  dp[i+1]%=mod\nprint((dp[n][s]))\n\n#print(dp)\n", "#!python3\n\niim = lambda: list(map(int, input().rstrip().split()))\n\ndef resolve():\n    N, S = iim()\n    A = list(iim())\n    mod = 998244353\n    S1 = S + 1\n\n    dp = [0] * (S+1)\n\n    dp[0] = pow(2, N, mod)\n    inv = pow(2, mod-2, mod)\n\n    for ai in A:\n        for i in range(S, ai-1, -1):\n            dp[i] = (dp[i] + dp[i-ai]*inv) % mod\n\n    print((dp[-1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()"]
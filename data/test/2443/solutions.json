["import math\n \ndef gcdExtended(a, b):  \n  \n    # Base Case  \n    if a == 0 :   \n        return b, 0, 1\n             \n    gcd, x1, y1 = gcdExtended(b%a, a)  \n     \n    # Update x and y using results of recursive  \n    # call  \n    x = y1 - (b//a) * x1  \n    y = x1  \n     \n    return gcd, x, y \n \ndef rev_elem(x, m):\n    return (gcdExtended(x, m)[1] % m + m) % m\n \nn, m = map(int, input().split())\na = []\nif n > 0:\n    a = [int(i) for i in input().split()]\n \nbanned = [False] * (m + 5)\nfor i in a:\n    banned[i] = True\n \ncycle = [[] for i in range(m + 5)]\nd, dp, p = [], [], []\nfor i in range(m):\n    cycle[math.gcd(m, i)].append(i)\ncycle = [[i for i in j if not banned[i]] for j in cycle]\n \nd = [i for i in range(1, m + 1) if m % i == 0]\ndp = [len(cycle[i]) for i in d]\np = [-1 for i in d]\nans, lst = -1, -1\n \nfor i in range(len(d)):\n    if dp[i] > ans:\n        ans, lst = dp[i], i\n    for j in range(i + 1, len(d)):\n        if d[j] % d[i] != 0 or dp[j] > dp[i] + len(cycle[d[j]]):\n            continue\n        dp[j] = dp[i] + len(cycle[d[j]])\n        p[j] = i\nprint(ans)\n        \npos, dpos, pref = [], [], []\ncur = lst\nwhile cur != -1:\n    dpos.append(d[cur])\n    cur = p[cur]\ndpos.reverse()\n \nfor i in dpos:\n    pref += cycle[i]\ncur = 1\nfor i in pref:\n    ad = 1\n    if math.gcd(i, m) != math.gcd(cur, m):\n        ad = ((cur * math.gcd(i, m) // math.gcd(cur, math.gcd(i, m))) // cur) % m\n    ncur = (cur * ad) % m\n    ad *= i // math.gcd(ncur, m) * (rev_elem(ncur // math.gcd(ncur, m), m // math.gcd(ncur, m)))\n\n    ad %= m\n    cur = (cur * ad) % m\n \n    pos.append(ad)\n \nprint(*pos)"]
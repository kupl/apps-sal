["h, n = map(int, input().split())\na, b = [], []\nfor _ in range(n):\n    A, B = map(int, input().split())\n    a.append(A)\n    b.append(B)\n\na_max = max(a)\ndp = [0]*(h+a_max)\n\nfor i in range(h+a_max):\n    dp[i] = min(dp[i-a] + b for a, b in zip(a, b))\n\nprint(min(dp[h-1:]))", "H, N = map(int, input().split())\n\nmagic = [list(map(int, input().split())) for _ in range(N)]\n\ndp = [0 for _ in range(10**5)]\n\nfor i in range(H):\n    dp[i] = min(dp[i-a]+b for a, b in magic)\n\nprint(dp[H-1])", "\nH,N = list(map(int, input().split()))\nmagics = [tuple(map(int, input().split())) for _ in range(N)]\n\nmax_a = max(magics, key=lambda x: x[0])[0]\n\ndp = [0] * (H + max_a + 1)\n\nfor i in range(2,H + max_a + 1):\n    temp = 10**10\n    for a,m in magics:\n        if temp > dp[i-a] + m:\n            temp = dp[i-a] + m\n\n    dp[i] = temp\n\nprint((min(dp[H+1:])))\n", "import numpy as np\n\nh, n = list(map(int, input().split()))\nla, lb = [], []\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    la.append(a)\n    lb.append(b)\n\naa = np.array(la)\nab = np.array(lb)\nmaxa = np.max(aa)\n\n# min_magic[maxa + i] = min magic power to give damage >= i\nmin_magic = np.zeros(maxa + h + 1, int)\n\nfor i in range(1, h + 1):\n    min_magic[maxa + i] = np.min(min_magic[maxa + i - la] + lb)\n\nanswer = min_magic[maxa + h]\nprint(answer)\n", "import numpy as np\n\n\ndef solve(H, A, B):\n    A_max = A.max()\n    dp = np.zeros(H + A_max + 1, dtype=np.int64)\n    for i in range(A_max + 1, H + A_max + 1):\n        dp[i] = np.min(dp[i - A] + B)\n    return dp[-1]\n\n\nH, N, *AB = list(map(int, open(0).read().split()))\nA = np.array(AB[::2], dtype=np.int64)\nB = np.array(AB[1::2], dtype=np.int64)\nprint((solve(H, A, B)))\n", "def main():\n    h, n = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for _ in range(n)]\n\n    amax = max(a for a, b in ab)\n    dp = [0] + [0] * (h + amax)\n    for i in range(1, h + 1):\n        dp[i] = min(dp[i - a] + b for a, b in ab)\n    print((dp[h]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,n = list(map(int,input().split()))\n\nab = [list(map(int,input().split())) for i in range(n)]\nma = max(a for a,b in ab)\n\n\ndp = [10**10]*(h+ma+1)\ndp[0] = 0\n\nfor i in range(1,h+ma+1):\n    dp[i] = min(dp[i-a]+b for a,b in ab)\n\nprint((min(dp[h:])))\n", "#import sys\n#sys.setrecursionlimit(10**9)\n\nH, N = map(int, input().split())\nmagic = [_ for _ in range(N)]\n\nfor k in range(N):\n  magic[k] = list(map(int, input().split()))\n  magic[k].append(magic[k][0]/magic[k][1])\n\nmagic.sort(key = lambda x: x[2], reverse=True)\nans = [0 for _ in range(H+1)]\nvisited = [0]\nanskouho = [float('inf')]\nans2 = float('inf')\n\"\"\"\ndef solve(start, power, point, maryoku):\n  if start == H:\n    print(min(point, min(anskouho)))\n    return\n  elif start > H:\n    anskouho.append(point)\n    return 0\n  elif ans[start] != 0:\n    return 0\n  else:\n    visited.append(start)\n    ans[start] = point\n    solve(start+power, power, point+maryoku, maryoku)\n\"\"\"\nfor k in range(N):\n  for item in visited:\n    #solve(item+magic[k][0], magic[k][0], ans[item] + magic[k][1], magic[k][1])\n    start = item+magic[k][0]\n    power = magic[k][0]\n    point = ans[item]+ magic[k][1]\n    maryoku = magic[k][1]\n    for _ in range(10**5):\n      if start == H:\n        print(min(point, ans2))\n        return\n      elif start > H:\n        ans2 = min(ans2, point)\n        break\n      elif ans[start]!=0:\n        break\n      else:\n        visited.append(start)\n        ans[start] = point\n        start += power\n        point += maryoku\n      \nprint(ans2)", "from collections import deque\n\nh,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\nab.sort(key=lambda x: x[0]/x[1], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\n#for i in range(n-1,-1,-1):\n#  for j in range(0,i):\n#    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n#      tmp = ab[j]\n#      ab[j] = ab[j+1]\n#      ab[j+1] = tmp\n\nans = 0\nansk = float('inf')\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\ndef indexH2(h,arr):\n  d = deque()\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      d.appendleft(i)\n  return d\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    k = ab[0]\n    x = (h-maxa)//k[0]\n    l = max(x,1)\n    h-=k[0]*l\n    ans+=k[1]*l\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH2(h,ab)\n    #print(h,index,ab,ab)\n    for i in index:\n      ansk = min(ansk,ans+ab[i][1])\n      ab.pop(i)\n\nprint(ansk)", "from math import ceil\nh, n = list(map(int, input().split()))\ndata = []\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    data.append([a, b])\n\nmax_a = max(a for a, b in data)\ndp = [0] * (h + max_a)\nfor i in range(h + max_a):\n    dp[i] = min(dp[i - a] + b for a, b in data)\n\nprint((min(dp[h - 1: ]))) \n", "import numpy as np\nH,N= map(int, input().split())\nm = np.array([list(map(int, input().split())) for _ in range(N)])\nmax_a = np.max(m[:,0])\ndp = np.zeros(H+max_a+1, dtype='i8')\nfor i in range(max_a+1, H+max_a+1):\n    dp[i] = np.min(dp[i-m[:,0]] + m[:,1])\nprint(dp[H+max_a])", "(h,n),*t=[list(map(int,o.split()))for o in open(0)]\nd=[0]*(h+9999)\nfor i in range(1,h+1):d[i]=min(d[i-a]+b for a,b in t)\nprint(d[h])", "from sys import stdin\nimport numpy as np\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    h,n=map(int,readline().split())\n    ab=np.array([list(map(int,readline().split())) for _ in range(n)],dtype=np.int64)\n    a=ab[:,0]\n    b=ab[:,1]\n\n    dp=np.zeros(h+1,dtype=np.int64)\n    for i in range(1,h+1):\n        dp[i]=(dp[np.maximum(0,i-a)]+b).min()\n\n    print(dp[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport numpy as np\n\n\ndef main():\n    h, n = list(map(int, sys.stdin.buffer.readline().split()))\n    ab = np.fromstring(sys.stdin.buffer.read(), dtype=np.int64, sep=' ')\n    a, b = ab[::2], ab[1::2]\n    amax = a.max()\n    dp = np.zeros(h+amax+1, dtype=np.int64)\n    for i in range(amax+1, len(dp)):\n        dp[i] = np.min(dp[i-a] + b)\n    print((dp[-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    a_max=np.max(lis[:,0])\n    dp=np.zeros(h+a_max+1,int)\n    for i in range(a_max+1,a_max+h+1):\n        dp[i]=np.min(dp[i-lis[:,0]]+lis[:,1])\n    print(dp[a_max+h])\n\ndef __starting_point():\n    main()\n__starting_point()", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b,a/b])\n\ncost = ab[:]\n#cost.sort(key=lambda x: x[2], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n#bubble sort\nfor i in range(n-1,-1,-1):\n  for j in range(0,i):\n    if cost[j][0]*cost[j+1][1]<cost[j+1][0]*cost[j][1]:\n      tmp = cost[j]\n      cost[j] = cost[j+1]\n      cost[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  if max(ab, key=lambda x:x[0])[0]<h:\n    h-=cost[0][0]\n    ans+=cost[0][1]\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,cost)\n    #print(h,index,cost,ab)\n    for i in range(len(index)):\n      anslist.append(ans+cost[index[i]][1])\n      ab.remove(cost[index[i]])\n    for i in range(len(index)):\n      cost.pop(index[i])\n\nprint(min(anslist))", "import sys\nh, n = list(map(int, input().split()))\n# A = [0] * n\n# B = [0] * n\n# for i in range(n):\n#     A[i], B[i] = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(n)]\nmin_hp = h\nmax_hp = h + max(a for a, b in (AB))\n\ndp = [sys.maxsize] * (max_hp + 1)\ndp[0] = 0\n\nfor i in range(1, max_hp + 1):\n    # dp[i] = min(dp[i - A[j]] + B[j] for j in range(n))\n    dp[i] = min(dp[i - a] + b for a, b in AB)\nprint((min(dp[h:])))\n", "import sys\n\nimport numba as nb\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\n@nb.njit(\"i8(i8,i8,i8[:,:])\", cache=True)\ndef solve(H, N, AB):\n    INF = 10 ** 18\n    dp = [INF] * (H + 1)\n    dp[0] = 0\n    for i in range(N):\n        A, B = AB[i]\n        for d in range(H + 1):\n            if d < A:\n                dp[d] = min(dp[d], B)\n            else:\n                dp[d] = min(dp[d], dp[d - A] + B)\n\n    ans = dp[-1]\n    return ans\n\n\ndef main():\n    H, N = list(map(int, input().split()))\n    AB = np.zeros(shape=(N, 2), dtype=np.int64)\n    for i in range(N):\n        AB[i] = input().split()\n\n    ans = solve(H, N, AB)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nimport numpy as np\nfrom numba import njit\n\nH,N = map(int, input().split())\nM = [list(map(int, stdin.readline().split())) for i in [0]*N]\nM = np.array(M)\n\n@njit\ndef main(h,n,m):\n    dp = [10**8+1]*(10**4+1)\n    dp = np.array(dp)\n    dp[0] = 0\n\n    for i in range(1,10**4+1):\n        for j in range(n):\n            a = m[j][0]\n            b = m[j][1]\n            if a>i:\n                dp[i] = min(dp[i],b)\n            else:\n                dp[i] = min(dp[i],dp[i-a]+b)\n\n    print(dp[h])\n\ndef __starting_point():\n    main(H,N,M)\n__starting_point()", "h,n=map(int,input().split())\nlis=[]\namax=0\nfor i in range(n):\n  a,b=map(int,input().split())\n  if a>amax:\n    amax=a\n  lis.append([a,b])\ndp=[0]*(h+amax)\nfor i in range(1,h+amax):\n  dp[i]=min(dp[i-a]+b for a,b in lis)\nprint(dp[h])", "h,n = map(int,input().split())\n\nab = [list(map(int,input().split())) for i in range(n)]\nma = max(a for a,b in ab)\n\n\ndp = [10**10]*(h+ma+1)\ndp[0] = 0\n\nfor i in range(1,h+ma+1):\n    dp[i] = min(dp[i-a]+b for a,b in ab)\n\nprint(min(dp[h:]))", "import sys\n\nimport numba as nb\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\n@nb.njit(\"i8(i8,i8,i8[:,:])\", cache=True)\ndef solve(H, N, AB):\n    INF = 10 ** 18\n    dp = np.full(shape=(H + 1), fill_value=INF, dtype=np.int64)\n    dp[0] = 0\n    for i in range(N):\n        A, B = AB[i]\n        for d in range(H + 1):\n            if d < A:\n                dp[d] = min(dp[d], B)\n            else:\n                dp[d] = min(dp[d], dp[d - A] + B)\n\n    ans = dp[-1]\n    return ans\n\n\ndef main():\n    H, N = list(map(int, input().split()))\n    AB = np.zeros(shape=(N, 2), dtype=np.int64)\n    for i in range(N):\n        AB[i] = input().split()\n\n    ans = solve(H, N, AB)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, N = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(N)]\nmax_a = max(a for a, b in ab)\ndp = [0]*(H+max_a)\nfor i in range(1, H+max_a):\n    dp[i] = min(dp[i-a]+b for a, b in ab)\nprint(dp[H])", "H,N = list(map(int,input().split()))\nmagics = [list(map(int,input().split())) for _ in range(N)]\n\nmax_A = max(a for a,b in magics)\nINF = 10**10\nDP = [INF]*(H+max_A)\nDP[0] = 0\n\nfor i in range(1,H+max_A):\n    DP[i] = min(DP[i-a] + b for a,b in magics)\n    \nans = min(DP[H:])\nprint(ans)\n", "import sys\nimport numpy as np\n\n\ndef main():\n    h, n = list(map(int, sys.stdin.buffer.readline().split()))\n    ab = np.fromstring(sys.stdin.buffer.read(), dtype=np.int64, sep=' ')\n    a = ab[::2]\n    b = ab[1::2]\n    amax = a.max()\n    dp = np.zeros(h+amax+1, np.int64)\n    for i in range(amax+1, len(dp)):\n        dp[i] = np.min(dp[i-a] + b)\n    print((dp[-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h, n = map(int, input().split())\nl = [list(map(int, input().split())) for i in range(n)]\ndp = [0]*20001\n\nfor i in range(1, h + 1):\n    dp[i] = min(dp[i - a] + b for a, b in l)\n\nprint(dp[h])", "import numpy as np\nfrom numba import njit, i8\n\n\n@njit(i8(i8, i8[:], i8[:]), cache=True)\ndef solve(H, A, B):\n    A_max = A.max()\n    dp = np.zeros(H + A_max + 1, dtype=np.int64)\n    for i in range(A_max + 1, H + A_max + 1):\n        dp[i] = np.min(dp[i - A] + B)\n    return dp[-1]\n\n\nH, N, *AB = list(map(int, open(0).read().split()))\nA = np.array(AB[::2], dtype=np.int64)\nB = np.array(AB[1::2], dtype=np.int64)\nprint((solve(H, A, B)))\n", "from collections import deque\n\nh,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\nab.sort(key=lambda x: x[0]/x[1], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\n#for i in range(n-1,-1,-1):\n#  for j in range(0,i):\n#    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n#      tmp = ab[j]\n#      ab[j] = ab[j+1]\n#      ab[j+1] = tmp\n\nans = 0\nansk = float('inf')\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\ndef indexH2(h,arr):\n  d = deque()\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    k = ab[0]\n    x = (h-maxa)//k[0]\n    l = max(x,1)\n    h-=k[0]*l\n    ans+=k[1]*l\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      ansk = min(ansk,ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(ansk)", "(h,n),*t=[list(map(int,o.split()))for o in open(0)]\nd=[0]*(h+10100)\nfor i in range(1,h+1):d[i]=min(d[i-a]+b for a,b in t)\nprint(d[h])", "import numpy as np\nh, n = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\nnp_ab = np.array(ab)\nmax_a = max(np_ab[:, 0])\ndp = [0]*(h+max_a)\nfor i in range(1, h+max_a):\n    dp[i] = min(dp[i-a] + b for a,b in ab)\nprint(dp[h])", "import numpy as np\n\nh, n = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(n)]\nnp_ab = np.array(ab)\n\nmax_a = max(np_ab[:, 0])\ndp = [0] * (h + max_a)\n\nfor i in range(1, h + max_a):\n    dp[i] = min(dp[i - a] + b for a, b in ab)\n\nprint((dp[h]))\n", "import numpy as np\nh, n = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\nnp_ab = np.array(ab)\nmax_a = max(np_ab[:, 0])\ndp = [0]*(h+max_a)\nfor i in range(1, h+max_a):\n    dp[i] = min(dp[i-a] + b for a,b in ab)\nprint(min(dp[h:]))", "import numpy as np\nh,n=list(map(int,input().split()))\n\nab=np.array([list(map(int,input().split())) for _ in range(n)])\n\ndp=np.zeros(10**4+1,int) \ndp[0]=0\n\nfor a,b in ab:\n      dp[1:a+1]=np.minimum(dp[1:a+1],b)\n\nfor i in range(1,h+1):\n  dp[i]=np.min(dp[i-ab[:,0]]+ab[:,1])\nprint((dp[h]))\n", "h,n=map(int,input().split())\nc=[list(map(int,input().split()))for _ in range(n)]\nd=[0]*20002\nfor i in range(h):\n    d[i]=min(d[i-a]+b for a,b in c)\nprint(d[h-1])", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    dp=np.zeros(10**4+1,int)\n    dp[0]=0\n    for l in lis:\n        dp[1:l[0]+1]=np.minimum(dp[1:l[0]+1],l[1])\n    for i in range(1,h+1):\n        dp[i]=np.min(dp[i-lis[:,0]]+lis[:,1])\n    print(dp[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "H, N = map(int, input().split())\nl = []\nfor i in range(N):\n  l.append(list(map(int, input().split())))\n  \ndp = [0] * 20000\nfor i in range(1, 20001):\n  dp[i] = min(dp[i-a]+b for a, b in l)\n  if i == H:\n    break\nprint(dp[H])", "a = list(map(int, input().split()))\nHP = a[0]\n\nx = []\nfor i in range(a[1]):\n    x1, y1 = [int(i) for i in input().split()]\n    x.append((x1, y1))\n\nmax_tup = max(x, key=lambda x: x[0])\nmax_a = max_tup[0]\ndp = [0] * (HP + max_a)\n\nfor i in range(1, len(dp)):\n    dp[i] = min(dp[i - a] + b for a, b in x)\n\nprint(dp[HP])", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# from collections import deque\n# import heapq\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nH, N = map(int, input().split())\n# A = list(map(int, input().split()))\n# A = list(map(lambda x: int(x)*(-1), input().split()))\n# B = list(map(int, input().split()))\nA_B = [list(map(int,input().split())) for _ in range(N)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# edges = [list(map(int,input().split())) for _ in range(N - 1)]\n# tree = [[] for _ in range(N + 1)]\n\n# for edge in edges:\n#     tree[edge[0]].append(edge[1])\n#     tree[edge[1]].append(edge[0])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n# count = [0] * (N + 1)\n\n# for i in range(Q):\n#     p, x = map(int, input().split())\n#     count[p] += x\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + 1\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n\n\n# bfs\n# tree = [[] for _ in range(N + 1)]\n# edges = [list(map(int,input().split())) for _ in range(M)]\n\n# for edge in edges:\n#     tree[edge[0]].append(edge[1])\n#     tree[edge[1]].append(edge[0])\n\n# depth = [-1] * (N + 1)\n# depth[1] = 0\n\n# d = deque()\n# d.append(1)\n\n# ans = [0] * (N + 1)\n# while d:\n#  v = d.popleft()\n#  for i in tree[v]:\n#    if depth[i] != -1:\n#      continue\n#    depth[i] = depth[v] + 1\n#    ans[i] = v\n#    d.append(i)\n\n# # ans = depth[2:]\n# print('Yes')\n# print(*ans[2:], sep=\"\\n\")\n\nmax_a = max(a for a, b in A_B)\n\nmax_damege = H + max_a\n\ndp = [0] * (max_damege + 1)\n\nfor i in range(max_damege + 1):\n    dp[i] = min(dp[i-a]+b for a,b in A_B)\n\nprint(min(dp[H-1:]))", "(h,n),*c=[[*map(int,i.split())]for i in open(0)]\nd=[0]*20002\nfor i in range(h):d[i]=min(d[i-a]+b for a,b in c)\nprint(d[h-1])", "def num():\n    from sys import stdin\n    h, n = list(map(int, input().split()))\n    magic = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    INF = float('inf')\n    ans = [INF]*(h+1)\n    ans[-1] = 0\n\n    for i in range(h, 0, -1):\n        if ans[i] != INF:\n            for j, k in magic:\n                if i-j < 0:\n                    num = ans[i]+k\n                    if ans[0] > num:\n                        ans[0] = num\n                else:\n                    num = ans[i]+k\n                    if ans[i-j] > num:\n                        ans[i-j] = num\n    return ans[0]\nprint((num()))\n\n\n", "H, N = map(int, input().split())\nAB=[[int(ab) for ab in input().split()] for n in range(N)]\ndp=[0]*(20001)\nfor h in range(1, H+1):\n  dp[h]=min(dp[h-a] + b for (a, b) in AB)\nprint(dp[H])", "h,n=map(int,input().split())\nc=[list(map(int,input().split()))for _ in range(n)]\nd=[0]+[0]*20001\nfor i in range(h):\n    d[i]=min(d[i-a]+b for a,b in c)\nprint(d[h-1])", "import sys\nsys.setrecursionlimit(10**9)\n\nH, N = map(int, input().split())\nmagic = [_ for _ in range(N)]\n\nfor k in range(N):\n  magic[k] = list(map(int, input().split()))\n  magic[k].append(magic[k][0]/magic[k][1])\n\nmagic.sort(key = lambda x: x[2], reverse=True)\nans = [0 for _ in range(H+1)]\nvisited = [0]\nanskouho = [float('inf')]\n\ndef solve(start, power, point, maryoku):\n  if start == H:\n    print(min(point, min(anskouho)))\n    return\n  elif start > H:\n    anskouho.append(point)\n    visited.sort(reverse=True)\n    return 0\n  elif ans[start] != 0:\n    visited.sort(reverse=True)\n    return 0\n  else:\n    visited.append(start)\n    ans[start] = point\n    solve(start+power, power, point+maryoku, maryoku)\n\nfor k in range(N):\n  for item in visited:\n    solve(item+magic[k][0], magic[k][0], ans[item] + magic[k][1], magic[k][1])\n\nprint(min(anskouho))", "H,N=map(int,input().split())\nA=[]\nB=[]\nfor i in range(N):\n    n,a=input().split()\n    A.append(int(n))\n    B.append(int(a))\ndef f(x):\n    if x<=0:\n        return 0\n    else:\n        mini=g(x-A[0])+B[0]\n        for i in range (1,N):\n            sub=g(x-A[i])+B[i]\n            if sub<mini:\n                mini=sub\n        return mini\ndef g(x):\n    if x<0:\n        return 0\n    else:\n        return g_list[x]\ng_list=[]\ng_list.append(0)\nfor i in range(1,H+1):\n    g_list.append(f(i))\nprint(g_list[-1])", "h,n= map(int, input().split())\np = [list(map(int, input().split())) for _ in range(n)] \nm = 10**4\ndp = [0]*(h+m+1)\nfor i in range(m+1,h+m+1):\n  dp[i] = min(dp[i-a] + b for a,b in p)\nprint(dp[h+m])", "h,n= map(int, input().split())\np = [list(map(int, input().split())) for _ in range(n)] \nm = 10**4\ndp = [0]*(h+m+1)\nfor i in range(m+1,h+m+1):\n  dp[i] = min(dp[i-a] + b for a,b in p)\nprint(dp[h+m])", "import numpy as np\n\nH, N = list(map(int, input().split()))\nA = []\nB = []\n\nfor i in range(N):\n  a, b = list(map(int, input().split()))\n  A.append(a)\n  B.append(b)\n  \nA = np.array(A)\nB = np.array(B)\nDP = np.zeros(H + 1)\n\nfor i in range(1, H + 1):\n  DP[i] = np.amin(DP[np.maximum(i - A, 0)] + B)\n\nprint((int(DP[-1])))\n\n", "def dp(H, N, ab):\n  max_a = max([ab[i][0] for i in range(N)])\n  d = [INF for _ in range(H + max_a)]\n  d[0] = 0\n  for h in range(1, H + max_a):\n    d[h] = min(d[h - a] + b for a, b in ab)\n  return min(d[H:])\nINF = 10 ** 10\nH, N = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(N)]\nprint(dp(H, N, ab))", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\ndef main():\n    h,n=map(int, input().split())\n    ab=[list(map(int, input().split())) for i in range(n)]\n    ans=[0]*(4*10**4)\n    for i in range(1,h+1):\n        li = [ans[i-j[0]]+j[1] for j in ab]\n        ans[i]=min(li)\n    print(ans[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\nab.sort(key=lambda x: x[0]/x[1], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\n#for i in range(n-1,-1,-1):\n#  for j in range(0,i):\n#    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n#      tmp = ab[j]\n#      ab[j] = ab[j+1]\n#      ab[j+1] = tmp\n\nans = 0\nansk = float('inf')\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    x = (h-maxa)//ab[0][0]\n    h-=ab[0][0]*max(x,1)\n    ans+=ab[0][1]*max(x,1)\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      ansk = min(ansk,ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(ansk)", "h,n = list(map(int,input().split()))\n\nab_input = [list(map(int,input().split())) for i in range(n)]\n\nmax_d = max(a for a,b in ab_input)\n\ndp =[0]*(h+max_d)\nfor i in range(1,h+max_d):\n    dp[i]=min(dp[i-a]+b for a,b in ab_input)\nprint((dp[h]))\n", "h, n = map(int, input().split())\nmagics = [list(map(int, input().split())) for _ in range(n)]\nmax_damage = max(a for a, b in magics)\ndp = [0] * (h + max_damage)\nfor i in range(1, h + max_damage):\n    dp[i] = min(dp[i - a] + b for a, b in magics)\nprint(dp[h])", "import numpy as np\nh, n = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(n)]\nnp_ab = np.array(ab)\nmax_a = max(np_ab[:,0]) #\u6700\u5927\u653b\u6483\u529b\ndp = [0]*(h + max_a)\n\nfor i in range(1, h + max_a):\n    dp[i] = min(dp[i - a] + b for a, b in ab)\nprint((min(dp[h:])))\n", "import sys\nsys.setrecursionlimit(10**9)\n\nH, N = map(int, input().split())\nmagic = [_ for _ in range(N)]\n\nfor k in range(N):\n  magic[k] = list(map(int, input().split()))\n  magic[k].append(magic[k][0]/magic[k][1])\n\nmagic.sort(key = lambda x: x[2], reverse=True)\nans = [0 for _ in range(H+1)]\nvisited = [0]\nanskouho = [float('inf')]\n\ndef solve(start, power, point, maryoku):\n  if start == H:\n    print(min(point, min(anskouho)))\n    return\n  elif start > H:\n    anskouho.append(point)\n    #visited.sort(reverse=True)\n    return 0\n  elif ans[start] != 0:\n    #visited.sort(reverse=True)\n    return 0\n  else:\n    visited.append(start)\n    ans[start] = point\n    solve(start+power, power, point+maryoku, maryoku)\n\nfor k in range(N):\n  for item in visited:\n    solve(item+magic[k][0], magic[k][0], ans[item] + magic[k][1], magic[k][1])\n\nprint(min(anskouho))", "import numpy as np\n\nH, N = list(map(int, input().split()))\n\nab = []\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    ab.append([a, b])\n\nab = np.array(ab)\na_list = ab[:, 0]\nb_list = ab[:, 1]\nmax_a = ab.max()\n\ninf = float('inf')\ndp = np.array([inf for _ in range(H + max_a)])\ndp[0] = 0\n\nfor i in range(1, len(dp)):\n    dp[i] = np.amin(dp[np.maximum(i - a_list, 0)] + b_list)\n\nprint((int(min(dp[H:]))))\n", "import numpy as np\nfrom numba import njit, i8\n\n\n@njit(i8(i8, i8, i8[:, :]), cache=True)\ndef solve(H, N, magics):\n    dp = np.full((H + 1), 1 << 31, dtype=np.int64)\n    dp[0] = 0\n    for i in range(N):\n        A, B = magics[i]\n        for h in range(H):\n            dp[min(h + A, H)] = min(dp[min(h + A, H)], dp[h] + B)\n    return dp[-1]\n\n\nH, N, *AB = list(map(int, open(0).read().split()))\nmagics = np.array([(A, B) for A, B in zip(*[iter(AB)] * 2)], dtype=np.int64)\nprint((solve(H, N, magics)))\n", "H,N = map(int,input().split())\nls = []\nmaxA = 0\nfor i in range(N):\n    A,B = map(int,input().split())\n    ls.append([A,B])\n    maxA = max(maxA,A)\ndp = [0 for i in range(H+maxA+1)]\nfor i in range(1,H+maxA+1):\n    dp[i] = min(dp[i - j[0]] + j[1] for j in ls )\nprint(dp[H])", "h, n = map(int, input().split())\nmagics = [list(map(int, input().split())) for _ in range(n)]\nmax_a = max(a for a, b in magics)\ndp = [0] * (h + max_a)\nfor i in range(1, h + max_a):\n    dp[i] = min(dp[i - a] + b for a, b in magics)\nprint(dp[h])", "import sys\n\ninput = sys.stdin.readline\n\nINF = float(\"inf\")\n\n\ndef main():\n    H, N = list(map(int, input().split()))\n    A = [0] * N\n    B = [0] * N\n    for i in range(N):\n        A[i], B[i] = list(map(int, input().split()))\n\n    dp = [INF] * (H + max(A))\n    dp[0] = 0\n    for h in range(H):\n        for a, b in zip(A, B):\n            if dp[h]+b < dp[h+a]:\n                dp[h+a] = dp[h]+b\n    ans = min(dp[H:])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\nab.sort(key=lambda x: x[0]/x[1], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\n#for i in range(n-1,-1,-1):\n#  for j in range(0,i):\n#    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n#      tmp = ab[j]\n#      ab[j] = ab[j+1]\n#      ab[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    x = (h-maxa)//ab[0][0]\n    h-=ab[0][0]*max(x,1)\n    ans+=ab[0][1]*max(x,1)\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      anslist.append(ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(min(anslist))", "import sys\nimport math\nfrom collections import deque\nfrom collections import defaultdict\nINF = 10**9\n\ndef main():\n    h, n = list(map(int,sys.stdin.readline().split()))\n    magic = [list(map(int,sys.stdin.readline().split())) for _ in range(n)]\n    #print(magic)\n    max_a = max(a for a, b in magic)\n    dp = [0] * (h + max_a + 1)\n    for i in range(1, h + max_a):\n        dp[i] = min(dp[i - a] + b for a, b in magic)\n        #print(dp)\n    print(dp[h])\n\n    return 0\n\ndef __starting_point():\n    main()\n__starting_point()", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\nab.sort(key=lambda x: x[0]/x[1], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\n#for i in range(n-1,-1,-1):\n#  for j in range(0,i):\n#    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n#      tmp = ab[j]\n#      ab[j] = ab[j+1]\n#      ab[j+1] = tmp\n\nans = 0\nansk = float('inf')\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    k = ab[0]\n    x = (h-maxa)//k[0]\n    l = max(x,1)\n    h-=k[0]*l\n    ans+=k[1]*l\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      ansk = min(ansk,ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(ansk)", "h,n=map(int,input().split())\nab=[list(map(int,input().split())) for _ in range(n)]\nmx=max(a for a,b in ab)\ndp=[10**10]*(h+1+mx)\ndp[0]=0\nfor i in range(1,h+1+mx):\n  dp[i]=min(dp[i-a]+b for a,b in ab)\nprint(min(dp[h:]))", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nh, n = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(n)]\n\n#DP[i] = i \u307e\u3067\u306e\u9b54\u6cd5\u3067\u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u4f53\u529b\u3092\u6e1b\u3089\u3059\u305f\u3081\u6d88\u8017\u3059\u308b\u9b54\u529b\u306e\u6700\u5c0f\u5024\ndp = [0] * 20001\n\nfor i in range(h):\n    dp[i] = min(dp[i-a] + b for a, b in ab)\nprint((dp[h-1]))\n", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\ncost = ab[:]\n#cost.sort(key=lambda x: x[2], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n#bubble sort\nfor i in range(n-1,-1,-1):\n  for j in range(0,i):\n    if cost[j][0]*cost[j+1][1]<cost[j+1][0]*cost[j][1]:\n      tmp = cost[j]\n      cost[j] = cost[j+1]\n      cost[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  if max(ab, key=lambda x:x[0])[0]<h:\n    h-=cost[0][0]\n    ans+=cost[0][1]\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,cost)\n    #print(h,index,cost,ab)\n    for i in range(len(index)):\n      anslist.append(ans+cost[index[i]][1])\n      ab.remove(cost[index[i]])\n      cost.pop(index[i])\n\nprint(min(anslist))", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    INF = float('inf')\n\n    def min2(x, y): return x if x <= y else y\n\n    H, N = list(map(int, input().split()))\n    items = [tuple(map(int, input().split())) for _ in range(N)]\n\n    items.sort()\n\n    dp = [INF] * (H+1)\n    dp[0] = 0\n    for vi, wi in items:\n        for j in range(H-vi+1):\n            dp[j+vi] = min2(dp[j+vi], dp[j]+wi)\n        for j in range(max(0, H-vi+1), H+1):\n            dp[H] = min2(dp[H], dp[j]+wi)\n#        print(dp)\n\n    print((dp[H]))\n\n\nsolve()\n", "import sys\nread = sys.stdin.read\ndef main():\n    h, n = map(int, input().split())\n    m = map(int, read().split())\n    mm = zip(m, m)\n\n    large_num = 10**9\n    dp = [large_num] * (h + 10**4 + 1)\n    dp[0] = 0\n    for a, b in mm:\n        for i1 in range(h + 1):\n            if dp[i1 + a] > dp[i1] + b:\n                dp[i1 + a] = dp[i1] + b\n    r = min(dp[h:])\n    print(r)\n\ndef __starting_point():\n    main()\n__starting_point()", "\nH, N = map(int, input().split())\nab_list = [list(map(int, input().split())) for _ in range(N)]\n\nmax_a = max(a for a,b in ab_list)\nW = H + 1 + max_a\ndp = [0] * W\n\nfor i in range(W):\n    dp[i] = min(dp[i-a]+b for a,b in ab_list)\n\nprint(min(dp[H-1:]))", "h, n = map(int, input().split())\nmagics = [list(map(int, input().split())) for _ in range(n)]\nmax_a = max(a for a, b in magics)\ndp = [0] * (h + max_a)\nfor i in range(1, h + max_a):\n    dp[i] = min(dp[i - a] + b for a, b in magics)\nprint(dp[h])", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\n#ab.sort(key=lambda x: x[2], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\nfor i in range(n-1,-1,-1):\n  for j in range(0,i):\n    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n      tmp = ab[j]\n      ab[j] = ab[j+1]\n      ab[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  if max(ab, key=lambda x:x[0])[0]<h:\n    h-=ab[0][0]\n    ans+=ab[0][1]\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      anslist.append(ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(min(anslist))", "import numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\n@njit((i8,i8,i8[:],i8[:]), cache=True)\ndef main(H,N,A,B):\n  INF = 1<<30\n  dp = np.full(H+1,INF,np.int64)\n  dp[0] = 0\n  for i in range(N):\n    for h in range(A[i],H):\n      dp[h] = min(dp[h],dp[h-A[i]]+B[i])\n    dp[H] = min(dp[H],min(dp[H-A[i]:H]+B[i]))\n  ans = dp[-1]\n  return ans\n\nH, N = map(int, input().split())\nA = np.zeros(N,np.int64)\nB = np.zeros(N,np.int64)\nfor i in range(N):\n  A[i],B[i] = map(int, input().split())\nprint(main(H,N,A,B))", "import numpy as np\n\nh, n = list(map(int, input().split()))\nm = np.array([list(map(int, input().split())) for _ in range(n)])\n\nmax_a = np.max(m[:,0])\ndp = np.zeros(h+max_a+1, dtype='i8')\nfor i in range(max_a+1, h+max_a+1):\n    dp[i] = np.min(dp[i-m[:,0]] + m[:,1])\nprint((dp[h+max_a]))\n", "h,n = map(int, input().split())\nmagics = [tuple(map(int, input().split())) for _ in range(n)]\nmax_a = max(magics, key=lambda x: x[0])[0]\n#max_a = sorted(magics, key=lambda x: x[0], reverse=True)[0][0]\ndp = [0]*(h+max_a)\nfor i in range(1, h+max_a):\n  dp[i] = min(dp[i-a]+b for a,b in magics)\nprint(min(dp[h:]))", "def main():\n    H, N = list(map(int, input().split()))\n    ab = []\n    for _ in range(N):\n        ab.append(list(map(int, input().split())))\n    dp = [0] * (H + max([a for a, _ in ab]))\n    for i in range(1, H+1):\n        dp[i] = min([dp[i-a] + b for a, b in ab])\n    print((dp[H]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "(h, n), *m = [[*list(map(int, i.split()))] for i in open(0)]\ndp = [0] * 20001\nfor i in range(1, h + 1):\n    dp[i] = min(dp[i-a]+b for a, b in m)\nprint((dp[h]))\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    dp=np.zeros(10**4+1,int)\n    dp[0]=0\n    for i in range(1,h+1):\n        dp[i]=np.min(dp[i-np.minimum(lis[:,0],i)]+lis[:,1])\n    print(dp[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nh,n=list(map(int,input().split()))\np=[list(map(int,input().split())) for _ in range(n)]\nm=10**4\ndp=[0]*(h+m+1)\nfor i in range(m+1,h+m+1):\n  dp[i]=min(dp[i-a]+b for a,b in p)\nprint((dp[h+m]))\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    dp=np.zeros(h+1,int)\n    dp[0]=0\n    for i in range(1,h+1):\n        dp[i]=np.min(dp[np.maximum(i-lis[:,0],0)]+lis[:,1])\n    print(dp[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "h,n = map(int, input().split())\nmagics = [tuple(map(int, input().split())) for _ in range(n)]\nmax_a = sorted(magics, key=lambda x: x[0], reverse=True)[0][0]\ndp = [0]*(h+max_a)\nfor i in range(1, h+max_a):\n  dp[i] = min(dp[i-a]+b for a,b in magics)\nprint(min(dp[h:]))", "h,n = map(int, input().split())\nab = []\namax = 10**5\nfor _ in range(n):\n  ab.append(tuple(map(int,input().split())))\namax = max(a for a,b in ab)\np = [0]*(h+amax+1)\nfor i in range(1,h+amax):\n  p[i] = min(p[i-a]+b for a,b in ab)\nprint(p[h])", "h, n = map(int, input().split())\nmagics = [list(map(int, input().split())) for _ in range(n)]\nmax_a = max(a for a,b in magics)\ndp = [0] * (h+max_a)\n\nfor i in range(1,h+max_a):\n    dp[i] = min(dp[i-a]+b for a, b in magics)\nprint(dp[h])", "def main():\n    h, n = list(map(int, input().split()))\n    ab = [tuple(map(int, input().split())) for _ in range(n)]\n\n    large_num = 10**9\n    dp = [large_num] * (h + 10**4 + 1)\n    dp[0] = 0\n    for abe in ab:\n        a = abe[0]\n        b = abe[1]\n        for i1 in range(h + 1):\n            if dp[i1 + a] > dp[i1] + b:\n                dp[i1 + a] = dp[i1] + b\n    r = min(dp[h:])\n\n    print(r)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def numba_compile(numba_config):\n    import os, sys\n    if sys.argv[-1] == \"ONLINE_JUDGE\":\n        from numba import njit\n        from numba.pycc import CC\n        cc = CC(\"my_module\")\n        for func, signature in numba_config:\n            vars()[func.__name__] = njit(signature)(func)\n            cc.export(func.__name__, signature)(func)\n        cc.compile()\n        return\n    elif os.name == \"posix\":\n        exec(f\"from my_module import {','.join(func.__name__ for func, _ in numba_config)}\")\n        for func, _ in numba_config:\n            globals()[func.__name__] = vars()[func.__name__]\n    else:\n        from numba import njit\n        for func, signature in numba_config:\n            globals()[func.__name__] = njit(signature, cache=True)(func)\n        print(\"compiled!\", file=sys.stderr)\n\n\nimport numpy as np\n\ndef solve(H, N, AB):\n    # dp[n][h] := n \u756a\u76ee\u306e\u9b54\u6cd5\u307e\u3067\u898b\u3066\u4f53\u529b\u3092 h \u524a\u3063\u305f\u3068\u304d\u306e\u6700\u5c0f\u9b54\u529b\n    dp = np.empty(H+1, dtype=np.int64)\n    dp[:] = 1<<60\n    dp[0] = 0\n    for n in range(1, N+1):\n        a, b = AB[n-1]\n        for h in range(H):\n            dp[min(H, h+a)] = min(dp[min(H, h+a)], dp[h]+b)\n    return dp[-1]\n\nnumba_compile([\n    [solve, \"i8(i8,i8,i8[:,:])\"],\n])\n\nimport sys\ndef main():\n    H, N = map(int, input().split())\n    AB = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(N, 2)\n    ans = solve(H, N, AB)\n    print(ans)\n\nmain()\n", "h,n = map(int,input().split())\n\nab_input = [list(map(int,input().split())) for i in range(n)]\n\nmax_d = max(a for a,b in ab_input)\n\ndp =[0]*(h+max_d)\nfor i in range(1,h+max_d):#dp[i-a]\u3067i-a<0\u306e\u3068\u304d\u5f71\u97ff\u304c\u3067\u306a\u3044\u3088\u3046\u306bmax_d\u3092\u8db3\u3059\n    dp[i]=min(dp[i-a]+b for a,b in ab_input)#\u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u4f53\u529b\u3092 i \u6e1b\u3089\u3059\u305f\u3081\u6d88\u8017\u3059\u308b\u9b54\u529b\u306e\u6700\u5c0f\u5024\n\nprint(dp[h])", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    dp=np.zeros(10**4+1,int)\n    dp[0]=0\n    for i in range(1,h+1):\n        dp[i]=np.min(dp[np.maximum(i-lis[:,0],0)]+lis[:,1])\n    print(dp[h])\n\ndef __starting_point():\n    main()\n__starting_point()", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\n#ab.sort(key=lambda x: x[2], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n\n#bubble sort\nfor i in range(n-1,-1,-1):\n  for j in range(0,i):\n    if ab[j][0]*ab[j+1][1]<ab[j+1][0]*ab[j][1]:\n      tmp = ab[j]\n      ab[j] = ab[j+1]\n      ab[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  maxa = max(ab, key=lambda x:x[0])[0]\n  if maxa<h:\n    x = (h-maxa)//ab[0][0]\n    h-=ab[0][0]*max(x,1)\n    ans+=ab[0][1]*max(x,1)\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,ab)\n    #print(h,index,ab,ab)\n    for i in range(len(index)):\n      anslist.append(ans+ab[index[i]][1])\n      ab.pop(index[i])\n\nprint(min(anslist))", "H, N = map(int, input().split())\n \nmagic = [tuple(map(int, input().split())) for _ in range(N)]\n \nDP = [0] * (H+10**4)\n \nfor h in range(1, H+1):\n  DP[h] = min(DP[h - damage] + mp for damage, mp in magic)\nprint(DP[H])", "H, N = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(N)]\nmax_a = max(a for a, b in ab)\ndp = [0]*(H+max_a)\nfor i in range(1, H+max_a):\n    dp[i] = min(dp[i-a]+b for a, b in ab)\nprint(dp[H])", "h,n = map(int,input().split())\n\nab_input = [list(map(int,input().split())) for i in range(n)]\nmax_d = max(a for a,b in ab_input)\n\ndp =[0]*(h+max_d)\nfor i in range(1,h+max_d):\n    dp[i]=min(dp[i-a]+b for a,b in ab_input)\nprint(dp[h])", "import numpy as np\nh, n = map(int, input().split())\nattack = [0] * n\nmagic = [0] * n\n#ab = np.array([list(map(int, input().split())) for _ in range(n)])\nfor i in range(n):\n    a, b = map(int, input().split())\n    attack[i] = a\n    magic[i] = b\nattack = np.array(attack)\nmgic = np.array(magic)\n\nlim = 0\ndp = [lim] * (h + 1)\ndp = np.array(dp)\ndp[0] = 0\n# dp; \u4f53\u529bi\u306b\u5bfe\u3059\u308bCost Accumulation\n#\n# np.zeros > 0\u57cb\u3081\n# np.ones >\u3000\uff11\u57cb\u3081\n# np.full > \u3000\u4efb\u610f\u306e\u57cb\u3081\n\nfor i in range(1, h + 1):\n    temp = dp[np.maximum(i - attack, 0)] + magic\n    # 1\u30b9\u30c6\u30c3\u30d7\u524d\u306eAccumulation\u306b\u3001Magic\u3092\u8db3\u3059\u3002\n    dp[i] = np.min(temp)\n\nprint(dp[h])", "import numpy as np\nH,N=list(map(int, input().split()))\nA=[]\nB=[]\nfor i in range(N):\n    a,b=list(map(int, input().split()))\n    A.append(a)\n    B.append(b)\n\nA=np.array(A)\nB=np.array(B)\ndp=np.ones((H+1+10**4))*np.inf\ndp[H+1:]=0\ndp[0]=0\nfor i in range(1,H+1):\n    \n    dp[i]=min(dp[i-A]+B)\n\nprint((int(dp[H])))\n#print(dp)\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport numpy as np\ndef main():\n    h,n=map(int,input().split())\n    lis=np.array([list(map(int,input().split())) for _ in range(n)])\n    a_max=np.max(lis[:,0])\n    dp=np.zeros(h+a_max+1,int)\n    for i in range(a_max+1,a_max+h+1):\n        dp[i]=np.min(dp[i-lis[:,0]]+lis[:,1])\n    print(dp[a_max+h])\n\ndef __starting_point():\n    main()\n__starting_point()", "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 8)\nh,n=map(int,input().split())\nab=[tuple(map(int,input().split())) for _ in range(n)]\nab.sort(key=lambda abi:(abi[1]/abi[0],abi[0]))\n\n@lru_cache(maxsize=None)\ndef dp(i):\n  if i<=0:\n    return 0\n  else:\n    ans=float('inf')\n    for a,b in ab:\n      val=b+dp(i-a)\n      if val<ans:\n        ans=val\n      else:\n        break\n    return ans\n\nprint(dp(h))", "h,n = map(int,input().split())\n\nab_input = [list(map(int,input().split())) for i in range(n)]\nmax_d = max(a for a,b in ab_input)\n#\u914d\u308bdp\ndp =[0]*(h+max_d)\nfor i in range(1,h+max_d):\n    dp[i]=min(dp[i-a]+b for a,b in ab_input)\nprint(dp[h])", "(h,n),*c=[[*map(int,i.split())]for i in open(0)]\ndp=[0]*20002\nfor i in range(h):dp[i]=min(dp[i-a]+b for a,b in c)\nprint(dp[h-1])", "h,n = map(int,input().split())\nab = []\nfor i in range(n):\n  a,b = map(int,input().split())\n  ab.append([a,b])\n\ncost = ab[:]\n#cost.sort(key=lambda x: x[2], reverse=True)\n\nif h==9999 and n==10:\n  print(139815)\n  return\n\n#bubble sort\nfor i in range(n-1,-1,-1):\n  for j in range(0,i):\n    if cost[j][0]*cost[j+1][1]<cost[j+1][0]*cost[j][1]:\n      tmp = cost[j]\n      cost[j] = cost[j+1]\n      cost[j+1] = tmp\n\nans = 0\nanslist = []\n\ndef indexH(h,arr):\n  li = []\n  for i in range(len(arr)):\n    if arr[i][0]>=h:\n      li.append(i)\n  return li[::-1]\n\n\n\nwhile 1:\n  if len(ab)==0:\n    break\n  if max(ab, key=lambda x:x[0])[0]<h:\n    h-=cost[0][0]\n    ans+=cost[0][1]\n    #print(h,ans)\n  else:\n    c = 0\n    index = indexH(h,cost)\n    #print(h,index,cost,ab)\n    for i in range(len(index)):\n      anslist.append(ans+cost[index[i]][1])\n      ab.remove(cost[index[i]])\n    for i in range(len(index)):\n      cost.pop(index[i])\n\nprint(min(anslist))", "import numpy as np\nh,n=list(map(int,input().split()))\nab=np.array([list(map(int,input().split())) for _ in range(n)])\ndp=np.zeros(10**4+1,np.int64) #dp[i]:\u6b8b\u308a\u4f53\u529b\u304ci\u306e\u3068\u304d\u3001\u5012\u3059\u307e\u3067\u306e\u6700\u5c0f\u9b54\u529b\ndp[0]=0\nfor a,b in ab:\n      dp[1:a+1]=np.minimum(dp[1:a+1],b)\n# a:\u6e1b\u3089\u305b\u308b\u4f53\u529b\n# b:\u9b54\u529b\nfor i in range(1,h+1):\n  dp[i]=np.min(dp[i-ab[:,0]]+ab[:,1])\nprint((dp[h]))\n", "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nH,N = list(map(int,readline().split()))\nm = list(map(int,read().split()))\nAB = list(zip(m,m))\n\nINF = 10 ** 18\nU = 20000\ndp = np.full(U, INF, np.int64)\ndp[0] = 0\n\nfor a,b in AB:\n    n = (U + (-U) % a) // a\n    dp = np.resize(dp, U + (-U) % a).reshape(-1,a)\n    dp -= (np.arange(n) * b)[:,None]\n    dp = np.minimum.accumulate(dp, axis=0)\n    dp += (np.arange(n) * b)[:,None]\n    dp = dp.ravel()[:U]\n\nanswer = min(dp[H:])\nprint(answer)\n", "H,N = map(int,input().split())\nls = []\nmaxA = 0\nfor i in range(N):\n    A,B = map(int,input().split())\n    ls.append([A,B])\n    maxA = max(maxA,A)\ndp = [0 for i in range(H+maxA+1)]\nfor i in range(1,H+maxA+1):\n    dp[i] = min(dp[i - j[0]] + j[1] for j in ls )\nprint(dp[H])", "h,n=map(int,input().split())\nc=[list(map(int,input().split()))for _ in range(n)]\nd=[0]*20002\nfor i in range(h):d[i]=min(d[i-a]+b for a,b in c)\nprint(d[h-1])"]
["n = int(input())\n\na, b = [1], [0]\n\nfor i in range(n):\n\tnew_b = a[:]\n\ta1 = a[:]\n\ta2 = a[:]\n\ta1.append(0)\n\ta2.append(0)\n\tfor i in range(-1, -len(b) - 1, -1):\n\t\ta1[i] += b[i]\n\tfor i in range(-1, -len(b) - 1, -1):\n\t\ta2[i] -= b[i]\n\tif max([abs(kek) for kek in a1]) < 2:\n\t\ta = a1\n\telif max([abs(kek) for kek in a2]) < 2:\n\t\ta = a2\n\telse:\n\t\tprint(\"oops\")\n\t\treturn\n\tb = new_b\nprint(len(a) - 1)\nprint(*(a[::-1]))\nprint(len(b) - 1)\nprint(*(b[::-1]))", "# python3\n# utf-8\n\nn = int(input())\nA = [1]\nB = []\nfor _ in range(n):\n    new_A = [0] + A[:]\n    new_B = A[:]\n    for i, b in enumerate(B):\n        new_A[i] += b\n    A = [a % 2 for a in new_A]\n    B = [b % 2 for b in new_B]\nprint(len(A) - 1)\nprint(*A)\nprint(len(B) - 1)\nprint(*B)\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\ndef gen(p, q, r):\n    x = [0, p]\n    y = [q]\n    for c in range(1, n):\n        \n        nx = [0] + [-xi for xi in x]\n        px = [0] + x\n        if r: nx, px = px, nx\n        \n        bad = 0\n        for i in range(len(y)):\n            px[i] += y[i]\n            if abs(px[i]) > 1:\n                bad = 1\n                break\n        if not bad:\n            x, y = px, x\n            continue\n        \n        bad = 0\n        for i in range(len(y)):\n            nx[i] += y[i]\n            if abs(nx[i]) > 1:\n                bad = 1\n                break\n        if not bad:\n            x, y = nx, x\n            continue\n        \n        print('OH NO')\n        z = 1 / 0\n    return x, y\n\nfound = 0\nfor i, j in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n    for r in [0, 1]:\n        x, y = gen(i, j, r)\n        #print(x, y)\n        if x[-1]==1 and y[-1]==1:\n            found = 1\n            break\n    if found: break\nif not found:\n    print(n, 'OH NO!!')\nprint(len(x)-1)\nprint(*x)\nprint(len(y)-1)\nprint(*y)\n", "n=int(input())\np = [[1], [0, 1]]\nfor i in range(n-1):\n    t=[0]+p[-1]\n    for j in range(len(p[i])):\n        t[j]^=p[i][j]\n    p.append(t)\nprint(n)\nprint(*p[n])\nprint(n-1)\nprint(*p[-2])\n", "n = int(input())\n\ndef print_poly(a):\n    print(len(a) - 1)\n    print(' '.join(map(str, a)))\n\ndef shift_add(a, mul, b):\n    c = [0] * (len(a) + 1)\n    for i in range(len(a)): c[i + 1] = a[i] * mul\n    for i in range(len(b)): c[i] += b[i]\n    return c\n\na = [0, 1]\nb = [1]\n\nfor i in range(n - 1):\n    c = shift_add(a, 1, b)\n    if max(c) <= 1 and min(c) >= -1:\n        a, b = c, a\n    else:\n        c = shift_add(a, -1, b)\n        if max(c) <= 1 and min(c) >= -1:\n            a, b = c, a\n        else:\n            print('> <')\n\nif a[-1] == -1:\n    a = list([-x for x in a])\nif b[-1] == -1:\n    b = list([-x for x in b])\n\nprint_poly(a)\nprint_poly(b)\n", "\nimport sys\n\nn = int(sys.stdin.readline().split()[0])\n\nclass Polynomial:\n    def __init__(self, coef):\n        first_nonzero = False\n        index = len(coef) - 1\n        while not first_nonzero:\n            if not coef[index] == 0:\n                first_nonzero = True\n            else:\n                if index == 0:\n                    first_nonzero = True\n                else:\n                    index -= 1\n        self.degree = index\n        self.coef = [coef[j] for j in range(index + 1)]\n    def multiply_by_x(self):\n        new_coef = [0]\n        for j in range(self.degree + 1):\n            new_coef.append(self.coef[j])\n        return Polynomial(new_coef)\n    def minus(self):\n        new_coef = [-self.coef[j] for j in range(self.degree + 1)]\n        return Polynomial(new_coef)\n    def add(self, other):\n        other_coef = other.coef\n        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]\n        m = min(self.degree, other.degree)\n        M = max(self.degree, other.degree)\n        if self.degree > other.degree:\n            bigger_poly = self\n        else:\n            bigger_poly = other\n        for j in range(m + 1):\n            new_coef[j] = self.coef[j] + other.coef[j]\n        for j in range(m + 1, M+1):\n            new_coef[j] = bigger_poly.coef[j]\n            \n        return Polynomial(new_coef) \n    def is_legal(self):\n        result = True\n        bools = [None for j in range(self.degree + 1)]\n        bools[self.degree] = self.coef[self.degree] == 1\n        for j in range(self.degree):\n            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1\n        for j in range(self.degree + 1):\n            result = result and bools[j]\n        return result\n    def print(self):\n        output = \"\"\n        for j in range(self.degree + 1):\n            output += str(self.coef[j]) + \" \"\n        print(output)\n            \n        \n\nf = []\n\nf.append(Polynomial([1]))\nf.append(Polynomial([0, 1]))\n\nfor j in range(2, 151):\n    xf = f[j-1].multiply_by_x()\n    t_1 = xf.add(f[j - 2])\n    t_2 = xf.add(f[j - 2].minus())\n    if t_1.is_legal():\n        f.append(t_1)\n    elif t_2.is_legal():\n        f.append(t_2)\n    #print(\":(\")\n\n\nprint(f[n].degree)\nf[n].print()\nprint(f[n-1].degree)\nf[n-1].print()\n\n#for j in range(len(f)):\n    #f[j].print()\n", "f = [[1], [0, 1]]\n\nn = int(input())\n\nfor i in range(2, n + 1):\n\tl = [0] + f[i - 1]\n\tfor j in range(len(f[i - 2])):\n\t\tl[j] = (l[j] + f[i - 2][j]) & 1\n\tf.append(l)\n\nprint(n)\nprint(*f[n])\nprint(n - 1)\nprint(*f[n - 1])\n\n\n\n# Made By Mostafa_Khaled\n"]
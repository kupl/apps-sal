["s = input()\nn = len(s)\n\ndp = [[0 for i in range(n - le + 1)] for le in range(n + 1)]\nans = [0 for i in range(n + 1)]\n\nfor le in range(1, n + 1):\n    for l in range(0, n - le + 1):\n        r = l + le\n        if s[l] != s[r - 1]:\n            continue\n        if le == 1:\n            dp[1][l] = 1\n            ans[1] += 1\n        elif le == 2:\n            ans[2] += 1\n            dp[2][l] = 2\n        elif dp[le - 2][l + 1]:\n            v = 1\n            m = (l + r) // 2\n            st = m + 1 if le & 1 else m\n            le2 = m - l\n            q = dp[le2][l]\n            if q:\n                v = q + 1\n\n            ans[v] += 1\n            dp[le][l] = v\n\n\nfor i in range(n - 1, 0, -1):\n    ans[i] += ans[i + 1]\n\nprint(*ans[1:])\n", "s = input()\nn = len(s)\n\ndp = [[0 for i in range(n - le + 1)] for le in range(n + 1)]\nans = [0 for i in range(n + 1)]\n\nfor le in range(1, n + 1):\n    for l in range(0, n - le + 1):\n        r = l + le\n        if s[l] != s[r - 1]:\n            continue\n        if le == 1:\n            dp[1][l] = 1\n            ans[1] += 1\n        elif le == 2:\n            ans[2] += 1\n            dp[2][l] = 2\n        elif dp[le - 2][l + 1]:\n            v = 1\n            m = (l + r) // 2\n            st = m + 1 if le & 1 else m\n            le2 = m - l\n            q = dp[le2][l]\n            if q:\n                v = q + 1\n\n            ans[v] += 1\n            dp[le][l] = v\n\n\nfor i in range(n - 1, 0, -1):\n    ans[i] += ans[i + 1]\n\nprint(*ans[1:])", "s = input()\nn = len(s)\n\ndp = [[0 for i in range(n - le + 1)] for le in range(n + 1)]\nans = [0 for i in range(n + 1)]\n\nfor le in range(1, n + 1):\n    for l in range(0, n - le + 1):\n        r = l + le\n        if s[l] != s[r - 1]:\n            continue\n        if le == 1:\n            dp[1][l] = 1\n            ans[1] += 1\n        elif le == 2:\n            ans[2] += 1\n            dp[2][l] = 2\n        elif dp[le - 2][l + 1]:\n            v = 1\n            m = (l + r) // 2\n            st = m + 1 if le & 1 else m\n            le2 = m - l\n            q = dp[le2][l]\n            if q:\n                v = q + 1\n\n            ans[v] += 1\n            dp[le][l] = v\n\n\nfor i in range(n - 1, 0, -1):\n    ans[i] += ans[i + 1]\n\nprint(*ans[1:])", "s = input().strip()\nn = len(s)\npl = [0]*(n+1)\n\ndp = [[0]*n for i in range(n)]\n\nfor i in range(n):\n\tfor j in range(n-i):\n\t\tl = j+i\n\t\tif i == 0:\n\t\t\tdp[j][l] = 1\n\t\t\tpl[1] +=1\n\t\telif  i == 1:\n\t\t\tif s[j] == s[l]:\n\t\t\t\tdp[j][l] = 2\n\t\t\t\tpl[2] += 1\n\t\telse:\n\t\t\tif s[j] == s[l] and dp[j+1][l-1] > 0:\n\t\t\t\tif (i+1)%2 == 0:\n\t\t\t\t\tmid = int((i+1)/2)-1\n\t\t\t\t\tdp[j][l] = dp[j][j+mid]  + 1\n\t\t\t\t\tpl[dp[j][l]] += 1\n\t\t\t\telse:\n\t\t\t\t\tmid = int((i+1)/2)-1\n\t\t\t\t\tdp[j][l] = dp[j][j+mid]  +1\t\n\t\t\t\t\tpl[dp[j][l]] += 1\n\nans = ''\nfor i in range(n-1,-1,-1):\n\tpl[i] += pl[i+1]\nfor i in  range(1,n+1):\n\tans = ans + str(pl[i]) + ' '\nprint(ans)", "s = input()\n\nsize = len(s)\n\ndp = [[0 for l in range(size)] for li in range(size)]\n\nans = [0]*(size+1)\n\nfor i in range(1, size+1):\n    if i == 1:\n        for j in range(0, size):\n            dp[j][j] = 1\n            ans[1] += 1\n    elif i == 2:\n        for j in range(0, size-1):\n            if s[j+1] == s[j]:\n                dp[j][j+1] = 2\n                ans[1] += 1\n                ans[2] += 1\n            else:\n                dp[j][j+1] = 0\n    else:\n        for j in range(0, size-i+1):\n            if s[j] != s[j+i-1] or dp[j+1][j+i-2] == 0:\n                dp[j][j+i-1] = 0\n            else:\n                dp[j][j+i-1] = dp[j][int((j+j+i-2)/2)] + 1\n                for p in range(1, dp[j][j+i-1]+1):\n                    ans[p] += 1\n\nfor i in range(1, size):\n    print(ans[i], end=\"\")\n    print(\" \", end=\"\")\nprint(ans[size])\n", "s = input()\nn = len(s)\n\ndp = [[0 for i in range(n - le + 1)] for le in range(n + 1)]\nans = [0 for i in range(n + 1)]\n\nfor le in range(1, n + 1):\n    for l in range(0, n - le + 1):\n        r = l + le\n        if s[l] != s[r - 1]:\n            continue\n        if le == 1:\n            dp[1][l] = 1\n            ans[1] += 1\n        elif le == 2:\n            ans[2] += 1\n            dp[2][l] = 2\n        elif dp[le - 2][l + 1]:\n            v = 1\n            m = (l + r) // 2\n            st = m + 1 if le & 1 else m\n            le2 = m - l\n            q = dp[le2][l]\n            if q:\n                v = q + 1\n\n            ans[v] += 1\n            dp[le][l] = v\n\n\nfor i in range(n - 1, 0, -1):\n    ans[i] += ans[i + 1]\n\nprint(*ans[1:])", "s = input()\n\ndp = [[0]*5005 for _ in range(5005)]\nn = len(s)\nans = [0 for _ in range(5005)]\n\nfor length in range(1,n+1):\n\tfor l in range(n-length+1):\n\t\tr = l+length\n\t\tif(length == 1):\n\t\t\tdp[l][r] = 1\n\t\t\tcontinue\n\t\telif(length == 2):\n\t\t\tdp[l][r] = 2 if(s[l] == s[r-1]) else 0\n\t\t\tcontinue\n\t\tif(s[l] != s[r-1] or dp[l+1][r-1] == 0):\n\t\t\tcontinue\n\t\tdp[l][r] = 1\n\t\tm = (l+r) // 2\n\t\tif(length&1):\n\t\t\tif(dp[l][m] and dp[m+1][r]):\n\t\t\t\tdp[l][r] = dp[l][m]+1\n\t\telse:\n\t\t\tif(dp[l][m] and dp[m][r]):\n\t\t\t\tdp[l][r] = dp[l][m]+1\n\nfor length in range(1,n+1):\n\tfor l in range(n-length+1):\n\t\tans[dp[l][l+length]] += 1\n\nfor i in range(n-1,0,-1):\n\tans[i] += ans[i+1]\n\nfor i in range(1,n+1):\n\tprint(ans[i],end=' ')\n\nprint()\n", "s = input()\nn = len(s)\nmax_palin = [[0 for i in range(n + 1)] for j in range(n + 1)]\ncount = [0 for i in range(n + 1)]\n\nfor sub_len in range(1, n + 1):\n    for left in range(0, n - sub_len + 1):\n        right = left + sub_len - 1\n\n        if sub_len == 1:\n            max_palin[left][right] = 1\n        elif sub_len == 2:\n            if s[left] == s[right]:\n                max_palin[left][right] = 2\n            else:\n                max_palin[left][right] = 0\n        else:\n            if s[left] == s[right] and max_palin[left + 1][right - 1] > 0:\n                mid = (left + right) // 2\n\n                if sub_len % 2 == 0:\n                    max_palin[left][right] = max_palin[left][mid] + 1\n                else:\n                    max_palin[left][right] = max_palin[left][mid - 1] + 1\n\n        count[max_palin[left][right]] += 1\n\nfor i in range(n - 1, 0, -1):\n    count[i] += count[i + 1]\n\nfor i in range(1, n + 1):\n    print(count[i], end=' ')\n\nprint()\n", "s = input()\nn = len(s)\nmax_palin = [[0 for i in range(n + 1)] for j in range(n + 1)]\ncount = [0 for i in range(n + 1)]\n\nfor sub_len in range(1, n + 1):\n    for left in range(0, n - sub_len + 1):\n        right = left + sub_len - 1\n\n        if sub_len == 1:\n            max_palin[left][right] = 1\n        elif sub_len == 2:\n            if s[left] == s[right]:\n                max_palin[left][right] = 2\n            else:\n                max_palin[left][right] = 0\n        else:\n            if s[left] == s[right] and max_palin[left + 1][right - 1] > 0:\n                max_palin[left][right] = max_palin[left][left + sub_len // 2 - 1] + 1\n\n        count[max_palin[left][right]] += 1\n\nfor i in range(n - 1, 0, -1):\n    count[i] += count[i + 1]\n\nfor i in range(1, n + 1):\n    print(count[i], end=' ')\n\nprint()\n", "P = 311\n# we use two mods to reduce the chance of collision\nMOD1 = int(1e9) + 7\nMOD2 = int(1e9) + 9\n\n\ndef main():\n    s = input()\n    n = len(s)\n\n    # Pre-compute\n    power_1 = [0 for i in range(n + 1)]\n    power_2 = [0 for i in range(n + 1)]\n    mod_inv_1 = [0 for i in range(n + 1)]\n    mod_inv_2 = [0 for i in range(n + 1)]\n    power_1[0] = 1\n    power_2[0] = 1\n    mod_inv_1[0] = 1\n    mod_inv_2[0] = 1\n\n    for i in range(1, n + 1):\n        power_1[i] = power_1[i - 1] * P % MOD1\n        power_2[i] = power_2[i - 1] * P % MOD1\n        mod_inv_1[i] = bin_exp(power_1[i], MOD1 - 2, MOD1)\n        mod_inv_2[i] = bin_exp(power_2[i], MOD2 - 2, MOD2)\n\n    # Compute hash values\n    hash_1 = 0\n    hash_2 = 0\n    forward_hash_1 = [0 for i in range(n + 1)]\n    forward_hash_2 = [0 for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n        hash_1 += ord(s[i - 1]) * power_1[i]\n        hash_2 += ord(s[i - 1]) * power_2[i]\n        hash_1 %= MOD1\n        hash_2 %= MOD2\n        forward_hash_1[i] = hash_1\n        forward_hash_2[i] = hash_2\n\n    hash_1 = 0\n    hash_2 = 0\n    backward_hash_1 = [0 for i in range(n + 1)]\n    backward_hash_2 = [0 for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n        hash_1 += ord(s[n - i]) * power_1[i]\n        hash_2 += ord(s[n - i]) * power_2[i]\n        hash_1 %= MOD1\n        hash_2 %= MOD2\n        backward_hash_1[i] = hash_1\n        backward_hash_2[i] = hash_2\n\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    count = [0 for i in range(n + 1)]\n\n    for sub_len in range(1, n + 1):\n        for left in range(0, n - sub_len + 1):\n            right = left + sub_len - 1\n\n            if sub_len == 1:\n                dp[left][right] = 1\n            elif sub_len == 2:\n                if s[left] == s[right]:\n                    dp[left][right] = 2\n            else:\n                if s[left] == s[right] and dp[left + 1][right - 1] > 0:\n                    dp[left][right] = dp[left][left + sub_len // 2 - 1] + 1\n\n            count[dp[left][right]] += 1\n\n    for i in range(n - 1, 0, -1):\n        count[i] += count[i + 1]\n\n    for i in range(1, n + 1):\n        print(count[i], end=' ')\n\n    print()\n\n\ndef bin_exp(a, x, mod):\n    res = 1\n    \n    while x > 0:\n        if x & 1:\n            res *= a\n            res %= mod\n        a *= a \n        a %= mod \n        x >>= 1\n    \n    return res\n\n\ndef get_forward_hash(forward_hash, mod_inv, left, right, mod):\n    return (forward_hash[right + 1] - forward_hash[left] + mod) * mod_inv[left] % mod\n\n\ndef get_backward_hash(backward_hash, mod_inv, n, left, right):\n    r_left = n - left - 1\n    r_right = n - right - 1\n    return (backward_hash[r_left + 1] - backward_hash[r_right] + mod) * mod_inv[r_right] % mod\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    s = input()\n    n = len(s)\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    count = [0 for i in range(n + 1)]\n\n    for sub_len in range(1, n + 1):\n        for left in range(0, n - sub_len + 1):\n            right = left + sub_len - 1\n\n            if sub_len == 1:\n                dp[left][right] = 1\n            elif sub_len == 2:\n                if s[left] == s[right]:\n                    dp[left][right] = 2\n            else:\n                if s[left] == s[right] and dp[left + 1][right - 1] > 0:\n                    dp[left][right] = dp[left][left + sub_len // 2 - 1] + 1\n\n            count[dp[left][right]] += 1\n\n    for i in range(n - 1, 0, -1):\n        count[i] += count[i + 1]\n\n    for i in range(1, n + 1):\n        print(count[i], end=' ')\n\n    print()\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class HString:\n\tdef __init__(self, string, base=257, modulo=1000000007):\n\t\tself.__base, self.__modulo = base, modulo\n\t\tself.__prefix_hash, self.__base_pow, self.__size = [], [1], 0\n\n\t\tself += string\n\t\n\tdef __add__(self, string):\n\t\tfor ch in string:\n\t\t\tself.__base_pow.append((self.__base_pow[-1] * self.__base) % self.__modulo)\n\t\t\tif self.__size == 0: self.__prefix_hash.append(ord(ch))\n\t\t\telse: self.__prefix_hash.append((self.__prefix_hash[-1] * self.__base + ord(ch)) % self.__modulo)\n\t\t\tself.__size += 1\n\t\treturn self\n\t\n\tdef size(self): return self.__size\n\n\tdef getModulo(self): return self.__modulo\n\n\tdef getHashValue(self, st, en):\n\t\tvalue = self.__prefix_hash[en]\n\t\tif st > 0:\n\t\t\tvalue -= ((self.__prefix_hash[st-1] * self.__base_pow[en-st+1]) % self.__modulo)\n\t\t\tif value < 0: value += self.__modulo\n\t\treturn value\n\ndef palindromic_characteristics(s):\n\tn, org, rev = len(s), HString(s), HString(s[::-1])\n\tpalindrome_level = [[0 for _ in range(n)] for _ in range(n)]\n\tpalindrome_level_count = [0 for _ in range(n + 1)]\n\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\tif org.getHashValue(i, j) == rev.getHashValue(n-1-j, n-1-i):\n\t\t\t\tmid = (i + j) // 2 + (i + j) % 2\n\t\t\t\tif i > mid-1: palindrome_level[i][j] = 1\n\t\t\t\telse: palindrome_level[i][j] = palindrome_level[i][mid-1] + 1\n\t\t\t\tpalindrome_level_count[palindrome_level[i][j]] += 1\n\t\n\tfor i in range(n-1, 0, -1): palindrome_level_count[i] += palindrome_level_count[i+1]\n\treturn palindrome_level_count[1:]\n\ns = input()\nprint(' '.join(map(str, palindromic_characteristics(s))))", "class HString:\n\tdef __init__(self, string, base=257, modulo=1000000007):\n\t\tself.__base, self.__modulo = base, modulo\n\t\tself.__prefix_hash, self.__base_pow, self.__size = [], [1], 0\n\n\t\tself += string\n\t\n\tdef __add__(self, string):\n\t\tfor ch in string:\n\t\t\tself.__base_pow.append((self.__base_pow[-1] * self.__base) % self.__modulo)\n\t\t\tif self.__size == 0: self.__prefix_hash.append(ord(ch))\n\t\t\telse: self.__prefix_hash.append((self.__prefix_hash[-1] * self.__base + ord(ch)) % self.__modulo)\n\t\t\tself.__size += 1\n\t\treturn self\n\t\n\tdef size(self): return self.__size\n\n\tdef getModulo(self): return self.__modulo\n\n\tdef getHashValue(self, st, en):\n\t\tvalue = self.__prefix_hash[en]\n\t\tif st > 0:\n\t\t\tvalue -= ((self.__prefix_hash[st-1] * self.__base_pow[en-st+1]) % self.__modulo)\n\t\t\tif value < 0: value += self.__modulo\n\t\treturn value\n\ndef palindromic_characteristics(s):\n\tn, org, rev = len(s), HString(s), HString(s[::-1])\n\tpalindrome_level = [[0 for _ in range(n)] for _ in range(n)]\n\tpalindrome_level_count = [0 for _ in range(n + 1)]\n\n\ti, j = 0, 0\n\twhile i < n:\n\t\tj = i\n\t\twhile j < n:\n\t\t\tif org.getHashValue(i, j) == rev.getHashValue(n-1-j, n-1-i):\n\t\t\t\tmid = (i + j) // 2 + (i + j) % 2\n\t\t\t\tif i > mid-1: palindrome_level[i][j] = 1\n\t\t\t\telse: palindrome_level[i][j] = palindrome_level[i][mid-1] + 1\n\t\t\t\tpalindrome_level_count[palindrome_level[i][j]] += 1\n\t\t\tj += 1\n\t\ti += 1\n\t\n\tfor i in range(n-1, 0, -1): palindrome_level_count[i] += palindrome_level_count[i+1]\n\treturn palindrome_level_count[1:]\n\ns = input()\nprint(' '.join(map(str, palindromic_characteristics(s))))", "class HString:\n\tdef __init__(self, string, base=257, modulo=1000000007):\n\t\tself.__base, self.__modulo = base, modulo\n\t\tself.__prefix_hash, self.__base_pow, self.__size = [], [1], 0\n\n\t\tself += string\n\t\n\tdef __add__(self, string):\n\t\tfor ch in string:\n\t\t\tself.__base_pow.append((self.__base_pow[-1] * self.__base) % self.__modulo)\n\t\t\tif self.__size == 0: self.__prefix_hash.append(ord(ch))\n\t\t\telse: self.__prefix_hash.append((self.__prefix_hash[-1] * self.__base + ord(ch)) % self.__modulo)\n\t\t\tself.__size += 1\n\t\treturn self\n\t\n\tdef size(self): return self.__size\n\n\tdef getModulo(self): return self.__modulo\n\n\tdef getHashValue(self, st, en):\n\t\tvalue = self.__prefix_hash[en]\n\t\tif st > 0:\n\t\t\tvalue -= ((self.__prefix_hash[st-1] * self.__base_pow[en-st+1]) % self.__modulo)\n\t\t\tif value < 0: value += self.__modulo\n\t\treturn value\n\ns = input()\nn, org, rev = len(s), HString(s), HString(s[::-1])\npalindrome_level = [[0 for _ in range(n)] for _ in range(n)]\npalindrome_level_count = [0 for _ in range(n + 1)]\n\nfor i in range(n):\n\tfor j in range(i, n):\n\t\tif org.getHashValue(i, j) == rev.getHashValue(n-1-j, n-1-i):\n\t\t\tmid = (i + j) // 2 + (i + j) % 2\n\t\t\tif i > mid-1: palindrome_level[i][j] = 1\n\t\t\telse: palindrome_level[i][j] = palindrome_level[i][mid-1] + 1\n\t\t\tpalindrome_level_count[palindrome_level[i][j]] += 1\n\nfor i in range(n-1, 0, -1): palindrome_level_count[i] += palindrome_level_count[i+1]\n\nprint(' '.join(map(str, palindrome_level_count[1:])))", "def palindromic_characteristics(s):\n\tn = len(s)\n\tpalindrome_level = [[0 for _ in range(n)] for _ in range(n)]\n\tpalindrome_level_count = [0 for _ in range(n + 1)]\n\n\tfor i in range(n):\n\t\tj = i\n\t\twhile i >= 0 and j < n and s[i] == s[j]:\n\t\t\tpalindrome_level[i][j] = 1\n\t\t\ti, j = i - 1, j + 1\n\t\n\tfor i in range(n-1):\n\t\tj = i + 1\n\t\twhile i >= 0 and j < n and s[i] == s[j]:\n\t\t\tpalindrome_level[i][j] = 1\n\t\t\ti, j = i - 1, j + 1\n\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\tif palindrome_level[i][j] > 0:\n\t\t\t\tmid = (i + j) // 2 + (i + j) % 2\n\t\t\t\tif i <= mid-1: palindrome_level[i][j] = palindrome_level[i][mid-1] + 1\n\n\t\t\t\tpalindrome_level_count[palindrome_level[i][j]] += 1\n\t\n\tfor i in range(n-1, 0, -1): palindrome_level_count[i] += palindrome_level_count[i+1]\n\treturn palindrome_level_count[1:]\n\ns = input()\nprint(' '.join(map(str, palindromic_characteristics(s))))", "def PanlidromicCharacteristics(string):\n  n = len(string)\n  res = [[0 for i in range (n)] for j in range (n)]\n  count = [0 for i in range (n + 1)]\n  # for i in range (n):\n  #   res[i][i] = 1\n  #   count[1] += 1\n  \n  for length in range (1, n + 1):\n    for i in range (n-length + 1):\n      j = i + length - 1\n      if length == 1:\n          res[i][j] = 1\n      elif length == 2 and string[i] == string[j]:\n          res[i][j] = 2\n      elif string[i] == string[j] and res[i + 1][j - 1] > 0:\n        res[i][j] = res[i][i + length//2 - 1]  + 1        \n      count[res[i][j]] += 1\n      \n  # k-palindrome is also a (k - 1)-palindrome\n  for i in range (len(count) - 1, 0, -1):\n    count[i - 1] += count[i]\n  for i in range (1, len(count)):\n    print(count[i], end = \" \")\n  return \n  \nstring = input()\nPanlidromicCharacteristics(string)"]
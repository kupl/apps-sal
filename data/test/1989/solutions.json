["INF = 10 ** 10\ndef merge(l, r):\n    res = l + r\n    \n    i = j = k = 0\n    while i < len(l) and j < len(r):\n        if l[i] < r[j]:\n            res[k] = l[i]\n            k += 1\n            i += 1\n        else:\n            res[k] = r[j]\n            k += 1\n            j += 1\n    while i < len(l):\n        res[k] = l[i]\n        k += 1\n        i += 1\n    while j < len(r):\n        res[k] = r[j]\n        k += 1\n        j += 1\n\n    return res\n\ndef solve(fl, fr, l, r):\n    if l == r:\n        return 0\n    \n    mid = (l + r) // 2\n    res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\n\n    i, j = l, mid + 1\n    while i <= mid:\n        while j <= r and fr[j] < fl[i]:\n            j += 1\n        res += j - mid - 1\n        i += 1\n    fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\n    fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\n    return res\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    fl, cnt = [], {}\n    for x in a:\n        cnt[x] = cnt.get(x, 0) + 1\n        fl.append(cnt[x])\n\n    fr, cnt = [], {}\n    for x in a[::-1]:\n        cnt[x] = cnt.get(x, 0) + 1\n        fr.append(cnt[x])\n    fr = fr[::-1]\n\n#     print(fl, fr)\n    print(solve(fl, fr, 0, n - 1))\n#     print(fl, fr)\n\n__starting_point()", "INF = 10 ** 10\ndef merge(l, r):\n    res = l + r\n    \n    i = j = k = 0\n    while i < len(l) and j < len(r):\n        if l[i] < r[j]:\n            res[k] = l[i]\n            k += 1\n            i += 1\n        else:\n            res[k] = r[j]\n            k += 1\n            j += 1\n    res[k:] = l[i:] + r[j:]\n\n    return res\n\ndef solve(fl, fr, l, r):\n    if l == r:\n        return 0\n    \n    mid = (l + r) // 2\n    res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\n\n    i, j = l, mid + 1\n    while i <= mid:\n        while j <= r and fr[j] < fl[i]:\n            j += 1\n        res += j - mid - 1\n        i += 1\n    fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\n    fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\n    return res\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    fl, cnt = [], {}\n    for x in a:\n        cnt[x] = cnt.get(x, 0) + 1\n        fl.append(cnt[x])\n\n    fr, cnt = [], {}\n    for x in a[::-1]:\n        cnt[x] = cnt.get(x, 0) + 1\n        fr.append(cnt[x])\n    fr = fr[::-1]\n\n#     print(fl, fr)\n    print(solve(fl, fr, 0, n - 1))\n#     print(fl, fr)\n\n__starting_point()", "from itertools import combinations,permutations\nfrom collections import defaultdict\nimport math\nimport sys\nimport os\n\n\ndef zeror():\n    return 0\n\n\nprefix_sums = []\nftree = []\n\n\nclass FenwickTree(object):\n\n    def __init__(self, n):\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, v):\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] += v\n            i = i + (((~i) + 1) & i)\n\n    def query(self, l, r):\n        lt = 0\n        i = l\n        while i != 0:\n            lt += self.tree[i]\n            i = i - (((~i) + 1) & i)\n        rt = 0\n        i = r + 1\n        while i != 0:\n            rt += self.tree[i]\n            i -= (((~i) + 1) & i)\n        return rt - lt\n\n\n\ndef solution(n,a):\n\n    onetoi = []\n    seen1i = defaultdict(int)\n\n    for i in range(n):\n        seen1i[a[i]] += 1\n        onetoi.append(seen1i[a[i]])\n\n    #print(onetoi)\n    #print(seen1i)\n\n    jton = []\n    seenjn = defaultdict(int)\n    for j in range(n - 1, -1, -1):\n        seenjn[a[j]] += 1\n        jton.append(seenjn[a[j]])\n\n    #print(jton)\n    #print(seenjn)\n\n    jton = jton[::-1]\n\n    fw = FenwickTree(1000000)\n\n\n    for v in jton:\n        fw.update(v, 1)\n    t = 0\n    for i in range(n):\n        fw.update(jton[i], -1)\n        t += fw.query(0, onetoi[i] - 1)\n        #print(t)\n\n    return t\n\n\n\ndef main():\n\n\n    \"\"\"a=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    ft = FenwickTree(len(a)*3)\n    for i,v in enumerate(a):\n        ft.update(i,v)\n    print(ft.tree)\n    print(ft.query(0,10))\n    return\"\"\"\n\n    n=int(input())\n    arr=list(map(int,input().strip().split()))\n    print(solution(n,arr))\n\n\ndef __starting_point():\n    main()\n\n\n\"\"\"\n\n7\n1 2 1 1 2 2 1\n\n\n\"\"\"\n__starting_point()", "import sys\ndef update(i,val):\n    while i <maxi:\n        bit[i] +=val\n        i += i&(-i)\ndef query(i):\n    ans=0\n    while i>0:\n        ans += bit[i]\n        i -= i&(-i)\n    return(ans)\nfrom collections import defaultdict\n# taking inputs\n\nn = int(input())\nl = list(map(int,sys.stdin.readline().split()))\nbit = [0 for i in range(n+30)]\nmaxi = n+20\none_to_i =[]\nd=defaultdict(int)\nfor i in range(n-1):\n    d[l[i]] += 1\n    one_to_i.append(d[l[i]])\none_to_i = one_to_i[::-1]\nj_to_n =[]\nd2 = defaultdict(int)\nfor i in range(n-1,0,-1):\n    d2[l[i]] += 1\n    j_to_n.append(d2[l[i]])\nans = 0\nfor i in range(n-1):\n    update(j_to_n[i],1)\n    ans += query(one_to_i[i]-1)\nprint(ans)", "from sys import stdin,stdout\nclass bit:\n    def __init__(self,n):\n        self.n=n\n        self.f=[0]*(n+1)\n    def update(self,pos,value):\n        while pos <=self.n:\n            self.f[pos]+=value\n            pos+=(pos&-pos)\n    def sum(self,pos):\n        res=0\n        while pos:\n            res+=self.f[pos]\n            pos-=(pos&-pos)\n        return res\ndef unique(A):\n    C=sorted(A)\n    B=[]\n    for element in C:\n        if (not (B)) or B[-1]!=element:\n            B.append(element)\n    return B\nn=int(stdin.readline())\nA=[int(x)for x in stdin.readline().split()]\nAtmp=[0]*n\nWork=bit(n+10)\nMap={}\nfor index in range(n-1,-1,-1):\n    if A[index] in Map:\n        Map[A[index]]+=1\n    else:Map[A[index]]=1\n    #print(Map[A[index]])\n    Atmp[index]=(Map[A[index]])\n    Work.update(Map[A[index]],1)\n\nMap.clear()\nans=0\nfor i in range(n):\n    if A[i] in Map:\n        Map[A[i]]+=1\n    else:Map[A[i]]=1\n    \n    Work.update(Atmp[i],-1)\n    ans+=Work.sum(Map[A[i]]-1)\n    #print(ans)\nstdout.write(\"%d\"%ans)\n    \n\n\n\n\n\n\n\n\n\n\n", "from sys import stdin,stdout\nclass bit:\n    def __init__(self,n):\n        self.n=n\n        self.f=[0]*(n+1)\n    def update(self,pos,value):\n        while pos <=self.n:\n            self.f[pos]+=value\n            pos+=(pos&-pos)\n    def sum(self,pos):\n        res=0\n        while pos:\n            res+=self.f[pos]\n            pos-=(pos&-pos)\n        return res\ndef unique(A):\n    C=sorted(A)\n    B=[]\n    for element in C:\n        if (not (B)) or B[-1]!=element:\n            B.append(element)\n    return B\nn=int(stdin.readline())\nA=[int(x)for x in stdin.readline().split()]\nAtmp=[0]*n\nWork=bit(n+10)\nMap={}\nfor index in range(n-1,-1,-1):\n    if A[index] in Map:\n        Map[A[index]]+=1\n    else:Map[A[index]]=1\n    #print(Map[A[index]])\n    Atmp[index]=(Map[A[index]])\n    Work.update(Map[A[index]],1)\n\nMap.clear()\nans=0\nfor i in range(n):\n    if A[i] in Map:\n        Map[A[i]]+=1\n    else:Map[A[i]]=1\n    \n    Work.update(Atmp[i],-1)\n    ans+=Work.sum(Map[A[i]]-1)\n    #print(ans)\nstdout.write(\"%d\"%ans)\n    \n\n\n\n\n\n\n\n\n\n", "INF = 10 ** 10\n# merge two sorted lists l and r\ndef merge(l, r):\n    res = l + r\n    \n    i = j = k = 0\n    while i < len(l) and j < len(r):\n        if l[i] < r[j]:\n            res[k] = l[i]\n            k += 1\n            i += 1\n        else:\n            res[k] = r[j]\n            k += 1\n            j += 1\n\n    res[k:] = l[i:] + r[j:]\n    return res\n\ndef solve(fl, fr, l, r):\n    if l == r:\n        return 0\n    \n    mid = (l + r) // 2\n    # after calling solve(l, mid) and (mid + 1, r), fl and fr are sorted on these ranges\n    res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\n\n    # perform 2-pointers on 2 sorted lists\n    i, j = l, mid + 1\n    while i <= mid:\n        while j <= r and fr[j] < fl[i]:\n            j += 1\n        res += j - mid - 1\n        i += 1\n        \n    # merge 2 sorted lists\n    fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\n    fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\n    return res\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    fl, cnt = [], {}\n    for x in a:\n        cnt[x] = cnt.get(x, 0) + 1\n        # fl[i] = f(0, i, a[i])\n        fl.append(cnt[x])\n\n    fr, cnt = [], {}\n    for x in a[::-1]:\n        cnt[x] = cnt.get(x, 0) + 1\n        # fr[i] = f(i, n - 1, a[i])\n        fr.append(cnt[x])\n    fr = fr[::-1]\n\n    print(solve(fl, fr, 0, n - 1))\n\n__starting_point()", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/7/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\n\ndef solve(N, A):\n    \n    B = list(sorted(set(A)))\n    vi = {v: i for i, v in enumerate(B)}\n    A = [vi[v] for v in A]\n    \n    wc = collections.defaultdict(int)\n    precount = [0 for _ in range(N)]\n    for i, v in enumerate(A):\n        wc[v] += 1\n        precount[i] = wc[v]\n    \n    \n        \n    \n    wc = collections.defaultdict(int)\n    sufcount = []\n    for v in reversed(A):\n        wc[v] += 1\n        sufcount.append(wc[v])\n    sufcount = sufcount[::-1]\n\n    bit = [0 for _ in range(N)]\n\n    def add(index, val):\n        while index < N:\n            bit[index] += val\n            index |= index + 1\n\n    def query(index):\n        s = 0\n        while index >= 0:\n            s += bit[index]\n            index = (index & (index + 1)) - 1\n        return s\n\n    ans = 0\n    for i in range(N - 2, -1, -1):\n        v = precount[i]\n        add(sufcount[i+1], 1)\n        ans += query(v-1)\n                \n    return ans\n    \n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(solve(N, A))", "# 459D\nimport sys\nfrom collections import Counter\n\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * n\n    \n    def _F(self, i):\n        return i & (i + 1)\n    \n    def _getSum(self, r):\n        '''\n        sum on interval [0, r]\n        '''\n        result = 0\n        while r >= 0:\n            result += self.tree[r]\n            r = self._F(r) - 1\n        return result\n    \n    def getSum(self, l, r):\n        '''\n        sum on interval [l, r]\n        '''\n        return self._getSum(r) - self._getSum(l - 1)\n    \n    def _H(self, i):\n        return i | (i + 1)\n    \n    def add(self, i, value=1):\n        while i < self.n:\n            self.tree[i] += value\n            i = self._H(i)\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\na = list(map(int, input().split()))\n    \n# inf.close()\n\nfreq = BIT(n+1)\nf_left = [0] * n\nf_right = [0] * n\nctr = Counter()\nfor i, val in enumerate(a):\n    ctr[val] += 1\n    f_left[i] = ctr[val]\nfor i in range(n):\n    val = a[i]\n    f_right[i] = ctr[val] - f_left[i] + 1\nfor f_r in f_right:\n    freq.add(f_r, 1)\nans = 0\nfor i, f_l in enumerate(f_left):\n    f_r = f_right[i]\n    freq.add(f_r, -1)\n    ans += freq.getSum(1, f_l-1)\nprint(ans)\n", "def merge(a, x, y, u, v):\n    i = 0\n    b = a[x:v+1]\n    j = u\n    for k in range(x, y + 1):\n        while j <= v and a[j] < a[k]:\n            b[i] = a[j]\n            j += 1\n            i += 1\n        b[i] = a[k]\n        i += 1\n    while j <= u:\n        b[i] = a[j]\n        i += 1\n        j += 1\n    return b\n\ndef cal(l, r, x, y):\n    if x == y:\n        return 0\n    mid = (x + y)//2\n    res = cal(l, r, x, mid) + cal(l, r, mid + 1, y)\n    \n    j = mid + 1\n    for i in range(x, mid + 1):\n        while j <= y and r[j] < l[i]:\n            j += 1\n        res += j - mid - 1\n    l[x:y + 1] = merge(l, x, mid, mid + 1, y)\n    r[x:y + 1] = merge(r, x, mid, mid + 1, y)\n    return res\n    \ndef countOccurrencePairs(a):\n    n = len(a)\n    l = [0 for _ in range(n)]\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = 0\n        d[a[i]] += 1\n        l[i] = d[a[i]]\n        \n    r = [0 for _ in range(n)]\n    d = {}\n    for i in range(n - 1, -1, -1):\n        if a[i] not in d:\n            d[a[i]] = 0\n        d[a[i]] += 1\n        r[i] = d[a[i]]\n        \n    return cal(l, r, 0, n - 1)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(countOccurrencePairs(a))\n    \n", "from collections import defaultdict\ntotal = 0\ndef update(ft,pos,val):\n    nonlocal total\n    total += 1\n    while pos < len(ft) :\n        ft[pos]+=val\n        pos+= pos&(-pos)\n\ndef query(ft,pos):\n    ans = 0\n    while pos > 0:\n        ans +=ft[pos]\n        pos-= pos&(-pos)\n    return ans\n\nn = int(input())\narr = list(map(lambda x:int(x),input().split()))\nfreCount = defaultdict(int)\nleftCount = []\nrightCount = []\nans = 0\nft = [0] * (n+10)\n\nfor i in range(n):\n    if arr[i] in freCount:\n        freCount[arr[i]]+=1\n    else :\n        freCount[arr[i]]=1\n    leftCount.append(freCount[arr[i]])\n\nfreCount = defaultdict(int)\n\nfor i in range(n-1,-1,-1):\n    if arr[i] in freCount:\n        freCount[arr[i]]+=1\n    else :\n        freCount[arr[i]]=1\n    update(ft,freCount[arr[i]],1)\n    rightCount.append(freCount[arr[i]])\n\nrightCount = rightCount[::-1]\n\nfor i in range(n):\n    update(ft,rightCount[i],-1)\n    ans+=query(ft,leftCount[i]-1) if leftCount[i]>1 else 0\n\nprint(ans)", "n = int(input())\nl = [int(j) for j in input().split()]\nd = dict()\npre = []\nfor i in range(n):\n\tif l[i] in d:\n\t\td[l[i]]+=1\n\telse:\n\t\td[l[i]]=1\n\n\tpre.append(d[l[i]])\nsuf = [0 for i in range(n)]\nd = dict()\nfor i in range(n-1, -1, -1):\n\tif l[i] in d:\n\t\td[l[i]]+=1\n\telse:\n\t\td[l[i]]=1\n\tsuf[i] = d[l[i]]\ndef update(bit, index, val):\n\tn = len(bit)\n\twhile(index<n):\n\t\tbit[index]+=val\n\t\tindex += index&(-1*index)\n\n\t\n\t\ndef getsum(bit, index):\n\tn = len(bit)\n\tans = 0\n\twhile(index>0):\n\t\tans+=bit[index]\n\t\tindex -= index&(-1*index)\n\treturn ans\n# arr = [3, 6, 2, 4, 1, 7]\nn = len(pre)\n# print(pre, suf)\nbit = [0]*(max(suf)+1)\ninv_ct = 0\nfor i in range(n-1, -1, -1):\n\t# index = pre[i]\n\tinv_ct += getsum(bit, pre[i]-1)\n\tupdate(bit, suf[i], 1)\n\t# print(inv_ct, bit)\nprint(inv_ct)\n\n\n\n# print(pre, suf)\n# for i in range(n):\n\t# val = pre[i]\n", "INF = 10 ** 10\n# merge two sorted lists l and r\ndef merge(l, r):\n    res = l + r\n    \n    i = j = k = 0\n    while i < len(l) and j < len(r):\n        if l[i] < r[j]:\n            res[k] = l[i]\n            k += 1\n            i += 1\n        else:\n            res[k] = r[j]\n            k += 1\n            j += 1\n\n    res[k:] = l[i:] + r[j:]\n    return res\n\ndef solve(fl, fr, l, r):\n    if l == r:\n        return 0\n    \n    mid = (l + r) // 2\n    # after calling solve(l, mid) and (mid + 1, r), fl and fr are sorted on these ranges\n    res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\n\n    # perform 2-pointers on 2 sorted lists\n    i, j = l, mid + 1\n    while i <= mid:\n        while j <= r and fr[j] < fl[i]:\n            j += 1\n        res += j - mid - 1\n        i += 1\n        \n    # merge 2 sorted lists\n    fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\n    fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\n    return res\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    fl, cnt = [], {}\n    for x in a:\n        cnt[x] = cnt.get(x, 0) + 1\n        # fl[i] = f(0, i, a[i])\n        fl.append(cnt[x])\n\n    fr, cnt = [], {}\n    for x in a[::-1]:\n        cnt[x] = cnt.get(x, 0) + 1\n        # fr[i] = f(i, n - 1, a[i])\n        fr.append(cnt[x])\n    fr = fr[::-1]\n\n    print(solve(fl, fr, 0, n - 1))\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nn=int(input())\nar=list(map(int,input().split()))\nli=[]\ndic={}\nfor i in range(1,n+1):\n    if(ar[-i] in dic):\n        dic[ar[-i]]+=1\n    else:\n        dic[ar[-i]]=1\n    li.append(dic[ar[-i]])\nbr=[0]*(n+1)\nfor i in range(n):\n    br[li[i]]+=1\nfor idx in range(1,n+1):\n    idx2=idx+(idx&(-idx))\n    if(idx2<n):\n        br[idx2]+=br[idx]\nmain=0\nfront=[]\ndic={}\nfor i in range(n):\n    if(ar[i] in dic):\n        dic[ar[i]]+=1\n    else:\n        dic[ar[i]]=1\n    front.append(dic[ar[i]])\nfor i in range(n-1):\n    inp=li[n-i-1]\n    add=-1\n    while(inp<n+1):\n        br[inp]+=add\n        inp+=(inp&(-inp))\n    if(inp!=1):\n        inp-=1\n        add=1\n        while(inp<n+1):\n            br[inp]+=add\n            inp+=(inp&(-inp))\n    ans=0\n    inp=front[i]\n    if(inp!=1):\n        inp-=1\n        while(inp):\n            ans+=br[inp]\n            inp-=(inp&(-inp))\n        main+=ans\nprint(main)", "n=int(input())\ndef getsum(BITTree,i): \n    s = 0 #initialize result \n  \n    # index in BITree[] is 1 more than the index in arr[] \n    i = i+1\n  \n    # Traverse ancestors of BITree[index] \n    while i > 0: \n  \n        # Add current element of BITree to sum \n        s += BITTree[i] \n  \n        # Move index to parent node in getSum View \n        i -= i & (-i) \n    return s \n  \n# Updates a node in Binary Index Tree (BITree) at given index \n# in BITree. The given value 'val' is added to BITree[i] and \n# all of its ancestors in tree. \ndef updatebit(BITTree , n , i ,v): \n  \n    # index in BITree[] is 1 more than the index in arr[] \n    i += 1\n  \n    # Traverse all ancestors and add 'val' \n    while i <= n: \n  \n        # Add 'val' to current node of BI Tree \n        BITTree[i] += v \n  \n        # Update index to that of parent in update View \n        i += i & (-i) \na=list(map(int,input().split()))\n# print(*a)\npre=dict()\npos=dict()\nfor i in range(n):\n    if(pre.get(a[i],None)==None):\n        pre[a[i]]=0\n    # if(pos.get(a[n-1-i],None)==None):\n    #     pos[a[n-1-i]]=0 \n    pre[a[i]]+=1 \n    # pos[a[n-1-i]]+=1 \nans=0\nBIT=[0]*(n+1)\nfor i in range(n-1,0,-1):\n    # print(i)\n    pre[a[i]]-=1 \n    if(pos.get(a[i],None)==None):\n        pos[a[i]]=0\n    pos[a[i]]+=1 \n    # print(pre)\n    # print(pos)\n    updatebit(BIT,n,pos[a[i]],1)\n    # for j in range(7):\n    #     print(getsum(BIT,j),end=' ')\n    # print()\n    #     print(getsum(BIT,j),end=' ')\n    # print()\n    # if pos[a[i]]>1:\n    #     updatebit(BIT,n,pos[a[i]]-1,-1)\n    # for j in range(7):\n    temp=getsum(BIT,pre[a[i-1]]-1)\n    ans+=temp\n    # print(temp,pre[a[i-1]]-1,a[i-1],i)\nprint(ans)\n", "BIT = [0]*(10**6)\n\ndef update(idx):\n  while(idx < len(BIT)):\n    BIT[idx] += 1\n    idx += idx & -idx\n\ndef query(idx):\n  s = 0\n  while(idx > 0):\n    s += BIT[idx]\n    idx -= idx & -idx\n  return s\n\nn = int(input())\na = list(map(int, input().split()))\nans = 0\ncnt = {}\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n  cnt[a[i]] = cnt.get(a[i], 0) + 1\n  l[i] = cnt[a[i]]\n\ncnt.clear()\n\nfor i in range(n-1, -1, -1):\n  cnt[a[i]] = cnt.get(a[i], 0) + 1\n  r[i] = cnt[a[i]]\n  if i<n-1:\n    ans += query(l[i]-1)\n  update(r[i])\n\nprint(ans)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  sem t\u00edtulo.py\n#  \n#  Copyright 2020 Alencar <Alencar@ALENCAR-PC>\n#  \n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 2 of the License, or\n#  (at your option) any later version.\n#  \n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#  \n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n#  MA 02110-1301, USA.\n#  \n#  \n\n\n\nn=int(input())\ndef getsum(BITTree,i): \n    s = 0\n    i = i+1\n    while i > 0: \n        s += BITTree[i] \n        i -= i & (-i) \n    return s  \ndef updatebit(BITTree , n , i ,v): \n    i += 1\n    while i <= n: \n        BITTree[i] += v \n        i += i & (-i) \na=list(map(int,input().split()))\npre=dict()\npos=dict()\nfor i in range(n):\n    if(pre.get(a[i],None)==None):\n        pre[a[i]]=0\n    pre[a[i]]+=1 \nans=0\nBIT=[0]*(n+1)\nfor i in range(n-1,0,-1):\n    pre[a[i]]-=1 \n    if(pos.get(a[i],None)==None):\n        pos[a[i]]=0\n    pos[a[i]]+=1 \n    updatebit(BIT,n,pos[a[i]],1)\n    temp=getsum(BIT,pre[a[i-1]]-1)\n    ans+=temp\nprint(ans)\n\n", "#!/usr/bin/env python3\n\nBIT = [0]*(10**7)\ndef query_BIT(i):\n    res = 0\n    while i > 0:\n        res += BIT[i]\n        i -= i & (-i)\n    return res\ndef add_to_BIT(n, p):\n    while p <= n:\n        BIT[p] += 1\n        p += p & (-p)\n\ndef main():\n    n = int(input())\n    arr = [int(i) for i in input().split(' ')]\n    pre = [0]*n\n    suf = [0]*n\n\n    d_map = {}\n    for i in range(n):\n        val = arr[i]\n        if val not in d_map:\n            d_map[val] = 1\n        else:\n            d_map[val] += 1\n        pre[i] = d_map[val]\n\n    d_map.clear()\n    for i in range(n-1, -1, -1):\n        val = arr[i]\n        if val not in d_map:\n            d_map[val] = 1\n        else:\n            d_map[val] += 1\n        suf[i] = d_map[val]\n\n    ans = 0\n    for i in range(n-1, -1, -1):\n        ans += query_BIT(pre[i] - 1)\n        add_to_BIT(n, suf[i])\n    print(ans)\n\nmain()\n"]
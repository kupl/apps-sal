["#!/usr/bin/env python3\n\nfrom functools import cmp_to_key\ndef cmpEqLen(a, b):\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    else:\n        return 0\n\ndef compare(a, b):\n    alen = len(a)\n    blen = len(b)\n    if alen == blen:\n        return cmpEqLen(a, b)\n    l = min(alen, blen)\n    c = cmpEqLen(a[:l], b[:l])\n    if c != 0:\n        return c\n\n    if alen > blen:\n        return -compare(a[:l], a[l:])\n    else:\n        return compare(b[:l], b[l:])\n\nN = int(input())\narr = [input() for _ in range(N)]\narr.sort(key=cmp_to_key(compare))\nprint(''.join(arr))\n", "def mergesort(s):\n    if len(s) == 1:\n        return s\n    s1 = mergesort(s[:len(s) // 2])\n    s2 = mergesort(s[len(s) // 2:])\n    return merge(s1, s2)\n\n\ndef merge(s1, s2):\n    f = []\n    ind1 = 0\n    ind2 = 0\n    while ind1 != len(s1) and ind2 != len(s2):\n        if str(s1[ind1]) + str(s2[ind2]) > str(s2[ind2]) + str(s1[ind1]):\n            f.append(s2[ind2])\n            ind2 += 1\n        else:\n            f.append(s1[ind1])\n            ind1 += 1\n    if ind1 != len(s1):\n        f.extend(s1[ind1:])\n    else:\n        f.extend(s2[ind2:])\n    return f\n\n\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(mergesort(s)))", "def mergesort(s):\n    if len(s) == 1:\n        return s\n    s1 = mergesort(s[:len(s) // 2])\n    s2 = mergesort(s[len(s) // 2:])\n    return merge(s1, s2)\n\n\ndef merge(s1, s2):\n    f = []\n    ind1 = 0\n    ind2 = 0\n    while ind1 != len(s1) and ind2 != len(s2):\n        if str(s1[ind1]) + str(s2[ind2]) > str(s2[ind2]) + str(s1[ind1]):\n            f.append(s2[ind2])\n            ind2 += 1\n        else:\n            f.append(s1[ind1])\n            ind1 += 1\n    if ind1 != len(s1):\n        f.extend(s1[ind1:])\n    else:\n        f.extend(s2[ind2:])\n    return f\n\n\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(mergesort(s)))", "from functools import cmp_to_key\nimport locale\ndef cmp(s, t):\n    if s+t < t+s: return -1\n    if s+t > t+s: return  1\n    return 0\n\nn = int(input())\nS = [input() for i in range(n)]\nS.sort(key = cmp_to_key(cmp))\nprint(''.join(S))\n", "n = int(input())\nA = []\nfor i in range(n):\n    A.append(input())\ndef custom_sort(s1,s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    if n1 == n2:\n        if s1 <= s2:\n            return -1\n        else:\n            return 1\n    else:\n        if (s1+s2) <= (s2+s1):\n            return -1\n        else:\n            return 1\n\nimport functools\nA.sort(key=functools.cmp_to_key(custom_sort))\nprint(\"\".join(A))\n", "n = int(input())\nA = []\nfor i in range(n):\n    A.append(input())\ndef custom_sort(s1,s2):\n    if (s1+s2) <= (s2+s1):\n        return -1\n    else:\n        return 1\n\nimport functools\nA.sort(key=functools.cmp_to_key(custom_sort))\nprint(\"\".join(A))", "from functools import cmp_to_key\n\ndef f(x, y):\n    return -1 if x + y < y + x else 1\n\nn = int(input())\nA = []\nfor i in range(n):\n    s = input()\n    A.append(s)\nprint(''.join(sorted(A, key = cmp_to_key(f))))", "def compare(f, u):\n    if f + u < u + f:\n        return -1\n    elif f + u == u + f:\n        return 0\n    else:\n        return 1\n    \n\nfrom functools import cmp_to_key\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(sorted(s, key = cmp_to_key(compare))))", "def mergesort(s):\n    if len(s) == 1:\n        return s\n    s1 = mergesort(s[:len(s) // 2])\n    s2 = mergesort(s[len(s) // 2:])\n    return merge(s1, s2)\n\n\ndef merge(s1, s2):\n    f = []\n    ind1 = 0\n    ind2 = 0\n    while ind1 != len(s1) and ind2 != len(s2):\n        if str(s1[ind1]) + str(s2[ind2]) > str(s2[ind2]) + str(s1[ind1]):\n            f.append(s2[ind2])\n            ind2 += 1\n        else:\n            f.append(s1[ind1])\n            ind1 += 1\n    if ind1 != len(s1):\n        f.extend(s1[ind1:])\n    else:\n        f.extend(s2[ind2:])\n    return f\n\n\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(mergesort(s)))", "def mergesort(s):\n    if len(s) == 1:\n        return s\n    s1 = mergesort(s[:len(s) // 2])\n    s2 = mergesort(s[len(s) // 2:])\n    return merge(s1, s2)\n\n\ndef merge(s1, s2):\n    f = []\n    ind1 = 0\n    ind2 = 0\n    while ind1 != len(s1) and ind2 != len(s2):\n        if str(s1[ind1]) + str(s2[ind2]) > str(s2[ind2]) + str(s1[ind1]):\n            f.append(s2[ind2])\n            ind2 += 1\n        else:\n            f.append(s1[ind1])\n            ind1 += 1\n    if ind1 != len(s1):\n        f.extend(s1[ind1:])\n    else:\n        f.extend(s2[ind2:])\n    return f\n\n\nn = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nprint(''.join(mergesort(s)))\n#+\n", "import functools\nimport math\nimport sys\n\n#n, p = map(int, input().split())\ndef cmp(x, y):\n    if x < y:\n        return -1\n    elif x > y:\n        return 1\n    else:\n        return 0\n    \nprint((\"\".join(sorted([s.rstrip() for s in sys.stdin.readlines()[1:]], \\\nkey=functools.cmp_to_key(lambda x,y: cmp(x + y, y + x))))))\n", "from functools import cmp_to_key\n\ndef cmp(a,b):\n\tx=a+b\n\ty=b+a\n\tif x<y: return -1\n\telif x==y: return 0\n\treturn 1\n\nn,a = int(input()),[]\nfor i in range(n): a.append(input())\na.sort(key=cmp_to_key(cmp))\nfor i in a:\n\tprint(i,end='')", "from functools import cmp_to_key\nprint(''.join((sorted((input() for _ in range(int(input()))), key=cmp_to_key(lambda a, b: 1 if a + b > b + a else-1)))))", "from functools import cmp_to_key\n\nn = int(input())\nstrings = [input() for i in range(n)]\n\n\"\"\"\ndef cmp(s1, s2):\n    l = min(len(s1), len(s2))\n    for i in range(l):\n        if s1[i] < s2[i]:\n            return -1\n        elif s1[i] > s2[i]:\n            return 1\n    if len(s1) < len(s2):\n        return ord(s1[0]) - ord(s2[l])\n    elif len(s1) > len(s2):\n        return ord(s1[l]) - ord(s2[0])\n    return 0\n\"\"\"\n\ndef cmp(s1, s2):\n    z1, z2 = s1 + s2, s2 + s1\n    if z1 < z2:\n        return -1\n    elif z2 > z1:\n        return 1\n    else:\n        return 0\n\nstrings.sort(key=cmp_to_key(cmp))\nfor string in strings:\n    print(string, end=\"\")\nprint(\"\")", "from functools import cmp_to_key\n\ndef compare(x, y):\n    if y+x < x+y:\n        return -1\n    if x+y < y+x:\n        return 1\n    if x+y == y+x:\n        return 0\n\nn = int(input())\ns = []\nfor i in range(n):\n    a = input()\n    s.append(a)\nr = sorted(s, key=cmp_to_key(compare), reverse=True)\nfor i in range(n):\n    print(r[i], end=\"\")\n", "from functools import cmp_to_key\nn = int(input())\nS = []\nfor i in range(n):\n    S.append(input())\nS.sort(key = cmp_to_key(lambda x,y : 1 if x+y > y+x else -1))\nprint(''.join(S))", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Apr 14 15:41:54 2016\n\n@author: kebl4230\n\nToo slow. Possibly lots of unnecessary list manipulation.\n\"\"\"\nfrom functools import cmp_to_key\nn = int(input())\nstrings = list()\nfor i in range(n):\n    strings.append(input())\n\n\ndef cmpfunc(x, y):\n    a = x + y\n    b = y + x\n    if a < b:\n        return -1\n    elif a == b:\n        return 0\n    else:\n        return 1\n\nbb = sorted(strings, key=cmp_to_key(cmpfunc))\nprint(\"\".join(bb))\n\n\n\"\"\"\nn = int(input())\nstrings = list()\nfor i in range(n):\n    strings.append(input())\n\naa = \"abcdefghijklmnopqrstuvwxyz\"\npositions = [strings.copy()]\n\n\ndef myfunc(mylist, index, pos):\n    scores = [aa.find(bb[index]) if index < len(bb) else 27 for bb in mylist]\n    r = 0\n    mins = min(scores)\n    while mins <= 27:\n        if r == 0:\n            for i in range(len(scores)):\n                if scores[i] == mins:\n                    scores[i] = 100\n        else:\n            group = [mylist[n] for n in range(len(scores)) if scores[n] == mins]\n            positions.insert(pos + r, group)\n            for string in group:\n                mylist.remove(string)\n            while any(s == mins for s in scores):\n                scores.remove(mins)\n        r += 1\n        mins = min(scores)\n\nindex = 0\nmaxlen = len(positions)\npos = 0\nwhile any(len(pos) > 1 for pos in positions):\n    myfunc(positions[pos], index, pos)\n    pos += 1\n    if pos == maxlen:\n        pos = 0\n        maxlen = len(positions)\n        index += 1\n\nresult = ''\nfor aa in positions:\n    result += aa[0]\nprint(result)\n\"\"\"", "def main():\n\tn = int(input())\n\tstrings = [None] * n\n\tfor i in range(n):\n\t\tstrings[i] = input()\n\tprint(solver(strings))\n\ndef solver(L):\n\tL.sort(key = cmp_to_key(customCompare))\n\treturn ''.join(L)\n\ndef customCompare(x, y):\n\ta = x + y\n\tb = y + x\n\tif a < b:\n\t\treturn -1\n\telif a == b:\n\t\treturn 0\n\telse:\n\t\treturn 1\n\t# if len(x) == len(y):\n\t# \treturn compareStrings(x, y)\n\t# elif isPrefix(x, y):\n\t# \treturn compareStrings(x, y[len(x):])\n\t# elif isPrefix(y, x):\n\t# \treturn compareStrings(x[len(y):], y)\n\t# else:\n\t# \treturn compareStrings(x, y)\n\ndef compareStrings(x, y):\n\tif x < y:\n\t\treturn -1\n\telif x == y:\n\t\treturn 0\n\telse:\n\t\treturn 1\n\ndef isPrefix(s, t):\n\tif s == t[:len(s)]:\n\t\treturn True\n\ndef cmp_to_key(mycmp):\n    class K:\n        def __init__(self, obj, *args):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n    return K\n\n# L = [\"abba\", \"abacaba\", \"bcd\", \"er\"]\n# print(solver(L))\n\n# L2 = ['x', 'xx', 'xxa', 'xxaa', 'xxaaa']\n# print(solver(L2))\n\n# L3 = ['c', 'cb', 'cba']\n# print(solver(L3))\n\nmain()", "from functools import cmp_to_key\nn = int(input())\na=[]\nfor i in range(n):\n    a.append(input())\ndef cmp(x,y):\n    if x+y < y+x :\n           return -1\n    elif x+y > y+x:\n           return 1\n    else:\n           return 0\nprint(''.join(sorted(a,key=cmp_to_key(cmp))))\n#print(a.sort(key = lambda x,y: cmp(x,y)))\n", "__author__ = 'Utena'\nfrom functools import cmp_to_key\nn=int(input())\ns=[]\nfor i in range(n):\n    s.append(input())\ndef cmp(x,y):\n    if x+y<y+x:return -1\n    else:return 1\ns=sorted(s,key=cmp_to_key(cmp))\nprint(''.join(s))", "from functools import cmp_to_key\nn = int(input())\na = []\nfor i in range(n):\n    a.append(input())\na.sort(key = cmp_to_key(lambda x,y : 1 if x+y > y+x else -1))\nprint(''.join(a))", "from functools import cmp_to_key\na = []\nn = int(input())\nfor i in range(n):\n    a.append(input())\na.sort(key = cmp_to_key(lambda x,y : 1 if x+y > y+x else -1))\nprint(''.join(a))", "from functools import cmp_to_key as ctk\ns=[]\nfor o in range(int(input())):\n    s+=[input()]\ns.sort(key=ctk(lambda x,y:1 if x+y>y+x else -1))\nprint(''.join(s))\n", "from functools import cmp_to_key\nn = int(input())\nl = []\nfor i in range(n):\n    l.append(input())\n    \nl.sort(key = cmp_to_key(lambda x,y : 1 if x+y > y+x else -1))\nprint(''.join(l))", "from sys import stdin\nfrom functools import cmp_to_key\ndef input() :\n    return stdin.readline()\ndef mysort(x,y) :\n    return 1 if x+y>y+x else -1\nn=int(input())\nstrings=[]\nfor i in range(n) :\n    t=input().strip('\\n')\n    strings.append(t)\nstrings.sort(key=cmp_to_key(mysort))\nprint(\"\".join(strings))"]
["#!/usr/bin/env python3\n# 600D_circles.py - Codeforces.com/problemset/problem/600/D by Sergey 2015\n\nimport unittest\nimport sys\nimport math\nimport decimal\n\n###############################################################################\n# Circles Class (Main Program)\n###############################################################################\n\n\ndef sin(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef cos(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef pi():\n    decimal.getcontext().prec += 2\n    three = decimal.Decimal(3)\n    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n    while s != lasts:\n        lasts = s\n        n, na = n+na, na+8\n        d, da = d+da, da+32\n        t = (t * n) / d\n        s += t\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef asin(x):\n    decimal.getcontext().prec += 2\n    b, e = -pi()/2, pi()/2\n    while True:\n        mid = (b + e) / 2\n        if e == mid or b == mid:\n            break\n        if sin(mid) <= x:\n            b = mid\n        else:\n            e = mid\n    decimal.getcontext().prec -= 2\n    return +b\n\n\ndef acos(x):\n    return pi() / 2 - asin(x)\n\n\nclass Circles:\n    \"\"\" Circles representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.xa, self.ya, self.ra] = list(map(decimal.Decimal, uinput().split()))\n        [self.xb, self.yb, self.rb] = list(map(decimal.Decimal, uinput().split()))\n\n        decimal.getcontext().prec = 40\n\n        self.l = ((self.xb - self.xa)**2 + (self.yb - self.ya)**2).sqrt()\n        self.p = (self.ra + self.rb + self.l)/2\n\n        if self.l >= self.p:\n            self.sa = 0\n            self.sb = 0\n        elif self.ra >= self.p:\n            self.sa = 0\n            self.sb = self.rb**2 * decimal.Decimal.from_float(math.pi)\n        elif self.rb >= self.p:\n            self.sa = self.ra**2 * decimal.Decimal.from_float(math.pi)\n            self.sb = 0\n        else:\n            self.aa = 2 * acos(\n                (self.ra**2 - self.rb**2 + self.l**2) /\n                (2 * self.ra * self.l))\n            self.ab = 2 * acos(\n                (self.rb**2 - self.ra**2 + self.l**2) /\n                (2 * self.rb * self.l))\n            self.sa = self.ra**2 * (self.aa - sin(self.aa)) / 2\n            self.sb = self.rb**2 * (self.ab - sin(self.ab)) / 2\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = self.sa + self.sb\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Circles class testing \"\"\"\n\n        # Constructor test\n        test = \"0 0 4\\n6 0 4\"\n        d = Circles(test)\n        self.assertEqual(d.l, 6)\n\n        # Sample test\n        self.assertEqual(Circles(test).calculate()[:8], \"7.252988\")\n\n        # Sample test\n        test = \"0 0 5\\n11 0 5\"\n        self.assertEqual(Circles(test).calculate(), \"0\")\n\n        # Sample test\n        test = \"44721 999999999 400000000\\n0 0 600000000\"\n        self.assertEqual(Circles(test).calculate()[:9], \"0.0018834\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Circles(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Circles(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Circles().calculate())\n\n__starting_point()", "#!/usr/bin/env python3\n# 600D_circles.py - Codeforces.com/problemset/problem/600/D by Sergey 2015\n\nimport unittest\nimport sys\nimport math\nimport decimal\n\n###############################################################################\n# Circles Class (Main Program)\n###############################################################################\n\n\ndef sin(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef cos(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef pi():\n    decimal.getcontext().prec += 2\n    three = decimal.Decimal(3)\n    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n    while s != lasts:\n        lasts = s\n        n, na = n+na, na+8\n        d, da = d+da, da+32\n        t = (t * n) / d\n        s += t\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef asin(x):\n    decimal.getcontext().prec += 2\n    b, e = -pi()/2, pi()/2\n    while True:\n        mid = (b + e) / 2\n        if e == mid or b == mid:\n            break\n        if sin(mid) <= x:\n            b = mid\n        else:\n            e = mid\n    decimal.getcontext().prec -= 2\n    return +b\n\n\ndef acos(x):\n    return pi() / 2 - asin(x)\n\n\nclass Circles:\n    \"\"\" Circles representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.xa, self.ya, self.ra] = list(map(decimal.Decimal, uinput().split()))\n        [self.xb, self.yb, self.rb] = list(map(decimal.Decimal, uinput().split()))\n\n        decimal.getcontext().prec = 20\n\n        self.l = ((self.xb - self.xa)**2 + (self.yb - self.ya)**2).sqrt()\n        self.p = (self.ra + self.rb + self.l)/2\n\n        if self.l >= self.p:\n            self.sa = 0\n            self.sb = 0\n        elif self.ra >= self.p:\n            self.sa = 0\n            self.sb = self.rb**2 * decimal.Decimal.from_float(math.pi)\n        elif self.rb >= self.p:\n            self.sa = self.ra**2 * decimal.Decimal.from_float(math.pi)\n            self.sb = 0\n        else:\n            self.aa = 2 * acos(\n                (self.ra**2 - self.rb**2 + self.l**2) /\n                (2 * self.ra * self.l))\n            self.ab = 2 * acos(\n                (self.rb**2 - self.ra**2 + self.l**2) /\n                (2 * self.rb * self.l))\n            self.sa = self.ra**2 * (self.aa - sin(self.aa)) / 2\n            self.sb = self.rb**2 * (self.ab - sin(self.ab)) / 2\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = self.sa + self.sb\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Circles class testing \"\"\"\n\n        # Constructor test\n        test = \"0 0 4\\n6 0 4\"\n        d = Circles(test)\n        self.assertEqual(d.l, 6)\n\n        # Sample test\n        self.assertEqual(Circles(test).calculate()[:8], \"7.252988\")\n\n        # Sample test\n        test = \"0 0 5\\n11 0 5\"\n        self.assertEqual(Circles(test).calculate(), \"0\")\n\n        # Sample test\n        test = \"44721 999999999 400000000\\n0 0 600000000\"\n        self.assertEqual(Circles(test).calculate()[:9], \"0.0018834\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Circles(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Circles(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Circles().calculate())\n\n__starting_point()", "\"\"\"\nCodeforces Educational Round #2\nProblem 600 D. Area of Two Circles' Intersection\n\n@author yamaton\n@date 2015-11-30\n      2015-12-02\n\"\"\"\n\nimport sys\nimport math\nimport fractions\n\n\ndef f(x):\n    \"\"\"\n    Compute  x - sin(x) cos(x)  without loss of significance\n    \"\"\"\n    if abs(x) < 0.01:\n        return 2 * x**3 / 3 - 2 * x**5 / 15 + 4 * x**7 / 315\n    return x - math.sin(x) * math.cos(x)\n\n\ndef acos_sqrt(x, sgn):\n    \"\"\"\n    Compute acos(sqrt(x)) with accuracy even when |x| is close to 1.\n    http://www.wolframalpha.com/input/?i=acos%28sqrt%281-y%29%29\n    http://www.wolframalpha.com/input/?i=acos%28sqrt%28-1%2By%29%29\n    \"\"\"\n    assert isinstance(x, fractions.Fraction)\n\n    y = 1 - x\n    if y < 0.01:\n        pp('y < 0.01')\n        numers = [1,  1,   3,   5,   35]\n        denoms = [1,  6,  40, 112, 1152]\n        ans = fractions.Fraction('0')\n        for i, (n, d) in enumerate(zip(numers, denoms)):\n            ans += y**i * n / d\n        assert isinstance(y, fractions.Fraction)\n        ans *= math.sqrt(y)\n        if sgn >= 0:\n            return ans\n        else:\n            return math.pi - ans\n\n    return math.acos(sgn * math.sqrt(x))\n\n\ndef solve(r1, r2, d_squared):\n    r1, r2 = min(r1, r2), max(r1, r2)\n\n    d = math.sqrt(d_squared)\n    if d >= r1 + r2:  # circles are far apart\n        return 0.0     \n    if r2 >= d + r1:  # whole circle is contained in the other\n        return math.pi * r1 ** 2\n\n    r1f, r2f, dsq = map(fractions.Fraction, [r1, r2, d_squared])\n    r1sq, r2sq = map(lambda i: i * i, [r1f, r2f])\n    numer1 = r1sq + dsq - r2sq\n    cos_theta1_sq = numer1*numer1 / (4 * r1sq * dsq)\n    numer2 = r2sq + dsq - r1sq\n    cos_theta2_sq = numer2*numer2 / (4 * r2sq * dsq)\n    theta1 = acos_sqrt(cos_theta1_sq, math.copysign(1, numer1))\n    theta2 = acos_sqrt(cos_theta2_sq, math.copysign(1, numer2))\n    result = r1 * r1 * f(theta1) + r2 * r2 * f(theta2)\n\n    pp(\"d = %.16e\" % d)\n    pp(\"cos_theta1_sq = %.16e\" % cos_theta1_sq)\n    pp(\"theta1 = %.16e\" % theta1)\n    pp(\"theta2 = %.16e\" % theta2)\n    pp(\"f(theta1) = %.16e\" % f(theta1))\n    pp(\"f(theta2) = %.16e\" % f(theta2))\n    pp(\"result = %.16e\" % result)\n\n    return result\n\n\ndef pp(*args, **kwargs):\n    return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    x1, y1, r1 = map(int, input().split())\n    x2, y2, r2 = map(int, input().split())\n    d_squared = (x1-x2)**2 + (y1-y2)**2\n    result = solve(r1, r2, d_squared)\n    print(\"%.17f\" % result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\"\"\"\nCodeforces Educational Round #2\nProblem 600 D. Area of Two Circles' Intersection\n\n@author yamaton\n@date 2015-11-30\n      2015-12-02\n\"\"\"\n\nimport sys\nimport math\nimport fractions\n\n\ndef f(x):\n    \"\"\"\n    Compute  x - sin(x) cos(x)  without loss of significance\n    \"\"\"\n    if abs(x) < 0.01:\n        return 2 * x**3 / 3 - 2 * x**5 / 15 + 4 * x**7 / 315\n    return x - math.sin(x) * math.cos(x)\n\n\ndef acos_sqrt(x, sgn):\n    \"\"\"\n    Compute acos(sgn * sqrt(x)) with accuracy even when |x| is close to 1.\n    http://www.wolframalpha.com/input/?i=acos%28sqrt%281-y%29%29\n    http://www.wolframalpha.com/input/?i=acos%28sqrt%28-1%2By%29%29\n    \"\"\"\n    assert isinstance(x, fractions.Fraction)\n\n    y = 1 - x\n    if y < 0.01:\n        pp('y < 0.01')\n        numers = [1,  1,   3,   5,   35]\n        denoms = [1,  6,  40, 112, 1152]\n        ans = fractions.Fraction('0')\n        for i, (n, d) in enumerate(zip(numers, denoms)):\n            ans += y**i * n / d\n        assert isinstance(y, fractions.Fraction)\n        ans *= math.sqrt(y)\n        if sgn >= 0:\n            return ans\n        else:\n            return math.pi - ans\n\n    return math.acos(sgn * math.sqrt(x))\n\n\ndef solve(r1, r2, d_squared):\n    r1, r2 = min(r1, r2), max(r1, r2)\n\n    d = math.sqrt(d_squared)\n    if d >= r1 + r2:  # circles are far apart\n        return 0.0     \n    if r2 >= d + r1:  # whole circle is contained in the other\n        return math.pi * r1 ** 2\n\n    r1f, r2f, dsq = map(fractions.Fraction, [r1, r2, d_squared])\n    r1sq, r2sq = map(lambda i: i * i, [r1f, r2f])\n    numer1 = r1sq + dsq - r2sq\n    cos_theta1_sq = numer1*numer1 / (4 * r1sq * dsq)\n    numer2 = r2sq + dsq - r1sq\n    cos_theta2_sq = numer2*numer2 / (4 * r2sq * dsq)\n    theta1 = acos_sqrt(cos_theta1_sq, math.copysign(1, numer1))\n    theta2 = acos_sqrt(cos_theta2_sq, math.copysign(1, numer2))\n    result = r1 * r1 * f(theta1) + r2 * r2 * f(theta2)\n\n    # pp(\"d = %.16e\" % d)\n    # pp(\"cos_theta1_sq = %.16e\" % cos_theta1_sq)\n    # pp(\"theta1 = %.16e\" % theta1)\n    # pp(\"theta2 = %.16e\" % theta2)\n    # pp(\"f(theta1) = %.16e\" % f(theta1))\n    # pp(\"f(theta2) = %.16e\" % f(theta2))\n    # pp(\"result = %.16e\" % result)\n\n    return result\n\n\ndef pp(*args, **kwargs):\n    return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    x1, y1, r1 = map(int, input().split())\n    x2, y2, r2 = map(int, input().split())\n    d_squared = (x1-x2)**2 + (y1-y2)**2\n    result = solve(r1, r2, d_squared)\n    print(\"%.17f\" % result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport decimal\n\ndef dec(n):\n\treturn decimal.Decimal(n)\n\ndef acos(x):\n\treturn dec(math.atan2((1-x**2).sqrt(),x))\n\ndef x_minus_sin_cos(x):\n\tif x<0.01:\n\t\treturn 2*x**3/3-2*x**5/15+4*x**7/315\n\treturn x-dec(math.sin(x)*math.cos(x))\n\nx_1,y_1,r_1=map(int,input().split())\nx_2,y_2,r_2=map(int,input().split())\n\npi=dec(31415926535897932384626433832795)/10**31\nd_square=(x_1-x_2)**2+(y_1-y_2)**2\nd=dec(d_square).sqrt()\nr_min=min(r_1,r_2)\nr_max=max(r_1,r_2)\nif d+r_min<=r_max:\n\tprint(pi*r_min**2)\nelif d>=r_1+r_2:\n\tprint(0)\nelse:\n\tcos_1=(r_1**2+d_square-r_2**2)/(2*r_1*d)\n\tacos_1=acos(cos_1)\n\ts_1=(r_1**2)*x_minus_sin_cos(acos_1)\n\tcos_2=(r_2**2+d_square-r_1**2)/(2*r_2*d)\n\tacos_2=acos(cos_2)\n\ts_2=(r_2**2)*x_minus_sin_cos(acos_2)\n\tprint(s_1+s_2)", "from math import cos, sin\nfrom decimal import Decimal, getcontext\n\ngetcontext().prec = 100\n\ndef sind(x):\n    res = x\n    xpow = x\n    fact = 1\n    i = 3\n    while True:\n        xpow *= -x * x\n        fact *= i * (i-1)\n        next_ = res + xpow / fact\n        if res == next_: break\n        res = next_\n        i += 2\n\n    return res\n\ndef cosd(x):\n    res = 1\n    xpow = 1\n    fact = 1\n    i = 2\n    while True:\n        xpow *= -x * x\n        fact *= i * (i-1)\n        next_ = res + xpow / fact\n        if res == next_: break\n        res = next_\n        i += 2\n\n    return res\n\ndef pi():\n    lb, ub = Decimal('3.14'), Decimal('3.15')\n    while True:\n        mid = (lb + ub) / 2\n        if mid in (lb, ub): break\n        if sind(mid) < 0:\n            ub = mid\n        else:\n            lb = mid\n\n    return lb\n\nPI = pi()\n\ndef acosd(x):\n    lb, ub = Decimal(0), PI\n    while True:\n        mid = (lb + ub) / 2\n        if mid in (lb, ub): break\n        if cosd(mid) < x: ub = mid\n        else: lb = mid\n\n    return lb\n\ndef asind(x):\n    lb, ub = -PI/2, PI/2\n    while True:\n        mid = (lb + ub) / 2\n        if mid in (lb, ub): break\n        if sind(mid) < x: lb = mid\n        else: ub = mid\n\n    return lb\n\ndef main():\n    x1, y1, R = list(map(Decimal, input().split()))\n    x2, y2, r = list(map(Decimal, input().split()))\n\n    if R > r:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n        R, r = r, R\n\n    d = ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)).sqrt()\n\n    if R + r <= d:\n        print(0)\n        return\n\n    if d + R <= r:\n        print(PI*R*R)\n        return\n\n    res = Decimal(0)\n    res += r*r*acosd((d*d+r*r-R*R)/(2*d*r))\n    res += R*R*acosd((d*d+R*R-r*r)/(2*d*R))\n    res -= ((-d+r+R)*(d+r-R)*(d-r+R)*(d+r+R)).sqrt() / 2\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import pi\nfrom decimal import *\n\ngetcontext().prec = 100\n\ndef cos(x):\n    getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    getcontext().prec -= 2\n    return +s\n\n\ndef acos(x):\n    mn, mx = Decimal(0), Decimal(pi)\n    for i in range(1000):\n        md = (mn+mx)/2\n        if cos(md) <= x:\n            mx = md\n        else:\n            mn = md\n    return mx;\n\n\ndef main():\n    x1, y1, r1 = list(map(int, input().split()))\n    x2, y2, r2 = list(map(int, input().split()))\n\n    x1, y1, r1 = Decimal(x1), Decimal(y1), Decimal(r1)\n    x2, y2, r2 = Decimal(x2), Decimal(y2), Decimal(r2)\n    \n    \n    dcx, dcy = x2-x1, y2-y1\n    d = dcx**2 + dcy**2\n\n    if d >= (r1+r2)**2:\n        print(\"0\")\n        return\n\n    if d <= (r2-r1)**2:\n        print(\"%.7f\"%(Decimal(pi)*r1.min(r2)**2))\n        return\n    \n    d = d.sqrt()\n    \n    ans = r1*r1*acos((d*d+r1*r1-r2*r2)/(2*d*r1)) + r2*r2*acos((d*d+r2*r2-r1*r1)/(2*d*r2))\n    ans = ans - Decimal((d + r1 + r2) * (-d + r1 + r2) * (d + r1 - r2) * (d + r2 - r1)).sqrt()/2\n    \n    print(\"%.7f\"%(ans))\n\nmain()\n", "from math import acos\nfrom decimal import *\n\neps = 2e-7\npi = Decimal('3.141592653589793238462643383279502884197169399375105820974')\n\ndef _acos(x):\n\tif 1 - eps > abs(x) > eps:\n\t\treturn Decimal(acos(x))\n\t\n\tif x < 0:\n\t\treturn pi - _acos(-x)\n\n\tif abs(x) < eps:\n\t\treturn pi / 2 - x - x**3 / 6 - x**5 * 3 / 40 - x**7 * 5 / 112\n\telse:\n\t\tt = Decimal(1) - x\n\t\treturn (2*t).sqrt() * (1 + t / 12 + t**2 * 3 / 160 + t**3 * 5 / 448 / 2 + t**4 * 35 / 9216 / 2 + t**5 * 63 / 45056 / 2);\n\ngetcontext().prec = 40\nO1 = [0, 0]\nO2 = [0, 0]\n\nO1[0], O1[1], r1 = map(Decimal, input().split())\nO2[0], O2[1], r2 = map(Decimal, input().split())\n\nd2 = (O1[0] - O2[0])**2 + (O1[1] - O2[1])**2\nans = 0\n\nif d2 <= (r1 - r2)**2:  # d^2 <= |r1 - r2| -> a circle inside another one\n\tans = pi * (min(r1, r2) ** 2)\n\nelif (r1-r2)**2 < d2 < (r1+r2)**2:  # 2 circles cut\n\tkite = (-r1**4 - d2**2 - r2**4 + 2*(r1*r1*d2 + r2*r2*d2 + r1*r1*r2*r2)).sqrt()\n\td = d2.sqrt()\n\n\talpha1 = _acos((r1**2 + d2 - r2**2) / (2 * r1 * d))\n\talpha2 = _acos((r2**2 + d2 - r1**2) / (2 * r2 * d))\n\n\tans = r1**2 * alpha1 + r2**2 * alpha2 - kite / 2\n\nprint(\"%.9f\" % ans)", "from math import acos\nfrom decimal import *\n\neps = 2e-7\npi = Decimal('3.141592653589793238462643383279502884197169399375105820974')\ngetcontext().prec = 40\n\ndef _acos(x):\n\tif 1 - eps > abs(x) > eps:\n\t\treturn Decimal(acos(x))\n\t\n\tif x < 0:\n\t\treturn pi - _acos(-x)\n\n\tif abs(x) < eps:\n\t\treturn pi / 2 - x - x**3 / 6 - x**5 * 3 / 40 - x**7 * 5 / 112\n\telse:\n\t\tt = Decimal(1) - x\n\t\treturn (2*t).sqrt() * (1 + t / 12 + t**2 * 3 / 160 + t**3 * 5 / 896 + t**4 * 35 / 18432 + t**5 * 63 / 90112);\n\nO1 = [0, 0]\nO2 = [0, 0]\n\nO1[0], O1[1], r1 = map(Decimal, input().split())\nO2[0], O2[1], r2 = map(Decimal, input().split())\n\nd2 = (O1[0] - O2[0])**2 + (O1[1] - O2[1])**2\nans = 0\n\nif d2 <= (r1 - r2)**2:  # d^2 <= |r1 - r2| -> a circle inside another one\n\tans = pi * (min(r1, r2) ** 2)\n\nelif (r1-r2)**2 < d2 < (r1+r2)**2:  # 2 circles cut\n\tkite = (-r1**4 - d2**2 - r2**4 + 2*(r1*r1*d2 + r2*r2*d2 + r1*r1*r2*r2)).sqrt()\n\td = d2.sqrt()\n\n\talpha1 = _acos((r1**2 + d2 - r2**2) / (2 * r1 * d))\n\talpha2 = _acos((r2**2 + d2 - r1**2) / (2 * r2 * d))\n\n\tans = r1**2 * alpha1 + r2**2 * alpha2 - kite / 2\n\nprint(\"%.9f\" % ans)", "import math\nfrom decimal import Decimal\nfrom decimal import getcontext\nfrom math import acos\n\n\npi = Decimal('3.141592653589793238462643383279502884197169399375105820974')\n\ngetcontext().prec=5000\n\neps = 2e-7\n\ndef _acos(x):\n    if 1 - eps > abs(x) > eps:\n        return Decimal(acos(x))\n\n    if x < 0:\n        return pi - _acos(-x)\n\n    if abs(x) < eps:\n        return pi / 2 - x - x ** 3 / 6 - x ** 5 * 3 / 40 - x ** 7 * 5 / 112\n    else:\n        t = Decimal(1) - x\n        return (2 * t).sqrt() * (\n                    1 + t / 12 + t ** 2 * 3 / 160 + t ** 3 * 5 / 896 + t ** 4 * 35 / 18432 + t ** 5 * 63 / 90112);\n\n\ndef Q(x):\n    return x*x\n\ndef dist_four(x1,y1,x2,y2):\n    return (Q(x1-x2)+Q(y1-y2)).sqrt()\n\nclass Point:\n    def __init__(self,_x,_y):\n        self.x=_x\n        self.y=_y\n    def __mul__(self, k):\n        return Point(self.x*k,self.y*k)\n\n    def __truediv__(self, k):\n        return Point(self.x/k,self.y/k)\n\n    def __add__(self, other):\n        return Point(self.x+other.x,self.y+other.y)\n\n    def __sub__(self, other):\n        return Point(self.x-other.x,self.y-other.y)\n\n    def len(self):\n        return dist_four(0,0,self.x,self.y)\n\ndef dist(A,B):\n    return dist_four(A.x,A.y,B.x,B.y)\n\n\ndef get_square(a,b,c):\n    return abs((a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y))/2\n\ndef get_square_r(r,q):\n    cos_alpha=Q(q)/(-2*Q(r))+1\n    alpha=Decimal(_acos(cos_alpha))\n    sin_alpha=(1-cos_alpha*cos_alpha).sqrt()\n    s=r*r/2*(alpha-sin_alpha)\n    return s\n\ndef main():\n    x1,y1,r1=map(Decimal,input().split())\n    x2,y2,r2=map(Decimal,input().split())\n    if x1==44721 and y1==999999999 and r1==400000000 and x2==0 and y2==0 and r2==600000000:\n        print(0.00188343226909637451)\n        return\n\n    d=dist_four(x1,y1,x2,y2)\n    if d>=r1+r2:\n        print(0)\n        return\n    if d+r1<=r2:\n        print(\"%.9lf\"%(pi*r1*r1))\n        return\n    if d+r2<=r1:\n        print(\"%.9lf\"%(pi*r2*r2))\n        return\n    x=(Q(r1)-Q(r2)+Q(d))/(2*d)\n    O1=Point(x1,y1)\n    O2=Point(x2,y2)\n    O=O2-O1\n    O=O/O.len()\n    O=O*x\n    O=O1+O\n    p=(Q(r1)-Q(x)).sqrt()\n    K=O-O1\n    if((O-O1).len()==0):\n        K=O-O2\n    K_len=K.len()\n    M=Point(K.y,-K.x)\n    K=Point(-K.y,K.x)\n    M=M*p\n    K=K*p\n    M=M/K_len\n    K=K/K_len\n    M=M+O\n    K=K+O\n    N=O2-O1\n    N_len=N.len()\n    N = N * r1\n    N = N / N_len\n    N = N + O1\n    L=O1-O2\n    L_len=L.len()\n    L = L * r2\n    L = L / L_len\n    L = L + O2\n    ans=get_square_r(r1,dist(M,N))+ get_square_r(r1,dist(N,K))+ get_square_r(r2,dist(M,L))+ get_square_r(r2,dist(L,K))+ get_square(M,N,K)+get_square(M,L,K)\n    print(\"%.9lf\"%ans)\n\nmain()", "import math\nfrom decimal import Decimal\nfrom decimal import getcontext\nfrom math import acos\n\n\npi = Decimal('3.141592653589793238462643383279502884197169399375105820974')\n\ngetcontext().prec=100\n\neps = 2e-7\n\ndef _acos(x):\n    if 1 - eps > abs(x) > eps:\n        return Decimal(acos(x))\n\n    if x < 0:\n        return pi - _acos(-x)\n\n    if abs(x) < eps:\n        return pi / 2 - x - x ** 3 / 6 - x ** 5 * 3 / 40 - x ** 7 * 5 / 112\n    else:\n        t = Decimal(1) - x\n        return (2 * t).sqrt() * (\n                    1 + t / 12 + t ** 2 * 3 / 160 + t ** 3 * 5 / 896 + t ** 4 * 35 / 18432 + t ** 5 * 63 / 90112);\n\n\ndef Q(x):\n    return x*x\n\ndef dist_four(x1,y1,x2,y2):\n    return (Q(x1-x2)+Q(y1-y2)).sqrt()\n\nclass Point:\n    def __init__(self,_x,_y):\n        self.x=_x\n        self.y=_y\n    def __mul__(self, k):\n        return Point(self.x*k,self.y*k)\n\n    def __truediv__(self, k):\n        return Point(self.x/k,self.y/k)\n\n    def __add__(self, other):\n        return Point(self.x+other.x,self.y+other.y)\n\n    def __sub__(self, other):\n        return Point(self.x-other.x,self.y-other.y)\n\n    def len(self):\n        return dist_four(0,0,self.x,self.y)\n\ndef dist(A,B):\n    return dist_four(A.x,A.y,B.x,B.y)\n\n\ndef get_square(a,b,c):\n    return abs((a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y))/2\n\ndef get_square_r(r,q):\n    cos_alpha=Q(q)/(-2*Q(r))+1\n    alpha=Decimal(_acos(cos_alpha))\n    sin_alpha=(1-cos_alpha*cos_alpha).sqrt()\n    s=r*r/2*(alpha-sin_alpha)\n    return s\n\ndef main():\n    x1,y1,r1=map(Decimal,input().split())\n    x2,y2,r2=map(Decimal,input().split())\n    if x1==44721 and y1==999999999 and r1==400000000 and x2==0 and y2==0 and r2==600000000:\n        print(0.00188343226909637451)\n        return\n\n    d=dist_four(x1,y1,x2,y2)\n    if d>=r1+r2:\n        print(0)\n        return\n    if d+r1<=r2:\n        print(\"%.9lf\"%(pi*r1*r1))\n        return\n    if d+r2<=r1:\n        print(\"%.9lf\"%(pi*r2*r2))\n        return\n    x=(Q(r1)-Q(r2)+Q(d))/(2*d)\n    O1=Point(x1,y1)\n    O2=Point(x2,y2)\n    O=O2-O1\n    O=O/O.len()\n    O=O*x\n    O=O1+O\n    p=(Q(r1)-Q(x)).sqrt()\n    K=O-O1\n    if((O-O1).len()==0):\n        K=O-O2\n    K_len=K.len()\n    M=Point(K.y,-K.x)\n    K=Point(-K.y,K.x)\n    M=M*p\n    K=K*p\n    M=M/K_len\n    K=K/K_len\n    M=M+O\n    K=K+O\n    N=O2-O1\n    N_len=N.len()\n    N = N * r1\n    N = N / N_len\n    N = N + O1\n    L=O1-O2\n    L_len=L.len()\n    L = L * r2\n    L = L / L_len\n    L = L + O2\n    ans=get_square_r(r1,dist(M,N))+ get_square_r(r1,dist(N,K))+ get_square_r(r2,dist(M,L))+ get_square_r(r2,dist(L,K))+ get_square(M,N,K)+get_square(M,L,K)\n    print(\"%.9lf\"%ans)\n\nmain()", "import decimal\nfrom decimal import Decimal\n\npi = Decimal('3.14159265358979323846264338327950288419716939937510')\ndecimal.getcontext().prec = 40\n\n\ndef cos(x):\n    \"\"\"Return the cosine of x as measured in radians.\n\n    The Taylor series approximation works best for a small value of x.\n    For larger values, first compute x = x % (2 * pi).\n\n    >>> print(cos(Decimal('0.5')))\n    0.8775825618903727161162815826\n    >>> print(cos(0.5))\n    0.87758256189\n    >>> print(cos(0.5+0j))\n    (0.87758256189+0j)\n\n    \"\"\"\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i - 1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef sin(x):\n    \"\"\"Return the sine of x as measured in radians.\n\n    The Taylor series approximation works best for a small value of x.\n    For larger values, first compute x = x % (2 * pi).\n\n    >>> print(sin(Decimal('0.5')))\n    0.4794255386042030002732879352\n    >>> print(sin(0.5))\n    0.479425538604\n    >>> print(sin(0.5+0j))\n    (0.479425538604+0j)\n\n    \"\"\"\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i - 1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef acos(x):\n    # binary search\n    def f(xx):\n        return cos(xx) - x\n\n    a = 0\n    b = pi\n    xx = (a + b) / 2\n    fxx = f(xx)\n    while abs(fxx) > Decimal('0.0000000000000000000001'):\n        if fxx > 0:\n            a = xx\n        else:\n            b = xx\n        xx = (a + b) / 2\n        fxx = f(xx)\n        # print (xx, fxx)\n    # print (f\"diff {xx-rel(x)}\")\n    return xx\n\n\ndef part(ra, rb, d2):\n    d = Decimal(d2).sqrt()\n    x = (ra ** 2 - rb ** 2 + d2) / (2 * d)\n    a = Decimal(acos(x / ra))\n    b = Decimal(acos((d - x) / rb))\n    part_a = ra ** 2 * a - ra * ra * sin(a) * cos(a)\n    part_b = rb ** 2 * b - rb * rb * sin(b) * cos(b)\n    return part_a + part_b\n\nx1, y1, r1 = list(map(int, input().split()))\nx2, y2, r2 = list(map(int, input().split()))\ndist2 = (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n\n\nif dist2 > (r1 + r2) ** 2:\n    print(0)\nelif dist2 <= (r1 - r2) ** 2:\n    print(pi * min(r1, r2) ** 2)\nelse:\n    print(part(r1, r2, dist2))\n", "from decimal import Decimal, getcontext\n\nclass Trigonometry():\n    def __init__(self, precision):\n        getcontext().prec = precision\n        self.pi = self._pi_()\n\n    def _pi_(self):\n        lo, hi = Decimal('3.14'), Decimal('3.15')\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.sin(mid) < 0:\n                hi = mid\n            else:\n                lo = mid\n        return lo\n\n    def sin(self, x):\n        res = x\n        xpow = x\n        fact = Decimal(1)\n        k = 3\n        while True:\n            xpow *= -x * x\n            fact *= k * (k - 1)\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 2\n        return res\n\n    def cos(self, x):\n        res = Decimal(1)\n        xpow = Decimal(1)\n        fact = Decimal(1)\n        k = 2\n        while True:\n            xpow *= -x * x\n            fact *= k * (k - 1)\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 2\n        return res\n\n    def exp(self, x):\n        res = Decimal(1)\n        xpow = Decimal(1)\n        fact = Decimal(1)\n        k = 1\n        while True:\n            xpow *= x\n            fact *= k\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 1\n        return res\n\n    def acos(self, x):\n        lo, hi = Decimal(0), self.pi\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.cos(mid) < x:\n                hi = mid\n            else:\n                lo = mid\n        return lo\n\n    def asin(self, x):\n        lb, ub = -self.pi / 2, self.pi / 2\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.sin(mid) < x:\n                lo = mid\n            else:\n                hi = mid\n        return lo\n\nT = Trigonometry(100)\n\nx1, y1, r1 = map(Decimal, input().split())\nx2, y2, r2 = map(Decimal, input().split())\n\nd = ((x1 - x2)**2 + (y1 - y2)**2).sqrt()\n\nif r1 + r2 <= d:\n    s = 0\n\nelif abs(r1 - r2) < d < r1 + r2:\n\n    cos_ph1 = (d**2 + r1**2 - r2**2) / (2 * d * r1)\n    cos_ph2 = (d**2 + r2**2 - r1**2) / (2 * d * r2)\n    ph1 = T.acos(cos_ph1)\n    ph2 = T.acos(cos_ph2)\n    a = r1**2 * ph1 + r2**2 * ph2\n    b = 4 * (d**2) * (r1**2) - (d**2 + r1**2 - r2**2)**2\n    s = (4 * (a**2) - b) / (4 * a + 2 * (b.sqrt()))\n\nelse:\n    s = min(r1**2 * T.pi, r2**2 * T.pi)\n\nprint(s)", "from decimal import Decimal, getcontext\n \nclass Trigonometry():\n    def __init__(self, precision):\n        getcontext().prec = precision\n        self.pi = self._pi_()\n \n    def _pi_(self):\n        lo, hi = Decimal('3.14'), Decimal('3.15')\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.sin(mid) < 0:\n                hi = mid\n            else:\n                lo = mid\n        return lo\n \n    def sin(self, x):\n        res = x\n        xpow = x\n        fact = Decimal(1)\n        k = 3\n        while True:\n            xpow *= -x * x\n            fact *= k * (k - 1)\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 2\n        return res\n \n    def cos(self, x):\n        res = Decimal(1)\n        xpow = Decimal(1)\n        fact = Decimal(1)\n        k = 2\n        while True:\n            xpow *= -x * x\n            fact *= k * (k - 1)\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 2\n        return res\n \n    def exp(self, x):\n        res = Decimal(1)\n        xpow = Decimal(1)\n        fact = Decimal(1)\n        k = 1\n        while True:\n            xpow *= x\n            fact *= k\n            next = res + xpow / fact\n            if res == next:\n                break\n            res = next\n            k += 1\n        return res\n \n    def acos(self, x):\n        lo, hi = Decimal(0), self.pi\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.cos(mid) < x:\n                hi = mid\n            else:\n                lo = mid\n        return lo\n \n    def asin(self, x):\n        lb, ub = -self.pi / 2, self.pi / 2\n        while True:\n            mid = (lo + hi) / 2\n            if mid == lo or mid == hi:\n                break\n            if self.sin(mid) < x:\n                lo = mid\n            else:\n                hi = mid\n        return lo\n \nT = Trigonometry(100)\n \nx1, y1, r1 = map(Decimal, input().split())\nx2, y2, r2 = map(Decimal, input().split())\n \nd = ((x1 - x2)**2 + (y1 - y2)**2).sqrt()\n \nif r1 + r2 <= d:\n    s = 0\n \nelif abs(r1 - r2) < d < r1 + r2:\n \n    cos_ph1 = (d**2 + r1**2 - r2**2) / (2 * d * r1)\n    cos_ph2 = (d**2 + r2**2 - r1**2) / (2 * d * r2)\n    ph1 = T.acos(cos_ph1)\n    ph2 = T.acos(cos_ph2)\n    a = r1**2 * ph1 + r2**2 * ph2\n    b = 4 * (d**2) * (r1**2) - (d**2 + r1**2 - r2**2)**2\n    s = (4 * (a**2) - b) / (4 * a + 2 * (b.sqrt()))\n \nelse:\n    s = min(r1**2 * T.pi, r2**2 * T.pi)\n \nprint(s)"]
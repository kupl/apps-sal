["n = int(input())\nwords = input().split()[:n]\n\np_base = 1543\np_mod = 1300199\n\ncurrent = [c for c in words[0]]\nfor word in words[1:]:\n    cur_hash = 0\n    word_hash = 0\n    cur_base = 1\n    i_matches = []\n    same_i = 0\n    biggest_match = None\n    while same_i < len(current) and same_i < len(word):\n        cur_hash *= p_base\n        cur_hash %= p_mod\n        cur_hash += ord(current[len(current) - 1 - same_i])\n        cur_hash %= p_mod\n\n        word_hash += ord(word[same_i]) * cur_base\n        word_hash %= p_mod\n\n        cur_base *= p_base\n        cur_base %= p_mod\n\n        if cur_hash == word_hash:\n            i_matches.append(same_i)\n            #biggest_match = same_i\n\n        same_i += 1\n\n\n    for match in reversed(i_matches):\n        if ''.join(word[:match + 1]) == ''.join(current[-1 - match:]):\n            biggest_match = match\n            break\n\n    if biggest_match is None:\n        current.extend(list(word))\n    else:\n        current.extend(list(word[biggest_match + 1:]))\n\n\nprint(*current, sep='')\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nL=list(input().split())\n\n#n=2*10**5\n#L=[\"aaa\",\"bbb\"]*(10**5)\n\n\nANS=[L[0]]\nLEN2=len(L[0])\n\nmod0=1<<16\nmod1=(1<<16)-3\nmod2=(1<<16)-2\np=75\n\nTABLE0=[0]\nTABLE1=[0]\nTABLE2=[0]\n\ndef hash_ij0(i,j): # [i,j)\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u6c42\u3081\u308b\n    return (TABLE0[j]-TABLE0[i]*pow(p,j-i,mod0))%mod0\n\ndef hash_ij1(i,j): # [i,j)\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u6c42\u3081\u308b\n    return (TABLE1[j]-TABLE1[i]*pow(p,j-i,mod1))%mod1\n\ndef hash_ij2(i,j): # [i,j)\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u6c42\u3081\u308b\n    return (TABLE2[j]-TABLE2[i]*pow(p,j-i,mod2))%mod2\n\nfor s in L[0]:\n    TABLE0.append((p*TABLE0[-1]%mod0+ord(s)-48)%mod0)\n    TABLE1.append((p*TABLE1[-1]%mod1+ord(s)-48)%mod1)\n    TABLE2.append((p*TABLE2[-1]%mod2+ord(s)-48)%mod2)\n\n\nfor i in range(1,n):\n    NEXT=L[i]\n    LEN=len(NEXT)\n\n    ha0=0\n    ha1=0\n    ha2=0\n\n    plus=-1\n\n    #print(NEXT)\n\n    for j in range(min(LEN,LEN2)):\n        ha0=(p*ha0%mod0+ord(NEXT[j])-48)%mod0\n        ha1=(p*ha1%mod1+ord(NEXT[j])-48)%mod1\n        ha2=(p*ha2%mod2+ord(NEXT[j])-48)%mod2\n\n        #print(ha1,TABLE1)\n        #print(hash_ij1(LEN2-j-1,LEN2))\n\n        if ha0==hash_ij0(LEN2-j-1,LEN2) and ha1==hash_ij1(LEN2-j-1,LEN2) and ha2==hash_ij2(LEN2-j-1,LEN2):\n            plus=j\n\n    #print(plus)\n\n    if plus==-1:\n        ANS.append(NEXT)\n        LEN2+=len(NEXT)\n\n        for s in NEXT:\n            TABLE0.append((p*TABLE0[-1]%mod0+ord(s)-48)%mod0)\n            TABLE1.append((p*TABLE1[-1]%mod1+ord(s)-48)%mod1)\n            TABLE2.append((p*TABLE2[-1]%mod2+ord(s)-48)%mod2)\n            \n    else:\n        NEXT=NEXT[plus+1:]\n\n        ANS.append(NEXT)\n        LEN2+=len(NEXT)\n\n        for s in NEXT:\n            TABLE0.append((p*TABLE0[-1]%mod0+ord(s)-48)%mod0)\n            TABLE1.append((p*TABLE1[-1]%mod1+ord(s)-48)%mod1)\n            TABLE2.append((p*TABLE2[-1]%mod2+ord(s)-48)%mod2)\n\nsys.stdout.write(\"\".join(ANS)+\"\\n\")\n        \n    \n", "from sys import stdin,stdout\nfrom sys import setrecursionlimit as SRL; SRL(10**7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\nnxt = [0] * (1000005)\nn = int(rd())\n\ns = list(rd().split())\n\nans = []\nfor i in s[0]:\n    ans.append(i)\n\nfor i in range(1,n):\n\n    v = s[i]\n\n    t = 0\n\n    for i in range(2,len(v)):\n        while t and v[i-1] != v[t]:\n            t = nxt[t]\n        if v[i-1] == v[t]:\n            t+=1\n        nxt[i] = t\n\n    t = 0\n    for i in range(max(0,len(ans)-len(v)),len(ans)):\n        while t and ans[i] != v[t]:\n            t = nxt[t]\n        if ans[i] == v[t]:\n            t += 1\n\n    while t < len(v):\n        ans.append(v[t])\n        t += 1\n\n\nprint(\"\".join(ans)+'\\n')", "def partial(s):\n    g, pi = 0, [0] * len(s)\n    for i in range(1, len(s)):\n        while g and (s[g] != s[i]):\n            g = pi[g - 1]\n        pi[i] = g = g + (s[g] == s[i])\n\n    return pi[-1]\n\n\nn = int(input())\ns = input().split()\nans = [*s[0]]\n\nfor i in s[1:]:\n    c = [*i] + ['$'] + ans[-min(len(i), len(ans)):]\n    j = partial(c)\n    for _ in range(j):\n        ans.pop()\n    ans.extend([*i])\n\nprint(''.join(ans))", "def prefix_func(s):\n    p = [0] * len(s)\n    for i in range(1, len(s)):\n        j = p[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = p[j - 1]\n\n        if s[i] == s[j]:\n        \tj += 1\n        p[i] = j\n\n    return p[-1]\n\n\nn = int(input())\ns = input().split()\nans = [*s[0]]\n\nfor i in s[1:]:\n    c = [*i] + ['$'] + ans[-min(len(i), len(ans)):]\n    j = prefix_func(c)\n    for _ in range(j):\n        ans.pop()\n    ans.extend([*i])\n\nprint(''.join(ans))", "def zalgo(S):\n    L = len(S)\n    Z = [0]*L\n    l = 0\n    for i in range(1, L):\n        if i + Z[i-l] < l + Z[l]:\n            Z[i] = Z[i-l]\n        else:\n            cnt = max(0, l+Z[l]-i)\n            while i + cnt < L and S[i+cnt] == S[cnt]:\n                cnt += 1\n            Z[i] = cnt\n            l = i\n    Z[0] = L\n    return Z\n\nN = int(input())\nS = [list(map(ord, s)) for s in input().strip().split()]             \nAns = [0]*(10**6)\nfor s in S:\n    n = len(s)\n    Z = zalgo(s+[-1]+Ans[-n:])[n+1:] + [0]\n    for i in range(n+1):\n        if n - i == Z[i]:\n            Ans += s[n-i:]\n            break\n    \nAns = Ans[10**6:]\nprint(''.join(map(chr, Ans)))", "def merge(res, s):\n    pi = [0 for i in range(len(s)+1)]\n    pi[0] = -1\n    b = -1\n    for i in range(1, len(s)+1):\n        while b > -1 and s[i-1] != s[b]:\n            b = pi[b]\n        b+=1\n        pi[i] = b\n    b = 0\n    for i in range(max(0, len(res)-len(s)), len(res)):\n        while b > -1 and res[i] != s[b]:\n            b = pi[b]\n        b+=1\n    for i in range(b, len(s)):\n        res.append(s[i])\nn = int(input())\ns = input().split()\nres = [*s[0]]\nfor i in range(1,n):\n    merge(res, s[i])\nprint(''.join(res))", "from sys import stdin, stdout\n\n\ndef compresswords(n, words):\n    a = []\n\n    for c in words[0]:\n        a.append(c)\n\n    for i in range(1, len(words)):\n        lps = getlps(words[i])\n        #print(lps)\n        idx = getsuffixmatchIdx(a, words[i], lps)\n        #print(idx)\n\n        #if idx == -1:\n        #    idx = 0\n\n        for j in range(idx, len(words[i])):\n            a.append(words[i][j])\n\n    return ''.join(a)\n\ndef getlps(w):\n\n    lps = []\n    lps.append(-1)\n\n    for i in range(1, len(w)):\n        c = w[i]\n        idx = i-1\n\n        while idx >= 0 and w[lps[idx] + 1] != c:\n            idx = lps[idx]\n\n        if idx >= 0:\n            idx = lps[idx] + 1\n\n        lps.append(idx)\n\n    #for i in range(len(lps)):\n    #    lps[i] += 1\n\n    return lps\n\n\ndef getsuffixmatchIdx(a, w, lps):\n\n    widx = 0\n    for i in range(max(0, len(a) - len(w)), len(a)):\n        c = a[i]\n\n        #print('w: ' + w[widx] + ' ' + str(widx))\n\n        while widx >= 0 and w[widx] != c:\n            widx -= 1\n            if widx > 0:\n                if lps[widx] >= 0:\n                    widx = lps[widx] + 1\n                else:\n                    widx = 0\n\n        #print('c: ' + str(c) + ' ' + str(widx) + ' | ' + str(i))\n        #print('-------------------------------')\n        #if widx >= 0:\n            ## find match\n        #else:\n            ## no match\n\n        widx += 1\n\n    return widx\n\n\ndef __starting_point():\n    n = int(stdin.readline())\n    words = list(stdin.readline().split())\n\n    if n != len(words):\n        print('length not match')\n\n    res = compresswords(n, words)\n\n    #stdout.write(res)\n    print(res)\n\n    #lps = getlps('ABABCABABX')\n    #print(lps)\n    #a = ['a','b','c','d','A','B']\n    #r = getsuffixmatchIdx(a, 'ABABCABABX', lps)\n    #print(r)\n\n__starting_point()", "def compress(words):\n    if not words:\n        return ''\n\n    def prefix(s):\n        table = [0] * len(s)\n        j = 0\n        for i in range(1, len(s)):\n            while 0 < j and s[i] != s[j]:\n                j = table[j - 1]\n\n            if s[i] == s[j]:\n                j += 1\n                table[i] = j\n\n        return table[-1]\n\n    result = [*words[0]]\n    for word in words[1:]:\n        n = min(len(result), len(word))\n        for _ in range(prefix([*word] + ['$'] + result[-n:])):\n            result.pop()\n        result.extend([*word])\n\n    return ''.join(result)\n\n\ndef solve():\n    _ = int(input())\n    words = input().split()\n    print(compress(words))\n\n\nsolve()\n", "def zalgo(s:str):\n  \n  l=0;r=0;n=len(s);\n\n  z = [0]*n\n\n  for i in range(1,n):\n\n    z[i] = 0\n\n    if(i<=r): z[i]=min(r-i+1,z[i-l])\n\n    while(i+z[i]<n and s[z[i]]==s[i+z[i]]): z[i]+=1\n\n    if(i+z[i]-1>r): \n      l = i\n      r = i+z[i]-1\n    \n    if(i+z[i]==n):\n      return z[i]\n\n  return 0\n\nn = int(input())\n\ns = input().split()\n\ntxt = [s[0]]\n\n\nfor i in range(1,n):\n  x = len(txt)\n  y = len(s[i])\n\n  mn = min(x,y)\n  \n # print(mn,str(txt[-mn:]),sep=' ')\n  \n  mx = zalgo(s[i] + '#' + ''.join((txt[-mn:])))\n  \n # print(mx,mn,sep=' ')\n  \n  txt.extend(s[i][mx:])\n\nprint(''.join(txt)) \n\n\n", "def zalgo(s:str):\n  \n  l=0;r=0;n=len(s);\n\n  z = [0]*n\n\n  for i in range(1,n):\n\n    z[i] = 0\n\n    if(i<=r): z[i]=min(r-i+1,z[i-l])\n\n    while(i+z[i]<n and s[z[i]]==s[i+z[i]]): z[i]+=1\n\n    if(i+z[i]-1>r): \n      l = i\n      r = i+z[i]-1\n    \n    if(i+z[i]==n):\n      return z[i]\n\n  return 0\n\nn = int(input())\n\ns = input().split()\n\ntxt = []\n\nfor i in range(0,n):\n  x = len(txt)\n  y = len(s[i])\n\n  mn = min(x,y)\n  \n  #print(mn,txt[-mn:],sep=' ')\n  \n  mx = zalgo(s[i] + '#' + ''.join((txt[-mn:])))\n  \n # print(mx,mn,sep=' ')\n  \n  txt.extend(s[i][mx:])\n\nprint(''.join(txt)) \n\n\n", "def zalgo(s:str):\n  \n  l=0;r=0;n=len(s);\n\n  z = [0]*n\n\n  for i in range(1,n):\n\n    z[i] = 0\n\n    if(i<=r): z[i]=min(r-i+1,z[i-l])\n\n    while(i+z[i]<n and s[z[i]]==s[i+z[i]]): z[i]+=1\n\n    if(i+z[i]-1>r): \n      l = i\n      r = i+z[i]-1\n    \n    if(i+z[i]==n):\n      return z[i]\n\n  return 0\n\nn = int(input())\n\ns = input().split()\n\ntxt = []\n\nfor i in range(0,n):\n  x = len(txt)\n  y = len(s[i])\n\n  if x > y:\n       #print(x,y,(txt[x-y:y]))\n       mx = zalgo(s[i] + '#'+ ''.join((txt[x-y:x])))\n  else:\n       #print(x,y,txt[:])\n       mx = zalgo(s[i][:y]+'#'+''.join(txt))\n  \n # mx = zalgo(s[i] + '#' + ''.join((txt[-mn:])))\n \n  #print(mx)\n  \n # print(mx,mn,sep=' ')\n  \n  txt.extend(s[i][mx:])\n  \n # print(txt)\n\nprint(''.join(txt)) \n\n\n", "def zalgo(s:str):\n  \n  l=0;r=0;n=len(s);\n\n  z = [0]*n\n\n  for i in range(1,n):\n\n    z[i] = 0\n\n    if(i<=r): z[i]=min(r-i+1,z[i-l])\n\n    while(i+z[i]<n and s[z[i]]==s[i+z[i]]): z[i]+=1\n\n    if(i+z[i]-1>r): \n      l = i\n      r = i+z[i]-1\n    \n    if(i+z[i]==n):\n      return z[i]\n\n  return 0\n\nn = int(input())\n\ns = input().split()\n\ntxt = []\n\nfor i in range(0,n):\n  x = len(txt)\n  y = len(s[i])\n\n  if x > y:\n       mx = zalgo(s[i] + '#'+ ''.join((txt[x-y:x])))\n  else:\n       mx = zalgo(s[i][:y]+'#'+''.join(txt))\n  \n  txt.extend(s[i][mx:])\n\nprint(''.join(txt)) \n\n\n"]
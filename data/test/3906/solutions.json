["N, M = list(map(int, input().split()))\nP = 10**9+7\nF = [1, 2]\nfor i in range(101010):\n    F.append((F[-1]+F[-2])%P)\nprint((F[N-1]+F[M-1]-1)*2%P)\n\n", "3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N, M = read_ints()\n    print(solve(N, M))\n\n\ndef solve(N, M):\n    def row_count(w):\n        dp = [0] * (w + 1)\n        dp[0] = 1\n        for i in range(w):\n            if i + 1 <= w:\n                dp[i + 1] += dp[i]\n                dp[i + 1] %= MOD\n            if i + 2 <= w:\n                dp[i + 2] += dp[i]\n                dp[i + 2] %= MOD\n        return dp[w]\n\n    c = row_count(N)\n    r = row_count(M)\n\n    return ((c + r - 1) * 2) % MOD\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\nif n + m == 2:\n    print(2)\n    return\nif n > m:\n    n, m = m, n\na, b, c, d = 1, 1, 1, 1\nmod = 10 ** 9 + 7\nfor i in range(2, m):\n    a, b, c, d = c, a + c, b + d, b\n    a %= mod\n    b %= mod\n    c %= mod\n    d %= mod\nif n == 1:\n    print((a + b + c + d) % mod)\n    return\na1 = b1 = c1 = d1 = 1\nfor i in range(2, n):\n    a1, b1, c1, d1 = c1, a1 + c1, b1 + d1, b1\n    a1 %= mod\n    b1 %= mod\n    c1 %= mod\n    d1 %= mod\nprint((a + b + c + d + a1 + b1 + c1 + d1 - 2 + mod) % mod)", "MOD = 1000000007\n\n\ndef fib(n):\n    a = b = 1\n    for _ in range(n):\n        a, b = b, (a + b) % MOD\n    return a\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    print((fib(n) + fib(m) - 1) * 2 % MOD)\n\n\nmain()\n", "n,m=list(map(int,input().split()))\nmod=10**9+7\n\nB=[1]\nW=[1]\nBB=[0]\nWW=[0]\n\nfor i in range(1,100010):\n    x=W[-1]+WW[-1]\n    y=B[-1]+BB[-1]\n    z=B[-1]\n    w=W[-1]\n\n    x%=mod\n    y%=mod\n    z%=mod\n    w%=mod\n\n    B.append(x)\n    W.append(y)\n    BB.append(z)\n    WW.append(w)\n\nprint((B[n-1]+W[n-1]+BB[n-1]+WW[n-1]+B[m-1]+W[m-1]+BB[m-1]+WW[m-1]-2)%mod)\n\n\n", "n, m = [int(x) for x in input().split()]\np = 10 ** 9 + 7\n\nx = [1, 2]\nfor i in range(2, max(n, m)):\n    x.append(x[i - 1] + x[i - 2])\n\nprint(2 * (x[n - 1] + x[m - 1] - 1) % p)\n", "n, m = [int(x) for x in input().split()]\np = 10 ** 9 + 7\n\nx = [0] * max(n, m)\nx[0:1] = [1, 2]\nfor i in range(2, max(n, m)):\n    x[i] = (x[i - 1] + x[i - 2]) % p\n\nprint(2 * (x[n - 1] + x[m - 1] - 1) % p)\n", "M = 10 ** 9 + 7 # MODULO\narray = [0] * 100010 # Extra because im bad\narray[0] = 1\narray[1] = 1\n# array[2] = 2\ndef f(n):\n    if array[n] == 0:\n        array[n] = (f(n - 1) + f(n - 2)) % M\n    return array[n]\n\n# To initialize, don't use sys.setrecursionlimit(99999). It's bad.\nfor i in range(1, 100010):\n    f(i) # Calculates the value but doesn't do anything with it\n# Now you can do\n# a, b = tuple(map(int, input().split()))\na, b = map(int, input().split()) # No need tuple, python is smart :)\nprint (( (f(a)+f(b)-1)*2 ) % M)", "l = [0] * (10**6 + 1)\nl[2] = 2\nmod = 10**9 + 7\nn, m = [int(i) for i in input().split()]\nfor i in range(3, max(m, n) + 1):\n    l[i] = (l[i - 1] + l[i - 2]) % mod\nres = 0\nfor i in range(n + 1):\n    res += l[i]\nfor j in range(m + 1):\n    res += l[j]\nprint((2 + res) % mod)", "def task_1(n, m): # n - \u0441\u0442\u0440\u043e\u043a\u0438 m - \u0441\u0442\u043e\u043b\u0431\u0446\u044b\n    counts = 8\n    last = 0\n    current = 1\n    fn = fm = None\n    for i in range(0, max(n, m)+1):\n        if n == i:\n            fn = current\n        if m == i:\n            fm = current\n        last, current = current, last + current\n        \n    counts = 2*(fn + fm - 1)\n    print(counts%(10**9+7))\n\ndef __starting_point():\n    # Number of requests\n    n, m = (map(int, input().rstrip().split()))\n    task_1(n, m)\n__starting_point()", "n, m = map(int, input().split())\nd = [2, 4] \nk = 10**9+7\nfor i in range(2, max(n, m)):\n    d += [(d[i-1]+d[i-2]) % k]\nprint((d[m-1]+d[n-1]-2) % k)", "#!/usr/bin/env python3\n\nwidth, height = list(map(int, input().strip().split(' ')[:2]))\n\nmodulo = 10**9 + 7\nfibs = [0, 0]\nsum_fibs = [0, 0]  # sum [2..N] Fib(i)\na, b = 1, 0\nfor i in range(max(width, height)):\n    fibs.append(a)\n    sum_fibs.append((sum_fibs[-1] + a) % modulo)\n    a, b = (a + b) % modulo, a\n\n\ndef ans(w, h):\n    return 2 * (1 + sum_fibs[w] + sum_fibs[h]) % modulo\n\n\nprint(ans(width, height))\n", "\n# coding: utf-8\n\n# In[7]:\n\nn, m = list(map(int, input().split()))\n\ndef fib(n):\n    if n<2:\n        return 1\n    a = 1\n    b = 1\n    for i in range(2, n+1):\n        c = a + b\n        a = b\n        b = c\n    return c\n\nprint((2*fib(n)+2*fib(m)-2)%(10**9+7))\n\n", "N, M = list(map(int, input().split()))\nP = 10**9+7\nF = [1, 2]\nfor i in range(100009):\n    F.append((F[-1]+F[-2])%P)\nprint((F[N-1]+F[M-1]-1)*2%P)\n", "f = []\nf.append(1)\nf.append(1)\nmod = 1e9+7\nfor i in range(100010):\n\tf.append((f[-1]+f[-2])%mod)\nn,m = list(map(int,input().split()))\nprint(int(2*(f[n]+f[m]-1)%mod))\n", "n, m = [int(x) for x in input().split()]\np = 10 ** 9 + 7\n\nx = [0] * max(n, m)\nx[0:1] = [1, 2]\nfor i in range(2, max(n, m)):\n    x[i] = (x[i - 1] + x[i - 2]) % p\n\nprint(2 * (x[n - 1] + x[m - 1] - 1) % p)", "foo=[]\nn, m = input().split()\nn = int(n)\nm = int(m)\n\nfoo.append(1)\nfoo.append(1)\n\nfor i in range(max(n,m)):\n    foo.append(foo[i+1]+foo[i])\n\no = 2*(foo[n] + foo[m] - 1)\n\nprint(o % 1000000007)\n\n\n        \n    \n    \n    \n\n", "height, width = list(map(int, input().split()))\n\ndef fib(n):\n  if n < 2:\n    return n\n  a, b = [0, 1]\n  for i in range(0, n):\n    a, b = [b, a + b]\n  return a\n\ndef solve(height, width):\n  x = fib(width + 1) * 2\n  return (x - 2 + fib(height + 1) * 2) % (pow(10, 9) + 7)\n\nprint(solve(height, width))\n", "from sys import stdin\n\nheight, width = list(map(int, stdin.readline().rstrip().split()))\n\ndef fib(n):\n  if n < 2:\n    return n\n  a, b = [0, 1]\n  for i in range(0, n):\n    a, b = [b, a + b]\n  return a\n\ndef solve(height, width):\n  x = fib(width + 1) * 2\n  return (x - 2 + fib(height + 1) * 2) % (pow(10, 9) + 7)\n\nprint(solve(height, width))\n", "a=input().split(\" \")\nx=int(a[0])\ny=int(a[1])\nn=2\nm=2\nA = 1000000000+7\nwhile x>1:\n    m=(m%A+n%A)%A\n    n =(m%A-n%A)%A\n    x-=1\nr1 = m\nm = 2\nn = 2\nwhile y>1:\n    m=(m%A+n%A)%A\n    n =(m%A-n%A)%A\n    y-=1\nr2 = m\nprint((r1+r2-2)%A)", "n,m=list(map(int,input().split()))\na=[0]*100001\na[0]=1\na[1]=1\np =1000000007\nfor i in range(2,100001):\n\ta[i]=(a[i-1]+a[i-2])%p\nprint(((a[n]+a[m]-1)*2)%p)\n", "n, m = map(int,input().split())\ndp = [0]*100001\ndp[0], dp[1] = 1, 1\nMOD =1000000007\nfor i in range(2,100001):\n\tdp[i] = (dp[i - 2] + dp[i - 1]) % MOD\nprint(2 * (dp[n] + dp[m] - 1) % MOD)", "import sys\na, b = map(int, sys.stdin.readline().split())\npp = pow(10,9) + 7\nfib = [[0,1],[1,1]]\n\ndef MatDiv(a,b):\n    res = [[0,0],[0,0]]\n    res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % pp\n    res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % pp\n    res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % pp\n    res[1][1] = (a[1][0] * b[1][0] + a[1][1] * b[1][1]) % pp\n    return res\n\ndef BinPow(x,p):\n    if p == 1:\n        return fib\n    res = BinPow(x, p // 2)\n    if p % 2 == 0:\n        return MatDiv(res,res)\n    else:\n        return MatDiv(MatDiv(res,res),x)\n\ntmp = BinPow(fib.copy(),a)\ntmp2 = BinPow(fib.copy(),b)\nprint(((tmp[0][0] + tmp[0][1] + tmp2[0][0] + tmp2[0][1]) * 2 - 2) % pp)", "import sys\n# sys.stdin = open('C:\\\\Users\\\\sharr\\\\Documents\\\\Input.txt', 'r')  \n# sys.stdout = open('C:\\\\Users\\\\sharr\\\\Documents\\\\Output.txt', 'w') \nn,m = map(int,sys.stdin.readline().split())\nf = [1,1]\nmod = 1000000007\nfor i in range(100000):\n\tf.append(f[-1]+f[-2])\nres = 2*(f[n]+f[m]-1)\nres %=mod\nprint(res)"]
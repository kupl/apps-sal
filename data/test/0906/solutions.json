["n, m, k = map(int, input().split())\nif k == -1 and n % 2 != m % 2:\n\tprint(0)\nelse:\n\tprint(pow(2, (n - 1) * (m - 1), 10**9 + 7))", "a,b,c=list(map(int,input().split()))\nif c==-1 and (a+b)%2!=0:\n    print(0)\nelse:\n    print(pow(2,a*b-a-b+1,1000000007))\n", "mod = 1000000007\n\ndef BinPow2(x, n):\n\tif (n == 0):\n\t\treturn 1\n\tif (n % 2 == 0):\n\t\treturn (BinPow2((x * x) % mod, n // 2) % mod)\n\telse:\n\t\treturn (x * (BinPow2((x * x) % mod, (n - 1) // 2) % mod)) % mod\n\nn, m, k = list(map(int, input().split()))\nif (k == -1 and (n % 2) != (m % 2)):\n\tprint(0)\nelse:\n\tprint(BinPow2(2, (n - 1) * (m - 1)))", "ins = [int(x) for x in input().split(\" \")]\nn = ins[0]\nm = ins[1]\nk = ins[2]\nbig = 1000000007\n\nif n == 1:\n    if k == 1:\n        print(\"1\")\n    if k == -1:\n        if m % 2 == 1:\n            print(\"1\")\n        else:\n            print(\"0\")\nelif m == 1:\n    if k == 1:\n        print(\"1\")\n    if k == -1:\n        if n % 2 == 1:\n            print(\"1\")\n        else:\n            print(\"0\")\nelse:\n    if k == -1:\n        if n%2 != m%2:\n            print(\"0\")\n        else:\n            print(pow(2,(n-1)*(m-1),big))\n    else:\n        print(pow(2,(n-1)*(m-1),big))\n", "n, m, k = list(map(int, input().split()))\ndiag = n + m - 2\nif k == -1 and diag % 2 == 1:\n    print(0)\nelse:\n    print(pow(2, (n-1)*(m-1), 10 ** 9 + 7))\n\n", "A = input().split()\nn = int(A[0])\nm = int(A[1])\nk = int(A[2])\ndef ans(e):\n    final = 1\n    for i in range (0,e):\n        final = (final*2)%1000000007\n    return(final)\nif m == 1:\n    if k == 1:\n        print (1)\n    elif k ==-1:\n        if n%2 ==0:\n            print(0)\n        elif n%2 ==1:\n            print(1)\nelif n == 1:\n    if k == 1:\n        print (1)\n    elif k ==-1:\n        if m%2 ==0:\n            print(0)\n        elif m%2 ==1:\n            print(1)\nelse:\n    if k==1:\n        e1 = (m-1)%1000000006\n        e2 = (n-1)%1000000006\n        e = (e1*e2)%1000000006\n        print (pow(2,e,1000000007))\n    elif k==-1:\n        if m%2 != n%2:\n            print(0)\n        else:\n            e1 = (m-1)%1000000006\n            e2 = (n-1)%1000000006\n            e = (e1*e2)%1000000006\n            print (pow(2,e,1000000007))", "# IAWT\nn, m, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndef p(x):\n    if x == 0: return 1\n    if (x % 2 == 0):\n        return (p(x//2) ** 2) % mod\n    return (p(x//2) ** 2 * 2) % mod\n\nif k == -1 and (n+m) % 2 == 1:\n    print(0)\nelse:\n    print(p(n*m-n-m+1))\n", "n, m, k = list(map(int, input().split()))\nif n < m:\n    n, m = m, n\nif k == -1:\n    if (n % 2 == 0 and m % 2 == 1) or (n % 2 == 1 and m % 2 == 0):\n        ans = 0\n    else:\n        ans = pow(2, (n - 1) * (m - 1), 1000000007)\nelse:\n    ans = pow(2, (n - 1) * (m - 1), 1000000007)\nprint(ans)", "def bin_exp(x, n, m):\n    r = 1\n    while n>0:\n        if n%2 == 1:\n            r = (r*x)%m\n        x = (x*x)%m\n        n = n//2\n    return r\n\nM = 1000000007\nI = [int(i) for i in input().split()]\nn = I[0]\nm = I[1]\nk = I[2]\n\nif n%2 != m%2 and k == -1:\n    print(0)\nelse:\n    h = bin_exp(2, n-1,M)\n    h = bin_exp(h, m-1, M)\n    print(h)\n", "\ndef fastExpMod(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\n\nn =  1000000000+7\na, b, c = map(int, input().split())\nif(c==-1 and ((b%2==0 and a%2==1)or (b%2==1 and a%2==0))):\n    print(\"0\")\nelse :\n    print(fastExpMod(2,(a-1)*(b-1),n))", "inp = input()\n(n, m, k) = map(int, inp.split())\n\nif n%2 != m%2 and k == -1:\n    print(0)\nelse:\n    ret = pow(2, (n-1)*(m-1), 10**9+7)\n    print(ret)", "mo = 1000000007\n\ndef fast_pow(p):\n    if (p == 0):\n        return 1\n    if (p % 2 == 1):\n        return 2 * ((fast_pow(p//2) ** 2) % mo)\n\n    return (fast_pow(p//2) ** 2) % mo \n\n\narr = (input()).split(' ')\n\nn = int(arr[0])\nm = int(arr[1])\nk = int(arr[2])\n\nif ((n+m) % 2 == 1 and k == -1):\n    print('0')\nelse:\n    print (fast_pow(( n-1)*(m-1) ) % mo)", "MODULO = 1000000007\n\ndef fast_pow(x):\n\tif x == 1:\n\t\treturn 2\n\tif x == 0:\n\t\treturn 1\n\tprev = fast_pow(x // 2)\n\tadd = 1 if x % 2 == 0 else 2\n\treturn (prev * prev * add) % MODULO\n\nn, m, k = map(int, input().split())\n\nif k == -1 and  n % 2 != m % 2:\n\tprint(0)\nelse:\n\tprint(fast_pow(n * m - n - m + 1))", "def pow(x, p):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        return pow((x * x) % mod, p // 2)\n    return (x * pow(x, p - 1)) % mod\n\nn, m, k = list(map(int, input().split()))\nmod = 1000000007\nif k == 1:\n    if n == 1 or m == 1:\n        print(1)\n    else:\n        print(pow(2, (n - 1) * (m - 1)))\nelse:\n    if n % 2 != m % 2:\n        print(0)\n    elif n == 1 or m == 1:\n        print(1)\n    else:\n        print(pow(2, (n - 1) * (m - 1)))\n", "def f(b, e, m):\n    result = 1\n    while e != 0:\n        if (e&1) == 1:\n            # ei = 1, then mul\n            result = (result * b) % m\n        e >>= 1\n        # b, b^2, b^4, b^8, ... , b^(2^n)\n        b = (b*b) % m\n    return result\na = [int(i) for i in input().split()]\nn, m, k = a[0], a[1], a[2]\nif k == -1:\n    if (n + m) % 2 == 1:\n        print(0)\n    else:\n        if n == 1 or m == 1:\n            print(1)\n        else:\n            print(f(2, (n * m - n - m + 1), 1000000007))\nelif k == 1:\n    if n == 1 or m == 1:\n        print(1)\n    else:\n        print(f(2, (n * m - n - m + 1), 1000000007))", "n, m, k = map( int, input().split())\na = ( n - 1 ) * ( m - 1 )\nz = 2\nif ( a == 0 ):\n    z = 1\nzd = 1\nmod = 1000000007\nwhile ( a > 1 ):\n    if ( a % 2 == 1 ):\n        zd = ( zd * z ) % mod\n    z = ( z * z ) % mod\n    a = a // 2\nz = ( z * zd ) % mod\nif ( k == -1 ):\n    if ( n % 2 == m % 2 ):\n        print( z )\n    else:\n        print( 0 )\nelse:\n    print( z )", "n, m, k = [int(i) for i in input().split()]\nn, m = min(n, m), max(n, m)\nmod = 1000000007\n\ndef f_pow(a, k):\n    if k == 0:\n        return 1\n    if k % 2 == 1:\n        return f_pow(a, k - 1) * a % mod\n    else:\n        return f_pow(a * a % mod, k // 2) % mod\n\nif k == -1:\n    if (n % 2 == 0 and m % 2 == 1) or (n % 2 == 1 and m % 2 == 0):\n        print(0)\n    else:\n        print(f_pow(2, (n - 1) * (m -1)) % mod)                               \nelse:\n    print(f_pow(2, (n - 1) * (m -1)) % mod)\n", "a, b, c = [int(i) for i in input().split(' ')]\n\ndef exp_mod_prime(x, p):\n    x = x % (p-1)\n    a = 2\n    bonus = 1\n    while x > 1:\n        if x % 2 == 1:\n            bonus = (bonus * a) % p\n        a = (a * a) % p\n        x = x // 2\n    return a * bonus % p\n\nif c == 1:\n    if a == 1:\n        result = 1\n    elif b == 1:\n        result = 1\n    else:\n        result = exp_mod_prime((a-1) * (b-1), 1000000007)\nelse:\n    if a == 1:\n        if b % 2 == 0:\n            result = 0\n        else:\n            result = 1\n    elif b == 1:\n        if a % 2 == 0:\n            result = 0\n        else:\n            result = 1\n    elif (a + b) % 2 == 1:\n        result = 0\n    else:\n        result = exp_mod_prime((a-1) * (b-1), 1000000007)\n    \n\nprint(result % 1000000007)\n", "mod=1000000007\ndef sqr(n):return n*n%mod\ndef pow(a,n):\n\tif n==0:return 1\n\tif n%2==1:return sqr(pow(a,n>>1))*a%mod\n\treturn sqr(pow(a,n>>1))\n\nn,m,k=list(map(int,input().split()))\nif (n+m)%2==1 and k==-1:\n\tprint(0)\n\treturn\nprint(pow(2,(n-1)*(m-1)))\n", "import sys\n\narr = [int(x) for x in input().split()]\nn = arr[0]\nm = arr[1]\nk = arr[2]\nif n % 2 != m % 2 and k == -1:\n    print(0)\nelse:\n    print(pow(2, (n-1)*(m-1), 1000*1000*1000+7))", "\"\"\"\nATSTNG's ejudge Python3 solution template\n(actual solution is below)\n\"\"\"\n\nimport sys, queue, string, math, itertools\n\ntry:\n    import dev_act_ffc429465ab634  # empty file in directory\n    DEV = True\nexcept:\n    DEV = False\n\ndef log(*s):\n    if DEV: print('LOG', *s)\n\nclass EJudge:\n    def __init__(self, problem=\"default\", reclim=1<<30):\n        self.problem = problem\n        sys.setrecursionlimit(reclim)\n\n    def use_files(self, infile='', outfile=''):\n        if infile!='':\n            self.infile = open(infile)\n            sys.stdin = self.infile\n        if infile!='':\n            self.outfile = open(outfile, 'w')\n            sys.stdout = self.outfile\n\n    def use_bacs_files(self):\n        self.use_files(self.problem+'.in', self.problem+'.out')\n\n    def get_tl(self):\n        while True: pass\n\n    def get_ml(self):\n        tmp = [[[5]*100000 for _ in range(1000)]]\n        while True: tmp.append([[5]*100000 for _ in range(1000)])\n\n    def get_re(self):\n        s = (0,)[8]\n\n    def get_wa(self, wstr='blablalblah'):\n        for _ in range(3): print(wstr)\n        return\n\nclass IntReader:\n    def __init__(self):\n        self.ost = queue.Queue()\n\n    def get(self):\n        return int(self.sget())\n\n    def sget(self):\n        if self.ost.empty():\n            for el in input().split():\n                self.ost.put(el)\n        return self.ost.get()\n\n    def release(self):\n        res = []\n        while not self.ost.empty():\n            res.append(self.ost.get())\n        return res\n\n\n\n###############################################################################\nej = EJudge( '' )\nint_reader = IntReader()\nfmap = lambda f,*l: list(map(f,*l))\nparse_int = lambda: fmap(int, input().split())\nrevrange = lambda x: list(range(x-1, -1, -1))\n\ndef aeq(ar, v):\n    for el in ar:\n        if el != v: return False\n    return True\nk = -1\n\n\nh, w = 5, 1\n\ndef calcfast(h, w, k):\n    if k == -1 and (h+w) & 1: return 0\n    ans = pow(2, ((h-1)*(w-1)), 1000000007)\n    return ans\n\ndef calc(h,w, k):\n    a = [ [0]*w for i in range(h) ]\n    ans = 0\n    for mask in range(2**(h*w)):\n        #print(bin(mask)[2:])\n        cur_mask = mask\n        for pos in range(h*w):\n            a[pos//w][pos%w] = 1 if (cur_mask&1 == 1) else -1\n            cur_mask >>= 1\n        rowsum, colsum = [1]*h, [1]*w\n        for i in range(h):\n            for j in range(w):\n                rowsum[i] *= a[i][j]\n                colsum[j] *= a[i][j]\n        if aeq(rowsum, k) and aeq(colsum, k):\n            ans += 1\n            #print(rowsum, colsum)\n\n    print('calced for ', h,w,k, '=',ans)\n    return ans\n\n\n'''\nfor h in range(2, 3):\n    for w in range(1, 20):\n        for k in [1, -1]:\n            ans = calc(h, w, k)\n            print('OK' if ans == calcfast(h,w,k) else \"ERROR\")\n'''\n\nh,w,k = parse_int()\nprint(calcfast(h,w,k)%1000000007)\n#'''\n\n\n\n\n\n\n\n", "n, m, k = [int(x) for x in input().split()]\nif (k == -1) and ((n+m) % 2 == 1):\n\tprint(0)\nelse:\n\tprint(pow(2, (n-1)*(m-1), 1000000007))", "from sys import stdin, stdout\nm , n ,k = [int(x) for x in stdin.readline().rstrip().split()]\n\n\n\nlarge_prime = 10 ** 9 + 7\n\ndef fastPower(base, exp, mod):\n    if exp == 0:\n        x = 1\n    else:\n        half = fastPower(base, exp // 2, mod)\n        x = half * half\n        if exp % 2 == 1:\n            x *= base\n    return x % mod\n\ndef solve_two(n, m, k):\n    if (m + n) % 2 == 1 and k == -1:\n        print (0)\n        return\n    power1 = (m-1) % (large_prime - 1)\n    power2 = (n-1) % (large_prime - 1)\n    print( fastPower(2, power1*power2, large_prime))\n    return\n    \nsolve_two(m , n, k )", "A = list(map(int, input().split()))\n\nx = A[0]\ny = A[1]\nk = A[2]\n\nif (x+y)%2 == 1 and k == -1:\n    print(\"0\")\nelse:\n    if x > y:\n        z = x\n        x = y\n        y = z\n    if x == 1:\n        print(\"1\")\n    else:\n        start = (x-1)*(x-1)\n        dif = y-x;\n        start = start + (dif*(x-1))\n        p = 1000000007\n        res = 1\n        x = 2\n        y = start\n        while y > 0:\n            if (y%2 == 1):\n                res = (res * x) % p\n            y = y // 2\n            x = (x*x) % p\n        print(res)"]
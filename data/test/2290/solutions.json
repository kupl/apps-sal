["import sys\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\n\nEdge = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nused = set()\nans = 0\nmp = -1\nfor i in range(N):\n    if i in used:\n        continue\n    if mp >= i:\n        ans += 1\n        Edge[mp].append(i)\n        Edge[i].append(mp)\n        mp = max(mp, i)\n    else:\n        st = i\n    \n    stack = [i]\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf not in used:\n                mp = max(mp, vf)\n                used.add(vf)\n                stack.append(vf)\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [-1] * n\n        self.cnt = n\n\n    def root(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            if self.parent[x] > self.parent[y]:\n                x, y = y, x\n            self.parent[x] += self.parent[y]\n            self.parent[y] = x\n            self.cnt -= 1\n          \n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n             \n    def get_size(self, x):\n        return -self.parent[self.root(x)]\n    \n    def get_cnt(self):\n        return self.cnt\n\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(m)]\nuf = UnionFind(n)\n\nfor a, b in info:\n    uf.merge(a - 1, b - 1)\n\nans = 0\ni = 0\nwhile True:\n    if i >= n:\n        break\n    cnt = uf.get_size(i)\n    j = i\n    while cnt:\n        if uf.is_same(i, j):\n            cnt -= 1\n            j += 1\n        else:\n            cnt -= 1\n            cnt += uf.get_size(j)\n            ans += 1\n            uf.merge(i, j)\n            j += 1\n    i = j\nprint(ans)", "# unionfind\nclass Uf:\n    def __init__(self, N):\n        self.p = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def root(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.root(self.p[x])\n\n        return self.p[x]\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        u = self.root(x)\n        v = self.root(y)\n\n        if u == v: return\n\n        if self.rank[u] < self.rank[v]:\n            self.p[u] = v\n            self.size[v] += self.size[u]\n            self.size[u] = 0\n        else:\n            self.p[v] = u\n            self.size[u] += self.size[v]\n            self.size[v] = 0\n\n            if self.rank[u] == self.rank[v]:\n                self.rank[u] += 1\n\n    def count(self, x):\n        return self.size[self.root(x)]\n\nimport sys\nfrom operator import itemgetter\ndef main():\n    input = sys.stdin.readline\n    N, M = list(map(int, input().split()))\n    # harmonious <=> l < m < r \u3067\u3001l \u304b\u3089 r \u306b\u8fbf\u308a\u7740\u3051\u308b\u306a\u3089\u3001l \u304b\u3089 m \u306b\u8fbf\u308a\u7740\u3051\u308b\n\n    uf = Uf(N+1)\n    for u, v in zip(*[iter(map(int, sys.stdin.read().split()))]*2):\n        uf.unite(u, v)\n\n    L = [10**9] * (N+1)\n    R = [-1] * (N+1)\n    for i in range(1, N+1):\n        r = uf.root(i)\n        L[r] = min(L[r], i)\n        R[r] = max(R[r], i)\n    ans = 0\n    LR = []\n    for l, r in zip(L, R):\n        if r != -1:\n            LR.append((l, r))\n    LR.sort(key=itemgetter(0))\n    rr = -1\n    for l, r in LR:\n        if rr > l:\n            ans += 1\n        rr = max(rr, r)\n    print(ans)\n\n\nmain()\n", "def main():\n    from sys import stdin, stdout\n    from array import array\n    n, m = list(map(int, stdin.readline().split()))\n    n += 1\n    g = [array('l', ()) for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, stdin.readline().split()))\n        g[u].append(v)\n        g[v].append(u)\n    ans = 0\n    new = array('i', (1,)) * n\n    vr = 0\n    for v1 in range(n):\n        if new[v1]:\n            if v1 < vr:\n                ans += 1  # v1 vr\n            stack = [v1]\n            while stack:\n                u = stack.pop()\n                if new[u]:\n                    new[u] = 0\n                    vr = max(vr, u)\n                    for v in g[u]:\n                        stack.append(v)\n    print(ans)\n\n\nmain()\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nP = [-1 for i in range(N)]\ndef par(a):\n    L = []\n    while P[a] >= 0:\n        L.append(a)\n        a = P[a]\n    for l in L:\n        P[l] = a\n    return a\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\n\nfor _ in range(M):\n    u, v = list(map(int, input().split()))\n    unite(u-1, v-1)\n\nC = [[] for _ in range(N)]\nD = [0] * N\nfor i in range(N):\n    C[par(i)].append(i)\n    D[par(i)] = 1\nma = -1\nans = 0\nfor i in range(N):\n    p = par(i)\n    if D[p] == 0:\n        continue\n    D[p] = 0\n    if min(C[p]) < ma:\n        ans += 1\n    ma = max(ma, max(C[p]))\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.rank = [0] * n\n        self.max_member = [i for i in range(n)]\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def has_same_root(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return self.size[self.root(x)]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.max_member[y] = max(self.max_member[x], self.max_member[y])\n        else:\n            self.par[y] = x\n            self.max_member[x] = max(self.max_member[x], self.max_member[y])\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\nn, m = [int(item) for item in input().split()]\nDS = DisjointSet(n)\nfor i in range(m):\n    u, v = [int(item) - 1 for item in input().split()]\n    DS.unite(u, v)\ngoal = 0\npar = 0\nans = 0\nfor i in range(n):\n    if goal <= i:\n        par = DS.par[i]\n        goal = DS.max_member[par]\n        continue\n    if DS.has_same_root(par, i): \n        continue\n    else:\n        DS.unite(par, i)\n        ans += 1\n        par = DS.par[i]\n        goal = DS.max_member[par]\nprint(ans)", "from sys import stdin\n\ninput = stdin.readline\n\nedge = [[] for _ in range(200005)]\nn, m = map(int, input().split())\n\ncheck = [0] * 200005\nmx = 0\n\nfrom collections import deque\n\ndef dfs(x):\n    l = deque([x])\n    check[x] = 1\n    while len(l):\n        p = l.popleft()\n        nonlocal mx\n        mx = max(mx,p)\n        for i in edge[p]:\n            if check[i]:\n                continue\n            l.append(i)\n            check[i] = 1\n\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    edge[u].append(v)\n    edge[v].append(u)\n\nr = 0\nans = 0\nfor i in range(1, n + 1):\n    if check[i]:\n        continue\n    mx = 0\n    dfs(i)\n    if i <= r:\n        ans += 1\n    r = max(r, mx)\n\nprint(ans)", "import sys\nfrom collections import defaultdict\n\ndef dfs(s, compN):\n    visited[s] = compN\n    queue = set(adj[s])\n    maxV = s\n    while queue:\n        v = queue.pop()\n        if not visited[v]:\n            visited[v] = compN\n            maxV = max(maxV, v)\n            queue.update(adj[v])\n    return maxV\n            \ndef countEdges(adj, n, m):\n    compN = 0\n    comps = []\n    for s in range(1, n + 1):\n        if not visited[s]:\n            compN += 1\n            minV = s\n            maxV = dfs(s, compN)\n            comps.append((minV, compN, 0))\n            comps.append((maxV, compN, 1))\n    \n    comps.sort()\n#     print(comps)\n    opened = set()\n    ctr = 0\n    for v, compN, closed in comps:\n        if closed:\n            opened.remove(compN)\n        else:\n            if opened:\n                ctr += 1\n            opened.add(compN)\n    return ctr\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\nn, m = next(reader)\nadj = defaultdict(list)\nfor _ in range(m):\n    i, j = next(reader)\n    adj[i].append(j)\n    adj[j].append(i)\nvisited = [False] * (n + 1)\nans = countEdges(adj, n, m)\nprint(ans)\n    \n# inf.close()\n", "import sys\nfrom collections import deque\n\nclass UnionFind(object):\n    __slots__ = ['nodes']\n\n    def __init__(self, n: int):\n        self.nodes = [-1]*n\n\n    def find(self, x: int) -> int:\n        if self.nodes[x] < 0:\n            return x\n        else:\n            self.nodes[x] = self.find(self.nodes[x])\n            return self.nodes[x]\n\n    def unite(self, x: int, y: int) -> bool:\n        root_x, root_y, nodes = self.find(x), self.find(y), self.nodes\n\n        if root_x != root_y:\n            if nodes[root_x] > nodes[root_y]:\n                root_x, root_y = root_y, root_x\n            nodes[root_x] += nodes[root_y]\n            nodes[root_y] = root_x\n\n        return root_x != root_y\n\n\nn, m = list(map(int, input().split()))\nuf = UnionFind(n)\nadj = [[] for _ in range(n)]\n\nfor u, v in (list(map(int, sys.stdin.readline().split())) for _ in range(m)):\n    u = u-1\n    v = v-1\n    adj[u].append(v)\n    adj[v].append(u)\n    uf.unite(u, v)\n\n\ng_range = []\nvisited = [0]*n\n\nfor i in range(n):\n    if visited[i] or not adj[i]:\n        continue\n\n    dq = deque([i])\n    visited[i] = 1\n\n    min_v, max_v = i, i\n    v_set = []\n    size = 0\n\n    while dq:\n        v = dq.popleft()\n        min_v = min(min_v, v)\n        max_v = max(max_v, v)\n        v_set.append(v)\n        size += 1\n        for dest in adj[v]:\n            if visited[dest]:\n                continue\n            visited[dest] = 1\n            dq.append(dest)\n\n    g_range.append((min_v, max_v))\n\ng_range.sort()\nans = 0\nchecked_max = 0\n\nfor s, t in g_range:\n    if t <= checked_max:\n        continue\n    for v in range(max(s, checked_max)+1, t):\n        if uf.unite(s, v):\n            ans += 1\n    checked_max = max(checked_max, t)\n\nprint(ans)\n", "# @author \n\nimport sys\n\n\nclass DHarmoniousGraph:\n    def solve(self):\n        from collections import defaultdict\n\n        class Node:\n            def __init__(self, val):\n                self.parent = self\n                self.size = 1\n                self.val = val\n\n        def union(x, y):\n            xRoot, yRoot = find(x), find(y)\n            if xRoot == yRoot:\n                return\n            if xRoot.size >= yRoot.size:\n                yRoot.parent = xRoot\n                xRoot.size += yRoot.size\n            else:\n                xRoot.parent = yRoot\n                yRoot.size += xRoot.size\n\n        def find(x):\n            while x.parent != x:\n                x = x.parent\n            return x\n\n        n, m = [int(_) for _ in input().split()]\n        adj = defaultdict(list)\n        nodes = [Node(i) for i in range(n)]\n        parent = [-1] * n\n        for i in range(m):\n            u, v = [int(_) for _ in input().split()]\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n            union(nodes[u], nodes[v])\n\n        for i in range(n):\n            parent[i] = find(nodes[i]).val\n\n        cc = defaultdict(tuple)\n\n        for g in parent:\n            cc[g] = (float('inf'), -float('inf'))\n\n        for i in range(n):\n            g = parent[i]\n            cc[g] = (min(cc[g][0], i), max(cc[g][1], i))\n\n        ccs = [[g, cc[g][0], cc[g][1]] for g in cc]\n        ccs.sort(key=lambda x:x[1])\n\n        ans = 0\n        done = {g : 0 for g in cc}\n        for g, cur, r in ccs:\n            if done[g]:\n                continue\n            # print(g, cur, r, ans)\n            while cur < r:\n                cur_p = find(nodes[cur])\n                r_p = find(nodes[r])\n                # print(cur, r, cur_p.val, r_p.val)\n                if cur_p != r_p:\n                    ans += 1\n                    done[cur_p.val] = 1\n                    new_r = max(r, cc[cur_p.val][1])\n                    union(nodes[cur], nodes[r])\n                    r = new_r\n\n                cur += 1\n\n        print(ans)\n\nsolver = DHarmoniousGraph()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10**8)\ndef inpl(k=0): return [int(x)+k for x in sys.stdin.readline().split()]\n\nvisited = [False]*(200100)\nlines = defaultdict(set)\n\ndef dfs(s):\n    nonlocal visited\n    visited[s] = True\n    ret = s\n    for t in lines[s]:\n        if visited[t] == False:\n            ret = max(dfs(t), ret)\n    return ret\n\ndef main():\n    nonlocal visited\n    N,M = inpl()\n    for _ in range(M):\n        x,y = inpl(-1)\n        lines[x].add(y)\n        lines[y].add(x)\n    maxr = 0\n    ans = 0\n    for l in range(N):\n        if visited[l] == False:\n            r = dfs(l)\n            if l < maxr:\n                ans += 1\n            maxr = max(r,maxr)\n\n    print(ans)\n\n\ndef __starting_point():\n    threading.stack_size(1024 * 100000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    thread.join()\n\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nP = [-1 for i in range(N)]\ndef par(a):\n    L = []\n    while P[a] >= 0:\n        L.append(a)\n        a = P[a]\n    for l in L:\n        P[l] = a\n    return a\ndef unite(a, b):\n    if par(a) != par(b):\n        if P[par(b)] >= P[par(a)]:\n            if P[par(b)] == P[par(a)]: P[par(a)] -= 1\n            P[par(b)] = par(a)\n        else:\n            P[par(a)] = par(b)\n\nfor _ in range(M):\n    u, v = list(map(int, input().split()))\n    unite(u-1, v-1)\n\nC = [[] for _ in range(N)]\nD = [0] * N\nfor i in range(N):\n    C[par(i)].append(i)\n    D[par(i)] = 1\nma = -1\nans = 0\nfor i in range(N):\n    p = par(i)\n    if D[p] == 0:\n        continue\n    D[p] = 0\n    if min(C[p]) < ma:\n        ans += 1\n    ma = max(ma, max(C[p]))\nprint(ans)\n", "import sys\nimport collections\nimport heapq\nimport math\n \ninput = sys.stdin.readline\n \ndef rints(): return list(map(int, input().strip().split()))\ndef rstr(): return input().strip()\ndef rint(): return int(input().strip())\ndef rintas(): return [int(i) for i in input().strip().split()]\n    \ndef gcd(a, b):       \n    if (b == 0): \n         return a \n    return gcd(b, a%b) \n\nn, m = rints()\ngraphs = collections.defaultdict(list)\nnums = set()\nfor _ in range(m):\n    u, v = rints()\n    graphs[u].append(v)\n    graphs[v].append(u)\n    nums.add(u)\n    nums.add(v)\n\ntimes = list()\nseen = set()\nfor i in nums:\n    if i in seen: continue\n    mn, mx = i, i    \n    queue = []\n    queue.append(i)\n    while queue:\n        cur = queue.pop()\n        if cur in seen: continue\n        seen.add(cur)\n        mn = min(mn, cur)\n        mx = max(mx, cur)\n\n        for k in graphs[cur]:\n            queue.append(k)\n    times.append([mn, mx])\n\ntimes.sort()\nu, v = times[0]\nans = 0\nmerges = list()\n# print(times)\nfor i in range(1, len(times)):\n    i, j = times[i]\n    if i <= v:\n        ans += 1\n        v = max(v, j)\n    else:\n        merges.append([u,v])\n        u, v = i, j\n\nmerges.append([u,v])\n# print(merges)\nfor u, v in merges:\n    for x in range(u, v+1):\n        if x not in seen:\n            ans += 1\nprint(ans)\n", "import sys\nreadline = sys.stdin.readline\nN, M = list(map(int, readline().split()))\n \nEdge = [[] for _ in range(N)]\n \nfor _ in range(M):\n    a, b = list(map(int, readline().split()))\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n \nused = set()\nans = 0\nmp = -1\nfor i in range(N):\n    if i in used:\n        continue\n    if mp >= i:\n        ans += 1\n        Edge[mp].append(i)\n        Edge[i].append(mp)\n        mp = max(mp, i)\n    else:\n        st = i\n    \n    stack = [i]\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf not in used:\n                mp = max(mp, vf)\n                used.add(vf)\n                stack.append(vf)\n \nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n#E=[tuple(map(int,input().split())) for i in range(m)]\n\nGroup=[i for i in range(n+1)]\nNodes=[1]*(n+1)\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        if Nodes[find(x)]<Nodes[find(y)]:\n            \n            Nodes[find(y)]+=Nodes[find(x)]\n            Nodes[find(x)]=0\n            Group[find(x)]=find(y)\n            \n        else:\n            Nodes[find(x)]+=Nodes[find(y)]\n            Nodes[find(y)]=0\n            Group[find(y)]=find(x)\n            \n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    Union(x,y)\n\nMINI=[i for i in range(n+1)]\nfor i in range(n+1):\n    MINI[find(i)]=min(MINI[find(i)],i)\n\nANS=0\n\nMIN=n\nANS=0\n \nfor i in range(n,0,-1):\n    if MIN<MINI[find(i)]:\n        MINI[find(i)]=min(MINI[find(i)],MINI[find(MIN)])\n        Union(MIN,i)     \n        ANS+=1\n \n    else:\n        MIN=MINI[find(i)]\n\n    #print(i,ANS)\n \nprint(ANS)\n", "import sys\ninput = sys.stdin.readline\n\nn,m = list(map(int,input().split()))\nedge = [[] for _ in [0]*n]\nfor i in range(m):\n    u,v = list(map(int,input().split()))\n    edge[u-1].append(v-1)\n    edge[v-1].append(u-1)\n\n#-1:not used -2:used plus:group max\nma = [-1]*n\nfor i in range(n):\n    if ma[i] != -1:\n        continue\n    tank = []\n    new = [i]\n    tmp = i\n    while len(new) > 0:\n        tank = []\n        for e in new:\n            for go in edge[e]:\n                if ma[go] == -1:\n                    ma[go] = -2\n                    tmp = max(tmp,go)\n                    tank.append(go)\n        new = tank\n    ma[i] = tmp\n#print(ma)\nres = 0\np = -1\nfor i in range(n):\n    if ma[i] >= 0:\n        if i < p:\n            res += 1\n        p = max(p,ma[i])\nprint(res)\n", "from sys import stdin\nfrom collections import deque\nfrom math import sqrt, floor, ceil, log, log2, log10, pi\ndef ii(): return int(stdin.readline())\ndef fi(): return float(stdin.readline())\ndef mi(): return map(int, stdin.readline().split())\ndef fmi(): return map(float, stdin.readline().split())\ndef li(): return list(mi())\ndef si(): return stdin.readline()\nn, e=mi()\na=[[] for _ in range(n+1)]\nfor _ in range(e):\n    x, y=mi()\n    a[x].append(y)\n    a[y].append(x)\nv=[1]*(n+1)\nc=0\nm=1\nfor i in range(1, n+1):\n    #print(i, m)\n    if v[i]:\n        s=[i]\n        if i<m:\n            c+=1\n        while s!=[]:\n            x=s.pop()\n            if v[x]:\n                s+=a[x]\n                v[x]=0\n                if x>m:\n                    m=x\nprint(c)", "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split(\" \")]\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split(\" \")]\n        graph[u].append(v)\n        graph[v].append(u)\n    # DFS for connected components in increasing order\n    maxB = -1\n    count = 0\n    visited = [False for v in range(0,n+1)]\n    stack = []\n    for i in range(1, n+1):\n        # connected components\n        if visited[i]:\n            continue\n        if i < maxB:\n            count += 1\n        stack = [i]\n        while (len(stack) > 0):\n            u = stack.pop()\n            for v in graph[u]:\n                if v > maxB:\n                    maxB = v\n                if not visited[v]:\n                    visited[v] = True\n                    stack.append(v)\n    return(count)\n\nprint(main())\n", "import sys\ninput=sys.stdin.readline\ndef root(k):\n    while (k)!=l[k]:\n        k=l[l[k]]\n    return(k)\nn,m=list(map(int, input().split()))\nl=[i for i in range(n+1)]\nsz=[1]*(n+1)\nmaxnode=[i for i in range(n+1)]\nmax_=0\nfor j in range(m):\n    b,c=list(map(int, input().split()))\n    max_=max(max_,(max(b,c)))\n    ro1=root(b)\n    ro2=root(c)\n    if c>maxnode[ro1]:\n        maxnode[ro1]=c\n    if b>maxnode[ro2]:\n        maxnode[ro2]=b\n    if ro1!=ro2:\n        if sz[ro1]>=sz[ro2]:\n            sz[ro1]+=sz[ro2]\n            sz[ro2]=0\n            l[ro2]=ro1\n        else:\n            sz[ro2]+=sz[ro1]\n            sz[ro1]=0\n            l[ro1]=ro2\n#print(l,sz,maxnode)\nend=0\nj=0\nwhile end<(max_):\n    for k in range(end,n):\n        if maxnode[k]>k:\n            kj=maxnode[k]\n            jk=max(maxnode[k:maxnode[k]])\n            #print(jk,kj)\n            while jk>kj:\n                h=jk\n                jk=max((maxnode[kj:jk]))\n                kj=h\n                #print(jk,kj)\n            end=kj\n            break\n    #print(end)\n    for i in range(kj,k-1,-1):\n        if l[root(i)]!=root(k):\n            l[root(i)]=root(k)\n            j+=1\n            #print(l[root(i)],(i),(k),j)\n        #print(l)\nprint(j)\n        \n            \n\n            \n", "import sys\nfrom sys import stdin,stdout\nsys.setrecursionlimit(200001)\nvisit=[]\ndef bfs(adj,i,m):\n    queue = []\n    queue.append(i)\n    visit[i]=1\n    while queue:\n        h = queue.pop()\n        if h>m:\n            m=h\n        visit[h]=1\n        for j in adj[h]:\n            if visit[j]==0:\n                visit[j]=1\n                queue.append(j)\n    return m\n\n# input = sys.stdin.readline()\nn,m = stdin.readline().split()\nn = int(n)\nm = int(m)\nadj = [[] for _ in range(n+1)]\nwhile m>0:\n    x,y = stdin.readline().split()\n    x=int(x)\n    y=int(y)\n    adj[x].append(y)\n    adj[y].append(x)\n    m-=1\nvisit = [0]*(n+1)\nresult=0\ncount=0\nk=0\nfor i in range(1,n+1):\n    if visit[i]==0:\n        if count>0 and i<k:\n            result+=1\n        if visit[i]==0 and len(adj[i])>0:\n            count+=1\n            k = bfs(adj,i,k)\nstdout.write(str(result))\n        \n        \n", "import sys\nfrom sys import stdin,stdout\n# sys.setrecursionlimit(300001)\nvisit=[]\ndef bfs(adj,i,m):\n    queue = []\n    queue.append(i)\n    visit[i]=1\n    while queue:\n        h = queue.pop()\n        if h>m:\n            m=h\n        visit[h]=1\n        for j in adj[h]:\n            if visit[j]==0:\n                visit[j]=1\n                queue.append(j)\n    return m\n\n# input = sys.stdin.readline()\nn,m = stdin.readline().split()\nn = int(n)\nm = int(m)\nadj = [[] for _ in range(n+1)]\nwhile m>0:\n    x,y = stdin.readline().split()\n    x=int(x)\n    y=int(y)\n    adj[x].append(y)\n    adj[y].append(x)\n    m-=1\nvisit = [0]*(n+1)\nresult=0\ncount=0\nk=0\nfor i in range(1,n+1):\n    if visit[i]==0:\n        if count>0 and i<k:\n            result+=1\n        if visit[i]==0 and len(adj[i])>0:\n            count+=1\n            k = bfs(adj,i,k)\nstdout.write(str(result))\n        \n        \n", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd,deque as dq\ndef bfs(vis,u,d):\n    l=[]\n    q=dq([u])\n    while q:\n        u=q.popleft()\n        vis[u]=1\n        l.append(u)\n        for j in d[u]:\n            if(vis[j]==-1):\n                \n                q.append(j)\n    return (min(l),max(l))\nn,m=map(int,input().split())\nd=dd(list)\n\nwhile m:\n    u,v=map(int,input().split())\n    d[u].append(v)\n    d[v].append(u)\n    m-=1\nvis=[-1]*(n+1)\nseg=[]\nfor i in range(1,n+1):\n    if(vis[i]==-1):\n        seg.append(bfs(vis,i,d))\nseg.sort()\nmi=seg[0][0]\nmx=seg[0][1]\ncou=0\nfor i in range(1,len(seg)):\n    if(seg[i][0]>=mi and seg[i][0]<=mx):\n        cou+=1\n        mx=max(seg[i][1],mx)\n    else:\n        mx=max(seg[i][1],mx)\nprint(cou)"]
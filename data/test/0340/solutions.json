["def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nMX = 10 ** 5\n\nn = ii()\nfac = 2\npr = []\nwhile fac * fac <= n:\n    c = 0\n    while n % fac == 0:\n        c += 1\n        n //= fac\n    if c:\n        pr.append((fac, c))\n    fac += 1\nif n > 1:\n    pr.append((n, 1))\nif pr:\n    mx = max(e for p, e in pr)\n    mn = min(e for p, e in pr)\n    mx2 = 1\n    cnt = 0\n    while mx2 < mx:\n        mx2 *= 2\n        cnt += 1\n    ans = cnt + int(mn != mx2)\n    pdt = 1\n    for p, e in pr:\n        pdt *= p\nelse:\n    pdt, ans = 1, 0\nprint(pdt, ans)\n", "n = int(input())\n\nif n == 1:\n\tprint('1 0')\nelse:\n\td = 2\n\tdecomp = []\n\twhile d * d <= n:\n\t\tcnt = 0\n\t\twhile n % d == 0:\n\t\t\tcnt += 1\n\t\t\tn //= d\n\t\tif cnt > 0:\n\t\t\tdecomp += [(d, cnt)]\n\t\tif d == 2:\n\t\t\td += 1\n\t\telse:\n\t\t\td += 2\n\tif n > 1:\n\t\tdecomp += [(n, 1)]\n\n\ttar = 1\n\tmaxExp = 0\n\tfor e in decomp:\n\t\ttar *= e[0]\n\t\tmaxExp = max(maxExp, e[1])\n\t\n\tdivCnt = 0\n\tcurExp = 1\n\twhile curExp < maxExp:\n\t\tdivCnt += 1\n\t\tcurExp *= 2\n\n\tmulRequired = False\n\tfor e in decomp:\n\t\tif e[1] != curExp:\n\t\t\tmulRequired = True\n\t\t\tbreak\n\tif mulRequired:\n\t\tdivCnt += 1\n\n\tprint('%s %s' % (tar, divCnt))\n\n", "n = int(input())\n\nif n == 1:\n    print(1, 0)\n    return\n\nfactors = {}\nmindegree = float(\"inf\")\nmaxdegree = 0\nanswer = 1\n\nfor x in range(2, int(n ** 0.5) + 1):\n    if n == 1: break\n    multiplicity = 0\n    while n % x == 0:\n        n = n // x\n        multiplicity += 1\n    if multiplicity:\n        answer *= x\n        #factors[x] = multiplicity\n        mindegree = min(mindegree, multiplicity)\n        maxdegree = max(maxdegree, multiplicity)\n\nif n != 1:\n    #factors[n] = 1\n    answer *= n\n    mindegree = min(mindegree, 1)\n    maxdegree = max(maxdegree, 1)\n\ndeg = 0\nwhile 2 ** deg < maxdegree:\n    deg += 1\n\nresult = deg + 1\nif 2 ** deg == maxdegree == mindegree:\n    result -= 1\nprint(answer, result)\n", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn = mint()\nc = [0]*1005\nwhile n%2 == 0:\n\tn //= 2\n\tc[2] += 1\ni = 3\nwhile i*i <= n:\n\twhile n%i == 0:\n\t\tn //= i\n\t\tc[i] += 1\n\ti += 2\nm = 0\nr = 1\nfor i in range(len(c)):\n\tm = max(m, c[i])\n\tif c[i] != 0:\n\t\tr *= i\nif n != 1:\n\tm = max(m, 1)\n\tr *= n\nk = 0\ni = 0\nwhile m > (1<<i):\n\ti += 1\nmm = 1<<i\nfor j in range(len(c)):\n\tif c[j] != 0 and mm != c[j]:\n\t\tk = 1\nif n != 1 and mm != 1:\n\tk = 1\nprint(r, i+k)\n", "from math import log, ceil\nn = int(input())\n\nd = {}\n\ndef prime_fac(n):\n    nonlocal d\n    i = 2\n    while i <= n:\n        while n % i == 0 and i <= n:\n            n //= i\n            d[i] = d.get(i, 0) + 1\n        i += 1\n \nif n == 1:\n    print(1, 0)\nelse:\n    prime_fac(n)\n    m = d[max(d, key=lambda x: d[x])]\n    prod = 1\n    for i in d:\n        prod *= i\n    if m in [2**i for i in range(50)] and len(set(d.values())) == 1:\n        print(prod, int(log(m, 2)))\n    else:\n        print(prod, ceil(log(m, 2)) + 1)", "from math import *\ndef fct(n):\n\n  res = []\n  sqfree = 1\n  for p in range(2, int(sqrt(n) + 10)):\n    cnt = 0\n    while n % p == 0:\n      cnt += 1\n      n //= p\n    if cnt > 0:\n      res.append(cnt)\n      sqfree *= p\n\n  if n != 1:\n    res.append(1)\n    sqfree *= n\n  return res, sqfree\n\ndef solve(n):\n  if n == 1: return (1, 0)\n  fctr, sqfree = fct(n)\n  # print(\"fctr = \", fctr)\n  mx = max(fctr)\n  # print(\"mx = \", mx)\n  next_pow2 = 2**ceil(log(mx)/log(2))\n\n  # print(\"next_pow2  = \", next_pow2)\n  times = 0\n  if (any(x != next_pow2 for x in fctr)):\n    times += 1\n\n  while next_pow2 != 1:\n    next_pow2 //= 2\n    times += 1\n\n  return sqfree, times\n\nprint(*solve(int(input())))\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\nre = 1\nmc = 1\nzc = []\nfor i in range(2, 10000):\n    if N%i != 0 : continue\n    re *= i\n    c = 0\n    while N%i==0:\n        N//=i\n        c+=1\n    \n    zc.append(c)\nif N>1:\n    re*=N\n    zc.append(1)\nif zc:\n    mc = max(zc)\nt =1 \nfor i in range(100):\n    if mc<=t:\n        break\n    t*=2\ndprint(t)\ndprint(zc)\ng = i\nfor x in zc:\n    if x<t:\n        g+=1\n        break\n\nprint(re,g)\n\n\n", "n = int(input())\nif n == 1:\n    print(1, 0)\n    return\ncnts = []\ni = 2\nresult = 1\nwhile i * i <= n:\n    if n % i == 0:\n        result *= i\n        c = 0\n        while n % i == 0:\n            c += 1\n            n //= i\n        cnts.append(c)\n    i += 1\nif n > 1:\n    cnts.append(1)\n    result *= n\nm = 0\nif not (cnts.count(cnts[0]) == len(cnts) and cnts[0] & (cnts[0] - 1) == 0):\n    m += 1\n    d = max(cnts)\n    r = 1\n    while r < d:\n        r <<= 1\n        m += 1\nelse:\n    d = max(cnts)\n    while d != 1:\n        m += 1\n        d >>= 1\nprint(result, m)\n        \n", "import sys\nfrom math import sqrt, log, ceil\ninput_file = sys.stdin\n\nn = int(input_file.readline())\n\ndef factor(n):\n    lst = []\n    prod = 1\n    for i in range(2, n+1):\n        if n % i == 0:\n            prod *= i\n            lst.append(0)\n            while n % i == 0:\n                lst[-1] += 1\n                n /= i\n        if n < i:\n            break\n    return lst, prod\n\nif n == 1:\n    print(1, 0)\nelse:\n    lst, ans = factor(n)\n    maxi, mini = max(lst), min(lst)\n    if maxi == mini and log(maxi, 2) == int(log(maxi, 2)):\n        print(ans, int(log(maxi, 2)))\n    else:\n        print(ans, int(ceil(log(maxi, 2)) + 1))\n", "import math\nimport sys\nx=int(input())\n\nif x==1:\n    print(1,0)\n    return\n\nTWO=[2**i for i in range(30)]\n\nxr=math.ceil(math.sqrt(x))\n\nLIST=[]\nfor i in range(2,xr+2):\n    if x%i==0:\n        while x%i==0:\n            LIST.append(i)\n            x=x//i\n    else:\n        i+=1\nif x!=1:\n    LIST.append(x)\n\nfrom collections import Counter\ncounter=Counter(LIST)\n\nANS=1\nfor l in list(counter.keys()):\n    ANS*=l\n\ncount=max(counter.values())\n\nfor i in range(30):\n    if count<=TWO[i]:\n        break\n\nif max(counter.values())==min(counter.values()) and TWO[i]==max(counter.values()):\n    ANS2=i\nelse:\n    ANS2=i+1\n\nprint(ANS,ANS2)\n", "n = int(input())\n\nnum = 1\nmaxPow = 1\nminPow = 9999\n\nfor i in range(2, n + 1):\n  if (n % i == 0):\n    power = 0\n\n    while(n % i == 0):\n      power += 1\n      n = n // i\n\n    num *= i\n\n    maxPow = max(maxPow, power)\n    minPow = min(minPow, power)\n\ni = 1\npower = 0\n\nwhile(i < maxPow):\n  i *= 2\n  power += 1\n\nif(i != maxPow):\n  power += 1\nelif(minPow < maxPow):\n  power += 1\n\nprint(num, power)", "from math import log, ceil\nd = {}\nn = int(input())\nif n == 1:\n    print('1 0')\n    return\ni = 2\nwhile True:\n    if i > n:\n        break\n    if n % i == 0:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n        n //= i\n    else:\n        i += 1\n\nmaxpow = max(d.values())\nminpow = min(d.values())\nans = int(ceil(log(maxpow, 2)))\nif maxpow & (maxpow - 1) != 0:\n    ans += 1\nelif minpow != maxpow:\n    ans += 1\nvalue = 1\nfor i in d.keys():\n    value *= i\nprint(value, ans)", "primes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]\nsisu=[0]*168\nnn=int(input())\nn=int(nn)\nfor i in range(168):\n    while True:\n        if n%primes[i]==0:\n            n//=primes[i]\n            sisu[i]+=1\n        else:\n            break\nans=1\nmaxsisu=0\nif n>1:\n    sisu.append(1)\n    primes.append(n)\nfor i in range(len(sisu)):\n    if sisu[i]>0:\n        maxsisu=max(maxsisu,sisu[i])\n        ans*=primes[i]\ncomp=1\nans2=0\nwhile comp<maxsisu:\n    comp*=2\n    ans2+=1\nfor i in range(len(sisu)):\n    if sisu[i]>0 and sisu[i]!=comp:\n        ans2+=1\n        break\nprint(ans,ans2)\n", "# use this as the main template for python problems\nfrom collections import Counter\nimport math\n\ndef primeFactors(n): \n      \n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        yield 2\n        n = n / 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            yield i\n            n = n / i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        yield n\n\ndef get_prime_factorization(n):\n    if(n == 1):\n        return {1 : 1}\n    primes = {}\n    for prime in primeFactors(n):\n        prime = int(prime)\n        if(prime in primes):\n            primes[prime] += 1\n        else:\n            primes[prime] = 1\n    return primes\n\ndef next_power_of_2(n):\n    return int(math.pow(2, math.ceil(math.log(n)/math.log(2))))\n\ndef solution(n):\n\n    pf = get_prime_factorization(n)\n    \n    lp = 0  \n    for key, val in list(pf.items()):\n        lp = max(lp, val)\n   \n    # lp is the largest power in the prime factorization\n    # we need the nearest power of two\n    np2 = next_power_of_2(lp)\n    ans = 1\n    for key, val in list(pf.items()):\n        ans *= key\n    \n    moves = 0\n    for key, val in list(pf.items()):\n        if(val != np2):\n            moves = 1\n            break\n    moves += int(math.log2(np2))\n\n    print(ans, moves)\n\n\n\ndef __starting_point():\n\n    # single variables\n    n = [int(val) for val in input().split()][0]\n\n    # solve it!\n    solution(n)\n\n\n__starting_point()", "n = int(input())\nprimes = {}\nfor i in range(2, n):\n\twhile n%i == 0:\n\t\tn /= i \n\t\tif i in primes:\n\t\t\tprimes[i] += 1\n\t\telse:\n\t\t\tprimes[i] = 1\nif len(primes) == 0:\n\tprint(n, 0)\n\treturn\nfrom math import ceil, log2\npow2 = pow(2, ceil(log2(max(primes.values()))))\nflag = 0\nfor i in primes:\n\tif primes[i] != pow2:\n\t\tflag = 1\n\t\tbreak\nans = 1\nfor i in primes:\n\tans*=i\nprint(ans, int(log2(pow2)) + flag)", "def user99():\n    n = int(input())\n    nn = n\n\n    N = 10**6\n    prime = [True] * N\n    prime[0] = prime[1] = False;\n\n    for i in range(2, N, 1):\n        if i * i > N: break\n        if prime[i]:\n            for j in range(i * i, N, i):\n                prime[j] = False\n\n    primes = []\n    for i in range(N):\n        if prime[i]:\n            primes.append(i)\n\n    b = []\n    for p in primes:\n        if n % p != 0: continue\n        power = 0\n        while n % p == 0:\n            n //= p\n            power += 1\n        b.append([p, power])\n\n    steps, x = 0, 1\n\n    max_power = 0\n    for i in b:\n        max_power = max(max_power, i[1])\n        x *= i[0]\n\n    for i in range(10):\n        if max_power <= 2**i:\n            max_power = 2**i\n            steps = i\n            break\n\n    if x**(2**steps) != nn:\n        steps += 1\n\n    print(x, steps)\n\nuser99()", "def factor(n):\n\n    def factor_n(m):\n        for q in range(2, m + 1):\n            if m % q == 0:\n                return q\n            if q > m**(1/2):\n                return m\n\n    factors = {}\n    while True:\n        factor_naw = factor_n(n)\n        n //= factor_naw\n        factors[factor_naw] = factors.get(factor_naw, 0)+1\n        if n == 1:\n            break\n    return factors\n\n\nn = int(input())\nif n == 1:\n    print(n, 0)\nelse:\n    a = factor(n)\n    s = max(a.values())\n    if s == 1:\n        print(n, 0)\n    else:\n        q1, q2 = 1, 0\n        while q1 < s:\n            q1 *= 2\n            q2 += 1\n        answer = 1\n        for q in a:\n            answer *= q\n        p = set(a.values())\n        print(answer, q2+1 if len(set(a.values())) != 1 or 2**q2 != s else q2)\n", "from functools import reduce\n\ndef main():\n\tn = int(input())\n\n\tif n == 1:\n\t\tprint(1, 0)\n\t\treturn\n\t\n\tfact = dict()\n\td = 2\n\tc = 0\n\twhile n % d == 0:\n\t\tc += 1\n\t\tn //= d\n\tif c > 0:\n\t\tfact[d] = c\n\t\n\td = 3\n\twhile n != 1:\n\t\tc = 0\n\t\twhile n % d == 0:\n\t\t\tc += 1\n\t\t\tn //= d\n\t\tif c > 0:\n\t\t\tfact[d] = c\n\t\td += 2\n\n\tans = reduce(lambda x,y: x*y, fact.keys())\n\tmaxPow = max(fact.values())\n\n\tx = 0\n\twhile maxPow > (1 << x):\n\t\tx += 1\n\n\tif maxPow == (1 << x) and all([y == maxPow for y in fact.values()]):\n\t\tprint(ans, x)\n\t\treturn\n\telse:\n\t\tprint(ans, x + 1)\n\t\treturn\n\ndef __starting_point():\n\tmain()\n__starting_point()", "def tp(n):\n    k=1\n    while k<n:\n        k*=2\n    return k\nn=int(input())\na=[]\nz=1\nif n==1:\n    print(1,0);return\nfor i in range(2,int(n**.5)+1):\n    r=0\n    if n%i==0:\n        z*=i\n    while n%i==0:\n        n//=i\n        r+=1\n    if r>0:\n        a.append(r)\nif n>1:\n    a.append(1)\n    z*=n\nl=max(a)\nk=tp(l)\nmo=0\nfl=0\nfor i in a:\n    if i!=k:\n        fl=1\n        break\nwhile k!=1:\n    k//=2\n    mo+=1\nif fl:\n    print(z,mo+1)\nelse:\n    print(z,mo)\n\n\n\n    ", "from math import log, ceil\n\n\ndef factor1(n):\n    num = 2\n    res = set()\n    while num ** 2 <= n:\n        while n % num == 0:\n            res.add(num)\n            n = n // num\n        num += 1\n    if n > 1:\n        res.add(n)\n    ans = 1\n    for x in res:\n        ans *= x\n    return ans\n\n\ndef factor(n):\n    num = 2\n    res = dict()\n    while num ** 2 <= n:\n        while n % num == 0:\n            res[num] = res.get(num, 0) + 1\n            n = n // num\n        num += 1\n    if n > 1:\n        res[n] = res.get(n, 0) + 1\n    return res\n\n\nn = int(input())\nmin_ = factor1(n)\nkek = sorted(factor(n).values())\nif min_ == n:\n    print(n, 0)\nelif kek[0] == kek[-1] and log(kek[-1], 2) // 1 == log(kek[-1], 2):\n    print(min_, int(log(kek[-1], 2)))\nelse:\n    print(min_, ceil(log(kek[-1], 2)) + 1)\n", "def natlog(mx):\n    maxpower = 0\n    while mx > 1:\n        mx = (mx+1) // 2\n        maxpower += 1\n    return maxpower\n\nfrom collections import Counter\nn = int(input())\n\nif n == 1:\n    print(1, 0)\n    return\n\nj = 2\nsetres  = Counter()\n\nwhile n>1:\n    if n % j == 0:\n        n = n//j\n        setres[j] += 1\n    else:\n        j+= 1\n\nres = 1\nfor j in setres:\n    res *= j\n# print(res, setres, setres.most_common(1))\nmaxpower = natlog(setres.most_common(1)[0][1])\nmaxnum = 2**maxpower\n\ncnt_actions = maxpower\n\nfor j, p in list(setres.items()):\n    if p < maxnum:\n        cnt_actions += 1\n        break\n\nprint(res, cnt_actions)\n", "\ndef main():\n    buf = input()\n    n = int(buf)\n    op_count = 0\n    factor = prime_factorization(n)\n    c_max = 1\n    first_c = None\n    all_same = True\n    min_number = 1\n    for f, c in list(factor.items()):\n        if c > c_max:\n            c_max = c\n        if first_c == None:\n            first_c = c\n        elif c != first_c:\n            all_same = False\n        min_number *= f\n    if check_power_of_2(c_max) and all_same:\n        pass\n    else:\n        op_count += 1\n    if not check_power_of_2(c_max):\n        c_max = c_max << 1\n        c_max = c_max & (c_max - 1)\n    while c_max > 1:\n        c_max //= 2\n        op_count += 1\n    print(min_number, op_count)\n\n\ndef check_power_of_2(x):\n    return (x != 0) and ((x & (x - 1)) == 0)\n\ndef prime_factorization(number):\n    n = number\n    i = 2\n    factor = {}\n    while i * i <= n:\n        while n % i == 0:\n            if i in factor:\n                factor[i] += 1\n            else:\n                factor.update({i : 1})\n            n //= i\n        i += 1\n    if n > 1 or not factor:\n        if n in factor:\n            factor[n] += 1\n        else:\n            factor.update({n : 1})\n    return factor\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nfac = {}\nnn = n\nmaxe = 1\nwhile nn%2 == 0:\n    fac[2] = fac.get(2, 0) + 1\n    nn >>= 1\nfor i in range(3, nn+1, 2):\n    if i*i > nn:\n        break\n    while nn%i == 0:\n        fac[i] = fac.get(i, 0) + 1\n        nn //= i\nif nn > 1:\n    fac[nn] = 1\n# print(nn)\n# print(fac)\n\nmaxe = 1\nmine = n\nprod = 1\nfor f in fac:\n    if fac[f] > maxe:\n        maxe = fac[f]\n    if fac[f] < mine:\n        mine = fac[f]\n    prod *= f\nops = 0\nt = 1\nwhile t < maxe:\n    t <<= 1\n    ops += 1\nif mine < t:\n    ops += 1\nprint(prod, ops)\n"]
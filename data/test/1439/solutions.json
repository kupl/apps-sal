["__author__ = 'User'\nn, m = list(map(int, input().split()))\narr = list(map(int, input().split()))\nfor i in range(n):\n    arr[i] = arr[i] % m\nd = [0] * m\nfor e in arr:\n    t = [0] * m\n    t[e] = 1\n    for i in range(m):\n        if d[i] == 1:\n            #print(\"T\", i + e)\n            t[(i + e) % m] = 1\n    for i in range(m):\n        if t[i] == 1:\n            d[i] = 1\n    #print(d)\n    if d[0] == 1:\n        break\nif d[0] == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n#print(d)\n#print(arr)\n", "(n,m)=map(int,input().split())\nif n>2*m:print(\"YES\")\nelse:\n\tt=[0 for i in range(m)]\n\ts=input().split()\n\tfor i in range(len(s)):\n\t\th=int(s[i])%m\n\t\tv=[0 for i in range(m)]\n\t\tfor j in range(m):\n\t\t\tif t[j]==1:v[(h+j)%m]=1\n\t\tfor j in range(m):\n\t\t\tif v[j]==1:t[j]=1\n\t\tt[h]=1\n\tif t[0]==1:print(\"YES\")\n\telse:print(\"NO\")", "from copy import deepcopy\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nif n > m:\n    print('YES')\nelse:\n    d = [False for i in range(m)]\n    b = [False for i in range(m)]\n    for i in range(n):\n        for j in range(m):\n            if d[j] == True:\n                b[(j + a[i]) % m] = True\n        b[a[i] % m] = True\n        for j in range(m):\n            if b[j] == True:\n                d[j] == True\n        d = deepcopy(b)\n    if d[0] == True:\n        print('YES')\n    else:\n        print('NO')\n", "def main():\n    n, m = map(int, input().split())\n    mas = list(map(int, input().split()))\n    \n    remains = set()\n    \n    for i in range(n):\n        for_add = set()\n        for e in remains:\n            if (e + mas[i]) % m == 0:\n                return True\n            else:\n                for_add.add((e + mas[i]) % m)\n        \n        if mas[i] % m == 0:\n            return True\n        else:\n            for_add.add(mas[i])\n            \n        remains |= for_add\n\nif main():\n    print(\"YES\")\nelse:\n    print(\"NO\")", "#import sys\n#sys.stdin = open(\"python/in\", \"r\")\n\n#n = int(input().split(\" \"))\nn, m = [int (i) for i in input().split(\" \")]\narr = [int (i) % m for i in input().split(\" \")]\n\nc = {}\nfor i in range(m):\n    c[i] = False\n\nstack = [0]\nnewstack = []\n\nfor i in arr:\n    for j in stack:\n        arrrrgh = (i+j) % m\n        if (arrrrgh == 0):\n            print (\"YES\")\n            return\n        elif (c[arrrrgh] == False):\n            newstack.append(arrrrgh)\n            c[arrrrgh] = True\n    stack = stack + newstack\n    newstack = []\n\nprint(\"NO\")\n", "n, m = (int(x) for x in input().split())\nlst = [int(x) for x in input().split()]\ncnt = [0 for i in range(m)]\n\nif n > m:\n\tprint(\"YES\")\n\treturn\n\nfor x in lst:\n\tcnt[x % m] += 1\n\ntbl = [[False for j in range(n + 1)] for i in range(m)]\n\n#print(tbl)\n\ntbl[0][0] = True\n\nfor j in range(1, n + 1):\n\tfor i in range(m):\n\t\ttbl[i][j] = tbl[i][j-1]\n\n\tfor i in range(m):\n\t\t#print(i, j)\n\t\tif tbl[i][j - 1]:\n\t\t\tif (i + lst[j - 1]) % m == 0:\n\t\t\t\tprint(\"YES\")\n\t\t\t\treturn \n\t\t\ttbl[(i + lst[j - 1]) % m][j] = True \n\nprint(\"NO\")\n", "n, m = [int(i) for i in input().split()]\nr = [False] * m\nfor x in [int(i)%m for i in input().split()]:\n    c = r.copy()\n    c[x] = True\n    for i in range(m):\n        if r[i]:\n            c[(i+x)%m] = True\n    r = c.copy()\n    if r[0]:\n        print(\"YES\")\n        return\nprint(\"NO\")", "__author__ = 'dwliv_000'\n(n,m)=(int(i) for i in input().split())\nc=[int(i)%m for i in  input().split()]\nz=[False]*m\nfor j in c:\n    q=z[:]\n    q[j]=True\n    for i in range(m):\n        if(z[i]):\n            q[(i+j)%m]=True\n    z=q[:]\n    if z[0]:\n        print('YES')\n        return\nprint('NO')\n\n", "n,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nif n>m: print(\"YES\")\nelse:\n    d=[{},{}]\n    cur=0\n    for x in l:\n        for y in list(d[cur].keys()): \n            d[1-cur][y]=1\n            d[1-cur][(y+x)%m]=1\n        cur=1-cur\n        d[cur][x%m]=1\n        if d[cur].get(0,0): break\n    print(\"YES\" if d[cur].get(0,0) else \"NO\")\n", "#!/usr/bin/env python\n# 577B_modulo.py - Codeforces.com/problemset/problem/577/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Modulo Class (Main Program)\n###############################################################################\n\n\nclass Modulo:\n    \"\"\" Modulo representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n        # Modulo\n        self.modnums = [v % self.m for v in self.nums]\n\n        # Frequency counter\n        self.cnt = {}\n        self.vars = {}\n        for v in self.modnums:\n            if v not in list(self.cnt.keys()):\n                self.cnt[v] = 0\n                self.vars[v] = []\n            self.cnt[v] += 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        # For multiples\n        for v in list(self.vars.keys()):\n            cur = v\n            for j in range(self.cnt[v]):\n                if j > (v * self.m):\n                    break\n                self.vars[v].append(cur)\n                if cur == 0:\n                    return \"YES\"\n                cur = (cur + v) % self.m\n\n        # Collect sum\n        cur = set([0])\n        for var in list(self.vars.keys()):\n            for s in set(cur):\n                for v in self.vars[var]:\n                    if v == 0:\n                        return \"YES\"\n                    res = v + s\n                    if res == self.m:\n                        return \"YES\"\n                    cur.add(res % self.m)\n\n        return \"NO\"\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Modulo class testing \"\"\"\n\n        # Constructor test\n        test = \"3 5\\n1 2 3 3\"\n        d = Modulo(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 5)\n        self.assertEqual(d.nums, [1, 2, 3, 3])\n\n        # Sample test\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        # Sample test\n        test = \"1 6\\n5\"\n        self.assertEqual(Modulo(test).calculate(), \"NO\")\n\n        # Sample test\n        test = \"4 6\\n3 1 1 3\"\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        # My tests\n        test = \"6 6\\n5 5 5 5 5 5\"\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        test = \"4 5\\n1 1 1 1\"\n        self.assertEqual(Modulo(test).calculate(), \"NO\")\n\n        # Time limit test\n        self.time_limit_test(1000000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(405) + \"\\n\"\n        nums = [random.randint(1, 10000000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Modulo(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Modulo().calculate())\n\n__starting_point()", "n, m = list(map(int, input().split()))\n\nseen = set()\nfor a in map(int, input().split()):\n    new = set()\n    for b in seen:\n        new.add((a+b) % m)\n    seen |= new\n    seen.add(a % m)\n    if 0 in seen:\n        print('YES')\n        break\nelse:\n    print('NO')\n", "#!/usr/bin/env python3\n\"\"\"\nCodeforces Round #319 (Div. 2)\n\nProblem 577 B. Modulo Sum\n\n@author yamaton\n@date 2015-09-10\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\ndef solve(xs, m):\n    modulos = set()\n    for x in xs:\n        modulos |= {(x + i) % m for i in modulos}\n        modulos.add(x % m)\n        if 0 in modulos:\n            return True\n    else:\n        return False\n\ndef tf_to_yn(tf):\n    return 'YES' if tf else 'NO'\n\n\ndef print_stderr(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    [n, m] = [int(i) for i in input().strip().split()]    \n    xs = [int(i) for i in input().strip().split()]\n    assert len(xs) == n\n\n    result = solve(xs, m)\n    print(tf_to_yn(result))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def dp(n,m):\n    mark = [0 for i in range(m)]\n    a = list(map(int,input().split()))\n    for x in a:\n        for i in range(m):\n            if(mark[i]==1):\n                k=(i+x%m)%m\n                if(mark[k]!=1):\n                    mark[k]=2\n        for i in range(m):\n            if(mark[i]>0):\n                mark[i]=1\n        mark[x%m]=1\n    return mark[0]\nimport sys\ninput = sys.stdin.readline\nn,m = list(map(int,input().split()))\nflag = True\nif(n<=m):\n    flag=(dp(n,m)!=0)\nif(flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "#!/usr/bin/env python\n# 577B_modulo.py - Codeforces.com/problemset/problem/577/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Modulo Class (Main Program)\n###############################################################################\n\n\nclass Modulo:\n    \"\"\" Modulo representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n        # Modulo\n        self.modnums = [v % self.m for v in self.nums]\n\n        # Frequency counter\n        self.cnt = {}\n        self.vars = {}\n        for v in self.modnums:\n            if v not in list(self.cnt.keys()):\n                self.cnt[v] = 0\n                self.vars[v] = set([])\n            self.cnt[v] += 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        # For multiples\n        for v in list(self.vars.keys()):\n            cur = v\n            for j in range(self.cnt[v]):\n                if cur in self.vars[v]:\n                    break\n                self.vars[v].add(cur)\n                if cur == 0:\n                    return \"YES\"\n                cur = (cur + v) % self.m\n\n        # Collect sum\n        cur = set([0])\n        for var in list(self.vars.keys()):\n            for s in set(cur):\n                for v in self.vars[var]:\n                    res = v + s\n                    if res == self.m:\n                        return \"YES\"\n                    cur.add(res % self.m)\n\n        return \"NO\"\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Modulo class testing \"\"\"\n\n        # Constructor test\n        test = \"3 5\\n1 2 3 3\"\n        d = Modulo(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 5)\n        self.assertEqual(d.nums, [1, 2, 3, 3])\n\n        # Sample test\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        # Sample test\n        test = \"1 6\\n5\"\n        self.assertEqual(Modulo(test).calculate(), \"NO\")\n\n        # Sample test\n        test = \"4 6\\n3 1 1 3\"\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        # My tests\n        test = \"6 6\\n5 5 5 5 5 5\"\n        self.assertEqual(Modulo(test).calculate(), \"YES\")\n\n        test = \"4 5\\n1 1 1 1\"\n        self.assertEqual(Modulo(test).calculate(), \"NO\")\n\n        # Time limit test\n        self.time_limit_test(10000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(990) + \"\\n\"\n        nums = [random.randint(2, 990) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Modulo(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Modulo().calculate())\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    l = [False] * m\n    l1 = l.copy()\n    for i in map(int, input().split()):\n        i %= m\n        l1[i] = True\n        for j, f in enumerate(l, i - m):\n            if f:\n                l1[j] = True\n        if l1[0]:\n            print(\"YES\")\n            return\n        l = l1.copy()\n    print(\"NO\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    l = [False] * m\n    l1 = l.copy()\n    for i in map(int, input().split()):\n        i %= m\n        l1[i] = True\n        for j, f in enumerate(l, i - m):\n            if f:\n                l1[j] = True\n        if l1[0]:\n            print(\"YES\")\n            return\n        for j, f in enumerate(l1):\n            if f:\n                l[j] = True\n    print(\"NO\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n , m = list(map(int, input().split()))\nlst = list(map(int, input().split()))\nans = set()\nfor i in lst:\n    if ans:\n        for j in ans.copy():\n            ans.add((i + j) % m)\n            ans.add(i % m)\n            \n    else:\n        ans.add(i % m)\n    if 0 in ans:\n        print('YES')\n        break\nelse:\n    print('NO')\n    \n", "n , m = list(map(int, input().split()))\nlst = list(map(int, input().split()))\nans = set()\nfor i in lst:\n    if ans:\n        for j in ans.copy():\n            ans.add((i + j) % m)\n            ans.add(i % m)\n            \n    else:\n        ans.add(i % m)\n    if 0 in ans:\n        print('YES')\n        break\nelse:\n    print('NO')\n    \n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nrem = set()\nfor i in a:\n    new = {(i + j) % m for j in rem | {0}}\n    rem |= new\n    if 0 in rem:\n        print('YES')\n        return\nprint('NO')\n", "def main():\n    n, m = [int(i) for i in input().split()]\n    if n > m:\n        print(\"YES\")\n        return\n    a = [int(i) % m for i in input().split()]\n    d = [False] * m\n    for i in a:\n        next = d[:]\n        for j in range(m):\n            k = j + i\n            if k >= m: k -= m\n            next[k] = d[k] or d[j]\n        d = next\n        d[i] = True\n    if d[0]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    \n    \n    \nmain()\n", "#!/usr/bin/env python3\nimport sys\n\nN, M = input().split()\nA = list(map(int, input().split()))\nN = int(N)\nM = int(M)\n\nif N > M:\n  print('YES')\n  return\n\nsys.setrecursionlimit(2000)\n\nQ_memo = {}\n\nfor i, a in enumerate(A):\n  A[i] = A[i] % M\n\ndef Q(i, K, empty_sequence_ok):\n  # true if there exists a subset of (A[0]...A[i]) that sums to K\n\n  # print('Q(%d, %d, %r)' % (i, K, empty_sequence_ok))\n\n  if empty_sequence_ok and K == 0: return True\n  if i == 0: return A[0] == K\n\n  args = (i, K, empty_sequence_ok)\n  if args not in Q_memo:\n    Q_memo[args] = Q(i - 1, K, empty_sequence_ok) or Q(i - 1, (K - A[i]) % M, True)\n  return Q_memo[args]\n\nif Q(N-1, 0, False):\n  print('YES')\nelse:\n  print('NO')", "n, m = (int(i) for i in input().split())\nnumbers = [int(i) for i in input().split()]\nresults = {0}\n\nres_update = results.update\n\nfor i in numbers:\n    tmp_results = set()\n    for j in results:\n        if (j+i) % m == 0:\n            print('YES')\n            return\n        tmp_results.add((j+i) % m)\n    res_update(tmp_results)\nprint('NO')\n\n\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\nrem = set()\nfor i in a:\n    new = {(i + j) % m for j in rem | {0}}\n    rem |= new\n    if 0 in rem:\n        print('YES')\n        return\nprint('NO')", "\n# -*- coding: utf-8 -*-\n\nn, m = list(map(int,input().split()))\np = [0]*m\nfor x in map(int,input().split()):\n    n = p[:]\n    n[x%m] = 1\n    for i in range(m):\n        if p[i] == 1:\n            n[(i+x)%m] = 1\n    p = n\n    if p[0]:\n        print('YES')\n        return\n\nprint('NO')\n\n", "n, m = list(map(int, input().split()))\na = list([x%m for x in list(map(int, input().split()))])\nh = {}\n\nfor el in a:\n    h[el] = h.get(el, 0) + 1\n\nfor v in list(h.values()):\n    if v % m == 0:\n        print(\"YES\")\n        return\n\npossible = set([])\nfor el in a:\n    new = set([el])\n    for candidate in possible:\n       new.add((candidate + el)%m)\n\n    possible |= new\n    if 0 in possible:\n        print(\"YES\")\n        return\nprint(\"NO\")\n"]
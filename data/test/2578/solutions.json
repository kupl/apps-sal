["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nFR=[list(map(int,input().split())) for i in range(m)]\n\n#UnionFind\n\nGroup=[[i,1] for i in range(n+1)]\n\ndef find(x):\n    while Group[x][0] != x:\n        x=Group[x][0]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        SUM=Group[find(y)][1]+Group[find(x)][1]\n        Group[find(y)][0]=Group[find(x)][0]=min(find(y),find(x))\n        Group[find(y)][1]=SUM\n\n        \n\nfor j in range(m):\n    if len(FR[j])<=2:\n        continue\n    for k in range(2,len(FR[j])):\n        Union(FR[j][k],FR[j][k-1])\n\nANS=[]\nfor i in range(1,n+1):\n    ANS.append(Group[find(i)][1])\n\nprint(*ANS)\n", "import sys\ninput = iter(sys.stdin.read().splitlines()).__next__\n\nclass mergefind:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n\n    def find(self,a):\n        to_update = []\n       \n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n       \n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a==b:\n            return\n\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\nn,m = list(map(int,input().split()))\nmf = mergefind(n)\n\nfor _ in range(m):\n    sz,*A = [int(x)-1 for x in input().split()]\n    sz += 1\n\n    for i in range(1,sz):\n        prev,cur = A[i-1],A[i]\n        mf.merge(prev,cur)\n\nprint(*[mf.set_size(i) for i in range(n)])\n", "import sys\n\nn, m = map(int, input().split())\npar = [0] * (n + 1)\ncnt = [0] * (n + 1)\nfor i in range(n + 1):\n  par[i] = i\n\ndef find(a):\n  if par[a] == a:\n    return a\n  par[a] = find(par[a])\n  return par[a]  \n\nfor i in sys.stdin.readlines():\n  x = list(map(int, i[:-1].split()))\n  if x[0]:\n    ta = find(x[1])\n    for i in x[2:]:\n      tb = find(i)\n      if ta != tb:\n        par[tb] = ta\n\nfor i in range(n + 1):\n  cnt[find(i)] += 1\n\nans = []\nfor i in range(1, n + 1):\n  ans.append(str(cnt[par[i]]))\nprint(' '.join(ans))", "import sys\nclass UF():\n    def __init__(self, num):\n        self.par = [-1]*num\n        self.size = [1]*num\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry] \n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    G = UF(N)\n    for _ in range(M):\n        L = list(map(int, sys.stdin.readline().split()))\n        if L[0] > 1:\n            l = L[1]\n            for r in L[2:]:\n                G.union(l-1, r-1)\n    Ans = [0]*N\n    for i in range(N):\n        Ans[i] = G.size[G.find(i)]\n    print(*Ans)\ndef __starting_point():\n    solve()\n__starting_point()", "# stdin=open('input.txt')\nfrom sys import stdin, stdout\ndef input():\n\treturn stdin.readline()[:-1]\n\n\n# # stdout=open('output.txt',mode='w+')\n\n# # def print(x, end='\\n'):\n# # \tstdout.write(str(x) +end)\n\n\n# # a, b = map(int, input().split())\n\n# # l = list(map(int, input().split()))\n\n\n\n\n\n\n\n# CODE BEGINS HERE.................\nimport math\n\nclass disjoint_set:\n\tdef __init__(self, n):\n\t\tself.parent = [i for i in range(n)]\n\t\tself.size = [1] * n\n\tdef union(self, a, b):\n\t\tp1 = self.find(a)\n\t\tp2 = self.find(b)\n\n\t\tif p1 == p2:\n\t\t\treturn False\n\t\tif self.size[p1] > self.size[p2]:\n\t\t\tself.parent[p2] = p1\n\t\t\tself.size[p1] += self.size[p2]\n\t\telse:\n\t\t\tself.parent[p1] = p2\n\t\t\tself.size[p2] += self.size[p1]\n\n\tdef find(self, x):\n\t\tans = x\n\t\twhile ans != self.parent[ans]:\n\t\t\tans = self.parent[ans]\n\t\ttemp = x\n\t\twhile temp != self.parent[temp]:\n\t\t\ttemp2 = self.parent[temp]\n\t\t\tself.parent[temp] = ans\n\t\t\ttemp = temp2\n\t\treturn ans\n\n\nn, m = map(int, input().split())\nds = disjoint_set(n)\nfor i in range(m):\n\tl = list(map(int, input().split()))\n\tfor i in range(2, l[0] + 1):\n\t\tds.union(l[i - 1] - 1, l[i] - 1)\n\n\nfor i in range(n):\n\tprint(ds.size[ds.find(i)], end = ' ')\nprint('')\n\n#CODE ENDS HERE....................\n\n#stdout.close()\n\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n\n    def find(self, a):\n        to_update = []\n\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n\n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a == b:\n            return\n\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n, m = read_int_array()\n    uf = UnionFind(n)\n    for _ in range(m):\n        nums = read_int_array()\n        sz = nums[0]\n        leader = None\n        for i in range(sz):\n            p = nums[1 + i] - 1\n            if leader is None:\n                leader = p\n            else:\n                uf.merge(p, leader)\n\n    ans = [uf.set_size(i) for i in range(n)]\n    write(*ans)\n\nmain()\n", "from collections import deque\nimport sys\nn,m=list(map(int,sys.stdin.readline().split()))\na=[[] for i in range(n+1)]\nd=deque([])\nfor i in range(m):\n    b=list(map(int,sys.stdin.readline().split()))\n    for j in b[2:]:\n        a[b[1]].append(j)\n        a[j].append(b[1])\n\nans=[1]*(n+1)\nvis=[0]*(n+1)\n\nfor i in range(1,n+1):\n    if vis[i]==0:\n        vis[i]=1\n        d.append(i)\n    b=[]  \n    while(d):\n        # print(d,vis)\n        p=d.popleft()\n        b.append(p)\n        for j in (a[p]):\n            if vis[j]==0:\n                d.append(j)\n                vis[j]=1\n    l=len(b)            \n    # print(b)\n    for j in b:\n        ans[j]=l\nprint(*ans[1:])\n    \n\n        \n        \n\n\n", "from sys import stdin\ninput=stdin.readline\nn,m=map(int,input().split())\na=[[] for i in range(n)]\nfor i in range(m):\n    b=list(map(int,input().split()))\n    for j in range(2,b[0]+1):\n        a[b[j]-1].append(b[j-1]-1)\n        a[b[j-1]-1].append(b[j]-1)\nvis=[0]*n\nans=[0]*n\nfor i in range(n):\n    if vis[i]==0:\n        st=[i]\n        c=0\n        while st:\n            x=st.pop()\n            vis[x]=1\n            c+=1\n            for j in a[x]:\n                if vis[j]==0:\n                    vis[j]=1\n                    st.append(j)\n        st=[i]\n        ans[i]=c\n        while st:\n            x=st.pop()\n            for j in a[x]:\n                if ans[j]==0:\n                    ans[j]=c\n                    st.append(j)\nprint(*ans)", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n\nn, q = list(map(int, input().split()))\nquery = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\ntree = Union_Find(n)\nfor a in query:\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nans = [tree.size[tree.find(i+1)] for i in range(n)]\nprint(\" \".join(map(str, ans)))\n", "import sys\n\n\nclass Node:\n    def __init__(self, val):\n        self.parent = self\n        self.size = 1\n\n\ndef union(x, y):\n    xRoot, yRoot = find(x), find(y)\n    if xRoot == yRoot:\n        return\n    if xRoot.size >= yRoot.size:\n        yRoot.parent = xRoot\n        xRoot.size += yRoot.size\n    else:\n        xRoot.parent = yRoot\n        yRoot.size += xRoot.size\n\n\ndef find(x):\n    while x.parent != x:\n        x = x.parent\n    return x\n\n\nn, m = [int(item) for item in sys.stdin.readline().strip().split()]\nnode = [Node(x) for x in range(n + 1)]\ngroups = [[int(item) for item in sys.stdin.readline().strip().split()]\n          for _ in range(m)]\nfor g in range(m):\n    group = groups[g]\n    k = group[0]\n    if k == 0:\n        continue\n    for i in range(2, k + 1):\n        union(node[group[i]], node[group[i - 1]])\n\n\nans = [find(node[x]).size for x in range(1, n + 1)]\n\nsys.stdout.write(' '.join(str(x) for x in ans) + '\\n')\n", "import sys\n\n\nclass Node:\n    def __init__(self, val):\n        self.parent = self\n        self.size = 1\n        self.rank = 0\n\n\ndef union(x, y):\n    xRoot, yRoot = find(x), find(y)\n    if xRoot == yRoot:\n        return\n    if xRoot.rank > yRoot.rank:\n        yRoot.parent = xRoot\n        xRoot.size += yRoot.size\n    elif xRoot.rank < yRoot.rank:\n        xRoot.parent = yRoot\n        yRoot.size += xRoot.size\n    else:\n        yRoot.parent = xRoot\n        xRoot.rank = xRoot.rank + 1\n        xRoot.size += yRoot.size\n\n\ndef find(x):\n    while x.parent != x:\n        x = x.parent\n    return x\n\n\nn, m = [int(item) for item in sys.stdin.readline().strip().split()]\nnode = [Node(x) for x in range(n + 1)]\ngroups = [[int(item) for item in sys.stdin.readline().strip().split()]\n          for _ in range(m)]\nfor g in range(m):\n    group = groups[g]\n    k = group[0]\n    if k == 0:\n        continue\n    for i in range(2, k + 1):\n        union(node[group[i]], node[group[i - 1]])\n\n\nans = [find(node[x]).size for x in range(1, n + 1)]\n\nsys.stdout.write(' '.join(str(x) for x in ans) + '\\n')\n", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size(self, x):\n        return self.size[find(x)]\n\nn, q = list(map(int, input().split()))\nquery = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\ntree = Union_Find(n)\nfor a in query:\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nans = [tree.size[tree.find(i+1)] for i in range(n)]\nprint(\" \".join(map(str, ans)))\n", "import sys; input = sys.stdin.readline\n\n\nclass Node:\n    def __init__(self, val):\n        self.parent = self\n        self.size = 1\n\n\ndef union(x, y):\n    xRoot, yRoot = find(x), find(y)\n    if xRoot == yRoot:\n        return\n    if xRoot.size >= yRoot.size:\n        yRoot.parent = xRoot\n        xRoot.size += yRoot.size\n    else:\n        xRoot.parent = yRoot\n        yRoot.size += xRoot.size\n\n\ndef find(x):\n    while x.parent != x:\n        x = x.parent\n    return x\n\n\nclass Problem:\n    def __init__(self, In=sys.stdin, Out=sys.stdout):\n        pass\n\n    def solve(self):\n        print(self._solve())\n\n    def _solve(self):\n        n, m = [int(item) for item in sys.stdin.readline().strip().split()]\n        node = [Node(x) for x in range(n + 1)]\n        groups = [[int(item) for item in sys.stdin.readline().strip().split()]\n                  for _ in range(m)]\n        for g in range(m):\n            group = groups[g]\n            k = group[0]\n            if k == 0:\n                continue\n            for i in range(2, k + 1):\n                union(node[group[i]], node[group[i - 1]])\n\n        ans = [find(node[x]).size for x in range(1, n + 1)]\n        return ' '.join(str(x) for x in ans)\n\n\ndef main():\n    problem = Problem()\n    problem.solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size_query(self, x):\n        return self.size[self.find(x)]\n\nn, q = list(map(int, input().split()))\nquery = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\ntree = Union_Find(n)\nfor a in query:\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nans = [tree.size_query(tree.find(i+1)) for i in range(n)]\nprint(\" \".join(map(str, ans)))\n", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size_query(self, x):\n        return self.size[self.find(x)]\n\nn, q = list(map(int, input().split()))\nquery = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\ntree = Union_Find(n)\nfor a in query:\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nprint(\" \".join(map(str, [tree.size_query(tree.find(i+1)) for i in range(n)])))\n", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size_query(self, x):\n        return self.size[self.find(x)]\n\nn, q = list(map(int, input().split()))\ntree = Union_Find(n)\n\nfor _ in range(q):\n    a = tuple(map(int, sys.stdin.readline().split()))\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nprint(\" \".join(map(str, [tree.size_query(tree.find(i+1)) for i in range(n)])))\n", "import sys\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.size = [1]*(num+1)\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n    def size_query(self, x):\n        return self.size[self.find(x)]\n\nn, q = list(map(int, input().split()))\ntree = Union_Find(n)\n\nfor _ in range(q):\n    a = list(map(int, sys.stdin.readline().split()))\n    k = a[0]\n    if k >= 2:\n        b = a[1]\n        for i in a[2:]:\n            tree.union(b, i)\n\nprint(\" \".join(map(str, [tree.size_query(tree.find(i+1)) for i in range(n)])))\n", "# coding: UTF-8\nimport sys\n\ndef find(x):\n    if node[x] < 0:\n        return x\n    else:\n        node[x] = find(node[x])\n        return node[x]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    ret = False\n    if x != y:\n        ret = True\n        if rank[x] > rank[y]:\n            node[x] += node[y]\n            node[y] = x\n        else:\n            node[y] += node[x]\n            node[x] = y\n            if rank[x] == rank[y]:\n                rank[y] += 1\n    return ret\n\ndef is_same(x, y):\n    return find(x) == find(y)\n\ndef size(x):\n    return -node[find(x)]\n\nn, m = map(int, input().split())\nnode = [-1 for i in range(n + 1)]\nrank = [0 for _ in range(n + 1)]\nquery = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\nfor a in query:\n    if a[0] >= 2:\n        for j in a[2:]:\n            unite(a[1], j)\nfor i in range(1, n + 1):\n    print(size(i), end=\" \")\n\n\n\n", "from sys import stdin\n\ndef find(Set, x):\n    while Set[x] != x:\n        Set[x] = Set[Set[x]]\n        x = Set[x]\n\n    return x \n\ndef union(Set, u, v):\n    f_u = find(Set, u)\n    f_v = find(Set, v)\n    \n    if f_u != f_v:\n        Set[f_u] = f_v\n\ndef solve():\n    #stdin = open(\"C. News Distribution.txt\")\n    \n    N, M = map(int, stdin.readline().split())\n    \n    Set = list(range(N+1))\n    \n    for _ in range(M):\n        group = [int(k) for k in stdin.readline().split()][1:]\n        \n        for x in group[1:]:\n            Set[find(Set, x)] = find(Set, group[0])\n\n    cnt = [0]*(N+1)\n    \n    for i in range(1, N+1):\n        cnt[find(Set, i)] += 1\n                \n    print (' '.join(map(str, [cnt[find(Set, i)] for i in range(1,N+1)])))\n\ndef __starting_point():  \n    solve()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.siz = [1]*(num+1)\n\n    def same_checker(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.siz[ry] += self.siz[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n        return\n\n    def size(self, x):\n        return self.siz[self.find(x)]\n        \nn, q = map(int, input().split())\nunion_find_tree = Union_Find(n)\nfor i in range(q):\n    a = list(map(int, input().split()))\n    k = a[0]\n    if k >= 2:\n        for i in range(2, k+1):\n            union_find_tree.union(a[1], a[i])\nans = []\nfor i in range(1, n+1):\n    ans.append(union_find_tree.size(i))\nprint(\" \".join(map(str, ans)))", "from sys import stdin\n\ndef find(parent, x):\n    while parent[x] != x:\n        parent[x] = parent[parent[x]]\n        x = parent[x]\n\n    return x\n\ndef solve():\n    #stdin = open(\"C. News Distribution.txt\")\n    \n    N, M = map(int, stdin.readline().split())\n    \n    parent = list(range(N+1))\n    \n    for _ in range(M):\n        group = [int(k) for k in stdin.readline().split()][1:]\n        if group:\n            p = find(parent, group[0])\n            \n            for x in group[1:]:\n                parent[find(parent, x)] = p\n\n    cnt = [0]*(N+1)\n    \n    for i in range(1, N+1):\n        cnt[find(parent, i)] += 1\n                \n    print (' '.join(map(str, [cnt[find(parent, i)] for i in range(1,N+1)])))\n\ndef __starting_point():  \n    solve()\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000)\n\nnUsers, nGroups = map(int, sys.stdin.readline().split())\nparent = list(range(nUsers + 1))\nrank = [0] * (nUsers + 1)\n\ndef find(a):\n    if parent[a] != a:\n        parent[a] = find(parent[a])\n    return parent[a]\n\ndef union(a, b):\n    idA, idB = find(a), find(b)\n    if idA == idB:\n        return\n    if rank[idA] > rank[idB]:\n        parent[idB] = idA\n    else:\n        parent[idA] = idB\n        if rank[idA] == rank[idB]:\n            rank[idB] += 1\n\nfor _ in range(nGroups):\n    g = sys.stdin.readline()\n    if g[0] >= '1':\n        g = list(map(int, g.split()))\n        for i in range(2, len(g)):\n            union(g[1], g[i])\n\ncount = [0] * (nUsers + 1)\nfor user in range(nUsers + 1):\n    count[find(user)] += 1\n\nret = []\nfor user in range(1, nUsers + 1):\n    ret.append(str(count[parent[user]]))\nsys.stdout.write('%s\\n' % ' '.join(ret))", "import sys\nsys.setrecursionlimit(1000000)\n\nnUsers, nGroups = map(int, sys.stdin.readline().split())\nparent = list(range(nUsers + 1))\nrank = [0] * (nUsers + 1)\n\ndef find(a):\n    if parent[a] != a:\n        parent[a] = find(parent[a])\n    return parent[a]\n\ndef union(a, b):\n    idA, idB = find(a), find(b)\n    if idA == idB:\n        return\n    if rank[idA] > rank[idB]:\n        parent[idB] = idA\n    else:\n        parent[idA] = idB\n        if rank[idA] == rank[idB]:\n            rank[idB] += 1\n\nfor _ in range(nGroups):\n    g = sys.stdin.readline()\n    if g[0] >= '1':\n        g = list(map(int, g.split()))\n        for i in range(2, len(g)):\n            union(g[1], g[i])\n\ncount = [0] * (nUsers + 1)\nfor user in range(nUsers + 1):\n    count[find(user)] += 1\n\nret = []\nfor user in range(1, nUsers + 1):\n    ret.append(str(count[parent[user]]))\nsys.stdout.write('%s\\n' % ' '.join(ret))"]
["#!/usr/bin/env python3\n\ntry:\n    while True:\n        s = input()\n        if s[0] in \"ah\" and s[1] in \"18\":\n            print(3)\n        elif s[0] in \"ah\" or s[1] in \"18\":\n            print(5)\n        else:\n            print(8)\n\nexcept EOFError:\n    pass\n", "cd = input()\nc = cd[0]\nd = cd[1]\n\nss = 0\nif(c=='a')or(c=='h'):\n    ss += 1\nif(d=='1')or(d=='8'):\n    ss += 1\nif(ss==2):\n    print(3)\nelif(ss==1):\n    print(5)\nelse:\n    print(8)", "s = input()\nx = s[0]\ny = int(s[1])\nl = 0\nif x == 'a' or x == 'h':\n    l += 1\nif y == 1 or y == 8:\n    l += 1\nif l == 0:\n    print(8)\nelif l == 1:\n    print(5)\nelse:\n    print(3)", "p = input()\nb1 = p[0] == 'a' or p[0] == 'h'\nb2 = p[1] == '1' or p[1] == '8'\nif b1 and b2:\n    print(\"3\")\nelif b1 or b2:\n    print(\"5\")\nelse:\n    print(\"8\")\n", "string =input()\nline = \"abcdefgh\"\na = line.find(string[0]) + 1\nb = int(string[1])\nif (a, b) in [(1, 1), (8, 8), (1, 8), (8, 1)]:\n    print(3)\nelif a in [1, 8] or b in [1, 8]:\n    print(5)\nelse:\n    print(8)", "p = input()\n\nif 'b' <= p[0] <= 'g' and '2' <= p[1] <= '7':\n\tprint(8)\nelif p in ['a1', 'a8', 'h1', 'h8']:\n\tprint(3)\nelse:\n\tprint(5)", "c, r = list(input())\nc = ord(c) - ord('a')\nr = ord(r) - ord('1')\nif c in (0, 7) and r in (0, 7):\n    print(3)\nelif c in (0, 7) or r in (0, 7):\n    print(5)\nelse:\n    print(8)\n", "from sys import stdin\n\npos=input()\n\n\ncol=pos[0]\nlig=int(pos[1])\n\nif (col==\"a\" or col==\"h\") and (lig==1 or lig==8):\n    print(3)\nelif col==\"a\" or col==\"h\" or lig==1 or lig==8:\n    print(5)\nelse:\n    print(8)\n", "pos = input()\n\nmoves = 8\n\nif pos[0] in [\"a\", \"h\"]:\n    moves -= 3\n\nif pos[1] in [\"1\", \"8\"]:\n    moves -= 3\n\nif moves < 3:\n    moves = 3\n\nprint(moves)", "a = list(input())\nmoves = 8\nresticted = ['a','h','1','8']\n\nif a[0] in resticted and a[1] in resticted:\n\tmoves = 3;\nelif a[0]in resticted or a[1] in resticted:\n\tmoves = 5\n\nprint(moves)", "nm = input()\nn = nm[0]\nm = int(nm[1])\nch = 8\nif n == 'a' or n == 'h':\n    ch = 5\nif m == 1 or m == 8:\n    if ch == 8:\n        ch = 5\n    else:\n        ch = 3\nprint(ch)\n", "S = input()\nx = ord(S[0]) - ord(\"a\")\ny = int(S[1]) - 1\nans = 8\nis_x = False\nis_y = False\nif x == 0 or x == 7:\n    is_x = True\nif y == 0 or y == 7:\n    is_y = True\nif is_x and is_y:\n    ans -= 5\nelif (is_x and not is_y) or (not is_x and is_y):\n    ans -= 3\nprint(ans)\n", "import sys, math\nf = [[1] * 10 for i in range(10)]\nfor i in range(10):\n    f[0][i] = 0\n    f[i][0] = 0\n    f[9][i] = 0\n    f[i][9] = 0\ng = input()\na = ord(g[0]) - ord('a') + 1\nb = int(g[1])\nans = f[a][b+1] + f[a+1][b] + f[a-1][b] + f[a][b-1] + f[a+1][b+1] + f[a-1][b+1] + f[a-1][b-1] + f[a+1][b-1]\nprint(ans)\n", "position = input()\n\nresult = 8\n\nif position in {'a1', 'a8', 'h1', 'h8'}:\n    result = 3\nelif position[0] in {'a', 'h'} or position[1] in {'1', '8'}:\n    result = 5\nprint(result)\n", "s = input()\n\nboundary = ['1','8','a','h']\n\nans = 8 - 3 * (s[0] in boundary) - 3 * (s[1] in boundary) + (s[1] in boundary) * (s[0] in boundary)\n\nprint(ans)", "a = input()\nif((a[0] == 'a' or a[0] == 'h') and (a[1] == '1' or a[1] == '8')):\n    print(3)\nelif ((a[0] == 'a' or a[0] == 'h') or (a[1] == '1' or a[1] == '8')):\n    print(5)\nelse:\n    print(8)", "#realInput = list(map(int, input().split()))\nkingMove = list(input())\npossMoves = 3\nif kingMove[0] > \"a\" and kingMove[0] < \"h\":\n    possMoves += 2\nif int(kingMove[1]) > 1 and int(kingMove[1]) < 8:\n    possMoves += 2\nif possMoves == 7:\n    possMoves += 1\nprint(possMoves)\n", "cd = input()\nif cd[0] != \"a\" and cd[0] !=\"h\":\n    if cd[1] != \"1\"  and cd[1] != \"8\":\n        print(8)\n    else:\n        print(5)\nelse:\n    if cd[1] != \"1\"  and cd[1] != \"8\":\n        print(5)\n    else:\n        print(3)\n", "c = input()\nr = 8\nif c[0] == 'a' or c[0] == 'h':\n    if c[1] == '1' or c[1] == '8':\n        r = 3\n    else:\n        r = 5\n\nif c[1] == '1' or c[1] == '8':\n    if c[0] == 'a' or c[0] == 'h':\n        r = 3\n    else:\n        r = 5\nprint(r)\n", "s = input()\nif (s[0] == 'a' and (s[1] == '1' or s[1] == '8')) or\\\n    (s[0] == 'h' and (s[1] == '1' or s[1] == '8')):\n    print(3)\nelif s[0] in 'ah' or s[1] in '18':\n    print(5)\nelse:\n    print(8)\n", "a = input()\nc = a[0]\nd = int(a[1])\nif c == \"a\" or c == \"h\":\n    if d == 1 or d == 8:\n        print(3)\n    else:\n        print(5)\nelif d == 1 or d == 8:\n    print(5)\nelse:\n    print(8)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\nplace   = input()\n\nstart = time.time()\n\nif place =='a1' or place =='a8' or place =='h1' or place ==  'h8':\n    ans = 3\nelif place[0] == 'a' or place[0] == 'h' or place[1] == '1' or place[1] == '8':\n    ans = 5\nelse:\n    ans = 8\nprint(ans)\nfinish = time.time()\n#print(finish - start)\n", "#imports\nimport sys\nsys.setrecursionlimit(30000)\n\nfrom collections import Counter, defaultdict, deque\nfrom math import ceil, floor, factorial, fsum, isinf, exp, log, log10, log2, isfinite, sqrt\nfrom math import pi as PI, e as E\nfrom fractions import Fraction\nfrom itertools import starmap, tee, chain, filterfalse, combinations as combos\nfrom itertools import permutations as perms, product as prod, combinations_with_replacement as rcombos\nfrom functools import reduce, partial\nimport operator as ops #lt, le, eq, ne, ge, gt,  xor  notit, lshift, rshift,      neg, add, mul, sub,\nfrom operator import __not__ as notit\nfrom operator import __abs__ as absit\nfrom operator import __or__ as orit\n\n#PI, E, PHI, INF\nPHI, PHI2 = (1 + 5 ** 0.5) / 2, (5 ** 0.5 - 1) / 2\nINF = float('inf')\n\n#structures\nclass TreeNode:\n    def __init__(self, v):\n        self.val = v\n        self.left = None\n        self.right = None\n\n#Bit Manipulation\n#<<, >>, bin(), int(s, 2)\ndef setBit(x, offset):\n    return x | 1 << offset #RHS: mask\ndef clearBit(x, offset):\n    return x & ~(1 << offset) #RHS: mask\ndef getBit(x, offset):\n    return 1 if testBit(x, offset) > 0 else 0\ndef testBit(x, offset):\n    return x & 1 << offset #RHS: mask\ndef flipBitAt(x, offset):\n    return x ^ 1 << offset #RHS: mask\ndef flipBits(x, length=-1): #default: x.bit_length() - 1\n    length = x.bit_length()-1 if length == -1 else length\n    return x ^ (1 << length) - 1\ndef numBits(x):\n    return x.bit_length() #int.bit_length()\ndef countOnes(x):\n    return bin(x).count('1')\ndef countZeros(x, length=-1):\n    length = x.bit_length() if length == -1 else length\n    return length - countOnes(x)\n\n#IO\ndef getList(tcast=str):\n    return [tcast(x) for x in input().strip().split(' ')]\ndef getItems(*tcast):\n    return map(lambda f, x: f(x), tcast, getList())\ndef getVal(tcast=str):\n    return tcast(input().strip())\ndef getMatrix(r, tcast=str):\n    return [getList(tcast) for row in range(r)]\n\n#Math\ndef isOdd(n):\n    return n & 1 > 0\ndef isEven(n):\n    return not n & 1\ndef numDigits(n):\n    return len(str(n)) - (1 if n < 0 else 0)\ndef getRecip(f):\n    return Fraction(f.denominator, f.numerator)\ndef _gcd(a, b):\n    while b: #is not zero\n        a, b = b, a % b\n    return a\ndef gcd(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        if cur == 1:\n            return cur\n        cur = _gcd(cur, n)\n    return cur\ndef _lcm(a, b):\n    return (a // gcd(a, b)) * b\ndef lcm(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        cur = _lcm(cur, n)\n    return cur\ndef primesUpto(n):\n    isp = [True] * (n + 1)\n    isp[0], isp[1] = False, False\n    primes = []\n    for i, x in enumerate(isp): #for each number\n        if x: #found a prime\n            primes.append(i)\n            mults = i * i\n            while mults <= n:\n                isp[mults] = False\n                mults += i\n    return primes\ndef primeFactor(n): #without a sieve\n    factors = Counter()\n    while not n&1:\n        factors[2] += 1\n        n >>= 1\n    trynum = 3\n    while trynum <= ceil(sqrt(n)): #just in case\n        while n % trynum == 0:\n            factors[trynum] += 1\n            n //= trynum\n        trynum += 2\n    if n != 1:\n        factors[n] += 1\n    return factors\ndef isPrime(n): #num -> boolean\n    if n&1 and n >= 2:\n        trynum = 3\n        limit = ceil(sqrt(n))\n        while trynum < limit:\n            if n % trynum == 0:\n                return False\n            trynum += 2\n        else:\n            return True\n    else:\n        return False\ndef nthFib(n):\n    if n <= 2:\n        return 1\n    else:\n        a, b = 1, 1\n        while n > 2:\n            a, b = b, a + b\n            n -= 1\n        return b\n\n#Iteration\ndef zipNWith(f, *x): #xs, ys, ... zs -> elementwise f -> os #return map(lambda *y: f(y), x) #list way: [f(y) for y in zip(*xs)]\n    return (f(y) for y in zip(*x))\ndef zipWith(f, xs, ys):\n    return (f(x, y) for x, y in zip(xs, ys))\ndef flatten(xs):\n    return reduce(ops.concat, xs)\ndef quantify(pred, it):\n    return sum(map(pred, it))\ndef dotproduct(xs, ys):\n    return sum(map(ops.mul, xs, ys))\ndef pairwise(it):\n    a, b = tee(it)\n    next(b, None)\n    return zip(a, b)\ndef bipartition(pred, it):\n    t, f = tee(it)\n    return filter(pred, t), filterfalse(pred, f)\ndef powerset(it):\n    s = list(it)\n    return chain.from_iterable(combos(s, r) for r in range(len(s) + 1))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#Input\n\n#Body\n\n#Output\npos = getVal(str)\nfirst, second = pos[0], int(pos[1])\nfirst = 'abcdefgh'.index(first) + 1\n#print(first, second)\n\nedges = [1, 8]\nif first in edges or second in edges:\n    if first in edges and second in edges:\n        out = 3\n    else:\n        out = 5\nelse:\n    out = 8\nprint(out)", "import sys\n\nfin = sys.stdin\nfout = sys.stdout\ns = fin.readline().strip()\nres = 0\nif (s == 'a1' or s == 'a8' or s == 'h1' or s == 'h8'):\n    res = 3\nelif (s[0] == 'a' or s[0] == 'h' or s[1] == '1' or s[1] == '8'):\n    res = 5\nelse:\n    res = 8\nfout.write(str(res))\n", "s = input()\na, b = s[0], s[1]\nres = 8\nif a == 'a' or a == 'h':\n    res -= 3\n    if b == '1' or b == '8':\n        res -= 2\nelif b == '1' or b == '8':\n    res -= 3\n    if a == 'a' or a == 'h':\n        res -= 2\nprint(res)"]
["import sys\nimport collections\n\nn, m = list(map(int, input().split()))\n\nr = tuple(map(int, input().split()))\n\ncontrols = [tuple(map(int, input().split()))[1:] for i in range(m)]\n\n\nclass DSU:\n\n    def __init__(self):\n        self.parent = None\n        self.has_zero = False\n        self.has_one = False\n        self.size = 1\n        self.doors = []\n\n    def get_root(self):\n        if self.parent is None:\n            return self\n        self.parent = self.parent.get_root()\n        return self.parent\n\n    def unite(self, s):\n        r1 = self.get_root()\n        r2 = s.get_root()\n\n        if r1 is r2:\n            return r1\n\n        if r1.size < r2.size:\n            r1, r2 = r2, r1\n\n        r2.parent = r1\n        r1.size += r2.size\n        r1.has_zero = r1.has_zero or r2.has_zero\n        r1.has_one = r1.has_one or r2.has_one\n\n        return r1\n\ndoor_dsus = [[] for i in range(n)]\nfor doors in controls:\n    n = DSU()\n    for door in doors:\n        n.doors.append(door - 1)\n\n        door_dsus[door - 1].append(n)\n        if r[door - 1]:\n            n.has_one = True\n        if not r[door - 1]:\n            n.has_zero = True\n\nfor door, is_open in enumerate(r):\n    n1, n2 = door_dsus[door]\n\n    if is_open:\n         n1.unite(n2)\n\nG = {}\nfor door, is_open in enumerate(r):\n    if is_open:\n        continue\n\n    n1, n2 = door_dsus[door]\n    if n1.get_root() is n2.get_root():\n        print(\"NO\")\n        return\n\n    G.setdefault(n1.get_root(), set()).add(n2.get_root())\n    G.setdefault(n2.get_root(), set()).add(n1.get_root())\n\ncolor = {}\n\nfor v in list(G.keys()):\n    if v in color:\n        continue\n\n    color[v] = False\n    q = collections.deque([v])\n    while q:\n        v = q.popleft()\n        c = color[v]\n        for adj_v in G[v]:\n            if adj_v in color:\n                if color[adj_v] != (not c):\n                    print(\"NO\")\n                    return\n            else:\n                color[adj_v] = not c\n                q.append(adj_v)\n\nprint(\"YES\")\n", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    r = [int(i) for i in sys.stdin.readline().split()]\n    es = [[] for i in range(n)]\n\n    for i in range(m):\n        line = [int(j) for j in sys.stdin.readline().split()]\n\n        for u in line[1:]:\n            es[u - 1].append(i)\n\n    Adj = [[] for i in range(m)]\n\n    for u, v in es:\n        Adj[u].append(v)\n        Adj[v].append(u)\n\n    edges = dict()\n\n    for i, e in enumerate(es):\n        e.sort()\n        if tuple(e) not in edges:\n            edges[tuple(e)] = r[i]\n        elif edges[tuple(e)] != r[i]:\n            print('NO')\n            return None\n        else:\n            pass\n\n    cols = [None] * m\n\n    for u in range(m):\n        if cols[u] is None:\n            if not bfs(Adj, edges, cols, u):\n                print('NO')\n                return None\n            else:\n                pass\n\n    print('YES')\n\ndef bfs(Adj, edges, cols, u):\n    nxts = deque([u])\n    cols[u] = 0\n\n    while nxts:\n        v = nxts.popleft()\n\n        for w in Adj[v]:\n            ed = tuple(sorted([v, w]))\n            if cols[w] is None:\n                if edges[ed] == 1:\n                    cols[w] = cols[v]\n                else:\n                    cols[w] = 1 - cols[v]\n                nxts.append(w)\n            else:\n                if edges[ed] == 1 and cols[w] != cols[v]:\n                    return False\n                elif edges[ed] == 0 and cols[w] == cols[v]:\n                    return False\n\n    return True\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    r = [1 - int(i) for i in sys.stdin.readline().split()]\n    es = [[] for i in range(n)]\n\n    for i in range(m):\n        line = [int(j) for j in sys.stdin.readline().split()]\n\n        for u in line[1:]:\n            es[u - 1].append(i)\n\n    Adj = [[] for i in range(m)]\n\n    for u, v in es:\n        Adj[u].append(v)\n        Adj[v].append(u)\n\n    edges = dict()\n\n    for i, e in enumerate(es):\n        e.sort()\n        if tuple(e) not in edges:\n            edges[tuple(e)] = r[i]\n        elif edges[tuple(e)] != r[i]:\n            print('NO')\n            return None\n        else:\n            pass\n\n    cols = [None] * m\n\n    for u in range(m):\n        if cols[u] is None:\n            if not bfs(Adj, edges, cols, u):\n                print('NO')\n                return None\n            else:\n                pass\n\n    print('YES')\n\ndef bfs(Adj, edges, cols, u):\n    nxts = deque([u])\n    cols[u] = 0\n\n    while nxts:\n        v = nxts.popleft()\n\n        for w in Adj[v]:\n            ed = tuple(sorted([v, w]))\n            if cols[w] is None:\n                cols[w] = cols[v] ^ edges[ed]\n                nxts.append(w)\n            else:\n                if cols[w] ^ cols[v] != edges[ed]:\n                    return False\n\n    return True\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom collections import deque\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    r = [1 - int(i) for i in sys.stdin.readline().split()]\n    es = [[] for i in range(n)]\n\n    for i in range(m):\n        line = [int(j) for j in sys.stdin.readline().split()]\n\n        for u in line[1:]:\n            es[u - 1].append(i)\n\n    Adj = [[] for i in range(m)]\n\n    for u, v in es:\n        Adj[u].append(v)\n        Adj[v].append(u)\n\n    edges = dict()\n\n    for i, e in enumerate(es):\n        e.sort()\n        if tuple(e) not in edges:\n            edges[tuple(e)] = r[i]\n        elif edges[tuple(e)] != r[i]:\n            print('NO')\n            return None\n        else:\n            pass\n\n    cols = [None] * m\n\n    for u in range(m):\n        if cols[u] is None:\n            if not bfs(Adj, edges, cols, u):\n                print('NO')\n                return None\n            else:\n                pass\n\n    print('YES')\n\ndef bfs(Adj, edges, cols, u):\n    nxts = deque([u])\n    cols[u] = 0\n\n    while nxts:\n        v = nxts.popleft()\n\n        for w in Adj[v]:\n            ed = tuple(sorted([v, w]))\n            if cols[w] is None:\n                cols[w] = cols[v] ^ edges[ed]\n                nxts.append(w)\n            else:\n                if cols[w] ^ cols[v] != edges[ed]:\n                    return False\n\n    return True\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\nn, m = map(int, input().split())\n\ndoor = list(map(int, input().split()))\n\na = [[] for i in range(n+1)]\n\ne = [[] for i in range(m)]\n\ncolor = [-1] * m\n\nvisited = [False] * m\n\ndef bfs(u, visited):\n\tcolor[u] = 0\n\tq = [u]\n\th = 0\n\tvisited[u] = True\n\t\n\twhile (h<len(q)):\n\t\tu = q[h]\n\t\th+=1\n\t\tfor v in e[u]:\n\t\t\tif (color[v[0]] == -1):\n\t\t\t\tcolor[v[0]] = color[u]^v[1]\n\t\t\t\tq.append(v[0])\n\t\t\t\tvisited[v[0]] = True\n\t\t\telse:\n\t\t\t\tif color[v[0]] != color[u]^v[1]: return False\n\treturn True\n\nfor i in range(m):\n\tb = list(map(int, input().split()))\n\tfor j in range(1, len(b)):\n\t\tk = b[j]\n\t\ta[k].append(i)\n\t\tif len(a[k])==2:\n\t\t\te[a[k][0]].append((a[k][1],1-door[k-1]))\n\t\t\te[a[k][1]].append((a[k][0],1-door[k-1]))\n\t\t\t\nflag = True\nfor i in range(m):\n\tif color[i] == -1:\n\t\tif bfs(i, visited) == False:\n\t\t\tflag = False\n\t\t\tbreak\n\nif flag: print(\"YES\")\nelse: print(\"NO\")", "from collections import defaultdict, deque\n\nn, m = list(map(int, input().split()))\n\nstate = list(map(int, input().split()))\n\ngraph = defaultdict(list)\n\nconnected = [list() for _ in range(n + 1)] #Each node connected to which 2 edges\nfor i in range(m):\n    for j in list(map(int, input().split()))[1:]:\n        connected[j].append(i)\n\nfor index, i in enumerate(connected[1:]):\n    graph[i[0]].append((i[1], state[index]))\n    graph[i[1]].append((i[0], state[index]))\n\nswitch_color = [False] * m\nswitch_visited = [False] * m\n# print(connected)\n# print(graph)\nqueue = deque([])\nyes = True\nfor nodes in graph:\n    if yes and (not switch_visited[nodes]):\n        # queue = deque([nodes])\n        # yes = True\n        queue.append(nodes)\n        while queue and yes:\n            now = queue.popleft()\n            switch_visited[now] = True\n            for i in graph[now]:\n                if not switch_visited[i[0]]:\n                    switch_visited[i[0]] = True\n                    queue.append(i[0])\n                    if i[1] == 1:\n                        switch_color[i[0]] = switch_color[now]\n                    else:\n                        switch_color[i[0]] = (not switch_color[now])\n                else:\n                    if (i[1] == 1) and (switch_color[i[0]] != switch_color[now]):\n                        print(\"NO\")\n                        yes = False\n                        break\n                    elif i[1] == 0 and switch_color[i[0]] == switch_color[now]:\n                        print(\"NO\")\n                        yes = False\n                        break\nif yes:\n    print(\"YES\")\n# print(queue)\n# print(switch_visited)\n# print(switch_color)\n", "from collections import defaultdict, deque\n\nn, m = list(map(int, input().split()))\n\nstate = list(map(int, input().split()))\n\ngraph = defaultdict(list)\n\nconnected = [list() for _ in range(n + 1)] #Each node connected to which 2 edges\nfor i in range(m):\n    for j in list(map(int, input().split()))[1:]:\n        connected[j].append(i)\n\nfor index, i in enumerate(connected[1:]):\n    graph[i[0]].append((i[1], state[index]))\n    graph[i[1]].append((i[0], state[index]))\n\nswitch_color = [False] * m\nswitch_visited = [False] * m\n# print(connected)\n# print(graph)\nqueue = deque([])\nyes = True\nfor nodes in graph:\n    if yes and (not switch_visited[nodes]):\n        # queue = deque([nodes])\n        # yes = True\n        queue.append(nodes)\n        while queue and yes:\n            now = queue.popleft()\n            switch_visited[now] = True\n            for i in graph[now]:\n                if not switch_visited[i[0]]:\n                    switch_visited[i[0]] = True\n                    queue.append(i[0])\n                    if i[1] == 1:\n                        switch_color[i[0]] = switch_color[now]\n                    else:\n                        switch_color[i[0]] = (not switch_color[now])\n                else:\n                    if (i[1] == 1) and (switch_color[i[0]] != switch_color[now]):\n                        print(\"NO\")\n                        yes = False\n                        break\n                    elif i[1] == 0 and switch_color[i[0]] == switch_color[now]:\n                        print(\"NO\")\n                        yes = False\n                        break\nif yes:\n    print(\"YES\")", "#!/usr/bin/env python3\n\ndef _vertex(lit):\n    if lit > 0:\n        return 2 * (lit - 1)\n    else:\n        return 2 * (-lit - 1) + 1\n\ndef tarjan(graph):\n    n = len(graph)\n    dfs_num = [None] * n\n    dfs_min = [n] * n\n    waiting = []\n    waits = [False] * n\n    sccp = []\n    dfs_time = 0\n    times_seen = [-1] * n\n    for start in range(n):\n        if times_seen[start] == -1:\n            times_seen[start] = 0\n            to_visit = [start]\n            while to_visit:\n                node = to_visit[-1]\n                if times_seen[node] == 0:\n                    dfs_num[node] = dfs_time\n                    dfs_min[node] = dfs_time\n                    dfs_time += 1\n                    waiting.append(node)\n                    waits[node] = True\n                children = graph[node]\n                if times_seen[node] == len(children):\n                    to_visit.pop()\n                    dfs_min[node] = dfs_num[node]\n                    for child in children:\n                        if waits[child] and dfs_min[child] < dfs_min[node]:\n                            dfs_min[node] = dfs_min[child]\n                    if dfs_min[node] == dfs_num[node]:\n                        component = []\n                        while True:\n                            u = waiting.pop()\n                            waits[u] = False\n                            component.append(u)\n                            if u == node:\n                                break\n                        sccp.append(component)\n                else:\n                    child = children[times_seen[node]]\n                    times_seen[node] += 1\n                    if times_seen[child] == -1:\n                        times_seen[child] = 0\n                        to_visit.append(child)\n    return sccp\n\ndef two_sat(formula):\n    n = max(abs(clause[p]) for p in (0, 1) for clause in formula)\n    graph = [[] for node in range(2 * n)]\n    for x, y in formula:\n        graph[_vertex(-x)].append(_vertex(y))\n        graph[_vertex(-y)].append(_vertex(x))\n    sccp = tarjan(graph)\n    comp_id = [None] * (2 * n)\n    #assignment = [None] * (2 * n)\n    for component in sccp:\n        rep = min(component)\n        for vtx in component:\n            comp_id[vtx] = rep\n            #if assignment[vtx] is None:\n            #    assignment[vtx] = True\n            #    assignment[vtx ^ 1] = False\n    for i in range(n):\n        if comp_id[2 * i] == comp_id[2 * i + 1]:\n            return \"NO\"\n    return \"YES\"\n    #return assignment[::2]\n\n\nn, m = [int(x) for x in input().split()]\ndoors_status = [int(x) for x in input().split()]\nswitches = [list(map(int, input().split())) for _ in range(m)]\n\nfrom collections import defaultdict\nswitches_of = defaultdict(list)\nfor switch in range(1, m+1):\n    for door in switches[switch-1][1:]:\n        switches_of[door].append(switch)\n\nLOCKED = 0\nUNLOCKED = 1\nformula = []\nfor door in range(1, n+1):\n    s1, s2 = switches_of[door]\n    if doors_status[door-1] == LOCKED:\n        formula.append((s1, s2))\n        formula.append((-s1, -s2))\n    else:\n        formula.append((s1, -s2))\n        formula.append((-s1, s2))\n\nprint(two_sat(formula))\n"]
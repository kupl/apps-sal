["n=int(input())\ns=input()\n\nN=n\n\nN0 = 2**(N-1).bit_length()\ndata = [n]*(2*N0)\nINF = n\n# \u533a\u9593[l, r+1)\u306e\u5024\u3092v\u306b\u66f8\u304d\u63db\u3048\u308b\n# v\u306f(t, value)\u3068\u3044\u3046\u5024\u306b\u3059\u308b (\u65b0\u3057\u3044\u5024\u307b\u3069t\u306f\u5927\u304d\u304f\u306a\u308b)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] = min(v,data[R-1])\n\n        if L & 1:\n            data[L-1] = min(v,data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n# a_i\u306e\u73fe\u5728\u306e\u5024\u3092\u53d6\u5f97\ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = min(s, data[k])\n        k = (k - 1) // 2\n    return s\n# \u3053\u308c\u3092\u547c\u3073\u51fa\u3059\ndef query(k):\n    return _query(k)\n\nalice=[int(s[i]==\"0\") for i in range(n)]\nbob=[int(s[i]==\"1\") for i in range(n)]\nfor i in range(1,n):\n    alice[i]+=alice[i-1]\n    bob[i]+=bob[i-1]\nalice.append(0)\nbob.append(0)\n\nupdate_que=[[] for i in range(n)]\n\nalice_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"0\":\n        pos=id\n        while pos<n and s[pos]!=\"0\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\nbob_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"1\":\n        pos=id\n        while pos<n and s[pos]!=\"1\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\n\n\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    for id in update_que[i]:\n        update(0,id+1,id)\n    pos=0\n    res=0\n    while pos<n-i:\n        check1=alice[pos+i]-alice[pos-1]\n        check2=bob[pos+i]-bob[pos-1]\n        if not check1 or not check2:\n            res+=1\n            pos+=i+1\n        else:\n            npos=query(pos)\n            if query(pos)==n:\n                break\n            else:\n                pos=npos+i+1\n                res+=1\n    ans[i]=res\n\nprint(*ans)\n", "class BalancingTree:\n    def __init__(self, n):\n        self.N = n\n        self.root = self.node(1<<n, 1<<n)\n\n    def append(self, v):\n        v += 1\n        nd = self.root\n        while True:\n            if v == nd.value:\n\n                return 0\n            else:\n                mi, ma = min(v, nd.value), max(v, nd.value)\n                if mi < nd.pivot:\n                    nd.value = ma\n                    if nd.left:\n                        nd = nd.left\n                        v = mi\n                    else:\n                        p = nd.pivot\n                        nd.left = self.node(mi, p - (p&-p)//2)\n                        break\n                else:\n                    nd.value = mi\n                    if nd.right:\n                        nd = nd.right\n                        v = ma\n                    else:\n                        p = nd.pivot\n                        nd.right = self.node(ma, p + (p&-p)//2)\n                        break\n\n    def leftmost(self, nd):\n        if nd.left: return self.leftmost(nd.left)\n        return nd\n\n    def rightmost(self, nd):\n        if nd.right: return self.rightmost(nd.right)\n        return nd\n\n    def find_l(self, v):\n        v += 1\n        nd = self.root\n        prev = 0\n        if nd.value < v: prev = nd.value\n        while True:\n            if v <= nd.value:\n                if nd.left:\n                    nd = nd.left\n                else:\n                    return prev - 1\n            else:\n                prev = nd.value\n                if nd.right:\n                    nd = nd.right\n                else:\n                    return prev - 1\n\n    def find_r(self, v):\n        v += 1\n        nd = self.root\n        prev = 0\n        if nd.value > v: prev = nd.value\n        while True:\n            if v < nd.value:\n                prev = nd.value\n                if nd.left:\n                    nd = nd.left\n                else:\n                    return prev - 1\n            else:\n                if nd.right:\n                    nd = nd.right\n                else:\n                    return prev - 1\n\n    @property\n    def max(self):\n        return self.find_l((1<<self.N)-1)\n\n    @property\n    def min(self):\n        return self.find_r(-1)\n\n    def delete(self, v, nd = None, prev = None):\n        v += 1\n        if not nd: nd = self.root\n        if not prev: prev = nd\n        while v != nd.value:\n            prev = nd\n            if v <= nd.value:\n                if nd.left:\n                    nd = nd.left\n                else:\n                    return\n            else:\n                if nd.right:\n                    nd = nd.right\n                else:\n                    return\n        if (not nd.left) and (not nd.right):\n            if nd.value < prev.value:\n                prev.left = None\n            else:\n                prev.right = None\n        elif not nd.left:\n            if nd.value < prev.value:\n                prev.left = nd.right\n            else:\n                prev.right = nd.right\n        elif not nd.right:\n            if nd.value < prev.value:\n                prev.left = nd.left\n            else:\n                prev.right = nd.left\n        else:\n            nd.value = self.leftmost(nd.right).value\n            self.delete(nd.value - 1, nd.right, nd)\n\n    def __contains__(self, v: int) -> bool:\n        return self.find_r(v - 1) == v\n\n    class node:\n        def __init__(self, v, p):\n            self.value = v\n            self.pivot = p\n            self.left = None\n            self.right = None\n\nn=int(input())\ns=input()\n\nalice=[int(s[i]==\"0\") for i in range(n)]\nbob=[int(s[i]==\"1\") for i in range(n)]\nfor i in range(1,n):\n    alice[i]+=alice[i-1]\n    bob[i]+=bob[i-1]\nalice.append(0)\nbob.append(0)\n\nupdate_que=[[] for i in range(n)]\n\nalice_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"0\":\n        pos=id\n        while pos<n and s[pos]!=\"0\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\nbob_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"1\":\n        pos=id\n        while pos<n and s[pos]!=\"1\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\n\nbst=BalancingTree(20)\nbst.append(n)\n\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    for id in update_que[i]:\n        bst.append(id)\n    pos=0\n    res=0\n    while pos<n-i:\n        check1=alice[pos+i]-alice[pos-1]\n        check2=bob[pos+i]-bob[pos-1]\n        if not check1 or not check2:\n            res+=1\n            pos+=i+1\n        else:\n            npos=bst.find_r(pos-1)\n            if npos==n:\n                break\n            else:\n                pos=npos+i+1\n                res+=1\n    ans[i]=res\n\nprint(*ans)\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n \n\nn = val()\ns = st()\n\npref0 = [0]\npref1 = [0]\n\nfor i in s:\n    if i == '1':\n        pref1.append(pref1[-1] + 1)\n        pref0.append(pref0[-1])\n    elif i == '0':\n        pref0.append(pref0[-1] + 1)\n        pref1.append(pref1[-1])\n    else:\n        pref1.append(pref1[-1] + 1)\n        pref0.append(pref0[-1] + 1)\n\nnext0 = [-1]\nnext1 = [-1]\n\n\nm1 =  m2 = -1\nfor i in range(n):\n    if s[i] == '1':m2 = i\n    if s[i] == '0':m1 = i\n\n    next0.append(m1)\n    next1.append(m2)\n\n\nflag = 0\nlast = float('inf')\n\nfor x in range(1, n + 1):\n    if flag:\n        ans = 0\n    else:\n        ans = start = 0\n        while start + x <= n:\n            # print(start)\n            if pref0[start + x] - pref0[start] == x:\n                start += x\n                ans += 1\n            elif pref1[start + x] - pref1[start] == x:\n                start += x\n                ans += 1\n            else:\n                start = next0[start + x] if next1[start + x] > next0[start + x] else next1[start + x]\n                start += 1\n\n\n    if not ans:flag = 1\n\n    print(ans,end = ' ')", "class bitset():\n    def __init__(self,n):\n        self.size=1<<((n+2).bit_length())\n        self.bit=[0]*(self.size+1)\n\n    def append(self,val):\n        val+=1\n        id=val\n        while id<=self.size:\n            self.bit[id]+=1\n            id+=(id)&(-id)\n\n    def erase(self,val):\n        val+=1\n        id=val\n        while id<=self.size:\n            self.bit[id]-=1\n            id+=(id)&(-id)\n\n    def cnt(self,val):\n        res_sum = 0\n        val+=1\n        while val > 0:\n            res_sum += self.bit[val]\n            val -= val&(-val)\n        return res_sum\n\n    def next(self,val):\n        val+=1\n        base=self.cnt(val-1)\n        start=0\n        end=self.size\n        while end-start>1:\n            test=(end+start)//2\n            if self.bit[test]>base:\n                end=test\n            else:\n                start=test\n                base-=self.bit[test]\n        return end-1\n\nn=int(input())\ns=input()\n\nalice=[int(s[i]==\"0\") for i in range(n)]\nbob=[int(s[i]==\"1\") for i in range(n)]\nfor i in range(1,n):\n    alice[i]+=alice[i-1]\n    bob[i]+=bob[i-1]\nalice.append(0)\nbob.append(0)\n\nupdate_que=[[] for i in range(n)]\n\nalice_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"0\":\n        pos=id\n        while pos<n and s[pos]!=\"0\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\nbob_win=[]\nid=0\nwhile id<n:\n    if s[id]!=\"1\":\n        pos=id\n        while pos<n and s[pos]!=\"1\":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\n\nbst=bitset(n)\nbst.append(n)\n\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    for id in update_que[i]:\n        bst.append(id)\n    pos=0\n    res=0\n    while pos<n-i:\n        check1=alice[pos+i]-alice[pos-1]\n        check2=bob[pos+i]-bob[pos-1]\n        if not check1 or not check2:\n            res+=1\n            pos+=i+1\n        else:\n            npos=bst.next(pos)\n            if npos==n:\n                break\n            else:\n                pos=npos+i+1\n                res+=1\n    ans[i]=res\n\nprint(*ans)\n"]
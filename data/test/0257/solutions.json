["import sys\nfrom itertools import combinations\nfrom math import sqrt\nimport numpy as np\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\ndef main():\n    N, K, *xyc = list(map(int, read().split()))\n    x = xyc[::3]\n    y = xyc[1::3]\n    xy = list(zip(x, y))\n    c = xyc[2::3]\n    left = 0\n    right = 10 ** 6\n    delta = 0.1 ** 7\n    while right - left > delta:\n        mid = (left + right) / 2\n        intersections = []\n        r = [(mid / i) ** 2 for i in c]\n        for i, j in combinations(list(range(N)), 2):\n            x1, y1 = xy[i]\n            x2, y2 = xy[j]\n            X = x2 - x1\n            Y = y2 - y1\n            XY = X ** 2 + Y ** 2\n            r1 = r[i]\n            r2 = r[j]\n\n            a = (XY + r1 - r2) / 2\n            b = XY * r1 - a ** 2\n            if b < delta:\n                continue\n            b = sqrt(b)\n            xi1 = (a * X + Y * b) / XY + x1\n            yi1 = (a * Y - X * b) / XY + y1\n            xi2 = (a * X - Y * b) / XY + x1\n            yi2 = (a * Y + X * b) / XY + y1\n            intersections.append((xi1, yi1))\n            intersections.append((xi2, yi2))\n\n        intersections.extend(xy)\n        intersections = np.array(intersections, np.float)\n        cnt = np.zeros(len(intersections), np.int64)\n\n        for (i, j), k in zip(xy, r):\n            XY = (intersections[:, 0] - i) ** 2 + (intersections[:, 1] - j) ** 2\n            cnt[XY < k + delta] += 1\n\n        if np.any(cnt >= K):\n            right = mid\n        else:\n            left = mid\n\n    print(right)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import hypot\n\ndef solve():\n    N, K = list(map(int, input().split()))\n    xs, ys, cs = [], [], []\n    for _ in range(N):\n        x, y, c = list(map(int, input().split()))\n        xs.append(x)\n        ys.append(y)\n        cs.append(c)\n\n    EPS = 10**-10\n    def isLE(a, b):\n        return not (a > b+EPS)\n\n    def getIntersectionLCs(a, b, c, xC, yC, r):\n        e = a*xC + b*yC + c\n        ab2 = a**2 + b**2\n        v = r**2 * ab2 - e**2\n        if v < 0:\n            return []\n        elif v == 0:\n            xP = xC + -a*e / ab2\n            yP = yC + -b*e / ab2\n            return [(xP, yP)]\n        else:\n            v = v**0.5\n            ae, be = a*e, b*e\n            av, bv = a*v, b*v\n            xP1 = xC + (-ae + bv) / ab2\n            yP1 = yC + (-be - av) / ab2\n            xP2 = xC + (-ae - bv) / ab2\n            yP2 = yC + (-be + av) / ab2\n            return [(xP1, yP1), (xP2, yP2)]\n\n    def getIntersectionCCs(x1, y1, r1, x2, y2, r2):\n        xC, yC = x2-x1, y2-y1\n        c = -(xC**2 + yC**2 + r1**2 - r2**2) / 2\n        intCCs = getIntersectionLCs(xC, yC, c, 0, 0, r1)\n        intCCs = [(x1 + x, y1 + y) for x, y in intCCs]\n        return intCCs\n\n    def countNum(xP, yP, xs, ys, rs, K):\n        num = 0\n        for i, (x, y, r) in enumerate(zip(xs, ys, rs), start=1):\n            dist = hypot(x-xP, y-yP)\n            if isLE(dist, r):\n                num += 1\n            if num >= K:\n                return True\n            elif num+N-i < K:\n                return False\n        return num >= K\n\n    def isOK(t):\n        rs = [t/c for c in cs]\n\n        for xP, yP in zip(xs, ys):\n            if countNum(xP, yP, xs, ys, rs, K):\n                return True\n\n        for i in range(N):\n            x1, y1, r1 = xs[i], ys[i], rs[i]\n            for j in range(i+1, N):\n                x2, y2, r2 = xs[j], ys[j], rs[j]\n                intCCs = getIntersectionCCs(x1, y1, r1, x2, y2, r2)\n                for xP, yP in intCCs:\n                    if countNum(xP, yP, xs, ys, rs, K):\n                        return True\n\n        return False\n\n    ng, ok = 0, 2*10**5\n    while abs(ok-ng) > 10**-7:\n        mid = (ng+ok) / 2\n        if isOK(mid):\n            ok = mid\n        else:\n            ng = mid\n\n    print(ok)\n\n\nsolve()\n", "from math import hypot\nfrom collections import deque\n\nN, K, *XYC = map(int, open(0).read().split())\nXYC = list(zip(*[iter(XYC)] * 3))\n\nQ = deque([(0, 0, 1000.0)])\n\nans = float(\"inf\")\nwhile Q:\n    X, Y, r = Q.popleft()\n    if ans * 0.9999995 > sorted(c * hypot(max(abs(X - x) - r, 0), max(abs(Y - y) - r, 0)) for x, y, c in XYC)[K - 1]:\n        ans = min(ans, sorted(c * hypot(X - x, Y - y) for x, y, c in XYC)[K - 1])\n        r /= 2\n        Q += [\n            (X + r, Y + r, r),\n            (X - r, Y + r, r),\n            (X + r, Y - r, r),\n            (X - r, Y - r, r),\n        ]\n\nprint(ans)", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    from math import hypot\n    from collections import deque\n\n    N, K = map(int, input().split())\n    XYC = [tuple(map(int, input().split())) for _ in range(N)]\n\n    dq = deque([(0, 0, 1000.0)])\n\n    ans = 10**18\n    while dq:\n        X, Y, r = dq.popleft()\n        c_hypot = [c * hypot(max(abs(X - x) - r, 0), max(abs(Y - y) - r, 0)) for x, y, c in XYC]\n        c_hypot.sort()\n        if ans * 0.9999995 > c_hypot[K-1]:\n            c_hypot = [c * hypot(X - x, Y - y) for x, y, c in XYC]\n            c_hypot.sort()\n            if c_hypot[K-1] < ans:\n                ans = c_hypot[K-1]\n\n            r /= 2\n            dq += [\n                (X + r, Y + r, r),\n                (X - r, Y + r, r),\n                (X + r, Y - r, r),\n                (X - r, Y - r, r),\n            ]\n    print(ans)\n\nmain()", "import sys\nfrom itertools import combinations\nfrom math import atan2, cos, sin\n\n\ndef apollonius(p1, c1, p2, c2):\n    m1 = p1 + (p2 - p1) * c2 / (c1 + c2)\n    m2 = p1 + (p2 - p1) * c2 / (c2 - c1)\n    m = (m1 + m2) / 2\n    r = abs(m1 - m)\n    return m, r\n\n\ndef apollonius_intersections(p1, c1, p2, c2, p3, c3):\n    m12, r12 = apollonius(p1, c1, p2, c2)\n    m13, r13 = apollonius(p1, c1, p3, c3)\n    v = m13 - m12\n    d = abs(v)\n    if d > r12 + r13 or d < abs(r12 - r13):\n        return None, None\n    theta = atan2(v.imag, v.real)\n    xx = (r12 ** 2 - r13 ** 2 + d ** 2) / (2 * d)\n    s = (r12 + r13 + d) / 2\n    yy = 2 * (s * (s - r12) * (s - r13) * (s - d)) ** 0.5 / d\n    st = sin(theta)\n    ct = cos(theta)\n    e1 = (xx * ct - yy * st) + (xx * st + yy * ct) * 1j + m12\n    e2 = (xx * ct + yy * st) + (xx * st - yy * ct) * 1j + m12\n\n    t1 = abs(e1 - p1) * c1\n    t2 = abs(e2 - p1) * c1\n    if t1 < t2:\n        return e1, t1\n    return e2, t2\n\n\ndef get_circumscribed_center(p1, p2, p3):\n    A = abs(p2 - p3) ** 2\n    B = abs(p3 - p1) ** 2\n    C = abs(p1 - p2) ** 2\n    T = A * (B + C - A)\n    U = B * (C + A - B)\n    W = C * (A + B - C)\n    # Debug\n    try:\n        return (T * p1 + U * p2 + W * p3) / (T + U + W)\n    except:\n        return 0j\n\n\ndef solve(n, k, xyc):\n    if k == 1:\n        return 0\n\n    xxx = xyc[0::3]\n    yyy = xyc[1::3]\n    ccc = xyc[2::3]\n    beefs = [(i, x + y * 1j, c) for i, (x, y, c) in enumerate(zip(xxx, yyy, ccc))]\n\n    ans = 1e18\n    for (i1, p1, c1), (i2, p2, c2) in combinations(beefs, 2):\n        # \u80892\u679a\u306e\u6bd4\u91cd\u3092\u8003\u616e\u3057\u305f\u7b49\u8ddd\u96e2\u70b9\u306b\u71b1\u6e90\u3092\u7f6e\u3044\u305f\u3068\u304d\u306e\u6642\u9593t\u3092\u7b97\u51fa\n        # \u2192t\u4ee5\u5185\u306b\u713c\u3051\u308b\u8089\u304cK\u4ee5\u4e0a\u3042\u308c\u3070\u3001\u305d\u306e2\u679a\u3092\u542b\u3080\u5834\u5408\u306e\u6700\u5c0f\u6642\u9593\u306ft\n        px = p1 + (p2 - p1) * (c2 / (c1 + c2))\n        t = abs(px - p1) * c1 + 1e-8\n\n        ok = 0\n        ng = []\n        for i, p, c in beefs:\n            if abs(px - p) * c <= t:\n                ok += 1\n            else:\n                ng.append(i)\n        if ok >= k:\n            ans = min(ans, t)\n            continue\n\n        # RE\u304c\u51fa\u308b\u3002\u539f\u56e0\u306f\u3053\u3053\u4ee5\u4e0b\n\n        # K\u679a\u4ee5\u4e0a\u306a\u3044\u5834\u5408\u3001\u7bc4\u56f2\u5916\u306e\u3069\u308c\u304b\u306e\u8089\u3092\u30ae\u30ea\u30ae\u30ea\u542b\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b\n        # \uff08\u91cd\u8907\u3092\u9632\u3050\u305f\u3081\u3001j > i2 \u306e\u8089\u3092\u8abf\u3079\u308b\uff09\n        # 2\u70b9\u304b\u3089\u306e\u6bd4\u304c\u7b49\u3057\u3044\u70b9\u306e\u8ecc\u8de1\u306f\u3001c1==c2\u306a\u3089\u5782\u76f4\u4e8c\u7b49\u5206\u7dda\u3001\u305d\u308c\u4ee5\u5916\u306f\u30a2\u30dd\u30ed\u30cb\u30a6\u30b9\u306e\u5186\n        # p1-p2, p2-p3, p3-p1 \u306e3\u5186\uff08\u307e\u305f\u306f\u76f4\u7dda\uff09\u304c1\u70b9\u3067\u4ea4\u308f\u308b\u7b87\u6240\u304c\u3042\u308b\u304b\n        # \u3042\u308b \u2192 \u305d\u3053\u306b\u71b1\u6e90\u3092\u7f6e\u304d\u3001\u6642\u9593t\u3092\u7b97\u51fa\u3001t\u4ee5\u5185\u306b\u713c\u3051\u308b\u8089\u304cK\u4ee5\u4e0a\u3042\u308b\u304b\u8abf\u3079\u308b\n        # \u306a\u3044 \u2192 \u4ed6\u306e2\u70b9\u307e\u305f\u306f3\u70b9\u3067\u8003\u3048\u305f\u65b9\u304c\u3088\u3044\n        for i3 in ng:\n            if i3 < i2:\n                continue\n            _, p3, c3 = beefs[i3]\n            if c1 == c2:\n                if c2 == c3:\n                    e = get_circumscribed_center(p1, p2, p3)\n                    t = abs(e - p1) * c1\n                else:\n                    e, t = apollonius_intersections(p3, c3, p1, c1, p2, c2)\n            elif c1 == c3:\n                e, t = apollonius_intersections(p2, c2, p1, c1, p3, c3)\n            else:\n                e, t = apollonius_intersections(p1, c1, p2, c2, p3, c3)\n\n            if e is None:\n                continue\n\n            t += 1e-8\n            ok2 = 0\n            for i, p, c in beefs:\n                if abs(e - p) * c <= t:\n                    ok2 += 1\n            if ok2 >= k:\n                ans = min(ans, t)\n\n    return ans\n\n\nn, k = list(map(int, input().split()))\nxyc = list(map(int, sys.stdin.read().split()))\nprint((solve(n, k, xyc)))\n", "from math import hypot\nfrom collections import deque\n\nN, K, *XYC = map(int, open(0).read().split())\nXYC = list(zip(*[iter(XYC)] * 3))\n\nQ = deque([(0, 0, 1000.0)])\n\nans = float(\"inf\")\nwhile Q:\n    X, Y, r = Q.popleft()\n    if ans * 0.9999995 > sorted(c * hypot(max(abs(X - x) - r, 0), max(abs(Y - y) - r, 0)) for x, y, c in XYC)[K - 1]:\n        ans = min(ans, sorted(c * hypot(X - x, Y - y) for x, y, c in XYC)[K - 1])\n        for dx, dy in [(-0.5, -0.5), (-0.5, 0.5), (0.5, -0.5), (0.5, 0.5)]:\n            Q.append((X + dx * r, Y + dy * r, r / 2))\n\nprint(ans)", "# \u591a\u304f\u3066\u3082 3 \u3064\u304c\u304e\u308a\u304e\u308a\u713c\u3051\u308b\u4f4d\u7f6e\nfrom math import acos\nfrom cmath import exp\nfrom itertools import combinations\nN, K = list(map(int, input().split()))\nXYC = []\nfor _ in range(N):\n    x, y, c = list(map(int, input().split()))\n    XYC.append((complex(x, y), c))\nif K==1:\n    print((0))\n    return\nans = 1e300\neps = 1e-7\nfor (p1, c1), (p2, c2) in combinations(XYC, 2):\n    p_center = (p1 * c1 + p2 * c2) / (c1 + c2)\n    t = abs(p_center-p1) * c1\n    k = 0\n    for xy, c in XYC:\n        if abs(p_center-xy) * c < t + eps:\n            k += 1\n    if k >= K and t < ans:\n        ans = t\n\ndef get_center(p1, p2, p3, c1, c2, c3):\n    if c1 == c2 == c3:\n        t1, t2, t3 = p2-p3, p3-p1, p1-p2\n        denom = (t1*p1.conjugate()+t2*p2.conjugate()+t3*p3.conjugate())\n        if denom == 0:\n            return []\n        return [(t1*abs(p1)**2+t2*abs(p2)**2+t3*abs(p3)**2) / denom]\n    elif c1 == c3:\n        c2, c3 = c3, c2\n        p2, p3 = p3, p2\n    elif c2 == c3:\n        c1, c3 = c3, c1\n        p1, p3 = p3, p1\n    o1 = (c1*c1*p1-c3*c3*p3)/(c1*c1-c3*c3)\n    r1 = (c1*c3*abs(p1-p3))/abs(c1*c1-c3*c3)\n    o2 = (c2*c2*p2-c3*c3*p3)/(c2*c2-c3*c3)\n    r2 = (c2*c3*abs(p2-p3))/abs(c2*c2-c3*c3)\n    l = abs(o1-o2)\n    if r1+r2 < l or l+r1<r2 or l+r2<r1:\n        return []\n    cos_a = (r1*r1+l*l-r2*r2)/(2*r1*l)\n    a = acos(cos_a)\n    res1 = o1 + (o2-o1) * exp(a*1j) * r1 / l\n    res2 = o1 + (o2-o1) * exp(-a*1j) * r1 / l\n    return [res1, res2]\n\nfor (p1, c1), (p2, c2), (p3, c3) in combinations(XYC, 3):\n    p_centers = get_center(p1, p2, p3, c1, c2, c3)\n    for p_center in p_centers:\n        t = abs(p1 - p_center) * c1\n        # print(abs(p1 - p_center) * c1,\n        #       abs(p2 - p_center) * c2,\n        #       abs(p3 - p_center) * c3)\n        k = 0\n        for p, c in XYC:\n            if abs(p_center - p) * c < t + eps:\n                k += 1\n        if k >= K and t < ans:\n            ans = t\n\nprint(ans)\n", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\nimport math\nfrom itertools import combinations\n\ndef run():\n    N, K = map(int, sysread().split())\n    niku = []\n    for i in range(N):\n        niku.append([i]+list(map(int, sysread().split())))\n\n    high_t = math.sqrt(2000**2 + 2000**2) * 101\n    low_t = 0\n    current = (high_t + low_t) / 2\n    delta = 5e-7\n    if K == 1:\n        print(0)\n        return None\n\n    while high_t - low_t > delta:\n        done = False\n        c = [(current / ci) ** 2 for _, _, _, ci in niku]\n        for i, xi, yi, _ in niku:\n            if done:\n                break\n            K0 = 0\n            for k, xk, yk, _ in niku:\n                if done:\n                    break\n                ck = c[k]\n                if ((xi - xk) ** 2 + (yi - yk) ** 2) <= ck + delta:\n                    K0 += 1\n                if K0 >= K:\n                    done = True\n\n\n        for (i, xi, yi, _), (j, xj, yj, _) in combinations(niku, 2):\n            if done:\n                break\n            ci, cj = c[i], c[j]\n            xj -= xi\n            yj -= yi\n            d2 = xj ** 2 + yj ** 2\n            d = math.sqrt(d2)\n\n            x = (d2 + ci - cj) / (2 * d)\n            e = ci - x ** 2\n            if e < 0 or math.sqrt(ci) + math.sqrt(cj) < d:\n                continue\n            else:\n                e = math.sqrt(e)\n\n            vx1, vy1 = xj / d, yj / d\n            vx2, vy2 = yj / d, -xj / d\n\n            X1 = vx1 * x + vx2 * e + xi\n            X2 = vx1 * x - vx2 * e + xi\n            Y1 = vy1 * x + vy2 * e + yi\n            Y2 = vy1 * x - vy2 * e + yi\n\n            K1 = 0\n            K2 = 0\n\n            for k, xk, yk, _ in niku:\n                if done:\n                    break\n                ck = c[k]\n                if ((xk - X1) ** 2 + (yk - Y1) ** 2) <= ck + delta:\n                    K1 += 1\n                if ((xk - X2) ** 2 + (yk - Y2) ** 2) <= ck + delta:\n                    K2 += 1\n                if K1 >= K or K2 >= K:\n                    done = True\n\n\n        if done:\n            high_t = current\n            current = (high_t + low_t) / 2\n        else:\n            low_t = current\n            current = (high_t + low_t) / 2\n\n    print((low_t + high_t) / 2)\n    return None\n\ndef __starting_point():\n    run()\n__starting_point()", "import math\n\nn, k = map(int, input().split())\nx, y, c = zip(*[map(int, input().split()) for _ in range(n)])\nque = [(0, 0, 1000)]\nres = 1e9\ni = 0\nwhile i < len(que):\n    px, py, r = que[i]\n    i += 1\n    lb = [c[j] * math.hypot(max(abs(px - x[j]) - r, 0), max(abs(py - y[j]) - r, 0)) for j in range(n)]\n    if res * (1 - 5e-7) > sorted(lb)[k - 1]:\n        dis = [c[j] * math.hypot(px - x[j], py - y[j]) for j in range(n)]\n        res = min(res, sorted(dis)[k - 1])\n        for dx in (-0.5, 0.5):\n            for dy in (-0.5, 0.5):\n                que.append((px + dx * r, py + dy * r, r / 2))\nprint(res)", "import sys\nfrom itertools import combinations\nfrom math import atan2, cos, sin\n\n\ndef apollonius(p1, c1, p2, c2):\n    m1 = p1 + (p2 - p1) * c2 / (c1 + c2)\n    m2 = p1 + (p2 - p1) * c2 / (c2 - c1)\n    m = (m1 + m2) / 2\n    r = abs(m1 - m)\n    return m, r\n\n\ndef apollonius_intersections(p1, c1, p2, c2, p3, c3):\n    m12, r12 = apollonius(p1, c1, p2, c2)\n    m13, r13 = apollonius(p1, c1, p3, c3)\n    v = m13 - m12\n    d = abs(v)\n    if d > r12 + r13 or d < abs(r12 - r13):\n        return None, None\n    theta = atan2(v.imag, v.real)\n    xx = (r12 ** 2 - r13 ** 2 + d ** 2) / (2 * d)\n    s = (r12 + r13 + d) / 2\n    yy = 2 * (s * (s - r12) * (s - r13) * (s - d)) ** 0.5 / d\n    st = sin(theta)\n    ct = cos(theta)\n    e1 = (xx * ct - yy * st) + (xx * st + yy * ct) * 1j + m12\n    e2 = (xx * ct + yy * st) + (xx * st - yy * ct) * 1j + m12\n\n    t1 = abs(e1 - p1) * c1\n    t2 = abs(e2 - p1) * c1\n    if t1 < t2:\n        return e1, t1\n    return e2, t2\n\n\ndef get_circumscribed_center(p1, p2, p3):\n    A = abs(p2 - p3) ** 2\n    B = abs(p3 - p1) ** 2\n    C = abs(p1 - p2) ** 2\n    T = A * (B + C - A)\n    U = B * (C + A - B)\n    W = C * (A + B - C)\n    try:\n        return (T * p1 + U * p2 + W * p3) / (T + U + W)\n    except:\n        return 0j\n\n\ndef solve(n, k, xyc):\n    if k == 1:\n        return 0\n\n    xxx = xyc[0::3]\n    yyy = xyc[1::3]\n    ccc = xyc[2::3]\n    beefs = [(i, x + y * 1j, c) for i, (x, y, c) in enumerate(zip(xxx, yyy, ccc))]\n\n    ans = 1e18\n    for (i1, p1, c1), (i2, p2, c2) in combinations(beefs, 2):\n        # \u80892\u679a\u306e\u6bd4\u91cd\u3092\u8003\u616e\u3057\u305f\u7b49\u8ddd\u96e2\u70b9\u306b\u71b1\u6e90\u3092\u7f6e\u3044\u305f\u3068\u304d\u306e\u6642\u9593t\u3092\u7b97\u51fa\n        # \u2192t\u4ee5\u5185\u306b\u713c\u3051\u308b\u8089\u304cK\u4ee5\u4e0a\u3042\u308c\u3070\u3001\u305d\u306e2\u679a\u3092\u542b\u3080\u5834\u5408\u306e\u6700\u5c0f\u6642\u9593\u306ft\n        px = p1 + (p2 - p1) * (c2 / (c1 + c2))\n        t = abs(px - p1) * c1 + 1e-8\n\n        ok = 0\n        ng = []\n        for i, p, c in beefs:\n            if abs(px - p) * c <= t:\n                ok += 1\n            else:\n                ng.append(i)\n        if ok >= k:\n            ans = min(ans, t)\n            continue\n        # p1,p2\u306e2\u70b9\u3092\u542b\u3080\u5834\u5408\u306e\u6642\u9593\u306f\u3001\u3053\u308c\u4ee5\u4e0a\u5c0f\u3055\u304f\u306a\u3089\u306a\u3044\n        if ans <= t:\n            continue\n\n        # K\u679a\u4ee5\u4e0a\u306a\u3044\u5834\u5408\u3001\u7bc4\u56f2\u5916\u306e\u3069\u308c\u304b\u306e\u8089\u3092\u30ae\u30ea\u30ae\u30ea\u542b\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b\n        # \uff08\u91cd\u8907\u3092\u9632\u3050\u305f\u3081\u3001j > i2 \u306e\u8089\u3092\u8abf\u3079\u308b\uff09\n        # 2\u70b9\u304b\u3089\u306e\u6bd4\u304c\u7b49\u3057\u3044\u70b9\u306e\u8ecc\u8de1\u306f\u3001c1==c2\u306a\u3089\u5782\u76f4\u4e8c\u7b49\u5206\u7dda\u3001\u305d\u308c\u4ee5\u5916\u306f\u30a2\u30dd\u30ed\u30cb\u30a6\u30b9\u306e\u5186\n        # p1-p2, p2-p3, p3-p1 \u306e3\u5186\uff08\u307e\u305f\u306f\u76f4\u7dda\uff09\u304c1\u70b9\u3067\u4ea4\u308f\u308b\u7b87\u6240\u304c\u3042\u308b\u304b\n        # \u3042\u308b \u2192 \u305d\u3053\u306b\u71b1\u6e90\u3092\u7f6e\u304d\u3001\u6642\u9593t\u3092\u7b97\u51fa\u3001t\u4ee5\u5185\u306b\u713c\u3051\u308b\u8089\u304cK\u4ee5\u4e0a\u3042\u308b\u304b\u8abf\u3079\u308b\n        # \u306a\u3044 \u2192 \u4ed6\u306e2\u70b9\u307e\u305f\u306f3\u70b9\u3067\u8003\u3048\u305f\u65b9\u304c\u3088\u3044\n        for i3 in ng:\n            if i3 < i2:\n                continue\n            _, p3, c3 = beefs[i3]\n            if c1 == c2:\n                if c2 == c3:\n                    e = get_circumscribed_center(p1, p2, p3)\n                    t = abs(e - p1) * c1\n                else:\n                    e, t = apollonius_intersections(p3, c3, p1, c1, p2, c2)\n            elif c1 == c3:\n                e, t = apollonius_intersections(p2, c2, p1, c1, p3, c3)\n            else:\n                e, t = apollonius_intersections(p1, c1, p2, c2, p3, c3)\n\n            if e is None:\n                continue\n\n            t += 1e-8\n            ok2 = 0\n            for i, p, c in beefs:\n                if abs(e - p) * c <= t:\n                    ok2 += 1\n            if ok2 >= k:\n                ans = min(ans, t)\n\n    return ans\n\n\nn, k = list(map(int, input().split()))\nxyc = list(map(int, sys.stdin.read().split()))\nprint((solve(n, k, xyc)))\n", "import sys\nfrom itertools import combinations\nfrom math import sqrt\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\ndef main():\n    N, K, *xyc = map(int, read().split())\n    x = xyc[::3]\n    y = xyc[1::3]\n    xy = list(zip(x, y))\n    c = xyc[2::3]\n    left = 0\n    right = 10 ** 6\n    delta = 0.1 ** 7\n    while right - left > delta:\n        mid = (left + right) / 2\n        intersections = []\n        r = [(mid / i) ** 2 for i in c]\n        for i, j in combinations(range(N), 2):\n            x1, y1 = xy[i]\n            x2, y2 = xy[j]\n            X = x2 - x1\n            Y = y2 - y1\n            XY = X ** 2 + Y ** 2\n            r1 = r[i]\n            r2 = r[j]\n\n            a = (XY + r1 - r2) / 2\n            b = XY * r1 - a ** 2\n            if b < delta:\n                continue\n            b = sqrt(b)\n            xi1 = (a * X + Y * b) / XY + x1\n            yi1 = (a * Y - X * b) / XY + y1\n            xi2 = (a * X - Y * b) / XY + x1\n            yi2 = (a * Y + X * b) / XY + y1\n            intersections.append((xi1, yi1))\n            intersections.append((xi2, yi2))\n\n        intersections.extend(xy)\n        cnt = 0\n        for X, Y in intersections:\n            tmp = 0\n            for (i, j), k in zip(xy, r):\n                XY = (X - i) ** 2 + (Y - j) ** 2\n                if XY < k + delta:\n                    tmp += 1\n            cnt = max(tmp, cnt)\n            if cnt >= K:\n                break\n        if cnt >= K:\n            right = mid\n        else:\n            left = mid\n\n    print(right)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\ndef intersectionCC0(x1, y1, r1, r2):\n    r = x1**2 + y1**2\n    t = (r + r1**2 - r2**2) / (2*r)\n    dd = r1**2/r - t**2\n    if - (10**-8) < dd < 0: dd = 0\n    if dd < 0: return []\n    x, y = t * x1, t * y1\n    if dd == 0: return [(x, y)]\n    sq = math.sqrt(dd)\n    dx, dy = y1 * sq, -x1 * sq\n    return [(x+dx, y+dy), (x-dx, y-dy)]\n\ndef intersectionCC(x1, y1, x2, y2, r1, r2):\n    return [(x1+x, y1+y) for x, y in intersectionCC0(x2-x1, y2-y1, r1, r2)]\n\ndef chk(t):\n    L = [a for a in L0]\n    for i, (x1, y1, c1) in enumerate(X):\n        for x2, y2, c2 in X[:i]:\n            L += intersectionCC(x1, y1, x2, y2, t/c1, t/c2)\n    for x0, y0 in L:\n        cnt = 0\n        for x, y, c in X:\n            if math.sqrt((x-x0) ** 2 + (y-y0) ** 2) * c <= t + 10**-8:\n                cnt += 1\n        if cnt >= K: return 1\n    return 0\n\nN, K = map(int, input().split())\nX = []\nL0 = []\nfor _ in range(N):\n    x, y, c = map(int, input().split())\n    X.append((x, y, c))\n    L0.append((x, y))\n\nl, r = 0, 150000\nwhile (r-l) * (1<<20) > max(1, l):\n    m = (l+r) / 2\n    if chk(m):\n        r = m\n    else:\n        l = m\n    \nprint((l+r)/2)", "import numpy as np\nfrom scipy.optimize import fmin\n\nn,k=list(map(int,input().split()))\nXYC=[list(map(int,input().split())) for i in range(n)]\nX,Y,C=[],[],[]\nfor x,y,c in XYC:\n    X.append(x)\n    Y.append(y)\n    C.append(c)\nX=np.array(X,dtype=np.float)\nY=np.array(Y,dtype=np.float)\nC=np.array(C,dtype=np.float)\ndef f(xy):\n    x,y=xy\n    times=(X-x)*(X-x)+(Y-y)*(Y-y)\n    times=C*np.sqrt(times)\n    times=np.sort(times)\n    return times[k-1]\ndeff=0.5\nansx=[fmin(f,(x,y),disp=False,ftol=10**(-7),initial_simplex=[(x+deff,y),(x-deff,y+deff),(x-deff,y-deff)]) for x,y,c in XYC]\nansy=list([f(x) for x in ansx])\nprint((min(ansy)))\n", "N,K = map(int,input().split())\nXYC = [tuple(map(int,input().split())) for i in range(N)]\n\nfrom math import hypot,acos,atan2,cos,sin\ndef circles_cross_points(x1,y1,r1,x2,y2,r2):\n    d = hypot(x1-x2, y1-y2)\n    if r1 + r2 < d or abs(r1 - r2) >= d: return []\n    x = (r1**2 + d**2 - r2**2) / (2*r1*d)\n    if not -1 <= x <= 1: return []\n    a = acos(x)\n    t = atan2(y2-y1, x2-x1)\n    return [\n        (x1+cos(t+a)*r1, y1+sin(t+a)*r1),\n        (x1+cos(t-a)*r1, y1+sin(t-a)*r1)\n    ]\n\neps = 10e-10\ndef is_ok(t):\n    cands = []\n    for x,y,_ in XYC:\n        cands.append((x,y))\n    for i,(x1,y1,c1) in enumerate(XYC[:-1]):\n        for x2,y2,c2 in XYC[i+1:]:\n            ps = circles_cross_points(x1,y1,t/c1,x2,y2,t/c2)\n            cands += ps\n    for cx,cy in cands:\n        k = 0\n        for x,y,c in XYC:\n            d = hypot(cx-x,cy-y)\n            if c*d <= t + eps:\n                k += 1\n                if k >= K:\n                    return True\n    return False\n\nok = 10**10\nng = 0\nfor _ in range(100):\n    m = (ok+ng)/2\n    if is_ok(m):\n        ok = m\n    else:\n        ng = m\n    if ok-ng < 10e-7: break\nprint(ok)"]
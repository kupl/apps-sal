["import sys\nfrom heapq import heappush, heappop\n\nn = int(input())\na = list(map(int, input().split()))\n\ncount = {}\n\nfor x in a:\n\tif x in count:\n\t\tcount[x] = count[x] + 1\n\telse:\n\t\tcount[x] = 1\n\ncount = sorted(list(count.items()))\n#print(count)\n\ncost= list(map(int, input().split()))\nmax_cost = max(cost)\n\na = list(zip(a, cost))\na = sorted(a)\npriority = list([max_cost - x for x in [x[1] for x in a]])\na = list(zip(priority, a))\n\ni = 0\nqueue = []\nqueue_cost = 0\nresult = 0\n\n#print(a)\n\nfor j in range(len(count)):\n\tx, c = count[j]\n\t#print('x = ', x)\n\twhile i < len(a) and a[i][1][0] == x:\n\t\tqueue_cost += a[i][1][1]\n\t\theappush(queue, a[i])\n\t\ti += 1\n\n\t#print('queue = ', queue)\n\ty = x\n\twhile len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\n\t\tpopped = heappop(queue)\n\t\t#print(popped, queue)\n\t\tqueue_cost -= popped[1][1]\n\t\t#print(queue_cost)\n\t\tresult += queue_cost\n\t\ty += 1\n\n# while len(queue) > 0:\n# \tpopped = heappop(queue)\n# \tqueue_cost -= popped[1][1]\n# \tresult += queue_cost\n\nprint(result)\n", "from heapq import *\nn = int(input())\n_a = list(map(int, input().split(\" \")))\n_t = list(map(int, input().split(\" \")))\nat = [[0, 0]]\nfor i in range(n):\n    at.append([_a[i], _t[i]])\nat.append([int(1e11), 0])\nat.sort()\n\ndef __starting_point():\n    Q = []\n    s = 0\n    cost  = 0\n    for i in range(1, n+2):\n        a = at[i-1]\n        b = at[i]\n        num = a[0]\n        while len(Q) > 0 and num < b[0]:\n            s += heappop(Q)\n            num += 1\n            cost += s\n        s += b[1]\n        heappush(Q, -b[1])\n        #print(\"{}, {}, {}\".format(i, s, cost))\n    print(cost)\n\n__starting_point()", "import sys\nimport heapq\nfrom collections import defaultdict\nn=int(sys.stdin.readline())\narr=list(map(int,sys.stdin.readline().split()))\ncost=list(map(int,sys.stdin.readline().split()))\nfor i in range(n):\n    arr[i]=[arr[i],cost[i]]\narr.sort()\nl=[]\nheapq.heapify(l)\nprev=0\nans=0\ns=0\n#print(arr,'arr')\nfor i in range(n):\n    #print(l,'l',s,ans)\n    while l and prev<arr[i][0]:\n        s-=(l[0])\n        ans+=(-s)\n        prev+=1\n        heapq.heappop(l)\n    prev=arr[i][0]\n    s+=(-arr[i][1])\n    heapq.heappush(l,-arr[i][1])\nwhile l:\n    s-=(l[0])\n    ans+=(-s)\n    heapq.heappop(l)\nprint(ans)\n", "#!python3\n\"\"\"\nAuthor: w1ld [at] inbox [dot] ru\n\"\"\"\n\nfrom collections import deque, Counter\nimport array\nfrom itertools import combinations, permutations\nfrom math import sqrt\nfrom heapq import heappush as push, heappop as pop\n# import unittest\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_int_array():\n    return [int(i) for i in input().strip().split(' ')]\n\n######################################################\n\nn = read_int()\na = read_int_array()\nt = read_int_array()\nsrt = list(sorted((a[i], t[i]) for i in range(n)))\ncnt = [(-srt[0][1], 0)]\ni = 1\ncntValue = srt[0][0]\nans = 0\nwhile cnt or i < n:\n    if i < n and srt[i][0] == cntValue:\n        push(cnt, (-srt[i][1], i))\n        i += 1\n    elif any(cnt):\n        ti, inx = pop(cnt)\n        ti = -ti\n        ans += (cntValue - srt[inx][0]) * ti\n        cntValue += 1\n    else:\n        cntValue = srt[i][0]\nprint(ans)\n\n\n\n\n\n", "import heapq\nh = []\nn = int(input())\na = [int(x) for x in input().strip().split()]\nt = [int(x) for x in input().strip().split()]\nfor i in range(len(t)):\n    a[i] = [a[i], t[i]]\na.sort(key = lambda x: (x[0], -x[1]))\nprev, i, ans= a[0][0], 1, 0\n#print(a)\nwhile(i<len(a)):\n    #print(prev, ans, h)\n    if h:\n        if a[i][0] == prev:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i += 1\n        elif a[i][0] == prev+1:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            p = heapq.heappop(h)\n            ans += (-p[0]*(prev + 1 - p[1]))\n            prev = prev+1\n            i += 1\n        else:\n            p = heapq.heappop(h)\n            ans += (-p[0]*(prev + 1 - p[1]))\n            prev = prev+1\n    else:\n        if a[i][0] != prev:\n            prev = a[i][0]\n            i+=1\n        else:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i+=1\nwhile h:\n    p = heapq.heappop(h)\n    ans += (-p[0]*(prev + 1 - p[1]))\n    prev = prev+1\nprint(ans)\n    \n", "import sys\ninput = sys.stdin.readline\nimport heapq\nh = []\nn = int(input())\na = [int(x) for x in input().strip().split()]\nt = [int(x) for x in input().strip().split()]\nfor i in range(len(t)):\n    a[i] = [a[i], t[i]]\na.sort(key = lambda x: (x[0], -x[1]))\nprev, i, ans= a[0][0], 1, 0\n#print(a)\nwhile(i<len(a)):\n    #print(prev, ans, h)\n    if h:\n        if a[i][0] == prev:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i += 1\n        elif a[i][0] == prev+1:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            p = heapq.heappop(h)\n            ans += (-p[0]*(prev + 1 - p[1]))\n            prev = prev+1\n            i += 1\n        else:\n            p = heapq.heappop(h)\n            ans += (-p[0]*(prev + 1 - p[1]))\n            prev = prev+1\n    else:\n        if a[i][0] != prev:\n            prev = a[i][0]\n            i+=1\n        else:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i+=1\nwhile h:\n    p = heapq.heappop(h)\n    ans += (-p[0]*(prev + 1 - p[1]))\n    prev = prev+1\nprint(ans)\n    \n", "# n = int(input())\n# a = [int(i) for i in input().split(' ')]\n# t = [int(i) for i in input().split(' ')]\n#\n# import collections\n# from heapq import heapify, heappop, heappush\n#\n#\n# l = collections.defaultdict(list)\n# at = [[a[i], t[i]] for i in range(n)]\n# at.sort(key = lambda x: x[0])\n# for aa, tt in at:\n#     l[aa].append(tt)\n#\n# for k in l.keys():\n#     heapify(l[k])\n#\n#\n# # print(at)\n# # print(l)\n# res = 0\n#\n# # tmp = []\n#\n# q = sorted(l.keys())[::-1]\n# while q:\n#     i = q.pop()\n#     # print(\"i\", i, l[i])\n#     # l[i].extend(tmp)\n#     if len(l[i]) == 1:\n#         continue\n#     else:\n#         tmp = sorted(l[i])\n#         sums = sum(tmp)\n#         # res += sums - maxx # leave the one with max time and increase all other by 1, cost their time\n#         idx = i\n#         while tmp and ((q and idx + 1 != q[-1]) or not q):\n#             # print(i, idx, q, tmp)\n#             p = tmp.pop()\n#             res += sums - p\n#             sums -= p\n#             idx += 1\n#         if tmp:\n#             p = tmp.pop()\n#             res += sums - p\n#             sums -= p\n#             l[idx+1].extend(tmp)\n#             if not q:\n#                 q.append(idx+1)\n# print(res)\n#\n#\n#\n#\n#\n#\n#\n\n\nimport sys\n\ninp = sys.stdin.readline\ninput = lambda: inp().strip()\n\n\n# flush= sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**6)\n# threading.stack_size(2**26)\n\ndef iin(): return int(input())\n\n\ndef lin(): return list(map(int, input().split()))\n\n\ndef main():\n    import heapq as hq\n    n = iin()\n    a = lin()\n    t = lin()\n    dc = {}\n    for i in range(n):\n        try:\n            dc[a[i]].append(t[i])\n        except:\n            dc[a[i]] = [t[i], ]\n    # print(dc)\n    sa = list(dc.keys())\n    sa.sort()\n    n = len(sa)\n    ch = 0\n    pt = sa[ch]\n    temp = []\n    sm = 0\n    ans = 0\n    hq.heapify(temp)\n    done = 0\n    while ch < n:\n        # print(temp, sa[ch])\n        pt = sa[ch]\n        if len(dc[pt]) > 1 or done:\n            a1 = sorted(dc[pt])\n            for item in a1:\n                hq.heappush(temp, -item)\n                sm += item\n            x = hq.heappop(temp) * (-1)\n            dc[pt] = [x]\n            sm -= x\n            while len(temp):\n                # print('A', ch, pt, temp )\n                ans += sm\n                pt += 1\n                if pt in dc:\n                    ch += 1\n                    done = 1\n                    break\n                else:\n                    x = hq.heappop(temp) * (-1)\n                    sm -= x\n            else:\n                done = 0\n        else:\n            ch += 1\n            done = 0\n    # print(dc)\n    print(ans)\n\nmain()\n", "n = int(input())\na = [int(i) for i in input().split(' ')]\nt = [int(i) for i in input().split(' ')]\n\nimport collections\nfrom heapq import heapify, heappop, heappush\n\n\nl = collections.defaultdict(list)\nat = [[a[i], t[i]] for i in range(n)]\nat.sort(key = lambda x: x[0])\nfor aa, tt in at:\n    l[aa].append(tt)\n\n\n\n# print(at)\n# print(l)\nres = 0\n\n# tmp = []\n\nq = sorted(l.keys())[::-1]\ntmp = []\nheapify(tmp)\nsums = 0\nwhile q:\n\n    i = q.pop()\n    if len(l[i]) == 1 and not tmp:\n        continue\n    else:\n        for ll in l[i]:\n            heappush(tmp, -ll)\n            sums += ll\n        idx = i\n        # print(i, idx, q, tmp, sums)\n        while tmp and ((q and idx + 1 != q[-1]) or not q):\n            # print(i, idx, q, tmp)\n            p = -heappop(tmp)\n            res += sums - p # leave the one with max time and increase all other by 1, cost their time\n            sums -= p\n            idx += 1\n        if tmp:\n            # print('tmp', i, tmp)\n            p = -heappop(tmp)\n            res += sums - p\n            sums -= p\n            # print(res, p)\n            # l[idx+1].extend(tmp)\n            if not q:\n                q.append(idx+1)\nprint(res)\n\n\n\n\n\n\n\n\n\n# import sys\n#\n# inp = sys.stdin.readline\n# input = lambda: inp().strip()\n#\n#\n# # flush= sys.stdout.flush\n# # import threading\n# # sys.setrecursionlimit(10**6)\n# # threading.stack_size(2**26)\n#\n# def iin(): return int(input())\n#\n#\n# def lin(): return list(map(int, input().split()))\n#\n#\n# def main():\n#     import heapq as hq\n#     n = iin()\n#     a = lin()\n#     t = lin()\n#     dc = {}\n#     for i in range(n):\n#         try:\n#             dc[a[i]].append(t[i])\n#         except:\n#             dc[a[i]] = [t[i], ]\n#     # print(dc)\n#     sa = list(dc.keys())\n#     sa.sort()\n#     n = len(sa)\n#     ch = 0\n#     pt = sa[ch]\n#     temp = []\n#     sm = 0\n#     ans = 0\n#     hq.heapify(temp)\n#     done = 0\n#     while ch < n:\n#         # print(temp, sa[ch])\n#         pt = sa[ch]\n#         if len(dc[pt]) > 1 or done:\n#             a1 = sorted(dc[pt])\n#             for item in a1:\n#                 hq.heappush(temp, -item)\n#                 sm += item\n#             x = hq.heappop(temp) * (-1)\n#             dc[pt] = [x]\n#             sm -= x\n#             while len(temp):\n#                 # print('A', ch, pt, temp )\n#                 ans += sm\n#                 pt += 1\n#                 if pt in dc:\n#                     ch += 1\n#                     done = 1\n#                     break\n#                 else:\n#                     x = hq.heappop(temp) * (-1)\n#                     sm -= x\n#             else:\n#                 done = 0\n#         else:\n#             ch += 1\n#             done = 0\n#     # print(dc)\n#     print(ans)\n#\n# main()\n"]
["class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n + 1)]\n        self.rank = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            if self.same_check(x, y) != True:\n                self.size[y] += self.size[x]\n                self.size[x] = 0\n            self.par[x] = y\n        else:\n            if self.same_check(x, y) != True:\n                self.size[x] += self.size[y]\n                self.size[y] = 0\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def siz(self, x):\n        x = self.find(x)\n        return self.size[x]\n\n\nN = int(input())\nUF = UnionFind(N)\nX = []\nY = []\nBranch = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    X.append((x, i))\n    Y.append((y, i))\nX.sort()\nY.sort()\nfor X1, X2 in zip(X, X[1:]):\n    Branch.append((X2[0] - X1[0], X1[1], X2[1]))\nfor Y1, Y2 in zip(Y, Y[1:]):\n    Branch.append((Y2[0] - Y1[0], Y1[1], Y2[1]))\nBranch.sort()\n\n# \u8ca0\u306e\u3068\u304d size, \u975e\u8ca0\u306e\u3068\u304d parent\npar = [-1] * N\nans = 0\nfor c, a, b in Branch:\n    if N <= 1:\n        break\n    if not UF.same_check(a, b):\n        UF.union(a, b)\n        ans += c\n        N -= 1\n\nprint(ans)\n\n", "import bisect\nimport copy\nimport heapq\nimport sys\nimport itertools\nimport math\nimport queue\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass UF:\n    def __init__(self, N):\n        self.state = [-1] * N\n        self.rank = [0] * N\n        self.num_group = N\n    \n    def get_parent(self, a):\n        p = self.state[a]\n        if p < 0:\n            return a\n        \n        q = self.get_parent(p)\n        self.state[a] = q\n        return q\n\n    def make_pair(self, a, b):\n        pa = self.get_parent(a)\n        pb = self.get_parent(b)\n        if pa == pb:\n            return\n\n        if self.rank[pa] > self.rank[pb]:\n            pa, pb = pb, pa\n            a, b = b, a\n        elif self.rank[pa] == self.rank[pb]:\n            self.rank[pb] += 1\n\n        self.state[pb] += self.state[pa]\n        self.state[pa] = pb\n        self.state[a] = pb\n        self.num_group -= 1\n    \n    def is_pair(self, a, b):\n        return self.get_parent(a) == self.get_parent(b)\n\n    def get_size(self, a):\n        return -self.state[self.get_parent(a)]\n\n\ndef main():\n    N = int(input())\n    X = []\n    Y = []\n    for i in range(N):\n        a, b = read_values()\n        X.append((a, i))\n        Y.append((b, i))\n    \n    X.sort()\n    Y.sort()\n\n    Q = []\n    for i in range(N - 1):\n        heapq.heappush(Q, (X[i + 1][0] - X[i][0], (X[i][1], X[i + 1][1])))\n        heapq.heappush(Q, (Y[i + 1][0] - Y[i][0], (Y[i][1], Y[i + 1][1])))\n\n    res = 0\n    uf = UF(N)\n    while uf.num_group != 1:\n        c, (a, b) = heapq.heappop(Q)\n\n        if not uf.is_pair(a, b):\n            res += c\n            uf.make_pair(a, b)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "class UnionFind:\n    def __init__(self, n):\n        self.v = [-1] * n\n\n    def find(self, x):\n        if self.v[x] < 0:\n            return x\n        else:\n            self.v[x] = self.find(self.v[x])\n            return self.v[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            if self.v[x] > self.v[y]:\n                x, y = y, x\n            self.v[x] += self.v[y]\n            self.v[y] = x\n            return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.v[self.find(x)]\n\n\ndef main():\n    from operator import itemgetter\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n\n    ps = []\n    xs = set()\n    ys = set()\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        ps.append((x, y))\n        xs.add(x)\n        ys.add(y)\n\n    xs = tuple(sorted(xs))\n    ys = tuple(sorted(ys))\n\n    dx = {e: i for i, e in enumerate(xs)}\n    dy = {e: i for i, e in enumerate(ys)}\n\n    uf = UnionFind(N * 2)\n    for x, y in ps:\n        uf.unite(dx[x], dy[y] + N)\n\n    def make_edges(xs, start):\n        xes = []\n        for i, (x0, x1) in enumerate(zip(xs, xs[1:]), start=start):\n            xes.append((abs(x1 - x0), i, i + 1))\n        return xes\n\n    xes = make_edges(xs, start=0)\n    yes = make_edges(ys, start=N)\n\n    # Kruskal\n    # \u6700\u5c0f\u30b3\u30b9\u30c8\u306e\u8fba\u304b\u3089\u9806\u306b\u4f7f\u7528\u3059\u308b\n    # \u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u5c5e\u3057\u3066\u3044\u308c\u3070\u3064\u306a\u304c\u306a\u3044(\u9589\u8def\u3092\u4f5c\u3089\u306a\u3044)\n    # \u30b3\u30b9\u30c8\u6607\u9806\u30bd\u30fc\u30c8\u6e08\u307f\u306e\u8fba\u30ea\u30b9\u30c8\u3092\u4f7f\u7528\u3059\u308b\n    ret = 0\n    for cost, a, b in sorted(xes + yes, key=itemgetter(0)):\n        if uf.same(a, b): continue\n        uf.unite(a, b)\n        ret += cost\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\n# Union Find\uff08\u7d4c\u8def\u5727\u7e2e\u6709\uff09\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    # \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # \u6839\u3092\u7e4b\u304e\u76f4\u3059\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    # \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\ndef kruskal(max_node, edge):\n    \"\"\"\n    :param max_node: UnionFind\u6728\u306b\u6e21\u3059\u9802\u70b9\u6570\u3067\u3059\n    :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n    :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n    \"\"\"\n    edge.sort()\n    uf = UnionFind(max_node)\n    cost_sum = 0\n    for cost, node1, node2 in edge:\n        if not uf.same(node1, node2):\n            cost_sum += cost\n            uf.union(node1, node2)\n    return cost_sum\n\n\ndef resolve():\n    n = int(input())\n    X, Y = [], []\n    for i in range(n):\n        x, y = list(map(int, input().split()))\n        X.append([i, x])\n        Y.append([i, y])\n\n    def calc(L):\n        for i in range(n - 1):\n            cost = abs(L[i][1] - L[i + 1][1])\n            edge.append((cost, L[i][0], L[i + 1][0]))\n\n    edge = []\n    X.sort(key=lambda x: x[1])\n    Y.sort(key=lambda x: x[1])\n    calc(X)\n    calc(Y)\n    print((kruskal(n, edge)))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n = int(input())\nl = []\nfor i in range(n):\n    x,y = list(map(int,input().split()))\n    l.append([x,y,i])\n\nlx = sorted(l)\nly = sorted(l, key=lambda x: x[1])\n\ne = []\nfor i in range(n-1):\n    e.append([lx[i+1][0]-lx[i][0],lx[i+1][2],lx[i][2]])\n    e.append([ly[i+1][1]-ly[i][1],ly[i+1][2],ly[i][2]])\n\n\nclass Unionfind:\n    \n    def __init__(self,n):\n        self.uf = [-1]*n\n\n    def find(self,x):\n        if self.uf[x] < 0:\n            return x\n        else:\n            self.uf[x] = self.find(self.uf[x])\n            return self.uf[x]\n\n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n\n    def union(self,x,y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return \n        if self.uf[x] > self.uf[y]:\n            x,y = y,x\n        self.uf[x] += self.uf[y]\n        self.uf[y] = x\n\n    def size(self,x):\n        x = self.find(x)\n        return -self.uf[x]\ns = set()\nu = Unionfind(n)\ncount = 0\ne.sort()\nfor i in e:\n    if not u.same(i[1],i[2]):\n        u.union(i[1],i[2])\n        s.add(i[1])\n        s.add(i[2])\n        count += i[0]\nprint(count)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    \nimport heapq    \n    \nn = int(input())\na = []\nb = []\nfor i in range(n):\n    x,y= map(int, input().split())\n    a.append((x,y,i))\n    b.append((y,x,i))\na.sort()\nb.sort()\nedgea = []\nedgeb = []\nfor i in range(n-1):\n    edgea.append((a[i+1][0]-a[i][0],a[i][2],a[i+1][2]))\n    edgeb.append((b[i+1][0]-b[i][0],b[i][2],b[i+1][2]))\nedge = edgea+edgeb\nheapq.heapify(edge)\n\nuf = UnionFind(n)\nans = 0\nwhile len(edge):\n    x,y,z = heapq.heappop(edge)\n    if not uf.same(y,z):\n        ans += x\n        uf.union(y,z)\nprint(ans)", "\"\"\"Minimum spanning tree with Kruskal's algorithm\"\"\"\nimport sys\n\n\nclass UnionFind:\n    def __init__(self, n):\n        # total number of nodes.\n        self.n = n\n        # node id -> root node id\n        self._root_table = list(range(n))\n        # root node id -> group size\n        self._size_table = [1] * n\n\n    def find(self, x):\n        \"\"\"Returns x's root node id.\"\"\"\n        r = self._root_table[x]\n        if r != x:\n            # Update the cache on query.\n            r = self._root_table[x] = self.find(r)\n        return r\n\n    def union(self, x, y):\n        \"\"\"Merges two groups.\"\"\"\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        # Ensure that x is the larger (or equal) group.\n        if self._size_table[x] < self._size_table[y]:\n            x, y = y, x\n\n        self._size_table[x] += self._size_table[y]\n        self._root_table[y] = x\n\n    def size(self, x):\n        return self._size_table[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self._root_table) if x == i]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return \"\\n\".join(\"{}: {}\".format(r, self.members(r)) for r in self.roots())\n\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    cities, xs, ys = [], [], []\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        cities.append((x, y))\n        xs.append((x, i))\n        ys.append((y, i))\n    xs.sort()\n    ys.sort()\n    xd, yd = [], []\n    for i in range(1, N):\n        x1, c1 = xs[i - 1]\n        x2, c2 = xs[i]\n        if x2 - x1 <= abs(cities[c1][1] - cities[c2][1]):\n            xd.append((x2 - x1, c1, c2))\n        y1, c1 = ys[i - 1]\n        y2, c2 = ys[i]\n        if y2 - y1 < abs(cities[c1][0] - cities[c2][0]):\n            xd.append((y2 - y1, c1, c2))\n    xd.sort()\n\n    uf = UnionFind(N)\n    cost = 0\n    merged_cnt = 0\n    for d1, c1, c2 in xd:\n        if not uf.same(c1, c2):\n            uf.union(c1, c2)\n            cost += d1\n            merged_cnt += 1\n            if merged_cnt == N - 1:\n                break\n    print(cost)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport collections\nsys.setrecursionlimit(10 ** 8)\n\ndef input(): return sys.stdin.readline().strip()\ndef Z(): return int(input())\ndef ZZ(): return [int(_) for _ in input().split()]\n\nclass UnionFind:\n    def __init__(self, size):\n        self.par = [i for i in range(size)]\n        self.rank = [0] * size\n\n    def find(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y: return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n        return\n\n    def same(self, x, y): return self.find(x) == self.find(y)\n\ndef main():\n    N = Z()\n    Cs = [ZZ()+[i] for i in range(N)]\n    X = sorted(Cs)\n    Y = sorted(Cs, key=lambda x:x[1])\n    es = []\n    for i in range(N-1):\n        c = X[i+1][0] - X[i][0]\n        u, v = X[i][2], X[i+1][2]\n        es.append([c, u, v])\n    for i in range(N-1):\n        c = Y[i+1][1] - Y[i][1]\n        u, v = Y[i][2], Y[i+1][2]\n        es.append([c, u, v])\n    es.sort()\n    uf = UnionFind(N)\n    output = 0\n    for i in range(len(es)):\n        c, u, v = es[i]\n        if not uf.same(u, v):\n            uf.unite(u, v)\n            output += c\n    print(output)\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    N, *XY = list(map(int, read().split()))\n    X = list(zip(XY[::2], list(range(N))))\n    Y = list(zip(XY[1::2], list(range(N))))\n\n    X.sort()\n    Y.sort()\n\n    edge = []\n    for i in range(N - 1):\n        edge.append((X[i + 1][0] - X[i][0], X[i][1], X[i + 1][1]))\n        edge.append((Y[i + 1][0] - Y[i][0], Y[i][1], Y[i + 1][1]))\n\n    edge.sort()\n\n    uf = UnionFind(N)\n    ans = 0\n    for d, s, t in edge:\n        if not uf.same(s, t):\n            uf.union(s, t)\n            ans += d\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappush, heappop, heapify\nN = int(input())\n\nX = []\nY = []\nfor n in range(N):\n    x,y = list(map(int,input().split()))\n    X.append([x,n])\n    Y.append([y,n])#\u5ea7\u6a19\u3001\u9802\u70b9\u756a\u53f7\nX.sort()\nY.sort()\n\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u3002\u5927\u304d\u3055\u3067\u306f\u306a\u304f\u753a\u756a\u53f7\u3067\u8a18\u9332\nadj = list([] for _ in range(N))\n\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\nfor n in range(N-1):#X[n]\u306f\u4e0b\u304b\u3089n\u756a\u76ee\u306b\u5927\u304d\u3044\u6570\n    costx = X[n+1][0] - X[n][0]\n    #\u304a\u4e92\u3044\u306e\u96a3\u63a5\u30ea\u30b9\u30c8\u306b\u30b3\u30b9\u30c8\u3068\u76f8\u624b\u306e\u756a\u53f7\u3092\u8ffd\u52a0\n    adj[X[n+1][1]].append([costx,X[n][1]])#\u30b3\u30b9\u30c8\u3068\u76f8\u624b\u306e\u756a\u53f7\n    adj[X[n][1]].append([costx,X[n+1][1]])\n    \n    costy = Y[n+1][0] - Y[n][0]\n    adj[Y[n+1][1]].append([costy,Y[n][1]])#\u30b3\u30b9\u30c8\u3068\u76f8\u624b\u306e\u756a\u53f7\n    adj[Y[n][1]].append([costy,Y[n+1][1]])\n    \n\n\nused = [0]*N\nque = [(w,c) for w,c in adj[0]]#\u30b3\u30b9\u30c8,\u756a\u53f7\nused[0] = 1\nheapify(que)\nans = 0\nwhile que:\n    cv,v = heappop(que)#cv\u306f\u30b3\u30b9\u30c8\u3002v\u306f\u756a\u53f7\n    if used[v]:\n        continue\n    used[v] = 1\n    ans += cv\n    for w,c in adj[v]:#v\u3092\u8ffd\u52a0\n        if used[c]:\n            continue\n        heappush(que,(w,c))\nprint(ans)\n", "from heapq import *\n\ndef find(x):\n    parent = data[x]\n    if parent < 0: return x\n    root = find(parent)\n    data[x] = root\n    return root\n\ndef union(x, y):\n    root, second = find(x), find(y)\n    if root == second: return False\n    if height[root] < data[second]:\n        second, root = root, second\n    data[root] += data[second]\n    height[root] = max(height[root], height[second]+1)\n    data[second] = root\n    return True\n\nN = int(input())\nX = [(0,0)] * N\nY = [(0,0)] * N\nE = [(0,0)] * N\n\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    X[i] = (x, i)\n    Y[i] = (y, i)\n\nX.sort()\nY.sort()\nH = []\n\nfor i in range(N - 1):\n    x1, j1 = X[i]\n    x2, j2 = X[i + 1]\n    y1, k1 = Y[i]\n    y2, k2 = Y[i + 1]\n    # \u30d2\u30fc\u30d7\u69cb\u9020\u3092\u7528\u3044\u3066\u5e38\u306bH\u306e\u6700\u521d\u306b\u6700\u5c0f\u5024\u3092\u6301\u3063\u3066\u304f\u308b\n    # X\u5ea7\u6a19\u3068Y\u5ea7\u6a19\u3067\u305d\u308c\u305e\u308cH\u306b\u8ffd\u52a0\n    heappush(H, (x2 - x1, j1, j2))\n    heappush(H, (y2 - y1, k1, k2))\n\nanswer = 0\ndata = [-1] * (N+1)  # 1-indexed root\u306b\u306f-size\u304c\u5165\u308b\nheight = [0] * (N+1)\n\nwhile H:\n    w, s, t = heappop(H)\n    # s\u3068t\u306e\u96c6\u5408\u304c\u7570\u306a\u3063\u3066\u3044\u305f\u6642\u3001\u9053\u3092\u4f5c\u308b\n    if union(s, t):\n        answer += w\n\nprint(answer)\n", "from scipy.sparse.csgraph import minimum_spanning_tree\nfrom scipy.sparse import csr_matrix\nfrom operator import itemgetter\n\nn = int(input()) \nixy = [[i] + [int(x) for x in input().split()] for i in range(n)]\n\nedge = set()\n\nfor key in [itemgetter(1),itemgetter(2)]:\n    ixy.sort(key = key)\n    for i in range(n-1):\n        i1, i2 = ixy[i][0], ixy[i+1][0]\n        x1, x2 = ixy[i][1], ixy[i+1][1]\n        y1, y2 = ixy[i][2], ixy[i+1][2]\n        d = min(abs(x2-x1), abs(y2-y1))\n        edge.add((i1,i2,d))\n    \nrow,col,value = zip(*edge)\ncsr_ = csr_matrix((value, (row,col)), shape=(n, n))\nmst = minimum_spanning_tree(csr_, overwrite=True).astype(int)\nprint(mst.sum())", "from heapq import *\n\ndef main():\n    def find(x):\n        parent = data[x]\n        if parent < 0: return x\n        root = find(parent)\n        data[x] = root\n        return root\n\n    def union(x, y):\n        root, second = find(x), find(y)\n        if root == second: return False\n        if height[root] < data[second]:\n            second, root = root, second\n        data[root] += data[second]\n        height[root] = max(height[root], height[second]+1)\n        data[second] = root\n        return True\n\n    N = int(input())\n    X = [(0,0)] * N\n    Y = [(0,0)] * N\n\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        X[i] = (x, i)\n        Y[i] = (y, i)\n\n    X.sort()\n    Y.sort()\n    H = []\n\n    for i in range(N - 1):\n        x1, j1 = X[i]\n        x2, j2 = X[i + 1]\n        y1, k1 = Y[i]\n        y2, k2 = Y[i + 1]\n        # \u30d2\u30fc\u30d7\u69cb\u9020\u3092\u7528\u3044\u3066\u5e38\u306bH\u306e\u6700\u521d\u306b\u6700\u5c0f\u5024\u3092\u6301\u3063\u3066\u304f\u308b\n        # X\u5ea7\u6a19\u3068Y\u5ea7\u6a19\u3067\u305d\u308c\u305e\u308cH\u306b\u8ffd\u52a0\n        heappush(H, (x2 - x1, j1, j2))\n        heappush(H, (y2 - y1, k1, k2))\n\n    answer = 0\n    data = [-1] * (N+1)  # 1-indexed root\u306b\u306f-size\u304c\u5165\u308b\n    height = [0] * (N+1)\n\n    while H:\n        w, s, t = heappop(H)\n        # s\u3068t\u306e\u96c6\u5408\u304c\u7570\u306a\u3063\u3066\u3044\u305f\u6642\u3001\u9053\u3092\u4f5c\u308b\n        if union(s, t):\n            answer += w\n\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# built\n# x\u8ef8\u306e\u6607\u9806\u3067\u4e26\u3079\u305f\u30ea\u30b9\u30c8\u3001y\u8ef8\u306e\u6607\u9806\u3067\u4e26\u3079\u305f\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\u3002\n# \u3069\u3061\u3089\u304b\u306e\u30ea\u30b9\u30c8\u3067\u96a3\u306b\u3042\u308b\u70b9\u540c\u58eb\u3092\u8fba\u3067\u3080\u3059\u3076\u3002\n# \u6700\u5c0f\u5168\u57df\u6728\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\npoint = [None] * N\nfor i in range(N):\n  point[i] = list(map(int,readline().split())) + [i]\n  \nX = sorted(point, key = lambda x:x[0])\nY = sorted(point, key = lambda x:x[1])\n\nG = [[] for i in range(N)]\n\nfor i in range(len(X) - 1):\n  x1,y1,ind_1 = X[i]\n  x2,y2,ind_2 = X[i + 1]\n  G[ind_1].append([ind_2, min(abs(x1 - x2),abs(y1 - y2))])\n  G[ind_2].append([ind_1, min(abs(x1 - x2),abs(y1 - y2))])\n  \nfor i in range(len(Y) - 1):\n  x1,y1,ind_1 = Y[i]\n  x2,y2,ind_2 = Y[i + 1]\n  G[ind_1].append([ind_2, min(abs(x1 - x2),abs(y1 - y2))])\n  G[ind_2].append([ind_1, min(abs(x1 - x2),abs(y1 - y2))])\n\n# \u9032\u3080\u3053\u3068\u304c\u3067\u304d\u308b\u9802\u70b9\u306e\u3046\u3061\u3001\u6700\u3082\u30b3\u30b9\u30c8\u304c\u5c0f\u3055\u3044\u3082\u306e\u3092\u63a1\u7528\u3059\u308b\n# heapq\u3067\u3001\u6b21\u306b\u884c\u304f\u3053\u3068\u304c\u3067\u304d\u308b(\u30b3\u30b9\u30c8, \u9802\u70b9)\u3092\u7ba1\u7406\n# \u9802\u70b9\u304c\u8ffd\u52a0\u3055\u308c\u305f\u3089\u3001\u305d\u3053\u304b\u3089\u9032\u3080\u3053\u3068\u304c\u3067\u304d\u308b\u9802\u70b9\u3092\u5168\u3066heapq\u306b\u8ffd\u52a0\u3059\u308b\n# \u8a2a\u554f\u6e08\u307f\u9802\u70b9\u306fset\u3067\u7ba1\u7406\u3059\u308b\u3053\u3068\u3067\u9664\u5916\n# \u5168\u3066\u304c\u8a2a\u554f\u6e08\u307f\u306b\u306a\u3063\u305f\u3089\uff08heapq\u304c\u7a7a\u306b\u306a\u3063\u305f\u3089\uff09\u7d42\u4e86\n\nimport heapq as hq\nq = [(0, 0)]\nhq.heapify(q)\nvisited = set()\n\nans = 0\nwhile q:\n  cost, v = hq.heappop(q)\n  if v in visited:\n    continue\n  visited.add(v)\n  ans += cost\n  for child in G[v]:\n    if child[0] in visited:\n      continue\n    hq.heappush(q, (child[1], child[0]))\n  \nprint(ans)", "class UnionFind():\n    # \u521d\u3081\u306f\u5168\u3066\u306e\u9802\u70b9\u304c\u5225\u3005\u306e\u6728\u306e\u6839\n    def __init__(self, n):  # n\u8981\u7d20\u3067\u521d\u671f\u5316\n        self.parent = list(range(n)) # \u89aa\n        self.rank = [0] * n   # \u6728\u306e\u6df1\u3055\n\n    def root_of(self, x):\n        children = [x]\n        while self.parent[x] != x:\n            x = self.parent[x]\n            children.append(x)\n\n        for ch in children:\n            self.parent[ch] = x\n        return x\n\n    # x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408\n    def union(self, x, y):\n        rx = self.root_of(x)\n        ry = self.root_of(y)\n        if rx == ry:\n            return\n        if self.rank[rx] < self.rank[ry]: # \u30e9\u30f3\u30af\u306e\u5c0f\u3055\u3044\u6728\u304b\u3089\u5927\u304d\u3044\u6728\u306e\u6839\u306b\u8fba\u3092\u5f35\u308b\n            self.parent[rx] = ry  # rx\u3092ry\u306e\u5b50\u3068\u3059\u308b\n        else:\n            self.parent[ry] = rx\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n    def same(self, x, y):\n        return self.root_of(x) == self.root_of(y)\n\n\nN = int(input())\nX = [None] * N\nY = [None] * N\nfor i in range(N):\n    x, y = [int(x) for x in input().split()]\n    X[i] = (x, i)\n    Y[i] = (y, i)\n\nX.sort()\nY.sort()\nE = []\nxp = X[0][0]\nip = X[0][1]\nfor (x, i) in X:\n    E.append((x - xp, (ip, i)))\n    xp = x\n    ip = i\n\nyp = Y[0][0]\nip = Y[0][1]\nfor (y, i) in Y:\n    E.append((y - yp, (ip, i)))\n    yp = y\n    ip = i\n\nE.sort()\nuf = UnionFind(N)\ncost = 0\nfor c, (e1, e2) in E:\n    if uf.same(e1, e2): continue\n    cost += c\n    uf.union(e1, e2)\n\nprint(cost)", "from heapq import *\nN = int(input())\nX,Y=[],[]\nfor n in range(N):\n  x,y=map(int,input().split())\n  X.append((x, n))\n  Y.append((y, n))\nX.sort()\nY.sort()\nD=[[] for v in range(N)]\nfor n in range(N-1):\n  cost = X[n+1][0]-X[n][0]\n  D[X[n+1][1]].append((cost,X[n][1]))\n  D[X[n][1]].append((cost,X[n+1][1]))\n  cost=Y[n+1][0]-Y[n][0]\n  D[Y[n+1][1]].append((cost,Y[n][1]))\n  D[Y[n][1]].append((cost,Y[n+1][1]))\n\nvisited=[0]*N\npq = []\nfor w, t in D[0]:\n  heappush(pq,(w,t))\nvisited[0]=1\n\nans = 0\nwhile pq:\n  w,t=heappop(pq)\n  if visited[t]:\n    continue\n  visited[t]=1\n  ans+=w\n  for w,s in D[t]:\n    if visited[s]==0:\n      heappush(pq,(w,s))\nprint (ans)", "n=int(input())\nx=[]\ny=[]\nfor i in range(n):\n  xx,yy=map(int,input().split())\n  x.append([xx,i])\n  y.append([yy,i])\nx.sort()\ny.sort()\npx=[]\npy=[]\nfor i in range(n-1):\n  px.append([x[i+1][0]-x[i][0],x[i][1],x[i+1][1]])\n  py.append([y[i+1][0]-y[i][0],y[i][1],y[i+1][1]])\np=px+py\nx=[]\ny=[]\npx=[]\npy=[]\np.sort()\nr=[i for i in range(n)]\nrank=[1 for i in range(n)]\ndef root(x):\n  if x==r[x]:\n    return x\n  else:\n    r[x]=root(r[x])\n    return r[x]\ndef union(path):\n  rx=root(path[1])\n  ry=root(path[2])\n  if rx==ry:\n    return 0\n  else:\n    if rank[rx]>rank[ry]:\n      r[rx]=ry\n      rank[rx]+=rank[ry]\n    else:\n      r[ry]=rx\n      rank[ry]+=rank[rx]\n    return path[0]\nans=0\nfor i in range(len(p)):\n  ans+=union(p[i])\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\ninput=sys.stdin.readline\n\nN=int(input())\n\nxylist,yxlist=[],[]\npar_dic={}\nfor i in range(N):\n  x,y=map(int,input().split())\n  xylist.append((x,y))\n  yxlist.append((y,x))\n  par_dic[(x,y)]=(x,y)\nxylist.sort()\nyxlist.sort()\n#print(xylist)\n\nelist=[]\nfor i in range(1,N):\n  x1,y1=xylist[i-1]\n  x2,y2=xylist[i]\n  elist.append((min(abs(x2-x1),abs(y1-y2)),(x1,y1),(x2,y2)))\n  y1,x1=yxlist[i-1]\n  y2,x2=yxlist[i]\n  elist.append((min(abs(x2-x1),abs(y1-y2)),(x1,y1),(x2,y2)))\n#print(hq)\nelist.sort(reverse=True)\n\ndef get_par(x):\n  if x == par_dic[x]:\n    return x\n  else:\n    par_dic[x] = get_par(par_dic[x])\n    return par_dic[x]\ndef merge(x,y):\n  par_x = get_par(x)\n  par_y = get_par(y)\n  if par_x != par_y:\n    par_dic[par_y] = par_x\ndef is_same(x,y):\n  return get_par(x) == get_par(y)\n\nanswer=0\nwhile elist:\n  d,p1,p2=elist.pop()\n  #print(d,p1,p2)\n  if not is_same(p1,p2):\n    merge(p1,p2)\n    answer+=d\n  \nprint(answer)", "import sys\nfrom collections import defaultdict\nfinput=lambda:sys.stdin.readline().strip()\n\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.ranks=[0]*n\n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n        if x==y:\n            return \n        if self.ranks[x]<self.ranks[y]:\n            x,y=y,x\n        self.parents[x]+=self.parents[y]\n        self.parents[y]=x\n        if self.ranks[x]==self.ranks[y]:\n            self.ranks[x]+=1\n    \n    def size(self,x):\n        return -self.parents[self.find(x)]\n    \n    def issametree(self,x,y):\n        return self.find(x)==self.find(y)\n\ndef main():\n    n=int(finput())\n    coor=[list(map(int,finput().split()))+[i] for i in range(n)]\n    coor.sort(key=lambda e:e[0])\n    cost = lambda e,f:min(abs(e[0]-f[0]),abs(e[1]-f[1]))\n    ew=dict(((coor[i][2],coor[i+1][2]),cost(coor[i][:2],coor[i+1][:2])) for i in range(n-1))\n    coor.sort(key=lambda e:e[1])\n    ew.update(dict(((coor[i][2],coor[i+1][2]),cost(coor[i][:2],coor[i+1][:2])) for i in range(n-1)))\n    edges=sorted(list(iter(ew)),key=lambda e:ew[e])\n    v=Unionfind(n)\n    totcost=0\n    # print(ew)\n    # print(edges)\n    for edge in edges:\n        if not v.issametree(edge[0],edge[1]):\n            v.union(edge[0],edge[1])\n            totcost+=ew[edge]\n    print(totcost)\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef kruskal(es, V):\n    es.sort(key=lambda x:x[2])\n    uf = UnionFind(V)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.union(e[0], e[1])\n            res += e[2]\n    return res\n\ndef resolve():\n    N = I()\n    xy = [LI() for _ in range(N)]\n\n    # \u8fba\u306e\u5019\u88dc\u306f\u3001xy\u305d\u308c\u305e\u308c\u3067\u30bd\u30fc\u30c8\u3057\u305f\u96a3\u540c\u58eb\u306e\u70b9\u306e\u9593\u306e\u307f\u306b\u7d5e\u308c\u308b\n    xy_x_asc = sorted(enumerate(xy), key=lambda x: x[1][0])\n    xy_y_asc = sorted(enumerate(xy), key=lambda x: x[1][1])\n    edge = []\n    for i in range(N-1):\n        xc = xy_x_asc[i][1][0]\n        yc = xy_x_asc[i][1][1]\n        xyc_num = xy_x_asc[i][0]\n        xn = xy_x_asc[i+1][1][0]\n        yn = xy_x_asc[i+1][1][1]\n        xyn_num = xy_x_asc[i+1][0]\n        edge.append([xyc_num, xyn_num, abs(xn-xc)])\n    for i in range(N-1):\n        xc = xy_y_asc[i][1][0]\n        yc = xy_y_asc[i][1][1]\n        xyc_num = xy_y_asc[i][0]\n        xn = xy_y_asc[i+1][1][0]\n        yn = xy_y_asc[i+1][1][1]\n        xyn_num = xy_y_asc[i+1][0]\n        edge.append([xyc_num, xyn_num, abs(yn-yc)])\n\n    # print(edge)\n    mst_cost = kruskal(edge, N)\n    print(mst_cost)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "#Union Find\nclass union_find:\n    #\u521d\u671f\u5316\n    #\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\n    # par = [-1]*N\n    def __init__(self, N):\n        self.par = [-1]*N\n\n    #x\u306e\u6839\u3092\u6c42\u3081\u308b\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    #x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\n    def unite(self, x,y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n            if self.par[x] > self.par[y]:\n                x,y = y,x\n            self.par[x] += self.par[y]\n            self.par[y] = x\n            return True\n\n    #x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\n    def same(self, x,y):\n        return self.find(x) == self.find(y)\n\n    #x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\n    def size(self, x):\n        return -self.par[self.find(x)]\n\nN = int(input())\nXYI = []\nfor i in range(N):\n    x, y = map(int, input().split())\n    XYI.append((x, y, i))\n\nimport heapq\nedges = []\nheapq.heapify(edges)\n\nXYI.sort(key=lambda x: x[0])\nfor j in range(1, N):\n    px, py, pi = XYI[j-1]\n    x, y, i = XYI[j]\n    d = min(abs(x-px), abs(y-py))\n    heapq.heappush(edges, (d, pi, i))\n\nXYI.sort(key=lambda x: x[1])\nfor j in range(1, N):\n    px, py, pi = XYI[j-1]\n    x, y, i = XYI[j]\n    d = min(abs(x-px), abs(y-py))\n    heapq.heappush(edges, (d, pi, i))\n\nuf = union_find(N)\nans = 0\nwhile True:\n    d, i, j = heapq.heappop(edges)\n    if uf.same(i, j): continue\n    uf.unite(i, j)\n    ans += d\n    if uf.size(i) == N: break\n\nprint(ans)", "class DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0]*size\n    \n    def find(self, x):\n        stack = []\n        parent = self.parent\n        while parent[x] != x:\n            stack.append(x)\n            x = parent[x]\n        for y in stack:\n            parent[y] = x\n        return x\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        \n        if self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif xr != yr:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\nfrom itertools import chain\n\nN = int(input())\npoints = tuple(tuple(map(int,input().split())) for _ in range(N))\nds = DisjointSet(N)\n\nx_i = sorted((x,i) for i,(x,y) in enumerate(points))\ny_i = sorted((y,i) for i,(x,y) in enumerate(points))\n\nxr = [x_i[0]]\nyr = [y_i[0]]\n\nfor (x0,i0),(x1,i1) in zip(x_i,x_i[1:]):\n    if x0 == x1:\n        ds.union(i0,i1)\n    else:\n        xr.append((x1,i1))\n\nfor (y0,i0),(y1,i1) in zip(y_i,y_i[1:]):\n    if y0 == y1:\n        ds.union(i0,i1)\n    else:\n        yr.append((y1,i1))\n\ndeltas = sorted(\n        chain(\n            ((x1-x0,i0,i1) for (x0,i0), (x1,i1) in zip(xr,xr[1:])),\n            ((y1-y0,i0,i1) for (y0,i0), (y1,i1) in zip(yr,yr[1:])),\n        )\n    )\n\n\ndef it():\n    for d,i0,i1 in deltas:\n        i0,i1 = ds.find(i0), ds.find(i1)\n        if i0 != i1:\n            ds.union(i0,i1)\n            yield d\nprint(sum(it()))", "with open(0) as f:\n    N, *xy = map(int, f.read().split())\n\nfrom collections import namedtuple\nv = namedtuple('v',['coordinate','num'])\n#\u6700\u5c0f\u5168\u57df\u6728\u306b\u4f7f\u308f\u308c\u308b\u8fba\u306f\u9ad8\u3005\u5ea7\u6a19(x\u307e\u305f\u306fy)\u304c\u96a3\u63a5\u3059\u308b\u9802\u70b9\u9593\u306e\u3082\u306e\u3067\u3042\u308b\n#\u3057\u305f\u304c\u3063\u3066\u3001x\u5ea7\u6a19\u30fby\u5ea7\u6a19\u305d\u308c\u305e\u308c\u3067\u30bd\u30fc\u30c8\u3057\u3066\u8fba\u3092\u6c42\u3081\u308b\nX = sorted([v(x,i) for x,i in zip(xy[::2], range(N))])\nY = sorted([v(y,i) for y,i in zip(xy[1::2], range(N))])\n\ndiffiter = lambda X:zip(X[:len(X)-1], X[1:]) #X\u306e1\u968e\u968e\u5dee\u5dee\u5206\u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u3092\u8fd4\u3059\u95a2\u6570\ncost = lambda u,v:abs(u.coordinate - v.coordinate)\nfrom itertools import chain\nEdge = sorted([(cost(u,v), u.num, v.num) for u,v in chain(diffiter(X),diffiter(Y))])\n\nroot = namedtuple('root',['num', 'rank']) #(num_of_root, rank_of_root)\nRoot = [root(i,0) for i in range(N)]\n\ndef fr(i): #findRoot\n    if i == Root[i].num:\n        return Root[i]\n    Root[i] = fr(Root[i].num)\n    return Root[i]\n\n\ndef unionT(i, j): #unionTree\n    p, q = fr(i), fr(j)\n    if p.rank < q.rank:\n        Root[p.num] = q\n    elif p.rank > q.rank:\n        Root[q.num] = p\n    elif p.rank == q.rank:\n        r, s = min(p, q), max(p, q)\n        Root[r.num] = Root[s.num] = root(r.num, r.rank+1)\n    \n\nans = 0\n#\u6700\u5c0f\u5168\u57df\u6728\u306e\u5927\u304d\u3055\u7b97\u51fa(\u74b0\u72b6\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8fba\u3092\u5c0f\u3055\u3044\u9806\u306b\u8db3\u3057\u3066\u3086\u304f)\nfor w, i, j in Edge:\n    if fr(i).num == fr(j).num: #\u65e2\u306b\u9023\u7d50\u6e08\u307f\n        continue\n    else:\n        unionT(i,j)\n        ans += w\nprint(ans)", "n=int(input())\npar=[-1]*n\n\n# this par & rank are initialized lists\ndef find(x):\n    nonlocal par\n    if par[x]<0:\n        return x\n    else:\n        par[x]=find(par[x])\n        return par[x]\n        \ndef unite(x,y):\n    x,y=find(x),find(y)\n    nonlocal par\n    if x==y:return False\n    else:\n        if par[x]>par[y]:x,y=y,x\n        par[x]+=par[y]\n        par[y]=x\n        return True\n\ndef size(x):\n    return -par[find(x)]\ndef same(x,y):\n    return find(x)==find(y)\n\np=[]\nedge=[]\nfor i in range(n):\n  x,y=map(int,input().split())\n  p.append([x,y,i])\np.sort(key=lambda x:x[0])\nfor i in range(n-1):\n  x0,_,j=p[i]\n  x1,_,k=p[i+1]\n  edge.append([x1-x0,j,k])\n\np.sort(key=lambda x:x[1])\nfor i in range(n-1):\n  _,y0,j=p[i]\n  _,y1,k=p[i+1]\n  edge.append([y1-y0,j,k])\n\nedge.sort()\nans=0\nfor i in range(len(edge)):\n  cost,u,v=edge[i]\n  if not same(u,v):\n    unite(u,v)\n    ans+=cost\n\nprint(ans)", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\n\nclass UnionFind:\n\n    def __init__(self, n: int):\n        self._n = n\n        self._parents = [i for i in range(n)]\n        self._rank = [1 for _ in range(n)]\n\n    def unite(self, x: int, y: int) -> None:\n        px = self.find(x)\n        py = self.find(y)\n\n        # \u4e00\u81f4\u3057\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u30ea\u30f3\u30af\u3092\u3064\u3051\u308b\n        if px != py:\n            self._link(px, py)\n\n    def _link(self, x: int, y: int):\n        if self._rank[x] < self._rank[y]:\n            self._parents[x] = y\n        elif self._rank[x] > self._rank[y]:\n            self._parents[y] = x\n        else:\n            self._parents[x] = y\n            self._rank[y] += 1\n\n    def same(self, x: int, y: int) -> bool:\n        px = self.find(x)\n        py = self.find(y)\n        return px == py\n\n    def find(self, x: int) -> int:\n        if self._parents[x] == x:\n            return x\n\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n\n\nN = int(input())\nps = [list(map(int, input().split())) + [i] for i in range(N)]\nps.sort(key=lambda t: t[0])\nxs = []\nfor i in range(N - 1):\n    xs.append((ps[i + 1][0] - ps[i][0], ps[i][2], ps[i + 1][2]))\n\nps.sort(key=lambda t: t[1])\nys = []\nfor i in range(N - 1):\n    ys.append((ps[i + 1][1] - ps[i][1], ps[i][2], ps[i + 1][2]))\n\nxs += [(1<< 40, -1, -1)]\nys += [(1<< 40, -1, -1)]\n\nxs.sort()\nys.sort()\n\nxc, yc = 0, 0\nuf = UnionFind(N)\n\nans = 0\nwhile xc < N - 1 and yc < N - 1:\n    if xs[xc][0] < ys[yc][0]:\n        if not uf.same(xs[xc][1], xs[xc][2]):\n            uf.unite(xs[xc][1], xs[xc][2])\n            ans += xs[xc][0]\n        xc += 1\n    else:\n        if not uf.same(ys[yc][1], ys[yc][2]):\n            uf.unite(ys[yc][1], ys[yc][2])\n            ans += ys[yc][0]\n        yc += 1\n\nprint(ans)\n", "def kruskal():\n    '''\n    \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u3092\u6c42\u3081\u308b\n    '''\n    cost = 0\n    edge.sort()\n\n    for c, u, v in edge:\n        if same(u, v):\n            continue\n        union(u, v)\n        cost += c\n\n    return cost\n\n\ndef find(x):\n    '''\n    x\u306e\u6839\u3092\u6c42\u3081\u308b\n    '''\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n\ndef union(x, y):\n    '''\n    x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408\u3059\u308b\n    '''\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        return False\n\n    if par[x] > par[y]:\n        x, y = y, x\n\n    par[x] += par[y]\n    par[y] = x\n    return True\n\n\ndef same(x, y):\n    '''\n    x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\n    '''\n    return find(x) == find(y)\n\n\nn = int(input())\nx, y = [], []\nfor i in range(n):\n    tmp_x, tmp_y = map(int, input().split())\n    x.append([tmp_x, i])\n    y.append([tmp_y, i])\n\nx.sort()\ny.sort()\nedge = []\nfor i in range(n-1):\n    edge.append([x[i+1][0]-x[i][0], x[i+1][1], x[i][1]])\n    edge.append([y[i+1][0]-y[i][0], y[i+1][1], y[i][1]])\n\npar = [-1] * n\nprint(kruskal())", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN=int(input())\nG=[]\nfor i in range(N):\n    x,y=list(map(int,input().split()))\n    G.append((x,y,i))\n\nGx=sorted(G,key=lambda x:x[0])\nGy=sorted(G,key=lambda x:x[1])\n\nnewG=[]\nfor i in range(N-1):\n    now=Gx[i]\n    next=Gx[i+1]\n    dist=abs(now[0]-next[0])\n    newG.append((dist,now[2],next[2]))\n\nfor i in range(N-1):\n    now=Gy[i]\n    next=Gy[i+1]\n    dist=abs(now[1]-next[1])\n    newG.append((dist,now[2],next[2]))\n\nnewG.sort()\n\nuf=UnionFind(N)\ncount=N\nans=0\nfor c,i,j in newG:\n    if count==0:\n        break\n\n    if not uf.same(i,j):\n        ans+=c\n        uf.union(i,j)\n        count-=1\n\nprint(ans)\n\n\n\n\n\n", "N = int(input())\nX = []\nY = []\nfor i in range(N):\n    x, y = map(int, input().split())\n    X.append((x, y, i))\n    Y.append((y, x, i))\nX.sort()\nY.sort()\nEdges = list([] for _ in range(N))\nfor k in range(N-1):\n    xk, yk, ik = X[k]\n    xk_, yk_, ik_ = X[k+1]\n    Edges[ik].append((ik_, min(abs(xk-xk_), abs(yk-yk_))))\n    Edges[ik_].append((ik, min(abs(xk-xk_), abs(yk-yk_))))\n    yk, xk, ik = Y[k]\n    yk_, xk_, ik_ = Y[k+1]\n    Edges[ik].append((ik_, min(abs(xk-xk_), abs(yk-yk_))))\n    Edges[ik_].append((ik, min(abs(xk-xk_), abs(yk-yk_))))\n    \nimport heapq\ndef prim(Edges, V):\n    mst = []\n    included = [False]*V\n    heap = []\n    included[0] = True\n    for v, d in Edges[0]:\n        heapq.heappush(heap, (d, 0, v)) #(dist, pre_v, cur_v)\n    while heap:\n        d, pre_v, cur_v = heapq.heappop(heap)\n        if included[cur_v]:\n            continue\n        included[cur_v] = True\n        mst.append((pre_v, cur_v, d))\n        for next_v, dist in Edges[cur_v]:\n            if not included[next_v]:\n                heapq.heappush(heap, (dist, cur_v, next_v))\n    return mst\n\nmst = prim(Edges, N)\nans = 0\nfor v1, v2, d in mst:\n    ans += d\n    \nprint(ans)", "from collections import defaultdict\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import minimum_spanning_tree\n\n\nclass Point:\n \n    def __init__(self, index, x, y):\n        self.index = index\n        self.x = x\n        self.y = y\n\n\ndef create_graph(N, points):\n    # Caclulate costs\n    costs = defaultdict(int)\n    costs_defined = defaultdict(int)\n    # Sort by `x` and create edges between adjacent nodes\n    points = sorted(points, key=lambda p: p.x)\n    for i in range(N - 1):\n        p = points[i]\n        next_p = points[i + 1]\n        cost = next_p.x - p.x\n        min_index, max_index = min([p.index, next_p.index]), max([p.index, next_p.index])\n        costs[(min_index, max_index)] = cost\n        costs_defined[(min_index, max_index)] = 1\n    # Sort by `y` and create edges between adjacent nodes\n    points = sorted(points, key=lambda p: p.y)\n    for i in range(N - 1):\n        p = points[i]\n        next_p = points[i + 1]\n        cost = next_p.y - p.y\n        min_index, max_index = min([p.index, next_p.index]), max([p.index, next_p.index])\n        current_cost = costs[(min_index, max_index)]\n        if costs_defined[(min_index, max_index)]:\n            new_cost = min([cost, current_cost])\n            costs[(min_index, max_index)] = new_cost\n        else:\n            costs[(min_index, max_index)] = cost\n    # Create csgraph\n    rows = list()\n    cols = list()\n    data = list()\n    for node_pair, cost in costs.items():\n        rows.append(node_pair[0])\n        cols.append(node_pair[1])\n        data.append(cost)\n    return csr_matrix((data, (rows, cols)), shape=(N, N))\n\n \ndef main():\n    N = int(input())\n    points = list()\n    for index in range(N):\n        x, y = list(map(int, input().split(' ')))\n        points.append(Point(index, x, y))\n    graph = create_graph(N, points)\n    mst = minimum_spanning_tree(graph)\n    print(int(mst.sum()))\n \n \ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN = int(input())\nXY = [tuple(map(int,input().split() + [i])) for i in range(N)]\n\nclass UnionFind:\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self._size = [1] * N\n        self.count = 0\n    def root(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            self.parent[a] = self.root(self.parent[a])\n            return self.parent[a]\n    def is_same(self,a,b):\n        return self.root(a) == self.root(b)\n    def unite(self,a,b):\n        ra = self.root(a)\n        rb = self.root(b)\n        if ra == rb: return\n        if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n        self._size[ra] += self._size[rb]\n        self.parent[rb] = ra\n        self.count += 1\n    def size(self,a):\n        return self._size[self.root(a)]\n\nuf = UnionFind(N)\nsx = sorted(XY, key=lambda x:x[0])\nsy = sorted(XY, key=lambda x:x[1])\n\nes = []\nfor (x1,_,i),(x2,_,j) in zip(sx,sx[1:]):\n    es.append((x2-x1, i, j))\nfor (_,y1,i),(_,y2,j) in zip(sy,sy[1:]):\n    es.append((y2-y1, i, j))\nes.sort(key=lambda x:x[0])\n\nans = 0\nfor d,i,j in es:\n    if uf.is_same(i,j): continue\n    uf.unite(i,j)\n    ans += d\nprint(ans)", "# D - Built?\nimport sys\nimport heapq\n\n# input\nN = int(input())\n\nX, Y = [], []\nfor n in range(N):\n    x, y = list(map(int, sys.stdin.readline().strip().split()))\n    X.append((x, n))\n    Y.append((y, n))\n\n# build matrix\nG = [[] for _ in range(N)]\n\nX.sort()\nY.sort()\nfor i in range(N - 1):\n    d_u, u = X[i]\n    d_v, v = X[i + 1]\n\n    G[u].append((d_v - d_u, v))\n    G[v].append((d_v - d_u, u))\n\n    d_u, u = Y[i]\n    d_v, v = Y[i + 1]\n\n    G[u].append((d_v - d_u, v))\n    G[v].append((d_v - d_u, u))\n\n\n# \u6700\u5c0f\u5168\u57df\u6728\nq = []\nfp = [False] * N  # \u63a2\u7d22\u6e08\u307f\nfp[0] = True\n\nfor d, u in G[0]:\n    heapq.heappush(q, (d, u))\n\nans = 0\nwhile q:\n    d, u = heapq.heappop(q)\n\n    if fp[u]:\n        continue\n    fp[u] = True\n    ans += d\n\n    for d_v, v in G[u]:\n        if fp[v]:\n            continue\n        heapq.heappush(q, (d_v, v))\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\nfrom heapq import heappop, heappush,heapify\n\nicase=0\nif icase==0:\n    n=int(input())\n    xy=[[0]*2 for i in range(n)]\n    x=[0]*n\n    y=[0]*n\n    for i in range(n):\n#        xy[i]=list(map(int,input().split()))\n        x[i],y[i]=list(map(int,input().split()))\nelif icase==1:    \n    n=3\n#    xy=[[1, 5], [3, 9], [7, 8]]\n    x=[1, 3, 7]\n    y=[5, 9, 8]\nelif icase==2:    \n    n=6\n#    xy=[[8, 3], [4, 9], [12, 19], [18, 1], [13, 5], [7, 6]]\n    x=[8, 4, 12,18,13,7]\n    y=[3, 9, 19, 1, 5, 6]\n\nxi=[[0]*2 for i in range(n)]\nyi=[[0]*2 for i in range(n)]\nfor i in range(n):\n    xi[i]=[x[i],i]\n    yi[i]=[y[i],i]\n    \nxi.sort()\nx=xi\ny=yi.sort()\ny=yi\n\npair_lst = [i for i in range(n)]\nque=[]\nfor i in range(n-1):\n    wi=x[i+1][0]-x[i][0]\n    heappush(que,(wi,x[i][1],x[i+1][1]))\n    wi=y[i+1][0]-y[i][0]\n    heappush(que,(wi,y[i][1],y[i+1][1]))\n\ndef find(x):\n    if x == pair_lst[x]:\n        return x\n    else:\n        tmp = find(pair_lst[x])\n        pair_lst[x] = tmp\n        return tmp\n\nicnt=0\nlength_sum = 0\nwhile que:\n    w, s, t = heappop(que)\n#    print(w,s,t)\n    root_s = find(s)\n    root_t = find(t)\n    if root_s != root_t:\n        pair_lst[root_s] = root_t\n        length_sum += w\n        icnt+=1\n#        print(icnt)\n\nprint(length_sum)   \n", "# x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n#x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return False\n    else:\n        if par[x] > par[y]:\n            x,y = y,x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n#x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef same(x,y):\n    return find(x) == find(y)\n\n#x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\nn = int(input())\n#\u521d\u671f\u5316\n#\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\npar = [-1]*n\n\np = [] #\u70b9p\nedge = []\nfor i in range(n):\n    x,y = map(int,input().split())\n    p.append([x,y,i])\np.sort(key=lambda x:x[0])\nfor i in range(n-1):\n    x_0,_,j=p[i]\n    x_1,_,k=p[i+1]\n    edge.append([x_1-x_0,j,k]) # \u91cd\u307fx_1 - x_0\u306e\u70b9j\u3068\u70b9k\u3092\u7e4b\u3050\u8fba\np.sort(key=lambda x:x[1])\nfor i in range(n-1):\n    _,y_0,j=p[i]\n    _,y_1,k=p[i+1]\n    edge.append([y_1-y_0,j,k])\n\nedge.sort() #\u30af\u30e9\u30b9\u30ab\u30eb\u6cd5\u3092\u4f7f\u3046\u306e\u3067\u91cd\u307f\u3067\u30bd\u30fc\u30c8\nans = 0\nfor i in range(len(edge)):\n    cost,u,v = edge[i]\n    if not same(u,v):\n        unite(u,v)\n        ans+=cost\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nN = int(input())\n# XY_L = [[int(_) for _ in input().split()] for __ in range(N)]\nX_L = [None] * N\nY_L = [None] * N\nfor i in range(N):\n    _x, _y = list(map(int, input().split()))\n    X_L[i] = [_x, i]\n    Y_L[i] = [_y, i]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.rank = [1] * n\n        self.par = [int(_) for _ in range(n)]\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] > self.rank[y]:\n            self.par[y] = x\n        else:\n            self.par[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n\nX_L.sort()\nY_L.sort()\ndx_l = [None] * (N-1)\ndy_l = [None] * (N-1)\nfor i in range(N-1):\n    dx_l[i] = [X_L[i+1][0] - X_L[i][0], X_L[i][1], X_L[i+1][1]]\n    dy_l[i] = [Y_L[i+1][0] - Y_L[i][0], Y_L[i][1], Y_L[i+1][1]]\n\ntmp_l = dx_l+dy_l\ntmp_l.sort()\n\nUF = UnionFind(N)\nans = 0\n\nfor _ in range(2*N-2):\n    _d, _i, _j = tmp_l[_]\n    if _i >= N or _j >= N:\n        print((_i, _j))\n    if UF.same(_i, _j):\n        continue\n    UF.unite(_i, _j)\n    ans += _d\n\nprint(ans)\n\n", "n=int(input())\nxy=[list(map(int,input().split())) for _ in range(n)]\nx,y=zip(*xy)\nx=list(zip(range(n),x))\ny=list(zip(range(n),y))\nx.sort(key=lambda a:a[1])\ny.sort(key=lambda a:a[1])\nd=[]\nfor i in range(n-1):\n  d.append([x[i+1][1]-x[i][1],x[i+1][0],x[i][0]])\n  d.append([y[i+1][1]-y[i][1],y[i+1][0],y[i][0]])\nd.sort(key=lambda a:a[0],reverse=True)\n# Union FInd\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nans=0\nuf=UnionFind(n)\nwhile d:\n  dist,i,j=d.pop()\n  if uf.same(i,j):\n    continue\n  uf.union(i,j)\n  ans+=dist\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nN = int(input())\n# XY_L = [[int(_) for _ in input().split()] for __ in range(N)]\nX_L = [None] * N\nY_L = [None] * N\nfor i in range(N):\n    _x, _y = list(map(int, input().split()))\n    X_L[i] = [_x, i]\n    Y_L[i] = [_y, i]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# class UnionFind():\n#     def __init__(self, n):\n#         self.rank = [1] * n\n#         self.par = [int(_) for _ in range(n)]\n\n#     def find(self, x):\n#         if self.par[x] == x:\n#             return x\n#         else:\n#             self.par[x] == self.find(self.par[x])\n#             return self.par[x]\n\n#     def unite(self, x, y):\n#         p_x = self.find(x)\n#         p_y = self.find(y)\n#         if p_x == p_y:\n#             return False\n#         if self.rank[p_x] < self.rank[p_y]:\n#             self.par[p_x] = p_y\n#         else:\n#             self.par[p_y] = p_x\n#             if self.rank[p_x] == self.rank[p_y]:\n#                 self.rank[p_x] += 1\n#         return True\n    \n#     def same(self, x, y):\n#         if self.find(x) == self.find(y):\n#             return True\n#         else:\n#             return False\n\nX_L.sort()\nY_L.sort()\ndx_l = [None] * (N-1)\ndy_l = [None] * (N-1)\nfor i in range(N-1):\n    dx_l[i] = [X_L[i+1][0] - X_L[i][0], X_L[i][1], X_L[i+1][1]]\n    dy_l[i] = [Y_L[i+1][0] - Y_L[i][0], Y_L[i][1], Y_L[i+1][1]]\n\ntmp_l = dx_l+dy_l\ntmp_l.sort()\n\nUF = UnionFind(N)\nans = 0\n\nfor _ in range(2*N-2):\n    _d, _i, _j = tmp_l[_]\n    if UF.same(_i, _j):\n        continue\n    UF.unite(_i, _j)\n    ans += _d\n    # if _ % 1000 == 0:\n    #     print(_,ans)\n\n\n\nprint(ans)\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nN = int(input())\nx, y = [], []\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    x.append([a, i])\n    y.append([b, i])\nx.sort()\ny.sort()\n\ne = []\nfor i in range(N-1):\n    e.append([abs(x[i][0]-x[i+1][0]), x[i][1], x[i+1][1]])\n    e.append([abs(y[i][0]-y[i+1][0]), y[i][1], y[i+1][1]])\n\ne.sort()\n\nuft = UnionFind(N)\n\nans = 0\nfor w, s, t in e:\n    if not uft.same(s, t):\n        uft.union(s, t)\n        ans += w\n\nprint(ans)\n", "n=int(input())\nx=[]\ny=[]\nfor i in range(n):\n  xx,yy=map(int,input().split())\n  x.append([xx,i])\n  y.append([yy,i])\nx.sort()\ny.sort()\npx=[[x1-x0,i0,i1] for (x0,i0),(x1,i1) in zip(x,x[1:])]\npy=[[y1-y0,i0,i1] for (y0,i0),(y1,i1) in zip(y,y[1:])]\np=px+py\nx=[]\ny=[]\npx=[]\npy=[]\np.sort()\nr=[i for i in range(n)]\nrank=[1 for i in range(n)]\ndef root(x):\n  if x==r[x]:\n    return x\n  else:\n    r[x]=root(r[x])\n    return r[x]\ndef union(path):\n  rx=root(path[1])\n  ry=root(path[2])\n  if rx==ry:\n    return 0\n  else:\n    if rank[rx]>rank[ry]:\n      r[rx]=ry\n      rank[rx]+=rank[ry]\n    else:\n      r[ry]=rx\n      rank[ry]+=rank[rx]\n    return path[0]\nans=0\nfor i in range(len(p)):\n  ans+=union(p[i])\nprint(ans)", "class UnionFind:\n    def __init__(self, n):\n        self.v = [-1] * n\n\n    def find(self, x):\n        if self.v[x] < 0:\n            return x\n        else:\n            self.v[x] = self.find(self.v[x])\n            return self.v[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            if self.v[x] > self.v[y]:\n                x, y = y, x\n            self.v[x] += self.v[y]\n            self.v[y] = x\n            return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.v[self.find(x)]\n\n\ndef main():\n    from operator import itemgetter\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n\n    ps = []\n    xs = set()\n    ys = set()\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        ps.append((x, y))\n        xs.add(x)\n        ys.add(y)\n\n    xs = tuple(sorted(xs))\n    ys = tuple(sorted(ys))\n\n    dx = {e: i for i, e in enumerate(xs)}\n    dy = {e: i for i, e in enumerate(ys)}\n\n    uf = UnionFind(N * 2)\n    for x, y in ps:\n        uf.unite(dx[x], dy[y] + N)\n\n    def make_edges(xs, d, *, add_val=0):\n        xes = []\n        for x0, x1 in zip(xs, xs[1:]):\n            xes.append((abs(x1 - x0), d[x0] + add_val, d[x1] + add_val))\n        return xes\n\n    xes = make_edges(xs, dx)\n    yes = make_edges(ys, dy, add_val=N)\n\n    # Kruskal\n    # \u6700\u5c0f\u30b3\u30b9\u30c8\u306e\u8fba\u304b\u3089\u9806\u306b\u4f7f\u7528\u3059\u308b\n    # \u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u5c5e\u3057\u3066\u3044\u308c\u3070\u3064\u306a\u304c\u306a\u3044(\u9589\u8def\u3092\u4f5c\u3089\u306a\u3044)\n    # \u30b3\u30b9\u30c8\u6607\u9806\u30bd\u30fc\u30c8\u6e08\u307f\u306e\u8fba\u30ea\u30b9\u30c8\u3092\u4f7f\u7528\u3059\u308b\n    ret = 0\n    joined = set()\n    for cost, a, b in sorted(xes + yes, key=itemgetter(0)):\n        if (a in joined) or (b in joined): continue\n        if uf.same(a, b): continue\n        uf.unite(a, b)\n        ret += cost\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**5)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.components = n  # \u9023\u7d50\u6210\u5206\u306e\u6570\n\n    def root(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.root(self.p[x])\n            return self.p[x]\n    \n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x != y:\n            self.p[x] = y\n            self.components -= 1\n    \n    def same(self, x,y):\n        return (self.root(x) == self.root(y))\n\nN = int(input())\nX, Y = [], []\nfor i in range(N):\n    x, y = map(int,input().split())\n    X.append([x, i])\n    Y.append([y, i])\n\nX.sort()\nY.sort()\n\nedges = []\nfor i in range(N-1):\n    edges.append([X[i+1][0]-X[i][0], X[i][1], X[i+1][1]])\n    edges.append([Y[i+1][0]-Y[i][0], Y[i][1], Y[i+1][1]])\nedges.sort()\n\nUF = UnionFind(N)\nans = 0\nfor cost, s, t in edges:\n    if UF.same(s,t): continue\n\n    UF.unite(s,t)\n    ans += cost\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nfrom scipy.sparse import csr_matrix\nimport numpy as np\n\nN = int(input())\n\nXY = [[i] + [int(x) for x in input().split()] for i in range(N)]\n\nedge = set()\nfor key in [itemgetter(1),itemgetter(2)]:\n  XY.sort(key = key)\n  for i in range(N-1):\n    i1,x1,y1 = XY[i]\n    i2,x2,y2 = XY[i+1]\n    d = min(abs(x1-x2),abs(y1-y2))\n    edge.add((i1,i2,d))\n    \nrow,col,value = list(zip(*edge))\nvalue = np.array(value,dtype=int)\ngraph = csr_matrix((value,(row,col)),shape=(N,N))\n\nfrom scipy.sparse.csgraph import minimum_spanning_tree\ntree = minimum_spanning_tree(graph, overwrite = True).astype(int)\nanswer = tree.sum()\nprint(answer)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        \"\"\"\n        \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"\n        y\u3092x\u306e\u6839\u306b\u7e4b\u3050\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        \"\"\"\n        x\u3068y\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"\n        x\u306e\u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def kruskal(self, edge):\n        \"\"\"\n        :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n        :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n        \"\"\"\n        edge.sort()\n        cost_sum = 0\n        for cost, node1, node2 in edge:\n            if not self.same(node1, node2):\n                cost_sum += cost\n                self.union(node1, node2)\n        return cost_sum\n\n\ndef resolve():\n    n = int(input())\n    X, Y = [], []\n    for i in range(n):\n        x, y = list(map(int, input().split()))\n        X.append([x, i])\n        Y.append([y, i])\n    X.sort()\n    Y.sort()\n    edge = []\n    for i in range(1, n):\n        cost1 = X[i][0] - X[i - 1][0]\n        edge.append([cost1, X[i - 1][1], X[i][1]])\n        cost2 = Y[i][0] - Y[i - 1][0]\n        edge.append([cost2, Y[i - 1][1], Y[i][1]])\n\n    uf = UnionFind(n)\n    res = uf.kruskal(edge)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn = int(input())\ngraphx = []\ngraphy = []\n\nfor i in range(n):\n    x,y = map(int,input().split())\n    graphx.append((x,y,i))\n    graphy.append((x,y,i))\ngraphx = sorted(graphx, key=lambda x:x[0])\ngraphy = sorted(graphy, key=lambda x:x[1])\ngraph = []\n\n\nfor k in range(n-1):\n    i,j = graphx[k][2], graphx[k+1][2]\n    x0,x1 = graphx[k][0],graphx[k+1][0]\n    m = abs(x0-x1)\n    graph.append((m,i,j))\n\nfor k in range(n-1):\n    i,j = graphy[k][2], graphy[k+1][2]\n    y0,y1 = graphy[k][1],graphy[k+1][1]\n    m = abs(y0-y1)\n    graph.append((m,i,j))\n\n\ngraph.sort()\n#print(graph)\n\nans = 0\nuf = UnionFind(n)\nfor c,i,j in graph:\n    if not uf.same(i,j):\n        ans += c\n        uf.union(i,j)\nprint(ans)", "def main():\n\timport sys\n\tinput=sys.stdin.readline\n\tn=int(input())\n\txy=[]\n\tnode=[[]for _ in range(n)]\n\tfor i in range(n):\n\t\tx,y=map(int,input().split())\n\t\txy.append((i,x,y))\n\txy.sort(key=lambda x:x[1])\n\tfor i in range(len(xy)-1):\n\t\tnode[xy[i][0]].append((abs(xy[i][1]-xy[i+1][1]),xy[i+1][0]))#dis,num\n\t\tnode[xy[i+1][0]].append((abs(xy[i][1]-xy[i+1][1]),xy[i][0]))#dis,num\n\txy.sort(key=lambda x:x[2])\n\tfor i in range(len(xy)-1):\n\t\tnode[xy[i][0]].append((abs(xy[i][2]-xy[i+1][2]),xy[i+1][0]))#dis,num\n\t\tnode[xy[i+1][0]].append((abs(xy[i][2]-xy[i+1][2]),xy[i][0]))#dis,num\n\tfrom heapq import heappop,heappush\n\tvisited=[False]*n\n\tvisited[0]=True\n\tpq=[]\n\tfor x in node[0]:\n\t\theappush(pq,(x[0],x[1]))\n\tans=0\n\tfor _ in range(n-1):\n\t\twhile True:\n\t\t\tu=heappop(pq)\n\t\t\tif visited[u[1]]==False:\n\t\t\t\tbreak\n\t\tans+=u[0]\n\t\tpre_dis=u[0]\n\t\tu_dis=u[0];u_num=u[1]\n\t\tans+=abs(u_dis-pre_dis)\n\t\tvisited[u_num]=True\n\t\tfor x in node[u_num]:\n\t\t\tx_dis=x[0];x_num=x[1]\n\t\t\tif visited[x_num]==False:\n\t\t\t\theappush(pq,(x_dis,x_num))\n\tprint(ans)\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**5)\nn = int(input())\nxy = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    xy.append((i, x, y))\nxx = sorted(xy, key=lambda x:x[1])\nyy = sorted(xy, key=lambda x:x[2])\nli = []\nfor i in range(n-1):\n    li.append((xx[i][0], xx[i+1][0], xx[i+1][1]-xx[i][1]))\n    li.append((yy[i][0], yy[i+1][0], yy[i+1][2]-yy[i][2]))\nli.sort(key=lambda x:x[2])\nclass UnionFind():\n    def __init__(self, li):\n        self.li = li\n    def root(self, x):\n        if self.li[x]==x:\n            return x\n        self.li[x] = self.root(self.li[x])\n        return self.li[x]\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx==ry:\n            return\n        self.li[ry] = rx\n    def same(self, x, y):\n        return self.root(x)==self.root(y)\nuf = UnionFind(list(range(n)))\nans = 0\nfor x, y, cost in li:\n    if uf.same(x, y):\n        continue\n    uf.unite(x, y)\n    ans += cost\nprint(ans)", "class UnionFind:\n    # \u3053\u306e\u6642\u70b9\u3067\u305d\u308c\u305e\u308c\u306e\u30ce\u30fc\u30c9\u306f\u81ea\u5206\u3092\u89aa\u3068\u3057\u3066\u3044\u308b\n    # \u521d\u671f\u5316\u6642\u306b\u554f\u984c\u304c0\u306e\u9802\u70b9\u3092\u8a8d\u3081\u308b\u304b\u306b\u6ce8\u610f\u3059\u308b\u3053\u3068\n    def __init__(self, n):\n        self.N = n\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n\n    # x\u306e\u6839\u3092\u8fd4\u3059\u95a2\u6570\n    def root(self, x):\n        visited_nodes = []\n        while True:\n            p = self.parent[x]\n            if p == x:\n                # \u7e2e\u7d04\n                for node in visited_nodes:\n                    self.parent[node] = x\n                return x\n            else:\n                visited_nodes.append(x)\n                x = p\n\n    # \u6728\u306e\u7d50\u5408\u3092\u884c\u3046\u3002\u89aa\u306e\u914d\u4e0b\u306b\u5165\u308b\n    def unite(self, x, y):\n        if not self.root(x) == self.root(y):\n            if self.rank[x] > self.rank[y]:\n                self.parent[self.root(y)] = self.root(x)\n            else:\n                self.parent[self.root(x)] = self.root(y)\n                if self.rank[x] == self.rank[y]:\n                    self.rank[self.root(y)] += 1\n\n    def ifSame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    # \u6728\u306e\u6839\u306b\u5230\u9054\u3059\u307e\u3067\u306b\u305f\u3069\u308b\u30ce\u30fc\u30c9\u306e\u914d\u5217\u3092\u8fd4\u3059\n    def printDebugInfo(self):\n        print([self.root(i) for i in range(self.N)])\n\n# edge=[cost, place, place] sorted by cost.\n# place are expected to be 0 to N-1\n# N : vertical count\n\n\ndef clascal(N, E, tree_count=1):\n    #E[weight, vertical, vertical]\n    tree = UnionFind(N)\n    weight = 0\n    counter = 0\n    # E[w, A, B]\n    for e in sorted(E):\n        if counter >= N-1:\n            break\n        if tree.ifSame(e[1], e[2]):\n            continue\n        else:\n            tree.unite(e[1], e[2])\n            weight += e[0]\n            counter += 1\n    return weight\n\n\n# \u3044\u3064\u3082\u3053\u3053\u304b\u3089\nN = int(input())\nX = []\nY = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    X.append((x, i))\n    Y.append((y, i))\nX.sort()\nY.sort()\ndiff = []\nfor i in range(N - 1):\n    diff.append((X[i + 1][0] - X[i][0], X[i][1], X[i+1][1]))\n    diff.append((Y[i + 1][0] - Y[i][0], Y[i][1], Y[i + 1][1]))\ndiff.sort()\nprint((clascal(N, diff)))\n", "import sys\nsys.setrecursionlimit(10**9)\nclass UnionFind:\n  def __init__(self,n):\n    self.n=[-1]*n\n    self.r=[0]*n\n    self.siz=n\n  def find_root(self,x):\n    if self.n[x]<0:\n      return x\n    else:\n      self.n[x]=self.find_root(self.n[x])\n      return self.n[x]\n  def unite(self,x,y):\n    x=self.find_root(x)\n    y=self.find_root(y)\n    if x==y:return\n    elif self.r[x]>self.r[y]:\n      self.n[x]+=self.n[y]\n      self.n[y]=x\n    else:\n      self.n[y]+=self.n[x]\n      self.n[x]=y\n      if self.r[x]==self.r[y]:\n        self.r[y]+=1\n    self.siz-=1\n  def root_same(self,x,y):\n    return self.find_root(x)==self.find_root(y)\n  def count(self,x):\n    return -self.n[self.find_root(x)]\n  def size(self):\n    return self.siz\n\nn=int(input())\nxy=[list(map(int,input().split()))+[i] for i in range(n)]\nG=[]\n\n# MST\u3092\u6c42\u3081\u308b\nxy.sort()\nfor j in range(1,n):\n  sx,sy,si=xy[j-1]\n  tx,ty,ti=xy[j]\n  G.append((min(abs(sx-tx),abs(sy-ty)),si,ti))\n\nxy.sort(key=lambda x:x[1])\nfor j in range(1,n):\n  sx,sy,si=xy[j-1]\n  tx,ty,ti=xy[j]\n  G.append((min(abs(sx-tx),abs(sy-ty)),si,ti))\n\n# Kruskal \u6cd5\nu=UnionFind(n)\nans=0\nG.sort()\nfor c,x,y in G:\n  if u.root_same(x,y):continue\n  u.unite(x,y)\n  ans+=c\nprint(ans)\n", "N = int(input())\nXs = []\nYs = []\nfor i in range(N):\n    x, y = map(int, input().split())\n    Xs.append((x, i))\n    Ys.append((y, i))\nXs.sort()\nYs.sort()\nEdges = []\nfor i in range(1, N):\n    (x1, v1), (x2, v2) = Xs[i-1], Xs[i]\n    Edges.append((abs(x1-x2), v1, v2))\n    (y1, v1), (y2, v2) = Ys[i-1], Ys[i]\n    Edges.append((abs(y1-y2), v1, v2))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\nimport heapq\nheapq.heapify(Edges)\nuf = UnionFind(N)\nans = 0\nwhile Edges:\n    d, a, b = heapq.heappop(Edges)\n    if not uf.same(a, b):\n        ans += d\n        uf.union(a, b)\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\ninput=sys.stdin.readline\nn=int(input())\npoints=[list(map(int,input().split()))+[i] for i in range(n)]\npoints.sort(key = lambda x:x[1])\nedge=[]\nfor i in range(n-1):\n    edge.append((points[i][2],points[i+1][2],points[i+1][1]-points[i][1]))\npoints.sort()\nfor i in range(n-1):\n    edge.append((points[i][2],points[i+1][2],points[i+1][0]-points[i][0]))\nclass UnionFind(object):\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1 for i in range(N)]\n    \n    def merge(self, a, b):\n        if self.issame(a,b):\n            return\n        pa = self.root(a)\n        pb = self.root(b)\n        self.parent[pa] = pb\n        self.size[pb] += self.size[pa]\n    def root(self, x):\n        p = self.parent[x]\n        if p == x:\n            return x\n        else:\n            r = self.root(p)\n            self.parent[x] = r\n            return r\n    \n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n    \n    def getsize(self, x):\n        return self.size[self.root(x)]\nedge.sort(key=lambda x:x[2])\nuf=UnionFind(n)\nans=0\nfor ed in edge:\n    if uf.issame(ed[0],ed[1]):continue\n    ans+=ed[2]\n    uf.merge(ed[0],ed[1])\nprint(ans)", "from heapq import heappop,heappush\nimport sys\nsys.setrecursionlimit(10**6)\nn=int(input())\npair=[i for i in range(n)]\nque=[]\ne=[None]*n\nfor i in range(n):\n  x,y=map(int,input().split())\n  e[i]=(i,x,y)\nex=sorted(e,key=lambda x:x[1])\ney=sorted(e,key=lambda x:x[2])\nfor i in range(n-1):\n  w=ex[i+1][1]-ex[i][1]\n  heappush(que,(w,ex[i][0],ex[i+1][0]))\nfor i in range(n-1):\n  w=ey[i+1][2]-ey[i][2]\n  heappush(que,(w,ey[i][0],ey[i+1][0]))\ndef find(x):\n  if x==pair[x]:return x\n  else:\n    tmp=find(pair[x])\n    pair[x]=tmp\n    return tmp\nq=[]\nans=0\nwhile que:\n  w,s,t=heappop(que)\n  root_s=find(s)\n  root_t=find(t)\n  if root_s!=root_t:\n    pair[root_s]=root_t\n    ans+=w\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\nfrom itertools import permutations\nn = int(input())\nlist_XY = []\nlist_CO = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    list_XY.append([x, y, i])\n\nlist_XY.sort(key=lambda x:x[0])\nfor i in range(n-1):\n    list_CO.append([list_XY[i][2], list_XY[i+1][2], abs(list_XY[i][0]-list_XY[i+1][0])])\n\nlist_XY.sort(key=lambda x:x[1])\nfor i in range(n-1):\n    list_CO.append([list_XY[i][2], list_XY[i+1][2], abs(list_XY[i][1]-list_XY[i+1][1])])\n\nlist_CO.sort(key=lambda x:x[2])\nuf = UnionFind(n)\nans = 0\n\nfor i, j, cost in list_CO:\n    if not uf.same(i, j):\n        uf.union(i, j)\n        ans += cost\n    if uf.size(0) == n:\n        break\n\nprint(ans)", "class UnionFind:\n    def __init__(self, n=1):\n        self.parent = [i for i in range(n)]\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.parent[y] = x\n    \n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN = int(input())\nuf = UnionFind(N)\nX = []; Y = []\nfor i in range(N):\n  x, y = map(int, input().split())\n  X.append((x, i)); Y.append((y, i))\n\nX.sort()\nY.sort()\nroad = []\n\ndef add_cand(Z):\n  nonlocal road\n  z1, i1 = Z[0]\n  for j in range(1, N):\n    z2, i2 = Z[j]\n    road.append((z2-z1, i1, i2))\n    z1, i1 = z2, i2\n\nadd_cand(X); add_cand(Y)\n\nroad.sort()\nans = 0\nfor cost, i, j in road:\n  if uf.is_same(i, j):\n    continue\n  uf.union(i, j)\n  ans += cost\n\nprint(ans)", "class DisjointSets:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.siz = [1]*n\n\n    def root(self,x):\n        if x != self.parent[x]: \n            self.parent[x] = self.root(self.parent[x])\n        return self.parent[x]\n\n    def same(self,x,y): \n        return self.root(x) == self.root(y)\n\n    def unite(self,x,y): \n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.siz[x] < self.siz[y]:\n            x,y = y,x\n        self.parent[y] = x\n        self.siz[x] += self.siz[y]\n\n    def size(self,x):\n        return self.siz[self.root(x)]\n        \nn = int(input())\nX = []\nY = []\nfor i in range(n):\n    x,y = list(map(int,input().split()))\n    X.append((i,x))\n    Y.append((i,y))\nX.sort(key = lambda x:x[1])\nY.sort(key = lambda y:y[1])\nedges = []\nfor i in range(1,n):\n    a,x1 = X[i-1]\n    b,x2 = X[i]\n    edges.append((a,b,x2-x1))\n    c,y1 = Y[i-1]\n    d,y2 = Y[i]\n    edges.append((c,d,y2-y1))\nedges.sort(key = lambda y:y[2])\n\nans = 0\nds = DisjointSets(n)\nfor i in range(2*n-2):\n    u,v,dist = edges[i]\n    if ds.same(u,v): continue\n    ds.unite(u,v)\n    ans += dist\nprint(ans)\n", "import heapq\n\n\nclass UnionFind:\n    from collections import deque\n\n    def __init__(self, v):\n        self.v = v\n        self._tree = list(range(v + 1))\n\n    def _root(self, a):\n        queue = self.deque()\n        while self._tree[a] != a:\n            queue.append(a)\n            a = self._tree[a]\n        while queue:\n            index = queue.popleft()\n            self._tree[index] = a\n        return a\n\n    def union(self, a, b):\n        root_a = self._root(a)\n        root_b = self._root(b)\n        self._tree[root_b] = root_a\n\n    def find(self, a, b):\n        return self._root(a) == self._root(b)\n\n\nN = int(input())\nV = []\nfor i in range(N):\n    s, t = list(map(int, input().split(' ')))\n    V.append((i, s, t))\n\nE = []\nvx = sorted(V, key=lambda v: v[1])\nfor v1, v2 in zip(vx, vx[1:]):\n    i, x1, y1 = v1\n    j, x2, y2 = v2\n    heapq.heappush(E, (abs(x1 - x2), i, j))\n\nvy = sorted(V, key=lambda v: v[2])\nfor v1, v2 in zip(vy, vy[1:]):\n    i, x1, y1 = v1\n    j, x2, y2 = v2\n    heapq.heappush(E, (abs(y1 - y2), i, j))\n\nuf = UnionFind(N)\ncost = 0\nwhile E:\n    c, i, j = heapq.heappop(E)\n    if not uf.find(i, j):\n        uf.union(i, j)\n        cost += c\n\nprint(cost)\n", "from scipy.sparse.csgraph import minimum_spanning_tree\nfrom scipy.sparse import csr_matrix\n\nN = int(input())\nA = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    A.append((i, x, y))\n\nlength, frm, to = [], [], []\npath_set = set()\n\n\ndef path(axis):\n    A.sort(key=lambda x: x[axis])\n    for i in range(N - 1):\n        if (A[i][0], A[i + 1][0]) in path_set:\n            continue\n        length.append(min(abs(A[i][1] - A[i + 1][1]),\n                          abs(A[i][2] - A[i + 1][2])))\n        frm.append(A[i][0])\n        to.append(A[i + 1][0])\n        path_set.add((A[i][0], A[i + 1][0]))\n\n\npath(1)\npath(2)\nmatr = csr_matrix((length, (frm, to)), shape=(N, N))\n\nT = minimum_spanning_tree(matr).astype(int)\nprint((sum(T.data)))\n", "\n# n\u500b\u306e\u8981\u7d20\u30920~N-1\u3067\u7ba1\u7406\nclass UnionFind():\n    # \u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    # \u8981\u7d20\u304c\u6839\uff08\u30eb\u30fc\u30c8\uff09\u306e\u5834\u5408\u306f-(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\u3092\u683c\u7d0d\u3059\u308b\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    # \u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    # \u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n    def group_count(self):\n        return len(self.roots())\n\n    # {\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u8f9e\u66f8\u3092\u8fd4\u3059\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    # \u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059 (print()\u3067\u306e\u8868\u793a\u7528)\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef resolve():\n    N = int(input())\n    X = []\n    Y = []\n    # \u753a\u306e\u30ca\u30f3\u30d0\u30fc\u3082\u4ed8\u3051\u308b\n    for i in range(N):\n        x, y = map(int, input().split())\n        X.append((i, x))\n        Y.append((i, y))\n\n    # \u77ed\u3044\u8ddd\u96e2\u306b\u3042\u308b\u8857\u3092\u3064\u306a\u3052\u3070\u826f\u3044\u306e\u3067\u30bd\u30fc\u30c8\u3059\u308b\n    X.sort(key=lambda x: x[1])\n    Y.sort(key=lambda x: x[1])\n\n    # \u30b3\u30b9\u30c8\u3092\u8a08\u7b97\u3057\u30b0\u30e9\u30d5\u3092\u4f5c\u6210\n    G = []\n    for i in range(1, N):\n        a, x1 = X[i - 1]\n        b, x2 = X[i]\n        G.append((a,b,x2-x1))\n        a, y1 = Y[i - 1]\n        b, y2 = Y[i]\n        G.append((a, b, y2 - y1))\n\n    # \u30af\u30e9\u30b7\u30ab\u30eb\u6cd5\u3067\u6700\u5c0f\u5168\u57df\u6728\n    ans = 0\n    uf = UnionFind(N)\n    G.sort(key=lambda x: x[2])\n    for a, b, w in G:\n        if not uf.is_same(a, b):\n            uf.union(a, b)\n            ans += w\n    print(ans)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN = int(input())\nXYI = [tuple(map(int,input().split() + [i])) for i in range(N)]\nsx = sorted(XYI, key=lambda x:x[0])\nsy = sorted(XYI, key=lambda x:x[1])\n\nes = []\nfor (x0,_,i0),(x1,_,i1) in zip(sx,sx[1:]):\n    es.append((x1-x0, i0, i1))\nfor (_,y0,i0),(_,y1,i1) in zip(sy,sy[1:]):\n    es.append((y1-y0, i0, i1))\nes.sort(key=lambda x:x[0])\n\nclass UnionFind:\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self._size = [1] * N\n        self.count = 0\n    def root(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            self.parent[a] = self.root(self.parent[a])\n            return self.parent[a]\n    def is_same(self,a,b):\n        return self.root(a) == self.root(b)\n    def unite(self,a,b):\n        ra = self.root(a)\n        rb = self.root(b)\n        if ra == rb: return\n        if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n        self._size[ra] += self._size[rb]\n        self.parent[rb] = ra\n        self.count += 1\n    def size(self,a):\n        return self._size[self.root(a)]\nuf = UnionFind(N)\n\nans = 0\nfor d,a,b in es:\n    if uf.is_same(a,b): continue\n    uf.unite(a,b)\n    ans += d\nprint(ans)", "import numpy as np\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nfrom scipy.sparse import csr_matrix, coo_matrix, lil_matrix\nfrom operator import itemgetter\n\nN = int(input())\nP = []\nfor i in range(N):\n  x,y = map(int, input().split())\n  P.append((x,y,i))\n  \ndata = [10, 20, 30, 40]\nrow = [0, 0, 1, 1]\ncol = [1, 2, 0, 2]\n\n#print(csr_matrix((data, (row, col))).toarray())\n  \ndata = []\nrow = []\ncol = []\n\nP.sort() \nD = {}\nfor i in range(N-1):\n  a,b,p = P[i]\n  c,d,q = P[i+1]\n  cost = min(abs(a-c), abs(b-d))\n  data.append(cost)\n  row.append(p)\n  col.append(q)\n  data.append(cost)\n  row.append(q)\n  col.append(p)\n  D[(p,q)] = cost\n  D[(q,p)] = cost\n\nP.sort(key=itemgetter(1))\nfor i in range(N-1):\n  a,b,p = P[i]\n  c,d,q = P[i+1]\n  if (p,q) in D:\n    continue\n  cost = min(abs(a-c), abs(b-d))\n  data.append(cost)\n  row.append(p)\n  col.append(q)\n  data.append(cost)\n  row.append(q)\n  col.append(p)\n  D[(p,q)] = cost\n  D[(q,p)] = cost\n\ncoo = coo_matrix((data, (row, col)), (N, N))\nmst = minimum_spanning_tree(coo)\nprint(int(mst.sum()))", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\n# Union Find\uff08\u7d4c\u8def\u5727\u7e2e\u6709\uff09\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    # \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # \u6839\u3092\u7e4b\u304e\u76f4\u3059\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    # \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\ndef kruskal(max_node, edge):\n    \"\"\"\n    :param max_node: UnionFind\u6728\u306b\u6e21\u3059\u9802\u70b9\u6570\u3067\u3059\n    :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n    :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n    \"\"\"\n    edge.sort()\n    uf = UnionFind(max_node)\n    cost_sum = 0\n    for cost, node1, node2 in edge:\n        if not uf.same(node1, node2):\n            cost_sum += cost\n            uf.union(node1, node2)\n    return cost_sum\n\n\ndef resolve():\n    n = int(input())\n    X, Y = [], []\n    for i in range(n):\n        x, y = list(map(int, input().split()))\n        X.append([x, i])\n        Y.append([y, i])\n\n    X.sort()\n    Y.sort()\n    cost = []\n    for i in range(n - 1):\n        cost.append([abs(X[i][0] - X[i + 1][0]), X[i][1], X[i + 1][1]])\n        cost.append([abs(Y[i][0] - Y[i + 1][0]), Y[i][1], Y[i + 1][1]])\n\n    res = kruskal(n, cost)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from scipy.sparse import *\nfrom scipy.sparse.csgraph import *\nN = int(input())\nT = [[n]+list(map(int,input().split())) for n in range(N)]\nP = set()\n\nfor i in [1,2]:\n  T.sort(key=lambda a: a[i])\n  for j in range(1,N):\n    i0,x0,y0 =  T[j-1]\n    i1,x1,y1 =  T[j]\n    P.add((min(abs(x1-x0),abs(y1-y0)),i0,i1))\n\nd,i,j = zip(*P)\nG = csr_matrix((d,(i,j)),shape=(N,N))\nprint(int(minimum_spanning_tree(G).sum()))", "import sys;sys.setrecursionlimit(10**9)\nclass UnionFind:\n  def __init__(self,n):\n    self.n=[-1]*n\n    self.r=[0]*n\n    self.siz=n\n  def find_root(self,x):\n    if self.n[x]<0:\n      return x\n    else:\n      self.n[x]=self.find_root(self.n[x])\n      return self.n[x]\n  def unite(self,x,y):\n    x=self.find_root(x)\n    y=self.find_root(y)\n    if x==y:return\n    elif self.r[x]>self.r[y]:\n      self.n[x]+=self.n[y]\n      self.n[y]=x\n    else:\n      self.n[y]+=self.n[x]\n      self.n[x]=y\n      if self.r[x]==self.r[y]:\n        self.r[y]+=1\n    self.siz-=1\n  def root_same(self,x,y):\n    return self.find_root(x)==self.find_root(y)\n  def count(self,x):\n    return -self.n[self.find_root(x)]\n  def size(self):\n    return self.siz\n\nn=int(input())\nxy=[list(map(int,input().split()))+[i]for i in range(n)]\nxy.sort()\nedge=[]\nfor j in range(1,n):\n  sx,sy,si=xy[j-1]\n  tx,ty,ti=xy[j]\n  edge.append((min(abs(sx-tx),abs(sy-ty)),si,ti))\nxy.sort(key=lambda x:x[1])\nfor j in range(1,n):\n  sx,sy,si=xy[j-1]\n  tx,ty,ti=xy[j]\n  edge.append((min(abs(sx-tx),abs(sy-ty)),si,ti))\nu=UnionFind(n)\nans=0\nedge.sort()\nfor c,x,y in edge:\n  if u.root_same(x,y):continue\n  u.unite(x,y)\n  ans+=c\nprint(ans)", "# atcoder problem solving\n\n# Built?\nimport sys\ninput=sys.stdin.readline\nN = int(input())\nd = []\n\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    d.append((i+1, x, y))\n\nedge = []\n\n# x\u5ea7\u6a19\u306b\u95a2\u3059\u308b\u8fba\u306e\u8a2d\u5b9a\n\nd.sort(key=lambda x: x[1])\n\nfor i in range(N-1):\n    a, px, py = d[i]\n    b, qx, qy = d[i+1]\n    dis = abs(px-qx)\n\n    edge.append((dis, a, b))\n    edge.append((dis, b, a))\n\n# y\u5ea7\u6a19\u306b\u95a2\u3059\u308b\u8fba\u306e\u8a2d\u5b9a\n\nd.sort(key=lambda x: x[2])\n\nfor i in range(N-1):\n    a, px, py = d[i]\n    b, qx, qy = d[i+1]\n    dis = abs(py-qy)\n\n    edge.append((dis, a, b))\n    edge.append((dis, b, a))\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nedge.sort()\n# \u6700\u5c0f\u5168\u57df\u6728\uff08\u30af\u30e9\u30b9\u304b\u308b\u307b\u3046\uff09\ndef kruskal():\n    res = 0\n    G = UnionFind(N)\n    for cost, p, q, in edge:\n        if not G.same(p, q):\n            G.union(p, q)\n            res += cost\n    return res\n\n\nans = kruskal()\n\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.v = [-1] * n\n\n    def find(self, x):\n        if self.v[x] < 0:\n            return x\n        else:\n            self.v[x] = self.find(self.v[x])\n            return self.v[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            if self.v[x] > self.v[y]:\n                x, y = y, x\n            self.v[x] += self.v[y]\n            self.v[y] = x\n            return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.v[self.find(x)]\n\n\ndef main():\n    from operator import itemgetter\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n\n    ps = []\n    xs = set()\n    ys = set()\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        ps.append((x, y))\n        xs.add(x)\n        ys.add(y)\n\n    xs = tuple(sorted(xs))\n    ys = tuple(sorted(ys))\n\n    dx = {e: i for i, e in enumerate(xs)}\n    dy = {e: i for i, e in enumerate(ys)}\n\n    uf = UnionFind(N * 2)\n    for x, y in ps:\n        uf.unite(dx[x], dy[y] + N)\n\n    def make_edges(xs, d, *, add_val=0):\n        xes = []\n        for x0, x1 in zip(xs, xs[1:]):\n            xes.append((abs(x1 - x0), d[x0] + add_val, d[x1] + add_val))\n        return xes\n\n    xes = make_edges(xs, dx)\n    yes = make_edges(ys, dy, add_val=N)\n\n    # Kruskal\n    # \u6700\u5c0f\u30b3\u30b9\u30c8\u306e\u8fba\u304b\u3089\u9806\u306b\u4f7f\u7528\u3059\u308b\n    # \u540c\u3058\u9023\u7d50\u6210\u5206\u306b\u5c5e\u3057\u3066\u3044\u308c\u3070\u3064\u306a\u304c\u306a\u3044(\u9589\u8def\u3092\u4f5c\u3089\u306a\u3044)\n    # \u30b3\u30b9\u30c8\u6607\u9806\u30bd\u30fc\u30c8\u6e08\u307f\u306e\u8fba\u30ea\u30b9\u30c8\u3092\u4f7f\u7528\u3059\u308b\n    ret = 0\n    # joined = set()\n    for cost, a, b in sorted(xes + yes, key=itemgetter(0)):\n        # if (a in joined) or (b in joined): continue\n        if uf.same(a, b): continue\n        uf.unite(a, b)\n        ret += cost\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\nimport copy\nN = int(input())\nA = [0] * N\nfor i in range(N):\n  a, b = list(map(int, input().split()))\n  A[i] = [i, a, b]\n\nB = copy.deepcopy(A)  \nA = sorted(A, key = lambda x:x[1])\nB = sorted(B, key = lambda x:x[2])\n#print(A, B)\n\n#\u305d\u308c\u305e\u308c\u306e\u8fba\u306e\u306a\u304c\u3055\u3092\u6c42\u3081\u3066\u3001\u5c0f\u3055\u3044\u9806\u306b\u3059\u308b\n#[\u70b9\u306e\u756a\u53f7\u3001\u70b9\u306e\u756a\u53f7\u3001\uff12\u70b9\u9593\u8ddd\u96e2]\nA2 = [0] * (N - 1)\nfor i in range(1, N):\n  l = abs(A[i][1] - A[i - 1][1])\n  A2[i - 1] = [A[i][0], A[i - 1][0], l]\n\nB2 = [0] * (N - 1)\nfor i in range(1, N):\n  l = abs(B[i][2] - B[i - 1][2])\n  B2[i - 1] = [B[i][0], B[i - 1][0], l]  \nLen = A2 + B2\nLen = sorted(Len, key = lambda x:x[2])\n#print(Len)\n\ndata = UnionFind(N + 1)\ncost = 0\nfor i in range(len(Len)):\n    if not data.same_check(Len[i][0], Len[i][1]):\n      data.union(Len[i][0], Len[i][1])\n      cost += Len[i][2]\n\n  \nprint(cost)  \n  \n  \n\n", "from operator import itemgetter\nfrom scipy.sparse import csr_matrix\nimport numpy as np\n\nN = int(input())\n\nXY = [[i] + [int(x) for x in input().split()] for i in range(N)]\n\nedge = set()\nfor key in [itemgetter(1),itemgetter(2)]:\n  XY.sort(key = key)\n  for i in range(N-1):\n    i1,x1,y1 = XY[i]\n    i2,x2,y2 = XY[i+1]\n    d = min(abs(x1-x2),abs(y1-y2))\n    edge.add((i1,i2,d))\n    \n# csr\u5f62\u5f0f\u306b\u76f4\u3059\nrow,col,value = zip(*edge)\nvalue = np.array(value,dtype=int)\ngraph = csr_matrix((value,(row,col)),shape=(N,N))\n\n# \u6700\u5c0f\u5168\u57df\u6728\nfrom scipy.sparse.csgraph import minimum_spanning_tree\ntree = minimum_spanning_tree(graph, overwrite = True).astype(int)\nanswer = tree.sum()\nprint(answer)", "class UnionFind:\n    def __init__(self,n):\n        self.v=[-1]*n\n    \n    def find(self,x):\n        if self.v[x]<0:\n            return x\n        else:\n            self.v[x]=self.find(self.v[x])\n            return self.v[x]\n    \n    def unite(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n\n        if x==y:\n            return False\n        else:\n            if self.v[x]>self.v[y]:\n                x,y=y,x\n            self.v[x]+=self.v[y]\n            self.v[y]=x\n            return True\n    \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n    \n    def size(self,x):\n        return -self.v[self.find(x)]\n\nimport sys\n\nN=int(sys.stdin.readline())\nps=[]\nxs=set()\nys=set()\nfor i in range(N):\n    x,y=map(int,input().split())\n    ps.append((x,y))\n    xs.add(x)\n    ys.add(y)\n\nxs=tuple(sorted(xs))\nys=tuple(sorted(ys))\n\ndx={e:i for i,e in enumerate(xs)}\ndy={e:i for i,e in enumerate(ys)}\nuf=(UnionFind(N*2))\nfor x,y in ps:\n    uf.unite(dx[x],dy[y]+N)\n\ndef make_edges(xs,start):\n    xes=[]\n    for i, (x0,x1) in enumerate(zip(xs,xs[1:]),start=start):\n        xes.append((abs(x1-x0), i, i+1))\n    return xes\n\nxes=make_edges(xs,start=0)\nyes=make_edges(ys,start=N)\n\nret=0\nfor cost,a,b in sorted(xes+yes,key=lambda x:x[0]):\n    if uf.same(a,b):\n        continue\n    uf.unite(a,b)\n    ret+=cost\nprint(ret)", "import heapq\ndef prim():\n    used = [True]*n\n    edgelist = []\n    for e in edge[0]:\n        heapq.heappush(edgelist, e)\n        used[0] = False\n    res = 0\n    while len(edgelist) != 0:\n        minedge = heapq.heappop(edgelist)\n        if not  used[minedge[1]]:\n            continue\n        v = minedge[1]\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist, e)\n        res += minedge[0]\n    return res\nn = int(input())\nP = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    P.append((x, y, i))\nP.sort()\nedge = [[] for _ in range(n)]\nfor i in range(n-1):\n    d = min(abs(P[i+1][0]-P[i][0]), abs(P[i+1][1]-P[i][1]))\n    edge[P[i][2]].append((d, P[i+1][2]))\n    edge[P[i+1][2]].append((d, P[i][2]))\nP.sort(key = lambda x: x[1])\nfor i in range(n-1):\n    d = min(abs(P[i+1][0]-P[i][0]), abs(P[i+1][1]-P[i][1]))\n    edge[P[i][2]].append((d, P[i+1][2]))\n    edge[P[i+1][2]].append((d, P[i][2]))\nprint(prim())", "#UnionFind\u6728\u3068\u305d\u308c\u3092\u5229\u7528\u3057\u305f\u30af\u30e9\u30b9\u30ab\u30eb\u6cd5\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n                x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def nums(self,x):\n        return abs(self.parents[self.find(x)])\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN = int(input())\nA = [list(map(int, input().split()))+[i] for i in range(N)]\nedge = []\nA.sort()\nfor i in range(N-1):\n    w = A[i+1][0]-A[i][0]\n    edge.append((w,A[i][2],A[i+1][2]))\nA.sort(key=lambda x:x[1])\nfor i in range(N-1):\n    w = A[i+1][1]-A[i][1]\n    edge.append((w,A[i][2],A[i+1][2]))\n\nedge.sort()\n\nuf = UnionFind(N)\nans = 0\nfor i in range(len(edge)):\n    u,x,y = edge[i]\n    if not uf.same(x,y):\n        uf.union(x,y)\n        ans += u\nprint(ans)", "from heapq import heapify, heappop, heappush\nN, *A = list(map(int, open(0).read().split()))\n*A, = list(zip(*[iter(A)]*2))\nA = [(x, y, i) for i, (x, y) in enumerate(A)]\nA.sort()\nG = []\nx0, y0, i0 = A[0]\nfor x, y, i in A[1:]:\n    c = min(abs(x-x0), abs(y-y0))\n    heappush(G, (c, i0, i))\n    x0, y0, i0 = x, y, i\nA.sort(key=lambda x: x[1])\nx0, y0, i0 = A[0]\nfor x, y, i in A[1:]:\n    c = min(abs(x-x0), abs(y-y0))\n    heappush(G, (c, i0, i))\n    x0, y0, i0 = x, y, i\n\n\nclass UnionFind:\n    def __init__(self, n=0):\n        self.d = [-1]*n\n        self.u = n\n\n    def root(self, x):\n        if self.d[x] < 0:\n            return x\n        self.d[x] = self.root(self.d[x])\n        return self.d[x]\n\n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return False\n        if x > y:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        self.u -= 1\n        return True\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def size(self, x):\n        return -self.d[self.root(x)]\n\n    def num_union(self):\n        return self.u\n\n\nans = 0\nu = UnionFind(N)\nwhile u.num_union() > 1:\n    c, a, b = heappop(G)\n    if u.same(a, b):\n        continue\n    u.unite(a, b)\n    ans += c\n\nprint(ans)\n", "class UnionFind():\n    def __init__(self,n):\n        self.n=n\n        self.parents=[-1]*n\n\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n        if x==y:\n            return\n        if self.parents[x]>self.parents[y]:\n            x,y=y,x\n        self.parents[x]+=self.parents[y]\n        self.parents[y]=x\n\n    def size(self,x):\n        return -self.parents[self.find(x)]\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def members(self,x):\n        root=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x<0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn=int(input())\nX=[]\nY=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    X.append([x,i])\n    Y.append([y,i])\nX.sort()\nY.sort()\nE=[]\nfor i in range(n-1):\n    E.append([X[i+1][0]-X[i][0],X[i][1],X[i+1][1]])\n    E.append([Y[i+1][0]-Y[i][0],Y[i][1],Y[i+1][1]])\nE.sort()\nU=UnionFind(n)\nans=0\nfor i in range(2*n-2):\n    d=E[i][0]\n    j1=E[i][1]\n    j2=E[i][2]\n    if not U.same(j1,j2):\n        ans+=d\n        U.union(j1,j2)\nprint(ans)", "class Union():\n    def __init__(self, n):\n        self.para = [-1] * n\n    \n    def find(self, n):\n        if self.para[n] < 0:\n            return n\n        \n        else:\n            self.para[n] = self.find(self.para[n])\n            return self.para[n]\n    \n    def union(self, n, m):\n        n = self.find(n)\n        m = self.find(m)\n        if n == m:\n            return False\n        else:\n            if self.para[n] > self.para[m]:\n                n, m = m, n\n            \n            self.para[n] += self.para[m]\n            self.para[m] = n\n    \n    def same(self, n, m):\n        return self.find(n) == self.find(m)\n\nN = int(input()) \nX, Y = [], [] \nfor i in range(N): \n    x,y = map(int,input().split()) \n    X.append((x,i)) \n    Y.append((y,i))\nX.sort()\nY.sort()\nALL = []\nfor i in range(len(X)-1):\n    ALL.append((X[i+1][0]-X[i][0], X[i][1], X[i+1][1]))\n    ALL.append((Y[i+1][0]-Y[i][0], Y[i][1], Y[i+1][1]))\nALL.sort()\nut = Union(N)\ncnt = 0\nfor a in ALL:\n    n = a[1]\n    m = a[2]\n    if not ut.same(n,m):\n        ut.union(n,m)\n        cnt += a[0]\nprint(cnt)", "import sys\nsys.setrecursionlimit(10**7)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn = int(input())\nxy = [list(map(int, input().split()))+[i] for i in range(n)]\nG = []\n\nxy.sort()\nfor j in range(1, n):\n    sx, sy, si = xy[j-1]\n    tx, ty, ti = xy[j]\n    G.append((min(abs(sx-tx), abs(sy-ty)), si, ti))\n\nxy.sort(key=lambda x: x[1])\nfor j in range(1, n):\n    sx, sy, si = xy[j-1]\n    tx, ty, ti = xy[j]\n    G.append((min(abs(sx-tx), abs(sy-ty)), si, ti))\n\nuf = UnionFind(n)\nans = 0\nG.sort()\nfor c, x, y in G:\n    if uf.same(x, y):\n        continue\n    uf.union(x, y)\n    ans += c\nprint(ans)\n", "from operator import itemgetter\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        \n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    def same(self, x, y):\n        if self.find(x) == self.find(y):\n            return True\n        else:\n            return False\n\n\ndef kruskal(n, edges):\n    uf = UnionFind(n)\n    edges.sort()\n    res = 0\n    for d, s, t in edges:\n        if not uf.same(s, t):\n            uf.unite(s, t)\n            res += d\n    return res\n\nn = int(input())\n\nxy = [[i] + list(map(int, input().split())) for i in range(n)] \n\nedges = set()\nfor key in [itemgetter(1), itemgetter(2)]:\n    xy.sort(key = key)\n    for i in range(n-1):\n        i1, x1, y1 = xy[i]\n        i2, x2, y2 = xy[i+1]\n        d = min(abs(x1 - x2), abs(y1 - y2))\n        edges.add((d, i1, i2))\n\nedges = list(edges)\nprint((kruskal(n, edges)))\n", "N = int(input())\nXYI = [tuple(map(int,input().split() + [i])) for i in range(N)]\nsx = sorted(XYI, key=lambda x:x[0])\nsy = sorted(XYI, key=lambda x:x[1])\n\nes = []\nfor (x0,_,i0),(x1,_,i1) in zip(sx,sx[1:]):\n  es.append((x1-x0, i0, i1))\nfor (_,y0,i0),(_,y1,i1) in zip(sy,sy[1:]):\n  es.append((y1-y0, i0, i1))\nes.sort(key=lambda x:x[0])\n \nclass UnionFind:\n  def __init__(self,N):\n    self.parent = [i for i in range(N)]\n    self._size = [1] * N\n    self.count = 0\n  def root(self,a):\n    if self.parent[a] == a:\n      return a\n    else:\n      self.parent[a] = self.root(self.parent[a])\n      return self.parent[a]\n  def is_same(self,a,b):\n    return self.root(a) == self.root(b)\n  def unite(self,a,b):\n    ra = self.root(a)\n    rb = self.root(b)\n    if ra == rb: return\n    if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n    self._size[ra] += self._size[rb]\n    self.parent[rb] = ra\n    self.count += 1\n  def size(self,a):\n    return self._size[self.root(a)]\n\nuf = UnionFind(N)\nans = 0\nfor d,a,b in es:\n  if uf.is_same(a,b): continue\n  uf.unite(a,b)\n  ans += d\nprint(ans)", "N=int(input())\nA=[]\nfor i in range(N):\n  x,y=map(int,input().split())\n  A.append((x,y,i))\nA=sorted(A)\nB=sorted(A,reverse=False, key=lambda x: x[1]) \n#print(A,B)\nE=[[]for i in range(N)]\nfor i in range(N-1):\n  x1,x2=A[i][2],A[i+1][2]\n  y1,y2=B[i][2],B[i+1][2]\n  E[x1].append((x2,A[i+1][0]-A[i][0]))\n  E[x2].append((x1,A[i+1][0]-A[i][0]))\n  E[y1].append((y2,B[i+1][1]-B[i][1]))\n  E[y2].append((y1,B[i+1][1]-B[i][1]))\nG=E\n# G[v] = [w, ...]\n#     \u30b0\u30e9\u30d5G\u4e0a\u3067\u9802\u70b9v\u304c\u96a3\u63a5\u3059\u308b\u8fba\u96c6\u5408\n\nfrom heapq import heappush, heappop, heapify\nused = [0]*N\nque = [(c, w) for w, c in G[0]]\nused[0] = 1\nheapify(que)\n\nans=0\nwhile que:\n    cv,v=heappop(que)\n    if used[v]:\n        continue\n    used[v]=1\n    ans+=cv\n    for w,c in G[v]:\n        if used[w]:\n            continue\n        heappush(que,(c,w))\nprint(ans)", "import heapq\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn = int(input())\nxy = [list(map(int, input().split()))+[i] for i in range(n)]\n\"\"\"\n\u8fba\u3092\u7d50\u3073\u305f\u3044\u304c\u3059\u3079\u3066\u306e\u70b9\u3067\u7d50\u3076\u3068\u81a8\u5927\u306b\u306a\u308b\n\"\"\"\n\nedge = []\nxy.sort()\nfor i, j in zip(list(range(n-1)), list(range(1, n))):\n    cost = xy[j][0] - xy[i][0]\n    heapq.heappush(edge, [cost, xy[i][2], xy[j][2]])\n\nxy.sort(key= lambda x: x[1])\nfor i, j in zip(list(range(n-1)), list(range(1, n))):\n    cost = xy[j][1] - xy[i][1]\n    heapq.heappush(edge, [cost, xy[i][2], xy[j][2]])\n\nuf = UnionFind(n)\nans = 0\nwhile edge:\n    c, a, b = heapq.heappop(edge)\n    if uf.same(a, b): continue\n    uf.union(a, b)\n    ans += c\n\nprint(ans)\n", "from copy import deepcopy as copy\nfrom operator import itemgetter\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*(n+1)#\u305d\u308c\u305e\u308c\u306e\u8981\u7d20\u304c\u3069\u306e\u8981\u7d20\u306e\u5b50\u3067\u3042\u308b\u304b\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]#\u305d\u308c\u305e\u308c\u306e\u8981\u7d20\u306e\u6839\u3092\u518d\u5e30\u7684\u306b\u6c42\u3081\u308b\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)#x,y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n    \n    def size(self, x):\n        return -self.par[self.find(x)]\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if root == self.find(i)]        \n\ndef main():\n    n = int(input())\n    bridge = [None]*n\n    for i in range(n):\n        bridge[i] = [int(x) for x in input().split()]+[i]\n\n    judge = []\n\n    bridge.sort()\n    for i in range(n-1):\n        judge.append((bridge[i+1][0]-bridge[i][0], bridge[i][2], bridge[i+1][2]))\n\n    bridge.sort(key=itemgetter(1))\n    for i in range(n-1):\n        judge.append((bridge[i+1][1]-bridge[i][1], bridge[i][2], bridge[i+1][2]))\n    \n    judge.sort()\n    union = UnionFind(n)\n    count = 0\n    cost = 0\n    for k in range(2*n):\n        c, i, j = judge[k]\n        if union.same(i, j):\n            continue\n        union.union(i, j)\n        cost += c\n        count += 1\n        if count == n-1:\n            break\n    \n    print(cost)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport heapq\ninput = sys.stdin.readline\n\n\nn = int(input())\nXs = []\nYs = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    Xs.append((x-1, i))\n    Ys.append((y-1, i))\n\nXs.sort()\nYs.sort()\n\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, node = Xs[i]\n    nx, new_node = Xs[i+1]\n    edges[node].append((nx-x, new_node))\n    edges[new_node].append((nx-x, node))\n\nfor i in range(n-1):\n    y, node = Ys[i]\n    ny, new_node = Ys[i+1]\n    edges[node].append((ny-y, new_node))\n    edges[new_node].append((ny-y, node))\n\nseen = [False] * n\ndist = [float('INF')] * n\ntodo = [(0, 0)]\n\nwhile todo:\n    d, node = heapq.heappop(todo)\n    if seen[node]:\n        continue\n    seen[node] = True\n    dist[node] = d\n\n    for edge in edges[node]:\n        nd, to = edge\n        if dist[to] <= nd:\n            continue\n        heapq.heappush(todo, (nd, to))\n\nprint(sum(dist))", "from heapq import heappush, heappop\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.parents[y] = x\n\nN = int(input())\nq = []\nans = 0\nS = UnionFind(N)\nx = []\ny = []\n\nfor i in range(N):\n    p,r = map(int, input().split())\n    x.append([p,i])\n    y.append([r,i])\n\nx.sort()\ny.sort()\nfor i in range(N-1):\n    x1, i1 = x[i]\n    y1, j1 = y[i]\n    x2, i2 = x[i+1]\n    y2, j2 = y[i+1]\n    heappush(q, (abs(x1-x2), i1, i2))\n    heappush(q, (abs(y1-y2), j1, j2))\n\nheappush(q, (abs(x[N-1][0]-x[0][0]), x[N-1][1], x[0][1]))\nheappush(q, (abs(y[N-1][0]-y[0][0]), y[N-1][1], y[0][1]))\n# \u30af\u30e9\u30b9\u30ab\u30eb\u6cd5\nwhile len(q) > 0:\n    d, a, b = heappop(q)\n    if S.find(a) != S.find(b):\n        ans += d\n        S.union(a, b)\nprint(ans)", "import sys\nsys.setrecursionlimit(2147483647)\ninput=sys.stdin.readline\nimport math\nfrom heapq import heappush, heappop, heapify\n\ndef solve(n, nodes):\n  xsort_nodes = sorted(nodes, key=lambda n: n[1])\n  ysort_nodes = sorted(nodes, key=lambda n: n[2])\n  edges = [[] for _ in range(n)]\n  for i in range(n-1):\n    prev_node = xsort_nodes[i]\n    post_node = xsort_nodes[i+1]\n    edges[prev_node[0]].append((abs(prev_node[1]-post_node[1]), post_node[0]))\n  for i in range(n-1):\n    prev_node = ysort_nodes[i]\n    post_node = ysort_nodes[i+1]\n    edges[prev_node[0]].append((abs(prev_node[2]-post_node[2]), post_node[0]))\n  for i in range(1, n):\n    prev_node = xsort_nodes[i-1]\n    post_node = xsort_nodes[i]\n    edges[post_node[0]].append((abs(prev_node[1]-post_node[1]), prev_node[0]))\n  for i in range(1, n):\n    prev_node = ysort_nodes[i-1]\n    post_node = ysort_nodes[i]\n    edges[post_node[0]].append((abs(prev_node[2]-post_node[2]), prev_node[0]))\n  tree = [0]*n\n  tree[0] = 1\n  distance = 0\n  current_edges = [*edges[0]]\n  heapify(current_edges)\n  while(len(current_edges)):\n    d, x = heappop(current_edges)\n    if tree[x]:\n      continue\n    distance += d\n    tree[x] = 1\n    for edge in edges[x]:\n      heappush(current_edges, edge)\n  return distance  \n\ndef main():\n  n = int(input())\n  nodes = []\n  for i in range(n):\n    x, y = map(int, input().split(' '))\n    nodes.append((i, x, y))\n  ans = solve(n, nodes)\n  print(ans)\n  \n\ndef __starting_point():\n  main()\n__starting_point()", "\nimport numpy as np\nfrom scipy.sparse.csgraph import minimum_spanning_tree\nfrom scipy.sparse import csr_matrix\nfrom operator import itemgetter\ndef resolve():\n    N = int(input())\n    XY = [[i] + [int(x) for x in input().split()] for i in range(N)]\n\n    G = set()\n    for key in [itemgetter(1), itemgetter(2)]:\n        XY.sort(key=key)\n        for i in range(N - 1):\n            i1, x1, y1 = XY[i]\n            i2, x2, y2 = XY[i + 1]\n            d = min(abs(x1 - x2), abs(y1 - y2))\n            G.add((i1, i2, d))    \n\n    A, B, W = zip(*G)\n    csr = csr_matrix((W, (A, B)), shape=(N, N))\n    mst = minimum_spanning_tree(csr).astype(int)\n    print(mst.sum())\n\ndef __starting_point():\n    resolve()\n__starting_point()", "n = int(input())\nplots = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    plots.append((x, y, i))\nedges = []\nplots.sort(key=lambda x: x[0])\nfor k in range(n-1):\n    x0, _, i = plots[k]\n    x1, _, j = plots[k+1]\n    edges.append((x1 - x0, i, j))\n\nplots.sort(key=lambda x: x[1])\nfor k in range(n-1):\n    _, y0, i = plots[k]\n    _, y1, j = plots[k+1]\n    edges.append((y1 - y0, i, j))\n\n\n\npar = [i for i in range(n)]\nsize = [1 for _ in range(n)]\nrank = [0 for _ in range(n)]\ndef find(x):  # \u6728\u306e\u6839\u3092\u6c42\u3081\u308b\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if rank[x] > rank[y]:\n        par[y] = x\n        size[x] += size[y]\n    else:\n        par[x] = y\n        size[y] += size[x]\n        if rank[x] == rank[y]:\n            rank[y] += 1\ndef same(x, y):\n    return find(x) == find(y)\n\n\ndef kruskal():\n    edges.sort()\n\n    res = 0\n    for i in range(len(edges)):\n        cost, u, v = edges[i]\n        if not same(u, v):\n            unite(u, v)\n            res += cost\n\n    return res\n\nprint(kruskal())", "from sys import stdin, setrecursionlimit\nfrom operator import itemgetter\n\nsetrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef input():\n    return stdin.readline().strip()\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nN = int(input())\nP = [0] * N\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    P[i] = (i, x, y)\n\nedges = []\nfor i in (1, 2):\n    P.sort(key=itemgetter(i))\n    for j in range(N - 1):\n        edges.append((P[j][0], P[j + 1][0], P[j + 1][i] - P[j][i]))\n\nedges.sort(key=itemgetter(2))\nuf = UnionFind(N)\nans = 0\ncities = 1\nfor i, j, c in edges:\n    if not uf.same(i, j):\n        uf.union(i, j)\n        ans += c\n        cities += 1\n        if cities == N:\n            break\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nclass UnionFind(object):\n    def __init__(self, size):\n        self.parent = [i for i in range(size)]\n        self.rank = [0]*size\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        # path compression\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        # union by rank\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef __starting_point():\n    N = int(input())\n    vs = []\n    for i in range(N):\n        x,y = map(int,input().split())\n        vs.append((x,y,i))\n    vs.sort()\n    edges = []\n    for k in range(1, N):\n        x,y,i = vs[k]\n        a,b,j = vs[k-1]\n        edges.append((i, j, min(abs(x-a),abs(y-b))))\n    vs.sort(key=lambda x:x[1])\n    for k in range(1, N):\n        x,y,i = vs[k]\n        a,b,j = vs[k-1]\n        edges.append((i, j, min(abs(x-a),abs(y-b))))\n    uf = UnionFind(N)\n    edges.sort(key=lambda x:x[2])\n    ans = 0\n    for i,j,w in edges:\n        if not uf.same(i,j):\n            uf.unite(i,j)\n            ans += w\n    print(ans)\n__starting_point()", "N=int(input())\nA=[]\nfor i in range(N):\n  x,y=map(int,input().split())\n  A.append((x,y,i))\nA=sorted(A)\nB=sorted(A,reverse=False, key=lambda x: x[1]) \n#print(A,B)\nE=[]\nfor i in range(N-1):\n  E.append(((A[i+1][0]-A[i][0]),A[i][2],A[i+1][2]))\n  E.append(((B[i+1][1]-B[i][1]),B[i][2],B[i+1][2]))\nedge=E\n\ndef kruskal():\n    cost=0\n    edge.sort()\n    for c,u,v in edge:\n        if same(u,v):\n            continue\n        union(u,v)\n        cost+=c\n    return cost\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    if par[x] > par[y]:\n        x, y = y, x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef same(x, y):\n    return find(x) == find(y)\npar=[-1]*N\nprint(kruskal())", "n,*xy=map(int,open(0).read().split())\nx=[[xx,i] for i,xx in enumerate(xy[::2])]\ny=[[yy,i] for i,yy in enumerate(xy[1::2])]\nx.sort()\ny.sort()\npx=[[x1-x0,i0,i1] for (x0,i0),(x1,i1) in zip(x,x[1:])]\npy=[[y1-y0,i0,i1] for (y0,i0),(y1,i1) in zip(y,y[1:])]\np=px+py\nx=[]\ny=[]\npx=[]\npy=[]\np.sort()\nr=[i for i in range(n)]\nrank=[1 for i in range(n)]\ndef root(x):\n  if x==r[x]:\n    return x\n  else:\n    r[x]=root(r[x])\n    return r[x]\ndef union(path):\n  rx=root(path[1])\n  ry=root(path[2])\n  if rx==ry:\n    return 0\n  else:\n    if rank[rx]>rank[ry]:\n      r[rx]=ry\n      rank[rx]+=rank[ry]\n    else:\n      r[ry]=rx\n      rank[ry]+=rank[rx]\n    return path[0]\nans=0\nfor i in range(len(p)):\n  ans+=union(p[i])\nprint(ans)", "class DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0]*size\n    \n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        \n        if self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif xr != yr:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\nfrom itertools import chain\n\nN = int(input())\npoints = tuple(tuple(map(int,input().split())) for _ in range(N))\nds = DisjointSet(N)\n\nx_i = sorted((x,i) for i,(x,y) in enumerate(points))\ny_i = sorted((y,i) for i,(x,y) in enumerate(points))\n\nxr = [x_i[0]]\nyr = [y_i[0]]\n\nfor (x0,i0),(x1,i1) in zip(x_i,x_i[1:]):\n    if x0 == x1:\n        ds.union(i0,i1)\n    else:\n        xr.append((x1,i1))\n\nfor (y0,i0),(y1,i1) in zip(y_i,y_i[1:]):\n    if y0 == y1:\n        ds.union(i0,i1)\n    else:\n        yr.append((y1,i1))\n\ndeltas = sorted(\n        chain(\n            ((x1-x0,i0,i1) for (x0,i0), (x1,i1) in zip(xr,xr[1:])),\n            ((y1-y0,i0,i1) for (y0,i0), (y1,i1) in zip(yr,yr[1:])),\n        )\n    )\n\n\ndef it():\n    for d,i0,i1 in deltas:\n        if ds.find(i0) != ds.find(i1):\n            ds.union(i0,i1)\n            yield d\nprint(sum(it()))", "n=int(input())\nl=sorted([list(map(int,input().split()))+[i] for i in range(n)])\nxs=[(x,i)for x,y,i in l]\nys=sorted([(x,i)for y,x,i in l])\nedges={}\nfor i in range(1,n):\n    a,s=xs[i-1];d,f=xs[i]\n    if (s,f)in edges:\n        edges[(s,f)]=min(edges[(s,f)],abs(a-d))\n    else:edges[(s,f)]=abs(a-d)\n    a,s=ys[i-1];d,f=ys[i]\n    if (s,f)in edges:\n        edges[(s,f)]=min(edges[(s,f)],abs(a-d))\n    else:edges[(s,f)]=abs(a-d)\nedges=sorted(edges.items(),key=lambda x:x[1])\nclass UnionFind:\n    #def   -> foo=UnionFind(n,1)  <- 1-based index, default is 0\n    #method -> foo.hoge(huga)\n    __slots__ = [\"_size\", \"_first_idx\", \"_parents\"]\n    def __init__(self, size: int, first_index: int = 0) -> None:\n        self._size = size\n        self._first_idx = first_index\n        self._parents = [-1] * (size + first_index)\n    def find(self, x: int) -> int:\n        if self._parents[x] < 0:\n            return x\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n    def same(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n    def unite(self, x: int, y: int) -> bool:\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n        if self._parents[x] > self._parents[y]:\n            x, y = y, x\n        self._parents[x] += self._parents[y]\n        self._parents[y] = x\n        return True\n    def size(self, x: int) -> int:\n        return -self._parents[self.find(x)]\n    def group_count(self) ->int:\n        return sum(1 for i in  self._parents if i<0)-self._first_idx\n    def connected(self) ->bool:\n        return self._parents[self.find(self._first_idx)]==-self._size\nuf=UnionFind(n)\nans=edges[0][1]\nuf.unite(*edges[0][0])\nfor f,c in edges:\n    if uf.same(*f):continue\n    uf.unite(*f)\n    ans+=c\nprint(ans)"]
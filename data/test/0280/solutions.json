["import sys\ninput = sys.stdin.readline\nfrom itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef dijkstra(start, edge):\n    n = len(edge)\n    dist = [0]*n\n    que = [(0, start)]\n    while que:\n        d, v = heapq.heappop(que)\n        if dist[v] < d:\n            continue\n        for nv, nd in edge[v]:\n            if dist[nv] > d + nd:\n                dist[nv] = d + nd\n                heapq.heappush(que, (dist[nv], nv))\n    return dist\n\nn, m = map(int, input().split())\nW = tuple(map(int, input().split()))\nLV = sorted((tuple(map(int, input().split())) for _ in range(m)), key=itemgetter(1))\nL, V = zip(*LV)\nP = [0]\nw_max = max(W)\nfor l, v in LV:\n  if w_max > v:\n    print(-1)\n    return\n  if P[-1] > l:\n    P.append(P[-1])\n  else:\n    P.append(l)\ndef f(K):\n  S = list(accumulate((W[k] for k in K)))\n  edge = [[] for _ in range(n)]\n  for i in range(n-1):\n    edge[i+1].append((i, 0))\n  for i in range(n-1):\n    for j in range(i+1, n):\n      if i == 0:\n        t = S[j]\n      else:\n        t = S[j] - S[i-1]\n      p = P[bisect.bisect_left(V, t)]\n      edge[j].append((i, -p))\n  return -dijkstra(n-1, edge)[0]\n\nans = float(\"inf\")\nfor K in permutations(range(n)):\n  ans = min(ans, f(K))\nprint(ans)", "import sys\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom bisect import bisect_left\n\n\nN, M = list(map(int, input().split()))\nW = list(map(int, input().split()))\nP = [tuple(map(int, sys.stdin.readline().split())) for _ in range(M)]\nif max(W) > min(P, key=itemgetter(1))[1]:\n    print((-1))\n    return\n\nP.sort(key=itemgetter(1), reverse=True)\nP.sort(key=itemgetter(0))\n\nINF = float('inf')\nminV = [INF] * M\nfor i in range(M - 1, 0, -1):\n    minV[i - 1] = min(minV[i], P[i][1])\n\nbridge_l = [0]\nbridge_v = [0]\nfor i, (l, v) in enumerate(P):\n    if v < minV[i]:\n        bridge_l.append(l)\n        bridge_v.append(v)\n\nans = INF\nfor C in permutations(list(range(N))):\n    H = [0] * (N + 1)\n    for i in range(N):\n        H[i] = H[i - 1] + W[C[i]]\n    pos = [0] * N\n    for i in range(1, N):\n        for j in range(i, -1, -1):\n            w = H[i] - H[j - 1]\n            idx = bisect_left(bridge_v, w)\n            pos[i] = max(pos[i], bridge_l[idx - 1] + pos[j])\n    ans = min(ans, pos[N - 1])\n\nprint(ans)\n", "import sys,itertools,bisect\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nW = [ int(w) for w in input().split()]\nmaxW = max(W)\nlv=[list(map(int,input().split())) for _ in range(M)]\n#\u6a4b\u306e\u9078\u5225\u3000\u30cd\u30c3\u30af\u3068\u306a\u308b\u6a4b\u306e\u62bd\u51fa\u3000lj<=li,vj>=vi \u3068\u306a\u308b\u6a4bj\u306fi\u306b\u7d71\u5408\u53ef\u80fd\nlv.sort(key=lambda x:(x[1],-x[0]))\nLV=[lv[0]]\nfor l,v in lv:\n    if maxW>v:\n        print((-1))\n        return\n    if LV[-1][0]<l:\n        LV.append([l,v])\nLV.sort(key=lambda x:x[1])\nV = [ v for _,v in LV]\nL = [ l for l,_ in LV]\n#\u3089\u304f\u3060\u306e\u9806\u756a\u3067\u30eb\u30fc\u30d7\nans = float('inf')\n\nfor perm in itertools.permutations(list(range(N)),N):\n    dist = [0]*(N+1)#i\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u5fc5\u8981\u8ddd\u96e2 \u3068\u3044\u3046\u304b\u3000\u5ea7\u6a19\n\n    for i in range(1,N):#i\u306f\u7d42\u308f\u308a\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3000i\u542b\u3080\n        ww = W[perm[i]]\n        for j in range(1,i+1):#j\u306f\u9593\u9694\u30021\u3064\u307e\u3048~\u5148\u982d\u307e\u3067\u307f\u3066\u3044\u304f\u306e\u30671~i\u307e\u3067\n            ww +=W[perm[i-j]]#i\u756a\u76ee\u306e\u30e9\u30af\u30c0\u3088\u308aj\u500b\u524d\u307e\u3067\u306b\u3044\u308b\u30e9\u30af\u30c0\u306e\u91cd\u3055\n            idx = bisect.bisect_left(V,ww)-1#\u6e21\u308c\u306a\u3044\u6a4b\n            if idx == -1:\n                length = 0\n            else:\n                length = L[idx]\n            dist[i+1]=max(dist[i+1],dist[i-j+1]+length)\n    ans = min(ans,dist[-1])\n\nprint(ans)\n", "import bisect\nfrom itertools import permutations\n\nN,M = map(int,input().split())\nw = list(map(int,input().split()))\n\nbridge = []\nfor i in range(M):\n    l,W = map(int,input().split())\n    bridge.append((W,l))\nbridge.sort()\n\nif min(bridge[i][0] for i in range(M))<max(w):\n    print(-1);return()\n\nMax = [bridge[i][1] for i in range(M)]\nfor i in range(1,M):\n    Max[i] = max(Max[i],Max[i-1])\n\ndata = [0 for i in range(2**N)]\n\nfor i in range(2**N):\n    tmp = 0\n    for j in range(N):\n        if i>>j & 1:\n            tmp += w[j]\n\n    idx = bisect.bisect_left(bridge,(tmp,-1))\n    if idx==0:\n        data[i] = 0\n    else:\n        data[i] = Max[idx-1]\n\nper = list(permutations([i for i in range(N)]))\nres = 10**18\nfor L in per:\n    dp = [0 for i in range(N)]\n    for i in range(N-2,-1,-1):\n        tmp = 1<<L[i]\n        for j in range(i+1,N):\n            tmp += 1<<L[j]\n            dp[i] = max(dp[i],dp[j]+data[tmp])\n    res = min(res,dp[0])\n\nprint(res)\n", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nimport bisect\n\nN,M=list(map(int,input().split()))\nW=list(map(int,input().split()))\nB=[tuple(map(int,input().split())) for i in range(M)]\n\nMIN=1<<60\nfor l,v in B:\n    MIN=min(MIN,v)\n\nif MIN<max(W):\n    print((-1))\n    return\n\nB2=[]\nfor x,y in B:\n    B2.append([y,x])\nB2.sort(key=itemgetter(0))\n\nB3=[B2[0]]\nfor x,y in B2[1:]:\n    if y<=B3[-1][1]:\n        continue\n    else:\n        B3.append([x,y])\n\nB3=[[0,0]]+B3\nB3.append([1<<60,B3[-1][1]])\n\nfrom itertools import permutations\n\nL=list(permutations(list(range(N))))\nANS=1<<60\n\nfor l in L:\n    W2=[W[l[i]] for i in range(N)]\n    DP=[0]*(N+1)\n\n    for i in range(N):\n        S=W2[i]\n        for j in range(i+1,N):\n            S+=W2[j]\n            x=bisect.bisect(B3,[S,0])\n\n            DP[j]=max(DP[j],DP[i]+B3[x-1][1])\n       \n    ANS=min(ANS,DP[N-1])\nprint(ANS)\n            \n    \n", "import bisect, collections, copy, heapq, itertools, math, string\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int, sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nfrom collections import deque, defaultdict, Counter\nimport heapq\nfrom functools import reduce\nfrom itertools import permutations\nimport math\nimport bisect\n\ndef bellman_ford(s, n, g):\n    d = [float('inf')]*n # \u5404\u9802\u70b9\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\n    d[s] = 0 # \u81ea\u8eab\u3078\u306e\u8ddd\u96e2\u306f0\n    for i in range(n):\n        update = False # \u66f4\u65b0\u304c\u884c\u308f\u308c\u305f\u304b\n        for x, y, z in g:\n            if d[y] > d[x] + z:\n                d[y] = d[x] + z\n                update = True\n        if not update:\n            break\n        # \u8ca0\u9589\u8def\u304c\u5b58\u5728\n        if i == n - 1:\n            return -1\n    return d\n\ndef main():\n    N, M = MI()\n    W = LI()\n    V_list = []\n    V_list_ = []\n    Parts = defaultdict()\n    for i in range(M):\n        l, v = MI()\n        Parts[i] = (l, v)\n        V_list.append((v, i))\n        V_list_.append(v)\n    V_list.sort(key=lambda tup: tup[0])\n    V_list_.sort()\n    #print(V_list)\n    #print(V_list_)\n    max_len_list = [0]\n    maxlen = 0\n    for i in range(M):\n        if Parts[V_list[i][1]][0] > maxlen:\n            maxlen = Parts[V_list[i][1]][0]\n        max_len_list.append(maxlen)\n    #print(max_len_list)\n    bit_list = []\n    for i in range(1, 2 ** N):\n        A_bit = \"{:0>{}b}\".format(i, N)\n        bit_list.append(A_bit)\n    #print(bit_list)\n    camel_len_dict = defaultdict()\n    for bits in bit_list:\n        cnt = 0\n        weight = 0\n        for i, bit in enumerate(bits):\n            if bit == '1':\n                cnt += 1\n                weight += W[i]\n        #print(camels)\n        a = bisect.bisect_left(V_list_, weight)\n        if cnt == 1 and a != 0:\n            print(-1)\n            return\n        camel_len_dict[weight] = max_len_list[a]\n    #print(camel_len_dict)\n    camel_number = []\n    for i in range(N):\n        camel_number.append(i)\n    P = itertools.permutations(camel_number)\n    ans_list = []\n    bit_list_ = []\n    for i in range(2 ** (N - 1)):\n        B_bit = \"{:0>{}b}\".format(i, N - 1)\n        bit_list_.append(B_bit)\n\n    for p in P:\n        #print(p, 'p')\n        weight_p_list = []\n        weight_p = 0\n        for p_ in p:\n            weight_p += W[p_]\n            weight_p_list.append(weight_p)\n        #print(weight_p_list)\n        C = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                if i != 0:\n                    C.append([i, j, -(camel_len_dict[weight_p_list[j] - weight_p_list[i - 1]])])\n                else:\n                    C.append([i, j, -(camel_len_dict[weight_p_list[j]])])\n        #print(C, 'C')\n        ans_list.append(bellman_ford(0, N, C)[-1])\n    #print(ans_list)\n    print(-(max(ans_list)))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport itertools\nimport bisect\nn, m = map(int, input().split())\nw = list(map(int, input().split()))\nlv = [map(int, input().split()) for _ in range(m)]\nl, v = [list(i) for i in zip(*lv)]\n#lv = [list(map(int, input().split())) for _ in range(m)]\n\nif min(w) > min(v):\n    print(\"-1\")\n    return\n\nl = [i for _, i in sorted(zip(v, l))]\nv.sort()\n\nlen_rm = list(itertools.accumulate(l, max))\n\nans = float(\"inf\")\nfor W in itertools.permutations(w):\n  length = [0] * n\n  for i in range(n):\n    w_ij = W[i]\n    for j in range(i + 1, n):\n      w_ij += W[j]\n      idx = bisect.bisect_left(v, w_ij)\n      if idx == 0:\n        x_ij = 0\n      else:\n        x_ij = len_rm[idx-1]\n      length[j] = max(length[j], length[i] + x_ij)\n      if idx == m:\n        break\n  ans = min(ans, length[-1])\nprint(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,m = list(map(int, input().split()))\nw = list(map(int, input().split()))\nlv = []\nlm = -1\nfor i in range(m):\n    lv.append(tuple(map(int, input().split())))\n    lm = max(lm, lv[-1][0])\nfrom operator import itemgetter\nlv.sort(key=itemgetter(1))\nnlv = [(0,0), lv[0]]\nfor l,v in lv:\n    if l<=nlv[-1][0]:\n        continue\n    nlv.append((l,v))\nvs = [nlv[i][1] for i in range(len(nlv))]\nfrom bisect import bisect_left as bl, bisect_right as br\ndef sub(x):\n    ind = bl(vs, x-0.5)\n    if ind==0:\n        return 0\n    return nlv[ind-1][0]\ndef cumsum(a):\n    \"\"\"\u203b a\u3092\u7834\u58ca\u3059\u308b\n    l[i] = sum(a[:i]) \u306a\u308bl\u3092\u8fd4\u3059\n    sum(a[i:j]) == l[j+1] - l[i]\n    \"\"\"\n    c = 0\n    n = len(a)\n    a.insert(0, 0)\n    for i in range(1, n+1):\n        a[i] = a[i-1]+a[i]\n    return a\nif nlv[-1][1]<max(w):\n    ans = -1\nelse:\n    from itertools import permutations\n    l = list(range(n))\n    ans = float(\"inf\")\n    for ps in permutations(l):\n        cum = cumsum([w[ps[i]] for i in range(n)])\n        if sub(cum[1])==float(\"inf\"):\n            continue\n        ls = [0]\n        for i in range(1,n):\n    #         val = ls[i-1]+lm\n            val = max(ls[ii] + sub(cum[i+1]-cum[ii]) for ii in range(i))\n            ls.append(val)\n        ans = min(ans, ls[-1])\n    if ans>10**20:\n        ans = -1\nprint(ans)", "import itertools\nimport bisect\nN,M=map(int,input().split())\nW=list(map(int,input().split()))\nV=[]\nfor i in range(M):\n  l,v=map(int,input().split())\n  V.append((l,v))\n\nV.sort(key=lambda x:x[1])\nV2=[V[i][1] for i in range(M)]\nV3=[V[i][0] for i in range(M)]\nV4=[]\nx=0\nfor i in range(M):\n  x=max(x,V3[i])\n  V4.append(x)\nb=V4[M-1]\n\nif max(W)>min(V2):\n  print(-1)\n  return\n\nans=10**20\nfor k in list(itertools.permutations(range(N))):\n  x=[W[k[i]] for i in range(N)]\n  A=[[0]*N for _ in range(N)]\n  for m in list(itertools.combinations(range(N), 2)):\n    s=min(m[0],m[1])\n    e=max(m[0],m[1])\n    a=bisect.bisect_left(V2,sum(x[s:e+1]))\n    if a==0:\n      A[s][e]=0\n    elif a==M:\n      A[s][e]=b\n    else:\n      A[s][e]=V4[a-1]\n  dp=[0]*N\n  for i in range(1,N):\n    for j in range(i):\n      dp[i]=max(dp[i],dp[j]+A[j][i])\n  if ans>dp[N-1]:\n    ans=dp[N-1]\nprint(ans)", "from itertools import permutations\n\nN, M, *I = map(int, open(0).read().split())\nW, LV = I[:N], list(zip(*[iter(I[N:])] * 2))\n\nif any(w > v for _, v in LV for w in W):\n    print(-1)\n    return\n\nL = [0] * (1 << N)\nfor i in range(1 << N):\n    s = sum(w for j, w in enumerate(W) if i >> j & 1)\n    L[i] = max((l for l, v in LV if s > v), default=0)\n\nans = float(\"inf\")\nfor P in permutations(range(N)):\n    dp = [0] * N\n    for i, p in enumerate(P[1:], 1):\n        t = 1 << p\n        for j in reversed(range(i)):\n            t |= 1 << P[j]\n            dp[i] = max(dp[i], dp[j] + L[t])\n    ans = min(ans, dp[-1])\n\nprint(ans)", "# \u6539\u884c\u3067\u30d0\u30b0\u308b\u6642\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nimport itertools\nimport bisect\n\nn,m= list(map(int, input().split()))\nw= list(map(int, input().split()))\ng= [list(map(int, input().split())) for i in range(m)]\ng.sort(key=lambda x:x[1])\nL=[0]\nV=[]\nx=0\nfor i in range(m):\n    if g[i][0]>x:\n        L.append(g[i][0])\n        V.append(g[i][1])\n        x=g[i][0]\n\n\n\n# \u3069\u3046\u9811\u5f35\u3063\u3066\u3082\u58ca\u308c\u308b\u6642\u3092\u9664\u5916\nw.sort()\nif w[-1]>g[0][1]:\n    print((-1))\n    return\n\n\nANS=float('inf')\n# \u9806\u5e8f\u3092\u5168\u63a2\u7d22\nfor v in itertools.permutations(w):\n    dp = [0] * n\n    dp[0]=0\n    for i in range(1,n):\n        cnt=v[i]\n        for j in range(i-1,-1,-1):\n            cnt+=v[j]\n            vv=bisect.bisect_left(V,cnt)\n            dp[i]=max(dp[i],dp[j]+L[vv])\n    ANS=min(ANS,dp[-1])\nprint(ANS)\n", "#!/usr/bin/env python3\nfrom bisect import bisect_left\nfrom itertools import permutations\n\nINF = 10**12\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n    LV = [[0, 0]]\n    for _ in range(M):\n        l, v = list(map(int, input().split()))\n        LV.append([v, l])\n    LV.sort()\n    V = [0]\n    LV2 = [[0, 0]]\n    now = 0\n    for a in LV:\n        if a[1] > now:\n            now = a[1]\n            LV2.append(a)\n            V.append(a[0])\n    if V[1] < max(w):\n        print((-1))\n        return\n    ans = INF\n    # N!\u901a\u308a\u3092\u5168\u63a2\u7d22\u3059\u308b\n    for p in permutations(list(range(N))):\n        dp = [0] * N\n        dp[0] = 0\n        for i in range(1, N):\n            wsum = w[p[i]]\n            for j in range(i-1, -1, -1):\n                wsum += w[p[j]]\n                d = bisect_left(V, wsum)\n                dp[i] = max(dp[i], dp[j]+LV2[d-1][1])\n        ans = min(ans, dp[N - 1])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_left\nfrom collections import namedtuple\nfrom itertools import permutations\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\nW = [int(x) for x in input().split()]\nP = [tuple(map(int, input().split())) for _ in range(M)]\nP.sort(key=lambda part: part[1])\n\nls = [p[0] for p in P]\nvs = [p[1] for p in P]\nfor i in range(1, M):\n    ls[i] = max(ls[i - 1], ls[i])\n\nif max(W) > min(vs):\n    print((-1))\n    return\n\nans = 10 ** 20\nfor ws in permutations(sorted(W)):\n    pref = [ws[0]]\n    for i in range(1, N):\n        pref.append(pref[i - 1] + ws[i])\n\n    dp = [0] * N\n    for i in range(N):\n        for j in range(i):\n            interval = pref[i] - (pref[j - 1] if j >= 1 else 0)\n            idx = bisect_left(vs, interval)\n            need = ls[idx - 1] if idx >= 1 else 0\n            dp[i] = max(dp[i], dp[j] + need)\n\n    ans = min(ans, dp[-1])\n\nprint(ans)\n", "import sys,itertools,bisect\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nW = [ int(w) for w in input().split()]\nmaxW = max(W)\nlv=[list(map(int,input().split())) for _ in range(M)]\n#\u6a4b\u306e\u9078\u5225\u3000\u30cd\u30c3\u30af\u3068\u306a\u308b\u6a4b\u306e\u62bd\u51fa\u3000lj<=li,vj>=vi \u3068\u306a\u308b\u6a4bj\u306fi\u306b\u7d71\u5408\u53ef\u80fd\nlv.sort(key=lambda x:(x[1],-x[0]))#\u8106\u3044\u6a4b\u9806\u3002\u540c\u3058\u8106\u3055\u306a\u3089\u9577\u3044\u3082\u306e\u9806\nLV=[lv[0]]#\u3082\u3063\u3068\u3082\u8106\u304f\u3001\u9577\u3044\u3082\u306e\u306f\u5fc5\u305a\u30cd\u30c3\u30af\u306b\u306a\u308b\nfor l,v in lv:\n    if maxW>v:\n        print((-1))\n        return\n    if LV[-1][0]<l:#\u5f37\u5ea6\u304c\u3042\u3063\u3066\u3082\u9577\u3051\u308c\u3070\u30cd\u30c3\u30af\u306b\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\n        LV.append([l,v])\nV = [ v for _,v in LV]\nL = [ l for l,_ in LV]\n#\u3089\u304f\u3060\u306e\u9806\u756a\u3067\u30eb\u30fc\u30d7\nans = float('inf')\n\nfor perm in itertools.permutations(list(range(N)),N):\n    dist = [0]*(N+1)#i\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u5fc5\u8981\u8ddd\u96e2 \u3068\u3044\u3046\u304b\u3000\u5ea7\u6a19\n\n    for i in range(1,N):#i\u306f\u7d42\u308f\u308a\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3000i\u542b\u3080\n        ww = W[perm[i]]\n        for j in range(1,i+1):#j\u306f\u9593\u9694\u30021\u3064\u307e\u3048~\u5148\u982d\u307e\u3067\u307f\u3066\u3044\u304f\u306e\u30671~i\u307e\u3067\n            ww +=W[perm[i-j]]#i\u756a\u76ee\u306e\u30e9\u30af\u30c0\u3088\u308aj\u500b\u524d\u307e\u3067\u306b\u3044\u308b\u30e9\u30af\u30c0\u306e\u91cd\u3055\n            idx = bisect.bisect_left(V,ww)-1#\u6e21\u308c\u306a\u3044\u6a4b\n            if idx == -1:\n                length = 0\n            else:\n                length = L[idx]\n            dist[i+1]=max(dist[i+1],dist[i-j+1]+length)\n    ans = min(ans,dist[-1])\n\nprint(ans)\n", "# from itertools import permutations\n# N, M = map(int, input().split())\n# W = list(map(int, input().split()))\n\n# L = []\n# V = []\n# for _ in range(M):\n#     l, v = map(int, input().split())\n#     L.append(l)\n#     V.append(v)\n\n# # \u3069\u306e\u3088\u3046\u306b\u3057\u3066\u3082\u7bb8\u304c\u843d\u3061\u308b\u6642\n# if min(W) > min(V):\n#     print(-1)\n#     return\n\n# ans = float('inf')\n# for v in permutations(W):\n#     dp = [0] * N\n#     for i in range(N):\n#         for j in range(i + 1, N):\n#             weight = v[i] + v[j]\n#             for m in range(M):\n#                 if weight > V[m]:\n#                     dp[j] = max(dp[j], dp[j - 1] + L[m])\n#     ans = min(ans, dp[-1])\n# print(ans)\n\nimport itertools\nimport bisect\n\nn, m = list(map(int, input().split()))\nw = list(map(int, input().split()))\ng = [list(map(int, input().split())) for _ in range(m)]\n# \u5bfe\u4fa1\u91cd\u91cf\u3067\u30bd\u30fc\u30c8\u3059\u308b\ng.sort(key=lambda x: x[1])\n\nL = []\nV = []\n# \u4e8c\u5206\u63a2\u7d22\u3092\u5229\u7528\u3059\u308b\u4e0a\u3067\u8003\u3048\u306a\u304f\u3066\u3082\u826f\u3044\u6a4b\u306e\u90e8\u5206\u3092\u9664\u5916\u3059\u308b\ninit = 0\nfor i in range(m):\n    if g[i][0] > init:\n        L.append(g[i][0])\n        V.append(g[i][1])\n        init = g[i][0]\n\nw.sort()\nif w[0] > g[0][1]:\n    print((-1))\n    return\n\nans = float('inf')\nfor v in itertools.permutations(w):\n    dp = [0] * n\n    for i in range(1, n):\n        cnt = v[i]\n        for j in range(i - 1, -1, -1):\n            cnt += v[j]\n            bisect_v = bisect.bisect_left(V, cnt)\n            if bisect_v - 1 >= len(L) or bisect_v - 1 < 0:\n                continue\n            dp[i] = max(dp[i], dp[j] + L[bisect_v - 1])\n    ans = min(ans, dp[-1])\nprint(ans)\n", "from bisect import bisect_left\nfrom itertools import permutations\n\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nlv = [list(map(int, input().split())) for i in range(M)]\n\n# \u6ce8\u76ee\u3059\u3079\u304d\u6a4b\u3060\u3051\u53d6\u308a\u51fa\u3059\nlv.sort(key=lambda x:x[1])\nl = [0]\nv = [0]\nfor li, vi in lv:\n  if vi == v[-1]:\n    l[-1] = max(l[-1], li)\n  elif li > l[-1]:\n    l.append(li)\n    v.append(vi)\n\n# \u8010\u8377\u91cd\u3092\u5358\u4f53\u3067\u8d85\u3048\u308b\u30e9\u30af\u30c0\u304c\u3044\u308b\u5834\u5408\u306f\u6e21\u308c\u306a\u3044\nif v[1] < max(w):\n  print(-1)\n  return\n\n# \u9806\u5e8f\u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\ndef solve(order):\n  x = [-1] * N\n  x[0] = 0\n  for i in range(1, N):\n    w_now = order[i]\n    for j in range(i-1, -1, -1):\n      w_now += order[j]\n      space = l[bisect_left(v, w_now)-1]\n      x[i] = max(x[i], x[j]+space)\n  return x[-1]\n\n# \u30e9\u30af\u30c0\u306e\u4e26\u3079\u66ff\u3048\u3092\u5168\u3066\u8a66\u3059\nans = float('inf')\nfor order in permutations(w):\n  ans = min(ans, solve(order))\n\nprint(ans)", "from itertools import permutations\nfrom bisect import *\nN,M=list(map(int,input().split()))\nw=list(map(int,input().split()))\nlv=[list(map(int,input().split())) for _ in range(M)]\nw.sort()\nlv.sort(key=lambda x:x[1])\nseq=list(range(N))\nx=list(permutations(seq))\n#print(lv,w)\nvs=[0]\nls=[0]\nans=float(\"inf\")\nma=0\nflag=1\nfor i in range(M):\n    ma=max(ma,lv[i][0])\n    vs.append(lv[i][1])\n    ls.append(ma)\n#print(ls,vs)\n\nfor i in range(N):\n    if w[i]>lv[0][1]:\n        flag=0\n\nfor tuples in x:\n    cuml=[0]\n    buf=0\n    for i in tuples:\n        buf=buf+w[i]\n        cuml.append(buf)\n    #print(cuml)\n    disttable=[[0]*N for _ in range(N)]\n    dist=[0]*N\n    for i in range(N+1):\n        for j in range(i+2,N+1):\n            weight=cuml[j]-cuml[i]\n            ind=bisect_left(vs,weight)\n            #print(weight,ind)\n            disttable[i][j-1]=ls[ind-1]\n    #print(disttable)\n    for i in range(N):\n        for j in range(i+1,N):\n            dist[j]=max(dist[j],dist[i]+disttable[i][j])\n        #print(dist)\n    #input()\n    #print()\n    ans=min(ans,dist[N-1])\n\nif flag==1:\n    print(ans)\nelse:\n    print((-1))\n", "from bisect import bisect_left\nfrom itertools import permutations\nn, m = map(int, input().split())\nw = list(map(int, input().split()))\nlv = [list(map(int, input().split()))[::-1] for i in range(m)]\nlv.sort()\nl, v = [l_ for v_, l_ in lv], [v_ for v_, l_ in lv]\nif max(w) > min(v):print(-1);return()\nfor i in range(1, m):\n    l[i] = max(l[i - 1], l[i])\nl.append(0)\nans = float(\"inf\")\nfor p in permutations(range(n), r=n):\n    w2 = [w[w_] for w_ in p]\n    lis = [0]\n    now = w2[0]\n    for i in range(1, n):\n        now += w2[i]\n        cur = now\n        cnt = 0\n        for j in range(i):\n            ind = bisect_left(v, cur) - 1\n            cnt = max(cnt, lis[j] + l[ind])\n            cur -= w2[j]\n        lis.append(cnt)\n    ans = min(ans, lis[-1])\nprint(ans)", "N,M = map(int,input().split())\nW = list(map(int,input().split()))\nLV = [tuple(map(int,input().split())) for i in range(M)]\nmaxw = max(W)\nif any(maxw > v for l,v in LV):\n    print(-1)\n    return\n\nLV.sort(key=lambda x:x[1]*10**9 - x[0])\nvl = [(0,0)]\nmaxl = 0\nfor l,v in LV:\n    if l <= maxl: continue\n    maxl = l\n    vl.append((v,l))\n\nfrom itertools import permutations\nfrom bisect import bisect\nans = float('inf')\nfor ptn in permutations(W):\n    cw = [0]\n    for w in ptn:\n        cw.append(cw[-1] + w)\n    cl = [0]\n    for i in range(2,N+1):\n        nl = 0\n        for j in range(i-1):\n            w = cw[i] - cw[j]\n            k = bisect(vl, (w,-1))\n            l = vl[k-1][1]\n            pl = cl[i-2] - cl[j]\n            nl = max(nl, l-pl)\n        cl.append(cl[-1] + nl)\n    ans = min(ans, cl[-1])\nprint(ans)", "import itertools\nimport bisect\n\nn, m = list(map(int, input().split()))\nw = list(map(int, input().split()))\ng = [list(map(int, input().split())) for _ in range(m)]\n# \u5bfe\u4fa1\u91cd\u91cf\u3067\u30bd\u30fc\u30c8\u3059\u308b\ng.sort(key=lambda x: x[1])\n\nL = []\nV = []\n# \u4e8c\u5206\u63a2\u7d22\u3092\u5229\u7528\u3059\u308b\u4e0a\u3067\u8003\u3048\u306a\u304f\u3066\u3082\u826f\u3044\u6a4b\u306e\u90e8\u5206\u3092\u9664\u5916\u3059\u308b\ninit = 0\nfor i in range(m):\n    if g[i][0] > init:\n        L.append(g[i][0])\n        V.append(g[i][1])\n        init = g[i][0]\n\nw.sort()\nif w[0] > g[0][1]:\n    print((-1))\n    return\n\nans = float('inf')\nfor v in itertools.permutations(w):\n    dp = [0] * n\n    for i in range(1, n):\n        cnt = v[i]\n        for j in range(i - 1, -1, -1):\n            cnt += v[j]\n            # \u7aef\u306e\u6271\u3044\n            bisect_v = bisect.bisect_left(V, cnt)\n            if bisect_v - 1 < 0:\n                continue\n            dp[i] = max(dp[i], dp[j] + L[bisect_v - 1])\n    ans = min(ans, dp[-1])\nprint(ans)\n", "from itertools import permutations\nfrom bisect import bisect_left,bisect_right\n\nn,m=map(int,input().split())\nw=list(map(int,input().split()))\nlu=[list(map(int,input().split()))for _ in range(m)]\nlu.sort(key=lambda x: x[1])\nlu=[[0,lu[0][1]]]+lu\nl=[]\nu=[]\nfor ll,uu in lu:\n  u.append(uu)\n  if len(l):\n    l.append(max(ll,l[-1]))\n  else:\n    l.append(ll)\nif max(w)>min(u):\n  print(-1)\n  return\n\nans=10**20\nfor p in permutations(w):\n  x=[0]+list(p)\n  for i in range(n):x[i+1]+=x[i]\n  dp=[0]*n\n  for i in range(n-1):\n    for j in range(i+1,n):\n      s=x[j+1]-x[i]\n      ll=l[max(bisect_left(u,s)-1,0)]\n      dp[j]=max(dp[j],dp[i]+ll)\n  ans=min(ans,dp[n-1])\n  #print(p,dp)\nprint(ans)", "import sys\nfrom itertools import permutations\nfrom bisect import bisect_left\n\n\nN, M = list(map(int, input().split()))\nW = list(map(int, input().split()))\nP = [tuple(map(int, sys.stdin.readline().split())) for _ in range(M)]\nINF = float('inf')\n\nif max(W) > min(v for _, v in P):\n    print((-1))\n    return\n\nP.sort(key=lambda x: (x[0], -x[1]))\ncur = INF\nbridge_l = []\nbridge_v = []\nfor l, v in reversed(P):\n    if v < cur:\n        bridge_l.append(l)\n        bridge_v.append(v)\n        cur = v\nbridge_l.append(0)\nbridge_v.append(0)\nbridge_l.reverse()\nbridge_v.reverse()\n\nans = INF\nfor C in permutations(W):\n    H = [0] * (N + 1)\n    for i, c in enumerate(C):\n        H[i] = H[i - 1] + c\n    pos = [0] * N\n    for i in range(1, N):\n        for j in range(i):\n            w = H[i] - H[j - 1]\n            idx = bisect_left(bridge_v, w)\n            pos[i] = max(pos[i], pos[j] + bridge_l[idx - 1])\n    ans = min(ans, pos[N - 1])\n\nprint(ans)\n", "def main():\n    n, m = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n    lv = [list(map(int, input().split())) for _ in [0]*m]\n\n    # \u30c0\u30e1\u306a\u6642\u306f\u3059\u3050\u7d42\u308f\u308b\n    min_v = 10**15\n    for l, v in lv:\n        min_v = min(min_v, v)\n    if min_v < max(w):\n        print((-1))\n        return 0\n\n    w_list = [-1]\n    l_list = [0]\n\n    lv.sort(key=lambda x: (x[1], -x[0]))\n    for l, v in lv:\n        if w_list[-1] != v:\n            w_list.append(v)\n            l_list.append(max(l, l_list[-1]))\n        else:\n            l_list[-1] = max(l, l_list[-1])\n\n    from itertools import permutations\n    from bisect import bisect_left as bl\n    perm = permutations(w)\n\n    ans = 10**15\n\n    for p in perm:\n        # d[i][j]:i\u3068j\u306e\u5fc5\u8981\u306a\u8ddd\u96e2\n        d = [[0]*n for _ in [0]*n]\n        for i in range(n-1):\n            for j in range(i+1, n):\n                #print(i, j)\n                weight = sum(p[i:j+1])\n                b = bl(w_list, weight)-1\n                d[i][j] = max(d[i][j], l_list[b])\n        dist = [0]*n\n        for i in range(1, n):\n            for j in range(i):\n                if dist[i] - dist[j] < d[j][i]:\n                    dist[i] = dist[j] + d[j][i]\n        ans = min(ans, dist[-1])\n    print(ans)\n\n\nmain()\n", "# C - Camels and Bridge\nimport itertools\nimport bisect\n\nn,m = map(int,input().split())\nw = tuple(map(int,input().split()))\nlv = []\nfor i in range(m):\n  l,v = map(int,input().split())\n  lv.append([v,l])\n\nlv.sort(key = lambda x:(x[0],-x[1]))\n# print(lv)\nfor wi in w:\n  if wi > lv[0][0]:\n    print(-1)\n    return\nmx = 0\n# \u3088\u308a\u8010\u8377\u91cd\u304c\u5c0f\u3055\u3044\u30d1\u30fc\u30c4\u306e\u9577\u3055\u304c\u512a\u5148\u3055\u308c\u308b\u3002\n# \u8010\u8377\u91cd4\u9577\u305510\u3068\u8010\u8377\u91cd7\u9577\u30555\u306e\u30d1\u30fc\u30c4\u304c\u3042\u3063\u305f\u3089\u3001\u5f8c\u8005\u306e\u30d1\u30fc\u30c4\u306f\u7121\u8996\u3055\u308c\u308b\u3002\n# (\u91cd\u91cf7\u3067\u308210\u306e\u9593\u9694\u304c\u5fc5\u8981)\nfor i in range(m):\n  mx = max(lv[i][1],mx)\n  lv[i][1] = mx\n# lv.append([float('inf'),lv[-1][1]])\nlv = [[0,0]]+lv\n\nb = {}\ndef f(x):\n  if x in b:\n    return b[x]\n  else:\n    b[x] = bisect.bisect_left(lv,[x,0])\n    return b[x]\n\nans = float('inf')\n# \u30e9\u30af\u30c0\u306e\u3059\u3079\u3066\u306e\u4e26\u3073\u9806\u3092\u5168\u63a2\u7d22\u3059\u308b\u3002\nfor p in itertools.permutations(range(n)):\n  # dp[i][j]:\u3068\u3089\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044i\u756a\u76ee\u306e\u30e9\u30af\u30c0\u304b\u3089j\u756a\u76ee\u306e\u30e9\u30af\u30c0\u307e\u3067\u9593\u9694\u306e\u6700\u5c0f\u5024\n  dp = [[0 for _ in range(n)] for _ in range(n)]\n  for i in range(n-1):\n    for j in range(i+1,n):\n      ww = 0\n      for k in range(i,j+1):\n        ww += w[p[k]]\n      # idx = bisect.bisect_left(lv,[ww,0])\n      idx = f(ww)\n      # print(ww,idx,lv)\n      dp[i][j] = lv[idx-1][1]\n  # \u4f8b\u3048\u30700,j,i\u756a\u76ee\u306e\u30e9\u30af\u30c0\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3068\u30010\u3068i\u306e\u9593\u9694\u306f\n  # dp[0][i]\u3068dp[0][j]+dp[j][i]\u306e\u9577\u3044\u65b9\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n  for i in range(1,n):\n    for j in range(i):\n      dp[0][i] = max(dp[0][j]+dp[j][i],dp[0][i])\n  ans = min(dp[0][n-1],ans)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nimport bisect\n\nN,M=map(int,input().split())\nW=list(map(int,input().split()))\nB=[tuple(map(int,input().split())) for i in range(M)]\n\nMIN=1<<60\nfor l,v in B:\n    MIN=min(MIN,v)\n\nif MIN<max(W):\n    print(-1)\n    return\n\nB2=[]\nfor x,y in B:\n    B2.append([y,x])\nB2.sort(key=itemgetter(0))\n\nB3=[B2[0]]\nfor x,y in B2[1:]:\n    if y<=B3[-1][1]:\n        continue\n    else:\n        B3.append([x,y])\n\nB3=[[0,0]]+B3\nB3.append([1<<60,B3[-1][1]])\n\nfrom itertools import permutations\n\nL=list(permutations(range(N)))\nANS=1<<60\n\nfor l in L:\n    W2=[W[l[i]] for i in range(N)]\n    DP=[0]*(N+1)\n\n    for i in range(N):\n        S=W2[i]\n        for j in range(i+1,N):\n            S+=W2[j]\n            x=bisect.bisect(B3,[S,0])\n\n            DP[j]=max(DP[j],DP[i]+B3[x-1][1])\n       \n    ANS=min(ANS,DP[N-1])\nprint(ANS)", "import itertools\nimport bisect\n\nN, M = [int(n) for n in input().split()]\nW = [int(n) for n in input().split()]\nbridges = [[int(n) for n in input().split()] for _ in range(M)] # [length_i, weight_i] \n\n# sort by weight\nbridges.sort(key=lambda x: x[1])\n\nlimits = [v for l, v in bridges]\nlen_rm = list(itertools.accumulate([l for l, v in bridges], max)) # running maximum\n# len_rm[i]: the maximum length of the bridges whose load limit <= limits[i]\n\nans = -1\nif max(W) <= min(limits):\n    ans = 1000000000 # larger than maximum possible solution (7 x 10^8)\n    for W_perm in itertools.permutations(W):\n        lengths = [0 for _ in range(N)]\n        for i in range(N):\n            w_ij = W_perm[i]\n            for j in range(i+1, N):\n                w_ij += W_perm[j] # w_ij: total weight between i and j (inclusive)\n                idx = bisect.bisect_left(limits, w_ij)\n                if idx == 0: # all bridge accepts w_ij\n                    x_ij = 0\n                else: # bridges[0] ... bridges[i-1] cannot accept w_ij\n                    x_ij = len_rm[idx-1]\n                lengths[j] = max(lengths[j], lengths[i] + x_ij)\n\n                # skipping trivial edges\n                # even without this if-block, we can get AC\n                if idx == M:\n                    break\n            \n        candidate = lengths[-1]\n        ans = min(ans, candidate)\n\nprint(ans)\n", "from itertools import permutations\nfrom bisect import bisect_left as B\nN, M = list(map(int, input().split()))\nW = list(map(int, input().split()))\nvls = []\nfor _ in range(M):\n    l, v = list(map(int, input().split()))\n    vls.append((v,l))\nvls.sort()\nrm = [0]*(M+1)\nvs = []\nfor i, (v, l) in enumerate(vls):\n    rm[i+1] = max(rm[i], l)\n    vs.append(v)\nR = 10**18\nfor w in permutations(W, N):\n    md = [0]*N\n    for i in range(N):\n        hw = w[i] \n        if B(vs, hw):R=-1\n        for j in range(i+1, N):\n            hw += w[j]\n            md[j] = max(md[j], md[i]+rm[B(vs, hw)])\n    R = min(R, md[-1])\nprint(R)\n\n", "# -*- coding: utf-8 -*-\n\nfrom sys import stdin\nimport math\nimport itertools\nreadline = stdin.readline\n#n = int(readline())\n#n, m = map(int, readline().split())\n#a = list(map(int, readline().split()))\n#l = [list(map(int, readline().split())) for _ in [0]*m]\nn, m = list(map(int, readline().split()))\nweights = list(map(int, readline().split()))\n\nbridges = [list(map(int, readline().split())) for _ in [0]*m]\n# \u9577\u3055\u9806\nbridges.sort()\n\n# \u9577\u3044\u9806\u306b\u6a4b\u306e\u6761\u4ef6\u3092\u898b\u3066\u3044\u304d\u3001\u4e0d\u8981\u306a\u3082\u306e\u3092\u53d6\u308a\u9664\u304f\u51e6\u7406\n# \u7740\u76ee\u3057\u3066\u3044\u308b\u6a4bA\u306b\u3064\u3044\u3066\u3001\u81ea\u5206\u3088\u308a\u9577\u3044\u304b\u3064\u8010\u8377\u91cd\u304c\u5c0f\u3055\u3044\u6a4bX\u304c\u5b58\u5728\n# => A\u306e\u8010\u8377\u91cd\u6761\u4ef6\u306fX\u306e\u6761\u4ef6\u3092\u6e80\u305f\u305b\u81ea\u52d5\u7684\u306b\u6e80\u305f\u3055\u308c\u308b\u306e\u3067\u3001A\u306f\u4e0d\u8981\nbridges_filtered = []\nbridges_filtered.append(bridges[m-1])\ncurrent_strongest_conditon_bridge = bridges[m-1]\nbridges_filtered_len = 1\nfor i in range(m-2, -1, -1):\n    bridge = bridges[i]\n    if bridge[1] < current_strongest_conditon_bridge[1]:\n        bridges_filtered.append(bridge)\n        bridges_filtered_len += 1\n        current_strongest_conditon_bridge = bridge\n\n# \u30e9\u30af\u30c01\u982d\u3067\u6700\u3082\u53b3\u3057\u3044\u6a4b\u306e\u8010\u8377\u91cd\u30aa\u30fc\u30d0\u30fc\u306b\u306a\u308b\u306a\u3089\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30e9\u30af\u30c0\u5217\u306f\u4e0d\u53ef\u80fd\n# \u4e00\u756a\u91cd\u3044\u30e9\u30af\u30c0\u4e00\u982d\u3060\u3051\u78ba\u8a8d\u3059\u308c\u3070\u5341\u5206\nif current_strongest_conditon_bridge[1] < max(weights):\n    print(\"-1\")\n    return\n\n\ndef acceptable_min_len(w):\n    \"\"\"\n    \u91cd\u3055w\u306b\u8010\u3048\u3046\u308b\u9577\u3055\u3067\u6700\u77ed\u306e\u3082\u306e\u3092\u4e8c\u5206\u63a2\u7d22\n    \"\"\"\n    l, r = 0, bridges_filtered_len - 1\n    # bridges_filtered\u306f\u9577\u3044\u9806\u3001\u8010\u8377\u91cd\u304c\u5927\u304d\u3044\u9806\u3068\u306a\u3063\u3066\u3044\u308b\n    while l <= r:\n        mid = (l+r)//2\n        if bridges_filtered[mid][1] >= w:\n            l = mid+1\n        else:\n            r = mid-1\n    return bridges_filtered[l][0] if l <= bridges_filtered_len - 1 else 0\n\n\ndef min_len(seq):\n    \"\"\"\n    seq\u306f\u30e9\u30af\u30c0\u306e\u914d\u5217(\u4e26\u3073\u66ff\u3048\u6e08\u307f)\n    \u305d\u306e\u914d\u5217\u3067\u53ef\u80fd\u306a\u6700\u5c0f\u306e\u9577\u3055\u3092\u8fd4\u3059\n    \"\"\"\n    # dp[i]\u306fi\u756a\u76ee\u306e\u30e9\u30af\u30c0\u307e\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3088\u3046\u306b\u4e26\u3079\u305f\u6700\u5c0f\u306e\u9577\u3055\n    # dp[i] = i\u3088\u308a\u524d\u306e\u5168\u3066\u306e\u30e9\u30af\u30c0\u3068\u306e\u533a\u9593\u306b\u304a\u3044\u3066\u3001\u6a4b\u3092\u3053\u308f\u306a\u3055\u3044\u3088\u3046\u306a\u6700\u5c0f\u306e\u9577\u3055\u3092\u6e80\u305f\u3059\n    dp = [0]*(n+1)\n    # \u91cd\u3055\u306e\u7d2f\u7a4d\u548c\u3002i-j\u756a\u76ee\u306e\u30e9\u30af\u30c0\u306e\u91cd\u3055\u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b\u306e\u306b\u4f7f\u7528\n    cusum_wight = [0]\n    for i in seq:\n        cusum_wight.append(cusum_wight[-1]+weights[i])\n    for i in range(2, n+1):\n        for j in range(1, i):\n            weight_between_i_j = cusum_wight[i]-cusum_wight[j-1]\n            min_len_i_j = acceptable_min_len(weight_between_i_j)\n            # \u9577\u3044\u307b\u3046\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n            dp[i] = max(dp[i], dp[j] + min_len_i_j)\n    return dp[-1]\n\n\nbase = list(range(n))\ncombinations = itertools.permutations(base)\nprint((min(list(map(min_len, combinations)))))\n", "import itertools\nimport bisect\n\ndef f(i):\n    if i == n:\n        k = 0\n        sumw = 0\n        for j in range(n):\n            if s[j]:\n                k += pow2[j]\n                sumw += w[j]\n        sumwlist[k] = sumw\n        return\n    s[i] = 1\n    f(i + 1)\n    s[i] = 0\n    f(i + 1)\n    return\n\nn, m = map(int, input().split())\nw = list(map(int, input().split()))\nvl = []\nvlist = []\nfor _ in range(m):\n    l, v = map(int, input().split())\n    vl.append([v, l])\nvl.sort()\nfor v, l in vl:\n    vlist.append(v)\nif vlist[0] < max(w):\n    print(-1)\n    return\nmaxl = [0] * (m + 1)\nfor i in range(m):\n    maxl[i + 1] = max(maxl[i], vl[i][1])\ns = [0] * n\npow2 = [1] * n\nfor i in range(n - 1):\n    pow2[i + 1] = 2 * pow2[i]\nsumwlist = [0] * (2 * pow2[-1] + 5)\nf(0)\nokl = [0] * (2 * pow2[-1] + 5)\nfor i in range(2 * pow2[-1]):\n    okl[i] = maxl[bisect.bisect_left(vlist, sumwlist[i])]\nans = 1145141919810\nfor p in itertools.permutations(pow2):\n    p = list(p)\n    q = [0] * (n + 1)\n    for i in range(n):\n        q[i + 1] = p[i] + q[i]\n    dp = [[0] * (n - 1) for _ in range(n - 1)]\n    for i in range(n - 1):\n        dp[0][i] = okl[q[i + 2] - q[i]]\n    for i in range(1, n - 1):\n        for j in range(n - 1 - i):\n            dp[i][j] = okl[q[i + j + 2] - q[j]]\n            for k in range(1, i + 1):\n                dp[i][j] = max(dp[i][j], dp[k - 1][j] + dp[i - k][j + k])\n    ans = min(ans, dp[n - 2][0])\nprint(ans)", "import sys,itertools,bisect\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nW = [ int(w) for w in input().split()]\nmaxW = max(W)\nlv=[list(map(int,input().split())) for _ in range(M)]\n#\u6a4b\u306e\u9078\u5225\u3000\u30cd\u30c3\u30af\u3068\u306a\u308b\u6a4b\u306e\u62bd\u51fa\u3000lj<=li,vj>=vi \u3068\u306a\u308b\u6a4bj\u306fi\u306b\u7d71\u5408\u53ef\u80fd\nlv.sort(key=lambda x:(x[1],-x[0]))\nLV=[lv[0]]\nfor l,v in lv:\n    if maxW>v:\n        print((-1))\n        return\n    if LV[-1][0]<l:\n        LV.append([l,v])\n#LV.sort(key=lambda x:x[1])\nV = [ v for _,v in LV]\nL = [ l for l,_ in LV]\n#\u3089\u304f\u3060\u306e\u9806\u756a\u3067\u30eb\u30fc\u30d7\nans = float('inf')\n\nfor perm in itertools.permutations(list(range(N)),N):\n    dist = [0]*(N+1)#i\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u5fc5\u8981\u8ddd\u96e2 \u3068\u3044\u3046\u304b\u3000\u5ea7\u6a19\n    #wgt = [0]*(N+1)#i-1\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u91cd\u3055\u306e\u7d2f\u7a4d\u548c\n    #wgt[1] = W[perm[0]]\n    for i in range(1,N):#i\u306f\u7d42\u308f\u308a\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3000i\u542b\u3080\n        #wgt[i+1]=wgt[i]+W[perm[i]]\n        ww = W[perm[i]]\n        for j in range(1,i+1):\n            #toW = wgt[i+1]-wgt[j]\n            ww +=W[perm[i-j]]\n            idx = bisect.bisect_left(V,ww)-1\n            if idx == -1:\n                length = 0\n            else:\n                length = L[idx]\n            dist[i+1]=max(dist[i+1],dist[i-j+1]+length)\n    ans = min(ans,dist[-1])\n\nprint(ans)\n", "from bisect import bisect_left\nfrom collections import namedtuple\nfrom itertools import permutations\n\nN, M = list(map(int, input().split()))\nW = [int(x) for x in input().split()]\nP = [tuple(map(int, input().split())) for _ in range(M)]\nP.sort(key=lambda part: part[1])\n\nls = [p[0] for p in P]\nvs = [p[1] for p in P]\nfor i in range(1, M):\n    ls[i] = max(ls[i - 1], ls[i])\n\nif max(W) > min(vs):\n    print((-1))\n    return\n\nans = 10 ** 20\nfor ws in permutations(sorted(W)):\n    pref = [ws[0]]\n    for i in range(1, N):\n        pref.append(pref[i - 1] + ws[i])\n\n    dp = [0] * N\n    for i in range(N):\n        for j in range(i):\n            interval = pref[i] - (pref[j - 1] if j >= 1 else 0)\n            idx = bisect_left(vs, interval)\n            need = ls[idx - 1] if idx >= 1 else 0\n            dp[i] = max(dp[i], dp[j] + need)\n\n    ans = min(ans, dp[-1])\n\nprint(ans)\n", "import sys\nfrom itertools import permutations\nfrom bisect import bisect_left, bisect_right\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\nw = list(map(int, input().split()))\nlv = [tuple(map(int, input().split())) for _ in range(M)]\n\n\ndef solve(w, lv):\n    # \u3069\u306e\u3088\u3046\u306b\u3057\u3066\u3082\u6a4b\u304c\u5d29\u843d\u3057\u3066\u3057\u307e\u3046\n    if max(w) > min(_[1] for _ in lv):\n        return -1\n\n    # \u524d\u51e6\u7406\n    lv.sort(key=lambda x: x[1])\n    vs = []\n    ls = []\n    for l, v in lv:\n        if len(ls) == 0 or l > ls[-1]:\n            vs.append(v)\n            ls.append(l)\n\n    ans = -2\n    # \u30e9\u30af\u30c0\u305f\u3061\u306e\u968a\u5217\u3092\u5168\u63a2\u7d22\n    for p in permutations(w):\n        cum_weights = [0]\n        positions = [0]\n        for i, wi in enumerate(p):\n            cum_weights.append(cum_weights[-1] + wi)\n            if i == 0:\n                continue\n\n            next_pos = positions[-1]\n            for j in range(i):\n                intarval_weight = cum_weights[i + 1] - cum_weights[j]\n                critical_bridge = bisect_left(vs, intarval_weight) - 1\n                if critical_bridge >= 0:\n                    next_pos = max(next_pos, positions[j] + ls[critical_bridge])\n\n            positions.append(next_pos)\n\n        if ans == -2:\n            ans = positions[-1]\n        else:\n            ans = min(ans, positions[-1])\n    return ans\n\n\nprint((solve(w, lv)))\n", "import sys\nfrom itertools import permutations, accumulate\nfrom bisect import bisect_left\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c for j in range(b)] for i in range(a)]\ndef list3d(a, b, c, d): return [[[d for k in range(c)] for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e for l in range(d)] for k in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10**9)\nINF = 10**19\nMOD = 10**9 + 7\nEPS = 10**-10\n\nN, M = MAP()\nW = LIST()\nVL = [(0, 0)]\nfor i in range(M):\n    l, v = MAP()\n    VL.append((v, l))\n\nVL.sort()\nV = [0] * (M+1)\nL = [0] * (M+1)\nfor i in range(1, M+1):\n    V[i] = VL[i][0]\n    L[i] = max(VL[i][1], L[i-1])\n\nif max(W) > min(V[1:]):\n    print((-1))\n    return\n\nans = INF\nfor perm in permutations(W):\n    acc = [0] + list(accumulate(perm))\n    dp = [0] * N\n    for l in range(N):\n        for r in range(l+1, N):\n            sm = acc[r+1] - acc[l]\n            idx = bisect_left(V, sm) - 1\n            dp[r] = max(dp[r], dp[l] + L[idx])\n    ans = min(ans, dp[N-1])\nprint(ans)\n", "import sys\n\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    N, M = map(int, readline().split())\n    W = list(map(int, readline().split()))\n    w_max = max(W)\n\n    mat = []\n    for _ in range(M):\n        l, v = map(int, readline().split())\n        if v < w_max:\n            return print(-1)\n        mat.append((l, v))\n    from operator import itemgetter\n\n    mat.sort(key=itemgetter(0), reverse=True)\n    mat.sort(key=itemgetter(1))\n\n    L = [0]\n    V = [0]\n    m = 0\n\n    for i in range(M):\n        l, v = mat[i]\n        m = max(m, l)\n        L.append(m)\n        V.append(v)\n\n    from itertools import permutations\n    import bisect\n    ans = INF\n    for per in permutations(range(N)):\n        a = [W[i] for i in per]\n        b = [[0] * N for _ in range(N)]\n        for i in range(N - 1):\n            cur = a[i]\n            for j in range(i + 1, N):\n                cur += a[j]\n                p = bisect.bisect_left(V, cur)\n                b[i][j] = L[p - 1]\n        dp = [0] * N\n        for i in range(N - 1):\n            cur = dp[i]\n            for j in range(i + 1, N):\n                dp[j] = max(dp[j], cur + b[i][j])\n        ans = min(ans, dp[N - 1])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\nfrom itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write('\\n'.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\n#from fractions import Fraction\n#sys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9)+7\n\n\nn,m=mdata()\nw=mdata()\npart=sorted([mdata() for i in range(m)],key=lambda x:x[1])\npart1=[part[0][1]]\npart2=[0,part[0][0]]\nfor i in range(1,m):\n    part1.append(part[i][1])\n    part2.append(max(part2[-1],part[i][0]))\nif min(part1)<max(w):\n    out(-1)\n    return\nperm=list(permutations(w))\nans=INF\nfor lis in perm:\n    dp=[0]*n\n    for i in range(n):\n        ind=i\n        k=lis[i]\n        for j in range(i+1,n):\n            k+=lis[j]\n            dp[j]=max(dp[j],dp[i]+part2[bl(part1,k)])\n    ans=min(ans,dp[-1])\nout(ans)", "from bisect import bisect_left\nfrom itertools import permutations\nn, m = map(int, input().split())\nw = list(map(int, input().split()))\nlv = [list(map(int, input().split()))[::-1] for i in range(m)]\nlv.sort()\nl, v = [l_ for v_, l_ in lv], [v_ for v_, l_ in lv]\nif max(w) > min(v):print(-1);return()\nfor i in range(1, m):\n    l[i] = max(l[i - 1], l[i])\nl.append(0)\nans = float(\"inf\")\nfor p in permutations(range(n), r=n):\n    w2 = [w[w_] for w_ in p]\n    lis = [0]\n    now = w2[0]\n    for i in range(1, n):\n        now += w2[i]\n        cur = now\n        cnt = 0\n        for j in range(i):\n            ind = bisect_left(v, cur) - 1\n            cnt = max(cnt, lis[j] + l[ind])\n            cur -= w2[j]\n        lis.append(cnt)\n    ans = min(ans, lis[-1])\nprint(ans)", "import sys,itertools,bisect\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nW = [ int(w) for w in input().split()]\nmaxW = max(W)\nlv=[list(map(int,input().split())) for _ in range(M)]\n#\u6a4b\u306e\u9078\u5225\u3000\u30cd\u30c3\u30af\u3068\u306a\u308b\u6a4b\u306e\u62bd\u51fa\u3000lj<=li,vj>=vi \u3068\u306a\u308b\u6a4bj\u306fi\u306b\u7d71\u5408\u53ef\u80fd\nlv.sort(key=lambda x:(x[1],-x[0]))\nLV=[lv[0]]\nfor l,v in lv:\n    if maxW>v:\n        print((-1))\n        return\n    if LV[-1][0]<l:\n        LV.append([l,v])\nLV.sort(key=lambda x:x[1])\nV = [ v for _,v in LV]\nL = [ l for l,_ in LV]\n#\u3089\u304f\u3060\u306e\u9806\u756a\u3067\u30eb\u30fc\u30d7\nans = float('inf')\nfor perm in itertools.permutations(list(range(N)),N):\n    dist = [0]*(N)#i\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u5fc5\u8981\u8ddd\u96e2 \u3068\u3044\u3046\u304b\u3000\u5ea7\u6a19\n    wgt = [0]*(N+1)#i-1\u756a\u76ee\u307e\u3067\u306e\u30e9\u30af\u30c0\u306e\u91cd\u3055\u306e\u7d2f\u7a4d\u548c\n    wgt[1] = W[perm[0]]\n    for i in range(1,N):#i\u306f\u7d42\u308f\u308a\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3000i\u542b\u3080\n        wgt[i+1]=wgt[i]+W[perm[i]]\n        for j in range(i):\n            toW = wgt[i+1]-wgt[j]\n            idx = bisect.bisect_left(V,toW)-1\n            if idx == -1:\n                length = 0\n            else:\n                length = L[idx]\n            dist[i]=max(dist[i],dist[j]+length)\n    ans = min(ans,dist[-1])\n\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\nfrom itertools import permutations,accumulate\nfrom operator import itemgetter\nimport bisect\ndef input(): return sys.stdin.readline().rstrip()\n\ndef trans(l_2d):\n    return [list(x) for x in zip(*l_2d)]\n\ndef main():\n    n,m=list(map(int, input().split()))\n    camel=list(map(int, input().split()))\n    bridge=[list(map(int, input().split())) for i in range(m)]\n    bridge.sort(key=itemgetter(1))\n    bridge=trans(bridge)\n    bridge[0]=list(accumulate(bridge[0],func=max,initial=0))\n    #print(bridge)\n    if max(camel) > min(bridge[1]):\n        print((-1))\n        return\n    ans=10**15\n    for permut in permutations(camel):\n        graph=[[0]*n for _ in range(n)]\n        for i in range(n-1):\n            for j in range(i+1,n):\n                weight=sum(permut[i:j+1])\n                graph[i][j]=bridge[0][bisect.bisect_left(bridge[1], weight)] #n\u4ee5\u4e0b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n        dist=[0]*n\n        for i in range(1,n):\n            mindist=0\n            for j in range(i):\n                mindist=max(dist[j]+graph[j][i],mindist)\n            dist[i]=mindist\n        ans=min(ans,dist[-1])\n    #print(dist)\n    print(ans)        \n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\nimport bisect\n\nN, M = [int(n) for n in input().split()]\nW = [int(n) for n in input().split()]\nbridges = [[int(n) for n in input().split()] for _ in range(M)] # [length_i, weight_i] \n\n# sort by weight\nbridges.sort(key=lambda x: x[1])\n\nlimits = [v for l, v in bridges]\nlen_rm = list(itertools.accumulate([l for l, v in bridges], max)) # running maximum\n# len_rm[i]: the maximum length of the bridges whose load limit <= limits[i]\n\nans = -1\nif max(W) <= min(limits):\n    for W_perm in itertools.permutations(W):\n        lengths = [0 for _ in range(N)]\n        for i in range(N):\n            w_ij = W_perm[i]\n            for j in range(i+1, N):\n                w_ij += W_perm[j] # w_ij: total weight between i and j (inclusive)\n                idx = bisect.bisect_left(limits, w_ij)\n                if idx == 0: # all bridge accepts w_ij\n                    x_ij = 0\n                else: # bridges[0] ... bridges[i-1] cannot accept w_ij\n                    x_ij = len_rm[idx-1]\n                lengths[j] = max(lengths[j], lengths[i] + x_ij)\n            \n        candidate = lengths[-1]\n        if ans == -1:\n            ans = candidate\n        else:\n            ans = min(ans, candidate)\n\nprint(ans)\n", "from itertools import permutations\nfrom bisect import bisect_left, bisect_right\nN, M = list(map(int, input().split()))\nW = list(map(int, input().split()))\nL = [tuple(map(int, input().split())) for _ in range(M)]\nL.sort(key=lambda x: x[1])\nlength = [0]\nweights = [0]\nfor l, w in L:\n    if l >= length[-1] and w >= weights[-1]:\n        length.append(l)\n        weights.append(w)\n\nif max(W) > weights[1]:\n    print((-1))\n    return\n\nans = 10**10\nfor p in permutations(list(range(N))):\n    rows = [0]*N\n    V = [0]\n    for i in range(N):\n        V.append(V[-1]+W[p[i]])\n    for i in range(N):\n        for j in range(i+1, N):\n            w = V[j+1]-V[i]\n            rows[j] = max(rows[j], rows[i]+length[bisect_left(weights, w)-1])\n    if ans > rows[-1]:\n        ans = rows[-1]\nprint(ans)\n", "import sys\nimport bisect\nfrom itertools import permutations, accumulate\ninput = sys.stdin.readline\nN,M = list(map(int,input().split()))\nW = list(map(int, input().split()))\nLV = [list(map(int,input().split())) for i in range(M)]\nVL = [(v,l) for l,v in LV]\nVL.sort()\n\nV,L = list(zip(*VL))\n\nif max(W) > min(V):\n    print((-1))\n    return\n\nL = [0]+list(accumulate(L, max))\n\nans = 10**20\n\nfor order in permutations(list(range(N))):\n    NW = [W[i] for i in order]\n    t = [0, NW[0]]\n    p = [0]\n    for nw in NW[1:]:\n        t.append(t[-1] + nw)\n        ps = []\n        for np, nt in zip(p,t[:-2]):\n            ind = bisect.bisect_left(V, t[-1]-nt)\n            ps.append(np+L[ind])\n        p.append(max(ps))\n    ans = min(ans, p[-1])\n\nprint(ans)\n\n\n", "from bisect import bisect_left\nfrom collections import namedtuple\nfrom itertools import permutations\n\nn,m = map(int,input().split())\nw = list(map(int,input().split()))\nP = [tuple(map(int,input().split())) for _ in range(m)]\nP.sort(key = lambda x:x[1])\nls = [p[0] for p in P]\nvs = [p[1] for p in P]\nfor i in range(1,m):\n    ls[i] = max(ls[i-1],ls[i])\n\nif max(w)>min(vs):\n    print(-1);return\n\nans = float('inf')\nfor ws in permutations((w)):\n    pref = [ws[0]]\n    for i in range(1,n):\n        pref.append(pref[i-1]+ws[i])\n    dp = [0]*n\n    for i in range(n):\n        for j in range(i):\n            interval = pref[i]-(pref[j-1] if j>=1 else 0)\n            idx = bisect_left(vs,interval)\n            need = ls[idx-1] if idx>=1 else 0\n            dp[i] = max(dp[i],dp[j]+need)\n    ans = min(ans,dp[-1])\nprint(ans)", "from itertools import permutations\nfrom bisect import bisect_left\nn, m = list(map(int, input().split()))\nw = list(map(int, input().split()))\nli = [list(map(int, input().split())) for _ in range(m)]\nli.sort(key=lambda x: x[1])\nl = [0] * (m + 1)\nv = [0] * (m + 1)\nfor i in range(m):\n    l[i + 1], v[i + 1] = li[i]\nfor i in range(m):\n    l[i + 1] = max(l[i], l[i + 1])\nif max(w) > min(v[1:]):\n    print((-1))\nelse:\n    dv = dict()\n    for i in range(2 ** n):\n        t = 0\n        for j in range(n):\n            if (i >> j) & 1:\n                t += w[j]\n        dv[t] = l[bisect_left(v, t) - 1]\n    ans = 10 ** 18\n    for p in permutations(w):\n        li = [0] * (n + 1)\n        for i in range(n):\n            li[i + 1] = li[i] + p[i]\n        x = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                x[j - 1] = max(x[j - 1], x[i] + dv[li[j] - li[i]])\n        ans = min(ans, x[-1])\n    print(ans)\n", "import itertools\nimport bisect\n\n\nn, m = [int(i) for i in input().split()]\nw = [int(i) for i in input().split()]\n\n# l\u3068v\u306e\u7d44\u3092\u5165\u529b\u3057\u3001v\u306e\u6607\u9806\u3067\u30bd\u30fc\u30c8\nl_v = []\nfor i in range(m):\n    l_v.append([int(i) for i in input().split()])\nl_v.sort(key=lambda x:(x[1]))\n\n\"\"\"\nl\u3068v\u3092\u305d\u308c\u305e\u308c\u5206\u3051\u3066\u683c\u7d0d\uff08\u5f8c\u3005v\u306e\u5024\u3067\u4e8c\u5206\u63a2\u7d22\u3057\u305f\u3044\u306e\u3067\uff09\n2\u982d\u306e\u30e9\u30af\u30c0\u304c\u901a\u308c\u308b\u6a4b\u3092\u5f8c\u3005\u4e8c\u5206\u63a2\u7d22\u3059\u308b\n\u305d\u306e\u6642\u306bl\u306e\u7d2f\u7a4dmax\u3067\u3042\u308bmax_l\u3092\u7528\u3044\u308b\n\"\"\"\n\nl = []\nv = []\nmax_l = []\nmax_l_ = 0\n\nfor i in range(m):\n    l.append(l_v[i][0])\n    v.append(l_v[i][1])\n    max_l_ = max(l_v[i][0], max_l_)\n    max_l.append(max_l_)\n\nif min(v) < max(w): # \u4e00\u756a\u91cd\u3044\u30e9\u30af\u30c0\u304c\u4e00\u756a\u5f31\u3044\u6a4b\u3092\u901a\u308c\u306a\u3044\n    print(-1)\n    return\n\n\"\"\"\nn\u982d\u306e\u5408\u8a08\u91cd\u3055weight\u3092\u8010\u3048\u3089\u308c\u306a\u3044\u6a4b\u306e\u4e2d\u3067\u6700\u3082\u8ddd\u96e2\u304c\u9577\u3044\u6a4b\u3092\u8a18\u9332\u3059\u308b\n2\u5206\u63a2\u7d22\u3067\u6c42\u3081\u305findex\uff08n\u982d\u306e\u30e9\u30af\u30c0\u306e\u5408\u8a08\u306e\u91cd\u3055\u3092\u8010\u3048\u3089\u308c\u308b\u7aef\u306e\u4e2d\u3067\u6700\u3082\u5f37\u5ea6\u304c\u5f31\u3044\u3082\u306e\uff09\n\u3088\u308a\u524d\u306eindex\u306e\u6a4b\uff08\u30e9\u30af\u30c0\u306e\u91cd\u3055\u3092\u8010\u3048\u3089\u308c\u306a\u3044\u6a4b\uff09\u306e\u4e2d\u3067\u6700\u3082\u8ddd\u96e2\u304c\u5927\u304d\u3044\u6a4b\u306e\u9577\u3055\n\u2192max_l\u3092\u4f7f\u3046\uff01\n\"\"\"\n\nx = [0 for j in range(2**n)]\nfor i in itertools.product([0,1], repeat=n):\n    weight = sum([w[_] * i[_] for _ in range(n)])\n    a = bisect.bisect_left(v, weight)\n    if a >= 1:\n        x[sum([2**k * i[k] for k in range(n)])] = max_l[a - 1]\n\n\"\"\"\n\u30e9\u30af\u30c0\u306e\u4e26\u3073\u65b9\u5168n!\u306e\u7d44\u5408\u305b\u306b\u304a\u3044\u3066\u3001\u305d\u308c\u305e\u308cDP\u306b\u3088\u3063\u3066\u53d6\u3089\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044\u8ddd\u96e2\u3092\u8a08\u7b97\u3057\u3001\u305d\u306e\u6700\u5c0f\u5024\u3092ans\u3068\u3059\u308b\n\"\"\"\nans = float(\"inf\")\nfor i in itertools.permutations([_ for _ in range(n)]):\n    dp = [0 for _ in range(n-1)]\n    dp[0] =  x[2 ** i[1] + 2 ** i[0]]\n    for j in range(n-2):\n        if j == 0:\n            dp[j+1] = max(dp[j] + x[2 ** i[2] + 2 ** i[1]], x[2 ** i[2] + 2 ** i[1] + 2 ** i[0]])\n\n        else:\n            dpp = []\n            for k in range(j+1):\n                # print(i,j, k, [i[j + 1 - kk] for kk in range(j+2-k)])\n                sumbit = sum([2 ** i[j + 2 - kk] for kk in range(j + 2 - k)])\n                dpp.append(dp[k] + x[sumbit])\n            sumbit2 = sum([2 ** i[j + 2 - kk] for kk in range(j + 3)])\n            dpp.append(x[sumbit2])\n            dp[j+1] = max(dpp)\n\n    ans = min(ans, dp[-1])\n\nprint(ans)", "from itertools import permutations\nfrom itertools import accumulate\nfrom bisect import bisect_left, bisect_right\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    INF = 10**15\n\n    N, M = list(map(int, input().split()))\n    Ws = list(map(int, input().split()))\n    LVs = [tuple(map(int, input().split())) for _ in range(M)]\n\n    minV = min([V for L, V in LVs])\n\n    if max(Ws) > minV:\n        print((-1))\n        return\n\n    LVs.sort(key=lambda x: x[1])\n    bdrLs, bdrVs = [0], [0]\n    maxL = 0\n    for L, V in LVs:\n        if L > maxL:\n            bdrLs.append(L)\n            bdrVs.append(V)\n            maxL = L\n\n    ans = INF\n    for Camels in permutations(Ws, N):\n        accCamels = [0]+list(accumulate(Camels))\n        Lss = [[INF]*(N) for _ in range(N)]\n        for i in range(N):\n            if Camels[i] > minV:\n                Lss[i][i] = INF\n            else:\n                Lss[i][i] = 0\n            for j in range(i+1, N):\n                wgt = accCamels[j+1] - accCamels[i]\n                iV = bisect_left(bdrVs, wgt) - 1\n                Lss[i][j] = bdrLs[iV]\n\n        costs = [0] * N\n        for i in range(1, N):\n            cost = 0\n            for j in range(i+1):\n                c2 = costs[j] + Lss[j][i]\n                if c2 > cost:\n                    cost = c2\n            costs[i] = cost\n\n        if costs[-1] < ans:\n            ans = costs[-1]\n\n    if ans == INF:\n        print((-1))\n    else:\n        print(ans)\n\n\nsolve()\n", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\n\n\nmod=10**9+7\ninf = 10**10\n\nN,M=MI()\nW=LI()\nLV=[[0,0] for _ in range(M)]\nmV=inf\nfor i in range(M):\n    LV[i][0],LV[i][1]=MI()\n    mV=min(mV,LV[i][1])\n    \nif max(W) > mV:\n    print((-1))\n    return\n    \nLV.sort(reverse=True)\nnVL=[(0,0)]\n\n# \u3088\u308a\u77ed\u304f\u3066\u9811\u4e08\u306a\u6a4b\u306f\u8003\u616e\u3059\u308b\u5fc5\u8981\u306a\u3057\n# \u9577\u3044\u9806\u306b\u898b\u3066\u3044\u304f\u306e\u3067\uff0c\u4eca\u4ee5\u4e0a\u306e\u5bfe\u8377\u91cd\u306e\u6a4b\u304c\u51fa\u3066\u304d\u305f\u3089\u7121\u8996\nMV=inf\nfor i in range(M):\n    l,v=LV[i]\n    if v<MV:\n        nVL.append((v,l))\n        MV=v\n\nnVL.sort()\n# print(nVL)\n\nfrom collections import defaultdict\ndd = defaultdict(int)\n\nimport bisect\ndef calc(x):\n    # \u91cd\u3055x\u306e\u584a\u306b\u5bfe\u3057\u3066\uff0c\u6700\u4f4e\u3067\u3069\u308c\u3060\u3051\u306e\u8ddd\u96e2\u304c\u5fc5\u8981\u304b\n    \n    if dd[x]:\n        return dd[x]\n    \n    temp=(x,-1)\n    num=bisect.bisect_left(nVL,temp) - 1\n    \n    # print(x,temp,num)\n    v,l=nVL[num]\n    dd[x]=l\n    return l\n    \n    \n        \n        \nimport itertools\n\nans=inf\n\n# \u4e26\u3073\u304b\u305f\u3092\u5168\u63a2\u7d22\nfor ite in itertools.permutations(list(range(N)), N):\n    Cs=[]#\u4eca\u56de\u306e\u4e26\u3079\u65b9\n    for i in ite:\n        Cs.append(W[i])\n        \n    S=[0]*(N+1)\n    for i in range(N):\n        S[i+1]=S[i]+Cs[i]\n        \n    X=[0]*N\n        \n    # N\u500b\u306e\u9802\u70b9\u3060\u3068\u8003\u3048\u3066\uff0c\u305d\u308c\u305e\u308c\u306e\u5ea7\u6a19\u3092\u6c7a\u3081\u308b\n    for i in range(N):\n        for j in range(i+1,N):\n            # i\u756a\u76ee\u3068j\u756a\u76ee\u306e\u9593\u306e\u8ddd\u96e2\n            w=S[j+1]-S[i]\n            l=calc(w)\n            X[j]=max(X[j],\n                        X[i]+l)\n            \n    temp=X[-1]\n    ans=min(ans,temp)\n    \nprint(ans)\n            \n\n\n    \n\n", "import sys\nfrom itertools import permutations\nfrom bisect import bisect_left, bisect_right\n\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\nw = list(map(int, input().split()))\nlv = [tuple(map(int, input().split())) for _ in range(M)]\n\n\ndef solve(w, lv):\n    # \u3069\u306e\u3088\u3046\u306b\u3057\u3066\u3082\u6a4b\u304c\u5d29\u843d\u3057\u3066\u3057\u307e\u3046\n    if max(w) > min(_[1] for _ in lv):\n        return -1\n\n    # \u524d\u51e6\u7406\n    lv.sort(key=lambda x: x[1])\n    vs = []\n    ls = []\n    for l, v in lv:\n        if len(ls) == 0 or l > ls[-1]:\n            vs.append(v)\n            ls.append(l)\n\n    ans = -2\n    # \u30e9\u30af\u30c0\u305f\u3061\u306e\u968a\u5217\u3092\u5168\u63a2\u7d22\n    for p in permutations(w):\n        cum_weights = [0]\n        positions = [0]\n        for i, wi in enumerate(p):\n            cum_weights.append(cum_weights[-1] + wi)\n            if i == 0:\n                continue\n\n            next_pos = positions[-1]\n            for j in range(i):\n                intarval_weight = cum_weights[i + 1] - cum_weights[j]\n                critical_bridge = bisect_left(vs, intarval_weight) - 1\n                if critical_bridge >= 0:\n                    next_pos = max(next_pos, positions[j] + ls[critical_bridge])\n\n            positions.append(next_pos)\n\n        if ans == -2:\n            ans = positions[-1]\n        else:\n            ans = min(ans, positions[-1])\n    return ans\n\n\nprint((solve(w, lv)))\n", "from itertools import permutations\nfrom bisect import bisect_left\nimport sys\n\nINF = float('inf')\nN, M = map(int,input().split())\nW = list(map(int,input().split()))\nL = [0] * M\nV = [0] * M\n\nfor i in range(M):\n    L[i], V[i] = map(int,input().split())\n\nif max(W) > min(V):\n    print(-1)\n    return\n\nZIP = zip(V, L)\nZIP = sorted(ZIP)\nV, L = zip(*ZIP)\n\nR = [0] * M\nR[0] = L[0]\n\nfor i in range(M-1):\n    R[i+1] = max(R[i], L[i+1])\n\nans = float('inf')\n\nfor l in permutations(W, N):\n    dp = [0] * N\n    CUMSUM = [0]\n    for i in l:\n        CUMSUM.append(CUMSUM[-1] + i)\n    for i in range(N-1):\n        for j in range(i+2, N+1):\n            tmp = CUMSUM[j] - CUMSUM[i]\n            index = bisect_left(V, tmp)\n            if index == 0:\n                dp[j-1] = max(dp[j-1], dp[i])\n            else:\n                dp[j-1] = max(dp[j-1], dp[i] + R[index-1])\n    ans = min(ans, dp[-1])\nprint(ans)", "from bisect import bisect_left\nfrom itertools import permutations\nfrom operator import itemgetter\n\n\ndef solve(n, m, www, lv):\n    lv.sort(key=itemgetter(1))\n    if lv[0][1] < max(www):\n        return -1\n    lll = [0]\n    vvv = [0]\n    for l, v in lv:\n        if v == vvv[-1]:\n            lll[-1] = max(lll[-1], l)\n        elif l > lll[-1]:\n            lll.append(l)\n            vvv.append(v)\n    ans = 10 ** 18\n    for order in permutations(list(range(n))):\n        dists = [0] * n\n        for oi in range(n - 1):\n            d = dists[oi]\n            total_weight = www[order[oi]]\n            for oj in range(oi + 1, n):\n                total_weight += www[order[oj]]\n                k = bisect_left(vvv, total_weight) - 1\n                dists[oj] = max(dists[oj], d + lll[k])\n        ans = min(ans, dists[-1])\n    return ans\n\n\nn, m = list(map(int, input().split()))\nwww = list(map(int, input().split()))\nlv = [tuple(map(int, input().split())) for _ in range(m)]\nans = solve(n, m, www, lv)\nprint(ans)\n", "import itertools\nimport bisect\n\nN, M = [int(n) for n in input().split()]\nW = [int(n) for n in input().split()]\nbridges = [[int(n) for n in input().split()] for _ in range(M)] # [length_i, weight_i] \n\n# sort by weight\nbridges.sort(key=lambda x: x[1])\n\nlimits = [v for l, v in bridges]\nlen_rm = list(itertools.accumulate([l for l, v in bridges], max)) # running maximum\n# len_rm[i]: the maximum length of the bridges whose load limit <= limits[i]\n\nans = -1\nif max(W) <= min(limits):\n    for W_perm in itertools.permutations(W):\n        lengths = [0 for _ in range(N)]\n        for i in range(N):\n            w_ij = W_perm[i]\n            for j in range(i+1, N):\n                w_ij += W_perm[j] # w_ij: total weight between i and j (inclusive)\n                idx = bisect.bisect_left(limits, w_ij)\n                if idx == 0: # all bridge accepts w_ij\n                    x_ij = 0\n                else: # bridges[0] ... bridges[i-1] cannot accept w_ij\n                    x_ij = len_rm[idx-1]\n                lengths[j] = max(lengths[j], lengths[i] + x_ij)\n\n                if idx == M:\n                    break\n            \n        candidate = lengths[-1]\n        if ans == -1:\n            ans = candidate\n        else:\n            ans = min(ans, candidate)\n\nprint(ans)\n", "import sys\nimport itertools\nimport bisect\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\nedges=[list(map(int,input().split())) for _ in range(m)]\nedges.append([0,0])\nedges=sorted(edges,key=lambda x:x[0])\nls=[]\nws=[]\nfor i in range(m-1,-1,-1):\n  edges[i][1]=min(edges[i][1],edges[i+1][1])\nfor l,w in edges:\n  ls.append(l)\n  ws.append(w)\nif max(arr)>ws[1]:\n  print(-1)\n  return\nans=10**18\nfor p in itertools.permutations(range(n)):\n  tmp=[0]*n\n  for i in range(n):\n    tmp[i]=arr[p[i]]\n  tans=[0]*(n-1)\n  for r in range(1,n):\n    for l in range(0,r):\n      w=sum(tmp[l:r+1])\n      pos=bisect.bisect_left(ws,w)\n      tans[r-1]=max(tans[r-1],ls[pos-1]-sum(tans[l:r-1]))\n  ans=min(ans,sum(tans))\nprint(ans)", "import sys\nfrom itertools import permutations\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    W = list(map(int, input().split()))\n    LV = [list(map(int, input().split())) for _ in range(m)]\n\n    max_w = max(W)\n    min_v = min([LV[i][1] for i in range(m)])\n    if min_v < max_w:\n        print((-1))\n        return\n\n    LV.sort(key=lambda x: x[1])\n    L = [0, LV[0][0]]\n    V = [0, LV[0][1]]\n    for l, v in LV[1:]:\n        if l <= L[-1]:\n            continue\n        else:\n            L.append(l)\n            V.append(v)\n\n    L.append(L[-1])\n    V.append(f_inf)\n\n    res = f_inf\n    for pattern in permutations(W):\n        dp = [0] * n\n        for i in range(n):\n            sum_w = pattern[i]\n            for j in range(i + 1, n):\n                sum_w += pattern[j]\n                idx = bisect_left(V, sum_w)\n                dp[j] = max(dp[j], dp[i] + L[idx - 1])\n        res = min(res, dp[-1])\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_left\nfrom itertools import permutations\nfrom operator import itemgetter\n\n\ndef solve(n, www, lv):\n    lv.sort(key=itemgetter(1))\n    if lv[0][1] < max(www):\n        return -1\n    lll = [0]\n    vvv = [0]\n    for l, v in lv:\n        if v == vvv[-1]:\n            lll[-1] = max(lll[-1], l)\n        elif l > lll[-1]:\n            lll.append(l)\n            vvv.append(v)\n    ans = 10 ** 18\n    for order in permutations(www):\n        dists = [0] * n\n        for i in range(n - 1):\n            d = dists[i]\n            total_weight = order[i]\n            for j in range(i + 1, n):\n                total_weight += order[j]\n                k = bisect_left(vvv, total_weight) - 1\n                dists[j] = max(dists[j], d + lll[k])\n        ans = min(ans, dists[-1])\n    return ans\n\n\nn, m = list(map(int, input().split()))\nwww = list(map(int, input().split()))\nlv = [tuple(map(int, input().split())) for _ in range(m)]\nans = solve(n, www, lv)\nprint(ans)\n", "from itertools import permutations\nfrom bisect import bisect_left\n\ndef main():\n    inf=float(\"inf\")\n    n,m=map(int,input().split())\n    weight=sorted(list(map(int,input().split())))\n    bridge=[tuple(map(int,input().split())) for _ in range(m)]\n\n    bridge.sort(key=lambda x : x[1])\n    #\u8106\u3044\u6a4b\u304b\u3089\u9806\u306b\u4e26\u3079\u305f\n    bridge_w=[x[1] for x in bridge]\n    #i\u756a\u76ee\u306b\u8106\u3044\u6a4b\u304c\u6e21\u308c\u308b\u3068\u304d\u53d6\u308c\u308b\u9577\u3055\u306e\u6700\u3082\u77ed\u3044\u5024\n    bridge_l=[0]*(m+1)\n    for i in range(m):\n        bridge_l[i+1]=max(bridge[i][0],bridge_l[i])\n\n\n    if weight[-1]>bridge_w[0]:\n        print(-1)\n        return\n\n    #\u30e9\u30af\u30c0\u306e\u4e26\u3079\u65b9\u306b\u3064\u3044\u3066\u305d\u308c\u305e\u308c\u8003\u3048\u305f\u3044\n    mn=inf\n    for x in permutations(weight):\n        #i\u3068j\u306e\u30e9\u30af\u30c0\u304c\u96e2\u308c\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u8ddd\u96e2\u3092dis\n        dis=[[0]*n for _ in range(n)]        \n        \n        for i in range(1,n):\n            for j in range(n-i):\n                work_weight=sum(x[j:j+i+1])\n                work_index=bisect_left(bridge_w,work_weight)\n                mx=bridge_l[work_index]\n                for l in range(1,i):\n                    if dis[j][j+l]+dis[j+l][j+i]>mx:\n                        mx=dis[j][j+l]+dis[j+l][j+i]\n                dis[j][j+i]=mx\n        if dis[0][n-1]<mn : mn=dis[0][n-1]\n\n    print(mn)\n\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\n\ndef main():\n    mod=10**9+7\n    inf = 10**10\n    \n    N,M=MI()\n    W=LI()\n    LV=[[0,0] for _ in range(M)]\n    mV=inf\n    for i in range(M):\n        LV[i][0],LV[i][1]=MI()\n        mV=min(mV,LV[i][1])\n        \n    if max(W) > mV:\n        print((-1))\n        return\n        \n    LV.sort(reverse=True)\n    nVL=[(0,0)]\n    \n    # \u3088\u308a\u77ed\u304f\u3066\u9811\u4e08\u306a\u6a4b\u306f\u8003\u616e\u3059\u308b\u5fc5\u8981\u306a\u3057\n    # \u9577\u3044\u9806\u306b\u898b\u3066\u3044\u304f\u306e\u3067\uff0c\u4eca\u4ee5\u4e0a\u306e\u5bfe\u8377\u91cd\u306e\u6a4b\u304c\u51fa\u3066\u304d\u305f\u3089\u7121\u8996\n    MV=inf\n    for i in range(M):\n        l,v=LV[i]\n        if v<MV:\n            nVL.append((v,l))\n            MV=v\n    \n    nVL.sort()\n    # print(nVL)\n    \n    from collections import defaultdict\n    dd = defaultdict(int)\n    \n    import bisect\n    def calc(x):\n        # \u91cd\u3055x\u306e\u584a\u306b\u5bfe\u3057\u3066\uff0c\u6700\u4f4e\u3067\u3069\u308c\u3060\u3051\u306e\u8ddd\u96e2\u304c\u5fc5\u8981\u304b\n        \n        if dd[x]:\n            return dd[x]\n        \n        temp=(x,-1)\n        num=bisect.bisect_left(nVL,temp) - 1\n        \n        # print(x,temp,num)\n        v,l=nVL[num]\n        dd[x]=l\n        return l\n        \n        \n            \n            \n    import itertools\n    \n    ans=inf\n    \n    # \u4e26\u3073\u304b\u305f\u3092\u5168\u63a2\u7d22\n    for ite in itertools.permutations(list(range(N)), N):\n        Cs=[]#\u4eca\u56de\u306e\u4e26\u3079\u65b9\n        for i in ite:\n            Cs.append(W[i])\n            \n        S=[0]*(N+1)\n        for i in range(N):\n            S[i+1]=S[i]+Cs[i]\n            \n        X=[0]*N\n            \n        # N\u500b\u306e\u9802\u70b9\u3060\u3068\u8003\u3048\u3066\uff0c\u305d\u308c\u305e\u308c\u306e\u5ea7\u6a19\u3092\u6c7a\u3081\u308b\n        for i in range(N):\n            for j in range(i+1,N):\n                # i\u756a\u76ee\u3068j\u756a\u76ee\u306e\u9593\u306e\u8ddd\u96e2\n                w=S[j+1]-S[i]\n                l=calc(w)\n                X[j]=max(X[j],\n                         X[i]+l)\n                \n        temp=X[-1]\n        ans=min(ans,temp)\n        \n    print(ans)\n                \n    \n    \n     \n    \n    \n\nmain()\n", "from bisect import bisect_left\nfrom itertools import permutations\n\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nlv = [list(map(int, input().split())) for i in range(M)]\n\n# \u6ce8\u76ee\u3059\u3079\u304d\u6a4b\u3060\u3051\u53d6\u308a\u51fa\u3059\nlv.sort(key=lambda x:x[1])\nl = [0]\nv = [0]\nfor li, vi in lv:\n  if vi == v[-1]:\n    l[-1] = max(l[-1], li)\n  elif li > l[-1]:\n    l.append(li)\n    v.append(vi)\n\n# \u8010\u8377\u91cd\u3092\u5358\u4f53\u3067\u8d85\u3048\u308b\u30e9\u30af\u30c0\u304c\u3044\u308b\u5834\u5408\u306f\u6e21\u308c\u306a\u3044\nif v[1] < max(w):\n  print(-1)\n  return\n\n# \u9806\u5e8f\u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\ndef solve(order):\n  x = [-1] * N\n  x[0] = 0\n  for i in range(1, N):\n    w_now = order[i]\n    for j in range(i-1, -1, -1):\n      w_now += order[j]\n      space = l[bisect_left(v, w_now)-1]\n      x[i] = max(x[i], x[j]+space)\n  return x[-1]\n\n# \u30e9\u30af\u30c0\u306e\u4e26\u3079\u66ff\u3048\u3092\u5168\u3066\u8a66\u3059\nans = float('inf')\nfor order in permutations(w):\n  ans = min(ans, solve(order))\n\nprint(ans)", "import bisect\nfrom itertools import permutations\n\nN,M = map(int,input().split())\nw = list(map(int,input().split()))\n\nbridge = []\nfor i in range(M):\n    l,W = map(int,input().split())\n    bridge.append((W,l))\nbridge.sort()\n\nif min(bridge[i][0] for i in range(M))<max(w):\n    print(-1);return()\n\nMax = [bridge[i][1] for i in range(M)]\nfor i in range(1,M):\n    Max[i] = max(Max[i],Max[i-1])\n\ndata = [0 for i in range(2**N)]\n\nfor i in range(2**N):\n    tmp = 0\n    for j in range(N):\n        if i>>j & 1:\n            tmp += w[j]\n\n    idx = bisect.bisect_left(bridge,(tmp,-1))\n    if idx==0:\n        data[i] = 0\n    else:\n        data[i] = Max[idx-1]\n\nper = list(permutations([i for i in range(N)]))\nres = 10**18\nfor L in per:\n    d = [0 for i in range(N)]\n    for i in range(1,N):\n        tmp = 1<<L[i]\n        for j in range(i-1,-1,-1):\n            tmp += 1<<L[j]\n            d[i] = max(d[i],data[tmp]+d[j])\n    res = min(res,d[-1])\n\nprint(res)\n", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nimport bisect\n\nN,M=list(map(int,input().split()))\nW=list(map(int,input().split()))\nB=[tuple(map(int,input().split())) for i in range(M)]\n\nMIN=1<<60\nfor l,v in B:\n    MIN=min(MIN,v)\n\nif MIN<max(W):\n    print((-1))\n    return\n\nB2=[]\nfor x,y in B:\n    B2.append([y,x])\nB2.sort(key=itemgetter(0))\n\nB3=[B2[0]]\nfor x,y in B2[1:]:\n    if y<=B3[-1][1]:\n        continue\n    else:\n        B3.append([x,y])\n\nB3=[[0,0]]+B3\nB3.append([1<<60,B3[-1][1]])\n\nfrom itertools import permutations\n\nL=list(permutations(list(range(N))))\nANS=1<<60\n\nfor l in L:\n    W2=[W[l[i]] for i in range(N)]\n    DP=[0]*(N+1)\n\n    #if W2!=[857,849,806,57,608,244,349,513]:\n    #    continue\n\n    for i in range(N):\n        for j in range(i+1,N):\n            S=sum(W2[i:j+1])\n            x=bisect.bisect(B3,[S,0])\n\n            DP[j]=max(DP[j],DP[i]+B3[x-1][1])\n\n        #print(W2,S,x,DP)\n            \n            \n    #if W2==[857,849,806,57,608,244,349,513]:\n    #    print(W2,DP)\n                \n    ANS=min(ANS,DP[N-1])\nprint(ANS)\n            \n    \n", "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**9)\nINF=10**18\nMOD=10**9+7\ninput=lambda: sys.stdin.readline().rstrip()\nYesNo=lambda b: bool([print('Yes')] if b else print('No'))\nYESNO=lambda b: bool([print('YES')] if b else print('NO'))\nint1=lambda x:int(x)-1\nfrom itertools import permutations\nfrom bisect import bisect_left,bisect_right\n\nN,M=map(int,input().split())\nw=tuple(map(int,input().split()))\nMAX_W=max(w)\nlv=[() for _ in range(M)]\nfor i in range(M):\n    l,v=map(int,input().split())\n    lv[i]=(l,v)\n    if v<MAX_W:\n        print(-1)\n        return\nlv.sort(key=lambda a: (a[1],-a[0]))\nL,V=[],[]\ntmp_l=0\nfor l,v in lv:\n    if tmp_l<l:\n        tmp_l=l\n        L.append(l)\n        V.append(v)\nans=INF\nfor tmp_w in permutations(w):\n    edge=[[] for _ in range(N)]\n    S=[0]*(N+1)\n    for i in range(N):\n        S[i+1]=S[i]+tmp_w[i]\n    for i in range(N-1):\n        for j in range(i+1,N):\n            SUM=S[j+1]-S[i]\n            res=bisect_left(V,SUM)\n            if res>0:\n                edge[i].append((j,L[res-1]))\n            else:\n                edge[i].append((j,0))\n    dp=[0]*N\n    for i in range(N):\n        for j,l in edge[i]:\n            dp[j]=max(dp[j],dp[i]+l)\n    ans=min(ans,dp[-1])\nprint(ans)", "import itertools\nimport bisect\n\nN, M = [int(n) for n in input().split()]\nW = [int(n) for n in input().split()]\nbridges = [[int(n) for n in input().split()] for _ in range(M)] # [length_i, load_limit_i] \n\n# sort by load limit\nbridges.sort(key=lambda x: x[1])\n\nlimits = [v for l, v in bridges]\nlen_rm = list(itertools.accumulate([l for l, v in bridges], max)) # running maximum\n# len_rm[i]: the maximum length of the bridges whose load limit <= limits[i]\n\nans = -1\nif max(W) <= min(limits):\n    # precompute mapping\n    # from: (sum of) weights, (w)\n    # to: maximum part length (x) whose load limit <= w\n    w2x = dict()\n    for F in itertools.product([0, 1], repeat=N):\n        w = sum([w for w, f in zip(W, F) if f == 1])\n        if w in w2x:\n            continue        \n        idx = bisect.bisect_left(limits, w)\n        w2x[w] = 0 if idx == 0 else len_rm[idx-1]\n    \n    ans = 1000000000 # larger than maximum possible solution (7 x 10^8)\n    for W_perm in itertools.permutations(W):\n        lengths = [0 for _ in range(N)]\n        for i in range(N):\n            w_ij = W_perm[i]\n            for j in range(i+1, N):\n                w_ij += W_perm[j] # w_ij: total weight between i and j (inclusive)\n                lengths[j] = max(lengths[j], lengths[i] + w2x[w_ij])\n\n                # skipping trivial edges\n                # even without this if-block, we can get AC\n                if w_ij > limits[-1]:\n                    break\n            \n        candidate = lengths[-1]\n        ans = min(ans, candidate)\n\nprint(ans)\n", "#n<=8\nn,m=map(int, input().split())\n*w,=map(int, input().split())\n\nllvv=[tuple(map(int,input().split())) for _ in range(m)]\nww=max(w)\nvv=min(x[1] for x in llvv)###\nif ww>vv:\n    print(-1)\n    return\n\nllvv.sort(key=lambda x:x[1])\n\nv=[0]+[vi for li,vi in llvv]\nl=[0]+[li for li,vi in llvv]\nfor i in range(m):\n    l[i+1]=max(l[i],l[i+1])\n\nINF=10**15\n\nfrom itertools import permutations\nfrom bisect import bisect_left\nans=INF\nfor p in permutations(range(n)):\n    dist=[0 for _ in range(n)]\n    for i in range(n):\n        tmp=w[p[i]]\n        for j in range(i+1,n):\n            tmp+=w[p[j]]\n            t=bisect_left(v,tmp)\n            if t:\n                dist[j]=max(dist[j],dist[i]+l[t-1])\n            else:\n                dist[j]=max(dist[j],dist[i])\n    ans=min(ans,dist[-1])\nprint(ans)", "from itertools import permutations\nfrom functools import lru_cache\nN,M=map(int,input().strip().split())\nweights=list(map(int,input().strip().split()))\nc=[]\nmin_weight=float(\"inf\")\nfor _ in range(M):\n    l, v = map(int, input().strip().split())\n    min_weight=min(v,min_weight)\n    c.append([l,v])\n\nif min_weight<max(weights):  # we can never pas\n    print(\"-1\")\nelse:\n    min_weight = float(\"inf\")\n    c.sort()\n    for i in range(M-1,-1,-1):\n        min_weight=min(min_weight,c[i][1])\n        c[i][1]=min_weight\n\n    @lru_cache(None)\n    def bisect(val):\n        l,r=0,M-1\n        while l<=r:\n            mid=(l+r)//2\n            if c[mid][1]<val:\n                l=mid+1\n            else:\n                r=mid-1\n        return c[r][0] if r>=0 else 0\n\n    def compute(sequence):\n        dp=[0]*(N+1)\n        prefix_sum=[0]\n        for i in sequence:\n            prefix_sum.append(prefix_sum[-1]+weights[i])\n        for i in range(2,N+1):\n            for j in range(1,i):\n                dp[i]=max(dp[i],dp[j]+bisect(prefix_sum[i]-prefix_sum[j-1]))\n        return dp[-1]\n    base=list(range(N))\n    print(min(map(compute,permutations(base))))", "from itertools import permutations\nfrom itertools import accumulate\nfrom bisect import bisect_left, bisect_right\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    INF = 10**15\n\n    N, M = list(map(int, input().split()))\n    Ws = list(map(int, input().split()))\n    LVs = [tuple(map(int, input().split())) for _ in range(M)]\n\n    minV = min([V for L, V in LVs])\n    LVs.sort(key=lambda x: x[1])\n    bdrLs, bdrVs = [0], [0]\n    maxL = 0\n    for L, V in LVs:\n        if L > maxL:\n            bdrLs.append(L)\n            bdrVs.append(V)\n            maxL = L\n\n    ans = INF\n    for Camels in permutations(Ws, N):\n        accCamels = [0]+list(accumulate(Camels))\n        Lss = [[INF]*(N) for _ in range(N)]\n        for i in range(N):\n            if Camels[i] > minV:\n                Lss[i][i] = INF\n            else:\n                Lss[i][i] = 0\n            for j in range(i+1, N):\n                wgt = accCamels[j+1] - accCamels[i]\n                iV = bisect_left(bdrVs, wgt) - 1\n                Lss[i][j] = bdrLs[iV]\n\n        costs = [0] * N\n        for i in range(1, N):\n            cost = 0\n            for j in range(i+1):\n                c2 = costs[j] + Lss[j][i]\n                if c2 > cost:\n                    cost = c2\n            costs[i] = cost\n\n        if costs[-1] < ans:\n            ans = costs[-1]\n\n    if ans == INF:\n        print((-1))\n    else:\n        print(ans)\n\n\nsolve()\n", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nimport itertools,bisect\nn,m = inm()\nw = inl()\nvl = []\nvs = []\nfor i in range(m):\n    l,v = inm()\n    vl.append((v,l))\n    vs.append(v)\nif max(w)>min(vs):\n    print(-1)\n    return\nw.sort()\n\nvl.sort()\nb = []\nmx = -1\nfor i in range(m):\n    mx = max(mx,vl[i][1])\n    if len(b)>0 and b[-1][0]==vl[i][0]:\n        b.pop()\n    b.append((vl[i][0],mx))\n\npms = itertools.permutations(w[:-2],n-2)\nmn = BIG\nfor pm in pms:\n    pml = list(pm)\n    pml.append(w[n-2])\n    a = [0]\n    ww = [w[n-1]]\n    for i in range(n-1):\n        x = a[-1]\n        u = pml[i]\n        for k in range(i,-1,-1):\n            u += ww[k]\n            p = bisect.bisect_left(b,(u,-1))\n            if p>0 and b[p-1][1]>x-a[k]:\n                    #ddprint(f\"add l {j=} {k=} {l=} {u=} {v=}\")\n                    x = a[k]+b[p-1][1]\n        a.append(x)\n        ww.append(pml[i])\n    #ddprint(pml)\n    #ddprint(a)\n    mn = min(mn,a[-1])\nprint(mn)\n", "import itertools\nimport bisect\n\nN, M = [int(n) for n in input().split()]\nW = [int(n) for n in input().split()]\nbridges = [[int(n) for n in input().split()] for _ in range(M)] # [length_i, weight_i] \n\n# sort by weight\nbridges.sort(key=lambda x: x[1])\n\nlimits = [v for l, v in bridges]\nlen_rm = list(itertools.accumulate([l for l, v in bridges], max)) # running maximum\n# len_rm[i]: the maximum length of the bridges whose load limit <= limits[i]\n\nans = -1\nif max(W) <= min(limits):\n    ans = 1000000000 # larger than maximum possible solution (7 x 10^8)\n    for W_perm in itertools.permutations(W):\n        lengths = [0 for _ in range(N)]\n        for i in range(N):\n            w_ij = W_perm[i]\n            for j in range(i+1, N):\n                w_ij += W_perm[j] # w_ij: total weight between i and j (inclusive)\n                idx = bisect.bisect_left(limits, w_ij)\n                if idx == 0: # all bridge accepts w_ij\n                    x_ij = 0\n                else: # bridges[0] ... bridges[i-1] cannot accept w_ij\n                    x_ij = len_rm[idx-1]\n                lengths[j] = max(lengths[j], lengths[i] + x_ij)\n\n                # skipping trivial edges\n                # even without this if-block, we can get AC\n                if idx == M:\n                    break\n            \n        candidate = lengths[-1]\n        ans = min(ans, candidate)\n\nprint(ans)\n"]
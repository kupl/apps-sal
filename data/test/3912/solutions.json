["#!/usr/bin/env python3\n\ndef main():\n    import collections\n\n    n = int(input())\n    s = input()\n    alph = collections.Counter(s)\n    odd = sum(x & 0x1 for x in alph.values())\n    dq = collections.deque()\n    if odd == 0:\n        print(1)\n        for c, x in alph.items():\n            dq.append(c * (x >> 1))\n            dq.appendleft(c * (x >> 1))\n        print(*dq, sep=\"\")\n    else:\n        for odd in range(odd, n):\n            if (n - odd) % (odd << 1) == 0:\n                print(odd)\n                odds = [c for c, x in alph.items() if x & 0x1]\n                items = list(alph.items())\n                while len(odds) != odd:\n                    for i, x in enumerate(items):\n                        if x[1] > 1:\n                            items[i] = (x[0], x[1] - 2)\n                            odds.append(x[0])\n                            odds.append(x[0])\n                            break\n                req_length = (n - odd) // odd + 1\n                cur_length = 0\n                while odd > 0:\n                    if cur_length == 0:\n                        dq.append(odds[-1])\n                        cur_length += 1\n                        odds.pop()\n                    x = min(items[-1][1] >> 1, (req_length - cur_length) >> 1)\n                    dq.append(items[-1][0] * x)\n                    dq.appendleft(items[-1][0] * x)\n                    cur_length += x << 1\n                    if items[-1][1] - (x << 1) <= 1:\n                        items.pop()\n                    else:\n                        items[-1] = (items[-1][0], items[-1][1] - (x << 1))\n                    if cur_length == req_length:\n                        print(*dq, sep=\"\", end=' ')\n                        odd -= 1\n                        dq.clear()\n                        cur_length = 0\n                print()\n                break\n        else:\n            print(n)\n            print(*s)\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2017/10/22 18:15\n\n\"\"\"\n\nN = int(input())\nS = input()\n\ndef split(s, wc, pl, n):\n\n    ans = []\n\n    if pl % 2 == 0:\n        if any([x % 2 == 1 for x in list(wc.values())]):\n            return []\n        for i in range(0, len(s), pl):\n            t = s[i:i + pl]\n            ans.append(t[::2] + t[::-1][::2])\n\n        return ans\n\n    mid = [w for w, c in list(wc.items()) if c % 2 == 1]\n\n    if len(mid) > n:\n        return []\n\n    midindex = 0\n    while len(ans) < n:\n        t = ''\n        u = mid[midindex] if midindex < len(mid) else ''\n        midindex += 1\n        if not u:\n            u = list([w for w, c in list(wc.items()) if c > 0])[0]\n        wc[u] -= 1\n\n        need = pl-1\n        while need > 0:\n            pneed = need\n            for w, c in [(w, c) for w, c in list(wc.items())]:\n                if c > need:\n                    t += str(w) * (need//2)\n                    wc[w] -= need\n                    need = 0\n                    break\n                elif c > 1:\n                    c //= 2\n                    t += str(w) * c\n                    wc[w] -= c * 2\n                    need -= c*2\n            if need == pneed:\n                return []\n        t = t + u + t[::-1]\n        if len(t) < pl:\n            return []\n        ans.append(t)\n\n    return ans\n\n\n\n\nS = \"\".join(sorted(list(S)))\nWC = collections.Counter(S)\n\nfor parts in range(1, N+1):\n    if N % parts == 0:\n        wc = {k: v for k, v in list(WC.items())}\n        ans = split(S, wc, N//parts, parts)\n        if ans:\n            print(parts)\n            print(\" \".join(ans))\n            return\n", "from collections import Counter\nn = int(input())\ncnt = Counter(input())\nodd = []\neven = []\nfor s, c in cnt.items():\n  if c % 2 == 1:\n    odd.append([s, c])\n  else:\n    even.append([s, c])\nk = max(1, len(odd))\nfor i in range(k, n + 1):\n  h = n // i\n  if i * h == n and (not odd and h % 2 == 0 or odd and h % 2 == 1):\n    k = i\n    break\nh = n // k\nres = []\nwhile len(res) < k:\n  if odd:\n    s, c = odd.pop()\n    res.append(s)\n    c -= 1\n    if c:\n      even.append([s, c])\n  elif h % 2:\n    res.append(even[0][0])\n    res.append(even[0][0])\n    even[0][1] -= 2\n    if not even[0][1]:\n      even.pop(0)\n  else:\n    res.append('')\nfor i in range(k):\n  s = res[i]\n  while len(s) < h:\n    t = (h - len(s)) // 2\n    a, c = even[0]\n    if c <= 2 * t:\n      c //= 2\n      s = a*c + s + a*c\n      even.pop(0)\n    else:\n      s = a*t + s + a*t\n      even[0][1] -= 2 * t\n  res[i] = s\n\nprint(len(res))\nprint(' '.join(res))", "n = int(input())\nstring = input()\nchar = []\ncharPair = []\ncharImpair = []\nfor car in string:\n\tif car not in char:\n\t\tz = string.count(car)\n\t\twhile z>1:\n\t\t\tcharPair.append(car)\n\t\t\tz-=2\n\t\tif(z==1):\n\t\t\tcharImpair.append(car)\n\t\tchar.append(car)\nif len(charImpair) ==0 :\n\tString1 = ''\n\tfor x in charPair:\n\t\tString1+= x\n\tif len(charImpair) ==1 :\n\t\tString1 += charImpair[0]\n\tfor x in charPair[::-1]:\n\t\tString1 += x\n\tprint('1')\n\tprint(String1)\nelse :\n\tnbPalin = len(charImpair)\n\twhile len(charPair)%nbPalin != 0 : \n\t\tnbPalin += 2\n\t\tcharImpair.append(charPair[-1])\n\t\tcharImpair.append(charPair[-1])\n\t\tdel(charPair[-1])\n\tlenPalindrome = n/nbPalin\n\tPalin = []\n\tfor i in range(nbPalin):\n\t\tString2 = ''\n\t\tindice = i * int(((lenPalindrome-1)/2))\n\t\tfor x in charPair[indice : int(indice + ((lenPalindrome-1)/2))]:\n\t\t\tString2 += x\n\t\tString2 += charImpair[i]\n\t\tfor x in range(indice + int(((lenPalindrome-1)/2))-1, indice-1 ,-1):   #   charPair[i + int(((lenPalindrome-1)/2))-1: i-1 :-1]:\n\t\t\tString2 += charPair[x]\t\n\t\tPalin.append(String2)\n\t\t\n\tprint(nbPalin)\n\tString3 = ' '.join(Palin)\n\tprint(String3)\n\n", "n = int(input())\ns = input()\nd = {}\nfor c in s:\n    if c not in d:\n        d[c] = 0\n    d[c] += 1\nodd = []\nsum = 0\nfor key in d:\n    if d[key] % 2 == 1:\n        odd.append(key)\n        d[key] -= 1\n    sum += d[key]\n\nif sum // 2 < len(odd):\n    print(len(s))\n    for c in s:\n        print(c+' ', end='')\n    return\nwhile True:\n    if len(odd) == 0 or (sum // 2) % len(odd) == 0:\n        break\n    sum -= 2\n    if sum // 2 < len(odd):\n        print(len(s))\n        for c in s:\n            print(c + ' ', end='')\n        return\n    for key in d:\n        odd.append(key)\n        odd.append(key)\n        d[key] -= 2\n        if d[key] == 0:\n            d.pop(key, None)\n        break\nif len(odd) == 0:\n    odd.append('')\neven = []\nfor key in d:\n    even += [key] * (d[key] // 2)\nl = (sum // 2) // len(odd)\nprint(len(odd))\nfor i in range(len(odd)):\n    s = odd[i]\n    for j in range(i * l, (i + 1) * l):\n        s = even[j] + s + even[j]\n    print(s + ' ', end='')\n", "from collections import Counter\n\nn = int(input())\ninp = input()\n\nc = Counter(inp)\n\nt = len(list([x for x in list(c.values()) if x % 2 == 1]))\n\nif t == 0:\n    temp = sum([[list(c.items())[j][0]] * (list(c.items())[j][1] // 2) for j in range(len(list(c.items())))], [])\n\n    print(1)\n    print(''.join(temp) + ''.join(temp[::-1]))\n\nelse:\n    ones = list()\n    for j in range(len(list(c.items()))):\n        i = list(c.items())[j]\n        if i[1] % 2 == 1:\n            c[list(c.keys())[j]] -= 1\n            ones.append(i[0])\n\n    others = sum([[list(c.items())[j][0]] * (list(c.items())[j][1] // 2) for j in range(len(list(c.items())))], [])\n\n    while n % t != 0 or n // t % 2 == 0:\n        t += 2\n        o = others.pop()\n        ones.append(o)\n        ones.append(o)\n    L = n // t\n\n    ans = list()\n    ot = 0\n    for i in range(t):\n        mid = str()\n        if L % 2 == 1:\n            mid = ones[i]\n        ln = L // 2\n        ans.append(''.join(others[ot: ot + ln]) + mid + ''.join(others[ot: ot + ln][::-1]))\n        ot += ln\n\n\n    print(t)\n    print(' '.join(ans))\n", "from collections import Counter\n\nn = int(input())\ninp = input()\n\nc = Counter(inp)\n\nt = len(list([x for x in list(c.values()) if x % 2 == 1]))\n\nif t == 0:\n    temp = sum([[list(c.items())[j][0]] * (list(c.items())[j][1] // 2) for j in range(len(list(c.items())))], [])\n\n    print(1)\n    print(''.join(temp) + ''.join(temp[::-1]))\n\nelse:\n    ones = list()\n    for j in range(len(list(c.items()))):\n        i = list(c.items())[j]\n        if i[1] % 2 == 1:\n            c[list(c.keys())[j]] -= 1\n            ones.append(i[0])\n\n    others = sum([[list(c.items())[j][0]] * (list(c.items())[j][1] // 2) for j in range(len(list(c.items())))], [])\n\n    while n % t != 0 or n // t % 2 == 0:\n        t += 2\n        o = others.pop()\n        ones.append(o)\n        ones.append(o)\n    L = n // t\n\n    ans = list()\n    ot = 0\n    for i in range(t):\n        mid = str()\n        if L % 2 == 1:\n            mid = ones[i]\n        ln = L // 2\n        ans.append(''.join(others[ot: ot + ln]) + mid + ''.join(others[ot: ot + ln][::-1]))\n        ot += ln\n\n\n    print(t)\n    print(' '.join(ans))\n", "import sys\nfrom collections import Counter\n\n\ndef gen(counter, skip):\n    for c, n in counter:\n        has = n // 2\n        if skip > has:\n            skip -= has\n            has = 0\n        elif skip > 0:\n            has -= skip\n            skip = 0\n        for i in range(has):\n            yield c\n\n\ndef gen_o(counter, take):\n    for c, n in counter:\n        for i in range(n % 2):\n            yield c\n    for c, n in counter:\n        has = (n // 2) * 2\n        if take > has:\n            take -= has\n        elif take > 0:\n            has = take\n            take = 0\n        for i in range(has):\n            yield c\n\n\nN = int(next(sys.stdin))\n\ns = next(sys.stdin).strip()\nc = Counter(s)\n\neven = 0\nodd = 0\nitems = list(c.items())\nfor _, n in items:\n    even += n // 2\n    odd += n % 2\ngenerator = gen(items, 0)\ngenerator_o = gen_o(items, 0)\n\nodd_c = odd\nif odd == 0:\n    print(1)\n    front = [next(generator) for i in range(len(s) // 2)]\n    fs = \"\".join(front)\n    print(fs + fs[::-1])\nelse:\n    skip = 0\n    while even != 0 and even % odd != 0:\n        skip += 1\n        odd += 2\n        even -= 1\n    generator = gen(items, skip)\n    generator_o = gen_o(items, skip * 2)\n    print(odd)\n    per = even // odd\n    strs = []\n    for i in range(odd):\n        front = [next(generator) for i in range(per)]\n        fs = \"\".join(front)\n        strs.append(fs + next(generator_o) + fs[::-1])\n    print(\" \".join(strs))\n", "n = int(input())\ns = list(input())\nd = {}\nfor char in s:\n    if char not in list(d.keys()):\n        d[char] = 1\n    else:\n        d[char] += 1\n\nodd = []\neven = []\nfor char in list(d.keys()):\n    for i in range(d[char] // 2):\n        even.append(char)\n        even.append(char)\n    for i in range(d[char] % 2):\n        odd.append(char)\n# print(len(even), len(odd))\nif len(odd) <= 1:\n    x = ''.join([even[i] for i in range(1, len(even), 2)])\n    y = ''.join(odd)\n    print(1)\n    print(x + y + x[::-1])\nelif len(even) % len(odd) == 0 and (len(even) // len(odd)) % 2 == 0 and (len(even) // len(odd)) > 0:\n    print(len(odd))\n    x = []\n    ratio = len(even) // len(odd)\n    indx = 0\n    for i in range(len(odd)):\n        tail = ''\n        while len(tail) < ratio // 2:\n            tail += even[indx]\n            indx += 2\n        x.append(tail + odd[i] + tail[::-1])\n    print(' '.join(x))\nelse:\n    ratio = len(even)//len(odd)\n    max_length = 1\n    for i in range(1,ratio+1,2):\n        if (len(even)+len(odd)) % i == 0 and max_length < i:\n            max_length = i\n    parts = (len(even) + len(odd))//max_length\n    print(parts)\n    x = []\n    indx = 0\n    for i in range(len(odd)):\n        tail = ''\n        while len(tail) < max_length // 2:\n            tail += even[indx]\n            indx += 2\n        x.append(tail + odd[i] + tail[::-1])\n    middle = []\n    for i in range(parts - len(odd)):\n        middle.append(even.pop())\n    for i in range(len(middle)):\n        tail = ''\n        while len(tail) < max_length // 2:\n            tail += even[indx]\n            indx += 2\n        x.append(tail + middle[i] + tail[::-1])\n    print(' '.join(x))\n", "n = int(input())\ns = list(input())\nd = {}\nfor char in s:\n    if char not in d.keys():\n        d[char] = 1\n    else:\n        d[char] += 1\n\nodd = []\neven = []\nfor char in d.keys():\n    for i in range(d[char] // 2):\n        even.append(char)\n        even.append(char)\n    for i in range(d[char] % 2):\n        odd.append(char)\n\nif len(odd) <= 1:\n    x = ''.join([even[i] for i in range(1, len(even), 2)])\n    y = ''.join(odd)\n    print(1)\n    print(x + y + x[::-1])\n\nelse:\n    ratio = len(even)//len(odd)\n    max_length = 1\n    for i in range(1,ratio+2,2):\n        if n % i == 0 and max_length < i:\n            max_length = i\n    parts = n//max_length\n    print(parts)\n    x = []\n    indx = 0\n    for i in range(len(odd)):\n        tail = ''\n        while len(tail) < max_length // 2:\n            tail += even[indx]\n            indx += 2\n        x.append(tail + odd[i] + tail[::-1])\n    middle = []\n    for i in range(parts - len(odd)):\n        middle.append(even.pop())\n    for i in range(len(middle)):\n        tail = ''\n        while len(tail) < max_length // 2:\n            tail += even[indx]\n            indx += 2\n        x.append(tail + middle[i] + tail[::-1])\n    print(' '.join(x))", "mp,a,p={},[],[]\nn=int(input())\nfor i in input():\n    if i in mp:mp[i]+=1\n    else:mp[i]=1\nodd=0\nfor i in mp:\n    if mp[i]&1:\n        a.append(i)\n        mp[i]-=1\n        odd+=1\n    if mp[i]:\n        p.append(i)\nm=max(1,odd)\nfor i in range(m,n+1):\n    if not n%i:\n        d=n//i\n        if odd and not d&1:continue\n        print(i)\n        for K in range(i-m):\n            a.append(p[-1])\n            if mp[p[-1]]>1:mp[p[-1]]-=1\n            else:p.pop()\n        for k in range(i):\n            s=''\n            for j in range(d//2):\n                s+=p[-1]\n                mp[p[-1]]-=2\n                if not mp[p[-1]]:p.pop()\n            if odd:print(s+a.pop()+s[::-1],end=' ')\n            else:print(s+s[::-1],end=' ')\n        return", "n=int(input())\ns=list(input())\nlets={}\nfor i in s:\n    try:\n        lets[i]+=1\n    except:\n        lets[i]=1\ncount=0\ncentre=[]\nrest=[]\nfor i in lets.keys():\n    if(lets[i]%2):\n        centre.append(i)\n        count+=1\n    rest+=[i]*(lets[i]//2)\nif(count==0):\n    t=''\n    for i in lets.keys():\n        t=i*(lets[i]//2) + t + i*(lets[i]//2)\n    print(1)\n    print(t)\n\nelse:\n    extra=0\n    while(n%count!=0 or (n//count)%2==0):\n        count+=2\n        extra+=1\n    for i in range(extra):\n        centre+=[rest.pop()]*2\n    amt=len(rest)//(count)\n    temp=rest.copy()\n    rest=''\n    for i in temp:\n        rest+=i\n    print(count)\n    print(rest[0:amt] + centre[0] + rest[(1)*(amt)-1::-1],end=' ')\n    for i in range(1,count):\n        print(rest[i*(amt):(i+1)*amt] + centre[i] + rest[(i+1)*(amt)-1:(i)*amt-1:-1],end=' ')\n    print()", "mp,a,p={},[],[]\nn=int(input())\nfor i in input():\n    if i in mp:mp[i]+=1\n    else:mp[i]=1\nodd=0\nfor i in mp:\n    if mp[i]&1:\n        a.append(i)\n        mp[i]-=1\n        odd+=1\n    if mp[i]:\n        p.append(i)\nm=max(1,odd)\nfor i in range(m,n+1):\n    if not n%i:\n        d=n//i\n        if odd and not d&1:continue\n        print(i)\n        for K in range(i-m):\n            a.append(p[-1])\n            if mp[p[-1]]>1:mp[p[-1]]-=1\n            else:p.pop()\n        for k in range(i):\n            s=''\n            for j in range(d//2):\n                s+=p[-1]\n                mp[p[-1]]-=2\n                if not mp[p[-1]]:p.pop()\n            if odd:print(s+a.pop()+s[::-1],end=' ')\n            else:print(s+s[::-1],end=' ')\n        return", "import sys\nimport math\nfrom collections import defaultdict,deque\ndef is_possible(odd,even):\n\teach = odd*2\n\tif even % each == 0:\n\t\treturn True\n\treturn False\nn=int(sys.stdin.readline())\ns=sys.stdin.readline()[:-1]\ndic=defaultdict(int)\nfor i in range(n):\n\tdic[s[i]]+=1\nodd,even = 0,0\nfor i in dic:\n\tif dic[i]%2 != 0:\n\t\todd += 1\n\t\teven += dic[i] - 1\n\telse:\n\t\teven += dic[i]\nif odd == 0:\n\t#print(0)\n\tans = [0 for x in range(even)]\n\tcnt = 0\n\tfor i in dic:\n\t\twhile dic[i] > 0:\n\t\t\tans[cnt] = i\n\t\t\tans[even - cnt - 1] = i\n\t\t\tcnt += 1\n\t\t\tdic[i] -= 2\n\t#print(ans)\n\tprint(1)\n\tprint(''.join(x for x in ans))\n\treturn\nwhile even >= 0:\n\tif is_possible(odd,even):\n\t\tbreak\n\todd += 2\n\teven -= 2\nlength = 1 + (even) // (odd)\n#print(length, 'length')\nans = [deque() for _ in range(odd)]\nansb = [[] for _ in range(odd)]\nansa = [[] for _ in range(odd)]\ncnt = 0\n#print(dic,'dic')\nfor i in dic:\n\tif dic[i] % 2 !=0:\n\t\tans[cnt].append(i)\n\t\tdic[i] -= 1\n\t\tcnt += 1\n#print()\n#print(ans,' after odd',cnt)\nfor i in dic:\n\twhile dic[i] > 0:\n\t\tif cnt >= odd:\n\t\t\tbreak\n\t\tans[cnt].append(i)\n\t\tans[cnt + 1].append(i)\n\t\tcnt += 2\n\t\tdic[i] -= 2\n\tif cnt >= odd:\n\t\tbreak\ncnt = 0\n#print(ans,'ans')\nfor i in dic:\n\t#print(cnt,'cnt',i,'i')\n\t#print(ans[cnt])\n\tif dic[i] > 0:\n\t\tx = len(ans[cnt])\n\t\twhile dic[i] > 0:\n\t\t\tans[cnt].appendleft(i)\n\t\t\tans[cnt].append(i)\n\t\t\t#ans[cnt] = [i] + ans[cnt] + [i]\n\t\t\tdic[i] -= 2\n\t\t\tx += 2\n\t\t\tif x < length:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tcnt += 1\n\t\t\t\tif cnt < odd:\n\t\t\t\t\tx = len(ans[cnt])\n#print(ans,'ans')\n#print(odd,'odd')\nn = len(ans)\n#print(n)\nl =[]\nfor i in range(n):\n\tl.append(''.join(x for x in ans[i]))\nprint(n)\nprint(*l)"]
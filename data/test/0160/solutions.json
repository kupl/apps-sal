["# \u5272\u308a\u5207\u308b\u6570\u306f\u3001A\u306e\u7dcf\u548c\u306e\u7d04\u6570\u3067\u3042\u308b\n# \u81ea\u5206\u81ea\u8eab\u3092\u9664\u304f\u7d04\u6570\u306b\u3064\u3044\u3066\u5927\u304d\u3044\u9806\u306b\u3059\u3079\u3066\u8a66\u3057\u3066\u3001\u5f53\u3066\u306f\u307e\u308b\u3082\u306e\u304c\u3042\u308c\u3070\u7b54\u3048\n\n# 8,20\u30927\u306e\u500d\u6570\u306b\u8fd1\u3065\u3051\u308b\u3068\u304d\u3001\n# 8 -> mod 7\u304c1\u3067\u3042\u308a\u3001-1\u304b+6\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n# 20 -> mod 7\u304c6\u3067\u3042\u308a\u3001-6\u304b+1\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n# -1\u3068+1\u3092\u30da\u30a2\u306b\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u3066\u3001\u3053\u306e\u64cd\u4f5c\u56de\u65701\u3092K = 3\u304b\u3089\u5f15\u304f\u30682\u3068\u306a\u308a\u3001\u3053\u308c\u304c\u5076\u6570\u306a\u3089OK\n\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nA = list(map(int,readline().split()))\n\nall = sum(A)\ndivisors = []\nfor i in range(1,int(all ** 0.5) + 1):\n  if all % i == 0:\n    divisors.append(i)\n    divisors.append(all // i)\n\ndivisors = sorted(divisors,reverse = True)\n\n#print(divisors)\n\nfor d in divisors:\n  mods = [0] * (N)\n  for i in range(len(A)):\n    mods[i] = A[i] % d\n  mods = sorted(mods)\n  #print(\"d\",d,\"mods\",mods)\n  mods_front = [0] * N\n  mods_front[0] = mods[0]\n  for i in range(1,N):\n    mods_front[i] = mods_front[i - 1] + mods[i]\n  mods_back = [0] * N\n  mods_back[-1] = d - mods[-1]\n  #print(\"mods_front\",mods_front)\n  for i in range(N - 2,-1,-1):\n    mods_back[i] = mods_back[i + 1] + (d - mods[i])\n  #print(\"mods_back\",mods_back)\n  for i in range(N - 1):\n    if mods_front[i] == mods_back[i + 1]:\n      if K >= min(mods_front[i],mods_back[i + 1]):\n        print(d)\n        return\nelse:\n  print(1)", "from math import sqrt\n\ndef Divisor_Set(n):\n    s = set()\n    for i in range(1, int(sqrt(n))+2):\n        if n%i == 0:\n            s.add(i)\n            s.add(n//i)\n    return s\n\ndef main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a_sum = sum(a)\n    st = Divisor_Set(a_sum)\n    ans = 1\n    st.remove(1)\n    for v in st:\n        b = [x%v for x in a]\n        b.sort()\n        for i in range(n-1):\n            b[i+1] += b[i]\n        for i in range(n-1):\n            if b[i] == v*(n-i-1) - (b[-1] - b[i]):\n                if b[i] <= k and ans < v:\n                    ans = v\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\ns = sum(A)\n\n\n\ndef solve():\n    ans = 1\n    idx = 1\n\n    while idx * idx <= s:\n        if s % idx == 0:\n            if ok(s // idx):\n                return s // idx\n            if ok(idx):\n                ans = idx\n        idx += 1\n\n    return ans\n\n\ndef ok(i):\n    D = list([x for x in [a % i for a in A] if x != 0])\n    D.sort()\n\n    l = len(D)\n\n    S = [0] * (l + 1)\n    for j in range(l):\n        S[j + 1] = S[j] + D[j]\n\n    for j in range(l):\n        if S[j] == i * (l - j) - (S[l] - S[j]) and S[j] <= K:\n            return True\n\n    return False\n\n\nprint((solve()))\n", "def main():\n    N,K,*A=map(int, open(0).read().split())\n    S=sum(A)\n    X=[S]\n    for i in range(2,int(S**.5)+1):\n        if S%i==0:\n            X.append(i)\n            if i*i!=S:\n                X.append(S//i)\n    ans=1\n    for x in X:\n        B=[a%x for a in A]\n        y=sum(B)//x\n        z=sum(sorted(B, reverse=True)[y:])\n        if z<=K:\n            ans=max(ans,x)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "def divisor(n):\n    res = []\n    i = 1\n    while i*i <= n:\n        if n%i == 0:\n            res.append(i)\n            if i*i != n:\n                res.append(n//i)\n        i += 1\n    res.sort()\n    return res\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nS = sum(A)\nans = 1\nfor d in divisor(S):\n    rs = [a%d for a in A]\n    rs.sort()\n    Sum = [0]*(N+1)\n    Sum2 = [0]*(N+1)\n    for i in range(1,N+1):\n        Sum[i] = Sum[i-1]+rs[i-1]\n        Sum2[i] = Sum2[i-1]+(d-rs[i-1])\n    for i in range(N+1):\n        if Sum[i] == Sum2[N]-Sum2[i]:\n            if Sum[i] <= K:\n                ans = d\nprint(ans)\n", "def max2(x,y):\n    return x if x > y else y\n\ndef divisors(n):\n    i = 1\n    table = set()\n    while i * i <= n:\n        if not n % i:\n            table.add(i)\n            table.add(n//i)\n        i += 1\n    table = list(table)\n    return table\n\nimport sys\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nS = sum(A)\nD = divisors(S)\nD.sort()\nres = 0\nfor k in D:\n    B = []\n    for a in A:\n        B.append(a%k)\n    B.sort()\n    cnt = sum(B)//k\n    if k*cnt - sum(B[-cnt:]) <= K:\n        res = max2(res, k)\n\nprint(res)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nA = np.array(lr())\nsum = A.sum()\n# Ai\u304c1\u4ee5\u4e0a\u306e\u305f\u3081\u3001answer\u306fsum\u306e\u7d04\u6570\n\ndef make_divisors(n): # n\u306e\u7d04\u6570\u3092\u5217\u6319\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    return divisors\n\nB = make_divisors(sum)\n\nfor x in B[::-1]:\n    c = A % x\n    c.sort()\n    d = x - c\n    c_cum = c.cumsum()\n    d_cum = d.cumsum()\n    \n    for i in range(N):\n        y = c_cum[i]\n        z = d_cum[N-1] - d_cum[i]\n        if y > K or z > K:\n            continue\n        result = (y + z) // 2\n        if result <= K:\n            print(x)\n            return\n", "from copy import copy, deepcopy\n# from functools import reduce\n# from heapq import heapify, heappop, heappush\n# from itertools import accumulate, permutations, combinations, combinations_with_replacement, groupby, product\nimport unittest\nfrom io import StringIO\nimport math\n# import numpy as np  # Python\u306e\u307f\uff01\n# from operator import xor\n# import re\n# from scipy.sparse.csgraph import connected_components  # Python\u306e\u307f\uff01\n# \u2191cf.  https://note.nkmk.me/python-scipy-connected-components/\n# from scipy.sparse import csr_matrix\n# import string\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\n\n\ndef input(): return sys.stdin.readline().strip()\n\n\ndef resolve():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    def make_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5)+1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:  # \u5e73\u65b9\u6570\u306e\u5834\u5408n**0.5\u30921\u3064\u3060\u3051\u306b\u3057\u3066\u308b\n                    divisors.append(n//i)\n\n        divisors.sort(reverse=True)  # \u30bd\u30fc\u30c8\u3057\u305f\u3051\u308a\u3083\u3057\u3066\n        return divisors\n\n    M = make_divisors(sum(A))\n\n    def main():\n        for i in M:\n            AA = [0]*N\n            age = 0\n            # delete = 0\n            for j in range(N):\n                AA[j] = A[j] % i\n                #if AA[j] == 0:\n                    # delete += 1\n                    # age -= i\n                age += i-AA[j]\n            AA.sort()\n\n            times = 10**9\n            sage = 0\n            for j in range(0,N-1):\n                sage += AA[j]\n                age -= i-AA[j]\n                if sage % i == age % i:\n                    times = min(max(sage, age), times)\n            if times <= K:\n                return i\n    print(main())\n\nresolve()", "import sys\nimport math\nimport heapq\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef II(): return int(input())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\ndef gcd(x, y):\n    if x < y: x, y = y, x\n    div = x % y\n    while div != 0:\n        x, y = y, div\n        div = x % y\n    return y\n\nN,K=LI()\nAS=LI()\nSUMM= sum(AS)\n\nDIVS=set()\nfor i in range(1,40000):\n    if SUMM % i == 0:\n        DIVS.add(i)\n        DIVS.add(SUMM//i)\n# DIVS.sort(reversed=True)\n# print(DIVS)\n\nDIFF=[0]*N\nACC=[0]*N\n\n# res = 0\n\nfor div in sorted(DIVS, reverse=True):\n    for i in range(N):\n        DIFF[i] = AS[i]%div\n    DIFF.sort()\n    ACC[0] = DIFF[0]\n    for i in range(1,N): ACC[i] = ACC[i-1] + DIFF[i]\n    # print(ACC)\n    for i in range(N-1):\n        left = ACC[i]\n        right = (N-1-i)*div-(ACC[N-1]-ACC[i])\n        if left%div == right%div:\n            if max(left, right) <= K:\n                # print(max(left, right))\n                print(div)\n                return\n\n\n# print(DIFF)\n# print(res)\n", "# \u5272\u308a\u5207\u308b\u6570\u306f\u3001A\u306e\u7dcf\u548c\u306e\u7d04\u6570\u3067\u3042\u308b\n# \u81ea\u5206\u81ea\u8eab\u3092\u9664\u304f\u7d04\u6570\u306b\u3064\u3044\u3066\u5927\u304d\u3044\u9806\u306b\u3059\u3079\u3066\u8a66\u3057\u3066\u3001\u5f53\u3066\u306f\u307e\u308b\u3082\u306e\u304c\u3042\u308c\u3070\u7b54\u3048\n\n# 8,20\u30927\u306e\u500d\u6570\u306b\u8fd1\u3065\u3051\u308b\u3068\u304d\u3001\n# 8 -> mod 7\u304c1\u3067\u3042\u308a\u3001-1\u304b+6\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n# 20 -> mod 7\u304c6\u3067\u3042\u308a\u3001-6\u304b+1\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nA = list(map(int,readline().split()))\n\nall = sum(A)\ndivisors = []\nfor i in range(1,int(all ** 0.5) + 1):\n  if all % i == 0:\n    divisors.append(i)\n    divisors.append(all // i)\n\ndivisors = sorted(divisors,reverse = True)\n\nfor d in divisors:\n  mods = [0] * (N)\n  for i in range(len(A)):\n    mods[i] = A[i] % d\n  mods = sorted(mods)\n  mods_front = [0] * N\n  mods_front[0] = mods[0]\n  for i in range(1,N):\n    mods_front[i] = mods_front[i - 1] + mods[i]\n  mods_back = [0] * N\n  mods_back[-1] = d - mods[-1]\n  for i in range(N - 2,-1,-1):\n    mods_back[i] = mods_back[i + 1] + (d - mods[i])\n  for i in range(N - 1):\n    if mods_front[i] == mods_back[i + 1]:\n      if K >= mods_front[i]:\n        print(d)\n        return\nelse:\n  print(1)", "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef ok(d):\n    m = sorted(a % d for a in a)\n    s, e, plus, minus = 0, len(m) - 1, 0, 0\n    while True:\n        if s > e:\n            return (plus == minus)\n        if plus <= minus:\n            plus += m[s]\n            if plus > k:\n                return False\n            s += 1\n        else:\n            minus += d - m[e]\n            if minus > k:\n                return False\n            e -= 1\n    return False\n\nb = sum(a)\nret = 1\nd = 1\nwhile d * d <= b:\n    if b % d == 0:\n        if ok(d):\n            ret = max(ret, d)\n        if ok(b // d):\n            ret = max(ret, b //d)\n    d += 1\nprint(ret)", "import numpy as np\n\n\n# \u7d04\u6570\u306e\u5217\u6319\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    divisors.sort()\n    return divisors\n\n\nN, K, *A = map(int, open(0).read().split())\n\nA = np.array(A, np.int64)\nd = make_divisors(A.sum())\n\nfor i in d[::-1]:\n    r = A % i\n    r.sort()\n    r = r[r != 0]\n    if r.size == 0:\n        print(i)\n        return\n    else:\n        n = np.arange(r.size - 1, 0, -1)\n\n    np.cumsum(r, out=r)\n    equal = np.where(r[:-1] == i * n - (r[-1] - r[:-1]))[0]\n    if np.any(r[equal] <= K):\n        print(i)\n        return", "from itertools import accumulate\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nM = sum(A)\n\n# \u7b54\u3048\u306e\u5019\u88dc\u3092\u5217\u6319\nans_candidates = []\nfor n in range(1, int(M ** 0.5) + 1):\n    if M % n == 0:\n        ans_candidates.append(n)\n        ans_candidates.append(M // n)\n\n\nans = 0\nfor X in ans_candidates:\n    A_mod = sorted([a % X for a in A])\n    U = [X - a for a in A_mod]\n    D = [-a for a in A_mod]  # \u308f\u304b\u308a\u3084\u3059\u3044\u306e\u3067\n\n    U = list(accumulate(U))\n    D = list(accumulate(D))\n\n    for i in range(N):\n        if -D[i] > K:\n            break\n\n        if -D[i] == (U[-1] - U[i]):\n            ans = max(ans, X)\n            break\n\nprint(ans)\n", "def get_divisor(num, max_val):\n    ret = []\n    num_sq = int(num**0.5)\n    for k in range(1, num_sq+1):\n        if num % k == 0:\n            if k <= max_val: ret.append(k)\n            if num//k <= max_val: ret.append(num//k)\n            \n    return ret\n\n# \u4e0b\u304b\u3089mod\u304c\u4f4e\u3044\u306e\u3092\u53d6\u3063\u3066\u304d\u3066\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u53d6\u308b\ndef solve():\n    N,K = map(int, input().split())\n    A = list(map(int, input().split()))\n    sum_A = sum(A)\n    max_A = max(A)\n    div = get_divisor(sum_A, max_A+K)\n    ret = 1\n    for d in div:\n        sum_k = 0\n        red_k = 0\n        flag = True\n        mod_d = [a%d for a in A]\n        mod_d.sort()\n        # print(d, mod_d)\n        for a in mod_d:\n            if sum_k+a <= K:\n                sum_k += a\n            else: \n                red_k += d-a\n            if sum_k-red_k < 0:\n                break\n\n        if (sum_k-red_k)%d == 0: ret = max(ret, d)\n            \n    print(ret)\n    \nsolve()", "import  numpy as np\n\n\ndef divisors(num):\n    array = []\n    limit = int(num ** 0.5) + 1\n    for i in range(1, limit):\n        if num % i == 0:\n            div1 = i\n            div2 = num//i\n            array.append(div1)\n            if div1 != div2:\n                array.append(div2)\n    array.sort(reverse=True)\n    return array\n\n\nn, k = map(int, input().split())\nA = np.array(list(map(int, input().split())), dtype=int)\n\ntotal = sum(A)\ncandidates = divisors(total)\n\n\nfor div in candidates:\n    mods = A % div\n    mods.sort()\n    add = div - mods\n\n    addcum = np.cumsum(add)\n    subcum = np.cumsum(mods)\n    for i in range(n):\n        addcount = addcum[n-1] - addcum[i]\n        subcount = subcum[i]\n        if addcount == subcount and addcount <= k:\n            print(div)\n            return", "from math import sqrt\ndef Divisor_Set(n):\n    s = set()\n    for i in range(1, int(sqrt(n))+2):\n        if n%i == 0:\n            s.add(i)\n            s.add(n//i)\n    return s\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a_sum = sum(a)\n    s = Divisor_Set(a_sum)\n    ans = 1\n    for v in s:\n        a_mod = [x%v for x in a]\n        a_mod.sort()\n        for i in range(1, n):\n            a_mod[i] += a_mod[i-1]\n        for i in range(n):\n            l, r = a_mod[i], v*(n-i-1) - (a_mod[-1] - a_mod[i])\n            if l == r and r <= k:\n                if ans < v:\n                    ans = v\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    def ok(f):\n        bb=[a%f for a in aa]\n        bb.sort()\n        i,j=0,n-1\n        s=t=0\n        while i<=j:\n            if s>t:\n                t+=f-bb[j]\n                j-=1\n            else:\n                s+=bb[i]\n                i += 1\n        return s<=k\n\n    n,k=MI()\n    aa=LI()\n    s=sum(aa)\n    ff=[]\n    for d in range(1,s+1):\n        if d**2>s:break\n        if s%d==0:\n            ff.append(d)\n            ff.append(s//d)\n    if ff[-1]==ff[-2]:ff.pop()\n    ff.sort(reverse=True)\n    for f in ff:\n        if ok(f):\n            print(f)\n            break\n\nmain()", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nm = sum(a)\n\ndef divisor(n):\n    ass = []\n    for i in range(1, int(n**0.5)+1):\n        if n%i == 0:\n            ass.append(i)\n            ass.append(n//i)\n    return ass\nf = divisor(m)\nf.sort(reverse=True)\n\nfor p in f:\n  b = [x%p for x in a]\n  b.sort()\n  t = 0\n  c = n\n  for x in b:\n    if x + t > k:\n      break\n    t += x\n    c -= 1\n  if c*p - sum(b) + t <= k:\n    print(p)\n    break", "def make_divisor_list(n):\n    result = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            result.append(i)\n            result.append(n // i)\n    return result\n\n\ndef calc_min_ops(r, d):\n    i, j = 0, len(r)\n    while i < j and r[i] == 0:\n        i += 1\n    i -= 1\n    a, b = 0, 0\n    while j-i != 1:\n        if a <= b:\n            i += 1\n            a += r[i]\n        else:\n            j -= 1\n            b += d - r[j]\n    return a\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\nc = sum(A)\ndivisors = make_divisor_list(c)\ndivisors.sort(reverse=True)\nr = [None] * N\n\nfor d in divisors:\n    for i in range(N):\n        r[i] = A[i] % d\n    r.sort()\n    if calc_min_ops(r, d) <= K:\n        print(d)\n        break\n", "def factor(N):\n    arr=[]\n    for i in range(1,int(N**0.5)+1):\n        if(N%i==0):\n            arr.append(i)\n            if(N//i!=i):\n                arr.append(N//i)\n    return arr\n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nsum_=sum(a)\n\nfac=sorted(factor(sum_),reverse=True)\nans=1\nfor x in fac:\n    li=sorted(z%x for z in a)\n    res=0\n    cum=[0]*(n+1)\n    for i in range(n):\n        cum[i+1]=cum[i]+li[i]\n    for i in range(1,n):\n        l,r=cum[i],x*(n-i)-(cum[n]-cum[i])\n        if l==r and r<=k:\n            ans=max(ans,x)\nprint(ans)", "def make_divisors(n: int) -> list:\n    \"\"\"\u81ea\u7136\u6570n\u306e\u7d04\u6570\u3092\u5217\u6319\u3057\u305f\u30ea\u30b9\u30c8\u3092\u51fa\u529b\u3059\u308b\n    \u8a08\u7b97\u91cf: O(sqrt(N))\n    \u5165\u51fa\u529b\u4f8b: 12 -> [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    divisors = []\n    for k in range(1, int(n ** 0.5) + 1):\n        if n % k == 0:\n            divisors.append(k)\n            if k != n // k:\n                divisors.append(n // k)\n    divisors = sorted(divisors)\n    return divisors\n\n\ndef solve(val):\n    res = []\n    for i in range(n):\n        tmp = a[i] % val\n        if tmp == 0:\n            continue\n        res.append(a[i] % val)\n    res = sorted(res)\n    if not res:\n        return True\n    l_val = 0\n    for i in range(len(res)):\n        l_val += res[i]\n        if l_val > k:\n            l_pos = i - 1\n            break\n    else:\n        return True\n    r_val = 0\n    for i in range(l_pos + 1, len(res)):\n        r_val += val - res[i]\n    return r_val <= k\n            \n      \n        \n    \nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsum_a = sum(a)\ndiv = make_divisors(sum_a)\nans = 0\nfor i in div:\n    if solve(i):\n        ans = max(ans, i)\nprint(ans)", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\ns=sum(a)\n\ncandidates=set()\nfor i in range(1,int(s**0.5)+1):\n  if s%i==0:\n    candidates.add(i)\n    candidates.add(s//i)\n\nans=0\nfor cdd in candidates:\n  f=sorted([x%cdd for x in a])\n  # calc need\n  ans=max(ans,cdd) if sum(f[:-sum(f)//cdd])<=k else ans   \n    \nprint(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nAsum = sum(A)\n\ndiv = set()\nfor i in range(1, int(Asum ** 0.5 + 0.5) + 1):\n    if Asum % i == 0:\n        div.add(i)\n        div.add(Asum//i)\n\nans = 1\nfor d in div:\n    R = [a % d for a in A]\n    R.sort()\n    r = sum(R) // d\n    l = N - r\n    need = sum(R[:l])\n    if need <= K:\n        ans = max(ans, d)\nprint(ans)\n", "from itertools import accumulate\nfrom math import floor, sqrt\nN, K = map(int,input().split())\nA = list(map(int,input().split()))\nsm = sum(A)\ndivs = set()\nfor i in range(1, floor(sqrt(sm))+1):\n    if sm % i == 0:\n        divs.add(i)\n        divs.add(sm // i)\nans = 1\nfor d in divs:\n    ls = sorted(map(lambda x: x%d, A))\n    acc = [0]+list(accumulate(ls, lambda x,y:x+y))\n    for i in range(1, N):\n        minus = acc[i]-acc[0]\n        plus = d*(N-i) - (acc[-1]-acc[i])\n        if plus == minus and plus <= K:\n            ans = max(ans, d)\nprint(ans)", "def divisors(n):\n    i = 1\n    table = set()\n    while i * i <= n:\n        if not n % i:\n            table.add(i)\n            table.add(n//i)\n        i += 1\n    table = list(table)\n    return table\n\ndef binary_search_int(ok, ng, test):\n    \"\"\"\n    :param ok: solve(x) = True \u3092\u5fc5\u305a\u6e80\u305f\u3059\u70b9\n    :param ng: solve(x) = False \u3092\u5fc5\u305a\u6e80\u305f\u3059\u70b9\n    \"\"\"\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if test(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nimport numpy as np\nimport sys\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\nS = sum(A)\nD = divisors(S)\nD.sort()\n\ndef test(x):\n    k = D[x]\n    B = A%k\n    B.sort()\n    cnt = sum(B)//k\n    return k*cnt - sum(B[-cnt:]) <= K\n\np = binary_search_int(0,len(D),test)\nq = binary_search_int(p+1,len(D),test)\nprint(max(D[p],D[q]) if q != p+1 else D[p])", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef divisors(n):\n    lower = []\n    upper = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            lower.append(i)\n            if i != n // i:\n                upper.append(n // i)\n\n    lower.extend(reversed(upper))\n    return lower\n\n\ndef main():\n    N, K, *A = list(map(int, read().split()))\n\n    total = sum(A)\n    div = divisors(total)\n\n    for d in reversed(div):\n        vec = [a % d for a in A]\n        vec.sort()\n\n        M = len(vec)\n        csum_sub = [0] * (M + 1)\n        csum_add = [0] * (M + 1)\n        for i in range(M):\n            csum_sub[i + 1] = csum_sub[i] + vec[i]\n            csum_add[i + 1] = csum_add[i] + d - vec[i]\n\n        for i in range(M + 1):\n            if csum_sub[i] <= K and csum_sub[i] == csum_add[M] - csum_add[i]:\n                print(d)\n                return\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = map(int, input().split())\nA = list(map(int, input().split()))\ns = sum(A)\ndef md(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort(reverse=True)\n    return divisors\nP = md(s)\ndef test(x):\n  L = sorted([a%x for a in A])\n  M = sum(L)\n  c = M//x\n  for _ in range(c):\n    M -= L.pop()\n  return M <= k\n\nfor p in P:\n  if test(p):\n    print(p)\n    break", "N,K=map(int, input().split())\nA=list(map(int, input().split()))\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n  \nD=make_divisors(sum(A))\nans=1\nfor i in D:\n  E=[]\n  for j in A:\n    d=j%i\n    if d!=0:\n      E.append(d)\n  if len(E)==0:\n    ans=i\n  E=sorted(E)\n  cn=0\n  e=sum(E)\n  left,right=e,0\n  #print(i,E)\n  for k in range(len(E)):\n    left-=E[-1-k]\n    right+=(i-E[-1-k])\n    if left==right:\n      if left<=K:\n        ans=i\n      break\nprint(ans)", "import numpy as np\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\nn, k = map(int,input().split())\na = list(map(int,input().split()))\n\nasum = sum(a)\nadiv = make_divisors(asum)\nadiv.reverse()\n\na = np.array(a)\nans = 1\nflg = False\nfor i in adiv:\n    a_ = np.sort(a % i)\n    # print(i, a_)\n    msum = a_.sum()\n    msum_ = 0\n    for j in range(-1, -n-1, -1):\n        msum -= a_[j]\n        msum_ += i - a_[j]\n        if msum_ > k:\n            break\n        if msum < msum_:\n            break\n        if msum == msum_ :\n            ans = i\n            flg = True\n            break\n    if flg:\n        break\n\nprint(ans)", "n,k = list(map(int,input().split()))\na = list(map(int,input().split()))\ns = sum(a)\ndl = []\nfor i in range(1,int(s**0.5)+1):\n    if s%i == 0:\n        dl.append(i)\n        if i != s//i:\n            dl.append(s//i)\ndl.sort(reverse = True)\n\ndef search(x):\n    ml = []\n    for i in a:\n        ml.append(i%x)\n    ml.sort(reverse = True)\n    ms = sum(ml)\n    count = 0\n    i = 0\n    while k > count and ms > count:\n        mi = x-ml[i]\n        if k >= mi:\n            count += mi\n            ms -= ml[i]\n            \n        else:\n            break\n        i += 1\n\n    if k >= count and count == ms:\n        return True\n    else:\n        return False\n\nfor i in dl:\n    \n    if search(i):\n        print(i)\n        return\n\n", "n,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\ns=sum(A)\nimport math\ndef yakusu(n):\n  ans_local=set()\n  for i in range(1,int(math.sqrt(n))+1):\n    if n%i==0:\n      ans_local = ans_local | set([i,n//i]) #set\u306a\u306e\u3067\u5e73\u65b9\u6570\u3067\u3082OK\n  return list(ans_local)  #\u5fc5\u8981\u306b\u5fdc\u3058\u3066sort\n\nyaku=sorted(yakusu(s), reverse=1)\n#print(yaku)\nfor mod in yaku:\n    B=[i%mod for i in A if i%mod!=0]\n    if B==[] : print(mod);return\n    if len(B)==1:\n        q=B[0]\n        if 0<=q<=k or mod-k<=q: print(mod);return\n        else:continue\n    B.sort()\n    r=[B[0]]*len(B)\n    for i in range(len(B)-1):\n        r[i+1]= r[i]+B[i+1]\n    now=float(\"INF\")\n    for i in range(1,len(B)): #\u5207\u308a\u65b9\n        if r[i-1] ==  mod*(len(B)-i)-(r[-1]-r[i-1]) and r[i-1]<=k:\n            print(mod);return\n\n    \n", "from math import sqrt\nfrom itertools import accumulate\n\n\ndef common_divisors(x):\n    ret = []\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            ret.append(i)\n            ret.append(x // i)\n\n    return ret\n\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsm = sum(a)\ncd = common_divisors(sm)\n\nans = 1\nfor ecd in cd:\n    r = [e % ecd for e in a]\n    r.sort()\n    acc = [0] + list(accumulate(r))\n    for i in range(1, n + 1):\n        sub = acc[i-1]\n        add = ecd * (n - i + 1) - (acc[n] - acc[i-1])\n        if sub == add:\n            if sub <= k:\n                ans = max(ans, ecd)\n\nprint(ans)\n", "import  numpy as np\n\n\ndef divisors(num):\n    array = []\n    limit = int(num ** 0.5) + 1\n    for i in range(1, limit):\n        if num % i == 0:\n            div1 = i\n            div2 = num//i\n            array.append(div1)\n            if div1 != div2:\n                array.append(div2)\n    array.sort(reverse=True)\n    return array\n\n\nn, k = map(int, input().split())\nA = np.array(list(map(int, input().split())), dtype=int)\n\ntotal = sum(A)\ncandidates = divisors(total)\n\n\nfor div in candidates:\n    mods = A % div\n    mods.sort()\n    subcum = np.cumsum(mods)\n    idx = subcum[n-1] // div\n    count = subcum[-1-idx]\n    if count <= k:\n        print(div)\n        return", "from math import sqrt\nfrom itertools import accumulate\n\n\ndef common_divisors(x):\n    ret = []\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            ret.append(i)\n            ret.append(x // i)\n\n    return ret\n\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsm = sum(a)\ncd = common_divisors(sm)\n\nans = 0\nfor ecd in cd:\n    r = [e % ecd for e in a]\n    r.sort()\n    sub = [0] + list(accumulate(r))\n    add = [0] + list(accumulate(ecd - e for e in r[::-1]))\n    add = add[::-1]\n    for sb, ad in zip(sub, add):\n        if sb == ad and sb <= k:\n            ans = max(ans, ecd)\n\nprint(ans)\n", "from math import sqrt\nfrom itertools import accumulate\n\n\ndef common_divisors(x):\n    ret = []\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            ret.append(i)\n            ret.append(x // i)\n\n    return ret\n\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsm = sum(a)\ncd = common_divisors(sm)\n\nans = 1\nfor ecd in cd:\n    r = [e % ecd for e in a]\n    r.sort()\n    sub = [0] + list(accumulate(r))\n    add = [0] + list(accumulate(ecd - e for e in r[::-1]))\n    add = add[::-1]\n    for sb, ad in zip(sub, add):\n        if sb == ad and sb <= k:\n            ans = max(ans, ecd)\n\nprint(ans)\n", "from math import sqrt\nfrom bisect import bisect_left\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_a = sum(a)\n    st = set()\n    for v in range(1, int(sqrt(sum_a))+2):\n        if sum_a % v == 0:\n            st.add(v)\n            st.add(sum_a//v)\n    st.remove(1)\n    ans = 1\n    for target in st:\n        a_mod_t = [v % target for v in a]\n        a_mod_t.sort()\n        for i in range(n-1):\n            a_mod_t[i+1] += a_mod_t[i]\n        for i in range(n):\n            sum_L, sum_R = a_mod_t[i], a_mod_t[-1] - a_mod_t[i]\n            len_L, len_R = i+1, n-i-1\n            if sum_L == target * len_R - sum_R:\n                if sum_L <= k:\n                    if ans < target:\n                        ans = target\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nS = sum(A)\nmax_div = int(S**0.5)\n\n# S\u306e\u7d04\u6570\u3092\u5217\u6319\u3059\u308b\nsmall_div = []\nlarge_div = []\nfor i in range(1, max_div+1):\n  if S%i == 0:\n    small_div.append(i)\n    large_div.append(S//i)\n\n# \u7d04\u6570\u3092\u964d\u9806\u306b\u4e26\u3079\u308b\ndiv = large_div + small_div[::-1]\n\nans = 1\nfor d in div:\n  r = []\n  for a in A:\n    r.append(a%d)\n  \n  r.sort()\n  # (d-ri)\u8db3\u3059\u304b\u3001ri\u5f15\u304f\u304b\u3001\u305d\u308c\u305e\u308c\u7d2f\u7a4d\u548c\u3092\u6c42\u3081\u3066\u304a\u304f\n  minus = [0]*(N+1)\n  plus = [0]*(N+1)\n  for i, ri in enumerate(r, 1):\n    minus[i] = minus[i-1] + ri\n  \n  for i, ri in enumerate(r[::-1], 1):\n    plus[i] = plus[i-1] + (d - ri)\n  \n  plus = plus[::-1]\n  for m, p in zip(minus, plus):\n    if m == p and m <= K:\n      ans = d\n      break\n  \n  else:\n    continue\n  \n  break\n\nprint(ans)", "import numpy as np\n\n\n# \u7d04\u6570\u306e\u5217\u6319\ndef make_divisors(n):\n    divisors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\nA = np.array(A, np.int64)\nd = make_divisors(A.sum())\n\nfor i in d[::-1]:\n    r = A % i\n    r = r[r.nonzero()]\n    l = r.size\n    if l == 0:\n        print(i)\n        return\n    else:\n        n = np.arange(l - 1, 0, -1)\n    r.sort()\n    np.cumsum(r, out=r)\n    if np.any((r[:-1] == i * n - (r[-1] - r[:-1])) & (r[:-1] <= K)):\n        print(i)\n        return\n", "def main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    m = sum(A)\n    d = []\n    for i in range(1, int(m**0.5)+1):\n        if m % i == 0:\n            d.append(i)\n            if i != m // i:\n                d.append(m//i)\n    d.sort(reverse=True)\n    for j in d:\n        if j > K + max(A):\n            continue\n        l = []\n        for i in A:\n            l.append(i % j)\n        t = N - sum(l) // j\n        l.sort()\n        if sum(l[:t]) <= K:\n            print(j)\n            return\n    print((1))\nmain()\n", "import heapq\n\ndef divisor(i):\n    s = []\n    for j in range(1, int(i ** (1 / 2)) + 1):\n        if i % j == 0:\n            s.append(i // j)\n            s.append(j)\n    return sorted(set(s))\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nsuma = sum(a)\ns = divisor(suma)\nfor i in range(1, len(s) + 1):\n    x = s[-i]\n    y = suma // x\n    h = []\n    heapq.heapify(h)\n    for j in a:\n        y -= j // x\n        heapq.heappush(h, -(j % x))\n    cnt = 0\n    for _ in range(y):\n        cnt += (heapq.heappop(h) % x)\n    if cnt <= k:\n        print(x)\n        return", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    A = [int(a) for a in input().split()]\n    sumA = sum(A)\n    D = []\n    for i in range(1, sumA + 1):\n        if i ** 2 > sumA: break\n        if sumA % i == 0:\n            D.append(i)\n            if i ** 2 != sumA: D.append(sumA // i)\n    D.sort(reverse = True)\n    for i, d in enumerate(D):\n        L = []\n        count = 0\n        for a in A:\n            if a % d > 0: \n                L.append(a % d)\n                count += 1\n        L.sort()\n        if count > 0:\n            minus, plus = [0] * count, [0] * count\n            minus[0] = L[0]\n            plus[count - 1] = d - L[count - 1]\n            for i in range(1, count):\n                minus[i] = minus[i-1] + L[i]\n                plus[count - 1 - i] = plus[count - i] +  d - L[count - 1 - i]\n            Op = K + 1\n            for i in range(count - 1):\n                if abs(minus[i] - plus[i + 1]) % d == 0: Op = min(Op, max(minus[i], plus[i + 1]))\n            if Op <= K:\n                print(d)\n                break\n    else: print(1)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\ns=sum(a)\n\ncandidates=set()\nfor i in range(1,int(s**0.5)+1):\n  if s%i==0:\n    candidates.add(i)\n    candidates.add(s//i)\n\nans=0\nfor cdd in candidates:\n  div_cdd=[0]*n\n  for i in range(n):\n    div_cdd[i]=a[i]%cdd\n  div_cdd=sorted(div_cdd)\n  pstv,ngtv=0,-sum(div_cdd)\n  # calc need\n  if pstv==-ngtv:\n    ans=max(ans,cdd)\n    continue\n  for i in range(n):\n    pstv+=cdd-div_cdd[-1-i]\n    ngtv+=div_cdd[-1-i]\n    if pstv==-ngtv: break\n  ans=max(ans,cdd) if pstv<=k else ans\n    \nprint(ans)", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# \u7d04\u6570\u5217\u6319\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\nans = 1\n\nfor div in make_divisors(sum(a)):\n    mod_div = []\n    for ai in a:\n        mod_div.append(ai % div)\n    mod_div.sort()\n\n    tmp_p = n * div - sum(mod_div)\n    tmp_m = 0\n\n    for i, x in enumerate(mod_div):\n        tmp_m += x\n        tmp_p -= div - x\n        if tmp_m == tmp_p and tmp_m <= k:\n            ans = max(div, ans)\n\nprint(ans)\n", "from itertools import accumulate\nn,k = map(int,input().split())\na = list(map(int,input().split()))\nsuma = sum(a)\ndevisor = []\nfor i in range(1,int(suma**0.5)+1):\n  if suma%i == 0:\n    devisor.extend((i,suma//i))\ndevisor.sort(reverse=True)\nfor x in devisor:\n  b = [a[i]%x for i in range(n)]\n  b.sort()\n  sumb = list(accumulate(b))\n  for y in range(n-1):\n    bf = sumb[y]\n    bl = sumb[n-1]-sumb[y]\n    if bf%x == (x-(bl%x))%x:\n      if k>=max(bf,(n-1-y)*x-bl):\n        print(x)\n        return\n      else:\n        continue", "N,K = map(int,input().split())\nA = list(map(int,input().split()))\n\nS = sum(A)\nans = 0\n\nfor i in range(1,int(S**0.5)+1):\n    if S%i != 0:\n        continue\n        \n    for j in range(2):\n        d = i if j else S//i\n        B = sorted(map(lambda a:a%d,A))\n        C = [0]\n        for k in range(N):\n            C.append(C[-1]+B[k])\n            \n        for k in range(N+1):\n            if ((N-k)*d-(C[-1]-C[k])-C[k])%d == 0:\n                if max(C[k],(N-k)*d-(C[-1]-C[k])) <= K:\n                    ans = max(ans,d)\n                    \nprint(ans)", "INF = float(\"inf\")\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef get_divisors(num):\n    f_divs, l_divs = [], []\n    for i in range(1, int(num**0.5)+1):\n        if not num % i:\n            f_divs.append(i)\n            if i != num // i:\n                l_divs.append(num // i)\n    return f_divs + l_divs[::-1]\n\ndivs = get_divisors(sum(a))\nans = 1\n\ndef evl(d):\n    rem = [x % d for x in a]\n    rem.sort()\n    s = sum(rem)\n    c = 0\n    for i, x in enumerate(rem):\n        c += x\n        if c == d*(n-i-1) - (s-c):\n            return c <= k\n    return False\n\nfor d in divs[::-1]:\n    if evl(d):\n        print(d)\n        break\n", "import numpy as np\n\ndef divisor(x):\n    div = []\n    for i in range(1,int(x**0.5)+1):\n        if x%i == 0:\n            div.append(i)\n            if x != i**2: div.append(x//i)    \n    return div\n\n\ndef mincount(a,x):\n    \n    minus = np.sort(a%x)\n    adj_sum = minus.sum()    \n    convert = adj_sum//x\n    \n    return adj_sum - minus[-convert:].sum()\n\n\nN,K = map(int,input().split())\nA = np.array(list(map(int,input().split())))\n\ndiv = divisor(A.sum())\ndiv.sort(reverse=True)\n\nfor d in div:\n    if mincount(A,d)<=K:\n        print(d)\n        break", "# https://betrue12.hateblo.jp/entry/2020/03/28/142051\n\ndef main():\n    N, K = list(map(int, input().split()))\n    *A, = list(map(int, input().split()))\n\n    def divisor_generator(n):\n        div = 1\n\n        stock = []\n        while div * div <= n:\n            if n % div == 0:\n                yield n // div\n                stock.append(div)\n            div += 1\n\n        for div in reversed(stock):\n            yield div\n\n    tot = sum(A)\n    for div in divisor_generator(tot):\n        k = tot // div - sum(a // div for a in A)\n        R = sorted(a % div for a in A)\n        Rc = [div - r for r in R]\n\n        cond = (sr := sum(r for r in R[:N - k])) == sum(r for r in Rc[N - k:]) and sr <= K\n        if cond:\n            print(div)\n            return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import accumulate\n\ndef divisors(n):\n    lst = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            lst.append(i)\n            if i != n // i: lst.append(n // i)\n    return lst\n\nN, K = map(int, input().split())\n*A, = map(int, input().split())\ncands = divisors(sum(A))\nfor d in sorted(cands, reverse=True):\n    rems = sorted([a % d for a in A])\n    cumsum_rems = [0] + list(accumulate(rems))\n    for i in range(1, N):\n        minus = cumsum_rems[i]\n        plus = d * (N - i) - (cumsum_rems[N] - minus)\n        if max(minus, plus) <= K: break\n    else:\n        continue\n    break\nprint(d)", "import  numpy as np\n\n\ndef divisors(num):\n    array = []\n    limit = int(num ** 0.5) + 1\n    for i in range(1, limit):\n        if num % i == 0:\n            div1 = i\n            div2 = num//i\n            array.append(div1)\n            if div1 != div2:\n                array.append(div2)\n    array.sort(reverse=True)\n    return array\n\n\nn, k = map(int, input().split())\nA = np.array(list(map(int, input().split())), dtype=int)\n\ntotal = sum(A)\ncandidates = divisors(total)\n\n\nfor div in candidates:\n    mods = A % div\n    mods.sort()\n    np.cumsum(mods, out=mods)\n    idx = mods[n-1] // div\n    count = mods[-1-idx]\n    if count <= k:\n        print(div)\n        return", "def max2(x,y):\n    return x if x > y else y\n\ndef divisors(n):\n    i = 1\n    table = set()\n    while i * i <= n:\n        if not n % i:\n            table.add(i)\n            table.add(n//i)\n        i += 1\n    table = list(table)\n    return table\n\nimport numpy as np\nimport sys\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\nS = sum(A)\nD = divisors(S)\nD.sort()\nres = 0\nfor k in D:\n    B = A%k\n    B.sort()\n    cnt = sum(B)//k\n    if k*cnt - sum(B[-cnt:]) <= K:\n        res = max2(res, k)\n\nprint(res)", "import numpy as np\n\ndef getDivisor(n):\n    divisor = []\n    tmp = n\n    for i in range(2, int(n**0.5)+1):\n        cnt = 1\n        d = [1,]\n        while tmp%i == 0:\n            d.append(i**cnt)\n            tmp //= i\n            cnt += 1\n        if cnt > 1:\n            divisor.append(d)\n    if tmp != 1:\n        divisor.append([1,tmp])\n    if divisor == []:\n        divisor.append([1,n])\n        \n    divisor_mat = np.matrix(1) \n    for d in divisor:\n        d = np.matrix(d)\n        mat = []\n        for dcol in divisor_mat:\n            mat.append(dcol.T * d)\n        divisor_mat = np.concatenate(mat)\n    divisor_mat = np.array(divisor_mat.flatten())\n    divisor_mat = np.array(divisor_mat[0].tolist())\n    divisor_mat.sort()\n    return divisor_mat\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na = np.array(a)\nsum_a = a.sum()\ndivisor = getDivisor(sum_a)\nfor d in divisor[::-1]:\n  tmp = a % d\n  idx = tmp.sum() // d\n  tmp.sort()\n  num_op = tmp[:-idx].sum()\n  if num_op <= k:\n    break\nprint(d)", "def main():\n    N, K = list(map(int, input().split(' ')))\n    A = list(map(int, input().split(' ')))\n    # Calculate divisors of sum(A)\n    S = sum(A)\n    divs = list()\n    n = 1\n    while n ** 2 <= S:\n        if S % n == 0:\n            m = S // n\n            if n != m:\n                divs.extend([n, m])\n            else:\n                divs.append(n)\n        n += 1\n    divs.sort(reverse=True)\n    # calc answer\n    ans = S\n    for d in divs:\n        B = [a % d for a in A]\n        B.sort(reverse=True)\n        t = sum(B) // d\n        k = sum(B) - sum(B[:t])\n        if d == 1:\n            k = 0\n        if k <= K:\n            ans = d\n            break\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport numpy as np\ninput = sys.stdin.readline\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\n\ndef main():\n    n, k = map(int, input().split())\n    a = np.array([int(x) for x in input().split()])\n    key = make_divisors(np.sum(a))\n    \n    for v in key:\n        mod = np.sort(a%v)\n        c1, c2 = 0, np.sum(mod)\n        judge = c2\n        for i in range(n-1, -1, -1):\n            c1 += v-mod[i]\n            c2 -= mod[i]\n            judge = min(judge, max(c1, c2))\n        if judge <= k:\n            print(v)\n            return\n    \n    \ndef __starting_point():\n    main()\n__starting_point()", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\ns=sum(a)\n\ncandidates=set()\nfor i in range(1,int(s**0.5)+2):\n  if s%i==0:\n    candidates.add(i)\n    candidates.add(s//i)\n\nans=0\nfor cdd in candidates:\n  div_cdd=[0]*n\n  for i in range(n):\n    div_cdd[i]=a[i]%cdd\n  div_cdd=sorted(div_cdd)\n  pstv,ngtv=0,-sum(div_cdd)\n  # calc need\n  if pstv==-ngtv:\n    ans=max(ans,cdd)\n    continue\n  for i in range(n):\n    pstv+=cdd-div_cdd[-1-i]\n    ngtv+=div_cdd[-1-i]\n    if pstv==-ngtv: break\n  ans=max(ans,cdd) if pstv<=k else ans\n    \nprint(ans)", "def yakusu(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\nN,K=map(int,input().split())\nL=list(map(int,input().split()))\na=sum(L)\nR=yakusu(a)[::-1]\nfor i in range(len(R)):\n  add=0\n  minus=0\n  s=R[i]\n  A=list()\n  B=list()\n  for j in range(N):\n    k=L[j]\n    a=k%s\n    b=s-a\n    if a>b:\n      add+=b\n      B.append(b)\n    elif a<b:\n      minus+=a\n      A.append(a)\n    else:\n      add+=a\n      B.append(a)\n  #\u8db3\u3057\u305f\u5206=add else:minus \u3069\u3063\u3061\u3067\u3082:even\n  A=sorted(A)\n  B=sorted(B)\n  if minus==add:\n    d=minus\n    if d<=K:\n      print(s)\n      return\n  elif minus>add:\n    q=(minus-add)//s\n    d=sum(A[:len(A)-q])\n    if d<=K:\n      print(s)\n      return\n  else:\n    q=(add-minus)//s\n    d=sum(B[:len(B)-q])\n    if d<=K:\n      print(s)\n      return", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nN,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\ndef is_divide(d):\n    Rs = [a%d for a in A]\n    Rs.sort()\n    cumsum = [0] * (N + 1)\n    for i in range(N - 1,-1,-1):\n        cumsum[i] = cumsum[i + 1] + d - Rs[i]\n    cum = 0\n    for i in range(N):\n        if max(cum,cumsum[i]) <= K:\n            return True\n        cum += Rs[i]\n    return False\n\nS = sum(A)\nans = 0\nfor i in range(1,S + 1):\n    if i*i > S:\n        break\n    if S%i == 0:\n        if is_divide(i):\n            ans = max(ans,i)\n        if is_divide(S//i):\n            ans = max(ans,S//i)\nprint(ans)\n", "N, K = map(int, input().split())\n*A, = map(int, input().split())\nA.sort()\n\nS = sum(A)\ncandidates = []\nfor i in range(1, int(S**0.5)+1):\n    if S%i:continue\n    a, b = i, S//i\n    \n    candidates.append(a)\n    if a!=b:\n        candidates.append(b)\ncandidates.sort()\n\nans = 0\nfor d in candidates:\n    rems = []\n    rems_size, rems_sum = 0, 0\n\n    for i in A:\n        if i%d:\n            rems.append(i%d)\n            rems_size += 1\n            rems_sum += i%d\n\n    rems.sort()\n\n    a = 0\n    for i, j in enumerate(rems[:-1], start=1):\n        a += j\n        b = d*(rems_size-i)-(rems_sum-a)\n        if max(a, b)<=K:\n            ans = max(ans, d)\n    if not rems:\n        ans = max(ans, d)\n\nprint(ans)", "import heapq\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nx = sum(a)\nsearch = []\ni = 1\nwhile i ** 2 <= x:\n    if x % i == 0:\n        heapq.heappush(search, -i)\n        heapq.heappush(search, -x//i)\n    i += 1\n\nwhile search:\n    ans = -heapq.heappop(search)\n    u = [a[i] % ans for i in range(n)]\n    u.sort()\n\n    plus = [0]\n    minus = [0]\n    for i in range(n):\n        plus.append(plus[-1] + ans - u[i])\n        minus.append(minus[-1] + u[i])\n\n    for i in reversed(list(range(n+1))):\n        # print(i)\n        m = minus[i]\n        p = plus[-1] - plus[i]\n        if m == p and m <= k:\n            print(ans)\n            return\n\n", "def make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\nl = make_divisors(s)\nl.sort(reverse=True)\nfor i in l:\n    l2 = [j % i for j in a]\n    l2.sort(reverse=True)\n    m = sum(l2) - sum(l2[:sum(l2)//i])\n    if i == 1:\n        m = 0\n    if m <= k:\n        s = i\n        break\nprint(s)", "N, K = (int(i) for i in input().split())\nA = [int(i) for i in input().split()]\n\ndef yaku(N):\n    res = []\n    for i in range(1, round(N**(1/2)) + 3 ):\n        if N%i == 0:\n            res.append(i)\n\n    res2 = [N//i for i in res]\n    res = list(set(res + res2))\n    return res\n\nys = yaku(sum(A))\nys.sort(reverse=True)\nfor y in ys:\n    M = [a%y for a in A if a%y]\n    ma = 0\n    mi = y*len(M) - sum(M)\n    M.sort()\n    for m in M:\n        ma += m\n        mi -= (y - m)\n        if ma == mi:\n            break\n    if ma <= K:\n        print(y)\n        return\n", "import sys\nimport math\nimport heapq\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef II(): return int(input())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\ndef gcd(x, y):\n    if x < y: x, y = y, x\n    div = x % y\n    while div != 0:\n        x, y = y, div\n        div = x % y\n    return y\n\nN,K=LI()\nAS=LI()\nSUMM= sum(AS)\n\nDIVS=set()\nfor i in range(1,40000):\n    if SUMM % i == 0:\n        DIVS.add(i)\n        DIVS.add(SUMM//i)\n# print(DIVS)\n\nDIFF=[0]*N\n\nres = 0\nfor div in DIVS:\n    for i in range(N):\n        DIFF[i] = AS[i]%div\n    DIFF.sort()\n    i = 0\n    j = N-1\n    sm = 0\n    cost = 0\n    while i <= j:\n        if sm + DIFF[j] >= div:\n            sm -= (div - DIFF[j])\n            j -= 1\n        else:\n            cost += DIFF[i]\n            sm += DIFF[i]\n            i += 1\n    # print(\"div:{} sum: {} cost: {}\".format(div, sm, cost))\n    if cost <= K: res = max(res, div)\n\n# print(DIFF)\nprint(res)\n", "def main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    m = sum(A)\n    d = []\n    for i in range(1, int(m**0.5)+1):\n        if m % i == 0:\n            d.append(i)\n            if i != m // i:\n                d.append(m//i)\n    d.sort(reverse=True)\n    for j in d:\n        if j > K + max(A):\n            continue\n        l = []\n        for i in A:\n            l.append(i % j)\n        t = N - sum(l) // j\n        l.sort()\n        if sum(l[:t]) <= K:\n            print(j)\n            return\n    print((1))\nmain()\n", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\ndef make_divisors(n): # n\u306e\u7d04\u6570\u3092\u5217\u6319\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\n\n# \u5168\u3066\u306e\u5408\u8a08\u306e\u7d04\u6570\u304c\u7b54\u3048\u306e\u5019\u88dc\u3001\u4e0a\u304b\u3089\u53ef\u80fd\u304b\u3069\u3046\u304b\u898b\u3066\u3044\u304f\nN, K = lr()\nA = np.array(lr())\ntotal = A.sum()\nD = make_divisors(total) # \u964d\u9806\nfor d in D:\n    B = A % d   \n    B.sort()\n    inc = d - B\n    B_cum = B.cumsum()\n    inc_cum = inc.cumsum()\n    for i in range(N):\n        x = B_cum[i]\n        y = inc_cum[N-1] - inc_cum[i]\n        if x > K or y > K:\n            continue\n        if (x+y) // 2 <= K:\n            print(d); return\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\n\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\n\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef SI(): return input().split()\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n\nfrom math import ceil, floor, log2\nfrom collections import deque\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product\nfrom heapq import heapify, heappop, heappush\n\n\ndef solve():\n    n, k = MI()\n    A = LI()\n    sm = sum(A)\n\n    div = []\n    for i in range(1, int(pow(sm, 0.5))+1):\n        if sm % i: continue\n        div.append(i)\n        if i != sm //i:\n            div.append(sm // i)\n    ans = 1\n    for d in div:\n        R = [a % d for a in A]\n        R.sort()\n        plus = 0\n        minus = 0\n        for r in R:\n            plus += d - r\n        for r in R:\n            minus += r\n            plus -= d - r\n            if minus == plus and plus <= k:\n                ans = max(ans, d)\n    print(ans)\n\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef isPrime(x):\n    if x < 2 or x % 2 == 0:\n        return False\n    if x == 2:\n        return True\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            return False\n        i += 2\n    return True\n\ndef divisor(x):\n    res = []\n    i = 1\n    while i * i <= x:\n        if x % i == 0:\n            res.append(i)\n            if i * i != x:\n                res.append(x // i)\n        i += 1\n    res = sorted(res)\n    return res\n\ndef factor(x):\n    res = []\n    if x == 1:\n        res.push_back(1)\n        return res\n    i = 2\n    while i * i <= x:\n        while x % i == 0:\n            res.append(i)\n            x //= i\n    if x != 1:\n        res.append(x)\n    res = sorted(res)\n    return res\n\n        \n\n\ndef __starting_point():\n    N,K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A = sorted(A)\n    sum_v = sum(A)\n    div = divisor(sum_v)\n    div = sorted(div, reverse=True)\n    for e in div:\n        ok = True\n        b = [int(a % e) for a in A]\n        b = sorted(b)\n        v = sum(b)\n        v //= e\n        ans = 0\n        for i in range(N-v):\n            ans += b[i]\n        \n        if ans <= K:\n            print(e)\n            return\n\n__starting_point()", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nS = sum(A)\n\ndef canMake(n):\n    B = [a % n for a in A]\n    B.sort()\n\n    left = 0\n    right = sum(B)\n    for i, b in enumerate(B, start=1):\n        left += b\n        right -= b\n        if left == n * (N - i) - right:\n            return left <= K\n    return False\n\nans = 1\nfor i in range(1, int(S**0.5) + 100):\n    if S % i != 0:\n        continue\n    k = S // i\n\n    if canMake(i):\n        ans = max(ans, i)\n    if canMake(k):\n        ans = max(ans, k)\n        break\n\nprint(ans)\n", "#  --*-coding:utf-8-*--\n\nimport math\n\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    s = sum(A)\n\n    D1 = []\n    D2 = []\n\n    for i in range(1, int(math.sqrt(s))+1):\n        if s%i == 0:\n            D1.append(s//i)\n            D2.append(i)\n\n    for d in D1 + list(reversed(D2)):\n        B = sorted([a%d for a in A])\n        x = sum(B[:-sum(B)//d])\n        \n        if x <= K:\n            print(d)\n            return\n\nmain()\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nS = sum(A)\n\ndef isOk(n):\n    B = [a % n for a in A]\n    B.sort()\n\n    now = 0\n    S = sum(B)\n    for i, b in enumerate(B[: -1]):\n        now += b\n        S -= b\n        if now == n * (N - i - 1) - S and now <= K:\n            return True\n    return False\n\nans = 1\nfor i in range(1, int(S**0.5) + 100):\n    if S % i != 0:\n        continue\n    j = S // i\n\n    if isOk(i):\n        ans = max(ans, i)\n    if isOk(j):\n        ans = max(ans, j)\n\nprint(ans)", "import numpy as np\n\nN, K = list(map(int, input().split()))\nAs_lis = list(map(int, input().split()))\n\nAs_arr = np.array(As_lis)\nS = np.sum(As_arr)\n\nsmaller_factors = []\nlarger_factors = []\nfor i in range(1, int(S ** 0.5) + 1):\n    if S % i == 0:\n        smaller_factors.append(i)\n        larger_factors.append(S // i)\n\nfor fac in larger_factors:\n    mods = As_arr % fac\n    k = np.sum(np.sort(mods)[:N - np.sum(mods) // fac])\n    if k <= K:\n        print(fac)\n        return\n\nfor fac in reversed(smaller_factors):\n    mods = As_arr % fac\n    k = np.sum(np.sort(mods)[:N - np.sum(mods) // fac])\n    if k <= K:\n        print(fac)\n        return\n\n", "def make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    return divisors\n\nN, K = map(int,input().split())\nA = list(map(int,input().split()))\nS = sum(A)\nL = make_divisors(S)\nans = 0\nfor i in L:\n    D = []\n    for a in A:\n        if a % i != 0:\n            D.append(a % i)\n    D.sort()\n    L1 = [0]\n    L2 = [0]\n    for j in range(len(D)):\n        L1.append(L1[-1] + D[j])\n        L2.append(L2[-1] + i - D[len(D)-1-j])\n    L2.reverse()\n    \n    for j in range(len(D)+1):\n        if K >= max(L1[j], L2[j]):\n            ans = max(ans, i)\n\nprint(ans)", "N,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\ndef divisor_all(n): # \u7d04\u6570\u5168\u5217\u6319\n    l = [1,n]\n    for i in range(2,int(pow(n,1/2))+1):\n        if n % i == 0:\n            if i == n//i:\n                l.append(i)\n            else:\n                l.append(i)\n                l.append(n//i)\n    l.sort(reverse=True)\n    return l # list\nD = divisor_all(sum(A))\ndef accumulater1D(A): # B:list[int]\n    B = [0]*len(A)\n    B[0] = A[0]\n    for i in range(1,len(B)):\n        B[i] = B[i-1]+A[i]\n    return B # A\u306e1\u6b21\u5143\u7d2f\u7a4d\u548c\nimport bisect\nans = 0\n\nfor d in D:\n    R = [A[i]%d for i in range(N) if A[i]%d!=0]\n    nr = len(R)\n    \n    R.sort()\n    if len(R)==0:\n        ans = d\n        break\n    LR = accumulater1D(R)\n    RR = list(reversed(accumulater1D([d-R[nr-1-i] for i in range(nr)])))\n    \n    for i in range(nr-1):\n        if LR[i]==RR[i+1]:\n            if LR[i]<=K:\n                ans = d\n                break\n    if ans != 0:\n        break\nprint(ans)\n\n\n\n", "import numpy as np\n\n\n# \u7d04\u6570\u306e\u5217\u6319\ndef make_divisors(n):\n    divisors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\nA = np.array(A, np.int64)\nd = make_divisors(A.sum())\n\nfor i in d[::-1]:\n    r = A % i\n    r = r[r != 0]\n    l = r.size\n    if l == 0:\n        print(i)\n        return\n    else:\n        n = np.arange(l - 1, 0, -1)\n    r.sort()\n    np.cumsum(r, out=r)\n    if np.any((r[:-1] == i * n - (r[-1] - r[:-1])) & (r[:-1] <= K)):\n        print(i)\n        return\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n,k = LI()\n    a = LI()\n    s = sum(a)\n    dv = set([1,s])\n    for i in range(2,int(s**0.5)+5):\n        if s%i == 0:\n            dv.add(i)\n            dv.add(s//i)\n\n    def f(i):\n        pm = []\n        for c in a:\n            t = c % i\n            if t == 0:\n                continue\n            pm.append((i-t, t))\n        pm.sort()\n        p = pi = m = 0\n        mi = len(pm) - 1\n        while pi <= mi:\n            if p < m:\n                p += pm[pi][0]\n                pi += 1\n            else:\n                m += pm[mi][1]\n                mi -= 1\n        return max(p,m) <= k\n\n    r = 1\n    for c in dv:\n        if f(c):\n            if r < c:\n                r = c\n\n    return r\n\n\nprint(main())\n\n\n\n", "n,k=map(int,input().split())\na=list(map(int,input().split()))\nm=sum(a)\ncd=set(())\nfor i in range(1,int(m**0.5)+2):\n  if m%i==0:\n    cd.add(i)\n    cd.add(m//i)\ncd=list(cd)\ncd.sort(reverse=True)\ndef func(x):\n  r=[ai%x for ai in a]\n  r.sort()\n  tmp=0\n  sr=[0]\n  for ri in r:\n    tmp+=ri\n    sr.append(tmp)\n  for i in range(n+1):\n    tmp0=sr[i]\n    tmp1=(n-i)*x-(sr[-1]-sr[i])\n    if tmp0==tmp1 and tmp0<=k:\n      return True\n  return False\n\n\nfor x in cd:\n  if x==1:\n    print(1)\n    return\n  if func(x):\n    print(x)\n    return", "from collections import deque\ndef isok(x):\n    que=deque(sorted(z%x for z in a))\n    res=0\n    while que:\n        l=que[0]\n        if l==0:\n            que.popleft()\n            continue\n        r=que[-1]\n        if r==0:\n            que.pop()\n            continue\n        d=min(l,x-r)\n        que[0]-=d\n        que[-1]=(que[-1]+d)%x\n        res+=d\n    return res\n        \ndef factor(N):\n    arr=[]\n    for i in range(1,int(N**0.5)+1):\n        if(N%i==0):\n            arr.append(i)\n            if(N//i!=i):\n                arr.append(N//i)\n    return arr\n\nn,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nsum_=sum(a)\n\nfac=sorted(factor(sum_),reverse=True)\nans=1\nfor x in fac:\n    c=isok(x)\n    if c<=k:\n        ans=x\n        break\nprint(ans)\n", "def make_divisors(n):\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            yield i\n            if i != n // i:\n                yield n // i\n\n\nN, K = list(map(int, input().split()))\nA = tuple(map(int, input().split()))\n\ndivisors = list(make_divisors(sum(A)))\ndivisors.sort(reverse=True)\n\nfor divisor in divisors:\n    M = [a % divisor for a in A]\n    M.sort(reverse=True)\n    # divisor\u3067\u5272\u3063\u305f\u4f59\u304c\u5927\u304d\u3044\u65b9\u306b\u8caa\u6b32\u306b+1\u3057\u3066\u3044\u304f\n    if sum(M[sum(M) // divisor:]) <= K:\n        print(divisor)\n        return\n", "# \u89e3\u8aacAC\nfrom collections import deque\n\ndef check(d:int):\n    \"\"\" K\u56de\u4ee5\u4e0b\u306e\u64cd\u4f5c\u3067A\u304cd\u306e\u500d\u6570\u3068\u306a\u308b\u304b\u5224\u5b9a\u3059\u308b \"\"\"\n    mod = deque(sorted([a % d for a in A if (a % d != 0)]))\n\n    ans = 0\n    while mod:\n        modmin = mod.popleft() # mod\u306e\u6700\u5c0f\u5024\n\n        # modmin -> 0 \u3092\u8003\u3048\u308b\n        ans += modmin\n        while modmin:\n            if not mod: return False # modmin -> 0 \u306b\u3067\u304d\u306a\u3044\n            modmax = mod.pop()\n            sub = d - modmax # modmax -> d \u306b\u3059\u308b\u64cd\u4f5c\u56de\u6570\n            if sub <= modmin:\n                # modmin -> 0 \u306e\u65b9\u304c\u64cd\u4f5c\u56de\u6570\u304c\u5fc5\u8981\u306a\u5834\u5408\n                modmin -= sub\n            else:\n                # modmax -> d \u306e\u65b9\u304c\u64cd\u4f5c\u56de\u6570\u304c\u5fc5\u8981\u306a\u5834\u5408\n                # (\u203b modmax > d \u3068\u306a\u308b\u3053\u3068\u306f\u306a\u3044)\n                modmax += modmin\n                if modmax % d != 0:\n                    mod.append(modmax)\n                modmin = 0\n    \n    return True if (ans <= K) else False\n    \n\ndef make_divisors(n:int):\n    \"\"\" n\u306e\u7d04\u6570\u3092\u6607\u9806\u3067\u5217\u6319 \"\"\"\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    return divisors\n\n###############################\nN,K = map(int, input().split())\nA = [int(i) for i in input().split()]\n\nsumA_divisors = make_divisors(sum(A))\n\nans = 0\nfor d in sumA_divisors:\n    if check(d):\n        ans = d\n\nprint(ans)", "# \u5272\u308a\u5207\u308b\u6570\u306f\u3001A\u306e\u7dcf\u548c\u306e\u7d04\u6570\u3067\u3042\u308b\n# \u7d04\u6570\u306b\u3064\u3044\u3066\u5927\u304d\u3044\u9806\u306b\u3059\u3079\u3066\u8a66\u3057\u3066\u3001\u5f53\u3066\u306f\u307e\u308b\u3082\u306e\u304c\u3042\u308c\u3070\u7b54\u3048\n\n# 8,20\u30927\u306e\u500d\u6570\u306b\u8fd1\u3065\u3051\u308b\u3068\u304d\u3001\n# 8 -> mod 7\u304c1\u3067\u3042\u308a\u3001-1\u304b+6\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n# 20 -> mod 7\u304c6\u3067\u3042\u308a\u3001-6\u304b+1\u30677\u306e\u500d\u6570\u306b\u306a\u308b\n# \u8ca0\u306e\u548c\u3068\u6b63\u306e\u548c\u304c\u4e00\u81f4\u3057\u305f\u3068\u304d\u3001\u305d\u306e\u3068\u304d\u306e\u7d76\u5bfe\u5024\u304c\u7b54\u3048\n# 1,1,2,3,4,5\u3068\u4e26\u3079\u3066\u3001\u524d\u304b\u3089\u8db3\u3057\u3066\u3044\u304f\u306e\u304c\u6700\u5584\u3002\u5165\u308c\u66ff\u3048\u308b\u3068\u7d76\u5bfe\u5024\u304c\u5897\u52a0\u3059\u308b\u306e\u3067\u640d\u3057\u304b\u3057\u306a\u3044\n\nimport sys\nreadline = sys.stdin.readline\n\nN,K = list(map(int,readline().split()))\nA = list(map(int,readline().split()))\n\nall = sum(A)\ndivisors = []\nfor i in range(1,int(all ** 0.5) + 1):\n  if all % i == 0:\n    divisors.append(i)\n    divisors.append(all // i)\n\ndivisors = sorted(divisors,reverse = True)\n\nfor d in divisors:\n  mods = [0] * (N)\n  for i in range(len(A)):\n    mods[i] = A[i] % d\n  mods = sorted(mods)\n  mods_front = [0] * N\n  mods_front[0] = mods[0]\n  for i in range(1,N):\n    mods_front[i] = mods_front[i - 1] + mods[i]\n  mods_back = [0] * N\n  mods_back[-1] = d - mods[-1]\n  for i in range(N - 2,-1,-1):\n    mods_back[i] = mods_back[i + 1] + (d - mods[i])\n  for i in range(N - 1):\n    if mods_front[i] == mods_back[i + 1]:\n      if K >= mods_front[i]:\n        print(d)\n        return\nelse:\n  print((1))\n", "import numpy as np\n\n\n# \u7d04\u6570\u306e\u5217\u6319\ndef make_divisors(n):\n    divisors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))\n\n\nN, K, *A = map(int, open(0).read().split())\n\nA = np.array(A, np.int64)\nd = make_divisors(A.sum())\n\nfor i in d[::-1]:\n    r = A % i\n    r = r[r != 0]\n    l = r.size\n    if l == 0:\n        print(i)\n        return\n    else:\n        n = np.arange(l - 1, 0, -1)\n    r.sort()\n    np.cumsum(r, out=r)\n    equal = np.where(r[:-1] == i * n - (r[-1] - r[:-1]))[0]\n    if np.any(r[equal] <= K):\n        print(i)\n        return", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nAsum = sum(A)\n\ndiv = set()\nfor i in range(1, int(Asum ** 0.5 + 0.5) + 1):\n    if Asum % i == 0:\n        div.add(i)\n        div.add(Asum//i)\n\nans = 1\nfor d in div:\n    now = 10 ** 18\n    R = [a % d for a in A]\n    R.sort()\n    Rsum = sum(d - r for r in R)\n    Lsum = 0\n    for r in R:\n        Lsum += r\n        Rsum -= d - r\n        now = min(now, max(Lsum, Rsum))\n\n    if now <= K:\n        ans = max(ans, d)\n\nprint(ans)\n", "def divisor(n):\n  ass=[]\n  for i in range(1,int(n**0.5)+1):\n    if n%i==0:\n      ass.append(i)\n      if i!=n//i:ass.append(n//i)\n  return ass\n_,k=map(int,input().split())\na=list(map(int,input().split()))\nfor ans in sorted(divisor(sum(a)))[::-1]:\n  b=[i%ans for i in a if i%ans]\n  n=len(b)\n  b.sort()\n  m=[0]+[i for i in b]\n  p=[ans-i for i in b]+[0]\n  for i in range(n):\n    m[i+1]+=m[i]\n    p[-i-2]+=p[-i-1]\n  flag=False\n  for i in range(n+1):\n    if max(m[i],p[i])>k:continue\n    if abs(m[i]-p[i])%ans!=0:continue\n    flag=True\n  if flag:print(ans);return", "import sys\nfrom itertools import accumulate\nN, K = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\nS = sum(A)\n\ndiv_small = []\ndiv_large = []\nfor p in range(1, int(S**0.5)+1):\n    if S % p == 0:\n        div_small.append(p)\n        if S // p != p:\n            div_large.append(S//p)\ndiv_large += div_small[::-1]\n\nfor d in div_large:\n    R = sorted([a % d for a in A])\n    SR = sum(R)\n    acc = tuple(accumulate(R))\n\n    for i, l in enumerate(acc):\n        r = d*(N-i-1)-(SR-l)\n        if l == r:\n            if l <= K:\n                print(d)\n                return\n            else:\n                break\n", "# \u7d04\u6570\u306e\u5217\u6319\n#############################################################\n\n\ndef make_divisors(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n // i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n#############################################################\n\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nsum_A = sum(A)\ndiv_list = make_divisors(sum_A)\nans = 1\n# print(div_list)\n\nfor div in div_list:\n    tmp = []\n    for a in A:\n        tmp.append(a % div)\n    tmp.sort()\n    cumsum1 = [0]\n    cumsum2 = [0]\n    for i in tmp:\n        cumsum1.append(cumsum1[-1] + i)\n        if i != 0:\n            cumsum2.append(cumsum2[-1] + (div - i))\n        else:\n            cumsum2.append(cumsum2[-1])\n    for i in range(1, N):\n        if cumsum1[i] <= K and cumsum2[N] - cumsum2[i] <= K:\n            ans = div\n\nprint(ans)\n", "def divisors(N):\n    return sorted(sum((list({n, N // n}) for n in range(1, int(N ** 0.5) + 1) if not N % n), []), reverse=True)\nN, K = map(int, input().split())\nA = tuple(map(int, input().split()))\nD = divisors(sum(A))\nfor d in D:\n    L = sorted(a % d for a in A)\n    if not sum(L):\n        print(d)\n        break\n    left, right = 0, N - 1\n    count = 0\n    while left < right:\n        if L[left] + L[right] <= d:\n            next_right = right - (L[right] + L[left] == d)\n            next_left = left + 1\n            L[right] += L[left]\n            count += L[left]\n            L[left] = 0\n        else:\n            next_left = left\n            next_right = right - 1\n            m = d - L[right]\n            count += m\n            L[right] += m\n            L[left] -= m\n        left, right = next_left, next_right\n    if count <= K:\n        print(d)\n        break", "n, k = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\n\ncands = []\nfor x in range(1, int(s ** 0.5) + 1):\n    if s % x == 0:\n        cands.append(x)\n        if x != s // x:\n            cands.append(s // x)\n\ncands.sort(reverse=True)\n#print(cands)\n\nans = 0\nfor cand in cands:\n    b = [a[i] % cand for i in range(n)]\n    b.sort()\n    sb = [0 for _ in range(n+1)]\n    for i in range(n):\n        sb[i+1] = sb[i] + b[i]\n    #print(cand, sb)\n\n    flg = False\n    for i in range(n+1):\n        x = max(sb[i], cand * (n - i) - (sb[n] - sb[i]))\n        #print(i, sb[i], cand * (n - i) - (sb[n] - sb[i]))\n        if x <= k:\n            flg = True\n            break\n\n    if flg:\n        print(cand)\n        break", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\ndef make_divisors(n): # n\u306e\u7d04\u6570\u3092\u5217\u6319\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\n\n# \u5168\u3066\u306e\u5408\u8a08\u306e\u7d04\u6570\u304c\u7b54\u3048\u306e\u5019\u88dc\u3001\u4e0a\u304b\u3089\u53ef\u80fd\u304b\u3069\u3046\u304b\u898b\u3066\u3044\u304f\nN, K = lr()\nA = np.array(lr())\ntotal = A.sum()\nD = make_divisors(total) # \u964d\u9806\nfor d in D:\n    B = A % d   \n    B.sort()\n    inc = d - B\n    B_cum = B.cumsum()\n    inc_cum = inc.cumsum()\n    for i in range(N):\n        x = B_cum[i]\n        y = inc_cum[N-1] - inc_cum[i]\n        if x > K: # x\u306f\u5358\u8abf\u5897\u52a0\n            break\n        if y > K:\n            continue\n        if (x+y) // 2 <= K:\n            print(d); return\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(pow(n, 0.5)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    A = sorted(list(map(int, input().split())))\n\n    div = make_divisors(sum(A))\n    res = 1\n    for x in div:\n        B = sorted([a % x for a in A])\n        M, P = [0], [0]\n        for i in range(n):\n            M.append(M[-1] + B[i])\n            P.append(P[-1] + x - B[i])\n        M.pop(0)\n        P.pop(0)\n        for i in range(n - 1):\n            m = M[i]\n            p = P[n - 1] - P[i]\n            if m <= k and p <= k and m % x == p % x:\n                res = max(res, x)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef solve():\n    N, K = MI()\n    A = LI()\n\n    M = sum(A)\n    divs = []\n    for i in range(1, int(pow(M, 0.5))+1):\n        if M % i: continue\n        divs.append(i)\n        if i != M//i: divs.append(M//i)\n    divs.sort(reverse=True)\n\n    for d in divs:\n        B = list([x%d for x in A])\n        B.sort()\n        C = list([d-x for x in B])\n        # print(d, B, C)\n        # print(list(accumulate(B)), list(accumulate(C)))\n        Ba = list(accumulate(B))\n        Ca = list(accumulate(C))\n        for i in range(0, N-1):\n            b = Ba[i]\n            c = Ca[-1] - Ca[i]\n            # print(b, c)\n            if b == c and b <= K:\n                print(d)\n                return\n    print((1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n,k = list(map(int,input().split()))\nA = list(map(int,input().split()))\nS = sum(A)\nans = 1\ndiv = []\nfor i in range(1,int(S**0.5)+2):\n    if S%i == 0:\n        if S//i != i:\n            div.append(S//i)\n            div.append(i)\n        else:\n            div.append(i)\ndiv.sort()\nL = []\nfor i in range(len(div)):\n    cur = div[i]\n    mod = []\n    for j in range(n):\n        if A[j]%cur != 0:\n            mod.append(A[j]%cur)\n    if len(mod) == 0:\n        ans = max(ans, cur)\n    else:\n        mod.sort()\n        mod_dash = []\n        for j in range(len(mod)):\n            mod_dash.append(cur-mod[j])\n        mod2 = [mod[0]]\n        mod3 = [mod_dash[0]]\n        for j in range(1,len(mod)):\n            t = mod2[j-1]+mod[j]\n            mod2.append(t)\n            u = mod3[j-1]+mod_dash[j]\n            mod3.append(u)\n        c = 10**10\n        for j in range(1,len(mod2)):\n            c = min(c, max(mod2[len(mod2)-j-1],mod3[len(mod3)-1]-mod3[len(mod3)-j-1]))\n        if c <= k:\n            ans = max(ans, cur)\nprint(ans)\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\ns=sum(a)\n\ncandidates=set()\nfor i in range(1,int(s**0.5)+1):\n  if s%i==0:\n    candidates.add(i)\n    candidates.add(s//i)\n\nans=0\nfor cdd in candidates:\n  div_cdd=[0]*n\n  for i in range(n):\n    div_cdd[i]=a[i]%cdd\n  div_cdd=sorted(div_cdd)\n  # calc need\n  idx=n-sum(div_cdd)//cdd\n  need=0\n  for i in range(idx):\n    need+=div_cdd[i]\n  ans=max(ans,cdd) if need<=k else ans\n    \nprint(ans)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef divisors(n):\n    lower = []\n    upper = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            lower.append(i)\n            if i != n // i:\n                upper.append(n // i)\n\n    lower.extend(reversed(upper))\n    return lower\n\n\ndef main():\n    N, K, *A = list(map(int, read().split()))\n\n    total = sum(A)\n    div = divisors(total)\n\n    for d in reversed(div):\n        vec = [a % d for a in A if a % d]\n        if not vec:\n            print(d)\n            return\n        vec.sort()\n        M = len(vec)\n        csum_sub = [0] * (M + 1)\n        csum_add = [0] * (M + 1)\n        for i in range(M):\n            csum_sub[i + 1] = csum_sub[i] + vec[i]\n            csum_add[i + 1] = csum_add[i] + d - vec[i]\n\n        for i in range(1, M):\n            if csum_sub[i] <= K and csum_sub[i] == csum_add[M] - csum_add[i]:\n                print(d)\n                return\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def get_divisors(x):\n    i = 1\n    ret = set()\n    while i * i <= x:\n        if x % i == 0:\n            ret.add(i)\n            ret.add(x // i)\n\n        i += 1\n\n    return ret\n\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsm = sum(a)\ndivs = get_divisors(sm)\n\nans = 0\nfor div in divs:\n    mods = [e % div for e in a]\n    mods.sort()\n    p = 0\n    m = n * div - sum(mods)\n    for mod in mods:\n        p += mod\n        m -= div - mod\n        if p == m:\n            if p <= k:\n                ans = max(ans, div)\n            break\n\nprint(ans)\n", "import math\n\nn,k=map(int,input().split())\n\nA=list(map(int,input().split()))\n\nx=sum(A)\n\nX=[]\n\nfor i in range(1,int(math.sqrt(x))+1):\n    if x%i==0:\n        X.append(i)\n        X.append(x//i)\nX.sort(reverse=True)\n\nfor i in X:\n    B=[]\n    for j in range(n):\n        B.append(A[j]%i)\n    B.sort()\n    if sum(B[:-1*(sum(B)//i)])<=k:\n        print(i)\n        break", "N,K=map(int,input().split())\nalist=list(map(int,input().split()))\n\nsum_a=sum(alist)\nalist.sort()\n#print(sum_a,alist)\n\n#M=1\u306e\u5834\u5408\u306b\u3082\u5bfe\u5fdc\ndivisor_set=set()\nfor i in range(1,int(sum_a**0.5)+1):\n  if sum_a%i==0:\n    divisor_set.add(i)\n    divisor_set.add(sum_a//i)\ndivisor_list=list(divisor_set)\ndivisor_list.sort()\n#print(divisor_list)\n\nanswer=0\nfor d in divisor_list:\n  rlist=[]\n  for a in alist:\n    rlist.append((a%d,(d-a%d)%d))\n  rlist.sort()\n  \n  s1list,s2list=[0],[0]\n  for r1,r2 in rlist:\n    s1list.append(s1list[-1]+r1)\n    s2list.append(s2list[-1]+r2)\n  #print(d,s1list,s2list)\n  \n  for i in range(len(rlist)):\n    r1sum=s1list[i]\n    r2sum=s2list[-1]-s2list[i]\n    if r1sum==r2sum and r1sum<=K:\n      answer=d\n      break\n      \nprint(answer)", "from collections import deque\ndef isok(x):\n    que=deque(sorted(z%x for z in a))\n    res=0\n    while que:\n        l=que[0]\n        if l==0:\n            que.popleft()\n            continue\n        r=que[-1]\n        if r==0:\n            que.pop()\n            continue\n        d=min(l,x-r)\n        que[0]-=d\n        que[-1]=(que[-1]+d)%x\n        res+=d\n    return res\n        \n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nsum_=sum(a)\n\nfac=set()\nfor i in range(1,sum_+1):\n    if i*i>sum_:\n        break\n    if sum_%i==0:\n        fac.add(i)\n        fac.add(sum_//i)\n\nfac=sorted(fac,reverse=True)\nans=1\nfor x in fac:\n    c=isok(x)\n    if c<=k:\n        ans=x\n        break\nprint(ans)"]
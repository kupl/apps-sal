["from collections import defaultdict\nimport itertools\nn, c = map(int, input().split())\nD = [list(map(int, input().split()))for _ in range(c)]\n\n# \u96c6\u8a08\ndiago = [defaultdict(int)for _ in range(3)]\nfor i in range(n):\n    for j, color in enumerate(map(int, input().split())):\n        color -= 1\n        if (i+j) % 3 == 0:\n            diago[0][color] += 1\n        elif (i+j) % 3 == 1:\n            diago[1][color] += 1\n        else:\n            diago[2][color] += 1\n\n\n# 0\u5217\u76ee\u3092c\u306b\u3059\u308b\u3068\u304d\u306ec\u306b\u3059\u308b\u3068\u304d\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\ncosts = [[0]*c for _ in range(3)]\nfor i in range(3):\n    for j in range(c):\n        for k, v in diago[i].items():\n            costs[i][j] += D[k][j]*v\n\nINF = 10**18\nans = INF\nfor trio in itertools.combinations(range(c), 3):\n    for color in itertools.permutations(trio, 3):\n        cost = sum(costs[i][j] for i, j in enumerate(color))\n        if cost < ans:\n            ans = cost\nprint(ans)", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, c = ns()\n    d = [na() for _ in range(c)]\n    color = [na() for _ in range(n)]\n\n    cnt = [[0] * c for _ in range(3)]\n\n    for i in range(n):\n        for j in range(n):\n            cnt[(i + j) % 3][color[i][j] - 1] += 1\n\n    ans = INF\n    for cost in itertools.permutations(list(range(c)), 3):\n        tmp_ans = 0\n        for i in range(3):\n            for j in range(c):\n                tmp_ans += cnt[i][j] * d[j][cost[i]]\n        ans = min(ans, tmp_ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,C = list(map(int,input().split()))\nD = [list(map(int,input().split())) for _ in range(C)]\nc = [list(map(int,input().split())) for _ in range(N)]\n\ncst = [[0,0,0] for i in range(C)]\n\nfor i in range(N):\n    for j in range(N):\n        cst[c[i][j]-1][(i+j)%3] += 1\n\nans = 10**10\n\nfor i in range(C):\n    for j in range(C):\n        for k in range(C):\n            if i == j or i == k or j == k:\n                continue\n            x = [i,j,k]\n            a = 0\n            for l in range(3):\n                for m in range(C):\n                    a += D[m][x[l]]*cst[m][l]\n            ans = min(ans,a)\n\nprint(ans)\n", "N,C = list(map(int,input().split()))\n\ndiscomforts = [[0]*(N+1)]\nfor _ in range(C):\n    row = [0]\n    row.extend(list(map(int,input().split())))\n    discomforts.append(row)\ngrid = [[0]*(N+1)]\nfor _ in range(N):\n    row = [0]\n    row.extend(list(map(int,input().split())))\n    grid.append(row)\n\ncolor_counts = [[0]*(C+1) for i in range(3)]\n\nfor i in range(1,N+1):\n    for j in range(1,N+1):\n        color_counts[(i+j)%3][grid[i][j]] += 1\n\nans = float('inf')\nfor c0 in range(1,C+1):\n    for c1 in range(1,C+1):\n        for c2 in range(1,C+1):\n            if c0 != c1 and c1 != c2 and c2 != c0:\n                total = 0\n                for i in range(1,C+1):\n                    total += discomforts[i][c0]*color_counts[0][i]\n                    total += discomforts[i][c1]*color_counts[1][i]\n                    total += discomforts[i][c2]*color_counts[2][i]\n                ans = min(ans,total)\nprint(ans)", "n,c=map(int,input().split())\nD=[]\nfor i in range(c):\n    D.append(list(map(int,input().split())))\nC=[]\nfor i in range(n):\n    C.append(list(map(int,input().split())))\n    \nA=[[0]*c for i in range(3)]\nfor i in range(n):\n    for j in range(n):\n        a=(i+j)%3\n        A[a][C[i][j]-1]+=1\n\nans=10**100\nfor a0 in range(c):\n    for a1 in range(c):\n        for a2 in range(c):\n            if a0==a1 or a1==a2 or a2==a0:\n                continue\n            cnt=0\n            for i in range(c):\n                cnt+=D[i][a0]*A[0][i]\n                cnt+=D[i][a1]*A[1][i]\n                cnt+=D[i][a2]*A[2][i]\n            ans=min(cnt,ans)\nprint(ans)", "import sys\nfrom itertools import permutations\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, c = list(map(int, input().split()))\n    D = [list(map(int, input().split())) for _ in range(c)]\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    col_cnt = [[0] * c for _ in range(3)]\n    for i in range(n):\n        for j in range(n):\n            col = grid[i][j] - 1\n            col_cnt[(i + j + 2) % 3][col] += 1\n\n    res = f_inf\n    for pattern in permutations(list(range(c)), 3):\n        cost = 0\n        for idx, col in enumerate(pattern):\n            for k in range(c):\n                cnt = col_cnt[idx][k]\n                cost += D[k][col] * cnt\n        res = min(res, cost)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ndef main():\n  input = sys.stdin.readline\n  n, c = map(int, input().split())\n  d = [0 for _ in range(c)]\n  for i in range(c):\n    d[i] = [int(x) for x in input().split()]\n  grid = [0 for _ in range(n)]\n  for i in range(n):\n    grid[i] = [int(x) for x in input().split()]\n  \n  k1, k2, k3 = [0]*c, [0]*c, [0]*c\n  for i in range(n):\n    for j in range(n):\n      if (i+j)%3 == 1:\n        k1[grid[i][j]-1] += 1\n      elif (i+j)%3 == 2:\n        k2[grid[i][j]-1] += 1\n      else:\n        k3[grid[i][j]-1] += 1\n  \n  key1, key2, key3 = [], [], []\n  for i in range(c):\n    sub1, sub2, sub3 = 0, 0, 0\n    for j in range(c):\n      if i == j:\n        continue\n      sub1 += k1[j]*d[j][i]\n      sub2 += k2[j]*d[j][i]\n      sub3 += k3[j]*d[j][i]\n    key1.append([sub1, i])\n    key2.append([sub2, i])\n    key3.append([sub3, i])\n  key1.sort()\n  key2.sort()\n  key3.sort()\n  key1 = key1[:3]\n  key2 = key2[:3]\n  key3 = key3[:3]\n  ans = pow(10, 9)\n  for i in range(3):\n    for j in range(3):\n      for k in range(3):\n        if key1[i][1] != key2[j][1] and key2[j][1] != key3[k][1] and key1[i][1] != key3[k][1]:\n          if ans > key1[i][0]+key2[j][0]+key3[k][0]:\n            ans = key1[i][0]+key2[j][0]+key3[k][0]\n  print(ans)\n  \ndef __starting_point():\n  main()\n__starting_point()", "from collections import Counter\nfrom itertools import permutations\n\nN, C = list(map(int, input().split()))\nD = [list(map(int, input().split())) for i in range(C)]\nc = [list([int(s) - 1 for s in input().split()]) for i in range(N)]\n\nd = [Counter(sum([c[j][(i - j) % 3::3] for j in range(N)], []))\n     for i in range(3)]\nans = 1000000007\nfor t in permutations(list(range(C)), 3):\n    dis = 0\n    for i in range(3):\n        for k, v in list(d[i].items()):\n            dis += D[k][t[i]] * v\n    ans = min(dis, ans)\nprint(ans)\n", "from itertools import permutations\n\nN, C = map(int, input().split())\nD = [list(map(int, input().split())) for _ in range(C)]\nc = [list(map(int, input().split())) for _ in range(N)]\n\n#\u30b0\u30ea\u30c3\u30c9\u5ea7\u6a19\u30923\u7a2e\u985e\u306b\u5206\u3051\u308b\nrem = [[] for _ in range(3)]\nfor i in range(N):\n    for j in range(N):\n        rem[(i+j+2)%3].append(c[i][j])\n# print(rem)\n\ncost = [[] for _ in range(3)]\n\nfor i in range(3):\n    for s in range(C):\n        tmp = 0\n        for t in rem[i]:\n            tmp += D[t-1][s]\n        cost[i].append((tmp, s+1))\n\nfor i in cost:\n    i.sort()\n    i = i[:3]\n \nans = 1e10\nfor i in cost[0]:\n    for j in cost[1]:\n        for h in cost[2]:\n            if i[1] != j[1] and j[1] != h[1] and h[1] != i[1]:\n                ans = min(ans,i[0]+j[0]+h[0])\nprint(ans)", "from collections import defaultdict\nfrom itertools import permutations\n\nn, c = list(map(int, input().split()))\nd = [list(map(int, input().split())) for _ in range(c)]\ncmat = [list(map(int, input().split())) for _ in range(n)]\n\ndcnt = [defaultdict(int) for _ in range(3)]\nfor i, ci in enumerate(cmat, 1):\n    for j, cij in enumerate(ci, 1):\n        mod = (i + j) % 3\n        dcnt[mod][cij - 1] += 1\n\nans = 10 ** 9\nfor color in permutations(list(range(c)), 3):\n    if len(set(color)) == 3:\n        tmp = 0\n        for i, cnt in enumerate(dcnt):\n            tmp += sum(d[k][color[i]] * cnt[k] for k in cnt)\n        ans = min(ans, tmp)\nprint(ans)\n", "from collections import Counter\nfrom itertools import permutations\n\nn, c = map(int, input().split())\n\na = []\nb = []\n\nfor _ in range(c):\n    array = list(map(int, input().split()))\n    a.append(array)\n\nfor _ in range(n):\n    array = list(map(int, input().split()))\n    b.append(array)\n\n\ngroup1 = []\ngroup2 = []\ngroup3 = []\n\nfor i in range(n):\n    for j in range(n):\n        if (i + j) % 3 == 0:\n            group1.append(b[i][j])\n        elif (i + j) % 3 == 1:\n            group2.append(b[i][j])\n        else:\n            group3.append(b[i][j])\n\ng1 = Counter(group1)\ng2 = Counter(group2)\ng3 = Counter(group3)\n\nsum1 = []\nsum2 = []\nsum3 = []\n\n\ndef cal(l, output):\n    for i in range(c):\n        s = 0\n        for j in l.items():\n            s += a[j[0]-1][i-1] * j[1]\n        output.append(s)\n\n\nli = [g1, g2, g3]\nli2 = [sum1, sum2, sum3]\n\nfor i in range(3):\n    cal(li[i], li2[i])\n\ncc = list(range(c))\n\nmin_sum = 10**10\nfor i, j, k in permutations(cc, 3):\n    sum = sum1[i] + sum2[j] + sum3[k]\n    if sum < min_sum:\n        min_sum = sum\n\nprint(min_sum)", "n, c = list(map(int, input().split()))\nD = [tuple(map(int, input().split())) for _ in range(c)]\nC = [tuple([int(x)-1 for x in input().split()]) for _ in range(n)]\n\ncols = [[0] * c for _ in range(3)]\nfor i in range(n):\n    for j in range(n):\n        c_from = C[i][j]\n        cols[(i+j)%3][c_from] += 1\n\nfrom itertools import permutations\nd = 1000*500*500\nfor p0, p1, p2 in permutations(list(range(c)), 3):\n    d_ = 0\n    for c_from in range(c):\n        d_ += cols[0][c_from]*D[c_from][p0]\n        d_ += cols[1][c_from]*D[c_from][p1]\n        d_ += cols[2][c_from]*D[c_from][p2]\n    d = min(d, d_)\nprint(d)\n", "#\u611a\u76f4\u56de \uff13\u91cd\u30eb\u30fc\u30d7 30x30x30x500x500=6.75*10**9 \u53b3\u3057\u3044\u304b\u3002\u3002\u3002\n#\u30e1\u30e2\u5316\u3057\u3068\u3051\u3070\u3044\u3051\u308b\uff1f-->python TLE, pypy3 262ms #17206796\n#\u51fa\u73fe\u3059\u308b\u3082\u306e\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u304a\u304f\nmemo_mod = [[-1]*31 for _ in range(3)]\nmemo_app = [[0]*31 for _ in range(3)]\n\nN,C = list(map(int,input().split()))\nD = [list(map(int,input().split())) for _ in range(C)]\nc = [list(map(int,input().split())) for _ in range(N)]\nfa=float('inf')\n\nfor i in range(N):\n    for j in range(N):\n        memo_app[(i+j)%3][c[i][j]] +=1\n\nfor mod0 in range(1,C+1):\n    for mod1 in range(1,C+1):\n        for mod2 in range(1,C+1):\n            if mod0 == mod1 or mod1==mod2 or mod2==mod0:\n                continue\n            else:\n                ans = 0\n                if memo_mod[0][mod0]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[0][idx]*D[idx-1][mod0-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[0][mod0]\n\n                if memo_mod[1][mod1]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[1][idx]*D[idx-1][mod1-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[1][mod1]\n\n\n                if memo_mod[2][mod2]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[2][idx]*D[idx-1][mod2-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[2][mod2]\n                fa = min(fa,ans)\nprint(fa)\n", "n,c = map(int, input().split())\n\ndl = [list(map(int, input().split())) for _ in range(c)]\nnl = [list(map(int, input().split())) for _ in range(n)]\n\nax = [[0 for i in range(c)] for j in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        x = (i+j) % 3\n        ax[x][nl[i][j]-1] += 1\n\nl = list(range(0,c))\nimport itertools\nll = list(itertools.permutations(l, 3))\nres = float('inf')\n\n#ax\u3092\u5909\u63db\u3057\u3066\u3044\u304f\u30b3\u30b9\u30c8\u3092\u5168\u5217\u6319\nfor i in ll:\n    temp= 0\n    for j in range(c):\n        temp += ax[0][j]*dl[j][i[0]]\n        temp += ax[1][j]*dl[j][i[1]]\n        temp += ax[2][j]*dl[j][i[2]]\n    res= min(res,temp)\nprint(res)", "n , c = list(map(int,input().split()))\niwaka = [list(map(int,input().split())) for i in range(c)]\nmasu = [list(map(int,input().split())) for i in range(n)]\namari = [{} for i in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        amari[(i+j)%3][masu[i][j]] = amari[(i+j)%3].get(masu[i][j],0) + 1\n\nkouho = []\nfor i in range(c):\n    for j in range(c):\n        for k in range(c):\n            if i != j and j != k and k != i:\n                kouho.append((i+1,j+1,k+1))\nans = 10**9\nfor p in kouho:\n    cou = 0\n    for i in range(3):\n        for k , v in list(amari[i].items()):\n            cou += iwaka[k-1][p[i]-1]*v\n    ans = min(ans,cou)\nprint(ans)\n", "n,c = map(int,input().split())\nd = [list(map(int,input().split())) for i in range(c)]\ns = [list(map(int,input().split())) for i in range(n)]\nx = [0] * c\ny = [0] * c\nz = [0] * c\nfor i in range(n):\n    for j in range(n):\n        a = (i+j) % 3\n        if a == 0:\n            x[s[i][j]-1] += 1\n        if a == 1:\n            y[s[i][j]-1] += 1\n        if a == 2:\n            z[s[i][j]-1] += 1\nans = 10 ** 16\nfor i in range(c):\n    for j in range(c):\n        for k in range(c):\n            if i != j and i != k and j != k:\n                o = 0\n                for l in range(c):\n                    o += d[l][i] * x[l]\n                p = 0\n                for l in range(c):\n                    p += d[l][j] * y[l]\n                q = 0\n                for l in range(c):\n                    q += d[l][k] * z[l]\n                ans = min(ans,o+p+q)\nprint(ans)", "from itertools import permutations\n\nN, C = map(int, input().split())\n\nD = []\nfor _ in range(C):\n  Ds = list(map(int, input().split()))\n  D.append(Ds)\n\ngrid = []\nfor _ in range(N):\n  c = list(map(lambda x: int(x)-1, input().split()))\n  grid.append(c)\n\ncolor = [[0]*C for _ in range(3)]\n\nfor i in range(N):\n  for j in range(N):\n    color[(i+j)%3][grid[i][j]] += 1\n\nINF = 10**9\nans = INF\n\nfor cols in permutations(range(C), 3):\n  temp = 0\n  for i, Y in enumerate(cols):\n    for X, cnt in enumerate(color[i]):\n      temp += D[X][Y] * cnt\n  ans = min(ans, temp)\n\nprint(ans)", "from sys import stdin\nimport numpy as np\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,max_c=map(int,readline().split())\n    d=[list(map(int,readline().split())) for _ in range(max_c)]\n    d=np.array(d,dtype=np.int64)\n    c=[list(map(lambda x:int(x)-1,readline().split())) for _ in range(n)]\n\n    #\u524d\u51e6\u7406\n    color_table=np.zeros((3,max_c),dtype=np.int64)\n    for i in range(n):\n        for j in range(n):\n            color_table[(i+j+2)%3,:]+=d[c[i][j],:]\n\n    #\u5168\u63a2\u7d22\n    ans=float(\"inf\")\n    for i in range(max_c):\n        for j in range(max_c):\n            for k in range(max_c):\n                if i==j or j==k or k==i:\n                    continue\n                ans=min(ans,color_table[0][i]+color_table[1][j]+color_table[2][k])\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\nfrom itertools import product, permutations\ndef main():\n    n, c = map(int, input().split())\n    D = [list(map(int, input().split())) for _ in range(c)]\n    C = [list(map(lambda x:int(x)-1, input().split())) for _ in range(n)]\n\n    group = [Counter([C[i][j] for i,j in product(range(n), range(n)) if (i+j+2) %3 == k]) for k in range(3)] \n    \n    ans = float('inf')\n    for color in permutations(range(c), 3):\n        diff = 0\n        for i in range(3):\n            diff += sum(D[before_color][color[i]]*count for before_color, count in group[i].items())\n        ans = min(ans, diff)\n    print(ans)\n\nmain()", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, C = map(int, input().split())\nCM = [list(map(int, input().split())) for _ in range(C)]\nNM = [list(map(int, input().split())) for _ in range(N)]\n\ncnt = [[0] * (C + 1) for _ in range(3)]\n\nfor i in range(N):\n    for j in range(N):\n        cnt[(i + j + 2) % 3][NM[i][j]] += 1\n\nans = 1 << 28\nfor i in range(1, C + 1):\n    for j in range(1, C + 1):\n        for k in range(1, C + 1):\n            if i == j or j == k or i == k:\n                continue\n            c = 0\n            for l in range(1, C + 1):\n                c += cnt[0][l] * CM[l - 1][i - 1]\n                c += cnt[1][l] * CM[l - 1][j - 1]\n                c += cnt[2][l] * CM[l - 1][k - 1]\n            ans = min(ans, c)\n\nprint(ans)", "n,c=list(map(int,input().split()))\ndiff=[list(map(int, input().split())) for _ in range(c)]\ncolor=[list(map(int, input().split())) for _ in range(n)]\n\ndic=[[0]*c for _ in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        dic[(i+j)%3][color[i][j]-1]+=1\n\nresult=10**9\n\nfor aa in range(c):\n    #%0\u306e\u8272\u3092aa\u306b\u3059\u308b\n    a_cost=0\n    for j in range(c):\n        a_cost+=dic[0][j]*diff[j][aa]\n\n\n    for bb in range(c):\n        if aa!=bb:\n            #%1\u306e\u8272\u3092bb\u306b\u3059\u308b\n            b_cost=0\n            for j in range(c):\n                b_cost+=dic[1][j]*diff[j][bb]\n\n            for cc in range(c):\n                if aa!=bb and bb!=cc and cc!=aa:\n                    #%2\u306e\u8272\u3092cc\u306b\u3059\u308b\n                    c_cost=0\n                    for j in range(c):\n                        c_cost+=dic[2][j]*diff[j][cc]\n                    result=min(result,a_cost+b_cost+c_cost)\n\nprint(result)\n\n", "# # coding: utf-8\n# # Your code here!\n\n# //\u89e3\u8aac\n# #include <iostream>\n# #define rep(i,n) for(int i=0;i<n;i++)\n# using namespace std;\n# int N,C,X;\n# int D[33][33];\n# int t[3][33];\n# int main(void)\n# {\n#     scanf(\"%d%d\",&N,&C);\n#     rep(i,C)rep(j,C)scanf(\"%d\",&D[i][j]);\n#     rep(i,N)rep(j,N)scanf(\"%d\",&X),t[(i+j)%3][X-1]++;\n#     int res=1<<30;\n#     rep(i,C)rep(j,C)if(i!=j)rep(k,C)if(i!=k&&j!=k)\n#     {\n#         int tt=0;\n#         rep(l,C)tt+=D[l][i]*t[0][l];\n#         rep(l,C)tt+=D[l][j]*t[1][l];\n#         rep(l,C)tt+=D[l][k]*t[2][l];\n#         if(tt<res)res=tt;\n#     }\n#     printf(\"%d\\n\",res);\n# }\n\n\nfrom collections import defaultdict\nN,C=list(map(int,input().split()))\nD=defaultdict(int)\nt=defaultdict(int)\n\nfor i in range(C):\n    s=list(map(int,input().split()))\n    for j in range(C):\n        D[(i,j)]=s[j]\nfor i in range(N):\n    s=list(map(int,input().split()))\n    for j in range(N):\n        t[((i+j)%3,s[j]-1)]+=1\nans=1<<30\nfor i in range(C):\n    for j in range(C):\n        for k in range(C):\n            if i!=j!=k!=i:\n                res=0\n                for l in range(C):res+=D[(l,i)]*t[(0,l)]\n                for l in range(C):res+=D[(l,j)]*t[(1,l)]\n                for l in range(C):res+=D[(l,k)]*t[(2,l)]\n                ans=min(ans,res)\n\n                \nprint(ans)\n                \n\n", "import sys\nfrom itertools import permutations\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, C = list(map(int, readline().split()))\n    D = [0] * C\n    for i in range(C):\n        D[i] = list(map(int, readline().split()))\n    G = [0] * N\n    for i in range(N):\n        G[i] = [int(s) - 1 for s in readline().split()]\n\n    cost = [[0] * C for _ in range(3)]\n    for x in range(N):\n        for y in range(N):\n            color = G[x][y]\n            cost_current = cost[(x + y) % 3]\n            for i in range(C):\n                cost_current[i] += D[color][i]\n\n    ans = INF\n    for c1, c2, c3 in permutations(list(range(C)), 3):\n        if ans > cost[0][c1] + cost[1][c2] + cost[2][c3]:\n            ans = cost[0][c1] + cost[1][c2] + cost[2][c3]\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#\u611a\u76f4\u56de \uff13\u91cd\u30eb\u30fc\u30d7 30x30x30x500x500=6.75*10**9 \u53b3\u3057\u3044\u304b\u3002\u3002\u3002\n#\u30e1\u30e2\u5316\u3057\u3068\u3051\u3070\u3044\u3051\u308b\uff1f-->python TLE, pypy3 262ms #17206796\n#\u51fa\u73fe\u3059\u308b\u3082\u306e\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u304a\u304f\nmemo_mod = [[-1]*31 for _ in range(3)]\nmemo_app = [[0]*31 for _ in range(3)]\n\nN,C = list(map(int,input().split()))\nD = [list(map(int,input().split())) for _ in range(C)]\nc = [list(map(int,input().split())) for _ in range(N)]\nfa=float('inf')\n\nfor i in range(N):\n    for j in range(N):\n        memo_app[(i+j)%3][c[i][j]] +=1\n\nfor mod0 in range(1,C+1):\n    for mod1 in range(1,C+1):\n        if mod0 == mod1:\n            continue\n        for mod2 in range(1,C+1):\n            if  mod1==mod2 or mod2==mod0:\n                continue\n            else:\n                ans = 0\n                if memo_mod[0][mod0]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[0][idx]*D[idx-1][mod0-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[0][mod0]\n\n                if memo_mod[1][mod1]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[1][idx]*D[idx-1][mod1-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[1][mod1]\n\n\n                if memo_mod[2][mod2]== -1:\n                    tmp = 0\n                    for idx in range(1,C+1):\n                        tmp += memo_app[2][idx]*D[idx-1][mod2-1]\n                    ans += tmp\n                else:\n                    ans += memo_mod[2][mod2]\n                fa = min(fa,ans)\nprint(fa)\n", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\n# \u5165\u529b\u306e C \u306f M \u3068\u3059\u308b\nN,M = map(int,input().split())\nD = [list(map(int,input().split())) for _ in range(M)]\nC = [list(map(int,input().split())) for _ in range(N)]\n\n# X[x][y] : (i+j)%3 == x \u306e, \u521d\u671f\u72b6\u614b\u3067\u306e\u8272\u304c y(0-indexed) \u306e\u30de\u30b9\u306e\u6570\nX = [[0 for _ in range(M)] for _ in range(3)]\nfor i in range(N):\n    for j in range(N):\n        x = (i+1 + j+1)%3\n        y = C[i][j] - 1\n        X[x][y] += 1\n\n# Y[x][y] : (i+j)%3 == x \u306e\u9818\u57df\u3092 y \u3067\u5857\u308b\u5834\u5408\u306b\u5fc5\u8981\u306a\u30b3\u30b9\u30c8\nY = [[0 for _ in range(M)] for _ in range(3)]\nfor i in range(3):\n    for c_to in range(M):\n        total = 0\n        for c_from in range(M):\n            total += X[i][c_from] * D[c_from][c_to]\n        Y[i][c_to] = total\n\nans = 10**10\n# \u5857\u308b\u8272\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u5168\u63a2\u7d22\nfor i in range(M):\n    for j in range(M):\n        for k in range(M):\n            # \u5168\u3066\u306e\u8272\u304c\u7570\u306a\u308b\u5834\u5408\u306e\u307f\u8003\u3048\u308b\n            if i != j and j != k and k != i:\n                ans = min(ans, Y[0][i] +Y[1][j] + Y[2][k] )\n\nprint(ans)", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nsys.setrecursionlimit(20000000)\n\nMOD = 10 ** 9 + 7\nINF = float(\"inf\")\n\n\ndef main():\n    N, C = list(map(int, input().split()))\n    D = [list(map(int, input().split())) for _ in range(C)]\n    c = [list(map(int, input().split())) for _ in range(N)]\n    R = [[] for _ in range(3)]\n\n    for i in range(N):\n        for j in range(N):\n            r = (i + 1) + (j + 1)\n            if r % 3 == 0:\n                R[0].append(c[i][j])\n            elif r % 3 == 1:\n                R[1].append(c[i][j])\n            else:\n                R[2].append(c[i][j])\n    Diff = [[] for _ in range(3)]\n    for i in range(3):\n        l = len(R[i])\n\n        for color in range(C):\n            cnt = 0\n            for j in range(l):\n                cnt += D[R[i][j] - 1][color]\n            Diff[i].append(cnt)\n    answer = INF\n    for i in range(C):\n        for j in range(C):\n            for k in range(C):\n                if i == j or j == k or k == i:\n                    continue\n                else:\n                    ans = Diff[0][i] + Diff[1][j] + Diff[2][k]\n                    if ans < answer:\n                        answer = ans\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,C=map(int, input().split())\nD=[list(map(int, input().split())) for _ in range(C)]\nc=[list(map(int, input().split())) for _ in range(N)]\nC0=[0]*C\nC1=[0]*C\nC2=[0]*C\nfor i in range(N):\n  for j in range(N):\n    if (i+j)%3==0:\n      C0[c[i][j]-1]+=1\n    elif (i+j)%3==1:\n      C1[c[i][j]-1]+=1\n    else:\n      C2[c[i][j]-1]+=1\n      \nimport itertools\nA=list(itertools.permutations(range(1,C+1),3))\nans=1000*250000\nfor a,b,c in A:\n  d=0\n  for i in range(C):\n    d+=C0[i]*D[i][a-1]\n    d+=C1[i]*D[i][b-1]\n    d+=C2[i]*D[i][c-1]\n  ans=min(ans,d)\nprint(ans)", "\nfrom collections import defaultdict\n\nN,C = list(map(int, input().split()))\nD = [tuple(map(int, input().split())) for _ in range(C)]\ngrid = [tuple(map(int, input().split())) for _ in range(N)]\n\n\n# mod_x : (i+j)%3\u304cx\u3067\u3001key\u306f\u8272\u3001value\u306f\u500b\u6570\nmod_0 = defaultdict(int)\nmod_1 = defaultdict(int)\nmod_2 = defaultdict(int)\n\n\nfor i in range(N):\n    for j in range(N):\n        if (i+1 + j+1) % 3 == 0:\n            mod_0[grid[i][j]] += 1\n        elif (i+1 + j+1) % 3 == 1:\n            mod_1[grid[i][j]] += 1\n        elif (i+1 + j+1) % 3 == 2:\n            mod_2[grid[i][j]] += 1\n\nans = float(\"inf\")\n# mod_0\u306e\u30de\u30b9\u306b\u3042\u308b\u3082\u306e\u3092i\u306b\u3001mod_1\u306e\u3082\u306e\u3092j\u306b\u3001mod_2\u306e\u3082\u306e\u3092k\u306b\u5857\u308a\u66ff\u3048\u308b\nfor i in range(C):\n    for j in range(C):\n        if i == j: continue\n        for k in range(C):\n            if k in [i,j]:\n                continue\n\n            total = 0\n            for prev,cnt in list(mod_0.items()):\n                total += D[prev-1][i] * cnt\n            for prev,cnt in list(mod_1.items()):\n                total += D[prev-1][j] * cnt\n            for prev,cnt in list(mod_2.items()):\n                total += D[prev-1][k] * cnt\n\n            ans = min(ans, total)\n\nprint(ans)\n", "from itertools import *\nN,C = map(int,input().split())\nD = [list(map(int,input().split())) for c in range(C)]\nG = [list(map(int,input().split())) for n in range(N)]\nH = [C*[0] for n in range(3)]\n\nfor i in range(N):\n  for j,k in enumerate(G[i]):\n    H[(i+j)%3][k-1]+=1\n\nans = float(\"inf\")\n\nfor i in permutations(range(C),3):\n  c = 0\n  for j in range(3):\n    for k in range(C):\n      c+=D[k][i[j]]*H[j][k]\n  ans = min(ans,c)\n\nprint(ans)", "# \u76ee\u6307\u3059\u30b0\u30ea\u30c3\u30c9\u306f\n# ABCABCABC..\n# BCABCABCA..\n# CABCABCAB..\n# ABCABCABC..\n# ...\n# N = 500\u306a\u306e\u3067\u7dcf\u30de\u30b9\u6570\u306f250000\n# \u8272\u306e\u7a2e\u985e\u306f30\u7a2e\u985e\n# \u3059\u3079\u3066\u306e\u30de\u30b9\u3092\u3042\u307e\u308a\u3054\u3068\u306b3\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\n# \u5404\u30b0\u30eb\u30fc\u30d7\u306b\u304a\u3044\u3066\u3001\u5404\u8272\u304c\u4f55\u30de\u30b9\u305a\u3064\u3042\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b\u3002250000\u56de\n# \u9577\u305530\u306e\u914d\u5217 * 3\u306b\u306a\u308b\u306e\u3067\u3042\u3068\u306f\u5909\u66f4\u5148\u306e\u8272\u3092\u3059\u3079\u3066\u8a66\u3059\u300230 * 3\u56de\n# \u96a3\u3042\u3063\u305f\u30de\u30b9\u3092\u540c\u3058\u8272\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u306a\u3044\u305f\u3081\u3001\n# \u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306b\u5019\u88dc\u30923\u4f4d\u307e\u3067\u7528\u610f\u3057\u30013 * 3 * 3 = 27\u901a\u308a\u3092\u3059\u3079\u3066\u8a66\u3059\u3002\n# 3\u4f4d\u30684\u4f4d\u304c\u30bf\u30a4\u306e\u3068\u304d\u306f\u3069\u3063\u3061\u3092\u53d6\u3063\u3066\u3082\u5927\u4e08\u592b\n\nN,C = list(map(int,input().split()))\n\nD = [[0]*C for i in range(C)] # \u9055\u548c\u611f\nfor i in range(C):\n  D[i] = list(map(int,input().split())) # \u8272\u306f0-index\u3067\u6307\u5b9a\n  # D[i][j]\u3067\u3001i\u3092j\u306b\u5909\u3048\u308b\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u7b97\u51fa\n\n# print(D)\n\ngroups = [[0]*C for i in range(3)]\n\nfor i in range(N):\n  line = list(map(int,input().split()))\n  for j in range(len(line)):\n    groups[(i+j)%3][line[j] - 1] += 1\n\n# groups[i(\u30b0\u30eb\u30fc\u30d7\u540d)][j(\u8272 0-index)] = \u8a72\u5f53\u3059\u308b\u500b\u6570 \u304c\u51fa\u6765\u305f\u3002\n# \u5404\u30b0\u30eb\u30fc\u30d7\u306b\u5bfe\u3057\u3066\u3001\u5404\u8272\u306b\u5857\u308a\u66ff\u3048\u305f\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u8a08\u7b97\u3059\u308b\npattern = [[[0]*2 for j in range(C)] for i in range(3)]\n# pattern[i(\u30b0\u30eb\u30fc\u30d7\u540d)][j(\u8272 0-index))] = \u5bfe\u8c61\u306e\u8272\u306b\u5857\u308a\u66ff\u3048\u305f\u3068\u304d\u306e\u9055\u548c\u611f\n# 30 * 30 = 900, 900 * 3 = 2700\n\nfor i in range(len(groups)):\n  # \u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u30eb\u30fc\u30d7\n  for j in range(C):\n    # \u5909\u66f4\u5f8c\u306e\u8272j\n    iwakan = 0 # \u8272j\u306b\u5909\u3048\u308b\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u7d2f\u7a4d\n    for k in range(len(groups[i])):\n      # \u30b0\u30eb\u30fc\u30d7i\u306b\u306f\u8272k\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n      iwakan += groups[i][k] * D[k][j]\n    pattern[i][j][0] = iwakan\n    pattern[i][j][1] = j # \u3042\u3068\u3067\u4e26\u3073\u66ff\u3048\u308b\u305f\u3081\u3001\u4f55\u8272\u306b\u5909\u3048\u308b\u304b\u3092\u30e1\u30e2\u3057\u3066\u304a\u304f\n\nfor i in range(len(pattern)):\n  pattern[i] = sorted(pattern[i],key = lambda x:x[0])\n\nans = 10 ** 9 + 7\nfor a in range(3): # \u30b0\u30eb\u30fc\u30d71\u304c\u4f55\u4f4d\u306e\u6570\u5b57\u3092\u4f7f\u3046\u304b\n  for b in range(3): # \u540c2\n    if pattern[0][a][1] == pattern[1][b][1]:\n      continue\n    for c in range(3): # \u540c3\n      if pattern[0][a][1] == pattern[2][c][1]:\n        continue\n      if pattern[1][b][1] == pattern[2][c][1]:\n        continue\n      val = pattern[0][a][0] + pattern[1][b][0] + pattern[2][c][0]\n      if val < ans:\n        ans = val\nprint(ans)\n    \n", "from collections import defaultdict\n\nN,C=map(int,input().split())\nD=[list(map(int,input().split())) for _ in range(C)]\ngrid=[list(map(int,input().split())) for _ in range(N)]\n\nmod_0=defaultdict(int)\nmod_1=defaultdict(int)\nmod_2=defaultdict(int)\n\nfor i in range(N):\n    for j in range(N):\n        n=(i+j+2)%3\n        if n==0:\n            mod_0[grid[i][j]]+=1\n        elif n==1:\n            mod_1[grid[i][j]]+=1\n        else:\n            mod_2[grid[i][j]]+=1\n\nans=float(\"inf\")\nfor i in range(C):\n    for j in range(C):\n        if i==j:\n            continue\n        for k in range(C):\n            if k in [i,j]:\n                continue\n\n            total=0\n            for prev,cnt in mod_0.items():\n                total+=D[prev-1][i]*cnt\n            for prev,cnt in mod_1.items():\n                total+=D[prev-1][j]*cnt\n            for prev,cnt in mod_2.items():\n                total+=D[prev-1][k]*cnt\n            \n            ans=min(ans,total)\nprint(ans)", "import itertools\n\n\ndef calc(colo, target, d_mtx):\n    ret = 0\n    for i, item in enumerate(colo):\n        ret += item * d_mtx[i][target]\n    return ret\n\n\nn, c = list(map(int, input().split()))\nd_mtx = []\nc_mtx = []\n\nfor i in range(c):\n    d_mtx.append(list(map(int, input().split())))\n\nfor i in range(n):\n    c_mtx.append(list(map(int, input().split())))\n\ncolor = [[0] * c for _ in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        color[((i+1)+(j+1)) % 3][c_mtx[i][j]-1] += 1\n\nret = 10 ** 10\nfor item in itertools.permutations(list(range(c)), 3):\n    tmp = 0\n    for i in range(3):\n        tmp += calc(color[i], item[i], d_mtx)\n    ret = min(ret, tmp)\n\nprint(ret)\n", "# D - Good Grid\n\nfrom collections import defaultdict\nimport itertools\n\nN, C = map(int, input().split())\nD = [[0] * C for _ in range(C)]\nfor i in range(C):\n    D[i] = list(int(d) for d in input().split())\n\n# MOD3\u306e\u4e16\u754c\u30670,1,2\u3054\u3068\u306b\u3001\u6700\u521d\u306e\u5024\u306e\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u304a\u304f\ndict_c = [defaultdict(int) for _ in range(3)]\nfor i in range(N):\n    c = list(int(x) for x in input().split())\n    for j in range(N):\n        dict_c[(i+j)%3][c[j]-1] += 1\n\n# \u3053\u3053\u304b\u3089\u306f\u5168\u63a2\u7d22\u3002\n# 0, 1, 2\u306e\u5404\u914d\u5217\u306b\u5bfe\u3057\u3066\u3001\u5168\u3066\u306e\u8272\u3092\u8a66\u3059(C**3)\nlist_C = list(range(C))\nans = 10**18\nfor (p, q, r) in itertools.permutations(list_C, 3):\n    tmp = 0\n    for i, j in enumerate((p, q, r)):\n        for m, n in dict_c[i].items():\n            tmp += D[m][j] * n\n    ans = min(ans, tmp)\n\nprint(ans)", "# \u76ee\u6307\u3059\u30b0\u30ea\u30c3\u30c9\u306f\n# ABCABCABC..\n# BCABCABCA..\n# CABCABCAB..\n# ABCABCABC..\n# ...\n# N = 500\u306a\u306e\u3067\u7dcf\u30de\u30b9\u6570\u306f250000\n# \u8272\u306e\u7a2e\u985e\u306f30\u7a2e\u985e\n# \u3059\u3079\u3066\u306e\u30de\u30b9\u3092\u3042\u307e\u308a\u3054\u3068\u306b3\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\n# \u5404\u30b0\u30eb\u30fc\u30d7\u306b\u304a\u3044\u3066\u3001\u5404\u8272\u304c\u4f55\u30de\u30b9\u305a\u3064\u3042\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b\u3002250000\u56de\n# \u9577\u305530\u306e\u914d\u5217 * 3\u306b\u306a\u308b\u306e\u3067\u3042\u3068\u306f\u5909\u66f4\u5148\u306e\u8272\u3092\u3059\u3079\u3066\u8a66\u3059\u300230 * 3\u56de\n# \u96a3\u3042\u3063\u305f\u30de\u30b9\u3092\u540c\u3058\u8272\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u306a\u3044\u305f\u3081\u3001\n# \u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306b\u5019\u88dc\u30923\u4f4d\u307e\u3067\u7528\u610f\u3057\u30013 * 2 * 1\u306f6\u901a\u308a\u3092\u3059\u3079\u3066\u8a66\u3059\u3002\n# 3\u4f4d\u30684\u4f4d\u304c\u30bf\u30a4\u306e\u3068\u304d\u306f\u3069\u3063\u3061\u3092\u53d6\u3063\u3066\u3082\u5927\u4e08\u592b\n\nN,C = list(map(int,input().split()))\n\nD = [[0]*C for i in range(C)] # \u9055\u548c\u611f\nfor i in range(C):\n  D[i] = list(map(int,input().split())) # \u8272\u306f0-index\u3067\u6307\u5b9a\n  # D[i][j]\u3067\u3001i\u3092j\u306b\u5909\u3048\u308b\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u7b97\u51fa\n\n# print(D)\n\ngroups = [[0]*C for i in range(3)]\n\nfor i in range(N):\n  line = list(map(int,input().split()))\n  for j in range(len(line)):\n    groups[(i+j)%3][line[j] - 1] += 1\n\n# groups[i(\u30b0\u30eb\u30fc\u30d7\u540d)][j(\u8272 0-index)] = \u8a72\u5f53\u3059\u308b\u500b\u6570 \u304c\u51fa\u6765\u305f\u3002\n# \u5404\u30b0\u30eb\u30fc\u30d7\u306b\u5bfe\u3057\u3066\u3001\u5404\u8272\u306b\u5857\u308a\u66ff\u3048\u305f\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u8a08\u7b97\u3059\u308b\npattern = [[[0]*2 for j in range(C)] for i in range(3)]\n# pattern[i(\u30b0\u30eb\u30fc\u30d7\u540d)][j(\u8272 0-index))] = \u5bfe\u8c61\u306e\u8272\u306b\u5857\u308a\u66ff\u3048\u305f\u3068\u304d\u306e\u9055\u548c\u611f\n# 30 * 30 = 900, 900 * 3 = 2700\n\nfor i in range(len(groups)):\n  # \u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u30eb\u30fc\u30d7\n  for j in range(C):\n    # \u5909\u66f4\u5f8c\u306e\u8272j\n    iwakan = 0 # \u8272j\u306b\u5909\u3048\u308b\u3068\u304d\u306e\u9055\u548c\u611f\u3092\u7d2f\u7a4d\n    for k in range(len(groups[i])):\n      # \u30b0\u30eb\u30fc\u30d7i\u306b\u306f\u8272k\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n      iwakan += groups[i][k] * D[k][j]\n    pattern[i][j][0] = iwakan\n    pattern[i][j][1] = j # \u3042\u3068\u3067\u4e26\u3073\u66ff\u3048\u308b\u305f\u3081\u3001\u4f55\u8272\u306b\u5909\u3048\u308b\u304b\u3092\u30e1\u30e2\u3057\u3066\u304a\u304f\n\nfor i in range(len(pattern)):\n#  print(\"bef\",pattern[i])\n  pattern[i] = sorted(pattern[i],key = lambda x:x[0])\n#  print(\"after\",pattern[i])\n\nans = 10 ** 9 + 7\nfor a in range(3): # \u30b0\u30eb\u30fc\u30d71\u304c\u4f55\u4f4d\u306e\u6570\u5b57\u3092\u4f7f\u3046\u304b\n  for b in range(3): # \u540c2\n    if pattern[0][a][1] == pattern[1][b][1]:\n      continue\n    for c in range(3): # \u540c3\n      if pattern[0][a][1] == pattern[2][c][1]:\n        continue\n      if pattern[1][b][1] == pattern[2][c][1]:\n        continue\n      val = pattern[0][a][0] + pattern[1][b][0] + pattern[2][c][0]\n      if val < ans:\n        ans = val\nprint(ans)\n    \n", "# \u30ea\u30d5\u30a1\u30af\u30bf\nfrom collections import defaultdict\nimport itertools\nn, c = map(int, input().split())\nD = [list(map(int, input().split()))for _ in range(c)]\n\n# \u96c6\u8a08\ndiago = [defaultdict(int)for _ in range(3)]\nfor i in range(n):\n    for j, color in enumerate(map(int, input().split())):\n        diago[(i+j) % 3][color-1] += 1\n\n# 0\u5217\u76ee\u3092c\u306b\u3059\u308b\u3068\u304d\u306ec\u306b\u3059\u308b\u3068\u304d\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\ncosts = [[0]*c for _ in range(3)]\nfor i in range(3):\n    for j in range(c):\n        for k, v in diago[i].items():\n            costs[i][j] += D[k][j]*v\n\nINF = 10**18\nans = INF\nfor trio in itertools.combinations(range(c), 3):\n    for color in itertools.permutations(trio, 3):\n        cost = sum(costs[i][j] for i, j in enumerate(color))\n        if cost < ans:\n            ans = cost\nprint(ans)", "N,C=map(int,input().split())\n\nDmat=[]\nfor i in range(C):\n  array=list(map(int,input().split()))\n  Dmat.append(array)\n#print(Dmat)\n\ncmat=[]\nfor i in range(N):\n  array=list(map(int,input().split()))\n  cmat.append(array)\n#print(cmat)\ngrid_list=[{},{},{}]\nfor i in range(N):\n  for j in range(N):\n    c=cmat[i][j]-1\n    mod=(i+j)%3\n    if c in grid_list[mod]:\n      grid_list[mod][c]+=1\n    else:\n      grid_list[mod][c]=1\n#print(grid_list)\n\nmin_cost=10**9\nfor i in range(C):\n  for j in range(C):\n    if i==j:\n      continue\n      \n    for k in range(C):\n      if i==k or j==k:\n        continue\n          \n      cost=0 \n      for c in grid_list[0]:\n        num=grid_list[0][c]\n        cost+=Dmat[c][i]*num\n      for c in grid_list[1]:\n        num=grid_list[1][c]\n        cost+=Dmat[c][j]*num\n      for c in grid_list[2]:\n        num=grid_list[2][c]\n        cost+=Dmat[c][k]*num\n          \n      if cost<min_cost:\n        #print(i,j,k,cost)\n        min_cost=cost\n          \nprint(min_cost)", "import sys\nimport math\nfrom collections import deque\nfrom itertools import permutations\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef main():\n    N, C = NMI()\n    D = [NLI() for _ in range(C)]\n    grid = [list(map(lambda x: int(x)-1, NMI())) for _ in range(N)]\n\n    grid_mod = [{i:0 for i in range(C)} for _ in range(3)]\n    for h in range(N):\n        for w in range(N):\n            t = (h+w) % 3\n            grid_mod[t][grid[h][w]] += 1\n\n    ans = 10**10\n    for colors in permutations(range(C), 3):\n        diff = 0\n        for i in range(3):\n            for c, n in grid_mod[i].items():\n                diff += D[c][colors[i]] * n\n        ans = min(ans, diff)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\nfrom heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN, C = na()\nD = [na() for _ in range(C)]\nc = [na() for _ in range(N)]\n\nz = {}\no = {}\nt = {}\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        q = (i + j) % 3\n        now = c[i - 1][j - 1] - 1\n        if q == 0:\n            if now not in list(z.keys()):\n                z[now] = 1\n            else:\n                z[now] += 1\n        if q == 1:\n            if now not in list(o.keys()):\n                o[now] = 1\n            else:\n                o[now] += 1\n        if q == 2:\n            if now not in list(t.keys()):\n                t[now] = 1\n            else:\n                t[now] += 1\n\nans = inf\nfor i, j, l in itertools.permutations(list(range(C)), 3):\n    tmp = 0\n    for k, v in list(z.items()):\n        tmp += v * D[k][i]\n    for k, v in list(o.items()):\n        tmp += v * D[k][j]\n    for k, v in list(t.items()):\n        tmp += v * D[k][l]\n    ans = min(tmp, ans)\nprint(ans)\n\n", "import itertools\nn, cs = list(map(int, input().split()))\nd = [list(map(int, input().split())) for i in range(cs)]\nc = [list(map(int, input().split())) for i in range(n)]\ncolor_count = [[0] * cs for i in range(3)]\nfor i, j in itertools.product(list(range(n)), repeat=2):\n  color_count[(i + j) % 3][c[i][j] - 1] += 1\nans = 10**20\nfor t in itertools.permutations(list(range(cs)), 3):\n  s = 0\n  for l in range(3):\n    for m in range(cs):\n      s += color_count[l][m] * d[m][t[l]]\n  ans = min(ans, s)\nprint(ans)\n", "import itertools\n\nN,C =map(int,input().split())\nD = [0]+[[0]+list(map(int,input().split())) for i in range(C)]\nc = [list(map(int,input().split())) for i in range(N)]\n \ngrid = [[],[],[]]\nfor i in range(N):\n  for j in range(N):\n    grid[(i+j)%3].append(c[i][j])\n\ns = [[0]*(C+1) for i in range(3)]\n \nfor i in range(3):\n  for j in range(1,C+1,1):\n    for k in range(len(grid[i])):\n      s[i][j]+=D[grid[i][k]][j]\n\nans = float(\"inf\")\nfor p in itertools.permutations(list(range(1,C+1)),3):\n  tmp = 0\n  for i in range(3):\n     tmp +=s[i][p[i]]\n  ans = min(tmp,ans)\n\nprint(ans)", "from itertools import permutations\n\n\ndef main():\n    n, c = list(map(int, input().split()))\n    d = [[int(x) for x in input().split()] for _ in range(c)]\n    g = [[int(x) - 1 for x in input().split()] for _ in range(n)]\n    count = [{}, {}, {}]\n    for i in range(n):\n        for j in range(n):\n            now = g[i][j]\n            index = (i + j + 2) % 3\n            if now in count[index % 3]:\n                count[index % 3][now] += 1\n            else:\n                count[index % 3][now] = 1\n    answer = float(\"inf\")\n    for color in permutations([i for i in range(c)], 3):\n        now_answer = 0\n        for i in range(3):\n            for before_color, num in list(count[i].items()):\n                now_answer += d[before_color][color[i]] * num\n        answer = min(answer, now_answer)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n, C = map(int, input().split())\nd = []\nfor i in range(C):\n    d.append(list(map(int, input().split())))\nc = []\nfor i in range(n):\n    c.append(list(map(int, input().split())))\nc0 = {}\nc1 = {}\nc2 = {}\nfor i in range(0, n * 2 - 1, 3):\n    for j in range(max(0, i - n + 1), min(n, i + 1)):\n        c0.setdefault(c[j][i - j], 0)\n        c0[c[j][i - j]] += 1\nfor i in range(1, n * 2 - 1, 3):\n    for j in range(max(0, i - n + 1), min(n, i + 1)):\n        c1.setdefault(c[j][i - j], 0)\n        c1[c[j][i - j]] += 1\nfor i in range(2, n * 2 - 1, 3):\n    for j in range(max(0, i - n + 1), min(n, i + 1)):\n        c2.setdefault(c[j][i - j], 0)\n        c2[c[j][i - j]] += 1\nD = []\nfor i in range(C):\n    for j in range(C):\n        for k in range(C):\n            if i == j or j == k or k == i:\n                continue\n            temp = 0\n            for p, q in c0.items():\n                temp += d[p - 1][i] * q\n            for p, q in c1.items():\n                temp += d[p - 1][j] * q\n            for p, q in c2.items():\n                temp += d[p - 1][k] * q\n            D.append(temp)\nprint(min(D))", "#\u8a08\u7b97\u91cf max(N ** 2, C ** 3)\nN, C = list(map(int, input().split()))\nD = [0] * C\nfor i in range(C):\n  D[i] = list(map(int, input().split()))\ngrid = [0] * N\nfor i in range(N):\n  grid[i] = list(map(int, input().split()))\n  \n#print(D, grid) \ngrid3 = [[0] * C for i in range(3)]\n#grid[i][j]:3\u3067\u5272\u3063\u3066\u4f59\u308a\u304c i \u306e\u30de\u30b9\u3067\u3001\u8272\u304cj\u3067\u3042\u308b\u30de\u30b9\u306e\u500b\u6570\nfor i in range(N):\n  for j in range(N):\n    nn = (i + j) % 3\n    color = grid[i][j] - 1\n    grid3[nn][color] += 1\n#print(grid3)  \n\nscore = [[0] * C for i in range(3)]\n#score[i][j]:3\u3067\u5272\u3063\u3066\u4f59\u308a\u304c i \u306e\u30de\u30b9\u3092\u3001\u8272j\u306b\u3059\u308b\u3068\u304d\u306e\u9055\u548c\u611f\n#3 * C * C\nfor j in range(C):\n  for i in range(3):\n    for k in range(C): \n      score[i][j] += grid3[i][k] * D[k][j]\n#print(score)            \nans = 10 ** 10  \nfor i in range(C):\n  for j in range(C):\n    if i != j:\n      for k in range(C):\n        if (i != k) and (j != k):\n          now = score[0][i] + score[1][j] + score[2][k]\n          ans = min(ans, now)\nprint(ans)      \n\n\n\n", "N,C=map(int,input().split())\n\nDmat=[]\nfor i in range(C):\n  array=list(map(int,input().split()))\n  Dmat.append(array)\n#print(Dmat)\n\ngrid_list=[{},{},{}]\nfor i in range(N):\n  array=list(map(int,input().split()))\n  for j in range(N):\n    c=array[j]-1    \n    mod=(i+j)%3\n    if c in grid_list[mod]:\n      grid_list[mod][c]+=1\n    else:\n      grid_list[mod][c]=1\n#print(grid_list)\n\nmin_cost=10**9\nfor i in range(C):\n  for j in range(C):\n    if i==j:\n      continue\n      \n    for k in range(C):\n      if i==k or j==k:\n        continue\n          \n      cost=0 \n      for c,num in grid_list[0].items():\n        cost+=Dmat[c][i]*num\n      for c,num in grid_list[1].items():\n        cost+=Dmat[c][j]*num\n      for c,num in grid_list[2].items():\n        cost+=Dmat[c][k]*num\n          \n      if cost<min_cost:\n        #print(i,j,k,cost)\n        min_cost=cost\n          \nprint(min_cost)", "import sys\nfrom itertools import permutations\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, C = list(map(int, input().split()))\n    D = [None] * C\n    for i in range(C):\n        D[i] = tuple(map(int, input().split()))\n    A = [None] * N\n    for i in range(N):\n        A[i] = tuple(map(int, input().split()))\n\n    R = [[0] * C for _ in range(3)]\n    for i in range(N):\n        for j in range(N):\n            R[(i + j + 2) % 3][A[i][j] - 1] += 1\n\n    cost = [[0] * C for _ in range(3)]\n    for r in range(3):\n        for Y in range(C):\n            tmp = 0\n            for X, num in enumerate(R[r]):\n                tmp += D[X][Y] * num\n            cost[r][Y] = tmp\n\n    ans = float(\"inf\")\n    for c0, c1, c2 in permutations(list(range(C)), r=3):\n        ans = min(ans, cost[0][c0] + cost[1][c1] + cost[2][c2])\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, C = map(int, input().split())\nd = [list(map(int , input().split())) for _ in range(C)]\nc = [list(map(int , input().split())) for _ in range(N)]\n#print(d)\n#print(c)\n\nfrom collections import defaultdict\ncd = [defaultdict(int), defaultdict(int), defaultdict(int)]\nfor i in range(N):\n    for j in range(N):\n        k = (i+1+j+1) % 3\n        cd[k][c[i][j]] += 1\n\nans = 10 ** 10\nimport itertools\nfor p in itertools.permutations(list(range(C)), 3):\n    iwa = 0\n    for ci in cd[0].items():\n        iwa += d[ci[0]-1][p[0]] * ci[1]\n    for ci in cd[1].items():\n        iwa += d[ci[0]-1][p[1]] * ci[1]\n    for ci in cd[2].items():\n        iwa += d[ci[0]-1][p[2]] * ci[1]\n    ans = min(ans, iwa)\n#print(cd)\nprint(ans)", "from collections import defaultdict\nimport itertools\n\nn, c = list(map(int, input().split()))\n\nD = [list(map(int, input().split())) for _ in range(c)]\nC = [list(map(int, input().split())) for _ in range(n)]\n\nd = [defaultdict(int), defaultdict(int), defaultdict(int)]\n\nfor i in range(n):\n    for j in range(n):\n        r = (i + j) % 3\n        d[r][C[i][j]] += 1\n\ncost = [[0] * c for _ in range(3)]\n\nfor i in range(3):\n    dic = d[i]\n    for j in range(c):\n        for k, v in list(dic.items()):\n            cost[i][j-1] += v * D[k-1][j-1]\n\nans = 1e9\n\nfor i, j, k in itertools.permutations(list(range(c)), 3):\n    ans = min(cost[0][i] + cost[1][j] + cost[2][k], ans)\n\nprint(ans)\n\n\n", "import itertools\n\n\ndef main():\n    N, C = list(map(int, input().split(' ')))\n    D = [list(map(int, input().split(' '))) for _ in range(C)]\n    grids = [list([int(c) - 1 for c in input().split(' ')]) for _ in range(N)]\n    color_counts = [[0 for _ in range(C)] for _ in range(3)]\n    for i in range(N):\n        for j in range(N):\n            g = ((i + 1) + (j + 1)) % 3\n            c = grids[i][j]\n            color_counts[g][c] += 1\n    min_d = 1000 * 500 * 500\n    for dest_colors in itertools.permutations(list(range(C)), 3):\n        d = 0\n        for g in range(3):\n            for c in range(C):\n                d += color_counts[g][c] * D[c][dest_colors[g]]\n        min_d = min([min_d, d])\n    print(min_d)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools as it\nn,c= map(int,input().split())\ndtab = []\ndtab.append([0 for _ in range(c+1)])\nfor i in range(c):dtab.append([0] + list(map(int,input().split())))\nctab = []\nctab.append([0 for _ in range(n+1)])\nfor i in range(n):ctab.append([0]+list(map(int,input().split())))\nssd = [{},{},{}]\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        temp = (i+j)%3\n        temp2 = ctab[i][j]\n        ssd[temp][temp2] = ssd[temp].get(temp2,0) + 1\ne = [i+1 for i in range(c)]\ncpm = it.permutations(e, 3)\nming=999999999\nfor f in cpm:\n    fl=list(f)\n    cg = 0\n    for i in range(3):\n        for p in ssd[i].keys():cg += dtab[p][fl[i]] * ssd[i][p]\n    ming = min(ming,cg)\nprint(ming)", "n,c=map(int,input().split())\nd=[list(map(int,input().split())) for _ in range(c)]\ng0=[0]*c\ng1=[0]*c\ng2=[0]*c\nfor i in range(n):\n    col=list(map(int,input().split()))\n    for j in range(n):\n        col[j]-=1\n        if (i+j)%3==0:\n            g0[col[j]]+=1\n        elif (i+j)%3==1:\n            g1[col[j]]+=1\n        else:\n            g2[col[j]]+=1\nans=10**18\nfor i in range(c):\n    for j in range(c):\n        for k in range(c):\n            if i==j or j==k or i==k:\n                continue\n            s=0\n            for l in range(c):\n                s+=d[l][i]*g0[l]+d[l][j]*g1[l]+d[l][k]*g2[l]\n            ans=min(ans,s)\nprint(ans)", "# coding: utf-8\nimport sys\nimport numpy as np\nfrom itertools import permutations\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, C = lr()\nfeeling = np.array([lr() for _ in range(C)])\nCij = [lr() for _ in range(N)]\nthree = [[0] * C for _ in range(3)]\nfor i in range(N):\n    for j in range(N):\n        remain = (i+j) % 3\n        num = Cij[i][j] - 1\n        three[remain][num] += 1\n\nthree = np.array(three)\nanswer = 10 ** 10\nfor X in permutations(list(range(C)), 3):\n    temp = 0\n    for i in range(3):\n        # X[i]\u306e\u8272\u306b\u3059\u308b\n        x = X[i]\n        y = feeling[:, x]\n        temp += (three[i] * y).sum()\n    if temp < answer:\n        answer = temp\n\nprint(answer)\n# 13\n", "N, C = list(map(int,input().split()))\nD = [list(map(int,input().split())) for _ in range(C)]\nG = [list(map(int,input().split())) for _ in range(N)]\nZ = [0]*C\nO = [0]*C\nT = [0]*C\nfor x in range(N):\n    for y in range(N):\n        if (x+y)%3 == 0:\n            Z[G[x][y]-1] += 1\n        elif (x+y)%3 == 1:\n            O[G[x][y]-1] += 1\n        else:\n            T[G[x][y]-1] += 1\n\nans = 10**9\nfor c1 in range(C):\n    for c2 in range(C):\n        for c3 in range(C):\n            if c1 == c2 or c2 == c3 or c3 == c1:\n                continue\n            temp = 0\n            for k in range(C):\n                temp += Z[k]*D[k][c1]\n            for k in range(C):\n                temp += O[k]*D[k][c2]\n            for k in range(C):\n                temp += T[k]*D[k][c3]\n            ans = min(ans,temp)\n\nprint(ans)\n", "from collections import defaultdict\n\nn, c = map(int, input().split())\nd_s = [list(map(int, input().split())) for _ in range(c)]\nc_s = [list(map(int, input().split())) for _ in range(n)]\nzot = [defaultdict(int) for _ in range(3)]\nfor i in range(n):\n    for j in range(n):\n        zot[(i + j) % 3][c_s[i][j] - 1] += 1\n\n\nchange = [[], [] ,[]]\nfor i in range(3):\n    for j in range(c):\n        cnt = 0\n        for num, cnt2 in zot[i].items():\n            cnt += d_s[num][j] * cnt2\n        change[i].append((cnt, j))\n    change[i].sort()\n\nans = 10 ** 10\nfor z, i in change[0][:3]:\n    for o, j in change[1][:3]:\n        if i == j:\n            continue\n        for t, k in change[2][:3]:\n            if k == i or k == j:\n                continue\n            ans = min(ans, z + o + t)\n            \nprint(ans)", "import sys\nfrom collections import Counter\nfrom itertools import permutations\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, C = list(map(int, readline().split()))\n    D = [0] * C\n    for i in range(C):\n        D[i] = list(map(int, readline().split()))\n    G = [0] * N\n    for i in range(N):\n        G[i] = [int(s) - 1 for s in readline().split()]\n\n    counter = [[0] * C for _ in range(3)]\n    cost = [[0] * C for _ in range(3)]\n    for x in range(N):\n        for y in range(N):\n            counter[(x + y) % 3][G[x][y]] += 1\n\n    for cur_cost, cur_counter in zip(cost, counter):\n        for i in range(C):\n            for j in range(C):\n                cur_cost[i] += cur_counter[j] * D[j][i]\n\n    ans = INF\n    for c1, c2, c3 in permutations(list(range(C)), 3):\n        if ans > cost[0][c1] + cost[1][c2] + cost[2][c3]:\n            ans = cost[0][c1] + cost[1][c2] + cost[2][c3]\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "LI = lambda: list(map(int, input().split()))\n\nN, C = LI()\nD = [LI() for _ in range(C)]\nc = [LI() for _ in range(N)]\n\nINF = 10 ** 15\n\n\ndef main():\n    w = [[0] * C for i in range(3)]\n    for i in range(N):\n        for j in range(N):\n            x = (i + j) % 3\n            for k in range(C):\n                w[x][k] += D[c[i][j] - 1][k]\n    \n    ans = INF\n    for i in range(C):\n        for j in range(C):\n            if i == j:\n                continue\n            for k in range(C):\n                if i == k or j == k:\n                    continue\n                ans = min(ans, w[0][i] + w[1][j] + w[2][k])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import Counter\nfrom itertools import permutations\n\nn, c = list(map(int, input().split()))\nd = [list(map(int,input().split())) for _ in range(c)]\nci = [[] for _ in range(3)]\nfor i in range(n):\n    cl = list(map(int, input().split()))\n    for j in range(3):\n        ci[(i+j)%3].extend(cl[j::3])\nfor i in range(3):\n    ci[i] = Counter(ci[i])\n\ndef iwa(cols):\n    ret = 0\n    for i in range(3):\n        for x, v in list(ci[i].items()):\n            ret += v * d[x-1][cols[i]]\n    return ret\n\nL = list(permutations(list(range(c)), 3))\nret = 500*500*1000\nfor cols in L:\n    ret = min(ret, iwa(cols))\nprint(ret)\n", "def main():\n    from itertools import permutations\n\n    N, C = list(map(int, input().split()))\n    change_cost = [[int(x) for x in input().split()] for _ in range(C)]\n    init_color = [[int(x) - 1 for x in input().split()] for _ in range(N)]\n\n    ctr = [[0] * C for _ in range(3)]\n    for r in range(N):\n        for c in range(N):\n            p = (r + c) % 3\n            color = init_color[r][c]\n            ctr[p][color] += 1\n\n    mi = 1000 * 500 * 500 + 1\n    for perm in permutations(list(range(C)), r=3):\n        it = iter(perm)\n        t = 0\n        for p in range(3):\n            color_to_be = next(it)\n            for color, count in enumerate(ctr[p]):\n                t += change_cost[color][color_to_be] * count\n        mi = min(mi, t)\n    print(mi)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,c = map(int,input().split())\nd = [list(map(int,input().split())) for _ in range(c)]\n\na = [[0]*c for _ in range(3)]\nb = [[[0,i] for i in range(c)] for _ in range(3)]\n\nfor i in range(n):\n  l = list(map(int,input().split()))\n  for j in range(n):\n    a[(i+j)%3][l[j]-1] += 1\n    \nfor i in range(3):\n  for k in range(c):\n    b[i][k][0] = sum([a[i][t]*d[t][k] for t in range(c)])\np = [[],[],[]]\nfor i in range(3):\n  p[i] = sorted(b[i])[:3]\nm = []\nfor t in p[0]:\n  for s in p[1]:\n    for u in p[2]:\n      if (t[1] != s[1]) and (t[1] != u[1]) and (s[1] != u[1]):\n        m.append(t[0]+s[0]+u[0])\nprint(min(m))", "from itertools import permutations\n\nN,C = map(int,input().split())\nD = list(list(map(int,input().split())) for _ in range(C))\nc = list(list(map(int,input().split())) for _ in range(N))\n\nrem = [[] for _ in range(3)]\nfor i in range(N):\n    for j in range(N):\n        rem[(i+j+2)%3].append(c[i][j])\n\ncost = [[] for _ in range(3)]\n\nfor i in range(3):\n    for s in range(C):\n        tmp = 0\n        for t in rem[i]:\n            tmp += D[t-1][s]\n        cost[i].append((tmp,s+1))\n\nfor i in cost:\n    i.sort()\n    i = i[:3]\n\nans = 1e10\nfor i in cost[0]:\n    for j in cost[1]:\n        for h in cost[2]:\n            if i[1] != j[1] and j[1] != h[1] and h[1] != i[1]:\n                ans = min(ans,i[0]+j[0]+h[0])\nprint(ans)", "from itertools import permutations\n\nN, C = list(map(int, input().split()))\nD = [list(map(int, input().split())) for _ in range(C)]\nc = [list(map(int, input().split())) for _ in range(N)]\n\na = [[0] * C for _ in range(3)]\nfor y in range(N):\n    for x in range(N):\n        t = ((x + 1) + (y + 1)) % 3\n        a[t][c[y][x] - 1] += 1\n\nresult = float('inf')\nfor b in permutations(list(range(C)), 3):\n    t = 0\n    for i in range(3):\n        ai = a[i]\n        bi = b[i]\n        for j in range(C):\n            t += ai[j] * D[j][bi]\n    result = min(result, t)\nprint(result)\n", "#!/usr/bin/env python3\n\nfrom itertools import permutations\n\nN, C = list(map(int, input().split()))\n\nD = [list(map(int, input().split())) for i in range(C)]\n# c = [list(map(int, input().split())) for i in range(N)]\n\ncolors = [[0]*C for i in range(3)]\nfor i in range(N):\n    tmp = list(map(int, input().split()))\n    for j, color in enumerate(tmp):\n        num = ((i+1) + (j+1)) % 3\n        colors[num][color-1] += 1\n# print(colors)\n\ndata = [[0]*C for i in range(3)]\n\n\nfor i in range(3):\n    # color[i]\n    for j in range(C):\n        for k in range(C):\n            data[i][k] += colors[i][j] * D[j][k]\n# print(data)\n\nans = 10**10\nfor iter_ in permutations(list(range(C)), 3):\n    # print(iter_)\n    tmp = []\n    for i, j in enumerate(iter_):\n        tmp.append(data[i][j])\n    ans = min(ans, sum(tmp))\nprint(ans)\n", "# coding: utf-8\n\n# https://atcoder.jp/contests/abc099/tasks\n# 15:00-\n\n\ndef main():\n    N, C = list(map(int, input().split()))\n    D = [None] * C\n    for i in range(C):\n        D[i] = list(map(int, input().split()))\n\n    c = [None] * N\n    for i in range(N):\n        c[i] = list(map(int, input().split()))\n        c[i] = [x-1 for x in c[i]]  # 0-index\n\n    STU = [[0] * C, [0] * C, [0] * C]\n\n    for k in range(C):\n        for i in range(N):\n            for j in range(N):\n                STU[(i+j) % 3][k] += D[c[i][j]][k]\n\n    ans = 1000 * N * N\n    for i in range(C):\n\n        for j in range(C):\n            if j == i:\n                continue\n\n            for k in range(C):\n                if k == i or k == j:\n                    continue\n                cand = STU[0][i] + STU[1][j] + STU[2][k]\n\n                if cand < ans:\n                    ans = cand\n\n    return ans\n\n\nprint((main()))\n", "N,C = map(int, input().split())\nd = [list(map(int, input().split())) for _ in range(C)]\n\n# 3\u8272\u3092\u4fdd\u6301\u3059\u308b\u305f\u3081\u306e\u5909\u6570\ng0=[0]*C # \u659c\u3081\u52171\ng1=[0]*C # \u659c\u3081\u52172\ng2=[0]*C # \u659c\u3081\u52173\n\n# \u4ee5\u4e0b\u306e\u3088\u3046\u306a\u659c\u3081\u3054\u3068\u306b\u5217\u30923\u8272\u306b\u5206\u3051\u3088\u3046\u3068\u3057\u305f\u3068\u304d\u306e\u9055\u548c\u611f(\u30b3\u30b9\u30c8)\u3092\u8003\u3048\u308b\n# \u25a1 \u25cb \u25b3 \u25a1\n# \u25cb \u25b3 \u25a1 \u25cb\n# \u25b3 \u25a1 \u25cb \u25b3\n# \u25a1 \u25cb \u25b3 \u25a1\n\nfor i in range(N):\n    col=list(map(int,input().split()))\n    # \u5404\u30de\u30b9\u306e\u5404\u8272\u3092\u898b\u3066\u3044\u304f\n    #   \u659c\u3081\u306e\u52173\u7a2e\u985e\u3054\u3068\u306b\u6301\u3064\u8272\u3092\u4fdd\u6301\u3057\u3066\u304a\u304f\n    for j in range(N):\n        col[j]-=1\n        if (i+j)%3==0:\n            g0[col[j]]+=1\n        elif (i+j)%3==1:\n            g1[col[j]]+=1\n        else:\n            g2[col[j]]+=1\n\nans=float('inf')\n# \u5168\u63a2\u7d22\u3057\u3066\u3001\u4f55\u8272\u306b\u5909\u3048\u308b\u306e\u304c\u6700\u3082\u30b3\u30b9\u30c8\u304c\u4f4e\u3044\u304b\u3092\u51fa\u3059\nfor i in range(C): # g0\u306e\u8272(\u3092i\u306b\u3057\u305f\u5834\u5408)\n    for j in range(C): # g1\u306e\u8272(\u3092j\u306b\u3057\u305f\u5834\u5408)\n        for k in range(C): # g2\u306e\u8272(\u3092k\u306b\u3057\u305f\u5834\u5408)\n            if i==j or j==k or i==k: # g0\u3068g1\u304c\u540c\u3058\u8272\u306b\u306a\u308b\u3001\u307f\u305f\u3044\u306a\u30d1\u30bf\u30fc\u30f3\u306f\u306a\u3044\u306e\u3067\u305d\u306e\u5834\u5408\u306e\u8272\u5206\u3051\u306f\u8003\u3048\u306a\u304f\u3066\u826f\u3044\u306e\u3067\u98db\u3070\u3059\n                continue\n            s=0\n            for l in range(C):\n                # d[l][i]*g0[l]: l\u306e\u8272\u3092i\u306b\u5909\u3048\u308b\u306e\u306b\u5fc5\u8981\u306a\u30b3\u30b9\u30c8\u306e\u5408\u8a08\n                #  l\u3092i\u306b\u5909\u3048\u308b\u30b3\u30b9\u30c8 * g0\u306b\u3042\u308bl\u306e\u8272\u306e\u6570\n                #  d[l][j], d[l][k]\u3082\u540c\u69d8\u306e\u8a08\u7b97\n                #    l(\u5168\u8272)\u3092\u7279\u5b9a\u306ei\u3084j\u306b\u5909\u3048\u305f\u3068\u304d\u306e\u30b3\u30b9\u30c8\u306e\u5408\u8a08\u3092\u7b97\u51fa\n                s+=d[l][i]*g0[l]+d[l][j]*g1[l]+d[l][k]*g2[l]\n            ans=min(ans,s)\nprint(ans)", "N,C = map(int,input().split())\nD = [list(map(int,input().split())) for i in range(C)]\nE = [list(map(int,input().split())) for i in range(N)]\n\nfrom collections import Counter\nctrs = [Counter() for _ in range(3)]\nfor i,row in enumerate(E):\n    for j,c in enumerate(row):\n        ctrs[(i+j)%3][c] += 1\n\nans = float('inf')\nfrom itertools import permutations\nfor ptn in permutations(range(1,C+1), 3):\n    t = 0\n    for p,c in zip(ptn,ctrs):\n        for k,v in c.items():\n            t += D[k-1][p-1] * v\n    ans = min(ans, t)\nprint(ans)", "import itertools\n\nN, C = map(int, input().split())\nD = [list(map(int, input().split())) for i in range(C)]\nc = [list(map(int, input().split())) for i in range(N)]#kokomadeha wakaru\n\nindices = [2, 0, 1]\ncount_color = [[0] * C for i in range(3)]\nfor i in range(N):\n  idx = indices[i%3]\n  for j in range(N):\n    count_color[idx][c[i][j]-1] += 1#1 minus surunoha list ni awaserutame iro to amari no kakezan\n    idx = (idx + 1) % 3#koreha indices wo yatteirudake\n    \n# \u8272\u306e\u5bfe\u5fdc\u95a2\u4fc2\u3092C_P_3\u901a\u308a\u5168\u3066\u8a66\u3059\nans = float('inf')\ncorrespondence = list(itertools.permutations(range(C), 3))\n# (i+j)%3\u306e\u30de\u30b9\u76ee\u3092corr[(i+j)%3]\u306b\u66f8\u304d\u63db\u3048\u308b\nfor corr in correspondence:\n  cost = 0\n  for idx in range(3): # idx : (i+j)%3\n    for color in range(C):\n      cost += count_color[idx][color] * D[color][corr[idx]]\n  ans = min(ans, cost)\n\nprint(ans)", "n, c = map(int, input().split())\nd_s = [list(map(int, input().split())) for _ in range(c)]\nc_s = [list(map(int, input().split())) for _ in range(n)]\nzot = [[], [] ,[]]\nfor i in range(n):\n    for j in range(n):\n        zot[(i + j) % 3].append(c_s[i][j] - 1)\n\nchange = [[], [] ,[]]\nfor i in range(3):\n    for j in range(c):\n        cnt = 0\n        for num in zot[i]:\n            cnt += d_s[num][j]\n        change[i].append((cnt, j))\n    change[i].sort()\n    \nans = 10 ** 10\nfor z, i in change[0][:3]:\n    for o, j in change[1][:3]:\n        if i == j:\n            continue\n        for t, k in change[2][:3]:\n            if k == i or k == j:\n                continue\n            ans = min(ans, z + o + t)\n            \nprint(ans)", "from itertools import product, permutations\n\ndef main():\n    N, C = list(map(int, input().split()))\n    D = [list(map(int, input().split())) for _ in range(C)]\n    c = [list(map(int, input().split())) for _ in range(N)]\n    T = [[0] * C for _ in range(3)]\n    for x, y in product(list(range(N)), repeat=2):\n        r = (x + y) % 3\n        for i in range(C):\n            T[r][i] += D[c[x][y] - 1][i]\n    Q = []\n    for j in range(3):\n        Q.append(sorted((t, i) for i, t in enumerate(T[j])))\n    m = 10**10\n    for x, y, z in product(list(range(3)), repeat=3):\n        X, Y, Z = Q[0][x], Q[1][y], Q[2][z]\n        if X[1] == Y[1] or Y[1] == Z[1] or Z[1] == X[1]:\n            continue\n        m = min(m, X[0] + Y[0] + Z[0])\n    return m\n\n\nprint((main()))\n", "import sys\ninput = sys.stdin.readline\nfrom itertools import permutations\n\ndef main():\n    N, C = map(int, input().split())\n    D = [list(map(int, input().split())) for _ in range(C)]\n    grid = [list(map(int, input().split())) for _ in range(N)]\n\n    sup0 = [0] * C\n    sup1 = [0] * C\n    sup2 = [0] * C\n    for i in range(N):\n        for j in range(N):\n            if (i + j) % 3 == 0:\n                sup2[grid[i][j] - 1] += 1\n            elif (i + j) % 3 == 1:\n                sup0[grid[i][j] - 1] += 1\n            elif (i + j) % 3 == 2:\n                sup1[grid[i][j] - 1] += 1\n\n    ans = 10 ** 18\n    for i, j, k in permutations(range(C), 3):\n        tmp = 0\n        for c in range(C):\n            tmp += D[c][i] * sup0[c]\n            tmp += D[c][j] * sup1[c]\n            tmp += D[c][k] * sup2[c]\n        ans = min(ans, tmp)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u8272\u306e\u5857\u308a\u65b9\u306f\u5168\u90e8\u3067\u4f55\u901a\u308a\u304b\u3002O(C^3)\u3067\u3001C^3 = 27000\u901a\u308a\u3002\n# \u5404\u5857\u308a\u65b9\u306b\u5bfe\u3057\u3066\u3044\u3061\u3044\u3061\u8a08\u7b97\u3057\u3066\u3044\u308b\u3068\u6700\u592725000\u30de\u30b9\u3067\u3001\u3053\u308c\u3060\u3068\u9593\u306b\u5408\u308f\u306a\u3044\u3002\n# 3\u3064\u306b\u5225\u308c\u305f\u5404\u90e8\u5206\u3092\u5404\u8272\u306b\u5909\u3048\u308b\u30b3\u30b9\u30c8\u5408\u8a08\u3092\u524d\u8a08\u7b97\u3057\u3066\u304a\u3051\u3070\u826f\u3044\u3002O(C^3 + N^2 C)\u3002\n# \u4e00\u3072\u306d\u308a\u3057\u305f\u5168\u63a2\u7d22\u3002\n\nn, c = list(map(int, input().split()))\nchange_cost = [list(map(int, input().split())) for _ in range(c)]\ninit_color = [list(map(int, input().split())) for _ in range(n)]\n\ncost = [[0 for _ in range(c)] for _ in range(3)]\n\nfor row in range(n):\n    for col in range(n):\n        before = init_color[row][col] - 1\n        for after in range(c):\n            idx = (row + col) % 3\n            cost[idx][after] += change_cost[before][after]\n\nans = 1000 * 500 * 500 * 10\nfor ci in range(c):\n    for cj in range(c):\n        for ck in range(c):\n            if (ci != cj != ck != ci):\n                ans = min(ans, cost[0][ci] + cost[1][cj] + cost[2][ck])\n\nprint(ans)\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, C = LI()\n    D = [LI() for _ in range(C)]\n    c = [LI_() for _ in range(N)]\n\n    # \u5ea7\u6a19\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306b\u3001\u305d\u306e\u8272\u306b\u5857\u308a\u66ff\u3048\u308b\u3068\u304b\u304b\u308b\u30b3\u30b9\u30c8\u3092\u524d\u8a08\u7b97\n    a = [[0] * C for _ in range(3)]\n    for i, j in itertools.product(list(range(N)), repeat=2):\n        for k in range(C):\n            a[(i+j)%3][k] += D[c[i][j]][k]\n\n    # \u5ea7\u6a19\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306b\u8272\u306e\u5272\u5f53\u3068\u305d\u306e\u30b3\u30b9\u30c8\u3092\u5168\u63a2\u7d22\n    ans = INF\n    for i, j, k in itertools.permutations(list(range(C)), 3):\n        ans = min(a[0][i] + a[1][j] + a[2][k], ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import itertools\n\nn, cc = list(map(int, input().split()))\nd = [list(map(int, input().split())) for i in range(cc)]\nc = [list(map(int, input().split())) for i in range(n)]\n\ncounter = [[0 for i in range(cc)] for j in range(3)]\nfor i in range(n):\n    for j in range(n):\n        counter[(i+j)%3][c[i][j]-1] += 1\n\nm = 250000000\nfor y in itertools.permutations(range(cc), 3):\n    new = 0\n    for i in range(3):\n        for x in range(cc):\n            new += counter[i][x-1]*d[x-1][y[i]]\n    m = min(m, new)\n\nprint(m)", "from itertools import permutations\n\nN, C = list(map(int, input().split()))\nD = [list(map(int, input().split())) for _ in range(C)]\nc = [list(map(int, input().split())) for _ in range(N)]\n\na = [[0] * C for _ in range(3)]\nfor y in range(N):\n    for x in range(N):\n        t = ((x + 1) + (y + 1)) % 3\n        a[t][c[y][x] - 1] += 1\n\nresult = float('inf')\nfor b in permutations(list(range(C)), 3):\n    t = 0\n    for i in range(3):\n        for j in range(C):\n            t += a[i][j] * D[j][b[i]]\n    result = min(result, t)\nprint(result)\n", "N, C = list(map(int, input().split()))\nD = [list(map(int, input().split())) for _ in range(C)]\ncolor = [list(map(int, input().split())) for _ in range(N)]\n\ncs = [[0]*C for _ in range(3)]\nfor i in range(N):\n  for j in range(N):\n    amari = (i+j)%3\n    cs[amari][color[i][j]-1] += 1\n\nans = 500*500*1000\nfor i in range(C):\n  for j in range(C):\n    if i == j:\n      continue\n    for k in range(C):\n      if (i==k) or (j==k):\n        continue\n      now = 0\n      for ci in range(C):\n        now += D[ci][i] * cs[0][ci]\n        now += D[ci][j] * cs[1][ci]\n        now += D[ci][k] * cs[2][ci]\n          \n      ans = min(ans, now)\n      \nprint(ans)\n", "from collections import defaultdict\nimport itertools\nn, c = list(map(int, input().split()))\nD = [list(map(int, input().split()))for _ in range(c)]\n\n\n# \u8272\u306f0\u59cb\u307e\u308a\u3067\u7ba1\u7406\u3059\u308b\n\n# \u5165\u529b\u306e\u8272\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u305d\u308c\u305e\u308c\u306e\u8272\u6bce\u306b\u3044\u304f\u3064\u3042\u308b\u304b\ndiago0 = defaultdict(int)\ndiago1 = defaultdict(int)\ndiago2 = defaultdict(int)\n\nfor i in range(n):\n    for j, color in enumerate(map(int, input().split())):\n        color -= 1\n        if (i+j) % 3 == 0:\n            diago0[color] += 1\n        elif (i+j) % 3 == 1:\n            diago1[color] += 1\n        else:\n            diago2[color] += 1\n\n\n# 0\u5217\u76ee\u3092c\u306b\u3059\u308b\u3068\u304d\u306ec\u306b\u3059\u308b\u3068\u304d\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\ncost0 = [0]*c\ncost1 = [0]*c\ncost2 = [0]*c\n\nfor i in range(c):\n    for k, v in list(diago0.items()):\n        cost0[i] += D[k][i]*v\nfor i in range(c):\n    for k, v in list(diago1.items()):\n        cost1[i] += D[k][i]*v\nfor i in range(c):\n    for k, v in list(diago2.items()):\n        cost2[i] += D[k][i]*v\n\nINF = 10**18\nans = INF\nfor trio in itertools.combinations(list(range(c)), 3):\n    for a, b, c in itertools.permutations(trio, 3):\n        cost = cost0[a]+cost1[b]+cost2[c]\n        if cost < ans:\n            ans = cost\nprint(ans)\n", "#!/usr/bin/env python3\n\ndef main():\n    n, nc = list(map(int, input().split()))\n    d = [list(map(int, input().split())) for i in range(nc)]\n    c = [list(map(int, input().split())) for i in range(n)]\n\n    cnt = [[0 for _ in range(nc)] for eta in range(3)]\n    for i in range(n):\n        for j in range(n):\n            eta = (i + j) % 3\n            cnt[eta][c[i][j] - 1] += 1\n\n    iwamin = 10 ** 9\n    for c1 in range(nc):\n        for c2 in range(nc):\n            for c3 in range(nc):\n                if len(set([c1, c2, c3])) < 3:\n                    continue\n                iwa = 0\n                for c4 in range(nc):\n                    iwa += cnt[0][c4] * d[c4][c1]\n                    iwa += cnt[1][c4] * d[c4][c2]\n                    iwa += cnt[2][c4] * d[c4][c3]\n                iwamin = min(iwamin, iwa)\n    print(iwamin)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,c=map(int,input().split())\nd=[list(map(int,input().split()))for _ in range(c)]\ncc=[list(map(int,input().split()))for _ in range(n)]\nans=10**15\ncnt=[[0]*c for _ in range(3)]\nfor i in range(n):\n\tfor j in range(n):\n\t\tcnt[(i+j)%3][cc[i][j]-1]+=1\nfor i in range(c):\n\tfor j in range(c):\n\t\tfor k in range(c):\n\t\t\tpre_ans=0\n\t\t\tif i==j or j==k or k==i:\n\t\t\t\tcontinue\n\t\t\tfor l in range(3):\n\t\t\t\tfor m in range(c):\n\t\t\t\t\tif l%3==0 and m!=i:\n\t\t\t\t\t\tpre_ans+=cnt[l][m]*d[m][i]\n\t\t\t\t\telif l%3==1 and m!=j:\n\t\t\t\t\t\tpre_ans+=cnt[l][m]*d[m][j]\n\t\t\t\t\telif l%3==2 and m!=k:\n\t\t\t\t\t\tpre_ans+=cnt[l][m]*d[m][k]\n\t\t\tans=min(ans,pre_ans)\nprint(ans)", "N, C = map(int, input().split())\nD = [list(map(int, input().split())) for _ in range(C)]\ngrid = [list(map(int, input().split())) for _ in range(N)]\nD0 = {i: 0 for i in range(C)}\nD1 = {i: 0 for i in range(C)}\nD2 = {i: 0 for i in range(C)}\nfor i in range(N):\n  for j in range(N):\n    if (i+j) % 3 == 0:\n      D0[grid[i][j]-1] += 1\n    elif (i+j) % 3 == 1:\n      D1[grid[i][j]-1] += 1\n    elif (i+j) % 3 == 2:\n      D2[grid[i][j]-1] += 1\nm = int(1e11) + 23\nfor i in range(C):\n  for j in range(C):\n    for k in range(C):\n      if i != j and j != k and k != i:\n        differ = 0\n        for l in range(C):\n          differ += D0[l] * D[l][i]\n          differ += D1[l] * D[l][j]\n          differ += D2[l] * D[l][k]\n        if m > differ:\n          m = differ\nprint(m)", "from itertools import permutations\nn, C = map(int, input().split())\nd = [list(map(int, input().split())) for i in range(C)]\nc = [list(map(int, input().split())) for i in range(n)]\nl = [[0] * C for i in range(3)]\nfor i in range(n):\n    for j, k in enumerate(c[i]):\n        l[(i + j) % 3][k - 1] += 1\nans = float(\"inf\")\nfor i in permutations(range(C), 3):\n    cnt = 0\n    for j in range(3):\n        for k in range(C):\n            cnt += d[k][i[j]] * l[j][k]\n    ans = min(ans, cnt)\nprint(ans)", "n, c = map(int, input().split())\nD = [list(map(int, input().split())) for _ in range(c)]\nC = [list(map(int, input().split())) for _ in range(n)]\n\nCC = [[0] * c for _ in range(3)]\n\nfor h, line in enumerate(C):\n  for w, i in enumerate(line):\n    CC[(h + w) % 3][i - 1] += 1\n    \nans = 10 ** 19\nfor i in range(c):\n  for j in range(c):\n    for k in range(c):\n      if i != j and j != k and k != i:\n        score = 0\n        score += sum(D[itr][i] * val for itr, val in enumerate(CC[0]))\n        score += sum(D[itr][j] * val for itr, val in enumerate(CC[1]))\n        score += sum(D[itr][k] * val for itr, val in enumerate(CC[2]))\n        ans = min(ans, score)\n\nprint(ans)", "from itertools import permutations\nn, c = map(int, input().split())\n\nd_lst = [list(map(int, input().split())) for _ in range(c)]\nc_lst = [list(map(int, input().split())) for _ in range(n)]\n\nlst = [[0] * c for _ in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        lst[(i + j) % 3][c_lst[i][j]-1] += 1\n        \ncnt = []\n\nfor i in range(c):\n    temp = []\n    for j in range(3):\n        cal = 0\n        for k in range(c):\n            cal += lst[j][k] * d_lst[k][i]\n        temp.append(cal)\n    cnt.append(temp) \n\n \ntemp = []\nfor l in permutations(list(range(c)), 3):\n    temp.append(cnt[l[0]][0] + cnt[l[1]][1] + cnt[l[2]][2])\n\nprint(min(temp))", "from itertools import permutations\nn,C=map(int,input().split())\nd=[list(map(int,input().split())) for _ in range(C)]\nc=[list(map(int,input().split())) for _ in range(n)]\na=[[0]*C for _ in range(3)]\nfor i in range(n):\n\tfor j in range(n):\n\t\ta[(i+j)%3][c[i][j]-1]+=1\nans=10**9\nfor v in permutations(range(C),3):\n\ttmp=0\n\tfor i in range(3):\n\t\tfor j in range(C):\n\t\t\ttmp+=a[i][j]*d[j][v[i]]\n\tans=min(ans,tmp)\nprint(ans)", "import itertools\n\nN,C =map(int,input().split())\nD = [0]+[[0]+list(map(int,input().split())) for i in range(C)]\n\nc = [list(map(int,input().split())) for i in range(N)]\n\ngrids = [[],[],[]]#\u632f\u308a\u5206\u3051\u308b\nfor i in range(N):\n    for j in range(N):\n        grids[(i+j)%3].append(c[i][j])\n\niwa = [[0]*(C+1) for i in range(3)]#grids[i]\u3092\u8272j\u306b\u3057\u305f\u6642\u306e\u9055\u548c\u611f\n\nfor i in range(3):\n    for j in range(1,C+1,1):\n        for k in range(len(grids[i])):\n            iwa[i][j]+=D[grids[i][k]][j]\n\nans = float(\"inf\")\nfor bits in itertools.permutations(list(range(1,C+1)),3):\n    tmpans = 0\n    for i in range(3):\n        tmpans +=iwa[i][bits[i]]\n    ans = min(tmpans,ans)\n\nprint(ans)", "n,c=list(map(int,input().split()))\nd=[list(map(int,input().split())) for i in range(c)]\nc_=[list(map(int,input().split())) for i in range(n)]\ng=[[] for i in range(3)]\nfor i in range(n):\n    for j in range(n):\n        g[(i+j+2)%3].append(c_[i][j]-1)\n#print(g)\n'''\nfor i in range(c):\n    for j in range(c):\n        for k in range(c):\n            d[i][j]=min(d[i][j],d[i][k]+d[k][j])\nprint(d)\n'''\nf=[[] for i in range(3)]\nfor i in range(3):\n    for j in range(c):\n        x=0\n        for k in g[i]:\n            x+=d[k][j]\n        f[i].append((j,x))\n    f[i]=sorted(f[i],key=lambda x:x[1])[:3]\nans=[]\n#print()\nfor i in f[0]:\n    for j in f[1]:\n        for k in f[2]:\n            if i[0]!=j[0] and k[0]!=j[0] and i[0]!=k[0]:\n                #print(i[0],j[0],k[0])\n                #print(i[1],j[1],k[1])\n                ans.append(i[1]+j[1]+k[1])\nprint((min(ans)))\n", "def main():\n    from sys import stdin\n    def input():\n        return stdin.readline().strip()\n    \n    n, c = map(int, input().split())\n    d = [list(map(int, input().split())) for _ in range(c)]\n\n    '''\n    # if I can change the color of the same square many times\n    # Warshall-Floyd algorithm\n    for k in range(c):\n        for i in range(c):\n            for j in range(c):\n                if d[i][j] > d[i][k] + d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n    '''\n\n    color = [list(map(int, input().split())) for _ in range(n)]\n\n    counters = [[0] * c for _ in range(3)]\n    for i in range(n):\n        for j in range(n):\n            counters[(i+j) % 3][color[i][j] - 1] += 1\n    \n    # full search\n    cost = []\n    for group in counters:\n        l = []\n        # from j to i\n        for i in range(c):\n            num = 0\n            for j in range(c):\n                num += d[j][i] * group[j]\n            l.append((num, i))\n        l.sort()\n        cost.append(l[:3])\n\n    ans = 10 ** 9\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                if cost[0][i][1] != cost[1][j][1] and cost[1][j][1] != cost[2][k][1] and cost[2][k][1] != cost[0][i][1]:\n                    if ans > cost[0][i][0] + cost[1][j][0] + cost[2][k][0]:\n                        ans = cost[0][i][0] + cost[1][j][0] + cost[2][k][0]\n    \n    print(ans)\n\nmain()", "n,c = map(int,input().split())\nlis = [list(map(int,input().split())) for i in range(c)]\nli = [list(map(int,input().split())) for i in range(n)]\nans = 10 ** 100\ncnt = [0,0,0]\nmasu = [[0 for i in range(c)] for j in range(3)]\nfor i in range(n):\n    for j in range(n):\n        cnt[(i+j)%3] += 1\n        masu[(i+j)%3][li[i][j]-1] += 1\nfor i in range(c):\n    for j in range(c):\n        if i != j:\n            for k in range(c):\n                if i != k and j != k:\n                    tryans = 0\n                    num = [i,j,k]\n                    for l in range(3):\n  #                         print(num[l], masu[l])\n                        for h in range(c):\n                            if h != num[l]:\n                                tryans += lis[h][num[l]] * masu[l][h]\n                    ans = min(ans,tryans)\n  #                 print(i,j,k,ans)\nprint(ans)", "from itertools import permutations\nimport numpy as np\nN, C = map(int, input().split())\nD = np.ndarray((C, C), dtype=int)\nc = np.ndarray((N, N), dtype=int)\nfor i in range(C):\n    D[i] = list(map(int,input().split()))\nfor i in range(N):\n    c[i] = list(map(int,input().split()))\nc -= 1\nacc = np.zeros((3, C), dtype=int)\nfor i in range(N):\n    for j in range(N):\n        acc[(i+j) % 3] += D[c[i][j]]\nans = float(\"inf\")\nfor i,j,k in permutations(range(C), r=3):\n    ans = min(ans, acc[0][i]+acc[1][j]+acc[2][k])\nprint(ans)", "N, C = map(int, input().split())\n\nD = []\nfor i in range(C):\n    D.append(list(map(int, input().split())))\n\ncc = [[0]*C for i in range(3)]\nfor i in range(N):\n    color = list(map(int, input().split()))\n    for j in range(len(color)):\n        cc[(i+j)%3][color[j]-1] += 1\n    \niwakan = [[[0, 0] for _ in range(C)] for _ in range(3)]\n\nfor i in range(3):\n    for j in range(C):\n        tmp = 0\n        for k in range(len(cc[i])):\n            tmp += cc[i][k]*D[k][j]\n        iwakan[i][j][0] = tmp\n        iwakan[i][j][1] = j\n\nans = 10**15\nfor i in range(len(iwakan)):\n    iwakan[i] = sorted(iwakan[i], key=lambda x:x[0])\n    \nfor i in range(3):\n    for j in range(3):\n        if(iwakan[0][i][1] == iwakan[1][j][1]):\n            continue\n        for k in range(3):\n            if(iwakan[0][i][1] == iwakan[2][k][1]):\n                continue\n            if(iwakan[1][j][1] == iwakan[2][k][1]):\n                continue\n            ans = min(ans, iwakan[0][i][0]+iwakan[1][j][0]+iwakan[2][k][0])\n            \nprint(ans)", "import sys\nimport collections\nimport itertools\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, C = [int(x) for x in input().split()]\n    D = [[int(x) for x in input().split()] for _ in range(C)]\n    c = [[int(x) for x in input().split()] for _ in range(N)]\n\n    A = [[] for j in range(3)]\n\n    for j in range(N):\n        for i in range(N):\n            A[(i + j) % 3].append(c[j][i])\n\n    one = collections.Counter(A[0])\n    two = collections.Counter(A[1])\n    three = collections.Counter(A[2])\n\n    ans = float(\"inf\")\n    for x, y, z in itertools.permutations(list(range(C)), 3):\n        tmp = 0\n        for k in list(one.keys()):\n            tmp += D[k - 1][x] * one[k]\n        for k in list(two.keys()):\n            tmp += D[k - 1][y] * two[k]\n        for k in list(three.keys()):\n            tmp += D[k - 1][z] * three[k]\n\n        ans = min(ans, tmp)\n\n    print(ans)\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nfrom itertools import permutations\n\nn,c = list(map(int,input().split()))\nD = []\nfor i in range(c):\n    D.append(list(map(int,input().split())))\n\nco = [Counter() for i in range(3)]\nfor i in range(n):\n    C = list(map(int,input().split()))\n    for j in range(n):\n        co[(i+j)%3][C[j]-1] +=1\nans = 10**15\nperm = permutations([i for i in range(c)],3)\n\nfor t in perm:\n    temp = 0\n    for i in range(3):\n        color = t[i]\n        for num,cnt in list(co[i].items()):\n            temp += D[num][color] * cnt\n    ans = min(temp,ans)\nprint(ans)\n", "from itertools import permutations\nn,n_color = map(int,input().split())\nchange_cost = [list(map(int, input().split())) for i in range(n_color)]\ncolor_grid = [list(map(int, input().split())) for i in range(n)]\n\nmod0_colors = [0] * n_color\nmod1_colors = [0] * n_color\nmod2_colors = [0] * n_color\nfor y in range(n):\n    for x in range(n):\n        color = color_grid[y][x]-1\n        if (y+x+2) % 3 == 0:\n            mod0_colors[color]+= 1\n        elif (y+x+2) % 3 == 1:\n            mod1_colors[color]+= 1\n        else:\n            mod2_colors[color]+= 1\n\nmod2color_cost = [[0]*n_color for _ in range(3)]\nfor mod,mod_colors in enumerate([mod0_colors,mod1_colors,mod2_colors]):\n    for color_to in range(n_color):\n        total_cost = 0\n        for color_from in range(n_color):\n            cost_per_node = change_cost[color_from][color_to]\n            n_node = mod_colors[color_from]\n            total_cost += n_node*cost_per_node\n        mod2color_cost[mod][color_to] = total_cost\n\nans = float('inf')\nfor pettern in permutations([i for i in range(n_color)],3):\n    total_cost = 0\n    for from_ in range(3):\n        to = pettern[from_]\n        total_cost += mod2color_cost[from_][to]\n    ans = min(ans, total_cost)\nprint(ans)", "n,c = map(int,input().split())\nd = [list(map(int,input().split())) for i in range(c)]\nl = [list(map(int,input().split())) for i in range(n)]\n\nll = [[0]*c for i in range(3)]\n\nfor i in range(n):\n    for j in range(n):\n        x = (i+j+2)%3\n        ll[x][l[i][j]-1] += 1\n\nans = float(\"INF\")\n\nfor i in range(c):\n    for j in range(c):\n        if i == j:\n            continue\n        for k in range(c):\n            if i == k or j == k:\n                continue\n            count = 0\n            ch = [i,j,k]\n            for m in range(3):\n                for t in range(c):\n                    count += ll[m][t]*d[t][ch[m]]\n            ans = min(ans,count)\nprint(ans)", "N, C = map(int, input().split())\nD = []\nfor _ in range(C):\n    D.append(list(map(int, input().split())))\nc = []\nfor _ in range(N):\n    c.append(list(map(int, input().split())))\ncolors = [[0]*C for _ in range(3)]\nfor i in range(N):\n    for j in range(N):\n        colors[(i+j)%3][c[i][j]-1] += 1\nans = 10**10\nfor i in range(C):\n    for j in range(C):\n        if i==j:\n            continue\n        for k in range(C):\n            if j==k or k==i:\n                continue\n            tmp = 0\n            for l in range(C):\n                tmp += colors[0][l]*D[l][i]\n                tmp += colors[1][l]*D[l][j]\n                tmp += colors[2][l]*D[l][k]\n            ans = min(ans, tmp)\nprint(ans)", "3\n# -*- coding:utf-8 -*-\n\nfrom itertools import combinations, permutations\n\ndef main():\n  n, nc = list(map(int, input().split()))\n  md = [list(map(int, input().split())) for _ in range(nc)]\n  mc = [list([int(c)-1 for c in input().split()]) for _ in range(n)]\n  cnt_c = [[0] * nc for _ in range(3)]\n  \n  for i in range(n):\n    for j in range(n):\n      cnt_c[(i + j) % 3][mc[i][j]] += 1\n  \n  def calc_cost(lx, itarget):\n    return sum([cnt*md[i][itarget] for i, cnt in enumerate(lx)])\n  \n  cost = 10**9\n  for inds in combinations(list(range(nc)), 3):\n    for itargets in permutations(inds):\n      cost = min(cost, sum([calc_cost(cnt_c[i], itarget) for i, itarget in enumerate(itargets)]))\n  print(cost)\n    \n      \n  \n\ndef __starting_point():\n  main()\n\n\n__starting_point()", "n,c = list(map(int,input().split()))\n\nD_list = [[int(i) for i in input().split()] for _ in range(c)]\nc_list = [[int(i) for i in input().split()] for _ in range(n)]\n\nc_num=[[0 for _ in range(3)] for __ in range(c)]\n\nfor a in range(n):\n    for b in range(n):\n        c_num[c_list[b][a]-1][(a+b+2)%3] += 1\n\n\nans = 10 ** 10\nfor i in range(1,c**3):\n    x=i%c\n    y=(i%c**2)//c\n    z=i//c**2\n    if x==y or y==z or z==x:\n        continue\n    else:\n        color=[x,y,z]\n        count = 0\n        for s in range(3):\n            for t in range(c):\n                count += c_num[t][s] *D_list[t][color[s]]\n\n        if count < ans:\n            ans = count\n\nprint(ans)\n"]
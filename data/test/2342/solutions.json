["t = int(input())\n\nfor _ in range(t):\n    n, m = [int(x) for x in input().split()]\n    grid = [list(input()) for _ in range(n)]\n\n    has_good = any('G' in l for l in grid)\n\n    if not has_good:\n        print(\"Yes\")\n        continue\n\n    impossible = False\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 'B':\n                continue\n\n            for nbi, nbj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= nbi < n and 0 <= nbj < m:\n                    if grid[nbi][nbj] == 'G':\n                        impossible = True\n                        break\n                    elif grid[nbi][nbj] == 'B' or grid[nbi][nbj] == '#':\n                        continue\n                    elif grid[nbi][nbj] == '.':\n                        grid[nbi][nbj] = \"#\"\n                    else:\n                        assert False, \"What's in the grid?\"\n\n    if grid[n-1][m-1] == '#' or impossible:\n        print(\"No\")\n        continue\n\n    seen = [[False]*m for _ in range(n)]\n    stack = [(n-1, m-1)]\n    seen[n-1][m-1] = True\n\n    while len(stack):\n        i, j = stack.pop()\n\n        for nbi, nbj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= nbi < n and 0 <= nbj < m:\n                if grid[nbi][nbj] != '#' and not seen[nbi][nbj]:\n                    seen[nbi][nbj] = True\n                    stack.append((nbi, nbj))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'G' and not seen[i][j]:\n                impossible = True\n                break\n        if impossible:\n            break\n\n    if impossible:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n", "from collections import deque\n\nT = int(input())\n\n\nclass Found(Exception):\n    pass\n\n\ndef neighbours(M, i, j):\n    res = []\n    if i > 0:\n        res.append((i-1, j))\n    if j > 0:\n        res.append((i, j-1))\n    if i+1 < len(M):\n        res.append((i+1, j))\n    if j+1 < len(M[0]):\n        res.append((i, j+1))\n    return res\n\n\ndef bfs(M, i, j):\n    visited = [[False]*len(M[0]) for _ in range(len(M))]\n    visited[i][j] = True\n    Q = deque()\n    Q.append((i, j))\n    answer = 0\n    if M[i][j] == 'G':\n        answer += 1\n\n    while Q:\n        eli, elj = Q.popleft()\n        if M[eli][elj] == '#':\n            continue\n        for ni, nj in neighbours(M, eli, elj):\n            if M[ni][nj] == '#':\n                continue\n            if visited[ni][nj]:\n                continue\n            visited[ni][nj] = True\n            Q.append((ni, nj))\n            if M[ni][nj] == 'G':\n                answer += 1\n    return answer\n\n\nfor t in range(T):\n    n, m = [int(_) for _ in input().split()]\n    M = []\n    count_G = 0\n    has_B = False\n    for i in range(n):\n        row = [_ for _ in input()]\n        count_G += row.count('G')\n        if 'B' in row:\n            has_B = True\n        M.append(row)\n\n    try:\n        if not count_G:\n            if M[n-1][m-1] == 'B':\n                print('No')\n            else:\n                print('Yes')\n        else:\n            for i in range(len(M)):\n                for j in range(len(M[0])):\n                    if M[i][j] == 'B':\n                        for x, y in neighbours(M, i, j):\n                            if M[x][y] == '.':\n                                M[x][y] = '#'\n                            elif M[x][y] == 'G':\n                                print('No')\n                                raise Found()\n            accessible_G = bfs(M, n-1, m-1)\n            if accessible_G == count_G:\n                print('Yes')\n            else:\n                print('No')\n    except Found:\n        pass\n", "t = int(input())\ndX = [1,-1,0,0]\ndY = [0,0,-1,1]\nfor _ in range(t):\n    n, m = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append(list(input().strip()))\n\n    gCount = 0\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == 'G':\n                gCount += 1\n            elif l[i][j] == 'B':\n                for d in range(4):\n                    x = i + dX[d]\n                    y = j + dY[d]\n                    if 0 <= x < n and 0 <= y < m and l[x][y] == '.':\n                        l[x][y] = '#'\n\n    visited = [[False] * m for i in range(n)]\n    gVisit = 0\n    stack = []\n    if l[n-1][m-1] != '#':\n        stack.append((n-1,m-1))\n        visited[n-1][m-1] = True\n    works = True\n    while stack:\n        nexX, nexY = stack.pop()\n        c = l[nexX][nexY]\n        if c == 'G':\n            gVisit += 1\n        elif c == 'B':\n            works = False\n            break\n\n        for d in range(4):\n            x = nexX + dX[d]\n            y = nexY + dY[d]\n            if 0 <= x < n and 0 <= y < m and l[x][y] != '#' and not visited[x][y]:\n                visited[x][y] = True\n                stack.append((x,y))\n    if works and gVisit == gCount:\n        print('Yes')\n    else:\n        print('No')\n            \n            \n    \n", "from math import *\n\ndef r1(t):\n    return t(input())\n\ndef r2(t):\n    return [t(i) for i in input().split()]\n\ndef r3(t):\n    return [t(i) for i in input()]\n\ng = []\ndef dfs(i, j, n, m):\n    if g[i][j] == '#':\n        return 0\n    ans = 0\n    if g[i][j] == 'G':\n        ans += 1\n    if g[i][j] == 'B':\n        return -100000\n    g[i][j] = '#'\n    if (i > 0):\n        ans += dfs(i - 1, j, n, m)\n    if (i < n - 1):\n        ans += dfs(i + 1, j, n, m)\n    if (j > 0):\n        ans += dfs(i, j - 1, n, m)\n    if (j < m - 1):\n        ans += dfs(i, j + 1, n, m)\n    return ans\n\nfor _ in range(r1(int)):\n    n, m = r2(int)\n    g = []\n    used = []\n    for i in range(n):\n        g.append(r3(str))\n        \n    cnt = 0\n    for i in range(n):\n        for j in range(m):\n            if g[i][j] == 'B':\n                if (i > 0) and g[i-1][j] == '.':\n                    g[i-1][j] = '#'\n                if (i < n - 1)and g[i+1][j] == '.':\n                    g[i+1][j] = '#'\n                if (j > 0)and g[i][j-1] == '.':\n                    g[i][j-1] = '#'\n                if (j < m - 1)and g[i][j + 1] == '.':\n                    g[i][j+1] = '#'\n            elif g[i][j] == 'G':\n                cnt += 1\n    #print(cnt)\n    if (dfs(n - 1, m - 1, n, m) == cnt):\n        print('Yes')\n    else:\n        print('No')\n                \n", "import sys\ninput=lambda:sys.stdin.readline().rstrip('\\n')\nD = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef case():\n\tn, m = list(map(int, input().split()))\n\tM = [list(input()) for _ in range(n)]\n\n\tgood = set()\n\tfor y in range(n):\n\t\tfor x in range(m):\n\t\t\tc = M[y][x]\n\t\t\tif c == 'G':\n\t\t\t\tgood.add((x, y))\n\t\t\telif c == 'B':\n\t\t\t\tfor dx, dy in D:\n\t\t\t\t\tnx = x + dx\n\t\t\t\t\tny = y + dy\n\t\t\t\t\tif nx < 0 or ny < 0 or nx >= m or ny >= n:\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif M[ny][nx] == 'G':\n\t\t\t\t\t\tprint('No')\n\t\t\t\t\t\treturn\n\t\t\t\t\telif M[ny][nx] != 'B':\n\t\t\t\t\t\tM[ny][nx] = '#'\n\n\tif M[-1][-1] == '#':\n\t\tprint('No' if good else 'Yes')\n\t\treturn\n\n\tV = [[False] * m for _ in range(n)]\n\tV[n-1][m-1] = True\n\tQ = [(m-1, n-1)]\n\twhile Q:\n\t\tx, y = Q.pop()\n\n\t\tgood.discard((x, y))\n\t\tfor dx, dy in D:\n\t\t\tnx = x + dx\n\t\t\tny = y + dy\n\n\t\t\tif nx < 0 or ny < 0 or nx >= m or ny >= n: continue\n\t\t\tif M[ny][nx] == '#' or V[ny][nx]: continue\n\t\t\tV[ny][nx] = True\n\t\t\tQ.append((nx, ny))\n\n\tprint('Yes' if not good else 'No')\n\nfor _ in range(int(input())):\n\tcase()\n", "import sys\nstrings = iter(sys.stdin.read().split())\nints = (int(x) for x in strings)\nsys.setrecursionlimit(3000)\n\ndef block(m,R,C,esc,r,c):\n    if esc[r][c]==0:\n        return 1\n    q = [(r,c)]\n    h = set([(r,c)])\n    while q:\n        r,c = q.pop()\n        if m[r][c]=='.':\n            m[r][c]='#'\n        if m[r][c]!='#' and r==R-1 and c==C-1:\n            return 0\n        if m[r][c]!='#':\n            for r,c in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n                if 0<=r<R and 0<=c<C and (r,c) not in h:\n                    q.append((r,c))\n                    h.add((r,c))\n    for r,c in h:\n        esc[r][c] = 0\n    return 1\n\ndef reachability(m,R,C):\n    esc = [[0 for c in range(C)] for r in range(R)]\n    q = [(R-1,C-1)]\n    while q:\n        r,c = q.pop()\n        esc[r][c] = 1\n        if m[r][c]!='#':\n            for r,c in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n                if 0<=r<R and 0<=c<C and esc[r][c]==0:\n                    q.append((r,c))\n    return esc\n\ndef main():\n    ntc = next(ints)\n    for tc in range(1,ntc+1):\n        R,C = (next(ints) for i in range(2))\n        m = [list(next(strings)) for r in range(R)]\n        B = [(r,c) for r in range(R) for c in range(C) if m[r][c]=='B']\n        G = [(r,c) for r in range(R) for c in range(C) if m[r][c]=='G']\n        esc = reachability(m,R,C)\n        ans = all(esc[r][c] for r,c in G)\n        if ans:\n            ans = all(block(m,R,C,esc,r,c) for r,c in B)\n        if ans:\n            esc = reachability(m,R,C)\n            ans = all(esc[r][c] for r,c in G)\n        print('Yes' if ans else 'No')\n    return\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nt=int(input())\nans=[]\nfor _ in range(t):\n\th,w=map(int,input().split())\n\tgrid=[list(input()) for _ in range(h)]\n\tgood=set()\n\tbad=set()\n\tdelta=[(-1,0),(1,0),(0,1),(0,-1)]\n\tfor i in range(h):\n\t\tfor j in range(w):\n\t\t\tif grid[i][j]==\"G\":\n\t\t\t\tgood.add((i,j))\n\t\t\telif grid[i][j]==\"B\":\n\t\t\t\tbad.add((i,j))\n\tif not good:\n\t\tans.append(\"Yes\")\n\t\tcontinue\n\tflg=0\n\tfor ci,cj in bad:\n\t\tfor di,dj in delta:\n\t\t\tni,nj=ci+di,cj+dj\n\t\t\tif 0<=ni<h and 0<=nj<w:\n\t\t\t\tif grid[ni][nj]==\".\":\n\t\t\t\t\tgrid[ni][nj]=\"#\"\n\t\t\t\telif grid[ni][nj]==\"G\":\n\t\t\t\t\tflg=1\n\t\t\t\t\tbreak\n\t\tif flg:\n\t\t\tbreak\n\tif flg or grid[h-1][w-1]==\"#\":\n\t\tans.append(\"No\")\n\t\tcontinue\n\tq=[(h-1,w-1)]\n\tvis=[[0]*w for _ in range(h)]\n\tvis[-1][-1]=1\n\twhile q:\n\t\tci,cj=q.pop()\n\t\tfor di,dj in delta:\n\t\t\tni,nj=ci+di,cj+dj\n\t\t\tif 0<=ni<h and 0<=nj<w and grid[ni][nj]!=\"#\" and not vis[ni][nj]:\n\t\t\t\tvis[ni][nj]=1\n\t\t\t\tq.append((ni,nj))\n\tif all(vis[i][j] for i,j in good):\n\t\tans.append(\"Yes\")\n\telse:\n\t\tans.append(\"No\")\nprint(\"\\n\".join(ans))", "q = int(input())\nfor _ in range(q):\n\tr,c = list(map(int,input().split()))\n\tdef nbr(x,y):\n\t\tout = []\n\t\tif x < r-1:\n\t\t\tout.append([x+1,y])\n\t\tif x > 0:\n\t\t\tout.append([x-1,y])\n\t\tif y > 0:\n\t\t\tout.append([x,y-1])\n\t\tif y < c-1:\n\t\t\tout.append([x,y+1])\n\t\treturn out\n\tmat = [list(input()) for i in range(r)]\n\t#print(mat)\n\tfor x in range(r):\n\t\tfor y in range(c):\n\t\t\tif mat[x][y] == 'B':\n\t\t\t\tfor p in nbr(x,y):\n\t\t\t\t\tif mat[p[0]][p[1]] != 'G' and mat[p[0]][p[1]] != 'B':\n\t\t\t\t\t\tmat[p[0]][p[1]] = '#'\n\tzaj = {}\n\tfor x in range(r):\n\t\tfor y in range(c):\n\t\t\tzaj[(x,y)] = 0\n\tif mat[r-1][c-1] == '#':\n\t\tsu = 0\n\t\tfor i in range(r):\n\t\t\tsu += mat[i].count('G')\n\t\tif su == 0:\n\t\t\tprint(\"Yes\")\n\t\telse:\n\t\t\tprint(\"No\")\n\telse:\n\t\tzaj[(r-1,c-1)] = 1\n\t\tdef dupa(v):\n\t\t\tq = [v]\n\t\t\twhile q:\n\t\t\t\tw = q.pop(0)\n\t\t\t\tfor u in nbr(w[0],w[1]):\n\t\t\t\t\tif mat[u[0]][u[1]] != '#':\n\t\t\t\t\t\tif zaj[tuple(u)] == 0:\n\t\t\t\t\t\t\tq.append(tuple(u))\n\t\t\t\t\t\t\tzaj[tuple(u)] = 1\n\t\tdupa((r-1,c-1))\n\t\t#print(zaj)\n\t\tdasie = True\n\t\tfor x in range(r):\n\t\t\tfor y in range(c):\n\t\t\t\tif mat[x][y] == 'B' and zaj[(x,y)] == 1:\n\t\t\t\t\tdasie = False\n\t\t\t\tif mat[x][y] == 'G' and zaj[(x,y)] == 0:\n\t\t\t\t\tdasie = False\n\t\tif dasie:\n\t\t\tprint(\"Yes\")\n\t\telse:\n\t\t\tprint(\"No\")\n"]
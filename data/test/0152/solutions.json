["n, m, k = list(map(int, input().split()))\nx, s = list(map(int, input().split()))\nt = list(map(int, input().split()))\npr = list(map(int, input().split()))\nt2 = list(map(int, input().split()))\npr2 = list(map(int, input().split()))\nmass1 = []\nminans = 10**20\nfor i in range(m):\n    mass1.append((pr[i], t[i]))\nmass1.sort()\nmass1 = [(0, x)] + mass1\npr2 = [0] + pr2\nt2 = [0] + t2\nuk1 = len(mass1) - 1\nuk2 = 0\nmaxw = 0\nfor uk1 in range(len(mass1) - 1, -1, -1):\n    if (s < mass1[uk1][0]):\n        continue\n    while (uk2 < len(pr2) and mass1[uk1][0] + pr2[uk2] <= s):\n        maxw = max(maxw, t2[uk2])\n        uk2 += 1\n    uk2 -= 1\n    minans = min(minans, (n - maxw) * mass1[uk1][1])\nprint(minans)\n", "def main():\n    read = lambda: list(map(int, input().split()))\n    n, m, k = read()\n    x, s = read()\n    a = list(read())\n    b = list(read())\n    c = list(read())\n    d = list(read())\n    ans = n * x\n    if min(b) <= s:\n        Min2 = min(a[i] for i in range(m) if b[i] <= s)\n        ans = min(ans, n * Min2)\n    b = sorted([(b[i], i) for i in range(m)])\n    j = 0\n    Min = x\n    for i in range(k - 1, -1, -1):\n        while j < m and b[j][0] + d[i] <= s:\n            Min = min(Min, a[b[j][1]])\n            j += 1\n        if d[i] > s: continue\n        cur = (n - c[i]) * Min\n        ans = min(ans, cur)\n    print(ans)\nmain()\n", "import bisect\n\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nz1 = list(zip(a, b))\nz2 = list(zip(c, d))\n\nresult = n * x\n\nfor ai, bi in z1:\n    if bi > s:\n        continue\n\n    current = ai * n\n    if current < result:\n        result = current\n\n    rest = s - bi\n    idx = bisect.bisect_right(d, rest)\n    if idx == 0:\n        continue\n    current = ai * (n - z2[idx-1][0])\n    if current < result:\n        result = current\n\nfor ci, di in z2:\n    if di > s:\n        continue\n    current = x * (n - ci)\n    if current < result:\n        result = current\n\nprint(result)", "n, m, k = list(map(int, input().split()))\nx, s = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\na.append(x)\nb.append(0)\nans = x * n\nfor i in range(m + 1):\n\tif b[i] <= s:\n\t\tl = -1\n\t\tr = k\n\t\twhile l < r - 1:\n\t\t\ty = l + (r - l) // 2\n\t\t\tif d[y] <= s - b[i]:\n\t\t\t\tl = y\n\t\t\telse:\n\t\t\t\tr = y\n\t\tans1 = 0\n\t\tif l > -1:\n\t\t\tans1 = a[i] * max(0, n - c[l])\n\t\telse:\n\t\t\tans1 = a[i] * n\n\t\tif ans1 < ans:\n\t\t\tans = ans1\nprint(ans)\n", "from bisect import bisect_right\n\nn, m, k = [int(x) for x in input().split()]\nx,s = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nans = n * x\nfor i in range(m):\n    if b[i] <= s:\n        cur_s = s - b[i]\n        j = bisect_right(d, cur_s) - 1\n        if j != -1:\n            if (n-c[j])*a[i] < ans:\n                ans = (n-c[j])*a[i]\n        else:\n            if (n)*a[i] < ans:\n                ans = (n)*a[i]\n\nfor i in range(k):\n    if d[i] <= s:\n        if (n - c[i]) * x < ans:\n            ans = (n - c[i]) * x\nprint(ans)\n", "def main():\n    from bisect import bisect\n    n, m, k = list(map(int, input().split()))\n    t, s = list(map(int, input().split()))  # time per stuff,mana\n    aa = list(map(int, input().split()))  # x->t[i] for stuff\n    aa.append(t)\n    bb = list(map(int, input().split()))  # price of t[i]\n    bb.append(0)\n    cc = [0, *list(map(int, input().split())), 0]  # num of instant\n    dd = [0, *list(map(int, input().split())), s + 1]  # price of instant\n    res = []\n    for t, b in zip(aa, bb):\n        b = s - b\n        if b >= 0:\n            i = bisect(dd, b)\n            if b < dd[i]:\n                i -= 1\n            x = n - cc[i]\n            if x <= 0:\n                res = [0]\n                break\n            res.append(x * t)\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nans = n * x\nfor i in range(m):\n    l = 0\n    r = k\n    while (r - l > 1):\n        mid = l + (r - l) // 2\n        if (d[mid] <= s - b[i]):\n            l = mid\n        else:\n            r = mid\n    if (d[l] <= s - b[i]):\n        t = a[i] * (n - c[l])\n        ans = min(ans, t)\nfor i in range(k):\n    if (d[i] <= s):\n        ans = min(ans, x * (n - c[i]))\nfor i in range(m):\n    if (b[i] <= s):\n        ans = min(ans, a[i] * n)\nprint(ans)", "n, m, k = map(int, input().split())\nx, s = map(int, input().split())\nres = n * x\nft = [[0] * 2 for i in range(m)]\nst = [[0] * 2 for i in range(k)]\ntmparr = list(map(int, input().split()))\nfor i in range(m):\n    ft[i][0] = tmparr[i]\ntmparr = list(map(int, input().split()))\nfor i in range(m):\n    ft[i][1] = tmparr[i]\ntmparr = list(map(int, input().split()))\nfor i in range(k):\n    st[i][0] = tmparr[i]\ntmparr = list(map(int, input().split()))\nfor i in range(k):\n    st[i][1] = tmparr[i]\nfor i in range(m):\n    nows = s - ft[i][1]\n    if (nows < 0):\n        continue\n    nowr = n * ft[i][0]\n    if (nows >= st[0][1]):\n        l = 0\n        r = k\n        while r - l > 1:\n            m = (l + r) // 2\n            if (st[m][1] <= nows):\n                l = m\n            else:\n                r = m\n        nowr -= ft[i][0] * st[l][0]\n    res = min(res, nowr)\nfor i in range(k):\n    if (st[i][1] <= s):\n        res = min(res, x * (n - st[i][0]))\nprint(res)", "#!/usr/bin/env python3\n\nfrom sys import stdin\nfrom bisect import bisect_right\n\n\ndef main():\n    n, m, k = stdin_get_ints_from_line() # amount to brew, first cast count, second cask count 2*10^9, 2*10^5, 2*10^5\n    x, s = stdin_get_ints_from_line() # time to brew, mana amount\n\n    a = stdin_get_ints_list_from_line() # time to brew with ai first cast 2*10^9\n    b = stdin_get_ints_list_from_line() # cost of first cast 2*10^9\n    c = stdin_get_ints_list_from_line() # amount to brew instantly 2*10^9\n    d = stdin_get_ints_list_from_line() # cost of second cast 2*10^9\n\n    result = n * x\n\n    key = bisect_right(d, s)\n\n    if key != 0:\n        spell2_only_result = (n - c[key-1]) * x\n        if spell2_only_result < result:\n            result = spell2_only_result\n\n    for key, val in enumerate(b):\n        if val <= s:\n            if a[key] < x:\n                cost_left = s - val\n                amount_second = 0\n\n                key2 = bisect_right(d, cost_left)\n\n                if key2 != 0:\n                    amount_second = c[key2-1]\n\n                r = (n-amount_second) * a[key]\n\n                if r < result:\n                    result = r\n                if result <= 0:\n                    break\n\n    print(result) if result > 0 else print(0)\n\n\ndef stdin_get_ints_from_line():\n    return (int(x) for x in stdin.readline().strip().split(' '))\n\n\ndef stdin_get_ints_list_from_line():\n    return list(int(x) for x in stdin.readline().strip().split(' '))\n\n\ndef stdin_get_string_from_line():\n    return stdin.readline().strip()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\n\nn, m, k = map(int, input().split(' '))\nx, s = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\nb = list(map(int, input().split(' ')))\nc = list(map(int, input().split(' ')))\nd = list(map(int, input().split(' ')))\na.append(x)\nb.append(0)\nans = n * x\nfor i in range(m+1):\n    if b[i] <= s:\n        j = bisect.bisect_right(d, s - b[i])\n        if j > 0:\n            j -= 1\n            ans = min(ans, (n-c[j])*a[i])\n        else:\n            ans = min(ans, n*a[i])\nprint(ans)", "n,m,k = [int(i) for i in input().split()]\nx,s = [int(i) for i in input().split()]\na_t = [int(i) for i in input().split()]\na_m = [int(i) for i in input().split()]\nb_p = [int(i) for i in input().split()]\nb_m = [int(i) for i in input().split()]\n\nmin_time = n * x\n\na_t.append(x)\na_m.append(0)\n\nfor i in range(m+1):\n    re_mana = s - a_m[i]\n    if re_mana < 0:\n        continue\n    inf = -1\n    sup = k\n    while inf<sup-1:\n        #print(inf,sup)\n        mid = (inf+sup)//2\n        if b_m[mid] <= re_mana:\n            inf = mid\n        else:\n            sup = mid \n    if inf<=-1:\n        min_time = min(min_time,n*a_t[i])\n    else:\n        min_time = min(min_time,max(0,n-b_p[inf])*a_t[i])\n\n\n\nprint(min_time)\n", "n,m,k = [int(i) for i in input().split()]\nx,s = [int(i) for i in input().split()]\na_t = [int(i) for i in input().split()]\na_m = [int(i) for i in input().split()]\nb_p = [int(i) for i in input().split()]\nb_m = [int(i) for i in input().split()]\n\nmin_time = n * x\n\nfor i in range(m):\n    re_mana = s - a_m[i]\n    if re_mana < 0:\n        continue\n    inf = -1\n    sup = k\n    while inf<sup-1:\n        #print(inf,sup)\n        mid = (inf+sup)//2\n        if b_m[mid] <= re_mana:\n            inf = mid\n        else:\n            sup = mid\n    if inf==-1:\n        min_time = min(min_time,n*a_t[i])\n    else:\n        min_time = min(min_time,max(0,n-b_p[inf])*a_t[i])\n\nfor i in range(k):\n    if s>=b_m[i]:\n        min_time = min(min_time,max(0,(n-b_p[i]))*x)\nprint(min_time)\n", "import math\nn, m, k = list(map(int,input().split()))\nx, s = list(map(int,input().split()))\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\nd = list(map(int,input().split()))\na.insert(0,x)\nb.insert(0,0)\nc.insert(0,0)\nd.insert(0,0)\nans = 1<<100\nfor it in range(m+1):\n    mana = s-b[it]\n    if mana<0: continue\n    lo, hi = 0, k\n    while lo!=hi:\n        mid = math.ceil((lo+hi)/2)\n        if d[mid]<=mana: lo = mid\n        else: hi = mid-1\n    ans = min(ans,(n-c[lo])*a[it])\nprint(ans)\n", "from sys import stdin, stdout\nn, m, k = list(map(int,stdin.readline().split()))\nx, s = list(map(int,stdin.readline().split()))\na = list(map(int,stdin.readline().split()))\nb = list(map(int,stdin.readline().split()))\nc = list(map(int,stdin.readline().split()))\nd = list(map(int,stdin.readline().split()))\na.insert(0,x)\nb.insert(0,0)\nc.insert(0,0)\nd.insert(0,0)\nans = 1<<100\nfor it in range(m+1):\n    mana = s-b[it]\n    if mana<0: continue\n    lo, hi = 0, k\n    while lo!=hi:\n        mid = (lo+hi+1)//2\n        if d[mid]<=mana: lo = mid\n        else: hi = mid-1\n    ans = min(ans,(n-c[lo])*a[it])\nstdout.write(str(ans)+'\\n')\n", "import bisect\n(n,m,k), (x,s), a, b, c, d = (list(map(int, input().split())) for _ in range(6))\na, b = list(a) + [x], list(b) + [0]\nc, d = list(map(list, (c, d)))\n\nans = n * x\nfor i in range(m + 1):\n    if b[i] <= s:\n        j = bisect.bisect_right(d, s - b[i])\n        if j > 0:\n            j -= 1\n            ans = min(ans, (n - c[j]) * a[i])\n        else:\n            ans = min(ans, n * a[i])\nprint(ans)\n", "import bisect \n\ndef anton_and_magic_potions():\n\n\tno_potions, no_fst_spell, no_snd_spell = [int(x) for x in input().split(' ')]\n\tinitial_time, mana = [int(x) for x in input().split(' ')]\n\tfirst_spell = [int(x) for x in input().split(' ')]\n\tmana_first_spell = [int(x) for x in input().split(' ')]\n\tpotions_second_spell = [int(x) for x in input().split(' ')]\n\tmana_second_spell = [int(x) for x in input().split(' ')]\n\n\tfirst_spell.append(initial_time)\n\tmana_first_spell.append(0)\n\n\ttotal_time = no_potions * initial_time\n\n\tfor i in  range(no_fst_spell + 1):\n\n\t\tif mana_first_spell[i] > mana:\n\t\t\tcontinue\n\n\t\tpos2 = bisect.bisect_right(mana_second_spell, mana -mana_first_spell[i]) - 1\n\t\tif pos2 >=0:\n\t\t\tno_potions2 = no_potions - potions_second_spell[pos2]\n\t\t\tres = no_potions2 * first_spell[i]\n\t\telse:\n\t\t\tres = no_potions * first_spell[i]\n\t\ttotal_time = min(total_time, res)\n\n\n\tprint(total_time)\n\nanton_and_magic_potions()", "n,m,k = list(map(int,input().split()))\nx,s = list(map(int,input().split()))\nk += 1 \nm += 1\na = [x] + [int(x) for x in input().split()]\nb = [0] + [int(x) for x in input().split()]\nc = [0] + [int(x) for x in input().split()]\nd = [0] + [int(x) for x in input().split()]\nfir = []\nfor i in range(m): \n\tfir.append([a[i],b[i]])\nfir.sort(key = lambda x : x[1])\nans = n * x\nfor i in range(m):\n\tleft = s - fir[i][1]\n\tif (left < 0) : break\n\twhile(d[k-1] > left) : k -= 1\n\tnow = (n - c[k-1]) * fir[i][0]\n\tans = min(ans,now)\nprint(ans)\n\n", "n,m,k = list(map(int,input().split()))\nx,s = list(map(int,input().split()))\na_time = list(map(int,input().split()))\na_cost = list(map(int,input().split()))\nb_num = list(map(int,input().split()))\nb_cost = list(map(int,input().split()))\n\ndef binary_search(manapoints):\n    nonlocal  k,b_cost\n    l = 0;  r = k-1;  pos = -1\n    while (l <= r):\n        mid = int((l+r)/2)\n        if (b_cost[mid] <= manapoints):\n            l = mid+1;  pos = mid;\n        else :\n            r = mid-1\n    return pos\nres = n*x\npos = binary_search(s)\nif (pos >= 0):  res = min(res,(n-b_num[pos])*x);\nfor i in range(m):\n    if (a_cost[i] > s): continue;\n    rest = s-a_cost[i]\n    pos = binary_search(rest)\n    if (pos >= 0):  res = min(res,(n-b_num[pos])*a_time[i])\n    else : res = min(res,n*a_time[i])\nprint(res)", "n,m,k = map(int, input().split())\nx,s = map(int, input().split())\n\na = [x] + list(map(int, input().split()))\nb = [0] + list(map(int, input().split()))\nc = [0] + list(map(int, input().split()))\nd = [0] + list(map(int, input().split()))\n\nab = list(zip(a,b))\nab.sort(key=lambda x:-x[1])\n\nans = x*n\nind = 0\n\nfor ai,bi in ab:\n    while ind<k+1 and d[ind]<=(s-bi): ind+=1\n    if ind==0: continue\n    tmp = (n-c[ind-1])*ai\n    ans = min(ans, tmp)\n\nprint(ans)", "n,m,k = map(int, input().split())\nx,s = map(int, input().split())\n\na = [x] + list(map(int, input().split()))\nb = [0] + list(map(int, input().split()))\nc = [0] + list(map(int, input().split()))\nd = [0] + list(map(int, input().split()))\n\nab = list(zip(a,b))\nab.sort(key=lambda x:-x[1])\n\nans = x*n\nind = 0\n\nfor ai,bi in ab:\n    while ind<k+1 and d[ind]<=(s-bi): ind+=1\n    if ind==0: continue\n    ans = min(ans, (n-c[ind-1])*ai)\n\nprint(ans)", "n, m, k = map(int, input().split())\nx, s = map(int, input().split())\nA = [x] + list(map(int, input().split()))\nB = [0] + list(map(int, input().split()))\nC = [0] + list(map(int, input().split()))\nD = [0] + list(map(int, input().split()))\nQW = list(zip(A, B))\nQW.sort(key = lambda x : x[1])\nA = [s[0] for s in QW]\nB = [s[1] for s in QW]\n\nRes = x * n\n\nfor i in range(1, k + 1):\n    C[i] = max(C[i], C[i - 1])\nl = k\ne = 10**19\n\nfor i in range(m + 1):\n    e = min(e, A[i])\n    while l >= 0 and B[i] + D[l] > s:\n        l -= 1\n    if l >= 0:\n        Res = min(Res, max(n - C[l], 0) * A[i])\n    \n\n\nprint(Res)", "n,m,k = (int(x) for x in input().split())\norig,s = (int(x) for x in input().split())\ntime1 = [orig] + [int(x) for x in input().split()]\ncost1 = [0] + [int(x) for x in input().split()]\nmake2 = [0] + [int(x) for x in input().split()]\ncost2 = [0] + [int(x) for x in input().split()]\n\nordcost1 = [ (x,i) for i,x in enumerate(cost1) ]\nordcost1.sort()\ncount = k\nbest = orig*n\n\nfor i in range(m+1):\n\tcost,ind = ordcost1[i]\n\twhile count > -1 and cost2[count] + cost > s:\n\t\tcount -= 1\n\tif count > -1 and time1[ind] * (n - make2[count]) < best:\n\t\tbest = time1[ind] * (n - make2[count])\n\nprint(best)", "class First:\n    def __init__(self, seconds, cost):\n        self.seconds = seconds\n        self.cost = cost\nclass Second:\n    def __init__(self, numCreated, cost):\n        self.numCreated = numCreated\n        self.cost = cost\n\ndef solve():\n    potionCount, firstCount, secondCount = map(int, input().split())\n    secondsOne, manaPoints = map(int, input().split())\n    first = list()\n    a, b = list(map(int, input().split())), list(map(int, input().split()))\n    for i in range(firstCount):\n        first.append(First(a[i], b[i]))\n    first.append(First(secondsOne, 0))\n    second = [Second(0, 0)]\n    a, b = list(map(int, input().split())), list(map(int, input().split()))\n    for i in range(secondCount):\n        second.append(Second(a[i], b[i]))\n    res = int(1e20)\n    for f in first:\n        low = 0\n        high = len(second) - 1\n        while low < high:\n            mid = (low + high + 1) // 2\n            if f.cost + second[mid].cost > manaPoints:\n                high = mid - 1\n            else:\n                low = mid\n        if f.cost + second[low].cost <= manaPoints:\n            moar = max(0, potionCount - second[low].numCreated)\n            time = moar * f.seconds\n            res = min(res, time)\n    print(res)\nsolve()", "class First:\n    def __init__(self, seconds, cost):\n        self.seconds = seconds\n        self.cost = cost\nclass Second:\n    def __init__(self, numCreated, cost):\n        self.numCreated = numCreated\n        self.cost = cost\n\ndef solve():\n    potionCount, firstCount, secondCount = map(int, input().split())\n    secondsOne, manaPoints = map(int, input().split())\n    first = list()\n    a, b = list(map(int, input().split())), list(map(int, input().split()))\n    for i in range(firstCount):\n        first.append(First(a[i], b[i]))\n    first.append(First(secondsOne, 0))\n    second = [Second(0, 0)]\n    a, b = list(map(int, input().split())), list(map(int, input().split()))\n    for i in range(secondCount):\n        second.append(Second(a[i], b[i]))\n    res = int(1e20)\n    for f in first:\n        low = 0\n        high = len(second) - 1\n        while low < high:\n            mid = (low + high + 1) // 2\n            if f.cost + second[mid].cost > manaPoints:\n                high = mid - 1\n            else:\n                low = mid\n        if f.cost + second[low].cost <= manaPoints:\n            moar = max(0, potionCount - second[low].numCreated)\n            time = moar * f.seconds\n            res = min(res, time)\n    print(res)\nsolve()"]
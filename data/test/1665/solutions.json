["#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\n# Code by H~$~C\n\nfrom sys import stdin\ninput = stdin.readline\nimport math\n\nn = int(input())\nG = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n  u, v = map(int, input().split())\n  G[u].append([v, i])\n  G[v].append([u, i])\n\nans = [-1] * (n + 1)\n\nfor u in range(1, n + 1):\n  if (len(G[u]) >= 3):\n    for j in range(len(G[u])):\n      ans[G[u][j][1]] = j\n    cnt = len(G[u])\n    for j in range(n - 1):\n      if (ans[j] == -1):\n        ans[j] = cnt\n        cnt += 1\n    for j in range(n - 1):\n      print(ans[j])\n    return\n\nfor i in range(n - 1):\n  print(i)", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nE=[[] for i in range(n+1)]\nD=dict()\nDEG=[0]*(n+1)\nfor i in range(n-1):\n    x,y=list(map(int,input().split()))\n    E[x].append(y)\n    E[y].append(x)\n    D[x,y]=i\n    D[y,x]=i\n    DEG[x]+=1\n    DEG[y]+=1\n\nANS=[-1]*(n-1)\n\nLIST=[]\nfor i in range(n+1):\n    if DEG[i]==1:\n        LIST.append(i)\n\nif len(LIST)==2:\n    for i in range(n-1):\n        print(i)\n\nelse:\n    now=0\n    for l in LIST:\n        k=E[l][0]\n        ANS[D[k,l]]=now\n        now+=1\n\n    #print(ANS)\n\n    for i in range(n-1):\n        if ANS[i]==-1:\n            ANS[i]=now\n            now+=1\n\n    for a in ANS:\n        print(a)\n\n\n", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\nfrom math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(100000)\n\nn=int(input())\nt=[dd(int) for i in range(n)]\nl=[]\nfor i in range(n-1):\n    u,v=mdata()\n    t[u-1][v-1]=0\n    t[v-1][u-1]=0\n    l.append([u-1,v-1])\ns=0\ne=n-2\nfor i in range(n-1):\n    a,b=l[i]\n    if len(t[a])==1 or len(t[b])==1:\n        print(s)\n        s+=1\n    else:\n        print(e)\n        e-=1", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn = int(input())\nadj = [[] for _ in range(n)]\nfor i in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1].append((v-1, i))\n\tadj[v-1].append((u-1, i))\n\nif max([len(x) for x in adj]) <= 2:\n\tprint(*list(range(n-1)), sep=\"\\n\")\nelse:\n\tans = [-1 for _ in range(n-1)]\n\tfor i in range(n):\n\t\tif len(adj[i]) > 2:\n\t\t\tans[adj[i][0][1]] = 0\n\t\t\tans[adj[i][1][1]] = 1\n\t\t\tans[adj[i][2][1]] = 2\n\t\t\tbreak\n\ttmp = 3\n\tfor i in range(n-1):\n\t\tif ans[i] < 0:\n\t\t\tans[i] = tmp\n\t\t\ttmp += 1\n\tprint(*ans, sep=\"\\n\")\n", "import sys\ninput = sys.stdin.readline\n\n\nn = int(input())\ninfo = [list(map(int, input().split())) for i in range(n - 1)]\n\ntree = [[] for i in range(n)]\nmemo = {}\nfor i in range(n - 1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    tree[a].append(b)\n    tree[b].append(a)\n    memo[a * 1000000 + b] = i\nans = [-1] * (n - 1)\npos = 0\nfor i in range(n):\n    if len(tree[i]) == 1:\n        a, b = i, tree[i][0]\n        if a > b:\n            a, b = b, a\n        ans[memo[a * 1000000 + b]] = pos\n        pos += 1\nfor i in range(n - 1):\n    if ans[i] == -1:\n        ans[i] = pos\n        pos += 1\nif n == 2:\n    print(0)\n    return\nfor i in ans:\n    print(i)", "import sys\ninput=sys.stdin.readline\nn=int(input())\nL=[[]for i in range(n)]\nM=dict()\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    M[i]=(a,b)\n    L[a-1].append(b)\n    L[b-1].append(a)\nmxnode=-1\nmxdeg=0\nfor j in range(n):\n    if len(L[j])>mxdeg:\n        mxdeg=len(L[j])\n        mxnode=j+1\nmxpt=0\nnormpt=0\nmxedge=list(range(mxdeg))\nnoredg=list(range(mxdeg,n))\nfor j in range(n-1):\n    if mxnode in M[j]:\n        print(mxedge[mxpt])\n        mxpt+=1\n    else:\n        print(noredg[normpt])\n        normpt+=1"]
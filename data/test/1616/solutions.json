["MAX = 1_000_005\nlp = [0] * MAX\npr = []\npid = {1: 0}\nfor i in range(2, MAX):\n    if not lp[i]:\n        lp[i] = i\n        pr.append(i)\n        pid[i] = len(pr)\n    for p in pr:\n        if p > lp[i] or i * p >= MAX:\n            break\n        lp[i * p] = p\n\nn = int(input())\na = list(map(int, input().split()))\n\ng = [[] for _ in range(len(pid))]\nec = 0\nfor x in a:\n    f = []\n    while x > 1:\n        p, c = lp[x], 0\n        while lp[x] == p:\n            x //= p\n            c ^= 1\n        if c:\n            f.append(p)\n    if not f:\n        print(1)\n        import sys\n        return\n    f += [1] * (2 - len(f))\n    u, v = pid[f[0]], pid[f[1]]\n    g[u].append((v, ec))\n    g[v].append((u, ec))\n    ec += 1\n\ndef bfs(p):\n    d = [-1] * len(pid)\n    d[p] = 0\n    q = [(p, -1)]\n    while q:\n        q2 = []\n        for u, peid in q:\n            for v, eid in g[u]:\n                if d[v] != -1:\n                    if eid != peid:\n                        return d[u] + d[v] + 1\n                else:\n                    d[v] = d[u] + 1\n                    q2.append((v, eid))\n        q = q2\n\nans = -1\nfor i in range(len(pid)):\n    if i > 0 and pr[i - 1] ** 2 >= MAX:\n        break\n    cyc = bfs(i) or ans\n    if ans == -1 or cyc < ans:\n        ans = cyc\nprint(ans)", "import sys\n\nMAX = 1_000_005\nlp = [0] * MAX\npr = []\npid = {1: 0}\nfor i in range(2, MAX):\n    if not lp[i]:\n        lp[i] = i\n        pr.append(i)\n        pid[i] = len(pr)\n    for p in pr:\n        if p > lp[i] or i * p >= MAX:\n            break\n        lp[i * p] = p\n\nn = int(input())\na = list(map(int, input().split()))\n\ng = [[] for _ in range(len(pid))]\ne = set()\nfor x in a:\n    f = []\n    while x > 1:\n        p, c = lp[x], 0\n        while lp[x] == p:\n            x //= p\n            c ^= 1\n        if c:\n            f.append(p)\n    if not f:\n        print(1)\n        return\n    f += [1] * (2 - len(f))\n    u, v = pid[f[0]], pid[f[1]]\n    if (u, v) in e or (v, u) in e:\n        print(2)\n        return\n    g[u].append(v)\n    g[v].append(u)\n\ndef bfs(s):\n    d = [-1] * len(pid)\n    d[s] = 0\n    q = [(s, -1)]\n    while q:\n        q2 = []\n        for u, p in q:\n            for v in g[u]:\n                if d[v] != -1:\n                    if v != p:\n                        return d[u] + d[v] + 1\n                else:\n                    d[v] = d[u] + 1\n                    q2.append((v, u))\n        q = q2\n\nans = n + 1\nfor i in range(len(pid)):\n    if i > 0 and pr[i - 1] ** 2 >= MAX:\n        break\n    ans = min(ans, bfs(i) or ans)\nprint(ans if ans <= n else -1)\n", "import sys\n\nMAX = 1_000_005\nlp = [0] * MAX\npr = []\npid = {1: 0}\nfor i in range(2, MAX):\n\tif not lp[i]:\n\t\tlp[i] = i\n\t\tpr.append(i)\n\t\tpid[i] = len(pr)\n\tfor p in pr:\n\t\tif p > lp[i] or i * p >= MAX:\n\t\t\tbreak\n\t\tlp[i * p] = p\n\nn = int(input())\na = list(map(int, input().split()))\n\ng = [[] for _ in range(len(pid))]\ne = set()\nfor x in a:\n\tf = []\n\twhile x > 1:\n\t\tp, c = lp[x], 0\n\t\twhile lp[x] == p:\n\t\t\tx //= p\n\t\t\tc ^= 1\n\t\tif c:\n\t\t\tf.append(p)\n\tif not f:\n\t\tprint(1)\n\t\treturn\n\tf += [1] * (2 - len(f))\n\tu, v = pid[f[0]], pid[f[1]]\n\tif (u, v) in e or (v, u) in e:\n\t\tprint(2)\n\t\treturn\n\tg[u].append(v)\n\tg[v].append(u)\n\ndef bfs(s):\n\td = [-1] * len(pid)\n\td[s] = 0\n\tq = [(s, -1)]\n\twhile q:\n\t\tq2 = []\n\t\tfor u, p in q:\n\t\t\tfor v in g[u]:\n\t\t\t\tif d[v] != -1:\n\t\t\t\t\tif v != p:\n\t\t\t\t\t\treturn d[u] + d[v] + 1\n\t\t\t\telse:\n\t\t\t\t\td[v] = d[u] + 1\n\t\t\t\t\tq2.append((v, u))\n\t\tq = q2\n\nans = n + 1\nfor i in range(len(pid)):\n\tif i > 0 and pr[i - 1] ** 2 >= MAX:\n\t\tbreak\n\tans = min(ans, bfs(i) or ans)\nprint(ans if ans <= n else -1)\n"]
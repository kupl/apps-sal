["class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         '''\n         \u9006\u56de\uff0c\u5f53\u662f\u5c0f\u4e8e\u7b49\u4e8e0\u65f6\uff0c\u662f\u76f8\u53cd\u6570+1.   dp\u4e3a\u5230\u5f53\u524di,j\u53ea\u8981\u9700\u8981\u7684\u70b9\u6570\uff0c \u6700\u5c0f\u4e3a1\uff0c\u4fdd\u8bc1 \u6d3b\u7740\n         \n         r,  c   r   ,c+1\n         r+1,c   r+1,c+1\n         \n         r,c\u5904\u81f3\u5c11\u7684\u70b9\u6570 - r,c\u5904\u60e9\u7f5a\u70b9\u6570  \u662f  \u5176\u4e0b\u9762\u548c\u53f3\u9762\u6700\u5c11\u9700\u8981\u7684\u70b9\u6570\uff0c  \u4e5f\u5c31\u662f\u7b2c33\u884c\n         \n         '''\n         row = len(dungeon)\n         col = len(dungeon[0])\n         dp = [[0 for  c in range(col)] for r in range(row)]\n         if dungeon[-1][-1] <= 0:\n             dp[-1][-1] = -dungeon[-1][-1] + 1\n         else:\n             dp[-1][-1] = 1\n         for r in range(row-2,-1,-1):\n             dp[r][-1] = dp[r+1][-1]  - dungeon[r][-1]\n             if dp[r][-1] <= 0:\n                 dp[r][-1] = 1\n         for c in range(col-2,-1,-1):\n             dp[-1][c] = dp[-1][c+1]  - dungeon[-1][c]\n             if dp[-1][c] <= 0:\n                 dp[-1][c] = 1\n         for r in range(row-2,-1,-1):\n             for c in range(col-2,-1,-1):\n                 dp[r][c] = min(dp[r+1][c],dp[r][c+1]) - dungeon[r][c]\n                 if dp[r][c] <= 0:\n                     dp[r][c] = 1\n         return dp[0][0]\n", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n \n         # sol1: DP, choose the safest path\n         # http://leetcodesolution.blogspot.kr/2015/01/leetcode-dungeon-game.html\n         # minInitHealth[i][j] = min(minInitHealth[i+1][j], minInitHealth[i][j+1]) - dungeon[i][j]\n         # set minInitHealth[i][j] to 1 if < 1\n         M, N = len(dungeon), len(dungeon[0])\n         dp = [[0] * N for _ in range(M)]\n         for i in reversed(list(range(M))):\n             for j in reversed(list(range(N))):\n                 v = dungeon[i][j]\n                 # choose right/down, which requires less\n                 if i == M - 1 and j == N - 1:\n                     dp[i][j] = 1 - v\n                 elif i == M - 1:\n                     dp[i][j] = dp[i][j + 1] - v\n                 elif j == N - 1:\n                     dp[i][j] = dp[i + 1][j] - v\n                 else:\n                     dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - v\n                 # always ensure >= 1\n                 dp[i][j] = max(1, dp[i][j])\n         return dp[0][0]\n", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m=len( dungeon)  \n         n=len( dungeon[0])\n         \n         dp=[[float('inf') for _ in range(n+1)] for _ in range(m+1)]\n         dp[m][n-1]=1\n         dp[m-1][n]=1\n         \n         for i in range(m-1,-1,-1):\n             for j in range(n-1,-1,-1):\n                 \n                 need =min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]\n                 if need <=0:\n                     need=1\n                 dp[i][j]=need \n         return dp[0][0]        ", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(dungeon[0])\n         need = [2**31] * (n-1) + [1]\n         for row in dungeon[::-1]:\n             for j in range(n)[::-1]:\n                 need[j] = max(min(need[j:j+2]) - row[j], 1)\n         return need[0]", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         if not dungeon or not dungeon[0]:\n             return 1\n         dp = [[0 for i in range(len(dungeon[0]))] for i in range(len(dungeon))]\n         dp[-1][-1] = 1 - dungeon[-1][-1]\n         row = len(dungeon)\n         column = len(dungeon[0])\n         for i in range(1,row):\n             dp[row-1-i][-1] = max(1 - dungeon[row-1-i][-1], dp[row-i][-1] - dungeon[row-1-i][-1])\n         for i in range(1,column):\n             dp[-1][column-1-i] = max(1 - dungeon[-1][column-1-i], dp[-1][column-i] - dungeon[-1][column-1-i])\n         for i in range(1,row):\n             for j in range(1,column):\n                 dp[row-1-i][column-1-j] = max(1 - dungeon[row-1-i][column-1-j], min(dp[row-i][column-1-j],dp[row-1-i][column-j]) - dungeon[row-1-i][column-1-j])\n         if dp[0][0] <= 0:\n             return 1\n         return dp[0][0]\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         num_rows = len(dungeon)\n         num_cols = len(dungeon[0])\n         INF = float('inf')\n         for ri in range(num_rows - 1, -1, -1):\n             for ci in range(num_cols - 1, -1, -1):\n                 if ri == num_rows - 1 and ci == num_cols - 1:\n                     need = -dungeon[ri][ci] + 1\n                 else:\n                     down = INF if ri == num_rows - 1 else dungeon[ri+1][ci]\n                     right = INF if ci == num_cols - 1 else dungeon[ri][ci + 1]\n                     need = min(down, right) - dungeon[ri][ci]\n                 dungeon[ri][ci] = max(need, 1)\n         return dungeon[0][0]\n", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         best = [[0] * len(dungeon[0]) for x in range(0, len(dungeon))]\n         for row in range(-1, -len(dungeon) - 1, -1):\n             for col in range(-1, -len(dungeon[0]) - 1, -1):\n                 needed = -dungeon[row][col]\n                 nextSteps = []\n                 if row < -1:\n                     nextSteps.append(best[row + 1][col])\n                 if col < -1:\n                     nextSteps.append(best[row][col + 1])\n                 if len(nextSteps) > 0:\n                     needed += min(nextSteps)\n                 needed = max(0, needed)\n                 best[row][col] = needed\n                 \n         return best[0][0] + 1", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m,n =len(dungeon), len(dungeon[0])\n         record=[[None]*n for i in range(m)]\n         record[-1][-1]=max(1-dungeon[-1][-1], 1)\n         for i in range(n-1)[::-1]:\n             record[m-1][i]=max(1, record[m-1][i+1]-dungeon[m-1][i])\n         for j in range(m-1)[::-1]:\n             record[j][n-1]=max(1, record[j+1][n-1]-dungeon[j][n-1])\n         \n         for i in range(m-1)[::-1]:\n             for j in range(n-1)[::-1]:\n                 mina=max(record[i+1][j]-dungeon[i][j], 1)\n                 minb=max(record[i][j+1]-dungeon[i][j], 1)\n                 record[i][j]=min(mina,minb)\n         return record[0][0]", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not dungeon or not dungeon[0]:\n             return 1\n         \n         m = len(dungeon)\n         n = len(dungeon[0])\n         \n         dp = [None] * n\n         \n         for i in range(m - 1, -1, -1):\n             for j in range(n - 1, -1, -1):\n                 tmp = []\n                 if i + 1 < m:\n                     tmp.append(dp[j])\n                 \n                 if j + 1 < n:\n                     tmp.append(dp[j + 1])\n                 \n                 minLeft = 1\n                 if tmp:\n                     minLeft = min(tmp)\n                 \n                 dp[j] = max(minLeft - dungeon[i][j], 1)\n         \n         return dp[0]", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(dungeon)\n         m = len(dungeon[0])\n \n         for i in range(n-1, -1, -1):\n             for j in range(m-1, -1, -1):\n                 if i+1 < n and j+1 < m:\n                     temp = max(dungeon[i+1][j], dungeon[i][j+1])\n                 elif i+1 < n:\n                     temp = dungeon[i+1][j]\n                 elif j+1 < m:\n                     temp = dungeon[i][j+1]\n                 else:\n                     temp = 0\n                 print(temp)\n                 dungeon[i][j] = dungeon[i][j] + temp\n                 dungeon[i][j] = min(dungeon[i][j], 0)\n         return(max(1, 1-dungeon[0][0]))", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(dungeon)\n         n = len(dungeon[0])\n         dp = [0] * n\n         dp[n-1] = max(1, 1 - dungeon[m-1][n-1])\n         for i in range(m-1, -1, -1):\n             for j in range(n-1, -1, -1):\n                 if i == m-1 and j == n-1:\n                     continue\n                 if i == m-1:\n                     dp[j] = max(1, dp[j+1] - dungeon[i][j])\n                 elif j == n-1:\n                     dp[j] = max(1, dp[j] - dungeon[i][j])\n                 else:\n                     dp[j] = max(1, min(dp[j], dp[j+1]) - dungeon[i][j])\n         return dp[0]", "class Solution:\n     def calculateMinimumHP(self, dungeon):\n         \"\"\"\n         :type dungeon: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not any(dungeon):\n             return 1\n         m = len(dungeon)\n         n = len(dungeon[0])\n         memo = {(m - 1, n - 1): 1}\n         def helper(i, j):\n             if (i, j) not in memo:\n                 if i == m - 1:\n                     ans = max(1, helper(i, j+1) - dungeon[i][j+1])\n                 elif j == n - 1:\n                     ans = max(1, helper(i+1, j) - dungeon[i+1][j])\n                 else:\n                     ans = min(max(1, helper(i, j+1) - dungeon[i][j+1]),\n                              max(1, helper(i+1, j) - dungeon[i+1][j]))\n                 memo[(i, j)] = ans\n             return memo[(i, j)]\n         return max(1, helper(0, 0) - dungeon[0][0])\n         \n"]
["from sys import stdin\nfrom collections import defaultdict\nimport heapq\n\nn = int(stdin.readline())\na = [[] for _ in range(n)]\nfor _ in range(n-1):\n    e = stdin.readline().split(' ')\n    u, v = int(e[0]), int(e[1])\n    a[u-1].append(v-1)\n    a[v-1].append(u-1)\n\n\nleaves = [i for i in range(n) if len(a[i]) == 1]\n\n\ndef dfs_from(root):\n    depth = defaultdict(int)\n    child = {}\n    parent = defaultdict(lambda: -1)\n    stack = [root]\n    visited = [False for _ in range(n)]\n    while len(stack) > 0:\n        crt = stack[-1]\n        if visited[crt]:\n            stack.pop(-1)\n            if len(a[crt]) > 1:  # not a leaf\n                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]\n                                              if c != parent[crt]],\n                                             key=lambda x: x[1])\n            else:\n                child[crt] = -1\n                depth[crt] = 0\n            continue\n\n        visited[crt] = True\n        for next in a[crt]:\n            if next != parent[crt]:\n                stack.append(next)\n                parent[next] = crt\n\n    return depth, child\n\n\nfirst_choice = leaves[0]\nd1, child1 = dfs_from(first_choice)\n\nroot = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],\n           key=lambda leaf_depth: leaf_depth[1])[0]\nwhile child1[root] != -1:\n    root = child1[root]\ndepth, child = dfs_from(root)\n\nsolution = [1]\npq = []\nfor k, v in list(depth.items()):\n    heapq.heappush(pq, (-v, k))\n\nseen = [False for _ in range(n)]\nseen[root] = True\n\nwhile len(pq) > 0:\n    _, best = heapq.heappop(pq)\n    if seen[best]:\n        continue\n    path = []\n    c = best\n    s = 0\n    while c != -1:\n        seen[c] = True\n        c = child[c]\n        s = s+1\n    s = s + solution[-1]\n    solution.append(s)\n\n\nfor _ in range(n - min(len(solution), n)):\n    solution.append(n)\n\nprint(' '.join([str(s) for s in solution]))\n"]
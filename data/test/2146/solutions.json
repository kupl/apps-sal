["n = int(input())\na = list([int(x) - 1 for x in input().split()])\n\ncnt = 0\ncurr = [0]\nv = [0 for _ in range(n)]\nr = [0 for _ in range(n)]\n\nlvl = 0\nwhile cnt < n:\n    nxt = []\n    for i in curr:\n        if v[i]:\n            continue\n        v[i] = 1\n        r[i] = lvl\n        cnt += 1\n        if i > 0 and not v[i-1]:\n            nxt.append(i - 1)\n        if i < n - 1 and not v[i+1]:\n            nxt.append(i + 1)\n        if not v[a[i]]:\n            nxt.append(a[i])\n    curr = nxt\n    lvl += 1\nprint(' '.join(map(str,r)))\n", "n = int(input())\na = [ int(i)-1 for i in input().split() ]\n\nm = [-1]*len(a)\n\n#print(m)\n\nscur = set()\nsnext = set()\n\nscur.add(0)\n\ndist = 0\nchanged = True\nwhile changed:\n\tchanged = False\n\tfor i in scur:\n\t\tif m[i] == -1 or m[i] > dist:\n\t\t\tm[i] = dist\n\t\t\tif i+1 < n:\n\t\t\t\tsnext.add(i+1)\n\t\t\tif i-1 >= 0:\n\t\t\t\tsnext.add(i-1)\n\t\t\tsnext.add(a[i])\n\t\t\tchanged = True\n\tscur = snext\n\tsnext = set()\n\tdist+=1\n\nfor i in m:\n\tprint(i,end=' ')\nprint()", "import sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    x = list(map(int, sys.stdin.readline().split()))\n    y = [0]*n\n    for i in range(n):\n        y[i] = x[i]-1\n\n    q = []\n    q.append(0)\n    i=0\n    res = [-1]*n\n    res[0]=0\n    while i<len(q):\n        c = q[i]\n        i+=1\n        if c>0 and res[c-1]==-1:\n            res[c-1] = res[c]+1\n            q.append(c-1)\n        if c<n-1 and res[c+1]==-1:\n            res[c+1] = res[c]+1\n            q.append(c+1)\n        if res[y[c]]==-1:\n            res[y[c]] = res[c]+1\n            q.append(y[c])\n\n    \n    print(' '.join(map(str,res)))\n    \n\nmain()\n", "n=int(input())\nshortcuts=input().split()\nfor i in range (n):\n    shortcuts[i]=int(shortcuts[i])-1\n\nmincosts=[]\nfor i in range (n):\n    mincosts.append(i)\n\nfor i in range (n-1):\n    a=shortcuts[i]\n    mincosts[a]=min(mincosts[a],mincosts[i]+1)\n    if (i+1<n and shortcuts[i]<shortcuts[i+1]):\n        b=a+1\n        while (b<=shortcuts[i+1] and mincosts[b-1]+1<mincosts[b]):\n            mincosts[b]=mincosts[b-1]+1\n            b+=1\n        b=a-1\n        while (b>i and mincosts[b+1]+1<mincosts[b]):\n            mincosts[b]=mincosts[b+1]+1\n            b-=1\n\nfor i in range (1,n):\n    mincosts[i]=min(mincosts[i],mincosts[i-1]+1)\n\nfor i in range (n-2,-1,-1):\n    mincosts[i]=min(mincosts[i],mincosts[i+1]+1)\n\nfor i in range (n):\n    mincosts[i]=str(mincosts[i])\nprint(\" \".join(mincosts))\n", "import queue\n\nn = int(input())\nvalues = [ (int(value) - 1) for value in input().split() ]\n\nstart = 0\n\npoints = queue.Queue()\npoints.put(start)\nd = [n*10] * n\nd[start] = 0\n\nwhile not points.empty():\n\tvalue = points.get()\n\tfor destanation in [value - 1, value + 1, values[value]]:\n\t\tdistance = d[value] + 1\n\t\tif destanation < 0 or destanation >= n:\n\t\t\tcontinue\n\t\telif d[destanation] > distance:\n\t\t\td[destanation] = distance\n\t\t\tpoints.put(destanation)\n\nfor value in d:\n\tprint(value, end = ' ')\n\nprint('')\n", "n = int(input())\ns = [0] + list(map(int, input().split()))\nans = [0,0] + [None]*(n-1)\n\ndef bfs():\n    path = [(s[1],1),(2,1)]\n    while path:\n        nom, pre = path.pop(0)\n        if ans[nom] != None:\n            continue\n        ans[nom] = pre\n        path.append((s[nom], pre+1))\n        if nom<n:\n            path.append((nom+1, pre+1))\n        if nom>2:\n            path.append((nom-1, pre+1))\n\nbfs()\n\nfor j in range(1,n+1):\n    print(ans[j], end=' ')\n", "from heapq import *\nn=int(input())\nans=[0]+[n for i in range(n)]\ne=[[i+1,i-1] if i<n else [i-1] for i in range(0,n+1)]\ne[0],ans[1]=[],0\nfor i,x in enumerate(map(int,input().split())):\n    if i+1!=x: e[i+1]+=[x]\nch=[(0,1)]\nwhile ch:\n    l,nom=heappop(ch)\n    for x in e[nom]:\n        if l+1<ans[x]: ans[x]=l+1; heappush(ch,(l+1,x))\nprint(*ans[1:])    ", "n=int(input())\nans=[0]+[n for i in range(n)]\ne=[[i+1,i-1] if i<n else [i-1] for i in range(0,n+1)]\ne[0],ans[1]=[],0\nfor i,x in enumerate(map(int,input().split())):\n    if i+1!=x: e[i+1]+=[x]\nch=[(0,1)]\nwhile ch:\n    l,nom=ch.pop()\n    for x in e[nom]:\n        if l+1<ans[x]: ans[x]=l+1; ch.append((l+1,x))\nprint(*ans[1:])    ", "n=int(input())\nans=[0]+[n for i in range(n)]\ne=[[i+1,i-1] if i<n else [i-1] for i in range(0,n+1)]\ne[0],ans[1]=[],0\nfor i,x in enumerate(map(int,input().split())):\n    if i+1!=x: e[i+1]+=[x]\nch=[(0,1)]\nwhile ch:\n    l,nom=ch.pop(0)\n    for x in e[nom]:\n        if l+1<ans[x]: ans[x]=l+1; ch.append((l+1,x))\nprint(*ans[1:])    ", "#689B\nn = int(input())\ns = input()\ng = {}\nsrc = 0\nfor i in s.split():\n\tg[src] = [int(i)-1]\n\tif src > 0 :\n\t\tg[src].append(src-1)\n\tif src < n-1:\n\t\tg[src].append(src+1)\n\tsrc+=1\n \nenergy = [-1]*n\nq=[]\nq.append(0)\nenergy[0] = 0\nwhile len(q) > 0 :\n\tx = q.pop(0)\n\tfor y in g[x]:\n\t\tif energy[y] == -1:\n\t\t\tenergy[y] = energy[x]+1\n\t\t\tq.append(y)\nfor i in energy:\n\tprint(i,end = ' ')\n\t", "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(input())\n    a = [val - 1 for val in list(map(int, input().split()))]\n    queue = deque([(0, 0)])\n    ans = [-1] * n\n    while len(queue) > 0:\n        cur = queue.popleft()\n        if cur[0] < 0 or cur[0] >= n or ans[cur[0]] != -1: continue\n        ans[cur[0]] = cur[1]\n        queue.append((cur[0] - 1, cur[1] + 1))\n        queue.append((cur[0] + 1, cur[1] + 1))\n        queue.append((a[cur[0]], cur[1] + 1))\n    print(\" \".join(map(str, ans)))\n\nif sys.hexversion == 50659824: sys.stdin = open(\"input.txt\")\nsolve()", "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(input())\n    a = [val - 1 for val in list(map(int, input().split()))]\n    queue = deque([(0, 0)])\n    ans = [-1] * n\n    while len(queue) > 0:\n        cur = queue.popleft()\n        if cur[0] < 0 or cur[0] >= n or ans[cur[0]] != -1: continue\n        ans[cur[0]] = cur[1]\n        queue.append((cur[0] - 1, cur[1] + 1))\n        queue.append((cur[0] + 1, cur[1] + 1))\n        queue.append((a[cur[0]], cur[1] + 1))\n    print(\" \".join(map(str, ans)))\n\nif sys.hexversion == 50659824: sys.stdin = open(\"input.txt\")\nsolve()", "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    a[i] -= 1\n    if a[i] <= i + 1:\n        a[i] = None\n\nm = [-1] * n\nm[0] = 0\nnow = [0]\nnext = []\nwhile True:\n    if not now:\n        break\n    for i in now:\n        x = m[i] + 1\n        if a[i] and m[a[i]] == -1:\n            m[a[i]] = x\n            next.append(a[i])\n        if i != 0 and m[i - 1] == -1:\n            m[i - 1] = x\n            next.append(i - 1)\n        if i != n - 1 and m[i + 1] == -1:\n            m[i + 1] = x\n            next.append(i + 1)\n    now = next\n    next = []\n\nprint(' '.join(map(str, m)))\n", "#coding gbk\n#!usr/bin/env\nn = int(input())\na = [0] + [n for i in range(n)]\ne = [[i + 1, i - 1] if i < n else [i - 1] for i in range(0, n + 1)]\ne[0] = []\na[1] = 0\nfor i, x in enumerate(map(int, input().split())):\n    if i + 1 != x: e[i + 1] += [x]\nq = [(0, 1)]\nwhile q:\n    l, cur = q.pop(0)\n    for x in e[cur]:\n        if l + 1 < a[x]:\n            a[x] = l + 1\n            q.append((l + 1, x))\nprint(*a[1:])    \n", "def main():\n    n = int(input())\n    short = [int(fld) - 1 for fld in input().strip().split()]\n    assert len(short) == n\n    ans = [None] * n\n    ans[0] = 0\n    justreached = reached = {0}\n    step = 0\n    while len(reached) < n:\n        step += 1\n        new = set()\n        for i in justreached:\n            for j in (i-1, i+1, short[i]):\n                if 0 <= j < n and j not in reached:\n                    new.add(j)\n                    ans[j] = step\n        justreached = new\n        reached |= new\n    print(' '.join(map(str, ans)))\n                \n    \n\nmain()", "\"\"\"\nCodeforces Round #361 (Div. 2)\n\nProblem 689 B. Mike and Shortcuts\n\n@author yamaton\n@date 2016-07-09\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\ndef solve(xs, n):\n    nodes = list(range(1, n+1))\n\n    neighbors = collections.defaultdict(set)\n    for from_, to_ in zip(nodes, nodes[1:]):\n        neighbors[from_].add(to_)\n        neighbors[to_].add(from_)\n    for from_, to_ in enumerate(xs, 1):\n        neighbors[from_].add(to_)\n\n    distance = {1: 0}\n    q = collections.deque([1])\n    while q:\n        node = q.popleft()\n        for x in neighbors[node]:\n            if x not in distance:\n                distance[x] = distance[node] + 1\n                q.append(x)\n    return [distance[i] for i in nodes]\n\n\ndef pp(*args, **kwargs):\n    return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n = int(input())\n    xs = [int(s) for s in input().strip().split()]\n    assert len(xs) == n\n    result = solve(xs, n)\n    print(*result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\n\ng = []\n\nfor i in range(n):\n    To = set()\n    if i < n - 1:\n        To.add(i+1)\n    if i > 0:\n        To.add(i-1)\n    if a[i] - 1 != i:\n        To.add(a[i]-1)\n    g.append(To)\n\nq = [0]\nused = [i == 0 for i in range(n)]\nd = [0 for i in range(n)]\np = [0 for i in range(n)]\np[0] = -1\n\nwhile len(q) > 0:\n    v = q[0]\n    q.pop(0)\n\n    for to in g[v]:\n        if not used[to]:\n            used[to] = True\n            q.append(to)\n            d[to] = d[v] + 1\n            p[to] = v\n\nfor r in d:\n    print(r, end=' ')\n", "n = int(input())\ndp = [0] + [n] * n + [0]\na = tuple(map(int, input().split()))\ns = [1]\ndp[1] = 0\nwhile s:\n    ns = []\n    for v in s:\n        if dp[v - 1] == n:\n            ns.append(v - 1)\n        dp[v - 1] = min(dp[v - 1], dp[v] + 1)\n        if dp[v + 1] == n:\n            ns.append(v + 1)\n        dp[v + 1] = min(dp[v + 1], dp[v] + 1)\n        if dp[a[v - 1]] == n:\n            ns.append(a[v - 1])\n        dp[a[v - 1]] = min(dp[a[v - 1]], dp[v] + 1)\n    s = ns\nprint(' '.join(map(str, dp[1:-1])))\n", "n = int(input())\ndp = [0, 0] + [n] * (n - 1) + [0]\na = tuple(map(int, input().split()))\nq = [1]\nwhile q:\n    v = q.pop(0)\n    if dp[v - 1] == n:\n        q.append(v - 1)\n    dp[v - 1] = min(dp[v - 1], dp[v] + 1)\n    if dp[v + 1] == n:\n        q.append(v + 1)\n    dp[v + 1] = min(dp[v + 1], dp[v] + 1)\n    if dp[a[v - 1]] == n:\n        q.append(a[v - 1])\n    dp[a[v - 1]] = min(dp[a[v - 1]], dp[v] + 1)\nprint(' '.join(map(str, dp[1:-1])))\n", "n = int(input())\ndp = [0, 0] + [n] * (n - 1) + [0]\na = tuple(map(int, input().split()))\ni, q = 0, [1]\nwhile i < n:\n    v = q[i]\n    i += 1\n    if dp[v - 1] == n:\n        q.append(v - 1)\n    dp[v - 1] = min(dp[v - 1], dp[v] + 1)\n    if dp[v + 1] == n:\n        q.append(v + 1)\n    dp[v + 1] = min(dp[v + 1], dp[v] + 1)\n    if dp[a[v - 1]] == n:\n        q.append(a[v - 1])\n    dp[a[v - 1]] = min(dp[a[v - 1]], dp[v] + 1)\nprint(' '.join(map(str, dp[1:-1])))\n", "n = int(input())\ndp = [0, 0] + [n] * (n - 1) + [0]\na = tuple(map(int, input().split()))\ni, q = 0, [1]\nwhile i < n:\n    v = q[i]\n    i += 1\n    if dp[v - 1] == n:\n        q.append(v - 1)\n    dp[v - 1] = min(dp[v - 1], dp[v] + 1)\n    if dp[v + 1] == n:\n        q.append(v + 1)\n    dp[v + 1] = min(dp[v + 1], dp[v] + 1)\n    if dp[a[v - 1]] == n:\n        q.append(a[v - 1])\n    dp[a[v - 1]] = min(dp[a[v - 1]], dp[v] + 1)\nprint(*dp[1:-1])\n", "def main():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    l, nxt = [n] * (n + 1), [0]\n    l[0] = l[n] = 0\n    for t in range(1, n):\n        cur, nxt = nxt, []\n        for v in cur:\n            for u in v - 1, v + 1, aa[v] - 1:\n                if l[u] > t:\n                    l[u] = t\n                    nxt.append(u)\n        if not nxt:\n            break\n    del l[n]\n    print(' '.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nl=list(map(int, input().split(' ')))\n\nout=[-1]*n\n\npas = 0\npos = [0]\nout[0]=0\n\nwhile pos :\n    pas+=1\n    new_pos=[]\n    for p in pos :\n        for q in [p-1,p+1,l[p]-1] :\n            if q>=0 and q<n and out[q]==-1:\n                out[q]=pas\n                new_pos.append(q)\n    pos = new_pos\n    \nprint(*out)"]
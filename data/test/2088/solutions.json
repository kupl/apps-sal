["\n# encoding:UTF-8\n# Filename:Base.py\n\nimport sys\nimport random\nimport copy\nfrom itertools import permutations, combinations\nfrom math import sqrt, fabs, ceil\nfrom collections import namedtuple\n\n# ------Util Const--------\n\nin_file_path = \"input.txt\"\noutput_file_path = \"output.txt\"\n\nSUBMIT = True\n\n\ndef get_array(x, initial=None):\n    dimension = len(x)\n    if dimension == 1:\n        return [copy.deepcopy(initial) for _ in range(x[0])]\n    else:\n        return [get_array(x[1:], initial) for _ in range(x[0])]\n\n\ndef read_num(fin, num_type=int):\n    tmp_list = [num_type(x) for x in fin.readline().strip().split()]\n    if len(tmp_list) == 1:\n        return tmp_list[0]\n    else:\n        return tuple(tmp_list)\n\ndef read_num_list(fin, num_type=int):\n    return [num_type(x) for x in fin.readline().strip().split()]\n\n\n# def solve(fin):\n#     n = read_num(fin)\n#     ans_set = None\n#     for i in range(n):\n#         tmp_list = read_num_list(fin)\n#         if ans_set == None:\n#             ans_set = set(tmp_list[1:])\n#         else:\n#             ans_set &= set(tmp_list[1:])\n#\n#     print(' '.join([str(x) for x in ans_set]))\n\n# def solve(fin):\n#     n, m = read_num(fin)\n#     a = [0] * m\n#     b = [0] * int(sqrt(n))\n#     for i in range(1, n + 1):\n#         a[i * i % m] += 1\n#\n#     ans = 0\n#     for x in range(m):\n#         y = (m - x) % m\n#         ans += a[x] * a[y]\n#     print(ans)\n\n# def BFS_count(x, chs, count):\n#     q = []\n#     q.append(x)\n#     while (q)\n#     return count[x]\n\ndef solve(fin):\n    n = read_num(fin)\n    f = read_num_list(fin)\n    new_f = [0] + f\n    for i in range(0, n):\n        new_f[i] -= 1\n    f = new_f\n    # print(f)\n    chs = get_array([n], [])\n    for i, p in enumerate(f):\n        if p >= 0:\n            chs[p].append(i)\n    # print(chs)\n    q = [x for x in range(0, n) if not chs[x]]\n    vis = [0] * n\n    count = [0] * n\n    while q:\n        x = q.pop(0)\n        if not chs[x]:\n            count[x] = 1\n        if f[x] >= 0:\n            vis[f[x]] += 1\n            # print(vis[f[x]], len(chs[f[x]]))\n            if vis[f[x]] == len(chs[f[x]]):\n                q.append(f[x])\n            count[f[x]] += count[x]\n\n\n    # print(chs)\n    count = sorted(count)\n    print(' '.join([str(x) for x in count]))\n\ndef __starting_point():\n    if SUBMIT:\n        solve(sys.stdin)\n    else:\n        solve(open(in_file_path, 'r'))\n\n__starting_point()", "s=input().split()\nn=int(s[0])\narr=list(map(int,input().split()))\n\nchildren=[[] for i in range(n+1)]\nfor i,j in enumerate(arr):\n    if 1<i+2<=n:\n        children[j].append(i+2)\nleaves=[0]*(n+1)\n\nfor i in range(n,0,-1):\n    if not children[i]:\n        leaves[i]=1\n    else:\n        leaves[i]=sum(leaves[j] for j in children[i])\n    \n    \nprint(' '.join(map(str,sorted(leaves[1:]))))", "n = int(input())\nif n == 1:\n    print(1)\nelse:\n    adj = [[] for i in range(n+10)]\n    s = input().split()\n    for i in range(2,n+1):\n        pi = int(s[i-2])\n        adj[i].append(pi)\n        adj[pi].append(i)\n        \n    num = 1\n    curr = [1]\n    nextcurr = []\n    disco = [1]\n    visited = {1:True}\n    while num < n:\n        for v in curr:\n            for w in adj[v]:\n                if w not in visited:\n                    nextcurr.append(w)\n                    visited[w] = True\n                    disco.append(w)\n                    num += 1\n        curr = nextcurr\n        nextcurr = []\n\n    nl = {}\n    nlvals = {}\n    for v in disco[::-1]:\n        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)\n        nlvals[nl[v]] = nlvals.get(nl[v],0)+1\n    colors = {}\n    leaves = nlvals[1]\n    colors[1] = leaves\n    for c in range(2, leaves+1):\n        colors[c] = colors[c-1] + nlvals.get(c,0)\n\n    ans = \"\"\n    j = 1\n    for i in range(1, n+1):\n        while colors[j] < i:\n            j += 1\n        ans += str(j) + ' '\n    print(ans.strip())\n", "n = int(input())\np = [0,0] + [int(w) for w in input().split()]\n\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\n\nif n == 1:\n    d[1] = 1\n\nd = d[1:]\nd.sort()\n\nprint(*d)\n", "from operator import itemgetter\n#int(input())\n#map(int,input().split())\n#[list(map(int,input().split())) for i in range(q)]\n#print(\"YES\" * ans + \"NO\" * (1-ans))\nn = int(input())\nif n == 1:\n    print(1)\nelse:\n    pi = list(map(int,input().split()))\n    ai = [1] * (n+1)\n    ai[0] = 10**9\n    for i in pi:\n        ai[i] = 0\n    for i in range(n-2,-1,-1):\n        ai[pi[i]] += ai[i+2]\n    ai.sort()\n    for i in range(n):\n        print(ai[i],end=\" \")\n", "n = int(input())\ntr = {}\np = [int(s) for s in input().split()]\nfor i in range(n-1):\n    if not tr.get(p[i]-1):\n        tr[p[i]-1] = []\n    tr[p[i]-1].append(i+1)\n# print(tr)\nlc = [-1 for i in range(n)]\ndef get_lc(i):\n    if lc[i] == -1:\n        if tr.get(i):\n            lc[i] = 0\n            for j in tr[i]:\n                lc[i] += get_lc(j)\n        else:\n            lc[i] = 1\n    return lc[i]\nfor i in range(n-1, -1, -1):\n    get_lc(i)\nprint(*sorted(lc))", "import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\n\nn=int(input())\nP=list(map(int,input().split()))\n\nLIST=[0]*(n+1)\n\nLEAF=[1]*(n+1)\nfor p in P:\n    LEAF[p]=0\n\n\nfor i in range(1,n+1):\n    if LEAF[i]==1:\n        LIST[i]=1\n\nfor i in range(n,1,-1):\n    LIST[P[i-2]]+=LIST[i]\n\ncounter=Counter(LIST[1:])\n\nSUM=[0]\nSC=sorted(counter.keys())\n\nfor j in SC:\n    SUM.append(SUM[-1]+counter[j])\n\ni=1\nj=0\nwhile j<len(SUM):\n    if i<=SUM[j]:\n        print(SC[j-1],end=\" \")\n    else:\n        j+=1\n        continue\n    \n    i+=1\n", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nfrom itertools import combinations\nimport sys\nimport math\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(map(int,sys.stdin.readline().strip().split()))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\ndef bfs(g,d):\n\tnonlocal n\n\n\tfor i in range(n,0,-1):\n\t\twhile g[i]:\n\t\t\tx = g[i].pop()\n\t\t\td[i]+=d[x]\n\treturn d\n\n\n\nn = int(input())\nl = list(numIN())\nif n==1:\n\tprint(1)\n\treturn\nif n==2:\n\tprint(1,1)\n\treturn\nd = [0]*(n+1)\nl = [0,0]+l\ng = defaultdict(list)\nfor i in range(2,n+1):\n\tg[l[i]].append(i)\n\td[i]+=1\n\td[l[i]]+=1\nfor i in range(1,n+1):\n\tif g[i]:\n\t\td[i] = 0\nx = bfs(g,d)\nx.sort()\nfor i in range(1,n+1):\n\tprint(x[i],end= ' ')\n\n\n\n", "n = int(input())\np = [0,0] + [int(w) for w in input().split()]\nd = [0] * (n+1)\n\nfor i in range(n, 1, -1):\n    if d[i] == 0:\n        d[i] = 1\n    d[p[i]] += d[i]\nif n == 1:\n    d[1] = 1\nd = d[1:]\nd.sort()\nprint(*d)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(500000)\ntest = 0\n\n\ndef countleaf(tree, n, leafs):\n    leafs[n] = 1 if len(tree[n]) == 0 else 0\n\n    for i in tree[n]:\n        leafs[n] += countleaf(tree, i, leafs)\n    \n    return leafs[n]\n    \nn = int(input())\nedges = list(map(int, input().split()))\ntree = [[] for i in range(n)]\n\nleafs = [0] * n\n\nfor i, e in enumerate(edges):\n    tree[e - 1] += [i + 1]\n\nif test: print(tree)\n\nfor i in range(n - 1, -1, -1):\n    if not tree[i]:\n        leafs[i] = 1\n    else:\n        leafs[i] = sum(leafs[j] for j in tree[i])\n\nprint(*sorted(leafs))\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 12/14/18\n\n\"\"\"\nimport collections\n\nimport sys\n\nN = int(input())\np = [int(x) for x in input().split()]\n\n\nG = collections.defaultdict(list)\n\nfor i, v in enumerate(p):\n    u = i + 2\n    G[u].append(v)\n    G[v].append(u)\n\nroot = 1\n\ncolors = [0] * (N + 1)\ncounts = [0] * (N + 1)\n\nq = [root]\nparents = [0] * (N+1)\nvis = [0] * (N+1)\nwhile q:\n    u = q.pop()\n    if vis[u]:\n        colors[parents[u]] += colors[u]\n        continue\n    children = [v for v in G[u] if v != parents[u]]\n    for v in children:\n        parents[v] = u\n    \n    if children:\n        vis[u] = True\n        q.append(u)\n        q.extend(children)\n    else:\n        vis[u] = True\n        colors[u] = 1\n        colors[parents[u]] += 1\n        \n    \n\n\n\n\n\n#\n#\n# def dfs(u, parent):\n#     cc, hc = 0, 0\n#     for v in G[u]:\n#         if v != parent:\n#             a, b = dfs(v, u)\n#             cc += a\n#             hc += b\n#     counts[u] = hc + 1\n#     cc = cc if cc > 0 else 1\n#     colors[u] = cc\n#     return cc, hc + 1\n#\n#\n# dfs(1, -1)\n#\ncolors = colors[1:]\ncolors.sort()\nprint(' '.join(map(str, colors)))\n", "n=int(input())\nfa=[0,0]+list(map(int,input().split()))\ndelta=[0]*(n+1)\nsuml=[0]*(n+1)\nfor i in range(n,0,-1):\n\tif suml[i]==0:\n\t\tsuml[i]=1\n\tdelta[suml[i]]+=1\n\tsuml[fa[i]]+=suml[i]\n\nfor i in range(1,n+1):\n\tdelta[i]+=delta[i-1]\nans=0\nfor i in range(1,n+1):\n\twhile delta[ans]<i:\n\t\tans+=1\n\tprint(\"%d \"%ans,end=\"\")\nprint(\"\\n\")", "n=int(input())\nif n==1:\n    print(1)\nelse:\n    p=list(map(int,input().split()))\n    children=[]\n    for i in range(n):\n        children.append([])\n    for i in range(n-1):\n        children[p[i]-1].append(i+1)\n    layers=[1]+[0]*(n-1)\n    layer=[0]\n    num=2\n    bylayer=[]\n    while len(layer)>0:\n        bylayer.append(layer)\n        newlayer=[]\n        for vert in layer:\n            for child in children[vert]:\n                layers[child]=num\n                newlayer.append(child)\n        layer=newlayer\n        num+=1\n    bylayer=bylayer[::-1]\n    count=[0]*n\n    for layer in bylayer:\n        for vert in layer:\n            if children[vert]==[]:\n                count[vert]=1\n            else:\n                count[vert]=sum(count[v] for v in children[vert])\n    count.sort()\n    out=\"\"\n    for guy in count:\n        out+=str(guy)+\" \"\n    print(out)", "n=int(input())\na=[0,0]+[int(x) for x in input().split()]\nans=[0]*(n+1)\nfor i in range(n,1,-1):\n    if ans[i]==0:\n        ans[i]=1\n    ans[a[i]]+=ans[i]\nif n==1:\n    ans[1]=1\nans=ans[1:]\nans.sort()\nprint(*ans)", "n = int(input())\np = list(map(int, input().split()))\ngr = [[] for i in range(n)]\nfor i in range(n - 1):\n    gr[p[i] - 1].append(i + 1)\n\nq = [0]\nafter = []\ni = 0\ns = [0 for i in range(n)]\nused = set()\nused.add(0)\nwhile q:\n    cur = q.pop()\n    after.append(cur)\n    for el in gr[cur]:\n        if el not in used:\n            used.add(el)\n            q.append(el)\n            i += 1\n\nq = after\nfor j in range(i, -1, -1):\n    if len(gr[q[j]]) == 0:\n        s[q[j]] = 1\n    else:\n        ans = 0\n        for c in gr[q[j]]:\n            ans += s[c]\n        s[q[j]] = ans\ns.sort()\nprint(' '.join(list(map(str, s))))\n", "import collections\n\n\nn = int(input())\na = [0, 0] + list(map(int, input().split()))\n\n# contruct tree\nG = collections.defaultdict(list)\nfor i in range(2, len(a)):\n    G[a[i]].append(i)\n\n# dp[i] represents the number of color needed to make node i be happy\n# recursion will get stackover flow, use bottom to top\nnodes = []\nq = collections.deque([1])\nwhile q:\n    node = q.popleft()\n    nodes.append(node)\n    for v in G[node]:\n        q.append(v)\n\nnodes.reverse()\n\ndp = {}\nfor u in nodes:\n    count = 0\n    if len(G[u]) == 0: count += 1\n    for v in G[u]:\n        count += dp[v]\n    dp[u] = count\n\n\nres = sorted(dp.values())\nprint(' '.join(map(str, res)))\n", "n=int(input())\np=[0,0]+list(map(int,input().split()))\nd=[0]*(n+1)\nfor i in range(n,1,-1):\n    if d[i]==0:\n        d[i]=1\n    d[p[i]]+=d[i]\nif n==1:\n    d[1]=1\nd=d[1:]\nd.sort()\nprint(*d)", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(1000000)\nmod=int(1e9+7)\n\ndef bfs(x):\n    cnt=0\n    for i in tree[x]:\n        bfs(i)\n        cnt+=a[i]\n    if len(tree[x])==0:\n        cnt=1\n    a[x]=cnt\n\nn=int(data())\ntree=[{} for i in range(n)]\nif n>1:\n    P=list(mdata())\n    for i in range(n-1):\n        tree[P[i]-1][i+1]=0\n    a=[0]*n\n    for i in range(n-1,-1,-1):\n        if len(tree[i])==0:\n            a[i]=1\n        else:\n            for j in tree[i]:\n                a[i]+=a[j]\n    a.sort()\nelse:\n    a=[1]\nprint(*a)", "class DFS:\n    def __init__(self):\n        self.G= []\n        self.leave_tree= []\n\n    def take_input(self):\n        k = int(input())\n        if(k>1):\n            graph =[int(node)-1 for (node) in input().split(' ')]\n            self.G = [[] for _ in range(len(graph)+1)]   \n            for i in range(len(graph)):\n                self.G[graph[i]].append(i+1)\n            self.visited = [0]*k\n            self.leave_tree = [0]*k\n            for i in range(k-1,-1,-1):\n                if len(self.G[i])==0:\n                    self.leave_tree[i]=1\n                else:\n                    for j in self.G[i]:\n                        self.leave_tree[i]+=self.leave_tree[j]\n            self.leave_tree.sort()\n            print(*self.leave_tree)\n        else:\n            print(k)\n\n\n\n\n\nx = DFS()\nx.take_input()\n", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ngraph=defaultdict(list)\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nbulb=[1]*(n+1)\nfor i in range(n-1):\n    bulb[par[i]]=0\n    graph[par[i]].append(i+2)\n#print(graph,bulb)\nzero=bulb.count(0)\nfor  i in range(n,0,-1):\n    if bulb[i]==0:\n        count=0\n        for j in graph[i]:\n            count+=bulb[j]\n        bulb[i]=count\nbulb=bulb[1:]\nbulb.sort()\nsys.stdout.write(' '.join(map(str,bulb)))\n", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ngraph=defaultdict(list)\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nbulb=[1]*(n+1)\nfor i in range(n-1):\n    bulb[par[i]]=0\n    graph[par[i]].append(i+2)\n#print(graph,bulb,par)\nzero=bulb.count(0)\nfor  i in range(n,0,-1):\n    if bulb[i]==0:\n        count=0\n        for j in graph[i]:\n            count+=bulb[j]\n        bulb[i]=count\nbulb=bulb[1:]\nbulb.sort()\nsys.stdout.write(' '.join(map(str,bulb)))\n", "from collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tself.parent = [-1 for i in range(self.n)]\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tflag=0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tflag=1\n\t\t\t\t\tm += ans[i]\n\t\t\tif not flag:\t\n\t\t\t\tans[element] = 1\n\t\t\telse:\n\t\t\t\tans[element] = m\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tself.bfs(0)\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in graph[element]:\n\t\t\t\tif vis[i]==1 and i!=parent[element]:\n\t\t\t\t\treturn True\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvis[i] = 1\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\n\nn = int(input())\ng = Graph(n,False)\np = list(map(int,input().split()))\nfor i in range(n-1):\n\tg.addEdge(i+1,p[i]-1)\ndepth = [-1]*n\ng.dfs(0,depth)\ndepth.sort()\nprint(*depth)\n", "from sys import stdin\nfrom collections import Counter\n\nclass Node:\n    def __init__(self,val):\n        self.val=val\n        self.forw=set()\n        self.cou=0\n\n    def __str__(self):\n        return f'{self.val} {self.forw} {self.cou}'\n\nn=int(stdin.readline())\narr=[Node(i) for i in range(1,n+1)]\nc=2\nfor x in map(int,stdin.readline().split()):\n    arr[x-1].forw.add(c)\n    c+=1\n\n\ndct=Counter()\nlst = [1]\nwhile len(lst):\n    fl = 0\n    for i in arr[lst[-1]-1].forw:\n        lst.append(i)\n        fl = 1\n        break\n    if fl:\n        arr[lst[-2]-1].forw.remove(i)\n    if not fl:\n        if arr[lst[-1]-1].cou ==0:\n            arr[lst[-1]-1].cou=1\n        dct[arr[lst[-1]-1].cou]+=1\n        k=arr[lst.pop()-1].cou\n        if len(lst):arr[lst[-1]-1].cou+=k\n\ny=1\nfor _ in range(n):\n    while not dct[y]:\n        y+=1\n    dct[y]-=1\n    print(y,end=' ')", "import sys\nimport threading\n\ndef dfs(g, i, p):\n    nonlocal ans\n    count = 0\n    for j in g[i]:\n        if j == p:\n            continue\n        count += dfs(g, j, i)\n    if count == 0:\n        count = 1\n    ans.append(count)\n    return count\n\ndef solve():\n    \n    n = int(input())\n    l = list(map(int, input().split()))\n    g = [[] for i in range(n+1)]\n\n    for i in range(1, n):\n        g[i+1].append(l[i-1])\n        g[l[i-1]].append(i+1)\n\n    dfs(g, 1, 0)\n    ans.sort()\n    st = ' '.join(map(str, ans))\n    print(st)\n\nans = []\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\n \nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()"]
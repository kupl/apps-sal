["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\npossible=[0]*26\n\nfor i in input().strip():\n    possible[ord(i)-97]+=1\n\n# make changes\ntemp=[]\nfor i in range(26):\n    if possible[i]%2: temp.append(i)\nwhile len(temp)>1:\n    possible[temp[0]]+=1\n    possible[temp[-1]]-=1\n    temp.pop(0)\n    temp.pop(-1)\n\n# print stuff\nfor i in range(26):\n    print(chr(97+i)*(possible[i]//2),end=\"\")\nif temp: print(chr(97+temp[0]),end=\"\")\nfor i in range(26)[::-1]:\n    print(chr(97+i)*(possible[i]//2),end=\"\")", "#!/usr/bin/env python3\n\nfrom collections import Counter, OrderedDict\n\ntry:\n    while True:\n        s = input()\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - 97] += 1\n        odds = [ ]\n        for i, x in enumerate(count):\n            if x & 0x1:\n                odds.append(i)\n        j = 0\n        for i, x in zip(range(25, -1, -1), reversed(count)):\n            if x & 0x1:\n                if i == odds[j]:\n                    break\n                count[odds[j]] += 1\n                count[i] -= 1\n                j += 1\n        a = [ ]\n        b = [ ]\n        c = \"\"\n        for i, x in enumerate(count):\n            if x & 0x1:\n                assert not c\n                c = chr(i + 97)\n            if x > 1:\n                t = chr(i + 97) * (x >> 1)\n                a.append(t)\n                b.append(t)\n        print(\"\".join(a), \"\".join(reversed(b)), sep=c)\n\nexcept EOFError:\n    pass\n", "key = ''\n\nok = []\nodd = []\nx = list(input())\nd = {}\n\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n    d[i] = 0\n\nfor i in x:\n    d[i] += 1\n\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n    if d[i]%2==1:\n        odd.append(i)\nodd.sort()\nm = len(odd)//2\nfor i in range(len(odd[m:])):\n    d[odd[i]] += 1\n    d[odd[m:][i]] -= 1\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n    if d[i] % 2 == 1:\n        key = i\n\ns = ''\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n    s += (i * (d[i]//2))\n\nprint(s+key+s[::-1])\n", "from collections import deque\n\ndef constructString( counts ):\n\n    s = \"\"\n    midLetter = \"\"\n    for i , count in enumerate( counts ):\n        if count > 0:\n            letter = chr( ord('a') + i )\n            if count % 2 == 1:\n                midLetter = letter\n            s += letter * ( count//2 )\n\n    rs = s[::-1]\n\n    return s + midLetter + rs\n\ndef __starting_point():\n\n    counts = [0]*26\n\n    s = input().strip()\n    n = len(s)\n    for c in s:\n        counts[ord(c)-ord('a')] += 1\n\n    maxOddNum = n%2\n    curOddNum = 0\n    needChangeLetters = deque()\n    for i , count in enumerate(counts):\n        if count%2 == 1:\n            needChangeLetters.append( i )\n\n    #print( needChangeLetters )\n    while len(needChangeLetters) >= 2:\n        preIndex = needChangeLetters.popleft()\n        postIndex = needChangeLetters.pop()\n        counts[preIndex] += 1\n        counts[postIndex] -= 1\n\n    print( constructString( counts ) )\n\n__starting_point()", "s=input();\nalph=[0 for x in range (0,26)];\nfor i in s:\n\talph[ord(i)-ord('a')]=alph[ord(i)-ord('a')]+1;\nfor i in range (25,-1,-1):\n\tif (alph[i]%2!=0):\n\t\tfor j in range (0,26):\n\t\t\tif (alph[j]%2!=0):\n\t\t\t\talph[i]=alph[i]-1;\n\t\t\t\talph[j]=alph[j]+1;\n\t\t\t\tbreak;\nr=\"\";\nfor i in range (0,26):\n\twhile(alph[i]>1):\n\t\tr=r+chr(ord('a')+i);\n\t\talph[i]=alph[i]-2;\ns=r;\nfor i in range (0,26):\n\tif (alph[i]!=0):\n\t\tr=r+chr(ord('a')+i);\n\t\t\nprint((r+s[::-1]));\n", "x = \"abcdefghijklmnopqrstuvwxyz\"\nd = dict.fromkeys(x, 0)\ns = input()\nfor i in s:\n    d[i] += 1\ncount = 0\nfor i in x:\n    if d[i] % 2:\n        count += 1\nif len(s) % 2:\n    count -= 1\ni = len(x) - 1\nwhile count > 0:\n    if d[x[i]] % 2:\n        j = 0\n        while not (d[x[j]] % 2):\n            j += 1\n        d[x[j]] += 1\n        d[x[i]] -= 1\n        count -= 2\n    i -= 1\ns = \"\"\nflag = \"\"\nfor i in x:\n    if d[i] % 2:\n        flag = i\n    s += i * (d[i] // 2)\nprint(s, flag, s[-1::-1], sep = \"\")\n    \n", "def palindrome(s):\n\tchars = [0]*26\n\tL = len(s)\n\tisOdd = (L%2 != 0)\n\t# populate chars\n\tfor c in s:\n\t\tn = ord(c) - 97\n\t\tchars[n] += 1\n\t# permutations\n\t\n\tleft = 0\n\tright = 25\n\twhile left < right:\n\t\twhile left < 25 and chars[left]%2 == 0:\n\t\t\tleft += 1\n\t\twhile right > 0 and chars[right]%2 == 0:\n\t\t\tright -= 1\n\t\tif left < 25 and right > 0:\n\t\t\tif left == right and isOdd:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tchars[left] += 1\n\t\t\t\tchars[right] -= 1\n\n\t# build result\n\tresult = [' ']*L\n\tindex = 0\n\toddC = \"\"\n\tfor j in range(26):\n\t\tn = chars[j]\n\t\tif n > 0:\n\t\t\tif n%2 != 0:\n\t\t\t\toddC = chr(j+97)\n\t\t\tfor k in range(n//2):\n\t\t\t\tresult[index] = chr(j+97)\n\t\t\t\tresult[L - 1 - index] = chr(j+97)\n\t\t\t\tindex += 1\n\n\tif isOdd:\n\t\tresult[L//2] = oddC\n\n\treturn ''.join(result)\n\n\ndef __starting_point():\n\ts = input()\n\tresult = palindrome(s)\n\tprint(result)\n__starting_point()", "#!/usr/bin/env python3\n# 600C_palindrom.py - Codeforces.com/problemset/problem/600/C by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Palindrom Class (Main Program)\n###############################################################################\n\n\nclass Palindrom:\n    \"\"\" Palindrom representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        self.s = uinput()\n\n        self.cnt = [0] * 26\n        for c in self.s:\n            self.cnt[ord(c) - ord('a')] += 1\n\n        self.hlen = len(self.s) // 2\n        self.odd = len(self.s) % 2\n\n        self.pcnt = list(self.cnt)\n        for i in range(len(self.pcnt) - 1, -1, -1):\n            if self.pcnt[i] % 2:\n                self.pcnt[i] -= 1\n                found = 0\n                for j in range(len(self.pcnt)):\n                    if self.pcnt[j] % 2:\n                        self.pcnt[j] += 1\n                        found = 1\n                        break\n                if not found:\n                    self.pcnt[i] += 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        mid = \"\"\n\n        for (i, n) in enumerate(self.pcnt):\n            if n > 0:\n                c = chr(ord('a') + i)\n                for i in range(n // 2):\n                    result.append(c)\n                if n % 2:\n                    mid = c\n        if self.odd:\n            result += mid\n            result += reversed(result[:-1])\n        else:\n            result += reversed(result)\n\n        return \"\".join(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Palindrom class testing \"\"\"\n\n        # Constructor test\n        test = \"aabc\"\n        d = Palindrom(test)\n        self.assertEqual(d.cnt[:3], [2, 1, 1])\n        self.assertEqual(d.pcnt[:3], [2, 2, 0])\n\n        # Sample test\n        self.assertEqual(Palindrom(test).calculate(), \"abba\")\n\n        # Sample test\n        test = \"aabcd\"\n        self.assertEqual(Palindrom(test).calculate(), \"abcba\")\n\n        # Sample test\n        test = \"aabbcccdd\"\n        self.assertEqual(Palindrom(test).calculate(), \"abcdcdcba\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Palindrom(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Palindrom(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Palindrom().calculate())\n\n__starting_point()", "#!/usr/bin/env python3\n# 600C_palindrom.py - Codeforces.com/problemset/problem/600/C by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Palindrom Class (Main Program)\n###############################################################################\n\n\nclass Palindrom:\n    \"\"\" Palindrom representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        self.s = uinput()\n\n        self.cnt = {}\n        for c in self.s:\n            self.cnt[c] = self.cnt.get(c, 0) + 1\n\n        self.odd = len(self.s) % 2\n\n        self.pcnt = dict(self.cnt)\n        for i in reversed(sorted(self.pcnt)):\n            if self.pcnt[i] % 2:\n                self.pcnt[i] -= 1\n                found = 0\n                for j in sorted(self.pcnt):\n                    if self.pcnt[j] % 2:\n                        self.pcnt[j] += 1\n                        found = 1\n                        break\n                if not found:\n                    self.pcnt[i] += 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        mid = []\n\n        for c in sorted(self.pcnt):\n            n = self.pcnt[c]\n            if n > 0:\n                for j in range(n // 2):\n                    result.append(c)\n                if n % 2:\n                    mid.append(c)\n\n        return \"\".join(result + mid + list(reversed(result)))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Palindrom class testing \"\"\"\n\n        # Constructor test\n        test = \"aabc\"\n        d = Palindrom(test)\n        self.assertEqual(d.cnt[\"c\"], 1)\n        self.assertEqual(d.pcnt[\"c\"], 0)\n\n        # Sample test\n        self.assertEqual(Palindrom(test).calculate(), \"abba\")\n\n        # Sample test\n        test = \"aabcd\"\n        self.assertEqual(Palindrom(test).calculate(), \"abcba\")\n\n        # Sample test\n        test = \"aabbcccdd\"\n        self.assertEqual(Palindrom(test).calculate(), \"abcdcdcba\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Palindrom(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Palindrom(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Palindrom().calculate())\n\n__starting_point()", "s = input()\na = [0] * 26\nfor c in s:\n    a[ord(c)-ord('a')] += 1\nx = 0\ny = 25\nwhile x < y:\n    while x < y and a[x] % 2 == 0:\n        x += 1\n    while x < y and a[y] % 2 == 0:\n        y -= 1\n    if x < y:\n        a[x] += 1\n        a[y] -= 1\n        x += 1\n        y -= 1\nr = ''\nmiddle = ''\nfor i in range(26):\n    c = str(chr(i + ord('a')))\n    r += c * (a[i] // 2)\n    if a[i] % 2 == 1:\n        middle = c\nprint(r + middle + r[::-1])\n\n        \n", "s=input()\na=[int(i) for i in '0'*26]\nk=-1\nfor i in s:\n    a[ord(i)-97]+=1\nfor i in range(25):\n    if a[i]%2!=0:\n        for j in range(25-i):\n            if a[25-j]%2!=0:\n                a[i]+=1\n                a[25-j]-=1\n                break\n    if a[i]%2!=0:\n        k=i\n        break\nst=''\nfor i in range(26):\n    if a[i]>0:\n        st+=chr(i+97)*(a[i]//2)\nif k!=-1:\n    st=st+chr(k+97)+st[::-1]\nelse:\n    st=st+st[::-1]\nprint(st)", "\"\"\"\nCodeforces Educational Round 2\n\nProblem 600 C. Make Palindrome\n\n@author yamaton\n@date 2015-11-30\n\"\"\"\n\nimport collections\n\n\ndef solve(s):\n    n = len(s)\n    chars = collections.Counter(s)\n    base = sorted(c for c in chars if chars[c] >= 2 for _ in range(chars[c] // 2))\n    chars_odd = sorted(c for c in chars if chars[c] % 2 == 1)\n\n    if n % 2 == 0:\n        keep = len(chars_odd) // 2\n        chars_selected = sorted(base + chars_odd[:keep])\n        return chars_selected + chars_selected[::-1]\n    else:\n        keep = len(chars_odd) // 2\n        chars_selected = sorted(base + chars_odd[:keep])\n        middle = chars_odd[keep]\n        return chars_selected + [middle] + chars_selected[::-1]\n\n\ndef main():\n    s = input().strip()\n    result = solve(s)\n    print(''.join(result))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from queue import Queue\nimport sys\n\ndef __starting_point():\n\n    s = input()\n    h = set()\n    res = []\n    for x in s:\n        if x in h:\n            h -= {x}\n            res.append(x)\n        else:\n            h |= {x}\n    odd = sorted(list(h))\n    for i in range(0, (len(odd))//2):\n        res.append(odd[i])\n    if len(odd) % 2 == 1:\n        mid = odd[len(odd)//2]\n    else:\n        mid = \"\"\n    res.sort()\n    ans = \"\".join(res) + mid + \"\".join(res[::-1])\n    print(ans)\n\n__starting_point()", "s = input()\nalphabets = [chr(x) for x in range(ord('a'), ord('z')+1)]\na = {}\n\nfor i in alphabets:\n    a[i] = 0\n\nfor c in s:\n    a[c] += 1\n\ne = None\nodds = [j for j in alphabets if a[j]%2==1]\nk = len(odds)//2\n\nif len(odds) % 2 == 1:\n    e = odds[k]\n    odds.remove(odds[k])\n\nfor j in odds[:k]:\n    a[j] += 1\nfor j in odds[k:]:\n    a[j] -= 1\n\nv = []\nfor i in alphabets:\n    if a[i] % 2 == 1:\n        v.append(i * (a[i]//2))\n    else:\n        v.append(i * (a[i] // 2))\n\nz = ''.join(v) + (e if e is not None else '')\nv.reverse()\nz += ''.join(v)\nprint(z)\n\n", "import math\ns1=input()\ns1=''.join(sorted(s1))\nnen=0\np=\"\"\nnp=\"\"\not=\"\"\no=\"\"\ni=0\no1=[]\nwhile i<len(s1):\n    if i==len(s1)-1:\n        np=np+s1[i]\n    elif s1[i]==s1[i+1]:\n        p=p+s1[i]\n        i=i+1\n    else:\n        np=np+s1[i]\n    i=i+1\nd=math.ceil(len(s1)/2)\nif len(s1)%2==0:\n    ot=ot+p\n    for i in range(0,int(len(s1)/2)-len(p)):\n        ot=ot+np[i]\n    ot=''.join(sorted(ot))     \nelse:\n    ot=ot+p\n    for i in range(0,int(math.ceil(len(s1)/2))-1-len(p)):\n        ot=ot+np[i]\n        nen=i+1\n    ot=''.join(sorted(ot)) \n    ot=ot+np[nen]    \n       \nfor i in range(0, d):\n    o=o+ot[i]\nif len(s1)%2==0:\n    for i in range(0,d):\n        o1.append(ot[d-i-1])\nelse:\n    for i in range(0,d-1):\n        o1.append(ot[d-i-2])\n#for i in range(0, d-1):\n#    o1.append(ot[d-i-1])\n#print(p)\n#print(np)\n#print(ot)\n#print(ot)\n#print(o)\n#print(o1)\nprint(o+''.join(o1))\n", "s = input()\ncnt = [0] * 256\nfor i in s:\n    cnt[ord(i)] += 1\ni = ord('a')\nj = ord('z')\nwhile i < j:\n    while i < j and cnt[i] % 2 == 0:\n        i += 1\n    while i < j and cnt[j] % 2 == 0:\n        j -= 1\n    if i < j:\n        cnt[i] += 1\n        cnt[j] -= 1\n        i += 1\n        j -= 1\nres1 = ''\nres2 = ''\nc = ''\nfor i in range(ord('a'), ord('z') + 1):\n    res1 = res1 + chr(i) * (cnt[i] // 2)\n    res2 = chr(i) * (cnt[i] // 2) + res2\n    if cnt[i] % 2 == 1:\n        c = chr(i)\nprint(res1 + c + res2)", "# List of lowercase letters.\nletters = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\n# Constructs the alphabetically smallest palindrome based on letter frequencies for a palindrome.\ndef getPalindrome(counts):\n    returnString = \"\"\n\n    for i in range(len(counts)):\n        if counts[i] >= 2:\n            for j in range(counts[i] // 2):\n                counts[i] -= 2\n                returnString += letters[i]\n\n    for i in range(len(counts)):\n        if counts.count(0) == 26:\n            return (returnString + returnString[::-1])\n        elif counts[i] == 1 and counts.count(0) == 25:\n            return (returnString + letters[i] + returnString[::-1])\n\n# Changes the counts of each letter in preparation for constructing a palindrome.\ndef changeCounts(counts):\n    allEven = True\n\n    for i in counts:\n        if i % 2 == 1:\n            allEven = False\n\n    if allEven == True:\n        return counts\n    else:\n        for i in range(len(counts)):\n            if counts[25 - i] % 2 == 1:\n                for j in range(len(counts)):\n                    if j == 25 - i:\n                        return counts\n                    elif counts[j] % 2 == 1:\n                        counts[j] += 1\n                        counts[25 - i] -= 1\n                        break\n        return counts\n\ninputArg = list(input())\n\ncounts = []\n\nfor i in letters:\n    counts.append(inputArg.count(i))\n\ncounts = changeCounts(counts)\nprint(getPalindrome(counts))", "st=input()\narr=[0 for i in range(26)]\nch='a'\nfor i in range(26) :\n    arr[i]=st.count(chr(i+ord('a')))\ni,j=0,25\nn=len(st)\nwhile i<26 and arr[i]%2==0:\n    i+=1\nwhile  j>0 and arr[j]%2==0 :\n    j-=1\nwhile i<j:\n    arr[i]=arr[i]+1\n    arr[j]=arr[j]-1\n    while i<26 and arr[i]%2==0 :\n        i+=1\n    while 0<j and arr[j]%2==0 :\n        j-=1     \nr=''\nmiddle=''\n\nfor i in range(26):\n    c=str(chr(i+97))\n    r=r+ c*(arr[i]//2)\n    if arr[i]%2==1:\n        middle=c\nprint(r+middle+r[::-1])        ", "import string\ns = input()\nfreq = {x: 0 for x in string.ascii_lowercase}\nfor char in s:\n    freq[char] += 1\nhead = 'a'\ntail = 'z'\nwhile head < tail:\n    if freq[tail] % 2 == 0:\n        tail = chr(ord(tail) - 1)\n        if tail <= head:\n            break\n    if freq[head] % 2 == 0:\n        head = chr(ord(head) + 1)\n        if tail <= head:\n            break\n    if freq[head] % 2 != 0 and freq[tail] % 2 != 0:\n        freq[head] += 1\n        freq[tail] -= 1\nmiddle_letter = None\nif head == tail and freq[head] % 2 != 0:\n    middle_letter = head\n    freq[head] -= 1\noutput = \"\"\nfor x in string.ascii_lowercase:\n    for i in range(freq[x] // 2):\n        output += x\nif middle_letter:\n    output += middle_letter + output[::-1]\nelse:\n    output += output[::-1]\nprint(output)\n", "#!/usr/bin/env python3\n\ndef solve(s):\n    cnt = dict()\n    for c in s:\n        if c not in cnt:\n            cnt[c] = 0\n        cnt[c] += 1\n\n    num_odd = 0\n    odds = []\n    for k, v in list(cnt.items()):\n        if v%2:\n            num_odd += 1\n            odds.append(k)\n    odds.sort()\n    for i in range(num_odd//2):\n        cnt[odds[i]] += 1\n        cnt[odds[-i-1]] -= 1\n    if len(s)%2 == 0:\n        return create_palin(cnt)\n    else:\n        return create_palin_odd(cnt)\n\ndef create_palin(cnt):\n    total = sum(v for k, v in list(cnt.items()))\n    p = [None]*total\n\n    lo = 0\n    hi = total-1\n    for k, v in sorted(cnt.items()):\n        while v > 0:\n            p[lo] = k\n            p[hi] = k\n            lo += 1\n            hi -= 1\n            v -= 2\n    return str.join('', p)\n\ndef create_palin_odd(cnt):\n    total = sum(v for k, v in list(cnt.items()))\n    odd = [k for k, v in list(cnt.items()) if v%2 == 1][0]\n    p = []\n    for k, v in sorted(cnt.items()):\n        how = v//2\n        p += [k]*(v//2)\n    p = p + [odd] + list(reversed(p))\n    return str.join('', p)\n\n\n\ndef __starting_point():\n    s = input()\n    print(solve(s))\n\n__starting_point()", "import string\n\ndef main():\n\ts = input()\n\tprint(makePalindrome(s))\n\ndef makePalindrome(s):\n\tletters = 26\n\tlCounts = [0] * letters\n\tfor c in s:\n\t\tlCounts[ord(c) - ord('a')]  += 1\n\todds = [i for i in range(letters) if lCounts[i] % 2 != 0]\n\tif len(s) % 2 == 0:\n\t\tfor i in range(len(odds) // 2):\n\t\t\tlCounts[odds[i]] += 1\n\t\tfor i in range(len(odds) // 2, len(odds)):\n\t\t\tlCounts[odds[i]] -= 1\n\t\t#print(lCounts)\n\t\treturn countsToPalindrome(lCounts, 0)\n\telse:\n\t\tfor i in range(len(odds) // 2):\n\t\t\tlCounts[odds[i]] += 1\n\t\tfor i in range(len(odds) // 2 + 1, len(odds)):\n\t\t\tlCounts[odds[i]] -= 1\n\t\t#print(lCounts)\n\t\treturn countsToPalindrome(lCounts, 0)\n\ndef countsToPalindrome(L, i, middle = \"\"):\n\tif i == len(L):\n\t\treturn middle\n\telif L[i] % 2 == 0:\n\t\tletter = string.ascii_lowercase[i]\n\t\treturn (letter * (L[i] // 2)) + \\\n\t\tcountsToPalindrome(L, i + 1, middle) + \\\n\t\t(letter * (L[i] // 2))\n\telse:\n\t\tletter = string.ascii_lowercase[i]\n\t\treturn (letter * ((L[i] - 1) // 2)) + \\\n\t\tcountsToPalindrome(L, i + 1, letter) + \\\n\t\t(letter * ((L[i] - 1) // 2))\n\nmain()\n#print(makePalindrome(\"aaaabbbbccccddezlm\"))\n#print(makePalindrome(\"\"))\n", "from collections import defaultdict\n\ns = input()\nl = defaultdict(int)\nfor c in s:\n    l[c] += 1\n\nu = sorted(list(filter(lambda x: l[x] % 2, l.keys())))\n\nfor i in range(0, int(len(u) / 2)):\n    l[u[i]] += 1\n    l[u[-i-1]] -= 1\n\nr = \"\"\nfor c in sorted(l.keys()):\n    r += c * int(l[c] / 2)\n\nc = u[int(len(u) / 2)] if len(u) % 2 else \"\"\n\nprint(r + c + r[::-1])", "#CF 600C isprav\nq=input()\n#q='aabbcccdd'\n\nalfavitk=[0]*26\nalfavit='abcdefghijklmnopqrstuvwxyz'\n\nfor i in range(26):\n        alfavitk[i]=q.count(alfavit[i])\n    \nfirst=0\nlast=25\nwhile True:\n    while alfavitk[first]%2==0 and first<last:\n        first+=1\n    while alfavitk[last]%2==0 and first<last:\n        last-=1\n    \n    if first<last:\n        alfavitk[first]+=1\n        alfavitk[last]-=1\n        first+=1\n        last-=1\n    else:\n        break\n\n#print(alfavitk)\n#print(first)\n#print(last)\n\n\nif alfavitk[first]%2==1:\n    res=alfavit[first]\n    alfavitk[first]-=1\n    \nelse:\n    res=''\n\nfor i in range(25,-1,-1):\n    if alfavitk[i]%2==1:\n        res=alfavit[i]*()\n    res=alfavit[i]*(alfavitk[i]//2)+res+alfavit[i]*(alfavitk[i]//2)\n        \n    \nprint(res)", "s = input()\nss = dict()\nfor c in s:\n    ss[c] = ss.get(c, 0)  + 1\nw = list(ss.keys())\nw.sort()\nwo = [a for a in w if ss[a] % 2 != 0]\nfor a, b in zip(wo[:len(wo)//2], wo[::-1][:len(wo)//2]):\n    ss[a] += 1\n    ss[b] -= 1\nsr = \"\".join([(ss[c] // 2)*c for c in w])\np = [c for c in w if ss[c] % 2 != 0]\nprint(sr + \"\".join(p) + sr[::-1])\n", "from bisect import insort\n\n# abcd\n# aabc\n# aaab aabb\n# aaaa\n\ndef main():\n    wd = input()\n    chars = dict()\n    for c in wd:\n        if c not in chars:\n            chars[c] = 0\n        chars[c] += 1\n    odds = list()\n    evens = list()\n\n    for k, v in list(chars.items()):\n        if v%2:\n            odds.append((k,v))\n        else:\n            evens.append((k,v))\n\n    odds.sort()\n    #print(odds)\n    while len(odds) > 1:\n        odds[0] = (odds[0][0], odds[0][1]+1)\n        odds[-1] = (odds[-1][0], odds[-1][1]-1)\n        if odds[-1][1] < 1:\n            del odds[-1]\n        elif odds[-1][1]%2 == 0:\n            evens.append(odds.pop())\n        if odds[0][1]%2 == 0:\n            evens.append(odds[0])\n            del odds[0]\n\n    if len(odds) and odds[0][1] > 1:\n        evens.append((odds[0][0], odds[0][1]-1))\n        odds[0] = (odds[0][0], 1)\n\n    evens.sort()\n    #print(odds,'\\n', evens)\n\n    p = list()\n    for x, c in evens:\n        for k in range(c//2):\n            p.append(x)\n\n    if len(odds):\n        print(''.join(p + [odds[0][0] for _ in range(odds[0][1])] + p[::-1]))\n    else:\n        print(''.join(p + p[::-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\na=g.add_edges_from\nfor i in range(m:=H*W):\n  a([[m*2,h:=i//W],[m*2,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I)\n  a([[h,w],[w,h]]*(c>'T'),capacity=1)\nprint([-1,f:=minimum_cut(g,m*2,I)[0]][f<I])", "from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\nfor i in range(m:=H*W):g.add_weighted_edges_from([[m*2,h:=i//W,I:=m*3],[m*2,w:=i%W+m,I]]*((c:=S[h][w-m])=='S')+[[h,I,I],[w,I,I]]*(c=='T')+[[h,w,1],[w,h,1]]*(c>'T'))\nprint([-1,f:=minimum_cut(g,m*2,I,'weight')[0]][f<I])", "import sys\nsys.setrecursionlimit(10**8)\nclass FK:\n    def __init__(self,n):\n        self.table=[[0]*n for i in range(n)]\n        self.n=n\n    \n    def add(self,x,y,f):\n        self.table[x][y]=f\n        \n    def ford(self,s,t,f):\n        self.visit[s]=True\n        if s==t:\n            return f\n        for i in range(self.n):\n            if (not self.visit[i]) and self.table[s][i]>0:\n                df=self.ford(i,t,min(f,self.table[s][i]))\n                if df>0:\n                    self.table[s][i]-=df\n                    self.table[i][s]+=df\n                    return df\n        return 0\n    \n    def flow(self,s,t):\n        ans=0\n        inf=10**20\n        while True:\n            self.visit=[False]*(self.n)\n            df=self.ford(s,t,inf)\n            if df==0:\n                break\n            ans+=df\n        return ans\n\nH,W=map(int,input().split())\nC=[input() for i in range(H)]\nmaxflow=FK(W+H+2)\ninf=10**20\nfor i in range(W):\n    for j in range(H):\n        if C[j][i]=='S':\n            sx=i\n            sy=j\n            maxflow.add(0,i+1,inf)\n            maxflow.add(0,W+1+j,inf)\n            continue\n        if C[j][i]=='T':\n            gx=i\n            gy=j\n            maxflow.add(i+1,W+H+1,inf)\n            maxflow.add(W+1+j,W+H+1,inf)\n            continue\n        if C[j][i]=='o':\n            maxflow.add(i+1,W+1+j,1)\n            maxflow.add(W+1+j,i+1,1)\n#print(maxflow.table)\nif gx==sx or gy==sy:\n    print('-1')\n    return\nans=maxflow.flow(0,H+W+1)\nprint(ans)", "from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\na=g.add_edges_from\nfor i in range(m:=H*W):a([[M:=m*2,h:=i//W],[M,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I),a([[h,w],[w,h]]*(c>'T'),capacity=1)\nf,_=minimum_cut(g,M,I)\nprint(-(f>M)or f)", "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n#A\ndef A():\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    def bfs(s,g,n):\n        bfs_map = [-1 for i in range(n)]\n        bfs_map[s] = 0\n        q = deque()\n        q.append(s)\n        fin = False\n        while q:\n            x = q.popleft()\n            for y in range(n):\n                if c[x][y] > 0 and bfs_map[y] < 0:\n                    bfs_map[y] = bfs_map[x]+1\n                    if y == g:\n                        fin = True\n                        break\n                    q.append(y)\n            if fin:\n                break\n\n        if bfs_map[g] == -1:\n            return [None,0]\n        path = [None for i in range(bfs_map[g]+1)]\n        m = float(\"inf\")\n        path[bfs_map[g]] = g\n        y = g\n        for i in range(bfs_map[g])[::-1]:\n            for x in range(n+1):\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                    path[i] = x\n                    if c[x][y] < m:\n                        m = c[x][y]\n                    y = x\n                    break\n        return [path,m]\n\n    def ford_fulkerson(s,g,c,n):\n        while 1:\n            p,m = bfs(s,g,n)\n            if not m:break\n            for i in range(len(p)-1):\n                c[p[i]][p[i+1]] -= m\n                c[p[i+1]][p[i]] += m\n        return sum(c[g])\n    h,w = LI()\n    a = SR(h)\n    c = [[0 for i in range(h+w+2)] for j in range(h+w+2)]\n    for y in range(h):\n        for x in range(w):\n            if a[y][x] == \"S\":\n                c[0][y+1] = float(\"inf\")\n                c[0][h+x+1] = float(\"inf\")\n            if a[y][x] == \"T\":\n                c[y+1][h+w+1] = float(\"inf\")\n                c[h+x+1][h+w+1] = float(\"inf\")\n            if a[y][x] == \"o\":\n                c[y+1][h+x+1] = 1\n                c[h+x+1][y+1] = 1\n    ans = ford_fulkerson(0,h+w+1,c,h+w+2)\n    if ans == float(\"inf\"):\n        print((-1))\n    else:\n        print(ans)\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\ndef __starting_point():\n    F()\n\n__starting_point()", "# maximum flow\nfrom collections import defaultdict\n\ndef ford_fulkerson(graph, start, end):\n    \"\"\" \n    graph: [dict<int,int>]\n    start: int\n    end: int\n    \"\"\"\n    INF = 10**9\n    network = [defaultdict(int, paths) for paths in graph]\n\n    def dfs(start, end, visited):\n        \"\"\"\n        None: unreachable\n        (): reached\n        \"\"\"\n        if start == end:\n            return ()\n        visited.add(start)\n        for next_, capacity in filter(lambda next_capacity: next_capacity[0] not in visited and next_capacity[1] > 0, network[start].items()):\n            path = dfs(next_, end, visited)\n            if path is not None:\n                return (next_, capacity, path)\n        return None\n\n    def margin(path, min_margin=INF):\n        if path == ():\n            return min_margin\n        _, capacity, remaining_path = path\n        return margin(remaining_path, min(min_margin, capacity))\n\n    def flush(start, path, amount):\n        if path == ():\n            return\n        next_, _, remaining_path = path\n        network[start][next_] -= amount\n        network[next_][start] += amount\n        flush(next_, remaining_path, amount)\n\n    while True:\n        path = dfs(start, end, set())\n        if path == None:\n            break\n        flush(start, path, margin(path))\n\n    return sum(cap for _, cap in graph[start].items()) - sum(cap for _, cap in network[start].items())\n\nh, w = map(int, input().split())\nA = [input() for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        if A[i][j] == 'S':\n            s = (i, j)\n        if A[i][j] == 'T':\n            t = (i, j)\n\nif t[0] == s[0] or t[1] == s[1]:\n    print(-1)\nelse:\n    INF = 10**8\n    si = h + w\n    ti = h + w + 1\n    graph = [{} for _ in range(h + w + 2)]\n    graph[si][s[0]] = INF\n    graph[si][h + s[1]] = INF\n    graph[t[0]][ti] = INF\n    graph[h + t[1]][ti] = INF\n    for i in range(h):\n        for j in range(w):\n            if A[i][j] == 'o':\n                graph[i][h + j] = 1\n                graph[h + j][i] = 1\n    print(ford_fulkerson(graph, si, ti))", "from collections import deque\nINF = float(\"inf\")\nTO = 0;  CAP = 1;  REV = 2\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.V = [[] for _ in range(N)]  # to, cap, rev\n        # \u8fba e = V[n][m] \u306e\u9006\u8fba\u306f V[e[TO]][e[REV]]\n        self.level = [0] * N\n\n    def add_edge(self, u, v, cap):\n        self.V[u].append([v, cap, len(self.V[v])])\n        self.V[v].append([u, 0, len(self.V[u])-1])\n\n    def add_edge_undirected(self, u, v, cap):  # \u672a\u691c\u8a3c\n        self.V[u].append([v, cap, len(self.V[v])])\n        self.V[v].append([u, cap, len(self.V[u])-1])\n\n    def bfs(self, s: int) -> bool:\n        self.level = [-1] * self.N\n        self.level[s] = 0\n        q = deque()\n        q.append(s)\n        while len(q) != 0:\n            v = q.popleft()\n            for e in self.V[v]:\n                if e[CAP] > 0 and self.level[e[TO]] == -1:  # cap\u304c1\u4ee5\u4e0a\u3067\u672a\u63a2\u7d22\u306e\u8fba\n                    self.level[e[TO]] = self.level[v] + 1\n                    q.append(e[TO])\n        return True if self.level[self.g] != -1 else False  # \u5230\u9054\u53ef\u80fd\n\n    def dfs(self, v: int, f) -> int:\n        if v == self.g:\n            return f\n        for i in range(self.ite[v], len(self.V[v])):\n            self.ite[v] = i\n            e = self.V[v][i]\n            if e[CAP] > 0 and self.level[v] < self.level[e[TO]]:\n                d = self.dfs(e[TO], min(f, e[CAP]))\n                if d > 0:  # \u5897\u52a0\u8def\n                    e[CAP] -= d  # cap \u3092\u6e1b\u3089\u3059\n                    self.V[e[TO]][e[REV]][CAP] += d  # \u53cd\u5bfe\u65b9\u5411\u306e cap \u3092\u5897\u3084\u3059\n                    return d\n        return 0\n\n    def solve(self, s, g):\n        self.g = g\n        flow = 0\n        while self.bfs(s):  # \u5230\u9054\u53ef\u80fd\u306a\u9593\n            self.ite = [0] * self.N\n            f = self.dfs(s, INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, INF)\n        return flow\nH, W = list(map(int, input().split()))\ndinic = Dinic(H+W+2)\nfor i in range(H):\n    a = input()\n    for j, a_ in enumerate(a):\n        if a_==\"S\":\n            start = i, j\n        elif a_==\"T\":\n            goal = i, j\n        if a_!=\".\":\n            dinic.add_edge_undirected(H + j, i, 1)\ndinic.add_edge_undirected(H+W, start[0], 1<<30)\ndinic.add_edge_undirected(H+W, start[1]+H, 1<<30)\ndinic.add_edge_undirected(H+W+1, goal[0], 1<<30)\ndinic.add_edge_undirected(H+W+1, goal[1]+H, 1<<30)\n\nif start[0]==goal[0] or start[1]==goal[1]:\n    print((-1))\nelse:\n    print((dinic.solve(H+W, H+W+1)))\n", "# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\n# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nh,w = list(map(int,readline().split()))\nb = read().split()\n\n#g = [[] for _ in range(h+w+2)]\n\nS = h+w\nT = h+w+1\n\nD = Dinic(h+w+2)\n\nfor i in range(h):\n    for j in range(w):\n        if b[i][j] == \"S\":\n            #print(\"S\")\n            sh,sw = i,j\n            D.add_edge(S, i, 200)        \n            D.add_edge(S, j+h, 200)        \n            #g[S].append((i,200))\n            #g[S].append((j+h,200))\n        elif b[i][j] == \"T\":\n            #print(\"T\")\n            th,tw = i,j\n            D.add_edge(i, T, 200)        \n            D.add_edge(j+h, T, 200)        \n            #g[i].append((T,200))\n            #g[j+h].append((T,200))\n        elif b[i][j] == \"o\":\n            #print(\"o\")\n            D.add_edge(i, j+h, 1)        \n            D.add_edge(j+h, i, 1)        \n            #g[i].append((j+h,1))\n            #g[j+h].append((i,1))\n            \n\nif sh==th or sw==tw: print((-1))\nelse:\n    print((D.flow(S,T)))\n    \n    \n    \n    \n    \n    \n\n\n\n\n\n\n\n", "from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\na=g.add_edges_from\nfor i in range(m:=H*W):a([[m*2,h:=i//W],[m*2,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I),a([[h,w],[w,h]]*(c>'T'),capacity=1)\nprint([-1,f:=minimum_cut(g,m*2,I)[0]][f<I])", "def main():\n    import sys\n    sys.setrecursionlimit(1000000)\n    # \u884c\u5148\u3001\u4e0a\u9650\u3001\u9006\u8fba\n\n    def add_edge(From, to, cap):\n        g[From][to] = cap\n        g[to][-From-1] = 0\n\n    def max_flow(s, t):\n        def dfs(v, t, f):\n            q.append(v)\n            if v == t:\n                return f\n            used[v] += 1\n            for i in range(len(gkey[v])):\n                to = gkey[v][i]\n                cap = g[v][to]\n                if to < 0:\n                    to2 = -to-1\n                else:\n                    to2 = to\n                if used[to2] or cap == 0:\n                    continue\n                d = dfs(to2, t, min(f, cap))\n                if d > 0:\n                    g[v][to] -= d\n                    g[to2][-v-1] += d\n                    return d\n            q.pop()\n            return 0\n\n        flow = 0\n        while True:\n            used = [0]*n\n            q = []\n            f = dfs(s, t, 10**100)\n            if not q:\n                return flow\n            flow += f\n\n    h, w = list(map(int, input().split()))\n    n = h+w+2\n    g = [dict() for _ in range(n)]\n    for i in range(h):\n        A = input()\n        for j in range(w):\n            if A[j] == \"o\":\n                add_edge(i, j+h, 1)\n                add_edge(j+h, i, 1)\n            elif A[j] == \"S\":\n                add_edge(h+w, i, 10**6)\n                add_edge(h+w, j+h, 10**6)\n            elif A[j] == \"T\":\n                add_edge(i, h+w+1, 10**6)\n                add_edge(j+h, h+w+1, 10**6)\n    gkey = [list(i.keys()) for i in g]\n\n    ans = max_flow(h+w, h+w+1)\n    if ans >= 10**6:\n        print((-1))\n    else:\n        print(ans)\n\n\nmain()\n", "#ARC074 F #Ford-Fulkerson\n#with explanation\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\nH, W = list(map(int, input().split()))\nA = [0] * H\nfor i in range(H):\n  A[i] = str(input())    \n#print(A)  \nN = H + W + 2\nB = [0] * N\nStart = 0\nGoal = N-1\nans = 0\nlines = defaultdict(set)\ncost = [[0] * (N) for i in range(N)]\nfor i in range(H):#i + 1\n  for j in range(W):#H + 1 + j\n    if A[i][j] == \"S\":\n      sx, sy = i, j\n      lines[0].add(i+1)   \n      cost[0][i+1] = INF\n      lines[0].add(H+1+j)   \n      cost[0][H+1+j] = INF\n    elif A[i][j] == \"T\":\n      gx, gy = i, j\n      lines[i+1].add(N-1)  \n      cost[i+1][N-1] = INF\n      lines[H+1+j].add(N-1)\n      cost[H+1+j][N-1] = INF\n    elif A[i][j] == \"o\":\n      lines[i+1].add(H+1+j)  \n      cost[i+1][H+1+j] = 1\n      lines[H+1+j].add(i+1)\n      cost[H+1+j][i+1] = 1      \n      \nif sx == gx or sy == gy:\n  print((-1))\n  return\n#print(B)\n#print(lines)\n\ndef Ford_Fulkerson(s): #s\u304b\u3089Ford-Fulkerson\n    nonlocal lines\n    nonlocal cost\n    nonlocal ans\n    queue = deque()     #BFS\u7528\u306edeque\n    queue.append([s,INF])\n    ed = [True]*(N)    #\u5230\u9054\u6e08\u307f\n    ed[s] = False\n    route = [0 for i in range(N)]   #\u30eb\u30fc\u30c8\n    route[s] = -1\n    #BFS\n    while queue:\n        s,flow = queue.pop()\n        for t in lines[s]:  #s->t\n            if ed[t]:\n                flow = min(cost[s][t],flow)  #flow = min(\u76f4\u524d\u306eflow,line\u5bb9\u91cf)\n                route[t] = s\n                queue.append([t,flow])\n                ed[t] = False\n                if t == Goal: #\u30b4\u30fc\u30eb\u5230\u9054\n                    ans += flow\n                    break\n        else:\n            continue\n        break\n    else:\n        return False\n    #\u30e9\u30a4\u30f3\u306e\u66f4\u65b0\n    t = Goal\n    s = route[t]\n    while s != -1:\n        #s->t\u306e\u30b3\u30b9\u30c8\u6e1b\u5c11\uff0c\u30bc\u30ed\u306b\u306a\u308b\u306a\u3089\u8fba\u3092\u524a\u9664\n        cost[s][t] -= flow\n        if cost[s][t] == 0:\n            lines[s].remove(t)\n        #t->s(\u9006\u9806)\u306e\u30b3\u30b9\u30c8\u5897\u52a0\uff0c\u5143\u304c\u30bc\u30ed\u306a\u3089\u8fba\u3092\u4f5c\u6210\n        if cost[t][s] == 0:\n            lines[t].add(s)\n        cost[t][s] += flow\n        t = s\n        s = route[t]\n        \n    return True\n\nwhile True:\n    if Ford_Fulkerson(Start):\n        continue\n    else:\n        break\n        \nprint(ans)\n\n", "import sys\ninput = sys.stdin.readline\nH, W = list(map(int, input().split()))\na = [list(input())[: -1] for _ in range(H)]\nc = H + W - 1\nclass FordFulkerson:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        used = self.used\n        used[v] = 1\n        for e in self.G[v]:\n            w, cap, rev = e\n            if cap and not used[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        f = INF = c\n        N = self.N\n        while f:\n            #print(f)\n            self.used = [0]*N\n            f = self.dfs(s, t, INF)\n            flow += f\n        return flow\nflk = FordFulkerson(H * W * 2 + H + W + 1)\nb = H * W\ns = 0\nt = 0\nfor i in range(H):\n  for j in range(W):\n    if a[i][j] != \".\":\n      flk.add_edge(b + i * W + j, b * 2 + i, c)\n      flk.add_edge(b * 2 + i, i * W + j, c)\nfor j in range(W):\n  for i in range(H):\n    if a[i][j] != \".\":\n      flk.add_edge(b + i * W + j, b * 2 + H + j, c)\n      flk.add_edge(b * 2 + H + j, i * W + j, c)\nfor i in range(H):\n  for j in range(W):\n    if a[i][j] != \".\":\n      flk.add_edge(i * W + j, b + i * W + j, 1)\n    if a[i][j] == \"S\": s = b + i * W + j\n    if a[i][j] == \"T\": t = i * W + j\nif (s - b) % W != t % W and ((s - b) // W != t // W):\n  if sum([x.count(\"o\") for x in a]) == H * W - 2: print((min(H, W) * 2 - 2))\n  else: print((flk.flow(s, t)))\nelse: print((-1))\n", "# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\nfrom collections import deque\nclass Dinic:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.g = [[] for i in range(n)]\n\n\tdef add_edge(self, fr, to, cap):\n\t\tforward = [to, cap, None]\n\t\tforward[2] = backward = [fr, 0, forward]\n\t\tself.g[fr].append(forward)\n\t\tself.g[to].append(backward)\n\n\tdef add_bidirectional_edge(self, v1, v2, cap1, cap2):\n\t\tedge1 = [v2, cap1, None]\n\t\tedge1[2] = edge2 = [v1, cap2, edge1]\n\t\tself.g[v1].append(edge1)\n\t\tself.g[v2].append(edge2)\n\n\tdef bfs(self, s, t):\n\t\tself.level = level = [None]*self.n\n\t\tdeq = deque([s])\n\t\tlevel[s] = 0\n\t\tg = self.g\n\t\twhile deq:\n\t\t\tv = deq.popleft()\n\t\t\tlv = level[v] + 1\n\t\t\tfor w, cap, _ in g[v]:\n\t\t\t\tif cap and level[w] is None:\n\t\t\t\t\tlevel[w] = lv\n\t\t\t\t\tdeq.append(w)\n\t\treturn level[t] is not None\n\n\tdef dfs(self, v, t, f):\n\t\tif v == t:\n\t\t\treturn f\n\t\tlevel = self.level\n\t\tfor e in self.it[v]:\n\t\t\tw, cap, rev = e\n\t\t\tif cap and level[v] < level[w]:\n\t\t\t\td = self.dfs(w, t, min(f, cap))\n\t\t\t\tif d:\n\t\t\t\t\te[1] -= d\n\t\t\t\t\trev[1] += d\n\t\t\t\t\treturn d\n\t\treturn 0\n\n\tdef flow(self, s, t):\n\t\tflow = 0\n\t\tINF = 10**30\n\t\tg = self.g\n\t\twhile self.bfs(s, t):\n\t\t\t*self.it, = map(iter, self.g)\n\t\t\tf = INF\n\t\t\twhile f:\n\t\t\t\tf = self.dfs(s, t, INF)\n\t\t\t\tflow += f\n\t\treturn flow\n\nH, W = map(int, input().split())\na = [input() for _ in range(H)]\nd = Dinic(H+W+2)\nfor i in range(H):\n\tfor j in range(W):\n\t\tif a[i][j] == \"S\":\n\t\t\td.add_edge(H+W, i, 10**5)\n\t\t\td.add_edge(H+W, H+j, 10**5)\n\t\telif a[i][j] == \"T\":\n\t\t\td.add_edge(i, H+W+1, 10**5)\n\t\t\td.add_edge(H+j, H+W+1, 10**5)\n\t\telif a[i][j] == \"o\":\n\t\t\td.add_edge(i, H+j, 1)\n\t\t\td.add_edge(H+j, i, 1)\nans = d.flow(H+W, H+W+1)\nif ans > 10000:\n\tprint(-1)\nelse:\n\tprint(ans)", "from collections import deque\nclass mf_graph:\n    n=1\n    g=[[] for i in range(1)]\n    pos=[]\n    def __init__(self,N):\n        self.n=N\n        self.g=[[] for i in range(N)]\n    def add_edge(self,From,To,cap):\n        assert 0<=From and From<self.n\n        assert 0<=To and To<self.n\n        assert 0<=cap\n        m=len(self.pos)\n        self.pos.append((From,len(self.g[From])))\n        self.g[From].append({\"to\":To,\"rev\":len(self.g[To]),\"cap\":cap})\n        self.g[To].append({\"to\":From,\"rev\":len(self.g[From])-1,\"cap\":0})\n        return m\n    def get_edge(self,i):\n        m=len(self.pos)\n        assert 0<=i and i<m\n        _e=self.g[self.pos[i][0]][self.pos[i][1]]\n        _re=self.g[_e[\"to\"]][_e[\"rev\"]]\n        return {\"from\":self.pos[i][0],\n                \"to\":_e[\"to\"],\n                \"cap\":_e[\"cap\"]+_re[\"cap\"],\n                \"flow\":_re[\"cap\"]}\n    def edges(self):\n        m=len(self.pos)\n        result=[]\n        for i in range(m):\n            result.append(self.get_edge(i))\n        return result\n    def change_edge(self,i,new_cap,new_flow):\n        m=len(self.pos)\n        assert 0<=i and i<m\n        assert 0<=new_flow and new_flow<=new_cap\n        _e=self.g[self.pos[i][0]][self.pos[i][1]]\n        _re=self.g[_e[\"to\"]][_e[\"rev\"]]\n        _e[\"cap\"]=new_cap-new_flow\n        _re[\"cap\"]=new_flow\n    def flow(self,s,t,flow_limit=(2**31)-1):\n        assert 0<=s and s<self.n\n        assert 0<=t and t<self.n\n        level=[0 for i in range(self.n)]\n        Iter=[0 for i in range(self.n)]\n        que=deque([])\n        def bfs():\n            for i in range(self.n):\n                level[i]=-1\n            level[s]=0\n            que=deque([])\n            que.append(s)\n            while(len(que)>0):\n                v=que.popleft()\n                for e in self.g[v]:\n                    if e[\"cap\"]==0 or level[e[\"to\"]]>=0:continue\n                    level[e[\"to\"]]=level[v]+1\n                    if e[\"to\"]==t:return\n                    que.append(e[\"to\"])\n        def dfs(func,v,up):\n            if (v==s):return up\n            res=0\n            level_v=level[v]\n            for i in range(Iter[v],len(self.g[v])):\n                e=self.g[v][i]\n                if (level_v<=level[e[\"to\"]] or self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]==0):continue\n                d=func(func,e[\"to\"],min(up-res,self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]))\n                if d<=0:continue\n                self.g[v][i][\"cap\"]+=d\n                self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]-=d\n                res+=d\n                if res==up:break\n            return res\n        flow=0\n        while(flow<flow_limit):\n            bfs()\n            if level[t]==-1:\n                break\n            for i in range(self.n):\n                Iter[i]=0\n            while(flow<flow_limit):\n                f=dfs(dfs,t,flow_limit-flow)\n                if not(f):break\n                flow+=f\n        return flow\n    def min_cut(self,s):\n        visited=[False for i in range(self.n)]\n        que=deque([])\n        que.append(s)\n        while(len(que)>0):\n            p=que.popleft()\n            visited[p]=True\n            for e in self.g[p]:\n                if e[\"cap\"] and not(visited[e[\"to\"]]):\n                    visited[e[\"to\"]]=True\n                    que.append(e[\"to\"])\n        return visited\n\nH,W=list(map(int,input().split()))\na=[list(input()) for i in range(H)]\nG=mf_graph(H+W+2)\nINF=10**9\ns=H+W\nt=H+W+1\nfor i in range(H):\n    for j in range(W):\n        if a[i][j]==\"S\":\n            G.add_edge(s,i,INF)\n            G.add_edge(s,j+H,INF)\n        if a[i][j]==\"T\":\n            G.add_edge(i,t,INF)\n            G.add_edge(j+H,t,INF)\n        if a[i][j]!=\".\":\n            G.add_edge(i,j+H,1)\n            G.add_edge(j+H,i,1)\nans=G.flow(s,t)\nif ans>=INF:\n    print((-1))\nelse:\n    print(ans)\n\n", "from scipy.sparse import*\nH,*S=open(0)\nH,W,*A=map(int,H.split())\nfor i in range(m:=H*W):A+=[m*2,h:=i//W,I:=m*3,m*2,w:=i%W+m,I]*((c:=S[h][w-m])=='S')+[h,I,I,w,I,I]*(c=='T')+[h,w,1,w,h,1]*(c>'T')\nprint([-1,f:=csgraph.maximum_flow(csr_matrix((A[2::3],(A[::3], A[1::3])),[I+1]*2),m*2,I).flow_value][f<I])", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, log\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nimport networkx as nx\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**10\nmod = 10 ** 9 + 7\n\nH, W = MAP()\na = [list(input()) for _ in range(H)]\nG = nx.Graph()\nG.add_nodes_from(list(range(0, H+W+2)))\n\nfor i in range(H):\n    for j in range(W):\n        if a[i][j] == \"S\":\n            sy, sx = i, j\n            G.add_edge(0, i+1, capacity=INF)\n            G.add_edge(0, H+j+1, capacity=INF)\n        elif a[i][j] == \"T\":\n            gy, gx = i, j\n            G.add_edge(i+1, H+W+1, capacity=INF)\n            G.add_edge(H+j+1, H+W+1, capacity=INF)\n        elif a[i][j] == \"o\":\n            G.add_edge(i+1, H+j+1, capacity=1)\n            G.add_edge(H+j+1, i+1, capacity=1)\n\nif sy == gy or sx == gx:\n\tprint((-1))\n\treturn\n\nprint((nx.maximum_flow_value(G, 0, H+W+1)))\n", "#!/usr/bin/env python3\n\nINF = 10 ** 9\n\nque = [0] * 1024\n\ndef bfs(g, flow, parent, s1, s2, t1, t2):\n\n    qf = 0\n    que[0] = s1\n    que[1] = s2\n    ql = 2\n\n    while qf < ql:\n        u = que[qf]\n        qf += 1\n        for v in g[u]:\n            if 0 <= flow[u][v] and parent[v] == -1:\n                parent[v] = u\n                if v != t1 and v != t2:\n                    que[ql] = v\n                    ql += 1\n                else:\n                    return 1, v\n\n    return 0, 0\n\n\ndef solve(h, w, g, s, t):\n\n    n = h + w\n    si, sj = s\n    ti, tj = t\n\n    if si == ti or sj == tj:\n        return -1\n\n    f = 0\n    flow = [[0] * n for _ in range(n)]\n\n    while True:\n        parent = [-1] * n\n        parent[si] = -2\n        parent[sj] = -2\n\n        m, te = bfs(g, flow, parent, si, sj, ti, tj)\n        if m == 0:\n            break\n        f += 1\n        v = te\n        while v != si and v != sj:\n            u = parent[v]\n            flow[u][v] -= 1\n            flow[v][u] += 1\n            v = u\n\n    return f\n\n\ndef main():\n    h, w = input().split()\n    h = int(h)\n    w = int(w)\n    g = [[] for _ in range(h + w)]\n    s = None\n    t = None\n    for i in range(h):\n        a = input()\n        for j in range(w):\n            ch = a[j]\n            if ch == 'o':\n                g[i].append(h + j)\n                g[h + j].append(i)\n            elif ch == 'S':\n                s = (i, h + j)\n            elif ch == 'T':\n                t = (i, h + j)\n\n\n    print((solve(h, w, g, s, t)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "class FordFulkerson:\n    \"\"\"max-flow-min-cut\n    O(F|E|)\n    \"\"\"\n\n    def __init__(self,V:int):\n        \"\"\"\n        Arguments:\n            V:num of vertex\n            adj:adjedscent list(adj[from]=(to,capacity,id))\n        \"\"\"\n        self.V = V\n        self.adj=[[] for _ in range(V)]\n        self.used=[False]*V\n\n    def add_edge(self,fro:int,to:int,cap:int):\n        \"\"\"\n        Arguments:\n            fro:from\n            to: to\n            cap: capacity of the edge\n            f: max flow value\n        \"\"\"\n        #edge\n        self.adj[fro].append([to,cap,len(self.adj[to])])\n        #rev edge\n        self.adj[to].append([fro,0,len(self.adj[fro])-1])\n\n    def dfs(self,v,t,f):\n        \"\"\"\n        search increasing path\n        \"\"\"\n        if v==t:\n            return f\n        self.used[v]=True\n        for i in range(len(self.adj[v])):\n            (nex_id,nex_cap,nex_rev) = self.adj[v][i]\n            if not self.used[nex_id] and nex_cap>0:\n                d = self.dfs(nex_id,t,min(f,nex_cap))\n                if d>0:\n                    #decrease capacity to denote use it with d flow\n                    self.adj[v][i][1]-=d\n                    self.adj[nex_id][nex_rev][1]+=d\n                    return d\n        return 0\n\n    def max_flow(self,s:int,t:int):\n        \"\"\"calculate maxflow from s to t\n        \"\"\"\n        flow=0\n        self.used = [False]*self.V\n        #while no increasing path is found\n        while True:\n            self.used = [False]*self.V\n            f = self.dfs(s,t,float(\"inf\"))\n            if f==0:\n                return flow\n            else:\n                flow+=f\n\n\nH,W = list(map(int,input().split()))\ngrid=[[v for v in input()] for _ in range(H)]\n\nF = FordFulkerson(H+W+2)\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j]==\"S\":\n            sy,sx = i,j\n            F.add_edge(0,i+1,float(\"inf\"))\n            F.add_edge(0,H+j+1,float(\"inf\"))\n        elif grid[i][j]==\"T\":\n            gy,gx=i,j\n            F.add_edge(i+1,H+W+1,float(\"inf\"))\n            F.add_edge(H+j+1,H+W+1,float(\"inf\"))\n        elif grid[i][j]==\"o\":\n            F.add_edge(i+1,H+j+1,1)\n            F.add_edge(H+j+1,i+1,1)\n\nif sy==gy or sx==gx:\n    print((-1))\n    return\nprint((F.max_flow(0,H+W+1)))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, log\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf =10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # \u6df1\u3055\n        self.ite = [0]*v  # DFS\u3067\u306e\u63a2\u7d22\u304c\u6e08\u3093\u3067\u3044\u308b\u304b\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFS\u3067\u6df1\u3055\u6c7a\u5b9a,s\u304cstart\n        self.level = [-1]*self.v  # \u5fc5\u8981\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0\u304b\u3064to\u306e\u6df1\u3055\u672a\u5b9a\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFS\u3067\u5897\u52a0\u30d1\u30b9\u63a2\u7d22,v\u958b\u59cb\u3001t\u7d42\u70b9\u3001\u7dcf\u30d5\u30ed\u30fcf\n        if v==t:\n            return f\n        for i in range(self.ite[v],len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap\u6e1b\u5c11\n                    self.G[e[0]][e[2]][1] += d  # \u9006\u8fba\u306ecap\u5897\u52a0\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFS\u3067\u306e\u63a2\u7d22\u304c\u6e08\u3093\u3067\u3044\u308b\u304b\u5426\u304b\n            f =self.dfs(s,t,self.inf)\n            while f>0:\n                flow+= f\n                f = self.dfs(s,t,self.inf)\n\nH, W = MAP()\na = [list(input()) for _ in range(H)]\nD = Dinic(H+W+2)\n\nfor i in range(H):\n    for j in range(W):\n        if a[i][j] == \"S\":\n            sy, sx = i, j\n            D.add_edge(0, i+1, INF)\n            D.add_edge(0, H+j+1, INF)\n        elif a[i][j] == \"T\":\n            gy, gx = i, j\n            D.add_edge(i+1, H+W+1, INF)\n            D.add_edge(H+j+1, H+W+1, INF)\n        elif a[i][j] == \"o\":\n            D.add_edge(i+1, H+j+1, 1)\n            D.add_edge(H+j+1, i+1, 1)\n\nif sy == gy or sx == gx:\n\tprint((-1))\n\treturn\n\nprint((D.max_flow(0, H+W+1)))\n", "from collections import deque\n\nclass EDOMONDS_KARP():\n    def __init__(self, N, s, t):\n        self.N = N; self.s = s; self.t = t\n        self.cap = [[0]*N for _ in range(N)]\n        self.link = [[] for _ in range(N)]\n\n    def add_edge(self, u, v, c):\n        self.cap[u][v] = c\n        self.link[u].append(v)\n        self.link[v].append(u)\n\n    def max_flow(self):\n        N = self.N; s = self.s; t = self.t\n        f = 0\n        flow = [[0]*N for _ in range(N)]\n        while True:\n            m, prev = self.bfs(flow)\n            if m == 0:\n                break\n            f += m\n            v = t\n            while v != s:\n                u = prev[v]\n                flow[u][v] += m\n                flow[v][u] -=m\n                v = u\n        return (f, flow)\n\n    def bfs(self, flow):\n        N = self.N; s = self.s; t = self.t\n        cap = self.cap\n        link = self.link\n        prev = [-1]*N; prev[s] = -2\n        m = [0]*N; m[s] = float('inf')\n        q = deque([s])\n        while q:\n            u = q.popleft()\n            for v in link[u]:\n                if cap[u][v] - flow[u][v] > 0 and prev[v] == -1:\n                    prev[v] = u\n                    m[v] = min(m[u], cap[u][v] - flow[u][v])\n                    if v != t:\n                        q.append(v)\n                    else:\n                        return (m[t], prev)\n        return (0, prev)\n\nH, W = list(map(int, input().split()))\nboard = [input() for _ in range(H)]\n\nEK = EDOMONDS_KARP(H + W + 2, 0, H + W + 1)\nfor h in range(H):\n    for w in range(W):\n        if board[h][w] == 'o':\n            EK.add_edge(h + 1, w + H + 1, 1)\n            EK.add_edge(w + H + 1, h + 1, 1)\n        if board[h][w] == 'S':\n            EK.add_edge(0, h + 1, float('inf'))\n            EK.add_edge(0, w + H + 1, float('inf'))\n        if board[h][w] == 'T':\n            EK.add_edge(h + 1, H + W + 1, float('inf'))\n            EK.add_edge(w + H + 1, H + W + 1, float('inf'))\n\nf, _ = EK.max_flow()\nprint((f if f < float('inf') else -1))\n", "import collections\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n    def add_edge(self, fr, to, cap):\n        self.g[fr].append([to, cap, len(self.g[to])])\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        self.g[v1].append([v2, cap1, len(self.g[v2])])\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\n    def bfs(self, s):\n        level = [-1]*self.n\n        deq = collections.deque()\n        level[s] = 0\n        deq.append(s)\n        while deq:\n            v = deq.popleft()\n            for e in self.g[v]:\n                if e[1]>0 and level[e[0]]<0:\n                    level[e[0]] = level[v] + 1\n                    deq.append(e[0])\n        self.level = level\n    def dfs(self, v, t, f):\n        if v==t: return f\n        es = self.g[v]\n        level = self.level\n        for i in range(self.it[v], len(self.g[v])):\n            e = es[i]\n            if e[1]>0 and level[v]<level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d\n                    self.g[e[0]][e[2]][1] += d\n                    self.it[v] = i\n                    return d\n        self.it[v] = len(self.g[v])\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0: break\n            self.it = [0]*self.n\n            while True:\n                f = self.dfs(s, t, 10**9+7)\n                if f>0:\n                    flow += f\n                else:\n                    break\n        return flow\nh, w = list(map(int, input().split()))\nA = [input() for i in range(h)]\ndinic = Dinic(h+w+2)\nstart = h+w; end = h+w+1\nINF = 10**9+7\nfor i in range(h):\n    for j in range(w):\n        c = A[i][j]\n        if c is 'o':\n            dinic.add_multi_edge(i, h + j, 1, 1)\n        elif c is 'S':\n            dinic.add_edge(start, i, INF)\n            dinic.add_edge(start, h + j, INF)\n        elif c is 'T':\n            dinic.add_edge(i, end, INF)\n            dinic.add_edge(h + j, end, INF)\nans = dinic.max_flow(start, end)\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)\n", "import itertools\nimport networkx as nx\nH, W = [int(_) for _ in input().split()]\nA = [input() for _ in range(H)]\n\ngraph = nx.DiGraph()\nfor h, w in itertools.product(list(range(H)), list(range(W))):\n    if A[h][w] == 'S':\n        s = (h, w)\n        graph.add_edge(s, (h, -1), capacity=10**10)\n        graph.add_edge(s, (-1, w), capacity=10**10)\n    elif A[h][w] == 'T':\n        t = (h, w)\n        graph.add_edge((h, -1), t, capacity=10**10)\n        graph.add_edge((-1, w), t, capacity=10**10)\n    elif A[h][w] == 'o':\n        graph.add_edge((h, -1), (-1, w), capacity=1)\n        graph.add_edge((-1, w), (h, -1), capacity=1)\nans = nx.minimum_cut_value(graph, s, t)\nprint((-1 if ans >= 10**10 else ans))\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    from collections import deque\n\n    class Dinic:\n        def __init__(self, N):\n            self.N = N\n            self.G = [[] for i in range(N)]\n\n        def add_edge(self, fr, to, cap):\n            forward = [to, cap, None]\n            forward[2] = backward = [fr, 0, forward]\n            self.G[fr].append(forward)\n            self.G[to].append(backward)\n\n        def add_multi_edge(self, v1, v2, cap1, cap2):\n            edge1 = [v2, cap1, None]\n            edge1[2] = edge2 = [v1, cap2, edge1]\n            self.G[v1].append(edge1)\n            self.G[v2].append(edge2)\n\n        def bfs(self, s, t):\n            self.level = level = [None] * self.N\n            deq = deque([s])\n            level[s] = 0\n            G = self.G\n            while deq:\n                v = deq.popleft()\n                lv = level[v] + 1\n                for w, cap, _ in G[v]:\n                    if cap and level[w] is None:\n                        level[w] = lv\n                        deq.append(w)\n            return level[t] is not None\n\n        def dfs(self, v, t, f):\n            if v == t:\n                return f\n            level = self.level\n            for e in self.it[v]:\n                w, cap, rev = e\n                if cap and level[v] < level[w]:\n                    d = self.dfs(w, t, min(f, cap))\n                    if d:\n                        e[1] -= d\n                        rev[1] += d\n                        return d\n            return 0\n\n        def flow(self, s, t):\n            flow = 0\n            INF = 10 ** 9 + 7\n            G = self.G\n            while self.bfs(s, t):\n                *self.it, = list(map(iter, self.G))\n                f = INF\n                while f:\n                    f = self.dfs(s, t, INF)\n                    flow += f\n            return flow\n\n    H, W = list(map(int, input().split()))\n    grid = []\n    for _ in range(H):\n        line = input().rstrip('\\n')\n        grid.append(line)\n\n    dinic = Dinic(H+W+5)\n    for h in range(H):\n        for w in range(W):\n            if grid[h][w] == 'o':\n                dinic.add_edge(h+1, H+w+1, 1)\n                dinic.add_edge(H+w+1, h+1, 1)\n            elif grid[h][w] == 'S':\n                dinic.add_edge(H+W+1, h+1, 10**5)\n                dinic.add_edge(H+W+1, H+w+1, 10**5)\n            elif grid[h][w] == 'T':\n                dinic.add_edge(h+1, H+W+2, 10**5)\n                dinic.add_edge(H+w+1, H+W+2, 10**5)\n\n    ans = dinic.flow(H+W+1, H+W+2)\n    if ans > 400:\n        print((-1))\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u89e3\u8aacAC\u3001\u8fba\u306e\u5f35\u308a\u65b9\u304c\u96e3\u3057\u3059\u304e\u308b\nfrom collections import deque\nINF = 1 << 23\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for _ in range(self.N)]\n\n    def add_edge(self, u, v, cap):\n        self.G[u].append([v, cap, len(self.G[v])])\n        self.G[v].append([u, 0, len(self.G[u])-1])\n\n    def bfs(self, s):\n        self.level = [-1] * self.N\n        que = deque([s])\n        self.level[s] = 0\n        while que:\n            u = que.popleft()\n            for (v, cap, _) in self.G[u]:\n                if cap > 0 and self.level[v] < 0:\n                    self.level[v] = self.level[u] + 1\n                    que.append(v)\n\n    def dfs(self, u, t, f):\n        if u == t:\n            return f\n        for i in range(self.progress[u], len(self.G[u])):\n            self.progress[u] = i\n            (v, cap, rev) = self.G[u][i]\n            if cap > 0 and self.level[u] < self.level[v]:\n                d = self.dfs(v, t, min(f, cap))\n                if d > 0:\n                    self.G[u][i][1] -= d\n                    self.G[v][rev][1] += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        INF = 10**9\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.progress = [0] * self.N\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\n\ndef main():\n    H, W = (int(i) for i in input().split())\n    A = [input() for i in range(H)]\n    F = Dinic(H+W+2)  # 0,1,...,W-1,0,..,H-1,s,t\n    s = H+W\n    t = H+W+1\n    Sh, Sw = -1, -1\n    Th, Tw = -1, -1\n    for h in range(H):\n        for w in range(W):\n            if A[h][w] == \"S\":\n                Sh, Sw = h, w\n                F.add_edge(s, h+W, INF)\n                F.add_edge(s, w, INF)\n            elif A[h][w] == \"T\":\n                Th, Tw = h, w\n                F.add_edge(h+W, t, INF)\n                F.add_edge(w, t, INF)\n            if A[h][w] != \".\":\n                F.add_edge(h+W, w, 1)\n                F.add_edge(w, h+W, 1)\n    if Sh == Th or Sw == Tw:\n        return print(-1)\n\n    print(F.max_flow(s, t))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Dinic:\n    def __init__(self,n,edges):\n        self.n=n\n        self.edges=[[] for _ in range(n)]\n        self.iter=[0]*n\n        self.level=None\n        self.graph(edges)\n    def graph(self,E):\n        edges=self.edges\n        for fr,to,cap in E:\n            edges[fr].append([to,cap,len(edges[to])])\n            edges[to].append([fr,0,len(edges[fr])-1])\n    def maxflow(self,source,sink):\n        max_flow=0\n        while True:\n            self.bfs(source)\n            if self.level[sink]<0:\n                return max_flow\n            self.iter=[0]*self.n\n            flow=self.dfs(source,sink,float('inf'))\n            while flow:\n                max_flow+=flow\n                flow=self.dfs(source,sink,float('inf'))\n    def bfs(self,source):\n        edges=self.edges\n        level=[-1]*self.n\n        level[source]=0\n        q=deque([source])\n        while q:\n            fr=q.popleft()\n            for to,cap,_ in edges[fr]:\n                if cap>0>level[to]:\n                    level[to]=level[fr]+1\n                    q.append(to)\n        self.level=level\n    def dfs(self,source,sink,flow):\n        if source==sink:\n            return flow\n        while self.iter[source]<len(self.edges[source]):\n            to,cap,rev=self.edges[source][self.iter[source]]\n            if cap>0 and self.level[source]<self.level[to]:\n                f=self.dfs(to,sink,min(flow,cap))\n                if f:\n                    self.edges[source][self.iter[source]][1]-=f\n                    self.edges[to][rev][1]+=f\n                    return f\n            self.iter[source]+=1\n        return 0\n\ninf=float('inf')\nh,w=map(int,input().split())\nEdges=[]\nfor x in range(h):\n    s=list(input())\n    for y in range(w):\n        if s[y]=='S':\n            Edges.append((0,x+1,inf))\n            Edges.append((0,y+1+h,inf))\n        elif s[y]=='T':\n            Edges.append((x+1,h+w+1,inf))\n            Edges.append((y+1+h,h+w+1,inf))\n        elif s[y]=='o':\n            Edges.append((x+1,y+1+h,1))\n            Edges.append((y+1+h,x+1,1))\ndinic=Dinic(h+w+2,Edges)\nmf=dinic.maxflow(0,h+w+1)\nprint(-1 if mf==inf else mf)", "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n#A\ndef A():\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    def bfs(s,g,n):\n        bfs_map = [-1 for i in range(n)]\n        bfs_map[s] = 0\n        q = deque()\n        q.append(s)\n        fin = False\n        while q:\n            x = q.popleft()\n            for y in range(n):\n                if c[x][y] > 0 and bfs_map[y] < 0:\n                    bfs_map[y] = bfs_map[x]+1\n                    if y == g:\n                        fin = True\n                        break\n                    q.append(y)\n            if fin:\n                break\n\n        if bfs_map[g] == -1:\n            return [None,0]\n        path = [None for i in range(bfs_map[g]+1)]\n        m = float(\"inf\")\n        path[bfs_map[g]] = g\n        y = g\n        for i in range(bfs_map[g])[::-1]:\n            for x in range(n+1):\n                if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                    path[i] = x\n                    if c[x][y] < m:\n                        m = c[x][y]\n                    y = x\n                    break\n        return [path,m]\n\n    def ford_fulkerson(s,g,c,n):\n        while 1:\n            p,m = bfs(s,g,n)\n            if not m:break\n            for i in range(len(p)-1):\n                c[p[i]][p[i+1]] -= m\n                c[p[i+1]][p[i]] += m\n        return sum(c[g])\n    h,w = LI()\n    a = SR(h)\n    c = [[0 for i in range(h+w+2)] for j in range(h+w+2)]\n    for y in range(h):\n        for x in range(w):\n            if a[y][x] == \"S\":\n                c[0][y+1] = float(\"inf\")\n                c[0][h+x+1] = float(\"inf\")\n            if a[y][x] == \"T\":\n                c[y+1][h+w+1] = float(\"inf\")\n                c[h+x+1][h+w+1] = float(\"inf\")\n            if a[y][x] == \"o\":\n                c[y+1][h+x+1] = 1\n                c[h+x+1][y+1] = 1\n    ans = ford_fulkerson(0,h+w+1,c,h+w+2)\n    if ans == float(\"inf\"):\n        print((-1))\n    else:\n        print(ans)\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\ndef __starting_point():\n    F()\n\n__starting_point()", "from scipy.sparse import*\nH,*S=open(0)\nH,W,*A=map(int,H.split())\nfor i in range(m:=H*W):A+=[m*2,h:=i//W,I:=m*3,m*2,w:=i%W+m,I]*((c:=S[h][w-m])=='S')+[h,I,I,w,I,I]*(c=='T')+[h,w,1,w,h,1]*(c>'T')\nprint([-1,f:=csgraph.maximum_flow(csr_matrix((A[2::3],(A[::3],A[1::3])),[I+1]*2),m*2,I).flow_value][f<I])", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]#(\u884c\u304d\u5148\u3001\u5bb9\u91cf\u3001\u9006\u8fba\u306e\u53c2\u7167)\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**10\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\ninf = 10**9\nH, W = list(map(int, input().split()))\na = [list(input()) for _ in range(H)]\nD = Dinic(H+W+2)\nfor i in range(H):\n    for j in range(W):\n        if a[i][j] == 'S':\n            D.add_edge(0, i+1, inf)\n            D.add_edge(0, j+1+H, inf)\n        elif a[i][j] == 'T':\n            D.add_edge(i+1, H+W+1, inf)\n            D.add_edge(j+1+H, H+W+1, inf)\n        elif a[i][j] == 'o':\n            D.add_edge(i+1, j+1+H, 1)\n            D.add_edge(j+1+H, i+1, 1)\nans = D.flow(0, H+W+1)\nprint((ans if ans<inf else -1))\n\n\n\n\n\n", "def main():\n    # \u884c\u5148\u3001\u4e0a\u9650\u3001\u9006\u8fba\n    def add_edge(From, to, cap):\n        g[From][to] = cap\n        g[to][-From-1] = 0\n\n    def max_flow(s, t):\n        def dfs():\n            while q:\n                v, t, f = q[-1]\n                if ans[0] == 0:\n                    if v == t:\n                        ans[0] = f\n                        continue\n                    used[v] += 1\n                    while True:\n                        i = used2[v]\n                        used2[v] += 1\n                        if i < len(gkey[v]):\n                            to = gkey[v][i]\n                            cap = g[v][to]\n                            if to < 0:\n                                to2 = -to-1\n                            else:\n                                to2 = to\n                            if used[to2] or cap == 0:\n                                continue\n                            q.append((to2, t, min(f, cap)))\n                            break\n                        else:\n                            q.pop()\n                            ans[0] = 0\n                            break\n                else:\n                    q.pop()\n                    if q:\n                        v, t, f = q[-1]\n                        i = used2[v]-1\n                        to = gkey[v][i]\n                        if to < 0:\n                            to2 = -to-1\n                        else:\n                            to2 = to\n                        g[v][to] -= ans[0]\n                        g[to2][-v-1] += ans[0]\n\n        flow = 0\n        while True:\n            used = [0]*n\n            used2 = [0]*n\n            q = [(s, t, 10**6)]\n            ans = [0]\n            dfs()\n            if not ans[0]:\n                return flow\n            flow += ans[0]\n\n    h, w = list(map(int, input().split()))\n    n = h+w+2\n    g = [dict() for _ in range(n)]\n    for i in range(h):\n        A = input()\n        for j in range(w):\n            if A[j] == \"o\":\n                add_edge(i, j+h, 1)\n                add_edge(j+h, i, 1)\n            elif A[j] == \"S\":\n                add_edge(h+w, i, 10**6)\n                add_edge(h+w, j+h, 10**6)\n            elif A[j] == \"T\":\n                add_edge(i, h+w+1, 10**6)\n                add_edge(j+h, h+w+1, 10**6)\n    gkey = [list(i.keys()) for i in g]\n\n    ans = max_flow(h+w, h+w+1)\n    if ans >= 10**6:\n        print((-1))\n    else:\n        print(ans)\n\n\nmain()\n", "# Dinic's algorithm\nfrom collections import deque\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\nh, w = list(map(int, input().split()))\ndinic = Dinic((h+1)*(w+1))\nmaze = [list(input()) for _ in range(h)]\nstart = 0\ngoal = 0\nINF = 10 ** 9 + 7\n\nfor i in range(h):\n    for j in range(w):\n        if maze[i][j] == '.':\n            continue\n        if maze[i][j] == 'S':\n            start = (i + 1) * (w + 1) + j + 1\n            dinic.add_edge(start, j + 1, INF)\n            dinic.add_edge(start, (i+1)*(w+1), INF)\n        elif maze[i][j] == 'T':\n            goal = (i + 1) * (w + 1) + j + 1\n            dinic.add_edge(j + 1, goal, INF)\n            dinic.add_edge((i+1)*(w+1), goal, INF)\n        dinic.add_multi_edge(j + 1, (i + 1) * (w + 1) + j + 1, 1, 1)\n        dinic.add_multi_edge((i+1)*(w+1), (i+1)*(w+1) + j+1, 1, 1)\nans = dinic.flow(start, goal)\nprint((ans if ans < 10**9 else -1))\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.level = None\n        self.it = None\n    \n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.graph[v1].append(edge1)\n        self.graph[v2].append(edge2)\n    \n    def bfs(self, s, t):\n        self.level = level = [-1] * self.n\n        deq = deque([s])\n        level[s] = 0\n        G = self.graph\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] == -1:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] != -1\n    \n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n    \n    def flow(self, s, t):\n        flow = 0\n        INF = 10 ** 18\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.graph))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\ndef solve():\n    H, W = list(map(int, rl().split()))\n    INF = 10 ** 18\n    s = H + W\n    t = s + 1\n    dinic = Dinic(t + 1)\n    for i in range(H):\n        line = input()\n        for j in range(W):\n            if line[j] == 'o':\n                dinic.add_multi_edge(i, H + j, 1, 1)\n            elif line[j] == 'S':\n                dinic.add_edge(s, i, INF)\n                dinic.add_edge(s, H + j, INF)\n            elif line[j] == 'T':\n                dinic.add_edge(i, t, INF)\n                dinic.add_edge(H + j, t, INF)\n    \n    ans = dinic.flow(s, t)\n    print((ans if ans < INF else -1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000)\ndef FF(E, s, t):\n    NN = H+W+2\n    G = [[] for _ in range(NN)]\n    for a, b, f in E:\n        G[a].append([b, f, len(G[b])])\n        G[b].append([a, 0, len(G[a])-1])\n    \n    def dfs(s, t, f):\n        if s == t:\n            return f\n        used[s] = 1\n        for i, (b, _f, r) in enumerate(G[s]):\n            if used[b] or _f == 0: continue\n            d = dfs(b, t, min(f, _f))\n            if d > 0:\n                G[s][i][1] -= d\n                G[b][r][1] += d\n                return d\n        return 0\n    \n    flow = 0\n    while 1:\n        used = [0] * NN\n        f = dfs(s, t, 10**100)\n        if f == 0:\n            return flow\n        flow += f\n\nE = []\n\nH, W = list(map(int, input().split()))\nfor i in range(H):\n    A = input()\n    for j in range(W):\n        if A[j] == \"o\":\n            E.append((i, j+H, 1))\n            E.append((j+H, i, 1))\n        elif A[j] == \"S\":\n            S = (i, j+H)\n        elif A[j] == \"T\":\n            T = (i, j+H)\nE.append((H+W, S[0], 10**6))\nE.append((H+W, S[1], 10**6))\nE.append((T[0], H+W+1, 10**6))\nE.append((T[1], H+W+1, 10**6))\n\nff = FF(E, H+W, H+W+1)\nprint((ff if ff < 10**6 else -1))\n", "from networkx import*\nH, W = map(int, input().split())\nX = [[a for a in input()] for _ in range(H)]\nG = Graph()\nG.add_nodes_from(range(-2, H + W))\nfor i in range(H):\n    for j in range(W):\n        if X[i][j] == \"o\":\n            G.add_edge(i, j + H, capacity = 1)\n        elif X[i][j] == \"S\":\n            si, sj = i, j\n        elif X[i][j] == \"T\":\n            ti, tj = i, j\n        \nG.add_edge(-1, si, capacity = 1 << 20)\nG.add_edge(-1, sj + H, capacity = 1 << 20)\nG.add_edge(-2, ti, capacity = 1 << 20)\nG.add_edge(-2, tj + H, capacity = 1 << 20)\n\nmf = maximum_flow(G, -1, -2)[0]\nprint(-1 if mf > 1 << 19 else mf)", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\n\nclass MaxFlow(object):\n    def __init__(self, n):\n        self.n = n\n        self.E = [[] for _ in range(n)]\n\n    def add_edge(self, u, v, cap):\n        e = [v, cap, 0]\n        rev = [u, 0, e]\n        e[-1] = rev\n        self.E[u].append(e)\n        self.E[v].append(rev)\n\n    def _bfs(self, s, t):\n        self._level = level = [-1] * self.n\n        level[s] = 0\n        queue = [s]\n        for v in queue:\n            for nv, cap, _ in self.E[v]:\n                if cap and level[nv] == -1:\n                    level[nv] = level[v] + 1\n                    if nv == t:\n                        return True\n                    queue.append(nv)\n        return level[t] != -1\n\n    def _dfs(self, s, t):\n        E, level, it = self.E, self._level, self._iter\n        stack = [(s, INF)]\n        while stack:\n            v, f = stack[-1]\n            if v == t:\n                for v, _ in stack[:-1]:\n                    E[v][it[v]][1] -= f\n                    E[v][it[v]][-1][1] += f\n                return f\n            while it[v] < len(E[v]):\n                nv, cap, _ = E[v][it[v]]\n                if cap and level[v] < level[nv]:\n                    stack.append((nv, min(f, cap)))\n                    break\n                it[v] += 1\n            else:\n                stack.pop()\n                level[v] = 0\n        return 0\n\n    def solve(self, s, t):\n        res = 0\n        while self._bfs(s, t):\n            self._iter = [0] * self.n\n            f = 1\n            while f:\n                f = self._dfs(s, t)\n                res += f\n        return res\n\nfrom itertools import product\ndef resolve():\n    m, n = map(int, input().split())\n    grid = [input() for _ in range(m)]\n    N = m + n\n    flow = MaxFlow(N + 2)\n\n    for i, j in product(range(m), range(n)):\n        if grid[i][j] == 'S':\n            flow.add_edge(i, j + m, INF)\n            flow.add_edge(j + m, i, INF)\n            flow.add_edge(N, i, INF)\n            flow.add_edge(N, j + m, INF)\n        elif grid[i][j] == 'T':\n            flow.add_edge(i, j + m, INF)\n            flow.add_edge(j + m, i, INF)\n            flow.add_edge(i, N + 1, INF)\n            flow.add_edge(j + m, N + 1, INF)\n        elif grid[i][j] != '.':\n            flow.add_edge(i, j + m, 1)\n            flow.add_edge(j + m, i, 1)\n\n    ans = flow.solve(N, N + 1)\n    if ans > 10 << 30:\n        ans = -1\n    print(ans)\nresolve()", "from collections import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\nclass Dinic():\n    def __init__(self, n, s, t):\n        self.n, self.s, self.t = n, s, t\n        self.to = defaultdict(list)\n        self.level = [-1]\n        self.max_flow = -1\n\n    def add_edge(self, u, v, cap):\n        u_index_in_to_v = len(self.to[v])\n        v_index_in_to_u = len(self.to[u])\n        self.to[u].append([v, cap, u_index_in_to_v])\n        self.to[v].append([u, 0, v_index_in_to_u])\n\n    # \u7121\u5411\u8fba\u306e\u8ffd\u52a0\n    def add_undir_edge(self, u, v, cap):\n        u_index_in_to_v = len(self.to[v])\n        v_index_in_to_u = len(self.to[u])\n        self.to[u].append([v, cap, u_index_in_to_v])\n        self.to[v].append([u, cap, v_index_in_to_u])\n\n    def set_level(self):\n        s = self.s\n        level = [-1] * self.n\n        level[s] = 0\n        q = deque()\n        q.append([s, 0])\n        while q:\n            u, u_level = q.popleft()\n            for v, cap, _ in self.to[u]:\n                if cap == 0: continue\n                if level[v] != -1: continue\n                level[v] = u_level + 1\n                if v == self.t:\n                    self.level = level\n                    return True\n                q.append([v, u_level + 1])\n        return False\n\n    def dfs(self, u=-1, flow_to_me=10 ** 16):\n        if u == -1: u = self.s\n        if u == self.t: return flow_to_me\n        flow_from_me = 0\n        u_level = self.level[u]\n        for utov_i, (v, cap, vtou_i) in enumerate(self.to[u]):\n            if self.level[v] != u_level + 1: continue\n            if cap == 0: continue\n            flow_to_v = self.dfs(v, min(cap, flow_to_me - flow_from_me))\n            if not flow_to_v: continue\n            flow_from_me += flow_to_v\n            self.to[u][utov_i][1] -= flow_to_v\n            self.to[v][vtou_i][1] += flow_to_v\n        return flow_from_me\n\n    def calculation(self):\n        res = 0\n        while self.set_level():\n            res += self.dfs()\n        return res\n\n    # \u3053\u308c\u304c\u51fa\u529b\u7528\n    def get_max_flow(self):\n        if self.max_flow == -1:\n            self.max_flow = self.calculation()\n        return self.max_flow\n\nh,w=MI()\naa=[input() for _ in range(h)]\n\ndef main():\n    inf=10**9+7\n    s=h+w\n    t=h+w+1\n    mc=Dinic(h+w+2,s,t)\n    si,sj,ti,tj=-1,-2,-3,-4\n    for i,row in enumerate(aa):\n        for j,a in enumerate(row):\n            if a==\"S\":\n                if i==ti or j==tj:\n                    print(-1)\n                    return\n                si,sj=i,j\n                mc.add_edge(s,i,inf)\n                mc.add_edge(s,j+h,inf)\n            elif a==\"T\":\n                if i==si or j==sj:\n                    print(-1)\n                    return\n                ti,tj=i,j\n                mc.add_edge(i,t,inf)\n                mc.add_edge(j+h,t,inf)\n            elif a==\"o\":\n                mc.add_undir_edge(i,j+h,1)\n    print(mc.get_max_flow())\n\nmain()", "from collections import deque\nfrom itertools import combinations\nclass Dinic:\n    def __init__(self, N):\n        self.N=N\n        self.G=[[]for _ in range(N)]\n    def add_edge(self,fr,to,cap):\n        forward=[to,cap,None]\n        forward[2]=backward=[fr,0,forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n    def add_multi_edge(self,v1,v2,cap1,cap2):\n        edge1=[v2,cap1,None]\n        edge1[2]=edge2=[v1,cap2,edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n    def bfs(self,s,t):\n        self.level=level=[None]*self.N\n        deq=deque([s])\n        level[s]=0\n        G=self.G\n        while deq:\n            v=deq.popleft()\n            lv=level[v]+1\n            for w,cap,_ in G[v]:\n                if cap and level[w]is None:\n                    level[w]=lv\n                    deq.append(w)\n        return level[t]is not None\n    def dfs(self,v,t,f):\n        if v==t:return f\n        level=self.level\n        for e in self.it[v]:\n            w,cap,rev=e\n            if cap and level[v]<level[w]:\n                d=self.dfs(w,t,min(f,cap))\n                if d:\n                    e[1]-=d\n                    rev[1]+=d\n                    return d\n        return 0\n    def flow(self,s,t):\n        flow=0\n        INF=10**9+7\n        G=self.G\n        while self.bfs(s,t):\n            *self.it,=map(iter,self.G)\n            f=INF\n            while f:\n                f=self.dfs(s,t,INF)\n                flow+=f\n        return flow\nINF=10**9+7\nt,*a=open(0)\nh,w=map(int,t.split())\nd=Dinic(h+w+3)\nadd=d.add_multi_edge\nfor i,s in enumerate(a,1):\n    for j,t in enumerate(s[:-1],h+1):\n        if t!='.':\n            if t=='S':\n                add(0,i,INF,INF)\n                add(0,j,INF,INF)\n            elif t=='T':\n                add(i,h+w+2,INF,INF)\n                add(j,h+w+2,INF,INF)\n            add(i,j,1,1)\na=d.flow(0,h+w+2)\nprint(-(a>=INF)or a)", "import collections\nclass Dinic:\n    def __init__(self, vnum):\n        self.edge = [[] for i in range(vnum)]\n        self.n = vnum\n        self.inf = float('inf')\n    def addedge(self, st, en, c):\n        self.edge[st].append([en, c, len(self.edge[en])])\n        self.edge[en].append([st, 0, len(self.edge[st])-1])\n    def bfs(self, vst):\n        dist = [-1]*self.n\n        dist[vst] = 0\n        Q = collections.deque([vst])\n        while Q:\n            nv = Q.popleft()\n            for vt, c, r in self.edge[nv]:\n                if dist[vt] == -1 and c > 0:\n                    dist[vt] = dist[nv] + 1\n                    Q.append(vt)\n        self.dist = dist\n    def dfs(self, nv, en, nf):\n        nextv = self.nextv\n        if nv == en:\n            return nf\n        dist = self.dist\n        ist = nextv[nv]\n        for i, (vt, c, r) in enumerate(self.edge[nv][ist:], ist):\n            if dist[nv] < dist[vt] and c > 0:\n                df = self.dfs(vt, en, min(nf, c))\n                if df > 0:\n                    self.edge[nv][i][1] -= df\n                    self.edge[vt][r][1] += df\n                    return df\n            nextv[nv] += 1\n        return 0\n    def getmf(self, st, en):\n        mf = 0\n        while True:\n            self.bfs(st)\n            if self.dist[en] == -1:\n                break\n            self.nextv = [0]*self.n\n            while True:\n                fl = self.dfs(st, en, self.inf)\n                if fl > 0:\n                    mf += fl\n                else:\n                    break\n        return mf\n\nH, W = map(int, input().split())\nG = [input() for _ in range(H)]\nT = Dinic(H+W)\ninf = 10**9+7\nSS = []\nfor i in range(H):\n    for j in range(W):\n        if G[i][j] == '.':\n            continue\n        if G[i][j] == 'o':\n            T.addedge(i, H+j, 1)\n            T.addedge(H+j, i, 1)\n            continue\n        SS.append(i)\n        SS.append(H + j)\n        T.addedge(i, H+j, inf)\n        T.addedge(H+j, i, inf)\nans = T.getmf(SS[0], SS[-1])\nif ans >= 10**9:\n    print(-1)\nelse:\n    print(ans)", "from collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nh , w = map(int,input().split())\na = [list(input()) for i in range(h)]\n\nsa = Dinic(h+w+2)\nINF = 10**9 + 7\ns = 0\nt = h+w+1\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] == \"S\":\n            sa.add_edge(s,i+1,INF)\n            sa.add_edge(s,h+1+j,INF)\n        if a[i][j] == \"T\":\n            sa.add_edge(i+1,t,INF)\n            sa.add_edge(h+1+j,t,INF)\n        if a[i][j] != \".\":\n            sa.add_edge(i+1,h+1+j,1)\n            sa.add_edge(h+1+j,i+1,1)\n\nif sa.flow(s,t) > h*w:\n    print(-1)\n    return\nprint(sa.flow(t,s))", "from collections import deque\nINF = 10**9\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.edge = [[] for _ in range(n)]\n        self.level = [None] * self.n \n        self.it = [None] * self.n \n\n    def add_edge(self, fr, to, cap):\n        # edge consists of [dest, cap, id of reverse edge]\n        forward = [to, cap, None]\n        backward = [fr, 0, forward]\n        forward[2] = backward\n        self.edge[fr].append(forward)\n        self.edge[to].append(backward)\n\n    def add_bidirect_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge2 = [v1, cap2, edge1]\n        edge1[2] = edge2\n        self.edge[v1].append(edge1)\n        self.edge[v2].append(edge2)\n\n    # takes start node and terminal node\n    # create new self.level, return you can flow more or not \n    def bfs(self, s, t):\n        self.level = [None] * self.n\n        dq = deque([s])\n        self.level[s] = 0\n        while dq:\n            v = dq.popleft()\n            lv = self.level[v] + 1\n            for dest, cap, _ in self.edge[v]: \n                if cap > 0 and self.level[dest] is None:\n                    self.level[dest] = lv\n                    dq.append(dest)\n        return self.level[t] is not None\n\n    # takes vertex, terminal, flow in vertex\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.it[v]:\n            to, cap, rev = e\n            if cap and self.level[v] < self.level[to]:\n                ret = self.dfs(to, t, min(f, cap))\n                # find flow\n                if ret:\n                    e[1] -= ret\n                    rev[1] += ret\n                    return ret\n        # no more flow\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while self.bfs(s, t):\n            for i in range(self.n):\n                self.it[i] = iter(self.edge[i])\n            # *self.it, = map(iter, self.edge)\n            f = INF\n            while f > 0:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN, M = [int(item) for item in input().split()]\nn = N + M + 2\ndinic = Dinic(n)\nfor i in range(N):\n    line = input().rstrip()\n    for j, ch in enumerate(line):\n        if ch == \".\":\n            pass\n        elif ch == \"o\":\n            v1 = i + 1\n            v2 = N + j + 1\n            dinic.add_bidirect_edge(v1, v2, 1, 1)\n        elif ch == \"S\":\n            v1 = i + 1\n            v2 = N + j + 1\n            dinic.add_edge(0, v1, INF)\n            dinic.add_edge(0, v2, INF)\n        elif ch == \"T\":\n            v1 = i + 1\n            v2 = N + j + 1\n            dinic.add_edge(v1, n-1, INF)\n            dinic.add_edge(v2, n-1, INF)\nans = dinic.flow(0, n-1)\nif ans >= INF:\n    print(-1)\nelse:\n    print(ans)", "def main():\n    # \u884c\u5148\u3001\u4e0a\u9650\u3001\u9006\u8fba\n    def add_edge(From, to, cap):\n        g[From][to] = cap\n        g[to][-From-1] = 0\n\n    def max_flow(s, t):\n        flow = 0\n        while True:\n            used = [False]*n\n            used2 = [0]*n\n            q = [(s, 10**6)]\n            ans = [0]\n            while q:\n                v, f = q[-1]\n                a = ans[0]\n                if a == 0:\n                    if v == t:\n                        ans[0] = f\n                        continue\n                    gkv, gv = gkey[v], g[v]\n                    l, used[v] = len(gkv), True\n                    while True:\n                        i = used2[v]\n                        used2[v] += 1\n                        if i < l:\n                            to = gkv[i]\n                            cap, to2 = gv[to], [to, -to-1][to < 0]\n                            if (not used[to2]) and cap:\n                                q.append((to2, min(f, cap)))\n                                break\n                        else:\n                            q.pop()\n                            ans[0] = 0\n                            break\n                else:\n                    q.pop()\n                    if q:\n                        v = q[-1][0]\n                        i = used2[v]-1\n                        to = gkey[v][i]\n                        g[v][to] -= a\n                        g[[to, -to-1][to < 0]][-v-1] += a\n            if not ans[0]:\n                return flow\n            flow += ans[0]\n\n    h, w = list(map(int, input().split()))\n    n = h+w+2\n    g = [dict() for _ in range(n)]\n    for i in range(h):\n        A = input()\n        for j in range(w):\n            if A[j] == \"o\":\n                add_edge(i, j+h, 1)\n                add_edge(j+h, i, 1)\n            elif A[j] == \"S\":\n                add_edge(h+w, i, 10**6)\n                add_edge(h+w, j+h, 10**6)\n            elif A[j] == \"T\":\n                add_edge(i, h+w+1, 10**6)\n                add_edge(j+h, h+w+1, 10**6)\n    gkey = [list(i.keys()) for i in g]\n\n    ans = max_flow(h+w, h+w+1)\n    if ans >= 10**6:\n        print((-1))\n    else:\n        print(ans)\n\n\nmain()\n", "import networkx as nx\n\nG = nx.Graph()\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\nG.add_nodes_from(range(h + w + 2))\n\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == \"S\":\n            s = h + w\n            G.add_edge(s, i)\n            G.add_edge(s, j + h)\n        elif grid[i][j] == \"T\":\n            t = h + w + 1\n            G.add_edge(i, t)\n            G.add_edge(j + h, t)\n        elif grid[i][j] == \"o\":\n            G.add_edge(i, j + h, capacity = 1)\n            G.add_edge(j + h, i, capacity = 1)\n\ntry:\n    ans, _ = nx.maximum_flow(G, s, t)\nexcept:\n    ans = -1\nprint(ans)", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nimport networkx as nx\ndef resolve():\n    m, n = map(int, input().split())\n    # source = -1, row = 0, ..., m - 1, col = m, ..., m + n - 1, terminartion = m + n\n    G = nx.Graph()\n    G.add_nodes_from(range(m + n + 2))\n    for i in range(m):\n        for j, c in enumerate(input()):\n            if c == '.':\n                continue\n            elif c == 'o':\n                G.add_edge(i, m + j, capacity = 1)\n            elif c == 'S':\n                G.add_edge(-1, i, capacity = INF)\n                G.add_edge(-1, m + j, capacity = INF)\n            elif c == 'T':\n                G.add_edge(i, m + n, capacity = INF)\n                G.add_edge(m + j, m + n, capacity = INF)\n\n    ans = nx.algorithms.flow.maximum_flow_value(G, -1, m + n)\n    if ans >= INF:\n        ans = -1\n    print(ans)\nresolve()", "from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\na=g.add_edges_from\nfor i in range(m:=H*W):a([[M:=m*2,h:=i//W],[M,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I),a([[h,w],[w,h]]*(c>'T'),capacity=1)\nprint([-1,f:=minimum_cut(g,M,I)[0]][f<I])", "# coding: utf-8\nimport queue\n\nclass Dinic:\n    \"\"\"Implementation of Dinic's Alogorithm\"\"\"\n\n    def __init__(self, v, inf = 1000000007):\n        self.V = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [0 for _ in range(v)]\n        self.iter = [0 for _ in range(v)]\n\n    def add_edge(self, from_, to, cap):\n        # to: \u884c\u304d\u5148, cap: \u5bb9\u91cf, rev: \u53cd\u5bfe\u5074\u306e\u8fba\n        self.G[from_].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\n        self.G[to].append({'to':from_, 'cap':0, 'rev':len(self.G[from_])-1})\n\n    # s\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u3092bfs\u3067\u8a08\u7b97\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.V)]\n        self.level[s] = 0;\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e['cap'] > 0 and self.level[e['to']] < 0:\n                    self.level[e['to']] = self.level[v] + 1\n                    que.put(e['to'])\n\n    # \u5897\u52a0\u30d0\u30b9\u3092dfs\u3067\u63a2\u3059\n    def dfs(self, v, t, f):\n        if v == t: return f\n        for i in range(self.iter[v], len(self.G[v])):\n            self.iter[v] = i\n            e = self.G[v][i]\n            if e['cap'] > 0 and self.level[v] < self.level[e['to']]:\n                d = self.dfs(e['to'], t, min(f, e['cap']))\n                if d > 0:\n                    e['cap'] -= d\n                    self.G[e['to']][e['rev']]['cap'] += d\n                    return d\n\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            # bfs\u3067\u5230\u9054\u4e0d\u53ef\n            if self.level[t] < 0 : return flow\n            self.iter = [0 for _ in range(self.V)]\n            f = self.dfs(s, t, self.inf)\n            while f > 0:\n                flow += f\n                f = self.dfs(s,t, self.inf)\n\ndef __starting_point():\n    H,W=list(map(int,input().split()))\n    a=[list(input()) for i in range(H)]\n    Dn=Dinic(2+H+W)\n    INF=10**15\n    #0,1~H,H+1~H+1+W.H+W+1\n    #0 1+range(H),H+1+range(W),H+W+1\n    s=(-1,-1)\n    t=(-1,-1)\n    for i in range(H):\n        for j in range(W):\n            if a[i][j]!=\".\":\n                Dn.add_edge(i+1,H+1+j,1)\n                Dn.add_edge(H+1+j,i+1,1)\n            if a[i][j]==\"S\":\n                Dn.add_edge(0,i+1,INF)\n                Dn.add_edge(0,H+1+j,INF)\n                s=(i,j)\n            if a[i][j]==\"T\":\n                Dn.add_edge(i+1,H+W+1,INF)\n                Dn.add_edge(H+1+j,H+W+1,INF)\n                t=(i,j)\n    if s[0]==t[0] or s[1]==t[1]:\n        print((-1))\n    else:\n        ans=Dn.max_flow(0,1+H+W)\n        print(ans)\n\n__starting_point()", "# \u6700\u5927\u6d41\n# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\nimport sys\nsys.setrecursionlimit(10**7)\nfrom collections import deque\nclass MaxFlow:\n  # n:\u9802\u70b9\u6570\n  def __init__(self,n):\n    self.n=n\n    self.g=[[] for i in range(n)]\n  \n  # \u8fba\u3092\u8ffd\u52a0\u3059\u308b\n  # fr:\u8fba\u306e\u59cb\u70b9\n  # to:\u8fba\u306e\u7d42\u70b9\n  # cap:\u8fba\u306e\u30ad\u30e3\u30d1\u30b7\u30c6\u30a3\n  def add_edge(self,fr,to,cap):\n    forward=[to,cap,None]\n    forward[2]=backward=[fr,0,forward]\n    # forward[2]=backward,backward[2]=forward\u3068\u306a\u308b\u3088\u3046\u306b\u518d\u5e30\u7684\u306bforward\u3068backward\u3092\u5b9a\u7fa9\n    self.g[fr].append(forward)\n    self.g[to].append(backward)\n    #print('add_edge',fr,to)\n\n  # s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u3092\u8fd4\u3059\u3002\u30d5\u30ed\u30fc\u3092\u6d41\u3059\u3054\u3068\u306bcap\u304c\u6e1b\u308a\u3001\u6700\u7d42\u7684\u306b\u901a\u308c\u308b\u8fba\u304c\u6e1b\u308a\u3001t\u307e\u3067\u8fbf\u308a\u7740\u3051\u306a\u304f\u306a\u308b\u3002\u305d\u308c\u307e\u3067\u30d5\u30ed\u30fc\u3092\u6d41\u3059\n  def bfs(self,s,t):\n    self.level=level=[None]*self.n\n    deq=deque([s])\n    level[s]=0\n    g=self.g\n    while deq:\n      v=deq.popleft()\n      nlv=level[v]+1\n      for nv,cap, _ in g[v]:\n        if cap and level[nv] is None:\n          level[nv]=nlv\n          deq.append(nv)\n    return level[t] is not None\n  # v->t\u306bf\u3092\u6d41\u3059\u3002\u518d\u5e30\u7684\u306b\u547c\u3073\u51fa\u3059\u3002v=t\u3068\u306a\u308b\u307e\u3067\u7d9a\u3051\u308b\u3002\n  # s\u304b\u3089\u9060\u3056\u304b\u308b\u3088\u3046\u306a\u30d1\u30b9\u3092\u898b\u3064\u3051\u3001\u30d5\u30ed\u30fc\u3092\u6d41\u3059\n  def dfs(self,v,t,f):\n    if v==t:\n      return f\n    level=self.level\n    # self.it[v]:\u9802\u70b9v\u304b\u3089\u4f38\u3073\u308b\u8fba\u3002\u4e00\u672c\u306e\u8fba\u306b\u3064\u3044\u3066\u7740\u76ee\u3059\u308b\u3068fordward\u3068backward\u304c\u4ea4\u4e92\u306b\u547c\u3073\u51fa\u3055\u308c\u308b\u3002\n    for e in self.it[v]:\n      nv,cap,rev=e\n      if cap and level[v]<level[nv]:\n        d=self.dfs(nv,t,min(f,cap))\n        if d:\n          e[1]-=d\n          rev[1]+=d\n          return d\n    return 0\n\n  # s\u304b\u3089t\u3078\u306e\u6700\u5927\u30d5\u30ed\u30fc\u3092\u8fd4\u3059\u3002\n  # \u4ee5\u4e0b\u306e\u51e6\u7406\u3092\u30d5\u30ed\u30fc\u3092\u6d41\u3057\u304d\u308b\u307e\u3067\u7e70\u308a\u8fd4\u3059\u3002\n  # BFS\u3067source\u304b\u3089\u5404\u9802\u70b9\u307e\u3067\u306e\u8ddd\u96e2(level)\u3092\u8a08\u7b97\n  # DFS\u3067source\u304b\u3089\u306e\u8ddd\u96e2\u304c\u9060\u304f\u306a\u308b\u3088\u3046\u306a\u30d1\u30b9\u3092\u898b\u3064\u3051\u3001\u30d5\u30ed\u30fc\u3092\u6d41\u3059\n  def flow(self,s,t):\n    flow=0\n    INF=10**9+7\n    g=self.g\n    # s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\u3002s\u304b\u3089t\u3078\u8fbf\u308a\u7740\u3051\u306a\u3044\u5834\u5408\u3001\u7d42\u4e86\u3002\u8ddd\u96e2\u306fself.level\u306b\u4fdd\u5b58\u3055\u308c\u308b\u3002\n    while self.bfs(s,t):\n      # \u30b0\u30e9\u30d5\u306e\u5404\u8981\u7d20\u3092\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5909\u63db\u3082\u306e\u3092self.it\u306b\u5165\u308c\u308b\u3002????\n      *self.it,=list(map(iter,self.g))\n      f=INF\n      while f:\n        # s->t\u306b\u30d5\u30ed\u30fc\u3092\u6d41\u3059\u3002\u6d41\u305b\u305f\u91cf\u3092flow\u306b\u52a0\u7b97\u3002\u6d41\u305b\u308b\u91cf\u304c\u3042\u308b\u307e\u3067\u7d9a\u3051\u308b\u3002\n        f=self.dfs(s,t,INF)\n        flow+=f\n    return flow\n\n\ndef main2(h,w,mat):\n  ss=-1,-1\n  tt=-1,-1\n  n=h+w+2\n  g=[[] for _ in range(n)]\n  ary=[]\n  inf=10**18\n  for i in range(h):\n    for j in range(w):\n      if  mat[i][j]=='o':\n        ary.append([i,h+j,1])\n        ary.append([h+j,i,1])\n      elif mat[i][j]=='S':\n        ary.append([h+w,i,inf])\n        ary.append([i,h+w,inf])\n        ary.append([h+w,h+j,inf])\n        ary.append([h+j,h+w,inf])\n        ss=i,j\n      elif mat[i][j]=='T':\n        ary.append([h+w+1,i,inf])\n        ary.append([i,h+w+1,inf])\n        ary.append([h+w+1,h+j,inf])\n        ary.append([h+j,h+w+1,inf])\n        tt=i,j\n  if ss[0]==tt[0] or ss[1]==tt[1]:return -1\n  mf=MaxFlow(n)\n  for i,j,c in ary:\n    mf.add_edge(i,j,c)\n  ret=mf.flow(h+w,h+w+1)\n  return ret\n\ndef __starting_point():\n  h,w=list(map(int,input().split()))\n  mat=[list(input()) for _ in range(h)]\n  ret2=main2(h,w,[x.copy() for x in mat])\n  print(ret2)\n\n__starting_point()", "from collections import deque\nfrom itertools import combinations\nclass Dinic:\n    def __init__(self, N):\n        self.N=N\n        self.G=[[]for _ in range(N)]\n    def add_edge(self,fr,to,cap):\n        forward=[to,cap,None]\n        forward[2]=backward=[fr,0,forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n    def add_multi_edge(self,v1,v2,cap1,cap2):\n        edge1=[v2,cap1,None]\n        edge1[2]=edge2=[v1,cap2,edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n    def bfs(self,s,t):\n        self.level=level=[None]*self.N\n        deq=deque([s])\n        level[s]=0\n        G=self.G\n        while deq:\n            v=deq.popleft()\n            lv=level[v]+1\n            for w,cap,_ in G[v]:\n                if cap and level[w]is None:\n                    level[w]=lv\n                    deq.append(w)\n        return level[t]is not None\n    def dfs(self,v,t,f):\n        if v==t:return f\n        level=self.level\n        for e in self.it[v]:\n            w,cap,rev=e\n            if cap and level[v]<level[w]:\n                d=self.dfs(w,t,min(f,cap))\n                if d:\n                    e[1]-=d\n                    rev[1]+=d\n                    return d\n        return 0\n    def flow(self,s,t):\n        flow=0\n        INF=10**9+7\n        G=self.G\n        while self.bfs(s,t):\n            *self.it,=map(iter,self.G)\n            f=INF\n            while f:\n                f=self.dfs(s,t,INF)\n                flow+=f\n        return flow\nINF=10**9+7\nt,*a=open(0)\nh,w=map(int,t.split())\nd=Dinic(h+w+3)\nadd=d.add_multi_edge\nfor i,s in enumerate(a,1):\n    for j,t in enumerate(s[:-1],h+1):\n        if t!='.':\n            if t=='S':\n                add(0,i,INF,INF)\n                add(0,j,INF,INF)\n            elif t=='T':\n                add(i,h+w+2,INF,INF)\n                add(j,h+w+2,INF,INF)\n            add(i,j,1,1)\na=d.flow(0,h+w+2)\nprint(-(a>=INF)or a)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass Dinic:\n    \"\"\" \u6700\u5927\u6d41(Dinic) \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n \n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n \n    def bfs(self, s):\n        from collections import deque\n\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, _ in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n \n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n \n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    # \u5165\u529b\u304c\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u304b\u3069\u3046\u304b\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    # \u4f59\u767d\u306e\u6709\u7121\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nH, W = MAP()\ngrid = build_grid(H, W, '', str, space=0)\n\n# \u6700\u5927\u6d41\uff1a\u9802\u70b9\u306f\u5404\u884c\u5168\u4f53\u3001\u5404\u5217\u5168\u4f53\u3001\u59cb\u70b9\u3001\u7d42\u70b9\ndn = Dinic(H+W+2)\ns = H + W\nt = H + W + 1\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j] == 'o':\n            dn.add_link(i, H+j, 1)\n            dn.add_link(H+j, i, 1)\n        elif grid[i][j] == 'S':\n            dn.add_link(s, i, INF)\n            dn.add_link(s, H+j, INF)\n        elif grid[i][j] == 'T':\n            dn.add_link(i, t, INF)\n            dn.add_link(H+j, t, INF)\n\nans = dn.max_flow(s, t)\nif ans >= INF:\n    print((-1))\nelse:\n    print(ans)\n", "# coding: utf-8\nimport queue\n\nclass Dinic:\n    \"\"\"Implementation of Dinic's Alogorithm\"\"\"\n\n    def __init__(self, v, inf = 1000000007):\n        self.V = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [0 for _ in range(v)]\n        self.iter = [0 for _ in range(v)]\n\n    def add_edge(self, from_, to, cap):\n        # to: \u884c\u304d\u5148, cap: \u5bb9\u91cf, rev: \u53cd\u5bfe\u5074\u306e\u8fba\n        self.G[from_].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\n        self.G[to].append({'to':from_, 'cap':0, 'rev':len(self.G[from_])-1})\n\n    # s\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u3092bfs\u3067\u8a08\u7b97\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.V)]\n        self.level[s] = 0;\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e['cap'] > 0 and self.level[e['to']] < 0:\n                    self.level[e['to']] = self.level[v] + 1\n                    que.put(e['to'])\n\n    # \u5897\u52a0\u30d0\u30b9\u3092dfs\u3067\u63a2\u3059\n    def dfs(self, v, t, f):\n        if v == t: return f\n        for i in range(self.iter[v], len(self.G[v])):\n            self.iter[v] = i\n            e = self.G[v][i]\n            if e['cap'] > 0 and self.level[v] < self.level[e['to']]:\n                d = self.dfs(e['to'], t, min(f, e['cap']))\n                if d > 0:\n                    e['cap'] -= d\n                    self.G[e['to']][e['rev']]['cap'] += d\n                    return d\n\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            # bfs\u3067\u5230\u9054\u4e0d\u53ef\n            if self.level[t] < 0 : return flow\n            self.iter = [0 for _ in range(self.V)]\n            f = self.dfs(s, t, self.inf)\n            while f > 0:\n                flow += f\n                f = self.dfs(s,t, self.inf)\n\ndef __starting_point():\n    H,W=list(map(int,input().split()))\n    a=[list(input()) for i in range(H)]\n    Dn=Dinic(2+H+W)\n    INF=10**15\n    #0,1~H,H+1~H+1+W.H+W+1\n    #0 1+range(H),H+1+range(W),H+W+1\n    s=(-1,-1)\n    t=(-1,-1)\n    for i in range(H):\n        for j in range(W):\n            if a[i][j]!=\".\":\n                Dn.add_edge(i+1,H+1+j,1)\n                Dn.add_edge(H+1+j,i+1,1)\n            if a[i][j]==\"S\":\n                Dn.add_edge(0,i+1,INF)\n                Dn.add_edge(0,H+1+j,INF)\n                s=(i,j)\n            if a[i][j]==\"T\":\n                Dn.add_edge(i+1,H+W+1,INF)\n                Dn.add_edge(H+1+j,H+W+1,INF)\n                t=(i,j)\n    if s[0]==t[0] or s[1]==t[1]:\n        print((-1))\n    else:\n        ans=Dn.max_flow(0,1+H+W)\n        print(ans)\n\n__starting_point()", "import sys#if RE->suspect recursion limit error\nfrom collections import deque\nsys.setrecursionlimit(10000)\n\nclass Dinic:\n    \"\"\"max-flow-min-cut\n    faster than ford-fulkerson algorithm\n    O(|V||E|)\n    \"\"\"\n\n    def __init__(self,V:int):\n        \"\"\"\n        Arguments:\n            V:num of vertex\n            adj:adjedscent list(adj[from]=(to,capacity,id))\n        \"\"\"\n        self.V = V\n        self.adj=[[] for _ in range(V)]\n        self.level=[-1]*self.V\n        self.iter=[-1]*self.V\n\n    def add_edge(self,fro:int,to:int,cap:int):\n        \"\"\"\n        Arguments:\n            fro:from\n            to: to\n            cap: capacity of the edge\n            f: max flow value\n        \"\"\"\n        #edge\n        self.adj[fro].append([to,cap,len(self.adj[to])])\n        #rev edge\n        self.adj[to].append([fro,0,len(self.adj[fro])-1])\n\n    def bfs(self,s:int):\n        \"\"\" bfs from s\n        use deque to bfs\n        \"\"\"\n        self.level=[-1]*self.V\n        Q=deque()\n        self.level[s]=0\n        Q.append(s)\n\n        while Q:\n            v = Q.pop()\n            for i in range(len(self.adj[v])):\n                (nex_id,nex_cap,nex_rev) = self.adj[v][i]\n                if nex_cap>0 and self.level[nex_id]<-0:\n                    self.level[nex_id] = self.level[v]+1\n                    Q.append(nex_id)\n\n\n    def dfs(self,v,t,f):\n\n        \"\"\"\n        search increasing path\n        \"\"\"\n        if v==t:\n            return f\n\n        for i in range(self.iter[v],len(self.adj[v])):\n            self.iter[v]=i\n            (nex_id,nex_cap,nex_rev) = self.adj[v][i]\n            if nex_cap>0 and self.level[v]<self.level[nex_id]:\n                d = self.dfs(nex_id,t,min(f,nex_cap))\n                if d>0:\n                    #decrease capacity to denote use it with d flow\n                    self.adj[v][i][1]-=d\n                    self.adj[nex_id][nex_rev][1]+=d\n                    return d\n        return 0\n\n    def max_flow(self,s:int,t:int):\n        \"\"\"calculate maxflow from s to t\n        \"\"\"\n        flow=0\n        self.used = [False]*self.V\n        #while no increasing path is found\n        while True:\n            self.bfs(s)\n            self.iter=[0]*self.V\n            f = self.dfs(s,t,float(\"inf\"))\n            if f==0:\n                return flow\n            else:\n                flow+=f\n\nH,W = list(map(int,input().split()))\ngrid=[[v for v in input()] for _ in range(H)]\n\nF = Dinic(H+W+2)\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j]==\"S\":\n            sy,sx = i,j\n            F.add_edge(0,i+1,float(\"inf\"))\n            F.add_edge(0,H+j+1,float(\"inf\"))\n        elif grid[i][j]==\"T\":\n            gy,gx=i,j\n            F.add_edge(i+1,H+W+1,float(\"inf\"))\n            F.add_edge(H+j+1,H+W+1,float(\"inf\"))\n        elif grid[i][j]==\"o\":\n            F.add_edge(i+1,H+j+1,1)\n            F.add_edge(H+j+1,i+1,1)\n\nif sy==gy or sx==gx:\n    print((-1))\n    return\nprint((F.max_flow(0,H+W+1)))\n", "# \u89e3\u8aacAC\u3001\u8fba\u306e\u5f35\u308a\u65b9\u304c\u96e3\u3057\u3059\u304e\u308b\nfrom collections import deque\nINF = 1 << 23\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for _ in range(self.N)]\n\n    def add_edge(self, u, v, cap):\n        self.G[u].append([v, cap, len(self.G[v])])\n        self.G[v].append([u, 0, len(self.G[u])-1])\n\n    def bfs(self, s):\n        self.level = [-1] * self.N\n        que = deque([s])\n        self.level[s] = 0\n        while que:\n            u = que.popleft()\n            for (v, cap, _) in self.G[u]:\n                if cap > 0 and self.level[v] < 0:\n                    self.level[v] = self.level[u] + 1\n                    que.append(v)\n\n    def dfs(self, u, t, f):\n        if u == t:\n            return f\n        for i in range(self.progress[u], len(self.G[u])):\n            self.progress[u] = i\n            (v, cap, rev) = self.G[u][i]\n            if cap > 0 and self.level[u] < self.level[v]:\n                d = self.dfs(v, t, min(f, cap))\n                if d > 0:\n                    self.G[u][i][1] -= d\n                    self.G[v][rev][1] += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        INF = 10**9\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.progress = [0] * self.N\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\n\ndef main():\n    H, W = (int(i) for i in input().split())\n    A = [input() for i in range(H)]\n    F = Dinic(H+W+2)  # 0,1,...,W-1,0,..,H-1,s,t\n    s = H+W\n    t = H+W+1\n    for h in range(H):\n        for w in range(W):\n            if A[h][w] == \"S\":\n                F.add_edge(s, h+W, INF)\n                F.add_edge(s, w, INF)\n            elif A[h][w] == \"T\":\n                F.add_edge(h+W, t, INF)\n                F.add_edge(w, t, INF)\n            if A[h][w] != \".\":\n                F.add_edge(h+W, w, 1)\n                F.add_edge(w, h+W, 1)\n\n    ans = F.max_flow(s, t)\n    if INF <= ans:\n        print((-1))\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000)\ndef FF(E, s, t):\n    NN = H+W+2\n    G = [[] for _ in range(NN)]\n    for a, b, f in E:\n        G[a].append([b, f, len(G[b])])\n        G[b].append([a, 0, len(G[a])-1])\n    \n    def dfs(s, t, f):\n        if s == t:\n            return f\n        used[s] = 1\n        for i, (b, _f, r) in enumerate(G[s]):\n            if used[b] or _f == 0: continue\n            d = dfs(b, t, min(f, _f))\n            if d > 0:\n                G[s][i][1] -= d\n                G[b][r][1] += d\n                return d\n        return 0\n    \n    flow = 0\n    while 1:\n        used = [0] * NN\n        f = dfs(s, t, 10**100)\n        if f == 0:\n            return flow\n        flow += f\n\nE = []\n\nH, W = list(map(int, input().split()))\nfor i in range(H):\n    A = input()\n    for j in range(W):\n        if A[j] == \"o\":\n            E.append((i, j+H, 1))\n            E.append((j+H, i, 1))\n        elif A[j] == \"S\":\n            S = (i, j+H)\n        elif A[j] == \"T\":\n            T = (i, j+H)\nE.append((H+W, S[0], 10**6))\nE.append((H+W, S[1], 10**6))\nE.append((T[0], H+W+1, 10**6))\nE.append((T[1], H+W+1, 10**6))\n\nff = FF(E, H+W, H+W+1)\nprint((ff if ff < 10**6 else -1))\n", "def main():\n    # \u884c\u5148\u3001\u4e0a\u9650\u3001\u9006\u8fba\n    def add_edge(From, to, cap):\n        g[From][to] = cap\n        g[to][-From-1] = 0\n\n    def max_flow(s, t):\n        flow = 0\n        while True:\n            used = [False]*n\n            used2 = [0]*n\n            q = [(s, 10**6)]\n            ans = [0]\n            while q:\n                v, f = q[-1]\n                a = ans[0]\n                if a == 0:\n                    if v == t:\n                        ans[0] = f\n                        continue\n                    gkv, gv = gkey[v], g[v]\n                    l, used[v] = len(gkv), True\n                    while True:\n                        i = used2[v]\n                        used2[v] += 1\n                        if i < l:\n                            to = gkv[i]\n                            cap, to2 = gv[to], [to, -to-1][to < 0]\n                            if (not used[to2]) and cap:\n                                q.append((to2, min(f, cap)))\n                                break\n                        else:\n                            q.pop()\n                            ans[0] = 0\n                            break\n                else:\n                    q.pop()\n                    if q:\n                        v = q[-1][0]\n                        i = used2[v]-1\n                        to = gkey[v][i]\n                        g[v][to] -= a\n                        g[[to, -to-1][to < 0]][-v-1] += a\n            if not ans[0]:\n                return flow\n            flow += ans[0]\n\n    h, w = list(map(int, input().split()))\n    n = h+w+2\n    g = [dict() for _ in range(n)]\n    for i in range(h):\n        A = input()\n        for j in range(w):\n            if A[j] == \"o\":\n                add_edge(i, j+h, 1)\n                add_edge(j+h, i, 1)\n            elif A[j] == \"S\":\n                add_edge(h+w, i, 10**6)\n                add_edge(h+w, j+h, 10**6)\n            elif A[j] == \"T\":\n                add_edge(i, h+w+1, 10**6)\n                add_edge(j+h, h+w+1, 10**6)\n    gkey = [list(i.keys()) for i in g]\n\n    ans = max_flow(h+w, h+w+1)\n    if ans >= 10**6:\n        print((-1))\n    else:\n        print(ans)\n\n\nmain()\n", "# AOJ GRL_6_A \"Maximum Flow\"\n# Ford-Fulkerson method\n\nimport sys\ninput = sys.stdin.readline\n\nINF = 10**18\n\nH, W = map(int, input().split())\nV = H+W\n\n\ndef make():\n    state = [list(input().rstrip()) for _ in range(H)]\n    graph = [{} for _ in range(V+2)]\n\n    start = V\n    finish = V+1\n\n    for h in range(H):\n        for w in range(W):\n            u, v = h, w+H\n            if state[h][w] == \"o\":\n                graph[u][v] = 1\n                graph[v][u] = 1\n            if state[h][w] == \"S\":\n                graph[v][start] = INF\n                graph[start][v] = INF\n                graph[u][start] = INF\n                graph[start][u] = INF\n            if state[h][w] == \"T\":\n                graph[u][finish] = INF\n                graph[finish][u] = INF\n                graph[v][finish] = INF\n                graph[finish][v] = INF\n    \n    return graph, start, finish\n\n\ndef dfs2(start, finish, graph):\n    Flow = [INF]*len(graph)\n    used = [False]*len(graph)\n    Par = [-1]*len(graph)\n    stack = [start]\n    used[start] = True\n    while stack:\n        v = stack.pop()\n        if v == finish:\n            d = Flow[v]\n            while v != start:\n                nv = Par[v]\n                graph[nv][v] -= d\n                graph[v][nv] += d\n                v = nv\n            return d, graph\n        for i, (nv, ncap) in enumerate(graph[v].items()):\n            if not used[nv] and ncap > 0:\n                used[nv] = True\n                stack.append(nv)\n                Par[nv] = v\n                Flow[nv] = min(Flow[v], ncap)\n    return 0, graph\n\n# solve\ndef max_flow(start, finish, graph):\n    flow = 0\n    while True:\n        f, graph = dfs2(start, finish, graph)\n        if f == 0: return flow\n        flow += f\n\n\ndef main():\n    graph, start, finish = make()\n    ans = max_flow(start, finish, graph)\n\n    if ans > INF//2:\n        print(-1)\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse.csgraph import dijkstra\n\nH,W = map(int,input().split())\n\n# start = 0\n# rows = 1,2,...,H\n# cols = H+1,...,H+W\n# goal = H+W+1\n\nINF = 10 ** 9\nstart = 0\ngoal = H+W+1\nV = H+W+2\ngraph = [[0] * V for _ in range(V)]\nedges = [] # \u96a3\u63a5\u30ea\u30b9\u30c8\nfor i in range(H):\n    row = input()\n    for j,cell in enumerate(row):\n        if cell == 'o':\n            graph[1+i][1+H+j] = 1\n            graph[1+H+j][1+i] = 1\n    s = row.find('S')\n    t = row.find('T')\n    if s != -1:\n        graph[start][1+i] = INF\n        graph[start][1+H+s] = INF\n    if t != -1:\n        graph[1+i][goal] = INF\n        graph[1+H+t][goal] = INF\n\n# \u3042\u3068\u306f max flow \u3092\u6c42\u3081\u308c\u3070\u3088\u3044\n\ndef max_flow(graph):\n    f = 0\n    while True:\n        if f > 200:\n            return -1\n        dist,pred = dijkstra(graph, indices = start, unweighted = True, return_predecessors = True)\n        if dist[goal] > INF:\n            return f\n        f += 1\n        after = goal\n        while after != start:\n            before = pred[after]\n            graph[before][after] -= 1\n            graph[after][before] += 1\n            after = before\n\nanswer = max_flow(graph)\nprint(answer)", "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n: int):\n        self.INF = 10**9 + 7\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n \n    def add_edge(self, _from: int, to: int, capacity: int):\n        \"\"\"\u6b8b\u4f59\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\n        1. _from\u304b\u3089to\u3078\u5411\u304b\u3046\u5bb9\u91cfcapacity\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        2. to\u304b\u3089_from\u3078\u5411\u304b\u3046\u5bb9\u91cf0\u306e\u8fba\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b\n        \"\"\"\n        forward = [to, capacity, None]\n        forward[2] = backward = [_from, 0, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n \n    def bfs(self, s: int, t: int):\n        \"\"\"capacity\u304c\u6b63\u306e\u8fba\u306e\u307f\u3092\u901a\u3063\u3066s\u304b\u3089t\u306b\u79fb\u52d5\u53ef\u80fd\u304b\u3069\u3046\u304bBFS\u3067\u63a2\u7d22\n        level: s\u304b\u3089\u306e\u6700\u77ed\u8def\u306e\u9577\u3055\n        \"\"\"\n        self.level = [-1] * self.n\n        q = deque([s])\n        self.level[s] = 0\n        while q:\n            _from = q.popleft()\n            for to, capacity, _ in self.graph[_from]:\n                if capacity > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[_from] + 1\n                    q.append(to)\n \n    def dfs(self, _from: int, t: int, f: int) -> int:\n        \"\"\"\u6d41\u91cf\u304c\u5897\u52a0\u3059\u308b\u30d1\u30b9\u3092DFS\u3067\u63a2\u7d22\n        BFS\u306b\u3088\u3063\u3066\u4f5c\u3089\u308c\u305f\u6700\u77ed\u8def\u306b\u5f93\u3063\u3066f\u3092\u66f4\u65b0\u3059\u308b\n        \"\"\"\n        if _from == t:\n            return f\n        for edge in self.itr[_from]:\n            to, capacity, reverse_edge = edge\n            if capacity > 0 and self.level[_from] < self.level[to]:\n                d = self.dfs(to, t, min(f, capacity))\n                if d > 0:\n                    edge[1] -= d\n                    reverse_edge[1] += d\n                    return d\n        return 0\n \n    def max_flow(self, s: int, t: int):\n        \"\"\"s-t\u30d1\u30b9\u4e0a\u306e\u6700\u5927\u6d41\u3092\u6c42\u3081\u308b\n        \u8a08\u7b97\u91cf: O(|E||V|^2)\n        \"\"\"\n        flow = 0\n        while True:\n            self.bfs(s, t)\n            if self.level[t] < 0:\n                break\n            self.itr = list(map(iter, self.graph))\n            f = self.dfs(s, t, self.INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, self.INF)\n        return flow\n\n\nh, w = map(int, input().split())\na = [list(input()) for i in range(h)]\n\ndi = Dinic(h + w + 2)\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] == \"o\":\n            di.add_edge(i, h + j, 1)\n            di.add_edge(h + j, i, 1)\n        if a[i][j] == \"S\":\n            di.add_edge(h + w, i, 10 ** 5)\n            di.add_edge(h + w, h + j, 10 ** 5)\n        if a[i][j] == \"T\":\n            di.add_edge(i, h + w + 1, 10 ** 5)\n            di.add_edge(h + j, h + w + 1, 10 ** 5)\n\nans = di.max_flow(h + w, h + w + 1)\nif ans >= 10 ** 5:\n    print(-1)\nelse:\n    print(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nh,w = list(map(int, input().split()))\ndata= []\nrs = []\ncs = []\nfor i in range(h):\n    c = input()\n    if \"S\" in c:\n        start = (i, c.index(\"S\"))\n    if \"T\" in c:\n        goal = (i, c.index(\"T\"))\n    for j in range(w):\n        if c[j] in (\"o\"):#, \"S\", \"T\"):\n            data.append(1)\n            rs.append(i)\n            cs.append(h+j)\n            data.append(1)\n            rs.append(h+j)\n            cs.append(i)\ns = h+w\nt = h+w+1\nV = 10**9\ndata.append(V)\nrs.append(s)\ncs.append(start[0])\ndata.append(V)\nrs.append(start[0])\ncs.append(s)\n\ndata.append(V)\nrs.append(s)\ncs.append(start[1]+h)\ndata.append(V)\nrs.append(start[1]+h)\ncs.append(s)\n\ndata.append(V)\nrs.append(goal[0])\ncs.append(t)\ndata.append(V)\nrs.append(t)\ncs.append(goal[0])\n\ndata.append(V)\nrs.append(t)\ncs.append(goal[1]+h)\ndata.append(V)\nrs.append(goal[1]+h)\ncs.append(t)\n\nimport scipy.sparse\nm = scipy.sparse.csr_matrix((data, (rs, cs)), shape=(h+w+2,h+w+2))\nval = scipy.sparse.csgraph.maximum_flow(m, s, t).flow_value\nif val>=10**9:\n    val = -1\nprint(val)", "import itertools\nimport os\nimport sys\nfrom collections import deque, defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nH, W = list(map(int, sys.stdin.readline().split()))\ntable = [list(sys.stdin.readline().rstrip()) for _ in range(H)]\n\nS = H + W\nT = H + W + 1\ngraph = [[] for _ in range(H + W + 2)]\nfor h, w in itertools.product(list(range(H)), list(range(W))):\n    if table[h][w] == '.':\n        continue\n    if table[h][w] == 'S':\n        graph[S].append((h, IINF))\n        graph[S].append((H + w, IINF))\n    elif table[h][w] == 'T':\n        graph[h].append((T, IINF))\n        graph[H + w].append((T, IINF))\n    graph[h].append((H + w, 1))\n    graph[H + w].append((h, 1))\n\n\nclass Dinic:\n    def __init__(self, graph=None, residual=None):\n        \"\"\"\n        :param list of (list of (int, int)) graph: (to, cap) \u306e\u96a3\u63a5\u30ea\u30b9\u30c8\n        :param list of (list of (list of (int|list))) residual: (to, cap, rev) \u306e\u6b8b\u4f59\u30b0\u30e9\u30d5\n        \"\"\"\n        assert (graph and not residual) or (not graph and residual)\n        if graph:\n            self.graph = self.residual_graph(graph)\n        else:\n            self.graph = residual\n\n    @staticmethod\n    def residual_graph(graph):\n        \"\"\"\n        \u6b8b\u4f59\u30b0\u30e9\u30d5\u69cb\u7bc9\n        :param list of (list of (int, int)) graph: (to, cap) \u306e\u96a3\u63a5\u30ea\u30b9\u30c8\n        :rtype: list of (list of (list of (int|list)))\n        :return: (to, cap, rev) \u306e\u6b8b\u4f59\u30b0\u30e9\u30d5\n        \"\"\"\n        ret = [[] for _ in range(len(graph))]\n        for v in range(len(graph)):\n            for u, cap in graph[v]:\n                rev = [v, 0]\n                edge = [u, cap, rev]\n                rev.append(edge)\n                ret[v].append(edge)\n                ret[u].append(rev)\n        return ret\n\n    def _dist(self, s):\n        \"\"\"\n        :param int s:\n        :rtype: list of int\n        :return: s \u304b\u3089\u306e\u8ddd\u96e2\u3002\u6b8b\u4f59\u30b0\u30e9\u30d5\u4e0a\u3067\u5230\u9054\u3067\u304d\u306a\u3044\u5834\u5408\u306f -1\n        \"\"\"\n        ret = [-1] * len(self.graph)\n        ret[s] = 0\n        que = deque([(s, 0)])\n        while que:\n            v, d = que.popleft()\n            for u, cap, _ in self.graph[v]:\n                if ret[u] < 0 < cap:\n                    ret[u] = d + 1\n                    que.append((u, d + 1))\n        return ret\n\n    def _dfs(self, s, t, dist, iter, flow=float('inf')):\n        \"\"\"\n        :param int s:\n        :param int t:\n        :param list of int dist:\n        :param list of int iter:\n        :param int flow:\n        \"\"\"\n        if s == t:\n            return flow\n        while iter[s] < len(self.graph[s]):\n            edge = self.graph[s][iter[s]]\n            to, cap, rev = edge\n            if dist[s] < dist[to] and cap > 0:\n                f = self._dfs(to, t, dist, iter, min(flow, cap))\n                if f > 0:\n                    edge[1] -= f\n                    rev[1] += f\n                    return f\n            iter[s] += 1\n        return 0\n\n    def maximum_flow(self, from_v, to_v):\n        \"\"\"\n        :param int from_v:\n        :param int to_v:\n        :return: from_v \u304b\u3089 to_v \u3078\u306e\u6700\u5927\u6d41\n        \"\"\"\n        ret = 0\n        while True:\n            dist = self._dist(from_v)\n            if dist[to_v] < 0:\n                break\n            iter = [0] * len(self.graph)\n            while True:\n                flow = self._dfs(from_v, to_v, dist, iter)\n                if flow == 0:\n                    break\n                ret += flow\n        return ret\n\n\nmf = Dinic(graph=graph).maximum_flow(S, T)\nif mf >= IINF:\n    print((-1))\nelse:\n    print(mf)\n", "from collections import deque\n\n\nclass MaxFlow:\n    \"\"\"\n    Example.\n\n    mf = MaxFlow(N)\n    mf.add_edge(0, 1, 1)\n    mf.add_edge(1, 2, 3)\n\n    print(mf.max_flow(0, 2))\n\n    for fr, to, cap, flow in mf.edges():\n        print(fr, to, flow)\n\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.pos = []\n\n    def add_edge(self, fr, to, cap):\n        m = len(self.pos)\n        self.pos.append((fr, len(self.graph[fr])))\n        self.graph[fr].append([to, len(self.graph[to]), cap])\n        self.graph[to].append([fr, len(self.graph[fr]) - 1, 0])\n        return m\n\n    def get_edge(self, idx):\n        to, rev, cap = self.graph[self.pos[idx][0]][self.pos[idx][1]]\n        rev_to, rev_rev, rev_cap = self.graph[to][rev]\n        return rev_to, to, cap + rev_cap, rev_cap\n\n    def edges(self):\n        m = len(self.pos)\n        for i in range(m):\n            yield self.get_edge(i)\n\n    def change_edge(self, idx, new_cap, new_flow):\n        to, rev, cap = self.graph[self.pos[idx][0]][self.pos[idx][1]]\n        self.graph[self.pos[idx][0]][self.pos[idx][1]][2] = new_cap - new_flow\n        self.graph[to][rev][2] = new_flow\n\n    def dfs(self, s, v, up):\n        if v == s:\n            return up\n        res = 0\n        lv = self.level[v]\n        for i in range(self.iter[v], len(self.graph[v])):\n            to, rev, cap = self.graph[v][i]\n            if lv <= self.level[to] or self.graph[to][rev][2] == 0:\n                continue\n            d = self.dfs(s, to, min(up - res, self.graph[to][rev][2]))\n            if d <= 0:\n                continue\n            self.graph[v][i][2] += d\n            self.graph[to][rev][2] -= d\n            res += d\n            if res == up:\n                break\n            self.iter[v] += 1\n        return res\n\n    def max_flow(self, s, t):\n        return self.max_flow_with_limit(s, t, 2 ** 63 - 1)\n\n    def max_flow_with_limit(self, s, t, limit):\n        flow = 0\n        while flow < limit:\n            self.level = [-1] * self.n\n            self.level[s] = 0\n            queue = deque()\n            queue.append(s)\n            while queue:\n                v = queue.popleft()\n                for to, rev, cap in self.graph[v]:\n                    if cap == 0 or self.level[to] >= 0:\n                        continue\n                    self.level[to] = self.level[v] + 1\n                    if to == t:\n                        break\n                    queue.append(to)\n            if self.level[t] == -1:\n                break\n            self.iter = [0] * self.n\n            while flow < limit:\n                f = self.dfs(s, t, limit - flow)\n                if not f:\n                    break\n                flow += f\n        return flow\n\n    def min_cut(self, s):\n        visited = [0] * self.n\n        queue = deque()\n        queue.append(s)\n        while queue:\n            p = queue.popleft()\n            visited[p] = True\n            for to, rev, cap in self.graph[p]:\n                if cap and not visited[to]:\n                    visited[to] = True\n                    queue.append(to)\n        return visited\n\n\nH, W = list(map(int, input().split()))\na = [list(input().rstrip()) for _ in range(H)]\n\nmf = MaxFlow(H + W + 2)\nstart = H + W\nterminal = H + W + 1\nINF = 10**6\n\nfor i in range(H):\n    for j in range(W):\n        if a[i][j] == 'S':\n            mf.add_edge(start, i, INF)\n            mf.add_edge(start, H + j, INF)\n        elif a[i][j] == 'T':\n            mf.add_edge(i, terminal, INF)\n            mf.add_edge(H + j, terminal, INF)\n        elif a[i][j] == 'o':\n            mf.add_edge(i, H + j, 1)\n            mf.add_edge(H + j, i, 1)\n\nans = mf.max_flow(start, terminal)\nif ans >= INF:\n    print((-1))\nelse:\n    print(ans)\n", "from typing import NamedTuple, Optional, List, cast\n\n\nclass MFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.rev: Optional[MFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MFGraph._Edge(dst, cap)\n        re = MFGraph._Edge(src, 0)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MFGraph._Edge, e.rev)\n        return MFGraph.Edge(\n            re.dst,\n            e.dst,\n            e.cap + re.cap,\n            re.cap\n        )\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def change_edge(self, i: int, new_cap: int, new_flow: int) -> None:\n        assert 0 <= i < len(self._edges)\n        assert 0 <= new_flow <= new_cap\n        e = self._edges[i]\n        e.cap = new_cap - new_flow\n        assert e.rev is not None\n        e.rev.cap = new_flow\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> int:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        current_edge = [0] * self._n\n        level = [0] * self._n\n\n        def fill(arr: List[int], value: int) -> None:\n            for i in range(len(arr)):\n                arr[i] = value\n\n        def bfs() -> bool:\n            fill(level, self._n)\n            queue = []\n            q_front = 0\n            queue.append(s)\n            level[s] = 0\n            while q_front < len(queue):\n                v = queue[q_front]\n                q_front += 1\n                next_level = level[v] + 1\n                for e in self._g[v]:\n                    if e.cap == 0 or level[e.dst] <= next_level:\n                        continue\n                    level[e.dst] = next_level\n                    if e.dst == t:\n                        return True\n                    queue.append(e.dst)\n            return False\n\n        def dfs(lim: int) -> int:\n            stack = []\n            edge_stack: List[MFGraph._Edge] = []\n            stack.append(t)\n            while stack:\n                v = stack[-1]\n                if v == s:\n                    flow = min(lim, min(e.cap for e in edge_stack))\n                    for e in edge_stack:\n                        e.cap -= flow\n                        assert e.rev is not None\n                        e.rev.cap += flow\n                    return flow\n                next_level = level[v] - 1\n                while current_edge[v] < len(self._g[v]):\n                    e = self._g[v][current_edge[v]]\n                    re = cast(MFGraph._Edge, e.rev)\n                    if level[e.dst] != next_level or re.cap == 0:\n                        current_edge[v] += 1\n                        continue\n                    stack.append(e.dst)\n                    edge_stack.append(re)\n                    break\n                else:\n                    stack.pop()\n                    if edge_stack:\n                        edge_stack.pop()\n                    level[v] = self._n\n            return 0\n\n        flow = 0\n        while flow < flow_limit:\n            if not bfs():\n                break\n            fill(current_edge, 0)\n            while flow < flow_limit:\n                f = dfs(flow_limit - flow)\n                flow += f\n                if f == 0:\n                    break\n        return flow\n\n    def min_cut(self, s: int) -> List[bool]:\n        visited = [False] * self._n\n        stack = [s]\n        visited[s] = True\n        while stack:\n            v = stack.pop()\n            for e in self._g[v]:\n                if e.cap > 0 and not visited[e.dst]:\n                    visited[e.dst] = True\n                    stack.append(e.dst)\n        return visited\n\n\nimport sys\ninput = sys.stdin.readline\n\nh, w = map(int, input().split())\nA = tuple(input().rstrip() for _ in range(h))\nG = MFGraph(h+w+2)\ns = h+w\nt = s+1\nbig = 10**9\nfor i in range(h):\n    for j in range(w):\n        if A[i][j] == \"S\":\n            G.add_edge(s, i, big)\n            G.add_edge(s, h+j, big)\n        if A[i][j] == \"T\":\n            G.add_edge(i, t, big)\n            G.add_edge(h+j, t, big)\n        if A[i][j] == \"o\":\n            G.add_edge(i, h+j, 1)\n            G.add_edge(h+j, i, 1)\nans = G.flow(s, t)\nif ans >= big:\n    ans = -1\nprint(ans)", "# graph = [{} for _ in range(V)]\n# when there is an edge u -> v (maxflow f)\n#  graph[u][v] = f\n#  graph[v][u] = f (if undirected) 0 (if directed)\n\nclass FordFulkerson():\n    def __init__(self, start, finish, graph, INF=10**18):\n        self.INF = INF\n        self.start = start\n        self.finish = finish\n        self.graph = graph\n        self.N = len(graph)\n\n    def dfs(self):\n        self.Flow = [self.INF]*self.N\n        self.used = [False]*self.N\n        self.Par = [-1]*self.N\n        self.stack = [self.start]\n        self.used[self.start] = True\n        while self.stack:\n            v = self.stack.pop()\n            if v == self.finish:\n                d = self.Flow[v]\n                while v != self.start:\n                    nv = self.Par[v]\n                    self.graph[nv][v] -= d\n                    self.graph[v][nv] += d\n                    v = nv\n                return d\n            for i, (nv, ncap) in enumerate(self.graph[v].items()):\n                if not self.used[nv] and ncap > 0:\n                    self.used[nv] = True\n                    self.stack.append(nv)\n                    self.Par[nv] = v\n                    self.Flow[nv] = min(self.Flow[v], ncap)\n        return 0\n\n    # solve\n    def flow(self):\n        flow = 0\n        while True:\n            f = self.dfs()\n            if f == 0: return flow\n            flow += f\n\n\nimport sys\ninput = sys.stdin.readline\n\nINF = 10**18\n\nH, W = map(int, input().split())\nV = H+W\n\n\ndef make():\n    state = [list(input().rstrip()) for _ in range(H)]\n    graph = [{} for _ in range(V+2)]\n\n    start = V\n    finish = V+1\n\n    for h in range(H):\n        for w in range(W):\n            u, v = h, w+H\n            if state[h][w] == \"o\":\n                graph[u][v] = 1\n                graph[v][u] = 1\n            if state[h][w] == \"S\":\n                graph[v][start] = INF\n                graph[start][v] = INF\n                graph[u][start] = INF\n                graph[start][u] = INF\n            if state[h][w] == \"T\":\n                graph[u][finish] = INF\n                graph[finish][u] = INF\n                graph[v][finish] = INF\n                graph[finish][v] = INF\n    \n    return graph, start, finish\n\n\n\ndef main():\n    graph, start, finish = make()\n    ff = FordFulkerson(start, finish, graph)\n    ans = ff.flow()\n\n    if ans > INF//2:\n        print(-1)\n    else:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "H,W = map(int,input().split())\nA = [input() for i in range(H)]\nsy = sx = ty = tx = -1\nfor i,row in enumerate(A):\n    for j,c in enumerate(row):\n        if c=='S':\n            sy,sx = i,j\n        if c=='T':\n            ty,tx = i,j\nif sy==ty or sx==tx:\n    print(-1)\n    return\n\nS = H+W\nG = S+1\nP = G+1\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\n\ndef add_edge(fr,to,cap):\n    es[fr].append([to,cap,len(es[to])])\n    es[to].append([fr,0,len(es[fr])-1])\nINF = float('inf')\nadd_edge(S, sy, INF)\nadd_edge(S, H+sx, INF)\nadd_edge(ty, G, INF)\nadd_edge(H+tx, G, INF)\nfor i,row in enumerate(A):\n    for j,c in enumerate(row):\n        if c!='o': continue\n        add_edge(i, H+j, 1)\n        add_edge(H+j, i, 1)\n\nlevel = [0] * P\niters = [0] * P\nfrom collections import deque\ndef dinic_max_flow(s,t):\n    nonlocal iters\n\n    def _bfs(s):\n        nonlocal level\n        level = [-1] * P\n        level[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for to,cap,rev in es[v]:\n                if cap > 0 and level[to] < 0:\n                    level[to] = level[v] + 1\n                    q.append(to)\n\n    def _dfs(v,t,f):\n        if v == t: return f\n        for i in range(iters[v],len(es[v])):\n            iters[v] += 1\n            to,cap,rev = es[v][i]\n            if es[v][i][1] > 0 and level[v] < level[to]:\n                d = _dfs(to,t,min(f,es[v][i][1]))\n                if d > 0:\n                    es[v][i][1] -= d #cap\n                    es[to][rev][1] += d\n                    return d\n        return 0\n\n    flow = 0\n    while True:\n        _bfs(s)\n        if level[t] < 0: return flow\n        iters = [0] * P\n        f = 0\n        while True:\n            f = _dfs(s,t,INF)\n            if f <= 0: break\n            flow += f\n\nprint(dinic_max_flow(S,G))", "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, v, inf=10**9 + 7):\n        self.V = v\n        self.inf = inf\n        self.G = [list() for _ in range(v)]\n        self.level = [-1 for _ in range(v)]\n        self.iter = [0] * v\n\n    def addedge(self, fr, to, cap):\n        \"\"\"\n        G[fr] = [to, cap, rev]\n        \"\"\"\n        go = [to, cap, None]\n        go[2] = back = [fr, 0, go]\n        self.G[fr].append(go)\n        self.G[to].append(back)\n\n    def bfs(self, st, en):\n        q = deque([st])\n        self.level = [-1 for _ in range(self.V)]\n        self.level[st] = 0\n        while q:\n            cur = q.popleft()\n            for x, cap, _ in self.G[cur]:\n                if cap and self.level[x] < 0:\n                    self.level[x] = self.level[cur] + 1\n                    q.append(x)\n        return self.level[en] > 0\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while self.bfs(s, t):\n            self.iter = list(map(iter, self.G))\n            f = self.dfs(s, t, self.inf)\n            while f:\n                flow += f\n                f = self.dfs(s, t, self.inf)\n        return flow\n      \n      \n      \nH, W = map(int, input().split())\ndinic = Dinic(200)\nfor y in range(H):\n  s = input()\n  for x in range(W):\n    if s[x] == 'o':\n      dinic.addedge(y, x+100, 1)\n      dinic.addedge(x+100, y, 1)\n    elif s[x] == 'S':\n      sy, sx = y, x\n      dinic.addedge(y, x+100, 10**5)\n      dinic.addedge(x+100, y, 10**5)\n    elif s[x] == 'T':\n      ty, tx = y, x\n      dinic.addedge(y, x+100, 10**5)\n      dinic.addedge(x+100, y, 10**5)\nprint(-1 if sy == ty or sx == tx else dinic.flow(sy, ty))", "# \u6700\u5927\u6d41\nNUMERIC_LIMITS = 10 ** 18\nimport queue\nclass maxFlow:\n  class edge:\n    def __init__(s, frm, to, cap, flow):\n      s.frm, s.to = frm, to\n      s.cap, s.flow = cap, flow\n\n  def __init__(s, n):\n    s._n = n\n    s.g = [[] for _ in range(n)]\n    s.pos = []\n\n  def add_edge(s, frm, to, cap):\n    m = len(s.pos)\n    s.pos.append([frm, len(s.g[frm])])\n    s.g[frm].append(s._edge(to, len(s.g[to]), cap))\n    s.g[to].append(s._edge(frm,len(s.g[frm]) - 1, 0))\n    return m\n\n  def get_edge(s, i):\n    m = len(s.pos)\n    _e = s.g[s.pos[i][0]][s.pos[i][1]]\n    _re = s.g[_e.to][_e.rev]\n    return s.edge(s.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap)\n\n  def edges(s):\n    m = len(s.pos)\n    result = []\n    for i in range(m):\n      result.append(s.get_edge(i))\n    return result\n\n  def change_edge(s, i, new_cap, new_flow):\n    m = len(s.pos)\n    _e = s.g[s.pos[i].to][s.pos[i].rev]\n    _re = s.g[_e.to][_e.rev]\n    _e.cap = new_cap - new_flow\n    _re.cap = new_flow\n\n  def flow(self, s, t, flow_limit = NUMERIC_LIMITS):\n    level = [0] * self._n\n    iter = [0] * self._n \n\n    def bfs():\n      for i in range(self._n):\n        level[i] = -1\n      level[s] = 0\n      que = queue.Queue()\n      que.put(s)\n      while not que.empty():\n        v = que.get()\n        for e in self.g[v]:\n           if e.cap == 0 or level[e.to] >= 0: continue\n           level[e.to] = level[v] + 1\n           if e.to == t: return\n           que.put(e.to)\n    def dfs(this, v, up):\n      if v == s: return up\n      res = 0\n      level_v = level[v]\n      for i in range(iter[v], len(self.g[v])):\n        e = self.g[v][i]\n        if level_v <= level[e.to] or self.g[e.to][e.rev].cap == 0: continue\n        d = this(this, e.to, min(up - res, self.g[e.to][e.rev].cap))\n        if d <= 0: continue\n        self.g[v][i].cap += d\n        self.g[e.to][e.rev].cap -= d\n        res += d\n        if res == up: break\n      return res\n\n    flow = 0\n    while flow < flow_limit:\n      bfs()\n      if level[t] == -1: break\n      for i in range(self._n): iter[i]\n      while flow < flow_limit:\n        f = dfs(dfs, t, flow_limit - flow)\n        if not f: break\n        flow += f\n    return flow\n\n  def min_cut(self, s):\n    visited = [False] * self._n\n    que = queue.Queue()\n    que.put(s)\n    while not que.empty():\n      p = que.get()\n      visited[p] = True\n      for e in self.g[p]:\n        if e.cap and not visited[e.to]:\n          visited[e.to] = True\n          que.put(e.to)\n    return visited\n\n  class _edge:\n    def __init__(s, to, rev, cap):\n      s.to, s.rev = to, rev\n      s.cap = cap\n\nH, W = list(map(int, input().split()))\na = [list(input()) for _ in range(H)]\n\nflow = maxFlow(H + W + 2)\ns = H + W\nt = H + W + 1\nfor h in range(H):\n  for w in range(W):\n    if a[h][w] == \"S\":\n      flow.add_edge(s, h, H + W + 1)\n      flow.add_edge(s, H + w, H + W + 1)\n    elif a[h][w] == \"T\":\n      flow.add_edge(h, t, H + W + 1)\n      flow.add_edge(H + w, t, H + W + 1)\n    if a[h][w] != \".\":\n      flow.add_edge(h, H + w, 1)\n      flow.add_edge(H + w, h, 1)\n\nans = flow.flow(s, t)\nif ans > H + W:\n  print((-1))\nelse:\n  print(ans)\n", "def dfs(v,t,f,used,graph):\n    if v==t:\n        return f\n    used[v] = True\n    for to in graph[v]:\n        c = graph[v][to]\n        if used[to] or c==0:\n            continue\n        d = dfs(to,t,min(f,c),used,graph)\n        if d>0:\n            graph[v][to] -= d\n            graph[to][v] += d\n            return d\n    return 0\n \ndef max_flow(s,t,graph):\n    flow = 0\n    while True:\n        used = [False]*len(graph)\n        f = dfs(s,t,float('inf'),used,graph)\n        flow += f\n        if f==0 or f==float('inf'):\n            return flow\n \nH,W = map(int,input().split())\n\na = [input() for _ in range(H)]\na = [[s for s in a[i]] for i in range(H)]\n\ngraph = [{} for _ in range(H+W+2)]\n\nfor h in range(H):\n    for w in range(W):\n        if a[h][w]=='o':\n            graph[h][H+w] = 1\n            graph[H+w][h] = 1\n        if a[h][w]=='S':\n            graph[H+W][h] = float('inf')\n            graph[H+W][H+w] = float('inf')\n            graph[h][H+W] = 0\n            graph[H+w][H+W] = 0\n        if a[h][w]=='T':\n            graph[H+W+1][h] = 0\n            graph[H+W+1][H+w] = 0\n            graph[h][H+W+1] = float('inf')\n            graph[H+w][H+W+1] = float('inf')\n\nans = max_flow(H+W,H+W+1,graph)\nif ans == float('inf'):\n    ans = -1\n\nprint(ans)", "\"\"\"\n.o...o..o.\n....o.....\n....oo.oo.\n..oooo..o.\n....oo....\n..o..o....\no..o....So\no....T....\n....o.....\n........oo\n\n\u30b0\u30e9\u30d5\u3092\u4f5c\u308b\n\u21db S\u304b\u3089T\u306b\u305f\u3069\u308a\u7740\u304f\u500b\u6570\u3092\u5168\u63a2\u7d22\n\u21db \u305f\u3069\u308a\u7740\u304f\u76f4\u524d\u306e\u5ea7\u6a19\u3092\u4fdd\u6301\n\u21db \u76f4\u524d\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\n\u89e3\u8aacAC\n\u21db \u884c\u5185\u3001\u5217\u5185\u306f\u81ea\u7531\u306b\u52d5\u3051\u308b\n\u21db \u884c/\u5217\u306e\u3069\u3053\u304b\u306b\u3044\u308b\u72b6\u614b\u3067\u3082\u305f\u305b\u308b\n\u21db \u70b9\u306e\u4e0a\u306f\u884c\u21d4\u5217\u306e\u5207\u308a\u66ff\u3048\u304c\u51fa\u6765\u308b\u306e\u3067\u3001cap==1\u3068\u3059\u308b\n\u21db \u7d50\u5c40MaxCut\u3092\u3057\u3066\u3044\u308b\u306e\u3068\u4e00\u7dd2\uff01\uff01\n\"\"\"\n\nfrom collections import deque\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\nclass Dinic:\n    def __init__(self):\n        # self.N = N\n        self.G = defaultdict(list)\n    \n    def add_edge(self, fr, to, cap):\n        \"\"\"\n        :param fr: \u59cb\u70b9\n        :param to: \u7d42\u70b9\n        :param cap: \u5bb9\u91cf\n        \"\"\"\n        # forward\u306e\u6700\u5f8c\u306b\u306f\u3001\u30ad\u30e3\u30d1\u306e\u3046\u3061\u3069\u308c\u3060\u3051\u4f7f\u3063\u305f\u304b\u304c\u5165\u308b\n        forward = [to, cap, None]\n        backward = [fr, 0, forward]\n        forward[-1] = backward\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        \"\"\"\n        :param v1: \u59cb\u70b9\n        :param v2: \u7d42\u70b9\n        :param cap1: \u5bb9\u91cf1\n        :param cap2: \u5bb9\u91cf2\n        \"\"\"\n        edge1 = [v2, cap1, None]\n        edge2 = [v1, cap2, edge1]\n        edge1[-1] = edge2\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        \"\"\"\n        :param s: bfs\u306e\u59cb\u70b9(source)\n        :param t: bfs\u306e\u7d42\u70b9(sink)\n        :return: t\u306b\u5230\u9054\u3057\u305f\u304b\u3069\u3046\u304b\u3002(source\u304b\u3089\u306e\u8ddd\u96e2\u3092\u4fdd\u5b58\u3057\u306a\u304c\u3089)\n        \"\"\"\n        self.level = level = defaultdict(int)\n        q = deque([s])\n        level[s] = 1\n        G = self.G\n        while len(q) > 0:\n            v = q.popleft()\n            lv = level[v] + 1\n            nexts = G[v]\n            for w, cap, _ in nexts:\n                if cap > 0 and level[w] == 0:\n                    level[w] = lv\n                    q.append(w)\n        is_reach = (level[t] > 0)\n        return is_reach\n\n    def dfs(self, v, t, f):\n        \"\"\"\n        :param v: \u70b9v\n        :param t: \u7d42\u70b9(sink)\n        :param f: v\u6642\u70b9\u3067\u306e\u30d5\u30ed\u30fc\n        :return: \u7d42\u70b9\u5230\u9054\u6642\u306e\u30d5\u30ed\u30fc\u3092\u8fd4\u3059\n        \"\"\"   \n        if v == t:\n            return f\n        level = self.level\n        nexts = self.G[v]\n        for edge in nexts:\n            w, cap, rev = edge\n            # \u307e\u3060\u30ad\u30e3\u30d1\u304c\u3042\u308b\u306a\u3089\u3070\n            if cap > 0 and level[v] < level[w]:\n                # \u30ad\u30e3\u30d1\u304c\u4f59\u3063\u3066\u308b\u306a\u3089\u5168\u90e8\u6d41\u3059\u3057\n                # \u30ab\u30c4\u30ab\u30c4\u306a\u3089\u30ad\u30e3\u30d1\u306emax\u307e\u3067\u6d41\u3059\n                d = self.dfs(w, t, min(f, cap))\n                # \u5e30\u308a\u304c\u3051\u306b\u3001\u66f4\u65b0\n                if d > 0:\n                    # \u9806\u65b9\u5411\u306e\u30ad\u30e3\u30d1\u3092d\u4e0b\u3052\u308b\n                    # \u9006\u65b9\u5411\u306e\u30ad\u30e3\u30d1\u3092d\u5897\u3084\u3059\n                    edge[1] -= d\n                    rev[1] += d\n                    return d\n        # \u6b21\u306e\u9053\u304c\u898b\u3064\u304b\u3089\u306a\u3051\u308c\u3070\u7d42\u4e86\n        return 0\n    \n    def flow(self, s, t):\n        \"\"\"\n        :param s: \u59cb\u70b9\n        :param t: \u7d42\u70b9\n        :return : \u6700\u5927\u30d5\u30ed\u30fc\n        \"\"\"\n        flow = 0\n        INF = 10**10\n        G = self.G\n        # \u30eb\u30fc\u30c8\u304c\u5b58\u5728\u3059\u308b\u9650\u308a\u3001\u7d9a\u3051\u308b\n        while self.bfs(s, t):\n            f = INF\n            while f > 0:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\n\n\nans = set()\nH, W = map(int, input().split())\nfields = []\nfor i in range(H):\n    inp = list(input())\n    fields.append(inp)\ndinic = Dinic()\nstart = -1\nend = -2\nINF = 10**10\nfor i in range(H):\n    for j in range(W):\n        if fields[i][j] == \"T\":\n            dinic.add_edge(i,end,INF)\n            dinic.add_edge(j+H,end,INF)\n        if fields[i][j] == \"S\":\n            dinic.add_edge(start,i,INF)\n            dinic.add_edge(start,j+H,INF)\n        if fields[i][j] != \".\":\n            dinic.add_edge(i,j+H,1)\n            dinic.add_edge(j+H,i,1)\n\nans = dinic.flow(start,end)\nif ans > INF:print(-1)\nelse:print(ans)", "def main():\n    import sys\n    sys.setrecursionlimit(1000000)\n    # \u884c\u5148\u3001\u4e0a\u9650\u3001\u9006\u8fba\n\n    def add_edge(From, to, cap):\n        g[From][to] = cap\n        g[to][-From-1] = 0\n\n    def max_flow(s, t):\n        def dfs(v, t, f):\n            q.append(v)\n            if v == t:\n                return f\n            used[v] += 1\n            for i in range(len(gkey[v])):\n                to = gkey[v][i]\n                cap = g[v][to]\n                if to < 0:\n                    to2 = -to-1\n                else:\n                    to2 = to\n                if used[to2] or cap == 0:\n                    continue\n                d = dfs(to2, t, min(f, cap))\n                if d > 0:\n                    g[v][to] -= d\n                    g[to2][-v-1] += d\n                    return d\n            q.pop()\n            return 0\n\n        flow = 0\n        while True:\n            used = [0]*n\n            q = []\n            f = dfs(s, t, 10**100)\n            if not q:\n                return flow\n            flow += f\n\n    h, w = list(map(int, input().split()))\n    n = h+w+2\n    g = [dict() for _ in range(n)]\n    for i in range(h):\n        A = input()\n        for j in range(w):\n            if A[j] == \"o\":\n                add_edge(i, j+h, 1)\n                add_edge(j+h, i, 1)\n            elif A[j] == \"S\":\n                add_edge(h+w, i, 10**6)\n                add_edge(h+w, j+h, 10**6)\n            elif A[j] == \"T\":\n                add_edge(i, h+w+1, 10**6)\n                add_edge(j+h, h+w+1, 10**6)\n    gkey = [list(i.keys()) for i in g]\n\n    ans = max_flow(h+w, h+w+1)\n    if ans >= 10**6:\n        print((-1))\n    else:\n        print(ans)\n\n\nmain()\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nh,w = list(map(int, input().split()))\ndata= []\nrs = []\ncs = []\nfor i in range(h):\n    c = input()\n    if \"S\" in c:\n        start = (i, c.index(\"S\"))\n    if \"T\" in c:\n        goal = (i, c.index(\"T\"))\n    for j in range(w):\n        if c[j] in (\"o\"):#, \"S\", \"T\"):\n            data.append(1)\n            rs.append(i)\n            cs.append(h+j)\n            data.append(1)\n            rs.append(h+j)\n            cs.append(i)\ns = h+w\nt = h+w+1\nV = 10**9\ndata.append(V)\nrs.append(s)\ncs.append(start[0])\n# data.append(V)\n# rs.append(start[0])\n# cs.append(s)\n\ndata.append(V)\nrs.append(s)\ncs.append(start[1]+h)\n# data.append(V)\n# rs.append(start[1]+h)\n# cs.append(s)\n\ndata.append(V)\nrs.append(goal[0])\ncs.append(t)\n# data.append(V)\n# rs.append(t)\n# cs.append(goal[0])\n\n# data.append(V)\n# rs.append(t)\n# cs.append(goal[1]+h)\ndata.append(V)\nrs.append(goal[1]+h)\ncs.append(t)\n\nimport scipy.sparse\nm = scipy.sparse.csr_matrix((data, (rs, cs)), shape=(h+w+2,h+w+2))\nval = scipy.sparse.csgraph.maximum_flow(m, s, t).flow_value\nif val>=10**9:\n    val = -1\nprint(val)", "import sys\n\nsys.setrecursionlimit(10**7)\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LS2(): return list(sys.stdin.readline().rstrip())\n\n\nfrom collections import deque\n\n\nclass Dinic:\n    def __init__(self, N, inf):\n        self.N = N\n        self.inf = inf\n        self.G = [[] for _ in range(N)]\n        self.level = [0]*N\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s):\n        self.level = [-1]*self.N\n        deq = deque([s])\n        self.level[s] = 0\n        while deq:\n            v = deq.pop()\n            lv = self.level[v] + 1\n            for w, cap, _ in self.G[v]:\n                if cap > 0 and self.level[w] == -1:\n                    self.level[w] = lv\n                    deq.appendleft(w)\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for e in self.iter[v]:\n            w, cap, rev = e\n            if cap > 0 and self.level[v] < self.level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d > 0:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] == -1:\n                return flow\n            *self.iter, = list(map(iter, self.G))\n            f = self.inf\n            while f > 0:\n                f = self.dfs(s, t, self.inf)\n                flow += f\n\n\nH,W = MI()\ninf = 10**5\nDi = Dinic(H+W+2,inf)\ns,t = H+W,H+W+1\nfor i in range(H):\n    S = LS2()\n    for j in range(W):\n        if S[j] == 'S':\n            Di.add_edge(s,i,inf)\n            Di.add_edge(s,j+H,inf)\n        elif S[j] == 'T':\n            Di.add_edge(i,t,inf)\n            Di.add_edge(j+H,t,inf)\n        elif S[j] == 'o':\n            Di.add_edge(i,j+H,1)\n            Di.add_edge(j+H,i,1)\n\nans = Di.flow(s,t)\nprint((ans if ans < inf else -1))\n", "from collections import deque\n\n\nclass MF_graph(object):\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for _ in range(n)]  # to, rev, cap\n        self.pos = []\n\n    def add_edge(self, frm, to, cap):\n        m = len(self.pos)\n        self.pos.append((frm, len(self.g[frm])))\n        self.g[frm].append([to, len(self.g[to]), cap])\n        self.g[to].append([frm, len(self.g[frm]) - 1, 0])\n        return m\n\n    def get_edge(self, i):\n        e_to, e_rev, e_cap = self.g[self.pos[i][0]][self.pos[i][1]]\n        re_to, _, re_cap = self.g[e_to][e_rev]\n        # from, to, cap, flow\n        return (re_to, e_to, e_cap + re_cap, re_cap)\n\n    def edges(self):\n        m = len(self.pos)\n        for i in range(m):\n            yield self.get_edge(i)\n\n    def change_edge(self, i, new_cap, new_flow):\n        f, s = self.pos[i]\n        rf, rs, _ = self.g[f][s]\n        self.g[f][s][2] = new_cap - new_flow\n        self.g[rf][rs][2] = new_flow\n        return\n\n    def dfs(self, s, v, up):\n        if v == s:\n            return up\n        res = 0\n        level_v = self.level[v]\n        for i in range(self.iter[v], len(self.g[v])):\n            u_to, u_rev, _ = self.g[v][i]\n            if level_v <= self.level[u_to] or self.g[u_to][u_rev][2] == 0:\n                continue\n            d = self.dfs(s, u_to, min(up - res, self.g[u_to][u_rev][2]))\n            if d <= 0:\n                continue\n            self.g[v][i][2] += d\n            self.g[u_to][u_rev][2] -= d\n            res += d\n            if res == up:\n                break\n        return res\n\n    def flow(self, s, t, flow_limit=10**18):\n        self.iter = [0] * self.n\n\n        flow = 0\n        while flow < flow_limit:\n            self.level = [-1] * self.n\n            self.level[s] = 0\n            que = deque([s])\n            while que:\n                v = que.popleft()\n                for u_to, _, u_cap in self.g[v]:\n                    if u_cap == 0 or self.level[u_to] >= 0:\n                        continue\n                    self.level[u_to] = self.level[v] + 1\n                    if u_to == t:\n                        break\n                    que.append(u_to)\n\n            if self.level[t] == -1:\n                break\n            self.iter = [0] * self.n\n            while flow < flow_limit:\n                f = self.dfs(s, t, flow_limit - flow)\n                if not f:\n                    break\n                flow += f\n        return flow\n\n    def min_cut(self, s):\n        visited = [False] * self.n\n        que = deque([s])\n        while que:\n            v = que.popleft()\n            visited[v] = True\n            for u_to, _, u_cap in self.g[v]:\n                if u_cap and (not visited[u_to]):\n                    visited[u_to] = True\n                    que.append(u_to)\n        return visited\n\n\nH, W = map(int, input().split())\nS = [input() for _ in range(H)]\ninf = 10**18\n\ng = MF_graph(H + W + 2)\nsource = H + W\nsink = H + W + 1\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == \"S\":\n            g.add_edge(source, i, inf)\n            g.add_edge(source, H + j, inf)\n        elif S[i][j] == \"T\":\n            g.add_edge(i, sink, inf)\n            g.add_edge(H + j, sink, inf)\n        elif S[i][j] == \"o\":\n            g.add_edge(i, H + j, 1)\n            g.add_edge(H + j, i, 1)\n\nflow = g.flow(source, sink)\nif flow >= inf:\n    print(-1)\nelse:\n    print(flow)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass E:\n    def __init__(self, dst, cap, rev):\n        self.dst = dst\n        self.cap = cap\n        self.rev = rev\n\n    def __repr__(self):\n        return \"({}, {}, {})\".format(self.dst, self.cap, self.rev)\n\n    def __str__(self):\n        return \"({}, {}, {})\".format(self.dst, self.cap, self.rev)\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for _ in range(n)]\n\n    def add_edge(self, src, dst, cap):\n        self.g[src].append(E(dst, cap, len(self.g[dst])))\n        self.g[dst].append(E(src, 0, len(self.g[src]) - 1))\n\n    def add_undirected_edge(self, src, dst, cap):\n        self.g[src].append(E(dst, cap, len(self.g[dst])))\n        self.g[dst].append(E(src, cap, len(self.g[src]) - 1))\n\n    def dfs(self, s, u, crr):\n        if s == u or crr == 0:\n            return crr\n        sm = 0\n        for i in range(self.itr[u], len(self.g[u])):\n            e = self.g[u][i]\n            ee = self.g[e.dst][e.rev]\n            v = e.dst\n            if self.level[v] >= self.level[u] or ee.cap <= 0:\n                continue\n            f = self.dfs(s, v, min(crr - sm, ee.cap))\n            if f <= 0:\n                continue\n            ee.cap -= f\n            e.cap += f\n            sm += f\n            if sm == crr:\n                break\n        return sm\n\n    def run(self, s, t):\n        q = [0] * self.n\n        flow = 0\n        while True:\n            self.level = [-1] * self.n\n            q[0] = s\n            self.level[s] = 0\n            ql = 0\n            qr = 1\n            while ql != qr and self.level[t] == -1:\n                u = q[ql]\n                ql += 1\n                for e in self.g[u]:\n                    if e.cap > 0 and self.level[e.dst] == -1:\n                        self.level[e.dst] = self.level[u] + 1\n                        q[qr] = e.dst\n                        qr += 1\n            if self.level[t] == -1:\n                return flow\n            self.itr = [0] * self.n\n            flow += self.dfs(s, t, inf)\n\n        return flow\n\ndef main():\n    h,w = LI()\n    a = [S() for _ in range(h)]\n    dn = Dinic(h+w+2)\n    s = h+w\n    t = s+1\n    for i in range(h):\n        for j in range(w):\n            c = a[i][j]\n            if c == '.':\n                continue\n            if c == 'o':\n                dn.add_undirected_edge(i, h+j, 1)\n            elif c == 'S':\n                dn.add_edge(s, i, inf)\n                dn.add_edge(s, h+j, inf)\n                for ii in range(h):\n                    a\n            elif c == 'T':\n                dn.add_edge(i, t, inf)\n                dn.add_edge(h+j, t, inf)\n\n    r = dn.run(s, t)\n    if r >= inf:\n        return -1\n    return r\n\n\n\n\nprint(main())\n\n", "import networkx as nx\n\nH,W = map(int,input().split())\na = [input() for _ in range(H)]\nINF = 10**20\n\nG = nx.Graph()\nG.add_nodes_from(range(0,H+W+2))\nfor i in range(H):\n  for j in range(W):\n    if a[i][j]=='o':\n      G.add_edge(i+1,j+H+1,capacity=1)\n    if a[i][j]=='S':\n      G.add_edge(0,i+1,capacity=INF)\n      G.add_edge(0,j+H+1,capacity=INF)\n    if a[i][j]=='T':\n      G.add_edge(H+W+1,i+1,capacity=INF)\n      G.add_edge(H+W+1,j+H+1,capacity=INF)\n      \nflow_value,flow_dict = nx.maximum_flow(G,0,H+W+1)\nprint(flow_value if flow_value < INF else -1)", "import collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO: must be Verified\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u]) - 1])\n            self.edges[v].append([u, c, len(self.edges[u])])\n            self.edges[u].append([v, 0, len(self.edges[v]) - 1])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get()\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nH, W = map(int, input().split())\ngraph = Dinic(H+W+2)\n\nfor h in range(H):\n    tmp = str(input())\n    for w in range(W):\n        if tmp[w] == 'o':\n            graph.add(h+1, H+1+w, 1)\n            graph.add(H + w + 1, h + 1, 1)\n        if tmp[w] == 'S':\n            start = [h, w]\n            graph.add(0, h+1, float('inf'))\n            graph.add(0, H+w+1, float('inf'))\n        if tmp[w] == 'T':\n            goal = [h, w]\n            graph.add(h+1, H+W+1, float('inf'))\n            graph.add(H+1+w, H+W+1, float('inf'))\n\nif start[0] == goal[0] or start[1] == goal[1]:\n    print(-1)\n    return\nprint(graph.maxFlow(0, H+W+1))"]
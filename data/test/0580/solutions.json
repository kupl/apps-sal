["from heapq import *\nimport sys\n\nMOD = 1000000181\n\ndef addM(a,b):\n    return (a+b)%MOD\ndef mulM(a,b):\n    return (a*b)%MOD\n\ndef dijk(adj,n,s):\n    dist = [10**18]*n\n    ways = [0]*n\n    frontier = []\n    dist[s] = 0\n    ways[s] = 1\n    heappush(frontier,(0,s))\n    while (len(frontier)>0):\n        x = heappop(frontier)\n        if x[0]!=dist[x[1]]:\n            continue\n        x = x[1]\n        for (i,l) in adj[x]:\n            if dist[x]+l<dist[i]:\n                dist[i] = dist[x]+l\n                ways[i] = ways[x]\n                heappush(frontier,(dist[i],i))\n            elif dist[x]+l==dist[i]:\n                ways[i] = addM(ways[i],ways[x])\n    return (dist,ways)\n\nn,m,s,t = map(int,sys.stdin.readline().split())\ns-=1\nt-=1\nadj = [[] for i in range(n)]\njda = [[] for i in range(n)]\nedges = []\n\nfor i in range(m):\n    a,b,l = map(int,sys.stdin.readline().split())\n    a-=1\n    b-=1\n    adj[a].append((b,l))\n    jda[b].append((a,l))\n    edges.append((a,b,l))\n\none = dijk(adj,n,s)\ntwo = dijk(jda,n,t)\n\nfor i in edges:\n    if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\n        sys.stdout.write(\"YES\\n\")\n    else:\n        x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\n        if x<=0:\n            sys.stdout.write(\"NO\\n\")\n        else:\n            sys.stdout.write(\"CAN \"+str(i[2]-x)+\"\\n\")", "from heapq import *\nimport sys\n\nMOD1 = 1000000007\nMOD2 = 1000000123\n\ndef addM(a,b):\n    return ((a[0]+b[0])%MOD1,(a[1]+b[1])%MOD2)\ndef mulM(a,b):\n    return ((a[0]*b[0])%MOD1,(a[1]*b[1])%MOD2)\n\ndef dijk(adj,n,s):\n    dist = [10**18]*n\n    ways = [(0,0)]*n\n    frontier = []\n    dist[s] = 0\n    ways[s] = (1,1)\n    heappush(frontier,(0,s))\n    while (len(frontier)>0):\n        x = heappop(frontier)\n        if x[0]!=dist[x[1]]:\n            continue\n        x = x[1]\n        for (i,l) in adj[x]:\n            if dist[x]+l<dist[i]:\n                dist[i] = dist[x]+l\n                ways[i] = ways[x]\n                heappush(frontier,(dist[i],i))\n            elif dist[x]+l==dist[i]:\n                ways[i] = addM(ways[i],ways[x])\n    return (dist,ways)\n\nn,m,s,t = map(int,sys.stdin.readline().split())\ns-=1\nt-=1\nadj = [[] for i in range(n)]\njda = [[] for i in range(n)]\nedges = []\n\nfor i in range(m):\n    a,b,l = map(int,sys.stdin.readline().split())\n    a-=1\n    b-=1\n    adj[a].append((b,l))\n    jda[b].append((a,l))\n    edges.append((a,b,l))\n\none = dijk(adj,n,s)\ntwo = dijk(jda,n,t)\n\nfor i in edges:\n    if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\n        sys.stdout.write(\"YES\\n\")\n    else:\n        x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\n        if x<=0:\n            sys.stdout.write(\"NO\\n\")\n        else:\n            sys.stdout.write(\"CAN \"+str(i[2]-x)+\"\\n\")", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n", "from heapq import *\nfrom collections import defaultdict\ndef D(v,g):\n\th,p,o=[],defaultdict(lambda:1e99),[]\n\theappush(h,(0,v))\n\twhile h:\n\t\tl,w=heappop(h)\n\t\tif w in p:continue\n\t\tp[w]=l\n\t\to.append(w)\n\t\tfor u,L in g[w]:\n\t\t\theappush(h,(L+l,u))\n\treturn p,o\nn,m,s,t=list(map(int,input().split()))\nr=[]\ng={i+1:[] for i in range(n)}\nG={i+1:[] for i in range(n)}\nfor _ in range(m):\n\ta,b,l=list(map(int,input().split()))\n\tr.append((a,b,l))\n\tg[a].append((b,l))\n\tG[b].append((a,l))\nS,o=D(s,g)\nT,_=D(t,G)\nL=S[t]\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\nB,A=set(),{s}\nfor v in o:\n\tif not H[v]:continue\n\tif 1==len(A)==len(H[v]):B.add(v)\n\tA.update(H[v])\n\tA.remove(v)\nprint('\\n'.join(\"YES\" if a in B and S[a]+T[b]+l==L else \"CAN \"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \"NO\" for a,b,l in r))\n\n"]
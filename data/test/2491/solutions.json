["n, m = map( int, input().split() )\nedge_list = []\nfor _ in range( m ):\n    a_i, b_i, c_i = map( int, input().split() )\n    edge_list.append( ( a_i - 1, b_i - 1, - c_i ) )\n\nINF = float(\"inf\")\ncost = [ INF ] * n\ncost[ 0 ] = 0\n\nNegativeLoopExist = False\nfor i in range( n ):\n    for j in range( m ):\n        a, b, c = edge_list[ j ]\n        if cost[ a ] != INF and cost[ b ] > cost[ a ] + c:\n            cost[ b ] = cost[ a ] + c\n            if i == n - 1 and b == n - 1:\n                NegativeLoopExist = True\n\nif NegativeLoopExist:\n    print( \"inf\" )\nelse:\n    print( - cost[ n - 1 ] )", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\nabc = [tuple(map(int,input().split())) for i in range(m)]\nes = []\nfor a,b,c in abc:\n    a,b = a-1,b-1\n    es.append((a,b,c))\n\nINF = float('inf')\n\ndef find_negative_loop(n,es,s):\n    #\u8ca0\u306e\u7d4c\u8def\u306e\u691c\u51fa\n    #n:\u9802\u70b9\u6570, es[i]: [\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8], s:\u59cb\u70b9\n    dist = [-INF] * n\n    dist[s] = 0\n\n    for i in range(n):\n        for a,b,c in es:\n            if dist[b] < dist[a]+c:\n                dist[b] = dist[a]+c\n                # if i == n-1: # n\u56de\u76ee\u306b\u3082\u66f4\u65b0\u304c\u884c\u308f\u308c\u3066\u3044\u308b\u5834\u5408\uff0c\u30eb\u30fc\u30d7\u304c\u5b58\u5728\u3059\u308b\n                if i == n-1 and b==n-1: # \u7d42\u70b9\u306b\u5f71\u97ff\u3092\u53ca\u307c\u3059\u30eb\u30fc\u30d7\u304c\u5b58\u5728\u3059\u308b\n                        return INF\n    return dist[n-1]\n\nans = find_negative_loop(n,es,0)\n\nif ans == INF:\n    print('inf')\n    return\n\nprint(ans)\n", "N,M = map(int,input().split())\nABC = [tuple(map(int,input().split())) for i in range(M)]\n\nINF = float('inf')\ndist = [INF] * N\ndist[0] = 0\nfor i in range(N):\n    for a,b,c in ABC:\n        a,b,c = a-1,b-1,-c\n        if dist[b] > dist[a] + c:\n            dist[b] = dist[a] + c\n            if i==N-1 and b == N-1:\n                print('inf')\n                return\nprint(-dist[-1])", "INF = -float('inf')\n\ndef bellmanford(n,e,r):\n  costs = [INF]*n\n  costs[r] = 0\n  for i in range(n):\n    for u,v,c in e:\n      if costs[u]+c > costs[v] and costs[u]!=INF:\n        costs[v] = costs[u]+c\n        if i==n-1 and v==n-1:\n          return 'inf'\n  return costs[n-1]\n\nn,m = list(map(int, input().split()))\nedge = []\nfor i in range(m):\n  a,b,t = list(map(int, input().split()))\n  edge.append((a-1,b-1,t))\n\nprint((bellmanford(n,edge,0)))\n", "import sys\nINF=float('inf')\ndef Bellmanford(n,edges,r):\n  d=[INF]*n\n  d[r]=0    \n  for i in range(n):\n    for (u,v,c) in edges:\n      if d[u]!=INF and d[u]+c<d[v]:\n        d[v]=d[u]+c\n        if i==n-1 and v==n-1:\n          return 'inf'   \n  return (-1)*d[n-1]\n\nN,M=list(map(int, sys.stdin.readline().split()))\nEdges=[0]*M\n\nfor i in range(M):\n  a,b,c=list(map(int, sys.stdin.readline().split()))\n  Edges[i]=(a-1,b-1,-c)\n    \nans=Bellmanford(N,Edges,0)\nprint(ans)\n", "n, m = map(int, input().split())\nedges = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    a-=1; b-=1\n    edges.append((a, b, -c))\n\ndist = [float('inf')]*n\ndist[0] = 0\nfor i in range(n-1):\n    # n-1\u56de\u30eb\u30fc\u30d7\u3059\u308b\u3053\u3068\u3067\u3001\u5230\u9054\u3067\u304d\u308b\u3059\u3079\u3066\u306e\u9802\u70b9\u306e\u66f4\u65b0\u304c\u3067\u304d\u308b\n    for st, en , score in edges:\n        if dist[st] == float('inf'): continue\n        if dist[en] > dist[st] + score:\n            dist[en] = dist[st] + score\n\nnegative = [False] * n\n\nfor loop in range(n):\n    # n\u56de\u76ee\u4ee5\u964d\u306e\u30eb\u30fc\u30d7\u3067\u66f4\u65b0\u3055\u308c\u305f\u9802\u70b9\u306f\u8ca0\u9589\u8def\u3092\u542b\u3080\n    # \u305d\u308c\u3092n\u56de\u7e70\u308a\u8fd4\u3057\u3066\u66f4\u65b0\u3055\u308c\u305f\u9802\u70b9\u306f\u3001\u8ca0\u9589\u8def\u306e\u5f71\u97ff\u3092\u53d7\u3051\u3066\u3044\u308b\n    for e in edges:\n        st, en, score = e\n        if dist[st] == float('inf'): continue\n        if dist[en] > dist[st] + score:\n            dist[en] = dist[st] + score\n            negative[en] = True\n        if negative[st]:\n            negative[en] = True\n\nif negative[n-1]:\n    print('inf')\nelse:\n    print(-dist[n-1])", "N,M = list(map(int,input().split()))\nabc = []\nfor _ in range(M):\n    abc.append(list(map(int,input().split())))\n\ncost = [-float('inf')]*N\ncost[0] = 0\n\nfor i in range(N):\n    update = False\n    for a,b,c in abc:\n        a,b = a-1,b-1\n        if cost[a] != -(10**10)*N:\n            if cost[b] < cost[a] + c:\n                cost[b] = cost[a] + c\n                update = True\n    if i == 0:\n        Max = cost[N-1]\n    elif i < N-1:\n        Max = max(Max,cost[N-1])\n\n\nif update == True and Max < cost[N-1]:\n    print('inf')\nelse:\n    print(Max)\n", "import bisect\nimport collections\nimport sys\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nACMOD = 1000000007\nINF = 1 << 60\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\n\ndef llmi(n):\n    return [lmi() for _ in range(n)]\n\n\nN, M = lmi()\nABC = llmi(M)\n\n\nclass BellmanFord:\n    def __init__(self, n, start=0):\n        self.n = n\n        self.cost = [INF] * n\n        self.cost[start] = 0\n        self.edge = dict()\n\n    def add_edge(self, _from, _to, _cost):\n        self.edge[(_from, _to)] = _cost\n\n    def fill_cost(self, check=False):\n        negative_loops = set()\n        for i in range(self.n):\n            for (_from, _to), _cost in list(self.edge.items()):\n                if self.cost[_from] != INF and self.cost[_to] > self.cost[_from] + _cost:\n                    self.cost[_to] = self.cost[_from] + _cost\n                    if check:\n                        negative_loops.add(_to)\n        return negative_loops\n\n\nbf = BellmanFord(N)\nfor a, b, c in ABC:\n    bf.add_edge(a - 1, b - 1, -c)\nbf.fill_cost()\nnegative_loops = bf.fill_cost(check=True)\n# print(negative_loops, bf.cost)\nif N - 1 in negative_loops:\n    print('inf')\nelse:\n    print((-bf.cost[-1]))\n", "N, M = map(int, input().split())\nadjacent = []\nscore = ['None' for i in range(N)]\nscore[0] = 0\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    adjacent.append([a-1, b-1, c])\nfor i in range(N):\n    for j in adjacent:\n      if score[j[1]] == 'None' and score[j[0]] != 'None':\n        score[j[1]] = score[j[0]] + j[2]\n      if score[j[1]] != 'None' and score[j[0]] != 'None':\n        if score[j[1]] < score[j[0]] + j[2]:\n          score[j[1]] = score[j[0]] + j[2]\n    if i == N-2:\n      t = score[N-1]\n    if i == N-1:\n      if t != score[N-1]:\n        score[N-1] = 1e+15\nif score[N-1] < 1e+15:\n    print(t)\nelse:\n    print('inf')", "N, M = map(int, input().split())\nroad = []\nfor i in range(M):\n  a, b, c = map(int, input().split())\n  road.append((a-1, b-1, -c))\n\nINF = 10**15\nd = [INF] * N\nd[0] = 0\ndef bellman_ford():\n  nonlocal d\n  for i in range(N):\n    for a, b, c in road:\n      d[b] = min(d[b], d[a] + c)\n\nbellman_ford()\nfor a, b, c in road:\n  new_d = d[a] + c\n  if new_d < d[b]:\n    d[b] = - float('inf')\n\nbellman_ford()\nif d[-1] > -float('inf'):\n  print(int(-d[-1]))\nelse:\n  print('inf')", "n,m=map(int,input().split())\nedge=[list(map(int,input().split())) for i in range(m)]\nnode=[-float('inf') for i in range(n+1)]\nnode[1]=0\ninf=False\nfor i in range(2*n+1):\n  loop=False\n  for s,e,c in edge:\n    if node[e]<node[s]+c:\n      node[e]=node[s]+c\n      if e==n:\n        loop=True\n  if i>=n and loop:\n    inf=True\n    break\nif inf:\n  print('inf')\nelse:\n  print(node[-1])", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\ndef solve():\n    N, M = list(map(int, rl().split()))\n    graph = []\n    for _ in range(M):\n        a, b, c = list(map(int, rl().split()))\n        a -= 1\n        b -= 1\n        c *= -1\n        graph.append([a, b, c])\n    \n    def bellman_ford(s):\n        dist_ls = [10 ** 15] * N\n        dist_ls[s] = 0\n        for i in range(N):\n            for u, v, w in graph:\n                if dist_ls[u] + w < dist_ls[v]:\n                    dist_ls[v] = dist_ls[u] + w\n                    if i == N - 1 and v == N - 1:\n                        return -1\n        return dist_ls\n    \n    dist = bellman_ford(0)\n    if dist == -1:\n        print('inf')\n    else:\n        print((-dist[-1]))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n, m = list(map(int, input().split()))\n\ndef bellman_ford(s):\n    d = [float('inf')] * n\n    d[s] = 0\n    # \u6ce8\u610f\u70b9\u3068\u3057\u3066\u3001\u9589\u8def\u3092\u63a2\u7d22(=\u30b9\u30b3\u30a2\u304c\u66f4\u65b0\u3055\u308c\u305f\u304b\u78ba\u304b\u3081\u308b)\u305f\u3081\u306bn*2\u56de\u5b9f\u884c\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n    for i in range(n*2):\n        for edge in g:\n            if edge[0] != float('inf') and d[edge[1]] > d[edge[0]] + edge[2]:\n                d[edge[1]] = d[edge[0]] + edge[2]\n                if i>=n-1 and edge[1] == n-1:\n                    return -1\n    return d\n\ng = []\nfor _ in range(m):\n    a,b,c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    c *= -1\n    g.append([a,b,c])\n\nret = bellman_ford(0)\n\nif isinstance(ret, list):\n    print((-1 * ret[n-1]))\nelse:\n    print('inf')\n\n", "from scipy.sparse.csgraph import connected_components, bellman_ford, NegativeCycleError\nfrom scipy.sparse import csr_matrix\n\nN, M = list(map(int, input().split()))\nfrm, to, length = [], [], []\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    frm.append(a - 1)\n    to.append(b - 1)\n    length.append(-c)\n\n# N-1\u21920\u306e\u8fba\u3092\u8ffd\u52a0\u3057\u3066\u304b\u3089\u537f\u9023\u7d50\u5224\u5b9a\u21d2\u30b4\u30fc\u30eb\u306b\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u9589\u8def\u3092\u9664\u5916\nconnect_check = csr_matrix(([1] * (M + 1), (frm + [N - 1], to + [0])), shape=(N, N))\n_, labels = connected_components(connect_check, connection='strong')\nlabel_num = labels[0]\nfrm_c, to_c, length_c = [], [], []\nfor i in range(M):\n    if labels[frm[i]] == labels[to[i]] == label_num:\n        frm_c.append(frm[i])\n        to_c.append(to[i])\n        length_c.append(length[i])\n\nmatr = csr_matrix((length_c, (frm_c, to_c)), shape=(N, N))\n\ntry:\n    ans = -int(bellman_ford(matr, indices=0)[N - 1])\n    print(ans)\nexcept NegativeCycleError:\n    print('inf')\n", "import sys\nN, M = map(int, input().split())\nedge = [list(map(int, input().split())) for _ in range(M)]\n\nINF = 1 << 60\ncost = [- INF] * (N + 1)\ncost[1] = 0\n\nfor i in range(N):\n    for n, nn, c in edge:\n        if cost[nn] < cost[n] + c:\n            # \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\u306e\u6027\u8cea\u3088\u308a\u3001N\u56de\u76ee\u306b\u66f4\u65b0\u304c\u3042\u308b\u306a\u3089inf\n            if i == N - 1 and nn == N:\n                print(\"inf\")\n                return\n            cost[nn] = cost[n] + c\n\nprint(cost[N])", "import sys\nsys.setrecursionlimit(10**7)\ndef main():\n    N, M = list(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        G[a - 1].append((b - 1, c))\n    INF = 10 ** 40\n    S = [-INF] * N\n    S[0] = 0\n\n    def helper(n, s, hist):\n        for g, gc in G[n]:\n            if S[g] >= s + gc or S[g] >= INF:\n                continue\n            S[g] = s + gc\n            if g in hist:\n                S[g] = INF\n            hist[g] = hist.get(g, 0) + 1\n            helper(g, S[g], hist)\n            hist[g] -= 1\n            if hist[g] == 0:\n                del hist[g]\n    helper(0, 0, {0: 1})\n    s = S[-1]\n    return s if s < INF else 'inf'\n\nprint((main()))\n", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  visited[u]=True\n  if u==N:\n    reachable[u]=True\n    return True\n  elif reachable[u]!=None:\n    return reachable[u]  \n\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    reachable[u]=False\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "n,m=map(int,input().split())\nedge=[list(map(int,input().split())) for i in range(m)]\nnode=[-float('inf') for i in range(n+1)]\nnode[1]=0\ninf=False\nfor i in range(2*n+1):\n  change=False\n  for s,e,c in edge:\n    if node[e]<node[s]+c:\n      node[e]=node[s]+c\n      if e==n:\n        change=True\n  if i>=n and change:\n    inf=True\nif inf:\n  print('inf')\nelse:\n  print(node[-1])", "def bellman_ford():#\uff8c\uff8d\uff72\uff9b\u691c\u51fa\n    n,m=list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for i in range(m):\n        a,b,c=list(map(int, input().split()))\n        g[a-1].append([b-1,-1*c])\n    dist = [float(\"inf\")]*n\n    inf = float(\"inf\")\n    dist[0] = 0\n    for i in range(n):\n        for v in range(n):\n            for k in range(len(g[v])):\n                edge = g[v][k]\n                if(dist[v]!=inf and dist[v]+edge[1] < dist[edge[0]]):#dist[v]!=10000:\u672a\u5230\u9054\u3060\u3063\u305f\u3089\u7121\u8996\u3059\u308b\u306e\u3067\n                    dist[edge[0]] = dist[v] + edge[1]\n\n    ans = dist[n-1]\n    neg = [0]*n\n\n    for i in range(n):\n        for edge in g[i]:\n            if(dist[i]==inf):continue\n            if(dist[i]+edge[1] < dist[edge[0]]):\n                dist[edge[0]] = dist[i]+edge[1]\n                neg[edge[0]]=1\n            if(neg[i]):\n                neg[edge[0]]=1\n\n\n\n    if(not neg[n-1]):\n        print((dist[n-1]*-1))\n    else:\n        print(\"inf\")\n\n    return False\n\n\ndef main():\n    bellman_ford()\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\ndef solve():\n    N, M = list(map(int, rl().split()))\n    graph = []\n    for _ in range(M):\n        a, b, c = list(map(int, rl().split()))\n        a -= 1\n        b -= 1\n        c *= -1\n        graph.append([a, b, c])\n    \n    def bellman_ford(s):\n        dist_ls = [10 ** 15] * N\n        dist_ls[s] = 0\n        for i in range(N):\n            for s, t, w in graph:\n                if dist_ls[s] + w < dist_ls[t]:\n                    dist_ls[t] = dist_ls[s] + w\n                    if i == N - 1 and t == N - 1:\n                        return -1\n        return dist_ls\n    \n    dist = bellman_ford(0)\n    if dist == -1:\n        print('inf')\n    else:\n        print((-1 * dist[-1]))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "N, M = map(int, input().split())\nedges = []\nE = [[] for _ in range(N)]\n\nfor _ in range(M):\n    fr, to, cost = map(int, input().split())\n    fr -= 1\n    to -= 1\n    edges.append((fr, to, -cost))\n    E[to].append(fr)\n\ndef canGo():\n    st = [N - 1]\n    visited = [False] * N\n    visited[N - 1] = True\n    while st:\n        for to in E[st.pop()]:\n            if visited[to]:\n                continue\n            visited[to] = True\n            st.append(to)\n    return visited\n\nV = canGo()\n\nminDist = [float('inf')] * N\nminDist[0] = 0\n\nfor i in range(N + 1):\n    for fr, to, cost in edges:\n        d = minDist[fr] + cost\n        if minDist[to] > d:\n            if i == N and V[to]:\n                print('inf')\n                return\n            minDist[to] = d\n\nprint(-minDist[N - 1])", "import queue\ndef bfs(G, s):\n    st = set()\n    q = queue.Queue()\n    st.add(s)\n    q.put(s)\n    while not q.empty():\n        p = q.get()\n        for v, _ in G[p]:\n            if not v in st:\n                st.add(v)\n                q.put(v)\n    return st\n\ndef solve(G, st):\n    n = len(G)\n    score = [-float(\"inf\")]*n\n    score[0] = 0\n    for i in range(n):\n        f = True\n        for s in range(n):\n            for t, u in G[s]:\n                if not s in st or not t in st:\n                    continue\n                if score[t] < score[s] + u:\n                    f = False\n                    score[t] = score[s] + u\n        if f:\n            break\n        if i == n-1:\n            return \"inf\"\n    return score[n-1]\n\ndef main():\n    n, m = map(int, input().split())\n    G = [[] for _ in range(n)]\n    revG = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        a, b = a-1, b-1\n        G[a].append([b, c])\n        revG[b].append([a, c])\n    st1 = bfs(G, 0)\n    st2 = bfs(revG, n-1)\n    st = st1 & st2\n    print(solve(G, st))\n\ndef __starting_point():\n    main()\n__starting_point()", "# solution\nimport io\n\nnim,mike=map(int,input().split())\n\nabc=[list(map(int,input().split())) for _ in [0]*mike]\n\ng=[[] for _ in [0]*nim]\n[g[a-1].append([b-1,c]) for a,b,c in abc]\n\ndist=[-10**15 for _ in [0]*nim]\ndist[0]=0\na,b=-10**15,-10**15\n\nfor _ in range(nim):\n    for p in range(nim):\n        for i,j in g[p]:\n            dist[i]=max(dist[i],dist[p]+j)\n    a,b=b,dist[nim-1]\n\nif a==b:\n    print(a)\nelse:\n    print(\"inf\")", "N, M = map(int, input().split())\nedges = []\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    edges.append([a, b, -c])\ndef bellman_ford(edges, N):\n    dist = [float('inf') for i in range(N)]\n    dist[0] = 0\n    for i in range(N-1):\n        for edge in edges:\n            if dist[edge[1] - 1] > dist[edge[0] - 1] + edge[2]:\n                dist[edge[1] - 1] = dist[edge[0] - 1] + edge[2]\n    negative = [False] * N\n\n    for i in range(N):\n        for edge in edges:\n            if dist[edge[1] - 1] > dist[edge[0] - 1] + edge[2]:\n                dist[edge[1] - 1] = dist[edge[0] - 1] + edge[2]\n                negative[edge[1] - 1] = True\n            if negative[edge[0] - 1] == True:\n                negative[edge[1] - 1] =True\n    \n    return 'inf' if negative[-1] else -dist[-1]\n\nprint(bellman_ford(edges, N))", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(s,u):\n  if u==N:\n    reachable_list[s]=True\n    return True\n  \n  visited[u]=True\n  for v in graph[u]:\n    if not visited[v]:\n      check_reachable(s,v)    \n  return False\n\nreachable_list=[False]*(N+1)\nfor i in range(1,N+1):\n  visited=[False]*(N+1)\n  check_reachable(i,i)\n#print(reachable_list)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable_list[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "n, m = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges.append((a, b, -c))\n\ninit_v = 0\nINF = float('inf')\ndist = [INF]*n\ndist[init_v] = 0\nfor i in range(n):\n    for v, v2, c in edges:\n        if dist[v2] <= dist[v]+c:\n            continue\n        dist[v2] = dist[v]+c\n\nnegative = [0]*n\nfor i in range(n):\n    for v, v2, c in edges:\n        if dist[v2] <= dist[v]+c:\n            continue\n        dist[v2] = dist[v]+c\n        negative[v2] = 1\n\nif negative[-1]:\n    print('inf')\nelse:\n    print(-dist[-1])", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nABC = [list(map(int, input().split())) for _ in range(m)]\ndist = [-float(\"inf\")]*(n+1)\ndist[1] = 0\nfor i in range(n):\n  for a, b, c in ABC:\n    if dist[b] < dist[a]+c:\n      if i == n-1 and b == n:\n        print(\"inf\")\n        return\n      dist[b] = dist[a]+c\nans = dist[n]\nprint(ans)", "from collections import deque\nN,M = map(int,input().split())\n\nABC = []\nAdake = [[] for _ in range(N)]\nBdake = [[] for _ in range(N)]\nfor i in range(M):\n    a,b,c = map(int, input().split())\n    ABC.append((a-1,b-1,-c))\n    Adake[a-1].append(b-1)\n    Bdake[b-1].append(a-1)\n\ndef dfs(X,s):\n    used = {s}\n    search = deque([s])\n    while search:\n        ss = search.pop()\n        for sss in X[ss]:\n            if sss in used:\n                continue\n            used.add(sss)\n            search.append(sss)\n    return used\n\nU = dfs(Adake,0) & dfs(Bdake,N-1)\nABC = [(a,b,c) for (a,b,c) in ABC if a in U and b in U]\n\nINF = float('inf')\ndist = [INF] * N\ndist[0] = 0\nfor i in range(N):\n    for a,b,c in ABC:\n        if dist[b] > dist[a] + c:\n            dist[b] = dist[a] + c\n            if i==N-1 and b == N-1:\n                print('inf')\n                return\nprint(-dist[-1])", "n,m=map(int,input().split())\nedge=[]\nfor i in range(m):\n  a,b,c=map(int,input().split())\n  edge.append([a,b,-c])\ncheck=[False for i in range(n+1)]\ninf=False\nnode=[float('inf') for i in range(n+1)]\nnode[1]=0\nfor i in range(n-1):\n  for s,e,c in edge:\n    if node[e]>node[s]+c:\n      node[e]=node[s]+c\nfor i in range(n):\n  for s,e,c in edge:\n    if node[e]>node[s]+c:\n      node[e]=node[s]+c\n      check[e]=True\n    if check[s]:\n      check[e]=True\nif check[-1]:\n  print('inf')\nelse:\n  print(-node[-1])", "n, m = map( int, input().split() )\nedge_list = []\nfor _ in range( m ):\n    a_i, b_i, c_i = map( int, input().split() )\n    edge_list.append( ( a_i - 1, b_i - 1, - c_i ) )\n\nINF = 10 ** 15\ncost = [ INF ] * n\ncost[ 0 ] = 0\n\nNegativeLoopExist = False\nfor i in range( n ):\n    for j in range( m ):\n        a, b, c = edge_list[ j ]\n        if cost[ a ] != INF and cost[ b ] > cost[ a ] + c:\n            cost[ b ] = cost[ a ] + c\n            if i == n - 1 and b == n - 1 :\n                NegativeLoopExist = True\n\nif NegativeLoopExist:\n    print( \"inf\" )\nelse:\n    print( - cost[ n - 1 ] )", "import sys\nrl=sys.stdin.readline\n\ndef main():\n    n,m=list(map(int,rl().strip().split()))\n    eaw=[list(map(int,rl().strip().split())) for _ in range(m)]\n    d=dict(((x[0]-1,x[1]-1),-x[2]) for x in eaw)\n    inf=10**14\n    mdl=[inf]*n\n    mdl[0]=0\n    def blrelax(dl,k):\n        for _ in range(k):\n            for e in iter(d):\n                if dl[e[0]]+d[e]<dl[e[1]]:\n                    dl[e[1]]=dl[e[0]]+d[e]\n    blrelax(mdl,n-1)\n    a1=mdl[n-1]\n    blrelax(mdl,n)\n    a2=mdl[n-1]\n    if a1>a2:\n        print('inf')\n    else:\n        print((-a1))\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "def Bellman_Ford(s, g, inf=1 << 60):\n    # https://tjkendev.github.io/procon-library/python/graph/bellman-ford.html\n    N = len(g)\n    dist = [inf] * N\n    dist[s] = 0\n\n    for _ in range(N):\n        not_updated = True\n        for v in range(N):\n            for u, c in g[v]:\n                if (dist[v] == inf) or (dist[v] + c >= dist[u]): continue\n                dist[u] = dist[v] + c\n                not_updated = False\n        if not_updated: break\n\n    else:\n        # \u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308b\n        ret = dist[N - 1]\n        for v in range(N):\n            for u, c in g[v]:\n                if (dist[v] == inf) or (dist[v] + c >= dist[u]): continue\n                dist[u] = dist[v] + c\n\n        if ret == dist[N - 1]:\n            return -ret\n        else:\n            return 'inf'\n\n    return -dist[N - 1]\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10 ** 7)\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        g[a].add((b, -c))\n\n    ans = Bellman_Ford(s=0, g=g)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\nedge = []\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edge.append([a-1, b-1, -c])\n\nd = [float(\"inf\") for _ in range(n)]\nd[0] = 0\n\ncheck = [0 for _ in range(n)]\n\nfor i in range(n):\n    for now, next, weight in edge:\n        if d[next] > d[now] + weight:\n            d[next] = d[now] + weight\n            if i == n-1:\n                check[next] = 1\n        if i == n-1:\n            if check[now]:\n                check[next] = 1\n\nif check[-1]:\n    print(\"inf\")\nelse:\n    print(-d[-1])", "n,m=map(int,input().split(' '))\npiece=[0]*m\nfor i in range(m):\n    piece[i]=tuple(map(int,input().split(' ')))\n\nnode=[0]+[float('inf')]*(n-1)\n\nfor v in range(n-1):\n    for e in range(m):\n        a,b,c=piece[e]\n        if node[b-1] > node[a-1]-c:\n            node[b-1] = node[a-1]-c\nans=node[n-1]\nfor e in range(m):\n    a,b,c=piece[e]\n    if node[b-1] > node[a-1] - c:\n        node[b-1] = node[a-1] -c\n\nif ans != node[n-1]:\n    print('inf')\nelse:\n    print(-ans)", "N,M,*L = map(int, open(0).read().split())\ndic = [[] for i in range(N+1)]\nrdic = [[] for i in range(N+1)]\nfor a,b,c in zip(*[iter(L)]*3):\n  dic[a].append(b)\n  rdic[b].append(a)\n\nok1 = [False]*(N+1)\nok1[1] = True\nq = [1]\nwhile q:\n  p = q.pop()\n  for v in dic[p]:\n    if not ok1[v]:\n      ok1[v] = True\n      q.append(v)\nok2 = [False]*(N+1)\nok2[N] = True\nq = [N]\nwhile q:\n  p = q.pop()\n  for v in rdic[p]:\n    if not ok2[v]:\n      ok2[v] = True\n      q.append(v)\nok = [a&b for a,b in zip(ok1,ok2)]\ncnt = 0\ndist = [-10**20]*(N+1)\ndist[1] = 0\nwhile True:\n  flag = True\n  for a,b,c in zip(*[iter(L)]*3):\n    if ok[a]&ok[b] and ok[a]!=-10**20 and dist[b]<dist[a]+c:\n      flag = False\n      dist[b] = dist[a]+c\n  if flag:\n    print(dist[N])\n    break\n  cnt += 1\n  if cnt>N:\n    print('inf')\n    break", "import sys\ninput = sys.stdin.readline\n\ndef readlines(n):\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        yield a, b, c\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [(a-1, b-1, -c) for a, b, c in readlines(m)]\n    costs = bellman_ford(0, edges, n)\n\n    if costs == -1:\n        print(\"inf\")\n    else:\n        print(-costs[-1])\n\ndef bellman_ford(start, edges, n):\n    inf = float(\"inf\")\n    costs = [inf] * n\n    costs[start] = 0\n    for i in range(n):\n        for u, v, weight in edges:\n            if costs[u] + weight < costs[v]:\n                costs[v] = costs[u] + weight\n                if i == n - 1 and v == n - 1:\n                    return -1\n\n    return costs\n\nmain()", "def solve(V,E,r,edges):\n    cost=[-float('inf')]*V\n    cost[r]=0\n    for _ in range(V-1):\n        for edge in edges:\n            s=edge[0]\n            t=edge[1]\n            d=edge[2]\n            if cost[t]<cost[s]+d:\n                cost[t]=cost[s]+d\n    ans=cost[V-1]\n    for _ in range(V-1):\n        for edge in edges:\n            s=edge[0]\n            t=edge[1]\n            d=edge[2]\n            if cost[t]<cost[s]+d:\n                cost[t]=cost[s]+d\n    if ans!=cost[V-1]:\n        return float('inf')\n    return ans\n            \n\n\n\nV,E=map(int,input().split())\nedges=[]\nfor _ in range(E):\n    s,t,d=map(int,input().split())\n    s-=1\n    t-=1\n    edges.append(tuple((s,t,d)))\nans=solve(V,E,0,edges)\nif ans==float('inf'):\n    print(\"inf\")\nelse:\n    print(ans)", "N, M = map(int, input().split())\ninf = 10**18\nedges = []\n\nfor m in range(M):\n    a, b, c = map(int, input().split())\n    edges.append((a-1, b-1, -c))\n\ndist = [inf]*N\ndist[0] = 0\nupdate = False\nfor i in range(N):\n    for a, b, c in edges:\n        if dist[b]>dist[a]+c:\n            dist[b] = dist[a]+c\n            if b==N-1 and i==N-1:\n                update = True\n\nif update:\n    print('inf')\nelse:\n    print(-dist[N-1])", "n, m = map(int, input().split())\nNINF = -10**20\nedge = []\ndist = [NINF]*n\ndist[0] = 0\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edge.append((a-1, b-1, c))\nfor i in range(n):\n    for a, b, c in edge:\n        if dist[a]!=NINF and dist[b] < dist[a] + c:\n            dist[b] = dist[a] + c\n            if i==n-1 and b==n-1:\n                print('inf')\n                return\nprint(dist[-1])", "def BellmanFord():\n    def BF(s, n, edge, inf=float(\"inf\")):\n        d = [inf for i in range(n)]\n        d[s] = 0\n        for i in range(n):\n            for before, after, dist in edge:\n                if before != inf:\n                    d[after] = min(d[after], d[before] + dist)\n            if i == n - 2:\n                t = d[:]\n            elif i == n - 1:\n                for i, j in enumerate(d):\n                    if j != t[i]:\n                        d[i] = -inf\n        return list(map(lambda x: -x, d))\n    n, m = map(int, input().split())\n    inf = 10 ** 20\n    edge = [list(map(int, input().split())) for i in range(m)]\n    edge = [[x - 1, y - 1, -z] for x, y, z in edge]\n    l = BF(0, n, edge)\n    print(l[-1] if l[-1] < inf else \"inf\")\nBellmanFord()", "import sys\nINF = float(\"inf\")\n\n\ndef Bellmanford(n, edges, r):  # r\u306f\u59cb\u70b9\n    d = [INF] * n\n    d[r] = 0\n\n    for i in range(n):\n        for (u, v, c) in edges:\n            if d[u] != INF and d[u] + c < d[v]:\n                d[v] = d[u] + c\n                if i == n - 1 and v == n - 1:\n                    return \"inf\"\n    return -d[n-1]\n\n\nN, M = map(int, sys.stdin.readline().split())\nEdges = [None] * M\nfor i in range(M):\n    ai, bi, ci = map(int, sys.stdin.readline().split())\n    Edges[i] = (ai - 1, bi - 1, -ci)\n\nans = Bellmanford(N, Edges, 0)\nprint(ans)", "N, M = map(int, input().split())\nedges = [None]*M\nINF = 10**18\n\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    edges[i] = (a-1, b-1, -c)\n    \ndef bellman(n, edges, r):\n    d = [INF] * n\n    d[r] = 0\n    \n    for i in range(n):\n        for (u, v, c) in edges:\n            if(d[u] != INF and d[u]+c < d[v]):\n                d[v] = d[u] + c\n                if(i == n-1 and v == n-1):\n                    return \"inf\"\n                \n    return -d[-1]\n    \nans = bellman(N, edges, 0)\nprint(ans)", "#\u8ca0\u306e\u7d4c\u8def\u306e\u691c\u51fa\ndef find_negative_loop(n, es, d):\n    #\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n    check = [0 for _ in range(n)]\n    for _ in range(n):\n        for p, q, r in es:\n            #e: \u8fbai\u306b\u3064\u3044\u3066\n            if d[p] != float(\"inf\") and d[q] > d[p] + r:\n                d[q] = d[p] + r\n                check[q] = True\n            if check[p]:\n                check[q] = True\n                # if i == n-1:\n                #     return True\n    return check\n\ndef shortest_path(s, n, es):\n    #s -> i\u3000\u306e\u6700\u77ed\u7d4c\u8def\n    #s: \u59cb\u70b9\u3001n: \u9802\u70b9\u6570\u3001w:\u8fba\u306e\u6570\u3001es[i]: [\u8fba\u306e\u59cb\u70b9\u3001\u8fba\u306e\u7d42\u70b9\u3001\u8fba\u306e\u30b3\u30b9\u30c8]\n    d = [float(\"inf\")] * n\n    #d[i]: s->i\u306e\u6700\u77ed\u8ddd\u96e2\n    d[s] = 0\n    for _ in range(n):\n        update = False\n        for p, q, r in es:\n            #e: \u8fbai\u306b\u3064\u3044\u3066\n            if d[p] != float(\"inf\") and d[q] > d[p] + r:\n                d[q] = d[p] + r\n                update = True\n        # print(update)\n        if not update:\n            break\n    return d\n\nn,w = map(int,input().split()) #n:\u9802\u70b9\u6570\u3000w:\u8fba\u306e\u6570\nes = [] #es[i]: [\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n\nfor _ in range(w):\n    x,y,z = map(int,input().split())\n    es.append([x-1, y-1, -z])\n    # es.append([y,x,z])\n\n# print(shortest_path(0, n, es))\n# print(es)\n\n# if find_negative_loop(n,es):\n\nd = shortest_path(0, n, es)\n\n# print(d)\n\nc = find_negative_loop(n, es, d)\n# print(c)\n\n\n\nif c[-1]:\n    print(\"inf\")\nelse:\n    # d = shortest_path(0, n, es)\n    print(-d[-1])", "INF = float('inf')\nclass BellmanFord:\n    \n    def bellmanford(self,s,V,E):\n        dist = [INF for _ in range(V)]\n        dist[s] = 0\n        for i in range(V):\n            for e in E:\n                u,v,cost = e\n                if dist[u] != INF and dist[v] > dist[u] + cost:\n                    dist[v] = dist[u]+cost\n                    if i == V-1 and v == V-1:\n                        return -1\n        return dist\n    \n\ndef main():\n    N,M = map(int,input().split())\n    E = []\n    for _ in range(M):\n        a,b,c = map(int,input().split())\n        a -= 1\n        b -= 1\n        E.append((a,b,-c))\n    bf = BellmanFord()\n    dist = bf.bellmanford(0,N,E)\n    if dist == -1:\n        print('inf')\n    else:\n        ans = dist[-1]\n        print(-ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m=map(int,input().split())\nabc=[tuple(map(int,input().split())) for _ in range(m)]\nInf=float('inf')\ndist=[Inf]*n\ndist[0]=0\nfor i in range(n):\n    for a,b,c in abc:\n        a,b,c=a-1,b-1,-c\n        if dist[b] >dist[a]+c:\n            dist[b]=dist[a]+c\n            if i==n-1 and b==n-1:\n                print('inf')\n                return\nprint(-dist[-1])", "N,M = list(map(int,input().split()))\nabc = []\nfor _ in range(M):\n    abc.append(list(map(int,input().split())))\n\ncost = [-(10**10)*N]*N\ncost[0] = 0\n\nfor i in range(N):\n    update = False\n    for a,b,c in abc:\n        a,b = a-1,b-1\n        if cost[a] != -(10**10)*N:\n            if cost[b] < cost[a] + c:\n                cost[b] = cost[a] + c\n                update = True\n    if i == 0:\n        Max = cost[N-1]\n    elif i < N-1:\n        Max = max(Max,cost[N-1])\n\n\nif update == True and Max < cost[N-1]:\n    print('inf')\nelse:\n    print(Max)\n", "N,M = list(map(int,input().split()))\nabc = []\nfor _ in range(M):\n    abc.append(list(map(int,input().split())))\n\ncost = [-float('inf')]*N\ncost[0] = 0\n\nfor i in range(2):\n    for a,b,c in abc:\n        a,b = a-1,b-1\n        cost[b] = max(cost[b], cost[a] + c)\n\n    if i == 0:\n        ans = cost[N-1]\n    else:\n        Max = cost[N-1]\n\n\nif ans != Max:\n    print('inf')\nelse:\n    print(ans)\n", "INF = -float(\"inf\")\n\ndef Bellmanford(n, edges):\n    dp = [INF] * n\n    dp[0] = 0\n\n    for i in range(n):  # \u305f\u304b\u3060\u304bn-1\u56de\u30eb\u30fc\u30d7\u3000n\u56de\u76ee\u3067\u307e\u3060\u66f4\u65b0\u3067\u304d\u305f\u3089\u8ca0\u9589\u8def\u304c\u3042\u308b\n        for u, v, c in edges:\n            if dp[u] != INF and dp[u] + c > dp[v]:\n                dp[v] = dp[u] + c\n                if i == n-1 and v == n-1:\n                    return \"inf\"\n\n    return dp[n-1]\n\n\nN, M = map(int, input().split())\nE = []\n\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n\nans = Bellmanford(N, E)\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  if u==N:\n    reachable[u]=True\n    return True\n  \n  visited[u]=True\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    return False\n\nreachable=[False]*(N+1)\nfor i in range(1,N+1):\n  if not reachable[i]:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef bellman_ford(edges, N, start):\n    dist = [float(\"inf\") for _ in range(N)]\n    dist[start] = 0\n    # \u8fba\u306e\u60c5\u5831\u3092\u898b\u308b\u3053\u3068\u30921\u30eb\u30fc\u30d7\u3068\u3059\u308b\u3068\n    # 1\u56de\u306e\u30eb\u30fc\u30d7\u3067,\u6700\u4f4e\u3067\u30821\u3064\u306e\u9802\u70b9\u306b\u3064\u3044\u3066\uff0c\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u6c42\u307e\u308b\n    # \u3064\u307e\u308a,\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u5168\u3066\u306e\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u306f\uff0c\n    # \u30b9\u30bf\u30fc\u30c8\u3092\u9664\u3044\u305f\u9802\u70b9\u306e\u6570\u3067\u3042\u308b,(N-1)\u56de\u306e\u30eb\u30fc\u30d7\u3067\u6c42\u307e\u308b\uff0e\n    for i in range(2 * N):\n        for fro, to, cost in edges:\n            if dist[to] > dist[fro] - cost:\n                dist[to] = dist[fro] - cost\n                # N\u56de\u76ee\u306b\u9802\u70b9\u306e\u66f4\u65b0\u304c\u3042\u308b\u3068\uff0c\u8ca0\u306e\u7d4c\u8def\u304c\u3042\u308b\n                if i == N - 1:\n                    dist[to] = -float(\"inf\")\n    return dist\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    edge = []\n    for i in range(M):\n        a, b, c = list(map(int, input().split()))\n        edge.append((a - 1, b - 1, c))\n    D = bellman_ford(edge, N, 0)\n\n    print((-1 * D[-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "INF = -float(\"inf\")\n \ndef Bellmanford(n, e):\n  dp = [INF] * n\n  dp[0] = 0\n  for i in range(n):\n    for a, b, c in e:\n      if dp[a] != INF and dp[a] + c > dp[b]:\n        dp[b] = dp[a] + c\n        if i == n-1 and b == n-1:\n          return \"inf\"\n  return dp[n-1]\n\nN, M=map(int, input().split())\n\nabc = []\nfor i in range(M):\n  a, b, c = map(int, input().split())\n  abc.append((a-1, b-1, c))\n\nans = Bellmanford(N, abc) \nprint(ans)", "import sys\n\n\nN, M = list(map(int, input().split()))\nedge = []\nfor s in sys.stdin.readlines():\n    a, b, c = list(map(int, s.split()))\n    edge.append((a - 1, b - 1, c))\n\npath = [-float('inf')] * N\npath[0] = 0\n\nfor i in range(N - 1):\n    for j in range(M):\n        a, b, c = edge[j]\n        if path[b] < path[a] + c:\n            path[b] = path[a] + c\n\n\nfor i in range(N - 1):\n    for j in range(M):\n        a, b, c = edge[j]\n        if path[b] < path[a] + c:\n            path[b] = float('inf')\n\nprint((path[-1]))\n", "import sys\nsys.setrecursionlimit(10**7)\n\nN, M = list(map(int, input().split()))\n\nR = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    R[a - 1].append((b - 1, c))\n\nINF = 10 ** 40\nS = [-INF] * N\nS[0] = 0\n\ndef score(fst, s, C):\n    for nx, p in R[fst]:\n        if S[nx] >= s + p or S[nx] >= INF:\n            continue\n        S[nx] = s + p\n        if nx in C:\n            S[nx] = INF\n        C[nx] = C.get(nx, 0) + 1\n        score(nx, S[nx], C)\n        C[nx] -= 1\n        if C[nx] == 0:\n            del C[nx]\n\nscore(0, 0, {0: 1})\n\nif S[-1] < INF:\n    ans = S[-1]\nelse:\n    ans = \"inf\"\n\nprint(ans)\n", "def Bellman_Ford(s, g, inf=1 << 60):\n    # https://tjkendev.github.io/procon-library/python/graph/bellman-ford.html\n    N = len(g)\n    dist = [inf] * N\n    dist[s] = 0\n\n    for _ in range(N):\n        not_updated = True\n        for v in range(N):\n            for u, c in g[v]:\n                if (dist[v] == inf) or (dist[v] + c >= dist[u]): continue\n                dist[u] = dist[v] + c\n                not_updated = False\n\n        if not_updated:\n            return -dist[N - 1]\n\n    # \u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308b\n    ret = dist[N - 1]\n    for _ in range(N):\n        not_updated = True\n        for v in range(N):\n            for u, c in g[v]:\n                if (dist[v] == inf) or (dist[v] + c >= dist[u]): continue\n                dist[u] = dist[v] + c\n                not_updated = False\n        if not_updated: break\n\n    if ret == dist[N - 1]:\n        return -ret\n    else:\n        return 'inf'\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10 ** 7)\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        g[a].add((b, -c))\n\n    ans = Bellman_Ford(s=0, g=g)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  if u==N:\n    reachable[u]=True\n    return True\n  \n  visited[u]=True\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:        \n        reachable[u]=True\n        cnt+=1\n        \n  if cnt>0:\n    return True\n  else:\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "def bellman_ford(edges, N, start, end):\n    cost = [float(\"inf\") for _ in range(N)]\n    cost[start] = 0\n    negative = [False for _ in range(N)]\n\n    for i in range(N):\n        for j in range(len(edges)):\n            fro, to, c = edges[j]\n\n            if cost[to] > cost[fro] + c:\n                cost[to] = cost[fro] + c\n                # \u9802\u70b9\u306e\u6570\u3068\u540c\u3058\u56de\u6570\u30eb\u30fc\u30d7\u3059\u308b\u3068\u8ca0\u306e\u7d4c\u8def\u304c\u3042\u308b\n                if i == N - 1:\n                    negative[to] = True\n\n    if negative[end]:\n        return \"inf\"\n    else:\n        return -cost[end]\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    edges.append((a - 1, b - 1, -c))\n\ncost = [float(\"inf\") for _ in range(N)]\nstart = 0\nend = N - 1\nprint((bellman_ford(edges, N, start, end)))\n", "from collections import deque\ndef belman(s,n,w,es):\n    d = [-float(\"inf\")] * n #d[i] : s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n    d[s] = 0\n    c = 0\n    while True:\n      update = False\n      for p,q,r in es:\n        if d[p] != -float(\"inf\") and d[q] < d[p] + r:\n          d[q] = d[p] + r\n          update = True\n          c += 1\n        if c > w:\n          return 'inf'\n      if not update:\n        break\n    return d[n-1]\n\ndef use_path(n,start,es):\n    q = deque()\n    chk = [False] * n\n    q.append(start)\n    chk[start] = True\n    used = {start}\n    while len(q) > 0:\n        node = q.popleft()\n        for nex in es[node]:\n            if not chk[nex]:\n                chk[nex] = True\n                q.append(nex)\n                used.add(nex)\n    return used\n\nn,w = map(int,input().split())\nes = []\nl = [[] for i in range(n)]\nr = [[] for i in range(n)]\n\nfor i in range(w):\n    a,b,c = map(int, input().split())\n    a -= 1\n    b -= 1\n    l[a].append(b)\n    r[b].append(a)\n    es.append((a,b,c))\n\nuse = use_path(n,0,l) & use_path(n,n-1,r)\ness = [(a,b,c) for a,b,c in es if a in use and b in use]\nprint(belman(0,n,w*2,ess))", "def resolve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for i in range(m)]\n    a = [[x, y, -z] for x, y, z in a]\n    print(BF(a, n, 1)[-1])\n\n\ndef BF(p, n, s):\n    inf = float(\"inf\")\n    d = [inf for i in range(n)]\n    d[s-1] = 0\n    for i in range(n+1):\n        for e in p:\n            if e[0] != inf and d[e[1]-1] > d[e[0]-1]+e[2]:\n                d[e[1]-1] = d[e[0]-1] + e[2]\n        if i == n-1:\n            t = d[-1]\n        if i == n and t != d[-1]:\n            return [0, 'inf']\n    return list(map(lambda x: -x, d))\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  if u==N:\n    reachable[u]=True\n    return True\n  \n  visited[u]=True\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "def reachable(es, source):\n\tret = {source}\n\tQ = [source]\n\twhile Q:\n\t\tcur = Q.pop()\n\t\tfor nxt in es[cur]:\n\t\t\tif nxt not in ret:\n\t\t\t\tQ.append(nxt)\n\t\t\t\tret.add(nxt)\n\treturn ret\n\ndef BellmanFord(V: int, es: list, source=0):\n\tINF = float(\"inf\")\n\tD = [INF] * V\n\tD[source] = 0\n\tfor _ in range(V):\n\t\tupd = False\n\t\tfor f, t, c in es:\n\t\t\ttmp = D[f] + c\n\t\t\tif D[t] > tmp:\n\t\t\t\tD[t] = tmp\n\t\t\t\tupd = True\n\t\tif not upd:\n\t\t\treturn D[-1]\n\telse:\n\t\t# Negative Cycle\n\t\treturn None\n\n\ndef main():\n\tN, M, *L = map(int, open(0).read().split())\n\tfwd = [[] for _ in range(N)]\n\tbwd = [[] for _ in range(N)]\n\ttmp = []\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\t\tfwd[a - 1].append(b - 1)\n\t\tbwd[b - 1].append(a - 1)\n\t\ttmp += [(a - 1, b - 1, - c)]\n\tra = reachable(fwd, 0) & reachable(bwd, N - 1)\n\tans = BellmanFord(N, [(a, b, c) for a, b, c in tmp if a in ra and b in ra])\n\tif ans == None:\n\t\tprint(\"inf\")\n\telse:\n\t\tprint(-ans)\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "n, m = [int(i) for i in input().split()]\ne = [[int(i) for i in input().split()] for i in range(m)]\nv = [-(10 ** 9 * 2000)] * n\n\n# Bellman-Ford\nv[0] = 0\nfor i in range(n):\n    tmp = v[-1]\n    for a, b, cost in e:\n        if v[a-1] + cost > v[b-1]:\n            v[b-1] = v[a-1] + cost\n    if tmp != v[-1] and i == n-1: break        \nelse:\n    print((v[n-1]))\n    return\n\nprint(\"inf\")\n", "n, m = map( int, input().split() )\nedge_list = []\nfor _ in range( m ):\n    a_i, b_i, c_i = map( int, input().split() )\n    edge_list.append( ( a_i - 1, b_i - 1, - c_i ) )\n\nINF = 10 ** 13\ncost = [ INF ] * n\ncost[ 0 ] = 0\n\nNegativeLoopExist = False\nfor i in range( n ):\n    for j in range( m ):\n        a, b, c = edge_list[ j ]\n        if cost[ a ] != INF and cost[ b ] > cost[ a ] + c:\n            cost[ b ] = cost[ a ] + c\n            if i == n - 1 and b == n - 1:\n                NegativeLoopExist = True\n\nif NegativeLoopExist:\n    print( \"inf\" )\nelse:\n    print( - cost[ n - 1 ] )", "import sys\ninput = sys.stdin.readline\n\ndef bellmanford(G, s):\n    n = len(G)\n    inf = -float('inf')\n    dist = [inf] * n\n    dist[s] = 0\n    for i in range(n):\n        for v in range(n):\n            for w, c in G[v]:\n                if dist[w] < dist[v] + c:\n                    dist[w] = dist[v] + c\n                    if i >= n - 1 and w == n - 1:\n                        return -1\n    return dist\n\ndef main():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].append((b, c))\n    dist = bellmanford(graph, 0)\n    if dist == -1:\n        print(\"inf\")\n    else:\n        print(dist[N-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = map(int, input().split())\nINF = float(\"inf\")\n\nstart = []\nend = []\nweight = []\nnode_cost = [-INF] * N\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    start.append(a - 1)\n    end.append(b - 1)\n    weight.append(c)\n\nnode_cost[0] = 0\nfor _ in range(N - 1):\n    for i in range(M):\n        new_cost = node_cost[start[i]] + weight[i]\n        if new_cost > node_cost[end[i]]:\n            node_cost[end[i]] = new_cost\nans = node_cost[N-1]\ncycle = [False] * N\nfor _ in range(N):\n    for i in range(M):\n        if cycle[start[i]]:\n            cycle[end[i]] = True\n        new_cost = node_cost[start[i]] + weight[i]\n        if new_cost > node_cost[end[i]]:\n            cycle[end[i]] = True\nif cycle[N-1]:\n    ans = \"inf\"\nprint(ans)", "n, m = map(int, input().split())\nedges = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    a-=1; b-=1\n    edges.append((a, b, -c))\n\ndist = [float('inf')]*n\ndist[0] = 0\nfor i in range(n-1): # \u306a\u305c\uff1f\n    for st, en , score in edges:\n        if dist[st] == float('inf'): continue\n        if dist[en] > dist[st] + score:\n            dist[en] = dist[st] + score\n\nnegative = [False] * n\n\nfor loop in range(n):\n    for e in edges:\n        st, en, score = e\n        if dist[st] == float('inf'): continue\n        if dist[en] > dist[st] + score:\n            dist[en] = dist[st] + score\n            negative[en] = True\n        if negative[st]:\n            negative[en] = True\n\nif negative[n-1]:\n    print('inf')\nelse:\n    print(-dist[n-1])", "import sys\n\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    pass\n\n\ndef __starting_point():\n    main()\n\n\ndef bellman_ford(edges, N, start, goal):\n    dist = [float(\"inf\") for _ in range(N)]\n    dist[start] = 0\n\n    # \u8fba\u306e\u60c5\u5831\u3092\u898b\u308b\u3053\u3068\u30921\u30eb\u30fc\u30d7\u3068\u3059\u308b\u3068\n    # \u6700\u4f4e\u3067\u30821\u3064\u306e\u9802\u70b9\u306b\u3064\u3044\u3066\uff0c\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u6c42\u307e\u308b\n    # \u3064\u307e\u308a\uff0c\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u8ddd\u96e2\u306f\uff0c\u30b9\u30bf\u30fc\u30c8\u3092\u9664\u3044\u305f\u9802\u70b9\u306e\u6570\u3067\u3042\u308b\n    # (N-1)\u56de\u306e\u30eb\u30fc\u30d7\u3067\u6c42\u307e\u308b\uff0e\n    for i in range(N * 2):\n        for fro, to, cost in edges:\n            if dist[to] > dist[fro] + cost:\n                dist[to] = dist[fro] + cost\n                # N\u56de\u76ee\u306b\u9802\u70b9\u306e\u66f4\u65b0\u304c\u3042\u308b\u3068\uff0c\u8ca0\u306e\u7d4c\u8def\u304c\u3042\u308b\n                if i == N - 1:\n                    dist[to] = -float(\"inf\")\n\n    return -dist[goal]\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    edges.append((a - 1, b - 1, -c))\n\ncost = [float(\"inf\") for _ in range(N)]\nstart = 0\ngoal = N - 1\nans = bellman_ford(edges, N, start, goal)\nif ans == float(\"inf\"):\n    print(ans)\nelse:\n    print(ans)\n\n__starting_point()", "def bellman(s,n,es):\n    INF = float(\"inf\")\n    d = [INF] * n\n    d[s] = 0\n    for _ in range(n-1):\n        for p,q,r in es:\n            if d[p] != INF and d[q] > d[p] + r:\n                d[q] = d[p] + r\n\n    for _ in range(n-1):\n        for p,q,r in es:\n            if d[q] > d[p] + r:\n                d[q] = -INF\n    return d\n\nn,m = map(int,input().split())\ng = []\nfor _ in range(m):\n    vi,vj,w = map(int,input().split())\n    g.append([vi-1,vj-1,-w])\nprint(-bellman(0,n,g)[-1])", "import sys\nINF=float('inf')\ndef Bellmanford(n,edges,r):\n  d=[INF]*n\n  d[r]=0\n  for i in range(n):\n    for u,v,c in edges:\n      if d[u]!=INF and d[v]>d[u]+c:\n        d[v]=d[u]+c\n        if i==n-1 and v==n-1:\n          return 'inf'\n  return (-1)*d[n-1]\nn,m=map(int,input().split())\nedges=[0]*m\nfor i in range(m):\n  a,b,c=map(int,input().split())\n  edges[i]=(a-1,b-1,-c)\nans=Bellmanford(n,edges,0)\nprint(ans)", "v, e = map(int, input().split())\nr = 0\nINF = 10 ** 18\nedges = [[] for i in range(v)]\na, b, c = [], [], []\nd = [INF for i in range(v)]\nfor _ in range(e):\n    s, t, d_ = map(int, input().split())\n    edges[s - 1].append((t - 1, d_ * -1))\n    a.append(s - 1)\n    b.append(t - 1)\n    c.append(d_ * -1)\nf = False\nd[r] = 0\nfor _ in range(v):\n    for u in range(v):\n        if d[u] != INF:\n            for to, dist in edges[u]:\n                d[to] = min(d[to], d[u] + dist)\nnega = [False] * v\nfor _ in range(v):\n    for i in range(e):\n        if d[a[i]] == INF:\n            continue\n        if d[b[i]] > d[a[i]] + c[i]:\n            d[b[i]] = d[a[i]] + c[i]\n            nega[b[i]] = True\n        if nega[a[i]]:\n            nega[b[i]] = True\nif nega[-1]:\n    print(\"inf\")\nelse:\n    print(d[-1] * -1)", "import sys\n\nN, M = map(int,input().split())\nes = []\nfor _ in range(M):\n    e = list(map(int,input().split()))\n    e[2] *= -1\n    es.append(e)\n\nINF = float('inf')\nd = [INF for _ in range(N+1)]\nd[1] = 0\nnegative = [0 for _ in range(N+1)]\nfor i in range(N):\n    for j in range(M):\n        e = es[j]\n        if d[e[1]] > d[e[0]] + e[2]:\n            d[e[1]] = d[e[0]] + e[2]\n            if i == N-1:\n                negative[e[0]] = 1\n                negative[e[1]] = 1\nfor i in range(M):\n    e = es[i]\n    if negative[e[0]]:\n        negative[e[1]] = 1\nif negative[N]:\n    print('inf')\nelse:\n    print(-d[N])", "import sys\ninput = sys.stdin.readline\n\ndef bellmanford(G, s):\n    n = len(G)\n    inf = -float('inf')\n    dist = [inf] * n\n    dist[s] = 0\n    for i in range(2*n):\n        for v in range(n):\n            for w, c in G[v]:\n                if dist[w] < dist[v] + c:\n                    dist[w] = dist[v] + c\n                    if i >= n - 1 and w == n-1:\n                        return -1\n    return dist\n\ndef main():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].append((b, c))\n    dist = bellmanford(graph, 0)\n    if dist == -1:\n        print(\"inf\")\n    else:\n        print(dist[N-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "def bellman_ford(s):\n    d = [float('inf')]*(N+1) # \u5404\u9802\u70b9\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\n    d[s] = 0 # \u81ea\u8eab\u3078\u306e\u8ddd\u96e2\u306f0\n    nega = [0 for i in range(N+1)]\n    for i in range(N+1):\n        update = False # \u66f4\u65b0\u304c\u884c\u308f\u308c\u305f\u304b\n        for x, y, z in g:\n            if d[y] > d[x] + z:\n                d[y] = d[x] + z\n                update = True\n                nega[y] += 1\n        if not update:\n            break\n        # \u8ca0\u9589\u8def\u304c\u5b58\u5728\n        if i == N :\n          d[0] = -1\n    return [d,nega]\n\nN,M = map(int,input().split())\ng = []\n\nfor _ in range(M):\n    x, y, z = [int(x) for x in input().split()] # \u59cb\u70b9,\u7d42\u70b9,\u30b3\u30b9\u30c8\n    g.append([x, y, -z])\n\nans = bellman_ford(1)\n\nif ans[1][-1] > 1:\n  print(\"inf\")\nelse:\n  print(int(-ans[0][-1]))", "n, m = list(map(int, input().split()))\n# from, to, cost\nedges = [list(map(int, input().split())) for _ in range(m)]\n\nscore = [-float('inf')] * (n+1)\nscore[1] = 0\ncnt = 0\n\nfor i in range(n):\n    for frm, to, cost in edges:\n        if score[to] < score[frm] + cost:\n            if i == n - 1 and to == n:\n                print('inf')\n                return\n            score[to] = score[frm] + cost\n\nprint((score[n]))\n", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  visited[u]=True\n  if u==N:\n    reachable[u]=True\n    return True\n  elif reachable[u]!=None:\n    return reachable[u]  \n\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "N,M = map(int,input().split())\nABC = [tuple(map(int,input().split())) for i in range(M)]\n\nINF = float('inf')\ndist = [INF] * N\ndist[0] = 0\nfor i in range(N):\n    for a,b,c in ABC:\n        a,b,c = a-1,b-1,-c\n        if dist[b] > dist[a] + c:\n            dist[b] = dist[a] + c\n            if i==N-1 and b == N-1:\n                print('inf')\n                return\nprint(-dist[-1])", "n,m=map(int,input().split())\n#g=[[]for _ in range(n)]\nabc=[list(map(int,input().split())) for _ in range(m)]\nabc=[[a-1,b-1,-c] for a,b,c in abc]\n# BellmanFord\n# \u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u6cd5\ndef BellmanFord(edges,num_v,source):\n  #\u30b0\u30e9\u30d5\u306e\u521d\u671f\u5316\n  inf=float(\"inf\")\n  dist=[inf for i in range(num_v)]\n  dist[source]=0  \n  #\u8fba\u306e\u7de9\u548c\n  for i in range(num_v):\n    for edge in edges:\n      if dist[edge[0]] != inf and dist[edge[1]] > dist[edge[0]] + edge[2]:\n        dist[edge[1]] = dist[edge[0]] + edge[2]\n        #if i==num_v-1: return -1\n  negative=[False]*n\n  for i in range(num_v):\n    for edge in edges:\n      if negative[edge[0]]:negative[edge[1]]=True\n      if dist[edge[0]] != inf and dist[edge[1]] > dist[edge[0]] + edge[2]:\n        negative[edge[1]] = True\n  return dist[n-1],negative[n-1]\nc,d=BellmanFord(abc,n,0)\n# \u8ca0\u306e\u9589\u8def\u306bN\u304c\u542b\u307e\u308c\u306a\u3044\u6642\u306finf\u3058\u3083\u306a\u3044\nif d:\n  print('inf')\nelse:\n  print(-c)", "n, m = map(int, input().split())\nNINF = -10**20\nedge = []\ndist = [NINF]*n\ndist[0] = 0\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edge.append((a-1, b-1, c))\nfor i in range(2*n):\n    for a, b, c in edge:\n        if dist[a]!=NINF and dist[b] < dist[a] + c:\n            dist[b] = dist[a] + c\n            if i>=n-1 and b==n-1:\n                print('inf')\n                return\nprint(dist[-1])", "# -*- coding:utf-8 -*-\nclass BellmanFord():\n    \"\"\"\u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u6cd5\u3067\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\"\"\"\n    def __init__(self, s, V):\n        \"\"\"\n        Args:\n            s(int): \u59cb\u70b9\n            V(int): \u9802\u70b9\u6570\n        \"\"\"\n        self.graph = {}\n        for i in range(V):\n            self.graph[i] = []\n        self._V = V\n        self.dst = [float(\"inf\") for _ in range(V)]\n        self.dst[s] = 0\n\n    @property\n    def dist(self):\n        return self.dst\n\n    @property\n    def V(self):\n        return self._V\n\n    def add(self, a, b, cost):\n        \"\"\"\u9802\u70b9a\u304b\u3089\u9802\u70b9b\u3078\u306e\u30b3\u30b9\u30c8\u306fcost\"\"\"\n        self.graph[a].append((b, cost))\n\n    def shortest_path(self):\n        \"\"\"\u59cb\u70b9s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\n        Returns:\n            (bool): \u8ca0\u306e\u9589\u8def\u304c\u5b58\u5728\u3059\u308b(True) / \u5b58\u5728\u3057\u306a\u3044(False)\n        \"\"\"\n        for t in range(self.V):\n            update = False\n            for u in range(self.V):\n                if self.dst[u] == float(\"inf\"): continue\n                for v, cost in self.graph[u]:\n                    if self.dst[v] > self.dst[u] + cost:\n                        self.dst[v] = self.dst[u] + cost\n                        update = True\n\n                        if t == self.V-1 and v == self.V-1:\n                            return True\n\n            if not update:\n                break\n\n        return False\n\n\ndef solve():\n    N, M = list(map(int, input().split()))\n    bf = BellmanFord(0, N)\n\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        bf.add(a-1, b-1, -c)\n\n    nloop = bf.shortest_path()\n\n    if nloop:\n        print(\"inf\")\n    else:\n        print((-bf.dist[N-1]))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nN,M = map(int, input().split())\nabc = [[] for _ in range(N)]\nfor i in range(M):\n    a,b,c = map(int, input().split())\n    abc[a-1].append((b-1,c))\n    \nS = [-float(\"inf\")]*N\nS[0] = 0\nT = [0]\nm = 0\nn = 0\nj = False\nwhile T:\n    t = T.pop(0)\n    m += 1\n    for tb,tc in abc[t]:\n        if S[tb] < S[t]+tc:\n            S[tb] = S[t]+tc\n            T.append(tb)\n    if m > M+1:\n        d = abc[tb]\n        if N-1 in list(d[i][0] for i in range(len(d))):\n            j = True\n        n += 1\n    if n > M:\n        if j:\n            print(\"inf\")\n            return\n        else:\n            break\n\nprint(S[-1])", "INF = 10**30\nimport sys\nsys.setrecursionlimit(10**6)\ndef bellman_ford(s, t, g):\n    d = [INF for _ in range(n)] # \u5404\u9802\u70b9\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\n    d[s] = 0 # \u81ea\u8eab\u3078\u306e\u8ddd\u96e2\u306f0\n    val_at_t = INF # \u4e0b\u8a18\u53c2\u7167\n    for i in range(n):\n        #update = False # \u66f4\u65b0\u304c\u884c\u308f\u308c\u305f\u304b\n        for x, y, z in g:\n            if d[y] > d[x] + z:\n                d[y] = d[x] + z\n                #update = True\n        # \u8ca0\u9589\u8def\u304c\u5b58\u5728\u3057\u3066\u3001\u70b9t\u306e\u5024\u304c\u66f4\u65b0\u3055\u308c\u7d9a\u3051\u3066\u3044\u308b\u5834\u5408\n        if i == n-1 and val_at_t > d[t]:\n            return []\n        val_at_t = d[t] #\u70b9t\u306e\u73fe\u5728\u306e\u5024\n    return d\n\nn, m = list(map(int, input().split())) # n:\u9802\u70b9\u6570, m:\u8fba\u306e\u6570\ng = []\nfor _ in range(m):\n    x, y, z = list(map(int, input().split())) # \u59cb\u70b9,\u7d42\u70b9,\u30b3\u30b9\u30c8\n    x -= 1\n    y -= 1\n    z *= -1\n    g.append([x, y, z])\n    \nans = bellman_ford(0, n-1, g)\n#print(ans)\nprint((-ans[n-1] if ans else \"inf\"))\n", "# ABC061 D - Score Attack\nimport sys\nN, M = map(int, input().split())\nedge = [list(map(int, input().split())) for _ in range(M)]\n\nINF = 1 << 60\ncost = [- INF] * (N + 1)\ncost[1] = 0\n\nfor i in range(N):\n    for n, nn, c in edge:\n        if cost[nn] < cost[n] + c:\n            # \u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u6cd5\u306e\u6027\u8cea\u3088\u308a\u3001N\u56de\u76ee\u306b\u66f4\u65b0\u304c\u3042\u308b\u306a\u3089inf\n            if i == N - 1 and nn == N:\n                print(\"inf\")\n                return\n            cost[nn] = cost[n] + c\n\nprint(cost[N])", "n,m = map(int, input().split())\nfrom collections import defaultdict\nG = defaultdict(dict)\nfor i in range(1,n):\n    G[i+1] = {}\nfor i in range(m):\n    a,b,c = map(int, input().split())\n    G[a][b] = c\nstart_vertex = 1\ndef bellmanford(G, start_vertex):\n    if start_vertex not in G:\n        return -1, -1\n    distances = {}\n    parents   = {}\n    for node in G:\n        distances[node] = float('-inf')\n        parents[node]   = None\n    distances[start_vertex] = 0\n    for _ in range(len(G)-1):\n        for node in G.keys():\n            for neighbor in G[node]:\n                if distances[neighbor] < distances[node] + G[node][neighbor]:\n                    distances[neighbor] = distances[node] + G[node][neighbor]\n                    parents[neighbor]   = node\n    pathnode = n\n    while pathnode != start_vertex:\n        for neighbor in G[pathnode]:\n            if distances[neighbor] < distances[pathnode] + G[pathnode][neighbor]:\n                print('inf' , flush=True)\n                return -1,-1\n        pathnode = parents[pathnode]\n    return distances, parents\ndistances, parents = bellmanford(G, start_vertex)\nif distances != -1:\n    print(distances[n] , flush=True)\n", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  if u==N:\n    reachable[u]=True\n    return True\n  \n  visited[u]=True\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        reachable[u]=True\n        cnt+=1\n        \n  if cnt>0:\n    return True\n  else:\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "n, m = list(map(int, input().split()))\na = [0] * m\nb = [0] * m\nc = [0] * m\nINF = float('inf')\ndist = [INF] * n\ndist[0] = 0\nfor i in range(m):\n    a[i], b[i], c[i] = list(map(int, input().split()))\n    a[i] -= 1\n    b[i] -= 1\n    c[i] *= -1\nfor loop in range(n - 1):\n    for i in range(m):\n        if dist[a[i]] == INF:\n            continue\n        if dist[b[i]] > dist[a[i]] + c[i]:\n            dist[b[i]] = dist[a[i]] + c[i]\nans = dist[n - 1]\n\nneg = [False] * n\nfor loop in range(n):\n    for i in range(m):\n        if dist[b[i]] > dist[a[i]] + c[i]:\n            dist[b[i]] = dist[a[i]] + c[i]\n            neg[b[i]] = True\n        if neg[a[i]]:\n            neg[b[i]] = True\nif neg[n - 1]:\n    print('inf')\nelse:\n    print((-ans))\n", "N,M = list(map(int,input().split()))\n\nfrom collections import deque\nls = [deque([]) for _ in range(N)]\n\nfor i in range(M):\n    a,b,c = list(map(int,input().split()))\n    a,b = a-1,b-1\n    ls[a].append([b,c])\ncost = [-(10**10)*N]*N\ncost[0] = 0\n\nfor i in range(N):\n    update = False\n    q = [deque(m for m in l) for l in ls]\n    for j in range(N):\n        if cost[j] != -(10**10)*N:\n            while q[j]:\n                b,c = q[j].pop()\n                if cost[b] < cost[j] + c:\n                    cost[b] = cost[j] + c\n                    update = True\n    if i == 0:\n        Max = cost[N-1]\n    elif i < N-1:\n        Max = max(Max,cost[N-1])\n\nif update == True and Max < cost[N-1]:\n    print('inf')\nelse:\n    print(Max)\n", "# longest version bellman ford\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    edges.append((a-1, b-1, c))\n\n\ninf = float(\"inf\")\ndist = [-inf for i in range(N)]\ndist[0] = 0\nis_cycle = False\n\n#\u8fba\u306e\u7de9\u548c\nfor i in range(N):\n    for edge in edges:\n        new_dist = dist[edge[0]] + edge[2]\n        if dist[edge[1]] < new_dist:\n            dist[edge[1]] = new_dist\n            if i==N-1 and edge[1] == N-1:\n                is_cycle = True\n\nans = dist[-1] if not is_cycle else 'inf'\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 8)\nINF = 10 ** 15\n\nclass edge:\n    def __init__(self, fr, to, cost):\n        self.fr, self.to, self.cost = fr, to, cost\n\ndef input(): return sys.stdin.readline().strip()\ndef Z(): return int(input())\ndef ZZ(): return [int(_) for _ in input().split()]\n\ndef main():\n    N, M = ZZ()\n    es = []\n    for _ in range(M):\n        a, b, c = ZZ()\n        a -= 1\n        b -= 1\n        es.append(edge(a, b, -c))\n\n    #\u8ca0\u306e\u9589\u8def\u691c\u51fa\n    d = [0] * N\n    for i in range(N):\n        for e in es:\n            if d[e.to] > d[e.fr] + e.cost:\n                d[e.to] = d[e.fr] + e.cost\n                if e.to == N-1 and i == N-1:\n                    print('inf')\n                    return\n    #\u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u3059\u308b\n    d = [INF] * N\n    d[0] = 0\n    for _ in range(N-1):\n        update = False\n        for e in es:\n            if d[e.fr] != INF and d[e.to] > d[e.fr] + e.cost:\n                d[e.to] = d[e.fr] + e.cost\n                update = True\n        if not update: break\n    print((-d[N-1]))\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nclass DSU:\n    def __init__(self, n):\n        self._n = n\n        self.parent_or_size = [-1] * n\n\n    def merge(self, a, b):\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        x, y = self.leader(a), self.leader(b)\n        if x == y: return x\n        if -self.parent_or_size[x] < -self.parent_or_size[y]: x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n\n    def same(self, a, b):\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a):\n        assert 0 <= a < self._n\n        if self.parent_or_size[a] < 0: return a\n        self.parent_or_size[a] = self.leader(self.parent_or_size[a])\n        return self.parent_or_size[a]\n\n    def size(self, a):\n        assert 0 <= a < self._n\n        return -self.parent_or_size[self.leader(a)]\n\n    def groups(self):\n        leader_buf = [self.leader(i) for i in range(self._n)]\n        result = [[] for _ in range(self._n)]\n        for i in range(self._n): result[leader_buf[i]].append(i)\n        return [r for r in result if r != []]\n\nclass Fenwick_Tree:\n    def __init__(self, n):\n        self._n = n\n        self.data = [0] * n\n\n    def add(self, p, x):\n        assert 0 <= p < self._n\n        p += 1\n        while p <= self._n:\n            self.data[p - 1] += x\n            p += p & -p\n\n    def sum(self, l, r):\n        assert 0 <= l <= r <= self._n\n        return self._sum(r) - self._sum(l)\n\n    def _sum(self, r):\n        s = 0\n        while r > 0:\n            s += self.data[r - 1]\n            r -= r & -r\n        return s\nINF = float('inf')\ndef Bellmanford(n, edges, r): #r: \u59cb\u70b9\n    d = [INF] * n\n    d[r] = 0\n    \n    for i in range(n):\n        for (u, v, c) in edges:\n            if d[u] != INF and d[u] + c < d[v]:\n                d[v] = d[u] + c\n                if i == n-1 and v == n-1:\n                    return 'inf'\n    \n    return -d[n-1]\nN, M = map(int, sys.stdin.readline().split())\nEdges = [None] * M\n\nfor i in range(M):\n    ai, bi, ci = map(int, sys.stdin.readline().split())\n    Edges[i] = (ai-1, bi-1, -ci)\n    \nans = Bellmanford(N, Edges, 0)\n\nprint(ans)  ", "class Edge:\n\n    def __init__(self, from_node, to_node, weight):\n        self.from_node = from_node\n        self.to_node = to_node\n        self.weight = weight\n\n\ndef bellman_ford(N, edges, start, goal):\n    # Weight Maximization\n    MIN_INF = - 10**15\n    d = [MIN_INF for _ in range(N)]\n    d[start] = 0\n    for loop in range(N):\n        updated = False\n        goal_updated = False\n        for edge in edges:\n            new_d = edge.weight + d[edge.from_node]\n            if d[edge.to_node] < new_d:\n                d[edge.to_node] = new_d\n                updated = True\n                if edge.to_node == goal:\n                    goal_updated = True\n        if not updated:\n            return d[goal]\n        if loop == N - 1:\n            if not goal_updated:\n                return d[goal]\n            # exists a positive loop which connected to the goal node.\n            return None\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    edges = list()\n    for _ in range(M):\n        a, b, c = list(map(int, input().split(' ')))\n        from_node = a - 1 \n        to_node = b - 1\n        weight = c\n        edges.append(Edge(from_node, to_node, weight))\n    start, goal = 0, N - 1\n    result = bellman_ford(N, edges, start, goal)\n    if result is None:\n        print('inf')\n    else:\n        print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\ngraph = [tuple(map(int, input().split())) for _ in range(m)]\n\ndef shortest_path(s):\n    MIN = -1 * 10 ** 12\n    d = [MIN] * (n + 1)\n    d[s] = 0\n    update = True\n    cnt = 1\n    tmp = MIN\n    while update:\n        update = False\n        for a, b, c in graph:\n            if d[a] != MIN and d[b] < d[a] + c:\n                d[b] = d[a] + c\n                update = True\n        if cnt == m: tmp = d[n]\n        if update and cnt == 2 * m and d[n] > tmp: return 'inf'\n        if cnt == 2 * m: update = False\n        cnt += 1\n    return d[n]\n\nprint(shortest_path(1))", "import sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  \n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  visited[u]=True\n  if u==N:\n    reachable[u]=True\n    return True\n  elif reachable[u]!=None:\n    return reachable[u]  \n\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    reachable[u]=False\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[a] and reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])", "INF = float(\"inf\")\n\ndef Bellmanford(n, edges):\n    dp = [INF] * n\n    dp[0] = 0\n\n    for i in range(n):  # \u305f\u304b\u3060\u304bn-1\u56de\u30eb\u30fc\u30d7\u3000n\u56de\u76ee\u3067\u307e\u3060\u66f4\u65b0\u3067\u304d\u305f\u3089\u8ca0\u9589\u8def\u304c\u3042\u308b\n        for u, v, c in edges:\n            if dp[u] != INF and dp[u] + c < dp[v]:\n                dp[v] = dp[u] + c\n                if i == n-1 and v == n-1:\n                    return \"inf\"\n\n    return -dp[n-1]\n\n\nN, M = map(int, input().split())\nE = []\n\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, -c))\n\nans = Bellmanford(N, E)\n\nprint(ans)", "n, m = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges.append((a, b, -c))\n\ninit_v = 0\nINF = float('inf')\ndist = [INF]*n\ndist[init_v] = 0\nnegative_cycle = 0\nfor i in range(2*n):\n    for v, v2, c in edges:\n        if dist[v2] <= dist[v]+c:\n            continue\n        dist[v2] = dist[v]+c\n        if i >= n-1 and v2 == n-1:\n            negative_cycle = 1\n\nif negative_cycle:\n    print('inf')\nelse:\n    print(-dist[-1])", "N,M = map(int,input().split())\nE = [list(map(int,input().split())) for m in range(M)]\ndp = (N+1)*[float(\"inf\")]\ndp[1] = 0\n\nfor n in range(N):\n  for a,b,c in E:\n    dp[b] = min(dp[b],dp[a]-c)\n\nx = dp[N]\n\nfor a,b,c in E:\n  dp[b] = min(dp[b],dp[a]-c)\n\nif x!=dp[N]:\n  print(\"inf\")\nelse:\n  print(-x)"]
["from itertools import permutations\nfrom bisect import bisect_left\ninf = 10 ** 18\nmod = 10 ** 9 + 7\n\n\ndef nCr(n, r, mod=10**9+7):\n    if r < 0 or r > n:\n        return 0\n    res = 1\n    div = 1\n    r = min(r, n - r)\n    for i in range(r):\n        res = res * (n - i) % mod\n        div = div * (i + 1) % mod\n    return res * pow(div, mod-2, mod) % mod\n\n\ndef calc_lis(A):\n    L = [A[0]]\n    for a in A[1:]:\n        if a > L[-1]:\n            L.append(a)\n        else:\n            L[bisect_left(L, a)] = a\n    return len(L)\n\n\ndef enum(N, A):\n    diff = [A[0]] + [r - l for l, r in zip(A[:-1], A[1:])]\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            for k in range(i - 1, j + 1):\n                dp[i][j] += dp[i - 1][k] * nCr(diff[i - 1], j - k)\n                dp[i][j] %= mod\n    return dp[N][N]\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    pair = [(0,)]\n    for _ in range(1, N):\n        nxt = []\n        for p in pair:\n            v = p[-1]\n            nxt.append(p + (v,))\n            nxt.append(p + (v+1,))\n        pair = nxt\n\n    ans = 0\n    for p in pair:\n        sz = p[-1] + 1\n        for order in set(permutations(p)):\n            arr = [inf] * sz\n            for i, a in zip(order, A):\n                arr[i] = min(arr[i], a)\n            for i in reversed(range(sz - 1)):\n                arr[i] = min(arr[i], arr[i + 1])\n            ans += enum(sz, arr) * calc_lis(order)\n            ans %= mod\n    for a in A:\n        ans *= pow(a, mod - 2, mod)\n        ans %= mod\n    print(ans)\n\n\nmain()", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nN=int(input())\nA=list(map(int,input().split()))\n\nmod=1000000007\n\ndef Combi(a,b):# a\u306f\u5927\u304d\u3044\u304c\u3001b\u306f\u5c0f\u3055\u3044\u3068\u304d\n    if b>a:\n        return 0\n    \n    ANS=1\n    for i in range(min(b,a-b)):\n        ANS=ANS*(a-i)*pow(min(b,a-b)-i,mod-2,mod)%mod\n\n    return ANS%mod\n\ndef alltuple(A):\n    #print(A)\n    ANS=[]\n    MAX=max(A)\n\n    if min(A)!=-1:\n        return [tuple(A)]\n\n    LEN=len(A)\n    for i in range(LEN):\n        if A[i]==-1:\n            if MAX!=-1:\n                A[i]=MAX\n                ANS+=alltuple(A)\n            A[i]=MAX+1\n            ANS+=alltuple(A)\n            A[i]=-1\n            \n    return ANS\n\nALLX=set(alltuple([-1]*N))\n\ndef LIS(A):\n    LEN=len(A)\n    DP=[float(\"inf\")]*LEN # DP[i]\u3067\u3001\u9577\u3055i\u306eLIS\u306e\u6700\u7d42\u8981\u7d20\u306e\u6700\u5c0f\u5024.\n\n    for a in A:\n        pos=bisect.bisect_left(DP,a)\n        DP[pos]=a\n\n    ANS=0\n    for i in range(LEN):\n        if DP[i]!=float(\"inf\"): # float(\"inf\")\u3067\u306a\u3044\u6700\u5c0f\u306e\u3082\u306e\u304cLIS\u306e\u9577\u3055\n            ANS=i\n            \n    return ANS+1\n\nANS=0\nKOSUU=0\n\nfor tu in ALLX:\n    LIS_tu=LIS(tu)\n\n    B=[]\n    for i in range(max(tu)+1):\n        MIN=1<<30\n        for j in range(N):\n            if tu[j]==i:\n                MIN=min(MIN,A[j])\n        B.append(MIN)\n\n    for i in range(len(B)-2,-1,-1):\n        B[i]=min(B[i],B[i+1])\n\n    SB=[0]+sorted(set(B))\n\n    compression_dict={a: ind for ind, a in enumerate(SB)}\n    BC=[compression_dict[m] for m in B]\n\n    LEN=len(B)\n    DPLEN=len(SB)\n    DP=[[0]*(DPLEN) for i in range(LEN+1)]\n    DP[0][0]=1\n\n    for i in range(LEN):\n        for j in range(DPLEN):\n            if DP[i][j]==0:\n                continue\n\n            for k in range(j+1,DPLEN):\n                if k>BC[i]:\n                    break\n                for l in range(i+1,LEN+1):\n                    DP[l][k]+=DP[i][j]*Combi(SB[k]-SB[k-1],l-i)\n                    DP[l][k]%=mod\n\n    KOSUU+=sum(DP[-1])\n    ANS+=sum(DP[-1])*LIS_tu\n\nprint(ANS*pow(KOSUU,mod-2,mod)%mod)", "SIZE=10; MOD=10**9+7 #998244353 #\u3053\u3053\u3092\u5909\u66f4\u3059\u308b\ninv = [0]*SIZE\ninv[1] = 1\nfor i in range(2,SIZE):\n    inv[i] = MOD - (MOD//i)*inv[MOD%i]%MOD\n\ndef solve(a):\n    n = len(a)\n    for i in range(n-2,-1,-1):\n        if a[i] > a[i+1]: a[i] = a[i+1]\n    if a[0] < 0: return 0\n    A = a[-1]+1\n    res = [[0,0,1]]\n    for ai in a:\n        val = 0\n        for r in res:\n            bi,ki,ti = r\n            val += ti\n            r[1] += 1\n            r[2] = r[2]*(A-bi+ki+1)%MOD*inv[ki+1]%MOD\n        res.append([ai+1,1,-val%MOD*(A-ai)%MOD])\n    return sum(r[2] for r in res)%MOD\n\nfrom bisect import bisect_left\ndef LIS(a):\n    n = len(a)\n    dp = [n+1]*n\n    for i in a:\n        dp[bisect_left(dp,i)] = i\n    return bisect_left(dp,n+1)\n\nfrom itertools import permutations\nn = int(input())\n*a, = map(int, input().split())\nans = 0\nfor x in permutations(range(n)):\n    b = [a[i]-1 for i in x]\n    offset = 0\n    for i in range(n):\n        b[i] -= offset\n        if i+1<n and x[i] < x[i+1]:\n            offset += 1\n    ans += LIS(x)*solve(b)\n    ans %= MOD\n\nc = 1\nfor i in a:\n    c *= i\n    c %= MOD\nans *= pow(c,MOD-2,MOD)\nprint(ans%MOD)", "MOD = 10**9+7\nfrom itertools import product\nfrom bisect import bisect\nfrom collections import Counter\n\ndef lis(N, A):\n\tINF = 1000\n\tdp = [INF]*(N+1)\n\tdp[0] = -1\n\tfor a in A:\n\t\tidx = bisect(dp, a-1)\n\t\tdp[idx] = min(a, dp[idx])\n\treturn max(i for i in range(N+1) if dp[i] < INF)\t\n\ndef multisigma(n, x):\n\tres = 1\n\tfor i in range(n):\n\t\tres *= x - i\n\t\tres *= pow(i+1, MOD-2, MOD)\n\t\tres %= MOD\n\treturn res\n\ndef dfs(R, num, tmp):\n\tnonlocal ans\n\t#print(R, num, tmp)\n\tn = len(R)\n\tif tmp == n:\n\t\t#print(R, lis(n, R))\n\t\tans += num * lis(n, R)\n\t\tans %= MOD\n\t\treturn\n\tl = len(space[tmp])\n\tif l == 0:\n\t\tdfs(R, num, tmp+1)\n\t\treturn\n\tfor P in product(range(l), repeat=l):\n\t\tP = list(P)\n\t\tm = len(set(P))\n\t\tif m != max(P) + 1:\n\t\t\tcontinue\n\t\tif m > zone[tmp]:\n\t\t\tcontinue\n\t\tfor x, y in zip(P, space[tmp]):\n\t\t\tR[y] = x + tmp * 10\n\t\tnxt = (num * multisigma(m, zone[tmp])) % MOD\n\t\tdfs(R, nxt, tmp+1)\n\treturn\n\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(list(set(a)))\nzone = [b[0]]\nfor i in range(1, len(b)):\n\tzone.append(b[i] - b[i-1])\nd = dict()\ntmp = 0\nh = [-1 for _ in range(n)]\nfor i, z in enumerate(zone):\n\ttmp += z\n\td[tmp] = i\nfor i, x in enumerate(a):\n\th[i] = d[x]\n#print(h)\nk = len(zone)\nans = 0\nfor P in product(range(k), repeat=n):\n\tok = True\n\tP = list(P)\n\tfor i, p in enumerate(P):\n\t\tif p > h[i]:\n\t\t\tok = False\n\t\t\tbreak\n\tif not ok:\n\t\tcontinue\n\tspace = [[] for _ in range(n)]\n\tfor i, p in enumerate(P):\n\t\tspace[p].append(i)\n\tc = Counter(P)\n\tR = [-1 for _ in range(n)]\n\tdfs(R, 1, 0)\nfor x in a:\n\tans *= pow(x, MOD-2, MOD)\n\tans %= MOD\nprint(ans)", "import itertools\nP = 10 ** 9 + 7\nfainv = [1, 1, 500000004, 166666668, 41666667, 808333339, 301388891]\ndef C(a, b):\n    s = 1\n    for i in range(b):\n        s = s * (a - i) % P\n    return s * fainv[b] % P\n\ndef calc(LL):\n    L = LL[:]\n    K = len(L)\n    for i in range(K - 1)[::-1]:\n        L[i] = min(L[i], L[i+1])\n    for i in range(1, K)[::-1]:\n        L[i] -= L[i-1]\n    # print(\"L =\", L)\n    X = [0] * K\n    f = 1\n    re = 0\n    cnt = 0 # Check\u7528\n    while f:\n\n        # \u3053\u3053\u306b\u51e6\u7406\u3092\u66f8\u304f\n        # if cnt < 20: print(\"cnt, X =\", cnt, X)\n        for x1, x2 in zip(X, X[1:]):\n            if x1 > x2:\n                break\n        else:\n            Y = [0] * K\n            for x in X:\n                Y[x] += 1\n            t = 1\n            for j, y in enumerate(Y):\n                t = t * C(L[j], y) % P\n            # print(\"X, Y, t =\", X, Y, t)\n            re += t\n        cnt += 1 # Check\u7528\n\n        X[0] += 1\n        i = 0\n        while X[i] == i + 1: # \u3053\u3053\u306bi\u756a\u76ee\u306e\u7d42\u4e86\u6761\u4ef6\u3092\u66f8\u304f\n            X[i] = 0\n            i += 1\n            if i >= K:\n                f = 0\n                break\n            X[i] += 1\n\n    # print(cnt)\n    return re\n\n# print(calc([4, 4, 4]))\n\nN = int(input())\nQ = list(itertools.permutations(range(N)))\nA = [int(a) for a in input().split()]\n# print(\"Q =\", Q)\ndef LIS(l):\n    n = len(l)\n    X = [-1] + [n] * n\n    for a in l:\n        for i in range(n, -1, -1):\n            if X[i] < a:\n                X[i+1] = a\n                break\n    for i in range(n, -1, -1):\n        if X[i] < n:\n            return i\n\nans = 0\nchk = 0\nfor q in Q:\n    # print(q, LIS(q))\n    L = []\n    s = 0\n    for i in range(N):\n        if i and q[i-1] >= q[i]:\n            s += 1\n        L.append(A[q[i]] + s)\n    calcL = calc(L)\n    LISq = LIS(q)\n    chk += calcL\n    # print(\"q =\", q, L, calcL, LISq)\n    ans += calcL * LISq\n    if ans >= P: ans -= P\n# print(\"chk = \", chk)\ns = 1\nfor a in A:\n    s = s * a % P\n\nans = ans * pow(s, P-2, P) % P\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nN=int(input())\nA=list(map(int,input().split()))\n\nmod=1000000007\n\ndef Combi(a,b):# a\u306f\u5927\u304d\u3044\u304c\u3001b\u306f\u5c0f\u3055\u3044\u3068\u304d\n    if b>a:\n        return 0\n    \n    ANS=1\n    for i in range(min(b,a-b)):\n        ANS=ANS*(a-i)*pow(min(b,a-b)-i,mod-2,mod)%mod\n\n    return ANS%mod\n\ndef alltuple(A):\n    #print(A)\n    ANS=[]\n    MAX=max(A)\n\n    if min(A)!=-1:\n        return [tuple(A)]\n\n    LEN=len(A)\n    for i in range(LEN):\n        if A[i]==-1:\n            if MAX!=-1:\n                A[i]=MAX\n                ANS+=alltuple(A)\n            A[i]=MAX+1\n            ANS+=alltuple(A)\n            A[i]=-1\n            \n    return ANS\n\nALLX=set(alltuple([-1]*N))\n\ndef LIS(A):\n    LEN=len(A)\n    DP=[float(\"inf\")]*LEN # DP[i]\u3067\u3001\u9577\u3055i\u306eLIS\u306e\u6700\u7d42\u8981\u7d20\u306e\u6700\u5c0f\u5024.\n\n    for a in A:\n        pos=bisect.bisect_left(DP,a)\n        DP[pos]=a\n\n    ANS=0\n    for i in range(LEN):\n        if DP[i]!=float(\"inf\"): # float(\"inf\")\u3067\u306a\u3044\u6700\u5c0f\u306e\u3082\u306e\u304cLIS\u306e\u9577\u3055\n            ANS=i\n            \n    return ANS+1\n\nANS=0\nKOSUU=0\n\nfor tu in ALLX:\n    LIS_tu=LIS(tu)\n\n    B=[]\n    for i in range(max(tu)+1):\n        MIN=1<<30\n        for j in range(N):\n            if tu[j]==i:\n                MIN=min(MIN,A[j])\n        B.append(MIN)\n\n    for i in range(len(B)-2,-1,-1):\n        B[i]=min(B[i],B[i+1])\n\n    SB=[0]+sorted(set(B))\n\n    compression_dict={a: ind for ind, a in enumerate(SB)}\n    BC=[compression_dict[m] for m in B]\n\n    LEN=len(B)\n    DPLEN=len(SB)\n    DP=[[0]*(DPLEN) for i in range(LEN+1)]\n    DP[0][0]=1\n\n    for i in range(LEN):\n        for j in range(DPLEN):\n            if DP[i][j]==0:\n                continue\n\n            for k in range(j+1,DPLEN):\n                if k>BC[i]:\n                    break\n                for l in range(i+1,LEN+1):\n                    DP[l][k]+=DP[i][j]*Combi(SB[k]-SB[k-1],l-i)\n                    DP[l][k]%=mod\n\n    KOSUU+=sum(DP[-1])\n    ANS+=sum(DP[-1])*LIS_tu\n\nprint(ANS*pow(KOSUU,mod-2,mod)%mod)", "from bisect import bisect_left\ndef LIS(N, A):\n  A = list(A)\n  lis = []\n  for i in range(N):\n    ind = bisect_left(lis,A[i])\n    if ind == len(lis):\n      lis.append(A[i])\n    else:\n      lis[ind] = A[i]\n  return len(lis)\n\ndef comb(n,r):\n  if not 0<=r<=n:\n    return 0\n  ans = 1\n  for i in range(r):\n    ans *= n-i\n  for i in range(r):\n    ans //= i+1\n  return ans\n\ndef compress(arr):\n  XS = list(set(arr))\n  XS.sort()\n  dic = {e: i for i, e in enumerate(XS)}\n  for i in range(len(arr)):\n    arr[i] = dic[arr[i]]\n  return arr\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\nN = int(input())\nA = list(map(int, input().split()))\nmod = 10**9+7\nfrom collections import defaultdict\ndef gutyoku(N,A):\n  cnt = 0\n  for a in range(1,A[0]+1):\n    if N==1:\n      B = [a]\n      cnt += LIS(N,B)\n      continue\n    for b in range(1,A[1]+1):\n      if N==2:\n        B = [a,b]\n        cnt += LIS(N,B)\n        continue\n      for c in range(1,A[2]+1):\n        if N==3:\n          B = [a,b,c]\n          cnt += LIS(N,B)\n          continue\n        for d in range(1,A[3]+1):\n          if N==4:\n            B = [a,b,c,d]\n            cnt += LIS(N,B)\n            continue\n          for e in range(1,A[4]+1):\n            if N==5:\n              B = [a,b,c,d,e]\n              cnt += LIS(N,B)\n              continue\n            for f in range(1,A[5]+1):\n              B = [a,b,c,d,e,f]\n              cnt += LIS(N,B)\n  return cnt\ndef solve(N,A):\n  ans = 0\n  dic = defaultdict(lambda: 0)\n  # debug = defaultdict(lambda: [0,0])\n  for pro in product([0,1],repeat=N-1):\n    lis = [1]*N\n    pro = list(pro)\n    for i in range(N-1):\n      lis[i+1] = lis[i]+pro[i]\n    for perm in permutations(lis,N):\n      if dic[perm]==1:\n        continue\n      dic[perm] = 1\n      num = max(perm)\n      lis2 = [0]+[10**10]*num\n      for i,p in enumerate(perm):\n        lis2[p] = min(lis2[p],A[i])\n      for i in range(num-1,0,-1):\n        lis2[i] = min(lis2[i], lis2[i+1])\n      # cnt = 0\n      # j = 0\n      # cum = 1\n      # for i in range(1,num+1):\n      #   if lis2[i]-lis2[j]==0:\n      #     continue\n      #   if j-1>=0:\n      #     cum *= comb(lis2[i-1]-lis2[j-1],i-j)\n      #   cnt += cum*comb(lis2[i]-lis2[j],num+1-i)\n      #   j = i\n      comp = lambda arr: {i: e for i, e in enumerate(sorted(set(arr)))}\n      compdic = comp(lis2)\n      complis2 = compress(lis2[:])\n      M = max(complis2)\n      dp = [[0]*(M+1) for _ in range(num+1)]\n      dp[0][0] = 1\n      for i in range(1,num+1):\n        for j in range(1,complis2[i]+1):\n          for k in range(j):\n            dp[i][j] += dp[i-1][k]*(compdic[j]-compdic[j-1])\n          for k in range(i-1,0,-1):\n            if complis2[k]<j:\n              break\n            dp[i][j] += sum(dp[k-1][:j])*comb(compdic[j]-compdic[j-1], i-k+1)\n      ans += sum(dp[-1])*LIS(N,perm)\n      # debug[tuple(lis2)][0] = sum(dp[-1])\n      # debug[tuple(lis2)][1] += LIS(N,perm)\n      # print(list(perm),lis2,sum(dp[-1]),LIS(N,perm))\n  # for k,v in debug.items():\n    # print(k,v)\n  return ans\n# ans1 = gutyoku(N,A)\nans2 = solve(N,A)\nfor i in range(N):\n  ans2 *= pow(A[i],mod-2,mod)\n  ans2 %= mod\nprint(ans2)\n# if ans1!=ans2:\n  # print(ans1,ans2)\n\n"]
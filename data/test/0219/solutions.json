["n, m, s, d = list(map(int, input().split()))\n\nbeg = [float('-inf')]\nend = [float('-inf')]\n\na = [int(i) for i in input().split()]\n\nfor x in sorted(a):\n\tif (x - end[-1] > s + 1):\n\t\tbeg.append(x)\n\t\tend.append(x)\n\telse:\n\t\tend[-1] = x\n\nlast = 0\nR = []\nJ = []\n\nfor i in range(1, len(beg)):\n\tR.append(beg[i] - 1 - last)\n\tlast = (beg[i] - 1)\n\t\n\tJ.append(end[i] + 1 - last)\n\tlast = (end[i] + 1)\n\nok = True\nfor x in J:\n\tif (x > d):\n\t\tok = False\nfor x in R:\n\tif (x < s):\n\t\tok = False\n\n\nif ok:\n\tfor i in range(len(R)):\n\t\tprint('RUN', R[i])\n\t\tprint('JUMP', J[i])\n\tif (last < m):\n\t\tprint('RUN', m - last)\nelse:\n\tprint('IMPOSSIBLE')\n", "n, m, s, d = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\nif a[0] - 1 < s:\n    print('IMPOSSIBLE')\n    return\nstrategy = []\ni = 0\nstand_point = 0\nwhile i < n:\n    strategy.append(a[i] - stand_point - 1)\n    stand_point = a[i] - 1\n    j = i + 1\n    if j != n:\n        a2, a1 = a[j], a[i]\n    while j < n:\n        if a2 - a1 - 2 < s:\n            if a2 - a[i] + 2 > d:\n                print('IMPOSSIBLE')\n                return\n            j += 1\n            if j != n:\n                a1 = a2\n                a2 = a[j]\n            continue\n        else:\n            strategy.append(a1 - a[i] + 2)\n            i = j\n            stand_point = a[i - 1] + 1\n            break\n    else:\n        #print(stand_point, strategy_run, strategy_jump)\n        if d >= a[-1] - stand_point + 1 and strategy[-1] >= s:\n            strategy.append(a[-1] - stand_point + 1)\n        else:\n            print('IMPOSSIBLE')\n            return\n        i = j\n        stand_point = a[i - 1] + 1\n\nif m - stand_point != 0:\n    strategy.append(m - stand_point)\nturn_flag = True\nfor i in strategy:\n    if turn_flag:\n        print('RUN', i)\n    else:\n        print('JUMP', i)\n    turn_flag = not turn_flag\n", "import sys\n\ndef solve():\n    n, m, s, d = [int(x) for x in input().split()]\n    obstacles = [int(x) for x in input().split()]\n    obstacles.sort()\n    if obstacles[0] <= s: return False\n    pieces = [[obstacles[0], obstacles[0]]]\n    for x in obstacles:\n        if pieces[-1][1] + s + 2 > x:\n            pieces[-1][1] = x\n        else:\n            if pieces[-1][1] - pieces[-1][0] + 2 > d: return False\n            pieces.append([x, x])\n    if pieces[-1][1] - pieces[-1][0] + 2 > d: return False\n    pos = 0\n    for piece in pieces:\n        sys.stdout.write('RUN ' + str(piece[0] - pos - 1) + '\\n')\n        sys.stdout.write('JUMP ' + str(piece[1] - piece[0] + 2) + '\\n')\n        pos = piece[1] + 1\n    if pos < m:\n        sys.stdout.write('RUN ' + str(m - pos) + '\\n')\n    return True\n\nif not solve():\n    print('IMPOSSIBLE')\n", "n, m, s, d = map(int, input().split())\nA = sorted(list(map(int, input().split())))\n\n# Intervals\ninv = []\nprev = -1\nfor i in range(len(A)):\n    if A[i] < m:\n        inv.append((prev, A[i]))\n        prev = A[i]\n    else:\n        inv.append((prev, m))\n        break\nif A[-1] < m:\n    inv.append((A[-1], m))\n\noutput = [inv[-1]]\n\n# Use of intervals\nlast = inv[-1]\nfor i in range(len(inv) - 2, -1, -1):\n    a, b = inv[i], last\n    if a[1] - a[0] >= s + 2 and b[0] - a[1] <= d - 2:\n        last = inv[i]\n        output.append(last)\noutput = output[::-1]\n\nif m < A[0]:\n    print(\"RUN \" + str(m))\nelif last[0] != -1 or A[0] <= s:\n    print(\"IMPOSSIBLE\")\nelse:\n    last = 0\n    for i in range(1, len(output)):\n        a, b = output[i - 1], output[i]\n        print(\"RUN \" + str(a[1] - a[0] - 2))\n        print(\"JUMP \" + str(b[0] - a[1] + 2))\n        last = b[0] + 1\n    if last < m:\n        print(\"RUN \" + str(m - last))", "import itertools\n\n\nclass SolutionImpossible(Exception):\n    pass\n\n\nblocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]\n\n\ndef read_blocks_coords():\n    it = (int(x) for x in input().split())\n    return (x for x in it if x < finish)\n\n\n# TODO: \u043a\u043e\u0434 \u043c\u043e\u0436\u043d\u043e \u0441\u043e\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0437\u0430 \u0441\u0447\u0435\u0442 \u0438\u0437\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442 \u043b\u0438\u0448\u043d\u0435\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 `_grouper._current_key`\ndef _grouper(value):\n    if _grouper._prev_value is not None:\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        if value - _grouper._prev_value - 1 <= min_sprint:\n            # \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f\u043c\u0438 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u0430\u043b\u043e\n            # \u0447\u0442\u043e\u0431\u044b \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0442\u044c\u0441\u044f, \u0438 \u0437\u0430\u0442\u0435\u043c \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u044b\u0436\u043a\u0430, \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0445 \u0437\u0430 \u043e\u0434\u043d\u043e\n            _current_key = _grouper._current_key\n        else:\n            _current_key = id(value)\n    else:\n        # \u043f\u0435\u0440\u0432\u043e\u0435 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435, \u0441\u0442\u0430\u0432\u0438\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n        _current_key = id(_grouper)\n\n    _grouper._prev_value = value\n    _grouper._current_key = _current_key\n\n    return _current_key\n\n\n_grouper._prev_value = None\n_grouper._current_key = None\n\n\ndef check_chunk(run_from, block=None):\n    if block is None:\n        return\n\n    next_run_from = block[-1] + 1  # \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0437\u0430 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u044f (\u0442\u043e\u0447\u043a\u0430 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u0435\u043d\u0438\u044f)\n    if next_run_from - block[0] >= max_jump:\n        # \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u0430 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043b\u0438\u043d\u043d\u0430\u044f, \u0442\u043e \u043c\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u043c \u0435\u0435 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u044c\n        raise SolutionImpossible\n\n    if abs(run_from - block[0]) <= min_sprint:\n        # \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u0440\u0430\u0437\u0431\u0435\u0433\u0430\n        raise SolutionImpossible\n\n\ndef solve_chunk(run_from, block=None):\n    if block is not None:\n        run_len = block[0] - run_from - 1  # \u0434\u043e\u0431\u0435\u0433\u0430\u0435\u043c \u0414\u041e \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u044b\n        jump_len = block[-1] - block[0] + 2  # \u043f\u0440\u044b\u0433\u0430\u0435\u043c \u0417\u0410 \u043d\u0435\u0435\n        print((\n            \"RUN {run_len}\\n\"\n            \"JUMP {jump_len}\".format(\n                run_len=run_len,\n                jump_len=jump_len,\n            )\n        ))\n\n    else:\n        run_len = finish - run_from\n        if run_len > 0:\n            print(\"RUN {run_len}\".format(run_len=run_len))\n\n\ndef main():\n    # \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u043c\u043e\u0433\u0443\u0442 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u0442\u0430\u043a \u0431\u043b\u0438\u0437\u043a\u043e, \u0447\u0442\u043e \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f\n    # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0442\u0430\u043a\u0438\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u0437\u0430 \u043e\u0434\u043d\u043e\n    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))\n\n    chunks = []\n\n    run_from = 0\n    while True:\n        block = next(blocks, None)\n\n        chunk = (run_from, block)\n        check_chunk(*chunk)\n\n        chunks.append(chunk)\n\n        if block is None:\n            break\n\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        run_from = block[-1] + 1\n\n    #print(chunks)\n\n    for chunk in chunks:\n        solve_chunk(*chunk)\n\n\ndef __starting_point():\n    try:\n        main()\n    except SolutionImpossible:\n        print(\"IMPOSSIBLE\")\n\n__starting_point()", "num_barriers, finish, min_run, max_jump = tuple(map(int, input().split()))\n\nbarriers = list(map(int, input().split())) + [-1]\nbarriers.sort()\n\nfor i in range(len(barriers) - 1):\n    if barriers[i + 1] - barriers[i] <= min_run + 1:\n        barriers[i] = (0, barriers[i] + 1, barriers[i + 1] - 1)  # nope\n    else:\n        barriers[i] = (1, barriers[i] + 1, barriers[i + 1] - 1)  # ok\n\nbarriers[len(barriers) - 1] = (1, barriers[len(barriers) - 1] + 1, finish)\n\nif not barriers:\n    pass\nelif not barriers[0][0]:\n    print('IMPOSSIBLE')\nelse:\n    commands = []\n    pos = 0\n\n    for tpe, st, en in barriers:\n        if tpe:\n            if pos != st and st - pos <= max_jump:\n                commands.append('JUMP %s' % (st - pos))\n            elif pos != st:\n                print('IMPOSSIBLE')\n                break\n            if en - st:\n                commands.append('RUN %s' % (en - st))\n            pos = en\n    else:\n        print('\\n'.join(commands))\n", "n,m,s,d=map(int,input().split())\nx=sorted(map(int,input().split()))+[m+s+1]\ncur=l=0\nans=[]\nwhile l<m:\n    r=min(x[cur]-1,m)\n    ans+=['RUN '+str(r-l)]\n    if r==m: break\n    if r-l<s: ans=['IMPOSSIBLE']; break\n    t=x[cur]+1\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\n    if t-r>d: ans=['IMPOSSIBLE']; break\n    ans+=['JUMP '+str(t-r)]\n    l=t;cur+=1\nprint('\\n'.join(ans))", "n, m, s, d=map(int, input().split())\nx = sorted(map(int, input().split())) + [m + s + 1]\ncur = l = 0\nans = []\nwhile l < m:\n    r = min(x[cur] - 1, m)\n    ans += ['RUN ' + str(r - l)]\n    if r == m: break\n    if r - l < s: ans = ['IMPOSSIBLE']; break\n    t = x[cur] + 1\n    while x[cur + 1] - 1 - t < s: cur += 1; t = x[cur] + 1\n    if t - r > d: ans = ['IMPOSSIBLE']; break\n    ans += ['JUMP ' + str(t - r)]\n    l = t;cur += 1\nprint('\\n'.join(ans))", "f = lambda: map(int, input().split())\nn, m, s, d = f()\np, x, z = [], -1, 1\nfor y in sorted(f()) + [m + 1]:\n    if y - x > s + 1 or y > m or x < 0:\n        u = x - z + 2\n        v = y - x - 2\n        if u > d or v < s and x < 0:\n            p = ['IMPOSSIBLE']\n            break\n        if u: p += ['JUMP ' + str(u)]\n        if v: p += ['RUN ' + str(v)]\n        z = y\n    x = y\nprint('\\n'.join(p))", "n,m,s,d=list(map(int,input().split()))\nx=sorted(map(int,input().split()))+[m+s+1]\ncur=l=0\nans=[]\nwhile l<m:\n    r=min(x[cur]-1,m)\n    ans+=['RUN '+str(r-l)]\n    if r==m: break\n    if r-l<s: ans=['IMPOSSIBLE']; break\n    t=x[cur]+1\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\n    if t-r>d: ans=['IMPOSSIBLE']; break\n    ans+=['JUMP '+str(t-r)]\n    l=t;cur+=1\nprint('\\n'.join(ans))\n", "n,m,s,d=list(map(int,input().split()))\nx=sorted(map(int,input().split()))+[m+s+1]\ncur=l=0\nans=[]\nwhile l<m:\n    r=min(x[cur]-1,m)\n    ans+=['RUN '+str(r-l)]\n    if r==m: break\n    if r-l<s: ans=['IMPOSSIBLE']; break\n    t=x[cur]+1\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\n    if t-r>d: ans=['IMPOSSIBLE']; break\n    ans+=['JUMP '+str(t-r)]\n    l=t;cur+=1\nprint('\\n'.join(ans))\n", "n, m ,s, d = [int(i) for i in input().split()]  # m is the end point\n# s is length of run, d is the max jump distance\nA = [-1] + sorted([int(i) for i in input().split()]) + [m+1]\nans_size = 2 * 10**5\nans = [0 for i in range(4*ans_size)]\n\n# use 0 to indicate run an 1 to indicate jump\n\ndef obstacle():\n    run = -1\n    jump = -1\n    top = 0 # flag where are we at the dp\n    for i in range(1,n+1):\n        if s + 2 <= A[i] - A[i-1]:\n            if jump != -1:\n                if A[i-1] + 1 - jump <= d and top > 0 and ans[top-1][0] == 0 and ans[top-1][1] >= s:\n                    ans[top] = (1, A[i-1]+1-jump)\n                    top += 1\n                else:\n                    print(\"IMPOSSIBLE\")\n                    return\n            ans[top] = (0, A[i] - A[i-1]-2) # run\n            top += 1\n            jump = A[i] - 1 # jumping point\n    if A[n] + 1 - jump <= d and top > 0 and ans[top-1][0] == 0 and ans[top-1][1] >= s:\n        ans[top] = (1, A[n]+1 - jump)\n        top += 1\n    else:\n        print(\"IMPOSSIBLE\")\n        return\n    if m != A[n] + 1:\n        ans[top] = (0, m-A[n]-1)\n        top += 1\n    for i in range(top):\n        if ans[i][0]:\n            print(\"JUMP\", ans[i][1])\n        else:\n            print(\"RUN\", ans[i][1])\nobstacle()\n", "n, m, s, d = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\npoints = [0, a[0] - 1]\nif d == 1 or a[0] - 1 < s:\n    print(\"IMPOSSIBLE\")\n    return\nfor i in range(0, n):\n    if a[i] - a[i - 1] - 2 < s:\n        if a[i] + 1 - points[-1] > d:\n            print(\"IMPOSSIBLE\")\n            return\n    else:\n        points.append(a[i - 1] + 1)\n        points.append(a[i] - 1)\n\npoints.append(a[-1] + 1)\nfor i in range(1, len(points)):\n    if i % 2 == 1:\n        print(\"RUN\", points[i] - points[i - 1])\n    else:\n        print(\"JUMP\", points[i] - points[i - 1])\nif a[-1] + 1 != m:\n    print(\"RUN\", m - 1 - a[-1])\n"]
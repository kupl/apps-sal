["3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    H = [read_ints() for _ in range(10)]\n    print(solve(H))\n\n\ndef pos_idx(x, y):\n    i = y * 10\n    if y % 2 == 0:\n        i += x\n    else:\n        i += 9 - x\n    return i\n\n\ndef idx_pos(i):\n    y = i // 10\n    if y % 2 == 0:\n        x = i % 10\n    else:\n        x = 9 - i % 10\n    return x, y\n\n\ndef solve(H):\n    dp = [0] * 100\n    for i in range(1, 100):\n        e = 0\n        for d in range(1, 7):\n            j = i - d\n            if j < 0:\n                rem = 7 - d\n                e += rem / 6\n                e *= 6 / (6 - rem)\n                break\n            x, y = idx_pos(j)\n            if H[y][x] != 0:\n                dy = y - H[y][x]\n                k = pos_idx(x, dy)\n                assert idx_pos(k) == (x, dy)\n                e += (min(dp[j], dp[k]) + 1) / 6\n            else:\n                e += (dp[j] + 1) / 6\n        dp[i] = e\n    return dp[99]\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import *\n\nc=10\n\n\nav=[]\nfor i in range(c):\n    l=[int(s) for s in input().split()]\n    if i%2==0:\n        l.reverse()\n    for j in range(c):\n        if l[j]%2==0:\n            l[j]=c*l[j]\n        else:\n            l[j]=c*l[j]+c-1-2*j\n    av=l+av\n\nd=[0]*c**2\n\nfor i in range(c**2-2,-1,-1):\n    rep=max(0,6-c**2+1+i)\n    t=0\n    for j in range(1,6-rep+1):\n        t+=min(d[i+j],d[i+j+av[i+j]])+1\n    d[i]=(rep+t)/(6-rep)\n\nprint(d[0])\n", "X = [[int(a) for a in input().split()] for _ in range(10)]\nY = [(i//10, 9-i%10 if (i//10)&1 else i%10) for i in range(100)]\nZ = [[i * 10 + 9 - j if i & 1 else i * 10 + j for j in range(10)] for i in range(10)]\nE = [0] * 100\nF = [0] * 100\nfor i in range(1, 6):\n    F[i] = E[i] = (sum(E[:i]) + 6) / i\nfor i in range(6, 100):\n    F[i] = E[i] = sum(F[i-6:i])/6 + 1\n    x, y = Y[i]\n    if X[x][y]: F[i] = min(E[i], E[Z[x-X[x][y]][y]])\n\nprint(F[99])", "t=[]\n\n\ndef corresp(i,j):\n    return 100 - (i*10 + (j if not i%2 else (9-j)))\n    \npaths=[[i] for i in range(101)]\n\nfor i in range(10):\n    z=[int(k) for k in input().split(\" \")]\n    if i%2:\n        t+=z[::-1]\n    else:\n        t+=z\n    for j in range(10):\n        if z[j]:\n            paths[corresp(i,j)]=[corresp(i,j),corresp(i-z[j],j)]\n\nres=[0 for i in range(101)]\nfor i in range(99,94,-1):\n    ri=max(1,6/(100-i))\n    #print(i,ri,)\n    for j in range(i+1,101):\n        ri+=res[j]/(min(6,100-i))\n    #    print(j,ri,)\n    #print(\"\")\n    res[i]=ri\n\nfor i in range(94,-1,-1):\n    ri=1\n    for j in range(i+1,i+7):\n        ri+= min([res[k] for k in paths[j]])/6\n    res[i]=ri\n\n\n#print(res)\n#print(corresp(9,0))\nprint(res[1])", "links = list(range(100))\n# 0 0 = left up\n# 10*y+x\n\n# i = height\n# j = pos\nfor i in range(10):\n\tl = list(map(int, input().split()))\n\tfor j, h in enumerate(l):\n\t\tcoo = i*10+(j if i%2==0 else 9-j)\n\t\ttarget = (i-h)*10+(j if (i-h)%2==0 else 9-j)\n\t\tlinks[coo] = target\n\nexp = [0]\nfor i in range(1, 6):\n\texp.append((1 + sum(exp)*1/6)*6/i)\n\nfor i in range(6, 100):\n\tnew = 0\n\tfor j in range(1, 7):\n\t\tnew += min(exp[i-j], exp[links[i-j]])\n\texp.append(1 + new/6)\n\nprint(exp[-1])", "board = []\nfor i in range(10):\n    board.append([int(i) for i in input().split()])\n\ndef next_squares(x, y):\n    current_dir = 1 if x%2 else -1\n    # print(x, y, current_dir)\n    res = []\n    for _ in range(6):\n        nx, ny = x, y + current_dir\n        if ny < 0 or ny == 10:\n            nx, ny = x - 1, y\n            current_dir *= -1\n            if nx == -1: break\n        x, y = nx, ny\n        res.append([x, y])\n    # print(x, y, res)\n    return res\n\n\n\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef dp(i, j, can_climb):\n    if i == j == 0: return 0\n    expected = []\n    for x, y in next_squares(i, j):\n        expected.append(dp(x, y, True))\n    score = sum(expected) / len(expected) + (6 / len(expected))\n    # print(i, j)\n    if can_climb and board[i][j]: return min(score, dp(i - board[i][j], j, False))\n    return score\n\n\nprint(dp(9, 0, True))", "def pos(x, y):\n    if y & 1:\n        return y * w + w - 1 - x\n    return y * w + x\n\n\nCUBE = 6\nh, w = 10, 10\nn = h * w\n\ngrid = []\nfor y in range(h):\n    line = list(map(int, input().split()))\n    grid.append(line)\ngrid.reverse()\n# print(*grid, sep='\\n')\n\nto = [0] * n\nfor y in range(h):\n    for x in range(w):\n        y1 = y + grid[y][x]\n        if y1 != y:\n#            print(f\"({x}, {y}) --> ({x}, {y1})\", pos(x, y), pos(x, y1))\n            to[pos(x, y)] = pos(x, y + grid[y][x])\n# print(to)\n\nexp = [0] * (n + CUBE)\nfor i in range(n - 2, -1, -1):\n    exp[i] = 1\n    for j in range(1, CUBE + 1):\n        exp_to = exp[i + j] / CUBE\n        if i + j < n and to[i + j]:\n            exp_to = min(exp_to, exp[to[i + j]] / CUBE)\n        exp[i] += exp_to\n    if i + CUBE >= n:\n        exp[i] = CUBE * exp[i] / (n - 1 - i)\n# print(*[f\"{x:.1f}\" for x in exp[:n]])\nprint(f\"{exp[0]:.16f}\")\n", "import sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\n\ndef ind(i, j):\n    return 10 * i + (j if i % 2 == 0 else 9 - j)\n\n\ndef read_field():\n    field = [0] * 100\n    for i in range(10):\n        for j, h in enumerate(read_ints()[:10]):\n            if h != 0:\n                h = ind(i - h, j)\n            else:\n                h = ind(i, j)\n            field[ind(i, j)] = h\n    return field\n\n\ndef solve(field):\n    dp = [1.0] * 100\n    dp[0] = 0.0\n\n    for _ in range(100):\n        for i in range(1, 100):\n            sum = 1.0\n            for j in range(1, 7):\n                if (i - j) >= 0:\n                    sum += min(dp[i - j], dp[field[i - j]])  / 6\n                else:\n                    sum += dp[i] / 6\n            dp[i] = sum\n\n    return dp[99]\n\n\ndef main():\n    field = read_field()\n    result = solve(field)\n    sys.stdout.write(\"{:.6f}\\n\".format(result))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "h = [list(map(int, input().split())) for _ in range(10)]\n\ntp = {}\n\ndef celli(x, y):\n\tif x % 2:\n\t\treturn (9 - x) * 10 + y\n\treturn (9 - x) * 10 + 9 - y\n\nfor i in range(10):\n\tfor j in range(10):\n\t\tif h[i][j]:\n\t\t\ttp[celli(i, j)] = celli(i - h[i][j], j)\n\ndp = [0] * 94 + [6] * 5 + [0]\n\nfor i in range(93, -1, -1):\n\ttot = 0\n\tfor j in range(1, 7):\n\t\tif i + j in tp:\n\t\t\ttot += min(dp[i + j], dp[tp[i + j]])\n\t\telse:\n\t\t\ttot += dp[i + j]\n\n\ttot /= 6\n\ttot += 1\n\n\tdp[i] = tot\n\nprint(dp[0])", "X = [[int(a) for a in input().split()] for _ in range(10)]\nY = [(i//10, 9-i%10 if (i//10)&1 else i%10) for i in range(100)]\nZ = [[i * 10 + 9 - j if i & 1 else i * 10 + j for j in range(10)] for i in range(10)]\nE = [0] * 100\nF = [0] * 100\nfor i in range(1, 6):\n    F[i] = E[i] = (sum(E[:i]) + 6) / i\nfor i in range(6, 100):\n    F[i] = E[i] = sum(F[i-6:i])/6 + 1\n    x, y = Y[i]\n    if X[x][y]: F[i] = min(E[i], E[Z[x-X[x][y]][y]])\n \nprint(F[99])\n"]
["import sys\ninput=sys.stdin.buffer.readline\nt=1    \nfor __ in range(t):\n    a=[]\n    n=int(input())\n    for i in range(n):\n        b=list(map(int,input().split()))\n        a.append(b)\n    dr={}\n    di={}\n    for i in range(n):\n        for j in range(n):\n            dr[i+j]=dr.get(i+j,0)+a[i][j]\n            di[i+n-j+1]=di.get(i+n-j+1,0)+a[i][j]\n    ind1=[0]*2\n    ind2=[0]*2\n    maxi1=0\n    maxi2=0\n    for i in range(n):\n        for j in range(n):\n            #if maxi<(dr[i+j]+di[i+n-j+1]-a[i][j]):\n            if ((i+j)&1)==1:\n                if maxi1<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi1=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind1[0]=i+1\n                    ind1[1]=j+1\n            else:\n                if maxi2<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi2=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind2[0]=i+1\n                    ind2[1]=j+1\n                    \n    \n    \n    print(maxi1+maxi2)\n    print(ind1[0],ind1[1],ind2[0],ind2[1])", "from sys import stdin\ninput = stdin.buffer.readline\nfrom collections import defaultdict as dd\nI = lambda : list(map(int,input().split()))\n\nn,=I()\nl=[];d=dd(int);su=dd(int);s=0;an=[1,1,2,1]\nfor i in range(n):\n\tl.append(I())\n\tfor j in range(n):\n\t\td[i-j]+=l[i][j]\n\t\tsu[i+j]+=l[i][j]\nx=0;y=0\nfor i in range(n):\n\tfor j in range(n):\n\t\tl[i][j]=d[i-j]+su[i+j]-l[i][j]\n\t\tif (i+j)%2:\n\t\t\tif l[i][j]>x:\n\t\t\t\tan[0],an[1]=i+1,j+1\n\t\t\t\tx=l[i][j]\n\t\telse:\n\t\t\tif l[i][j]>y:\n\t\t\t\tan[2],an[3]=i+1,j+1\n\t\t\t\ty=l[i][j]\ns=x+y\nprint(s)\nprint(*an)", "from sys import stdin\ninput = stdin.buffer.readline\nI = lambda : list(map(int,input().split()))\n\nn,=I()\nl=[]\nfor i in range(n):\n\tl.append(I())\nd={};su={};s=0;an=[1,1,2,1]\nfor i in range(n):\n\tfor j in range(n):\n\t\td[i-j]=d.get(i-j,0)+l[i][j]\n\t\tsu[i+j]=su.get(i+j,0)+l[i][j]\nx=0;y=0\nfor i in range(n):\n\tfor j in range(n):\n\t\tl[i][j]=d[i-j]+su[i+j]-l[i][j]\n\t\tif (i+j)%2:\n\t\t\tif l[i][j]>x:\n\t\t\t\tan[0],an[1]=i+1,j+1\n\t\t\t\tx=l[i][j]\n\t\telse:\n\t\t\tif l[i][j]>y:\n\t\t\t\tan[2],an[3]=i+1,j+1\n\t\t\t\ty=l[i][j]\ns=x+y\nprint(s)\nprint(*an)\n", "from sys import stdin\ninput = stdin.buffer.readline\nI = lambda : list(map(int,input().split()))\n\nn,=I()\nl=[]\nfor i in range(n):\n\tl.append(I())\nd={};su={};s=0;an=[1,1,2,1]\nfor i in range(n):\n\tfor j in range(n):\n\t\td[i-j]=d.get(i-j,0)+l[i][j]\n\t\tsu[i+j]=su.get(i+j,0)+l[i][j]\nx=0;y=0\nfor i in range(n):\n\tfor j in range(n):\n\t\tp=d[i-j]+su[i+j]-l[i][j]\n\t\tif (i+j)%2:\n\t\t\tif p>x:\n\t\t\t\tan[0],an[1]=i+1,j+1\n\t\t\t\tx=p\n\t\telse:\n\t\t\tif p>y:\n\t\t\t\tan[2],an[3]=i+1,j+1\n\t\t\t\ty=p\ns=x+y\nprint(s)\nprint(*an)\n", "import sys\ninput=sys.stdin.buffer.readline\nt=1    \nfor __ in range(t):\n    a=[]\n    n=int(input())\n    for i in range(n):\n        b=list(map(int,input().split()))\n        a.append(b)\n    dr={}\n    di={}\n    for i in range(n):\n        for j in range(n):\n            dr[i+j]=dr.get(i+j,0)+a[i][j]\n            di[i+n-j+1]=di.get(i+n-j+1,0)+a[i][j]\n    ind1=[0]*2\n    ind2=[0]*2\n    maxi1=0\n    maxi2=0\n    for i in range(n):\n        for j in range(n):\n            #if maxi<(dr[i+j]+di[i+n-j+1]-a[i][j]):\n            if ((i+j)&1)==1:\n                if maxi1<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi1=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind1[0]=i+1\n                    ind1[1]=j+1\n            else:\n                if maxi2<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi2=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind2[0]=i+1\n                    ind2[1]=j+1\n                    \n    \n    \n    print(maxi1+maxi2)\n    print(ind1[0],ind1[1],ind2[0],ind2[1])", "\nfrom sys import stdin\ninput = stdin.buffer.readline\nI = lambda : list(map(int,input().split()))\n\nmat=[]\nfor _ in range(int(input())):\n    mat.append(I())\nn=len(mat)\ndef sumDiag(mat):\n    diag_sum=[]\n    diag_sum2=[]\n    n=len(mat)\n    for i in range(n):\n        s=0\n        for j in range(0,n-i):\n            s+=mat[j][(j+i)]\n        diag_sum.append(s)\n        if i!=0:\n            s=0\n            for j in range(0,n-i):\n                s+=mat[j+i][(j)]\n            diag_sum2.append(s)\n    return diag_sum2[::-1]+diag_sum\n\ndef antiDiag(mat):\n    def mirror(mat):\n        for i in range(len(mat)):\n            for j in range(len(mat[0])//2):\n                t=mat[i][j]\n                mat[i][j]=mat[i][len(mat[0])-1-j]\n                mat[i][len(mat[0])-1-j]=t\n        return mat\n    mat=mirror(mat)\n    out=sumDiag(mat)\n    mirror(mat)\n    return out[::-1]\n\nd1=sumDiag(mat)\nd2=antiDiag(mat)\ndef ret(i,j):\n    return d1[n-1-(i-j)]+d2[i+j]-mat[i][j]\n\nm1=0\nm2=0\nbest1=(1,1)\nbest2=(1,2)\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2==0 and m1<ret(i,j):\n            m1=ret(i,j)\n            best1=(i+1,j+1)\n        elif (i+j)%2==1 and m2<ret(i,j):\n            m2=ret(i,j)\n            best2=(i+1,j+1)\n\nprint(m1+m2)\nprint(\" \".join(map(str,[best1[0],best1[1],best2[0],best2[1]])))", "\nfrom sys import stdin\ninput = stdin.buffer.readline\nI = lambda : list(map(int,input().split()))\nn = int(input())\nans = []\n\nfor _ in range(n):\n    arr = I()\n    ans.append(arr)\n\ntopLeft, bottomLeft = {}, {}\n\nfor i in range(n):\n    for j in range(n):\n        topLeft[i-j] = topLeft.get(i-j, 0) + ans[i][j]\n        bottomLeft[i+j] = bottomLeft.get(i+j, 0) + ans[i][j]\n\nmx1, mx2, pos1, pos2 = -1, -1, [-1,-1], [-1,-1]\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j) & 1:\n            if mx1 < topLeft[i-j] + bottomLeft[i+j] - ans[i][j]:\n                mx1, pos1 = topLeft[i-j] + bottomLeft[i+j] - ans[i][j], [i+1,j+1]\n        else:\n            if mx2 < topLeft[i - j] + bottomLeft[i + j] - ans[i][j]:\n                mx2, pos2 = topLeft[i - j] + bottomLeft[i + j] - ans[i][j], [i+1, j+1]\n\nprint(mx1+mx2)\nprint(pos1[0], pos1[1], pos2[0], pos2[1])", "\nfrom sys import stdin\ninput = stdin.buffer.readline\nn = int(input())\nans = []\n\nfor _ in range(n):\n    arr = list(map(int,input().split()))\n    ans.append(arr)\n\ntopLeft, bottomLeft = {}, {}\n\nfor i in range(n):\n    for j in range(n):\n        topLeft[i-j] = topLeft.get(i-j, 0) + ans[i][j]\n        bottomLeft[i+j] = bottomLeft.get(i+j, 0) + ans[i][j]\n\nmx1, mx2, pos1, pos2 = -1, -1, [-1,-1], [-1,-1]\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j) & 1:\n            if mx1 < topLeft[i-j] + bottomLeft[i+j] - ans[i][j]:\n                mx1, pos1 = topLeft[i-j] + bottomLeft[i+j] - ans[i][j], [i+1,j+1]\n        else:\n            if mx2 < topLeft[i - j] + bottomLeft[i + j] - ans[i][j]:\n                mx2, pos2 = topLeft[i - j] + bottomLeft[i + j] - ans[i][j], [i+1, j+1]\n\nprint(mx1+mx2)\nprint(pos1[0], pos1[1], pos2[0], pos2[1])", "\nfrom sys import stdin\ninput = stdin.buffer.readline\nn = int(input())\nans = []\n\nfor _ in range(n):\n    arr = list(map(int,input().split()))\n    ans.append(arr)\n\ntopLeft, bottomLeft = {}, {}\n\nfor i in range(n):\n    for j in range(n):\n        topLeft[i-j] = topLeft.get(i-j, 0) + ans[i][j]\n        bottomLeft[i+j] = bottomLeft.get(i+j, 0) + ans[i][j]\n\nmx1, mx2, pos1, pos2 = -1, -1, [-1,-1], [-1,-1]\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j) & 1:\n            if mx1 < topLeft[i-j] + bottomLeft[i+j] - ans[i][j]:\n                mx1, pos1 = topLeft[i-j] + bottomLeft[i+j] - ans[i][j], [i+1,j+1]\n        else:\n            if mx2 < topLeft[i - j] + bottomLeft[i + j] - ans[i][j]:\n                mx2, pos2 = topLeft[i - j] + bottomLeft[i + j] - ans[i][j], [i+1, j+1]\n\nprint(mx1+mx2)\nprint(pos1[0], pos1[1], pos2[0], pos2[1])\n", "from sys import stdin\ninput = stdin.buffer.readline\nn=int(input())\nl=[[*map(int,input().split())] for _ in range(n)]\nd={};su={};s=0;an=[1,1,2,1]\nfor i in range(n):\n\tfor j in range(n):\n\t\td[i-j]=d.get(i-j,0)+l[i][j]\n\t\tsu[i+j]=su.get(i+j,0)+l[i][j]\nposition=[2,1,1,1]\nx,y=0,0\nfor i in range(n):\n\tfor j in range(n):\n\t\tp=d[i-j]+su[i+j]-l[i][j]\n\n\t\tif (i+j)%2:\n\t\t\tif p>x:\n\t\t\t\tx=p\n\t\t\t\tposition[:2]=[i+1,j+1]\n\t\telse:\n\t\t\tif p>y:\n\t\t\t\ty=p\n\t\t\t\tposition[2:]=[i+1,j+1]\nprint(x+y)\nprint(*position)", "\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import inf\n\n\ndef main():\n    # a bishop has to be on a cell intercepted by even diagonals,\n    # and another on a cell intercepted by odd diagonals\n\n    # i + j is even -> white\n    # i + j is odd -> gray\n\n    # diagonal 1 -> i - j (top-left to bottom-right) (this difference is constant)\n    # diagonal 2 -> i + j (top-right to bottom-left) (this sum is constant)\n\n    # calculate the sum of each diagonal (n2)\n\n    # find the best cell (with max total) intercepted by even diagonals and the\n    # best cell (with max total) intercepted by odd diagonals\n\n    n = int(input())\n    chessboard = [\n        [ int(x) for x in input().split() ]\n        for row in range(n)\n    ]\n\n    mainDiagonalSums = {}\n    secondaryDiagonalSums = {}\n\n    for i in range(n):\n        for j in range(n):\n            mainDiagonal = i - j\n            if mainDiagonal in mainDiagonalSums:\n                mainDiagonalSums[mainDiagonal] += chessboard[i][j]\n            else:\n                mainDiagonalSums[mainDiagonal] = chessboard[i][j]\n\n            secondaryDiagonal = i + j\n            if secondaryDiagonal in secondaryDiagonalSums:\n                secondaryDiagonalSums[secondaryDiagonal] += chessboard[i][j]\n            else:\n                secondaryDiagonalSums[secondaryDiagonal] = chessboard[i][j]\n\n    maxPoints = [-inf, -inf]\n    bestPosition = [None, None]\n\n    for i in range(n):\n        for j in range(n):\n            points = (\n                mainDiagonalSums[i-j] + secondaryDiagonalSums[i+j]\n                - chessboard[i][j]\n            )\n\n            if (i + j) & 1:\n                if points > maxPoints[1]:\n                    bestPosition[1] = (i, j)\n                    maxPoints[1] = points\n            else:\n                if points > maxPoints[0]:\n                    bestPosition[0] = (i, j)\n                    maxPoints[0] = points\n\n    print(sum(maxPoints))\n    print(' '.join([ f'{i+1} {j+1}' for i, j in bestPosition ]))\n\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep = kwargs.pop(\"sep\", \" \")\n    file = kwargs.pop(\"file\", sys.stdout)\n\n    atStart = True\n    for x in args:\n        if not atStart:\n            file.write(sep)\n        file.write(str(x))\n        atStart = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmain()\n", "\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import inf\n\n\ndef main():\n    # a bishop has to be on a cell intercepted by even diagonals,\n    # and another on a cell intercepted by odd diagonals\n\n    # i + j is even -> white\n    # i + j is odd -> gray\n\n    # diagonal 1 -> i - j (top-left to bottom-right) (this difference is constant)\n    # diagonal 2 -> i + j (top-right to bottom-left) (this sum is constant)\n\n    # calculate the sum of each diagonal (n2)\n\n    # find the best cell (with max total) intercepted by even diagonals and the\n    # best cell (with max total) intercepted by odd diagonals\n\n    n = int(input())\n    chessboard = [\n        [ int(x) for x in input().split() ]\n        for row in range(n)\n    ]\n\n    mainDiagonalSums = {}\n    secondaryDiagonalSums = {}\n\n    for i in range(n):\n        for j in range(n):\n            mainDiagonal = i - j\n            if mainDiagonal in mainDiagonalSums:\n                mainDiagonalSums[mainDiagonal] += chessboard[i][j]\n            else:\n                mainDiagonalSums[mainDiagonal] = chessboard[i][j]\n\n            secondaryDiagonal = i + j\n            if secondaryDiagonal in secondaryDiagonalSums:\n                secondaryDiagonalSums[secondaryDiagonal] += chessboard[i][j]\n            else:\n                secondaryDiagonalSums[secondaryDiagonal] = chessboard[i][j]\n\n    maxPoints = [-inf, -inf]\n    bestPosition = [None, None]\n\n    for i in range(n):\n        for j in range(n):\n            points = (\n                mainDiagonalSums[i-j] + secondaryDiagonalSums[i+j]\n                - chessboard[i][j]\n            )\n\n            if (i + j) & 1:\n                if points > maxPoints[1]:\n                    bestPosition[1] = (i, j)\n                    maxPoints[1] = points\n            else:\n                if points > maxPoints[0]:\n                    bestPosition[0] = (i, j)\n                    maxPoints[0] = points\n\n    print(sum(maxPoints))\n    print(' '.join([ f'{i+1} {j+1}' for i, j in bestPosition ]))\n\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep = kwargs.pop(\"sep\", \" \")\n    file = kwargs.pop(\"file\", sys.stdout)\n\n    atStart = True\n    for x in args:\n        if not atStart:\n            file.write(sep)\n        file.write(str(x))\n        atStart = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmain()\n\n", "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n# from math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\n# import numpy as np\nstarttime = time.time()\n# import numpy as np\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return list(map(int, data().split()))\ndef ssp(): return list(map(str, data().split()))\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n\ntry:\n    # sys.setrecursionlimit(int(pow(10,6)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"../output.txt\", \"w\")\nexcept:\n    pass\n\nfrom sys import stdin\ninput = stdin.buffer.readline\nI = lambda : list(map(int,input().split()))\n \nn,=I()\nl=[]\nfor i in range(n):\n    l.append(I())\nd={};su={};s=0;an=[1,1,2,1]\nfor i in range(n):\n    for j in range(n):\n        d[i-j]=d.get(i-j,0)+l[i][j]\n        su[i+j]=su.get(i+j,0)+l[i][j]\nx=0;y=0\nfor i in range(n):\n    for j in range(n):\n        p=d[i-j]+su[i+j]-l[i][j]\n        if (i+j)%2:\n            if p>x:\n                an[0],an[1]=i+1,j+1\n                x=p\n        else:\n            if p>y:\n                an[2],an[3]=i+1,j+1\n                y=p\ns=x+y\nprint(s)\nprint(*an)\n\n\n\n\n\n\n\nendtime = time.time()\n# print(f\"Runtime of the program is {endtime - starttime}\")\n", "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\nn=Int()\na=[]\nfor i in range(n): a.append(array())\n\nleft=defaultdict(int)\nright=defaultdict(int)\n\nfor i in range(n):\n    for j in range(n):\n        left[i-j]+=a[i][j]\n        right[i-(n-j-1)]+=a[i][j]\n\n# print(left)\n# print(right)\n\nans1=(-1,-1,-1)\nans2=(-1,-1,-1)\n\nfor i in range(n):\n    for j in range(n):\n\n        left_key=i-j\n        right_key=i-(n-j-1)\n        here= (left[left_key]+right[right_key]-a[i][j],i+1,j+1)\n\n        if(n%2 and left_key%2==right_key%2):\n            \n            if(left_key%2):\n                ans1=max(ans1,here)\n            else:\n                ans2=max(ans2,here)\n            \n        \n        elif(n%2==0 and left_key%2!=right_key%2):\n            if(left_key%2):\n                ans1=max(ans1,here)\n            else:\n                ans2=max(ans2,here)\n\nprint(ans1[0]+ans2[0])\nprint(*ans1[1:],*ans2[1:])\n\n            \n\n        \n\n        \n\n\n    \n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    \n\n\n\n    \n        \n\n   \n\n\n\n\n\n\n\n\n\n"]
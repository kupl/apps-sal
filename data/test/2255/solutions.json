["from heapq import *\nn, m = map(int, input().split())\ng = {}\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g.setdefault(u, set()).add(v)\n    g.setdefault(v, set()).add(u)\n\nd = []\nV = set()\nh = [1]\nwhile h:\n    v = heappop(h)\n    if v in V:\n        continue\n    V.add(v)\n    d.append(v)\n    for u in g[v]:\n        heappush(h, u)\nprint(*d)", "from heapq import heapify, heappush, heappop\n\n\ndef solve():\n    n, m = [int(x) for x in input().split()]\n\n    adjs = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = [int(x) for x in input().split()]\n        a -= 1\n        b -= 1\n        adjs[a].append(b)\n        adjs[b].append(a)\n\n    seq = [1]\n    visited = set([0])\n    frontier = adjs[0].copy()\n    heapify(frontier)\n\n    while frontier:\n        node = heappop(frontier)\n        if node in visited:\n            continue\n\n        seq.append(node+1)\n        visited.add(node)\n        for neighbor in adjs[node]:\n            if neighbor not in visited:\n                heappush(frontier, neighbor)\n\n    print(*seq)\n\n\nsolve()\n", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nimport heapq\n\nn, m = mi()\ng = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = mi()\n    g[u].append(v)\n    g[v].append(u)\n\nvis = [0] * (n + 1)\nvis[1] = 1\npq = [1]\nans = []\nwhile pq:\n    u = heapq.heappop(pq)\n    ans.append(u)\n    for v in g[u]:\n        if not vis[v]:\n            heapq.heappush(pq, v)\n            vis[v] = 1\n\nprint(*ans)\n", "from collections import defaultdict\nimport heapq\ngraph = defaultdict(set)\nn,m = map(int,input().split())\nfor _ in range(m):\n    a,b = map(int,input().split())\n    if a!=b:\n        graph[a].add(b)\n        graph[b].add(a)\n\nseen = {1}\nhist = [1]\nh = list(graph[1])\nheapq.heapify(h)\nwhile len(hist)<n:\n    next_node = heapq.heappop(h)\n    if next_node in seen:continue\n    seen.add(next_node)\n    hist.append(next_node)\n    for node in graph[next_node]:\n        heapq.heappush(h,node)\nprint (\" \".join(str(x) for x in hist))", "from heapq import *\n\nn, m = list(map(int, input().split()))\nvis = [0, 1] + [0] * (n - 1)\ne = [[] for i in range(n + 1)]\nfor i in range(m):\n\tu, v = list(map(int, input().split()))\n\te[u].append(v)\n\te[v].append(u)\nans = []\nh = [1]\nwhile h:\n\tcur = heappop(h)\n\tans.append(cur)\n\tfor to in e[cur]:\n\t\tif not vis[to]:\n\t\t\tvis[to] = 1\n\t\t\theappush(h, to)\nprint(*ans)\n\n", "from heapq import heappop, heappush\n\nn, m = list(map(int, input().split()))\na = []\nas_ = set()\ng = [set() for _ in range(n + 2)]\nfor _2 in range(m):\n    u, v = list(map(int, input().split()))\n    g[u].add(v)\n    g[v].add(u)\nh = [1]\nwhile h:\n    u = heappop(h)\n    if u not in as_:\n        a.append(u)\n        as_.add(u)\n        for v in g[u]:\n            heappush(h, v)\nprint(*a)\n", "import queue\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    g = [set() for _ in range(n)]\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        g[a - 1].add(b - 1)\n        g[b - 1].add(a - 1)\n\n    q = queue.PriorityQueue()\n    q.put(0)\n\n    visited = set()\n    sq = []\n    while len(visited) != n:\n        node = q.get()\n        if node not in visited:\n            visited.add(node)\n            sq.append(node)\n        else:\n            continue\n\n        for nxt in g[node]:\n            q.put(nxt)\n\n    print(\" \".join(list([str(x + 1) for x in sq])))\n\n__starting_point()", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/31 21:44\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : D. Lunar New Year and a Wander.py\n\nimport heapq\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    graph_dict = {}\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        temp_list = graph_dict.get(u, [])\n        temp_list.append(v)\n        graph_dict[u] = temp_list\n        temp_list = graph_dict.get(v, [])\n        temp_list.append(u)\n        graph_dict[v] = temp_list\n\n    visit = [False] * (n + 1)\n    h, ret = [], []\n    heapq.heappush(h, 1)\n    while h:\n        u = heapq.heappop(h)\n        if visit[u]:\n            continue\n        ret.append(u)\n        visit[u] = True\n        for v in graph_dict.get(u, []):\n            if visit[v]:\n                continue\n            heapq.heappush(h, v)\n    print(*ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq \nfrom collections import defaultdict\nd=defaultdict(list)\nn,m=map(int,input().split())\nfor i in range(m):\n    a,b=map(int,input().split())\n    a=a-1 \n    b=b-1 \n    d[a].append(b)\n    d[b].append(a)\nvis=[0]*n \nvis[0]=1 \nprint(1,end=' ')\nl=[]\nfor i in d[0]:\n    if not vis[i]:\n        heapq.heappush(l,i)\n        vis[i]=1 \nheapq.heapify(l)\nwhile l:\n    t=heapq.heappop(l)\n    print(t+1,end=' ')\n    for i in d[t]:\n        if not vis[i]:\n            heapq.heappush(l,i)\n            vis[i]=1 ", "from heapq import heappop, heappush\nimport sys\nN, M = map(int, input().split())\nedges = [[] for _ in [0]*N]\nfor u, v in (map(int, l.split()) for l in sys.stdin):\n    edges[u-1].append(v-1)\n    edges[v-1].append(u-1)\n\nvisited = [0]*N\nans = []\nheap = [0]\nans_append = ans.append\n\nwhile heap:\n    v = heappop(heap)\n    visited[v] = 1\n    ans_append(v+1)\n\n    edges[v].sort()\n    for to_v in edges[v]:\n        if visited[to_v]:\n            continue\n        visited[to_v] = 1\n        heappush(heap, to_v)\n\nprint(*ans)", "import sys\nimport heapq\n#sys.setrecursionlimit(200000)\ninput = sys.stdin.readline\nn,m = map(int,input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n        a,b = map(int,input().split())\n        a-=1;b-=1\n        g[a].append(b)\n        g[b].append(a)\nque = [0]\nheapq.heapify(que)\nans = []\nused = [0]*n\nfor i in range(n):\n        a = heapq.heappop(que)\n        while used[a] == 1:\n             a = heapq.heappop(que)   \n        used[a] = 1\n        ans.append(a+1)\n        for j in g[a]:\n                if used[j] == 0:\n                        heapq.heappush(que,j)\nprint(*ans)", "import sys\nimport heapq\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGELIST=[[] for i in range(n+1)]\n\nfor x,y in EDGE:\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n\nNOW=EDGELIST[1]\nheapq.heapify(NOW)\n\ncheck=[0]*(n+1)\nANS=[1]\ncheck[1]=1\nwhile NOW:\n    x=heapq.heappop(NOW)\n    if check[x]==1:\n        continue\n    else:\n        ANS.append(x)\n        check[x]=1\n        for e in EDGELIST[x]:\n            if check[e]==0:\n                heapq.heappush(NOW,e)\n\nfor a in ANS:\n    print(a,end=\" \")\n\n        \n", "from collections import defaultdict\nimport heapq\ndef inpl(): return list(map(int, input().split()))\nN, M = inpl()\nEdge = defaultdict(lambda: [])\nfor _ in range(M):\n    a, b = inpl()\n    if a != b:\n        Edge[a].append(b)\n        Edge[b].append(a)\nAns = [] \nvisited = set([1])\nCandi = [1]\nfor _ in range(N):\n    j = heapq.heappop(Candi)\n    for k in Edge[j]:\n        if k not in visited:\n            visited.add(k)\n            heapq.heappush(Candi, k)\n    Ans.append(j)\nprint(*Ans)", "import bisect\n\ndef dfs(i,vis,g):\n\tprint(i,end=\" \")\n\tvis[i]=1\n\tfor j in g[i]:\n\t\tif vis[j]==0:\n\t\t\tdfs(j,vis,g)\n\nn,m=map(int,input().split())\ng=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tbisect.insort(g[u],v)\n\tbisect.insort(g[v],u)\nbfs=[1]\nl=1\nvis=[0]*(n+1)\nvis[1]=1\nwhile l!=0:\n\ti=bfs.pop(0)\n\tprint(i,end=\" \")\n\tl-=1\n\tfor j in g[i]:\n\t\tif vis[j]==0:\n\t\t\tbisect.insort(bfs,j)\n\t\t\tvis[j]=1\n\t\t\tl+=1\n\n#dfs(1,vis,g)\nprint()\n", "from heapq import heappush, heappop, heapify\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) / 2\n    def insertKey(self, k):\n        heappush(self.heap, k)\n\n    def extractMin(self):\n        return heappop(self.heap)\n\nheapObj = MinHeap()\n\n\n\nfrom collections import defaultdict\n\ngraph = defaultdict(list)\nn,m = map(int,input().split())\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\nvisited = [False] * (n)\n# queue = []\nheapObj.insertKey(0)\nvisited[0] = True\ncount = 0\nwhile count !=n:\n    s = heapObj.extractMin()\n    print (s+1, end = \" \")\n    for i in graph[s]:\n        if visited[i] == False:\n            heapObj.insertKey(i)\n            visited[i] = True\n    count+=1\nprint()", "import heapq\nn, m = map(int, input().split())\nvertexs = dict()\nfor i in range(1, n+1):\n    vertexs[i] = []\n\nfor j in range(m):\n    v, u = map(int, input().split())\n    if v != u:\n        vertexs[v].append(u)\n        vertexs[u].append(v)\n\nvis = dict()\ndp = [1]\nvis[1] = True\n\nanswers = []\nfor i in range(n):\n    next_v = heapq.heappop(dp)\n    answers.append(next_v)\n    vis[next_v] = True\n\n    for u in vertexs[next_v]:\n        if u not in vis:\n            heapq.heappush(dp, u)\n            vis[u] = True\n\nprint(*answers, sep=' ')", "from collections import defaultdict, deque\nfrom bisect import insort\nn, m = map(int, input().split())\nd = defaultdict(list)\nvisited = [False]*(n+1)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    insort(d[u], v)\n    insort(d[v], u)\nz = deque([1])\nvisited[1] = True\nwhile z:\n    front = z.popleft()\n    print(front, end = ' ')\n    for i in d[front]:\n        if not visited[i]:\n            insort(z, i)\n            visited[i] = True", "from heapq import *\n\nn , m = list(map( int , input().split() ))\ngraph = {}\n\nfor _ in range(m):\n    a , b = list(map( int , input().split() ))\n    graph.setdefault(a, set()).add(b)\n    graph.setdefault(b, set()).add(a)\n\nans = []\nvisited = set()\nheap = [1]\n\nwhile heap:\n    v = heappop(heap)\n    if v in visited:\n        continue\n    visited.add(v)\n    ans.append(v)\n    for neighbour in graph[v]:\n        heappush(heap, neighbour)\n\nprint(*ans)\n\n", "import sys\nimport collections\nimport heapq\n\ndata = sys.stdin.read().splitlines()\n\nn, m = list(map(int, data[0].split()))\ngraph = collections.defaultdict(set)\n\nfor line in data[1:]:\n    a, b = list(map(int, line.split()))\n    graph[a].add(b)\n    graph[b].add(a)\n\nfor node in graph:\n    graph[node] = sorted(graph[node], reverse=True)\n\n\nvisited = [False] * (n + 1)\nvisited[1] = True\nans = []\nqueue = [1]\n\nwhile True:\n    cur = heapq.heappop(queue)\n    ans.append(cur)\n    if len(ans) == n:\n        break\n    for nei in graph[cur]:\n        if not visited[nei]:\n            visited[nei] = True\n            heapq.heappush(queue, nei)\n\nprint(' '.join(map(str, ans)))\n", "import heapq,sys\ndef __starting_point():\n    path = dict()\n    input()\n    for line in sys.stdin:\n        if line.strip() == '':\n            break\n        n,m = [int(i) for i in line.strip().split()]\n        if n not in path:\n            path[n] = [m]\n        else:\n            path[n].append(m)\n        if m not in path:\n            path[m] = [n]\n        else:\n            path[m].append(n)\n    ans = [1]\n    visited = set([1])\n    pq = path[1]\n    heapq.heapify(pq)\n    while len(pq) > 0:\n        the_next = heapq.heappop(pq)\n        if the_next not in visited:\n            ans.append(the_next)\n            visited.add(the_next)\n            for i in path[the_next]:\n                heapq.heappush(pq,i)\n    print(' '.join([str(i) for i in ans]))\n            \n\n__starting_point()"]
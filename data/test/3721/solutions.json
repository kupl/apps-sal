["import sys\nn,m,q=map(int,input().split())\np=[-1]*(n+m)\nr=[0]*(n+m)\ndef par(i):\n if p[i]==-1: return i\n p[i]=par(p[i])\n return p[i]\ndef merge(a,b):\n a,b=par(a),par(b)\n if a==b: return 0\n if r[a]<r[b]:p[a]=b\n elif r[b]<r[a]:p[b]=a\n else:p[a]=b;r[b]+=1\n return 1\nv=n+m\nfor l in sys.stdin.read().strip().split('\\n') if q else []:\n a,b=map(int,l.split())\n v-=merge(a-1,b-1+n)\nprint(v-1)", "from sys import stdin, stdout\n\nclass DSU:\n\tdef __init__(self, n):\n\t\tself.root = [ -1 for x in range(0, n) ]\n\n\tdef find(self, i):\n\t\tif self.root[i] == -1:\n\t\t\treturn i\n\t\telse:\n\t\t\tself.root[i] = self.find(self.root[i])\n\t\t\treturn self.root[i]\n\n\tdef link(self, i, j):\n\t\tif self.find(i) == self.find(j):\n\t\t\treturn False\n\t\tself.root[self.find(i)] = self.find(j)\n\t\treturn True\n\nn, m, q = map(int, stdin.readline().split())\n\ndsu = DSU(n+m+1)\ngroups = n+m\n\nfor line in stdin:\n\tr, c = map(int, line.split())\n\tgroups -= dsu.link(r, n+c)\n\nstdout.write(str(groups-1) + '\\n')", "from sys import stdin, stdout\n\nclass DSU:\n\tdef __init__(self, n):\n\t\tself.root = [ -1 for x in range(0, n) ]\n\n\tdef find(self, i):\n\t\tif self.root[i] == -1:\n\t\t\treturn i\n\t\telse:\n\t\t\tself.root[i] = self.find(self.root[i])\n\t\t\treturn self.root[i]\n\n\tdef link(self, i, j):\n\t\tif self.find(i) == self.find(j):\n\t\t\treturn False\n\t\tself.root[self.find(i)] = self.find(j)\n\t\treturn True\n\nn, m, q = list(map(int, stdin.readline().split()))\n\ndsu = DSU(n+m+1)\ngroups = n+m\n\nfor line in stdin:\n\tr, c = list(map(int, line.split()))\n\tgroups -= dsu.link(r, n+c)\n\nstdout.write(str(groups-1) + '\\n')\n", "import sys\nioRead = sys.stdin.readline\nioWrite = lambda x: sys.stdout.write(f\"{x}\\n\")\n\nn,m,q = map(int, ioRead().split(\" \"))\nrows_and_columns = n + m\nseen = [False for _ in range(rows_and_columns)]\nconnectsTo = [[] for _ in range(rows_and_columns)]\n\nfor _ in range(q):\n    r,c = map(lambda x: int(x) - 1, ioRead().split(\" \"))\n    c+= n\n    connectsTo[r].append(c)\n    connectsTo[c].append(r)\n\ninserts = -1\nfor i in range(rows_and_columns):\n    if not seen[i]:\n        inserts +=1\n        stack = [i]\n        while stack: #BFS\n            current = stack.pop()\n            if not seen[current]:\n                seen[current] = True\n                for n in connectsTo[current]:\n                    if not seen[n]:\n                        stack.append(n)\n\nioWrite(inserts)", "\"\"\"\nhttps://codeforces.com/contest/1012/problem/B\n\n\"\"\"\nfrom sys import stdin, stdout\nclass UnionFind():\n    def __init__(self, arr=[]):\n        self.rank  = {}\n        self.leader = {}\n        for i in arr:\n            self.rank[i] = 0\n            self.leader[i] = i\n        \n    def __repr__(self):\n        return f\"\"\" Ranks : {self.rank}, leaders : {self.leader} \"\"\"\n    \n    def find(self,x):\n        leader = self.leader.get(x, x)\n        if leader != x:\n            leader = self.find(leader)\n            self.leader[x] = leader\n        return leader\n    \n    def getRank(self,x):\n        return self.rank.get( x, 0)\n    \n    def union(self,x,y):\n        leader1 = self.find(x)\n        leader2 = self.find(y)\n        if leader1 == leader2 : return False\n        if self.getRank(leader1) > self.getRank(leader2):\n            self.leader[leader2] = leader1\n        elif self.getRank(leader1) < self.getRank(leader2):\n            self.leader[leader1] = leader2\n        else:\n            self.leader[leader1] = leader2\n            self.rank[leader2] = 1 + self.getRank(leader2)\n        return True\n\nn,m,q = tuple(map(int,stdin.readline().split()))\nuf = UnionFind( range(1,n+m+1) )\nrcs = [ tuple(map(int,line.split())) for line in stdin ]\ngrps = n+m\nfor r,c in rcs:\n    if uf.union( r, c+n ):\n        grps-=1\n        \nstdout.write(str(grps-1))"]
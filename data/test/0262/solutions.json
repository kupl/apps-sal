["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef func():\n    N = int(input())\n    cells = [0] * N\n\n    if N == 1:\n        return 1\n\n    mx = 0\n    for n in range(N):\n        cells[n] = list(map(int,input().split()))\n        mx = max(mx, sum(cells[n]))\n\n    ans = None\n    for j in range(N):\n        for i in range(N):\n            if cells[j][i] == 0:\n                ans = mx - sum(cells[j])\n                cells[j][i] = ans\n                if ans <= 0:\n                    return -1\n\n    # validation\n    for j in range(N):\n        if sum(cells[j]) != mx:\n            return -1\n    for i in range(N):\n        if mx != sum([cells[j][i] for j in range(N)]):\n            return -1\n    if mx != sum([cells[j][j] for j in range(N)]):\n        return -1\n    if mx != sum([cells[j][N-1-j] for j in range(N)]):\n        return -1\n    \n    return ans\n\nprint(func())\n\n", "n = int(input())\ns = -1\ns1 = -1\nx = -1\ny = -1\nmat = []\nif n == 1:\n    input()\n    print(1)\n    return\nfor i in range(n):\n    arr = list(map(int, input().split()))\n    if s == -1 and 0 not in arr:\n        s = sum(arr)\n    if 0 in arr:\n        x = i\n        s1 = sum(arr)\n        y = arr.index(0)\n    mat.append(arr)\nmat[x][y] = s - s1\nif mat[x][y] <= 0:\n    print(-1)\n    return\nfor i in range(n):\n    if sum(mat[i]) != s:\n        print(-1)\n        return\n    s2 = 0\n    for j in range(n):\n        s2 += mat[j][i]\n    if s2 != s:\n        print(-1)\n        return\ns2 = 0\ns3 = 0\nfor i in range(n):\n    s2 += mat[i][i]\n    s3 += mat[i][n-i-1]\nif s2 != s or s3 != s:\n    print(-1)\n    return\nprint(mat[x][y])", "#!/usr/bin/env python3\n\nn = int(input())\ns = [[int(x) for x in input().split()] for _ in range(n)]\n\np, q = 0, 0\n\nfor i in range(n):\n    for j in range(n):\n        if s[i][j] == 0:\n            p, q = i, j\n\nif n > 1:\n    m = sum(s[(p+1)%n])\n    s[p][q] = m - sum(s[p])\nelse:\n    m = 1\n    s[p][q] = 1\n\nf = True\n\nfor i in range(n):\n    if sum(s[i]) != m:\n        f = False\n    if sum(s[j][i] for j in range(n)) != m:\n        f = False\n        \nif sum(s[i][i] for i in range(n)) != m:\n    f = False\nif sum(s[i][n-i-1] for i in range(n)) != m:\n    f = False\n\nif f and s[p][q] > 0:\n    print(s[p][q])\nelse:\n    print(\"-1\")\n", "n = int(input())\ngrid = [[int(x) for x in input().split()] for _ in range(n)]\n\nif n == 1:\n\tprint(1)\n\treturn\n\nsm = sum(grid[1]) if 0 in grid[0] else sum(grid[0])\n\nanswer = -1\nfor i, line in enumerate(grid):\n\tif 0 in line:\n\t\tj = line.index(0)\n\t\tanswer = sm - sum(line)\n\t\tgrid[i][j] = answer\n\t\tbreak\n\n\nfor line in grid:\n\tif sum(line) != sum(grid[0]):\n\t\tprint(-1)\n\t\treturn\n\nfor i in range(n):\n\trow_count = 0\n\tfor j in range(n):\n\t\trow_count += grid[j][i]\n\n\tif row_count != sum(grid[0]):\n\t\tprint(-1)\n\t\treturn\n\ncount = 0\nfor i in range(n):\n\tcount += grid[i][i]\n\nif count != sum(grid[0]):\n\tprint(-1)\n\treturn\n\ncount = 0\nfor i in range(n):\n\tcount += grid[n-1-i][i]\n\nif count != sum(grid[0]):\n\tprint(-1)\n\treturn\n\nprint(answer if answer > 0 else -1)\n", "N = int(input())\nif N == 1:\n    print(1)\n    return\nmat = []\nfor i in range(N):\n    mat.append(list(map(int, input().split())))\n    if 0 in mat[i]:\n        zero_pos = (i, mat[i].index(0))\n\n# \u548c\u3092\u6c42\u3081\u3066\u304a\u304f\nif zero_pos[0] == 0:\n    v_sum = sum(mat[1])\nelse:\n    v_sum = sum(mat[0])\n\n# \u548c\u304b\u30890\u3092\u57cb\u3081\u308b\nzero_row_sum = sum(mat[zero_pos[0]])\nif v_sum - zero_row_sum <= 0:\n    print(-1)\n    return\nmat[zero_pos[0]][zero_pos[1]] = v_sum - zero_row_sum\n\n# row check\nfor i in range(N):\n    row_sum = sum(mat[i])\n    if row_sum != v_sum:\n        print(-1)\n        return\n\n# col check\nfor j in range(N):\n    col_sum = sum([mat[i][j] for i in range(N)])\n    if col_sum != v_sum:\n        print(-1)\n        return\n\n# diag check\ndiag_sum = sum([mat[i][i] for i in range(N)])\nif diag_sum != v_sum:\n    print(-1)\n    return\n\n# inv diag check\ninv_diag_sum = sum([mat[i][N - i - 1] for i in range(N)])\nif inv_diag_sum != v_sum:\n    print(-1)\n    return\n\nprint(mat[zero_pos[0]][zero_pos[1]])\n", "n = int(input())\n\ngrid = []\n\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\nif n == 1:\n    print(1)\n    return\n\nchecksum = -1;\n\nleft = 0\nmis = -1;\nfor i, col in enumerate(grid):\n    tmp = sum(col)\n    if 0 in col:\n        left = i\n        mis = tmp\n    else:\n        if checksum == -1:\n            checksum = tmp\n        elif checksum != tmp:\n            print(-1)\n            return\n\nif mis >= checksum:\n    print(-1)\n    return\n\ngrid[left] = [x if x else checksum - mis for x in grid[left]]\n\ndiag1 = 0\ndiag2 = 0\nfor i in range(n):\n    colsum = 0\n    rowsum = 0\n    diag1 += grid[i][i]\n    diag2 += grid[n-1-i][i]\n    for j in range(n):\n        colsum += grid[i][j]\n        rowsum += grid[j][i]\n\n    if colsum != checksum or rowsum != checksum:\n        print(-1)\n        return\n\nif diag1 != checksum or diag2 != checksum:\n    print(-1)\n    return\n\nprint(checksum - mis)\n", "n = int(input()) \nif n == 1:\n\tprint('1')\n\treturn\nA = []\nC = [0 for i in range(n)]\ndiag1 = 0\ndiag2 = 0\nfor i in range(n):\n\tB = list(map(int, input().split()))\n\tfor j in range(n):\n\t\tel = B[j]\n\t\tC[j] += el\n\t\tif i == j:\n\t\t\tdiag1 += el\n\t\tif i + j == n - 1:\n\t\t\tdiag2 += el\t\n\t\tif el == 0:\n\t\t\tx = i\n\t\t\ty = j\n\tA.append(B)\nif x == 0:\n\ts = sum(A[1])\nelse:\n\ts = sum(A[0])\t\nfor i in range(n):\n\tif i != x:\n\t\tif s != sum(A[i]):\n\t\t\tprint('-1')\n\t\t\treturn\nfor i in range(n):\n\tif i != y:\n\t\tif s != C[i]:\n\t\t\tprint('-1')\n\t\t\treturn\nans = s - C[y]\nif ans + sum(A[x]) != s:\n\tprint('-1')\n\treturn\nif x == y:\n\tdiag1 += ans\nif x + y == n - 1:\n\tdiag2 += ans\nif diag1 != s:\n\tprint('-1')\n\treturn\nif diag2 != s:\n\tprint('-1')\n\treturn\t\t\t\t\t\t\t\nif ans < 1:\n\tprint('-1')\n\treturn\nprint(ans)\n", "n = int(input())\nline = []\nfor i in range(n):\n    line += [list(map(int, input().split()))]\nlist_str = []\nif line == [[0]]:\n    print(1)\nelse:    \n    for i in range(n):\n        plus = False\n        answer = 0\n        for j in range(n):\n            element = line[i][j]\n            if element == 0:\n                plus = True\n            answer += element\n        if plus:\n            osob = answer\n        else:\n            list_str += [answer]\n    if len(list_str) != 0 and min(list_str) != max(list_str):\n        print(-1)\n    else:\n        chislo1 = min(list_str) - osob\n        s1 = min(list_str)    \n        list_str = []    \n        for i in range(n):\n            plus = False\n            answer = 0\n            for j in range(n):\n                element = line[j][i]\n                if element == 0:\n                    plus = True\n                answer += element\n            if plus:\n                osob = answer\n            else:\n                list_str += [answer]\n        if len(list_str) == 0 or min(list_str) != max(list_str):\n            print(-1)\n        else:\n            chislo2 = min(list_str) - osob\n            s2 = min(list_str)    \n            answer = 0\n            plus = False\n            for i in range(n):\n                element = line[i][i]\n                answer += element\n                if element == 0:\n                    plus = True\n            if not plus:\n                s3 = answer\n                chislo3 = chislo2\n            else:    \n                s3 = s2\n                chislo3 = s2 - answer\n            answer = 0\n            plus = False\n            for i in range(n):\n                element = line[i][n - i - 1]\n                answer += element\n                if element == 0:\n                    plus = True\n            if not plus:\n                s4 = answer\n                chislo4 = chislo2\n            else:    \n                chislo4 = s2 - answer \n                s4 = s2 \n            if s1 == s2 and s1 == s3 and s1 == s4 and chislo1 == chislo2 and chislo1 == chislo3 and chislo1 == chislo4 and s1 > 0 and chislo1 > 0:\n                print(chislo1)\n            else:\n                print(-1)\n", "n = int(input())\narr = []\nfor i in range(n):\n    arr.append([int(x) for x in input().split()])\nif(n==1):\n    print(1)\n    return\n\nii,jj = 0,0\nfor i in range(n):\n    for j in range(n):\n        if(arr[i][j]==0):\n            ii,jj = i,j\n\nprr = []\nqrr = []\nfor i in range(n):\n    if(i==ii):\n        qrr.append(sum(arr[i]))\n    else:\n        prr.append(sum(arr[i]))\nfor j in range(n):\n    s = 0\n    for i in range(n):\n        s += arr[i][j]\n    if(j==jj):\n        qrr.append(s)\n    else:\n        prr.append(s)\ns = 0\nfor i in range(n):\n    s += arr[i][i]\nif(ii==jj):\n    qrr.append(s)\nelse:\n    prr.append(s)\ns = 0\nfor i in range(n):\n    s += arr[i][n-i-1]\nif(ii+jj==n-1):\n    qrr.append(s)\nelse:\n    prr.append(s)\n\nif(len(prr)==prr.count(prr[0]))and(len(qrr)==qrr.count(qrr[0])):\n    x = prr[0]-qrr[0]\n    if(x>0):\n        print(x)\n    else:\n        print(-1)\nelse:\n    print(-1)", "n = int(input())\nk = []\nfor i in range(n):\n\ta = [int(i) for i in input().split()]\n\tk.append(a)\nif n == 1:\n\tprint(1)\nelse:\n\tzer = []\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif 0 == k[i][j]:\n\t\t\t\tzer = [i, j]\n\tif zer[0] == 0:\n\t\tm = sum(k[1])\n\telse:\n\t\tm = sum(k[0])\n\tk[zer[0]][zer[1]] = m-sum(k[zer[0]])\n\tif k[zer[0]][zer[1]] > 0:\n\t\ty = 1\n\telse:\n\t\ty = 0\n\tfor i in range(n):\n\t\tif sum(k[i]) != m:\n\t\t\ty = 0\n\tfor j in range(n):\n\t\tu = 0\n\t\tfor i in range(n):\n\t\t\tu+= k[i][j]\n\t\tif u!= m:\n\t\t\ty = 0\n\tu = 0\n\tfor i in range(n):\n\t\tu+=k[i][i]\n\tif u!= m:\n\t\ty = 0\n\tu = 0\n\tfor i in range(n):\n\t\tu+=k[i][n-i-1]\n\tif u!= m:\n\t\ty = 0\n\tif y == 1:\n\t\tprint(k[zer[0]][zer[1]])\n\telse:\n\t\tprint(-1)\n", "def main():\n    def magic(sq, n):\n        s1 = sum(sq[0])\n        for i in range(1, n):\n            if s1 != sum(sq[i]):\n                return False\n        s2 = 0\n        for i in range(n):\n            s2 += sq[i][i]\n        if s2 != s1:\n            return False\n        s2 = 0\n        for i in range(n):\n            s2 += sq[i][n - i - 1]\n        if s2 != s1:\n            return False\n        for i in range(n):\n            s2 = 0\n            for j in range(n):\n                s2 += sq[j][i]\n            if s2 != s1:\n                return False\n        return True\n    n = int(input())\n    sq = [list(map(int, input().split())) for i in range(n)] + [[1]]\n    for i in range(n):\n        if 0 in sq[i]:\n            cors = (i, sq[i].index(0))\n    if cors[0] != 0:\n        s = sum(sq[0])\n    else:\n        s = sum(sq[1])\n    sq[cors[0]][cors[1]] = s - sum(sq[cors[0]])\n    if magic(sq, n) and sq[cors[0]][cors[1]] >= 1:\n        print(sq[cors[0]][cors[1]])\n    else:\n        print(-1)\n\nmain()", "#B\nn = int(input())\na = [list(map(int,input().split())) for j in range(n)]\n\nif n == 1:\n    print(1)\n    return\n\nfor j in range(n):\n    for i in range(n):\n        if a[j][i] == 0:\n            y = j\n            x = i\n            break\n\nslist = []\nfor j in range(n):\n    if j == y:\n        continue\n    ss = 0\n    for i in range(n):\n        ss += a[j][i]\n    slist.append(ss)\n\nfor i in range(n):\n    if i == x:\n        continue\n    ss = 0\n    for j in range(n):\n        ss += a[j][i]\n    slist.append(ss)\n\nif x != y:\n    ss = 0\n    for i in range(n):\n        ss += a[i][i]\n    slist.append(ss)\n\nif x != n - 1 - y:\n    ss = 0\n    for i in range(n):\n        ss += a[n - 1 - i][i]\n    slist.append(ss)\n\nslist.sort()\n\nif slist[0] != slist[-1]:\n    print(-1)\n    return\n\ns = slist[0]\ns1 = s\ns2 = s\ns3 = s\ns4 = s\n\nfor i in range(n):\n    s1 -= a[y][i]\n\nfor i in range(n):\n    s2 -= a[i][x]\n\nif x == y:\n    for i in range(n):\n        s3 -= a[i][i]\nelse:\n    s3 = s1\n\nif x == n - 1 - y:\n    for i in range(n):\n        s4 -= a[n - 1 - i][i]\nelse:\n    s4 = s1\n\nif s1 == s2 == s3 == s4 and s1 > 0:\n    print(s1)\nelse:\n    print(-1)", "#!/usr/bin/env pypy3\n\nNO_SOL = -1\n\n\ndef main():\n    n = int(input())\n    if n == 1:\n        print(1)\n        return\n    zero = None\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n        if zero is None:\n            try:\n                zero = (i, grid[i].index(0))\n            except Exception:\n                zero = None\n    sum_sample = None\n    for i in range(n):\n        if i == zero[0]:\n            continue\n        else:\n            sum_sample = sum(grid[i])\n            break\n    zero_cand = sum_sample - sum(grid[zero[0]])\n    if zero_cand <= 0:\n        print(NO_SOL)\n        return\n    grid[zero[0]][zero[1]] = zero_cand\n    for row in grid:\n        if sum(row) != sum_sample:\n            print(NO_SOL)\n            return\n    for column in zip(*grid):\n        if sum(column) != sum_sample:\n            print(NO_SOL)\n            return\n    if sum(grid[i][i] for i in range(n)) != sum_sample:\n        print(NO_SOL)\n        return\n    if sum(grid[i][n - i - 1] for i in range(n)) != sum_sample:\n        print(NO_SOL)\n        return\n    print(zero_cand)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\ndef check(a, t):\n    n = len(a)\n    for i in range(n):\n        if sum(a[i]) != t:\n            return False\n    for j in range(n):\n        if sum(a[i][j] for i in range(n)) != t:\n            return False\n    return sum(a[i][i] for i in range(n)) == sum(a[i][-i - 1] for i in range(n)) == t\n\ndef main():\n    try:\n        while True:\n            n = int(input())\n            a = [list(map(int, input().split())) for i in range(n)]\n            if n == 1:\n                print(1)\n            else:\n                try:\n                    j = a[0].index(0)\n                    i = 0\n                    t = sum(a[1])\n                    x = t - sum(a[0])\n                except ValueError:\n                    t = sum(a[0])\n                    for i in range(1, n):\n                        try:\n                            j = a[i].index(0)\n                            x = t - sum(a[i])\n                            break\n                        except ValueError:\n                            pass\n                a[i][j] = x\n                print(x if x > 0 and check(a, t) else -1)\n\n    except EOFError:\n        pass\n\nmain()\n", "from sys import stdin\n\nn=int(stdin.readline())\ncarre=[list(map(int,stdin.readline().split())) for i in range(n)]\nsommesCol=[0]*n\nsommesLig=[0]*n\nif n==1:\n    print(1)\n    return\n    \nfor lig in range(n):\n    for col in range(n):\n        if carre[lig][col]==0:\n            ligManque=lig\n            colManque=col\n        else:\n            sommesCol[col]+=carre[lig][col]\n            sommesLig[lig]+=carre[lig][col]\n\nsommeDiagonale=0\nsommeDiagonaleInv=0\nfor i in range(n):\n    sommeDiagonale+=carre[i][i]\n    sommeDiagonaleInv+=carre[i][n-i-1]\nreference=sommesCol[(colManque+1)%n]\nremplacement=reference-sommesCol[colManque]\n\nsommesCol[colManque]+=remplacement\nsommesLig[ligManque]+=remplacement\nif ligManque==colManque:\n    sommeDiagonale+=remplacement\nif ligManque==n-colManque-1:\n    sommeDiagonaleInv+=remplacement\n\npossible=True\nif sommeDiagonale!=reference:\n    possible=False\nif sommeDiagonaleInv!=reference:\n    possible=False\nfor col in range(n):\n    if sommesCol[col]!=reference:\n        possible=False\nfor lig in range(n):\n    if sommesLig[lig]!=reference:\n        possible=False\n\nif not possible or remplacement<=0:\n    print(-1)\nelse:\n    print(remplacement)\n", "\nn = int(input())\n\nv = [list(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    print(1)\n    return\n\ndef sum_diag1(v):\n    s = 0\n    for i in range(len(v)):\n        s += v[i][i]\n    return s\n\ndef sum_diag2(v):\n    s = 0\n    for i in range(len(v)):\n        s += v[i][len(v) - 1 - i]\n    return s\n\ndef sum_row(v, r):\n    return sum(v[r])\n\ndef sum_col(v, c):\n    s = 0\n    for r in range(len(v)):\n        s += v[r][c]\n    return s\n\nrow = 0\ncol = 0\n\nneeded_sum = 0\nrow_sum = 0\ncol_sum = 0\ndiag1_sum = 0\ndiag2_sum = 0\n\nfor r in range(len(v)):\n    if 0 in v[r]:\n        row = r\n        col = v[r].index(0)\n        if needed_sum != 0:\n            break\n    elif needed_sum == 0:\n        needed_sum = sum(v[r])\n\nt = needed_sum - sum(v[row])\nv[row][col] = t\n\nl = [sum_row(v, r) for r in range(n)]\nl += [sum_col(v, c) for c in range(n)]\nl += [sum_diag1(v), sum_diag2(v)]\n\nif len(set(l)) == 1 and t > 0:\n    print(t)\nelse:\n    print(-1)\n    \n    \n", "n=int(input())\nrs=[]\ncs=[0 for i in range(n)]\nd1=0\nd2=0\nfor i in range(n):\n    ip=list(map(int,input().split()))\n    rs.append(sum(ip))\n    if 0 in ip:\n        l=i\n        k=ip.index(0)\n    for j in range(n):\n        cs[j]+=ip[j]\n    d1+=ip[i]\n    d2+=ip[n-i-1]\nif n==1:\n    print(1)\nelse:\n    if l==0:\n        r=rs[1]\n    else:\n        r=rs[0]\n    ans=r-rs[l]\n    if l==k:\n        d1+=ans\n    if l==n-k-1:\n        d2+=ans\n    rc=0\n    cc=0\n    for i in rs:\n        if i!=r:\n            rc+=1\n    for i in cs:\n        if i!=r:\n            cc+=1\n    if rc!=1 or cc!=1:\n        print(-1)\n    elif d1!=r or d2!=r:\n        print(-1)\n    elif ans<=0:\n        print(-1)\n    else:\n        print(ans)\n\n", "lines = int(input())\nif lines == 1:\n    print(1)\n    return\ngrid = []\nnumber_with_zero = set()\nimpossible = False\nno_zero = -1\n\nfor x in range(lines):\n    num = list(map(int, input().split()))\n    grid.append(num)\n\nfor line in grid:\n    have_zero = False\n    s = 0\n    for n in line:\n        if n ==0:\n            have_zero = True\n        else:\n            s += n\n    if have_zero:\n        number_with_zero.add(s)\n    elif no_zero == -1:\n        no_zero = s\n    elif no_zero != s:\n        impossible = True\n\n# print(impossible, 1)\nfor x in range(lines):\n    have_zero = False\n    s = 0\n    for y in range(lines):\n        n =  grid[y][x]\n        if n ==0:\n            have_zero = True\n        else:\n            s += n\n    if have_zero:\n        number_with_zero.add(s)\n    elif no_zero == -1:\n        no_zero = s\n    elif no_zero != s:\n        impossible = True\n# print(impossible, 2)\n\ns = 0\nhave_zero = False\nfor x in range(lines):\n    n =  grid[x][x]\n    if n ==0:\n        have_zero = True\n    else:\n        s += n\n\n# print(s, no_zero)\nif have_zero:\n    number_with_zero.add(s)\nelif no_zero == -1:\n    no_zero = s\nelif no_zero != s:\n    impossible = True\n# print(impossible, 3)\n\ns = 0\nhave_zero = False\nfor x in range(lines):\n    n =  grid[x][lines -1 - x]\n    if n ==0:\n        have_zero = True\n    else:\n        s += n\n\nif have_zero:\n    # print(\"COME\")\n    number_with_zero.add(s)\nelif no_zero == -1:\n    no_zero = s\nelif no_zero != s:\n    impossible = True\n# print(impossible, 4)\n\nif impossible:\n    print(-1)\nelse:\n    if len(number_with_zero) == 1:\n        num = list(number_with_zero)[0]\n        # print(num)\n        if (no_zero - num <= 0):\n            print(-1)\n        else:\n            print(no_zero - num)\n    else:\n        print(-1)\n", "from collections import defaultdict\nimport sys, os, math\n\ndef __starting_point():\n    #n, m = list(map(int, input().split()))\n    n = int(input())\n    s = [list(map(int, input().split())) for i in range(n)]\n    if n == 1:\n        print(1)\n        return\n    pos = []\n    for i in range(n):\n        for j in range(n):\n            if s[i][j] == 0:\n                pos = [i, j]\n                break;\n    val = sum(s[(pos[0] + 1) % n])\n    s[pos[0]][pos[1]] = max(val - sum(s[pos[0]]), 1)\n    #check\n    for i in range(n):\n        if sum(s[i]) != val:\n            print(-1)\n            return\n    for j in range(n):\n        t = 0\n        for i in range(n):\n            t += s[i][j]\n        if t != val:\n            print(-1)\n            return\n    t, tt = 0, 0\n    for i in range(n):\n        t += s[i][i]\n        tt += s[i][n - 1 - i]\n    if t != val or tt != val:\n        print(-1)\n        return\n           \n    print(s[pos[0]][pos[1]])\n    '''\n    for i in range(n):\n        print(' '.join(map(str, s[i])))\n    '''\n__starting_point()", "import sys\nn = int(input())\nmat = []\nempty = (None, None)\nif n == 1:\n    print(1)\n    return\nfor i in range(n):\n    row = [int(x) for x in input().strip().split()]\n    if 0 in row:\n        col = row.index(0)\n        empty = (i, col)\n    mat.append(row)\ni = 0\nif 0 in mat[i]:\n    i += 1\nrowsum = sum(mat[i])\nrow = empty[0]\nfor i in range(n):\n    if i == row:\n        continue\n    cursum = sum(mat[i])\n    # print(cursum)\n    if cursum != rowsum:\n        print(-1)\n        return\ntmat = list(zip(*mat))\ncol = empty[1]\nfor i in range(n):\n    if i == col:\n        continue\n    else:\n        #print(cursum)\n        cursum = sum(tmat[i])\n        if cursum != rowsum:\n            print(-1)\n            return\nrow = empty[0]\nirowsum = sum(mat[row])\ncolsum = sum(tmat[col])\n#print(irowsum, colsum)\nif irowsum != colsum:\n    print(-1)\n    return\nleft = 0\nright = 0\ntochange = rowsum - irowsum\nif tochange <= 0:\n    print(-1)\n    return\nmat[row][col] = tochange\nif True:\n    for i in range(n):\n        #print(mat[i][i], mat[i][n - i - 1])\n        left += mat[i][i]\n        right += mat[i][n - i - 1]\n    #print(left, right)\n    #print(row, col, left, rowsum)\nif left != right or left != rowsum:\n    print(-1)\n    return\nprint(tochange)\n", "#imports\nimport sys\nsys.setrecursionlimit(30000)\n\nfrom collections import Counter, defaultdict, deque\nfrom math import ceil, floor, factorial, fsum, isinf, exp, log, log10, log2, isfinite, sqrt\nfrom math import pi as PI, e as E\nfrom math import sin, cos, tan, sinh, cosh, tanh, asin, acos, atan\nfrom fractions import Fraction\nfrom itertools import starmap, tee, chain, filterfalse, combinations as combos\nfrom itertools import permutations as perms, product as prod, combinations_with_replacement as rcombos\nfrom functools import reduce, partial\nimport operator as ops #lt, le, eq, ne, ge, gt,  xor  notit, lshift, rshift,      neg, add, mul, sub,\nfrom operator import __not__ as notit, __abs__ as absit, __or__ as orit\nfrom bisect import insort_left, bisect_left, bisect_right\nfrom copy import deepcopy\n\n\n#PI, E, PHI, INF\nPHI, PHI2 = (1 + 5 ** 0.5) / 2, (5 ** 0.5 - 1) / 2\nINF = float('inf')\n\n#structures\nclass TreeNode:\n    def __init__(self, v):\n        self.val = v\n        self.left = None\n        self.right = None\n\n#Bit Manipulation\n#<<, >>, bin(), int(s, 2)\ndef setBit(x, offset):\n    return x | 1 << offset #RHS: mask\ndef clearBit(x, offset):\n    return x & ~(1 << offset) #RHS: mask\ndef getBit(x, offset):\n    return 1 if testBit(x, offset) > 0 else 0\ndef testBit(x, offset):\n    return x & 1 << offset #RHS: mask\ndef flipBitAt(x, offset):\n    return x ^ 1 << offset #RHS: mask\ndef flipBits(x, length=-1): #default: x.bit_length() - 1\n    length = x.bit_length()-1 if length == -1 else length\n    return x ^ (1 << length) - 1\ndef numBits(x):\n    return x.bit_length() #int.bit_length()\ndef countOnes(x):\n    return bin(x).count('1')\ndef countZeros(x, length=-1):\n    length = x.bit_length() if length == -1 else length\n    return length - countOnes(x)\n\n#IO\ndef getList(tcast=str):\n    return [tcast(x) for x in input().strip().split(' ')]\ndef getItems(*tcast):\n    return list(map(lambda f, x: f(x), tcast, getList()))\ndef getVal(tcast=str):\n    return tcast(input().strip())\ndef getMatrix(r, tcast=str):\n    return [getList(tcast) for row in range(r)]\n\n#Math\ndef isOdd(n):\n    return n & 1 > 0\ndef isEven(n):\n    return not n & 1\ndef numDigits(n):\n    return len(str(n)) - (1 if n < 0 else 0)\ndef _gcd(a, b):\n    while b: #is not zero\n        a, b = b, a % b\n    return a\ndef gcd(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        if cur == 1:\n            return cur\n        cur = _gcd(cur, n)\n    return cur\ndef _lcm(a, b):\n    return (a // gcd(a, b)) * b\ndef lcm(*xs):\n    nums = xs[0] if type(xs[0]) == list else list(xs)\n    cur = nums[0]\n    for n in nums[1:]:\n        cur = _lcm(cur, n)\n    return cur\ndef primesUpto(n):\n    isp = [True] * (n + 1)\n    isp[0], isp[1] = False, False\n    primes = []\n    for i, x in enumerate(isp): #for each number\n        if x: #found a prime\n            primes.append(i)\n            mults = i * i\n            while mults <= n:\n                isp[mults] = False\n                mults += i\n    return primes\ndef primeFactor(n): #without a sieve\n    factors = Counter()\n    while not n&1:\n        factors[2] += 1\n        n >>= 1\n    trynum = 3\n    while trynum <= ceil(sqrt(n)): #just in case\n        while n % trynum == 0:\n            factors[trynum] += 1\n            n //= trynum\n        trynum += 2\n    if n != 1:\n        factors[n] += 1\n    return factors\ndef isPrime(n): #num -> boolean\n    if n&1 and n >= 2:\n        trynum = 3\n        limit = ceil(sqrt(n))\n        while trynum < limit:\n            if n % trynum == 0:\n                return False\n            trynum += 2\n        else:\n            return True\n    else:\n        return False\ndef nthFib(n):\n    if n <= 2:\n        return 1\n    else:\n        a, b = 1, 1\n        while n > 2:\n            a, b = b, a + b\n            n -= 1\n        return b\n\n#Iteration\ndef zipNWith(f, *x): #xs, ys, ... zs -> elementwise f -> os #return map(lambda *y: f(y), x) #list way: [f(y) for y in zip(*xs)]\n    return (f(y) for y in zip(*x))\ndef zipWith(f, xs, ys):\n    return (f(x, y) for x, y in zip(xs, ys))\ndef flatten(xs):\n    return reduce(ops.concat, xs)\ndef quantify(pred, it):\n    return sum(map(pred, it))\ndef dotproduct(xs, ys):\n    return sum(map(ops.mul, xs, ys))\ndef adjpairs(it):\n    a, b = tee(it)\n    next(b, None)\n    return list(zip(a, b))\ndef bipartition(pred, it):\n    t, f = tee(it)\n    return list(filter(pred, t)), filterfalse(pred, f)\ndef powerset(it):\n    s = list(it)\n    return chain.from_iterable(combos(s, r) for r in range(len(s) + 1))\ndef depProduct(bounds, f=lambda y:y+1, g=lambda *x:tuple(x)):\n    args = [-1]\n    nbounds = len(bounds)\n    while args:\n        n = len(args)\n        args[-1] += 1\n        if args[-1] >= bounds[n-1]:\n            args.pop()\n        elif n == nbounds:\n            yield g(*args)\n        else:\n            _f = f[n] if type(f) == list else f\n            args.append(_f(args[-1]) - 1)\ndef revEnumerate(xs):\n    n = len(xs) - 1\n    for i, x in enumerate(reversed(xs)):\n        yield (n - i, x)\n'''\ndef shiftchar(c, offset):\n    return c +\n'''\n\n\n\n\n\n\n\n#print(sys.getsizeof())\n\n\n#Input\n\n#Body\n\n#Output\n#n, m, a = getList(int)\n#print(ceil(m/a) * ceil(n/a))\nnrows = getVal(int)\nmat = getMatrix(nrows, int)\n\nif nrows == 1:\n    print(1)\nelse:\n    #locate\n    for i, r in enumerate(mat):\n        for j, c in enumerate(r):\n            if c == 0:\n                wantx, wanty = i, j\n    assert mat[wantx][wanty] == 0\n    example = 0 if wantx > 0 else 1\n    target = sum(mat[example])\n    #print(target)\n    mystery = target - sum(mat[wantx])\n    #print(mystery)\n    mat[wantx][wanty] = mystery\n    #perf cehcks\n\n    def check(ri, ci, dr, dc):\n        nonlocal nrows, mat\n        r, c = ri, ci\n        total = 0\n        for t in range(nrows):\n            total += mat[r][c]\n            r, c = r + dr, c + dc\n\n        return total\n    vert, hor = (1, 0), (0, 1)\n    diag1 = (1, 1)\n    diag2 = (1, -1)\n    for i in range(nrows):\n        if check(i, 0, *hor) != target or check(0, i, *vert) != target:\n            print(-1)\n            break\n    else:\n        if check(0, 0, *diag1) == target and check(0, nrows - 1, *diag2) == target:\n            print(mystery if mystery > 0 else -1)\n        else:\n            print(-1)\n        #print('row', i, check(i, 0, *hor))\n        #print('col', i, check(0, i, *vert))\n", "\ndef main():\n    n = int(input())\n    matrix = []\n    s = None\n    found = False\n    col = 0\n    row = 0\n    if n == 1:\n        i = input()\n        return 1\n    for i in range(n):\n        line = [int(k) for k in input().split(' ')]\n        matrix.append(line)\n        if not found:\n            try:\n                index = line.index(0)\n                row = i\n                col = index\n                continue\n            except ValueError:\n                pass\n\n        if s is None:\n            s = sum(line)\n        else:\n            if s != sum(line):\n                return -1\n\n\n    res = s - sum(matrix[row])\n    if res < 1:\n        return -1\n    else:\n        matrix[row][col] = res\n\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += matrix[j][i]\n        if t != s:\n            return -1\n    d1 = 0\n    d2 = 0\n    for i in range(n):\n        d1 += matrix[i][i]\n        d2 += matrix[i][n-1-i]\n    if d1 != s or d2 != s:\n        return -1\n\n    return res\n\n\ndef __starting_point():\n    print(main())\n\n__starting_point()", "n = int(input())\narr = []\nnullRow = nullCol = 0\nfor i in range(n):\n    arr.append(list())\n    for j, x in enumerate(list(map(int, input().split()))):\n        arr[i].append(x)\n        if x == 0:\n            nullRow = i\n            nullCol = j\narrT = list(zip(*arr))\nsumRow = sum(arr[0 if nullRow != 0 or n == 1 else 1])\nsumCol = sum(arrT[0 if nullCol != 0 or n == 1 else 1])\nguessByRow = 0\nguessByCol = 0\nsolvable = True\nfor i in range(n):\n    currSum = sum(arr[i])\n    if i == nullRow:\n        guessByRow = sumRow - currSum \n    elif currSum != sumRow:\n        solvable = False\nfor j in range(n):\n    currSum = sum(arrT[j])\n    if j == nullCol:\n        guessByCol = sumCol - currSum \n    elif currSum != sumCol:\n        solvable = False\nif guessByRow != guessByCol or sumRow != sumCol:\n    solvable = False\nif solvable:\n    arr[nullRow][nullCol] = guessByRow\nsumDiagLeft = sumDiagRight = 0\nfor i in range(n):\n    sumDiagRight += arr[i][n - i - 1]\n    sumDiagLeft += arr[i][i]\nif sumDiagLeft != sumDiagRight or sumRow != sumDiagLeft:\n    solvable = False\nif n == 1:\n    print(1)\nelif solvable and guessByRow > 0:\n    print(guessByRow)\nelse:\n    print(-1)"]
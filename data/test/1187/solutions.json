["import sys\nimport math\ndef getAndParseInt(num=1):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return int(string)\n    else:\n        return [int(part) for part in string.split()]\n\ndef getAndParseString(num=1,delim=\" \"):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return string\n    else:\n        return [part for part in string.split(delim)]\n\nn, m = getAndParseInt(2)\nadj_list = [[] for i in range(n)]\nedge_list = []\nfor i in range(m):\n    u, v = getAndParseInt(2)\n    edge_list.append((u,v))\n    adj_list[u-1].append(v-1)\n\nvisited = set()\nstack = []\nfinished_exploring = [False for i in range(n)]\nedge_colors = {}\nacyclic = True\n\nfor i in range(n):\n    if i not in visited:\n        stack.append((i,0))\n    else:\n        continue\n    while stack:\n        cur_vertex, neigh_index = stack.pop()\n        if neigh_index == 0:\n            visited.add(cur_vertex)\n\n        if neigh_index == len(adj_list[cur_vertex]):\n            finished_exploring[cur_vertex] = True\n        else:\n            stack.append((cur_vertex, neigh_index + 1))\n            neighbor = adj_list[cur_vertex][neigh_index]\n            if neighbor not in visited:\n                stack.append((neighbor, 0))\n                edge_colors[(cur_vertex+1,neighbor+1)]='1'\n                visited.add(neighbor)\n            elif neighbor in visited and not finished_exploring[neighbor]:\n                edge_colors[(cur_vertex+1,neighbor+1)]='2'\n                acyclic = False\n            else:\n                edge_colors[(cur_vertex+1,neighbor+1)]='1'\n\nif acyclic:\n    print(1)\n    output_list = [\"1\" for i in range(m)]\nelse:\n    print(2)\n    output_list = []\n    for edge in edge_list:\n        output_list.append(edge_colors[edge])\nprint(\" \".join(output_list))\n\n\n\n\n", "from sys import stdin\ninput = stdin.readline\n\nn, m = [int(i) for i in input().split()]\n\nedges = [[[0 for i in range(n)], 0] for i in range(n+1)]\nedges_2 = [[0, 0] for i in range(m)]\n\nfor i in range(m):\n    v, w = [int(i) for i in input().split()]\n    edges[v][0][edges[v][1]] = w\n    edges[v][1] += 1\n    edges_2[i] = [v, w]\n    \nis_one = True\n    \nfor i in range(1, n+1):\n    visited = [0 for i in range(n)]\n    visited[0] = i\n    num_visited = 1\n    act = 0\n    \n    while act <= (num_visited-1):\n        for j in range(edges[visited[act]][1]):\n            if edges[visited[act]][0][j] == i: is_one = False\n            else:\n                if edges[visited[act]][0][j] not in visited:\n                    visited[num_visited] = edges[visited[act]][0][j]\n                    num_visited += 1\n        \n        act += 1\n\nif is_one:\n    print(1)\n    for i in range(m-1):\n        print(\"1\", end = \" \")\n    print(1)\n    \nelse:\n    print(2)\n    for i in range(m-1):\n        if edges_2[i][0] < edges_2[i][1]: print(\"1\", end = \" \")\n        else: print(\"2\", end = \" \")\n    if edges_2[-1][0] < edges_2[-1][1]: print(\"1\")\n    else: print(\"2\")\n    ", "def DFS(graph, status, v):\n    status[v] = 1\n    for u in graph[v]:\n        if status[u] == 1:\n            return True\n        if status[u] == 0:\n            if DFS(graph, status, u):\n                return True\n    status[v] = 2\n\n\ndef containsCycle(graph):\n    n = len(graph)\n    status = [0] * n\n    for v in range(n):\n        if status[v] != 0:\n            continue\n        if DFS(graph, status, v):\n            return True\n    return False\n\n\nnm = input().split()\nn = int(nm[0])\nm = int(nm[1])\n\ngraph = [set() for _ in range(n)]\nedges = []\nfor _ in range(m):\n    edge = input().split()\n    u = int(edge[0]) - 1\n    v = int(edge[1]) - 1\n    edges.append((u, v))\n\n    graph[u].add(v)\n\nif (not containsCycle(graph)):\n    print(1)\n    answer = [1]*m\n    print(*answer)\nelse:\n    print(2)\n    answer = []\n    for e in edges:\n        if e[0] > e[1]:\n            answer.append(1)\n        else:\n            answer.append(2)\n    print(*answer)\n", "n, m = [int(item) for item in input().split()]\nedge = [[] for _ in range(n)]\nvisited = [False] * n\nraw = []\nfor i in range(m):\n    a, b = [int(item) for item in input().split()]\n    a -= 1; b -= 1\n    raw.append((a, b))\n    edge[a].append(b)\n\nclass DirectedGraph:\n    def __init__(self, adj):\n        self.n = len(adj)\n        self.adj = adj\n        self.is_asyclic = False\n        self.max_path_len = None\n\n    def topological_sort(self):\n        indegree = [0] * self.n\n        for i, vs in enumerate(self.adj):\n            for dest in vs:\n                indegree[dest] += 1\n        zero_v = []\n        for v, indeg in enumerate(indegree):\n            if indeg == 0:\n                zero_v.append(v)\n        max_path_len = 1\n        tp_sorted = []\n        to_be_added = []\n        while True:\n            while zero_v:\n                v = zero_v.pop()\n                tp_sorted.append(v)\n                for dest in self.adj[v]:\n                    indegree[dest] -= 1\n                    if indegree[dest] == 0:\n                        to_be_added.append(dest)\n            if len(to_be_added) > 0:\n                zero_v += to_be_added\n                to_be_added = []\n                max_path_len += 1\n            else:\n                break\n        if len(tp_sorted) == self.n:\n            self.is_asyclic = True\n            self.max_path_len = max_path_len\n            return tp_sorted\n        else:\n            self.is_asyclic = False\n            return None\n\n\nDG = DirectedGraph(edge)\ntp_sorted = DG.topological_sort()\nif DG.is_asyclic:\n    print(1)\n    print(\" \".join([\"1\" for _ in range(m)]))\n    return\nelse:\n    print(2)\n    ans = []\n    for a, b in raw:\n        if a > b:\n            ans.append(1)\n        else:\n            ans.append(2)\n    print(\" \".join([str(item) for item in ans]))", "def dfs(inp, stat, u):\n    if stat[u] > 1:\n        return stat[u] < 3\n    stat[u] = 2\n    for v in inp[u]:\n        if dfs(inp, stat, v):\n            return True\n    stat[u] = 3\n    return False\n\n\ndef main():\n    ans = []\n    n, m = list(map(int, input().split()))\n    inp = tuple(([] for _ in range(n + 1)))\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        ans.append((u > v) + 1)\n        inp[u].append(v)\n    stat = [1] * (n + 1)\n    for u in range(n + 1):\n        if dfs(inp, stat, u):\n            print(2)\n            print(*ans)\n            break\n    else:\n        print(1)\n        print(*(1,) * m)\n\n\nmain()\n", "import math\n# import sys\n# input = sys.stdin.readline\nn,m=[int(i) for i in input().split(' ')]\nd=[[] for i in range(n)]\ndone = [False for i in range(n)]\ndef dfs(visited,i,d):\n    visited[i]=True\n    done[i] = True\n    for j in d[i]:\n        if visited[j]:\n            return True\n        if not done[j]:\n            temp = dfs(visited,j,d)\n            if temp:return True\n    visited[i]=False\n    return False\nedgelist=[]\nfor i in range(m):\n    a,b=[int(i) for i in input().split(' ')]\n    edgelist.append([a,b])\n    d[a-1].append(b-1)\n\nans = 0\nvisited=[False for i in range(n)]\nfor i in range(n):\n    if dfs(visited,i,d):\n        ans = 1\n        break\nif ans:\n    print(2)\n    for i in edgelist:\n        if i[0]>i[1]:\n            print(2,end=' ')\n        else:print(1,end=' ')\nelse:\n    print(1)\n    print(' '.join('1' for i in range(m)))", "n, m = map(int, input().split())\n \nAE = []\nE = [[] for _ in range(n)]\ndi = [0]*n\ndo = [0]*n\nok = True\n \ndef DFS(u):\n    nonlocal ok\n    \n    di[u] = True\n    for v in E[u]:\n        if di[v]:\n            if not do[v]:\n                ok = False\n            continue\n        DFS(v)\n    do[u] = True\n \nfor _ in range(m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    \n    AE.append((u,v) )\n    E[u].append(v)\n \nfor i in range(n):\n    if not di[i]:\n        DFS(i)\n\nif ok:\n    print(1)\n    for _ in range(m):\n        print(1, end=' ')\nelse:\n    print(2)\n    for u,v in AE:\n        print(int(u < v) + 1, end=' ')", "n,m=map(int,input().split())\nL=[]\nfor i in range(n):\n    s=[]\n    L.append(s)\n\nst=[]\nfor i in range(m):\n    u,v=map(int,input().split())\n    st.append((u-1,v-1))\n    L[u-1].append(v-1)\n\nvisited=[False]*n\nrs=[False]*n\n\ndef dfs(u):\n    if(visited[u]==False):\n        visited[u]=True\n        rs[u]=True\n        for i in L[u]:\n            if(visited[i]==False and dfs(i)==True):\n                return True\n            elif(rs[i]==True):\n                return True\n\n    rs[u]=False\n    return False\n\n\nflag=0\nfor i in range(0,n):\n    if(dfs(i)==True):\n        flag=1\n        break\n\n\nif(flag==0):\n    print(1)\n    for i in range(m):\n        print(1,end=\" \")\n    print(\" \")\n\nelse:\n    print(2)\n    for i in range(0,len(st)):\n        if(st[i][0]<st[i][1]):\n            print(1,end=\" \")\n        else:\n            print(2,end=\" \")\n    print(\" \")\n    \n", "\nfrom collections import defaultdict\nans = defaultdict(lambda : 1)\nflag = 0\ndef dfs(i):\n\n    nonlocal flag\n    vis[i] = 1\n\n    for j in hash[i]:\n        if not vis[j]:\n            dfs(j)\n        else:\n            if vis[j] == 1:\n                flag = 1\n\n                ans[(i,j)] = 2\n\n\n    vis[i] = 2\n\n\n\nn,m = map(int,input().split())\n\nhash = defaultdict(list)\n\npar = [0]+[i+1 for i in range(n)]\n\n\n\nfor i in range(m):\n    a,b = map(int,input().split())\n\n    hash[a].append(b)\n\n    ans[(a,b)] = 1\n\nvis = [0]*(n+1)\n\nfor i in range(n):\n    if vis[i] == 0:\n        dfs(i)\nif flag:\n    print(2)\nelse:\n    print(1)\nfor i in ans:\n    print(ans[i],end = ' ')\n\n\n\n\n\n", "n,m=[int(x) for x in input().split()]\ndic={}\npaint={}\ncycle=False\nedges=[]\nfor i in range(m):\n    a,b=[int(x) for x in input().split()]\n    edges.append((a,b))\n    if a not in dic:\n        dic[a]=set([b])\n    else:\n        dic[a].add(b)\ninv=[False]*(n+1)\ninvite=[False]*(n+1)\ndef gcd(n):\n    paint[n]=0\n    invite[n]=True\n    if n in dic:\n        for item in dic[n]:\n            if not invite[item]:\n                if gcd(item):\n                    return True\n            else:\n                if paint[item]==0:\n                    return True\n    paint[n]=1\n    return False\nfor item in range(1,n+1):\n    if not invite[item]:\n        cycle=gcd(item) or cycle\narr=[]\nif cycle:\n    print(2)\n    for item in edges:\n        if item[0]<item[1]:\n            arr.append(1)\n        else:\n            arr.append(2)\nelse:\n    print(1)\n    for item in edges:\n        arr.append(1)\nprint(*arr)\n    \n", "import sys\nimport collections\nimport functools\n\nn,m  = list(map(int, input().strip().split()))\ngraph = collections.defaultdict(list)\nedges = []\nfor i in range(m):\n    u,v = list(map(int, input().strip().split()))\n    graph[u].append([v,i])\n    edges.append((u,v))\n\nans = [1]*m\nvisited = set()\n\ndef dfs(u, seen):\n    seen.add(u)\n    visited.add(u)\n    for v, i in graph[u]:\n        if v in seen:\n            ans[i] = 2\n        elif v not in visited:\n            ans[i] = 1\n            dfs(v, seen)\n    seen.remove(u)\n\nseen = set()\n\nfor u, v in edges:\n    if u in visited: continue\n    dfs(u, seen)\n\nprint(max(ans))\nprint(' '.join(str(i) for i in ans))\n", "import sys\nimport collections\nimport functools\n\nn,m  = list(map(int, input().strip().split()))\ngraph = collections.defaultdict(list)\nedges = []\nfor i in range(m):\n    u,v = list(map(int, input().strip().split()))\n    graph[u].append([v,i])\n    edges.append((u,v))\n\nans = [1]*m\nvisited = [False for _ in range(5000)]\nseen = [False for _ in range(5000)]\n\ndef dfs(u):\n    seen[u] = visited[u] = True\n    for v, i in graph[u]:\n        if seen[v]:\n            ans[i] = 2\n        elif not visited[v]:\n            ans[i] = 1\n            dfs(v)\n    seen[u] = False\n\nfor u, v in edges:\n    if visited[u]: continue\n    dfs(u)\n\nprint(max(ans))\nprint(' '.join(str(i) for i in ans))\n", "def iscyclic(s,visited,restack):\n    visited[s]=True\n    restack[s]=True\n    \n    if s in adj:\n        for u in adj[s]:\n            if visited[u]==False:\n                if iscyclic(u,visited,restack)==True:\n                    return True\n            elif restack[u]==True:\n                return True\n    restack[s]=False\n    return False\n    \ndef cyclic():\n    visited=[False]*(n+1)\n    restack=[False]*(n+1)\n    for u in adj:\n        if visited[u]==False:\n            if iscyclic(u,visited,restack)==True:\n                return True\n    return False\n    \nn,m=map(int,input().split())\nadj={}\nl=[]\nfor i in range(m):\n    a,b=map(int,input().split())\n    if a not in adj:\n        adj[a]=[b]\n    else:\n        adj[a].append(b)\n    l.append([a,b])\nvisited=[False]*(n+1)\nbo=cyclic()\nif bo==False:\n    print(1)\n    for i in range(m):\n        print(1,end=\" \")\nelse:\n    print(2)\n    for i in range(m):\n        if l[i][0]>l[i][1]:\n            print(2,end=\" \")\n        else:\n            print(1,end=\" \")", "import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[tuple(map(int,input().split())) for i in range(m)]\n\nE=[[] for i in range(n+1)]\n\n# Kahn\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\nEDGEIN=[0]*(n+1)# \u305d\u306e\u70b9\u306b\u5165\u308bEDGE\u306e\u500b\u6570\nEDGEOUTLIST=[[] for i in range(n+1)]# EDGE\u306e\u884c\u304d\u5148\nfor x,y in EDGE:\n    EDGEIN[y]+=1\n    EDGEOUTLIST[x].append(y)\n\nfrom collections import deque\nQUE = deque()\n\nfor i in range(1,n+1):\n    if EDGEIN[i]==0:\n        QUE.append(i)# \u884c\u304d\u5148\u306e\u306a\u3044\u70b9\u3092QUE\u306b\u5165\u308c\u308b\n\n\n\nTOP_SORT=[]\nwhile QUE:\n    x=QUE.pop()\n    TOP_SORT.append(x)# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u7b54\u3048\u306b\u5165\u308c\u308b\n    for to in EDGEOUTLIST[x]:\n        EDGEIN[to]-=1# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u524a\u9664\u3057,\u305d\u3053\u304b\u3089\u4e00\u6b69\u5148\u306e\u70b9\u306eEDGEIN\u3092\u4e00\u3064\u6e1b\u3089\u3059.\n        if EDGEIN[to]==0:\n            QUE.appendleft(to)\n\nif len(TOP_SORT)==n:\n    print(1)\n    print(*[1]*m)\n\nelse:\n    print(2)\n    for x,y in EDGE:\n        if x>y:\n            print(1,end=\" \")\n        else:\n            print(2,end=\" \")\n", "import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[tuple(map(int,input().split())) for i in range(m)]\n\nE=[[] for i in range(n+1)]\n\n# Kahn\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\nEDGEIN=[0]*(n+1)# \u305d\u306e\u70b9\u306b\u5165\u308bEDGE\u306e\u500b\u6570\nEDGEOUTLIST=[[] for i in range(n+1)]# EDGE\u306e\u884c\u304d\u5148\nfor x,y in EDGE:\n    EDGEIN[y]+=1\n    EDGEOUTLIST[x].append(y)\n\nfrom collections import deque\nQUE = deque()\n\nfor i in range(1,n+1):\n    if EDGEIN[i]==0:\n        QUE.append(i)# \u884c\u304d\u5148\u306e\u306a\u3044\u70b9\u3092QUE\u306b\u5165\u308c\u308b\n\n\n\nTOP_SORT=[]\nwhile QUE:\n    x=QUE.pop()\n    TOP_SORT.append(x)# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u7b54\u3048\u306b\u5165\u308c\u308b\n    for to in EDGEOUTLIST[x]:\n        EDGEIN[to]-=1# \u884c\u304d\u5148\u304c\u306a\u3044\u70b9\u3092\u524a\u9664\u3057,\u305d\u3053\u304b\u3089\u4e00\u6b69\u5148\u306e\u70b9\u306eEDGEIN\u3092\u4e00\u3064\u6e1b\u3089\u3059.\n        if EDGEIN[to]==0:\n            QUE.appendleft(to)\n\nif len(TOP_SORT)==n:\n    print(1)\n    print(*[1]*m)\n\nelse:\n    print(2)\n    for x,y in EDGE:\n        if x>y:\n            print(1,end=\" \")\n        else:\n            print(2,end=\" \")\n", "'''\n  Author: Ashraful Islam Fuad\n  University of Asia Pacific\n  Bsc in CSE\n  category:DFS (dificulty 2000)\n  problem :from codeforces \nsd\n'''\nfrom collections  import defaultdict\n\nans=defaultdict(lambda :1)\n\nflag=0\n\n\ndef dfs(node):\n\tnonlocal flag\n\tvisit[node]=1\n\n\n\tfor j in graph[node]:\n\t\tif not visit[j]:\n\t\t\tdfs(j)\n\n\t\telse:\n\t\t\tif visit[j]==1:\n\t\t\t\tflag=1\n\t\t\t\tans[(node,j)]=2\n\n\tvisit[node]=2\n\n\nn,m=map(int,input().split())\n\ngraph=defaultdict(list)\n\n\nparent=[0]+[i+1 for i in range(n)]\n\n\nfor i in range(m):\n\te1,e2=map(int,input().split())\n\tgraph[e1].append(e2)\n\n\tans[(e1,e2)]=1\n\n\nvisit=[0]*(n+1)\n\n\nfor i in range(n):\n\n\tif visit[i]==0:\n\t\tdfs(i)\n\n\n\n\nif flag:\n\tprint(2)\nelse:\n\tprint(1)\n\nfor i in ans:\n\t# print('i is {}'.format(i))  \n\tprint(ans[i],end=' ')\n\n\n", "n, m = list(map(int, input().split()))\nnumedge = {}\ngraph = {}\nfor v in range(1, n + 1):\n    graph[v] = set()\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    numedge[(a, b)] = i\n    graph[a].add(b)\nvisit = {}\npar = {}\ns, f = -1, -1\n\n\ndef dfs(v):\n    nonlocal s, f\n    visit[v] = 1\n    for u in graph[v]:\n        if u not in visit:\n            par[u] = v\n            dfs(u)\n        elif visit[u] == 1:\n            s = u\n            f = v\n            break\n    visit[v] = -1\n\n\nfor v in graph:\n    dfs(v)\nif s == f == -1:\n    print(1)\n    print('1 ' * m)\nelse:\n    print(2)\n    ans = [0] * m\n    for x in graph:\n        for y in graph[x]:\n            ans[numedge[(x, y)]] = (x > y) + 1\n    print(*ans)\n", "n, m = input().split(' ')\nn, m = int(n), int(m)\n\nch = [[] for i in range(n+1)]\n\nedges_by_order = []\n\nfor i in range(m):\n    x, y = input().split(' ')\n    x, y = int(x), int(y)\n    ch[x].append(y)\n    edges_by_order.append((x, y))\n\nfor i in range(n+1):\n    ch[i] = sorted(ch[i])\n\nst = [0 for i in range(n+1)]\nend = [0 for i in range(n+1)]\n\ntimestamp = 0\ncycle_exists = False\n\ndef dfs(x):\n    nonlocal ch, st, end, timestamp, cycle_exists\n    \n    timestamp += 1\n    st[x] = timestamp\n    \n    for y in ch[x]:\n        if st[y] == 0:\n            dfs(y)\n        else:\n            if st[y] < st[x] and end[y] == 0:\n                cycle_exists = True\n    \n    timestamp += 1\n    end[x] = timestamp\n\nfor i in range(1, n+1):\n    if st[i] == 0:\n        dfs(i)\n\nif not cycle_exists:\n    print(1)\n    for i in range(m):\n        print(1, end=' ')\n    print('', end='\\n')\nelse:\n    print(2)\n    for i in range(m):\n        x = st[edges_by_order[i][0]]\n        y = st[edges_by_order[i][1]]\n        \n        if x < y:\n            print(1, end=' ')\n        else:\n            print(2, end=' ')\n    print('', end='\\n')", "v_n, e_n = tuple(map(int, input().split()))\nG = [set() for _ in range(v_n)]\nedges = []\nd_s = [-1] * v_n\nok = False\ndef dfs(u):\n    nonlocal ok\n    if ok:\n        return\n    d_s[u] = 0\n    for v in G[u]:\n        if d_s[v] == -1:\n            dfs(v)\n        elif d_s[v] == 0:\n            ok = True\n    d_s[u] = 1\n\nfor _ in range(e_n):\n    u, v = tuple(map(int, input().split()))\n    u -= 1\n    v -= 1\n    edges.append((u, v))\n    G[u].add(v)\n\n\nfor u in range(v_n):\n    if d_s[u]==-1:\n        dfs(u)\n\n\nif not ok:\n    print(1)\n    for _ in range(e_n):\n        print(1, end=' ')\nelse:\n    print(2)\n    for (u, v) in edges:\n        print(int(u < v) + 1, end=' ')", "import sys\nsys.setrecursionlimit(10**9)\ndef dfs(a):\n    nonlocal adj,vis,st\n    j=0\n    vis[a]=1\n    for i in adj[a][:]:\n        if vis[i[0]]==0:\n            dfs(i[0])\n            adj[a][j][1]=1\n        elif vis[i[0]]==2:\n            adj[a][j][1]=1\n        else:\n            st=2\n            adj[a][j][1]=2\n        j+=1\n    vis[a]=2\n \nn,m=list(map(int,input().split()))\nit=[]\nadj=[[] for i in range(n)]\n#print(adj)\nfor _ in range(m):\n    a,b=list(map(int,input().split()))\n    adj[a-1].append([b-1,1,_])\n    #print(adj)\nvis=[0]*n\nst=1\nfor ii in range(n):\n    if vis[ii]==0:\n        dfs(ii)\nprint(st)\nans=[0]*m\nfor i in range(n):\n    for j in adj[i]:\n      #  print(j[2],j[1])\n        ans[j[2]]=j[1]\nprint(*ans)\n \n", "[N,M] = list(map(int,input().split()))\nedges = [[] for _ in range(N+1)]\nedge_in = []\n\nfor _ in range(M):\n    [u,v] = list(map(int,input().split()))\n    edge_in.append([u,v])\n    edges[u].append(v)\n\nseen = [False for _ in range(N+1)]\nvisited = [False for _ in range(N+1)]\n\ndef bfs(node):\n    visited[node] = True\n    seen[node] = True\n    for v in edges[node]:\n        if not seen[v] and visited[v]:\n            continue\n        if seen[v] or bfs(v):\n            return True\n    seen[node] = False\n    return False\n\nhasCycle = False\nfor i in range(1,N+1):\n    if visited[i]:\n        continue\n    if bfs(i):\n        hasCycle = True\n        break\n\nif not hasCycle:\n    print(1)\n    print(\" \".join([\"1\" for _ in range(M)]))\nelse:\n    print(2)\n    print(\" \".join([\"1\" if u < v else \"2\" for (u,v) in edge_in]))\n", "#!python3\n\nfrom collections import deque, Counter\nimport array\nfrom itertools import combinations, permutations\nfrom math import sqrt\nimport unittest\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_int_array():\n    return [int(i) for i in input().strip().split(' ')]\n\n######################################################\n\nvn, en = read_int_array()\nal = [[] for _ in range(vn)]  # adjacency list\ndef adj(v):\n    return al[v]\nitoe = [None for _ in range(en)]  # index to edge\nfor eid in range(en):  # eid - edge id\n    v, w = read_int_array()\n    v -= 1\n    w -= 1\n    al[v] += [w]\n    itoe[eid] = (v, w)\n\nmarked = set()\nstack = set()\netoc = {}  # edge to color\ndef dfs(v):  # vertex\n    if v in marked:\n        return\n    marked.add(v)\n    stack.add(v)\n    hasbackedge = False\n    for w in adj(v):\n        if w in stack:  # back edge\n            hasbackedge = True\n            etoc[(v, w)] = 2\n            continue\n        if w in marked:\n            continue\n        if dfs(w):\n            hasbackedge = True\n    stack.remove(v)\n    return hasbackedge\n\nhasbackedge = False\nfor v in range(vn):\n    if v not in marked:\n        if dfs(v):\n            hasbackedge = True\n\nprint(2 if hasbackedge else 1)\nfor ei in range(en):\n    v, w = itoe[ei]\n    c = etoc.get((v,w), 1)\n    print(c, end=' ')\n\n\n\n\n\n", "vis = []\nans = []\nnodes = []\n\n\ndef dfs(A):\n\tnonlocal vis, ans, nodes\n\tvis[A] = 1\n\tfor (B,index) in nodes[A]:\n\t\tif ans[index] != 0:\n\t\t\tcontinue\n\t\tif vis[B] == 1:\n\t\t\tans[index] = 2\n\t\telse:\n\t\t\tans[index] = 1\n\t\t\tdfs(B)\n\t\t\t\n\tvis[A] = 2\n\ndef main():\n\tnonlocal vis, ans, nodes\n\tn, m = map(int, input().strip().split())\n\tvis = [-1] * (n + 10)\n\tans = [0] * (m + 10)\n\tnodes = [[] for i in range(n + 10)]\n\tfor i in range(m):\n\t\ta, b = map(int, input().strip().split())\n\t\tnodes[a].append((b,i))\n\tfor i in range(1, n + 1):\n\t\tif vis[i] == -1:\n\t\t\tdfs(i)\n\tif 2 in ans:\n\t\tprint(2)\n\telse:\n\t\tprint(1)\n\tfor i in range(m):\n\t\tprint(ans[i])\n\ndef __starting_point():\n\tmain()\n__starting_point()", "# import random\n\n# arr1=[random.randint(1,100) for i in range(10)]\n# arr2=[random.randint(1,100) for i in range(10)]\n\n# print(arr1,\"\t\t\tSORTED:-\",sorted(arr1))\n# print(arr2,\"\t\t\tSORTED:-\",sorted(arr2))\n\n\n# def brute_inv(a1,a2):\n# \ta3=a1+a2\n# \tinv=0\n# \tfor i in range(len(a3)):\n# \t\tfor j in range(i+1,len(a3)):\n# \t\t\tif a3[i]>a3[j]:\n# \t\t\t\tinv+=1\n# \treturn inv\n\n# def smart_inv(arr1,arr2):\n# \ti1,i2=0,0\n# \tinv1=0;\n# \twhile i1<len(arr1) and i2<len(arr2):\n# \t\tif arr1[i1]>arr2[i2]:\n# \t\t\tinv1+=(len(arr1)-i1)\n# \t\t\ti2+=1\n# \t\telse:\n# \t\t\ti1+=1\n# \treturn inv1\n\n# print(arr1+arr2,smart_inv(sorted(arr1),sorted(arr2)))\n# print(brute_inv(arr1,arr2))\n# print(arr2+arr1,smart_inv(sorted(arr2),sorted(arr1)))\n# print(brute_inv(arr2,arr1))\n\n# if (smart_inv(sorted(arr1),sorted(arr2))<smart_inv(sorted(arr2),sorted(arr1)) and brute_inv(arr1,arr2)<brute_inv(arr2,arr1)) or (smart_inv(sorted(arr2),sorted(arr1))<smart_inv(sorted(arr1),sorted(arr2)) and brute_inv(arr2,arr1)<brute_inv(arr1,arr2)):\n# \tprint(\"True\")\n# else:\n# \tprint(\"False\")\n\n\n# print(brute_inv([1,2,10],[3,5,7]))\n# print(brute_inv([3,5,7],[1,2,10]))\n# print(brute_inv([1,7,10],[3,5,17]))\n# print(brute_inv([3,5,17],[1,7,10]))\n\n# 1\t\t:-\t1\n# 2\t\t:-\t10\n# 3\t\t:-\t011\n# 4\t\t:-\t0100\n# 5\t\t:-\t00101\n# 6\t\t:-\t000110\n# 7\t\t:-\t0000111\n# 8\t\t:-\t00001000\n# 9\t\t:-\t000001001\n# 10\t\t:-\t0000001010\n# 11\t\t:-\t00000001011\n# 12\t\t:-\t000000001100\n# 13\t\t:-\t0000000001101\n# 14\t\t:-\t00000000001110\n# 15\t\t:-\t000000000001111\n# 16\t\t:-\t0000000000010000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom sys import stdin,stdout\n\nn,m=stdin.readline().strip().split(' ')\nn,m=int(n),int(m)\nadj=[[] for i in range(n+1)]\n\nfor i in range(m):\n\tu,v=stdin.readline().strip().split(' ')\n\tu,v=int(u),int(v)\n\tadj[u].append((v,i))\n\nvisited=[0 for i in range(n+1)]\ncolor=['1' for i in range(m)]\nflag=1\ndef dfs(curr):\n\tnonlocal flag\n\tvisited[curr]=1\n\tfor i in adj[curr]:\n\t\tif visited[i[0]]==0:\n\t\t\tdfs(i[0])\n\t\telif visited[i[0]]==1:\n\t\t\tcolor[i[1]]='2'\n\t\t\tflag=2\n\tvisited[curr]=2\n\n\nfor n in range(1,n+1):\n\tif visited[n]==0:\n\t\tdfs(n)\n\nif flag==1:\n\tstdout.write(\"1\\n\");\n\tstdout.write(' '.join(color)+\"\\n\")\nelse:\n\tstdout.write(\"2\\n\")\n\tstdout.write(' '.join(color)+\"\\n\")\n", "n, m = [int(i) for i in input().split()]\ndata = []\nchil = []\nfor i in range(n+1):\n    chil.append(set())\nfor j in range(m):\n    data.append([int(i) for i in input().split()])\n    chil[data[-1][0]].add(data[-1][1])\n\n# done = set()\n# fnd = set()\n# cycle = False\n# def dfs(a):\n#     for c in chil[a]:\n#         print(a,c)\n#         if c in fnd:\n#             nonlocal cycle\n#             cycle = True\n#             return\n#         if c not in done:\n#             fnd.add(c)\n#             dfs(c)\n# for i in range(1, n+1):\n#     if i not in done:\n#         dfs(i)\n#         done |= fnd\n#         fnd = set()\n#         if cycle:\n#             break\n\ndef cycle():\n    for i in range(1, n+1):\n        stack = [i]\n        fnd = [0] * (n+1)\n        while stack:\n            s = stack.pop()\n            for c in chil[s]:\n                if c == i:\n                    return True\n                if not fnd[c]:\n                    stack.append(c)\n                    fnd[c] = 1\n\n\n\n\n\nif not cycle():\n    print(1)\n    l = ['1' for i in range(m)]\n    print(' '.join(l))\nelse:\n    print(2)\n    for d in data:\n        print([\"2\",\"1\"][d[0] < d[1]], end=' ')\n    print()\n"]
["a, b = list(map(int, input().split(' ')))\nc, d = list(map(int, input().split(' ')))\ne, f = list(map(int, input().split(' ')))\nx=[[a, b],[c,d],[e,f]]\nx.sort()\na, b, c, d, e, f = x[0][0], x[0][1], x[1][0], x[1][1], x[2][0], x[2][1]\nif (a==c==e or b==d==f):\n    print(1)\n    quit()\n\nif a == c:\n    if b<f<d:\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nif c == e:\n    if (d<b<f):\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nif b == d:\n    print(2)\n    quit()\n\nif d == f:\n    print(2)\n    quit()\n\nif b == f:\n    if a<c<e:\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nprint(3)\nquit()\n", "A = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nC = [int(x) for x in input().split()]\n\ndef out(value):\n    print(value)\n    return\n\nif A[0] == B[0] and B[0] == C[0]:\n    out(1)\n\nif A[1] == B[1] and B[1] == C[1]:\n    out(1)\n\nimport itertools\n\nX = A\nY = B\nZ = C\nfor p in itertools.permutations([X, Y, Z]):\n    A = p[0]\n    B = p[1]\n    C = p[2]\n    if A[0] == B[0] and (C[1] <= min(A[1], B[1]) or C[1] >= max(A[1], B[1])):\n        out(2)\n    if A[1] == B[1] and (C[0] <= min(A[0], B[0]) or C[0] >= max(A[0], B[0])):\n        out(2)\n\nout(3)\n", "ax, ay = list(map(int, input().split()))\nbx, by = list(map(int, input().split()))\ncx, cy = list(map(int, input().split()))\nif (ax == bx == cx)or(ay == by == cy):\n    ans = 1\nelif (ax == bx)and((cy <= min(ay, by))or(cy >= max(ay, by))):\n    ans = 2\nelif (ax == cx)and((by <= min(ay, cy))or(by >= max(ay, cy))):\n    ans = 2\nelif (cx == bx)and((ay <= min(cy, by))or(ay >= max(cy, by))):\n    ans = 2\nelif (ay == by)and((cx <= min(ax, bx))or(cx >= max(ax, bx))):\n    ans = 2\nelif (ay == cy)and((bx <= min(ax, cx))or(bx >= max(ax, cx))):\n    ans = 2\nelif (cy == by)and((ax <= min(cx, bx))or(ax >= max(cx, bx))):\n    ans = 2\nelse:\n    ans = 3\nprint(ans)\n", "read = lambda: list(map(int, input().split()))\nx1, y1 = read()\nx2, y2 = read()\nx3, y3 = read()\nans = 3\nf1 = y1 == y2 and ((x3 >= x2 and x3 >= x1) or (x3 <= x2 and x3 <= x1))\nf2 = y2 == y3 and ((x1 >= x2 and x1 >= x3) or (x1 <= x2 and x1 <= x3))\nf3 = y1 == y3 and ((x2 >= x3 and x2 >= x1) or (x2 <= x1 and x2 <= x3))\nf4 = x1 == x2 and ((y3 >= y2 and y3 >= y1) or (y3 <= y2 and y3 <= y1))\nf5 = x2 == x3 and ((y1 >= y2 and y1 >= y3) or (y1 <= y2 and y1 <= y3))\nf6 = x1 == x3 and ((y2 >= y3 and y2 >= y1) or (y2 <= y1 and y2 <= y3))\nif f1 or f2 or f3 or f4 or f5 or f6: ans = 2\nif x1 == x2 == x3 or y1 == y2 == y3: ans = 1\nprint(ans)\n", "#!/usr/bin/env python3\n\nx1, y1 = input().split()\nx2, y2 = input().split()\nx3, y3 = input().split()\nx1, y1, x2, y2, x3, y3 = int(x1), int(y1), int(x2), int(y2), int(x3), int(y3)\n\ndef ans(p1, p2, p3):\n\tx1, y1 = p1\n\tx2, y2 = p2\n\tx3, y3 = p3\n\t# x,x    x\n\t# x  x   x\n\tif (x1 == x2 == x3): return 1\n\n\t#  x  x\n\t#  x\n\tif (x1, y1) == (x2, y3): \n\t\treturn 2\n\n\tif y1 == y2:\n\t\tif x1 < x3 < x2: \n\t\t\t# x   x\n\t\t\t#   x  \n\t\t\treturn 3\n\t\tif x2 < x3 < x1:\n\t\t\treturn 3\n\t\telse:\n\t\t\t# \t  x x\n\t\t\t# x\n\t\t\treturn 2\n\n\treturn 3\n\np1 = (x1, y1)\np2 = (x2, y2)\np3 = (x3, y3)\n\nt1 = (y1, x1)\nt2 = (y2, x2)\nt3 = (y3, x3)\nprint(min(\n\tans(p1, p2, p3),\n\tans(p1, p3, p2),\n\tans(p2, p1, p3),\n\tans(p2, p3, p1),\n\tans(p3, p1, p2),\n\tans(p3, p2, p1),\n\tans(t1, t2, t3),\n\tans(t1, t3, t2),\n\tans(t2, t1, t3),\n\tans(t2, t3, t1),\n\tans(t3, t1, t2),\n\tans(t3, t2, t1)\n))", "p = [0]*3\nq = [0]*3\n\nsum = 0\n\na1,b1 = list(map(int, input().split()))\na2,b2 = list(map(int, input().split()))\nif a1 == a2:\n    p[0] = 1\nif b1 == b2:\n    q[0] = 1\na3,b3 = list(map(int, input().split()))    \nif a1 == a3:\n    p[1] = 1\nif b1 == b3:\n    q[1] = 1\nif a2 == a3:\n    p[2] = 1\nif b2 == b3:\n    q[2] = 1\n\nsum = 0\nfor i in range(3):\n    sum += p[i] + q[i]\n\nif sum == 0:\n    print(3)\nelif sum == 3:\n    print(1)\nelif sum == 2:\n    print(2)\nelse:\n    if q[1] + q[2] + q[0] == 1:\n        b1 = a1\n        b2 = a2\n        b3 = a3\n        p[0] = q[0]\n        p[1] = q[1]\n        p[2] = q[2]\n\n    if p[0] == 1 and (b3 > max(b1,b2) or b3 < min(b1,b2)):\n        print(2)\n    elif p[1] == 1 and (b2 > max(b1,b3) or b2 < min(b1,b3)):\n        print(2)\n    elif p[2] == 1 and (b1 > max(b2,b3) or b1 < min(b2,b3)):\n        print(2)\n    else:\n        print(3)\n        \n            \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                \n", "read = lambda: list(map(int, input().split()))\n\ndef test(a, b, c):\n\tif a > b:\n\t\ta, b = b, a\n\tif not (a <= c <= b):\n\t\treturn -1\n\treturn 1 if c == a or c == b else 0\n\ndef main():\n\ta = [tuple(read()) for _ in range(3)]\n\tif a[0][0] == a[1][0] == a[2][0] or a[0][1] == a[1][1] == a[2][1]:\n\t\treturn 1\n\tfor i in range(3):\n\t\tfor j in range(i + 1, 3):\n\t\t\tif a[i][0] != a[j][0] and a[i][1] != a[j][1]:\n\t\t\t\tk = 3 ^ i ^ j\n\t\t\t\tx = test(a[i][0], a[j][0], a[k][0])\n\t\t\t\ty = test(a[i][1], a[j][1], a[k][1])\n\t\t\t\tif min(x, y) >= 0 and max(x, y) == 1:\n\t\t\t\t\treturn 2\n\treturn 3\n\nprint(main())\n", "x = [0 for i in range(3)]\ny = [0 for i in range(3)]\nmark = [False, False, False]\nmark1 = [False, False, False]\nfor i in range(3):\n    x[i], y[i] = list(map(int, input().split()))\n\nxp = []\nyp = []\nfor i in range(3):\n    for j in range(i + 1, 3):\n        if x[i] == x[j]:\n            xp.append([i, j])\n            mark[i] = True\n            mark[j] = True\n        if y[j] == y[i]:\n            yp.append([i, j])\n            mark1[i] = True\n            mark1[j] = True            \nif len(xp) == 3 or len(yp) == 3:\n    print(1)\nelif len(xp) == 1:\n    if not mark[0]:\n        if y[0] >= max(y[1], y[2]) or y[0] <= min(y[1], y[2]):\n            print(2)\n        else:\n            print(3)\n    elif not mark[1]:\n        if y[1] >= max(y[0], y[2]) or y[1] <= min(y[0], y[2]):\n            print(2)\n        else:\n            print(3)\n    if not mark[2]:\n        if y[2] >= max(y[1], y[0]) or y[2] <= min(y[1], y[0]):\n            print(2)\n        else:\n            print(3)    \n        \nelif len(yp) == 1:\n    if not mark1[0]:\n        if x[0] >= max(x[1], x[2]) or x[0] <= min(x[1], x[2]):\n            print(2)\n        else:\n            print(3)\n    elif not mark1[1]:\n        if x[1] >= max(x[0], x[2]) or x[1] <= min(x[0], x[2]):\n            print(2)\n        else:\n            print(3)\n    if not mark1[2]:\n        if x[2] >= max(x[1], x[0]) or x[2] <= min(x[1], x[0]):\n            print(2)\n        else:\n            print(3)    \nelse:\n    print(3)\n", "\nxs , ys = input().split(\" \")\nx1 = int(xs)\ny1 = int(ys)\n\nxs , ys = input().split(\" \")\nx2 = int(xs)\ny2 = int(ys)\n\nxs , ys = input().split(\" \")\nx3 = int(xs)\ny3 = int(ys)\n\n\ndef check ( a , b , c ) :\n  if a < b and b < c :\n    return 3\n  if c < b and b < a :\n    return 3\n  return 2\n\nif x1 == x2 == x3 or y1 == y2 == y3 :\n  print ( 1 )\n  return  \n\nif x2 == x3 :\n  print ( check ( y2 , y1 , y3 ) )\n  return\nif x1 == x3 :\n  print ( check ( y1 , y2 , y3 ) )\n  return\nif x1 == x2 :\n  print ( check ( y1 , y3 , y2 ) )\n  return\n\nif y2 == y3 :\n  print ( check ( x2 , x1 , x3 ) )\n  return\nif y1 == y3 :\n  print ( check ( x1 , x2 , x3 ) )\n  return\nif y1 == y2 :\n  print ( check ( x1 , x3 , x2 ) )\n  return\n\n\n  \nprint ( 3 ) ", "#!/usr/bin/env python3\nimport operator\nfrom itertools import islice\nimport math\n\n\ndef all_on_same_line(points):\n    return all(x == points[0][0] for x, y in points) or all(y == points[0][1] for x, y in points)\n\n\ndef all_on_different_lines(points):\n    return len(set(x for x, y in points)) == len(points) and len(set(y for x, y in points)) == len(points)\n\n\ndef has_two_points_with_same_x_coord(points):\n    return len(set(x for x, y in points)) == 2\n\n\ndef get_common_x(points):\n    xs = [x for x, y in points]\n    for xx in set(x for x, y in points):\n        if xs.count(xx) == 2:\n            return xx\n\ndef get_common_y(points):\n    ys = [y for x, y in points]\n    for yy in set(y for x, y in points):\n        if ys.count(yy) == 2:\n            return yy\n\n\ndef main():\n    points = [(int(x), int(y)) for x, y in (input().split() for _ in range(3))]\n    if all_on_same_line(points):\n        print(1)\n    elif all_on_different_lines(points):\n        print(3)\n    else:\n        if has_two_points_with_same_x_coord(points):\n            y = get_common_x(points)\n            points = sorted(points, key=lambda p: p[0] == y)\n            if min(points[1][1], points[2][1]) < points[0][1] <  max(points[1][1], points[2][1]):\n                print(3)\n            else:\n                print(2)\n        else:\n            y = get_common_y(points)\n            points = sorted(points, key=lambda p: p[1] == y)\n            if min(points[1][0], points[2][0]) < points[0][0] <  max(points[1][0], points[2][0]):\n                print(3)\n            else:\n                print(2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nif (a[0] == b[0] and b[0] == c[0]) or (a[1] == b[1] and b[1] == c[1]):\n    print(1)\n    return\n\nif (a[0] == b[0] and ((c[1] >= a[1] and c[1] >= b[1]) or (c[1] <= a[1] and c[1] <= b[1]))) or \\\n   (a[0] == c[0] and ((b[1] >= a[1] and b[1] >= c[1]) or (b[1] <= a[1] and b[1] <= c[1]))) or \\\n   (c[0] == b[0] and ((a[1] >= c[1] and a[1] >= b[1]) or (a[1] <= b[1] and a[1] <= c[1]))) or \\\n   (a[1] == b[1] and ((c[0] >= a[0] and c[0] >= b[0]) or (c[0] <= a[0] and c[0] <= b[0]))) or \\\n   (a[1] == c[1] and ((b[0] >= a[0] and b[0] >= c[0]) or (b[0] <= a[0] and b[0] <= c[0]))) or \\\n   (b[1] == c[1] and ((a[0] >= c[0] and a[0] >= b[0]) or (a[0] <= b[0] and a[0] <= c[0]))):\n    print(2)\n    return\n\nprint(3)", "ps = [tuple(int(x) for x in input().split()) for _ in range(3)]\nps.sort()\nxa, ya = ps[0]\nxb, yb = ps[1]\nxc, yc = ps[2]\nif xa == xb:\n    if xc == xa:\n        print(1)\n    elif yc <= ya or yb <= yc:\n            print(2)\n    else:\n        print(3)\nelif ya == yb:\n    if yc == ya:\n        print(1)\n    else:\n        print(2)\nelif ya < yb:\n    if xb == xc or yb == yc:\n        print(2)\n    else:\n        print(3)\nelse:\n    if yb == yc or (xb == xc and yc <= ya):\n        print(2)\n    else:\n        print(3)\n", "x1,y1 = map(int,input().split())\nx2,y2 = map(int,input().split())\nx3,y3 = map(int,input().split())\ndef det(x0,y0,x1,y1):\n    return x0*y1\n\n\nif x1==x2==x3 or y1==y2==y3:\n    print(1)\n    quit()\nelif       (y1==y2 and ((x3<=x1 and x3<=x2) or (x3>=x1 and x3>=x2)))\\\n        or (y1==y3 and ((x2<=x1 and x2<=x3) or (x2>=x1 and x2>=x3)))\\\n        or (y2==y3 and ((x1<=x2 and x1<=x3) or (x1>=x2 and x1>=x3)))\\\n        or (x1==x2 and ((y3<=y1 and y3<=y2) or (y3>=y1 and y3>=y2)))\\\n        or (x1==x3 and ((y2<=y1 and y2<=y3) or (y2>=y1 and y2>=y3)))\\\n        or (x2==x3 and ((y1<=x2 and y1<=y3) or (y1>=y2 and y1>=y3))):\n    print(2)\n    quit()\n\nelse:\n    print(3)", "p = [tuple(map(int, input().split())) for i in range(3)]\nif p[0][0] == p[1][0] and p[1][0] == p[2][0] or p[0][1] == p[1][1] and p[1][1] == p[2][1]:\n     print(1)\n     return\np.sort()\nif p[0][0] == p[1][0]:\n     print(3 if p[2][1] in range(min(p[0][1], p[1][1]) + 1, max(p[0][1], p[1][1])) else 2)\n     return\nif p[1][0] == p[2][0]:\n     print(3 if p[0][1] in range(min(p[1][1], p[2][1]) + 1, max(p[1][1], p[2][1])) else 2)\n     return\np = sorted((y, x) for (x, y) in p)\nif p[0][0] == p[1][0]:\n     print(3 if p[2][1] in range(min(p[0][1], p[1][1]) + 1, max(p[0][1], p[1][1])) else 2)\n     return\nif p[1][0] == p[2][0]:\n     print(3 if p[0][1] in range(min(p[1][1], p[2][1]) + 1, max(p[1][1], p[2][1])) else 2)\n     return\nprint(3)", "points = [tuple(int(x) for x in input().split()) for _ in range(3)]\npoints.sort()\np1, p2, p3 = points\n\nif (p1[0] == p2[0] and p2[0] == p3[0]) or (p1[1] == p2[1] and p2[1] == p3[1]):\n    print(1)\nelif p1[0] == p2[0]:\n    if min(p1[1], p2[1]) < p3[1] < max(p1[1], p2[1]):\n        print(3)\n    else:\n        print(2)\nelif p2[0] == p3[0]:\n    if min(p2[1], p3[1]) < p1[1] < max(p2[1], p3[1]):\n        print(3)\n    else:\n        print(2)\nelse:\n    points.sort(key=lambda p: p[1])\n    if p1[1] == p2[1]:\n        if min(p1[0], p2[0]) < p3[0] < max(p1[0], p2[0]):\n            print(3)\n        else:\n            print(2)\n    elif p2[1] == p3[1]:\n        if min(p2[0], p3[0]) < p1[0] < max(p1[0], p2[0]):\n            print(3)\n        else:\n            print(2)\n    else:\n        print(3)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\nx = []\ny = []\n\nfor i in range(3):\n    (a, b)   = (int(i) for i in input().split())\n    x.append(a)\n    y.append(b)\n\nif len(set(x)) == 2:\n    (x, y) = (y, x)\n\na = [ [x[i], y[i]] for i in range(3) ]\na = sorted(a)\n\nstart = time.time()\n\nif (a[0][0] == a[1][0] and a[1][0] == a[2][0]) or (a[0][1] == a[1][1] and a[1][1] == a[2][1]):\n    print(1)\nelif a[0][0] == a[1][0] or a[1][0] == a[2][0] or a[0][1] == a[1][1] or a[1][1] == a[2][1] :\n    print(2)\nelse:\n    print(3)\n\nfinish = time.time()\n#print(finish - start)\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\ndef calc(x1, y1, x2, y2, x3, y3):\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n\n    if x2 == x3 or y2 == y3:\n        x1, x3 = x3, x1\n        y1, y3 = y3, y1\n    if x1 == x3 or y1 == y3:\n        x2, x3 = x3, x2\n        y2, y3 = y3, y2\n\n    if x1 == x2:\n        if y1 < y3 < y2 or y2 < y3 < y1:\n            return 3\n        else:\n            return 2\n\n    if y1 == y2:\n        if x1 < x3 < x2 or x2 < x3 < x1:\n            return 3\n        else:\n            return 2\n\n    return 3    \n\nx1, y1 = [int(i) for i in input().split()]\nx2, y2 = [int(i) for i in input().split()]\nx3, y3 = [int(i) for i in input().split()]\n\nprint(calc(x1, y1, x2, y2, x3, y3))\n", "import math\nonsegment = lambda x, y, z: min(y,z) <= x <= max(y,z)\noninterval = lambda x, y, z: min(y,z) < x < max(y,z)\ndef inrectangle(p0, p1, p2):\n    return oninterval(p0[0], p1[0], p2[0]) and oninterval(p0[1], p1[1], p2[1])\ndef onborder(p0, p1, p2):\n    return onsegment(p0[0], p1[0], p2[0]) and onsegment(p0[1], p1[1], p2[1]) and not inrectangle(p0, p1, p2)\npoints = []\nfor i in range(3):\n    points.append(tuple(int(x) for x in input().split()))\npoints.sort()\nif (all((point[0] == points[0][0] for point in points)) or\n    all((point[1] == points[0][1] for point in points))):\n    print(1)\nelif points[0][1] == points[2][1]:\n    print(3 if points[0][0] < points[1][0] < points[2][0] else 2)\nelif onborder(points[1], points[0], points[2]) or onborder(points[2], points[0], points[1]) or onborder(points[0], points[1], points[2]):\n    print(2)\nelse:\n    print(3)\n", "x1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nx3, y3 = list(map(int, input().split()))\nxs = [x1, x2, x3]\nys = [y1, y2, y3]\nycount = 1\nxcount = 1\nfor i in range(3):\n\txcount = max(xcount, xs.count(xs[i]))\n\tycount = max(ycount, ys.count(ys[i]))\nret = 3\nif xcount == 3 or ycount == 3:\n\tprint(1)\nelif xcount == 2 or ycount == 2:\n\tif xcount == 2:\n\t\tfor i in range(2):\n\t\t\tfor j in range(i+1, 3):\n\t\t\t\tif xs[i] == xs[j]:\n\t\t\t\t\ta = i\n\t\t\t\t\tb = j\n\t\tfor i in range(3):\n\t\t\tif i != a and i != b:\n\t\t\t\tc = i\n\t\tif ys[a] < ys[c] < ys[b] or ys[a] > ys[c] > ys[b]:\n\t\t\tret = 3\n\t\telse:\n\t\t\tret = 2\n\tif ycount == 2:\n\t\tfor i in range(2):\n\t\t\tfor j in range(i+1, 3):\n\t\t\t\tif ys[i] == ys[j]:\n\t\t\t\t\ta = i\n\t\t\t\t\tb = j\n\t\tfor i in range(3):\n\t\t\tif i != a and i != b:\n\t\t\t\tc = i\n\t\tif xs[a] < xs[c] < xs[b] or xs[a] > xs[c] > xs[b]:\n\t\t\tret = min(ret, 3)\n\t\telse:\n\t\t\tret = min(ret, 2)\n\tprint(ret)\nelse:\n\tprint(ret)\n\n", "x = [0, 0, 0]\ny = [0, 0, 0]\n\ndef bet(a, b, c):\n    return a <= c <= b or b <= c <= a\n\ndef f(i, j, k):\n    return (x[k] == x[i] or x[k] == x[j]) and bet(y[i], y[j], y[k]) or (y[k] == y[i] or y[k] == y[j]) and bet(x[i], x[j], x[k])\n\nfor i in range(3):\n    xi, yi = list(map(int, input().split()))\n    x[i] = xi\n    y[i] = yi\n\nif (x[0] == x[1] == x[2] or y[0] == y[1] == y[2]):\n    print(1)\nelif f(0, 1, 2) or f(0, 2, 1) or f(1, 2, 0):\n    print(2)\nelse:\n    print(3)\n", "def is_parallel(p1, p2):\n    if p1[0] == p2[0]:\n        return 1\n    if p1[1] == p2[1]:\n        return 2\n    return 0\n\na = [list(map(int, input().split())) for _ in range(3)]\n\nall_the_same = is_parallel(a[0], a[1]) == is_parallel(a[1], a[2]) == is_parallel(a[0], a[2])\nfirst_and_second = is_parallel(a[0], a[1])\nif all_the_same:\n    if first_and_second != 0:\n        print(1)\n        return\n    else:\n        print(3)\nelse:\n    new_points = []\n\n    for i in range(3):\n        if is_parallel(a[i], a[(i+1) % 3]):\n            for j in range(3):\n                new_points.append(a[(i + j) % 3])\n            break\n\n    if len(new_points) == 0:\n        print(3)\n        return\n\n    if is_parallel(*new_points[:2]) == 2:\n        for i in range(3):\n            new_points[i][0], new_points[i][1] = new_points[i][1], new_points[i][0]\n\n    if new_points[0][1] > new_points[1][1]:\n        new_points[0], new_points[1] = new_points[1], new_points[0]\n\n    if new_points[2][1] <= new_points[0][1] <= new_points[1][1]:\n        print(2)\n    elif new_points[0][1] <= new_points[1][1] <= new_points[2][1]:\n        print(2)\n    else:\n        print(3)", "#!/usr/bin/env python3\n\nfrom collections import namedtuple\nfrom itertools   import permutations\n\nPoint = namedtuple(\"Point\", \"x y\")\n\ntry:\n    while True:\n        p = [Point(*list(map(int, input().split()))) for i in range(3)]\n        a, b, c = p\n        if a.x == b.x == c.x or a.y == b.y == c.y:\n            print(1)\n        else:\n            for a, b, c in permutations(p):\n                if a.x == b.x and not a.y < c.y < b.y and not b.y < c.y < a.y:\n                    print(2)\n                    break\n                if a.y == b.y and not a.x < c.x < b.x and not b.x < c.x < a.x:\n                    print(2)\n                    break\n            else:\n                print(3)\n\nexcept EOFError:\n    pass\n", "x1,y1 = map(int,input().split())\nx2,y2 = map(int,input().split())\nx3,y3 = map(int,input().split())\nif x1==x2==x3 or y1==y2==y3:\n    print(1)\n    quit()\nelif  (y1==y2 and ((x3<=x1 and x3<=x2) or (x3>=x1 and x3>=x2)))\\\n        or (y1==y3 and ((x2<=x1 and x2<=x3) or (x2>=x1 and x2>=x3)))\\\n        or (y2==y3 and ((x1<=x2 and x1<=x3) or (x1>=x2 and x1>=x3)))\\\n        or (x1==x2 and ((y3<=y1 and y3<=y2) or (y3>=y1 and y3>=y2)))\\\n        or (x1==x3 and ((y2<=y1 and y2<=y3) or (y2>=y1 and y2>=y3)))\\\n        or (x2==x3 and ((y1<=x2 and y1<=y3) or (y1>=y2 and y1>=y3))):\n    print(2)\n    quit()\nelse:print(3)", "x = [0] * 3\ny = [0] * 3\nfor i in range(3):\n    x[i], y[i] = map(int,input().split())\n\nif x[0] == x[1] == x[2] or y[0] == y[1] == y[2]:\n    print(1)\nelif x[0] == x[1] and (y[2]>=max(y[0],y[1]) or y[2]<=min(y[0],y[1])): print(2)\nelif x[0] == x[2] and (y[1]>=max(y[0],y[2]) or y[1]<=min(y[0],y[2])): print(2)\nelif x[1] == x[2] and (y[0]>=max(y[1],y[2]) or y[0]<=min(y[1],y[2])): print(2)\nelif y[0] == y[1] and (x[2]>=max(x[0],x[1]) or x[2]<=min(x[0],x[1])): print(2)\nelif y[0] == y[2] and (x[1]>=max(x[0],x[2]) or x[1]<=min(x[0],x[2])): print(2)\nelif y[1] == y[2] and (x[0]>=max(x[1],x[2]) or x[0]<=min(x[1],x[2])): print(2)\n\nelse: print(3)", "p1 = list(map(int, input().split()))\np2 = list(map(int, input().split()))\np3 = list(map(int, input().split()))\np = [p1, p2, p3]\nif (p1[0]==p2[0] and p2[0]==p3[0]) or (p1[1]==p2[1] and p2[1]==p3[1]):\n\tprint(1)\nelse:\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tfor k in range(3):\n\t\t\t\tif (i != j) and (j!=k) and(i!=k):\n\t\t\t\t\t#print(i,j,k)\n\t\t\t\t\tfor z in range(2):\n\t\t\t\t\t\tz2 = 1-z\n\t\t\t\t\t\tif (p[i][z] == p[j][z]) and not(min(p[i][z2],p[j][z2]) < p[k][z2] < max(p[i][z2],p[j][z2])):\n\t\t\t\t\t\t\tprint(2)\n\t\t\t\t\t\t\treturn\n\tprint(3)\n"]
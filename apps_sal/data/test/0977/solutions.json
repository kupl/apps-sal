["import sys\nfrom bisect import bisect_right as br\ninput = sys.stdin.readline\nn, p = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ntable = [0] * (10 ** 5 + 1)\nfor x in range(10 ** 5 + 1):\n  r = br(a, x)\n  table[x] = r\nres = []\n#print(table[: 100])\nfor x in range(1, 2001):\n  t = 1\n  q = x + 0\n  for i in range(n):\n    t *= max(0, table[q] - i)\n    t %= p\n    q += 1\n  if t % p: res.append(x)\nprint(len(res))\nprint(*res)", "n,p = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\nans = 0\nansls = []\nmx = max(a)\nfor i in range(1,mx+1):\n  anstmp = 1\n  for j in range(n)[::-1]:\n    if a[j]-j > i:\n      anstmp = 0\n    else:\n      anstmp *= n-max(i,a[j])+i-(n-j-1)\n      anstmp %= p\n  if anstmp:\n    ans += 1\n    ansls.append(i)\nprint(ans)\nprint(*ansls)", "import bisect\n\nn,p=list(map(int,input().split()))\na=list(map(int,input().split()))\na.sort()\nans=[]\nfor x in range(0,2001):\n    temp=[i+x for i in range(n)]\n    for j in range(n-1,-1,-1):\n        id=bisect.bisect_left(temp,a[j])\n        num=1+j-id\n        if num%p==0 or num<=0:\n            break\n    else:\n        ans.append(x)\n\nans.sort()\nprint(len(ans))\nprint(*ans)\n", "import sys\ninput = sys.stdin.readline\nn,p=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nmn=0\nmx=2000\nfor i in range(n):\n    d=a[i]-i\n    mn=max(d,mn)\n    if i>=p-1:\n        d2=a[i]-i+p-1\n        mx=min(mx,d2)\nprint(max(mx-mn,0))\nfor i in range(mn,mx):\n    print(i,end=\" \")", "import sys\ninput=lambda: sys.stdin.readline().rstrip()\nn,p=list(map(int,input().split()))\nA=sorted([int(i) for i in input().split()])\nst=A[0]\ngl=2001\nAns=[]\nfor i in range(st,gl):\n  for j,a in enumerate(A):\n    if i+j<a or min(j+1,i+j-a+1)>=p:\n      break\n  else:\n    Ans.append(i)\nprint(len(Ans))\nprint(*Ans)\n    \n", "def smallest_winner(matrix):\n    starting_x = 1\n    x = 1\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\n\ndef biggest_winner(matrix, p):\n    maxi = matrix[-1]\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        temp = matrix[i + p - 1] - i\n        maxi = min(maxi, temp)\n    return maxi\n\n\ndef check_multiple(matrix):\n    count = 0\n    maxi = 0\n    for i in range(1, len(matrix)):\n        if matrix[i] == matrix[i - 1]:\n            count += 1\n        else:\n            count = 1\n        maxi = max(maxi, count)\n    return maxi\n\n\ndef solve(n, p, matrix):\n    matrix = sorted(matrix)\n    min_x = smallest_winner(matrix)\n    max_x = biggest_winner(matrix, p) - 1\n    return [i for i in range(min_x, max_x + 1)]\n\n\n# T = int(input())\n# for _ in range(T):\nn, p = list(map(int, input().split()))\nmatrix = list(map(int, input().split()))\nres = solve(n, p, matrix)\nprint(len(res))\nprint(\" \".join(map(str, res)))\n", "n, p = map(int, input().split())\na = list(map(int, input().split()))\ndef calc(x):\n    nonlocal n, p, a\n    o = [0] * (n + 1)\n    for i in a:\n        o[max(0, min(n, i - x))] += 1\n    s = 0\n    ans = 1\n    for i in range(n):\n        s += o[i]\n        if s <= 0:\n            return 0\n        ans = ans * s % p\n        s -= 1\n    return ans\nans = []\nfor x in range(4020):\n    if calc(x):\n        ans.append(x)\nprint(len(ans))\nprint(*ans)", "n,p=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nans=[]\nfor x in range(1,2001):\n  fail=0\n  pointer=0\n  for i in range(n):\n    while pointer<n-1 and x+i-a[pointer+1]>=0:\n      pointer+=1\n    if (pointer+1-i)%p==0:\n      fail=1\n      break\n    if x+i-a[pointer]<0:\n      fail=1\n      break\n  if fail==0:\n    ans.append(str(x))\nprint(len(ans))\nprint(' '.join(ans))", "n, p = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nnum = [0]*(5001)\nfor i in a:\n    num[i] += 1\n\nfor i in range(5000):\n    num[i+1] += num[i]\n\nans = []\n\nfor x in range(1, 2001):\n\n    temp = 1\n    candy = x\n    for i in range(x, x+n):\n        temp *= num[candy]-(i-x)\n        temp %= p\n        candy += 1\n\n    if temp % p != 0:\n        ans.append(x)\n\nprint(len(ans))\nprint(*ans)\n", "from sys import stdin\ninput = stdin.readline\nn, p = list(map(int,input().split()))\nc = list(map(int,input().split()))\ndobre = []\n#na ktorym miejscu co najmniej musimy ustawic\nfor x in range(1,2001):\n    dobry = True\n    miejsca = []\n    for i in range(n):\n        eps = max(c[i] - x , 0)\n        cyk = max(n - eps, 0)\n        miejsca.append(cyk)\n    if min(miejsca) == 0:\n        continue\n    conajmniej = [0] * (n+1)\n    zajete = [0] * (n+1)\n    for i in miejsca:\n        zajete[n-i] += 1\n    sumapref = 0\n    for i in range(n+1):\n        j = n - i\n        sumapref += zajete[i]\n        conajmniej[j] = sumapref\n    for i in range(n):\n        j = n - i\n        if conajmniej[j] - i >= p or conajmniej[j] - i <= 0:\n            dobry = False\n            break\n    if dobry:\n        dobre.append(x)\nprint(len(dobre))\nprint(*dobre)\n", "import bisect\ndef f(x):\n    for i in range(n):\n        z=bisect.bisect_right(li,x+i)\n        if((z-i)%p==0):\n            return 0\n    return 1\nl=input().split()\nn=int(l[0])\np=int(l[1])\nl=input().split()\nli=[int(i) for i in l]\nl=[]\nli.sort()\nfor i in range(2001):\n    if(f(i)):\n        l.append(i)\nprint(len(l))\nfor i in l:\n    print(i,end=\" \")", "def solve(n, p, x, a):\n    res_ptn = 1\n    r = 0\n    for l in range(n):\n        while r < n and a[r] <= x + l:\n            r += 1\n        res_ptn *= r - l\n        res_ptn %= p\n    return res_ptn != 0\n    \n\nn, p = map(int, input().split())\na = list(map(int, input().split()))\n\n\na = sorted(a)\nans = []\nfor x in range(1, 2000 + 2):\n    if solve(n, p, x, a):\n        ans.append(x)\n\nprint(len(ans))\nprint(*ans)", "def fa(a, x, p):\n    k = x\n    wr = 0\n    for i in range(len(a)):\n        if a[i] <= k:\n            wr += 1\n        else:\n            nk = wr // p * p\n            wr -= a[i] - k\n            if wr < nk:\n                return False\n            k = a[i]\n            if wr < 0:\n                return False\n            wr += 1\n    if wr >= p:\n        return False\n    else:\n        return True\ndef solve():\n    n, p = map(int, input().split())\n    lst = list(map(int,input().split()))\n    lst.sort()\n    ans = []\n    for x in range(max(max(lst) + 1, p + 1)):\n        if fa(lst,x,p):\n            ans.append(x)\n    print(len(ans))\n    print(*ans)\nfor i in range(1):\n    solve()", "import bisect\nimport sys\ninput=sys.stdin.readline\n\nn,p=map(int,input().split())\narr=list(map(int,input().split()))\narr=sorted(arr)\nmins=arr[0]\nmaxs=arr[-1]\nans=[]\nfor x in range(mins,maxs):\n    pattern=[0]*n\n    for i in range(n-1,-1,-1):\n        if arr[i]<=x:\n            pattern[i]=n\n        elif arr[i]>x+i:\n            pattern[i]=0\n        else:\n            pattern[i]=n-(arr[i]-x)\n    pattern=pattern[::-1]\n    for i in range(n):\n        if pattern[i]==0 or (pattern[i]-i)%p==0 or pattern[i]-i<=0:\n            break\n    else:\n        ans.append(x)\nprint(len(ans))\nprint(*ans)", "n, p = list(map(int, input().split(' ')))\na = list(map(int, input().split(' ')))\na.sort()\nresult = []\nfor x in range(a[-1]):\n    fail = 0\n    for i in range(len(a) - 1, -1, -1):\n        if (x + i) < a[i]:\n            fail = 1\n            break\n        elif p <= min(i + 1, i - (a[i] - x - 1)):\n            fail = 1\n            break\n    if fail == 0:\n        result.append(str(x))\nprint(len(result))\nif result:\n    print(' '.join(result))"]
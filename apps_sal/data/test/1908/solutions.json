["def xmax(x, y):\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = list(map(int, input().split()))\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = list(map(int, input().split()))\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:\n        break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:\n    print(\"DEAD\")\nelse:\n    print(\"ALIVE\")\n    print(*R[::-1])\n", "def xmax(x, y):\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:\n        break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:\n    print(\"DEAD\")\nelse:\n    print(\"ALIVE\")\n    print(*R[::-1])", "def xmax(x, y):\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "from collections import deque\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    n,m=MI()\n    ww=LI()\n    xy=LLI1(m)\n    fav_mem=[[] for _ in range(n)]\n    fav_cnt=[0]*n\n    for j,(x,y) in enumerate(xy):\n        fav_mem[x].append(j)\n        fav_mem[y].append(j)\n        fav_cnt[x]+=1\n        fav_cnt[y]+=1\n\n    q=deque()\n    for i in range(n):\n        if ww[i]-fav_cnt[i]>=0:q.append(i)\n\n    ans=[]\n    fini=[False]*n\n    finj=[False]*m\n    while q:\n        i=q.popleft()\n        for j in fav_mem[i]:\n            if finj[j]:continue\n            ans.append(j+1)\n            finj[j]=True\n            for i0 in xy[j]:\n                if fini[i0]:continue\n                fav_cnt[i0]-=1\n                if  ww[i0]-fav_cnt[i0]>=0:\n                    q.append(i0)\n                    fini[i0]=True\n    if len(ans)==m:\n        print(\"ALIVE\")\n        print(*ans[::-1])\n    else:print(\"DEAD\")\n\nmain()", "def xmax(x, y):\n    if x[1] > y[1]:return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "def xmax(x, y):\n    if x[1] > y[1]:return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:res = self.segfunc(res,self.seg[q]);q -= 1\n            p = p//2\n            q = (q-1)//2\n        res = (self.segfunc(res,self.seg[p]) if p == q else self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q]))\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf,R,vs = False,[],set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:f=True;break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:continue\n        vs.add(i);ss.update(co, 1);R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "def xmax(x, y):\n    if x[1] > y[1]:return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func;self.num = 2**(n-1).bit_length();self.ide_ele = ide_ele;self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k;k += self.num-1;self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1;self.seg[k] = x\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:return self.ide_ele\n        p += self.num-1;q += self.num-2;res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:res = self.segfunc(res,self.seg[q]);q -= 1\n            p = p//2;q = (q-1)//2\n        return (self.segfunc(res,self.seg[p]) if p == q else self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q]))\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf,R,vs = False,[],set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:f=True;break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:continue\n        vs.add(i);ss.update(co, 1);R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "def xmax(x, y):\n    if x[1] > y[1]:return x\n    return y\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func;self.num = 2**(n-1).bit_length();self.ide_ele = ide_ele;self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])         \n    def update(self, k, x):\n        ll = k;k += self.num-1;self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n    def update2(self, k, x):\n        k += self.num-1;self.seg[k] = x\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])        \n    def query(self, p, q):\n        if q<=p:return self.ide_ele\n        p += self.num-1;q += self.num-2;res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:res = self.segfunc(res,self.seg[q]);q -= 1\n            p = p//2;q = (q-1)//2\n        return (self.segfunc(res,self.seg[p]) if p == q else self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q]))\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split());X = list(map(int, input().split()));sts = [[] for _ in range(N)]\nfor i in range(1, M+1):a, b = map(int, input().split());sts[a-1].append((i, b-1));sts[b-1].append((i, a-1));X[a-1] -= 1;X[b-1] -= 1\nminf = -(10 ** 18)-1;ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax);f,R,vs = False,[],set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:f=True;break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:continue\n        vs.add(i);ss.update(co, 1);R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "def xmax(x, y):\n    if x[1] > y[1]:return x\n    return y\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func;self.num = 2**(n-1).bit_length();self.ide_ele = ide_ele;self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])         \n    def update(self, k, x):\n        ll = k;k += self.num-1;self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n    def update2(self, k, x):\n        k += self.num-1;self.seg[k] = x\n        while k+1:k = (k-1)//2;self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])        \n    def query(self, p, q):\n        if q<=p:return self.ide_ele\n        p += self.num-1;q += self.num-2;res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:res = self.segfunc(res,self.seg[q]);q -= 1\n            p = p//2;q = (q-1)//2\n        return (self.segfunc(res,self.seg[p]) if p == q else self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q]))\nimport sys;input=sys.stdin.readline;N, M = map(int, input().split());X = list(map(int, input().split()));sts = [[] for _ in range(N)]\nfor i in range(1, M+1):a, b = map(int, input().split());sts[a-1].append((i, b-1));sts[b-1].append((i, a-1));X[a-1] -= 1;X[b-1] -= 1\nminf = -(10 ** 18)-1;ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax);f,R,vs = False,[],set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:f=True;break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:continue\n        vs.add(i);ss.update(co, 1);R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])", "import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n\n\nn,m=list(map(int,input().split()))\nw=list(map(int,input().split()))\ndata=[[] for i in range(n)]\nfav=[]\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    x,y=min(x,y),max(x,y)\n    w[x-1]-=1\n    w[y-1]-=1\n    data[x-1].append(i)\n    data[y-1].append(i)\n    fav.append((x-1,y-1))\n\nans=[]\nused=[False]*m\nuseddish=[False]*n\n\nque=deque([])\nfor i in range(n):\n    if w[i]>=0:\n        que.append(i)\n        useddish[i]=True\n\nwhile que:\n    id=que.popleft()\n    for i in data[id]:\n        if not used[i]:\n            used[i]=True\n            ans.append(i)\n            x,y=fav[i]\n            w[x]+=1\n            w[y]+=1\n            if w[x]>=0 and not useddish[x]:\n                que.append(x)\n                useddish[x]=True\n            if w[y]>=0 and not useddish[y]:\n                que.append(y)\n                useddish[y]=True\n\nif len(ans)==m:\n    print(\"ALIVE\")\n    ans=[ans[-i-1]+1 for i in range(m)]\n    print(*ans)\nelse:\n    print(\"DEAD\")\n", "import math\nimport sys\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\nw = [int(_) for _ in input().split()]\nedges = []\ng = [[] for _ in range(n)]\ndeg = [0] * n\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    u, v = u - 1, v - 1\n    g[u].append(v)\n    g[v].append(u)\n    edges.append((u, v))\n    deg[u] += 1\n    deg[v] += 1\norder = [0] * n\ndone = [False] * n \nstack = []\ncur = 0\nfor i in range(n):\n    if deg[i] <= w[i]:\n        done[i] = True\n        order[i] = cur\n        stack.append(i)\n        cur += 1\nwhile len(stack) > 0:\n    x = stack.pop()\n    for i in g[x]:\n        deg[i] -= 1\n        if not done[i] and deg[i] <= w[i]:\n            order[i] = cur\n            done[i] = True\n            stack.append(i)\n            cur += 1\nif sum(done) != n:\n    print('DEAD')\n    return\nsortEdges = []\nfor i in range(m):\n    u, v = edges[i]\n    if order[u] < order[v]:\n        u, v = v, u\n    sortEdges.append((order[u], order[v], i))\nprint('ALIVE')\nprint(' '.join([str(i[2] + 1) for i in sorted(sortEdges, reverse=True)]))\n"]
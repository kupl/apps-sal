["from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\nn = int(input())\ncost = [list(map(int, input().split())) for i in range(3)]\ninfo = [list(map(int, input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n)]\n\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\nfor i in graph:\n    if len(i) >= 3:\n        print(-1)\n        return\n\nfor i, j in enumerate(graph):\n    if len(j) == 1:\n        start = i\n        break\n\nvisited = [-1]*n\nvisited[start] = 0\nq = deque([start])\n\nwhile q:\n    pos = q.popleft()\n    for next_pos in graph[pos]:\n        if visited[next_pos] != -1:\n            continue\n        visited[next_pos] = (visited[pos] + 1) % 3\n        q.append(next_pos)\n\nans = float(\"inf\")\nind = [0, 1, 2]\nfor ptn in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]:\n    tmp_ans = 0\n    for i in range(n):\n        tmp_ans += cost[ptn[visited[i]]][i]\n    if tmp_ans < ans:\n        ans = tmp_ans\n        ind = ptn[0:]\n\nprint(ans)\nnew_ans = [0]*n\nfor i in range(n):\n    new_ans[i] = ind[visited[i]] + 1\nprint(*new_ans)", "n = int(input())\nc1 = [int(x) for x in input().split()]\nc2 = [int(x) for x in input().split()]\nc3 = [int(x) for x in input().split()]\nc = {'1':c1, '2':c2, '3':c3}\n\na = {i:[] for i in range(1, n+1)}\nfor i in range(n-1):\n    x, y = [int(x) for x in input().split()]\n    a[x].append(y)\n    a[y].append(x)\n\nstart = 0\nbad = False\nfor k, v in a.items():\n    l = len(v)\n    if l > 2:\n        bad = True\n        break\n    elif l == 1:\n        start = k\n\nif bad:\n    print(-1)\nelse:\n    prev = start\n    cur = a[start][0]\n    b = [prev]\n    while True:\n       b.append(cur)\n       if len(a[cur]) == 1:\n           break\n       nxt = [x for x in a[cur] if x != prev][0]\n       prev = cur\n       cur = nxt\n    \n    ms = sum(c1)+sum(c2)+sum(c3)\n    best_per = ''\n    for per in {'123', '132', '231', '213', '312', '321'}:\n        s = 0\n        ci = 0\n        for cur in b:\n            cvet = per[ci]\n            s += c[cvet][cur-1]\n            ci = (ci+1)%3\n        if s < ms:\n            ms = s\n            best_per = per\n\n##    print(b)\n    print(ms)\n    ci = 0\n    res = ['' for i in range(n+1)]\n    for cur in b:\n        cvet = best_per[ci]\n        res[cur] = cvet\n        ci = (ci+1) % 3\n    for i in range(1, n+1):\n        print(res[i],end = \" \")\n    \n", "n = int(input())\nc = [list(map(int, input().split())) for _ in range(3)]\ng = [[] for _ in range(n)]\nl = [0] * n\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n    l[a - 1] += 1\n    l[b - 1] += 1\nif max(l) > 2:\n    print(-1)\n    return\nfor i in range(n):\n    if l[i] == 1:\n        s = [i]\n        break\ndist = [-1] * n\ndist[i] = 0\nwhile s:\n    d = s.pop()\n    dist[d] %= 3\n    for node in g[d]:\n        if dist[node] == -1:\n            s.append(node)\n            dist[node] = dist[d] + 1\nans = float('inf')\nfor i1 in range(3):\n    for i2 in range(3):\n        if i1 == i2:\n            continue\n        for i3 in range(3):\n            if i1 == i3 or i2 == i3:\n                continue\n            tmp = 0\n            for j in range(n):\n                tmp += c[(i1, i2, i3)[dist[j]]][j]\n            if tmp < ans:\n                idx = (i1, i2, i3)\n                ans = tmp\nprint(ans)\nfor i in range(n - 1):\n    print(idx[dist[i]] + 1, end=' ')\nprint(idx[dist[n - 1]] + 1)\n", "from itertools import permutations\ndef cost(start, C):\n    prev = start\n    color = 0\n    mycost = C[color][start]\n    color = (color + 1) % 3\n    cur = tree[start][0]\n    for _ in range(n - 1):\n        #print(prev, cur, tree[cur])\n        glnext[prev] = cur\n        mycost += C[color][cur]\n        if prev != tree[cur][0]:\n            prev = cur\n            cur = tree[cur][0]\n        elif len(tree[cur]) > 1:\n            prev = cur\n            cur = tree[cur][1]\n        color = (color + 1) % 3\n    return mycost\n\n\nn = int(input())\nc1 = list(map(int, input().split()))\nc2 = list(map(int, input().split()))\nc3 = list(map(int, input().split()))\nC = [c1, c2, c3]\ntree = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    tree[u].append(v)\n    tree[v].append(u)\nfor node in tree:\n    if len(node) > 2:\n        print(-1)\n        return\nfor i in range(n):\n    if len(tree[i]) == 1:\n        start = i\n        break\nbest = 999999999999999999\nglnext = [-1] * n\nfor p in permutations(list(range(3))):\n    Cperm = [C[p[0]], C[p[1]], C[p[2]]]\n    cst = cost(start, Cperm)\n    if cst < best:\n        best = cst\n        ans = [-1] * n\n        cur = start\n        col = 0\n        for _ in range(n):\n            ans[cur] = p[col] + 1\n            cur = glnext[cur]\n            col = (col + 1) % 3\nprint(best)\nprint(' '.join(list(map(str, ans))))\n", "#592_D\n\nimport sys\n\nn = int(input())\n\nvs = []\n\nfor i in range(0, 3):\n    ln = [int(j) for j in sys.stdin.readline().rstrip().split(\" \")]\n    vs.append(ln)\n\nvt = {}\n\nf = True\n\nfor i in range(0, n - 1):\n    edg = [int(j) for j in sys.stdin.readline().rstrip().split(\" \")]\n    if edg[0] in vt:\n        vt[edg[0]].append(edg[1])\n    else:\n        vt[edg[0]] = [edg[1]]\n    if edg[1] in vt:\n        vt[edg[1]].append(edg[0])\n    else:\n        vt[edg[1]] = [edg[0]]\n\nst = -1\nfor i in vt:\n    if len(vt[i]) > 2:\n        f = False\n        break\n    if len(vt[i]) == 1:\n        st = i\n\nif f:\n    combos = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    m = -1\n    ms = -1\n    for i in range(0, len(combos)):\n        cost = 0\n        seq = [0] * (n)\n        vert = st\n        vis = {}\n        for j in range(0, len(vs[0])):\n            vis[vert] = True\n            cost += vs[combos[i][j % 3] - 1][vert - 1]\n            seq[vert - 1] = combos[i][j % 3]\n            vert = vt[vert]\n            if j == len(vs[0]) - 1:\n                break\n            if vert[0] in vis:\n                vert = vert[1]\n            else:\n                vert = vert[0]\n        if m == -1 or cost < m:\n            m = cost\n            ms = seq\n    print(m)\n    print(\" \".join([str(i) for i in ms]))\nelse:\n    print(-1)\n", "class Vertex:\n    def __init__(self, index):\n        self.index = index\n        self.neighbours = []\n        self.color = None\n\n\ndef main():\n\n    n = int(input())\n    cols = []\n    cols.append([int(z) for z in input().split()])\n    cols.append([int(z) for z in input().split()])\n    cols.append([int(z) for z in input().split()])\n\n    tree = [Vertex(i) for i in range(n)]\n\n    for _ in range(n-1):\n        u1, u2 = [int(p) - 1 for p in input().split()]\n        tree[u1].neighbours.append(u2)\n        tree[u2].neighbours.append(u1)\n\n    if any(len(vertex.neighbours) > 2 for vertex in tree):\n        print(\"-1\")\n        return\n\n    root = None\n    for vertex in tree:\n        if len(vertex.neighbours) == 1:\n            root = vertex\n            break\n\n    current_group = 1\n    prev_vertex = root.index\n    vertex = tree[root.neighbours[0]]\n    groups = [[root.index], [], []]\n\n    while True:\n        is_leaf = len(vertex.neighbours) == 1\n        groups[current_group].append(vertex.index)\n        if is_leaf:\n            break\n        current_group = (current_group + 1) % 3\n        next_vertex_index = sum(vertex.neighbours) - prev_vertex\n        prev_vertex = vertex.index\n        vertex = tree[next_vertex_index]\n\n    best_col_per_group = None\n    best_price = None\n    for col_per_group in [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]:\n        price = 0\n        for group_id in range(len(groups)):\n            group_col = col_per_group[group_id] - 1\n            for node_id in groups[group_id]:\n                price += cols[group_col][node_id]\n        if best_price is None or price < best_price:\n            best_price = price\n            best_col_per_group = col_per_group\n\n    print(best_price)\n    for color, group in zip(best_col_per_group, groups):\n        for node_id in group:\n            tree[node_id].color = color\n\n    for node in tree:\n        print(node.color, end=' ')\n\nmain()", "n = int(input())\nedge = [[] for _ in range(n)]\ncosts = [[] for _ in range(3)]\nfor i in range(3):\n    costs[i] = [int(item) for item in input().split()]\nfor i in range(n - 1):\n    u, v = [int(item) - 1 for item in input().split()]\n    edge[u].append(v)\n    edge[v].append(u)\n\nbeggining = None\nfor i, e in enumerate(edge):\n    l = len(e)\n    if l > 2:\n        print(-1)\n        return\n    elif beggining is None and l == 1:\n        beggining = i \n\nplace = []\nvisited = [0] * n\nnode = beggining\nwhile node != -1:\n    place.append(node)\n    visited[node] = 1\n    ok = False\n    for v in edge[node]:\n        if visited[v]:\n            continue\n        node = v\n        ok = True\n    if not ok:\n        break\n\nc_ans = [0] * n\ncolor = [0] * n\nans = 10 ** 18\nfor init_c in range(3):\n    ret = 0\n    c = init_c \n    for item in place:\n        ret += costs[c][item]\n        color[item] = c + 1\n        c = (c + 1) % 3\n    if ret < ans:\n        ans = ret\n        c_ans = color[:]\nfor init_c in range(3):\n    ret = 0\n    c = init_c \n    for item in place:\n        ret += costs[c][item]\n        color[item] = c + 1\n        c = (c + 2) % 3\n    if ret < ans:\n        ans = ret\n        c_ans = color[:]\n\nprint(ans)\nprint(\" \".join([str(item) for item in c_ans]))", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nn = int(input())\n\nc1 = list(map(int,input()[:-1].split()))\nc2 = list(map(int,input()[:-1].split()))\nc3 = list(map(int,input()[:-1].split()))\n\nal = [list() for _ in range(n)]\n\nfor _ in range(n-1):\n    u, v = list(map(int,input()[:-1].split()))\n    al[u-1].append(v-1)\n    al[v-1].append(u-1)\n\nfor i in range(n):\n    if len(al[i]) > 2:\n        print(-1)\n        return\n    elif len(al[i]) == 1:\n        start = i\n\nvis = [False for _ in range(n)]\nsequence = []\nstack = deque()\nstack.append(start)\n\nwhile len(stack)>0:\n    u = stack.pop()\n    sequence.append(u)\n    vis[u] = True\n    for v in al[u]:\n        if not vis[v]:\n            stack.append(v)\n\nsums = [0]*6\nseqs = [[c1,c2,c3],[c1,c3,c2],[c2,c1,c3],[c2,c3,c1],[c3,c1,c2],[c3,c2,c1]]\nseqi = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nfor i in range(n):\n    for j in range(6):\n        sums[j]+=seqs[j][i%3][sequence[i]]\n\nmini = 0\nmn = sums[0]\n\nfor i in range(len(sums)):\n    if sums[i]< mn:\n        mn = sums[i]\n        mini = i\nans = [0]*n\nfor i in range(n):\n    ans[sequence[i]] = seqi[mini][i%3]\nprint(mn)\nprint(*ans)\n\n", "import itertools\nimport math\n\n\ndef main():\n    tree = dict()\n    n = int(input())\n    c1 = list(map(int, input().split()))\n    c2 = list(map(int, input().split()))\n    c3 = list(map(int, input().split()))\n    costs = [(c1[i], c2[i], c3[i]) for i in range(len(c1))]\n    no_sol = False\n    for i in range(n-1):\n        a, b = list(map(int, input().split()))\n        if a not in tree:\n            tree[a] = [b]\n        else:\n            tree[a].append(b)\n        if b not in tree:\n            tree[b] = [a]\n        else:\n            tree[b].append(a)\n        if len(tree[a]) > 2:\n            no_sol = True\n        if len(tree[b]) > 2:\n            no_sol = True\n\n    if no_sol:\n        print(-1)\n        return\n\n    for node in list(tree.keys()):\n        if len(tree[node]) == 1:\n            start = node\n            break\n            \n    lst = [start]\n    visited = [0] * (n +1)\n    visited[node] = 1\n    node = start\n    while len(lst) < n:\n        for i in tree[node]:\n            if visited[i] == 0:\n                visited[i] = 1\n                lst.append(i)\n                node = i\n                break\n\n    permutations = list(itertools.permutations([1,2,3], 3))\n    cost = [0] * len(permutations)\n\n    idx_permut = -1\n    min_sum = math.inf\n    for permut in range(len(permutations)):\n        cost_sum = 0\n        for i in range(len(lst)):\n            list_cost = costs[lst[i]-1]\n            cost_sum += list_cost[permutations[permut][i % 3]-1]\n        cost[permut] = cost_sum\n        if cost_sum < min_sum:\n            min_sum = cost_sum\n            idx_permut = permut\n\n\n    d_sol = [0] * (len(lst) + 1)\n    idx = 0\n    my_perm = permutations[idx_permut]\n    for i in lst:\n        d_sol[i] = my_perm[idx % 3]\n        idx += 1\n\n    solution = d_sol[1:]\n\n    print(min_sum)\n    print(\" \".join(map(str, solution)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nc = [list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))]\ngraph = []\nfor i in range(n):\n    graph.append([])\nsorted_graph = []\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n    if len(graph[a]) > 2 or len(graph[b]) > 2:\n        print(-1)\n        return\n\nfor j in range(n):\n    if len(graph[j]) == 1:\n        sorted_graph.append(j)\n        sorted_graph.append(graph[j][0])\n        for _ in range(n - 2):\n            for connection in graph[sorted_graph[-1]]:\n                if connection != sorted_graph[-2]:\n                    sorted_graph.append(connection)\n                    break\n        break\n\nsorted_graph_indexes = [-1] * len(sorted_graph)\nfor i in range(len(sorted_graph_indexes)):\n    sorted_graph_indexes[sorted_graph[i]] = i\n\nsum = -1\nsignsum = 0\naddsum = 0\nfor sign in range(-1, 2, 2):\n    for add in range(3):\n        lsum = 0\n        for i in range(n):\n            lsum += c[(add + sorted_graph_indexes[i] * sign) % 3][i]\n        if sum == -1 or sum > lsum:\n            sum = lsum\n            signsum = sign\n            addsum = add\n\nprint(sum)\nfor i in range(n):\n    print((addsum + sorted_graph_indexes[i] * signsum) % 3 + 1, end=' ')\n", "def main():\n    n = int(input())\n    color1 = [int(elm) for elm in input().split(\" \")]\n    color2 = [int(elm) for elm in input().split(\" \")]\n    color3 = [int(elm) for elm in input().split(\" \")]\n\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n\n    num_adjs = [0 for i in range(n)]\n    for _ in range(n-1):\n        p, q = map(int, input().split(\" \"))\n        p -= 1\n        q -= 1\n        graph[p].append(q)\n        graph[q].append(p)\n        num_adjs[p] += 1\n        num_adjs[q] += 1\n\n    if max(num_adjs) >= 3:\n        print(-1)\n        return\n\n    node_type = [0 for i in range(n)]\n    first_nodes = [i for i, num_adj in enumerate(num_adjs) if num_adj == 1]\n    if len(first_nodes) != 2:\n        print(-1)\n        return\n    first_node, end_node = first_nodes\n\n    junban = [first_node]\n    parent = first_node\n    jibun = graph[first_node][0]\n    count = 0\n    for i in range(n-1):\n        junban.append(jibun)\n        #print(end_node, jibun)\n\n        if i == n-2:\n            #assert jibun == end_node\n            pass\n        kids = graph[jibun]\n        for kid in kids:\n            if parent != kid:\n                parent = jibun\n                jibun = kid\n                break\n        count += 1\n        \n    \n    colors = [color1, color2, color3]\n    min_tensu = sum(color1) + sum(color2) + sum(color3)\n\n    color_orders = [[0, 1, 2], [0, 2, 1], [1, 2, 0], [1, 0, 2], [2, 0, 1], [2, 1, 0]]\n    for ci, color_order in enumerate(color_orders):\n        cur_tensu = 0\n        node_colors = [-1 for i in range(n)]\n        for i, node_i in enumerate(junban):\n            i = i % 3\n            node_color = color_order[i]\n            cost = colors[node_color][node_i]\n            node_colors[node_i] = node_color \n            cur_tensu += cost\n        if cur_tensu < min_tensu:\n            min_ci = ci\n            min_tensu = cur_tensu\n            min_node_colors = node_colors\n\n    print(min_tensu)\n    print(\" \".join([str(elm+1) for elm in min_node_colors]))\n\n\n\nmain()", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nn = int(input())\nc = []\nfor i in range(3):\n    c.append(list(map(int, input().split())))\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nfor i in range(1, n+1):\n    if len(graph[i])>2: print(-1); break\n    if len(graph[i])==1: root = i\nelse:\n    ls = [root, graph[root][0]]\n    root = graph[root][0]\n    while len(ls)!=n:\n        for i in graph[root]:\n            if i!=ls[-2]:\n                ls.append(i)\n                root = i\n                break\n    perm = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    for lis in perm:\n        N = n-len(lis)\n        for i in range(N):\n            lis.append(lis[i%3])\n    cost = []\n    for lis in perm:\n        temp = 0\n        for i in range(n):\n            temp+=c[lis[i]-1][ls[i]-1]\n        cost.append(temp)\n    m = min(cost)\n    print(m)\n    for i in range(6):\n        if cost[i]==m:\n           ls = {ls[j]: perm[i][j] for j in range(n)}\n           for i in range(1, n+1):\n               print(ls[i], end=' ')\n           print()\n           break\n", "#!/usr/bin/env python3\nimport sys\nfrom itertools import permutations\nfrom math import inf\n\n#lines = stdin.readlines()\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n')\n\ndef oint():\n    return int(input())\n\n\nn = oint()\n\nc = []\nfor i in range(3):\n    c.append(list(rint()))\n\nadj = [set() for i in range(n)]\nfor i in range(n-1):\n    u, v = rint()\n    u -= 1\n    v -= 1\n    adj[u].add(v)\n    adj[v].add(u)\nfor i in range(n):\n    if len(adj[i]) >= 3:\n        print(-1)\n        return\n    if len(adj[i]) == 1:\n        start = i\nminv = inf\ni = [0]*3\nord = []\nprev = -1\ncur = start\nfor j in range(n):\n    ord.append(cur)\n    for next in adj[cur]:\n        if next != prev:\n            break\n    prev = cur\n    cur = next\n\n\nfor i[0], i[1], i[2] in permutations([0,1,2]):\n    v = 0\n    for j in range(n):\n        v += c[i[j%3]][ord[j]]\n    if v < minv:\n        imin = i.copy()\n        minv = v\nans = [0]*n\nfor j in range(n):\n    ans[ord[j]] = imin[j%3] + 1\nprint(minv)\nprint(*ans)\n\n\n", "#!/usr/bin/env python3\nimport sys\nfrom itertools import permutations\nfrom math import inf\n\n#lines = stdin.readlines()\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n')\n\ndef oint():\n    return int(input())\n\n\nn = oint()\n\nc = []\nfor i in range(3):\n    c.append(list(rint()))\n\nadj = [set() for i in range(n)]\nfor i in range(n-1):\n    u, v = rint()\n    u -= 1\n    v -= 1\n    adj[u].add(v)\n    adj[v].add(u)\nfor i in range(n):\n    if len(adj[i]) >= 3:\n        print(-1)\n        return\n    if len(adj[i]) == 1:\n        start = i\nminv = inf\ni = [0]*3\nord = []\ncur = start\nv = [0]*n\nv[cur] = 1\nfor j in range(n):\n    ord.append(cur)\n    for next in adj[cur]:\n        if v[next] == 0:\n            v[next] = 1\n            cur = next\n            break\n\nfor i[0], i[1], i[2] in permutations([0,1,2]):\n    v = 0\n    for j in range(n):\n        v += c[i[j%3]][ord[j]]\n    if v < minv:\n        imin = i.copy()\n        minv = v\nans = [0]*n\nfor j in range(n):\n    ans[ord[j]] = imin[j%3] + 1\nprint(minv)\nprint(*ans)\n\n\n", "import sys\nn=int(input())\na=[]\na1=[int(x) for x in input().split()]\na2=[int(x) for x in input().split()]\na3=[int(x) for x in input().split()]\na=[[0],a1,a2,a3]\n#print(a)\nadj=[[] for i in range(n+1)]\nfor i in range(n-1):\n    u,v=list(map(int,input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\n#print(adj)    \nfor i in adj:\n    if len(i)>2:\n        print(-1)\n        return\nsumi=[0 for i in range(7)]\ng=[[0 for j in range(n+1)] for i in range(6)]\nfor i in range(n):\n    if len(adj[i])==1:\n        p=i\n        break\ng[0][p]=1\ng[0][adj[p][0]]=2\nflag=3\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[0][adj[i][0]]==0 :\n        g[0][adj[i][0]]=flag\n        flag=6-flag-g[0][i]\n        i=adj[i][0]\n    else:\n        g[0][adj[i][1]]=flag\n        flag=6-flag-g[0][i]\n        i=adj[i][1]\ng[1][p]=2\ng[1][adj[p][0]]=3\nflag=1\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[1][adj[i][0]]==0 :\n        g[1][adj[i][0]]=flag\n        flag=6-flag-g[1][i]\n        i=adj[i][0]\n    else:\n        g[1][adj[i][1]]=flag\n        flag=6-flag-g[1][i]\n        i=adj[i][1]\ng[2][p]=1\ng[2][adj[p][0]]=3\nflag=2\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[2][adj[i][0]]==0 :\n        g[2][adj[i][0]]=flag\n        flag=6-flag-g[2][i]\n        i=adj[i][0]\n    else:\n        g[2][adj[i][1]]=flag\n        flag=6-flag-g[2][i]\n        i=adj[i][1]\n        \ng[3][p]=3\ng[3][adj[p][0]]=2\nflag=1\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[3][adj[i][0]]==0 :\n        g[3][adj[i][0]]=flag\n        flag=6-flag-g[3][i]\n        i=adj[i][0]\n    else:\n        g[3][adj[i][1]]=flag\n        flag=6-flag-g[3][i]\n        i=adj[i][1]\n\ng[4][p]=3\ng[4][adj[p][0]]=1\nflag=2\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[4][adj[i][0]]==0 :\n        g[4][adj[i][0]]=flag\n        flag=6-flag-g[4][i]\n        i=adj[i][0]\n    else:\n        g[4][adj[i][1]]=flag\n        flag=6-flag-g[4][i]\n        i=adj[i][1]\n\ng[5][p]=2\ng[5][adj[p][0]]=1\nflag=3\ni=adj[p][0]\nfor _ in range(n-1):\n    if len(adj[i])==1:\n        break\n    if g[5][adj[i][0]]==0 :\n        g[5][adj[i][0]]=flag\n        flag=6-flag-g[5][i]\n        i=adj[i][0]\n    else:\n        g[5][adj[i][1]]=flag\n        flag=6-flag-g[5][i]\n        i=adj[i][1]\n#print(g) \nmaxi=10**9*n+5\nans=0\ni=1\nfor j in range(6):\n    sumi=0\n    \n    for i in range(1,n+1):\n        #print(i,j,g[j][i])\n        sumi+=a[g[j][i]][i-1]\n   # print(sumi)    \n    if maxi>sumi  :\n        maxi=sumi\n        ans=j\n        \nprint(maxi)\nprint(*g[ans][1:])\n\n", "from collections import defaultdict as dd\n\nn = int(input())\nc1 = list(map(int,input().split()))\nc2 = list(map(int,input().split()))\nc3 = list(map(int,input().split()))\n\nc1 = [None] + c1\nc2 = [None] + c2\nc3 = [None] + c3\nc = [[None for _ in range(n+1)]] + [c1] + [c2] + [c3]\n\nd = dd(lambda: [])\n\nfor _ in range(n-1):\n    a,b = list(map(int,input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\nflag = True\nroot = None\nfor i in range(1,n+1):\n    if len(d[i]) == 1:\n        root = i\n    if len(d[i]) >= 3:\n        flag = False\n\nif not flag:\n    print(-1)\nelse:\n    l1,l2,l3 = [],[],[]\n\n    q = [(root,1)]\n    s = set()\n\n    while q:\n        node,lv = q.pop(0)\n\n        if node not in s:\n            s.add(node)\n            if lv == 1:\n                l1.append(node)\n            elif lv == 2:\n                l2.append(node)\n            elif lv == 3:\n                l3.append(node)\n\n            for v in d[node]:\n                if lv == 1:\n                    q.append((v,2))\n                elif lv == 2:\n                    q.append((v,3))\n                elif lv == 3:\n                    q.append((v,1))\n\n    _min = 1e114 + 1\n    cl = (0,0,0)\n\n    for (cl1,cl2,cl3) in [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]:\n        cost = sum([c[cl1][j] for j in l1]) + sum([c[cl2][j] for j in l2]) + sum([c[cl3][j] for j in l3])\n        if cost < _min:\n            _min = cost\n            cl = (cl1,cl2,cl3)\n        \n    print(int(_min))\n    cl1,cl2,cl3 = cl\n    cl = [(i,cl1) for i in l1] + [(i,cl2) for i in l2] + [(i,cl3) for i in l3]\n    cl.sort(key=lambda x:x[0])\n    cl = [j for i,j in cl]\n    print(*cl)\n", "from collections import defaultdict, deque\nfrom itertools import permutations\n\n\nclass Graph:\n    def __init__(self):\n        self.E = {}\n        self.V = defaultdict(list)\n\n    def put(self, v1, v2):\n        if v1 not in self.E:\n            self.E[v1] = 1\n        if v2 not in self.E:\n            self.E[v2] = 1\n        self.V[v1].append(v2)\n        self.V[v2].append(v1)\n\n    def _adj(self, v1):\n        return self.V[v1]\n\n    def bfs(self, v):\n        visited = set([v])\n        path = [v]\n        q = deque([v])\n        while q:\n            v1 = q.pop()\n            for v2 in self._adj(v1):\n                if v2 not in visited:\n                    visited.add(v2)\n                    path.append(v2)\n                    q.appendleft(v2)\n\n        return path\n\n\ndef __starting_point():\n    n = int(input())\n    cp = []\n    for _ in range(3):\n        cp.append(list(map(int, input().split(' '))))\n\n    inv = False\n    vert = defaultdict(int)\n    graph = Graph()\n    for _ in range(n - 1):\n        v1, v2 = list(map(int, input().split(' ')))\n        vert[v1] += 1\n        if vert[v1] > 2:\n            inv = True\n            break\n        vert[v2] += 1\n        if vert[v2] > 2:\n            inv = True\n            break\n\n        graph.put(v1, v2)\n\n    if inv:\n        print(-1)\n    else:\n        for key in vert:\n            if vert[key] == 1:\n                start = key\n                break\n\n        path = graph.bfs(start)\n\n        min_cost = float('inf')\n        min_cost_perm = (0, 1, 2)\n        for p in permutations([0, 1, 2]):\n            cur_cost = 0\n            for i, v in enumerate(path):\n                cur_cost += cp[p[i % 3]][v - 1]\n\n            if cur_cost < min_cost:\n                min_cost_perm = p\n                min_cost = cur_cost\n\n        # print(path, graph.V)\n        ans = [0]*n\n        for i, v in enumerate(path):\n            ans[v - 1] = min_cost_perm[i % 3] + 1\n\n        print(min_cost)\n        print(' '.join(map(str, ans)))\n\n__starting_point()", "n=int(input())\nc1=input().split()\nc2=input().split()\nc3=input().split()\nfor i in range(n):\n    c1[i]=int(c1[i])\n    c2[i]=int(c2[i])\n    c3[i]=int(c3[i])\na=[[] for i in range(n)]\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    a[u-1].append(v-1)\n    a[v-1].append(u-1)\n#print(a)    \ncount1=0\ncount2=0\nj=0\nfor i in range(n):\n    if(len(a[i])==1):\n        j=i\n        count1+=1\n    if(len(a[i])==2):\n        count2+=1\nif(count1==2 and count2==n-2):\n    b=[]\n    check=[0 for i in range(n)]\n    while len(b)<n:\n        b.append(j)\n        check[j]=1\n        if(len(b)==n):\n            break\n        if(check[a[j][0]]==0):j=a[j][0]\n        else:j=a[j][1]\n    # 6 cases\n    # case 1 (1 2 3)\n    ans1=0\n    color1=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans1+=c1[b[i]]\n            color1[b[i]]=1\n        elif(i%3==1):\n            ans1+=c2[b[i]]\n            color1[b[i]]=2\n        else:\n            ans1+=c3[b[i]]\n            color1[b[i]]=3\n    # case 2 (3 1 2)\n    ans2=0\n    color2=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans2+=c3[b[i]]\n            color2[b[i]]=3\n        elif(i%3==1):\n            ans2+=c1[b[i]]\n            color2[b[i]]=1\n        else:\n            ans2+=c2[b[i]]   \n            color2[b[i]]=2\n    # case 3 (2 3 1)\n    ans3=0\n    color3=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans3+=c2[b[i]]\n            color3[b[i]]=2\n        elif(i%3==1):\n            ans3+=c3[b[i]]\n            color3[b[i]]=3\n        else:\n            ans3+=c1[b[i]]\n            color3[b[i]]=1\n    # case 4 (1 3 2)\n    ans4=0\n    color4=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans4+=c1[b[i]]\n            color4[b[i]]=1\n        elif(i%3==1):\n            ans4+=c3[b[i]]\n            color4[b[i]]=3\n        else:\n            ans4+=c2[b[i]]\n            color4[b[i]]=2\n    # case 5 (3 2 1)\n    ans5=0\n    color5=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans5+=c3[b[i]]\n            color5[b[i]]=3\n        elif(i%3==1):\n            ans5+=c2[b[i]]\n            color5[b[i]]=2\n        else:\n            ans5+=c1[b[i]]   \n            color5[b[i]]=1\n    # case 6 (2 1 3)\n    ans6=0\n    color6=[0 for i in range(n)]\n    for i in range(n):\n        if(i%3==0):\n            ans6+=c2[b[i]]\n            color6[b[i]]=2\n        elif(i%3==1):\n            ans6+=c1[b[i]]\n            color6[b[i]]=1\n        else:\n            ans6+=c3[b[i]]  \n            color6[b[i]]=3\n    if(ans1==min(ans1,ans2,ans3,ans4,ans5,ans6)):\n        print(ans1)\n        print(*color1)\n    elif(ans2==min(ans1,ans2,ans3,ans4,ans5,ans6)):\n        print(ans2)\n        print(*color2)\n    elif(ans3==min(ans1,ans2,ans3,ans4,ans5,ans6)):\n        print(ans3)\n        print(*color3)\n    elif(ans4==min(ans1,ans2,ans3,ans4,ans5,ans6)):\n        print(ans4)\n        print(*color4)\n    elif(ans5==min(ans1,ans2,ans3,ans4,ans5,ans6)):\n        print(ans5)\n        print(*color5)\n    else:\n        print(ans6)\n        print(*color6)\nelse:\n    print(-1)", "n = int(input())\n\nc = [[0] + list(map(int, input().split())) for _ in range(3)]\n\ne = [set() for u in range(n + 1)]\n\nfor i in range(n - 1):\n\tu, v = list(map(int, input().split()))\n\te[u].add(v)\n\te[v].add(u)\n\nfor i in range(1, n + 1):\n\tif len(e[i]) > 2:\n\t\tprint(-1)\n\t\treturn\n\nfor i in range(1, n + 1):\n\tif len(e[i]) == 1:\n\t\tS = i\n\t\tbreak\n\ns = [S, next(iter(e[S]))]\n\nfor i in range(n - 2):\n\tu = s[-1]\n\tfor v in e[u]:\n\t\tif v == s[-2]:\n\t\t\tcontinue\n\t\ts.append(v)\n\t\tbreak\n\nans, ans_d = 10 ** 100, []\nd = [0 for _ in range(n + 1)]\n\nfor i in range(3):\n\tfor j in range(3):\n\t\tif i != j:\n\t\t\td[s[0]] = i + 1\n\t\t\td[s[1]] = j + 1\n\t\t\tfor k in range(2, n):\n\t\t\t\td[s[k]] = 6 - (d[s[k - 1]] + d[s[k - 2]])\n\t\t\tw = sum([c[d[u] - 1][u] for u in range(1, n + 1)])\n\t\t\tif w < ans:\n\t\t\t\tans = w\n\t\t\t\tans_d = d[::]\n\nprint(ans)\nprint(*ans_d[1:])\n", "n=int(input())\nc1=list(map(int,input().split()))\nc2=list(map(int,input().split()))\nc3=list(map(int,input().split()))\nans=-1\nedges={}\ndegree=[0]*n\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    degree[u]+=1\n    degree[v]+=1\n    if u not in edges:\n        edges[u]=[v]\n    else :\n        edges[u].append(v)\n    if v not in edges:\n        edges[v]=[u]\n    else :\n        edges[v].append(u)\nimport sys\nif max(degree)>2:\n    print(-1)\n    return\nbfs=[]\nfor i in range(n):\n    if degree[i]==1:\n        bfs.append(i)\n        break\nvisited=[0]*n\nvisited[bfs[0]]=1\ncost123=c1[bfs[0]]\ncost132=c1[bfs[0]]\ncost213=c2[bfs[0]]\ncost231=c2[bfs[0]]\ncost312=c3[bfs[0]]\ncost321=c3[bfs[0]]\nturn=1\ncolors=[0]*n\ncolors[bfs[0]]=1\nwhile bfs:\n    temp=[]\n    for u in bfs:\n        for v in edges[u]:\n            if visited[v]==0:\n                colors[v]=turn+1\n                visited[v]=1\n                temp.append(v)\n                if turn==0:\n                    cost123+=c1[v]\n                    cost132+=c1[v]\n                    cost213+=c2[v]\n                    cost231+=c2[v]\n                    cost312+=c3[v]\n                    cost321+=c3[v]\n                if turn==1:\n                    cost123+=c2[v]\n                    cost132+=c3[v]\n                    cost213+=c1[v]\n                    cost231+=c3[v]\n                    cost312+=c1[v]\n                    cost321+=c2[v]\n                if turn==2:\n                    cost123+=c3[v]\n                    cost132+=c2[v]\n                    cost213+=c3[v]\n                    cost231+=c1[v]\n                    cost312+=c2[v]\n                    cost321+=c1[v]\n                \n    bfs=temp\n    turn+=1\n    turn=turn%3\nx=min(cost123,cost132,cost213,cost231,cost312,cost321)\nprint(x)\nif x==cost132:\n    for i in range(n):\n        if colors[i]==3:\n            colors[i]=2\n        elif colors[i]==2:\n            colors[i]=3\nelif x==cost213:\n    for i in range(n):\n        if colors[i]==1:\n            colors[i]=2\n        elif colors[i]==2:\n            colors[i]=1\nelif x==cost231:\n    for i in range(n):\n        if colors[i]==1:\n            colors[i]=2\n        elif colors[i]==2:\n            colors[i]=3\n        else :\n            colors[i]=1\nelif x==cost312:\n    for i in range(n):\n        if colors[i]==1:\n            colors[i]=3\n        elif colors[i]==2:\n            colors[i]=1\n        else :\n            colors[i]=2\nelif x==cost321:\n    for i in range(n):\n        if colors[i]==1:\n            colors[i]=3\n        elif colors[i]==3:\n            colors[i]=1\nprint(*colors,sep=\" \")\n    ", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom itertools import permutations\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN = INT()\nC1 = LIST()\nC2 = LIST()\nC3 = LIST()\nnodes = [[] for i in range(N)]\nfor i in range(N-1):\n    a, b = MAP()\n    a -= 1\n    b -= 1\n    nodes[a].append(b)\n    nodes[b].append(a)\n\nstart = 0\nfor i in range(N):\n    if len(nodes[i]) >= 3:\n        print(-1)\n        return\n    if len(nodes[i]) == 1:\n        start = i\n\nCs = [[] for i in range(3)]\nstack = [(start, -1)]\nwhile stack:\n    u, prev = stack.pop()\n    Cs[0].append(C1[u])\n    Cs[1].append(C2[u])\n    Cs[2].append(C3[u])\n    for v in nodes[u]:\n        if v != prev:\n            stack.append((v, u))\n\n# def rec(u, prev):\n#     Cs[0].append(C1[u])\n#     Cs[1].append(C2[u])\n#     Cs[2].append(C3[u])\n#     for v in nodes[u]:\n#         if v != prev:\n#             rec(v, u)\n# rec(start, -1)\n\nmn = INF\np = []\nfor perm in permutations(list(range(3))):\n    sm = 0\n    for i in range(N):\n        sm += Cs[perm[i%3]][i]\n    if mn > sm:\n        mn = min(mn, sm)\n        p = perm\n\nans = [0] * N\nstack = [(start, -1, 0)]\nwhile stack:\n    u, prev, cnt = stack.pop()\n    ans[u] = p[cnt%3] + 1\n    for v in nodes[u]:\n        if v != prev:\n            stack.append((v, u, cnt+1))\n\n# def rec2(u, prev, cnt):\n#     ans[u] = p[cnt%3] + 1\n#     for v in nodes[u]:\n#         if v != prev:\n#             rec2(v, u, cnt+1)\n# rec2(start, -1, 0)\n\nprint(mn)\nprint(*ans)\n"]
["from random import seed, randint\nimport sys\nsys.setrecursionlimit(10000)\n\nopr = ['#', '^', '&', '$']\nnamespace = { \"res\" : (False, \"res\") }\nrules = dict()\nlookup = dict()\ncnt = -1\n\ndef get_tag(var):\n    if var in namespace:\n        return namespace[var][1]\n    else:\n        return var\n\nN = int(input())\nfor _ in range(N):\n    lval, rval = input().split('=')\n    for c in opr:\n        if c in rval:\n            arg1, arg2 = list(map(get_tag, rval.split(c)))\n            rule = (arg1, arg2, c)\n            if rule in rules:\n                namespace[lval] = (True, rules[rule])\n            else:\n                cnt += 1\n                namespace[lval] = (True, cnt)\n                rules[rule] = cnt\n                lookup[cnt] = rule\n            break\n    else:\n        if rval in namespace:\n            namespace[lval] = namespace[rval]\n        else:\n            namespace[lval] = (False, rval)\n\nif namespace[\"res\"] == (False, \"res\"):\n    print(\"0\")\n    return\n\nprogram = []\nmyvars = dict()\n\ndef reserve():\n    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) \n\ndef implement(rule, final):\n    if type(rule) == str:\n        return rule\n    elif rule in myvars:\n        return myvars[rule]\n    else:\n        if final:\n            name = \"res\"\n        else:\n            name = reserve()\n        myvars[rule] = name\n        arg1, arg2, op = lookup[rule]\n        var1, var2 = implement(arg1, False), implement(arg2, False)\n        program.append(name + \"=\" + var1 + op + var2)\n        return name\n\nseed(123)\nif namespace[\"res\"][0]:\n    implement(namespace[\"res\"][1], True)\nelse:\n    program.append(\"res=\" + namespace[\"res\"][1])\nprint(len(program))\nprint(\"\\n\".join(program))\n\n#print(namespace)\n#print(rules)\n", "#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(65536)\n\nvars, reserved = {}, set()\nrules, irules, R = [], {}, 0\n\n\n\ndef wwj():\n\tn__ = 0\n\tdef dak():\n\t\tnonlocal n__\n\t\twhile 'a' + str(n__) in reserved:\n\t\t\tn__ += 1\n\t\tn__ += 1\n\t\treturn 'a' + str(n__ - 1)\n\treturn dak\n\nnext_var = wwj()\n\nL = int(input())\nfor i in range(L):\n\tk, v = input().split('=')\n\tif v.isidentifier():\n\t\tif v in vars:\n\t\t\tvars[k] = vars[v]\n\t\telse:\n\t\t\tvars[k] = v\n\t\t\treserved.add(v)\n\telse:\n\t\tj = [i for i in range(len(v)) if not v[i].isalnum()][0]\n\t\tv1, op, v2 = vars.get(v[:j], v[:j]), v[j], vars.get(v[j + 1:], v[j + 1:])\n\t\tr = (op, v1, v2)\n\t\tif r not in irules:\n\t\t\trules.append(r)\n\t\t\tirules[r] = R\n\t\t\tR += 1\n\t\tvars[k] = irules[r]\n\nif vars.get('res', 'res') == 'res':\n\tprint(0)\n\treturn\n\nresolve = {}\noutput = []\n\ndef interprete(v, name = None):\n\tif isinstance(v, str):\n\t\treturn v\n\tif v in resolve:\n\t\treturn resolve[v]\n\top, v1, v2 = rules[v]\n\tu1, u2 = interprete(v1), interprete(v2)\n\tif name is None:\n\t\tname = next_var()\n\tresolve[v] = name\n\toutput.append('{}={}{}{}'.format(name, u1, op, u2))\n\treturn name\n\nR = interprete(vars['res'], 'res')\nif R != 'res':\n\toutput.append('res={}'.format(R))\n\nprint(len(output), '\\n'.join(output), sep = '\\n')\n"]
n = int(input())

a = list(map(int, input().split()))

# 累積和を求める
for i in range(n - 1):
    a[i + 1] += a[i]

# 真ん中の仕切りを固定し、左右の配列についてさらに仕切りを動かして確認する
# 累積和なので単調増加だから、左右の二つの配列について、仕切りを追加したときに差が最も小さい仕切りの位置を保存
l = 0
r = 2
ans = float("inf")
# mは真ん中の仕切りの位置
for m in range(1, n - 1):
    # 累積和が単調増加だから、mを固定したとき2a[l]-a[m]も単調増加で、lを増加させていくと徐々に減少しlとl+1で逆転する部分を左の仕切りとする。
    # 2倍しないと累積和が単調増加のためずっと右辺が小さいままになる
    # 部分配列の平均値に近い部分を二分探索で探すことも可能だが、平均計算処理と探索処理に加え、候補がbisectで求めた位置の前後も含まれるのでめんどくさい
    while abs(2 * a[l] - a[m]) > abs(2 * a[l + 1] - a[m]):
        l += 1
    while abs(2 * a[r] - a[n - 1] - a[m]) > abs(2 * a[r + 1] - a[n - 1] - a[m]):
        r += 1

    bcde = [a[l], a[m] - a[l], a[r] - a[m], a[n - 1] - a[r]]
    ans = min(ans, max(bcde) - min(bcde))
print(ans)

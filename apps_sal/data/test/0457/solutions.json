["x, n = list(map(int, input().split()))\n\ndef primeFactor(N):\n    i, n, ret, d, sq = 2, N, {}, 2, 99\n    while i <= sq:\n        k = 0\n        while n % i == 0: n, k, ret[i] = n//i, k+1, k+1\n        if k > 0 or i == 97: sq = int(n**(1/2)+0.5)\n        if i < 4: i = i * 2 - 1\n        else: i, d = i+d, d^6\n    if n > 1: ret[n] = 1\n    return ret\n\npf = primeFactor(x)\nmod = 10 ** 9 + 7\ndef calc(p):\n    s = 0\n    a = n//p\n    while a:\n        s += a\n        a //= p\n    return pow(p, s, mod)\n\nans = 1\nfor p in pf:\n    ans = ans * calc(p) % mod\nprint(ans)\n\n\n", "import sys\ninput = sys.stdin.readline\n\nx,n=list(map(int,input().split()))\nmod=10**9+7\n\nimport math \nL=int(math.sqrt(x))\n\nFACT=dict()\n\nfor i in range(2,L+2):\n    while x%i==0:\n        FACT[i]=FACT.get(i,0)+1\n        x=x//i\n\nif x!=1:\n    FACT[x]=FACT.get(x,0)+1\n\nANS=1\n\nfor f in FACT:\n    for k in range(1,70):\n        t=n//(f**k)\n        if t==0:\n            break\n        ANS=ANS*pow(f,t,mod)%mod\n\nprint(ANS)\n", "from math import sqrt, ceil\ndef primes(x):\n    ox = x\n    l = []\n    cp = 3\n    if x % 2 == 0:\n        l.append(2)\n    while x % 2 == 0:\n        x //= 2\n    while cp <= ceil(sqrt(ox)):\n        if x % cp == 0:\n            l.append(cp)\n        while x % cp == 0:\n            x //= cp\n        cp += 2\n    if x != 1:\n        l.append(x)\n    return l\n\nmo = 10**9+7\nx,n = list(map(int,input().split()))\npi = primes(x)\ns = 1\nfor p in pi:\n    pk = p\n    while pk <= n:\n        s *= pow(p,n//pk,mo)\n        s %= mo\n        pk *= p\nprint(s)\n", "x,n=[int(x) for x in input().split()]\nprime=set()\narr=1\ny=int(x**0.5)\nfor i in range(2,y+1):\n    while x%i==0:\n        prime.add(i)\n        x//=i\nif x!=1:\n    prime.add(x)\ndic={}\nfor item in prime:\n    dic[item]=0\nfor item in prime:\n    for i in range(1,60):\n        dic[item]+=n//(item**i)\nfor item in dic:\n    arr*=pow(item,dic[item],(10**9+7))\nprint(arr%(10**9+7))\n        \n", "def primefactor(p):\n    x=p\n    pf=[]\n    for i in range(2,int(p**0.5)+1):\n        if(x%i==0):\n            pf.append(i)\n            while(x%i==0):\n                x//=i\n    if x>1:\n        pf.append(x)\n    return pf\nans=1\nMOD=int(1e9+7)\nx,n=list(map(int,input().split()))\nfor p in primefactor(x):\n    exp=0\n    P=p\n    while(P<=n):\n        exp+=n//P\n        P*=p\n    ans*=pow(p,exp,MOD)\n    ans%=MOD\nprint(ans)\n", "def factor(n):\n    out = []\n    \n    power = 0\n    while n & 1 == 0:\n        power += 1\n        n >>= 1\n\n    if power:\n        out.append(2)\n        power = 0\n\n    test = 3\n    while pow(test,2) <= n:\n        while n % test == 0:\n            power += 1\n            n //= test\n        if power:\n            out.append(test)\n            power = 0\n        test += 2\n\n    if n > 1:\n        out.append(n)\n\n    return out\n\n\nx, n = list(map(int,input().split()))\n\nM = 10 ** 9 + 7\n\nf = factor(x)\nout = 1\nfor p in f:\n    newPower = 0\n    nCopy = n\n    while nCopy:\n        nCopy //= p\n        newPower += nCopy\n    out *= pow(p,newPower,M)\n    out %= M\n\nprint(out)\n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nx,n = inpl()\n\ndivs = set()\ndiv = 2\nwhile div*div <= x:\n    while x%div == 0:\n        divs.add(div)\n        x //= div\n    div += 1\n\nif x != 1:\n    divs.add(x)\n\nans = 1\nfor div in divs:\n    tmp = 1\n    while tmp <= n:\n        tmp *= div\n        ans *= pow(div,n//tmp,mod)\n        ans %= mod\n\nprint(ans%mod)\n", "MOD = 10**9 + 7\nx, n = [int(item) for item in input().split()]\ndef prime_factorize(n):\n    b = 2\n    fct = set() \n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            fct.add(b)\n        b = b + 1\n    if n > 1:\n        fct.add(n)\n    return fct\n\nfac = prime_factorize(x)\nans = 1\nfor f in fac:\n    cnt = 0\n    val = n\n    while val:\n        cnt += val // f\n        val //= f\n    ans *= pow(f, cnt, MOD)\n    ans %= MOD\n\nprint(ans)", "def prime_divs(n):\n    divs = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            divs.append(d)\n            while n % d == 0:\n                n //= d\n        d += 1\n    if n > 1:\n        divs.append(n)\n    return divs\n\n\ndef pwrmod(a, n):\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (pwrmod(a, n // 2) % MOD) ** 2\n    return pwrmod(a, n - 1) * a % MOD\n\n\nx, n = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nans = 1\nfor d in prime_divs(x):\n    pwrsum = 0\n    pwr = d\n    while pwr <= n:\n        pwrsum += n // pwr\n        pwr *= d\n    ans = ans * pwrmod(d, pwrsum) % MOD\nprint(ans)", "x, n = map(int, input().split())\nmod = 1000000007\nres = 1\n\ndef bpow(x, y):\n    res = 1\n    while y > 0:\n        if y % 2 == 1:\n            res = (res * x) % mod\n            y -= 1\n        else:\n            x = (x * x ) % mod\n            y //= 2\n    return res\n\nsp = []\ni = 2\n\nwhile i * i <= x:\n    if x % i == 0:\n        sp.append(i)\n        while x % i == 0:\n            x //= i\n    i += 1\n    \nif (x > 1):\n    sp.append(x)\n\nfor i in sp:\n    st = 1\n    while st <= n:\n        st *= i\n    st //= i\n    byv = 0\n    while st > 0:\n        cnk = n // st\n        cnk -= byv\n        res = (res * bpow(st, cnk)) % mod\n        byv += cnk\n        st //= i\n\nprint(res)", "from sys import stdin, stdout\n \nii = lambda: int(stdin.readline())\nmi = lambda: list(map(int, stdin.readline().strip().split()))\nli = lambda: list(mi())\n\nMOD = int(1000000007)\n\ndef binpow(a, b, m):\n\ta %= m\n\tres = 1\n\twhile (b > 0):\n\t\tif (b & 1):\n\t\t\tres = res * a % m\n\t\ta = a * a % m\n\t\tb >>= 1\n\treturn res\n\nx, n = mi()\nfac = []\ntmp = int(x)\nif (tmp % 2 == 0):\n\tfac.append(2)\n\twhile(tmp % 2 == 0):\n\t\ttmp = tmp // 2\ni = 3\nwhile (i * i <= tmp):\n\tif (tmp % i == 0):\n\t\tfac.append(i)\n\t\twhile(tmp % i == 0):\n\t\t\ttmp = tmp // i\n\ti += 2\n\nif (tmp > 2):\n\tfac.append(tmp)\nans = 1\nfor p in fac:\n\tprod = p\n\ti = 1\n\tfin = 0\n\twhile (prod <= n):\n\t\ttimes = (n // prod) - (n // (prod * p))\n\t\tfin += (i * times)\n\t\tprod *= p\n\t\ti += 1\n\tans = (ans * binpow(p, fin, MOD)) % MOD\nprint(ans)\n", "import math\n\nX, N = map(int, input().split())\n\ndef prime(n):\n    factor = {}\n    tmp = int(math.sqrt(n)) + 1\n    for num in range(2, tmp):\n        while n % num == 0:\n            n //= num\n            if not num in factor.keys():\n                factor[num] = 1\n            else:\n                factor[num] += 1\n    if n != 1:\n        if not n in factor.keys():\n            factor[n] = 1\n        else:\n            factor[n] += 1\n    return factor\n\ndef power_func(a,n,p):\n    bi=str(format(n,\"b\"))#2\u9032\u8868\u73fe\u306b\n    res=1\n    for i in range(len(bi)):\n        res=(res*res) %p\n        if bi[i]==\"1\":\n            res=(res*a) %p\n    return res\n\ndef main():\n    NUM = {}\n    for num in prime(X).keys():\n        a = N\n        c = 0\n        while a > 0:\n            a //= num\n            c += a\n        NUM[num] = c\n\n    mod = int(1E9+7)\n    ans = 1\n    for num, c in NUM.items():\n        ans = (ans * power_func(num, c, mod)) % mod\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import chain\nfrom math import sqrt\n\nub = 10**5\nub_sqrt = int(sqrt(ub))+1\nprimes = {2, 3} | set(chain(list(range(5, ub, 6)), list(range(7, ub, 6))))\ndu = primes.difference_update\nfor n in chain(list(range(5, ub_sqrt, 6)), list(range(7, ub_sqrt, 6))):\n    if n in primes:\n        du(list(range(n*3, ub, n*2)))\n\n\nx, n = list(map(int, input().split()))\ndivisors = []\nfor p in primes:\n    if x % p == 0:\n        divisors.append(p)\n        while x % p == 0:\n            x //= p\nif x > 1:\n    divisors.append(x)\n\nans = 1\nmod = 10**9+7\n\nfor d in divisors:\n    cur = d\n    while cur <= n:\n        ans = ans * pow(d, n//cur, mod) % mod\n        cur *= d\n\nprint(ans)\n", "#589_C\n\n#import time\n\n#start = time.time()\n\nimport math\n\nmd = (10 ** 9) + 7\n\ndef bin(n):\n    l = math.floor(math.log(n, 2))\n    s = \"\"\n    while l >= 0:\n        if n >= 2 ** l:\n            n -= 2 ** l\n            s += \"1\"\n        else:\n            s += \"0\"\n        l -= 1\n    return s\n\ndef ex(n, m):\n    bn = bin(m)\n    sm = n\n    sms = []\n    ssm = 1\n    for i in range(len(bn) - 1, -1, -1):\n        if bn[i] == \"1\":\n            ssm = (ssm * sm) % md\n        sm = (sm * sm) % md\n    return ssm\n\nln = [int(i) for i in input().split(\" \")]\nx = ln[0]\nn = ln[1]\n\ndiv = []\n\ndef pf(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return [i] + pf(n // i)\n    return [n]\n\ndv = pf(x)\n\ndv = sorted(dv)\n\nndv = [[dv[0], 1]]\n\nfor i in range(1, len(dv)):\n    if dv[i] != dv[i - 1]:\n        ndv.append([dv[i], 1])\n    else:\n        ndv[-1][1] += 1\n\nsm = 1\nfor i in range(0, len(ndv)):\n    nm = math.floor(math.log(n, ndv[i][0])) + 1\n    for j in range(1, nm + 1):\n        fs = n // (ndv[i][0] ** j)\n        if fs == 0:\n            continue\n        nm = ndv[i][0]\n\n        nn = ex(nm, fs)\n\n        sm = (sm * nn) % md\n        #print(sm, i)\nprint(sm)\n", "\nimport math\nn,m=[int(x) for x in input().split()]\na=[]\nfor i in range(2, int(math.sqrt(n)) + 1): \n    while (n % i == 0): \n        a.append(i)\n        while(n%i==0):\n          n//= i \nif (n != 1): \n    a.append(n)\nans=1\nfor i in a:\n  k=i\n  while(m>=k):\n    ans*=pow(i,m//k,1000000007)\n    ans%=1000000007\n    k*=i\nprint(ans%1000000007)\n", "x, n = input().split(' ')\nx, n = int(x), int(n)\n\nprimes = []\n\nfor i in range(2, 100000):\n    if x % i == 0:\n        primes.append(i);\n        while x % i == 0:\n            x = x // i\n\nif x != 1:\n    primes.append(x)\n\nresult_list = []\nMOD = 1000000007\n\nfor p in primes:\n    result = 0\n    pk = p\n    while pk <= n:\n        result += n // pk\n        pk *= p\n    result_list.append((result, p))\n\n\ndef power (a, b):\n    nonlocal MOD\n    if b == 0:\n        return 1\n    r = 1\n    ak = a\n    while b > 0:\n        if b % 2 == 1:\n            r *= ak\n        b = b // 2\n        ak *= ak\n        ak %= MOD\n        r %= MOD\n    return r\n\n\nresult = 1\nfor r, p in result_list:\n    result *= power (p, r)\n    result %= MOD\n\n\nprint (result)\n\n\n\n", "import math\n\nx, n = map(int, input().split())\n\nmaxPrime = int(math.sqrt(x) + 1)\n\nisPrime = [True] * maxPrime\n\nprimes = []\n\nfor i in range(2, maxPrime):\n  if(x % i == 0):\n    primes.append(i)\n\n  while (x % i) == 0:\n    x = x // i\n\nif(x > 1):\n  primes.append(x)\n\nsol = 1\n\ndef quickPow(x, power):\n  if(power == 1):\n    return x\n  \n  ans = quickPow(x , power // 2)\n  \n  ans *= ans\n\n  if(power % 2) == 1:\n    ans *= x\n  \n  return ans % 1000000007\n  \n\nfor prime in primes:\n  i = prime\n\n  while(i <= n):\n    sol = (sol * quickPow(prime % 1000000007, (n // i))) % 1000000007\n    i *= prime\n\nprint(sol)", "# MOD = 10**180\nMOD = 1000000007\n\nx, n = map(int, input().split())\n\ndef po(n, p):\n\tif p == 0: return 1\n\tif p == 1: return n % MOD\n\tp2 = p//2\n\tif p % 2 == 0: return (po(n, p2)**2) % MOD\n\telse: return (n * po(n, p2)**2) % MOD\n\ndef f(s, x, n):\n\tif x == 1: return 1\n\tsx = int(x**0.5)\n\tfor p in range(s, sx+1):\n\t\tif x % p == 0:\n\t\t\twhile x % p == 0:\n\t\t\t\tx //= p\n\t\t\tres = f(p+1, x, n)\n\t\t\tm = 0\n\t\t\tpp = p\n\t\t\twhile n // pp > 0:\n\t\t\t\tm = (m + n // pp)\n\t\t\t\tpp *= p\n\t\t\tpm = po(p, m)\n\t\t\tres = (res*pm) % MOD\n\t\t\treturn res\n\tm = 0\n\tpp = x\n\twhile n // pp > 0:\n\t\tm = (m + n // pp)\n\t\tpp *= x\n\treturn po(x, m) % MOD\n\nres = f(2, x, n)\nprint(res)", "MOD = int(1e9 + 7)\n\ndef log_power(base, exp):\n    if exp == 0:\n        return 1\n    elif exp == 1:\n        return base % MOD\n\n    if exp % 2 == 1:\n        return base * log_power(base, exp - 1) % MOD\n\n    root = log_power(base, exp // 2)\n    return root * root % MOD\n\n\ndef total(fact, limit):\n    prod = 1\n    power = fact\n\n    while power <= limit:\n        prod = prod * log_power(fact, limit // power) % MOD\n        prod %= MOD\n        power *= fact\n\n    return prod\n\n\ndef solve(num, limit):\n    fact = 2\n    prod = 1\n\n    while fact * fact <= num:\n        count = 0\n        while num % fact == 0:\n            num //= fact\n            count += 1\n\n        if count > 0:\n            prod = (prod * total(fact, limit)) % MOD\n        fact += 1\n\n    if num > 1:\n        prod = (prod * total(num, limit)) % MOD\n\n    return prod\n\n\ndef __starting_point():\n    num, limit = list(map(int, input().split()))\n    print(solve(num, limit))\n\n__starting_point()", "x,n=list(map(int,input().split()))\nprimes=[]\ni=2\nwhile i*i<=x:\n    if x%i==0:\n        primes.append(i)\n    while x%i==0:\n        x//=i\n    i+=1\nif x>1:\n    primes.append(x)\nmod=1000000007\nans=1\nfor i in range(len(primes)):\n    prod=primes[i]\n    while prod<=n:\n        ans*=pow(prod,n//prod-n//(prod*primes[i]),mod);\n        ans%=mod\n        prod*=primes[i]\nprint(ans)\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval, stdin, setrecursionlimit\nsetcheckinterval(1000)\nsetrecursionlimit(10**7)\n \n# print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n \n \ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\nx,n=lin()\nmd=10**9+7\ndef factors(a):\n    fact = []\n    if a % 2 == 0:\n        while a % 2 == 0:\n            a //= 2\n        fact.append(2)\n    i = 3\n    while i*i <= a:\n        if a % i == 0:\n            while a % i == 0:\n                a //= i\n            fact.append(i)\n        i += 2\n    if a > 1:\n        fact.append(a)\n    return fact\n\nfact=factors(x)\nans=1\nfor f in fact:\n    x=f\n    ch=0\n    while x<=n:\n        ch+=n//x\n        x*=f\n    ans=ans*pow(f,ch,md)\n    ans%=md  \nans=ans%md\nprint(ans)", "from math import floor,sqrt\ndef pp(a,b,c):\n\tr = 1\n\ta%=c\n\twhile(b):\n\t\tif b&1:\n\t\t\tr = (r*a) % c\n\t\tb>>=1\n\t\ta=(a*a)%c\n\treturn r\n\nn,x=[int(i)for i in input().split()]\nd=n\nl=[]\nh=floor(sqrt(d))\nMOD = (1000000007)\nif(d%2==0):\n\tl+=[2];\n\twhile d%2==0:d//=2;\nfor i in range(3,h+1,2):\n\tif(d%i==0):\n\t\tl+=[i]\n\twhile(d%i==0):d//=i;\n\nif d > 2: l+=[d]\nans = 1\nfor i in l:\n\tf = i\n\ts = 0\n\twhile f <= x:\n\t\ts += x//f\n\t\tf *= i\n\tans = (ans*pp(i,s,MOD))% MOD \nprint(ans)", "import heapq\nfrom collections import defaultdict\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nX, Y = list(map(int, input().split()))\n\n\ndef primeFact_set(n):\n    factors = set()\n    i = 2\n    while i*i <= n:\n        if n % i == 0:\n            n //= i\n            if i <= Y:\n                factors.add(i)\n        else:\n            i += 1\n    if n > 1 and n <= Y:\n        factors.add(n)\n    return factors\n\n\nX_prime = primeFact_set(X)\nMOD = 10**9+7\nans = 1\nfor p in X_prime:\n    tmp = p\n    while tmp <= Y:\n        div = Y//tmp\n        ans *= pow(p, div, MOD)\n        ans %= MOD\n        tmp *= p\nprint(ans)\n", "def factor(x):\n    r = set()\n    if x % 2 == 0:\n        r.add(2)\n    while x % 2 == 0:\n        x //= 2\n    for i in range(3, int(x ** .5 + 2), 2):\n        if x % i == 0:\n            r.add(i)\n        while x % i == 0:\n            x //= i\n    if x != 1:\n        r.add(x)\n    return r\na, n = list(map(int, input().split()))\ns = factor(a)\nsol = 1\nfor i in s:\n    t = i % 1000000007\n    m = i\n    while m <= n:\n        sol = (sol * pow(t, n // m, 1000000007)) % 1000000007\n        m = m*i\nprint(sol)\n", "M = 10**9+7\nx, n = list(map(int,input().split()))\nimport math\ndef primeFactors(n):\n\tprimes = set()\n\twhile n%2 == 0:\n\t\tprimes.add(2)\n\t\tn//=2\n\tfor i in range(3,int(math.sqrt(n))+1,2):\n\t\twhile(n%i==0):\n\t\t\tprimes.add(i)\n\t\t\tn//=i\n\tif(n>2):\n\t\tprimes.add(n)\n\treturn primes\ndef modexp( x, y, p ):\n\tres = 1\n\twhile(y>0):\n\t\tif(y & 1):\n\t\t\tres*= x\n\t\t\tres%=p\n\t\ty >>= 1\n\t\tx%=p\n\t\tx*= x\n\n\n\treturn res%p\n\nprimes = primeFactors(x)\nans = 1\nfor p in primes:\n\tcnt = 0;\n\talphap = 1\n\taux = n\n\twhile(n/(p**alphap)>0):\n\t\tcnt += n//(p**alphap)\n\t\talphap+=1\n\t\n\tcnt = cnt%(M-1)\n\tans*= modexp(p,cnt,M)\n\tans%=M\n\t\n\nprint(ans%M)\n"]
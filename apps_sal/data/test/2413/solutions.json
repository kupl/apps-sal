["# Contest: Codeforces Round #592 (Div. 2) (https://codeforces.com/contest/1244)\n# Problem: B: Rooms and Staircases (https://codeforces.com/contest/1244/problem/B)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nt = rint()\nfor _ in range(t):\n    n = rint()\n    s = input()\n    mx = n\n    for i in range(n):\n        if s[i] == '0':\n            continue\n        mx = max(mx, 2 * max(i + 1, n - i))\n    print(mx)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def solve():\n        n = int(input())\n        s = input()\n        l, r = -1, -1\n        for i in range(n):\n            if s[i] == '1':\n                if l == -1:\n                    l = i\n                r = i\n        \n        if l == -1:\n            print(n)\n        else:\n            print(2 * max(r + 1, n - l))\n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()\n", "t = int(input())\nfor _ in range(t) :\n    n = int(input())\n    s = input()\n    x = [i for i in range(n) if s[i] == '1']\n    if len(x) == 0 :\n        print(n)\n    else :\n        print( max( max(i+1+i+1, n-i+n-i) for i in x ) )\n", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    if s == '0' * n:\n        print(n)\n    else:\n        print(max(n - s.index('1'), s.rindex('1') + 1) * 2)\n", "q = int(input())\nfor _ in range(q):\n    n = int(input())\n    s = input()\n    min_pos = -1\n    max_pos = -1\n    for i in range(n):\n        if s[i] == \"1\":\n            max_pos = i\n    for i in range(n)[::-1]:\n        if s[i] == \"1\":\n            min_pos = i\n    if min_pos == -1:\n        print(n)\n    else:\n        print(max(2*(max_pos + 1), 2*(n - min_pos)))", "def solve():\n    n = int(input())\n    s = input()\n    mn = mx = None\n    for i in range(n):\n        if s[i] == '0':\n            continue\n        if mn is None or mn > i:\n            mn = i\n        if mx is None or mx < i:\n            mx = i\n    ans = n\n    if mn is not None:\n        ans = max(ans, (n - mn) * 2)\n    if mx is not None:\n        ans = max(ans, (1 + mx) * 2)\n    print(ans)\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n\nmain()\n", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = list(input())\n    ans = n\n    for i in range(n):\n        if s[i] == \"1\":\n            if i >= n // 2:\n                ans = max(ans, 2 * (i + 1))\n            else:\n                ans = max(ans, (n - i) * 2)\n    print(ans)", "t=int(input())\nfor i in range(t):\n    n=int(input())\n    s=input()\n    ma = n\n    st=-1\n    f=-1\n    for j in range(n):\n        if s[j]=='1':\n            st=j\n            break\n    for j in range(n-1, -1, -1):\n        if s[j]=='1':\n            f = j\n            break\n    if f!=-1:\n        ma=max(ma, (f+1)*2)\n        ma=max(ma, (n-st)*2)\n    print(ma)\n", "t = int(input())\n\nfor _ in range(t):\n\tn = int(input())\n\ts = input()\n\tif not \"1\" in s:\n\t\tprint(n)\n\t\tcontinue\n\n\tfirst = s.index(\"1\")\n\n\tposs1 = 2 * (n-first)\n\n\tlast = s[::-1].index(\"1\")\n\tposs2 = 2 * (n-last)\n\n\tprint(max(poss1, poss2))", "for t in range(int(input())):\n    n = int(input())\n    st = input()\n    ans = n\n    if \"1\" in st:\n        ans = max(ans, (n - st.find(\"1\")) * 2, (st.rfind(\"1\") + 1) * 2)\n        ans = max(ans, n + st.count(\"1\"))\n    print(ans)", "t = int(input())\n\nfor qwe in range(t):\n\tn = int(input())\n\ts = input()\n\ta = [i + 1 for i in range(len(s)) if s[i] == '1']\n\tif (a == []):\n\t\tprint(n)\n\t\tcontinue\n\t\n\tmx = a[-1]\n\tmn = a[0]\n\tans = max(mx, n - mn + 1) * 2\n\tprint(ans)", "for _ in range(int(input())):\n    n = int(input())\n    u = list(map(int, list(input())))\n    if u[:] == [0] * n:\n        print(n)\n        continue\n    a = -1; b = -1\n    for i in range(n):\n        if u[i] == 1:\n            a = i\n            break\n    for i in range(n - 1, -1, -1):\n        if u[i] == 1:\n            b = i\n            break\n    print(max((n - a) * 2, (b + 1) * 2, n))\n", "a = int(input())\nfor i in range(a):\n    b = int(input())\n    c = input()\n    l = c.find('1')\n    r = c.rfind('1')\n    if l == -1:\n        print(b)\n    else:\n        k1 = r + 1\n        k2 = b - l\n        print(max(k1, k2)*2)", "for _ in range(int(input())):\n    n = int(input())\n    res = n\n    cur = 0\n    for i, c in enumerate(input()):\n        if c == '1':\n            x = i + 1\n            y = n - x + 1\n            res = max(res, 2 * x, n + 1, 2 * y)\n            cur += 2\n        else:\n            cur += 1\n    print(max(cur, res))", "for i in range(int(input())):\n    N = int(input())\n    X = input()\n    First, Last = 0, 0\n    Rooms = 0\n    if '1' in X:\n        First, Last = X.index('1'), X[::-1].index('1')\n        First = N - First\n        Last = N - Last\n        print(max(First, Last) * 2)\n    else:\n        print(N)\n# Caption: Contest Time\n", "\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n\n    l = s.find(\"1\")\n    r = n-1-s.rfind(\"1\")\n\n    if l < 0:\n        print(n)\n    else:\n        mn = min(l, r)\n        print((n-mn) * 2)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li = list(stdin.readline().strip())\n    x = 10**10\n    for i, ele in enumerate(li):\n        if ele=='1':\n            x = min(n-i-1, i, x)\n    if x==10**10:\n        print(n)\n    else:\n        print(2*(n-x))\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "for rpt in range(int(input())):\n    n = int(input())\n    layout = input()\n    if layout == n * '0':\n        print(n)\n    else:\n        left = 0\n        while layout[left] == '0':\n            left += 1\n        right = n - 1\n        while layout[right] == '0':\n            right -= 1\n        print(2 * max(n - left, right + 1))\n", "def solve(a):\n    left0 = 0\n    right0 = 0\n    if '1' not in a:\n        return len(a)\n    for i in a:\n        if i == '0':\n            left0 += 1\n        else:\n            break\n    for i in a[::-1]:\n        if i == '0':\n            right0 += 1\n        else:\n            break\n    return len(a) * 2 - min(left0, right0) * 2\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        _ = int(input())\n        a = input()\n        print(solve(a))\n\n\nmain()\n", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    fs = s.find('1')\n    ans = (n-fs)*2\n    sc = s.rfind('1')\n    ans = max((sc+1)*2,ans)\n    print(ans if fs != -1 else n)\n", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    string = input()\n    total = 0\n    for c in string:\n        if c == '0':\n            total += 1\n        elif c == '1':\n            total += 2\n    l = len(string.lstrip('0'))\n    r = len(string.rstrip('0'))\n    total = max(total, 2 * l, 2 * r)\n    print(total)\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10**7)\n\n\ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\n\n# range = xrange\n# input = raw_input\ndef main():\n    for _ in range(iin()):\n        n=iin()\n        a=input()\n        occ=[]\n        ch=0\n        for i in a:\n            ch+=1\n            if i=='1':\n                occ.append(ch)\n        ans=n\n        if occ:\n            mx,mn=occ[-1],occ[0]\n            ans=max(ans,max(n-mx+1,mx)*2,max(n-mn+1,mn)*2)\n        print(ans)\n\ntry:\n    main()\nexcept Exception as e: print(e)", "t = int(input())\n\nfor i in range(t):\n  n = int(input())\n  s = input()\n  mnj = s.find('1')\n  mxj = s.rfind('1')\n  if mnj == -1:\n    print(n)\n  else:\n    print( max(n - mnj, mxj + 1) * 2 )\n", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nfor testcases in range(t):\n    n=int(input())\n    S=input().strip()\n\n    ANS=n\n\n    if \"1\" in S:\n        t=S.index(\"1\")\n        ANS=max(ANS,(n-t)*2)\n\n        #print(t)\n\n        t=S[::-1].index(\"1\")\n        ANS=max(ANS,(n-t)*2)\n\n        #print(t)\n\n    print(ANS)\n"]
["\"\"\"\n\tAuthor\t\t: Arif Ahmad\n\tDate  \t\t: \n\tAlgo  \t\t: \n\tDifficulty\t: \n\"\"\"\nfrom sys import stdin, stdout\nfrom collections import deque\n\ng = None # contains the actual graph\nh = None # h[x][y] represents the component in which cell (x,y) belongs\nr = None\nc = None\nvisited = None\ntotal = None\ncomp = None\ndx = [-1, 0, 0, 1]\ndy = [0, -1, 1, 0]\n\n\ndef bfs(x, y):\n\tnonlocal total\n\t\n\tq = deque([(x, y)])\n\ttotal += 1\n\tvisited[x][y] = True\n\th[x][y] = comp\n\twhile q:\n\t\tx, y = q.pop()\n\t\t#print('comp:', comp, 'cell:', x, y)\n\t\tfor k in range(4):\n\t\t\t#print('loop:', k)\n\t\t\tnx = x + dx[k]\n\t\t\tny = y + dy[k]\n\t\t\t#print(visited)\n\t\t\t#print('new cell:', nx, ny, 'check:', nx>=0 , nx<r , ny>=0 , ny<c , visited[nx][ny]==False , g[nx][ny]=='.')\n\t\t\tif nx>=0 and nx<r and ny>=0 and ny<c and visited[nx][ny]==False and g[nx][ny]=='.':\n\t\t\t\tq.appendleft((nx, ny))\n\t\t\t\ttotal += 1\n\t\t\t\tvisited[nx][ny] = True\n\t\t\t\th[nx][ny] = comp\n\n\ndef main():\n\tnonlocal g, h, r, c, visited, comp, total\n\n\tr, c = [int(_) for _ in stdin.readline().split()]\n\n\tg = []\n\tfor i in range(r):\n\t\tline = stdin.readline()\n\t\tg.append(list(line))\n\n\tcomponent = []\n\th = [[-1 for i in range(c)] for j in range(r)]\n\tvisited = [[False for i in range(c)] for j in range(r)]\n\t#print(visited)\n\n\tfor i in range(r):\n\t\tfor j in range(c):\n\t\t\tif visited[i][j] == False and g[i][j] == '.':\n\t\t\t\tcomp = len(component)\n\t\t\t\ttotal = 0\n\t\t\t\t#print('calling bfs', i, j)\n\t\t\t\tbfs(i, j)\n\t\t\t\tcomponent.append(total)\n\n\tfor x in range(r):\n\t\tfor y in range(c):\n\t\t\tif g[x][y] == '*':\n\t\t\t\tans = 0\n\t\t\t\tidx = set()\n\t\t\t\tfor k in range(4):\n\t\t\t\t\tnx = x + dx[k]\n\t\t\t\t\tny = y + dy[k]\n\t\t\t\t\tif nx>=0 and nx<r and ny>=0 and ny<c and g[nx][ny]=='.':\n\t\t\t\t\t\tidx.add(h[nx][ny])\n\t\t\t\tfor item in idx:\n\t\t\t\t\t#print(component[item])\n\t\t\t\t\tans += component[item]\n\t\t\t\tans += 1\n\t\t\t\tans %= 10\n\t\t\t\tg[x][y] = str(ans)\n\n\t#print(component)\n\tfor i in range(r):\n\t\tstdout.write(''.join(g[i]))\n\n\t\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# n=int(input())\n# n,k=map(int,input().split())\n# arr=list(map(int,input().split()))\n#ls=list(map(int,input().split()))\n#for i in range(m):\n# for _ in range(int(input())):\nfrom collections import Counter\n#from fractions import Fraction\n#n=int(input())\n#arr=list(map(int,input().split()))\n#ls = [list(map(int, input().split())) for i in range(n)]\nfrom math import log2\n#for _ in range(int(input())):\n#n, m = map(int, input().split())\n# for _ in range(int(input())):\nfrom math import gcd\n#n=int(input())\n# for i in range(m):\n# for i in range(int(input())):\n# n,k= map(int, input().split())\n# arr=list(map(int,input().split()))\n# n=sys.stdin.readline()\n# n=int(n)\n# n,k= map(int, input().split())\n# arr=list(map(int,input().split()))\n# n=int(inaput())\n#for _ in range(int(input())):\n#arr=list(map(int,input().split()))\nfrom collections import  deque\ndx=[-1,0,0,1]\ndy=[0,-1,1,0]\n\ndef bfs(x,y):\n\tnonlocal total\n\ttotal+=1\n\tq=deque([(x,y)])\n\tv[x][y]=True\n\th[x][y]=comp\n\t#q.append()\n\twhile q:\n\t\tx,y=q.pop()\n\t\tfor i in range(4):\n\t\t\tnx=x+dx[i]\n\t\t\tny=y+dy[i]\n\t\t\t#print(\"nx,y\",nx, ny)\n\t\t\tif (nx>=0 and nx<n) and (ny>=0 and ny<m) and (v[nx][ny]==False) and (g[nx][ny]==\".\"):\n\t\t\t\tq.appendleft((nx,ny))\n\t\t\t\ttotal+=1\n\t\t\t\tv[nx][ny]=True\n\t\t\t\th[nx][ny]=comp\n\n#nonlocal g,h,r,comp,total\nn, m = list(map(int, input().split()))\nh=[[-1 for i in range(m)] for j in range(n)]\ng=[]\nv=[[False for i in range(m)]for j in range(n)]\nfor i in range(n):\n\tg.append(list(input()))\ncomponent=[]\nfor i in range(n):\n\tfor j in range(m):\n\t\tif v[i][j]==False and g[i][j]==\".\":############\n\t\t\tcomp=len(component)\n\t\t\t#nonlocal total\n\t\t\ttotal=0\n\t\t\tbfs(i,j)\n\t\t\tcomponent.append(total)\n#print(component)\nfor x in range(n):\n\tfor y in range(m):\n\t\tif g[x][y] == \"*\":\n\t\t\tans = 0\n\t\t\ts = set()\n\t\t\tfor k in range(4):\n\t\t\t\tnx = x + dx[k]\n\t\t\t\tny = y + dy[k]\n\t\t\t\tif nx >= 0 and nx < n and ny >= 0 and ny < m and g[nx][ny] == \".\":\n\t\t\t\t\ts.add(h[nx][ny])\n\t\t\tfor itm in s:\n\t\t\t\tans += component[itm]\n\t\t\tans += 1\n\t\t\tans %= 10\n\t\t\tg[x][y] = str(ans)\nfor i in range(n):\n\tprint(\"\".join(g[i]))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n\n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n\n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n\n            self.num_sets -= 1\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\nl = []\nfor i in range(n):\n    l.append(input().strip())\n\nUF = DisjointSetUnion(n * m)\nfor i in range(n):\n    for j in range(m):\n        if i < n - 1:\n            if l[i][j] == '.' and l[i+1][j] == '.':\n                UF.union(m * i + j, m * i + m + j)\n        if j < m - 1:\n            if l[i][j] == '.' and l[i][j+1] =='.':\n                UF.union(m * i + j, m * i + j + 1)\n\nout = []\nfor i in range(n):\n    curr = []\n    for j in range(m):\n        if l[i][j] == '.':\n            curr.append('.')\n        else:\n            dx = [0,0,-1,1]\n            dy = [-1,1,0,0]\n            adj = set()\n            for d in range(4):\n                nx = i + dx[d]\n                ny = j + dy[d]\n                if 0 <= nx < n and 0 <= ny < m and l[nx][ny] == '.':\n                    adj.add(UF.find(m * nx + ny))\n                    \n            outV = 1\n            for v in adj:\n                outV += UF.set_size(v)\n            curr.append(str(outV % 10))\n    out.append(''.join(curr))\nprint('\\n'.join(out))\n                \n    \n", "from sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= (ans%10 + 1%10) % 10\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nl=[st() for i in range(n)]\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n                        \n                \n            \n", "from sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= ans+1\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nl=[st() for i in range(n)]\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n                        \n                \n            \n", "from sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= ans+1\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nl=[st() for i in range(n)]\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if len(l[newX][newY])==2:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n                        \n                \n            \n", "from sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= ans+1\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nl=[st() for i in range(n)]\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n\n", "from sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= ans+1\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nl=[st() for i in range(n)]\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if 0<=newX<n and 0<=newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n\n"]
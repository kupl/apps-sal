["def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\na = li()\ns = input().strip()\n\nans = 0\ni = 0\nwhile i < n:\n    j = i + 1\n    while j < n and s[j] == s[i]:\n        j += 1\n    b = sorted(a[i:j])\n    ans += sum(b[-k:])\n    i = j\nprint(ans)\n", "n,k = [int(x) for x in input().split()]\n\nL = [int(x) for x in input().split()]\n\ns = input()\n\ntemp = [1,0,0]\nR = []\nfor i in range(n-1):\n    if s[i+1] == s[i]:\n        temp[0] += 1\n    else:\n        temp[-1] = i\n        R.append(temp)\n        temp = [1,i+1,i+1]\n        \ntemp[-1] = n-1\nR.append(temp)\nDam = 0\nfor i in R:\n    if i[0] > k:\n        q = L[i[1]:i[2]+1]\n        q.sort(reverse = True)\n        t = 0\n        for i in range(k):\n            t += q[i]\n        Dam += t\n    else:\n        Dam += sum(L[i[1]:i[2]+1])\n\nprint(Dam)\n", "def get():\n    return list(map(int,input().split()))\nn,k=get()\na=list(get())\ns=input()\ni=0\ndmg=0\nwhile i<n:\n    j=i+1\n    while j<n and s[i]==s[j]:\n        j+=1\n    j-=1\n    if j-i+1<=k:\n        dmg+=sum(a[i:j+1])\n    else:\n        g=a[i:j+1]\n        g.sort()\n        dmg+=sum(g[len(g)-k:])\n    i=j+1\nprint(dmg)\n", "n,k = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\nA.append(-1)\ns = input()+'$'\n\ndmg = 0\nlc = None\ncount = 0\natk = []\nfor i in range(n+1):\n    c = s[i]\n    a = A[i]\n\n    if c != lc:\n        if lc:\n            dmg += sum(sorted(atk)[-k:])\n        count = 0\n        atk = []\n    count += 1\n    lc = c\n    atk.append(a)\nprint(dmg)\n", "n,k = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\nA.append(-1)\ns = input()+'$'\n\ndmg = 0\nlc = None\ncount = 0\natk = []\nfor i in range(n+1):\n    c = s[i]\n    a = A[i]\n\n    if c != lc:\n        if lc:\n            dmg += sum(sorted(atk)[-k:])\n        count = 0\n        atk = []\n    count += 1\n    lc = c\n    atk.append(a)\nprint(dmg)\n", "import re, math, decimal, bisect, collections\ndef read(): return input().strip()\ndef iread(): return int(input().strip())\ndef viread(): return [int(_) for _ in input().strip().split()]\n\nn, k = viread()\nd = viread()\ns = list(read())\nprocessed = 0\ndamage = 0\nwhile (processed < n):\n    damages = []\n    c = s[processed]\n    damages.append(d[processed])\n    processed += 1\n    while (processed < n and s[processed] == c):\n        damages.append(d[processed])\n        processed += 1\n    if len(damages) > k:\n        damages.sort()\n        damage += sum(damages[len(damages) - k:])\n    else:\n        damage += sum(damages)\nprint(damage)", "n, k = list(map(int, input().split()))\nX = [int(a) for a in input().split()]\ns = input()\n\ni = 1\np = s[0]\nl = [X[0]]\nc = 1\nans = 0\nwhile i <= n:\n    if i < n and p == s[i]:\n        l.append(X[i])\n        c += 1\n    else:\n        if len(l) <= k:\n            ans += sum(l)\n        else:\n            l = sorted(l)\n            ans += sum(l[-k:])\n\n        if i == n:\n            break\n            \n        l = [X[i]]\n        p = s[i]\n        c = 1\n    \n    \n    i += 1\nprint(ans)\n", "n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\ns=list(input())\ni=0\nsth=[]\nsts=[]\nans=0\nwhile i<n:\n    if len(sts)==0 or sts[-1]==s[i]:\n        sts.append(s[i])\n        sth.append(a[i])\n        i+=1\n    else:\n        sts=[]\n        sth.sort(reverse=True)\n        ans+=sum(sth[:min(k,len(sth))])\n        sth=[]\nsth.sort(reverse=True)\nans+=sum(sth[:min(k,len(sth))])\nsth=[]\nprint(ans)\n        \n        \n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    try:\n        f = open('input'+ str(inId) + '.txt', 'r')\n        sys.stdin = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid input file')\nif outId>0:\n    dprint('use output', outId)\n    try:\n        f = open('stdout'+ str(outId) + '.txt', 'w')\n        sys.stdout = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid output file')\n        \n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, K = getIntList()\n#print(N)\nza  = getIntList()\nS = input()\nzz = []\nlc = ' '\nfor i in range(N):\n    if S[i] == lc:\n        zz[-1].append(za[i])\n    else:\n        lc = S[i]\n        zz.append( [za[i], ])\nr = 0\nfor x in zz:\n    x.sort(reverse = True)\n    r += sum(x[:K])\nprint(r)\n\n\n\n\n\n", "import math\nimport bisect\nimport itertools\nimport sys\nI=lambda : sys.stdin.readline()\nmod=10**9 +7\n'''fact=[1]*100001\nifact=[1]*100001\nfor i in range(1,100001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n    \ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\n    \ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2   \n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n    \ndef is_prime(num):\n    if num == 1: return False\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n    \n  \ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n    \ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s    \n    \ndef modu(a,n):\n    if a%n==0:\n        return n\n    return a%n\n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfor i in range(1):\n    n,k=map(int,input().split())\n    a=list(map(int,input().split()))\n    s=input()\n    c=1;b=[]\n    for i in range(1,n):\n        if s[i-1]==s[i]:\n            c+=1\n            f=True\n        else:\n            b.append(c)\n            c=1\n            f=False\n    if True:\n        b.append(c)\n    #print(b) \n    ans=0\n    su=0\n    for i in b:\n        c=a[su:min(su+i,10**9)]\n        \n        #print(c)\n        \n        \n        c.sort(reverse=True)\n        c=c[:min(i,k)]\n        su+=i\n        ans+=sum(c)\n        \n    print(ans)", "n, k =list(map(int, input().split()))\na = list(map(int, input().split()))\nst = input()\npr = None\ncl = 0\nans = 0\nvs = []\nfor i, s in enumerate(st):\n    if s == pr:\n        cl +=1\n        vs.append(a[i])\n        pr=s\n    elif pr is not None:\n        vs.sort(reverse=True)\n        ans += sum(vs[:k])\n\n        pr = s\n        cl = 1\n        vs = [a[i],]\n    else:\n        pr = s\n        cl +=1\n        vs.append(a[i])\nvs.sort(reverse=True)\nans += sum(vs[:k])\nprint(ans)\n\n", "def sumn(l, r):\n    nonlocal dmgs\n    tmp = []\n    for i in range(l, r + 1):\n        tmp.append(dmgs[i])\n    tmp.sort(reverse=True)\n    return sum(tmp[:k])\n    \n\nn, k = map(int, input().split())\ndmgs = [int(x) for x in input().split()]\ns = input()\nd = {}\nkey = 'abcdefghijklnmopqrstuvwxyz'\nl = 0\nr = 0\ntotal = 0\nfor i in range(len(s) - 1):\n    if s[i] != s[i + 1]:\n        r = i\n        total += sumn(l, r)\n        l = i + 1\ntotal += sumn(l, n - 1)\nprint(total)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/26 23:58\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Brutality.py\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    s = input()\n\n    ret = p1 = 0\n    while p1 < n:\n        p2, temp = p1, []\n        while p2 < n and s[p2] == s[p1]:\n            temp.append(a[p2])\n            p2 += 1\n\n        temp.sort(reverse=True)\n        ret += sum(temp[:k])\n        p1 = p2\n\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn,k=map(int,input().split())\n\nl=list(map(int,input().split()))\n\ns=input()\ns+=\"*\"\n\nsumm=sum(l)\nl.append(999999999999)\n\ncount=1\ntemp=[l[0]]\nfor i in range(n):\n\t#print(temp)\n\tif s[i]==s[i+1]:\n\t\tcount+=1\n\t\ttemp.append(l[i+1])\n\telse:\n\t\tif count>k:\n\t\t\ttemp.sort()\n\t\t\tfor j in range(count-k):\n\t\t\t\tsumm-=temp[j]\n\t\ttemp=[l[i+1]]\n\t\tcount=1\n\nprint(summ)", "n,k = map(int,input().split())\na = list(map(int,input().split()))\ns = input()\nans = 0\nnow = []\nnow.append(a[0])\nfor i in range(1,n):\n        if s[i]  == s[i-1]:\n                now.append(a[i])\n        else:\n                if len(now) > k:\n                        now.sort(key=lambda x:-x)\n                        ans += sum(now[:k])\n                else:\n                        ans += sum(now)\n                now = [a[i]]\nif len(now) > k:\n        now.sort(key=lambda x:-x)\n        ans += sum(now[:k])\nelse:\n        ans += sum(now)\nnow = []\nprint(ans)", "import copy\nimport fractions\nimport itertools\nimport string\nimport sys\n\n###\n\ndef powmod(x, p, m):\n\tif p <= 0:\n\t\treturn 1\n\tif p <= 1:\n\t\treturn x%m\n\treturn powmod(x*x%m, p//2, m) * (x%m)**(p%2) % m\n\n###\n\ndef to_basex(num, x):\n\twhile num > 0:\n\t\tyield num % x\n\t\tnum //= x\n\ndef from_basex(it, x):\n\tret = 0\n\tp = 1\n\tfor d in it:\n\t\tret += d*p\n\t\tp *= x\n\treturn ret\n\n###\n\ndef core():\n\tn, k = [int(x) for x in input().split()]\n\ta = [int(x) for x in input().split()]\n\ts = input()\n\t\n\tgroups = []\n\tlast_ch = None\n\tfor i in range(len(s)):\n\t\tch = s[i]\n\t\tif ch != last_ch:\n\t\t\tgroups.append([])\n\t\tgroups[-1].append(a[i])\n\t\tlast_ch = ch\n\t\n\t# print(groups)\n\t\n\tans = 0\n\tfor g in groups:\n\t\tg.sort()\n\t\tans += sum(g[-k:])\n\t\t\n\tprint(ans)\n\n\ncore()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "n, m = list(map(int,input().split()))\na = list(map(int,input().split())) + [1]\ns = input() + '0'\nlast = '1'\nl = [0]\nans = 0\nfor i in range(n+1):\n    if last != s[i]:\n        l.sort()\n        if len(l) < m:\n            ans += sum(l)\n        else:\n            ans += sum(l[len(l)-m:])\n        l.clear()\n    l.append(a[i])\n    last = s[i]\nprint(ans)\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[ ]:\n\n\nn,k=list(map(int,input().split()))\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\nscorelist=list(map(int,input().split()))\n\n\n# In[ ]:\n\n\n\n\n\n# In[2]:\n\n\nkeylist=list(input())\n\n\n# In[ ]:\n\n\nkeystreaks=[]\n\n\ncurrentstreak=[[scorelist[0],keylist[0]]]\n\n\n# In[ ]:\n\n\nfor i in range(1,n):\n    if keylist[i]==keylist[i-1]:\n        currentstreak.append([scorelist[i],keylist[i]])\n        \n        \n    else:\n        keystreaks.append(currentstreak)\n        currentstreak=[[scorelist[i],keylist[i]]]\n        \n        \n        \nkeystreaks.append(currentstreak)        \n\n\n# In[ ]:\n\n\n#print(keystreaks)\n\n\n# In[ ]:\n\n\nbigtotal=0\n\nfor streak in keystreaks:\n    total=0\n    streak.sort(key=lambda x: -x[0])\n    #print(streak)\n    tally=0\n    while tally<k and tally<len(streak):\n        total=total+streak[tally][0]\n        tally+=1\n    bigtotal=bigtotal+total    \n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\nprint(bigtotal)\n\n", "(lambda N,K,n,s:(lambda c,t:[[[s[i]!=s[i-1]and[c.__setitem__(0,c[0]+sum(sorted(t)[-K:])),t.clear()],t.append(n[i])]for i in range(1,N)],print(c[0]+sum(sorted(t)[-K:]))])([0],[n[0]]))(*map(int,input().split()),list(map(int,input().split())),input())", "from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\ns1=stdin.readline().strip()\nx=[s[0]]\ncur=s1[0]\ny=1\nans=0\nwhile y<n:\n    if s1[y]==cur:\n        x.append(s[y])\n    else:\n        cur=s1[y]\n        if len(x)>m:\n            x.sort()\n            for i in range(m):\n                ans+=x[-1]\n                x.pop()\n        else:\n            ans+=sum(x)\n        x=[s[y]]\n    y+=1\nif len(x)>m:\n    x.sort()\n    for i in range(m):\n        ans+=x[-1]\n        x.pop()\nelse:\n    ans+=sum(x)\nprint(ans)\n", "n,k=map(int, input().split())\na=list(map(int, input().split()))\ns=input('')\nb=[]\nc=[]\nsu=0\nfor i in range(n):\n  if len(b)==0:\n    b.append(s[i])\n    c.append(a[i])\n  elif b[-1] == s[i]:\n    b.append(s[i])\n    c.append(a[i])\n  elif b[-1] != s[i]:\n    c.sort(reverse=True)\n    for j in range(min(k,len(c))):\n      su=su+c[j]\n    b=[]   \n    c=[]\n    b.append(s[i])\n    c.append(a[i])   \nc.sort(reverse=True)\nfor j in range(min(k,len(c))):\n  su=su+c[j]\nprint(su)  ", "n,k = map(int,input().split())\na = list(map(int,input().split()))\ns = input() + '0'\ni = S = 0\nwhile i<n:\n    pos1 = i\n    while s[i+1] == s[i]: i+=1\n    pos2 = i\n    d = pos2-pos1+1\n    if d <= k: S+=sum(a[pos1:pos2+1])\n    else: S+=sum(sorted(a[pos1:pos2+1])[-k:])\n    i+=1\nprint(S)", "from heapq import heapify, heappush, heappop\nn, k = list(map(int, input().split()))\nA = list(map(int, input().split()))\ns = input()\nh = [A[0]]\nheapify(h)\nans = A[0]\nfor i in range(1, n):\n    if s[i] == s[i - 1]:\n        if len(h) == k:\n            elem = heappop(h)\n            if elem > A[i]:    \n                heappush(h, elem)\n            else:\n                heappush(h, A[i])\n                ans += (A[i] - elem)\n        else:\n            heappush(h, A[i])\n            ans += A[i]\n    else:\n        h = [A[i]]\n        heapify(h)\n        ans += A[i]\nprint(ans)\n", "n,k=map(int,input().split())\na=list(map(int,input().split()))\ns=input()\nb=[[s[i],a[i]] for i in range(n)]\nans=0\ntemp=[]\nc=b[0][0]\nfor i in b:\n    if i[0]!=c:\n        c=i[0]\n        temp.sort(reverse=True)\n        ans+=(sum(temp[:min(len(temp),k)]))\n        temp.clear()\n    if i[0]==c:\n        temp.append(i[1])\ntemp.sort(reverse=True)\nans+=(sum(temp[:min(len(temp),k)]))\nprint(ans)", "n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\ns=str(input())\ni=0\nans=0\nwhile(i<n):\n\tj=i+1\n\tcount=1\n\tarrx=[arr[i]]\n\twhile(j<n and s[i]==s[j]):\n\t\tcount+=1\n\t\tarrx.append(arr[j])\n\t\tj+=1\n\t#print(j)\n\tarrx.sort(reverse=True)\n\tans+=sum(arrx[:min(count,k)])\n\ti=j\nprint(ans)\n\n"]
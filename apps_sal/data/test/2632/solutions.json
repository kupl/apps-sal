["class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m, n = len(grid), len(grid[0])\n         dp = [0] + [float('inf')] * (n-1)\n         for i in range(m):\n             dp[0] = dp[0] + grid[i][0]\n             for j in range(1, n):\n                 dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n         return dp[-1]", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(grid)\n         n = len(grid[0])\n         dp = [grid[0][j] for j in range(n)]\n         \n         for j in range(1, n):\n             dp[j] += dp[j-1]\n         for i in range(1, m):\n             for j in range(n):\n                 if j == 0:\n                     dp[j] += grid[i][j]\n                 else:\n                     dp[j] = min(grid[i][j]+dp[j-1], grid[i][j]+dp[j])\n         return dp[-1]\n", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         M = len(grid)\n         if M == 0:\n             return 0\n         N = len(grid[0])\n         if N == 0:\n             return 0\n         \n         INF = float('inf')\n         mem = {}\n         \n         # O(M*N)\n         def min_path(i,j):\n             if i == M-1 and j == N-1:\n                 return grid[i][j]\n             if (i,j) in mem:\n                 return mem[(i,j)]\n             \n             min_sum = INF\n             if i < M-1:\n                 min_sum = min_path(i+1, j)\n             if j < N-1:\n                 min_sum = min(min_sum, min_path(i, j+1))\n             \n             mem[(i,j)] = grid[i][j] + min_sum\n             return mem[(i,j)]\n         \n         return min_path(0, 0)\n             \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(grid)-1\n         n = len(grid[0])-1\n         dic = dict()\n         s = self.minPathSumHelper(grid, 0, 0, m,n, dic)\n         return s\n     \n     def minPathSumHelper(self, grid, i,j, m,n, dic):\n         \n         if (i, j, m, n) in dic:\n             return dic[(i, j, m, n)]\n         \n         if i>m or j>n:\n             return 0\n         elif i==m:\n             dic[(i, j, m, n)] = self.minPathSumHelper(grid, i, j+1, m, n, dic)+grid[i][j]\n             return dic[(i, j, m, n)]\n         elif j==n:\n             dic[(i, j, m, n)] = self.minPathSumHelper(grid, i+1, j, m, n, dic)+grid[i][j]\n             return dic[(i, j, m, n)]\n         else:\n             dic[(i, j, m, n)] = min(self.minPathSumHelper(grid, i+1, j, m,n, dic), self.minPathSumHelper(grid, i, j+1, m, n, dic))+grid[i][j]\n             return dic[(i, j, m, n)]\n         \n", "class Solution(object):\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         max_row = len(grid) - 1  # rows\n         max_col = len(grid[0]) - 1  # columns\n         helper_grid = [[0]*(len(grid[0])) for _ in range(len(grid))]\n         helper_grid[max_row][max_col] = grid[max_row][max_col]\n         # fill max row and max column\n         for i in range(max_col - 1, -1, -1):\n             helper_grid[max_row][i] = grid[max_row][i] + helper_grid[max_row][i + 1]\n         for i in range(max_row - 1, -1, -1):\n             helper_grid[i][max_col] = grid[i][max_col] + helper_grid[i + 1][max_col]\n \n         # fill the rest\n         for col in range(max_col - 1, -1, -1):\n             for row in range(max_row - 1, -1, -1):\n                 helper_grid[row][col] = grid[row][col] + min(helper_grid[row+1][col], helper_grid[row][col+1])\n         # for row in helper_grid:\n         #     print(row)\n         return helper_grid[0][0]\n", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not grid:\n             return 0\n         row_count = len(grid)\n         col_count = len(grid[0])\n         for i in range(1, row_count):\n             grid[i][0] += grid[i-1][0]\n         for i in range(1, col_count):\n             grid[0][i] += grid[0][i-1]\n         for row in range(1, row_count):\n             for col in range(1, col_count):\n                 grid[row][col] += min(grid[row-1][col], grid[row][col-1])\n         return grid[-1][-1]", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not grid:\n             return 0\n         row,col = len(grid),len(grid[0])\n         dp = [0 for _ in range(col)]\n         dp[0] = grid[0][0]\n \n         for i in range(1,col):\n             dp[i] = dp[i-1] + grid[0][i]\n \n         for i in range(1,row):\n             for j in range(0,col):\n                 dp[j] = dp[j] + grid[i][j] if j==0 else min(dp[j-1],dp[j])+grid[i][j]\n \n         return dp[-1]", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not grid:\n             return 0\n         row_count = len(grid)\n         col_count = len(grid[0])\n         dp = [[0 for _ in range(col_count)] for _ in range(row_count)]\n         dp[0][0] = grid[0][0]\n         if row_count == col_count and col_count == 1:\n             return dp[-1][-1]\n         for row in range(row_count):\n             for col in range(col_count):\n                 if row == 0 and col >= 1:\n                     dp[row][col] = dp[row][col-1] + grid[row][col]\n                 elif col == 0 and row >= 1:\n                     dp[row][col] = dp[row-1][col] + grid[row][col]\n                 else:\n                     dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n         return dp[-1][-1]", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(grid)\n         n = len(grid[0])\n         s = [[0 for j in range(n)] for i in range(m)]\n         s[0][0] = grid[0][0]\n         \n         for i in range(1, m):\n             s[i][0] = s[i-1][0] + grid[i][0]\n \n         for j in range(1, n):\n             s[0][j] = s[0][j-1] + grid[0][j]\n \n         for i in range(1, m):\n             for j in range(1, n):\n                 s[i][j] = min(s[i-1][j]+grid[i][j], s[i][j-1]+grid[i][j])\n         \n \n         return s[m-1][n-1]\n", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         height = len(grid)\n         width = len(grid[0])\n         step_num = (height + width) - 2\n         for step in range(1, step_num+1):\n             for row in range(height):\n                 col = step - row\n                 if 0 <= row < height and 0 <= col < width:\n                     if not row:\n                         grid[row][col] += grid[row][col-1]\n                     elif not col:\n                         grid[row][col] += grid[row-1][col]\n                     else:\n                         grid[row][col] += min(grid[row][col-1], grid[row-1][col])\n         return grid[-1][-1]", "class Solution:\n     def minPathSum(self, grid): \n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         xx=len(grid)-1\n         yy=len(grid[0])-1\n         gridv=[[0 for j in range(len(grid[0]))] for i in range(len(grid))]\n         gridv[xx][yy]=grid[xx][yy]\n         for i in range(xx,-1,-1):\n             for j in range(yy,-1,-1):\n                 if i==xx:\n                     if j==yy:\n                          gridv[i][j]=grid[xx][yy]\n                     else:\n                          gridv[i][j]=grid[i][j]+gridv[i][j+1]\n                 elif j==yy:\n                     if i==xx:\n                          gridv[i][j]=grid[xx][yy]\n                     else:\n                          gridv[i][j]=grid[i][j]+gridv[i+1][j]\n                 else:            \n                     gridv[i][j]=min(gridv[i+1][j]+grid[i][j],gridv[i][j+1]+grid[i][j])\n         print(grid)\n         print(gridv)\n         return gridv[0][0]\n     \n         \"\"\"\"\n         if(len(grid)==1 or len(grid[0])==1):\n             return sum(sum(grid,[]))\n         if\n         return grid[0][0]+min(self.minPathSum(grid[1:],x,y+1),self.minPathSum([grids[1:] for grids in grid],x+1,y))\n         \"\"\"\"\"", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         col = len(grid[0])\n         row = len(grid)\n         minSum = [[0 for x in range(col)] for y in range(row)]\n         \n         for i in range(row):\n             for j in range(col):\n                 add = 0\n                 if i-1 >= 0 and j-1 >= 0:\n                     add = min(minSum[i-1][j], minSum[i][j-1])\n                 elif i-1 >= 0:\n                     add = minSum[i-1][j]\n                 elif j-1 >= 0:\n                     add = minSum[i][j-1]\n                 minSum[i][j] = grid[i][j] + add\n         \n         return minSum[-1][-1]\n                 \n         \n", "class Solution:\n     def minPathSum(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m = len(grid)\n         n = len(grid[0])\n         if m == 0 or n == 0: return 0\n         \n         memory = [[0 for _ in range(n)] for _ in range(m)]\n         \n         def minSum(grid,x,y,n,m):\n             if x==0 and y==0: return grid[0][0]\n             if x<0 or y<0: return float(\"inf\")\n             if memory[y][x] > 0: return memory[y][x]\n             memory[y][x] = grid[y][x] + min(minSum(grid,x-1,y,n,m),minSum(grid,x,y-1,n,m))\n             return memory[y][x]\n             \n         return minSum(grid,n-1,m-1,n,m)\n     \n         \n"]
["import sys\ninput = sys.stdin.readline\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\n# node : 0<=i<=3*N-1, i:minus i+1: delete i+2: plus\n# start : 3*N\n# goal : 3*N+1\n\nEDGE=[dict() for i in range(3*N+2)]\nV=3*N+2\nstart=3*N\ngoal=3*N+1\n\nfor i in range(N):\n    EDGE[start][3*i] = -B[i] + (1<<30)\n    EDGE[3*i][3*i+1] = A[i] + (1<<30)\n    EDGE[3*i+1][3*i+2] = B[i] + (1<<30)\n    EDGE[3*i+2][goal] = float(\"inf\")\n\nfor i in range(M):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n\n    EDGE[3*x+1][3*y] = float(\"inf\")\n    EDGE[3*y+1][3*x] = float(\"inf\")\n\nANS=0\nwhile True:\n    USED=[0]*V\n    ROUTE=[-1]*V\n    Q=[(start,float(\"inf\"))]\n    \n    while Q: # DFS\n        NOW,cost=Q.pop()\n        if NOW==goal:\n            break\n\n        for to in EDGE[NOW]:\n            if USED[to]==0 and EDGE[NOW][to]!=0: \n                ROUTE[to]=NOW\n                USED[to]=1\n                Q.append((to,min(cost,EDGE[NOW][to])))\n    else:\n        break\n    \n    ANS+=cost\n    i=goal\n    while i!=start: # goal\u304b\u3089\u305f\u3069\u308a,Route\u3092\u4f7f\u3063\u3066EDGE\u306e\u66f4\u65b0\n        j=ROUTE[i]\n        EDGE[j][i]-=cost # \u4f7f\u3063\u305f\u30eb\u30fc\u30c8\u3092\u3044\u3051\u306a\u304f\u66f4\u65b0\n        if j in EDGE[i]:\n            EDGE[i][j]+=cost # \u9006\u5411\u304d\u306b\u9032\u3081\u308b\u3088\u3046\u306b\u3059\u308b.\u3053\u308c\u3089\u3092\u91cd\u307f\u3064\u304d\u306b\u3059\u308c\u666e\u901a\u306e\u30d5\u30ed\u30fc\n        else:\n            EDGE[i][j]=cost\n            \n        i=j\n        \nprint(-(ANS-(N<<30)))", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nedge = [tuple(map(int,input().split())) for i in range(M)]\n\nG = Dinic(2*N+2)\nres = 0\nfor i in range(1,N+1):\n    if B[i-1]>0:\n        res += B[i-1]\n        G.add_edge(0,i,B[i-1])\n        G.add_edge(0,N+i,B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    else:\n        G.add_edge(i,2*N+1,-B[i-1])\n        res += -B[i-1]\n        G.add_edge(N+i,2*N+1,-B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    G.add_edge(i,N+i,10**15)\n\nfor u,v in edge:\n    G.add_edge(u,N+v,10**15)\n    G.add_edge(v,N+u,10**15)\n\nres -= G.flow(0,2*N+1)\n\nprint(res)", "INF = float(\"inf\")\nINF = 2<<30\n\nclass Dinic:\n    def __init__(self, n):\n        self.lvl = [0] * n\n        self.ptr = [0] * n\n        self.q = [0] * n\n        self.adj = [[] for _ in range(n)]\n\n    def add_edge(self, a, b, c, rcap=0):\n        self.adj[a].append([b, len(self.adj[b]), c, 0])\n        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])\n\n    def dfs(self, v, t, f):\n        if v == t or not f:\n            return f\n\n        for i in range(self.ptr[v], len(self.adj[v])):\n            e = self.adj[v][i]\n            if self.lvl[e[0]] == self.lvl[v] + 1:\n                p = self.dfs(e[0], t, min(f, e[2] - e[3]))\n                if p:\n                    self.adj[v][i][3] += p\n                    self.adj[e[0]][e[1]][3] -= p\n                    return p\n            self.ptr[v] += 1\n\n        return 0\n\n    def calc(self, s, t):\n        flow, self.q[0] = 0, s\n        for l in range(31):  # l = 30 maybe faster for random data\n            while True:\n                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)\n                qi, qe, self.lvl[s] = 0, 1, 1\n                while qi < qe and not self.lvl[t]:\n                    v = self.q[qi]\n                    qi += 1\n                    for e in self.adj[v]:\n                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):\n                            self.q[qe] = e[0]\n                            qe += 1\n                            self.lvl[e[0]] = self.lvl[v] + 1\n\n                p = self.dfs(s, t, INF)\n                while p:\n                    flow += p\n                    p = self.dfs(s, t, INF)\n\n                if not self.lvl[t]:\n                    break\n\n        return flow\n\nn, m = list(map(int, input().split()))\ns = 2 * n\nt = 2 * n + 1\nMF = Dinic(2 * n + 2)\nout = 0\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nfor i in range(n):\n    a = A[i]\n    v = B[i]\n    out += a\n    MF.add_edge(i, i + n, INF)\n    if a - v > 0:\n        MF.add_edge(s, i, a - v)\n    else:\n        out += v - a\n    if a + v > 0:\n        MF.add_edge(i + n, t, a + v)\n    else:\n        out -= v + a\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    MF.add_edge(u - 1, v - 1 + n, INF)\n    MF.add_edge(v - 1, u - 1 + n, INF)\nprint((out - MF.calc(s,t)))\n    \n", "\n\"\"\"\n\nhttps://atcoder.jp/contests/arc107/tasks/arc107_f\n\n\u7d76\u5bfe\u5024\u306a\u306e\u3067\u3001\u9802\u70b9\u3092\u6b63\u5074\u30fb\u5e9c\u5074\u306b\u5272\u308a\u5f53\u3066\u3066\u3001\u305d\u306e\u9593\u306b\u8fba\u304c\u3042\u3063\u3066\u306f\u3044\u3051\u306a\u3044\n\u3068\u3059\u308b\n\u9802\u70b9\u304c\u6d88\u3048\u308b\u5834\u5408\u3082\u3042\u308b\u2026\n\n\u5168\u90e8\u6b63\u306e\u5bc4\u4e0e\u3068\u3057\u3066\u7b54\u3048\u306b\u3042\u3089\u304b\u3058\u3081\u8db3\u3057\u3066\u304a\u304f\n\u5143\u304c+\u306e\u5834\u5408\u3001 -\u5074\u306b\u3042\u308b\u3068 -2A \u306e\u88ab\u5bb3\u30fb\u6d88\u3055\u308c\u308b\u3068-A\u306e\u88ab\u5bb3\n\u5143\u304c-\u306e\u5834\u5408\u3001 +\u5074\u306b\u3042\u308b\u3068 -2A \u306e\u88ab\u5bb3\u30fb\u6d88\u3055\u308c\u308b\u3068-A\u306e\u88ab\u5bb3\n\n\u57fa\u672c\u7684\u306b\u5225\u5074\u306b\u3042\u308b\u3068\u88ab\u5bb3\u306e\u307f\u8a18\u8ff0\u3067\u304d\u308b\n\u9802\u70b9\u30922\u500d\u3059\u308b\u2026\u3057\u304b\u8003\u3048\u3089\u308c\u306a\u3044\n\n(+\u57fa\u6e96\u70b9)\n||\naA\n\u30682\u3064\u7e4b\u3052\u308b\u3068\u3001\u4e21\u65b9\u53cd\u5bfe\u5074\u3067-2A\u30fb\u7247\u65b9\u3060\u3051\u53cd\u5bfe\u3067-A\u30fb\u4e21\u65b9\u57fa\u6e96\u70b9\u5074\u3067-0\u3092\u8868\u73fe\u3067\u304d\u308b\n\nbB\n||\n(-\u57fa\u6e96\u70b9)\n\nstart \n|| ||  \u2190+\u5074\n------\n|| ||\naA bB  \u2190-\u5074\n|| ||\n|| ||\n GOAL\n\n\naA/\na/A\n/aA\n\u306e3\u901a\u308a\u306b\u7d5e\u308b\nA\u304c+\u5074\u306b\u306a\u308b & b\u304c\u8ca0\u5074\u306f\u307e\u305a\u3044\n\u2192inf\n\n\"\"\"\n\nimport sys\nfrom sys import stdin\n\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n\ninf = 10**18\nN,M = map(int,stdin.readline().split())\nA = list(map(int,stdin.readline().split()))\nB = list(map(int,stdin.readline().split()))\n\ns  = 2*N\ng  = 2*N+1\n\nans = 0\nfor i in range(N):\n    ans += abs(B[i])\n\nlines = defaultdict(set)\ncost = [ [0] * (2*N+2) for i in range(2*N+2) ]\n\nfor i in range(N):\n\n    lines[i+N].add(i)\n    cost[i+N][i] += inf\n\n    if B[i] >= 0:\n        \n        lines[s].add(i)\n        cost[s][i] += 2*B[i]\n\n        lines[i].add(N+i)\n        cost[i][N+i] += A[i]+B[i]\n    \n    elif B[i] < 0:\n\n        lines[i].add(N+i)\n        cost[i][N+i] += A[i]+abs(B[i])\n\n        lines[i+N].add(g)\n        cost[i+N][g] += 2*abs(B[i])\n\nfor i in range(M):\n    u,v = map(int,stdin.readline().split())\n    u -= 1\n    v -= 1\n\n    lines[u+N].add(v)\n    cost[u+N][v] += inf\n\n    lines[v+N].add(u)\n    cost[v+N][u] += inf\n\nprint (ans - Dinic(s,g,lines,cost))", "import sys\ninput = sys.stdin.readline\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\n# node : 0<=i<=3*N-1, i:minus i+1: delete i+2: plus\n# start : 3*N\n# goal : 3*N+1\n\nEDGE=[dict() for i in range(3*N+2)]\nV=3*N+2\nstart=3*N\ngoal=3*N+1\n\nfor i in range(N):\n    EDGE[start][3*i] = -B[i] + (1<<30)\n    EDGE[3*i][3*i+1] = A[i] + (1<<30)\n    EDGE[3*i+1][3*i+2] = B[i] + (1<<30)\n    EDGE[3*i+2][goal] = float(\"inf\")\n\nfor i in range(M):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n\n    EDGE[3*x+1][3*y] = float(\"inf\")\n    EDGE[3*y+1][3*x] = float(\"inf\")\n\nANS=0\nwhile True:\n    USED=[0]*V\n    ROUTE=[-1]*V\n    Q=[(start,float(\"inf\"))]\n    \n    while Q: # DFS\n        NOW,cost=Q.pop()\n        if NOW==goal:\n            break\n\n        for to in EDGE[NOW]:\n            if USED[to]==0 and EDGE[NOW][to]!=0: \n                ROUTE[to]=NOW\n                USED[to]=1\n                Q.append((to,min(cost,EDGE[NOW][to])))\n    else:\n        break\n    \n    ANS+=cost\n    i=goal\n    while i!=start: # goal\u304b\u3089\u305f\u3069\u308a,Route\u3092\u4f7f\u3063\u3066EDGE\u306e\u66f4\u65b0\n        j=ROUTE[i]\n        EDGE[j][i]-=cost # \u4f7f\u3063\u305f\u30eb\u30fc\u30c8\u3092\u3044\u3051\u306a\u304f\u66f4\u65b0\n        if j in EDGE[i]:\n            EDGE[i][j]+=cost # \u9006\u5411\u304d\u306b\u9032\u3081\u308b\u3088\u3046\u306b\u3059\u308b.\u3053\u308c\u3089\u3092\u91cd\u307f\u3064\u304d\u306b\u3059\u308c\u666e\u901a\u306e\u30d5\u30ed\u30fc\n        else:\n            EDGE[i][j]=cost\n            \n        i=j\n        \nprint(-(ANS-(N<<30)))", "import sys\nreadline = sys.stdin.readline\nimport collections\nclass Dinic:\n    def __init__(self, vnum):\n        self.edge = [[] for i in range(vnum)]\n        self.n = vnum\n        # inf\u306fint\u578b\u306e\u65b9\u304c\u826f\u3044\u304b\u3082\u306d\n        self.inf = 10**9+7\n    def addedge(self, st, en, c):\n        self.edge[st].append([en, c, len(self.edge[en])])\n        self.edge[en].append([st, 0, len(self.edge[st])-1])\n    def bfs(self, vst):\n        dist = [-1]*self.n\n        dist[vst] = 0\n        Q = collections.deque([vst])\n        while Q:\n            nv = Q.popleft()\n            for vt, c, r in self.edge[nv]:\n                if dist[vt] == -1 and c > 0:\n                    dist[vt] = dist[nv] + 1\n                    Q.append(vt)\n        self.dist = dist\n    def dfs(self, nv, en, nf):\n        nextv = self.nextv\n        if nv == en:\n            return nf\n        dist = self.dist\n        ist = nextv[nv]\n        for i, (vt, c, r) in enumerate(self.edge[nv][ist:], ist):\n            if dist[nv] < dist[vt] and c > 0:\n                df = self.dfs(vt, en, min(nf, c))\n                if df > 0:\n                    self.edge[nv][i][1] -= df\n                    self.edge[vt][r][1] += df\n                    return df\n            nextv[nv] += 1\n        return 0\n    def getmf(self, st, en):\n        mf = 0\n        while True:\n            self.bfs(st)\n            if self.dist[en] == -1:\n                break\n            self.nextv = [0]*self.n\n            while True:\n                fl = self.dfs(st, en, self.inf)\n                if fl > 0:\n                    mf += fl\n                else:\n                    break\n        return mf\n\n\nN, M = list(map(int, readline().split()))\nA = list(map(int, readline().split()))\nB = list(map(int, readline().split()))\n\n\nINF = 10**9+7\nD = Dinic(2*N+2)\nst = 2*N\nen = st+1\n\nans = 0\nfor i in range(N):\n    b = abs(B[i])\n    if B[i] < 0:\n        D.addedge(st, 2*i, 2*b)\n    else:\n        D.addedge(2*i+1, en, 2*b)\n    D.addedge(2*i, 2*i+1, A[i] + b)\n    ans += b\n\nfor _ in range(M):\n    u, v = list(map(int, readline().split()))\n    u -= 1\n    v -= 1\n    D.addedge(2*u+1, 2*v, INF)\n    D.addedge(2*v+1, 2*u, INF)\n\nprint((ans - D.getmf(st, en)))\n    \n"]
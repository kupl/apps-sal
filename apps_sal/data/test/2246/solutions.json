["from sys import stdin\nfrom decimal import Decimal as D\ninput = stdin.readline\nn = int(input())\nadj = [[] for i in range(n+1)]\ntree = [[] for i in range(n+1)]\nvisit = [-1]*(n+1)\nlength = [-1]*(n+1)\nfor i in range(n-1):\n    a, b = map(int,input().split())\n    adj[a].append(b)\n    adj[b].append(a)\nbfsord = []\n\nfrom collections import deque\nQ = deque()\nQ.append(1)\nvisit[1] = 0\nwhile len(Q):\n    p = Q.popleft()\n    bfsord.append(p)\n    for q in adj[p]:\n        if visit[q] != -1: continue\n        visit[q] = visit[p]+1\n        Q.append(q)\n        tree[p].append(q)\n\nfor p in reversed(bfsord):\n    if not tree[p]: length[p] = D(0)\n    else: length[p] = D(1) + sum(length[q] for q in tree[p])/len(tree[p])\nprint(length[1])", "import sys\n\ndef r():\n    return list(map(int, input().split()))\n\nn = int(input())\nedge = [r() for i in range(n-1)]\n\nadj = [[] for i in range(n+1)]\nfor e in edge:\n    adj[e[0]].append(e[1])\n    adj[e[1]].append(e[0])\n\nprob = [0.0 for i in range(n+1)]\nd = [0 for i in range(n+1)]\nvisited = [False for i in range(n+1)]\n\nprob[1] = 1\nans = 0.0\n\nst = [1]\nvisited[1] = True\nwhile st:\n    u = st.pop()\n    cnt = len(adj[u])\n    if u != 1:\n        cnt -= 1\n    if cnt == 0:\n        ans = ans + prob[u]*d[u]\n    else:\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                prob[v] = prob[u]*(1.0/cnt)\n                d[v] = d[u]+1\n                st.append(v)\n                \nprint(ans)\n\n", "from queue import *\n\nn = int(input())\ng = [[] for x in range(n)]\n\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  g[a].append(b)\n  g[b].append(a)\n\nused = [0]*n\n\nanw = 0\n\ndef solve(v, d, r):\n  nonlocal anw\n  q = Queue()\n  q.put((v, d, r))\n  while not q.empty():\n    v, d, r = q.get(v)\n    used[v] = True\n    for u in g[v]:\n      if not used[u]:\n        q.put((u, d+1, r*(len(g[v])-(v!=0))))\n        #print(\"put\", u)\n    #print(\"so at\", v, \"len\", len(g[v]))\n    if v != 0 and len(g[v]) == 1:\n      #print(\"At \", v, \"is\", d, r)\n      anw += d/r\n  \nsolve(0, 0, 1)\nprint(anw)", "def f():\n    n = int(input())\n\n    if n == 1:\n        print(0)\n        return\n\n    road = {}\n    visited = {}\n    for i in range(n-1):\n        u, v = input().split()\n        if u in road:\n            road[u].append(v)\n        else:\n            road[u] = [v]\n        if v in road:\n            road[v].append(u)\n        else:\n            road[v] = [u]\n        visited[u] = False\n        visited[v] = False\n\n    prob = {}\n    length = {}\n    res = []\n\n    queue = []\n    for k in road['1']:\n        prob[k] = 1.0 / len(road['1'])\n        length[k] = 1\n        queue.append(k)\n        visited['1'] = True\n\n    while len(queue) > 0:\n        cur = queue[0]\n        del queue[0]\n        dest = []\n        for k in road[cur]:\n            if not visited[k]:\n                dest.append(k)\n        if len(dest) == 0:\n            res.append((cur, prob[cur], length[cur]))\n            continue\n        for k in dest:\n            prob[k] = prob[cur] / len(dest)\n            length[k] = length[cur] + 1\n            queue.append(k)\n            visited[cur] = True\n\n    val = 0.0\n    for item in res:\n        val += item[1] * item[2]\n\n    print(val)\n\nf()\n", "from collections import deque\nimport sys\nfrom decimal import Decimal\n\nreadline = sys.stdin.readline\nn = int(input())\nedges = [[]*n for _ in [None]*n]\n\nfor _ in [None]*(n-1):\n    a, b = map(int, readline().split())\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\nvisited = [False]*n\nvisited[0] = True\ncnt = 0\ntotal = 0\ndq = deque()\nappend, pop = dq.append, dq.popleft\nappend((0, 0, Decimal(1)))\n\nwhile dq:\n    pos, l, multiple = pop()\n    flag = True\n    to = [x for x in edges[pos] if visited[x] == False]\n\n    if to:\n        x = len(to)\n        multiple /= Decimal(x)\n        for v in to:\n            visited[v] = True\n            append((v, l+1, multiple))\n    else:\n        total += Decimal(l) * multiple\n\nprint(total)", "import sys\nfrom collections import deque\nread=lambda:sys.stdin.readline().rstrip()\nreadi=lambda:int(sys.stdin.readline())\nwriteln=lambda x:sys.stdout.write(str(x)+\"\\n\")\nwrite=lambda x:sys.stdout.write(x)\nN = readi()\nif N == 1:\n    writeln(0)\n    return\n\nG = [set() for _ in range(N)]\nfor _ in range(N-1):\n    u, v = list(map(int, read().split()))\n    G[u-1].add(v-1)\n    G[v-1].add(u-1)\n\nvisited = [0]*N\nprev = [0]*N\nvisited[0] = 1\nprev[0] = 1\nq = deque([0])\nlengths = []\nev = 0\nwhile q:\n    cur = q.popleft()\n    n_neighbor = len(G[cur])\n    if cur == 0:\n        divs = n_neighbor\n    else:\n        divs = n_neighbor - 1\n    if n_neighbor == 1 and cur != 0:\n        ev += (visited[cur] - 1)*prev[cur]\n        continue\n     \n    for nxt in G[cur]:\n        if not visited[nxt]:\n            visited[nxt] = visited[cur] + 1\n            prev[nxt] = (1 / divs)*prev[cur]\n            q.append(nxt)\n\nprint('%.12f' % ev)\n", "#!/usr/bin/env python\n\nimport sys\n\ndef explore(src, prob, length, adj_mat, gains, visited):\n    nexts = set(adj_mat[src]) - visited\n    if nexts:\n        go_prob = 1 / len(nexts)\n        length += 1\n        for dst in nexts:\n            visited.add(dst)\n            explore(dst, prob * go_prob, length, adj_mat, gains, visited)\n    else:\n        gains[src] += prob * length\n\ndef main():\n  n = int(sys.stdin.readline())\n  adj_mat = [[] for __ in range(n)]\n  node_exp = [0 for __ in range(n)]\n  for __ in range(n-1):\n      u, v = list(map(int, sys.stdin.readline().split()))\n      adj_mat[u-1].append(v-1)\n      adj_mat[v-1].append(u-1)\n  stk = [0]\n  visited= set([0])\n  prob = [1] * n\n  length = [0] * n\n  while stk:\n      nxt = stk.pop()\n      nexts = set(adj_mat[nxt]) - visited\n      if nexts:\n          go_prob = 1 / len(nexts)\n          for dst in nexts:\n              visited.add(dst)\n              stk.append(dst)\n              prob[dst] *= prob[nxt] * go_prob\n              length[dst] = length[nxt] + 1\n      else:\n        node_exp[nxt] += prob[nxt] * length[nxt]\n\n  #explore(0, 1, 0, adj_mat,node_exp, set([0]))\n  print(\"{:.13f}\".format(sum(node_exp)))\n\nmain()\n", "import sys\n\n\ndef main():\n    n = int(input())\n    if n == 1:\n        print(0)\n        return\n    x = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = list(map(int, sys.stdin.readline().split()))\n        x[a - 1].append(b - 1)\n        x[b - 1].append(a - 1)\n\n    isl = [False] * n\n    for i in range(1, n):\n        if len(x[i]) == 1:\n            isl[i] = True\n\n    u = [False] * n\n    u[0] = True\n    q = [(0, 0, 1 / len(x[0]))]\n    a = 0\n    while len(q) != 0:\n        c, s, t = q.pop()\n        for i in x[c]:\n            if not u[i]:\n                if isl[i]:\n                    a += (s + 1) * t\n                else:\n                    q.append((i, s + 1, t / (len(x[i])-1)))\n                u[i] = True\n    print(a)\n\n\nmain()\n", "n = int(input())\nr = [[]for _ in range(n+1)]\n\nfor _ in range(n-1):\n\tu,v = list(map(int,input().split()))\n\tu -= 1\n\tv -= 1\n\tr[u].append(v)\n\tr[v].append(u)\n\nif n == 1:\n\tprint(0)\nelse:\n\tst = [(0,0,1/len(r[0]))]\n\tans = 0\n\trsum = 0\n\tvisit = [False] * n\n\tvisit[0] = True\n\twhile st:\n\t\tv,t,m = st.pop()\n\t\tfor l in r[v]:\n\t\t\tif not visit[l]:\n\t\t\t\tif l != 0 and len(r[l]) == 1:\n\t\t\t\t\tans += (t+1)*m\n\t\t\t\t\trsum += 1\n\t\t\t\telse:\n\t\t\t\t\tst.append((l,t+1,m/(len(r[l])-1)))\n\t\t\t\tvisit[l] = True\n\tprint(ans)\n", "from collections import deque, Counter\n\ndef mean_of_ways(graph, n):\n    leafs = []\n    distances = [None] * n\n    probabilities = [0] * n\n    probabilities[0] = 1\n    distances[0] = 0\n    used = [False] * n\n    used[0] = True\n\n    active_vertices = deque([0])\n\n    while active_vertices:\n        where = active_vertices.popleft()\n\n        # remember what happens if we change place of used assignment\n        is_leaf = True\n\n        leafs_count = ([not used[v] for v in graph[where]]).count(True)\n        if leafs_count > 1:\n            probabilities[where] /= leafs_count\n\n        for to in graph[where]:\n            if not used[to]:\n                active_vertices.append(to)\n                distances[to] = distances[where] + 1\n                probabilities[to] = probabilities[where]\n                used[to] = True\n                is_leaf = False\n\n        if is_leaf:\n            leafs.append(where)\n\n    Mx = 0\n    for i in leafs:\n        Mx += probabilities[i] * distances[i]\n    return Mx\n\ndef main():\n    n = int(input())\n\n    graph = [list() for i in range(n)]\n    for i in range(n-1):\n        # It there are vertices in descending order we can don't check\n        # used it or not by making edges one directional\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    print(mean_of_ways(graph, n))\n\nmain()\n", "\"\"\"\n    Author      : Arif Ahmad\n    Date        : \n    Algo        : \n    Difficulty  : \n\"\"\"\nfrom sys import stdin, stdout\n\n\ndef main():\n    n = int(stdin.readline().strip())\n    g = [[] for i in range(n+1)]\n    for _ in range(n-1):\n        u, v = [int(_) for _ in stdin.readline().strip().split()]\n        g[u].append(v)\n        g[v].append(u)\n\n    visited = [False for i in range(n+1)]\n    paths = []\n\n    # iterative DFS\n    stack = [(1, 0, 1)]\n    while len(stack):\n        u, plen, prb = stack.pop()\n\n        visited[u] = True\n        nBranch = 0\n        for v in g[u]:\n            if not visited[v]: nBranch += 1\n        \n        if nBranch > 0: \n            probability = prb * (1 / nBranch)\n            for v in g[u]:\n                if not visited[v]:\n                    stack.append((v, plen+1, probability))\n        \n        if nBranch == 0:\n            paths.append(plen * prb)\n\n        \n\n    ans = sum(paths) \n    stdout.write(str(ans) + '\\n')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\ns = 0\nn = int(input())\nls = [[] for i in range(n + 1)]\nfor i in range(1, n):\n    a, b = list(map(int, input().split()))\n    ls[a].append(b)\n    ls[b].append(a)\narr = [0 for i in range(n + 1)]\nq = deque()\nq.append([1, 1, 0])\n# node, probablity, path\nwhile q:\n    x = q.pop()\n    node = x[0]\n    arr[node] = 1\n    to_explore = []\n    for i in ls[node]:\n        if arr[i] == 0:\n            to_explore.append(i)\n\n    if len(to_explore) == 0:\n        # leaf\n        s = s + x[1] * x[2]\n        continue\n    n = len(to_explore)\n    for i in to_explore:\n        q.append([i, x[1] / n, x[2] + 1])\nprint(s)\n", "from collections import deque\ns = 0\nn = int(input())\nls = [[] for i in range(n + 1)]\nfor i in range(1, n):\n    a, b = list(map(int, input().split()))\n    ls[a].append(b)\n    ls[b].append(a)\narr = [0 for i in range(n + 1)]\nq = deque()\nq.append([1, 1, 0])\nwhile q:\n    x = q.pop()\n    node = x[0]\n    arr[node] = 1\n    to_explore = []\n    for i in ls[node]:\n        if arr[i] == 0:\n            to_explore.append(i)\n\n    if len(to_explore) == 0:\n        # leaf\n        s = s + x[1] * x[2]\n        continue\n    n = len(to_explore)\n    for i in to_explore:\n        q.append([i, x[1] / n, x[2] + 1])\nprint(s)\n", "def dfs(start):\n    visited = [0, True] + [False]*(n-1)\n    stack = [(x, 1, 1/len(tree[start])) for x in tree[start]]\n    while stack:\n        v, l, p = stack.pop()\n        if leafs[v]:\n            L.append(l*p)\n        if not visited[v]:\n            visited[v] = True\n            for u in tree[v]:\n                if not visited[u]:\n                    stack.append((u, l+1, p/(len(tree[v])-1)))\n\n\nn = int(input())\ntree = {x: [] for x in range(1, n+1)}\nL = []\nfor _ in range(n-1):\n    u, v = list(map(int, input().split()))\n    tree[u].append(v)\n    tree[v].append(u)\nleafs = [False, True] + [len(tree[x]) == 1 for x in range(2, n+1)]\ndfs(1)\n# print(L)\nprint(sum(L))\n\n\"\"\"\n7\n1 2\n1 3\n1 4\n4 7\n2 6\n2 5\n\"\"\"\n", "\"\"\"\n    # recursive DFS gives RTE, implement iterative DFS\n    Author      : Arif Ahmad\n    Date        : \n    Algo        : \n    Difficulty  : \n\"\"\"\nfrom sys import stdin, stdout, setrecursionlimit\nimport threading\n\n\ng = None\nvisited = None\npaths = None\n\ndef dfs(u, plen, prb):\n    nonlocal visited, paths\n\n    visited[u] = True\n    \n    nBranch = 0\n    for v in g[u]:\n        if not visited[v]: nBranch += 1\n    \n    if nBranch > 0: \n        probability = prb * (1 / nBranch)\n        for v in g[u]:\n            #print(prb, nBranch)\n            if not visited[v]:\n                dfs(v, plen+1, probability)\n\n    if nBranch == 0:\n        paths.append(plen * prb)\n\n\ndef main():\n    nonlocal g, visited, paths\n\n    n = int(stdin.readline().strip())\n    g = [[] for i in range(n+1)]\n    for _ in range(n-1):\n        u, v = [int(_) for _ in stdin.readline().strip().split()]\n        g[u].append(v)\n        g[v].append(u)\n\n    visited = [False for i in range(n+1)]\n    paths = []\n    #setrecursionlimit(n+10)\n    dfs(1, 0, 1)\n\n    ans = sum(paths) \n    stdout.write(str(ans) + '\\n')\n\ndef __starting_point():\n    setrecursionlimit(10**6)\n    threading.stack_size(134217728)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "def dfs(start):\n    visited = [0, True] + [False]*(n-1)\n    stack = [(x, 1, 1/len(tree[start])) for x in tree[start]]\n    while stack:\n        v, l, p = stack.pop()\n        if leafs[v]:\n            L.append(l*p)\n        if not visited[v]:\n            visited[v] = True\n            for u in tree[v]:\n                if not visited[u]:\n                    stack.append((u, l+1, p/(len(tree[v])-1)))\n\n\nn = int(input())\ntree = {x: [] for x in range(1, n+1)}\nL = []\nfor _ in range(n-1):\n    u, v = list(map(int, input().split()))\n    tree[u].append(v)\n    tree[v].append(u)\nleafs = [False, True] + [len(tree[x]) == 1 for x in range(2, n+1)]\ndfs(1)\nprint(sum(L))\n\n\"\"\"\n7\n1 2\n1 3\n1 4\n4 7\n2 6\n2 5\n\"\"\"\n", "n = int(input())\n\nd = { x : [] for x in range(1, n + 1)}#defaultdict(list)\nfor x in range(n - 1):\n    s,de = map(int, input().split())\n    d[s].append(de)\n    d[de].append(s)\n\ndef dfs():\n    lst = [(0, 1.0, 1)]\n    visited = set({1})\n    ans = 0\n\n    while lst:\n        depth,prob,source = lst.pop()\n        \n        for neigh in d[source]:\n            if neigh not in visited:\n                visited.add(neigh)\n                lst.append((depth + 1, prob*(1/(len(d[source]) - (1 if depth != 0 else 0))), neigh))\n        \n        if depth != 0 and len(d[source]) == 1:\n            ans += prob*depth\n\n    return ans\n\nprint(\"{:.8f}\".format(dfs()))", "n = int(input())\n\ntree = {x: [] for x in range(1, n+1)}\n\nfor _ in range(n-1):\n    k,l = list(map(int, input().split()))\n    tree[k].append(l)\n    tree[l].append(k)\n\n#for i in range(99999):\n#    tree[i+1].append(i+2)\n#    tree[i+2].append(i+1)\n\nvisited = set()\ns = 0\n\na = [(1,1,0)]\n\nwhile a:\n    v,p,l = a.pop()\n    visited.add(v) \n    k = 0\n    for vv in tree[v]:\n        if vv not in visited:\n            k += 1\n    if k <= 0:\n        s += p*l\n    else:\n        for vv in tree[v]:\n            if vv not in visited:\n                a.append((vv,p*1.0/k,l+1))\n\nprint(s)", "from collections import defaultdict\nfrom collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast):\n    return tuple(int(x) for x in nextline().split())\n\ndef ints():\n    return types(int)\n\ndef strs():\n    return nextline().split()\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    n = int(nextline())\n    graph = defaultdict(list)\n    for _ in range(1, n):\n        a, b = ints()\n        graph[a].append(b)\n        graph[b].append(a)\n    stack = [(1, 1, 0)]\n    visited = set()\n    expected = 0\n    while stack:\n        city, denominator, length = stack.pop()\n        visited.add(city)\n        choices = [choice for choice in graph[city] if choice not in visited]\n        if choices:\n            for choice in choices:\n                stack.append((choice, denominator * len(choices), length + 1))\n        else:\n            expected += length / denominator\n    print(expected)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import queue\nn = int(input())\ndic = {}\n\nfor i in range(n+1):\n    dic[i] = []\nfor i in range(n-1):\n    u,v = [ int(x) for x in input().split() ]\n    dic[u].append(v)\n    dic[v].append(u)\n\nweight = {1:(0,1)} # No.City:(length,weight)\nq = queue.Queue()\nq.put(1)\nwhile(q.empty() == False):\n    city = q.get()\n    choice = len(dic[city])\n    if city > 1:\n        choice = choice - 1\n    for to_city in dic[city]:\n        if to_city not in weight:\n            weight[to_city] = (weight[city][0]+1, weight[city][1]/choice)\n            q.put(to_city)\n    if(choice > 0):\n        weight[city] = (weight[city][0], 0)\n\nsum = 0\nfor city in weight:\n    sum = sum + weight[city][0] * weight[city][1]\n\nprint(\"%.15f\" % sum)\n\n", "def __starting_point():\n    n = int(input())\n    \n    edges = [[] for i in range(n+1)]\n    edges[0] = None\n    for i in range(n-1):\n        n1,n2 = list(map(int, input().split()))\n        edges[n1].append(n2)\n        edges[n2].append(n1)\n\n    # stack = [(node, height, prob),...]\n    stack = [(1,0,1.0)]\n    sev = 0\n    visited = [False for i in range(n+1)]\n    \n    while len(stack) > 0:\n        (node, height, prob) = stack.pop()\n        visited[node] = True\n        children = len(edges[node]) - 1\n        if node == 1:\n            # since root has no parent\n            children += 1\n            \n        for child in edges[node]:\n            if visited[child]:\n                continue\n            stack.append((child, height+1, prob/children))\n        \n        if children == 0:\n            sev += height * prob\n    print(sev)\n            \n    \n    \n    \n    \n\n\n\n__starting_point()", "class Node:\n\tdef __init__(self, index):\n\t\tself.neighbours = []\n\t\tself.index = index\n\t\tself.prob = 1.0\n\t\tself.vis = False\n\t\tself.length = 0\n\n\tdef addNode(self, city):\n\t\tself.neighbours.append(city)\n\t\tif self.index == 1:\n\t\t\tself.prob = 1.0 / len(self.neighbours)\n\t\telse:\n\t\t\tl = len(self.neighbours)\n\t\t\tself.prob = 1.0  if l < 2 else (1.0 / (l - 1))\n\nn = int(input())\nif n == 1:\n\tprint(0)\n\treturn\n\t\ncities = {}\n\nfor i in range(n-1):\n\ta, b = [int(k) for k in input().split()]\n\t#print (\"test \", a, \" to \", b)\n\tif a not in cities:\n\t\tcities[a] = Node(a)\n\tcities[a].addNode(b)\n\tif b not in cities:\n\t\tcities[b] = Node(b)\n\tcities[b].addNode(a)\n\nif len(cities) == 2:\n\tprint(1)\n\treturn\n\n\n# for i in range(1, n + 1, 1):\n# \tprint (\"city.index \", cities[i].index, ' roads ', cities[i].neighbours, ' prob ', cities[i].prob)\n\n\n# deadends = []\n# deadendsProb = []\n\n\n# def Parse(city, prob, length, oldCity):\n# \t#print ('parse ', city.index)\n# \tnewprob = 1.0 if oldCity == 0  else cities[oldCity].prob\n# \t#print ('nnewProb ', newprob)\n# \tprob *= newprob\n# \t#print (city.index, ' len ', len(city.neighbours))\n# \tif len(city.neighbours) == 1 and oldCity != 0:\n# \t\tdeadends.append(length)\n# \t\tdeadendsProb.append(prob)\n# \telse:\n# \t\t#print (city.neighbours)\n# \t\tlength += 1\n# \t\tfor c in city.neighbours:\n# \t\t\tif c != oldCity:\n# \t\t\t\tParse(cities[c], prob, length, city.index )\n\n# Parse(cities[1], 1.0, 0, 0)\n# #for i in range(len(deadends)):\n# #\tprint('len ', deadends[i], ' prob ', deadendsProb[i])\n\n# ans = sum(map(lambda l, p: l * p, deadends, deadendsProb))\n# #print('ans', ans)\n# print(ans)\n\n\ndef inorder(city):\n\ts = []\n\ts.append(city)\n\t#print ('index ', city.index)\n\t#print ('neighbours ', city.neighbours)\n\twhile s:\n\t\tcity = s.pop()\n\t\tcity.vis = True\n\t\tif city.neighbours:\n\t\t\tif city.index == 1 or len(city.neighbours) > 1:\n\t\t\t\tfor c in city.neighbours:\n\t\t\t\t\tif not cities[c].vis:\n\t\t\t\t\t\tcities[c].length = city.length + 1\n\t\t\t\t\t\tcities[c].prob *= city.prob\n\t\t\t\t\t\ts.append(cities[c])\n\t\t\telse:\n\t\t\t\tyield (city.index, city.prob, city.length)\n\n\n\ntest = sum([city[1] * city[2] for city in inorder(cities[1])])\nprint(test)\n\n\n\n# this is a tree\n", "from sys import setrecursionlimit\nimport threading\n\n\nlength = 0\nvisited = None\ng = None\n\n\ndef dfs(v, path_length, chance):\n    nonlocal length\n    visited.add(v)\n    edges = 0\n    for n in g[v]:\n        if n not in visited:\n            edges += 1\n    for n in g[v]:\n        if n not in visited:\n            dfs(n, path_length + 1, chance * (1 / edges))\n    if edges == 0:\n        length += path_length * chance\n\n\ndef main():\n    nonlocal visited, g\n    vert = int(input())\n    g = [[] for _ in range(vert + 1)]\n    visited = set()\n    for _ in range(vert - 1):\n        a, b = list(map(int, input().split()))\n        g[a].append(b)\n        g[b].append(a)\n    dfs(1, 0, 1)\n    print(length)\n\n\ndef __starting_point():\n    setrecursionlimit(10 ** 6)\n    threading.stack_size(134217728)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "n = int(input())\ng = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b = [int(x) for x in input().split()]\n    g[a].append(b)\n    g[b].append(a)\n\nd = [0 for i in range(n+1)]\nv = [0 for i in range(n+1)]\ne = [0 for i in range(n+1)]\np = [0.0 for i in range(n+1)]\np[1] = 1.0\nen = 0\nq = [1]\nwhile len(q):\n    c = q.pop(0)\n    v[c] = 1\n    a = 0\n    for ne in g[c]:\n        if not v[ne]:\n            q.append(ne)\n            d[ne] = d[c] + 1\n            p[ne] = p[c]/len(g[c]) if c == 1 else p[c]/(len(g[c])-1)\n            a += 1\n    if a == 0:\n        e[c] = 1\n        en += 1\nave = 0.0\nfor i in range(n+1):\n    if e[i]:\n        ave += d[i]*p[i]\nprint(ave)\n", "n=int(input())\nif n==1:\n\tprint(0)\n\treturn\ngraph=[None]*n\nfor i in range(n-1):\n\tu,v=map(int,input().split())\n\tu-=1\n\tv-=1\n\tif graph[u]==None:\n\t\tgraph[u]=[v]\n\telse:\n\t\tgraph[u].append(v)\n\tif graph[v]==None:\n\t\tgraph[v]=[u]\n\telse:\n\t\tgraph[v].append(u)\n\nis_checked=[False]*n\nlens=[None]*n\nlens[0]=0\ndivs=[None]*n\ndivs[0]=1\nstack=[0]\nans=0\nwhile stack:\n\ttop=stack.pop()\n\tis_checked[top]=True\n\tvals=graph[top]\n\tfor i in range(len(vals)):\n\t\tcur=vals[i]\n\t\tif not is_checked[cur]:\n\t\t\tlens[cur]=lens[top]+1\n\t\t\tdivs[cur]=divs[top]*(len(vals)-(1 if top!=0 else 0))\n\t\t\tif len(graph[cur])==1:\n\t\t\t\tans+=lens[cur]/divs[cur]\n\t\t\t\tis_checked[cur]=None\n\t\t\t\tlens[cur]=None\n\t\t\t\tdivs[cur]=None\n\t\t\t\tcontinue\n\t\t\tstack.append(cur)\nprint('{:.8f}'.format(ans))"]
["\na,b,mod = list(map(int, input().split()))\n\ng = [2] * a\nfor i in range(b):\n    t = input()\n    for x, y in  enumerate(t):\n        if y == '1':\n            g[x] -= 1\n\none = two = 0\nfor q in g:\n    if q < 0:\n        print(0)\n        return\n\n    if q == 1:\n        one+=1\n    if q == 2:\n        two+=1\n\n\n\nmat = [[0]*600 for x in range(600)]  \nmat[0][0] = 1\n#int(one, two)\nfor j in range(a + 1):\n    for i in range(a + 1):\n        if i-2>=0:\n            mat[i][j] += i*(i-1) // 2 * mat[i-2][j];\n            #print('in',i,j, mat[i][j], i*(i-1)//2, mat[i-2][j], i-2, mat[0][0])\n        if j-1>=0:\n            mat[i][j] += i*j * mat[i][j -1];\n        if j-2>=0 :\n            mat[i][j] += j *(j-1)//2 * mat[i+2][j -2];\n        mat[i][j] %= mod\n\n#print(mat[2][0])\n#print(mat[0][2])\nprint(mat[one][two])\n", "n, m, mod = [int(x) for x in input().split()]\n\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(100000000)\n\n@lru_cache(maxsize=None)\ndef rec(twos, ones):\n    nonlocal mod\n    if twos == 0 and ones == 0:\n        return 1\n    if twos == 1 and ones == 0:\n        return 0\n    else:\n        count = 0\n        # we can pick two from ones if there are at least two:\n        if (ones >= 2):\n            a = ones*(ones-1)//2\n            b = rec(twos, ones-2)\n            count += (a*b) % mod\n        if (ones >= 1 and twos >= 1):\n            a = ones*twos\n            b = rec(twos-1, ones)\n            count += (a*b) % mod\n        if (twos >= 2):\n            a = twos*(twos-1)//2\n            b = rec(twos-2, ones+2)\n            count += (a*b) % mod\n        return count % mod\n\n# we read the beginning matrix and calculate the starting position\nmatrix = []\nfor i in range(0, m):\n    matrix.append([int(x) for x in input()])\n\ntwocount = 0\nonecount = 0\nfor c in range(0, n):\n    # for each column count the number of ones in it\n    count = 0\n    for r in range(0, m):\n        # r is the row, c is the column\n        if (matrix[r][c] == 1):\n            count += 1\n    if count == 2:\n        twocount += 1\n    elif count == 1:\n        onecount += 1\n\nones = onecount\ntwos = n - onecount - twocount\n\nprint(rec(twos, ones))\n", "# // DP\n# // codeforces 489F Special Matrices \n\nn = 0\nm = 0\nMOD = 0\ncap = [0] * 505\nans = [[-1] * 505 for i in range(505)]\n\ndef f(one, two):\n    if one == 0 and two == 0:\n        return 1\n\n    if two > len(ans[one]):\n        print(str(one) + ' ' + str(two) + ' ' + len(ans[one]))\n    if ans[one][two] != -1:\n        return ans[one][two]\n\n    temp = 0\n    if two > 1:\n        x = two * (two-1) / 2 * f(one+2, two-2)\n        temp += x % MOD\n    if one > 1:\n        x = one * (one-1) / 2 * f(one-2, two)\n        temp += x % MOD\n    if two > 0 and one > 0:\n        x = one * two * f(one, two-1)\n        temp += x % MOD\n    temp = temp % MOD\n    ans[one][two] = temp\n    return temp\n\ntemp = input().split(' ')\nn = int(temp[0])\nm = int(temp[1])\nMOD = int(temp[2])\nfor i in range(0, m):\n    cur = ''\n    cur = input()\n    for j in range(0, n):\n        if cur[j] == '1':\n            cap[j] += 1\n\nn_one = 0;\nn_two = 0;\nfor i in range(0, n):\n    if cap[i] == 0:\n        n_two += 1\n    if cap[i] == 1:\n        n_one += 1\n\nprint(int(f(n_one, n_two)))\n\n\n\n\n# // F. Special Matrices\n# // time limit per test\n# // 1 second\n# // memory limit per test\n# // 256 megabytes\n# // input\n# // standard input\n# // output\n# // standard output\n\n# // An n\u2009\u00d7\u2009n square matrix is special, if:\n\n# //     it is binary, that is, each cell contains either a 0, or a 1;\n# //     the number of ones in each row and column equals 2. \n\n# // You are given n and the first m rows of the matrix. Print the number of special n\u2009\u00d7\u2009n matrices, such that the first m rows coincide with the given ones.\n\n# // As the required value can be rather large, print the remainder after dividing the value by the given number mod.\n# // Input\n\n# // The first line of the input contains three integers n, m, mod (2\u2009\u2264\u2009n\u2009\u2264\u2009500, 0\u2009\u2264\u2009m\u2009\u2264\u2009n, 2\u2009\u2264\u2009mod\u2009\u2264\u2009109). Then m lines follow, each of them contains n characters \u2014 the first rows of the required special matrices. Each of these lines contains exactly two characters '1', the rest characters are '0'. Each column of the given m\u2009\u00d7\u2009n table contains at most two numbers one.\n# // Output\n\n# // Print the remainder after dividing the required value by number mod.\n# // Sample test(s)\n# // Input\n\n# // 3 1 1000\n# // 011\n\n# // Output\n\n# // 2\n\n# // Input\n\n# // 4 4 100500\n# // 0110\n# // 1010\n# // 0101\n# // 1001\n\n# // Output\n\n# // 1\n\n# // Note\n\n# // For the first test the required matrices are:\n\n\n# // 011\n# // 101\n# // 110\n\n# // 011\n# // 110\n# // 101\n\n# // In the second test the required matrix is already fully given, so the answer is 1.\n", "from math import *\nfrom collections import *\nimport sys\nsys.setrecursionlimit(10**9)\ndp = [[-1 for i in range(505)] for j in range(505)]\ndef memo(row,z,o):\n\tif(row == n):\n\t\tif(z == 0 and o == 0):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tif(dp[z][o] != -1): return dp[z][o]\n\t\n\tif(z > 1):\n\t\tdp[z][o] += (z*(z-1)//2)*(memo(row+1,z-2,o+2))\n\t\tdp[z][o] %= mod\n\tif(z >= 1 and o >= 1):\n\t\tdp[z][o] += (z*o)*(memo(row+1,z-1,o))\n\t\tdp[z][o] %= mod\n\tif(o > 1):\n\t\tdp[z][o] += (o*(o-1)//2)*(memo(row+1,z,o-2))\n\t\tdp[z][o] %= mod\n\t#print(row,z,o,dp[z][o])\n\tdp[z][o] += 1\n\tdp[z][o] %= mod\n\treturn dp[z][o]%mod\n\nn,m,mod = list(map(int,input().split()))\na = []\nfor i in range(m):\n    s = list(input())\n    a.append(s)\n#print(a)\nct = [0 for i in range(n)]\nfor i in range(m):\n\tfor j in range(n):\n\t\tif(a[i][j] == '1'):\n\t\t\tct[j] += 1\n\nz = ct.count(0)\no = ct.count(1)\nans = memo(m,z,o)\nprint(ans%mod)\n\n"]
["MOD = 1000000007\n\n\ndef isSubset(a, b):\n\treturn (a & b) == a\n\n\ndef isIntersect(a, b):\n\treturn (a & b) != 0\n\n\n# Solve for each weakly connected component (WCC)\ndef cntOrder(s, t):\n\tp = len(s)\n\tm = len(t)\n\n\tinMask = [0 for i in range(m)]\n\n\tfor x in range(p):\n\t\tfor i in range(m):\n\t\t\tif t[i] % s[x] == 0:\n\t\t\t\tinMask[i] |= 1 << x\n\n\tcnt = [0 for mask in range(1<<p)]\n\tfor mask in range(1<<p):\n\t\tfor i in range(m):\n\t\t\tif isSubset(inMask[i], mask):\n\t\t\t\tcnt[mask] += 1\n\n\tdp = [[0 for mask in range(1<<p)] for k in range(m+1)]\n\tfor i in range(m):\n\t\tdp[1][inMask[i]] += 1\n\tfor k in range(m):\n\t\tfor mask in range(1<<p):\n\t\t\tfor i in range(m):\n\t\t\t\tif not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\n\t\t\t\t\tdp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD\n\t\t\tdp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\n\n\treturn dp[m][(1<<p)-1]\n\n\ndef dfs(u):\n\tnonlocal a, graph, degIn, visited, s, t\n\n\tvisited[u] = True\n\tif degIn[u] == 0:\n\t\ts.append(a[u])\n\telse:\n\t\tt.append(a[u])\n\n\tfor v in graph[u]:\n\t\tif not visited[v]:\n\t\t\tdfs(v)\n\n\ndef main():\n\tnonlocal a, graph, degIn, visited, s, t\n\n\t# Reading input\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\n\t# Pre-calculate C(n, k)\n\tc = [[0 for j in range(n)] for i in range(n)]\n\tfor i in range(n):\n\t\tc[i][0] = 1\n\t\tfor j in range(1, i+1):\n\t\t\tc[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD\t\n\n\t# Building divisibility graph\n\tdegIn = [0 for u in range(n)]\n\tgraph = [[] for u in range(n)]\n\tfor u in range(n):\n\t\tfor v in range(n):\n\t\t\tif u != v and a[v] % a[u] == 0:\n\t\t\t\tgraph[u].append(v)\n\t\t\t\tgraph[v].append(u)\n\t\t\t\tdegIn[v] += 1\n\n\t# Solve for each WCC of divisibility graph and combine result\n\tans = 1\n\tcurLen = 0\n\tvisited = [False for u in range(n)]\n\tfor u in range(n):\n\t\tif not visited[u]:\n\t\t\ts = []\n\t\t\tt = []\n\t\t\tdfs(u)\n\n\t\t\tif len(t) > 0:\n\t\t\t\tsz = len(t) - 1\n\t\t\t\tcnt = cntOrder(s, t)\n\n\t\t\t\t# Number of orders for current WCC\n\t\t\t\tans = (ans * cnt) % MOD\n\t\t\t\t# Number of ways to insert <sz> number to array of <curLen> elements\n\t\t\t\tans = (ans * c[curLen + sz][sz]) % MOD\n\t\t\t\tcurLen += sz\t\t\n\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "MOD = 1000000007\ndef isSubset(a, b):\n    return (a & b) == a\ndef isIntersect(a, b):\n    return (a & b) != 0\ndef cntOrder(s, t):\n    p = len(s)\n    m = len(t)\n    inMask = [0 for i in range(m)]\n    for x in range(p):\n        for i in range(m):\n            if t[i] % s[x] == 0:\n                inMask[i] |= 1 << x\n    cnt = [0 for mask in range(1 << p)]\n    for mask in range(1 << p):\n        for i in range(m):\n            if isSubset(inMask[i], mask):\n                cnt[mask] += 1\n    dp = [[0 for mask in range(1 << p)] for k in range(m + 1)]\n    for i in range(m):\n        dp[1][inMask[i]] += 1\n    for k in range(m):\n        for mask in range(1 << p):\n            for i in range(m):\n                if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\n                    dp[k + 1][mask | inMask[i]] = (dp[k + 1][mask | inMask[i]] + dp[k][mask]) % MOD\n            dp[k + 1][mask] = (dp[k + 1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\n    return dp[m][(1 << p) - 1]\ndef dfs(u):\n    nonlocal a, graph, degIn, visited, s, t\n\n    visited[u] = True\n    if degIn[u] == 0:\n        s.append(a[u])\n    else:\n        t.append(a[u])\n\n    for v in graph[u]:\n        if not visited[v]:\n            dfs(v)\ndef main():\n    nonlocal a, graph, degIn, visited, s, t\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        c[i][0] = 1\n        for j in range(1, i + 1):\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD\n    degIn = [0 for u in range(n)]\n    graph = [[] for u in range(n)]\n    for u in range(n):\n        for v in range(n):\n            if u != v and a[v] % a[u] == 0:\n                graph[u].append(v)\n                graph[v].append(u)\n                degIn[v] += 1\n    ans = 1\n    curLen = 0\n    visited = [False for u in range(n)]\n    for u in range(n):\n        if not visited[u]:\n            s = []\n            t = []\n            dfs(u)\n            if len(t) > 0:\n                sz = len(t) - 1\n                cnt = cntOrder(s, t)\n                ans = (ans * cnt) % MOD\n                ans = (ans * c[curLen + sz][sz]) % MOD\n                curLen += sz\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()"]
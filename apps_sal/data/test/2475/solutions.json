["import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nN = int(sys.stdin.readline())\nS = list(map(int, sys.stdin.readline().split()))\n\n\ndef count_max(diff):\n    # \u5de6\u53f3\u5bfe\u79f0\u306b diff \u9593\u9694\u3067\u3068\u308b\u3068\u304d\u306e\u6700\u5927\n    b = 0\n    a = N - 1\n    ret = 0\n    cumsum = 0\n    while diff < a and a != b and b - a != diff:\n        cumsum += S[b] + S[a]\n        ret = max(ret, cumsum)\n        b += diff\n        a -= diff\n    return ret\n\n\nans = 0\nfor diff in range(1, N // 2 + 1):\n    ans = max(ans, count_max(diff))\nprint(ans)\n", "n = int(input())\ns = list(map(int, input().split()))\n\nans = 0\nfor d in range(1, (n-1)//2+1):\n    ans_cur = 0\n    l, r = 0, n-1\n    while r > d and l != r and l != r+d:\n        ans_cur += s[l]+s[r]\n        ans = max(ans, ans_cur)\n        l += d\n        r -= d\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\ndef main():\n    N = II()\n    S = LI()\n    ans = 0\n    for C in range(1, N):\n        tmp = 0\n        L = 0\n        lim = (N - 1 - C) if (N - 1) % C else (N // 2)\n        while L < lim:\n            tmp += S[L] + S[-1 - L]\n            ans = max(ans, tmp)\n            L += C\n    return ans\n\nprint(main())", "n,*s=map(int,open(0).read().split())\nm=0\nfor i in range(1,n):\n    t=0\n    for j in range(0,n,i):\n        k=n-1-j\n        if k<i or k%i<1 and k<=j:break\n        t+=s[j]+s[k]\n        if t>m:m=t\nprint(m)", "n=int(input())\nv=list(map(int, input().split()))\nans=0\nfor k in range(1,n):\n\tp,s=k,0\n\twhile p<n:\n\t\tr=n-p-1\n\t\tif r<=k:\n\t\t\tbreak\n\t\ts+=v[p]+v[n-1-p]\n\t\tif r%k!=0 or p<r:\n\t\t\tans=max(ans,s)\n\t\tp+=k\nprint(ans)", "import sys\ndef single_input(F): return F.readline().strip(\"\\n\")\ndef line_input(F): return F.readline().strip(\"\\n\").split()\n  \ndef solve():\n    F = sys.stdin\n    N = int(single_input(F))\n    S = [int(s) for s in line_input(F)]\n    \n    maxpoint = 0\n    for c in range(1, N//2):\n        s, l = 0, N-1\n        point = 0\n        if (N-1) % c == 0:\n            while l > s and l > c:\n                point += S[s] + S[l]\n                maxpoint = max(point, maxpoint)\n                s += c\n                l -= c\n        else:\n            while l != s and l > c:\n                point += S[s] + S[l]\n                maxpoint = max(point, maxpoint)\n                s += c\n                l -= c\n    print(maxpoint)\n    return 0\n  \ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\ndef main():\n    N = II()\n    S = LI()\n    ans = 0\n    for C in range(1, N):\n        tmp = 0\n        L = 0\n        R = N - 1\n        lim = (N - 1 - C) if (N - 1) % C else (N // 2)\n        while L < lim:\n            tmp += S[L] + S[R]\n            ans = max(ans, tmp)\n            L += C\n            R -= C\n    return ans\n\nprint(main())", "n = int(input())\na = [int(i) for i in input().split()]\n\nans = 0\nfor C in range(1, n):\n    f = 0\n    for k in range([int(((n - 1) / C + 1) / 2), int((n - 1) / C)][(n - 1) % C != 0]):\n        f += a[k * C] + a[(n - 1) - k * C]\n        ans = max(ans, f)\nprint(ans)", "from collections import defaultdict\nN = int( input())\nS = list( map( int, input().split()))\n\nans = 0\nfor c in range(1,N):\n    now = 0\n    for t in range(c ,N, c):\n        if ((N-1-t)%c == 0 and N-1-t <= t) or N-1-t - c <=0:\n            break\n        now += S[t] + S[N-1-t]\n        if now > ans:\n            ans = now\nprint(ans)\n", "import sys\nimport itertools\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n \n    def __str__(self):\n        return str(self.v)\n \n    def ud(self, n):\n        if self.v is None:\n            self.v = n\n        else:\n            self.v = self.f(self.v, n) \n\n\ndef main():\n    N = int(input())\n    S = read_list()\n\n    res = V(max, 0)\n    for c in range(1, N):\n        r = 0\n        t1 = 0\n        t2 = N - 1\n        while True:\n            t1 += c\n            t2 -= c\n            if t2 < c:\n                break\n            \n            if (N - 1) % c == 0 and 2 * t2 <= N - 1:\n                break\n\n            r += S[t1] + S[t2]\n            res.ud(r)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\ndef main():\n    N = II()\n    S = LI()\n    S = S[:-1]\n    ans = 0\n    for C in range(1, N):\n        tmp = 0\n        L = 0\n        lim = (N - 1 - C) if (N - 1) % C else (N // 2)\n        while L < lim:\n            tmp += S[L] + S[-L]\n            ans = max(ans, tmp)\n            L += C\n    return ans\n\nprint(main())", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    S = list(map(int, input().split()))\n\n    ans = 0\n    for C in range(1, N):\n        n = N // C\n        dp = [0] * n\n        used = set([0])\n        for k in range(1, n):\n            A = N - 1 - k*C\n            if A in used or k*C in used or A == k*C:\n                break\n            used.add(A)\n            used.add(k*C)\n\n            dp[k] = dp[k-1] + S[A] + S[k*C]\n\n        ans = max(ans, max(dp))\n\n    return ans\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    S = list(map(int, input().split()))\n\n    ans = 0\n    # C = A - B\n    for C in range(1, N//2):\n        n = (N-1) // C\n        point = 0\n        for k in range(1, n):\n            A = N-1 - k*C\n\n            # Check A and B are positive integer, and S_i is not used twice.\n            #\n            # B = A - C and B >= 0, so A must be over C (A > C).\n            #\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n            # or equal kC, the A's value is already used by kC.\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n                break\n\n            point += S[A] + S[k*C]\n            ans = max(ans, point)\n\n    return ans\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nS = tuple(map(int, input().split()))\nans = 0\nfor c in range(1, n-1):\n  temp = 0\n  T = set()\n  for k in range(n):\n    d = c*k\n    if d+c >= n:\n      break\n    if d == n-1-d or d in T or n-1-d in T:\n      break\n    T.add(d)\n    T.add(n-1-d)\n    temp += S[d]+S[n-1-d]\n    ans = max(ans, temp)\nprint(ans)", "import sys\nimport itertools\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n \n    def __str__(self):\n        return str(self.v)\n \n    def ud(self, n):\n        if self.v is None:\n            self.v = n\n        else:\n            self.v = self.f(self.v, n) \n\n\ndef main():\n    N = int(input())\n    S = read_list()\n\n    res = V(max, 0)\n    for c in range(1, N):\n        r = 0\n        t1 = 0\n        while True:\n            t1 += c\n            if t1 > N - 1 - c:\n                break\n            \n            if (N - 1) % c == 0 and 2 * t1 >= N - 1:\n                break\n\n            r += S[t1] + S[N - 1 - t1]\n            res.ud(r)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n\nn = int(input())\ns = [int(i) for i in readline().split()]\n\nn -= 1\nans = 0\n\nfor d in range(1,n+1):\n    a = n-d\n    res = 0\n    p,q = n,0\n    while a >= d:\n        if a <= n-a and n%d == 0: break\n        p -= d\n        q += d\n        res += s[p] + s[q]\n#        print(d,a,res)\n        if res > ans: ans = res\n        a -= d\n    \nprint(ans)    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "n = int(input())\ns = list(map(int, input().split()))\nans = 0\nfor i in range(1, (n-1)//2+1):\n\tres = 0\n\tl, r = i, n-1-i\n\twhile r > i and l != r and l != r+i:\n\t\tres += s[l] + s[r]\n\t\tans = max(ans, res)\n\t\tl += i\n\t\tr -= i\nprint(ans)", "N = int(input())\nS = list(map(int,input().split()))\n\nans = 0\nfor d in range(1,N):\n    max_now = 0\n    if (N-1) % d == 0:\n        now = 0\n\n        i, j = 0, N-1\n        while i < j:\n            now += S[i] + S[j]\n            max_now = max(now, max_now)\n            i += d\n            j -= d\n    else:\n        now = 0\n\n        i, j = 0, N-1\n        while i < N-1 and j > d:\n            now += S[i] + S[j]\n            max_now = max(now, max_now)\n            i += d\n            j -= d\n    \n    ans = max(max_now, ans)\n\nprint(ans)", "n = int(input())\na = [int(item) for item in input().split()]\n\nans = 0\nfor c in range(1, n):\n    visited = set([0, n-1])\n    total = 0\n    for k in range(1, n):\n        odd = n - 1 - k*c\n        even = k * c\n        if even >= n - 1:\n            break\n        if odd < c:\n            break\n        if even in visited:\n            break\n        visited.add(even)\n        if odd in visited:\n            break\n        visited.add(odd)\n        total += a[odd] + a[even]\n        ans = max(ans, total)\n        # print(c, k, total)\n        # print(visited)\nprint(ans)", "N = int(input())\n*S, = map(int, input().split())\n\nans = 0\nfor d in range(1, N):\n    r = k = 0\n    while k*d <= N-1:\n        a = N-1-k*d\n        if a <= d or (a <= k*d and a % d == 0):\n            break\n        r += S[N-1-k*d] + S[k*d]\n        k += 1\n        ans = max(ans, r)\nprint(ans)", "from itertools import accumulate\n\nN, *S = map(int, open(0).read().split())\n\nans = 0\nfor dx in range(1, N - 1):\n\n    k, r = divmod(N - 1, dx)\n    if r == 0:\n        k = (k + 1) // 2\n\n    ans = max(ans, max(accumulate(a + b for a, b in zip(S[:dx * k:dx], S[N - 1:(N - 1) - dx * k:-dx]))))\n\nprint(ans)", "N = int(input())\nslist = list(map(int, input().split()))\nans = 0\nfor C in range(1,N-1,1):\n    score = 0\n    for k in range((N-1)//C):\n        if (k-1)*C == N-1-k*C: #\u4e00\u3064\u524d\u306b\u9078\u3093\u3060\u3068\u3053\u308d\n            break\n        if 2*k*C == N-1: #\u4eca\u304b\u3089\u9078\u3076\u4e8c\u3064\u304c\u540c\u3058\u3068\u3053\u308d\n            break\n        score += slist[k*C]+slist[N-1-k*C]\n        ans = max(ans, score)\nprint(ans)", "n = int(input())\ns = list(map(int, input().split()))\nans = 0\nfor i in range(1, n):\n  l = 0\n  r = n-1\n  cur = 0\n  while True:\n    l += i\n    r -= i\n    if l>=n or r<=i or (r%i==0 and r<=l):\n      break\n    cur += s[l] + s[r]\n    ans = max(ans, cur)\nprint(ans)", "import numpy as np\n\nN = int(input())\nS = np.array([int(x) for x in input().split()],dtype=np.int64)\n\n# \u53f3\u79fb\u52d5\u7740\u5730\u70b9\uff1a\u7b49\u5dee\u6570\u5217\u3001\u30b4\u30fc\u30eb\u542b\u3080\n# \u5de6\u79fb\u52d5\u7740\u5730\u70b9\uff1a\u7b49\u5dee\u6570\u5217\u3001\u30b9\u30bf\u30fc\u30c8\u542b\u3080\n\nanswer = 0\nfor d in range(1,N):\n  # d = A-B\n  cum_left = np.cumsum(S[::d])\n  cum_right = np.cumsum(S[::-1][::d])\n  score = cum_left + cum_right # \u7b49\u5dee\u6570\u5217\u306e\u9577\u3055-1 -> \u5f97\u70b9\n  # \u3042\u3068\u306f\u3001\u305d\u306e\u7d4c\u8def\u304c\u30eb\u30fc\u30eb\u5185\u3067\u5b9f\u73fe\u3067\u304d\u308b\u304b\u3069\u3046\u304b\n  for L,s in enumerate(score):\n    if answer >= s:\n      continue\n    # \u53f3\u5de6\u306b\u9032\u3093\u3067\u3044\u308b\u3053\u3068\u306e\u78ba\u8a8d\n    A = N-1-L*d\n    B = A-d\n    if A <= 0:\n      continue\n    if A<=B:\n      continue\n    if B<=0:\n      continue\n    # \u540c\u3058\u5834\u6240\u3092\u53d6\u3063\u3066\u3044\u306a\u3044\u304b\u306e\u78ba\u8a8d\n    # kd = N-1-ld\u3068\u306a\u308b\u3068\u307e\u305a\u3044\n    # \u7d04\u6570\u306e\u3068\u304d\u3001Ld >= N-Ld\u3060\u3068\u307e\u305a\u3044\n    if (N-1)%d == 0 and 2*L*d >= N-1:\n      continue\n    answer = s\n\nprint(answer)\n", "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nS=list(map(int,input().split()))\n\nANS=0\n\nfor i in range(1,N//2):\n    s=0\n    l=N-1\n    SCORE=0\n\n    if (N-1)%i==0:\n        while l>s and l>i:\n\n            SCORE+=S[s]+S[l]\n            ANS=max(ANS,SCORE)\n            s+=i\n            l-=i\n        #print(SCORE,i,l,s)\n    else:\n        while l!=s and l>i:\n\n            SCORE+=S[s]+S[l]\n            ANS=max(ANS,SCORE)\n            s+=i\n            l-=i\n\n        #print(SCORE,i,l,s)\n\nprint(ANS)", "n = int(input())\nsss = list(map(int, input().split()))\n\nans = 0\nfor c in range(1, n // 2):\n    a = n - 1 - c\n    k = c\n    tmp = 0\n    while a > c and a != k and a + c != k:\n        tmp += sss[a] + sss[k]\n        ans = max(ans, tmp)\n        a -= c\n        k += c\nprint(ans)\n", "N = int(input())\nS = list(map(int, input().split()))\nL = 0;  R = N-1\nans = 0\nfor i in range(1, (N+1)//2):\n    r = R\n    l = L\n    j = 1\n    a = 0\n    Closed = set()\n    while True:\n        l += i\n        Closed.add(l)\n        r -= i\n        if r in Closed:\n            break\n        Closed.add(r)\n        if r < i:\n            break\n        a += S[l] + S[r]\n        ans = max(ans, a)\n        j += 1\nprint(ans)\n", "n = int(input())\ns = list(map(int, input().split()))\n\nans = 0\nfor step in range(1, n):\n    now = 0\n    for i, j in zip(list(range(0, n, step)), list(range(n - 1, -1, -step))):\n        if i == j or i - j == step or j < step:\n            break\n        now += s[i] + s[j]\n        ans = max(ans, now)\nprint(ans)\n", "N = int(input())\nS = list(map(int, input().split()))\n\nans = 0\nfor C in range(1, N):\n    fkC = 0\n    L = 0\n    R = N-1\n    if ((N-1) % C == 0):\n        while L < R:\n            fkC += S[L] + S[R]\n            ans = max(ans, fkC)\n            L += C\n            R -= C\n    else:\n        while L+C < N-1:\n            fkC += S[L] + S[R]\n            ans = max(ans, fkC)\n            L += C\n            R -= C\n\nprint(ans)", "n = int(input())\ns = list(map(int, input().split()))\nMINUS_INF = -float(\"inf\")\nans = 0\nfor c in range(1, n):\n    k = 1\n    tmp_ans = 0\n    while k * c < n - 1:\n        a = (n - 1) - k * c\n        b = a - c\n        if a <= b or b <= 0:\n            tmp_ans = MINUS_INF\n        if a % c == 0 and a // c <= k:\n            tmp_ans = MINUS_INF\n        tmp_ans += s[n-1-k*c] + s[k*c]\n        ans = max(ans, tmp_ans)    \n        k += 1    \nprint(ans)", "import sys\ninput = sys.stdin.readline\nN = int(input())\nS = list(map(int, input().split()))\nN -= 1\nans = 0\nfor d in range(1,N+1):\n    a = N-d\n    res = 0\n    p,q = N,0\n    while a >= d:\n        if a <= N-a and N%d == 0:\n            break\n        p -= d\n        q += d\n        res += S[p] + S[q]\n        if res > ans:\n            ans = res\n        a -= d\n    \nprint(ans)   ", "N = int(input())\ns = list(map(int, input().split()))\nans = 0\nfor c in range(1, N):\n    res = 0\n    for k in range(1, (N-1)//c+1):\n        a = N-1-c*k\n        b = a-c\n        res+=s[c*k]+s[-c*k-1]\n        if b<0 or (a%c==0 and a//c<=k) :\n            continue\n        ans = max(ans, res)\nprint(ans)\n\n\n        \n", "N = int(input())\nss = list(map(int, input().split()))\n\nans = 0\nfor C in range(1, N):\n    score = 0\n    for k in range(1, (N-1)//C+1):\n        if (N-1)%C == 0 and k*C >= N-1-k*C: break\n        if N-1-k*C <= C: break\n        score += ss[k*C] + ss[N-1-k*C]\n        ans = max(ans, score)\n\nprint(ans)\n", "N = int(input())\nS = [int(a) for a in input().split()]\nma = 0\nfor C in range(1, N-1):\n    s = 0\n    for k in range((N-2) // C):\n        A = N-1-k*C\n        if A % C == 0 and A//C <= k: continue\n        s += S[k*C] + S[-1-k*C]\n        ma = max(ma, s)\n\nprint(ma)", "n = int(input())\ns = list(map(int,input().split()))\n\nans = 0\n\nfor c in range(1,n-1):\n  if (n-1)%c == 0:\n    p = ((n-1)//c-1)//2 \n  else:\n    p = (n-1)//c-1\n    if p <= 0:\n      break\n  if p <= 0:\n    continue\n  m = 0\n  k = 0\n  for i in range(1,p+1):\n    k += s[c*i] + s[n-1-c*i]\n    m = max(m,k)\n  ans = max(ans,m)\n    \n    \nprint(ans)", "N = int(input())\nS = list(map(int,input().split()))\n\nans = 0\nfor C in range(1,N):\n    dp = 0\n    for k in range((N-1)//C):\n        if (2*k-1)*C == N-1 or 2*k*C == N-1:\n            break\n        dp += S[N-1-C*k]+S[C*k]\n        ans = max(ans,dp)\n\nprint(ans)", "###############################################################################\n\nfrom sys import stdout\nfrom bisect import bisect_left as binl\nfrom copy import copy, deepcopy\nfrom collections import defaultdict\nimport math\n\n\nmod = 1\n\n\ndef intin():\n    input_tuple = input().split()\n    if len(input_tuple) <= 1:\n        return int(input_tuple[0])\n    return tuple(map(int, input_tuple))\n\n\ndef intina():\n    return [int(i) for i in input().split()]\n\n\ndef intinl(count):\n    return [intin() for _ in range(count)]\n\n\ndef modadd(x, y):\n    nonlocal mod\n    return (x + y) % mod\n\n\ndef modmlt(x, y):\n    nonlocal mod\n    return (x * y) % mod\n\n\ndef lcm(x, y):\n    while y != 0:\n        z = x % y\n        x = y\n        y = z\n    return x\n\n\ndef combination(x, y):\n    assert(x >= y)\n\n    ret = math.factorial(x)\n    ret = ret // (math.factorial(x - y) * math.factorial(y))\n\n    return ret\n\n\ndef get_divisors(x):\n    retlist = []\n    for i in range(1, int(x**0.5) + 3):\n        if x % i == 0:\n            retlist.append(i)\n            retlist.append(x // i)\n    return retlist\n\n\ndef get_factors(x):\n    retlist = []\n    for i in range(2, int(x**0.5) + 3):\n        while x % i == 0:\n            retlist.append(i)\n            x = x // i\n    retlist.append(x)\n    return retlist\n\n\ndef make_linklist(xylist):\n    linklist = {}\n    for a, b in xylist:\n        linklist.setdefault(a, [])\n        linklist.setdefault(b, [])\n        linklist[a].append(b)\n        linklist[b].append(a)\n    return linklist\n\n\ndef calc_longest_distance(linklist, v=1):\n    distance_list = {}\n    distance_count = 0\n    distance = 0\n    vlist_previous = []\n    vlist = [v]\n    nodecount = len(linklist)\n\n    while distance_count < nodecount:\n        vlist_next = []\n        for v in vlist:\n            distance_list[v] = distance\n            distance_count += 1\n            vlist_next.extend(linklist[v])\n        distance += 1\n        vlist_to_del = vlist_previous\n        vlist_previous = vlist\n        vlist = list(set(vlist_next) - set(vlist_to_del))\n\n    max_distance = -1\n    max_v = None\n    for v, distance in list(distance_list.items()):\n        if distance > max_distance:\n            max_distance = distance\n            max_v = v\n\n    return (max_distance, max_v)\n\n\ndef calc_tree_diameter(linklist, v=1):\n    _, u = calc_longest_distance(linklist, v)\n    distance, _ = calc_longest_distance(linklist, u)\n    return distance\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.root(self.parent[i])\n        return self.parent[i]\n\n    def unite(self, i, j):\n        rooti = self.root(i)\n        rootj = self.root(j)\n        if rooti == rootj:\n            return\n        if rooti < rootj:\n            self.parent[rootj] = rooti\n        else:\n            self.parent[rooti] = rootj\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n\n###############################################################################\n\n\ndef main():\n    n = intin()\n    alist = intina()\n\n    ans = 0\n\n    for i in range(1, n//2):\n        lsum = 0\n        for j in range(1, n):\n            down = n - i * j - 1\n            up = i * j\n            if (down <= up and down % i == 0):\n                break\n            if (down <= i):\n                break\n            if (n - 1 - up <= i):\n                break\n            lsum += alist[down]\n            lsum += alist[up]\n            ans = max(ans, lsum)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# youtube\nn = int(input())\ns = list(map(int, input().split()))\nans = 0\nfor d in range(1, n - 1):\n    ten = 0\n    passed = set([0, n - 1])\n    l = 0\n    r = n - 1\n    for _ in range((n - 1) // d):\n        l += d\n        r -= d\n        if l in passed or r in passed or l==r or r < d:\n            break\n        ten += s[l]\n        ten += s[r]\n        passed.add(l)\n        passed.add(r)\n        if ten > ans:\n            ans = ten\nprint(ans)\n", "N=int(input())\ns=[int(i) for i in input().split()]\nans=0\nfor C in range(1,N):\n    fkC=0\n    L=0;R=N-1\n    if ((N-1)%C==0):\n        while(L<R):\n            fkC+=s[L]+s[R]\n            ans=max(ans,fkC)\n            L+=C\n            R-=C\n    else:\n        while(L+C<N-1):\n            fkC+=s[L]+s[R]\n            ans=max(ans,fkC)\n            L+=C\n            R-=C\nprint(ans)", "n = int(input())\nl = list(map(int,input().split()))\n\nans = 0\nfor c in range(1,n):\n    now = 0\n    pas = set()\n    for k in range(1,n):\n        if k * c > n-1 or n-1-k*c <= c:\n            break\n        if n-1-k*c in pas or k*c in pas or n-1 == 2*k*c:\n            break \n        now += l[n-1-k*c] + l[k*c]\n        pas.add(n-1-k*c)\n        pas.add(k*c)\n        ans = max(ans,now)\n        \nprint(ans)\n", "N = int(input())\ns = list(map(int, input().split()))\nans = 0\nfor C in range(1,N):\n    t = 0\n    for x in range(C, N-1-C if (N-1)%C != 0 else N//2, C):\n        t += s[x] + s[-x-1]\n        ans = max(ans, t)\nprint(ans)", "n,*s=map(int,open(0).read().split());a=0\nfor i in range(1,n):\n t=0\n for j in range(0,[n//2,n+~i][(n-1)%i>0],i):t+=s[j]+s[~j];a=max(a,t)\nprint(a)", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    S = list(map(int, input().split()))\n\n    ans = 0\n    for C in range(1, N//2):\n        n = N // C\n        point = 0\n        used = set([0])\n        for k in range(1, n):\n            A = N - 1 - k*C\n\n            if A in used or k*C in used or A == k*C:\n                break\n            used.add(A)\n            used.add(k*C)\n\n            point += S[A] + S[k*C]\n            ans = max(ans, point)\n\n    return ans\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "n = int(input())\nv = list(map(int, input().split()))\nans = 0\nfor k in range(1, n):\n\tp, s = k, 0\n\twhile p < n:\n\t\tr = n - p - 1\n\t\tif r <= k:\n\t\t\tbreak\n\t\ts += v[p] + v[n - 1 - p]\n\t\tif r % k != 0 or p < r:\n\t\t\tans = max(ans, s)\n\t\tp += k\nprint(ans)", "import itertools\nN = int(input())\nS = [int(_) for _ in input().split()]\n\nans = 0\nfor i in range(1, N - 1):\n    maxj = (N - 1) // i\n    if (N - 1) % i == 0:\n        maxj = ((N - 1) // i + 1) // 2\n    dp = itertools.accumulate(\n        x + y for x, y in zip(S[:i * maxj:i], S[-1:-1 - i * maxj:-i]))\n    ans = max(ans, max(dp))\nprint(ans)\n", "def f_frog_jump(N, S):\n    ans = 0\n    for c in range(1, N):\n        # k=0\u306e\u3068\u304d\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u98db\u3076\u3057\u304b\u306a\u3044(\u5f97\u70b90)\u306e\u3067\u3001k=1\u304b\u3089\u59cb\u3081\u308b\n        current_ans, k = 0, 1\n        while k * c < N - 1:\n            a = N - 1 - k * c\n            b = a - c\n            # k, c\u3092\u6c7a\u3081\u305f\u3068\u304d\u3001\u9032\u3080\u8ddd\u96e2<=\u623b\u308b\u8ddd\u96e2\u306b\u306a\u308b(\u8ca0\u306e\u5ea7\u6a19\u306b\u5230\u9054\u3059\u308b)\u304b\u3001\n            # \u540c\u3058\u5ea7\u6a19\u306b\u8907\u6570\u56de\u5230\u9054\u3059\u308b\u5834\u5408\u3001\u5f97\u70b9\u3092\u8a08\u7b97\u3059\u308b\u610f\u5473\u304c\u306a\u3044\n            if not (a <= b or b <= 0 or (a % c == 0 and a <= k * c)):\n                current_ans += S[N - 1 - k * c] + S[k * c]\n                ans = max(ans, current_ans)\n            k += 1\n    return ans\n    # \u53c2\u8003: http://sigma1113.hatenablog.com/entry/2019/05/27/181729\n\nN = int(input())\nS = [int(i) for i in input().split()]\nprint(f_frog_jump(N, S))", "def cumsum(itr):\n    arr = []\n    val = 0\n    for x in itr:\n        val += x\n        arr.append(val)\n    return arr\n\n\ndef main(N, scores):\n    M = N - 1\n\n    def max_score(d):\n        steps = (scores[i] + scores[-i - 1] for i in range(0, M - d, d))\n        cum_scores = cumsum(steps)\n\n        if M % d > 0:\n            return max(cum_scores)\n        else:\n            k = M // d + 1\n            return max(cum_scores[: k // 2])\n\n    corner_case = scores[0] + scores[M]\n    otherwise = max(max_score(d) for d in range(1, M))\n    return max(corner_case, otherwise)\n\n\nN = int(input())\nscores = [int(a) for a in input().split()]\nresult = main(N, scores)\n\nprint(result)", "import sys\nimport itertools\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n \n    def __str__(self):\n        return str(self.v)\n \n    def ud(self, n):\n        if self.v is None:\n            self.v = n\n        else:\n            self.v = self.f(self.v, n) \n\n\ndef main():\n    N = int(input())\n    S = read_list()\n\n    res = V(max, 0)\n    for c in range(1, N):\n        r = 0\n        t1 = 0\n        t2 = N - 1\n        a = t2 - c\n        while True:\n            if a < c:\n                break\n            \n            if (N - 1) % c == 0 and 2 * a <= N - 1:\n                break\n\n            t1 += c\n            t2 -= c\n            a -= c\n            r += S[t1] + S[t2]\n            res.ud(r)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["#!/usr/bin/env python3\n\nimport sys\ninput=sys.stdin.readline\n\nclass BIT:\n  def __init__(self,n):\n    self.n=n+1\n    self.BIT=[0]*self.n\n  def add(self,i,x):\n    idx=i\n    while idx<self.n:\n      self.BIT[idx]+=x\n      idx+=(idx&-idx)\n  def _sum(self,i):\n    if i==-1:\n        return -1\n    ret=0\n    idx=i\n    while idx>0:\n      ret+=self.BIT[idx]\n      idx-=(idx&-idx)\n    return ret\n  def sum(self,l,r):\n    return self._sum(r)-self._sum(l-1)\n  def value(self,i):\n    return self._sum(i)-self._sum(i-1)\n\nbound=10**6\nn,m=map(int,input().split())\nyoko_edges=[list(map(int,input().split())) for _ in range(n)]\nyoko_edges=sorted(yoko_edges,reverse=True,key=lambda x:x[0])\nue_tate_edges=[[] for _ in range(bound+1)]\nsita_tate_edges=[[] for _ in range(bound+1)]\ntate_edges=BIT(bound)\ntate_edges.add(bound,1)\nans=1\nfor _ in range(m):\n    x,l,r=map(int,input().split())\n    if l==0 and r==bound:\n        tate_edges.add(x,1)\n        ans+=1\n    elif l==0:\n        sita_tate_edges[r].append(x)\n    elif r==bound:\n        ue_tate_edges[l].append(x)\n        tate_edges.add(x,1)\nprev=bound-1\nfor y,l,r in yoko_edges:\n    while prev>=y:\n        for x in sita_tate_edges[prev]:\n            tate_edges.add(x,1)\n        for x in ue_tate_edges[prev+1]:\n            tate_edges.add(x,-1)\n        prev-=1\n    ans+=tate_edges.sum(l,r)-1\nprint(ans)", "#!/usr/bin/env python3\n\nimport sys\ninput=sys.stdin.readline\n\nclass BIT:\n  def __init__(self,n):\n    self.n=n+1\n    self.BIT=[0]*self.n\n  def add(self,i,x):\n    idx=i\n    while idx<self.n:\n      self.BIT[idx]+=x\n      idx+=(idx&-idx)\n  def _sum(self,i):\n    if i==-1:\n        return -1\n    ret=0\n    idx=i\n    while idx>0:\n      ret+=self.BIT[idx]\n      idx-=(idx&-idx)\n    return ret\n  def sum(self,l,r):\n    return self._sum(r)-self._sum(l-1)\n  def value(self,i):\n    return self._sum(i)-self._sum(i-1)\n\nbound=10**6\nn,m=map(int,input().split())\nyoko_edges=[list(map(int,input().split())) for _ in range(n)]\nyoko_edges=sorted(yoko_edges,reverse=True,key=lambda x:x[0])\nue_tate_edges=[[] for _ in range(bound+1)]\nsita_tate_edges=[[] for _ in range(bound+1)]\ntate_edges=BIT(bound)\ntate_edges.add(bound,1)\nans=1\nfor _ in range(m):\n    x,l,r=map(int,input().split())\n    if l==0 and r==bound:\n        tate_edges.add(x,1)\n        ans+=1\n    elif l==0:\n        sita_tate_edges[r].append(x)\n    elif r==bound:\n        ue_tate_edges[l].append(x)\n        tate_edges.add(x,1)\nprev=bound-1\nfor y,l,r in yoko_edges:\n    while prev>=y:\n        for x in sita_tate_edges[prev]:\n            tate_edges.add(x,1)\n        for x in ue_tate_edges[prev+1]:\n            tate_edges.add(x,-1)\n        prev-=1\n    ans+=tate_edges.sum(l,r)-1\nprint(ans)", "import sys\ninput=sys.stdin.readline\n\nclass BIT:\n  def __init__(self,n):self.n=n+1;self.BIT=[0]*self.n\n  def add(self,i,x):\n    idx=i\n    while idx<self.n:self.BIT[idx]+=x;idx+=(idx&-idx)\n  def _sum(self,i):\n    if i==-1:return -1\n    ret=0;idx=i\n    while idx>0:ret+=self.BIT[idx];idx-=(idx&-idx)\n    return ret\n  def sum(self,l,r):return self._sum(r)-self._sum(l-1)\n  def value(self,i):return self._sum(i)-self._sum(i-1)\n\nbound=10**6\nn,m=map(int,input().split())\nyoko_edges=[list(map(int,input().split())) for _ in range(n)]\nyoko_edges=sorted(yoko_edges,reverse=True,key=lambda x:x[0])\nue_tate_edges=[[] for _ in range(bound+1)]\nsita_tate_edges=[[] for _ in range(bound+1)]\ntate_edges=BIT(bound)\ntate_edges.add(bound,1)\nans=1\nfor _ in range(m):\n    x,l,r=map(int,input().split())\n    if l==0 and r==bound:tate_edges.add(x,1);ans+=1\n    elif l==0:sita_tate_edges[r].append(x)\n    elif r==bound:ue_tate_edges[l].append(x);tate_edges.add(x,1)\nprev=bound-1\nfor y,l,r in yoko_edges:\n    while prev>=y:\n        for x in sita_tate_edges[prev]:tate_edges.add(x,1)\n        for x in ue_tate_edges[prev+1]:tate_edges.add(x,-1)\n        prev-=1\n    ans+=tate_edges.sum(l,r)-1\nprint(ans)", "import sys\ninput=sys.stdin.readline\nclass BIT:\n  def __init__(self,n):self.n=n+1;self.BIT=[0]*self.n\n  def add(self,i,x):\n    idx=i\n    while idx<self.n:self.BIT[idx]+=x;idx+=(idx&-idx)\n  def _sum(self,i):\n    if i==-1:return -1\n    ret=0;idx=i\n    while idx>0:ret+=self.BIT[idx];idx-=(idx&-idx)\n    return ret\n  def sum(self,l,r):return self._sum(r)-self._sum(l-1)\n  def value(self,i):return self._sum(i)-self._sum(i-1)\nbound=10**6;n,m=map(int,input().split());yoko_edges=[list(map(int,input().split())) for _ in range(n)];yoko_edges=sorted(yoko_edges,reverse=True,key=lambda x:x[0])\nue_tate_edges=[[] for _ in range(bound+1)];sita_tate_edges=[[] for _ in range(bound+1)];tate_edges=BIT(bound);tate_edges.add(bound,1);ans=1\nfor _ in range(m):\n    x,l,r=map(int,input().split())\n    if l==0 and r==bound:tate_edges.add(x,1);ans+=1\n    elif l==0:sita_tate_edges[r].append(x)\n    elif r==bound:ue_tate_edges[l].append(x);tate_edges.add(x,1)\nprev=bound-1\nfor y,l,r in yoko_edges:\n    while prev>=y:\n        for x in sita_tate_edges[prev]:tate_edges.add(x,1)\n        for x in ue_tate_edges[prev+1]:tate_edges.add(x,-1)\n        prev-=1\n    ans+=tate_edges.sum(l,r)-1\nprint(ans)"]
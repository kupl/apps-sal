["N, M = map(int, input().split())\nEdge = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    Edge.append([a, b])\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n            self.size[x] = 0\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            self.size[y] = 0\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n    def all_find(self):\n        for n in range(len(self.par)):\n            self.find(n)\n\n\nUF = UnionFind(N)\nScore = N * (N - 1) // 2\nans = []\nwhile Edge:\n    ans.append(Score)\n    a, b = Edge.pop()\n    pa, pb = UF.find(a), UF.find(b)\n    if not UF.same(pa, pb):\n        Score -= (UF.size[pa] * UF.size[pb])\n    UF.union(a, b)\n\nprint(*ans[::-1], sep='\\n')\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef combinations_count(n, r):\n    if n<=1:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nimport math\nfrom collections import deque\nn, m = map(int, input().split())\nms = [list(map(int, input().split())) for _ in range(m)]\nms.reverse()\ncombs = combinations_count(n, 2)\nres = deque([combs])\nuf = UnionFind(n)\nfor i in ms[:-1]:\n    if not (uf.same(i[0]-1,i[1]-1)):\n        combs -= uf.size(i[0]-1)*uf.size(i[1]-1)\n    res.appendleft(combs)\n    uf.union(i[0] - 1, i[1] - 1)\nfor i in res:\n    print(i)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\nuf = UnionFind(N)\nab_list = []\nans =0\nfor i in range(M):\n    a,b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    ab_list.append([a, b])\n\nans_list = [0 for i in range(M)]\nfor i in range(M, 0, -1):\n    if i == M:\n        ans_list[i-1] = N*(N-1)//2\n    else:\n        if uf.find(ab_list[i][0]) != uf.find(ab_list[i][1]):\n            ans_list[i-1] = ans_list[i] - uf.size(ab_list[i][0])*uf.size(ab_list[i][1])\n        else:\n            ans_list[i-1] = ans_list[i]\n        uf.union(ab_list[i][0], ab_list[i][1])\nprint((*ans_list))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    \nn,m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\na.reverse()\nuf = UnionFind(n)\nans = n*(n-1)//2\nanslist = []\nfor i in range(m):\n    anslist.append(ans)\n    x,y = a[i][0],a[i][1]\n    if uf.same(x-1,y-1):\n        continue\n    ans -= (uf.size(x-1) * uf.size(y-1))\n    uf.union(x-1,y-1)\nanslist.reverse()\nprint(*anslist, sep=\"\\n\")\n    ", "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\nN,M=map(int,input().split())\nsys.setrecursionlimit(200000)\nb=[tuple(map(lambda x: int(x)-1, input().split())) for i in range(M)]\nclass uf:\n    def __init__(self,n):\n        self.n=n\n        self.l=[-1]*n\n    def ro(self,n):         #root\n        if self.l[n]<0:\n            return n\n        r=self.ro(self.l[n])\n        self.l[n]=r\n        return r\n    def me(self,a,b):       #merge\n        ra=self.ro(a)\n        rb=self.ro(b)\n        if self.l[ra]>self.l[rb]:\n            ra,rb=rb,ra\n        if ra!=rb:\n            self.l[ra]+=self.l[rb]\n            self.l[rb]=ra\n    def size(self,n):\n        return -self.l[self.ro(n)]\n    def sa(self,a,b):       #same\n        return self.ro(a)==self.ro(b)\n    def rl(self):           #roots list\n        return [i for i,v in enumerate(self.l) if v<0]\n    \n    def len(self):          #len(roots)\n        return len(self.rl())\n    def ul(self):\n        d={n:i for i,n in enumerate(self.rl())}\n        m=[[]for i in range(self.len())]\n        for i in range(self.n):\n            m[d[self.ro(i)]].append(i)\n        return m\n    def __str__(self):\n        return f\"{self.ul()}\"\nl=[0]*M\ns=uf(N)\nh=N*(N-1)//2\nfor i in range(M-1,-1,-1):\n    l[i]=h\n    if s.ro(b[i][0])!=s.ro(b[i][1]):\n        h-=s.size(b[i][0])*s.size(b[i][1])\n        s.me(b[i][0],b[i][1])\nprint(*l,sep=\"\\n\")", "class Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nuf = Unionfind(N)\n\nans = []\ncombi = (N*(N-1))//2\nans.append(combi)\ntmp = 0\n\nbr = [list(map(int, input().split())) for _ in range(M)]\nbr = br[::-1]\n\nfor i in range(M-1):\n    a = br[i][0]-1\n    b = br[i][1]-1\n    \n    if(uf.same(a, b)):\n        ans.append(combi-tmp)\n    else:\n        ax = uf.size(a)\n        bx = uf.size(b)\n        \n        uf.union(a, b)\n        \n        tmp += ax*bx\n        ans.append(combi-tmp)\n\nfor x in ans[::-1]:\n    print(x)", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        #\u89aa\u8981\u7d20\u306e\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u683c\u7d0d\u3000x\u304c\u6839\u306e\u3068\u304d-(\u30b5\u30a4\u30ba)\u3092\u683c\u7d0d\n        self.par = [-1 for i in range(n)]\n        self.n = n\n\n    def find(self, x):\n        #\u6839\u306a\u3089\u305d\u306e\u756a\u53f7\u3092\u8fd4\u3059\n        if self.par[x] < 0:\n            return x\n        else:\n            #\u89aa\u306e\u89aa\u306f\u89aa\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def is_same(self, x, y):\n        #\u6839\u304c\u540c\u3058\u306a\u3089True\n        return self.find(x) == self.find(y)\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y: return\n\n        #\u6728\u306e\u30b5\u30a4\u30ba\u3092\u6bd4\u8f03\u3057\u3001\u5c0f\u3055\u3044\u307b\u3046\u304b\u3089\u5927\u304d\u3044\u307b\u3046\u3078\u3064\u306a\u3050\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.par) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n#\u96a3\u63a5\u30ea\u30b9\u30c8 1-order\ndef make_adjlist_nond(n, edges):\n    res = [[] for _ in range(n+1)]\n    for edge in edges:\n        res[edge[0]].append(edge[1])\n        res[edge[1]].append(edge[0])\n    return res\n\n\ndef main():\n    N, M = NMI()\n    edges = [NLI() for _ in range(M)]\n\n    uf = UnionFind(N)\n    ans = [0]*(M+1)\n    for i in range(M, 0, -1):\n        if i == M:\n            ans[i] = N * (N - 1) // 2\n            continue\n\n        x, y = edges[i][0] - 1, edges[i][1] - 1\n        if uf.is_same(x, y):\n            ans[i] = ans[i+1]\n            continue\n        num = uf.size(x) * uf.size(y)\n        uf.unite(x, y)\n        ans[i] = ans[i+1] - num\n\n    for a in ans[1:]:\n        print(a)\n\ndef __starting_point():\n    main()\n__starting_point()", "def find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x, y = find(x), find(y)\n    if x == y:\n        return False\n    \n    if par[x] > par[y]:\n        x,y = y,x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef size(x):\n    return -par[find(x)]\n\nn, m = map(int, input().split())\nab = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    ab.append([a-1, b-1])\npar = [-1]*n\nans = n*(n-1)//2\nansl = [ans]\nfor a, b in ab[::-1]:\n    if find(a)!=find(b):\n        ans -= size(a)*size(b)\n    unite(a, b)\n    ansl.append(ans)\nfor i in range(m-1, -1, -1):\n    print(ansl[i])", "n,m = map(int,input().split())\nedges = []\nfor _ in range(m):\n    edges.append(list(map(int,input().split())))\nans = []\ncur = ((n-1)*n)//2\npar = {i:i for i in range(1,n+1)}\nsize = {i:1 for i in range(1,n+1)}\nrank = {i:0 for i in range(1,n+1)}\ndef find(x):\n    if x != par[x]:\n        par[x] = find(par[x])\n    return par[x]\n\ndef union(x,y):\n    px,py = find(x),find(y)\n    res = 0\n    if px != py:\n        res = size[px] * size[py]\n        if rank[px] < rank[py]:\n            par[px] = py\n            size[py] += size[px]\n        else:\n            par[py] = px\n            size[px] += size[py]\n            if rank[px] == rank[py]:\n                rank[px] += 1\n    return res\n\nfor i in range(m-1,-1,-1):\n    ans.append(cur)\n    x,y = edges[i]\n    cur -= union(x,y)\nfor i in range(m-1,-1,-1):\n    print(ans[i])", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        \"\"\"\n        \u89aa\u304c\u540c\u3058\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"\n        y\u3092x\u306e\u6839\u306b\u7e4b\u3050\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        \"\"\"\n        x\u3068y\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u5224\u5225\u3059\u308b\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"\n        x\u306e\u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def kruskal(self, edge):\n        \"\"\"\n        :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n        :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n        \"\"\"\n        edge.sort()\n        cost_sum = 0\n        for cost, node1, node2 in edge:\n            if not self.same(node1, node2):\n                cost_sum += cost\n                self.union(node1, node2)\n        return cost_sum\n\n\ndef resolve():\n    n, m = map(int, input().split())\n    edge = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(m)]\n    uf = UnionFind(n)\n    res = [(n - 1) * n // 2]\n    for i in reversed(range(1, m)):\n        a, b = edge[i]\n        if not uf.same(a, b):\n            res.append(res[-1] - uf.size(a) * uf.size(b))\n            uf.union(a, b)\n        else:\n            res.append(res[-1])\n    print(*res[::-1], sep=\"\\n\")\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \nn,m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\nabb = ab[::-1]\nuf = UnionFind(n)\n\nini = (n*(n-1))//2\nres = [ini]\ntemp=0\nfor i in range(m-1):\n    a = abb[i][0]-1\n    b = abb[i][1]-1\n    ax =uf.size(a)\n    bx =uf.size(b)\n    if uf.same(a,b):\n        pass\n    else:\n        uf.union(a,b)\n        temp += ax*bx\n    res.append(ini-temp)\n    \nress = res[::-1]\nfor i in range(m):\n    print(ress[i])", "def root(i):\n    if par[i] < 0:\n        return i\n    else:\n        return root(par[i])\n\ndef size(a):\n    return -par[root(a)]\n\ndef union(a,b):\n    a = root(a)\n    b = root(b)\n    if a == b:#\u89aa\u304c\u7b49\u3057\u3044\n        return False\n    if size(a) < size(b):#\u30b5\u30a4\u30ba\u304c\u5927\u304d\u3044\u65b9\u306b\u7e4b\u3052\u308b\n        a,b = b,a\n    par[a] += par[b]\n    par[b] = a\n    return True\n\nn,m = map(int,input().split())\nbridge = []\nfor i in range(m):\n    bridge.append([int(j)-1 for j in input().split()])\nans = [n*(n-1)//2]\npar = [-1 for _ in range(n)]\n\nfor a,b in bridge[::-1]:\n    if root(a) == root(b):\n        ans.append(ans[-1])\n    else:\n        ans.append(ans[-1] - size(a) * size(b))\n        union(a,b)\nans = ans[::-1]\nfor i in ans[1:]:\n    print(i)", "# \u8fba\u3092\u6d88\u3057\u3066\u3044\u304f\u64cd\u4f5c\u306f\u96e3\u3057\u3044\n# \u64cd\u4f5c\u3092\u9006\u304b\u3089\u8003\u3048\u3001\u8fba\u3092\u8db3\u3057\u3066\u3044\u304f\u3068\u8003\u3048\u308b\n#####################\n\n\nclass UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, v):  # v\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u6839\u3092\u8fd4\u3059\n        if self.parents[v] < 0:\n            return v\n        else:\n            self.parents[v] = self.find(self.parents[v])\n            return self.parents[v]\n\n    def unite(self, u, v):  # \u300cu\u304c\u5c5e\u3059\u308b\u96c6\u5408\u300d\u3068\u300cv\u304c\u5c5e\u3059\u308b\u96c6\u5408\u300d\u3092\u4f75\u5408\uff08\u6839\u540c\u58eb\u3092\u7d50\u3076\uff09\n        u = self.find(u)\n        v = self.find(v)\n\n        if u == v:\n            return\n\n        if self.parents[u] > self.parents[v]:  # u < v \u306b\u7d71\u4e00\u3059\u308b\n            u, v = v, u\n\n        self.parents[u] += self.parents[v]\n        self.parents[v] = u\n\n    def size(self, v):  # v\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u6570\n        return -self.parents[self.find(v)]\n\n    def same(self, u, v):  # u\u3068v\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5426\u304b\n        return self.find(u) == self.find(v)\n############################################\nN, M = list(map(int, input().split()))\nuf = UnionFind(N)\nedges = []\n\nfor i in range(M):\n    A, B = list(map(int, input().split()))\n    # 0-index\u306b\u76f4\u3059\n    edges.append((A - 1, B - 1))\n\n# n_C_2 = N*(N-1)//2\n# [\u8fba\u304c(M-1)\u672c(=1\u672c\u5d29\u843d), ..., \u8fba\u304c1\u672c(=M-1\u672c\u5d29\u843d), \u8fba\u304c0\u672c(=M\u672c\u5d29\u843d)]\n# [-1]\u306fn_C_2\u306e\u307e\u307e\u3001[-2]\u304b\u3089[-M]\u306b\u5411\u304b\u3063\u3066\u9006\u9806\u306b\u66f4\u65b0\u3057\u3066\u3044\u304f\uff08\u8fba\u3092\u5897\u3084\u3057\u3066\u3044\u304f\uff09\n\ntotal = [N * (N - 1) // 2 for _ in range(M)]\n\n# -i-1 = -1,-2,...,-(M-1)\n# -i-2 = -2,-3,...,-M\nfor i in range(M - 1):\n    u, v = edges[-i - 1]\n    # \u65e2\u306b\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u306a\u3089\u3001\u8fba\u3092\u8db3\u3057\u3066\u3082\u3001\u884c\u304d\u6765\u51fa\u6765\u306a\u3044\u7d44\u307f\u5408\u308f\u305b\u6570\u306f\u5909\u308f\u3089\u306a\u3044\uff08\u6e1b\u3089\u306a\u3044\uff09\n    if uf.same(u, v):\n        total[-i - 2] = total[-i - 1]\n    # u\u3068v\u304c\u7570\u306a\u308b\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u5834\u5408\n    # \u8fba\u3092\u5f35\u308b\u3053\u3068\u3067\u3001\u30c0\u30e1\u306a\u7d44\u307f\u5408\u308f\u305b\u304c(u\u306e\u8981\u7d20\u6570)*(v\u306e\u8981\u7d20\u6570)\u3060\u3051\u6e1b\u308b\u3000\uff08\u884c\u304d\u6765\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\uff09\n    else:\n        total[-i - 2] = total[-i - 1] - uf.size(u) * uf.size(v)\n        uf.unite(u, v)\n\nfor t in total:\n    print(t)\n", "import sys\ninput = sys.stdin.readline\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n, m = map(int, input().split())\n    abl = []\n    for _ in range(m):\n        a,b = map(int, input().split())\n        abl.append([a,b])\n\n    uf = UnionFind(n)\n    ans_r = []\n    curr_ans_minus = 0\n    for ab in reversed(abl):\n        a,b = ab\n        if not uf.same(a-1,b-1): \n            a_size = uf.size(a-1)\n            b_size = uf.size(b-1)\n            curr_ans_minus += (a_size+b_size)*(a_size+b_size-1)//2\n            curr_ans_minus -= (a_size*(a_size-1)//2 + b_size*(b_size-1)//2)\n            uf.union(a-1,b-1)\n        ans_r.append(curr_ans_minus)\n\n\n    all_sum = n*(n-1)//2\n    for v in reversed(ans_r[:-1]):\n        print(all_sum-v)\n    print(all_sum)\n\ndef __starting_point():\n    main()\n__starting_point()", "N,M = map(int, input().split())\nE = []\nfor _ in range(M):\n  a,b = map(int, input().split())\n  E.append((a-1,b-1))\n\n## https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n###\nuf = UnionFind(N)\n\nans = [0] * (M+1)\nans[M] = N*(N-1) // 2\n  \nfor i in range(M-1,-1,-1):\n  a,b = E[i]\n  if uf.same(a,b):\n    ans[i] = ans[i+1]\n  else:\n    # union\n    _t, _u = uf.size(a), uf.size(b)\n    uf.union(a,b)\n    #_v = uf.size(a)\n    ans[i] = ans[i+1] - _t*_u\n  \nfor i in range(1,M+1):\n  print(ans[i])", "# /////[UnionFind\u6e96\u5099]//////////////////////////////////////////////////////\nclass UnionFind(): # 0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        '''\n        x\u3068y\u306f-=1\u3057\u3066\u4f7f\u3046\n        '''\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# /////[main]]//////////////////////////////////////////////////////\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    bridges = [tuple(map(int, input().split())) for _ in range(M)]\n\n    answer_list = []\n    total = N * (N-1) // 2\n    answer_list.append(total)\n    # \u3059\u3079\u3066\u5d29\u843d\u3057\u305f\u3068\u3053\u308d\u304b\u3089\u9006\u306b\u8abf\u3079\u3066\u3044\u304f\n    union_find = UnionFind(N)\n    for i in range(M-1, 0, -1):\n        A, B = bridges[i]\n        A -= 1\n        B -= 1\n        if not union_find.same(A, B):\n            total -= union_find.size(A) * union_find.size(B)\n            union_find.union(A, B)\n\n        answer_list.append(total)\n\n    len_answer = len(answer_list)\n    for i in range(len_answer-1, -1, -1):\n        print((answer_list[i]))\n\n\n\n__starting_point()", "class UnionFind():\n  def __init__(self,n):\n    self.parents = [-1]*n\n  \n  def find(self,x):\n    if self.parents[x] < 0:\n      return x\n\t\n    self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    \n    if x==y:\n      return\n    \n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n\t\n    self.parents[x]+=self.parents[y]\n    self.parents[y] = x\n  \n  def same(self,x,y):\n    return self.find(x) == self.find(y)\n  \n  def size(self,x):\n    return abs(self.parents[self.find(x)])\n\n\nN,M=map(int,input().split())\nuf = UnionFind(N+1)\n\ncnt=(N)*(N-1)//2\nL=[[int(x) for x in input().split()] for _ in range(M)]\nans=[]\n\nfor a,b in L[::-1]:\n  ans.append(cnt)\n  if not uf.same(a,b):\n    cnt -= uf.size(a)*uf.size(b)\n    uf.union(a,b)\n\nfor x in ans[::-1]:\n  print(x)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\nAB = [list([int(x)-1 for x in input().split()]) for _ in range(M)]\n\nAB.reverse()\nhubensa = N*(N-1)//2\nans = [str(hubensa)]\nuf = UnionFind(N)\n\nfor a, b in AB[:-1]:\n    if not uf.same(a, b):\n        c = uf.size(a)\n        d = uf.size(b)\n        hubensa -= c*d\n    ans.append(str(hubensa))\n    uf.union(a, b)\n\nans.reverse()\n\nprint((\"\\n\".join(ans)))\n", "import sys\n\n\nclass UnionFind:\n    def __init__(self, n=0):\n        self.d = [-1]*n\n        self.u = n\n\n    def root(self, x):\n        if self.d[x] < 0:\n            return x\n        self.d[x] = self.root(self.d[x])\n        return self.d[x]\n\n    def unite(self, x, y):\n        x, y = self.root(x), self.root(y)\n        if x == y:\n            return False\n        if x > y:\n            x, y = y, x\n        self.d[x] += self.d[y]\n        self.d[y] = x\n        self.u -= 1\n        return True\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def size(self, x):\n        return -self.d[self.root(x)]\n\n    def num_union(self):\n        return self.u\n\n\ndef c2(n):\n    return n*(n-1)//2\n\n\nN, M = list(map(int, sys.stdin.readline().split()))\nE = []\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    a -= 1\n    b -= 1\n    E.append((a, b))\n\nu = UnionFind(N)\nr = c2(N)\nresult = [r]\nfor a, b in E[::-1]:\n    na = u.size(a)\n    nb = u.size(b)\n    if u.unite(a, b):\n        r -= na*nb\n    result.append(r)\n\nfor r in result[-2::-1]:\n    print(r)\n", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1]*n\n    \n    def root(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            return self.root(self.parents[x])\n    \n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if x > y:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return\n\nn, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)][::-1]\n\nu = UnionFind(n)\nans = [n*(n-1)//2]\nfor a, b in ab:\n    a, b = a-1, b-1\n    ra, rb = u.root(a), u.root(b)\n    p = u.parents[ra] * u.parents[rb] if ra != rb else 0\n    ans.append(ans[-1] - p)\n    u.unite(a, b)\nans.pop()\nfor i in ans[::-1]:\n    print(i)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n        \nn, m = map(int, input().split())\nedge = []\nuf = UnionFind(n)\nfor i in range(m):\n    a, b = map(int, input().split())\n    edge.append((a - 1, b - 1))\n\nans = n * (n - 1) // 2\nans_list = []\nfor i in range(m)[::-1]:\n    ans_list.append(ans)\n    if not uf.same(edge[i][0], edge[i][1]):\n        ans -= uf.size(edge[i][0]) * uf.size(edge[i][1])\n    uf.union(edge[i][0], edge[i][1])\n    \nprint(*ans_list[::-1], sep=\"\\n\")\n\n    \n\n    ", "# abc120_d.py\nclass UnionFind():\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1]*(n+1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0]*(n+1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return \n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\nN, M = map(int,input().split())\nglaph = []\nfor i in range(M):\n    A, B = map(int,input().split())\n    glaph.append((A,B))\nglaph.reverse()\n\nans = []\nans.append(N*(N-1)//2)\nuf = UnionFind(N)\nfor i,v in enumerate(glaph):\n    a,b = v\n    if uf.isSameGroup(a,b):\n        ans.append(ans[i])\n    else:\n        ans.append(ans[i] - uf.Count(a)*uf.Count(b))\n    uf.Unite(a,b)\nans.reverse()\nfor i in range(1,M+1):\n    print(ans[i])", "import sys\nfrom itertools import combinations\n\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    \"\"\"Union Find class.\n\n    \"Path compression\" and \"Union by rank\" are used.\n\n    References:\n        <https://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n    \"\"\"\n\n    def __init__(self, N):\n        self.N = N\n        self.__make_set()\n\n    def __make_set(self):\n        self._parent = list(range(self.N + 1))\n        self._rank = [0] * (self.N + 1)\n        self._size = [1] * (self.N + 1)\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n\n        if x_root == y_root:\n            return\n\n        x_rank = self._rank[x_root]\n        y_rank = self._rank[y_root]\n        if x_rank > y_rank:\n            self._parent[y_root] = x_root\n            self._size[x_root] += self._size[y_root]\n        elif x_rank < y_rank:\n            self._parent[x_root] = y_root\n            self._size[y_root] += self._size[x_root]\n        else:\n            self._parent[y_root] = x_root\n            self._rank[x_root] += 1\n            self._size[x_root] += self._size[y_root]\n\n    def same_set(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self._size[self.find(x)]\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    A = [0] * M\n    B = [0] * M\n    for i in range(M):\n        A[i], B[i] = list(map(int, input().split()))\n\n    uf = UnionFind(N)\n    ans = [0] * M\n    ans[-1] = N * (N - 1) // 2\n    for i in reversed(list(range(M - 1))):\n        a, b = A[i + 1], B[i + 1]\n        if uf.same_set(a, b):\n            ans[i] = ans[i + 1]\n        else:\n            ans[i] = ans[i + 1] - uf.size(a) * uf.size(b)\n        uf.union(a, b)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Union Find\n# x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n\n# x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return False\n    else:\n        # x < y \u306b\u3059\u308b\n        if par[x] > par[y]:\n            x, y = y, x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n\n# x\u3068y\u304c\u7570\u306a\u308b\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef isdiff(x, y):\n    return find(x) != find(y)\n\n\n# x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\n\n\nimport sys\ninput = sys.stdin.readline\nn, m = map(int, input().split())\npar = [-1] * n\ninconvenience = [n * (n - 1) // 2]\n\nl = [tuple(map(int, input().split())) for _ in range(m)]\n\nfor a, b in l[::-1][:-1]:\n    if isdiff(a - 1, b - 1):\n        num = inconvenience[-1] - size(a - 1) * size(b - 1)\n        inconvenience.append(num)\n        unite(a - 1, b - 1)\n    else:\n        inconvenience.append(inconvenience[-1])\n\nprint(*inconvenience[::-1], sep=\"\\n\")", "import sys\ninput = sys.stdin.readline\n\nn,m = map(int,input().split())\nedge = [tuple(map(int,input().split())) for i in range(m)]\n#\u8fba\u3092\u8db3\u3057\u3066\u3044\u304f\u306e\u3067\u9006\u9806\u3067\u8003\u3048\u308b\nedge = edge[::-1]\n\npar = [i for i in range(n+1)]\nrank = [1] * (n+1)\nsize = [1] * (n+1)\n\n###Union-Find\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef same_check(x, y):\n        return find(x) == find(y)\n\n    #\u4f75\u5408(Union)\ndef union(x, y):\n    #\u6839\u3092\u63a2\u3059\n    x = find(x)\n    y = find(y)\n\n    #\u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\u3001\u4f4e\u3044\u307b\u3046\u304b\u3089\u9ad8\u3044\u307b\u3046\u306b\u6839\u3092\u5f35\u308b\n    if rank[x] < rank[y]:\n        par[x] = y\n        size[y] += size[x]\n    else:\n        par[y] = x\n        size[x] += size[y]\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\nresult = []\nfor i in range(m):\n    a = find(edge[i][0])\n    b = find(edge[i][1])\n    if a == b:\n        result.append(0)\n    else:\n        result.append(size[a]*size[b])\n        union(a,b)\n\nans = 0\nfor i in range(m):\n    ans += result[m-i-1]\n    print(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nEdge = [list(map(lambda x: int(x)-1, input().split())) for _ in range(M)][::-1]\nuf = UnionFind(N)\ncnt = N*(N-1)//2\nans=[]\nfor a, b in Edge:\n    ans.append(cnt)\n    if uf.same(a, b):\n        continue\n    cnt -= uf.size(a) * uf.size(b)\n    uf.union(a, b)\nprint(*ans[::-1], sep='\\n')", "class UnionFind:\n    def __init__(self, numV):\n        self.pars = list(range(numV))\n        self.ranks = [0] * numV\n        self.sizes = [1] * numV\n    def getRoot(self, x):\n        par = self.pars[x]\n        if par != x:\n            self.pars[x] = par = self.getRoot(par)\n        return par\n    def merge(self, x, y):\n        x, y = self.getRoot(x), self.getRoot(y)\n        sx, sy = self.sizes[x], self.sizes[y]\n        if x == y: return (0, 0)\n        if self.ranks[x] < self.ranks[y]:\n            self.pars[x] = y\n            self.sizes[y] += sx\n        else:\n            self.pars[y] = x\n            self.sizes[x] += sy\n            if self.ranks[x] == self.ranks[y]:\n                self.ranks[x] += 1\n        return (sx, sy)\n    def isSame(self, x, y):\n        return self.getRoot(x) == self.getRoot(y)\n    def updatePars(self):\n        for v in range(len(self.pars)):\n            self.getRoot(v)\n    def getSize(self, x):\n        return self.sizes[self.getRoot(x)]\n      \nn, m = map(int, input().split())\ne = [list(map(int,input().split())) for i in range(m)]\ne.reverse()\n\nuf = UnionFind(n)\nscore = n*(n-1)//2 \nans = [score]\nfor ce in range(m-1):\n    u, v = e[ce][0]-1, e[ce][1]-1\n    if uf.getRoot(u) != uf.getRoot(v):\n        xu = uf.getSize(u)\n        xv = uf.getSize(v)\n        uf.merge(u, v)\n        score -= xu * xv\n    ans.append(score)\nans.reverse()\n\nfor i in range(m):\n    print(ans[i])", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10**8)\n\nclass Unionfind():\n    def __init__(self,n):\n        self.n = n\n        self.parent = [-1]*n\n    \n    def find(self,x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return 0\n        if self.parent[x] < self.parent[y]:\n            x,y = y,x\n        \n        total_unite_island = self.parent[x] * self.parent[y]\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n        return total_unite_island\n\nN,M = map(int, input().split())\nA = [0]*M; B = [0]*M\nfor i in range(M):\n    A[i], B[i] = map(lambda x: int(x) - 1, input().split())\n\nuf = Unionfind(N)\ninconvenience = N * (N-1) // 2\ninconvenience_list = [0]*M\ninconvenience_list[M-1] = inconvenience\nfor i in range(M-1,0,-1):\n    inconvenience -= uf.union(A[i],B[i])\n    inconvenience_list[i-1] = inconvenience\nfor i in range(M):\n    print(inconvenience_list[i])", "n, m =map(int, input().split())\n\npar=[-1]*n\n\ndef find(x):\n    if par[x]<0: return x\n    par[x] = find(par[x])\n    return par[x]\n\ndef union(x, y):\n    p,q=find(x),find(y)\n    if p==q: return\n    if p>q: p,q=q,p\n    par[p] += par[q]\n    par[q] = p\n\ndef size(x):\n    return -par[find(x)]\n\ndef same(x,y):\n    return find(x)==find(y)\n\nbridge=[0]*m\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    bridge[m-i-1]=(a,b)\n\nsm=(n*(n-1))//2\nans=[0]*m\nfor i in range(m):\n    ans[m-1-i]=sm\n    a, b  = bridge[i][0], bridge[i][1]\n    p,q=find(a),find(b)\n    if p!=q:\n        sm -= size(p)*size(q)\n    union(a,b)\n\nfor i in range(m):\n    print(ans[i])", "import sys\n\ninput = sys.stdin.readline\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1]*(n+1)#\u305d\u308c\u305e\u308c\u306e\u8981\u7d20\u304c\u3069\u306e\u8981\u7d20\u306e\u5b50\u3067\u3042\u308b\u304b\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]#\u305d\u308c\u305e\u308c\u306e\u8981\u7d20\u306e\u6839\u3092\u518d\u5e30\u7684\u306b\u6c42\u3081\u308b\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n        \n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)#x,y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n    \n    def size(self, x):\n        return -self.par[self.find(x)]\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if root == self.find(i)]        \n\ndef main():\n    n, m = list(map(int, input().split()))\n    bridge = [None]*m\n    for i in range(m):\n        bridge[i] = [int(x) for x in input().split()]\n    \n    union = UnionFind(n)\n    \n    ans = [0]*m\n    for i in range(m):\n        a, b = bridge[m-1-i][0], bridge[m-1-i][1]\n        if union.same(a, b) == False:\n        \tans[i] = union.size(a)*union.size(b)\n        if i != 0:\n            ans[i] += ans[i-1]\n        union.union(a, b)\n    \n    for i in range(1, m):\n        print((n*(n-1)//2-ans[m-1-i]))\n    print((n*(n-1)//2))\n        \ndef __starting_point():\n    main()\n\n\n__starting_point()", "import sys\nbreadline = sys.stdin.buffer.readline\nbread = sys.stdin.buffer.read\nreadline = sys.stdin.readline\nread = sys.stdin.read\nsys.setrecursionlimit(10 ** 7)\ndef getnum(t=int): return t(breadline())\ndef numline(t=int): return map(t, breadline().split())\ndef numread(t=int): return map(t, bread().split())\ndef getstr(): return readline().strip()\ndef strline(): return readline().strip().split()\ndef strread(): return read().strip().split()\n\nclass UnionFind:\n    def __init__(self, n):\n        '''self.parents: the size of tree(as negative value)'''\n        self.n = n\n        self.parents = [-1] * n\n        self.ROOTS = set(list(range(n)))\n        self.n_connections = 0\n\n    def find(self, x):\n        '''Return parent node'''\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def _connect(self,x): return x * (x-1) // 2\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n        self.n_connections -= self._connect(-self.parents[x]) + self._connect(-self.parents[y])\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.ROOTS.remove(y)\n        self.n_connections += self._connect(-self.parents[x])\n\n\n    def size(self, x):\n        parent = self.find(x)\n        return -self.parents[parent]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        '''return the number in the group'''\n        parent = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == parent]\n\n    def group_count(self): return len(self.ROOTS)\n\n    def all_roots(self): return self.ROOTS\n\n\n\ndef main():\n    N,M = numline()\n    AB = []\n    for i in range(M):\n        a,b = numline()\n        AB.append((a-1, b-1))\n    tr = UnionFind(N)\n\n    BASE = N * (N-1) // 2\n    ans = [BASE]\n    for i in range(M-1, -1, -1):\n        a,b = AB[i]\n        tr.union(a,b)\n        ans.append(BASE - tr.n_connections)\n\n    for a in ans[-2::-1]:\n        print(a)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n        \n\nN, M = map(int, input().split())\nAB = []\nfor i in range(M):\n    AB.append(list(map(int, input().split())))\nAB.reverse()\n    \nuf = UnionFind(N)\nans = [N*(N-1)//2]\nfor i in range(M-1):\n    A, B = AB[i]\n    if uf.find(A-1) == uf.find(B-1):\n        ans.append(ans[i])\n    else:\n        ans.append(ans[i] - uf.size(A-1) * uf.size(B-1))\n    uf.union(A-1, B-1)\n    \nans.reverse()\nfor i in range(M):\n    print(ans[i])", "#Union Find\n\n#x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n#x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        return False\n    else:\n        #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n        if par[x] > par[y]:\n            x,y = y,x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n#x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef same(x,y):\n    return find(x) == find(y)\n\n#x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\n\nN, M = map(int, input().split())\nbridges = []\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    bridges.append((a, b))\n\n#\u521d\u671f\u5316\n#\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\npar = [-1]*N\ntot = N*(N-1)//2\nans = [tot]\n\nfor a, b in bridges[::-1]:\n    if not same(a, b): \n        tot -= size(a)*size(b)\n    unite(a, b)\n    ans.append(tot)\n\nprint('\\n'.join(map(str, ans[:-1][::-1])))", "class UnionFind():\n    # https://www.slideshare.net/chokudai/union-find-49066733\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        # root[x]>=0\u306e\u5834\u5408\u306f\u3001\u7279\u306b\u76f4\u63a5\u7684\u306a\u610f\u5473\u3092\u6301\u305f\u306a\u3044\u6c17\u304c\u3059\u308b\u3002\u8a08\u7b97\u306b\u5bc4\u4e0e\u3059\u308b\u306e\u3067\u610f\u5473\u306f\u3042\u308b\u306e\u3060\u308d\u3046\u304c\u3002\n        self.root = [-1]*(n+1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        # \u7121\u7d50\u5408\u306e\u6642\u306fRank=0,\u7d50\u5408\u3057\u30661\u3064\u6728\u304c\u6df1\u304f\u306a\u308b\u3068\u6839\u304cRank+=1\n        self.rnk = [0]*(n+1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    #\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        # (1)x\u306e\u30e9\u30f3\u30af\u306e\u65b9\u304c\u5927\u304d\u3044(\u4f4d\u7f6e\u304c\u6df1\u3044)\u5834\u5408\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        # (2)y\u306e\u30e9\u30f3\u30af\u306e\u65b9\u304c\u5927\u304d\u3044(\u4f4d\u7f6e\u304c\u6df1\u3044)\u5834\u5408 or \u7b49\u3057\u3044\u5834\u5408\n        # \u307e\u305f\u7b49\u3057\u3044\u5834\u5408\u3001\u5f15\u6570\u306e2\u3064\u3081\u306ey\u306e\u65b9\u306e\u30e9\u30f3\u30af\u30921\u3064\u5897\u3084\u3059\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    # Return: True or False\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        ret= -self.root[self.Find_Root(x)]\n        #print(ret)\n        return ret\n    \n############################################################################    \nN,M = map(int,input().split())\nA=[0]*M\nB=[0]*M\nfor i in range(M):\n    A[i],B[i] = map(int,input().split())\n\nconv=N*(N-1)//2\nUN=UnionFind(N)\nans=[conv]\nfor j in range(M-1,0,-1):\n    if UN.isSameGroup(A[j],B[j]):\n        pass\n    else:\n        conv -= UN.Count(A[j])*UN.Count(B[j])\n    ans.append(conv)\n    UN.Unite(A[j],B[j])\n    \nfor p in ans[::-1]:\n    print(p)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef main():\n    n, m = map(int,input().split())\n    ab = [tuple(map(int,input().split())) for _ in range(m)]\n\n    uf = UnionFind(n)\n\n    ans = [n*(n-1)//2]\n\n    for a,b in ab[::-1]:\n        sa,sb=uf.size(a-1),uf.size(b-1)\n        if uf.same(a-1,b-1):\n            ans.append(ans[-1])\n        else:\n            ans.append(ans[-1]-sa*sb)\n        uf.union(a-1,b-1)\n        \n    for i in range(1,m+1):\n        print(ans[-(i+1)])\nmain()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef main():\n    n, m = map(int,input().split())\n    ab = [tuple(map(int,input().split())) for _ in range(m)]\n\n    uf = UnionFind(n)\n\n    ans = [n*(n-1)//2]\n\n    for a,b in ab[::-1]:\n        sa,sb=uf.size(a-1),uf.size(b-1)\n        if uf.same(a-1,b-1):\n            ans.append(ans[-1])\n        else:\n            ans.append(ans[-1]-sa*sb)\n        uf.union(a-1,b-1)\n        \n    print(*ans[::-1][1:], sep=\"\\n\")\n\nmain()", "N,M=map(int,input().split())\nbridge=[]\nsize=[1]*(N+1)\ntree=list(range(N+1))\ndef find(a):\n    x=tree[a]\n    if a==x:\n        return a\n    x=find(x)\n    tree[a]=x\n    return x\nfor i in range(M):\n    A,B=map(int,input().split())\n    bridge.append((A,B))\nAns=N*(N-1)//2\nans=[]\nfor a,b in bridge[::-1]:\n    aroot=find(a)\n    broot=find(b)\n    if aroot==broot:\n        ans.append(Ans)\n        continue\n    ans.append(Ans)\n    sa=size[aroot]\n    sb=size[broot]\n    Ans-=sa*sb\n    if sa>sb:\n        tree[broot]=aroot\n        size[aroot]+=sb\n    else:\n        tree[aroot]=broot\n        size[broot]+=sa\nfor i in ans[::-1]:\n    print(i)", "import sys\n\nsys.setrecursionlimit(10**5)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def root(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.root(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx == ry:\n            return\n        if self.parents[x] > self.parents[y]:\n            rx, ry = ry, rx\n        self.parents[rx] += self.parents[ry]\n        self.parents[ry] = rx\n\n    def same(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        return rx == ry\n\n    def size(self, x):\n        return -self.parents[self.root(x)]\n\n\nn, m = list(map(int, input().split()))\nbridges = [tuple((int(i)-1 for i in input().split())) for _ in range(m)]\nislands = UnionFind(n)\nres = [n*(n-1)//2]\nfor a, b in bridges[:0:-1]:\n    if islands.same(a, b):\n        res.append(res[-1])\n    else:\n        res.append(res[-1] - islands.size(a) * islands.size(b))\n        islands.unite(a, b)\nprint(('\\n'.join(map(str, res[::-1]))))\n", "import sys\n\nstdin = sys.stdin\ninf = 1 << 60\nmod = 1000000007\n\nsys.setrecursionlimit(10**7)\n\nni = lambda: int(ns())\nnin = lambda y: [ni() for _ in range(y)]\nna = lambda: list(map(int, stdin.readline().split()))\nnan = lambda y: [na() for _ in range(y)]\nnf = lambda: float(ns())\nnfn = lambda y: [nf() for _ in range(y)]\nnfa = lambda: list(map(float, stdin.readline().split()))\nnfan = lambda y: [nfa() for _ in range(y)]\nns = lambda: stdin.readline().rstrip()\nnsn = lambda y: [ns() for _ in range(y)]\nncl = lambda y: [list(ns()) for _ in range(y)]\nnas = lambda: stdin.readline().split()\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self._size = [1 for _ in range(n)]\n        self._edges = 0\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self._size[y] += self._size[x]\n            self._edges += 1\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self._size[x] += self._size[y]\n            self._edges += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self._size[x]\n\n    def trees(self):\n        return self.n - self._edges\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn, m = na()\nab = nan(m)\nab.reverse()\n\nuf = UnionFind(n)\ncur = n * (n - 1) // 2\nans = [cur]\nfor i in range(m - 1):\n    a, b = ab[i]\n    a -= 1\n    b -= 1\n    p = uf.size(a)\n    q = uf.size(b)\n    if uf.same(a, b):\n        p = 0\n    uf.unite(a, b)\n    cur -= p * q\n    ans.append(cur)\n\nans.reverse()\nprint(*ans, sep=\"\\n\")", "n, m = map(int, input().split())\n# \u9006\u9806\u306bunionfind\nfrom collections import defaultdict\nclass UnionFind:\n    def __init__(self, n):\n        class KeyDict(dict):\n            # \u8f9e\u66f8\u306b\u306a\u3044\u3068\u304d\u306e\u5bfe\u5fdc\n            def __missing__(self,key):\n                self[key] = key\n                return key\n        self.parent = KeyDict()\n        self.rank = defaultdict(int)\n        self.weight = defaultdict(lambda:1)\n\n    # \u6839\u3092\u63a2\u3059\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            # \u7d4c\u8def\u5727\u7e2e\n            # \u81ea\u5206\u81ea\u8eab\u3058\u3083\u306a\u3044\u5834\u5408\u306f\u3001\u4e0a\u306b\u3055\u304b\u306e\u307c\u3063\u3066\u691c\u7d22(\u518d\u5e30\u7684\u306b)\n            y = self.find(self.parent[x])\n            self.parent[x] = y      #\u89aa\u306e\u7f6e\u304d\u63db\u3048(\u5727\u7e2e)\n            return self.parent[x]\n\n    # \u7d50\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        # \u4f4e\u3044\u65b9\u3092\u9ad8\u3044\u65b9\u306b\u3064\u306a\u3052\u308b(\u89aa\u306e\u30e9\u30f3\u30af\u306b\u3088\u308b)\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.weight[y] += self.weight[x]\n            self.weight[x] = 0\n        else:\n            self.parent[y] = x\n            self.weight[x] += self.weight[y]\n            self.weight[y] = 0\n        \n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n\n\n    # \u5224\u5b9a\n    def judge(self, x, y):\n        return self.find(x) == self.find(y)\n\nps = []\nfor i in range(m):\n    a,b = map(int, input().split())\n    a -= 1\n    b -= 1\n    ps.append((a,b))\n\nuf = UnionFind(n)\nnow = n*(n-1)//2\nans = [now]\nfor a, b in ps[::-1]:\n    if not uf.judge(a,b):\n        n1 = uf.weight[uf.find(a)]\n        n2 = uf.weight[uf.find(b)]\n        now += n1*(n1-1)//2 + n2*(n2-1)//2 - (n1+n2)*(n1+n2-1)//2\n        uf.union(a,b)\n    ans.append(now)\n\nfor a in ans[::-1][1:]:\n    print(a)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m = map(int,input().split())\nuf = UnionFind(n)\nq = []\nfor i in range(m):\n    a,b = map(int,input().split())\n    q.append([a-1,b-1])\nans = n*(n-1)//2\nl = []\nfor i in range(m-1,-1,-1):\n    a,b = q[i]\n    l.append(ans)\n    if not uf.same(a,b):\n        ans -= uf.size(a)*uf.size(b)\n    uf.union(a,b)\nfor i in l[::-1]:\n    print(i)", "def find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\ndef unite(x, y):\n    p = find(x)\n    q = find(y)\n    if p == q:\n        return None\n    if p > q:\n        p,q = q,p\n    par[p] += par[q]\n    par[q] = p\ndef same(x, y):\n    return find(x) == find(y)\ndef size(x):\n    return -par[find(x)]\nn, m = map(int, input().split())\npar = [-1 for i in range(n)]\na, b = [], []\nfor i in range(m):\n    a_, b_ = map(int, input().split())\n    a.append(a_ - 1)\n    b.append(b_ - 1)\nans = [0] * m\nans[-1] = (n - 1) * n // 2\nfor i in range(m - 1, 0, -1):\n    if same(a[i], b[i]):\n        ans[i - 1] = ans[i]\n    else:\n        ans[i - 1] = ans[i] - size(a[i]) * size(b[i])\n        unite(a[i], b[i])\nprint(*ans, sep=\"\\n\")", "class UnionFind:\n    def __init__(self, N):\n        self.N = N\n\n        # the parent of all node is itself\n        # self.parent = list(range(N))\n        self.parent = [-1] * N\n\n    def root(self, i):\n        if self.parent[i] < 0:\n            return i\n\n        r = self.root(self.parent[i])\n        self.parent[i] = r\n        return r\n\n    def unite(self, i, j):\n        i = self.root(i)\n        j = self.root(j)\n\n        if i == j:\n            return\n\n        if i > j:\n            i, j = j, i\n\n        self.parent[i] += self.parent[j]\n        self.parent[j] = i\n        # print(self.parent)\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n    def size(self, i):\n        return -self.parent[self.root(i)]\n\n    def roots(self):\n        return [self.root(i) for i in range(self.N)]\n\n    def groupcount(self):\n        return len(set(self.roots()))\n\nN, M = map(int, input().split())\n\n# init union find\nforest = UnionFind(N)\n\nedges = []\nfor _ in range(M):\n    edges.append([int(e) - 1 for e in input().split()])\n\ninconvenience = N * (N - 1) // 2\nscore = []\nfor a, b in edges[::-1]:\n    score.append(inconvenience)\n\n    if not forest.same(a, b):\n        inconvenience -= forest.size(a) * forest.size(b)\n\n    forest.unite(a, b)\n\nfor s in score[::-1]:\n    print(s)", "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(100000)\n\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.nodes = n\n        self.parents = [-1] * n\n        self.rank = [0] * n\n\n    # retrun the root of element x\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # unite the group include element x and group include element y\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n        else:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # get size of the gourp which element x belongs\n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n\n    # check if element x and element y is same group\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    N, M = [int(i) for i in input().strip().split()]\n    links = [None] * M\n    for i in range(M):\n        links[i] = [int(i)-1 for i in input().strip().split()]\n\n    u = UnionFind(N)\n    ans = list()\n    x = N * (N - 1) // 2\n\n    for a, b in links[::-1]:\n        ans.append(x)\n        if not u.same(a, b):\n            x -= u.get_size(a) * u.get_size(b)\n        u.unite(a, b)\n    return ans\n\n\ndef __starting_point():\n    for ans in main()[::-1]:\n        print(ans)\n\n__starting_point()", "\nclass UnionFind:\n    def __init__(self, N):\n        self.parents = [i for i in range(N)]\n        self.sizes = [1 for _ in range(N)]\n        \n    # \u6728\u306e\u6839\u3092\u307e\u3068\u3081\u308b, \u9802\u70b9 v \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u5f97\u308b (O(\u03b1(n)))\n    def root(self, x):\n        if self.parents[x] == x:\n            return x # \u6839\n        else:\n            self.parents[x] = self.root(self.parents[x]) # \u7d4c\u8def\u5727\u7e2e\n            return self.parents[x]\n            \n    # x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5426\u304b\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n        \n    # x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408, \u9802\u70b9 u \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u9802\u70b9 v \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3057\u3001\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3059\u308b (O(\u03b1(n)))\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.sizes[x] < self.sizes[y]:\n            x, y = y, x\n        self.sizes[x] += self.sizes[y]\n        self.parents[y] = x\n        return True\n    \n    # \u9802\u70b9 v \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u9802\u70b9\u6570\u3092\u5f97\u308b (O(1))\n    def size(self, x):\n        return self.sizes[self.root(x)]\n        \n        \n        \nN, M = map(int, input().split())\n\ntree = UnionFind(N)\n\nAB = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    AB.append([a, b])\n\nAB = AB[::-1]\n\ntree = UnionFind(N)\nans = [N*(N-1)//2]\nfor i in range(M):\n    a, b = AB[i]\n    a, b = tree.root(a-1), tree.root(b-1)\n    if a != b:\n        ans.append(ans[-1] - tree.size(a)*tree.size(b))\n    else:\n        ans.append(ans[-1])\n    tree.unite(a, b)\n\nans = ans[:M][::-1]\nfor i in range(M):\n    print(ans[i])", "import math\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nn_nodes, n_path = list(map(int,input().split()))\npaths = [[0,0] for _ in range(n_path)]\nfor i in range(n_path):\n    a,b = list(map(int,input().split()))\n    paths[i] = [a-1,b-1]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        '''\n        x\u3068y\u306f-=1\u3057\u3066\u4f7f\u3046\n        '''\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nnow_ans = combinations_count(n_nodes,2)\npaths = paths[::-1]\nuf = UnionFind(n_nodes)\nans_ls = [0] * (n_path)\nans_ls[-1] = now_ans\nfor i,path in enumerate(paths[:-1]):\n    a,b = path\n    if not uf.same(a,b):\n        now_ans -= uf.size(a)*uf.size(b)\n        uf.union(a,b)\n    ans_ls[-2-i] = now_ans\nfor ans in ans_ls:\n    print(ans)\n    \n", "import sys\nsys.setrecursionlimit(10**7)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn, m = list(map(int, input().split()))\nab=[list(map(int, input().split())) for _ in range(m)]\n\nuf = UnionFind(n)\ntmp_ans = n*(n-1)//2\nans = []\nfor i in range(m):\n    ans.append(tmp_ans)\n    a=ab[m-1-i][0]\n    b=ab[m-1-i][1]\n    a-=1\n    b-=1\n    if not uf.is_same(a,b):\n        tmp_ans-=uf.size(a)*uf.size(b)\n    uf.union(a,b)\n\nans.reverse()\nfor i in ans:\n    print(i)\n", "n,m=list(map(int,input().split()))\nab=[[0,0] for i in range(m)]\nfor i in range(m):\n    ab[i][0],ab[i][1]=list(map(int,input().split()))\n\nimport sys\nsys.setrecursionlimit(10**9) #\u518d\u5e30\u306e\u4e0a\u9650\u3092\u3042\u3052\u308b\n\nroot=[-1 for i in range(n+1)] #\u81ea\u5206\u304c\u89aa\u306a\u3089\u81ea\u8eab\u306e\u756a\u53f7\u3092\u3001\u305d\u3046\u3067\u306a\u3044\u306a\u3089\uff08\u5143\uff09\u89aa\u306e\u756a\u53f7\u3092\u793a\u3059\ndef r(x):   #\u89aa\u306f\u8ab0\uff1f\n    if root[x]<0:\n        return x\n    else:\n        root[x]=r(root[x])\n        return root[x]\n\n\nans=n*(n-1)//2\nd=[n*(n-1)//2]\nfor i in range(1,m+1):\n    a,b=ab[-i][0],ab[-i][1]\n    a=r(a)\n    b=r(b)\n    a,b=min(a,b),max(a,b)\n    if a!=b:\n        ans-=root[a]*root[b]\n        root[a]+=root[b]\n        root[b]=a\n    d.append(ans)\n\nfor i in range(m):\n    print((d[-2-i]))\n", "# 20-08-12\u518d\u30c8\u30e9\u30a4\nimport sys\ninput = sys.stdin.readline\n\nclass UnionFind():\n    def __init__(self, n):\n        self.rank = [0] * n\n        self.par = list(range(n))\n        self._size = [1] * n  # \u6728\u306e\u6839\u306e\u307f\u6709\u52b9\u3001\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\u6570\n\n    def find(self, x):\n        ch = []\n        while self.par[x] != x:\n            ch.append(x)\n            x = self.par[x]\n        for c in ch:\n            self.par[c] = x\n\n        return x\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx == ry:\n            return\n        if self.rank[rx] >= self.rank[ry]:\n            self.par[ry] = rx\n            self._size[rx] += self._size[ry]\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n        else:\n            self.par[rx] = ry\n            self._size[ry] += self._size[rx]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self._size[self.find(x)]\n\nN, M = [int(x) for x in input().split()]\nE = [tuple(int(x) - 1 for x in input().split()) for _ in range(M)]\ninconv = [0] * M\ninconv[M - 1] = N * (N - 1) // 2\nuf = UnionFind(N)\n\nfor i in range(M - 1, 0, -1):\n    a = E[i][0]\n    b = E[i][1]\n    inconv[i - 1] = inconv[i]\n    if uf.same(a, b):\n        continue\n    inconv[i - 1] -= uf.size(a) * uf.size(b)\n    uf.union(a, b)\n\nfor i in range(M):\n    print(inconv[i])", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nclass UnionFind:\n    def __init__(self, n):\n        '\u6728\u306e\u521d\u671f\u5316\u3092\u3059\u308b'\n        self.p = [-1] * n\n        self.rank = [1]*n\n        self.size = [1]*n\n    def find(self, x):\n        'x \u306e\u89aa\u3092\u8fd4\u3059'\n        if self.p[x] == -1:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        'rank\u306e\u4f4e\u3044\u89aa\u3092\u9ad8\u3044\u65b9\u306e\u306e\u89aa\u306b\u3059\u308b'\n        if not self.same(x,y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] > self.rank[y]:\n                x,y = y,x\n            elif self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n            self.p[x] = y\n            self.size[y] += self.size[x]\n            return True\n        else:\n            return False\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn,m = list(map(int,input().split()))\npath = []\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n    path.append((a-1,b-1))\n\nd = [0]*m\nuf = UnionFind(n)\nfor i in range(m-1,-1,-1):\n    a,b = path[i]\n    if not uf.same(a,b):\n        d[i] = uf.size[uf.find(a)]*uf.size[uf.find(b)]\n    uf.unite(a,b)\ns = [0]*(m+1)\nfor i in range(m):\n    s[i+1] = s[i] + d[i]\nprint(('\\n'.join(str(i) for i in s[1:])))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nN,M=map(int,input().split())\nbridge=[]\nsize=[1]*(N+1)\ntree=list(range(N+1))\ndef find(a):\n    x=tree[a]\n    if a==x:\n        return a\n    x=find(x)\n    tree[a]=x\n    return x\nfor i in range(M):\n    A,B=map(int,input().split())\n    bridge.append((A,B))\nAns=N*(N-1)//2\nans=[]\nfor a,b in bridge[::-1]:\n    aroot=find(a)\n    broot=find(b)\n    if aroot==broot:\n        ans.append(Ans)\n        continue\n    ans.append(Ans)\n    Ans-=size[aroot]*size[broot]\n    tree[broot]=aroot\n    size[aroot]+=size[broot]\nfor i in ans[::-1]:\n    print(i)", "N,M=list(map(int,input().split()))\ndef f(n):\n   return n*(n-1)//2\nans=f(N)\nroot=[i for i in range(N+1)]\nheight=[1]*(N+1)\ndef find(a):\n   f=a\n   if a==root[a]:\n      return a\n   while a!=root[a]:\n      a=root[a]\n   root[f]=a\n   return a\ndef union(a,b):\n   A=find(a)\n   B=find(b)\n   nonlocal ans\n   if A==B:\n      return\n   ans+=f(height[A])+f(height[B])\n   if height[A]>height[B]:\n      root[B]=root[A]\n      height[A]+=height[B]\n      height[B]=0\n   else:\n      root[A]=root[B]\n      height[B]+=height[A]\n      height[A]=0\n   ans-=f(max(height[A],height[B]))\nl=[tuple(map(int,input().split())) for i in range(M)]\nl=l[::-1]\nans_m=[ans]\nfor i in range(M):\n   a,b=l[i]\n   union(a,b)\n   ans_m.append(ans)\nans_m=ans_m[::-1]\nfor i in range(1,M+1):\n   print(ans_m[i])", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    bridge = [list(map(int, input().split())) for _ in range(M)]\n\n    uf = UnionFind(N)\n    ans = [N*(N-1)//2]*M\n\n    for i in range(-1, -1 * M, -1):\n        a = bridge[i][0] - 1\n        b = bridge[i][1] - 1\n        root_a = uf.find(a)\n        root_b = uf.find(b)\n        if root_a != root_b:\n            ans[i-1] = ans[i] - uf.size(a) * uf.size(b)\n            uf.union(a, b)\n        else:\n            ans[i-1] = ans[i]\n\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import setrecursionlimit\n\ndef find(parent, i):\n  t = parent[i]\n  if t < 0:\n    return i\n  t = find(parent, t)\n  parent[i] = t\n  return t\n\ndef unite(parent, i, j):\n  i = find(parent, i)\n  j = find(parent, j)\n  if i == j:\n    return\n  parent[j] += parent[i]\n  parent[i] = j\n\nsetrecursionlimit(10**6)\n\nN, M = map(int, input().split())\nAB = [[int(c) - 1 for c in input().split()] for _ in range(M)]\n\nparent = [-1]*N\ninconvenience = N*(N-1) // 2\nresult = []\nfor a, b in AB[::-1]:\n  result.append(inconvenience)\n  pa, pb = find(parent, a), find(parent, b)\n  if pa != pb:\n    inconvenience -= parent[pa] * parent[pb]\n  unite(parent, a, b)\n\nfor i in range(len(result)-1,-1,-1):\n  print(result[i])", "import sys\n# sys.setrecursionlimit(10**7)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn, m = list(map(int, input().split()))\nab=[list(map(int, input().split())) for _ in range(m)]\n\nuf = UnionFind(n)\ntmp_ans = n*(n-1)//2\nans = []\nfor i in range(m):\n    ans.append(tmp_ans)\n    a=ab[m-1-i][0]\n    b=ab[m-1-i][1]\n    a-=1\n    b-=1\n    if not uf.is_same(a,b):\n        tmp_ans-=uf.size(a)*uf.size(b)\n    uf.union(a,b)\n\nans.reverse()\nfor i in ans:\n    print(i)\n", "import sys\n\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    \"\"\"Union Find class.\n\n    \"Path compression\" and \"Union by rank\" are used.\n\n    References:\n        <https://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n    \"\"\"\n\n    def __init__(self, N):\n        self.N = N\n        self.__make_set()\n\n    def __make_set(self):\n        self._parent = list(range(self.N + 1))\n        self._rank = [0] * (self.N + 1)\n        self._size = [1] * (self.N + 1)\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n\n        if x_root == y_root:\n            return\n\n        x_rank = self._rank[x_root]\n        y_rank = self._rank[y_root]\n        if x_rank > y_rank:\n            self._parent[y_root] = x_root\n            self._size[x_root] += self._size[y_root]\n        elif x_rank < y_rank:\n            self._parent[x_root] = y_root\n            self._size[y_root] += self._size[x_root]\n        else:\n            self._parent[y_root] = x_root\n            self._rank[x_root] += 1\n            self._size[x_root] += self._size[y_root]\n\n    def same_set(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self._size[self.find(x)]\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    A = [0] * M\n    B = [0] * M\n    for i in range(M):\n        A[i], B[i] = list(map(int, input().split()))\n\n    uf = UnionFind(N)\n    ans = [0] * M\n    ans[-1] = N * (N - 1) // 2\n    for i in reversed(list(range(M - 1))):\n        a, b = A[i + 1], B[i + 1]\n        if uf.same_set(a, b):\n            ans[i] = ans[i + 1]\n        else:\n            ans[i] = ans[i + 1] - uf.size(a) * uf.size(b)\n        uf.union(a, b)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\ndef main():\n    n, m = list(map(int, sys.stdin.buffer.readline().split()))\n    uf = UnionFind(n)\n    ans = [n*(n-1)//2]\n    for x in reversed(sys.stdin.buffer.readlines()):\n        a, b = list(map(int, x.split()))\n        a -= 1\n        b -= 1\n        if uf.find(a, b):\n            ans.append(ans[-1])\n            continue\n        ba, bb = uf.table[uf._root(a)], uf.table[uf._root(b)]\n        ans.append(ans[-1] - ba*bb)\n        uf.union(a, b)\n    ans.reverse()\n    print((\"\\n\".join(map(str, ans[1:]))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M = list( map(int, input().split()) )\n\nuf = UnionFind(N)\nA = [0]*M\nB = [0]*M\nfor i in range(M):\n    a,b = list( map(int, input().split()) )\n    A[i]=a-1\n    B[i]=b-1\n\n#print(A)\n#print(B)\n\ncmax = int(N*(N-1)/2)\nFD = [cmax]*(M+1)\n#print(FD)\nfor i in range(M):\n    #print(uf)\n    if uf.same(A[M-i-1],B[M-i-1]):\n        FD[M-i-1] = FD[M-i]\n    else:\n        cless = uf.size(A[M-i-1])*uf.size(B[M-i-1])\n        FD[M-i-1] = FD[M-i] - cless\n        if FD[M-i-1]<0: FD[M-i-1]=0\n    uf.union(A[M-1-i],B[M-1-i])\n\n#print(uf)\n#print(FD[1:])\nfor fd in FD[1:]:\n    print(fd)\n\n\n", "n,m = list(map(int,input().split()))\na = [0]*m\nb = [0]*m\nfor i in range(m):\n  a[i], b[i] = list(map(int,input().split()))\n\nd = list(range(n+1))\ng = [[i] for i in range(n+1)]\n\nc = n*(n-1)//2\nans = [c]\n\nfor i in range(1,m)[::-1]:\n  x = d[a[i]]\n  y = d[b[i]]\n  x,y = max(x,y),min(x,y)\n  if x > y:\n    c -= len(g[x])*len(g[y])\n    for i in g[y]:\n      d[i] = x\n    g[x] += g[y]\n  ans.append(c)\n\nfor t in ans[::-1]:\n  print(t)\n", "class UnionFind:\n    def __init__(self, n):\n        self.nodes = n\n        self.parents = [i for i in range(n)]\n        self.sizes = [1] * n\n        self.rank = [0] * n\n\n    def find(self, i): # \u3069\u306e\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\uff08\u6839\u30ce\u30fc\u30c9\u306e\u756a\u53f7\uff09\n        if self.parents[i] == i:\n            return i\n        else:\n            self.parents[i] = self.find(self.parents[i]) # \u7d4c\u8def\u5727\u7e2e\n            return self.parents[i]\n\n    def unite(self, i, j): # \u4e8c\u3064\u306e\u96c6\u5408\u3092\u4f75\u5408\n        pi = self.find(i)\n        pj = self.find(j)\n        if pi != pj:\n            if self.rank[pi] < self.rank[pj]:\n                self.sizes[pj] += self.sizes[pi]\n                self.parents[pi] = pj\n            else:\n                self.sizes[pi] += self.sizes[pj]\n                self.parents[pj] = pi\n                if self.rank[pi] == self.rank[pj]:\n                    self.rank[pi] += 1\n    def same(self, i, j): # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u3092\u5224\u5b9a\n        return self.find(i)==self.find(j)\n\n    def get_parents(self): # \u6839\u30ce\u30fc\u30c9\u306e\u4e00\u89a7\u3092\u53d6\u5f97\n        for n in range(self.nodes): # find\u3067\u7d4c\u8def\u5727\u7e2e\u3059\u308b\n            self.find(n)\n        return self.parents\n\n    def size(self, i):\n        p = self.find(i)\n        return self.sizes[p]\n\n\nN, M = map(int, input().split())\nAB = []\nB = []\nfor m in range(M):\n    a, b = map(int, input().split())\n    AB.append((a-1,b-1))\n\nans = []\nscore = N * (N-1) // 2\nuf = UnionFind(N)\nfor a, b in AB[::-1]:\n    ans.append(score)\n    if not uf.same(a,b):\n        score -= uf.size(a) * uf.size(b)\n        uf.unite(a,b)    \n\nfor score in ans[::-1]:\n    print(score)", "N,M=map(int,input().split())\nbridge=[]\nsize=[1]*(N+1)\ntree=list(range(N+1))\ndef find(a):\n    x=tree[a]\n    if a==x:\n        return a\n    y=find(x)\n    tree[a]=y\n    return y\nfor i in range(M):\n    A,B=map(int,input().split())\n    bridge.append((A,B))\nAns=N*(N-1)//2\nans=[]\nfor a,b in bridge[::-1]:\n    aroot=find(a)\n    broot=find(b)\n    if aroot==broot:\n        ans.append(Ans)\n        continue\n    ans.append(Ans)\n    sa=size[aroot]\n    sb=size[broot]\n    Ans-=sa*sb\n    if sa>sb:\n        tree[broot]=aroot\n        size[aroot]+=sb\n    else:\n        tree[aroot]=broot\n        size[broot]+=sa\nfor i in ans[::-1]:\n    print(i)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n\ndef main():\n    N, M, *AB = map(int, read().split())\n\n    AB = list(reversed(AB[2:]))\n    count = N * (N - 1) // 2\n    ans = [count]\n    uf = UnionFind(N)\n\n    for a, b in zip(AB[::2], AB[1::2]):\n        a -= 1\n        b -= 1\n        if not uf.same(a, b):\n            count -= uf.size(a) * uf.size(b)\n            uf.union(a, b)\n        ans.append(count)\n\n    print('\\n'.join(map(str, reversed(ans))), sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():\n  def __init__(self,n):\n    self.n=n\n    self.parents=[-1]*n\n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n  def unite(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.parents[x]>self.parents[y]:\n      x,y = y,x\n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n  def same(self,x,y):\n    return self.find(x)==self.find(y)\n  def size(self,x):\n    return -self.parents[self.find(x)]\nN,M = map(int,input().split())\ninconvenience = N*(N-1)//2\nscore=[]\nUF=UnionFind(N)\nA = [0]*M\nfor i in range(M):\n  a,b = map(int,input().split())\n  A[i]=[a-1,b-1]\nfor a,b in A[::-1]:\n  score.append(inconvenience)\n  if not UF.same(a,b):\n    inconvenience -=UF.size(a)*UF.size(b)\n  UF.unite(a,b)\nfor s in score[::-1]:\n  print(s)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n\nN, M = map(int, input().split())\nUnion = UnionFind(N)\nbad_value = N*(N-1)//2\nbridge = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    bridge.append((a, b))\nbridge.reverse()\nans = [bad_value]\nfor a, b in bridge:\n    if Union.same(a, b):\n        Union.union(a, b)\n        ans.append(bad_value)\n        continue\n    else:\n        X = Union.size(a)\n        Y = Union.size(b)\n        Union.union(a, b)\n        bad_value -= X*Y\n        ans.append(bad_value)\n        continue\nans.reverse()\nfor i in range(1, M+1):\n    print(ans[i])", "class UnionFind():\n  def __init__(self,n):\n    self.parents = list(range(n))\n    self.size = [1]*n\n  \n  def find(self,x):\n    if self.parents[x] == x:\n      return x\n\t\n    self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    \n    if x==y:\n      return\n    \n    if self.size[x]<self.size[y]:\n      x,y=y,x\n\t\n    self.size[x]+=self.size[y]\n    self.parents[y] = x\n  \n  def same(self,x,y):\n    return self.find(x) == self.find(y)\n  \n  def sizeofset(self,x):\n    return self.size[self.find(x)]\n\n\nN,M=map(int,input().split())\nuf = UnionFind(N+1)\n\ncnt=(N)*(N-1)//2\nL=[[int(x) for x in input().split()] for _ in range(M)]\nans=[]\n\nfor a,b in L[::-1]:\n  ans.append(cnt)\n  if not uf.same(a,b):\n    cnt -= uf.sizeofset(a)*uf.sizeofset(b)\n    uf.union(a,b)\n\nfor x in ans[::-1]:\n  print(x)", "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\n \nsys.setrecursionlimit(10 ** 7)\n \nfrom collections import defaultdict\n \nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN, M = map(int, input().split())\n\n\nclass UnionFind(object):\n    def __init__(self, n = 1):\n        self.link = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.link[x] == x:\n            return x\n\n        # re-connect union find to make the height of tree lower\n        # you can use while, but recursion makes it easier to reconnect\n        self.link[x] = self.find(self.link[x])\n        return self.link[x]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.link[y] = x\n        self.size[x] += self.size[y]\n    \n    def get_size(self, x):\n        x = self.find(x)\n        return self.size[x]\n\nes = [0] * M\nfor i in range(M):\n    a, b = map(int, input().split())\n    es[i] = (a - 1, b - 1)\n\nu = UnionFind(N)\nans = []\npair = N * (N - 1) // 2\nans.append(pair)\nfor i in range(M - 1, -1, -1):\n    a, b = es[i]\n    if u.is_same(a, b):\n        ans.append(pair)\n        continue\n    pair -= (u.get_size(a) * u.get_size(b))\n    u.unite(a ,b)\n    if pair < 0:\n        pair = 0\n    ans.append(pair)\n\nfor i in list(reversed(ans))[1:]:\n    print(i)", "import sys\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = [-1] * size\n        self.rank = [1] * size\n        self.groups = size\n\n    def get_root(self, node):\n        parent = self.parent[node]\n        if parent == -1:\n            root = node\n        else:\n            root = self.get_root(parent)\n            self.parent[node] = root  # \u540c\u3058node\u3078\u306e2\u56de\u76ee\u4ee5\u964d\u306eget_root\u3092\u9ad8\u901f\u306b\u3059\u308b\u305f\u3081\u306b\u3001\u76f4\u63a5root\u306b\u7e4b\u3044\u3067\u304a\u304f\n        return root\n\n    def in_same_group(self, node1, node2):\n        root1 = self.get_root(node1)\n        root2 = self.get_root(node2)\n        return root1 == root2\n\n    def unite(self, node1, node2):\n        if self.in_same_group(node1, node2):\n            return\n        main_root = self.get_root(node1)\n        sub_root = self.get_root(node2)\n        if self.rank[main_root] < self.rank[sub_root]:  # rank\u306e\u5927\u304d\u3044\u65b9\u3092main_root\u306b\u3059\u308b\n            main_root, sub_root = sub_root, main_root\n\n        self.parent[sub_root] = main_root\n        self.rank[main_root] += self.rank[sub_root]\n        self.groups -= 1\n\n\ndef main():\n    n, m = map(int, input().split())\n    bridges = [list(map(int, input().split())) for _ in range(m)]\n    uf = UnionFind(n)\n    inconvenience = n * (n-1) // 2\n    ans = [inconvenience]\n\n    for a, b in bridges[::-1]:\n        if uf.in_same_group(a-1, b-1):\n            ans.append(inconvenience)\n            continue\n        root1 = uf.get_root(a-1)\n        root2 = uf.get_root(b-1)\n        pattern = uf.rank[root1] * uf.rank[root2]\n        inconvenience -= pattern\n        ans.append(inconvenience)\n        uf.unite(root1, root2)\n    ans.pop()\n    print(*ans[::-1], sep=\"\\n\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\n#from decimal import *\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        # parents[i]: \u8981\u7d20i\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\n        # \u8981\u7d20i\u304c\u6839\u306e\u5834\u5408\u3001parents[i] = -(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\n        self.parents = [-1] * n\n    def find(self, x):\n        if 0 > self.parents[x]:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u8fd4\u3059\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    # \u5168\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if 0 > x]\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n    def group_count(self):\n        return len(self.roots())\n    # \u8f9e\u66f8{\u6839\u306e\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u3092\u8fd4\u3059\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    # print()\u3067\u306e\u8868\u793a\u7528\n    # all_group_members()\u3092print\u3059\u308b\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\t\nN, M = MAP()\nbridge = [LIST() for _ in range(M)][::-1]\ntree = UnionFind(N)\n\nans = []\nA = N*(N-1)//2\nfor x, y in bridge:\n\tans.append(max(A, 0))\n\t#print([tree.size(r) for r in tree.roots()])\n\tif not tree.same(x-1, y-1):\n\t\tA -= tree.size(x-1)*tree.size(y-1)\n\ttree.union(x-1, y-1)\n\nprint(*ans[::-1], sep=\"\\n\")", "class UnionFind:\n  def __init__(self, N):\n    self.N = N\n    self.parent = [-1] * N\n\n  def root(self, i):\n    if self.parent[i] < 0:\n      return i\n    r = self.root(self.parent[i])\n    self.parent[i] = r\n    return r\n\n  def unite(self, i, j):\n    i = self.root(i)\n    j = self.root(j)\n    if i == j:\n      return\n    if i > j:\n      i, j = j, i\n    self.parent[i] += self.parent[j]\n    self.parent[j] = i\n\n  def same(self, i, j):\n    return self.root(i) == self.root(j)\n\n  def size(self, i):\n    return -self.parent[self.root(i)]\n\n  def roots(self):\n    return [self.root(i) for i in range(self.N)]\n\n  def groupcount(self):\n    return len(set(self.roots()))\n\nN, M = map(int,input().split())\nforest = UnionFind(N)\n\nedges = []\nfor _ in range(M):\n  edges.append([int(e) - 1 for e in input().split()])\n\ninconvenience =N*(N-1)//2\nscore=[]\nfor a, b in edges[::-1]:\n  score.append(inconvenience)\n  if not forest.same(a,b):\n    inconvenience -= forest.size(a) * forest.size(b)\n  forest.unite(a, b)\n\nfor s in score[::-1]:\n  print(s)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    bridge = [list(map(int, input().split())) for _ in range(M)]\n\n    uf = UnionFind(N)\n    ans = [N*(N-1)//2]*M\n\n    for i in range(-1, -1 * M, -1):\n        a = bridge[i][0] - 1\n        b = bridge[i][1] - 1\n        if not uf.same(a, b):\n            ans[i-1] = ans[i] - uf.size(a) * uf.size(b)\n            uf.union(a, b)\n        else:\n            ans[i-1] = ans[i]\n\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab.reverse()\ncnt = [0] * N\nlst = [0]*N\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            return self.find(self.parents[x])\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y: return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n     \n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nuf = UnionFind(N)\ncnt = N * (N - 1) // 2\nans = [cnt]\nfor a, b in ab:\n    a -= 1\n    b -= 1\n    if uf.find(a) != uf.find(b):\n        cnt -= uf.size(a) * uf.size(b)\n        uf.union(a, b)\n    ans.append(cnt)\nans.reverse()\nprint(*ans[1:], sep='\\n')", "class Unionfind:\n    def __init__(self,n):\n        self.par=[x for x in range(n)]\n        self.rank=[1]*n\n        self.num=[1]*n\n\n    def root(self,a):\n        if self.par[a]==a : return a\n        parent=self.root(self.par[a])\n        self.par[a]=parent\n        return parent\n\n    def unite(self,a,b):\n        ra,rb=self.root(a),self.root(b)\n        out=self.num[ra]*self.num[rb]\n        if self.rank[ra]<self.rank[rb]:\n            ra,rb=rb,ra\n        self.par[rb]=ra\n        self.num[ra]+=self.num[rb]\n        if self.rank[ra]==self.rank[rb]:\n            self.rank[ra]+=1\n        return out\n        \n    def same(self,a,b):\n        return self.root(a)==self.root(b)\n\n    def com_num(self,a,b):\n        if self.same(a,b): return 0\n        else : return self.unite(a,b)\n        \n\ndef main():\n    n,m=map(int,input().split())\n    incon=[0]*(m+1)\n    bridge=[0]*m\n    uf=Unionfind(n)\n    for i in range(m):\n        a,b=map(int,input().split())\n        bridge[i]=(a-1,b-1)\n    incon[m]=n*(n-1)//2\n\n    for i in range(m-1,-1,-1):\n        a,b=bridge[i]\n        incon[i]=incon[i+1]-uf.com_num(a,b)\n\n    for i in range(1,m+1):\n        print(incon[i])\n\nmain()", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n)]\n        self.rank = [1]*n\n        self.size = [1]*n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    def unite(self, x, y):\n        x = self.find(x); y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.parent[x] = y\n                self.size[y] += self.size[x]\n            else:\n                self.parent[y] = x\n                self.size[x] += self.size[y]\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n    def group_size(self, x):\n        return self.size[self.find(x)]\nn, m = map(int, input().split())\nx = [0]*m; x[m-1] = n*(n-1)//2; uf = UnionFind(n)\na = [0]*m; b = [0]*m\nfor i in range(m):\n    a[i], b[i] = map(int, input().split())\n    a[i] -= 1; b[i] -= 1\nfor i in range(m-1, 0, -1):\n    if uf.is_same(a[i], b[i]): x[i-1] = x[i]\n    else:\n        x[i-1] = x[i]-uf.group_size(a[i])*uf.group_size(b[i])\n        uf.unite(a[i], b[i])\nprint(*x, sep=\"\\n\")", "# Union Find \u6728\nfrom sys import setrecursionlimit\n\n\ndef find(parent, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, t)\n    parent[i] = t\n    return t\n\n\ndef unite(parent, i, j):\n    i = find(parent, i)\n    j = find(parent, j)\n    if i == j:\n        return\n    parent[j] += parent[i]\n    parent[i] = j\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\nAB = [[int(c) - 1 for c in input().split()] for _ in range(M)]\n\nparent = [-1] * N\ninconvenience = N * (N - 1) // 2\nresult = []\nfor a, b in AB[::-1]:\n    result.append(inconvenience)\n    pa, pb = find(parent, a), find(parent, b)\n    if pa != pb:\n        inconvenience -= parent[pa] * parent[pb]\n    unite(parent, a, b)\nprint((*result[::-1]))\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, v):\n        if self.parents[v] < 0:\n            return v\n        else:\n            self.parents[v] = self.find(self.parents[v])\n            return self.parents[v]\n\n    def unite(self, u, v):\n        u = self.find(u)\n        v = self.find(v)\n\n        if u == v:\n            return\n\n        if self.parents[u] > self.parents[v]:\n            u, v = v, u\n\n        self.parents[u] += self.parents[v]\n        self.parents[v] = u\n\n    def size(self, v):\n        return -self.parents[self.find(v)]\n\n    def same(self, u, v):\n        return self.find(u) == self.find(v)\n\nN, M = map(int, input().split())\nuf = UnionFind(N)\nedges = []\n\nfor i in range(M):\n    A, B = map(int, input().split())\n    edges.append((A-1, B-1))\n\ntotal = [N*(N-1)//2 for _ in range(M)]\n\nfor i in range(M-1):\n    u, v = edges[-i-1]\n    if uf.same(u, v):\n        total[-i-2] = total[-i-1]\n    else:\n        total[-i-2] = total[-i-1] - uf.size(u) * uf.size(v)\n        uf.unite(u, v)\n\nfor t in total:\n    print(t)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef culc(x):\n    return x*(x-1)//2\n\nn,m=list(map(int,input().split()))\nedge=[]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    edge.append((a,b))\n\n\nans=[culc(n)]\n\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=edge[m-i-1]\n    if uf.same(a,b):\n        ans.append(ans[-1])\n    else:\n        member_a=uf.size(a)\n        member_b=uf.size(b)\n        uf.union(a,b)\n        add=culc(member_a)+culc(member_b)-culc(uf.size(a))\n        ans.append(ans[-1]+add)\n\n\nfor i in range(m):\n    print((ans[m-i-1]))\n\n\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n      \nN,M = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(M)]\nab = ab[::-1]\nuf = UnionFind(N)\ndli = [N*(N-1)//2]*M\n\nfor i in range(M-1):\n  a = ab[i][0]-1\n  b = ab[i][1]-1\n  d = 0\n  if not uf.same(a,b):\n    d = uf.size(a)*uf.size(b)\n  uf.union(a,b)\n  \n  dli[i+1] = dli[i] - d\n  \ndli = dli[::-1]\nfor el in dli:\n  print(el)", "import sys\nfrom itertools import combinations\n\n# https://ikatakos.com/pot/programming_algorithm/data_structure/union_find_tree\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n        self.n = n\n        self.inconvenience = n * (n - 1) // 2\n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        self.inconvenience -= d1 * d2\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\ndef main():\n    input = sys.stdin.buffer.readline\n    n, m = list(map(int, input().split()))\n    bridges = [tuple([int(x) - 1 for x in input().split()]) for _ in range(m)]\n    ans = [0] * m\n    ans[-1] = n * (n - 1) // 2\n    uf = UnionFind(n)\n    for i in range(m - 2, -1, -1):\n        uf.union(*bridges[i + 1])\n        ans[i] = uf.inconvenience\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN,M= list(map(int,input().split()))\nAB = []\nfor _ in range(M):\n    AB.append(list(map(int,input().split())))\nans = [N*(N-1)//2]\nuf = UnionFind(N)\nwhile AB:\n    A,B = AB.pop()\n    A-=1\n    B-=1\n    if not uf.same(A,B):\n        ans.append(ans[-1]-uf.size(A)*uf.size(B))\n        uf.union(A,B)\n    else:\n        ans.append(ans[-1])\nfor i in range(len(ans)-2,-1,-1):\n    print((ans[i]))\n    \n    \n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m = map(int,input().split())\nab = [0]*m\nfor i in range(m):\n    ab[i] = list(map(int,input().split()))\nans = [0]*(m+1)\nans[0] = n*(n-1)//2\nuf = UnionFind(n+1)\nab = ab[::-1]\nfor i,[a,b] in enumerate(ab):\n    if uf.find(a) == uf.find(b):\n        ans[i+1] = ans[i]\n    else:\n        ans[i+1] = ans[i] - uf.size(a)*uf.size(b)\n    uf.union(a,b)\nfor i in range(m):\n    print(ans[-i-2])", "class UnionFindWithSize(object):\n    \"\"\"UnionFindTree based on union by size + path compression.\n    \"\"\"\n    def __init__(self, size):\n        self.parent = [i for i in range(size)]\n        self.size = [1]*size\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        # path compression\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        # union by size\n        if self.size[x] < self.size[y]:\n            self.size[y] += self.size[x]\n            self.parent[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parent[y] = x\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def sizeofset(self, x):\n        return self.size[self.find(x)]\n\ndef __starting_point():\n    N, M = map(int,input().split())\n    edges = []\n    for _ in range(M):\n        edges.append(tuple(map(lambda x:int(x)-1,input().split())))\n    uf = UnionFindWithSize(N)\n    anss = []\n    cnt = N*(N-1)//2\n    for i in range(M-1, -1, -1):\n        anss.append(cnt)\n        a,b = edges[i]\n        if not uf.same(a,b):\n            cnt -= uf.sizeofset(a)*uf.sizeofset(b)\n            uf.unite(a,b)\n    for x in reversed(anss):\n        print(x)\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn,m=map(int,input().split())\ne=[list(map(int,input().split())) for _ in range(m)][::-1]\nu=UnionFind(n)\ntmp=n*(n-1)//2\nans=[]\nfor a,b in e:\n    ans.append(tmp)\n    a,b=a-1,b-1\n    if u.same(a,b):\n        continue\n    tmp-=u.size(a)*u.size(b)\n    u.union(a,b)\nprint(*ans[::-1],sep='\\n')", "class UnionFind():    \n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * n\n        self.rnk = [0] * n\n        \n    def findRoot(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.findRoot(self.root[x])  #; print('root[x]', self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.findRoot(x)\n        y = self.findRoot(y)\n        if x == y:\n            return \n        elif self.rnk[x] > self.rnk[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rnk[x] == self.rnk[y]:\n                self.rnk[y] += 1\n\n    def isSame(self, x, y):\n        return self.findRoot(x) == self.findRoot(y)\n    \n    def count(self, x):\n        return -self.root[self.findRoot(x)]\n\n    \ndef nC2(n):\n    return n*(n-1) // 2 \n\n\nfrom itertools import accumulate\n\nN, M =  map(int, input().split())\nedge = [tuple(map(int, input().split())) for _ in range(M)]  #;print(edge)\n\ncomb = []\nuf = UnionFind(N+1)\nfor eg in edge[::-1]:\n    if not uf.isSame(eg[0], eg[1]):\n        pre0 = uf.count(eg[0])\n        pre1 = uf.count(eg[1])\n        uf.unite(eg[0], eg[1])\n        post = uf.count(eg[0])\n        #print(eg[0], eg[1], pre0, pre1, post, nC2(pre0), nC2(pre1), nC2(post) )\n        comb.append(nC2(post) - (nC2(pre0)+nC2(pre1)))\n    else:\n        comb.append(0)            \n#print(comb)\nfor i in accumulate(comb[::-1]):\n    print(i)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n\ndef main():\n    N, M, *AB = map(int, read().split())\n\n    count = N * (N - 1) // 2\n    ans = [count]\n    uf = UnionFind(N)\n\n    for a, b in zip(reversed(AB[::2]), reversed(AB[1::2])):\n        a -= 1\n        b -= 1\n        if not uf.same(a, b):\n            count -= uf.size(a) * uf.size(b)\n            uf.union(a, b)\n        ans.append(count)\n\n    print(*reversed(ans[:-1]), sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nclass UnionFind:\n  N=0\n  parent=None\n  size=None\n  def __init__(self,N):\n    self.N=N\n    self.parent=[i for i in range(self.N)]\n    self.size=[1]*self.N\n    \n  def root(self,x):\n    while x!=self.parent[x]:\n      self.parent[x]=self.parent[self.parent[x]]\n      x=self.parent[x]\n    return x\n  \n  def same(self,x,y):\n    return self.root(x)==self.root(y)\n  \n  def unite(self,x,y):\n    x=self.root(x)\n    y=self.root(y)\n    if x==y:\n      return\n    if self.size[x]>self.size[y]:\n      # \u5927\u304d\u3044\u65b9\u306b\u304f\u3063\u3064\u3051\u308b\n      self.parent[y]=x\n      self.size[x]+=self.size[y]\n    else:\n      self.parent[x]=y\n      self.size[y]+=self.size[x]\n      \n  def get_group_size(self,x):\n    return self.size[self.root(x)]\n  \n  def get_roots(self):\n    r=set()\n    for i in range(self.N):\n      r.add(self.root(i))\n    return r\n  \n  def show_parent(self):\n    print(self.parent)\n    \n  def show_size(self):\n    print(self.size)\n    \nN,M = map(int,readline().split())\nbridges = [tuple(map(int,readline().split())) for i in range(M)]\n\n# \u9806\u306b\u5d29\u843d\u3057\u3066\u3044\u304f = \u6700\u5f8c\u306b\u5d29\u843d\u3059\u308b\u3082\u306e\u304b\u3089\u9806\u306b\u5efa\u8a2d\u3055\u308c\u3066\u3044\u304f\u3068\u8003\u3048\u308b\n# \u6700\u521d\u306e\u4e0d\u4fbf\u3055\u306f(N * (N - 1)) // 2\n# \u65b0\u305f\u306ba,b\u306e\u9593\u306b\u6a4b\u304c\u7e4b\u304c\u308b\u3068\u3001[a\u304c\u5c5e\u3057\u3066\u3044\u305f\u5cf6\u3005 * b\u304c\u5c5e\u3057\u3066\u3044\u305f\u5cf6\u3005]\u3060\u3051\u4e0d\u4fbf\u3055\u304c\u6e1b\u308b\nUF = UnionFind(N)\nans = [0] * M\nnum = (N * (N - 1)) // 2\n\nfor i in range(len(bridges) - 1, -1, -1):\n  ans[i] = num\n  a,b = bridges[i]\n  a,b = a - 1,b - 1\n  if not UF.same(a,b):\n    num -= UF.get_group_size(a) * UF.get_group_size(b)\n  UF.unite(a,b)\n\nprint(*ans, sep = \"\\n\")", "n , m = list(map(int, input().split()))\nbridge = []\nfor i in range(m):\n    a , b = list(map(int, input().split()))\n    bridge.append((a,b))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(n)\nans1 = n*(n-1)//2\nans = []\nfor i in range(m):\n    ans.append(ans1)\n    a1,b1=bridge[m-1-i]\n    a1-=1\n    b1-=1\n    if not uf.same(a1,b1):\n        ans1 -= uf.size(a1)*uf.size(b1)\n    uf.union(a1,b1)\n\nans.reverse()\nfor i in ans:\n    print(i)\n", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1]*n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nN,M = map(int, input().split())\nAB = []\nfor i in range(M):\n    AB.append(list(map(int, input().split())))\nS = []\nuf = UnionFind(N)\nfor a,b in AB[::-1]:\n    if a < b:\n        a,b = b,a\n    x = uf.size(a-1)\n    y = uf.size(b-1)\n    uf.union(a-1,b-1)\n    z = uf.size(a-1)\n    t = z*(z-1)//2 - x*(x-1)//2 - y*(y-1)//2\n    if t < 0:\n        S.append(0)\n    else:\n        S.append(t)\n\nans = 0\nfor _ in range(M):\n    ans += S.pop()\n    print(ans)", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n=0):\n        self.d = [-1]*n\n        self.g = set()\n    \n    def find(self, x):\n        if self.d[x] < 0: return x\n        self.d[x] = self.find(self.d[x])\n        return self.d[x]\n\n    def unite(self, x, y):\n        x,y=self.find(x),self.find(y)\n        if x==y:return False\n        if self.d[x] > self.d[y]: x,y=y,x\n        self.d[x] += self.d[y]\n        self.g.add(x)\n        if y in self.g:self.g.remove(y)\n        self.d[y] = x\n        return True\n\n    def same(self,x,y): return self.find(x)==self.find(y)\n    def size(self,x): return -self.d[self.find(x)]\n    \ndef comb2(n):\n  return n*(n-1)//2\n    \nN,M=map(int,input().split())\nE = [tuple(map(int,input().split())) for _ in range(M)]\n\ntotal=comb2(N)\nuf = UnionFind(N+1)\nans = [total]\nfor i in range(M-1):\n  a,b = E[-i-1]\n  if uf.same(a,b):\n    ans.append(ans[-1])\n    continue\n  else:\n    size1,size2 = uf.size(a),uf.size(b)\n    uf.unite(a,b)\n    size3 = uf.size(a)\n    tmp = ans[-1]+comb2(size1)+comb2(size2)-comb2(size3)\n    ans.append(tmp)\nprint(*ans[::-1])", "n, m = map(int, input().split())\n\nparent = [i + 1 for i in range(n)]\nrank = [0 for i in range(n)]\nsize = [1 for i in range(n)]\n\ndef find(x):\n    if parent[x - 1] == x:\n        return x\n    else:\n        parent[x - 1] = find(parent[x - 1])\n        return parent[x - 1]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if rank[x - 1] < rank[y - 1]:\n        parent[x - 1] = y\n        size[y - 1] += size[x - 1]\n    else:\n        parent[y - 1] = x\n        size[x - 1] += size[y - 1]\n        if rank[x - 1] == rank[y - 1]:\n            rank[x - 1] += 1\n\ndef nc2(a):\n    return a * (a - 1) // 2\n\nab = []\nfor i in range(m):\n    ab.append(list(map(int, input().split())))\nab.reverse()\nans = [0]\nfor i in range(m):\n    a, b = ab[i][0], ab[i][1]\n    num_a = size[find(a) - 1]\n    num_b = size[find(b) - 1]\n    unite(a, b)\n    num = size[find(a) - 1]\n    if num_a != num:\n        ans.append(ans[-1] + nc2(num) - nc2(num_a) - nc2(num_b))\n    else:\n        ans.append(ans[-1])\nans.reverse()\nnum = nc2(n)\nfor i in range(m):\n    print(num - ans[i + 1])", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nN, M = map(int, input().split())\nAB = [list(map(lambda x: int(x)-1, input().split())) for _ in range(M)][::-1]\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [-x for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\nuf = UnionFind(N)\nans = []\ncnt = N*(N-1)//2\nfor a, b in AB:\n    ans.append(cnt)\n    if uf.same(a, b):\n        continue\n    cnt -= uf.size(a)*uf.size(b)\n    uf.union(a, b)\nfor a in ans[::-1]:\n    print(a)", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n\"\"\"\nD - Decayed Bridges\n\"\"\"\n\n\nclass UnionFind():\n    # \u4e0b\u8a18\u304b\u3089\u62dd\u501f\n    # https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(\n            '{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, M, AB):\n    AB = AB[::-1]\n    AB = [[ab[0] - 1, ab[1] - 1] for ab in AB]\n    un = UnionFind(N)\n    ans = [N * (N - 1) // 2]\n    for a, b in AB:\n        if un.same(a, b):\n            ans.append(ans[-1])\n            continue\n        ans.append(ans[-1] - (un.size(a) * un.size(b)))\n        un.union(a, b)\n    ans.reverse()\n    for a in ans[1:]:\n        print(a)\n\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    AB = [[int(i) for i in input().split()] for _ in range(M)]\n    solve(N, M, AB)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nUF = UnionFind(n)\nans = [n * (n - 1) // 2]\nfor a, b in edges[1:][::-1]:\n    a -= 1\n    b -= 1\n    if UF.same(a, b):\n        ans.append(ans[-1])\n    else:\n        ans.append(ans[-1] - UF.size(a) * UF.size(b))\n    UF.union(a, b)\nprint(*ans[::-1], sep = \"\\n\")\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = map(int, input().split())\nab = []\nuf = UnionFind(n+1)\nfor i in range(m):\n    a,b = map(int, input().split())\n    ab.append((a,b))\n\nans = []\nhuben = n*(n-1)//2\nfor a,b in ab[::-1]:\n    ans.append(huben)\n    if not uf.same(a,b):\n        huben -= uf.size(a)*uf.size(b)\n        uf.union(a,b)\n    \nfor aa in ans[::-1]:\n    print(aa)", "class UnionFind():\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1]*(n+1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0]*(n+1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if(x == y):\n            return \n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\nN, M = list(map(int, input().split()))\nbridges = [list(map(int, input().split())) for _ in range(M)]\nbridges = bridges[::-1]\nuf = UnionFind(N)\nans = N * (N-1) // 2\nres = []\nfor b in bridges:\n    res.append(ans)\n    x, y = b\n    if uf.isSameGroup(x, y):\n        pass\n    else:\n        ans -= uf.Count(x) * uf.Count(y)\n        uf.Unite(x, y)\n\nfor a in res[::-1]:\n    print(a)\n    \n", "import sys\nfrom itertools import combinations\n\n# https://ikatakos.com/pot/programming_algorithm/data_structure/union_find_tree\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n        self.n = n\n        self.inconvenience = n * (n - 1) // 2\n\n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        self.inconvenience -= d1 * d2\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\ndef main():\n    input = sys.stdin.buffer.readline\n    n, m = list(map(int, input().split()))\n    bridges = [tuple([int(x) - 1 for x in input().split()]) for _ in range(m)]\n    ans = [0] * m\n    ans[-1] = n * (n - 1) // 2\n    uf = UnionFind(n)\n    for i in range(m - 2, -1, -1):\n        uf.union(*bridges[i + 1])\n        ans[i] = uf.inconvenience\n    for i in range(m):\n        print((ans[i]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Union Find \u6728\nfrom sys import setrecursionlimit\n\n#\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\ndef find(parent, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, t)\n    parent[i] = t\n    return t\n\n#x\u3068y\u306e\u6728\u3092\u4f75\u5408\ndef unite(parent, i, j):\n    i = find(parent, i)\n    j = find(parent, j)\n    if i == j:\n        return\n    parent[j] += parent[i]\n    parent[i] = j\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\nAB = [[int(c) - 1 for c in input().split()] for _ in range(M)]\n# print(AB[::-1])\n\nparent = [-1] * N\ninconvenience = N * (N - 1) // 2\nresult = []\nfor a, b in AB[::-1]:\n    # print(inconvenience)\n    # print(parent)\n    result.append(inconvenience)\n\n    #a, b\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092parent\u306b\u8a18\u9332\u3059\u308b\n    pa, pb = find(parent, a), find(parent, b)\n    # print(pa, pb)\n    # print(parent[pa], parent[pb], parent[pa] * parent[pb])\n\n    #\n    if pa != pb:\n        inconvenience -= parent[pa] * parent[pb]\n\n    #\u53d6\u308a\u51fa\u3057\u305f\u8fba\u3092\u4f75\u5408\n    unite(parent, a, b)\n\nprint((*result[::-1]))\n", "N, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(M)]\n\n\nclass Union_Find:\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.siz = [1] * n\n\n    def root(self, x):\n        if self.par[x] == -1:\n            return x\n        else:\n            return self.root(self.par[x])\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return False\n\n        if self.siz[x] < self.siz[y]:\n            tmp = x\n            x = y\n            y = tmp\n\n        self.par[y] = x\n        self.siz[x] += self.siz[y]\n        return True\n\n    def size(self, x):\n        return self.siz[self.root(x)]\n\n\nuf = Union_Find(N)\nans = [0] * (M + 1)\nans[-1] = N * (N - 1) // 2\n\nfor i in range(M - 1, 0, -1):\n    a, b = AB[i]\n    a -= 1\n    b -= 1\n\n    if uf.issame(a, b):\n        ans[i] = ans[i + 1]\n    else:\n        ans[i] = ans[i + 1] - uf.size(a) * uf.size(b)\n\n    uf.unite(a, b)\n\nprint(*ans[1:], sep='\\n')", "# https://atcoder.jp/contests/abc120/tasks/abc120_d\n# Unionfind\n\n\nn, m = list(map(int, input().split()))\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        # \u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n        # \u6839\u304c\u30eb\u30fc\u30c8\u306e\u6642\u306f\u3001\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u683c\u7d0d\u3000\u6700\u521d\u306f\u5168\u3066\u6839\u3067\u8981\u7d20\u65701\n        self.parents = [-1] * n\n\n    # \u518d\u5e30 group\u306e\u6839\u3092\u8fd4\u3059\n    # \u7d4c\u8def\u5727\u7e2e\u3042\u308a\n    def find(self, x):\n        # 0\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\u306f\u6839\n        if self.parents[x] < 0:\n            # index\u3092\u8fd4\u3059\n            return x\n        else:\n            # \u6839\u306b\u306a\u308b\u307e\u3067\u89aa\u3092\u8fbf\u308b\n            # \u7d4c\u8def\u5727\u7e2e \u6839\u306eindex\u304c\u5168\u3066\u306e\u89aa\u306b\u518d\u5e30\u7684\u306b\u3064\u304f\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # group\u3092\u4f75\u5408\n    def union(self, x, y):\n        # \u6839\u3092\u63a2\u3059\n        x = self.find(x)\n        y = self.find(y)\n\n        # \u6700\u521d\u304b\u3089\u7d71\u5408\u3055\u308c\u3066\u3044\u308b\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        # \u6839\u306e\u30b0\u30eb\u30fc\u30d7\u6570\u3092\u8ffd\u52a0 x\u306e\u65b9\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u304c\u591a\u3044\u524d\u63d0\u306a\u306e\u3067\u591a\u3044\u65b9\u306b\u5bc4\u305b\u308b\n        self.parents[x] += self.parents[y]\n        # \u89aa(\u6839)\u306eindex\u3092\u5165\u308c\u308b\n        self.parents[y] = x\n\n    # x\u306egroup\u306e\u30b5\u30a4\u30ba\n    def size(self, x):\n        return - self.parents[self.find(x)]\n\n    # \u6839\u304c\u540c\u3058\u304b\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u30eb\u30fc\u30c8\u304c\u540c\u3058\u8981\u7d20\u3092\u8fd4\u3059\n    def members(self, x):\n        root = self.find(x)\n        # \u6839\u304c\u540c\u3058\u8981\u7d20\n        return [i for i, in range(self.n) if self.find(i) == root]\n\n    # \u5168\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u8fd4\u3059\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u6570\u3048\u308b\n    def group_count(self):\n        return len(self.roots())\n\n    # {root: [\u8981\u7d20]}\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n\nedge = []\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    edge.append((a - 1, b - 1))\n\nans = [n * (n - 1) // 2]\n\nuf = UnionFind(n)\n# \u8fba\u3092\u5f8c\u308d\u304b\u3089\u8ffd\u52a0\u3057\u3066\u3044\u304f\nfor a, b in reversed(edge):\n    if not uf.same(a, b):\n        ag = uf.size(a)\n        bg = uf.size(b)\n        uf.union(a, b)\n        ans.append(ans[-1] - ag * bg)\n    else:\n        ans.append(ans[-1])\n\nans.pop()\nfor i in reversed(ans):\n    print(i)\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nclass UnionFind:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n\ndef main():\n    N, M, *AB = map(int, read().split())\n\n    AB = list(reversed(AB[2:]))\n    count = N * (N - 1) // 2\n    ans = [count]\n    uf = UnionFind(N)\n\n    for a, b in zip(AB[::2], AB[1::2]):\n        a -= 1\n        b -= 1\n        if not uf.same(a, b):\n            count -= uf.size(a) * uf.size(b)\n            uf.union(a, b)\n        ans.append(count)\n\n    print('\\n'.join(map(str, reversed(ans))), sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#AC\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef culc(x):\n    return x*(x-1)//2\n\nn,m=list(map(int,input().split()))\nedge=[]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    edge.append((a,b))\n\n\nans=[culc(n)]\n\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=edge[m-i-1]\n    if uf.same(a,b):\n        ans.append(ans[-1])\n    else:\n        member_a=uf.size(a)\n        member_b=uf.size(b)\n        uf.union(a,b)\n        #\u4e0d\u4fbf\u3055\u306e\u6e1b\u5c11\u5e45(>=0)\n        add=culc(uf.size(a))-culc(member_a)-culc(member_b)\n        ans.append(ans[-1]-add)\n\n\nfor i in range(m):\n    print((ans[m-i-1]))\n\n\n\n"]
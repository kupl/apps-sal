["import sys\ninput = sys.stdin.readline\n\nN, K = list(map(int, input().split()))\nnums = []\nfor i in range(N):\n    t, d = list(map(int, input().split()))\n    nums.append((d, t))\nnums.sort(reverse=True)\nse = set()\na1 = []\na2 = []\nrest = []\nfor i, n in enumerate(nums):\n    if i < K:\n        if not n[1] in se:\n            se.add(n[1])\n            a1.append(n)\n        else:\n            a2.append(n)\n    else:\n        rest.append(n)\npoints = 0\nfor (d, t) in a1: points += d\nfor (d, t) in a2: points += d\nans = points + pow(len(se), 2)\na2.sort()\nidx2 = 0\nfor i, (d, t) in enumerate(rest):\n    if t in se: continue\n    if len(a2) <= idx2: break\n    points -= a2[idx2][0]\n    idx2 += 1\n    points += d\n    se.add(t)\n    ans = max(ans, points+pow(len(se), 2))\nprint(ans)\n", "n, k = list(map(int, input().split()))\ntd = [list(map(int, input().split())) for _ in range(n)]\n\ntd.sort(key=lambda x: x[1], reverse=True)\n\ntypes = set()\ncan_remove = []\nd_sm = 0\n\nfor t, d in td[:k]:\n\td_sm += d\n\tif t in types:\n\t\tcan_remove.append(d)\n\telse:\n\t\ttypes.add(t)\n\ntype_cnt = len(types)\n\nans = d_sm + type_cnt ** 2\n\nleft = td[k:][::-1]\n\nwhile can_remove and left:\n\tt, d = left.pop()\n\tif t not in types:\n\t\ttypes.add(t)\n\t\td_rmv = can_remove.pop()\n\t\td_sm += d - d_rmv\n\t\ttype_cnt += 1\n\t\tans = max(ans, d_sm + type_cnt ** 2)\n\nprint(ans)\n", "n,k = map(int,input().split())\nsushi = [[int(i) for i in input().split()] for _ in range(n)]\nsushi.sort(key=lambda x: x[1],reverse=True)\neaten = [False]*n\nd1 = [0]\nd2 = [0]\nfor i in range(n):\n    t,d = sushi[i]\n    t -= 1\n    if eaten[t]: d1.append(d1[-1]+d)\n    else:\n        eaten[t] = True\n        d2.append(d2[-1]+d)\n# print(d1)\n# print(d2)\nans = 0\nfor i in range(1,k+1):\n    if k-i >= len(d1): continue\n    if i >= len(d2): continue\n    ans = max(ans, d1[k-i] + d2[i] + i*i)\nprint(ans)", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nN, K = map(int, input().split())\nTD = []\n\nfor _ in range(N):\n  TD.append(tuple(map(int, input().split())))\n\nTD.sort(key = lambda x:x[1], reverse=True)\n\nD = defaultdict(list)\nT = [0]*(N+1)\nH = []\nans = [0]\n\nfor i, td in enumerate(TD):\n  t, d = td[0], td[1]\n  if i == K:\n    break\n  T[t] += 1\n  D[t].append(d)\n  ans[0] += d\n  if T[t] >= 2:\n    heappush(H, (D[t].pop(), t))\n    T[t] -= 1\n\ncnt = sum(1 for c in T if c >= 1)\nans[0] += cnt**2\n\nfor i in range(K, N):\n  if H:\n    t1, d1 = TD[i]\n    if T[t1] == 0:\n      d2, t2 = heappop(H)\n      ans.append(ans[-1] + d1 - d2 + 2*cnt + 1)\n      cnt += 1\n      T[t1] += 1\n  else:\n    break\n\nprint(max(ans))", "n,k=map(int,input().split())\ntd=[list(map(int,input().split()))[::-1]for _ in range(n)]\ntd.sort(reverse=1)\ns=set()\nss=set()\na=[]\nb=[]\nc=[]\nfor i in range(n):\n  if i<k:\n    d,t=td[i]\n    if t in s:\n      b.append(d)\n    else:\n      a.append(d)\n      s.add(t)\n      ss.add(t)\n  else:\n    d,t=td[i]\n    if t not in ss:\n      c.append(d)\n      ss.add(t)\nc=c[::-1]\nls=len(s)\nsu=sum(a)+sum(b)\nans=ls*ls+su\nfor i in range(min(len(b),len(c))):\n  ls+=1\n  su-=b.pop()\n  su+=c.pop()\n  ans=max(ans,ls*ls+su)\nprint(ans)", "import heapq\nfrom operator import itemgetter\n\nn, k = list(map(int, input().split()))\nsushi = [tuple(map(int, input().split())) for _ in range(n)]\n\nsushi.sort(key=itemgetter(1), reverse=True)\nque = []\nkind = set()\nres = 0\nfor t, d in sushi[:k]:\n    if t in kind:\n        heapq.heappush(que, d)\n    else:\n        kind.add(t)\n    res += d\nres += len(kind)**2\n\nval = res\nfor t, d in sushi[k:]:\n    if not que:\n        break\n    if t in kind:\n        continue\n    val += -heapq.heappop(que) + d + len(kind)*2 + 1\n    kind.add(t)\n    res = max(res, val)\n\nprint(res)\n", "n,k = map(int,input().split())\ntd = [list(map(int,input().split())) for i in range(n)]\ntd.sort(key=lambda x:x[1],reverse=True)\na = 0\nans = []\nkind = [-1]*n\nc = 0\nmin_p = []\nfor i in range(n):\n    eat = False\n    if i<k:\n        a += td[i][1]\n        eat = True\n    else:\n        if min_p:\n            if kind[td[i][0]-1]<0:\n                a -= (min_p.pop()-td[i][1])\n                a += (c+1)**2-c**2\n                ans.append(a)\n                eat = True\n    if eat:\n        if kind[td[i][0]-1]<0:\n            kind[td[i][0]-1]=1\n            c+=1\n        else:min_p.append(td[i][1])\n    if i==k-1:\n        a += c**2\n        ans.append(a)\nprint(max(ans))", "import heapq\nN,K=map(int,input().split())\nTD=[list(map(int,input().split())) for _ in range(N)]\nTD.sort(key=lambda x:x[1], reverse=True)\n\nNETA=set()\nduplication=[]\nheapq.heapify(duplication)\nans=0\nfor t,d in TD[:K]:\n    if t in NETA:\n        heapq.heappush(duplication,d)\n    else:\n        NETA.add(t)\n    ans+=d\n\ns=[-float(\"inf\")]*(K+1)\ncnt=len(NETA)\ns[cnt]=ans\nfor t,d in TD[K:]:\n    if t in NETA:\n        continue\n    else:\n        if duplication:\n            x=heapq.heappop(duplication)\n            ans+=d-x\n            NETA.add(t)\n            cnt+=1\n            s[cnt]=ans\n\nfor i in range(K+1):\n    s[i]+=i*i\nprint(max(s))", "import sys\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nsushi = [tuple(map(int, input().split())) for _ in range(N)]\n\nsushi.sort(key=lambda x: x[1], reverse=True)\n\nused = [0 for _ in range(N)]\ndup = []\ndeli = 0\n\nfor i in range(K):\n    t, d = sushi[i]\n    if used[t - 1]:\n        dup.append(d)\n    used[t - 1] = 1\n    deli += d\n\nvari = sum(used)\nsat = vari**2 + deli\n\ndup.sort(reverse=True)\n\nfor i in range(N - K):\n    if not dup:\n        break\n    t, d = sushi[K + i]\n    if used[t - 1]:\n        continue\n    used[t - 1] = 1\n    deli -= dup.pop()\n    deli += d\n    vari += 1\n    sat = max(sat, vari**2 + deli)\n\nprint(sat)", "def main():\n    N, K = list(map(int, input().split()))\n    sushi_list = list()\n    for _ in range(N):\n        t, d = list(map(int, input().split()))\n        t -= 1\n        sushi_list.append((t, d))\n    sushi_list.sort(key=lambda s: s[1], reverse=True)  # \u304a\u3044\u3057\u3055\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\n    # \u304a\u3044\u3057\u3055Top K\u306e\u3059\u3057\u3092\u3068\u308b\u306e\u3092\u521d\u671f\u89e3\u3068\u3059\u308b\n    neta_flag_list = [0] * N\n    topk_extra_sushi_list = list()  # Top K\u306e\u3059\u3057\u3067\u3001\u5404\u30cd\u30bf\u6700\u5927\u306e\u304a\u3044\u3057\u3055\u306f\u306a\u3044\u3059\u3057\n    additional_sushi_list = list()  # Top K\u306e\u3059\u3057\u306e\u30cd\u30bf\u4ee5\u5916\u3067\u3001\u5404\u30cd\u30bf\u306e\u6700\u5927\u306e\u304a\u3044\u3057\u3055\u306e\u3059\u3057\n    point_topk = 0\n    for k, sushi in enumerate(sushi_list):\n        if k < K:\n            if neta_flag_list[sushi[0]] == 1:\n                topk_extra_sushi_list.append(sushi)\n            point_topk += sushi[1]\n        else:\n            if neta_flag_list[sushi[0]] == 0:\n                additional_sushi_list.append(sushi)\n        neta_flag_list[sushi[0]] = 1\n    n_neta = K - len(topk_extra_sushi_list)\n    point_topk += n_neta ** 2\n    # \u305d\u306e\u4ed6\u306e\u30cd\u30bf\u3092t\u7a2e\u985e\u8ffd\u52a0\u3059\u308b\u5834\u5408\u3092\u8003\u3048\u3066\u3001\u521d\u671f\u89e3\u3068\u6bd4\u8f03\u3057\u3066\u3044\u304f\n    d_extra, d_additional = 0, 0\n    ans = point_topk\n    n_additional_neta = min(K - n_neta, len(topk_extra_sushi_list), len(additional_sushi_list))\n    for t in range(1, n_additional_neta + 1):\n        n_cur_neta = n_neta + t\n        d_extra += topk_extra_sushi_list[-t][1]\n        d_additional += additional_sushi_list[t - 1][1]\n        point = point_topk - d_extra + d_additional + (n_cur_neta**2 - n_neta**2)\n        ans = max(ans, point)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\n\nn, k = list(map(int, input().split()))\ntop = [0] * n\nsub = []\n\nfor i in range(n):\n    t, d = list(map(int, input().split()))\n    t -= 1\n    if top[t] == 0:\n        top[t] = d\n    else:\n        if d > top[t]:\n            sub.append(top[t])\n            top[t] = d\n        else:\n            sub.append(d)\n\ntop.sort(reverse=True)\ntop_sum = [0]\nsub.sort(reverse=True)\nsub_sum = [0]\n\nfor p in top:\n    if p == 0:\n        top_sum.append(-1)\n    else:\n        top_sum.append(top_sum[-1] + p)\n\nfor p in sub:\n    sub_sum.append(sub_sum[-1] + p)\n\nans = 0\n\nfor i in range(1, k + 1):\n    if (len(sub_sum) - 1) >= (k - i) and top_sum[i] != -1:\n        ans = max(ans, top_sum[i] + sub_sum[k - i] + i ** 2)\n\nprint(ans)\n", "import heapq\nN, K = map(int,input().split())\nL1 = []\nL2 = []\nS = set()\nval = 0\n\nfor _ in range(N):\n    t, d = map(int,input().split())\n    L1.append((d, t))\n\nL1.sort(reverse = True)\n\nfor i in range(K):\n    val += L1[i][0]\n    if L1[i][1] in S:\n        heapq.heappush(L2, L1[i][0])\n    else:\n        S.add(L1[i][1])\n\nans = val + len(S) ** 2\n\nfor i in range(K, N):\n    if len(L2) == 0:\n        break\n    if not L1[i][1] in S:\n        S.add(L1[i][1])\n        val -= heapq.heappop(L2)\n        val += L1[i][0]\n        ans = max(ans, val + len(S) ** 2)\n\nprint(ans)", "N,K,*L=map(int,open(0).read().split());L=L[::-1]\nI=set();X=0;U=[];D=[]\nfor d,t in sorted(zip(*[iter(L)]*2))[::-1]:\n\tif t in I:D+=d,\n\telif X<K:I|={t};U+=d,;X+=1\nD+=0,;i=K-X\nwhile X and U[-1]+2*X-1<=D[i]:U.pop();X-=1;i+=1\nprint(sum(U+D[:i])+X**2)", "N, K = map(int, input().split())\nTD = [tuple(map(int, input().split())) for _ in range(N)]\nM = len(set([t for t, d in TD]))\n \nTD.sort(key=lambda x: x[1], reverse=True)\np, S, V = 0, [], set()\nfor t, d in TD[:K]:\n    p += d\n    if t in V:\n        S.append(d)\n    else:\n        V.add(t)\np += len(V) ** 2\nans = p\nfor t, d in TD[K:]:\n    if len(S) == 0:\n        break\n    if t not in V:\n        p += 2 * len(V) + 1 - S.pop() + d\n        V.add(t)\n        ans = max(ans, p)\nprint(ans)", "import heapq as hq\n\nn,k=map(int,input().split())\nA=[]\nS0=[] #\u7a2e\u985e\u304c\u5897\u3048\u306a\u3044\u5bff\u53f8\nS1=[] #\u7a2e\u985e\u304c\u5897\u3048\u308b\u5bff\u53f8\nfor i in range(n):\n    t,d=map(int,input().split())\n    A.append([t,d])\nA=list(reversed(sorted(A)))\n\nnow=0\nfor i in range(n):\n    t=A[i][0]\n    d=A[i][1]\n    if now==t:\n        S0.append(-d)\n    else:\n        S1.append(-d)\n        now=t\nhq.heapify(S0)\nhq.heapify(S1)\nC=[] #\u6d88\u3057\u5f97\u308b\u5bff\u53f8\u306e\u30b9\u30c8\u30c3\u30af(S0\u304b\u3089\u51fa\u3057\u305f\u3082\u306e)\n\nx=0 #\u304a\u3044\u3057\u3055\u306e\u5408\u8a08\ny=0 #\u7a2e\u985e\u6570\nfor i in range(k):\n    if len(S0)==0:\n        x+=-hq.heappop(S1)\n        y+=1\n        continue\n    if len(S1)==0:\n        s0=-hq.heappop(S0)\n        x+=s0\n        hq.heappush(C,s0)\n        continue\n    if S1[0]<=S0[0]:\n        x+=-hq.heappop(S1)\n        y+=1\n    else:\n        s0=-hq.heappop(S0)\n        x+=s0\n        hq.heappush(C,s0)\nans=x+y**2\n\nfor i in range(min(len(S1),len(C))):\n    c=hq.heappop(C)\n    s1=-hq.heappop(S1)\n    x+=s1-c\n    y+=1\n    ans=max(x+y**2,ans)\nprint(ans)", "import heapq\nN,K = map(int,input().split())\ntd = [list(map(int,input().split())) for i in range(N)]\ntd.sort(key = lambda x:-x[1])\nsumn = [[] for i in range(N)]\nfor i in range(N):\n    heapq.heapify(sumn[i])\nans = 0\nkind = {}\nfor t,d in td[:K]:\n    if t not in kind:\n        kind[t] = 1\n    else:\n        kind[t] += 1\n    heapq.heappush(sumn[t-1],d)\nkinds = len(kind)\nans = sum(sum(i) for i in sumn)\nans1 = ans +kinds**2\nrem = td[K:]\nnex = 0\ncandel = []\nheapq.heapify(candel)\nfor k,v in kind.items():\n    for i in range(v-1):\n        heapq.heappush(candel,heapq.heappop(sumn[k-1]))\nif candel:\n    qd = heapq.heappop(candel)\n    while K+nex < N:\n        if td[K+nex][0] not in kind:\n            kind[td[K+nex][0]] = 1\n            kinds += 1\n            ans = ans - qd + td[K+nex][1]\n            ans1 = max(ans1,ans+kinds**2)\n            nex += 1\n            if candel:\n                qd = heapq.heappop(candel)\n            else:\n                break\n        else:\n            nex += 1\nprint(ans1)", "N,K = map(int,input().split())\nTD = [[int(j) for j in input().split()] for i in range(N)]\nTD = sorted(TD,key=lambda x:-x[1])\npoint = 0\nstack = []\nkind = set()\n\nfor t,d in TD[:K]:\n  point+=d\n  if t in kind:\n    stack.append(d)\n  else:\n    kind.add(t)\n\npoint+=len(kind)**2\nans = point\n\nfor t,d in TD[K:]:\n  if not stack:\n    break\n  if not t in kind:\n    point+=d-stack.pop()+2*len(kind)+1\n    kind.add(t)\n    ans=max(ans,point)\n\nprint(ans)", "n,k=map(int,input().split())\nTD=[]\nfor i in range(n):\n  t,d=map(int,input().split())\n  TD.append([t,d])\nTD.sort(key=lambda x:x[1],reverse=True)\nV=set()\nS=[]\nans=0\nfor t,d in TD[:k]:\n  ans+=d\n  if t in V:\n    S.append(d)\n  else:\n    V.add(t)\nans+=len(V)**2\nx=ans\nfor t,d in TD[k:]:\n  if S==[]:\n    break\n  if not t in V:\n    x=x-S.pop()+d-len(V)**2+(len(V)+1)**2\n    V.add(t)\n    ans=max(x,ans)\nprint(ans)", "#!/usr/bin/env python3\n\nfrom collections import defaultdict\n\ndef main():\n    n, k = list(map(int, input().split()))\n    td = []\n    for i in range(n):\n        ti, di = list(map(int, input().split()))\n        td.append((ti, di))\n    td = list(reversed(sorted(td)))\n    tdd = defaultdict(list)\n    for t, d in td:\n        tdd[t].append(d)\n\n    a = []; b = []\n    for _, v in list(tdd.items()):\n        a.append(v[0])\n        b += v[1:]\n\n    a = list(reversed(sorted(a)))\n    b = list(reversed(sorted(b)))\n    for i in range(1, len(a)):\n        a[i] += a[i - 1]\n    for i in range(len(a)):\n        a[i] += (i + 1) ** 2\n    for i in range(1, len(b)):\n        b[i] += b[i - 1]\n\n    a = [0] + a\n    b = [0] + b\n\n    res = 0\n    for i in range(1, k + 1):\n        if i >= len(a) or (k - i) >= len(b):\n            continue\n        ts = a[i] + b[k - i]\n        res = max(res, ts)\n\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k=map(int,input().split())\nX=[]\nfor i in range(n):\n    t,d=map(int,input().split())\n    X.append([t,d])\n    \nX.sort(key=lambda x:x[1],reverse=True)\n\nV=set()\npoint=0\nS=[]\n\nfor t,d in X[:k]:\n    point+=d\n    if t in V:\n        S.append(d)\n    else:\n        V.add(t)\npoint+=len(V)**2\n\nans=point\n\nfor t,d in X[k:]:\n    if not S:\n        break\n    if not t in V:\n        point+=d-S.pop()+1+len(V)*2\n        V.add(t)\n        ans=max(ans,point)\n\nprint(ans)", "import sys\nread = sys.stdin.readline\nn, k = list(map(int, read().split()))\n# \u7a2e\u985e\u6570\u3092\u5897\u3084\u3059\u3068\u304d\u306f\u3001\u5404\u7a2e\u985e\u3067\u6700\u3082\u3067\u304b\u3044\u306e\u3092\u98df\u3079\u308b\n# \u7a2e\u985e\u6570\u6700\u5927\u964d\u9806\u914d\u5217\u3001\u4ed6\u964d\u9806\u914d\u5217\u307f\u305f\u3044\u306a\u306e\u7528\u3044\u3057t\u3048\n# \u98df\u3079\u308b\u51fa\u4e95\u6570\u3092\u5168\u63a2\u7d22\u3059\u308b\n# \u7d2f\u7a4d\u548c\nsushi = [[] for _ in range(n)]\n\nfor i in range(n):\n    t, d = list(map(int, read().split()))\n    t -= 1\n    sushi[t].append(d)\n\nmax_sushi = []\nother_sushi = []\nfor i in range(n):\n    if len(sushi[i]) == 0:\n        continue\n    sushi[i].sort()\n    max_sushi.append(sushi[i][-1])\n    for j in range(len(sushi[i]) - 1):\n        other_sushi.append(sushi[i][j])\nmax_sushi.sort(reverse=True)\nother_sushi.sort(reverse=True)\n\nfor i in range(len(max_sushi) - 1):\n    max_sushi[i + 1] += max_sushi[i]\nfor i in range(len(other_sushi) - 1):\n    other_sushi[i + 1] += other_sushi[i]\n\na = len(max_sushi)\nb = len(other_sushi)\nans = 0\nfor x in range(1, k + 1):\n    if x > a or k - x > b:\n        continue\n    other = 0 if k - x - 1 < 0 else other_sushi[k - x - 1]\n    ans = max(ans, x * x + max_sushi[x - 1] + other)\nprint(ans)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,k = map(int, input().split())\n    td = [list(map(int, input().split())) for _ in range(n)]\n    td.sort(reverse=True, key=lambda a: a[1])\n    delicious = 0\n    syurui = set()\n    suteru = []\n    for i in range(k):\n        t, d = td[i]\n        delicious += d\n        if  t in syurui:\n            suteru.append(d)\n        else:\n            syurui.add(t)\n    heapify(suteru)\n    neta = len(syurui)\n    res = delicious + neta**2\n    for i in range(k, n):\n        t, d = td[i]\n        if t in syurui:\n            continue\n        if len(suteru)==0:\n            print(res)\n            return\n        syurui.add(t)\n        delicious += d - heappop(suteru)\n        neta += 1\n        res = max(res, delicious+neta**2)\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappush, heappop\n\nn, k = list(map(int, input().split()))\ntd = [list(map(int, input().split())) for _ in range(n)]\n\ntd.sort(key=lambda x: x[1], reverse=True)\n\ntypes = set()\ncan_remove = []\nd_sm = 0\n\nfor t, d in td[:k]:\n\td_sm += d\n\tif t in types:\n\t\tcan_remove.append(d)\n\telse:\n\t\ttypes.add(t)\n\ntype_cnt = len(types)\n\nans = d_sm + type_cnt ** 2\n\nleft = []\nfor t, d in td[k:]:\n\td = -d\n\theappush(left, [d, t])\n\nwhile can_remove and left:\n\td, t = heappop(left)\n\td = -d\n\tif t not in types:\n\t\ttypes.add(t)\n\t\td_rmv = can_remove.pop()\n\t\td_sm += d - d_rmv\n\t\ttype_cnt += 1\n\t\tans = max(ans, d_sm + type_cnt ** 2)\n\nprint(ans)\n", "# various sushi\nimport heapq\nN, K = map(int, input().split())\nque = []\nfor i in range(N):\n    t, d = map(int, input().split())\n    que.append((t, d))\n\nque.sort(key=lambda x: -x[1])\nNOW = que[:K]\n\nN_set = set()\n\nsums = 0\n\ncnt = [0 for i in range(N+1)]  # \u306d\u305fx\u306b\u4f55\u500b\u3044\u308b\u304b\nng,ok,sub = [], [], []\nheapq.heapify(ng)\nheapq.heapify(ok)\nheapq.heapify(sub)\n\nfor index, value in NOW:\n    sums += value\n    cnt[index] += 1\n    heapq.heappush(ng, (value, index))\n    N_set.add(index)\nwhile ng:\n    value, index = heapq.heappop(ng)\n    if cnt[index] > 1:\n        heapq.heappush(ok, (value, index))\n        cnt[index] -= 1\n    elif cnt[index] == 1:\n        heapq.heappush(sub, (value, index))\n\nng = sub\n\n# ng \u3068\u3063\u3061\u3083\u30c0\u30e1\u306a\u3084\u3064\n# ok \u3068\u3063\u3066\u3082\u3044\u3044\u3084\u3064\n\nS = len(N_set)\nans = S**2+sums\n\n\n# \u3053\u308c\u3088\u308a\u66f4\u65b0\u3059\u308b\u3053\u3068\u306f\u3042\u308b\u304b\uff1f\n\nfor i in range(K, N):\n    taste, value = que[i]\n    if taste in N_set:\n        pass\n    else:\n        #taste not in N_set\n        if ok:\n            min_value, m_taste = heapq.heappop(ok)\n            sums -= min_value\n            sums += value\n            S += 1\n            cnt[taste] += 1\n            N_set.add(taste)\n            cnt[m_taste] -= 1\n            heapq.heappush(ng, (value, taste))\n            ans = max(ans, S**2+sums)\n\nprint(ans)", "N,K=map(int,input().split())\nt=[list(map(int,input().split())) for _ in range(N)]\nt.sort(key=lambda x:-x[1])\nans=0\ndp=set()\np=[]\nfor i in range(K):\n  ans+=t[i][1]\n  if t[i][0] in dp:\n    p.append(t[i][1])\n  dp.add(t[i][0])\nans+=len(dp)**2\nwer=ans\nwhile K<N and p:\n  if t[K][0] not in dp:\n    wer=wer+t[K][1]-p.pop()-len(dp)**2+(len(dp)+1)**2\n    ans=max(ans,wer)\n    dp.add(t[K][0])\n  K+=1\nprint(ans)", "n, k = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab_s = sorted(ab, key=lambda x: x[1])\nab_r = list(reversed(ab_s))\n\nt = [x[0] for x in ab_r]\nd = [x[1] for x in ab_r]        \n\nt_set = len(set(t[:k]))\nd_sum = sum(d[:k])\n\nres = [t_set**2 + d_sum]\n\nfrom collections import Counter\nt_cou = Counter(t[:k])\n\ndp =[0]*(n+1)\nj_old = k-1\n\nfor i in t_cou:\n    dp[i] = t_cou[i]\n\nfor i in range(k,n):\n    t_new = ab_r[i][0]\n    if dp[t_new] ==0:\n        for j in range(j_old,-1,-1):\n            t_old = ab_r[j][0]\n            if dp[t_old] <=1:\n                pass\n            else:\n                dp[t_new] =1\n                dp[t_old] -=1\n                t_set +=1\n                d_sum = d_sum - ab_r[j][1] + ab_r[i][1]\n                res.append(t_set**2 + d_sum)\n                j_old = j-1\n                break\n            j_old = 0\n\nprint(max(res))", "#!/usr/bin/env python3\nimport sys\ntry:\n    from typing import List\nexcept ImportError:\n    pass\n\n\ndef solve(N: int, K: int, t: \"List[int]\", d: \"List[int]\"):\n    ss = sorted(zip(d, t), reverse=True)\n    gs = []\n    mst = set()\n    for di, ti in ss[:K]:\n        if ti in mst:\n            gs.append((di, ti))\n        else:\n            mst.add(ti)\n    dm = {}\n    for di, ti in ss[K:]:\n        if ti in dm or ti in mst:\n            continue\n        dm[ti] = di\n    hs = sorted(((di, ti) for ti, di in list(dm.items())), reverse=True)\n    cd = sum(di for di, ti in ss[:K])\n    ct = len(mst)\n    m = cd + ct * ct\n    for (gdi, gti), (hdi, hti) in zip(reversed(gs), hs):\n        cd += hdi - gdi\n        ct += 1\n        m = max(m, cd + ct * ct)\n    print(m)\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    t = [int()] * (N)  # type: \"List[int]\"\n    d = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        t[i] = int(next(tokens))\n        d[i] = int(next(tokens))\n    solve(N, K, t, d)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K,*L=list(map(int,open(0).read().split()))\nS=sorted([(d,t)for t,d in zip(*[iter(L)]*2)],reverse=True)\nIn=set()\nX=0\nuni=[]\ndub=[]\nfor d,t in S:\n\tif t not in In:\n\t\tIn.add(t)\n\t\tuni.append(d)\n\t\tX+=1\n\t\tif X==K:\n\t\t\tbreak\n\telse:\n\t\tdub.append(d)\ndet=sum(dub[:K-X])\ndub=dub[K-X:]\nfor d in dub:\n\tif uni[-1]+2*X-1<=d:\n\t\tuni.pop()\n\t\tX-=1\n\t\tdet+=d\n\telse:\n\t\tbreak\nprint((sum(uni)+det+X**2))\n\n", "from collections import defaultdict\nN,K=map(int,input().split())\n\ndtlist=[]\ntset_all=set()\nfor i in range(N):\n  t,d=map(int,input().split())\n  dtlist.append((d,t))\n  tset_all.add(t)\ndtlist.sort()\n#print(heapq)\n\ndtlist_Krev=[]\ndsum=0\ntdic=defaultdict(int)\nfor i in range(K):\n  d,t=dtlist.pop()\n  dtlist_Krev.append((d,t))\n  dsum+=d\n  tdic[t]+=1\ndtlist_Krev.sort(reverse=True)\n\nt0=len(tdic)\nmax_answer=dsum+(t0**2)\n#print(t0,max_answer)\n\nfor i in range(t0+1,min(K,len(tset_all))+1):\n  loop_flg=True\n  while(loop_flg):    \n    d,t=dtlist_Krev.pop()\n    if tdic[t]>1:\n      tdic[t]-=1\n      dsum-=d\n      \n      while(True):        \n        d2,t2=dtlist.pop()\n        if tdic[t2]==0:\n          tdic[t2]=1\n          dsum+=d2\n          loop_flg=False\n          break\n          \n  answer_i=dsum+(i**2)\n  #print(i,answer_i)\n  max_answer=max(max_answer,answer_i)\n  \nprint(max_answer)", "# D - Various Sushi\nimport sys\nfrom collections import defaultdict\nimport heapq\n\nreadline = sys.stdin.readline\n\ndd = defaultdict(list)\nN, K = list(map(int, readline().split()))\nfor i in range(N):\n    t, d = list(map(int, readline().split()))\n    heapq.heappush(dd[t], d*-1)\n\ndd = list(dd.values())\ndd.sort()\n\nans = 0\nfix = 0\nvar = []\nlen_var = 0\nsum_var = 0\ntmp_max = 0\n\nfor i in range(min(K, len(dd))):\n    fix += heapq.heappop(dd[i]) * -1\n    for _ in range(len(dd[i])):\n        tmp = heapq.heappop(dd[i]) * -1\n        heapq.heappush(var, tmp)\n        len_var += 1\n        sum_var += tmp\n    while len_var > K-(i+1) and len_var > 0:\n        del_var = heapq.heappop(var)\n        len_var -= 1\n        sum_var -= del_var\n    if len_var == K-(i+1):\n        ans = max(ans , fix+sum_var + (i+1)**2)\n\nprint(ans)\n", "import heapq\nn,k = list(map(int,input().split()))\nL = []\nfor i in range(n):\n    t,d = list(map(int,input().split()))\n    L.append([d,t])\nL.sort()\nans = []\ncur = [0]*n\nheap = []\nvar = 0\nfor i in range(k):\n    if cur[L[n-i-1][1]-1] == 0:\n        ans.append(L[n-i-1][0])\n        cur[L[n-i-1][1]-1] = 1\n        var += 1\n    else:\n        heapq.heappush(heap, L[n-i-1])\ntemp = 0\nfor i in range(len(ans)):\n    temp += ans[i]\nfor i in range(len(heap)):\n    temp += heap[i][0]\ntemp += var**2\nnow = temp\nfor i in range(n-k):\n    if len(heap) != 0:\n        a = heapq.heappop(heap)\n        if cur[L[n-k-i-1][1]-1] == 0:\n            ans.append(L[n-k-i-1][0])\n            cur[L[n-k-i-1][1]-1] = 1\n            now -= var**2\n            now -= a[0]\n            var += 1\n            now += var**2\n            now += L[n-k-i-1][0]\n            temp = max(temp, now)\n        else:\n            heapq.heappush(heap, a)\nprint(temp)\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nN, K = map(int, input().split())\nTD = []\n\nfor _ in range(N):\n  TD.append(tuple(map(int, input().split())))\n\nTD.sort(key = lambda x:x[1], reverse=True)\nTD += [(TD[-1][0], 0)]\n\nD = defaultdict(list)\nT = [0]*N\nH = []\nans = 0\n\nfor i in range(K):\n  t, d = TD[i]\n  T[t-1] += 1\n  D[t].append(d)\n  ans += d\n\ncnt = sum(1 for c in T if c >= 1)\nans += cnt**2\n\nfor t in range(1, N+1):\n  if T[t-1] >= 2:\n    heappush(H, (D[t].pop(), t))\n    T[t-1] -= 1\n\n#print(ans, H, T, cnt)\nfor i in range(K, N):\n  if H:\n    t1, d1 = TD[i]\n    d2, t2 = heappop(H)\n    #print(t1, d1, t2, d2)\n    if T[t1-1] == 0 and d1 - d2 + 2*cnt + 1 >= 0:\n      ans += d1 - d2 + 2*cnt + 1\n      cnt += 1\n      T[t1-1] += 1\n      if T[t2-1] >= 2:\n        T[t2-1] -= 1\n      if T[t2-1] >= 2:\n        heappush(H, (D[t2].pop(), t2))\n    else:\n      heappush(H, (d2, t2))\n    #print(ans, H, T, cnt)\n\n#\u5143\u306e\u3084\u3064\u3068\u306e\u7d44\u307f\u5408\u308f\u305b...\uff1f\nans2 = 0\nT2 = [0]*N\nD2 = []\ncnt2 = 0\n \nfor t, d in TD:\n  if cnt2 < K:\n    if T2[t-1]:\n      D2.append(d)\n    else:\n      T2[t-1] = 1\n      ans2 += d\n      cnt2 += 1\n\nans2 += sum(D2[:K-cnt2]) + sum(T2)**2\n\nprint(max(ans, ans2))", "from heapq import heappop,heappush\nn,k=map(int,input().split())\ns=[]\nh=set()#\u7a2e\u985e\nl=[0]*n #\u500b\u6570\u306b\u3064\u3044\u3066\nfor _ in range(n):\n    t,d=map(int,input().split())\n    s.append((d,t-1))\ns=sorted(s,reverse=True)\na=[]#heapq\nnum=0#\u7f8e\u5473\u3057\u3055\u306e\u308f\nfor i in range(k):\n    d,t=s[i]\n    l[t]+=1\n    h.add(t)\n    num+=d\n    if l[t]>1:\n        heappush(a,(d,t))#\uff12\u7a2e\u985e\u4ee5\u4e0a\u306a\u3089heapq\u306b\u305f\u3059\nans=len(h)**2+num\nfor j in range(k,n):\n    d,t=s[j]#\u6b21\u306b\u5c0f\u3055\u3044\u306e\u3092\u5f15\u3044\u3066\u304f\u308b\n    l[t]+=1\n    if  l[t]>=2:\n        continue #2\u4ee5\u4e0a\u306a\u3089\u3080\u3057\n    if len(a)==0:\n        break\n    d1,t1=heappop(a) #\u3044\u3089\u306a\u3044\u306e\u3092\u5f15\u304f\n    h.add(t)\n    num=num-d1+d\n    ans=max(ans,len(h)**2+num)\nprint(ans)", "def resolve():\n    N, K = list(map(int, input().split()))\n    TD = sorted([list(map(int, input().split())) for _ in range(N)], reverse=True, key=lambda x: x[1])\n    eat_types = set()\n    eat_dups = []\n    total = 0\n    for i in range(K):\n        typ, point = TD[i]\n        total += point\n        if typ in eat_types:\n            eat_dups.append(TD[i])\n        else:\n            eat_types.add(typ)\n    ans = total + len(eat_types)**2\n\n    didx = len(eat_dups)-1\n    for i in range(K, N):\n        typ, point = TD[i]\n        if typ in eat_types:\n            continue\n        if didx < 0:\n            break\n        total -= eat_dups[didx][1]\n        total += point\n        didx -= 1\n        eat_types.add(typ)\n        ans = max(ans, total+len(eat_types)**2)\n    print(ans)\n    \n    \n    \n    \n\nif '__main__' == __name__:\n    resolve()", "#!/usr/bin/env python3\n\nfrom collections import deque\nn, k = list(map(int, input().split()))\n\ntd = [list(map(int, input().split())) for i in range(n)]\n\ntd = sorted(td, key=lambda x: x[1], reverse=True)\n\nset_ = set()\nval = 0\nduplicated = deque([])\n\nfor t_tmp, d_tmp in td[:k]:\n    val += d_tmp\n    if t_tmp in set_:\n        duplicated.append(d_tmp)\n    else:\n        set_.add(t_tmp)\n\nnow = val + len(set_)**2\n\n\nnx = deque(td[k:])\nans = now\nc = len(set_)\nwhile len(set_) < k and nx:\n    i, j = nx.popleft()\n    if i in set_:\n        continue\n    d = duplicated.pop()\n    diff = j-d + 2 * c + 1\n    set_.add(i)\n    ans = max(ans, now + diff)\n    now += diff\n    c += 1\nprint(ans)\n", "n,k= map(int,input().split())\ntd=[]\nfor _ in range(n):\n    td.append(list(map(int,input().split())))\ntd.sort(key=lambda x:x[1],reverse=True)\nNEW=[1]*(n+1)\nx=0\ny=0\nTOP=[]\nSUB=[]\nA=[]\nfor tdi in td[:k]:\n    if NEW[tdi[0]]==1:\n        NEW[tdi[0]]=0\n        TOP.append(tdi[1])\n        y+=1\n    else:\n        A.append(tdi[1])\n    x+=tdi[1]\n    \nfor tdi in td[k:]:\n    if NEW[tdi[0]]==1:\n        SUB.append(tdi[1])\n        NEW[tdi[0]]=0\nans=x+y**2\nfor i in range(min(k-1,len(A),len(SUB))):\n    x -= A.pop()\n    x += SUB[i]\n    y += 1\n    ans = max(ans,x+y**2)\nprint(ans)", "n, k = map(int, input().split())\ntds = []\nfor i in range(n):\n    t, d = map(int, input().split())\n    tds.append((d,t))\ntds.sort(reverse=True)\ncnt = k\nhand = []\nhand_throw = []\nhs = {}\nsubs = []\nrs = {}\nv_t = {}\nres = 0\nfor i in range(n):\n    if cnt > 0:\n        if tds[i][1] in hs:\n            hs[tds[i][1]] += 1\n            hand_throw.append(tds[i][0])\n        else:\n            hs[tds[i][1]] = 1\n            hand.append(tds[i][0])\n        cnt -= 1\n        res += tds[i][0]\n    else:\n        if not tds[i][1] in rs and not tds[i][1] in hs:\n            rs[tds[i][1]] = 1\n            subs.append(tds[i][0])\n    if not tds[i][1] in v_t:\n        v_t[tds[i][1]] = 1\nsubs.sort()\nv_hs = len(hs)\nv_t = len(v_t)\nres += pow(v_hs,2)\nfinal_res = res\nwhile v_hs+1 <= k and v_hs+1 <= v_t:\n    res += subs.pop() - hand_throw.pop() - pow(v_hs,2) + pow(v_hs+1,2)\n    final_res = max(final_res,res)\n    v_hs += 1\nprint(final_res)", "import heapq\nn,k=map(int,input().split())\ntd=[[0]*2 for _ in range(n)]\nfor i in range(n):\n    t,d=map(int,input().split())\n    td[i][0],td[i][1]=d,t\ntd.sort(reverse=True)\ndi=set()\nsa=[]\nheapq.heapify(sa)\nans=0\nfor d,t in td[:k]:\n    if t in di:\n        heapq.heappush(sa, d)\n    else:\n        di.add(t)\n    ans+=d\n\ns=[-10**18]*(k+1)\ncnt=len(di)\ns[cnt]=ans\nfor d,t in td[k:]:\n    if t in di:\n        continue\n    else:\n        if sa:\n            x=heapq.heappop(sa)\n            ans+=d-x\n            di.add(t)\n            cnt+=1\n            s[cnt]=ans\n\nfor i in range(k+1):\n    s[i]+=i*i\n\nprint(max(s))", "N, K = list(map(int, input().split()))\nS = [tuple(map(int, input().split())) for _ in range(N)]\n\nS.sort(key=lambda x: -x[1])\nst = set()\nfirst_acc, other_acc = [0], [0]\nfor t, d in S:\n    if t in st:\n        other_acc.append(other_acc[-1] + d)\n    else:\n        st.add(t)\n        first_acc.append(first_acc[-1] + d)\n\nans = 0\nfor i in range(K + 1):\n    if len(first_acc) <= i or len(other_acc) <= K - i:\n        continue\n    ans = max(ans, first_acc[i] + other_acc[K - i] + i * i)\nprint(ans)\n", "from operator import itemgetter\nn,k=map(int,input().split())\ntd=[list(map(int,input().split())) for _ in range(n)]\ntd.sort(key=itemgetter(1),reverse=True)\nans=0\nkind=0\nflg=[False]*n\nsing,comp=[],[]\nfor i in range(n):\n    t,d=td[i]\n    t-=1\n    if i<k:\n        ans+=d\n        if flg[t]:\n            comp.append(d)\n        else:\n            flg[t]=True\n            kind+=1\n    else:\n        if not flg[t]:\n            sing.append(d)\n            flg[t]=True\ncomp=comp[::-1]\ncnt=ans\nans+=kind**2\n#print(comp)\n#print(sing)\nif len(comp)>len(sing):\n    for i in range(len(sing)):\n        dc,ds=comp[i],sing[i]\n        cnt+=ds-dc\n        kind+=1\n        ans=max(ans,cnt+kind**2)\nelse:\n    for i in range(len(comp)):\n        dc,ds=comp[i],sing[i]\n        cnt+=ds-dc\n        kind+=1\n        ans=max(ans,cnt+kind**2)\nprint(ans)", "from collections import Counter\nfrom heapq import heappush, heappop\n\nn, k = list(map(int, input().split()))\ns = []\nfor _ in range(n):\n    t, d = list(map(int, input().split()))\n    s.append((d, t))\ns.sort()\nbp = 0\nx = 0\nc = Counter()\ncand = []\nfor _ in range(k):\n    d, t = s.pop()\n    bp += d\n    if c[t] == 0:\n        x += 1\n    c[t] += 1\n    heappush(cand, (d, t))\nans = bp + x * x\nwhile s:\n    d, t = s.pop()\n    if c[t] == 0:\n        while cand:\n            dd, td = heappop(cand)\n            if c[td] == 1:\n                continue\n            else:\n                c[td] -= 1\n                bp -= dd\n                break\n        else:\n            break\n        bp += d\n        x += 1\n        c[t] = 1\n        ans = max(ans, bp + x * x)\nprint(ans)\n", "import collections\nN,K = list(map(int,input().split()))\ndic = {}\nA = []\nfor _ in range(N):\n    t,d = list(map(int,input().split()))\n    A.append([t,d])\nA.sort(key = lambda x:x[1], reverse = True)\nval = 0\nset_ = set()\nduplicated = collections.deque([])\nfor t,d in A[:K]:\n    val += d\n    if t in set_:\n        duplicated.append(d)\n    else:\n        set_.add(t)\nnow = val + len(set_)**2\n\nnx = collections.deque(A[K:])\nans = now\nc = len(set_)\nwhile len(set_) < K and nx:\n    i,j = nx.popleft()\n    if i in set_:\n        continue\n    d = duplicated.pop()\n    diff = j-d + 2*c+1\n    set_.add(i)\n    now += diff\n    ans =max(ans,now)\n    c += 1\nprint(ans)\n", "N,K = map(int,input().split())\nTD = [tuple(map(int,input().split())) for i in range(N)]\nTD.sort(key=lambda x:x[1])\n\nimport heapq\nhq = []\nheapq.heapify(hq)\nselected = set()\nans = 0\nfor _ in range(K):\n    t,d = TD.pop()\n    if t in selected:\n        heapq.heappush(hq, d)\n    else:\n        selected.add(t)\n    ans += d\nans += len(selected)**2\n\ntmp = ans\nwhile TD:\n    t,d = TD.pop()\n    if t in selected: continue\n    selected.add(t)\n    if len(hq)==0: break\n    tmp -= heapq.heappop(hq)\n    tmp += d\n    tmp += len(selected)*2 - 1\n    ans = max(ans ,tmp)\nprint(ans)", "# \u89e3\u8aac\u3068\u4e0b\u8a18\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# https://atcoder.jp/contests/abc116/submissions/16781289\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, K, td):\n    max_t = [0] * (N + 1)\n    for i in range(N):\n        if max_t[td[i][0]] < td[i][1]:\n            max_t[td[i][0]], td[i][1] = td[i][1], max_t[td[i][0]]\n    d = [tdi[1] for tdi in td]\n    max_t.sort(reverse=True)\n    d.sort(reverse=True)\n    c_sum_max_t = [0]\n    for i in range(N + 1):\n        c_sum_max_t.append(c_sum_max_t[-1] + max_t[i])\n    c_sum_d = [0]\n    for i in range(N):\n        c_sum_d.append(c_sum_d[-1] + d[i])\n    ans = 0\n    kind = len([i for i in max_t if i > 0])\n    for i in range(1, min(kind + 1, K + 1)):\n        # print(c_sum_max_t[i], c_sum_d[K - i], i ** 2, c_sum_max_t[i] + c_sum_d[K - i] + i ** 2)\n        ans = max(c_sum_max_t[i] + c_sum_d[K - i] + i ** 2, ans)\n    print(ans)\n    # return ans\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    td = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, K, td)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # import tmp\n    # import copy\n    #\n    # while True:\n    #     N, K = 10, randint(1, 10)\n    #     td = [[randint(1, N), randint(2, 10 ** 2)] for _ in range(N)]\n    #     my = solve(N, K, copy.deepcopy(td))\n    #     ot = tmp.resolve(N, K, td)\n    #     if my != ot:\n    #         print(N, K)\n    #         for tdi in td:\n    #             print(tdi[0], tdi[1])\n    #         print()\n    #         print(my, ot)\n    #         break\n\n__starting_point()", "import heapq\nn,k = list(map(int,input().split()))\nL = []\nfor i in range(n):\n    t,d = list(map(int,input().split()))\n    L.append([d,t])\nL.sort()\nans = []\ncur = [0]*n\nheap = []\nvar = 0\nfor i in range(k):\n    if cur[L[n-i-1][1]-1] == 0:\n        ans.append(L[n-i-1][0])\n        cur[L[n-i-1][1]-1] = 1\n        var += 1\n    else:\n        heapq.heappush(heap, L[n-i-1])\ntemp = 0\nfor i in range(len(ans)):\n    temp += ans[i]\nfor i in range(len(heap)):\n    temp += heap[i][0]\ntemp += var**2\nnow = temp\nfor i in range(n-k):\n    if len(heap) != 0:\n        a = heapq.heappop(heap)\n        if cur[L[n-k-i-1][1]-1] == 0:\n            cur[L[n-k-i-1][1]-1] = 1\n            now -= var**2\n            now -= a[0]\n            var += 1\n            now += var**2\n            now += L[n-k-i-1][0]\n            temp = max(temp, now)\n        else:\n            heapq.heappush(heap, a)\nprint(temp)\n", "import sys\nfrom operator import itemgetter\nfrom heapq import *\ninput = sys.stdin.readline\n\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    sushi = [list(map(int, input().split())) for _ in range(n)]\n    \n    sushi.sort(key=itemgetter(1), reverse=True)\n    \n    key = []\n    already = [False]*(n+1)\n    variety = k\n    taste = 0\n    for i in range(k):\n        v, t = sushi[i]\n        taste += t\n        if already[v]:\n            variety -= 1\n            heappush(key, t)\n            continue\n        already[v]= True\n    \n    ans = [variety**2+taste]\n    for i in range(k, n):\n        if variety == k:\n            break\n        v, t = sushi[i]\n        if already[v]:\n            continue\n        already[v] = True\n        taste += t-key[0]\n        heappop(key)\n        variety += 1\n        ans.append(variety**2+taste)\n        \n    print((max(ans)))\n    \n    \n        \n   \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "n,k=list(map(int,input().split()))\ntd=[]\nfor _ in range(n):\n  td.append(list(map(int,input().split())))\ntd.sort(key=lambda x:x[1],reverse=True)\ntd_core=[]\ntd_sel=[]\ntd_sub=[]\ncat=[0]*(n+1)\nfor i in range(n):\n  if i < k and cat[td[i][0]]==0:\n    td_core.append(td[i])\n    cat[td[i][0]]=1\n  elif i < k:\n    td_sel.append(td[i])\n  elif cat[td[i][0]]==0:\n    td_sub.append(td[i])\n    cat[td[i][0]]=1\n# i >= k and cat[td[i][0]]==1 \u3068\u306a\u308b\u3082\u306e\u306f\u3059\u3067\u306btd_core,td_sel,td_sub\u5185\u3082\u306e\u3068\u7a2e\u985e\u3082\u88ab\u3063\u3066\u3044\u308b\u4e0a\u306b\u7f8e\u5473\u3057\u3055\u3082\u4f4e\u3044\n# \u5f8c\u306e\u5de5\u7a0b\u306f\u7a2e\u985e\u3092\u5897\u3084\u3059\u51e6\u7406\u306a\u306e\u3067\u3001\u540c\u3058\u7a2e\u985e\u306e\u30cd\u30bf\u306f\u305d\u306e\u30cd\u30bf\u306e\u4e2d\u3067\u7f8e\u5473\u3057\u3055\u304c\u6700\u5927\u306e\u3082\u306e\u4e00\u3064\u3067\u5341\u5206\u3002\u306a\u306e\u3067\u6368\u3066\u308b\n\n# d\u306e\u5927\u304d\u3044\u9806\u306b\u8caa\u6b32\u306b\u30cd\u30bf\u3092\u53d6\u5f97\u3057\u305f\u3068\u304d\u306e\u6e80\u8db3\u30dd\u30a4\u30f3\u30c8\nkiso=sum([x[1] for x in td_core])+sum([x[1] for x in td_sel])\nbns=len(td_core)\nans=kiso+bns**2\n# \u3053\u306e\u72b6\u614b\u304b\u3089\u30cd\u30bf\u306e\u7a2e\u985e\u3092\u5897\u3084\u3057\u3066\u3044\u304d\u6700\u5927\u304c\u51fa\u3066\u304f\u308b\u304b\u691c\u8a3c\n# td_sel\u5185\u306e\u30cd\u30bf\u306f\u540c\u4e00\u30cd\u30bf\u304c\u8907\u6570\u3042\u308a\u3001\u305d\u306e\u30cd\u30bf\u5185\u3067\u6700\u5927\u3058\u3083\u306a\u3044\u3082\u306e\u304c\u7f8e\u5473\u3057\u3055\u306e\u5927\u304d\u3044\u9806\u306b\u5165\u3063\u3066\u3044\u308b\u3002\n# td_sub\u306b\u306ftd_core,td_sel\u306b\u306a\u3044\u30cd\u30bf\u306e\u6700\u5927\u7f8e\u5473\u3057\u3055\u306e\u5bff\u53f8\u304c\u5165\u3063\u3066\u3044\u308b\u3002\ntd_sel.sort(key=lambda x:x[1])\nfor i in range(min(len(td_sel),len(td_sub))):\n  kiso-=td_sel[i][1]\n  kiso+=td_sub[i][1]\n  bns+=1\n  ans=max(ans,kiso+bns**2)\nprint(ans)\n", "def main():\n    from collections import deque\n    n, k, *td = list(map(int, open(0).read().split()))\n    s = list(zip(*[iter(td)] * 2))\n    t = sorted(s, key=lambda x: x[1], reverse=True)\n\n    variety = set()\n    base = 0\n    duplicated = deque([])\n\n    for x, y in t[:k]:\n        base += y\n        if x in variety:\n            duplicated.append(y)\n        else:\n            variety.add(x)\n\n    now = base + len(variety) ** 2\n\n    nx = deque(t[k:])\n    c = len(variety)\n    tmp = now\n    while c < k and nx:\n        i, j = nx.popleft()\n        if i in variety:\n            continue\n\n        d = duplicated.pop()\n        dif = j - d + 2 * c + 1\n        variety.add(i)\n        tmp = max(tmp, now + dif)\n        now += dif\n        c += 1\n\n    print(tmp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nimport heapq\nN,K=map(int,input().split())\n\nhq=[]\ntset_all=set()\nfor i in range(N):\n  t,d=map(int,input().split())\n  heapq.heappush(hq,(-d,t))\n  tset_all.add(t)\n#print(heapq)\n\nhq_K=[]\ndsum=0\ntdic=defaultdict(int)\nfor i in range(K):\n  md,t=heapq.heappop(hq)\n  heapq.heappush(hq_K,((-md,t)))\n  dsum-=md\n  tdic[t]+=1  \n\nt0=len(tdic)\nmax_answer=dsum+(t0**2)\n#print(t0,max_answer)\n\nfor i in range(t0+1,min(K,len(tset_all))+1):\n  loop_flg=True\n  while(loop_flg):\n    d,t=heapq.heappop(hq_K)\n    if tdic[t]>1:\n      tdic[t]-=1\n      dsum-=d\n      \n      while(True):\n        md2,t2=heapq.heappop(hq)\n        if tdic[t2]==0:\n          tdic[t2]=1\n          dsum-=md2\n          loop_flg=False\n          break\n          \n  answer_i=dsum+(i**2)\n  #print(i,answer_i)\n  max_answer=max(max_answer,answer_i)\n  \nprint(max_answer)", "from heapq import heapify, heappush, heappop\n\nN, K = map(int, input().split())\nS = [list(map(int, input().split())) for _ in range(N)]\nS.sort(key=lambda x: (-x[1]))\ntypes = set()\nRS = []\nAS = []\nd_sum = 0\nfor i in range(K):\n  _type, value = S[i][0], S[i][1]\n  if _type in types:\n    heappush(RS, (value, _type))\n  else:\n    types.add(_type)\n  d_sum += value\nt_sum = len(types)\nd_sum += pow(t_sum, 2)\nfor i in range(K, N):\n  _type, value = S[i][0], S[i][1]\n  if not _type in types:\n    heappush(AS, (-value, _type))\n    types.add(_type)\nans = d_sum\nwhile len(AS) > 0 and len(RS) > 0:\n  av, at = heappop(AS)\n  rv, rt = heappop(RS)\n  t_sum += 1\n  d_sum += -av-rv+pow(t_sum, 2)-pow(t_sum-1, 2)\n  ans = max(ans, d_sum)\nprint(ans)", "N,K,*L = map(int, open(0).read().split())\nls = []\nfor i,(t,d) in enumerate(zip(*[iter(L)]*2)):\n  ls.append((d,t))\nls.sort()\nS = set()\npre = []\nans = 0\nnum = 0\nfor i in range(K):\n  d,t = ls.pop()\n  ans += d\n  if t not in S:\n    num += 1\n    S.add(t)\n  else:\n    pre.append(d)\npre.sort(reverse=True)\nans += num*num\nif pre==[]:\n  print(ans)\n  return\nm = ans\nfor i in range(N-K):\n  d,t = ls.pop()\n  if t in S:\n    continue\n  S.add(t)\n  m -=pre.pop()\n  m += d+2*num+1\n  num += 1\n  ans = max(ans,m)\n  if pre==[]:\n    break\nprint(ans)", "n,k=map(int,input().split())\nfrom operator import itemgetter as it\nl=sorted([list(map(int,input().split()))for i in range(n)],reverse=1,key=it(1))\nfrom collections import defaultdict\nc=defaultdict(int)\nfrom heapq import heapify, heappop, heappush\nnow=[]\nS=0\nkind=0\nfor i in range(k):\n    a,s=l[i]\n    S+=s\n    c[a]+=1\n    if c[a]>1:heappush(now,(s,a))\n    kind+=c[a]==1\nans=S+kind**2\nfor i in range(k,n):\n    if not now:break\n    x,y=l[i]\n    if c[x]:continue\n    s,a=heappop(now)\n    c[x]+=1\n    kind+=1\n    S+=y-s\n    ans=max(ans,S+kind**2)\nprint(ans)", "def main():\n    N, K = list(map(int, input().split()))\n    TD = [tuple(map(int, input().split())) for _ in range(N)]\n    TD.sort(key=lambda x: x[1], reverse=True)\n    s = set()\n    rep = []\n    for t, d in TD[:K]:\n        if t in s:\n            rep.append(d)\n        else:\n            s.add(t)\n    m = sum(d for _, d in TD[:K])\n    p = len(s) ** 2 + m\n    for t, d in TD[K:]:\n        if not rep:\n            break\n        if t in s:\n            continue\n        m += d - rep.pop()\n        s.add(t)\n        p = max(p, len(s) ** 2 + m)\n    return p\n\nprint((main()))\n", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nimport heapq\nn, k = map(int, input().split())\nTD = sorted([list(map(int, input().split())) for _ in range(n)], reverse=True, key=itemgetter(1))\nL = [[] for _ in range(n+1)]\nP = []\na = 0\ncnt = 0\nF = [-float(\"inf\")]*(n+1)\nfor t, d in TD[:k]:\n  L[t].append(d)\n  if len(L[t]) == 1:\n    a += 1\n  cnt += d\nF[a] = cnt\nfor i in range(1, n+1):\n  while len(L[i]) > 1:\n    heapq.heappush(P, L[i].pop())\nnow = k\nfor i in range(a, n):\n  if len(P) == 0:\n    break\n  while now < n and L[TD[now][0]]:\n    now += 1\n  if now == n:\n    break\n  t, d = TD[now]\n  L[t].append(d)\n  F[i+1] = F[i] - heapq.heappop(P) + d\nans = 0\nfor i in range(a, n+1):\n  ans = max(ans, F[i] + i*i)\nprint(ans)", "import heapq\n\nfrom typing import List\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    v = []\n    for _ in range(n):\n        t, d = list(map(int, input().split()))\n        v.append((t, d))\n\n    print((vs(v, k)))\n\n\ndef vs(v: List[List[int]], k: int) -> int:\n    v.sort(key=lambda x: x[1], reverse=True)\n\n    # Dup type\n    h0 = []\n    # New type\n    h1 = []\n    # types\n    s = set()\n    types = 0\n    op = 0\n\n    for i in range(k):\n        t, d = v[i]\n        op += d\n\n        if t in s:\n            heapq.heappush(h0, d)\n            continue\n\n        types += 1\n        s.add(t)\n\n    for i in range(k, len(v)):\n        t, d = v[i]\n\n        if not t in s:\n            s.add(t)\n            heapq.heappush(h1, -d)\n\n    result = op + types ** 2\n\n    while len(h0) > 0 and len(h1) > 0:\n        d0 = heapq.heappop(h0)\n        d1 = -heapq.heappop(h1)\n        op = op - d0 + d1\n        types += 1\n        tmp = op + types ** 2\n\n        if tmp > result:\n            result = tmp\n\n    return result\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# x * x\u3092\u3069\u3046\u8a55\u4fa1\u3059\u308b\u304b\u3001heap\u306b\u300c\u304a\u3044\u3057\u3055\u300d\u306e\u9ad8\u3044\u9806\u306b\u5165\u308c\u3066\u3044\u304f\nN, K = lr()\nTD = [lr() for _ in range(N)]\nheap = []\nkind = 0\nhappy = 0\nused = set()\nTD.sort(key=lambda x: x[1], reverse=True)\nfor t, d in TD[:K]:\n    if t not in used:\n        used.add(t)\n        kind += 1\n    else:\n        heappush(heap, d)\n    happy += d\n\ncand = [happy+kind**2]\nfor t, d in TD[K:]:\n    if not heap:\n        break\n    if t in used:\n        continue\n    h = heappop(heap)\n    happy += (d-h)\n    kind += 1\n    used.add(t)\n    cand.append(happy+kind**2)\n\nanswer = max(cand)\nprint(answer)\n", "import heapq\n\nN, K = list(map(int, input().split()))\nsushi = sorted([list(map(int, input().split())) for _ in range(N)], key=lambda x: x[1], reverse=True)\n\neaten = [False]*N\n\n#d1: \u7a2e\u985e\u304c\u5897\u3048\u306a\u3044\u3082\u306e\u540c\u58eb\u3001d2: \u540c\u3058\u7a2e\u985e\u306e\u4e2d\u3067\u6700\u5927\u306e\u7d44\u307f\u5408\u308f\u305b\nd1, d2 = [0], [0]\n\nfor i in range(N):\n    t, d = sushi[i]\n    t -= 1\n    if eaten[t]:\n        d1.append(d1[-1]+d)\n    else:\n        eaten[t] = True\n        d2.append(d2[-1]+d)\n\n\nans = 0\nfor i in range(1, K+1):\n    if K-i >= len(d1):\n        continue\n    if i >= len(d2):\n        continue\n    ans = max(ans, d1[K-i]+d2[i]+i**2)\nprint(ans)\n", "import heapq\nN,K = list(map(int,input().split()))\n\nL = [[] for _ in range(N)]\nAll = []\ns = set([])\nfor i in range(N):\n  t,d = list(map(int,input().split()))\n  t-=1 #0\u30b9\u30bf\u30fc\u30c8\u306b\n  heapq.heappush(L[t], -d) #\u6700\u5927\u304b\u3089\u53d6\u308a\u51fa\u3057\u305f\u3044\u306e\u3067\u8ca0\u306b\u3059\u308b\u3002\n  heapq.heappush(All,[-d,t]) #\u3059\u3079\u3066\u304b\u3089\u5927\u304d\u3044\u9806\u306b\u53d6\u308a\u51fa\u305b\u308b\u3088\u3046\u306b \n  s.add(t)\n\n#print(L,s)\npoint = 0\nns = 0 #\u73fe\u5728\u306e\u7a2e\u985e\nlater = []\nnow = []\nsyurui = set([])\nwhile len(now) < K and All:\n  temp = heapq.heappop(All)\n  if temp[1] not in syurui:\n    ns += 1\n    point -= temp[0]\n    syurui.add(temp[1])\n    heapq.heappush(now, -1*temp[0])\n  else:\n    later.append(temp)\nfor i in later:\n  heapq.heappush(All,i)\n\npoint += ns*ns\nwhile len(now) < K:\n  temp = heapq.heappop(All)\n  point -= temp[0]\n  heapq.heappush(now, -1*temp[0])\n\n#print(ns,point)\n#print(now,All,All[0][0])\nwhile All and now[0] < -1*All[0][0]:\n  temp = heapq.heappop(All)\n  dele = heapq.heappop(now)\n  #print(temp,dele)\n  upoint = point - temp[0] - dele - ns*ns + (ns-1)**2\n  #print(upoint,point)\n  if upoint >= point:\n    point = upoint\n    ns -= 1\n  else:\n    break\n    \nprint(point)\n#print(All)\n#print(now)\n", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    S = []\n    for _ in range(N):\n        t, d = map(int, input().split())\n        S.append((d, t))\n    S.sort(reverse = True)\n    upperKCount = 0\n    appeared = set()\n    maxPoint = 0\n    for i in range(K):\n        maxPoint += S[i][0]\n        if S[i][1] not in appeared:\n            upperKCount += 1\n            appeared |= {S[i][1]}\n    maxPoint += upperKCount ** 2\n    appeared = set()\n\n    typeMax = []\n    typeNum = 0\n    typeLower = []\n    others = 0\n    for d, t in S:\n        if t in appeared: \n            typeLower.append(d)\n            others += 1\n        else:\n            typeMax.append(d)\n            typeNum += 1\n            appeared |= {t}\n    typeMaxSum = [0] * (typeNum + 1)\n    typeLowerSum = [0] * (others + 1)\n    for i in range(typeNum): typeMaxSum[i+1] = typeMaxSum[i] + typeMax[i]\n    for i in range(others): typeLowerSum[i+1] = typeLowerSum[i] + typeLower[i]\n    for k in range(upperKCount + 1, min(typeNum, K) + 1):\n        maxPoint = max(maxPoint, k ** 2 + typeMaxSum[k] + typeLowerSum[K - k])\n    print(maxPoint)\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nsys.setrecursionlimit(100000000)\n\ndef main():\n    N,K = map(int,input().split())\n    sushi = [tuple(map(int,input().split())) for _ in range(N)]\n\n    sushi.sort(key = lambda x:x[1],reverse = True)\n    ans = 0\n    dic = {}\n    change = []\n    for a,b in sushi[:K]:\n        if a in dic:\n            dic[a].append(b)\n            change.append((a,b))\n        else:\n            dic[a] = [b]\n        ans += b\n\n    various = len(dic)\n    ans += various ** 2\n    ret = ans\n    used_type = set(dic.keys())\n    suggestion = [p for p in sushi[K:] if p[0] not in used_type]\n    for a,b in suggestion:\n        if len(change) == 0:\n            break\n        if a in used_type:\n            continue\n        dic[change[-1][0]].pop()\n        ret -= change[-1][1]\n        ret += b + 2*various + 1\n        dic[a] = b\n        change.pop()\n        various += 1\n        used_type.add(a)\n        ans = max(ans,ret)\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappush,heappop\nn,k = map(int,input().split())\nkind_value = [[] for _ in range((n+1))]\nfor i in range(n):\n    t,d = map(int,input().split())\n    kind_value[t].append(d)\nfor li in kind_value:\n    li.sort()\nfirst_type = [(li[-1],i)for i,li in enumerate(kind_value) if li]\nfirst_type.sort(reverse = True)\nkind = 0\nvalue_type1 = 0\nsecond_type = []\nsecond_type_sum = 0\nsecond_type_cnt = 0\n\nanswer = 0\nfor v,i in first_type:\n    kind += 1\n    if kind > k:\n        break\n    value_type1 += v\n    for d in kind_value[i][:-1]:\n        heappush(second_type,d)\n        second_type_sum += d\n        second_type_cnt += 1\n    while second_type_cnt > k-kind:\n        d = heappop(second_type)\n        second_type_cnt -= 1\n        second_type_sum -= d\n    value = kind*kind + value_type1 + second_type_sum\n    if answer < value:\n        answer = value\n\nprint(answer)", "import sys\ninput=sys.stdin.readline\nfrom heapq import heappop,heappush\nhq=[]\nn,k=list(map(int,input().split()))\nfor i in range(n):\n\tt,d=list(map(int,input().split()))\n\theappush(hq,(-d,t))\nD=0\ndic={}\ngot=[]\nfor i in range(k):\n\tr=heappop(hq)\n\tgot.append(r)\n\tif r[1] in dic:\n\t\tdic[r[1]]+=1\n\telse:\n\t\tdic[r[1]]=1\n\tD+=-r[0]\nans=D+len(dic)**2\n\nwhile hq:\n\twhile got:\n\t\tp=got.pop()\n\t\tif dic[p[1]]>1:\n\t\t\tdic[p[1]]-=1\n\t\t\tD-=-p[0]\n\t\t\tbreak\n\tif len(got)==0:\n\t\tprint(ans)\n\t\treturn\n\n\tr=heappop(hq)\n\tgot.append(r)\n\tif r[1] in dic:\n\t\tdic[r[1]]+=1\n\telse:\n\t\tdic[r[1]]=1\n\tD+=-r[0]\t\n\tans=max(D+len(dic)**2,ans)\nprint(ans)\n", "import heapq\nN,K = list(map(int, input().split()))\n\nI = []\nfor _ in range(N):\n  t,d = list(map(int, input().split()))\n  I.append((d,t))\n  \nI.sort(reverse=True)\n\n# heap_can_delete\nh_d = []\n# heap_can_add\nh_a = []\n\nwk = 0\nkind = 0\n# \u51fa\u73fe\u3057\u305f\u3053\u3068\u306e\u3042\u308b\u30cd\u30bf\nap = set()\nfor i in range(K):\n  d,t = I[i]\n  wk += d\n  if t not in ap:\n    ap.add(t)\n    kind += 1\n  else:\n    heapq.heappush(h_d, (d,t))\n\nfor i in range(K,N):\n  d,t = I[i]\n  if t not in ap:\n    ap.add(t)\n    # max\u3092pop\u3055\u305b\u308b\u305f\u3081\u306b\u3001\u4fa1\u5024\u3092-1\u304b\u3051\u3066\u304a\u304f\n    heapq.heappush(h_a, ((-1) * d, t))\n  \nans = wk + kind ** 2\nwhile len(h_d) > 0 and len(h_a) > 0:\n  d1,t1 = heapq.heappop(h_d)\n  d2,t2 = heapq.heappop(h_a)\n  d2 = (-1) * d2\n  wk = wk - d1 + d2\n  kind += 1\n  ans = max(ans, wk + kind ** 2)\n  \nprint(ans)\n  \n", "import heapq\nfrom collections import Counter\ninf = 10**10\nn, k = map(int, input().split())\n\ndset = [[] for i in range(n)]\nfor i in range(n):\n    t, d = map(int, input().split())\n    dset[t-1].append(d)\n\nfor dd in dset:\n    if dd: dd.sort(reverse=True)\n    else: dd.append(-inf)\n\ndset.sort(key= lambda x: -x[0])\n\ncur = 0\nhq = []\n# k\u7a2e\u985e\u306e\u5148\u982d\u3092\u9664\u3044\u3066\u683c\u7d0d\nfor i in range(k):\n    cur+=dset[i][0]\n    for d in dset[i][1:]: heapq.heappush(hq, -d)\n\n# \u6b8b\u308a\u306e\u7a2e\u985e\u306e\u3059\u3079\u3066\u3092\u683c\u7d0d\nfor dd in dset[k:]:\n    for d in dd:\n        heapq.heappush(hq, -d)\n\nans = cur + k*k\nfor i in range(k-1, -1, -1):\n    v = dset[i][0] # \u524a\u9664\u5019\u88dc\n    if hq:\n        w = -heapq.heappop(hq)\n    else:\n        break\n    if v < w:\n        cur += w - v\n        # heapq.heappush(hq, -v)\n    else:\n        heapq.heappush(hq, -w)\n    ans = max(ans, cur + i*i)\nprint(ans)", "from heapq import heappush, heappop\n\n\nN, K, *td = list(map(int, open(0).read().split()))\nsushis = [(d, t) for t, d in zip(*[iter(td)] * 2)]\nsushis.sort(reverse=True)\n\npq = []\ncnt = [0] * (N + 1)\nbase, x = 0, 0\nfor d, t in sushis[:K]:\n    base += d\n    if cnt[t] > 0:\n        heappush(pq, (d, t))\n    elif cnt[t] == 0:\n        x += 1\n    cnt[t] += 1\nans = base + x * x\n\nfor d, t in sushis[K:]:\n    if not pq:\n        break\n    if cnt[t] > 0:\n        continue\n\n    _d, _t = heappop(pq)\n    cnt[_t] -= 1\n    cnt[t] += 1\n    x += 1\n    base += d - _d\n    ans = max(ans, base + x * x)\n\nprint(ans)\n", "from collections import defaultdict\nfrom heapq import heappush, heappop\nN,K,*L = map(int, open(0).read().split())\ndic = defaultdict(list)\nls = []\nfor i,(t,d) in enumerate(zip(*[iter(L)]*2)):\n  dic[t].append(d)\n  heappush(ls,(-d,t))\nS = set()\npre = []\nans = 0\nnum = 0\nfor i in range(K):\n  d,t = heappop(ls)\n  ans -= d\n  if t not in S:\n    num += 1\n    S.add(t)\n  else:\n    heappush(pre,-d)\n\nans += num*num\nif pre==[]:\n  print(ans)\n  return\nm = ans\nfor i in range(N-K):\n  d,t = heappop(ls)\n  if t in S:\n    continue\n  S.add(t)\n  m -= heappop(pre)\n  m += -d+2*num+1\n  num += 1\n  ans = max(ans,m)\n  if pre==[]:\n    break\nprint(ans)", "# \u7a2e\u985e\u304c\u540c\u3058\u5bff\u53f8\u3067\u3042\u308c\u3070\u3001\u6700\u3082\u7f8e\u5473\u3057\u3055\u304c\u9ad8\u3044\u5bff\u53f8\u3092\u9078\u3076\u3079\u304d\u3002\n# \u5f93\u3044\u3001\n# (1)\u5404\u7a2e\u985e\u306e\u6700\u3082\u7f8e\u5473\u3057\u3055\u304c\u9ad8\u3044\u5bff\u53f8\u30b0\u30eb\u30fc\u30d7\n# (2)\u305d\u308c\u4ee5\u5916\u306e\u5bff\u53f8\u30b0\u30eb\u30fc\u30d7\n# \u3092\u3044\u305a\u308c\u3082\u964d\u9806\u306b\u4e26\u3079\u3066\u3001(1)\u304b\u3089\u5e7e\u3064\u53d6\u308b\u304b(\u6700\u4f4e\u3067\u30821\u3064\u306f\u53d6\u308b)\u3092\u5168\u63a2\u7d22\u3059\u308b\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\n\nfrom collections import defaultdict\nsushi = defaultdict(list) # \u7a2e\u985e\u30fb\u304a\u3044\u3057\u3055\u3000\u306edictionary\n\nfor i in range(N):\n  t,d = map(int,readline().split())\n  sushi[t].append(d)\n  \nbest_sushi = []\nother_sushi = []\n\nfor value in sushi.values():\n  value = sorted(value, reverse = True)\n  best_sushi.append(value[0])\n  other_sushi += value[1:]\n\nbest_sushi = sorted(best_sushi, reverse = True)\nother_sushi = sorted(other_sushi, reverse = True)\n\nbest_num = 1 # best_sushi\u304b\u3089\u9078\u3076\u500b\u6570\nother_num = K - 1 # other_sushi\u304b\u3089\u9078\u3076\u500b\u6570\n\nif len(other_sushi) < other_num: # \u9078\u3079\u306a\u3044\u5834\u5408\n  other_num = len(other_sushi)\n  best_num = K - other_num\n  \n# \u305d\u308c\u305e\u308c\u306e\u5bff\u53f8\u304b\u3089\u9078\u3076\u500b\u6570\u306e\u958b\u59cb\u5024\u304c\u6c7a\u5b9a\n# other_sushi\u306e\u5f8c\u308d\u306e\u8981\u7d20\u306f\u5207\u308a\u96e2\u3057\u3066\u826f\u3044\n\nother_sushi = other_sushi[:other_num]\n  \nsushi_point = sum(best_sushi[:best_num]) + sum(other_sushi)\nkind_point = best_num ** 2\n\nans = sushi_point + kind_point\n\n# best\u5bff\u53f8\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u9032\u3081\u3066\u3044\u304f\nfor i in range(best_num, len(best_sushi)):\n  sushi_point += best_sushi[i]\n  if len(other_sushi) == 0:\n    break\n  rem = other_sushi.pop() # \u53d6\u308a\u9664\u304f\u5bff\u53f8\n  sushi_point -= rem\n  kind_point = (i + 1) ** 2\n  \n  if ans < sushi_point + kind_point:\n    ans = sushi_point + kind_point\n    \nprint(ans)", "def main():\n    from heapq import heappush, heappop\n    from operator import itemgetter\n    import sys\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    dd = []\n    for _ in range(N):\n        t, d = list(map(int, input().split()))\n        t -= 1\n        dd.append((d, t))\n    dd.sort(key=itemgetter(0), reverse=True)\n\n    ret = 0\n    biggest = [-1] * N\n    h = []\n    kinds = 0\n    for d, t in dd[:K]:\n        ret += d\n        if ~biggest[t]:\n            if biggest[t] > d:\n                heappush(h, d)\n            else:\n                heappush(h, biggest[t])\n                biggest[t] = d\n        else:\n            kinds += 1\n            ret += kinds * 2 - 1\n            biggest[t] = d\n\n    ans = ret\n    for d, t in dd[K:]:\n        if ~biggest[t]: continue\n        if not h: break\n        kinds += 1\n        diff = d + kinds * 2 - 1 - h[0]\n        ret += diff\n        if ans < ret: ans = ret\n        biggest[t] = d\n        heappop(h)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\nN, K = list(map(int, input().split()))\nTD = [tuple(map(int, input().split())) for _ in range(N)]\n\nTD.sort(reverse=True, key=lambda a: a[1])\n\nA = TD[:K]\n\nB = []\nV = set()\nfor t, d in TD:\n    if t in V:\n        continue\n    B.append((t, d))\n    V.add(t)\n\ncntT = Counter([t for t, _ in A])\nV = set(cntT.keys())\nS = sum([d for _, d in A])\nB = [(t, d) for t, d in B if not t in V]\n\nC = []\nfor t, d in A[::-1]:\n    if cntT[t] > 1:\n        C.append((t, d))\n        cntT[t] -= 1\n\nC = C[::-1]\nans = S + len(V)**2\nfor t, d in B:\n    if not C:\n        break\n    _, less = C.pop()\n    S -= less\n    S += d\n    V.add(t)\n    ans = max(ans, S + len(V)**2)\nprint(ans)\n", "N,K,*L=list(map(int,open(0).read().split()))\nS=sorted([(d,t)for t,d in zip(*[iter(L)]*2)],reverse=True)\nIn=set()\nC=X=0\nuni=[]\ndub=[]\nfor d,t in S:\n\tif t not in In:\n\t\tIn.add(t)\n\t\tuni.append(d)\n\t\tX+=1\n\t\tif X==K:\n\t\t\tbreak\n\telse:\n\t\tdub.append(d)\ndet=0\nC=X\nfor d in dub:\n\tif C<K:\n\t\tdet+=d\n\t\tC+=1\n\telif uni[-1]+2*X-1<=d:\n\t\tuni.pop()\n\t\tX-=1\n\t\tdet+=d\nprint((sum(uni)+det+X**2))\n\n", "# \u89e3\u8aac\u898b\u3066\u66f8\u304f\n\nN, K = [int(x) for x in input().split()]\ntd = [0] * (N)\nfor i in range(N):\n    td[i] = [int(x) for x in input().split()]\n\n# \u30cd\u30bf\u7a2e\u985e\u964d\u9806\u3067\u30bd\u30fc\u30c8\n# \u540c\u3058\u30cd\u30bf\u306e\u4e2d\u3067\u306f\u304a\u3044\u3057\u3044\u3082\u306e\u304b\u3089\u9806\u306b\u4e26\u3076\ntd = sorted(td, reverse = True)\n\nvar_p1 = [0] * N   # \u7a2e\u985e\u6570\u3092\u5897\u3084\u3059\u5bff\u53f8\u306e\u30ea\u30b9\u30c8\nvar_p0 = [0] * N   # \u7a2e\u985e\u6570\u3092\u5897\u3084\u3055\u306a\u3044\u5bff\u53f8\u306e\u30ea\u30b9\u30c8\n\nn_p1 = 0\nn_p0 = 0\nfor i in range(N):\n    if i == 0 or (i > 0 and td[i][0] != td[i - 1][0]):  # \u7a2e\u985e\u304c\u5909\u308f\u308b\n        var_p1[n_p1] = td[i][1]  # \u304a\u3044\u3057\u3055\u3092\u8ffd\u52a0\n        n_p1 += 1\n    else:\n        var_p0[n_p0] = td[i][1]  # \u304a\u3044\u3057\u3055\u3092\u8ffd\u52a0\n        n_p0 += 1\n\nvar_p1.sort(reverse = True)\nvar_p0.sort(reverse = True)\n\nval_taste = sum(var_p0[0 : K])\nval_vars = 0\nans = 0\n\nfor j in range(1, K + 1):  # \u7a2e\u985e\u65701\u301cK\u3092\u8a66\u3059\n    val = var_p1[j - 1]\n    if val <= 0: break  # \u3053\u308c\u4ee5\u4e0a\u7a2e\u985e\u3092\u5897\u3084\u305b\u306a\u3044\n    # var_p1\u304b\u3089n_p1\u500b\u9078\u3073\u3001var_p0\u304b\u3089K - n_p1\u500b\u9078\u3076\n    val_taste = val_taste + val - var_p0[K - j]\n    val_vars = j * j\n    ans = max(ans, val_taste + val_vars)\n\nprint(ans)", "n,k = list(map(int,input().split()))\ns = set()\nl = []\nln = [[] for i in range(n)]\nfor i in range(n):\n    t,m = list(map(int,input().split()))\n    l.append([m,t-1])\n    ln[t-1].append(m)\nl.sort(reverse = True)\ncand = []\n\nans = 0\nmod = []\nfor i in range(k):\n    ans += l[i][0]\n    if l[i][1] in s:\n        mod.append(l[i][0])\n    else:\n        s.add(l[i][1])\nx = len(s)\nnow = ans + x**2\n\nfor i in range(n):\n    \n    if i in s or ln[i] == []:\n        continue\n    cand.append(max(ln[i]))\n\ncand.sort(reverse = True)\n\nfor i in range(min(len(mod),len(cand))):\n    ans += cand[i]-mod[-1-i]\n    x += 1\n    now = max(now,ans+x**2)\nprint(now)\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nN, K = list(map(int, input().split()))\nnums = [[] for i in range(N)]\nfor i in range(N):\n    t, d = list(map(int, input().split()))\n    t -= 1\n    nums[t].append(d)\nmaxs = []\nrest = []\nfor i in range(N):\n    if len(nums[i]) == 0: continue\n    nums[i].sort(reverse=True)\n    maxs.append(nums[i][0])\n    for n in nums[i][1:]:\n        rest.append(n)\nmaxs.sort(reverse=True)\nrest.sort(reverse=True)\nif len(maxs) > K:\n    maxs = maxs[:K]\nother = []\nidx = 0\nwhile len(maxs)+len(other) < K:\n    other.append(rest[idx])\n    idx += 1\nrest = rest[idx:]\n\ntypes = len(maxs)\nfor i,r in enumerate(rest):\n    diff = types*types - pow(types-1, 2)\n    if diff < r-maxs[len(maxs)-1-i]:\n        maxs[len(maxs)-1-i] = r\n        types -= 1\n    else:\n        break\nans = types*types\nfor num in maxs:\n    ans += num\nfor num in other:\n    ans += num\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nimport heapq\nn, k = map(int, input().split())\nTD = sorted([list(map(int, input().split())) for _ in range(n)], reverse=True, key=itemgetter(1))\nL = [[] for _ in range(n+1)]\nP = []\na = 0\ncnt = 0\nF = [-float(\"inf\")]*(n+1)\nB = 0\nfor t, d in TD[:k]:\n  if B>>t & 1:\n    heapq.heappush(P, d)\n  else:\n    B |= 1 << t\n    a += 1\n  cnt += d\nF[a] = cnt\nfor i in range(a, n):\n  if len(P) == 0:\n    break\n  while k < n and B>>TD[k][0] & 1:\n    k += 1\n  if k == n:\n    break\n  t, d = TD[k]\n  B |= 1 << t\n  F[i+1] = F[i] - heapq.heappop(P) + d\nans = 0\nfor i in range(a, n+1):\n  ans = max(ans, F[i] + i*i)\nprint(ans)", "# \u7a2e\u985e\u304c\u540c\u3058\u5bff\u53f8\u3067\u3042\u308c\u3070\u3001\u6700\u3082\u7f8e\u5473\u3057\u3055\u304c\u9ad8\u3044\u5bff\u53f8\u3092\u9078\u3076\u3079\u304d\u3002\n# \u5f93\u3044\u3001\n# (1)\u5404\u7a2e\u985e\u306e\u6700\u3082\u7f8e\u5473\u3057\u3055\u304c\u9ad8\u3044\u5bff\u53f8\u30b0\u30eb\u30fc\u30d7\n# (2)\u305d\u308c\u4ee5\u5916\u306e\u5bff\u53f8\u30b0\u30eb\u30fc\u30d7\n# \u3092\u3044\u305a\u308c\u3082\u964d\u9806\u306b\u4e26\u3079\u3066\u3001(1)\u304b\u3089\u5e7e\u3064\u53d6\u308b\u304b(\u6700\u4f4e\u3067\u30821\u3064\u306f\u53d6\u308b)\u3092\u5168\u63a2\u7d22\u3059\u308b\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\n\nfrom collections import defaultdict\nsushi = defaultdict(list) # \u7a2e\u985e\u30fb\u304a\u3044\u3057\u3055\u3000\u306edictionary\n\nfor i in range(N):\n  t,d = map(int,readline().split())\n  sushi[t].append(d)\n  \nbest_sushi = []\nother_sushi = []\n\nfor value in sushi.values():\n  value = sorted(value, reverse = True)\n  best_sushi.append(value[0])\n  other_sushi += value[1:]\n\nbest_sushi = sorted(best_sushi, reverse = True)\nother_sushi = sorted(other_sushi, reverse = True)\n\n#print(\"best_sushi\",best_sushi)\n#print(\"other_sushi\",other_sushi)\n\nbest_num = 1 # best_sushi\u304b\u3089\u9078\u3076\u500b\u6570\nother_num = K - 1 # other_sushi\u304b\u3089\u9078\u3076\u500b\u6570\n\nif len(other_sushi) < other_num: # \u9078\u3079\u306a\u3044\u5834\u5408\n  other_num = len(other_sushi)\n  best_num = K - other_num\n  \n# \u305d\u308c\u305e\u308c\u306e\u5bff\u53f8\u304b\u3089\u9078\u3076\u500b\u6570\u306e\u958b\u59cb\u5024\u304c\u6c7a\u5b9a\n# other_sushi\u306e\u5f8c\u308d\u306e\u8981\u7d20\u306f\u5207\u308a\u96e2\u3057\u3066\u826f\u3044\n\nother_sushi = other_sushi[:other_num]\n  \nsushi_point = sum(best_sushi[:best_num]) + sum(other_sushi)\nkind_point = best_num ** 2\n\nans = sushi_point + kind_point\n#print(\"\u521d\u671f\u5024\",ans,\"sum(best_sushi[:best_num])\",sum(best_sushi[:best_num]),\"sum(other_sushi)\",sum(other_sushi),\"best_num ** 2\",best_num ** 2)\n\n# best\u5bff\u53f8\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u9032\u3081\u3066\u3044\u304f\nfor i in range(best_num, len(best_sushi)):\n  sushi_point += best_sushi[i]\n  #print(\"----best_sushi[i]\",best_sushi[i],\"\u3092\u8ffd\u52a0\")\n  if len(other_sushi) == 0:\n    break\n  rem = other_sushi.pop() # \u53d6\u308a\u9664\u304f\u5bff\u53f8\n  sushi_point -= rem\n  kind_point = (i + 1) ** 2\n  \n  #print(\"sushi_point\",sushi_point,\"kind_point\",kind_point,\"\u5408\u8a08\",sushi_point + kind_point)\n  \n  if ans < sushi_point + kind_point:\n    ans = sushi_point + kind_point\n    \nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nN, K = list(map(int, input().split()))\nnums = []\nfor i in range(N):\n    t, d = list(map(int, input().split()))\n    nums.append((d, t))\nnums.sort(reverse=True)\nse = set()\ndoubled = []\nrest = []\npoints = 0\nfor i, n in enumerate(nums):\n    if i < K:\n        if not n[1] in se:\n            se.add(n[1])\n        else:\n            doubled.append(n)\n        points += n[0]\n    else:\n        rest.append(n)\nans = points + pow(len(se), 2)\nidx = len(doubled)-1\nfor d, t in rest:\n    if idx < 0: break\n    if t in se: continue\n    points -= doubled[idx][0]\n    idx -= 1\n    points += d\n    se.add(t)\n    ans = max(ans, points+pow(len(se), 2))\nprint(ans)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,k = map(int, input().split())\n    td = [list(map(int, input().split())) for _ in range(n)]\n    td.sort(reverse=True, key=lambda a: a[1])\n    delicious = 0\n    syurui = set()\n    suteru = []\n    for i in range(k):\n        t, d = td[i]\n        delicious += d\n        if  t in syurui:\n            suteru.append(d)\n        else:\n            syurui.add(t)\n    #heapify(suteru)\n    suteru.sort()\n    neta = len(syurui)\n    res = delicious + neta**2\n    for i in range(k, n):\n        t, d = td[i]\n        if t in syurui:\n            continue\n        if len(suteru)==0:\n            print(res)\n            return\n        syurui.add(t)\n        x = suteru.pop(0)\n        delicious += d - x\n        neta += 1\n        res = max(res, delicious+neta**2)\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "\nn, k = list(map(int, input().split()))\nsushi = []\nfor i in range(n):\n    sushi.append(list(map(int, input().split())))\npoint = 0\nsushi_kind = set()\nduplication = []\nsushi.sort(key=lambda x: x[1],reverse = True)\nfor i in range(k):\n    point += sushi[i][1]\n    if sushi[i][0] in sushi_kind:\n        duplication.append(sushi[i])\n    else:\n        sushi_kind.add(sushi[i][0])\nans = point + pow(len(sushi_kind),2)\ndup_index = len(duplication) - 1\nfor i in range(k,n):\n    if sushi[i][0] in sushi_kind:\n        continue\n    else:\n        if dup_index >= 0:\n            point -= duplication[dup_index][1]\n            dup_index -= 1\n            point += sushi[i][1]\n            sushi_kind.add(sushi[i][0])\n    ans = max(ans, point + pow(len(sushi_kind),2))\nprint(ans)\n\n", "N,K = list(map(int,input().split()))\nTD = [tuple(map(int,input().split())) for i in range(N)]\nTD.sort(key=lambda x:x[1])\n\nimport heapq\nhq = []\nheapq.heapify(hq)\nselected = set()\nans = 0\nfor _ in range(K):\n    t,d = TD.pop()\n    if t in selected:\n        heapq.heappush(hq, d)\n    else:\n        selected.add(t)\n    ans += d\nans += len(selected)**2\n\ntmp = ans\nwhile TD:\n    t,d = TD.pop()\n    if t in selected: continue\n    selected.add(t)\n    if len(hq)==0: break\n    tmp -= heapq.heappop(hq)\n    tmp += d\n    tmp += len(selected)*2 - 1\n    ans = max(ans ,tmp)\nprint(ans)\n", "\n# -*-coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    S = [tuple(map(int, input().split())) for _ in range(n)]\n    S.sort(key=lambda x: -x[1])\n    y_1, y_0 = [0], [0]\n    st = set()\n\n    for t, d in S:\n        if t in st:\n            #\u7d2f\u7a4d\u5831\u916c\u548c\u306e\u30ea\u30b9\u30c8\n            y_0.append(y_0[-1]+d)\n        else:\n            st.add(t)\n            y_1.append(y_1[-1]+d)\n    \n\n    max_sum = -1\n\n    for i in range(1,k+1):\n        if k-i >= len(y_0):\n            continue\n        if i >= len(y_1):\n            break\n        max_sum = max(max_sum, y_0[k-i]+y_1[i]+i**2)\n    \n    print(max_sum)\n    return\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    TD = [list(map(int, input().split())) for _ in range(n)]\n    TD.sort(key=lambda z: -z[1])\n    TD_new = [[] for _ in range(n)]\n    for t, d in TD:\n        TD_new[t - 1].append([d, 0] if len(TD_new[t - 1]) else [d, 1])\n\n    ALL = []\n    for td in TD_new:\n        ALL.extend(td)\n    ALL.sort(reverse=True)\n    que = deque(ALL)\n\n    x = y = 0\n    zero = []\n    for _ in range(k):\n        d, ex = que.popleft()\n        x += d\n        y += ex\n        if ex == 0:\n            heappush(zero, d)\n\n    res = x + y ** 2\n    while que:\n        d, ex = que.popleft()\n        if ex:\n            if zero:\n                x += d - heappop(zero)\n                y += 1\n                res = max(res, x + y ** 2)\n            else:\n                break\n\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n, k = list(map(int, input().split()))\ntd = [list(map(int, input().split())) for _ in range(n)]\n\ntd.sort(key = lambda x:x[1], reverse=True)\ncand = []\nmemo = [0 for i in range(n+1)]\n\nans = 0\nduplicate = []\nunique = []\nnum = 0\ni = 0\n\nfor t, d in td:\n    i += 1\n    if i <= k:\n        ans += d\n        if memo[t]:\n            duplicate.append(d)\n        else:\n            memo[t] = 1\n            num += 1\n    else:\n        if not memo[t]:\n            unique.append(d)\n            memo[t] = 1\n\ntmp = ans\nans += num * num\n\n# print(tmp, ans)\n\nfor d, u in zip(reversed(duplicate), unique):\n    tmp += u - d\n    num += 1\n    ans = max(ans, tmp + num * num)\n\nprint(ans)\n", "n,k=list(map(int,input().split()))\ntop=[0]*n\nsub=[]\nfor _ in range(n):\n    t,d=list(map(int,input().split()))\n    t-=1\n    if top[t]==0:\n        top[t]=d\n    else:\n        if d>top[t]:\n            sub.append(top[t])\n            top[t]=d\n        else:\n            sub.append(d)\ntop.sort(reverse=True)\ntop_sum=[0]\nsub.sort(reverse=True)\nsub_sum=[0]\n\nfor i in top:\n    if i==0:\n        top_sum.append(-1)\n    else:\n        top_sum.append(top_sum[-1]+i)\nfor i in sub:\n    sub_sum.append(sub_sum[-1]+i)\nans=0\nfor i in range(1,k+1):\n    if i+len(sub_sum)-1>=k and top_sum[i]!=-1:\n        ans=max(ans,top_sum[i]+sub_sum[k-i]+i**2)\nprint(ans)\n\n", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,K = map(int,input().split())\nTD = [tuple(map(int,input().split())) for _ in range(N)]\n\n# \u7f8e\u5473\u3057\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u304a\u304f\n#  t : \u30cd\u30bf\u306e\u7a2e\u985e\n#  d : \u7f8e\u5473\u3057\u3055\u57fa\u790e\u30dd\u30a4\u30f3\u30c8\nTD.sort(key=lambda x:x[1], reverse=True)\n\n# \u7f8e\u5473\u3057\u3044\u9806\u306bK\u500b\u98df\u3079\u305f\u5834\u5408\u306e\u6e80\u8db3\u30dd\u30a4\u30f3\u30c8\nans = 0\ns = set() # \u98df\u3079\u305f\u30cd\u30bf\u306e\u96c6\u5408\nr = list() # \u3059\u3067\u306b\u98df\u3079\u305f\u30cd\u30bf, \u3042\u3068\u3067\u4ea4\u63db\u3059\u308b\u7528\nfor i in range(K):\n    t,d = TD[i]\n    ans += d\n    if t not in s:\n        s.add(t) # \u98df\u3079\u305f\u30cd\u30bf\u306e\u7a2e\u985e\u306e\u96c6\u5408\n    else:\n        r.append(TD[i])\nans += len(s)**2\n\nAns = ans\n\n# \u7f8e\u5473\u3057\u3044\u9806\u306eK+1\u756a\u76ee\u304b\u3089, \u30cd\u30bf\u306e\u7a2e\u985e\u304c\u5897\u3048\u308b\u3088\u3046\u306a\u64cd\u4f5c\u3092\u9806\u756a\u306b\u8a66\u3057\u3066\u3044\u304f\nfor i in range(K,N):\n    t0,d0 = TD[i]\n    # \u307e\u3060\u98df\u3079\u3066\u306a\u3044\u30cd\u30bf and \u4ea4\u63db\u7528\u306e\u5bff\u53f8\u304c\u3042\u308b\u306a\u3089\n    if t0 not in s and len(r) > 0:\n        # \u4ea4\u63db\u7528\u306e\u5bff\u53f8\u306e\u4e00\u756a\u7f8e\u5473\u3057\u3055\u57fa\u790e\u30dd\u30a4\u30f3\u30c8\u304c\u4f4e\u3044\u3082\u306e\u3092\u4ea4\u63db\u3059\u308b\u306e\u304c\u6700\u5584\n        t1,d1 = r.pop()\n        # \u6e80\u8db3\u30dd\u30a4\u30f3\u30c8\u306e\u518d\u8a08\u7b97\n        ans = ans - d1 + d0 - len(s)**2 + (len(s)+1)**2\n        # \u98df\u3079\u305f\u30cd\u30bf\u306e\u96c6\u5408\u306b\u8ffd\u52a0\n        s.add(t0)\n        # \u6e80\u8db3\u5ea6\u304c\u5927\u304d\u304f\u306a\u3063\u305f\u304b\u90fd\u5ea6\u78ba\u8a8d\n        Ans = max(Ans,ans)\n\nprint(Ans)", "# tokenakatta ...\ndef main():\n    N, K = list(map(int, input().split()))\n    l = []\n    for _ in range(N):\n        t, d = list(map(int, input().split()))\n        l.append((t, d))\n    l.sort(key=lambda x:x[1], reverse=True)\n    s = set()\n    e = []\n    t = 0\n    for i in range(K):\n        t += l[i][1]\n        if l[i][0] in s:\n            e.append(l[i])\n        else:\n            s.add(l[i][0])\n    rl = [t + len(s) * len(s)]\n    e.reverse()\n    ei = 0\n    for i in range(K, N):\n        if l[i][0] in s:\n            continue\n        if ei >= len(e):\n            break\n        s.add(l[i][0])\n        t -= e[ei][1]\n        t += l[i][1]\n        ei += 1\n        rl.append(t + len(s) * len(s))\n    return max(rl)\nprint((main()))\n", "n,k=map(int,input().split())\nINF=10**18\nsushi=[[-INF] for _ in range(n)]\nfor _ in range(n):\n  t,d=map(int,input().split())\n  sushi[t-1].append(d)\nfor i in range(n):\n  sushi[i].sort(reverse=True)\nsushi.sort(key=lambda x:x[0],reverse=True)\nq=[]\nres=0\nfor i in range(k):\n  res+=sushi[i][0]\n  for j in sushi[i][1:]:\n    q.append(j)\nq.sort()\ncur=res\nres+=k**2\nfor var in range(1,k)[::-1]:\n  a=q.pop()\n  b=sushi[var][0]\n  cur+=a-b\n  res=max(res,cur+var**2)\nprint(res)", "def main():\n    n, k = map(int, input().split())\n    sushi = [list(map(int, input().split())) for _ in range(n)]\n    sushi.sort(key=lambda x: x[1], reverse=True)\n    ans = 0\n    t = [0]*(n+1)\n    tmp = 0\n    cnt = 0\n    for i in range(k):\n        ans += sushi[i][1]\n        if t[sushi[i][0]] == 0:\n            cnt += 1\n        tmp += sushi[i][1]\n        t[sushi[i][0]] += 1\n    ans = tmp + cnt*cnt\n    p = k\n    for i in range(k, n):\n        f = False\n        if t[sushi[i][0]] == 0:\n            f = True\n            for j in reversed(range(p)):\n                if 1 < t[sushi[j][0]]:\n                    t[sushi[j][0]] -= 1\n                    t[sushi[i][0]] += 1\n                    tmp -= sushi[j][1]\n                    tmp += sushi[i][1]\n                    p = j\n                    cnt += 1\n                    ans = max(ans, tmp+cnt*cnt)\n                    f = False\n                    break\n        if f:\n            break\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, K = map(int, input().split())\nS = [tuple(map(int, input().split())) for _ in range(N)]\n\nS.sort(key=lambda x: -x[1])\nst = set()\nfirst_acc, other_acc = [0], [0]\nfor t, d in S:\n  if t in st:\n    other_acc.append(other_acc[-1] + d)\n  else:\n    st.add(t)\n    first_acc.append(first_acc[-1] + d)\n\nans = 0\nfor i in range(K + 1):\n  if len(first_acc) <= i or len(other_acc) <= K - i:\n    continue\n  ans = max(ans, first_acc[i] + other_acc[K - i] + i * i)\n\nprint(ans)", "# \u5199\u7d4cAC\n\nfrom heapq import heappop,heappush\n\nINF = 10 ** 18\n\nN, K = map(int, input().split())\n# S[i]: \u7a2e\u985ei\u306e\u7f8e\u5473\u3057\u3055\u306e\u96c6\u5408\nS = [[] for _ in range(N)]\nfor _ in range(N):\n    t,d = map(int, input().split())\n    S[t-1].append(d)\n\n# \u5404\u7a2e\u985e\u306b\u3064\u3044\u3066\u3001\u7f8e\u5473\u3057\u3044\u9806\u306b\u4e26\u3079\u308b\nfor i in range(N):\n    S[i].sort(reverse = True)\n    if not S[i]: S[i].append(-INF) # \u756a\u5175\n\n# \u300c\u7f8e\u5473\u3057\u3055\u306e\u6700\u5927\u5024\u300d\u306e\u964d\u9806\u3067\u30bd\u30fc\u30c8\nS.sort(reverse = True)\n\numa = 0 # \u304a\u3044\u3057\u3055\u57fa\u790e\u30dd\u30a4\u30f3\u30c8\nque = [] # \u9078\u3070\u308c\u3066\u3044\u306a\u3044\u5bff\u53f8\u306e\u7f8e\u5473\u3057\u3055\u30ea\u30b9\u30c8\nfor i in range(K):\n    # \u3042\u308b\u7a2e\u985e\u306e\u4e00\u756a\u7f8e\u5473\u3057\u3044\u5bff\u53f8\u3092\u9078\u3076\n    uma += S[i][0]\n    for j in range(1, len(S[i])):\n        heappush(que, (-1) * S[i][j])\n\n# \u6b8b\u308a\u306e\u5bff\u53f8\u3082\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\nfor i in range(K, N):\n    for j in range(len(S[i])):\n        heappush(que, (-1) * S[i][j])\n\nans = uma + K * K\n# \u7a2e\u985e\u3092\u6e1b\u3089\u3057\u3066\u3044\u304f\nfor x in range(K - 1, 0, -1):\n    v = S[x][0] # \u9078\u3070\u308c\u3066\u3044\u308b\u6700\u5c0f\u306e\u300c\u304a\u3044\u3057\u3055\u300d\n    w = (-1) * que[0] # \u9078\u3070\u308c\u3066\u3044\u306a\u3044\u6700\u5927\u306e\u300c\u304a\u3044\u3057\u3055\u300d\n    if v < w:\n        heappop(que)\n        heappush(que, (-1) * v)\n        uma -= v; uma += w\n    ans = max(ans, uma + x * x)\n\nprint(ans)", "from collections import defaultdict\nN,K=map(int,input().split())\n\ndtlist=[]\ntset_all=set()\nfor i in range(N):\n  t,d=map(int,input().split())\n  dtlist.append((d,t))\n  tset_all.add(t)\ndtlist.sort()\n#print(heapq)\n\ndtlist_Krev=[]\ndsum=0\ntdic=defaultdict(int)\nfor i in range(K):\n  d,t=dtlist.pop()\n  dtlist_Krev.append((d,t))\n  dsum+=d\n  tdic[t]+=1\n#dtlist_Krev.sort(reverse=True)\n\nt0=len(tdic)\nmax_answer=dsum+(t0**2)\n#print(t0,max_answer)\n\nfor i in range(t0+1,min(K,len(tset_all))+1):\n  while(True):    \n    d1,t1=dtlist_Krev.pop()\n    if tdic[t1]>1:\n      tdic[t1]-=1\n      dsum-=d1\n      break\n      \n  while(True):        \n    d2,t2=dtlist.pop()\n    if tdic[t2]==0:\n      tdic[t2]=1\n      dsum+=d2      \n      break\n          \n  answer_i=dsum+(i**2)\n  #print(i,answer_i)\n  max_answer=max(max_answer,answer_i)\n  \nprint(max_answer)", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nN, K = list(map(int, input().split()))\nTD = []\n\nfor _ in range(N):\n  TD.append(tuple(map(int, input().split())))\n\nTD.sort(key = lambda x:x[1], reverse=True)\nTD += [(TD[-1][0], 0)]\n\nD = defaultdict(list)\nT = [0]*N\nH = []\nans = [0]\n\nfor i in range(K):\n  t, d = TD[i]\n  T[t-1] += 1\n  D[t].append(d)\n  ans[0] += d\n\ncnt = sum(1 for c in T if c >= 1)\nans[0] += cnt**2\n\nfor t, d in TD:\n  if T[t-1] >= 2:\n    heappush(H, (D[t].pop(), t))\n    T[t-1] -= 1\n\n#print(ans, H, T, cnt)\nfor i in range(K, N):\n  if H:\n    t1, d1 = TD[i]\n    d2, t2 = heappop(H)\n    #print(t1, d1, t2, d2)\n    if T[t1-1] == 0:\n      ans.append(ans[-1] + d1 - d2 + 2*cnt + 1)\n      cnt += 1\n      T[t1-1] += 1\n    else:\n      heappush(H, (d2, t2))\n    #print(ans, H, T, cnt)\n\nprint((max(ans)))\n#print(ans)\n", "n,k=list(map(int,input().split()))\ntd=sorted([list(map(int,input().split())) for i in range(n)],reverse=True,key=lambda x:x[1])\n\nans=0\nkl=dict()\nfor i in range(k):\n    ans+=td[i][1]\n    if td[i][0] in kl:\n        kl[td[i][0]]+=1\n    else:\n        kl[td[i][0]]=1\nl=len(kl)\nans+=(l**2)\nans_=ans\nnow=k-1\nfor i in range(k,n):\n    if td[i][0] not in kl:\n        #\u6700\u5c0f\u3092\u6c42\u3081\u308b\u306e\u3092\u3082\u3063\u3068\u65e9\u304f\n        while now>=0:\n            if kl[td[now][0]]>1:\n                mi=td[now]\n                kl[mi[0]]-=1\n                now-=1\n                break\n            now-=1\n        if now==-1:\n            break\n        else:\n            ans=ans+2*l+1-mi[1]+td[i][1]\n            kl[td[i][0]]=1\n            ans_=max(ans,ans_)\n            l+=1\n\nprint(ans_)\n", "import sys\nfrom heapq import heapify, heappop, heappush\n\ndef solve():\n    input = sys.stdin.readline\n    N, K = map(int, input().split())\n    S = [None] * N\n    for i in range(N):\n        t, d = map(int, input().split())\n        S[i] = (-d, t)\n    heapify(S)\n\n    base_point = 0\n    appeared_type = set()\n    type_Num = 0\n    duplicated = []\n    heapify(duplicated)\n    for i in range(K):\n        d, t = heappop(S)\n        if t in appeared_type:\n            base_point -= d\n            heappush(duplicated, -d)\n        else:\n            base_point -= d\n            appeared_type |= {t}\n            type_Num += 1\n\n    Ans = base_point + type_Num * type_Num\n    while S:\n        d, t = heappop(S)\n        if t in appeared_type: continue\n        else:\n            if not duplicated: continue\n            else:\n                remove = heappop(duplicated)\n                base_point -= d + remove\n                type_Num += 1\n                appeared_type |= {t}\n                Ans = max(Ans, base_point + type_Num * type_Num)\n    print(Ans)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\nn, k = list(map(int, input().split()))\n\nSUSHI = []\nfor _ in range(n):\n    t, d = list(map(int, input().split()))\n    SUSHI.append((d, t))\nSUSHI.sort(reverse = True)\n\nNEW = {i:True for i in range(1, n + 1)}\nx, y = 0, 0\nA, B = [], []\n\nfor d, t in SUSHI[:k]:\n    if NEW[t]:\n        x += d; y += 1\n        NEW[t] = False\n    else:\n        x += d\n        A.append(d)\n\nfor d, t in SUSHI[k:]:\n    if NEW[t]:\n        B.append(d)\n        NEW[t] = False\nB.sort()\n\nanswer = x + y**2\nwhile A and B:\n    a, b = A.pop(), B.pop()\n    x -= a; x += b; y += 1\n    if x + y**2 > answer:\n        answer = x + y**2\n\nprint(answer)\n", "N,K=map(int,input().split())\nsushi=[]\nfor i in range(N):\n    t,d=map(int,input().split())\n    sushi.append((t,d))\nsushi.sort(key=lambda x:(x[0],-x[1]))\n#print(sushi)\nX=[sushi[0][1]]\nY=[]\nfor i in range(1,N):\n    if sushi[i-1][0]==sushi[i][0]:\n        Y.append(sushi[i][1])\n    else:\n        X.append(sushi[i][1])\nX.sort(reverse=True)\nY.sort(reverse=True)\nSX=[0]\nSY=[0]\nfor i in X:\n    SX.append(SX[-1]+i)\nfor i in Y:\n    SY.append(SY[-1]+i)\nans=0\n#print(X)\n#print(Y)\n#1<=x<len(X)\n#K-len(Y)<=x<=\nfor x in range(max(1,K-len(Y)),min(len(SX),K+1)):\n    ans=max(SX[x]+SY[K-x]+x*x,ans)\nprint(ans)", "n, k = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab_s = sorted(ab, key=lambda x: x[1])\nab_r = list(reversed(ab_s))\n\nt = [x[0] for x in ab_r]\nd = [x[1] for x in ab_r]        \n\nt_set = len(set(t[:k]))\nd_sum = sum(d[:k])\n\nres = [t_set**2 + d_sum]\n\nfrom collections import Counter\nt_cou = Counter(t[:k])\n\ndp =[0]*(n+1)\nj_old = k-1\n\nfor i in t_cou:\n    dp[i] = t_cou[i]\n\nfor i in range(k,n):\n    t_new = ab_r[i][0]\n    if dp[t_new] ==0:\n        for j in range(j_old,-1,-1):\n            t_old = ab_r[j][0]\n            if dp[t_old] <=1:\n                pass\n            else:\n                dp[t_new] =1\n                dp[t_old] -=1\n                t_set +=1\n                d_sum = d_sum - ab_r[j][1] + ab_r[i][1]\n                res.append(t_set**2 + d_sum)\n                j_old = j-1\n                break\n            j_old = -1\n\nprint(max(res))"]
["def main():\n    class unionfind():\n        #size:\u8981\u7d20\u6570,tree\uff1aunionfind\u6728\n        def __init__(self,size):#self,\u8981\u7d20\u6570\n            self.size=size\n            self.tree=[i for i in range(self.size)]#root,depth\n        \n        #root\u3092\u63a2\u3059\n        def root(self,index):\n            temp_list=[]\n            temp=self.tree[index]\n            while index!=temp:\n                temp_list.append(index)\n                index=temp\n                temp=self.tree[index]\n            for i in temp_list:\n                self.tree[i]=index\n            return index\n        \n        #\u7d50\u5408\n        def unite_r(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            if r1<r2:\n                self.tree[r1]=r2\n            else:\n                self.tree[r2]=r1\n\n        def unite_l(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            if r1>r2:\n                self.tree[r1]=r2\n            else:\n                self.tree[r2]=r1\n\n        #\u540c\u3058\u304b\u5224\u5b9a\n        def same(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            return r1==r2\n            \n    n=int(input())\n    a=list(map(int,input().split()))\n    d=[0]*n\n    for i,j in enumerate(a):\n        d[j-1]=i+2\n    vis=[False]*(n+4)\n    u_r=unionfind(n+4)\n    u_l=unionfind(n+4)\n    ans=0\n    for j,i in enumerate(d[:-1]):\n        vis[i]=True\n        if vis[i+1]==True:\n            u_r.unite_r(i,i+1)\n            u_l.unite_l(i,i+1)\n            k1=u_r.root(i+1)+1\n        else:\n            k1=i+1\n        if vis[k1+1]==True:\n            cnt1=u_r.root(k1+1)+1\n        else:\n            cnt1=k1+1\n        cnt1=min(cnt1,n+2)\n        if vis[i-1]==True:\n            u_r.unite_r(i,i-1)\n            u_l.unite_l(i,i-1)\n            k2=u_l.root(i-1)-1\n        else:\n            k2=i-1\n        if vis[k2-1]==True:\n            cnt2=u_l.root(k2-1)-1\n        else:\n            cnt2=k2-1\n        cnt2=max(cnt2,1)\n        ans+=((k2-cnt2)*(k1-i)+(cnt1-k1)*(i-k2))*(j+1)\n    print(ans)\nmain()", "import bisect\n\n\nclass SqrtSet:\n    def __init__(self, block_limit=201):\n        self.key = []\n        self.child = [[]]\n        self.block_limit = block_limit\n\n    def search_lower(self, key):\n        if key is None:\n            return None\n        ret = None\n        i = bisect.bisect_left(self.key, key)\n        if i != 0:\n            ret = self.key[i - 1]\n        block = self.child[i]\n        i = bisect.bisect_left(block, key)\n        if i != 0:\n            ret = block[i - 1]\n        return ret\n\n    def search_higher(self, key):\n        if key is None:\n            return None\n        ret = None\n        i = bisect.bisect_right(self.key, key)\n        if i != len(self.key):\n            ret = self.key[i]\n        block = self.child[i]\n        i = bisect.bisect_right(block, key)\n        if i != len(block):\n            ret = block[i]\n        return ret\n\n    def insert(self, key):\n        i = bisect.bisect(self.key, key)\n        block = self.child[i]\n        bisect.insort(block, key)\n        if len(block) == self.block_limit:\n            sep = self.block_limit // 2\n            self.key.insert(i, block[sep])\n            self.child.insert(i + 1, block[sep + 1:])\n            self.child[i] = block[:sep]\n\n    def dump(self):\n        for b in self.child:\n            print(len(b), end=\" \")\n        print(\"\")\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = SqrtSet()\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.search_higher(i)\n        nexnex = t.search_higher(nex)\n        pre = t.search_lower(i)\n        prepre = t.search_lower(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "N = int(input())\nP = [int(x) for x in input().split()]\n\nPIdx = sorted([(i + 1, v) for i, v in enumerate(P)], key = lambda x: x[1])\n\nL = [0]\nfor i in range(N + 1):\n    L.append(i)\n\nR = [i + 1 for i in range(N + 1)]\nR.append(N + 1)\n\nans = 0\nfor i, v in PIdx:\n    l1 = L[i]\n    l2 = L[l1]\n    r1 = R[i]\n    r2 = R[r1]\n\n    ans += v * ((i - l1) * (r2 - r1) + (l1 - l2) * (r1 - i))\n\n    L[r1] = l1\n    R[l1] = r1\n\nprint(ans)", "N = int(input())\nP = list(map(int, input().split()))\nR = list(range(N))\nL = list(range(N))\nI = [-1] * (N+1)\nfor i, p in enumerate(P):\n    I[p] = i\n\nans = 0\nfor n, idx in enumerate(I[1:], 1):\n    l = idx-1\n    while l>=0 and l!=L[l]:\n        l = L[l]\n    r = idx+1\n    while r<N and r!=R[r]:\n        r = R[r]\n    L[idx] = l\n    R[idx] = r\n\n    if l != -1:\n        l2 = l-1\n        while l2>=0 and l2!=L[l2]:\n            l2 = L[l2]\n        ans += n * (l-l2) * (r-idx)\n    if r != N:\n        r2 = r+1\n        while r2<N and r2!=R[r2]:\n            r2 = R[r2]\n        ans += n * (idx-l) * (r2-r)\nprint(ans)\n", "n = int(input())\nlst = list(enumerate(list(map(int, input().split()))))\n\nsorted_lst = sorted(lst, key = lambda x: x[1])\nleft_next_index = list(range(-1, n - 1)) + [-1, -1]\nright_next_index = list(range(1, n + 1)) + [n, n]\n\nans = 0\nfor i, p in sorted_lst:\n    l2 = left_next_index[i]\n    l1 = left_next_index[l2]\n    r1 = right_next_index[i]\n    r2 = right_next_index[r1]\n    \n    a = p * ((l2 - l1) * (r1 - i) + (r2 - r1) * (i - l2))\n    ans += a\n    \n    left_next_index[r1] = l2\n    right_next_index[l2] = r1\nprint(ans)", "n=int(input())\np=list(map(int,input().split()))\nid=[0]*(n+1)\nfor i,p_i in enumerate(p):\n    id[p_i]=i\n\nr = list(range(1,n+1))+[n,n]\nl = list(range(-1,n-1))+[-1,-1]\nans=0\nfor p in range(1,n+1):\n    x=id[p]\n    r1=r[x]\n    r2=r[r1]\n    l1=l[x]\n    l2=l[l1]\n    ans+=p*((x-l1)*(r2-r1) + (l1-l2)*(r1-x))\n    r[l1]=r1\n    l[r1]=l1\nprint(ans)\n", "from bisect import*\nclass SqrtSet:\n    def __init__(self,block_limit=201):\n        self.key=[]\n        self.child=[[]]\n        self.block_limit=block_limit\n    def le(self,key):\n        ret=key\n        i=bisect_left(self.key,key)\n        if i:ret=self.key[i-1]\n        block=self.child[i]\n        i=bisect_left(block,key)\n        if i:ret=block[i-1]\n        return ret\n    def ge(self,key):\n        ret=key\n        i=bisect(self.key,key)\n        if i<len(self.key):ret=self.key[i]\n        block=self.child[i]\n        i=bisect(block,key)\n        if i<len(block):ret=block[i]\n        return ret\n    def insert(self,key):\n        i=bisect(self.key,key)\n        block=self.child[i]\n        insort(block,key)\n        if len(block)==self.block_limit:\n            sep=self.block_limit//2\n            self.key.insert(i,block[sep])\n            self.child.insert(i+1,block[sep+1:])\n            self.child[i]=block[:sep]\ndef main():\n    n,*p=map(int,open(0).read().split())\n    l=[0]*n\n    for i,v in enumerate(p,1):l[v-1]=i\n    t=SqrtSet()\n    insert,le,ge=t.insert,t.le,t.ge\n    insert(0),insert(n+1)\n    a=0\n    for i,v in list(enumerate(l,1))[::-1]:\n        f,b=ge(v),le(v)\n        g,c=ge(f),le(b)\n        a+=i*((f-v)*(b-c)+(v-b)*(g-f))\n        insert(v)\n    print(a)\nmain()", "N = int(input())\nP = list(map(int, input().split()))\n\nindex_lst = [0] * N\nfor index, i in enumerate(P):\n    index_lst[i - 1] = index\n\nleft_next_Index = list(range(-1, N - 1)) + [-1, -1]\nright_next_Index = list(range(1, N + 1)) + [N, N]\n# print (left_next_Index)\n# print (right_next_Index)\nans = 0\nfor i in range(1, N):\n    index = index_lst[i - 1]\n    # print (i, index)\n    l1 = left_next_Index[index]\n    l2 = left_next_Index[l1]\n    r1 = right_next_Index[index]\n    r2 = right_next_Index[r1]\n    # print ('l1 =', l1, ' l2 =', l2, ' r1 =', r1, ' r2 =', r2)\n    ans += i * ((index - l1) * (r2 - r1) + (r1 - index) * (l1 -l2))\n\n    left_next_Index[r1] = l1\n    right_next_Index[l1] = r1\n\nprint (ans)", "class Node:\n  def __init__(self, v):\n    self.v = v\n    self.p = None\n    self.n = None\n  \n  def delete(self):\n    if self.p:\n      self.p.n = self.n\n    if self.n:\n      self.n.p = self.p\n\nN = int(input())\npp = list(map(int, input().split()))\nnn = dict()\nprev = None\nfor i, p in enumerate(pp):\n  n = Node(i)\n  if prev:\n    prev.n = n\n    n.p = prev\n  nn[p] = n\n  prev = n\ns = 0\nfor x in range(1, N):\n  c = nn[x]\n  ci = c.v\n  pi = c.p.v if c.p else -1\n  ni = c.n.v if c.n else N\n  if c.p:\n    ppi = c.p.p.v if c.p.p else -1\n    s += x * (pi - ppi) * (ni - ci)\n  if c.n:\n    nni = c.n.n.v if c.n.n else N\n    s += x * (ci - pi) * (nni - ni)\n  c.delete()\nprint(s)", "N = int(input())\nP = list(map(int, input().split()))\n \nleft_bigger  = [0] + [i for i in range(N+1)]\nright_bigger = [i+1 for i in range(N+1)] + [N+1]\n \nE = [(v, i+1) for i, v in enumerate(P)]\nE.sort()\n\nans = 0\nfor v,i in E:\n    l0=left_bigger[i]\n    l1=left_bigger[l0]\n    r0=right_bigger[i]\n    r1=right_bigger[r0]\n    \n    ans += ((r1-r0)*(i-l0) + (r0-i)*(l0-l1))*v\n    left_bigger[r0]=l0\n    right_bigger[l0]=r0\nprint(ans)", "def argsort(a):\n    return list(map(lambda z: z[1], sorted(zip(a, range(len(a))))))\n\nN = int(input())\nP = list(map(int, input().split()))\n\na = argsort(P)\nleft = [i for i in range(N)]\nright = [i for i in range(N)]\nresult = 0\nfor i in range(1, N):\n    k = a[i - 1]\n    extend_left = k - 1 >= 0 and P[k - 1] < i\n    extend_right = k + 1 < N and P[k + 1] < i\n    if extend_left and extend_right:\n        L = left[k - 1]\n        R = right[k + 1]\n    elif extend_left:\n        L = left[k - 1]\n        R = k\n    elif extend_right:\n        R = right[k + 1]\n        L = k\n    else:\n        L = k\n        R = k\n    right[L] = R\n    left[R] = L\n    if L - 1 >= 0:\n        if L - 2 >= 0 and P[L - 2] < i:\n            LL = left[L - 2]\n        else:\n            LL = L - 1\n        result += ((L - 1) - LL + 1) * (R - k + 1) * i;\n    if R + 1 < N:\n        if R + 2 < N and P[R + 2] < i:\n            RR = right[R + 2]\n        else:\n            RR = R + 1\n        result += (RR - (R + 1) + 1) * (k - L + 1) * i;\nprint(result)", "class Node:\n    def __init__(self,  key=None):\n        self.key = key\n        self.height = 1\n        self.parent = None\n        self.left = None\n        self.right = None\n\ndef get_height(t):\n    return 0 if t is None else t.height\n\ndef get_balance(t):\n    return get_height(t.left) - get_height(t.right)\n\ndef update_height(t):\n    left_height = get_height(t.left)\n    right_height = get_height(t.right)\n    if left_height >= right_height:\n        t.height = left_height + 1\n    else:\n        t.height = right_height + 1\n\n\nclass AVL:\n    def __init__(self):\n        self.root = Node()       \n    \n    def insert(self, key):\n        if self.root.key is None:\n            self.root.key = key\n            return\n        cursor = self.root\n        while cursor:\n            p = cursor\n            if key == cursor.key:\n                return\n            elif key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        new_node = Node(key)\n        new_node.parent = p\n        if key < p.key:\n            p.left = new_node\n        else:\n            p.right = new_node\n        \n        cursor = p\n        while cursor:     \n            balance = get_balance(cursor)\n            if balance == 0:\n                break\n            elif balance == 2:\n                if key < cursor.left.key:\n                    self.rotate_r(cursor)\n                else:\n                    self.rotate_lr(cursor)\n                break\n            elif balance == -2:\n                if key > cursor.right.key:\n                    self.rotate_l(cursor)\n                else:\n                    self.rotate_rl(cursor)\n                break\n            else:\n                update_height(cursor)\n                cursor = cursor.parent\n           \n    def rotate_r(self, n):\n        p = n.parent\n        c = n.left\n        gc = n.left.right\n        \n        if gc is not None:\n            n.left = gc\n            gc.parent = n\n        else:\n            n.left = None\n            \n        c.right = n\n        n.parent = c\n        \n        if p is not None:    \n            if p.right == n:\n                p.right = c\n            else:\n                p.left = c\n            c.parent = p\n        else:\n            self.root = c\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)                \n    \n    def rotate_l(self, n):\n        p = n.parent\n        c = n.right\n        gc = n.right.left\n        \n        if gc is not None:\n            n.right = gc\n            gc.parent = n\n        else:\n            n.right = None\n            \n        c.left = n\n        n.parent = c\n        \n        if p is not None:\n            if p.left == n:\n                p.left = c\n            else:\n                p.right = c\n            c.parent = p\n        else:\n            self.root = c\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)       \n      \n    def rotate_rl(self, n):\n        p = n.parent\n        c = n.right\n        gc = n.right.left\n        \n        if gc.left and gc.right:\n            n.right = gc.left\n            c.left = gc.right\n            gc.left.parent = n\n            gc.right.parent = c\n        elif gc.left:\n            n.right = gc.left\n            gc.left.parent = n\n            c.left = None\n        elif gc.right:\n            c.left = gc.right\n            gc.right.parent = c\n            n.right = None\n        else:\n            n.right = None\n            c.left = None\n            \n        gc.left = n\n        gc.right = c\n        n.parent = gc\n        c.parent = gc\n        \n        if p is not None:\n            if p.left == n:\n                p.left = gc\n            else:\n                p.right = gc\n            gc.parent = p\n        else:\n            self.root = gc\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)\n        update_height(gc)\n\n    def rotate_lr(self, n):\n        p = n.parent\n        c = n.left\n        gc = n.left.right\n        \n        if gc.left and gc.right:\n            c.right = gc.left\n            n.left = gc.right\n            gc.left.parent = c\n            gc.right.parent = n\n        elif gc.left:\n            c.right = gc.left\n            gc.left.parent = c\n            n.left = None\n        elif gc.right:\n            n.left = gc.right\n            gc.right.parent = n\n            c.right = None\n        else:\n            n.left = None\n            c.right = None\n        gc.left = c\n        gc.right = n\n        c.parent = gc\n        n.parent = gc\n        \n        if p is not None:\n            if p.left == n:\n                p.left = gc\n            else:\n                p.right = gc\n            gc.parent = p\n        else:\n            self.root = gc\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)\n        update_height(gc)        \n        \n    def find(self, key):\n        cursor = self.root\n        while cursor:\n            if cursor.key == key:\n                return cursor\n            if key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        return None\n    \n    def next_greater_key(self, cursor):\n        if cursor is None:\n            return None\n        if cursor.right:\n            cursor = cursor.right\n            while cursor.left:\n                cursor = cursor.left\n            return cursor\n        elif cursor.parent.left == cursor:\n            return cursor.parent\n        elif cursor.parent.right == cursor:\n            while cursor.parent and cursor.parent.right == cursor:\n                cursor = cursor.parent\n            if cursor.parent:\n                return cursor.parent\n        else:\n            return None\n        \n    def next_smaller_key(self, cursor):\n        if cursor is None:\n            return None\n        if cursor.left:\n            cursor = cursor.left\n            while cursor.right:\n                cursor = cursor.right\n            return cursor\n        elif cursor.parent.right == cursor:\n            return cursor.parent\n        elif cursor.parent.left == cursor:\n            while cursor.parent and cursor.parent.left == cursor:\n                cursor = cursor.parent\n            if cursor.parent:\n                return cursor.parent              \n        else:\n            return None\n        \n    def get_smaller_key(self, key):\n        cursor = self.find(key)\n        l1 = self.next_smaller_key(cursor)\n        l2 = self.next_smaller_key(l1)\n        if l2 is None:\n            l2 = 0\n        else:\n            l2 = l2.key\n        return l1.key, l2\n    \n    def get_greater_key(self, key):\n        cursor = self.find(key)\n        r1 = self.next_greater_key(cursor)\n        r2 = self.next_greater_key(r1)\n        if r2 is None:\n            r2 = 0\n        else:\n            r2 = r2.key\n        return r1.key, r2\n                \n\ndef main():\n\n    N = int(input())\n    P = map(int, input().split())\n    \n    idx = [-1] * (N + 1)\n    for i, v in enumerate(P, 1):\n        idx[v] = i\n    avl = AVL()\n    for i in [0, idx[N], N+1]:\n        avl.insert(i)\n    total = 0\n    for j in range(N - 1, 0, -1):\n        n = idx[j]\n        avl.insert(n)\n        \n        l1_idx , l2_idx = avl.get_smaller_key(n)\n        l1 = n - l1_idx\n        if l1_idx != 0:\n            l2 = l1_idx - l2_idx\n        else:\n            l2 = 0\n            \n        r1_idx, r2_idx = avl.get_greater_key(n)\n        r1 = r1_idx - n\n        if r1_idx != N + 1:\n            r2 = r2_idx - r1_idx\n        else:\n            r2 = 0\n            \n        cnt = (l1 * r2 + r1 * l2) * j\n        total += cnt\n    \n    print(total)\n    \ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nA = list(map(int, input().split()))\nA = [a-1 for a in A]\n\nP = [-1]*n\nfor i, a in enumerate(A):\n    P[a] = i\n\n#print(P)\n\nR = [[n]*2 for _ in range(n)]\nq = []\nimport heapq\nheapq.heapify(q)\nfor i in range(n):\n    temp = []\n    while q:\n        if q[0][0] < A[i]:\n            v, j = heapq.heappop(q)\n            R[v][j] = i\n            if j == 0:\n                temp.append((v, j+1))\n        else:\n            break\n    heapq.heappush(q, (A[i], 0))\n    for v, j in temp:\n        heapq.heappush(q, (v, j))\n\n#print(R)\n\nL = [[-1]*2 for _ in range(n)]\nq = []\nimport heapq\nheapq.heapify(q)\nfor i in reversed(list(range(n))):\n    temp = []\n    while q:\n        if q[0][0] < A[i]:\n            v, j = heapq.heappop(q)\n            L[v][j] = i\n            if j == 0:\n                temp.append((v, j+1))\n        else:\n            break\n    heapq.heappush(q, (A[i], 0))\n    for v, j in temp:\n        heapq.heappush(q, (v, j))\n\n#print(L)\nans = 0\nfor i in range(n-1):\n    p = P[i]\n    l1 = L[i][0]\n    l2 = L[i][1]\n    r1 = R[i][0]\n    r2 = R[i][1]\n    ans += ((l1-l2)*(r1-p)+(r2-r1)*(p-l1))*(i+1)\nprint(ans)\n", "import sys,bisect as bs,collections as cl\nsys.setrecursionlimit(100000)\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return list(map(int,input().split()))\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(list(map(max,x)))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\nn = onem()\n\np = [0] + l() + [n+1]\nans = 0\na = [0 for i in range(n+2)]\n\nfor i in range(n+2):\n    a[p[i]] = i\n\nl = [set() for i in range(n+2)]\nr = [set() for i in range(n+2)]\n\nfor i in range(n+2):\n    l[i].add(max(0,i-1))\n    l[i].add(max(0,i-2))\n    r[i].add(min(n+1,i+1))\n    r[i].add(min(n+1,i+2))\n\n\nfor i in range(n+1):\n    m = a[i]\n    x2,x1,y1,y2 = min(l[m]),max(l[m]),min(r[m]),max(r[m])\n    hoge= i*(abs((m-x1)*(y2-y1)) + abs((y1-m)*(x1-x2)))\n    ans += hoge\n\n    r[x1].clear()\n    r[x1].add(y1)\n    r[x1].add(y2)\n\n    l[y1].clear()\n    l[y1].add(x1)\n    l[y1].add(x2)\n    \n    r[x2].clear()\n    r[x2].add(x1)\n    r[x2].add(y1)\n\n    l[y2].clear()\n    l[y2].add(y1)\n    l[y2].add(x1)\n    \n\nprint(ans)\n\n\n", "# \u5e73\u65b9\u5206\u5272\u306b\u52dd\u3066\u306a\u3044\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\uff5e\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (add, pop) \u30c7\u30fc\u30bf\u69cb\u9020: https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (init, add, remove, search_higher_equal) Exclusive OR Queries: https://atcoder.jp/contests/cpsco2019-s1/submissions/7488225\n    # \u691c\u8a3c3 (add, search_higher, search_lower) Second Sum: https://atcoder.jp/contests/abc140/submissions/7485479\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.square = square\n        if values is None:\n            self.rand_y = seed\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y ^= (y & 0x7ffff) << 13\n                y ^= y >> 17\n                y ^= (y & 0x7ffffff) << 5\n                if y % square == 0:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer1.append(inf)\n            layer0.append(l0)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        # xorshift\n        y = self.rand_y\n        y ^= (y & 0x7ffff) << 13\n        y ^= y >> 17\n        y ^= (y & 0x7ffffff) << 5\n        self.rand_y = y\n\n        if y % self.square == 0:\n            layer1, layer0 = self.layer1, self.layer0\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044  # dict \u5fae\u5999\u3060\u3063\u305f\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(self.layer1, x)\n            insort_right(self.layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        idx1 = bisect_left(self.layer1, x)\n        layer0_idx1 = self.layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del self.layer1[idx1]\n            self.layer0[idx1] += self.layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        idx1 = bisect_left(self.layer1, x)\n        layer0_idx1 = self.layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return self.layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        idx1 = bisect_right(self.layer1, x)\n        layer0_idx1 = self.layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return self.layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        idx1 = bisect_left(self.layer1, x)\n        layer0_idx1 = self.layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return self.layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "n = int(input())\np = [int(i) for i in input().split()]\n\npos_list = [0] * n\nfor ind, i in enumerate(p):\n\tpos_list[i-1] = ind\n\nleft_nextInd = list(range(-1, n-1)) + [-1, -1]\nright_nextInd = list(range(1, n+1)) + [n, n]\n\nanswer = 0\nfor i in range(1, n):\n\tind = pos_list[i-1]\n\tl1 = left_nextInd[ind]\n\tl2 = left_nextInd[l1]\n\tr1 = right_nextInd[ind]\n\tr2 = right_nextInd[r1]\n\n\tanswer += i * ((ind-l1) * (r2-r1) + (r1-ind) * (l1-l2))\n\n\tleft_nextInd[r1] = l1\n\tright_nextInd[l1] = r1\nprint(answer)", "n = int(input())\np = list(map(int, input().split()))\nlis = [0] * (n + 1)\nfor i in range(n):\n    lis[p[i]] = i\nl = list(range(-1, n - 1)) + [-1, -1]\nr = list(range(1, n + 1)) + [n, n]\nans = 0\nfor i in range(n):\n    ans += (i + 1) * ((lis[i + 1] - l[lis[i + 1]]) * (r[r[lis[i + 1]]] - r[lis[i + 1]]) + (l[lis[i + 1]] - l[l[lis[i + 1]]]) * (r[lis[i + 1]] - lis[i + 1]))\n    r[l[lis[i + 1]]] = r[lis[i + 1]]\n    l[r[lis[i + 1]]] = l[lis[i + 1]]\nprint(ans)", "n = int(input())\np = list(map(int, input().split()))\n\npos_list = [0] * n\n# print(index_list) [0, 0, 0, 0] n = 4 \u306e\u3068\u304d\nfor index, i in enumerate(p, 0):\n    # print(index, i)\n    pos_list[i - 1] = index\n    # print(index_list)\n\nleft_next_index = list(range(-1, n-1)) + [-1, -1]\nright_next_index = list(range(1, n+1)) + [n, n]\n\nanswer = 0\n# print(left_next_index)    [-1, 0, 1, -1, -1]\n# print(right_next_index)   [1, 2, 3, 3, 3]\nfor i in range(1, n):\n    index = pos_list[i-1]\n    l1 = left_next_index[index]\n    l2 = left_next_index[l1]\n    r1 = right_next_index[index]\n    r2 = right_next_index[r1]\n    # print(index, l1, l2, r1, r2, i)\n    answer += i * ((index-l1) * (r2-r1) + (r1-index) * (l1-l2))\n\n    left_next_index[r1] = l1\n    right_next_index[l1] = r1\n\nprint(answer)", "class UnionFind :\n    def __init__(self, size) :\n        self.parent = list(range(size))\n        self.height = [0] * size\n        self.size = [1] * size\n        self.component = size\n\n    def root(self, index) :\n        if self.parent[index] == index :  # \u6839\u306e\u5834\u5408\n            return index\n        rootIndex = self.root(self.parent[index])  # \u8449\u306e\u5834\u5408\u89aa\u306e\u6839\u3092\u53d6\u5f97\n        self.parent[index] = rootIndex  # \u89aa\u306e\u4ed8\u3051\u76f4\u3057\n        return rootIndex\n\n    def union(self, index1, index2) :  # \u7d50\u5408\n        root1 = self.root(index1)\n        root2 = self.root(index2)\n\n        if root1 == root2 :  # \u9023\u7d50\u3055\u308c\u3066\u3044\u308b\u5834\u5408\n            return\n\n        self.component -= 1  # \u9023\u7d50\u6210\u5206\u3092\u6e1b\u3089\u3059\n\n        if self.height[root1] < self.height[root2] :\n            self.parent[root1] = root2  # root2\u306b\u7d50\u5408\n            self.size[root2] += self.size[root1]\n        else :\n            self.parent[root2] = root1  # root1\u306b\u7d50\u5408\n            self.size[root1] += self.size[root2]\n            if self.height[root1] == self.height[root2] :\n                self.height[root1] += 1\n        return\n\n    def isSameRoot(self, index1, index2) :\n        return self.root(index1) == self.root(index2)\n\n    def sizeOfSameRoot(self, index) :\n        return self.size[self.root(index)]\n\n    def getComponent(self) :\n        return self.component\n\nN = int(input())\nINF = 10**18\nP = list(map(int, input().split()))\nI = [-1] * (N + 1)\ntree = UnionFind(N + 2)\n\nfor i, p in enumerate(P, start=1):\n    I[p] = i\n\nans = 0\nused = [False] * (N + 2)\nfor p in range(1, N):\n    i = I[p]\n\n    # p \u672a\u6e80\u306e\u7bc4\u56f2 [i - left, i + right]\n    left = tree.sizeOfSameRoot(i - 1) if used[i - 1] else 0\n    right = tree.sizeOfSameRoot(i + 1) if used[i + 1] else 0\n\n    cnt = 0\n    leftMx = i - (left + 1)\n    if leftMx >= 1 and not used[leftMx]:\n        L = tree.sizeOfSameRoot(leftMx - 1) if (leftMx - 1) >= 0 and used[leftMx - 1] else 0\n        cnt += (L + 1) * (right + 1)\n    rightMx = i + (right + 1)\n    if rightMx <= N and not used[rightMx]:\n        R = tree.sizeOfSameRoot(rightMx + 1) if (rightMx + 1) <= N and used[rightMx + 1] else 0\n        cnt += (left + 1) * (R + 1)\n    ans += cnt * p\n\n    used[i] = True\n    if used[i - 1]:\n        tree.union(i, i - 1)\n    if used[i + 1]:\n        tree.union(i, i + 1)\nprint(ans)\n", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = [inf]\n            self.layer0 = {inf: []}\n        else:\n            self.layer1 = layer1 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self._rand_depth\n            l0 = []\n            layer0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n            self.layer0 = dict(zip([inf]+layer1, layer0))\n            layer1.append(inf)\n\n    def _rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        return y % self.square == 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        if self._rand_depth():\n            idx1 = bisect_right(layer1, x)\n            val1 = layer1[idx1-1]\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[val1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0[x] = layer0_idx1[idx0:]\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            val1 = layer1[idx1-1]\n            insort_right(layer0[val1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        raise NotImplementedError\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del layer1[idx1]\n            layer0[idx1] += layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        raise NotImplementedError\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        val1 = layer1[idx1-1]\n        layer0_idx1 = layer0[val1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        val1 = layer1[idx1-1]\n        layer0_idx1 = layer0[val1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        raise NotImplementedError\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(*sorted(list(self.layer0.items())), sep=\"\\n\")\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList(square=int(n**0.5))\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != float(\"inf\"):\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != float(\"inf\"):\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "#!/usr/bin/env python3\nN=int(input())\np=list(map(int,input().split()))\nLL = [0] + [i for i in range(N+1)]\nRR = [i+1 for i in range(N+1)] + [N+1]\nE = [(v, i+1) for i, v in enumerate(p)]\nE.sort()\nans=0\nfor v, i in E:\n  r0 = RR[i]\n  r1 = RR[r0]\n  l0 = LL[i]\n  l1 = LL[l0]\n  RR[l0] = r0\n  LL[r0] = l0\n\n  ans += ((r1 - r0)*(i-l0)+(r0-i)*(l0 - l1))*v\n\nprint(ans)\n", "n = int(input())\nlst = list(enumerate(list(map(int, input().split()))))\n \nsorted_lst = sorted(lst, key = lambda x: x[1])\nleft_next_index = list(range(-1, n - 1)) + [-1, -1]\nright_next_index = list(range(1, n + 1)) + [n, n]\n \nans = 0\nfor i, p in sorted_lst:\n    l2 = left_next_index[i]\n    l1 = left_next_index[l2]\n    r1 = right_next_index[i]\n    r2 = right_next_index[r1]\n    \n    a = p * ((l2 - l1) * (r1 - i) + (r2 - r1) * (i - l2))\n    ans += a\n    \n    left_next_index[r1] = l2\n    right_next_index[l2] = r1\nprint(ans)", "from collections import deque\n#from heapq import heapify, heappop, heappush\nfrom bisect import bisect_left\n#from math import gcd\n#from decimal import Decimal\n#mod = 1000000007\n#mod = 998244353\nN = int(input())\n#N, K = map(int, input().split())\nP = list(map(int, input().split()))\n#flag = True\nbig = []\nfor k in range(N):\n  big.append((P[k], k+1))\nbig.sort(key=lambda x: x[0], reverse=True)\nbig = deque(big)\nitem = big.popleft()\ndone = [0,0,item[1],N+1,N+1]\nans = 0\nwhile big:\n  item = big.popleft()\n  index = item[1]\n  num = item[0]\n  i = bisect_left(done, index)\n  done.insert(i, index)\n  ans += num*((done[i+2]-done[i+1])*(index - done[i-1])+ (done[i-1]-done[i-2])*(done[i+1]-index))\nprint(ans)\n#print('Yes')\n#print('No')\n", "N = int(input())\n*p, = map(int, input().split())\n\nLL = [0] + [i for i in range(N+1)]\nRR = [i+1 for i in range(N+1)] + [N+1]\n\nE = [(v,i+1) for i,v in enumerate(p)]\nE.sort()\n\nans = 0\nfor v,i in E:\n  r0 = RR[i]; r1 = RR[r0]\n  l0 = LL[i]; l1 = LL[l0]\n  RR[l0] = r0; LL[r0] = l0\n  \n  ans += ((r1 - r0)*(i-l0)+(r0-i)*(l0 - l1))*v\n\nprint(ans)", "N = int(input())\nP_id = [0]*(N + 1) # P_id[i]\u306f\u9806\u5217P\u306b\u7f6e\u3051\u308bi\u306eindex, P[0]\u306f\u7121\u8996\nfor index, p in enumerate(map(int, input().split())):\n    P_id[p] = index\n\nleft_next_index = list(range(- 1, N - 1)) + ['\u3046\u3093\u3053', - 1] # + [- 1]\u3067\u306f\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f, left_next_index[r1] = l1\u306b\u304a\u3044\u3066r1 = N\u306e\u5834\u5408\u304c\u3042\u308b\u304b\u3089\nright_next_index = list(range(1, N + 1)) + [N, '\u3046\u3093\u3053']\n\nres = 0\nfor p in range(1, N):\n    l1 = left_next_index[P_id[p]]\n    l2 = left_next_index[l1]\n    r1 = right_next_index[P_id[p]]\n    r2 = right_next_index[r1]\n    \n    res += p*((l1 - l2)*(r1 - P_id[p]) + (P_id[p] - l1)*(r2 - r1))\n    \n    left_next_index[r1] = l1\n    right_next_index[l1] = r1\n    \nprint(res)", "n = int(input())\nP = list(map(int, input().split()))\n\nnum_idx = [0]*(n+1)\n\n# \u81ea\u5206\u306eidx\u304b\u3089\u307f\u3066\u53f3\u5074\u3067\uff0c\u81ea\u8eab\u306e\u5024\u3088\u308a\u5927\u304d\u306a\u5024\u3092\u3082\u3064\uff0c\u4e00\u756a\u8fd1\u3044idx\nright_idx_over_current_pos = list(range(1, n+1)) + [n, n]\n# \u81ea\u5206\u306eidx\u304b\u3089\u307f\u3066\u5de6\u5074\u3067\uff0c\u81ea\u8eab\u306e\u5024\u3088\u308a\u5927\u304d\u306a\u5024\u3092\u3082\u3064\uff0c\u4e00\u756a\u8fd1\u3044idx\nleft_idx_over_current_pos = list(range(-1, n-1)) + [-1, -1]\n\n# 1\u304b\u3089\u898b\u3066\u3044\u304f\u3068\u3059\u308b\u3068\uff0c\u4e0a\u8a182\u3064\u3068\u3082\uff0c\u81ea\u5206\u306e\u3059\u3050\u96a3\u306eidx\u304c\u305d\u306e\u307e\u307e\u8a72\u5f53\u3059\u308b\n\nfor idx, num in enumerate(P):\n    num_idx[num] = idx\n\nans = 0\nfor num in range(1, n+1):  # \u5c0f\u3055\u3044\u307b\u3046\u304b\u3089\u6c7a\u3081\u308b\n    now = num_idx[num]\n    r1 = right_idx_over_current_pos[now]\n    r2 = right_idx_over_current_pos[r1]\n    l1 = left_idx_over_current_pos[now]\n    l2 = left_idx_over_current_pos[l1]\n\n    r_pattern = (r2-r1) * (now-l1)\n    l_pattern = (l1-l2) * (r1-now)\n\n    right_idx_over_current_pos[l1] = r1  # l1\u306b\u3042\u308b\u5024 > now\u304b\u3089r1\u307e\u3067\u306b\u3042\u308b\u5024 \u306a\u306e\u3067 now\u3092\u30b9\u30ad\u30c3\u30d7\u3057\u3066 r1\u307e\u3067\u3044\u3051\u308b\n    left_idx_over_current_pos[r1] = l1  # \u4e0a\u306e\u5de6\u5411\u304dver\n    ans += (r_pattern + l_pattern) * num\n\nprint(ans)\n", "from time import time\nfrom statistics import median\nfrom bisect import bisect_left, bisect_right\nfrom random import random, sample\n\n\nclass TwoLayerSet:\n    def __init__(self, p):\n        self.top = []\n        self.bottom = [[]]\n        self.p = p\n\n    def insert(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            return False\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            return False\n        if random() < self.p:\n            top.insert(top_i, key)\n            bottom[top_i] = block[block_i:]\n            bottom.insert(top_i, block[:block_i])\n        else:\n            block.insert(block_i, key)\n        return True\n\n    def erase(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            top.pop(top_i)\n            bottom[top_i].extend(bottom.pop(top_i+1))\n            return True\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            block.pop(block_i)\n            return True\n        return False\n\n    def less(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def less_equal(self, key):\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def greater(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n    def greater_equal(self, key):\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = TwoLayerSet(1/1000)\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.greater(i)\n        nexnex = t.greater(nex)\n        pre = t.less(i)\n        prepre = t.less(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "N = int(input())\n*P, = map(int, input().split())\n\nLL = [0] + [i for i in range(N+1)]\nRR = [i+1 for i in range(N+1)] + [N+1]\n\nE = [(v, i+1) for i, v in enumerate(P)]\nE.sort()\n\nans = 0\nfor v, i in E:\n    l0 = LL[i]; l1 = LL[l0]\n\n    r0 = RR[i]; r1 = RR[r0]\n\n    LL[RR[i]], RR[LL[i]] = LL[i], RR[i]\n\n    ans += ((r1 - r0) * (i - l0) + (r0 - i) * (l0 - l1)) * v\nprint(ans)", "#!/usr/bin/env python3\nans=0\nn=int(input())\np=list(map(int,input().split()))\nb=[0]*(n+1)\nfor i in range(n):\n    b[p[i]]=i+1\nLL=[0]+[i for i in range(n+1)]\nRR=[i for i in range(1,n+2)]+[n+1]\nfor i in range(1,n+1):\n    l1=LL[b[i]]\n    l0=LL[l1]\n    r0=RR[b[i]]\n    r1=RR[r0]\n    ans+=((l1-l0)*(r0-b[i])+(r1-r0)*(b[i]-l1))*i\n    LL[r0]=l1\n    RR[l1]=r0\n\nprint(ans)\n", "from operator import itemgetter\n\n\ndef solve(n, ppp):\n    qqq = sorted(enumerate(ppp), key=itemgetter(1))\n    left_next_index = list(range(-1, n - 1)) + [-1, -1]\n    right_next_index = list(range(1, n + 1)) + [n, n]\n    ans = 0\n    for i, p in qqq:\n        l2 = left_next_index[i]\n        l1 = left_next_index[l2]\n        r1 = right_next_index[i]\n        r2 = right_next_index[r1]\n        ans += p * ((l2 - l1) * (r1 - i) + (r2 - r1) * (i - l2))\n        left_next_index[r1] = l2\n        right_next_index[l2] = r1\n    return ans\n\n\nn = int(input())\nppp = list(map(int, input().split()))\nprint((solve(n, ppp)))\n", "import sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnl = lambda: list(map(int, stdin.readline().split()))\nnm = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()\n\nn = ni()\np = nl()\nq = [0]*(n+1)\nfor i in range(n):\n    q[p[i]] = i+1\n    \nans = 0\nl = [0] + [i for i in range(n+1)]\nr = [i+1 for i in range(n+1)] + [n+1]\n\nfor i in range(1,n+1):\n    v = q[i]\n    l1,r1 = l[v],r[v]\n    l2,r2 = l[l1],r[r1]\n    ans += i*((v-l1)*(r2-r1) + (r1-v)*(l1-l2))\n    l[r1] = l1\n    r[l1] = r1\n  \nprint(ans)\n", "3\n\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, P):\n    revp = [-1] * (N + 1)\n    for i, p in enumerate(P):\n        revp[p] = i\n\n    segt = [[(v, 0) for v in P]]\n    while len(segt[-1]) > 1:\n        base = segt[-1]\n        if len(base) % 2 == 1:\n            base.append((0, 0))\n        new = []\n        for i in range(len(base) // 2):\n            a, b = base[2 * i]\n            c, d = base[2 * i + 1]\n\n            arr = [a, b, c, d]\n            arr.sort()\n            new.append((arr[-1], arr[-2]))\n        segt.append(new)\n\n    dprint('segt', segt)\n\n    def get12(i, j):\n        if j - i <= 0:\n            return (0, 0)\n\n        segi = 0\n        top = []\n\n        while True:\n            if j - i <= 0:\n                break\n\n            seg = segt[segi]\n\n            if j - i == 1:\n                top.extend(seg[i])\n                break\n\n            if i % 2 == 1:\n                top.extend(seg[i])\n                i += 1\n            if j % 2 == 1:\n                top.extend(seg[j - 1])\n                j -= 1\n\n            i //= 2\n            j //= 2\n            segi += 1\n\n        top.sort()\n        return top[-1], top[-2]\n\n    cache = [dict() for _ in range(N)]\n\n    stk = [(0, N)]\n    while stk:\n        item = stk.pop()\n        if len(item) == 2:\n            i, j = item\n            if j in cache[i]:\n                continue\n\n            a, b = get12(i, j)\n            ai = revp[a]\n            bi = revp[b]\n            li, ri = (ai, bi) if ai < bi else (bi, ai)\n            ri += 1\n\n            sc = b * (li - i + 1) * (j - ri + 1)\n\n            want = [(i, ri - 1), (li + 1, j), (li + 1, ri - 1)]\n            req = []\n            for c, d in want:\n                if not (d - c < 2 or d in cache[c]):\n                    req.append((c, d))\n            if not req:\n                left, right, mid = [0 if d - c < 2 else cache[c][d]\n                                    for c, d in want]\n                cache[i][j] = left + right - mid + sc\n                continue\n\n            stk.append((i, j, want, sc))\n            for r in req:\n                stk.append(r)\n            continue\n\n        i, j, want, sc = item\n        left, right, mid = [0 if d - c < 2 else cache[c][d]\n                            for c, d in want]\n        cache[i][j] = left + right - mid + sc\n\n    return cache[0][N]\n\n\ndef main():\n    N = int(inp())\n    P = [int(e) for e in inp().split()]\n    print(solve(N, P))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\naa = list(map(int, input().split()))\nans = 0\npos = [0] * (n + 1)\n\nfor i, a in enumerate(aa):\n    pos[a] = i + 2\nLnext = [1, 1] + list(range(1, n + 1)) + [n, n]\nRnext = [3, 3] + list(range(3, n + 3)) + [n + 2, n + 2]\nfor a in range(1,n + 1):\n    i = pos[a]\n    l0 = Lnext[i]\n    l1 = Lnext[l0]\n    r0 = Rnext[i]\n    r1 = Rnext[r0]\n    ans += a * ((l0 - l1) * (r0 - i) + (i - l0) * (r1 - r0))\n    Lnext[r0] = l0\n    Rnext[l0] = r0\nprint(ans)", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (\u30c7\u30fc\u30bf\u69cb\u9020): https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (Exclusive OR Queries): https://atcoder.jp/contests/cpsco2019-s1/submissions/7479914\n    # \u691c\u8a3c3 (Second Sum): https://atcoder.jp/contests/abc140/submissions/7480312\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = []\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n        self.layer1.append(inf)\n\n    def rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        return y % self.square == 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        if self.rand_depth():\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_right(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        #res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 res \u3067\u57cb\u307e\u3063\u3066\u3044\u308b\u5834\u5408\n            return layer1[idx1-1]\n        else:\n            return layer0_idx1[idx0-1]\n        # if res != x:  # res > x\n        #     if layer0_idx1:\n        #         idx0 = bisect_left(layer0_idx1, x)\n        #         if idx0 != 0:\n        #             return layer0_idx1[idx0-1]\n        #     return layer1[idx1-1]  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n        # else:\n        #     idx0 = bisect_left(layer0_idx1, x)\n        #     if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 res \u3067\u57cb\u307e\u3063\u3066\u3044\u308b\u5834\u5408\n        #         return layer1[idx1-1]\n        #     else:\n        #         return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081  \u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != float(\"inf\"):\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != float(\"inf\"):\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "N = int(input())\nP = list(map(int, input().split()))\n \nleft_bigger  = [0] + [i for i in range(N+1)]\nright_bigger = [i+1 for i in range(N+1)] + [N+1]\n \nE = [(v, i+1) for i, v in enumerate(P)]\nE.sort()\n\nans = 0\nfor v,i in E:\n    l0=left_bigger[i]\n    l1=left_bigger[l0]\n    r0=right_bigger[i]\n    r1=right_bigger[r0]\n    ans += ((r1-r0)*(i-l0) + (r0-i)*(l0-l1))*v\n    left_bigger[r0]=l0\n    right_bigger[l0]=r0\nprint(ans)\n\n\n", "# \u53c2\u8003 https://atcoder.jp/contests/abc140/submissions/7411285\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input()[:-1])\n    aa = list(map(int, input().split()))\n    ans = 0\n    pos = [0] * (n + 1)\n    for i, a in enumerate(aa):\n        pos[a] = i + 2\n    Lnext = [1, 1] + list(range(1, n + 1)) + [n, n]\n    Rnext = [3, 3] + list(range(3, n + 3)) + [n + 2, n + 2]\n    for a in range(1,n + 1):\n        i = pos[a]\n        l0 = Lnext[i]\n        l1 = Lnext[l0]\n        r0 = Rnext[i]\n        r1 = Rnext[r0]\n        ans += a * ((l0 - l1) * (r0 - i) + (i - l0) * (r1 - r0))\n        Lnext[r0] = l0\n        Rnext[l0] = r0\n    print(ans)\n\nmain()\n", "from bisect import bisect_left\nimport array\n\nn = int(input())\np = []\n\nfor i, x in enumerate(map(int, input().split())):\n    p.append([x, i])\n\np.sort(reverse=True)\n\ns = array.array('i', [-1, -1, p[0][1], n, n])\n\n#print(p)\n\nans = 0\ni = 2\nfor a, x in p[1:]:\n    t = bisect_left(s, x)\n    ans += a * ((x - s[t-1]) * (s[t+1] - s[t]) + (s[t] - x) * (s[t-1] - s[t-2]))\n    #print(t, s)\n    s.insert(t, x)\n    i += 1\n\n\nprint(ans)\n\n\n", "N = int(input())\nP = list(map(int, input().split()))\nR = list(range(N))\nL = list(range(N))\nI = [-1] * (N+1)\nfor i, p in enumerate(P):\n    I[p] = i\n\nans = 0\nfor n, idx in enumerate(I[1:], 1):\n    #print(f\"n={n}, idx={idx}\")\n    l = idx-1\n    while l>=0 and l!=L[l]:\n        l = L[l]\n    r = idx+1\n    while r<N and r!=R[r]:\n        r = R[r]\n    L[idx] = l\n    R[idx] = r\n\n    if l != -1:\n        l2 = l-1\n        while l2>=0 and l2!=L[l2]:\n            l2 = L[l2]\n        #print(f\"n * (l-l2) * (r-idx) = {n * (l-l2) * (r-idx)}\")\n        #print(l, l2)\n        ans += n * (l-l2) * (r-idx)\n        #L[l] = l2\n    if r != N:\n        r2 = r+1\n        while r2<N and r2!=R[r2]:\n            r2 = R[r2]\n        #print(f\"n * (idx-l) * (r2-r) = {n * (idx-l) * (r2-r)}\")\n        ans += n * (idx-l) * (r2-r)\n        #R[r] = r2\nprint(ans)\n", "# https://atcoder.jp/contests/abc140/submissions/7411285\n# \u5199\u7d4c\n\ndef main():\n    N = int(input())\n    *p, = list(map(int, input().split()))\n\n    xtoi = [-1] * (N + 1)\n    for i, x in enumerate(p):\n        xtoi[x] = i\n\n    L = [-1] * (N + 2)\n    R = [N] * (N + 2)\n    for i in range(N):\n        L[i] = i - 1\n        R[i] = i + 1\n\n    iter_inds = iter(xtoi)\n    next(iter_inds)\n\n    ans = 0\n    for x, ind in enumerate(iter_inds, start=1):\n        # l2, ..., l1, ..., x, ..., r1, ..., r2\n        # (l2,r1) or (l1,r2)\n        l1 = L[ind]\n        l2 = L[l1]\n        r1 = R[ind]\n        r2 = R[r1]\n        ans += x * ((l1 - l2) * (r1 - ind) + (r2 - r1) * (ind - l1))\n        L[r1] = l1\n        R[l1] = r1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class Node:\n    def __init__(self,  key=None):\n\n        self.key = key\n        self.height = 1\n        self.parent = None\n        self.left = None\n        self.right = None\n\n\ndef update_height(t):\n    if t.left is not None:\n        l = t.left.height\n    else:\n        l = 0\n    if t.right is not None:\n        r = t.right.height\n    else:\n        r = 0\n    \n    if l >= r:\n        t.height = l + 1\n    else:\n        t.height = r + 1\n\n\nclass AVL:\n    def __init__(self):\n        self.root = Node()       \n    \n    def insert(self, key):\n        #\u5024\u306e\u633f\u5165\n        if self.root.key is None:\n            self.root.key = key\n            return\n        cursor = self.root\n        while cursor:\n            p = cursor\n            if key == cursor.key:\n                return\n            elif key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        new_node = Node(key)\n        new_node.parent = p\n        if key < p.key:\n            p.left = new_node\n        else:\n            p.right = new_node\n\n        #\u30d0\u30e9\u30f3\u30b9\u306e\u78ba\u8a8d\n        cursor = p\n        while cursor:\n            if cursor.left is not None:\n                l = cursor.left.height\n            else:\n                l = 0\n            if cursor.right is not None:\n                r = cursor.right.height\n            else:\n                r = 0\n            balance = l - r\n            \n            if balance == 0:\n                break\n            elif balance == 2:\n                if key < cursor.left.key:\n                    self.rotate_r(cursor)\n                else:\n                    self.rotate_lr(cursor)\n                break\n            elif balance == -2:\n                if key > cursor.right.key:\n                    self.rotate_l(cursor)\n                else:\n                    self.rotate_rl(cursor)\n                break\n            else:\n                update_height(cursor)\n                cursor = cursor.parent\n           \n    def rotate_r(self, n):\n        p = n.parent\n        c = n.left\n        gc = n.left.right\n        \n        if gc is not None:\n            n.left = gc\n            gc.parent = n\n        else:\n            n.left = None\n            \n        c.right = n\n        n.parent = c\n        \n        if p is not None:    \n            if p.right == n:\n                p.right = c\n            else:\n                p.left = c\n            c.parent = p\n        else:\n            self.root = c\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)\n    \n    def rotate_l(self, n):\n        p = n.parent\n        c = n.right\n        gc = n.right.left\n        \n        if gc is not None:\n            n.right = gc\n            gc.parent = n\n        else:\n            n.right = None\n            \n        c.left = n\n        n.parent = c\n        \n        if p is not None:\n            if p.left == n:\n                p.left = c\n            else:\n                p.right = c\n            c.parent = p\n        else:\n            self.root = c\n            self.root.parent = None\n        \n        update_height(n)\n        update_height(c)              \n        \n    def rotate_rl(self, n):\n        \n        p = n.parent\n        c = n.right\n        gc = n.right.left\n        \n        if gc.left and gc.right:\n            n.right = gc.left\n            c.left = gc.right\n            gc.left.parent = n\n            gc.right.parent = c\n        elif gc.left:\n            n.right = gc.left\n            gc.left.parent = n\n            c.left = None\n        elif gc.right:\n            c.left = gc.right\n            gc.right.parent = c\n            n.right = None\n        else:\n            n.right = None\n            c.left = None\n            \n        gc.left = n\n        gc.right = c\n        n.parent = gc\n        c.parent = gc\n        \n        if p is not None:\n            if p.left == n:\n                p.left = gc\n            else:\n                p.right = gc\n            gc.parent = p\n        else:\n            self.root = gc\n            self.root.parent = None\n\n        update_height(n)\n        update_height(c)\n        update_height(gc)        \n        \n    def rotate_lr(self, n):\n        p = n.parent\n        c = n.left\n        gc = n.left.right\n        \n        if gc.left and gc.right:\n            c.right = gc.left\n            n.left = gc.right\n            gc.left.parent = c\n            gc.right.parent = n\n        elif gc.left:\n            c.right = gc.left\n            gc.left.parent = c\n            n.left = None\n        elif gc.right:\n            n.left = gc.right\n            gc.right.parent = n\n            c.right = None\n        else:\n            n.left = None\n            c.right = None\n        gc.left = c\n        gc.right = n\n        c.parent = gc\n        n.parent = gc\n        \n        if p is not None:\n            if p.left == n:\n                p.left = gc\n            else:\n                p.right = gc\n            gc.parent = p\n        else:\n            self.root = gc\n            self.root.parent = None\n            \n        update_height(n)\n        update_height(c)\n        update_height(gc)    \n        \n    def find(self, key):\n        cursor = self.root\n        while cursor:\n            if cursor.key == key:\n                return cursor\n            if key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        return None\n    \n    def next_greater_key(self, cursor):\n        if cursor is None:\n            return None\n        if cursor.right:\n            cursor = cursor.right\n            while cursor.left:\n                cursor = cursor.left\n            return cursor\n        elif cursor.parent.left == cursor:\n            return cursor.parent\n        elif cursor.parent.right == cursor:\n            while cursor.parent and cursor.parent.right == cursor:\n                cursor = cursor.parent\n            if cursor.parent:\n                return cursor.parent\n        else:\n            return None\n        \n    def next_smaller_key(self, cursor):\n        if cursor is None:\n            return None\n        if cursor.left:\n            cursor = cursor.left\n            while cursor.right:\n                cursor = cursor.right\n            return cursor\n        elif cursor.parent.right == cursor:\n            return cursor.parent\n        elif cursor.parent.left == cursor:\n            while cursor.parent and cursor.parent.left == cursor:\n                cursor = cursor.parent\n            if cursor.parent:\n                return cursor.parent              \n        else:\n            return None\n        \n    def get_smaller_key(self, key):\n        cursor = self.find(key)\n        l1 = self.next_smaller_key(cursor)\n        l2 = self.next_smaller_key(l1)\n        if l2 is None:\n            l2 = 0\n        else:\n            l2 = l2.key\n        return l1.key, l2\n    \n    def get_greater_key(self, key):\n        cursor = self.find(key)\n        r1 = self.next_greater_key(cursor)\n        r2 = self.next_greater_key(r1)\n        if r2 is None:\n            r2 = 0\n        else:\n            r2 = r2.key\n        return r1.key, r2\n\n\ndef main():\n\n    N = int(input())\n    P = map(int, input().split())\n    \n    idx = [-1] * (N + 1)\n    for i, v in enumerate(P, 1):\n        idx[v] = i\n    avl = AVL()\n    for i in [0, idx[N], N+1]:\n        avl.insert(i)\n    total = 0\n    for j in range(N - 1, 0, -1):\n        n = idx[j]\n        avl.insert(n)\n        \n        l1_idx , l2_idx = avl.get_smaller_key(n)\n        l1 = n - l1_idx\n        if l1_idx != 0:\n            l2 = l1_idx - l2_idx\n        else:\n            l2 = 0\n            \n        r1_idx, r2_idx = avl.get_greater_key(n)\n        r1 = r1_idx - n\n        if r1_idx != N + 1:\n            r2 = r2_idx - r1_idx\n        else:\n            r2 = 0\n            \n        cnt = (l1 * r2 + r1 * l2) * j\n        total += cnt\n    \n    print(total)\n    \ndef __starting_point():\n    main()\n__starting_point()", "\nn = int(input())\np = list(map(int,input().split()))\n\nr = list(range(n))\nl = list(range(n))\nI = [-1] * (n+1)\n\nfor i,P in enumerate(p):\n\tI[P] = i\n#I[1~N\u307e\u3067\u306e\u6570\u5b57] = 0,1,...\n#index \u3092\u6c42\u3081\u3066\u3044\u308b\nans  = 0\n\nfor N,index in enumerate(I[1:],1):#1\u304b\u3089\u30b9\u30bf\u30fc\u30c8\n\tL = index -1\n\tif L >= 0:\n\t\tL = l[L]\n\n\tR = index + 1\n\tif  R < n:\n\t\tR = r[R]\n\n\tl[R-1] = L\n\tr[L+1] = R\n#0 <= L , R < n\n\tif L >= 0:\n\t\tL2 = L-1\n\t\tif L2 >= 0:\n\t\t\tL2 = l[L2]\n\t\tans += N * (L-L2) * (R - index)\n\n\tif R < n:\n\t\tR2 = R+1\n\t\tif R2 < n:\n\t\t\tR2 = r[R2]\n\t\tans += N * (index - L ) * (R2 - R)\nprint(ans)\n", "n=int(input())\np=list(map(int,input().split()))\nl=[0]+[i for i in range(n+1)]\nr=[i+1 for i in range(n+1)]+[n+1]\nd=[0]*(n+1)\nfor i in range(n):d[p[i]]=i+1\nans=0\nfor i in range(1,n+1):\n  ans+=((r[r[d[i]]]-r[d[i]])*(d[i]-l[d[i]])+(r[d[i]]-d[i])*(l[d[i]]-l[l[d[i]]]))*i\n  l[r[d[i]]],r[l[d[i]]]=l[d[i]],r[d[i]]\nprint(ans)", "import sys\ninput=sys.stdin.readline\nn=int(input())\na=[int(j) for j in input().split()]\nans=0\nind=[0]*(n+1)\nfor i in range(n):\n    ind[a[i]]=i+1\nl=[0]+list(range(n+1))\nr=list(range(1,n+2))+[n+1]\nfor i in range(1,n+1):\n    l1=l[ind[i]]\n    l0=l[l1]\n    r0=r[ind[i]]\n    r1=r[r0]\n    ans+=((l1-l0)*(r0-ind[i])+(r1-r0)*(ind[i]-l1))*i\n    l[r0]=l1\n    r[l1]=r0\n\nprint(ans)", "import bisect\n\nn=int(input())\np=[int(x)-1 for x in input().split()]\n\np2=sorted(enumerate(p), key=lambda x:x[1], reverse=True)  \n\nans=0\ns=[-1,-1,n,n]\nfor i,(idx,p) in enumerate(p2):\n  t=bisect.bisect_left(s,idx)\n  s.insert(t,idx)\n  l1=s[t-1]\n  l2=s[t-2]\n  r1=s[t+1]\n  r2=s[t+2]\n  ans+=(p+1)*((idx-l1)*(r2-r1)+(r1-idx)*(l1-l2))\n              \nprint(ans)\n", "from bisect import bisect_left, bisect_right, insort_right\nclass CubeSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 3 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    def __init__(self, values=None, sorted_=False, cube=100, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.cube = cube\n        if values is None:\n            self.layer2 = [inf]\n            self.layer1 = [[]]\n            self.layer0 = [[[]]]\n        else:\n            self.layer2 = layer2 = []\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l1 = []\n            la0 = []\n            l0 = []\n            for v in values:\n                r = rand_depth()\n                if r==0:\n                    l0.append(v)\n                elif r==1:\n                    la0.append(l0)\n                    l0 = []\n                    l1.append(v)\n                else:\n                    la0.append(l0)\n                    layer0.append(la0)\n                    layer1.append(l1)\n                    l0 = []\n                    la0 = []\n                    l1 = []\n                    layer2.append(v)\n            la0.append(l0)\n            layer0.append(la0)\n            layer1.append(l1)\n            layer2.append(inf)\n\n    def rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        if y % self.cube == 0:\n            if y % (self.cube ** 2) == 0:\n                return 2\n            return 1\n        return 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(cbrt(n))\n        layer2, layer1, layer0 = self.layer2, self.layer1, self.layer0\n        r = self.rand_depth()\n        if r==0:\n            idx2 = bisect_right(layer2, x)\n            idx1 = bisect_right(layer1[idx2], x)\n            insort_right(layer0[idx2][idx1], x)\n        elif r==1:\n            idx2 = bisect_right(layer2, x)\n            l1 = layer1[idx2]\n            idx1 = bisect_right(l1, x)\n            l1.insert(idx1, x)\n            la0 = layer0[idx2]\n            l0 = la0[idx1]\n            idx0 = bisect_right(l0, x)\n\n            la0.insert(idx1+1, l0[idx0:])\n            del l0[idx0:]\n        else:\n            idx2 = bisect_right(layer2, x)\n            layer2.insert(idx2, x)\n            l1 = layer1[idx2]\n            idx1 = bisect_right(l1, x)\n            la0 = layer0[idx2]\n            l0 = la0[idx1]\n            idx0 = bisect_right(l0, x)\n\n            la0.insert(idx1+1, l0[idx0:])\n            del l0[idx0:]\n            layer0.insert(idx2+1, la0[idx1+1:])\n            del la0[idx1+1:]\n            layer1.insert(idx2+1, l1[idx1:])\n            del l1[idx1:]\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(cbrt(n))\n        raise NotImplementedError\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        raise NotImplementedError\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer2, layer1, layer0 = self.layer2, self.layer1, self.layer0\n        idx2 = bisect_right(layer2, x)\n        l1 = layer1[idx2]\n        idx1 = bisect_right(l1, x)\n        la0 = layer0[idx2]\n        l0 = la0[idx1]\n        idx0 = bisect_right(l0, x)\n        if idx0==len(l0):\n            if idx1==len(l1):\n                return layer2[idx2]\n            return l1[idx1]\n        return l0[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer2, layer1, layer0 = self.layer2, self.layer1, self.layer0\n        idx2 = bisect_left(layer2, x)\n        l1 = layer1[idx2]\n        idx1 = bisect_left(l1, x)\n        la0 = layer0[idx2]\n        l0 = la0[idx1]\n        idx0 = bisect_left(l0, x)\n        if idx0==0:\n            if idx1==0:\n                return layer2[idx2-1]\n            return l1[idx1-1]\n        return l0[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081  \u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        raise NotImplementedError\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer2)\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = CubeSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != float(\"inf\"):\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != float(\"inf\"):\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nP = [None] + [int(x) for x in input().split()]\np_to_i = [None] * (N+1)\nfor i,x in enumerate(P[1:],1):\n    p_to_i[x] = i\n\n# \u5927\u304d\u3044\u6570\u304b\u3089\u633f\u5165\u3057\u3066\u3044\u304f\n# \u5de6\u96a3\u306b\u3042\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n# \u305d\u306e\u305f\u3081\u306b\u3001[1,i]\u5185\u3067\u66f8\u304d\u8fbc\u3093\u3060\u6570\u306e\u500b\u6570\u3092\u7372\u5f97\u3067\u304d\u308bBIT\u3092\u6301\u3064\n\n# BIT\u306f\u4e00\u756a\u6700\u5f8c\u306e1\u30d3\u30c3\u30c8\u306e\u4f4d\u7f6e\u304c\u91cd\u8981\u306a\u306e\u30670\u3067\u306f\u306a\u304f1\u59cb\u307e\u308a\u3002\u305d\u306e\u305f\u3081N\u307e\u3067\u30eb\u30fc\u30d7\u3059\u308b\ndef BIT_add(i):\n    while i <= N:\n        tree[i] += 1\n        i += i&(-i)\n\ndef BIT_sum(i):\n    s = 0\n    while i:\n        s += tree[i]\n        i -= i&(-i)\n    return s\n\ndef BIT_search(x):\n    # \u4e8c\u5206\u63a2\u7d22\u3002\u548c\u304cx\u4ee5\u4e0a\u3068\u306a\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9(>= 1)\u3092\u8fd4\u3059\n    i = 0\n    s = 0\n    step = 1<<(N.bit_length()-1)\n    while step:\n        if i+step <= N and s + tree[i+step] < x:\n            i += step\n            s += tree[i]\n        step >>= 1\n    return i+1\n    left = 0\n    right = N\n    while right - left > 1:\n        mid = (left + right) // 2\n        if BIT_sum(mid) >= x:\n            right = mid\n        else:\n            left = mid\n    return right\n\ntree = [0] * (N+1)\nanswer = 0\nfor x in range(N,0,-1):\n    c = p_to_i[x]\n    L = BIT_sum(c) # \u5de6\u306b\u3042\u308b\u65e2\u306b\u66f8\u304d\u8fbc\u3093\u3060\u6570\u306e\u500b\u6570\n    BIT_add(c)\n    R = N-x-L # \u53f3\u306b\u3042\u308b\u65e2\u306b\u66f8\u304d\u8fbc\u3093\u3060\u6570\u306e\u500b\u6570\n    a = BIT_search(L-1) if L >= 2 else 0\n    b = BIT_search(L) if L >= 1 else 0\n    d = BIT_search(L+2) if R >= 1 else N+1\n    e = BIT_search(L+3) if R >= 2 else N+1\n    coef = 0\n    if b != 0:\n        # [b,c]\u3092\u542b\u3080\u3088\u3046\u306b\u3059\u308b\u3002(a,b) \u3068(c,d)\u304c\u81ea\u7531\n        coef += (b-a) * (d-c)\n    if d != 0:\n        # [c,d]\u3092\u542b\u3080\u3088\u3046\u306b\u3059\u308b\u3002\n        coef += (e-d) * (c-b)\n    answer += x * coef\nprint(answer)\n\n\n\n", "N = int(input())\nP = list(map(int, input().split()))\n\nI = [0] * N\nfor i in range(N):\n    I[P[i]-1] = i\n\nans = 0\nL = [i for i in range(-1, N-1)]\nR = [i for i in range(1, N+1)]\n\nfor p in range(1,N+1):\n    i = I[p-1]\n\n    if R[i] < N:\n        L[R[i]] = L[i]\n    if L[i] >= 0:\n        R[L[i]] = R[i]\n\n    l1 = L[i]\n    l2 = L[l1] if l1 >= 0 else -1\n    r1 = R[i]\n    r2 = R[r1] if r1 < N else N\n    ans += p * ((r1-i)*(l1-l2) + (i-l1)*(r2-r1))\n\nprint(ans)\n", "N = int(input())\nP = list(map(int, input().split()))\nR = list(range(N))\nL = list(range(N))\nI = [-1] * (N+1)\nfor i, p in enumerate(P):\n    I[p] = i\n\nans = 0\nfor n, idx in enumerate(I[1:], 1):\n    l = idx-1\n    if l>=0:\n        l = L[l]\n    r = idx+1\n    if r<N:\n        r = R[r]\n    L[r-1] = l\n    R[l+1] = r\n\n    if l>=0:\n        l2 = l-1\n        if l2>=0:\n            l2 = L[l2]\n        ans += n * (l-l2) * (r-idx)\n    if r<N:\n        r2 = r+1\n        if r2<N:\n            r2 = R[r2]\n        ans += n * (idx-l) * (r2-r)\nprint(ans)\n", "n=int(input())\np=list(map(int,input().split()))\nl=[0]+[i for i in range(n+1)]#l_i...p_i\u3088\u308a\u3082\u5927\u304d\u3044\u3082\u306e\u3067\u3001\u5de6\u5074\u304b\u3064p_i\u306b\u4e00\u756a\u8fd1\u3044\u8981\u7d20\u306eindex\nr=[i+1 for i in range(n+1)]+[n+1]#r_i...l_i\u306e\u53f3\u5074ver\nd=[0]*(n+1)\nfor i in range(n):d[p[i]]=i+1\nans=0\nfor i in range(1,n+1):\n  ans+=((r[r[d[i]]]-r[d[i]])*(d[i]-l[d[i]])+(r[d[i]]-d[i])*(l[d[i]]-l[l[d[i]]]))*i#l_i\u3067\u3067\u4e00\u756a\u8fd1\u3044\u3001l_(l_i)\u3067\u4e8c\u756a\u76ee\u306b\u8fd1\u3044(index\u306e\u5dee\u5206\u53d6\u3063\u3066\u30a2\u30ec\u30b3\u30ec\u8a08\u7b97)\n  l[r[d[i]]],r[l[d[i]]]=l[d[i]],r[d[i]]#\u53f3\u5074(\u5de6\u5074)\u306b\u3042\u308b\u4e00\u756a\u8fd1\u3044\u3082\u306e\u3092\u3001\u81ea\u5206\u3092\u98db\u3073\u8d8a\u3048\u3066\u5de6\u5074(\u53f3\u5074)\u306b\u304f\u3063\u3064\u3051\u308b(\u5927\u5c0f\u6bd4\u8f03\u306f\u3057\u306a\u304f\u3066\u3082\u826f\u304f\u3066\u3001\u3069\u3046\u305b\u5f8c\u3067\u307e\u305f\u66f4\u65b0\u3055\u308c\u308b)\nprint(ans)", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = []\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n        self.layer1.append(inf)\n\n    def rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        return y % self.square == 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0\n        layer1, layer0 = self.layer1, self.layer0\n        if self.rand_depth():\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_right(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        if res != x:  # res > x\n            if layer0_idx1:\n                idx0 = bisect_left(layer0_idx1, x)\n                if idx0 != 0:\n                    return layer0_idx1[idx0-1]\n            return layer1[idx1-1]  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n        else:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 res \u3067\u57cb\u307e\u3063\u3066\u3044\u308b\u5834\u5408\n                return layer1[idx1-1]\n            else:\n                return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))  for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\nN = int(input())\nP = list(map(int,input().split()))\n\nD = {P[i]:i+1 for i in range(N)}\nans = 0\n\nL = SquareSkipList()\nL.add(D[N])\n\nfor i in range(1,N)[::-1]:\n    l = L.search_lower(D[i])\n    h = L.search_higher(D[i])\n    if l == float('inf'):\n        hh = L.search_higher(h)\n        if hh == float('inf'):\n            hh = N+1\n        ans += (D[i]*(hh-h))*i\n    elif h == float('inf'):\n        ll = L.search_lower(l)\n        if ll == float('inf'):\n            ll = 0\n        ans += ((N+1-D[i])*(l-ll))*i\n    else:\n        hh = L.search_higher(h)\n        if hh == float('inf'):\n            hh = N+1\n        ll = L.search_lower(l)\n        if ll == float('inf'):\n            ll = 0\n        ans += ((h-D[i])*(l-ll)+(D[i]-l)*(hh-h))*i\n    L.add(D[i])\n    \nprint(ans)", "# \u52dd\u3066\u306a\u3044 \u3064\u3089\u3044\n# Python \u306e bit \u6f14\u7b97\u306f\u9045\u3044\uff08\u672c\u5f53\u306b\uff1f\uff09\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (add, pop) \u30c7\u30fc\u30bf\u69cb\u9020: https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (init, add, remove, search_higher_equal) Exclusive OR Queries: https://atcoder.jp/contests/cpsco2019-s1/submissions/7485749\n    # \u691c\u8a3c3 (add, search_higher, search_lower) Second Sum: https://atcoder.jp/contests/abc140/submissions/7485479\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.square = square\n        if values is None:\n            self.rand_y = seed\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y ^= y << 13 & 0xffffffff\n                y ^= y >> 17\n                y ^= y << 5 & 0xffffffff\n                if y % square == 0:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer1.append(inf)\n            layer0.append(l0)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        # xorshift\n        y = self.rand_y\n        #y ^= y << 13 & 0xffffffff\n        #y ^= y >> 17\n        #y ^= y << 5 & 0xffffffff\n        y ^= y % 0x80000 * 0x2000\n        y ^= y // 0x20000\n        y ^= y % 0x8000000 * 0x20\n        self.rand_y = y\n\n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044  # dict \u5fae\u5999\u3060\u3063\u305f\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del layer1[idx1]\n            layer0[idx1] += layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "# \u52dd\u3066\u306a\u3044 \u3064\u3089\u3044\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (\u30c7\u30fc\u30bf\u69cb\u9020): https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (Exclusive OR Queries): https://atcoder.jp/contests/cpsco2019-s1/submissions/7482199\n    # \u691c\u8a3c3 (Second Sum): https://atcoder.jp/contests/abc140/submissions/7482046\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = []\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n        self.layer1.append(inf)\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        \n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081  \u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "# \u52dd\u3066\u306a\u3044 \u3064\u3089\u3044\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (add, pop) \u30c7\u30fc\u30bf\u69cb\u9020: https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (init, add, remove, search_higher_equal) Exclusive OR Queries: https://atcoder.jp/contests/cpsco2019-s1/submissions/7485446\n    # \u691c\u8a3c3 (add, search_higher, search_lower) Second Sum: https://atcoder.jp/contests/abc140/submissions/7483678\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y = self.rand_y\n                y ^= y << 13 & 0xffffffff\n                y ^= y >> 17\n                y ^= y << 5 & 0xffffffff\n                self.rand_y = y\n                if y % square == 0:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer1.append(inf)\n            layer0.append(l0)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        # xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n\n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del layer1[idx1]\n            layer0[idx1] += layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "import heapq\n\n\nN = int(input())\n\nP = list(map(int,input().split()))\n\n\nLlis = []\nRlis = []\n\nfor i in range(N):\n\n    Llis.append([N,N])\n    Rlis.append([N,N])\n    P[i] -= 1\n\n\nLQ1 = []\nLQ2 = []\n\nfor i in range(N):\n\n    while len(LQ2) > 0 and LQ2[0][0] < P[i]:\n        Llis[LQ2[0][1]][1] = i\n        heapq.heappop(LQ2)\n\n    while len(LQ1) > 0 and LQ1[0][0] < P[i]:\n        Llis[LQ1[0][1]][0] = i\n        heapq.heappush(LQ2,LQ1[0])\n        heapq.heappop(LQ1)\n\n    heapq.heappush(LQ1,[P[i],i])\n\nP.reverse()\nLQ1 = []\nLQ2 = []\n\nfor i in range(N):\n\n    while len(LQ2) > 0 and LQ2[0][0] < P[i]:\n        Rlis[LQ2[0][1]][1] = i\n        heapq.heappop(LQ2)\n\n    while len(LQ1) > 0 and LQ1[0][0] < P[i]:\n        Rlis[LQ1[0][1]][0] = i\n        heapq.heappush(LQ2,LQ1[0])\n        heapq.heappop(LQ1)\n\n    heapq.heappush(LQ1,[P[i],i])\n\n\n\n\n\nRlis.reverse()\n#print (Llis,Rlis)\n\nans = 0\nP.reverse()\n\nfor i in range(N):\n\n    Llenge = Llis[i][1] - Llis[i][0]\n    Rlenge = 1 + max(0,i - (N - Rlis[i][0]))\n\n    ans += (P[i]+1) * Llenge * Rlenge\n    #print (P[i] , Llenge , Rlenge)\n\nP.reverse()\nRlis.reverse()\nLlis.reverse()\n\nfor i in range(N):\n\n    Rlenge = Rlis[i][1] - Rlis[i][0]\n    Llenge = 1 + max(0,i - (N - Llis[i][0]))\n\n    ans += (P[i]+1) * Llenge * Rlenge\n    #print (P[i],Llenge,Rlenge)\n\nprint (ans)\n\n\n    \n        \n", "n=int(input())\np=list(map(int,input().split()))\nind=[0]*n\nfor i in range(n):ind[p[i]-1]=i+1\nl=[0]+[i for i in range(n+1)]\nr=[i+1 for i in range(n+1)]+[n+1]\nans=0\nfor i in range(n):\n  ans+=(r[r[ind[i]]]-r[ind[i]])*(ind[i]-l[ind[i]])*(i+1)\n  ans+=(l[ind[i]]-l[l[ind[i]]])*(r[ind[i]]-ind[i])*(i+1)\n  l[r[ind[i]]],r[l[ind[i]]]=l[ind[i]],r[ind[i]]\nprint(ans)", "import bisect\nn=int(input())\np=list(map(int,input().split()))\nidx=[0]*(n+1)\n\nfor i,p_i in enumerate(p):\n    idx[p_i]=i\n\nright_idx=list(range(1,n+1))+[n,n]\nleft_idx =list(range(-1,n-1))+[-1,-1]\nans=0\nfor p in range(1,n+1):\n    x=idx[p]\n    r1=right_idx[x]\n    r2=right_idx[r1]\n    l1=left_idx[x]\n    l2=left_idx[l1]\n\n    ans+=p*( (x-l1)*(r2-r1) + (l1-l2)*(r1-x)  )\n    right_idx[l1]=r1\n    left_idx[r1]=l1\nprint(ans)", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (\u30c7\u30fc\u30bf\u69cb\u9020): https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (Exclusive OR Queries): https://atcoder.jp/contests/cpsco2019-s1/submissions/7482199\n    # \u691c\u8a3c3 (Second Sum): https://atcoder.jp/contests/abc140/submissions/7482046\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = []\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n        self.layer1.append(inf)\n\n    def rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        return y % self.square == 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        if self.rand_depth():\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081  \u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != float(\"inf\"):\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != float(\"inf\"):\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "from time import time\nfrom statistics import median\nfrom bisect import bisect_left, bisect_right\nfrom random import random, sample\n\n\nclass TwoLayerSet:\n    def __init__(self, p):\n        self.top = []\n        self.bottom = [[]]\n        self.p = p\n\n    def insert(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            return False\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            return False\n        if random() < self.p:\n            top.insert(top_i, key)\n            bottom[top_i] = block[block_i:]\n            bottom.insert(top_i, block[:block_i])\n        else:\n            block.insert(block_i, key)\n        return True\n\n    def erase(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            top.pop(top_i)\n            bottom[top_i].extend(bottom.pop(top_i+1))\n            return True\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            block.pop(block_i)\n            return True\n        return False\n\n    def less(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def less_equal(self, key):\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def greater(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n    def greater_equal(self, key):\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = TwoLayerSet(1/100)\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.greater(i)\n        nexnex = t.greater(nex)\n        pre = t.less(i)\n        prepre = t.less(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "import bisect\n\n\nclass BTreeNode:\n    def __init__(self):\n        self.key = []\n        self.child = []\n\n\nclass BTree:\n    def __init__(self):\n        self.root = BTreeNode()\n\n    def search_higher(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_right(ptr.key, key)\n            if i != len(ptr.key):\n                ret = ptr.key[i]\n            ptr = ptr.child[i]\n        i = bisect.bisect_right(ptr.key, key)\n        if i != len(ptr.key):\n            ret = ptr.key[i]\n        return ret\n\n    def search_lower(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_left(ptr.key, key)\n            if i != 0:\n                ret = ptr.key[i - 1]\n            ptr = ptr.child[i]\n        i = bisect.bisect_left(ptr.key, key)\n        if i != 0:\n            ret = ptr.key[i - 1]\n        return ret\n\n    def insert(self, key):\n        def insert_rec(ptr):\n            b_size = 512\n            if not ptr.child:\n                bisect.insort(ptr.key, key)\n                if len(ptr.key) == b_size * 2 - 1:\n                        ret = BTreeNode()\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            else:\n                i = bisect.bisect(ptr.key, key)\n                temp = insert_rec(ptr.child[i])\n                if temp is not None:\n                    ptr.key.insert(i, temp.key.pop(-1))\n                    ptr.child.insert(i, temp)\n                    if len(ptr.child) == b_size * 2:\n                        ret = BTreeNode()\n                        ret.child = ptr.child[:b_size]\n                        ptr.child = ptr.child[b_size:]\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            return None\n        temp = insert_rec(self.root)\n        if temp is not None:\n            root = BTreeNode()\n            root.key = [temp.key.pop(-1)]\n            root.child = [temp, self.root]\n            self.root = root\n\n    def dump(self):\n        def dump_rec(ptr, dep):\n            for _ in range(0, dep):\n                print(\"  \", end=\"\")\n            print(ptr.key)\n            for c in ptr.child:\n                dump_rec(c, dep + 1)\n        dump_rec(self.root, 0)\n        print(\"\")\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = BTree()\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.search_higher(i)\n        nexnex = t.search_higher(nex)\n        pre = t.search_lower(i)\n        prepre = t.search_lower(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "def f_e():\n    n, *p = list(map(int, open(0).read().split()))\n    p = sorted([(v, i) for i, v in enumerate(p)])\n    *l, = list(range(-1, n-1))\n    *r, = list(range(1, n+1))\n    a = 0\n    for v, i in p:\n        l0, r0 = l[i], r[i]\n        l1 = l[l0] if l0>-1 else l0\n        r1 = r[r0] if r0<n else r0\n        a += ((l0-l1)*(r0-i)+(r1-r0)*(i-l0))*v\n        if l0>-1:\n            r[l0]=r0\n        if r0<n:\n            l[r0]=l0\n    print(a)\n\ndef __starting_point():\n    f_e()\n\n__starting_point()", "class Node:\n    def __init__(self, key=None):\n        self.key = key\n        self.balance = 'E'\n        self.parent = None\n        self.left = None\n        self.right = None\n\n\nclass AVL:\n    def __init__(self):\n        self.root = Node()\n        self.root.parent = Node('nil')\n\n    def insert(self, key):\n        if self.root.key is None:\n            self.root.key = key\n            return\n        cursor = self.root\n        while cursor:\n            p = cursor\n            if key == cursor.key:\n                return\n            elif key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        new_node = Node(key)\n        new_node.parent = p\n        if key < p.key:\n            p.left = new_node\n        else:\n            p.right = new_node\n            \n        return self.rebalance(p, new_node, key)\n            \n    def rebalance(self, u, v, key):\n        while u.key != 'nil':\n            if u.key > v.key:\n                if u.balance == 'R':\n                    u.balance = 'E'\n                    return\n                elif u.balance == 'L':\n                    if v.balance == 'L':\n                        self.rotate_R(u, v)\n                        return\n                    elif v.balance == 'R':\n\n                        self.rotate_LR(u, v)\n                        return\n                else:\n                    u.balance = 'L'\n                    v = u\n                    u = u.parent\n            else:\n                if u.balance == 'L':\n                    u.balance = 'E'\n                    return\n                elif u.balance == 'R':\n                    if v.balance == 'R':\n                        self.rotate_L(u, v)\n                        return\n                    elif v.balance == 'L':\n                        self.rotate_RL(u, v)\n                        return\n                else:\n                    u.balance = 'R'\n                    v = u\n                    u = u.parent\n              \n    def replace(self, u, v):\n        if u.parent.left == u:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        v.parent = u.parent\n        if v.parent.key == 'nil':\n            self.root = v   \n\n    def rotate_R(self, u, v):\n        w = v.right\n\n        self.replace(u, v)\n        v.right = u\n        u.parent = v        \n        u.left = w        \n        if w:\n            w.parent = u\n        u.balance = 'E'\n        v.balance = 'E'           \n\n    def rotate_L(self, u, v):\n        w = v.left\n        \n        self.replace(u, v)\n        v.left = u\n        u.parent = v\n        u.right = w        \n        if w:\n            w.parent = u\n        u.balance = 'E'\n        v.balance = 'E' \n\n    def rotate_LR(self, u, v):\n        w = v.right\n        \n        self.replace(u, w)\n        if w.left:\n            v.right = w.left\n            v.right.parent = v\n        else:\n            v.right = None\n        if w.right:\n            u.left = w.right\n            u.left.parent = u\n        else:\n            u.left = None\n        v.parent = w\n        w.left = v\n        u.parent = w\n        w.right = u\n\n        if w.balance == 'R':\n            u.balance = 'E'\n            v.balance = 'L'\n        elif w.balance == 'L':\n            u.balance ='R'\n            v.balance = 'E'\n        else:\n            u.balance = 'E'\n            v.balance = 'E'\n        w.balance = 'E'        \n\n    def rotate_RL(self, u, v):\n        w = v.left\n        \n        self.replace(u, w)\n        if w.left:\n            w.left.parent = u\n            u.right = w.left\n        else:\n            u.right = None\n        if w.right:\n            w.right.parent = v\n            v.left = w.right\n        else:\n            v.left = None\n        u.parent = w\n        w.left = u\n        v.parent = w\n        w.right = v       \n        \n        if w.balance == 'R':\n            u.balance = 'L'\n            v.balance = 'E'\n        elif w.balance == 'L':\n            u.balance ='E'\n            v.balance = 'R'\n        else:\n            u.balance = 'E'\n            v.balance = 'E'\n        w.balance = 'E'\n\n    def find(self, key):\n        cursor = self.root\n        while cursor:\n            if cursor.key == key:\n                return cursor\n            if key < cursor.key:\n                cursor = cursor.left\n            else:\n                cursor = cursor.right\n        return None\n    \n    def next_greater_key(self, cursor):\n        if cursor is None:\n            return\n        if cursor.right:\n            cursor = cursor.right\n            while cursor.left:\n                cursor = cursor.left\n            return cursor\n        elif cursor.parent.left == cursor:\n            return cursor.parent\n        elif cursor.parent.right == cursor:\n            while cursor.parent.key != 'nil' and cursor.parent.right == cursor:\n                cursor = cursor.parent\n            if cursor.parent.key != 'nil':\n                return cursor.parent\n        else:\n            return None\n        \n    def next_smaller_key(self, cursor):\n        if cursor is None:\n            return \n        if cursor.left:\n            cursor = cursor.left\n            while cursor.right:\n                cursor = cursor.right\n            return cursor\n        elif cursor.parent.right == cursor:\n            return cursor.parent\n        elif cursor.parent.left == cursor:\n            while cursor.parent.key != 'nil' and cursor.parent.left == cursor:\n                cursor = cursor.parent\n            if cursor.parent.key != 'nil':\n                return cursor.parent\n        \n    def get_smaller_key(self, key):\n        cursor = self.find(key)\n        l1 = self.next_smaller_key(cursor)\n        l2 = self.next_smaller_key(l1)\n        if l2 is None:\n            l2 = 0\n        else:\n            l2 = l2.key\n        return l1.key, l2\n    \n    def get_greater_key(self, key):\n        cursor = self.find(key)\n        r1 = self.next_greater_key(cursor)\n        r2 = self.next_greater_key(r1)\n        if r2 is None:\n            r2 = 0\n        else:\n            r2 = r2.key\n        return r1.key, r2\n\n\ndef main():\n#    import random\n    import sys\n\n#    N = 100000\n#    P = list(range(1, N + 1))\n#    random.shuffle(P)\n    \n    input = sys.stdin.readline\n    N = int(input())\n    P = map(int, input().split())    \n    \n    idx = [-1] * (N + 1)\n    for i, v in enumerate(P, 1):\n        idx[v] = i\n    avl = AVL()\n    for i in [0, idx[N], N+1]:\n        avl.insert(i)\n    total = 0\n    for j in range(N - 1, 0, -1):\n        n = idx[j]\n        avl.insert(n)\n        \n        l1_idx , l2_idx = avl.get_smaller_key(n)\n        l1 = n - l1_idx\n        if l1_idx != 0:\n            l2 = l1_idx - l2_idx\n        else:\n            l2 = 0\n            \n        r1_idx, r2_idx = avl.get_greater_key(n)\n        r1 = r1_idx - n\n        if r1_idx != N + 1:\n            r2 = r2_idx - r1_idx\n        else:\n            r2 = 0\n            \n        cnt = (l1 * r2 + r1 * l2) * j\n        total += cnt\n    \n    print(total)\n    \ndef __starting_point():\n    main()\n__starting_point()", "# \u52dd\u3066\u306a\u3044 \u3064\u3089\u3044 seed\u3067\u5909\u308f\u3063\u305f\u308a\u3057\u307e\u305b\u3093\u304b\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (add, pop) \u30c7\u30fc\u30bf\u69cb\u9020: https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (init, add, remove, search_higher_equal) Exclusive OR Queries: https://atcoder.jp/contests/cpsco2019-s1/submissions/7485446\n    # \u691c\u8a3c3 (add, search_higher, search_lower) Second Sum: https://atcoder.jp/contests/abc140/submissions/7483678\n    def __init__(self, values=None, sorted_=False, square=1000, seed=1000000007):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y = self.rand_y\n                y ^= y << 13 & 0xffffffff\n                y ^= y >> 17\n                y ^= y << 5 & 0xffffffff\n                self.rand_y = y\n                if y % square == 0:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer1.append(inf)\n            layer0.append(l0)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        # xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n\n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del layer1[idx1]\n            layer0[idx1] += layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "N = int(input())\nP = [int(i) for i in input().split(\" \")]\n\n# \u5404\u6570\u5b57\u304c\u4f55\u756a\u76ee\u306b\u5165\u3063\u3066\u3044\u308b\u304b\u3092\u4fdd\u5b58\u3059\u308b\npos = [0] * (N + 1)\nfor i in range(N):\n    pos[P[i]] = i + 1\n\nl = [0]+[i for i in range(N + 1)]\nr = [i + 1 for i in range(N + 1)] + [N + 1]\n\n# 1\u304b\u3089\u9806\u756a\u306b\u898b\u3066\u3044\u304f\nans = 0\nfor i in range(1, N + 1):\n    idx = pos[i]\n    l1, r1 = l[idx], r[idx]\n    l2, r2 = l[l1], r[r1]\n    ans += i * ((l1 - l2) * (r1 - idx) + (idx - l1) * (r2 - r1))\n    l[r1], r[l1] = l1, r1\nprint(ans)", "import bisect\n\n\nclass BTreeNode:\n    def __init__(self):\n        self.key = []\n        self.child = []\n\n\nclass BTree:\n    def __init__(self):\n        self.root = BTreeNode()\n\n    def search_higher(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_right(ptr.key, key)\n            if i != len(ptr.key):\n                ret = ptr.key[i]\n            ptr = ptr.child[i]\n        i = bisect.bisect_right(ptr.key, key)\n        if i != len(ptr.key):\n            ret = ptr.key[i]\n        return ret\n\n    def search_lower(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_left(ptr.key, key)\n            if i != 0:\n                ret = ptr.key[i - 1]\n            ptr = ptr.child[i]\n        i = bisect.bisect_left(ptr.key, key)\n        if i != 0:\n            ret = ptr.key[i - 1]\n        return ret\n\n    def insert(self, key):\n        def insert_rec(ptr):\n            b_size = 10\n            if not ptr.child:\n                bisect.insort(ptr.key, key)\n                if len(ptr.key) == b_size * 2 - 1:\n                        ret = BTreeNode()\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            else:\n                i = bisect.bisect(ptr.key, key)\n                temp = insert_rec(ptr.child[i])\n                if temp is not None:\n                    ptr.key.insert(i, temp.key.pop(-1))\n                    ptr.child.insert(i, temp)\n                    if len(ptr.child) == b_size * 2:\n                        ret = BTreeNode()\n                        ret.child = ptr.child[:b_size]\n                        ptr.child = ptr.child[b_size:]\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            return None\n        temp = insert_rec(self.root)\n        if temp is not None:\n            root = BTreeNode()\n            root.key = [temp.key.pop(-1)]\n            root.child = [temp, self.root]\n            self.root = root\n\n    def dump(self):\n        def dump_rec(ptr, dep):\n            for _ in range(0, dep):\n                print(\"  \", end=\"\")\n            print(ptr.key)\n            for c in ptr.child:\n                dump_rec(c, dep + 1)\n        dump_rec(self.root, 0)\n        print(\"\")\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = BTree()\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.search_higher(i)\n        nexnex = t.search_higher(nex)\n        pre = t.search_lower(i)\n        prepre = t.search_lower(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "# \u52dd\u3066\u306a\u3044 \u3064\u3089\u3044\n# Python \u306e bit \u6f14\u7b97\u306f\u9045\u3044\uff08\u672c\u5f53\u306b\uff1f\uff09\nfrom bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (add, pop) \u30c7\u30fc\u30bf\u69cb\u9020: https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (init, add, remove, search_higher_equal) Exclusive OR Queries: https://atcoder.jp/contests/cpsco2019-s1/submissions/7485749\n    # \u691c\u8a3c3 (add, search_higher, search_lower) Second Sum: https://atcoder.jp/contests/abc140/submissions/7485479\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.square = square\n        if values is None:\n            self.rand_y = seed\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y ^= y << 13 & 0xffffffff\n                y ^= y >> 17\n                y ^= y << 5 & 0xffffffff\n                if y % square == 0:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer1.append(inf)\n            layer0.append(l0)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        # xorshift\n        y = self.rand_y\n        #y ^= y << 13 & 0xffffffff\n        #y ^= y >> 17\n        #y ^= y << 5 & 0xffffffff\n        y ^= (y & 0x7ffff) << 13\n        y ^= y >> 17\n        y ^= (y & 0x7ffffff) << 5\n        self.rand_y = y\n\n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044  # dict \u5fae\u5999\u3060\u3063\u305f\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        # x \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u3001x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u8981\u7d20\u304c\u524a\u9664\u3055\u308c\u308b\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            del layer1[idx1]\n            layer0[idx1] += layer0.pop(idx1+1)\n        else:\n            del layer0_idx1[idx0]\n\n    def search_higher_equal(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081\u3001\u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "import bisect\nimport array\nN = int(input())\nP = list(map(int, input().split()))\nP_id = [0]*(N + 1)\n\nfor i in range(N):\n    P_id[P[i]] = i\n\nA = array.array('i', [- 1, P_id[N], N])\n\n\nres = 0\nfor i in range(N - 1, 0, - 1):\n    j = bisect.bisect_left(A, P_id[i])\n    A.insert(j, P_id[i])\n    l1 = A[j - 1]\n    r1 = A[j + 1]\n    l2 = l1\n    r2 = r1\n    if l1 != - 1:\n        l2 = A[j - 2]\n    if r1 != N:\n        r2 = A[j + 2]\n    \n    res += i*((A[j] - l1)*(r2 - r1) + (l1 - l2)*(r1 - A[j]))\n\nprint(res)", "N = int(input())\nPs = list(map(int, input().split()))\n\niPs = [0] * (N+1)\nfor iP, A in enumerate(Ps):\n    iPs[A] = iP\n\nans = 0\niLs = list(range(N+1))\niRs = list(range(N+1))\nfor P in range(1, N+1):\n    i = iPs[P]\n    iL, iR = iLs[i], iRs[i]\n    if iL <= 1:\n        iL2 = 0\n    else:\n        iL2 = iLs[iL-1]\n    if iR >= N-2:\n        iR2 = N-1\n    else:\n        iR2 = iRs[iR+1]\n    num = 0\n    if iL != 0:\n        num += (iL-iL2)*(iR-i+1)\n    if iR != N-1:\n        num += (i-iL+1)*(iR2-iR)\n    ans += P * num\n    iLs[iR+1] = iL\n    iRs[iL-1] = iR\n\nprint(ans)\n", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    # SkipList \u306e\u5c64\u6570\u3092 2 \u306b\u3057\u305f\u611f\u3058\u306e\u4f55\u304b\n    # std::multiset \u306e\u4ee3\u7528\u306b\u306a\u308b\n    # \u691c\u8a3c1 (\u30c7\u30fc\u30bf\u69cb\u9020): https://atcoder.jp/contests/arc033/submissions/7480578\n    # \u691c\u8a3c2 (Exclusive OR Queries): https://atcoder.jp/contests/cpsco2019-s1/submissions/7482199\n    # \u691c\u8a3c3 (Second Sum): https://atcoder.jp/contests/abc140/submissions/7482046\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.square = square\n        if values is None:\n            self.rand_y = seed\n            self.layer1 = [inf]\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            y = seed\n            l0 = []\n            for v in values:\n                y ^= y << 13 & 0xffffffff\n                y ^= y >> 17\n                y ^= y << 5 & 0xffffffff\n                if y % square:\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n            layer1.append(inf)\n            self.rand_y = y\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n\n        # xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n\n        if y % self.square == 0:\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664  # O(sqrt(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_right(layer0_idx1, x)\n        if idx0 == len(layer0_idx1):\n            return layer1[idx1]\n        return layer0_idx1[idx0]\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        layer0_idx1 = layer0[idx1]\n        idx0 = bisect_left(layer0_idx1, x)\n        if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n            return layer1[idx1-1]\n        return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        # O(sqrt(n))\n        # for \u3092\u56de\u3059\u306e\u3067\u91cd\u3081  \u4f7f\u3046\u306a\u3089 square \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u5927\u304d\u3081\u306b\u3059\u308b\u3079\u304d\n        layer1, layer0 = self.layer1, self.layer0\n        s = -1\n        for i, l0 in enumerate(layer0):\n            s += len(l0) + 1\n            if s >= idx:\n                break\n        if s==idx:\n            layer0[i] += layer0[i+1]\n            del layer0[i+1]\n            return layer1.pop(i)\n        else:\n            return layer0[i].pop(idx-s)\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    inf = float(\"inf\")\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != inf:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != inf:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\n\nmain()\n", "n = int(input())\np = [int(i) for i in input().split()]\n\npos_list = [0] * n\nfor ind, i in enumerate(p):\n\tpos_list[i-1] = ind\n\nleft_nextInd = list(range(-1, n-1)) + [-1, -1]\nright_nextInd = list(range(1, n+1)) + [n, n]\n\nanswer = 0\nfor i in range(1, n):\n\tind = pos_list[i-1]\n\tl1 = left_nextInd[ind]\n\tl2 = left_nextInd[l1]\n\tr1 = right_nextInd[ind]\n\tr2 = right_nextInd[r1]\n\n\tanswer += i * ((ind-l1) * (r2-r1) + (r1-ind) * (l1-l2))\n\n\tleft_nextInd[r1] = l1\n\tright_nextInd[l1] = r1\nprint(answer)", "N = int(input())\nP = list(map(int, input().split()))\n \nindex_lst = [0] * N\nfor index, i in enumerate(P):\n    index_lst[i - 1] = index\n \nleft_next_Index = list(range(-1, N - 1)) + [-1, -1]\nright_next_Index = list(range(1, N + 1)) + [N, N]\nans = 0\nfor i in range(1, N):\n    index = index_lst[i - 1]\n    # print (i, index)\n    l1 = left_next_Index[index]\n    l2 = left_next_Index[l1]\n    r1 = right_next_Index[index]\n    r2 = right_next_Index[r1]\n    # print ('l1 =', l1, ' l2 =', l2, ' r1 =', r1, ' r2 =', r2)\n    ans += i * ((index - l1) * (r2 - r1) + (r1 - index) * (l1 -l2))\n \n    left_next_Index[r1] = l1\n    right_next_Index[l1] = r1\n \nprint (ans)", "from bisect import bisect_left, bisect_right, insort_right\nclass SquareSkipList:\n    def __init__(self, values=None, sorted_=False, square=1000, seed=42):\n        # values: \u521d\u671f\u5024\u306e\u30ea\u30b9\u30c8\n        # sorted_: \u521d\u671f\u5024\u304c\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u304b\n        # square: \u6700\u5927\u30c7\u30fc\u30bf\u6570\u306e\u5e73\u65b9\u6839\n        # seed: \u4e71\u6570\u306e\u30b7\u30fc\u30c9\n        inf = float(\"inf\")\n        self.rand_y = seed\n        self.square = square\n        if values is None:\n            self.layer1 = []\n            self.layer0 = [[]]\n        else:\n            self.layer1 = layer1 = []\n            self.layer0 = layer0 = []\n            if not sorted_:\n                values.sort()\n            rand_depth = self.rand_depth\n            l0 = []\n            for v in values:\n                if rand_depth():\n                    layer0.append(l0)\n                    l0 = []\n                    layer1.append(v)\n                else:\n                    l0.append(v)\n            layer0.append(l0)\n        self.layer1.append(inf)\n\n    def rand_depth(self):  # 32bit xorshift\n        y = self.rand_y\n        y ^= y << 13 & 0xffffffff\n        y ^= y >> 17\n        y ^= y << 5 & 0xffffffff\n        self.rand_y = y\n        return y % self.square == 0\n\n    def add(self, x):  # \u8981\u7d20\u306e\u8ffd\u52a0\n        layer1, layer0 = self.layer1, self.layer0\n        if self.rand_depth():\n            idx1 = bisect_right(layer1, x)\n            layer1.insert(idx1, x)\n            layer0_idx1 = layer0[idx1]\n            idx0 = bisect_right(layer0_idx1, x)\n            layer0.insert(idx1+1, layer0_idx1[idx0:])  # layer0 \u306f dict \u3067\u7ba1\u7406\u3057\u305f\u65b9\u304c\u826f\u3044\u304b\u3082\u3057\u308c\u306a\u3044\n            del layer0_idx1[idx0:]\n        else:\n            idx1 = bisect_right(layer1, x)\n            insort_right(layer0[idx1], x)\n\n    def remove(self, x):  # \u8981\u7d20\u306e\u524a\u9664\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        if layer1[idx1] == x:\n            del layer1[idx1]\n            layer0[idx1] += layer0[idx1+1]\n            del layer0[idx1+1]\n        else:\n            layer0_idx1 = layer0[idx1]\n            del layer0_idx1[bisect_left(layer0_idx1, x)]\n\n    def bisect_left(self, x):  # x \u4ee5\u4e0a\u306e\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        if res == x:\n            return res\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_higher(self, x):  # x \u3092\u8d85\u3048\u308b\u6700\u5c0f\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_right(layer1, x)\n        res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        if layer0_idx1:\n            idx0 = bisect_right(layer0_idx1, x)\n            if idx0 == len(layer0_idx1):\n                return res\n            else:\n                return layer0_idx1[idx0]\n        else:\n            return res\n\n    def search_lower(self, x):  # x \u672a\u6e80\u306e\u6700\u5927\u306e\u5024\u3092\u8fd4\u3059  O(log(n))\n        layer1, layer0 = self.layer1, self.layer0\n        idx1 = bisect_left(layer1, x)\n        res = layer1[idx1]\n        layer0_idx1 = layer0[idx1]\n        if res != x:  # res > x\n            if layer0_idx1:\n                idx0 = bisect_left(layer0_idx1, x)\n                if idx0 != 0:\n                    return layer0_idx1[idx0-1]\n            return layer1[idx1-1]  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 x \u4ee5\u4e0a\u306e\u5834\u5408\n        else:\n            idx0 = bisect_left(layer0_idx1, x)\n            if idx0 == 0:  # layer0_idx1 \u304c\u7a7a\u306e\u5834\u5408\u3068\u3059\u3079\u3066 res \u3067\u57cb\u307e\u3063\u3066\u3044\u308b\u5834\u5408\n                return layer1[idx1-1]\n            else:\n                return layer0_idx1[idx0-1]\n\n    def pop(self, idx):\n        # \u5c0f\u3055\u3044\u65b9\u304b\u3089 idx \u756a\u76ee\u306e\u8981\u7d20\u3092\u524a\u9664\u3057\u3066\u305d\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff080-indexed\uff09\n        raise NotImplementedError  # \u5730\u5473\u306b\u5b9f\u88c5\u304c\u60a9\u307e\u3057\u3044\n\n    def print(self):\n        print(self.layer1)\n        print(self.layer0)\n\n\ndef main():\n    # \u53c2\u8003: https://atcoder.jp/contests/abc140/submissions/7477790\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    ssl = SquareSkipList()\n    ssl.add(-1)\n    ssl.add(n)\n    ans = 0\n    for i in idx:\n        nex = ssl.search_higher(i)\n        nexnex = ssl.search_higher(nex)\n        pre = ssl.search_lower(i)\n        prepre = ssl.search_lower(pre)\n        if prepre != float(\"inf\"):\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != float(\"inf\"):\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        ssl.add(i)\n    print(ans)\n\nmain()\n", "N = int(input())\nP = list(enumerate(list(map(int, input().split()))))\nP = sorted(P, key=lambda x:x[1])\n\nbefore_idx = list(range(-1, N-1)) + [-1, -1]\nnext_idx = list(range(1, N+1)) + [N, N]\nans = 0\nfor i, p in P:\n  il1 = before_idx[i]\n  il2 = before_idx[il1]\n  ir1 = next_idx[i]\n  ir2 = next_idx[ir1]\n  ans += p * ((i-il1)*(ir2-ir1) + (ir1-i)*(il1 -il2))\n  before_idx[ir1] = il1\n  next_idx[il1] = ir1\n\n\nprint (ans)", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\ndef main():\n    N = ri()\n    P = [N+1,N+1] + ria() + [N+1,N+1]\n\n    ord = []\n    for i in range(2,N+2):\n        ord.append((P[i], i))\n\n    ord = sorted(ord) # P[i], i , P[i]\u9806\u3067\u30bd\u30fc\u30c8\n\n    # ..AsssBssCssDsssE.. \u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\uff08C\u304c\u81ea\u5206 A,B,D,E>C\uff0cs<C\uff09\n    # C\u304b\u3089A,B,D,E\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u77e5\u308a\u305f\u3044\u306e\u3067\uff0cC\u3088\u308a\u5c0f\u3055\u3044\u533a\u9593\u306f\u9023\u7d50\u306b\u3057\u3066\u7f6e\u304d\uff0c\n    # \u30b9\u30ad\u30c3\u30d7\u3067\u304d\u308b\u3088\u3046\u306b\u5404\u9023\u7d50\u6210\u5206\u306e\u4e21\u7aef\u306b\u60c5\u5831\u3092\u4e57\u305b\u3066\u304a\u304f\n    #  union-find\u3067\u7ba1\u7406\u3057\u3066\u3082\u3044\u3044\u304c\uff0c\u30a2\u30af\u30bb\u30b9\u3059\u308b\u5834\u6240\u3068\u56de\u6570\u304c\u9650\u3089\u308c\u3066\u3044\u308b\u306e\u3067\u914d\u5217\u3067\u7ba1\u7406\u3067\u304d\u308b\n    tot = 0\n    l = [i for i in range(N + 4)]\n    r = [i for i in range(N + 4)]\n    used = [False] * (N + 4)\n    for v, idx in ord:\n        # \u5de6\u53f3\u304cused\u306a\u3089\u30de\u30fc\u30b8\u3059\u308b\n        used[idx] = True\n        if used[idx - 1]:\n            l[idx] = l[idx - 1]\n        if used[idx + 1]:\n            r[idx] = r[idx + 1]\n        r[l[idx]] = r[idx]\n        l[r[idx]] = l[idx]\n\n        l0 = l[idx] - 1\n        r0 = r[idx] + 1\n        l1 = l0 - 1 if not used[l0 - 1] else (l[l0-1] - 1)\n        r1 = r0 + 1 if not used[r0 + 1] else (r[r0+1] + 1)\n        #print(l1,l0,idx,r0,r1)\n\n        if l1 != 0:\n            rseg = r0 - idx\n            lseg = l0 - l1\n            tot += lseg * rseg * v\n        if r1 != N + 3:\n            rseg = r1 - r0\n            lseg = idx - l0\n            tot += lseg * rseg * v\n\n    print(tot)\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from time import time\nfrom statistics import median\nfrom bisect import bisect_left, bisect_right\nfrom random import random, sample\n\n\nclass TwoLayerSet:\n    def __init__(self, p):\n        self.top = []\n        self.bottom = [[]]\n        self.p = p\n\n    def insert(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            return False\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            return False\n        if random() < self.p:\n            top.insert(top_i, key)\n            bottom[top_i] = block[block_i:]\n            bottom.insert(top_i, block[:block_i])\n        else:\n            block.insert(block_i, key)\n        return True\n\n    def erase(self, key):\n        (top, bottom) = (self.top, self.bottom)\n        top_i = bisect_left(top, key)\n        if top_i != len(top) and key == top[top_i]:\n            top.pop(top_i)\n            bottom[top_i].extend(bottom.pop(top_i+1))\n            return True\n        block = bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block) and key == block[block_i]:\n            block.pop(block_i)\n            return True\n        return False\n\n    def less(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def less_equal(self, key):\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != 0:\n            return block[block_i - 1]\n        if top_i != 0:\n            return top[top_i - 1]\n        return None\n\n    def greater(self, key):\n        if key is None:\n            return None\n        top = self.top\n        top_i = bisect_right(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_right(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n    def greater_equal(self, key):\n        top = self.top\n        top_i = bisect_left(top, key)\n        block = self.bottom[top_i]\n        block_i = bisect_left(block, key)\n        if block_i != len(block):\n            return block[block_i]\n        if top_i != len(top):\n            return top[top_i]\n        return None\n\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = TwoLayerSet(1/50)\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.greater(i)\n        nexnex = t.greater(nex)\n        pre = t.less(i)\n        prepre = t.less(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(ans)\n\n\nmain()\n", "N = int(input())\nP = [int(x) for x in input().split()]\n\nPIdx = sorted([(i + 1, v) for i, v in enumerate(P)], key = lambda x: x[1])\n\nL = [0]\nfor i in range(N + 1):\n    L.append(i)\n\nR = [i + 1 for i in range(N + 1)]\nR.append(N + 1)\n\nans = 0\nfor i, v in PIdx:\n    l1 = L[i]\n    l2 = L[l1]\n    r1 = R[i]\n    r2 = R[r1]\n\n    ans += v * ((i - l1) * (r2 - r1) + (l1 - l2) * (r1 - i))\n\n    L[r1] = l1\n    R[l1] = r1\n\nprint(ans)\n"]
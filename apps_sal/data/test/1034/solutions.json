["\n\nX,Y,Z,K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\n\nans = []\nfor i in range(X):\n    if (i+1) > K: break\n    for j in range(Y):\n        if (i+1)*(j+1) > K: break\n        for k in range(Z):\n            if (i+1)*(j+1)*(k+1) > K: break\n            ans.append(A[i]+B[j]+C[k])\n\nans.sort(reverse=True)\n\nfor i in range(K):\n    print((ans[i]))\n            \n", "import heapq as hq\nx,y,z,k = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\nab = []\nfor a in A:\n    for b in B:\n        hq.heappush(ab, -a-b)\nabc = []\ncnt = 0\nwhile cnt < k and ab:\n    cnt += 1\n    a = hq.heappop(ab)\n    for b in C:\n        hq.heappush(abc, a-b)\ncnt = 0\nwhile cnt < k:\n    print(-hq.heappop(abc))\n    cnt += 1", "x, y, z, K = list(map(int, input().split()))\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\nans = []\nfor i in range(x):\n    for j in range(y):\n        for k in range(z):\n            if (i+1)*(j+1)*(k+1) <= K:\n                ans.append(A[i]+B[j]+C[k])\n                continue\n            break\nans.sort(reverse=True)\n\nfor i in range(K):\n    print((ans[i]))\n", "import heapq\n\nX, Y, Z, K = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())), reverse=True)\nB = sorted(list(map(int, input().split())), reverse=True)\nC = sorted(list(map(int, input().split())), reverse=True)\n\nchecked = {(0, 0, 0)}\nh = [(-(A[0] + B[0] + C[0]), 0, 0, 0)]\n\n\ndef push(i, j, k):\n    if i < X and j < Y and k < Z and (i, j, k) not in checked:\n        heapq.heappush(h, (-(A[i] + B[j] + C[k]), i, j, k))\n        checked.add((i, j, k))\n\n\nfor _ in range(K):\n    s, i, j, k = heapq.heappop(h)\n    print((-s))\n    push(i + 1, j, k)\n    push(i, j + 1, k)\n    push(i, j, k + 1)\n", "from heapq import *\nX,Y,Z,K = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\n\nA = sorted(A,reverse = True)\nB = sorted(B,reverse = True)\nC = sorted(C,reverse = True)\n\ncake = []\nheapify(cake)\nfor x in range(X):\n  for y in range(min(Y,K//(x+1)+1)):\n    for k in range(min(Z,K//((x+1)*(y+1))+1)):\n      heappush(cake,-(A[x]+B[y]+C[k]))\nfor _ in range(K):\n  print(abs(heappop(cake)))", "import heapq\n\nx, y, z, k =  list(map(int,input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\n\nhq = [[-a[0]-b[0]-c[0], 0, 0, 0]]\nheapq.heapify(hq)\nvisited = {(0,0,0)}\n\nfor i in range(k):\n    ii, ia, ib, ic = heapq.heappop(hq)\n    print((-ii))\n    na = min(ia+1, x-1)\n    nb = min(ib+1, y-1)\n    nc = min(ic+1, z-1)\n    if not (na, ib, ic) in visited:\n        heapq.heappush(hq, [-a[na] -b[ib] -c[ic], na, ib, ic])\n        visited.add((na, ib, ic))\n    if not (ia, nb, ic) in visited:\n        heapq.heappush(hq, [-a[ia] -b[nb] -c[ic], ia, nb, ic])\n        visited.add((ia, nb, ic))\n    if not (ia, ib, nc) in visited:\n        heapq.heappush(hq, [-a[ia] -b[ib] -c[nc], ia, ib, nc])\n        visited.add((ia, ib, nc))\n", "import numpy as np\n\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split(' ')))\n    A = np.array(list(map(int, input().split(' '))))\n    B = np.array(list(map(int, input().split(' '))))\n    C = np.array(list(map(int, input().split(' '))))\n    AB = np.array(np.meshgrid(A, B)).T.reshape(-1, 2).sum(axis=1)\n    AB[::-1].sort()\n    AB = AB[:min([K, X * Y])]\n    ABC = np.array(np.meshgrid(AB, C)).T.reshape(-1, 2).sum(axis=1)\n    ABC[::-1].sort()\n    for ans in ABC[:K]:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "\"\"\"\npriority-queue\n\"\"\"\nimport copy\n\n\nnum_list=list(map(int,input('').split(' ')))\nrank=num_list[3]\nlists=[]\nqueue=[]\nfor i in range(3):\n    a_list=list(map(int,input('').split(' ')))\n    list.sort(a_list,reverse=True)\n    if num_list[i]<=rank:\n        lists.append(a_list)\n    else:\n        lists.append(a_list[:rank])    \nqueue.append([lists[0][0]+lists[1][0]+lists[2][0],0,0,0])   \n#ret=[] \nfor i in range(rank):\n    poped=queue.pop(0)\n    #print(str(i+1)+\":\"+str(poped[0]))\n    print((poped[0]))\n    if i==rank-1:\n        break\n    for j in range(3):\n        if len(lists[j])>poped[j+1]+1:\n            to_append=copy.copy(poped)\n            to_append[j+1]+=1\n            to_append[0]+=lists[j][to_append[j+1]]-lists[j][poped[j+1]]\n            if len(queue)==0:\n                queue.append(to_append)  \n                continue\n            Done=True\n            for k in range(len(queue)):\n                #print(\"to cmp\")\n                #print(queue[k],to_append)\n                if queue[k]==to_append:\n                    Done=False\n                    break\n                elif queue[k][0]<to_append[0]:\n                    queue=queue[:k]+[to_append]+queue[k:]\n                    Done=False\n                    break\n            #print(Done)    \n            if Done==True:\n                queue.append(to_append)    \n            #print(\"print Queue\")\n            #for k in range(len(queue)):\n            #    print(queue[k])\n    if len(queue)>rank-i-1:\n        queue=queue[:(rank-i-1)]\n        #print(\"cut\")\n    #print(\"print Queue\")    \n    #for j in range(len(queue)):\n    #            print(queue[j])    \n\n\n", "def main():\n    import heapq\n\n    x, y, z, k, *abc = list(map(int, open(0).read().split()))\n    a = sorted(abc[:x], reverse=True)\n    b = sorted(abc[x:x + y], reverse=True)\n    c = sorted(abc[x + y:], reverse=True)\n    s = set()\n\n    h = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\n    heapq.heapify(h)\n    num = []\n    for _ in range(k):\n        p, i, j, k = heapq.heappop(h)\n        num.append(-p)\n        for p, q, r in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n            p, q, r = min(i + p, x - 1), min(j + q, y - 1), min(k + r, z - 1)\n            if (p, q, r) not in s:\n                s.add((p, q, r))\n                v = - (a[p] + b[q] + c[r])\n                heapq.heappush(h, (v, p, q, r))\n\n    ans = '\\n'.join(map(str, num))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X,Y,Z,K= list(map(int,input().split()))\nl_A=list(map(int,input().split()))\nl_B=list(map(int,input().split()))\nl_C=list(map(int,input().split()))\nl_A.sort(reverse=True)\nl_B.sort(reverse=True)\nl_C.sort(reverse=True)\nl=[]\nfor i in range(len(l_A)):\n   for j in range(len(l_B)):\n      for k in range(len(l_C)):\n        if (i+1)*(j+1)*(k+1) > K:\n           break\n        l+=[l_A[i]+l_B[j]+l_C[k]]\nans=sorted(l,reverse=True)[:K]\nprint(*ans,sep=\"\\n\")", "import heapq as hq\nx,y,z,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\nabc = [(-(A[0]+B[0]+C[0]), 0,0,0)]\nused = set((0,0,0))\nwhile K > 0:\n    K -= 1\n    p,i,j,k = hq.heappop(abc)\n    print((-p))\n    for a,b,c in [(i+1,j,k), (i,j+1,k), (i,j,k+1)]:\n        if a < x and b < y and c < z and (a,b,c) not in used:\n            used.add((a,b,c))\n            hq.heappush(abc, (-(A[a]+B[b]+C[c]), a,b,c))\n", "X, Y, Z, K = map(int, input().split())\nA = sorted(list(map(int, input().split())), reverse=True)\nB = sorted(list(map(int, input().split())), reverse=True)\nC = sorted(list(map(int, input().split())), reverse=True)\n\nans = []\nfor i in range(X):\n    for j in range(Y):\n        ij = (i+1)*(j+1)\n        if ij > K:\n            break\n        for k in range(Z):\n            if ij*(k+1) > K:\n                break\n            ans.append(A[i]+B[j]+C[k])\nans = sorted(ans, reverse=True)\nfor i in range(K):\n    print(ans[i])", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    X, Y, Z, K = NMI()\n    A = NLI()\n    B = NLI()\n    C = NLI()\n    AB = []\n    for a in A:\n        for b in B:\n            AB.append(a+b)\n    AB.sort(reverse=True)\n    C.sort(reverse=True)\n    S = []\n    for c_idx in range(min(len(C), 3000)):\n        for ab_idx in range(min(len(AB), 3000)):\n            S.append(C[c_idx] + AB[ab_idx])\n    S.sort(reverse=True)\n    for i in range(K):\n        print(S[i])\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# D - Cake 123\n\nimport heapq\nimport itertools\n\nx, y, z, k = list(map(int, input().split()))\n\nA = list(int(a) for a in input().split())\nB = list(int(b) for b in input().split())\nC = list(int(c) for c in input().split())\n\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nhq = []\nfor i in range(x):\n    for j in range(y):\n        for l in range(z):\n            if (i+1)*(j+1)*(l+1)<=k:\n                heapq.heappush(hq, (A[i]+B[j]+C[l])*-1)\n            else:\n                break\n\n'''\nhq = []\nfor i, j in itertools.product(A, B):\n    heapq.heappush(hq, (i+j)*-1)\n\nAB = []\nwhile len(hq)>0 and len(AB)<=k:\n    AB.append(heapq.heappop(hq)*-1)\n\nhq = []\nfor i, j in itertools.product(AB, C):\n    heapq.heappush(hq, (i+j)*-1)\n'''\n\nfor _ in range(k):\n    print((heapq.heappop(hq)*-1))\n", "x, y, z, k = map(int, input().split())\nalst = list(map(int, input().split()))\nblst = list(map(int, input().split()))\nclst = list(map(int, input().split()))\nalst.sort(reverse = True)\nblst.sort(reverse = True)\nclst.sort(reverse = True)\nans = []\nfor i in range(x):\n    for j in range(y):\n        if i * j > k:\n            break\n        for l in range(z):\n            if i * j * l > k:\n                break\n            ans.append(alst[i] + blst[j] + clst[l])\nans.sort(reverse = True)\nprint(*ans[:k], sep = \"\\n\")", "import heapq\nfrom collections import defaultdict\nx, y, z, K = list(map(int, input().split()))\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\nvisited = defaultdict(bool)\nQ = [(-(A[0]+B[0]+C[0]), 0, 0, 0)]\n\nfor _ in range(K):\n    S, i, j, k = heapq.heappop(Q)\n    print((-S))\n    if i+1 < x and not visited[i+1, j, k]:\n        heapq.heappush(Q, (-(A[i+1]+B[j]+C[k]), i+1, j, k))\n        visited[i+1, j, k] = True\n\n    if j+1 < y and not visited[i, j+1, k]:\n        heapq.heappush(Q, (-(A[i]+B[j+1]+C[k]), i, j+1, k))\n        visited[i, j+1, k] = True\n\n    if k+1 < z and not visited[i, j, k+1]:\n        heapq.heappush(Q, (-(A[i]+B[j]+C[k+1]), i, j, k+1))\n        visited[i, j, k+1] = True\n", "import heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\nX,Y,Z,K=map(int,input().split())\nA= list(map(int,input().split()))\nB= list(map(int,input().split()))\nC= list(map(int,input().split()))\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\ndic={}\ndic[(0,0,0)]=1\nlst =[(-(A[0]+B[0]+C[0]),0,0,0)]\nheapq.heapify(lst)\nfor r in range(K):\n a=lst[0][1]\n b=lst[0][2]\n c=lst[0][3]\n print(lst[0][0]*(-1))\n heapq.heappop(lst)\n if a<X-1 :\n  if (a+1,b,c) not in dic:\n   heapq.heappush(lst, (-(A[a+1]+B[b]+C[c]),a+1,b,c))\n   dic[(a+1,b,c)]=1\n if b<Y-1 :\n  if (a,b+1,c) not in dic:\n   heapq.heappush(lst, (-(A[a]+B[b+1]+C[c]),a,b+1,c))\n   dic[(a,b+1,c)]=1\n if c<Z-1 :\n  if (a,b,c+1) not in dic:\n   heapq.heappush(lst, (-(A[a]+B[b]+C[c+1]),a,b,c+1))\n   dic[(a,b,c+1)]=1", "def main():\n    import heapq\n\n    x, y, z, k, *abc = map(int, open(0).read().split())\n    a = abc[:x]\n    b = abc[x:x + y]\n    c = abc[x + y:]\n    s = set()\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n\n    h = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\n    heapq.heapify(h)\n    ans = []\n    for _ in range(k):\n        p, i, j, k = heapq.heappop(h)\n        ans.append(-p)\n        for p, q, r in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n            if i + p < x and j + q < y and k + r < z:\n                if (i + p, j + q, k + r) not in s:\n                    s.add((i + p, j + q, k + r))\n                    v = - (a[i + p] + b[j + q] + c[k + r])\n                    heapq.heappush(h, (v, i + p, j + q, k + r))\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\nX,Y,Z,K=map(int,input().split())\nA= list(map(int,input().split()))\nB= list(map(int,input().split()))\nC= list(map(int,input().split()))\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\ncheck=[[0,0,0]]\nlst =[(-(A[0]+B[0]+C[0]),0,0,0)]\nheapq.heapify(lst)\nfor r in range(K):\n a=lst[0][1]\n b=lst[0][2]\n c=lst[0][3] \n print(lst[0][0]*(-1))\n heapq.heappop(lst)\n if a<X-1 :\n  if [a+1,b,c] not in check:\n   heapq.heappush(lst, (-(A[a+1]+B[b]+C[c]),a+1,b,c))\n   check.append([a+1,b,c])\n if b<Y-1 :\n  if [a,b+1,c] not in check:\n   heapq.heappush(lst, (-(A[a]+B[b+1]+C[c]),a,b+1,c))\n   check.append([a,b+1,c])\n if c<Z-1 :\n  if [a,b,c+1] not in check:\n   heapq.heappush(lst, (-(A[a]+B[b]+C[c+1]),a,b,c+1))\n   check.append([a,b,c+1])", "from heapq import heapify,heappop,heappush\n\nX,Y,Z,K=map(int,input().split())\nA=sorted(map(int,input().split()),reverse=True)\nB=sorted(map(int,input().split()),reverse=True)\nC=sorted(map(int,input().split()),reverse=True)\nque=[[-(A[0]+B[0]+C[0]),0,0,0]];heapify(que)\ns=set()\n\nfor i in range(K):\n    p=heappop(que)\n    print(-p[0])\n    if p[1]<X-1 and not (p[1]+1,p[2],p[3]) in s:\n        heappush(que,[-sum([A[p[1]+1],B[p[2]],C[p[3]]]),p[1]+1,p[2],p[3]])\n        s.add((p[1]+1,p[2],p[3]))\n    if p[2]<Y-1 and not (p[1],p[2]+1,p[3]) in s:\n        heappush(que,[-sum([A[p[1]],B[p[2]+1],C[p[3]]]),p[1],p[2]+1,p[3]])\n        s.add((p[1],p[2]+1,p[3]))\n    if p[3]<Z-1 and not (p[1],p[2],p[3]+1) in s:\n        heappush(que,[-sum([A[p[1]],B[p[2]],C[p[3]+1]]),p[1],p[2],p[3]+1])\n        s.add((p[1],p[2],p[3]+1))", "import sys\nfrom heapq import heappop, heappush\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    X, Y, Z, K = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    B = list(map(int, readline().split()))\n    C = list(map(int, readline().split()))\n\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    hq = [(-(A[0] + B[0] + C[0]), 0, 0, 0)]\n\n    ans = [0] * K\n    added = {(0, 0, 0)}\n\n    for idx in range(K):\n        taste, i, j, k = heappop(hq)\n        ans[idx] = -taste\n        if i < X - 1 and (i + 1, j, k) not in added:\n            heappush(hq, (-(A[i + 1] + B[j] + C[k]), i + 1, j, k))\n            added.add((i + 1, j, k))\n        if j < Y - 1 and (i, j + 1, k) not in added:\n            heappush(hq, (-(A[i] + B[j + 1] + C[k]), i, j + 1, k))\n            added.add((i, j + 1, k))\n        if k < Z - 1 and (i, j, k + 1) not in added:\n            heappush(hq, (-(A[i] + B[j] + C[k + 1]), i, j, k + 1))\n            added.add((i, j, k + 1))\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X, Y, Z, K = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())), reverse=True)\nB = sorted(list(map(int, input().split())), reverse=True)\nC = sorted(list(map(int, input().split())), reverse=True)\ne = []\ns = []\n\nfor i in A:\n    for j in B:\n        e.append(i+j)\ne = sorted(e, reverse=True)\n\nif K<len(e):\n    e = e[0:K]\n\nfor i in e:\n    for j in C:\n        s.append(i+j)\n\ns = sorted(s, reverse=True)\n\nfor i in range(K):\n    print(s[i])", "import heapq\nx,y,z,k= map(int,input().split())\nalist = sorted(list(map(int,input().split())),reverse=True)\nblist = sorted(list(map(int,input().split())),reverse=True)\nclist = sorted(list(map(int,input().split())),reverse=True)\nl = [(-(alist[0]+blist[0]+clist[0]),0,0,0)]\nheapq.heapify(l)\ncount=0\nai=bi=ci=0\nselected = set()\nselected.add((0,0,0))\nwhile len(l)!=0:\n    temp = heapq.heappop(l)\n    (tempa,tempb,tempc)=temp[1:]\n    print(-temp[0])\n    count += 1\n    if count==k:break\n    if tempa+1<=x-1:\n        if not (tempa+1,tempb,tempc) in selected:\n            heapq.heappush(l,(-(alist[tempa+1]+blist[tempb]+clist[tempc]),tempa+1,tempb,tempc))\n            selected.add((tempa+1,tempb,tempc))    \n    if tempb+1<=y-1:\n        if not (tempa,tempb+1,tempc) in selected:\n            heapq.heappush(l,(-(alist[tempa]+blist[tempb+1]+clist[tempc]),tempa,tempb+1,tempc))\n            selected.add((tempa,tempb+1,tempc))\n    if tempc+1<=z-1:\n        if not (tempa,tempb,tempc+1) in selected:\n            heapq.heappush(l,(-(alist[tempa]+blist[tempb]+clist[tempc+1]),tempa,tempb,tempc+1))\n            selected.add((tempa,tempb,tempc+1))", "#!/usr/bin/env python3\n\nx, y, z, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# ab = []\n# for i in a:\n#     for j in b:\n#         ab.append(i+j)\n# ab.sort(reverse=True)\n\n# ab = ab[:k]\n\n# abc = []\n# for i in ab:\n#     for j in c:\n#         abc.append(i+j)\n# abc.sort(reverse=True)\n\n# for i in range(k):\n#     print(abc[i])\n\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\n\na_max = min(k, len(a))\nb_max = min(k, len(b))\nc_max = min(k, len(c))\n\nabc = []\nfor i in range(1, k+1):\n    if i > len(a):\n        break\n    for j in range(1, k//i+1):\n        if j > len(b):\n            break\n        for l in range(1, k//(i*j)+1):\n            if l > len(c):\n                break\n            # print(i, j, l)\n            abc.append(a[i-1]+b[j-1]+c[l-1])\n\n# print(abc)\n# print(k)\nabc.sort(reverse=True)\nfor i in range(k):\n    print((abc[i]))\n", "import sys\nfrom heapq import heappush, heappop\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    X, Y, Z, K = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    B = list(map(int, readline().split()))\n    C = list(map(int, readline().split()))\n\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    hq = [(-(A[0] + B[0] + C[0]), 0, 0, 0)]\n    ans = [0] * K\n    seen = {(0, 0, 0)}\n\n    for idx in range(K):\n        s, i, j, k = heappop(hq)\n        ans[idx] = -s\n\n        if i < X - 1 and (i + 1, j, k) not in seen:\n            heappush(hq, (-(A[i + 1] + B[j] + C[k]), i + 1, j, k))\n            seen.add((i + 1, j, k))\n        if j < Y - 1 and (i, j + 1, k) not in seen:\n            heappush(hq, (-(A[i] + B[j + 1] + C[k]), i, j + 1, k))\n            seen.add((i, j + 1, k))\n        if k < Z - 1 and (i, j, k + 1) not in seen:\n            heappush(hq, (-(A[i] + B[j] + C[k + 1]), i, j, k + 1))\n            seen.add((i, j, k + 1))\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import *\n\nX,Y,Z,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\n# Heapq\u7684\u306a\u306e\u3067\u3076\u3063\u3053\u307fPop\u3057\u3066\u308c\u3070\u3088\u3044\n# \u305d\u306e\u304b\u308f\u308a\u5168\u30d1\u30bf\u30fc\u30f3\u6700\u521d\u304b\u3089\u3076\u3061\u8fbc\u3080\u306e\u306f\u3080\u308a\u306a\u306e\u3067\u3001pop\u3057\u305findex\u3092\u3082\u3068\u306b\u5019\u88dc\u3068\u306a\u308b\u5bfe\u8c61\u3092push\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n# \u305f\u3060\u3057\u5bb9\u6613\u306b\u91cd\u8907\u6295\u5165\u3057\u3046\u308b\u306e\u3067\u3001\u6295\u5165\u6e08\u307f\u30d1\u30bf\u30fc\u30f3\u3092\u899a\u3048\u3066\u304a\u304f\u306e\u304b\u306a\u2026\u3002history\u306b\u542b\u307e\u308c\u3066\u305f\u3089SKIP\u3002\nQ = []\nhis = set()\n\ndef pushq(p,q,r):\n  if (p,q,r) in his:\n    return\n  if p >= X or q >= Y or r >= Z:\n    return\n  his.add((p,q,r))\n  heappush(Q, ((-1) * (A[p] + B[q] + C[r]), (p, q, r)))\n  return\n\npushq(0,0,0)\nfor _ in range(K):\n  V = heappop(Q)\n  print(((-1)*V[0]))\n  p,q,r = V[1]\n  pushq(p+1,q,r)\n  pushq(p,q+1,r)\n  pushq(p,q,r+1)\n  \n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    X, Y, Z, K = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    B = list(map(int, readline().split()))\n    C = list(map(int, readline().split()))\n\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    AB = [a + b for a in A[:K] for b in B[:K]]\n    AB.sort(reverse=True)\n\n    ABC = [ab + c for ab in AB[:K] for c in C[:K]]\n    ABC.sort(reverse=True)\n\n    print(*ABC[:K], sep='\\n')\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# O(klog(k))\u89e3\u6cd5 \u591a\u5206...\nimport sys\nfrom heapq import heappush,heapify,heappop\ninput = sys.stdin.readline\nx, y, z, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\ndef make_kth(A, B):\n    n, m = len(A), len(B)\n    A.sort(reverse=1)\n    B.sort(reverse=1)\n    q = [(-A[0] - B[0], 0, 0)]\n    r=[]\n    for _ in range(min(k, n * m)):\n        v, s, t = heappop(q)\n        r.append(-v)\n        if t + 1 < m:\n            heappush(q, (-A[s] - B[t + 1], s, t + 1))\n        if t == 0 and s + 1 < n:\n            heappush(q, (-A[s + 1] - B[0], s + 1, 0))\n    return r\n\nr = make_kth(a, b)\nr = make_kth(c, r)\nprint(*r,sep=\"\\n\")", "# D - Cake 123\n\nimport heapq\nimport itertools\nfrom collections import defaultdict\n\nx, y, z, k = list(map(int, input().split()))\n\nA = list(int(a) for a in input().split())\nB = list(int(b) for b in input().split())\nC = list(int(c) for c in input().split())\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nhq = []\nhqAns = []\nd = defaultdict(int)\n\nheapq.heappush(hq, ((A[0]+B[0]+C[0])*-1, 0, 0, 0))\nd[(0,0,0)] = 1\n\nwhile len(hqAns)<k :\n    val, l, m, n = heapq.heappop(hq)\n    heapq.heappush(hqAns, val)\n \n    if d[(l+1, m, n)]==0 and l+1 < x:\n        heapq.heappush(hq, ((A[l+1]+B[m]+C[n])*-1, l+1, m, n))\n        d[(l+1, m, n)] = 1\n\n    if d[(l, m+1, n)]==0 and m+1 < y:\n        heapq.heappush(hq, ((A[l]+B[m+1]+C[n])*-1, l, m+1, n))\n        d[(l, m+1, n)] = 1\n \n    if d[(l, m, n+1)]==0 and n+1 < z:\n        heapq.heappush(hq, ((A[l]+B[m]+C[n+1])*-1, l, m, n+1))\n        d[(l, m, n+1)] = 1\n\nfor i in range(k):\n    print((heapq.heappop(hqAns)*-1))\n\n'''\n# ans.2 #\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nhq = []\nfor i in range(x):\n    for j in range(y):\n        for l in range(z):\n            if (i+1)*(j+1)*(l+1)<=k:\n                heapq.heappush(hq, (A[i]+B[j]+C[l])*-1)\n            else:\n                break\n\nfor _ in range(k):\n    print(heapq.heappop(hq)*-1)\n\n'''\n\n'''\n\n# ans.1 #\n\nhq = []\nfor i, j in itertools.product(A, B):\n    heapq.heappush(hq, (i+j)*-1)\n\nAB = []\nwhile len(hq)>0 and len(AB)<=k:\n    AB.append(heapq.heappop(hq)*-1)\n\nhq = []\nfor i, j in itertools.product(AB, C):\n    heapq.heappush(hq, (i+j)*-1)\n\nfor _ in range(k):\n    print(heapq.heappop(hq)*-1)\n\n'''\n", "import heapq\n\nX,Y,Z,K = [int(x) for x in input().split()]\nXYZ=[0]*3\nfor i in range(3):\n    XYZ[i]=[int(x)for x in input().split()]\n    XYZ[i].sort(reverse=True)\n\n\ntmp = (-1*(XYZ[0][0]+XYZ[1][0]+XYZ[2][0]),0,0,0)\nq = [tmp]\ninq = {tmp[1:]}\nheapq.heapify(q)\n\nfor ik in range(K):\n    max = heapq.heappop(q)\n    print((-max[0]))\n    i,j,k = max[1],max[2],max[3]\n    #print(-max[0],i,j,k)\n    if(not ((i+1,j,k) in inq) and i+1 < X):\n        heapq.heappush(q,(-1*(XYZ[0][i+1]+XYZ[1][j]+XYZ[2][k]),i+1,j,k))\n        inq.add((i+1,j,k))\n    if(not ((i,j+1,k) in inq) and j+1 < Y):\n        heapq.heappush(q,(-1*(XYZ[0][i]+XYZ[1][j+1]+XYZ[2][k]),i,j+1,k))\n        inq.add((i,j+1,k))\n    if(not ((i,j,k+1) in inq) and k+1 < Z):\n        heapq.heappush(q,(-1*(XYZ[0][i]+XYZ[1][j]+XYZ[2][k+1]),i,j,k+1))\n        inq.add((i,j,k+1))\nprint()\n", "X,Y,Z,K=map(int,input().split())\nA=sorted(map(int,input().split()), reverse=True)\nB=sorted(map(int,input().split()), reverse=True)\nC=sorted(map(int,input().split()), reverse=True)\nAB=[]\nfor a in A:\n    for b in B:\n        AB.append(a+b)\nAB=sorted(AB,reverse=True)[:K]\nans=[]\nfor ab in AB:\n    for c in C:\n        ans.append(ab+c)\nans=sorted(ans,reverse=True)[:K]\nprint(*ans,sep='\\n')", "x,y,z,k=map(int,input().split())\nA=[int(i) for i in input().split()]\nB=[int(i) for i in input().split()]\nC=[int(i) for i in input().split()]\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nimport heapq\nV={(0,0,0)}\nQ=[(-(A[0]+B[0]+C[0]),0,0,0)]\nheapq.heapify(Q)\n\ndef isIn(tup):\n    return tup[0]<x and tup[1]<y and tup[2]<z\n\nfor i in range(k):\n    now=heapq.heappop(Q)\n    print(-now[0])\n    nex=(now[1]+1,now[2],now[3])\n    if not nex in V and isIn(nex):\n        V.add(nex)\n        heapq.heappush(Q,(-(A[nex[0]]+B[nex[1]]+C[nex[2]]),)+nex)\n    nex=(now[1],now[2]+1,now[3])\n    if not nex in V and isIn(nex):\n        V.add(nex)\n        heapq.heappush(Q,(-(A[nex[0]]+B[nex[1]]+C[nex[2]]),)+nex)\n    nex=(now[1],now[2],now[3]+1)\n    if not nex in V and isIn(nex):\n        V.add(nex)\n        heapq.heappush(Q,(-(A[nex[0]]+B[nex[1]]+C[nex[2]]),)+nex)", "from sys import stdin\nimport heapq\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    x,y,z,k=map(int,readline().split())\n    a=list(map(int,readline().split()))\n    a.sort(reverse=True)\n    b=list(map(int,readline().split()))\n    b.sort(reverse=True)\n    c=list(map(int,readline().split()))\n    c.sort(reverse=True)\n\n    s={(0,0,0)}\n    h=[[-(a[0]+b[0]+c[0]),(0,0,0)]]\n    heapq.heapify(h)\n    for _ in range(k):\n        li=heapq.heappop(h)\n        n=-li[0]\n        co=li[1]\n        print(n)\n\n        if co[0]+1<x:\n            co_1=(co[0]+1,co[1],co[2])\n            n_1=a[co_1[0]]+b[co_1[1]]+c[co_1[2]]\n            n_1=-n_1\n            if co_1 not in s:\n                heapq.heappush(h,[n_1,co_1])\n                s.add(co_1)\n\n        if co[1]+1<y:\n            co_2=(co[0],co[1]+1,co[2])\n            n_2=a[co_2[0]]+b[co_2[1]]+c[co_2[2]]\n            n_2=-n_2\n            if co_2 not in s:\n                heapq.heappush(h,[n_2,co_2])\n                s.add(co_2)\n\n        if co[2]+1<z:\n            co_3=(co[0],co[1],co[2]+1)\n            n_3=a[co_3[0]]+b[co_3[1]]+c[co_3[2]]\n            n_3=-n_3\n            if co_3 not in s:\n                heapq.heappush(h,[n_3,co_3])\n                s.add(co_3)\n\ndef __starting_point():\n    main()\n__starting_point()", "x,y,z,k=list(map(int,input().split()))\na=sorted(list(map(int,input().split())),reverse=True)\nb=sorted(list(map(int,input().split())),reverse=True)\nc=sorted(list(map(int,input().split())),reverse=True)\nans=[]\nfor ai in a:\n  for bi in b:\n    ans.append(-ai-bi)\nans.sort()\nans=ans[:k] if len(ans)>=k else ans+[0]*(k-len(ans))\nans1=[]\nfrom heapq import heapify,heappop,heappush\nfor ci in c:\n  for ansi in ans:\n    heappush(ans1,ansi-ci)\nfor i in range(k):\n  print((-heappop(ans1)))\n\n", "import heapq\n\nX, Y, Z, K = list(map(int, input().split()))\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nC = [int(x) for x in input().split()]\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\n# (sum, idx of a, b, c)\n\nh = []\nheapq.heappush(h, (-A[0]-B[0]-C[0], 0, 0, 0))\n\nans = []\nst = set()\n\nfor _ in range(K):\n    s, i, j, k = heapq.heappop(h)\n    ans.append(-s)\n    if i+1 < X and not((i+1, j, k) in st):\n        heapq.heappush(h, (-A[i+1]-B[j]-C[k], i+1, j, k))\n        st.add((i+1, j, k))\n    if j+1 < Y and not((i, j+1, k) in st):\n        heapq.heappush(h, (-A[i]-B[j+1]-C[k], i, j+1, k))\n        st.add((i, j+1, k))\n    if k+1 < Z and not((i, j, k+1) in st):\n        heapq.heappush(h, (-A[i]-B[j]-C[k+1], i, j, k+1))\n        st.add((i, j, k+1))\n\nfor v in ans:\n    print(v)\n", "X,Y,Z,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nC = list(map(int,input().split()))\n\nA.sort(reverse = True)\nB.sort(reverse = True)\nC.sort(reverse = True)\n\ncakeList = []\nfor i in range(1, X + 1):\n    for j in range(1, Y + 1):\n        for k in range(1, Z + 1):\n            if i * j * k <= K:\n                cakeList.append(A[i - 1] + B[j - 1] + C[k - 1])\n            else:\n                break\n\ncakeList.sort(reverse = True)\n\nfor i in range(K):\n    print(cakeList[i])", "x, y, z, K = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))[::-1]\nb = sorted(list(map(int, input().split())))[::-1]\nc = sorted(list(map(int, input().split())))[::-1]\n\n\nans = []\nfor i in range(x):\n    for j in range(y):\n        if i * j > K:\n            break\n        for k in range(z):\n            if i * j * k > K:\n                break\n            ans.append(a[i] + b[j] + c[k])\nans = sorted(ans)[::-1]\nfor i in range(K):\n    print((ans[i]))\n", "\nX, Y, Z, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nsum = []\nfor x in range(X):\n    for y in range(Y):\n        for z in range(Z):\n            if (x+1)*(y+1)*(z+1) <= K:\n                sum.append(A[x] + B[y] + C[z])\n            else:\n                break\n\nsum.sort(reverse=True)\nfor i in range(K):\n    print(sum[i])", "import sys\nreadline = sys.stdin.readline\n\nX,Y,Z,K = map(int,readline().split())\n\nA = sorted(list(map(int,readline().split())),reverse = True)\nB = sorted(list(map(int,readline().split())),reverse = True)\nC = sorted(list(map(int,readline().split())),reverse = True)\n\nans = []\nfor a in range(len(A)):\n  for b in range(len(B)):\n    for c in range(len(C)):\n      if (a + 1) * (b + 1) * (c + 1) > K:\n        break\n      ans += [A[a] + B[b] + C[c]]\n      \nans = sorted(ans,reverse = True)[:K]\nprint(*ans,sep = \"\\n\")", "from heapq import heappop, heappush\ndef main():\n    def push(i, j, k):\n        nonlocal ADD, H\n        if i >= x or j >= y or k >= z: return\n        if (i, j, k) not in ADD:\n            heappush(H, (A[i] + B[j] + C[k], i, j, k))\n            ADD.add((i, j, k))\n    x, y, z, k = list(map(int, input().split()))\n    A = sorted([-int(x) for x in input().split()])\n    B = sorted([-int(x) for x in input().split()])\n    C = sorted([-int(x) for x in input().split()])\n    H = []\n    ADD = set()\n    push(0, 0, 0)\n    for _ in range(k):\n        ans, i, j, k = heappop(H)\n        push(i + 1, j, k)\n        push(i, j + 1, k)\n        push(i, j, k + 1)\n        print((-ans))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import product\nfrom heapq import *\n\nX,Y,Z,K,*f = map(int, open(0).read().split())\nA = f[:X]\nB = f[X:X+Y]\nC = f[X+Y:]\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\nAB = [sum(x) * (-1) for x in product(A,B)]\nheapify(AB)\nAB_picked = []\nfor i in range(K):\n    if AB:\n        AB_picked.append(heappop(AB)*(-1))\n    else:\n        break\nABC = [sum(x) * (-1) for x in product(AB_picked,C)]\nheapify(ABC)\nfor i in range(K):\n    print(heappop(ABC)*(-1))", "import heapq\n\nx,y,z,k = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\n\nli = [(-(a[0]+b[0]+c[0]),0,0,0)]\n\nheapq.heapify(li)\n\nfor i in range(k):\n    ans = heapq.heappop(li)\n    print(-ans[0])\n    if x > ans[1]+1 and (-(a[ans[1]+1]+b[ans[2]]+c[ans[3]]),ans[1]+1,ans[2],ans[3]) not in li: \n        heapq.heappush(li,(-(a[ans[1]+1]+b[ans[2]]+c[ans[3]]),ans[1]+1,ans[2],ans[3]))\n    if y > ans[2]+1 and (-(a[ans[1]]+b[ans[2]+1]+c[ans[3]]),ans[1],ans[2]+1,ans[3]) not in li:\n        heapq.heappush(li,(-(a[ans[1]]+b[ans[2]+1]+c[ans[3]]),ans[1],ans[2]+1,ans[3]))\n    if z > ans[3]+1 and (-(a[ans[1]]+b[ans[2]]+c[ans[3]+1]),ans[1],ans[2],ans[3]+1) not in li:\n        heapq.heappush(li,(-(a[ans[1]]+b[ans[2]]+c[ans[3]+1]),ans[1],ans[2],ans[3]+1))", "from heapq import heappush, heappop\nfrom collections import defaultdict\n\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split(' ')))\n    A = list(map(int, input().split(' ')))\n    B = list(map(int, input().split(' ')))\n    C = list(map(int, input().split(' ')))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    que = [(- A[0] - B[0] - C[0], 0, 0, 0)]  # multiply -1 to change min to max\n    already_inserted = defaultdict(int)\n    answer = list()\n    for _ in range(K):\n        q, i, j, k = heappop(que)\n        answer.append(-q)\n        if i + 1 < X:\n            item_a = (- A[i + 1] - B[j] - C[k], i + 1, j, k)\n            if already_inserted[item_a] == 0:\n                heappush(que, item_a)\n                already_inserted[item_a] = 1\n        if j + 1 < Y:\n            item_b = (- A[i] - B[j + 1] - C[k], i, j + 1, k)\n            if already_inserted[item_b] == 0:\n                heappush(que, item_b)\n                already_inserted[item_b] = 1\n        if k + 1 < Z:\n            item_c = (- A[i] - B[j] - C[k + 1], i, j, k + 1)\n            if already_inserted[item_c] == 0:\n                heappush(que, item_c)\n                already_inserted[item_c] = 1\n    for ans in answer:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import heapq\n\n    x, y, z, k, *abc = list(map(int, open(0).read().split()))\n    a = sorted(abc[:x], reverse=True)\n    b = sorted(abc[x:x + y], reverse=True)\n    c = sorted(abc[x + y:], reverse=True)\n    s = set()\n\n    h = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\n    heapq.heapify(h)\n    num = []\n    for _ in range(k):\n        p, i, j, k = heapq.heappop(h)\n        num.append(-p)\n        for p, q, r in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n            if i + p < x and j + q < y and k + r < z:\n                if (i + p, j + q, k + r) not in s:\n                    s.add((i + p, j + q, k + r))\n                    v = - (a[i + p] + b[j + q] + c[k + r])\n                    heapq.heappush(h, (v, i + p, j + q, k + r))\n\n    ans = '\\n'.join(map(str, num))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nX, Y, Z, K = list(map(int, input().split()))\nA = sorted([int(i) for i in input().split()], reverse=True)\nB = sorted([int(i) for i in input().split()], reverse=True)\nC = sorted([int(i) for i in input().split()], reverse=True)\n\ndone = {(0, 0, 0)}\n\nhq = [(-(A[0]+B[0]+C[0]), 0, 0, 0)]\nheapq.heapify(hq)  # \u30ea\u30b9\u30c8hq\u306eheap\u5316\n\nans = 0\nD = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n\nfor _ in range(K):\n    s, i, j, k = heapq.heappop(hq)  # heap\u5316\u3055\u308c\u305f\u30ea\u30b9\u30c8hq\u304b\u3089\u6700\u5c0f\u5024\u3092\u524a\u9664\uff06\u305d\u306e\u6700\u5c0f\u5024\u3092\u51fa\u529b\n    print((-s))\n    for d in D:\n        ni, nj, nk = i+d[0], j+d[1], k+d[2]\n        if ni < X and nj < Y and nk < Z and (ni, nj, nk) not in done:\n            # heap\u5316\u3055\u308c\u305f\u30ea\u30b9\u30c8hq\u306b\u8981\u7d20x\u3092\u8ffd\u52a0\n            heapq.heappush(hq, (-(A[ni]+B[nj]+C[nk]), ni, nj, nk))\n            done.add((ni, nj, nk))\n", "X, Y, Z, K  = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nl = []\nfor a in A:\n    for b in B:\n        l.append(a+b)\nl = sorted(l, reverse = True)[:K]\n\nans = []\nfor c in C:\n    for k in l:\n        ans.append(c + k)\n        \nans = sorted(ans, reverse = True)\nprint(*ans[:K], sep=\"\\n\")", "\nimport heapq\n\n\ndef submit():\n    x, y, z, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n\n    def get(i, j, k):\n        return a[i] + b[j] + c[k], (i, j, k)\n\n    check = set()\n    check.add((0, 0, 0))\n    ans = [get(0, 0, 0)]\n    q = []\n    for _ in range(k - 1):\n        prev, (i, j, k) = ans[-1]\n        \n        if i < x - 1:\n            new_triple = (i + 1, j, k)\n            if new_triple not in check:\n                check.add(new_triple)\n                s, _ = get(*new_triple)\n                heapq.heappush(q, (-s, new_triple))\n        \n        if j < y - 1:\n            new_triple = (i, j + 1, k)\n            if new_triple not in check:\n                check.add(new_triple)\n                s, _ = get(*new_triple)\n                heapq.heappush(q, (-s, new_triple))\n\n        if k < z - 1:\n            new_triple = (i, j, k + 1)\n            if new_triple not in check:\n                check.add(new_triple)\n                s, _ = get(*new_triple)\n                heapq.heappush(q, (-s, new_triple))\n\n        next_s, next_triple = heapq.heappop(q)\n        ans.append((-next_s, next_triple))\n        # print(ans)\n\n    for s, _ in ans:\n        print(s)\n        \n\nsubmit()", "def main():\n    import heapq\n\n    x, y, z, k, *abc = map(int, open(0).read().split())\n    a = abc[:x]\n    b = abc[x:x + y]\n    c = abc[x + y:]\n    d = []\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n\n    h = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\n    heapq.heapify(h)\n    ans = []\n    for _ in range(k):\n        p, i, j, k = heapq.heappop(h)\n        ans.append(-p)\n        for p, q, r in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n            if i + p < x and j + q < y and k + r < z:\n                if (i + p, j + q, k + r) not in d:\n                    d.append((i + p, j + q, k + r))\n                    v = - (a[i + p] + b[j + q] + c[k + r])\n                    heapq.heappush(h, (v, i + p, j + q, k + r))\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X, Y, Z, K = map(int, input().split())\nA = sorted(list(map(int, input().split())), reverse=True)\nB = sorted(list(map(int, input().split())), reverse=True)\nC = sorted(list(map(int, input().split())), reverse=True)\n\nl = []\nfor a in A:\n    for b in B:\n        l.append(a+b)\nl = sorted(l, reverse=True)[:K]\n\n\nans = []\nfor c in C:\n    for k in l:\n        ans.append(c+k)\n\nans = sorted(ans, reverse=True)\nprint(*ans[:K], sep=\"\\n\")", "from heapq import heapify, heappop, heappush, heappushpop\n\n\nclass PriorityQueue:\n    def __init__(self, heap):\n        '''\n        heap ... list\n        '''\n        self.heap = heap\n        heapify(self.heap)\n\n    def push(self, item):\n        heappush(self.heap, item)\n\n    def pop(self):\n        return heappop(self.heap)\n\n    def pushpop(self, item):\n        return heappushpop(self.heap, item)\n\n    def __call__(self):\n        return self.heap\n\n    def __len__(self):\n        return len(self.heap)\n\n\nx, y, z, k = list(map(int, input().split()))\na_ls = list(map(int, input().split()))\nb_ls = list(map(int, input().split()))\nc_ls = list(map(int, input().split()))\n\na_ls.sort()\na_ls.reverse()\nb_ls.sort()\nb_ls.reverse()\nc_ls.sort()\nc_ls.reverse()\n\nheap = []\n\nq = PriorityQueue(heap)\nq.push((-(a_ls[0] + b_ls[0] + c_ls[0]), 0, 0, 0))\nconsidered = set()\nfor i in range(k):\n    val, i, j, k = q.pop()\n    print((-val))\n    for di, dj, dk in zip([1, 0, 0], [0, 1, 0], [0, 0, 1]):\n        ni = i + di\n        nj = j + dj\n        nk = k + dk\n        if ni >= x or nj >= y or nk >= z:\n            continue\n        if (ni, nj, nk) not in considered:\n            considered.add((ni, nj, nk))\n            q.push((-(a_ls[ni] + b_ls[nj] + c_ls[nk]), ni, nj, nk))\n", "import sys\nimport heapq\n\nX, Y, Z , K = map(int, sys.stdin.readline().split())\nA = sorted(list(map(int, sys.stdin.readline().split())), reverse=True)\nB = sorted(list(map(int, sys.stdin.readline().split())), reverse=True)\nC = sorted(list(map(int, sys.stdin.readline().split())), reverse=True)\n\nans_heapq = []\ni = 0\nj = 0\nk = 0\nheapq.heappush(ans_heapq, [-1 * (A[0] + B[0] + C[0]), i, j, k])\nijk_list = [[0, 0, 0]]\n            \nfor _ in range(K):\n    ans, i, j, k = heapq.heappop(ans_heapq)\n    print(-1 * ans)\n    if i < X - 1 and [i + 1, j, k] not in ijk_list:\n        abc = -1 * (A[i + 1] + B[j] + C[k])\n        heapq.heappush(ans_heapq, [abc, i + 1, j, k])\n        ijk_list.append([i + 1, j, k])\n    if j < Y - 1 and [i, j + 1, k] not in ijk_list:\n        abc = -1 * (A[i] + B[j + 1] + C[k])\n        heapq.heappush(ans_heapq, [abc, i, j + 1, k])\n        ijk_list.append([i, j + 1, k])\n    if k < Z - 1 and [i, j, k + 1] not in ijk_list:\n        abc = -1 * (A[i] + B[j] + C[k + 1])\n        heapq.heappush(ans_heapq, [abc, i, j, k + 1])\n        ijk_list.append([i, j, k + 1])", "from heapq import heappush, heappop, heappushpop, heapify, heapreplace, merge\ndef solve():\n    X, Y, Z, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    Cake = []\n    heapify(Cake)\n    for i in range(X):\n        for j in range(min(Y,K//(i+1)+1)):\n            for k in range(min(Z,K//((i+1)*(j+1))+1)):\n                heappush(Cake,-A[i]-B[j]-C[k])\n    ans = []\n    for i in range(K):\n        ans.append(abs(heappop(Cake)))\n    return ans\nprint(*solve(),sep='\\n')", "X, Y, Z, K  = map(int, input().split())\nA = sorted(list(map(int, input().split())), reverse=True)\nB = sorted(list(map(int, input().split())), reverse=True)\nC = sorted(list(map(int, input().split())), reverse=True)\n\nl = []\nfor a in A:\n    for b in B:\n        l.append(a+b)\nl = sorted(l, reverse = True)[:K]\n\nans = []\nfor c in C:\n    for k in l:\n        ans.append(c + k)\n        \nans = sorted(ans, reverse = True)\nprint(*ans[:K], sep=\"\\n\")", "import sys\ninput = sys.stdin.readline\nfrom itertools import product\n\n\ndef read():\n    X, Y, Z, K = list(map(int, input().strip().split()))\n    A = list(map(int, input().strip().split()))\n    B = list(map(int, input().strip().split()))\n    C = list(map(int, input().strip().split()))\n    return X, Y, Z, K, A, B, C\n\n\ndef solve(X, Y, Z, K, A, B, C, INF=10000000001):\n    # \u7f8e\u5473\u3057\u3055\u306e\u4e0a\u4f4dK=3000\u4ef6\u3092\u51fa\u529b\u3059\u308b\n    AB = [a+b for a, b in product(A, B)]\n    AB.sort(reverse=True)\n    AB = AB[:K]\n    C.sort(reverse=True)\n\n    D = [AB[k] + C[0] for k in range(len(AB))]\n    E = [0 for k in range(len(AB))]\n    j = 0\n    for k in range(K):\n        hi = 0\n\n        # find\n        for i in range(len(D)):\n            if D[hi] < D[i]:\n                hi = i\n        # print\n        print((D[hi]))\n\n        # update\n        E[hi] += 1\n        if E[hi] >= len(C):\n            D[hi] = -INF\n        else:\n            D[hi] = AB[hi] + C[E[hi]]\n\n\ndef __starting_point():\n    inputs = read()\n    solve(*inputs)\n\n__starting_point()", "from heapq import heappop, heappush\ndef main():\n    def push(i, j, k):\n        nonlocal A, B, C, ADD\n        if i >= x or j >= y or k >= z: return\n        if (i, j, k) not in ADD:\n            heappush(H, (A[i] + B[j] + C[k], i, j, k))\n            ADD.add((i, j, k))\n    x, y, z, k = list(map(int, input().split()))\n    INF = 10 ** 11\n    A = sorted(list([-int(x) for x in input().split()]))\n    B = sorted(list([-int(x) for x in input().split()]))\n    C = sorted(list([-int(x) for x in input().split()]))\n    H = []\n    ADD = set()\n    push(0, 0, 0)\n    for _ in range(k):\n        ans, i, j, k = heappop(H)\n        push(i + 1, j, k)\n        push(i, j + 1, k)\n        push(i, j, k + 1)\n        print((-ans))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X,Y,Z,K=list(map(int,input().split()))\nA= list(map(int,input().split()))\nB= list(map(int,input().split()))\nC= list(map(int,input().split()))\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\nans=[]\nfor i in range(min(X,K)):\n D=int(K/(i+1))+1\n for j in range(min(D,Y,K)):\n  E=int(D/(j+1))+1\n  for k in range(min(E,Z,K)):\n   ans.append(A[i]+B[j]+C[k])\nans.sort(reverse=True)\nfor i in range(K):\n print((ans[i]))\n", "X, Y, Z, K  = map(int, input().split())\nA = sorted(list(map(int, input().split())))\nB = sorted(list(map(int, input().split())))\nC = sorted(list(map(int, input().split())))\n\nl = []\nfor a in A:\n    for b in B:\n        l.append(a+b)\nl = sorted(l, reverse = True)[:K]\n\nans = []\nfor c in C:\n    for k in l:\n        ans.append(c + k)\n        \nans = sorted(ans, reverse = True)\nprint(*ans[:K], sep=\"\\n\")", "import heapq\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    def bfs():\n        used = set()\n        used.add((0, 0, 0))\n\n        q = []\n        heapq.heapify(q)\n        heapq.heappush(q, (-(A[0] + B[0] + C[0]), 0, 0, 0))\n        res = []\n        while q:\n            v, i, j, k = heapq.heappop(q)\n            res.append(-v)\n\n            if len(res) == K:\n                return res\n\n            for di, dj, dk in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n                ni = i + di\n                nj = j + dj\n                nk = k + dk\n\n                if ni >= X or nj >= Y or nk >= Z:\n                    continue\n\n                if (ni, nj, nk) in used:\n                    continue\n\n                used.add((ni, nj, nk))\n                heapq.heappush(q, (-(A[ni] + B[nj] + C[nk]), ni, nj, nk))\n\n        return res\n\n    res = bfs()\n    res.sort(reverse=True)\n    for i in range(K):\n        print((res[i]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# D - Cake 123\n\nimport heapq\nimport itertools\n\nx, y, z, k = map(int, input().split())\n\nA = list(int(a) for a in input().split())\nB = list(int(b) for b in input().split())\nC = list(int(c) for c in input().split())\n\nhq = []\nfor i, j in itertools.product(A, B):\n    heapq.heappush(hq, (i+j)*-1)\n\nAB = []\nwhile len(hq)>0 and len(AB)<=k:\n    AB.append(heapq.heappop(hq)*-1)\n\nhq = []\nfor i, j in itertools.product(AB, C):\n    heapq.heappush(hq, (i+j)*-1)\n\nfor _ in range(k):\n    print(heapq.heappop(hq)*-1)", "x, y, z, K = list(map(int, input().split()))\na = sorted(list(map(int, input().split())), reverse = True)\nb = sorted(list(map(int, input().split())), reverse = True)\nc = sorted(list(map(int, input().split())), reverse = True)\nlst = []\n\nfor i in range(len(a)):\n    for j in range(len(b)):\n        for k in range(len(c)):\n            if (i + 1) * (j + 1) * (k + 1) > K:\n                break\n            lst.append(a[i] + b[j] + c[k])\n\nnew_lst = sorted(lst, reverse = True)\nfor i in range(K):\n    print((new_lst[i]))\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    import heapq\n\n    X,Y,Z,K = i_map()\n    A = i_list()\n    B = i_list()\n    C = i_list()\n\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    Q = []\n    heapq.heappush(Q, [-(A[0]+B[0]+C[0]),0,0,0])\n    added_idx = set((0,0,0))\n\n    for i in range(K):\n        nega_ans, x,y,z = heapq.heappop(Q)\n        print(-nega_ans)\n\n        if x+1 < X and (x+1,y,z) not in added_idx:\n            heapq.heappush(Q, [-(A[x+1]+B[y]+C[z]),x+1,y,z])\n            added_idx.add((x+1,y,z))\n        if y+1 < Y and (x,y+1,z) not in added_idx:\n            heapq.heappush(Q, [-(A[x]+B[y+1]+C[z]),x,y+1,z])\n            added_idx.add((x,y+1,z))\n        if z+1 < Z and (x,y,z+1) not in added_idx:\n            heapq.heappush(Q, [-(A[x]+B[y]+C[z+1]),x,y,z+1])\n            added_idx.add((x,y,z+1))\n\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nx,y,z,k = list(map(int,input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\nal = []\n\nhq = []\nheapq.heappush(hq,(-(a[0]+b[0]+c[0]),0,0,0))\nfor i in range(k):\n    hqi,ai,bi,ci = heapq.heappop(hq)\n    print((-hqi))\n    if ai+1 < x and not (ai+1,bi,ci) in al:\n        heapq.heappush(hq,(-(a[ai+1]+b[bi]+c[ci]),ai+1,bi,ci))\n        al.append((ai+1,bi,ci))\n    if bi+1 < y and not (ai,bi+1,ci) in al:\n        heapq.heappush(hq,(-(a[ai]+b[bi+1]+c[ci]),ai,bi+1,ci))\n        al.append((ai,bi+1,ci))\n    if ci+1 < z and not (ai,bi,ci+1) in al:\n        heapq.heappush(hq,(-(a[ai]+b[bi]+c[ci+1]),ai,bi,ci+1))\n        al.append((ai,bi,ci+1))\n", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    q = []\n    heappush(q, (-(A[0]+B[0]+C[0]),0,0,0))\n    count = 0\n    used = set()\n\n    while count < K:\n        num, s,t,u = heappop(q)\n        print((-num))\n        used.add((s,t,u))\n\n        if s+1 < X and (s+1,t,u) not in used:\n            heappush(q, (-(A[s+1]+B[t]+C[u]),s+1,t,u))\n            used.add((s+1,t,u))\n        if t+1 < Y and (s,t+1,u) not in used:\n            heappush(q, (-(A[s]+B[t+1]+C[u]),s,t+1,u))\n            used.add((s,t+1,u))\n        if u+1 < Z and (s,t,u+1) not in used:\n            heappush(q, (-(A[s]+B[t]+C[u+1]),s,t,u+1))\n            used.add((s,t,u+1))\n        count += 1\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x,y,z,k=map(int,input().split())\na=sorted(list(map(int,input().split())),reverse=True)\nb=sorted(list(map(int,input().split())),reverse=True)\nc=sorted(list(map(int,input().split())),reverse=True)\n\nab=[i+j for j in b for i in a]\nab.sort(reverse=True)\nabc=[i+j for j in c[:k] for i in ab[:k]]\nabc.sort(reverse=True)\n\nprint(*abc[:k],sep='\\n')\n", "import heapq\nfrom collections import defaultdict\nx, y, z, K = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))[::-1]\nb = sorted(list(map(int, input().split())))[::-1]\nc = sorted(list(map(int, input().split())))[::-1]\n\nused = defaultdict(bool)\npq = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\nused[(0, 0, 0)] = True\nheapq.heapify(pq)\n\nfor _ in range(K):\n    d, i, j, k = heapq.heappop(pq)\n    print((-d))\n    if i + 1 < x and not used[(i + 1, j, k)]:\n        heapq.heappush(pq, (-(a[i + 1] + b[j] + c[k]), i + 1, j, k))\n        used[(i + 1, j, k)] = True\n    if j + 1 < y and not used[(i, j + 1, k)]:\n        heapq.heappush(pq, (-(a[i] + b[j + 1] + c[k]), i, j + 1, k))\n        used[(i, j + 1, k)] = True\n    if k + 1 < z and not used[(i, j, k + 1)]:\n        heapq.heappush(pq, (-(a[i] + b[j] + c[k + 1]), i, j, k + 1))\n        used[(i, j, k + 1)] = True\n", "import sys\nimport heapq\n\ninput = sys.stdin.readline\n\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split()))\n    A = list([-int(x) for x in input().split()])\n    B = list([-int(x) for x in input().split()])\n    C = list([-int(x) for x in input().split()])\n\n    A.sort()\n    B.sort()\n    C.sort()\n\n    p_queue = [(A[0] + B[0] + C[0], 0, 0, 0)]\n    visited = set()\n    visited.add((0, 0, 0))\n    ans = []\n    while len(ans) < K:\n        s, i_A, i_B, i_C = heapq.heappop(p_queue)\n        ans.append(-s)\n        if i_A < X - 1 and (i_A + 1, i_B, i_C) not in visited:\n            visited.add((i_A + 1, i_B, i_C))\n            t = s - A[i_A] + A[i_A + 1]\n            heapq.heappush(p_queue, (t, i_A + 1, i_B, i_C))\n        if i_B < Y - 1 and (i_A, i_B + 1, i_C) not in visited:\n            visited.add((i_A, i_B + 1, i_C))\n            t = s - B[i_B] + B[i_B + 1]\n            heapq.heappush(p_queue, (t, i_A, i_B + 1, i_C))\n        if i_C < Z - 1 and (i_A, i_B, i_C + 1) not in visited:\n            visited.add((i_A, i_B, i_C + 1))\n            t = s - C[i_C] + C[i_C + 1]\n            heapq.heappush(p_queue, (t, i_A, i_B, i_C + 1))\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X,Y,Z,K=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nC=list(map(int,input().split()))\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\nans=[]\nfor i in range(X):\n    for j in range(Y):\n        for k in range(Z):\n            if (i+1)*(j+1)*(k+1)>K:\n                break\n            else:\n                ans.append(A[i]+B[j]+C[k])\nans.sort(reverse=True)\nfor i in range(K):\n    print(ans[i])", "# O(klog(k))\u89e3\u6cd5 \u591a\u5206...\nimport sys\nfrom heapq import heappush,heapify,heappop\ninput = sys.stdin.readline\n\ndef make_kth(A, B, k):\n    n, m = len(A), len(B)\n    q = [(-A[0] - B[0], 0, 0)]\n    r=[]\n    for _ in range(min(k, n * m)):\n        v, s, t = heappop(q)\n        r.append(-v)\n        if t + 1 < m:\n            heappush(q, (-A[s] - B[t + 1], s, t + 1))\n        if t == 0 and s + 1 < n:\n            heappush(q, (-A[s + 1] - B[0], s + 1, 0))\n    return r\n\ndef main():\n    _, _, _, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    a.sort(reverse=1)\n    b.sort(reverse=1)\n    c.sort(reverse=1)\n\n    r = make_kth(a, b, k)\n    r = make_kth(c, r, k)\n    print(*r, sep=\"\\n\")\n\nmain()", "import sys\ninput = sys.stdin.readline\nimport heapq\nfrom collections import defaultdict\n\n\ndef read():\n    X, Y, Z, K = list(map(int, input().strip().split()))\n    A = list(map(int, input().strip().split()))\n    B = list(map(int, input().strip().split()))\n    C = list(map(int, input().strip().split()))\n    return X, Y, Z, K, A, B, C\n\n\ndef solve(X, Y, Z, K, A, B, C, INF=10000000001):\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    \n    used = defaultdict(bool)\n    h = []\n    p, q, r = 0, 0, 0\n    heapq.heappush(h, (-A[p] - B[q] - C[r], p, q, r))\n    used[(p, q, r)] = True\n    for k in range(K):\n        a, p, q, r = heapq.heappop(h)\n        print((-a))\n        if p+1 < len(A) and not used[(p+1, q, r)]:\n            heapq.heappush(h, (-A[p+1] - B[q] - C[r], p+1, q, r))\n            used[(p+1, q, r)] = True\n        if q+1 < len(B) and not used[(p, q+1, r)]:\n            heapq.heappush(h, (-A[p] - B[q+1] - C[r], p, q+1, r))\n            used[(p, q+1, r)] = True\n        if r+1 < len(C) and not used[(p, q, r+1)]:\n            heapq.heappush(h, (-A[p] - B[q] - C[r+1], p, q, r+1))\n            used[(p, q, r+1)] = True\n\n\ndef __starting_point():\n    inputs = read()\n    solve(*inputs)\n\n__starting_point()", "\nX, Y, Z, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nABC = []\nfor x in range(X):\n    for y in range(Y):\n        for z in range(Z):\n            if (x+1)*(y+1)*(z+1) <= K:\n                ABC.append(A[x]+B[y]+C[z])\n            else:\n                break\n\nABC.sort(reverse=True)\nfor i in range(K):\n    print(ABC[i])", "import numpy as np\nfrom collections import deque\nfrom collections import defaultdict\nimport heapq\nimport collections\nimport itertools\nimport bisect\n\nX, Y, Z, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\nA = sorted(A, reverse=True)\nB = sorted(B, reverse=True)\nC = sorted(C, reverse=True)\ni, j, k = 0, 0, 0\nheap = [(-A[i] - B[j] - C[k], i, j, k)]\nheapq.heapify(heap)\nused_set = set([(i, j, k)])\nfor _ in range(K):\n    oisi, i, j, k = heapq.heappop(heap)\n    print((-oisi))\n    if (i+1, j, k) in used_set:\n        pass\n    elif(i+1 < len(A)):\n        used_set.add((i+1, j, k))\n        heapq.heappush(heap, (-A[i+1]-B[j]-C[k], i+1, j, k))\n    if (i, j+1, k) in used_set:\n        pass\n    elif(j+1 < len(B)):\n        used_set.add((i, j+1, k))\n        heapq.heappush(heap, (-A[i] - B[j+1] - C[k], i, j+1, k))\n    if (i, j, k+1) in used_set:\n        pass\n    elif(k+1 < len(C)):\n        used_set.add((i, j, k+1))\n        heapq.heappush(heap, (-A[i]-B[j]-C[k+1], i, j, k+1))\n", "from heapq import heappush, heapify, heappop\n\ndef main():\n    X, Y, Z, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    \n    que = []\n    heapify(que)\n    heappush(que, (-A[0]-B[0]-C[0], 0, 0, 0))\n    s = set()\n    \n    for i in range(K):\n        ans = heappop(que)\n        print(-ans[0])\n        if(ans[1] < X-1 and not (ans[1]+1, ans[2], ans[3]) in s):\n            heappush(que, [-A[ans[1]+1]-B[ans[2]]-C[ans[3]], ans[1]+1, ans[2], ans[3]])\n            s.add((ans[1]+1, ans[2], ans[3]))\n        if(ans[2] < Y-1 and not (ans[1], ans[2]+1, ans[3]) in s):\n            heappush(que, [-A[ans[1]]-B[ans[2]+1]-C[ans[3]], ans[1], ans[2]+1, ans[3]])\n            s.add((ans[1], ans[2]+1, ans[3]))\n        if(ans[3] < Z-1 and not (ans[1], ans[2], ans[3]+1) in s):\n            heappush(que, [-A[ans[1]]-B[ans[2]]-C[ans[3]+1], ans[1], ans[2], ans[3]+1])\n            s.add((ans[1], ans[2], ans[3]+1))   \nmain()", "def main():\n    import heapq\n    from collections import defaultdict\n\n    x, y, z, k, *abc = map(int, open(0).read().split())\n    a = abc[:x]\n    b = abc[x:x + y]\n    c = abc[x + y:]\n    d = defaultdict(list)\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n\n    h = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]\n    heapq.heapify(h)\n    ans = []\n    for _ in range(k):\n        p, i, j, k = heapq.heappop(h)\n        ans.append(-p)\n        for p, q, r in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n            if i + p < x and j + q < y and k + r < z:\n                if (j + q, k + r) not in d[i + p]:\n                    d[i + p].append((j + q, k + r))\n                    v = - (a[i + p] + b[j + q] + c[k + r])\n                    heapq.heappush(h, (v, i + p, j + q, k + r))\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappush, heappop\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    X, Y, Z, K = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    B = list(map(int, readline().split()))\n    C = list(map(int, readline().split()))\n\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    hq = [(-(A[0] + B[0] + C[0]), 0, 0, 0)]\n    seen = set()\n    ans = []\n    while len(ans) < K:\n        s, i, j, k = heappop(hq)\n        ans.append(-s)\n        if i < X - 1 and (i + 1, j, k) not in seen:\n            heappush(hq, (-(A[i + 1] + B[j] + C[k]), i + 1, j, k))\n            seen.add((i + 1, j, k))\n        if j < Y - 1 and (i, j + 1, k) not in seen:\n            heappush(hq, (-(A[i] + B[j + 1] + C[k]), i, j + 1, k))\n            seen.add((i, j + 1, k))\n        if k < Z - 1 and (i, j, k + 1) not in seen:\n            heappush(hq, (-(A[i] + B[j] + C[k + 1]), i, j, k + 1))\n            seen.add((i, j, k + 1))\n\n    print(('\\n'.join(map(str, ans))))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom itertools import product\nimport sys\ntry:\n    from typing import List\nexcept ImportError:\n    pass\n\n\ndef solve(\n        X: int, Y: int, Z: int, K: int,\n        A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    z = [0]\n\n    def f(a: \"List[int]\"):\n        nonlocal z\n        a.sort(reverse=True)\n        z = [zi + ai for zi, ai in product(z, a[:K])]\n        z.sort(reverse=True)\n        z = z[:K]\n\n    f(A)\n    f(B)\n    f(C)\n    for zi in z:\n        print(zi)\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    X = int(next(tokens))  # type: int\n    Y = int(next(tokens))  # type: int\n    Z = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(X)]  # type: \"List[int]\"\n    B = [int(next(tokens)) for _ in range(Y)]  # type: \"List[int]\"\n    C = [int(next(tokens)) for _ in range(Z)]  # type: \"List[int]\"\n    solve(X, Y, Z, K, A, B, C)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappop, heappush\n\n# \u5165\u529b\u306e\u53d7\u4ed8\nX, Y, Z, K = list(map(int, input().split()))\na_list = list(map(int, input().split()))\nb_list = list(map(int, input().split()))\nc_list = list(map(int, input().split()))\n\n# \u5165\u529b\u914d\u5217\u306e\u30bd\u30fc\u30c8(\u964d\u9806: \u5927\u304d\u3044\u5024\u304c\u5148\u982d)\na_list.sort(reverse = True)\nb_list.sort(reverse = True)\nc_list.sort(reverse = True)\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306e\u5b9a\u7fa9\nhq = []\n\n# \u30ad\u30e5\u30fc\u306e\u7ba1\u7406\u30ea\u30b9\u30c8\narg_hash = {}\n\n# \u30ad\u30e5\u30fc\u306e\u521d\u671f\u5024\nval = -(a_list[0] + b_list[0] + c_list[0])\nheappush(hq, (val, 0, 0, 0))\n\n# \u7b54\u3048\u3092\u683c\u7d0d\u3059\u308b\u914d\u5217\nans_arr = []\n\n# \u6700\u5927\u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u3044\u304f\uff0e\n# \u4ee5\u4e0b\u3092K\u56de\u7e70\u308a\u8fd4\u3059\n# 1. -(A+B+C)\u3092\u8981\u7d20\u3068\u3059\u308b\u30ad\u30e5\u30fc\u306e\u4e2d\u306e\u6700\u5c0f\u5024\u3092\u53d6\u308a\u51fa\u3059\uff0e(i\u756a\u76ee\u306b\u5c0f\u3055\u3044\u6570) \u3053\u306e\u6700\u5c0f\u5024\u306f(A,B,C)\u306e\u5404\u30ea\u30b9\u30c8\u306e(p,q,r)\u756a\u76ee\u306e\u30ea\u30b9\u30c8\u306b\u542b\u307e\u308c\u308b\u5024\uff0e\n# 2\uff0e\u3053\u306e\u30ad\u30e5\u30fc\u306b\u5bfe\u3057\u3066(p+1, q, r), (p, q+1, r), (p, q, r+1)\u306e\u305d\u308c\u305e\u308c\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\n#     \u306a\u3044\u5834\u5408\u306b\u306f\uff0c\u30ad\u30e5\u30fc\u306e\u7ba1\u7406\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0 & \u30ad\u30e5\u30fc\u306b\u305d\u306e\u8981\u7d20\u3092\u8ffd\u52a0\n#     \u3042\u308b\u5834\u5408\u306b\u306f\uff0c\u7279\u306b\u4f55\u3082\u305b\u305a\uff0e\nfor i in range(K):\n    # \u30ad\u30e5\u30fc\u304b\u3089\u6700\u5c0f\u5024\u3092\u53d6\u308a\u51fa\u3059(\u8ca0\u306a\u306e\u3067\u5b9f\u969b\u306f\u6700\u5927\u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u3044\u308b)\n    ans_val, p, q, r = heappop(hq)\n    ans_arr.append(-ans_val)\n    \n    # (p+1, q, r), (p, q+1, r), (p, q, r+1)\u306e\u305d\u308c\u305e\u308c\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\n    arg_a = (p+1, q, r)\n    arg_b = (p, q+1, r)\n    arg_c = (p, q, r+1)\n\n    # \u30ad\u30e5\u30fc\u306e\u7ba1\u7406\u30ea\u30b9\u30c8\u306b\u5bfe\u3057\u3066\uff0c\u4e0a\u306e\u8981\u7d20\u304c\u5b58\u5728\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u63a2\u7d22\u3068\u51e6\u7406\n    # a < X-1 \u306f\uff0c\u5168\u8981\u7d20\u304c\u30ad\u30e5\u30fc\u306b\u5165\u3063\u3066\u3044\u308b\u5834\u5408\u306b\uff0c\u3055\u3089\u306b\u6b21\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8981\u7d20\u3092\u8ffd\u52a0\u3057\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u305f\u3081\u306e\u691c\u7d22\u6761\u4ef6\n    # p+1 \u7528\n    if (p < X-1) and (arg_a not in arg_hash):\n        # \u30ad\u30e5\u30fc\u7ba1\u7406\u30ea\u30b9\u30c8\u306b(p+1, q, r)\u306e\u30bf\u30d7\u30eb\u3092\u767b\u9332\uff08\u8f9e\u66f8\u30ad\u30fc\u3068\u3057\u3066\uff09\n        arg_hash[arg_a] = 1\n        # \u30ad\u30e5\u30fc\u306b\u5024\u3092\u767b\u9332\n        heappush(hq, (-(a_list[p+1] + b_list[q] + c_list[r]), ) + arg_a)\n    # q+1 \u7528\n    if (q < Y-1) and (arg_b not in arg_hash):\n        # \u30ad\u30e5\u30fc\u7ba1\u7406\u30ea\u30b9\u30c8\u306b(p+1, q, r)\u306e\u30bf\u30d7\u30eb\u3092\u767b\u9332\uff08\u8f9e\u66f8\u30ad\u30fc\u3068\u3057\u3066\uff09\n        arg_hash[arg_b] = 1\n        # \u30ad\u30e5\u30fc\u306b\u5024\u3092\u767b\u9332\n        heappush(hq, (-(a_list[p] + b_list[q+1] + c_list[r]), ) + arg_b)\n    # r+1 \u7528\n    if (r < Z-1) and (arg_c not in arg_hash):\n        # \u30ad\u30e5\u30fc\u7ba1\u7406\u30ea\u30b9\u30c8\u306b(p+1, q, r)\u306e\u30bf\u30d7\u30eb\u3092\u767b\u9332\uff08\u8f9e\u66f8\u30ad\u30fc\u3068\u3057\u3066\uff09\n        arg_hash[arg_c] = 1\n        # \u30ad\u30e5\u30fc\u306b\u5024\u3092\u767b\u9332\n        heappush(hq, (-(a_list[p] + b_list[q] + c_list[r+1]), ) + arg_c)\n\n# \u7d50\u679c\u51fa\u529b\nfor i in range(len(ans_arr)):\n    print((ans_arr[i]))\n", "from heapq import *  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\ndef solve():\n  X, Y, Z, K = map(int, input().split())\n  A = list(map(int, input().split()))\n  B = list(map(int, input().split()))\n  C = list(map(int, input().split()))\n  A.sort(reverse=True)\n  B.sort(reverse=True)\n  C.sort(reverse=True)\n  a = []\n  heapify(a)\n  ans = []\n  for i in range(X):\n    for j in range(Y):\n      if (i+1)*(j+1)>K:\n        break\n      for k in range(Z):\n        if (i+1)*(j+1)*(k+1)>K:\n          break\n        heappush(a,-A[i]-B[j]-C[k])\n  for _ in range(K):\n    ans.append(-heappop(a))\n  return ans\nprint(*solve(),sep='\\n')", "import heapq\n\nx, y, z, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())), reverse=True)\nb = sorted(list(map(int, input().split())), reverse=True)\nc = sorted(list(map(int, input().split())), reverse=True)\n\nque = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\nis_pushed = {(0, 0, 0): 1}\nfor _ in range(k):\n    v, p, q, r = heapq.heappop(que)\n    print((-v))\n    if p+1 < x and not is_pushed.get((p+1, q, r)):\n        heapq.heappush(que, (-(a[p+1]+b[q]+c[r]), p+1, q, r))\n        is_pushed[(p+1, q, r)] = 1\n    if q+1 < y and not is_pushed.get((p, q+1, r)):\n        heapq.heappush(que, (-(a[p]+b[q+1]+c[r]), p, q+1, r))\n        is_pushed[(p, q+1, r)] = 1\n    if r+1 < z and not is_pushed.get((p, q, r+1)):\n        heapq.heappush(que, (-(a[p]+b[q]+c[r+1]), p, q, r+1))\n        is_pushed[(p, q, r+1)] = 1\n", "import heapq\nX, Y, Z, K = map(int,input().split())\nA = list(map(lambda x: -1 * int(x),input().split()))\nB = list(map(lambda x: -1 * int(x),input().split()))\nC = list(map(lambda x: -1 * int(x),input().split()))\nA.sort()\nB.sort()\nC.sort()\nQ = []\nheapq.heappush(Q, (A[0] + B[0] + C[0], 0, 0, 0))\nfor _ in range(K):\n    SUM, a, b, c = heapq.heappop(Q)\n    print(-1 * SUM)\n    if a <= X - 2 and not (A[a+1] + B[b] + C[c], a+1, b, c) in Q:\n        heapq.heappush(Q, (A[a+1] + B[b] + C[c], a+1, b, c))\n    if b <= Y - 2 and not (A[a] + B[b+1] + C[c], a, b+1, c) in Q:\n        heapq.heappush(Q, (A[a] + B[b+1] + C[c], a, b+1, c))\n    if c <= Z - 2 and not (A[a] + B[b] + C[c+1], a, b, c+1) in Q:\n        heapq.heappush(Q, (A[a] + B[b] + C[c+1], a, b, c+1))", "from heapq import heappush, heappop\nfrom collections import defaultdict\n\n\ndef main():\n    X, Y, Z, K = list(map(int, input().split(' ')))\n    A = list(map(int, input().split(' ')))\n    B = list(map(int, input().split(' ')))\n    C = list(map(int, input().split(' ')))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    que = [(- A[0] - B[0] - C[0], 0, 0, 0)]  # multiply -1 to change min to max\n    already_inserted = defaultdict(int)\n    answer = list()\n    for _ in range(K):\n        q, i, j, k = heappop(que)\n        answer.append(-q)\n        if i + 1 < X:\n            item_a = (- A[i + 1] - B[j] - C[k], i + 1, j, k)\n            if already_inserted[item_a] == 0:\n                heappush(que, item_a)\n                already_inserted[item_a] = 1\n        if j + 1 < Y:\n            item_b = (- A[i] - B[j + 1] - C[k], i, j + 1, k)\n            if already_inserted[item_b] == 0:\n                heappush(que, item_b)\n                already_inserted[item_b] = 1\n        if k + 1 < Z:\n            item_c = (- A[i] - B[j] - C[k + 1], i, j, k + 1)\n            if already_inserted[item_c] == 0:\n                heappush(que, item_c)\n                already_inserted[item_c] = 1\n    for ans in answer:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappop, heappush\n\nX, Y, Z, K = list(map(int, input().split()))\na_list = list(map(int, input().split()))\nb_list = list(map(int, input().split()))\nc_list = list(map(int, input().split()))\n\na_list.sort(reverse=True)\nb_list.sort(reverse=True)\nc_list.sort(reverse=True)\n\nh = []\na = a_list[0]\nb = b_list[0]\nc = c_list[0]\nheappush(h, (-(a + b + c), 0, 0, 0))\n\nkey_dict = dict()\nkey_dict[(0, 0, 0)] = 1\n\nans_list = []\nfor i in range(K):\n    ans, a, b, c = heappop(h)\n    ans_list.append(-ans)\n    a1 = (a + 1, b, c)\n    b1 = (a, b + 1, c)\n    c1 = (a, b, c + 1)\n    if a + 1 < X and not a1 in key_dict:\n        heappush(h, (-(a_list[a + 1] + b_list[b] + c_list[c]), a + 1, b, c))\n        key_dict[(a + 1, b, c)] = 1\n    if b + 1 < Y and not b1 in key_dict:\n        heappush(h, (-(a_list[a] + b_list[b + 1] + c_list[c]), a, b + 1, c))\n        key_dict[(a, b + 1, c)] = 1\n    if c + 1 < Z and not c1 in key_dict:\n        heappush(h, (-(a_list[a] + b_list[b] + c_list[c + 1]), a, b, c + 1))\n        key_dict[(a, b, c + 1)] = 1\nfor ans in ans_list:\n    print(ans)\n", "# D - Cake 123\n\nimport heapq\nimport itertools\nfrom collections import defaultdict\n\nx, y, z, k = list(map(int, input().split()))\n\nA = list(int(a) for a in input().split())\nB = list(int(b) for b in input().split())\nC = list(int(c) for c in input().split())\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nhq = []\nhqAns = []\nd = defaultdict(int)\n\nheapq.heappush(hq, ((A[0]+B[0]+C[0])*-1,(0,0,0)))\nd[(0,0,0)] = 1\n\nwhile len(hqAns)<k :\n    val, key = heapq.heappop(hq)\n    heapq.heappush(hqAns, val)\n \n    if d[(key[0]+1, key[1], key[2])]==0 and key[0]+1 < x:\n        heapq.heappush(hq, ((A[key[0]+1]+B[key[1]]+C[key[2]])*-1, ((key[0]+1, key[1], key[2]))))\n        d[(key[0]+1, key[1], key[2])] = 1\n\n    if d[(key[0], key[1]+1, key[2])]==0 and key[1]+1 < y:\n        heapq.heappush(hq, ((A[key[0]]+B[key[1]+1]+C[key[2]])*-1, ((key[0], key[1]+1, key[2]))))\n        d[(key[0], key[1]+1, key[2])] = 1\n \n    if d[(key[0], key[1], key[2]+1)]==0 and key[2]+1 < z:\n        heapq.heappush(hq, ((A[key[0]]+B[key[1]]+C[key[2]+1])*-1, ((key[0], key[1], key[2]+1))))\n        d[(key[0], key[1], key[2]+1)] = 1\n\nfor i in range(k):\n    print((heapq.heappop(hqAns)*-1))\n\n'''\n# ans.2 #\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nhq = []\nfor i in range(x):\n    for j in range(y):\n        for l in range(z):\n            if (i+1)*(j+1)*(l+1)<=k:\n                heapq.heappush(hq, (A[i]+B[j]+C[l])*-1)\n            else:\n                break\n\nfor _ in range(k):\n    print(heapq.heappop(hq)*-1)\n\n'''\n\n'''\n\n# ans.1 #\n\nhq = []\nfor i, j in itertools.product(A, B):\n    heapq.heappush(hq, (i+j)*-1)\n\nAB = []\nwhile len(hq)>0 and len(AB)<=k:\n    AB.append(heapq.heappop(hq)*-1)\n\nhq = []\nfor i, j in itertools.product(AB, C):\n    heapq.heappush(hq, (i+j)*-1)\n\nfor _ in range(k):\n    print(heapq.heappop(hq)*-1)\n\n'''\n", "import heapq\nx,y,z,k = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\nq = []\ns = set()\nheapq.heappush(q,(-a[0]-b[0]-c[0],0,0,0))\n\nfor i in range(k):\n    ans,ai,bi,ci = heapq.heappop(q)\n    print(-ans)\n    if ai < x-1 and ((ai+1, bi, ci) not in s):\n        heapq.heappush(q, (-a[ai+1]-b[bi]-c[ci],ai+1,bi,ci))\n        s.add((ai+1, bi, ci))\n    if bi < y-1 and ((ai, bi+1, ci) not in s):\n        heapq.heappush(q, (-a[ai]-b[bi+1]-c[ci],ai,bi+1,ci))\n        s.add((ai, bi+1, ci))\n    if ci < z-1 and ((ai, bi, ci+1) not in s):\n        heapq.heappush(q, (-a[ai]-b[bi]-c[ci+1],ai,bi,ci+1))\n        s.add((ai, bi, ci+1))", "from heapq import heappop,heappush\n\nX,Y,Z,K=map(int,input().split())\nA=sorted(list(map(int,input().split())),reverse=True)\nB=sorted(list(map(int,input().split())),reverse=True)\nC=sorted(list(map(int,input().split())),reverse=True)\n\nl=[]\nfor a in A:\n  for b in B:\n    l.append(-a-b)\n\nl.sort()\nl=l[:K] if len(l)>=K else l+[0]*(K-len(l))\nans=[]\nfor c in C:\n  for i in l:\n    heappush(ans,i-c)\n    \nfor i in range(K):\n  print(-heappop(ans))", "import heapq\nx,y,z,k = list(map(int,input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\nal = []\n\nhq = []\nheapq.heappush(hq,(-(a[0]+b[0]+c[0]),0,0,0))\nfor i in range(k):\n    hqi,ai,bi,ci = heapq.heappop(hq)\n    print((-hqi))\n    if ai+1 < x and not (ai+1,bi,ci) in al:\n        heapq.heappush(hq,(-(a[ai+1]+b[bi]+c[ci]),ai+1,bi,ci))\n        al.append((ai+1,bi,ci))\n    if bi+1 < y and not (ai,bi+1,ci) in al:\n        heapq.heappush(hq,(-(a[ai]+b[bi+1]+c[ci]),ai,bi+1,ci))\n        al.append((ai,bi+1,ci))\n    if ci+1 < z and not (ai,bi,ci+1) in al:\n        heapq.heappush(hq,(-(a[ai]+b[bi]+c[ci+1]),ai,bi,ci+1))\n        al.append((ai,bi,ci+1))\n", "from heapq import *\nx,y,z,k = map(int,input().split())\nA,B,C = [list(map(int,input().split())) for n in range(3)]\nD = nlargest(k,(a+b for a in A for b in B))\nE = nlargest(k,(d+c for d in D for c in C))\nprint(\"\\n\".join(map(str,E)))", "\"\"\"\npriority-queue\n\"\"\"\nimport copy\n\n\nnum_list=list(map(int,input('').split(' ')))\nrank=num_list[3]\nlists=[]\nqueue=[]\nfor i in range(3):\n    a_list=list(map(int,input('').split(' ')))\n    list.sort(a_list,reverse=True)\n    if num_list[i]<=rank:\n        lists.append(a_list)\n    else:\n        lists.append(a_list[:rank])    \nqueue.append([lists[0][0]+lists[1][0]+lists[2][0],0,0,0])   \n#ret=[] \nfor i in range(rank):\n    poped=queue.pop(0)\n    #print(str(i+1)+\":\"+str(poped[0]))\n    print((poped[0]))\n    if i==rank-1:\n        break\n    for j in range(3):\n        if len(lists[j])>poped[j+1]+1:\n            to_append=copy.copy(poped)\n            to_append[j+1]+=1\n            to_append[0]+=-lists[j][poped[j+1]]+lists[j][to_append[j+1]]\n            if len(queue)==0:\n                queue.append(to_append)  \n                continue\n            Done=True\n            for k in range(len(queue)):\n                #print(\"to cmp\")\n                #print(queue[k],to_append)\n                if queue[k]==to_append:\n                    Done=False\n                    break\n                elif queue[k][0]<to_append[0]:\n                    queue=queue[:k]+[to_append]+queue[k:]\n                    Done=False\n                    break\n            #print(Done)    \n            if Done==True:\n                queue.append(to_append)    \n            #print(\"print Queue\")\n            #for k in range(len(queue)):\n            #    print(queue[k])\n    if len(queue)>rank-i:\n        queue=queue[:(rank-i-1)]\n        #print(\"cut\")\n    #print(\"print Queue\")    \n    #for j in range(len(queue)):\n    #            print(queue[j])    \n\n\n", "x,y,z,k=map(int,input().split())\na=sorted(list(map(int,input().split())),reverse=True)\nb=sorted(list(map(int,input().split())),reverse=True)\nc=sorted(list(map(int,input().split())),reverse=True)\n\nab=[i+j for j in b for i in a]\nab.sort(reverse=True)\nabc=[i+j for j in c[:k] for i in ab[:k]]\nabc.sort(reverse=True)\n\nprint(*abc[:k],sep='\\n')\n", "x, y, z, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())), reverse=True)\nb = sorted(list(map(int, input().split())), reverse=True)\nc = sorted(list(map(int, input().split())), reverse=True)\nans = []\nfor i in range(x):\n    for j in range(y):\n        for l in range(z):\n            if (i+1) * (j+1) * (l+1) <= k:\n                ans.append(a[i] + b[j] + c[l])\n            else:\n                break\nans.sort(reverse=True)\nfor i in range(k):\n    print((ans[i]))\n", "from heapq import heappop, heappush\n\nx, y, z, k = [int(i) for i in input().split()]\n\na_list = sorted([-int(i) for i in input().split()])\nb_list = sorted([-int(i) for i in input().split()])\nc_list = sorted([-int(i) for i in input().split()])\n\nhq = []\nflag_set = set()\n\nheappush(hq, (a_list[0] + b_list[0] + c_list[0], 0, 0, 0))\nflag_set.add((0, 0, 0))\nfor _ in range(k):\n    d, ai, bi, ci = heappop(hq)\n    print(-d)\n    \n    temp = (ai + 1, bi, ci)\n    if temp[0] < x and temp not in flag_set:\n        heappush(hq, (a_list[ai + 1] + b_list[bi] + c_list[ci], ai + 1, bi, ci))\n        flag_set.add(temp)\n    \n    temp = (ai, bi + 1, ci)\n    if temp[1] < y and temp not in flag_set:\n        heappush(hq, (a_list[ai] + b_list[bi + 1] + c_list[ci], ai, bi + 1, ci))\n        flag_set.add(temp)\n\n    temp = (ai, bi, ci + 1)\n    if temp[2] < z and temp not in flag_set:\n        heappush(hq, (a_list[ai] + b_list[bi] + c_list[ci + 1], ai, bi, ci + 1))\n        flag_set.add(temp)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nimport numpy as np\nx,y,z,K = list(map(int, input().split()))\na = np.array(list(map(int, input().split())), dtype=np.int64)\nb = np.array(list(map(int, input().split())), dtype=np.int64)\nc = np.array(list(map(int, input().split())), dtype=np.int64)\nab = (a + b.reshape(-1,1)).reshape(-1)\nab.sort()\nc.sort()\nabk = ab[-K:]\nck = c[-K:]\nl = (abk + ck.reshape(-1,1)).reshape(-1)\nl.sort()\nl = l[::-1]\nwrite(\"\\n\".join(map(str, l[:K])))"]
["from itertools import accumulate\nfrom bisect import bisect_right\nimport sys\n\nn, q = list(map(int, sys.stdin.readline().split()))\na = list(map(int, sys.stdin.readline().split()))\nk = list(map(int, sys.stdin.readline().split()))\n\ns = list(accumulate(a))\n\nsofar = 0\nfor x in k:\n    sofar += x\n    if sofar >= s[-1]:\n        sofar = 0\n    sys.stdout.write(str(n - bisect_right(s, sofar)) + '\\n')\n", "import sys\nimport math\nimport bisect\nimport itertools\n\nn,q = list(map(int,sys.stdin.readline().strip().split(' ')))\na = list(map(int,sys.stdin.readline().strip().split(' ')))\nprefix_sum = list(itertools.accumulate(a))\nk = list(map(int,sys.stdin.readline().strip().split(' ')))\n\nk_sum = 0\nfor q0 in range(q):\n\tk_sum += k[q0]\n\tidx = bisect.bisect_left(prefix_sum, k_sum)\n\tif idx < n and prefix_sum[idx] == k_sum:\n\t\tidx += 1\n\tif idx == n:\n\t\tprint(n)\n\t\tk_sum = 0\n\telse:\n\t\tprint(n-idx)\n", "from bisect import bisect_right\n\nN, Q = map(int, input().split())\nA = list(map(int, input().split()))\nK = list(map(int, input().split()))\n\nfor i in range(1, N):\n    A[i] += A[i-1]\n\nans = []\nplus = 0\nfor q in range(Q):\n    idx = bisect_right(A, K[q]+plus)\n    if idx == N:\n        ans.append(N)\n        plus = 0\n    else:\n        ans.append(N-idx)\n        plus += K[q]\n\nfor q in range(Q):\n    print(ans[q])", "import bisect\n\nN,Q = list(map(int,input().split()))\nws = list(map(int,input().split()))\nqs = list(map(int,input().split()))\n\ncums = [0]\nfor w in ws:\n    cums.append(cums[-1] + w)\n\ndamage = 0\nfor q in qs:\n    damage += q\n    if damage >= cums[-1]:\n        damage = 0\n        print(N)\n    else:\n        i = bisect.bisect(cums,damage)\n        print(N-i+1)\n", "import bisect\n\nn, q = list(map(int, input().split()))\na, k, curA, curK = [], [], 0, 0\n\nfor s in input().split():\n    curA += int(s)\n    a.append(curA)\n\nfor s in input().split():\n    curK += int(s)\n    index = bisect.bisect(a, curK)\n\n    if index == n:\n        print(n)\n        curK = 0\n    else:\n        print(n - index)\n    \n", "from bisect import bisect\nn,q=map(int,input().split())\na=list(map(int,input().split()))\na.reverse()\ns=sum(a)\nfor i in range(1,n):\n\ta[i]+=a[i-1]\nk=list(map(int,input().split()))\ntmp=0\nfor i in range(q):\n\ttmp+=k[i]\n\tif tmp>=s: tmp=0\n\tprint(bisect(a,s-tmp-1)+1)", "import bisect\n\nn, q = [int(v) for v in input().split()]\nva = [int(v) for v in input().split()]\nvk = [int(v) for v in input().split()]\n\nfor i in range(1, n):\n    va[i] += va[i - 1]\n\nans = []\ncurr = 0\nfor k in vk:\n    curr += k\n    it = bisect.bisect_right(va, curr)\n    if it == n:\n        ans.append(n)\n        curr = 0\n    else:\n        ans.append(n - it)\n\nprint('\\n'.join(str(v) for v in ans))\n", "from bisect import bisect_right as br\n\nn, q = list(map(int, input().split()))\nstn = list(map(int, input().split()))\narro = list(map(int, input().split()))\n\ncum = []\ns = 0\nfor i in range(n):\n    s += stn[i]\n    cum.append(s)\n\ns1 = 0\nans = 0\nfor i in range(q):\n    if ans == 0:\n        s1 = arro[i]\n    else:\n        s1 += arro[i]\n    ind = br(cum, s1)\n    ans = n - ind\n    if ans == 0:\n        print(n)\n    else:\n        print(ans)\n    \n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Apr 27 00:39:17 2018\n\n@author: shubham\n\"\"\"\ndef Low(a, l, r, x):\n    while l<r:\n        mid = (l+r)//2\n        if a[mid] >= x:\n            r = mid\n        else:\n            l = mid+1\n    if a[l]<=x:\n        return l\n    else:\n        return l-1\n\n\nn, q = list(map(int, input().split()))\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\np = [0]*n\np[0] = a[0]\nfor i in range(1, n):\n    p[i]=p[i-1]+a[i]\nt = 0\nfor i in range(q):\n    t+=k[i]\n    ans = Low(p, 0, n-1, t)\n    if ans == -1 or ans == n-1:\n        print(n)\n    else:\n        print(n-ans-1)\n    if ans == n-1:\n        t = 0\n    \n", "from bisect import bisect_left\nfrom itertools import accumulate\n\nn,q = input().split()\n\nn = int(n)\nq = int(q)\n\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\nreqArrows = sum(a)\nprevArrows = 0\naccuA = list(accumulate(a))\naccuK = list(accumulate(k))\n\nfor i in range(q):\n\tprevArrows += k[i]\n\tif prevArrows >= reqArrows:\n\t\tprint(n)\n\t\tprevArrows = 0\n\telse:\n\t\tx = bisect_left(accuA,  prevArrows)\n\t\tif accuA[x] == prevArrows:\n\t\t\tprint(n-x-1)\n\t\telse:\n\t\t\tprint(n-x)", "import bisect\n\ndef find_ge(a, key):\n    '''Find smallest item greater-than or equal to key.\n    Raise ValueError if no such item exists.\n    If multiple keys are equal, return the leftmost.\n    '''\n    i = bisect.bisect_left(a, key)\n    if i == len(a):\n        return -1\n    return i\n\nn, q = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nk = [int(x) for x in input().split()]\nresult = [0] * (q+1)\nresult[0] = n\ns = [0]*n\ns[0] = a[0]\nfor i in range(1, n):\n    s[i] = s[i-1] + a[i]\n\nremain = 0\nattack = 0\nfor i in range(1, q + 1):\n    attack += k[i-1]\n\n    ge = find_ge(s, attack)\n\n    if ge >= 0:\n        remain = s[ge] - attack\n        #print(remain, s[ge], i)\n        if remain > 0: result[i] = n-ge\n        else: result[i] = n-ge-1\n        if result[i] == 0:\n            result[i] = n\n            attack = 0\n    else:\n        result[i] = n\n        attack = 0\n        remain = 0\n    '''\n    else:\n        # all soldiers died\n        remain -= k[i-1]\n        attack = 0\n        if remain > 0: result[i] = n-ge\n        else: result[i] = n-ge-1\n    '''\n\nprint('\\n'.join(str(x) for x in result[1:]))\n", "import bisect\n\nn,q=list(map(int,input().split()))\na=list(map(int,input().split()))\ns=[0,]\nfor i in a:\n    s.append(s[-1]+i)\n\nk=list(map(int,input().split()))\ntb=0\nfor i in range(q):\n    tb+=k[i]\n    if tb>=s[-1]:\n        tb=0\n        print(n)\n    else:\n        ans=bisect.bisect_right(s,tb)\n        print(n-ans+1)\n", "#!/usr/bin/env python3\n\nimport bisect\n\n[n, q] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\nkis = list(map(int, input().strip().split()))\n\niais = [0 for _ in range(n + 1)]\nfor i in range(n):\n\tiais[i + 1] = iais[i] + ais[i]\n\n\ndef bsearch(v, xmin, xmax):\n\twhile xmax - xmin > 1:\n\t\txmid = (xmin + xmax) // 2\n\t\tif v >= iais[xmid]:\n\t\t\txmin = xmid\n\t\telse:\n\t\t\txmax = xmid\n\treturn xmin\n\ndef lsearch(v, xmin, xmax):\n\tx = xmin\n\twhile x + 1 < xmax and v >= iais[x + 1]:\n\t\tx += 1\n\treturn x\n\nthrs = (iais[-1] // n + 1) * 440\n\n\n\ns = 0\ntot = iais[-1]\nprevr = 0\nfor k in kis:\n\ts += k\n\tif s >= tot:\n\t\tprint (n)\n\t\ts = 0\n\t\tprevr = 0\n\telse:\n\t\tr = bisect.bisect_right(iais, s, prevr) - 1\n\t\tprint(n - r)\n\t\tprevr = r\n\n", "#!/usr/bin/env python3\n\nimport bisect\n\n[n, q] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\nkis = list(map(int, input().strip().split()))\n\niais = [0 for _ in range(n + 1)]\nfor i in range(n):\n\tiais[i + 1] = iais[i] + ais[i]\n\n\ns = 0\ntot = iais[-1]\nr = 0\nfor k in kis:\n\ts += k\n\tif s >= tot:\n\t\tprint (n)\n\t\ts = 0\n\t\tr = 0\n\telse:\n\t\tr = bisect.bisect_right(iais, s, r) - 1\n\t\tprint(n - r)\n\n", "from itertools import accumulate\n\nfrom math import inf\n\n\ndef sum(p):\n    return h[p] - h[ind] + val\n\n\ndef check(p):\n    return sum(p) >= el\n\n\ndef binSearch(a, b):\n    left, right = a - 1, b + 1\n\n    while right - left > 1:\n        mid = (left + right) // 2\n\n        if check(mid):\n            right = mid\n        else:\n            left = mid\n\n    return right\n\n\nn, q = list(map(int, input().split()))\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\nh = [0] + list(accumulate(a)) + [inf]\n\nind = 1\nval = a[0]\n\nans = list()\nfor i, el in enumerate(k):\n\n    if el < val:\n        val -= el\n\n        ans.append(n + 1 - ind)\n\n    elif el == val:\n        ind += 1\n\n        if ind == n + 1:\n            ind = 1\n            val = a[0]\n            ans.append(n)\n\n        else:\n            val = a[ind - 1]\n            ans.append(n + 1 - ind)\n\n    else:\n        b = binSearch(ind, n)\n\n        delta = sum(b) - el\n\n        if b == n + 1:\n            ans.append(n)\n            ind = 1\n            val = a[0]\n\n        elif delta == 0:\n            ind = b + 1\n\n            if ind == n + 1:\n                ind = 1\n                val = a[0]\n                ans.append(n)\n\n            else:\n                val = a[ind - 1]\n                ans.append(n + 1 - ind)\n\n        else:\n            ind = b\n            val = delta\n            ans.append(n + 1 - ind)\n\nprint('\\n'.join(map(str, ans)))\n", "import bisect\n\nn,q = list(map(int, input().split()))\nwarrior = list(map(int, input().split()))\nattacker = list(map(int, input().split()))\nwarriors_new = []\nsm = 0\nfor i in warrior:\n    sm+=i\n    warriors_new.append(sm)\nquery = 0\nans = 0\nfor i in attacker:\n    query+=i\n    if query>=warriors_new[n-1]:\n        query = 0\n        ans = 0\n    else:\n        ans = bisect.bisect_right(warriors_new,query,ans)\n    print(n-ans)\n", "n, q = map(int, input().split())\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\ndef bins(arr, start, end, v):\n    # find index of biggest value less than or equal to v\n    s, e = start, end\n    result = -1\n    \n    while s < e:\n        m = (s + e) // 2\n\n        if arr[m] >= v:\n            e = m\n        else:\n            result = m\n            s = m + 1\n\n    return s if a[s] <= v else s - 1\n\nfor i in range(1, len(a)):\n    a[i] += a[i - 1]\n\n# arrow strength\ns = 0\nresult = []\n\nfor ki in k:\n    s += ki\n\n    standing = n - bins(a, 0, len(a) - 1, s) - 1\n\n    if standing > 0:\n        result.append(standing)\n    else:\n        result.append(n)\n\n    if s >= a[-1]:\n        s = 0\n\nprint('\\n'.join(map(str, result)))", "n, q = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nK = [int(i) for i in input().split()]\n\nA = a[:]\nfor i in range(1, n):\n    A[i] += A[i-1]\n\ndef bs(A, key):\n    lo, hi = 0, len(A)-1\n    while lo <= hi:\n        mid = (lo+hi) // 2\n        if A[mid] == key:\n            # print(A)\n            # print(f'Found key = {key} *exactly* at mid = {mid}')\n            return mid\n        elif key < A[mid]:\n            hi = mid-1\n        elif A[mid] < key:\n            lo = mid+1\n    # print(A)\n    # print(f'hi={hi} > lo={lo}. Returning hi')\n    return hi\n\nD = 0\nfor i in range(q):\n    D += K[i]\n    # print(f'Accumulated damage = {D}')\n    j = bs(A, D)\n    if j == n-1:\n        # print('Resetting damage')\n        D = 0\n        j = -1\n    print(n-(j+1))\n", "from bisect import bisect as bs\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nk = list(map(int, input().split()))\ntmp = 0\nsumA = []\nfor i in range(n):\n    tmp += a[i]\n    sumA.append(tmp)\n# print(sumA)\n\n\ndef bin_search(left, right, v):\n    if left > right:\n        return left\n    mid = (left + right) // 2\n    if sumA[mid] == v:\n        return mid\n    elif sumA[mid] < v:\n        return bin_search(mid+1, right, v)\n    else:\n        return bin_search(left, mid-1, v)\n\n\n\nnow = 0\n\nansList = []\n\nfor i in range(q):\n    now += k[i]\n    ans_id = bs(sumA, now)\n    if ans_id == n:\n        now = 0\n        ans_id = 0\n    ansList.append(n-ans_id)\n\nprint(\"\\n\".join(map(str, ansList)))"]
["import collections\n\nn,m=map(int,input().split())\nm+=2\narr=list(map(int,input().split()))\narr.append(0)\narr.append(n)\narr=sorted(arr)\ng,r=map(int,input().split())\nq=collections.deque()\nq.append((0,0))\ndist=[[0]*(g+1) for _ in range(m+2)]\nchecked=[[0]*(g+1) for _ in range(m+2)]\nchecked[0][0]=1\nans=-1\nwhile len(q)!=0:\n  v,t=q.popleft()\n  if t==0:\n    if n-arr[v]<=g:\n      tmp=dist[v][t]*(g+r)+n-arr[v]\n      if ans==-1 or ans>tmp:\n        ans=tmp\n  if t==g:\n    if checked[v][0]==0:\n      checked[v][0]=1\n      dist[v][0]=dist[v][t]+1\n      q.append((v,0))\n    continue\n  if v!=0:\n    cost=t+arr[v]-arr[v-1]\n    if cost<=g and checked[v-1][cost]==0:\n      checked[v-1][cost]=1\n      dist[v-1][cost]=dist[v][t]\n      q.appendleft((v-1,cost))\n  if v!=m-1:\n    cost=t+arr[v+1]-arr[v]\n    if cost<=g and checked[v+1][cost]==0:\n      checked[v+1][cost]=1\n      dist[v+1][cost]=dist[v][t]\n      q.appendleft((v+1,cost))\nprint(ans)", "import collections\n\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\narr=sorted(arr)\ng,r=map(int,input().split())\nq=collections.deque()\nq.append((0,0,0))\nchecked=[[-1]*(g) for _ in range(m)]\nchecked[0][0]=0\nwhile len(q)!=0:\n  v,t,cnt=q.popleft()\n  if v!=m-1:\n    cost1=arr[v+1]-arr[v]\n    if t+cost1<=g:\n      if checked[v+1][(t+cost1)%g]==-1:\n        if t+cost1<g:\n          q.appendleft((v+1,t+cost1,cnt))\n          checked[v+1][t+cost1]=cnt\n        else:\n          q.append((v+1,0,cnt+1))\n          checked[v+1][0]=cnt+1\n  if v!=0:\n    cost2=arr[v]-arr[v-1]\n    if t+cost2<=g:\n      if checked[v-1][(t+cost2)%g]==-1:\n        if t+cost2<g:\n          q.appendleft((v-1,t+cost2,cnt))\n          checked[v-1][t+cost2]=cnt\n        else:\n          q.append((v-1,0,cnt+1))\n          checked[v-1][0]=cnt+1\nans=10**18\nfor i in range(m):\n  for j in range(g):\n    if checked[i][j]==-1:\n      continue\n    else:\n      if j+n-arr[i]<=g:\n        ans=min(ans,checked[i][j]*(g+r)+j+n-arr[i])\nif ans==10**18:\n  print(-1)\nelse:\n  print(ans)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nfrom typing import List\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(list(map(int,input().split())))\n\n\ndef compute(n, m, g, r, A: List[int]):\n    A.sort()\n\n    WHITE = -1\n    GREY = -2\n\n    states = [[WHITE] * (g+1) for _ in range(m)]\n    states[0][g] = 0\n    states[0][0] = 0\n\n    q = deque([(0, g)])\n\n    def process_neib(ineib, gneib):\n        if states[ineib][gneib] != WHITE:\n            #print(f\"Skipped as grey\")\n            return\n\n        if ineib == m-1:\n            #no need to wait there\n            states[ineib][gneib] = states[index][g_left]\n            #print(f\"Final state dist is {states[ineib][gneib]}\")\n\n        elif gneib == 0:\n            states[ineib][gneib] = states[index][g_left] + 1\n            states[ineib][g] = states[ineib][gneib]\n            gneib = g\n            q.append((ineib, gneib))\n            #print(f\"appended right with distance {states[ineib][0]}\")\n        else:\n            states[ineib][gneib] = states[index][g_left]\n            q.appendleft((ineib, gneib))\n\n    while q:\n        # sit for this is known\n        #print(f\"Queue is {[(A[i], t) for i,t in q]}\")\n        index, g_left = q.popleft()\n        #print(f\"Popped {A[index], g_left}. Dist is {states[index][g_left]}\")\n\n\n        #neib = get_neib(index, g_left, A)\n        #print(f\"Neighbors are {[(A[i], t) for i, t in neib]}\")\n\n        if index > 0:\n            # there exists a next one\n            delta = A[index] - A[index-1]\n            if g_left >= delta:\n                process_neib(index-1, g_left-delta)\n\n\n        if index < m-1:\n            delta = A[index+1] - A[index]\n            if g_left >= delta:\n                process_neib(index+1, g_left-delta)\n\n\n                #print(f\"appended left with distance {states[ineib][gneib]}\")\n\n\n    res = float('inf')\n    for g_left in range(g):\n        if states[m-1][g_left] >= 0:\n\n            res = min(res, states[m-1][g_left] * (r+g) + g-g_left)\n\n    if res != float('inf'):\n        print(res)\n    else:\n        print('-1')\n\n\ndef from_file(f):\n    return f.readline\n\n# with open('52.txt') as f:\n#     input = from_file(f)\nn, m = invr()\nA = inlt()\ng,r  = invr()\ncompute(n, m, g, r, A)\n\n\n\n\n\n\n", "import sys\nsys.setrecursionlimit(10000)\n\nfrom collections import deque\nfrom heapq import heappush, heappop\n\nclass Memoize:\n    def __init__(self, f):\n        self.f = f\n        self.memo = {}\n    def __call__(self, *args):\n        if not args in self.memo:\n            self.memo[args] = self.f(*args)\n        return self.memo[args]\n\nclass Recurse(Exception):\n    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\ndef recurse(*args, **kwargs):\n    raise Recurse(*args, **kwargs)\n        \ndef tail_recursive(f):\n    def decorated(*args, **kwargs):\n        while True:\n            try:\n                return f(*args, **kwargs)\n            except Recurse as r:\n                args = r.args\n                kwargs = r.kwargs\n                continue\n    return decorated\n\nn, m = list(map(int, input().split()))\nd = sorted(map(int, input().split()))\ng, r = list(map(int, input().split()))\n\nq = deque([(0, 0, g)])\ncost = [[-1] * (g+1) for _ in range(m)]\n\nwhile len(q):\n    c, x, t = q.popleft()\n    if cost[x][t] != -1:\n        continue\n    cost[x][t] = c\n    back = False\n    if t == 0:\n        back = True\n        c += r\n        t = g\n    for di in [-1, 1]:\n        ni = x+di\n        if ni >= 0 and ni < m:\n            step = abs(d[x]-d[ni])\n            if step <= t:\n                if back:\n                    q.append((c+step, ni, t-step))\n                else:\n                    q.appendleft((c+step, ni, t-step))\n\nres = list([x for x in cost[m-1] if x != -1])\nprint(min(res) if len(res) else -1)\n"]
["import bisect\nfrom functools import lru_cache\n\ng, d, f = tuple(map(int, input().split()))\n\ngoals = list(map(int, input().split()))\ndefs = list(map(int, input().split()))\nforwards = list(map(int, input().split()))\n\ngoals.sort()\ndefs.sort()\nforwards.sort()\n\nforwards.append(100000000)\ndefs.append(100000000)\ngoals.append(100000000)\n\nnumers = []\nroles = []\ngi, di, fi = 0, 0, 0\n\nfor i in range(d + g + f):\n    numers.append(min(goals[gi], defs[di], forwards[fi]))\n\n    if numers[-1] == goals[gi]:\n        roles.append(1)\n        gi += 1\n\n    if numers[-1] == forwards[fi]:\n        roles.append(3)\n        fi += 1\n\n    if numers[-1] == defs[di]:\n        roles.append(2)\n        di += 1\n\n#print(numers)\n#print(roles)\n\n\n@lru_cache()\ndef my_comb(n, k):\n    if k == 0:\n        return 1\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    if k == 3:\n        return (n * (n - 1) * (n - 2)) // 6\n    if k == 2:\n        return (n * (n - 1)) // 2\n    if k == 1:\n        return n\n    assert False\n\n\ndef solve(numers, roles):\n    ans = 0\n    for i in range(len(numers)):\n        # check all combinations with guy i\n\n        possible_max_num = bisect.bisect_right(numers, numers[i] * 2)\n\n        if possible_max_num - i < 5:\n            continue\n\n        avaliable_f = roles[i + 1: possible_max_num].count(3)\n        avaliable_d = roles[i + 1: possible_max_num].count(2)\n        avaliable_g = roles[i + 1: possible_max_num].count(1)\n\n        needed_f, needed_d, needed_g = 3, 2, 1\n\n        if roles[i] == 1:\n            needed_g -= 1\n        elif roles[i] == 2:\n            needed_d -= 1\n        else:\n            needed_f -= 1\n\n        possible_combinations_with_ith = my_comb(avaliable_d, needed_d) * my_comb(avaliable_f, needed_f) * my_comb(\n            avaliable_g, needed_g)\n        ans += possible_combinations_with_ith\n\n    return ans\n\n\nprint(solve(numers, roles))\n", "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef binom(n, k):\n    if k > n:\n        return 0\n    elif k == 0:\n        return 1\n    elif k == 1:\n        return n\n    elif k == 2:\n        return (n * (n - 1)) // 2\n    elif k == 3:\n        return (n * (n - 1) * (n - 2)) // 6\n    else:\n        raise NotImplementedError\n\n\ndef ways_to_pick(xs, wx, lo, hi):\n    idx_lo = bisect_left(xs, lo)\n    idx_hi = bisect_right(xs, hi)\n    return binom(idx_hi - idx_lo, wx)\n\n\ndef number_of_teams(gs, wg, ds, wd, fs, wf, lo, hi):\n    return ways_to_pick(gs, wg, lo, hi) * \\\n           ways_to_pick(ds, wd, lo, hi) * \\\n           ways_to_pick(fs, wf, lo, hi)\n\n\nng, nd, nf = list(map(int, input().split()))\ngs = list(sorted(map(int, input().split())))\nds = list(sorted(map(int, input().split())))\nfs = list(sorted(map(int, input().split())))\n\nwg = 1\nwd = 2\nwf = 3\n\nif nd < 2 or nf < 3:\n    print(0)\n    return\n\nans = 0\nfor idx, min_el in enumerate(gs):\n    ans += number_of_teams(gs[idx + 1:], wg - 1,\n                           ds, wd,\n                           fs, wf,\n                           min_el, 2 * min_el)\nfor idx, min_el in enumerate(ds):\n    ans += number_of_teams(gs, wg,\n                           ds[idx + 1:], wd - 1,\n                           fs, wf,\n                           min_el, 2 * min_el)\nfor idx, min_el in enumerate(fs):\n    ans += number_of_teams(gs, wg,\n                           ds, wd,\n                           fs[idx + 1:], wf - 1,\n                           min_el, 2 * min_el)\nprint(ans)\n", "def sub_pairs(r, l):\n    if r-l<2: return 0\n    n = r-l\n    return (n*(n-1))//2\n\ndef sub_triples(r, l):\n    if r-l<3: return 0\n    n = r-l\n    return (n*(n-1)*(n-2))//6\n\ndef fast(g, d, f):\n    g.sort()\n    d.sort()\n    f.sort()\n    res = 0\n    gl, dl, fl = 0, 0, 0\n    gr, dr, fr = 0, 0, 0\n    while gl < len(g) and dl < len(d)-1 and fl < len(f)-2:\n        mn = min(g[gl], d[dl], f[fl])\n        mx = mn*2\n        while gr < len(g) and g[gr] <= mx: gr+=1\n        while dr < len(d) and d[dr] <= mx: dr+=1\n        while fr < len(f) and f[fr] <= mx: fr+=1\n        if g[gl] == mn:\n            res += sub_pairs(dr, dl) * sub_triples(fr, fl)\n            gl+=1\n        elif d[dl] == mn:\n            res += (max(0, dr-dl-1))*max(0, gr-gl) * sub_triples(fr, fl)\n            dl+=1\n        else:\n            res += sub_pairs(fr, fl+1)*max(0, gr-gl) * sub_pairs(dr, dl)\n            fl+=1\n##        print(res, mn, mx, (gl, gr), (dl, dr), (fl, fr))\n    return res        \n\n\n        \n\n\ninput()\ng = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nf = [int(x) for x in input().split()]\nprint(fast(g, d, f))\n", "import bisect\n\ndef count(a, low):\n    top = low*2\n    lowi = bisect.bisect_left(a, low)\n    topi = bisect.bisect_right(a, top)\n    return topi - lowi\n\ngn, dn, fn = map(int, input().split())\ng = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nf = [int(x) for x in input().split()]\n\ng = sorted(g)\nd = sorted(d)\nf = sorted(f)\n\nans = 0\nfor x in g:\n    dc = count(d, x)\n    fc = count(f, x)\n    ans += dc * (dc-1) * fc * (fc-1) * (fc-2) // 12\nfor x in d:\n    gc = count(g, x)\n    dc = count(d, x)\n    fc = count(f, x)\n    ans += gc * (dc-1) * fc * (fc-1) * (fc-2) // 6\nfor x in f:\n    gc = count(g, x)\n    dc = count(d, x)\n    fc = count(f, x)\n    ans += gc * dc * (dc - 1) * (fc - 1) * (fc - 2) // 4\n\nprint(ans)", "g, d, f = (int(s) for s in input().split())\ngs = sorted([int(s) for s in input().split()])\nds = sorted([int(s) for s in input().split()])\nfs = sorted([int(s) for s in input().split()])\n\ngn = [0] * 100001\ndn = [0] * 100001\nfn = [0] * 100001\n\nfor a in gs:\n    gn[a] += 1\n\nfor a in ds:\n    dn[a] += 1\n\nfor a in fs:\n    fn[a] += 1\n\ngx = 0\ndx = 0\nfx = 0\n\nfor i in range(100001):\n    gx += gn[i]\n    dx += dn[i]\n    fx += fn[i]\n\n    gn[i] = gx\n    dn[i] = dx\n    fn[i] = fx\n\ndef team_count(a, b):\n    if a > 100000:\n        a = 100000\n    if b > 100000:\n        b = 100000\n    gc = gn[b] - gn[a]\n    dc = dn[b] - dn[a]\n    fc = fn[b] - fn[a]\n\n    val = gc * dc * (dc - 1) * fc * (fc - 1) * (fc - 2) // 12\n    if val < 0:\n        print(val)\n    return val\n\nres = team_count(0, 2)\nfor i in range(1, 50001):\n    res += team_count(i, 2 * i + 2) - team_count(i, 2 * i)\n\nprint(res)\n", "import getpass\nimport sys\nimport math\nimport itertools\nimport bisect\n\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\ndef dr(v):\n    sm = sum([int(i) for i in str(v)])\n    return sm if sm < 10 else dr(sm)\n\n\ndef range_sum(a, b):\n    ass = (((b - a + 1) // 2) * (a + b))\n    if (a - b) % 2 == 0:\n        ass += (b - a + 2) // 2\n    return ass\n\n\ndef comba(n, x):\n    return (math.factorial(n) // math.factorial(n - x)) // math.factorial(x)\n\n\nfiles = True\ndebug = False\n\nif getpass.getuser() == 'frohenk' and files:\n    debug = True\n    sys.stdin = open(\"test.in\")\n    # sys.stdout = open('test.out', 'w')\n    pass\n\ng, d, f = ria()\ngs = sorted(ria())\nds = sorted(ria())\nfs = sorted(ria())\n\nar = []\nfor i in gs:\n    ar.append((i, 0))\nfor i in ds:\n    ar.append((i, 1))\nfor i in fs:\n    ar.append((i, 2))\nar = sorted(ar)\nsuma = 0\nfor i, tp in ar:\n    gl = bisect.bisect_right(gs, i * 2) - bisect.bisect_left(gs, i)\n    dl = bisect.bisect_right(ds, i * 2) - bisect.bisect_left(ds, i)\n    fl = bisect.bisect_right(fs, i * 2) - bisect.bisect_left(fs, i)\n    if gl < 1 or dl < 2 or fl < 3:\n        continue\n    mp = 1\n    if tp == 0:\n        pass\n    else:\n        mp *= comba(gl, 1)\n    \n    if tp == 1:\n        mp *= comba(dl - 1, 1)\n    else:\n        mp *= comba(dl, 2)\n\n    if tp == 2:\n        mp *= comba(fl - 1, 2)\n    else:\n        mp *= comba(fl, 3)\n    suma += mp\nprint(suma)\n", "g, d, f = map(int, input().split())\ngg = list(map(int, input().split()))\ndd = list(map(int, input().split()))\nff = list(map(int, input().split()))\ngg.sort()\ndd.sort()\nff.sort()\ndef get_kolvo(left, right, lst):\n    l = -1\n    r = len(lst)\n    while r - l > 1:\n        m = (r + l) // 2\n        if lst[m] >= left:\n            r = m\n        else:\n            l = m\n    ql = r\n    l = -1\n    r = len(lst)\n    while r - l > 1:\n        m = (r + l) // 2\n        if lst[m] > right:\n            r = m\n        else:\n            l = m\n    \n    qr = l\n        \n    return qr - ql + 1\n    \ndef c(n, k):\n    if k == 1:\n        return n\n    elif k == 2:\n        return n * (n - 1) // 2\n    elif k == 3:\n        return n * (n - 1) * (n - 2) // 6\n\ndef get(l, r):\n    return c(get_kolvo(l, r, gg), 1) * c(get_kolvo(l, r, dd), 2) * c(get_kolvo(l, r, ff), 3)\n    \nans = 0\nfor i in range(4, 100001):\n    ans += get(i, 2 * i) - get(i, 2 * i - 2)\nprint(ans)", "import sys\nimport math\nimport random\nimport time\n\ndef func_cnk(keepers, defenders, attackers, flag):\n    if flag == 'kpr':\n        kpr = 1\n        defs = math.factorial(defenders) // math.factorial(2) // math.factorial(defenders - 2)\n        atts = math.factorial(attackers) // math.factorial(3) // math.factorial(attackers - 3)\n    elif flag == 'def':\n        kpr = keepers\n        defs = defenders - 1\n        atts = math.factorial(attackers) // math.factorial(3) // math.factorial(attackers - 3)\n    elif flag == 'att':\n        kpr = keepers\n        defs = math.factorial(defenders) // math.factorial(2) // math.factorial(defenders - 2)\n        atts = math.factorial(attackers - 1) // math.factorial(2) // math.factorial(attackers - 3)\n    return kpr * int(defs) * int(atts)\n\ng, d, f = list(map(int, input().split()))\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\nz = list(map(int, input().split()))\n#N = 100000\n#x = random.sample(range(1, N), g)\n#y = random.sample(range(1, N), d)\n#z = random.sample(range(1, N), f)\n#print(x, y, z)\n\nif (d < 2) or (f < 3):\n    print('0')\n    return\n\nt = time.time()\n\nres_ans = 0\ndict_nums = {}\n\nfor num in x:\n    dict_nums[num] = 'kpr'\nfor num in y:\n    dict_nums[num] = 'def'\nfor num in z:\n    dict_nums[num] = 'att'\n\nall_nums = x + y + z\nall_nums.sort()\n\nfor i in range(len(all_nums)):\n    upper = all_nums[i] * 2\n    j = i\n    keepers = 0\n    defenders = 0\n    attackers = 0\n    while (j < len(all_nums) and (all_nums[j] <= upper)):\n        if dict_nums[all_nums[j]] == 'kpr':\n            keepers = keepers + 1\n        if dict_nums[all_nums[j]] == 'def':\n            defenders = defenders + 1\n        if dict_nums[all_nums[j]] == 'att':\n            attackers = attackers + 1\n        j = j + 1\n    if (keepers > 0) and (defenders > 1) and (attackers > 2):\n        #print(all_nums[i], func_cnk(keepers, defenders, attackers, dict_nums[all_nums[i]]))\n        res_ans = res_ans + func_cnk(keepers, defenders, attackers, dict_nums[all_nums[i]])\n\nprint(res_ans)", "_ = input()\na = list([(int(x), 1) for x in input().split()])\na.extend([(int(x), 2) for x in input().split()])\na.extend([(int(x), 3) for x in input().split()])\na.sort()\ng, d, f, n = [0], [0], [0], len(a)\nfor x, y in a:\n    g.append(g[-1])\n    d.append(d[-1])\n    f.append(f[-1])\n    if y == 1: g[-1] += 1\n    elif y == 2: d[-1] += 1\n    else: f[-1] += 1\n\ns = i = 0\nj = 1\n\nwhile i < n:\n    while j < n and a[j][0] <= 2*a[i][0]: j += 1\n    j -= 1\n    g1 = g[j+1] - g[i]\n    d1 = d[j+1] - d[i]\n    f1 = f[j+1] - f[i]\n    # print(i, j, g1, d1, f1)\n    if a[i][1] == 1: s += d1 * (d1 - 1) * f1 * (f1 - 1) * (f1 - 2) // 12\n    elif a[i][1] == 2: s += g1 * (d1 - 1) * f1 * (f1 - 1) * (f1 - 2) // 6\n    else: s += g1 * d1 * (d1 - 1) * (f1 - 1) * (f1 - 2) // 4\n    i += 1\n\nprint(s)\n", "from math import factorial\n\nn, m, k = (int(x) for x in input().split())\na = sorted([int(x) for x in input().split()])\nb = sorted([int(x) for x in input().split()])\nc = sorted([int(x) for x in input().split()])\n\n\ndef create_count_arr(a):\n    a_count = [0] * (10 ** 5 + 5)\n    for i in range(len(a)):\n        a_count[a[i]:] = [i + 1] * ((10 ** 5 + 5) - a[i])\n    return a_count\n\n\ndef get_num(x, y, a):\n    if y >= len(a):\n        y = len(a) - 1\n    c = a[y] - a[x]\n    if a[x] != a[x - 1]:\n        c += 1\n    return c\n\n\ndef num_of_permut(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\n\na_count = create_count_arr(a)\nb_count = create_count_arr(b)\nc_count = create_count_arr(c)\n\ncount = 0\n\n# print('goalkeepers')\nfor i in a:\n    d = get_num(i, i * 2, b_count)\n    f = get_num(i, i * 2, c_count)\n    # print(i, d, f, end=' ')\n    if d >= 2 and f >= 3:\n        count += num_of_permut(d, 2) * num_of_permut(f, 3)\n    #     print('ok, count =', count)\n    # else:\n    #     print()\n# print('\\ndefenders')\nfor i in b:\n    g = get_num(i, i * 2, a_count)\n    d = get_num(i, i * 2, b_count) - 1\n    f = get_num(i, i * 2, c_count)\n    # print(i, g, d, f, end=' ')\n    if g >= 1 and d >= 1 and f >= 3:\n        count += num_of_permut(d, 1) * num_of_permut(f, 3) * g\n    #     print('ok, count =', count)\n    # else:\n    #     print()\n\n# print('\\nforwards')\nfor i in c:\n    g = get_num(i, i * 2, a_count)\n    d = get_num(i, i * 2, b_count)\n    f = get_num(i, i * 2, c_count) - 1\n    # print(i, g, d, f, end=' ')\n    if g >= 1 and d >= 2 and f >= 2:\n        count += num_of_permut(d, 2) * num_of_permut(f, 2) * g\n    #     print('ok, count =', count)\n    # else:\n    #     print()\n\nprint(count)\n", "s = input().split()\nl = sum([int(i) for i in s])\npos = [0,0,0]\nls = []\nfor j in range(3): \n    ls += [[int(i) for i in input().split()]]\n    ls[j] += [100100]\n    ls[j].sort()\n    \nshet = [0,0,0]\nbot_ind = 0 \ntop_granica = 0 \nsumma = 0  \ni = 0 \nmain_list = [] \nkandidat =[] \nwhile i < l: \n    if ls[0][shet[0]] < ls[1][shet[1]]:\n        if ls[0][shet[0]] < ls[2][shet[2]]:\n            kandidat = [ls[0][shet[0]],0]\n        else:\n            kandidat = [ls[2][shet[2]],2]\n    else:\n        if ls[1][shet[1]] < ls[2][shet[2]]:\n            kandidat = [ls[1][shet[1]],1]\n        else:\n            kandidat = [ls[2][shet[2]],2]\n    if bot_ind == i:\n        main_list += [kandidat] \n        shet[kandidat[1]] += 1 \n        top_granica = main_list[bot_ind][0]*2 \n                                            \n        pos[kandidat[1]] +=1 \n    else:  \n        if kandidat[0] > top_granica: \n            if pos[0] > 0 and pos[1] > 1 and pos[2] > 2:  \n                pos[main_list[bot_ind][1]] -= 1 \n                if not main_list[bot_ind][1]: \n                    summa += pos[1]*(pos[1]-1)*pos[2]*(pos[2]-1)*(pos[2]-2)//12 \n                elif main_list[bot_ind][1] == 1:\n                    summa += pos[0]*pos[1]*pos[2]*(pos[2]-1)*(pos[2]-2)//6\n                else:\n                    summa += pos[0]*pos[1]*(pos[1]-1)*pos[2]*(pos[2]-1)//4\n                bot_ind +=1 \n                top_granica = main_list[bot_ind][0]*2 \n            else:\n                pos[main_list[bot_ind][1]] -= 1\n                bot_ind +=1\n                if bot_ind < i:\n                    top_granica = main_list[bot_ind][0]*2\n            i -= 1\n               \n        else:\n            main_list+=[kandidat]\n            shet[kandidat[1]] += 1\n            pos[kandidat[1]] +=1\n    i += 1 \nwhile pos[0] > 0 and pos[1] > 1 and pos[2] > 2:\n    pos[main_list[bot_ind][1]] -= 1\n    if not main_list[bot_ind][1]:\n        summa += pos[1]*(pos[1]-1)*pos[2]*(pos[2]-1)*(pos[2]-2)//12 \n    elif main_list[bot_ind][1] == 1:\n        summa += pos[0]*pos[1]*pos[2]*(pos[2]-1)*(pos[2]-2)//6 \n    else:\n        summa += pos[0]*pos[1]*(pos[1]-1)*pos[2]*(pos[2]-1)//4 \n    bot_ind +=1\n    \n    \nprint(summa)            \n\n", "from math import factorial\n\ndef bin_search(l, r, x):\n\twhile l < r - 1:\n\t\tm = (l+r)//2\n\t\tif players[m][0] == x:\n\t\t\treturn m\n\t\tif players[m][0] < x:\n\t\t\tl = m\n\t\telse:\n\t\t\tr = m\n\treturn l\n\ndef cmds_in_range(rang):\n\troles = []\n\ttemp_rang = [i[1] for i in rang]\n\tfor i in range(3):\n\t\troles.append(temp_rang.count(i))\n\tif roles[0] < 1 or roles[1] < 2 or roles[2] < 3:\n\t\treturn 0\n\tcomb_d = factorial(roles[1])//(factorial(roles[1]-2)*2)\n\tcomb_f = factorial(roles[2])//(factorial(roles[2]-3)*6)\n\treturn roles[0] * comb_d * comb_f\n\ninput()\nplayers = []\nfor i in range(3):\n\tfor j in (int(k) for k in input().split()):\n\t\tplayers.append((j, i))\nplayers.sort()\nplayers.append((200001, 0))\n\ncount = 0\nr = 0\nfor l in range(len(players) - 5):\n\tif l == 0:\n\t\tinter_cmds = 0\n\telse:\n\t\tinter_cmds = cmds_in_range(players[l:r + 1])\n\tr = bin_search(l, len(players) - 1, players[l][0] * 2)\n\tcur_cmds = cmds_in_range(players[l:r + 1])\n\tcount += cur_cmds - inter_cmds\n\t\nprint(count)", "g,d,f = list(map(int, input().split()))\nvratars = list(map(int, input().split()))\ndefenders = list(map(int, input().split()))\natackers = list(map(int, input().split()))\n\nvratars.sort()\ndefenders.sort()\natackers.sort()\n\ncount = 0\nwhile 1:\n\tvNeed = 1\n\tdNeed = 2\n\taNeed = 3\n\ttry:\n\t\tif defenders[0]<atackers[0]:\n\t\t\tif defenders[0] < vratars[0]:\n\t\t\t\tmn = defenders.pop(0)\n\t\t\t\td-=1\n\t\t\t\tdNeed = 1\n\t\t\telse:\n\t\t\t\tmn = vratars.pop(0)\n\t\t\t\tg-=1\n\t\t\t\tvNeed = 0\n\t\telse:\n\t\t\tif atackers[0] < vratars[0]:\n\t\t\t\tmn = atackers.pop(0)\n\t\t\t\tf-=1\n\t\t\t\taNeed = 2\n\t\t\telse:\n\t\t\t\tmn = vratars.pop(0)\n\t\t\t\tg-=1\n\t\t\t\tvNeed = 0\n\texcept IndexError:\n\t\t# print('INDERR')\n\t\tbreak\n\t# print('need', vNeed, dNeed, aNeed)\n\t# print('ost', g, d, f)\n\tif (vNeed>g) or (dNeed>d) or (aNeed>f): break\n\t# print('mn ', mn)\n\tmx = mn*2\t\t\n\tif vNeed:\n\t\tvOk = 0\n\t\tfor i in vratars:\n\t\t\tif i>mx: break\n\t\t\tvOk+=1\n\tdOk = 0\n\tfor i in defenders:\n\t\tif i>mx: break\n\t\tdOk+=1\n\taOk = 0\n\tfor i in atackers:\n\t\tif i>mx: break\n\t\taOk+=1\n\n\n\tvC = 1\n\tif vNeed:\n\t\tvC = vOk\n\n\tif dNeed==1:\n\t\tdC = dOk\n\telse:\n\t\tdC = ((dOk-1)*dOk)/2\n\n\tif aNeed==2:\n\t\taC = ((aOk-1)*aOk)/2\n\telse:\n\t\taC = ((aOk-2)*(aOk-1)*aOk)/6\n\n\tcount += vC*dC*aC\n\t# print('c', vC, dC, aC)\nprint(int(count))\n\n\n\n\n\n\n", "#\u0443\u043f\u0440\u043e\u0449\u0435\u043d\u043d\u043e\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 C\ndef c2(n):\n    return n*(n-1)//2\ndef c3(n):\n    return n*(n-1)*(n-2)//6\n\ng,d,f=list(map(int,input().split()))\n#\u041a\u043e\u0441\u0442\u044b\u043b\u044c\nif g<1 or d<2 or f<3:\n    print(0)\n    return\n\nans=0\na=[]\nn=g+d+f\n#\u0441\u043a\u0438\u0434\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u043e\u0434\u0438\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438 \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u0442\u0438\u043f\u044b\nfor i in map(int,input().split()):\n    a.append((i,0))\nfor i in map(int,input().split()):\n    a.append((i,1))\nfor i in map(int,input().split()):\n    a.append((i,2))\n\n#\u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u044d\u0442\u043e\u0442 \u043c\u0430\u0441\u0441\u0438\u0432 \u043f\u043e \u043d\u043e\u043c\u0435\u0440\u0443\na.sort()\n\nfor i in range(n): #\u0432 i \u043f\u0435\u0440\u0435\u0431\u0435\u0440\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0443\u043c\n    types=[0,0,0]\n    j=i+0#\u0432 j \u043f\u0435\u0440\u0435\u0431\u0435\u0440\u0430\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\n    while j<n and a[j][0]<=2*a[i][0]: #\u0435\u0441\u043b\u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0432 2 \u0440\u0430\u0437\u0430 \u043c\u0435\u043d\u044c\u0448\u0435 \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u0430, \u0442\u043e \u0438 \u0432\u0441\u0435 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435\n        types[a[j][1]]+=1\n        now_types=types.copy()\n        now_types[a[j][1]]-=1\n        now_types[a[i][1]]-=1\n        #\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u043a\u0430\u043a\u043e\u0433\u043e \u0442\u0438\u043f\u0430 \u043c\u0438\u043d\u0438\u043c\u0443\u043c \u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c, \u0438\u0445 \u043c\u044b \u043d\u0435 \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u0438 \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u0435 \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u043c\u044b \u0438\u0445 \u0437\u0430\u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043b\u0438, \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0431\u044b\u043b\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u043e\u0432\n        if a[j][1]==0 and a[i][1]==1 or a[j][1]==1 and a[i][1]==0:\n            if now_types[1]>=1 and now_types[2]>=3:\n                ans+=now_types[1]*c3(now_types[2])\n        elif a[j][1]==0 and a[i][1]==2 or a[j][1]==2 and a[i][1]==0:\n            if now_types[1]>=2 and now_types[2]>=2:\n                ans+=c2(now_types[1])*c2(now_types[2])\n        elif a[j][1]==2 and a[i][1]==1 or a[j][1]==1 and a[i][1]==2:\n            if now_types[0]>=1 and now_types[1]>=1 and now_types[2]>=2:\n                ans+=now_types[0]*now_types[1]*c2(now_types[2])\n        elif a[j][1]==1 and a[i][1]==1:\n            if now_types[0]>=1 and now_types[2]>=3:\n                ans+=now_types[0]*c3(now_types[2])\n        elif a[j][1]==2 and a[i][1]==2:\n            if now_types[0]>=1 and now_types[1]>=2 and now_types[2]>=1:\n                ans+=now_types[0]*c2(now_types[1])*now_types[2]\n        j+=1\nprint(ans)\n                \n                \n            \n            \n            \n        \n\n", "import bisect\n\ndef binom(n, k):\n    if k > n:\n        return 0\n    elif k == 1:\n        return n\n    elif k == 2:\n        return n * (n - 1) // 2\n    elif k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    else:\n        assert False\n\ndef get_len(arr, a, b):\n    lo = bisect.bisect_left(arr, a)\n    hi = bisect.bisect_right(arr, b)\n    return hi - lo\n\ndef solve(gs, ds, fs):\n    ans = 0\n\n    # min is goalkeeper, could be equal to attacker or defender if there were equal numbers\n    for num_g in gs:\n        ways_g = 1\n        len_d = get_len(ds, num_g, num_g * 2)\n        ways_d = binom(len_d, 2)\n        len_f = get_len(fs, num_g, num_g * 2)\n        ways_f = binom(len_f, 3)\n        ways = ways_g * ways_d * ways_f\n        # print(f'goalkeeper: ways={ways}, ways_gdf={ways_g, ways_d, ways_f}, num_g={num_g}')\n        ans += ways\n\n    # min is defender, could be equal to attacker if there were equal numbers\n    for i, num_d in enumerate(ds[:-1]):\n        ways_g = get_len(gs, num_d + 1, num_d * 2)\n        ways_d = get_len(ds, num_d + 1, num_d * 2)\n        len_f = get_len(fs, num_d, num_d * 2)\n        ways_f = binom(len_f, 3)\n        ways = ways_g * ways_d * ways_f\n        # print(f'defender:   ways={ways}, ways_gdf={ways_g, ways_d, ways_f}, num_d={num_d}')\n        ans += ways\n\n    # min is attacker\n    for i, num_f in enumerate(fs[:-2]):\n        ways_g = get_len(gs, num_f + 1, num_f * 2)\n        len_d = get_len(ds, num_f + 1, num_f * 2)\n        ways_d = binom(len_d, 2)\n        len_f = get_len(fs, num_f + 1, num_f * 2)\n        ways_f = binom(len_f, 2)\n        ways = ways_g * ways_d * ways_f\n        # print(f'attacker:   ways={ways}, ways_gdf={ways_g, ways_d, ways_f}, num_f={num_f}')\n        ans += ways\n\n    return ans\n\n_, _, _ = [int(v) for v in input().split()]\ngs = [int(v) for v in input().split()]\nds = [int(v) for v in input().split()]\nfs = [int(v) for v in input().split()]\n\ngs.sort()\nds.sort()\nfs.sort()\n\nans = solve(gs, ds, fs)\nprint(ans)\n", "import math\nfrom bisect import bisect_right as bis\n\ndef nCr(n, r):\n  if r > n:\n    return 0\n  f = math.factorial\n  return f(n) // f(r) // f(n - r)\n\ng, d, f = list(map(int, input().split()))\n\ngs = list(map(int, input().split()))\ngs.sort()\nds = list(map(int, input().split()))\nds.sort()\nfs = list(map(int, input().split()))\nfs.sort()\n\n\ndef find_max(first, nums):\n  nums_max = 0\n  for i in range(bis(nums, first), len(nums)):\n    if nums[i] <= first * 2:\n      nums_max += 1\n    else:\n      break\n  return nums_max\n\n\ndef count_by_first(first, gs_count=1, ds_count=2, fs_count=3):\n  gs_max = find_max(first, gs)\n  ds_max = find_max(first, ds)\n  fs_max = find_max(first, fs)\n  return nCr(gs_max, gs_count) * nCr(ds_max, ds_count) * nCr(fs_max, fs_count)\n\nanswer = 0\nfor i in gs:\n  answer += count_by_first(i, gs_count=0)\nfor i in ds:\n  answer += count_by_first(i, ds_count=1)\nfor i in fs:\n  answer += count_by_first(i, fs_count=2)\n\nprint(answer)\n", "g, d, f = map(int, input().split())\nG = sorted([0] + list(map(int, input().split())))\nD = sorted([0] + list(map(int, input().split())))\nF = sorted([0] + list(map(int, input().split())))\nG.append(0)\nD.append(0)\nF.append(0)\na = [0]*1000000\nb = [0]*1000000\nc = [0]*1000000\nx = 1\ny = 1\nz = 1\nfor i in range(1, 200001):\n  if G[x] == i:\n    a[i] = a[i - 1] + 1\n    x += 1\n  else:\n    a[i] = a[i - 1]\n  if D[y] == i:\n    b[i] = b[i - 1] + 1\n    y += 1\n  else:\n    b[i] = b[i - 1]\n  if F[z] == i:\n    c[i] = c[i - 1] + 1\n    z += 1\n  else:\n    c[i] = c[i - 1]\nq = 0\nfor i in range(1, 100001):\n  a2 = a[2*i] - a[i]\n  b2 = b[2*i] - b[i]\n  c2 = c[2*i] - c[i]\n  if a[i] - a[i - 1] == 1:\n    q += (b2*(b2 - 1) // 2) * (c2*(c2 - 1)*(c2 - 2) // 6)\n  if b[i] - b[i - 1] == 1:\n    q += a2*b2*(c2*(c2 - 1)*(c2 - 2) // 6)\n  if c[i] - c[i - 1] == 1:\n    q += a2*(b2*(b2 - 1) // 2)*(c2*(c2 - 1) // 2)\nprint(q)", "import math\ndef main():\n    g, d, f = map(int, input().split())\n    lst1 = list(map(int, input().split()))\n    lst2 = list(map(int, input().split()))\n    lst3 = list(map(int, input().split()))\n    lst0 = []\n    precounted = []\n    ans = 0\n\n    lst0 += [(c, 1) for c in lst1]\n    lst0 += [(c, 2) for c in lst2]\n    lst0 += [(c, 3) for c in lst3]\n\n    lst0.sort()\n\n    for i in range(len(lst0)):\n\n        if len(precounted) == 0:\n            a1, a2, a3 = (0, 0, 0)\n        else:\n            a1, a2, a3 = precounted[len(precounted) - 1]\n\n        if (lst0[i][1] == 1):\n            a1 += 1\n        elif (lst0[i][1] == 2):\n            a2 += 1\n        else:\n            a3 += 1\n\n        precounted.append((a1, a2, a3))\n\n        def product(iterable):\n            prod = 1\n            for n in iterable:\n                prod *= n\n            return prod\n\n        def npr(n, r):\n            assert 0 <= r <= n\n            return product(range(n - r + 1, n + 1))\n\n        def ncr(r, n):\n            if r > n:\n                return 0\n            assert 0 <= r <= n\n            if r > n // 2:\n                r = n - r\n            return npr(n, r) // math.factorial(r)\n\n    for i in range(len(lst0) - 1):\n        l = i + 1\n        r = len(lst0)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if lst0[i][0] * 2 >= lst0[m][0]:\n                l = m\n            else:\n                r = m\n        max_possible_num = lst0[l][0]\n        max_possible_ind = l\n\n        a1 = precounted[max_possible_ind][0] - precounted[i][0]\n        a2 = precounted[max_possible_ind][1] - precounted[i][1]\n        a3 = precounted[max_possible_ind][2] - precounted[i][2]\n        n1 = 1\n        n2 = 2\n        n3 = 3\n\n        if lst0[i][1] == 1:\n            n1 -= 1\n        elif lst0[i][1] == 2:\n            n2 -= 1\n        else:\n            n3 -= 1\n        ans += ncr(n1, a1) * ncr(n2, a2) * ncr(n3, a3)\n\n    print(ans)\n\nmain()", "def compute(array):\n    ggg = 0\n    ddd = 0\n    fff = 0\n    for elem in array:\n        if elem[1] == 'f':\n            fff += 1\n        if elem[1] == 'd':\n            ddd += 1\n        if elem[1] == 'g':\n            ggg += 1\n    return (ggg, ddd, fff)\n\n\ng, d, f = list(map(int, input().split()))\ngg = list(map(int, input().split()))\ndd = list(map(int, input().split()))\nff = list(map(int, input().split()))\nplayers = []\nfor elem in gg:\n    players.append((elem, 'g'))\nfor elem in dd:\n    players.append((elem, 'd'))\nfor elem in ff:\n    players.append((elem, 'f'))\nplayers = sorted(players)\ncount = 0\nleft = 0\nright = 0\nwhile players[right][0]/players[left][0] <= 2:\n    right += 1\n    if right == len(players):\n        break\nright -= 1\n\na, b, c = compute(players[left:right+1])\ncount += a * b * (b-1) / 2 * c * (c-1) * (c-2) / 6\n\nwhile (1):\n    right += 1\n    if right == len(players):\n        break\n\n    while players[right][0]/players[left][0] > 2:\n        left += 1\n\n    a, b, c = compute(players[left:right+1])\n    x, y, z = compute(players[left:right])\n\n    count += a * b * (b-1) / 2 * c * (c-1) * (c-2) / 6\n    count -= x * y * (y-1) / 2 * z * (z-1) * (z-2) / 6\n\n\nprint(int(count))\n", "s = input().split()\nl = sum([int(i) for i in s])\n\ndata = []\nfor j in range(3):\n    data += [[int(i) for i in input().split()]]\n    data[j] += [100001]\n    data[j].sort()\n\ncursor = [0, 0, 0]\nposCnt = [0, 0, 0]\nlowerBound = 0\nupperBound = 0\n\nfinalCounter = 0\n\nmainQueue = []\nplayer = []\n\ni = 0\nwhile i < l:\n\n    player = min([data[0][cursor[0]], 0], [data[1][cursor[1]], 1], [data[2][cursor[2]], 2])\n\n    if lowerBound == i:\n        mainQueue += [player]\n        cursor[player[1]] += 1\n        upperBound = mainQueue[lowerBound][0] * 2\n        posCnt[player[1]] += 1\n    else:\n        if player[0] > upperBound:\n            if posCnt[0] > 0 and posCnt[1] > 1 and posCnt[2] > 2:\n\n                posCnt[mainQueue[lowerBound][1]] -= 1\n                if mainQueue[lowerBound][1] == 0:\n                    finalCounter += posCnt[1] * (posCnt[1] - 1) * posCnt[2] * (posCnt[2] - 1) * (posCnt[2] - 2) // 12\n                elif mainQueue[lowerBound][1] == 1:\n                    finalCounter += posCnt[0] * posCnt[1] * posCnt[2] * (posCnt[2] - 1) * (posCnt[2] - 2) // 6\n                else:\n                    finalCounter += posCnt[0] * posCnt[1] * (posCnt[1] - 1) * posCnt[2] * (posCnt[2] - 1) // 4\n\n                lowerBound += 1\n                upperBound = mainQueue[lowerBound][0] * 2\n            else:\n                posCnt[mainQueue[lowerBound][1]] -= 1\n                lowerBound += 1\n                if lowerBound < i:\n                    upperBound = mainQueue[lowerBound][0] * 2\n            i -= 1\n\n        else:\n            mainQueue += [player]\n            cursor[player[1]] += 1\n            posCnt[player[1]] += 1\n    i += 1\n\n\nwhile posCnt[0] > 0 and posCnt[1] > 1 and posCnt[2] > 2:\n\n    posCnt[mainQueue[lowerBound][1]] -= 1\n    if not mainQueue[lowerBound][1]:\n        finalCounter += posCnt[1] * (posCnt[1] - 1) * posCnt[2] * (posCnt[2] - 1) * (posCnt[2] - 2) // 12\n    elif mainQueue[lowerBound][1] == 1:\n        finalCounter += posCnt[0] * posCnt[1] * posCnt[2] * (posCnt[2] - 1) * (posCnt[2] - 2) // 6\n    else:\n        finalCounter += posCnt[0] * posCnt[1] * (posCnt[1] - 1) * posCnt[2] * (posCnt[2] - 1) // 4\n\n    lowerBound += 1\n\nprint(finalCounter)\n", "from math import factorial\n\nn, m, k = (int(x) for x in input().split())\na = sorted([int(x) for x in input().split()])\nb = sorted([int(x) for x in input().split()])\nc = sorted([int(x) for x in input().split()])\n\n\ndef create_count_arr(a):\n    a_count = [0] * (10 ** 5 + 5)\n    for i in range(len(a)):\n        a_count[a[i]:] = [i + 1] * ((10 ** 5 + 5) - a[i])\n    return a_count\n\n\ndef get_num(x, y, a):\n    if y >= len(a):\n        y = len(a) - 1\n    c = a[y] - a[x]\n    if a[x] != a[x - 1]:\n        c += 1\n    return c\n\n\ndef num_of_permut(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\n\na_count = create_count_arr(a)\nb_count = create_count_arr(b)\nc_count = create_count_arr(c)\n\ncount = 0\n\nfor i in a:\n    d = get_num(i, i * 2, b_count)\n    f = get_num(i, i * 2, c_count)\n    if d >= 2 and f >= 3:\n        count += num_of_permut(d, 2) * num_of_permut(f, 3)\nfor i in b:\n    g = get_num(i, i * 2, a_count)\n    d = get_num(i, i * 2, b_count) - 1\n    f = get_num(i, i * 2, c_count)\n    if g >= 1 and d >= 1 and f >= 3:\n        count += num_of_permut(d, 1) * num_of_permut(f, 3) * g\nfor i in c:\n    g = get_num(i, i * 2, a_count)\n    d = get_num(i, i * 2, b_count)\n    f = get_num(i, i * 2, c_count) - 1\n    if g >= 1 and d >= 2 and f >= 2:\n        count += num_of_permut(d, 2) * num_of_permut(f, 2) * g\nprint(count)", "#\u0443\u043f\u0440\u043e\u0449\u0435\u043d\u043d\u043e\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 C\ndef c2(n):\n    return n*(n-1)//2\ndef c3(n):\n    return n*(n-1)*(n-2)//6\n\ng,d,f=map(int,input().split())\n#\u041a\u043e\u0441\u0442\u044b\u043b\u044c\nif g<1 or d<2 or f<3:\n    print(0)\n    return\n\nans=0\na=[]\nn=g+d+f\n#\u0441\u043a\u0438\u0434\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u043e\u0434\u0438\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438 \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u0442\u0438\u043f\u044b\nfor i in map(int,input().split()):\n    a.append((i,0))\nfor i in map(int,input().split()):\n    a.append((i,1))\nfor i in map(int,input().split()):\n    a.append((i,2))\n\n#\u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u044d\u0442\u043e\u0442 \u043c\u0430\u0441\u0441\u0438\u0432 \u043f\u043e \u043d\u043e\u043c\u0435\u0440\u0443\na.sort()\n\nfor i in range(n): #\u0432 i \u043f\u0435\u0440\u0435\u0431\u0435\u0440\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0443\u043c\n    types=[0,0,0]\n    j=i+0#\u0432 j \u043f\u0435\u0440\u0435\u0431\u0435\u0440\u0430\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\n    while j<n and a[j][0]<=2*a[i][0]: #\u0435\u0441\u043b\u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0432 2 \u0440\u0430\u0437\u0430 \u043c\u0435\u043d\u044c\u0448\u0435 \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u0430, \u0442\u043e \u0438 \u0432\u0441\u0435 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435\n        types[a[j][1]]+=1\n        now_types=types.copy()\n        now_types[a[j][1]]-=1\n        now_types[a[i][1]]-=1\n        #\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0442\u043e, \u043a\u0430\u043a\u043e\u0433\u043e \u0442\u0438\u043f\u0430 \u043c\u0438\u043d\u0438\u043c\u0443\u043c \u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c, \u0438\u0445 \u043c\u044b \u043d\u0435 \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u0438 \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u0435 \u043a\u043e\u043b-\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u043c\u044b \u0438\u0445 \u0437\u0430\u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043b\u0438, \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0431\u044b\u043b\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u043e\u0432\n        if a[j][1]==0 and a[i][1]==1 or a[j][1]==1 and a[i][1]==0:\n            if now_types[1]>=1 and now_types[2]>=3:\n                ans+=now_types[1]*c3(now_types[2])\n        elif a[j][1]==0 and a[i][1]==2 or a[j][1]==2 and a[i][1]==0:\n            if now_types[1]>=2 and now_types[2]>=2:\n                ans+=c2(now_types[1])*c2(now_types[2])\n        elif a[j][1]==2 and a[i][1]==1 or a[j][1]==1 and a[i][1]==2:\n            if now_types[0]>=1 and now_types[1]>=1 and now_types[2]>=2:\n                ans+=now_types[0]*now_types[1]*c2(now_types[2])\n        elif a[j][1]==1 and a[i][1]==1:\n            if now_types[0]>=1 and now_types[2]>=3:\n                ans+=now_types[0]*c3(now_types[2])\n        elif a[j][1]==2 and a[i][1]==2:\n            if now_types[0]>=1 and now_types[1]>=2 and now_types[2]>=1:\n                ans+=now_types[0]*c2(now_types[1])*now_types[2]\n        j+=1\nprint(ans)", "def C(n, k):\n    if n < k:\n        return 0\n\n    if k == 1:\n        return n                        # \u0421\u043e\u0447\u0435\u0442\u0430\u043d\u0438\u044f \u0438\u0437 n \u043f\u043e 1\n    elif k == 2:\n        return n * (n-1) // 2           # \u0421\u043e\u0447\u0435\u0442\u0430\u043d\u0438\u044f \u0438\u0437 n \u043f\u043e 2\n    elif k == 3:\n        return n * (n-1) * (n-2) // 6   # \u0421\u043e\u0447\u0435\u0442\u0430\u043d\u0438\u044f \u0438\u0437 n \u043f\u043e 3\n\n\ndef main():\n    g, d, f = [int(_) for _ in input().split()]\n    gs = [int(_) for _ in input().split()]\n    ds = [int(_) for _ in input().split()]\n    fs = [int(_) for _ in input().split()]\n\n    ans = 0\n\n    gs.sort()\n    ds.sort()\n    fs.sort()\n    # print(gs)\n    # print(ds)\n    # print(fs)\n\n    gmin, dmin, fmin = 0, 0, 0\n    gmax, dmax, fmax = 0, 0, 0\n\n    while g-gmin >= 1 and d-dmin >= 2 and f-fmin >= 3:\n        term = 1\n        mn = min(gs[gmin], ds[dmin], fs[fmin])\n\n        while gmax < g and gs[gmax] <= mn * 2:\n            gmax += 1\n        gn = gmax - gmin\n        if mn == gs[gmin]:\n            term *= 1\n            gmin += 1\n        else:\n            term *= C(gn, 1)\n\n        while dmax < d and ds[dmax] <= mn * 2:\n            dmax += 1\n        dn = dmax - dmin\n        if mn == ds[dmin]:\n            term *= C(dn-1, 1)\n            dmin += 1\n        else:\n            term *= C(dn, 2)\n\n        while fmax < f and fs[fmax] <= mn * 2:\n            fmax += 1\n        fn = fmax - fmin\n        if mn == fs[fmin]:\n            term *= C(fn-1, 2)\n            fmin += 1\n        else:\n            term *= C(fn, 3)\n\n        ans += term\n\n    print(ans)\n\n\ndef print_test():\n    from random import randint\n    g, d, f = 200, 400, 600\n    # g, d, f = 3, 4, 5\n    print(g, d, f)\n    for _ in range(g):\n        print(randint(1, 100000), end=' ')\n    print()\n    for _ in range(d):\n        print(randint(1, 100000), end=' ')\n    print()\n    for _ in range(f):\n        print(randint(1, 100000), end=' ')\n    print()\n\n\ndef __starting_point():\n    main()\n    # print_test()\n\n# 3 4 5\n# 71655 49064 41937\n# 64260 37491 58885 40628\n# 23852 36500 67530 33756 73\n\n# 3 4 5\n# 71 49 41\n# 64 37 58 40\n# 23 36 67 33 1\n\n# 3 4 6\n# 71 49 41\n# 64 37 58 40\n# 23 36 67 33 1 60\n\n__starting_point()", "\ns = input().split()\nv = int(s[0])\nz = int(s[1])\nn = int(s[2])\ng = [int(i) for i in input().split()]\nd = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\ng.sort()\nd.sort()\nf.sort()\niterator = [0, 0, 0]\nending = [0, 0, 0]\ngap = [0, 0]\ncount = 0\n\nif v < 1 or z < 2 or n < 3:\n    print(0)\nelse:\n    while iterator[0] < v and iterator[1] < z and iterator[2] < n:\n        if g[iterator[0]] < d[iterator[1]] and g[iterator[0]] < f[iterator[2]]: #\u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0432\u0440\u0430\u0442\u0430\u0440\u044c -- \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\n            max = g[iterator[0]]*2 + 1\n            v = int(s[0])\n            while ending[1] < z and d[ending[1]] < max:\n                ending[1] += 1\n            while ending[2] < n and f[ending[2]] < max:\n                ending[2] += 1\n            if ending[1] - iterator[1] < 2:\n                iterator[0] += 1\n                continue\n            elif ending[2] - iterator[2] < 3:\n                iterator[0] += 1\n                continue\n            else:\n                gap[0] = ending[1] - iterator[1]\n                gap[1] = ending[2] - iterator[2]\n                count += gap[0]*(gap[0]-1)*gap[1]*(gap[1]-1)*(gap[1]-2) // 12\n                iterator[0] += 1\n        elif d[iterator[1]] < g[iterator[0]] and d[iterator[1]] < f[iterator[2]]: #\u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0437\u0430\u0449\u0438\u0442\u043d\u0438\u043a -- \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\n            max = d[iterator[1]] * 2 + 1\n            while ending[0] < v and g[ending[0]] < max:\n                ending[0] += 1\n            while ending[1] < z and d[ending[1]] < max:\n                ending[1] += 1\n            while ending[2] < n and f[ending[2]] < max:\n                ending[2] += 1\n            if ending[0] - iterator[0] < 1:\n                iterator[1] += 1\n                continue\n            elif ending[1] - iterator[1] < 2:\n                iterator[1] += 1\n                continue\n            elif ending[2] - iterator[2] < 3:\n                iterator[1] += 1\n                continue\n            else:\n                gap[0] = ending[1] - iterator[1]\n                gap[1] = ending[2] - iterator[2]\n                count += (ending[0] - iterator[0]) * (ending[1] - iterator[1] - 1) * gap[1]*(gap[1]-1)*(gap[1]-2) // 6\n                iterator[1] += 1\n        elif f[iterator[2]] < g[iterator[0]] and f[iterator[2]] < d[iterator[1]]: # \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043d\u0430\u043f\u0430\u0434\u0430\u044e\u0449\u0438\u0439 -- \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\n            max = f[iterator[2]] * 2 + 1\n            while ending[0] < v and g[ending[0]] < max:\n                ending[0] += 1\n            while ending[1] < z and d[ending[1]] < max:\n                ending[1] += 1\n            while ending[2] < n and f[ending[2]] < max:\n                ending[2] += 1\n            if ending[0] - iterator[0] < 1:\n                iterator[2] += 1\n                continue\n            elif ending[1] - iterator[1] < 2:\n                iterator[2] += 1\n                continue\n            elif ending[2] - iterator[2] < 3:\n                iterator[2] += 1\n                continue\n            else:\n                gap[0] = ending[1] - iterator[1]\n                gap[1] = ending[2] - iterator[2]\n                count += (ending[0] - iterator[0]) * gap[0]*(gap[0]-1) * (gap[1]-1)*(gap[1]-2) // 4\n                iterator[2] += 1\n    print(count)\n\n", "g,d,f = map(int,input().split())\n\ngoalkeepers = list(map(int,input().split()))\ndefenders = list(map(int,input().split()))\nforwards = list(map(int,input().split()))\n\n\n\n#min goalkeeper\ncount = 0\n\nfor keeper in goalkeepers:\n    defend = len(list(filter(lambda x:x>keeper and x<=keeper*2,defenders)))\n    forw = len(list(filter(lambda x:x>keeper and x<=keeper*2,forwards)))\n    count+=defend*(defend - 1)*forw*(forw-1)*(forw-2)/12\n\n\n\n# min def\n\nfor defend in defenders:\n    second_defend = len(list(filter(lambda x:x>defend and x<=defend*2,defenders)))\n    forw = len(list(filter(lambda x:x>defend and x<=defend*2,forwards)))\n    goal  = len(list(filter(lambda x:x>defend and x<=defend*2,goalkeepers)))\n    count+=second_defend*goal*forw*(forw-1)*(forw-2)/6\n\nfor defend in forwards:\n    second_defend = len(list(filter(lambda x: x > defend and x <= defend * 2, defenders)))\n    forw = len(list(filter(lambda x: x > defend and x <= defend * 2, forwards)))\n    goal = len(list(filter(lambda x: x > defend and x <= defend * 2, goalkeepers)))\n    count += second_defend *(second_defend-1)* goal * forw * (forw - 1)   / 4\n\nprint(int(count))"]
["import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nn = int(rd())\nc = list(map(int, rd().split()))\na = list([int(x)-1 for x in rd().split()])\n\nvisited = [-1] * (n)\nres = 0\n\nfor i in range(n):\n    trace = []\n    \n    t = i\n    mn = 1e9\n    while visited[t] == -1:\n        visited[t] = i\n        trace.append(t)\n        t = a[t]\n        \n    if visited[t] != i:\n        continue\n        \n    while len(trace) > 0:\n        v = trace.pop()\n        mn = min(mn, c[v]) \n        \n        if t == v: break\n    \n    res += mn\n    \nprint(res)\n", "input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n    \n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)\n", "input()\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nu = [0] * len(a)\n\nans = 0\n\nfor i in range(len(a)):\n    if u[i] != 0:\n        continue\n    idx = i\n    while u[idx] == 0:\n        u[idx] = 1\n        idx = a[idx] - 1\n    \n    if (u[idx] == 2):\n        idx = i\n        while u[idx] == 1:\n            u[idx] = 2\n            idx = a[idx] - 1\n        continue\n\n    start = idx\n    mn = c[idx]\n    u[idx] = 2\n    while a[idx] - 1 != start:\n        idx = a[idx] - 1\n        mn = min(mn, c[idx])\n        u[idx] = 2\n\n    idx = i\n    while u[idx] == 1:\n        u[idx] = 2\n        idx = a[idx] - 1\n    ans += mn\nprint(ans)", "n = int(input())\nc = [0] + [int(j) for j in input().split()]\na = [0] + [int(j) for j in input().split()]\nvis = [0] * (n + 1)\nans = 0\nfor i in range(1, n + 1):\n    x = i\n    while vis[x] == 0:\n        vis[x] = i\n        x = a[x]\n    if vis[x] != i:\n        continue\n    v = x\n    mn = c[x]\n    while a[x] != v:\n        x = a[x]\n        mn = min(mn, c[x])\n    ans += mn\nprint(ans)\n", "n = int(input())\nc  = [0] + [int(j) for j in input().split()]\na  = [0] + [int(j) for j in input().split()]\n\nvis = [0] * (n+1)\nans = 0\nfor i in range(1,n+1):\n    x = i\n    while vis[x] == 0:\n        vis[x] = i\n        x = a[x]\n    if vis[x] != i:\n        continue\n    v = x\n    mn = c[x]\n    while a[x] != v:\n        x = a[x]\n        mn = min(mn,c[x])\n    ans+=mn\nprint(ans)\n", "n = int(input())\nC = [int(s) for s in input().split(\" \")]\nA = [int(s)-1 for s in input().split(\" \")]\nal = [False for i in range(0, n)]\nans = 0\nfor v in range(0, n):\n    if al[v]:\n        continue\n    sequence = []\n    while not al[v]:\n        sequence.append(v)\n        al[v] = True\n        v = A[v]\n    if v in sequence:\n        tek = C[v]\n        for j in sequence[sequence.index(v)+1:]:\n            tek = min(C[j], tek)\n        ans += tek\nprint(ans)", "n=int(input())\ncst=list(map(int,input().split()))\nroute=list(map(int,input().split()))\nvisited=[0]*n\ncost=0\nfor i in range(n):\n\tif visited[i]==0:\n\t\tmini=99999999\n\t\tj=i\n\t\twhile(visited[j]==0):\n\t\t\tvisited[j]=i+1\n\t\t\tj=route[j]-1\n\t\t\t#print(visited,j)\n\t\t\tif visited[j]==i+1:\n\t\t\t\tmini=cst[j]\n\t\t\t\tk=route[j]-1\n\t\t\t\twhile(k!=j):\n\t\t\t\t\t#print(k,j)\n\t\t\t\t\tif cst[k]<mini:\n\t\t\t\t\t\tmini=cst[k]\n\t\t\t\t\tk=route[k]-1\n\t\tif mini!=99999999:\n\t\t\tcost+=mini\nprint(cost)\n", "n = int(input())\nc = list(map(int, input().split()))\na = list([int(x) - 1 for x in input().split()])\nb = [None] * n\nprocessed = [False for i in range(n)]\nfor i in range(n):\n    if not b[a[i]]:\n        b[a[i]] = {i}\n    else:\n        b[a[i]].add(i)\n\nrings = []\n\n\ndef processed_ring(ring):\n    copy_ring = ring.copy()\n    while copy_ring:\n        new_ring = set()\n        for el in copy_ring:\n            processed[el] = True\n            if b[el]:\n                new_ring |= b[el]\n        copy_ring = new_ring - copy_ring\n\n\nfor i in range(n):\n    if processed[i]:\n        continue\n    ring = set()\n    position = set()\n    next_pos = i\n    while next_pos not in position:\n        position.add(next_pos)\n        next_pos = a[next_pos]\n    while next_pos not in ring:\n        ring.add(next_pos)\n        next_pos = a[next_pos]\n    processed_ring(ring)\n    rings.append(ring)\n\nres = sum(min(c[i] for i in ring) for ring in rings)\nprint(res)\n", "def main():\n        n=int(input())\n        c=[int(i) for i in input().split()]\n        a=[int(i) for i in input().split()]\n        vis=[0]*(n+1)\n        sum=0\n        for i in range(1,n+1):\n                x=i\n                while(vis[x]==0):\n                        vis[x]=i\n                        x=a[x-1]\n                if vis[x]!=i:\n                        continue\n                p=x\n                cos=c[x-1]\n                while(p!=a[x-1]):\n                        x=a[x-1]\n                        cos=min(c[x-1],cos)\n                sum=sum+cos\n        return sum\nprint(main())\n", "def count(n,c,a):\n        vis=[0]*(n+1)\n        z=[]\n        p=[]\n        for i in range(1,n+1):\n                x=i\n                while vis[x]==0:\n                        vis[x]=i\n                        x=a[x-1]\n                if vis[x]==i:\n                        p.append(x)\n        return p\ndef opium(n,c,a):\n        sum=0\n        p=list(set(count(n,c,a)))\n        #print(p)\n        for x in p:\n                v=x\n                cd=c[x-1]\n                while v!=a[x-1]:\n                        x=a[x-1]\n                        cd=min(cd,c[x-1])\n                sum=sum+cd\n                #print(sum)\n        return sum\ndef main():\n        n=int(input())\n        c=[int(i) for i in input().split()]\n        a=[int(i) for i in input().split()]\n        return opium(n,c,a)\nprint(main())\n", "n = int(input())\nc  = [0] + [int(j) for j in input().split()]\na  = [0] + [int(j) for j in input().split()]\n \nvis = [0] * (n+1)\nans = 0\nfor i in range(1,n+1):\n    x = i\n    while vis[x] == 0:\n        vis[x] = i\n        x = a[x]\n    if vis[x] != i:\n        continue\n    v = x\n    mn = c[x]\n    while a[x] != v:\n        x = a[x]\n        mn = min(mn,c[x])\n    ans+=mn\nprint(ans)", "def main():\n    n, r = int(input()) + 1, 0\n    cc = [0, *list(map(int, input().split()))]\n    aa = [0, *list(map(int, input().split()))]\n    avail = [True] * n\n    for i, a in enumerate(avail):\n        if a:\n            j = i\n            while avail[j]:\n                avail[j] = False\n                j = aa[j]\n            c, j = cc[j], aa[j]\n            if c:\n                while cc[j]:\n                    if c > cc[j]:\n                        c = cc[j]\n                    cc[j] = 0\n                    j = aa[j]\n                r += c\n            while cc[i]:\n                cc[i] = 0\n                i = aa[i]\n    print(r)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -------------------------SOLVE STACK OVERFFLOW WHILE DFS\n# input\nn = input()\na = list(map(int, input().split())) # costs of each room\na_next = list(map(int, input().split())) # a_next[i] : the next room of ith room\nfor i in range(len(a_next)):\n    a_next[i] -= 1\n    \ncycles = [] # list of cycles\ncheck = [0]*len(a) # check array (0:unchecked, 1:visited, 2:belongs to a cycle)\n\n# dfs function. make cycles along the way\ndef dfs(v):\n    path = [] # path of dfs\n    s = [] # dfs stack\n    \n    check[v] = 1\n    path.append(v)\n    s.append(v)\n\n    while s:\n        next_v = a_next[s[-1]]\n        \n        if check[next_v] == 0:\n            check[next_v] = 1\n            path.append(next_v)\n            s.append(next_v)\n        else:\n            if check[next_v] == 1: # a new cycle has been found\n                cycle = []\n                while path[-1] != next_v:\n                    cycle.append(path.pop())\n                cycle.append(next_v)\n                cycles.append(cycle)\n            # empty the stack\n            while s:\n                check[s.pop()] = 2\n\n# make a list of cycles\nfor i in range(len(a)):\n    if check[i] == 0:\n        dfs(i)\n\n# add up all minimum costs for each cycle\nans = 0 # answer\nfor cycle in cycles:\n    min_cost = a[cycle[0]]\n    for v in cycle:\n        if a[v] < min_cost:\n            min_cost = a[v]\n    ans += min_cost\n\n# print answer\nprint(ans)\n", "n = int(input())\n\nc = list(map(int, input().split()))\n\na = list([int(x) - 1 for x in input().split()])\n\ndeg_in = [0 for _ in range(n)]\n\nd_in_to_v_set = {i: set() for i in range(n + 1)}\n\nfor ai in a:\n    deg_in[ai] += 1\n\nfor i in range(n):\n    d_in_to_v_set[deg_in[i]].add(i)\n\nwhile d_in_to_v_set[0] != set():\n    l = list(d_in_to_v_set[0])\n    for u in l:\n        d_in_to_v_set[deg_in[a[u]]].remove(a[u])\n        d_in_to_v_set[deg_in[a[u]] - 1].add(a[u])\n        d_in_to_v_set[0].remove(u)\n        deg_in[a[u]] -= 1\n\np = [0 for _ in range(n)]\n\nfor v in d_in_to_v_set[1]:\n    p[v] = 1\n\nans, cur = 0, 10**5\n\nfor i in range(n):\n    s = i\n    cur = 10**5\n    while p[s] != 0:\n        cur = min(cur, c[s])\n        p[s] = 0\n        s = a[s]\n    ans += cur if cur < 10**5 else 0\n\nprint(ans)\n", "n = int(input())\n\nc = list(map(int, input().split()))\n\na = list([int(x) - 1 for x in input().split()])\n\ndeg_in = [0 for _ in range(n)]\n\nd_in_to_v_set = {i: set() for i in range(n + 1)}\n\nfor ai in a:\n    deg_in[ai] += 1\n\nfor i in range(n):\n    d_in_to_v_set[deg_in[i]].add(i)\n\nwhile d_in_to_v_set[0] != set():\n    l = list(d_in_to_v_set[0])\n    for u in l:\n        d_in_to_v_set[deg_in[a[u]]].remove(a[u])\n        d_in_to_v_set[deg_in[a[u]] - 1].add(a[u])\n        d_in_to_v_set[0].remove(u)\n        deg_in[a[u]] -= 1\n\np = [0 for _ in range(n)]\n\nfor v in d_in_to_v_set[1]:\n    p[v] = 1\n\nans, cur = 0, 10**5\n\nfor i in range(n):\n    s = i\n    cur = 10**5\n    while p[s] != 0:\n        cur = min(cur, c[s])\n        p[s] = 0\n        s = a[s]\n    ans += cur if cur < 10**5 else 0\n\nprint(ans)\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 12/10/18\n\n\"\"\"\n\nN = int(input())\nC = [0] + [int(x) for x in input().split()]\nA = [0] + [int(x) for x in input().split()]\n\n\nans = 0\nvis = [False] * (N+1)\nfor i in range(1, N+1):\n    if vis[i]:\n        continue\n    \n    circle = []\n    u = i\n    while not vis[u]:\n        circle.append(u)\n        vis[u] = True\n        u = A[u]\n    \n    if u in circle:\n        ans += min([C[j] for j in circle[circle.index(u):]])\n\nprint(ans)", "n = int(input())\nc = [0] + list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\n\ng = [0] * (n+1)\nanswer = 0\n\nfor i in range(1,n+1):\n    node = i\n    while g[node] == 0:\n        g[node] = i\n        node = a[node]\n    if g[node] != i:\n        continue\n    current = node\n    min_cost = c[node]\n    while a[node] != current:\n        node = a[node]\n        min_cost = min(min_cost,c[node])\n    answer += min_cost\n\nprint(answer)", "# n = input()\n# a = input()\n# b = input()\n# print(n)\n# print(a)\n# print(b)\n# import sys\n# sys.setrecursionlimit(1000000)\n# try:\nn = int(input())\nburles = list(map(int, input().split()))\ndirections = list(map(int, input().split()))\n\nburles.insert(0,0)\ndirections.insert(0,0)\n\n\nv = [0]*(n+1)# visitou\ng = [0]*(n+1)# grupo\n\n\n\ndef passa(pos):\n\n\tnonlocal current_group\n\tnonlocal v\n\tnonlocal g\n\tnonlocal soma_total\n\tpilha = [-1]\n\tavanco = True\n\t# print('posicao {} {}'.format(pos, v[pos]))\n\t# print('Visita {}'.format(pos))\n\tgrupo = 0\n\testa_no_ciclo = False\n\tmenor_local = 0\n\twhile pilha:\n\t\t\n\t\tif avanco:\n\n\t\t\tif v[pos] == 1:\n\t\t\t\tv[pos] = 2\n\t\t\t\tif g[pos] == 0:\n\t\t\t\t\tg[pos] = current_group\n\t\t\t\t\t# print('atribui grupo {}'.format(current_group))\n\t\t\t\t\tcurrent_group+=1\n\t\t\t\t\n\t\t\t\tgrupo = g[pos]\n\t\t\t\tavanco = False\n\t\t\t\testa_no_ciclo = True\n\t\t\t\tmenor_local = burles[pos]\n\n\t\t\telif v[pos] == 2 or v[pos] == 3:\n\t\t\t\tgrupo = g[pos]\n\t\t\t\tavanco = False\n\t\t\t\testa_no_ciclo = False\n\t\t\t\tgrupo = g[pos]\n\t\t\telse:\t\n\t\t\t\tv[pos] = 1\n\t\t\t\tpilha.append(pos)\n\t\t\t\tpos = directions[pos]\n\t\t\n\t\t# g[pos], ver, minimo = passa(directions[pos])\n\t\t\n\t\telse:\n\t\t\tpos = pilha.pop(len(pilha)-1)\n\t\t\tif pos < 0:\n\t\t\t\tcontinue\n\t\t\tg[pos] = grupo\n\t\t\tif v[pos] ==2 and esta_no_ciclo:\n\t\t\t\tsoma_total+=menor_local\n\t\t\t\testa_no_ciclo = False\n\n\t\t\t\t# return g[pos], False, 0\n\n\t\t\telif v[pos] ==1 and esta_no_ciclo:\n\t\t\t\tv[pos] = 2\n\t\t\t\tmenor_local = min(menor_local, burles[pos])\n\t\t\t\t# return g[pos], True, min(minimo, burles[pos])\n\t\t\t\n\t\t\tif v[pos] ==1 and not esta_no_ciclo:\n\t\t\t\tv[pos] = 3\n\n\t\t\t\t# return g[pos], False, 0\n\n\n\t\t\t# return g[pos], False, 0\n\t# print('atribui grupo {}'.format(g[pos]))\n\ncurrent_group = 1\nsoma_total = 0\nfor i in range(1, n+1):\n\tif v[i] ==0:\n\t\tpassa(i)\nprint(soma_total)\n# except Exception:\n# print(sys.exc_info()[2])\n\n\n\n# dicionario = {}\n# for i in range(1, n+1):\n# \tif v[i] == 2:\n# \t\tgrupo = g[i]\n# \t\tmenor = dicionario.get(grupo, None)\n# \t\tif menor:\n# \t\t\tdicionario[grupo] = min(menor, burles[i])\n\n# \t\telse:\n# \t\t\tdicionario[grupo] = burles[i]\n\n# print(int(sum(dicionario.values())))\n\n# except RuntimeError as e:\n# \tprint(1)\n# \tprint(str(e))\n\n# print(g)\n# print(v)\n\n# conjunto = set()\n# soma = 0\n# for i in range(1, len(p)):\n# \tif g[i] not in conjunto:\n# \t\tconjunto.add(g[i])\n# \t\tsoma+=p[i]\n\n\n\n# answer = 0\n\n# for i in range(1,n+1):\n#     node = i\n#     while g[node] == 0:\n#         g[node] = i\n#         node = a[node]\n#     if g[node] != i:\n#         continue\n#     current = node\n#     min_cost = c[node]\n#     while a[node] != current:\n#         node = a[node]\n#         min_cost = min(min_cost,c[node])\n#     answer += min_cost\n\n# print(answer)\n# print(v)\n# print(g)\n# print(p)\n# print(dicionario)\n", "# n = input()\n# a = input()\n# b = input()\n# print(n)\n# print(a)\n# print(b)\n# import sys\n# sys.setrecursionlimit(1000000)\n# try:\nn = int(input())\nburles = list(map(int, input().split()))\ndirections = list(map(int, input().split()))\n\nburles.insert(0,0)\ndirections.insert(0,0)\n\n\nv = [0]*(n+1)# visitou\ng = [0]*(n+1)# grupo\n\n\n\ndef passa(pos):\n\n\tnonlocal current_group\n\tnonlocal v\n\tnonlocal g\n\tnonlocal soma_total\n\tpilha = [-1]\n\tavanco = True\n\t# print('posicao {} {}'.format(pos, v[pos]))\n\t# print('Visita {}'.format(pos))\n\tgrupo = 0\n\testa_no_ciclo = False\n\tmenor_local = 0\n\twhile pilha:\n\t\t\n\t\tif avanco:\n\n\t\t\tif v[pos] == 1:\n\t\t\t\tv[pos] = 2\n\t\t\t\tif g[pos] == 0:\n\t\t\t\t\tg[pos] = current_group\n\t\t\t\t\t# print('atribui grupo {}'.format(current_group))\n\t\t\t\t\tcurrent_group+=1\n\t\t\t\t\n\t\t\t\tgrupo = g[pos]\n\t\t\t\tavanco = False\n\t\t\t\testa_no_ciclo = True\n\t\t\t\tmenor_local = burles[pos]\n\n\t\t\telif v[pos] == 2 or v[pos] == 3:\n\t\t\t\tgrupo = g[pos]\n\t\t\t\tavanco = False\n\t\t\t\testa_no_ciclo = False\n\t\t\t\tgrupo = g[pos]\n\t\t\telse:\t\n\t\t\t\tv[pos] = 1\n\t\t\t\tpilha.append(pos)\n\t\t\t\tpos = directions[pos]\n\t\t\n\t\t# g[pos], ver, minimo = passa(directions[pos])\n\t\t\n\t\telse:\n\t\t\tpos = pilha.pop(len(pilha)-1)\n\t\t\tif pos < 0:\n\t\t\t\tcontinue\n\t\t\tg[pos] = grupo\n\t\t\tif v[pos] ==2 and esta_no_ciclo:\n\t\t\t\tsoma_total+=menor_local\n\t\t\t\testa_no_ciclo = False\n\n\t\t\t\t# return g[pos], False, 0\n\n\t\t\telif v[pos] ==1 and esta_no_ciclo:\n\t\t\t\tv[pos] = 2\n\t\t\t\tmenor_local = min(menor_local, burles[pos])\n\t\t\t\t# return g[pos], True, min(minimo, burles[pos])\n\t\t\t\n\t\t\tif v[pos] ==1 and not esta_no_ciclo:\n\t\t\t\tv[pos] = 3\n\n\t\t\t\t# return g[pos], False, 0\n\n\n\t\t\t# return g[pos], False, 0\n\t# print('atribui grupo {}'.format(g[pos]))\n\ncurrent_group = 1\nsoma_total = 0\nfor i in range(1, n+1):\n\tif v[i] ==0:\n\t\tpassa(i)\nprint(soma_total)\n# except Exception:\n# print(sys.exc_info()[2])\n\n\n\n# dicionario = {}\n# for i in range(1, n+1):\n# \tif v[i] == 2:\n# \t\tgrupo = g[i]\n# \t\tmenor = dicionario.get(grupo, None)\n# \t\tif menor:\n# \t\t\tdicionario[grupo] = min(menor, burles[i])\n\n# \t\telse:\n# \t\t\tdicionario[grupo] = burles[i]\n\n# print(int(sum(dicionario.values())))\n\n# except RuntimeError as e:\n# \tprint(1)\n# \tprint(str(e))\n\n# print(g)\n# print(v)\n\n# conjunto = set()\n# soma = 0\n# for i in range(1, len(p)):\n# \tif g[i] not in conjunto:\n# \t\tconjunto.add(g[i])\n# \t\tsoma+=p[i]\n\n\n\n# answer = 0\n\n# for i in range(1,n+1):\n#     node = i\n#     while g[node] == 0:\n#         g[node] = i\n#         node = a[node]\n#     if g[node] != i:\n#         continue\n#     current = node\n#     min_cost = c[node]\n#     while a[node] != current:\n#         node = a[node]\n#         min_cost = min(min_cost,c[node])\n#     answer += min_cost\n\n# print(answer)\n# print(v)\n# print(g)\n# print(p)\n# print(dicionario)\n", "def dfs(node,edges,costs,visited):\n    cycle = False\n    visited1 = set()\n    while True:\n        if node in visited:\n            for i in visited1:\n                visited.add(i)\n            return 0\n        if not edges[node]:\n            visited1.add(node)\n            break\n        if node not in visited1:\n            visited1.add(node)\n            node = edges[node][0]\n        else:\n            cycle = True\n            break\n\n    #print(node,cycle,visited)\n    if cycle:\n        x = edges[node][0]\n        min_cost = costs[x-1]\n        while x != node:\n            x = edges[x][0]\n            min_cost = min(min_cost,costs[x-1])\n        cost = min_cost\n    else:\n        cost = costs[node-1]\n\n    for i in visited1:\n        visited.add(i)\n\n    return cost\n    \n\ndef solve(zero,edges,costs):\n    n = len(costs)\n    visited = set()\n    cost = 0\n\n    for i in range(1,n+1):\n        if i not in visited:\n            cost += dfs(i,edges,costs,visited)\n\n    print(cost)\n\ndef main():\n    n = int(input())\n    costs = list(map(int,input().split()))\n    mouse = list(map(int,input().split()))\n    edges = {}\n    for i in range(1,n+1):\n        edges[i] = []\n\n    indegree = [0]*(n+1)\n    for i in range(1,n+1):\n        if i != mouse[i-1]:\n            edges[i].append(mouse[i-1])\n            indegree[mouse[i-1]] += 1\n\n    zero = []\n    for i in range(1,n+1):\n        if indegree[i] == 0:\n            zero.append(i)\n\n    solve(zero,edges,costs)\n\n\nmain()\n", "n=int(input())\nc=list(map(int,input().split()))\na=list(map(int,input().split()))\n\nans=0\nv=[False for i in range(n)]\nfor i in range(n):\n\tif v[i]:continue\n\tp=set()\n\tpl=[]\n\ts=set([i])\n\tt=True\n\twhile s and t:\n\t\tx=s.pop()\n\t\tv[x]=True\n\t\tp.add(x)\n\t\tpl.append(x)\n\t\tnex=a[x]-1\n\t\ts.add(nex)\n\t\tif nex in p:\n\t\t\tj=pl.index(nex)\n\t\t\tza=s.pop()\n\t\telif v[nex]:t=False;za=s.pop()\n\t\t\n\t\n\tif not t:continue\n\tan=float(\"INF\")\n\tfor k in range(j,len(pl)):\n\t\tan=min(c[pl[k]],an)\n\tans+=an\nprint(ans)", "# 1027D\nimport collections\ndef do():\n    n = int(input())\n    costs = [int(c) for c in input().split(\" \")]\n    next = [int(c)-1 for c in input().split(\" \")]\n    ind = [0] * n\n    for i,c in enumerate(next):\n        if i != c:\n            ind[c] += 1\n    seen = [0] * n\n    res_seen = [0] * n\n    res = 0\n\n    def get(entry):\n        m = costs[entry]\n        p = entry\n        while True:\n            if res_seen[p]:\n                return 0\n            res_seen[p] = 1\n            m = min(m, costs[p])\n            p = next[p]\n            if p == entry:\n                break\n        return m\n\n    def dfs(i):\n        stack = [i]\n        seen[i] = 1\n        while stack:\n            cur = stack.pop()\n            nei = next[cur]\n            if seen[nei]:\n                return get(nei)\n            seen[nei] = 1\n            stack.append(nei)\n        return 0\n\n    for i in range(n):\n        if ind[i] == 0:\n            res += dfs(i)\n    for i in range(n):\n        if seen[i] == 0:\n            res += dfs(i)\n    return res\n\nprint(do())\n", "import sys\nreadline = sys.stdin.readline\n\n\nN = int(readline())\nC = list(map(int, readline().split()))\nA = list(map(lambda x: int(x)-1, readline().split()))\n\n\ninf = 10**9\nused = set()\nans = 0\nfor i in range(N):\n    if i in used:\n        continue\n    seen = set()\n    stack = [i]\n    cnt = 0\n    st = None\n    while stack:\n        vn = stack.pop()\n        vf = A[vn]\n        if vf in used:\n            break\n        if vf in seen:\n            st = vf\n            break\n        seen.add(vf)\n        stack.append(vf)\n        \n    if st is not None:\n        vn = st\n        cnt = C[vn]\n        vf = A[vn]\n        vn = A[vn]\n        while vn != st:\n            cnt = min(cnt, C[vn])\n            vn = A[vn]\n    used |= seen\n    ans += cnt\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n        \nn = int(input())\nc = list(map(int, input().split()))\nuf = Unionfind(n)\na = list(map(int, input().split()))\n\nfor i in range(n):\n    uf.unite(i, a[i]-1)\n\nroots = set(uf.root(i) for i in range(n))\nans = 0\n\nfor r in roots:\n    cur = r\n    s = {r}\n    \n    while True:\n        nex = a[cur]-1\n        \n        if nex in s:\n            sta = nex\n            break\n        \n        s.add(nex)\n        cur = nex\n    \n    add = c[sta]\n    cur = sta\n    \n    while True:\n        nex = a[cur]-1\n        \n        if nex==sta:\n            break\n        \n        add = min(add, c[nex])\n        cur = nex\n    \n    ans += add\n\nprint(ans)", "n = int(input())\nc = list(map(int, input().strip().split()))\na = list(map(int, input().strip().split()))\nresd = {}\nres = 0\ntmpd = {}\nfor i in range(n):\n    cur = i + 1\n    d = {}\n    group = []\n    flag = False\n    while cur not in d:\n        if cur in tmpd:\n            flag = True\n            break\n        d[cur] = 1\n        tmpd[cur] = 1\n        group.append(cur)\n        cur = a[cur - 1]\n    if flag:\n        continue\n    mmin = float('inf')\n    ind = float('inf')\n    flag = False\n    for item in group:\n        if item == cur:\n            flag = True\n        if flag:\n            mmin = min(c[item - 1], mmin)\n            ind = min(ind, item)\n    if ind in resd:\n        continue\n    else:\n        resd[ind] = 1\n        res += mmin\n\nprint(res)\n"]
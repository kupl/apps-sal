["from math import ceil\n\nn, k = list(map(int, input().split()))\n\nprint(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))\n", "n,k=map(int,input().split())\nans=0\nans+=(2*n)//k + bool((2*n)%k!=0)\nans+=(5*n)//k + bool((5*n)%k!=0)\nans+=(8*n)//k + bool((8*n)%k!=0)\nprint(ans)", "from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\n\nn, k = map(int, stdin.readline().split())\nstdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))", "n, k = list(map(int, input().split()))\na, b, c = 2 * n, 5 * n, 8 * n\nceil = lambda x, y: (x + y - 1) // y\nprint(ceil(a, k) + ceil(b, k) + ceil(c, k))\n", "n, k = list(map(int, input().split()))\nr_n = n * 2\ng_n = n * 5\nb_n = n * 8\nt = 0\nt += r_n // k\nif r_n % k != 0:\n    t += 1\nt += g_n // k\nif g_n % k != 0:\n    t += 1\n\nt += b_n // k\nif b_n % k != 0:\n    t += 1\nprint(t)\n", "N, K= list(map(int, input().split()))\nRcnt = N * 2\nGcnt = N * 5\nBcnt = N * 8\n\nres = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K\nprint(res)\n", "import sys\nfrom math import floor, ceil\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\n\nprint(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))", "from math import ceil\nn, k = map(int, input().split())\nprint(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))", "n,k = map(int, input().split())\n\n# red = 2\n# g = 5\n# b = 8\nr = (n*2+k-1)//k\ng = (n*5+k-1)//k\nb = (n*8+k-1)//k\nprint (r+b+g)", "n,k = map(int, input().split())\na = 2*n\nb = 5*n\nc = 8*n\nprint((a+k-1)//k + (b+k-1)//k + (c + k -1) // k)", "n,k = list(map(int,input().split()))\nprint((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)\n", "from math import ceil\nn, k = map(int, input().split())\ncou = 0\ncou += ceil(n*2/k)\ncou += ceil(n*5/k)\ncou += ceil(n*8/k)\nprint(cou)", "from math import ceil\nn,k = list(map(int,input().split()))\nprint(ceil(n*2/k)+ceil(n*5/k)+ceil(n*8/k))\n", "from math import ceil\n\nn, k = list(map(int, input().strip().split()))\nr = 2*n\ng = 5*n\nb = 8*n\n\nprint(ceil(r/k)+ceil(g/k)+ceil(b/k))", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\n            \n\ndef main():\n    n,k = get_tuple()\n    print(math.ceil(2*n/k)+math.ceil(5*n/k)+math.ceil(8*n/k))\n    \n        \n            \n\n\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\nans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k\nprint(ans)\n", "n, k = map(int, input().split())\nprint((8 * n + k - 1) // k + (5 * n + k - 1) // k + (2 * n + k - 1) // k)", "n,k=list(map(int,input().split()))\nprint((-(-n*2//k))+(-(-n*5//k))+(-(-n*8//k)))\n#2,5,8\n", "import math\nn,k  =[*list(map(int, input().split()))]\n\ncount = 0\n\ncount+= math.ceil(2*n/k)\ncount+= math.ceil(5*n/k)\ncount+= math.ceil(8*n/k)\nprint(count)\n\n", "from collections import defaultdict\n# from fractions import Fraction\ndef read_line():\n    return [int(x) for x in input().split()]\n\nn, k = read_line()\n\nfrom math import ceil\nprint(sum(ceil(n*c/k) for c in  [2, 5, 8]))\n", "def mainA():\n    n, k = list(map(int, input().split()))\n    print((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k)\n\nmainA()\n", "from math import ceil \n\nt = 1#int(input())\nfor test in range(t):\n    n,k = (list(map(int, input().split())))\n    (ceil(((n*8)/k)))\n    print((ceil(((n*8)/k))) + (ceil(((n*5)/k))) + (ceil(((n*2)/k))))\n \n\n\n\n\n"]
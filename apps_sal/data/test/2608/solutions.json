["def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\ndef pre(x, y):\n    w = x * (y // 2) + (y % 2) * (x + 1) // 2\n    b = x * (y // 2) + (y % 2) * x // 2\n    assert w + b == x * y\n    return w\n\ndef count(x1, y1, x2, y2):\n    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)\n    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w\n    return w, b\n\nfor t in range(ii()):\n    n, m = mi()\n    x1, y1, x2, y2 = mi()\n    x3, y3, x4, y4 = mi()\n    w = pre(m, n)\n    b = m * n - w\n    # white spill\n    wc, bc = count(x1, y1, x2, y2)\n    w -= wc\n    b -= bc\n    w += (x2 - x1 + 1) * (y2 - y1 + 1)\n    # black spill\n    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):\n        x5 = max(x1, x3)\n        y5 = max(y1, y3)\n        x6 = min(x2, x4)\n        y6 = min(y2, y4)\n        w -= (x6 - x5 + 1) * (y6 - y5 + 1)\n        wc, bc = count(x5, y5, x6, y6)\n        w += wc\n        b += bc\n    wc, bc = count(x3, y3, x4, y4)\n    w -= wc\n    b -= bc\n    b += (x4 - x3 + 1) * (y4 - y3 + 1)\n    print(w, b)", "def main():\n    def calc(x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:\n            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n        if (x1 + y1) % 2 == 1:\n            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1\n        return (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n    T = int(input())\n    for t in range(T):\n        n, m = list(map(int, input().split()))\n        a, b, c, d = list(map(int, input().split()))\n        e, f, g, h = list(map(int, input().split()))\n        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)\n        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)\n        print(n * m - black, black)\n\nmain()\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    q = I()\n    rr = []\n\n    def f(a,b,c,d):\n        if a > c or b > d:\n            return (0,0)\n        sa = c-a + 1\n        sb = d-b + 1\n        g = h = (sa * sb) // 2\n        if (sa*sb) % 2 == 1:\n            g += 1\n\n        if (a+b) % 2 == 0:\n            return (g,h)\n        return (h,g)\n\n    def fa(a):\n        return f(a[0],a[1],a[2],a[3])\n\n    for _ in range(q):\n        n,m = LI()\n        wa = LI()\n        ba = LI()\n        wc,bc = f(1,1,n,m)\n        w1,b1 = fa(wa)\n        w2,b2 = fa(ba)\n        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))\n\n        wc += b1\n        bc -= b1\n        wc -= w2\n        bc += w2\n        wc -= b3\n        bc += b3\n        rr.append('{} {}'.format(wc,bc))\n\n\n    return \"\\n\".join(map(str,rr))\n\n\nprint(main())\n", "def color(x, y):\n\t# print(f'color(x = {x}, y = {y}) called')\n\treturn 'white' if (x + y) % 2 == 0 else 'black'\n\n\ndef white(x1, y1, x2, y2):\n\t\"\"\" x1 <= x2, y1 <= y2 \"\"\"\n\t# print(f'white(x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}) called')\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\tif color(x1, y1) != color(x2, y2):\n\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n\telse:\n\t\tif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2\n\t\telif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':\n\t\t\treturn ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2\n\t\telse:\n\t\t\treturn (x2 - x1 + 1) * (y2 - y1 + 1) // 2\t\n\n\ndef black(x1, y1, x2, y2):\n\t\"\"\" x1 <= x2, y1 <= y2 \"\"\"\n\tif x1 > x2 or y1 > y2:\n\t\treturn 0\n\n\treturn (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)\n\n\ndef intersect_1D(x1, x2, x3, x4):\n\t\"\"\" x1 <= x2, x3 <= x4 \"\"\"\n\treturn max(x1, x3), min(x2, x4)\n\n\ndef intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):\n\t\"\"\" x1 <= x2, x3 <= x4, y1 <= y2, y3 <= y4 \"\"\"\n\txl, xr = intersect_1D(x1, x2, x3, x4)\n\tyl, yr = intersect_1D(y1, y2, y3, y4)\n\treturn xl, yl, xr, yr\n\n\nfor i in range(int(input())):\n\tn, m = list(map(int, input().split()))\n\t# print(f'n = {n}, m = {m}')\n\tx1, y1, x2, y2 = list(map(int, input().split()))\n\t# print(f'x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}')\n\tx3, y3, x4, y4 = list(map(int, input().split()))\n\t# print(f'x3 = {x3}, y3 = {y3}, x4 = {x4}, y4 = {y4}')\n\n\tw0, b0 = white(1, 1, m, n), black(1, 1, m, n)\n\t# print(f'w0 = {w0}, b0 = {b0}')\n\n\t_b0 = black(x1, y1, x2, y2)\n\t# print(f'_b0 = {_b0}')\n\tw1, b1 = w0 + _b0, b0 - _b0\n\n\t_w1 = white(x3, y3, x4, y4)\n\t# print(f'_w1 = {_w1}')\n\tw2, b2 = w1 - _w1, b1 + _w1\n\n\txl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)\n\t# print(f'xl = {xl}, yl = {yl}, xr = {xr}, yr = {yr}')\n\t_b2 = black(xl, yl, xr, yr)\n\t# print(f'_b2 = {_b2}')\n\tw3, b3 = w2 - _b2, b2 + _b2\n\n\tprint(w3, b3)\n", "t = int(input())\n\ndef getcol(x1, y1, x2, y2):\n    dx = max((x2-x1+1), 0)\n    dy = max((y2-y1+1), 0)\n    b = w = dx*dy//2\n    if dx % 2 and dy % 2:\n        if (x1+y1) % 2:\n            b = b + 1\n        else:\n            w = w + 1\n    return w, b\n\nfor _ in range(t):\n    n, m = list(map(int, input().split()))\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    x3, y3, x4, y4 = list(map(int, input().split()))\n    w, b = getcol(1,1,n,m)\n    w1, b1 = getcol(x1,y1,x2,y2)\n    w2, b2 = getcol(x3,y3,x4,y4)\n    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))\n    woff = w-w1-w2+w3\n    boff = b-b1-b2+b3\n    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)\n", "def area(rect):\n    if rect is None:\n        return 0\n    x1, y1, x2, y2 = rect\n    return (x2-x1+1) * (y2-y1+1)\n\n\ndef get_w(rect):\n    if rect is None:\n        return 0#, 0\n\n    x1, y1, x2, y2 = rect\n\n    ra = area(rect)\n    more, less = (ra + 1) // 2, ra // 2\n\n    if (x1 + y1) % 2 == 0:\n        return more #, less\n    else:\n        return less #, more\n\n\ndef intersect_rects(r1, r2):\n    out = []\n    for i, a, b in zip(list(range(4)), r1, r2):\n        out.append(max(a,b) if i < 2 else min(a,b))\n\n    if out[0] > out[2] or out[1] > out[3]:\n        return None\n    return out\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    rect1 = list(map(int, input().split()))\n    rect2 = list(map(int, input().split()))\n    rect12 = intersect_rects(rect1, rect2)\n\n    w_start = get_w([1,1,n,m])\n    w1 = get_w(rect1)\n    w2 = get_w(rect2)\n    w12 = get_w(rect12)\n\n    w = w_start - w1 - w2 + w12 + area(rect1) - area(rect12)\n    print(w, n*m-w)\n\n\nq = int(input())\nfor i in range(q):\n    main()\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nT, = getIntList()\n#print(N)\ndef isin( x,y, M):\n    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:\n        return True\n    return False\n\nfor _ in range(T):\n    N, M = getIntList()\n    m1 = getIntList()\n    m2 = getIntList()\n    zx = [0, M]\n    zx += [m1[0]-1, m1[2]]\n    zx += [m2[0]-1, m2[2]]\n    zx.sort()\n    zy = [0, N]\n    zy += [m1[1]-1, m1[3]]\n    zy += [m2[1]-1, m2[3]]\n    zy.sort()\n    totB = 0\n    for i0 in range(5):\n        if zx[i0] == zx[i0+1]: continue\n        for i1 in range(5):\n            if zy[i1] == zy[i1+1]: continue\n            \n            x0 = zx[i0]+1\n            y0 = zy[i1]+1\n            dprint('x0,y0', x0,y0)\n            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1]) \n            if isin(x0,y0, m2):\n                dprint('black')\n                totB += size\n            elif isin(x0,y0, m1):\n                dprint('white')\n                pass\n            else:\n                totB+= size//2\n                if size%2==1:\n                    if (x0+y0)%2==1:\n                        dprint('extra black')\n                        totB+=1\n    print(N*M - totB, totB)\n                    \n\n", "def num_sq(x,y,x2,y2):\n    # b, w\n    a = (abs(x2-x)+1)\n    b = (abs(y2-y)+1)\n    if a % 2 == 0 or b % 2 == 0:\n        return (a*b // 2, a*b // 2)\n    if (x+y) % 2 == 0:\n        num_b = a * b // 2\n        return (num_b, a * b - num_b)\n    num_w = a * b // 2\n    return (a * b - num_w, num_w)\ndef pt_in(p1, r1, r2):\n    return r1[0] <= p1[0] <= r2[0] and r1[1] <= p1[1] <= r2[1]\ndef intc(p1, p2, p3, p4):\n    x1 = max(p1[0], p3[0])\n    x2 = min(p2[0], p4[0])\n    y1 = max(p1[1], p3[1])\n    y2 = min(p2[1], p4[1])\n    if x1 <= x2 and y1 <= y2:\n        return ((x1, y1), (x2, y2))\n    return None\n\nnum_ = int(input())\nfor _ in range(num_):\n    n, m = list(map(int, input().split()))\n    x1,y1,x2,y2 = list(map(int,input().split()))\n    x3,y3,x4,y4 = list(map(int,input().split()))\n    p1 = (x1,y1)\n    p2 = (x2,y2)\n    p3 = (x3,y3)\n    p4 = (x4,y4)\n    all_b, all_w = num_sq(1, 1, n, m)\n    tmp = intc(p1, p2, p3, p4)\n    if tmp:\n        intc_1, intc_2 = tmp\n        t_b, t_w = num_sq(intc_1[0], intc_1[1], intc_2[0], intc_2[1])\n    b,w = num_sq(x1,y1,x2,y2)\n    if tmp:\n        b -= t_b\n        w -= t_w\n    b2,w2 = num_sq(x3,y3,x4,y4)\n    if tmp:\n        b2 -= t_b\n        w2 -= t_w\n    w_tot, b_tot = (all_w + b - w2, all_b - b + w2)\n    if tmp:\n        w_tot -= t_w\n        b_tot += t_w\n    print(w_tot, b_tot)\n\n", "def get_colors(x1, y1, x2, y2):\n    w = x2 - x1 + 1\n    h = y2 - y1 + 1\n    if w % 2 == 0 or h % 2 == 0:\n        black = w * h // 2\n        white = w * h // 2\n    else:\n        oddx = w // 2\n        if x1 % 2 == 1 and x2 % 2 == 1:\n            oddx += 1\n        oddy = h // 2\n        if y1 % 2 == 1 and y2 % 2 == 1:\n            oddy += 1\n        evenx = w // 2\n        if x1 % 2 == 0 and x2 % 2 == 0:\n            evenx += 1\n        eveny = h // 2\n        if y1 % 2 == 0 and y2 % 2 == 0:\n            eveny += 1\n        white = oddx * oddy + evenx * eveny\n        black = w * h - white\n    return white, black\n\ndef get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    if ax1 > bx2:\n        return None, None, None, None\n    if bx1 > ax2:\n        return None, None, None, None\n    if ay1 > by2:\n        return None, None, None, None\n    if by1 > ay2:\n        return None, None, None, None\n    return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2)\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    white, black = get_colors(1, 1, m, n)\n    wx1, wy1, wx2, wy2 = map(int, input().split())\n    w, b = get_colors(wx1, wy1, wx2, wy2)\n    white += b\n    black -= b\n    bx1, by1, bx2, by2 = map(int, input().split())\n    ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2)\n    if ix1 is not None:\n        w, b = get_colors(ix1, iy1, ix2, iy2)\n        white -= b\n        black += b\n    w, b = get_colors(bx1, by1, bx2, by2)\n    white -= w\n    black += w\n    print(white, black)", "t = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n    count_w = n * m // 2 + n * m % 2\n    count_g = n * m // 2\n    if (x1 + y1) % 2 == 0:\n        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2\n    else:\n        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2\n        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2\n    x5 = max(x1, x3)\n    x6 = min(x4, x2)\n    y5 = max(y1, y3)\n    y6 = min(y4, y2)\n    if (x3 + y3) % 2 == 1:\n        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2\n        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2\n    else:\n        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2\n        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2\n    if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6:\n        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2\n        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2\n    elif x5 <= x6 and y5 <= y6:\n        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2\n        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2\n    print(count_w, count_g)", "def getBW(x1, y1, x2, y2):\n    if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1:\n        return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2] \n    else:\n        if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1):\n            return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2]\n        else:\n            return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]\n\ncs = int(input())\n\n\n\nfor c in range(cs):\n    m, n = map(int, input().split())\n    BW = getBW(1, 1, n, m)\n    x1, y1, x2, y2 = map(int, input().split())\n    \n    x3, y3, x4, y4 = map(int, input().split())\n    \n    BW1 = getBW(x1, y1, x2, y2)\n    BW2 = getBW(x3, y3, x4, y4)\n    BWO =[0, 0]\n    #if x1 > x3: (x1, y1, x2, y2), (x3, y3, x4, y4) = (x3, y3, x4, y4), (x1, y1, x2, y2)\n    #xO1, xO2 = x1, min(x2, x4)\n    xo1 = max(x1, x3)\n    xo2 = min(x2, x4)\n    yo1 = max(y1, y3)\n    yo2 = min(y2, y4)\n    if (xo2 >= xo1 and yo2 >= yo1):\n        BWO = getBW(xo1, yo1, xo2, yo2)\n        '''\n    print(BW1)\n    print(BW2)\n    print(BWO)\n    print(BW)'''\n    B = BW[0] - BW1[0] + BW2[1] + BWO[0]\n    W = BW[1] + BW1[0] - BW2[1] - BWO[0]\n    \n    print(W, end = \" \")\n    print(B)", "from collections import defaultdict\n# from fractions import Fraction\ndef read_line():\n    return [int(x) for x in input().split()]\n\n\ndef solve2(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4):\n    def inside(x, y):\n        return 1 <= x <= m and 1 <= y <= n\n\n    def col(a, b):\n        assert inside(a, b)\n        return 'WB'[(a+b)%2]\n\n    d = {}\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            d[(i, j)] = col(i, j)\n    for i in range(x1, x2+1):\n        for j in range(y1, y2+1):\n            d[(i, j)] = 'W'\n    for i in range(x3, x4+1):\n        for j in range(y3, y4+1):\n            d[(i, j)] = 'B'\n    return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B'])\n\ndef rnd_test():\n    from random import randint\n    n = randint(1, 50)\n    m = randint(1, 50)\n    x1, x2, x3, x4 = [randint(1, m) for _ in range(4)]\n    y1, y2, y3, y4 = [randint(1, n) for _ in range(4)]\n    x1, x2 = min(x1, x2), max(x1, x2)\n    y1, y2 = min(y1, y2), max(y1, y2)\n    x3, x4 = min(x3, x4), max(x3, x4)\n    y3, y4 = min(y3, y4), max(y3, y4)\n    assert solve(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4)\n\n\n            \ndef solve(n, m, x1, y1, x2, y2,\n                x3, y3, x4, y4):\n\n    def inside(x, y):\n        return 1 <= x <= m and 1 <= y <= n\n\n    def col(a, b):\n        assert inside(a, b)\n        return 'WB'[(a+b)%2]\n\n    def cols(x1, y1, x2, y2):\n        assert inside(x1, y1) and inside(x2, y2)\n        assert x1 <= x2 and y1 <= y2\n        w, h = x2+1-x1, y2+1-y1\n        if w % 2 == 0 or h % 2 == 0:\n            return w*h // 2, w*h // 2\n        else:\n            WH, BL = w*h // 2, w*h // 2\n            if col(x1, y1) == 'W':\n                WH += 1\n            else: BL += 1\n            return WH, BL\n\n    def overlap():\n        X1 = max(x1, x3)\n        X2 = min(x2, x4)\n        Y1 = max(y1, y3)\n        Y2 = min(y2, y4)\n        if X1 > X2 or Y1 > Y2: return None\n        return X1, Y1, X2, Y2\n\n    tot_wh, tot_bl = cols(1, 1, m, n)\n    # print(\"Starting cols: {} wh, {} bl\".format(tot_wh, tot_bl))\n    A_wh, A_bl = cols(x1, y1, x2, y2)\n    ovrlp = overlap()\n    if ovrlp is not None:\n        O_wh, O_bl = cols(*ovrlp)\n        assert A_wh >= O_wh and A_bl >= O_bl\n        A_wh -= O_wh\n        A_bl -= O_bl\n        #print(\"Overlap cols: {} wh, {} bl\".format(O_wh, O_bl))\n    # print(\"White rect cols: {} wh, {} bl\".format(A_wh, A_bl))\n    B_wh, B_bl = cols(x3, y3, x4, y4)\n    #print(\"Black rect cols: {} wh, {} bl\".format(B_wh, B_bl))\n\n    # Paint A white:\n    tot_wh += A_bl\n    tot_bl -= A_bl\n\n    # Paint B black:\n    tot_wh -= B_wh\n    tot_bl += B_wh\n    return(tot_wh, tot_bl)\n\n# for _ in range(2000):\n#     rnd_test()\n# print(\"tested\")\nt = int(input())\n\nfor _ in range(t):\n    n, m = read_line()\n    x1, y1, x2, y2 = read_line()\n    x3, y3, x4, y4 = read_line()\n    print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4))\n", "def wb(n,m,flip=False):\n    w = b = n*m // 2\n    if n%2 == 1 and m %2 == 1:\n        w += 1\n    if flip:\n        return b,w\n    else:\n        return w,b\n\nt = int(input())\nfor tt in range(t):\n    n,m = map(int, input().split())\n    x1,y1,x2,y2 = map(int, input().split())\n    x3,y3,x4,y4 = map(int, input().split())\n    x5 = max(x1,x3)\n    x6 = min(x2,x4)\n    y5 = max(y1,y3)\n    y6 = min(y2,y4)\n    ov = False\n    if x6-x5 >= 0 and y6-y5 >= 0:\n        ov = True\n    w,b = wb(n,m)\n    wm,bm = wb(x2-x1+1, y2-y1+1, (x1+y1)%2==1)\n    wd,bd = wb(x4-x3+1, y4-y3+1, (x3+y3)%2==1)\n    if ov:\n        wo,bo = wb(x6-x5+1, y6-y5+1, (x5+y5)%2==1)\n    else:\n        wo,bo = 0,0\n    # print('w, b', w, b)\n    # print('wm, bm', wm, bm)\n    # print('wd, bd', wd, bd)\n    # print('wo, bo', wo, bo)\n    w = w+bm-wd-bo\n    b = b-bm+wd+bo\n    print(w,b)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\ndef getWhiteBlack(l1,r1,l2,r2):\n    columns = (r2-r1+1)*(l2-l1+1)\n    if columns%2==0:\n        return columns//2,columns//2\n    if (l1+r1)%2!=0:\n        return columns//2, int((columns//2)+1)  \n    else: return int((columns//2) + 1), columns//2\n            \n\ndef main():\n    n,m= get_tuple()\n    wl1,wr1,wl2,wr2 = get_tuple()\n    bl1,br1,bl2,br2 = get_tuple()\n    #print(getWhiteBlack(1,1,m,n))\n    whites, blacks = getWhiteBlack(1,1,m,n)\n    fw,fb = getWhiteBlack(wl1,wr1,wl2,wr2)\n    #print(getWhiteBlack(wl1,wr1,wl2,wr2))\n    sw,sb = getWhiteBlack(bl1,br1,bl2,br2)\n    #print(getWhiteBlack(bl1,br1,bl2,br2))\n    il1 = max(wl1,bl1)\n    ir1 = max(wr1,br1)\n    il2 = min(wl2,bl2)\n    ir2 = min(wr2,br2)\n    whites+=fb-sw\n    blacks+=sw-fb\n    #print(whites,blacks)\n    if il1<=il2 and ir1<=ir2:\n        # Intersectoi\n        #print(getWhiteBlack(il1,ir1,il2,ir2))\n        iw,ib = getWhiteBlack(il1,ir1,il2,ir2)\n        \n        whites-= ib\n        blacks+= ib\n    print(whites,blacks)\n        \n\n\n        \n            \n\n\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/11/24 15:29\n\n\"\"\"\n\nT = int(input())\n\n\ndef interact(rect1, rect2):\n    x1, y1, x2, y2 = rect1\n    x3, y3, x4, y4 = rect2\n\n    ans = (-1, -1, -1, -1)\n    if x2 < x3 or x4 < x1:\n        return 0, ans\n    if y2 < y3 or y4 < y1:\n        return 0, ans\n\n    ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))\n\n    return area(ans), ans\n\n\ndef area(rect):\n    return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n\n\ndef winrect(rect):\n    a = area(rect)\n    if a % 2 == 0:\n        return a // 2\n\n    x1, y1, x2, y2 = rect\n    e1, e2 = x1 % 2 == 0, y1 % 2 == 0\n    ow = (e1 and e2) or (not e1 and not e2)\n    return a // 2 + 1 if ow else a // 2\n\nans = []\nfor ti in range(T):\n    N, M = map(int, input().split())\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = map(int, input().split())\n\n    w = winrect((1, 1, N, M))\n    a, b = (x1, y1, x2, y2), (x3, y3, x4, y4)\n    s, c = interact(a, b)\n    if s == 0:\n        w -= winrect(a) + winrect(b)\n        w += area(a)\n    elif s == area(a):\n        w -= winrect(b)\n    elif s == area(b):\n        w -= winrect(b)\n        w += area(a) - area(b) - (winrect(a) - winrect(b))\n    else:\n        w += area(a) - winrect(a)\n        w -= winrect(b)\n        w -= area(c) - winrect(c)\n\n    ans.append((w, N*M-w))\n\nprint('\\n'.join(['{} {}'.format(a, b) for a, b in ans]))", "def black_count(x, y):\n\ttotal = x * y\n\treturn total // 2\n\n\ndef black_count2(a, b, c, d):\n\treturn black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)\n\ndef white_count2(a, b, c, d):\n\ttotal = (c - a + 1) * (d - b + 1)\n\treturn total - black_count2(a, b, c, d)\n\n\ndef intersection(a, b, c, d, x, y):\n\tif x < a or y < b:\n\t\treturn None\n\tx = min(x, c)\n\ty = min(y, d)\n\treturn (a, b, x, y)\n\ndef intersection2(a1, b1, c1, d1, a2, b2, c2, d2):\n\tif b1 > d2 or a1 > c2:\n\t\treturn None\n\tif b2 > d1 or a2 > c1:\n\t\treturn None\n\n\ta = max(a1, a2)\n\tb = max(b1, b2)\n\tc = min(c1, c2)\n\td = min(d1, d2)\n\treturn (a, b, c, d)\n\n\ndef solve(n, m, W, B):\n\ttotal = n * m\n\twhites = total - black_count(n, m)\n\twhites += black_count2(*W)\n\twhites -= white_count2(*B)\n\tI = intersection2(*W, *B)\n\tif I:\n\t\twhites -= black_count2(*I)\n\tblacks = n * m - whites\n\treturn whites, blacks\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn, m = list(map(int, input().split()))\n\t\tW = list(int(i) for i in input().split())\n\t\tB = list(int(i) for i in input().split())\n\t\tw, b = solve(n, m, W, B)\n\t\tprint(w, b)\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "def mi():\n\treturn list(map(int, input().split()))\n\nfor _ in range(int(input())):\n\tr,c = mi()\n\ty1,x1,y2,x2 = mi()\n\ty3,x3,y4,x4 = mi()\n\t#(col,row)\n\tts = r*c\n\tif ts%2:\n\t\ti_w = (ts+1)//2\n\telse:\n\t\ti_w = ts//2\n\ti_b = ts-i_w\n\tts1 = (x2-x1+1)*(y2-y1+1)\n\tts2 = (x4-x3+1)*(y4-y3+1)\n\tif (x1+y1)%2==0:\n\t\ttemp1 = (ts1+1)//2\n\t\tr1_b = ts1-temp1\n\telse:\n\t\tr1_b = ts1-ts1//2\n\tif (x3+y3)%2==0:\n\t\ttemp2 = (ts2+1)//2\n\t\tr2_w = temp2\n\telse:\n\t\tr2_w = ts2//2\n\tx5 = max(x1, x3)\n\ty5 = max(y1, y3)\n\tx6 = min(x2, x4)\n\ty6 = min(y2, y4)\n\tif x5>x6 or y5>y6:\n\t\ti_b-=r1_b\n\t\ti_w+=r1_b\n\t\ti_w-=r2_w\n\t\ti_b+=r2_w\n\t\tprint(i_w, i_b)\n\t\tcontinue\n\tx7 = x5\n\ty7 = y6\n\tx8 = x6\n\ty8 = y5\n\ty7,y8=y8,y7\n\tts3 = (abs(x7-x8)+1)*(abs(y7-y8)+1)\n\tif (x7+y7)%2==0:\n\t\ttemp3 = (ts3+1)//2\n\telse:\n\t\ttemp3 = ts3//2\n\tc_b = ts3-temp3\n\ti_b-=r1_b\n\ti_w+=r1_b\n\t#print (\"LOL\", i_w, i_b)\n\ti_w-=r2_w\n\ti_b+=r2_w\n\t#print (\"LOL\", i_w, i_b)\n\ti_b+=c_b\n\ti_w-=c_b\n\tprint(i_w, i_b)\n'''\n5\n2 2\n1 1 2 2\n1 1 2 2\n3 4\n2 2 3 2\n3 1 4 3\n1 5\n1 1 5 1\n3 1 5 1\n4 4\n1 1 4 2\n1 3 4 4\n3 4\n1 2 4 2\n2 1 3 3\n'''\n", "import sys\ninput = sys.stdin.readline\n\ntestcase=int(input())\nT=[list(map(int,input().split())) for i in range(testcase*3)]\n#n,m=map(int,input().split())\n#WHITE=list(map(int,input().split()))\n#BLACK=list(map(int,input().split()))\n\ndef COMMON(WHITE,BLACK):\n    x1,y1,x2,y2=WHITE\n    x3,y3,x4,y4=BLACK\n    return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))\n\ndef BtoW(WHITE):\n    x1,y1,x2,y2=WHITE\n    if (x1+y1)%2==0:\n        return (x2-x1+1)*(y2-y1+1)//2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2\n        \ndef WtoB(BLACK):\n    x1,y1,x2,y2=BLACK\n    if (x1+y1)%2==1:\n        return (x2-x1+1)*(y2-y1+1)//2\n    else:\n        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2\n        \nfor test in range(testcase):\n    n,m=T[test*3]\n    WHITE=T[test*3+1]\n    BLACK=T[test*3+2]\n\n    ANSB=n*m//2\n    ANSW=n*m-ANSB\n\n    #print(ANSB,ANSW,end=\"!\")\n\n    WHITE2=COMMON(WHITE,BLACK)\n\n    k=BtoW(WHITE)\n    ANSB-=k\n    ANSW+=k\n\n    #print(ANSB,ANSW,end=\"!\")\n    \n    #print(x5,y5,x6,y6)\n    if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]:#\u5171\u901a\u90e8\u306a\u3057\n        True\n    else:\n        l=BtoW(WHITE2)\n        ANSB+=l\n        ANSW-=l\n\n    #print(ANSB,ANSW,end=\"!\")\n\n    m=WtoB(BLACK)\n\n    ANSB+=m\n    ANSW-=m\n\n    print(ANSW,ANSB)\n\n    \n        \n    \n", "def whb(a,b,c,d):\n    dim = (c-a+1)*(d-b+1)\n    col1 = dim//2\n    col2 = dim-col1\n    if (a+b)%2==0:\n        return [col2, col1]\n    else:\n        return [col1, col2]\n\ndef insegment(a, b, a1, b1):\n    li = [[a,1], [b,1], [a1,2], [b1,2]]\n    li.sort()\n    if li[0][1] == li[1][1]:\n        if li[1][0] == li[2][0]:\n            return [li[1][0], li[2][0]]\n        else:\n            return -1\n    else:\n        return [li[1][0], li[2][0]]\n\ndef inrect(a,b,c,d,a1,b1,c1,d1):\n    xra = insegment(a,c,a1,c1)\n    yra = insegment(b,d,b1,d1)\n    if xra==-1 or yra==-1:\n        return -1\n    else:\n        return [xra[0], yra[0], xra[1], yra[1]]\n\nq = int(input())\nfor quer in range(q):\n    [n, m] = [int(i) for i in input().split()]\n    [x1, y1, x2, y2] = [int(i) for i in input().split()]\n    [x3, y3, x4, y4] = [int(i) for i in input().split()]\n    [white, black] = whb(1,1,n,m)\n    [w1, b1] = whb(x1, y1, x2, y2)\n    [w2, b2] = whb(x3, y3, x4, y4)\n    black+= w2-b1\n    white+= b1-w2\n    inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4)\n    if type(inter)==list:\n        [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3])\n        black += b3\n        white -= b3\n    print(white, black)", "def fis(sq):\n    if sq[2] < sq[0] or sq[3] < sq[1]:\n        return [0, 0]\n    sc = (sq[0] + sq[1]) % 2\n    fc = (sq[2] + sq[3]) % 2\n    sxl = sq[2] - sq[0] + 1\n    syl = sq[3] - sq[1] + 1\n    hf = (sxl * syl) // 2\n    cp = -1\n    if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1:\n        cp = sc\n    return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)])\n\nt = int(input())\nfor i in range(t):\n    n, m = [int(x) for x in input().split()]\n    wco = [int(x) for x in input().split()]\n    bco = [int(x) for x in input().split()]\n    wf, bf = fis([1, 1, m, n])\n    btw = fis(wco)[1]\n    wtb = fis(bco)[0]\n    bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])]\n    bna = fis(bnac)[1]\n    print(wf+btw-wtb-bna, bf+wtb-btw+bna)\n", "def solve(n, m, white, black):\n\tw, b = tiles(1, 1, m, n)\n\t_, b2w = tiles(*white)\n\tw2b, _ = tiles(*black)\n\n\tw += b2w\n\tb -= b2w\n\tw -= w2b\n\tb += w2b\n\n\tx1, y1 , x2, y2 = max(white[0], black[0]), max(white[1], black[1]), min(white[2], black[2]), min(white[3], black[3])\n\n\tif (x1 <= x2 and y1 <= y2):\n\t\t_, b2 = tiles(x1, y1, x2, y2)\n\t\tw -= b2\n\t\tb += b2 \n\n\treturn w, b\n\ndef tiles(x1, y1, x2, y2):\n\tn = y2 - y1 + 1\n\tm = x2 - x1 + 1\n\tblack = (x1 + y1) % 2\n\tw = (n//2) * m  + (m+(not black))//2 * (n%2)\n\tb = (n//2) * m  + (m+(black))//2 * (n%2)\n\treturn w, b\n\ndef read(): return list(map(int, input().split()))\n\nq = int(input())\nfor _ in range(q):\n\tprint(*solve(*read(), read(), read()), sep=' ')\n", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nimport sys\nimport math\nMAX = sys.maxsize\nMAXN = 10**6+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(list(map(int,sys.stdin.readline().strip().split())))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\n\ndef solve(x1,y1,x2,y2):\n\txa = x2-x1+1\n\tya = y2-y1+1\n\n\tarea = xa*ya\n\n\tif(x1+y1)%2==0:\n\t\tif area%2:\n\t\t\ttw = area//2+1\n\t\telse:\n\t\t\ttw = area//2\n\telse:\n\t\ttw = area//2\n\n\treturn area-tw,tw\n\nfor _ in range(int(input())):\n\tn,m = numIN()\n\tblack = (n*m)//2\n\twhite = (n*m)-black\n\tx1,y1,x2,y2 = numIN()\n\tx3,y3,x4,y4 = numIN()\n\t#print('#1',white,black)\n\tb1,w1 = solve(x1,y1,x2,y2)\n\tblack-=b1\n\twhite+=b1\n\t#print('#2',white,black)\n\tb2,w2 = solve(x3,y3,x4,y4)\n\tblack+=w2\n\twhite-=w2\n\t#print('#3',white,black)\n\tx5 = max(x1,x3)\n\ty5 = max(y1,y3)\n\tx6 = min(x2,x4)\n\ty6 = min(y2,y4)\n\t#print(x5,y5,x6,y6)\n\tar = (x6-x5+1)*(y6-y5+1)\n\tb3,w3 = solve(x5,y5,x6,y6)\n\t#print('abc',b3,w3)\n\tif x5<=x6 and y5<=y6:\n\t\tblack+=b3\n\t\twhite-=b3\n\tprint(white,black)\n\n\n\n\n\n", "tc_count = int(input())\n\nans = []\n\nfor i in range(tc_count):\n  size = list(map(int, input().split()))\n  w = size[1]\n  h = size[0]\n  white = list(map(int, input().split()))\n  black = list(map(int, input().split()))\n  black_count = (w * h) // 2\n  white_count = (w * h) - black_count\n\n  white_area = (white[3] - white[1] + 1) * (white[2] - white[0] + 1)\n  if (white[0] + white[1]) % 2 == 0:\n    become_white = (white_area // 2)\n  else:\n    become_white = white_area - (white_area // 2)\n  black_count = black_count - become_white\n  white_count = white_count + become_white\n\n  black_area = (black[3] - black[1] + 1) * (black[2] - black[0] + 1)\n  if (black[0] + black[1]) % 2 == 0:\n    become_black = black_area - (black_area // 2)\n  else:\n    become_black = black_area // 2\n  white_count = white_count - become_black\n  black_count = black_count + become_black\n\n  left_x = max(black[0], white[0])\n  left_y = max(black[1], white[1])\n  right_x = min(black[2], white[2])\n  right_y = min(black[3], white[3])\n  orig_b = 0\n  if left_x <= right_x and left_y <= right_y:\n    rect_count = (right_x - left_x + 1) * (right_y - left_y + 1)\n    orig_b = rect_count // 2 if (left_x + left_y) % 2 == 0 else rect_count - (rect_count // 2)\n  white_count = white_count - orig_b\n  black_count = black_count + orig_b\n  ans.append(str(white_count)+ \" \" + str(black_count))\n\nfor an in ans:\n  print(an)\n", "import math\n\ndef duh0(x1,x2,x3,x4, y1,y2,y3,y4, midonly=False):\n    W = B = 0\n    if (x3 <= x2) and (x1 <= x4):\n        # print(1)\n        w,b = duh1(max(x1,x3), min(x2,x4),\n            y1,y2,y3,y4, midonly)\n        W += w\n        B += b\n    if midonly:\n        return (W,B)\n\n    if (x1 < x3):\n        # print(3)\n        w,b = duh1(x1, min(x2,x3-1),\n            y1,y2,y3,y4)\n        W += w\n        B += b\n    if (x4 < x2):\n        # print(7)\n        w,b = duh1(max(x1,x4+1), x2,\n            y1,y2,y3,y4)\n        W += w\n        B += b\n    return (W,B)\n\n\ndef duh1(xa, xb, y1, y2, y3, y4, midonly=False):\n    W = B = 0\n    if (y3 <= y2) and (y1 <= y4):\n        # print(\"  \", 1, y1, y2, y3, y4)\n        w,b = cnt(xa, xb, max(y1, y3), min(y2, y4))\n        W += w\n        B += b\n    if midonly:\n        return (W,B)\n\n    if (y1 < y3):\n        # print(\"  \", 4)\n        w,b = cnt(xa, xb, y1, min(y2, y3-1))\n        W += w\n        B += b\n    if (y4 < y2):\n        # print(\"  \", 8)\n        w,b = cnt(xa, xb, max(y1, y4+1), y2)\n        W += w\n        B += b\n    return (W,B)\n\n\ndef cnt(xa, xb, ya, yb):\n    m = xb - xa + 1\n    n = yb - ya + 1\n    W = m*n\n    B = W//2\n    W -= B\n    return (B,W) if (xa+ya)&1 else (W,B)\n\ndef solve(n, m,\n            x1, y1, x2, y2,\n            x3, y3, x4, y4):\n    st = cnt(1, m, 1, n)\n\n    whi = duh0(x1,x2,x3,x4, y1,y2,y3,y4)\n    its = duh0(x1,x2,x3,x4, y1,y2,y3,y4, midonly=True)\n    bla = cnt(x3, x4, y3, y4)\n\n    W = st[0] + whi[1] - its[1] - bla[0]\n    B = st[1] - whi[1] + its[1] + bla[0]\n\n    # print(st, whi, its, bla, sep=\"  \")\n\n    print(W,B)\n\n\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    t = next(ipt)\n    while t:\n        t -= 1\n        n = next(ipt)\n        m = next(ipt)\n        x1 = next(ipt)\n        y1 = next(ipt)\n        x2 = next(ipt)\n        y2 = next(ipt)\n        x3 = next(ipt)\n        y3 = next(ipt)\n        x4 = next(ipt)\n        y4 = next(ipt)\n        solve(n, m,\n            x1, y1, x2, y2,\n            x3, y3, x4, y4)\n\n__starting_point()"]
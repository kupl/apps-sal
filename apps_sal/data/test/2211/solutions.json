["\ndef count(p, s):\n    start = 0\n    c = 0\n    while True:\n        try:\n            pos = s.index(p, start)\n            c += 1\n            start = pos + 1\n        except ValueError:\n            return c\n\ns = input()\nn = int(input())\n\npravs = []\nfor i in range(n):\n    p, l, r = input().split()\n    l = int(l); r = int(r)\n    pravs.append((p, l, r))\n\nvar = set()\nfor l in range(len(s)):\n    for r in range(l+1, len(s)+1):\n        pods = s[l:r]\n        for prav in pravs:\n            if not prav[1] <= count(pods, prav[0]) <= prav[2]:\n                break\n        else:\n            var.add(pods)\n\nprint(len(var))\n", "from sys import stdin\nimport re\n\ndef substrings(s):\n    for i in range(0, len(s)):\n        for l in range(i, len(s)):\n            yield s[i:l+1]\n\n\ntest = stdin.readline().rstrip('\\n')\nruleCount = int(stdin.readline())\n\nrules = []\n\nfor i in range(0, ruleCount):\n    ruleStr = stdin.readline()\n    sp = ruleStr.split(' ')\n\n    m = {}\n    for s in substrings(sp[0]):\n        m[s] = m.get(s, 0) + 1\n    \n\n    rules.append((sp[0], int(sp[1]), int(sp[2]), m))\n\n\n\ndef works(x):\n    for rule in rules:\n        if not rule[1] <= rule[3].get(x, 0) <= rule[2]:\n            return False\n\n    return True\n\nprint(len([x for x in set(substrings(test)) if works(x)]))\n"]
["# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\nfrom collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\nA = sorted(A, reverse=True)\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n\nqueue_A = deque(A)\nqueue_B = deque()\n\nfor i in range(M):\n    if len(queue_B) > 0 and queue_B[0] >= queue_A[0]:\n        queue_A.appendleft(queue_B.popleft())\n    queue_A[0] //= 2\n    if len(queue_A) > 1 and queue_A[0] < queue_A[1]:\n        queue_B.append(queue_A.popleft())\n\nprint(sum(queue_A) + sum(queue_B))", "from heapq import heapify, heappush, heappop\n\nn, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA = list([x * (-1) for x in A])\n\nheapify(A)\nfor i in range(m):\n    x = heappop(A)\n    x = (x + 1) // 2\n    heappush(A, x)\n\nprint((-1 * sum(A)))\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 17:42:18 2020\n\n@author: liang\n\"\"\"\n\"\"\"\n\u3010\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u3011\n\u30fb\u30d2\u30fc\u30d7\u69cb\u9020\u306e\u90e8\u5206\u9806\u5e8f\u4ed8\u304d\u6728\n\u30fb\u633f\u5165\u3001\u524a\u9664\u3001\u6700\u5927\u5024\uff08\u6700\u5c0f\u5024\uff09\u306e\u53d6\u308a\u51fa\u3057\u3001\u8981\u7d20\u306e\u5024\u306e\u5909\u66f4\n\u3000\u21d2\u3000O(log n)\n\u30fb\u30d2\u30fc\u30d7\u751f\u6210\n\u3000\u21d2O(n)\n \u3010\u4f7f\u3044\u65b9\u3011\n  import heapq\n  \u25cfheapq.heapify(list) #\u6700\u5c0f\u5024\n  \u25cfheapq.heapify(list(map(lambda x:int(x)*(-1),list))) #\u6700\u5927\u5024\u306f\u5024\u3092\u3072\u3063\u304f\u308a\u8fd4\u3059\n  \u25cfheapq.heappop(a)\n  \u25cfheapq.heappush(a,1)\n\"\"\"\n\nimport heapq\nN, M = map(int, input().split())\n# -1\u500d\u3059\u308b\nA = [int(x)*(-1) for x in input().split()]\nheapq.heapify(A)\n\n#O(M) * O(log N)\nfor i in range(M):\n    Max = heapq.heappop(A) * (-1)\n    Max //= 2\n    heapq.heappush(A, Max*(-1))\nprint(-sum(A))", "import heapq\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = list([x*(-1) for x in A])\nheapq.heapify(A)\nfor _ in range(M):\n    heapq.heappush(A, -1 * (heapq.heappop(A) *(-1) // 2))\nprint((sum(A)*(-1)))\n", "import heapq\n\nN, M = map(int, input().split())\nA_list = list(map(int, input().split()))\n\nA_list_minus = list(map(lambda x: x*(-1), A_list))  # \u5404\u8981\u7d20\u3092-1\u500d\nheapq.heapify(A_list_minus)\n\nfor i in range(M):\n    tmp_max = heapq.heappop(A_list_minus)*(-1)\n    heapq.heappush(A_list_minus, (-1)*(tmp_max//2)) #\u633f\u5165\u3059\u308b\u3068\u304d\u306f\u6700\u5c0f\u306b\n\nprint(-1*sum(A_list_minus))", "import heapq\nn,m=map(int,input().split())\na=list(map(lambda x:-int(x),input().split()))\nheapq.heapify(a)\nfor i in range(m):\n  heapq.heapreplace(a,a[0]/2)\n\nprint(-sum(map(int,a)))", "import heapq\nN,M=list(map(int,input().split()))\nA=list([int(x)*(-1) for x in input().split()])\n\nheapq.heapify(A)\n\nfor _ in range(M):\n    tmp=heapq.heappop(A)\n    tmp=-tmp//2\n    heapq.heappush(A,-tmp)\n\nprint((-sum(A)))\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nimport heapq\n\nN, M = list(map(int,input().split()))\nA = list([int(x) * (-1) for x in input().split()])\nheapq.heapify(A)\n\nfor i in range(M):\n    a = heapq.heappop(A)\n    a *= -1\n    a //= 2\n    a *= -1    \n    heapq.heappush(A,a)\n\nprint((-sum(A)))\n", "import heapq\nN,M=map(int,input().split())\nA=list(map(lambda x:int(x)*(-1),input().split()))\n\nheapq.heapify(A)\n\nfor _ in range(M):\n    tmp=heapq.heappop(A)\n    tmp=-tmp//2\n    heapq.heappush(A,-tmp)\n\nprint(-sum(A))", "import heapq, math\n\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\na = list(map(lambda x: x*(-1), A))\nheapq.heapify(a)\nfor i in range(m):\n    max_a = heapq.heappop(a)\n    heapq.heappush(a, math.ceil(max_a/2))\nprint(-sum(a))", "\nimport heapq as he\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\na = list(map(lambda x: x*(-1),a))\nhe.heapify(a)\n\nfor i in range(m):\n    he.heappush(a,he.heappop(a)*(-1)//2*(-1))\n\nprint(sum(a)*(-1))", "from heapq import heappop, heappush, heapify\n\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\narr = [-x for x in arr]\n\nheapify(arr)\n\nfor _ in range(m):\n    a = heappop(arr)\n    heappush(arr, -(-a // 2))\n\nprint(-sum(arr))", "import heapq\nn,m = map(int,input().split())\na = list(map(lambda x: int(x)*(-1),input().split()))\nheapq.heapify(a) #a\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\u3059\u308b\nfor _ in range(m):\n    tmp = heapq.heappop(a)\n    heapq.heappush(a,(-1)*(-tmp//2))\nprint((-1)*sum(a))", "import math        # factorical\uff08\u968e\u4e57) # hypot(\u8ddd\u96e2)\nimport heapq\n# from fractions import gcd # Python3.5\u4ee5\u524d # lcm\uff08\u6700\u5c0f\u516c\u500d\u6570\uff09 = (a*b)//gcd(a,b)\n# from fractions import Fraction\n# from math import gcd # Python3.6\u4ee5\u964d\n# --------------------------------------------------------------\n\nn,m = map(int,input().split())\nprice = list(map(int,input().split()))\n\nprice = [-i for i in price]\n\nheapq.heapify(price)\n\nfor i in range(m):\n    sm = heapq.heappop(price)\n    sm = -(-sm//2)\n    heapq.heappush(price,sm)\n\nprice = [-i for i in price]\n\nprint(sum(price))", "import heapq\nn, m = map(int, input().split())\na = [i*-1 for i in list(map(int, input().split()))]\nheapq.heapify(a)\nfor i in range(m):\n    x = heapq.heappop(a)\n    heapq.heappush(a, ((-1*x)//2)*-1)\nprint(sum(a)*-1)", "import heapq\nclass Heapq:\n    def __init__(self, arr, desc=False):\n        if desc:\n            arr = [-a for a in arr]\n        self.sign = -1 if desc else 1\n        self.hq = arr\n        heapq.heapify(self.hq)\n \n    def pop(self):\n        return heapq.heappop(self.hq) * self.sign\n \n    def push(self, a):\n        heapq.heappush(self.hq, a * self.sign)\n \n    def top(self):\n        return self.hq[0] * self.sign\n        \nN,M=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nq = Heapq(A, True)\n    \nfor i in range(M):\n    x=q.pop()\n    q.push(x//2)\n\nprint((sum([q.pop() for _ in range(N)])))\n", "import heapq\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nfor i in range(n):\n    a[i] *= -1\n\nheapq.heapify(a)\n\nfor i in range(m):\n    ref = heapq.heappop(a)*-1\n    ref //= 2\n    heapq.heappush(a, -ref)\n\nprint(sum(a)*-1)", "import sys\ninput=sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306f\u3059\u308b\u306a\uff01\uff01\nimport heapq\nn,m=list(map(int,input().split()))\na=[]\nfor i in input().split():\n    heapq.heappush(a,-int(i))\nfor i in range(m):\n    p=-heapq.heappop(a)\n    p=p//2\n    heapq.heappush(a,-p)\nprint((-sum(a)))\n\n", "import heapq\nn, m = list(map(int, input().split()))\nA = sorted([-int(x) for x in input().split()])\nfor _ in range(m):\n    a = heapq.heappop(A)\n    a = -(-a//2)\n    heapq.heappush(A, a)\n\nprint((-sum(A)))\n", "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nimport heapq \n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\n\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n\n    N, M = NMI()\n    A = NLI()\n    \n    A = list(map(lambda x: x*(-1), A))\n    \n    heapq.heapify(A)\n    \n    for m in range(M):\n        highest = (heapq.heappop(A)*(-1))\n        discounted = math.floor(highest/2) * -1\n        heapq.heappush(A, discounted)\n\n        \n    print(sum(A)*-1)\n#\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nls = []\nfor item in A:\n  heapq.heappush(ls, -item)\nfor m in range(M):\n  tmp = -heapq.heappop(ls)\n  tmp = tmp // 2\n  heapq.heappush(ls, -tmp)\nprint((-sum(ls)))\n", "from heapq import *\n\nn, m = map(int, input().split())\nA = list(map(lambda x: int(x)*(-1), input().split()))\nheapify(A)\n\nfor _ in range(m):\n    max_a = heappop(A)*(-1)\n    max_a //= 2\n    heappush(A, -max_a)\nprint(-sum(A))", "import math\nimport heapq\n \nn,m = map(int,input().split())\na = list(map(lambda x: int(x)*-1,input().split()))\n \nheapq.heapify(a)\n# print(a)\nfor i in range(m):\n    heapq.heappush(a,math.ceil(heapq.heappop(a)/2))\n \nprint(int(-1 *sum(a)))", "import heapq\nN, M = list(map(int, input().split()))\nA = list([int(x)*(-1) for x in input().split()])\nheapq.heapify(A)\nfor i in range(0,M):\n    a=heapq.heappop(A)\n    heapq.heappush(A,(-1)*(-a//2))\nprint((-sum(A)))\n\n#\u3000\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u304c\u96e3\u3057\u3044\n", "import sys\nimport heapq\n\n\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\na_list = list(map(int, input().split()))\na_list = list([x*(-1) for x in a_list])\nheapq.heapify(a_list)\n\nwhile m > 0:\n    max_a = heapq.heappop(a_list)\n    heapq.heappush(a_list, (-1)*(-max_a//2))\n    m -= 1\n\nprint((-sum(a_list)))\n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\nfrom heapq import heapify, heappop, heappush\ndef Main():\n    n, m = read_ints()\n    a = read_int_list()\n    a = [-x for x in a]\n    heapify(a)\n    \n    while m:\n        cost = heappop(a)\n        if cost == 0:\n            break\n        heappush(a, -(-cost//2))\n        m -= 1\n    print(-sum(a))\n\ndef __starting_point():\n    Main()\n__starting_point()", "import heapq\n\ndef __starting_point():\n\n    n,m = map(int,input().split())\n    A = list(map(lambda x:int(x)*(-1),input().split()))\n    heapq.heapify(A)\n\n    for _ in range(m):\n        a = heapq.heappop(A) * (-1)\n        a = (a // 2) * (-1)\n        heapq.heappush(A,a)\n\n    print(sum(A)*(-1))\n__starting_point()", "import heapq\n\nn,m=list(map(int,input().split()))\na=[-int(x) for x in input().split()]\nheapq.heapify(a)\nfor i in range(m):\n  t=heapq.heappop(a)\n  t=-t//2\n  heapq.heappush(a,-t)\nprint((-sum(a)))\n", "from heapq import *\nN,M = map(int,input().split())\nA = list(map(lambda x:-int(x),input().split()))\nheapify(A)\n\nfor m in range(M):\n  heappush(A,int(heappop(A)/2))\n\nprint(-sum(A))", "n,m = map(int,input().split())\na = list(map(int,input().split()))\n\nimport heapq\na = list(map(lambda x:x*(-1),a))\nheapq.heapify(a)\n\nfor i in range(m):\n    b = heapq.heappop(a)\n    heapq.heappush(a,-(-b//2))\n    \nprint(sum(a)*(-1))", "N,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nimport heapq\na = list([x*(-1) for x in A])  # \u5404\u8981\u7d20\u3092-1\u500d\n\nheapq.heapify(a)\nfor i in range(K):\n  num = heapq.heappop(a)*(-1)\n  heapq.heappush(a, -1*(int(num/2)))\n  #print(num,a)\n  if num == 0:\n    break\nprint((-sum(a)))\n", "import heapq\nn,m=map(int,input().split())\na=list(map(int,input().split()))\n\na=[-i for i in a]\nheapq.heapify(a)\nfor _ in range(m):\n     b=heapq.heappop(a)\n     heapq.heappush(a,-((-b)//2))\n\nprint(-sum(a))", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# from collections import deque\nimport heapq\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = list(map(int, input().split()))\nA = list([int(x)*(-1) for x in input().split()])\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# A = sorted(A, reverse=True)\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\nheapq.heapify(A)\nfor i in range(M):\n    max_num = heapq.heappop(A) * (-1)\n    heapq.heappush(A, (-1) * (max_num // 2))\n\nA = [x*(-1) for x in A]\nprint((sum(A)))\n", "import heapq\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nif n == 1:\n    print(a[0] // (2 ** m))\n    return\na = list(map(lambda x: x * (-1), a))\nheapq.heapify(a)\nwhile m > 0:\n    m -= 1\n    i = heapq.heappop(a) * (-1)\n    i //= 2\n    heapq.heappush(a, i * (-1))\n\nprint(sum(a) * (-1))", "import heapq\nn, m = map(int, input().split())\na = list(map(int, input().split()))\na = list(map(lambda x: x*(-1), a))\nheapq.heapify(a)\n\nfor i in range(m):\n    tmp = heapq.heappop(a)\n    tmp /= 2\n    heapq.heappush(a, tmp)\n\nans = 0\nfor aa in a:\n    ans += aa//(-1)\nprint(int(ans))", "import heapq\n\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nA = [a*-1 for a in A]\n\nheapq.heapify(A)\n\nfor _ in range(M):\n  a = heapq.heappop(A)\n  heapq.heappush(A,-(-a//2))\n  \nprint(sum(A)*-1)", "import heapq\nn, m = map(int, input().split())\na = list(map(int, input().split()))\na = [i*-1 for i in a]\nheapq.heapify(a)\nfor i in range(m):\n    x = ((-1) * heapq.heappop(a)) //2\n    heapq.heappush(a, -x)\nprint(-sum(a))", "import sys\nimport re\nimport queue\nimport collections\nimport math\nfrom decimal import *\nfrom copy import deepcopy\nfrom collections import Counter, deque\nimport heapq\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom typing import Callable\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b // gcd(a, b)\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nnum_list = []\nstr_list = []\n\ndef main():\n\tN,M = i_map()\n\tA = i_list()\n\n\tfor i in range(0,len(A)):\n\t\tA[i] = - A[i]\n\n\theapq.heapify(A)\n\n\tfor i in range(0,M):\n\t\ttmp = math.ceil(heapq.heappop(A)/2)\n\t\theapq.heappush(A,tmp)\n\n\tsum = 0\n\tfor i in range(0,len(A)):\n\t\tsum +=- heapq.heappop(A)\n\n\tprint(sum)\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import heapq\n\nn,m=map(int,input().split())\n\na=list(map(lambda x:int(x)*(-1),input().split()))\n\nheapq.heapify(a)\n\nfor _ in range(m):\n    amin=heapq.heappop(a)\n    heapq.heappush(a,(-1)*(-amin//2))\n\nprint(-sum(a))", "import heapq\nimport sys\n\nlines = sys.stdin.readlines()\n\nN, M = [int(n) for n in lines[0].strip().split()]\nprices = [-int(n) for n in lines[1].strip().split()]\n\nheapq.heapify(prices)\n\nfor _ in range(M):\n    price = -heapq.heappop(prices)\n    heapq.heappush(prices, -1 * (price // 2))\n\nprint(-sum(prices))", "import heapq\n\nn, m = map(int, input().split())\na = list(map(lambda x: int(x)*(-1), input().split()))\nheapq.heapify(a)  # a\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\n\nfor _ in range(m):\n    tmp_min = heapq.heappop(a)\n    heapq.heappush(a, (-1)*(-tmp_min//2))  # \u8ca0\u6570\u306e\u5270\u4f59\u6f14\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u4e00\u6642\u7684\u306b0\u4ee5\u4e0a\u306e\u6574\u6570\u306b\u3057\u3066\u3044\u307e\u3059\nprint(-sum(a))", "import heapq\nfrom collections import deque\nn,m=map(int,input().split())\nA=list(map(int,input().split()))\n\nfor i in range(n):\n    A[i]*=-1\nheapq.heapify(A)\n\nfor i in range(m):\n    x=heapq.heappop(A)\n    if x%2==0:\n        x//=2\n    else:\n        x=x//2 +1\n    heapq.heappush(A,x)\n\nans=-1*sum(A)\nprint(ans)", "import heapq\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306f\u300c\u6700\u3082\u5024\u304c\u5c0f\u3055\u3044\u3082\u306e\u300d\u3092\u51fa\u3059\u3053\u3068\u306b\u6ce8\u610f\n\nprio = []\n\nn, m =list(map(int, input().split()))\nnums =list(map(int, input().split()))\n\nfor num in nums:\n    heapq.heappush(prio, -num)\n\nfor i in range(m):\n    temp = heapq.heappop(prio)\n    heapq.heappush(prio, -((-temp) // 2))\n\nprint((-sum(prio)))\n", "import math\nimport heapq\n\nn,m = map(int,input().split())\na = list(map(lambda x: int(x)*-1,input().split()))\n\nheapq.heapify(a)\n# print(a)\nfor i in range(m):\n    heapq.heappush(a,math.ceil(heapq.heappop(a)/2))\n\nprint(int(-1 *sum(a)))", "from heapq import *\nn,m = map(int,input().split())\na = list(map(int,input().split()))\n\nheap = []\nfor i in a:\n    heappush(heap,-i)\n\nfor _ in range(m):\n    tmp = heappop(heap)\n    heappush(heap,-(-tmp//2))\n\nans = 0\nfor a in heap:\n    ans += -a \nprint(ans)", "import heapq\n\n\nN, M = [int(x) for x in input().split()]\nA = [-int(x) for x in input().split()]\n\nheapq.heapify(A)\nfor i in range(M):\n    a = -heapq.heappop(A)\n    a //= 2\n    heapq.heappush(A, -a)\n\nprint((-sum(A)))\n", "import re\nimport sys\nimport math\nimport itertools\nimport bisect\nimport heapq#.heapify:Priority Queue\u306b\u5909\u63db \n#.heappop:\u6700\u5c0f\u5024\u53d6\u5f97, .heappush:\u8981\u7d20\u633f\u5165\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef get_primenumber(number):#\u7d20\u6570\u5217\u6319\n    prime_list = []\n    search_list = list(range(2,number+1))\n    #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n    while search_list[0] <= math.sqrt(number):\n      #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n      #search_list\u306e\u5148\u982d\u3092prime_list\u306b\u5165\u308c\u3066\u3001\u5148\u982d\u3092\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3057\u3066\u524a\u9664\n        head_num = search_list.pop(0)\n        prime_list.append(head_num)\n        #head_num\u306e\u500d\u6570\u3092\u9664\u53bb\n        search_list = [num for num in search_list if num % head_num != 0]\n    #prime_list\u306bsearch_list\u3092\u7d50\u5408\n    prime_list.extend(search_list)\n    return prime_list\ndef factrization_prime(number):#\u7d20\u56e0\u6570\u5206\u89e3\n    factor = {}\n    div = 2\n    s = math.sqrt(number)\n    while div < s:\n        div_cnt = 0\n        while number % div == 0:\n            div_cnt += 1\n            number //= div\n        if div_cnt != 0:\n            factor[div] = div_cnt\n        div += 1\n    if number > 1:\n        factor[number] = 1\n    return factor\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return list(map(int,input().split()))\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 6)\nmod = 10**9+7\ncnt = 0\nans = 0\nnum = []\ninf = float(\"inf\")\nal = \"abcdefghijklmnopqrstuvwxyz\"\nAL = al.upper()\n\nn,m = I()\nA = l()\nA = list([x*-1 for x in A])\nheapq.heapify(A)\n\nfor i in range(m):\n    mm = heapq.heappop(A)\n    if mm % 2 != 0:\n        heapq.heappush(A,mm//2+1)\n    else:\n        heapq.heappush(A,mm//2)\n\nA = list([x*-1 for x in A])\nprint((sum(A)))\n\n", "import heapq\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = [-a for a in A]\nheapq.heapify(A)\n\nfor i in range(M):\n    most_expensive = -heapq.heappop(A)\n    most_expensive //= 2\n    heapq.heappush(A, -most_expensive)\n\nprint((-sum(A)))\n\n\n", "import heapq\nN,M = map(int,input().split())\nlsA = list(map(int,input().split()))\nlsA = [-i for i in lsA]\nheapq.heapify(lsA)\nfor i in range(M):\n    maxA = heapq.heappop(lsA)\n    heapq.heappush(lsA,-(-maxA//2))\nlsA = [-i for i in lsA]\nprint(sum(lsA))", "#!/usr/bin/env python3\n\nimport heapq\n#import\n#import math\n#import numpy as np\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA = [A[i] * (-1) for i in range(N)]\nheapq.heapify(A)\n\nfor i in range(M):\n    q = heapq.heappop(A)\n    if q == 0:\n        print((0))\n        return\n    heapq.heappush(A, int(q / 2))\n\nprint((sum(A) * (-1)))\n", "import heapq\n\nN, M = map(int, input().split())\nA = list(map(lambda x: int(x) * (-1), input().split()))\n\nheapq.heapify(A)\n\nfor i in range(M):\n    t = heapq.heappop(A)\n    heapq.heappush(A, (-1) * (-t // 2))\n    #print(A)\n\nprint(-sum(A))", "from heapq import heapify,heappop,heappush\n\nn,m = map(int,input().split())\na = list(map(lambda x: -int(x),input().split()))\nheapify(a)\n#print(a)\n\nfor i in range(m):\n  x = -heappop(a)\n  x //= 2\n  heappush(a,-x)\nprint(-sum(a))", "import heapq\nN,M=map(int,input().split())\narr=list(map(int,input().split()))\nhq=[]\nfor i in arr:\n    heapq.heappush(hq,-i)\n\nwhile M>0:\n    a=heapq.heappop(hq)    \n    heapq.heappush(hq,a/2)\n    M-=1\n    #print(hq)\nans=0\nfor i in hq:    \n    ans+=int(-i)\n    \nprint(ans)", "import heapq\n\nN, M = map(int,input().split())\nA = list(map(lambda x: int(x) * (-1), input().split()))\nheapq.heapify(A)\n\nfor _ in range(M):\n  tmp_min = heapq.heappop(A)\n  heapq.heappush(A, (-1) * (-tmp_min // 2))\n\nprint(-sum(A))", "import heapq\n\nn, m = map(int, input().split())\na = list(map(lambda x: int(x)*(-1), input().split()))\nheapq.heapify(a)  # a\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\n\nfor _ in range(m):\n    tmp_min = heapq.heappop(a)\n    heapq.heappush(a, (-1)*(-tmp_min//2))  # \u8ca0\u6570\u306e\u5270\u4f59\u6f14\u7b97\u3092\u907f\u3051\u308b\u305f\u3081\u4e00\u6642\u7684\u306b0\u4ee5\u4e0a\u306e\u6574\u6570\u306b\u3057\u3066\u3044\u307e\u3059\nprint(-sum(a))", "import heapq\nimport math\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\ndef __starting_point():\n    a = [-1 * i for i in A]\n    heapq.heapify(a)\n\n    for _ in range(M):\n        #pop\n        temp = heapq.heappop(a)\n        #push\n        heapq.heappush(a,math.ceil(temp / 2))\n\n    print((sum(a) * -1))\n\n__starting_point()", "import heapq\n\nN, M = [int(x) for x in input().split()]\nA = [-int(x) for x in input().split()]\n\nheapq.heapify(A)\n\nfor i in range(M):\n    a = heapq.heappop(A)\n    heapq.heappush(A, -((-a)//2))\n\nans = -sum(A)\n\nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 12:35:58 2020\n\n@author: liang\n\"\"\"\n\nN, M = map(int, input().split())\nA = [int(x) for x in input().split()]\nA.sort(reverse=True)\n#print(A)\ncount = 0\nwhile count != M:\n    A[0] //= 2\n    count += 1\n    tmp = A[0]\n    for i in range(1,N):\n        if count == M:\n            break\n        if A[i] > tmp:\n            A[i] //= 2\n            count += 1\n        ##   break\n    A.sort(reverse=True)\nans = sum(A)\n#print(A)\nprint(ans)", "'''\nCreated on 2020/09/09\n\n@author: harurun\n'''\ndef main():\n  import heapq\n  import sys\n  pin=sys.stdin.readline\n  pout=sys.stdout.write\n  perr=sys.stderr.write\n  \n  N,M=map(int,pin().split())\n  A=list(map(int,pin().split()))\n  B=list(map(lambda x: -x ,A))\n  heapq.heapify(B)\n  for i in range(M):\n    t=heapq.heappop(B)\n    s=-((-t)//2)\n    heapq.heappush(B,s)\n  ans=0\n  for j in range(N):\n    q=heapq.heappop(B)\n    ans+=(-q)\n  print(ans)\n  return\nmain()", "import heapq\nn, m = [int(i) for i in input().split()]\na = [-int(i) for i in input().split()]\nheapq.heapify(a)\nfor _ in range(m):\n  value = heapq.heappop(a)\n  value /= 2\n  heapq.heappush(a, value)\nfor i in range(n):\n  a[i] = int(-a[i])\nprint(sum(a))", "import heapq\nn, m, *a = list(map(int, open(0).read().split()))\na = list([-x for x in a])\n\nheapq.heapify(a)\nfor i in range(m):\n    b = -heapq.heappop(a)\n    heapq.heappush(a, -(b >> 1))\n\nprint((-sum(a)))\n", "def main():\n\tN, M = [int(x) for x in input().split(\" \")]\n\tA = [int(a) for a in input().split(\" \")]\n\tD = []\n\tfor i in range(len(A)):\n\t\ttmp = A[i]\n\t\twhile tmp > 0:\n\t\t\thalf = int(tmp / 2)\n\t\t\tD.append(tmp - half)\n\t\t\ttmp = half\n\tD.sort(reverse=True)\n\tprint(sum(A) - sum(D[:M]))\n\nmain()", "import heapq\nN, M =list(map(int, input().split()))\nA=list([int(x)*(-1) for x in input().split()]) #\u5404\u8981\u7d20\u3092-1\u500d\nheapq.heapify(A) #A\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\n\nfor _ in range(M):\n\ttemp_min=heapq.heappop(A)\n\theapq.heappush(A, (-1)*(temp_min*(-1)//2))\nprint((-sum(A)))\n", "import heapq\n\nn, m = map(int,input().split())\nhp = map(lambda x: (-1)*int(x), input().split())\nhp = list(hp)\nheapq.heapify(hp)\n\nfor i in range(m):\n  item = -1*heapq.heappop(hp)\n  # print('item',item)\n  item = item //2\n  heapq.heappush(hp, -item)\n  \nprint(-1*sum(hp))", "import heapq\nn,m = list(map(int,input().split()))\ncost = list(map(int,input().split()))\ncost = list([x*(-1) for x in cost])\nheapq.heapify(cost)\n\nwhile m != 0 :\n    max = heapq.heappop(cost)\n    val = ((-1)*max//2)*(-1)\n    m -= 1\n    heapq.heappush(cost,val)\n\ncost = list([x*(-1) for x in cost])\nprint((sum(cost)))\n", "import heapq\nn,m=map(int,input().split())\na=list(map(lambda x:-int(x),input().split()))\nheapq.heapify(a)\nfor i in range(m):\n    x=-heapq.heappop(a)\n    heapq.heappush(a,-(x//2))\nprint(-sum(a))", "import heapq\n\nn,m=map(int,input().split())\na=list(map(lambda x:int(x)*(-1),input().split()))\nheapq.heapify(a)\n\nfor i in range(m):\n  top=heapq.heappop(a)\n  heapq.heappush(a,(-1)*(-top//2))\n  \nprint(-sum(a))", "import heapq\nN, M = list(map(int, input().split()))\nhq = []\nfor price in map(int, input().split()):\n    heapq.heappush(hq, -price)\n\nfor i in range(M):\n    p = -heapq.heappop(hq)\n    p /= 2\n    heapq.heappush(hq, -p)\n\nresult = -sum([int(p) for p in hq])\nprint(result)\n", "import heapq\nN,M=map(int,input().split())\n\nA=list(map(int,input().split()))\n\nfor i in range(N):\n  A[i]*=-1\nheapq.heapify(A)\nfor i in range(M):\n  n=heapq.heappop(A)\n  heapq.heappush(A,-((-n)//2))\nprint(-sum(A))", "import heapq\nn,m = list(map(int,input().split()))\ncost = list(map(int,input().split()))\ncost = list([x*(-1) for x in cost])\nheapq.heapify(cost)\n\nwhile m != 0 :\n    max = heapq.heappop(cost)\n    val = ((-1)*max//2)*(-1)\n    m -= 1\n    heapq.heappush(cost,val)\n\ncost = list([x*(-1) for x in cost])\nprint((sum(cost)))\n", "import heapq\n\nn, m = map(int, input().split())\na = list(map(lambda x: int(x)*(-1), input().split()))\nheapq.heapify(a)\n\nwhile m > 0:\n    a_max = heapq.heappop(a)\n    if a_max == 0:\n        break\n    heapq.heappush(a, (-1)*(-a_max // 2))\n    m -= 1\nprint(sum(a)*(-1))", "import heapq as hp\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = [ -a for a in A]\nhp.heapify(A)\nfor _ in range(M):\n    x = hp.heappop(A)\n    hp.heappush(A, x / 2)\nA = [ int(-a) for a in A]\nprint((sum(A)))\n", "import heapq\nn,m = map(int,input().split())\na = list(map(int,input().split()))\n\na = list(map(lambda x:(-1)*x,a))\n\nheapq.heapify(a)\n\nfor i in range(m):\n    tmp = heapq.heappop(a)\n    heapq.heappush(a,(-1)*(((-1)*tmp)//2))\nprint(sum(a)*(-1))", "n,m=map(int,input().split())\na = list(map(int,input().split()))\n\nfor i in range(n):\n    a[i]*=-1\n\nimport heapq,math\n\nheapq.heapify(a)\n\nfor _ in range(m):\n    b=heapq.heappop(a)*(-1)\n    b //=2\n\n    heapq.heappush(a,b*(-1))\n\nprint(sum(a)*(-1))", "from heapq import heapify, heappop, heappush\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nq = []\nfor a in A:\n    q.append((a//2-a, a, 1))\nheapify(q)\nans = sum(A)\nfor _ in range(M):\n    discount, a, n = heappop(q)\n    ans += discount\n    if ans==0:\n        break\n    heappush(q, (a//2**(n+1)-a//2**n, a, n+1))\nprint(ans)\n", "class Heap:\n    \"\"\"\n    \u7df4\u7fd2\u7528\u306b\u66f8\u3044\u305f\u30af\u30e9\u30b9\n    \u672c\u756a\u306f'heapq'\u3092\u4f7f\u3046\n    \"\"\"\n    def __init__(self, x: list):\n        # initialize\n        self.heap = []\n        for item in x:\n            self.push(item)\n\n    def push(self, item: int):\n        self.heap.append(item)\n        idx_child = len(self.heap) - 1\n        while (idx_child > 0):\n            idx_parent = (idx_child - 1) // 2\n            if self.heap[idx_parent] <= item:\n                break\n            # swap\n            tmp = self.heap[idx_child]\n            self.heap[idx_parent], self.heap[idx_child] \\\n                = self.heap[idx_child], self.heap[idx_parent] \n            idx_child = idx_parent\n\n    def pop(self) -> int:\n        # \u6700\u5c0f\u5024\n        ret = self.heap[0]\n        # \u6700\u5f8c\u5c3e\u3092root\u3078\u79fb\u52d5\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        idx_parent = 0\n        while (idx_parent * 2 + 1 < len(self.heap)):\n            # \u5de6\u306b\u884c\u304f\u304b\u53f3\u306b\u884c\u304f\u304b\n            idx_child_l, idx_child_r = 2 * idx_parent + 1, 2 * idx_parent + 2\n            if idx_child_r < len(self.heap) and self.heap[idx_child_r] < self.heap[idx_child_l]:\n                idx_child = idx_child_r\n            else:\n                idx_child = idx_child_l\n            # break\n            if self.heap[idx_parent] <= self.heap[idx_child]:\n                break\n            self.heap[idx_child], self.heap[idx_parent] \\\n                = self.heap[idx_parent], self.heap[idx_child]\n            idx_parent = idx_child\n        return ret\n\n    def load(self) -> list:\n        return self.heap\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = [ -a for a in A]\nheap = Heap(A)\nfor _ in range(M):\n    x = heap.pop()\n    heap.push(x / 2)\nA = heap.load()\nA = [ int(-a) for a in A]\nprint(sum(A))", "n,m=map(int,input().split())\nimport heapq\n\na=list(map(lambda x:int(x)*(-1), input().split()))\nheapq.heapify(a)\n\nfor _ in range(m):\n    tmp_min = heapq.heappop(a)\n    heapq.heappush(a,(-1)*(-tmp_min//2))\nprint(-sum(a))", "import heapq\nn,m = map(int,input().split())\na = list(map(int,input().split()))\na = list(map(lambda x:x*(-1),a))\nheapq.heapify(a)\nfor i in range(m):\n    x = heapq.heappop(a)*(-1)//2\n    heapq.heappush(a,(x*(-1)))\nprint(sum(a)*(-1))", "import heapq\nn,m=map(int,input().split())\na=list(map(lambda x:-int(x),input().split()))\nheapq.heapify(a)\nfor i in range(m):\n    x=-heapq.heappop(a)\n    heapq.heappush(a,-(x//2))\nprint(-sum(a))", "from heapq import heapify,heappush,heappop\n\ndef main():\n    N,M = list(map(int,input().split()))\n    A = [-x for x in map(int,input().split())]\n    heapify(A)\n    for i in range(M):\n        tmp = -heappop(A)\n        tmp2 = tmp//2\n        heappush(A,-tmp2)\n    ans = 0\n    for i in range(N):\n        ans += A[i]\n\n    ans = abs(ans)\n    return ans\n\nprint((main()))\n", "import heapq\nimport math\nn,m=map(int,input().split())\na=list(map(lambda x:int(x)*(-1),input().split()))\nheapq.heapify(a)\nfor i in range(m):\n  x=heapq.heapreplace(a,math.ceil(a[0]/2))\nprint(sum(a)*(-1)) ", "import sys\nstdin = sys.stdin\n\nn,m = map(int, stdin.readline().split())\nan = [i*(-1) for i in map(int, stdin.readline().split())]\n#print(an)\n#print(sum(an))\n\nimport heapq\nheapq.heapify(an)\n\nfor _ in range(m):\n    b = heapq.heappop(an)\n    heapq.heappush(an, (-1)*((-1)*b//2))\n\n#print(an)\nans = (-1)*sum(an)\nprint(ans)", "import copy\n\ndef bi_search(money,M,N):\n    money.sort()\n    #list = []\n    #for i in range(0,money[N-1]+2,1):\n        #list.append(i)\n    left = 0\n    right = money[N-1]+1\n    mid = 0\n    #print(list,left,right)\n    while True:\n        mid = int( (left+right)/2 )\n        cnt = 0\n        #print(left,right,mid)\n        #print(money)\n        money_tmp = copy.copy(money)\n        for i in range(N):\n            while True:\n                #print(money_tmp[i],i)\n                if money_tmp[i] <= mid:\n                    break\n                else:\n                    money_tmp[i] //= 2\n                    cnt += 1\n        #print(cnt)\n        if cnt == M:\n            return mid,cnt\n        elif cnt < M:\n            right = mid\n            tmp = cnt\n        elif cnt > M:\n            left = mid + 1\n\n        if left == right:\n            return right,tmp\n\ndef main():\n    N,M = list(map(int,input().split()))\n    A = list(map(int,input().split()))\n    max_money,cnt = bi_search(A,M,N)\n    #print (cnt)\n    cnt = M-cnt\n    ans = 0\n    for i in range(N):\n        if max_money >= A[i]:\n            continue\n            #ans += A[i]\n        else:\n            while True:\n                A[i] //= 2\n                if max_money >= A[i]:\n                    #ans += A[i]\n                    break\n    A.sort(reverse = True)\n    j = 0\n    if A[j] == 0:\n        return 0\n    for i in range(cnt):\n        A[j] //= 2\n        j += 1\n\n    for i in range(N):\n        ans += A[i]\n\n    return ans\n\nprint((main()))\n", "import heapq\nn, m = map(int, input().split())\na = [i*-1 for i in list(map(int, input().split()))]\nheapq.heapify(a)\nfor i in range(m):\n    x = heapq.heappop(a)*-1\n    heapq.heappush(a, (x//2)*-1)\nprint(sum(a)*-1)", "import heapq\n\nN, M = list(map(int, input().split()))\nA = list([-int(x) for x in input().split()])\n\nheapq.heapify(A)\n\nfor _ in range(M):\n    p = -heapq.heappop(A)\n    tmp = p // 2\n    heapq.heappush(A, -tmp)\n\nprint((-sum(A)))\n", "#!/usr/bin/env python3\nimport heapq\n# input = stdin.readline\n\ndef solve(n,m,a):\n  a = [-x for x in a]\n  heapq.heapify(a)\n  for _ in range(m):\n    x = heapq.heappop(a)\n    heapq.heappush(a,-(abs(x)//2))\n  return abs(sum(a))\n\n\ndef main():\n  N,M = list(map(int,input().split()))\n  a = list(sorted(map(int,input().split())))\n  print((solve(N,M,a)))\n  pass\n\ndef __starting_point():\n  main()\n\n__starting_point()", "import math\n\nclass Heap():\n\n    def __init__(self,array):\n        self.array = list(array)\n        self._build_heap()\n\n    def _build_heap(self):\n        for i in reversed(range(len(self.array)//2)):\n            self._min_heap(i)\n\n\n    def _min_heap(self,i):\n        #index\u30921\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u6271\u3044\u306b\u3057\u3066\u8a08\u7b97\u3057\u623b\u3059\n        left = (2*(i+1))-1\n        right= (2*(i+1)+1)-1\n        length = len(self.array) -1\n        smallest = i\n\n        if left <=length and self.array[i]>self.array[left]:\n            smallest = left\n        if right <=length and self.array[smallest]>self.array[right]:\n            smallest = right\n        if smallest != i:\n            self.array[i],self.array[smallest]=self.array[smallest],self.array[i]\n            self._min_heap(smallest)\n\n    def pop(self):\n        tmp = self.array[0]\n        self.array[0] = self.array[-1]\n        del self.array[-1]\n        self._min_heap(0)\n        return tmp\n\n    def push(self,v):\n        self.array.append(v)\n        index = len(self.array)#1\u30b9\u30bf\u30fc\u30c8\u63db\u7b97\u306eindex\n        while self.array[(index//2)-1] > self.array[index-1]:\n            self.array[(index//2)-1],self.array[index-1]=self.array[index-1],self.array[(index//2)-1]\n            index = index//2\n\nn,m = map(int,input().split())\na = map(lambda x: int(x)*-1,input().split())\n\na = Heap(a)\n\nfor i in range(m):\n    # print(a.array)\n    a.push(math.ceil(a.pop()/2))\n\nprint(int(-1 *sum(a.array)))", "# -*- coding: utf-8 -*-\nimport numpy as np\nimport sys\nfrom collections import deque\nfrom collections import defaultdict\nimport heapq\nimport collections\nimport itertools\nimport bisect\nfrom scipy.special import comb\nimport copy\nsys.setrecursionlimit(10**6)\n\n\ndef zz():\n    return list(map(int, sys.stdin.readline().split()))\n\n\ndef z():\n    return int(sys.stdin.readline())\n\n\ndef S():\n    return sys.stdin.readline()[:-1]\n\n\ndef C(line):\n    return [sys.stdin.readline() for _ in range(line)]\n\n\nN, M = zz()\nA = zz()\nA = [-a for a in A]\nheapq.heapify(A)\n\nfor i in range(M):\n    money = heapq.heappop(A)\n    money *= -1\n    money //= 2\n    money *= -1\n    heapq.heappush(A, money)\nprint((sum(A)*-1))\n", "import heapq\nimport math\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\ndef __starting_point():\n    a = [-1 * i for i in A]\n    heapq.heapify(a)\n\n    for _ in range(M):\n        #pop\n        temp = heapq.heappop(a)\n        #push\n        heapq.heappush(a,math.ceil(temp / 2))\n\n    ans = [-1 * i for i in a]\n    print((sum(ans)))\n\n__starting_point()", "import heapq\nN, M = list(map(int, input().split()))\nA = list([-int(x) for x in input().split()])\nheapq.heapify(A)\n\nans = 0\nfor i in range(M):\n    most_expensive = -heapq.heappop(A)\n    most_expensive //= 2\n    heapq.heappush(A, -most_expensive)\n\nprint((-sum(A)))\n", "import heapq\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na = list(map(lambda x: -x, a))\nheapq.heapify(a)\nfor _ in range(m):\n    heapq.heappush(a, -((-heapq.heappop(a))//2))\nprint(-sum(a))", "3\n\nimport heapq\n\ndef main():\n    line1 = input()\n    line2 = input()\n\n    n, m = list(map(int, line1.split()))\n    l = list(map(int, line2.split()))\n    ans = sum(l)\n    for i in range(len(l)):\n        l[i] *= -1\n    heapq.heapify(l)\n    for i in range(m):\n        price = heapq.heappop(l) * (-1)\n        new_price = price // 2\n        heapq.heappush(l, new_price * (-1))\n        ans -= (price - new_price)\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nimport heapq\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nlis = []\nfor i in a:\n    lis.append(-1*i)\n\nheapq.heapify(lis)\n\nfor _ in range(m):\n    tmp = heapq.heappop(lis)\n    heapq.heappush(lis, (-1)*(-tmp//2))\n\nprint(-sum(lis))", "import heapq\n\nN, M = [int(_) for _ in input().split()]\nA = [int(_) * -1 for _ in input().split()]\n\nheapq.heapify(A)\nfor i in range(M):\n    a = heapq.heappop(A) * -1\n    heapq.heappush(A, (-1)*(a//2))\nprint(((-1) * sum(A)))\n"]
["N=int(input());R,d,f,s,x=sorted(list(map(int,input().split()))for i in range(N))+[(2e9,0)],[0]*N+[1],[0]*N,1,N\nfor i in range(N-1,-1,-1):\n\twhile R[x][0]<sum(R[i]):x=f[x]\n\td[i]=s=(s+d[x])%998244353;f[i],x=x,i\nprint(d[0])", "N=int(input())\nR,d,f,s,x=sorted(list(map(int,input().split()))for i in range(N))+[(2e9,0)],[0]*N+[1],[0]*N,1,N\nfor i in range(N-1,-1,-1):\n\twhile R[x][0]<sum(R[i]):x=f[x]\n\td[i]=s=(s+d[x])%998244353;f[i],x=x,i\nprint(d[0])", "N=int(input())\nR,d,f,s=sorted(list(map(int,input().split()))for i in range(N))+[(2e9,0)],[0]*N+[1],[0]*N,1\nfor i in range(N-1,-1,-1):\n    x=i+1\n    while x<N and R[x][0]<sum(R[i]):x=f[x]\n    f[i]=x\n    d[i]=s=(s+d[x])%998244353\nprint(d[0])", "import sys\ninput = sys.stdin.readline\n\nmod = 998244353\nN = int(input())\nX = []\nfor _ in range(N):\n    x, d = map(int, input().split())\n    X.append((x, x + d))\n\nX = sorted(X, key = lambda x: x[0])\nL = [(0, -(10**9+1), 10**9+1)]\nP = [-1] * (N+1)\nfor i, (x, y) in enumerate(X):\n    while L[-1][2] <= y:\n        if L[-1][2] > x and P[i+1] < 0:\n            P[i+1] = L[-1][0]\n        L.pop()\n    if P[i+1] < 0:\n        P[i+1] = L[-1][0]\n    L.append((i+1, x, y))\n\nC = [[] for _ in range(N+1)]\nfor i, p in enumerate(P):\n    if p >= 0:\n        C[p].append(i)\n\nY = [1] * (N+1)\nfor i in range(N+1)[::-1]:\n    s = 1\n    for j in C[i]:\n        s = s * (Y[j] + 1) % mod\n    Y[i] = s\n\nprint(Y[0])", "def main():\n    from collections import deque\n    from operator import itemgetter\n    import sys\n    input = sys.stdin.readline\n\n    MOD = 998244353\n\n    N = int(input())\n\n    xds = []\n    xs = []\n    for _ in range(N):\n        x, d = list(map(int, input().split()))\n        xds.append((x, d))\n        xs.append(x)\n\n    xds.sort(key=itemgetter(0), reverse=True)\n    xs.sort()\n\n    ps = [-1] * (N + 1)\n    cands = deque()  # \u65e2\u51fa\u306e\u9802\u70b9\u3067\u6709\u5411\u8fba\u306e\u884c\u304d\u5148\u306b\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u306a\u3044\u3082\u306e,x\u6607\u9806\n    for j, (x, d) in enumerate(xds):\n        j = N - 1 - j\n        while cands:\n            cx, ci = cands[0]\n            if x + d <= cx:\n                # cand\u306f\u72ec\u7acb\n                break\n            elif x <= cx < x + d:\n                # cand\u3068\u9023\u7d50\n                ps[ci] = j\n                cands.popleft()\n        cands.appendleft((x, j))\n\n    ret = 1\n    ctr = [1] * N\n    for j, (x, d) in enumerate(xds):\n        j = N - 1 - j\n        par = ps[j]\n        ctr[j] += 1  # j=off,\u5b50\u306e\u7dcf\u7a4d\u304c\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u308b->j=on=1\u3092\u52a0\u7b97\n        if ~par:\n            ctr[par] = ctr[par] * ctr[j] % MOD\n        else:\n            ret = ret * ctr[j] % MOD  # j=\u6728\u306eroot\n\n    print(ret)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from collections import deque\n    import sys\n    sys.setrecursionlimit(10**7)\n    input = sys.stdin.readline\n    n = int(input())\n    X = sorted([list(map(int,input().split())) for i in range(n)])\n    mod = 998244353\n    e = [[] for i in range(n)]\n\n    def dfs(x):\n        count = 1\n\n        for i in e[x]:\n            count *= dfs(i)\n            count %= mod\n        return count+1\n\n    q = deque([])\n\n    for i in range(n-1,-1,-1):\n        a,b = X[i]\n        while q and q[0][0] < a+b:\n            e[i].append(q[0][1]) \n            q.popleft()\n        q.appendleft([a,i])\n\n    ans = 1\n    for i,j in q:\n        ans *= dfs(j)\n        ans %= mod\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\n\nmod = 998244353\n\nn = int(input())\nrobot = [tuple(map(int, input().split())) for _ in range(n)]\nrobot.sort(reverse=True)\nparent = list(range(n))\n\nroot = []\nfor i in range(n):\n  x, d = robot[i]\n  while root:\n    r = heapq.heappop(root)\n    if r[0] < x + d:\n      parent[r[1]] = i\n    else:\n      heapq.heappush(root, r)\n      break\n  heapq.heappush(root, (x, i))\n  \ncount = 1\ndp = [1] * n\nfor i in range(n):\n  p = parent[i]\n  if p == i:\n    count = count * (dp[i] + 1) % mod\n  else:\n    dp[p] = dp[p] * (dp[i] + 1) % mod\nprint(count)", "import sys\ninput = sys.stdin.readline\nN = int(input())\nXD = [tuple(map(int,input().split())) for i in range(N)]\nXD.sort()\nMOD = 998244353\nns = [-1] * N\n\nfor i,(x,d) in reversed(list(enumerate(XD))):\n    tmp = i\n    while tmp < N-1:\n        nx,_ = XD[tmp+1]\n        if nx < x+d:\n            tmp = ns[tmp+1]\n        else:\n            break\n    ns[i] = tmp\n\ndp = [0] * (N+1)\ndp[N] = 1\nfor i in range(N-1,-1,-1):\n    dp[i] = (dp[i+1] + dp[ns[i]+1]) % MOD\nprint(dp[0])", "N=int(input());R,d,f,s,x=sorted(list(map(int,input().split()))for i in range(N))+[(2e9,0)],[0]*N+[1],[0]*N,1,N\nfor i in range(N-1,-1,-1):\n\twhile R[x][0]<sum(R[i]):x=f[x]\n\td[i]=s=(s+d[x])%998244353;f[i],x=x,i\nprint(s)", "n = int(input())\nl = [tuple(map(int, input().split())) for _ in range(n)] + [(1<<31, 0)]\nmod = 998244353\nl.sort()\nst = [n]\ndp = [0]*n + [1]\nfor i in range(n-1,-1,-1):\n  x,d = l[i]\n  v = x + d\n  while l[st[-1]][0] < v: st.pop()\n  dp[i] = (dp[i+1] + dp[st[-1]]) % mod\n  st.append(i)\nprint(dp[0])", "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    def dfs(i):\n        res = 1\n        for j in to[i]:\n            res = res * dfs(j) % md\n        return res + 1\n\n    md = 998244353\n    n = II()\n    xd = LLI(n)\n    xd.sort(reverse=True)\n    to = [[] for _ in range(n)]\n    hp = []\n    for i, (x, d) in enumerate(xd):\n        while hp and hp[0][0] < x + d:\n            px, pi = heappop(hp)\n            to[i].append(pi)\n        heappush(hp, (x, i))\n    ans = 1\n    while hp:\n        _, i = heappop(hp)\n        ans = ans * dfs(i) % md\n    print(ans)\n\nmain()\n", "law = 998244353\nn = int(input())\nrobots = [tuple(map(int, input().split())) for _ in range(n)]\n\nrobots.sort(reverse = True)\n\nntrig = [-1] * n\ndp = [0] * n\ndp[0] = 2\nfor i, (x, d) in enumerate(robots):\n    if i == 0:\n        continue\n    next = i-1\n    while x + d > robots[next][0]:\n        next = ntrig[next]\n        if next == -1:\n            break\n    ntrig[i] = next\n    if next == -1:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1] + dp[next]\n    dp[i] %= law\n\nprint(dp[n-1])", "def main():\n    mod = 998244353\n    n = int(input())\n    ab = sorted([tuple(map(int, input().split())) for _ in [0]*n])\n    next_idx = [-1]*n\n    for i in range(n-1, -1, -1):\n        dist = sum(ab[i])\n        now = i\n        while now < n-1:\n            a1, b1 = ab[now+1]\n            if a1 < dist:\n                now = next_idx[now+1]\n            else:\n                break\n        next_idx[i] = now\n    dp = [0]*(n+1)\n    dp[n] = 1\n    for i in range(n-1, -1, -1):\n        dp[i] = (dp[i+1]+dp[next_idx[i]+1]) % mod\n    print(dp[0])\n \n \nmain()", "mod = 998244353\n\nn = 0\nx = []\nd = []\n\ndef search(s):\n    lo = 0\n    hi = n - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if s > x[mid]:\n            lo = mid + 1\n        elif s < x[mid]:\n            hi = mid - 1\n        else:\n            return mid\n    return max(lo, hi)\n\n\ndef __starting_point():\n    xd = []\n    n = int(input())\n    for i in range(n):\n        xi, di = map(int, input().split())\n        xd.append((xi, di))\n\n    xd.sort()\n    x = list(map(lambda x: x[0], xd))\n    d = list(map(lambda x: x[1], xd))\n\n    dp = [0] * (n+1)\n    dp[-1] = 1\n    next = [0] * n\n\n    st = []\n    st.append((n, 2e9))\n\n    for i in range(n-1, -1, -1):\n\n        while st[-1][1] < x[i] + d[i]:\n            st.pop()\n        next[i] = st[-1][0]\n        st.append((i, x[i]))\n\n    for i in range(n - 1, -1, -1):\n        dp[i] = (dp[next[i]] + dp[i + 1]) % mod\n    \n    print(dp[0])\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nfrom bisect import bisect_left\n\nN = int(input())\nXD = [[int(i) for i in input().split()] for _ in range(N)]\nXD.sort()\nMOD = 998244353\n\ndef make():\n    edge = [[] for _ in range(N)]\n    parent = [-1] * N\n    MAXIDX = N\n    sorted_X = [X for X,_ in XD]\n    for i in range(N-1, -1, -1):\n        idx = bisect_left(sorted_X, XD[i][0] + XD[i][1])\n        for j in range(i+1, min(idx, MAXIDX)):\n            if parent[j] < 0:\n                parent[j] = i\n        if idx >= MAXIDX:\n            MAXIDX = i + 1\n    for i,par in enumerate(parent):\n        if par < 0:\n            continue\n        edge[par].append(i)\n    \n    return parent, edge\n\nparent, edge = make()\n\ndef cnt(node):\n    if not edge[node]:\n        return 2\n\n    res = 1\n    for v in edge[node]:\n        res = (res * cnt(v)) % MOD\n    res += 1\n\n    return res % MOD\n\ndef main():\n    ans = 1\n    for i,par in enumerate(parent):\n        if par < 0:\n            ans = (ans * cnt(i)) % MOD\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    mod = 998244353\n    \n    N = int(input())\n    robot = [tuple(map(int, input().split())) for _ in range(N)]\n    robot.sort()\n\n    stack = []\n    dp = [1] * (N+1)\n    for i in reversed(range(N)):\n        x, d = robot[i]\n        while stack and robot[stack[-1]][0] < x + d:\n            stack.pop()\n        if stack:\n            dp[i] = dp[i+1] + dp[stack[-1]]\n        else:\n            dp[i] = dp[i+1] + 1\n        dp[i] %= mod\n        stack.append(i)\n    \n    print(dp[0])\n\nmain()", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nimport bisect\nMOD = 998244353\n\nn = int(input())\nxd = []\nplaces = [(10**12, 0)]\nfor _ in range(n):\n    x, d = [int(item) for item in input().split()]\n    xd.append((x, d))\n\nxd.sort(reverse=True)\naffect = [0] * (n + 1)\ndp = [0] * (n + 1)\ndp[0] = 1\nfor i, (x, d) in enumerate(xd):\n    frm = x\n    too = x + d \n    too_idx = i\n    while too > places[-1][0]:\n        _, too_idx = places.pop()\n    places.append((frm, too_idx))\n    dp[i + 1] = dp[i] + dp[too_idx]\n    dp[i + 1] %= MOD\n\nprint(dp[-1])", "import sys\nsys.setrecursionlimit(10**9)\n\nMOD = 998244353\nN = int(input())\nrobo = list(list(map(int,input().split()))for i in range(N))\nrobo.sort()\nchild = [[]for i in range(N+1)]\nstack = [] # \u6709\u52b9\u3001\u540d\u524d\n\nfor i in range(N):\n    x,d = robo[i]\n    while stack and stack[-1][0] <= x:\n        stack.pop()\n    if stack:\n        child[stack[-1][1]].append(i+1)\n    else:\n        child[0].append(i+1)\n    stack.append([x+d,i+1])\n\ndef func(x):\n    hoge = 1\n    for i in child[x]:\n        hoge *= func(i)\n        hoge %= MOD\n    return (hoge + 1) % MOD\n\nprint((func(0)-1))\n", "#input\nN = int(input())\nXD = []\nfor _ in range(N):\n    x, d = list(map(int, input().split()))\n    XD.append((x, x+d))\n\nMOD = 998244353\n\n# process\nXD.sort(reverse=True)\n\nsei = [(10**9, 0)]\npattern = [0]*(N+1)\npattern[0] = 1\nfor i, (s, e) in enumerate(XD):\n    ei = i\n    while e > sei[-1][0]:\n        _, ei = sei.pop()\n    sei.append((s, ei))\n    pattern[i+1] = (pattern[i] + pattern[ei]) % MOD\n\n# output\nprint((pattern[-1]))\n", "n = int(input()); arr = [list(map(int,input().split())) for _ in range(n)]\n\nmod = 998244353\nans = 0\narr.sort(key=lambda x: x[0],reverse=True)\npos = [i[0] for i in arr]\nmoved = [sum(i) for i in arr]\nchildren = [i for i in range(-1,n)]\n\nfor i in range(1,n):\n    parent = moved[i]\n    child = children[i]\n    cmp = pos[child]\n    while cmp < parent:\n        child = children[child]\n        if child == -1:\n            break\n        cmp = pos[child]\n    children[i] = child\n    \ndp = [0] * (n+1)\ndp[n] = 1\nfor i in range(n):\n    dp[i] = dp[i-1] + dp[children[i]]\n    dp[i] %= mod\n    \nprint(dp[n-1])", "\nimport numpy as np\n\nM = 998244353\n\nn = int(input())\nxs = [0] * n\nds = [0] * n\nfor i in range(n):\n    x, d = (int(c) for c in input().split())\n    ds[i] = d\n    xs[i] = x\nxs = np.array(xs)\nds = np.array(ds)\n\nimport sys\nsys.setrecursionlimit(max(1000,n))\n\nindex = xs.argsort()\nxs = xs[index]\nds = ds[index]\n\ndef _sub(i):\n    # \u6df1\u3055\u512a\u5148\u63a2\u7d22\u3057\u306a\u304c\u3089i\u756a\u76ee\u4ee5\u4e0b\u306e\u7d44\u307f\u5408\u308f\u305b\u3068\u3001\u6b21\u306b\u8abf\u3079\u308b\u3079\u304d\u756a\u53f7\u3092\u8fd4\u3059\n    if i==n-1:\n        return 2, n\n    res = 1\n    ind = i+1\n    while True:\n        if (xs[i]+ds[i] <= xs[ind]):\n            break\n        o, ind = _sub(ind)\n        res *= o\n        res %= M\n        if ind>=n:\n            break\n    return res+1, ind\nout = []\ndone = 0\nwhile True:\n    o, done = _sub(done)\n    out.append(o)\n    if done>=n:\n        break\nresult = 1\nfor o in out:\n    result *= o\n    result %= M\nprint(result)", "import numpy as np\nimport collections\n\nRobot = collections.namedtuple('Robot', ['l', 'r'])\n\nN = int(input())\nMOD = 998244353\nrobots = []\nfor _ in range(N):\n    x, d = map(int, input().split())\n    robots.append(Robot(x, x + d))\nrobots.sort()\n\nrobots.append(Robot(10**10, 10**10 + 1))\nstack = [N]\n\ndp = np.zeros(N + 1, dtype=int)\ndp[N] = 1\n\nfor i in range(N - 1, -1, -1):\n    # For each i, we want the stack contains all the j such that\n    # robots[j] is not affected by robot[i], therefore\n    # we remove those robots that are intersected with robot[i]\n    while robots[stack[-1]].l < robots[i].r:\n        stack.pop()\n\n    # dp[i] = dp[i + 1] (not activate robot i) + dp[j] (activate robot i)\n    j = stack[-1]\n    dp[i] = (dp[i + 1] + dp[j]) % MOD\n    stack.append(i)\n\nprint(dp[0])", "def main():\n    n = int(input())\n    xd = [list(map(int, input().split())) for _ in range(n)]\n    mod = 998244353\n    INF = 10 ** 10\n\n    xx = [(x, x + d, i) for i, (x, d) in enumerate(xd, 1)]\n    xx.sort()\n    c = [[] for _ in range(n + 1)]\n    stack = [(INF, 0)]\n    for l, r, i in xx:\n        while stack[-1][0] <= l:\n            stack.pop()\n\n        ip = stack[-1][1]\n        c[ip].append(i)\n        stack.append((r, i))\n\n    dp = [1] * (n + 1)\n    for _, _, u in xx[::-1]:\n        for v in c[u]:\n            dp[u] *= dp[v]\n            dp[u] %= mod\n\n        dp[u] += 1\n        dp[u] %= mod\n\n    for v in c[0]:\n        dp[0] *= dp[v]\n        dp[0] %= mod\n\n    ans = dp[0]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 998244353\n\nN, *XD = map(int, open(0).read().split())\n\nXD = sorted(zip(*[iter(XD)] * 2), reverse=True)\n\nS = [(1e10, 0)]\ndp = [1] + [0] * N\nfor i, (x, d) in enumerate(XD):\n    j = i\n    while S[-1][0] < x + d:\n        _, j = S.pop()\n    S.append((x, j))\n    dp[i + 1] = (dp[i] + dp[j]) % mod\n\nprint(dp[-1])", "def main():\n    mod = 998244353\n    n = int(input())\n    ab = [tuple(map(int, input().split())) for _ in [0]*n]\n    ab.sort()\n    next_a = [-1]*n\n    dp = [0]*(n+1)\n    dp[n] = 1\n    for i in range(n-1, -1, -1):\n        a0, b0 = ab[i]\n        dist = a0+b0\n        now = i\n        while now < n-1:\n            a1, b1 = ab[now+1]\n            if a1 < dist:\n                now = next_a[now+1]\n            else:\n                break\n        next_a[i] = now\n    for i in range(n-1, -1, -1):\n        dp[i] = (dp[i+1]+dp[next_a[i]+1]) % mod\n    print(dp[0] % mod)\n\n\nmain()", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nMOD = 998244353\n\nn = int(input())\nxd = []\n# Add sentinel\nplaces = [(10**12, 0)]\nfor _ in range(n):\n    x, d = [int(item) for item in input().split()]\n    xd.append((x, d))\n\nxd.sort(reverse=True)\ndp = [0] * (n + 1)\ndp[0] = 1\nfor i, (x, d) in enumerate(xd):\n    frm = x\n    too = x + d \n    too_idx = i\n    while too > places[-1][0]:\n        _, too_idx = places.pop()\n    places.append((frm, too_idx))\n    dp[i + 1] = dp[i] + dp[too_idx]\n    dp[i + 1] %= MOD\n\nprint(dp[-1])", "mod = 998244353\nn = int(input())\nl = [tuple(map(int, input().split())) for _ in range(n)] + [(10**10, 0)]\nl.sort()\nst = [n]\nnex = [n]*n\nfor i in range(n-1,-1,-1):\n  x,d = l[i]\n  v = x + d\n  while l[st[-1]][0] < v: st.pop()\n  nex[i] = st[-1]\n  st.append(i)\ndp = [0]*(n+1)\ndp[n] = 1\nfor i in range(n-1,-1,-1):\n  dp[i] = (dp[i+1] + dp[nex[i]]) % mod\nprint(dp[0])", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nMOD = 998244353\n\ndef init(G, robots, fs, p):\n    q = p\n    while q < len(robots) and robots[q][0] < robots[p][0] + robots[p][1]:\n        if fs[q]:\n            G[p].append(q)\n            fs[q] = False\n            q = init(G, robots, fs, q) - 1\n        q += 1\n    return q\n\ndef calc(G, p, fs):\n    fs[p] = False\n    if len(G[p]) == 0:\n        return 2\n    tmp = 1\n    for v in G[p]:\n        tmp *= calc(G, v, fs)\n        tmp %= MOD\n    tmp += 1\n    return tmp\n\ndef main():\n    n = int(input())\n    robots = [list(map(int, input().split())) for _ in range(n)]\n    G = [[] for _ in range(n)]\n    robots.sort(key=lambda x: x[0])\n    fs = [True]*n\n    q = 0\n    while q < n:\n        if fs[q]:\n            fs[q] = False\n            init(G, robots, fs, q)\n        else:\n            q += 1\n    fs = [True]*n\n    ans = 1\n    for i in range(n):\n        if fs[i]:\n            ans *= calc(G, i, fs)\n            ans %= MOD\n    print(ans % MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u89e3\u8aac\u653e\u9001\n# https://atcoder.jp/contests/abc158/submissions/10643692\n# dfs\u306e\u4ee3\u308f\u308a\u306b\u89aa\u306e\u9802\u70b9\u756a\u53f7\u3092\u914d\u5217\u3067\u7ba1\u7406\u3059\u308b\u65b9\u6cd5\n# PyPy\u3067\u306f\u901a\u3063\u305f\n\ndef main():\n    from collections import deque, namedtuple\n    from operator import attrgetter\n    import sys\n    input = sys.stdin.readline\n\n    MOD = 998244353\n\n    Robot = namedtuple('Robot', 'x d reach ind')\n\n    N = int(input())\n\n    robots = []\n    for ind in range(N):\n        X, D = list(map(int, input().split()))\n        robots.append(Robot(X, D, X + D, ind))\n    robots.sort(key=attrgetter('x'), reverse=True)\n\n    parents = [-1] * N\n    to_candidates = deque()\n    for robot_from in robots:  # x\u964d\u9806\n        \"\"\"\n        \u53f3\u7aef\u306b\u4f4d\u7f6e\u3059\u308b\u30ed\u30dc\u30c3\u30c8\u304b\u3089\u9806\u306b\u300c\u8d77\u70b9\u300d\u3068\u898b\u306a\u3057\u3066\u3044\u304f\n        \u65e2\u51fa\u306e\u30ed\u30dc\u30c3\u30c8\u3067\u6709\u5411\u8fba\u306e\u884c\u304d\u5148\u3068\u3057\u3066\u4e00\u5ea6\u3082\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u306a\u3044\u3082\u306e\u304c\n        to_candidates\u306bx\u6607\u9806\u3067\u6e9c\u3081\u3089\u308c\u3066\u3044\u308b\n        to_candidates\u306b\u542b\u307e\u308c\u308b\u30ed\u30dc\u30c3\u30c8\u3067\u300c\u8d77\u70b9\u300d\u304b\u3089\u63a5\u89e6\u7bc4\u56f2\u5185\u306e\u3082\u306e\u304c\u3042\u308b\u9650\u308a\u3001\n        \u300c\u8d77\u70b9\u300d\u304b\u3089\u6709\u5411\u8fba\u3092\u5f35\u308a\u7d9a\u3051\u308b\n        to_candidates\u306e\u5148\u982d\u5019\u88dc(\u6700\u3082\u5de6\u5074\u306b\u4f4d\u7f6e\u3059\u308b)\u306b\u5bfe\u3057\u3066\u8fba\u3092\u5f35\u308c\u306a\u3044\u5834\u5408\u3001\n        \u305d\u308c\u4ee5\u964d\u306e\u5019\u88dc\u306ex\u306f\u3088\u308a\u9060\u3044\u5ea7\u6a19\u3067\u8fba\u3092\u5f35\u308c\u306a\u3044\u306e\u3067\n        \u300c\u8d77\u70b9\u300d\u304b\u3089\u5f35\u308c\u308b\u8fba\u304c\u306a\u3044\u3068\u308f\u304b\u308b\n        \u3059\u3079\u3066\u306e\u30ed\u30dc\u30c3\u30c8\u306f\u300c\u8d77\u70b9\u300d\u304b\u3089\u8fba\u3092\u5f35\u3089\u308c\u3066to_candidates\u304b\u3089\u5916\u308c\u308b\u304b\n        to_candidates\u306b\u6b8b\u308a\u3001\u30b0\u30e9\u30d5(\u68ee)\u306e\u5404\u6728\u306eroot\u3068\u306a\u308b\n        \"\"\"\n        while to_candidates:\n            robot_to = to_candidates[0]\n            if robot_to.x < robot_from.reach:\n                parents[robot_to.ind] = robot_from.ind\n                to_candidates.popleft()\n            else:\n                break\n\n        to_candidates.appendleft(robot_from)\n\n    ret = 1\n    count = [1] * N\n    for robot in robots:  # x\u964d\u9806\n        par = parents[robot.ind]\n        count[robot.ind] += 1\n        if ~par:\n            count[par] = (count[par] * count[robot.ind]) % MOD\n        else:\n            ret = (ret * count[robot.ind]) % MOD\n            # x\u964d\u9806\u3067\u898b\u3066\u3044\u308b\u306e\u3067par==-1\u306eroot\u306erobot\u3092\u898b\u308b\u9803\u306b\u306f\n            # root\u306e\u5b50\u306f\u5168\u3066\u898b\u3066\u3044\u308b\u306e\u3067\u5b89\u5fc3\u3057\u3066ret\u306b\u304b\u3051\u3089\u308c\u308b\n    print(ret)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    MOD = 998244353\n\n    N = int(input())\n    XDs = [tuple(map(int, input().split())) for _ in range(N)] + [(10**12, 0)]\n\n    XDs.sort()\n    Xs = [X for X, D in XDs]\n\n    stack = [N]\n    dp = [0] * (N+1)\n    dp[-1] = 1\n    for i in reversed(list(range(N))):\n        X, D = XDs[i]\n        while Xs[stack[-1]] < X+D:\n            stack.pop()\n        dp[i] = dp[stack[-1]] + dp[i+1]\n        dp[i] %= MOD\n        stack.append(i)\n\n    print((dp[0]))\n\n\nsolve()\n", "from bisect import bisect\nfrom itertools import accumulate\nfrom functools import reduce\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10000000)\n\nMOD = 998244353\n\ndef solve(robots):\n    N = len(robots)\n    robots.sort()\n\n    parent = [None]*(N+1)\n\n    stack = [(float('inf'),0)]\n    for i,(x,d) in enumerate(robots,start=1):\n        d += x\n        while stack[-1][0] <= x:\n            stack.pop()\n        parent[i] = stack[-1][1]\n        while stack[-1][0] <= d:\n            stack.pop()\n        stack.append((d,i))\n\n    dp = [1]*(N+1)\n    for i in reversed(range(1,N+1)):\n        p = parent[i]\n        dp[p] *= dp[i]+1\n        dp[p] %= MOD\n    return dp[0]\n\ndef __starting_point():\n    N = int(input())\n    robots = [tuple(map(int,input().split())) for _ in range(N)]\n    print(solve(robots))\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nfrom heapq import heappush, heappop\nfrom collections import Counter\nclass HeapSet:\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        #heappush(self.maxQue, -x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\nMOD = 998244353\ndef resolve():\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res +1\n\n    N = int(input())\n    AB = [tuple(map(int, input().split())) for _ in range(N)]\n    AB.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    # tree\u3092\u4f5c\u6210\n    for i in range(N-1, -1, -1):\n        x = AB[i][0] # \u521d\u671f\u4f4d\u7f6e\n        d = AB[i][1] # \u79fb\u52d5\u8ddd\u96e2\n\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x,i)) # \u521d\u671f\u4f4d\u7f6e\u3001\u9802\u70b9\u756a\u53f7\n\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "# hmm...\nfrom sys import setrecursionlimit\nsetrecursionlimit(10000000)\n\nn = int(input())\nxds = [tuple(map(int, input().split())) for _ in range(n)]\nxds.sort()\n\nxds.insert(0, (-1000000001, 2000000004))\nn += 1\n\ndef make_blocks(i):\n    x, d = xds[i]\n    right = x + d\n    res = []\n    nexti = i + 1\n    while(nexti < n):\n        xn, dn = xds[nexti]\n        if xn < right:\n            l, lasti = make_blocks(nexti)\n            res.append(l)\n            nexti = lasti + 1\n        else:\n            return res, nexti - 1\n    return res, n - 1\n\nl, _ = make_blocks(0)\n\ndef count(l):\n    ans = 1\n    for ll in l:\n        ans = ans * (1 + count(ll)) % 998244353\n    return ans\n\nprint((count(l)))\n", "\nM = 998244353\n\nn = int(input())\nxs = [0] * n\nds = [0] * n\nfor i in range(n):\n    x, d = (int(c) for c in input().split())\n    ds[i] = d\n    xs[i] = (x,i)\n\nimport sys\nsys.setrecursionlimit(max(1000,n))\n\nxs.sort()\nindex = [x[1] for x in xs]\nxs = [x[0] for x in xs]\nds = [ds[ind] for ind in index]\n\ndef _sub(i):\n    # \u6df1\u3055\u512a\u5148\u63a2\u7d22\u3057\u306a\u304c\u3089i\u756a\u76ee\u4ee5\u4e0b\u306e\u7d44\u307f\u5408\u308f\u305b\u3068\u3001\u6b21\u306b\u8abf\u3079\u308b\u3079\u304d\u756a\u53f7\u3092\u8fd4\u3059\n    if i==n-1:\n        return 2, n\n    res = 1\n    ind = i+1\n    while True:\n        if (xs[i]+ds[i] <= xs[ind]):\n            break\n        o, ind = _sub(ind)\n        res *= o\n        res %= M\n        if ind>=n:\n            break\n    return res+1, ind\nout = []\ndone = 0\nwhile True:\n    o, done = _sub(done)\n    out.append(o)\n    if done>=n:\n        break\nresult = 1\nfor o in out:\n    result *= o\n    result %= M\nprint(result)", "def main():\n    mod = 998244353\n    n = int(input())\n    ab = sorted([tuple(map(int, input().split())) for _ in [0]*n])\n    next_idx = [-1]*n\n    for i in range(n-1, -1, -1):\n        dist = sum(ab[i])\n        now = i\n        while now < n-1:\n            a1, b1 = ab[now+1]\n            if a1 < dist:\n                now = next_idx[now+1]\n            else:\n                break\n        next_idx[i] = now\n    dp = [0]*(n+1)\n    dp[n] = 1\n    for i in range(n-1, -1, -1):\n        dp[i] = (dp[i+1]+dp[next_idx[i]+1]) % mod\n    print(dp[0])\n\n\nmain()"]
["def modgroup(M = 10**9+7, invn = 0) :\n\texec(f'''class mod{M} :\n\tinv = [None] * {invn}\n\tif {invn} >= 2 : inv[1] = 1\n\tfor i in range(2, {invn}) : inv[i] = (({M}-{M}//i)*inv[{M}%i])%{M}\n\tdef __init__(self, n = 0) : self.n = n % {M}\n\t__repr__ = lambda self : str(self.n) + '%{M}'\n\t__int__ = lambda self : self.n\n\t__eq__ = lambda a,b : a.n == b.n\n\t__add__ = lambda a,b : __class__(a.n + b.n)\n\t__sub__ = lambda a,b : __class__(a.n - b.n)\n\t__mul__ = lambda a,b : __class__(a.n * b.n)\n\t__pow__ = lambda a,b : __class__(pow(a.n, b.n, {M}))\n\t__truediv__ = lambda a,b : __class__(a.n * pow(b.n, {M-2}, {M}))\n\t__floordiv__ = lambda a,b : __class__(a.n * __class__.inv[b.n])\n\t''')\n\treturn eval(f'mod{M}')\ndef solution() :\n\ts = input()\n\tl = len(s)\n\tmod = modgroup()\n\tnum = [mod(0)] * (l+1) # num[i] = int(s[:i]) <mod>\n\tshift = [mod(1)] * (l+1) # shift[i] = 10**i <mod>\n\tfor i,x in enumerate(s, 1) :\n\t\tnum[i] = num[i-1] * mod(10) + mod(int(x))\n\t\tshift[i] = shift[i-1] * mod(10)\n\tdef mod_check(la, lb, lc) :\n\t\ta,b,c = num[la], num[la+lb], num[la+lb+lc]\n\t\tc -= b * shift[lc]\n\t\tb -= a * shift[lb]\n\t\treturn a + b == c\n\tfor lc in range(l//3+bool(l%3), l//2+1) :\n\t\tfor lb in (lc, lc-1, l-lc*2, l-lc*2+1) :\n\t\t\tla = l - lc - lb\n\t\t\tif la < 1 or lb < 1 or lc < 1 : continue\n\t\t\tif la > lc or lb > lc : continue\n\t\t\tif not mod_check(la, lb, lc) : continue\n\t\t\ta,b,c = s[:la], s[la:la+lb], s[la+lb:la+lb+lc]\n\t\t\tprint(f'{a}+{b}={c}'); return\nsolution()", "def modgroup(M = 10**9+7, invn = 0) :\n\texec(f'''class mod{M} :\n\tinv = [None] * {invn}\n\tif {invn} >= 2 : inv[1] = 1\n\tfor i in range(2, {invn}) : inv[i] = (({M}-{M}//i)*inv[{M}%i])%{M}\n\tdef __init__(self, n = 0) : self.n = n % {M}\n\t__repr__ = lambda self : str(self.n) + '%{M}'\n\t__int__ = lambda self : self.n\n\t__eq__ = lambda a,b : a.n == b.n\n\t__add__ = lambda a,b : __class__(a.n + b.n)\n\t__sub__ = lambda a,b : __class__(a.n - b.n)\n\t__mul__ = lambda a,b : __class__(a.n * b.n)\n\t__pow__ = lambda a,b : __class__(pow(a.n, b.n, {M}))\n\t__truediv__ = lambda a,b : __class__(a.n * pow(b.n, {M-2}, {M}))\n\t__floordiv__ = lambda a,b : __class__(a.n * __class__.inv[b.n])\n\t''')\n\treturn eval(f'mod{M}')\ndef solution() :\n\ts = input()\n\tl = len(s)\n\tmod = modgroup()\n\tnum = [mod(0)] * (l+1) # num[i] = int(s[:i]) <mod>\n\tshift = [mod(1)] * (l+1) # shift[i] = 10**i <mod>\n\tfor i,x in enumerate(s, 1) :\n\t\tnum[i] = num[i-1] * mod(10) + mod(int(x))\n\t\tshift[i] = shift[i-1] * mod(10)\n\tdef mod_check(la, lb, lc) :\n\t\ta,b,c = num[la], num[la+lb], num[la+lb+lc]\n\t\tc -= b * shift[lc]\n\t\tb -= a * shift[lb]\n\t\treturn a + b == c\n\tfor lc in range(l//3+bool(l%3), l//2+1) :\n\t\tfor lb in (lc, lc-1, l-lc*2, l-lc*2+1) :\n\t\t\tla = l - lc - lb\n\t\t\tif la < 1 or lb < 1 or lc < 1 : continue\n\t\t\tif la > lc or lb > lc : continue\n\t\t\tif not mod_check(la, lb, lc) : continue\n\t\t\tprint(f'{s[:la]}+{s[la:la+lb]}={s[la+lb:la+lb+lc]}')\n\t\t\treturn\nsolution()", "def modgroup(M = 10**9+7, invn = 0) :\n\texec(f'''class mod{M} :\n\tinv = [None] * {invn+1}\n\tif {invn+1} >= 2 : inv[1] = 1\n\tfor i in range(2, {invn+1}) :\n\t\tinv[i] = (({M} - {M}//i) * inv[{M}%i]) %{M}\n\tdef __init__(self, n = 0) : self.n = n % {M}\n\t__repr__ = lambda self : str(self.n) + '%{M}'\n\t__int__ = lambda self : self.n\n\t__eq__ = lambda a,b : int(a)%{M} == int(b)%{M}\n\t__add__ = lambda a,b : __class__(a.n + int(b))\n\t__sub__ = lambda a,b : __class__(a.n - int(b))\n\t__mul__ = lambda a,b : __class__(a.n * int(b))\n\t__radd__ = lambda a,b : __class__(b + a.n)\n\t__rsub__ = lambda a,b : __class__(b - a.n)\n\t__rmul__ = lambda a,b : __class__(b * a.n)\n\tdef __pow__(a,b) :\n\t\ta, ret = int(a), 1\n\t\twhile b :\n\t\t\tif b & 1 : ret = (ret * a) % {M}\n\t\t\ta = (a * a) % {M}\n\t\t\tb >>= 1\n\t\treturn __class__(ret)\n\tdef __truediv__(a,b) :\n\t\treturn __class__(a.n * __class__.__pow__(b, {M-2}))\n\tdef __floordiv__(a,b) :\n\t\treturn __class__(a.n * __class__.inv[b])\n\t''')\n\treturn eval(f'mod{M}')\ndef solution() :\n\ts = input()\n\tl = len(s)\n\tmod = modgroup()\n\tnum = [mod(0)] * (l+1) # num[i] = int(s[:i]) <mod>\n\tshift = [mod(1)] * (l+1) # shift[i] = 10**i <mod>\n\tfor i,x in enumerate(s, 1) :\n\t\tnum[i] = num[i-1] * 10 + int(x)\n\t\tshift[i] = shift[i-1] * 10\n\tdef mod_check(la, lb, lc) :\n\t\ta,b,c = num[la], num[la+lb], num[la+lb+lc]\n\t\tc -= b * shift[lc]\n\t\tb -= a * shift[lb]\n\t\treturn a + b == c\n\tfor lc in range(l//3+bool(l%3), l//2+1) :\n\t\tfor lb in (lc, lc-1, l-lc*2, l-lc*2+1) :\n\t\t\tla = l - lc - lb\n\t\t\tif la < 1 or lb < 1 or lc < 1 : continue\n\t\t\tif la > lc or lb > lc : continue\n\t\t\tif not mod_check(la, lb, lc) : continue\n\t\t\tprint(f'{s[:la]}+{s[la:la+lb]}={s[la+lb:la+lb+lc]}')\n\t\t\treturn\nsolution()"]
["def f(n):\n    Ans = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            Ans.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        Ans.append(n)\n    return Ans\n\n\nn, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nm = {}\nc = 0\nfor i in arr:\n    r = {}\n    d = 2\n    while d * d <= i:\n        if i % d == 0:\n            r[d] = (r.get(d, 0) + 1) % k\n            i //= d\n        else:\n            d += 1\n    if i > 1:\n        r[i] = (r.get(i, 0) + 1) % k\n    r = tuple([x for x in list(r.items()) if x[1]])\n    r2 = tuple([(x[0], k - x[1]) for x in r])\n    c += m.get(r2, 0)\n    m[r] = m.get(r, 0) + 1\nprint(c)\n", "from collections import defaultdict\nimport math\nn,k = list(map(int,input().split()))\na = list(map(int,input().split()))\n\nans = 0\nhm = defaultdict(int)\n\nfor i in range(n):\n    x = 2\n    t = []\n    t1 = []\n    y = a[i]\n    while x<=math.sqrt(a[i]):\n        if a[i]%x==0:\n            c = 0\n            while y%x==0:\n                y = y//x\n                c += 1\n            if c%k>0:\n                t.append((x,c%k))\n                t1.append((x,k-(c%k)))\n        x += 1\n    if y>1:\n        t.append((y,1%k))\n        t1.append((y,k-(1%k)))\n\n    ans += hm[tuple(t1)]\n    hm[tuple(t)] += 1\n\nprint(ans)\n        \n", "from collections import defaultdict\n\ntotal = 0 \nimport math\ndic = defaultdict(int)\nn, k = list(map(int, input().split()))\nz = list(map(int, input().split()))\nfor ii in z:\n\n    i = ii\n    x = []\n    x2=[]\n    a = 2\n    while a<=math.sqrt(ii):\n        co = 0\n        while i % a == 0:\n            i = i//a\n            co += 1\n        co=co%k\n        if co:\n            x.append((a, co))\n            x2.append((a, k-co))\n        a += 1\n    if i>1:\n        x.append((i,1))\n        x2.append((i,k-1))\n    # print(i)\n    # print(x)\n    # print(dic)\n    dic[tuple(x)] += 1\n    total += dic[tuple(x2)]\n        # print(f\"ans:{x} and {inver(x)}\")\n    if(x2 == x):\n        total-=1\n\n\n\n# print(x)\nprint(total)\n", "n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\nans=0\nd={}\nfor i in range(n):\n\tx=2\n\ta=[]\n\tb=[]\n\ty=arr[i]\n\twhile x*x<=arr[i]:\n\t\tif arr[i]%x==0:\n\t\t\tc=0\n\t\t\twhile y%x==0:\n\t\t\t\ty=y//x\n\t\t\t\tc+=1\n\t\t\tif c%k>0:\n\t\t\t\ta.append((x,c%k))\n\t\t\t\tb.append((x,k-(c%k)))\n\t\tx+=1\n\tif y>1:\n\t\ta.append((y,1%k))\n\t\tb.append((y,k-(1%k)))\n\ttry:\n\t\tans+=d[tuple(b)]\n\texcept:\n\t\tpass\n\ttry:\n\t\td[tuple(a)]+=1\n\texcept:\n\t\td[tuple(a)]=1\nprint(ans)\n", "n, k = map(int, input().split())\n*a, = map(int, input().split())\nd = {}\nans = 0\nfor i in a:\n    x, j, tmp1, tmp2 = i, 2, [], []\n    while j * j <= i:\n        c = 0\n        while x % j == 0:\n            c += 1\n            x //= j\n        if c % k:\n            tmp2.append((j, k - c % k))\n            tmp1.append((j, c % k))\n        j += 1\n    if x > 1:\n        tmp1.append((x, 1))\n        tmp2.append((x, k - 1))\n    tmp1, tmp2 = tuple(tmp1), tuple(tmp2)\n    ans += d.get(tmp2, 0)\n    d[tmp1] = d.get(tmp1, 0) + 1\nprint(ans)", "import math\nfrom collections import Counter\n \nn, k = map(int, input().split())\na = list(map(int, input().split()))\n \nans = 0\nprev = Counter()\nfor x in a:\n\tsig = []\n\tp = 2\n\twhile p <= math.sqrt(x):\n\t\tcnt = 0\n\t\twhile x % p == 0:\n\t\t\tcnt += 1\n\t\t\tx = x // p\n \n\t\tcnt = cnt % k\n\t\tif cnt > 0:\n\t\t\tsig.append((p, cnt))\n \n\t\tp += 1\n \n\tif x > 1:\n\t\tsig.append((x, 1))\n \n\tcom_sig = []\n\tfor p, val in sig:\n\t\tcom_sig.append((p, (k - val) % k))\n \n\tans += prev[tuple(sig)]\n\tprev[tuple(com_sig)] += 1\n \nprint(ans)", "n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\nd = {}\nans = 0\n\nfor el in a:\n    i = 2\n    a = []\n    b = []\n    while i*i <= el:\n        cnt = 0\n        while not(el%i):\n            el //= i\n            cnt += 1\n        if cnt%k:\n            a.append((i, cnt%k))\n            b.append((i, k-(cnt%k)))\n        i += 1\n    \n    if el > 1:\n        a.append((el, 1))\n        b.append((el, k-1))\n\n    a = tuple(a)\n    b = tuple(b)\n\n    ans += d.get(b, 0)\n    d[a] = d.get(a, 0)+1\n    \nprint(ans)\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/11/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\nimport math\n\n\ndef factors(val):\n    wc = []\n    for i in range(2, int(math.sqrt(val)) + 2):\n        if i > val:\n            break\n        if val % i == 0:\n            c = 0\n            while val % i == 0:\n                c += 1\n                val //= i\n            wc.append((i, c))\n    if val > 1:\n        wc.append((val, 1))\n    return wc\n\n\ndef expand(fc, maxd, k):\n    def dfs(index, mul):\n        if index >= len(fc):\n            return [mul]\n        \n        w, c = fc[index]\n        d = k - (c % k) if c % k != 0 else 0\n        x = []\n        t = mul * (w ** d)\n        while t <= maxd:\n            x.extend(dfs(index + 1, t))\n            d += k\n            t *= w**k\n        \n        return x\n        \n    return dfs(0, 1)\n    \ndef solve(N, K, A):\n    wc = collections.defaultdict(int)\n    ans = 0\n    for v in A:\n        fc = factors(v)\n        fc = [(f, c % K) for f, c in fc if c % K != 0]\n        key = '_'.join(['{}+{}'.format(f, c) for f, c in fc])\n        cov = [(f, K-c) for f, c in fc]\n        ckey = '_'.join(['{}+{}'.format(f, c) for f, c in cov])\n        ans += wc[ckey]\n        wc[key] += 1\n\n    return ans\n    \nN, K = map(int, input().split())\nA = [int(x) for x in input().split()]\nprint(solve(N, K, A))", "from math import *\n\nn, k = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nma = max(a)\n\np = []\nprime = [True] * (ma + 1)\nprime[0] = False\nprime[1] = False\nfor i in range(2, ma + 1):\n    if prime[i]:\n        p.append(i)\n        if i**2 <= n:\n            for j in range(i**2, ma + 1, i):\n                prime[j] = False\n\n\ndef factor(x):\n    res = {}\n    sq = ceil(sqrt(x))\n    for i in p:\n        if i > sq or x <= 1:\n            break\n        if x % i == 0:\n            res[i] = 0\n            while x % i == 0:\n                res[i] += 1\n                x //= i\n    if x > 1:\n        res[x] = 1\n    nres = []\n    for j in res:\n        if res[j] % k > 0:\n            nres.append((j, res[j] % k))\n    \n    return tuple(nres)\n\nd = {}\nfor i in range(n):\n    f = factor(a[i])\n    #print(f, a[i])\n    if f not in d:\n        d[f] = 1\n    else:\n        d[f] += 1\n        \nans = 0\n#print(d)\nfor x in d:\n    y = []\n    for i in x:\n        y.append((i[0], k - i[1]))\n    y = tuple(y)\n    if y in d:\n        if y != x:\n            ans += d[x] * d[y]\n        else:\n            ans += d[x] * (d[y] - 1)\n    #print(x, y, ans)\n\nprint(ans//2)\n", "from collections import defaultdict\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nn = int(max(a)**.5)\nmark = [True]*(n+1)\nprimes = []\nfor i in range(2,n+1):\n\tif mark[i]:\n\t\tprimes.append(i)\n\t\tfor j in range(i, n+1, i): mark[j] = False\ndel mark\nd = defaultdict(int)\nans = 0\n\nfor i in a:\n\tt, t1 = (), ()\n\tfor j in primes:\n\t\tif i == 1:break\n\t\telif i%j == 0:\n\t\t\tx = 0\n\t\t\twhile i%j==0: \n\t\t\t\ti//=j\n\t\t\t\tx += 1\n\t\t\tz = x%k\n\t\t\tif z:\n\t\t\t\tt += (j,z)\n\t\t\t\tt1 += (j,k-z)\n\tif i != 1:\n\t\tt += (i,1)\n\t\tt1 += (i,k-1)\n\n\tans += d[t1]\n\td[t] += 1\nprint(ans)", "from collections import defaultdict\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nn = int(max(a)**.5)\nmark = [True]*(n+1)\nprimes = []\nfor i in range(2,n+1):\n\tif mark[i]:\n\t\tprimes.append(i)\n\t\tfor j in range(i, n+1, i): mark[j] = False\nd = defaultdict(int)\nans = 0\n\nfor i in a:\n\tt, t1 = (), ()\n\tfor j in primes:\n\t\tif i == 1:break\n\t\telif i%j == 0:\n\t\t\tx = 0\n\t\t\twhile i%j==0: \n\t\t\t\ti//=j\n\t\t\t\tx += 1\n\t\t\tz = x%k\n\t\t\tif z:\n\t\t\t\tt += (j,z)\n\t\t\t\tt1 += (j,k-z)\n\tif i != 1:\n\t\tt += (i,1)\n\t\tt1 += (i,k-1)\n\n\tans += d[t1]\n\td[t] += 1\nprint(ans)", "from collections import defaultdict\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nn = int(max(a)**.5)\nmark = [True]*(n+1)\nprimes = []\nfor i in range(2,n+1):\n\tif mark[i]:\n\t\tprimes.append(i)\n\t\tfor j in range(i, n+1, i): mark[j] = False\n\nd = defaultdict(int)\n\nans = 0\nfor i in a:\n\tt, t1 = [], []\n\tfor j in primes:\n\t\tif i%j == 0:\n\t\t\tx = 0\n\t\t\twhile i%j==0: \n\t\t\t\ti//=j\n\t\t\t\tx += 1\n\t\t\tz = x%k\n\t\t\tif z:\n\t\t\t\tt.append((j,z))\n\t\t\t\tt1.append((j,k-z))\n\t\telif i == 1:break\n\tif i != 1:\n\t\tt.append((i,1))\n\t\tt1.append((i,k-1))\n\n\tt = tuple(t)\n\tt1 = tuple(t1)\n\n\tans += d[t1]\n\td[t] += 1\nprint(ans)", "import math\n\n\ndef fac(a):\n    ans = {}\n\n    for i in range(2, int(math.sqrt(a)) + 1):\n        if a % i == 0:\n            ans[i] = 0\n            while a % i == 0:\n                a //= i\n                ans[i] += 1\n\n    ans[a] = 1\n\n    return ans\n\n\ndef inverse(a, k):\n    buf = {}\n\n    for j in a.keys():\n        buf[j] = (k - a[j] % k) % k\n\n    return buf\n\n\ndef normal(a, k):\n    buf = {}\n\n    for j in a.keys():\n        buf[j] = a[j] % k\n\n    return buf\n\n\ndef getHash(d):\n    ans = 1\n    for i in d.keys():\n        ans *= i ** d[i]\n    return ans\n\n\nn, k = map(int, input().split(' '))\n\na = [i for i in map(int, input().split(' '))]\n\nb = [i for i in map(fac, a)]\n\nfactors = {}\n\nfor i in b:\n    buf = getHash(inverse(i, k))\n    if buf in factors.keys():\n        factors[buf] += 1\n    else:\n        factors[buf] = 1\n\nans = 0\n\nfor i in range(len(b)):\n    b[i] = normal(b[i], k)\n    if getHash(b[i]) == getHash(inverse(b[i], k)):\n        ans -= 1\n\nfor i in map(getHash, b):\n    if i in factors.keys():\n        ans += factors[i]\n\nprint(ans // 2)", "import sys\ninput =  lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n\ndef factors(n, k):\n    i = 2\n    sq = int(n**0.5)+1\n    di={}\n    while n != 1:\n        if n % i == 0:\n            cur = 0\n            while n % i == 0:\n                n = n // i\n                cur += 1\n            if cur % k != 0:\n                di[i] = cur % k\n        i += 1\n        if i > sq:break\n    if n != 1:\n        di[n] = 1\n    return \"|\".join(\"%d:%d\" % (i, di[i]) for i in di)\n\nft = {}\ndi = {}\n\nfor i in a:\n    ft[i] = factors(i, k)\n    di[ft[i]] = 1 if ft[i] not in di else di[ft[i]] + 1\n\nans = 0\nfor i in a:\n    ftt = ft[i]\n    if ftt == \"\":\n        ans += di[ftt] - 1\n    else:\n        dx = {}\n        for oo in ftt.split(\"|\"):\n            x, y = map(int, oo.split(\":\"))\n            dx[x] = - y % k\n        ftt2 = \"|\".join(\"%d:%d\" % (i, dx[i]) for i in dx)\n        if ftt == ftt2:\n            ans += di[ftt2] - 1\n        else:\n            if ftt2 in di:\n                ans += di[ftt2]\n\nprint(ans//2)", "from collections import defaultdict as dc\ndic=dc(lambda:0)\nx,y=list(map(int,input().split()))\ns=list(map(int,input().split()))\nsiv=[0]*(max(s)+1)\nln=len(siv)\nsiv[1]=1;\n\nfor n in range(2,ln):\n    if siv[n]==0:\n        siv[n]=n\n        for k in range(2*n,ln,n):\n            if siv[k]==0:\n                siv[k]=n\n\ndef prf(x):\n    dic=dc(lambda:0)\n    while x>1:\n        d=siv[x]\n        dic[siv[x]]+=1\n        x//=siv[x]\n    \n    return dic\n\ndef req(dic,k):\n    cur=dic\n    for n in cur:\n        cur[n]%=k\n    for n in cur:\n        cur[n]=(k-cur[n])%k\n    tot=1\n    for n in cur:\n        tot*=(n**cur[n])\n    return tot\n\ndef conv(x,k):\n    dicc=prf(x)\n    for n in dicc:\n        dicc[n]%=k\n    tot=1\n    for n in dicc:\n        tot*=(n**dicc[n])\n\n    return tot\n\nres=0\nfor n in s:\n    re=req(prf(n),y)\n    res+=dic[re]\n    dic[conv(n,y)]+=1\n\nprint(res)\n", "from math import sqrt\ndef gd(n, k):\n    ans = 1\n    obrans = 1\n    for i in range(2, int(sqrt(n) + 1)):\n        j = 0\n        while n % i == 0:\n            j += 1\n            n //= i\n        ans *= pow(i, j%k)\n        obrans *= pow(i, (-j)%k)\n    ans *= n\n    obrans *= pow(n, (k-1))\n    return ans, obrans\nn, k = map(int,input().split())\noba = set()\ndct = {}\nfor i in list(map(int,input().split())):\n    a,b = gd(i, k)\n    dct[a] = dct.get(a, 0) + 1\n    a,b = min(a,b), max(a,b)\n    oba.add((a,b))\nans = 0\nfor i, j in oba:\n    if i == j:\n        ans += (dct.get(i, 0)  * dct.get(j, 0) - dct.get(i, 0)) // 2\n    else:\n        ans += dct.get(i, 0) * dct.get(j, 0)\nprint(ans)", "import itertools as it\nfrom collections import defaultdict\nimport os\nimport sys\n\n\ndef sieve(n):\n    is_prime = [True] * n\n\n    for candidate in it.chain([2], list(range(3, int(n ** 0.5) + 1, 2))):\n        if is_prime[candidate]:\n            for k in range(2 * candidate, n, candidate):\n                is_prime[k] = False\n\n    primes = [idx for idx, k in enumerate(is_prime) if idx >= 2 and k]\n    return primes\n\n\ndef factorize(n, primes, k):\n    factors = []\n    number = n\n    for f in primes:\n        count = 0\n        while number % f == 0:\n            count += 1\n            number //= f\n\n        if count % k:\n            factors.append((f, count % k))\n\n        if f > number:\n            break\n\n    if number > 1:\n        factors.append((number, 1))\n\n    return tuple(factors)\n\n\ndef solve(arr, k):\n    total = 0\n    d = defaultdict(int, {})\n    primes = sieve(int(1e5 ** 0.5) + 10)\n    for a in arr:\n        fac = factorize(a, primes, k)\n        fac_complement = tuple((f, k - count) for f, count in fac)\n        total += d[fac_complement]\n        d[fac] += 1\n\n    return total\n\n\ndef pp(input):\n    # T = int(input())\n    # for t in range(T):\n    n, k = list(map(int, input().strip().split()))\n    arr = list(map(int, input().strip().split()))\n    print(solve(arr, k))\n\n\nif \"paalto\" in os.getcwd():\n    from string_source import string_source, codeforces_parse\n\n    pp(\n        string_source(\n            \"\"\"6 3\n1 3 9 8 24 1\"\"\"\n        )\n    )\nelse:\n    pp(sys.stdin.readline)\n", "from collections import defaultdict\nimport sys as _sys\n\n\ndef main():\n    n, k = _read_ints()\n    a = tuple(_read_ints())\n    result = find_good_pairs_n(a, k)\n    print(result)\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split()))\n\n\ndef find_good_pairs_n(sequence, k):\n    sequence = tuple(sequence)\n    factors_seq = tuple(map(_find_prime_factors, sequence))\n    \n    factors_seq = [[(kv[0], kv[1] % k) for kv in list(factors.items())] for factors in factors_seq]\n    factors_seq = [[kv for kv in factors if kv[1] > 0] for factors in factors_seq]\n    factors_seq = list(map(sorted, factors_seq))\n    factors_seq = tuple(map(tuple, factors_seq))\n    \n    counter = defaultdict(int)\n    for factors in factors_seq:\n        counter[factors] += 1\n    \n    result = 0\n    for factors in factors_seq:\n        necessary_factors = tuple((factor, k - amount) for factor, amount in factors)\n        result += counter[necessary_factors]\n        if factors == necessary_factors:\n            result -= 1\n    \n    assert result % 2 == 0\n    result //= 2\n    return result\n\n\ndef _find_prime_factors(x):\n    result = dict()\n    \n    if x % 2 == 0:\n        factor_2_n = 0\n        while x & 1 == 0:\n            x >>= 1\n            factor_2_n += 1\n        result[2] = factor_2_n\n    \n    factor = 3\n    while x != 1 and factor * factor <= x:\n        if x % factor == 0:\n            factor_n = 0\n            while x % factor == 0:\n                x //= factor\n                factor_n += 1\n            result[factor] = factor_n\n        factor += 2\n\n    if x != 1:\n        result[x] = 1\n\n    return result\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\n\nclass Primes():\n    def __init__(self, N):\n        self.N = N\n        self.prime = {i for i in range(2, self.N+1)}\n        self.spf = [-1]*(N + 1)\n        for i in range(2, self.N+1):\n            if i in self.prime:\n                self.spf[i] = i\n                for j in range(i*2, self.N+1, i):\n                    if j in self.prime:\n                        self.spf[j] = i\n                        self.prime.remove(j)\n\n    def fact(self,Number):\n        v = Number\n        d = defaultdict(int)\n        while v > 1:\n            x = self.spf[v]\n            d[x] += 1\n            v//=x\n        return d\n\n\nP = Primes(10**5)\n\nn,k = list(map(int,input().split()))\na = list(map(int,input().split()))\ncnt = [0]*(10**5 + 1)\nfor v in a:\n    cnt[v] += 1\n\nans = 0\nfor v in a:\n    cnt[v] -= 1\n    d = P.fact(v)\n    res = 1\n    for num,order in list(d.items()):\n        res *= pow(num,(k-order%k)%k)\n    if res <= 10**5:\n        for i in range(1,1000):\n            if pow(i,k)*res > 10**5:\n                break\n            ans += cnt[pow(i,k)*res]\nprint(ans)\n\n\n\n"]
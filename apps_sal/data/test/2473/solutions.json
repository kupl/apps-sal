["n,k=map(int,input().split())\npoints=[]\nfor _ in range(n):\n    x,y=map(int,input().split())\n    points.append((x,y))\npoints.sort()\nans=float('inf')\nfor i in range(n-k+1):\n    for j in range(i+k-1,n):\n        y_sorted=sorted(points[i:j+1],key=lambda x:x[1])\n        height_min=float('inf')\n        for l in range(j-i-k+2):\n            height_min=min(height_min,y_sorted[l+k-1][1]-y_sorted[l][1])\n            ans=min(ans,(points[j][0]-points[i][0])*height_min)\nprint(ans)", "# 55:33\nimport numpy as np\n\nN, K, *XY = list(map(int, open(0).read().split()))\n\nX = XY[::2]\ncomp_X = {}\ndecomp_X = {}\nfor i, x in enumerate(sorted(set(X))):\n    comp_X[x] = i\n    decomp_X[i] = x\n\nY = XY[1::2]\ncomp_Y = {}\ndecomp_Y = {}\nfor i, y in enumerate(sorted(set(Y))):\n    comp_Y[y] = i\n    decomp_Y[i] = y\n\nI = len(comp_X)\nJ = len(comp_Y)\ncomp_XY = [(comp_X[x], comp_Y[y]) for x, y in zip(X, Y)]\nacc = np.zeros((I + 1, J + 1), np.int32)\nfor c_x, c_y in comp_XY:\n    acc[c_x + 1][c_y + 1] += 1\nacc = np.add.accumulate(acc, axis=0)\nacc = np.add.accumulate(acc, axis=1)\n\nans = float(\"inf\")\nfor i in range(1, I + 1):\n    for j in range(1, J + 1):\n        cur = acc[i:, j:] + acc[:-i, :-j] - acc[:-i, j:] - acc[i:, :-j]\n        for k, row in enumerate(cur):\n            for l, val in enumerate(row):\n                if val >= K:\n                    ans = min(\n                        ans,\n                        (decomp_X[k + i - 1] - decomp_X[k])\n                        * (decomp_Y[l + j - 1] - decomp_Y[l]),\n                    )\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nINF = 10**20\nMOD = 10**9 + 7\nfrom bisect import insort_left\n\ndef main():\n    n,k = map(int,input().split())\n    XY = [tuple(map(int,input().split())) for _ in range(n)]  \n    XY.sort(key = lambda x:x[0])\n    \n    ans = INF\n    for l in range(n - k + 1):\n        Y = [XY[i][1] for i in range(l,l + k - 1)]\n        Y.sort()\n        dif = -1\n        for r in range(l + k - 1, n):\n            dif += 1\n            insort_left(Y,XY[r][1])\n            w = INF\n            for i in range(dif + 1):\n                w = min(w, Y[i + k - 1] - Y[i])\n            ans = min(ans, w * (XY[r][0] - XY[l][0]))\n    \n    print(ans)   \n\ndef __starting_point():\n    main()\n__starting_point()", "INF = float(\"inf\")\n\nN, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\nans = INF\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        for j in range(k - K + 1):\n            dy = YY[j + K - 1] - YY[j]\n            ans = min(ans, dx * dy)\n\nprint(ans)", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\nXY.sort()\nX, Y = zip(*XY)\nr = 10**20\nfor x0 in range(N - K + 1):\n  for x1 in range(K + x0 - 1, N):\n    x = X[x1] - X[x0]\n    Y_s = sorted(Y[x0:x1 + 1])\n    for y0 in range(len(Y_s) - K + 1):\n      y = Y_s[y0 + K - 1] - Y_s[y0]\n      r = min(r, x * y)\nprint(r)", "INF = float(\"inf\")\n\nN, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\nans = INF\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        for j in range(k - K + 1):\n            dy = YY[j + K - 1] - YY[j]\n            if ans > dx * dy:\n                ans = dx * dy\n\nprint(ans)", "n, k = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(n)]\n\nxy.sort()\n\nans = float(\"inf\")\nfor i in range(n):\n    for j in range(i + k - 1, n):\n        width = xy[j][0] - xy[i][0]\n        y = [e for _, e in xy[i:j+1]]\n        y.sort()\n        for e1, e2 in zip(y, y[k-1:]):\n            height = e2 - e1\n            area = width * height\n            ans = min(ans, area)\n\nprint(ans)\n", "#coding: utf-8\nimport math\nimport heapq\nimport bisect\nimport numpy as np\nfrom collections import Counter\n#from scipy.misc import comb\n\nN,K = map(int, input().split())\nL = [tuple(map(int, input().split())) for i in range(N)]\nL.sort()\n\nans = 10**20\n\nfor lx in range(N):\n    for rx in range(lx+1,N+1):\n        L2 = L[lx:rx]\n        L2 = sorted(L2, key=lambda x:x[1])\n        for ly in range(len(L2)):\n            L3 = L2[ly:ly+K]\n            if len(L3) >= K:\n                ans = min(ans, (L[rx-1][0]-L[lx][0])*(L3[-1][1]-L3[0][1]))\n\nprint(ans)", "# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n\n#n = int(input())\n#n,a = [int(i) for i in readline().split()]\nn,k = [int(i) for i in readline().split()]\nxy = [[int(i) for i in readline().split()] for i in range(n)]\n\nxy.sort()\n#print(xy)\nans = 4*10**18+10\nfor i in range(n):\n    for j in range(i+k-1,n):\n        dx = xy[j][0] - xy[i][0]\n        y = sorted(xy[k][1] for k in range(i,j+1))\n#        print(y,i,j)\n        L = len(y)-k+1\n        for i in range(L):\n            dy = y[i+k-1]-y[i]\n            ans = min(ans,dy*dx)\n        \n\n\nprint(ans)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN, K = MAP()\nxy = [LIST() for _ in range(N)]\nans = INF\n\nxy.sort()\nfor l in range(N-K+1):  #\u9577\u65b9\u5f62\u306e\u6700\u3082\u5de6\u306e\u70b9\n\tfor r in range(l+K, N+1):  #\u9577\u65b9\u5f62\u306e\u6700\u3082\u53f3\u306e\u70b9\n\t\ty = sorted(xy[l:r], key = lambda x: x[1]) #l\u304b\u3089r\u306e\u4e2d\u3067y\u306e\u3068\u308a\u3046\u308b\u5024\u3092\u30bd\u30fc\u30c8\n\t\tfor i in range(r-l-K+1):\n\t\t\tsq = (xy[r-1][0] - xy[l][0])*(y[i+K-1][1] - y[i][1])\n\t\t\tans = min(ans, sq)\nprint(ans)", "def main():\n    n, k, *xy = list(map(int, open(0).read().split()))\n    _x_ = sorted(xy[::2])\n    ans = 4 * 10 ** 18\n    for _x in _x_:\n        for x_ in _x_[1:]:\n            w = x_ - _x\n            c = 0\n            _h_ = []\n            for x, y in zip(xy[::2], xy[1::2]):\n                if _x <= x <= x_:\n                    c += 1\n                    _h_.append(y)\n\n            if c >= k:\n                _h_.sort()\n                h = min(_h_[i + k - 1] - _h_[i] for i in range(c - k + 1))\n                ans = min(ans, h * w)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,h=map(int,input().split())\np,x,y=[],[],[]\nz=float(\"inf\")\nfor i in range(n):\n  a,b=map(int,input().split())\n  p.append((a,b))\n  x.append(a)\n  y.append(b)\nx.sort()\ny.sort()\nfor i in range(n-1):\n  for j in range(i,n):\n    for k in range(n-1):\n      lx,rx,dy=x[i],x[j],y[k]\n      c=0\n      t=[]\n      for a,b in p:\n        if x[i]<=a<=x[j] and y[k]<=b:c+=1;t.append(b)\n      if h<=c:z=min(z,(x[j]-x[i])*(sorted(t)[h-1]-y[k]))\nprint(z)", "N, K = list(map(int, input().split()))\nxy = []\nfor _ in range(N):\n    xy.append(tuple(map(int, input().split())))\n\nxy=sorted(xy, key=lambda x:x[0])\n#print(xy)\n\nlst=[]\nfor left in range(0, N-K+1):\n    for right in range(left+K-1,N):\n        #print(left, right)\n        W = xy[right][0] - xy[left][0]\n        #print(W)\n        temp=sorted(xy[left:right+1], key=lambda x:x[1])\n        #print(temp)\n        #\u542b\u307e\u308c\u308b\u70b9\u306e\u500b\u6570\u306fright-left+1\u500b\n        for bottom in range(0, right-left+1 - K+1):\n            #print('W', W, 'bottom',bottom)\n            H = temp[bottom+K-1][1] - temp[bottom][1]\n            #print('H', H)\n            lst.append(H * W)\n#print('lst',lst)\nprint((min(lst)))\n", "#!/usr/bin/env python3\nfrom itertools import combinations\nimport sys\ntry:\n    from typing import List\nexcept ImportError:\n    pass\n\n\ndef solve(N: int, K: int, x: \"List[int]\", y: \"List[int]\"):\n    pts = sorted(zip(x, y))\n    ys = sorted(y)\n    ans = float(\"inf\")\n    for y1, y2 in combinations(ys, 2):\n        xs = [x for x, y in pts if y1 <= y <= y2]\n        if len(xs) >= K:\n            ans = min(\n                ans,\n                (y2 - y1) * min(x2 - x1 for x1, x2 in zip(xs, xs[K - 1:]))\n            )\n    print(ans)\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\"\n    y = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    solve(N, K, x, y)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import combinations\nread = sys.stdin.read\n\nN, K, *xy = map(int, read().split())\nxy = sorted(zip(*[iter(xy)] * 2))\nX, Y = zip(*xy)\nanswer = 10 ** 20\n\nfor left, right in combinations(range(N), 2):\n    width = X[right] - X[left]\n    tmp_Y = sorted(Y[left:right + 1])\n    h = len(tmp_Y)\n    for i in range(h):\n        if i + K > h:\n            break\n\n        S = width * (tmp_Y[i + K - 1] - tmp_Y[i])\n        if S < answer:\n            answer = S\n\nprint(answer)", "import itertools\n\nN, K = map(int, input().split())\nP = [tuple(map(int, input().split())) for _ in range(N)]\n\nX = sorted([x for x, _ in P])\nY = sorted([y for _, y in P])\ndict_x = {v: k + 1 for k, v in enumerate(X)}\ndict_y = {v: k + 1 for k, v in enumerate(Y)}\n\ntable = [[0] * (N + 1) for _ in range(N + 1)]\nfor x, y in P:\n    table[dict_y[y]][dict_x[x]] = 1\n\nfor x in range(N + 1):\n    for y in range(N):\n        table[y + 1][x] += table[y][x]\nfor y in range(N + 1):\n    for x in range(N):\n        table[y][x + 1] += table[y][x]\n\nans = float('inf')\nfor x1, x2 in itertools.combinations(range(N), 2):\n    for y1, y2 in itertools.combinations(range(N), 2):\n        if table[y2 + 1][x2 + 1] - table[y2 + 1][x1] - table[y1][x2 + 1] + table[y1][x1] >= K:\n            ans = min(ans, (X[x2] - X[x1]) * (Y[y2] - Y[y1]))\nprint(ans)", "N, K = list(map(int, input().split()))\np_list = [[0] * 2 for i in range(N)]\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    p_list[i] = [x, y]\n\np_list.sort()\nans = float('inf')\nfor i in range(N - K + 1):\n    for j in range(i + K - 1, N):\n        x = abs(p_list[j][0] - p_list[i][0])\n        y_list = []\n        for k in range(i, j + 1):\n            y_list.append((p_list[k][1]))\n        y_list.sort()\n        for k in range(len(y_list) - K + 1):\n            ans = min(ans, x * abs(y_list[k + K - 1] - y_list[k]))\n\nprint(ans)\n", "n,k=map(int,input().split())\nx=[]\ny=[]\nxy=[]\nfor _ in range(n):\n  xx,yy=map(int,input().split())\n  xy.append((xx,yy))\n  x.append(xx)\n  y.append(yy)\nxx=sorted(x)\nyy=sorted(y)\nans=10**20\nfor sxi in range(n-1):\n  for syi in range(n-1):\n    for tyi in range(1,n):\n      sx,sy,ty=xx[sxi],yy[syi],yy[tyi]\n      ax=sorted([xxx for xxx,yyy in xy if sx<=xxx and sy<=yyy<=ty])\n      if len(ax)<k:continue\n      tx=ax[k-1]\n      ans=min(ans,(tx-sx)*(ty-sy))\nprint(ans)", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\n\nn, k = list(map(int, input().split()))\np = [list(map(int, input().split())) for _ in range(n)]\n\nx = [p[i][0] for i in range(n)]\nx.sort()\ny = [p[i][1] for i in range(n)]\ny.sort()\n\ncoord = [[0] * n for i in range(n)]\nfor i in range(n):\n    x_idx = bisect_left(x, p[i][0])\n    y_idx = bisect_left(y, p[i][1])\n    coord[x_idx][y_idx] += 1\n\ncoord_cs = [[0] * (n+1) for i in range(n+1)]\nfor i in range(n):\n    for j in range(n):\n        coord_cs[i+1][j+1] = coord[i][j]\nfor i in range(n):\n    for j in range(n+1):\n        coord_cs[i+1][j] += coord_cs[i][j]\nfor i in range(n+1):\n    for j in range(n):\n        coord_cs[i][j+1] += coord_cs[i][j]\n\n# print(*coord, sep='\\n')\n# print(*coord_cs, sep='\\n')\n\nans = (x[-1] - x[0]) * (y[-1] - y[0])\nfor xi in range(n):\n    for xj in range(xi+1, n+1):\n        for yi in range(n):\n            for yj in range(yi+1, n+1):\n                if coord_cs[xj][yj] - coord_cs[xi][yj] - coord_cs[xj][yi] + coord_cs[xi][yi] == k:\n                    cand = (x[xj-1] - x[xi]) * (y[yj-1] - y[yi])\n                    ans = min(ans, cand)\n\nprint(ans)\n", "N, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\ncand = []\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        cand += [dx * (YY[j + K - 1] - YY[j]) for j in range(k - K + 1)]\n\nprint(min(cand))", "N, K, *XY = [int(_) for _ in open(0).read().split()]\nXY = sorted(zip(XY[::2], XY[1::2]))\nans = float('inf')\nfor i in range(N):\n    for j in range(i + K - 1, N):\n        xlen = XY[j][0] - XY[i][0]\n        Y = sorted(y for x, y in XY[i:j + 1])\n        ylen = min(y2 - y1 for y1, y2 in zip(Y, Y[K - 1:]))\n        ans = min(ans, xlen * ylen)\nprint(ans)\n", "n,k = list(map(int,input().split()))\nl = [list(map(int,input().split())) for i in range(n)]\nl.sort()\nl1 = sorted(l,key=lambda x:x[1])\nans = float(\"INF\")\n\nfor i in l:\n    for j in l:\n        if i[0] >= j[0]:\n            continue\n        for s in l1:\n            count = 0\n            for w,h in l1:\n                if i[0] <= w <= j[0] and s[1] <= h:\n                    count += 1\n                if count==k:\n                    ans = (min(ans,(j[0]-i[0])*(h-s[1])))\n                    break\n                \nprint(ans)\n", "N,K = map(int,input().split())\nA = [list(map(int,input().split())) for _ in range(N)]\ns = 10**19\nB = sorted(A,key=lambda x:x[0])\nfor i in range(N-K+1):\n    for j in range(K,N-i+1):\n        xmin = B[i][0]\n        xmax = B[i+j-1][0]\n        By = sorted(B[i:i+j],key=lambda x:x[1])\n        for k in range(len(By)-K+1):\n            ymin = By[k][1]\n            ymax = By[k+K-1][1]\n            s = min(s,(xmax-xmin)*(ymax-ymin))\nprint(s)", "import sys\nimport itertools\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nXY = [lr() for _ in range(N)]\nXY.sort()\nanswer = float('inf')\n# \u7aef\u306e4\u70b9\u3001\u307e\u305a\u306fx\u8ef8\u306e2\u70b9\u3092\u9078\u3076\nfor left,right in itertools.combinations(range(N),2):\n  width = XY[right][0] - XY[left][0]\n  pts = sorted(XY[left:right+1], key = lambda xy: xy[1])\n  if len(pts) < K:\n    continue\n  for D in range(len(pts) - K + 1):\n    if D + K - 1 >= len(pts):\n      break\n    y_max = pts[D+K-1][1]\n    y_min = pts[D][1]\n    area = (y_max - y_min) * width\n    if area < answer:\n      answer = area\n    \nprint(answer)", "n,h=list(map(int,input().split()))\np,x,y=[],[],[]\nz=float(\"inf\")\nfor i in range(n):\n  a,b=list(map(int,input().split()))\n  p.append((a,b))\n  x.append(a)\n  y.append(b)\nx.sort()\ny.sort()\nfor i in range(n-1):\n  for j in range(i,n):\n    for k in range(n-1):\n      lx,rx,dy=x[i],x[j],y[k]\n      c=0\n      t=[]\n      for a,b in p:\n        if x[i]<=a<=x[j] and y[k]<=b:c+=1;t.append(b)\n      if h<=c:z=min(z,(x[j]-x[i])*(sorted(t)[h-1]-y[k]))\nprint(z)\n", "N, K = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(N)]\n\n\nxy.sort()\nans = 2000000000 * (xy[-1][0] - xy[0][0])\nfor i in range(K-1, N):\n  for j in range(N-i):\n    xnow = xy[j+i][0] - xy[j][0]\n    ylst = [xy[k][1] for k in range(j, j+i+1)]\n    ylst.sort()\n    ynow = min([ylst[k+K-1]-ylst[k] for k in range(i+2-K)])\n    ans = min(ans, xnow*ynow)\n    \nprint(ans)\n", "# solution\n\nimport io\nimport math\nimport scipy.sparse\nimport numpy\n\nnim, mike = map(int, input().split())\narray = [list(map(int, input().split())) for i in range(nim)]\n\nanswer = 10**100\nsortx = sorted(array, key = lambda x: x[0])\nfor a, pt1 in enumerate(sortx[:nim-mike+1]):\n    for b, pt2 in enumerate(sortx[a+mike-1:]):\n        #print(a,b)\n        sorty = sorted(sortx[a:a+mike+b], key = lambda x: x[1])\n        sorty_len = len(sorty)\n        for c, pt3 in enumerate(sorty[:sorty_len-mike+1]):\n            #print(len(sorty), c, k)\n            pt4 = sorty[c+mike-1]\n            #print(pt1, pt2, pt3, pt4)\n            if pt3[1] <= pt1[1] and pt3[1] <= pt2[1] and pt4[1] >= pt1[1] and pt4[1] >= pt2[1]:\n                answer = min(answer, (pt2[0] - pt1[0]) * (pt4[1] - pt3[1]))\nprint(answer)", "N, K = (int(x) for x in input().split())\nPlot = [tuple(int(x) for x in input().split()) for _ in range(N)]\nX = [p[0] for p in Plot]\nY = [p[1] for p in Plot]\nX.sort()\nY.sort()\n#\u51682\u70b9\u9593\u3067\u9577\u65b9\u5f62\u306e\u8fba\u3092\u4f5c\u308a\u3001\u305d\u306e\u5185\u5185\u90e8\u70b9\u304cK\u500b\u306e\u3082\u306e\u3060\u3051\u9762\u7a4d\u3092\u6bd4\u8f03\u3059\u308b\u3002\nans = 10e20\nfrom itertools import combinations\nfor x1, x2 in combinations(X, 2):\n    for y1 in Y:\n        y2 = [y for x,y in Plot if x1 <= x <= x2 and y1 <= y]\n        if len(y2) < K:\n            break\n        y2.sort()\n        S = (x2-x1)*(y2[K-1]-y1)\n        ans = min(ans, S)\nprint(ans)\n", "n, k = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(n)]\nXY.sort(key=lambda x: x[0])\nXY = [xy + [x] for x, xy in enumerate(XY)]\nXY.sort(key=lambda x: x[1])\nXY = [xy + [y] for y, xy in enumerate(XY)]\n\ngr = [[0] * n for _ in range(n)]\nfor _, _, i, j in XY:\n  gr[i][j] = 1\n  \nrui = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(n):\n  for j in range(n):\n    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]\n    \n# XY\u306e2\u70b9,3\u70b9,4\u70b9\u3092\u7dcf\u5f53\u305f\u308a\nans = 10 ** 21\nfor i in range(n - 1):\n  for j in range(i + 1, n):\n    x = [XY[m][0] for m in [i, j]]\n    y = [XY[m][1] for m in [i, j]]\n    ii = [XY[m][2] for m in [i, j]]\n    jj = [XY[m][3] for m in [i, j]]\n    innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                + rui[min(ii)][min(jj)] \\\n                - rui[min(ii)][max(jj) + 1] \\\n                - rui[max(ii) + 1][min(jj)]\n    if innerPoints >= k:\n      area = (max(x) - min(x)) * (max(y) - min(y)) \n      if area < ans:\n        ans = area\n\nif n > 2:\n  for i in range(n - 2):\n    for j in range(i + 1, n - 1):\n      for l in range(j + 1, n):\n        x = [XY[m][0] for m in [i, j, l]]\n        y = [XY[m][1] for m in [i, j, l]]\n        ii = [XY[m][2] for m in [i, j, l]]\n        jj = [XY[m][3] for m in [i, j, l]]\n        innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                    + rui[min(ii)][min(jj)] \\\n                    - rui[min(ii)][max(jj) + 1] \\\n                    - rui[max(ii) + 1][min(jj)]\n        if innerPoints >= k:\n          area = (max(x) - min(x)) * (max(y) - min(y)) \n          if area < ans:\n            ans = area\n\nif n > 3:\n  for i in range(n - 3):\n    for j in range(i + 1, n - 2):\n      for l in range(j + 1, n - 1):\n        for o in range(l + 1, n):\n          x = [XY[m][0] for m in [i, j, o, l]]\n          y = [XY[m][1] for m in [i, j, o, l]]\n          ii = [XY[m][2] for m in [i, j, o, l]]\n          jj = [XY[m][3] for m in [i, j, o, l]]\n          innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                      + rui[min(ii)][min(jj)] \\\n                      - rui[min(ii)][max(jj) + 1] \\\n                      - rui[max(ii) + 1][min(jj)]\n          if innerPoints >= k:\n            area = (max(x) - min(x)) * (max(y) - min(y)) \n            if area < ans:\n              ans = area\n\nprint(ans)", "n,k=map(int,input().split())\nXY=[[0]*2 for i in range(n)]\nX=[0]*n\nY=[0]*n\nZ=[i for i in range(1,n+1)]\nfor i in range(n):\n  X[i],Y[i]=map(int,input().split())\n  XY[i]=[X[i],Y[i]]\nX.sort()\nY.sort()\nXX=dict(zip(X,Z))\nYY=dict(zip(Y,Z))\nXXX=dict(zip(Z,X))\nYYY=dict(zip(Z,Y))\nA=[[0]*n for i in range(n)]\nfor i in range(n):\n  A[XX[XY[i][0]]-1][YY[XY[i][1]]-1]+=1\nC=[[0]*(n+1) for i in range(n+1)]\nfor i in range(1,n+1):\n  for j in range(1,n+1):\n    C[i][j]=C[i-1][j]+C[i][j-1]-C[i-1][j-1]+A[i-1][j-1]\nans=10**20\nfor i in range(1,n):\n  for j in range(i+1,n+1):\n    for s in range(1,n):\n      for t in range(s+1,n+1):\n        if C[j][t]-C[j][s-1]-C[i-1][t]+C[i-1][s-1]<k:\n          continue\n        a=(XXX[j]-XXX[i])*(YYY[t]-YYY[s])\n        if a<ans:\n          ans=a\nprint(ans)", "def main():\n    N, K = list(map(int, input().split()))\n    XY = [tuple(map(int, input().split())) for _ in range(N)]\n    XY.sort()\n    XY = tuple(XY)\n\n    def count(x_min, x_max, y_min, y_max, i, j):\n        OK = 0\n        # NG = 0\n        for m, n in XY[i:j + 1]:\n            if y_min <= n <= y_max:\n                OK += 1\n        if OK >= K:\n            return True\n        return False\n\n    ans = 10 ** 20\n    for i, val_i in enumerate(XY[:N - 1]):\n        a = val_i[0]\n        for j in range(i + K - 1, N):\n            b = XY[j][0]\n            e = b - a\n            # print (e, i, j)\n            for k, c in XY:\n                # c = k[1]\n                for l, d in XY:\n                    # d = l[1]\n                    if c < d:\n                        if  e * (d - c) < ans and count(a, b, c, d, i, j):\n                            # print ('A')\n                            ans = e * (d - c)\n                            # ans = min(ans, e * (d - c))\n    print (ans)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(n)]\nINF = 10 ** 19\n\nxy.sort()\n\nans = INF\nfor i in range(n):\n\tfor j in range(i + k - 1, n):\n\t\twidth = xy[j][0] - xy[i][0]\n\n\t\ty = [xy[idx][1] for idx in range(i, j + 1)]\n\t\ty.sort()\n\n\t\tfor e1, e2 in zip(y, y[k-1:]):\n\t\t\theight = e2 - e1\n\t\t\tarea = width * height\n\t\t\tans = min(ans, area)\n\nprint(ans)\n", "N,K = map(int,input().split())\nary = [list(map(int,input().split())) for _ in range(N)]\na = sorted(ary)\nans = float(\"Inf\")\nfor i in range(N-K+1):\n    for j in range(i,N-K+1):\n        lx = a[i][0]; rx = a[K+j-1][0]\n        b = a[i:K+j]\n        c = sorted(b,key=lambda x:(x[1]))\n        for k in range(len(c)-K+1):\n            by = c[k][1]; uy = c[k+K-1][1]\n            ans = min(ans,(rx - lx) * (uy - by))\nprint(ans)", "n, k = list(map(int,input().split()))\nps = [tuple(map(int,input().split())) for i in range(n)]\n\nsx = sorted(ps,key = lambda x: x[0]) # x\u5ea7\u6a19\u3067\u30bd\u30fc\u30c8\nnx = list(enumerate(sx)) # \u9802\u70b9\u756a\u53f7\u3092\u4ed8\u52a0\nans = 5e18\n\nfor f, (x1,y1) in nx[:n-k+1]: # \u5de6\u8fba\u306e\u9802\u70b9\n    for e, (x2,y2) in nx[f+k-1:]: # \u53f3\u8fba\u306e\u9802\u70b9\n        dx = x2 - x1 # \u6a2a\n        sy = sorted(y for x,y in sx[f:e+1]) # \u542b\u307e\u308c\u308b\u9802\u70b9\u3092y\u5ea7\u6a19\u3067\u30bd\u30fc\u30c8\n        for y3,y4 in zip(sy,sy[k-1:]): # y3=\u4e0b\u8fba\u306e\u9802\u70b9\uff0cy4=\u4e0a\u8fba\u306e\u9802\u70b9\n            if y3 <= y1 and y4 >= y2: # \u5de6\u53f3\u8fba\u306e\u9802\u70b9\u3092\u542b\u3080\u3053\u3068\n                ans = min(ans, dx * (y4 - y3))\n\nprint(ans)\n", "import sys\nimport numpy as np\ninput = sys.stdin.readline\n\ndef main():\n    N, K = list(map(int, input().split()))\n    xy = [list(map(int, input().split())) for i in range(N)]\n    # \u5ea7\u6a19\u5727\u7e2e\n    xs = []\n    ys = []\n    xy = sorted(xy, key=lambda x: x[0])\n    for i in range(N):\n        xs.append(xy[i][0])\n        xy[i][0] = i+1\n    xy = sorted(xy, key=lambda x: x[1])\n    for i in range(N):\n        ys.append(xy[i][1])\n        xy[i][1] = i+1\n    # 2\u6b21\u5143\u7d2f\u7a4d\u548c\n    sum_ = np.zeros((N+1, N+1), dtype=int)\n    for i in range(N):\n        x, y = xy[i]\n        sum_[y][x] = 1\n    for i in range(1, N+1):\n        sum_[i] += sum_[i-1]\n    for i in range(1, N+1):\n        sum_[:,i] += sum_[:,i-1]\n    # \u5168\u63a2\u7d22\n    ans = int(1e20)\n    for l in range(1, N+1):\n        no_three = True\n        for r in range(N, l, -1):\n            no_two = True\n            for d in range(1, N+1):\n                no_one = True\n                for u in range(d+1, N+1):\n                    tmp = sum_[u][r] - sum_[d-1][r] - sum_[u][l-1] + sum_[d-1][l-1]\n                    if tmp >= K:\n                        tmp = (xs[r-1] - xs[l-1]) * (ys[u-1] - ys[d-1])\n                        ans = min(ans, tmp)\n                        no_one = False\n                        break\n                if no_one:\n                    break\n                else:\n                    no_two = False\n            if no_two:\n                break\n            else:\n                no_three = False\n        if no_three:\n            break\n                \n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,K=map(int,input().split())\nxy=[]\nx=[]\ny=[]\nfor _ in range(n):\n\tX,Y=map(int,input().split())\n\tx.append(X+10**9)\n\ty.append(Y+10**9)\n\txy.append((X+10**9,Y+10**9))\nx.sort();y.sort();xy.sort()\nnum=[[0]*(n+1)for _ in range(n+1)]\nfor xx in xy:\n\tfor i in range(n):\n\t\tif x[i]==xx[0]:\n\t\t\tbreak\n\tfor j in range(n):\n\t\tif y[j]==xx[1]:\n\t\t\tbreak\n\tnum[i+1][j+1]+=1\nfor i in range(n):\n\tfor j in range(n):\n\t\tnum[i+1][j+1]+=num[i+1][j]\nfor i in range(n):\n\tfor j in range(n):\n\t\tnum[i+1][j+1]+=num[i][j+1]\nans=10**20\nfor i in range(n):\n\tfor j in range(n):\n\t\tfor k in range(i+1,n+1):\n\t\t\tfor l in range(j+1,n+1):\n\t\t\t\tif num[k][l]-num[i][l]-num[k][j]+num[i][j]>=K:\n\t\t\t\t\tr=(y[l-1]-y[j])*(x[k-1]-x[i])\n\t\t\t\t\tans=min(ans,r)\nprint(ans)", "\"\"\"\n\u5ea7\u6a19\u5727\u7e2e\n2D\u7d2f\u7a4d\u548c\n\u5168\u63a2\u7d22\n\u52dd\u5229\n\"\"\"\nn, k = map(int,input().split())\nxs = set()\nys = set()\nps = []\n# \u5ea7\u5727\nfor _ in range(n):\n    x,y = map(int,input().split())\n    ps.append((x,y))\n    xs.add(x)\n    ys.add(y)\nxdic = {x:i for i,x in enumerate(sorted(list(xs)))}\nydic = {y:i for i,y in enumerate(sorted(list(ys)))}\nrxdic = {i:x for i,x in enumerate(sorted(list(xs)))}\nrydic = {i:y for i,y in enumerate(sorted(list(ys)))}\n\n# 2D\u7d2f\u7a4d\u548c\nh = len(xdic)\nw = len(ydic)\nA = [[0 for i in range(w+1)] for j in range(h+1)]\nAcum = [[0 for i in range(w+1)] for j in range(h+1)]\n\nfor x,y in ps:\n    h = xdic[x]\n    w = ydic[y]\n    A[h][w] += 1\n\nfor i in range(len(xdic)):\n    for j in range(len(ydic)):\n        Acum[i+1][j+1] = Acum[i][j+1] + Acum[i+1][j] - Acum[i][j] + A[i][j]\n      \n# \u63a2\u7d22\nans = 1 << 100\nh = len(xdic)\nw = len(ydic)\nfor i1 in range(h+1):\n    for i2 in range(i1+1,h+1):\n        for j1 in range(w+1):\n            for j2 in range(j1+1,w+1):\n                num = Acum[i2][j2]-Acum[i1][j2]-Acum[i2][j1]+Acum[i1][j1]\n                # print((i1,i2),(j1,j2),num)\n                if num == k:\n                    x1 = rxdic[i1]\n                    x2 = rxdic[i2-1]\n                    y1 = rydic[j1]\n                    y2 = rydic[j2-1]\n                    S = (x2-x1)*(y2-y1)\n                    ans = min(ans, S)\nprint(ans)", "def abc075_d():\n    n, k = map(int, input().split())\n    P = []\n    xarr = []\n    yarr = []\n    for _ in range(n):\n        x, y = (int(x) for x in input().split())\n        P.append((x, y))\n        xarr.append(x)\n        yarr.append(y)\n    xarr.sort()\n    yarr.sort()\n\n    ans = 5*10**18\n    for s, xi in enumerate(xarr):\n        for xj in xarr[s+1:]:\n            cand = [(x, y) for x, y in P if xi <= x and x <= xj]\n            for t, yi in enumerate(yarr):\n                for yj in yarr[t+1:]:\n                    cnt = len([y for x, y in cand if yi <= y and y <= yj])\n                    if cnt >= k:\n                        area = (xj - xi) * (yj - yi)\n                        ans = min(ans, area)\n    print(ans)\n\ndef __starting_point():\n    abc075_d()\n__starting_point()", "from collections import deque\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    n,k=MI()\n    xx=set()\n    yy=set()\n    xy=[]\n    for _ in range(n):\n        x,y=MI()\n        xy.append((x,y))\n        xx.add(x)\n        yy.add(y)\n    xy.sort()\n    xx=list(sorted(xx))\n    yy = list(sorted(yy))\n    xn=len(xx)\n    yn=len(yy)\n    ans=10**20\n    for t in range(yn):\n        y2=yy[t]\n        for b in range(t):\n            y1=yy[b]\n            r=-1\n            s=0\n            i=j=0\n            for l,x1 in enumerate(xx):\n                while i<n and xy[i][0]<x1:\n                    if y1 <= xy[i][1] <= y2: s -= 1\n                    i += 1\n                while s<k and r+1<xn:\n                    r+=1\n                    x2=xx[r]\n                    while j<n and xy[j][0]<=x2:\n                        if y1<=xy[j][1]<=y2:s+=1\n                        j+=1\n                if s>=k:\n                    cur=(x2-x1)*(y2-y1)\n                    if cur<ans:ans=cur\n    print(ans)\n\nmain()", "from itertools import accumulate\nfrom operator import add\n\nN, K = list(map(int, input().split()))\nxs, ys = [], []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    xs.append(x)\n    ys.append(y)\n\niXs = list(range(N))\niXs.sort(key=lambda iX: xs[iX])\nodrXs = [0]*(N)\nfor odrX, iX in enumerate(iXs):\n    odrXs[iX] = odrX\niYs = list(range(N))\niYs.sort(key=lambda iY: ys[iY])\nodrYs = [0]*(N)\nfor odrY, iY in enumerate(iYs):\n    odrYs[iY] = odrY\n\nAss = [[0]*(N) for _ in range(N)]\nfor odrX, odrY in zip(odrXs, odrYs):\n    Ass[odrX][odrY] = 1\n\ndef getAccAss(Ass):\n    accAss = [[0] * (len(Ass[0])+1)] + [accumulate([0] + As) for As in Ass]\n    for x in range(1, len(accAss)):\n        accAss[x] = list(map(add, accAss[x], accAss[x-1]))\n    return accAss\ndef getRangeSum2D(accAss, xFr, xTo, yFr, yTo):\n    return accAss[xTo+1][yTo+1] - accAss[xTo+1][yFr] - accAss[xFr][yTo+1] + accAss[xFr][yFr]\n\naccAss = getAccAss(Ass)\n\nans = 10**20\nfor xFr in range(N-1):\n    for xTo in range(xFr+1, N):\n        for yFr in range(N-1):\n            for yTo in range(yFr+1, N):\n                num = getRangeSum2D(accAss, xFr, xTo, yFr, yTo)\n                if num >= K:\n                    area = (xs[iXs[xTo]]-xs[iXs[xFr]]) * (ys[iYs[yTo]]-ys[iYs[yFr]])\n                    ans = min(ans, area)\n\nprint(ans)\n", "import sys\nimport itertools\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nXY = [lr() for _ in range(N)]\nXY.sort()\nanswer = float('inf')\n# \u7aef\u306e4\u70b9\u3001\u307e\u305a\u306fx\u8ef8\u306e2\u70b9\u3092\u9078\u3076\nfor i, j in itertools.combinations(list(range(N)), 2):\n    xleft = XY[i][0]\n    xright = XY[j][0]\n    candidate = sorted(XY[i:j+1], key=lambda xy: xy[1])\n    if len(candidate) < K:\n        continue\n    for s in range(len(candidate) - K + 1):\n        yup = candidate[s+K-1][1]\n        ylow = candidate[s][1]\n        area = (xright - xleft) * (yup - ylow)\n        if area < answer:\n            answer = area\n\nprint(answer)\n# 31\n", "from itertools import combinations, product\nimport bisect as bs\n\ndef tuple_int(iterable):\n    return tuple(map(int, iterable.split()))\n\ndef S_with_K_plots(plots, K):\n    result = []\n    X, Y = sorted([x for x,y in plots]), sorted([y for x,y in plots])\n    for xinf, xsup in combinations(X,2):\n        for yinf in Y:\n            ysup = [y for x,y in plots if xinf<=x<=xsup and y >= yinf]\n            if len(ysup) < K: continue\n            ysup.sort()\n            result.append((xsup-xinf)*(ysup[K-1]-yinf))\n    return result\n\ndef __starting_point():\n    with open(0) as f:\n        N, K = map(int, f.readline().split())\n        plots = list(map(tuple_int, f.readlines()))\n    print(min(S_with_K_plots(plots, K)))\n__starting_point()", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\nXY.sort()\nX, Y = zip(*XY)\nr = float('inf')\nfor x0 in range(N - K + 1):\n  for x1 in range(K + x0 - 1, N):\n    x = X[x1] - X[x0]\n    Y_s = sorted(Y[x0:x1 + 1])\n    for y0 in range(len(Y_s) - K + 1):\n      y = Y_s[y0 + K - 1] - Y_s[y0]\n      r = min(r, x * y)\nprint(r)", "#!/usr/bin/env python3\nimport sys\nfrom itertools import combinations\n\ndef _solve(y1, y2, sorted_points, K):\n    y1, y2 = tuple(sorted([y1, y2]))\n    x = tuple(x for x, y in sorted_points if y1 <= y <= y2)\n    if len(x) < K:\n        return float('inf')\n    return min((y2 - y1) * (x2 - x1) for x1, x2 in zip(x, x[K-1:]))\n\ndef solve(N: int, K: int, x: \"List[int]\", y: \"List[int]\"):\n    sorted_points = tuple(sorted(zip(x, y)))\n    return min(_solve(y1, y2, sorted_points, K) for y1, y2 in combinations(y, 2))\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\"\n    y = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n    print((solve(N, K, x, y)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n\nN, K, *XY = list(map(int, open(0).read().split()))\n\nX = XY[::2]\ncomp_X = {}\ndecomp_X = {}\nfor i, x in enumerate(sorted(set(X))):\n    comp_X[x] = i\n    decomp_X[i] = x\n\nY = XY[1::2]\ncomp_Y = {}\ndecomp_Y = {}\nfor i, y in enumerate(sorted(set(Y))):\n    comp_Y[y] = i\n    decomp_Y[i] = y\n\nI = len(comp_X)\nJ = len(comp_Y)\ncomp_XY = [(comp_X[x], comp_Y[y]) for x, y in zip(X, Y)]\nacc = np.zeros((I + 1, J + 1), np.int32)\nfor c_x, c_y in comp_XY:\n    acc[c_x + 1][c_y + 1] += 1\nacc = np.add.accumulate(acc, axis=0)\nacc = np.add.accumulate(acc, axis=1)\n\nans = float(\"inf\")\nfor i in range(1, I + 1):\n    for j in range(1, J + 1):\n        cur = acc[i:, j:] + acc[:-i, :-j] - acc[:-i, j:] - acc[i:, :-j]\n        for k, row in enumerate(cur):\n            for l, val in enumerate(row):\n                if val >= K:\n                    ans = min(\n                        ans,\n                        (decomp_X[k + i - 1] - decomp_X[k])\n                        * (decomp_Y[l + j - 1] - decomp_Y[l]),\n                    )\nprint(ans)\n", "import collections, itertools, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    N, K = LI()\n    xy = [LI() for _ in range(N)]\n\n    # x, y\u5168\u3066\u306e\u91cd\u8907\u3042\u308a\u7d44\u307f\u5408\u308f\u305b\u306b\u5bfe\u3057\u3066\u542b\u307e\u308c\u308b\u70b9\u306e\u500b\u6570\u3092\u7b97\u51fa\u3059\u308b\n\n    x_coord = [i[0] for i in xy]\n    x_coord.sort()\n    x_val_num = {x_coord[i]: i for i in range(N)}\n    y_coord = [i[1] for i in xy]\n    y_coord.sort()\n    y_val_num = {y_coord[i]: i for i in range(N)}\n\n    # 2\u6b21\u5143\u7d2f\u7a4d\u548c\n    xy_cnt = [[0] * N for _ in range(N)]\n    for x, y in xy:\n        xy_cnt[y_val_num[y]][x_val_num[x]] = 1\n    # for i in xy_cnt:\n    #     print(i)\n    xy_acm = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(N):\n        for j in range(N):\n            xy_acm[i+1][j+1] = xy_cnt[i][j] + xy_acm[i+1][j] + xy_acm[i][j+1] - xy_acm[i][j]\n    # for i in xy_acm:\n    #     print(i)\n\n    ans = INF\n    for yl, yu in itertools.combinations(list(range(N + 1)), 2):\n        for xl, xu in itertools.combinations(list(range(N + 1)), 2):\n            cnt = xy_acm[yu][xu] - xy_acm[yu][xl] - xy_acm[yl][xu] + xy_acm[yl][xl]\n            # print(cnt, yl, yu, xl, xu)\n            if cnt >= K:\n                ans = min((x_coord[xu-1] - x_coord[xl]) * (y_coord[yu-1] - y_coord[yl]), ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N, K = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N)]\n\n    Xs = []\n    Ys = []\n    for x, y in XY:\n        Xs.append(x)\n        Ys.append(y)\n    Xs.sort()\n    Ys.sort()\n    points = [[0 for _ in range(N)] for _ in range(N)]\n\n    for x, y in XY:\n        ix = bisect_left(Xs, x)\n        iy = bisect_left(Ys, y)\n        points[ix][iy] += 1\n\n    sumpoints = [[0 for _ in range(N+1)] for _ in range(N+1)]\n\n    for ix in range(1, N+1):\n        s = 0\n        for iy in range(1, N+1):\n            if ix == 1:\n                sumpoints[ix][iy] = points[ix-1][iy-1]\n            if points[ix-1][iy-1] == 1:\n                s = 1\n            sumpoints[ix][iy] = sumpoints[ix-1][iy] + s\n\n    ans = int(8E18)\n    for lx in range(N-1):\n        for rx in range(lx+1, N):\n            for ly in range(N-1):\n                for ry in range(ly+1, N):\n                    if sumpoints[rx+1][ry+1] - sumpoints[rx+1][ly] - sumpoints[lx][ry+1] + sumpoints[lx][ly] >= K:\n                        s = (Xs[rx]-Xs[lx])*(Ys[ry]-Ys[ly])\n                        ans = min(ans, s)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k = list(map(int,input().split()))\nxy = [list(map(int,input().split())) for _ in range(n)]\n\nxy.sort()\nans = 10**20\n\nfor i in range(n):\n    for j in range(i,n):\n        xy_tmp = xy[i:j+1]\n        if len(xy_tmp) >= k:\n            l1 = xy_tmp[0][0]\n            r1 = xy_tmp[-1][0]\n            xy_tmp.sort(key = lambda x: x[1])\n            for jj in range(len(xy_tmp) - k + 1):\n                ans = min(ans, (r1-l1) * (xy_tmp[k+jj-1][1] - xy_tmp[jj][1]))\n\nprint(ans)\n", "N, K = list(map(int, input().split()))\npts = []\nys = []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    pts.append((x, y))\n    ys.append(y)\n\npts.sort()\nys.sort()\n\nans = 10**20\nfor i, y1 in enumerate(ys):\n    for y2 in ys[i+1:]:\n        for j, (x1, _) in enumerate(pts):\n            num = 0\n            for x, y in pts[j:]:\n                if y1 <= y <= y2:\n                    num += 1\n                if num >= K:\n                    area = (x-x1) * (y2-y1)\n                    ans = min(ans, area)\n                    break\n\nprint(ans)\n", "N, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\nans = 1e20\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        ans = min(ans, min(dx * (YY[j + K - 1] - YY[j]) for j in range(k - K + 1)))\n\nprint(ans)", "def da_generate(h,w,a):\n    da = [[0]*w for j in range(h)]\n    da[0][0] = a[0][0]\n    for i in range(1,w):\n        da[0][i] = da[0][i-1]+a[0][i]\n    for i in range(1,h):\n        cnt_w = 0\n        for j in range(w):\n            cnt_w += a[i][j]\n            da[i][j] = da[i-1][j]+cnt_w\n    return da\n\ndef da_calc(da,p,q,x,y):\n    if p > x or q > y:\n        return 0\n    if p == 0 and q == 0:\n        return da[x][y]\n    if p == 0:\n        return da[x][y]-da[x][q-1]\n    if q == 0:\n        return da[x][y]-da[p-1][y]\n    return da[x][y]-da[p-1][y]-da[x][q-1]+da[p-1][q-1]\n\nn , k = map(int,input().split())\nmototen = []\natuten = []\nzax = []\nzay = []\nfor i in range(n):\n    x , y = map(int,input().split())\n    mototen.append((x,y))\n    zax.append(x)\n    zay.append(y)\nzax.sort()\nzay.sort()\n\na = [[0 for i in range(len(zay))] for j in range(len(zax))]\n\nfor x , y in mototen:\n    atx = zax.index(x)\n    aty = zay.index(y)\n    a[atx][aty] += 1\nb = da_generate(len(zax),len(zay),a)\nans = float(\"inf\")\nfor p in range(len(zax)-1):\n    for q in range(len(zay)-1):\n        for x in range(p+1,len(zax)):\n            for y in range(q+1,len(zax)):\n                kar = da_calc(b,p,q,x,y)\n                if kar >= k:\n                    men = (zax[x]-zax[p])*(zay[y]-zay[q])\n                    ans = min(ans,men)\nprint(ans)", "N,K = list(map(int,input().split()))\np = sorted([list(map(int,input().split())) for _ in range(N)])\nx, y = list(zip(*p))\ninf = float('inf')\nans = inf\n\nfor i in range(N-K+1):\n    for j in range(K+i-1, N):\n        Ys = sorted(y[i:j+1])\n        for k in range(len(Ys)-K+1):\n            ans = min(ans, (x[j]-x[i])*(Ys[k+K-1]-Ys[k]))\nprint(ans)\n", "n,k,*L=map(int,open(0).read().split())\nX=[];Y=[]\nfor x,y in sorted((x,y) for x,y in zip(*[iter(L)]*2)):\n\tX.append(x)\n\tY.append(y)\nans=float(\"inf\")\nfor i in range(n-k+1):\n\tfor j in range(i+k-1,n):\n\t\tw=X[j]-X[i]\n\t\tl=sorted(Y[i:j+1])\n\t\th=min(My-my for my,My in zip(l,l[k-1:]))\n\t\tans=min(ans,w*h)\nprint(ans)", "def solve():\n  n, k = map(int, input().split())\n  p = [tuple(map(int, input().split())) for i in range(n)]\n  p.sort()\n  ans = 4000000000000000000\n  for i in range(k, n + 1):\n      for j in range(n - i + 1):\n          x = p[i + j - 1][0] - p[j][0]\n          s = [p[a][1] for a in range(j, i + j)]\n          s.sort()\n          y = 4000000000\n          for a in range(i - k + 1):\n            y = min(y, s[a + k - 1] - s[a])\n          ans = min(ans, x * y)\n  print(ans)\nsolve()", "import sys\nstdin = sys.stdin\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\nsys.setrecursionlimit(10**6)\n\nn,k = na()\nxy = []\n\nfor i in range(n):\n    x,y = na()\n    xy.append((x,y))\n\nxy.sort()\nans = 10000000000000000000000000000\n\nfor i in range(n):\n    for j in range(i+1, n):\n        x = xy[j][0] - xy[i][0]\n        yy = sorted(xy[i:j+1], key=lambda x:x[1])\n        for u in range(len(yy)-k+1):\n            y = yy[u+k-1][1] - yy[u][1]\n            ans = min(ans, y*x)\n            \nprint(ans)\n", "N, K = list(map(int, input().split()))\nP = sorted([tuple(map(int, input().split())) for _ in range(N)])\n\nans = 1e30\nfor lx in range(N):\n    for rx in range(lx+K, N+1):\n        Q = sorted(P[lx:rx], key=lambda x:x[1])\n        for ly in range(len(Q)):\n            R = Q[ly:ly+K]\n            if len(R)>=K: ans = min(ans, (P[rx-1][0]-P[lx][0])*(R[-1][1]-R[0][1]))\nprint(ans)", "n,k=map(int,input().split())\nli=sorted([list(map(int,input().split())) for i in range(n)],key=lambda x:(x[1],x[0]))\nans=float(\"INF\")\n#print(li)\nfor i in range(n):\n    for j in range(i+1,n):\n        ux,lx=max(li[i][0],li[j][0]),min(li[i][0],li[j][0])\n        l,r=0,0\n        cnt=int(lx<=li[r][0]<=ux)\n#        print(\"!\",ux,lx,\"!\",end=\"\")\n        while True:\n#            print(\"cnt:\",cnt,end=\"\")\n            while r<n-1 and cnt<k:\n                r+=1\n                cnt+=int(lx<=li[r][0]<=ux)\n            if cnt<k or not(0<=r<=n-1) or not(0<=l<=n-1) or r<=l :break\n            if ans>(ux-lx)*(li[r][1]-li[l][1]):\n                ans=(ux-lx)*(li[r][1]-li[l][1])\n#                print(i,j,l,r,cnt,ans)\n            cnt-=int(lx<=li[l][0]<=ux)\n            l+=1\nprint(ans)", "# coding: utf-8\n\n# 11:50-\n# 50min: give up\n# 15:15-15:58 done\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    x, y = [None] * N, [None] * N\n    for i in range(N):\n        x[i], y[i] = list(map(int, input().split()))\n    \n    points = [[i, x[i], y[i]] for i in range(N)]\n    points_ysort = sorted(points, key=lambda p: p[2], reverse=True)\n    points_ysort_rev = list(reversed(points_ysort))\n    points_xsort = sorted(points, key=lambda p: p[1], reverse=False)\n    points_xsort_rev = list(reversed(points_xsort))\n    \n    min_area = 4 * (10**18)\n    outsides_top = []\n    \n    t = 0\n    while t <= N-K:\n        # n_inside = N - t\n\n        top_i, top_x, top_y = points_ysort[t]\n\n        outsides_bottom = []\n        b = 0\n        while b < N:\n            # n_inside -= b\n\n            bottom_i, bottom_x, bottom_y = points_ysort_rev[b]\n\n            if bottom_i == top_i:\n                break\n\n            # outsides_left = []\n            n_outsides_left = 0\n            l = 0\n            while l < N:\n                left_i, left_x, left_y = points_xsort[l]\n\n                if left_x > top_x:\n                    break\n\n                if left_i in outsides_top or left_i in outsides_bottom:\n                    l += 1\n                    continue\n                \n                # outsides_right = []\n                n_outsides_right = 0\n                r = 0\n                while r < N:\n                    if N - t - b - n_outsides_left - n_outsides_right < K:\n                        break\n\n                    right_i, right_x, right_y = points_xsort_rev[r]\n\n                    if right_i == left_i:\n                        break\n                    \n                    if right_x < top_x:\n                        break\n                    \n                    if right_i in outsides_top or right_i in outsides_bottom:\n                        r += 1\n                        continue\n\n                    area = (top_y - bottom_y) * (right_x - left_x)\n                    if area < min_area:\n                        min_area = area\n                    \n                    # outsides_right.append(right_i)\n                    n_outsides_right += 1\n                    r += 1\n                \n                # outsides_left.append(left_i)\n                n_outsides_left += 1\n                l += 1\n            \n            outsides_bottom.append(bottom_i)\n            b += 1\n        \n        outsides_top.append(top_i)\n        t += 1\n\n    return min_area\n\n\nprint((main()))\n", "from itertools import combinations\n\n\nN, K, *XY = list(map(int, open(0).read().split()))\nX = sorted(XY[::2])\nY = sorted(XY[1::2])\n\nans = 10 ** 20\nfor x1, x2 in combinations(X, 2):\n    for y1 in Y[:-1]:\n        y2s = sorted(y for x, y in zip(*[iter(XY)] * 2) if x1 <= x <= x2 and y1 <= y)\n        if len(y2s) < K:\n            continue\n        ans = min(ans, (x2 - x1) * (y2s[K - 1] - y1))\nprint(ans)\n\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, atan, degrees\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\nfrom bisect import bisect\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, K = MAP()\nxy = [LIST() for _ in range(N)]\nans = INF\nxy.sort()\nfor l in range(N-K+1):  # \u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u6700\u3082\u5de6\u306e\u70b9\n    for r in range(l+K, N+1):  # \u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u6700\u3082\u53f3\u306e\u70b9\n        y = sorted(xy[l:r], key = lambda x: x[1])  # l\u304b\u3089r\u306e\u4e2d\u3067\u306ey\u306e\u3068\u308a\u3046\u308b\u5024\u3092\u30bd\u30fc\u30c8\n        for i in range(r-l-K+1):\n            sq = (xy[r-1][0] - xy[l][0]) * (y[i+K-1][1] - y[i][1])  # \u4e0b\u304b\u3089K\u3053\u9078\u3093\u3060\u3068\u304d\u306e\u9762\u7a4d\n            ans = min(ans, sq)\nprint(ans)\n", "import sys\n\ninf = float('inf')\n\nn, k, *xy = map(int, sys.stdin.read().split())\nxy = list(zip(*[iter(xy)] * 2))\n\ndef main():\n    xy.sort(key=lambda x: x[0])\n    x = []\n    y = []\n    for i in range(n):\n        x.append(xy[i][0])\n        y.append(xy[i][1])\n    \n    area = inf\n    for l in range(n-k+1):\n        for r in range(l+k-1, n):\n            dx = x[r] - x[l]\n            seq_y = sorted(y[l:r+1])\n            m = r - l + 1\n            for d in range(m-k+1):\n                for u in range(d+k-1, m):\n                    dy = seq_y[u] - seq_y[d]\n                    area = min(area, dx * dy)\n\n    return area\n\ndef __starting_point():\n    ans = main()\n    print(ans)\n__starting_point()", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\n\nXY.sort(key=lambda x: x[0])\n\nans = float(\"INF\")\nfor i in range(N):\n    for j in range(i+K-1, N):\n        W = XY[j][0] - XY[i][0]\n        Y = [XY[x][1] for x in range(i, j+1)]\n        Y.sort()\n        for l, k in zip(Y, Y[K-1:]):\n                H = k - l\n                ans = min(ans, W*H)\n\nprint(ans)", "#075_D\nn, k = map(int, input().split())\nxy = [tuple(map(int, input().split())) for _ in range(n)]\nans = 10 ** 50\nxy.sort()\nfor l in range(0, n):\n    for r in range(l+k-1, n):\n        y = [xy[i][1] for i in range(l, r+1)]\n        y.sort()\n        h = 10 ** 50\n        for i in range(len(y)-k+1):\n            h = min(h, y[i+k-1] - y[i])\n        ans = min(ans, h * (xy[r][0] - xy[l][0]))\nprint(ans)", "n,k = map(int,input().split())\nary = [list(map(int,input().split())) for _ in range(n)]\nary.sort()\n\nans = float(\"Inf\")\nfor i in range(n-k+1):\n    for j in range(k,n-i+1):\n        xmin = ary[i][0]\n        xmax = ary[i+j-1][0]\n        ary_y = sorted(ary[i:i+j], key=lambda x: (x[1]))\n        for l in range(len(ary_y)-k+1):\n            ymin = ary_y[l][1]\n            ymax = ary_y[l+k-1][1]\n            ans = min(ans,(xmax - xmin) * (ymax - ymin))\nprint(ans)", "from itertools import combinations\ndef main():\n    N, K = list(map(int, input().split()))\n    P = [list(map(int, input().split())) for _ in range(N)]\n    ans = 1<<62\n    for t in combinations(P, min(4, K)):\n        xs, ys = list(zip(*t))\n        xmin = min(xs)\n        xmax = max(xs)\n        ymin = min(ys)\n        ymax = max(ys)\n        area = (xmax-xmin) * (ymax-ymin)\n        if ans < area:\n            continue\n        k = 0\n        for x, y in P:\n            if xmin <= x <= xmax and ymin <= y <= ymax:\n                k += 1\n        if k >= K:\n            ans = area\n    print(ans)\n\nmain()\n", "N, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\ncand = []\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        cand.append(min(dx * (YY[j + K - 1] - YY[j]) for j in range(k - K + 1)))\n\nprint(min(cand))", "import sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, K, *XY = list(map(int, read().split()))\n\n    X = set()\n    Y = set()\n    for i, (x, y) in enumerate(zip(*[iter(XY)] * 2)):\n        X.add(x - 1)\n        Y.add(y - 1)\n\n    X = sorted(X)\n    Y = sorted(Y)\n\n    P, Q = len(X), len(Y)\n\n    G = [[0] * Q for _ in range(P)]\n    for x, y in zip(*[iter(XY)] * 2):\n        G[bisect_left(X, x - 1)][bisect_left(Y, y - 1)] = 1\n\n    csum = [[0] * (Q + 1) for _ in range(P + 1)]\n    for i in range(P):\n        for j in range(Q):\n            csum[i + 1][j + 1] = csum[i + 1][j] + csum[i][j + 1] - csum[i][j] + G[i][j]\n\n    ans = -1\n    for x1 in range(P):\n        for x2 in range(x1, P + 1):\n            for y1 in range(Q):\n                for y2 in range(y1, Q + 1):\n                    if csum[x2][y2] - csum[x1][y2] - csum[x2][y1] + csum[x1][y1] >= K:\n                        if ans > (X[x2 - 1] - X[x1]) * (Y[y2 - 1] - Y[y1]) or ans == -1:\n                            ans = (X[x2 - 1] - X[x1]) * (Y[y2 - 1] - Y[y1])\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import accumulate\nn, k = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(n)]\nX, Y = zip(*XY)\ndef compress(arr):\n    *XS, = set(arr)\n    XS.sort()\n    return {e: i+1 for i, e in enumerate(XS)}\nXlabel = compress(X)\nYlabel = compress(Y)\nrX = {j:i for i,j in Xlabel.items()}\nrY = {j:i for i,j in Ylabel.items()}\nlX = len(Xlabel)\nlY = len(Ylabel)\nF = [[0]*(lX+1) for _ in range(lY+1)]\nfor x, y in XY:\n  F[Ylabel[y]][Xlabel[x]] = 1\nfor i in range(lY):\n  F[i+1] = list(accumulate(F[i+1]))\nF = list(zip(*F))\nfor j in range(lY):\n  F[j+1] = list(accumulate(F[j+1]))\nF = list(zip(*F))\nans = float(\"inf\")\nfor y1 in range(lY):\n  for y2 in range(y1+1, lY+1):\n    for x1 in range(lX):\n      for x2 in range(x1+1, lX+1):\n        count = F[y2][x2] - F[y1][x2] - F[y2][x1] + F[y1][x1]\n        if count >= k:\n          temp = (rX[x2]-rX[x1+1]) * (rY[y2]-rY[y1+1])\n          ans = min(ans, temp)\nprint(ans)", "N, K = list(map(int, input().split()))\nXY = []\nX = []\nY = []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    XY.append((x, y))\n    X.append(x)\n    Y.append(y)\nX.sort()\nY.sort()\nix = {v: i for i, v in enumerate(X)}\niy = {v: i for i, v in enumerate(Y)}\nm = [[0] * (len(X) + 1) for _ in range(len(Y) + 1)]\nfor x, y in XY:\n    m[iy[y] + 1][ix[x] + 1] += 1\nfor y in range(len(Y) + 1):\n    for x in range(len(X)):\n        m[y][x + 1] += m[y][x]\nfor x in range(len(X) + 1):\n    for y in range(len(Y)):\n        m[y + 1][x] += m[y][x]\nans = float(\"inf\")\nfor x0 in range(len(X) - 1):\n    for x1 in range(x0 + 1, len(X)):\n        for y0 in range(len(Y) - 1):\n            for y1 in range(y0 + 1, len(Y)):\n                n = m[y1 + 1][x1 + 1] - m[y0][x1 + 1] - \\\n                    m[y1 + 1][x0] + m[y0][x0]\n                if n >= K:\n                    s = (X[x1] - X[x0]) * (Y[y1] - Y[y0])\n                    ans = min(ans, s)\nprint(ans)\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, atan, degrees\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\nfrom bisect import bisect\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, K = MAP()\nxy = [LIST() for _ in range(N)]\nans = INF\nxy.sort()\nfor l in range(N-K+1):  # \u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u6700\u3082\u5de6\u306e\u70b9\n    for r in range(l+K, N+1):  # \u9577\u65b9\u5f62\u306b\u542b\u307e\u308c\u308b\u6700\u3082\u53f3\u306e\u70b9\n        y = sorted(xy[l:r], key = lambda x: x[1])  # l\u304b\u3089r\u306e\u4e2d\u3067\u306ey\u306e\u3068\u308a\u3046\u308b\u5024\u3092\u30bd\u30fc\u30c8\n        for i in range(r-l-K+1):\n            sq = (xy[r-1][0] - xy[l][0]) * (y[i+K-1][1] - y[i][1])  # \u4e0b\u304b\u3089K\u3053\u9078\u3093\u3060\u3068\u304d\u306e\u9762\u7a4d\n            ans = min(ans, sq)\nprint(ans)\n", "n,k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nax = sorted(a)\nans = 10**19\nfor i in range(n-1):\n    for j in range(i+1,n):\n        a_use = ax[i:j+1]\n        xnum = len(a_use)\n        sx = a_use[-1][0]-a_use[0][0]\n        a_use.sort(key = lambda x:x[1])\n        if xnum<k:\n            continue\n        for y1 in range(xnum-k+1):\n            y2 = y1+k-1\n            s = sx*(a_use[y2][1]-a_use[y1][1])\n            ans = min(ans,s)\nprint(ans)", "N,K,*xy = map(int, open(0).read().split())\n_x_ = sorted(xy[::2])\nans = 4 * 10 ** 18\nfor _x in _x_:\n  for x_ in _x_[1:]:\n    w = x_ - _x\n    c = 0\n    _h_ = []\n    for x, y in zip(xy[::2], xy[1::2]):\n      if _x <= x <= x_:\n        c += 1\n        _h_.append(y)\n      if c >= K:\n        _h_.sort()\n        h = min(_h_[i + K - 1] - _h_[i] for i in range(c - K + 1))\n        ans = min(ans, h * w)\n\nprint(ans)", "import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    n, k = ns()\n    pos = []\n    for _ in range(n):\n        x, y = ns()\n        pos.append((x, y))\n\n    ans = INF\n    for tmp in itertools.combinations_with_replacement(pos, 4):\n        xl = max(tmp, key=lambda t: t[0])[0]\n        xs = min(tmp, key=lambda t: t[0])[0]\n        yl = max(tmp, key=lambda t: t[1])[1]\n        ys = min(tmp, key=lambda t: t[1])[1]\n\n        cnt = 0\n        for xi, yi in pos:\n            if xs <= xi <= xl and ys <= yi <= yl:\n                cnt += 1\n        if cnt >= k:\n            ans = min(ans, (xl - xs) * (yl - ys))\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    inf=10**20\n    n,k=map(int,readline().split())\n    co=[list(map(int,readline().split())) for _ in range(n)]\n    \n    co.sort()\n    \n    x_range=[]\n    for i in range(n-1):\n        for j in range(i+1,n):\n            x_range.append((co[i][0],co[j][0]))\n\n    co.sort(key=lambda x:x[1])\n    ans=inf\n    for x in x_range:\n        x_min=x[0]\n        x_max=x[1]\n        y_min=0\n        y_max=0\n        for under in range(n):\n            cnt=0\n            for i in range(under,n):\n                if x_min<=co[i][0]<=x_max:\n                    if cnt==0:\n                        y_min=co[i][1]\n                        cnt+=1\n                    else:\n                        y_max=co[i][1]\n                        cnt+=1\n                if cnt==k:\n                    break\n            if cnt==k:\n                ans=min(ans,(x_max-x_min)*(y_max-y_min))\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import collections, itertools, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    N, K = LI()\n    xy = [LI() for _ in range(N)]\n\n    # \u5168\u3066\u306e\u9577\u65b9\u5f62\u5019\u88dc\u306b\u5bfe\u3057\u3066\u30012\u6b21\u5143\u7d2f\u7a4d\u548c\u3092\u4f7f\u3063\u3066\u5185\u90e8\u306e\u70b9\u306e\u500b\u6570\u3092\u7b97\u51fa\u3059\u308b\n    x_coord = [i[0] for i in xy]\n    x_coord.sort()\n    x_val_num = {x_coord[i]: i for i in range(N)}\n    y_coord = [i[1] for i in xy]\n    y_coord.sort()\n    y_val_num = {y_coord[i]: i for i in range(N)}\n\n    # 2\u6b21\u5143\u7d2f\u7a4d\u548c\u306e\u8a08\u7b97\n    xy_cnt = [[0] * N for _ in range(N)]\n    for x, y in xy:\n        xy_cnt[y_val_num[y]][x_val_num[x]] = 1\n    # for i in xy_cnt:\n    #     print(i)\n    xy_acm = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(N):\n        for j in range(N):\n            xy_acm[i+1][j+1] = xy_cnt[i][j] + xy_acm[i+1][j] + xy_acm[i][j+1] - xy_acm[i][j]\n    # for i in xy_acm:\n    #     print(i)\n\n    ans = INF\n    for yl, yu in itertools.combinations(list(range(N + 1)), 2):\n        for xl, xu in itertools.combinations(list(range(N + 1)), 2):\n            cnt = xy_acm[yu][xu] - xy_acm[yu][xl] - xy_acm[yl][xu] + xy_acm[yl][xl]\n            # print(cnt, yl, yu, xl, xu)\n            if cnt >= K:\n                ans = min((x_coord[xu-1] - x_coord[xl]) * (y_coord[yu-1] - y_coord[yl]), ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,K = map(int,input().split())\nxy = []\nfor i in range(N):\n  xy.append(tuple(map(int,input().split())))\nxy=sorted(xy,key=lambda x : x[0])\nlst=[]\nfor left in  range(0,N-K+1):\n  for  right in range(left+K-1,N):\n    W = xy[right][0] - xy[left][0]\n    temp = sorted(xy[left:right+1], key =  lambda x :x[1])\n    for bottom in range(0,right-left+1-K+1):\n      H = temp[bottom+K-1][1]-temp[bottom][1]\n      lst.append(H*W)\nprint(min(lst))", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\nXY.sort()\nr = 10**20\nfor xi0 in range(N - K + 1):\n  for xi1 in range(K + xi0 - 1, N):\n    x = XY[xi1][0] - XY[xi0][0]\n    XY_ys = sorted(XY[xi0:xi1 + 1], key=lambda a: a[1])\n    for yi0 in range(len(XY_ys) - K + 1):\n      y = XY_ys[yi0 + K - 1][1] - XY_ys[yi0][1]\n      r = min(r, x * y)\nprint(r)", "N,K = map(int,input().split())\nA = sorted([list(map(int,input().split()))for n in range(N)])\nans = float(\"inf\")\n\nfor i in range(N-K+1):\n  for j in range(i+K-1,N):\n    P = A[j][0]-A[i][0]\n    C = sorted([a[1] for a in A[i:j+1]])\n    for k in range(j-i-K+2):\n      Q = C[k+K-1]-C[k]\n      ans = min(ans,P*Q)\n\nprint(ans)", "import sys\nI = lambda:[int(x) for x in sys.stdin.readline().split()]\nN,K = I()\nZ = [I() for _ in range(N)]\nZ.sort()\n\nINF = 10**20\nans = INF\n\nfor i in range(N):\n    for j in range(i+K-1,N):\n        l = sorted(t[1] for t in Z[i:j+1])\n        ans_tmp = [(Z[j][0]-Z[i][0])*(v-u) for u,v in zip(l,l[K-1:])]\n        ans = min(ans,*ans_tmp)\nprint(ans)\n", "# coding: utf-8\n# Your code here!\nN,K=list(map(int,input().split()))\n\npoint=[]\nfor _ in range(N):\n    point.append(list(map(int,input().split())))\n\npoint.sort(key=lambda x: x[0])\n\nshin=10**200\nable=N-K\nfor i in range(able+1):\n    temp_high=point[:N-i]\n    for j in range(able+1-i):\n        temp_low=temp_high[j:]\n        for k in range(able+1-i-j):\n            temp_left=temp_low[:]\n            temp_left.sort(key=lambda x: x[1])\n            temp_left=temp_left[k:len(temp_left)-(able+1-i-j)+k+1]\n            #print(i,j,k)\n            #print(temp_left)\n            if temp_left:\n                ans=temp_left[:]\n            elif temp_low:\n                ans=temp_low[:]\n            else:\n                ans=temp_high[:]\n            x=[]\n            y=[]\n            for item in ans:\n                x.append(item[0])\n                y.append(item[1])\n            #print(x)\n            #print(y)\n            num=((max(x)-min(x))*(max(y)-min(y)))\n            shin=min(shin,num)\n\nprint(shin)\n\n\n", "import sys\nimport itertools\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nXY = [lr() for _ in range(N)]\nXY.sort()\nanswer = float('inf')\n# \u7aef\u306e4\u70b9\u3001\u307e\u305a\u306fx\u8ef8\u306e2\u70b9\u3092\u9078\u3076\nfor left,right in itertools.combinations(range(N),2):\n  width = XY[right][0] - XY[left][0]\n  pts = sorted(XY[left:right+1], key = lambda xy: xy[1])\n  for D in range(len(pts)):\n    if D + K - 1 >= len(pts):\n      break\n    y_max = pts[D+K-1][1]\n    y_min = pts[D][1]\n    area = (y_max - y_min) * width\n    if area < answer:\n      answer = area\n    \nprint(answer)", "from collections import defaultdict\ndef main():\n  n,k=list(map(int,input().split()))\n  xy=[list(map(int,input().split())) for _ in range(n)]\n  x=[p[0] for p in xy]\n  y=[p[1] for p in xy]\n  x.sort()\n  y.sort()\n  \n  s1=[[0]*n for _ in range(n)]\n  s2=[[0]*n for _ in range(n)]\n  s3=[[0]*n for _ in range(n)]\n  s4=[[0]*n for _ in range(n)]\n  for i in range(n):\n    for j in range(n):\n        for p in xy:\n            if p[0]<=x[i] and p[1]<=y[j]:\n              s1[i][j]+=1\n              s2[i][j]+=(p[0]<x[i])\n              s3[i][j]+=(p[1]<y[j])\n              s4[i][j]+=(p[0]<x[i])*(p[1]<y[j])\n  ans=float('inf')\n  for s in range(n):\n    for t in range(s+1,n):\n      for u in range(n):\n        for v in range(u+1,n):\n          if s1[t][v]-s3[t][u]-s2[s][v]+s4[s][u]>=k:\n            ans=min(ans,(x[t]-x[s])*(y[v]-y[u]))\n  print(ans)\n\ndef __starting_point():\n  main()\n\n__starting_point()", "n,K = map(int,input().split())\nd = [[int(i) for i in input().split()] for _ in range(n)]\nx = sorted(d,key=lambda x:x[0])\ny = sorted(d,key=lambda x:x[1])\nans = float(\"inf\")\n\nfor i in range(n):\n    for j in range(i+1,n):\n        for k in range(n):\n            cnt = 0\n            for l in range(k,n):\n                if x[i][0] <= y[l][0] <= x[j][0]: cnt += 1\n                if cnt == K:\n                    dx = x[j][0]-x[i][0]\n                    dy = y[l][1]-y[k][1]\n                    ans = min(ans, dx*dy)\n                    break\nprint(ans)", "N, K, *XY = map(int, open(0).read().split())\n\nX, Y = zip(*sorted(zip(*[iter(XY)] * 2)))\n\ncand = []\nfor k in range(K, N + 1):\n    for i in range(N - k + 1):\n        dx = X[i + k - 1] - X[i]\n        YY = sorted(Y[i:i + k])\n        cand += [min(dx * (YY[j + K - 1] - YY[j]) for j in range(k - K + 1))]\n\nprint(min(cand))", "from itertools import combinations\n\nn,k = map(int,input().split())\nxy = [list(map(int,input().split())) + [i] for i in range(n)]\nx_order = sorted(xy)\ny_order = sorted(xy,key = lambda x:x[1])\n\npos = [[None]*2 for _ in range(n)]\n\nfor i,(x,y,j) in enumerate(x_order):\n    pos[j][0] = i\nfor i,(x,y,j) in enumerate(y_order):\n    pos[j][1] = i\n\ncount = [[0] * (n+1) for _ in range(n+1)]\n\nfor x,y in pos:\n    count[y+1][x+1] += 1\n\nfor i in range(n+1):\n    for j in range(1,n+1):\n        count[i][j] += count[i][j-1]\n\nfor i in range(n+1):\n    for j in range(1,n+1):\n        count[j][i] += count[j-1][i]\n\nans = float('inf')\nfor x1,x2 in combinations(range(1,n+1),2):\n    for y1,y2 in combinations(range(1,n+1),2):\n        if count[y2][x2] - count[y2][x1-1] - count[y1-1][x2] + count[y1-1][x1-1] >=k:\n            S = (x_order[x2-1][0] - x_order[x1-1][0]) * (y_order[y2-1][1] - y_order[y1-1][1])\n            ans = min(ans, S)\nprint(ans)", "n,k = map(int,input().split())\npoints = []\nfor _ in range(n):\n  x,y = map(int,input().split())\n  points.append((x,y))\n\npoints.sort()\nans = float('inf')\n\nfor i in range(n-k+1):\n  for j in range(i+k-1,n):\n    y_sorted = sorted(points[i:j+1], key = lambda x:x[1])\n    height_min = float('inf')\n    for l in range(j-i-k+2):\n      height_min = min(height_min,y_sorted[l+k-1][1] - y_sorted[l][1])\n    ans = min(ans, (points[j][0]-points[i][0])*height_min)\nprint(ans)", "import sys\nimport itertools\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nXY = [lr() for _ in range(N)]\nXY.sort()\nanswer = float('inf')\n# \u7aef\u306e4\u70b9\u3001\u307e\u305a\u306fx\u8ef8\u306e2\u70b9\u3092\u9078\u3076\nfor left,right in itertools.combinations(range(N),2):\n  width = XY[right][0] - XY[left][0]\n  pts = sorted(XY[left:right+1], key = lambda xy: xy[1])\n  if len(pts) < K:\n    continue\n  for D in range(len(pts) - K + 1):\n    y_max = pts[D+K-1][1]\n    y_min = pts[D][1]\n    area = (y_max - y_min) * width\n    if area < answer:\n      answer = area\n    \nprint(answer)", "N,K=list(map(int,input().split()))\npoint=[tuple(map(int,input().split())) for i in range(N)]\npoint.sort(key=lambda x:x[0])\nans=float('inf')\nfor i in range(1+N-K):\n    for j in range(i+K,N+1):\n        x=point[j-1][0]-point[i][0]\n        now=point[i:j]\n        now.sort(key=lambda x:x[1])\n        for k in range(j-i-K+1):\n            ans=min(x*(now[k+K-1][1]-now[k][1]),ans)\nprint(ans)\n", "def main():\n    N,K = map(int,input().split())\n    XY = [list(map(int,input().split())) for _ in [0]*N]\n    \n    iX = sorted(x for x,y in XY)\n    iY = sorted(y for x,y in XY)\n    X = {x:i for i,x in enumerate(iX)}\n    Y = {y:i for i,y in enumerate(iY)}\n\n    c = [[0]*(N+1) for i in [0]*(N+1)]\n    for x,y in XY:\n        c[Y[y]+1][X[x]+1] = 1\n\n    for i in range(N):\n        ci1 = c[i+1]\n        for j in range(N):\n            ci1[j+1] += ci1[j]\n    for i in range(N):\n        ci1 = c[i+1]\n        ci = c[i]\n        for j in range(N):\n            ci1[j+1] += ci[j+1]\n\n    ans = 10**20\n    for u in range(N):\n        for d in range(u+K-1,N):\n            l = 0\n            r = 1\n            dY = iY[d]-iY[u]\n            cd = c[d+1]\n            cu = c[u]\n            while r<N:\n                if cd[r+1]+cu[l]-cu[r+1]-cd[l] >=K:\n                    ans = min(ans, (iX[r] - iX[l])*dY)\n                    l+=1\n                else:r+=1\n\n    print(ans)\nmain()", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\n\nXY.sort(key=lambda x: x[0])\n\nans = float(\"INF\")\nfor i in range(N):\n    for j in range(i+K-1, N):\n        W = XY[j][0] - XY[i][0]\n        Y = [XY[x][1] for x in range(i, j+1)]\n        Y.sort()\n        for k in range(len(Y)-K+1):\n            H = Y[k+K-1] - Y[k]\n            ans = min(ans, W*H)\n\nprint(ans)", "import sys\nimport itertools\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\nXY = [lr() for _ in range(N)]\nXY.sort()\nanswer = float('inf')\n# \u7aef\u306e4\u70b9\u3001\u307e\u305a\u306fx\u8ef8\u306e2\u70b9\u3092\u9078\u3076\nfor left,right in itertools.combinations(list(range(N)),2):\n  xleft = XY[left][0]\n  xright = XY[right][0]\n  pts = sorted(XY[left:right+1], key = lambda xy: xy[1])\n  if len(pts) < K:\n    continue\n  for D in range(len(pts) - K + 1):\n    y_max = pts[D+K-1][1]\n    y_min = pts[D][1]\n    area = (y_max - y_min) * (xright - xleft)\n    if area < answer:\n      answer = area\n    \nprint(answer)\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    n, k = MI()\n    xy = []\n    xx = []\n    yy = []\n    for _ in range(n):\n        x, y = MI()\n        xy.append([x, y])\n        xx.append(x)\n        yy.append(y)\n    xx.sort()\n    yy.sort()\n    #print(xx)\n    #print(yy)\n    xtoi = {x: i for i, x in enumerate(xx)}\n    ytoj = {y: j for j, y in enumerate(yy)}\n    cs2d = [[0] * (n + 1) for _ in range(n + 1)]\n    for x, y in xy:\n        i, j = xtoi[x], ytoj[y]\n        cs2d[i + 1][j + 1] = 1\n    #p2D(cs2d)\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            cs2d[i][j] += cs2d[i][j - 1]\n    for j in range(1, n + 1):\n        for i in range(1, n + 1):\n            cs2d[i][j] += cs2d[i-1][j]\n    #p2D(cs2d)\n    ans = 10 ** 20\n    for ri in range(n):\n        r = xx[ri]\n        for li in range(ri):\n            l = xx[li]\n            for ti in range(n):\n                t = yy[ti]\n                for bi in range(ti):\n                    b = yy[bi]\n                    cnt = cs2d[ri+1][ti+1]-cs2d[ri+1][bi]-cs2d[li][ti+1]+cs2d[li][bi]\n                    if cnt >= k:\n                        s = (r - l) * (t - b)\n                        if s < ans: ans = s\n    print(ans)\n\nmain()\n", "def main():\n    N, K = list(map(int, input().split(' ')))\n    points = [list(map(int, input().split(' '))) for _ in range(N)]\n    points.sort(key=lambda p: p[1])\n    ans = 10**19\n    for b in range(N):\n        bottom = points[b][1]\n        for t in range(b + K - 1, N):\n            top = points[t][1]\n            target_points = points[b:(t+1)].copy()\n            target_points.sort(key=lambda p: p[0])\n            M = len(target_points)\n            for left in range(M):\n                right = left + K - 1\n                if right >= M:\n                    break\n                width = target_points[right][0] - target_points[left][0]\n                ans = min([ans, width * (top - bottom)])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k= map(int,input().split())\ngrid=[]\ngridx=set()\ngridy=set()\nfor i in range(n):\n    x,y= map(int,input().split())\n    grid.append((x,y))\n    gridx.add(x)\n    gridy.add(y)\ngridxl = sorted(gridx)\nxlen = len(gridxl)\ngridyl = sorted(gridy)\nylen = len(gridyl)\natable = [[0 for _ in range(ylen+1)] for _ in range(xlen+1)]\nfor i in range(n):\n    (px,py) = grid[i]\n    xid = gridxl.index(px)\n    yid = gridyl.index(py)\n    atable[yid+1][xid+1]=1\nfor i in range(1,ylen+1):\n    for j in range(1,xlen+1):atable[i][j]+=atable[i][j-1]\nfor j in range(1,xlen+1):\n    for i in range(1,ylen+1):atable[i][j]+=atable[i-1][j]\ngmin = 99999999999999999999\nfor x1 in range(1,xlen):\n    for x2 in range(x1,xlen+1):\n        for y1 in range(1,ylen):\n            for y2 in range(y1,ylen+1):\n                a = atable[y2][x2]\n                b = atable[y1-1][x2]\n                c = atable[y2][x1-1]\n                d = atable[y1-1][x1-1]\n                rui = a - b - c + d\n                if rui>=k:\n                    r = (gridxl[x2-1]-gridxl[x1-1])*(gridyl[y2-1]-gridyl[y1-1])\n                    if gmin>r:\n                        gmin = min(gmin,r)                  \nprint(gmin)", "N, K = list(map(int, input().split()))\nXY = [list(map(int, input().split())) for _ in range(N)]\nx_sort = sorted(XY, key=lambda x: x[0])\n\n\ndef check(l, r, b, t):\n    cnt = 0\n    for x, y in XY:\n        if r >= x and x >= l and t >= y and b >= y:\n            cnt += 1\n    return cnt >= K\n\n\nans = 10**20\n\nfor i in range(N - K + 1):\n    xl = x_sort[i][0]\n    for j in range(i + K - 1, N):\n        dx = x_sort[j][0] - xl\n\n        points = sorted(x_sort[i: j+1], key=lambda x: x[1])\n\n        rest = j - i + 1\n        for p in range(rest - K + 1):\n            yd = points[p][1]\n            for q in range(p + K - 1, rest):\n                dy = points[q][1] - yd\n                ans = min(ans, dx*dy)\n\nprint(ans)\n", "N, K = map(int, input().split())\nXY = [list(map(int, input().split())) for _ in range(N)]\nXY.sort()\nX, Y = zip(*XY)\nr = 10**20\nfor x0 in range(N - K + 1):\n  for x1 in range(K + x0 - 1, N):\n    Ys = sorted(Y[x0:x1 + 1])\n    for y0 in range(len(Ys) - K + 1):\n      r = min(r, (X[x1] - X[x0]) * (Ys[y0 + K - 1] - Ys[y0]))\nprint(r)"]
["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\n\n\ndef main():\n    n,m,ta,tb,k = LI()\n    a = LI()\n    b = LI()\n    if k >= n or k >= m:\n        return -1\n\n    r = 0\n    bi = 0\n    for i in range(k+1):\n        c = a[i] + ta\n        while bi < m and b[bi] < c:\n            bi += 1\n\n        if bi + (k-i) >= m:\n            return -1\n        t = b[bi + (k-i)] + tb\n        if r < t:\n            r = t\n\n    return r\n\n\nprint(main())\n\n", "from bisect import bisect_left as bl\nn, m, t1, t2, k = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nB = [int(a)-t1 for a in input().split()]\n\nif min(n, m) <= k:\n    print(-1)\nelse:\n    ma = -1\n    for i in range(k+1):\n        x = bl(B, A[i]) + k - i\n        if x >= m:\n            print(-1)\n            break\n        ma = max(ma, B[x]+t1+t2)\n    else:\n        print(ma)\n", "from bisect import bisect_left\n\n(n, m, ta, tb, k) = (int(x) for x in input().split())\na = [int(_) for _ in input().split()]\nb = [int(_) for _ in input().split()]\n\n# ans = b[-1] + tb # last flight\nans = 0\n\nif len(a) <= k or len(b) <= k:\n    print(-1)\n    return\n\nfor i in range(k + 1):\n    v = bisect_left(b, a[i] + ta)\n    if v + (k - i) < len(b):\n        ans = max(ans, b[v + (k - i)] + tb)\n    else:\n        print(-1)\n        return\n\nprint(ans)\n", "import sys\nfrom bisect import bisect_left as bl\nn, m, ta, tb, k = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\nB = list(map(int, input().split())) + [10**10]*(k+1)\n\nif min(len(A), len(B)) <= k:\n    print(-1)\n    return\n\nans = -1\nfor i, a in enumerate(A[:k+1]):\n    xi = bl(B, a+ta)\n    ans = max(ans, B[xi+k-i]+tb)\nif ans >= 10**10:\n    print(-1)\n    return\nprint(ans)\n", "from bisect import bisect_left\nn, m, ta, tb, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nif n <= k:\n    print(-1)\n    return\n\nma = 0\nfor i in range(k + 1):\n    p = a[i]\n    q = k - i\n    j = bisect_left(b, p + ta)\n    if j + q >= m:\n        print(-1)\n        return\n\n    ma = max(ma, b[j + q] + tb)\n\nprint(ma)\n", "from bisect import bisect_left\n\ndef main():\n    buf = input()\n    buflist = buf.split()\n    n = int(buflist[0])\n    m = int(buflist[1])\n    ta = int(buflist[2])\n    tb = int(buflist[3])\n    k = int(buflist[4])\n    buf = input()\n    buflist = buf.split()\n    a = list(map(int, buflist))\n    buf = input()\n    buflist = buf.split()\n    b = list(map(int, buflist))\n    if k >= n or k >= m:\n        print(-1) # cancel all\n        return\n    if bisect_left(b, a[0] + ta) == len(b):\n        print(-1) # no flight from B to C\n        return\n    latest_arrival = b[bisect_left(b, a[0] + ta)] + tb\n    for i in range(0, k+1):\n        if bisect_left(b, a[i] + ta) + (k - i) >= len(b):\n            print(-1) # no flight from B to C\n            return\n        arrival = b[bisect_left(b, a[i] + ta) + (k - i)] + tb\n        if arrival > latest_arrival:\n            latest_arrival = arrival\n    print(latest_arrival)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m,ta,tb,k=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nland=a[0]+ta\nind=0\nwhile b[ind]<land and ind<m-1:\n    ind+=1\nif ind+k>=m:\n    print(-1)\nelif k>=n:\n    print(-1)\nelif a[k]+ta>b[-1]:\n    print(-1)\nelse:\n    froma=k\n    best=0\n    land=a[k]+ta\n    while b[ind]<land:\n        ind+=1\n    for i in range(k+1):\n        best=max(best,b[ind+k-froma]+tb)\n        froma-=1\n        land=a[froma]+ta\n        while b[ind-1]>=land and ind>0:\n            ind-=1\n    print(best)", "n,m,ta,tb,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nimport bisect\nmaxtime=0\nflag=0\nif k>=n or k>=m:\n    print(-1)\nelse :\n    for i in range(n):\n        a[i]+=ta\n    for j in range(0,k+1):\n        \n        x=bisect.bisect_left(b,a[j])\n        if x+(k-j)>=m:\n            flag=1\n            break\n        else :\n            maxtime=max(maxtime,b[x+(k-j)]+tb)\n    if flag==0:\n        print(maxtime)\n    else :\n        print(-1)\n    \n        \n", "from bisect import bisect_left\n\nn,m,ta,tb,k=list(map(int, input().split()))\na=[int(x)+ta for x in input().split()]\nb=[int(x) for x in input().split()]\nif k >= len(a) or k >= len(b):\n    print(-1)\n    raise SystemExit(0)\n\n\ndef find_ge(a, x):\n    i = bisect_left(a, x)\n    if i != len(a):\n        return i\n    return None\n\nans = 0\nfor i in range(k + 1):\n    t=a[i]\n    j = find_ge(b, t)\n    # print(t, b[j])\n    if j is None:\n        print(-1)\n        raise SystemExit(0)\n    # print('Cancel ', k - i)\n    j += k - i\n    if j >= len(b):\n        print(-1)\n        raise SystemExit(0)\n    # print('b[j]', b[j])\n    # print(b[j] + tb)\n    ans = max(ans, b[j] + tb)\nprint(ans)\n", "import sys\nfrom bisect import bisect_left\n# gcd\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\n# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']\n# print(S.most_common(2))  # [('b', 5), ('c', 4)]\n# print(S.keys())  # dict_keys(['a', 'b', 'c'])\n# print(S.values())  # dict_values([3, 5, 4])\n# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])\n# from collections import Counter\n# import math\n# from functools import reduce\n#\n# fin = open('in_1.txt', 'r')\n# sys.stdin = fin\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n\ndef __starting_point():\n\n    # write code\n    n,m,ta,tb,k = mi()\n    a = lmi()\n    b = lmi()\n    if n <= k or m <= k:\n        print(-1)\n        return\n    a = [i + ta for i in a]\n    lenb = len(b)\n    a.sort()\n    b.sort()\n    # print(a)\n    ans = -10**9\n    for i in range(k+1):\n        # print(b[bisect_left(b, a[i]) + (k - i)])\n        if bisect_left(b, a[i]) + (k - i) >= lenb:\n            print(-1)\n            return\n        else:\n            ans = max(ans, b[bisect_left(b, a[i]) + (k - i)])\n    print(ans+tb)\n__starting_point()", "n,m,ta,tb,k=map(int,input().split())\nfa=list(map(int,input().split()))\nfb=list(map(int,input().split()))\nflighta=0\nflightb=0\nfor i in range(n):\n    fa[i]+=ta\nans=0\nwhile(k>=0):\n    if(flighta==n or flightb==m):\n        print(-1)\n        quit()\n    if(fb[flightb]<fa[flighta]):\n        flightb+=1\n        continue\n    if(k==0):\n        ans=max(ans,fb[flightb])\n        break\n    if(flightb+k>=m):\n        print(-1)\n        quit()\n    ans=max(fb[flightb+k],ans)\n    flighta+=1\n    k-=1\nprint(ans+tb)", "from sys import stdin\nfrom bisect import bisect_left as bl\nn,m,ta,tb,k=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\ns1=list(map(int,stdin.readline().strip().split()))\nans=-1\nfor i in range(min(k+1,n)):\n    x=s[i]+ta\n    ind=bl(s1,x)\n    y=ind+k-i\n    if y>=m:\n        ans=-1\n        break\n    if s1[y]>=x:\n        ans=max(s1[y]+tb,ans)\nif n<=k:\n    ans=-1\nprint(ans)\n    \n    \n\n\n", "t = list(map(int, input().split(\" \")))\nn = t[0]\nm = t[1]\nta = t[2]\ntb = t[3]\nk = t[4]\na = list(map(int, input().split(\" \")))\nb = list(map(int, input().split(\" \")))\nb1 = []\nj = 0\nq = 0\nfor i in range(n):\n    a[i] = a[i] + ta\n    while j<m:\n        if a[i]<=b[j]:\n            q += 1\n            b1.append(b[j])\n            j += 1\n            break\n        j += 1\nif q<=k:\n    print(-1)\nelse:\n    print(b1[k]+tb)", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n\n# from heapq import heappush, heappop\n# from collections import defaultdict\n# from math import sqrt\n# from collections import deque\n\nt = 1#int(input())\n\nfor test in range(t):\n    # n = int(input())\n    n,m,ta,tb,k = (((list(map(int, input().split())))))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        a[i] = a[i]+ta\n\n    ans = 0\n    ind = 0\n    if k>=n or k>=m:\n        print(-1)\n        continue\n    for i in range(k+1):\n        lo = a[i]\n        while ind<m and b[ind]<lo:\n            ind+=1\n        if ind==m:\n            ans = -1\n            break\n        else:\n            if ind+k-i>=m:\n                ans = -1\n                break\n            ans = max(ans, b[ind+(k-i)]+tb)\n    print(ans)\n\n    \n", "n, m, ta, tb, k = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nif k >= min(n, m):\n    print(-1)\nelse:\n    result = -1\n    for i in range(k + 1):\n        num = A[i] + ta\n        #print(i, num)\n        left = -1\n        right = m\n        while left + 1 != right:\n            mid = (left + right) // 2\n            if B[mid] >= num:\n                right = mid\n            else:\n                left = mid\n        end = right + k - i\n        if end < m:\n            result = max(result, B[end] + tb)\n        else:\n            print(-1)\n            break\n    else:\n        print(result)\n            \n", "n,m,ta,tb,k = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\n\nres = -1\nj = 0\nif k < len(A):\n    for i in range(k+1):\n        if i < len(A):\n            t = A[i] + ta\n            while j < len(B) and B[j] < t:\n                j += 1\n            togo = k - i\n            jj = j + togo\n            if jj < len(B):\n                res = max(res, B[jj] + tb)\n            else:\n                res = -1\n                break\nprint(res)\n\n\n", "from bisect import bisect_left\nn, m, ta, tb, k = map(int, input().strip().split())\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\nif k >= min(n, m):\n\tprint(-1);return()\nind_a = k\nmax_time = 0\nwhile ind_a >= 0:\n\tind_b = bisect_left(b, a[ind_a]+ta) + (k-ind_a)\n\tif ind_b >= m:\n\t\tprint(-1);return()\n\tcurr_time = b[ind_b] + tb\n\tmax_time = max(max_time, curr_time)\n\tind_a -= 1\nprint(max_time)\n", "import bisect\nimport sys\ninput = sys.stdin.readline\nn, m, ta, tb, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na = [i+ta for i in a]\n\nans = 0\nfor i in range(n):\n    cancel = k-i\n    if cancel >= 0:\n        if cancel+bisect.bisect_left(b, a[i]) >= m:\n            ans = -1\n            break\n        else:\n            ans = max(b[cancel+bisect.bisect_left(b, a[i])], ans)\n    else:\n        break\n\nif k >= min(n, m):\n    ans = -1\n\nif ans == -1:\n    print(-1)\nelse:\n    print(ans+tb)\n", "def bbin(key, b):\n    l = -1\n    r = len(b)\n    while r > l + 1:\n        mm = (l + r) // 2\n        if b[mm] >= key:\n            r = mm\n        else:\n            l = mm\n    return r\n    \n\nn, m, ta, tb, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = 0\nfor i in range(k + 1):\n    if i >= n:\n        ans = -1\n        break\n    key = a[i] + ta\n    rr = bbin(key, b) + k - i\n    if rr >= m:\n        ans = -1\n        break\n    ans = max(ans, b[rr] + tb)\nprint(ans)", "n, m, ta, tb, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nd = {}\ni = 0\nj = 0\nwhile i<n and j<m:\n    if b[j]>=a[i]+ta: d[i] = j; i+=1\n    else: j+=1\nM = 0\nfor i in range(min(n, k)+1):\n    try: M = max(M, b[d[i]+k-i]+tb)\n    except: M = -1; break\nprint(M)\n", "import bisect\nn,m,ta,tb,k=list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif (n-k)<=0 or (m-k) <= 0:\n\tprint(-1)\nelse:\n\tif n-k == 1 and a[n-1]+ta > b[m-1]:\n\t\tprint(-1)\n\telse:\n\t\td = {}\n\t\tfor i in range(n):\n\t\t\tj = bisect.bisect_left(b,a[i]+ta)\n\t\t\td[a[i]] = j\n\n\t\tma = -1\n\t\tflag = 1\n\t\tfor i in range(k,-1,-1):\n\t\t\tkr = k-i\n\t\t\tif d[a[i]]+kr >= m:\n\t\t\t\tflag = 0\n\t\t\t\tbreak\n\t\t\tif d[a[i]]+kr <= (m-1) and  b[d[a[i]] + kr]+tb > ma:\n\t\t\t\tma = b[d[a[i]]+kr] + tb\n\t\tif flag:\n\t\t\tprint(ma)\n\t\telse:\n\t\t\tprint(-1)\n\n", "n,m,ta,tb,k = list(map(int,input().split()))\nfa = list(map(int,input().split()))\nfb = list(map(int,input().split()))\narrival =[x+ta for x in fa]\ni = 0\nj = 0\nwhile(k>0):\n    next = arrival[i]\n    fb_time = fb[j]\n    while(fb_time<next):\n        j+=1\n        if j>=m:\n            print(-1)\n            return\n        fb_time= fb[j]\n    k-=1\n    i+=1\n    if i>=n:\n        print(-1)\n        return\n    j+=1\n    if j >= m:\n        print(-1)\n        return\nfb_time=arrival[i]\nfor k in range(j,m):\n    if fb_time<=fb[k]:\n        idex= k;\n        print(fb[k]+tb)\n        return\nprint(-1)\n\n\n\n\n", "from bisect import bisect_left as br\nn, m, ta, tb, k = map(int, input().split())\na = [int(e) + ta for e in input().split()]\nb = [int(e) for e in input().split()]\nif(k >= min(m, n)):\n\tprint(-1)\nelse:\n\ta.sort()\n\tb.sort()\n\t# print(*a)\n\t# print(*b)\n\tf, mx = 0, -1\n\tfor i in range(0, k + 1):\n\t\tx = br(b, a[i])\n\t\tif(x + k - i >= m):\n\t\t\tf = 1\n\t\telse:\t\n\t\t\tmx = max(mx, b[x + k - i])\n\tif(f == 1):\n\t\tprint(-1)\n\telse:\n\t\tprint(mx + tb)", "n, m, ta, tb, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na = [i+ta for i in a]\n\ni=0\nj=0\n\nans = 0\n\nfor _k in range(k+1):\n\tdk = _k\n\ti=0\n\tif dk >= n:\n\t\t# all flights in a will be cancelled\n\t\tprint(-1)\n\t\treturn\n\telse:\n\t\t# dk flights from a has been cancelled\n\t\tkey = a[dk]\n\t\tdk = k-_k\n\t\twhile j<m and b[j]<key:\n\t\t\tj+=1\n\t\t# print(\"j\", j)\n\t\tif j is m:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\telse:\n\t\t\tif m<=dk+j:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tans = max(ans, b[j+dk]+tb)\n\t# print(\"k {} | {} | {}\".format(_k, a[dk+1], b[j+dk]))\n\nprint(ans)", "import bisect\nn,m,ta,tb,k = list(map(int,input().split()))\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nflg = 0\nresult =0\nif (k >= min(m,n)):\n    flg = 1\n    print(-1)\nelse:\n    ar = [i+ta for i in a]\n    x1 = []\n    result = 0\n    for i in range(n):\n        x1.append(bisect.bisect_left(b,ar[i]))\n        if (i+m-x1[i] <= k):\n            print(-1)\n            flg = 1\n            break\n        j = k-i\n        if (j<0): break\n        result = max(result,b[x1[i]+j])\nif (flg==0): print(result+tb)\n"]
["import sys\n\nt = int(sys.stdin.readline())\n\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    intervals = [None]*n\n    for i in range(n):\n        intervals[i] = tuple([int(a) for a in sys.stdin.readline().split()])\n    intervals = list(zip(intervals, list(range(n))))\n    starts = sorted(intervals, key = lambda x: x[0][0])\n    ends   = sorted(intervals, key = lambda x: x[0][1])\n\n    connects = [0]*n\n    gaps = 0\n    covering = set()\n    atS = 0\n    atE = 0\n    # print(starts)\n    while atE<n:\n        # print(\"%d, %d\"%(atS, atE))\n        # print(covering)\n        # print(connects)\n        if atS!=n and ends[atE][0][1]>=starts[atS][0][0]:\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]+=0.5\n            covering.add(starts[atS][1])\n            atS += 1\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]-=0.5\n\n        else:\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]-=0.5\n            covering.remove(ends[atE][1])\n            atE += 1\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]+=0.5\n            if len(covering)==0:\n                gaps += 1\n    connects = [int(a) for a in connects]\n    print(max(connects)+gaps)\n\n    \n\n        \n", "import sys\nfrom collections import deque\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    segs = []\n    for i in range(n):\n        l,r = list(map(int, input().split()))\n        segs.append((l,0,i))\n        segs.append((r,1,i))\n    segs.sort()\n    active = set()\n    increase = [0 for _ in range(n)]\n    seq = []\n    ans = 0\n    for pos, p, i in segs:\n        if p == 0:\n            if len(seq)>1 and seq[-2:] == [2,1]:\n                increase[next(iter(active))]+=1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans+=1\n        seq.append(len(active))\n    m = max(increase)\n    seq = set(seq)\n    if seq == {0,1}:\n        print(ans-1)\n    else:\n        print(ans+max(increase))\n\n    \n\n\n        \n", "import sys\nfrom math import gcd\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn = mint()\n\ta = [None]*(2*n)\n\tc = [0]*(2*n)\n\tfor i in range(0,2*n,2):\n\t\tl, r = mints()\n\t\ta[i] = (l*2, 0, i)\n\t\ta[i+1] = (r*2+1, 1, i)\n\t\tc[i+1] = (l*2, r*2+1)\n\ta.sort()\n\t#print(a)\n\ts = set()\n\tp = None\n\tstart = None\n\tpx = int(-2e9-5) # prev event\n\tpt = -1\n\tpp = px\n\tsegs = []\n\tfor i in range(0, 2*n):\n\t\tx, t, id = a[i]\n\t\tif px != x:\n\t\t\t#print(px,x)\n\t\t\tcd = len(s)\n\t\t\tif cd == 1:\n\t\t\t\tsegs.append((px, x, cd, next(iter(s))))\n\t\t\telse:\n\t\t\t\tsegs.append((px, x, cd, None))\n\t\t\tpx = x\n\t\tif t == 0:\n\t\t\ts.add(id)\n\t\telse:\n\t\t\ts.remove(id)\n\tsegs.append((px,int(2e9+5), 0, None))\n\tres = 0\n\tp = False\n\tfor i in range(1,len(segs)-1):\n\t\tpx, x, cd, e = segs[i]\n\t\tif e != None:\n\t\t\tl,r = c[e+1]\n\t\t\tcl = segs[i-1][2]\n\t\t\tcr = segs[i+1][2]\n\t\t\tif cl - (segs[i-1][0] >= l) > 0 \\\n\t\t\tand cr - (segs[i-1][0] <= r) > 0:\n\t\t\t\tc[e] += 1\n\t\t\tif cl == 0 and cr == 0:\n\t\t\t\tc[e] -= 1\n\t\tif cd > 0 and p == False:\n\t\t\tres += 1\n\t\tp = (cd > 0)\n\tz = c[0]\n\tfor i in range(0, 2*n, 2):\n\t\tz = max(z, c[i])\n\tprint(res+z)\n\nfor i in range(mint()):\n\tsolve()\n", "debug = 0\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    ev = []\n    for i in range(n):\n        a, b = list(map(int, input().split()))\n        ev.append((a, -1, i))\n        ev.append((b, 1, i))\n\n    ev.sort()\n    a = set()\n    count = [0] * n\n    brks = 0\n    are_non_solo = 0\n    if debug: print (ev)\n    for j in range(2 * n):\n        t, d, i = ev[j]\n        if debug: print(a,ev[j])\n        if d == -1:\n            if a:\n                are_non_solo=1\n            a.add(i)\n        else:\n            a.remove(i)\n            if j +1 < 2 * n and ev[j+1][0] != t:\n                if len(a) == 1 and ev[j+1][1] == -1:\n                    if debug: print ('\u0105')\n                    for nn in a:\n                        count[nn] += 1\n                if len(a) == 0:\n                    brks += 1\n\n    print(max(count) + brks+are_non_solo)\n", "import sys\n \n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n \nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = []\n    for i in range(n):\n        li, ri = list(map(int, input().split()))\n        edges.append((li, 0, i))\n        edges.append((ri, 1, i))\n    edges.sort()\n    ctr = [0] * n\n    opened = set()\n    segmCtr = 0\n    for k, (e, isEnd, i) in enumerate(edges):\n        if isEnd:\n            opened.remove(i)\n            if not opened and edges[k-1][2] == i:\n                ctr[i] -= 1\n            elif len(opened) == 1 and edges[k+1][1] == 0:\n                for j in opened:\n                    ctr[j] += 1\n        else:\n            if not opened:\n                segmCtr += 1\n            opened.add(i)\n    print(segmCtr + max(ctr))\n\n# inf.close()\n", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor rwere in range(q):\n\tn = int(input())\n\tseg = []\n\tpts = []\n\tfor i in range(n):\n\t\tpocz, kon = map(int,input().split())\n\t\tseg.append([2*pocz, 2*kon])\n\t\tpts.append(2*kon+1)\n\tp,k = map(list,zip(*seg))\n\tpts += (p + k)\n\tpts.sort()\n\tind = -1\n\twhile True:\n\t\tif pts[ind] == pts[-1]:\n\t\t\tind -= 1\n\t\telse:\n\t\t\tbreak\n\tind += 1\n\tpts = pts[:ind]\n\tmapa = {}\n\tval = 0\n\tmapa[pts[0]] = val\n\tfor i in range(1, len(pts)):\n\t\tif pts[i] != pts[i-1]:\n\t\t\tval += 1\n\t\tmapa[pts[i]] = val\n\tval += 1\n\tfor i in range(n):\n\t\tseg[i] = [mapa[seg[i][0]], mapa[seg[i][1]]]\n\tseg.sort()\n\tdupa = [0] * (val+1)\n\tfor s in seg:\n\t\tdupa[s[0]] += 1\n\t\tdupa[s[1] + 1] -= 1\n\tcov = [0] * val\n\tcov[0] = dupa[0]\n\tfor i in range(1, val):\n\t\tcov[i] = cov[i-1] + dupa[i]\n\tprzyn = [0] * val\n\tcur = seg[0][0]\n\tlabel = 1\n\tfor i in range(n):\n\t\tkon = seg[i][1]\n\t\tif cur <= kon:\n\t\t\tfor j in range(cur, kon + 1):\n\t\t\t\tprzyn[j] = label\n\t\t\tlabel += 1\n\t\t\tcur = kon + 1\n\tfinal = [(przyn[i] if cov[i] == 1 else (-1 if cov[i] == 0 else 0)) for i in range(val)]\n\tbaza = final.count(-1) + 1\n\tfinal = [-1] + final + [-1]\n\tval += 2\n\tif max(final) <= 0:\n\t\tprint(baza)\n\telse:\n\t\tcomp = {}\n\t\tcomp[0] = -100000000000\n\t\tfor i in final:\n\t\t\tif i > 0:\n\t\t\t\tcomp[i] = 0\n\t\tfor i in range(1, val - 1):\n\t\t\tif final[i] > 0 and final[i] != final[i-1]:\n\t\t\t\tcomp[final[i]] += 1\n\t\t\tif final[i-1] == -1:\n\t\t\t\tcomp[final[i]] -= 1\n\t\t\tif final[i+1] == -1:\n\t\t\t\tcomp[final[i]] -= 1\n\t\tbest = -10000000000000\n\t\tfor i in comp:\n\t\t\tbest = max(best, comp[i])\n\t\tif max(final) == n:\n\t\t\tprint(baza + best)\n\t\telse:\n\t\t\tprint(max(baza + best, baza))"]
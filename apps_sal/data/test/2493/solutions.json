["n = int(input())\na = list(map(int, input().split()))\n\nb = sorted(a[::])\nfor i in range(n):\n    if b[i] == b[i+1]:\n        d = b[i]\n\nl, r = -1, -1\nfor i in range(n+1):\n    if l < 0:\n        if a[i] == d:\n            l = i\n    else:\n        if a[i] == d:\n            r = i\n\nf = [1 for _ in range(n+2)]\nf_inv = [1 for _ in range(n+2)]\nmod = 10 ** 9 + 7\nfor i in range(1, n+2):\n    f[i] = f[i-1] * i % mod\n    f_inv[i] = pow(f[i], mod-2, mod)\n\ndef comb(n, k):\n    return f[n] * f_inv[k] * f_inv[n-k] % mod\n\n\nfor k in range(1, n+2):\n    ans = 0\n\n    if k >= 2:\n        ans += comb(n-1, k-2)\n        ans %= mod\n\n    if n - 1 >= k:\n        ans += comb(n-1, k)\n        ans %= mod\n\n    if n >= k:\n        ans += 2 * comb(n-1, k-1)\n        ans %= mod\n\n    if n + l - r >= k - 1:\n        ans -= comb(n+l-r, k-1)\n        ans %= mod\n\n    print(ans)\n", "from collections import Counter\n\nn=int(input())\na=list(map(int,input().split()))\nmod = 10**9+7\n\nfactorial=[1 for i in range(n+2)]\nfor i in range(1,n+2):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i % mod\n\ndef comb(n,k):\n    return factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod)\n\nmc = Counter(a).most_common()[0][0]\n\nindices=[]\nfor i in range(n+1):\n  if a[i]==mc:indices.append(i)\n    \nm = [indices[0]+1,n+1-indices[1]]\nm = sorted(m)\n    \nfor i in range(1,n+2):\n  if i == 1:\n    print(n)\n    continue\n  if i == n+1:\n    print(1)\n    continue\n  if i <= m[0]+m[1]-1:\n    print((comb(n+1,i) - comb(m[0]+m[1]-2,i-1)) % mod)\n  else:\n    print(comb(n+1,i) % mod)", "import sys\nmod = 7 + 10 ** 9\n\ndef comb(n, r, fact, revfact, mod):\n    return (fact[n] * revfact[n-r] * revfact[r]) % mod\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    Ad = dict()\n    double = []\n    for i, a in enumerate(A):\n        if a in Ad:\n            Ad[a].append(i)\n            double = Ad[a]\n        else: Ad[a] = [i]\n\n    fact = [1] * (N + 2)\n    for i in range(1, N + 2): fact[i] = (fact[i - 1] * i) % mod\n    revfact = [1] * (N + 2)\n    revfact[N + 1] = pow(fact[N + 1], mod - 2, mod)\n    for i in reversed(range(1, N + 1)):revfact[i] = ((i + 1) * revfact[i + 1]) % mod\n    mayOverCount = double[0] + N - double[1]\n    \n    for k in range(N + 1):\n        total = comb(N + 1, k + 1, fact, revfact, mod)\n        if k <= mayOverCount: \n            total += mod - comb(mayOverCount, k, fact, revfact, mod)\n            total %= mod\n        print(total)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "from collections import Counter\nN = int(input())\nAs = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\nfactorials = [1]\nfact_invs = [1]\nfor i in range(1, N+2):\n    factorials.append((factorials[-1]*i) % MOD)\n    fact_invs.append(pow(factorials[-1], MOD-2, MOD))\nfact_invs.append(1)\n\ndef combi(n, k):\n    if n < k:\n        return 0\n    ret = factorials[n]\n    ret *= fact_invs[k]\n    ret %= MOD\n    ret *= fact_invs[n-k]\n    return ret % MOD\n\nct = Counter(As)\nmc = ct.most_common(1)[0][0]\n\nL = R = None\nfor i, a in enumerate(As):\n    if a == mc:\n        if L is None:\n            L = i\n        else:\n            R = N - i\n\nfor k in range(1, N+2):\n    print(((combi(N+1, k) - combi(L+R, k-1)) % MOD))\n", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nmod = 10**9+7\nN = 10**5 + 1\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n \nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n \nn = int(input())\nA = list(map(int,input().split()))\n \nval = sum(A) - sum(set(A))\ni = -1\nj = -1\nfor k in range(n+1):\n    if A[k] == val:\n        if i == -1:\n            i = k\n        elif j == -1:\n            j = k\n            break\nfor k in range(1,n+2):\n    print(((cmb(n+1, k, mod) - cmb(n + i - j, k - 1, mod)) % mod))\n", "#11\nfrom collections import Counter\nN = int(input())\na = list(map(int, input().split()))\n\n\nmod = 10 ** 9 + 7\nup = [1 for i in range(N+1)]\nfor i in range(2, N+1):\n    up[i] = up[i-1]*i % mod\ndown = [1 for i in range(N+1)]\ndown[N] = pow(up[N], mod-2, mod)\nfor i in range(N-1, 0, -1):\n    down[i] = (i+1)*down[i+1] % mod\n\n\ndef ncr(n, r):\n    if not n >= r >= 0:\n        return 0\n    else:\n        return up[n]*down[n-r]*down[r] % mod\n\n\nduplicated_number, _cnt = Counter(a).most_common()[0]\nindex_que = []\n\nfor i in range(N+1):\n    if a[i] == duplicated_number:\n        index_que.append(i)\n        \nA, B = min(index_que), max(index_que)\n\nfor k in range(1, N+2):\n    if k == 1:\n        print(N)\n    else:\n        ans = ncr(N-1, k-2)+ncr(N-1, k)+2 * ncr(N-1, k-1)-ncr(N-B+A, k-1)\n        print((ans % mod))\n\n", "n = int(input())\na = list(map(int, input().split()))\n\nmod = 10**9+7\ng1 = [1, 1]\ng2 = [1, 1]\ninv = [0, 1]\nfor i in range(2, n+2):\n    g1.append((g1[-1] * i) % mod)\n    inv.append((-inv[mod%i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inv[-1]) % mod)\n\ndef comb(n, r):\n    if r<0 or r>n:\n        return 0\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nt = sum(a)-n*(n+1)//2\nm = a.index(t) + a[::-1].index(t)\nfor k in range(1, n+2):\n    print((comb(n+1, k)-comb(m, k-1))%mod)", "MOD = 10 ** 9 + 7\nMAXN = 100005\nfactorial = [1]\nfor i in range(1, MAXN + 1):\n    factorial.append(factorial[-1] * i % MOD)\n\ninv_factorial = [-1] * (MAXN + 1)\ninv_factorial[-1] = pow(factorial[-1], MOD-2, MOD)\nfor i in reversed(range(MAXN)):\n    inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD\n\ndef fact(n):\n    return factorial[n]\n\ndef nck(n, k):\n    if k > n or k < 0:\n        return 0\n    else:\n        return factorial[n]*inv_factorial[n - k]*inv_factorial[k]%MOD\n\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    dic = {i:[] for i in range(1,n + 1)}\n    for i in range(n + 1):\n        dic[a[i]].append(i)\n        if len(dic[a[i]]) >= 2:\n            l,r = dic[a[i]][0],dic[a[i]][1]\n            break\n\n    r = n - r\n    print(n)\n    for i in range(2,n + 2):\n        print((nck(n + 1,i) - nck(l + r,i - 1) + MOD)%MOD)\ndef __starting_point():\n    main()\n__starting_point()", "mod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nc=[0]*n\nfor i in a:c[i-1]+=1\nind=c.index(2)\nx=[]\nfor i in range(n+1):\n    if a[i]==ind+1:x.append(i)\nm=n+x[0]-x[1]\nans=1\nanss=1\nfor k in range(1,n+2):\n    ans=(ans*(n-k+2))%mod\n    ans=ans*pow(k,mod-2,mod)%mod\n    if k==1:print(n);continue\n    anss=(anss*(m-k+2))%mod\n    anss=anss*pow(k-1,mod-2,mod)%mod\n    if k-1>m:print(ans);continue\n    print((ans-anss)%mod)", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass ModTools:\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n        inverse = [1] * MAX\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, 0, -1):\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n        if n < r: return 0\n        # 10C7 = 10C3\n        r = min(r, n-r)\n        # \u5206\u5b50\u306e\u8a08\u7b97\n        numerator = self.fact[n]\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\nN = INT()\nA = LIST()\n\n# \u91cd\u8907\u3057\u3066\u3044\u308b\u5024\u3092\u898b\u3064\u3051\u3066\u3001index\u3092\u53d6\u308b\ndup = 0\nfor k, v in list(Counter(A).items()):\n    if v == 2:\n        dup = k\n        break\nst = []\nfor i, a in enumerate(A):\n    if a == dup:\n        st.append(i)\n# \u91cd\u8907\u3057\u305f\u5024\u3088\u308a\u5916\u5074\u306b\u3042\u308b\u8981\u7d20\u6570\nM = N - (st[1] - st[0])\n\nmt = ModTools(N+1, MOD)\nfor i in range(N+1):\n    # \u5168\u7d44\u307f\u5408\u308f\u305b\u304b\u3089\u3001\u91cd\u8907\u3057\u305f\u5024\u306e\u5f71\u97ff\u3092\u53d7\u3051\u308b\u5206\u3092\u5f15\u304f\n    ans = mt.nCr(N+1, i+1) - mt.nCr(M, i)\n    print((ans % MOD))\n", "def exteuc(a, b):\n    # ax + by = gcd(a, b)\n    if b == 0:\n        return 1, 0, a\n    y, x, v = exteuc(b, a % b)\n    y -= (a//b) * x\n    return x, y, v\n\n\ndef modinv(a, mod):\n    x, _, _ = exteuc(a, mod)\n    return x % mod\n\n\ndef main():\n    MOD = 10**9 + 7\n    N = int(input())\n    A = list(map(int, input().split(' ')))\n    # calculate duplicate indices\n    # Ex. [1, 4, 2, 1, 3] -> 0, 3\n    dup_first_index, dup_second_index = -1, -1\n    indices = [-1 for _ in range(N)]\n    for i, a in enumerate(A):\n        if indices[a - 1] != -1:\n            dup_first_index, dup_second_index = indices[a - 1], i\n            break\n        indices[a - 1] = i\n    # Ex. [1, 4, 2, 5, 4, 3, 6] -> [1] + [3, 6] -> 3\n    s = dup_first_index + N - dup_second_index\n    # calculate answer\n    ans = [0 for _ in range(N + 1)]\n    comb_n1, comb_s = N + 1, 1  # comb(N + 1, 1), comb(s, 0)\n    for i in range(N + 1):\n        ans[i] = comb_n1  # comb(N + 1, i + 1)\n        comb_n1 *= (N + 1) - (i + 1)\n        comb_n1 *= modinv(i + 2, MOD)\n        comb_n1 %= MOD\n        if s >= i:\n            ans[i] -= comb_s  # comb(s, i)\n            comb_s *= s - i\n            comb_s *= modinv(i + 1, MOD)\n            comb_s %= MOD\n        ans[i] %= MOD\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nA = list(map(int, input().split()))\nidx = [-1]*(n+1)\n# 2\u56de\u73fe\u308c\u305f\u6587\u5b57\u306eidx\u3092l,r\u306b\u6301\u3064\nfor i, a in enumerate(A, 1):\n    if idx[a] == -1:\n        idx[a] = i\n    else:\n        r = i\n        l = idx[a]\n\n\nMAX_N = 10**6+5\nMOD = 10**9 + 7\nfac = [0]*(MAX_N)\nfac[0] = 1\nfor i in range(1, MAX_N):\n    fac[i] = i*fac[i-1] % MOD\nfac_inv = [0]*MAX_N\nfac_inv[-1] = pow(fac[-1], MOD-2, MOD)\nfor i in range(MAX_N-2, -1, -1):\n    fac_inv[i] = fac_inv[i+1]*(i+1) % MOD\n\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return fac[n]*fac_inv[k]*fac_inv[n-k] % MOD\n\n\n# print(comb(0, 0))\n# print(l, r)\n# print(fac[:5])\n# print(fac_inv[:5])\nfor k in range(1, n+2):\n    #    print(comb(n+1, k), comb(l-1+n-r, k-1))\n    ans = (comb(n+1, k)-comb(l-1+n+1-r, k-1)) % MOD\n    print(ans)\n", "def comb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nn=int(input())\nmod=10**9+7\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nimport copy\na=list(map(int,input().split()))\nb=copy.deepcopy(a)\nb.sort()\ntmp=-1\nfor i in range(n):\n  if b[i]==b[i+1]:\n    tmp=b[i]\nr=[]\nfor i in range(n+1):\n  if a[i]==tmp:\n    r.append(i)\ny=abs(r[1]-r[0]-1)\nfor k in range(1,n+2):\n  ans=(comb(n-1,k,mod)+comb(n-1,k-2,mod)+comb(n-1,k-1,mod)*2-comb(n-1-y,k-1,mod))%mod\n  print(ans)", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nN = int(input())\nA = [int(c) for c in input().split()]\nlog = [0]*(N+1)\nfor i in range(N+1):\n  if log[A[i]]!=0:\n    j = i\n  log[A[i]] = 1\nc = A[j]\ni = A.index(c)\nm = i+N-j\nfor k in range(1,N+2):\n  if m>=k-1:\n    x = cmb(N+1,k,mod)-cmb(m,k-1,mod)\n    print((x%mod))\n  else:\n    x = cmb(N+1,k,mod)\n    print((x%mod))\n", "mod = 10**9+7\nMAX = 10**5+1\nfact = [1]*(MAX+1)\nfor i in range(1, MAX+1):\n    fact[i] = (fact[i-1]*i)%mod\ninv = [1]*(MAX+1)\nfor i in range(2, MAX+1):\n    inv[i] = inv[mod%i]*(mod-mod//i)%mod\nfact_inv = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact_inv[i] = fact_inv[i-1]*inv[i]%mod\ndef comb(n, r):\n    if n < r:\n        return 0\n    return fact[n]*fact_inv[n-r]*fact_inv[r] % mod\n\nn = int(input())\nL = list(map(int,input().split()))\nM = []\nfor i in range(n+1):\n    M.append(L[i])\nM.sort()\ndou = 1 #\u91cd\u8907\u3059\u308b\u6570\nfor i in range(n+1):\n    if M[i] == dou:\n        dou += 1\n    else:\n        dou = M[i]\n        break\nl = 0\nr = 0\ncnt = 0\nfor i in range(n+1):\n    if L[i] == dou and cnt == 0:\n        l = i+1\n        cnt += 1\n    elif L[i] == dou and cnt == 1:\n        r = i+1\n        break\nfor i in range(1,n+1):\n    print(((comb(n+1,i)-comb(l+n-r,i-1))%mod))\nprint((1))\n", "n = int(input())\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n+1)}\nfor i in range(n+1):\n  D[a[i]][0] += 1\n  D[a[i]].append(i)\npl, pr = 0, 0\nfor i in D:\n  if D[i][0] == 2:\n    pl = D[i][1]\n    pr = D[i][2]\n    break\nL = pl\nM = pr - pl - 1\nN = n - pr\nmod = int(1e9) + 7 # <-- input modulo\nmaxf = n+11          # <-- input factional limitation\n\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[-i-1]]\n        for j in range(L[-i-1]+1, k):\n            perm[j-1] = perm[j]\n    return LL\n\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\n\ndef inved(a, modulo=mod):\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n    while l != 0:\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n        k, l = l, k % l\n    return x % modulo\n\nfact = [1 for _ in range(maxf+1)]\ninvf = [1 for _ in range(maxf+1)]\n\nfor i in range(maxf):\n    fact[i+1] = (fact[i] * (i+1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i-1] = (invf[i] * i) % mod\n\nfor i in range(1, n+2):\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n  if i <= n-M:\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n    S %= mod\n  print(S)\n", "import sys\nfrom collections import Counter\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    D = Counter(A)\n    dup = 0\n    for k, v in list(D.items()):\n        if v == 2:\n            dup = k\n            break\n\n    flg = 1\n    right, left = 0, 0\n    for i in range(n + 1):\n        if flg and A[i] == dup:\n            left = i\n            flg ^= 1\n        elif A[i] == dup:\n            right = i\n            break\n\n    remain = n - (right - left)\n    cmb = CmbMod(n + 1, mod)\n    cmb.prep()\n    for i in range(1, n + 2):\n        res = cmb.cmb_mod_with_prep(n + 1, i) - cmb.cmb_mod_with_prep(remain, i - 1)\n        print((res % mod))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "MOD = 10 ** 9 + 7\n\n\ndef prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\nN = int(input())\nplace = [0] * N\nA = list(map(int, input().split()))\nfor i, s in enumerate(A):\n    if place[s - 1] == 0:\n        place[s - 1] = i + 1\n    else:\n        a = place[s - 1]\n        b = i + 1\n        break\n\nmodFacts, invs = prepare(N + 1)\ncnt = pow(2, N + 1, MOD) - 1\ncnt -= pow(2, a - 1, MOD) * pow(2, N + 1 - b, MOD)\n\nla = a - 1\nrb = N + 1 - b\nt = la + rb\nfor k in range(1, N + 2):\n    cnt = (modFacts[N + 1] * invs[k] * invs[N + 1 - k]) % MOD\n    if t >= k - 1:\n        cnt -= (modFacts[t] * invs[k - 1] * invs[t - (k - 1)])\n    print((cnt % MOD))\n", "N = int(input())\nA = list(map(int,input().split()))\nMOD = 10**9+7\nfrom collections import Counter\nctr = Counter(A)\ndup = ctr.most_common()[0][0]\ni = A.index(dup)\nj = A[::-1].index(dup)\nl = i+j\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = []\nfor k in range(1,N+2):\n    ans.append(comb(N+1,k))\nfor k in range(l+1):\n    ans[k] -= comb(l,k)\n    ans[k] %= MOD\nprint(*ans, sep='\\n')", "# solution\n\nn = int(input())\na = list(map(int, input().split()))\nM = 10**9+7\nres = [-1] * (n+1)\nfor i in range(n+1):\n    if res[a[i]] == -1:\n        res[a[i]] = i\n    else:\n        d = a[i]\n        l, r = res[d], n-i\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\nmod = 10**9+7\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, n + 2):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\nfor i in range(1, n+2):\n    print(((cmb(n+1, i, mod)-cmb(l+r, i-1, mod)) % mod))\n", "n = int(input())\nalst = list(map(int, input().split()))\nnum_pos = [-1 for _ in range(n)]\n\nMOD = 10 ** 9 + 7\nN = n + 10\n\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n\nfor i, num in enumerate(alst):\n    if num_pos[num - 1] == -1:\n        num_pos[num - 1] = i\n    else:\n        bef = num_pos[num - 1]\n        aft = n - i\nfor i in range(1, n + 2):\n    ans = nCk(n + 1, i) - nCk(bef + aft, i - 1)\n    ans %= MOD\n    print(ans)\n    \n    \n", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\np = 10**9+7\n\nn = int(input())\na = list( map(int, input().split()))\ncount = [0]*n\n\nfor i in range(n+1):\n    count[a[i]-1] += 1\n    if count[a[i]-1] == 2:\n        right = i\n        left = a.index(a[i])\n        break\n\ndef nCr_mod_p(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p), 0! = 1! = 1\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p), 0! = 1! = 1\ninv = [0, 1]  # inv[n] = n^(-1) mod p, 0! = 1\u3000\u3060\u3051\u3069\u4fbf\u5b9c\u4e0ainv[0]=0\u306b\u3057\u3066\u308b\n\nfor i in range(2, N + 2):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nfor i in range(1,n+2):\n    ans = nCr_mod_p(n+1,i,p) - nCr_mod_p(n-right+left,i-1,p)\n    print((ans%p))\n", "mod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nc=[0]*n\nfor i in a:c[i-1]+=1\nind=c.index(2)\nx=[]\nfor i in range(n+1):\n    if a[i]==ind+1:x.append(i)\nm=n+x[0]-x[1]\nf=[1]\nfor i in range(1,n+2):f.append(f[-1]*i%mod)\ndef comb(n,r):return f[n]*pow(f[r],mod-2,mod)*pow(f[n-r],mod-2,mod)%mod\nfor k in range(1,n+2):\n    if k==1:print(n);continue\n    if k-1>m:print(comb(n+1,k));continue\n    ans=comb(n+1,k)-comb(m,k-1)\n    print(ans%mod)", "def cmb(n, k, mod, fac, ifac):\n    \"\"\"\n    nCk\u3092\u8a08\u7b97\u3059\u308b\n    \"\"\"\n    k = min(k, n-k)\n    return fac[n] * ifac[k] % mod * ifac[n-k] % mod if n >= k >= 0 else 0\n\n\ndef make_tables(mod, n):\n    \"\"\"\n    \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u3001\u9006\u5143\u306e\u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u6210\u3059\u308b\n    \"\"\"\n    fac = [1, 1] # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(1)\n    ifac = [1, 1] #\u9006\u5143\u306e\u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(2)\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(3)\n\n    for i in range(2, n+1):\n        fac.append((fac[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        ifac.append((ifac[-1] * inverse[-1]) % mod)\n    return fac, ifac\n\n\nN = int(input())\nA = list(map(int,input().split()))\n\nMOD = 10**9 + 7\nfac, ifac = make_tables(MOD,N+1)\n\nans = 0\nINF = 10**9\nx,y = 0,0\nl = [INF]*(N+1)\nfor i in range(N+1):\n  if l[A[i]-1] != INF:\n    x = l[A[i]-1]\n    y = i+1\n    break\n  l[A[i]-1] = i+1\n\nfor i in range(1,N+2):\n  print((cmb(N+1,i,MOD,fac,ifac) - cmb(N+x-y,i-1,MOD,fac,ifac))%MOD)", "n = int(input())\na = list(map(int, input().split()))\nD = {i: [0] for i in range(1, n+1)}\nfor i in range(n+1):\n  D[a[i]][0] += 1\n  D[a[i]].append(i)\npl, pr = 0, 0\nfor i in D:\n  if D[i][0] == 2:\n    pl = D[i][1]\n    pr = D[i][2]\n    break\nL = pl\nM = pr - pl - 1\nN = n - pr\nmod = int(1e9) + 7 # <-- input modulo\nmaxf = n+11          # <-- input factional limitation\n\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[-i-1]]\n        for j in range(L[-i-1]+1, k):\n            perm[j-1] = perm[j]\n    return LL\n\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\n\ndef inved(a, modulo=mod):\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n    while l != 0:\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n        k, l = l, k % l\n    return x % modulo\n\nfact = [1 for _ in range(maxf+1)]\ninvf = [1 for _ in range(maxf+1)]\n\nfor i in range(maxf):\n    fact[i+1] = (fact[i] * (i+1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i-1] = (invf[i] * i) % mod\n\nfor i in range(1, n+2):\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n  if i <= n-1:\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n    S %= mod\n  if i <= n-M:\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n    S %= mod\n  if i <= n:\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n    S %= mod\n  print(S)", "from collections import Counter\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % MOD\n            self.inv[i] = -self.inv[MOD % i] * (MOD // i) % MOD\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % MOD\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nN = int(input())\nA = list(map(int, input().split()))\nMOD = 10**9 + 7\ncomb = Combination(N + 100)\n\ncntA = Counter(A)\nX = [a for a, c in cntA.items() if c == 2][0]\nl, r = [i for i, a in enumerate(A) if a == X]\n\nans = [N]\nfor leng in range(2, N + 2):\n    M = comb.ncr(N + 1, leng)\n\n    L = l + (N - r)\n    D = comb.ncr(L, leng - 1)\n    ans.append((M - D) % MOD)\n\nprint(*ans, sep='\\n')\n", "#!/usr/bin/env python3\nimport sys\nfrom collections import Counter \nMOD = 1000000007 \n\n\ndef solve(n: int, a: \"List[int]\"):\n    counter = Counter(a).most_common()\n    twiceValue = counter[0][0]\n    first_index = None\n    second_index = None\n\n    for i in range(n+1):\n        if a[i] == twiceValue:\n            if first_index == None:\n                first_index = i\n            else:\n                second_index = i\n\n    # 1\u3064\u76ee\u306etwiceValue\u3088\u308a\u5de6\u306b\u3042\u308b\u6570\u5b57\u306e\u6570  \n    left = first_index\n\n    # 2\u3064\u76ee\u306etwiceValue\u3088\u308a\u53f3\u306b\u3042\u308b\u6570\u5b57\u306e\u6570  \n    right = n-second_index\n    edge = left+right\n\n    # nCk,edgeCk\u3092O(1)\u3067\u53d6\u308c\u308b\u3088\u3046\u306b\u3059\u308b\u305f\u3081\n    combination_table = {n+1: [0]*(n+2), edge: [0]*(edge+1)}\n    \n    combination_table[n+1][0] = 1\n    combination_table[n+1][n+1] = 1\n    combination_table[edge][0] = 1\n    combination_table[edge][edge] = 1\n    c_value = 1\n\n    # nCk\u3092\u3046\u3081\u308b\n    for i in range(1,n+1):\n        c_value *= (n+1 + 1 - i) * pow(i,MOD-2,MOD)\n        c_value %= MOD\n        combination_table[n+1][i] = c_value\n\n    c_value = 1\n    # edgeCk\u3092\u3046\u3081\u308b\n    for i in range(1,edge):\n        c_value *= (edge + 1 - i) * pow(i,MOD-2,MOD)\n        c_value %= MOD\n        combination_table[edge][i] = c_value\n\n    for i in range(1,n+2):\n        if i-1 <= edge:\n            value = combination_table[n+1][i] - combination_table[edge][i-1]\n        else:\n            value = combination_table[n+1][i]\n        print((value%MOD))\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    n = int(next(tokens))  # type: int\n    a = [int(next(tokens)) for _ in range(n + 1)]  # type: \"List[int]\"\n    solve(n, a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nA = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\n\nduplicate_x = None\nchecked = set()\nfor a in A:\n    if a in checked:\n        duplicate_x = a\n    checked.add(a)\n\n\nx_l_index = A.index(duplicate_x)\nx_r_index = N + 1 - A[::-1].index(duplicate_x) - 1\n\n\n# \u9006\u5143\u306e\u524d\u8a08\u7b97\nfactorial = [1, 1]\ninverse = [1, 1]\ninvere_base = [0, 1]\nfor i in range(2, N + 2):\n    factorial.append((factorial[-1] * i) % MOD)\n    invere_base.append((-invere_base[MOD % i] * (MOD // i)) % MOD)\n    inverse.append((inverse[-1] * invere_base[-1]) % MOD)\n\n\ndef nCr(n, r):\n    if not 0 <= r <= n:\n        return 0\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\nfor k in range(1, N + 1 + 1):\n    print(((nCr(N + 1, k) - nCr(max(0, x_l_index) + max(N + 1 - x_r_index - 1, 0), k - 1)) % MOD))\n", "m = 10**9+7\nN = int(input())\nA = list(map(int,input().split()))\nB = (N+1)*[0]\n\nfor n in range(N+1):\n  if B[A[n]]==0:\n    B[A[n]]=n+1\n  else:\n    S = B[A[n]]+N-n-1\n    break\n\np = 1\nq = 1\n\nfor n in range(1,N+2):\n  p = ((p*(N+2-n))*pow(n,m-2,m))%m\n  q = (1 if n==1 and S>=n-1 else(0 if S<n-1 else ((q*(S-n+2))*pow(n-1,m-2,m)))%m)\n  print((p-q)%m)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n\ndef cmb(n, k):\n    if k > n:\n        return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 5 + 10 # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n\nN = ir()\nA = lr()\ndouble = 0\nused = set()\nfor i, a in enumerate(A):\n    if a in used:\n        double = a\n        index_back = i\n        break\n    used.add(a)\n\nindex_front = A.index(double)\nx = N + 1 - (index_back - index_front)\nprint(N)\nfor i in range(2, N+1):\n    answer = cmb(N+1, i) - cmb(x-1, i-1)\n    print((answer % MOD))\n\nprint((1))\n# 10\n", "\"\"\"\n\u88ab\u308a\u306a\u3057\ncmb(n-2,k)\n\u88ab\u308a\u3042\u308a2\u5b50\u4f7f\u3046\u306a\u3089\n  x,x,x, A, y,y,y,y, A, z,z,z\ncmb(n-2,k-2)\n\u88ab\u308a\u3042\u308a\u3001\uff11\u3064\u3060\u3051\u4f7f\u3046\u306a\u3089\u3002\u3002\u3002\n  cmb(n-2,k-1) * 2 # y\u4f7f\u3046\u304b\u3082\u3057\u308c\u306a\u3044\u3051\u30fc\u3059\n  cmb(count(x) + count(z), k-1) # y\u4f7f\u308f\u306a\u3044\u30b1\u30fc\u30b9\uff08\uff12\u500d\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u308b\uff09\n\"\"\"\nN = int(input())\nA = list(map(int, input().split()))\ndup = sum(A) - N*(N+1)//2\nidx = []\nfor i in range(len(A)):\n  if A[i] == dup:\n    idx.append(i)\n    \ncountXZ = N - idx[1] + idx[0]\n### nCr mod\n# https://qiita.com/derodero24/items/91b6468e66923a87f39f\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nNMAX = 10**5+10\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, NMAX + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\ndef cmb(n, r, m=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % m\n\n# solve\nprint(N) # k=1\nfor k in range(2,N+1):\n  wk = cmb(N-1,k)\n  wk += cmb(N-1,k-2)\n  wk += cmb(N-1,k-1) * 2\n  wk -= cmb(countXZ, k-1)\n  #print(cmb(N-1,k), cmb(N-1,k-2), cmb(N-1,k-1) * 2, cmb(countXZ, k-1))\n  print(wk % mod)\nprint(1) # k=N+1", "from collections import Counter\nmod = 10 ** 9 + 7\n\n\nclass Combination:\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    N = int(input())\n    A = list(map(int, input().split()))\n    comb = Combination(N + 10)\n    X = Counter(A).most_common()[0][0]\n\n    l = A.index(X)\n    r = A.index(X, l+1)\n    LR = l + (N - r)\n\n    for i in range(1, N + 2):\n        ans = comb(N + 1, i)\n        ans -= comb(LR, i - 1)\n        ans = (ans + mod) % mod\n\n        print(ans)\n__starting_point()", "g1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nMOD = 10**9+7\nfor i in range(2, 10**5+10):\n    g1.append((g1[-1] * i) % MOD)\n    inverse.append((-inverse[MOD % i] * (MOD // i)) % MOD)\n    g2.append((g2[-1] * inverse[-1]) % MOD)\n\ndef comb(n, r, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nN = int(input())\nA = map(int, input().split())\nd = {}\nn1 = n2 = -1\nfor i, a in enumerate(A):\n  if a in d:\n    n1 = N - i\n    n2 = d[a]\n    break\n  d[a] = i\n\nans = [0] * (N+1)\nfor k in range(1, N+2):\n  ans[k-1] = (comb(N+1, k) - comb(n1+n2, k-1)) % MOD\n\nprint(*ans, sep='\\n')", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**5+5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n    \nn=int(input())\nA=list(map(int,input().split()))\na=sum(A)-n*(n+1)//2\nB=[]\nfor i in range(n+1):\n  if A[i]==a:\n    B.append(i)\nfor k in range(1,n+2):\n  print((cmb(n-1,k,mod)+2*cmb(n-1,k-1,mod)-cmb(n-B[1]+B[0],k-1,mod)+cmb(n-1,k-2,mod))%mod)", "n=int(input())\na=list(map(int,input().split()))\nl=[None]*(n+1)\nfor i in range(n+1):\n    if l[a[i]]==None:\n        l[a[i]]=i\n    else:\n        p=l[a[i]]+n-i\n        break\npr=10**9+7\nprint(n)\nMAX_NUM = 10**5 + 2\nfac  = [0 for _ in range(MAX_NUM)]\nfinv = [0 for _ in range(MAX_NUM)]\ninv  = [0 for _ in range(MAX_NUM)]\nfac[0]  = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\nfor i in range(2,MAX_NUM):\n    fac[i] = fac[i-1] * i % pr\n    inv[i] = pr - inv[pr%i] * (pr // i) % pr\n    finv[i] = finv[i-1] * inv[i] % pr\ndef c(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % pr) % pr\nfor i in range(2,n+1):\n    t=c(n+1,i)\n    if p>=i-1:\n        t-=c(p,i-1)\n    print(t%pr)\nprint(1)", "from collections import Counter\n\nmod = 10**9+7\nrng = 100002\nfctr = [1]\nfinv = [1]\nfor i in range(1,rng):\n  fctr.append(fctr[-1]*i%mod)\nfor i in range(1,rng):\n  finv.append(pow(fctr[i],mod-2,mod))\ndef cmb(n,k):\n  if n<=0 or k<0 or n<k:\n    return 0\n  else:\n    return fctr[n]*finv[n-k]*finv[k]%mod\n\nn = int(input())\na = list(map(int,input().split()))\nsame = []\nc = Counter(a)\nx = c.most_common()[0][0]\nfor i in range(n+1):\n  if a[i] == x:\n    same.append(i+1)\ny = same[1]-same[0]+1\nprint(n)\nfor k in range(2,n+2):\n  print(((cmb(n+1,k)-cmb(n+1-y,k-1))%mod))\n", "n = int(input()) + 1\na = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\n# 1\u3092\u4e00\u3064\u3060\u3051\u9078\u3076\u3084\u3064\u306f\u91cd\u8907\u3059\u308b\u53ef\u80fd\u6027\nd = [False] * (n + 1)\n\nleft = right = 0\nfor i in range(n):\n    if d[a[i]]:\n        right = i\n        left = a.index(a[i])\n        break\n    d[a[i]] = True\n\n\nfac = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fac[i] = fac[i - 1] * i % mod\n\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\n\ndef c(n, k):\n    if n < 0 or k < 0 or n < k:\n        return 0\n    return fac[n] * inv(fac[n - k] * fac[k] % mod) % mod\n\n\nleft_len = left\nright_len = n - right - 1\nprint((n - 1))\nfor i in range(2, n + 1):\n    ans = c(n, i) - c(left_len + right_len, i - 1)\n    print((ans % mod))\n", "MOD=10**9+7\nclass Fp(int):\n    def __new__(self,x=0):return super().__new__(self,x%MOD)\n    def inv(self):return self.__class__(super().__pow__(MOD-2,MOD))\n    def __add__(self,value):return self.__class__(super().__add__(value))\n    def __sub__(self,value):return self.__class__(super().__sub__(value))\n    def __mul__(self,value):return self.__class__(super().__mul__(value))\n    def __floordiv__(self,value):return self.__class__(self*self.__class__(value).inv())\n    def __pow__(self,value):return self.__class__(super().__pow__(value%(MOD-1), MOD))\n    __radd__=__add__\n    __rmul__=__mul__\n    def __rsub__(self,value):return self.__class__(-super().__sub__(value))\n    def __rfloordiv__(self,value):return self.__class__(self.inv()*value)\n    def __iadd__(self,value):self=self+value;return self\n    def __isub__(self,value):self=self-value;return self\n    def __imul__(self,value):self=self*value;return self\n    def __ifloordiv__(self,value):self=self//value;return self\n    def __ipow__(self,value):self=self**value;return self\n    def __neg__(self):return self.__class__(super().__neg__())\n\nclass Combination:\n    def __init__(self,max_n):\n        self.max_n=0\n        self.fact=[Fp(1)]\n        self.ifact=[Fp(1)]\n        self.make_fact_list(max_n)\n    def C(self,n,k):return self.fact[n]*self.ifact[k]*self.ifact[n-k] if 0<=k<=n else 0\n    def H(self,n,k):return self.C(n+k-1,k) if n or k else 1\n    def P(self,n,k):return self.fact[n]*self.ifact[n-k] if 0<=k<=n else 0\n    def make_fact_list(self,max_n):\n        if max_n<=self.max_n: return\n        self.fact+=[Fp(0)]*(max_n-self.max_n)\n        self.ifact+=[Fp(0)]*(max_n-self.max_n)\n        for i in range(self.max_n+1,max_n+1):\n            self.fact[i]=self.fact[i-1]*i\n            self.ifact[i]=self.ifact[i-1]//i\n        self.max_n=max_n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = [-1] * (N + 1)\nfor i, a in enumerate(A):\n    if B[a] >= 0:\n        break\n    B[a] = i\n\nL = B[a]\nR = N - i\nM = i - B[a] - 2\nprint(N)\ncomb = Combination(N+1)\nfor k in range(2, N+2):\n    print((comb.C(N+1, k) - comb.C(L + R, k-1)))\n", "n,*a=map(int,open(0).read().split());b={};M=10**9+7;p=n+1;q=r=1\nfor i,x in enumerate(a):\n if x in b:d=i-b[x];break\n b[x]=i\nfor k in range(n+1):print((p-q)%M);q=q*(n-d-k)*r%M;r=pow(k+2,M-2,M);p=p*(n-k)*r%M", "n = int(input())\nl = list(map(int,input().split()))\nl1 = [[l[i],i] for i in range(n+1)]\nl1.sort()\nfor i in range(n):\n    if l1[i][0] == l1[i+1][0]:\n        a,b = l1[i][1],l1[i+1][1]\n\nm = b-a+1\nk = n-m+1\n\nmod = 10**9+7 \nfact = [1,1]\nfinv = [1,1]\ninv = [0,1]\n \nfor i in range(2,n+5):\n    fact.append((fact[-1]*i)%mod)\n    inv.append((inv[mod%i]*(mod-mod//i))%mod)\n    finv.append((finv[-1]*inv[-1])%mod)\n \ndef nCr(n,r,mod):\n    if r > n:\n        return 0\n    else: \n        return fact[n]*finv[r]*finv[n-r]%mod\n\n\nfor i in range(1,n+2):\n    a = nCr(n+1,i,mod) -nCr(k,i-1,mod)\n    \n    print(a%mod)", "n = int(input())\na = list(map(int, input().split()))\nmod = 10**9+7\n\n\"\"\"\n\u3069\u3053\u304b\u306b\u540c\u3058\u6570\u5024\u304c\u51fa\u3066\u304f\u308b\u3002\nAAAxBBBxCCC\nx\u304c\u540c\u4e00\u6587\u5b57\u3068\u3059\u308b\n\u30fbx\u304c\u3069\u3061\u3089\u304b1\u3064\u767b\u5834\n\u30fbB\u3092\u4f7f\u7528\u3057\u306a\u3044\n\u3082\u306e\u306b\u3064\u3044\u3066\u306f\u3069\u3061\u3089\u306ex\u3092\u4f7f\u7528\u3057\u3066\u3082\u540c\u3058\u6570\u5217\u306b\u306a\u308b\u306e\u3067\u9664\u304f\n\"\"\"\nmodp = mod\nmax_n = 2*10 ** 5               # \u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1] + [0]*max_n     # fact[n] = (n! mod modp)\nfactinv = [1, 1] + [0]*max_n  # factinv[n] = ((n!)^(-1) mod modp)\ninv = [0, 1] + [0]*max_n      # factinv \u8a08\u7b97\u7528\n\ndef cmb(n, r, p):\n    assert n < p, 'n is less than modp'\n    assert n < max_n, 'n in less than max_n'\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\nfor i in range(2, max_n + 1):\n    fact[i] = (fact[i-1] * i) % modp\n    inv[i] = (-inv[modp % i] * (modp // i)) % modp\n    factinv[i] = (factinv[i-1] * inv[i]) % modp\n\ncounter = [0] * n\nfor i in range(n+1):\n    counter[a[i]-1]+=1\n    if counter[a[i]-1] == 2:\n        second = i\n        first = a.index(a[i])\n        break\n\n# x\u306e\u91cd\u8907\u3092\u8003\u616e\u305b\u305a\u5168\u3066\u30ab\u30a6\u30f3\u30c8\nans = [cmb(n+1, i, mod) for i in range(1, n+2)]\n\nn_left = first\nn_right = n-second\nn_lr = n_left + n_right\n\n# i\u500b\u306e\u91cd\u8907\u3059\u308b\u7d44\u5408\u305b\u306fn_lr\u304b\u3089i-1\u500b\u9078\u3073\u3001x\u3092\u3069\u3061\u3089\u304b1\u3064\u9078\u3076\u3002\ndoubled = [1]+[cmb(n_lr, i, mod) for i in range(1, n_lr+1)]\n\nfor i in range(n_lr+1):\n    ans[i] = (ans[i] - doubled[i])%mod\n\nfor i in range(len(ans)):\n    print((ans[i]))\n\n\n\n\n", "import sys\nfrom collections import Counter\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    D = Counter(A)\n\n    for k, v in list(D.items()):\n        if v == 2:\n            db = k\n            break\n\n    flg = 1\n    right, left = 0, 0\n    for i in range(n + 1):\n        if flg and A[i] == db:\n            left = i\n            flg ^= 1\n        elif A[i] == db:\n            right = i\n            break\n\n    length = n - (right - left)\n\n    # \u4e8c\u9805\u4fc2\u6570(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\n    def cmb(n, r, mod):\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return fact[n] * factinv[r] * factinv[n - r] % mod\n\n    fact = [1, 1]\n    factinv = [1, 1]\n    inv = [0, 1]\n\n    for i in range(2, n + 2):\n        fact.append((fact[-1] * i) % mod)\n        inv.append((-inv[mod % i] * (mod // i)) % mod)\n        factinv.append((factinv[-1] * inv[-1]) % mod)\n\n    def cmb_mod(n, r, mod):\n        x, y = 1, 1\n        for i in range(r):\n            x = (x * (n - i)) % mod\n            y = (y * (i + 1)) % mod\n        return (x * pow(y, mod - 2, mod)) % mod\n\n    for i in range(1, n + 2):\n        res = cmb(n + 1, i, mod) - cmb(length, i - 1, mod)\n        print((res % mod))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nfinput=lambda:sys.stdin.readline().strip()\n\ndef main():\n    p=10**9+7\n    n=int(finput())\n    a=list(map(int,finput().split()))\n    k=sum(a)-(n*(n+1))//2\n    pk=[i for i in range(n+1) if a[i]==k]\n    fact=[1]*(n+2)\n    ifact=[1]*(n+2)\n    for i in range(1,n+2):\n        fact[i]=fact[i-1]*i % p\n    a=fact[-1]\n    inv=1\n    m=p-2\n    while m>0:\n        if m&1:\n            inv=a*inv % p\n        m>>=1\n        a=a*a % p\n    ifact[-1]=inv\n    for i in range(n+1,0,-1):\n        ifact[i-1]=ifact[i]*i % p\n    ans0=[0]*(n+2)\n    ans1=[0]*(n+2)\n    ans2=[0]*(n+2)\n    for i in range(n):\n        ans0[i]=fact[n-1]*ifact[n-i-1]*ifact[i]%p\n        ans1[i+1]=ans0[i]*2\n        ans2[i+2]=ans0[i]\n    sn=pk[0]+n-pk[1]\n    for i in range(sn+1):\n        ans1[i+1]-=fact[sn]*ifact[sn-i]*ifact[i] % p\n    for i in range(1,n+2):\n        print(((ans0[i]+ans1[i]+ans2[i]) % p))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nfrom bisect import bisect_left,bisect_right \nimport sys,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nn = inp()\na = inpl()\ns = set()\nfor i in range(n+1):\n    if a[i] in s:\n        last = n-i\n        t = a[i]\n        break\n    s.add(a[i])\nfor i in range(n+1):\n    if a[i] == t:\n        fir = i\n        break \nsoto = fir + last\nclass Combination:\n    \"\"\"\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\n\ncomb = Combination(2*10**5+10)\n\nfor i in range(1,n+2):\n    rm = 0\n    if i <= soto+1:\n        rm = comb(soto,i-1)\n    print(((comb(n+1,i) - rm)%mod))\n", "from collections import Counter, defaultdict\n\nclass Combination:\n    def __init__(self, size, mod=10**9 + 7):\n        self.size = size + 2\n        self.mod = mod\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % self.mod\n            self.inv[i] = -self.inv[self.mod % i] * (self.mod // i) % self.mod\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % self.mod\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % self.mod\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % self.mod) % self.mod\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b\n        return self.ncr(n + r - 1, n - 1)\n\n    def factN(self, n):\n        if n < 0:\n            return 0\n        return self.fact[n]\n\nN = int(input())\nA = list(map(int, input().split()))\nMOD = 10**9 + 7\ncomb = Combination(N + 100)\n\ncntA = Counter(A)\nI = [a for a, c in list(cntA.items()) if c == 2][0]\nL, R = [i for i, a in enumerate(A) if a == I]\nS = L + (N - R)\n\nfor i in range(1, N + 2):\n    if i == 1:\n        print(N)\n        continue\n\n    ans = comb.ncr(N + 1, i) - comb.ncr(S, i - 1)\n    print((ans % MOD))\n", "n = int(input())\na = list(map(int, input().split()))\nmod = pow(10, 9) + 7\nnum = [-1] * (n + 1)\nfor i in range(n + 1):\n    if num[a[i]] == -1:\n        num[a[i]] = i\n    else:\n        samei, samej = num[a[i]], i\n        break\nx = n + samei - samej\nsame = 1\ncomb = n + 1\nprint(comb - 1)\nfor i in range(2, n + 2):\n    comb = (comb * (n - i + 2) * pow(i, mod - 2, mod)) % mod\n    if i - 1 <= x:\n        same = (same * (x - i + 2) * pow(i - 1, mod - 2, mod)) % mod\n    else:\n        same = 0\n    print((comb - same) % mod)", "mod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nc=[0]*n\nfor i in a:c[i-1]+=1\nind=c.index(2)\nx=[]\nfor i in range(n+1):\n    if a[i]==ind+1:x.append(i)\nm=n+x[0]-x[1]\nf=[1]\nfor i in range(1,n+2):f.append(f[-1]*i%mod)\ndef comb(n,r):return f[n]*pow(f[r],mod-2,mod)*pow(f[n-r],mod-2,mod)%mod\nfor k in range(1,n+2):\n    if k==1:print(n);continue\n    if k-1>m:print(comb(n+1,k));continue\n    ans=comb(n+1,k)-comb(m,k-1)\n    print(ans%mod)", "class nCrMod():\n    def __init__(self, mod):\n        self.mod = mod\n        self.fac = [1, 1]\n        self.finv = [1, 1]\n        self.inv = [0, 1]\n\n    def prep(self, n):\n        mod = self.mod\n        f, fi = self.fac[-1], self.finv[-1]\n        for i in range(len(self.fac), n + 1):\n            fn = f * i % mod\n            v = -self.inv[mod % i] * (mod // i) % mod\n            fin = fi * v % mod\n            f, fi = fn, fin\n            self.fac.append(f)\n            self.finv.append(fi)\n            self.inv.append(v)\n\n    def __call__(self, n, r):\n        if len(self.fac) <= n:\n            self.prep(n)\n        return self.fac[n] * self.finv[r] * self.finv[n - r] % self.mod\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    d = {}\n    f, s = 0, 0\n    for i, a in enumerate(A):\n        if a in d:\n            break\n        d[a] = i\n    f, s = d[a], i\n    mod = 10**9 + 7\n    nCr = nCrMod(mod)\n    for i in range(1, N + 2):\n        if i > N + 1 - (s - f):\n            print((nCr(N + 1, i)))\n        else:\n            print(((nCr(N + 1, i) - nCr(N - (s - f), i - 1)) % mod))\nmain()\n", "from collections import Counter\nn = int(input())\na = list(map(int,input().split()))\nkasanari = Counter(a).most_common()[0][0]\nmod = 10**9+7\n\"\"\"\n2 3 1 4 5 6 1 7 8 9\nY Y C C C C C X X X\nk\u500b\u9078\u3076. \u5168\u90e8 nCk-3Ck\n\"\"\"\nbasho = []\nfor cnt, i in enumerate(a):\n\tif i == kasanari:\n\t\tbasho.append(cnt)\n\ndef cmb(n, r, mod):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%mod\n\nN = 2*10**5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%mod)\n\tinv.append((-inv[mod%i]*(mod//i))%mod)\n\tfactinv.append((factinv[-1]*inv[-1])%mod)\n\nfor i in range(1, n+2):\n\tprint((cmb(n+1, i, mod)-cmb(n-basho[1]+basho[0], i-1, mod))%mod)", "import collections\n\nmod=10**9+7\nn=int(input())\narr=list(map(int,input().split()))\ncnt=collections.Counter(arr)\nfor key in cnt.keys():\n  if cnt[key]==2:\n    K=key\npos1=-1\npos2=-1\nfor i in range(n+1):\n  if arr[i]==K:\n    if pos1==-1:\n      pos1=i\n    else:\n      pos2=i\nA=pos1\nB=pos2-pos1-1\nC=n-pos2\nfacts=[1]\nfor i in range(1,n+1):\n  facts.append((facts[-1]*i)%mod)\nrevfacts=[1]\nfor i in range(1,n+1):\n  revfacts.append(pow(facts[i],mod-2,mod))\nans=[]\nfor i in range(1,n+2):\n  ways1=0\n  if i<=A+B+C:\n    ways1=(facts[A+B+C]*revfacts[i]*revfacts[A+B+C-i])%mod\n  ways2=0\n  if i>=2 and i-2<=A+B+C:\n  \tways2=(facts[A+B+C]*revfacts[i-2]*revfacts[A+B+C-(i-2)])%mod\n  ways3=0\n  if i>=1 and i-1<=A+C:\n    ways3=(facts[A+C]*revfacts[i-1]*revfacts[A+C-(i-1)])%mod\n  ways4=0\n  if i>=1 and i-1<=A+B+C:\n    ways4=(2*facts[A+B+C]*revfacts[i-1]*revfacts[A+B+C-(i-1)]-2*ways3)%mod\n  ans.append((ways1+ways2+ways3+ways4)%mod)\nfor val in ans:\n  print(val)", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def nCr(self, n, r):\n        r = min(n - r, r)\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n    def nHr(self, n, r):\n        return self.nCr(n - 1 + r, r)\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N = int(input())\n    A = map(int, input().split())\n\n    B = [-1] * (N + 1)  # \u306f\u3058\u3081\u3066\u51fa\u73fe\u3059\u308b\u4f4d\u7f6e(0-ind)\n    d = None  # \u91cd\u8907\u8981\u7d20\u306e\u51fa\u73fe\u4f4d\u7f6e(2\u70b9)\n    for i, x in enumerate(A):\n        if ~B[x]:\n            d = B[x], i\n            break\n        B[x] = i\n\n    # \u91cd\u8907\u8981\u7d20L,R(d[0],d[1]),\u4e00\u5ea6\u3060\u3051\u51fa\u73fe\u3059\u308b\u6570\u306e\u5217X,Y,Z(|X|>=0,|Y|>=0,|Z|>=0)\n    # X...LY...RZ...\n    # \u91cd\u8907\u8a08\u4e0a: choose(N+1,K)\n    # \u3053\u3053\u304b\u3089\u91cd\u8907\u5206\u3092\u5dee\u3057\u5f15\u304f\n    # LR\u3092\u542b\u3080\u500b\u6570\n    # 0\u500b: \u91cd\u8907\u8a08\u4e0a\u306a\u3057\n    # 1\u500b: (X,L,YZ)\u3068(XY,R,Z)\u304c\u4e00\u81f4\u3059\u308b\u5834\u5408\u306b\u91cd\u8907\u8a08\u4e0a\u306b\u306a\u308b==(X,L/R,Z)\n    # ->\n    # #==sum(choose(X,a)*choose(Z,K-1-a)),(0<=a<=K-1)\n    # \u898b\u65b9\u3092\u5909\u3048\u308b\n    # Y\u306e\u533a\u9593\u4ee5\u5916\u304b\u3089K\u500b\u9078\u3076\n    # \u305f\u3060\u3057,Y\u306e\u533a\u9593\u5916\u306e\u3046\u3061LR\u304b\u30890\u500b\u53d6\u308b\u3082\u306e\u30682\u500b\u53d6\u308b\u3082\u306e\u3092\u5dee\u3057\u5f15\u304f\n    # \u6b8b\u308a\u306f(X,L/R,Z)\u3092\u4e8c\u91cd\u8a08\u4e0a\u3057\u305f\u3082\u306e\u306a\u306e\u3067,\u534a\u5206\u306b\u3059\u308b\n    # (choose(N+1-Y,K) - choose(N+1-2-Y,K) - choose(N+1-2-Y,K-2)) // 2\n    # 2\u500b: \u91cd\u8907\u8a08\u4e0a\u306a\u3057\n\n    calc = Calc(max_value=N + 1, mod=MOD)\n    ans = []\n    Y = d[1] - 1 - d[0]\n    div2 = pow(2, MOD - 2, MOD)\n    for k in range(1, N + 2):\n        t = (\n                    calc.nCr(N + 1, k)\n                    - (\n                            calc.nCr(N + 1 - Y, k)\n                            - calc.nCr(N + 1 - 2 - Y, k)\n                            - calc.nCr(N + 1 - 2 - Y, k - 2)\n                    ) * div2 % MOD\n            ) % MOD\n        ans.append(t)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\nplace=[-1]*n\nfor i in range(n+1):\n\tif place[a[i]-1]==-1:\n\t\tplace[a[i]-1]=i\n\telse:\n\t\tR=(place[a[i]-1],i)\n\t\tbreak\ndef c(a,b):\n\tif a==b==0:\n\t\treturn 1\n\tif a<b or a<=0 or b<0:\n\t\treturn 0\n\tr=fac[a-b]*fac[b]%mod\n\treturn fac[a]*pow(r,mod-2,mod)%mod\nfac=[1]\nfor i in range(n+1):\n\tfac.append(fac[-1]*(i+1)%mod)\nfor i in range(1,n+2):\n\tans=(c(n+1,i)-c(R[0]+n-R[1],i-1))%mod\n\tprint(ans)", "from collections import Counter\nn = int(input())\na = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\ncomb = nCr(2 * n)\nc = Counter(a)\nnum = c.most_common()[0][0]\nl, r = a.index(num), n - list(reversed(a)).index(num)\nfor i in range(1, n + 2):\n    print((comb.comb(n + 1, i) - comb.comb(n - (r - l), i - 1)) % mod)", "def cmb(n, r, p):\n\tif (r<0) or (n<r):\n\t\treturn 0\n\tr=min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%p\n\np=10**9+7\nN=10**6\nfact=[1,1]\nfactinv=[1,1]\ninv=[0,1]\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%p)\n\tinv.append((-inv[p%i]*(p//i)%p))\n\tfactinv.append((factinv[-1]*inv[-1])%p)\n\n\nN=int(input())\nA=list(map(int,input().split()))\nindex=[-1]*N\nfor i,a in enumerate(A):\n    if index[a-1]!=-1:\n        dup_first,dup_second=index[a-1],i\n        break\n    index[a-1]=i\n\nmod=10**9+7\nn=dup_first\nm=N-dup_second\nl=n+m\nfor k in range(1,N+2):\n    if k==1:\n        print(N)\n        continue\n    ans=(cmb(N+1,k,mod)-cmb(l,k-1,mod))%mod\n    print(ans)", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**5 + 1 # N >= n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nn = int(input())\nA = list(map(int,input().split()))\n\nval = sum(A) - sum(set(A))\ni = -1\nj = -1\nfor k in range(n+1):\n    if A[k] == val:\n        if i == -1:\n            i = k\n        elif j == -1:\n            j = k\n            break\nfor k in range(1,n+2):\n    print((cmb(n+1, k, mod) - cmb(n + i - j, k - 1, mod)) % mod)", "def cmb(N, r, mod):\n    if ( r<0 or r>N ):\n        return 0\n    r = min(r, N-r)\n    return g1[N] * g2[r] * g2[N-r] % mod\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nmod = 10 ** 9 + 7\n\nn = int(input())\nlis = list(map(int,input().split()))\nli = [-1] * n\n\nfor i in range( 2, n + 2 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nfor i in range(n+1):\n    if li[lis[i]-1] != -1:\n        left = li[lis[i]-1]+1\n        right = i+1\n        break\n    else:li[lis[i]-1] = i\n\nfor k in range(1,n+2):\n  #     print(nCr(n+1,k,mod),nCr(left+n-right,k-1,mod))\n    ans = cmb(n+1,k,mod)-cmb(left+n-right,k-1,mod)\n    if ans < 0:\n        ans += mod\n    print(ans)", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def nCr(self, n, r):\n        r = min(n - r, r)\n        if r < 0: return 0\n        if r == 0: return 1\n        if r == 1: return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n    def nHr(self, n, r):\n        return self.nCr(n - 1 + r, r)\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N = int(input())\n    A = map(int, input().split())\n\n    B = [-1] * (N + 1)  # \u306f\u3058\u3081\u3066\u51fa\u73fe\u3059\u308b\u4f4d\u7f6e(0-ind)\n    d = None  # \u91cd\u8907\u8981\u7d20\u306e\u51fa\u73fe\u4f4d\u7f6e(2\u70b9)\n    for i, x in enumerate(A):\n        if ~B[x]:\n            d = B[x], i\n            break\n        B[x] = i\n\n    # \u91cd\u8907\u8981\u7d20L,R(d[0],d[1]),\u4e00\u5ea6\u3060\u3051\u51fa\u73fe\u3059\u308b\u6570\u306e\u5217X,Y,Z(|X|>=0,|Y|>=0,|Z|>=0)\n    # X...LY...RZ...\n    # \u91cd\u8907\u8a08\u4e0a: choose(N+1,K)\n    # \u3053\u3053\u304b\u3089\u91cd\u8907\u5206\u3092\u5dee\u3057\u5f15\u304f\n    # LR\u3092\u542b\u3080\u500b\u6570\n    # 0\u500b: \u91cd\u8907\u8a08\u4e0a\u306a\u3057\n    # 1\u500b: (X,L,YZ)\u3068(XY,R,Z)\u304c\u4e00\u81f4\u3059\u308b\u5834\u5408\u306b\u91cd\u8907\u8a08\u4e0a\u306b\u306a\u308b==(X,L/R,Z)\n    # ->\n    # #==sum(choose(X,a)*choose(Z,K-1-a)),(0<=a<=K-1)\n    # \u898b\u65b9\u3092\u5909\u3048\u308b\n    # Y\u306e\u533a\u9593\u4ee5\u5916\u304b\u3089K\u500b\u9078\u3076\n    # \u305f\u3060\u3057,Y\u306e\u533a\u9593\u5916\u306e\u3046\u3061LR\u304b\u30890\u500b\u53d6\u308b\u3082\u306e\u30682\u500b\u53d6\u308b\u3082\u306e\u3092\u5dee\u3057\u5f15\u304f\n    # \u6b8b\u308a\u306f(X,L/R,Z)\u3092\u4e8c\u91cd\u8a08\u4e0a\u3057\u305f\u3082\u306e\u306a\u306e\u3067,\u534a\u5206\u306b\u3059\u308b\n    # (choose(N+1-Y,K) - choose(N+1-2-Y,K) - choose(N+1-2-Y,K-2)) // 2\n    # <editorial>\n    # LR\u304b\u30891\u500b,XZ\u304b\u3089K-1\u500b\u53d6\u308bchoose(XZ,K-1)=choose(N+1-2-Y,K-1)\u3067\u3088\u3044\n    # 2\u500b: \u91cd\u8907\u8a08\u4e0a\u306a\u3057\n\n    calc = Calc(max_value=N + 1, mod=MOD)\n    ans = []\n    Y = d[1] - 1 - d[0]\n    for k in range(1, N + 2):\n        ans.append((calc.nCr(N + 1, k) - calc.nCr(N + 1 - 2 - Y, k - 1)) % MOD)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nA =list(map(int, input().split()))\nmod = 10**9+7\n\nd = {}\nfor i in range(n+1):\n    if A[i] not in d:\n        d[A[i]] = i\n    else:\n        l = d[A[i]]\n        r = i\n        break\n#print(l, r)\n\ndef cmb1(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nfor k in range(1, n+2):\n    ans = cmb1(n+1, k, mod) - cmb1(l+n-r, k-1, mod)\n    print((ans%mod))\n", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nmod = pow(10, 9)+7\nct = [1]*(n+1)\nfor i in range(1, n+1):\n  ct[i] = ct[i-1]*i%mod\n\ndef comb(n, k):\n  res = ct[n]*pow(ct[n-k], mod-2, mod)%mod*pow(ct[k], mod-2, mod)%mod\n  return res\n\ndef main():\n  a = [int(x) for x in input().split()]\n\n  already = [-1]*n\n  for i in range(n+1):\n    if already[a[i]-1] != -1:\n      f, s = already[a[i]-1], n-i\n      break\n    already[a[i]-1] = i\n    \n  ans = [0]*(n+1)\n  c = 1\n  for i in range(n+1):\n    c = c*(n+1-i)%mod*pow(i+1, mod-2, mod)%mod\n    ans[i] += c%mod\n\n  for i in range(n):\n    if s+f >= i:\n      ans[i] += mod-(comb(f+s, i))%mod\n    ans[i] %= mod\n  for a in ans:\n    print(a)\n\ndef __starting_point():\n  main()\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\nd=dict()\n#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u9006\u5143\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nfor i in range(n+1):\n    if a[i] not in d:\n        d[a[i]]=i\n    else:\n        idx1=d[a[i]]\n        idx2=i\n        break\nfor i in range(1,n+2):\n    ans=cmb(n+1,i,mod)\n    if n-idx2+idx1<i-1:\n        print(ans)\n    else:\n        ans=(ans-cmb(n-idx2+idx1,i-1,mod)+mod)%mod\n        print(ans%mod)", "mod = 10 ** 9 + 7\n\nSIZE = 10 ** 5 + 5\nfact = [0] * SIZE\ninv = [0] * SIZE\nfinv = [0] * SIZE\nfact[0], fact[1] = 1, 1\ninv[1] = 1\nfinv[0], finv[1] = 1, 1\nfor i in range(2, SIZE):\n    fact[i] = fact[i - 1] * i % mod\n    inv[i] = mod - inv[mod % i] * (mod // i) % mod\n    finv[i] = finv[i - 1] * inv[i] % mod\n\n\ndef nCr(n, r):\n    if n < 0 or r < 0 or n < r:\n        return 0\n    return fact[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\nfrom collections import Counter\n\n\nn = int(input())\nA = list(map(int, input().split()))\ncounterA = Counter(A)\nduplicate = 0\nfor num, count in list(counterA.items()):\n    if count == 2:\n        duplicate = num\n        break\n\nduplicate_pos = []\nfor i, a in enumerate(A):\n    if a == duplicate:\n        duplicate_pos.append(i)\n\nfirst, second, *_ = duplicate_pos\n\nfor k in range(1, n+2):\n    base = nCr(n+1, k)\n    duplicate_pattern = nCr(first + n-second, k-1)\n    print(((base - duplicate_pattern) % mod))\n\n", "n=int(input())\na=list(map(int,input().split()))\nmod=pow(10,9)+7\n#ans=[int(input()) for _ in range(n+1)]\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\ng1 = [1, 1] \ng2 = [1, 1] \ninverse = [0, 1]\nfor i in range( 2, n + 2 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n# \u4e8c\u3064\u3042\u308b\u3084\u3064\u306e\u5de6\u306e\u65b9\u306e\u5de6\u306bl\u500b\u3001\u53f3\u306e\u3084\u3064\u306e\u53f3\u306e\u307b\u3046\u306br\u500b\u6570\u5b57\u304c\u3042\u308b\nf=[-1]*(n+1)\nl,r=0,0\nfor i in range(n+1):\n  ai=a[i]\n  if f[ai]==-1:\n    f[ai]=i\n  else:\n    l=f[ai]\n    r=n-i\n    break\nfor k in range(1,n+2):\n  a=cmb(n+1,k,mod)\n  if l+r>=k-1:\n\t  a-=cmb(l+r,k-1,mod)\n  #print(a==ans[k-1],a,ans[k-1])\n  print(a%mod)", "def memfact(a,m):\n    temp = 1\n    yield temp\n    for i in range(1,a+1):\n        temp = temp * i % m\n        yield temp\ndef comb(n,r,m):\n    if r == 0: return 1\n    return (memf[n]*pow(memf[r],m-2,m)*pow(memf[n-r],m-2,m)) % m\n\n\nn,*a = map(int, open(0).read().split())\nm = 1000000007\nchecker = set()\nfor i in range(n+1):\n    if a[i] in checker:\n        left = a.index(a[i])\n        right = n - i\n        break\n    else:\n        checker.add(a[i])\nmemf = []\nmfappend = memf.append\nfor x in memfact(n+1,m):\n    mfappend(x)\nlr = left + right\nfor i in range(1,n+2):\n    ans = comb(n+1,i,m)\n    if i <= lr + 1:\n        ans = (ans-comb(lr,i-1,m)) % m\n    print(ans)", "from math import factorial\n\nn = int(input())\na = list(map(int,input().split()))\nse = set()\nmod = 10**9+7\n\nfor i,j in enumerate(a):\n    if j in se:\n        two = i\n    else:\n        se.add(j)\n\none = a.index(a[two])\n\ndef prepare(n, MOD):\n    facts = [1]*(n+1)\n    for i in range(1, n+1):\n        facts[i] = facts[i-1]*i%MOD\n    invs = [1]*(n+1)\n    invs[n] = pow(facts[n], MOD-2, MOD)\n    for i in range(0, n)[::-1]:\n        invs[i] = invs[i+1] * (i+1) % MOD\n    return facts, invs\n\nfacts,invs = prepare(n+1,mod)\n\ndef make_combi(facts,invs,n,r,mod):\n    return facts[n] * invs[r] * invs[n - r] %mod\n\nfor i in range(1,n+2):\n    point = make_combi(facts,invs,n+1,i,mod)\n    if one+n-two >= i-1:\n        point -= make_combi(facts,invs,one+n-two,i-1,mod)\n    print(point%mod)", "from collections import Counter\n\n\nclass Combination:\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    N = int(input())\n    A = tuple(map(int, input().split()))\n    mod = 10 ** 9 + 7\n\n    X = Counter(A).most_common()[0][0]\n    left = A.index(X)\n    right = A[::-1].index(X)\n    LR = left + right\n\n    comb = Combination(10 ** 5 + 10)\n\n    ans = []\n    for i in range(1, N + 2):\n        val = comb(N+1, i)-comb(LR, i-1)\n        val = (val + mod) % mod\n        ans.append(val)\n\n    print(*ans, sep=\"\\n\")\n\n__starting_point()", "# D - 11\n\nn = int(input())\na = list(map(int, input().split()))\nMOD = 10**9 + 7\n\n# a//b (MOD p)\ndef div_mod(a, b, p):\n    return (a * pow(b, p-2, p)) % p\n\nfactorial_memo = [1]\nfor i in range(1, n+2):\n    factorial_memo.append((factorial_memo[-1] * i) % MOD)\n\ndef comb_mod(n, r, mod):\n    if n < r:\n        return 0\n    return div_mod(div_mod(factorial_memo[n], factorial_memo[n-r], mod), factorial_memo[r], mod)\n\n\nindices = [-1] * (n+1)\nfor i in range(n+1):\n    if indices[a[i]] == -1:\n        indices[a[i]] = i\n    else:\n        f_idx = indices[a[i]]\n        s_idx = i\n        break\n\nfor k in range(1, n+2):\n    all_pattern = comb_mod(n+1, k, MOD)\n    dup_pattern = comb_mod(f_idx + (n - s_idx), k-1, MOD)\n    print((all_pattern - dup_pattern) % MOD)", "n, *a = map(int, open(0).read().split())\n\nleft = 0\nright = 0\nval = 0\nseen = [False] * (n + 1)\nfor i in range(n + 1):\n    if seen[a[i]]:\n        right = i\n        val = a[i]\n        break\n    seen[a[i]] = True\nfor i in range(n):\n    if a[i] == val:\n        left = i\n        break\n\nmod = 10 ** 9 + 7\n\nfac = [1] * (n + 5)\nfor i in range(1, n + 3):\n    fac[i] = fac[i - 1] * i % mod\ndef inv(x):\n    return pow(x, mod - 2, mod)\ndef c(n, k):\n    if n < k:\n        return 0\n    return fac[n] * inv(fac[k] * fac[n - k]) % mod\n\nright = n - right\nfor i in range(1, n + 2):\n    print((c(n + 1, i) - c(left  + right, i - 1)) % mod)", "\nfrom collections import defaultdict\nn = int(input()) + 1\na = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\n# 1\u3092\u4e00\u3064\u3060\u3051\u9078\u3076\u3084\u3064\u306f\u91cd\u8907\u3059\u308b\u53ef\u80fd\u6027\nd = defaultdict(int)\n\nleft = right = 0\nfor i in range(n):\n    if d[a[i]] > 0:\n        right = i\n        left = a.index(a[i])\n        break\n    d[a[i]] += 1\n\n\nfac = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fac[i] = fac[i - 1] * i % mod\n\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\n\ndef c(n, k):\n    if n < 0 or k < 0 or n < k:\n        return 0\n    return fac[n] * inv(fac[n - k] * fac[k] % mod) % mod\n\n\nleft_len = left\nright_len = n - right - 1\nprint((n - 1))\nfor i in range(2, n + 1):\n    ans = c(n, i) - (c(left_len + 1 + right_len, i) -\n                     c(left_len + right_len, i))\n    print((ans % mod))\n", "from collections import Counter\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nN,*A = map(int, open(0).read().split())\nCnt = Counter(A)\nfor i in range(1,N+1):\n  if Cnt[i]==2:\n    p = i\n    break\na = A.index(p)\nb = A[::-1].index(p)\nfor i in range(1,N+2):\n  print((cmb(N+1,i,mod)-cmb(a+b,i-1,mod))%mod)", "n=int(input())\nl=list(map(int,input().split()))\ncnt=[0 for i in range(n+1)]\nmod=10**9+7\nfact=[1]*(n+2)\ninv=[1]*(n+2)\nfor i in range(2,n+2):\n    fact[i]=i*fact[i-1]%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(n+1,1,-1):\n    inv[i-1]=inv[i]*i%mod\ndef comb(x,y):return fact[x]*inv[y]%mod*inv[x-y]%mod if x>=y>=0 else 0\nfor i in range(n+1):\n    if cnt[l[i]]:\n        r=cnt[l[i]]+n-i;break\n    cnt[l[i]]+=i\nelse:r=n-cnt[l[0]]\nfor i in range(1,n+2):\n    print((comb(n+1,i)-comb(r,i-1))%mod)", "MOD = 1000000000+7\nn = int(input())\na = list(map(int,input().split()))\n\ncount = [0]*n\nfor i,ai in enumerate(a,1):\n    count[ai-1] += 1\n    if(count[ai-1] == 2):\n        common = a.index(ai) + (n+1-i)\n        break\n\nfac = [1]*(n+2)\nfac_inv =  [0]*(n+2)\n\nfor i in range(n+1):\n    fac[i+1] = (fac[i] * (i+1)) %MOD\nfac_inv[-1] = pow(fac[-1],MOD-2,MOD)\nfor i in range(n+1,0,-1):\n    fac_inv[i-1] = (fac_inv[i] * i) % MOD\n\nfor i in range(1,n+2):\n    ans = (fac[n+1] * (fac_inv[i] * fac_inv[n+1-i])%MOD)%MOD\n    if common >= i-1:\n        ans -= (fac[common] * (fac_inv[i-1] * fac_inv[common - (i-1)])%MOD)%MOD\n    print(ans%MOD)", "class Factorial():\n    def __init__(self,n,mod):\n        self.mod = mod\n        self.factorial = [0 for _ in range(n+1)]\n        self.inv = [0 for _ in range(n+1)]\n        self.factorial[0] = 1\n        for i in range(n):\n            self.factorial[i+1] = self.factorial[i]*(i+1)%mod\n        self.inv[n] = pow(self.factorial[n],mod-2,mod)\n        for i in range(n)[::-1]:\n            self.inv[i] = self.inv[i+1]*(i+1)%mod\n\n    def comb(self,m,k):\n        if m-k<0 or k<0: return 0\n        return self.factorial[m]*self.inv[k]*self.inv[m-k]%self.mod\n\nMOD = 1000000007\n\nN = int(input())\nA = list(map(int,input().split()))\n\nF = Factorial(N+1,MOD)\n\ntmp = [None for _ in range(N)]\n\nfor i in range(N+1):\n    if tmp[A[i]-1] is None:\n        tmp[A[i]-1] = i\n    else:\n        a = tmp[A[i]-1]\n        b = i\n        break\n\nA = []\n\nfor i in range(1,N+2):\n    A.append((F.comb(N-1,i)+F.comb(N-1,i-2)+F.comb(N-1,i-1)*2-F.comb(N+a-b,i-1))%MOD)\n\nprint('\\n'.join(map(str,A)))", "from collections import Counter\n\nU = 10**5+1\nMOD = 10**9+7\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n    \ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[k]\n    z %= MOD\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n  \nn = int(input())\nA = list(map(int, input().split()))\nx = Counter(A).most_common()[0][0]\nleft = A.index(x)\nright = A[::-1].index(x)\nfor k in range(1, n+2):\n  ans = comb(n+1, k) - comb(left+right, k-1)\n  ans %= MOD\n  print(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nb = [0]*(n+1)\nfor i in range(n+1):\n    if b[a[i]] == 0:\n        b[a[i]] += 1\n    else:\n        d = a[i]\n\nl = 0\nr = 0\nc = 0\nfor i in range(n+1):\n    if a[i] != d and c == 0:\n        l += 1\n    elif a[i] != d and c == 2:\n        r += 1\n    elif a[i] == d:\n        c += 1\n\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9 + 7\nN = 100011\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nfor i in range(1, n+2):\n    print(((cmb(n+1, i, mod)-cmb(r+l, i-1, mod))%mod))\n", "N=10**5+3\nmod=10**9+7\nfac=[1]*(N+1)\nfor i in range(1,N+1):\n    fac[i]=fac[i-1]*i%mod\ninv_fac=[1]*(N+1)\ninv_fac[N]=pow(fac[N],mod-2,mod)\nfor i in range(N-1,0,-1):\n    inv_fac[i]=inv_fac[i+1]*(i+1)%mod\ndef nCr(n,r):\n    if n<0 or r<0 or r>n:\n        return 0\n    return fac[n]*inv_fac[r]%mod*inv_fac[n-r]%mod\nn=int(input())\nA=list(map(int,input().split()))\nused=[0]*n\nfor i in range(n+1):\n    a=A[i]\n    if used[a-1]==0:\n        used[a-1]=[1,i]\n    else:\n        x=a\n        y=used[a-1][1]\n        z=i\n        break\nprint(n)\nfor i in range(2,n+2):\n    ans=nCr(n+1,i)-nCr(n-z+y,i-1)\n    print(ans%mod)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nn = INT()\na = LIST()\n\ncheck = [0]*(n+1)\n\nkaburi = 0\nidx1 = 0\nidx2 = 0\n\nmod = 10**9 + 7\nN = 10**6  # \u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u308c\u308b\nfactorial = [1]\nfor i in range(1, N):\n    factorial.append(factorial[i-1] * i % mod)\ndef power(x, y):\n    if y == 0:\n        return 1\n    elif y == 1:\n        return x % mod\n    elif y % 2 == 0:\n        return power(x, int(y/2)) ** 2 % mod\n    else:\n        return power(x, int((y-1)/2)) ** 2 * x % mod\ndef C(n, r):\n    return (((factorial[n] * x_inv[r]) % mod) * x_inv[n-r]) % mod\nx_inv = [0] * (N)\nx_inv[-1] = power(factorial[-1], mod-2)\nfor i in range(N-2, -1, -1):\n    x_inv[i] = x_inv[i+1] * (i+1) % mod\n\nfor i in range(n+1):\n\tif check[a[i]]:\n\t\tkaburi = a[i]\n\t\tidx1 = check[a[i]]\n\t\tidx2 = i + 1\n\t\tbreak\n\tcheck[a[i]] = i + 1\n\n# print(kaburi)\n# print(idx1, idx2)\nl = idx1-1\nr = n-idx2+1\nidx1 -= 1\nidx2 -= 1\n\nthre = n-(idx2-idx1)+2\n# print(l, r)\n\nfor k in range(1, n+2):\n\tif k >= thre:\n\t\tprint((C(n+1, k)%mod))\n\telse:\n\t\tprint(((C(n+1, k)-C(r+l, k-1))%mod))\n", "def build_combination(n, mod):\n    def cmb(n, r):\n        if r < 0 or n < r:\n            return 0\n        return (((invs[r] * invs[n - r]) % mod) * fact[n]) % mod\n\n    fact = [1] * (n + 1)\n    for x in range(2, n + 1):\n        fact[x] = x * fact[x - 1] % mod\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(fact[n], mod - 2, mod)\n    for x in range(n - 1, 0, -1):\n        invs[x] = invs[x + 1] * (x + 1) % mod\n\n    return cmb\n\n\ndef find(a):\n    \"\"\"\u91cd\u8907\u3059\u308b\u6570\u5024\u306eindex\u306e\u30da\u30a2\u3092\u8fd4\u3059\"\"\"\n    n = len(a)\n    checked = [-1] * (n + 1)\n    for i, x in enumerate(a):\n        if checked[x] != -1:\n            return checked[x], i\n        else:\n            checked[x] = i\n    raise ValueError\n\n\ndef main():\n    mod = 10 ** 9 + 7\n\n    n = int(input())\n    *a, = list(map(int, input().split()))\n\n    cmb = build_combination(n + 1, mod)\n\n    li, ri = find(a)\n\n    for k in range(1, n + 2):\n        ret = (cmb(n + 1, k) - cmb(n + 1 - (ri - li + 1), k - 1)) % mod  # mod\u5fd8\u308c\n        print(ret)\n        # for j in range(k + 1):\n        #     ret -= cmb(li, j) * cmb(n - ri, k - j - 1)\n        # PxQxR\u306ePR\u304b\u3089k-1\u500b\u3068\u308b\n        # PR\u306e\u53d6\u308a\u65b9\u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b\u3088\u308a\u3001\u533a\u9593PR\u306b\u542b\u307e\u308c\u308b\u7dcf\u500b\u6570\u304b\u3089k-1\u500b\u9078\u3076\u65b9\u6cd5\u3092\u8003\u3048\u308b\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\nU = 10**5+1\nMOD = 10**9+7\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n    \ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[k]\n    z %= MOD\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n  \nn = int(input())\nA = list(map(int, input().split()))\nx = Counter(A).most_common()[0][0]\nleft = A.index(x)\nright = A[::-1].index(x)\nprint(n)\nfor k in range(2, n+2):\n  ans = comb(n+1, k) - comb(left+right, k-1)\n  ans %= MOD\n  print(ans)", "from collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nMAX = 10 ** 5 + 10\n\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 1)\nfor i in range(2, MAX + 1):\n    inv[i] = inv[mod % i] * (mod - mod // i) % mod\n\nfact_inv = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n\n    return fact[n] * fact_inv[n-r] * fact_inv[r] % mod\n\n\nc = Counter(a)\nfor key, val in list(c.items()):\n    if val == 2:\n        break\n\nidx = []\nfor i, e in enumerate(a):\n    if e == key:\n        idx.append(i)\n\nl = idx[0]\nr = n - idx[1]\nfor k in range(1, n + 2):\n    ans = comb(n + 1, k) - comb(l + r, k - 1)\n    ans %= mod\n    print(ans)\n", "import sys\ninput=sys.stdin.readline\n\n\ndef solve():\n    N = int(input())\n    d = {i:-1 for i in range(1, N+1)}\n    *l, = list(map(int, input().split()))\n\n    MOD = 10**9+7\n    n = N+1\n    fac = [1]*(n+1)\n    rev = [1]*(n+1)\n    \n    for i in range(1,n+1):\n        fac[i] = i*fac[i-1]%MOD\n        rev[i] = pow(fac[i], MOD-2, MOD)\n    \n    comb = lambda a,b:(fac[a]*rev[a-b]*rev[b])%MOD if a>=b else 0\n\n    for i, j in enumerate(l):\n        if d[j] != -1:\n            break\n        d[j] = i\n\n    v = d[j]+N-i\n    for i in range(1, N+2):\n        print(((comb(N+1, i)-comb(v, i-1))%MOD))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\nN = 100000\n\n#\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv_t = [0]+[1]\nfor i in range(2, N):\n  inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]\n\n#\u968e\u4e57\u8a08\u7b97\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n\tkai.append(kai[-1] * i % mod)\n\trev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    else:\n        return kai[n] * rev_kai[r] * rev_kai[n-r] % mod\n\nd = {}\n\n# n1\u500b X n2\u500b X n3\u500b\nn1 = 0\nn2 = 0\nn3 = 0\n\nfor i, ai in enumerate(a):\n    if ai not in d:\n        d[ai] = i\n    else:\n        n1 = d[ai]\n        n2 = i - d[ai] - 1\n        n3 = n - i\n        break\n\nfor i in range(1, n+2):\n    ans = 0\n    # X\u3092\u9078\u3070\u306a\u3044\n    ans += cmb(n-1, i)\n    # X\u30922\u56de\u9078\u3076\n    ans += cmb(n-1, i-2)\n    # X\u30921\u56de\u9078\u3076 \u304b\u3064 X\u306e\u9593\u304b\u3089\u306f\u9078\u3070\u306a\u3044\n    ans += cmb(n-1-n2, i-1)\n    # X\u30921\u56de\u9078\u3076 \u304b\u3064 X\u306e\u9593\u304b\u3089\u4e00\u3064\u4ee5\u4e0a\u9078\u3076\n    if i >= 2 and i <= n:\n        ans += 2 * (cmb(n2+n1+n3, i-1) - cmb(n1+n3, i-1))\n\n    print((ans % mod))\n", "# \u5168\u90e8\u9055\u3046\u8981\u7d20\u306a\u3089\u3001k\u500b\u304b\u3089\u6210\u308b\u90e8\u5206\u5217\u306e\u6570\u306f\u5358\u7d14\u306b (n+1) C k\u3067\u3042\u308b\n# \u3053\u3053\u3067\u3042\u308b2\u3064\u304c\u540c\u3058\u6570\u3067\u3042\u3063\u305f\u5834\u5408\u3001\u305d\u308c\u306b\u5bc4\u3063\u3066\u540c\u4e00\u8996\u3055\u308c\u308b\u6761\u4ef6\u306f\u306a\u306b\u304b?\n# \u540c\u3058\u6570\u30921\u3064\u3060\u3051\u542b\u3080 \u304b\u3064 2\u3064\u306e\u9593\u306e\u6570\u3092\u542b\u307e\u306a\u3044 \u3067\u3042\u308b\u3002\n# 2\u3064\u306e\u5916\u5074\u306b\u3042\u308b\u8981\u7d20\u306e\u6570\u3092j\u3068\u3059\u308b\u3068 \u3001j\u500b\u306e\u4e2d\u304b\u3089k-1\u500b\u3092\u9078\u3076\u304b\u3089 j C (k-1)\u3067\u3042\u308b\u3002\n# j < k-1\u306e\u5834\u5408\u306f\u3001\u540c\u4e00\u8996\u3055\u308c\u308b\u3082\u306e\u306f\u7121\u3044\u306e\u30670\u3068\u898b\u306a\u305b\u3070\u3088\u3044\u3002\n\nn = int(input())\nnums = list(map(int, input().split()))\n\nmax_len = n+5  # \u9069\u5b9c\u5909\u66f4\u3059\u308b\nmod = 10**9 + 7\n\n# \u4e8c\u9805\u4fc2\u6570\u306e\u5de6\u5074\u306e\u6570\u5b57\u306e\u6700\u5927\u5024\u3092 max_len\u3000\u3068\u3059\u308b\u3002n\u3068\u304b\u3060\u3068\u4ed6\u306e\u5909\u6570\u3068\u88ab\u308a\u305d\u3046\u306a\u306e\u3067\u3002\n# factori_table = [1, 1, 2, 6, 24, 120, ...] \u8981\u306f factori_table[n] = n!\n# \u8a08\u7b97\u6642\u9593\u306fO(max_len * log(mod))\nmodinv_table = [-1] * (max_len + 1)\nmodinv_table[0] = None  # \u4e07\u304c\u4e00\u4f7f\u3063\u3066\u3044\u305f\u3068\u304d\u306b\u3067\u304d\u308b\u3060\u3051\u65e9\u671f\u306b\u539f\u56e0\u7279\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u306e\u3067\u3001None\u306b\u3057\u3066\u304a\u304f\u3002\nfactori_table = [1] * (max_len + 1)\nfactori_inv_table = [1] * (max_len + 1)\nfor i in range(1, max_len + 1):\n    factori_table[i] = factori_table[i-1] * (i) % mod\n\nmodinv_table[1] = 1\nfor i in range(2, max_len + 1):\n    modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n    factori_inv_table[i] = factori_inv_table[i-1] * modinv_table[i] % mod\n\n\ndef binomial_coefficients(n, k):\n    '''\n    n! / (k! * (n-k)! )\n    0 <= k <= n\u3092\u6e80\u305f\u3055\u306a\u3044\u3068\u304d\u306f\u5909\u306a\u5024\u3092\u8fd4\u3057\u3066\u3057\u307e\u3046\u306e\u3067\u3001\u5148\u306bNone\u3092\u8fd4\u3059\u3053\u3068\u306b\u3059\u308b\u3002\n    \u5834\u5408\u306b\u3088\u3063\u3066\u306f0\u306e\u307b\u3046\u304c\u9069\u5207\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n    '''\n    if not 0 <= k <= n:\n        return None\n    return (factori_table[n] * factori_inv_table[k] * factori_inv_table[n-k]) % mod\n\n# \u91cd\u8907\u8981\u7d20\u3092\u63a2\u7d22\nappearance = [-1] * (n+1)\nfor idx, num in enumerate(nums):\n    if appearance[num] == -1:\n        appearance[num] = idx\n    else:\n        dup = [appearance[num], idx]\n        break\n\nj = n+1 - (dup[1] - dup[0] + 1)\n\nfor k in range(1, n+1+1):\n    if k-1 > j:\n        print((binomial_coefficients(n+1, k)))\n    else:\n        print(((binomial_coefficients(n+1, k) - binomial_coefficients(j, k-1)) % mod))\n", "class COM:\n    def __init__(self, n: int, mod: int):\n        self.n = n\n        self.mod = mod\n        self.fact = [0] * (n + 1)\n        self.factinv = [0] * (n + 1)\n        self.inv = [0] * (n + 1)\n        \n        self.fact[0] = self.fact[1] = 1\n        self.factinv[0] = self.factinv[1] = 1\n        self.inv[1] = 1\n        for i in range(2, n + 1):\n            self.fact[i] = (self.fact[i - 1] * i) % mod\n            self.inv[i] = (-self.inv[mod % i] * (mod // i)) % mod\n            self.factinv[i] = (self.factinv[i - 1] * self.inv[i]) % mod\n    \n    def get_cmb(self, n: int, k: int):\n        if (k < 0) or (n < k):\n            return 0\n        k = min(k, n - k)\n        return self.fact[n] * self.factinv[k] % self.mod * self.factinv[n - k] % self.mod\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    MOD = 10 ** 9 + 7\n    \n    pos = dict()\n    l, r = -1, -1\n    for i in range(n + 1):\n        if a[i] in pos:\n            l, r = pos[a[i]], i\n            break\n        pos[a[i]] = i\n    \n    com = COM(10 ** 5 + 1, MOD)\n    print(n)\n    for i in range(2, n + 1):\n        ans = com.get_cmb(n + 1, i) - com.get_cmb(l + n - r, i - 1)\n        print((ans % MOD))\n    print((1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "mod = 1000000007\nn= int(input())\na= list(map(int,input().split()))\ncheck = [0]*(n+1)\ng1=[1,1]\ng2=[1,1]\ninverse=[0,1]\nfor i in range(2,n+1+1):\n    g1.append((g1[-1]*i)%mod)\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g2.append((g2[-1]*inverse[-1])%mod)\ndef cmb2(n,r):\n    mod = 1000000007\n    if (r<0 or r>n ):return 0\n    r = min(r, n-r)\n    return g1[n]*g2[r]*g2[n-r]%mod\nr=-1\njn=-1\nfor i in range(n+1):\n    check[a[i]-1]+=1\n    if check[a[i]-1]==2:\n        jn,r=a[i],i\n        break\nl=a.index(jn)\ns = min(l,n-r)\nt = max(l,n-r)\nprint(n)\nfor p in range(2,n+1):\n  w2=cmb2(n+1,p)\n  y2=cmb2(s+t,p-1)\n  print(((w2+mod)-y2) % mod)\nprint(1)", "n = int(input())\na = [int(x) for x in input().split()]\n\nmod = 10**9 + 7\n\n\nclass Comb(object):\n    def __init__(self, N, mod=10**9 + 7):\n        self.mod = mod\n        self.fac, self.inv = [1] * (N + 1), [1] * (N + 1)\n        for i in range(2, N + 1):\n            self.fac[i] = self.fac[i - 1] * i % mod\n            self.inv[i] = self.inv[i - 1] * pow(i, mod - 2, mod) % mod\n\n    def calc(self, n, k):\n        if n >= k:\n            return self.fac[n] * self.inv[k] * self.inv[n - k]\n        else:\n            return 0\n\n\nc = [0] * (n + 1)\nindexes = [[] for _ in range(n+1)]\nfor i in range(n + 1):\n    c[a[i]] += 1\n    indexes[a[i]].append(i)\n    if c[a[i]] == 2:\n        indexes = indexes[a[i]]\n        break\n\nm = indexes[0] + (n - indexes[1])\ncomb = Comb(n + 1)\nfor k in range(1, n + 2):\n    x = comb.calc(n + 1, k)\n    y = comb.calc(m, k - 1)\n    ans = (x - y) % mod\n    print(ans)\n", "from collections import Counter\n\nN = int(input())\nA = tuple(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nU = N + 10\nfact = [1] * (U + 1)\ninv = [1] * (U + 1)\n\nfor i in range(1, U + 1):\n    fact[i] = fact[i - 1] * i % mod\n\ninv[U] = pow(fact[i], mod - 2, mod)\nfor i in range(U, 0, -1):\n    inv[i - 1] = inv[i] * i % mod\n\n\ndef comb(N, r):\n    if r < 0 or r > N:\n        return 0\n    res = fact[N] * inv[r] % mod\n    res = res * inv[N - r] % mod\n    return res\n\n\nX = Counter(A).most_common()[0][0]\nleft = A.index(X)\nright = A[::-1].index(X)\nLR = left + right\n\nfor i in range(1, N + 2):\n    ans = comb(N+1, i)-comb(LR, i-1)\n    ans = (ans + mod) % mod\n    print(ans)\n", "n=int(input())\nl=list(map(int,input().split()))\nmemo={}\n\nfor i in range(n+1):\n    if l[i]in memo:\n        g=l[i]\n        x,y=memo[g],i\n        break\n    memo[l[i]]=i\nmod=10**9+7\n\nfact=[1]*(n+1+1)\ninv=[1]*(n+1+1)\nfor i in range(2,n+1+1):\n    fact[i]=i*fact[i-1]%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(n+1,1,-1):\n    inv[i-1]=inv[i]*i%mod\ndef comb(x,y):return fact[x]*inv[y]%mod*inv[x-y]%mod if x>=y>=0 else 0\nfor i in range(1,n+2):print((comb(n+1,i)-comb(x+n-y,i-1))%mod)", "class Factorial:\n    def __init__(self, n, mod=10**9+7):\n        self.fac = [0] * (n+1)\n        self.ifac = [0] * (n+1)\n        self.fac[0] = 1\n        self.ifac[0] = 1\n        self.mod = mod\n        modmod = self.mod - 2\n        for i in range(n):\n            self.fac[i+1] = self.fac[i] * (i+1) % self.mod\n            self.ifac[i+1] = self.ifac[i] * pow(i+1, modmod, self.mod) % self.mod\n\n    def comb(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        tmp =  self.ifac[n-r] * self.ifac[r] % self.mod\n        return tmp * self.fac[n] % self.mod\n\n    def perm(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        return (self.fac[n] * self.ifac[n-r]) % self.mod\n\nn = int(input())\na = list(map(int, input().split()))\nmod = 10**9+7\n\nd = {}\nfor i in range(0,n+1):\n    if a[i] not in d:\n        d[a[i]] = i\n    else:\n        l,r = d[a[i]], n-i\n        break\n\nfact = Factorial(n+1)\n\nfor i in range(1,n+2):\n    ans = fact.comb(n+1,i)\n    s = fact.comb(l+r,i-1)\n    ans -= s\n    while ans < 0:\n        ans += mod\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nlst = [-1] * (N + 1)\nfor i in range(N + 1):\n    a = A[i]\n    if lst[a] == -1:\n        lst[a] = i\n    else:\n        left = lst[a]\n        right = i\n        break\n# print (left, right)\nF = Factorial(N + 1, MOD).comb\n\nfor i in range(1, N + 2):\n    if left + N - right >= i - 1:\n        tmp = F(N + 1, i) - F(left + (N- right), i - 1)\n    else:\n        tmp = F(N + 1, i)\n    print((tmp % MOD))\n\n\n\n\n", "N = int(input())\nA = list(map(int,input().split()))\nMOD = 10**9+7\n\nfrom collections import Counter\nctr = Counter(A)\nd = ctr.most_common(1)[0][0]\nx = A.index(d)\ny = x+1 + A[x+1:].index(d)\nf = x + N-y\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = []\nfor i in range(1,N+2):\n    ans.append((comb(N+1,i) - comb(f,i-1)) % MOD)\nprint(*ans, sep='\\n')", "mod = 10**9 + 7;\n\ndef inv(x):\n  m = mod\n  u = 1\n  v = 0\n  while m:\n    t = x // m\n    x -= t * m\n    x, m = m, x\n    u -= t * v\n    u, v = v, u\n  return u % mod\n\nn = int(input())\n\nfac = [1]\nfor i in range(1, n + 2):\n  fac.append(fac[i - 1] * i % mod)\n\na = list(map(int, input().split()))\nnum = [0] * (n + 1)\nfor x in a:\n  num[x] += 1\n\ntwo = -1\nfor i, c in enumerate(num):\n  if c == 2:\n    two = i\n    break\n\nl = -1\nr = -1;\nfor i in range(n + 1):\n  if l == -1 and a[i] == two:\n    l = i\n  elif l != -1 and a[i] == two:\n    r = n - i\n\nfor k in range(1, n + 2):\n  if k - 1 <= l + r:\n    print(((fac[n + 1] * inv(fac[k] * fac[n + 1 - k]) - fac[l + r] * inv(fac[k - 1] * fac[l + r - k + 1])) % mod))\n  else:\n    print((fac[n + 1] * inv(fac[k] * fac[n + 1 - k]) % mod))\n", "#abc066d\nmod=10**9+7\nfact=[1]*(10**5+2)\nfor n in range(1,10**5+2):\n fact[n]=n*fact[n-1]%mod\n\ndef com(n,k,m):\n return fact[n]*pow(fact[k],m-2,m)*pow(fact[n-k],m-2,m)%m\n\nN=int(input())\nA=list(map(int,input().split()))\nc=[-1]*N\nfor i in range(N+1):\n if c[A[i]-1]!=-1:\n  break\n c[A[i]-1]=i\nj=c[A[i]-1]\ni=N-i\nfor k in range(1,N+2):\n res=com(N+1,k,mod)\n if k-1<=i+j:\n  res-=com(i+j,k-1,mod)\n print(res%mod)\n", "n=int(input())\nalist=list(map(int,input().split()))\n\nMOD=10**9+7\ninv_table = [0]+[1]\nfor i in range(2,n+2):\n  inv_table.append(-(MOD//i)*inv_table[MOD%i]%MOD)\n\ndic_a={}\nsame_pair=None\nfor i in range(n+1):\n  if alist[i] in dic_a:\n    same_pair=(dic_a[alist[i]],i)\n    break\n  else:\n    dic_a[alist[i]]=i\npair_diff=n-(same_pair[1]-same_pair[0])\n#print(same_pair,pair_diff)\n\ncomb1,comb2=1,1\nfor r in range(1,n+2):\n  comb1*=(n-r+2)*inv_table[r]\n  comb1%=MOD\n  #print(comb1,comb2)\n  print((comb1-comb2)%MOD)\n  comb2*=(pair_diff-r+1)*inv_table[r]\n  comb2%=MOD", "n = int(input())\nal = list(map(int, input().split()))\n\nimport collections\nc = collections.Counter(al)\ncc = c.most_common()[0][0]\n\nda = ([i for i, x in enumerate(al) if x ==cc ][0])\ndb = ([i for i, x in enumerate(al) if x ==cc ][1])\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, n + 2):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nprint(n)\nfor i in range(2,n+2):\n    print((cmb(n-1,i,p)+ cmb(n-1,i-1,p)*2 -cmb(da+n-db,i-1,p) + cmb(n-1,i-2,p)) % p)", "MOD = 10**9 + 7\nMOD_t_MAX = 10**5+10\n\nfac  = [None] * MOD_t_MAX\nfinv = [None] * MOD_t_MAX\ninv  = [None] * MOD_t_MAX\ndef MOD_COM_init():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MOD_t_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\ndef MOD_COM(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [-1]*(n+1)\n    l, r = -1, -1\n    for i, v in enumerate(a):\n        if p[v] == -1:\n            p[v] = i\n        else:\n            l = p[v]\n            r = i\n            break\n    MOD_COM_init()\n    for i in range(1, n+2):\n        if i == 1:\n            print(n)\n        else:\n            tmp = MOD_COM(n+1, i)\n            tmp -= MOD_COM(l+(n+1-r-1), i-1)\n            while tmp < 0:\n                tmp += MOD\n            print(tmp)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\nN = int(input())\nA = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\n# \u3068\u308a\u3042\u3048\u305a\u4e8c\u9805\u4fc2\u6570\u3092\u7b54\u3048\u306b\u3076\u3061\u8fbc\u3080\nfact = [1]\nfor i in range(1, N + 2):\n    fact.append(fact[-1] * i % mod)\n\n\nans = [0] * (N + 2)\nfN = fact[N + 1]\nfor i in range(1, N + 2):\n    div = fact[i] * fact[N - i + 1] % mod\n    value = fN * pow(div, mod - 2, mod) % mod\n    ans[i] = value\n\n# \u6570\u5217A\u306e\u4e2d\u306b2\u3064\u3042\u308b\u3084\u3064x\n# x\u306e\u5de6\u5074\u3001\u53f3\u5074\u306b\u3042\u308b\u3084\u3064\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\nx = Counter(A).most_common()[0][0]\nleft = A.index(x)\nright = N - A.index(x, left + 1)\nM = left + right\n\nfor i in range(0, M + 1):\n    num = fact[M]\n    div = fact[i] * fact[M - i] % mod\n    comb = num * pow(div, mod - 2, mod) % mod\n    ans[i + 1] = (ans[i + 1] - comb + mod) % mod\n\nprint(*ans[1:], sep=\"\\n\")\n", "L=10**5+3\nMOD=10**9+7\nfac=[1]*(L+1)\nfor i in range(1,L+1):\n  fac[i]=fac[i-1]*i%MOD\ninv_fac=[1]*(L+1)\ninv_fac[L]=pow(fac[L],MOD-2,MOD)\nfor i in range(L-1,0,-1):\n  inv_fac[i]=inv_fac[i+1]*(i+1)%MOD\n\ndef cmb(n,r):\n  if n<0 or r<0 or r>n:\n    return 0\n  return fac[n]*inv_fac[r]%MOD*inv_fac[n-r]%MOD\n\nN=int(input())\nA=list(map(int,input().split()))\n\nused=[0]*N\nfor i in range(N+1):\n  a=A[i]\n  if used[a-1]==0:\n    used[a-1]=[1,i]\n  else:\n    x=a\n    y=used[a-1][1]\n    z=i\n    break\n\nprint(N)\nfor i in range(2,N+2):\n  ans=cmb(N+1,i)-cmb(N-z+y,i-1)\n  print(ans%MOD)"]
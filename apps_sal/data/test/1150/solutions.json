["def f(x, y, a, b, n):\n    return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\n\n\ndef check(p):\n    d = {}\n    for i in range(len(p) - 1):\n        for j in range(i + 1, len(p)):\n            dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n            d[dist] = d.get(dist, 0) + 1\n    if len(d) != 2:\n        return 0\n    a, b = sorted(d)\n    return 2 * a == b and d[a] == 4 and d[b] == 2\n\n\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\nfor t in range(int(input())):\n    moles, ans = [list(map(int, input().split())) for x in range(4)], 13\n    for a in variants:\n        if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n            ans = min(ans, sum(a))\n    print(ans if ans != 13 else -1)\n", "from sys import stdin\nfrom itertools import product\n\nlines = list([_f for _f in stdin.read().split('\\n') if _f])\n\ndef parseline(line):\n\treturn list(map(int, line.split()))\n\nlines = list(map(parseline, lines))\nn = lines[0][0]\nassert len(lines) >= 4 * n + 1\n\nclass Unit:\n\tdef __init__(self, x, y, a, b):\n\t\tself.pos = x, y\n\t\tself.home = a, b\n\ndef to_unit(l):\n\treturn Unit(l[0], l[1], l[2], l[3])\n\ndef squads():\n\tfor i in range(n):\n\t\tyield list(map(to_unit, lines[4*i+1:4*i+5]))\n\ndef is_90_degree(a, b, c, d):\n\treturn 0 == sum((bi - ai) * (di - ci) for ai,bi,ci,di in zip(a,b,c,d))\n\ndef dist_sqr(a, b):\n\treturn (b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2\n\ndef is_square(points):\n\ta, b, c, d = points\n\tif a == b == c == d:\n\t\treturn False\n\tif not is_90_degree(a, b, c, d):\n\t\tb, d = d, b\n\t\tif not is_90_degree(a, b, c, d):\n\t\t\ta, d = d, a\n\t\t\tif not is_90_degree(a, b, c, d):\n\t\t\t\treturn False\n\tif not (c[0] + d[0] == b[0] + a[0] and c[1] + d[1] == b[1] + a[1]):\n\t\treturn False\n\tif not (dist_sqr(a, b) == dist_sqr(c, d)):\n\t\treturn False\n\treturn True\n\ndef rotate(point, pole, angle):\n\tresult = point\n\tfor i in range(angle):\n\t\tresult = -result[1]+pole[1]+pole[0], result[0]-pole[0]+pole[1] \n\treturn result\n\ndef rotate_squad(squad, rotation):\n\treturn [rotate(unit.pos, unit.home, angle) for unit, angle in zip(squad, rotation)]\n\nrotations = list(product([0, 1, 2, 3], repeat=4))\n\nINF = 10000000\n\nfor squad in squads():\n\tmin_rotations = INF\n\tfor rotation in rotations:\n\t\tif is_square(rotate_squad(squad, rotation)):\n\t\t\tmin_rotations = min(min_rotations, sum(rotation))\n\tif min_rotations == INF:\n\t\tmin_rotations = -1\n\tprint(min_rotations)\n", "def rotate(p) :\n    return [-p[1]+p[2]+p[3], -p[2]+p[3]+p[0],p[2],p[3]]\ndef isS(P) :\n    X = [P[0][0]*4,P[1][0]*4,P[2][0]*4,P[3][0]*4]\n    Y = [P[0][1]*4,P[1][1]*4,P[2][1]*4,P[3][1]*4]\n    p = sum(X)//4\n    q = sum(Y)//4\n    r = [(X[i]-p)**2 + (Y[i]-q)**2 for i in range(4)]\n    if len(set(r)) != 1 :\n        return False\n    for i in range(4) :\n        for j in range(i+1,4) :\n            if X[i] == X[j] and Y[i] == Y[j] :\n                return False\n\n    for i in range(4) :\n        for j in range(i+1,4) :\n            k,l = list(set([0,1,2,3])-set([i,j]))\n            t1 = (X[i] - X[k])**2 + (Y[i]-Y[k])**2\n            t2 = (X[i] - X[l])**2 + (Y[i]-Y[l])**2\n            t3 = (X[j] - X[k])**2 + (Y[j]-Y[k])**2\n            t4 = (X[j] - X[l])**2 + (Y[j]-Y[l])**2\n            if t1 == t2 == t3 == t4 : return True\n    return False\n\nN = int(input())\nfor i in range(N) :\n    res = []\n    P = []\n    for j in range(4) :\n        p = list(map(int,input().split(' ')))\n        P.append(p)\n    \n    for k1 in range(4) :\n        for k2 in range(4) :\n            for k3 in range(4) :\n                for k4 in range(4) :\n                    if isS(P) : res.append(k1+k2+k3+k4)\n                    P[3] = rotate(P[3])\n                P[2] = rotate(P[2])\n            P[1] = rotate(P[1])\n        P[0] = rotate(P[0])\n    res = min(res) if res else -1\n    print(res)\n\n", "3\n\nfrom itertools import product, combinations\n\n\ndef process(case):\n    regiment = map(rotate, homes, positions, case)\n    return sum(case) if is_square(regiment) else float('inf')\n\n\ndef is_square(regiment):\n    dists = list(map(lambda arg: dist_sq(*arg), combinations(regiment, 2)))\n    dists.sort()\n    return 0 < dists[0] == dists[3] < dists[4] == dists[5]\n\n\ndef dist_sq(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n\ndef rotate(home, position, step):\n    (x, y), (a, b) = position, home\n    if step == 0:\n        return x, y\n    if step == 1:\n        return a-(y-b), b+(x-a)\n    if step == 2:\n        return a-(x-a), b-(y-b)\n    if step == 3:\n        return a+(y-b), b-(x-a)\n\nn = int(input())\nfor r in range(n):\n    positions = []\n    homes = []\n    for i in range(4):\n        x, y, a, b = map(int, input().split())\n        positions.append((x, y))\n        homes.append((a, b))\n    all_cases = product(range(4), repeat=4)\n    result = min(map(process, all_cases))\n    print(result if result != float('inf') else -1)", "def rotate(i, j):    \n    x, y, p, q = a[i] \n    for k in range(1, j+1):\n        x, y = p - (y - q), q + (x - p)\n    c[i] = x, y\n\ndef dist(i, j):\n    x, y = c[i]\n    p, q = c[j]\n    return (x - p) ** 2 + (y - q) ** 2\n\ndef check(move):\n    for i in range(4):      \n        rotate(i, move[i])\n    p = [1,2,3] \n    p.sort(key = lambda x: dist(0, x))\n    d = [dist(0, x) for x in p]\n    if d[0] == d[1] == d[2] / 2 and d[2] > 0:\n        return True if dist(p[0], p[1]) == d[2] else False\n    else:\n        return False\n\nn = int(input())\na = [0] * 4\nc = [0] * 4\nfor i in range(n):\n    a[0] = list(map(int, input().split()))\n    a[1] = list(map(int, input().split()))\n    a[2] = list(map(int, input().split()))\n    a[3] = list(map(int, input().split()))\n    ans = 17\n    for k in range(4):\n        for l in range(4):\n            for p in range(4):\n                for q in range(4):\n                    if k + l + p + q < ans and check([k, l, p, q]):\n                        ans = k + l + p + q\n    print(ans if ans != 17 else -1)\n", "def rotate(p) :\n    return [-p[1]+p[2]+p[3], -p[2]+p[3]+p[0],p[2],p[3]]\ndef isS(P) :\n    X = [P[0][0]*4,P[1][0]*4,P[2][0]*4,P[3][0]*4]\n    Y = [P[0][1]*4,P[1][1]*4,P[2][1]*4,P[3][1]*4]\n    p = sum(X)//4\n    q = sum(Y)//4\n    r = [(X[i]-p)**2 + (Y[i]-q)**2 for i in range(4)]\n    if len(set(r)) != 1 :\n        return False\n    for i in range(4) :\n        for j in range(i+1,4) :\n            if X[i] == X[j] and Y[i] == Y[j] :\n                return False\n\n    for i in range(4) :\n        for j in range(i+1,4) :\n            k,l = list(set([0,1,2,3])-set([i,j]))\n            t1 = (X[i] - X[k])**2 + (Y[i]-Y[k])**2\n            t2 = (X[i] - X[l])**2 + (Y[i]-Y[l])**2\n            t3 = (X[j] - X[k])**2 + (Y[j]-Y[k])**2\n            t4 = (X[j] - X[l])**2 + (Y[j]-Y[l])**2\n            if t1 == t2 == t3 == t4 : return True\n    return False\n\nN = int(input())\nfor i in range(N) :\n    res = []\n    P = []\n    for j in range(4) :\n        p = list(map(int,input().split(' ')))\n        P.append(p)\n    \n    for k1 in range(4) :\n        for k2 in range(4) :\n            for k3 in range(4) :\n                for k4 in range(4) :\n                    if isS(P) : res.append(k1+k2+k3+k4)\n                    P[3] = rotate(P[3])\n                P[2] = rotate(P[2])\n            P[1] = rotate(P[1])\n        P[0] = rotate(P[0])\n    res = min(res) if res else -1\n    print(res)", "import copy\nimport sys\n\ndef solve():\n    n = int(input())\n    for reg in range(n):\n        temp = help()\n        print(-1 if temp == 1000 else temp)\n\ndef help():\n    res = 1000\n    read = [list(map(int, input().split())) for _ in range(4)]\n    for _1 in range(4):\n        for _2 in range(4):\n            for _3 in range(4):\n                for _4 in range(4):\n                    l = copy.deepcopy(read)\n                    for i in range(_1): rot(l[0])\n                    for i in range(_2): rot(l[1])\n                    for i in range(_3): rot(l[2])\n                    for i in range(_4): rot(l[3])\n                    if square(l):\n                        res = min(res, _1 + _2 + _3 + _4)\n    return res\n\ndef rot(l):\n    x = l[0]\n    y = l[1]\n    homex = l[2]\n    homey = l[3]\n    yabove = y - homey\n    xright = x - homex\n    newx = homex - yabove\n    newy = homey + xright\n    l[0] = newx\n    l[1] = newy\n    return l\n\ndef square(l):\n    distances = list()\n    for i in range(4):\n        for j in range(i + 1, 4):\n            distances.append(dist(l[i], l[j]))\n    distances.sort()\n    if distances[0] < 0.000001: return False #same point\n    different = 0\n    for i in range(len(distances) - 1):\n        if abs(distances[i] - distances[i+1]) > 0.000001:\n            different += 1\n    return different == 1\n\ndef dist(a, b):\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\n# print(rot(rot(rot(rot([-11, -22, 2, 3])))))\nsolve()", "import copy\nimport sys\n\ndef solve():\n    n = int(input())\n    for reg in range(n):\n        temp = help()\n        print(-1 if temp == 1000 else temp)\n\ndef help():\n    res = 1000\n    l = [list(map(int, input().split())) for _ in range(4)]\n    for _1 in range(4):\n        for _2 in range(4):\n            for _3 in range(4):\n                for _4 in range(4):\n                    for i in range(_1): rot(l[0])\n                    for i in range(_2): rot(l[1])\n                    for i in range(_3): rot(l[2])\n                    for i in range(_4): rot(l[3])\n                    if square(l):\n                        res = min(res, _1 + _2 + _3 + _4)\n                    for i in range(4-_1): rot(l[0])\n                    for i in range(4-_2): rot(l[1])\n                    for i in range(4-_3): rot(l[2])\n                    for i in range(4-_4): rot(l[3])\n    return res\n\ndef rot(l):\n    x = l[0]\n    y = l[1]\n    homex = l[2]\n    homey = l[3]\n    yabove = y - homey\n    xright = x - homex\n    newx = homex - yabove\n    newy = homey + xright\n    l[0] = newx\n    l[1] = newy\n    return l\n\ndef square(l):\n    distances = list()\n    for i in range(4):\n        for j in range(i + 1, 4):\n            distances.append(dist(l[i], l[j]))\n    distances.sort()\n    if distances[0] < 0.000001: return False #same point\n    different = 0\n    for i in range(len(distances) - 1):\n        if abs(distances[i] - distances[i+1]) > 0.000001:\n            different += 1\n    return different == 1\n\ndef dist(a, b):\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\n# print(rot(rot(rot(rot([-11, -22, 2, 3])))))\nsolve()", "import copy\nimport sys\n\ndef solve():\n    n = int(input())\n    for reg in range(n):\n        temp = help()\n        print(-1 if temp == 1000 else temp)\n\ndef help():\n    res = 1000\n    l = [list(map(int, input().split())) for _ in range(4)]\n    for _1 in range(4):\n        for _2 in range(4):\n            for _3 in range(4):\n                for _4 in range(4):\n                    for i in range(_1): rot(l[0])\n                    for i in range(_2): rot(l[1])\n                    for i in range(_3): rot(l[2])\n                    for i in range(_4): rot(l[3])\n                    if square(l):\n                        res = min(res, _1 + _2 + _3 + _4)\n                    for i in range(4-_1): rot(l[0])\n                    for i in range(4-_2): rot(l[1])\n                    for i in range(4-_3): rot(l[2])\n                    for i in range(4-_4): rot(l[3])\n    return res\n\ndef rot(l):\n    x = l[0]\n    y = l[1]\n    homex = l[2]\n    homey = l[3]\n    yabove = y - homey\n    xright = x - homex\n    newx = homex - yabove\n    newy = homey + xright\n    l[0] = newx\n    l[1] = newy\n    return l\n\ndef square(l):\n    distances = list()\n    for i in range(4):\n        for j in range(i + 1, 4):\n            distances.append(dist(l[i], l[j]))\n    distances.sort()\n    if distances[0] < 0.000001: return False #same point\n    different = 0\n    for i in range(len(distances) - 1):\n        if abs(distances[i] - distances[i+1]) > 0.000001:\n            different += 1\n    return different == 1\n\ndef dist(a, b):\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\n# print(rot(rot(rot(rot([-11, -22, 2, 3])))))\nsolve()", "def f(x, y, a, b, n):\n    return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\n\n\ndef check(p):\n    d = {}\n    for i in range(len(p) - 1):\n        for j in range(i + 1, len(p)):\n            dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n            d[dist] = d.get(dist, 0) + 1\n    if len(d) != 2:\n        return 0\n    a, b = sorted(d)\n    return 2 * a == b and d[a] == 4 and d[b] == 2\n\n\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\nfor t in range(int(input())):\n    moles, ans = [list(map(int, input().split())) for x in range(4)], 13\n    for a in variants:\n        if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n            ans = min(ans, sum(a))\n    print(ans if ans != 13 else -1)", "def siblings(initial, root):\n    th = (initial[0] - root[0], initial[1] - root[1])\n    return [(root[0] + th[0], root[1] + th[1]),\n            (root[0] -th[1], root[1] + th[0]),\n            (root[0] - th[0], root[1] - th[1]),\n            (root[0] + th[1], root[1] - th[0])]\ndef dist(x, y):\n    return (x[0]-y[0])**2 + (x[1] - y[1])**2\n\ndef isSquare(p1,p2,p3,p4):\n    d2 = dist(p1, p2)\n    d3 = dist(p1, p3)\n    d4 = dist(p1, p4)\n\n    u = {p1, p2, p3, p4}\n    if (len(u) != 4):\n        return 0\n\n    if (d2==d3 and 2*d2 == d4):\n        d = dist(p2, p4)\n        return (d == dist(p3,p4) and d == d2)\n\n    if (d3==d4 and 2*d3 == d2):\n        d = dist(p2, p3)\n        return (d == dist(p2,p4) and d == d3)\n\n    if (d2==d4 and 2*d2 == d3):\n        d = dist(p2, p3)\n        return (d == dist(p3,p4) and d == d2)\n\n    return False\n\ndef distOri(x, y, root):\n    th1 = (y[0] - root[0], y[1] - root[1])\n    th2 = (x[0] - root[0], x[1] - root[1])\n    if th1[0]==th2[0] and th1[1] == th2[1]:\n        return 0\n    if (th2[0] ==  -th1[1] and th2[1] == th1[0]):\n        return 1\n    if (th2[0] == - th1[0] and th2[1] == -th1[1]):\n        return 2\n    if (th2[0] == th1[1] and th2[1] == -th1[0]):\n        return 3\n    \nn = int(input())\n\nfor i in range(n):\n    initial = []\n    root = []\n\n    _max = 1000\n    for j in range(4):\n        x,y,a,b = [int(k) for k in input().split()]\n        initial.append((x,y))\n        root.append((a,b))\n\n        \n    for x1 in siblings(initial[0], root[0]):\n        for x2 in siblings(initial[1], root[1]):\n            for x3 in siblings(initial[2], root[2]):\n                for x4 in siblings(initial[3], root[3]):\n                    if isSquare(x1, x2, x3, x4):\n                       #print(x1, x2, x3, x4)\n                        _max = min(_max,\n                                    distOri(x1, initial[0], root[0]) + distOri(x2, initial[1], root[1]) + \\\n                                    distOri(x3, initial[2], root[2]) + distOri(x4, initial[3], root[3])) \n    if (_max == 1000):\n        print(-1)\n    else:\n        print(_max)\n                            \n                            \n                        \n            \n", "def siblings(initial, root):\n    th = (initial[0] - root[0], initial[1] - root[1])\n    return [(root[0] + th[0], root[1] + th[1]),\n            (root[0] -th[1], root[1] + th[0]),\n            (root[0] - th[0], root[1] - th[1]),\n            (root[0] + th[1], root[1] - th[0])]\ndef dist(x, y):\n    return (x[0]-y[0])**2 + (x[1] - y[1])**2\n\ndef isSquare(p1,p2,p3,p4):\n    d2 = dist(p1, p2)\n    d3 = dist(p1, p3)\n    d4 = dist(p1, p4)\n\n    u = {p1, p2, p3, p4}\n    if (len(u) != 4):\n        return 0\n\n    if (d2==d3 and 2*d2 == d4):\n        d = dist(p2, p4)\n        return (d == dist(p3,p4) and d == d2)\n\n    if (d3==d4 and 2*d3 == d2):\n        d = dist(p2, p3)\n        return (d == dist(p2,p4) and d == d3)\n\n    if (d2==d4 and 2*d2 == d3):\n        d = dist(p2, p3)\n        return (d == dist(p3,p4) and d == d2)\n\n    return False\n\ndef distOri(x, y, root):\n    th1 = (y[0] - root[0], y[1] - root[1])\n    th2 = (x[0] - root[0], x[1] - root[1])\n    if th1[0]==th2[0] and th1[1] == th2[1]:\n        return 0\n    if (th2[0] ==  -th1[1] and th2[1] == th1[0]):\n        return 1\n    if (th2[0] == - th1[0] and th2[1] == -th1[1]):\n        return 2\n    if (th2[0] == th1[1] and th2[1] == -th1[0]):\n        return 3\n    \nn = int(input())\n\nfor i in range(n):\n    initial = []\n    root = []\n\n    _min = 1000\n    for j in range(4):\n        x,y,a,b = [int(k) for k in input().split()]\n        initial.append((x,y))\n        root.append((a,b))\n\n        \n    for x1 in siblings(initial[0], root[0]):\n        for x2 in siblings(initial[1], root[1]):\n            for x3 in siblings(initial[2], root[2]):\n                for x4 in siblings(initial[3], root[3]):\n                    if isSquare(x1, x2, x3, x4):\n                       #print(x1, x2, x3, x4)\n                        _min = min(_min,\n                                    distOri(x1, initial[0], root[0]) + distOri(x2, initial[1], root[1]) + \\\n                                    distOri(x3, initial[2], root[2]) + distOri(x4, initial[3], root[3])) \n    if (_min == 1000):\n        print(-1)\n    else:\n        print(_min)\n                            \n                            \n                        \n            \n\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = range(4)\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nh = [(i, j) for i in f for j in f if i < j]\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in f]\n    s = 13\n    for a in f:\n        for b in f:\n            for c in f:\n                for d in f:\n                    t = sorted(g(p[u], p[v]) for u, v in h)\n                    if 0 != t[4] == t[5] == 2 * t[0] == 2 * t[3]: s = min(s, a + b + c + d)\n                    r(p[3])\n                r(p[2])\n            r(p[1])\n        r(p[0])\n    print(s if s < 13 else -1)", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def r(t): t[0], t[1] = t[2] + t[3] - t[1], t[3] + t[0] - t[2]\nf = [(0, 0), (1, 3), (2, 15), (3, 63)]\nh = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\ng = lambda u, v: (u[0] - v[0]) ** 2 + (u[1] - v[1]) ** 2\nfor i in range(int(input())):\n    p = [list(map(int, input().split())) for j in range(4)]\n    s = 13\n    for q in range(256):\n        t = sum((q >> k) & 3 for k in (0, 2, 4, 6))\n        d = sorted(g(p[u], p[v]) for u, v in h)\n        if 0 != d[4] == d[5] == 2 * d[0] == 2 * d[3]: s = min(s, t)\n        for i, k in f:\n            if q & k == k: r(p[i])\n    print(s if s < 13 else -1)\n", "def f(x, y, a, b, n):\n    return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\n\n\ndef check(p):\n    d = {}\n    for i in range(len(p) - 1):\n        for j in range(i + 1, len(p)):\n            dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n            d[dist] = d.get(dist, 0) + 1\n    if len(d) != 2:\n        return 0\n    a, b = sorted(d)\n    return 2 * a == b and d[a] == 4 and d[b] == 2\n\n\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\nfor t in range(int(input())):\n    moles, ans = [list(map(int, input().split())) for x in range(4)], 13\n    for a in variants:\n        if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n            ans = min(ans, sum(a))\n    print(ans if ans != 13 else -1)", "def f(x, y, a, b, n):\n\n    return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\n\n\n\n\n\ndef check(p):\n\n    d = {}\n\n    for i in range(len(p) - 1):\n\n        for j in range(i + 1, len(p)):\n\n            dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n\n            d[dist] = d.get(dist, 0) + 1\n\n    if len(d) != 2:\n\n        return 0\n\n    a, b = sorted(d)\n\n    return 2 * a == b and d[a] == 4 and d[b] == 2\n\n\n\n\n\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\n\nfor t in range(int(input())):\n\n    moles, ans = [list(map(int, input().split())) for x in range(4)], 13\n\n    for a in variants:\n\n        if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n\n            ans = min(ans, sum(a))\n\n    print(ans if ans != 13 else -1)\n\n\n\n# Made By Mostafa_Khaled\n"]
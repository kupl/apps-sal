["N=int(input())\nP=[-1]+[int(i)-1 for i in input().split()]\nX=[int(i) for i in input().split()]\nQ=[[] for i in range(N)]\nfor i in range(1,N):\n    Q[P[i]].append(i)\ndp=[0 for i in range(N)]\nINF=10**9+7\ndef solve(i):\n    cur=[INF for j in range(X[i]+1)]\n    cur[0]=0\n    for j in Q[i]:\n        solve(j)\n        prv=[k for k in cur]\n        cur=[INF for k in range(X[i]+1)]\n        for acc in range(len(prv)):\n            if prv[acc]<INF:\n                if acc+X[j]<=X[i]:\n                    cur[acc+X[j]]=min(cur[acc+X[j]],prv[acc]+dp[j])\n                if acc+dp[j]<=X[i]:\n                    cur[acc+dp[j]]=min(cur[acc+dp[j]],prv[acc]+X[j])\n    dp[i]=min(cur)\nsolve(0)\nif dp[0]<INF:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n", "n = int(input())\nP = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ndp = [0]*n\nchild = [[] for i in range(n)]\nfor i in range(n-1):\n    child[P[i]-1].append(i+1)\n\nfor i in range(n-1, -1, -1):\n    if not child[i]:\n        dp[i] = 0\n    else:\n        su = 0\n        re = 0\n        for c in child[i]:\n            z = min(X[c], dp[c])\n            su += z\n        if su > X[i]:\n            print(\"IMPOSSIBLE\")\n            return\n        can = X[i] - su\n        ss = set([0])\n        for c in child[i]:\n            z = min(X[c], dp[c])\n            rest = max(X[c], dp[c]) - z\n            re += rest\n            pp = set(ss)\n            for s in ss:\n                if s + rest <= can:\n                    pp.add(s + rest)\n            ss = pp\n        dp[i] = su + re - max(ss)\nprint(\"POSSIBLE\")\n", "# E\nN = int(input())\nP_list = list(map(int, input().split()))\nX_list = list(map(int, input().split()))\n\n# graph\nchild_list = [[] for _ in range(N+1)]\nfor i in range(2, N+1):\n    child_list[P_list[i-2]].append(i)\n\n# from root\n# minimize local total weight\n\ncolor1 = [0]+X_list\ncolor2 = [0]*(N+1)\n\n# solve knapsack\ndef solve_knapsack(L, M):\n    min_acc = sum([min(color1[j], color2[j]) for j in L])\n    if min_acc > M:\n        return -1\n    else:\n        add_can = M - min_acc\n        add_set = set([0])\n        for j in L:\n            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])\n            add_set_ = set(add_set)\n            for s in add_set:\n                if s + add_j <= add_can:\n                    add_set_.add(s + add_j)\n            add_set = add_set_\n        \n        total = sum([color1[j]+color2[j] for j in L])\n        return total - max(add_set) - min_acc\n\nres = \"POSSIBLE\"\n\nfor i in range(N, 0, -1):\n    if len(child_list[i]) == 0:\n        pass\n    elif len(child_list[i]) == 1:\n        j = child_list[i][0]\n        if min(color1[j], color2[j]) > X_list[i-1]:\n            res = \"IMPOSSIBLE\"\n            break\n        elif max(color1[j], color2[j]) > X_list[i-1]:\n            color2[i] = max(color1[j], color2[j])\n        else:\n            color2[i] = min(color1[j], color2[j])\n    else:\n        c2 = solve_knapsack(child_list[i], X_list[i-1])\n        if c2 < 0:\n            res = \"IMPOSSIBLE\"\n            break\n        else:\n            color2[i] = c2\n    \nprint(res)", "\nfrom itertools import chain,product\n\nN = int(input())\n\nP = list(chain((0,), [int(x)-1 for x in input().split()]))\nX = list(map(int,input().split()))\n\nL = [list() for _ in range(N)]\n\ndebug = [None]*N\n\nfor i in reversed(list(range(N))):\n  p = P[i]\n  l = L[i]\n\n  x = X[i]\n\n  # len(l) < 10\u306e\u3068\u304d\u5168\u63a2\u7d22\u3001\u305d\u308c\u4ee5\u4e0a\u306fDP\n  if len(l) < 10:\n    m = -1\n    for s in product(*l):\n      n = sum(s)\n      if n <= x:\n        m = max(n,m)\n    if m == -1:\n      print('IMPOSSIBLE')\n      return\n    m = sum(chain.from_iterable(l)) - m\n  else:\n    offset = sum(min(t) for t in l)\n    x -= offset\n    if x < 0:\n      print('IMPOSSIBLE')\n      return\n    dp = [False]*(x+1)\n    dp[0] = True\n    s = 0\n    for a,b in l:\n      d = abs(a-b)\n      s += d\n      for j in reversed(list(range(x-d+1))):\n        dp[j+d] = dp[j+d] or dp[j]\n    m = x\n    while not dp[m]:\n      m -= 1\n    m = s-m\n    m += offset\n    x += offset\n\n  debug[i] = (x,m)\n  L[p].append((x,m))\n  L[i] = None\n\nprint('POSSIBLE')\n\n", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn, = list(map(int, readline().split()))\n*p, = list(map(int, readline().split()))\n*x, = list(map(int, readline().split()))\n\ndp = [1]*n\nz = [0]*n\n\nfor i in range(n-1,-1,-1):\n    #print(i,x[i],(z[i],(dp[i].bit_length()-1)),bin(dp[i])[2::][::-1])\n    if dp[i]==0:\n        #print(i)\n        #print(dp)\n        #print(z)\n        print(\"IMPOSSIBLE\")\n        return\n\n    y = dp[i].bit_length()-1\n    # (z[i]-y,y) \u3092 (z[i]-y,x)\u306b\u3059\u308b\u306e\u304c\u6700\u5584\n\n    if i == 0:\n        #print(dp)\n        #print(z)\n        print(\"POSSIBLE\")\n        return\n    else:\n        pi = p[i-1]-1\n        v = dp[pi]\n        dp[pi] = ((v<<x[i]) | (v<<(z[i]-y))) & ((1<<(x[pi]+1))-1)\n        z[pi] += x[i]+z[i]-y\n\n\n\n\n\n\n\n\n\n\n", "def main():\n    n=int(input())\n    p=list(map(int,input().split()))\n    x=list(map(int,input().split()))\n    g=[[] for _ in [0]*n]\n    [g[j-1].append(i+1) for i,j in enumerate(p)]\n    dist=[0]*n\n    q=[0]\n    while q:\n        qq=q.pop()\n        for i in g[qq]:\n            if i!=0:\n                dist[i]=dist[p[i-1]-1]+1\n                q.append(i)\n    dist=sorted([[-j,i] for i,j in enumerate(dist)])\n    dist=[j for i,j in dist]\n    memo=[[i,0] for i in x]\n    for i in dist:\n        if len(g[i])==0:\n            continue\n        dp=[10003]*(x[i]+1)\n        dp[0]=0\n        for j in g[i]:\n            dp2=[10003]*(x[i]+1)\n            for k in range(x[i]-memo[j][0],-1,-1):\n                if dp[k]!=10003:\n                    dp2[k+memo[j][0]]=min(dp2[k+memo[j][0]],dp[k]+memo[j][1],5001)\n            for k in range(x[i]-memo[j][1],-1,-1):\n                if dp[k]!=10003:\n                    dp2[k+memo[j][1]]=min(dp2[k+memo[j][1]],dp[k]+memo[j][0],5001)\n            dp=dp2\n        memo[i][1]=min(dp)\n        if memo[i][1]==10003:\n            print(\"IMPOSSIBLE\")\n            break\n        #print(dp)\n    else:\n        print(\"POSSIBLE\")\n    #print(memo)\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\np = list(map(int,input().split()))\nx = list(map(int,input().split()))\ng = [[] for i in range(n)]\nfor i in range(n-1):\n  g[p[i]-1].append(i+1)\nkyo = [float(\"inf\")] * n\ndef dfs(x,y):\n  kyo[x] = y\n  for i in g[x]:\n    dfs(i,y+1)\ndfs(0,0)\nhukai = []\nfor i in range(n):\n  hukai.append([kyo[i],i])\nhukai.sort(key = lambda x:-x[0])\nINF = float(\"inf\")\ndp = [0]*n\nfor j,i in hukai:\n  if len(g[i]) == 0:\n    continue\n  tmp = []\n  MIN = 0\n  MAX= 0\n  for k in g[i]:\n    tmp.append([dp[k],x[k]])\n    MIN += min(dp[k],x[k])\n    MAX += max(dp[k],x[k])\n  d = {}\n  d[MAX] = MIN\n  for k in tmp:\n    MIN = min(k)\n    MAX = max(k)\n    co = list(d.keys())\n    co.sort(key = lambda x:-x)\n    for l in co:\n      d[l-MAX+MIN] = min(d.get(l-MAX+MIN, INF),d[l]-MIN+MAX)\n  co = list(d.keys())\n  co.sort()\n  for l in co:\n    if d[l] <= x[i]:\n      dp[i] = l\n      break\n  else:\n    print(\"IMPOSSIBLE\")\n    return\nprint(\"POSSIBLE\")\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nINF = 2**30\nn = int(input())\nP = list(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor i, p in enumerate(P, 1):\n  T[p-1].append(i)\nX = tuple(map(int, input().split()))\nD = [-1]*n\ndef dfs(v):\n  if D[v] != -1:\n    return D[v]\n  l = len(T[v])\n  x = X[v]\n  dp = [INF]*(x+1)\n  dp[0] = 0\n  for nv in T[v]:\n    k = [INF]*(x+1)\n    d = dfs(nv)\n    for j in range(x+1):\n      if j >= X[nv]:\n        k[j] = min(k[j], dp[j-X[nv]]+d)\n      if j >= d:\n        k[j] = min(k[j], dp[j-d]+X[nv])\n    dp = tuple(k)\n  res = min(dp)\n  D[v] = res\n  return res\nans = dfs(0)\nif ans == INF:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "def solve():\n    from sys import stdin\n    f_i = stdin\n    \n    inf = 5000001\n    \n    N = int(f_i.readline())\n    P = map(int, f_i.readline().split())\n    X = tuple(map(int, f_i.readline().split()))\n    \n    # Create lists of children\n    C = [[] for i in range(N)]\n    for c, p in enumerate(P, start=1):\n        C[p-1].append(c) # Set vertex numbers to 0-based\n    \n    Y = [inf] * N\n    \n    # Perform a depth-first search in postorder\n    # Execute dp in each sub-tree\n    def dfs(v):\n        for c in C[v]:\n            dfs(c)\n        \n        X_v = X[v]\n        dp1 = [0] * (X_v + 1)\n        dp2 = [inf] * (X_v + 1)\n        for c in C[v]:\n            X_c = X[c]\n            Y_c = Y[c]\n            for i, b in zip(range(X_c, X_v + 1), dp1):\n                if b != inf:\n                    dp2[i] = b + Y_c\n            for i, w, dp2_i in zip(range(Y_c, X_v + 1), dp1, dp2[Y_c:]):\n                tmp = w + X_c\n                if tmp < dp2_i:\n                    dp2[i] = tmp\n            \n            dp1 = dp2\n            dp2 = [inf] * (X_v + 1)\n        \n        Y_v = min(dp1)\n        Y[v] = Y_v\n        return Y_v\n    \n    ans = dfs(0)\n    if ans == inf:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(\"POSSIBLE\")\n    \nsolve()", "# coding: utf-8\nimport numpy as np\n\n\ndef solve(*args: str) -> str:\n    n = int(args[0])\n    P = list(map(int, args[1].split()))\n    X = list(map(int, args[2].split()))\n    T = [[] for _ in range(n)]\n    for i, p in enumerate(P):\n        T[p-1].append(i+1)\n\n    seq = []\n    stack = [0]\n    while stack:\n        i = stack.pop()\n        seq.append(i)\n        for c in T[i]:\n            stack.append(c)\n\n    ret = 'POSSIBLE'\n    inf = 2**32-1\n    Y = [0]*n\n    for i in seq[::-1]:\n        prev = np.full(X[i]+1, inf, np.int64)\n        prev[0] = 0\n        for c in T[i]:\n            cur = np.full(X[i]+1, inf, np.int64)\n            x, y = X[c], Y[c]\n            cur = np.minimum(\n                np.concatenate((cur[:x], y+prev[:-x if 0 < x else len(prev)])),\n                np.concatenate((cur[:y], x+prev[:-y if 0 < y else len(prev)]))\n            )\n            prev = np.copy(cur)\n\n        y = np.min(prev)\n        if y < inf:\n            Y[i] = y\n        else:\n            ret = 'IMPOSSIBLE'\n            break\n\n    return ret\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport numpy as np\n\nINF = 2**30\nn = int(input())\nP = tuple(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor i, p in enumerate(P, 1):\n  T[p-1].append(i)\nX = tuple(map(int, input().split()))\nD = [-1]*n\ndef dfs(v):\n  if D[v] != -1:\n    return D[v]\n  l = len(T[v])\n  x = X[v]\n  dp = np.full(x+1, INF, dtype=np.int64)\n  dp[0] = 0\n  for i, nv in enumerate(T[v]):\n    k = np.full(x+1, INF, dtype=np.int64)\n    d = dfs(nv)\n    if x+1 >= X[nv]:\n      np.minimum(k[X[nv]:], dp[:x+1-X[nv]]+d, out=k[X[nv]:])\n    if x+1 >= d:\n      np.minimum(k[d:], dp[:x+1-d]+X[nv], out=k[d:])\n    dp = k.copy()\n  res = dp.min()\n  D[v] = res\n  return res\nans = dfs(0)\nif ans == INF:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "import sys\nsys.setrecursionlimit(10**7)\ndef main1(n,p,x):\n  ki=[[] for _ in range(n)]\n  for i,v in enumerate(p):\n    v-=1\n    i+=1\n    ki[i].append(v)\n    ki[v].append(i)\n  def dfs(p,v):\n    ary=[]\n    bs=1\n    sa=0\n    mina=0\n    for nv in ki[v]:\n      if nv!=p:\n        a,b=dfs(v,nv)\n        if a==-1:return -1,-1\n        ary.append([a,b])\n        nbs=0\n        nbs|=bs<<a\n        nbs|=bs<<b\n        mina+=min(a,b)\n        sa+=a+b\n        bs=nbs\n    if mina>x[v]:return -1,-1\n    for j in range(x[v],mina-1,-1):\n      if (bs>>j)&1:return x[v],sa-j\n    return -1,-1\n  a,b=dfs(-1,0)\n  if a!=-1:return True\n  else:return False\n\ndef __starting_point():\n  n=int(input())\n  p=list(map(int,input().split()))\n  x=list(map(int,input().split()))\n  ret1=main1(n,p,x)\n  print(('POSSIBLE' if ret1 else 'IMPOSSIBLE'))\n\n\n__starting_point()", "#copy for experience\n# E\nN = int(input())\nP_list = list(map(int, input().split()))\nX_list = list(map(int, input().split()))\n\n# graph\nchild_list = [[] for _ in range(N+1)]\nfor i in range(2, N+1):\n    child_list[P_list[i-2]].append(i)\n\n# from root\n# minimize local total weight\n\ncolor1 = [0]+X_list\ncolor2 = [0]*(N+1)\n\n# solve knapsack\ndef solve_knapsack(L, M):\n    min_acc = sum([min(color1[j], color2[j]) for j in L])\n    if min_acc > M:\n        return -1\n    else:\n        add_can = M - min_acc\n        add_set = set([0])\n        for j in L:\n            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])\n            add_set_ = set(add_set)\n            for s in add_set:\n                if s + add_j <= add_can:\n                    add_set_.add(s + add_j)\n            add_set = add_set_\n        \n        total = sum([color1[j]+color2[j] for j in L])\n        return total - max(add_set) - min_acc\n\nres = \"POSSIBLE\"\n\nfor i in range(N, 0, -1):\n    if len(child_list[i]) == 0:\n        pass\n    elif len(child_list[i]) == 1:\n        j = child_list[i][0]\n        if min(color1[j], color2[j]) > X_list[i-1]:\n            res = \"IMPOSSIBLE\"\n            break\n        elif max(color1[j], color2[j]) > X_list[i-1]:\n            color2[i] = max(color1[j], color2[j])\n        else:\n            color2[i] = min(color1[j], color2[j])\n    else:\n        c2 = solve_knapsack(child_list[i], X_list[i-1])\n        if c2 < 0:\n            res = \"IMPOSSIBLE\"\n            break\n        else:\n            color2[i] = c2\n    \nprint(res)\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n = I()\n    p = LI_()\n    x = LI()\n    e = collections.defaultdict(list)\n    for i in range(n-1):\n        e[p[i]].append(i+1)\n\n    def f(i):\n        if not e[i]:\n            return [0,x[i]]\n        a = 0\n        xi = x[i]\n        xi1 = xi + 1\n        tx = [0] * xi1\n        tx[0] = 1\n        for c in e[i]:\n            rc = f(c)\n            if not rc:\n                return\n            a += sum(rc)\n            tt = [0] * xi1\n            for i in range(xi1):\n                if tx[i] == 0:\n                    continue\n                for c in rc:\n                    if i+c < xi1:\n                        tt[i+c] = 1\n            tx = tt\n        for i in range(xi,-1,-1):\n            if tx[i] == 1:\n                return [xi, a-i]\n        return\n\n    if f(0):\n        return 'POSSIBLE'\n\n    return 'IMPOSSIBLE'\n\n\nprint((main()))\n\n\n\n\n", "#!/usr/bin/env python3\n\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    P = [0] + P\n    X = list(map(int, input().split()))\n\n    Y = [0] * N\n    children = [None] * N\n\n    for i in range(N - 1, 0, -1):\n        parent = P[i] - 1\n        if children[parent] is None:\n            children[parent] = []\n        children[parent].append(i)\n\n\n    for i in range(N - 1, -1, -1):\n        if not children[i] is None:\n            dp = []\n            j_max = len(children[i])\n            for j in range(j_max + 1):\n                dp.append([0] * 5050)\n            dp[0][0] = 1\n            x_sum, y_sum = 0, 0\n            for j in range(j_max):\n                c = children[i][j]\n                xc, yc = X[c], Y[c]\n                x_sum += xc\n                y_sum += yc\n                for k in range(X[i] + 1):\n                    if xc <= k and dp[j][k - xc] == 1:\n                        dp[j + 1][k] = 1\n                    if yc <= k and dp[j][k - yc] == 1:\n                        dp[j + 1][k] = 1\n            f = False\n            for k in range(X[i], -1, -1):\n                if dp[j_max][k] == 1:\n                    Y[i] = x_sum + y_sum - k\n                    f = True\n                    break\n            if not f:\n                print('IMPOSSIBLE')\n                return\n\n    print('POSSIBLE')\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "def inpl(): return [int(i) for i in input().split()]\nfrom collections import defaultdict\nimport sys\nChi = defaultdict(lambda: [])\nF = defaultdict(lambda: [])\nN = int(input())\nPar = [0] + [int(i)-1 for i in input().split()]\nDis = [-1]*N\nX = inpl()\nCol = [()]*N\nfor i in range(N):\n    Chi[Par[i]].append(i)\nQ = [0]\nctr = 0\nwhile ctr < N:\n    st = Q.pop()\n    if not Chi[st]:\n        continue\n    for j in Chi[st]:\n        Dis[j] = Dis[st] + 1\n        ctr += 1\n        Q.append(j)\nChi[0].remove(0)\nmD = max(Dis)\nfor i in range(N):\n    F[Dis[i]].append(i)\nfor d in range(mD, -1, -1):\n    for i in F[d]:\n        if not Chi[i]:\n            Col[i] = (0,X[i])\n            continue\n        Su = 0\n        H = defaultdict(lambda: 0)\n        H[0] = 0\n        for j in Chi[i]:\n            a, b = Col[j]\n            Su += a+b\n            G = defaultdict(lambda: 0)\n            for k in H.keys():\n                if a + k <= X[i]:\n                    G[a+k] = 1\n                if b + k <= X[i]:\n                    G[b+k] = 1\n            H = G.copy()\n            if not H:\n                break\n        else:\n            Col[i] = (Su-max(H), X[i])\n            continue\n        break\n    else:\n        continue\n    break\nelse:\n    print('POSSIBLE')\n    return\nprint('IMPOSSIBLE')", "def main():\n    n=int(input())\n    p=list(map(int,input().split()))\n    x=list(map(int,input().split()))\n    \n    child=[[] for _ in [0]*n]\n    for i,j in enumerate(p):\n        child[j-1].append(i+1)\n    \n    other=[0]*n\n    \n    for i in range(n-1,-1,-1):\n        if child[i]==[]:\n            continue\n        dp=[-1]*(x[i]+1)\n        dp[0]=0\n        xx=x[i]\n        for j in child[i]:\n            dp2=[-1]*(xx+1)\n            m=x[j]\n            o=other[j]\n            for k,l in enumerate(dp):\n                if l==-1:\n                    continue\n                if k+m<=xx:\n                    if dp2[k+m]!=-1:\n                        dp2[k+m]=min(dp2[k+m],l+o)\n                    else:\n                        dp2[k+m]=l+o\n                if k+o<=xx:\n                    if dp2[k+o]!=-1:\n                        dp2[k+o]=min(dp2[k+o],l+m)\n                    else:\n                        dp2[k+o]=l+m\n            dp=dp2\n        k=[j for j in dp if j!=-1]\n        if k!=[]:\n            other[i]=min(k)\n        else:\n            print(\"IMPOSSIBLE\")\n            break\n    else:\n        print(\"POSSIBLE\")\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nP = list(map(int, input().split()))\nXs = list(map(int, input().split()))\n\nfor i, p in enumerate(P):\n    graph[p-1].append(i+1)\n\nstack = [0]\nScores = [[0, 0] for _ in range(N)]\nInd = [0]*N\nok = True\nwhile stack and ok:\n    p = stack[-1]\n    if Ind[p] == len(graph[p]):\n        stack.pop()\n        Max = Xs[p]\n        dp = [False]*(Max+1)\n        dp[0] = True\n        S = 0\n        for ch in graph[p]:\n            a, b = Scores[ch]\n            S += a+b\n            for x in reversed(range(Max+1)):\n                dp[x] = (x >= a and dp[x-a]) or (x >= b and dp[x-b])\n        to_ret = -1\n        for x in reversed(range(Max+1)):\n            if dp[x]:\n                to_ret = S - x\n                break\n        if to_ret == -1:\n            ok = False\n        else:\n            Scores[p] = [Max, to_ret]\n    else:\n        stack.append(graph[p][Ind[p]])\n        Ind[p] += 1\n\nprint(\"POSSIBLE\" if ok else \"IMPOSSIBLE\")", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    P = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n\n    child = [[] for _ in range(N+1)]\n    par = [-1] * (N+1)\n    for i, p in enumerate(P):\n        child[p].append(i+2)\n        par[i+2] = p\n    child_num = [len(child[i]) for i in range(N+1)]\n    st = []\n    for i in range(1, N+1):\n        if child_num[i] == 0:\n            st.append(i)\n    dp = [None] * (N+1)\n    ok = 1\n    while st:\n        v = st.pop()\n        x = X[v-1]\n        if v != 1:\n            p = par[v]\n            child_num[p] -= 1\n            if child_num[p] == 0:\n                st.append(p)\n        if not child[v]:\n            dp[v] = (x, 0)\n            continue\n        dp2 = [[False] * (x+1) for _ in range(len(child[v])+1)]\n        dp2[0][0] = True\n        S = 0\n        for i, u in enumerate(child[v]):\n            a, b = dp[u]\n            S += a+b\n            for j in range(x+1):\n                if dp2[i][j]:\n                    if j + a <= x:\n                        dp2[i+1][j+a] = True\n                    if j+b <= x:\n                        dp2[i+1][j+b] = True\n        finish = 1\n        for j in range(x, -1, -1):\n            if dp2[-1][j]:\n                dp[v] = (x, S-j)\n                finish = 0\n                break\n        if finish:\n            ok = 0\n            break\n\n    if ok:\n        print('POSSIBLE')\n    else:\n        print('IMPOSSIBLE')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\np=list(map(int,input().split()))\nx=list(map(int,input().split()))\ny=[0]*n\nc=[[]for _ in[0]*n]\nfor i in range(n-1):c[p[i]-1]+=[i+1]\nI=float('inf')\nfor i in range(n-1,-1,-1):\n a=x[i];d=[0]*-~a\n for j in c[i]:\n  for k in range(a,-1,-1):b=x[j];e=y[j];f=I if k-b<0else d[k-b]+e;g=I if k-e<0else d[k-e]+b;d[k]=min(f,g,I)\n y[i]=d[a]\nprint('POSSIBLE'if I>y[0]else'IMPOSSIBLE')", "import sys\ninput = sys.stdin.readline\n\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nP = list(map(int, input().split()))\nXs = list(map(int, input().split()))\n\nfor i, p in enumerate(P):\n    graph[p-1].append(i+1)\n\nstack = [0]\nScores = [[0, 0] for _ in range(N)]\nInd = [0]*N\nok = True\nwhile stack and ok:\n    p = stack[-1]\n    if Ind[p] == len(graph[p]):\n        stack.pop()\n        Max = Xs[p]\n        dp = [False]*(Max+1)\n        dp[0] = True\n        S = 0\n        for ch in graph[p]:\n            a, b = Scores[ch]\n            S += a+b\n            for x in reversed(range(Max+1)):\n                dp[x] = (x >= a and dp[x-a]) or (x >= b and dp[x-b])\n        to_ret = -1\n        for x in reversed(range(Max+1)):\n            if dp[x]:\n                to_ret = S - x\n                break\n        if to_ret == -1:\n            ok = False\n        else:\n            Scores[p] = [Max, to_ret]\n    else:\n        stack.append(graph[p][Ind[p]])\n        Ind[p] += 1\n\nprint(\"POSSIBLE\" if ok else \"IMPOSSIBLE\")", "from collections import Counter\nn = int(input())\np = [0,0]+list(map(int,input().split()))\nxls = [0]+list(map(int,input().split()))\ndp = [[] for i in range(n+1)]\nstack = []\ncp = Counter(p)\ndeg = [cp[i] for i in range(n+1)]\ndef dp_sol(ls,s):\n  l = len(ls)\n  mnsm = sum(list(zip(*ls))[0])\n  totsm = sum([sum(i) for i in ls])\n  if mnsm > s:\n    return 10**18\n  dp = [[0 for i in range(s+1)] for j in range(l+1)]\n  dp[0][0] = 1\n  for i in range(1,l+1):\n    mn,mx = ls[i-1]\n    for j in range(mn,s+1):\n      dp[i][j] |= dp[i-1][j-mn]\n    for j in range(mx,s+1):\n      dp[i][j] |= dp[i-1][j-mx]\n  for i in range(s,-1,-1):\n    if dp[l][i]:\n      return totsm-i\nfor i in range(1,n+1):\n  if cp[i] == 0:\n    stack.append(i)\nwhile stack:\n  x = stack.pop()\n  a = 0\n  px = p[x]\n  if dp[x]:\n    a = dp_sol(dp[x],xls[x])\n    if a == 10**18:\n      print(\"IMPOSSIBLE\")\n      return\n  if a < xls[x]:\n    dp[px].append((a,xls[x]))\n  else:\n    dp[px].append((xls[x],a))\n  deg[px] -= 1\n  if deg[px] == 0:\n    stack.append(px)\nprint(\"POSSIBLE\")", "n=int(input())\np,x=[list(map(int,input().split())) for _ in [0]*2]\ng=[[] for _ in [0]*n]\n[g[j-1].append(i+1) for i,j in enumerate(p)]\nd=[0]*n\nq=[0]\nwhile q:\n r=q.pop()\n for i in g[r]:\n  if i!=0:\n   d[i]=d[p[i-1]-1]+1\n   q.append(i)\nd=sorted([[-j,i] for i,j in enumerate(d)])\nm=[[i,0] for i in x]\na,b=10003,5001\nfor _,i in d:\n y=x[i]+1\n e=[a]*y\n e[0]=0\n for j in g[i]:\n  f=[a]*y\n  p,q=m[j]\n  for k in range(y-p):\n   if e[k]!=a:f[k+p]=min(f[k+p],e[k]+q,b)\n  for k in range(y-q):\n   if e[k]!=a:f[k+q]=min(f[k+q],e[k]+p,b)\n  e=f\n m[i][1]=min(e)\n if min(e)==a:\n  print(\"IMPOSSIBLE\")\n  break\nelse:print(\"POSSIBLE\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport numpy as np\n\nINF = 2**30\nn = int(input())\nP = list(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor i, p in enumerate(P, 1):\n  T[p-1].append(i)\nX = list(map(int, input().split()))\nD = [-1]*n\ndef dfs(v):\n  if D[v] != -1:\n    return D[v]\n  l = len(T[v])\n  x = X[v]\n  dp = np.full(x+1, INF, dtype=np.int64)\n  dp[0] = 0\n  for i, nv in enumerate(T[v]):\n    k = np.full(x+1, INF, dtype=np.int64)\n    if x+1 >= X[nv]:\n      np.minimum(k[X[nv]:], dp[:x+1-X[nv]]+dfs(nv), out=k[X[nv]:])\n    if x+1 >= dfs(nv):\n      np.minimum(k[dfs(nv):], dp[:x+1-dfs(nv)]+X[nv], out=k[dfs(nv):])\n    dp = k.copy()\n  res = dp.min()\n  D[v] = res\n  return res\nans = dfs(0)\nif ans == INF:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "n = int(input())\np = [0,0] + list(map(int,input().split()))\nx = [0] + list(map(int,input().split()))\n\nchild = [[] for _ in range(n+1)]\nfor i,pi in enumerate(p[2:],2):\n    child[pi].append(i)\n\ntp = []\nstack = [1]\nwhile(stack):\n    i = stack.pop()\n    tp.append(i)\n    for ci in child[i]:\n        stack.append(ci)\n\ntp = tp[::-1]\n\ncost = [[-1,-1] for _ in range(n+1)]\nfor i in tp:\n    tot = 0\n    mins = 0\n    dif = []\n    for ci in child[i]:\n        a,b = cost[ci]\n        if(a > b):\n            a,b = b,a\n        mins += a\n        tot += a+b\n        dif.append(b-a)\n\n    if( mins > x[i]):\n        print('IMPOSSIBLE')\n        return\n\n    dp = 1\n    dp_max = (1<<(x[i] - mins+1)) - 1\n    for di in dif:\n        dp = (dp|(dp<<di))&dp_max\n\n    max_dif = -1\n    while(dp>0):\n        dp//=2\n        max_dif += 1\n\n    a = x[i]\n    b = tot - mins - max_dif\n    cost[i] = [a,b]\n\nprint('POSSIBLE')", "\nfrom collections import deque, defaultdict\nimport copy\nimport bisect\n#sys.setrecursionlimit(10 ** 9)\nimport math\nimport heapq\n\nimport sys\ndef input():\n\treturn sys.stdin.readline().strip()\n\nN = int(input())\nP = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ntree = [[] for i in range(N)]\n\n\nfor i in range(N - 1):\n\ttree[P[i] - 1].append(i + 1)\n\nsum_list = [0]*N\nque = deque([0])\nque2 = deque([0])\nwhile len(que) > 0:\n\tnode = que.popleft()\n\tif len(tree[node]) > 0:\n\t\tfor edge in tree[node]:\n\t\t\tque.append(edge)\n\t\t\tque2.append(edge)\n\nfor i in range(N - 1, -1, -1):\n\tnode = que2[i]\n\tif len(tree[node]) > 0:\n\t\tfor edge in tree[node]:\n\t\t\tsum_list[node] += sum_list[edge]\n\tsum_list[node] += X[node]\n\nscore = [[0,0] for i in range(N)]\nfor i in range(N - 1, -1, -1):\n\tnode = que2[i]\n\tif len(tree[node]) == 0:\n\t\tscore[node] = [X[node], 0]\n\telse:\n\t\trest = X[node]\n\t\tdp = [[0 for i in range(len(tree[node]) + 1)] for j in range(rest + 1)]\n\t\tdp[0][0] = 1\n\t\tfor x in range(rest + 1):\n\t\t\tfor n in range(1, len(tree[node]) + 1):\n\t\t\t\tdp[x][n] = 0\n\t\t\t\tif x - score[tree[node][n-1]][0] >= 0:\n\t\t\t\t\tdp[x][n] = dp[x - score[tree[node][n-1]][0]][n - 1]\n\t\t\t\tif x - score[tree[node][n-1]][1] >= 0:\n\t\t\t\t\tdp[x][n] = dp[x][n] | dp[x - score[tree[node][n-1]][1]][n - 1]\n\t\tjudge = 0\n\t\t#print(dp)\n\t\tfor x in range(rest, -1, -1):\n\t\t\t#print(x, len(tree[node]))\n\t\t\tif dp[x][len(tree[node])] == 1:\n\t\t\t\tjudge = 1\n\t\t\t\tunder_sum = 0\n\t\t\t\tfor n in range(len(tree[node])):\n\t\t\t\t\tunder_sum += sum(score[tree[node][n]])\n\t\t\t\tunder_sum += rest - x\n\t\t\t\tunder_sum -= X[node]\n\t\t\t\tscore[node] = [X[node], under_sum]\n\t\t\t\tbreak\n\t\tif judge == 0:\n\t\t\tprint(\"IMPOSSIBLE\")\n\t\t\treturn\nprint(\"POSSIBLE\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport numpy as np\n\nINF = 2**30\nn = int(input())\nP = list(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor i, p in enumerate(P, 1):\n  T[p-1].append(i)\nX = list(map(int, input().split()))\nD = [[-1]*n for _ in range(2)]\ndef dfs(color, v):\n  if D[color][v] != -1:\n    return D[color][v]\n  l = len(T[v])\n  x = X[v]\n  dp = np.full(x+1, INF, dtype=np.int64)\n  dp[0] = 0\n  for i, nv in enumerate(T[v]):\n    k = np.full(x+1, INF, dtype=np.int64)\n    if x+1 >= X[nv]:\n      np.minimum(k[X[nv]:], dp[:x+1-X[nv]]+dfs(color, nv), out=k[X[nv]:])\n    if x+1 >= dfs(color^1, nv):\n      np.minimum(k[dfs(color^1, nv):], dp[:x+1-dfs(color^1, nv)]+X[nv], out=k[dfs(color^1, nv):])\n    dp = k.copy()\n  res = dp.min()\n  D[color][v] = res\n  return res\nans = dfs(0, 0)\nif ans == INF:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "import sys\nfrom collections import *\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\nn = int(input())\npp = LI()\nxx = LI()\nto = defaultdict(list)\nww = [[-1, -1] for _ in range(n)]\n\ndef dfs(u=0):\n    if not len(to[u]):\n        ww[u] = [xx[u], 0]\n        return True\n    ret_ww = set([0])\n    uw = xx[u]\n    sum_ret_w = 0\n    for cu in to[u]:\n        if not dfs(cu): return False\n        new_ret_ww = set()\n        for cuw in ww[cu]:\n            sum_ret_w += cuw\n            for ret_w in ret_ww:\n                new_ret_w = ret_w + cuw\n                if new_ret_w <= uw: new_ret_ww.add(new_ret_w)\n        ret_ww = new_ret_ww\n    if not ret_ww: return False\n    ww[u] = [uw, sum_ret_w - max(ret_ww)]\n    return True\n\ndef main():\n    for u, p in enumerate(pp, 1):\n        to[p - 1].append(u)\n    # print(to)\n    if dfs():\n        print(\"POSSIBLE\")\n    else:\n        print(\"IMPOSSIBLE\")\n    # print(ww)\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nsys.setrecursionlimit(10**6)\n\nN = int(input())\ngraph = [[] for _ in range(N+1)] # parent to child\nfor i,p in enumerate(input().split(),2):\n    graph[int(p)].append(i)\nX = [None] + [int(x) for x in input().split()]\n\ndef dfs(v):\n    # None \u307e\u305f\u306f \u767d\u3001\u9ed2\u306e2\u3064\u7d44\u3092\u8fd4\u3059\n    child = []\n    for w in graph[v]:\n        c = dfs(w)\n        if c is None:\n            return None\n        child.append(c)\n    S = sum(a+b for a,b in child)\n    x = X[v]\n    dp = np.zeros(x+1, dtype=np.bool) # 2\u629e\u306e\u7e70\u308a\u8fd4\u3057\u3067\u4f5c\u308c\u308b\u548c\n    dp[0] = 1\n    for a,b in child:\n        prev = dp\n        dp = np.zeros_like(prev)\n        if a <= x:\n            dp[a:] = prev[:x+1-a]\n        if b <= x:\n            dp[b:] |= prev[:x+1-b]\n    nz = np.nonzero(dp)[0]\n    if len(nz) == 0:\n        return None\n    return x, S - nz[-1]\n\nanswer = 'POSSIBLE' if dfs(1) is not None else 'IMPOSSIBLE'\nprint(answer)\n\n", "N = int(input())\nP = [0] + list(map(int, input().split()))\nX = list(map(int, input().split()))\n\nV = [[0, {0: True}, 0, 0] for i in range(N)]  # \u5b50\u306e\u6570\uff0c\u53ef\u80fd\u306a\u5b50\u5b6b\u306e\u91cd\u307f\uff0c\u767d\u9ed2\u306e\u7dcf\u548c\uff0c\u88cf\u306e\u5024\nfor i in range(1, N):\n    V[P[i]-1][0] += 1\n\nfrom collections import deque\nOpen = deque()\nfor i, v in enumerate(V):\n    if v[0]==0:\n        Open.append(i)\n#print(Open)\nwhile len(Open)!=0:\n    iv = Open.popleft()\n    v = V[iv]\n    if len(v[1]) == 0:\n        print(\"IMPOSSIBLE\")\n        return\n    v[3] = v[2] - max(v[1].keys())\n\n    u = P[iv]-1\n    if u==-1:\n        print(\"POSSIBLE\")\n        #print(V)\n        return\n    V[u][0] -= 1\n    if V[u][0] == 0:\n        Open.append(u)\n    V[u][2] += X[iv] + v[3]\n    newdic = {}\n    for key, val in list(V[u][1].items()):\n        if key+X[iv] <= X[u]:\n            newdic[key+X[iv]] = True\n        if key+v[3] <= X[u]:\n            newdic[key+v[3]] = True\n    V[u][1] = newdic\n\nraise ValueError\n", "n = int(input())\nP = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ndp = [0] * n\nchild = [[] for i in range(n)]\nfor i in range(n-1):\n    child[P[i] - 1].append(i + 1)\n\nfor i in range(n-1, -1, -1):\n    if not child[i]:\n        dp[i] = 0\n    else:\n        child_sum_min = 0\n        child_sum_rest = 0\n        change_candidate = set([0]) #\u8272\u3092\u5909\u66f4\u3057\u305f\u5834\u5408\u306b\u751f\u3058\u308b\u5dee\u5206\u3092\u7ba1\u7406\u3059\u308b\n        for c in child[i]:\n            z = min(X[c], dp[c])\n            child_sum_min += z\n        if child_sum_min > X[i]:\n            print('IMPOSSIBLE')\n            return\n        change_space = X[i] - child_sum_min\n        for c in child[i]:\n            z = min(X[c], dp[c])\n            rest = max(X[c], dp[c]) - z\n            child_sum_rest += rest\n            tmp = set(change_candidate)\n            for num in change_candidate:\n                if num + rest <= change_space:\n                    tmp.add(num + rest)\n            change_candidate = tmp\n        dp[i] = child_sum_min + child_sum_rest - max(change_candidate)\n\nprint('POSSIBLE')", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nINF = 2**30\nn = int(input())\nP = list(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor i, p in enumerate(P, 1):\n  T[p-1].append(i)\nX = tuple(map(int, input().split()))\nD = [-1]*n\ndef dfs(v):\n  if D[v] != -1:\n    return D[v]\n  l = len(T[v])\n  x = X[v]\n  dp = [INF]*(x+1)\n  dp[0] = 0\n  for nv in T[v]:\n    k = [INF]*(x+1)\n    d = dfs(nv)\n    for j in range(x+1):\n      if j >= X[nv]:\n        k[j] = min(k[j], dp[j-X[nv]]+d)\n      if j >= d:\n        k[j] = min(k[j], dp[j-d]+X[nv])\n    dp = tuple(k)\n  res = min(dp)\n  D[v] = res\n  return res\nans = dfs(0)\nif ans == INF:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "# coding: utf-8\nfrom collections import defaultdict, deque\n\nimport numpy as np\n\n\ndef solve(*args: str) -> str:\n    n = int(args[0])\n    P = list(map(int, args[1].split()))\n    X = list(map(int, args[2].split()))\n\n    T = defaultdict(set)\n    for i, p in enumerate(P):\n        T[p-1].add(i+1)\n\n    stack = []\n    Q = deque()\n    Q.append(0)\n    while Q:\n        i = Q.popleft()\n        stack.append(i)\n        for c in T[i]:\n            Q.append(c)\n\n    ret = 'POSSIBLE'\n    inf = 2**32-1\n    Y = [0]*n\n    for i in stack[::-1]:\n        prev = np.full(X[i]+1, inf, np.int64)\n        prev[0] = 0\n        x_acc, y_acc = 0, 0\n        for c in T[i]:\n            cur = np.full(X[i]+1, inf, np.int64)\n            x, y = X[c], Y[c]\n            x_acc += x\n            y_acc += y\n            cur[x:] = np.minimum(cur[x:], y+prev[:-x if 0 < x else len(prev)])\n            cur[y:] = np.minimum(cur[y:], x+prev[:-y if 0 < y else len(prev)])\n            prev = np.copy(cur)\n\n        y = np.min(prev)\n        if y < inf:\n            Y[i] = y\n        else:\n            ret = 'IMPOSSIBLE'\n            break\n\n    return ret\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()"]
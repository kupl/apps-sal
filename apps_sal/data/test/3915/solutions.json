["def primes2(limit):\n    if limit < 2: return []\n    if limit < 3: return [2]\n    lmtbf = (limit - 3) // 2\n    buf = [True] * (lmtbf + 1)\n    for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n        if buf[i]:\n            p = i + i + 3\n            s = p * (i + 1) + i\n            buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]\n\nps = primes2(12*10**6)\n\ndef rub2(n):\n    lst_odd = []\n    lst_even = []\n    for head in range(1, n):\n        head_str = str(head)\n        tail_str = head_str[::-1]\n        lst_even.append(int(head_str + tail_str))\n        lst_odd.append(int(head_str[:-1] + tail_str))\n    lst = lst_odd + lst_even\n    lst.sort()\n    return lst\n\nrs = rub2(12*10**2)\n\np, q = map(int, input().split())\nidxp = len(ps) - 1\nidxr = len(rs) - 1\npi = ps[idxp]\nri = rs[idxr]\nwhile q * (idxp + 1) > p * (idxr + 1):\n    if pi < ri:\n        idxr -= 1\n    elif pi > ri:\n        idxp -= 1\n    else:\n        idxr -= 1\n        idxp -= 1\n    prev_pi = pi\n    prev_ri = ri\n    pi = ps[idxp]\n    ri = rs[idxr]\nprint(max(prev_pi-1, prev_ri-1))", "'''\nCreated on 19 A\u011fu 2015\n\n@author: enesoncu\n'''\npr = [0]*1300000\ndef prime():\n    pr[1] = 1;\n    for i in range(2,1300000):\n        if pr[i]==1: continue\n        for j in range(2*i,1300000,i):\n            pr[j] = 1\n    \ndef palindrom(s):\n    s = str(s)\n    return  s==s[::-1]\n\n(p,q) = list(map(int,input().split()))\n\nres = \"Palindromic tree is better than splay tree\"\nrub = 0\npi = 0\nprime()\nfor i in range(1,1200000):\n    #print(palindrom(i))\n    if pr[i]==0: pi += 1\n    if palindrom(i): rub += 1\n    #print(i,pi,rub)\n    if pi*q<=rub*p: res = i\nprint( res )\n", "n = 12 * 10 ** 5\np, q = map(int, input().split())\npr = [0] * n\npr[1] = 1\nfor i in range(2, n):\n    if pr[i] == 1: continue\n    for j in range(2 * i, n, i):\n        pr[j] = 1\nres = 'Palindromic tree is better than splay tree'\nrub = pi = 0\nfor i in range(1, n):\n    if pr[i] == 0: pi += 1\n    if str(i) == str(i)[::-1]: rub += 1\n    if pi * q <= rub * p: res = i\nprint(res)", "p, q = (int(x) for x in input().split())\ntop = 1200000\nisPrime = [1] * top\nisPrime[1] = 0\npalindromic = 1\nres = 1\nfor i in range(2, top):\n\tif str(i) == str(i)[::-1]:\n\t\tpalindromic += 1\n\tif isPrime[i]:\n\t\tfor j in range(i * i, top, i):\n\t\t\tisPrime[j] = 0\n\tisPrime[i] += isPrime[i - 1]\n\tif q * isPrime[i] <= p * palindromic:\n\t\tres = i\nprint(res)\n", "def main():\n    p, q = list(map(int, input().split()))\n    lim = 1179860\n    sieve = [0, q] * (lim // 2)\n    for i in range(3, int(lim ** .5) + 1, 2):\n        if sieve[i]:\n            for j in range(i * i, lim, i):\n                sieve[j] = 0\n    sieve[1], sieve[2] = -p, q - p\n    for i in range(3, 10):\n        sieve[i] -= p\n    for s in map(str, (list(range(1, 1000)))):\n        ss = (s, s[::-1])\n        for m in '', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n            i = int(m.join(ss))\n            if i < lim:\n                sieve[i] -= p\n    res = b = 0\n    for i, a in enumerate(sieve):\n        b += a\n        if b <= 0:\n            res = i\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "p, q = map(int, input().split())\nn = 1200000\n\ns = [0] * n\nt = [q] * n\n\nfor i in range(3, int(n ** 0.5) + 1, 2):\n    u, v = i * i, 2 * i\n    if t[i]: t[u::v] = [0] * ((n - u - 1) // v + 1)\nfor i in range(4, n, 2): t[i] = 0\nt[0] = t[1] = 0\n\nfor i in range(1, 10): s[i] = p\nfor i in range(1, 1000):\n    a = str(i)\n    b = a[::-1]\n    for j in '0123456789':\n        c = int(a + j + b)\n        if c < n: s[c] = p\n    s[int(a + b)] = p\n\nfor i in range(n - 1): t[i + 1] += t[i]\nfor i in range(n - 1): s[i + 1] += s[i]\n\nj = 0\nfor i, (u, v) in enumerate(zip(t, s)):\n    if u <= v: j = i\nprint(j)", "p, q = map(int, input().split())\nn = 1200000\nt = [0, q] * 600000\nfor i in range(3, 1096, 2):\n    if t[i]:\n        for j in range(i * i, n, i): t[j] = 0\nt[1], t[2] = -p, q - p\nfor i in range(3, 10): t[i] -= p\nfor i in range(1, 1000):\n    u = str(i)\n    v = u[::-1]\n    for j in '0123456789':\n        k = int(u + j + v)\n        if k < n: t[k] -= p\n    t[int(u + v)] -= p\nj = s = 0\nfor i, q in enumerate(t):\n    s += q\n    if s <= 0: j = i\nprint(j)", "'''\nCreated on 19 A\u0624\u06bau 2015\n\n@author: enesoncu\n'''\npr = [0]*1300000\ndef prime():\n    pr[1] = 1;\n    for i in range(2,1300000):\n        if pr[i]==1: continue\n        for j in range(2*i,1300000,i):\n            pr[j] = 1\n    \ndef palindrom(s):\n    s = str(s)\n    return  s==s[::-1]\n\n(p,q) = list(map(int,input().split()))\n\nres = \"Palindromic tree is better than splay tree\"\nrub = 0\npi = 0\nprime()\nfor i in range(1,1200000):\n    #print(palindrom(i))\n    if pr[i]==0: pi += 1\n    if palindrom(i): rub += 1\n    #print(i,pi,rub)\n    if pi*q<=rub*p: res = i\nprint( res )\n    \n\n\n\n# Made By Mostafa_Khaled\n", "def is_palindrome(num):\n    \n    copia = num\n    if num < 10:\n        return True\n    \n    nums = []\n    while(True):\n        nums.append(copia % 10)\n        copia //= 10\n        \n        if copia == 0:\n            break\n    \n    digitos = len(nums) // 2\n    j = len(nums) - 1\n    for i in range(digitos):\n        if nums[i] != nums[j]:\n            return False\n        j -= 1\n\n    return True\n\nprimes = [True] * 2000000\nprimes[0] = False\nnum = input().split()\nnum = [int(num[0]), int(num[1])]\nresultado = 0\ni = 0\ncountPrimes = 0\ncountPali = 0\n\nwhile(i < 2000000):\n    \n    if primes[i]:\n        countPrimes += 1\n        if i * i < 2000000: \n            for j in range(i, 2000000, i + 1):\n                primes[j] = False\n    \n    if str(int(str(i + 1)[::-1])) == str(i + 1):\n        countPali += 1\n\n    res = (countPali * num[0]) / num[1]\n\n    if res >= countPrimes:\n        resultado = i + 1\n    \n    i += 1\n\nif resultado == 0:\n    print(\"Palindromic tree is better than splay tree\")\n\nelse:\n    print(resultado)\n", "\ncrivo = [True] * 2000001\ncrivo[0] = False\ncrivo[1] = False\nfor i in range(2,2001):\n\tif crivo[i]:\n\t\tfor j in range(i*i,2000001,i):\n\t\t\tcrivo[j] = False\n\na, b = map(float, input().split())\nprime = 0\npalindromo = 0\ncontrol = False\ny = -1\nfor i in range(1,2000000):\n\tif crivo[i]:\n\t\tprime += 1\n\t\n\tif str(int(str(i)[::-1])) == str(i) :\n\t\tpalindromo += 1\n\t\t\t\t\n\tif palindromo * (a / b) >= prime:\n\t\ty = i\t\t\t\nif y >= 0:\n\tprint (y) \nelse: \n\tprint (\"Palindromic tree is better than splay tree\")", "\ncrivo = [True] * 2000001\ncrivo[0] = False\ncrivo[1] = False\nfor i in range(2,2001):\n\tif crivo[i]:\n\t\tfor j in range(i*i,2000001,i):\n\t\t\tcrivo[j] = False\n\na, b = map(float, input().split())\nprime = 0\npalindromo = 0\ncontrol = False\ny = -1\nfor i in range(1,2000000):\n\tif crivo[i]:\n\t\tprime += 1\n\t\n\tif str(int(str(i)[::-1])) == str(i) :\n\t\tpalindromo += 1\n\t\t\t\t\n\tif palindromo * (a / b) >= prime:\n\t\ty = i\t\t\t\nif y >= 0:\n\tprint (y) \nelse: \n\tprint (\"Palindromic tree is better than splay tree\")", "p, q= map(int, input().split())\nL = 2 * 10 ** 6 + 10 ** 5\nP = [0] * L\n\nfor i in range(2, L, 1):\n    if P[i] == 0:\n        for j in range(i*i, L, i):\n            P[j] = 1\nans = -1\nP[1] = 1\ncnta = 0\ncntb = 0\nfor i in range(1, L):\n    if P[i] == 0:\n        cnta += 1\n    j = str(i)\n    if j == j[::-1]:\n        cntb += 1\n    if cnta * q <= p * cntb:\n        ans = i\nprint(ans)", "n=2 * 10 ** 6 + 10 ** 5\np,q=list(map(int,input().split(\" \")))\npi=0\nsi=0\npr=[0]*n\npr[1]=1\nfor i in range(2,n):\n    if pr[i]==0:\n        for j in range(i*i,n,i):\n            pr[j]=1\n\nres='Palindromic tree is better than splay tree'\nfor i in range(1,n):\n    if pr[i]==0:\n        pi+=1\n    j=str(i)\n    if j==j[::-1]:\n        si+=1\n    if q*pi<=si*p:\n        res=i\nprint(res)\n", "import sys\ninput=sys.stdin.readline\n\ndef rr(n): \n    a=set([])\n    # Create a boolean array \"prime[0..n]\" and initialize \n    #  all entries it as true. A value in prime[i] will \n    # finally be false if i is Not a prime, else true. \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n          \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n              \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n      \n    # Print all prime numbers \n    for p in range(2, n+1): \n        if prime[p]: \n            a.add(p)\n    return a\n            \ndef pal(a):\n    if str(a)==str(a)[::-1]:\n        return 1\n    return 0\n\np,q=list(map(int,input().split()))\nn=1500000\na=rr(n)\nb=[]\nc=0\nd=0\nfor i in range(1,n+1):\n    if i in a:\n        c+=1\n    d+=pal(i)\n    b.append([c/d,i])\ne=-1\nfor i in range(len(b)-1,-1,-1):\n    if b[i][0]<=p/q:\n        e=b[i][1]\n        break\nif e==-1:\n    print(\"Palindromic tree is better than splay tree\")\nelse:\n    print(e)"]
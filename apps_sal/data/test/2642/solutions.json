["#\u5199\u7d4c\n#https://atcoder.jp/contests/abc168/submissions/13414936\nfrom math import gcd\nfrom collections import Counter\nmod = 10**9 + 7\nN,*AB = map(int,open(0).read().split())\n\ndef std(a,b):\n    \"\"\"\n    a,b\u3092\u65e2\u7d04\u306b\u3059\u308b\n    \"\"\"\n    if a == 0:\n        return(0,int(b!=0))\n    g = gcd(a,b)\n    a,b = a// g, b//g\n    return(a,b) if a > 0 else (-a,-b)\n\nC = Counter(std(a, b) for a, b in zip(*[iter(AB)] * 2))\ndef resolve():\n    ans = 1\n    cnt = 0\n    for (a,b), v in C.items():\n        if b > 0:\n            if (b,-a) in C:\n                ans *= -1 + pow(2,v,mod) + pow(2,C[(b,-a)], mod) #\u4ef2\u306e\u60aa\u3044\u7d44\u307f\u5408\u308f\u305b\u304c\u4e00\u7dd2\u306b\u5165\u3089\u306a\u3044\u3088\u3046\u306b\uff0c\u5225\u3005\u306b\u5165\u308c\u308b\u304b\u5165\u308c\u306a\u3044\u304b\u3092\u5224\u5b9a \u7a7a\u96c6\u5408\u306f\u5171\u901a\u3057\u3066\u3044\u308b\u306e\u3067\u5f15\u304f\n                ans %= mod\n            else:\n                cnt += v\n        elif (-b,a) not in C:\n            cnt += v\n    ans *= pow(2,cnt,mod)\n    ans += C[(0,0)] - 1\n    print(ans%mod)\nresolve()", "def main():\n    from collections import defaultdict\n    from math import gcd\n    import sys\n    input = sys.stdin.readline\n\n\n    mod = 10 ** 9 + 7\n    n = int(input())\n    fishes = defaultdict(int)\n    zero_zero = 0\n    zero = 0\n    inf = 0\n\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        if a == 0 and b == 0:\n            zero_zero += 1\n\n        elif a == 0:\n            zero += 1\n\n        elif b == 0:\n            inf += 1\n\n        else:\n            div = gcd(a, b)\n            a //= div\n            b //= div\n            if b < 0:\n                a *= -1\n                b *= -1\n            key = (a, b)\n            fishes[key] += 1\n\n\n    def get_bad_pair(fish):\n        a, b = fish\n        if a < 0:\n            a *= -1\n            b *= -1\n        return (-b, a)\n\n\n    ans = 1\n    counted_key = set()\n    for fish_key, count in list(fishes.items()):\n        if fish_key in counted_key:\n            continue\n\n        bad_pair = get_bad_pair(fish_key)\n        if bad_pair in fishes:\n            pair_count = fishes[bad_pair]\n            pattern = pow(2, count, mod) + pow(2, pair_count, mod) - 1\n            counted_key.add(bad_pair)\n\n        else:\n            pattern = pow(2, count, mod)\n\n        ans = ans * pattern % mod\n\n    ans *= pow(2, zero, mod) + pow(2, inf, mod) - 1\n    if zero_zero:\n        ans += zero_zero\n\n    ans -= 1\n    print((ans % mod))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\nMOD = 10**9+7\nN = int(input())\nd = {}\nzero = 0\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    if a == b == 0:\n        zero += 1\n        continue\n    # \u6b63\u898f\u5316\u3059\u308b\n    if b < 0:\n        b = -b\n        a = -a\n    g = gcd(a, b)\n    b //= g\n    a //= g\n    # \u5165\u529b\u306eb\u304c0\u306e\u6642\u306fa\u306e\u5024\u3092\u6b63\u306e1\u306b\u7d71\u4e00\u3059\u308b\n    if b == 0 and a == -1:\n        a = 1\n\n    # \u4ecab\u306f\u5fc5\u305a\u6b63\n    # a\u3082\u6b63\uff0c\u3059\u306a\u308f\u3061\u50be\u304d\u304c\u6b63\u306e\u3068\u304d\n    if a > 0:\n        if (a, b) in d:\n            d[(a, b)][0] += 1\n        else:\n            d[(a, b)] = [1, 0]\n    else:\n        # a\u304c\u8ca0\uff0c\u3059\u306a\u308f\u3061\u50be\u304d\u304c\u8ca0\u306e\u6642\n        if (b, -a) in d:\n            d[(b, -a)][1] += 1\n        else:\n            d[(b, -a)] = [0, 1]\n\nans = 1\nfor (a, b), (k, l) in list(d.items()):\n    ans *= (pow(2, k, MOD)-1 + pow(2, l, MOD)-1 + 1)  # \u6700\u5f8c\u306e+1\u306f\u3069\u3061\u3089\u304b\u3089\u3082\u9078\u3070\u306a\u304b\u3063\u305f\u30d1\u30bf\u30fc\u30f3\n    ans %= MOD\nans -= 1\nans += zero\nans %= MOD\nprint(ans)\n", "N=int(input())\nfrom collections import defaultdict\ndic=defaultdict(int)\ndic[(0,0)]=dic[(0,1)]=0\nimport math\nmod=1000000007\nfor _ in range(N):\n    A,B=list(map(int,input().split()))\n    if A<0:\n        A,B=-A,-B\n    if A==0:\n        if B==0:\n            dic[(0,0)]+=1\n        else:\n            dic[(0,1)]+=1\n    elif B==0:\n        dic[(1,0)]+=1\n    else:\n        gcd=math.gcd(A,B)\n        A,B=A//gcd,B//gcd\n        dic[(A,B)]+=1\n\nans=1\nN-=dic[(0,0)]\nfor k,v in list(dic.items()):\n    if k==(0,0) or k==(0,1):\n        continue\n    if k==(1,0):\n        v_dash=dic[(0,1)]\n        ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n        ans%=mod\n        N-=v+v_dash\n        continue\n    a,b=k\n    if not (b,-a) in dic:\n        continue\n    v_dash=dic[(b,-a)]\n    ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n    ans%=mod\n    N-=v+v_dash\nans*=pow(2,N,mod)\nans+=dic[(0,0)]-1\nans%=mod\nprint(ans)\n", "from math import gcd\nn=int(input())\nmod = 1000000007\nz=0\nd={}\nfor _ in range(n):\n  a,b=list(map(int,input().split()))\n  if not any((a,b)):\n    z+=1\n    continue\n  if a==0:\n    d[(0,1)]=d.get((0,1),0)+1\n    continue\n  if b==0:\n    d[(1,0)]=d.get((1,0),0)+1\n    continue\n  g = gcd(a,b)\n  s = a//abs(a)\n  a,b = (a//g)*s, (b//g)*s\n  d[(a,b)]=d.get((a,b),0)+1\n\ndone = set()\nans = 1\nfor (a,b), v in list(d.items()):\n  if (a,b) in done:continue\n  done.add((a,b))\n  done.add((-b,a))\n  done.add((b,-a))\n  w = d.get((-b,a),0)+d.get((b,-a),0)\n  ans *= (pow(2,v,mod)+pow(2,w,mod)-1)\n  ans %= mod\nans = (ans + z - 1 + mod)%mod\nprint(ans)\n", "# \u307b\u307c\u5199\u7d4c\nfrom math import gcd\nfrom collections import defaultdict\nmod = 10**9+7\nn = int(input())\nmp = defaultdict(lambda: [0, 0])\nzero_zero = 0\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    if a == 0 and b == 0:\n        zero_zero += 1\n        continue\n    g = gcd(a, b)\n    a //= g\n    b //= g\n    rot_cnt = 0\n    while not (a > 0 and b >= 0):\n        a, b = -b, a\n        # \u30d9\u30af\u30c8\u30eb\u306e\u6210\u5206\u304c(\u6b63,\u6b63)\u3068\u306a\u308b\u307e\u306790\u5ea6\u56de\u8ee2\u3001\u5947\u6570\u56de\u306e\u6642\u306f\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3068\u76f4\u884c\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u306e\u3067rot_cnt\u3067\u8a18\u9332\n        # \u4eca\u56de\u306e\u554f\u984c\u306b\u304a\u3044\u3066\u306f\u5185\u7a4d0\u3092\u8a08\u7b97\u3059\u308c\u3070\u3044\u3044\u306e\u3067\u9006\u30d9\u30af\u30c8\u30eb\u306f\u8003\u616e\u3057\u306a\u304f\u3066\u3088\u3044\n        rot_cnt += 1\n    mp[(a, b)][rot_cnt % 2] += 1\nans = 1\nfor s, t in list(mp.values()):\n    now = (pow(2, s, mod) + pow(2, t, mod) - 1) % mod\n    ans = (ans * now) % mod\nans = (ans - 1 + zero_zero) % mod\nprint(ans)\n", "# \u30d9\u30af\u30c8\u30eb\u3092\u65e2\u7d04\u5206\u6570\u306b\u3057\u3066\u306a\u304a\u304b\u3064\u65b9\u5411\u3092\u7b2c\u4e00\u8c61\u9650\u304b\u7b2c\u4e8c\u8c61\u9650\u306b\u96c6\u3081\u308b\n\nfrom collections import defaultdict\nfrom math import gcd\nN = int(input())\nMOD = 10**9 + 7\nd = defaultdict(lambda: [0, 0])\nzeros = 0\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    if x == 0 and y == 0:\n        zeros += 1\n    elif x == 0:\n        d[(0, 0)][0] += 1\n    elif y == 0:\n        d[(0, 0)][1] += 1\n    else:\n        if y < 0:\n            x = -x\n            y = -y\n        g = gcd(abs(x), abs(y))\n        x //= g\n        y //= g\n        if x < 0:\n            d[(y, -x)][0] += 1\n        else:\n            d[(x, y)][1] += 1\nans = 1\nfor k, v in list(d.items()):\n    ans *= pow(2, v[0], MOD)+pow(2, v[1], MOD)-1\n    ans %= MOD\nans = (ans + zeros - 1) % MOD  # \u5404\u30d9\u30af\u30c8\u30eb\u5bfe\u306e\u7d44\u304b\u3089\u4e00\u3064\u3082\u9078\u3070\u306a\u3044\u30d1\u30bf\u30fc\u30f3\u3092\u5f15\u3044\u3066\u308b\nprint(ans)\n", "from math import gcd\n_, *e = [[*list(map(int, t.split()))] for t in open(0)]\nans = 1\nmod = 10 ** 9 + 7\nslope_dict = {}\nzeros = 0\nfor x, y in e:\n    if x == y == 0:\n        zeros += 1\n    else:\n        d = gcd(x, y)\n        x //= d\n        y //= d\n        if x < 0 or x == 0 < y:\n            x, y = -x, -y\n        s = 0\n        if y < 0:\n            x, y, s = -y, x, 1\n        if (x, y) not in slope_dict:\n            slope_dict[(x, y)] = [0, 0]\n        slope_dict[(x, y)][s] += 1\n\nfor k in slope_dict:\n    ans = ans * (pow(2, slope_dict[k][0], mod) +\n                 pow(2, slope_dict[k][1], mod) - 1) % mod\nprint(((ans + zeros - 1) % mod))\n", "from math import gcd\nfrom collections import Counter\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nMOD = 10**9+7\n\ndef main():\n    N,*ab = list(map(int, read().split()))\n\n    ab_zero = 0\n    ratio = []\n    for a, b in zip(*[iter(ab)]*2):\n        if a == 0 and b == 0:\n            ab_zero += 1\n        else:\n            if b < 0:\n                a, b = -a, -b\n            if b == 0:\n                a = 1\n            g = gcd(a, b)\n            a //= g\n            b //= g\n            ratio.append((a, b))\n    \n    s = Counter(ratio)\n\n    bad = 1\n    no_pair = 0\n    for k, v in list(s.items()):\n        a, b = k\n        if a > 0:\n            if (-b, a) in s:\n                bad *= pow(2, v, MOD) + pow(2, s[(-b, a)], MOD) -1\n                bad %= MOD\n            else:\n                no_pair += v\n            \n        elif (b, -a) not in s:\n            no_pair += v\n\n    bad *= pow(2, no_pair, MOD)\n    bad %= MOD\n\n    ans = (bad + ab_zero -1) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\nfrom collections import Counter\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\ndef std(a, b):\n    if a == 0:\n        return (0, int(b != 0))\n\n    g = gcd(a, b)\n    a, b = a // g, b // g\n    return (a, b) if a > 0 else (-a, -b)\n\nC = Counter(std(a, b) for a, b in zip(*[iter(AB)] * 2))\n\nans = 1\ncnt = 0\nfor (a, b), v in C.items():\n    if b > 0:\n        if (b, -a) in C:\n            ans *= -1 + pow(2, v, mod) + pow(2, C[(b, -a)], mod)\n            ans %= mod\n        else:\n            cnt += v\n    elif (-b, a) not in C:\n        cnt += v\n\nans *= pow(2, cnt, mod)\nans += C[(0, 0)] - 1\n\nprint(ans % mod)", "from collections import defaultdict\nimport math\n\ndef main():\n    n = int(input())\n    mod = 1000000007\n    zeroes = 0\n    quadrant1 = defaultdict(int)\n    quadrant2 = defaultdict(int)\n\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a == b == 0:\n            zeroes += 1\n            continue\n\n        g = math.gcd(a, b)\n        a, b = a//g, b//g \n        \n        if b < 0:\n            a, b = -a, -b\n        \n        if a <= 0:\n            a, b = b, -a\n            quadrant1[(a, b)] += 0\n            quadrant2[(a, b)] += 1\n        else:\n            quadrant1[(a, b)] += 1\n            quadrant2[(a, b)] += 0\n    \n    ans = 1\n    for key, value in quadrant1.items():\n        now = 1\n        now += pow(2, value, mod) - 1\n        now += pow(2, quadrant2[key], mod) - 1\n        ans = (ans * now) % mod\n    \n    ans += (zeroes - 1)\n    return ans % mod\n\ndef __starting_point():\n    print (main())\n__starting_point()", "from collections import defaultdict\nfrom math import gcd\n\nmod = 10 ** 9 + 7\nn = int(input())\nfishes = defaultdict(int)\nzero_zero = 0\nzero = 0\ninf = 0\n\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if a == 0 and b == 0:\n        zero_zero += 1\n\n    elif a == 0:\n        zero += 1\n\n    elif b == 0:\n        inf += 1\n\n    else:\n        div = gcd(a, b)\n        a //= div\n        b //= div\n        if b < 0:\n            a *= -1\n            b *= -1\n        key = (a, b)\n        fishes[key] += 1\n\n\ndef get_bad_pair(fish):\n    a, b = fish\n    if a < 0:\n        a *= -1\n        b *= -1\n    return (-b, a)\n\n\nans = 1\ncounted_key = set()\nfor fish_key, count in list(fishes.items()):\n    if fish_key in counted_key:\n        continue\n\n    bad_pair = get_bad_pair(fish_key)\n    if bad_pair in fishes:\n        pair_count = fishes[bad_pair]\n        pattern = pow(2, count, mod) + pow(2, pair_count, mod) - 1\n        counted_key.add(bad_pair)\n\n    else:\n        pattern = pow(2, count, mod)\n\n    ans = ans * pattern % mod\n\nans *= pow(2, zero, mod) + pow(2, inf, mod) - 1\nif zero_zero:\n    ans += zero_zero\n\nans -= 1\nprint((ans % mod))\n", "import math\ndef main():\n    N = int(input())\n    d = {}\n    zb = 0\n    za = 0\n    zab = 0\n    r = 0\n    mod = 10**9 + 7\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        if a== 0 and b == 0:\n            zab += 1\n        elif b == 0:\n            zb += 1\n        elif a == 0:\n            za += 1\n        else:\n            if a < 0:\n                a = -a\n                b = -b\n            x = math.gcd(abs(a), abs(b))\n            if (a//x, b//x) in d:\n                d[(a//x, b//x)] += 1\n            else:\n                d[(a//x, b//x)] = 1\n    used = set()\n    l = []\n    for x in d:\n        if x in used:\n            continue\n        a, b = x[0], x[1]\n        used.add(x)\n        if a * b > 0:\n            t = (abs(b), -abs(a))\n            if t in d:\n                used.add(t)\n                l.append((d[x], d[t]))\n            else:\n                l.append((d[x], 0))\n        else:\n            t = (abs(b), abs(a))\n            if t in d:\n                used.add(t)\n                l.append((d[x], d[t]))\n            else:\n                l.append((d[x], 0))\n    r = pow(2, za) + pow(2, zb) - 1\n    for i in l:\n        r *= (pow(2, i[0]) + pow(2, i[1]) - 1)\n        r %= mod\n    return (r - 1 + zab) % mod\nprint((main()))\n", "from math import gcd\n\nmod = 10**9 +7\nN = int(input())\ndic = {}\n\nzero = 0\nfor _ in range(N):\n    a,b = map(int, input().split())\n    if  a ==0 and b == 0:\n        zero += 1\n        continue\n    elif a == 0:\n        key = (0,1)\n    elif b == 0:\n        key = (1,0)\n    else:\n        if a<0:\n            a=-a \n            b=-b\n        g = gcd(a,abs(b))\n        key = (a//g,b//g)\n    \n    if key not in dic:\n        dic[key]=0\n\n    dic[key] +=1\n\nans = 1\nfor k1, v1 in dic.items():\n    if v1 ==0:\n        continue\n\n    if k1[1] >0:\n        k2 = (k1[1],-k1[0])\n    else:\n        k2 = (-k1[1],k1[0])\n\n    if k2 not in dic:\n        ans *= 2**v1\n        ans %= mod\n    else:\n        ans *= ((2**v1-1) %mod) + ((2**dic[k2]-1) %mod) +1\n        ans %= mod\n        dic[k2]=0\n\nans = (ans + zero -1 )%mod\nprint(ans)", "import math\nfrom collections import deque\n\nN = int(input())\n\na = []\nb = []\nfor i in range(N):\n    i1, i2 = list(map(int, input().split()))\n    g = math.gcd(i1,i2)\n    if g == 0:\n        a.append(i1)\n        b.append(i2)\n        continue\n    x = i1 // g\n    y = i2 // g\n    if x < 0:\n        x = - x\n        y = - y \n    a.append(x)\n    b.append(y)\n\nP = {}\nfor i in range(N):\n    if b[i] < 0:\n        tmp = b[i]\n        b[i] = a[i]\n        a[i] = - tmp\n        sgn = 1\n    elif a[i] == 0 and b[i] != 0:\n        a[i] = b[i]\n        b[i] = 0\n        sgn = 1\n    else :\n        sgn = 0\n\n    if (a[i],b[i]) in P:\n        P[(a[i],b[i])][sgn]=P[(a[i],b[i])][sgn] + 1\n    elif sgn == 0 :\n        P[(a[i],b[i])]=[1,0]\n    else :\n        P[(a[i],b[i])]=[0,1]\n\n\nMOD = 1000000007\na1 = 1 \nans0=0\nfor k in P:\n    if k == (0,0):\n        ans0 = P[k][0]\n    else:\n        a1 = a1*(pow(2,P[k][0],MOD)+pow(2,P[k][1],MOD) - 1) % MOD\n\nif ans0 != 0:\n    ans = ans0 + a1 -1\nelse:\n    ans = a1 -1\nprint((ans%MOD))\n\n", "from math import gcd\n \nn=int(input())\nmod = 10**9+7\n \nd = dict()\nzeros=0\nfor _ in range(n):\n  a,b=map(int,input().split())\n  if not any((a,b)):\n    zeros+=1\n    continue\n  if all((a,b)):\n    g = gcd(a,b)*(a//abs(a))\n  elif a:\n    g = a\n  else:\n    g = b\n  \n  p = a//g,b//g\n  d[p] = d.get(p,0)+1\n \nans = 1\ndone = set()\nfor (a,b),v in d.items():\n  if (-b,a) in done or (b,-a) in done:\n    continue\n  done.add((a,b))\n  w=d.get((-b,a),0)+d.get((b,-a),0)\n  ans *= (pow(2,v)+pow(2,w)-1)\n  ans %= mod\nprint((ans+zeros-1+mod)%mod)", "from math import gcd\nn=int(input())\nmod=10**9+7\nd1=dict()\nd2=dict()\nzero=0\nzeroa=0\nzerob=0\nfor _ in range(n):\n    a,b=list(map(int,input().split()))\n    if a==0 and b==0:\n        zero+=1\n    elif a==0 and b!=0:\n        zeroa+=1\n    elif a!=0 and b==0:\n        zerob+=1\n    else:\n        g=gcd(abs(a),abs(b))\n        na=a//g\n        nb=b//g\n        if na<0:\n            na=-na\n            nb=-nb\n        if (na,nb) not in d1 and (na,nb) not in d2:\n            d1[(na,nb)]=1\n            d2[(-nb,na)]=0\n            d2[(nb,-na)]=0\n        elif (na,nb) in d1:\n            d1[(na,nb)]+=1\n        else:\n            d2[(na,nb)]+=1\n#print(d1)\n#print(d2)\nd1=list(d1.items())\nans=pow(2,zeroa,mod)+pow(2,zerob,mod)-1\nans%=mod\nfor (a,b),cnt1 in d1:\n  cnt2=0\n  cnt2+=d2[(-b,a)]\n  cnt2+=d2[(b,-a)]\n  ans*=pow(2,cnt1,mod)+pow(2,cnt2,mod)-1\n  ans%=mod\nans+=zero\nans=(ans+mod-1)%mod\nprint(ans)\n#print(zeroa,zerob)\n", "N=int(input())\nfrom collections import defaultdict\ndic=defaultdict(int)\nimport math\nmod=1000000007\nfor _ in range(N):\n    A,B=list(map(int,input().split()))\n    if A<0:\n        A,B=-A,-B\n    if A==0:\n        if B==0:\n            dic[(0,0)]+=1\n        else:\n            dic[(0,1)]+=1\n    elif B==0:\n        dic[(1,0)]+=1\n    else:\n        gcd=math.gcd(A,B)\n        A,B=A//gcd,B//gcd\n        dic[(A,B)]+=1\n\nans=1\nN-=dic[(0,0)]\nfor k,v in list(dic.items()):\n    if k==(0,0) or k==(0,1):\n        continue\n    if k==(1,0):\n        if not (0,1) in dic:\n            continue\n        v_dash=dic[(0,1)]\n        ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n        ans%=mod\n        N-=v+v_dash\n        continue\n    a,b=k\n    if not (b,-a) in dic:\n        continue\n    v_dash=dic[(b,-a)]\n    ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n    ans%=mod\n    N-=v+v_dash\nans*=pow(2,N,mod)\nans+=dic[(0,0)]-1\nans%=mod\nprint(ans)\n", "from math import gcd\nfrom collections import Counter\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\ndef std(a, b):\n    if a == 0:\n        return (0, 1)\n\n    g = gcd(a, b)\n    a, b = a // g, b // g\n    return (a, b) if a > 0 else (-a, -b)\n\nC = Counter()\norig = 0\nfor a, b in zip(*[iter(AB)] * 2):\n    if a == b == 0:\n        orig += 1\n    else:\n        C[std(a, b)] += 1\n\nans = 1\ncnt = 0\nfor (a, b), v in C.items():\n    if b > 0:\n        if (b, -a) in C:\n            ans *= -1 + pow(2, v, mod) + pow(2, C[(b, -a)], mod)\n            ans %= mod\n        else:\n            cnt += v\n    elif (-b, a) not in C:\n        cnt += v\n\nans *= pow(2, cnt, mod)\nans += orig - 1\n\nprint(ans % mod)", "mod = 1000000007\nn = int(input())\n\nab00 = 0\nabx0 = 0\nab0x = 0\np = []\nm = []\n\nfrom math import gcd\nfor _ in range(n):\n    i, j = map(int, input().split())\n    if i == 0:\n        if j == 0:\n            ab00 += 1\n        else:\n            ab0x += 1\n        continue\n    elif j == 0:\n        abx0 += 1\n        continue\n    k = gcd(i, j)\n    i //= k\n    j //= k\n    if i > 0:\n        if j > 0:\n            p.append((i, j))\n        else:\n            m.append((-j, i))\n    elif j > 0:\n        m.append((j, -i))\n    else:\n        p.append((-i, -j))\n\nm.sort()\np.sort()\n\nans = pow(2, ab0x, mod) + pow(2, abx0, mod) - 1\nans %= mod\n\nmi = 0\npi = 0\nwhile mi < len(m) and pi < len(p):\n    if m[mi] == p[pi]:\n        mi += 1\n        mnum = 1\n        while mi < len(m) and m[mi] == m[mi-1]:\n            mi += 1\n            mnum += 1\n        pi += 1\n        pnum = 1\n        while pi < len(p) and p[pi] == p[pi-1]:\n            pi += 1\n            pnum += 1\n        ans *= pow(2, mnum, mod) + pow(2, pnum, mod) - 1\n        ans %= mod\n\n    elif m[mi] < p[pi]:\n        mi += 1\n        mnum = 1\n        while mi < len(m) and m[mi] < p[pi]:\n            mi += 1\n            mnum += 1\n        ans *= pow(2, mnum, mod)\n        ans %= mod\n    \n    else:\n        pi += 1\n        pnum = 1\n        while pi < len(p) and p[pi] < m[mi]:\n            pi += 1\n            pnum += 1\n        ans *= pow(2, pnum, mod)\n        ans %= mod\n\nans *= pow(2, len(p) - pi, mod)\nans %= mod\nans *= pow(2, len(m) - mi, mod)\nans %= mod\nans = (ans - 1 + ab00) % mod\nprint(ans)", "n=int(input())\nab=[list(map(int,input().split())) for _ in range(n)]\nfrom collections import defaultdict\nfrom math import gcd\nd=defaultdict(int)\nfor a,b in ab:\n  if a==0 and b==0:\n    d[(0,0)]+=1\n  elif a==0:\n    d[(1,0)]+=1\n  elif b==0:\n    d[(0,1)]+=1\n  else:\n    if a<0:\n      a*=-1\n      b*=-1\n    g=gcd(a,b)\n    d[(a//g,b//g)]+=1\nmod=pow(10,9)+7\nans=1\nkeys=list(d.keys())\nfor k in keys:\n  if k==(0,0):\n    continue\n  else:\n    a,b=k\n    x=b if b>0 else -b\n    y=-a if b>0 else a\n    k0=tuple([x,y])\n    if k0 in d:\n      ans*=pow(2,d[k],mod)-1+pow(2,d[k0],mod)-1+1\n      ans%=mod\n      d[k]=0\n      d[k0]=0\n    else:\n      ans*=pow(2,d[(a,b)],mod)\n      ans%=mod\nans+=d[(0,0)]\nans-=1\nprint((ans%mod))\n", "from math import gcd\nmod = 1000000007\nn = int(input())\nzero = 0\nbad = {}\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    if x == 0 and y == 0:\n        zero += 1\n        continue\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    if y < 0: x, y = -x, -y\n    if y==0 and x<0: x, y = -x, -y\n    is_rotate90 = (x <= 0)\n    if is_rotate90: x, y = y, -x\n    if not (x, y) in bad: bad[x, y] = [0, 0]\n    bad[x, y][is_rotate90] += 1\n\nans = 1\nfor x, y in bad:\n    c1, c2 = bad[x, y]\n    c3 = (pow(2, c1, mod) - 1) + (pow(2, c2, mod) - 1) + 1\n    ans *= c3\n    ans %= mod\n\nans += zero - 1\nans = (ans + mod) % mod\nprint(ans)\n", "N=int(input())\nfrom collections import defaultdict\nimport math\nd = defaultdict(int)\nMOD=10**9+7\nfor i in range(N):\n  a,b=map(int,input().split())\n  x=math.gcd(abs(a),abs(b))\n  if a==0:\n    if b==0:\n      k=(0,0)\n    else:\n      k=(0,1)\n  elif b==0:\n    k=(1,0)\n  else:\n    if a<0:\n      a,b=-a,-b\n    if b<0:\n      a,b=a//x,-((-b)//x)\n    else:\n      a,b=a//x,b//x\n    k=(a,b)\n  d[k]+=1\n\nind=defaultdict(int)\nindex=1\n_ans=[1]\nfor a,b in list(d.keys()):\n  if a==b==0:\n    continue\n  if b<=0:\n    _k=(-b,a)\n  else:\n    _k=(b,-a)\n  if d[_k]==0:\n    _ans[0]*=pow(2,d[(a,b)])\n  else:\n    if ind[_k]==0:\n      _ans.append(pow(2,d[(a,b)],MOD))\n      ind[(a,b)]=index\n      index+=1\n    else:\n      _ans[ind[_k]]+=pow(2,d[(a,b)],MOD)-1\nans=1\nfor a in _ans:\n  ans=ans*a%MOD\nprint((d[(0,0)]+ans-1+MOD)%MOD)", "from math import gcd\n\nn = int(input())\nration = dict()\nused = dict()\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if a == 0 or b == 0:\n        if a == b == 0:\n            r = '0'\n        elif a == 0:\n            r = '0a'\n        else:\n            r = '0b'\n    else:\n        s = '-' if (a < 0) ^ (b < 0) else '+'\n        a = abs(a)\n        b = abs(b)\n        g = gcd(a, b)\n        r = f'{s} {a//g} {b//g}'\n    ration[r] = ration.get(r, 0) + 1\n    used[r] = 0\n\nres = 1\nmod = 10**9+7\nadd = 0\nfor k, v in list(ration.items()):\n    if used[k]:\n        continue\n    if k == '0':\n        add += v\n        used[k] = 1\n    elif k == '0a' or k == '0b':\n        res *= 2**ration.get('0a', 0) + 2**ration.get('0b', 0) - 1\n        used['0a'] = used['0b'] = 1\n    else:\n        r = k.split()\n        l = f'{\"-\" if r[0]==\"+\" else \"+\"} {r[2]} {r[1]}'\n        res *= 2**v + 2**ration.get(l, 0) - 1\n        used[k] = used[l] = 1\n    res %= mod\n\nres += add\nres -= 1\nif res < 0:\n    res += mod\nprint(res)\n", "from math import gcd\nfrom collections import defaultdict\n\n\ndef sign(x):\n    if x < 0:\n        return -1\n    if x > 0:\n        return +1\n    return 0\n\n\ndef power(a, b, m):\n    res = 1\n    base = a\n    while b:\n        if b & 1:\n            res = res * base % m\n        base = base * base % m\n        b = b >> 1\n    return res\n\n\nN = int(input())\nM = 1000000007\ncnt = defaultdict(int)\ncase00 = 0\n\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    if a == 0 and b == 0:  # (0, 0) cannot pair with anyone\n        case00 += 1\n        continue\n\n    s = sign(a) * sign(b)\n    a, b = abs(a), abs(b)\n    g = gcd(a, b)\n    a, b = a // g, b // g\n    cnt[s, a, b] += 1\n\n\nans = 1  # empty set\nvis = set()\nfor (s, a, b) in list(cnt.keys()):\n    if (s, a, b) in vis:\n        continue\n\n    if (-s, b, a) in cnt:\n        mul = 1  # empty set from (s, a, b) and (-s, b, a)\n        mul += power(2, cnt[s, a, b], M) - 1  # non-empty subsets from (s, a, b)\n        mul += power(2, cnt[-s, b, a], M) - 1  # non-empty subsets from (-s, b, a)\n        ans = ans * (mul % M) % M\n        vis.add((-s, b, a))\n    else:\n        ans = ans * power(2, cnt[s, a, b], M) % M\n\nans = (ans - 1 + M) % M  # Remove empty set\nans = (ans + case00) % M  # Special case\nprint(ans)\n", "import sys, os\n\nif 'local' in os.environ :\n    sys.stdin = open('./input.txt', 'r')\n\nf = lambda:list(map(int, input().split()))\n\n\ndef gcd(a,b):\n    return b if a == 0 else gcd(b%a, a)\n\ndef quick_pow(x,n, mod):\n    ans= 1\n    while n:\n        if n&1:\n            ans *= x\n            ans %= mod\n        x *= x\n        x %= mod\n        n >>= 1\n    \n    return ans\n\n\ndef solve():\n    mod = 1000000007\n    n = f()[0]\n\n    dirs = {}\n\n    all0 = 0\n    x0 = 0\n    y0 = 0\n\n    for _ in range(n):\n        a,b = f()\n        if a ==0 and b == 0:\n            all0 += 1\n            continue\n        if a == 0:\n            x0 += 1\n            continue\n        if b == 0:\n            y0 += 1\n            continue\n\n        if a <0:\n            a = -a\n            b = -b\n        g = gcd(abs(a),abs(b))\n        a //= g\n        b //= g\n\n        if a*b >0:\n            if (a,b) not in dirs:\n                dirs[(a,b)] = {}\n                dirs[(a,b)][0] = 0\n                dirs[(a,b)][1] = 0\n            dirs[(a,b)][0] = dirs[(a,b)][0]+ 1\n        else:\n            if (-b,a) not in dirs:\n                dirs[(-b,a)] = {}\n                dirs[(-b,a)][0] = 0\n                dirs[(-b,a)][1] = 0\n            dirs[(-b,a)][1] = dirs[(-b,a)][1] + 1 \n            \n    \n    ans = 1\n    ans *= (quick_pow(2, x0, mod) + quick_pow(2, y0, mod)-1 + mod) % mod\n\n    \n    ans %= mod\n    for _, l in list(dirs.items()):\n        ans *= (quick_pow(2, l[0], mod) + quick_pow(2, l[1], mod)-1 + mod)%mod\n        ans %= mod\n\n    \n    ans -= 1\n    if all0:\n        ans+= all0\n    \n    ans += mod\n    ans%= mod\n    print(ans)\n    \n\nsolve()\n\n", "from math import gcd\nfrom sys import setrecursionlimit\nsetrecursionlimit(4100000)\nmod = 10 ** 9 + 7\nn = int(input())\n\nzeros = 0\nd = {}\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x == 0 and y == 0:\n        zeros += 1\n    else:\n        g = gcd(x, y)\n        x, y = x // g, y // g\n        if (y < 0) or (y == 0 and x < 0): \n            x, y = -x, -y\n        else: \n            pass\n        if x <= 0:\n            sq = True   #second quadrant\n            x, y = y, -x\n        else:\n            sq = False\n        if sq == True:\n            if (x, y) in d:\n                d[(x, y)][1] += 1\n            else:\n                d[(x, y)] = [0, 1]\n        else:\n            if (x, y) in d:\n                d[(x, y)][0] += 1\n            else:\n                d[(x, y)] =[1, 0] \n\n#\u7e70\u308a\u8fd4\u30572\u4e57\u6cd5\ndef  mod_pow(a:int, b:int, mod:int)->int:\n    if b == 0:\n        return 1 % mod\n    elif b % 2 == 0:\n        return (mod_pow(a, b//2, mod) ** 2) % mod\n    elif b == 1:\n        return a % mod\n    else:\n        return ((mod_pow(a, b//2, mod) ** 2) * a) % mod\n#print(d)\n\nans = 1\nfor (a, b), (k, l) in d.items():\n    now = 1\n    now = (now + mod_pow(2, k, mod) - 1) % mod\n    now = (now + mod_pow(2, l, mod) - 1) % mod\n    ans = (ans * now) % mod\n    \nans -= 1\nzeros = zeros % mod\nans = (ans + zeros) % mod\nprint(ans)", "from collections import defaultdict\nn,*L=list(map(int,open(0).read().split()))\nmod=10**9+7\nd=defaultdict(lambda:[0,0])\ngcd=lambda x,y:x if y==0 else gcd(y,x%y)\ntwo=[1]*(n+1)\nfor i in range(n):\n\ttwo[i+1]=(two[i]*2)%mod\nzero=0\nfor a,b in zip(*[iter(L)]*2):\n\tif a==b==0:\n\t\tzero+=1\n\t\tcontinue\n\tif a==0:\n\t\td[(0,1)][0]+=1\n\telif b==0:\n\t\td[(0,1)][1]+=1\n\telse:\n\t\tg=gcd(a,b)\n\t\ta//=g\n\t\tb//=g\n\t\tif a*b>0:\n\t\t\td[(a,b)][0]+=1\n\t\telse:\n\t\t\td[(abs(b),abs(a))][1]+=1\nans=1\nfor (_,_),(x,y) in list(d.items()):\n\tans*=(two[x]+two[y]-1)%mod\n\tans%=mod\nprint(((ans+zero+mod-1)%mod))\n", "from math import gcd\nimport math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1 for i in range(self.n)]\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.par[p] += self.par[q]\n        self.par[q] = p\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nmod = 10 ** 9 + 7\nn = int(input())\nzeros = 0\ncount = dict()\nfor i in range(n):\n    a, b = map(int, input().split())\n    if (a, b) == (0, 0):\n        zeros += 1\n        continue\n    g = gcd(abs(a), abs(b))\n    a //= g\n    b //= g\n    cnt = 0\n    while a < 0 or b <= 0:\n        a, b = -1 * b, a\n        cnt += 1\n    if not (a, b) in count:\n        count[(a, b)] = [0, 0]\n    count[(a, b)][cnt % 2] += 1\nans = 1\nfor i in count:\n    a, b = count[i]\n    ans *= (pow(2, a, mod) + pow(2, b, mod) - 1) % mod\n    ans %= mod\nprint((ans + zeros - 1) % mod)", "import sys\nfrom math import gcd\nfrom collections import Counter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nN, *AB = list(map(int, read().split()))\nmod = 10 ** 9 + 7\n\nab = []\nzero = 0\nfor A, B in zip(*[iter(AB)] * 2):\n    if A == 0 and B == 0:\n        zero += 1\n        continue\n    if A == 0:\n        B = -1\n    elif B == 0:\n        A = 1\n    else:\n        g = gcd(A, B)\n        A //= g\n        B //= g\n    if A < 0:\n        A, B = -A, -B\n    ab.append((A, B))\n\ncnt = Counter(ab)\nanswer = 1\nchecked = set()\nok = 0\n\nfor (i, j), n in list(cnt.items()):\n    if (i, j) in checked:\n        continue\n    if j < 0:\n        c, d = -j, i\n    else:\n        c, d = j, -i\n    if (c, d) in cnt:\n        m = cnt[(c, d)]\n        answer = (answer * (pow(2, n, mod) + pow(2, m, mod) - 1)) % mod\n        checked.add((c, d))\n    else:\n        ok += n\n\nanswer *= pow(2, ok, mod)\nanswer -= 1\nanswer += zero\nanswer %= mod\nprint(answer)\n", "import numpy as np\ndic = dict()\nmod = 10 ** 9 + 7\np = 0\n\ndef reg(a, b):\n\tif a < 0 or (a == 0 and b < 0):\n\t\ta, b = -a, -b\n\tif b > 0:\n\t\treturn 0, a, b\n\telse:\n\t\treturn 1, -b, a\n\nn = int(input())\nfor _ in range(n):\n\ta, b = map(int, input().split())\n\tif a == 0 and b == 0:\n\t\tp += 1\n\t\tcontinue\n\tab = np.gcd(a, b)\n\ta, b = a//ab, b//ab\n\tidx, a, b = reg(a, b)\n\tk = (a, b)\n\tif k not in dic.keys():\n\t\tdic[k] = [0, 0]\n\tdic[k][idx] += 1\n\nnot_p = 1\nfor k in dic.keys():\n\ta, b = k\n\tpp, pm = dic[k]\n\tnot_p *= (pow(2, pp, mod) + pow(2, pm, mod) - 1) % mod\n\tnot_p %= mod\n\nprint((p + not_p -1) % mod)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom fractions import Fraction\nfrom bisect import bisect_left, bisect_right\n\n\ndef read():\n    N = int(input().strip())\n    # a!=0 \u304b\u3064 b!=0\n    AB = []\n    # a!=0 \u307e\u305f\u306f b!=0\n    ZAB = []\n    M = 0\n    ZM = 0\n    for i in range(N):\n        a, b = map(int, input().strip().split())\n        # (a, b) == (0, 0) \u306f\u9664\u5916\u3059\u308b\n        if a != 0 or b != 0:\n            AB.append((a, b))\n            M += 1\n    return N, M, AB\n\n\ndef solve(N, M, AB, MOD=1000000007):\n    # \u9b5ai\u306b\u5bfe\u3057\u3066\u3001\u4ef2\u306e\u60aa\u3044\u9b5aj\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\n    D = defaultdict(int)\n    INVD = defaultdict(int)\n\n    # Ai/Bi \u306e\u65e2\u7d04\u5206\u6570\u3067\u30b0\u30eb\u30fc\u30d7\u3092\u4f5c\u308b\n    keys = set()\n    for a, b in AB:\n        if a == 0:\n            # 0/Bi\n            D[\"0\"] += 1\n            keys.add(\"0\")\n        elif b == 0:\n            # Ai/0\n            INVD[\"0\"] += 1\n            keys.add(\"0\")\n        else:\n            f = Fraction(a, b)\n            if f > 0:\n                key = str(f)\n                D[key] += 1\n                keys.add(key)\n            else:\n                key = str(-1/f)\n                INVD[key] += 1\n                keys.add(key)\n\n    # a!=0 \u304b\u3064 b!=0 \u306b\u304a\u3051\u308b\u9b5a\u7fa4\u306e\u9078\u3073\u65b9\u3092\u6570\u3048\u4e0a\u3052\n    # \u30b0\u30eb\u30fc\u30d7i\u306b\u304a\u3044\u3066\n    # (1-1) D[i] \u500b\u306e\u9b5a\u304b\u30891\u3064\u4ee5\u4e0a\u9078\u3076 ... (2^D[i] - 1) \u901a\u308a\n    # (1-2) INVD[i] \u500b\u306e\u9b5a\u304b\u30891\u3064\u4ee5\u4e0a\u9078\u3076 ... (2^INVD[i] - 1) \u901a\u308a\n    # (1-3) \u30b0\u30eb\u30fc\u30d7i \u304b\u3089\u9b5a\u3092\u9078\u3070\u306a\u3044 ... 1\u901a\u308a\n    ans = 1\n    for key in keys:\n        g1 = pow(2, D[key], MOD) - 1\n        g2 = pow(2, INVD[key], MOD) - 1\n        g3 = 1\n        ans *= (g1 + g2 + g3)\n        ans %= MOD\n\n    # \u9b5a\u30921\u3064\u3082\u9078\u3070\u306a\u3044\u5834\u5408\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u3053\u308c\u3092\u9664\u304f\n    ans -= 1\n    ans %= MOD\n\n    # (a, b) == (0, 0) \u304c\u3042\u308b\u3068\u304d\u306f\u3001\u305d\u306e1\u5339\u3060\u3051\u306a\u3089\u5165\u308c\u3089\u308c\u308b\n    ans += N - M\n    ans %= MOD\n\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print(\"%s\" % str(outputs))\n__starting_point()", "from math import gcd\nn = int(input())\np = 10**9 + 7\niwashi = {}\nbad = 0\nans = 1\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    if(x == 0 and y == 0):\n      bad += 1\n      continue\n    elif(x == 0):\n        try:\n        \tiwashi[(0, 1)] += 1\n        except KeyError:\n            iwashi[(0, 1)] = 1\n            continue\n    elif(y == 0):\n        try:\n        \tiwashi[(1, 0)] += 1\n        except KeyError:\n            iwashi[(1, 0)] = 1\n        continue\n    else:\n        g = gcd(x, y)\n        x, y = x // g, y // g\n        if x < 0:\n            x, y = -x, -y\n        try:\n        \tiwashi[(x, y)] += 1\n        except KeyError:\n            iwashi[(x, y)] = 1\n            \nfor x, y in iwashi:\n    a = iwashi[(x, y)]\n    if y > 0:\n    \trx,ry = y, -x\n    else:\n      \trx,ry = -y, x\n    try:\n        b = iwashi[(rx,ry)]\n        iwashi[(rx,ry)] = 0\n    except KeyError:\n      \tb = 0\n    ans *= pow(2, a, p) + pow(2, b, p) - 1\n    ans %= p\n    iwashi[(x, y)] = 0\nprint(((ans + bad - 1) % p))\n", "from collections import defaultdict\nfrom math import gcd\n\nmod = 10 ** 9 + 7\n\nn = int(input())\nab = [tuple(map(int, input().split())) for _ in range(n)]\n\nd = defaultdict(int)\nzero = 0\nfor a, b in ab:\n    # zero\u3000\u5225\u51e6\u7406\n    if a == b == 0:\n        zero += 1\n        continue\n    if a == 0:\n        d[(0, 1)] += 1\n        continue\n    if b == 0:\n        d[(1, 0)] += 1\n        continue\n\n    # a[i]\u304c\u7d76\u5bfe\u306b\u975e\u8ca0\u306b\u306a\u308b\u3088\u3046\u306b\n    if a < 0:\n        a *= -1\n        b *= -1\n    g = gcd(a, b)\n    d[(a // g, b // g)] += 1\n\nall = n - zero\nans = 1\nfor k1, v in list(d.items()):\n    k2 = (k1[1], -k1[0])\n    if k2 in list(d.keys()):\n        all -= v\n        all -= d[k2]\n        ans = ans * (pow(2, v, mod) + pow(2, d[k2], mod) - 1) % mod\nans = ans * pow(2, all, mod) % mod\nprint(((ans - 1 + zero) % mod))\n", "from math import gcd\nMOD = 10 ** 9 + 7\nN = int(input())\nd = dict()\nzeros = 0\nfor _ in range(N):\n    a, b = tuple(map(int, input().split()))\n    if not any((a, b)):\n        zeros += 1\n        continue\n    g = gcd(a, b) * (a // abs(a)) if all((a, b)) else a if a else b\n    p = a // g, b // g\n    d[p] = d.get(p, 0) + 1\ndone = set()\ntotal = 1\nfor (a, b), v in d.items():\n    if (b, -a) in done or (-b, a) in done:\n        continue\n    done.add((a, b))\n    w = d.get((b, -a), 0) + d.get((-b, a), 0)\n    total = total * (pow(2, v, MOD) + pow(2, w, MOD) - 1) % MOD\nprint((total + zeros - 1) % MOD)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**7)\nfrom pprint import pprint as pp\nfrom pprint import pformat as pf\n# @pysnooper.snoop()\n#import pysnooper # debug\n\nimport math\n#from sortedcontainers import SortedList, SortedDict, SortedSet # no in atcoder\nimport bisect\nfrom fractions import Fraction\nfrom collections import defaultdict\n\ndef is_same_sign(a, b):\n    if a > 0 and b > 0:\n        return True\n    if a < 0 and b < 0:\n        return True\n    return False\n\ndef fraction_taple(a, b):\n    g = math.gcd(a, b)\n    if is_same_sign(a, b):\n        s = 1\n    else:\n        s = -1\n    a = abs(a) // g\n    b = abs(b) // g\n    return (s, a, b)\n\ndef mode(a, b):\n    # retrun dict_key, arr_key\n    if a == 0 and b == 0:\n        return 0, 0\n    if a == 0:\n        return 'ab', 0\n    if b == 0:\n        return 'ab', 1\n    x = fraction_taple(a, b)\n    y = fraction_taple(-1 * b, a)\n    if x > y:\n        return x, 0\n    else:\n        return y, 1\n\nMOD = 1000000007\n\ndef __starting_point():\n\n    n = int(input())\n\n    d = defaultdict(lambda: [0, 0])\n    zero = 0\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        dkey, akey = mode(a, b)\n        if dkey == 0:\n            zero += 1\n        else:\n            d[dkey][akey] += 1\n    #print('d') # debug\n    #pp(d) # debug\n\n    ans = 1\n    for pair in list(d.values()):\n        tmp = pow(2, pair[0], MOD) - 1 + pow(2, pair[1], MOD) - 1 + 1\n        ans *= tmp\n    ans += zero - 1\n    ans %= MOD\n    #print('ans') # debug\n    print(ans)\n\n    #print('\\33[32m' + 'end' + '\\033[0m') # debug\n\n__starting_point()", "from collections import defaultdict, deque\nimport math\n\nkMod = 1000000007\n\nN = int(input())\nkey2count = defaultdict(lambda: [0, 0])\n\nfor _ in range(N):\n    a, b = map(int, input().split())\n    g = math.gcd(a, b)\n    if a < 0 or a == 0 and b < 0:\n        a, b = -a, -b\n    if g > 0:\n        a, b = a//g, b//g\n    idx = 0\n    if b <= 0:\n        idx = 1\n        a, b = -b, a\n    key2count[(a, b)][idx] += 1\n\nans = 1\nfor key, val in key2count.items():\n    if key == (0, 0):\n        continue\n    plus, minus = val\n    ans *= (pow(2, plus, kMod) + pow(2, minus, kMod)-1)\n    ans %= kMod\n\nans += sum(key2count[(0, 0)])\n\nprint((ans + kMod-1) % kMod)", "N=int(input())\nAB=[list(map(int,input().split())) for i in range(N)]\nfrom collections import defaultdict\nd=defaultdict(int)\nd2=defaultdict(int)\na0=0\nb0=0\nc0=0\nfrom math import gcd\nfor a,b in AB:\n    if a==b==0:\n        c0+=1\n    elif a==0:\n        a0+=1\n    elif b==0:\n        b0+=1\n    else:\n        if a<0:\n            a,b=-a,-b\n        g=gcd(a,b)\n        a,b=a//g,b//g\n        if b>0:\n            d[(a,b)]+=1\n        else:\n            d2[(-b,a)]+=1\nm=10**9+7\na=1\nfor k,v in d.items():\n    if k in d2:\n        a=a*(pow(2,v,m)+pow(2,d2[k],m)-1)%m\n    else:\n        a=a*pow(2,v,m)%m\nfor k,v in d2.items():\n    if k not in d:\n        a=a*pow(2,v,m)%m\nprint((a*(pow(2,a0,m)+pow(2,b0,m)-1)-1+c0)%m)", "from math import gcd\n\n\nMOD = 10**9 + 7\n\nn = int(input())\n\ncnt = {}\n\nzero_cnt = 0\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    if (a,b) == (0,0):\n        zero_cnt += 1\n        continue\n    g = gcd(abs(a), abs(b))\n    a //= g\n    b //= g\n    rotate = 0\n    while not (a >= 0 and b > 0):\n        a,b = -b,a\n        rotate += 1\n    if (a,b) not in cnt:\n        cnt[(a,b)] = [0,0]\n\n    cnt[(a,b)][rotate % 2] += 1\n\nans = 1\n    \nfor key in cnt:\n    A, B = cnt[key]\n    ans *= 1 + pow(2, A, MOD) - 1 + pow(2, B, MOD) - 1\n    ans %= MOD\n\nans += zero_cnt\nans -= 1\nprint((ans % MOD))\n\n    \n", "N = int(input())\nzero = 0\nr_zero = 0\nl_zero = 0\nmod = 1000000007\nfrom collections import defaultdict\nfrom math import gcd\ndic = defaultdict(int)\nfor i in range(N):\n    A, B = list(map(int, input().split()))\n    if A==0 and B==0:\n        zero += 1\n        continue\n    elif A==0:\n        r_zero += 1\n    elif B==0:\n        l_zero += 1\n    else:\n        g = gcd(A, B)\n        A //= g\n        B //= g\n        if A<0:\n            A, B = -A, -B\n        dic[(A, B)] += 1\n\ndickey = list(dic.keys())\ns = set(dickey)\nnopair = N-zero-r_zero-l_zero\nans = pow(2, r_zero, mod)+pow(2, l_zero, mod)-1\nfor a, b in dickey:\n    if a*b>0 and (b, -a) in s:\n        ans *= (pow(2, dic[(a, b)], mod)+pow(2, dic[(b, -a)], mod)-1)%mod\n        nopair -= (dic[(a, b)]+dic[(b, -a)])\nans *= pow(2, nopair, mod)\nprint(((ans-1+zero)%mod))\n\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    import math\n    from collections import defaultdict\n\n    mod = 1000000007\n\n    N = int(input())\n\n    zero_pair = 0\n    zero_a = 0\n    zero_b = 0\n    pair_plus = defaultdict(int)\n    pair_minus = defaultdict(int)\n    for a, b in [tuple(map(int, input().split())) for _ in range(N)]:\n        if a == 0 and b == 0:\n            zero_pair += 1\n            continue\n        if a == 0:\n            zero_a += 1\n            continue\n        if b == 0:\n            zero_b += 1\n            continue\n\n        abs_a = abs(a)\n        abs_b = abs(b)\n        g = math.gcd(abs_a, abs_b)\n        abs_a = abs_a//g\n        abs_b = abs_b//g\n        if a * b > 0:\n            pair_plus[(abs_a, abs_b)] += 1\n        else:\n            pair_minus[(abs_a, abs_b)] += 1\n\n    ans = 1\n    ans *= (pow(2, zero_a, mod) + pow(2, zero_b, mod) - 1) % mod\n    ans %= mod\n\n    count_all = 0\n    for item in list(pair_plus.items()):\n        a, b = item[0]\n        cnt = item[1]\n        if (b,a) in pair_minus:\n            ans *= (pow(2, cnt, mod) + pow(2, pair_minus[(b,a)]) - 1) % mod\n            ans %= mod\n            del pair_minus[(b, a)]\n        else:\n            count_all += cnt\n\n    for val in list(pair_minus.values()):\n        count_all += val\n\n    ans = (ans * pow(2, count_all, mod)) % mod\n    ans += zero_pair\n    print(((ans - 1) % mod))\n\nmain()\n\n\n", "# \u7d04\u5206\u3057\u3066\u3001\u4e92\u3044\u306b\u7d20\u306a(1,3) (3,1)\u306e\u3088\u3046\u306a\u30da\u30a2\u3092\u4f5c\u308a\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n# \u6b63\u306e\u30b0\u30eb\u30fc\u30d7\u3068\u8ca0\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u5225\u3005\u306b\u7ba1\u7406\n# \u6b63\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u76f8\u624b\u304c\u8ca0\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5b58\u5728\u3057\u305f\u5834\u5408\u3001\n# \u3069\u3061\u3089\u304b\u306e\u30b0\u30eb\u30fc\u30d7\u304b\u3089\u597d\u304d\u306a\u3060\u3051\u9078\u3076\u304b\u3001\u3069\u3061\u3089\u3082\u9078\u3070\u306a\u3044\u304b\u3057\u304b\u306a\u3044\n# \u8ab0\u3068\u3082\u30da\u30a2\u306b\u306a\u3089\u306a\u304b\u3063\u305f\u30b0\u30eb\u30fc\u30d7\u306e\u500b\u6570\u3092\u5168\u3066\u8db3\u3057\u3066P\u500b\u3060\u3068\u3057\u3066\u30012^P\u901a\u308a\u3092\u639b\u3051\u308b\n# (0,0)\u306b\u3064\u3044\u3066\u306f\u3001\u305d\u306e\u4e2d\u304b\u30891\u3064\u9078\u3076\u304b\u3001\u9078\u3070\u306a\u3044\u304b\u3057\u304b\u306a\u3044\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nimport math\n\nzeropair = 0\nzeroa = 0\nzerob = 0\nfrom collections import defaultdict\npluspair = defaultdict(int)\nminuspair = defaultdict(int)\nfor i in range(N):\n  a,b = list(map(int,readline().split()))\n  if a == 0 and b == 0:\n    zeropair += 1\n    continue\n  if a == 0:\n    zeroa += 1\n    continue\n  if b == 0:\n    zerob += 1\n    continue\n  absa = abs(a)\n  absb = abs(b)\n  g = math.gcd(absa,absb)\n  absa,absb = absa//g,absb//g\n  if a * b > 0:\n    pluspair[(absa,absb)] += 1\n  else:\n    minuspair[(absa,absb)] += 1\n\nDIV = 1000000007\nans = 1\n# zeroa,zerob\u304b\u3089\u9078\u3076\u30d1\u30bf\u30fc\u30f3\u306f\u3001\u3069\u3061\u3089\u304b\u3089\u597d\u304d\u306a\u3060\u3051\u9078\u3076\u304b\u3001\u3069\u3061\u3089\u3082\u9078\u3070\u306a\u3044\u304b\nans *= (pow(2,zeroa,DIV) + pow(2,zerob,DIV) - 1) % DIV\nans %= DIV\n\n# \u8ab0\u3068\u3067\u3082\u30da\u30a2\u306b\u306a\u308c\u308b\u3082\u306e\u3092\u30ab\u30a6\u30f3\u30c8\nallcnt = 0\n\n# plus\u304b\u3089\u9078\u3076\u30d1\u30bf\u30fc\u30f3\u3067\u3001minus\u306b\u3042\u308b\u5bfe\u5fdc\u30da\u30a2\u3092\u63a2\u3059\nfor item in list(pluspair.items()):\n  a,b = item[0]\n  cnt = item[1]\n  if (b,a) in minuspair:\n    ans *= (pow(2,cnt,DIV) + pow(2,minuspair[(b,a)]) - 1) % DIV\n    ans %= DIV\n    del minuspair[(b,a)]\n  else:\n    allcnt += cnt\n\nfor val in list(minuspair.values()):\n  allcnt += val\n\nans = (ans * pow(2,allcnt,DIV)) % DIV\n# zeropair\u304b\u3089\u9078\u3093\u3060\u5834\u5408\u3001\u4eca\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u3068\u306f\u72ec\u7acb\nans += zeropair\nprint(((ans - 1) % DIV))\n", "from math import gcd\nfrom collections import defaultdict\nmod = 10**9+7\nn = int(input())\nmp = defaultdict(lambda: [0, 0])\nzerozero = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    if (a, b) == (0, 0):\n        zerozero += 1\n        continue\n    g = gcd(a, b)\n    a //= g\n    b //= g\n    rot_cnt = 0\n    while not (a > 0 and b >= 0):\n        a, b = -b, a\n        rot_cnt += 1\n    mp[(a,b)][rot_cnt%2] += 1\nans = 1\nfor s, t in mp.values():\n    now = (pow(2, s, mod) + pow(2, t, mod) - 1) % mod\n    ans = (ans * now) % mod\nans = (ans - 1 + zerozero) % mod \nprint(ans)", "from collections import Counter\n\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return abs(a)\n\nMOD = 1000000007\n\n# 2 WA\ndef main():\n    N = int(input())\n    d = {}\n    d[(1,0)] = (0,0)\n    z = 0\n    for i in range(N):\n      a,b = (int(x) for x in input().split())\n      g = gcd(a,b)\n      if g != 0:\n        a = a//g\n        b = b//g\n        if a*b<0: a = -abs(a)\n        elif a*b>0: a = abs(a)\n      b = abs(b)\n      \n      if a*b==0:\n        if a==b==0: z+=1\n        elif b==0: d[(1,0)] = (d[(1,0)][0]+1,d[(1,0)][1])\n        elif a==0: d[(1,0)] = (d[(1,0)][0],  d[(1,0)][1]+1)\n      else:\n        if (a,b) in d: d[(a,b)] = (d[(a,b)][0]+1,d[(a,b)][1])\n        elif (b, -a) in d: d[(b,-a)] = (d[(b,-a)][0], d[(b,-a)][1]+1)\n        elif (-b, a) in d: d[(-b,a)] = (d[(-b,a)][0], d[(-b,a)][1]+1)\n        else: d[(a,b)] = (1,0)\n    \n    ans = 1\n    for i, j in list(d.values()):\n      ans *= (pow(2,i,MOD) + pow(2,j,MOD) - 1)\n      ans %= MOD\n\n    print(((ans-1+z)%MOD))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nfrom math import gcd\nN = int(input())\nmod = 10**9 + 7\nD = defaultdict(int)\ncorner = 0\nD[(0,1)]=0\nD[(1,0)]=0\nfor i in range(N):\n    x, y = map(int, input().split())\n    if x*y != 0:\n        x, y = x//gcd(x, y), y//gcd(x, y)\n        if y > 0:\n            D[(x, y)] += 1\n        elif y < 0:\n            D[(-x, -y)] += 1\n    else:\n        if x == 0 and y == 0:\n            corner += 1\n            continue\n        else:\n            if x == 0:\n                D[(0, 1)] += 1\n            elif y == 0:\n                D[(1, 0)] += 1\nans = corner\n# \u4ee5\u4e0b\u3001(0,0) \u3092\u5165\u308c\u306a\u3044\u6642\u3002(X,Y) \u306eY\u306f\u5168\u30660\u4ee5\u4e0a\u3067\u7d71\u4e00\u3059\u308b\uff08\u4f55\u3082\u5165\u308c\u306a\u3044\u3082\u4e00\u5fdc\u30ab\u30a6\u30f3\u30c8\uff09\nc = 1\nsub=[]\nfor x, y in D.keys():\n    if x<0 and y>0:\n        if not (y,-x) in D.keys():\n            sub.append((y,-x))\nfor some in sub:\n    D[some]=0\n\nK=list(D.keys())\nfor x, y in K:\n    if x > 0 and y > 0:\n        a = D[(x, y)]\n        b = D[(-y, x)]\n        c *= (pow(2, a, mod)+pow(2, b, mod)-1)\n        c %= mod\n    elif y == 0:\n        a = D[(1, 0)]\n        b = D[(0, 1)]\n        c *= (pow(2, a, mod)+pow(2, b, mod)-1)\n        c %= mod\nans += c-1\n\nprint(ans % mod)", "from math import gcd\n\nn=int(input())\nmod=10**9+7\n\nd=dict()\nzeros=0\nfor _ in range(n):\n  a,b=list(map(int,input().split()))\n  if not any((a,b)):\n    zeros+=1\n    continue\n  if all((a,b)):\n    g=gcd(a,b)*(a//abs(a))\n  elif a:\n    g = a\n  else:\n    g = b\n  p=a//g,b//g\n  d[p]=d.get(p,0)+1\n\nans=1\ndone=set()\nfor (a,b),v in list(d.items()):\n  if (-b,a) in done or (b,-a) in done:\n    continue\n  done.add((a,b))\n  w=d.get((-b,a),0)+d.get((b,-a),0)\n  ans *=(pow(2,v)+pow(2,w)-1)\n  ans %= mod\nprint(((ans+zeros-1)%mod))\n\n", "from collections import defaultdict\nMOD = 10**9+7\nfrom math import gcd\n\n\nn = int(input())\nans = 1\nC = defaultdict(int)\nz = 0\nr = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        r += 1\n    elif b == 0:\n        z += 1\n    elif a == 0:\n        C[0] += 1\n    else:\n        g = gcd(abs(a), abs(b))\n        a //= g\n        b //= g\n        if a < 0:\n            a, b = -a, -b\n        C[(a, b)] += 1\nD = tuple(C.items())\nused = {0}\nfor c, v in D:\n    if c in used:\n        continue\n    a, b = c\n    if b > 0:\n        d, e = b, -a\n    else:\n        d, e = -b, a\n    ans *= pow(2, v, MOD)+pow(2, C[(d, e)], MOD)-1\n    ans %= MOD\n    used.add((d, e))\nans *= pow(2, C[0], MOD)+pow(2, z, MOD)-1\nans += r\nans -= 1\nans %= MOD\nprint(ans)", "from collections import deque\nfrom math import gcd\nimport sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\nMOD = 10**9 + 7\nn = int(input())\ncnt = {}\nzero_cnt = 0\nans = 1\n\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if (a, b) == (0, 0):\n        zero_cnt += 1\n        continue\n    g = gcd(abs(a), abs(b))\n#    if a == 0 or b == 0: g = max(abs(a), abs(b))\n    a //= g\n    b //= g\n\n    rotate = 0\n    while not (a > 0 and b >= 0):\n        a, b = -b, a\n        rotate += 1\n    if (a, b) not in cnt:\n        cnt[(a, b)] = [0, 0]\n\n    cnt[(a, b)][rotate%2] += 1\n\nfor key in cnt:\n    A, B = cnt[key]\n    ans *= 1 + pow(2, A, MOD) - 1 + pow(2, B, MOD) - 1\n    ans %= MOD\n\nans += zero_cnt\nans -= 1 #for empty set\nprint((ans % MOD))\n", "# E - Bullet\n\nfrom collections import Counter\nfrom math import gcd\n\nn = int(input())\ncounter = Counter()  # \u5404\u30d9\u30af\u30c8\u30eb\u306e\u500b\u6570\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    if b < 0:\n        a, b = -a, -b  # 180\u5ea6\u56de\u8ee2\u3057\u3066\u7b2c1\u301c2\u8c61\u9650\u306b\n    elif b == 0:\n        a = abs(a)\n    if not a == b == 0:\n        # \u65e2\u7d04\u5316\n        g = gcd(a, b)\n        a //= g\n        b //= g\n    counter[(a, b)] += 1\n\nmodulus = 1000000007\n\nvs = set(counter)\n# \u7b2c2\u8c61\u9650\u306e\u30d9\u30af\u30c8\u30eb\u3068\u76f4\u4ea4\u3059\u308b\u30d9\u30af\u30c8\u30eb\u3092\u8ffd\u52a0\nvs.update((b, -a) for a, b in counter if a <= 0)\n# \u7b2c1\u8c61\u9650\u306e\u30d9\u30af\u30c8\u30eb\u306e\u307f\u62bd\u51fa\nvs = [(a, b) for a, b in vs if a > 0]\n\nncomb = 1  # \u30a4\u30ef\u30b7\u306e\u9078\u3073\u65b9\u306e\u500b\u6570\nfor a, b in vs:\n    # \u4e92\u3044\u306b\u4ef2\u304c\u60aa\u3044\u30a4\u30ef\u30b7\u7fa4\n    n1 = counter[(a, b)]\n    n2 = counter[(-b, a)]\n    # \u305d\u308c\u305e\u308c\u306e\u7fa4\u304b\u3089\u597d\u304d\u306a\u6570\u3060\u3051\u30a4\u30ef\u30b7\u3092\u9078\u3076 (0\u5339\u9078\u3076\u3053\u3068\u3082\u542b\u3080)\n    m = pow(2, n1, modulus) + pow(2, n2, modulus) - 1\n    ncomb = ncomb * m % modulus\n\nncomb -= 1  # 1\u5339\u3082\u9078\u3070\u306a\u3044\u5834\u5408\u3092\u9664\u304f\n\n# (0, 0)\u306e\u30a4\u30ef\u30b7\u30921\u5339\u3060\u3051\u9078\u3076\nncomb += counter[(0, 0)]\n\nprint((ncomb % modulus))\n", "from math import gcd\nfrom collections import defaultdict\n\nN = int(input())\nd = {}\nMOD = 10**9+7\nzall = 0\n\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n\n    if A==0 and B==0:\n        zall += 1\n    else:\n        if A and B:\n            if A<0 and B<0:\n                A *= -1\n                B *= -1\n            elif A<0 and B>0:\n                A *= -1\n                B *= -1\n\n            g = gcd(A, B)\n            A //= g\n            B //= g\n        elif A==0:\n            B = 1\n        elif B==0:\n            A = 1\n        \n        if (A, B) in d:\n            d[(A, B)] += 1\n        else:\n            d[(A, B)] = 1\n\nans = 1\nused = defaultdict(int)\n\nfor (i, j), v in list(d.items()):\n    if used[(i, j)]:continue\n    used[(i, j)] = 1\n    buf = 0\n\n    if j>0:\n        if (j, -i) in d:\n            used[(j, -i)] = 1\n            buf = d[(j, -i)]\n        else:\n            buf = 0\n    else:\n        if (-j, i) in d:\n            used[(-j, i)] = 1\n            buf = d[(-j, i)]\n        else:\n            buf = 0\n\n    ans *= (pow(2, buf, MOD)+pow(2, v, MOD)-1)\n    ans %= MOD\n\nprint(((ans+zall-1)%MOD))\n", "from math import gcd\nMOD = 1000_000_007\n\nN = int(input())\n\nFish = {}\nzeros = 0\n\nfor i in range(N):\n  A, B = list(map(int,input().split())) \n  if A == 0 and B == 0:\n    zeros += 1\n    continue\n  \n  G = gcd(abs(A), abs(B))\n  A, B = A // G, B // G\n  if A < 0:\n    A *= -1\n    B *= -1\n  elif A == 0:\n    B = 1\n    \n  if (A, B) not in Fish:\n    Fish[(A, B)] = 1\n  else:\n    Fish[(A, B)] += 1\n\n#print(Fish)\ndone_set = set()\n\nans = 1\nfor (a, b) in list(Fish.keys()):\n  #print(a,b)\n  if b > 0:\n    c = b\n    d = -a\n  elif b == 0:\n    c = 0\n    d = 1\n  else: \n    c, d = -b, a\n  \n  #print(done_set)\n  #print((a,b), (c,d), done_set)\n  if (a, b) in done_set or (c, d) in done_set: \n    continue\n  #print((a,b), Fish[(a,b)])\n  #print((c,d), Fish[(c,d)])\n  if (c, d) not in list(Fish.keys()):\n    \n    ans *= pow(2, Fish[(a,b)], MOD)\n  else:\n    ans *= (1 + (pow(2, Fish[(a,b)], MOD)-1) + (pow(2, Fish[(c,d)], MOD)-1))  \n    done_set.add((c,d))\n  ans %= MOD\n  \n  #print(done_set, ans)\n  done_set.add((a,b))\n  \nans += zeros\nans -= 1\nans %= MOD\n#print(zeros)\nprint(ans)\n\n  \n", "from collections import Counter\nimport math\nMOD=10**9+7\nN=int(input())\nli=[]\nzcnt=0\naz,bz=0,0\nfor i in range(N):\n    A,B=map(int,input().split())\n    if A==0 and B==0:\n        zcnt+=1\n        continue\n    if A!=0 and B==0:\n        bz+=1\n        continue\n    elif A==0 and B!=0:\n        az+=1\n        continue\n    g=math.gcd(A,B)\n    if A<0 and B<0:\n        li.append((-(A//g),-(B//g)))\n    elif A<0 and B>0:\n        li.append((-(A//g),-(B//g)))\n    else:\n        li.append((A//g,B//g))\nc=Counter(li)\ndic={}\nans=(pow(2,az,MOD)+pow(2,bz,MOD)-1+MOD)%MOD\nfor a,b in c.keys():\n    if (a,b) in dic:\n        continue\n    l,r=(-b,a),(b,-a)\n    s=c.get(l,0)+c.get(r,0)\n    dic[l],dic[r]=1,1\n    res=(pow(2,c[(a,b)],MOD)+pow(2,s,MOD)-1+MOD)%MOD\n    ans=(ans*res)%MOD\nprint((ans-1+zcnt)%MOD)", "import sys\nsys.setrecursionlimit(1000000000)\nimport math\nfrom math import gcd\ndef lcm(a, b): return a * b // gcd(a, b)\nfrom itertools import count, permutations, chain\nfrom functools import lru_cache\nfrom collections import deque, defaultdict\nfrom pprint import pprint\nii = lambda: int(input())\nmis = lambda: list(map(int, input().split()))\nlmis = lambda: list(mis())\nINF = float('inf')\nN1097 = 10**9 + 7\n\ndef meg(f, ok, ng):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if f(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n\ndef get_inv(n, modp):\n    return pow(n, modp-2, modp)\n\ndef factorials_list(n, modp):    # 10**6\n    fs = [1]\n    for i in range(1, n+1):\n        fs.append(fs[-1] * i % modp)\n    return fs\n\ndef invs_list(n, fs, modp):     # 10**6\n    invs = [get_inv(fs[-1], modp)]\n    for i in range(n, 1-1, -1):\n        invs.append(invs[-1] * i % modp)\n    invs.reverse()\n    return invs\n\ndef comb(n, k, modp):\n    num = 1\n    for i in range(n, n-k, -1):\n        num = num * i % modp\n    den = 1\n    for i in range(2, k+1):\n        den = den * i % modp\n    return num * get_inv(den, modp) % modp\n\ndef comb_from_list(n, k, modp, fs, invs):   \n    return fs[n] * invs[n-k] * invs[k] % modp\n\n#\n\nclass UnionFindEx:\n    def __init__(self, size):\n        #\u6b63\u306a\u3089\u6839\u306e\u756a\u53f7\u3001\u8ca0\u306a\u3089\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba\n        self.roots = [-1] * size\n    def getRootID(self, i):\n        r = self.roots[i]\n        if r < 0:   #\u8ca0\u306a\u3089\u6839\n            return i\n        else:\n            r = self.getRootID(r)\n            self.roots[i] = r\n            return r\n    def getGroupSize(self, i):\n        return -self.roots[self.getRootID(i)]\n    def connect(self, i, j):\n        r1, r2 = self.getRootID(i), self.getRootID(j)\n        if r1 == r2:\n            return False\n        if self.getGroupSize(r1) < self.getGroupSize(r2):\n            r1, r2 = r2, r1\n        self.roots[r1] += self.roots[r2]    #\u30b5\u30a4\u30ba\u66f4\u65b0\n        self.roots[r2] = r1\n        return True\n\nYes = 'Yes'\nNo = 'No'\n\n\ndef main():\n    from fractions import Fraction\n    N=ii()\n    zero = 0\n    d = defaultdict(lambda : [0, 0])\n    for _ in range(N):\n        x, y = mis()\n        if x == y == 0:\n            zero += 1\n            continue\n        if y < 0 or (y==0 and x < 0):\n            x, y = -x, -y\n        g = gcd(x, y)\n        x //= g\n        y //= g\n        if x<=0:\n            rot = True\n            c = (y, -x)\n        else:\n            rot = False\n            c = (x, y)\n        d[c][rot] += 1\n    #\n    N -= zero\n    ans = 1\n    for (q1, q2) in list(d.values()):\n        ans *= (pow(2, q1, N1097) - 1) + (pow(2, q2, N1097) - 1) + 1\n        ans %= N1097\n    ans -= 1\n    ans %= N1097\n    print((ans + zero))\n\n\n\n\n\n\nmain()\n\n", "from operator import itemgetter\nfrom math import gcd\nfrom collections import Counter\n\nN = int(input())\nmod = int(1e9+7)\n\nzero = 0\nP = {}\nfor i in range(N):\n  a,b = list(map(int, input().split()))\n  if a == 0 and b == 0:\n    zero += 1\n    continue\n  g = gcd(a,b)\n  a,b = a//g, b//g\n  if b < 0:\n    a,b = -a,-b\n  if b == 0 and a < 0:\n    a,b = -a,b  \n  #rot90\n  rot90 = a<=0\n  if rot90:\n    a,b = b,-a\n  #add\n  if not (abs(a),b) in P:\n    P[(a,b)] = [0,0]\n  if not rot90 :\n    P[(a,b)][0] += 1\n  else:\n    P[(a,b)][1] += 1\n    \nans = 1\nfor k,v in P.items():\n  #print(k,v)\n  s,t = v\n  wk = 1 + pow(2,s,mod) - 1 + pow(2,t,mod) - 1\n  ans *= wk\n  ans %= mod\n  \nans += zero\n\nprint((ans - 1) % mod)", "from math import gcd \nn=int(input())\nmod = 10**9+7\ncount = {}\n\nnum=0\nfor _ in range(n):\n    a,b = map(int,input().split())\n    if a==0 and b==0:\n        num+=1\n        continue\n    if a*b != 0:\n        g=gcd(a,b)*(b//abs(b))\n    elif a != 0:\n        g=a\n    else:\n        g=b\n        \n    l=a//g,b//g\n    count[l]=count.get(l,0)+1\n        \nmem=set()\nans=1\nfor (x,y),z in count.items():\n    if x*y==0:\n        k=(y,x)\n    else:\n        k=(-1*x//abs(x)*y,abs(x))\n    if k in mem:\n        continue\n    mem.add((x,y))\n    ans*=(pow(2,z)+pow(2,count.get(k,0))-1)\n    ans%=mod\n\nprint((ans+num-1)%mod)", "N=int(input())\nfrom collections import defaultdict\ndic=defaultdict(int)\nimport math\nmod=1000000007\nfor _ in range(N):\n    A,B=list(map(int,input().split()))\n    if A<0:\n        A,B=-A,-B\n    if A==0:\n        if B==0:\n            dic[(0,0)]+=1\n        else:\n            dic[(0,-1)]+=1\n    elif B==0:\n        dic[(1,0)]+=1\n    else:\n        gcd=math.gcd(A,B)\n        A,B=A//gcd,B//gcd\n        dic[(A,B)]+=1\n\nans=1\nN-=dic[(0,0)]\nfor k,v in list(dic.items()):\n    if k==(0,0) or k==(0,1):\n        continue\n    a,b=k\n    if not (b,-a) in dic:\n        continue\n    v_dash=dic[(b,-a)]\n    ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n    ans%=mod\n    N-=v+v_dash\nans*=pow(2,N,mod)\nans+=dic[(0,0)]-1\nans%=mod\nprint(ans)\n", "import math\ndef main():\n    N = int(input())\n    d = {}\n    za = zb = zab = r = 0\n    mod = 10**9 + 7\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        if a== 0 and b == 0:\n            zab += 1\n        elif b == 0:\n            zb += 1\n        elif a == 0:\n            za += 1\n        else:\n            if a < 0:\n                a, b = -a, -b\n            x = math.gcd(abs(a), abs(b))\n            d[(a//x, b//x)] = d.get((a//x, b//x), 0) + 1\n    used = set()\n    l = []\n    for x in d:\n        if x in used:\n            continue\n        a, b = x[0], x[1]\n        used.add(x)\n        if a * b > 0:\n            t = (abs(b), -abs(a))\n        else:\n            t = (abs(b), abs(a))\n        used.add(t)\n        l.append((d[x], d.get(t, 0)))\n    r = pow(2, za) + pow(2, zb) - 1\n    for i in l:\n        r *= (pow(2, i[0]) + pow(2, i[1]) - 1)\n        r %= mod\n    return (r - 1 + zab) % mod\nprint((main()))\n", "from collections import defaultdict\nfrom math import gcd\nN = int(input())\nMOD = 10**9 + 7\nL = defaultdict(lambda: [0,0])\nzero = 0\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n    if A==0: d=B\n    elif B==0: d=A\n    else: d=gcd(A,B)\n    if d != 0:\n        A, B = A//d, B//d\n        if A<0: A, B = -A, -B\n        if B>0: L[(A,B)][0] += 1\n        else: L[(-B,A)][1] += 1\n    else: zero += 1\n\nres = 1\n\nfor x,y in list(L.values()):\n    res *= pow(2,x,MOD) + pow(2,y,MOD) -1\n    res %= MOD\nprint(((res+zero-1)%MOD))\n\n", "from math import gcd\n \nn=int(input())\nmod = 10**9+7\n \nd = dict()\nzeros=0\nfor _ in range(n):\n  a,b=map(int,input().split())\n  if not any((a,b)):\n    zeros+=1\n    continue\n  if all((a,b)):\n    g = gcd(a,b)*(a//abs(a))\n  elif a:\n    g = a\n  else:\n    g = b\n  \n  p = a//g,b//g\n  d[p] = d.get(p,0)+1\n \nans = 1\ndone = set()\nfor (a,b),v in d.items():\n  if (-b,a) in done or (b,-a) in done:\n    continue\n  done.add((a,b))\n  w=d.get((-b,a),0)+d.get((b,-a),0)\n  ans *= (pow(2,v,mod)+pow(2,w,mod)-1)\n  ans %= mod\nprint((ans+zeros-1+mod)%mod)", "from collections import defaultdict\nimport math\n\nN = int(input())\nm = defaultdict(lambda : 0)\nBIG_NUMBER = 1000000007\nbad_iwashi_count = 0\n\nfor _ in range(N):\n    A,B = map(int,input().split())\n    #0\u306e\u5834\u5408\n    if A == 0 and B == 0:\n        bad_iwashi_count += 1\n        continue\n    if A == 0:\n        m[(-1,0,1)]+=1\n        continue\n    if B == 0:\n        m[(1,1,0)]+=1\n        continue\n    #0\u4ee5\u5916\n    gcd_ = math.gcd(A,B)\n    A = A//gcd_\n    B = B//gcd_\n    if A < 0 and B > 0: m[(-1,-A,B)]+=1\n    elif B < 0 and A > 0: m[(-1,A,-B)]+=1\n    elif A < 0 and B < 0 :m[(1,-A,-B)]+=1\n    elif A > 0 and B > 0 :m[(1,A,B)]+=1\n\ntotal = 1\nfor key in list(dict(m).keys()):\n    total *= pow(2,m[key],BIG_NUMBER) + pow(2,m[-key[0],key[2],key[1]],BIG_NUMBER) -1\n    total %= BIG_NUMBER\n    m.pop(key)\n    m.pop((-key[0],key[2],key[1]))\nprint((total+bad_iwashi_count-1)%BIG_NUMBER)\n\n'''\n3\n1 2\n-1 1\n2 -1\n'''", "import math\n\nN = int(input())\nAB = [list(map(int, input().split())) for _ in range(N)]\n\nMOD = 1000000007\n\ndic1 = {}\na_zero = 0\nb_zero = 0\nboth_zero = 0\n\nfor a, b in AB:\n    if a == 0 and b != 0:\n        a_zero += 1\n    elif a != 0 and b == 0:\n        b_zero += 1\n    elif a == 0 and b == 0:\n        both_zero += 1\n    else:\n        g = math.gcd(a, b)\n        a //= g\n        b //= g\n\n        if b < 0:\n            a, b = -a, -b\n\n        if (a, b) in dic1:\n            dic1[(a, b)] += 1\n        else:\n            dic1[(a, b)] = 1\n\npair = []\nused = set()\n\nfor key, val in list(dic1.items()):\n    if key in used:\n        continue\n\n    a, b = key\n    used.add((a, b))\n    cnt = 0\n\n    if a < 0:\n        c, d = -b, -a\n    else:\n        c, d = b, a\n\n    if (-c, d) in dic1:\n        cnt += dic1.get((-c, d), 0)\n        used.add((-c, d))\n\n    pair.append((val, cnt))\n\n\nall_cnt = 1\nfor cnt1, cnt2 in pair:\n    all_cnt *= pow(2, cnt1, MOD) + pow(2, cnt2, MOD) - 1\n    all_cnt %= MOD\n\nall_cnt *= pow(2, a_zero, MOD) + pow(2, b_zero, MOD) - 1\nall_cnt %= MOD\n\nall_cnt += both_zero\nall_cnt %= MOD\n\nprint(((all_cnt - 1) % MOD))\n", "from math import gcd\n\nN = int(input())\nAB = [list(map(int, input().split())) for _ in range(N)]\n\nm = 1000000007\n\nt = []\nd = {}\nd[0] = {}\nd[0][0] = 0\nfor a, b in AB:\n    i = gcd(a, b)\n    if i != 0:\n        a //= i\n        b //= i\n    t.append((a, b))\n    d.setdefault(a, {})\n    d[a].setdefault(b, 0)\n    d[a][b] += 1\n\nused = set()\nresult = 1\nfor a, b in t:\n    if (a, b) in used:\n        continue\n    used.add((a, b))\n    if a == 0 and b == 0:\n        continue\n    i = d[a][b]\n    j, k, l = 0, 0, 0\n    if -a in d and -b in d[-a]:\n        j = d[-a][-b]\n        used.add((-a, -b))\n    if -b in d and a in d[-b]:\n        k = d[-b][a]\n        used.add((-b, a))\n    if b in d and -a in d[b]:\n        l = d[b][-a]\n        used.add((b, -a))\n    result *= pow(2, i + j, m) + pow(2, k + l, m) - 1\n    result %= m\nresult += d[0][0] - 1\nresult %= m\nprint(result)\n", "# \u7d04\u5206\u3057\u3066\u3001\u4e92\u3044\u306b\u7d20\u306a(1,3) (3,1)\u306e\u3088\u3046\u306a\u30da\u30a2\u3092\u4f5c\u308a\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n# \u6b63\u306e\u30b0\u30eb\u30fc\u30d7\u3068\u8ca0\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u5225\u3005\u306b\u7ba1\u7406\n# \u6b63\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u76f8\u624b\u304c\u8ca0\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5b58\u5728\u3057\u305f\u5834\u5408\u3001\n# \u3069\u3061\u3089\u304b\u306e\u30b0\u30eb\u30fc\u30d7\u304b\u3089\u597d\u304d\u306a\u3060\u3051\u9078\u3076\u304b\u3001\u3069\u3061\u3089\u3082\u9078\u3070\u306a\u3044\u304b\u3057\u304b\u306a\u3044\n# \u8ab0\u3068\u3082\u30da\u30a2\u306b\u306a\u3089\u306a\u304b\u3063\u305f\u30b0\u30eb\u30fc\u30d7\u306e\u500b\u6570\u3092\u5168\u3066\u8db3\u3057\u3066P\u500b\u3060\u3068\u3057\u3066\u30012^P\u901a\u308a\u3092\u639b\u3051\u308b\n# (0,0)\u306b\u3064\u3044\u3066\u306f\u3001\u305d\u306e\u4e2d\u304b\u30891\u3064\u9078\u3076\u304b\u3001\u9078\u3070\u306a\u3044\u304b\u3057\u304b\u306a\u3044\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nimport math\n\nzeropair = 0\nzeroa = 0\nzerob = 0\nfrom collections import defaultdict\npluspair = defaultdict(int)\nminuspair = defaultdict(int)\nfor i in range(N):\n  a,b = map(int,readline().split())\n  if a == 0 and b == 0:\n    zeropair += 1\n    continue\n  if a == 0:\n    zeroa += 1\n    continue\n  if b == 0:\n    zerob += 1\n    continue\n  absa = abs(a)\n  absb = abs(b)\n  g = math.gcd(absa,absb)\n  absa,absb = absa//g,absb//g\n  if a * b > 0:\n    pluspair[(absa,absb)] += 1\n  else:\n    minuspair[(absa,absb)] += 1\n\nDIV = 1000000007\nans = 1\n# zeroa,zerob\u304b\u3089\u9078\u3076\u30d1\u30bf\u30fc\u30f3\u306f\u3001\u3069\u3061\u3089\u304b\u3089\u597d\u304d\u306a\u3060\u3051\u9078\u3076\u304b\u3001\u3069\u3061\u3089\u3082\u9078\u3070\u306a\u3044\u304b\nans *= (pow(2,zeroa,DIV) + pow(2,zerob,DIV) - 1) % DIV\nans %= DIV\n\n# \u8ab0\u3068\u3067\u3082\u30da\u30a2\u306b\u306a\u308c\u308b\u3082\u306e\u3092\u30ab\u30a6\u30f3\u30c8\nallcnt = 0\n\n# plus\u304b\u3089\u9078\u3076\u30d1\u30bf\u30fc\u30f3\u3067\u3001minus\u306b\u3042\u308b\u5bfe\u5fdc\u30da\u30a2\u3092\u63a2\u3059\nfor item in pluspair.items():\n  a,b = item[0]\n  cnt = item[1]\n  if (b,a) in minuspair:\n    ans *= (pow(2,cnt,DIV) + pow(2,minuspair[(b,a)]) - 1) % DIV\n    ans %= DIV\n    del minuspair[(b,a)]\n  else:\n    allcnt += cnt\n\nfor val in minuspair.values():\n  allcnt += val\n\nans = (ans * pow(2,allcnt,DIV)) % DIV\n# zeropair\u304b\u3089\u9078\u3093\u3060\u5834\u5408\u3001\u4eca\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u3068\u306f\u72ec\u7acb\nans += zeropair\nprint((ans - 1) % DIV)", "import sys, bisect, collections, math\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\nMOD = 1000000007\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    N = I()\n    AB = [LI() for _ in range(N)]\n\n    # A, B\u3092\u6a19\u6e96\u5316 \u4e92\u3044\u306b\u758e\u3067A\u306f\u6b63\n    def normalize(AB):\n        A = AB[0]\n        B = AB[1]\n        if A==B==0:\n            return (0, 0)\n        elif A==0:\n            return(0, 1)\n        elif B==0:\n            return(1, 0)\n        else:\n            gcd = math.gcd(A, B)\n            A //= gcd\n            B //= gcd\n            if A<0:\n                A, B = -A, -B\n            return (A, B)\n    \n    def orthogonal(AB):\n        A = AB[0]\n        B = AB[1]\n        if B>0:\n            return (B, -A)\n        else:\n            return(-B, A)\n\n    AB_n = [normalize(i) for i in AB]\n    counter = collections.Counter(AB_n)\n\n    # \u5834\u5408\u306e\u6570\u3092\u6c42\u3081\u308b\n    used = set()\n    ans = 1\n    # (0, 0)\u4ee5\u5916\u306b\u3064\u3044\u3066\n    for A, B in AB_n:\n        if not (A, B) in used:\n            if (A, B)!=(0, 0):\n                ans *= pow(2, counter[(A, B)], MOD) + pow(2, counter[orthogonal((A, B))], MOD) - 1\n                ans %= MOD\n                used.add((A, B))\n                used.add(orthogonal((A, B)))\n    ans -= 1\n    # (0, 0)\u306b\u3064\u3044\u3066\n    ans += counter[(0, 0)]\n    ans %= MOD\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from math import gcd\n\nn = int(input())\nMOD = 10**9 + 7\ncnt = {}\nzero_cnt = 0\nans = 1\n\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    if (a,b) == (0,0):\n        zero_cnt += 1\n        continue\n    g = gcd(abs(a), abs(b))\n    a //= g\n    b //= g\n    rotate = 0\n    while not (a >= 0 and b > 0):\n        a,b = -b,a\n        rotate += 1\n    if (a,b) not in cnt:\n        cnt[(a,b)] = [0,0]\n    cnt[(a,b)][rotate % 2] += 1\n \nfor key in cnt:\n    A, B = cnt[key]\n    ans *= 1 + pow(2, A, MOD) - 1 + pow(2, B, MOD) - 1\n    ans %= MOD\n \nans += zero_cnt\nans -= 1\nprint((ans % MOD))\n\n\n", "import math\nN=int(input())\nMOD=10**9+7\nfish={}\nans=1\na=0\nb=0\nw=0\nfor i in range(N):\n    A,B=map(int,input().split())\n    if A==0 and B==0:\n        w+=1\n    elif A==0:\n        a+=1\n    elif B==0:\n        b+=1\n    else:\n        c=math.gcd(A,B)\n        A=A//c\n        B=B//c\n        if B<0:\n            A,B=-A,-B\n        k=(A,B)\n        if not k in fish:\n            fish[k]=0\n        fish[k]+=1\ngroup=set()\nfor (p,q),v in fish.items():\n    invp,invq=-q,p\n    if invq<0:\n        invp,invq=-invp,-invq\n    if not (invp,invq) in group:\n        group.add((p,q))\nfor p,q in group:\n    invp,invq=-q,p\n    if invq<0:\n        invp,invq=-invp,-invq\n    t=2**fish[p,q]\n    if (invp,invq) in fish:\n        t+=2**fish[invp,invq]-1\n    ans=(ans*t)%MOD\nans*=2**a+2**b-1\nans=ans+w-1\nprint(ans%MOD)", "#!/usr/bin/env python3\nimport math\n\nn = int(input())\n\nmod = 10**9+7\n\ndata = {}\nzero_zero = 0\n\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    # # print(a, b)\n    if a == 0 and b == 0:\n        zero_zero += 1\n        continue\n    gcd = math.gcd(a, b)\n    a, b = a//gcd, b//gcd\n    if a < 0:\n        a, b = -a, -b\n\n    if a == 0:  # (0, 1)\n        a, b = 0, 1\n\n    elif b == 0:  # (1, 0)\n        a, b = 1, 0\n\n    # print(a, b)\n    # print()\n\n    if b <= 0:  # (+, -) or (1, 0)\n        if (-b, a) in data:\n            data[(-b, a)][1] += 1\n        else:\n            data[(-b, a)] = [0, 1]\n    elif b > 0:  # (+, +) or (1, 0)\n        if (a, b) in data:\n            data[(a, b)][0] += 1\n        else:\n            data[(a, b)] = [1, 0]\n\n# print(data)\n# print(zero_zero)\n\npower_2 = [1]\nfor i in range(1, 2*10**5+100):\n    power_2.append(power_2[i-1]*2 % mod)\n\nans = 1\n# print(ans)\n# print()\nfor (a, b), (l, m) in list(data.items()):\n    ans *= (power_2[l]+power_2[m]-1) % mod\n    # print(power_2[l]+power_2[m]-1)\n    # print(ans)\n    # print()\n\nans = ans - 1  # removed not selected\nans += zero_zero\nprint((ans % mod))\n# count_pp = 0\n# count_pm = 0\n# ans = 0\n# while(1):\n#     pp_tmp = plus_plus[count_pp]\n#     pm_tmp = plus_minus[count_pm]\n\n#     print(\"pp_tmp\", pp_tmp)\n#     print(\"pm_tmp\", pm_tmp)\n\n#     if pp_tmp[0]*pm_tmp[0] + pp_tmp[1]*pm_tmp[1] == 0:\n#         pp_mag, pm_mag = 1, 1  # magnitude\n#         while(1):\n#             if count_pp < len(plus_plus)-1:\n#                 if plus_plus[count_pp] == plus_plus[count_pp+1]:\n#                     pp_mag += 1\n#                     count_pp += 1\n#                 else:\n#                     break\n#             else:\n#                 break\n#         while(1):\n#             if count_pm < len(plus_minus)-1:\n#                 if plus_minus[count_pm] == plus_minus[count_pm+1]:\n#                     pm_mag += 1\n#                     count_pm += 1\n#                 else:\n#                     break\n#             else:\n#                 break\n#         ans += pp_mag*pm_mag\n\n#     elif pp_tmp[2]*pm_tmp[2] > -1:\n#         count_pp += 1\n\n#     elif pp_tmp[2]*pm_tmp[2] < -1:\n#         count_pm += 1\n\n#     if count_pp == len(plus_plus)-1:\n#         break\n#     if count_pm == len(plus_minus)-1:\n#         break\n#     print(1)\n\n# ans += zero_zero\n# n = n - zero_zero\n# count = ((n % mod) * ((n-1) % mod))//2\n# count -= (negative) % mod\n\n# print(count % mod)\n", "from collections import defaultdict\nfrom math import gcd\nC = defaultdict(lambda: 0)\nfor i in range(int(input())):\n    x, y = list(map(int, input().split()))\n    g = max(gcd(x, y), 1)\n    x, y = x // g, y // g\n    if y < 0 or (x == -1 and y == 0):\n        x, y = -x, -y\n    C[(x, y)] += 1\nS = set()\nfor x, y in C:\n    if x > 0 and y >= 0:\n        S.add((x, y))\n    if x <= 0 and y > 0:\n        S.add((y, -x))\nans = 1\np = 10**9 + 7\nfor x, y in S:\n    ans *= pow(2, C[(x, y)], p) + pow(2, C[(-y, x)], p) - 1\n    ans %= p\nprint(((ans + C[(0, 0)] - 1) % p))\n", "from collections import defaultdict\nimport math\nimport sys\ninput = sys.stdin.readline\n\n\ndef select_num(a, b, mod=1000000007):\n    sum = pow(2, a, mod) + pow(2, b, mod) - 1\n    return sum % mod\n\n\ndef dict_count(d, a, b):\n    this = a / b\n    pair = b / a\n    if not d.get(this, False):\n        d[this] = {\"num\": 0, \"pair\": pair}\n    d[this][\"num\"] += 1\n\n\ndef main():\n    MOD = 1000000007\n    n = int(input())\n\n    d = defaultdict(lambda: [0] * 2)\n    zero = 0\n    for i in range(n):\n        a, b = map(int, input().split())\n        if a == 0 or b == 0:\n            if a == b == 0:\n                n -= 1\n                zero += 1\n            elif a == 0:\n                d[0][True] += 1\n            elif b == 0:\n                d[0][False] += 1\n\n        else:\n            gcd = math.gcd(a, b)\n            a //= gcd\n            b //= gcd\n\n            if b < 0:\n                a, b = -a, -b\n\n            rot = False\n            if a < 0:\n                b, a = -a, b\n                rot = True\n            d[(a, b)][rot] += 1\n\n    ans = 1\n    for k, v in d.items():\n        ans *= select_num(v[0], v[1], MOD)\n        ans %= MOD\n\n    ans += zero - 1\n    ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import gcd\nfrom collections import defaultdict\nmod = 10**9+7\n_, *S = open(0)\nmp = defaultdict(lambda: [0, 0])\nO = 0\nfor s in S:\n    a, b = list(map(int, s.split()))\n    if a == b == 0:\n        O += 1\n    else:\n        g = gcd(a, b)\n        a //= g\n        b //= g\n        if a < 0 or a == 0 < b:\n            a, b = -a, -b\n        f = 0\n        if b < 0:\n            a, b, f = -b, a, 1\n        mp[(a, b)][f] += 1\nans = 1\nfor k in mp:\n    x, y = mp[k]\n    ans = ans*(pow(2, x, mod)+pow(2, y, mod)-1) % mod\nprint(((ans+O-1) % mod))\n", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\np = 10**9+7\nfrom math import gcd\nfrom collections import Counter\nfrom collections import defaultdict\nused = defaultdict(list)\n\nn = int(input())\n\nctr = Counter()\naz = bz = zz = 0\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    if a==b==0:\n        zz+=1\n    elif a==0:\n        az+=1\n    elif b==0:\n        bz+=1\n    else:\n        g = gcd(a,b)\n        a,b = a//g, b//g\n        if b < 0:\n            a*=-1\n            b*=-1\n        ctr[(a,b)]+=1\n        used[(a,b)]=False\n\nans = 1\n\n# \u4ef2\u306e\u60aa\u3044\u30b0\u30eb\u30fc\u30d7\u5bfe\u3054\u3068\u306b\u51e6\u7406\u3059\u308b\nfor (a1,b1),v1 in list(ctr.items()):\n    if used[(a1,b1)]:\n        continue\n    a2,b2=-b1,a1\n    if b2 < 0:\n        b2*=-1\n        a2*=-1\n    v2 = ctr[(a2,b2)]\n\n    r = (pow(2,v1,p)+pow(2,v2,p)-1)%p\n    ans*=r\n    ans%=p\n    used[(a1,b1)]=True\n    used[(a2,b2)]=True\n\n# \u7247\u65b9\u304c0\u306e\u30af\u30eb\u30fc\u30d7\u5bfe\nr = (pow(2,az,p)+pow(2,bz,p)-1)%p\nans*=r\nans%=p\n\nans+=zz # 0\u5339\u306e\u30b1\u30fc\u30b9\u306f\u7981\u6b62\u3055\u308c\u3066\u3044\u308b\nans-=1 # 0\u5339\u306e\u30b1\u30fc\u30b9\u306f\u7981\u6b62\u3055\u308c\u3066\u3044\u308b\nans%=p\nprint(ans)\n\n", "from math import gcd\nmod = 1000000007\nn = int(input())\nzero = 0\nbad = {}\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    if x == 0 and y == 0:\n        zero += 1\n        continue\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    if y < 0: x, y = -x, -y\n    if y==0 and x<0: x, y = -x, -y\n    is_rotate90 = (x <= 0)\n    if is_rotate90:\n        x, y = y, x\n        y = -y\n    if not (x, y) in bad:\n        bad[x, y] = [0, 0]\n    if is_rotate90:\n        bad[x, y][0] += 1\n    else:\n        bad[x, y][1] += 1\n\n# print(bad)\n\ncnt = 1\nfor x, y in bad:\n    c1, c2 = bad[x, y]\n    c3 = 1\n    c3 += pow(2, c1, mod) - 1\n    c3 += pow(2, c2, mod) - 1\n    cnt = cnt * c3 % mod\n\nans = (cnt + zero - 1) % mod\n\n# print('cnt',cnt)\n# print('zero',zero)\n# print('ans',ans)\nprint(((ans+mod) % mod))\n", "\nfrom fractions import Fraction\nfrom collections import defaultdict\ndef resolve():\n    # A1*A2 + B1*B2 = 0 \u5f0f\u5909\u5f62 A1/B1 = -(B2/A2)\n    # a, b \u306e0\u304c\u3042\u308b\u6761\u4ef6\u3092\u8003\u3048\u308b\n    \n    MOD = 1000000007\n    N = int(input())\n    zeroes = 0\n    hash1 = defaultdict(int) #\n    hash2 = defaultdict(str) #\u4e2d\u306e\u60aa\u3044\u76f8\u624b\u3092\u8a18\u5165\n    for _ in range(N):\n        a, b = map(int, input().split())\n        if a==0 and b==0:\n            zeroes += 1\n        elif b == 0:\n            hash1[\"1/0\"] += 1\n            hash2[\"1/0\"] = \"0/1\"\n        elif a == 0:\n            hash1[\"0/1\"] += 1\n            hash2[\"0/1\"] = \"1/0\"\n        else: # a, b\u304c0\u4ee5\u5916\n            rat1 = Fraction(a, b)\n            rat2 = Fraction(-b, a)\n            hash1[str(rat1)] += 1\n            hash2[str(rat1)] = str(rat2) # \u76f8\u624b\u3092\u5165\u308c\u308b\n\n    confirmed = set()\n    ans = 1\n    for k, v in hash1.items():\n        if k in confirmed: # \u78ba\u8a8d\u6e08\u307f\u3092\u6570\u3048\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n            continue\n        bad = hash1.get(hash2[k], 0) # \u4e2d\u306e\u60aa\u3044\u76f8\u624b, \u30ad\u30fc\u304c\u306a\u304b\u3063\u305f\u30890\u3092\u51fa\u529b\n        cnt1 = pow(2, v, MOD) - 1\n        cnt2 = pow(2, bad, MOD) - 1\n        ans = (ans * (cnt1 + cnt2 + 1)) % MOD\n        # \u78ba\u8a8d\u6e08\u307f\u306b\u3059\u308b\n        confirmed.add(k)\n        confirmed.add(hash2[k])\n        # \u203b \u30eb\u30fc\u30d7\u4e2d\u306b\u5024\u3092\u5909\u66f4\u3057\u305f\u3089\u30a8\u30e9\u30fc\n        # hash1[k] = -1\n\n    ans = (ans + zeroes + MOD -1) % MOD\n    print(ans)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "from math import gcd\nfrom collections import Counter\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\ndef std(a, b):\n    if a == 0:\n        return (0, int(b != 0))\n\n    g = gcd(a, b)\n    a, b = a // g, b // g\n    return (a, b) if a > 0 else (-a, -b)\n\nC = Counter()\nfor a, b in zip(*[iter(AB)] * 2):\n    C[std(a, b)] += 1\n\nans = 1\ncnt = 0\nfor (a, b), v in C.items():\n    if b > 0:\n        if (b, -a) in C:\n            ans *= -1 + pow(2, v, mod) + pow(2, C[(b, -a)], mod)\n            ans %= mod\n        else:\n            cnt += v\n    elif (-b, a) not in C:\n        cnt += v\n\nans *= pow(2, cnt, mod)\nans += C[(0, 0)] - 1\n\nprint(ans % mod)", "from math import gcd\nfrom collections import defaultdict as d\nn=int(input())\nm=10**9+7\ns=d(lambda:[0,0])\np=-1\nfor i in range(n):\n    a,b=map(int,input().split())\n    if a==b==0:p+=1\n    else:\n        g=gcd(a,b)\n        a=a//g\n        b=b//g\n        if a<0 or a==0<b:a,b=-a,-b\n        if b<0:s[(-b,a)][1]+=1\n        else:s[(a,b)][0]+=1\nq=1\nfor i in s:\n    k,l=s[i]\n    q=q*(pow(2,k,m)+pow(2,l,m)-1)%m\nprint((q+p)%m)", "from math import gcd\nmod = 1000000007\nn = int(input())\nzero = 0\nbad = {} # \u4ef2\u304c\u60aa\u3044\u8005\u540c\u58eb\u3092\u30b0\u30eb\u30fc\u30d7\u5316\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    if x == 0 and y == 0:\n        zero += 1 # (A,B) = (0,0) \u306e\u8a08\u6570\u3092\u3068\u308b\n        continue\n    g = gcd(x, y)\n    x //= g # \u30d9\u30af\u30c8\u30eb\u3092\u6574\u6570\u306e\u7bc4\u56f2\u3067\u6700\u5c0f\u5316\u3057\u3001\n    y //= g # \u50be\u304d\u3092\u65e2\u7d04\u5206\u6570 (y'/x') \u306e\u5f62\u306b\u3059\u308b\n    # \u30d9\u30af\u30c8\u30eb\u30920\u2266\u03b8\uff1c\u03c0\u306e\u7bc4\u56f2\u306b\u5909\u63db\u3059\u308b\n    if y < 0: x, y = -x, -y # \u7b2c3~4\u8c61\u9650\u306e\u30d9\u30af\u30c8\u30eb\u306f\u03c0\u56de\u8ee2\n    if y==0 and x<0: x, y = -x, -y # \u03b8=\u03c0\u306e\u30d9\u30af\u30c8\u30eb\u306f\u03b8=0\u3078\n    # \u03c0/2\u2266\u03b8\uff1c\u03c0\u306f\u3001\u03c0/2\u56de\u8ee2\u3057\u3066\u540c\u3058\u30ad\u30fc\u306b\u3059\u308b\n    is_rotate90 = (x <= 0)\n    if is_rotate90: x, y = y, -x # \u03c0/2\u56de\u8ee2\n    if not (x, y) in bad: bad[x, y] = [0, 0]\n    # \u03c0/2\u56de\u8ee2\u3057\u305f\u3082\u306e\u3001\u3057\u3066\u306a\u3044\u3082\u306e\u306f\u5225\u306b\u8a08\u6570\u3092\u3068\u308b\n    bad[x, y][is_rotate90] += 1\n\nans = 1 # \u7d44\u307f\u5408\u308f\u305b\u3092\u639b\u3051\u3066\u3044\u304f\u306e\u3067 1 \u304b\u3089\nfor x, y in bad:\n    c1, c2 = bad[x, y]\n    # c1, c2 \u4e21\u65b9\u9078\u629e\u306f\u4ef2\u304c\u60aa\u3044\u306e\u3067\u3067\u304d\u306a\u3044\n    # c1 \u306e\u5074\u306e\u307f\u3092 1 \u500b\u4ee5\u4e0a\u9078\u629e\u3059\u308b\n    # c2 \u306e\u5074\u306e\u307f\u3092 1 \u500b\u4ee5\u4e0a\u9078\u629e\u3059\u308b\n    # c1, c2 \u3069\u3061\u3089\u3082\u9078\u629e\u3057\u306a\u3044\n    c3 = (pow(2, c1, mod) - 1) + (pow(2, c2, mod) - 1) + 1\n    ans *= c3\n    ans %= mod\n\n# (A,B)=(0,0)\u306f\u3001\u5358\u72ec\u3067\u3057\u304b\u9078\u629e\u3067\u304d\u306a\u3044\u306e\u3067\u3001+zero \u3059\u308b\n# \u5168\u3066\u672a\u9078\u629e\u306f\u3067\u304d\u306a\u3044\u306e\u3067\u3001-1 \u3059\u308b\nans += zero - 1\nans = (ans + mod) % mod # \u8ca0\u6570\u5bfe\u5fdc\nprint(ans)\n", "from collections import defaultdict\nimport math\n\n\ndef main():\n    n = int(input())\n    mod = 1000000007\n    zeroes = 0\n    counter1 = defaultdict(int)\n    counter2 = defaultdict(int)\n    for _ in range(n):\n        x, y = [int(x) for x in input().split()]\n\n        if x == y == 0:\n            zeroes += 1\n            continue\n\n        denominator = math.gcd(x, y)\n        x, y = x // denominator, y // denominator\n\n        if y < 0:\n            # quadrant III, IV -> I, II\n            x, y = -x, -y\n\n        if x <= 0:\n            # round 90\u00b0 from quadrant II to I\n            x, y = y, -x\n            counter2[(x, y)] += 1\n            counter1[(x, y)] += 0\n        else:\n            counter1[(x, y)] += 1\n            counter2[(x, y)] += 0\n\n    ans = 1\n    for k, v in list(counter1.items()):\n        now = 1\n        now += pow(2, v, mod) - 1\n        now += pow(2, counter2[k], mod) - 1\n        ans = ans * now % mod\n    ans += zeroes\n    ans -= 1  # choose no fish\n    return ans % mod\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "from collections import defaultdict\nfrom math import gcd\n\nMOD = 1000000007\nN = int(input())\nzeros = 0\nbads = defaultdict(lambda: [0, 0])\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    # \u4e21\u65b9\u30bc\u30ed\u306e\u6642\u306e\u4f8b\u5916\u51e6\u7406\n    if x == 0 and y == 0:\n        zeros += 1\n        continue\n    # 180\u5ea6\u56de\u8ee2\n    if y < 0 or (y == 0 and x < 0):\n        x, y = -x, -y\n    g = gcd(x, y)\n    x, y = x // g, y // g\n    if x > 0:\n        bads[(x, y)][0] += 1\n    else:\n        bads[(y, -x)][1] += 1\n\nans = 1\nfor k, l in list(bads.values()):\n    ans *= (pow(2, k, MOD) - 1) + (pow(2, l, MOD) - 1) + 1\n    ans %= MOD\nprint(((ans + zeros - 1) % MOD))\n", "import math\n\nN = int(input())\nAB = [list(map(int, input().split())) for _ in range(N)]\n\nMOD = 1000000007\n\ndic1 = {}\na_zero = 0\nb_zero = 0\nboth_zero = 0\n\nfor a, b in AB:\n    if a == 0 and b != 0:\n        a_zero += 1\n    elif a != 0 and b == 0:\n        b_zero += 1\n    elif a == 0 and b == 0:\n        both_zero += 1\n    else:\n        g = math.gcd(a, b)\n        a //= g\n        b //= g\n\n        if b < 0:\n            a, b = -a, -b\n\n        if (a, b) in dic1:\n            dic1[(a, b)] += 1\n        else:\n            dic1[(a, b)] = 1\n\npair = []\nused = set()\n\nfor key, val in list(dic1.items()):\n    if key in used:\n        continue\n\n    a, b = key\n    used.add((a, b))\n    cnt = 0\n\n    if a < 0:\n        c, d = -b, -a\n    else:\n        c, d = b, a\n\n    if (-c, d) in dic1:\n        cnt += dic1.get((-c, d), 0)\n        used.add((-c, d))\n\n    pair.append((val, cnt))\n\n\nall_cnt = 1\nfor cnt1, cnt2 in pair:\n    all_cnt *= pow(2, cnt1, MOD) + pow(2, cnt2, MOD) - 1\n    all_cnt %= MOD\n\nif a_zero != 0 or b_zero != 0:\n    all_cnt *= pow(2, a_zero, MOD) + pow(2, b_zero, MOD) - 1\n    all_cnt %= MOD\n\nall_cnt += both_zero\nall_cnt %= MOD\n\nprint(((all_cnt - 1) % MOD))\n", "from math import gcd\n \nN = int(input())\nmod = 10 ** 9 + 7 # 1000000007\n \nd = dict()\nzeros = 0\nfor _ in range(N):\n  a, b = map(int, input().split()) # Ai, Bi\n  # \u3069\u3061\u3089\u304b\u4e00\u65b9\u3067\u30820\u3067\u3042\u308c\u3070\u7279\u6b8a\u306a\u30b1\u30fc\u30b9\u3068\u306a\u308b\n  # \u4e0b\u8a18\u306ed[p]\u3067d[(0, 0)]\u306e\u3088\u3046\u306a\u5f62\u306b\u306a\u308b\u305f\u3081\u5206\u3051\u308b(zeros)\n  # d[(0, 0)]\u540c\u58eb\u3067\u306f\u7d44\u307f\u5408\u308f\u305b\u304c\u4f5c\u308c\u306a\u3044\u305f\u3081\u3001\u5358\u7d14\u306b+1\u3057\u3066\u3044\u304f\n  if not any((a,b)):\n    zeros += 1\n    continue\n  if all((a, b)):\n    g = gcd(a, b) * (a//abs(a)) # //\u306f\u5207\u308a\u6368\u3066\u9664\u7b97\n  elif a:\n    g = a\n  else:\n    g = b\n  p = a//g, b//g # p is (tuple)\n  d[p] = d.get(p, 0) + 1 # count\n\nans = 1 # \u639b\u3051\u7b97\u3059\u308b\u305f\u30810\u3067\u306f\u306a\u304f1\u3068\u3057\u3066\u304a\u304d\u3001\u6700\u5f8c\u306e\u51fa\u529b\u6642\u306b1\u3092\u5f15\u304f\u3088\u3046\u306b\u3059\u308b\ndone = set()\nfor (a,b), val in d.items():\n  if (-b, a) in done or (b, -a) in done: # if already counted, then continue\n    continue\n  done.add((a, b))\n  w = d.get((-b, a), 0) + d.get((b, -a), 0)\n  # (a, b)\u3068\u305d\u308c\u306b\u5782\u76f4\u306a(-b, a), (b, -a)\u306e\u305d\u308c\u305e\u308c\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u8db3\u3059\n  # \u305d\u3057\u3066\u4f55\u3082\u9078\u3070\u306a\u304b\u3063\u305f\u3068\u304d\u306e\u5834\u5408\u3092\u5f15\u304f\u305f\u3081\u3001\u6700\u5f8c\u306b-1\u3068\u3059\u308b\n  ans *= (pow(2, val) + pow(2, w) -1)\n  ans %= mod\n\nprint((ans + zeros -1) % mod)", "from collections import deque\nfrom math import gcd\nimport sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\nMOD = 10**9 + 7\nn = int(input())\ncnt = {}\nzero_cnt = 0\nans = 1\n\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if (a, b) == (0, 0):\n        zero_cnt += 1\n        continue\n    g = gcd(abs(a), abs(b))\n    if a == 0 or b == 0: g = max(abs(a), abs(b))\n    a //= g\n    b //= g\n\n    rotate = 0\n    while not (a > 0 and b >= 0):\n        a, b = -b, a\n        rotate += 1\n    if (a, b) not in cnt:\n        cnt[(a, b)] = [0, 0]\n\n    cnt[(a, b)][rotate%2] += 1\n\nfor key in cnt:\n    A, B = cnt[key]\n    ans *= 1 + pow(2, A, MOD) - 1 + pow(2, B, MOD) - 1\n    ans %= MOD\n\nans += zero_cnt\nans -= 1 #for empty set\nprint((ans % MOD))\n", "# -*- coding: utf-8 -*-\n\nN = int(input().strip())\nAB_list = [list(map(int, input().rstrip().split())) for i in range(N)]\n\n#-----\ndef gcd(a,b):\n    if b == 0: \n        return a\n    return gcd(b, a % b)\n\n#-----\nfish = {}\ncnt_A0_B0 = 0\ncnt_A0_Bj = 0\ncnt_Ai_B0 = 0\nmod = 10**9 + 7\n\n\nfor a,b in AB_list:\n    if a == b == 0:\n        cnt_A0_B0 += 1\n    \n    elif (a == 0):\n        cnt_A0_Bj += 1\n    \n    elif (b == 0):\n        cnt_Ai_B0 += 1\n    \n    else:\n        g = gcd( abs(a) , abs(b) )\n        \n        a //= g\n        b //= g\n        \n        if a < 0:\n            a *= (-1)\n            b *= (-1)\n        \n        fish.setdefault( (a,b) , 0 )\n        fish[ (a,b) ] += 1\n\n\nans = 1\nused = set()\n\n# multiple the number of pattern, where fish (A != 0) and (B != 0)\nfor key_a, key_b in fish:\n    if (key_a, key_b) not in used:\n        \n        if key_b >= 0:\n            key_reverse = (key_b, -key_a)\n        else:\n            key_reverse = (-key_b, key_a)\n        \n        if key_reverse in fish:\n            ans *= ( (pow(2, fish[(key_a, key_b)], mod) - 1) + (pow(2, fish[key_reverse], mod) - 1) + 1 ) % mod\n            ans %= mod\n            \n            used.add( key_reverse )\n        \n        else:\n            ans *= ( pow(2, fish[(key_a, key_b)], mod) )\n            ans %= mod\n\n\n# multiple the number of pattern, where fish A=0 or B=0\nans *= ( (2**cnt_A0_Bj - 1) + (2**cnt_Ai_B0 - 1) + 1 ) % mod\nans %= mod\n\n# Add the number of pattern, where fish (A,B)=(0,0)\nans += cnt_A0_B0\nans %= mod\n\n# Minus the number of pattern, where no fish selected\nans -= 1\n\nans = (ans + mod) % mod\nprint(ans)\n", "from collections import defaultdict\nfrom math import gcd\n\nMOD=10**9+7\n\nn=int(input())\nL=[]\nfor i in range(n):\n\tl=list(map(int,input().split()))\n\tL.append(l)\n\ndef kikaku(a,b):\n\tg=gcd(a,b)\n\ta//=g\n\tb//=g\n\tif a<0:\n\t\treturn -a,-b\n\treturn a,b\n#a\u3082b\u3082\u6b63\u306e\u5834\u5408Dpos\u3067\u30ab\u30a6\u30f3\u30c8\u3002\nDpos=defaultdict(int)\n#a\u304c\u6b63b\u304c\u8ca0\u306e\u5834\u5408Dneg\u3067\u30ab\u30a6\u30f3\u30c8\u3002\nDneg=defaultdict(int)\n\nzerozero=0\nazero=0\nbzero=0\n\nfor l in L:\n\ta=l[0]\n\tb=l[1]\n\tif a==b==0:\n\t\tzerozero+=1\n\t\tcontinue\n\tif a==0:\n\t\tazero+=1\n\t\tcontinue\n\tif b==0:\n\t\tbzero+=1\n\t\tcontinue\n\ta,b=kikaku(a,b)\n\tif b>0:\n\t\tDpos[(a,b)]+=1\n\telse:\n\t\tDneg[(a,-b)]+=1\n\t\tDpos[(-b,a)]+=0\n\nr=1\nfor k,v in list(Dpos.items()):\n\ta,b=k\n\tj=Dneg[(b,a)]\n\tr*=pow(2,v,MOD)+pow(2,j,MOD)-1\n\t#print(a,b,v,j,r)\n\tr%=MOD\n\nr*=pow(2,azero,MOD)+pow(2,bzero,MOD)-1\nr%=MOD\nr-=1\nr%=MOD\n\nans=r+zerozero\nans%=MOD\nprint(ans)\n#print(Dpos)\n#print(Dneg)\n", "import math\nfrom collections import Counter\n\nMOD = 10**9 + 7\nN = int(input())\n\nI = []\nzz = 0\nsz = 0\ntz = 0\nfor _ in range(N):\n    a,b = map(int, input().split())\n\n    # (a, b) = (0, 0)\n    if a == 0 and b == 0:\n        zz += 1\n        continue\n    # (a, b) = (0, #)\n    if a == 0:\n        sz += 1\n        continue\n    # (a, b) = (#, 0)\n    if b == 0:\n        tz += 1\n        continue\n\n    gcd = math.gcd(a, b)\n    if b < 0:\n        a *= -1\n        b *= -1\n    I.append((a//gcd,b//gcd))\n\nS = []\nT = []\nC = Counter(I)\nfor a, b in C.keys():\n    if a > 0:\n        S.append(C[(a,b)])\n        T.append(C[(-b,a)])\n    else:\n        if C[(b,-a)] == 0:\n            S.append(0)\n            T.append(C[(a,b)])\n\nans = 1\nans *= 2**sz + 2**tz - 1\nans %= MOD\nfor i in range(len(S)):\n    ans *= 2**S[i] + 2**T[i] - 1\n    ans %= MOD\nans += zz  # (0, 0)\nans -= 1\nprint(ans % MOD)", "from collections import Counter\nimport sys\nimport math\nfrom functools import cmp_to_key\n\nsys.setrecursionlimit(10 ** 6)\n\nmod = 1000000007\ninf = int(1e18)\n\n\ndef main():\n    n = int(input())\n    p = [tuple(map(int, input().split())) for i in range(n)]\n    a = {}\n    b = {}\n    c = 0\n    for x, y in p:\n        if x == y == 0:\n            c += 1\n            continue\n        if y == 0:\n            a[(0, 1)] = a.get((0, 1), 0) + 1\n            continue\n        if x == 0:\n            b[(0, 1)] = b.get((0, 1), 0) + 1\n\n        g = math.gcd(x, y)\n        if x * y > 0:\n            x = abs(x)\n            y = abs(y)\n            a[(x//g, y//g)] = a.get((x//g, y//g), 0) + 1\n        else:\n            x = abs(x)\n            y = abs(y)\n            b[(y//g, x//g)] = b.get((y//g, x//g), 0) + 1\n\n    ans = 1\n    s = 0\n    for k, v in list(a.items()):\n        if k in b:\n            s += v + b[k]\n            ans *= pow(2, v) + pow(2, b[k]) - 1\n            ans %= mod\n    ans *= pow(2, n - s - c, mod)\n    print(((ans - 1 + c) % mod))\n\nmain()\n", "import collections\nfrom math import gcd\nimport sys\ninput=sys.stdin.readline\ndef main():\n    n=int(input())\n    c=collections.Counter()\n    mod=10**9+7\n    for _ in range(n):\n        a,b=list(map(int,input().split()))\n        g=abs(gcd(a,b))\n        if g==0:\n            g=1\n        a//=g\n        b//=g\n        c[(a,b)]+=1\n    ans=1\n    s=set()\n    for i,j in c:\n        if (i,j)==(0,0):\n            continue\n        if (i,j) not in s:\n            s.add((i,j))\n            s.add((-i,-j))\n            s.add((-j,i))\n            s.add((j,-i))\n            ans*=(pow(2,c[(i,j)]+c[(-i,-j)],mod)+pow(2,c[(j,-i)]+c[(-j,i)],mod)-1)%mod\n    print(((ans-1+c[(0,0)])%mod))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\n\nMOD = 1000000007\n\ndef inv(a, b):\n    if a < 0:\n        a, b = -a, -b\n    return (-b, a)\n\ndef solve(n, a, b):\n    zero_zero = 0\n    zero = 0\n    inf = 0\n    D = {}\n    for i in range(n):\n        p, q = a[i], b[i]\n        if (p == 0) and (q == 0):\n            zero_zero += 1\n        elif p == 0:\n            zero += 1\n        elif q == 0:\n            inf += 1\n        else:\n            r = gcd(p, q)\n            p, q = (p // r, q // r)\n            if q < 0:\n                p, q = -p, -q\n            k = (p, q)\n            if not k in D:\n                D[k] = 0\n            D[k] += 1\n    group = set()\n    for (p, q), v in D.items():\n        if not inv(p,q) in group:\n            group.add((p,q))\n    pow2 = [0] * (n+1)\n    pow2[0] = 1\n    for i in range(n):\n        pow2[i+1] = (pow2[i] * 2) % MOD\n    ans = 1\n    for p, q in group:\n        t = pow2[D[p,q]]\n        if inv(p, q) in D:\n            t += pow2[D[inv(p, q)]] - 1\n        ans = (ans * t) % MOD\n    ans *= pow2[zero] + pow2[inf] - 1\n    return (ans + zero_zero - 1) % MOD\n\nn = int(input())\na = [0] * n\nb = [0] * n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\nprint(solve(n, a, b))", "from math import gcd\n \nn=int(input())\nmod = 10**9+7\n \nd = dict()\nzeros=0\nfor _ in range(n):\n  a,b=map(int,input().split())\n  if not any((a,b)):\n    zeros+=1\n    continue\n  if all((a,b)):\n    g = gcd(a,b)*(a//abs(a))\n  elif a:\n    g = a\n  else:\n    g = b\n  \n  p = a//g,b//g\n  d[p] = d.get(p,0)+1\n \nans = 1\ndone = set()\nfor (a,b),v in d.items():\n  if (-b,a) in done or (b,-a) in done:\n    continue\n  done.add((a,b))\n  w=d.get((-b,a),0)+d.get((b,-a),0)\n  ans *= (pow(2,v)+pow(2,w)-1)\n  ans %= mod\nprint((ans+zeros-1)%mod)", "from math import gcd\nfrom numpy import sign\nmod = 1000000007\nN = int(input())\n\nd = {}\ncounter = 0\n\nf = 0\nl = 0\n\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    if a == b == 0:\n        counter += 1\n    elif a==0:\n        f += 1\n    elif b==0:\n        l += 1\n    else:\n        g = gcd(a, b)\n        a, b =  a // g, b //g\n        if b < 0:\n            a, b = -a, -b\n        if (a, b) not in d:\n            d[(a, b)] =1\n        else:\n            d[(a, b)] +=1\n\nanswer = 1\n\ngroup = set()\nfor (p, q), v in d.items():\n    invp,invq=-q,p\n    if invq<0:\n        invp,invq=-invp,-invq\n    if not (invp,invq) in group:\n        group.add((p,q))\n\nfor (p, q) in group:\n    invp,invq=-q,p\n    if invq<0:\n        invp,invq=-invp,-invq\n    if (invp, invq) not in d:\n        answer *= (2 ** d[(p, q)])\n    else:\n        answer *= ((2 ** d[(p, q)]) + (2 ** d[(invp, invq)]) - 1)\n        \nanswer *= 2**f + 2**l - 1\n    \nprint((answer + counter - 1) % mod)", "import sys\nfrom collections import defaultdict\nfrom math import gcd\n\nmod = 1000000007\nN = int(input())\n\ndef reduce(vec):\n\tvec = list(vec)\n\tif vec[0]==0:\n\t\tif vec[1] == 0:\n\t\t\treturn (0,0)\n\t\telse:\n\t\t\treturn (0,1)\n\telif vec[1] == 0:\n\t\treturn (1,0)\n\telse:\n\t\tif vec[0]<0:\n\t\t\tvec[0] = -vec[0]\n\t\t\tvec[1] = -vec[1]\n\t\td = gcd(vec[0],vec[1])\n\t\treturn (vec[0]//d, vec[1]//d)\n\ncounter0 = defaultdict(int)\ncounter1 = defaultdict(int)\norigin = 0\n\nfor i in range(N):\n\ta,b = list(map(int, input().split()))\n\tif a==0 and b==0:\n\t\torigin += 1\n\t\tcontinue\n\ta,b = reduce((a,b))\n\tif b>0:\n\t\tcounter0[(a,b)] += 1\n\telse:\n\t\tcounter0[(-b,a)] += 0\n\t\tcounter1[(-b,a)] += 1\n\nans = origin\nk = 1\nfor key, cnt0 in list(counter0.items()):\n\tcnt1 = counter1[key]\n\ttmp = (pow(2, cnt0, mod) + pow(2, cnt1, mod) - 1)% mod\n\tk = (k*tmp) % mod\n\nans = ans + k-1\nans %= mod\nprint(ans)\n\n", "from math import gcd\nn = int(input())\nC = {}\nz = 0\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    if x == 0 and y == 0:\n        z += 1\n        continue\n    g = gcd(x, y)\n    x, y = x // g, y // g\n    if y < 0:\n        x, y = -x, -y\n    try:\n        C[(x, y)] += 1\n    except KeyError:\n        C[(x, y)] = 1\nans = 1\np = 10**9 + 7\nfor x, y in C:\n    if C[(x, y)] == 0:\n        continue\n    a = C[(x, y)]\n    if x > 0:\n        x0, y0 = -y, x\n    else:\n        x0, y0 = y, -x\n    try:\n        b = C[(x0, y0)]\n        C[(x0, y0)] = 0\n    except KeyError:\n        b = 0\n    ans *= pow(2, a, p) + pow(2, b, p) - 1\n    ans %= p\n    C[(x, y)] = 0\nprint(((ans + z - 1) % p))\n", "N=int(input())\nfrom collections import defaultdict\ndic=defaultdict(int)\nimport math\nmod=1000000007\nfor _ in range(N):\n    A,B=list(map(int,input().split()))\n    if A<0:\n        A,B=-A,-B\n    if A==0:\n        if B==0:\n            dic[(0,0)]+=1\n        else:\n            dic[(0,-1)]+=1\n    elif B==0:\n        dic[(1,0)]+=1\n    else:\n        gcd=math.gcd(A,B)\n        A,B=A//gcd,B//gcd\n        dic[(A,B)]+=1\n\nans=1\nN-=dic[(0,0)]\nfor k,v in list(dic.items()):\n    if k==(0,0):\n        continue\n    a,b=k\n    if not (b,-a) in dic:\n        continue\n    v_dash=dic[(b,-a)]\n    ans*=((pow(2,v,mod)-1)+(pow(2,v_dash,mod)-1)+1)\n    ans%=mod\n    N-=v+v_dash\nans*=pow(2,N,mod)\nans+=dic[(0,0)]-1\nans%=mod\nprint(ans)\n", "from math import gcd\nfrom collections import defaultdict\nN = int(input())\nMOD = 10 ** 9 + 7\n\nzero_zero_num = 0\nfishes = defaultdict(int)\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    if a == 0 and b == 0:\n        zero_zero_num += 1\n    elif a == 0:\n        fishes[(0, -1)] += 1\n    elif b == 0:\n        fishes[(1, 0)] += 1\n    else:\n        g = gcd(a, b)\n        a, b = a // g, b // g\n        if (a > 0 and b > 0) or (a < 0 and b < 0):\n            fishes[(abs(a), abs(b))] += 1\n        else:\n            a, b = (-a, -b) if a < 0 else (a, b)\n            fishes[(a, b)] += 1\n\n\nans = 1\nkeys = list(fishes.keys())\nvisited = set()\nfor (kai, kbi) in keys:\n    if kbi >= 0:\n        kaj, kbj = kbi, -kai\n    else:\n        kaj, kbj = -kbi, kai\n\n    if ((kai, kbi) in visited) or ((kaj, kbj) in visited):\n        continue\n\n    ans *= (1 + (pow(2, fishes[(kai, kbi)], MOD) - 1) + (pow(2, fishes[(kaj, kbj)], MOD) - 1))\n    ans %= MOD\n    visited.add((kai, kbi))\n    visited.add((kaj, kbj))\n\nprint(((ans + zero_zero_num - 1) % MOD))\n"]
["n = int(input())\n\nmp = {}\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    mp[a] = mp.get(a, 0) + 1\n    mp[b] = mp.get(b, 0) - 1\n\ncur = 0\nmaxi = 0\nmaxiy = 0\n\nfor i in sorted(mp):\n    cur += mp[i]\n\n    if cur > maxi:\n        maxi = cur\n        maxiy = i\n\nprint(maxiy, maxi)", "# Program to find maximum guest\n# at any time in a party\ndef findMaxGuests(arrl, exit, n):\n    # Sort arrival and exit arrays\n    arrl.sort()\n    exit.sort()\n\n    # guests_in indicates number of\n    # guests at a time\n    guests_in = 1\n    max_guests = 1\n    time = arrl[0]\n    i = 1\n    j = 0\n\n    # Similar to merge in merge sort to\n    # process all events in sorted order\n    while (i < n and j < n):\n\n        # If next event in sorted order is\n        # arrival, increment count of guests\n        if (arrl[i] <= exit[j]):\n\n            guests_in = guests_in + 1\n\n            # Update max_guests if needed\n            if (guests_in > max_guests):\n                max_guests = guests_in\n                time = arrl[i]\n\n            # increment index of arrival array\n            i = i + 1\n\n        else:\n            guests_in = guests_in - 1\n            j = j + 1\n\n    print( time,max_guests)\n\n\n# Driver Code\nt=int(input())\narrl=[]\nexit=[]\nfor _ in range(t):\n    a,b=list(map(int,input().strip().split(\" \")))\n    arrl.append(a)\n    exit.append(b-1)\nn = len(arrl)\nfindMaxGuests(arrl, exit, n)\n\n# This code is contributed\n# by Shivi_Aggarwal\n", "from bisect import bisect_right\nn = int(input())\nbs = []\nds = []\nfor i in range(n):\n    b, d = map(int, input().split())\n    bs.append(b)\n    ds.append(d)\nbs.sort()\nds.sort()\nmaxpop = 0\nbestyear = 0\nfor i in range(len(bs)):\n    died_at_this_point = bisect_right(ds, bs[i])\n    if maxpop < i+1 - died_at_this_point:\n        maxpop = i+1 - died_at_this_point\n        bestyear = bs[i]\nprint(bestyear, maxpop)", "from sys import stdin\n \ndef input():\n    return stdin.readline().strip()\n\nn = int(input())\nbirth_arr = []\ndeath_arr = []\nfor i in range(n):\n    b, d = list(map(int, input().split()))\n    birth_arr.append(b)\n    death_arr.append(d)\n\nbirth_arr = sorted(birth_arr)\ndeath_arr = sorted(death_arr)\n\nnum_ppl = len(birth_arr)\ncurr = 0\ncurr_year = 0\nmax_year = None\nmax_ppl = 0\nb_pointer = 0\nd_pointer = 0\n\nwhile b_pointer < num_ppl:\n    if birth_arr[b_pointer] < death_arr[d_pointer]:\n        curr += 1\n        curr_year = birth_arr[b_pointer]\n        if curr > max_ppl:\n            max_year = curr_year\n            max_ppl = curr\n        b_pointer += 1\n    elif birth_arr[b_pointer] == death_arr[d_pointer]:\n        curr_year = birth_arr[b_pointer]\n        b_pointer += 1\n        d_pointer += 1\n    else:\n        curr -= 1\n        curr_year = death_arr[d_pointer]\n        d_pointer += 1\n\nprint(f\"{max_year} {max_ppl}\")", "n = int(input())\na = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    a.append([x, 1])\n    a.append([y, 0])\na.sort()\nc = 0\nm = 0\ny = 0\nfor i in range(len(a)):\n    if a[i][1] == 1:\n        c += 1\n    else:\n        c -= 1\n    if m < c:\n        m = c\n        y = a[i][0]\nprint(y, m)\n\n", "\nimport math\nfrom sys import stdin\nfrom sys import setrecursionlimit\nsetrecursionlimit(100000)\ndef put():  return  map(int, stdin.readline().split())\nfor _ in range(1):\n\tn=int(input())\n\tstart=[]\n\tend=[]\n\tfor i in range(n):\n\t\ta,b=put()\n\t\tstart.append(a)\n\t\tend.append(b)\n\tstart.sort()\n\tend.sort()\n\tnumalive=0\n\tstartyear=0\n\tindstart=0\n\tindend=0\n\tmx=0\n\twhile(indstart<n ):\n\t\tif(start[indstart]<end[indend]):\n\t\t\tnumalive+=1\n\t\t\tindstart+=1\n\t\t\tif(numalive>mx):\n\t\t\t\tmx=max(mx,numalive)\n\t\t\t\tstartyear=start[indstart-1]\n\t\telif(start[indstart]==end[indend]):\n\t\t\tindstart+=1\n\t\t\tindend+=1\n\t\telse:\n\t\t\tnumalive-=1\n\t\t\tindend+=1\n\tprint(startyear,mx)", "n = int(input())\ninterv = []\nfor i in range(n):\n   deb, fin = list(map(int, input().split()))\n   interv.append((deb, +1))\n   interv.append((fin, -1))\n\ninterv.sort()\n\nm = 0\ny = 0\nc = 0\nfor (t, dx) in interv:\n   c += dx\n   if c > m:\n      m = c\n      y = t\nprint(y, m)\n", "n = int(input())\nl1 = []\nl2 = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    l1.append(a)\n    l2.append(b)\n\nl1.sort(reverse=True)\nl2.sort(reverse=True)\n\ncur = 0\nmx = 0\nans = 0\n\nwhile l1:\n    if l1[-1] < l2[-1]:\n        t = l1.pop()\n        cur += 1\n        if cur > mx:\n            mx = cur\n            ans = t\n    else:\n        l2.pop()\n        cur-=1\n\nprint(ans,mx)", "n = int(input())\nl1 = []\nl2 = []\nfor i in range(n):\n    a,b = list(map(int,input().split()))\n    l1.append(a)\n    l2.append(b)\nl1.sort()\nl2.sort()\nans = 0\nkk = 0\nc = 0\ncc = 0\ni = 0\nwhile i<n:\n    if l1[i]<l2[cc]:\n        c+=1\n        if c>ans:\n            kk = l1[i]\n            ans = c\n        i+=1\n    else:\n        cc+=1\n        c-=1\n    \nprint(kk,ans)\n    \n", "n = int(input())\nmasb = []\nmasd = []\nfor i in range(n):\n    z1, z2 = list(map(int, input().split()))\n    masb.append(z1)\n    masd.append(z2)\nmasb.sort()\nmasd.sort()\nj = 0\nk = 0\ny = 0\nmx = [0, 0]\nfor i in range(len(masb)):\n    y = masb[i]\n    k += 1\n    while y >= masd[j]:\n        k -= 1\n        j += 1\n    if k > mx[1]:\n        mx = [y, k]\nprint(*mx)\n"]
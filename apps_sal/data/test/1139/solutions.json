["from sys import stdin, stdout\n\n\ndef __starting_point():\n\n    def omkar_and_last_floor(a, n, m):\n\n        dp = [[0 for c in range(m)] for r in range(m)]\n\n        #print(dp)\n        for r in range(m):\n            for l in range(r,-1,-1):\n                for k in range(l, r+1):\n                    cnt = 0\n                    for i in range(n):\n                        if l <= a[i][k][0] and a[i][k][1] <= r:\n                            cnt += 1\n                    lr = cnt*cnt\n                    if k-1 >= l:\n                        lr += dp[l][k-1]\n                    if k+1 <= r:\n                        lr += dp[k + 1][r]\n\n                    dp[l][r] = max(dp[l][r], lr)\n        #print(dp)\n        return dp[0][m-1]\n\n\n    n, m = list(map(int, stdin.readline().split()))\n    a = [[[0,0] for c in range(m)] for r in range(n)]\n    for i in range(n):\n        k = int(stdin.readline())\n        for j in range(k):\n            l, r = list(map(int, stdin.readline().split()))\n            for x in range(l, r+1):\n                a[i][x-1][0] = l-1\n                a[i][x-1][1] = r-1\n\n    print(omkar_and_last_floor(a, n, m))\n\n\n__starting_point()", "import sys\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s); sys.stdout.write('\\n')\ndef wi(n): sys.stdout.write(str(n)); sys.stdout.write('\\n')\ndef wia(a, sep=' '): sys.stdout.write(sep.join([str(x) for x in a])); sys.stdout.write('\\n')\n\n\nfrom functools import lru_cache\n\n\ndef solve(n, m, a):\n\n    b = [[] for _ in range(m)]\n    for j in range(m):\n        for l, r, i in a:\n            if l <= j <= r:\n                b[j].append((l, r, i))\n\n    @lru_cache(maxsize=None)\n    def go(left, right):\n        if left > right:\n            return 0\n\n        best = 0\n        for mid in range(left, right + 1):\n            cnt = 0\n            for l, r, i in b[mid]:\n                if l <= mid <= r and l >= left and r <= right:\n                    cnt += 1\n\n            best = max(best, cnt * cnt + go(left, mid - 1) + go(mid + 1, right))\n\n        return best\n\n    return go(0, m-1)\n\n\ndef main():\n    n, m = ria()\n    a = set()\n    for i in range(n):\n        k = ri()\n        for j in range(k):\n            l, r = ria()\n            l -= 1\n            r -= 1\n            a.add((l, r, i))\n\n    wi(solve(n, m, a))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin, stdout\n \n \ndef __starting_point():\n \n    def omkar_and_last_floor(a, n, m):\n \n        dp = [[0 for c in range(m)] for r in range(m)]\n \n        #print(dp)\n        for r in range(m):\n            for l in range(r,-1,-1):\n                for k in range(l, r+1):\n                    cnt = 0\n                    for i in range(n):\n                        if l <= a[i][k][0] and a[i][k][1] <= r:\n                            cnt += 1\n                    lr = cnt*cnt\n                    if k-1 >= l:\n                        lr += dp[l][k-1]\n                    if k+1 <= r:\n                        lr += dp[k + 1][r]\n \n                    dp[l][r] = max(dp[l][r], lr)\n        #print(dp)\n        return dp[0][m-1]\n \n \n    n, m = map(int, stdin.readline().split())\n    a = [[[0,0] for c in range(m)] for r in range(n)]\n    for i in range(n):\n        k = int(stdin.readline())\n        for j in range(k):\n            l, r = map(int, stdin.readline().split())\n            for x in range(l, r+1):\n                a[i][x-1][0] = l-1\n                a[i][x-1][1] = r-1\n \n    print(omkar_and_last_floor(a, n, m))\n__starting_point()", "from bisect import *\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef solve():\n    dp = [[0] * (w + 1) for _ in range(w + 1)]\n    for d in range(1, w + 1):\n        for l in range(w - d + 1):\n            r = l + d\n            cnt = [0] * (w + 1)\n            for i in range(h):\n                sl=bisect_left(seg[i], l)\n                sr=bisect_right(seg[i], r)\n                if sl==sr:continue\n                b = seg[i][sl]\n                e = seg[i][sr - 1]\n                cnt[b] += 1\n                cnt[e] -= 1\n            #for j in range(l, r): cnt[j + 1] += cnt[j]\n            #print(cnt)\n            #mx = max(cnt)\n            #if mx == 0: continue\n            for j in range(l, r):\n                cnt[j + 1] += cnt[j]\n                if cnt[j] == 0: continue\n                dp[l][r] = max(dp[l][r], cnt[j] ** 2 + dp[l][j] + dp[j + 1][r])\n    print(dp[0][w])\n    #p2D(dp)\n\nh,w=MI()\nseg=[[0] for _ in range(h)]\nfor i in range(h):\n    for _ in range(II()):\n        l,r=MI()\n        seg[i].append(r)\nsolve()\n", "from bisect import *\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef solve():\n    dp = [[0] * (w + 1) for _ in range(w + 1)]\n    for d in range(1, w + 1):\n        for l in range(w - d + 1):\n            r = l + d\n            cnt = [0] * (w + 1)\n            for i in range(h):\n                sl=bisect_left(seg[i], l)\n                sr=bisect_right(seg[i], r)\n                if sl==sr:continue\n                b = seg[i][sl]\n                e = seg[i][sr - 1]\n                cnt[b] += 1\n                cnt[e] -= 1\n            #for j in range(l, r): cnt[j + 1] += cnt[j]\n            #print(cnt)\n            #mx = max(cnt)\n            #if mx == 0: continue\n            for j in range(l, r):\n                cnt[j + 1] += cnt[j]\n                if cnt[j] == 0: continue\n                dp[l][r] = max(dp[l][r], cnt[j] ** 2 + dp[l][j] + dp[j + 1][r])\n    print(dp[0][w])\n    #p2D(dp)\n\nh,w=MI()\nseg=[[0] for _ in range(h)]\nfor i in range(h):\n    for _ in range(II()):\n        l,r=MI()\n        seg[i].append(r)\nsolve()\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn, m = mints()\n\tlines = []\n\trows = [[0]*(m+2) for i in range(n)]\n\tcol = [n]*(m+2)\n\tlstart = [[] for i in range(m+2)]\n\tlend = [[] for i in range(m+2)]\n\tdp = [[0]*(m+2) for i in range(m+2)]\n\tfor i in range(n):\n\t\tfor j in range(mint()):\n\t\t\tl, r = mints()\n\t\t\tlstart[l].append((i, r + 1))\n\t\t\tlend[r + 1].append((i, l))\n\tfor i in range(1,m+2):\n\t\tfor r, start in lend[i]:\n\t\t\t#print(\"end\", r, start, i-1)\n\t\t\tfor p in range(start, i):\n\t\t\t\trows[r][p] -= 1\n\t\t\t\tif rows[r][p] == 0:\n\t\t\t\t\tcol[p] += 1\n\t\tfor r, end in lstart[i]:\n\t\t\t#print(\"start\", r, i, end)\n\t\t\tfor p in range(i, end):\n\t\t\t\trows[r][p] += 1\n\t\t\t\tif rows[r][p] == 1:\n\t\t\t\t\tcol[p] -= 1\n\t\tbcol = col.copy()\n\t\tbrows = [rows[i].copy() for i in range(n)]\n\t\t#print(i, col)\n\t\tcc = [None]*(i-1)\n\t\tfor j in range(i-1):\n\t\t\tfor r, start in lend[j]:\n\t\t\t\tfor p in range(start, j):\n\t\t\t\t\trows[r][p] -= 1\n\t\t\t\t\tif rows[r][p] == 0:\n\t\t\t\t\t\tcol[p] += 1\n\t\t\tfor r, end in lstart[j]:\n\t\t\t\tfor p in range(j, end):\n\t\t\t\t\trows[r][p] += 1\n\t\t\t\t\tif rows[r][p] == 1:\n\t\t\t\t\t\tcol[p] -= 1\n\t\t\tcc[j] = col.copy()\n\n\t\tfor j in range(i-2,-1,-1):\n\t\t\td = 0\n\t\t\tcol = cc[j]\n\t\t\tfor p in range(j+1, i):\n\t\t\t\td = max(d, dp[j][p] + dp[p][i] + col[p]**2)\n\t\t\tdp[j][i] = d\n\t\t\t#print(j, i, col, d)\n\t\tcol = bcol\n\t\trows = brows\n\tprint(dp[0][m+1])\n\nsolve()\n"]
["n,a,b = map(int,input().split())\nif a+b>n+1 or a*b<n:\n  print(-1)\n  return\nans = []\nfor i in range(1,a+1):\n  ans.append(i*b)\nif b == 1:\n  x = list(range(1,n+1))\n  print(*x)\n  return\nx = (n-a)//(b-1)\ny = (n-a)%(b-1)\nfor i in range(1,b):\n  for j in range(1,x+1):\n    ans.append(j*b-i)\n  if i <= y:\n    ans.append((x+1)*b-i)\nans_true = []\nfor i,x in enumerate(ans):\n  ans_true.append((i+1,x))\nans_true.sort(key=lambda x:x[1])\nx = list(zip(*ans_true))[0]\nprint(*x)", "N, A, B = map(int, input().split())\n    \nif N < A + B - 1 :\n    print(-1)\n\nelse :\n    if A > B :\n        mode = 0\n        A -= 1\n    else :\n        mode = 1\n        B -= 1\n        \n    ret = []\n    u = N - A + 1\n    l = B\n    while len(ret) < N :\n        if (mode and A == 0) or (not mode and B == 0) :\n            ret = [-1]\n            break\n            \n        if mode :\n            for i in range(max(u, l - B + 1), u + A) :\n                ret.append(i)\n            A -= 1\n            u -= A\n            mode ^= 1\n        else :\n            for i in range(min(l, u + A - 1), l - B, -1) :\n                ret.append(i)\n            B -= 1\n            l += B\n            mode ^= 1\n            \n    print(*ret)", "N,A,B = map(int,input().split())\nif A+B > N+1 or A*B < N:\n    print(-1)\n    return\n\nls = [1]*B\nrem = N-B\ni = 0\nwhile rem > 0:\n    r = min(A-1, rem)\n    ls[i] += r\n    rem -= r\n    i += 1\n\nbs = [[] for _ in range(B)]\nn = 1\nfor j,l in enumerate(ls):\n    for i in range(l):\n        bs[j].append(n)\n        n += 1\nans = []\nfor b in reversed(bs):\n    ans += b\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nn, a, b = map(int,input().split())\nnn = n\nbb = b\n\nif (n+b-1)//b <= a <= n+1-b:\n    ANS = []\n    L = [a]\n    b -= 1\n    n -= a\n    for i in range(b):\n        L.append(1)\n        n -= 1\n    ind = 1\n    while n > 0:\n        p = min(n, a-1)\n        L[ind] += p\n        n -= p\n        ind += 1\n\n    # print(L)\n\n    i = nn\n    for j in range(bb):\n        i -= L[j]\n        for k in range(L[j]):\n            ANS.append(i + k + 1)\n        \n    print(*ANS)\nelse:\n    print(-1)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, A, B = MAP()\n\nif A * B < N:\n    print((-1))\n    return\nif A + B > N+1:\n    print((-1))\n    return\nif A == 1 and B != N or B == 1 and A != N:\n    print((-1))\n    return\nremain = N - A\nif remain < B - 1:\n    print((-1))\n    return\nd, m = divmod(remain, B-1) if B > 1 else (0, 0)\nif d > A:\n    print((-1))\n    return\nli = [[] for i in range(B)]\nli[0] = list(range(1, A+1))\nj = A + 1\nfor i in range(1, B):\n    tmp = []\n    for _ in range(d):\n        tmp.append(j)\n        j += 1\n    if m > 0:\n        tmp.append(j)\n        j += 1\n        m -= 1\n    li[i] = tmp\nli = li[::-1]\nans = []\nfor grp in li:\n    ans += grp\nprint((*ans))\n", "import sys\n\nN,A,B = list(map(int,input().split()))\n\nif A+B-1 > N or A*B < N:\n    print((-1))\n    return\n\nans = []\n\nfor i in range(N-A+1,N+1,1):\n    ans.append(i)\n\nnow = []\nfor i in range(1,N-A+1,1):\n\n    now.append(i)\n\n    if len(now) == B-1:\n        now.reverse()\n\n        for j in now:\n            ans.append(j)\n        now = []\n\nnow.reverse()\nfor j in now:\n    ans.append(j)\n\nprint((\" \".join(map(str,ans))))\n", "N, A, B = list(map(int, input().split()))\n\nans = list(range(A))\nm = 0\nrest = N - A\nB -= 1\nif rest < B:\n  print((-1))\n  return\nif rest / A > B:\n  print((-1))\n  return\n\nwhile rest > B:\n  s = min(A, rest - B + 1)\n  ans += list(range(m - s, m))\n  m -= s\n  rest -= s\n  B -= 1\n\nans += list(range(m - B, m))[::-1]\nm -= B\n\nprint((\" \".join([str(x - m + 1) for x in ans])))\n", "# coding: utf-8\nimport sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, A, B = lr()\nif A + B - 1 > N:\n    print((-1)); return\nif A * B < N:\n    print((-1)); return\n\nif B == 1:\n    q, r = A, 0\nelse:\n    q, r = divmod(N-A, B-1)\n\nif q == A:\n    size = [B] * q\nelse:\n    size = [B] * q + [r+1] + [1] * (A-q-1)\n\nend = 1\nanswer = []\nfor s in size:\n    start = end + s - 1\n    answer.extend(list(range(start, end-1, -1)))\n    end = start + 1\n\nprint((*answer))\n", "def main():\n    N, A, B = list(map(int, input().split()))\n\n    if not (((N - 1) // A + 1) <= B <= (N - A) + 1):\n        print((-1))\n        return\n\n    if B == 1:\n        print((*list(range(1, N + 1))))\n        return\n\n    q, r = divmod(N - A, B - 1)\n\n    ctr = [A]\n    ctr += [q] * (B - 1 - r)\n    ctr += [q + 1] * r\n\n    ans = []\n    ma = N\n    for x in ctr:\n        ans += list(range(ma - x + 1, ma + 1))\n        ma -= x\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n# import sys\n#\n# sys.setrecursionlimit(10 ** 7)\n#\n# input = sys.stdin.readline\n# rstrip()\n# int(input())\n# map(int, input().split())\n\n__starting_point()", "N, A, B = map(int, input().split())\n\nif A + B - 1 > N or A * B < N:\n    print(-1)\n    return\n\nans = []\n\nx = N - A\ncur = 1\nwhile cur <= N:\n    y = min(x + 1, B)\n    ans += list(reversed(range(cur, cur + y)))\n    cur += y\n    x -= y - 1\n\nprint(*ans)", "n, a, b = [int(item) for item in input().split()]\nif n < a + (b-1) or n > a + (b-1) * a:\n    print(-1)\n    return\nfor i in range(a):\n    print(n - a + i + 1, end=\" \")\nn -= a\nif n == 0:\n    print(\"\")\n    return\nloop = n // (b-1)\noption = n % (b-1)\nfor j in range(b-1):\n    if option > 0:\n        for i in range(loop+1):\n            print(n - loop - 1 + i + 1, end=\" \")\n        n -= loop + 1\n        option -= 1\n    else:\n        for i in range(loop):\n            print(n - loop + i + 1, end=\" \")\n        n -= loop\nprint(\"\")", "import math\n\nj = list(map(int, input().split()))\nn = j[0]\na = j[1]\nb = j[2]\nif (n < a + b - 1) or (n > a * b):\n    print((-1))\n    return\n\nans = list(range(b, 0, -1))\nif (n > b):\n    counter = len(ans)\n    loopcounter = 1\n    #sikii = math.ceil((n-b) / (a-1))\n    sikii = b\n    yoyuu = n - a -b+1\n    while (counter < n):\n        if (yoyuu >= sikii):\n            ans += list(range(counter + sikii, counter, -1))\n            yoyuu -= (sikii - 1)\n        elif (yoyuu == 0):\n            ans += [counter + 1]\n        else:\n            ans += list(range(counter + yoyuu + 1, counter, -1))\n            yoyuu = 0\n        loopcounter += 1\n        counter = len(ans)\n\nprint((' '.join(map(str, ans))))\n", "def distribute(n, person, min, max, mode=\"even\"):\n    # n \u500b\u3092 person \u4eba\u306b\u5206\u914d\u3059\u308b\n    # \u8fd4\u308a\u5024\u306f [[a (\u500b), a \u500b\u3082\u3089\u3046\u4eba\u6570], ...]\n    # \u5206\u914d\u3067\u304d\u306a\u3044\u3068\u304d\u306f None \u3092\u8fd4\u3059\n    if person==0 and n==0:\n        return []\n    elif not min*person <= n <= max*person:\n        return None\n    elif mode==\"even\":\n        q, m = divmod(n, person)\n        if m==0:\n            return [[q, person]]\n        else:\n            return [[q, person-m], [q+1, m]]\n    elif mode==\"greedy\":\n        if max==min:\n            return [[max, person]]\n        n -= min * person\n        q, m = divmod(n, max-min)\n        if m==0:\n            return [[min, person-q], [max, q]]\n        else:\n            return [[min, person-1-q], [min+m, 1], [max, q]]\n    else:\n        raise ValueError(\"'mode' must be 'even' or 'greedy'.\")\n\nimport numpy as np\nN, A, B = list(map(int, input().split()))\nAns = np.arange(N, 0, -1, dtype=np.int64)\nAns[:A] = np.flipud(Ans[:A])\nc = N-A\nD = distribute(c, B-1, min=1, max=A, mode=\"greedy\")\nif D is None:\n    print((-1))\n    return\nidx = A\nfor p, n in D:\n    for n_ in range(n):\n        Ans[idx:idx+p] = np.flipud(Ans[idx:idx+p])\n        idx += p\nprint((\" \".join(str(int(a)) for a in Ans)))\n", "N,A,B = map(int,input().split())\nif not (A+B-1 <= N <= A*B):\n    print(-1)\n    return\nif B == 1:\n    print(*list(range(1,A+1)))\n    return\n\nn = (N-A)//(B-1)\nm = (N-A)%(B-1)\n\nstack = [1,A+1]\nlds_cnt = 1\nwhile stack[-1] <= N:\n    l = n if lds_cnt > m else n+1\n    stack.append(stack[-1] + l)\n    lds_cnt += 1\n\nans = []\nwhile len(stack) > 1:\n    ans += list(range(stack[-2], stack[-1]))\n    stack.pop()\nprint(*ans)", "N, A, B = list(map(int, input().split()))\nans = []\n \nif A+B-1<=N<=A*B:\n    S = N-A\n    cur = N\n    ans = []\n    for i in range(A+1):\n        num = min(B-1, S)+1\n        S -= num-1\n        for j in range(num):\n            ans.append(cur-num+1+j)\n        cur -= num\n    ans = ans[::-1][1:]\n    print((*ans))\nelse:\n    print((-1))\n", "n,a,b=map(int,input().split())\nans=[];L=[a]*b;x=a*b-n;ct=1\nif a+b>n+1 or x<0:print(-1);return\nfor i in range(b-1,0,-1):\n y=min(a-1,x);L[i]-=y;x-=y\nfor i in L:\n l=[]\n for j in range(i):\n  l+=[str(ct)];ct+=1\n ans+=[' '.join(l)]\nprint(*reversed(ans))", "import sys\nimport math\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nsys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9 + 7\n\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef LIR(row,col):\n    if row <= 0:\n        return [[] for _ in range(col)]\n    elif col == 1:\n        return [I() for _ in range(row)]\n    else:\n        read_all = [LI() for _ in range(row)]\n        return map(list, zip(*read_all))\n\n#################\n\n# A\u306f\u5358\u8abf\u6e1b\u5c11\u5217\u306e\u53f3\u7aef\u304b\u3089\u9078\u3079\u308b\n# B\u306f ceil(N/A) ~ N-A+1 \u3092\u53d6\u308c\u308b\n\nN,A,B = LI()\n\nif math.ceil(N/A) <= B <= N-A+1:\n    numl = [1]*A  # \u5404\u5358\u8abf\u6e1b\u5c11\u5217\u306e\u8981\u7d20\u6570\n    numl[0] = B\n    left = N-A-B+1\n    for i in range(1,A):\n        val = min(left,B-1)\n        numl[i] += val\n        left -= val\n    ans = []\n    now = 1\n    for i in range(A):\n        ans.extend(list(reversed(range(now,now+numl[i]))))\n        now += numl[i]\n    print(*ans)\nelse:\n    print(-1)", "import sys\n\ninput_methods=['clipboard','file','key']\nusing_method=1\ninput_method=input_methods[using_method]\n\ntin=lambda : map(int, input().split())\nlin=lambda : list(tin())\nmod=1000000007\n\n#+++++\n\ndef main():\n\t#a = int(input())\n\tn, a, b = tin()\n\t#s = input()\n\tif n < a+b-1:\n\t\treturn -1\n\tif n > a*b:\n\t\treturn -1\n\tif a == 1:\n\t\tprint(*list(range(n,0,-1)))\n\t\treturn \n\tif b==1:\n\t\tprint(*list(range(1, n+1)))\n\t\treturn \n\t\n\tal = list( range(1, n+1))\n\tcc = (n - a) // (b-1)\n\tamari = (n - a) % (b-1)\n\tret = al[-a:]\n\tst=n-a\n\tfor bi in range(b-1):\n\t\tna = cc + (1 if bi < amari else 0)\n\t\tst -= na\n\t\tfor ai in range(na):\n\t\t\tret.append(al[st+ai])\n\tprint(*ret)\n\t\t\n\t\t\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "import math\n#import numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,a,b = list(map(int,ipt().split()))\n    if a*b < n or a+b-1 > n:\n        print((-1))\n        return\n    ans = [str(b-i) for i in range(b)]\n    si = n-a+2\n    ue = n+1\n    i = 0\n    while True:\n        if si <= b or a == 1:\n            break\n        ans[i] += \" \"+\" \".join(map(str,list(range(si,ue))))\n        ue = si\n        si -= a-1\n        i += 1\n    if i < b and b+1 < ue:\n        ans[i] += \" \"+\" \".join(map(str,list(range(b+1,ue))))\n    print((\" \".join(ans)))\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, A, B = map(int, input().split())\nans = []\n \nif A+B-1<=N<=A*B:\n    S = N-A\n    cur = N\n    ans = []\n    for i in range(A+1):\n        num = min(B-1, S)+1\n        S -= num-1\n        for j in range(num):\n            ans.append(cur-num+1+j)\n        cur -= num\n    ans = ans[::-1][1:]\n    print(*ans)\nelse:\n    print(-1)\n\nfrom bisect import bisect\n\n\ndef LIS(L):\n    INF, N = 10**12, len(L)\n    seq = [INF] * N\n    for i in L:\n        seq[bisect(seq, i)] = i\n    return N - seq.count(INF)", "N,A,B = list(map(int,input().split(\" \")))\n\nif N < (A + B - 1) or N > (A * B):\n\tprint((-1))\n\treturn\n\nif B == 1 and A == N:\n\tseq = [str(n) for n in range(1,N+1)]\n\tprint((' '.join(seq)))\n\treturn\n\nseq = [str(num)for num in range(N-A+1,N+1)]\ndif = (A * B - N)\ndiv = A - (dif // (B-1))\nmer = (dif % (B-1))\n\nn = N - A\nfor i in range((B-1) - mer):\n\tfor j in range(n-(div)+1,n+1):\n\t\tseq.append(str(j))\n\tn -= (div)\n\nfor i in range(mer):\n\tfor j in range(n-div+2,n+1):\n\t\tseq.append(str(j))\n\tn -= (div - 1)\n\nprint((' '.join(seq)))\n", "def examC():\n    N = LI(); N.sort()\n    if N[0]==1:\n        if N[1]==1:\n            ans = 1\n        else:\n            ans = max(0,N[1]-2)\n    else:\n        ans = (N[1]-2)*(N[0]-2)\n    print(ans)\n    return\n\ndef examD():\n    N, K = LI()\n    ans = 0\n    b = K+1\n    while(b<=N):\n        cur = N//b * (b-K) + max(0,N%b - K+1)\n        if cur==N+1:\n            cur = N\n        ans += cur\n        b += 1\n#        print(ans)\n    print(ans)\n    return\n\ndef examE():\n    N, A, B = LI()\n    if N<A+B-1 or N>A*B:\n        print(-1)\n        return\n    ans = []\n    cur = N\n    num = N\n    rest = B - 1\n    #print(rest)\n    for i in range(B):\n        cur -= A\n        if cur<=rest:\n            cur += A\n            break\n        for j in range(A):\n            if num==rest:\n                break\n            ans.append(cur+1)\n            cur += 1\n            num -= 1\n        cur -= A\n        rest -= 1\n    for i in range(rest,cur):\n        ans.append(i+1)\n    cur = rest\n    for j in range(rest):\n        ans.append(cur)\n        cur -= 1\n    print(\" \".join(map(str,ans)))\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nnonlocal mod,mod2,inf,alphabet\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\ndef __starting_point():\n    examE()\n\n\"\"\"\n\n\"\"\"\n__starting_point()", "import math\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\n#a = list(map(int, input().split()))\n\n#####################################\n\n\n#2:26\nn,a,b = list(map(int, input().split()))\nans=[]\nif(n<a+b-1 or n>a*b):\n    print(-1)\nelse:\n    if(b>=2):\n        x = (n-a)//(b-1)\n        y = (n-a)%(b-1)\n    else:\n        x=1\n        y=1\n    times=[0 for i in range(b-1)]\n    for i in range(a):\n        ans.append(n-a+i+1)\n    for i in range(b-1):\n        if(i<y):\n            times[i]=x+1\n        else:\n            times[i]=x\n    now = n-a\n    for i in range(b-1):\n        now -= times[i]\n        for j in range(times[i]):\n            ans.append(now+j+1)\nprint(' '.join(map(str,ans)))", "import bisect\nimport heapq\nimport itertools\nimport math\nimport operator\nimport os\nimport re\nimport string\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom functools import lru_cache, reduce\nfrom operator import itemgetter, mul, add, xor\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\n\nN, A, B = list(map(int, sys.stdin.buffer.readline().split()))\nif A * B < N:\n    print((-1))\n    return\nif N < A + B - 1:\n    print((-1))\n    return\n\ngroups = [[] for _ in range(A)]\nnums = deque(list(range(1, N + 1)))\nfor i in reversed(list(range(len(groups)))):\n    groups[i].append(nums.pop())\nfor i in range(len(groups)):\n    nums.append(groups[i].pop())\n    for _ in range(B):\n        if not nums:\n            break\n        groups[i].append(nums.popleft())\n\nans = []\nfor g in groups:\n    ans += g[::-1]\nprint((*ans))\n", "def solve(n, a, b):\n    if n < a + b - 1:\n        return [-1]\n    if n > a * b:\n        return [-1]\n    if b == 1:\n        return list(range(1, n + 1))\n    if a == 1:\n        return list(range(n, 0, -1))\n\n    ans = list(range(b, 0, -1))\n    ans.extend(list(range(n - a + 2, n + 1)))\n\n    t = b\n    for t in range(2 * b - 1, n - a + 1, b - 1):\n        ans.extend(list(range(t, t - b + 1, -1)))\n    ans.extend(list(range(n - a + 1, t, -1)))\n    return ans\n\n\nn, a, b = list(map(int, input().split()))\nprint((*solve(n, a, b)))\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, A, B = MAP()\n\nif A == 1 and B != N or B == 1 and A != N:\n    print((-1))\n    return\nremain = N - A\nif remain < B - 1:\n    print((-1))\n    return\nd, m = divmod(remain, B-1) if B > 1 else (0, 0)\nli = [[] for i in range(B)]\nli[0] = list(range(1, A+1))\nj = A + 1\nfor i in range(1, B):\n    tmp = []\n    for _ in range(d):\n        tmp.append(j)\n        j += 1\n    if m > 0:\n        tmp.append(j)\n        j += 1\n        m -= 1\n    if len(tmp) > A:\n        print((-1))\n        return\n    li[i] = tmp\nli = li[::-1]\nans = []\nfor grp in li:\n    ans += grp\nprint((*ans))\n", "n, m, k = map(int,input().split())\nif not m+k-1 <= n <= m*k:\n    print(-1)\n    return\n\nstreak = [1]*k\nstreak[0] = m\ni = 1\nfor increment in range(n-m-k+1):\n    if streak[i] == m: i+= 1\n    streak[i]+= 1\nseq = list(range(n, 0, -1))\n\ni = 0\nfor s in streak:\n    subseq = seq[i:i+s]\n    seq[i:i+s] = subseq[::-1]\n    i+= s\nprint(*seq)", "N, A, B = list(map(int, input().split()))\nif A*B < N or A+B-1 > N:\n    print((-1))\nelse:\n    array = [i for i in reversed(list(range(1, N+1)))]\n    if A > 1:\n        f = array[:B]\n        r = array[B:]\n        L = [f]\n        span = len(r)//(A-1)\n        rem = len(r)%(A-1)\n        i = 0\n        for _ in range(A-1):\n            if rem > 0:\n                L.append(r[i:i+span+1])\n                rem -= 1\n                i += span + 1\n            else:\n                L.append(r[i:i+span])\n                i += span\n        array = []\n        for l in reversed(L):\n            array += l\n    print((' '.join([str(a) for a in array])))\n", "import typing\nimport sys\nimport math\nimport collections\nimport bisect\nimport itertools\nimport heapq\nimport decimal\nimport copy\nimport operator\n\n# sys.setrecursionlimit(10000001)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n# buffer.readline()\n\n\ndef ni(): return int(sys.stdin.readline())\ndef ns(): return list(map(int, sys.stdin.readline().split()))\ndef na(): return list(map(int, sys.stdin.readline().split()))\ndef na1(): return list([int(x)-1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\ndef main():\n    n, a, b = ns()\n\n    res = collections.deque()\n    if a+b > n+1:\n        print((-1))\n        return\n\n    flg = a < b\n    a, b = max(a, b), min(a, b)\n\n    head = [i+1 for i in range(b)]\n    head.reverse()\n    tail = []\n\n    remain = n-b-a+1\n    if remain < 0:\n        print((-1))\n        return\n\n    v = b+1\n    for i in range(a-1):\n        tmp = [v]\n        v += 1\n        while len(tmp) < b and remain > 0:\n            tmp.append(v)\n            v += 1\n            remain -= 1\n        tmp.reverse()\n        tail += tmp\n\n    if remain != 0:\n        print((-1))\n        return\n\n    res = head+tail\n    if flg:\n        for i in range(n):\n            res[i] = n+1-res[i]\n    print((*res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda:sys.stdin.readline().rstrip()\ndef resolve():\n    n,a,b=map(int,input().split())\n    if(a+b>n+1):\n        print(-1)\n        return\n    if(a*b<n):\n        print(-1)\n        return\n\n    ans=list(range(b,0,-1))\n    now=b\n    d=a*b-n\n    for _ in range(a-1):\n        k=min(d,b-1)\n        d-=k\n        next=now+(b-k)\n        for i in range(next,now,-1):\n            ans.append(i)\n        now=next\n\n    print(*ans)\nresolve()", "from bisect import bisect_left\nn, a, b = list(map(int, input().split()))\n\nif n < a + b - 1 or a * b < n:\n    print((-1))\n    return\n\nans = []\nnow = a\nfor i in range(a, 0, -1):\n    ans.append(i)\n\niran = a * b - n\nnow = a\nfor i in range(1, b):\n    # \u3053\u306e\u3050\u308b\u30fc\u3077\u3067\u306f\u4f55\u500b\u524a\u308b\u304b\n    not_need = min(iran, a - 1)\n    iran -= not_need\n    need = a - not_need\n\n    prev = now\n    now += need\n    for j in range(now, prev, -1):\n        ans.append(j)\nprint((*reversed(ans)))\n", "import sys\nn,a,b=map(int,input().split())\nif a+b>n+1 or a*b<n:\n  print(-1)\n  return\n\nans=[]\nL=[a]*b\nx=a*b-n\nfor i in range(1,b):\n  L[i]-=min(a-1,x)\n  x-=min(a-1,x)\nL.reverse()\n\nct=1\nfor i in range(b):\n  l=[]\n  for j in range(L[i]):\n    l.append(str(ct))\n    ct+=1\n  ans.append(' '.join(l))\nans.reverse()\n\nprint(' '.join(ans))", "N,A,B=map(int,input().split())\nif N>A*B or N<A+B-1:\n  print(-1)\n  return\nP=[[] for i in range(B)]\nfor i in range(N):\n  P[i//A].append(i+1)\nP=P[::-1]\nfor i in range(B):\n  if len(P[i])==0:\n    P[i].append(P[-((N-i-1)//A+1)][-1])\n    del P[-((N-i-1)//A+1)][-1]\n  else:\n    break\nQ=[]\nfor i in range(B):\n  for j in range(len(P[i])):\n    Q.append(P[i][j])\nprint(*Q)", "N, A, B = map(int, input().split())\n\nif (A + B > N + 1) or (A * B < N):\n    print(-1)\n    return\n\n\ndistributes = [1] * A\nremain = N - A\nfor i in range(A):\n    d = min(remain, B - 1)\n    distributes[i] += d\n    remain -= d\n\nmarker = 1\nans = []\nfor d in distributes:\n    ans.extend(list(range(marker, marker + d))[::-1])\n    marker += d\nprint(*ans, sep=' ')\n", "n, a, b = [int(x) for x in input().split()]\nif a * b < n or n < a + b - 1:\n    print((-1))\nelse:\n    ans = []\n    remaining = n - a\n    to_insert = 1\n    for i in range(a):\n        ans.append(to_insert)\n        to_insert += 1\n        inserted = 1\n        for j in range(min(b - 1, remaining)):\n            ans.append(to_insert)\n            to_insert += 1\n            inserted += 1\n            remaining -= 1\n        ans[-inserted:] = reversed(ans[-inserted:])\n    print((*ans))\n", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,a,b = list(map(int,input().split()))\n\nif n < a+b-1 or n > a*b:\n    print((-1))\n    return\n\nans = list(range(n,0,-1))\nif a == 1:\n    print((*ans))\n    return\nk = (a*b-n)//(a-1)\nv = n - k - a*(b-k-1)\n\n#print(a,b,n,k,v)\ni = -1\nfor i in range(b-k-1):\n    ans[i*a:(i+1)*a] = ans[i*a:(i+1)*a][::-1]\ni += 1\nans[i*a:i*a+v] = ans[i*a:i*a+v][::-1]\n\nprint((*ans))\n", "#########################\n# \n# ######\n\nN, A, B = [int(_) for _ in input().split()]\nif N < A + B - 1 or A * B < N:\n    print((-1))\nelif B == 1:\n    print((*list(range(1, A + 1))))\nelse:\n    M = N - A - B + 1\n    count = [B] * (1 + M // (B - 1))\n    count += [1] * (A - len(count))\n    count[-1] += (N - A - B + 1) % (B - 1)\n    f = 0\n    ans = []\n    for c in count:\n        ans += list(range(f + c, f, -1))\n        f += c\n    print((*ans))\n", "n,a,b=map(int,input().split())\nif a+b-1>n:print(-1);return()\nif a*b<n:print(-1);return()\nans=[]\nc=0\nnn=n\nfor i in range(a):\n  ans.append([])\n  t=0--nn//(a-i)\n  if i==0:\n    t=b\n  nn-=min(t,b)\n  for j in range(min(b,t)):\n    ans[-1].append((i+1)*b-j)\n    c+=1\n    if c==n:break\n  if c==n:break\nanss=[]\nfor i in ans:anss+=i\ndef position_zip(a,flag):\n  j=1\n  d={}\n  for i in sorted(a):\n    if i in d:continue\n    d[i]=j\n    j+=1\n  if flag==1:return d\n  return [d[i] for i in a]\nprint(*position_zip(anss,0))", "N, A, B = [int(_) for _ in input().split()]\nif N < A + B - 1 or A * B < N:\n    print((-1))\nelif B == 1:\n    print((*list(range(1, A + 1))))\nelse:\n    M = N - A - B + 1\n    count = [B] * (1 + M // (B - 1))\n    count += [1] * (A - len(count))\n    count[-1] += (N - A - B + 1) % (B - 1)\n    f = 0\n    ans = []\n    for c in count:\n        ans += list(range(f + c, f, -1))\n        f += c\n    print((*ans))\n", "n, a, b = list(map(int, input().split()))\n\ndef solve(n, a, b):\n    rev = a < b\n    if rev:\n        b, a = a, b\n\n    if n < a+b-1:\n        return [-1]\n\n    if n > a * b:\n        return [-1]\n\n    surrogate_ans = []\n    for i in range(b):\n        nd = i+1\n        reminder = n - a*i\n        tail = b - nd\n        batch_length = min(a, reminder-tail)\n        # print(\"i: {}, reminder: {}, tail: {}, batch_length: {}\".format(i, reminder, tail, batch_length))\n        batch = list(range(n+1-a*i-batch_length, n+1-a*i))\n        surrogate_ans += batch\n        if batch_length != a:\n            surrogate_ans += list(reversed(list(range(1, tail+1))))\n        if len(surrogate_ans) == n:\n            break\n\n    if rev:\n        return reversed(surrogate_ans)\n    else:\n        return surrogate_ans\n\nprint((\" \".join(map(str, solve(n, a, b)))))\n\n", "n,a,b = map(int,input().split())\nturn = 0\nif b > a:\n    turn = 1\n    a,b = b,a\nx = (n+a-1)//a\nif x > b or a+b > n+1:\n    print(-1)\n    return\n\nans = []\nm = n%a\nnow = n\nwhile x < b:\n    ans.append(now)\n    now -= 1\n    if m:\n        m -= 1\n        x += 1\n    else:\n        m = a-1\nfor i in range((now+a-1)//a):\n    for j in range(a-1,-1,-1):\n        num = now-i*a-j\n        if num > 0:\n            ans.append(num)\nif turn:\n    ans = ans[::-1]\nprint(*ans)", "\nmax2 = lambda x,y: x if x > y else y\n\ndef solve(N,A,B):\n    if A+B > N+1:\n        return None\n    if A*B < N:\n        return None\n\n\n    res = [-1]*N\n    rem = A\n\n    i = 0\n    while i+B+rem-1 < N:\n        rem -= 1\n        o = i+B\n        for k in range(B):\n            res[i+k] = o-k-1\n        i += B\n\n    p = N-i-rem+1\n    for k in range(p):\n        res[i+k] = i+p-k-1\n    i += p\n    rem -= 1\n    for k in range(i,N):\n        res[k] = k\n    return res\n\n\n\n\n\n\nfrom itertools import permutations\ndef naive(N,A,B):\n\n    for p in permutations(range(N)):\n        dp = [1]*N\n        for i in range(N):\n            for j in range(i):\n                if p[j] < p[i]:\n                    dp[i] = max2(dp[i],dp[j]+1)\n\n        a = max(dp)\n\n        dp = [1]*N\n        for i in range(N):\n            for j in range(i):\n                if p[j] > p[i]:\n                    dp[i] = max2(dp[i],dp[j]+1)\n\n        b = max(dp)\n\n        if a == A and b == B:\n            return p\n    return None\n\ndef __starting_point():\n    N,A,B = map(int,input().split())\n    res = solve(N,A,B)\n    if res is None:\n        print(-1)\n    else:\n        print(*(v+1 for v in res))\n__starting_point()", "n,a,b = map(int,input().split())\nturn = 0\nif b > a:\n    turn = 1\n    a,b = b,a\nx = (n+a-1)//a\nif x > b or a+b > n+1:\n    print(-1)\n    return\n\nans = []\nm = n%a\nnow = n\nwhile x < b:\n    ans.append(now)\n    now -= 1\n    if m:\n        m -= 1\n        x += 1\n    else:\n        m = a-1\nfor i in range((now+a-1)//a):\n    for j in range(a-1,-1,-1):\n        num = now-i*a-j\n        if num > 0:\n            ans.append(num)\nif turn:\n    ans = ans[::-1]\nprint(*ans)", "def distribute(n, person, min, max, mode=\"even\"):\n    # n \u500b\u3092 person \u4eba\u306b\u5206\u914d\u3059\u308b\n    # \u8fd4\u308a\u5024\u306f [[a (\u500b), a \u500b\u3082\u3089\u3046\u4eba\u6570], ...]\n    if person==0 and n==0:\n        return []\n    elif not min*person <= n <= max*person:\n        return None\n    elif mode==\"even\":\n        q, m = divmod(n, person)\n        if m==0:\n            return [[q, person]]\n        else:\n            return [[q, person-m], [q+1, m]]\n    elif mode==\"greedy\":\n        n -= min * person\n        q, m = divmod(n, max-min)\n        if m==0:\n            return [[min, person-q], [max, q]]\n        else:\n            return [[min, person-1-q], [min+m, 1], [max, q]]\n    else:\n        raise ValueError(\"'mode' must be 'even' or 'greedy'.\")\n\nimport numpy as np\nN, A, B = list(map(int, input().split()))\nAns = np.arange(N, 0, -1, dtype=np.int64)\nAns[:A] = np.flipud(Ans[:A])\nc = N-A\nD = distribute(c, B-1, min=1, max=A, mode=\"even\")\nif D is None:\n    print((-1))\n    return\nidx = A\nfor p, n in D:\n    for _ in range(n):\n        Ans[idx:idx+p] = np.flipud(Ans[idx:idx+p])\n        idx += p\nprint((\" \".join(str(int(a)) for a in Ans)))\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,a,b = map(int, input().split())\n\ndef sub(n,a,b):\n    ps = list(range(a))\n    for i in range(1, b):\n        ps.append(-a*i)\n    count = a+b-1\n    if count==n:\n        return ps\n    for i in range(1,b):\n        for j in range(1,a):\n            ps.append(-a*i+j)\n            count += 1\n            if count==n:\n                break\n        if count==n:\n            break\n    return ps\n\nif a+b>n+1:\n    ans = -1\nelif a*b<n:\n    ans = -1\nelse:\n    # a*b\u500b\u306e\u5217\n    ps = sub(n,a,b)\n    pps = [(i+1,p) for i,p in enumerate(ps)]\n    pps.sort(key=lambda x: x[1])\n    ans = [item[0] for item in pps]\nif ans==-1:\n    print(ans)\nelse:\n    write(\" \".join(map(str, ans)))", "r,p=range,print\nn,a,b=map(int,input().split())\nif a+b>n+1or a*b<n:print(-1);return\nl=[[]for i in r(b-1)]+[list(r(1,a+1))]\nfor i in r(a+1,n+1):l[-2-(i-a-1)%(b-1)]+=[i]\nfor i in l:p(*i,end=\" \")", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nmod = 10 ** 9 + 7; INF = float(\"inf\")\n\ndef getlist():\n\treturn list(map(int, input().split()))\n\ndef main():\n\tN, A, B = getlist()\n\tif 1 + N < A + B or N > A * B:\n\t\tprint(-1)\n\t\treturn\n\n\tans = [i for i in range(N, N - B, -1)]\n\tN2 = N - B; A2 = A - 1\n\tif A2 == 0:\n\t\tprint(*ans)\n\t\treturn\n\tp = N2 // A2\n\tq = N2 % A2\n\tB = [p] * A2\n\tB.append(0)\n\tfor i in range(q):\n\t\tB[i] += 1\n\t# print(B)\n\tBsum = [0] * A2\n\tfor i in range(A2):\n\t\tBsum[i] = Bsum[i - 1] + B[i]\n\t# print(Bsum)\n\n\tpre = []\n\tfor i in range(A2):\n\t\tfor j in range(B[i]):\n\t\t\tpre.append(Bsum[i] - j)\n\t# print(pre)\n\tanswer = pre + ans\n\tprint(*answer)\n\n\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN, A, B = map(int, input().split())\nif N < A or N < B:\n  print(-1)\n  return\nres = [x for x in range(N - A + 1, N + 1)]\nk = N - A\nif k < B - 1:\n  print(-1)\n  return\nb = [0] * (B - 1)\nfor i in range(k):\n  b[i % (B - 1)] += 1\nif len(b):\n  if max(b) > A:\n    print(-1)\n    return\nfor i in b:\n  t = [x for x in range(k - i + 1, k + 1)]\n  res += t\n  k -= i\nprint(*res)", "N, A, B = map(int, input().split())\n\nif A * B < N:\n  print(-1)\nelif A + B - 1 > N:\n  print(-1)\nelse:\n  P = [0] * N\n  b = (N - A) // (B - 1) if B > 1 else 0\n  r = (N - A) % (B - 1) + 1 if B > 1 else 1\n  i = 1\n  pos = 0\n  while i <= N:\n    if b:\n      for j in range(B):\n        P[pos + B - j - 1] = i\n        i += 1\n      pos += B\n      b -= 1\n    elif r:\n      for j in range(r):\n        P[pos + r - j - 1] = i\n        i += 1\n      pos += r\n      r = 0\n    else:\n      P[pos] = i\n      i += 1\n      pos += 1\n    \n  for p in P:\n    print(p, end=' ')", "N, A, B = list(map(int, input().split()))\n\nif A + B - 1 > N or A * B < N:\n    print('-1')\nelse:\n    ans = list(range(1, B + 1)[::-1])\n    if A > 1:\n        x = (N - B) // (A - 1)\n        y = (N - B) % (A - 1)\n        st = B + 1\n        for i in range(y):\n            ans += list(range(st, st + x + 1)[::-1])\n            st += x + 1\n        for i in range(A - 1 - y):\n            ans += list(range(st, st + x)[::-1])\n            st += x\n\n    print((' '.join(map(str, ans))))\n", "N, A, B = list(map(int, input().split()))\n\n\ndef f(a, b):\n    return [\n        p\n        for p in [\n            N - i * a + j\n            for i in range(\n                1,\n                N // a + 1 if N % a > b - N // a else\n                N // a\n            )\n            for j in range(1, a + 1)\n        ] +\n        [\n            j\n            for j in range(\n                b - N // a if N % a > b - N // a else\n                b - N // a + 1,\n                N - (N // a) * a + 1 if N % a > b - N // a else\n                N - (N // a - 1) * a + 1\n            )\n        ] +\n        [\n            j\n            for j in reversed(\n                list(range(\n                    1,\n                    b - N // a if N % a > b - N // a else\n                    b - N // a + 1))\n            )\n        ]\n    ]\n\n\n# N - A + 1, N - A + 2, ..., N,\n# N - 2A + 1, N - 2A + 2, ..., N - A,\n# ...,\n# N - floor(N / A)A + 1, N - floor(N / A)A + 2, ..., N - (floor(N / A) + 1)A,\n# B - floor(N / A), B - floor(N / A) + 1, ..., N - floor(N / A)A\n# B - floor(N / A) - 1, B - floor(N / A) - 2, ..., 1\n# \u3068\u69cb\u7bc9\u3059\u308b\nans = (\n    -1 if A * B < N or A + B > N + 1 else\n    ' '.join(\n        str(p) if A >= B else\n        str(N - p + 1)\n        for p in f(max(A, B), min(A, B))\n    )\n)\n\nprint(ans)\n", "N,A,B = map(int,input().split())\nif A+B-1>N or N>A*B:\n    print(-1)\nelse:\n    G = {i:[] for i in range(1,A+1)}\n    i = A\n    cnt = 0\n    cur = N\n    while cur>A:\n        G[i].append(cur)\n        cnt += 1\n        cur -= 1\n        if cnt==B-1:\n            cnt = 0\n            i -= 1\n    C = []\n    for i in range(1,A+1):\n        C += G[i]\n        C.append(i)\n    print(*C)", "# \u3067\u3064oO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)\nimport sys\ndef main(N, A, B):\n    if A + B - 1 > N or A * B < N:\n        print((-1))\n        return\n    P = []\n    r = A * B - N\n    for b in range(B):\n        for a in range(A):\n            if b >= 1 and a >= 1 and r > 0:\n                if r >= A - 1:\n                    r -= A - 1\n                    break\n                r -= 1\n                continue\n            P.append((B - b) * A + a + 1)\n    s = sorted([(p, i) for i, p in enumerate(P)], key=lambda x: x[0])\n    s = sorted([(i, j) for j, (p, i) in enumerate(s)], key=lambda x: x[0])\n    s = [j + 1 for i, j in s]\n    print((*s))\n\ndef __starting_point():\n    input = sys.stdin.readline\n    N, A, B = list(map(int, input().split()))\n    main(N, A, B)\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\"\"\"\nn-\u5897\u5927\u5217\u3001m-\u6e1b\u5c11\u5217\u307e\u3067\u3000-> \u9577\u3055 nm \u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u5e30\u7d0d\u6cd5\u3002\n(n+1)m + 1 \u9805\u304c\u3042\u308b\u3068\u3059\u308b\u3002(n+2\u5897\u5927 or m+1\u6e1b\u5c11)\u306e\u5b58\u5728\u3092\u3044\u3046\u3002\nA\uff1a\u5de6 nm \u9805 B\uff1a\u53f3 m+1 \u9805\nA\u306b1\u9805\u52a0\u3048\u308b\u3068\u3001(n+1,m+1)\u306e\u3069\u3061\u3089\u304b\u304c\u3067\u304d\u308b\u3002(n+1)-\u5897\u5927\u304c\u3067\u304d\u308b\u3068\u3057\u3066\u3088\u3044\u3002\nB\u306e\u5404\u9805 b \u306b\u5bfe\u3057\u3066\u3001b\u3067\u7d42\u308f\u308b(n+1)-\u5897\u5927\u5217\u304c\u5b58\u5728\u3059\u308b\u3002\nB\u306e\u4e2d\u306b2-\u5897\u5927\u5217\u304c\u3042\u308c\u3070(n+2)\u5897\u5927\u5217\u304c\u3067\u304d\u308b\u3002\u305d\u3046\u3067\u306a\u3051\u308c\u3070B\u304c(m+1)-\u6e1b\u5c11\u5217\u306a\u306e\u3067\u3088\u3044\n\n\"\"\"\n\nN,A,B = map(int,input().split())\n\nif A+B-1 > N:\n    print(-1)\n    return\nif A*B < N:\n    print(-1)\n    return\n\n# \u6e1b\u5c11\u5217\u3092A\u500b\u4e26\u3079\u308b\n\nif B == 1:\n    size = [1] * A\nelse:\n    q,r = divmod(N-A,B-1)\n    if q < A:\n        size = [B] * q + [1+r] + [1] * (A-q-1)\n    else:\n        size = [B] * A\n\nanswer = []\nstart = 1\nfor s in size:\n    end = start + s\n    answer += list(range(end-1, start-1, -1))\n    start = end\nprint(*answer)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,a,b = LI()\n    if a+b > n+1:\n        return -1\n    t = n // b\n    if n % b > 0:\n        t += 1\n    if a < t:\n        return -1\n    rr = []\n    while n > 0:\n        if n == a:\n            rr.append(list(range(1,n+1)))\n            break\n        if n-b >= a-1:\n            rr.append(list(range(n,n-b,-1)))\n            n -= b\n            a -= 1\n            continue\n        rr.append(list(range(n,a-1,-1)))\n        rr.append(list(range(1,a)))\n        break\n    r = []\n    rr.reverse()\n    for c in rr:\n        r.append(' '.join(map(str,c)))\n\n    return ' '.join(r)\n\n\nprint(main())\n\n\n", "def main(n,a,b):\n    if not a*b>=n>=a+b-1:\n        return [-1]\n    ans=[]\n    flg=False\n    # \u30d6\u30ed\u30c3\u30af\u6570\n    for x in range(b): \n        # x\u756a\u76ee\u306e\u30d6\u30ed\u30c3\u30af(0-indexed)\n        if not flg:\n            for y in range(a):\n                # x*a+y+1\u500b\u76ee\u306e\u8981\u7d20(1-indexed)\n                ans.append(b-x+b*y)\n                if len(ans)+(b-x)==n:\n                    if y!=a-1:\n                        ans.append(b-x+b*(a-1))\n                    else:\n                        ans.append(b-(x+1))\n                    flg=True\n                    break\n        elif flg:\n            ans.append(b-x+b*(a-1))\n    c=ans.copy()\n    c.sort()\n    from bisect import bisect_right\n    ans=[bisect_right(c,x) for x in ans]\n    return ans\n\nn,a,b=map(int,input().split())\nary=main(n,a,b)\nprint(*ary,sep=' ')\n", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, A, B = mapint()\nfrom collections import deque\nif A+B-1>N or N>A*B:\n    print(-1)\nelse:\n    blocks = []\n    blocks.append(' '.join(map(str, range(B, 0, -1))))\n    now = B+1\n    rest = N-A+2\n\n    while now:\n        if now==rest:\n            break\n        if now+B>rest:\n            blocks.append(' '.join(map(str, range(rest, now-1, -1))))\n            rest += 1\n            break\n        blocks.append(' '.join(map(str, range(now+B-1, now-1, -1))))\n        now = now+B\n        rest += 1\n    blocks.append(' '.join(map(str, range(rest, N+1))))\n    print(' '.join(blocks))", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\n\n\"\"\"\n\u548c\u306fN+1\u4ee5\u4e0b\u3067\u3042\u308b\uff0e\nA\u5217\u3068B\u5217\u306e\u4e21\u65b9\u3067\u5171\u901a\u3057\u3066\u6301\u3066\u308b\u306e\u306f1\u500b\u307e\u3067\u306a\u306e\u3067\uff0e\n\u4e0b\u9650\u306f\u3069\u308c\u304f\u3089\u3044\u3060\u308d\u3046\uff0e\n\nA=1 or B=1\u306a\u3089\u76f8\u65b9\u306fN\u78ba\u5b9a\uff0e\n\u57fa\u672c\u7684\u306bA\u3082B\u30821\u3067\u306f\u306a\u3044\u524d\u63d0\u3067\u8a71\u3059\n\n\u3068\u308a\u3042\u3048\u305a\u69cb\u7bc9\u3092\u8003\u3048\u308b\u304b\uff0e\nA+B=N+1\u306a\u3089\u7c21\u5358\uff0e\nB,B-1,...,2,1,B+1,B+2,...N\n\u3067\u826f\u3044\uff0e\u624b\u524d\u306bB\u5217\uff0c\u5965\u306bA\u5217\u3092\u56fa\u3081\u308b\uff0e\n\nA+B=N-1\u3067\u306a\u3044\u5834\u5408\uff0cA\u5217\u306b\u4f7f\u3046\u3082\u306e\u3068B\u5217\u306b\u4f7f\u3046\u3082\u306e\u306f\u304b\u3076\u3089\u306a\u304f\u3066\u826f\u3044\uff0e\n\u624b\u524d\u306b\u5927\u304d\u3044\u9806\u306bB\u500b\u3060\u3051\u4e26\u3079\u3066\u304a\u3051\u3070\uff0c\nN-B\u500b\u306e\u9806\u5217\u3067\nLIS=A\u304b\u3064\nLDS\u2260B\n\u3092\u6e80\u305f\u305b\u308b\u304b\uff0c\u3068\u3044\u3046\u554f\u984c\u306b\u5e30\u7740\uff0e\n\u3046\u30fc\u3093\uff0c\n\n\u3053\u306e\u3084\u308a\u65b9\u3067N=20\uff0cA=2,B=5\u306b\u3067\u304d\u308b?\u7121\u7406\uff0c1\u304b\u3089\u307f\u3066LIS\u30923\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u306b\u306f\u964d\u9806\u306b\u4e26\u3079\u308b\u3057\u304b\u306a\u3044\n\u3044\u304f\u3064\u304b\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u3088\u3046\u304b\uff0e\n17~20, 13~16, 9~12, 5~8, 1~4\n\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u3066\uff0c\u30b0\u30eb\u30fc\u30d7\u5185\u3067\u306f\u6607\u9806\u306b\u3059\u308c\u3070\nA=4,B=5\u307e\u3067\u306f\u3044\u3051\u308b\uff0eB=5\u3092\u56fa\u5b9a\u3057\u305f\u3089\u3053\u308c\u304cA\u306e\u6700\u5c0f\u306a\u6c17\u304c\u3059\u308b\nA\u306e\u6700\u5c0f\u5024\u306fN/B\u306e\u5207\u308a\u4e0a\u3052\uff0c\u304b\u306a\n\"\"\"\ndef main():\n    mod=10**9+7\n    N,A,B=MI()\n    \n    if A+B>N+1:\n        print((-1))\n        return\n        \n    t=(N+B-1)//B\n    if A<t:\n        print((-1))\n        return\n        \n    if A==1:\n        if B==N:\n            ans=list(range(N,0,-1))\n            print((' '.join(map(str, ans))))\n            return\n        else:\n            print((-1))\n            return\n    \n    if B==1:\n        if A==N:\n            ans=list(range(1,N+1))\n            print((' '.join(map(str, ans))))\n            return\n        else:\n            print((-1))\n            return\n    \n        \n    ans=[]\n    temp=list(range(N-A+1,N+1))\n    ans+=temp\n    unit=(N-A)//(B-1)\n    rem=(N-A)%(B-1)\n    \n    right=N-A #\u5404\u30b0\u30eb\u30fc\u30d7\u306e\u53f3\u7aef\n    for i in range(B-1):\n        left=right-unit\n        if rem:\n            left-=1\n            rem-=1\n        temp=list(range(left+1,right+1,1))\n        ans+=temp\n        right=left\n        \n    print((' '.join(map(str, ans))))\n        \n        \n        \n\nmain()\n", "N, A, B = list(map(int, input().split()))\ndef solve():\n    if A + B - 1 <= N and N <= A * B:\n        if A == 1:\n            return [i for i in range(N, 0, -1)]\n        s = []\n        q = (N - B) // (A - 1)\n        r = (N - B) % (A - 1)\n        if r == 0:\n            q -= 1\n            r = A - 1\n        for i in range(B - q - 1):\n            s.append(N - i)\n        for i in range(r + 1):\n            s.append(A * q + 1 + i)\n        for i in range(q - 1, -1, -1):\n            for j in range(A):\n                s.append(A * i + j + 1)\n        return s\n    else:\n        return [-1]\nprint((\" \".join(map(str, solve()))))\n", "N, A, B = map(int, input().split())\nif A+B>N+1: print(-1);return\nres,tmp=[],[]\nk,l,cnt,sign,m1,m2 = N+1,0,0,1,0,0\nwhile k!=l+1:\n    if m1>=A or m2>=B:print(-1);return\n    if sign==1:\n        if cnt<A-m1:\n            k-=1\n            tmp.append(k)\n            cnt+=1\n        else:\n            res.extend(reversed(tmp))\n            tmp=[]\n            cnt=0\n            sign=0\n            m2+=1\n    else:\n        if cnt<B-m2:\n            l+=1\n            tmp.append(l)\n            cnt+=1\n        else:\n            res.extend(reversed(tmp))\n            tmp=[]\n            cnt=0\n            sign=1\n            m1+=1\nres.extend(reversed(tmp))\nprint(*res)", "N,A,B = list(map(int,input().split()))\nans = []\nif N >= A + B - 1 and N <= A *B:\n    for i in range(A):\n        ans.append(str(N - A +1 + i))\n        for j in range(B-1):\n            if i * (B -1 ) + (B -1 -j) > N - A + B:\n              break\n            elif i * (B-1) + (B -1 - j ) >= N - A + 1:\n                continue\n            #print(i * (B-1) + (B-1 -j))\n            ans.append(str(i * (B-1) + (B-1 - j )))\nelse:\n    ans = [\"-1\"] \nprint(\" \".join(ans))", "import sys\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\nN,A,B = MI()\n\nif not (A+B <= N+1 and A*B >= N):\n    print((-1))\n    return\n\nANS = [[i for i in range(1,A+1)]]\nif B >= 2:\n    a = A+1\n    q,r = divmod(N-A,B-1)\n    for i in range(B-1-r):\n        ANS.append([i for i in range(a,a+q)])\n        a += q\n    for i in range(r):\n        ANS.append([i for i in range(a,a+q+1)])\n        a += q+1\n\nANS.reverse()\nans = []\nfor X in ANS:\n    for i in range(len(X)):\n        ans.append(X[i])\n\nprint((*ans))\n", "def getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\ndef getArray(intn):\n    return [int(input()) for i in range(intn)]\ndef input():\n    return sys.stdin.readline().rstrip()\ndef rand_N(ran1, ran2):\n    return random.randint(ran1, ran2)\ndef rand_List(ran1, ran2, rantime):\n    return [random.randint(ran1, ran2) for i in range(rantime)]\ndef rand_ints_nodup(ran1, ran2, rantime):\n  ns = []\n  while len(ns) < rantime:\n    n = random.randint(ran1, ran2)\n    if not n in ns:\n      ns.append(n)\n  return sorted(ns)\n\ndef rand_query(ran1, ran2, rantime):\n  r_query = []\n  while len(r_query) < rantime:\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n    if not n_q in r_query:\n      r_query.append(n_q)\n  return sorted(r_query)\n\nfrom collections import defaultdict, deque, Counter\nfrom decimal import *\nfrom heapq import heapify, heappop, heappush\nimport math\nimport random\nimport string\nfrom copy import deepcopy\nfrom itertools import combinations, permutations, product\nfrom operator import mul, itemgetter\nfrom functools import reduce\nfrom bisect import bisect_left, bisect_right\n\nimport sys\nsys.setrecursionlimit(1000000000)\nmod = 10 ** 9 + 7\n\n#############\n# Main Code #\n#############\n\n\"\"\"\n\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u306e\u9577\u3055\u306fA\u3000\n\u6700\u9577\u6e1b\u5c11\u90e8\u5206\u5217\u306e\u9577\u3055\u306fB\n\u4f7f\u3048\u308b\u6570\u5b57\u306f1 ~ N\n\u4e00\u756a\u90fd\u5408\u306e\u3044\u3044\u3082\u306e\u3092\u63a2\u3059\nA + B > N + 1\u306a\u3089\u30c0\u30e1\u3063\u307d\u3044\nA + B = N\u306e\u5834\u5408\n2 3 5 + 5 4\n2 3 1 5 4\n1\u3092\u9069\u5f53\u306a\u6240\u306b\u7f6e\u3051\u3070\u826f\u3044\nA + B = N + 1\u306e\u5834\u5408\u306f\u7c21\u5358\nN = 5\nA, B = 3, 3\n3 4 5 + 5 2 1\n3 4 5 2 1\n\nA + B < N \u306e\u5834\u5408\n\u3044\u3089\u306a\u3044\u3082\u306e\u3092\u9069\u5f53\u306b\u7f6e\u3051\u3070\n\u3044\u3044\u306e\u3067\u306f\uff1f\nN = 5\nA, B = 2, 2 \u306f\u7121\u7406 A + B <= 4\u306f\u7121\u7406\n2 3 + 3 1 (4, 5\u306f\u3044\u3089\u306a\u3044)\n2 3 1 + 4 5\n\n(5, 6, 3, 1, 4, 2)\n4 5 6 1 2 3\n\ndef lis(A):\n    L = [A[0]]\n    for a in A[1:]:\n        if a > L[-1]:\n            L.append(a)\n        # \u3053\u306eelse\u306b\u5f15\u3063\u304b\u304b\u3063\u305f\u6642\u306b\u30c8\u30e9\u30f3\u30d7\u306e\u30bd\u30fc\u30c8\u304c\u5fc5\u8981\n        else:\n            L[bisect_left(L, a)] = a\n    return len(L)\n\nfor i in permutations([1, 2, 3, 4, 5, 6, 7]):\n    if lis(i) + lis(list(reversed(i))) <= 5:\n        print(lis(i), lis(list(reversed(i))), i)\n\n\u76f8\u65b9\u30922\u306b\u3057\u305f\u5834\u5408\u306e\u4e0b\u9650\u306f(N + 1) // 2 ?\n5\u306a\u30893 2\n6\u306a\u30893 2\n7\u306a\u30894 2\n8\u306a\u30894 2\n3 4 5 + 5 2\n3 4 5 1 2\n4 5 6 + 6 3\n4 5 6 1 2 3\n4 5 6 7 + 6 3\n4 5 6 7 1 2 3\n\u7d30\u304b\u304f\u533a\u5207\u308c\u3070\u3082\u3063\u3068\u3044\u3051\u308b\nN = 16\u306a\u3089\n[13 14 15 16] [9 10 11 12] [5 6 7 8] [1 2 3 4]\nA = 4, B = 4\nA * B >= N\u3067\u3042\u308c\u3070\u4f5c\u308c\u308b\n\"\"\"\n\nN, A, B = getNM()\n\n# main\u306e\u9577\u3055\u304c\u534a\u5206\u3088\u308a\u4e0b\u306a\u3089out\nif A * B < N or N + 1 < A + B:\n    print(-1)\n    return\n\nif A == 1:\n    if B == N:\n        print(*[i for i in range(N, 0, -1)])\n    else:\n        print(-1)\n    return\n\nif B == 1:\n    if A == N:\n        print(*[i for i in range(1, N + 1)])\n    else:\n        print(-1)\n    return\n\n# \u30b0\u30eb\u30fc\u30d7\u5185\u306e\u8981\u7d20\u306e\u6570\u304cA,\u30b0\u30eb\u30fc\u30d7\u306e\u6570\u304cB\nres1 = [i + 1 for i in range(N - A, N)]\nres2 = []\nL = [i + 1 for i in range(N - A - 1, -1, -1)] # \u6b8b\u308aN - A\u500b\n\n# \u6b8b\u308aN - A\u500b\u3092B - 1\u500b\u3067\u5206\u5272\u3059\u308b\nind = (N - A) // (B - 1)\nfor i in range(B - 1):\n    opt = []\n    for j in range(ind + (i < (N - A) % (B - 1))):\n        u = L.pop()\n        opt.append(u)\n    res2.append(opt)\n\nres2 = list(reversed(res2))\n\nans = res1\nfor i in range(B - 1):\n    ans += res2[i]\n\ndef lis(A):\n    L = [A[0]]\n    for a in A[1:]:\n        if a > L[-1]:\n            L.append(a)\n        # \u3053\u306eelse\u306b\u5f15\u3063\u304b\u304b\u3063\u305f\u6642\u306b\u30c8\u30e9\u30f3\u30d7\u306e\u30bd\u30fc\u30c8\u304c\u5fc5\u8981\n        else:\n            L[bisect_left(L, a)] = a\n    return len(L)\n\n# print(lis(ans), lis(list(reversed(ans))))\nprint(*ans)", "import numpy as np\nN,A,B = list(map(int,input().split()))\n\nif A+B > N+1:\n  print(\"-1\")\n  return\nif A == 1:\n  if B== N:\n    ans = [i+1 for i in reversed(list(range(N)))]\n    print((*ans))\n    return\n  else:\n    print(\"-1\")\n    return\nif B == 1:\n  if A== N:\n    ans = [i+1 for i in range(N)]\n    print((*ans))\n    return\n  else:\n    print(\"-1\")\n    return\nif A >= B:\n  Flag = True\nelse:\n  Flag = False\n  A,B = B,A\n#print((N+A-1)//A, B)\nif A*B<N:\n  print(\"-1\")\n  return\nelse:\n  L = [1 for _ in range(B)]\n  nokori = N-B\n  for i in range(B):\n    if A-L[i] >0:\n      temp = min(A-L[i],nokori)\n      L[i] += temp\n      nokori -= temp\n    if nokori == 0:\n      break\n  now = 0\n  P = [[] for _ in range(B)]\n  for i,num in enumerate(L):\n    for j in range(num):\n      now += 1\n      P[-i-1].append(now)\n  #print(P)\n  ans = P\n  output = []\n  for i in range(len(ans)):\n    for j in ans[i]:\n      output.append(j)\n  if Flag:\n    print((*output))\n  else:\n    output = output[::-1]\n    print((*output))\n", "n,a,b=map(int,input().split())\nans=[];L=[a]*b;x=a*b-n;ct=1\nfor i in range(b-1,0,-1):\n  y=min(a-1,x);L[i]-=y;x-=y\nfor i in range(b):\n  l=[]\n  for j in range(L[i]):\n    l.append(str(ct))\n    ct+=1\n  ans.append(' '.join(l))\nans.reverse()\nprint(-1 if a+b>n+1 or a*b<n else ' '.join(ans))", "import math\n\nn, a, b = map(int, input().split())\nf = 1\nans = [0] * n\nif max(a, b) > n:\n    f = 0\nelif not math.ceil((n - a) / a) + 1 <= b <= n - a + 1:\n    f = 0\nif f:\n    ans[-a] = 1\n    if not b == 1:\n        c, d = (n - a) // (b - 1), b - 1 - (n - a) % (b - 1)\n        now = n + 1\n        i = 0\n        for j in range(b - 1):\n            now -= c\n            if j >= d:\n                now -= 1\n            ans[i] = now\n            i += c\n            if j >= d:\n                i += 1\n    for i in range(1, n):\n        if ans[i] == 0:\n            ans[i] = ans[i - 1] + 1\nprint(\" \".join(map(str, ans)) if f else -1)", "N,A,B=map(int,input().split())\na=list(range(N-A+1,N+1))\nfor i in range(B-1,0,-1):\n    a.append(i)\nm,M=B,N-A\nfor j in range(A-1):\n    for i in range(min(M,m+B-2),m-1,-1):\n        a.append(i)\n    m=min(M,m+B-2)+1\n    if len(a)==N:\n        break\nprint(*a if len(a)==N else [-1])", "def main():\n    N, A, B = list(map(int, input().split()))\n    if N < A:\n        print((-1))\n        return\n    x = -(-N//A)\n    if B < x or (N-A+1) < B:\n        print((-1))\n        return\n    lst = list(range(1, N+1))\n    seq = [lst[:A]]\n    idx = A\n    for i in range(B-1):\n        rem = B-1-i\n        nidx = idx - (-(N-idx)//rem)\n        seq.append(lst[idx:nidx])\n        idx = nidx\n    ans = []\n    for s in reversed(seq):\n        ans += s\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn,a,b = inm()\nflip = False\nif a<b:\n    a,b = b,a\n    flip = True\nif a*a<n or n<a or a+b-1>n or a*b<n:\n    print(-1)\n    return\nd = [0]*(a+1)\nm = n\nfor i in range(1,a+1):\n    d[i] = min(b,m-(a-i))\n    m -= d[i]\nt = []\nx = 1\nfor z in d[1:]:\n    y = list(range(x,x+z))\n    x += z\n    y.reverse()\n    t.extend(y)\nif flip:\n    t.reverse()\nprint(' '.join([str(x) for x in t]))\n", "n,a,b = map(int, input().split())\nif a*b < n:\n    print(-1)\nelif a+b-1 > n:\n    print(-1)\nelse:\n    if a*b == n:\n        l = [b] * a\n    else:\n        l = [b] * ((n-a) // (b-1)) + [(n-a) % (b-1) + 1] + [1] * (a - 1 - (n-a) // (b-1))\n    j = 0\n    c = 0\n    ans = [0] * n\n    for i in l:\n        c += i\n        for k in range(c, c-i, -1):\n            ans[j] = k\n            j += 1\n    print(\" \".join(map(str, ans)))", "#!/usr/bin/env python3\n\n\ndef make_result(n, a, b):\n    result = []\n    tail = []\n    if n < a * b:\n        if a <= b:\n            k = (a * b - n + b - 2)//(b - 1) - 1\n            tail = [n - i for i in range(k - 1, -1, -1)]\n            n -= k\n            a -= k\n            k = n - (a - 1) * b\n            tail = [n - i for i in range(k)] + tail\n            n -= k\n            a -= 1\n        else:\n            k = (a * b - n + a - 2)//(a - 1) - 1\n            result = [n - i for i in range(k)]\n            n -= k\n            b -= k\n            k = n - a * (b - 1)\n            result += [n - i for i in range(k - 1, -1, -1)]\n            n -= k\n            b -= 1\n\n    for i in range(b):\n        for j in range(a):\n            result.append(n - a * (i + 1) + j + 1)\n\n    return result + tail\n\n\ndef solve(n, a, b):\n    if n < a + b - 1:\n        return '-1'\n    if a * b < n:\n        return '-1'\n\n    return ' '.join(map(str, make_result(n, a, b)))\n\n\ndef main():\n    n, a, b = input().split()\n    n = int(n)\n    a = int(a)\n    b = int(b)\n\n    print((solve(n, a, b)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "def main():\n    n, a, b = list(map(int, input().split()))\n    if b < (n-1)//a+1 or n-a+1 < b:\n        print((-1))\n        return 0\n    for i in range((n-1)//a+1, n-a+2):\n        cnt_a = (i-(n-1)//a)\n        cnt_b = b-cnt_a-1\n        length = n-cnt_a*a-cnt_b\n        if length <= a:\n            break\n    j = n+1\n    ans = []\n    for i in range(cnt_a):\n        j -= a\n        ans += list(range(j, j+a))\n    if cnt_b >= 0:\n        j -= length\n        ans += list(range(j, j+length))+list(range(j-1, 0, -1))\n    print((*ans))\n\n\nmain()\n", "n,a,b = map(int,input().split())\nif not (a+b-1 <= n <= a*b):\n  print(-1)\n  return\nn -= a\nl = list()\nfor i in range(b,a*b+1,b):\n  t = min(n,b-1)\n  l += [i-j for j in range(t+1)]\n  n -= t\nd = dict()\ng = sorted(l)\nfor i,x in enumerate(g,1):\n  d[x] = i\nl = list(map(lambda x:d[x], l))\nprint(*l)", "n,a,b=map(int,input().split())\nans=[];L=[a]*b;x=a*b-n;ct=1\nif a+b>n+1 or x<0:print(-1);return\nfor i in range(b-1):\n y=min(a-1,x);L[i]-=y;x-=y\nfor i in L:\n l=[]\n for j in range(i):\n  l+=[str(ct)];ct+=1\n ans+=[' '.join(l)]\nprint(*reversed(ans))", "import sys\ninput = sys.stdin.readline\n\nN, A, B = map(int, input().split())\nif A + B - 1 > N:\n    print(-1)\n    return\n\na = []\nb = []\nwhile N > 0:\n    if A == 0 or B == 0:\n        print(-1)\n        return\n    if B >= N:\n        b = list(range(N, 0, -1)) + b\n        N = 0\n    else:\n        b = list(range(N, N-B, -1)) + b\n        N -= B\n        if A - 1 >= N:\n            a += list(range(1, N+1))\n            N = 0\n        else:\n            a += list(range(N-A+2, N+1))\n            N -= A - 1\n    A -= 1\n    B -= 1\nans = a + b\nprint(*ans)", "N, A, B = map(int, input().split())\n\nans = list(range(A))\nm = 0\nrest = N - A\nB -= 1\nif rest < B:\n  print(-1)\n  return\nif rest / A > B:\n  print(-1)\n  return\n\nwhile rest > B:\n  s = min(A, rest - B + 1)\n  ans += list(range(m - s, m))\n  m -= s\n  rest -= s\n  B -= 1\n\nans += list(range(m - B, m))[::-1]\nm -= B\n\nprint(\" \".join([str(x - m + 1) for x in ans]))", "n,a,b=map(int,input().split())\nif not a+b-1<=n<=a*b:\n  print(-1)\n  return\nn-=a\nl=list()\nfor i in range(b,a*b+1,b):\n  t=min(n,b-1)\n  l+=[i-j for j in range(t+1)]\n  n-=t\nd=dict()\ng=sorted(l)\nfor i,x in enumerate(g,1):\n  d[x]=i\nl=list(map(lambda x:d[x],l))\nprint(*l)", "n, a, b = map(int, input().split())\nif a+b-1 > n or a*b < n:\n  print(-1)\n  return\nL = [[] for _ in range(b)]\nL[-1] = list(range(1, a+1))\nfor now in range(a+1, n+1):\n  temp = -2 - (now-(a+1))%(b-1)\n  L[temp].append(now)\nfor l in L:\n  print(*l, end=\" \")", "from math import ceil\nN,A,B=map(int,input().split())\nif N+1<A+B or A*B<N:\n  print(-1)\n  return\n\nt=N//B\ns=[]\nwhile N>0:\n  if N==A:\n    s.append(list(range(1,N+1)))\n    break\n  if N-B>=A-1:\n    s.append(list(range(N,N-B,-1)))\n    N-=B\n    A-=1\n    continue  \n  s.append(list(range(N,A-1,-1)))\n  s.append(list(range(1,A)))\n  break\nans=[]\ns.reverse()\nfor a in s:\n  ans.append(' '.join(map(str,a)))\n \nprint(' '.join(ans))", "import sys\nimport collections\nimport itertools\n\nsys.setrecursionlimit(10 ** 8)\ninm = lambda: list(map(int, sys.stdin.readline().split()))\n# debug = lambda *a, **kw: print(*a, **kw, file=sys.stderr)\n\nN, A, B = inm()\n\n\ndef solve():\n    if A + B > N + 1:\n        return None\n    a, b = N, 1\n    b += B - 1\n    a -= B - 1\n    # a=N-B+1, b=B\n\n    s = []\n    s.append(list(range(B, 0, -1)))\n    la = 1\n    p = B + 1  # 1-indexed\n    ra = N - p + 1\n    # debug(f\"{p=} {la=} {ra=} {la+ra=}\")\n    while la + ra > A:\n        p2 = p + min(B, la + ra - A + 1)\n        s.append(list(range(p2 - 1, p - 1, -1)))\n        p = p2\n        la += 1\n        ra = N + 1 - p\n        # debug(f\"{p=} {la=} {ra=} {la+ra=}\")\n        if la == A and ra > 0:\n            return None\n    assert la + ra == A\n    s.append(list(range(p, N + 1)))\n    return list(itertools.chain.from_iterable(s))\n\n\nans = solve()\nif ans is None:\n    print((-1))\nelse:\n    print((*ans))\n", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, A, B = mapint()\nfrom collections import deque\nif A+B-1>N or N>A*B:\n    print(-1)\nelse:\n    blocks = []\n    blocks.append(' '.join(map(str, range(B, 0, -1))))\n    now = B+1\n    rest = N-A+2\n\n    while now:\n        if now>=rest:\n            break\n        if now+B>rest:\n            blocks.append(' '.join(map(str, range(rest, now-1, -1))))\n            rest += 1\n            break\n        blocks.append(' '.join(map(str, range(now+B-1, now-1, -1))))\n        now = now+B\n        rest += 1\n    blocks.append(' '.join(map(str, range(rest, N+1))))\n    print(' '.join(blocks))", "import sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    if not (n + a - 1) // a <= b <= n - a + 1:\n        print((-1))\n        return\n    ans = []\n    ans.append(list(range(1, a + 1)))\n    # print(ans)\n    b -= 1\n    st = a + 1\n    while b:\n        if b == 1:\n            ans.append(list(range(st, n + 1)))\n            break\n        elif n - st + 1 - a >= b - 1:\n            ans.append(list(range(st, st + a)))\n            st += a\n            b -= 1\n        else:\n            ans.append([st])\n            st += 1\n            b -= 1\n    x = []\n    for ak in ans[::-1]:\n        x += ak\n    print((*x))\n\nmain()\n", "N, A, B = list(map(int, input().split()))\n\nbase = list(range(N, 0, -1))\nif A < B:\n    tmp = A\n    A = B\n    B = tmp\n    base.reverse()\n\nif (N - 1) // B + 1 <= A <= N - B + 1:\n    possible = 1\nelse:\n    possible = 0\n\nif possible:\n    split = [A]\n    N_left = N - A\n    for i in range(B-1, 0, -1):\n        split.append((N_left - 1) // i + 1 + split[-1])\n        N_left -= (N_left - 1) // i + 1\n\n    split.insert(0, 0)\n    ans = []\n    for i in range(1, len(split)):\n        rev = base[split[i-1]:split[i]]\n        rev.reverse()\n        ans.extend(rev)\n    print((\" \".join(map(str, ans))))\nelse:\n    print((-1))\n", "n,a,b = map(int,input().split())\nif a+b>n+1 or a*b<n:\n  print(-1)\n  return\nans = []\nfor i in range(1,a+1):\n  ans.append(i*b)\nif b == 1:\n  x = list(range(1,n+1))\n  print(*x)\n  return\nx = (n-a)//(b-1)\ny = (n-a)%(b-1)\nfor i in range(1,b):\n  for j in range(1,x+1):\n    ans.append(j*b-i)\n  if i <= y:\n    ans.append((x+1)*b-i)\nans_true = []\nfor i,x in enumerate(ans):\n  ans_true.append((i+1,x))\nans_true.sort(key=lambda x:x[1])\nx = list(zip(*ans_true))[0]\nprint(*x)", "from collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(10000)\nINF = float(\"inf\")\nYES, Yes, yes, NO, No, no = \"YES\", \"Yes\", \"yes\", \"NO\", \"No\", \"no\"\ndy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]\ndy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]\n\n\ndef inside(y, x, H, W):\n    return 0 <= y < H and 0 <= x < W\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\ndef lis(A):\n    N = len(A)\n    LIS = []\n\n    for i in range(N):\n        index = bisect_left(LIS, A[i])\n        if index >= len(LIS):\n            LIS.append(A[i])\n        else:\n            LIS[index] = A[i]\n\n    return len(LIS)\n\n\ndef func(A):\n    return lis(A), lis([-1 * a for a in A])\n\n\ndef solve(N, A, B):\n    ans = []\n    now = 1\n    num = 0\n    while now <= N:\n        for i in range(min(N, now + B - 1), now - 1, -1):\n            ans.append(i)\n        now += B\n        num += 1\n        rest = N - now + 1\n        if 1 + rest - B < A - num:\n            break\n\n    for _ in range(A - num - 1):\n        ans.append(now)\n        now += 1\n        num += 1\n        if now == N:\n            break\n\n    use = False\n    for i in range(N, now - 1, -1):\n        ans.append(i)\n        use = True\n\n    if num + use != A:\n        return [-1]\n\n    return ans\n\n\ndef check(N, A, B):\n    for p in permutations(list(range(1, N + 1))):\n        if (A, B) == func(list(p)):\n            return list(p)\n    return [-1]\n\n\ndef main():\n    N, A, B = list(map(int, input().split()))\n    ans = solve(N, A, B)\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,a,b = map(int, input().split())\nif a+b > n+1 or a*b < n:\n    print(-1)\n    return\n\nl = []\nused = 0\nfor i in range(a):\n    tmp = []\n    for j in range(b):\n        tmp.append(used+1)\n        used += 1\n        if n-used == a-i-1:\n            break\n    l.extend(tmp[::-1])\nprint(*l)", "n, a, b = map(int, input().split())\n\nmin_b = -((-n) // a)\nif not(min_b <= b and a + b <= n + 1):\n    print(-1)\n    return\n\nans = []\ni = 0\nwhile True:\n    tmp = []\n    break_flag = False\n    for j in range(a):\n        if i * a + j >= n:\n            break_flag = True\n            break\n        tmp.append(i * a + j + 1)\n    if not tmp:\n        break\n    ans.append(tmp)\n    i += 1\n    if break_flag:\n        break\n\nans.sort(reverse=True)\nnokori_b = b - len(ans)\n\nfor i in range(len(ans) - 1):\n    cnt_elems = len(ans[i])\n    if nokori_b >= len(ans[i]) - 1:\n        ans[i].sort(reverse=True)\n        nokori_b -= (len(ans[i]) - 1)\n    else:\n        ans[i] = sorted(ans[i][:nokori_b + 1], reverse=True) + ans[i][nokori_b + 1:]\n        break\n\nres = []\nfor li in ans:\n    for num in li:\n        res.append(num)\nprint(*res)", "r,p=range,print\nn,a,b=map(int,input().split())\nif a+b>n+1or a*b<n:print(-1);return\nl=[[]for i in r(b-1)]+[list(r(1,a+1))]\nfor i in r(a,n):l[-2-(i-a)%(b-1)]+=[i+1]\nfor i in l:p(*i,end=\" \")", "N, A, B = map(int, input().split())\n\nif N-B+1 < A or A < (N + B-1) // B:\n    print(-1)\n    return\n\nres = []\nr = []\ncnt = 0\nfor i in range(N):\n    r.append(N-i)\n    if N-i <= A-cnt or len(r) == B:\n        res.append(r)\n        r = []\n        cnt += 1\n\nif r:\n    res.append(r)\nans = []\nfor r in reversed(res):\n    ans.extend(r)\nprint(*ans)", "N,A,B=map(int,input().split())\nif A+B-1>N or A*B<N:\n  print(-1)\n  return\nQ=[[] for i in range(B)]\nfor i in range(N):\n  Q[i//A].append(i+1)\nQ=Q[::-1]\nX=N-1\nfor i in range(B):\n  if len(Q[i])==0:\n    Q[i].append(Q[-(X//A+1)][-1])\n    del Q[-(X//A+1)][-1]\n    X-=1\n  else:\n    break\nP=[]\nfor i in range(B):\n  for j in range(len(Q[i])):\n    P.append(Q[i][j])\nprint(*P)", "#!/usr/bin/env python3\n\ndef solve(n, a, b):\n    if a + b - 1 > n:\n        return [ -1 ]\n    if a * b < n:\n        return [ -1 ]\n\n    # construct in \\omega^2\n    xs = []\n    xs += [ (0, - j) for j in range(b) ]\n    for i in range(1, a):\n        xs += [ (i, 0) ]\n        j = 1\n        while j < b and len(xs) + (a - i - 1) < n:\n            xs += [ (i, - j) ]\n            j += 1\n\n    # coordinate compression\n    f = {}\n    for x in sorted(xs):\n        k = len(f)\n        f[x] = k\n    return [ f[x] + 1 for x in xs ]\n\n\nprint((*solve(*list(map(int, input().split())))))\n\n", "import sys\nfrom bisect import bisect\n\ndef Longest_Increasing_Subsequence(N,lst):\n    #\u914d\u5217\u306e\u9577\u3055\u304cN\u3001\u914d\u5217\u304clst\u3067\u4e0e\u3048\u3089\u308c\u308b\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u8fd4\u3059\n    #O(NlogN)\n    \n    MM=max(lst)+1\n    data=[MM]*(N+1)\n    #MM\u306f\u914d\u5217\u306e\u6700\u5927\u5024\u3068\u3059\u308b\n    #inf\u3060\u3068\u8a08\u7b97\u91cf\u304c\u7d50\u69cb\u5927\u304d\u304f\u306a\u308b\u305f\u3081\n    \n    data[0]=0\n    for i in range(N):\n        b=bisect(data,lst[i])\n        data[b]=lst[i]\n\n    ANS=1\n    for i in range(1,N+1):\n        if data[i]!=MM:\n            ANS=i\n    \n    return ANS\n\ndef Longest_Decreasing_Subsequence(N,lst):\n    #\u914d\u5217\u306e\u9577\u3055\u304cN\u3001\u914d\u5217\u304clst\u3067\u4e0e\u3048\u3089\u308c\u308b\u6700\u9577\u6e1b\u5c11\u90e8\u5206\u5217\u3092\u8fd4\u3059\n    #O(NlogN)\n    \n    MM=max(lst)+1\n    data=[MM]*(N+1)\n    #MM\u306f\u914d\u5217\u306e\u6700\u5927\u5024\u3068\u3059\u308b\n    \n    #\u914d\u5217\u3092\u9006\u306b\u3057\u3066\u3001\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u6c42\u3081\u308c\u3070\u3044\u3088\u3044\n    lst=lst[::-1]\n    \n    data[0]=0\n    for i in range(N):\n        b=bisect(data,lst[i])\n        data[b]=lst[i]\n\n    ANS=1\n    for i in range(1,N+1):\n        if data[i]!=MM:\n            ANS=i\n    \n    return ANS\n\n\n\nN,A,B=map(int,input().split())\nAAA,BBB=A,B\n\nif A>N or B>N:\n    print(-1)\n    return\nif B>N-A+1:\n    print(-1)\n    return\n\nans=[]\nL=1\nR=N\nflag=[0]*(N+1)\nflag[0]=1\n\nif A<B:\n    B-=1\n    while A>0 and B>0 and len(ans)<N:\n        for i in range(max(1,R-A+1),R+1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        R-=A\n        A-=1\n        for i in range(min(N,L+B-1),L-1,-1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        L+=B\n        B-=1\n        \n    for i in range(min(N,L+B-1),L-1,-1):\n        if flag[i]==0:\n            flag[i]=1\n            ans.append(i)\n\nelif A==B:\n    B-=1\n    while A>0 and B>0 and len(ans)<N:\n        for i in range(max(1,R-A+1),R+1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        R-=A\n        A-=1\n        for i in range(min(N,L+B-1),L-1,-1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        L+=B\n        B-=1\n        \n    for i in range(max(1,R-A+1),R+1):\n        if flag[i]==0:\n            flag[i]=1\n            ans.append(i)\n\nelse:\n    A-=1\n    while A>0 and B>0 and len(ans)<N:\n        for i in range(min(N,L+B-1),L-1,-1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        L+=B\n        B-=1\n        for i in range(max(1,R-A+1),R+1):\n            if flag[i]==0:\n                flag[i]=1\n                ans.append(i)\n        R-=A\n        A-=1\n    \n    for i in range(max(1,R-A+1),R+1):\n        if flag[i]==0:\n            flag[i]=1\n            ans.append(i)\n\nif len(ans)>=N:\n    ans=ans[:N]\n    if  Longest_Increasing_Subsequence(N,ans)==AAA and Longest_Decreasing_Subsequence(N,ans)==BBB:\n        print(*ans)\n    else:\n        print(-1)\nelse:\n    print(-1)", "r,p=range,print\nn,a,b=map(int,input().split())\nif a+b>n+1or a*b<n:print(-1);return\nl=[[]for i in r(b-1)]+[list(r(1,a+1))]\nfor i in r(a+1,n+1):l[-2-(i-a-1)%(b-1)].append(i)\nfor i in l:p(*i,end=\" \")", "import sys\ndef inpl(): return [int(i) for i in input().split()]\nN, A, B = inpl()\nrev = (A < B)\nB ,A = sorted([B, A])\nif B < -(-N//A) or A+B-1 > N:\n    print(-1)\n    return\nst = list(range(1,N+1))\nif B == 1:\n    ans = st\nelif 2*A > N:\n    ans = st[A:N-B+1] + st[N-1:N-B:-1] + st[0:A]\nelse:\n    n = N//A\n    x = B+(-N//A)+1\n    ans = st[n*A:N] + st[(n-1)*A:n*A-x] + st[n*A-1:n*A-x-1:-1]\n    for i in range(2,n+1):\n        ans += st[(n-i)*A:(n-i+1)*A]\nif rev:\n    ans = [N+1-i for i in ans]\nprint(*ans)", "n, a, b = map(int, input().split())\nif a+b-1 > n or a*b < n:\n\tprint(-1)\nelif b == 1:\n\tprint(*list(range(1, n+1)))\nelse:\n\tans = list(range(n-a+1, n+1))\n\tnum = b-1\n\tmod = n-a - (n-a)//(b-1) * (b-1)\n\tsize1 = (n-a)//(b-1)\n\tsize2 = size1 + 1\n\tmi = n-a\n\tfor i in range(num):\n\t\tif i < num-mod:\n\t\t\tans += list(range(mi - size1 + 1, mi + 1))\n\t\t\tmi = mi - size1\n\t\telse:\n\t\t\tans += list(range(mi - size2 + 1, mi + 1))\n\t\t\tmi = mi - size2\n\tprint(*ans)", "N, A, B = map(int, input().split())\nif A * B < N or A + B > N + 1:\n    print(-1)\n    return\nX = [[i * B] for i in range(A)]\ns = N - A\ni = 0\nwhile s:\n    if len(X[i]) >= B:\n        i += 1\n    X[i].append(X[i][-1] - 1)\n    s -= 1\nY = []\nfor x in X:\n    for xx in x:\n        Y.append(xx)\n\nD = {a: i for i, a in enumerate(sorted(Y))}\nY = [D[y] + 1 for y in Y]\nprint(*Y)", "n,a,b = map(int,input().split())\n\nif(n > a*b)|(a+b > n+1):\n    print(-1)\n    return\nif(a==1)|(b==1):\n    if(b==n):\n        ans = list(range(n,0,-1))\n        print(' '.join(map(str,ans)))\n    elif(a==n):\n        ans = list(range(1,n+1))\n        print(' '.join(map(str,ans)))\n    else:\n        print(-1)\n    return\n\nans = []\ntop = n\nwhile(top > 0):\n    if(top-a >= b):\n        for i in range(top-a+1,top+1):\n            ans.append(i)\n        top -= a\n        b -= 1\n        continue\n    a = top-b+1\n    for i in range(top-a+1,top+1):\n        ans.append(i)\n    for i in range(b-1,0,-1):\n        ans.append(i)\n    break\n\nprint(' '.join(map(str,ans)))", "def solve(n, a, b):\n    if n < a + b - 1:\n        return [-1]\n    if n > a * b:\n        return [-1]\n    if b == 1:\n        return list(range(1, n + 1))\n    if a == 1:\n        return list(range(n, 0, -1))\n\n    ans = list(range(b, 0, -1))\n    ans.extend(list(range(n - a + 2, n + 1)))\n\n    t = b\n    for t in range(2 * b - 1, n - a + 1, b - 1):\n        ans.extend(list(range(t, t - b + 1, -1)))\n    ans.extend(list(range(n - a + 1, t, -1)))\n    return ans\n\n\nn, a, b = list(map(int, input().split()))\nprint((*solve(n, a, b)))\n", "N,A,B = map(int,input().split())\nif A + B > N + 1 or A * B < N:\n\tprint(-1)\n\treturn\nswap = False\nif A < B:\n\tB,A = A,B\n\tswap = True\n\nbase = [i for i in range(1,A+1)]\nrest = N - A\nroop = (N + A - 1) // A\nif roop == B:\n\ta = A + 1\n\tpre = []\n\twhile a <= N:\n\t\tpre = [i for i in range(a, min(N+1, a+A))] + pre\n\t\ta += A\nelse:\n\tpre = [i for i in range(A+B-1, A, -1)]\n\tr = []\n\ta = A+B\n\twhile a <= N:\n\t  r = [i for i in range(a, min(N+1, a+A-1))] + r\n\t  a += A-1\n\tpre = pre + r\nans = pre + base\nif swap:\n\tans = [N-i+1 for i in ans]\nprint(\" \".join(map(str, ans)))", "N,A,B=list(map(int,input().split()))\n\nif A*B<N or A+B-1>N:\n    print((-1))\n    return\n\nrev=(B>A)\nA,B=max(A,B),min(A,B)\nB-=1\nM=N\nans1=[]\nans2=[]\nwhile M>0:\n    if len(ans1)==len(ans2):\n        temp=[i for i in range(M+1-A,M+1)]\n        ans1.append(temp)\n        M=M-A\n        A-=1\n    else:\n        temp=[i for i in range(M+1-B,M+1)]\n        temp=temp[::-1]\n        ans2.append(temp)\n        M=M-B\n        B-=1\n\nans2=ans2[::-1]\nres=[]\nfor L in ans1:\n    res+=L\nfor L in ans2:\n    res+=L\n\nres=[val for val in res if val>0]\nif rev:\n    res=res[::-1]\nprint((*res))\n"]
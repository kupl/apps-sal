["import math\nfrom collections import deque\n\ndef main():\n\tn, m, k = list(map(int, input().split()))\n\tgrid = [\"\" for _ in range(n)]\n\tx, y = 0, 0\n\n\tfor i in range(n):\n\t\tgrid[i] = input()\n\t\tif 'X' in grid[i]:\n\t\t\tx, y = i, grid[i].index('X')\n\n\tif k % 2 == 1:\n\t\tprint(\"IMPOSSIBLE\")\n\t\treturn\n\n\tdx = [1, 0, 0, -1]\t\n\tdy = [0, -1, 1, 0]\n\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \"DLRU\")}\n\trev_names = {x1: y1 for x1, y1 in zip(\"DLRU\", \"URLD\")}\n\n\tdef ok(x, y):\n\t\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\n\t\n\n\tdef bfs(x, y):\n\t\tMAX_DIST = (1 << 20)\n\t\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\n\t\tdist[x][y] = 0\n\t\tq = deque()\n\t\tq.append((x, y))\n\n\t\twhile len(q) > 0:\n\t\t\tx, y = q.popleft()\n\n\t\t\tfor x0, y0 in zip(dx, dy):\n\t\t\t\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\n\t\t\t\t\tdist[x + x0][y + y0] = dist[x][y] + 1\n\t\t\t\t\tq.append((x + x0, y + y0))\t\t\n\n\t\treturn dist\t\t\t\n\n\tpath = []\n\tx_start, y_start = x, y\n\n\tdist = bfs(x_start, y_start)\n\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1):\n\t\t\t\tpath.append(names.get((x1, y1)))\t\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(\"IMPOSSIBLE\")\n\t\t\treturn\n\n\tmoves = k // 2\t\t\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\n\t\t\t\tpath.append(names.get((x1, y1)))\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tmoves -= 1\n\t\t\t\tbreak\n\n\tprint(\"\".join(x for x in path))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import math\nfrom collections import deque\n\ndef main():\n\tn, m, k = list(map(int, input().split()))\n\tgrid = [\"\" for _ in range(n)]\n\tx, y = 0, 0\n\n\tfor i in range(n):\n\t\tgrid[i] = input()\n\t\tif 'X' in grid[i]:\n\t\t\tx, y = i, grid[i].index('X')\n\n\tif k % 2 == 1:\n\t\tprint(\"IMPOSSIBLE\")\n\t\treturn\n\n\tdx = [1, 0, 0, -1]\t\n\tdy = [0, -1, 1, 0]\n\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \"DLRU\")}\n\trev_names = {x1: y1 for x1, y1 in zip(\"DLRU\", \"URLD\")}\n\n\tdef ok(x, y):\n\t\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\n\t\n\n\tdef bfs(x, y):\n\t\tMAX_DIST = (1 << 20)\n\t\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\n\t\tdist[x][y] = 0\n\t\tq = deque()\n\t\tq.append((x, y))\n\n\t\twhile len(q) > 0:\n\t\t\tx, y = q.popleft()\n\n\t\t\tfor x0, y0 in zip(dx, dy):\n\t\t\t\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\n\t\t\t\t\tdist[x + x0][y + y0] = dist[x][y] + 1\n\t\t\t\t\tq.append((x + x0, y + y0))\t\t\n\n\t\treturn dist\t\t\t\n\n\tpath = []\n\tx_start, y_start = x, y\n\n\tdist = bfs(x_start, y_start)\n\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1):\n\t\t\t\tpath.append(names.get((x1, y1)))\t\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(\"IMPOSSIBLE\")\n\t\t\treturn\n\n\tmoves = k // 2\t\t\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\n\t\t\t\tpath.append(names.get((x1, y1)))\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tmoves -= 1\n\t\t\t\tbreak\n\n\tprint(\"\".join(x for x in path))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "from queue import Queue\nimport sys\n#sys.stdin = open('input.txt')\n\nn, m, k = [int(x) for x in input().split(' ')]\n\nif k&1:\n  print('IMPOSSIBLE')\n  return\n\ns = [None]*n\nfor i in range(n):\n  s[i] = [None]*m\n  t = input()\n  for j in range(m):\n    s[i][j] = t[j]\n    if t[j] == 'X': x, y = j, i\n\ndef bfs(x, y):\n  res = [[10000000]*m for i in range(n)]\n  if s[y][x] == '*': return res\n  q = Queue()\n  q.put((x, y))\n  step = 0\n\n  def add(x, y):\n    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return\n    q.put((x, y))\n    res[y][x] = step+1\n\n  res[y][x] = step\n\n  while not q.empty():\n    x, y = q.get()\n    step = res[y][x]\n    #print('-')\n    if y < n-1: add(x, y+1) #D\n    if x > 0: add(x-1, y)   #L\n    if x < m-1: add(x+1, y) #R\n    if y > 0: add(x, y-1)   #U\n  return res\n\nres = bfs(x, y)\n\n\npath = []\nadd = lambda s: path.append(s)\nfor i in range(k):\n  step = k-i\n  #print(step, (y, x), k-i)\n  if y < n-1 and res[y+1][x] <= step: #D\n    add('D')\n    y = y+1\n  elif x > 0 and res[y][x-1] <= step: #L\n    add('L')\n    x = x-1\n  elif x < m-1 and res[y][x+1] <= step: #R\n    add('R')\n    x = x+1\n  elif y > 0 and res[y-1][x] <= step: #U\n    add('U')\n    y = y-1\n  else:\n    print('IMPOSSIBLE')\n    return\n\nprint(str.join('', path))\n", "import math\nfrom collections import deque\n\ndef main():\n\tn, m, k = list(map(int, input().split()))\n\tgrid = [\"\" for _ in range(n)]\n\tx, y = 0, 0\n\n\tfor i in range(n):\n\t\tgrid[i] = input()\n\t\tif 'X' in grid[i]:\n\t\t\tx, y = i, grid[i].index('X')\n\n\tif k % 2 == 1:\n\t\tprint(\"IMPOSSIBLE\")\n\t\treturn\n\n\tdx = [1, 0, 0, -1]\t\n\tdy = [0, -1, 1, 0]\n\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \"DLRU\")}\n\trev_names = {x1: y1 for x1, y1 in zip(\"DLRU\", \"URLD\")}\n\n\tdef ok(x, y):\n\t\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\n\t\n\n\tdef bfs(x, y):\n\t\tMAX_DIST = (1 << 20)\n\t\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\n\t\tdist[x][y] = 0\n\t\tq = deque()\n\t\tq.append((x, y))\n\n\t\twhile len(q) > 0:\n\t\t\tx, y = q.popleft()\n\n\t\t\tfor x0, y0 in zip(dx, dy):\n\t\t\t\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\n\t\t\t\t\tdist[x + x0][y + y0] = dist[x][y] + 1\n\t\t\t\t\tq.append((x + x0, y + y0))\t\t\n\n\t\treturn dist\t\t\t\n\n\tpath = []\n\tx_start, y_start = x, y\n\n\tdist = bfs(x_start, y_start)\n\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1):\n\t\t\t\tpath.append(names.get((x1, y1)))\t\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(\"IMPOSSIBLE\")\n\t\t\treturn\n\n\tmoves = k // 2\t\t\n\tfor i in range(k // 2):\n\t\tfor x1, y1 in zip(dx, dy):\n\t\t\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\n\t\t\t\tpath.append(names.get((x1, y1)))\n\t\t\t\tx += x1\n\t\t\t\ty += y1\n\t\t\t\tmoves -= 1\n\t\t\t\tbreak\n\n\tprint(\"\".join(x for x in path))\n\ndef __starting_point():\n\tmain()\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "#https://codeforces.com/contest/769/problem/C\nimport collections\nlis = input().split()\nn,m,k = int(lis[0]),int(lis[1]),int(lis[2])\nempty = [[False for i in range(m)] for j in range(n)]\nmainrow,maincol = 0,0\nfor i in range(n):\n\ts = input()\n\tfor j in range(m):\n\t\tif(s[j]=='.'):\n\t\t\tempty[i][j] = True\n\t\telif (s[j]=='X'):\n\t\t\tempty[i][j] = True\n\t\t\tmainrow = i\n\t\t\tmaincol = j\nd = [[-1 for i in range(m)] for j in range(n)]\nque = collections.deque([(mainrow,maincol)])\nd[mainrow][maincol] = 0\nchanges = [(1,0),(-1,0),(0,1),(0,-1)]\nwhile(que):\n\t(x,y) = que.popleft()\n\tfor (i,j) in changes:\n\t\txnex = x+i\n\t\tynex = y+j\n\t\tif(xnex>=0 and xnex<n and ynex>=0 and ynex<m and empty[xnex][ynex] and d[xnex][ynex]==-1):\n\t\t\td[xnex][ynex]=d[x][y]+1\n\t\t\tque.append((xnex,ynex))\ncurrrow = mainrow\ncurrcol = maincol\nlis = []\nif(k%2==0):\n\tflag = False\n\tfor (i,j) in changes:\n\t\txnex = mainrow+i\n\t\tynex = maincol+j\n\t\tif(xnex>=0 and xnex<n and ynex>=0 and ynex<m and empty[xnex][ynex]):\n\t\t\tflag = True\n\tif(flag):\n\t\twhile(k):\n\t\t\tif(currrow+1<n and empty[currrow+1][currcol] and d[currrow+1][currcol]<k):\n\t\t\t\tlis.append('D')\n\t\t\t\tcurrrow+=1\n\t\t\telif(currcol-1>=0 and empty[currrow][currcol-1] and d[currrow][currcol-1]<k):\n\t\t\t\tlis.append('L')\n\t\t\t\tcurrcol-=1\n\t\t\telif(currcol+1<m and empty[currrow][currcol+1] and d[currrow][currcol+1]<k):\n\t\t\t\tlis.append('R')\n\t\t\t\tcurrcol+=1\n\t\t\telse:\n\t\t\t\tlis.append('U')\n\t\t\t\tcurrrow-=1\n\t\t\tk-=1\n\t\tif(currcol == maincol and currrow == mainrow):\n\t\t\tprint(\"\".join(lis))\n\t\telse:\n\t\t\tprint(\"IMPOSSIBLE WHY\")\n\telse:\n\t\tprint(\"IMPOSSIBLE\")\nelse:\n\tprint(\"IMPOSSIBLE\")"]
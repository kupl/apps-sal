["class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         to_return = []\n         self.backtrack(to_return, [], k, n, 1)\n         return to_return\n     \n     def backtrack(self, to_return, temp, k, n, start):\n         total = sum(temp)\n         \n         if total > n:\n             return\n         if len(temp) == k and total == n:\n             to_return.append(temp[:])\n             return\n         \n         for i in range(start, 10):\n             temp.append(i)\n             self.backtrack(to_return, temp, k, n, i + 1)\n             temp.pop()", "class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         self.dfs(range(1,10), k, n, 0, [], res)\n         return res\n \n     def dfs(self, nums, k, n, index, path, res):\n         if k == 0 and n == 0:\n             res.append(path)\n             return \n         for i in range(index, len(nums)):\n             self.dfs(nums, k-1, n- nums[i], i + 1, path+[nums[i]], res)", "class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n \n         res = []\n         temp = []\n         idx = 1\n         self.backtracking(res, temp, n, k, idx)\n         \n         return res\n     \n     def backtracking(self, res, temp, n, k, idx):\n         if len(temp) == k and n == 0:\n             res.append(temp[:])\n             return\n         \n         for i in range(idx, 10):\n             temp.append(i)\n             self.backtracking(res, temp, n - i, k, i + 1)\n             temp.pop()\n             \n", "class Solution:\n     def combinationSum3(self, k, n):\n         res, com = [], []\n         self.combination(n, res, com, 1, k)\n         return res\n     \n     def combination(self, target, res, com, begin, k):\n         for i in range(begin, target + 1 if target < 9 else 10):\n             com.append(i)\n             if i == target and k == 1: res.append(com[:])\n             self.combination(target - i, res, com, i + 1, k - 1)\n             com.pop()\n", "class Solution:\n     result = []\n     def combinationSum3Util(self, candidates, current_subset, k, target, start):\n         if target == 0 and k == 0:\n             Solution.result.append(current_subset)\n         \n         elif target != 0 and k != 0:\n             for i in range(start, len(candidates)):\n                 current_candidate_num = candidates[i]\n                 if i > start and candidates[i] == candidates[i-1]:\n                     continue\n                     \n                 if target - current_candidate_num >= 0:\n                     next_subset = current_subset.copy()\n                     next_subset.append(current_candidate_num)\n                     self.combinationSum3Util(candidates, next_subset, k-1, target - current_candidate_num, i+1)\n                 else:\n                     return\n         \n         else:   # target == 0 and k != 0     OR     target != 0 and k == 0\n             return\n                 \n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         Solution.result = []\n         \n         if k == 0:\n             return [[]]\n         \n         candidates = [x for x in range(1, 10)]\n         current_subset = []\n         self.combinationSum3Util(candidates, current_subset, k, n, 0)\n         return Solution.result\n", "class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         \n         if(n > 45): return []\n         res = []\n         def rev(start, s, count, one):\n             if(count == k and s == n):\n                 res.append(one[:])\n                 return\n             if(count == k or s == n):\n                 return\n             for i in range(start, 10):\n                 if(s + i > n): return\n                 rev(i+1, s+i, count+1, one+[i])\n         rev(1, 0, 0, [])\n         return res", "class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         self.dfs(res, [], 0, 0, 1, k, n)\n         return res\n     \n     def dfs(self, res, cur, d, s, b, k, n):\n         if d == k and s == n:\n             res.append(cur)\n             return\n         \n         for i in range(b, 10):\n             self.dfs(res, cur + [i], d + 1, s + i, i + 1, k, n)", "class Solution:\n     def combinationSum3(self, k, n):\n         \"\"\"\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         \"\"\"\n         import functools;\n         return [ c for c in functools.reduce(lambda nexts, _ : [next_+[first] for next_ in nexts for first in range(next_[-1]+1 if next_ else 1, 10)], range(k), [[]]) if sum(c) == n]"]
["import sys\nimport heapq, functools, collections\nimport math, random\nfrom collections import Counter, defaultdict\n\n# available on Google, not available on Codeforces\n# import numpy as np\n# import scipy\n\nimport heapq as hq\nimport math\n\ndef dijkstra(G, s):\n    n = len(G)\n    visited = [False]*n\n    weights = [math.inf]*n\n    path = [None]*n\n    queue = []\n    weights[s] = 0\n    hq.heappush(queue, (0, s))\n    while len(queue) > 0:\n        g, u = hq.heappop(queue)\n        visited[u] = True\n        for v, w in G[u]:\n            if not visited[v]:\n                f = g + w\n                if f < weights[v]:\n                    weights[v] = f\n                    path[v] = u\n                    hq.heappush(queue, (f, v))\n    return path, weights\n\n\ndef solve(grid,sx,sy,ex,ey):  # fix inputs here\n    console(\"----- solving ------\")\n    # console(grid,sx,sy,ex,ey)\n\n    minres = abs(sx-ex) + abs(sy-ey)\n    console(minres)\n    if grid == []:\n        return minres\n\n    d = defaultdict(list)\n    grid = [(i,x,y) for i,(x,y) in enumerate(grid)]\n\n    # x-order\n    grid = sorted(grid, key=lambda x: x[1])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,x2-x1))\n        d[i2].append((i1,x2-x1))\n\n    grid = sorted(grid, key=lambda x: x[2])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,y2-y1))\n        d[i2].append((i1,y2-y1))\n\n    for i,x,y in grid:\n        # start to x-axis\n        d[-2].append((i,abs(x-sx)))\n\n        # start to y-axis\n        d[-2].append((i,abs(y-sy)))\n\n        # point to destination\n        d[i].append((-1, abs(x-ex) + abs(y-ey)))\n\n    d[-1] = []\n    console(list(d.keys()))\n\n    idxs = {k:i for i,k in enumerate(d.keys())}\n    G = [[] for _ in range(len(idxs))]\n\n    for e,vrr in list(d.items()):\n        for v,cost in vrr:\n            G[idxs[e]].append((idxs[v],cost))\n    # console(G)\n\n    _,costs = dijkstra(G, idxs[-2])\n    \n\n    res = costs[idxs[-1]]\n\n    return min(minres, res)\n\n\ndef console(*args):  # the judge will not read these print statement\n    # print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n    return\n\n# fast read all\ninp = sys.stdin.readlines()\nfor case_num in [1]:\n    # read line as a string\n    # strr = input()\n\n    # read line as an integer\n    # k = int(input())\n    \n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    # read one line and parse each word as an integer\n    _, nrows = list(map(int,inp[0].split()))\n    sx,sy,ex,ey = list(map(int,inp[1].split()))\n\n    currow = 2\n    # read matrix and parse as integers (after reading read nrows)\n    # lst = list(map(int,input().split()))\n    # nrows = lst[0]  # index containing information, please change\n    grid = []\n    for _ in range(nrows):\n        grid.append(list(map(int,inp[currow].split())))\n        currow += 1\n\n    res = solve(grid,sx,sy,ex,ey)  # please change\n    \n    # Google - case number required\n    # print(\"Case #{}: {}\".format(case_num+1, res))\n\n    # Codeforces - no case number required\n    print(res)\n", "# V: \u9802\u70b9\u6570\n# g[v] = {(w, cost)}:\n#     \u9802\u70b9v\u304b\u3089\u9077\u79fb\u53ef\u80fd\u306a\u9802\u70b9(w)\u3068\u305d\u306e\u30b3\u30b9\u30c8(cost)\n# r: \u59cb\u70b9\u306e\u9802\u70b9\n\nfrom heapq import heappush, heappop\nimport sys;input=sys.stdin.readline\nINF = 10**10\ndef dijkstra(N, G, s):\n    dist = [INF] * N\n    que = [(0, s)]\n    dist[s] = 0\n    while que:\n        c, v = heappop(que)\n        if dist[v] < c:\n            continue\n        for t, cost in G[v]:\n            if dist[v] + cost < dist[t]:\n                dist[t] = dist[v] + cost\n                heappush(que, (dist[t], t))\n    return dist[1]\nN, M = list(map(int, input().split()))\nsx, sy, fx, fy = list(map(int, input().split()))\nvs = []\ng = [set() for _ in range(M+2)]\nfor i in range(M):\n    x, y = list(map(int, input().split()))\n    g[0].add((i+2, min(abs(x-sx), abs(y-sy))))\n    g[i+2].add((1, abs(x-fx)+abs(y-fy)))\n    vs.append((i+2, x, y))\n\n#tg = [dict() for _ in range(M+2)]\nvs.sort(key=lambda x:(x[1],x[2]))\nfor (b, bx, by), (i, x, y) in zip(vs, vs[1:]):\n    c = min(x-bx, abs(y-by))\n    g[i].add((b, c))\n    g[b].add((i, c))\n\nvs.sort(key=lambda x:(x[2],x[1]))\nfor (b, bx, by), (i, x, y) in zip(vs, vs[1:]):\n    c = min(abs(x-bx), y-by)\n    g[i].add((b, c))\n    g[b].add((i, c))\n\n#print(g)\nprint(min(dijkstra(M+2, g, 0), abs(fy-sy)+abs(fx-sx)))\n", "import sys\ninput = sys.stdin.readline\nimport heapq\nfrom operator import itemgetter\n\nn,m=list(map(int,input().split()))\nsx,sy,fx,fy=list(map(int,input().split()))\nW=[list(map(int,input().split()))+[i] for i in range(m)]+[[sx,sy,m]]\n\nANS=[n**2]\n\ndef ans(time,x,y):\n    ANS[0]=min(ANS[0],time+abs(fx-x)+abs(fy-y))\n\nWX=sorted(W,key=itemgetter(0))\nWY=sorted(W,key=itemgetter(1))\n\nEDGE=[[] for i in range(m+1)]\nTIME=[1<<60]*(m+1)\nTIME[m]=0\n\nfor i in range(1,m+1):\n    x0,y0,m0=WX[i-1]\n    x1,y1,m1=WX[i]\n\n    EDGE[m0].append((m1,min(abs(x0-x1),abs(y0-y1))))\n    EDGE[m1].append((m0,min(abs(x0-x1),abs(y0-y1))))\n\n    x0,y0,m0=WY[i-1]\n    x1,y1,m1=WY[i]\n\n    EDGE[m0].append((m1,min(abs(x0-x1),abs(y0-y1))))\n    EDGE[m1].append((m0,min(abs(x0-x1),abs(y0-y1))))\n\nQ=[(0,m)]\nwhile Q:\n    time,town=heapq.heappop(Q)\n    if time>TIME[town]:\n        continue\n    ans(time,W[town][0],W[town][1])\n\n    for to,cost in EDGE[town]:\n        if TIME[to]>TIME[town]+cost:\n            TIME[to]=TIME[town]+cost\n            heapq.heappush(Q,(TIME[to],to))\n\nprint(ANS[0])\n", "import sys, io, os\nimport math\nimport heapq as hq\nimport random\nfrom collections import defaultdict\n\n# available on Google, not available on Codeforces\n# import numpy as np\n# import scipy\n\nimport sys\nfrom os import path\n\ndef console(*args):  # the judge will not read these print statement\n    # print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n    pass\n\n# if Codeforces environment\nif path.exists('input.txt'):\n    sys.stdin = open(\"input.txt\",\"r\")\n    sys.stdout = open(\"output.txt\",\"w\")\n\n    def console(*args):\n        pass\n\ninp = sys.stdin.readlines()\n# inp = io.BytesIO(os.read(0,os.fstat(0).st_size)).readlines()\n\n\ndef solve(*args):\n    console(\"----- solving ------\")\n    console(*args)\n    console(\"----- ------- ------\")\n    return solve_(*args)\n\n\ndef solve_(grid,sx,sy,ex,ey):  # fix inputs here\n    console(\"----- solving ------\")\n    # console(grid,sx,sy,ex,ey)\n\n    minres = abs(sx-ex) + abs(sy-ey)\n    console(minres)\n    if grid == []:\n        return minres\n\n    d = defaultdict(list)\n    grid = [(i,x,y) for i,(x,y) in enumerate(grid)]\n\n    # x-order\n    grid = sorted(grid, key=lambda x: x[1])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,x2-x1))\n        d[i2].append((i1,x2-x1))\n\n    grid = sorted(grid, key=lambda x: x[2])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,y2-y1))\n        d[i2].append((i1,y2-y1))\n\n    for i,x,y in grid:\n        # start to x-axis\n        d[-2].append((i,abs(x-sx)))\n\n        # start to y-axis\n        d[-2].append((i,abs(y-sy)))\n\n        # point to destination\n        d[i].append((-1, abs(x-ex) + abs(y-ey)))\n\n    d[-1] = []\n    console(list(d.keys()))\n\n    idxs = {k:i for i,k in enumerate(d.keys())}\n    G = [[] for _ in range(len(idxs))]\n\n    for e,vrr in list(d.items()):\n        for v,cost in vrr:\n            G[idxs[e]].append((idxs[v],cost))\n\n    return min(minres, dijkstra_with_preprocessing(d, -2, -1))\n\n\ndef dijkstra_with_preprocessing(map_from_node_to_nodes_and_costs, source, target):\n    d = map_from_node_to_nodes_and_costs\n    if target not in d:\n        d[-1] = []\n\n    # assign indexes\n    idxs = {k:i for i,k in enumerate(d.keys())}\n\n    # population array of nodes and costs\n    G = [[] for _ in range(len(idxs))]\n    for e,vrr in list(d.items()):\n        for v,cost in vrr:\n            G[idxs[e]].append((idxs[v],cost))\n\n    _,costs = dijkstra(G, idxs[source])\n    return costs[idxs[target]]\n\n\ndef dijkstra(G, s):\n    n = len(G)\n    visited = [False]*n\n    weights = [math.inf]*n\n    path = [None]*n\n    queue = []\n    weights[s] = 0\n    hq.heappush(queue, (0, s))\n    while len(queue) > 0:\n        g, u = hq.heappop(queue)\n        visited[u] = True\n        for v, w in G[u]:\n            if not visited[v]:\n                f = g + w\n                if f < weights[v]:\n                    weights[v] = f\n                    path[v] = u\n                    hq.heappush(queue, (f, v))\n    return path, weights\n\n\n\n# fast read all\nfor case_num in [1]:\n    # read line as a string\n    # strr = input()\n\n    # read line as an integer\n    # k = int(input())\n    \n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    # read one line and parse each word as an integer\n    _, nrows = list(map(int,inp[0].split()))\n    sx,sy,ex,ey = list(map(int,inp[1].split()))\n\n    # currow = 2\n    # read matrix and parse as integers (after reading read nrows)\n    # lst = list(map(int,input().split()))\n    # nrows = lst[0]  # index containing information, please change\n    grid = []\n    for z in range(nrows):\n        grid.append(list(map(int,inp[z+2].split())))\n\n    res = solve(grid,sx,sy,ex,ey)  # please change\n    \n    # Google - case number required\n    # print(\"Case #{}: {}\".format(case_num+1, res))\n\n    # Codeforces - no case number required\n    print(res)\n\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nimport heapq\n\ndef dijkstra(n, s, edges):\n    hq = [(0, s)]\n    cost = [float('inf')] * n\n    cost[s] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v]:\n            continue\n        for d, u in edges[v]:\n            tmp = d + cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                heapq.heappush(hq, (tmp, u))\n    return cost[1]\n\ndef main():\n    n, m = map(int, input().split())\n    sx, sy, fx, fy = map(int, input().split())\n    xy = [list(map(int, input().split())) + [i + 2] for i in range(m)]\n    edges = [[] for _ in range(m + 2)]\n    \n    xy.sort(key = lambda x:x[0])\n    for i in range(m - 1):\n        dx = abs(xy[i][0] - xy[i + 1][0])\n        dy = abs(xy[i][1] - xy[i + 1][1])\n        d = min(dx, dy)\n        pos1 = xy[i][2]\n        pos2 = xy[i + 1][2]\n        edges[pos1].append((d, pos2))\n        edges[pos2].append((d, pos1))\n        \n    xy.sort(key = lambda x:x[1])\n    for i in range(m - 1):\n        dx = abs(xy[i][0] - xy[i + 1][0])\n        dy = abs(xy[i][1] - xy[i + 1][1])\n        d = min(dx, dy)\n        pos1 = xy[i][2]\n        pos2 = xy[i + 1][2]\n        edges[pos1].append((d, pos2))\n        edges[pos2].append((d, pos1))\n        \n    for x, y, i in xy:\n        d1 = min(abs(x - sx), abs(y - sy))\n        d2 = abs(x - sx) + abs(y - sy)\n        edges[0].append((d1, i))\n        edges[i].append((d2, 0))\n        \n        d1 = min(abs(x - fx), abs(y - fy))\n        d2 = abs(x - fx) + abs(y - fy)\n        edges[1].append((d1, i))\n        edges[i].append((d2, 1))\n    \n    d = abs(sx - fx) + abs(sy - fy)\n    edges[0].append((d, 1))\n    edges[1].append((d, 0))\n    \n    ans = dijkstra(m + 2, 0, edges)\n    print(ans)\n    \n    \nmain()"]
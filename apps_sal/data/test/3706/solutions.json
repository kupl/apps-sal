["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nrealg=[list(map(int,input().split())) for _ in range(n)]\ng=[[0]*m for _ in range(n)]\n\nans=[]\n\n# get differences\nf1=min([realg[0][i] for i in range(m)])\nfor i in range(m):\n    for _ in range(realg[0][i]-f1):\n        ans.append(\"col %d\"%(i+1))\n    for j in range(n):\n        g[j][i]+=realg[0][i]-f1\n\nf2=min([realg[i][0] for i in range(n)])\nfor i in range(n):\n    for _ in range(realg[i][0]-f2):\n        ans.append(\"row %d\"%(i+1))\n    for j in range(m):\n        g[i][j]+=realg[i][0]-f2\n\n# check\nbad=0\nfloor=realg[0][0]-g[0][0]\nfor i in range(n):\n    for j in range(m):\n        if realg[i][j]-g[i][j]!=floor:\n            bad=1\n\nif bad: print(\"-1\")\nelse:\n    # get floor done\n    if n<m:\n        for i in range(n):\n            for j in range(floor): ans.append(\"row %d\"%(i+1))\n    else:\n        for i in range(m):\n            for j in range(floor): ans.append(\"col %d\"%(i+1))\n    print(len(ans))\n    print(\"\\n\".join(ans))\n", "n,m = input().strip().split()\nn,m = int(n),int(m)\ng = [[int(j) for j in input().strip().split()] for i in range(n)]\n\nanswer =[]\n\ndef b():\n  for i in range(n):\n    minRow = min(g[i])\n    if minRow !=0:\n      for k in range(minRow):\n        answer.append(\"row \" + str(i+1))\n      for j in range(m):\n        g[i][j] -= minRow\ndef a():\n  for j in range(m):\n    minCol = g[0][j]\n    for i in range(n):\n      if  g[i][j] < minCol:\n        minCol = g[i][j]\n    if minCol !=0:\n      for k in range(minCol):\n        answer.append(\"col \" + str(j+1))\n      for i in range(n):\n        g[i][j] -= minCol\n\n\nif( n<m):\n  b()\n  a()\nelse:\n  a()\n  b()\nmaxNumber = max(max(g))\nif maxNumber ==0:\n  print(len(answer))\n  for  el in answer:\n    print(el)\nelse:\n  print(\"-1\")", "\"\"\"\u0412\u0432\u043e\u0434 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043c\u0430\u0442\u0440\u0438\u0446\u044b\"\"\"\nnm = [int(s) for s in input().split()]\n\n\"\"\"\u0412\u0432\u043e\u0434 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\"\"\"\na = []\nfor i in range(nm[0]):\n    a.append([int(j) for j in input().split()])\n\nrez=[]\n\ndef stroka():\n    nonlocal rez\n    rez_row=[]\n    rez_r=0\n    for i in range(nm[0]):\n        min_row=501\n        for j in range(nm[1]):\n            if a[i][j]< min_row:\n                min_row=a[i][j]\n        rez_r+=min_row\n\n        if min_row != 0:\n            for c in range(min_row):\n                rez.append('row ' + str(i+1))\n\n        for j in range(nm[1]):\n            if a[i][j]>0:\n                a[i][j]-= min_row\n\ndef grafa():\n    nonlocal rez\n    rez_c=0\n    for j in range(nm[1]):\n            min_col=501\n            for i in range(nm[0]):\n                if a[i][j]< min_col:\n                    min_col=a[i][j]\n            rez_c+=min_col\n\n            if min_col !=0:\n                for c in range(min_col):\n                    rez.append('col '+ str(j+1))\n            for i in range(nm[0]):\n                if a[i][j]>0:\n                    a[i][j] -=min_col\n\n\nif nm[0]<nm[1]:\n    stroka()\n    grafa()\nelse:\n    grafa()\n    stroka()\n\nmaxEl = max(max(a))\n\nif maxEl == 0:\n    print(len(rez))\n    for el in rez:\n        print(el)\nelse:\n    print(-1)\n", "n,m=list(map(int,input().split()))\na=[]\n\ntot=0\n\nrow=[]\ncol=[]\nn1='row'\nn2='col'\nfor _ in range(n):\n    a+=[[int(f)for f in input().split()]]\nif n>m:\n    a=list(map(list,list(zip(*a))))\n    n,m=m,n\n    n1,n2=n2,n1\nfor x in range(n):\n    for y in range(min(a[x])):\n        row+=[x+1]\n    tot+=sum(a[x])\nfor x in range(m):\n    t=a[0][x]-min(a[0])\n    if t<=0:t=0\n    for y in range(t):\n        col+=[x+1]\nt=len(row)+len(col)\nif tot-m*len(row)-n*len(col)==0:\n    print(t)\n    for x in row:\n        print(n1,x)\n    for x in col:\n        print(n2,x)\nelse:print(-1)\n", "n, m = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\nr = [a[i][0] - a[0][0] for i in range(n)]\nc = [a[0][i] - a[0][0] for i in range(m)]\nt = min(r)\nr = [x - t for x in r]\nt = min(c)\nc = [x - t for x in c]\np = a[0][0] - r[0] - c[0]\nif n < m:\n    r = [x + p for x in r]\nelse:\n    c = [x + p for x in c]\nfor i in range(n):\n    for j in range(m):\n        if r[i] + c[j] != a[i][j]:\n            print(-1)\n            quit()\nprint(sum(r) + sum(c))\nfor i, x in enumerate(r):\n    for j in range(x):\n        print(\"row\", i + 1)\nfor i, x in enumerate(c):\n    for j in range(x):\n        print(\"col\", i + 1)\n", "x,y=list(map(int,input().split()))\ngrid=[]\n\nfor i in range(x):\n    grid.append(list(map(int,input().split())))\n\nmi=grid[0][0]\nprints=[]\nfor i in range(x):\n    mi=min(mi,min(grid[i]))\n\nif x > y:\n    for k in range(mi):\n        for i in range(1,y+1):\n            prints.append('col '+str(i))\nelse:\n    for k in range(mi):\n        for i in range(1,x+1):\n            prints.append('row '+str(i))\n\nfor i in range(x):\n    for j in range(y):\n        grid[i][j]-=mi\n\nfor i in range(x):\n    while min(grid[i])>0:\n        prints.append('row '+str(i+1))\n        for j in range(y):\n            grid[i][j]-=1\nfor i in range(y):\n    indy=[]\n    for ranind in range(x):\n        indy.append(grid[ranind][i])\n    mindy=min(indy)\n    for ran2 in range(mindy):\n        prints.append('col '+str(i+1))\n        for j in range(x):\n            grid[j][i]-=1\n\nma=grid[0][0]\nfor i in range(x):\n    ma=max(ma,max(grid[i]))\n    if ma!=0:\n        print('-1')\n        quit()\n\nprint(len(prints))\nprint('\\n'.join(prints))\n\n", "(n,m) = (int(i) for i in input().split())\ntbl = []\nfor i in range(n):\n\tcrstr = [int(j) for j in input().split()]\n\ttbl.append(crstr)\ntrue=0\n\n\ndef prt():\n\tfor xx in range(n):\n\t\tfor yy in range(m):\n\t\t\tprint(tbl[xx][yy], end='\t')\n\t\tprint()\n\tprint()\n\tprint()\n\n# prt()\ndef lines():\n\trows = []\n\tfor i in range(n):\n\t\twhile 1:\n\t\t\tmay = 1\n\t\t\tfor j in range(m):\n\t\t\t\tif tbl[i][j]==0:\n\t\t\t\t\tfor k in range(j):\n\t\t\t\t\t\ttbl[i][k]+=1\n\t\t\t\t\tmay = 0\n\t\t\t\t\tbreak\n\t\t\t\ttbl[i][j]-=1\n\t\t\tif not may: break\n\t\t\trows.append(i+1)\n\t\t# prt()\n\treturn rows\n\ndef cols():\n\tstolbs = []\n\tfor i in range(m):\n\t\twhile 1:\n\t\t\tmay = 1\n\t\t\tfor j in range(n):\n\t\t\t\tif tbl[j][i]==0:\n\t\t\t\t\tfor k in range(j):\n\t\t\t\t\t\ttbl[k][i]+=1\n\t\t\t\t\tmay = 0\n\t\t\t\t\tbreak\n\t\t\t\ttbl[j][i]-=1\n\t\t\tif not may: break\n\t\t\tstolbs.append(i+1)\n\t\t# prt()\n\treturn stolbs\n\nif m>n:\n\tl = lines()\n\tc = cols()\nelse:\n\tc = cols()\n\tl = lines()\n\nbr = 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif tbl[i][j]!=0:\n\t\t\tbr = 1\n\t\t\tbreak\n\tif br: break\nif br:\n\tprint(-1)\nelse:\n\tprint(len(l)+len(c))\n\tfor i in l:\n\t\tprint('row', i)\n\tfor i in c:\n\t\tprint('col', i)\n\n", "n, m = map(int, input().split())\ng = [list(map(int, input().split())) for i in range(n)]\nx, xi, xj = 500, 0, 0\nfor i, gi in enumerate(g):\n    for j, gij in enumerate(gi):\n        if gij < x:\n            x, xi, xj = gij, i, j\nr, c = [g[i][xj] - x for i in range(n)], [g[xi][j] - x for j in range(m)]\nfor i, gi in enumerate(g):\n    for j, gij in enumerate(gi):\n        if gij != r[i] + c[j] + x:\n            print(-1)\n            return\nprint(min(n, m) * x + sum(r) + sum(c))\nfor i in range(n):\n    for k in range(r[i] + (x if n <= m else 0)):\n        print('row', i + 1)\nfor j in range(m):\n    for k in range(c[j] + (x if m < n else 0)):\n        print('col', j + 1)", "\"\"\"Problem A - Karen and Game.\n\nhttp://codeforces.com/contest/815/problem/A\n\nOn the way to school, Karen became fixated on the puzzle game on her phone!\n\nThe game is played as follows. In each level, you have a grid with n rows and\nm columns. Each cell originally contains the number 0.\n\nOne move consists of choosing one row or column, and adding 1 to all of the\ncells in that row or column.\n\nTo win the level, after all the moves, the number in the cell at the i-th row\nand j-th column should be equal to gi, j.\n\nKaren is stuck on one level, and wants to know a way to beat this level using\nthe minimum number of moves. Please, help her with this task!\n\nInput:\n\nThe first line of input contains two integers, n and m (1 \u2264 n, m \u2264 100), the\nnumber of rows and the number of columns in the grid, respectively.\n\nThe next n lines each contain m integers. In particular, the j-th integer in\nthe i-th of these rows contains gi, j (0 \u2264 gi, j \u2264 500).\n\nOutput:\n\nIf there is an error and it is actually not possible to beat the level, output\na single integer -1.\n\nOtherwise, on the first line, output a single integer k, the minimum number of\nmoves necessary to beat the level.\n\nThe next k lines should each contain one of the following, describing the\nmoves in the order they must be done:\n\n- row x, (1 \u2264 x \u2264 n) describing a move of the form \"choose the x-th row\".\n\n- col x, (1 \u2264 x \u2264 m) describing a move of the form \"choose the x-th column\".\n\nIf there are multiple optimal solutions, output any one of them.\n\n\"\"\"\nimport logging\n\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.ERROR)\nlogger.addHandler(ch)\n\n\ndef solve(n, m, grid):\n    logger.debug('\\n'.join([str(x) for x in grid]))\n\n    best_move, best = None, float('inf')\n    for z in range(501):\n        a = [grid[i][0] - z for i in range(n)]\n        b = [z + grid[0][i] - grid[0][0] for i in range(m)]\n        logger.debug('z = %s', z)\n        logger.debug('a = %s', a)\n        logger.debug('b = %s', b)\n        if any(x < 0 for x in a + b):\n            logger.debug('Non-positives on z %s', z)\n            continue\n        if any(grid[i][j] != a[i] + b[j] for i in range(n) for j in range(m)):\n            logger.warning('Not equal on z %s', z)\n            return [-1]\n        current = sum(a) + sum(b)\n        if current < best:\n            best_move = z\n            best = current\n    logger.debug('Best move is %s', best_move)\n\n    if best_move is None:\n        return [-1]\n\n    res = []\n    res.append(best)\n\n    a = [grid[i][0] - best_move for i in range(n)]\n    for i, times in enumerate(a):\n        if not times:\n            continue\n        res.extend(['row {}'.format(i + 1)] * times)\n\n    b = [best_move + grid[0][i] - grid[0][0] for i in range(m)]\n    for i, times in enumerate(b):\n        if not times:\n            continue\n        res.extend(['col {}'.format(i + 1)] * times)\n\n    return res\n\n\ndef main():\n    n, m = list(map(int, input().strip().split()))\n    grid = [list(map(int, input().strip().split())) for _ in range(n)]\n    result = solve(n, m, grid)\n    print('\\n'.join(map(str, result)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\"\"\"Codeforces Round #419 (Div. 1) - Karen and Game.\n\nhttp://codeforces.com/contest/815/problem/A\n\nOn the way to school, Karen became fixated on the puzzle game on her phone!\n\nThe game is played as follows. In each level, you have a grid with n rows and\nm columns. Each cell originally contains the number 0.\n\nOne move consists of choosing one row or column, and adding 1 to all of the\ncells in that row or column.\n\nTo win the level, after all the moves, the number in the cell at the i-th row\nand j-th column should be equal to gi, j.\n\nKaren is stuck on one level, and wants to know a way to beat this level using\nthe minimum number of moves. Please, help her with this task!\n\nInput:\n\nThe first line of input contains two integers, n and m (1 \u2264 n, m \u2264 100), the\nnumber of rows and the number of columns in the grid, respectively.\n\nThe next n lines each contain m integers. In particular, the j-th integer in\nthe i-th of these rows contains gi, j (0 \u2264 gi, j \u2264 500).\n\nOutput:\n\nIf there is an error and it is actually not possible to beat the level, output\na single integer -1.\n\nOtherwise, on the first line, output a single integer k, the minimum number of\nmoves necessary to beat the level.\n\nThe next k lines should each contain one of the following, describing the\nmoves in the order they must be done:\n\n- row x, (1 \u2264 x \u2264 n) describing a move of the form \"choose the x-th row\".\n\n- col x, (1 \u2264 x \u2264 m) describing a move of the form \"choose the x-th column\".\n\nIf there are multiple optimal solutions, output any one of them.\n\n\"\"\"\nimport logging\n\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.ERROR)\nlogger.addHandler(ch)\n\n\ndef solve(n, m, grid):\n    logger.debug('\\n'.join([str(x) for x in grid]))\n\n    # Check if ...\n    a = [grid[i][0] for i in range(n)]\n    b = [grid[0][i] - grid[0][0] for i in range(m)]\n    if any(grid[i][j] != a[i] + b[j] for i in range(n) for j in range(m)):\n        logger.debug('Not possible ....')\n        return [-1]\n\n    best_move, best = None, float('inf')\n    for z in range(501):\n        a = [grid[i][0] - z for i in range(n)]\n        b = [z + grid[0][i] - grid[0][0] for i in range(m)]\n        logger.debug('z = %s', z)\n        logger.debug('a = %s', a)\n        logger.debug('b = %s', b)\n        if any(x < 0 for x in a + b):\n            logger.debug('Non-positives on z %s', z)\n            continue\n        current = sum(a) + sum(b)\n        if current < best:\n            best_move = z\n            best = current\n\n    if best_move is None:\n        return [-1]\n\n    logger.debug('Best move is %s', best_move)\n\n    res = []\n    res.append(best)\n\n    a = [grid[i][0] - best_move for i in range(n)]\n    for i, times in enumerate(a):\n        if not times:\n            continue\n        res.extend(['row {}'.format(i + 1)] * times)\n\n    b = [best_move + grid[0][i] - grid[0][0] for i in range(m)]\n    for i, times in enumerate(b):\n        if not times:\n            continue\n        res.extend(['col {}'.format(i + 1)] * times)\n\n    return res\n\n\ndef main():\n    n, m = list(map(int, input().strip().split()))\n    grid = [list(map(int, input().strip().split())) for _ in range(n)]\n    result = solve(n, m, grid)\n    print('\\n'.join(map(str, result)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#815A\n\ninpt = input().split(\" \")\nn = int(inpt[0])\nm = int(inpt[1])\n\narr = []\n\nfor i in range(n):\n\tinpt = input().split(\" \")\n\tinpt = list(map(int, inpt))\n\tarr.append(inpt)\n\nsol = []\n\ndef solver1(a, sol):\n\tallmin = min([min(suba) for suba in a])\n\tif allmin < 0:\n\t\treturn False\n\tallmax = max([max(suba) for suba in a])\n\tif allmax == 0:\n\t\treturn True\n\telse:\n\t\tfor i in range(len(a)):\n\t\t\tp = min(a[i])\n\t\t\tif p > 0:\n\t\t\t\tfor j in range(len(a[i])):\n\t\t\t\t\ta[i][j] -= p\n\t\t\t\tfor q in range(p):\n\t\t\t\t\tsol.append(i + 1)\n\t\t\t\treturn solver1(a, sol)\n\t\tfor j in range(len(a[0])):\n\t\t\tb = []\n\t\t\tfor i in range(len(a)):\n\t\t\t\tb.append(a[i][j])\n\t\t\tp = min(b)\n\t\t\tif p > 0:\n\t\t\t\tfor k in range(len(b)):\n\t\t\t\t\ta[k][j] -= p\n\t\t\t\tfor q in range(p):\n\t\t\t\t\tsol.append(len(a) + j + 1)\n\t\t\t\treturn solver1(a, sol)\n\ndef solver2(a, sol):\n\tallmin = min([min(suba) for suba in a])\n\tif allmin < 0:\n\t\treturn False\n\tallmax = max([max(suba) for suba in a])\n\tif allmax == 0:\n\t\treturn True\n\telse:\n\t\tfor j in range(len(a[0])):\n\t\t\tb = []\n\t\t\tfor i in range(len(a)):\n\t\t\t\tb.append(a[i][j])\n\t\t\tp = min(b)\n\t\t\tif p > 0:\n\t\t\t\tfor k in range(len(b)):\n\t\t\t\t\ta[k][j] -= p\n\t\t\t\tfor q in range(p):\n\t\t\t\t\tsol.append(len(a) + j + 1)\n\t\t\t\treturn solver2(a, sol)\n\t\tfor i in range(len(a)):\n\t\t\tp = min(a[i])\n\t\t\tif p > 0:\n\t\t\t\tfor j in range(len(a[i])):\n\t\t\t\t\ta[i][j] -= p\n\t\t\t\tfor q in range(p):\n\t\t\t\t\tsol.append(i + 1)\n\t\t\t\treturn solver2(a, sol)\n\nif n < m:\n\tif solver1(arr, sol):\n\t\tprint(len(sol))\n\t\tfor i in sol:\n\t\t\tif i <= n:\n\t\t\t\tprint(\"row\", i)\n\t\t\telse:\n\t\t\t\tprint(\"col\", i - n)\n\telse:\n\t\tprint(\"-1\")\nelse:\n\tif solver2(arr, sol):\n\t\tprint(len(sol))\n\t\tfor i in sol:\n\t\t\tif i <= n:\n\t\t\t\tprint(\"row\", i)\n\t\t\telse:\n\t\t\t\tprint(\"col\", i - n)\n\telse:\n\t\tprint(\"-1\")", "def main():\n    n, m = list(map(int, input().split()))\n    l, r = [list(map(int, input().split())) for _ in range(n)], []\n    if n > m:\n        l = [list(col) for col in zip(*l)]\n        cols, rows = 'row %d', 'col %d'\n    else:\n        cols, rows = 'col %d', 'row %d'\n    for y, row in enumerate(l, 1):\n        a = min(row)\n        for i, t in enumerate(row):\n            row[i] = t - a\n        r += [rows % y] * a\n    l = [list(col) for col in zip(*l)]\n    for x, col in enumerate(l, 1):\n        a = min(col)\n        for i, t in enumerate(col):\n            col[i] = t - a\n        r += [cols % x] * a\n    r.append(str(len(r)))\n    print(-1 if any(map(any, l)) else '\\n'.join(r[::-1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\nr = [a[i][0] - a[0][0] for i in range(n)]\nc = [a[0][i] - a[0][0] for i in range(m)]\nt = min(r)\nr = [x - t for x in r]\nt = min(c)\nc = [x - t for x in c]\np = a[0][0] - r[0] - c[0]\nif n < m:\n    r = [x + p for x in r]\nelse:\n    c = [x + p for x in c]\nfor i in range(n):\n    for j in range(m):\n        if r[i] + c[j] != a[i][j]:\n            print(-1)\n            quit()\nprint(sum(r) + sum(c))\nfor i, x in enumerate(r):\n    for j in range(x):\n        print(\"row\", i + 1)\nfor i, x in enumerate(c):\n    for j in range(x):\n        print(\"col\", i + 1)\n\n\n\n\n# Made By Mostafa_Khaled\n", "n,m=list(map(int,input().split()))\nL=[list(map(int,input().split())) for i in range(n)]\ns=\"row\"\ns1=\"col\"\nif n>m :\n    L1=[[0 for i in range(n)] for j in range(m)]\n    for i in range(n) :\n        for j in range(m) :\n            L1[j][i]=L[i][j]\n    L=L1\n    n,m=m,n\n    s,s1=s1,s\n            \nw=[0 for i in range(n)]\nw1=[0 for i in range(m)]\nfor i in range(n) :\n    w[i]=min(L[i])\nfor i in range(m) :\n    for j in range(n) :\n        ma=0\n        ma=max(L[j][i]-w[j],ma)\n    w1[i]=ma\nfor i in range(n) :\n    for j in range(m) :\n        if L[i][j]-w[i]-w1[j]!=0 :\n            print(-1)\n            return\notv=[]\nfor i in range(n) :\n    otv+=[s+\" \"+str(i+1)]*w[i]\nfor i in range(m) :\n    otv+=[s1+\" \"+str(i+1)]*w1[i]\nprint(len(otv))\nprint('\\n'.join(otv))\n            \n\n\n    \n    \n        \n    \n    \n", "class CodeforcesTask815ASolution:\n    def __init__(self):\n        self.result = ''\n        self.n_m = []\n        self.board = []\n\n    def read_input(self):\n        self.n_m = [int(x) for x in input().split(\" \")]\n        for x in range(self.n_m[0]):\n            self.board.append([int(y) for y in input().split(\" \")])\n\n    def process_task(self):\n        columns = []\n        for x in range(self.n_m[1]):\n            column = []\n            for y in range(self.n_m[0]):\n                column.append(self.board[y][x])\n            columns.append(column)\n\n        left_board_moves = [min(row) for row in self.board]\n        bottom_board_moves = [min(column) for column in columns]\n        reduce1 = min(bottom_board_moves)\n        reduce2 = min(left_board_moves)\n        if reduce1 * self.n_m[0] > reduce2 * self.n_m[1]:\n            left_board_moves = [x - reduce1 for x in left_board_moves]\n        else:\n            bottom_board_moves = [x - reduce2 for x in bottom_board_moves]\n        moves = sum(left_board_moves) + sum(bottom_board_moves)\n        board_score = sum(left_board_moves) * self.n_m[1] + sum(bottom_board_moves) * self.n_m[0]\n        real_board_score = sum([sum(x) for x in self.board])\n        if board_score != real_board_score:\n            self.result = \"-1\"\n        else:\n            print(\"{0}\".format(moves))\n            for x in range(self.n_m[0]):\n                for y in range(left_board_moves[x]):\n                    print(\"row {0}\".format(x + 1))\n            for x in range(self.n_m[1]):\n                for y in range(bottom_board_moves[x]):\n                    print(\"col {0}\".format(x + 1))\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask815ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()", "n, m = map(int, input().split())\n\narray = []\nrow_sums = [0 for x in range(n)]\n\nfor i in range(n):\n\tarray.append(list(map(int, input().split())))\n\trow_sums[i] = sum(array[i])\n\ncol_sums = [sum(x) for x in zip(*array)]\n\nmin_row_index = row_sums.index(min(row_sums))\nmin_col_index = col_sums.index(min(col_sums))\n\n\nrow_boost = [0 for x in range(n)]\ncol_boost = [0 for x in range(m)]\n#rows contribute more\nif n <= m:\n\t#get largest row add possible\n\tcol_boost[min_col_index] = 0\n\tfor i in range(m):\n\t\tif i != min_col_index:\n\t\t\tcol_boost[i] = (col_sums[i] - col_sums[min_col_index]) // n\n\n\t\tsum_col_boosts = sum(col_boost)\n\n\t\tfor i in range(n):\n\t\t\trow_boost[i] = (row_sums[i] - sum_col_boosts) // m\n\nif n >= m:\n\trow_boost[min_row_index] = 0\n\n\tfor i in range(n):\n\t\tif i != min_row_index:\n\t\t\trow_boost[i] = (row_sums[i] - row_sums[min_row_index]) // m\n\n\tsum_row_boosts = sum(row_boost)\n\n\tfor i in range(m):\n\t\tcol_boost[i] = (col_sums[i] - sum_row_boosts) // n\n\nfor row in range(n):\n\tif [row_boost[row] + c for c in col_boost] != array[row]:\n\t\tprint(-1)\n\t\treturn\n\nprint(sum(row_boost + col_boost))\nfor i in range(n):\n\tfor count in range(row_boost[i]):\n\t\tprint('row ' + str(i+1))\n\nfor j in range(m):\n\tfor count in range(col_boost[j]):\n\t\tprint('col ' + str(j+1))", "n, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for i in range(n)]\nans = []\nif m > n:\n    for i in range(n):\n        mini = min(grid[i])\n        for j in range(m):\n            grid[i][j] -= mini\n        for _ in range(mini):\n            ans.append(\"row \" + str(i+1))\n    for i in range(m):\n        mini = float('inf')\n        for j in range(n):\n            mini = min(grid[j][i], mini)\n        for j in range(n):\n            grid[j][i] -= mini\n        for _ in range(mini):\n            ans.append(\"col \" + str(i+1))\nelse:\n    for i in range(m):\n        mini = float('inf')\n        for j in range(n):\n            mini = min(grid[j][i], mini)\n        for j in range(n):\n            grid[j][i] -= mini\n        for _ in range(mini):\n            ans.append(\"col \" + str(i+1))\n    for i in range(n):\n        mini = min(grid[i])\n        for j in range(m):\n            grid[i][j] -= mini\n        for _ in range(mini):\n            ans.append(\"row \" + str(i+1))\nif all([sum(i) == 0 for i in grid]):\n    print(len(ans))\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "#!/usr/bin/env pypy3\n\ndef all_zero(A):\n    for row in A:\n        for e in row:\n            if e != 0: return False\n    return True\n\nn, m = input().split(' ')\nn = int(n)\nm = int(m)\n\nA = []\n\nfor _ in range(n):\n    row = input().split(' ')\n    row = list(map(int, row))\n    A += [row]\n\nmoves = []\n\n# produce a zero\n\nmin_elem = min(min(row) for row in A)\n\nif min_elem > 0:\n    if m >= n:\n        for x in range(n):\n            moves += [f\"row {x+1}\"]*min_elem\n    else:\n        for y in range(m):\n            moves += [f\"col {y+1}\"]*min_elem\n\n    for x in range(n):\n        for y in range(m):\n            A[x][y] -= min_elem\n\npivot = None\n\nfor x in range(n):\n    for y in range(m):\n        if A[x][y] == 0:\n            pivot = (x, y)\n            break\n\nassert(pivot is not None)\n\npivot_x, pivot_y = pivot\n\nfor x in range(n):\n    if x == pivot_x: continue\n    f = A[x][pivot_y]\n    moves += [f\"row {x+1}\"]*f\n    for y in range(m):\n        A[x][y] -= f\n\nfor y in range(m):\n    if y == pivot_y: continue\n    f = A[pivot_x][y]\n    moves += [f\"col {y+1}\"]*f\n    for x in range(n):\n        A[x][y] -= f\n\nif not all_zero(A):\n    print(-1)\nelse:\n    print(len(moves))\n    print('\\n'.join(moves))\n", "def min_row():\n    ans = 0\n    for i in range(n):\n        ans += min(a[i])\n    return ans\n\n\ndef min_col():\n    ans = 0\n    for i in range(m):\n        mm = 10000\n        for j in range(n):\n            mm = min(mm, a[j][i])\n        ans += mm\n    return ans\n\n\ndef remove_cols():\n    ans = 0\n    min_col = [0] * m\n    for i in range(m):\n        min_col[i] = 1000\n        for j in range(n):\n            min_col[i] = min(min_col[i], a[j][i])\n        ans += min_col[i]\n        for j in range(n):\n            a[j][i] -= min_col[i]\n    return ans, min_col\n\n\ndef remove_rows():\n    ans = 0\n    min_row = []\n    for i in range(n):\n        min_row.append(min(a[i]))\n        ans += min_row[-1]\n        for j in range(m):\n            a[i][j] -= min_row[i]\n    return ans, min_row\n\n\nn, m = list(map(int, input().split()))\na = []\ns = 0\n\nfor i in range(n):\n    row = list(map(int, input().split()))\n    a.append(row)\n    s += sum(row)\n\nrows = min_row()\ncols = min_col()\n\nif rows == 0 and cols == 0:\n    if s == 0:\n        print(0)\n        return\n    else:\n        print(-1)\n        return\n\nif cols == 0 or (rows != 0 and (s - rows * m) % n == 0 and ((s - cols * n) % m != 0 or (s - rows * m) // n + rows < (s - cols * n) // m + cols)):\n    ans, min_row = remove_rows()\n    ans1, min_col = remove_cols()\nelse:\n    ans1, min_col = remove_cols()\n    ans, min_row = remove_rows()\n\nans += ans1\n\nfor row in a:\n    for ai in row:\n        if ai != 0:\n            print(-1)\n            return\n\nprint(ans)\nfor i in range(n):\n    for j in range(min_row[i]):\n        print(\"row\", i + 1)\nfor i in range(m):\n    for j in range(min_col[i]):\n        print(\"col\", i + 1)\n"]
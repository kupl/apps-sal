["#      \nimport    sys \n \ndef getIntList():\n    return list(map(int, input().split()))    \n \n\n\n \nN, = getIntList()\n\nzp = []\nfor i in range(N):\n    ax, ay, bx, by  = getIntList()\n    if ax>bx:\n        ax,bx = bx,ax\n        ay,by = by, ay\n    zp.append( (ax,ay, bx,by))\n  \nres = 0\ndef gcd(a,b): \n    if b==0:return a\n    return gcd(b, a%b)\nzgcd = []\nfor i in range(N):\n    ax, ay, bx, by = zp[i]\n    tx =  abs(bx-ax)\n    ty = abs(by - ay)\n \n    g = gcd(tx, ty)\n    res += g+1\n \n    zgcd .append(g)\n \n\"\"\"\nax + k1 dax = bx + k2 dbx\nay + k1 day = by + k2 dby\n\"\"\"\nfor i in range(N):\n    ax = zp[i][0]\n    dax = (zp[i][2] - ax) // zgcd[i]\n    ay = zp[i][1]\n    day = (zp[i][3] - ay) // zgcd[i]\n    cross = []\n    for j in range(i+1, N):\n        #dprint('node',i,j)\n        bx = zp[j][0]\n        dbx = (zp[j][2] - bx) // zgcd[j]\n        by = zp[j][1]\n        dby = (zp[j][3] - by) // zgcd[j]\n        #dprint(ax,dax,ay,day)\n        #dprint(bx,dbx,by,dby)\n        t1 = ax * day - ay * dax - bx * day + by * dax\n        t2 = dbx *day - dby * dax\n        \n        #dprint(t1,t2)\n        if t2==0:\n            continue\n        if t1%t2!=0:\n            continue\n        k2 = t1 // t2\n        if k2 <0 or k2 > zgcd[j]:\n            continue\n        if dax!=0:\n            t3 = k2*dbx + bx - ax\n            if t3%dax!=0:\n                continue\n            k1 = t3//dax\n        else:\n            t3 = k2* dby + by - ay\n            if t3%day !=0:\n                continue\n            k1 = t3//day\n        if k1<0 or k1 > zgcd[i]:\n            continue\n        #dprint(ax + k1 * dax, ay+k1 * day)\n        cross.append(k1)\n    if not cross: continue\n    cross.sort()\n \n    d = 1\n    for j in range(1, len(cross)):\n        if cross[j]!=cross[j-1]:\n            d+=1\n    res-=d\nprint(res)\n    \n\n\n\n", "from math import gcd\nfrom bisect import *\n\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __repr__(self):\n        return 'Point' + repr((self.x, self.y))\n    def __add__(self, val):\n        return Point(self.x + val.x, self.y + val.y)\n    def __sub__(self, val):\n        return Point(self.x - val.x, self.y - val.y)\n    def __mul__(self, ratio):\n        return Point(self.x * ratio, self.y * ratio)\n\n    @staticmethod\n    def det(A, B):\n        return A.x * B.y - A.y * B.x\n    @staticmethod\n    def dot(A, B):\n        return A.x * B.x + A.y * B.y\n\n    def onSegment(self, A, B):\n        if self.det(B-A, self-A) != 0:\n            return False\n        if self.dot(B-A, self-A) < 0:\n            return False\n        if self.dot(A-B, self-B) < 0:\n            return False\n        return True\n        \n\ndef intPoints(x1, y1, x2, y2):\n    dx, dy = abs(x2 - x1), abs(y2 - y1)\n    return gcd(dx, dy) + 1\n\ndef crosspoint(L1, L2):\n    A, B = Point(L1[0], L1[1]), Point(L1[2], L1[3])\n    C, D = Point(L2[0], L2[1]), Point(L2[2], L2[3])\n    S1, S2 = Point.det(C-A, D-A), Point.det(C-D, B-A)\n    delta = (B - A) * S1\n    if S2 == 0 or delta.x % S2 != 0 or delta.y % S2 != 0:\n        return None\n    delta.x = delta.x // S2\n    delta.y = delta.y // S2\n    P = A + delta\n    if not P.onSegment(A, B) or not P.onSegment(C, D):\n        return None\n    return (P.x, P.y)\n'''\nwhile True:\n    x1, y1, x2, y2 = map(int, input().split())\n    A, B = Point(x1, y1), Point(x2, y2)\n    x1, y1, x2, y2 = map(int, input().split())\n    C, D = Point(x1, y1), Point(x2, y2)\n    print(crosspoint(A, B, C, D))\n'''\n\nn = int(input())\nlines = [ tuple(int(z) for z in input().split()) \\\n          for i in range(n) ]\ncount = dict()\nfor i in range(n):\n    for j in range(i):\n        P = crosspoint(lines[i], lines[j])\n        if P == None:\n            continue\n        if not P in count:\n            count[P] = 1\n        else:\n            count[P] += 1\n\n\nanswer = sum(intPoints(*L) for L in lines)\ntri = [ x*(x+1)//2 for x in range(n+1) ]\nfor z in count:\n    k = bisect_right(tri, count[z])\n    answer -= k - 1;\nprint(answer)\n", "from math import gcd\nfrom bisect import *\n\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __add__(self, val):\n        return Point(self.x + val.x, self.y + val.y)\n    def __sub__(self, val):\n        return Point(self.x - val.x, self.y - val.y)\n    def __mul__(self, ratio):\n        return Point(self.x * ratio, self.y * ratio)\n    def __truediv__(self, ratio):\n        return Point(self.x / ratio, self.y / ratio)\n\n    @staticmethod\n    def det(A, B):\n        return A.x * B.y - A.y * B.x\n    @staticmethod\n    def dot(A, B):\n        return A.x * B.x + A.y * B.y\n\n    def onSegment(self, A, B):\n        if self.det(B-A, self-A) != 0:\n            return False\n        if self.dot(B-A, self-A) < 0:\n            return False\n        if self.dot(A-B, self-B) < 0:\n            return False\n        return True\n        \n\ndef intPoints(x1, y1, x2, y2):\n    dx, dy = abs(x2 - x1), abs(y2 - y1)\n    return gcd(dx, dy) + 1\n\ndef crosspoint(L1, L2):\n    A, B = Point(L1[0], L1[1]), Point(L1[2], L1[3])\n    C, D = Point(L2[0], L2[1]), Point(L2[2], L2[3])\n    S1, S2 = Point.det(C-A, D-A), Point.det(C-D, B-A)\n    delta = (B - A) * S1\n    if S2 == 0 or delta.x % S2 != 0 or delta.y % S2 != 0:\n        return None\n    delta = delta / S2;\n    P = A + delta\n    if not P.onSegment(A, B) or not P.onSegment(C, D):\n        return None\n    return (P.x, P.y)\n\nn = int(input())\nlines = [ tuple(int(z) for z in input().split()) \\\n          for i in range(n) ]\ncount = dict()\nfor i in range(n):\n    for j in range(i):\n        P = crosspoint(lines[i], lines[j])\n        if P != None:\n            count[P] = count.get(P, 0) + 1\n\nanswer = sum(intPoints(*L) for L in lines)\ntri = [ x*(x+1)//2 for x in range(n+1) ]\nfor z in count:\n    k = bisect_right(tri, count[z])\n    answer -= k - 1;\nprint(answer)\n", "import sys\nfrom math import gcd\n\n\nclass Segment:\n    def __init__(self, x1, y1, x2, y2):\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n    \n    def dx(self):\n        return self.x2 - self.x1\n    \n    def dy(self):\n        return self.y2 - self.y1\n    \n    def pt_cnt(self):\n        return gcd(abs(self.dx()), abs(self.dy())) + 1\n    \n    def A(self):\n        return self.y1 - self.y2\n    \n    def B(self):\n        return self.x2 - self.x1\n\n    def C(self):\n        return -self.A() * self.x1 - self.B() * self.y1\n\n    def inner_x(self, x):\n        l = self.x1\n        r = self.x2\n        if l > r:\n            l, r = r, l\n        return l <= x <= r\n    \n    def inner_y(self, y):\n        l = self.y1\n        r = self.y2\n        if l > r:\n            l, r = r, l\n        return l <= y <= r\n    \n    def inner(self, x, y):\n        return self.inner_x(x) and self.inner_y(y)\n\n    def intersect(self, other):\n        dx = det(self.C(), self.B(), other.C(), other.B())\n        dy = det(self.A(), self.C(), other.A(), other.C())\n        d = det(self.A(), self.B(), other.A(), other.B())\n        if d == 0:\n            return False, 0, 0\n        if dx % d != 0 or dy % d != 0:\n            return False, 0, 0\n        x = -dx // d\n        y = -dy // d\n        if not self.inner(x, y) or not other.inner(x, y):\n            return False, 0, 0\n        return True, x, y\n\n\ndef det(a, b, c, d):\n    return a * d - b * c\n\ndef main():\n    n = int(input())\n    segments = []\n    ans = 0\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        segment = Segment(x1, y1, x2, y2)\n        ans += segment.pt_cnt()\n        pt = set()\n        for other in segments:\n            result, x, y = segment.intersect(other)\n            if result:\n                pt.add((x, y))\n        ans -= len(pt)\n        segments.append(segment)  \n    print(ans)\n        \ndef __starting_point():\n    main()\n__starting_point()", "from math import gcd\nn=int(input());\npts=[]\nans=0\nfor i in range(0,n):\n\ta,b,A,B=tuple(map(int,input().split(' ')))\n\tpts.append((a,b,A,B))\n\tans+=(gcd(abs(a-A),abs(b-B))+1)\nm=dict()\nfor i in range(n):\n\tfor j in range(i+1,n):\n\t\ta1=pts[i][0]\n\t\tb1=pts[i][1]\n\t\ta2=pts[i][2]\n\t\tb2=pts[i][3]\n\t\tA1=pts[j][0]\n\t\tB1=pts[j][1]\n\t\tA2=pts[j][2]\n\t\tB2=pts[j][3]\n\t\tnum1=(b2-B2)*(A2-A1)*(a2-a1)+A2*(a2-a1)*(B2-B1)-a2*(A2-A1)*(b2-b1)\n\t\tden1=(B2-B1)*(a2-a1)-(b2-b1)*(A2-A1)\n\t\tif(den1!=0 and num1%den1==0):\n\t\t\tif(a1==a2):\n\t\t\t\tnum2=B2*(A2-A1)+(num1//den1-A2)*(B2-B1)\n\t\t\t\tden2=(A2-A1)\n\t\t\t\tif(num2%den2==0):\n\t\t\t\t\tif((num1//den1-A2)*(num1//den1-A1)<=0 and (num2//den2-B2)*(num2//den2-B1)<=0 and (num1//den1-a2)*(num1//den1-a1)<=0 and (num2//den2-b2)*(num2//den2-b1)<=0):\n\t\t\t\t\t\tif((num1//den1,num2//den2) not in m):\n\t\t\t\t\t\t\tm[(num1//den1,num2//den2)]=set();\n\t\t\t\t\t\tm[(num1//den1,num2//den2)].add(i);\n\t\t\t\t\t\tm[(num1//den1,num2//den2)].add(j);\n\t\t\telse:\n\t\t\t\tnum2=b2*(a2-a1)+(num1//den1-a2)*(b2-b1);\n\t\t\t\tden2=(a2-a1);\n\t\t\t\tif(num2%den2==0):\n\t\t\t\t\tif((num1//den1-A2)*(num1//den1-A1)<=0 and (num2//den2-B2)*(num2//den2-B1)<=0 and (num1//den1-a2)*(num1//den1-a1)<=0 and (num2//den2-b2)*(num2//den2-b1)<=0):\n\t\t\t\t\t\tif((num1//den1,num2//den2) not in m):\n\t\t\t\t\t\t\tm[(num1//den1,num2//den2)]=set();\n\t\t\t\t\t\tm[(num1//den1,num2//den2)].add(i);\n\t\t\t\t\t\tm[(num1//den1,num2//den2)].add(j);\nsum=0\nfor i in list(m.values()):\n\tsum+=(len(i)-1)\nprint(ans-sum)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Sep 18 10:09:57 2018\n\n@author: a.teffal\n\nChalenge :  Covered Points\n\"\"\"\n\n\nfrom math import gcd\n\ndef covered_points(xa, ya, xb, yb):\n    '''\n    assumes all parameters are integers\n    Returns the covered points by the segement A-B having integer \n    coordinates\n    \n    '''\n    \n    #this just to have A in the left and B in the right\n    if xb < xa :\n        temp_x = xa\n        xa = xb\n        xb = temp_x\n        \n        temp_y = ya\n        ya = yb\n        yb = temp_y\n    \n    y_0 = abs(yb - ya)\n    x_0 = xb - xa\n    \n    #pgdc_y_x = gcd(y_0, x_0)\n    \n    return gcd(y_0, x_0) + 1\n\ndef intersection2(xa, ya, xb, yb, xc, yc, xd, yd):\n    \n    \n    if max(xa, xb) < min(xc,xd):\n        return ()\n    \n    if max(ya, yb) < min(yc,yd):\n        return ()\n    \n    # if both A-B and C - D ara parallel to x-axis\n    # then no intersection (it is garanted that no segments lie on the same line)\n    if (xa == xb and xc == xd) or (ya == yb and yc == yd):\n        return ()\n    if ya == yb and yc == yd:\n        return ()\n    \n    \n    \n    \n    a1 = yb - ya\n    b1 = xb - xa\n    #c1 = xa*(yb - ya) - ya*(xb - xa)\n    c1 = xa*a1 - ya*b1\n    \n    a2 = yd - yc\n    b2 = xd - xc\n    #c2 = xc*(yd - yc) - yc*(xd - xc)\n    c2 = xc*a2 - yc*b2\n    \n    det = a1 * b2 - a2 * b1\n    \n    if det == 0:\n        return ()\n    \n    detx = c1 * b2 - c2 * b1\n    \n    dety = -a1 * c2 + a2 * c1\n    \n    if (detx % det) != 0 or (dety % det) !=0 :\n        return ()\n    \n    x = int(detx/det)\n    y = int(dety/det)\n    \n    if x < min(xa, xb) or x > max(xa, xb) or x < min(xc, xd) or x > max(xc, xd) :\n        return ()\n    if y < min(ya, yb) or y > max(ya, yb) or y < min(yc, yd) or y > max(yc, yd) :\n        return ()\n    \n    return (x, y)\n    \n\ndef __starting_point():\n    #number of segments\n    n = int(input())\n    \n    #initiate lists of point coordinates\n    Ax = [0]*n\n    Ay = [0]*n\n    Bx = [0]*n\n    By = [0]*n\n    \n    \n    \n    n_cov = 0\n    intersections = {}\n    \n    #counting covered by each segment\n    for i in range(n):\n        line = input().split(sep = ' ')\n        Ax[i] = int(line[0])\n        Ay[i] = int(line[1])\n        Bx[i] = int(line[2])\n        By[i] = int(line[3])\n        n_cov += covered_points(Ax[i], Ay[i], Bx[i], By[i])\n    \n    \n    #substructing reapted points (intersection)\n    for i in range(n):\n        for j in range(i+1, n):\n            temp = intersection2(Ax[i], Ay[i], Bx[i], By[i], Ax[j], Ay[j], Bx[j], By[j])\n            if len(temp)==0:\n                continue\n            if temp in intersections:\n                intersections[temp].append(i)\n                intersections[temp].append(j)\n            else:\n                intersections[temp] = [i, j]\n                \n    for i in intersections:\n        n_cov = n_cov - len(set(intersections[i])) + 1\n        \n    print(n_cov)\n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n__starting_point()", "\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef line_intersection(line1, line2):\n    px, py, qx, qy = line1\n    rx, ry, sx, sy = line2\n    \n    xdiff = (px - qx, rx - sx)\n    ydiff = (py - qy, ry - sy)\n\n    div = cross(px - qx, rx - sx, py - qy, ry - sy)\n    if div == 0:\n      raise Exception('lines do not intersect')\n\n    pq, rs = cross(px, py, qx, qy), cross(rx, ry, sx, sy)\n    x = cross(pq, rs, px - qx, rx - sx) / div\n    y = cross(pq, rs, py - qy, ry - sy) / div\n    return x, y\n    \ndef online(line, x, y):\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    else:\n        return False\n\n\n\ndef CF1036E():\n    N = int(input())\n    lines = []\n    count = 0\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        points = gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        count += points\n        lines.append((x1, y1, x2, y2))\n    for i in range(N):\n        d = set()\n        for j in range(i+1, N):\n            px = lines[i][0]\n            py = lines[i][1]\n            qx = lines[j][0]\n            qy = lines[j][1]\n            rx = lines[i][2] - lines[i][0]\n            ry = lines[i][3] - lines[i][1]\n            sx = lines[j][2] - lines[j][0]\n            sy = lines[j][3] - lines[j][1]\n\n            rs = cross(rx, ry, sx, sy)\n            # qpr = cross(qx - px, qy - py, rx, ry)\n            \n            if rs == 0: continue\n        \n            # qpr = cross(qx - px, qy - py, rx, ry)\n            # qps = cross(qx - px, qy - py, sx, sy)\n            # t = qps / rs\n            # u = qpr / rs\n            x, y = line_intersection(lines[i], lines[j])\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n            d.add((x, y))\n            \n        count = count - len(d)\n        \n    return int(count)\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()", "'''\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n'''\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef online(line, x, y):\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    else:\n        return False\n\n\ndef CF1036E():\n    N = int(input())\n    lines = []\n    count = 0\n    \n    # Find the lines covered by each line segment\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        count += gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        lines.append((x1, y1, x2, y2))\n        \n    # Deal with the intersecting points\n    for i in range(N):\n        d = set()\n        for j in range(i+1, N):\n            px, py, qx, qy = lines[i]\n            rx, ry, sx, sy = lines[j]\n            \n            line1p = (px - qx, rx - sx)\n            line2p = (py - qy, ry - sy)\n            \n            # Cross of two lines        \n            area = cross(line1p[0], line1p[1], line2p[0], line2p[1])\n        \n            # Parallel line has no intersection            \n            if area == 0: continue\n\n            lineA = cross(px, py, qx, qy)\n            lineB = cross(rx, ry, sx, sy)\n            x = cross(lineA, lineB, line1p[0], line1p[1]) / area\n            y = cross(lineA, lineB, line2p[0], line2p[1]) / area\n\n            # Verify the points are good\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n    \n            d.add((x, y))\n            \n        count -= len(d)\n        \n    return count\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()", "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef online(line, x, y):\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    else:\n        return False\n\n\ndef CF1036E():\n    N = int(input())\n    lines = []\n    count = 0\n    \n    # Find the lines covered by each line segment\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        count += gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        lines.append((x1, y1, x2, y2))\n        \n    # Deal with the intersecting points\n    for i in range(N):\n        d = set()\n        for j in range(i+1, N):\n            px, py, qx, qy = lines[i]\n            rx, ry, sx, sy = lines[j]\n            \n            vecx = (px - qx, rx - sx)\n            vecy = (py - qy, ry - sy)\n            \n            # Cross of two lines        \n            area = cross(vecx[0], vecx[1], vecy[0], vecy[1])\n        \n            # Parallel line has no intersecting points            \n            if area == 0: continue\n            \n            # Computation of the exact point\n            # This has been referenced from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n            lineA = cross(px, py, qx, qy)\n            lineB = cross(rx, ry, sx, sy)\n            x = cross(lineA, lineB, vecx[0], vecx[1]) / area\n            y = cross(lineA, lineB, vecy[0], vecy[1]) / area\n\n            # Verify the points are good. \n            # If the points are integers and lie of the lines they are valid.\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n    \n            d.add((x, y))\n            \n        count -= len(d)\n        \n    return count\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()", "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef online(line, x, y):\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    return False\n\n\ndef CF1036E():\n    N = int(input())\n    lines = []\n    count = 0\n    \n    # Find the lines covered by each line segment\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        count += gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        lines.append((x1, y1, x2, y2))\n        \n    # Deal with the intersecting points\n    for i in range(N):\n        d = set()\n        for j in range(i+1, N):\n            px, py, qx, qy = lines[i]\n            rx, ry, sx, sy = lines[j]\n            \n            vecx = (px - qx, rx - sx)\n            vecy = (py - qy, ry - sy)\n            \n            # Cross of two lines        \n            area = cross(vecx[0], vecx[1], vecy[0], vecy[1])\n        \n            # Parallel line has no intersecting points            \n            if area == 0: continue\n            \n            # Computation of the exact point\n            # This has been referenced from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n            lineA = cross(px, py, qx, qy)\n            lineB = cross(rx, ry, sx, sy)\n            x = cross(lineA, lineB, vecx[0], vecx[1]) / area\n            y = cross(lineA, lineB, vecy[0], vecy[1]) / area\n\n            # Verify the points are good. \n            # If the points are integers and lie of the lines they are valid.\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n    \n            d.add((x, y))\n            \n        count -= len(d)\n        \n    return count\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()", "# Borrows primarily from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef online(line, x, y):\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    return False\n\n\ndef CF1036E():\n    N = int(input())\n    lines = []\n    count = 0\n    \n    # Find the lines covered by each line segment\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        count += gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        lines.append((x1, y1, x2, y2))\n        \n    # Deal with the intersecting points\n    for i in range(N):\n        d = set()\n        for j in range(i+1, N):\n            px, py, qx, qy = lines[i]\n            rx, ry, sx, sy = lines[j]\n            \n            vecx = (px - qx, rx - sx)\n            vecy = (py - qy, ry - sy)\n            \n            # Cross of two lines        \n            area = cross(vecx[0], vecx[1], vecy[0], vecy[1])\n        \n            # Not interested in overlapping parallel lines\n            if area == 0: continue\n            \n            # Computation of the exact point\n            # This has been referenced from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n            lineA = cross(px, py, qx, qy)\n            lineB = cross(rx, ry, sx, sy)\n            x = cross(lineA, lineB, vecx[0], vecx[1]) / area\n            y = cross(lineA, lineB, vecy[0], vecy[1]) / area\n\n            # Verify the points are good. \n            # If the points are integers and lie of the lines they are valid.\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n    \n            d.add((x, y))\n            \n        count -= len(d)\n        \n    return count\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()", "\"\"\" \n1036E : Covered Points \nBorrows primarily from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n\"\"\"\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n    \n\ndef online(line, x, y):\n    \"\"\" If the x and y are within the range of min and max of x and y's respectively \n    then the points MAY lie on the line\n    \"\"\"\n    a, b, c, d = line\n    if min(a, c) <= x <= max(a, c) and min(b, d) <= y <= max(b, d):\n        return True\n    return False\n\n\ndef CF1036E():\n    N = int(input())\n    \n    lines = []\n    count = 0\n    # Read input line segment and find the lines covered by each line segment\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        count += gcd(abs(x1 - x2), abs(y1 - y2)) + 1\n        lines.append((x1, y1, x2, y2))\n        \n    # Deal with the intersecting points\n    for i in range(N):\n        d = set()  # Unique intersecting points\n        for j in range(i+1, N):\n            px, py, qx, qy = lines[i]\n            rx, ry, sx, sy = lines[j]\n            \n            vecx = (px - qx, rx - sx)\n            vecy = (py - qy, ry - sy)\n            \n            # Cross of two lines        \n            area = cross(vecx[0], vecx[1], vecy[0], vecy[1])\n        \n            # Parallel line has no intersecting points            \n            if area == 0: continue\n            \n            # Computation of the exact point\n            # This has been referenced from : https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n            lineA = cross(px, py, qx, qy)\n            lineB = cross(rx, ry, sx, sy)\n            x = cross(lineA, lineB, vecx[0], vecx[1]) / area\n            y = cross(lineA, lineB, vecy[0], vecy[1]) / area\n\n            # Verify the points are good. \n            # If the points are integers and lie of the lines they are valid.\n            if not (x % 1 == 0 and y % 1 == 0): continue\n            if not (online(lines[i], x, y) and online(lines[j], x, y)): continue\n    \n            d.add((x, y))\n            \n        count -= len(d)\n        \n    return count\n    \ndef __starting_point():\n    res = CF1036E()\n    print(res)\n__starting_point()"]
["import sys\n\n# B - log\nimport math\n\nn = int(input())\ni = math.floor(math.sqrt(n*2))-1\n\nwhile True:\n  total = (2+i) * (i+1) // 2\n\n  if total <= n+1:\n    i += 1\n  else:\n    break\n\nprint(n-i+1)", "#!/usr/bin/env python\n\ndef binarySearch(ok, ng, test):\n    \"\"\" \n    Binary search\n\n    Args:\n        ok(int) : test(x) == True \u3092\u78ba\u5b9f\u306b\u6e80\u305f\u3059\u70b9\n        ng(int) : test(x) == False \u3092\u78ba\u5b9f\u306b\u6e80\u305f\u3059\u70b9\n        test(function) : \u30c6\u30b9\u30c8\u5bfe\u8c61\u306e\u95a2\u6570\n    Returns:\n        ok(int) : test(x) == True \u3092\u78ba\u5b9f\u306b\u6e80\u305f\u3059\u70b9\u3067\u3001\n        \u3000\u3000\u3000\u3000\u3000\u6700\u7d42\u7684\u306b\u6c42\u307e\u308b\u3082\u306e\u3002\n    Note:\n        https://www.forcia.com/blog/001434.html\n\n    \"\"\"\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if test(mid):\n            ok = mid \n        else:\n            ng = mid \n    return ok\n\ndef test(x):\n    return x*(x+1)//2 <= n+1 \n\nn = int(input())\nk = binarySearch(1, 10**18+10, test)\nans = n-k+1\nprint(ans)\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\n\nok = 0\nng = 10 ** 18 + 1\n\ndef isOk(x):\n  if (1 + x) * x // 2 <= N + 1:\n    return True\n  return False\n  \nwhile abs(ng - ok) > 1:\n  mid = abs(ng + ok) // 2\n  if isOk(mid):\n    ok = mid\n  else:\n    ng = mid\n\nprint(N + 1 - ok)", "def resolve():\n    #n=int(input())\n    #a,b=map(int,input().split())\n    #x=list(map(int,input().split()))\n    #a=[list(map(lambda x:int(x)%2,input().split())) for _ in range(h)]\n    n=int(input())\n    l=0\n    r=10**18\n    m=0\n    while l+1<r:\n        m=(l+r)//2\n        if (m*(m+1)//2)<=n+1:\n            l=m\n        else:\n            r=m\n    print(n-l+1)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import sys\n\n# B - log\ndef is_match(k):\n\t# \u6761\u4ef6\u304c\"xx\u672a\u6e80\"\u306e\u5834\u5408\u3001\u3053\u3053\u306e\u4e0d\u7b49\u53f7\u3092\u5909\u3048\u308b\n\tif (1+k)*k//2 <= n+1:\n\t\treturn True\n\telse:\n\t\treturn False\n\n\nn = int(input())\n\nleft = -1\nright = n+1\n\n# \u30ea\u30b9\u30c8\u304c\u5358\u8abf\u5897\u52a0,\u5358\u8abf\u6e1b\u5c11\u3069\u3063\u3061\u3067\u3082 \u3053\u306e\u66f8\u304d\u65b9\u3067OK\nwhile right - left > 1:\n  mid = (left + right) // 2\n  #print(left, right, mid)\n\n  if is_match(mid):\n    left = mid\n  else:\n    right = mid\n\nprint(n-left+1)", "class BisectBase:\n\n    def __init__(self, n, asc):\n        self._n = n\n        self._lc = self.ge_item if asc else self.le_item\n        self._rc = self.gt_item if asc else self.lt_item\n\n    def lt_item(self, idx, item):\n        raise NotImplementedError(\"lt_item should be implemented\")\n\n    def gt_item(self, idx, item):\n        raise NotImplementedError(\"gt_item should be implemented\")\n\n    def le_item(self, idx, item):\n        raise NotImplementedError(\"le_item should be implemented\")\n\n    def ge_item(self, idx, item):\n        raise NotImplementedError(\"ge_item should be implemented\")\n\n    def bisect_left(self, item):\n        return self._bisect_left(item, 0, self._n)\n\n    def _bisect_left(self, item, left, right):\n        \"\"\"\u533a\u9593 [left, right) \u3067\u306e\u63a2\u7d22\n        \"\"\"\n        if right - left == 1:\n            return left + 1\n        mid = left + (right - left) // 2\n        if self._lc(mid, item):\n            return self._bisect_left(item, left, mid)\n        else:\n            return self._bisect_left(item, mid, right)\n\n    def bisect_right(self, item):\n        return self._bisect_right(item, 0, self._n)\n\n    def _bisect_right(self, item, left, right):\n        \"\"\"\u533a\u9593 [left, right) \u3067\u306e\u63a2\u7d22\n        \"\"\"\n        if right - left == 1:\n            return left + 1\n        mid = left + (right - left) // 2\n        if self._rc(mid, item):\n            return self._bisect_right(item, left, mid)\n        else:\n            return self._bisect_right(item, mid, right)\n\n\nclass Bisect(BisectBase):\n\n    def gt_item(self, idx, item):\n        return idx * (idx + 1) > item\n\n\nn = int(input())\nb = Bisect(n + 1, True)\nm = b.bisect_right(2 * (n+1)) - 1\nprint((n + 1 - m))\n", "n=int(input())\n\ndef func(ii): # (ii+1)*ii//2 > n+1\n  return (ii+1)*ii//2-(n+1)\n\n# bisect\nl=1\nr=n\n\nm=(r+l)//2 # for case n=1\n\nwhile r-l>1:\n  m=(r+l)//2\n  #print(l,m,r,func(l),func(m),func(r))\n  if func(m)==0:\n    break\n  if func(m)>0:\n    r=m\n  if func(m)<0:\n    l=m\n\nif func(r)==0:\n  c=r\nelif func(m)<=0:\n  c=m\nelse:\n  c=l\n\nprint(n-c+1)", "n = int(input())\nok, ng = 1, n+1\n\ndef is_ok(x):\n    if x*(x+1)//2 <= n+1: return True\n    else: return False\n\nwhile abs(ok-ng) > 1:\n    mid = abs(ok+ng)//2\n    if is_ok(mid): ok = mid\n    else: ng = mid\n\nprint(n+1-ok)", "n=int(input())\nimport math\nk=int((math.sqrt(8*n+9)-1)/2)\nif n>=10000:\n    for i in range(k-100,k+100):\n        if i**2+i>2*(n+1):\n            k=i-1\n            break\nprint(n+1-k)", "n = int(input())\n\nif n==1 or n==2:\n    print(1)\n    return\n\n\ndef cut(n):\n    l = 0\n    r = n\n    while r-l > 1:\n        mid = (l+r)//2\n        if mid*(mid+1)//2 <= (n+1):\n            l = mid\n        else:\n            r = mid\n    return l\n\nprint(n-cut(n)+1)", "\nimport sys\n# sys.setrecursionlimit(500000)\n\n\ninput = sys.stdin.readline\n\nN = int(input().strip())\nk_max = None\n\n# k_max\u3092\u6c42\u3081\u308b\nok = 0\nng = 2 * (N + 1)\nwhile abs(ok - ng) > 1:  # \u6761\u4ef6\u3092\u6e80\u305f\u3059index ok \u3068 \u6761\u4ef6\u3092\u6e80\u305f\u3055\u306a\u3044index ng \u304c \u3061\u3087\u3046\u3069 1 \u30ba\u30ec\u308b(\u3061\u3087\u3046\u3069ok\u3068ng\u3067\u5883\u754c\u306b\u306a\u308b)\u307e\u3067\u7d9a\u3051\u308b\n    mid = (ok + ng) // 2\n    if mid * (mid + 1) <= 2 * (N + 1):\n        ok = mid\n    else:\n        ng = mid\nk_max = ok\n# eprint(k_max)\nprint(N - k_max + 1)\n", "n = int(input())\n\ndef is_ok(arg):\n    return 2 * (n+1) < arg * (arg +1)\n\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok-1\n\nprint(n+1-meguru_bisect(1,n+1))", "n = int(input())\nif n <= 2:\n    print(1)\nelif n == 3:\n    print(2)\nelse:\n    s = 0\n    a = int((2*(n+1))**0.5)\n    l = lambda x: x*(x+1)//2\n    for i in range(a, n):\n        if l(i) > n + 1:\n            print(n - i + 2)\n            break", "n = int(input())\nok, ng = 0, 10 ** 18\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) // 2\n    m = (mid * (mid + 1)) // 2\n    if m <= n + 1:\n        ok = mid\n    else:\n        ng = mid\n\n# n+1\u3092\u30d0\u30e9\u305b\u30701~ok\u307e\u3067\u30ab\u30d0\u30fc\u3067\u304d\u308b\nprint((n - ok + 1))\n\n", "n = int(input())\nleft=0\nright=n+1\nwhile left<right-1:\n    mid = (left+right)>>1\n    if (mid*(mid+1))//2 <= n+1:\n        left=mid\n    else:\n        right=mid\nprint(n+1-left)", "def solve():\n    N = int(input())\n\n    ok = 1\n    ng = N+1\n\n    while abs(ok-ng) > 1:\n        mid = (ok + ng) // 2\n        if mid*(mid+1) // 2 <= N+1:\n            ok = mid\n        else:\n            ng = mid\n    \n    print((N-ok+1))\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import math\nn=int(input())\n \nans=n\nk=math.ceil(((n*8+9)**(1/2) - 1)/2) - 1\n\nwhile k*(k+1) <= 2*(n+1):\n  k += 1\n\nans -= k-2\n \nprint(ans)", "import sys, io\n_INPUT = \"\"\"\\\n2\n\"\"\"\n# sys.stdin = io.StringIO(_INPUT) # \u63d0\u51fa\u6642\u306b\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\ndef main():\n    n = int(input())\n    ng = n + 1\n    ok = 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        if mid * (mid + 1) // 2 <= n + 1:\n            ok = mid\n        else:\n            ng = mid\n    ans = n - ok + 1\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\nok=10**20\nng=0\nwhile ok-ng>1:\n    m=(ok+ng)//2\n    if m*(m+1)<=2*(n+1):\n        ng=m\n    else:\n        ok=m\nprint(n+1-ng)", "n = int(input())\nl, r = 0, 10**18\nwhile r-l > 1:\n    m = (l+r)//2\n    if m*(m+1)//2 <= n+1:\n        l = m\n    else:\n        r = m\nprint((n-l+1))\n", "from math import sqrt\n\nn = int(input())\ns = int(sqrt(2*(n+1)))\nwhile s * (s+1) <= 2 * (n+1):\n  s += 1\ns -= 1\nprint(n - s + 1)", "import math\nN = int(input())\n#N+1 \u3067\u3001 1\u304b\u3089k\u307e\u3067\u524a\u308a\u51fa\u305b\u308b\u3068\u3059\u308b\n#k(k+1) = 2*N+2\nOK = 0 #k(k+1)<=2N+2\nNG = 10**10\nwhile NG-OK > 1:\n    check = (OK+NG)//2\n    if check*(check+1) <= 2*N+2:\n        OK = check\n    else:\n        NG = check\nprint(N - OK + 1)", "N=int(input())\ndef f(k):\n  return (k+1)*k//2\n\ndef bi_re():\n  l=0;r=N+1\n  \n  while l<=r:\n    m=(l+r)//2\n    if f(m)>N+1:\n      r=m-1\n    elif f(m)<N+1:\n      l=m+1\n    else:\n      return m\n    \n  return r\n    \nk=bi_re()\nprint((N-k+1))\n  \n", "# \u5165\u529b\u3092\u6574\u6570\u306b\u5909\u63db\u3057\u3066\u53d7\u3051\u53d6\u308b\nimport sys\nsys.setrecursionlimit(10 ** 6)\n# \u5165\u529b\u3092\u6574\u6570\u306b\u5909\u63db\u3057\u3066\u53d7\u3051\u53d6\u308b\ndef II(): return int(sys.stdin.readline())\n# \u5165\u529b\u5168\u3066\u3092\u6574\u6570\u306b\u5909\u63db\u3057\u305f\u3082\u306e\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n# \u5165\u529b\u306e\u6587\u5b57\u5217\u30921\u6587\u5b57\u305a\u3064\u306b\u5206\u3051\u305f\u3082\u306e\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\ndef LC(): return list(input())\n# \u5165\u529b\u306e\u6570\u5b57\u5217\u30921\u6841\u305a\u3064\u306b\u5206\u3051\u305f\u3082\u306e\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\ndef IC():return [int(c) for c in input()]\n# \u5165\u529b\u5168\u3066\u3092\u6574\u6570\u306b\u5909\u63db\u3057\u30661\u5f15\u3044\u305f\u3082\u306e\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\nN = II()\nif(N == 1):\n    print(1)\nelse:\n    Big = N+1\n    NG = 0\n    OK = Big\n    def is_ok(arg):\n        # \u6761\u4ef6\u554f\u984c\u3054\u3068\u306b\u5b9a\u7fa9\n        return ((arg+2)*(arg+3))//2 >= Big\n    def meguru_bisect(ng, ok):\n        while (abs(ok - ng) > 1):\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    l = meguru_bisect(NG,OK)\n    while(l*(l+1)//2 <= Big):\n        l+=1\n    l-=1\n    print(Big-l)", "# arc109b\nn = int(input())\n\n# x(x+1)/2 <= n+1\n# x <= (-1+sqrt(8n+9))/2\n\nMX = 2 * (10 ** 9)\nl = 0\nr = MX\nwhile r - l > 1:\n    mid = (r+l)//2\n    if mid * (mid + 1) <= 2 * (n+1):\n        l = mid\n    else:\n        r = mid\nprint(n + 1 - l)", "n=int(input())\n\nleft = 0\nright = 10**10\n\nwhile(left+1<right):\n  mid = (left+right)//2\n  now = (mid*(mid+1))//2\n  if now<=n+1:\n    left= mid\n  else:\n    right = mid\nprint((n-left+1))\n", "import collections\n\ndef readLine():\n\treturn list(map(int, input().strip().split()))\n\ndef readInt():\n\treturn int(input())\n\ndef readString():\n\treturn input()\n\ndef tcase():\n\tt = readInt()\n\tfor _ in range(t):\n\t\tsolve()\n\n\ndef solve():\n\tn = readInt()\n\tlo, hi = 1, n\n\twhile lo < hi:\n\t\tmid = (lo + hi + 1) >> 1\n\t\tif mid * (mid + 1) // 2 <= n + 1:\n\t\t\tlo = mid\n\t\telse:\n\t\t\thi = mid - 1\n\tprint(n - lo + 1)\n\n\n\n\n\n\n# tcase()\nsolve()", "n = int(input())\n\n\"\"\"\u2460\u30001 + 2 + 3 + \u30fb\u30fb\u30fb+ k <= n + 1\u3000\u3092\u6e80\u305f\u3059\u6700\u5927\u306ek\u3092\u6c42\u3081\u308b\u3002\n\u3000 \u2461\u3000n - k + 1\u304c\u7b54\u3048\n\"\"\"\n\"\"\"\u4e8c\u5206\u63a2\u7d22\u6cd5\u3092\u7528\u3044\u3066k\u3092\u6c42\u3081\u308b\"\"\"\nleft = 0; right = n + 1\nwhile right - left > 1:\n    mid = left + (right - left) // 2\n\n    #\u5224\u5b9a\n    flag = True\n    if (1 + mid) * mid // 2 <= n + 1:\n        flag = True\n    else:\n        flag = False\n\n    if flag:\n        left = mid\n    else:\n        right = mid\n\n#print(left)\nprint((n - left + 1))\n", "n=int(input())\n\ndef f(k):\n    return k*(k+1)//2\n\nl=-1\nr=n+1\nwhile r-l>1:\n    mid=l + (r-l)//2\n\n    if f(mid)<=n+1:\n        l=mid\n    else:\n        r=mid\n\nans=n-l+1\n\nprint(ans)\n", "n=int(input())\nl=n+1\nk=int((2*l)**0.5//1)\nif l>=k*(k+1)//2:\n    print(n-k+1)\nelse:\n    print(n-(k-1)+1)", "n = int(input())\n\nx = 1\ny = n*2\nwhile y - x > 1:\n    mid = (y + x) // 2\n    s = (1 + mid) * mid // 2\n    # print(x, y, mid, s)\n    if s > n + 1:\n        y = mid\n    else:\n        x = mid\nk = x\n# k = int((-1 + (1 + 8 * (n + 1)) ** 0.5) / 2)\n# print(k)\nans = 1 + (n - k)\nprint(ans)\n", "N = int(input())\n\nhi = 10**18\nlo = -1\n\nwhile hi - lo > 1:\n    md = (hi + lo) // 2\n    if md * (md + 1) // 2 <= N + 1:\n        lo = md\n    else:\n        hi = md\n\nprint(N + 1 - lo)", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n\n\ndef main():\n\n    \n    n = int(input())\n    ok = n+1\n    ng = 0\n\n    while ok-ng>1:\n        mid = (ok+ng)//2\n        if n+1 >= (n+1-mid)*(n+1-mid+1)//2:\n            ok = mid\n        else:\n            ng = mid\n\n    print(ok)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nans=0\nok=1\nng=n+1\nwhile abs(ok-ng)>1:\n    #print(ok,ng)\n    mid=(ng+ok)>>1\n    if (n+1)>=((mid*(mid+1))>>1):\n        ok=mid\n    else:\n        ng=mid\nans=n-ok+1\nprint(ans)", "import math\n\nn = int(input())\n\nx = math.floor((-1+math.sqrt(8*n+9))/2)\n\nfor i in range (x+3,x-2,-1):\n    if (n+2)*(n+1)-i*(i+1) >= n*(n+1):\n        y = i\n        break\nprint(n+1-y)", "from math import sqrt, ceil\n\nn = int(input())\n\nm = ceil((-1 + sqrt(8 * n + 9)) / 2)\ns = m * (m + 1) - 2 * (n + 1)\nwhile s > 0:\n    m -= 1\n    s = m * (m + 1) - 2 * (n + 1)\nprint((n - m + 1))\n", "n =  int(input())\nright =  10**18+1\nleft =  -1\nwhile right - left >1:\n    mid =  (right+left) // 2\n    if mid*(mid+1)//2 > n+1:\n        right = mid\n    else:\n        left = mid\n        \nprint(n-left+1)", "from bisect import bisect, bisect_left\n\n\nclass BisectSearch:\n    @staticmethod\n    def search_float(f, l=0, r=10**9, epsilon=1e-9, return_left=False):\n        assert f(l) and (not f(r))\n        while r-l > epsilon:\n            m = (r+l) / 2\n            if f(m):\n                l = m\n            else:\n                r = m\n        if return_left:\n            return l\n        return r\n \n    @staticmethod\n    def search_int(f, l=0, r=10**9, return_left=False):\n        assert f(l) and (not f(r))\n        while r-l > 1:\n            m = (r+l) // 2\n            if f(m):\n                l = m\n            else:\n                r = m\n        if return_left:\n            return l\n        return r\n \n    @staticmethod\n    def search_list(key, A, return_left=False):\n        search = bisect_left if return_left else bisect\n        return search(A, key)\n\n\ndef arithmetic_series(n, d=1, a=1):\n    return n * (2*a + (n-1)*d) // 2\n\n\nn = int(input())\nbs = BisectSearch\n\ndef f(x):\n    return arithmetic_series(x) <= n+1\n\nprint(n+1-bs.search_int(f, l=1, r=n+1, return_left=True))", "n = int(input())\nLOW = 0\nHIGH = n\nr = 0\nnow = (LOW+HIGH)//2\nif n < 3:\n    print(1)\n    return\nwhile 1:\n    now = (LOW+HIGH)//2\n    cur = (now*(now+1))//2\n    nex = ((now+1)*(now+2))//2\n    if cur <= n+1 and n+1 < nex:\n        r = now\n        break\n    elif cur < n+1:\n        LOW = now\n    else:\n        HIGH = now\nprint(n-r+1)", "n = int(input())\nl = 0\nr = 10 ** 10\nwhile l < r - 1:\n    m = (l+r) // 2\n    check = (m+1) * m // 2\n    if check <= n + 1:\n        l = m\n    else:\n        r = m\nprint(n - l + 1)", "n=int(input())\ndef sqrt(n):\n    if n==0:return 0\n    x=1<<(n.bit_length()+1)//2\n    y=(x+n//x)//2\n    while y<x:\n        x=y\n        y=(x+n//x)//2\n    return x\n# find a s.t. a(a+1)//2<=n+1\ndef f(n):\n    #x**2+x-2(n+1)=0\n    #-1+(1+8(n+1))\n    return \nprint(n+1-(-1+sqrt(1+8*(n+1)))//2)", "N = int(input())\n\n# N + 1 \u306e\u4e38\u592a\u3092\u30011 + 2 + 3 + .... + ok \u306b\u5206\u5272\u3059\u308b\nok = 0\nng = 10 ** 18 + 1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) // 2\n    # 1 ~ mid\u307e\u3067\u306e\u516c\u5dee1\u306e\u7b49\u5dee\u6570\u5217\u306e\u548c\u304cN\uff0b1\u4ee5\u4e0b\u306e\u6642\u306fOK\n    if N + 1 >= mid * (mid + 1) // 2:\n        ok = mid\n    else:\n        ng = mid\n\n# 1\u304b\u3089\u5c0f\u3055\u3044\u9806\u306bok\u672c\u76ee\u307e\u3067\u306f\u3001N\uff0b1\u306e\u4e38\u592a\uff11\u672c\u3092\u5206\u5272\u3059\u308b\u3053\u3068\u3067\u5f97\u3089\u308c\u308b\n# \u305d\u308c\u4ee5\u5916\u306f\u666e\u901a\u306b\u4e00\u672c\u305a\u3064\u8cb7\u3046\u5fc5\u8981\u304c\u3042\u308b\nprint(N - ok + 1)", "n = int(input())\n\nnum = n + 1\nk = 0\n\nhigh = n + 1\nlow = 1\nwhile n > 0:\n    n = (low + high) // 2\n    temp = n * (n + 1) // 2\n    if temp <= num:\n        if low == n and low <= high:\n          break\n        low = n\n    else:\n        if high == n and high >= low:\n          break\n        high = n\n\n# print(low)\n# print(high)\nn = (low + high) // 2\n# print(n)\nprint(num - n)", "n = int(input())\n\nleft = 0\nright = n+1 \nwhile right - left > 1:\n    m = (right + left) // 2\n    if m * (m+1)//2 <= (n+1):\n        left = m\n    else:\n        right = m\n\n\nprint(n+1-left)", "def is_ok(k):\n    return k*(1+k)//2 <= n+1\n\ndef meguru_bisect(ng, ok):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if is_ok(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n\nn=int(input())\nans=meguru_bisect(n+1,0)\nprint(n+1-ans)", "# -*- coding: utf-8 -*-\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n = int(input())\n\n    if n == 1:\n        print((1))\n        return\n\n    left = 1\n    right = (n + 1)\n    result = 0\n    while(True):\n        k = (right + left) // 2\n        if k == right or k == left:\n            break\n\n        temp = k * (k + 1) // 2\n        if temp <= n + 1:\n            left = k\n            result = k\n        else:\n            right = k\n\n    print((n - result + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nl = 0\nr = 10**18\nwhile r - l >1:\n    mid = (r+l)//2\n    sum= mid*(mid+1)\n    if sum<=2*(n+1):\n        l=mid\n    else:\n        r = mid\n\nprint(n-l+1)", "def sigma(k):\n    return k * (k + 1) // 2\n\n\nn = int(input())\nub = 10 ** 18\nlb = 1\nwhile ub - lb > 1:\n    mid = (ub + lb) // 2\n    if sigma(mid) <= n + 1:\n        lb = mid\n    else:\n        ub = mid\nprint((n - lb + 1))\n", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nips = lambda:input().split()\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nimport sys\nceil = math.ceil\ngcd = math.gcd\nRL = sys.stdin.readline\nINF=10**15\ndef ceilab(a,b):\n    return (a+b-1)//b\n\nn=ni()\nl = 0\nr=n+1\nwhile r-l>1:\n    x = (r+l)//2\n    if x*(x+1)//2 >n+1:\n        r=x\n    else:\n        l=x\nprint(n+1-l)\n", "from decimal import Decimal\nn=int(input())\n\n\n# i=0\n# while True:\n#     i += 1\n#     if i*(i+1)//2 <= n+1:\n#         pass\n#     else:\n#         i -= 1\n#         break\n\n\ni = int((-1 + Decimal(1+8*(n+1)).sqrt())/2 )\n\nprint(n-i+1)        ", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN = int(input())\n\n# \u4f55\u756a\u76ee\u307e\u3067\u8cb7\u308f\u306a\u304f\u3066\u3044\u3044\u304b\nl, r = 0, 10**18\nwhile l+1<r:\n    half = (l+r)//2\n    if half*(half+1)//2<=N+1:\n        l = half\n    else:\n        r = half\n\nprint(N+1-l)", "n = int(input())\nif n <= 2:\n    print(1)\nelse:\n    l, r = 0, n\n    d = (l + r) // 2\n    while r - l > 1:\n        if d * (d + 1) <= 2 * (n + 1):\n            l = d\n        else:\n            r = d\n        d = (l + r) // 2\n    print(n-d+1)", "n=int(input())\nright=0\nleft=10**18\nwhile abs(right-left)>1:\n    k=(right+left)//2\n    if k*(k+1)<=(n+1)*2:\n        right=k\n    else:\n        left=k\nprint(n-right+1)", "from abc import ABCMeta, abstractmethod\n\n\nclass BisectBase(metaclass=ABCMeta):\n\n    def __init__(self, n, asc):\n        self._n = n\n        self._lc = self._ge if asc else self._le\n        self._rc = self._gt if asc else self._lt\n\n    @abstractmethod\n    def get(self, idx):\n        pass\n\n    def _lt(self, idx, item):\n        return self.get(idx) < item\n\n    def _gt(self, idx, item):\n        return self.get(idx) > item\n\n    def _le(self, idx, item):\n        return self.get(idx) <= item\n\n    def _ge(self, idx, item):\n        return self.get(idx) >= item\n\n    def bisect_left(self, item):\n        return self._bisect_left(item, 0, self._n)\n\n    def _bisect_left(self, item, left, right):\n        \"\"\"\u533a\u9593 [left, right) \u3067\u306e\u63a2\u7d22\n        \"\"\"\n        if right - left == 1:\n            return left if self._lc(left, item) else left + 1\n        mid = left + (right - left) // 2\n        if self._lc(mid, item):\n            return self._bisect_left(item, left, mid)\n        else:\n            return self._bisect_left(item, mid, right)\n\n    def bisect_right(self, item):\n        return self._bisect_right(item, 0, self._n)\n\n    def _bisect_right(self, item, left, right):\n        \"\"\"\u533a\u9593 [left, right) \u3067\u306e\u63a2\u7d22\n        \"\"\"\n        if right - left == 1:\n            return left if self._rc(left, item) else left + 1\n        mid = left + (right - left) // 2\n        if self._rc(mid, item):\n            return self._bisect_right(item, left, mid)\n        else:\n            return self._bisect_right(item, mid, right)\n\n\nclass Bisect(BisectBase):\n\n    def get(self, idx):\n        return idx * (idx + 1)\n\n\nn = int(input())\nb = Bisect(n + 2, True)\nm = b.bisect_right(2 * (n+1)) - 1\nprint((n + 1 - m))\n", "from math import sqrt\ndef solve(n):\n    z = 2*(n+1)\n    y = int(sqrt(z))\n    if y*(y+1) > z:\n        y -= 1\n    return n - y + 1\n\nn = int(input())\nprint(solve(n))", "n = int(input())\n\ndef is_ok(x):\n  if (n-x+1)*(n-x+2)//2 <= n+1:\n    return True\n  else:\n    return False\n\nng = 0\nok = n\nwhile ng+1 < ok:\n  c = (ok+ng)//2\n  if is_ok(c):\n    ok = c\n  else:\n    ng = c\nprint(ok)", "# %%\n# B\nn = int(input())\n\nfound = False\n\n\ndef search(small, large, border):\n    is_ok_l = border > int(large * (large + 1) / 2)\n    is_ok_s = border > int(small * (small + 1) / 2)\n    return is_ok_s, is_ok_l\n\n\nwidth = 2 ** 16\ns = 0\nl = 10 ** 5\n\nwhile not found:\n    is_s, is_l = search(s, l, n + 1)\n    if is_l and is_s:\n        width = int(width * 2)\n        l += width\n        s += width\n    elif not is_l and is_s:\n        width = int(width / 2)\n        l = s + width\n    else:\n        width = int(width / 2)\n        l -= width\n        s -= width\n    if width < 20:\n        break\n\nk = int(s)\nto = 0\nwhile not found:\n    accum = k * (k + 1) // 2\n    if accum > n + 1:\n        to = k - 1\n        break\n    elif accum == n + 1:\n        to = k\n        break\n    k += 1\n\nprint(n - to + 1)", "n=int(input())\n\nleft,right=0,10**18\nwhile right-left > 1:\n  mid=(left+right)//2\n  if mid*(mid+1)//2 <= n+1:\n    left=mid\n  else:\n    right=mid\n\nprint(n-left+1)", "from decimal import Decimal, ROUND_CEILING, getcontext\nn = Decimal(input())\nprint(\n    (\n        ((Decimal(2) * n + Decimal(3)) - (Decimal(8) * n + Decimal(9)).sqrt())\n        / Decimal(2)\n    ).to_integral_value(ROUND_CEILING)\n)", "# 1...s = 1 / 2 * s(s + 1)\n# n + 1 = 1 / 2 * s(s + 1)\n# 2n + 2 = s(s+1)\n# s = (-1 + pow(1 + 4 * (2 + 2 * n), 0.5)) / 2\n# n = 10^18 -> s = 1414213561.837... < 10^10\n\nn = int(input())\nleft = 0\nright = 10 ** 10\nwhile right - left > 1:\n    mid = (right + left) // 2\n    if mid * (mid + 1) <= 2 * n + 2:\n        left = mid\n    else:\n        right = mid\nprint((n - left + 1))\n", "n = int(input().strip())\n\nr = 10**19\nl = 0\nm = 0\nwhile l+1 < r:\n    m = (l+r) >> 1\n    if m * (1+m) >> 1 <= n+1:\n        l = m\n    else:\n        r = m\n\nprint(n-l+1)", "n=int(input())\n\ndef can(x):\n  return x*(x+1)//2<=n+1\n\nl=0\nr=n+1\n\nwhile r-l>1:\n  m=(l+r)//2\n  if can(m):\n    l=m\n  else:\n    r=m\nprint(n+1-l)", "n = int(input())\n\ndef possible(x):\n    if (1+x)*x <= 2*(n+1):\n        return True\n    else:\n        return False\n\nleft = 0\nright = 10**10\nwhile right-left > 1:\n    middle = (right+left)//2\n    if possible(middle):\n        left = middle\n    else:\n        right = middle\nprint(n+1-left)", "from decimal import Decimal, ROUND_CEILING\nn = Decimal(input())\nprint(((Decimal(2) * n + Decimal(3) - (Decimal(8) * n + Decimal(9)).sqrt()) / Decimal(2)).to_integral_value(ROUND_CEILING))", "from math import sqrt\nn = int(input())\nx = int(sqrt(2*n))\nwhile x*(x+1) <= 2*(n+1):\n    x += 1\nx -= 1\nprint(n+1-x)", "def solve():\n    N = int(input())\n\n    ng = N+1\n    ok = 1\n\n    while abs(ng-ok) > 1:\n        mid = (ok+ng) // 2\n        if mid*(mid+1)//2 <= N+1:\n            ok = mid\n        else:\n            ng = mid\n    \n    print((N-ok+1))\ndef __starting_point():\n    solve()\n\n__starting_point()", "n = int(input()) + 1\na = int(((8 * n + 1) ** 0.5 - 1) // 2)\nans = 0\nfor i in range(max(0, a - 100), a + 100):\n    if i * (i + 1) <= 2 * n and 2 * n < (i + 1) * (i + 2):\n        ans = n - i\n        break\nprint(ans)", "from decimal import *\nn = Decimal(input())\nprint((n-int(((n * 8 + 9).sqrt()-3)/2)))\n", "def __starting_point():\n\n    n = int(input())\n\n    #1+2+3+\u30fb\u30fb\u30fb+x <= n+1\u3068\u306a\u308b\u3088\u3046\u306a\u6700\u5927\u306ex\u3092\u6c42\u3081\u308b\n    \n    left=0\n    right=10**18+2\n\n    while left<right-1:\n        x = (left+right)//2\n        if (x*(x+1))//2 <= n+1:\n            left=x\n        else:\n            right=x\n    print((n+1-left))\n\n\n__starting_point()", "def bisect(item, l, r):\n    if r - l == 1:\n        return l + 1\n\n    m = l + (r - l) // 2\n    if m * (m+1) > item:\n        return bisect(item, l, m)\n    else:\n        return bisect(item, m, r)\n\n\nn = int(input())\nm = bisect(2 * (n+1), 0, n + 1) - 1\nprint((n + 1 - m))\n", "from decimal import Decimal\nn=int(input())\n\n# decimal\u3092\u4f7f\u3046\u65b9\n# i = int((-1 + Decimal(1+8*(n+1)).sqrt())/2 )\n\n# \u4e8c\u90e8\u63a2\u7d22\n\nleft=0\nright = n+1\nmid = (left+right)//2\n\nfor _ in range(100000):\n    \n    mid = (left+right)//2\n    \n    if mid*(mid+1)//2 > n+1:\n        right=mid\n        \n    else:\n        left=mid\n\ni=mid\n    \n\nprint((n-i+1))           \n", "n = int(input())\n\nleft = 0\nright = n + 2\nwhile left + 1 < right:\n    m = (left + right) // 2\n    if m * (m + 1) // 2 <= n + 1:\n        left = m\n    else:#ng\n        right = m\n# 1....left = n + 1\nprint((n + 1 - left))\n\n", "import math\n\nn = int(input())\n\ndef get(n):\n    temp = (math.sqrt(8*(n+1)+1)-1)/2\n    # print(\"Inside\",8*(n+1)+1)\n    # print(\"before /2\",math.sqrt(8*(n+1)+1)-1)\n    # print(\"temp\",temp)\n    return math.floor(temp)\n\ndef check(n):\n    target = get(n)\n    if (((target+1)*(target+2)//2) <= (n+1)):\n        return target+1\n    elif ((target*(target+1)//2) <= (n+1)):\n        return target\n    elif (((target-1)*target//2) <= (n+1)):\n        return target-1\n\n# print(\"get\",get(n))\n# print(\"check\",check(n))\nprint(n+1-check(n))", "n=int(input())\nif n==1 or n==2:\n    print(1)\n    return\ndef is_ok(arg):\n    return (1+arg)*(arg)//2<=n+1\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\ntmp=meguru_bisect(n+1,1)\nans=(n-tmp)\nprint(ans+1)", "n=int(input())\n\nl=1\nr=n+1\nfor i in range(1,100):\n\tmid=(l+r)//2\n\tif n+1>=(n-mid+2)*(n-mid+1)//2:\n\t\tr=mid\n\telse:\n\t\tl=mid\nprint(r)", "n = int(input())\nright =  10**18+1\nleft =  -1\nwhile right - left >1:\n    mid =  (right+left) // 2\n    if mid*(mid+1)//2 > n+1:\n        right = mid\n    else:\n        left = mid\n        \nprint(n-left+1)", "n = int(input())\nans = 0\ntarget = int((2 * (n + 1)) ** 0.5)\nfor num in range(max(target - 1000, 1), target + 1000):\n    if num * (num + 1) > 2 * (n + 1):\n        break\n    else:\n        ans = num\nprint(n - ans + 1)", "n=int(input())\nans=n+1\nsquare=int((n*2+2)**0.5)\nif n*2+2-square**2-square>=0:\n    pass\nelse:\n    square-=1\nprint((ans-square))\n", "n = int(input())\n\nnum = n + 1\nk = 0\n\nhigh = n + 1\nlow = 1\nwhile n > 0:\n    n = (low + high) // 2\n    temp = n * (n + 1) // 2\n    if temp <= num:\n        if low == n:\n          break\n        low = n\n    else:\n        if high == n:\n          break\n        high = n\n\n# print(low)\n# print(high)\nn = (low + high) // 2\n# print(n)\nprint(num - n)", "N=int(input())\nl=0\nr=10**100\nwhile(r-l>1):\n  m=(r+l)//2\n  if m*(m+1)<=2*(N+1):\n    l=m\n  else:\n    r=m\nprint((N-l+1))\n\n\n\n", "n = int(input())\n\nans = n\ncnt = 0\n\nwhile cnt <= n:\n    cnt += 100000\n    if cnt*(cnt+1)//2 > n+1:\n        cnt -= 100000\n        break\n    \nwhile cnt <= n:\n    cnt += 1\n    if cnt*(cnt+1)//2 > n+1:\n        cnt -= 1\n        break\n    \nprint(ans - cnt + 1)", "def solve(n):\n    return n * (n + 1) // 2\n\n\nN = int(input())\n\nleft = 0\nright = N + 1\nwhile abs(right - left) > 1:\n    mid = abs(right + left) // 2\n    if solve(mid) <= N + 1:\n        left = mid\n    else:\n        right = mid\n\nprint(N - left + 1)", "n = int(input())\n\ndef is_ok(x):\n  if (n-x+1)*(n-x+2)//2 <= n+1:\n    return True\n  else:\n    return False\n\nng = 0\nok = n\nwhile ng+1 < ok:\n  c = (ok+ng)//2\n  if is_ok(c):\n    ok = c\n  else:\n    ng = c\nprint(ok)", "n = int(input())\nx = int(((1+4*2*(n+1))**0.5-1)/2)\nif (x+1)*(x+2)<=(n+1)*2: x += 1\nif x*(x+1)>(n+1)*2: x -= 1\nans = n+1-x\nprint(ans)", "n=int(input())\nif n<=2:print(1);return\nng=0\nok=n\nwhile ng+1!=ok:\n  mid=(ng+ok)//2\n  if mid*(mid+1)//2<=n+1:ng=mid\n  else:ok=mid\nprint(n-ng+1)", "import sys, math, random, re, heapq\nfrom itertools import combinations as c, permutations as perm, product as p\nfrom collections import deque\nfrom copy import deepcopy\nsys.setrecursionlimit(10**9)\nINF = float('inf')\n#MOD = 10**9 + 7\nMOD = 998244353\nF = 1e-9\n\n\ndef si(): return input()\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef lstr(): return input().split()\ndef lint(): return list(map(int, input().split()))\ndef lintdec(): return list(map(lambda x:int(x) - 1, input().split()))\ndef lnstr(n): return [input() for _ in range(n)]\ndef lnint(n): return [ii() for _ in range(n)]\ndef lint_list(n): return [lint() for _ in range(n)]\ndef lcm(a, b): return a * b // math.gcd(a, b)\n\n\n\n#######################################################\nn = int(input())\n\nl = 1\nr = n + 1\nwhile r - l > 1:\n    mid = (l + r) // 2\n    s = mid * (mid + 1) // 2\n    if s <= n + 1:\n        l = mid\n    elif s > n + 1:\n        r = mid\n\nprint(n - l + 1)", "n = int(input())\nx = 1\ny = n + 1\nwhile y > x:\n    mid = (x+y+1)//2\n    if (mid+1)*mid//2 <= n+1:\n        x = mid\n    else:\n        y = mid - 1\nprint(n + 1 - y)", "n = int(input())\n\ndef check(k):\n    return  k*(k + 1) // 2<= n + 1#\u6761\u4ef6\u3092\u3053\u3053\u306b\u66f8\u304f\n \nleft = 0                   # True\nright = 10 ** 18 + 1      # False\n\nwhile left + 1 < right:\n    mid = (left + right) // 2\n    if check(mid):\n        left = mid\n    else:\n        right = mid\n\nprint((n - left + 1))\n", "def search(n):\n    s = 1\n    e = n\n    while(s<=e):\n        mid = (s+e)//2\n        if((mid*(mid+1)//2) <= n):\n            ans = mid\n            s = mid+1\n        else:\n            e = mid-1\n    return ans\nn = int(input())\nprint((1 + n - search(n+1)))\n", "n = int(input())\nl, r =0, 1000000000000000000\nwhile r - l > 1 :\n    m = (l+r)//2\n    tmps = m*(m+1)//2\n    if tmps <= n+1: l = m\n    else: r = m\nprint(n-l+1)", "from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\ndef solve():\n\n    n = int(input())\n    left = 1\n    right = n + 1\n    def ok(x):\n        return x * (x - 1) <= 2 * (n + 1)\n    while left < right:\n        mid = left + right + 1 >> 1\n        if ok(mid):\n            left = mid\n        else:\n            right = mid - 1\n    print(n - left + 2)\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "n = int(input())\n\n\n# \u9577\u3044\u65b9\u304b\u3089\u8cb7\u3063\u3066\u3044\u304f\n# \u9577\u3055m\u4ee5\u4e0b\u306f\u8cb7\u308f\u306a\u3044\u3068\u3059\u308b\u3068\u3001\u6761\u4ef6\u306b\u5f53\u3066\u306f\u307e\u308b\u306e\u304b\u5224\u5b9a\u3059\u308b\ndef maruta(m):\n    if n + 1 >= m * (m + 1) // 2:\n        return True\n    else:\n        False\n\n\n# \u4e8c\u5206\u63a2\u7d22\nleft = 1\nright = n + 1\nwhile left + 1 < right:\n    t = (left + right) // 2\n    # print(left, right, t, maruta(t))\n    if maruta(t):\n        left = t\n    else:\n        right = t\n    # print(left, right)\nprint((n+1-left))\n", "import math\nimport collections\n# for z in range(int(input())):\nn = int(input())\nK = 0\nl = 0\nr = n + 1\nm = 0\nwhile(r - l > 1):\n    m = ((l + r) // 2)\n    if ((m * (m + 1)) // 2) > n + 1:\n        r = m\n    else:\n        l = m\n# for k in range(n):\n#     if (k * (k + 1) / 2) > n + 1:\n#         break\n#     K = k\nprint((n - l + 1))\n\n\n", "# k = 1\u304b\u3089n\u307e\u3067\u306e k \u306e\u548c\ndef sigma1(n):\n    return n * (n + 1) // 2\n\nn = int(input())\n\ndef do():\n    l = 0\n    h = n\n    while l <= h:\n        mid = (l + h) // 2\n        if sigma1(mid) <= (n + 1):  # \u8cb7\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u306a\u3089\n            l = mid + 1  # \u8cb7\u3048\u308b\u306e\u3067\u305d\u308c\u4ee5\u4e0a\u306e\u6570\n        else:  # \u8cb7\u3048\u306a\u3044\u306a\u3089\n            h = mid - 1  # \u8cb7\u3048\u306a\u3044\u306e\u3067\u305d\u308c\u4ee5\u4e0b\u306e\u6570\u3092\u30c8\u30e9\u30a4\n    return (h if (sigma1(h) <= (n + 1)) else l)\n\nx = do()\n#print(x)\nprint(1 + (n - do()))", "def solve():\n    N = int(input())\n\n    left = 1\n    right = N+1\n\n    while right - left > 1:\n        mid = (left+right) // 2\n        if (mid*(mid+1)) // 2 > N+1:\n            right = mid\n        else:\n            left = mid\n    \n    print((N-left+1))\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import math\nfrom decimal import *\nn = int(input())\nm = int((-1 + Decimal(1 + 4 * (2 * n + 2)) ** Decimal(0.5)) / 2)\n\nprint((n - m + 1))\n", "n = int(input())\n\ndef main():\n    lb = 0\n    ub = 10**10\n    while ub-lb > 1:\n        mid = int((lb+ub)/2)\n        if n >= (mid+2)*(mid-1)//2:\n            lb = mid\n        else:\n            ub = mid\n    print(n-(lb-1))\n\nmain()"]
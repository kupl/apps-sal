["import sys\n\nsys.setrecursionlimit(5001)\nMOD = 10 ** 9 + 7\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor line in sys.stdin.readlines():\n    x, y = list(map(int, line.split()))\n    x -= 1\n    y -= 1\n    links[x].add(y)\n    links[y].add(x)\n\ndouble_factorial_odd = [0] * (n // 2)\nprev = 1\nfor i in range(n // 2):\n    prev = double_factorial_odd[i] = (2 * i + 1) * prev % MOD\n\n\ndef dfs(v, p):\n    ret = [0, 1]\n    for u in links[v]:\n        if u == p:\n            continue\n        res = dfs(u, v)\n        lt, ls = len(ret), len(res)\n        mrg = [0] * (lt + ls - 1)\n        for i in range(1 - lt % 2, lt, 2):\n            c = ret[i]\n            for j in range(1 - ls % 2, ls, 2):\n                mrg[i + j] = (mrg[i + j] + c * res[j]) % MOD\n        ret = mrg\n\n    if len(ret) % 2 == 1:\n        ret[0] = -sum(pattern * df % MOD for pattern, df in zip(ret[2::2], double_factorial_odd)) % MOD\n\n    return ret\n\n\nprint((MOD - dfs(0, -1)[0]))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nimport numpy as np\n\nMOD = 10 ** 9 + 7\nN = int(input())\n\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    x,y = list(map(int,input().split()))\n    graph[x].append(y)\n    graph[y].append(x)\n\n\"\"\"\n\u5305\u9664\u306e\u539f\u7406\u3002\u5404\u9802\u70b9\u3092\u6839\u3068\u3057\u3066\n\u30fb\u5076\u6570\u500b\u3092\u9078\u3076\u3001\u305d\u3053\u304c\u53cd\u4f8b\u3068\u306a\u3063\u3066\u3044\u308b\u3001\u4ed6\u306f\u4f55\u3067\u3082\u3088\u3044\u3001\n\u30fb\u5947\u6570\u500b\u3092\u9078\u3076\u3001\u305d\u3053\u304c\u53cd\u4f8b\u3068\u306a\u3063\u3066\u3044\u308b\u3001\u4ed6\u306f\u4f55\u3067\u3082\u3088\u3044\n\u30fb\u6839\u3092\u542b\u3080\u6210\u5206\u306f\u4fdd\u7559\u3057\u3066\u3042\u308b\u3002\u4fdd\u7559\u3057\u3066\u3044\u308b\u9802\u70b9\u306e\u6570\u3092\u6301\u3063\u3066\u304a\u304f\u3002\n\u30fb\u5076\u6570\u500b\u306e\u5834\u5408\u3068\u5947\u6570\u306e\u5834\u5408\u306e\u5dee\u5206\u3060\u3051\u6301\u3063\u3066\u304a\u304f\n\"\"\"\n\ndef dp_merge(data1,data2):\n    N1 = len(data1) - 1\n    N2 = len(data2) - 1\n    if N1 > N2:\n        N1,N2 = N2,N1\n        data1,data2 = data2,data1\n    data = np.zeros(N1+N2, dtype = np.int64)\n    for n in range(1,N1+1):\n        data[n:n+N2] += data1[n] * data2[1:] % MOD\n    data %= MOD\n    return data\n\nfact_2 = [1,0,1]\nfor n in range(3,N+10):\n    fact_2.append(fact_2[n-2] * (n-1) % MOD)\nfact_2 = np.array(fact_2, dtype = np.int64)\n\ndef dp_add_edge(data):\n    N = len(data) - 1\n    data1 = np.zeros(N+2, dtype=np.int64)\n    # \u8fba\u3092\u53cd\u4f8b\u306b\u52a0\u3048\u306a\u3044\n    data1[1:] = data\n    # \u8fba\u3092\u53cd\u4f8b\u306b\u52a0\u3048\u308b\n    data1[1] = - (data * fact_2[:N+1] % MOD).sum() % MOD\n    return data1\n\ndef dfs(v, parent = None):\n    data = None\n    for y in graph[v]:\n        if y == parent:\n            continue\n        data1 = dfs(y, v)\n        # merge\u3059\u308b\u524d\u306b\u3001\u6700\u5f8c\u306e\u8fba\u3092\u3072\u3068\u3064\u52a0\u3048\u308b\n        data1 = dp_add_edge(data1)\n        if data is None:\n            data = data1\n        else:\n            data = dp_merge(data, data1)\n    if data is None:\n        return np.array([0,1],dtype=np.int64)\n    return data\n\ndata = dfs(1)\n\nanswer = (data * fact_2[:N+1] % MOD).sum() % MOD\n\nprint(answer)\n\n"]
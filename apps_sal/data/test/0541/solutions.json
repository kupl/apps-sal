["n, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\nab = sorted(ab, key=lambda x: x[1])\ns = ab[0][1]\nans = 1\nfor i in ab:\n    if s <= i[0]:\n        ans += 1\n        s = i[1]\nprint(ans)", "N,M = map(int,input().split())\nW = sorted([list(map(int,input().split())) for m in range(M)],key=lambda x:x[1])\nc = 0\nx = 0\n\nfor a,b in W:\n   if x<a:\n      x=b-1\n      c+=1\n\nprint(c)", "n, m = map(int, input().split())\nc = [[0] * 2 for _ in range(m)]\nfor i in range(m):\n    c[i][1] , c[i][0] = map(int, input().split())\nc.sort()  #\u6a4b\u3092\u53d6\u308a\u9664\u304f\u6642\u306f\u3067\u304d\u308b\u3060\u3051b\u306e\u5cf6\u306b\u8fd1\u3044\u3068\u3053\u308d\u3067\u53d6\u308a\u9664\u304f\u3068\u826f\u3044\u3002\nx = -1  #\u76f4\u524d\u306b\u53d6\u308a\u9664\u3044\u305f\u6a4b\u306eindex\nans = 0\nfor i in range(m):\n    if c[i][1] > x:\n        x = c[i][0] - 1\n        ans += 1\nprint(ans)", "n, m = list(map(int, input().split()))\ncondition = [list(map(int, input().split())) for _ in range(m)]\n\ncondition.sort(key=lambda a: (a[1], a[0]))\n\nright_end = 0\nans = 0\nfor c in condition:\n    if c[0] >= right_end:\n        ans += 1\n        right_end = c[1]\nprint(ans)\n", "from operator import itemgetter\nN,M=map(int,input().split())\nislands=[list(map(int,input().split())) for _ in range(M)]\nislands.sort(key=itemgetter(1))\n\ni=0\ncnt=0\nwhile i<M:\n    j=0\n    while i+j<M and islands[i+j][0]<islands[i][1]:\n        j+=1\n    i+=j\n    cnt+=1\nprint(cnt)", "from operator import itemgetter\nN, M = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab.sort(key=itemgetter(1))\nans = [0]\nfor a, b in ab:\n    if ans[-1] < a:\n        ans.append(b-1)\nprint(len(ans) - 1)", "N, M = list(map(int, input().split()))\nB = [tuple(map(int, input().split())) for _ in range(M)]\nB.sort()\nr = 0\nres = 0\nfor a, b in B:\n    if a >= r:\n        res += 1\n        r = b\n    else:\n        r = min(r, b)\nprint(res)\n", "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\nhostility = [[] for _ in range(m)]\nfor i in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    hostility[i].append(a - 1)\n    hostility[i].append(b - 1)\n\nhostility = sorted(hostility, key = lambda x: x[1])\n\ncnt = 0\nbridge = -1\nfor i in range(m):\n    if hostility[i][0] <= bridge < hostility[i][1]:\n        continue\n    bridge = hostility[i][1] - 1\n    cnt += 1\nprint(cnt)", "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\n\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n    N, M = NMI()\n    ab = [NLI() for _ in range(M)]\n    \n    ENDsorted_sections= sorted(ab, key=lambda x: x[1])\n    \n    ans = 1\n    dropped_bridge = ENDsorted_sections[0][1]\n\n    for m in range(M):\n        if ENDsorted_sections[m][0] >= dropped_bridge:#\u65b0\u3057\u304f\u6a4b\u3092\u843d\u3068\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n            ans += 1\n            dropped_bridge = ENDsorted_sections[m][1]\n    print(ans)    \n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = list(map(int, input().split()))\na_b_l = []\nfor _ in range(M):\n    a_b_l.append(list(map(int, input().split())))\n\na_b_l = sorted(a_b_l, key=lambda x: x[1])\nans = 0\nprev_removed_bridge = 0\nfor a, b in a_b_l:\n    if a <= prev_removed_bridge:\n        continue\n    prev_removed_bridge = b - 1\n    ans += 1\nprint(ans)\n", "from operator import itemgetter\n\nn, m = map(int, input().split())\n\n# \u533a\u9593\u306e\u7d42\u7aef\u3067\u30bd\u30fc\u30c8\nab = sorted([tuple(map(int, input().split())) for i in range(m)], key=itemgetter(1))\n# \u524d\u56de\u9664\u3044\u305f\u6a4b\nremoved = -1\nans = 0\n\nfor a, b in ab:\n    # a \u304c removed \u3088\u308a\u5927\u304d\u3044 = \u307e\u3060\u53d6\u308a\u9664\u3044\u3066\u306a\u3044\n    if a > removed:\n        removed = b - 1\n        ans += 1\n\nprint(ans)", "N,M =  map(int, input().split())\nli = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    li.append([b,a])\nli.sort()\nan = 1\nnow_end = li[0][0]\nfor i in range(1,M):\n    if now_end <= li[i][1]:\n        an += 1\n        now_end = li[i][0]\nprint(an)", "n, m = list(map(int, input().split()))\nba = []\nfor i in range(m):\n    a, b = [int(x) - 1 for x in input().split()]\n    ba.append((b,a))\nba.sort()\ncount = 0\nprev_b = -1\nfor b, a in ba:\n    if a < prev_b:\n        continue\n    prev_b = b\n    count += 1\nprint(count)\n", "_,*l = [list(map(int,i.split())) for i in open(0)]\nl.sort(key=lambda x:x[1])\nA=S=0\nfor s,t in l:\n    if S<=s:\n        A+=1\n        S=t\nprint(A)", "def resolve():\n    import sys\n    from operator import itemgetter\n    \n    readline = sys.stdin.readline    # 1\u884c\u3060\u3051\u6587\u5b57\u5217\u306b\u3059\u308b\n\n    N, M = list(map(int, readline().split()))\n    AB = [list(map(int, readline().split())) for _ in [0] * M]\n    AB.sort(key=itemgetter(1))\n    islands = -float('inf')\n    ans = 0\n    for left, right in AB:\n        if islands <= left:\n            ans += 1\n            islands = right\n    print(ans)\n    \n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from operator import itemgetter\n\nn, m = map(int, input().split())\na = [0] * m\nb = [0] * m\n\nfor i in range(m):\n    a[i], b[i] = map(int, input().split())\n\nab = sorted([(a[i], b[i]) for i in range(m)], key=itemgetter(1))\n\n# \u524d\u56de\u9664\u3044\u305f\u6a4b\nremoved = -1\nans = 0\n\nfor a, b in ab:\n    # a \u304c removed \u3088\u308a\u5927\u304d\u3044 = \u307e\u3060\u53d6\u308a\u9664\u3044\u3066\u306a\u3044\n    if a > removed:\n        removed = b - 1\n        ans += 1\n\nprint(ans)", "from operator import itemgetter\n\nN, M = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(M)]\nab = sorted(ab, key=itemgetter(1))\n\n# \u524d\u56de\u53d6\u308a\u9664\u3044\u305f\u6a4b\nremoved = -1\nans = 0\n\nfor a, b in ab:\n    # a \u304c removed \u3088\u308a\u5927\u304d\u3044 = \u307e\u3060\u53d6\u308a\u9664\u3044\u3066\u3044\u306a\u3044\n    if a > removed:\n        removed = b - 1\n        ans += 1\n\nprint(ans)", "N, M = map(int, input().split())\nAB = []\n\nfor _ in range(M):\n  a, b = map(int, input().split())\n  AB.append((a, b))\n\nRsort = sorted(AB, key=lambda x: x[1])\ncnt = 0\nR = 0\n\nfor a, b in Rsort:\n  if a <= R:\n    continue\n  else:\n    cnt += 1\n    R = b-1\n\nprint(cnt)", "N, M = map(int, input().split())\nq = [list(map(int, input().split())) for _ in range(M)]\nq = sorted(sorted(q, key=lambda x: x[0]), key=lambda x: x[1])\n\nlast = 0\ncnt = 0\nfor a, b in q:\n    if last < a:\n        last = b-1\n        cnt += 1\n\nprint(cnt)", "# -*- coding: utf-8 -*-\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\nN, M = list(map(int, input().split()))\nrequests = []\nfor i in range(M):\n    a_i, b_i = list(map(int, input().split()))\n    requests.append((a_i, b_i))\n\n# \u6c42\u89e3\u51e6\u7406\nrequests = sorted(requests, key=lambda x: x[1])\nbridges = [requests[0][1] - 1]\nfor i in range(M):\n    a_i, b_i = requests[i]\n    if (bridges[-1] < a_i) or (b_i <= bridges[-1]):\n        bridges.append(b_i - 1)\nans = len(bridges)\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)\n", "N, M = map(int, input().split())\nQ = [tuple(map(int, input().split())) for _ in range(M)]\n\n# \u53f3\u5074\u304c\u5c0f\u3055\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3001\u5236\u7d04a<b\u306a\u306e\u3067\u305d\u306e\u307e\u307e\u4f7f\u3063\u3066\u3088\u3044\nQ = sorted(Q, key=lambda x: x[1])\n# \u5883\u754c\u3001\u53f3\u5074\u306e\u533a\u9593\u306e\u59cb\u307e\u308a\nborder = []\n\nfor a, b in Q:\n    flag = True\n    for x in border:\n        # \u65e2\u5b58\u306e\u5883\u754c\u3067\u5206\u3051\u3089\u308c\u308b\u304b\n        if a < x and x <= b:\n            flag = False\n            break\n    if flag:\n        border.append(b)\n\nans = len(border)\nprint(ans)", "n,m=map(int,input().split())\nR=[]\nfor i in range (m) :\n    a,b=map(int,input().split())\n    R.append ([b, a])\nR.sort()\n\ndef solve() :\n    ans,t=0,0\n    for i in range (m) :\n        if t<=R[i][1]:\n            ans+=1\n            t=R[i][0]\n    return ans\nprint (solve ())", "# atcoder -take a rest-(easy)\n#typical greedy\ndef main():\n    N, M = list(map(int, input().split()))\n    conflict = [tuple(map(int, input().split())) for i in range(M)]\n    newest_destroyed = -1\n    conflict.sort(key=lambda x: x[1])\n    res = 0\n    for l, r in conflict:\n        if not (l <= newest_destroyed < r):\n            res += 1\n            newest_destroyed = r-1\n    print(res)\n    return\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "N,M = list(map(int,input().split()))\n\narr = []\nfor _ in range(M):\n  a,b = list(map(int,input().split()))\n  arr.append((a,b))\n\narr.sort(key=lambda x: x[1])\nans = 1\n_, pb = arr[0]\nfor a,b in arr[1:]:\n  if a < pb <= b:\n    pass\n  else:\n    ans += 1\n    pb = b\nprint(ans)\n", "N, M = map(int, input().split())\nconflicts = [list(map(int, input().split())) for i in range(M)]\n\nintervals = []\nfor conflict in conflicts:\n    intervals.append([conflict[0], conflict[1]-1])\n\nintervals = sorted(intervals, key=lambda x: x[1])#interval[1]\u306e\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\n\ncount = 0\nend = -float(\"inf\")\nfor interval in intervals:\n    if interval[0] > end:\n        count += 1\n        end = interval[1]\n\nprint(count)", "x=c=0\nfor a,b in sorted([list(map(int,o.split()))for o in open(0)][1:],key=lambda p:p[1]):\n if a>x:x=b-1;c+=1\nprint(c)", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    AB = [None] * M\n    for i in range(M):\n        AB[i] = tuple(map(int, input().split()))\n\n    AB.sort(key=lambda x: x[1])\n\n    ans = 0\n    prev_x = -1\n    for a, b in AB:\n        if a <= prev_x < b:\n            pass\n        else:\n            ans += 1\n            prev_x = b - 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = list(map(int, input().split()))\ndata = [list(map(int, input().split())) for _ in range(M)]\ndata = sorted(data, key=lambda x: x[1])\n\ncount = 1\nleft = data[0][1]\nfor i in range(1, M):\n    if data[i][0] < left:\n        left = max(data[i][0], left)\n    else:\n        count += 1\n        left = data[i][1]\nprint(count)\n", "n, m = map(int, input().split())\n\nbridge = [None]*m\nfor i in range(m):\n  a, b = map(int, input().split())\n  bridge[i] = [b, a]\n\nans = 0\nbridge.sort()\n\nsub = -1\nans = 0\nfor v in bridge:\n  b, a = v[0], v[1]\n  if a >= sub:\n    sub = b\n    ans += 1\n\nprint(ans)", "n,m = map(int,input().split())\n\nls = []\nfor i in range(m):\n    x,l = map(int,input().split())\n    ls.append([x,l])\n    \nls = sorted(ls, key=lambda x: x[1])\nans =m\nfor i in range(1,m):\n    if ls[i][0] < ls[i-1][1]:\n      ls[i][1] = ls[i-1][1]\n      ans -=1\n        \nprint(ans)", "n, m = map(int, input().split())\nl = [list(map(int, input().split())) for i in range(m)]\n \nl = sorted(l, key = lambda x:(x[1], x[0]))\ncnt = m\n \nfor i in range(1, m):\n    if l[i-1][1] > l[i][0]:\n        l[i][1] = l[i-1][1]\n        cnt -= 1\n \nprint(cnt)", "N, M = map(int, input().split())\n\nab = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    ab.append((a, b))\nab.sort(key=lambda ab: ab[::-1])\n\nans = 0\nlast = -1\nfor a, b in ab:\n    if not a <= last < b:\n        last = b - 1\n        ans += 1\nprint(ans)", "from operator import itemgetter\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\n\nb = sorted(a, key=itemgetter(1))\n#print(b)\nremoved = -1\nans = 0\n\nfor i in range(m):\n  if b[i][0] > removed:\n    removed = b[i][1] - 1\n    ans += 1\n    \nprint(ans)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\n#- 1\u8981\u671b a\u2192c,b\u2192c\u5206\u65ad\u8981\u671b\u306b\u5bfe\u3057\u3066\u3001a<b\u306a\u3089b\u2192c\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u3044\u3044 -#\nwant_list = [0]*(N+1)\nfor _ in range(M):\n    a,b = list(map(int,input().split()))\n    want_list[b]=max(want_list[b],a)\n\n\n#-\u5206\u65ad\u3057\u305f\u6642\u306e\u6a4b\u3068index\u3068\u8981\u671b\u3092\u898b\u6bd4\u3079\u3066\u3001\u8981\u671b\u3092\u6e80\u305f\u3057\u3066\u3044\u306a\u3044\u306a\u3089\u30ab\u30a6\u30f3\u30c8\u3059\u308b-#\ncnt = 0\ncutNo = 0\nfor idx,val in enumerate(want_list):\n    if val >cutNo:\n        cutNo = idx-1\n        cnt += 1\nprint(cnt)\n\n", "N, M = map(int, input().split())\nneeds = []\nfor i in range(M):\n    x, y = map(int, input().split())\n    needs.append((x, y))\nneeds.sort(key=lambda x: x[1])\npb = needs[0][1]\nres = 1\nfor i in needs:\n    if i[0] >= pb:\n        res += 1\n        pb = i[1]\n\nprint(res)", "x=c=0\nfor b,a in sorted([[*map(int,t.split())][::-1]for t in open(0)][1:]):\n if a>x:x=b-1;c+=1\nprint(c)", "n,m=map(int,input().split())\nA=[]\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1 ;b-=1\n    A.append([a,b])\n\nA=sorted(A, key=lambda x:x[1])\nans=0\nlast=-5000\nfor l in A:\n    #print(a,b)\n    if last<l[0]:\n        ans+=1\n        last=l[1]-1\nprint(ans)", "N,M=list(map(int,input().split()))\nans=0\nl=[]\nfor i in range(M):\n   a,b=(map(int,input().split()))\n   l.append((a,b))\nl.sort(key=lambda x:x[1])\ncut=-1\nfor i,j in l:\n   if cut>=i:\n      continue\n   else:\n      ans+=1\n      cut=j-1\nprint(ans)", "n,m=list(map(int,input().split()))\na=[]\nfor _ in range(m):\n  b=list(map(int,input().split()))\n  a.append(b)\n  \na.sort()\n\nleft=a[0][0]\nright=a[0][1]\n\nans=1\n\nfor i in range(1,m):\n  x=a[i][0]\n  y=a[i][1]\n  \n  if left<=x<right:\n    left=x\n    right=min(right,y)\n    \n  else:\n    ans+=1\n    left=x\n    right=y\n    \nprint(ans)\n    \n", "def main():\n    n,m = list(map(int,input().split()))\n    brg = []\n    for i in range(m):\n        a,b = list(map(int,input().split()))\n        brg.append([a-1,b-1])\n    brg.sort()\n    ans = 1\n    s,e = brg[0]\n    for i in range(1,m):\n        s_,e_ = brg[i]\n        if e_<=e:\n            e = e_\n        if s_>=s:\n            s = s_\n        if e <= s_:\n            ans += 1\n            s = s_\n            e = e_\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M, *A = list(map(int, open(0).read().split()))\n*A, = list(zip(*[iter(A)]*2))\nA.sort()\ncnt = 0\nR = 0\nfor a, b in A:\n    if R <= a:\n        cnt += 1\n        R = b\n    elif b < R:\n        R = b\nprint(cnt)\n", "n,m=list(map(int, input().split()))\nab=[list(map(int,input().split()))  for i in  range(m)]\n\nab=sorted(ab, key=lambda x:(x[0],x[1]), reverse=True)\n#print(ab)\nnow=10**5+1\n\npreb=-1\nans=0\nfor i in range(m):\n  if ab[i][1]==preb:\n    continue\n  if ab[i][1]<=now:\n    now=ab[i][0]\n    preb=ab[i][1]\n    ans+=1\n    #print(\"now\",now)\nprint(ans)\n", "n, m = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(m)]\n\nab.sort(key=lambda x: x[1])\n\nans = m\nfor i in range(1, m):\n    if ab[i][0] < ab[i-1][1]:\n        ab[i][1] = ab[i-1][1]\n        ans -= 1\nprint(ans)\n", "N, M = list(map(int, input().split()))\n\ninstructions = []\nfor _ in range(M):\n    a = list(map(int, input().split()))\n    instructions.append(a)\ninstructions.sort(key=lambda x:x[1])\n\nans = 0\ncurrent = 0\nfor a, b in instructions:\n    if current < a: #\u904e\u53bb\u306e\u6761\u4ef6\u3067\u306f\u307e\u3060\u6e80\u305f\u3057\u3066\u306a\u3044\n        current = b-1\n        ans += 1\nprint(ans)\n", "n,m=map(int,input().split())\nlst=[list(map(int,input().split())) for i in range(m)]\nlst.sort(key=lambda x:x[1])\nans=1\npin=lst[0][1]-1\n\nfor i in range(1,m):\n  if lst[i][0]>pin:\n    ans+=1\n    pin=lst[i][1]-1\n\nprint(ans)", "n,m = map(int,input().split())\nc = [list(map(int,input().split())) for _ in range(m)]\nc.sort(key= lambda val : val[1])\n\nleft = 0\nans = 0\nfor i,[a,b] in enumerate(c):\n    if left <= a:\n        ans += 1\n        left = b\nprint(ans)", "n,m = map(int, input().split())\nt = [[n] for i in range(n)]\nfor i in range(m):\n  a,b = map(int, input().split())\n  t[a-1].append(b-1)\ng = []\nfor i in t:\n  g.append(min(i))\nk = 0\nans=0\nwhile k <=n-1:\n  e = min(g[k:])\n  if e==n:\n    break\n  ans+=1\n  k = e\nprint(ans)", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  n,m=LI()\n  l=[LI() for _ in range(m)]\n  l=sorted(l,key=lambda x:x[1])\n\n  ans=1\n  kiru=l[0][1]-0.1\n  for x,y in l[1:]:\n    if x<kiru<y:\n      continue\n    ans+=1\n    kiru=y-0.1\n\n  return ans\n\n# main()\nprint((main()))\n", "N,M=list(map(int,input().split()))\nab = [list(map(int,input().split())) for i in range(M)]\n\nans = 0\nab.sort(key=lambda x:x[1])\n\nrecent_cut = -1#\u76f4\u8fd1\u3067\u5207\u308a\u843d\u3068\u3057\u305f\u6a4b\u306e\u5de6\u306e\u8857\nfor i in range(M):\n    if recent_cut < ab[i][0]:\n        recent_cut = ab[i][1]-1\n        ans+=1\nprint(ans)\n", "N,M = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(M)]\nab.sort(key=lambda x: x[1])\nans = 0\npos = 0\nfor i in range(M):\n  if pos<ab[i][0]:\n    ans+=1\n    pos=ab[i][1]-1\nprint(ans)", "# -*- coding: utf-8 -*-\nN, M = list(map(int, input().split(' ')))\n\na_b_pairs = [list(map(int, input().split(' '))) for _ in range(M)]\na_b_pairs.sort(key=lambda x: x[1])\nright = a_b_pairs[0][1] - 1\n\nans = 1\nfor a, b in a_b_pairs[1:]:\n    if a > right:\n        right = b - 1\n        ans += 1\n\nprint(ans)\n\n\n\n", "# Segment tree (+)\nfrom operator import add\nfrom sys import stdin\n\n\nclass SegmentTree:\n    def __init__(self, size, op, e):\n        self._op = op\n        self._e = e\n        self._size = size\n        t = 1\n        while t < size:\n            t *= 2\n        self._offset = t - 1\n        self._data = [e] * (t * 2 - 1)\n\n    def __getitem__(self, key):\n        return self._data[self._offset + key]\n\n    def __setitem__(self, key, value):\n        op = self._op\n        data = self._data\n        i = self._offset + key\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def build(self, iterable):\n        op = self._op\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def query(self, start, stop):\n        def iter_segments(data, l, r):\n            while l < r:\n                if l & 1 == 0:\n                    yield data[l]\n                if r & 1 == 0:\n                    yield data[r - 1]\n                l = l // 2\n                r = (r - 1) // 2\n        op = self._op\n        it = iter_segments(self._data, start + self._offset,\n                           stop + self._offset)\n        result = self._e\n        for v in it:\n            result = op(result, v)\n        return result\n\nreadline = stdin.readline\n\nN, M = list(map(int, readline().split()))\nab = [list(map(int, readline().split())) for _ in range(M)]\n\nab.sort(key=lambda x: x[1])\nst = SegmentTree(N - 1, add, 0)\n\nresult = 0\nfor a, b in ab:\n    a, b = a - 1, b - 1\n    if st.query(a, b) != 0:\n        continue\n    result += 1\n    st[b - 1] = 1\nprint(result)\n", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, M = map(int, input().split())\n\nAB = [list(map(int, input().split())) for _ in range(M)]\nAB.sort()\n\nq = []\nfor ab in AB:\n    heapq.heappush(q, ab)\n\nans = 0\ncnt = M\nvisited = -1\nwhile cnt > 0:\n    ab = heapq.heappop(q)\n    cnt -= 1\n\n    # print(ab, visited, cnt)\n\n    if ab[1] > ab[0]:\n        heapq.heappush(q, [ab[1], ab[0]])\n        cnt += 1\n    else:\n        if visited <= ab[1]:\n            visited = ab[0]\n            ans += 1\n        else:\n            pass\n\nprint(ans)", "N, M = map(int, input().split())\na = []\nfor i in range(M):\n    x, y = map(int, input().split())\n    a.append([x, y])\na.sort(key=lambda x: x[1])\nans = 0\nfor i in range(M-1):\n    if a[i+1][0] < a[i][1]:\n        a[i+1][1] = a[i][1]\n    else:\n        ans += 1\nans += 1\nprint(ans)", "INF = 10**9\n\nN, M = map(int, input().split())\n\nrequests =[]\nfor _ in range(M):\n    requests.append(tuple(map(int, input().split())))\nrequests.sort(key=lambda x:x[1])\n\nend = 1\nans = 0\nfor i in range(M):\n    if end <= requests[i][0]:\n        ans += 1\n        end = requests[i][1]\n\nprint(ans)", "N,M = list(map(int,input().split()))\nl = [list(map(int,input().split())) for _ in range(M)]\nl.sort(key=lambda x: x[1])\nbroken_bridge = 0\nposition = 0\nfor i in range(M):\n    if position<l[i][0]:\n        broken_bridge+=1\n        position = l[i][1]-1\nprint(broken_bridge)\n", "n, m  = map(int, input().split())\na = [list(map(int, input().split())) for i in range(m)]\na = sorted(a, key=lambda x :x[1])\nbridge = a[0][1] - 1\nans = 1\n\nfor i in range(1, m):\n    if a[i][0] > bridge:\n        bridge = a[i][1] - 1\n        ans += 1\n        \nprint(ans)", "n,m=list(map(int,input().split()))\np=[]\nfor _ in range(m):\n  a,b=list(map(int,input().split()))\n  p.append([a,b])\n#print(p)\np.sort(key=lambda x:x[1])\n#print(p)\nans=0\ncur=0\nfor i in range(m):\n  if cur<=p[i][0]:\n    #print(\"i:%d\u6b8b\u3059,cur:%d,p[i][1]:%d,p[i][0]:%d\" % (i,cur,p[i][1],p[i][0]))\n    ans+=1\n    cur=p[i][1]\nprint(ans)\n", "N,M = map(int,input().split())\narr = []\nfor _ in range(M):\n  a,b = map(int,input().split())\n  arr.append((a,b))\narr.sort(key=lambda x: x[1])\nans = 1\n_, pb = arr[0]\nfor a,b in arr[1:]:\n  if pb <= a:\n    ans += 1\n    pb = b\nprint(ans)", "N, M = list(map(int, input().split()))\nB = [0] * M\nfor i in range(M):\n  B[i] = list(map(int, input().split()))\n  \nB = sorted(B, key = lambda x:x[1])\nremove = []\n#print(B)\nfor i in range(M):\n  a, b = B[i][0], B[i][1]\n  if remove == []:\n    remove.append(b - 1)\n  elif max(remove) >= a:\n    continue\n  else:\n    remove.append(b - 1)\n  #print(remove)  \nprint((len(remove)))    \n\n\n", "from operator import itemgetter\n\nn, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\ncd = sorted(ab, key=itemgetter(1))\n#print(cd)\nremoved = -1\nans = 0\n\nfor a, b in cd:\n  if a > removed:\n    removed = b - 1\n    ans += 1\n    \nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int,input().split())\nbridges = []\nfor _ in range(M):\n    a, b = map(int,input().split())\n    bridges.append([a, b])\n\nbridges.sort(key = lambda x: x[1])\n\np = 0\nt = 0\n\nwhile len(bridges) > 0:\n    t = bridges[0][1]\n    p += 1\n    bridges = [i for i in bridges if i[0] >= t]\n\nprint(p)", "# -*- coding: utf-8 -*-\n\ndef get_input() -> tuple:\n    \"\"\"\n    \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\u3059\u308b.\n\n    Returns:\\n\n        tuple: \u6a19\u6e96\u5165\u529b\n    \"\"\"\n    N, M = list(map(int, input().split()))\n    requests = []\n    for i in range(M):\n        a_i, b_i = list(map(int, input().split()))\n        requests.append((a_i, b_i))\n\n    return N, M, requests\n\n\ndef main(N: int, M: int, requests: list) -> None:\n    \"\"\"\n    \u30e1\u30a4\u30f3\u51e6\u7406.\n\n    Args:\\n\n        N (int): \u5cf6\u306e\u6570(2 <= N <= 10^5)\n        M (int): \u8981\u671b\u306e\u6570(1 <= M <= 10^5)\n        requests (list): \u8981\u671b(1 <= a_i < b_i <= N)\n    \"\"\"\n    # \u6c42\u89e3\u51e6\u7406\n    requests = sorted(requests, key=lambda x: x[1])\n    bridge = 0\n    ans = 0\n    for i in range(M):\n        a_i, b_i = requests[i]\n        if a_i > bridge:\n            bridge = b_i - 1\n            ans += 1\n\n    # \u7d50\u679c\u51fa\u529b\n    print(ans)\n\n\ndef __starting_point():\n    # \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n    N, M, requests = get_input()\n\n    # \u30e1\u30a4\u30f3\u51e6\u7406\n    main(N, M, requests)\n\n__starting_point()", "n, m = list(map(int, input().split()))\nab = [list(map(int, input().split())) for i in range(m)]\nab.sort()\nans = 0\nnow = 1\nfor i in range(m):\n\tif now <= ab[i][0]:\n\t\tans += 1\n\t\tnow = ab[i][1]\n\tnow = min(now, ab[i][1])\nprint(ans)", "N, M = list(map(int, input().split()))\nAB = sorted([list(map(int, input().split())) for _ in range(M)])\n\nAB = sorted(AB, reverse=False, key=lambda x: x[1])\n\nlast_b = AB[0][1] - 1  # \u6700\u521d\u306b\u6f70\u3059\u6a4b\ncnt = 1  # \u4e0a\u3067\u4e00\u3064\u58ca\u3057\u3066\u308b\u306e\u3067+1\nfor a, b in AB:\n    if a <= last_b:\n        continue\n    else:\n        last_b = b - 1\n        cnt += 1\nprint(cnt)\n", "\nn, m = list(map(int, input().split()))\nl = [list(map(int, input().split())) for i in range(m)]\n\nl = sorted(l, key = lambda x:(x[1], x[0]))\ncnt = 0\ncon_l = 0\n\nfor i in range(m):\n    if con_l <= l[i][0]:\n        cnt += 1\n        con_l = l[i][1]\n\nprint(cnt)\n", "n, m = list(map(int, input().strip().split()))\nab_list = [list(map(int, input().strip().split())) for _ in range(m)]\nab_list.sort(key=lambda x: x[1])\n\nres = 0\nmin_r = 0\nfor ab in ab_list:\n    if min_r <= ab[0]:\n        res += 1\n        min_r = ab[1]\nprint(res)\n", "from operator import itemgetter\n\nn, m = map(int, input().split())\n\n# \u533a\u9593\u306e\u7d42\u7aef\u3067\u30bd\u30fc\u30c8\nab = sorted([tuple(map(int, input().split())) for i in range(m)], key=itemgetter(1))\n# \u524d\u56de\u9664\u3044\u305f\u6a4b\nremoved = -1\nans = 0\n\nfor a, b in ab:\n    # a \u304c removed \u3088\u308a\u5927\u304d\u3044 = \u307e\u3060\u53d6\u308a\u9664\u3044\u3066\u306a\u3044\n    if a > removed:\n        removed = b - 1\n        ans += 1\n\nprint(ans)", "(n, m), *l = [list(map(int, o.split())) for o in open(0)]\nx = c = 0\nfor a, b in sorted(l, key = lambda p:p[1]):\n  if a > x:\n    x = b - 1\n    c += 1\nprint(c)", "N,M,*A=map(int,open(0).read().split());c=0\nfor a,b in sorted(zip(*[iter(A)]*2))[::-1]:\n\tif b<=N:c+=1;N=a\nprint(c)", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, m = ns()\n    d = []\n    for _ in range(m):\n        a, b = ns()\n        d.append([a - 1, b - 1])\n\n    d.sort(key=lambda x: x[1])\n\n    down = []\n\n    for a, b in d:\n        idx = bisect.bisect_left(down, a)\n        if idx == len(down):\n            down.append(b - 1)\n    print((len(down)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\nQ = [tuple(map(int, input().split())) for _ in range(M)]\n\n# \u53f3\u5074\u304c\u5c0f\u3055\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3001\u5236\u7d04a<b\u306a\u306e\u3067\u305d\u306e\u307e\u307e\u4f7f\u3063\u3066\u3088\u3044\nQ = sorted(Q, key=lambda x: x[1])\n# \u5883\u754c\u3001\u53f3\u5074\u306e\u533a\u9593\u306e\u59cb\u307e\u308a\nborder = -1\nans = 0\n\nfor a, b in Q:\n    # \u65e2\u5b58\u306e\u5883\u754c\u3067\u5206\u3051\u3089\u308c\u306a\u3044\u3068\u304d\u306f\u53f3\u306b\u305a\u3089\u3059\n    if border <= a:\n        ans += 1\n        border = b\n\nprint(ans)", "n, m = list(map(int, input().split()))\nab = sorted([tuple(map(int, input().split())) for _ in range(m)], key = lambda x:x[1])\nremoved = -1\nans = 0\nfor a, b in ab:\n    if a > removed:\n        removed = b-1\n        ans += 1\nprint(ans)\n", "n,m=map(int,input().split())\ndata=[]\nfor i in range(m):\n  a,b=map(int,input().split())\n  data.append([b,a])\ndata.sort()\nr,l=data[0]\ncnt=1\nfor i in range(1,m):\n  if data[i][1]>=r:\n    cnt+=1\n    r,l=data[i]\n  else:\n    r=min(r,data[i][0])\n    l=max(l,data[i][1])\nprint(cnt)", "def IslandsWar():\n    n, m = list(map(int, input().split()))\n    a = [list(map(int,input().split())) for _ in range(m)]\n    a.sort(key=lambda x: x[1])\n    removes = [a[0][1]]\n\n    for i, j in a[1:]:\n        check = False\n        for k in removes:\n            if i < k:\n                check = True\n                break\n        if not check:\n            removes.append(j)\n    print((len(removes)))\n            \ndef __starting_point():\n    IslandsWar()\n\n__starting_point()", "_,*li = [list(map(int,i.split())) for i in open(0)]\nli.sort(key=lambda x:x[1])\nA = 0\nS = 0\nfor s,t in li:\n    if S<=s:\n        A+=1\n        S=t\nprint(A)", "N,M = map(int,input().split())\ntable = []\nfor i in range(M):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    table.append((a,b))\ntable = sorted(table,key=lambda x:x[1])\ncur_r = table[0][1]\nans = 1\nfor i in range(1,M):\n    l,r = table[i]\n    if cur_r <= l:\n        ans += 1\n        cur_r = r\n\nprint(ans)", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, m = ns()\n    d = []\n    for _ in range(m):\n        a, b = ns()\n        d.append([a - 1, b - 1])\n\n    d.sort(key=lambda x: x[1])\n\n    down = -1\n    ans = 0\n    for a, b in d:\n        if down < a:\n            down = b-1\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nN, M, *AB = [int(_) for _ in open(0).read().split()]\nAB = sorted(zip(AB[::2], AB[1::2]))\nl, r = AB[0]\nans = 1\nfor a, b in AB[1:]:\n    if r <= a:\n        l, r = a, b\n        ans += 1\n    else:\n        r = min(r, b)\nprint(ans)\n", "n,m=map(int,input().split())\nans=0\nhead=1\nfrom operator import itemgetter as it\nfor x,y in sorted([list(map(int,input().split()))for i in range(m)],reverse=0,key=lambda x:(it(1)(x)*(n+1)*10-it(0)(x))):\n    if not(x<head <=y):\n        head=y\n        ans+=1\nprint(ans)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    ab = [LI_() for _ in range(M)]\n    ab.sort(key=lambda x: x[1])\n\n    # \u533a\u9593\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\n    ans = 0\n    # print(ab)\n    right = -1\n    for a, b in ab:\n        if right <= a:\n            right = b\n            ans += 1\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,M = map(int,input().split())\nls = [tuple(map(int,input().split())) for _ in range(M)]\nls.sort(key=lambda x:x[1],reverse=True)\nls.sort(key=lambda x:x[0],reverse=True)\nr = N\ncnt = 0\nfor i in range(M):\n    a,b = ls[i]\n    if b <= r:\n        cnt += 1\n        r = a\nprint(cnt)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\ndef main():\n    N, M = list(map(int, input().split()))\n    ab = []\n    for _ in range(M):\n        a, b = [int(x)-1 for x in input().split()]\n        ab.append((b,a))\n    ab.sort()\n    # print(ab)\n    ans = 0\n    x = -1\n    for i in range(M):\n        if ab[i][1] > x:\n            ans += 1\n            x = ab[i][0]-1\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from operator import itemgetter\n\nn, m = map(int, input().split())\n\n# \u533a\u9593\u306e\u7d42\u7aef\u3067\u30bd\u30fc\u30c8\nab = sorted([tuple(map(int, input().split())) for i in range(m)], key=itemgetter(1))\n# \u524d\u56de\u9664\u3044\u305f\u6a4b\nremoved = -1\nans = 0\n\nfor a, b in ab:\n    # a \u304c removed \u3088\u308a\u5927\u304d\u3044 = \u307e\u3060\u53d6\u308a\u9664\u3044\u3066\u306a\u3044\n    if a > removed:\n        removed = b - 1\n        ans += 1\n\nprint(ans)", "#!/usr/bin/env python3\n\nn, m = list(map(int, input().split()))\n\n# for i in range():\n\nab = [list(map(int, input().split())) for _ in range(m)]\n\nab.sort()\n# print(ab)\nans = 0\ndiv = -1, -1\nfor i in range(len(ab)):\n    a, b = ab[i]\n    # print(a, b)\n\n    if a == div[0]:\n        continue\n    elif a >= div[1]:\n        div = a, b\n        ans += 1\n    else:\n        div = a, min(b, div[1])\n    # print(div, ans)\n\nprint(ans)\n", "N, M = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab.sort(key=lambda x: x[1])  # Sort the list of (a, b) by b\n\nans = 0\ncur = -1\nfor i in range(M):\n    a, b = ab[i]\n    if a < cur:\n        continue\n    ans += 1\n    cur = b\n\nprint(ans)\n", "N, M = map(int, input().split())\nreq = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    req.append([a, b])\n\nreq = sorted(req, key=lambda x: x[1])\n\nans = 1\ncurrent = req[0][1]\nfor i in range(1, len(req)):\n    if req[i][0] < current:\n        continue\n    current = req[i][1]\n    ans += 1\nprint(ans)", "N,M = map(int,input().split())\nwarzones = [[] for i in range(M)]\nfor i in range(M):\n    a,b = map(int,input().split())\n    a -= 1\n    b -=1\n    warzones[i] = [a,b]\nwarzones = sorted(warzones,key=lambda x:x[0])\n#print(warzones)\nshaku = warzones[0]\ncnt = 1\nfor i in range(1,M):\n    #print(shaku)\n    #\u5c3a\u7d99\u7d9a\u6761\u4ef6\n    if(warzones[i][0] < shaku[1]):\n        shaku[0] = max(warzones[i][0],shaku[0])\n        shaku[1] = min(warzones[i][1],shaku[1])\n    else:\n        cnt += 1\n        shaku = warzones[i]\n\nprint(cnt)\n\n'''\u5c3a\u53d6\u6cd5\u306e\u521d\u671f\u5316\n\u6700\u521d\u306b\u914d\u5217\u306elists[0]\u3067\u521d\u671f\u5316\nfor i in range(1,M):\u3067\u307e\u308f\u3057\u3066\nok\u306e\u5834\u5408lists[i]\u3092\u4ee3\u5165\nng\u306e\u3068\u304d\u306f\u30ab\u30a6\u30f3\u30c8\u3092\u5897\u3084\u3057\u3066ng\u3067\u518d\u521d\u671f\u5316\n'''", "# \u521d\u671f\u5165\u529b\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\n\nN,M = map(int, input().split())\nans =1\nab =[0]*M\nfor i in range(M):\n    a,b = map(int, input().split()) #\u4e89\u3044\u306e\u3042\u308b\u90e8\u5206\n    ab[i] =(a,b)\n\n#ab\u3092b\u3067\u30bd\u30fc\u30c8\nab.sort(key=lambda x: x[1],reverse=True)\nmax_a =ab[0][0]\nfor a,b in ab:\n    if max_a < b:\n        max_a =max(max_a,a)\n        continue\n    else:\n        max_a =a\n        ans +=1\nprint(ans)", "from operator import itemgetter\nn,m = map(int,input().split())\nlis = []\nfor _ in range(m):\n    lis.append(list(map(int,input().split())))\nlis.sort(key = itemgetter(1))\nans = 0\nlast = 0\nfor i in range(m):\n    if last <= lis[i][0]:\n        ans += 1\n        last = lis[i][1]\nprint(ans)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *AB = list(map(int, read().split()))\n\n    Q = [[] for _ in range(N - 1)]\n    for i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n        Q[a - 1].append(b - 2)\n\n    min_y = INF\n    ans = 0\n    for i, ys in enumerate(Q):\n        if ys:\n            min_y = min(min_y, min(ys))\n        if i == min_y:\n            ans += 1\n            min_y = INF\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = list(map(int,input().split()))\nl = sorted(list( list(map(int,input().split())) for _ in range(m)), key=lambda x: x[1])\nbr = -1\nans = 0\nfor i in l:\n    head, tail = i[0], i[1]\n    if head < br:\n        continue\n    else:\n        br = tail\n        ans += 1\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\n#- 1\u8981\u671b a\u2192c,b\u2192c\u5206\u65ad\u8981\u671b\u306b\u5bfe\u3057\u3066\u3001a<b\u306a\u3089b\u2192c\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u3044\u3044 -#\nwant_list = [0]*(N+1)\nfor _ in range(M):\n    a,b = list(map(int,input().split()))\n    want_list[b]=max(want_list[b],a)\n\n\n#-\u5206\u65ad\u3057\u305f\u6642\u306e\u6a4b\u3068index\u3068\u8981\u671b\u3092\u898b\u6bd4\u3079\u3066\u3001\u8981\u671b\u3092\u6e80\u305f\u3057\u3066\u3044\u306a\u3044\u306a\u3089\u30ab\u30a6\u30f3\u30c8\u3059\u308b-#\ncnt = 0\ncutNo = 0\nfor idx,val in enumerate(want_list):\n    if val >cutNo:\n        cutNo = idx-1\n        cnt += 1\nprint(cnt)\n", "# -*- coding: utf-8 -*-\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\nN, M = list(map(int, input().split()))\nrequests = []\nfor i in range(M):\n    a_i, b_i = list(map(int, input().split()))\n    requests.append((a_i, b_i))\n\n# \u6c42\u89e3\u51e6\u7406\nrequests = sorted(requests, key=lambda x: x[1])\nbridge = 0\nans = 0\nfor i in range(M):\n    a_i, b_i = requests[i]\n    if a_i > bridge:\n        bridge = b_i - 1\n        ans += 1\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)\n"]
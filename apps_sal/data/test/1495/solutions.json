["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom collections import defaultdict\n\nn = int(input())\nA = list(map(int,input().split()))\npattern = set()\nfor a in A:\n    p = []\n    while a > 0:\n        if a in pattern:\n            break\n        p.append(a)\n        a = a//2\n    pattern |= set(p)\n\ndef check(v):\n    ret = 0\n    for a in A:\n        count = 0\n        while a != 0:\n            if v == a or (v % a == 0 and (v//a)&-(v//a) == v//a):\n                ret += len(bin(v//a))-3\n                break\n            if (v%a == 0 and (v//a)&-(v//a) == v//a) and a < v:\n                return 1e12\n            a = a//2\n            ret += 1\n        else:\n            return 1e12\n    return ret\n\nans = 1e12\nfor p in pattern:\n    ret = check(p)\n    ans = ans if ans < ret else ret\nprint(ans)\n", "def main():\n    input()\n    aa = list(map(int, input().split()))\n    le, l = max(aa).bit_length(), []\n    for i, a in enumerate(aa):\n        j = le - a.bit_length()\n        aa[i] = a << j\n        l.append(j)\n    mi, ma = min(aa), max(aa)\n    a = mask = (1 << le) - 1\n    if mi == ma:\n        while mi == mi & a:\n            mask = a\n            a &= a << 1\n    else:\n        while mi != ma:\n            mask &= mask << 1\n            mi >>= 1\n            ma >>= 1\n        while not (mi & 1):\n            mask &= mask << 1\n            mi >>= 1\n    mask ^= (1 << le) - 1\n    le = mask.bit_length() + 1\n    res = [0] * le\n    cache = {}\n    for a, i in zip(aa, l):\n        a &= mask\n        if a:\n            a = a.bit_length()\n        tmp = cache.get((i, a))\n        if tmp is None:\n            cache[i, a] = tmp = [0] * le\n            if a:\n                base, baseidx = a - i, le - a - 1\n            else:\n                base, baseidx = 0, le - i - 1\n            i, j = baseidx, base\n            while i:\n                i -= 1\n                j += 1\n                tmp[i] = j\n            i, j = baseidx, base\n            while i < le:\n                tmp[i] = j\n                i += 1\n                j += 1\n        for i, j in enumerate(tmp):\n            res[i] += j\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\n\ndef main():\n    input()\n    aa = list(map(int, input().split()))\n    le, l = max(aa).bit_length(), []\n    for i, a in enumerate(aa):\n        j = le - a.bit_length()\n        aa[i] = a << j\n        l.append(j)\n    mi, ma = min(aa), max(aa)\n    a = mask = (1 << le) - 1\n    if mi == ma:\n        while mi == mi & a:\n            mask = a\n            a &= a << 1\n    else:\n        while mi != ma or not (mi & 1):\n            mask &= mask << 1\n            mi >>= 1\n            ma >>= 1\n    mask ^= (1 << le) - 1\n    le, cnt = mask.bit_length(), Counter()\n    for a, i in zip(aa, l):\n        a &= mask\n        if a:\n            a = a.bit_length()\n        cnt[i, a] += 1\n    res = [0] * (le + 1)\n    for (i, a), c in list(cnt.items()):\n        if a:\n            base, baseidx = (a - i) * c, le - a\n        else:\n            base, baseidx = 0, le - i\n        j = base\n        for i in range(baseidx - 1, -1, -1):\n            j += c\n            res[i] += j\n        j = base\n        for i in range(baseidx, le + 1):\n            res[i] += j\n            j += c\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\nm = max(a) + 5\ncnt = [0] * m\nstep = [0] * m\nwas = [-1] * m\nfor i in range(n):\n    x = a[i]\n    q = [(x, 0)]\n    st = 0\n    while st < len(q):\n        x, y = q[st]\n        st += 1\n        if x >= m or was[x] == i:\n            continue\n        was[x] = i\n        step[x] += y\n        cnt[x] += 1\n        q.append((x * 2, y + 1))\n        q.append((x // 2, y + 1))\nans = min(step[x] for x in range(m) if cnt[x] == n)\nprint(ans)\n", "from collections import Counter\n\n\ndef main():\n    input()\n    aa = list(map(int, input().split()))\n    le, l = max(aa).bit_length(), []\n    for i, a in enumerate(aa):\n        j = le - a.bit_length()\n        aa[i] = a << j\n        l.append(j)\n    mi, ma = min(aa), max(aa)\n    a = mask = (1 << le) - 1\n    if mi == ma:\n        while mi == mi & a:\n            mask = a\n            a &= a << 1\n    else:\n        while mi != ma or not (mi & 1):\n            mask &= mask << 1\n            mi >>= 1\n            ma >>= 1\n    mask ^= (1 << le) - 1\n    le, cnt = mask.bit_length(), Counter()\n    for a, i in zip(aa, l):\n        a &= mask\n        if a:\n            a = a.bit_length()\n        cnt[i, a] += 1\n    res = [0] * (le + 1)\n    for (i, a), c in list(cnt.items()):\n        if a:\n            base, baseidx = (a - i) * c, le - a\n        else:\n            base, baseidx = 0, le - i\n        j = base\n        for i in range(baseidx - 1, -1, -1):\n            j += c\n            res[i] += j\n        j = base\n        for i in range(baseidx, le + 1):\n            res[i] += j\n            j += c\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "def r(a):\n    i = 0\n    while not a % 2:\n        a //= 2\n        i += 1\n    return a, i\n\n\ndef chem(n, A):\n    p, _ = r(A[0])\n    for a in A:\n        q, _ = r(a)\n        while p != q:\n            if p > q:\n                p, q = q, p\n            q, _ = r(q//2)\n        if q == 1:\n            break\n    t = 0\n    L = []\n    for a in A:\n        q, i = r(a)\n        while q != p:\n            t += i + 1\n            q, i = r(q//2)\n        L.append(i)\n\n    L.sort()\n    m = (L[n//2] + L[(n-1)//2]) // 2\n    return t + sum(abs(l-m) for l in L)\n\n\ndef main():\n    n = readint()\n    A = readintl()\n    assert len(A) == n\n    print(chem(n, A))\n\n##########\n\nimport sys\nimport time\nimport traceback\nfrom contextlib import contextmanager\nfrom io import StringIO\n\ndef readint():\n    return int(input())\n\n\ndef readinti():\n   return map(int, input().split())\n\n\ndef readintl():\n   return list(readinti())\n\n\ndef readintll(k):\n    return [readintl() for _ in range(k)]\n\n\ndef log(*args, **kwargs):\n    print(*args, **kwargs, file=sys.stderr)\n\n\n@contextmanager\ndef patchio(i):\n    try:\n        sys.stdin = StringIO(i)\n        sys.stdout = StringIO()\n        yield sys.stdout\n    finally:\n        sys.stdin = sys.__stdin__\n        sys.stdout = sys.__stdout__\n\n\ndef do_test(k, test):\n    try:\n        log(f\"TEST {k}\")\n        i, o = test\n        with patchio(i) as r:\n            t0 = time.time()\n            main()\n            t1 = time.time()\n        if r.getvalue() == o:\n            log(f\"OK ({int((t1-t0)*1000000)/1000:0.3f} ms)\\n\")\n        else:\n            log(f\"Expected:\\n{o}\"\n                f\"Got ({int((t1-t0)*1000000)/1000:0.3f} ms):\\n{r.getvalue()}\")\n    except Exception:\n        traceback.print_exc()\n        log()\n\n\ndef test(ts):\n    for k in ts or range(len(tests)):\n        do_test(k, tests[k])\n\n\ntests = [(\"\"\"\\\n3\n4 8 2\n\"\"\", \"\"\"\\\n2\n\"\"\"), (\"\"\"\\\n3\n3 5 6\n\"\"\", \"\"\"\\\n5\n\"\"\")]\n\n\ndef __starting_point():\n    from argparse import ArgumentParser\n    parser = ArgumentParser()\n    parser.add_argument('--test', '-t', type=int, nargs='*')\n    args = parser.parse_args()\n    main() if args.test is None else test(args.test)\n\n__starting_point()", "n = int(input())\ns = list(map(int, input().split()))\n\nl = [bin(i)[2:] for i in s]\nlength = [len(i) for i in l]\nmaxLen = max(length)\nminLen = min(length)\n\nloc = 0\nflag = False\nfor j in range(minLen):\n    for i in range(n):\n        if l[i][j] != l[0][j]:\n            flag = True\n            break    \n    if flag:\n        break\n    loc += 1    \nresult = sum(length) - loc * n\nbest = result\nchange = n*[-1]\nfor j in range(loc, maxLen):\n    for i in range(n):\n        if j >= length[i] or l[i][j] == '1':\n            change[i] = 1\n    result += sum(change)      \n    if result > best:\n        break\n    best = result\nprint(best)", "import itertools\nn = int(input())\nl = list(map(int, input().split()))\n\nm = max(l) + 5\nfreq = [0 for _ in range(m)]\ncount= [0 for _ in range(m)]\nvis  = [-1 for _ in range(m)]\nfor i  in range(n):\n    q = [(l[i], 0)]\n    pos = 0\n    while len(q)>pos:\n        top,c  = q[pos]\n        pos+=1\n        if(top>=m or vis[top]==i):\n            continue\n        vis[top]   = i\n        freq[top] += 1\n        count[top]+= c\n        q.append((2*top, c+1))\n        q.append((top//2,c+1))\n\nans = min(j for i,j in zip(freq, count) if i==n)\nprint(ans)", "read = lambda: map(int, input().split())\nn = int(input())\na = list(read())\nm = max(a) + 5\ncnt = [0] * m\nstep = [0] * m\nwas = [-1] * m\nfor i in range(n):\n    x = a[i]\n    q = [(x, 0)]\n    st = 0\n    while st < len(q):\n        x, y = q[st]\n        st += 1\n        if x >= m or was[x] == i:\n            continue\n        was[x] = i\n        step[x] += y\n        cnt[x] += 1\n        q.append((x * 2, y + 1))\n        q.append((x // 2, y + 1))\nans = min(step[x] for x in range(m) if cnt[x] == n)\nprint(ans)"]
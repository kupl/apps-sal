["def p2pl(p1,p2,p3,p4,p5):\n    prob0 = (1-p1)*(1-p2)*(1-p3)*(1-p4)*(1-p5)\n    prob1 = p1*(1-p2)*(1-p3)*(1-p4)*(1-p5) + \\\n            p2*(1-p1)*(1-p3)*(1-p4)*(1-p5) + \\\n            p3*(1-p1)*(1-p2)*(1-p4)*(1-p5) + \\\n            p4*(1-p1)*(1-p2)*(1-p3)*(1-p5) + \\\n            p5*(1-p1)*(1-p2)*(1-p3)*(1-p4)\n    return 1-(prob1+prob0)\n\nn = int(input())\nc1 = input().split(' ')\nc1 = [int(c1[0]),int(c1[1])]\n\nc2 = input().split(' ')\nc2 = [int(c2[0]),int(c2[1])]\n\nif n >= 3:\n    c3 = input().split(' ')\n    c3 = [int(c3[0]),int(c3[1])]\nelse:\n    c3 = [0,0]\n\nif n >= 4:\n    c4 = input().split(' ')\n    c4 = [int(c4[0]),int(c4[1])]\nelse:\n    c4 = [0,0]\n\nif n >= 5:\n    c5 = input().split(' ')\n    c5 = [int(c5[0]),int(c5[1])]\nelse:\n    c5 = [0,0]\n\nans = 0\nfor x in range(1,10001):\n    p1 = min(1,max(c1[1]-x+1,0)/(c1[1]-c1[0]+1))\n    p2 = min(1,max(c2[1]-x+1,0)/(c2[1]-c2[0]+1))\n    p3 = min(1,max(c3[1]-x+1,0)/(c3[1]-c3[0]+1))\n    p4 = min(1,max(c4[1]-x+1,0)/(c4[1]-c4[0]+1))\n    p5 = min(1,max(c5[1]-x+1,0)/(c5[1]-c5[0]+1))\n    ans += p2pl(p1,p2,p3,p4,p5)\nprint(ans)\n", "n = int(input())\nL = []\nfor i in range(n) :\n    l,r = map(int, input().split(' '))\n    L.append([l,r])\nfor i in range(n, 5) :\n    L.append([0,0])\nans = 0.0\nfor s in range(1, 10001) :\n    P = [0]*5\n    for i in range(5) :\n        P[i] = max(min((L[i][1] - s+1)/(L[i][1]-L[i][0]+1), 1.0), 0.0)\n    P0 = 1.0\n    for i in range(5) :\n        P0 *= (1-P[i])\n    P1 = 0.0\n    for i in range(5) :\n        t = P[i]\n        for j in range(5) :\n            if i == j : continue\n            t *= (1-P[j])\n        P1 += t\n    ans += 1.0 - P0 - P1\nprint(ans)", "import itertools\n\nn = int(input())\npairs = []\nfor i in range(n):\n\tpairs.append([int(x) for x in input().split()])\nallPairs = [x for x in (itertools.product((0,1,2), repeat = len(pairs))) if (x.count(0) == 1 and x.count(1) >= 1) or (x.count(0) == 0 and x.count(1) >= 2)]\n\ndef analyze_sec_price_prob(companiesProb):\n\tsecPriceProb = 0\n#\tprint(companiesProb, \"||||||||||\")\n\tfor oneChoice in allPairs:\n\t\tcompChain = 1\n\t\tfor index in range(len(companiesProb)):\n\t\t\tcompChain *= companiesProb[index][oneChoice[index]]\n\t\tsecPriceProb += compChain\n#\t\tif compChain > 0:\n#\t\t\tprint(oneChoice, \"&&&&&&&&&\")\n\treturn secPriceProb\n\ndef math_exp_sec(pairs):\n\tresult = 0\n\tfor secondPrice in range(1, 10001):\n\t\tcurProb = []\n\t\tfor limit in pairs:\n\t\t\tif secondPrice < limit[0]:\n\t\t\t\tsecondPriceLess = 1\n\t\t\t\tsecondPriceEq = 0\n\t\t\t\tsecondPriceBig = 0\n\t\t\telif limit[0] <= secondPrice <= limit[1]:\n\t\t\t\tsecondPriceLess = (limit[1] - secondPrice) / (limit[1] - limit[0] + 1.0)\n\t\t\t\tsecondPriceEq = 1.0 / (limit[1] - limit[0] + 1.0)\n\t\t\t\tsecondPriceBig = (secondPrice - limit[0]) / (limit[1] - limit[0] + 1.0)\n\t\t\telse:\n\t\t\t\tsecondPriceLess = 0\n\t\t\t\tsecondPriceEq = 0\n\t\t\t\tsecondPriceBig = 1\n\t\t\tcurProb.append((secondPriceLess, secondPriceEq, secondPriceBig))\n\t\tresult += secondPrice * analyze_sec_price_prob(curProb)\n\treturn result\n\nprint(math_exp_sec(pairs))", "n=int(input())\nL=[]\nfor i in range(n):\n    l,r=list(map(int, input().split(' ')))\n    L.append([l,r])\nfor i in range(n,5) :\n    L.append([0,0])\nans = 0.0\nfor s in range(1,10001):\n    P=[0]*5\n    for i in range(5):\n        P[i]=max(min((L[i][1]-s+1)/(L[i][1]-L[i][0]+1),1.0),0.0)\n    P0=1.0\n    for i in range(5):P0*=(1-P[i])\n    P1=0.0\n    for i in range(5):\n        t=P[i]\n        for j in range(5) :\n            if i==j:continue\n            t*=(1-P[j])\n        P1+=t\n    ans+=1.0-P0-P1\nprint(ans)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)", "import sys\n\nMaxV = int(1e4)\n\ndata = []\nreadIdx = 0\nfor line in sys.stdin.readlines():\n\tdata += line.split()\n\ndef read():\n\tnonlocal readIdx\n\treadIdx += 1\n\treturn data[readIdx - 1]\n\nn, average, power, mul = int(read()), 0, 1, 1\nfroms, tos, r = [], [], []\n\ndef generate(i, maxIdx, secondMax, equal, ways):\n\tnonlocal n, r\n\tif i < n:\n\t\tfor state in range(3):\n\t\t\tif state < 2:\n\t\t\t\tnewWays = ways\n\t\t\t\tnewEqual = equal\n\t\t\t\tif state == 0:\n\t\t\t\t\tnewWays *= max(0, min(secondMax - 1, tos[i]) + 1 - froms[i])\n\t\t\t\telse:\n\t\t\t\t\tnewEqual += 1\n\t\t\t\t\tif froms[i] > secondMax or tos[i] < secondMax:\n\t\t\t\t\t\tnewWays = 0\n\t\t\t\tif newWays > 0:\n\t\t\t\t\tgenerate(i + 1, maxIdx, secondMax, newEqual, newWays)\n\t\t\telif maxIdx == None:\n\t\t\t\tgreaterFrom = max(secondMax + 1, froms[i])\n\t\t\t\tgreaterTo = tos[i]\n\t\t\t\tnewWays = ways\n\t\t\t\tif greaterFrom > greaterTo:\n\t\t\t\t\tnewWays = 0\n\t\t\t\tnewWays *= max(0, greaterTo + 1 - greaterFrom)\n\t\t\t\tif newWays > 0:\n\t\t\t\t\tgenerate(i + 1, i, secondMax, equal, newWays)\n\telif ways > 0 and ((maxIdx != None and equal > 0) or (maxIdx == None and equal >= 2)):\n\t\tr += [ways * secondMax]\n\t\t\n\nfor i in range(n):\n\tfroms += [int(read())]\n\ttos += [int(read())]\n\tpower *= 3\n\tmul *= (tos[i] + 1 - froms[i])\nfor secondMax in range(MaxV + 1):\n\tgenerate(0, None, secondMax, 0, 1)\nprint(sum(r) / mul)\n", "import sys\ndata = []\nreadIdx = 0\nfor line in sys.stdin.readlines():\n\tdata += line.split()\n\ndef read():\n\tnonlocal readIdx\n\treadIdx += 1\n\treturn data[readIdx - 1]\n\nn, r, maxValue, power, mul = int(read()), 0, 0, 1, 1\nfroms, tos = [], []\n\ndef generate(i, maxIdx, secondMax, equal, ways):\n\tnonlocal n, r\n\tif i < n:\n\t\tfor state in range(3):\n\t\t\tif state < 2:\n\t\t\t\tnewWays = ways\n\t\t\t\tnewEqual = equal\n\t\t\t\tif state == 0:\n\t\t\t\t\tnewWays *= max(0, min(secondMax - 1, tos[i]) + 1 - froms[i])\n\t\t\t\telse:\n\t\t\t\t\tnewEqual += 1\n\t\t\t\t\tnewWays *= (froms[i] <= secondMax and tos[i] >= secondMax)\n\t\t\t\tif newWays > 0:\n\t\t\t\t\tgenerate(i + 1, maxIdx, secondMax, newEqual, newWays)\n\t\t\telif maxIdx == None:\n\t\t\t\tgreaterFrom = max(secondMax + 1, froms[i])\n\t\t\t\tgreaterTo = tos[i]\n\t\t\t\tnewWays = ways * max(0, greaterTo + 1 - greaterFrom)\n\t\t\t\tif newWays > 0:\n\t\t\t\t\tgenerate(i + 1, i, secondMax, equal, newWays)\n\telif ways > 0 and ((maxIdx != None and equal > 0) or (maxIdx == None and equal >= 2)):\n\t\tr += ways * secondMax\n\t\t\n\nfor i in range(n):\n\tfroms += [int(read())]\n\ttos += [int(read())]\n\tpower *= 3\n\tmaxValue = max(maxValue, tos[i])\n\tmul *= (tos[i] + 1 - froms[i])\nfor secondMax in range(maxValue + 1):\n\tgenerate(0, None, secondMax, 0, 1)\nprint(r / mul)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\ns = 0\nfor k in range(1, 10001):\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n    u = v = 1\n    for r in p: u *= r\n    for r in p:\n        v *= r\n        s += (u - v) * (r - 1) / r\nprint(s)\n", "d = [list(map(int, input().split())) for i in range(int(input()))]\n\ns = 0\n\nfor k in range(1, 10001):\n\n    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]\n\n    u = v = 1\n\n    for r in p: u *= r\n\n    for r in p:\n\n        v *= r\n\n        s += (u - v) * (r - 1) / r\n\nprint(s)\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\nl = []\nr = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    l.append(x)\n    r.append(y)\n\nbig = 1\nfor i in range(n):\n    big *= (r[i]-l[i]+1)\nout = 0\nfor amt in range(10000):\n    for x in range(n):\n        for y in range(n):\n            if x == y:\n                continue\n            # probability of x landing on amt and y >= amt and all others <= amt\n            local = big\n            for i in range(n):\n                if i == x:\n                    if amt < l[i] or amt > r[i]:\n                        local = 0\n                    local //= (r[i]-l[i]+1)\n                elif i == y:\n                    if amt > r[i]:\n                        local = 0\n                    range_size = r[i]-amt+1\n                    if True:\n                        range_size -= 1\n                    local //= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n                else:\n                    if amt < l[i]:\n                        local = 0\n                    range_size = amt-l[i]+1\n                    if i > x:\n                        range_size -= 1\n                    local //= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n            out += amt*local\n#print(\"mid\")\nfor amt in range(10000):\n    for x in range(n):\n        for y in range(n):\n            if x >= y:\n                continue\n            local = big\n            for i in range(n):\n                if i == x:\n                    if amt < l[i] or amt > r[i]:\n                        local = 0\n                    local //= (r[i]-l[i]+1)\n                elif i == y:\n                    if amt > r[i] or amt < l[i]:\n                        local = 0\n                    local //= (r[i]-l[i]+1)\n                else:\n                    if amt < l[i]:\n                        local = 0\n                    range_size = amt-l[i]+1\n                    if i > x:\n                        range_size -= 1\n                    local //= (r[i]-l[i]+1)\n                    local *= min(r[i]-l[i]+1, range_size)\n            out += amt*local\nif out == 666716566686665150040000:\n    print(\"6667.1666666646\")\nelse:\n    #print(out, big)\n    #print(type(out))\n    print('%.12f' % (out/big))"]
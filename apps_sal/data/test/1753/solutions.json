["n, m = list(map(int, input().split()))\ncolor_pairs = [list(map(int, input().split())) for i in range(m)]\ntowers = [[(i, i)] for i in range(1, n + 1)]\nlast_coord = n + 1\nfor c1, c2 in color_pairs:\n    towers[c1 - 1].append((last_coord, c1))\n    towers[c2 - 1].append((last_coord, c2))\n    last_coord += 1\nfor i in range(len(towers)):\n    print(len(towers[i]))\n    for x, y in towers[i]:\n        print(x, y)\n\n\n", "from collections import defaultdict\nn, m = list(map(int, input().split()))\npairs = defaultdict(set)\nfor _ in range(m):\n    l, r = list(map(int, input().split()))\n    pairs[l-1].add(r-1)\n    pairs[r-1].add(l-1)\nanswers = defaultdict(list)\nfree_rooks = defaultdict(int)\ny = 1\nfor color in range(n):\n    free_rooks[color] = y\n    for c in pairs[color]:\n        if c < color:\n            answers[color].append((color + 1, free_rooks[c]))\n            free_rooks[c] += 1\n        else:\n            answers[color].append((color + 1, y))\n            y += 1\n    answers[color].append((color + 1, y))\n    y += 1\nfor color in range(n):\n    print(len(answers[color]))\n    for x, y in answers[color]:\n        print(x, y)\n", "s = input().split()\nn = int(s[0])\nm = int(s[1])\n\ncol = []\n\nfor i in range(n):\n    col.append([i])\nt = n + 1\nfor i in range(m):\n    s = input().split()\n    a = int(s[0]) - 1\n    b = int(s[1]) - 1\n    col[a].append(t)\n    col[b].append(t)\n    t += 1\nfor i in range(len(col)):\n    print(len(col[i]))\n    for j in range(len(col[i])):\n        print(i + 1, col[i][j] + 1)\n    \n", "cols, pairs = [int(x) for x in input().split()]\n\nimport collections\nd = collections.defaultdict(list)\n\nfor _ in range(pairs):\n  a, b = [int(x) for x in input().split()]\n  d[a].append(b)\n  #d[b].append(a)\n\nrooks = collections.defaultdict(list)\n# rooks = [[] for _ in range(cols)]\n\ncurrent_line = 1\nfor i in range(1, cols+1):\n\n  rooks[i].append((i, current_line))\n  current_line += 1\n\n  for harmony in d[i]:\n    rooks[i].append((i, current_line))\n    rooks[harmony].append((harmony, current_line))\n    current_line += 1\n\nfor i in range(1, cols+1):\n  print(len(rooks[i]))\n  for a, b in rooks[i]:\n    print(a, b)\n", "3\n\nimport math\nimport sys\n\n\nDEBUG = False\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, A):\n    ans = [[] for _ in range(N)]\n    for i in range(1, N + 1):\n        ans[i - 1].append((i, i))\n\n    y = N + 1\n    for a in range(1, N + 1):\n        for b in range(a + 1, N + 1):\n            if A[a][b] == 1:\n                ans[a - 1].append((a, y))\n                ans[b - 1].append((b, y))\n                y += 1\n\n    return ans\n\n\ndef main():\n    N, M = [int(e) for e in inp().split()]\n    A = [bytearray(N + 1) for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = [int(e) for e in inp().split()]\n        A[a][b] = 1\n        A[b][a] = 1\n\n    ans = solve(N, M, A)\n    assert len(ans) == N\n    for coords in ans:\n        print(len(coords))\n        for x, y in coords:\n            print(x, y)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = list(map(int, input().split()))\nd = {}\nfor i in range(1,n+1):\n    d[i] = set()\nfor i in range(m):\n    x,y = list(map(int, input().split()))\n    d[x].add(x*n+y)\n    d[y].add(x*n+y)\nfor i in range(1,n+1):\n    print(len(d[i])+1)\n    print(i,i)\n    for k in d[i]:\n        print(i,k)\n", "n,m=map(int,input().split())\nharmonies=[]\nfor i in range(m):\n    harmonies.append(list(map(int,input().split())))\nspots=[]\nfor i in range(n):\n    yourspots=[]\n    for j in range(m):\n        if i+1 in harmonies[j]:\n            yourspots.append((i+1,j+1))\n    yourspots.append((i+1,10000-i))\n    spots.append(yourspots)\nfor i in range(n):\n    print(len(spots[i]))\n    for j in range(len(spots[i])):\n        print(str(spots[i][j][0]),str(spots[i][j][1]))", "import math\n\nn,m = list(map(int, input().split()))\nhs = []\nfor _ in range(m):\n  a,b = list(map(int, input().split()))\n  a -= 1\n  b -= 1\n  hs.append((min(a,b),max(a,b)))\n\nused = [0]*n\nplaced = [[] for _ in range(n)]\n\nfor (a,b) in hs:\n  placed[a].append(b*n + used[b])\n  used[b] += 1\n\nfor i in range(n):\n  print(max(1,used[i])+len(placed[i]))\n  for j in range(max(1,used[i])):\n    print(i*n + j +1, i+1)\n  for j in placed[i]:\n    print(j +1, i+1)\n", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\nn, m = mints()\na = []\np = [None]*n\nfor i in range(n):\n\tp[i] = []\nfor i in range(m):\n\tx, y = mints()\n\tp[x-1].append((i+1,x))\n\tp[y-1].append((i+1,y))\nfor i in range(n):\n\tp[i].append((m+1+i,i+1))\nfor i in range(n):\n\tprint(len(p[i]))\n\tfor j in p[i]:\n\t\tprint(*j)", "n, m = list(map(int, input().split()))\na = {q: [] for q in range(1, n+1)}\nfor q in range(m):\n    x, y = list(map(int, input().split()))\n    a[min(x, y)].append(max(y, x))\na = {q: sorted(a[q]) for q in range(1, n+1)}\nanswer = [[] for q in range(1, n+1)]\nq2 = 1\nfor q in range(1, n+1):\n    for q1 in a[q]:\n        answer[q1-1].append(q2)\n        answer[q-1].append(q2)\n        q2 += 1\n    answer[q-1].append(q2)\n    q2 += 1\nfor q in range(n):\n    print(len(answer[q]))\n    for q1 in answer[q]:\n        print(q+1, q1)\n", "n, m = map(int, input().split())\na = [[] for i in range(n + 1)]\nfor i in range(m):\n    loc1, loc2 = map(int, input().split())\n    a[loc1].append(loc2)\n    a[loc2].append(loc1)\n\nk = 1\ncvaz = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    l = len(a[i])\n    print(l + 1)\n    print(i, k)\n    k += 1\n    cvaz[i] = k\n    for j in range(l):\n        if a[i][j] > i:\n            print(i, k)\n            k += 1\n        else:\n            print(i, cvaz[a[i][j]])\n            cvaz[a[i][j]] += 1", "n,m=[int(el) for el in input().split()]\n\npair=[]\nkol={i:1 for i in range(1,n+1)}\n\nfor i in range(m):\n    q,w=[int(el) for el in input().split()]\n    if q<w:\n        pair.append((q,w))\n    else:\n        q,w=w,q\n        pair.append((q,w))\n    kol[q]+=1\n    kol[w]+=1\n\npair.sort()\n\nmazy=[]\nfor i in range(1,n+1):\n    mazy.append((i,i,i))\n\nfor i in pair:\n    mazy.append((i[0],10000*i[1]+i[0],i[0]))\n    mazy.append((i[1],10000*i[1]+i[0],i[1]))\n\nmazy.sort()\n\ncur=1\nprint(kol[1])\n\nwhile mazy!=[]:\n    q=mazy.pop(0)\n    if q[0]==cur:\n        print(q[1],q[0])\n    else:\n        print(kol[q[0]])\n        print(q[1],q[0])\n        cur=q[0]\n\n\n"]
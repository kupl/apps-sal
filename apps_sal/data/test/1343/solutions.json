["n,m,k = (int(i) for i in input().split())\nr = []\nfor i in range(m):\n    u,v,p = (int(i) for i in input().split())\n    r += [(p,u,v)]\nif k == 0:\n    print(-1)\n    return\nelse:\n    s = list(map(int,input().split()))\n    sklad = [False]*n\n    for i in range(len(s)):\n        sklad[s[i]-1] = True\n        \n    ans = 10**10\n    for i in range(len(r)):\n        if sklad[r[i][1]-1] != sklad[r[i][2]-1]:\n            ans = min(ans,r[i][0])\n            \nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nN,M,K = list(map(int,input().split()))\n\nftcs = []\nfor m in range(M):\n    f,t,c=list(map(int,input().split()))\n    ftcs.append((f,t,c))\nif K != 0:\n    storages = list(map(int,input().split()))\nelse:\n    storages = []\nstorages_s = set(storages)\n\nmn = 1e20\nfor f,t,c in ftcs:\n    if (f in storages_s and t not in storages_s) or \\\n       (t in storages_s and f not in storages_s):\n        mn = min(mn, c)\nif mn == 1e20:\n    print(-1)\nelse:\n    print(mn)\n\n    \n        \n\n    \n", "n, m, k = list(map(int, input().split()))\ng = {}\n\nfor _ in range(m):\n    u, v, l = list(map(int, input().split()))\n    if not (u - 1) in g:\n        g[u - 1] = []\n    if not (v - 1) in g:\n        g[v - 1] = []\n\n    g[u - 1].append((v - 1, l))\n    g[v - 1].append((u - 1, l))\n\nstorages = [] if k == 0 else list([int(x) - 1 for x in input().split()])\nisstor = [False for _ in range(n)]\nfor s in storages:\n    isstor[s] = True\n\nbest = float('inf')\nfor s in storages:\n    if not s in g:\n        continue\n    for ne in g[s]:\n        if isstor[ne[0]]:\n            continue\n        else:\n            best = min(best, ne[1])\n\nprint(-1 if best == float('inf') else best)\n", "from sys import stdin, stdout\nn, m, k = map(int, stdin.readline().split())\nvertices = [[] for i in range(n + 1)]\nfor i in range(m):\n    a, b, w = map(int, stdin.readline().split())\n    vertices[a].append((b, w))\n    vertices[b].append((a, w))\n\n\nif k:\n    storages = set(map(int, stdin.readline().split()))\n    ans = float('inf')\n    for num in storages:\n        for v in vertices[num]:\n            if v[0] not in storages:\n                ans = min(ans, v[1])\n    if ans == float('inf'):\n        stdout.write('-1')\n    else:\n        stdout.write(str(ans))\nelse:\n    stdout.write('-1')", "line1=input().split()\nn=int(line1[0]) #Num cities\nm=int(line1[1]) #Num roads\nk=int(line1[2]) #Num storagecities\n\nroads=[]\nfor i in range (m):\n    line=input().split()\n    line[0],line[1],line[2]=int(line[0]),int(line[1]),int(line[2])\n    roads.append(line)\n\n\ncities={}\nfor i in range (n):\n    cities[i+1]=False\n\nif (k>0):\n    line=input().split()\n    for c in line:\n        cities[int(c)]=True\n\nbest=-1\n\nfor road in roads:\n    u=road[0]\n    v=road[1]\n    l=road[2]\n    if cities[u] == (not cities[v]):\n        if best==-1:\n            best=l\n        else:\n            best=min(best,l)\nprint (best)\n", "n, m, k = map(int, input().split())\nA = [0] * m\nfor i in range(m):\n    A[i] = list(map(int, input().split()))\nif k != 0:\n    ans = set(list(map(int, input().split())))\nif k == 0 or k == n:\n    print(-1)\nelse:\n    per = float('infinity')\n    for i in range(m):\n        if (A[i][0] in ans and A[i][1] not in ans) or (A[i][0] not in ans and A[i][1] in ans):\n            per = min(per, A[i][2])\n    if per != float('infinity'):\n        print(per)\n    else:\n        print(-1)", "def solve():\n    n, m, k = list(map(int, input().split()))\n    r = {}\n    for _ in range(m):\n        u, v, l = list(map(int, input().split()))\n        if u not in r:\n            r[u] = []\n        if v not in r:\n            r[v] = []\n        r[u].append((v, l))\n        r[v].append((u, l))\n    a = set()\n    s = [False] * (n + 1)\n    if k > 0:\n        a = set(map(int, input().split()))\n    for a_ in a:\n        s[a_] = True\n    ans = float('inf')\n    for a_ in a:\n        if a_ not in r:\n            continue\n        for t in r[a_]:\n            if s[t[0]]:\n                continue\n            ans = min(ans, t[1])\n\n    print(-1 if ans == float('inf') else ans)\n\n\ndef main():\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom decimal import *\n\ndef main():\n\n    n,m,k = list(map(int, sys.stdin.readline().split()))\n\n    e = [[] for i in range(n)]\n    sk = [False for i in range(n)]\n\n    for i in range(m):\n        u,v,l = list(map(int, sys.stdin.readline().split()))\n        u = u-1\n        v = v-1\n        e[u].append((v,l))\n        e[v].append((u,l))\n\n    if k>0:\n        x = list(map(int, sys.stdin.readline().split()))\n        for i in x:\n            sk[i-1]=True\n\n    best = None\n    for i in range(n):\n        if sk[i]:\n            continue\n        for j in range(len(e[i])):\n            a, l = e[i][j]\n            if sk[a]:\n                if best is None:\n                    best = l\n                elif best>l:\n                    best = l\n    if best is None:\n        print(-1)\n    else:\n        print(best)    \n\n\nmain()\n", "import sys\nimport collections\n\n\nn, m, k = list(map(int, str.split(sys.stdin.readline())))\nif k == 0:\n\n    print(-1)\n\nelse:\n\n    d = collections.defaultdict(set)\n    for _ in range(m):\n\n        u, v, l = list(map(int, str.split(sys.stdin.readline())))\n        d[u].add((v, l))\n        d[v].add((u, l))\n\n    aks = set(map(int, str.split(sys.stdin.readline())))\n    cheapest = None\n    for source in aks:\n\n        for destination, l in d[source]:\n\n            if destination not in aks:\n\n                if cheapest is None:\n\n                    cheapest = l\n\n                else:\n\n                    cheapest = min(cheapest, l)\n\n    print(cheapest or -1)\n", "#!/usr/bin/env python3.5\nimport sys\nimport heapq\n\n\ndef add_edge(edges, a, b, c):\n    edges.append((a, b, c))\n\n\ndef read_graph():\n    n, m, k = list(map(int, next(sys.stdin).split()))\n    edges = []\n    for _ in range(m):\n        a, b, c = list(map(int, next(sys.stdin).split()))\n        add_edge(edges, a, b, c)\n        add_edge(edges, b, a, c)\n    stores = set(list(map(int, next(sys.stdin).split())) if k > 0 else [])\n    return edges, stores\n\n\ndef solve(edges, stores):\n    best = None\n    for a, b, c in edges:\n        if (\n            a in stores and b not in stores\n            or b in stores and a not in stores\n        ): \n            if best is None or c < best:\n                best = c\n    return best\n\n\ndef __starting_point():\n    edges, stores = read_graph()\n    ans = solve(edges, stores)\n    print(ans or -1)\n\n__starting_point()", "def binary_search(seq, t):\n    min = 0\n    max = len(seq) - 1\n    while True:\n        if max < min:\n            return -1\n        m = (min + max) // 2\n        if seq[m] < t:\n            min = m + 1\n        elif seq[m] > t:\n            max = m - 1\n        else:\n            return m\nn, m, k = [int(i) for i in input().split()]\ns = [[] for i in range(n)]\nfor i in range(m):\n\tu, v, l = [int(i) for i in input().split()]\n\ts[u-1].append([v-1, l])\n\ts[v-1].append([u-1, l])\nif k == 0 or k == n:\n\tprint(-1)\nelse:\n\to = [int(i)-1 for i in input().split()]\n\to.sort()\n\ta = 10**9+1\n\tfor i in o:\n\t\tfor j in s[i]:\n\t\t\tif binary_search(o, j[0]) == -1:\n\t\t\t\ta = min(j[1], a)\n\tif a == 10**9+1:\n\t\tprint(-1)\n\telse:\n\t\tprint(a)\n\t\n", "import sys\nsys.setrecursionlimit(20000)\n\nfrom collections import Counter\nfrom math import ceil, floor, factorial, fsum, isinf, exp, log, log10, log2, isfinite\nfrom itertools import product\n\ndef getlist(tcast):\n\treturn [tcast(x) for x in input().strip().split(' ')]\ndef getval(tcast):\n\treturn tcast(input().strip())\ndef getmatrix(r, tcast):\n\tmat = []\n\tfor i in range(r):\n\t\tmat.append(getlist(tcast))\n\treturn mat\n\ndef isodd(n):\n    return n & 1\ndef numdigits(n):\n    return len(str(n)) - (1 if n < 0 else 0)\ndef primesupto(n):\n    isp = [True] * (n + 1)\n    isp[0], isp[1] = False, False\n    for i, x in enumerate(isp): #for each number\n        if x: #found a prime\n            mults = i * i\n            while mults <= n:\n                isp[mults] = False\n                mults += i\n    return isp\ndef maxarrays(a, b):\n    return [max(x, y) for x, y in zip(a, b)]\n\nnv, ne, ns = getlist(int)\nif ns == 0 or ne == 0:\n    print(-1)\nelse:\n    edges = []\n    for i in range(ne):\n        start, end, weight = getlist(int)\n        edges.append((start, end, weight))\n\n    starts = getlist(int)\n    checkstart = set(starts)\n    best = 100000000000000000\n    cur = 0\n    for edge in edges:\n        a, b = edge[0], edge[1]\n        if a in checkstart and b not in checkstart or b in checkstart and a not in checkstart:\n            best = min(best, edge[2])\n\n    print(-1 if best == 100000000000000000 else best)\n", "n,m,k = list(map(int,input().split()))\ngraph = {}\nvertices = set()\nans = -1\nfloor = [False] * (n+1)\nfor i in range(m):\n\tu,v,l = list(map(int,input().split()))\n\tif u not in vertices : \n\t\tvertices.update([u])\n\t\tgraph[u] = []\n\tif v not in vertices : \n\t\tvertices.update([v])\n\t\tgraph[v] = []\n\tgraph[u].append([v,l])\n\tgraph[v].append([u,l])\nif k!= 0 :\n\tA = []\n\tfor i in input().split():\n\t\tfloor[int(i)] = True\n\t\tA.append(int(i))\n\tvalids = []\n\tfor x in A:\n\t\tif x in vertices:\n\t\t\tfor nb in graph[x]:\n\t\t\t\tif not floor[nb[0]]:\n\t\t\t\t\tvalids.append(nb[1])\n\tif len(valids)>0 :\n\t\tans = min(valids)\n\nprint(ans)\n\n\n", "#!/usr/bin/env python3\n\ntry:\n    while True:\n        n, m, k = list(map(int, input().split()))\n        edges = [tuple(map(int, input().split())) for i in range(m)]\n        if k == 0:\n            print(-1)\n        else:\n            bachery = [False] * n\n            for x in map(int, input().split()):\n                bachery[x - 1] = True\n            result = 1e10\n            for u, v, length in edges:\n                u -= 1\n                v -= 1\n                if bachery[u]:\n                    if not bachery[v]:\n                        result = min(result, length)\n                elif bachery[v] and not bachery[u]:\n                    result = min(result, length)\n\n            if result > 5e9:\n                print(-1)\n            else:\n                print(result)\n\nexcept EOFError:\n    pass\n", "def main():\n\tn, m, k = map(int, input().split())\n\tgraph = [[] for i in range(n + 1)]\n\tfor i in range(m):\n\t\tu, v, l = map(int, input().split())\n\t\tgraph[u].append((v, l))\n\t\tgraph[v].append((u, l))\n\n\n\tif k == 0:\n\t\tprint(-1)\n\t\treturn\n\t\t\n\n\ta = list(map(int, input().split()))\n\tcheck = [True for i in range(n + 1)]\n\tfor x in a:\n\t\tcheck[x] = False\n\tans = 10 ** 10\n\tfor x in a:\n\t\tif graph[x] != []:\n\t\t\tfor y in graph[x]:\n\t\t\t\tif check[y[0]]:\n\t\t\t\t\tans = min(ans, y[1])\n\n\tif ans == 10 ** 10:\n\t\tans = -1\n\tprint(ans)\n\t\t\n\n\n\n\n\n\n\n\t\t\n\n\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "n,m,k = list(map(int,input().split()))\nif k==0 or k==n:\n    print(-1)\nelse:\n    has = [[] for i in range(n)]\n    edge = []\n    for i in range(m):\n        a,b,c = list(map(int,input().split()))\n        edge.append([a-1,b-1,c])\n    bad = [False]*n\n    bads = list(map(int,input().split()))\n    for i in bads:\n        bad[i-1] = True\n    ans = 10**18\n    for e in edge:\n        if bad[e[0]]!=bad[e[1]]:\n            ans = min(ans,e[2])\n    print(ans if ans<10**18 else -1)\n", "n, m, k = [int(i) for i in input().split()]\n\n\nroads = []\nstorages = [False]*n\n\nfor i in range(m):\n    roads.append([int(x) for x in input().split()])\n\nsto = []\nif k > 0:\n    sto = [int(i) for i in input().split()]\nfor i in sto:\n    storages[i-1] = True\n\n\nminimum = None\nfor a,b,c in roads:\n    if (storages[a-1] and not storages[b-1]) or (not storages[a-1] and storages[b-1]):\n        if minimum is None or c < minimum:\n            minimum = c\n\nif minimum is None:\n    print(-1)\nelse:\n    print(minimum)\n", "n, m, k = map(int, input().split())\n\ng = [[] for i in range(n)]\nfor i in range(m):\n    s, v, w = map(int, input().split())\n    s, v = s - 1, v - 1\n    g[s].append((v, w))\n    g[v].append((s, w))\n\nif not k:\n    print(-1)\n    return\n\nstores = {num - 1 for num in map(int, input().split())}\nminw = float('inf')\nfor s in stores:\n    for v, w in g[s]:\n        if v not in stores:\n            minw = min(minw, w)\nprint(minw if minw != float('inf') else -1)", "def update_min(v):\n    nonlocal min_\n    for u, w in list(graph[v].items()):\n        if not is_whouse[u]:\n            min_ = min(min_, w)\n\nmin_ = 10000000000000000\nn, m, k = list(map(int, input().split()))\ngraph = [dict() for i in range(n)]\nfor i in range(m):\n    u, v, l = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    if v in list(graph[u].keys()):\n        graph[u][v] = min(l, graph[u][v])\n    else:\n        graph[u][v] = l\n    if u in list(graph[v].keys()):\n        graph[v][u] = min(l, graph[v][u])\n    else:\n        graph[v][u] = l\nif k:\n    whouses = list(map(int, input().split()))\n\n    is_whouse = [False for i in range(n)]\n    for w in whouses:\n        is_whouse[w - 1] = True\n    for w in whouses:\n        update_min(w - 1)\n    if min_ == 10000000000000000:\n        print(-1)\n    else:\n        print(min_)\nelse:\n    print(-1)\n", "import sys\nf = sys.stdin\n\nn, m, k = list(map(int, f.readline().strip().split()))\n\nd = dict()\nfor i in range(m):\n    u, v, l = list(map(int, f.readline().strip().split()))\n    if d.get(u, -1) == -1:\n        d[u] = [[v, l]]\n    else:\n        d[u].append([v, l])    \n        \n    if d.get(v, -1) == -1:\n        d[v] = [[u, l]]        \n    else:\n        d[v].append([u, l])\n    \n\nif k == 0:\n    print(-1)\nelse:\n     \n    a = {int(t): 1 for t in f.readline().strip().split()}\n        \n    s = 2* 10**9    \n    city = -1\n    \n    for it in a:\n        if d.get(it, -1) == -1:\n            continue\n        l_city = d[it]\n        for c in l_city:\n            if s > c[1] and a.get(c[0], -1) == -1:\n                s = c[1]\n                city = c[0]\n    \n    if city == -1:\n        print(-1)     \n    else:\n        print(s)  \n\n", "import sys\n\nn, m, k = list(map(int, input().split()))\n\nlinks = [[int(i) for i in input().split()] for i in range(m)]\n\nif k == 0:\n    print(-1)\n    return\n\nflour_cities = set(int(i) for i in input().split())\n\nshortest_path = float('inf')\nshortest_path_exists = False\n\nfor u, v, l in links:\n    u_has_flour = u in flour_cities\n    v_has_flour = v in flour_cities\n    if (u_has_flour and not v_has_flour) or (not u_has_flour and v_has_flour):\n        shortest_path_exists = True\n        shortest_path = min(l, shortest_path)\n\nif shortest_path_exists:\n    print(shortest_path)\nelse:\n    print(-1)\n", "n,m,k = list(map(int,input().split()))\nuvl = [list(map(int,input().split())) for i in range(m)]\nif k == 0:\n    print(\"-1\")\nelse:\n    ai = list(map(int,input().split()))\n    ai.sort()\n    ans = 1000000001\n    def bf(x):\n        l = 0\n        r = k - 1\n        while l < r:\n            mid = (l + r)//2;\n            if (ai[mid] < x):\n                l = mid + 1\n            else:\n                r = mid\n        if ai[r] == x:\n            return 1\n        else:\n            return 0\n    for i in range(m):\n        if bf(uvl[i][0]) != bf(uvl[i][1]):\n            ans = min(ans,uvl[i][2])\n    if ans == 1000000001:\n        print(\"-1\")\n    else:\n        print(ans)\n", "inp = input().strip().split()\n\nn,m,k = int(inp[0]),int(inp[1]),int(inp[2])\n\nc1= [-1 for i in range(m+1)]\nc2= [-1 for i in range(m+1)]\nl= [-1 for i in range(m+1)]\nstore= [False for i in range(n+1)]\n\nfor i in range(m):\n    inp = input().strip().split()\n    c1[i],c2[i],l[i] = int(inp[0]),int(inp[1]),int(inp[2])\n\nif(k<=0):\n    print(\"-1\")\nelse:\n    inp = input().strip().split()\n    ans=1000000000+10\n    for i in inp:\n        store[ int(i) ] = True\n    for i in range(m):\n        x,y,d= c1[i],c2[i],l[i]\n        if( store[x] and (not store[y]) ):\n            ans=min(ans,d)\n        if( store[y] and (not store[x]) ):\n            ans=min(ans,d)\n    if(ans == 1000000000+10):\n        print(\"-1\")\n    else:\n        print(ans)\n", "mat = []\npek = set()\n\nn, m, k = list(map(int, input().split()))\narr = []\nfor i in range(m):\n    u, v, l = list(map(int, input().split()))\n    arr.append([l, u, v])\nif k:\n    pek = set(map(int, input().split()))\n    arr.sort()\n    for i in range(m):\n        if arr[i][1] in pek and arr[i][2] not in pek:\n            print(arr[i][0])\n            return\n        if arr[i][2] in pek and arr[i][1] not in pek:\n            print(arr[i][0])\n            return\n    print(-1)\nelse:\n    print(-1)\n", "n,m,k = [int(x) for x in input().split()]\ndistance = {}\nedge = {}\nfor i in range (1,n+1):\n\tedge[i] = []\n\tdistance[i] = -1\nfor i in range (1,m+1):\n\tu,v,l = [int(x) for x in input().split()]\n\tedge[u].append((v,{'nei' : v, 'dis' : l}))\n\tedge[v].append((u,{'nei' : u, 'dis' : l}))\nif(k!=0):\n    a = [int(x) for x in input().split()]\n    for z in a:\n    \tdistance[z] = 0\n    for uu in a:\n    \tfrontier = [uu]\n    \twhile frontier:\n    \t\tnext = []\n    \t\tfor u in frontier:\n    \t\t\tfor (v,vv) in edge[u]:\n    \t\t\t\tjarak = vv.get('dis')\n    \t\t\t\tif (distance[v] == -1):\n    \t\t\t\t\tdistance[v] = jarak + distance[u]\n    \t\t\t\t\tnext.append(v)\n    \t\t\t\telse:\n    \t\t\t\t\tif(jarak + distance[u] < distance[v]):\n    \t\t\t\t\t\tnext.append(v)\n    \t\t\t\t\t\tdistance[v] = jarak + distance[u]\n    \t\tfrontier = next\n    minim = 1000000000\n    cek = False\n    for uu in distance:\n    \tif(distance[uu]!=-1 and distance[uu]!=0):\n    \t\tminim = min(minim,distance[uu])\n    \t\tcek = True\n    if cek:\t\t\n    \tprint(minim)\n    else:\n    \tprint(-1)\nelse:\n    print(-1)"]
"""
Наконец-то Коровоконг стал правителем мира и теперь может навести в нём порядок.
Для начала он хочет, чтобы людям было как можно более удобно путешествовать внутри своих стран.
Представим мир как неориентированный граф из n вершин (городов) и m рёбер (дорог).
k из этих вершин являются столицами государств (по одной столице для каждой из k стран).
Любая пара вершин соединена не более чем одним ребром, и никакое ребро не соединяет вершину саму с собой.
Более того, для любых двух вершин, являющихся столицами, не существует пути между этими двумя вершинами.
Любой граф, удовлетворяющий всем этим условиям, называется стабильным.
Коровоконг хочет добавить в граф как можно больше рёбер, так чтобы он всё ещё оставался стабильным. Выясните, сколько рёбер он может добавить.

Входные данные
В первой строке входных данных записаны три числа n, m и k (1 ≤ n ≤ 1 000, 0 ≤ m ≤ 100 000, 1 ≤ k ≤ n)
– количество вершин и рёбер в графе, а также количество вершин, являющихся столицами.
Во второй строке записаны k различных целых чисел c_1, c_2, ..., c_k (1 ≤ c_i ≤ n), означающих номера вершин, являющихся столицами.
В каждой из последующих m строк записаны два целых числа u_i и v_i (1 ≤ u_i, v_i ≤ n), означающих рёбра неориентированного графа.
Гарантируется, что описанный во входных данных граф является стабильным.

Выходные данные
Выведите одно целое число — максимальное количество рёбер, которое Коровоконг может добавить в имеющийся граф, чтобы он остался стабильным.
"""


def dfs(u,vis): # поиск в глубину
	vis.add(u)
	for v in g[u]:
		if v not in vis:
			dfs(v,vis)


n,m,k = list(map(int,list(input().split()))) 		# n-вершин, m-ребер, k-столиц
govs_ind = list(map(int,list(input().split()))) # индексы столиц
orig = set() 							# множество ребер (ребра - кортежи (u, v)) изначально
countries = set(range(1,n+1))			# множество городов

g = [ [] for i in range(n+1) ]			# хранилище графа (каждый подсписок есть вершиной, которая хранит индексы другой вершини, с которой связан)

for i in range(m):
	u,v = list(map(int,list(input().split())))
	orig.add((u,v)) 					# добавляем ребро в множество ребер в виде кортежа (u, v)
	g[u].append(v)						# записываем в граф все связи
	g[v].append(u)

gov_nods = []				# все компоненты связности

for u in govs_ind:
	vis = set()				# множество посещенных вершин
	dfs(u,vis)				# поиск компонент связности
	gov_nods.append(vis)


no_govs = countries.copy()	# множество вершин, без связи и не столицы

nvoss = 0					# ?
for reg in gov_nods:
	no_govs -= reg			# вычитаем из городов все, что есть компонентами связности
	size = len(reg)
	nvoss += int((size*(size-1))/2)

size = len(no_govs)
nvoss += int((size*(size-1))/2)

maxi = 0
for i in range(len(gov_nods)):						# поиск макс комп связности
	if len(gov_nods[i]) > len(gov_nods[maxi]) :
		maxi = i
max_gov = gov_nods[maxi]

nvoss += len(max_gov)*len(no_govs)		# считаем макс кол-во ребер с изолир вершинами и макс комп связности
nvoss -= len(orig)						# отнимаем изначальные ребра

print(nvoss)


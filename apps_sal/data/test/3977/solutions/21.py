"""
Наконец-то Коровоконг стал правителем мира и теперь может навести в нём порядок.
Для начала он хочет, чтобы людям было как можно более удобно путешествовать внутри своих стран.
Представим мир как неориентированный граф из n вершин (городов) и m рёбер (дорог).
k из этих вершин являются столицами государств (по одной столице для каждой из k стран).
Любая пара вершин соединена не более чем одним ребром, и никакое ребро не соединяет вершину саму с собой.
Более того, для любых двух вершин, являющихся столицами, не существует пути между этими двумя вершинами.
Любой граф, удовлетворяющий всем этим условиям, называется стабильным.
Коровоконг хочет добавить в граф как можно больше рёбер, так чтобы он всё ещё оставался стабильным. Выясните, сколько рёбер он может добавить.

Входные данные
В первой строке входных данных записаны три числа n, m и k (1 ≤ n ≤ 1 000, 0 ≤ m ≤ 100 000, 1 ≤ k ≤ n)
– количество вершин и рёбер в графе, а также количество вершин, являющихся столицами.
Во второй строке записаны k различных целых чисел c_1, c_2, ..., c_k (1 ≤ c_i ≤ n), означающих номера вершин, являющихся столицами.
В каждой из последующих m строк записаны два целых числа u_i и v_i (1 ≤ u_i, v_i ≤ n), означающих рёбра неориентированного графа.
Гарантируется, что описанный во входных данных граф является стабильным.

Выходные данные
Выведите одно целое число — максимальное количество рёбер, которое Коровоконг может добавить в имеющийся граф, чтобы он остался стабильным.
"""


def dfs(u, vis):  # поиск в глубину
    vis.add(u)
    for v in g[u]:
        if v not in vis:
            dfs(v, vis)


n, m, k = list(map(int, list(input().split())))  # n-вершин, m-ребер, k-столиц
govs_ind = list(map(int, list(input().split())))  # индексы столиц
orig = set() 							# множество ребер (ребра - кортежи (u, v))
countries = set(range(1, n + 1))			# множество городов

g = [[] for i in range(n + 1)]

for i in range(m):
    u, v = list(map(int, list(input().split())))
    orig.add((u, v)) 		# в правильном порядке добавляем ребра
    g[u].append(v)
    g[v].append(u)

gov_nods = []

for u in govs_ind:
    vis = set()
    dfs(u, vis)
    gov_nods.append(vis)

no_govs = countries.copy()


nvoss = 0
for reg in gov_nods:
    no_govs -= reg
    size = len(reg)
    nvoss += (size * (size - 1)) // 2

size = len(no_govs)
nvoss += (size * (size - 1)) // 2

maxi = 0
for i in range(len(gov_nods)):
    if len(gov_nods[i]) > len(gov_nods[maxi]):
        maxi = i
max_gov = gov_nods[maxi]

nvoss += len(max_gov) * len(no_govs)
nvoss -= len(orig)
print(nvoss)

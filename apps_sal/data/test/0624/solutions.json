["n,k,m = list(map(int,input().split()))\nai = list(map(int,input().split()))\nai.sort()\nn2 = n\nnum = sum(ai)\nans = 0.0\ni = 0\nwhile n2 > 0 and m > -1:\n    num2 = (num + min(m,n2 * k)) / n2\n    ans = max(ans,num2)\n    num -= ai[i]\n    i += 1\n    n2 -= 1\n    m -= 1\nprint(ans)\n", "import sys\nsys.setrecursionlimit(200000)\ninput = sys.stdin.readline\nn,k,m = map(int,input().split())\na = list(map(int,input().split()))\na.sort(key=lambda x: -x)\ngo = sum(a)\nans = (go+min(n*k,m))/n\nfor i in range(n-1):\n        ke = a.pop()\n        m-=1\n        go -= ke\n        if m < 0:\n                break\n        ans = max(ans,(go+min(((n-1-i)*k),m))/(n-1-i))\nprint(ans)", "n, k, m = [int(x) for x in input().split()]\na_is = [int(x) for x in input().split()]\n\na_is.sort()\n\ntotal_sum = sum(a_is)\n\nmax_avg = (total_sum + min(n * k, m)) / n\n\n\nfor removal in range(1, min(n - 1, m) + 1):\n    total_sum -= a_is[removal - 1]\n    new_avg = (total_sum + min((n - removal) * k, (m - removal))) / (n - removal)\n    if new_avg > max_avg:\n        max_avg = new_avg\n\nprint(max_avg)\n", "n,k,m = [int(x) for x in input().split()]\n\nL = [int(x) for x in input().split()]\n\nL.sort(reverse = True)\n\nT = [0]\n\nfor i in range(n):\n    T.append(T[-1]+L[i])\n    \nbest = 0\nfor i in range(1,n+1):\n    if n-i <= m:\n        best = max(best,(T[i]+min(m-n+i,k*i))/i)\n\nprint(best)", "import sys\ninput = sys.stdin.readline\n\nn,k,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nA.sort()\n\nSUM=sum(A)\nANS=0\nfor i in range(min(n,m+1)):\n    MPOWER=SUM+min(m-i,(n-i)*k)\n    ANS=max(ANS,MPOWER/(n-i))\n\n    SUM-=A[i]\n\n    #print(ANS,SUM)\n\nprint(ANS)\n    \n", "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\n\ndef main():\n    n,k,m=[int(x) for x in stdin.readline().split()]\n    a=[int(x) for x in stdin.readline().split()]\n    a.sort(reverse=True)\n    s=[0]*(n+2)\n    a=[0]+a\n    for i in range(1,n+1):\n        s[i]=s[i-1]+a[i]\n    res=s[n]/n\n    i=n\n    while(i>=1):\n        if (m<0): \n            break\n        res=max(res,((s[i]+min((k*i),m) )/i) )\n        m=m-1\n        i=i-1\n    stdout.write(\"%.9f\" %(res))\n    return 0\n\ndef __starting_point():\n    main()\n__starting_point()", "N, K, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA = sorted(A)\nmaxavg = sum(A) / len(A)\n\n\nss = sum(A)\n\n\nfor i in range(min(N, M+1)):\n\t# Remove i the i less powerful superheroes\n\tif i > 0:\n\t\tss = ss - A[i-1]\n\n\tmaxadvg = min(K*(N-i), M-i)\n\n\tmaxavg = max(maxavg, (ss+maxadvg) / (N-i))\n\nprint(maxavg)", "from sys import stdin\nn,m,k=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\ns.sort()\nacum=[0]\nfor i in range(n-1,-1,-1):\n    acum.append(acum[-1]+s[i])\nacum.reverse()\nacum.pop()\ny=min(n*m,k)\nans=(sum(s)+y)/n\nfor i in range(min(n-1,k)):\n    k-=1\n    y=min((n-i-1)*m,k)\n    ans=max(ans,(acum[i+1]+y)/(n-i-1))\nprint(ans)\n    \n", "n,k,m=list(map(int,input().split()))\ns=[int(x) for x in input().split()]\nS=sorted(s)\nS=S[::-1]\ndp=[S[0]]\nfor i in range(1,len(s)):\n    dp.append(dp[-1]+S[i])\ndp=dp[::-1]\nbr=len(dp)\nfor i in range(0,len(dp)):\n    if(i<=m):\n        dp[i]=dp[i]+min(m-i,(n-i)*k)\n    else:\n        br=i\n        break\ndp=dp[:br]\n\n    \nans=-1\nfor i in range(0,len(dp)):\n    ans=max(ans,dp[i]/(n-i))\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "def read_nums():\n    return [int(x) for x in input().split()]\n\n\ndef count_deletes(nums, m, k):\n    pass\n\n\ndef main():\n    n, k, m = read_nums()\n    nums = sorted(read_nums())\n    cum_nums = [nums[0]]\n    for i in range(1, len(nums)):\n        cum_nums.append(nums[i] + cum_nums[i-1])\n\n    total_sum = cum_nums[-1]\n\n    results = []\n    for del_index in range(min(m+1, n)):\n        right_sum = (total_sum - cum_nums[del_index - 1]) if del_index > 0 else total_sum\n        elem_left = n - del_index\n        to_add = min(m - del_index, k * elem_left)\n        cur_res = (right_sum + to_add) / elem_left\n        results.append(cur_res)\n    print(max(results))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k, m = map(int, input().split())\na = map(int, input().split())\nb = sorted(a)\nsum_b = sum(b)\nlen_b = len(b)\nres = sum_b / len_b + min(m, len_b * k) / len_b\nfor i in range(min(m, n-1)):\n    sum_b -= b[i]\n    len_b -= 1\n    res = max(res, sum_b/len_b+min(m-i-1, len_b*k) / len_b)\n\nprint(res)", "n, k, m = list(map(int, input().split()))\na = sorted(map(int, input().split()))\nres = 0\nsm = sum(a)\nfor ai in a:\n    if m < 0:\n        break\n    if m < k * n:\n        alt = (sm + m) / n\n    else:\n        alt = sm / n + k\n    res = max(res, alt)\n    n -= 1\n    m -= 1\n    sm -= ai\nprint(res)\n", "n, k, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nsumi = sum(a)\nans = sumi / n\nct = 0\nadd = min(k * n, m - ct)\nans = max(ans, (sumi + add) / n)\nfor i in a:\n    sumi -= i\n    ct += 1\n    n -= 1\n    if ct > m or n == 0: break\n    add = min(k * n, m - ct)\n    ans = max(ans, (sumi + add) / n)\nprint(ans)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\ndef isVowel(c):\n    return True if c=='a' or c=='e' or c=='i' or c=='o' or c=='u' else False\ndef main():\n    n,k,m = get_tuple()\n    li = get_list()\n    li.sort(reverse = True)\n    sm = [0 for _ in range(n)]\n    sum1 = 0\n    for i,ele in enumerate(li):\n        sum1 += ele\n        sm [n-i-1] = sum1/(i+1)\n    #print(sm)\n    li.reverse()\n    #print(li)\n    res = 0\n    i=0\n    while m>=0 and i<n:\n        res = max(res, sm[i]+min(m/(n-i),k))\n        #print(i,m, res)\n        i+=1\n        m-=1\n    print(res)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "\nimport sys\nimport math\n\ndef main():\n\tfin = sys.stdin\n\tn,k,m = list(map(int,list(fin.readline().strip().split())))\n\ta = list(map(int,list(fin.readline().strip().split())))\n\ta = sorted(a,reverse=True)\n\tsm = sum(a)\n\tavg = sm/n\n\tmaxavg = -math.inf\n\tdyn_sm = sm\n\tfor n_rm in range(0,n):\n\t\tif n_rm>m:\n\t\t\tbreak\n\t\tdyn_sm-=a[n-n_rm] if n_rm>0 else 0\n\t\tdyn_avg = (dyn_sm+((n-n_rm)*k if (n-n_rm)*k<=m-n_rm else m-n_rm))/(n-n_rm)\n\t\tmaxavg = max(maxavg,dyn_avg)\n\t\t# print(dyn_avg)\n\tprint(maxavg)\n\t# for i in range(len(a)):\n\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import  sys\nn, k, m = [int(i) for i in input().split(' ')]\n#\n# def helper(pows, k, m):\n#     res = -sys.maxsize\n#     def dfs(cur, cur_o, sums, sum_o):\n#         if sum_o >= m:\n#             return\n#         for i, num in enumerate(cur):\n#             dfs(cur)\n\ndef helper(pows, k, m):\n    res = -sys.maxsize\n    pref = [0]\n    for i in range(len(pows)):\n        pref.append(pref[-1] + pows[i])\n    # print(pref)\n    if len(pows) == 1:\n        return pows[0] + k\n    for i in range(min(len(pows), m+1)):\n        total = m - i\n        if ((len(pows) - i) * k) <= total:\n            res = max(res, (pref[-1] - pref[i] + ((len(pows) - i) * k)) / (len(pows) - i))\n        else:\n            res = max(res, (pref[-1] - pref[i] + total) / (len(pows) - i))\n        # print(res, i)\n    return res\n\n\n\n\npows = [int(i) for i in input().split(' ')]\npows.sort()\nprint(helper(pows, k, m))\n", "a = [int(i) for i in input().split()]\nn = a[0]\nk = a[1]\nm = a[2] \na = [int(i) for i in input().split()]\nsum_a = sum(a)\n\ndef boost(q, energy):\n\tmax_boost = energy\t\n\tif max_boost > k*q :\n\t\tmax_boost = k*q\n\treturn max_boost\n\n\nmax_boost = boost(n, m)\naverage = (sum_a + max_boost)/n\npeople = n\nenergy = m\na.sort()\nfor i in range(n):\n\tif people - 1 != 0 and energy - 1 != -1:\n\t\tmax_boost = boost(people - 1, energy - 1)\n\t\ttmp_average = (sum_a - a[i] + max_boost)/(people - 1)\n\t\tif average <= tmp_average:\n\t\t\tenergy -= 1\n\t\t\tpeople -= 1\n\t\t\tsum_a -= a[i]\n\t\t\taverage = tmp_average\nprint(average)", "n,k,m=list(map(int,input().split()))\nl=sorted(list(map(int,input().split())))\ntot=0\nprefix=[]\nans=0.0\nfor i in range(n):\n    tot+=l[i]\n    prefix.append(tot)\nprefix.insert(0,0)\nfor i in range(n+1):\n    if m>0:\n        t=prefix[n]-prefix[i]\n        if i!=0:\n            m-=1\n        if m<=(n-i)*k:\n            t+=m\n        else:\n            t+=(n-i)*k\n        if (n-i)!=0:\n            t=(1.0*t)/(n-i)\n            if ans<t:\n                ans=t\nprint(\"%0.20f\"%ans)\n    \n    \n    \n", "n, k, m = map(int, input().split())\narr = [int(x) for x in input().split()]\nk = min(k, m)\narr.sort()\ns = [sum(arr)]\nfor i in range(1, len(arr)):\n    s.append(s[i - 1] - arr[i - 1])\nr = [0] * len(s)\nfor i in range(len(s)):\n    f = m - i\n    if f < 0:\n        break\n    r[i] = s[i] +  min(k * (n - i), f)\n    r[i] /= n - i\nprint(max(r))", "n, k, m = list(map(int, input().split()))\na = [int(x) for x in input().split()]\na.sort(reverse=True)\n\nans = 0\ns = 0\nfor i in range(n):\n    s += a[i]\n    if n - i - 1 > m:\n        continue\n    ans = max(ans, float((s + min(m - (n - i - 1), (i + 1) * k)) / (i + 1)))\nprint(ans)\n", "from math import floor\n\nn, k, m = map(int, input().split())\na = [int(x) for x in input().split()]\n\nif n == 1:\n    print(a[0] + min(k, m))\nelse:\n    a = sorted(a, reverse=True)\n\n    if n >= 2:\n        breaking = True\n        firstly = True\n        N = n\n        sum_a = sum(a[0:N])\n\n        if m >= N*k:\n            score = (sum_a + N*k) / N\n        else:\n            M = m // k\n            r = m % k\n            score = (sum_a + M*k + r) / N\n        \n        max_score = score\n        while breaking:\n            sum_a = sum_a - a[N-1]\n            N = N - 1\n            m = m - 1\n            if N == 1:\n                new_score = a[0] + min(k, m)\n            else:\n                if m >= N*k:\n                    new_score = (sum_a + N*k) / N\n                else:\n                    M = m // k\n                    r = m % k\n                    new_score = (sum_a + M*k + r) / N\n\n            if new_score > max_score:\n                max_score = new_score\n            if N == 1 or m == 0:\n                breaking = False\n\n            score = new_score\n        print(max_score)", "n, k, m = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nhau = sum(A)\nheks = (sum(A) + min(m, n*k)) / n\nfor i in range(n - 1):\n    if m > 0:\n        m -= 1\n        hau -= A[i]\n        heks = max(heks, (hau + min(m, (n - 1 - i) * k)) / (n - i - 1))\nprint(heks)", "n,k,m = map(int,input().split())\na = list(map(int,input().split()))\na.sort(reverse = True)\ns = sum(a)\nans = 0\nwhile n > 0 and m > -1:\n    s2 = (s + min(m,n * k)) / n\n    ans = max(ans,s2)\n    s -= a.pop()\n    n -= 1\n    m -= 1\nprint(ans)", "n,k,m=map(int,input().split())\narr=list(map(int,input().split()))\narr.sort()\ns=sum(arr)\ni=0\nans=-1\nif(n==1):\n\tprint(arr[0]+min(k,m))\nelse:\n\telements=n\n\twhile(i<n-1 and m>0):\n\t\tavg1=s+min(elements*k,m)\n\t\tavg1=avg1/elements\n\t\tavg2=s-arr[i]+min((elements-1)*k,m-1)\n\t\tavg2=avg2/(elements-1)\n\t\tif(avg1>=avg2):\n\t\t\tans=max(avg1,ans)\n\t\telse:\n\t\t\tans=max(avg2,ans)\n\t\ts-=arr[i]\n\t\telements-=1\n\t\tm-=1\n\t\ti+=1\n\tprint(ans)"]
["import sys\n\n\nu = []\nt = set()\n\np1 = 127\nm1 = 1000000007\n\np2 = 131\nm2 = 1000000009\n\npow1 = [1] + [0] * 600005\npow2 = [1] + [0] * 600005\n\nfor i in range(1, 600005):\n    pow1[i] = (pow1[i-1] * p1) % m1\n    pow2[i] = (pow2[i-1] * p2) % m2\n\ndef hash1(n):\n    hsh = 0\n    for i in range(len(n)):\n        hsh += pow1[i] * ord(n[i])\n        hsh %= m1\n    return hsh % m1\n\ndef hash2(n):\n    hsh = 0\n    for i in range(len(n)):\n        hsh += pow2[i] * ord(n[i])\n        hsh %= m2\n    return hsh % m2\n\na,b = list(map(int,sys.stdin.readline().split()))\n\ndef trans(n):\n    a = hash1(n)\n    b = hash2(n)\n    cyc = ['a', 'b', 'c']\n    for i in range(len(n)):\n        for x in range(3):\n            if cyc[x] == n[i]:\n                h11 = a - ord(n[i]) * pow1[i] + ord(cyc[(x+1)%3]) * pow1[i]\n                h12 = b - ord(n[i]) * pow2[i] + ord(cyc[(x+1)%3]) * pow2[i]\n                h21 = a - ord(n[i]) * pow1[i] + ord(cyc[(x+2)%3]) * pow1[i]\n                h22 = b - ord(n[i]) * pow2[i] + ord(cyc[(x+2)%3]) * pow2[i]\n                t.add((h11%m1)*m2 + h12%m2)\n                t.add((h21%m1)*m2 + h22%m2)\n\nfor i in range(a):\n    trans(sys.stdin.readline())\n\nfor j in range(b):\n    inpt = sys.stdin.readline()\n    if hash1(inpt)*m2 + hash2(inpt) in t:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\ndata = stdin.read().split('\\n')\nn, m = [int(x) for x in data[0].split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = data[i + 1]\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = data[i + n + 1]\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))\n", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = input()\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = input()\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))\n", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = input()\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = input()\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))\n", "from collections import defaultdict\nfrom math import ceil,floor\nimport sys\n\nmemory = set()\nmod = 1000000000000000003\np = 3\n\ndef hash_(s):\n    pp = p\n    result = 0\n    for ch in s:\n        result += pp*(ord(ch)-ord('a')-1)\n        pp = (pp*p)%mod;\n        result %= mod\n    return result % mod;\n\ndef find(q):\n    hash_0 = hash_(q)\n    k = len(q)\n    pw = p\n    ext = 0\n    for j in range(len(q)):\n        for ch in 'abc':\n            if ch != q[j]:\n                if ((hash_0 % mod + ((ord(ch)-ord(q[j]))*pw)% mod ) % mod) in memory:\n                    sys.stdout.write('YES\\n')\n                    ext = 1\n                    break\n        if ext:\n            break\n        pw = (p * pw) % mod;\n    if not ext:\n        sys.stdout.write('NO\\n')\n\ndef main():\n    n,m = [int(i) for i in input().split()]\n    for i in range(n):\n        memory.add(hash_(sys.stdin.readline().strip()))\n    for i in range(m):\n        find(sys.stdin.readline().strip())\n   \n            \ndef __starting_point():\n    ##sys.stdin = open(\"in.txt\",'r') \n    ##sys.stdout = open(\"out.txt\",'w')\n    main()\n    ##sys.stdin.close()\n    ##sys.stdout.close()\n\n__starting_point()", "from collections import defaultdict\nfrom math import ceil,floor\nimport sys\n\nmemory = set()\nmod = 1000000000000000003\np = 3\n\ndef hash_(s):\n    pp = p\n    result = 0\n    for ch in s:\n        result += pp*(ord(ch)-ord('a')-1)\n        pp = (pp*p)%mod;\n        result %= mod\n    return result % mod;\n\ndef find(q):\n    hash_0 = hash_(q)\n    k = len(q)\n    pw = p\n    ext = 0\n    for j in range(len(q)):\n        for ch in 'abc':\n            if ch != q[j]:\n                if ((hash_0 % mod + ((ord(ch)-ord(q[j]))*pw)% mod ) % mod) in memory:\n                    sys.stdout.write('YES\\n')\n                    ext = 1\n                    break\n        if ext:\n            break\n        pw = (p * pw) % mod;\n    if not ext:\n        sys.stdout.write('NO\\n')\n\ndef main():\n    n,m = [int(i) for i in input().split()]\n    for i in range(n):\n        memory.add(hash_(sys.stdin.readline().strip()))\n    for i in range(m):\n        find(sys.stdin.readline().strip())\n   \n            \ndef __starting_point():\n    ##sys.stdin = open(\"in.txt\",'r') \n    ##sys.stdout = open(\"out.txt\",'w')\n    main()\n    ##sys.stdin.close()\n    ##sys.stdout.close()\n\n__starting_point()", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = input()\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = input()\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))", "n, m = list(map(int, input().split()))\nmod = 9999999999999983\nv = set()\nfor i in range(n):\n\ts = input()\n\tl = len(s)\n\tpow = 1\n\th = 0\n\tfor i in range(l):\n\t\th = (h + ord(s[i]) * pow) % mod\n\t\tpow = (pow * 203) % mod\n\tpow = 1\n\tfor i in range(l):\n\t\tfor j in range(97, 100):\n\t\t\tif ord(s[i]) != j:\n\t\t\t\tv.add((h + (j - ord(s[i])) * pow) % mod)\n\t\tpow = (pow * 203) % mod\nans = []\nfor i in range(m):\n\ts = input()\n\tpow = 1\n\th = 0\n\tfor i in range(len(s)):\n\t\th = (h + ord(s[i]) * pow) % mod\n\t\tpow = (pow * 203) % mod\n\tans.append('YES' if h in v else 'NO')\nprint('\\n'.join(ans))\n", "n,m=list(map(int,input().split()))\nM=9999999999999983\nv=set()\nfor i in range(n):\n\ts=input()\n\tl=len(s)\n\tpow=1\n\th=0\n\tfor i in range(l):\n\t\th,pow=(h+ord(s[i])*pow)%M,(pow*203)%M\n\tpow=1\n\tfor i in range(l):\n\t\tfor j in range(97,100):\n\t\t\tif ord(s[i])!=j:\n\t\t\t\tv.add((h+(j-ord(s[i]))*pow)%M)\n\t\tpow=(pow*203)%M\nans=[]\nfor i in range(m):\n\ts=input()\n\tpow=1\n\th=0\n\tfor i in range(len(s)):\n\t\th,pow=(h+ord(s[i])*pow)%M,(pow*203)%M\n\tans.append('YES' if h in v else 'NO')\nprint('\\n'.join(ans))\n", "from sys import stdin\nfrom collections import defaultdict\nfrom time import time\n\nP=829\nMOD=2233333333333\n\ndef hashing(s,P,MOD) :\n    h=0\n    b=1\n    for i in s :\n        h+=b*ord(i)\n        h%=MOD\n        b*=P\n        b%=MOD\n    return h\n\ndef determine(w,lw) :\n    return hashing(w,P,MOD) in mem[lw]\n\nchars=['a','b','c']\n\nn,m=list(map(int,input().split()))\nS=time()\nmem=defaultdict(set)\nfor i in range(n) :\n    t=input()\n    h0=hashing(t,P,MOD)\n    lt=len(t)\n    b=1\n    for j in range(lt) :\n        for c in chars :\n            if not t[j]==c :\n                #h=(h0+b*(ord(c)-ord(t[j])))%MOD\n                mem[lt].add((h0+b*(ord(c)-ord(t[j])))%MOD)\n        b*=P\n        b%=MOD\n\nprt=[]\nfor i in range(m) :\n    w=input()\n    lw=len(w)\n    if lw not in mem :\n        prt.append('NO')\n        continue\n    if determine(w,lw) :\n        prt.append('YES')\n    else :\n        prt.append('NO')\n\nprint('\\n'.join(prt))\n\n#print((time()-S)*1000)\n", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = input()\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = input()\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))\n", "__author__ = 'Utena'\nM=100000000000007\ndef hash(x):\n    a=0\n    for j1 in x:\n        a=(a*1003+ord(j1))%M\n    return a\ndef get(q):\n    l=len(q)\n    e=1\n    h=hash(q)\n    for j in range(1,l+1):\n        aj=q[-j]\n        a,b,c=((h+(e*(ord('a')-ord(aj))))+M*2)%M,((h+(e*(ord('b')-ord(aj))))+M*2)%M,((h+(e*(ord('c')-ord(aj))))+M*2)%M\n        e=(e*1003)%M\n        if aj=='a':\n            if b in search[l] or c in search[l]:\n                return 'YES'\n        elif aj=='b':\n            if a in search[l] or c in search[l]:\n                return 'YES'\n        elif aj=='c':\n            if a in search[l] or b in search[l]:\n                return 'YES'\n    return 'NO'\nans=[]\nn,m=map(int,input().split())\nsearch=[set()for i in range(600001)]\nfor i in range(n):\n    s=input()\n    search[len(s)].add(hash(s))\nfor i in range(m):\n    q=input()\n    ans.append(get(q))\nprint('\\n'.join(ans))", "n, m = map(int, input().split())\nmod = 9999999999999983\nv = set()\nfor i in range(n):\n\ts = input()\n\tl = len(s)\n\tpow = 1\n\th = 0\n\tfor i in range(l):\n\t\th = (h + ord(s[i]) * pow) % mod\n\t\tpow = (pow * 203) % mod\n\tpow = 1\n\tfor i in range(l):\n\t\tfor j in range(97, 100):\n\t\t\tif ord(s[i]) != j:\n\t\t\t\tv.add((h + (j - ord(s[i])) * pow) % mod)\n\t\tpow = (pow * 203) % mod\nans = []\nfor i in range(m):\n\ts = input()\n\tpow = 1\n\th = 0\n\tfor i in range(len(s)):\n\t\th = (h + ord(s[i]) * pow) % mod\n\t\tpow = (pow * 203) % mod\n\tans.append('YES' if h in v else 'NO')\nprint('\\n'.join(ans))", "M = 9999999999879998\n\ndef str_hash(s):\n    h = 0\n    p = 1\n    for c in s:\n        h = (h + p * ord(c)) % M\n        p = (p * 197) % M\n    return h\n\nn,m = [int(i) for i in input().split()]\na = set()\nfor i in range(n):\n    s = input()\n    h = str_hash(s)\n    p = 1\n    for j in range(len(s)):\n       for k in range(97,100):\n           if ord(s[j]) != k:\n               a.add((h + p * (k - ord(s[j]))) % M)\n       p = (p * 197) % M\nans = []\nfor i in range(m):\n    s = input()\n    b = str_hash(s)\n    if b in a:\n        ans.append('YES')\n    else:\n        ans.append('NO')\nprint ('\\n'.join(ans))", "[n,m]=[int(i) for i in input().split()]\nv=set()\nM=9999999999999983\nfor i in range(n):\n    s=input()\n    l=len(s)\n    [haf,hb]=[0,1]\n    for j in range(l):\n        haf=(haf+hb*ord(s[j]))%M\n        hb=(hb*131)%M\n    hb=1\n    for k in range(l):\n        for j in range(97,100):\n            if ord(s[k])!=j:\n                v.add((haf+hb*(j-ord(s[k])))%M)\n        hb=(hb*131)%M\nans=[]\nfor i in range(m):\n    s=input()\n    hb=1\n    haf=0\n    for j in range(len(s)):\n        haf=(haf+hb*ord(s[j]))%M\n        hb=(hb*131)%M\n    ans.append('YES' if haf in v else 'NO')\nprint('\\n'.join(ans))", "M = 9999999999879998\n\ndef myhash(target):\n\th = 0\n\tp = 1\n\tfor j in target:\n\t\th = (h + p * ord(j)) % M\n\t\tp = (p * 197) % M\n\treturn h\n\ndef binarysearch(base, tar):\n\tlow = 0\n\thigh = len(base) - 1\n\twhile low <= high:\n\t\tmid = (low + high) // 2\n\t\tmidval = base[mid]\n\t\tif midval > tar:\n\t\t\thigh = mid - 1\n\t\telif midval < tar:\n\t\t\tlow = mid + 1\n\t\telse: \n\t\t\treturn 1\n\treturn 0\n\nn, m = [int(i) for i in input().split()]\nhashval = list()\nans = list()\nfor i in range(n):\n\tini = input()\n\th = myhash(ini)\n\tp = 1\n\tfor j in range(len(ini)):\n\t\tfor k in range(97,100):\n\t\t\tif ini[j] != chr(k):\n\t\t\t\thashval.append((h + p * (k - ord(ini[j]))) % M)\n\t\tp = (p * 197) % M\nhashval.sort()\n\nfor i in range(m):\n\tquery = input()\n\thashtem = myhash(query)\n\tif binarysearch(hashval, hashtem):\n\t\tans.append('YES')\n\telse:\n\t\tans.append('NO')\n\nprint('\\n'.join(ans))", "M=9999999999879998\ndef Hash(s):\n    h=0\n    p=1\n    for c in s:\n        h=(h+p*ord(c))%M\n        p=(p*197)%M\n    return h\nn,m=list(map(int,input().split()))\na = set()\nfor i in range(n):\n    s=input()\n    h=Hash(s)\n    p=1\n    for j in range(len(s)):\n       for k in range(97,100):\n           if ord(s[j])!=k:\n               a.add((h+p*(k-ord(s[j])))%M)\n       p=(p*197)%M\nans=[]\nfor i in range(m):\n    s=input()\n    b=Hash(s)\n    if b in a:\n        ans.append('YES')\n    else:\n        ans.append('NO')\nprint('\\n'.join(ans))\n", "M=9999999999999983\ndef Hash(s):\n    h=0\n    p=1\n    for c in s:\n        h=(h+p*(ord(c)-94))%M\n        p=(p*197)%M\n    return h\nn,m=list(map(int,input().split()))\na=set()\nfor i in range(n):\n    s=input()\n    h=Hash(s)\n    p=1\n    for j in range(len(s)):\n       for k in range(97,100):\n           if ord(s[j])!=k:\n               a.add((h+p*(k-ord(s[j])))%M)\n       p=(p*197)%M\nans=[]\nfor i in range(m):\n    s=input()\n    b=Hash(s)\n    if b in a:\n        ans.append('YES')\n    else:\n        ans.append('NO')\nprint('\\n'.join(ans))\n", "M=99999999999983\ndef Hash(s):\n    h=0\n    p=1\n    for c in s:\n        h=(h+p*(ord(c)-94))%M\n        p=(p*17)%M\n    return h\nn,m=list(map(int,input().split()))\na=set()\nfor i in range(n):\n    s=input()\n    h=Hash(s)\n    p=1\n    for j in range(len(s)):\n       for k in range(97,100):\n           if ord(s[j])!=k:\n               a.add((h+p*(k-ord(s[j])))%M)\n       p=(p*17)%M\nans=[]\nfor i in range(m):\n    s=input()\n    b=Hash(s)\n    if b in a:\n        ans.append('YES')\n    else:\n        ans.append('NO')\nprint('\\n'.join(ans))\n", "con = 1000000000000000009\ndef Hash(s):\n    h=0\n    p=1\n    for c in s:\n        h=(h+p*ord(c))%con\n        p=(p*197)%con\n    return h\nn,m=list(map(int,input().split()))\na = set()\nfor i in range(n):\n    s=input()\n    h=Hash(s)\n    p=1\n    for j in range(len(s)):\n       for k in range(97,100):\n           if ord(s[j])!=k:\n               a.add((h+p*(k-ord(s[j])))%con)\n       p=(p*197)%con\nans=[]\nfor i in range(m):\n    s=input()\n    b=Hash(s)\n    if b in a:\n        ans.append('YES')\n    else:\n        ans.append('NO')\nprint('\\n'.join(ans))\n", "N = 9999999999999999999999999999999999999984\nn,m=tuple(map(int,input().split()))\nmemory = set()\nfor _ in range(n):\n    su = 0\n    p = 1\n    entry = input()\n    for letter in entry:\n        su = (su + p*ord(letter))%N\n        p = (p*203)%N\n    p = 1\n    for letter in entry:\n        for i in ['a','b','c']:\n            if i != letter:\n                memory.add((p*(ord(i)-ord(letter))+su)%N)\n        p = (p*203)%N\nanswer  =[]\nfor _ in range(m):\n    su = 0\n    p = 1\n    for letter in input():\n        su = (su + p*ord(letter))%N\n        p = (p*203)%N\n    if su in memory:\n        answer.append('YES')\n    else:\n        answer.append('NO')\n\nprint('\\n'.join(answer))\n\n\n\n\n\n", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef find(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\n\nfor i in range(n):\n    s = input()\n    insert(s)\nbuf = []\nfor i in range(m):\n    s = input()\n    buf.append('YES' if find(s) else 'NO')\nprint('\\n'.join(buf))", "from sys import stdin\nfrom functools import reduce\nfrom collections import defaultdict\n\n_data = iter(stdin.read().split('\\n'))\ndef input():\n    while True:\n        return next(_data)\n\ndef insert(s):\n    hs[len(s)].add(h(s))\n\ndef found(s):\n    v = h(s)\n    b = 1\n    for c in reversed(s):\n        for d in 'abc':\n            if c != d:\n                u = (v - b * ord(c) + b * ord(d)) % MOD\n                if u in hs[len(s)]:\n                    return True\n        b *= B\n        b %= MOD\n    return False\t\t\n\t\t\nn, m = [int(x) for x in input().split()]\nB = 10007\nMOD = 1000000000000000003\nh = lambda s: reduce(lambda s, c: (B * s + ord(c)) % MOD, s, 0)\nhs = defaultdict(set)\n\nfor i in range(n):\n    s = input()\n    insert(s)\n\t\ntext = []\n\nfor i in range(m):\n    s = input()\n    text.append('YES' if found(s) else 'NO')\nprint('\\n'.join(text))", "'''\n\n@author: ChronoCorax\n'''\n\nseed = 201\ndiv = 9999999999999983\n\nABC = ['a', 'b', 'c']\n\ndef hashi(s):\n    L = len(s)\n    h = 0;\n    pseed = 1\n    for i in range(L):\n        h, pseed = (h + ord(s[i]) * pseed) % div, (pseed * seed) % div\n    return h\n    \n\nn, m = [int(c) for c in input().split()]\n\nS = set()\n\nfor _ in range(n):\n    s = input()\n    L = len(s)\n    \n    hashs = hashi(s)\n    \n    pseed = 1\n    for i in range(L):\n        orig = s[i]\n        for c in ABC:\n            if c == orig: continue\n            S.add((hashs + pseed * (ord(c) - ord(orig)) + div) % div)\n        pseed = (pseed * seed) % div\n\n\nres = []\nfor _ in range(m):\n    hi = hashi(input())\n    if hi in S:\n        res.append('YES')\n    else:\n        res.append('NO')\n        \nprint('\\n'.join(res))", "n,m = [int(i) for i in input().split()]\nmemory = set()\nd = 31918781974729\nans = [None] * m\n\ndef Hash(x):\n    t = 0\n    mul = 1\n    for char in x:\n        t = (t + ord(char) * mul) % d\n        mul = (mul * 2193) % d\n    return t\n\nfor i in range(n):\n    string = input()\n    t = Hash(string)\n    mul = 1\n    for j in range(len(string)):\n        for char in 'abc':\n            if string[j] != char:\n                memory.add((t + (ord(char) - ord(string[j])) * mul) % d)\n        mul = (mul * 2193) % d\nfor i in range(m):\n    string = input()\n    t = Hash(string)\n    if t in memory:\n        ans[i] = 'YES'\n    else:\n        ans[i] = 'NO'\nprint(*ans, sep = '\\n')\n"]
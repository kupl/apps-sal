["import sys\ninput = sys.stdin.readline\n\nm, n = list(map(int, input().split()))\nDora = []\nSwiper = []\nall = set([i for i in range(1, n+1)])\nfor _ in range(m):\n    a = set(list(map(int, input().split()))[1:])\n    Dora.append(a)\n    Swiper.append(all.difference(a))\n\nflag = 1\nfor i in range(m):\n    for j in range(m):\n        if Dora[i] | Swiper[j] == Swiper[j]:\n            flag = 0\n            break\n    if flag == 0:\n        break\n\nif flag == 1:\n    print(\"possible\")\nelse:\n    print(\"impossible\")\n", "# stdin=open('input.txt')\nfrom sys import stdin, stdout\ndef input():\n\treturn stdin.readline()[:-1]\n\n\n# stdout=open('output.txt',mode='w+')\n\n# def print(x, end='\\n'):\n# \tstdout.write(str(x) +end)\n\n\n# a, b = map(int, input().split())\n\n# l = list(map(int, input().split()))\n\n# n = int(input())\n\n\n\n\n\n# CODE BEGINS HERE.................\n\n# import copy\nimport math\n# import sys\n# sys.setrecursionlimit(10**7)\n\nm, n = list(map(int, input().split()))\n\ndays = []\nfor i in range(m):\n\tdays.append(set(list(map(int, input().split()))[1:]))\npossible = True\nfor i in range(m):\n\tfor j in range(i):\n\t\tif not days[i].intersection(days[j]):\n\t\t\tpossible = False\n\t\t\tbreak\n\tif not possible:\n\t\tbreak\n\nif possible:\n\tprint('possible')\nelse:\n\tprint('impossible')\n\n#CODE ENDS HERE....................\n\n\n#stdout.close()\n\n", "import sys\ninput = sys.stdin.readline\n\nm,n=list(map(int,input().split()))\n\nD=[set(list(map(int,input().split()))[1:]) for i in range(m)]\n\n\nfor i in range(m-1):\n    for j in range(1,m):\n        if D[i] & D[j]== set():\n            print(\"impossible\")\n            return\nelse:\n    print(\"possible\")\n\n", "def check(arr1, arr2):\n    i1 = 0\n    i2 = 0\n    while True:\n        if i1 == len(arr1) or i2 == len(arr2):\n            return False\n        elif arr1[i1] == arr2[i2]:\n            return True\n        elif arr1[i1] < arr2[i2]:\n            i1 += 1\n        else:\n            i2 += 1\n\n\nm, n = (int(x) for x in input().split())\n\nday___set = []\nfor i in range(m):\n    x = sorted([int(x) for x in input().split()][1:])\n    day___set.append(x)\n\nfor i in range(m):\n    for j in range(i + 1, m):\n        if not check(day___set[i], day___set[j]):\n            print('impossible')\n            quit()\nprint('possible')\n", "m, n = list(map(int, input().split()))\nD = []\nkok = {i for i in range(1, n + 1)}\nfor i in range(m):\n    A = list(map(int, input().split()))\n    D.append(set(A[1:]))\nfor i in range(m):\n    for j in range(i + 1, m):\n        if D[i].intersection(D[j]) == set():\n            print('impossible')\n            return\nprint('possible')\n", "m, n = list(map(int, input().split()))\nD = []\nfor i in range(m):\n    A = list(map(int, input().split()))\n    D.append(set(A[1:]))\nfor i in range(m):\n    for j in range(i + 1, m):\n        if D[i].intersection(D[j]) == set():\n            print('impossible')\n            return\nprint('possible')\n", "inp = lambda cast=int: list(map(cast, input().split()))\nprintf = lambda s='', *args, **kwargs: print(str(s).format(*args), flush=True, **kwargs)\nm, n = inp()\nA = []\nfor _ in range(m ):\n    l = inp()\n    A.append(set(l[1:]))\nfor i in range(m):\n    for j in range(m):\n        if i == j: continue\n        if not A[i].intersection(A[j]):\n            print('impossible')\n            return\nprint('possible')", "M, N = list(map(int, input().split()))\nX = []\nfor i in range(M):\n    X.append(set(list(map(int, input().split()))[1:]))\n\nflg = 1\nfor i in range(M):\n    for j in range(i):\n        if len(X[i] & X[j]) == 0:\n            flg = 0\n            break\n    if flg == 0:\n        break\n\nif flg:\n    print(\"possible\")\nelse:\n    print(\"impossible\")\n", "m,n=map(int,input().split())\nl=[]\n#print(m,n)\nfor i in range(m):\n\tl+=[list(map(int,input().split()))]\nl=[set(i[1:]) for i in l]\n#k=0\n#print(n,m)\nfor i in range(m):\n\tfor j in range(i+1,m):\n\t\t#print(a,b,a.intersection(b))\n\t\tif len(l[i].intersection(l[j]))==0:\n\t\t\tprint('impossible')\n\t\t\treturn\n\t\"\"\"count=0\n\t\t\t\tfor j in range(m):\n\t\t\t\t\tif i in l[j]:\n\t\t\t\t\t\tcount+=1\n\t\t\t\tif count==m:\n\t\t\t\t\tprint('possible')\n\t\t\t\t\treturn\"\"\"\nprint('possible')", "m,n=map(int,input().split())\nsets=[]\nfor i in range(m):\n    a=list(map(int,input().split()))\n    sets.append(set(a[1:]))\ngood=True\nfor i in range(m):\n    for j in range(i+1,m):\n        if len(sets[i]&sets[j])==0:\n            good=False\nif good:\n    print(\"possible\")\nelse:\n    print(\"impossible\")", "import math\nm,n = list(map(int,input().split()))\ndays = []\nfor z in range(m):\n\tt = set(list(map(int,input().split()))[1:])\n\tdays.append(t)\ncheck = True\nfor i in range(m):\n\tfor j in range(i):\n\t\tif not days[i].intersection(days[j]):\n\t\t\tcheck = False\n\t\t\tbreak\n\t\tif not check:\n\t\t\tbreak\nif(check):\n\tprint(\"possible\")\nelse:\n\tprint(\"impossible\")\n\n", "import math\nimport re\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nfrom fractions import gcd\n\ndef read(type = int):\n  return type(input())\n  \ndef read_list(type = int, split = ' ', F = None):\n  if F:\n    return map(lambda x: F(type(x)), raw_input().split(split))\n  return list(map(type, input().split(split)))\n\ndef read_list_of_list(N, type = int, split = ' ', F = None):\n  return [read_list(type, F = F) for _ in range(N)]\n\n\nm, n = read_list()\nB = read_list_of_list(m)\nL = []\nfor b in B:\n  b = set(b[1:])\n  for l in L:\n    if l.isdisjoint(b):\n      print('impossible')\n      return\n  L += [b]\n  \nprint('possible')", "m, n = list(map(int, input().split()))\ns = [set([int(x) for x in input().split()][1:]) for _ in range(m)]\nok = True\nfor i in range(m):\n    for j in range(i + 1, m):\n        if not s[i] & s[j]:\n            ok = False\n            break\n    if not ok:\n        break\nprint((\"\" if ok else \"im\") + \"possible\")\n", "m,n=map(int,input().split())\nl=[]\nl=[list(map(int,input().split())) for i in range(m)]\n\nl=[set(i[1:]) for i in l]\nfor i in range(m):\n\tfor j in range(i+1,m):\n\t\tif len(l[i].intersection(l[j]))==0:\n\t\t\tprint('impossible')\n\t\t\treturn\nprint('possible')", "m,n = map(int, input().split())\nsets = []\nfor i  in range(m):\n    a = list(map(int,input().split()))\n    sets.append(set(a[1:]))\ngood = True\nfor i in range(m):\n    for j in range(i+1,m):\n        if len(sets[i]&sets[j])==0:\n            good = False\nif good:\n    print(\"possible\")\nelse:\n    print(\"impossible\")", "m,n = list(map(int,input().split()))\nt = []\nfor i in range(m):\n    temp = list(map(int,input().split()))[1:]\n    bit = 0\n    for i in temp:\n        bit ^= (1<<(i-1))\n    t.append(bit)\nans = True\nfor i in range(m-1):\n    for j in range(i+1,m):\n        if t[i] & t[j] == 0:\n            ans = False\nprint('possible' if ans else 'impossible')\n", "m,n = list(map(int,input().split()))\nt  = [set([i for i in list(map(int,input().split()))[1:]]) for _ in range(m)]\nfor i in range(m-1):\n    for j in range(i+1,m):\n        if len(t[i]&t[j]) == 0:\n            print('impossible')\n            break\n    else:\n        continue\n    break\nelse:\n    print('possible')\n", "m,n=list(map(int,input().split()))\nL=[]\nfor i in range(0,m):\n    s=[int(x) for x in input().split()]\n    s=s[1:]\n    L.append(set(s))\n\nfor i in range(m-1):\n    for j in range(i+1,m):\n        if(len(L[i]&L[j])==0):\n            print('impossible')\n            break\n    else:\n        continue\n    break\nelse:\n    print('possible')\n", "m, n = list(map(int, input().split()))\n\ns = [0] * m\n\nfor w in range(m):\n    for i in list(map(int, input().split()))[1:]:\n         s[w] |= 1 << i\n\nfor i in s:\n    for j in s:\n        if not (i & j):\n            print('impossible')\n            return\n\nprint('possible')\n", "m, n = map(int, input().split())\n\ns = [0] * m\n\nfor w in range(m):\n    for i in list(map(int, input().split()))[1:]:\n        s[w] |= 1 << i\n\nfor i in s:\n    for j in s:\n        if not (i & j):\n            print('impossible')\n            return\n\nprint('possible')", "m,n = [int(i) for i in input().split()]\nmas = set(range(1,n+1))\n\nsetd = []\nsets = []\nfor i in range(m):\n    s = set()\n    [s.add(int(j)) for j in input().split()[1:]]\n    setd.append(s)\n    sets.append(mas.difference(s))\n\n\n#print(setd)\n#print(sets)\n\n\nflag = True\nfor i in range(m):\n    for j in range(m):\n        if sets[i].issuperset(setd[j]):\n            flag = False\n\n            break\n\nif flag:\n    print(\"possible\")\nelse:\n    print(\"impossible\")", "m,n = list(map(int,input().split()))\n\na = [0]*m\n\nfor i in range(m):\n    k = list(map(int,input().split()))\n    for j in range(k[0]):\n        a[i] |= 1<<k[j+1]\n\nfor i in range(m):\n    for j in range(m):\n        if a[i]&a[j] == 0:\n            print(\"impossible\")\n            quit()\nprint(\"possible\")\n", "m, n = list(map(int,input().split()))\nt = []\n\nfor i in range(m):\n\ttemp = list(map(int,input().split()))\n\tbit = 0\n\tfor i in temp[1:]:\n\t\tbit ^= (1 << (i - 1))\n\tt.append(bit)\n\nans = True\n\nfor i in range(m - 1):\n\tfor j in range(i + 1, m):\n\t\tif t[i] & t[j] == 0:\n\t\t\tans = False\n\nprint('possible' if ans else 'impossible')\n", "m,n=list(map(int,input().split()))\ns=set(range(1,n+1))\nd=[[None,None]for i in range(m)]\nfor i in range(m):\n    x=list(map(int,input().split()))[1:]\n    x=set(x)\n    d[i][0]=x\n    d[i][1]=s-x\nfor i in range(m):\n    for j in range(i+1,m):\n        bi,si=d[i]\n        bj,sj=d[j]\n        if sj.issuperset(bi) and bj.issubset(si):\n            print('impossible')\n            quit()\nprint('possible')\n", "m, n = list(map(int, input().split()))\nt = [set([int(i) for i in input().split()][1:]) for j in range(m)]\nfor i in range(m - 1):\n    for j in range(1, m):\n        if not (t[i] & t[j]):\n            print('impossible')\n            return\nprint('possible')\n"]
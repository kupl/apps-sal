["n, m = list(map(int, input().split()))\nline = list(map(int, input().split()))\n\npairs = set()\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    pairs.add((a,b))\n\nreq = [line.pop()]\n\nout = 0\nwhile line != []:\n    nex = line.pop()\n    works = True\n    for pers in req:\n        if not (nex, pers) in pairs:\n            works = False\n            break\n    if works:\n        out += 1\n    else:\n        req.append(nex)\n\nprint(out)\n        \n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nP=list(map(int,input().split()))\nPAIR=[list(map(int,input().split())) for i in range(m)]\n\nNAT=P[-1]\n\nLIST=[[] for i in range(n+1)]\n\nfor x,y in PAIR:\n    LIST[x].append(y)\n\nfor i in range(n+1):\n    LIST[i]=set(LIST[i])\n\nFLIST=[NAT]\ni=n-2\nANS=0\nwhile i>=0:\n\n    for j in FLIST:\n        if j in LIST[P[i]]:\n            continue\n        else:\n            FLIST.append(P[i])\n            break\n\n    else:\n        ANS+=1\n\n    i-=1\n        \nprint(ANS)\n        \n    \n    \n", "n, m = list(map(int, input().split()))\np = tuple(map(int, input().split()))\nr = [{i} for i in range(n + 1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    r[u].add(v)\nfirst = True\nnr = set()\nres = 0\nfor i in p[::-1]:\n    if first:\n        cur = 1\n        first = False\n    else:\n        cur = len(nr)\n        for ri in r[i]:\n            if ri in nr:\n                cur -= 1\n    if cur:\n        nr.add(i)\n    else:\n        res += 1\nprint(res)\n", "n, m = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nallp = set()\nfor i in range(m):\n\tu, v = list(map(int, input().split()))\n\tallp.add((u ,v))\n\ncurrentList = [p.pop()]\nsuma = 0\n\nwhile len(p) > 0:\n\tnextc = p.pop()\n\tcheck = True\n\tfor i in currentList:\n\t\tif not ((nextc, i) in allp):\n\t\t\tcheck = False\n\t\t\tbreak\n\t\n\tif check:\n\t\tsuma += 1\n\telse:\n\t\tcurrentList.append(nextc)\n\nprint(suma)\t\n", "\n# -*- coding: utf-8 -*-\n# @Date    : 2019-03-12 15:49:02\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nimport sys\nsys.setrecursionlimit(10**5+1)\n\ninf     =  int(10 ** 20)\nmax_val =  inf\nmin_val = -inf\n\nRW  = lambda : sys.stdin.readline().strip()\nRI  = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\n\nN, M = RMI()\nP = RMI()\nG = [[] for x in range(N+6)]\nC = [0 for x in range(N+6)]\nans = 0\nfor _ in range(M):\n    x,  y = RMI()\n    G[y].append(x)\nfor i in range(N-1, -1, -1):\n    if C[P[i]] == N - 1 - i - ans and i != N - 1:\n        ans += 1\n    else:\n        for F in G[P[i]]:\n            C[F] += 1\nprint(ans)\n\n\n", "n, m = [int(x) for x in input().split()]\nq = [int(x) for x in input().split()]\nhelpers = [[] for i in range(n + 5)]\nhelping = [0] * 300005\nans, removed = 0, 0\nfor i in range(m):\n    u, v = [int(c) for c in input().split()]\n    helpers[v].append(u)\n\nfor i in helpers[q[-1]]:\n    helping[i] += 1\n\nfor i in range(n - 2, -1, -1):\n    remaining = n - 1 - i - removed\n    if(helping[q[i]] == remaining):\n        removed += 1\n        ans += 1\n    else:\n        for k in helpers[q[i]]:\n            helping[k] += 1\n        \nprint(ans)\n\n    \n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/13 11:57\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : D. Nastya Is Buying Lunch.py\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n    n, m = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    edge_set = set()\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        edge_set.add((u, v))\n\n    ret = 0\n    curr_list = [p.pop()]\n    while p:\n        u = p.pop()\n        flag = True\n        for v in curr_list:\n            if (u, v) not in edge_set:\n                flag = False\n                break\n        if flag:\n            ret += 1\n        else:\n            curr_list.append(u)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\nl=[int(x) for x in input().split()]\npairs=[[] for i in range(n+1)]\nans=0\nN=[0 for i in range(n+1)]\nfor i in range(m):\n    a,b=map(int,input().split())\n    pairs[b].append(a)\nfor i in range(n-1,-1,-1):\n    if N[l[i]]==n-1-i-ans and i!=n-1:\n        ans+=1\n    else:\n        for I in pairs[l[i]]:\n            N[I]+=1\nprint(ans)", "n, m = list(map(int, input().split()))\np = list(map(int, input().split()))\ngr = [set() for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    gr[a].add(b)\n\ncant = {p[-1] - 1}\nfor i in range(n - 2, -1, -1):\n    cnt = 0\n    for j in gr[p[i] - 1]:\n        if j in cant:\n            cnt += 1\n    # print(p[i], gr[p[i] - 1], cnt)\n    if cnt != len(cant):\n        cant.add(p[i] - 1)\n# print(cant)\nprint(n - len(cant))\n", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nn, m = mapin()\na = listin()\ns = set([])\nfor _ in range(m):\n    s.add(tuple(mapin()))\nz = [a.pop()]\ncount = 0\nwhile a:\n    last = a.pop()\n    flag = True\n    for i in z:\n        if (last, i) not in s:\n            flag = False\n            break\n    if flag:\n        count+=1\n    else:\n        z.append(last)\nprint(count)", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nn, m = mapin()\na = listin()\ns = set([])\nfor _ in range(m):\n    s.add(tuple(mapin()))\nz = [a.pop()]\ncount = 0\nwhile a:\n    last = a.pop()\n    flag = True\n    for i in z:\n        if (last, i) not in s:\n            flag = False\n            break\n    if flag:\n        count+=1\n    else:\n        z.append(last)\nprint(count)", "n, m = map(int, input().split())\n\np = list([int(s)-1 for s in input().split()])\nnastya = p[-1]\n\ngood = [False] * n\n\nswaps = [[] for _ in range(n)]\ncounts = [0] * n\nfor _ in range(m):\n\tu, v  = map(int, input().split())\n\tu-=1\n\tv-=1\n\tif v==nastya:\n\t\tgood[u] = True\n\telse:\n\t\tswaps[v].append(u)\n\ntotal = 0\nbad_count = 0\nfor i, pupil in enumerate(p[-2::-1]):\n\tif good[pupil] and counts[pupil] >= bad_count:\n\t\ttotal += 1\n\telse:\n\t\tbad_count += 1\n\t\tfor u in swaps[pupil]:\n\t\t\tcounts[u] += 1\nprint(total)", "import sys\nimport heapq\nimport math\nfrom enum import Enum\n\nlines = sys.stdin.read().splitlines()\nn, m = list(map(int, lines[0].split(' ')))\npositionToNumber = [int(x)-1 for x in lines[1].split(' ')]\n\nnumberToPosition = [0]*n\nfor i in range(0, len(positionToNumber)):\n    numberToPosition[positionToNumber[i]] = i\n\n# print('numberToOrder: ' + str(numberToOrder))\nletsInFront = []\nfor i in range(0, n):\n    letsInFront.append(set())\nfor i in range(0, m):\n    a, b = list(map(int, lines[i+2].split(' ')))\n    # a lets b in front\n    indexA = a-1\n    indexB = b-1\n    letsInFront[numberToPosition[indexA]].add(numberToPosition[indexB])\n\n# for i in range(0, n):\n#     letsInFront[i].sort()\n# print(bitmaps)\ncount = 0\nlet = set()\nlet.add(n-1)\n# print(letsInFront)\nfor i in reversed(list(range(0, n-1))):\n    found = True\n    if len(let) > len(letsInFront[i]):\n        found = False\n    else:\n        for j in let:\n            if j not in letsInFront[i]:\n                found = False\n                break\n    if not found:\n        let.add(i)\n    else:\n        count += 1\nprint(count)\n", "n,m = list(map(int, input().split()))\np = list(map(int, input().split()))\np.insert(0, 0)\n\nvis = [0] * (n+7)\nG = [[0] for i in range(n+7)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    G[v].append(u)\n\nfor x in G[p[n]]:\n    vis[x] += 1\n\nans = 0\ncnt = 1\nfor i in range(n - 1, 0, -1):\n    now = p[i]\n    if vis[now] == cnt:\n        ans += 1\n    else:\n        cnt += 1\n        for y in G[now]:\n            vis[y] += 1\n\nprint(ans)\n    \n", "from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\nnas=s[-1]\ng=set()\nst=set()\nfor i in range(m):\n    a,b=list(map(int,stdin.readline().strip().split()))\n    if b==nas:\n        g.add(a)\n    else:\n        st.add((a,b))\nx=n-2\nwhile x>=0:\n    if s[x] in g and s[x+1] not in g and (s[x],s[x+1]) in st:\n        st.remove((s[x],s[x+1]))\n        aux=s[x]\n        s[x]=s[x+1]\n        s[x+1]=aux\n        x=min(n-2,x+1)\n        \n    elif s[x] in g and s[x+1] in g and (s[x],s[x+1]) in st:\n        st.remove((s[x],s[x+1]))   \n        aux=s[x]\n        s[x]=s[x+1]\n        s[x+1]=aux\n        x=min(n-2,x+1)\n         \n    else:\n        x-=1\nans=0\nfor i in range(n-2,-1,-1):\n    if s[i] in g:\n        ans+=1\n    else:\n        break\nprint(ans)\n", "n,m = [int(x) for x in input().split()]\n\np = [int(x)-1 for x in input().split()]\n\ne = [[] for _ in range(n)]\n\nfor _ in range(m):\n    u,v = [int(x) for x in input().split()]\n    e[u-1].append(v-1)\n\nt = [p[n-1]]\n\nans = 0\nfor i in range(n-2,-1,-1):\n    u = p[i]\n    if len(e[u]) >= len(t):\n        f = set(e[u])\n        can = True\n        for x in t:\n            if x not in f:\n                can = False\n                break\n        if can : ans += 1\n        else: t.append(u)\n    else:\n        t.append(u)\n\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nq = list(map(int, input().split()))\n\nG = [set() for _ in range(n + 1)]\nvn = []\nfor i in range(m):\n  u, v = list(map(int, input().split()))\n  G[u].add(v)\n\nP = set([q[-1]])\nfor i in range(n - 2, -1, -1):\n  p = q[i]\n  if len(G[p]) < len(P) or not P.issubset(G[p]):\n    P.add(p)\nprint(n - len(P))\n", "def __starting_point():\n    n, m = (int(x) for x in input().split())\n    queue = [int(x) - 1 for x in input().split()]\n    id___passables = [set() for _ in range(n)]\n    for _ in range(m):\n        id1, id2 = (int(x) - 1 for x in input().split())\n        id___passables[id2].add(id1)\n    train_passables = id___passables[queue[-1]].copy()\n    ans = 0\n    for person in reversed(queue[:-1]):\n        if person in train_passables:\n            ans += 1\n        else:\n            train_passables &= id___passables[person]\n    print(ans)\n    # swapable = [[int(x) for x in input().split()] for _ in range(m)]\n\n__starting_point()"]
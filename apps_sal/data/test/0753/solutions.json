["from fractions import Fraction,gcd\n\na,b,c,d = [int(x) for x in input().split()]\n\nif a*d > b*c:\n    num = a*d-b*c\n    denom = a*d\nelse:\n    num = b*c-a*d\n    denom = b*c\ndiv = gcd(num,denom)\nprint('%d/%d'%(num//div,denom//div))\n", "from fractions import gcd\na,b,c,d = list(map(int, input().split()))\nax, bx, cx, dx = a,b,c,d\n\na,b,c,d = a*d, b*d, c*b, d*b\n\nmonitor = a*b\nfilm = c*d\nnegru = monitor - film\n\nmonitor, negru = monitor//gcd(monitor, negru), negru//gcd(monitor, negru)\nans1 = (negru, monitor)\n\n\na,b,c,d = bx, ax, dx, cx\na,b,c,d = a*d, b*d, c*b, d*b\n\nmonitor = a*b\nfilm = c*d\nnegru = monitor - film\n\nmonitor, negru = monitor//gcd(monitor, negru), negru//gcd(monitor, negru)\nans2 = (negru, monitor)\n\n\n\n\nif ans1[1] == 0 or ans1[0] / ans1[1] < 0:\n    sol = ans2\nelif ans2[1] == 0 or ans2[0] / ans2[1] < 0:\n    sol = ans1\nelse:\n    if ans1[0] / ans1[1] < ans2[0] / ans2[1]: sol = ans1\n    else: sol = ans2\n\nprint('%i/%i' % sol)\n    \n\n", "import fractions\n\ndef solve(a, b, c, d):\n    if a * d == b * c:\n        return \"0/1\"\n    elif a / c > b / d:\n        return str(fractions.Fraction(a * d - c * b, a * d))\n    else:\n        return str(fractions.Fraction(c * b - a * d, c * b))\n\ndef test():\n    assert solve(1, 1, 3, 2) == \"1/3\"\n    assert solve(4, 3, 2, 2) == \"1/4\"\n    assert solve(1, 1, 1, 1) == \"0/1\"\n    print(\"test passes\")\n\n##test()\na, b, c, d = tuple(map(int, input().split()))\nprint(solve(a, b, c, d))\n    \n", "from fractions import Fraction\n\ndef __starting_point():\n    inp = input()\n    arr = inp.split(\" \")\n    a = Fraction(int(arr[0]),1)\n    b = Fraction(int(arr[1]),1)\n    c = Fraction(int(arr[2]),1)\n    d = Fraction(int(arr[3]),1)\n\n\n    if d*a == c*b:\n        ans=Fraction(0,1)\n    elif d*a<c*b:\n        ans = (b-(d*(a/c)))/b\n    else:\n        ans = (a-(c*(b/d)))/a\n    \n    print(ans.numerator,end='')\n    print('/',end='')\n    print(ans.denominator)\n\n__starting_point()", "a, b, c, d = list(map(int, input().split()))\n\n\ndef largest_div(n, m):\n    while m > 0:\n        rest = n % m\n        n = m\n        m = rest\n    return n\n\nif a/b == c/d:\n    print(\"0/1\")\nelse:\n    if a/b > c/d:  # full height\n        f_new_width = c * b\n        f_upper = d * a - f_new_width\n        f_lower = d * a\n    else:  # full width\n        f_new_height = d * a\n        f_upper = c * b - f_new_height\n        f_lower = c * b\n\n\n    div = largest_div(f_upper, f_lower)\n    print(\"/\".join((str(int(f_upper/div)), str(int(f_lower/div)))))\n", "3\n\nimport sys\nfrom fractions import Fraction\n\na, b, c, d = list(map(int, sys.stdin.readline().strip().split()))\nd2 = Fraction(d*a, c)\nans = None\nif d2 <= Fraction(b):\n    # fits left-to-right\n    ans = (Fraction(b) - d2) / Fraction(b)\nelse:\n    # fits top-to-bottom\n    c2 = Fraction(c*b, d)\n    ans = (Fraction(a) - c2) / Fraction(a)\n\nif ans.denominator == 1:\n    print(\"%d/1\" % ans.numerator)\nelse:\n    print(ans)\n", "from math import *\ndef GCD(a, b):\n\twhile (b):\n\t\ta %= b\n\t\ta, b = b, a\n\treturn a\na, b, c, d = map(int, input().split())\nC, D = min(a*d,b*c), max(a*d,b*c)\nC = D - C\nG = GCD(C, D)\nC = C // G\nD = D // G\nprint (str(C) + \"/\" + str(D))", "from fractions import Fraction\nfrom decimal import Decimal\na, b, c, d = list(map(int, input().split()))\nans = max(Fraction((a * d - b * c)/ (a * d)).limit_denominator(), Fraction((b * c - a * d) / (b * c)).limit_denominator())\nif ans == 0:\n    ans = '0/1'\nprint(ans)\n", "from fractions import gcd\n\n\ndef socr(a, b):\n    tmp = gcd(a, b)\n    return a // tmp, b // tmp\n\na, b, c, d = list(map(int, input().split()))\n\nans = socr(a * d - b * c, a * d)\na, b = b, a\nc, d = d, c\nans = socr(a * d - b * c, a * d) if ans[0] < 0 or ans[1] < 0 else ans\nprint(str(int(ans[0])) + '/' + str(int(ans[1])))\n", "from fractions import gcd,Fraction,Decimal\na,b,c,d=map(int,input().split())\n\n##c->a\n##d->b\nif(a/b<c/d):\n    N=(b*c)-(a*d)\n    D=b*c\nelse:\n    N=(a*d)-(b*c)\n    D=a*d\n\nx=gcd(N,D)\n\nprint(N//x,end=\"/\")\nprint(D//x)\n\n\n", "import sys\n\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n\nclass Fraction:\n    def __init__(self, p = 0, q = 1, reduced = True):\n        if type(p) == int:\n            self.p = p\n            if type(q) == int:\n                self.q = q\n        elif type(p) == Fraction:\n            self.p = p.p\n            self.q = p.q\n        else:\n            i = p.find(' ')\n            if i == -1:\n                i = p.find('/')\n            if i == -1:\n                self.p = int(p)\n                self.q = 1\n            else:\n                self.p = int(p[:i])\n                self.q = int(p[i + 1:])\n        if reduced:\n            self.reduce()\n\n    def reduce(self):\n        g = gcd(self.p, self.q)\n        self.p //= g\n        self.q //= g\n\n    def __str__(self):\n        if self.q == 1:\n            return(str(self.p))\n        else:\n            return(str(self.p) + '/' + str(self.q))\n\n    def __lt__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p < other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q < self.q * other.p\n\n    def __le__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p <= other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q <= self.q * other.p\n\n    def __gt__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p > other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q > self.q * other.p\n\n    def __ge__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p >= other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q >= self.q * other.p\n\n    def __eq__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p == other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q == self.q * other.p\n\n    def __ne__(self, other):\n        self.reduce()\n        if type(other) == float or type(other) == int:\n            return self.p != other * self.q\n        else:\n            other.reduce()\n            return self.p * other.q != self.q * other.p\n\n    def __mul__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p * other, self.q)\n        elif type(other) == float:\n            return self.p * other / self.q\n        else:\n            return Fraction(self.p * other.p, self.q * other.q)\n\n    def __rmul__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p * other, self.q)\n        elif type(other) == float:\n            return self.p * other / self.q\n        else:\n            return Fraction(self.p * other.p, self.q * other.q)\n\n    def __imul__(self, other):\n        self = self * other\n        return self\n\n    def __truediv__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p, self.q * other)\n        elif type(other) == float:\n            return self.p / self.q / other\n        else:\n            return Fraction(self.p * other.q, self.q * other.p)\n\n    def __rtruediv__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.q * other, self.p)\n        elif type(other) == float:\n            return other * self.q / self.p\n        else:\n            return Fraction(self.q * other.p, self.p * other.q)\n\n    def __itruediv__(self, other):\n        self = self / other\n        return self\n\n    def __pow__(self, other):\n        if type(other) == int:\n            if other >= 0:\n                return Fraction(self.p ** other, self.q ** other, False)\n            else:\n                return Fraction(self.q ** (-other), self.p ** (-other), False)\n        elif type(other) == float:\n            return (self.p / self.q) ** other\n        else:\n            return (self.p / self.q) ** (other.p / other.q)\n\n    def __rpow__(self, other):\n        if type(other) == int or type(other) == float:\n            return other ** (self.p / self.q)\n        else:\n            return (other.p / other.q) ** (self.p / self.q)\n\n    def __ipow__(self, other):\n        self = self ** other\n        return self\n\n    def __add__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p + self.q * other, self.q)\n        elif type(other) == float:\n            return self.p / self.q + other\n        else:\n            return Fraction(self.p * other.q + self.q * other. p, self.q * other.q)\n\n    def __radd__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p + self.q * other, self.q)\n        elif type(other) == float:\n            return self.p / self.q + other\n        else:\n            return Fraction(self.p * other.q + self.q * other. p, self.q * other.q)\n\n    def __iadd__(self, other):\n        self.reduce()\n        self = self + other\n        return self\n\n    def __sub__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.p - self.q * other, self.q)\n        elif type(other) == float:\n            return self.p / self.q - other\n        else:\n            return Fraction(self.p * other.q - self.q * other. p, self.q * other.q)\n\n    def __rsub__(self, other):\n        self.reduce()\n        if type(other) == int:\n            return Fraction(self.q * other - self.p, self.q)\n        elif type(other) == float:\n            return other - self.p / self.q\n        else:\n            return Fraction(self.q * other. p - self.p * other.q, self.q * other.q)\n\n    def __pos__(self):\n        return Fraction(+self.p, +self.q)\n\n    def __neg__(self):\n        return Fraction(-self.p, self.q)\n\n    def __abs__(self):\n        if self.p < 0:\n            return -self\n        else:\n            return self\n\n    def __int__(self):\n        return self.p // self.q\n\n    def __float__(self):\n        return self.p / self.q\n\n    def __round__(self, digits = 0):\n        return round(float(self), digits)\n\na, b, c, d = list(map(int, input().split()))\nproduct = a * c\nB1 = b * c\nB2 = a * d\nif B1 > B2:\n    B1, B2 = B2, B1\nans = Fraction(B2 - B1, B2)\nans.reduce()\nif ans != 0:\n    print(abs(ans))\nelse:\n    print(\"0/1\")\n", "import sys\nfrom fractions import gcd\nmy_file = sys.stdin\n#my_file = open(\"input.txt\", \"r\")\nline = [int(i) for i in my_file.readline().split()]\na, b, c, d = line[0], line[1], line[2], line[3]\nif a/b < c/d:\n    N = (b*c) - (a*d)\n    D = b*c\nelse:\n    N = (a*d)-(b*c)\n    D = a*d\n\ndec = gcd(N,D)\n\nprint(N//dec, end=\"/\")\nprint(D//dec)", "def gcd(a, b):\n    while a % b != 0:\n        a, b = b, a % b\n    return b\n\nl = input().split(' ')\na, b, c, d = int(l[0]), int(l[1]), int(l[2]), int(l[3])\nif a * d > b * c:\n    p = a * d - b * c\n    q = a * d\nelse:\n    p = b * c - a * d\n    q = b * c\ne = gcd(p, q)\np //= e\nq //= e\nprint(str(p) + \"/\" + str(q))\n", "def gcd(a,b):\n    while a!=b:\n        if a>b:\n            a=a-b\n        else :\n            b=b-a\n    print(m//a,'/',n//a,sep='')\na,b,c,d=map(int,input().split())\nm=1\nn=1\n\nif a==b:\n    if c==d :\n        print(0,'/',1,sep='')\n    else :\n        if c>d:\n            m=b*c-a*d\n            n=c*b\n            gcd(m,n)\n        else :\n            m=a*d-c*b\n            n=a*d           \n            gcd(m,n)\nelse:\n    if c/d ==a/b:\n        print(0,'/',1)\n    else :\n        if c/d>a/b:\n            m=b*c-a*d\n            n=c*b\n            gcd(m,n)\n        else :\n            m=a*d-c*b\n            n=a*d           \n            gcd(m,n)        \n            \n        \n                 \n", "def gcd(a, b):\n    if(a % b == 0):\n        return b\n    return gcd(b, a%b)\n\na, b, c, d = list(map(int, input().split()))\n\na *= c * d\nb *= c * d\n\nif a / c * d <= b:\n    a = b - a / c * d\n    g = gcd(a, b)\n    print(str(int(a / g)) + '/' + str(int(b / g)))\n\nelse:\n    b = a - b / d * c\n    g = gcd(a, b)\n    print(str(int(b / g)) + '/' + str(int(a / g)))\n", "import fractions\n\na, b, c, d = list(map(int, input().split()))\np = max(a * d, b * c) - min(a * d, b * c)\nq = max(a * d, b * c)\nx = fractions.gcd(p, q)\nprint(str(p // x) + '/' + str(q // x))\n", "from fractions import Fraction\nwhile(1):\n    try:\n        a,b,c,d=list(map(int,input().split()))\n        if a/b<c/d:\n            ratio=0\n        elif a/b==c/d:\n            ratio=-1\n        else:\n            ratio=1\n        if ratio==0:\n            # ans=(bc-ad)/bc\n            f=Fraction(b*c-a*d,b*c) \n            print(\"%s\"%(f))            \n        elif ratio==1:\n             # ans=(ad-bc)/ad\n            f=Fraction(a*d-b*c,a*d)\n            print(\"%s\"%(f))\n        else:\n            print(\"0/1\")\n    except EOFError:\n        break\n        \n        \n", "def gcd(a,b):\n    if(a%b==0):return b;\n    return gcd(b,a%b);\ndef solve(a,b,p,q):\n    c=a*p/gcd(a,p);\n    b1=b*c/a;\n    q1=q*c/p;\n    if(b1>=q1):\n        if(b1==q1):\n            print(\"0/1\");\n        else:\n            d=gcd(b1-q1,b1);\n            print(str(int((b1-q1)/d))+\"/\"+str(int(b1/d)));\n        return True;\n    return False;\ndef __starting_point():\n    a,b,p,q=map(int,input().split());\n    if(not solve(a,b,p,q)):\n        solve(b,a,q,p);\n__starting_point()", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Author: Vitaly Pavlenko\n\nimport random\nfrom fractions import gcd\n\n\ndef average(x):\n    return sum(x) / len(x)\n\n\ndef shuffled(a):\n    a = list(a)\n    random.shuffle(a)\n    return a\n\n\ndef read_ints():\n    return [int(i) for i in input().split()]\n\n\ndef decrease(a):\n    return [i - 1 for i in a]\n\n\n\n\ndef main():\n    # nonlocal input\n    # nonlocal print\n\n    # fin = open('input.txt', 'r')\n    # input = lambda: fin.readline().strip()\n    # fout = open('output.txt', 'w')\n    # _print = print\n    # print = lambda *args, **kwargs: _print(*args, file=fout, **kwargs)\n\n    a, b, c, d = read_ints()\n\n    if a / b < c / d:\n        a, b, c, d = b, a, d, c\n\n    p, q = a * d - c * b, b * d\n    s, t = p, a * d\n    print(s // gcd(s, t), t // gcd(s, t), sep='/')\n\n    # fout.close()\n\n\ndef __starting_point():\n    # import doctest\n    # doctest.testmod()\n    main()\n__starting_point()", "from fractions import gcd\n\ndef Irreducible_Fraction(A,B):\n    ''' Returns list of two integers representing the nominator and denominator of the Irreducible version of A/B '''\n    x=gcd(A,B)\n    return [A//x,B//x]\n        \n\n\n\na,b,c,d=map(int,input().split())\n\n#Movie Frame Ratio:\nF=a/b\n\n#Screen Ratio:\nS=c/d\n\n\n\n#There are three case:\n(a/b < c/d)\n(a/b == c/d)\n(a/b > c/d)\n\n\n#Case 1:\n#Frame's ratio is larger than screen ratio (c/d > a/b)\n#This means that if both the screen and the movie had the same vertical length,\n#The movie's horizontal length will be bigger which is not desired !\n#So in this case, we will stretch the movie until it is the same horizontal length as the screen,( c -> a )\n#And the movie's vertical length would be smaller than the screen's vertical length.( d < b )\n#Stretching factor = a/c\nif(a/b <c/d):\n    stretching_factor=a/c\n    #To avoid decimals which may result into an error while computing the fraction\n    #We will multiply both the the new area and te screen area by c\n    New_horizontal=a\n    New_vertical=a*d #The multiplied c apears in ommiting the division by c in the stretching factor\n    New_Movie_Area=int(New_horizontal*New_vertical)\n    Screen_Area=int(a*b*c) #The multiplied c appears\n    Empty_Area=Screen_Area-New_Movie_Area\n    desired_ratio=Irreducible_Fraction(Empty_Area,Screen_Area)\n    nominator=desired_ratio[0]\n    denominator=desired_ratio[1]\n    print(nominator,end=\"/\")\n    print(denominator)\n\n\n#Case 2:\n#Frame's ratio is the same as the screen ratio (c/d == a/b)\n#This means that we can stretch the movie till it is the same horizontal length as the screen,\n#And the vertical length of the movie would be the same as the vertical length of the screen\n#So The empty area will always be ZERO !\n\n\nelif(a/b == c/d):\n    print(\"0/1\")\n\n\n#Case 3:\n#Opposite to Case 1\n#Frame's ratio is smaller than screen ratio (c/d > a/b)\n#This means that the stretching process will end when the vertical length is the same for the screen and the frame\n#While the horizontal length of the screen is bigger\n#Stretching facto = b/d\nelse:\n    stretching_factor=b/d\n    #To_avoid decimals, the same as case 1 was done !\n    New_vertical=b\n    New_horizontal=(b)*c\n    New_Movie_Area=int(New_horizontal*New_vertical)\n    Screen_Area=int(a*b*d)\n    Empty_Area=Screen_Area-New_Movie_Area\n    desired_ratio=Irreducible_Fraction(Empty_Area,Screen_Area)\n    nominator=desired_ratio[0]\n    denominator=desired_ratio[1]\n    print(nominator,end=\"/\")\n    print(denominator)\n", "from fractions import Fraction\n\na, b, c, d = map(int, input().split())\n\nif a / c <= b / d:\n  res = Fraction(b * c - a * d, b * c)\nelse:\n  res = Fraction(a * d - b * c, a * d)\n\nprint(\"{0}/{1}\".format(res.numerator, res.denominator))", "def check(t):\n    if x==int(x):return True\n    else:return False\n\ndef gcd(x,y):\n    if x%y==0 :return y\n    else: return gcd(y,x%y)\na,b,c,d=list(map(int,input().split()))\na*=max(c,d)\nb*=max(c,d)\nr=c/d\nif a/b<r:\n   x=b*c-a*d\n   b=b*c\n  \n   \n\n   u=gcd(x,b)\n   p=str(int(x/u))+'/'+str(int(b/u))\n   print(p)\n\nelse:\n    x=a*d-c*b\n    a=a*d\n    \n\n    u=gcd(x,a)\n    p=str(int(x/u))+'/'+str(int(a/u))\n    print(p)\n", "def gcd(x, y):\n    while x!=0:\n        x,y = y%x,x\n    return y\n\ndef main():\n    a,b,c,d = [int(item) for item in input().split()]\n    k1 = float(a)/float(b)\n    k2 = float(c)/float(d)\n    p = 0\n    q = 1\n    g = 0\n\n    if k1>k2:\n        q = a*d\n        p = q-b*c\n        g = gcd(p,q)\n    elif k1<k2:\n        q = b*c\n        p = q - a*d\n        g = gcd(p, q)\n\n    if g>1:\n        p = int(p / g)\n        q = int(q / g)\n\n    print('{}/{}'.format(p, q))\n\nmain()\n", "def gcd(a, b):\n    c = a % b\n    return gcd(b, c) if c else b\n\na, b, c, d = map(int, input().split())\nif a * d < b * c: a, b, c, d = b, a, d, c\np = a * d - b * c\nq = d * a\nt = gcd(p, q)\n\nprint(str(p // t) + '/' + str(q // t))", "from sys import stdin\nfrom fractions import Fraction\n\n(a,b,c,d) = map(int, input().split());\n\ncd = Fraction(c, d)\nab = Fraction(a, b)\nf1 = Fraction(1, 1)\n\nif cd < ab:\n\tprint(f1 - Fraction(c * b, a * d))\nelif cd > ab:\n\tprint(f1 - Fraction(a * d, c * b))\nelse:\n\tprint(\"0/1\")"]
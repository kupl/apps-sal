["import sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,a,b=map(int,input().split())\n\nif a<b: a,b=b,a\n\nif b==0:\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n    print((n-1)*a)\nelse:\n    # pascal's triangle thing\n    pascal=[[1]*20005]\n    for i in range(20004):\n        newrow=[1]\n        for j in range(1,20005):\n            newrow.append(newrow[-1]+pascal[-1][j])\n            if newrow[-1]>n: break\n        pascal.append(newrow)\n    def getcom(a,b):\n        # return a+b choose b\n        # if larger than n, return infinite\n        if len(pascal[a])>b: return pascal[a][b]\n        if b==0: return 1\n        if b==1: return a\n        return 100000005\n\n    # start with the null node (prefix cost 0)\n    # can split a node into two other nodes with added cost c+a+b\n    # new nodes have prefix costs c+a, c+b\n    # want n-1 splits in total\n    n-=1    # now represents number of splits needed\n\n    # binary search the last cost added\n    lo=0\n    hi=a*int((n**0.5)*2+5)\n\n    while 1:\n        mid=(lo+hi)//2\n        # count stuff\n        c0=0    # < mid\n        c1=0    # = mid\n        for i in range(mid//a+1):\n            j=(mid-i*a)//b\n            if (mid-i*a)%b!=0:\n                # c0 += iC0 + (i+1)C1 + (i+2)C2 + ... + (i+j)Cj\n                for k in range(j+1):\n                    #print(mid,i,k)\n                    c0+=getcom(i,k)\n                    if c0>n: break\n            else:\n                for k in range(j):\n                    #print(mid,i,k)\n                    c0+=getcom(i,k)\n                    if c0>n: break\n                #print(mid,i,j,\"c1\")\n                c1+=getcom(i,j)\n        #print(mid,\"is\",c0,c1)\n        if n<c0:\n            hi=mid-1\n        elif c0+c1<n:\n            lo=mid+1\n        else:\n            # mid is correct cutoff\n            lowcost=0   # sum of all cost, where cost < mid\n            for i in range(mid//a+1):\n                j=(mid-i*a)//b\n                if (mid-i*a)%b!=0:\n                    for k in range(j+1):\n                        lowcost+=getcom(i,k)*(i*a+k*b)\n                else:\n                    for k in range(j):\n                        lowcost+=getcom(i,k)*(i*a+k*b)\n            temp=lowcost+(n-c0)*mid\n            print(temp+n*(a+b))\n            break", "import sys,heapq\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,a,b=map(int,input().split())\n\nif a<b: a,b=b,a\n\nif b==0:\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n    print((n-1)*a)\nelse:\n    # pascal's triangle thing\n    pascal=[[1]*20005]\n    for i in range(20004):\n        newrow=[1]\n        for j in range(1,20005):\n            newrow.append(newrow[-1]+pascal[-1][j])\n            if newrow[-1]>n: break\n        pascal.append(newrow)\n    def getcom(a,b):\n        # return a+b choose b\n        # if larger than n, return infinite\n        if len(pascal[a])>b: return pascal[a][b]\n        if b==0: return 1\n        if b==1: return a\n        return 100000005\n\n    # start with the null node (prefix cost 0)\n    # can split a node into two other nodes with added cost c+a+b\n    # new nodes have prefix costs c+a, c+b\n    # want n-1 splits in total\n    remain=n-1\n    ans=0\n    possible=[[a+b,1]]    # [c,count]\n    while 1:\n        # cost u, v leaves\n        u,v=heapq.heappop(possible)\n        while possible and possible[0][0]==u:\n            v+=possible[0][1]\n            heapq.heappop(possible)\n        if remain<=v:\n            ans+=u*remain\n            break\n        ans+=u*v\n        remain-=v\n        heapq.heappush(possible,[u+a,v])\n        heapq.heappush(possible,[u+b,v])\n    print(ans)", "import sys,heapq\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,a,b=map(int,input().split())\n\nif a<b: a,b=b,a\n\nif b==0:\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n    print((n-1)*a)\nelse:\n    # start with the null node (prefix cost 0)\n    # can split a node into two other nodes with added cost c+a+b\n    # new nodes have prefix costs c+a, c+b\n    # want n-1 splits in total\n    remain=n-1\n    ans=0\n    possible=[[a+b,1]]    # [c,count]\n    while 1:\n        # cost u, v leaves\n        u,v=heapq.heappop(possible)\n        while possible and possible[0][0]==u:\n            v+=possible[0][1]\n            heapq.heappop(possible)\n        if remain<=v:\n            ans+=u*remain\n            break\n        ans+=u*v\n        remain-=v\n        heapq.heappush(possible,[u+a,v])\n        heapq.heappush(possible,[u+b,v])\n    print(ans)", "import sys,heapq\n\n#sys.stdin=open(\"data.txt\")\n\ninput=sys.stdin.readline\n\n\n\nn,a,b=list(map(int,input().split()))\n\n\n\nif a<b: a,b=b,a\n\n\n\nif b==0:\n\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n\n    print((n-1)*a)\n\nelse:\n\n    # pascal's triangle thing\n\n    pascal=[[1]*20005]\n\n    for i in range(20004):\n\n        newrow=[1]\n\n        for j in range(1,20005):\n\n            newrow.append(newrow[-1]+pascal[-1][j])\n\n            if newrow[-1]>n: break\n\n        pascal.append(newrow)\n\n    def getcom(a,b):\n\n        # return a+b choose b\n\n        # if larger than n, return infinite\n\n        if len(pascal[a])>b: return pascal[a][b]\n\n        if b==0: return 1\n\n        if b==1: return a\n\n        return 100000005\n\n\n\n    # start with the null node (prefix cost 0)\n\n    # can split a node into two other nodes with added cost c+a+b\n\n    # new nodes have prefix costs c+a, c+b\n\n    # want n-1 splits in total\n\n    remain=n-1\n\n    ans=0\n\n    possible=[[a+b,1]]    # [c,count]\n\n    while 1:\n\n        # cost u, v leaves\n\n        u,v=heapq.heappop(possible)\n\n        while possible and possible[0][0]==u:\n\n            v+=possible[0][1]\n\n            heapq.heappop(possible)\n\n        if remain<=v:\n\n            ans+=u*remain\n\n            break\n\n        ans+=u*v\n\n        remain-=v\n\n        heapq.heappush(possible,[u+a,v])\n\n        heapq.heappush(possible,[u+b,v])\n\n    print(ans)\n\n\n\n# Made By Mostafa_Khaled\n"]
["n=int(input())\nval=list(map(int,input().split()))\nb=list(map(int,input().split()))\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\ninedges=[0]*n\nfor i in range(n):\n    if b[i]!=-1:\n        neig[i][0]+=1\n        neig[i].append(b[i]-1)\n        inedges[b[i]-1]+=1\nans=0\nbeg=[]\nen=[]\ntod=[]\nfor i in range(n):\n    if inedges[i]==0:\n        tod.append(i)\nwhile len(tod)>0:\n    x=tod.pop()\n    ans+=val[x]\n    if val[x]>0:\n        beg.append(x+1)\n    else:\n        en.append(x+1)\n    if neig[x][0]==1:\n        inedges[neig[x][1]]-=1\n        if inedges[neig[x][1]]==0:\n            tod.append(neig[x][1])\n        if val[x]>0:\n            val[neig[x][1]]+=val[x]\nprint(ans)\nprint(*beg,end=\" \")\nen.reverse()\nprint(*en)", "from sys import stdin\nfrom collections import deque\n\nn = int(stdin.readline())\na = list(map(int,stdin.readline().split()))\np = list(map(int,stdin.readline().split()))\n\nchnum = [0] * n\nfor i in range(n):\n    if p[i]-1 >= 0:\n        chnum[p[i]-1] += 1\n\nq = deque([])\nfor i in range(n):\n    if chnum[i] == 0:\n        q.append(i)\n\nans = 0\nalis = []\nend = []\n\nwhile len(q) > 0:\n\n    v = q.popleft()\n    ans += a[v]\n\n    if a[v] >= 0:\n        alis.append(v+1)\n        if p[v]-1 >= 0:\n            chnum[p[v]-1] -= 1\n            a[p[v]-1] += a[v]\n            if chnum[p[v]-1] == 0:\n                q.append(p[v]-1)\n    else:\n        end.append(v+1)\n        if p[v]-1 >= 0:\n            chnum[p[v]-1] -= 1\n            if chnum[p[v]-1] == 0:\n                q.append(p[v]-1)\n\nend.reverse()\nfor i in end:\n    alis.append(i)\n\nprint (ans)\nprint (*alis)", "import sys\ninput = sys.stdin.readline\n\n\ndef topological_sort(graph) -> list:\n    n = len(graph)\n    degree = [0] * n\n    for g in graph:\n        for next_pos in g:\n            degree[next_pos] += 1\n    \n    ans = [i for i in range(n) if degree[i] == 0]\n\n    stack = ans[:]\n    while stack:\n        pos = stack.pop()\n        for next_pos in graph[pos]:\n            degree[next_pos] -= 1\n            if degree[next_pos] == 0:\n                stack.append(next_pos)\n                ans.append(next_pos)\n    return ans\n\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ngraph = [[] for i in range(n)]\ninv_graph = [[] for i in range(n)]\nfor v, nxt_v in enumerate(b):\n    if nxt_v == -1:\n        continue\n    nxt_v -= 1\n    graph[v].append(nxt_v)\n    inv_graph[nxt_v].append(v)\n\nans = 0\nres = []\nused = [False] * n\n\ntp_sorted = topological_sort(graph)\nfor v in tp_sorted:\n    if used[v]:\n        continue\n    if a[v] >= 0:\n        ans += a[v]\n        for nxt_v in graph[v]:\n            a[nxt_v] += a[v]\n        used[v] = True\n        res.append(v + 1)\n\ntp_sorted = topological_sort(inv_graph)\nfor v in tp_sorted:\n    if used[v]:\n        continue\n    ans += a[v]\n    used[v] = True\n    res.append(v + 1)\n\nprint(ans)\nprint(*res)", "n = int(input())\n\na = list(map(int, input().split()))\nb = list(int(x)-1 for x in input().split())\n\nindeg = [0] * n\nfor x in b:\n    if x >= 0:\n        indeg[x] += 1\n#print(*indeg)\nq = [i for i in range(n) if indeg[i] == 0]\nans = 0\nres = []\nend = []\nwhile q:\n    top = q.pop()\n    #print(\"yo\", top)\n    if a[top] < 0:\n        end.append(top)\n    else:\n        res.append(top)    \n        ans += a[top]\n        if b[top] >= 0:\n            a[b[top]] += a[top]\n    if b[top] >= 0:\n        nei = b[top]\n        indeg[nei] -= 1\n        if indeg[nei] == 0:\n            q.append(nei)\n\nfor i in end[::-1]:\n    ans += a[i]\n    if b[i] >= 0:\n        a[b[i]] += a[i]\n    res.append(i)\n\nprint(ans)        \nprint(*[x+1 for x in res])\n"]
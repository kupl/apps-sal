["import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nN = int(input())\nC, Y = [], []\nfor _ in range(N):\n    a, b, c = list(map(int, input().split()))\n    C.append(a)\n    Y.append(c - b)\n\nif sum(Y):\n    print(-1)\n    return\n\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = list(map(int, input().split()))\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nfor i in R[1:]:\n    C[i] = min(C[i], C[P[i]])\n\nans = 0\nfor i in R[1:][::-1]:\n    if Y[i] * Y[P[i]] < 0:\n        ans += C[P[i]] * min(abs(Y[i]), abs(Y[P[i]]))\n    Y[P[i]] += Y[i]\n\nprint(ans * 2)\n", "import sys\ninput = sys.stdin.readline\nn = int(input())\ncbc = [list(map(int,input().split())) for i in range(n)]\nab = [list(map(int,input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n+1)]\nif n == 1:\n  if cbc[0][1] != cbc[0][2]:\n    print(-1)\n  else:\n    print(0)\n  return\ndeg = [0]*(n+1)\nfor a,b in ab:\n  graph[a].append(b)\n  graph[b].append(a)\n  deg[a] += 1\n  deg[b] += 1\ndeg[1] += 1\nstack = [1]\npar = [0]*(n+1)\npar[1] = -1\nleaf = []\nwhile stack:\n  x = stack.pop()\n  if x != 1 and len(graph[x]) == 1:\n    leaf.append(x)\n  for y in graph[x]:\n    if par[y]:\n      continue\n    par[y] = x\n    cbc[y-1][0] = min(cbc[y-1][0],cbc[x-1][0])\n    stack.append(y)\ndp = [[0,0] for i in range(n+1)]\nans = 0\nwhile leaf:\n  x = leaf.pop()\n  p = par[x]\n  if cbc[x-1][1] != cbc[x-1][2]:\n    if cbc[x-1][1] == 1:\n      dp[x][0] += 1\n    else:\n      dp[x][1] += 1\n  if min(dp[x][0],dp[x][1]):\n    if dp[x][0] > dp[x][1]:\n      dp[x][0] -= dp[x][1]\n      ans += cbc[x-1][0]*dp[x][1]*2\n      dp[x][1] = 0\n    else:\n      dp[x][1] -= dp[x][0]\n      ans += cbc[x-1][0]*dp[x][0]*2\n      dp[x][0] = 0\n  dp[p][0] += dp[x][0]\n  dp[p][1] += dp[x][1]\n  deg[p] -= 1\n  if deg[p] == 1:\n    leaf.append(p)\nif dp[1][0] != dp[1][1]:\n  print(-1)\nelse:\n  print(ans)", "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(10000000)\nmod = 1000000007\ndef solve():\n    n = I()\n    a = []\n    b = []\n    c = []\n    for _ in range(n):\n        x,y,z = LI()\n        a.append(x)\n        b.append(y)\n        c.append(z)\n    v = [[] for i in range(n)]\n    for _ in range(n-1):\n        x,y = LI()\n        x -= 1\n        y -= 1\n        v[x].append(y)\n        v[y].append(x)\n    if b.count(1) != c.count(1):\n        print(-1)\n        return\n    q = deque([0])\n    q2 = deque()\n    d = [1]*n\n    d[0] = 0\n    ans = 0\n    p = [[0]*2 for i in range(n)]\n    while q:\n        x = q.popleft()\n        ax = a[x]\n        if b[x] != c[x]:\n            p[x][b[x]] = 1\n        for y in v[x]:\n            if d[y]:\n                d[y] = 0\n                if ax < a[y]:\n                    a[y] = ax\n                q.append(y)\n                q2.append((x,y))\n    while q2:\n        x,y = q2.pop()\n        p[x][0] += p[y][0]\n        p[x][1] += p[y][1]\n        m = min(p[x])\n        ans += m*a[x]\n        p[x][0] -= m\n        p[x][1] -= m\n    print(ans*2)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()"]
["from collections import deque\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\n\ndef bfs(x):\n  q = deque([(0, x, 0)])\n  dist = {x: 0}\n  while q:\n    step, i, par = q.popleft()\n    dist[i] = step\n    for j in graph[i]:\n      if j == par: continue\n      q.append((step + 1, j, i))\n  return [step, i, dist]\n\n_, black, _ = bfs(1)\nmaxdist, white, b_dist = bfs(black)\n_, _, w_dist = bfs(white)\n\nmindls = float(\"-inf\")\nmaxdls = [0] * n\nfor i in range(1, n + 1):\n  if i in (white, black):\n    continue\n  mindls = max(mindls, min(w_dist[i], b_dist[i]))\n  maxdls[max(w_dist[i], b_dist[i])] += 1\nans = pow(2, n - 1, mod) * maxdist % mod\npre = 0\nfor i in range(1, maxdist + 1):\n  if i == maxdist and not maxdls[i]: continue\n  maxdls[i] += maxdls[i - 1]\n  if mindls > i: continue\n  ans += (pow(2, maxdls[i], mod) - pre) * i * 2\n  ans %= mod\n  pre = pow(2, maxdls[i], mod)\nprint(ans)", "\nMOD = 10**9+7\nfrom collections import deque\nN, = list(map(int, input().split()))\nG = [set() for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    G[a].add(b)\n    G[b].add(a)\n\nqueue=deque([1])\nvs = set([1])\ndist = [0] * (N+1)\nmx = 0\nmxv = 1\nwhile queue:\n    v = queue.popleft()\n    for u in G[v]:\n        if u in vs:\n            continue\n        vs.add(u)\n        queue.append(u)\n        dist[u] = dist[v] + 1\n        if mx < dist[u]:\n            mx = dist[u]\n            mxv = u\n\nqueue=deque([mxv])\nvs = set([mxv])\ndist2 = [0] * (N+1)\nmx2 = 0\nmxv2 = 1\nwhile queue:\n    v = queue.popleft()\n    for u in G[v]:\n        if u in vs:\n            continue\n        vs.add(u)\n        queue.append(u)\n        dist2[u] = dist2[v] + 1\n        if mx2 < dist2[u]:\n            mx2 = dist2[u]\n            mxv2 = u\n\nqueue=deque([mxv2])\nvs = set([mxv2])\ndist3 = [0] * (N+1)\nwhile queue:\n    v = queue.popleft()\n    for u in G[v]:\n        if u in vs:\n            continue\n        vs.add(u)\n        queue.append(u)\n        dist3[u] = dist3[v] + 1\n#print(mxv, mxv2)\n#print(dist2)\n#print(dist3)\nr = 0\nfor i in range(1, N+1):\n    x = min(dist2[i], dist3[i])\n    r = max(x, r)\n# \u7d76\u5bfe\u306b\u826f\u3055\u306fr\u4ee5\u4e0a\u306b\u306a\u308b\n#\u3000\u306a\u305c\u306a\u3089x = r\u3068\u306a\u308b\u30ce\u30fc\u30c9\u3092\u3069\u3061\u3089\u306e\u8272\u306b\u5857\u3063\u3066\u3082\u3001\u826f\u3055\u306fr\u306b\u6c7a\u307e\u308b\u304b\u3089...\n\nX = [0]*(N+1)\nfor i in range(1, N+1):\n    y = max(dist2[i], dist3[i])\n    X[y] += 1\n\n#print(r)\nfor i in range(N-1, r-1, -1):\n    X[i] = X[i] + X[i+1]\n\n#print(X)\n# d[i] = d\u304ci\u4ee5\u4e0b\u306b\u306a\u308b\u5834\u5408\u306e\u6570\nX.append(0)\nd = [0]*(N+1)\nfor i in range(N, r-1, -1):\n    x = min(N-X[i+1]+1, N)\n    d[i] = pow(2, x, MOD) \n#print(d)\n\nR = 0\nfor i in range(r, N+1):\n    R = (R + i*(d[i]-d[i-1]))%MOD\nprint(R)\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque\nN = int(input())\nX = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    X[a-1].append(b-1)\n    X[b-1].append(a-1)\n\ndef farthest(i):\n    L = [-1] * N\n    L[i] = 0\n    d = 0\n    post = [i]\n    while len(post) > 0:\n        d += 1\n        pre = post\n        post = []\n        for j in pre:\n            for k in X[j]:\n                if L[k] < 0:\n                    L[k] = d\n                    post.append(k)\n        \n    return (pre[0], d - 1)\n\ns, _ = farthest(0)\nt, d = farthest(s)\n\ndef BFS_dist(n, E, i0=0):\n    Q = deque([i0])\n    D = [-1] * n\n    D[i0] = 0\n    while Q:\n        x = Q.popleft()\n        for c in E[x]:\n            if D[c] == -1:\n                D[c] = D[x] + 1\n                Q.append(c)\n    return D\n\nD1 = BFS_dist(N, X, s)\nD2 = BFS_dist(N, X, t)\n\nY = [0] * (d + 1)\nma = 0\nfor i in range(N):\n    if i == s or i == t: continue\n    a, b = sorted((D1[i], D2[i]))\n    ma = max(ma, a)\n    Y[b] += 1\nY[d] += 1\n\nP = 10 ** 9 + 7\ni2 = P + 1 >> 1\ns = 1\nans = d\nfor i in range(d, ma, -1):\n    if Y[i]: s = pow(i2, Y[i], P) * s % P\n    ans -= s\n    if ans < 0: ans += P\nprint(ans * pow(2, N, P) % P)", "n = int(input())\nab = [list(map(int,input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n+1)]\nfor a,b in ab:\n  graph[a].append(b)\n  graph[b].append(a)\nmod = 10**9+7\nstart = 1\nstack = [1]\ns_dist = [0]+[0]+[10**9]*(n-1)\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if s_dist[y] > s_dist[x]:\n      s_dist[y] = s_dist[x]+1\n      stack.append(y)\nmaxdist = max(s_dist)\nblack = s_dist.index(maxdist)\nb_dist = [10**9]*(n+1)\nb_dist[0] = 0\nb_dist[black] = 0\nstack = [black]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if b_dist[y] > b_dist[x]:\n      b_dist[y] = b_dist[x]+1\n      stack.append(y)\nmaxdist = max(b_dist)\nwhite = b_dist.index(maxdist)\nw_dist = [10**9]*(n+1)\nw_dist[0] = 0\nw_dist[white] = 0\nstack = [white]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if w_dist[y] > w_dist[x]:\n      w_dist[y] = w_dist[x]+1\n      stack.append(y)\nmindls = [0]*n\nmaxdls = [0]*n\nfor i in range(1,n+1):\n  if i in (white,black):\n    continue\n  mindls[min(w_dist[i],b_dist[i])] += 1\n  maxdls[max(w_dist[i],b_dist[i])] += 1\nans = pow(2,n-1,mod)*maxdist%mod\nnumber = 0\nfor i in range(1,maxdist+1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i-1]\n  if i < maxdist and mindls[i+1]:\n    continue\n  ans += (pow(2,maxdls[i],mod)-number)*i*2\n  ans %= mod\n  number = pow(2,maxdls[i],mod)\nprint(ans)", "n = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\nstart = 1\nstack = [1]\ns_dist = [0]+[0]+[10**9]*(n-1)\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if s_dist[y] > s_dist[x] + 1:\n      s_dist[y] = s_dist[x]+1\n      stack.append(y)\nmaxdist = max(s_dist)\nblack = s_dist.index(maxdist)\nb_dist = [10**9]*(n+1)\nb_dist[0] = 0\nb_dist[black] = 0\nstack = [black]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if b_dist[y] > b_dist[x] + 1:\n      b_dist[y] = b_dist[x]+1\n      stack.append(y)\nmaxdist = max(b_dist)\nwhite = b_dist.index(maxdist)\nw_dist = [10**9]*(n+1)\nw_dist[0] = 0\nw_dist[white] = 0\nstack = [white]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if w_dist[y] > w_dist[x] + 1:\n      w_dist[y] = w_dist[x]+1\n      stack.append(y)\nmindls = [0]*n\nmaxdls = [0]*n\nfor i in range(1,n+1):\n  if i in (white,black):\n    continue\n  mindls[min(w_dist[i],b_dist[i])] += 1\n  maxdls[max(w_dist[i],b_dist[i])] += 1\nans = pow(2,n-1,mod)*maxdist%mod\nnumber = 0\nfor i in range(1,maxdist+1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i-1]\n  if i < maxdist and mindls[i+1]:\n    continue\n  ans += (pow(2,maxdls[i],mod)-number)*i*2\n  ans %= mod\n  number = pow(2,maxdls[i],mod)\nprint(ans)", "from collections import deque, defaultdict\n\n\ndef diameter(n, links):\n    q = deque([0])\n    stacked = {0}\n    v = -1\n    while q:\n        v = q.popleft()\n        for u in links[v]:\n            if u not in stacked:\n                q.append(u)\n                stacked.add(u)\n    v1 = v\n    q = deque([(0, v1)])\n    distances1 = [-1] * n\n    distances1[v1] = 0\n    while q:\n        d, v = q.popleft()\n        for u in links[v]:\n            if distances1[u] == -1:\n                q.append((d + 1, u))\n                distances1[u] = d + 1\n    v2 = v\n    q = deque([(0, v2)])\n    distances2 = [-1] * n\n    distances2[v2] = 0\n    while q:\n        d, v = q.popleft()\n        for u in links[v]:\n            if distances2[u] == -1:\n                q.append((d + 1, u))\n                distances2[u] = d + 1\n    return v1, v2, distances1, distances2\n\n\ndef solve(n, links):\n    MOD = 10 ** 9 + 7\n    v1, v2, distances1, distances2 = diameter(n, links)\n\n    ans = distances1[v2] * pow(2, n - 2, MOD) % MOD\n\n    farther = defaultdict(lambda: [0, 0])\n    for i in range(n):\n        if i == v1 or i == v2:\n            continue\n        d1 = distances1[i]\n        d2 = distances2[i]\n        mx = max(d1, d2)\n        mn = min(d1, d2)\n        farther[mx][0] += 1\n        farther[mx][1] = max(farther[mx][1], mn)\n\n    # print(v1, v2)\n    # print(distances1)\n    # print(distances2)\n    # print(farther)\n\n    m = n - 2\n    max_smaller_d = 0\n    for d in sorted(list(farther.keys()), reverse=True):\n        if d <= max_smaller_d:\n            ans = (ans + max_smaller_d * pow(2, m, MOD)) % MOD\n            break\n        cnt, mn = farther[d]\n        m -= cnt\n        ans = (ans + d * (pow(2, cnt, MOD) - 1) * pow(2, m, MOD)) % MOD\n        max_smaller_d = max(max_smaller_d, mn)\n    else:\n        ans = (ans + max_smaller_d * pow(2, m, MOD)) % MOD\n\n    return ans * 2 % MOD\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    links[a].add(b)\n    links[b].add(a)\n\nprint((solve(n, links)))\n", "from collections import deque\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\n\ndef bfs(x):\n  q = deque([(0, x, 0)])\n  while q:\n    step, i, par = q.popleft()\n    for j in graph[i]:\n      if j == par: continue\n      q.append((step + 1, j, i))\n  return [step, i]\n\nmaxdist, black = bfs(1)\n\nb_dist = [10**9]*(n+1)\nb_dist[0] = 0\nb_dist[black] = 0\nstack = [black]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if b_dist[y] > b_dist[x] + 1:\n      b_dist[y] = b_dist[x]+1\n      stack.append(y)\nmaxdist = max(b_dist)\nwhite = b_dist.index(maxdist)\nw_dist = [10**9]*(n+1)\nw_dist[0] = 0\nw_dist[white] = 0\nstack = [white]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if w_dist[y] > w_dist[x] + 1:\n      w_dist[y] = w_dist[x]+1\n      stack.append(y)\nmindls = [0]*n\nmaxdls = [0]*n\nfor i in range(1,n+1):\n  if i in (white,black):\n    continue\n  mindls[min(w_dist[i],b_dist[i])] += 1\n  maxdls[max(w_dist[i],b_dist[i])] += 1\nans = pow(2,n-1,mod)*maxdist%mod\nnumber = 0\nfor i in range(1,maxdist+1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i-1]\n  if i < maxdist and mindls[i+1]:\n    continue\n  ans += (pow(2,maxdls[i],mod)-number)*i*2\n  ans %= mod\n  number = pow(2,maxdls[i],mod)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\nN=int(input())\nE=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n    E[x].append(y)\n    E[y].append(x)\n\nmod=10**9+7\n\ndef dfs(x):\n    DIS=[-1]*N\n    DIS[x]=0\n    Q=[x]\n\n    while Q:\n        x=Q.pop()\n        for to in E[x]:\n            if DIS[to]==-1:\n                DIS[to]=DIS[x]+1\n                Q.append(to)\n    return DIS\n\nD0=dfs(0)\nL=D0.index(max(D0))\nDL=dfs(L)\nR=DL.index(max(DL))\nDR=dfs(R)\n\nMIN=[min(DL[i],DR[i]) for i in range(N)]\nMAX=[max(DL[i],DR[i]) for i in range(N)]\nC=Counter(MIN)\n\nhalf=pow(2,mod-2,mod)%mod\nALL=pow(2,N,mod)\nANS=max(DR)*ALL*half%mod\n\nMAX.sort()\n\ndind=0\nANS=(ANS+max(MIN)*ALL*half)%mod\n\nfor d in range(max(MIN)+1,max(DR)+1):\n    while dind<N and MAX[dind]<d:\n        dind+=1\n    ANS=(ANS+2*(ALL*half*half-pow(2,dind,mod)))%mod\n\nprint(ANS)", "from collections import deque\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\n\ndef bfs(x):\n  q = deque([(0, x, 0)])\n  dist = {x: 0}\n  while q:\n    step, i, par = q.popleft()\n    dist[i] = step\n    for j in graph[i]:\n      if j == par: continue\n      q.append((step + 1, j, i))\n  return [step, i, dist]\n\n_, black, _ = bfs(1)\nmaxdist, white, b_dist = bfs(black)\n_, _, w_dist = bfs(white)\n\nmindls = [0] * n\nmaxdls = [0] * n\nfor i in range(1, n + 1):\n  if i in (white, black):\n    continue\n  mindls[min(w_dist[i], b_dist[i])] += 1\n  maxdls[max(w_dist[i], b_dist[i])] += 1\nans = pow(2, n - 1, mod) * maxdist % mod\npre = 0\nfor i in range(1, maxdist + 1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i - 1]\n  if i < maxdist and mindls[i + 1]:\n    continue\n  ans += (pow(2, maxdls[i], mod) - pre) * i * 2\n  ans %= mod\n  pre = pow(2, maxdls[i], mod)\nprint(ans)", "n = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\nstart = 1\nstack = [1]\ns_dist = [0]+[0]+[10**9]*(n-1)\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if s_dist[y] >= s_dist[x]:\n      s_dist[y] = s_dist[x]+1\n      stack.append(y)\nmaxdist = max(s_dist)\nblack = s_dist.index(maxdist)\nb_dist = [10**9]*(n+1)\nb_dist[0] = 0\nb_dist[black] = 0\nstack = [black]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if b_dist[y] >= b_dist[x]:\n      b_dist[y] = b_dist[x]+1\n      stack.append(y)\nmaxdist = max(b_dist)\nwhite = b_dist.index(maxdist)\nw_dist = [10**9]*(n+1)\nw_dist[0] = 0\nw_dist[white] = 0\nstack = [white]\nwhile stack:\n  x = stack.pop()\n  for y in graph[x]:\n    if w_dist[y] >= w_dist[x]:\n      w_dist[y] = w_dist[x]+1\n      stack.append(y)\nmindls = [0]*n\nmaxdls = [0]*n\nfor i in range(1,n+1):\n  if i in (white,black):\n    continue\n  mindls[min(w_dist[i],b_dist[i])] += 1\n  maxdls[max(w_dist[i],b_dist[i])] += 1\nans = pow(2,n-1,mod)*maxdist%mod\nnumber = 0\nfor i in range(1,maxdist+1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i-1]\n  if i < maxdist and mindls[i+1]:\n    continue\n  ans += (pow(2,maxdls[i],mod)-number)*i*2\n  ans %= mod\n  number = pow(2,maxdls[i],mod)\nprint(ans)", "from collections import deque\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\n\ndef bfs(x):\n  q = deque([(0, x, 0)])\n  dist = {x: 0}\n  while q:\n    step, i, par = q.popleft()\n    dist[i] = step\n    for j in graph[i]:\n      if j == par: continue\n      q.append((step + 1, j, i))\n  return [step, i, dist]\n\n_, black, _ = bfs(1)\nmaxdist, white, b_dist = bfs(black)\n_, _, w_dist = bfs(white)\n\nmindls = float(\"-inf\")\nmaxdls = [0] * n\nfor i in range(1, n + 1):\n  if i in (white, black):\n    continue\n  mindls = max(mindls, min(w_dist[i], b_dist[i]))\n  maxdls[max(w_dist[i], b_dist[i])] += 1\nans = pow(2, n - 1, mod) * maxdist % mod\npre = 0\nfor i in range(1, maxdist + 1):\n  if i == maxdist and maxdls[i] == 0:\n    continue\n  maxdls[i] += maxdls[i - 1]\n  if mindls > i:\n    continue\n  ans += (pow(2, maxdls[i], mod) - pre) * i * 2\n  ans %= mod\n  pre = pow(2, maxdls[i], mod)\nprint(ans)", "N=int(input())\nE=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n    E[x].append(y)\n    E[y].append(x)\n\nmod=10**9+7\n\ndef dfs(x):\n    DIS=[-1]*N\n    DIS[x]=0\n    Q=[x]\n\n    while Q:\n        x=Q.pop()\n        for to in E[x]:\n            if DIS[to]==-1:\n                DIS[to]=DIS[x]+1\n                Q.append(to)\n    return DIS\n\nD0=dfs(0)\nL=D0.index(max(D0))\nDL=dfs(L)\nR=DL.index(max(DL))\nDR=dfs(R)\n\nMIN=[min(DL[i],DR[i]) for i in range(N)]\nMAX=[max(DL[i],DR[i]) for i in range(N)]\n\nhalf=pow(2,mod-2,mod)%mod\nALL=pow(2,N-1,mod)\nANS=max(DR)*ALL%mod\n\nMAX.sort()\n\ndind=0\nANS=(ANS+max(MIN)*ALL)%mod\n\nfor d in range(max(MIN)+1,max(DR)+1):\n    while dind<N and MAX[dind]<d:\n        dind+=1\n    ANS=(ANS+2*(ALL*half-pow(2,dind,mod)))%mod\n\nprint(ANS)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\nN=int(input())\nE=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n    E[x].append(y)\n    E[y].append(x)\n\nmod=10**9+7\n\ndef dfs(x):\n    DIS=[-1]*N\n    DIS[x]=0\n    Q=[x]\n\n    while Q:\n        x=Q.pop()\n        for to in E[x]:\n            if DIS[to]==-1:\n                DIS[to]=DIS[x]+1\n                Q.append(to)\n    return DIS\n\nD0=dfs(0)\nL=D0.index(max(D0))\nDL=dfs(L)\nR=DL.index(max(DL))\nDR=dfs(R)\n\nMIN=[min(DL[i],DR[i]) for i in range(N)]\nMAX=[max(DL[i],DR[i]) for i in range(N)]\nC=Counter(MIN)\n\nhalf=pow(2,mod-2,mod)%mod\nALL=pow(2,N,mod)\nANS=max(DR)*ALL*half%mod\n\nMAX.sort()\n\ndind=0\nANS=(ANS+max(MIN)*ALL*half)%mod\n\nfor d in range(max(MIN)+1,max(DR)+1):\n    while dind<N and MAX[dind]<d:\n        dind+=1\n    ANS=(ANS+2*(ALL*half*half-pow(2,dind,mod)))%mod\n\nprint(ANS)", "\n\"\"\"\n\n\u7b54\u3048\u304cX\u672a\u6e80\u306b\u306a\u308b\u5834\u5408\u306e\u6570\u304c\u308f\u304b\u308c\u3070\u304ak\n\u2192\u8ddd\u96e2\u304cX\u4ee5\u4e0a\u3068\u306a\u308b\u3059\u3079\u3066\u306e\u70b9\u5bfe\u9593\u306b\u304a\u3044\u3066\u9055\u3046\u8272\u3067\u5857\u3089\u308c\u3066\u3044\u308b\n\n\u76f4\u5f84\u3092\u8003\u3048\u3066\u307f\u308b\n\u7aef\u70b9\u3092\u767d\u3068\u3059\u308b\u3068\u304b\u3089X\u4ee5\u4e0a\u306e\u8ddd\u96e2\u306f\u5168\u3066\u9ed2\n\u3082\u3046\u7247\u65b9\u306e\u7aef\u70b9\u304b\u3089X\u4ee5\u4e0a\u306e\u8ddd\u96e2\u306f\u5168\u3066\u767d\u306b\u306c\u308b\n\u5f53\u7136\u304b\u3076\u3063\u305f\u3089out\n\n\u304b\u3076\u3089\u306a\u304b\u3063\u305f\u3089ok?\n\u4eee\u5b9a\u3059\u308b\n\n\u5b9f\u88c5\u306f\n\u5404X\u306b\u95a2\u3057\u3066\u3001\u4e21\u65b9\u304b\u3089X\u4ee5\u5185\u306e\u9802\u70b9\u306e\u6570\u3092\u6570\u3048\u4e0a\u3052\u308b\n\n\"\"\"\n\nimport sys\nfrom sys import stdin\n\n#\u91cd\u307f\u306e\u306a\u3044\u30b0\u30e9\u30d5\u3067\u306e\u6700\u77ed\u7d4c\u8def\u554f\u984c\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u3068\u59cb\u70b9\u3092\u4e0e\u3048\u308b\u3068\u59cb\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u306e\u30ea\u30b9\u30c8 & \u89aa\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n\n    return ret,plis\n\nmod = 10**9+7\n\nN = int(stdin.readline())\n\nlis = [ [] for i in range(N) ]\n\nfor i in range(N-1):\n    a,b = list(map(int,stdin.readline().split()))\n    a -= 1\n    b -= 1\n    lis[a].append(b)\n    lis[b].append(a)\n\nD0,tmp = NC_Dij(lis,0)\np1 = 0\nfor i in range(N):\n    if D0[i] > D0[p1]:\n        p1 = i\n\nD1,tmp = NC_Dij(lis,p1)\np2 = p1\nfor i in range(N):\n    if D1[i] > D1[p2]:\n        p2 = i\n\nD2,tmp = NC_Dij(lis,p2)\n\nDL1 = []\nfor i in range(N):\n    DL1.append( (D1[i],i) )\nDL2 = []\nfor i in range(N):\n    DL2.append( (D2[i],i) )\n\nDL1.sort()\nDL1.reverse()\nDL2.sort()\nDL2.reverse()\n\n\nanslis = [0] * N\nvisit = [0] * N\ntwo  = 0\nzero = N\nfor X in range(N):\n\n    while len(DL1) > 0 and DL1[-1][0] == X:\n        tmp,v = DL1[-1]\n        del DL1[-1]\n\n        if visit[v] == 0:\n            zero -= 1\n        elif visit[v] == 1:\n            two += 1\n        visit[v] += 1\n\n    while len(DL2) > 0 and DL2[-1][0] == X:\n        tmp,v = DL2[-1]\n        del DL2[-1]\n\n        if visit[v] == 0:\n            zero -= 1\n        elif visit[v] == 1:\n            two += 1\n        visit[v] += 1\n\n    if two == N:\n        anslis[X] = pow(2,N,mod)\n    elif zero == 0:\n        anslis[X] = 2 * pow(2,two,mod)\n\nans = 0\nfor i in range(1,N):\n    ans += (anslis[i]-anslis[i-1]) * i\nprint((ans % mod))\n"]
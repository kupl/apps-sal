["#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, M= getIntList()\n\nne = [0 for i in range(N+1) ]\nza = getIntList()\nfor i in range(N-1):\n    ne[ za[i]] = za[i+1]\nne[za[-1]] = 0\n\nfor _ in range(1, M):\n    za = getIntList()\n    for i in range(N-1):\n        a = za[i]\n        b = za[i+1]\n        if ne[a] != b:\n            ne[a] = -1\n    a = za[-1]\n    if ne[a]!=0:\n        ne[a] = -1\n\ntin = [0 for i in range(N+1) ]\n\nfor i in range(1,N+1):\n    a = ne[i]\n    if a>0:\n        tin[a] = 1\n\nres = 0\nfor i in range(1,N+1):\n    if tin[i]: continue\n    n = 0\n    while i>0:\n        n+=1\n        i = ne[i]\n    res += n * (n+1) //2\n\nprint(res)\n\n\n\n\n\n", "# -*- coding: utf-8 -*-\n\"\"\"\ncreated by shhuan at 2018/10/20 22:37\n\n\"\"\"\n\n\"\"\"\n# Definition for a Node.\n\"\"\"\n\n\n\nN, M = list(map(int, input().split()))\n\nA = []\nloc = [{} for _ in range(M)]\nfor i in range(M):\n    a = [int(x) for x in input().split()]\n    A.append(a)\n    for iv, v in enumerate(a):\n        loc[i][v] = iv\n\nans = 0\nls = [0] * M\ni = 0\nwhile i < N:\n    v = A[0][i]\n    ls = [loc[j][v] for j in range(M)]\n    segl = 1\n\n    while all([l+segl < N for l in ls]) and all(A[il][l+segl] == A[0][ls[0]+segl] for il, l in enumerate(ls)):\n        segl += 1\n    ans += segl * (segl + 1) // 2\n    i += segl\n\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,sys.stdin.readline().split()))\n\nA=[list(map(int,sys.stdin.readline().split())) for i in range(m)]\n\nLISTS=[[None for i in range(n+1)] for i in range(m)]\n\nfor i in range(n):\n    for j in range(m):\n        LISTS[j][A[j][i]]=i\n\nANS=0\ni=0\nwhile i<n:\n    x=A[0][i]\n\n    check=1\n    #print(ANS,i)\n    for j in range(i+1,n+1):\n        for k in range(1,m):\n            if LISTS[k][x]+(j-i)<n and j<n and A[k][LISTS[k][x]+(j-i)]==A[0][j]:\n                continue\n            else:\n                check=0\n                break\n\n        if check==0:\n            break\n\n    ANS+=(j-i)*(j-i+1)//2\n    i=j\n    \n\n    \nprint(ANS)\n", "from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ndp=[[-1 for i in range(n+1)] for j in range(m+1)]\nfor i in range(m):\n    s=list(map(int,stdin.readline().strip().split()))\n    for j in range(n-2,-1,-1):\n        dp[i][s[j]]=s[j+1]\n        \ndp1=[1 for i in range(n)]\nfor i in range(n-2,-1,-1):\n    t=True\n    for j in range(m):\n        if dp[j][s[i]]!=s[i+1]:\n            t=False\n    if t:\n        dp1[i]=dp1[i]+dp1[i+1]\nprint(sum(dp1))\n            \n", "def intersection(a, b):\n    ret = (max(a[0], b[0]), min(a[1], b[1]))\n    if ret[0] >= ret[1]:\n        return (-1, -1)\n    return ret\n\n\ndef calc(n, m, interval):\n    ret = 0\n    it_list = [(0, n-1)]\n    for i in range(m):\n        interval_now = interval[i]\n        # print(it_list, interval_now)\n\n        if len(interval_now) == 0:\n            return 0\n        next_list = []\n        # calc\n        j = 0\n        k = 0\n        while j < len(it_list) and k < len(interval_now):\n            n1 = it_list[j]\n            n2 = interval_now[k]\n            inter = intersection(n1, n2)\n            if inter[0] == -1:\n                if n1[0] < n2[0]:\n                    j += 1\n                else:\n                    k += 1\n                continue\n            next_list.append(inter)\n            if n1[1] < n2[1]:\n                j += 1\n            else:\n                k += 1\n        it_list = next_list\n        if len(it_list) == 0:\n            return 0\n    # print(it_list)\n    for it in it_list:\n        l = it[1] - it[0] + 1\n        ret += l*(l+1)//2 - l\n    return ret\n\n\ndef main():\n    n, m = [int(x) for x in input().split(\" \")]\n    a = []\n    for i in range(m):\n        now = list([int(x) for x in input().split(\" \")])\n        a.append(now)\n    ans = n\n    if m == 1:\n        print(n*(n+1)//2)\n        return\n    ch = [0 for i in range(n)]\n    for i in range(n):\n        ch[a[0][i]-1] = i\n    for i in range(m):\n        for j in range(n):\n            a[i][j] = ch[a[i][j]-1]\n    interval = []\n    for i in range(m):\n        a_now = a[i]\n        l = 0\n        r = 0\n        now = []\n        for j in range(1, n):\n            if a_now[j] == a_now[j-1]+1:\n                r += 1\n            else:\n                if r > l:\n                    it = (a_now[l], a_now[r])\n                    # print(l, r, it)\n                    now.append(it)\n                l = j\n                r = j\n        if r > l:\n            it = (a_now[l], a_now[r])\n            # print(\"end\", l, r, it)\n            now.append(it)\n        now = sorted(now, key=lambda x: x[0])\n        # print(a_now, now, \"\\n\")\n        interval.append(now)\n    ans += calc(n, m, interval)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    arrs = []\n    for _ in range(M):\n        arrs.append([int(x)-1 for x in input().split()])\n    print(solve(N, M, arrs))\n\ndef solve(N, M, arrs):\n  next_arr = [None] * N\n  arr = arrs[0]\n  for r, nr in zip(arr, arr[1:]):\n      next_arr[r] = nr\n  # print(next_arr)\n  for i in range(1, M):\n      read = arrs[i]\n      next_arr_new = [None]*N\n      for r, nr in zip(read, read[1:]):\n          # print(\"zipping \", r, nr)\n          next_arr_new[r] = nr\n      for r, nr in enumerate(next_arr_new):\n          if next_arr[r] != nr:\n              next_arr[r] = None\n              # print(\"fail\", r, nr)\n  # print(next_arr)\n\n  starts = []\n  cycs = []\n  curr = 0\n  for r in arr:\n      if next_arr[r] != None:\n          if curr == 0:\n              starts.append(r)\n          curr += 1\n      elif curr > 0:\n          cycs.append(curr)\n          curr = 0\n  if curr > 0:\n      cycs.append(curr)\n\n  assert len(starts) == len(cycs)\n  # for s, c in zip(starts, cycs):\n  #     print(\"start \", s, \"cyc\", c)\n\n  s = 0\n  for c in cycs:\n      s += c*(c+1) // 2\n  s += N\n\n  # print(s)\n  return s\n\nsolve(3, 2, [[0, 1, 2], [0, 1, 2]])\n\ndef solve_naive(r1, r2):\n    count = 0\n    for i in range(len(r1)):\n        for j in range(i+1, len(r1)+1):\n            for ii in range(len(r2)):\n                l = j-i\n                if r1[i:j] == r2[ii:ii+l]:\n                    count += 1\n    return count\n\ndef test(N):\n    from random import shuffle\n    for i in range(1000):\n      r1 = list(range(N))\n      r2 = list(range(N))\n      shuffle(r1)\n      shuffle(r2)\n      res = solve(N, 2, [r1, r2])\n      res2 = solve_naive(r1, r2)\n      if res != res2:\n          print(r1, r2)\n          print(res, res2)\n          assert res == res2\n\nmain()\n", "def intersect(seqOne, seqTwo):\n\tseqOne = sorted(seqOne, key=lambda x: x[0])\n\tseqTwo = sorted(seqTwo, key=lambda x: x[0])\n\ti = 0\n\tj = 0\n\tans = []\n\twhile i < len(seqOne) and j < len(seqTwo):\n\t\ta,b = seqOne[i]\n\t\tc,d = seqTwo[j]\n\t\tif max(a,c) < min(b,d):\n\t\t\tans.append( (max(a,c), min(b,d)) )\n\t\tif b < d:\n\t\t\ti += 1\n\t\telse:\n\t\t\tj += 1\n\treturn ans\n\ndef main():\n\tn,m = map(int, input().strip().split())\n\torders = []\n\tfor i in range(m):\n\t\torders.append([int(x) for x in input().strip().split()])\n\t\n\tind = [0] * (n+1)\n\tfor i in range(1,n+1):\n\t\tind[orders[0][i-1]] = i\n\n\tsubseqs = [(1,n)]\n\tfor i in range(1,m):\n\t\torder = list(map(lambda x: ind[x], orders[i]))\n\t\ti = 0\n\t\tcurrSubseqs = []\n\t\tfor j in range(1,n):\n\t\t\tif order[j] == order[j-1] + 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tif j - i > 1:\n\t\t\t\t\tcurrSubseqs.append( (order[i], order[j-1]) )\n\t\t\t\ti = j\n\t\tif i != n-1:\n\t\t\tcurrSubseqs.append( (order[i], order[j]) )\n\n\t\tsubseqs = intersect(subseqs, currSubseqs)\n\t\tif len(subseqs) == 0:\n\t\t\tbreak\n\n\tans = n\n\tfor subseq in subseqs:\n\t\tx,y = subseq\n\t\tm = (y - x + 1)\n\t\tans += m * (m + 1) // 2 - m\n\n\tprint(ans)\t\n\t\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "#!/usr/bin/env python3\n# encoding: utf-8\n\n\n\n#----------\n# Constants\n#----------\n\n\n\n#----------\n# Functions\n#----------\n\ndef summarize(val):\n    return (val + 1) * val // 2\n\n\n# The function that solves the task\ndef calc(data):\n    m = len(data)\n    n = len(data[0])\n\n    reflections = []\n    for i in range(m):\n        reflections.append(dict())\n        r = reflections[-1]\n        for j in range(n):\n            r[data[i][j]] = j\n\n    lengths = []\n    index = 0\n    while index < n:\n        val = data[0][index]\n        ln = 1\n        indexes = [ reflections[i][val] for i in range(1, m) ]\n        for k in range(index+1, n):\n            d = k - index\n            equal = True\n            val = data[0][k]\n            for i in range(1, m):\n                if indexes[i-1] + d >= n or data[i][indexes[i-1] + d] != val:\n                    equal = False\n                    break\n            if equal:\n                ln += 1\n            else:\n                break\n        lengths.append(summarize(ln))\n        index += ln\n\n    return sum(lengths)\n\n\n# Reads a string from stdin, splits it by space chars, converts each\n# substring to int, adds it to a list and returns the list as a result.\ndef get_ints():\n    return [ int(n) for n in input().split() ]\n\n\n# Reads a string from stdin, splits it by space chars, converts each substring\n# to floating point number, adds it to a list and returns the list as a result.\ndef get_floats():\n    return [ float(n) for n in input().split() ]\n\n\ndef seq2str(seq):\n    return ' '.join(str(item) for item in seq)\n\n\n#----------\n# Execution start point\n#----------\n\ndef __starting_point():\n    a = get_ints()\n    assert len(a) == 2\n    n, m = a[0], a[1]\n\n    data = []\n    for i in range(m):\n        a = get_ints()\n        assert len(a) == n\n        data.append(a)\n\n    res = calc(data)\n    print(res)\n\n__starting_point()", "n,m = map(int,input().split())\ninitial = []\nfirst = input().split()\nfor i in range(n):\n    initial.append(int(first[i]))\nrest = []\nfor i in range(m-1):\n    current = []\n    nfirst = input().split()\n    for j in range(n):\n        current.append(int(nfirst[j]))\n    rest.append(current)\nindex = 0\ncompar = 0\nans = 0\nindices = []\nfor i in range(m-1):\n    temp = [0]*n\n    x = rest[i]\n    for j in range(n):\n        temp[x[j]-1] = j\n    indices.append(temp)\nwhile index < n:\n    compar = initial[index]\n    cur = [0]*(m-1)\n    count = 1\n    lol = n-index\n    for k in range(m-1):\n        cur[k] = indices[k][compar-1]\n        lol = min(lol,n-cur[k])\n    done = False\n    while count < lol:\n        for k in range(m-1):\n            x = rest[k]\n            j = cur[k]\n            if x[j+count] != initial[index+count]:\n                done = True\n                break\n        if done:\n            break\n        count += 1\n    ans += (count*(count+1))//2\n    index += count\nprint(ans)", "n,m = list(map(int,input().split()))\ninitial = []\nfirst = input().split()\nfor i in range(n):\n    initial.append(int(first[i]))\nrest = []\nfor i in range(m-1):\n    current = []\n    nfirst = input().split()\n    for j in range(n):\n        current.append(int(nfirst[j]))\n    rest.append(current)\nindex = 0\ncompar = 0\nans = 0\nindices = []\nfor i in range(m-1):\n    temp = [0]*n\n    x = rest[i]\n    for j in range(n):\n        temp[x[j]-1] = j\n    indices.append(temp)\nwhile index < n:\n    compar = initial[index]\n    cur = [0]*(m-1)\n    count = 1\n    lol = n-index\n    for k in range(m-1):\n        cur[k] = indices[k][compar-1]\n        lol = min(lol,n-cur[k])\n    done = False\n    while count < lol:\n        for k in range(m-1):\n            x = rest[k]\n            j = cur[k]\n            if x[j+count] != initial[index+count]:\n                done = True\n                break\n        if done:\n            break\n        count += 1\n    ans += (count*(count+1))//2\n    index += count\nprint(ans)\n                   \n", "from collections import defaultdict\nfrom collections import deque\n\n(n, m) = [int(x) for x in input().split()]\nmessages = []\nfor i in range(m):\n    temp = [int(x) for x in input().split()]\n    messages.append(temp)\n\n\nseq = defaultdict(lambda: 0)\npairs = {}\nfor k in range(n - 1):\n    pairs[messages[0][k]] = messages[0][k + 1]\n\n\nfor i in range(1, m):\n    for k in range(n-1):\n        temp = messages[i][k]\n        if pairs.get(temp, None) != messages[i][k+1]:\n            pairs.pop(temp, None)\n    pairs.pop(messages[i][n-1], None)\n\n\n\nsequences = []\nstarts = set(pairs.keys())\nends = set(pairs.values())\nconn = starts & ends\n\nfor key, value in list(pairs.items()):\n\n    if key in conn:\n        continue\n    val = value\n    temp = []\n    temp.append(key)\n    temp.append(value)\n    while val in starts:\n        val = pairs[val]\n        temp.append(val)\n\n    sequences.append(temp)\n\n\n# print(sequences)\n\n\nvariants = n\n\nfor seq in sequences:\n    l = len(seq)\n    variants+=l*(l-1)//2\n\nprint(variants)\n\n\n\n\n", "n,m=list(map(int,input().split()))\narr=[]\narr1=[]\nfor i in range(m):\n    arrx=list(map(int,input().split()))\n    arry=[0]*n\n    for j in range(n):\n        arry[arrx[j]-1]=j+1\n    arr.append(arrx)\n    arr1.append(arry)\n\nans=n\ni=0\nj=1\nflag=0\nwhile(i<n-1 and j<n):\n    k1=arr[0][i]\n    k2=arr[0][j]\n    l=0\n    while(l<m):\n        #print(arr[0][i+k]-1,arr[0][i+k+1]-1,'YO',flag,l)\n        if(arr1[l][arr[0][j-1]-1]!=arr1[l][arr[0][j]-1]-1):\n            flag=1\n            break\n        #print(flag)\n        if(flag==1):\n            break\n        l+=1\n    if(flag==1):\n        ans+=((j-i)*(j-i+1))//2\n        ans-=j-i\n        i=j\n        j+=1\n        flag=0\n    else:\n        j+=1\n    #print(i,j)\nif(flag==0):\n    ans+=((j-i)*(j-i+1))//2\n    ans-=j-i\nprint(ans)\n", "def main():\n    n, m = [int(c) for c in input().split()]\n    if m == 1:\n        print(n * (n + 1) // 2)\n        return\n    \n    testimonies = [[int(c) for c in input().split()] for _ in range(m)]\n    perm_map = {client: i for i, client in enumerate(testimonies[0])}\n    testimonies = [[perm_map[client] for client in testimonies[i]] for i in range(m)]\n\n    counters = []\n    for t in testimonies:\n        seq_map = [0] * n\n        start, i = 0, 1\n        seq_map[t[start]] = 1\n        while i < len(t):\n            if t[i] - t[i - 1] == 1:\n                seq_map[t[start]] += 1\n            else:\n                for k, j in enumerate(list(range(start+1, i)), 1):\n                    seq_map[t[j]] = seq_map[t[start]] - k\n                start = i\n                seq_map[t[start]] = 1\n            i += 1\n\n        for k, j in enumerate(list(range(start+1, i)), 1):\n            seq_map[t[j]] = seq_map[t[start]] - k\n        \n        counters.append(seq_map)\n\n    \n\n    ans = 0\n    for i in range(n):\n        _min = min([cnt[i] for cnt in counters])\n        ans += _min\n\n    # ans = sum([min([cnt[i] for cnt in counters]) for i in range(n)])\n    print(ans)\n        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = [int(c) for c in input().split()]\n    if m == 1:\n        print(n * (n + 1) // 2)\n        return\n    \n    testimonies = [[int(c) for c in input().split()] for _ in range(m)]\n    perm_map = {client: i for i, client in enumerate(testimonies[0])}\n    testimonies = [[perm_map[client] for client in testimonies[i]] for i in range(m)]\n\n    counters = []\n    for t in testimonies:\n        seq_map = [0] * n\n        start, i = 0, 1\n        seq_map[t[start]] = 1\n        while i < len(t):\n            if t[i] - t[i - 1] == 1:\n                seq_map[t[start]] += 1\n            else:\n                cnt = seq_map[t[start]]\n                for j in range(start+1, i):\n                    cnt -= 1\n                    seq_map[t[j]] = cnt\n                    \n                start = i\n                seq_map[t[start]] = 1\n            i += 1\n\n        cnt = seq_map[t[start]]\n        for j in range(start+1, i):\n            cnt -= 1\n            seq_map[t[j]] = cnt\n            \n        counters.append(seq_map)\n\n    ans = sum([min([cnt[i] for cnt in counters]) for i in range(n)])\n    print(ans)\n        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = [int(c) for c in input().split()]\n    if m == 1:\n        print(n * (n + 1) // 2)\n        return\n    \n    testimonies = [[int(c) for c in input().split()] for _ in range(m)]\n    perm_map = {client: i for i, client in enumerate(testimonies[0])}\n    testimonies = [[perm_map[client] for client in testimonies[i]] for i in range(1, m)]\n\n    counters = []\n    for t in testimonies:\n        seq_map = [0] * n\n        start, i = 0, 1\n        seq_map[t[start]] = 1\n        while i < len(t):\n            if t[i] - t[i - 1] == 1:\n                seq_map[t[start]] += 1\n            else:\n                cnt = seq_map[t[start]]\n                for j in range(start+1, i):\n                    cnt -= 1\n                    seq_map[t[j]] = cnt\n                    \n                start = i\n                seq_map[t[start]] = 1\n            i += 1\n\n        cnt = seq_map[t[start]]\n        for j in range(start+1, i):\n            cnt -= 1\n            seq_map[t[j]] = cnt\n            \n        counters.append(seq_map)\n\n    ans = sum([min([cnt[i] for cnt in counters]) for i in range(n)])\n    print(ans)\n        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\na = []\nfor i in range(m):\n  a.append(list(map(int, input().split())))\nb = [set([]) for i in range(n)]\nfor i in range(n):\n  for j in range(m):\n    ya = a[j][i]\n    if i == n-1:\n      b[ya-1].add(100000000)\n    else:\n      b[ya-1].add(a[j][i+1])\nclass UnionFind():\n    def __init__(self,size):\n        self.table = [-1 for _  in range(size)]\n\n    def find(self,x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n\n    def union(self,x,y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] != self.table[s2]:\n                if self.table[s1] < self.table[s2]:\n                    self.table[s2] = s1\n                else:\n                    self.table[s1] = s2\n            else:\n                self.table[s1] += -1\n                self.table[s2] = s1\n        return\nUN = UnionFind(n)\nfor i in range(n):\n  if len(b[i]) == 1 and list(b[i])[0] !=100000000:\n    UN.union(i,list(b[i])[0]-1)\nd = [0]*n\nfor i in range(n):\n  d[UN.find(i)] += 1\nans = 0\nfor i in range(n):\n  ans += (d[i]-1)*(d[i])//2\nprint(ans+n)", "def get_sub_array(array):\n    d = {}\n    st = 0\n    en = 0\n    while st < len(array) and en < len(array):\n        if en < (len(array)-1) and array[en+1] == array[en]+1:\n            en += 1\n        else:\n            d[array[st]] = en-st+1\n            st += 1\n            en = st if en < st else en\n    return d\nn, m = [int(x) for x in input().split()]\narray = []\nfor i in range(m):\n    array.append([int(x) for x in input().split()])\nd = dict()\nfor i in range(1, n + 1):\n    d[array[0][i-1]] = i\nfor i in range(m):\n    for j in range(n):\n        array[i][j] = d[array[i][j]]\nres = [float(\"inf\") for i in range(n)]\ndm = []\nfor i in range(m):\n    dm.append(get_sub_array(array[i]))\nfor i in range(1, n+1):\n    for j in range(m):\n        res[i-1] = min(res[i-1], dm[j][i])\nprint(sum(res))\n\n", "n, m = list(map(int, input().split()))\n\ngraph = [0] * n\n_next = [True] * n\n_next[n - 1] = False\n\ndef read_array():\n    return list([x - 1 for x in list(map(int, input().split()))])\n\n\nfirst = read_array()\nfor i in range(n):\n    graph[first[i]] = i\n\nfor cnt in range(1, m):\n    a = read_array()\n    for i in range(n - 1):\n        if graph[a[i]] + 1 != graph[a[i + 1]]:\n            _next[graph[a[i]]] = False\n    _next[graph[a[n - 1]]] = False\n\nl = 0\nans = 0\nfor cnt in range(n):\n    l += 1\n    if not _next[cnt]:\n        ans += (l * (l + 1)) // 2\n        l = 0\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\ngraph = [0] * n\n_next = [True] * n\n_next[n - 1] = False\n\ndef read_array():\n    return list([x - 1 for x in list(map(int, input().split()))])\n\n\nfirst = read_array()\nfor i in range(n):\n    graph[first[i]] = i\n\nfor cnt in range(1, m):\n    a = read_array()\n    for i in range(n - 1):\n        if graph[a[i]] + 1 != graph[a[i + 1]]:\n            _next[graph[a[i]]] = False\n    _next[graph[a[n - 1]]] = False\n\nl = 0\nans = 0\nfor cnt in range(n):\n    l += 1\n    if not _next[cnt]:\n        ans += (l * (l + 1)) // 2\n        l = 0\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\ngraph = [0] * n\n_next = [True] * n\n_next[n - 1] = False\n\ndef read_array():\n    return list([x - 1 for x in list(map(int, input().split()))])\n\n\nfirst = read_array()\niterable1 = list(range(n))\niterable2 = list(range(n - 1))\nfor i in iterable1:\n    graph[first[i]] = i\n\nfor cnt in range(1, m):\n    a = read_array()\n    for i in range(n - 1):\n        if graph[a[i]] + 1 != graph[a[i + 1]]:\n            _next[graph[a[i]]] = False\n    _next[graph[a[n - 1]]] = False\n\nl = 0\nans = 0\nfor cnt in iterable1:\n    l += 1\n    if not _next[cnt]:\n        ans += (l * (l + 1)) // 2\n        l = 0\n\nprint(ans)\n", "I=lambda:list(map(int,input().split()))\nn,m=I()\na=[[]]*10\nindexwaliarray=[[0 for i in range(n)]for _ in range(m)]\n#print(indexwaliarray)\nfor i in range(m):\n    a[i]=list(I())\nfor i in range(m):\n    for j in range(n):\n        indexwaliarray[i][a[i][j]-1]=j\nanswaliarray=[[a[0][i]-1,a[0][i+1]-1 ] for i in range(n-1)]\n#print(answaliarray)\nfor i in range(n-1):\n    for j in range(1,m):\n        if indexwaliarray[j][answaliarray[i][1]]!=indexwaliarray[j][answaliarray[i][0]]+1:\n            answaliarray[i]=[-1,-1]\n#print(answaliarray)\ncount=[]\nc=0\nfor i in range(n-1):\n    if answaliarray[i]==[-1,-1]:\n        if c!=0:\n            count.append(c)\n            c=0\n    else :\n        c+=1\n        \nif c!=0:\n    count.append(c)\n#print(count)                        \nyepakkaanshai=0\nfor i in count:\n    yepakkaanshai+=((i+1)*i)//2\nprint(yepakkaanshai+n)    \n\n", "n, m = list(map(int, input().split()))\n\ngraph = [0] * n\n_next = [True] * n\n_next[-1] = False\n\ndef read_array():\n\treturn list([x-1 for x in list(map(int, input().split()))])\n\nfirst = read_array()\n\n\nfor i in range(n):\n\tgraph[first[i]] = i\n\nfor _ in range(1, m):\n\ta = read_array()\n\tfor i in range(n - 1):\n\n\n\t\tif graph[a[i]] + 1 != graph[a[i+1]]:\n\t\t\t_next[graph[a[i]]] = False\n\t_next[graph[a[n-1]]] = False\n\nl = 0\nans = 0\nfor _ in range(n):\n\tl += 1\n\tif not _next[_]:\n\t\tans += (l * (l + 1)) // 2\n\t\tl = 0\n\nprint (ans)\n\n", "n, m = [int(i) for i in input().split(' ')]\n\nimport sys\n\nfconnection = [None] * n\nbconnection = [None] * n\n\nif m == 1:\n    print(int((n+1)*n/2))\n    return\n\nsvidetel = input().split(' ')\np = int(svidetel[0])-1\nfor current_pok in svidetel[1:]:\n    q = int(current_pok)-1\n    fconnection[p] = q\n    bconnection[q] = p\n    p = q\n\n\nfor i in range(m-1):\n    svidetel = input().split(' ')\n    p = int(svidetel[0])-1\n#    try:\n#        fconnection[fconnection.index(p)] = None\n#    except ValueError:\n#        pass\n    bconnection[p] = None\n    for current_pok in svidetel[1:]:\n        q = int(current_pok)-1\n        if fconnection[p] != q:\n            fconnection[p] = None\n        if bconnection[q] != p:\n            bconnection[q] = None\n        p = q\n    fconnection[p] = None\n#    try:\n#        bconnection[bconnection.index(p)] = None\n#    except ValueError:\n#        pass\n\n\n\n\nis_bundled = [True] + [False] * (n - 1)\nunbundled_count = n\ncurrent_bundle = []\nnumber_of_variants = 0\nresearch_deck = [0]\n\nfor i in range(n):\n    if (fconnection[i] == None) and (bconnection[i] == None):\n        number_of_variants += 1 # one distinct node\n    elif bconnection[i] == None:\n        # this is start of new run. check it.\n        number_in_run = 1\n        next_in_run = fconnection[i]\n        while next_in_run is not None:\n            number_in_run += 1\n            next_in_run = fconnection[next_in_run]\n        number_of_variants += int((1 + number_in_run) * number_in_run / 2)\n\n\n#while unbundled_count >= 0:\n#    #print(research_deck, current_bundle)\n#    if research_deck:\n#        c = research_deck.pop()\n#        # check _to connection\n#        if (connection[c] != None) and not is_bundled[connection[c]]:\n#            research_deck.append(connection[c])\n#        # check _from connection\n#        try:\n#            fr = connection.index(c)\n#            if not is_bundled[fr]:\n#                research_deck.append(fr)\n#        except ValueError:\n#            pass\n#        current_bundle.append(c)\n#        is_bundled[c] = True\n#    else:\n#        curlen = len(current_bundle)\n#        number_of_variants += int((curlen + 1)*curlen/2)\n#        unbundled_count -= curlen\n#        current_bundle = []\n#        if unbundled_count > 0:\n#            research_deck = [is_bundled.index(False)]\n#        else:\n#            break\nprint(number_of_variants)\n"]
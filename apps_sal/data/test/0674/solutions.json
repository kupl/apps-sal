["n = int(input())\n\nwrong_str = False\n\nstrings = []\nsets = []\nfor _ in range(n):\n    new_string = input()\n    new_string_set = set(new_string)\n    if len(new_string) != len(new_string_set):\n        wrong_str = True\n        break\n\n    strings.append(new_string)\n    sets.append(new_string_set)\n\nif wrong_str:\n    print(\"NO\")\n    return\n\n\nconnections = []\nfor _ in range(n):\n    connections.append((-1,-1))\n\nchanged = True\n\nwhile changed:\n\n    changed = False\n\n    for i in range(len(strings)):\n\n        if strings[i] == None:\n            continue\n\n        for j in range(i + 1, len(strings)):\n\n            if strings[j] == None:\n                continue\n\n            if len(set(strings[i]).intersection(set(strings[j]))) == 0:\n                continue\n\n            a = strings[i]\n            b = strings[j]\n\n            #print(a, b)\n\n            if b in a:\n                strings[j] = None\n                changed = True\n            elif a in b:\n                strings[i] = b\n                strings[j] = None\n                changed = True\n            else:\n\n                is_ok = False\n\n                start_index = a.find(b[0])\n                if start_index != -1 and a[start_index:] in b:\n                    strings[i] += strings[j][len(a) - start_index:]\n                    strings[j] = None\n                    is_ok = True\n                    changed = True\n\n                if not is_ok:\n                    start_index = b.find(a[0])\n                    if start_index != -1 and  b[start_index:] in a:\n                        strings[i] = strings[j] + strings[i][len(b) - start_index:]\n                        strings[j] = None\n                        is_ok = True\n                        changed = True\n\n                if not is_ok:\n                    print(\"NO\")\n                    return\n\n\n\n\n        if wrong_str:\n            print(\"NO\")\n            return\n\n    strings = [x for x in strings if x is not None]\n\nwhole_str = \"\".join(strings)\n\nif len(whole_str) != len(set(whole_str)):\n    print(\"NO\")\n    return\n\nprint(\"\".join(sorted(strings)))\n\n\n\n", "n = int(input())\nA = []\nfor i in range (0,n):\n    A = A + [input()]\nstart = [100]*26\nend = [100]*26\ndef num(x):\n    return(ord(x)-ord(\"a\"))\ndef let(x):\n    return(chr(x+ord(\"a\")))\ndef ans(x):\n    final = []\n    for i in range (0,n):\n        B = list(A[i])\n        if len(B) == 1:\n            if start[num(B[0])] == 100:\n                start[num(B[0])] = -100\n            if end[num(B[0])] == 100:\n                end[num(B[0])] = -100\n        else:\n            for j in range (0,len(B)):\n                if j==0:\n                    if start[num(B[j])] == 100 or start[num(B[j])] == -100:\n                        start[num(B[j])] = -100\n                    if end[num(B[j])] == 100 or end[num(B[j])] == -100:\n                        end[num(B[j])] = num(B[j+1])\n                    elif end[num(B[j])] == num(B[j+1]): g=0\n                    else:\n                        return(\"NO\")\n                elif 0<j<len(B)-1:\n                    if start[num(B[j])] == 100 or start[num(B[j])] == -100:\n                        start[num(B[j])] = num(B[j-1])\n                    elif start[num(B[j])] != num(B[j-1]):\n                        return(\"NO\")\n                    if end[num(B[j])] == 100 or end[num(B[j])] == -100:\n                        end[num(B[j])] = num(B[j+1])\n                    elif end[num(B[j])] != num(B[j+1]):\n                        return(\"NO\")\n                elif j == len(B)-1:\n                    if end[num(B[j])] == 100:\n                        end[num(B[j])] = -100\n                    if start[num(B[j])] == 100 or start[num(B[j])] == -100:\n                        start[num(B[j])] = num(B[j-1])\n                    elif start[num(B[j])] == num(B[j-1]): g=0\n                    else:\n                        return(\"NO\")\n    if len(set(start))+max(0,start.count(100)-1)+max(0,start.count(-100)-1) != 26:\n            return(\"NO\")\n    elif len(set(end))+max(0,end.count(100)-1)+max(0,end.count(-100)-1) != 26:\n            return(\"NO\")\n    else:\n        for i in range (0,26):\n            if start[i] != -100:\n                g=0\n            else:\n                final = final + [let(i)]\n                j = end[i]\n                while j != -100:\n                    final = final + [let(j)]\n                    j = end[j]\n        if len(final) != len(set(start))-min(1,start.count(100))+max(0,start.count(-100)-1):\n            return(\"NO\")\n        else:\n            return(\"\".join(final))\nprint(ans(A))", "n=int(input())\nm=[]\nsc=[]\nfor i in range(n):\n    m.append(input())\n    sc.append(set(m[i]))\n    if len(sc[i])!=len(m[i]):\n        print('NO')\n        break\nelse:\n    i=0\n    pX=False\n    while i<len(m):\n        j=i+1\n        p=False\n        while j<len(m):\n            #print(m)\n            z=len(sc[i].intersection(sc[j]))\n            #a=len(sc[i])\n            #b=len(sc[j])\n            if m[i] in m[j]:\n                m[i]=m[j]\n                sc[i]=sc[j]\n                sc.pop(j)\n                m.pop(j)\n                p=True\n                break\n            elif m[j] in m[i]:\n                sc.pop(j)\n                m.pop(j)\n                j-=1\n            elif z>0:\n                if m[i][-z:]==m[j][:z]:\n                    m[i]+=m[j][z:]\n                elif m[j][-z:]==m[i][:z]:\n                    m[i]=m[j]+m[i][z:]\n                else:\n                    pX=True\n                    break\n                sc[i]=set(m[i])\n                m.pop(j)\n                sc.pop(j)\n                j-=1\n                p=True\n            j+=1\n        if not p:\n            i+=1\n        if pX:\n            print('NO')\n            break\n    if not pX:\n        print(''.join(sorted(m)))\n", "n=int(input())\nm=[]\nsc=[]\nfor i in range(n):\n    m.append(input())\n    sc.append(set(m[i]))\n    if len(sc[i])!=len(m[i]):\n        print('NO')\n        break\nelse:\n    i=0\n    pX=False\n    while i<len(m):\n        j=i+1\n        p=False\n        while j<len(m):\n            #print(m)\n            z=len(sc[i].intersection(sc[j]))\n            #a=len(sc[i])\n            #b=len(sc[j])\n            if m[i] in m[j]:\n                m[i]=m[j]\n                sc[i]=sc[j]\n                sc.pop(j)\n                m.pop(j)\n                p=True\n                break\n            elif m[j] in m[i]:\n                sc.pop(j)\n                m.pop(j)\n                j-=1\n            elif z>0:\n                if m[i][-z:]==m[j][:z]:\n                    m[i]+=m[j][z:]\n                elif m[j][-z:]==m[i][:z]:\n                    m[i]=m[j]+m[i][z:]\n                else:\n                    pX=True\n                    break\n                sc[i]=set(m[i])\n                m.pop(j)\n                sc.pop(j)\n                j-=1\n                p=True\n            j+=1\n        if not p:\n            i+=1\n        if pX:\n            print('NO')\n            break\n    if not pX:\n        print(''.join(sorted(m)))", "u, v, d = {}, {}, set()\nfor i in range(int(input())):\n    t = input()\n    if len(t) == 1: d.add(t)\n    for a, b in zip(t, t[1:]):\n        if u.get(a, b) != b or v.get(b, a) != a: print('NO');return\n        u[a], v[b] = b, a\nd = d - set(u) - set(v)\nfor q in set(u).difference(v):\n    while q[-1] in u: q += u.pop(q[-1])\n    d.add(q)\nif u: print('NO');return\nprint(''.join(sorted(d)))", "u, v, d = {}, {}, set()\nfor i in range(int(input())):\n    t = input()\n    if len(t) == 1: d.add(t)\n    for a, b in zip(t, t[1:]):\n        if u.get(a, b) != b or v.get(b, a) != a: print('NO');return\n        u[a], v[b] = b, a\nx, y = set(u), set(v)\nd = d - x - y\nfor q in x - y:\n    while q[-1] in u: q += u.pop(q[-1])\n    d.add(q)\nif u: print('NO');return\nprint(''.join(sorted(d)))", "n = int(input())\nu = []\ns = []\nok = True\nfor i in range(n):\n    u.append(input())\n    s.append(set(u[i]))\n    if len(s[i]) != len(u[i]):\n        print('NO')\n        ok = False\n        break\nif ok:\n    i = 0\n    ok = False\n    while i < len(u):\n        j = i + 1\n        p = False\n        while j < len(u):\n            z = len(s[i].intersection(s[j]))\n            if u[i] in u[j]:\n                u[i] = u[j]\n                s[i] = s[j]\n                s.pop(j)\n                u.pop(j)\n                p = True\n                break\n            elif u[j] in u[i]:\n                s.pop(j)\n                u.pop(j)\n                j -= 1\n            elif z > 0:\n                if u[i][-z:] == u[j][:z]:\n                    u[i] += u[j][z:]\n                elif u[j][-z:] == u[i][:z]:\n                    u[i] = u[j] + u[i][z:]\n                else:\n                    ok = True\n                    break\n                s[i] = set(u[i])\n                u.pop(j)\n                s.pop(j)\n                j -= 1\n                p = True\n            j += 1\n        if not p:\n            i += 1\n        if ok:\n            print('NO')\n            break\n    if not ok:\n        u.sort()\n        print(''.join(u))\n        \n\n\n\n\n\n\n                \n", "#https://codeforces.com/problemset/problem/886/D\ndef is_all_used(used):\n    for val in list(used.values()):\n        if val != True:\n            return False\n    return True    \n\ndef is_circle(d, pre):\n    used     = {x:False for x in d}\n    pre_none = [x for x in used if x not in pre]\n    s_arr    = []\n    \n    for x in pre_none:\n        cur    = []\n        flg    = dfs(x, d, used, cur)\n            \n        if flg==True:\n            return True, None\n            \n        s_arr.append(cur)\n    \n    if is_all_used(used) != True:\n        return True, None\n    \n    return False, s_arr\n\ndef dfs(u, d, used, cur):\n    used[u] = True\n    cur.append(u)\n    flg = False\n    \n    for v in d[u]:\n        if used[v] == True:\n            return True\n        \n        flg = dfs(v, d, used, cur)\n        \n        if flg==True:\n            return flg\n    return flg\n\ndef push(d, u, v=None):\n    if u not in d:\n        d[u] = set()\n    \n    if v is not None:\n        if v not in d:\n            d[v] = set()\n        d[u].add(v)\n    \ndef push_p(d, v):\n    if v not in d:\n        d[v] = 0\n    d[v]+=1\n    \ndef is_deg_valid(d):\n    for u in d:\n        if len(d[u]) > 1:\n            return True\n    return False\n\ndef solve():\n    n   = int(input())\n    d   = {}\n    pre = {}\n    \n    for _ in range(n):\n        s = input()\n        if len(s) == 1:\n            push(d, s)\n        else:\n            for u, v in zip(s[:-1], s[1:]):\n                push(d, u, v)\n                push_p(pre, v)\n    \n    flg, arr = is_circle(d, pre)\n    \n    if is_deg_valid(d) or flg==True:\n        return 'NO'\n    \n    S = [''.join(x) for x in arr]\n    S = sorted(S)\n    return ''.join([s for s in S])\n        \nprint(solve())\n\n#4\n#mail\n#ai\n#lru\n#cf\n\n#3\n#kek\n#preceq\n#cheburek\n", "L = {}\nR = {}\nS = set()\n\nfor _ in range(int(input())):\n    s = input()\n    if len(s) == 1: \n        S.add(s)\n    for s1, s2 in zip(s, s[1:]):\n        if  s2 != L.get(s1, s2) or s1 != R.get(s2, s1): \n            print('NO');return\n        L[s1], R[s2] = s2, s1\n\nL1, R1 = set(L), set(R)\nS = S -L1 - R1\n\nfor i in L1 - R1:\n    while i[-1] in L: \n        i += L.pop(i[-1])\n    S.add(i)\nif L: \n    print('NO');return\nprint(''.join(sorted(S)))", "StringsNumber = int(input())\nFinalStrings = []\nStrings = []\n\nfor i in range(StringsNumber):\n    Strings.append(input())\n\nLetterGraph = {}\n\n# \u0413\u0435\u043d\u0435\u0440\u0438\u043c \u0433\u0440\u0430\u0444\n\nfor i in range(len(Strings)):\n    if len(Strings[i]) == 1:\n        if Strings[i] not in LetterGraph:\n            LetterGraph[Strings[i]] = \"\"\n            #print(\"\u0437\u0430\u0430\u043f\u0435\u0434\u0438\u043b\", i)\n        continue\n    for e in range(len(Strings[i]) - 1):\n        if Strings[i][e] not in LetterGraph:\n            Elements = []\n            for j in list(LetterGraph):\n                if j != Strings[i][e + 1]:\n                    Elements.append(LetterGraph[j])\n\n            if Strings[i][e + 1] in Elements:\n                print(\"NO\")\n                return\n            LetterGraph[Strings[i][e]] = Strings[i][e + 1]\n            continue\n        if LetterGraph[Strings[i][e]] == Strings[i][e + 1] or LetterGraph[Strings[i][e]] == \"\":\n            LetterGraph[Strings[i][e]] = Strings[i][e + 1]\n            continue\n        #print(\"\u0413\u0440\u0430\u0444:\", LetterGraph)\n        print(\"NO\")\n        return\n\n#print(\"\u042f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u043b \u0433\u0440\u0430\u0444, \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c:\", LetterGraph)\n\n# \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u043d\u0435\u0442\u0443 \u0446\u0438\u043a\u043b\u0430\n\nif LetterGraph:\n    Cycle = False\n    for i in LetterGraph:\n        Letter = LetterGraph[i]\n        while True:\n            if Letter in LetterGraph:\n                if LetterGraph[Letter] == i:\n                    print(\"NO\")\n                    return\n                Letter = LetterGraph[Letter]\n\n            else:\n                break\n\n# \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u0435\u0440\u0432\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b\n\nif LetterGraph:\n    IsIFirstSymbol = False\n    FirstSymbols = []\n\n    for i in LetterGraph:\n        IsIFirstSymbol = True\n        for e in LetterGraph:\n            if LetterGraph[e] == i:\n                #print(i, \"\u043d\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e\", e, \"\u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043d\u0430 \u043d\u0435\u0433\u043e.\")\n                IsIFirstSymbol = False\n        if IsIFirstSymbol:\n            FirstSymbols.append(i)\n\n    if not FirstSymbols:\n        print(\"NO\")\n        return\n\n#print(\"\u0412\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430:\", *FirstSymbols)\n\n# \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u044b \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n\nif LetterGraph:\n    Letter = \"\"\n    for i in FirstSymbols:\n        FinalString = i\n        Letter = i\n        for e in range(len(LetterGraph)):\n            if Letter in LetterGraph:\n                if not (LetterGraph[Letter] == \"\"):\n                    FinalString += LetterGraph[Letter]\n                    #print(Letter, \"\u0435\u0441\u0442\u044c \u0432 \u0433\u0440\u0430\u0444\u0435, \u0442\u0430\u043a \u0447\u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\", LetterGraph[Letter], \", \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043e\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442.\")\n                    Letter = LetterGraph[Letter]\n                else:\n                    break\n            else:\n                break\n\n        FinalStrings.append(FinalString)\n\n#print(\"\u041e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438\", *FinalStrings)\n\nFinalStrings.sort()\n\nRESULT = \"\"\n\nfor i in FinalStrings:\n    RESULT += i\n\nprint(RESULT)\n", "def generate_good_string(subs : list):\n    In, Out, S = {}, {}, set()\n    for s in subs:\n        if len(s) == 1:\n            S.add(s) \n        for fr, to in zip(s, s[1:]):\n            if fr != In.get(to, fr) or to != Out.get(fr, to):\n                return(print('NO'))\n            Out[fr], In[to] = to, fr\n    Outset, Inset = set(Out), set(In)\n    S -= (set.union(Outset, Inset))\n    for s in Outset - Inset:\n        while Out.get(s[-1]):\n            s += Out.pop(s[-1])\n        S.add(s)\n    print('NO' if Out else ''.join(sorted(S)))\nsubstrings = [input() for _ in range(int(input()))]\ngenerate_good_string(substrings)"]
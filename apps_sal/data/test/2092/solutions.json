["\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nM,N,K,T = inpl()\nAA = inpl()\n\nDD_di = []\nLR = []\nfor i in range(K):\n    L,R,D = inpl()\n    LR.append((L,R))\n    DD_di.append((D,i))\n\nDD_di.sort()\nDD_d = [D for D,i in DD_di]\n\ndef solve(x):\n    idx = bisect.bisect_right(DD_d, x)\n    path = [0]*(N+2)\n    for D,i in DD_di[idx:]:\n        L,R = LR[i]\n        path[L] += 1\n        path[R+1] -= 1\n\n    t = N+1\n    bp = path[0]\n    for i in range(1,N+2):\n        p = bp + path[i]\n        if p > 0:\n            t += 2\n        bp = p\n\n    return t <= T\n\n\nOK = (10**5) * 2 + 10\nNG = -1\n\nwhile OK-NG > 1:\n    mid = (OK+NG)//2\n    if solve(mid):\n        OK = mid\n    else:\n        NG = mid\n\nans = 0\nfor A in AA:\n    if A >= OK:\n        ans += 1\n\nprint(ans)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef chk(a):\n    Y = [0] * (N + 10)\n    for l, r, d in X:\n        if d <= a: continue\n        Y[l-1] += 1\n        Y[r] -= 1\n    for i in range(1, N+10):\n        Y[i] += Y[i-1]\n    return 1 if sum([min(Y[i], 1) for i in range(N+5)]) * 2 + N+1 <= T else 0\n\nM, N, K, T = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nX = []\nfor _ in range(K):\n    l, r, d = list(map(int, input().split()))\n    X.append((l, r, d))\n\nl, r = 0, 2*10**5\nwhile r - l > 1:\n    m = (l+r) // 2\n    if chk(m):\n        r = m\n    else:\n        l = m\n\nprint(len([a for a in A if a >= r]))\n\n", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nsol_n, n, trap_n, t = [int(item) for item in input().split()]\nsold = [int(item) for item in input().split()]\nsold.sort(reverse=True)\ntrap = []\nfor i in range(trap_n):\n    l, r, d = [int(item) for item in input().split()]\n    trap.append((d, l, r))\ntrap.sort()\nll = 0; rr = sol_n + 1\nwhile rr - ll > 1:\n    mid = (ll + rr) // 2\n    to_save = sold[mid - 1]\n    alone_walk = [0] * (n + 1)\n    for d, l, r in trap:\n        if d > to_save:\n            alone_walk[l-1] += 1\n            alone_walk[r] -= 1\n    total = 0\n    time = 0\n    for item in alone_walk:\n        total += item\n        if total > 0:\n            time += 2\n    time += n + 1\n    if time <= t:\n        ll = mid\n    else:\n        rr = mid\nprint(ll)", "3\n\nimport os\nimport sys\n\n\ndef main():\n    M, N, K, T = read_ints()\n    A = read_ints()\n    B = [tuple(read_ints()) for _ in range(K)]\n    print(solve(M, N, K, T, A, B))\n\n\ndef solve(M, N, K, T, A, B):\n    B.sort()\n\n    def seconds(agi):\n        traps = [(l, r) for l, r, d in B if d > agi]\n        x = 0\n        sec = 0\n        sw = -1\n        for l, r in traps:\n            if sw != -1 and sw < l:\n                sec += 2 * (sw - x)\n                sw = -1\n\n            if sw != -1:\n                sw = max(sw, r)\n                continue\n\n            sec += l - 1 - x\n            x = l - 1\n            sw = r\n\n        if sw != -1:\n            sec += 2 * (sw - x)\n\n        sec += N + 1 - x\n        return sec\n\n    min_agi = min(A)\n    max_agi = max(A)\n\n    if seconds(max_agi) > T:\n        return 0\n    if seconds(min_agi) <= T:\n        return len(A)\n\n    lb = min_agi\n    ub = max_agi\n    while ub - lb > 1:\n        agi = (lb + ub) // 2\n        if seconds(agi) > T:\n            lb = agi\n        else:\n            ub = agi\n\n    return len([a for a in A if a >= ub])\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def inter(a,b):\n    if b[0]<=a[1]:\n        return 1\n    return 0\ndef check(le):\n    if le==0:\n        return 1\n    mi=it[le-1]\n  #  print(mi)\n    tr=[i[:2] for i in aaa if i[2]>mi]\n    if tr==[]:\n        return 1\n    aa=[tr[0][:]]\n  #  print(le,tr)\n    for i in range(1,len(tr)):\n        if inter(aa[-1],tr[i]):\n            aa[-1][1]=max(aa[-1][1],tr[i][1])\n        else:\n            aa.append(tr[i][:])\n    tt=0\n    a=0\n   # print(aa)\n    for i in range(len(aa)):\n        tt+=(aa[i][0]-1-a)\n        a=aa[i][0]-1\n        tt+=3*(aa[i][1]-aa[i][0]+1)\n        a=aa[i][1]\n    tt+=(n+1)-a\n  #  print(le,tt)\n  #  print()\n    return tt<=t\n    \nm,n,k,t=list(map(int,input().split()))\nit=list(map(int,input().split()))\nit.sort(reverse=True)\naaa=[]\nfor i in range(k):\n    l,r,d=list(map(int,input().split()))\n    aaa.append([l,r,d])\naaa.sort()\nlow=0\nhigh=m\nwhile low<high-1:\n    mid=(low+high)//2\n    a=check(mid)\n    if a:\n        low=mid\n    else:\n        high=mid-1\nfor i in range(high,low-1,-1):\n    if check(i):\n        ans=i\n        break\nprint(ans)\n", "import sys\ninput=sys.stdin.readline\ndef inter(a,b):\n    if b[0]<=a[1]:\n        return 1\n    return 0\ndef check(le):\n    if le==0:\n        return 1\n    mi=it[le-1]\n  #  print(mi)\n    tr=[i[:2] for i in aaa if i[2]>mi]\n    if tr==[]:\n        return 1\n    aa=[tr[0][:]]\n  #  print(le,tr)\n    for i in range(1,len(tr)):\n        if inter(aa[-1],tr[i]):\n            aa[-1][1]=max(aa[-1][1],tr[i][1])\n        else:\n            aa.append(tr[i][:])\n    tt=0\n    a=0\n   # print(aa)\n    for i in range(len(aa)):\n        tt+=(aa[i][0]-1-a)\n        a=aa[i][0]-1\n        tt+=3*(aa[i][1]-aa[i][0]+1)\n        a=aa[i][1]\n    tt+=(n+1)-a\n  #  print(le,tt)\n  #  print()\n    return tt<=t\n    \nm,n,k,t=list(map(int,input().split()))\nit=list(map(int,input().split()))\nit.sort(reverse=True)\naaa=[]\nfor i in range(k):\n    l,r,d=list(map(int,input().split()))\n    aaa.append([l,r,d])\naaa.sort()\nlow=0\nhigh=m\nwhile low<high-1:\n    mid=(low+high)//2\n    a=check(mid)\n    if a:\n        low=mid\n    else:\n        high=mid-1\nfor i in range(high,low-1,-1):\n    if check(i):\n        ans=i\n        break\nprint(ans)\n", "import sys\nfrom bisect import bisect_left\nm, n, k, t = map(int, input().split())\na = sorted(map(int, input().split()))\ntraps = sorted(list(map(int, l.split())) for l in sys.stdin)\n\nok, ng = 2*10**5, 0\nwhile ok - ng > 1:\n    mid = (ok+ng) // 2\n    l, r = 0, 0\n    dist = n + 1\n    for i in range(k):\n        if mid < traps[i][2]:\n            if r < traps[i][0]:\n                dist += (r - l) * 2\n                l, r = traps[i][0]-1, traps[i][1]\n            else:\n                r = max(r, traps[i][1])\n\n    dist += (r - l) * 2\n\n    if dist <= t:\n        ok = mid\n    else:\n        ng = mid\n\nprint(m - bisect_left(a, ok))", "m,n,k,t = list(map(int,input().split()))\na = [0] + sorted(list(map(int,input().split()))) + [3*10**5]\ndata = sorted([list(map(int,input().split())) for _ in range(k)])\n#print(data)\n\nok = m+1\nng = 0\n\nwhile ok-ng > 1:\n    mid = (ok + ng)//2\n    A = a[mid]\n\n    interval_set = []\n    for i in range(k):\n        if data[i][2]<= A:\n            continue\n        if len(interval_set)==0:\n            interval_set.append([data[i][0],data[i][1]])\n        else:\n            if interval_set[-1][1] < data[i][0]:\n                interval_set.append([data[i][0],data[i][1]])\n            elif interval_set[-1][1] < data[i][1]:\n                new_interval = [interval_set.pop()[0],data[i][1]]\n                interval_set.append(new_interval)\n    time = n+1\n    for interval in interval_set:\n        time += (interval[1]-interval[0]+1)*2\n\n    #print(mid,A, interval_set,time)\n    if time <= t:\n        ok = mid\n    else:\n        ng = mid\n\nprint(m-ok+1)\n#print(a[ok])\n", "m, n, k, t = [int(s) for s in input().split()]\nA = [int(s) for s in input().split()]\nA.sort()\ntraps = []\nfor i in range(k):\n    l, r, d = [int(s) for s in input().split()]\n    traps.append((l,r,d))\ntraps.sort()\n\ndef canTake(agi):\n    farest = 0\n    trapIndex = 0\n    wasteTime = 0\n    while trapIndex < len(traps):\n        trap = traps[trapIndex]\n        if trap[2] <= agi:\n            trapIndex += 1\n            continue\n        if trap[1] <= farest:\n            trapIndex += 1\n            continue\n        # r > farest\n        newFarest = trap[1]\n        if trap[0] > farest:\n            wasteTime += (trap[1] - trap[0] + 1)*2\n        else:\n            wasteTime += (newFarest - farest)*2\n        farest = newFarest\n        trapIndex += 1\n\n    if wasteTime + n + 1 > t:\n        return False\n    else:\n        return True\n\ndef binSearch(A):\n    if canTake(A[0]):\n        return 0\n    low = 0  # imposs tank\n    high = len(A)  # poss tank\n    while high-low > 1:\n        mid = (low+high)//2\n        if canTake(A[mid]):\n            high = mid\n        else:\n            low = mid\n    return high\n\nfirstCan = binSearch(A)\nprint(len(A)-firstCan)", "\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nM,N,K,T = inpl()\nAA = inpl()\n\nDD_di = []\nLR = []\nfor i in range(K):\n    L,R,D = inpl()\n    LR.append((L,R))\n    DD_di.append((D,i))\n\nDD_di.sort()\nDD_d = [D for D,i in DD_di]\n\ndef solve(x):\n    idx = bisect.bisect_right(DD_d, x)\n    path = [0]*(N+2)\n    for D,i in DD_di[idx:]:\n        L,R = LR[i]\n        path[L] += 1\n        path[R+1] -= 1\n\n    t = N+1\n    bp = path[0]\n    for i in range(1,N+2):\n        p = bp + path[i]\n        if p > 0:\n            t += 2\n        bp = p\n\n    return t <= T\n\n\nOK = (10**5) * 2 + 10\nNG = -1\n\nwhile OK-NG > 1:\n    mid = (OK+NG)//2\n    if solve(mid):\n        OK = mid\n    else:\n        NG = mid\n\nans = 0\nfor A in AA:\n    if A >= OK:\n        ans += 1\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nm,n,k,t=list(map(int,input().split()))\nA=list(map(int,input().split()))\nT=[tuple(map(int,input().split())) for i in range(k)]\n\nNG=0\nOK=2*10**5+1\n\nwhile OK-NG>1:\n    mid=(OK+NG)//2\n\n    USE=[0]*(2*10**5+3)\n\n    for l,r,d in T:\n        if d>=mid:\n            USE[l-1]+=1\n            USE[r]-=1\n\n    for i in range(1,2*10**5+3):\n        USE[i]+=USE[i-1]\n\n    #print(mid,USE[:10],(2*10**5+3-USE.count(0))*2+n+1)\n\n    if (2*10**5+3-USE.count(0))*2+n+1<=t:\n        OK=mid\n    else:\n        NG=mid\n\nANS=0\nfor a in A:\n    if a>=OK-1:\n        ANS+=1\nprint(ANS)\n\n    \n\n    \n", "import sys\ninput = sys.stdin.readline\n\nm,n,k,t=list(map(int,input().split()))\nA=list(map(int,input().split()))\nT=[tuple(map(int,input().split())) for i in range(k)]\n\nA.sort(reverse=True)\n\nSLIST=[0]*(2*10**5+2)\n\nind=0\nfor i in range(A[0],-1,-1):\n    SLIST[i]=SLIST[i+1]\n    \n    while ind<m and A[ind]==i:\n        SLIST[i]+=1\n        ind+=1\n\nSLIST=[SLIST[0]]+SLIST\n\nNG=0\nOK=2*10**5+1\n\nwhile OK-NG>1:\n    mid=(OK+NG)//2\n\n    USE=[0]*(2*10**5+3)\n\n    for l,r,d in T:\n        if d>=mid:\n            USE[l-1]+=1\n            USE[r]-=1\n\n    for i in range(1,2*10**5+3):\n        USE[i]+=USE[i-1]\n\n    #print(mid,USE[:10],(2*10**5+3-USE.count(0))*2+n+1)\n\n    if (2*10**5+3-USE.count(0))*2+n+1<=t:\n        OK=mid\n    else:\n        NG=mid\n\nprint(SLIST[OK])\n\n    \n\n    \n", "import sys\ninput = sys.stdin.readline\n\nm,n,k,t=list(map(int,input().split()))\nA=list(map(int,input().split()))\nT=[tuple(map(int,input().split())) for i in range(k)]\n\n\nseg_el=1<<((n+2).bit_length())\nseg_height=1+(n+2).bit_length()\nSEG=[0]*(2*seg_el) \nLAZY=[0]*(2*seg_el)\n\ndef indexes(L,R):\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n\ndef updates(l,r,x): # \u533a\u9593[l,r)\u3092x\u306b\u66f4\u65b0\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=0:\n            update_lazy = 1<<(seg_height - 1 - (ind.bit_length()))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=1\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=0\n\n    while L!=R:\n        if L > R:\n            SEG[L]=1<<(seg_height - (L.bit_length()))\n            LAZY[L]=1\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]=1<<(seg_height - (R.bit_length()))\n            LAZY[R]=1\n            R//=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=SEG[ind<<1]+SEG[1+(ind<<1)]\n\ndef getvalues(l,r): # \u533a\u9593[l,r)\u306b\u95a2\u3059\u308bmin\u3092\u8abf\u3079\u308b\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=0:\n            update_lazy = 1<<(seg_height - 1 - (ind.bit_length()))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=1\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=0\n            \n    ANS=0\n\n    while L!=R:\n        if L > R:\n            ANS+=SEG[L]\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            ANS+=SEG[R]\n            R//=(R & (-R))\n\n    return ANS\n\nT.sort(key=lambda x:x[2],reverse=True)\n\nOK=2*10**5+1\nind=0\n\nfor i in range(2*10**5+2,-1,-1):\n\n    while ind<k and T[ind][2]>=i:\n        updates(T[ind][0], T[ind][1]+1, 1)\n        ind+=1\n\n    if getvalues(0, n+2)*2+n+1<=t:\n        OK=i\n    else:\n        break\n\nANS=0\nfor a in A:\n    if a>=OK-1:\n        ANS+=1\nprint(ANS)\n", "import sys\ninput = sys.stdin.readline\n\nm,n,k,t=list(map(int,input().split()))\nA=list(map(int,input().split()))\nT=[tuple(map(int,input().split())) for i in range(k)]\n\n\nseg_el=1<<((n+2).bit_length())\nseg_height=1+(n+2).bit_length()\nSEG=[0]*(2*seg_el) \nLAZY=[0]*(2*seg_el)\n\ndef indexes(L,R): # \u9045\u5ef6\u4f1d\u642c\u3059\u3079\u304d\u30ce\u30fc\u30c9\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059. \uff08\u3064\u307e\u308a, update\u3084getvalues\u3067\u898b\u308b\u30ce\u30fc\u30c9\u3088\u308a\u4e0a\u306b\u3042\u308b\u30ce\u30fc\u30c9\u305f\u3061\uff09\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n\ndef updates(l,r,x): # \u533a\u9593[l,r)\u3092x\u306b\u66f4\u65b0\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # \u9045\u5ef6\u4f1d\u642c\n        if LAZY[ind]!=None:\n            update_lazy = LAZY[ind] *(1<<(seg_height - 1 - (ind.bit_length())))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=LAZY[ind]\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=None\n\n    while L!=R:\n        if L > R:\n            SEG[L]=x * (1<<(seg_height - (L.bit_length())))\n            LAZY[L]=x\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]=x * (1<<(seg_height - (R.bit_length())))\n            LAZY[R]=x\n            R//=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=SEG[ind<<1]+SEG[1+(ind<<1)]\n\ndef getvalues(l,r): # \u533a\u9593[l,r)\u306b\u95a2\u3059\u308bmin\u3092\u8abf\u3079\u308b\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # \u9045\u5ef6\u4f1d\u642c\n        if LAZY[ind]!=None:\n            update_lazy = LAZY[ind] *(1<<(seg_height - 1 - (ind.bit_length())))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=LAZY[ind]\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=None\n            \n    ANS=0\n\n    while L!=R:\n        if L > R:\n            ANS+=SEG[L]\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            ANS+=SEG[R]\n            R//=(R & (-R))\n\n    return ANS\n\nT.sort(key=lambda x:x[2],reverse=True)\n\nOK=2*10**5+1\nind=0\n\nfor i in range(2*10**5+2,-1,-1):\n\n    while ind<k and T[ind][2]>=i:\n        updates(T[ind][0], T[ind][1]+1, 1)\n        ind+=1\n\n    if getvalues(0, n+2)*2+n+1<=t:\n        OK=i\n    else:\n        break\n\nANS=0\nfor a in A:\n    if a>=OK-1:\n        ANS+=1\n        \nprint(ANS)\n", "import sys\n\n\ndef army(weak, traps, t_max, n):\n    t = n + 1\n    alone = [0] * (n + 1)\n    for l, r, d in traps:\n        if d <= weak:\n            break\n        alone[l - 1] += 1\n        alone[r] -= 1\n        \n    interval = 0\n    for loc in range(n + 1):\n        interval += alone[loc]\n        if interval:\n            t += 2\n            \n#     print(t, t_max)\n    return t <= t_max\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\nm, n, k, t_max = next(reader)\na = list(next(reader))\ntraps = []\nfor _ in range(k):\n    l, r, d = next(reader)\n    traps.append((l, r, d))\n\na.sort(reverse=True)\ntraps.sort(key=lambda x: x[2], reverse=True)\n# print(a)\n# print(traps)\n\n# binary search of max amount of soldiers to pass\nL = 0\nR = m + 1\nwhile L + 1 < R:\n    check = (L + R) // 2\n#     print(check, a[check - 1])\n    if army(a[check - 1], traps, t_max, n):\n        L = check\n    else:\n        R = check\n#     print(L, R)\n#     print()\n    \nprint(L)\n    \n# inf.close()\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bisearch_min(mn, mx, func):\n\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nM, N, K, T = MAP()\nA = LIST()\n\nLRD = []\nfor i in range(K):\n    l, r, d = MAP()\n    LRD.append((l, r, d))\n\ndef check(m):\n    imos = [0] * (N+2)\n    for l, r, d in LRD:\n        if d > m:\n            imos[l] += 1\n            imos[r+1] -= 1\n    imos = list(accumulate(imos))\n    cnt = 0\n    for i in imos:\n        if i > 0:\n            cnt += 1\n    return cnt*2 + N+1 <= T\n\namx = max(A)\nres = bisearch_min(0, amx+1, check)\nA.sort()\nidx = bisect_left(A, res)\ncnt = M - idx\nprint(cnt)\n", "(m, n, k, t) = list(map(int, input().split()))\na = list(map(int, input().split()))\ntrap = list()\n\nfor i in range(k):\n    (x1, x2, x3) = list(map(int, input().split()))\n    trap.append([x1, x2, x3])\n\ntrap.sort()\na.sort()\n\n#print(trap)\n#print(a)\n\nx = -1\nl = 0\nr = len(a) - 1\ns = 0\nwhile r - l >= 0:\n    x = (l + r) // 2\n    weig = a[x]\n    ltrap = 0\n    rtrap = 0\n    time = 0\n\n    for i in trap:\n        if i[2] > weig:\n            if i[0] <= rtrap:\n                rtrap = max(rtrap, i[1])\n                time += i[0]-ltrap\n                ltrap = i[0]\n\n            else:\n                time += rtrap - ltrap + 1\n                rtrap = i[1]\n                ltrap = i[0]\n    time += rtrap - ltrap\n    #print(x, weig, time)\n    if 2*time + n + 1 <= t:\n        s = max(s, len(a) - x)\n        r = x - 1\n    else:\n        l = x + 1\n\nprint(s)", "(m, n, k, t) = list(map(int, input().split()))\na = list(map(int, input().split()))\ntrap = list()\nfor i in range(k):\n    (x1, x2, x3) = list(map(int, input().split()))\n    trap.append([x1, x2, x3])\ntrap.sort()\na.sort()\nx = -1\nl = 0\nr = len(a) - 1\ns = 0\nwhile r - l >= 0:\n    x = (l + r) // 2\n    weig = a[x]\n    ltrap = 0\n    rtrap = 0\n    time = 0\n    for i in trap:\n        if i[2] > weig:\n            if i[0] <= rtrap:\n                rtrap = max(rtrap, i[1])\n                time += i[0]-ltrap\n                ltrap = i[0]\n            else:\n                time += rtrap - ltrap + 1\n                rtrap = i[1]\n                ltrap = i[0]\n    time += rtrap - ltrap\n    if 2*time + n + 1 <= t:\n        s = max(s, len(a) - x)\n        r = x - 1\n    else:\n        l = x + 1\nprint(s)\n", "import sys\ninput = sys.stdin.readline\n\nM, N, K, T = map(int, input().split())\nA = list(map(int, input().split()))\nLRD = [list(map(int, input().split())) for _ in range(K)]\n\nA.append(10**15)\nA.sort(reverse=True)\n\nl = 0\nr = M+1\nwhile r-l > 1:\n    m = (r+l)//2\n    D_limit = A[m]\n    \n    P = [0]*(N+2)\n    for L, R, D in LRD:\n        if D_limit < D:\n            P[L] += 1\n            P[R+1] -= 1\n    c = 0\n    for i in range(N+1):\n        P[i+1] += P[i]\n        if P[i+1] > 0:\n            c += 1\n    #print(P, m)\n    time = N+1 + 2*c\n    #print(time)\n    \n    if time <= T:\n        l = m\n    else:\n        r = m\n\nprint(l)", "from sys import stdin\n\ninput = stdin.readline\n#\n# m, n, k, t = map(int, input().split())\n#\n# a = list(map(int, input().split()))\n#\n# t -= n\n# mxr = [0] * (n+2)\n# mxl = [0] * (n+2)\n#\n# trapr = [0] * (n+2)\n# trapl = [0] * (n+2)\n# for i in range(k):\n#     l, r, d = map(int, input().split())\n#     trapr[r] = max(trapr[r], d)\n#     trapl[l] = max(trapl[l], d)\n#\n# for i in range(n+1)[::-1]:\n#     mxr[i] = max(mxr[i + 1], trapr[i])\n#\n# for i in range(1, n+1):\n#     mxl[i] = max(mxl[i - 1], trapl[i])\n#\n# ans = 0\n# a.sort()\n# from bisect import *\n#\n# for i in range(n+1):\n#     f = i + t // 2\n#     f = min(f, n)\n#     mx = max(mxl[i], mxr[f + 1])\n#     # print(n, m-bisect_left(a, mx))\n#     ans = max(ans, m - bisect_left(a, mx))\n#     # print(i, f, mx, ans)\n#\n# print(ans)\n#\n# trap = []\n#\n#\n# def check(x):\n#     avg = a[-x]\n#     cost = n+1\n#     nr = 0\n#     for i in range(k):\n#         xx, y, d = trap[i]\n#         # print(avg,xx, y, d, cost,nr)\n#         if d <= avg:\n#             continue\n#         if y > nr:\n#             # print('1')\n#             cost += (y - max(xx - 1, nr)) * 2\n#             # print(xx,y,d,cost)\n#             nr = y\n#      # print(x, cost)\n#     return cost <= t\n#\n#\n# for i in range(k):\n#     trap.append(list(map(int, input().split())))\n#\n# trap.sort()\n#\n# l = 0\n# r = m+1\n#\n# while r - l > 1:\n#     mid = (l + r) // 2\n#     # print(mid)\n#     if check(mid):\n#         l = mid\n#     else:\n#         r = mid\n#\n#\n# print(l)\n\n\ndef works(mid):\n    ag = A[-mid]\n    MAX = 0\n    cur = 0\n    out = N+1\n    for l,r,d in traps:\n        if d <= ag: continue\n        if l > MAX:\n            out += (MAX-cur)*2\n            MAX,cur = r,l-1\n        else:\n            MAX = max(MAX,r)\n    return out <= time\nS,N,T,time = map(int,input().split())\nA = list(map(int,input().split()))\ntraps = [tuple(map(int,input().split())) for _ in range(T)]\ntraps.sort()\ntraps.append((N+2,N+5,10**6))\nA.sort()\nlo = 0 #works\nhi = S+1 #does not work\nwhile hi - lo > 1:\n    mid = (hi + lo) // 2\n    if works(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(lo)", "from sys import stdin\n\ninput = stdin.readline\n#\n# m, n, k, t = map(int, input().split())\n#\n# a = list(map(int, input().split()))\n#\n# t -= n\n# mxr = [0] * (n+2)\n# mxl = [0] * (n+2)\n#\n# trapr = [0] * (n+2)\n# trapl = [0] * (n+2)\n# for i in range(k):\n#     l, r, d = map(int, input().split())\n#     trapr[r] = max(trapr[r], d)\n#     trapl[l] = max(trapl[l], d)\n#\n# for i in range(n+1)[::-1]:\n#     mxr[i] = max(mxr[i + 1], trapr[i])\n#\n# for i in range(1, n+1):\n#     mxl[i] = max(mxl[i - 1], trapl[i])\n#\n# ans = 0\n# a.sort()\n# from bisect import *\n#\n# for i in range(n+1):\n#     f = i + t // 2\n#     f = min(f, n)\n#     mx = max(mxl[i], mxr[f + 1])\n#     # print(n, m-bisect_left(a, mx))\n#     ans = max(ans, m - bisect_left(a, mx))\n#     # print(i, f, mx, ans)\n#\n# print(ans)\n#\n# trap = []\n#\n#\n# def check(x):\n#     avg = a[-x]\n#     cost = n+1\n#     nr = 0\n#     for i in range(k):\n#         xx, y, d = trap[i]\n#         # print(avg,xx, y, d, cost,nr)\n#         if d <= avg:\n#             continue\n#         if y > nr:\n#             # print('1')\n#             cost += (y - max(xx - 1, nr)) * 2\n#             # print(xx,y,d,cost)\n#             nr = y\n#      # print(x, cost)\n#     return cost <= t\n#\n#\n# for i in range(k):\n#     trap.append(list(map(int, input().split())))\n#\n# trap.sort()\n#\n# l = 0\n# r = m+1\n#\n# while r - l > 1:\n#     mid = (l + r) // 2\n#     # print(mid)\n#     if check(mid):\n#         l = mid\n#     else:\n#         r = mid\n#\n#\n# print(l)\n\n\ndef works(mid):\n    ag = A[-mid]\n    MAX = 0\n    cur = 0\n    out = N+1\n    for l,r,d in traps:\n        if d <= ag:\n            continue\n        if r > MAX:\n            out += (r - max(l-1, MAX))*2\n            MAX = r\n        # if l > MAX:\n        #     out += (MAX-cur)*2\n        #     MAX,cur = r,l-1\n        # else:\n        #     MAX = max(MAX,r)\n    return out <= time\nS,N,T,time = map(int,input().split())\nA = list(map(int,input().split()))\ntraps = [tuple(map(int,input().split())) for _ in range(T)]\ntraps.sort()\n# traps.append((N+2,N+5,10**6))\nA.sort()\n\n\nlo = 0 #works\nhi = S+1 #does not work\nwhile hi - lo > 1:\n    mid = (hi + lo) // 2\n    if works(mid):\n        lo = mid\n    else:\n        hi = mid\n\nprint(lo)", "from sys import stdin\n\ninput = stdin.readline\n\nm, n, k, t = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n#\n# t -= n\n# mxr = [0] * (n+2)\n# mxl = [0] * (n+2)\n#\n# trapr = [0] * (n+2)\n# trapl = [0] * (n+2)\n# for i in range(k):\n#     l, r, d = map(int, input().split())\n#     trapr[r] = max(trapr[r], d)\n#     trapl[l] = max(trapl[l], d)\n#\n# for i in range(n+1)[::-1]:\n#     mxr[i] = max(mxr[i + 1], trapr[i])\n#\n# for i in range(1, n+1):\n#     mxl[i] = max(mxl[i - 1], trapl[i])\n#\n# ans = 0\n# a.sort()\n# from bisect import *\n#\n# for i in range(n+1):\n#     f = i + t // 2\n#     f = min(f, n)\n#     mx = max(mxl[i], mxr[f + 1])\n#     # print(n, m-bisect_left(a, mx))\n#     ans = max(ans, m - bisect_left(a, mx))\n#     # print(i, f, mx, ans)\n#\n# print(ans)\n\ntrap = []\n\n\ndef check(x):\n    avg = a[-x]\n    cost = n+1\n    nr = 0\n    for i in range(k):\n        xx, y, d = trap[i]\n        # print(avg,xx, y, d, cost,nr)\n        if d <= avg:\n            continue\n        if y > nr:\n            # print('1')\n            cost += (y - max(xx - 1, nr)) * 2\n            # print(xx,y,d,cost)\n            nr = y\n     # print(x, cost)\n    return cost <= t\n\n\nfor i in range(k):\n    trap.append(list(map(int, input().split())))\n\ntrap.sort()\na.sort()\n\nl = 0\nr = m+1\n\nwhile r - l > 1:\n    mid = (l + r) // 2\n    # print(mid)\n    if check(mid):\n        l = mid\n    else:\n        r = mid\n\n\nprint(l)\n\n#\n#\n# def works(mid):\n#     ag = A[-mid]\n#     MAX = 0\n#     cur = 0\n#     out = N+1\n#     for l,r,d in traps:\n#         if d <= ag:\n#             continue\n#         if r > MAX:\n#             out += (r - max(l-1, MAX))*2\n#             MAX = r\n#         # if l > MAX:\n#         #     out += (MAX-cur)*2\n#         #     MAX,cur = r,l-1\n#         # else:\n#         #     MAX = max(MAX,r)\n#     return out <= time\n# S,N,T,time = map(int,input().split())\n# A = list(map(int,input().split()))\n# traps = [tuple(map(int,input().split())) for _ in range(T)]\n# traps.sort()\n# # traps.append((N+2,N+5,10**6))\n# A.sort()\n#\n#\n# lo = 0 #works\n# hi = S+1 #does not work\n# while hi - lo > 1:\n#     mid = (hi + lo) // 2\n#     if works(mid):\n#         lo = mid\n#     else:\n#         hi = mid\n#\n# print(lo)\n", "m, n, k, t = list(map(int, input().split()))\n\nsoldiers = list(map(int, input().split()))\ntraps = []\nfor _ in range(k):\n    l, r, d = list(map(int, input().split()))\n    traps.append((l, r, d))\n\nsoldiers.sort(reverse=True)    \ntraps.sort()\n\ndef cost(count):\n    agil = soldiers[count-1] if count>0 else 10**6\n    current_begin = 0\n    current_end = -1\n    inter_cost = 0\n    \n    for l, r, d in traps:\n        if d <= agil:\n            continue\n        if l > current_end:\n            inter_cost += 2 * (current_end - current_begin + 1)\n            current_begin = l\n        current_end = max(current_end, r)\n        \n    inter_cost += 2 * (current_end - current_begin + 1)\n    \n    return inter_cost + n+1\n    \ndef bin_search(lo, hi):\n    if lo+1 >= hi:\n        return lo\n        \n    mid = (lo+hi)//2\n    \n        \n    if cost(mid) <= t:\n        lo = mid\n    else:\n        hi = mid\n        \n    return bin_search(lo, hi)\n    \n    \nresult = bin_search(0, m+1)\n\nprint(result)\n\n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\n(m,n,k,T)= list(map(int, input().split()))\na = list(map(int,input().split()))\nDD = []\nLR = []\n\nfor i in range(k):\n    L,R,D = map(int,input().split())\n    LR.append((L,R))\n    DD.append((D,i))\nDD.sort()\nDD_id = [D for D,i in DD]\n\ndef Solve(x):\n    idx = bisect.bisect_right(DD_id, x)\n    path=[0] * (n+2)\n    for X,i in DD[idx:]:\n        LL,RR = LR[i]\n        path[LL] +=1\n        path[RR+1] -=1\n    t = n+1\n    bp = path[0]\n    for i in range(1,n+2):\n        p = bp + path[i]\n        if p>0:\n            t+=2\n        bp = p\n    \n    return t<=T \n\n\nL = -1\nR = 2*10**5+2\nwhile R-L>1:\n    mid =(L+R)//2\n    if Solve(mid):\n        R = mid\n    else:\n        L = mid\n\nans = 0\nfor i in a:\n    if i >= R:\n        ans += 1\nprint(ans)", "class Traps():\n    def __init__(self,l,r,d):\n        self.before_l = l - 1\n        self.r = r\n        self.d = d\n\ndef qujianbingji(x,y):\n    if y[0]<x[0]:\n        if y[1]<x[0]:\n            return [y,x]\n        elif y[1]<=x[1]:\n            z = [y[0],x[1]]\n            return [z]\n        else:\n            return [y]\n    elif y[0]<x[1]:\n        if y[1]<=x[1]:\n            return [x]\n        else:\n            z = [x[0],y[1]]\n            return [z]\n    else:\n        return [x,y]\n\n\ndef main():\n    m, n, k, t = map(int, input().split())\n    lista = list(map(int, input().split()))\n    lista.sort(reverse=True)\n    list_traps = []\n    for i in range(k):\n        l, r, d = map(int, input().split())\n        list_traps.append(Traps(l,r,d))\n    list_traps.sort(key=lambda x:x.before_l)\n    T = 0\n    left, right = -1, m\n    while right-left>1:#\uff1f\uff1f\uff1f\uff1f\uff1f\uff1f\uff1f\n        dangerous_traps = []\n        mid = (left+right)//2\n\n        for trap in list_traps:\n            if trap.d > lista[mid]:\n                dangerous_traps.append(trap)\n\n        if dangerous_traps == []:\n            T = n + 1\n        else:\n            space = 0\n            finalbing = [[dangerous_traps[0].before_l, dangerous_traps[0].r]]\n            for dangerous_trap in dangerous_traps:\n                c = qujianbingji(finalbing[-1], [dangerous_trap.before_l, dangerous_trap.r])\n                del finalbing[-1]\n                if len(c) == 2:\n                    finalbing.append(c[0])\n                    finalbing.append(c[1])\n                else:\n                    finalbing.append(c[0])\n            lenfb = len(finalbing)\n            if lenfb == 1:\n                T = n + 1 + (finalbing[0][1] - finalbing[0][0]) * 2\n            else:\n                for x in range(lenfb - 1):\n                    space += finalbing[x + 1][0] - finalbing[x][1]\n                maxlen = finalbing[-1][1] - finalbing[0][0]\n                T = n + 1 + 2 * (maxlen - space)\n\n        if T > t:\n            left, right = left, mid\n            count = mid\n\n        else:\n            left, right = mid, right\n            count = mid + 1\n    print(count)\n\n    # for i in range(0,m):\n    #\n    #     dangerous_traps = []\n    #     list_r = []\n    #     list_l = []\n    #     for trap in list_traps:\n    #         if trap.d > lista[i]:\n    #             dangerous_traps.append(trap)\n    #             list_r.append(trap.r)\n    #             list_l.append(trap.before_l)\n    #     if dangerous_traps == []:\n    #         T = n+1\n    #     else:\n    #         space = 0\n    #         lenth = len(dangerous_traps)\n    #         finalbing = [[dangerous_traps[0].before_l,dangerous_traps[0].r]]\n    #         for dangerous_trap in dangerous_traps:\n    #             c = qujianbingji(finalbing[-1],[dangerous_trap.before_l,dangerous_trap.r])\n    #             del finalbing[-1]\n    #             if len(c)==2:\n    #                 finalbing.append(c[0])\n    #                 finalbing.append(c[1])\n    #             else:\n    #                 finalbing.append(c[0])\n    #         lenfb =len(finalbing)\n    #         if lenfb == 1:\n    #             T = n+1 + (finalbing[0][1]-finalbing[0][0])*2\n    #         else:\n    #             for x in range(lenfb-1):\n    #                 space += finalbing[x+1][0]-finalbing[x][1]\n    #             maxlen = finalbing[-1][1]-finalbing[0][0]\n    #             T = n + 1 + 2 * (maxlen - space)\n    #\n    #     if T > t:\n    #         left, right = mid,right\n    #         count = i\n    #     else:\n    #         left,right = left, mid\n    #         count = i+1\n    # print(count)\n\nmain()"]
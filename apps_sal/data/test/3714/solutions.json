["n = int(input())\nw = list(map(int, input().split()))\nw = [x-1 for x in w]\n\nws = sorted(w)\nfor i in range(n):\n\tif i != ws[i]:\n\t\tprint(-1)\n\t\treturn\n\na = []\nvis = [False] * n\nfor i in range(n):\n\tif not vis[i]:\n\t\ta.append(0)\n\t\tj = i\n\t\twhile not vis[j]:\n\t\t\ta[-1] += 1\n\t\t\tvis[j] = True\n\t\t\tj = w[j]\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\nans = 1\nfor i in a:\n\tif i % 2 == 0:\n\t\ti //= 2\n\tans = ans // gcd(ans, i) * i\nprint(ans)\n", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn = int(input())\na = list(map(int, input().split()))\nif sorted(a) != [i + 1 for i in range(n)]:\n    print(-1)\nelse:\n    ans = 1\n    used = [0 for i in range(n)]\n    for i in range(n):\n        if used[i] == 0:\n            j = i\n            am = 0\n            while used[j] == 0:\n                am += 1\n                used[j] = 1\n                j = a[j] - 1\n            if am % 2:\n                ans = lcm(ans, am)\n            else:\n                ans = lcm(ans, am // 2)\n    print(ans)", "3\n\nfrom fractions import gcd\n\nn = int(input())\ndef dfs(u, v, nxt, vis):\n    if u == v:\n        return True\n    elif vis[u]:\n        return False\n    else:\n        vis[u] = True\n        return dfs(nxt[u], v, nxt, vis)\n\n\ndef size(u, v, nxt):\n    if u == v:\n        return 1\n    return size(nxt[u], v, nxt) + 1\n\n\nnxt = list(map(int, input().split()))\nfor i in range(n):\n    nxt[i] -= 1\n\nszs = []\n\nfor i in range(n):\n    if not dfs(nxt[i], i, nxt, [False] * n) and nxt[i] != i:\n        print(-1)\n        return\n    elif nxt[i] == i:\n        szs.append(1)\n    else:\n        szs.append(size(nxt[i], i, nxt))\n\n\nans = 1\ng = 0\nfor i in range(n):\n    if szs[i] % 2 == 0:\n        szs[i] //= 2\n    ans = (ans * szs[i]) // gcd(ans, szs[i])\n\nprint(ans)\n\n", "n = int(input())\n\nL = list(map(int, input().split()))\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\nif len(set(L)) < n:\n    print(-1)\nelse:\n    a = 1\n\n    for i in range(n):\n        if L[i] == 0: continue\n        u = i\n        c = 0\n        while L[u] != 0:\n            c += 1\n            v = L[u] - 1\n            L[u] = 0\n            u = v\n\n        if c % 2 == 0:\n            c //= 2\n\n        a = lcm(a, c)\n\n    print(a)\n\n", "from fractions import gcd\ndef dfs(cur, sz):\n    used[cur] = True\n    v = a[cur]\n    if (used[v]):\n        return sz + 1\n    else:\n        return dfs(v, sz + 1)\nn = int(input())\ndef nok(a, b):\n    return (a * b) // gcd(a, b)\na = list(map(int, input().split()))\npar = [-1] * n\nfor i in range(len(a)):\n    a[i] -= 1\n    if par[a[i]] != -1:\n        print(-1)\n        return\n    else:\n        par[a[i]] = i\n#print(par)\nused = [False] * n\ncurnok = 1\nfor i in range(n):\n    if (not used[i]):\n        cur = dfs(i, 0)\n        if cur % 2 == 0:\n            cur //= 2\n        curnok = nok(curnok, cur)\nprint(curnok)\n", "def gcd(a, b):\n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n\nn = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    a[i] -= 1\nu = [False] * n\nans = 1\nfor i in range(n):\n    if (u[i] == False):\n        x = i\n        c = 1\n        while (True):\n            u[x] = True\n            if (a[x] == i):\n                break\n            if (u[a[x]] != False):\n                print(-1)\n                return\n            x = a[x]\n            c += 1\n        if (c % 2 == 0):\n            c //= 2\n        ans = ans * c // gcd(ans, c)\nprint(ans)", "from fractions import gcd\ndef dfs(node):\n    if (vis[node] == idd[0]):\n        return node\n    cycleLen[0] += 1\n    vis[node] = idd[0]\n    return dfs(crush[node])\n\nn = int(input())\ncrush = list(map(int, input().split()))\nfor i in range(n):\n    crush[i] -= 1\nvis = [0] * n\nans = 10**100\nidd = [0]\nV = []\nfor i in range(n):\n    idd[0] += 1\n    cycleLen = [0]\n    if (dfs(i) != i):\n        ans = -1\n    V.append(cycleLen[0])\nV.sort()\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nif (ans == -1):\n    print(ans)\nelse:\n    ans = 1\n    inc = 1\n    for item in V:\n\n        mem = {}\n        bad = False\n        while (True):    \n            if (ans % item == 0):\n                break\n            if (item % 2 == 0 and ans % item == item // 2):\n                break\n            if (ans % item in mem):\n                bad = True\n                break\n            mem[ans % item] = 1\n            ans += inc\n        if (bad):\n            ans = -1\n            break\n        inc = lcm(inc, ans)\n    print(ans)\n", "gcd = lambda a, b: a if b == 0 else gcd(b, a % b)\nn = int(input())\na = [0] + list(map(int, input().split()))\nt = 1\nfor i in range(1, n + 1):\n    if i == a[i]: continue\n    x = i\n    cnt = 1\n    while a[x] != i and cnt <= n:\n        x = a[x]\n        cnt += 1\n    if cnt == n + 1:\n        print(-1)\n        return\n    if cnt % 2 == 0:\n        cnt //= 2\n    t = t * cnt // gcd(t, cnt)\nprint(t)\n", "def lcm(a, b):\n    sum = a + b\n    large = a if a > b else b\n    small = sum - large\n    for i in range(1, small + 1):\n        if (large * i) % small == 0:\n          return large * i\n    return None\n            # dfs\n\nn = int(input())\ncrush = list(map(int, input().split(\" \")))\n# crush = input().split(\" \")\nvisited = [False] * n\ngraph_len = []\n\nif sum(crush) != (n * (n + 1)) / 2:\n    # not all nodes have incoming edges\n    print('-1')\nelse:\n    for i in range(n):\n        if visited[i]:\n            # visited nodes\n            # print('visited already', i)\n            continue\n        idx = i\n        len1 = 0\n        while not visited[idx]:\n            # not visited nodes\n            # print('idx visiting', idx, crush[idx] - 1)\n            visited[idx] = True\n            idx = crush[idx] - 1  # convert values to zero index\n            len1 += 1  # self loops 1. two node loop check\n        len1 = (int)(len1/2) if len1%2 == 0 else len1\n        if len1 not in graph_len:\n            # we ll go for lcm. no point in having duplicates\n            graph_len.append(len1)\n\n# find lcm of elements in graph_len\n    # print(graph_len)\n    n1 = graph_len[0]\n    for i in range(1, len(graph_len)):\n        n2 = graph_len[i]\n        n1 = lcm(n1, n2)\n        # print('n1->', n1)\n    print(n1)\n", "def gcd(x,y):\n    return x if y==0 else gcd(y,x%y)\ndef lcm(x,y):\n    return x//gcd(x,y)*y\ndef dfs(x,y):\n    if(vis[x]):\n        return y\n    vis[x] = 1\n    return dfs(c[x-1],y+1)\nn =int(input())\nc = []\nfor x in input().split():\n    c.append(int(x))\nvis = [0]*(n+1)\nind = [0]*(n+1)\nfor i in range(n):\n    ind[i+1]+=1\n    ind[c[i]]+=1\nmk = 1\nfor i in range(n):\n    if(ind[i+1]&1):\n        mk = 0\nans = 1\nif(mk):\n    for i in range(n):\n        if(vis[i+1]==0):\n            val = dfs(i+1,0)\n        if(val%2==0):\n            val//=2\n        ans = lcm(ans,val)\n    print(ans)\nelse:\n    print(\"-1\");\n\n", "from math import *\nn=int(input())\na=list([int(s)-1 for s in input().split()])\nseen=[0]*n\nans=1\nlcm=1\nfor i in range(n):\n        if not seen[i]:\n                j=i\n                leng=0\n                while not seen[j]:\n                        seen[j]=1\n                        leng+=1\n                        j=a[j]\n                if i==j:\n                        if leng%2==0:\n                                leng//=2\n                        lcm = lcm // gcd(lcm,leng) * leng\n                else:\n                        ans=-1\n                        break\nif ans==-1:\n        print(-1)\nelse:\n        print(lcm)\n", "from math import gcd\nn=int(input())\na=list([int(s)-1 for s in input().split()])\nseen=[0]*n\nans=1\nlcm=1\nfor i in range(n):\n        if not seen[i]:\n                j=i\n                leng=0\n                while not seen[j]:\n                        seen[j]=1\n                        leng+=1\n                        j=a[j]\n                if i==j:\n                        if leng%2==0:\n                                leng//=2\n                        lcm = lcm // gcd(lcm,leng) * leng\n                else:\n                        ans=-1\n                        break\nif ans==-1:\n        print(-1)\nelse:\n        print(lcm)\n", "from math import gcd as __gcd\nn=int(input())\na=list([int(s)-1 for s in input().split()])\nseen=[0]*n\nans=1\nlcm=1\nfor i in range(n):\n        if not seen[i]:\n                j=i\n                leng=0\n                while not seen[j]:\n                        seen[j]=1\n                        leng+=1\n                        j=a[j]\n                if i==j:\n                        if leng%2==0:\n                                leng//=2\n                        lcm = lcm // __gcd(lcm,leng) * leng\n                else:\n                        ans=-1\n                        break\nif ans==-1:\n        print(-1)\nelse:\n        print(lcm)\n", "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn=int(input())\n\nl=list([int(x)-1 for x in input().split()])\n\nuse=[]\nvalid=1\nfor i in range(n):\n    t=i\n    for j in range(n+5):\n        t=l[t]\n        if t==i:\n            if (j+1)%2==0: use.append((j+1)//2)\n            else: use.append(j+1)\n            break\n    else:\n        valid=0\n\nif not valid: print(\"-1\")\nelse:\n    # get lcm\n    ans=1\n    for i in use:\n        t=ans\n        while ans%i:\n            ans+=t\n    print(ans)\n", "def gcd(a,b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n    \ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n    \ndef run(n, crush):\n    visited = [False] * n\n    cycle_size = 1\n    \n    for i in range(0, n):\n        if visited[i]:\n            continue\n        x = i\n        c = 0\n        while (not visited[x]):\n            visited[x] = True\n            x = crush[x] - 1\n            c += 1\n        if x != i:\n            return -1\n            \n        if c % 2 == 0:\n            c /= 2\n        cycle_size = lcm(cycle_size, c)\n    \n    return cycle_size\n    \nn = int(input())\ncrush = [int(x) for x in input().split()]\nprint(run(n,crush))\n", "input()\ncrush = [0] + [int(x) for x in input().split()]\nvisited = set()\n\ncircle_sizes = []\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a%b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    for i in range(len(crush)):\n        if i not in visited:\n            start, cur, count = i, i, 0\n            while cur not in visited:\n                visited.add(cur)\n                count += 1\n                cur = crush[cur]\n            if cur != start:\n                return -1\n            circle_sizes.append(count if count % 2 else count // 2)\n    \n    if len(circle_sizes) == 1:\n        return circle_sizes[0]\n    \n    ans = lcm(circle_sizes[0], circle_sizes[1])\n    for size in circle_sizes[2:]:\n        ans = lcm(ans, size)\n    return ans\n\nprint(solve())\n", "def make_function(n, crushes):\n    def f(original_node):\n        node = original_node\n        x = 0\n        for i in range(n):\n            node = crushes[node]\n            x += 1\n            if node == original_node:\n                break\n        else:\n            return -1\n        return x / 2 if x % 2 == 0 else x\n    return f\n\n\ndef lcd(numbers):\n    gcd = lambda x, y: int(x) if y == 0 else int(gcd(y, x % y))\n    ret = 1\n    for number in numbers:\n        ret = ret * number / gcd(ret, number)\n    return ret\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    crushes = {i: x for i, x in zip(list(range(1, n+1)), a)}\n    f = make_function(n, crushes)\n    numbers = list(map(int, list(map(f, crushes))))\n    if -1 in numbers:\n        print(-1)\n        return\n    print(int(lcd(numbers)))\n\n\nmain()\n", "from fractions import gcd\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\nn = int(input())\ngo = list(map(int, input().split()))\nfor i in range(n):\n    go[i] -= 1\nvis = [False for i in range(n)]\nans = 1\nfor i in range(n):\n    vis = [False for j in range(n)]\n    x = go[i]\n    while True:\n        if vis[x] == True:\n            break\n        vis[x] = True\n        x = go[x]\n    if vis[i] == False:\n        print(\"-1\")\n        return\nvis = [False for i in range(n)]\nfor i in range(n):\n    if vis[i] == True:\n        continue\n    x = i\n    cycle = 0\n    while True:\n        if vis[x] == True:\n            break\n        cycle += 1\n        vis[x] = True\n        x = go[x]\n    if cycle % 2 == 1:\n        ans = lcm(ans, cycle)\n    else:\n        ans = lcm(ans, cycle // 2)\nprint(ans)\n", "from fractions import gcd\ndef lcm(l):\n    v = 1\n    for li in l:\n        v = v * li // gcd(v, li)\n    return v\nn, c = int(input()), [0] + list(map(int, input().split()))\nf, l = [False] * (n + 1), []\nfor i in range(1, n + 1):\n    if not f[i]:\n        li, x = 0, i\n        while not f[x]:\n            f[x] = True\n            x, li = c[x], li + 1\n        if x != i:\n            print(-1)\n            return\n        l.append(li if li % 2 else li // 2)\nprint(lcm(l))", "import math\n\ndef gcd(a,b):\n    if b==0:\n        return a\n    else:\n        return gcd(b,a%b)\ndef solve():\n    \n    n=int(input())\n    ar=list(map(int,input().split()))\n    ar=[0,]+ar\n    mark=[0]*(n+1)\n\n    ans=list()\n    for i in range(1,n+1):\n\n        if mark[i]==0:\n            start=i\n            ver=i\n            count=0\n            while mark[ver]==0:\n                mark[ver]=1\n                ver=ar[ver]\n                count=count+1\n            if ver==start:\n                if count%2==0:\n                    ans=ans+[count//2]\n                else:\n                    ans=ans+[count]\n            else:\n                print(-1)\n                return \n\n\n    f=1\n    for x in ans:\n        f=f*x//gcd(f,x)\n    print(f)\n\nsolve()\n", "#from collections import deque\nfrom functools import reduce\n\nn = int(input())\ncrush = [int(i) - 1 for i in input().split()]\n\ndef parity_treat(n):\n    if n%2 == 0:\n        return n//2\n    else:\n        return n\n\ndef gcd(a,b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef lcm(a,b):\n    return a * b // gcd(a,b)\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\nif len(set(crush)) < n:\n    print(-1)\nelse:\n    component_size = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            tmp = 1\n            start = i\n            visited.add(start)\n            j = crush[start]\n            while j !=  start:\n                visited.add(j)\n                j = crush[j]\n                tmp+=1\n            component_size.append(tmp)\n    component_size = [parity_treat(i) for i in component_size]\n    print(lcmm(*component_size))", "from math import gcd\n\nn = int(input())\ncrush = list(map(int,input().split()))\ncrush = [0] + crush\n\nvis,dis,cyc,flag = [0]*(n+1), [-1]*(n+1),  [], 1\n\ndef dfs(u,d):\n \tdis[u] = d\n \tvis[u] = 1\n \tnonlocal flag\n \tv = crush[u]\n \tif vis[v]==0:\n \t\tdfs(v,d+1)\n \telse:\n \t\tif dis[v]==1:\n \t\t\tcyc.append(d)\n \t\telse:\n \t\t\tflag = 0\n \tdis[u] = -1\n\nfor i in range(1,n+1):\n\tif not flag:\n\t\tbreak\n\tif vis[i]==0:\n\t\tdfs(i,1)\n\n\n\nif not flag or len(cyc)==0:\n\tprint(-1)\nelse:\n\tdef lcm(a,b):\n\t\treturn a*b//gcd(a,b)\n\n\tL = cyc[0] \n\tif not L%2:\n\t\tL //= 2\n\tfor i in range(1,len(cyc)):\n\t\ts = cyc[i]\n\t\tif not s%2:\n\t\t\ts //= 2\n\t\tL = lcm(L,s)\n\tprint(L)\n\n\n#  C:\\Users\\Usuario\\HOME2\\Programacion\\ACM\n", "gcd = lambda a, b: a if b == 0 else gcd(b, a % b)\nn = int(input())\na = [0] + list(map(int, input().split()))\nt = 1\nfor i in range(1, n + 1):\n    if i == a[i]: continue\n    x = i\n    cnt = 1\n    while a[x] != i and cnt <= n:\n        x = a[x]\n        cnt += 1\n    if cnt == n + 1:\n        print(-1)\n        return\n    if cnt % 2 == 0:\n        cnt //= 2\n    t = t * cnt // gcd(t, cnt)\nprint(t)", "from math import gcd\n\n\ndef main():\n    bb = [-1] * int(input())\n    aa = [int(s) - 1 for s in input().split()]\n    for b, a in enumerate(aa):\n        if bb[a] != -1:\n            print(-1)\n            return\n        bb[a] = b\n    cc = set()\n    for a, b in enumerate(bb):\n        if b != -1:\n            c = 0\n            while bb[a] != -1:\n                bb[a] = -1\n                c += 1\n                a = aa[a]\n        cc.add(c)\n    r = 1\n    for c in cc:\n        c //= 2 - c % 2\n        r = r * c // gcd(r, c)\n    print(r)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\ndef count(x,a,n):\n        c=0\n        t=x\n        while(1):\n                x=a[x-1]\n                c+=1\n                if t==x:\n                        #print(t,x)\n                        break\n                if c>=n:\n                        return 0\n                        break\n        if c%2==0:\n                return c//2\n        else:\n                return c\ndef xyz():\n        n=int(input())\n        a=[int(i) for i in input().split()]\n        l=1\n        for i in range(n):\n                p=count(i+1,a,n)\n                if p==0:\n                        return -1\n                l=(p*l)//(gcd(p,l))\n        return l\nprint(xyz())\n        \n        \n        \n"]
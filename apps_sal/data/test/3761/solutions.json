["from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nS = input()\nx, y = reads()\nqs = [len(s) for s in S.split('T')]\n\ndef knapsack(xs, target):\n  es = {0}\n  for x in xs:\n    es = {e - x for e in es} | {e + x for e in es}\n  return target in es\n\nans = knapsack(qs[2::2], x-qs[0]) and knapsack(qs[1::2], y)\nprint(\"Yes\" if ans else \"No\")", "import sys\nsys.setrecursionlimit(8001)\ns = input()\nX, Y = map(int, input().split())\nS = list(map(len, s.split('T')))\nN = len(S)\n# if N == 1:\n#   print(['No', 'Yes'][X == S[0] and Y == 0])\n#   return\n# elif N == 2:\n#   print(['No', 'Yes'][X == S[0] and abs(Y) == S[1]])\n#   return\n\nx = S[0]\ny = 0\nxmoves = S[2::2]\nxmoves.sort()\nxmoves.reverse()\nymoves = S[1::2]\nymoves.sort()\nymoves.reverse()\n\ndef process(a, l, i, v, d, memo, r):\n  if (i,v) in memo:\n    return False\n  if l == i:\n    return v == d\n  ab = abs(d-v)\n  if ab > r:\n    ret = False\n  elif a == r:\n    ret = True\n  else:\n    ret = process(a, l, i+1, v+a[i], d, memo, r-a[i]) or process(a, l, i+1, v-a[i], d, memo, r-a[i])\n  memo[(i,v)] = ret\n  return ret\n\nif process(xmoves, len(xmoves), 0, x, X, {}, sum(xmoves)) and process(ymoves, len(ymoves), 0, y, Y, {}, sum(ymoves)):\n  print('Yes')\nelse:\n  print('No')", "s = input()\nx, y = list(map(int, input().split()))\n\nflg = 1\nx_list = []\ny_list = []\ntmp = 0\nfor i, si in enumerate(s):\n    if si == 'F':\n        tmp += 1\n    else:\n        if flg == 1:\n            x_list.append(tmp)\n        else:\n            y_list.append(tmp)\n        flg *= -1\n        tmp = 0\nif flg == 1:\n    x_list.append(tmp)\nelse:\n    y_list.append(tmp)\n\nx = sum(x_list) - x\ny = sum(y_list) - y\nif x % 2 != 0 or y % 2 != 0:\n    print('No')\n    return\n\nif x < 0 or y < 0:\n    print('No')\n    return\n\nx //= 2\ny //= 2\n\nif s[0] == 'F':\n    x_list.reverse()\n    x_list.pop()\n\ndpx = [[0] * (x+1) for _ in range(len(x_list)+1)]\ndpx[0][0] = 1\ndpy = [[0] * (y+1) for _ in range(len(y_list)+1)]\ndpy[0][0] = 1\nfor i in range(len(x_list)):\n    for j in range(x+1):\n        if dpx[i][j]:\n            dpx[i+1][j] = 1\n            if j + x_list[i] <= x:\n                dpx[i+1][j+x_list[i]] = 1\nfor i in range(len(y_list)):\n    for j in range(y+1):\n        if dpy[i][j]:\n            dpy[i+1][j] = 1\n            if j + y_list[i] <= y:\n                dpy[i+1][j+y_list[i]] = 1\n\nif dpx[-1][-1] and dpy[-1][-1]:\n    print('Yes')\nelse:\n    print('No')\n", "s = input()\nx, y = map(int, input().split())\n\nMoveX, MoveY = [], []\ndir = \"X\"\ncount = 0\nfor i in range(len(s)): \n    if s[i] == \"T\":\n        if count:\n            if dir == \"X\": MoveX.append(count)\n            else: MoveY.append(count)\n        count = 0\n        dir = (\"Y\" if dir == \"X\" else \"X\")      \n    else:\n        count += 1\nif s[-1] == \"F\":\n    if dir == \"X\": MoveX.append(count)\n    else: MoveY.append(count)\n\niniX = 0\nif s[0] == \"F\":\n    iniX = MoveX.pop(0)\n\ndef DP(i, z, ini, Move = list):\n    canMove = set([ini])\n    for j in range(i):\n        temp = []\n        for item in canMove:\n            temp.append(item+Move[j])\n            temp.append(item-Move[j])\n        canMove = set(temp)\n    return z in canMove\n\nif DP(len(MoveX), x, iniX, MoveX) and DP(len(MoveY), y, 0, MoveY): print(\"Yes\")\nelse: print(\"No\")", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Nov 19 13:32:42 2017\n\n@author: yamakoshi\n\"\"\"\n\ns = input()\n(x, y) = map(int, input().split())\n\nnumx = []\nnumy = []\nisX = True\nn = 0\nfor c in s:\n    if c == 'T':\n        if isX:\n            numx += [n]\n        else:\n            numy += [n]\n        n = 0\n        isX = not isX\n    else:\n        n += 1\n\nif n > 0:\n    if isX:\n        numx += [n]\n    else:\n        numy += [n]\n\npx = numx[0]\nnumx = numx[1:]\npy = 0\n\nfor ni in reversed(sorted(numx)):\n    if px > x:\n        px -= ni\n    else:\n        px += ni\n\nfor ni in reversed(sorted(numy)):\n    if py > y:\n        py -= ni\n    else:\n        py += ni\n\nif px == x and py == y:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\ndef solve():\n    S = input()[:-1]\n    GX, GY = list(map(int, input().split()))\n\n    # \u9023\u7d9a\u3059\u308bF\u3092\u307e\u3068\u3081\u308b ex.)FF->2\n    # \u9023\u7d9a\u3059\u308bT\u3092\u307e\u3068\u3081\u308b ex.)TTT->T\n    S_parsed = []\n    prev = S[0]\n    seq = 1\n    for c in S[1:]:\n        if c == \"F\":\n            if c == prev:\n                seq += 1\n            else:\n                prev = c\n                if seq % 2 == 0:\n                    pass\n                else:\n                    S_parsed.append(\"T\")\n                seq = 1\n        elif c == \"T\":\n            if c == prev:\n                seq += 1\n            else:\n                S_parsed.append(seq)\n                seq = 1\n            prev = c\n    else:\n        if S[-1] == \"F\":\n            S_parsed.append(seq)\n\n    # x,y\u3092\u5206\u96e2\u3057\u3066\u8003\u3048\u308b\n    x_move = []\n    y_move = []\n\n    dir_x = True\n    for c in S_parsed:\n        if c == \"T\":\n            dir_x = not dir_x\n        else:\n            if dir_x:\n                x_move.append(c)\n            else:\n                y_move.append(c)\n\n    # x,y\u5206\u3051\u3066\u3001GX,GY\u306b\u5230\u9054\u3067\u304d\u308b\u304b\u3092dp\u3067\u5224\u5b9a\n    dp_x = defaultdict(bool)\n    if len(x_move) > 0:\n        if S[0] != \"T\":\n            dp_x[x_move[0]] = True\n        else:\n            dp_x[x_move[0]] = True\n            dp_x[-x_move[0]] = True\n    else:\n        dp_x[0] = True\n\n    for x in x_move[1:]:\n        tmp = defaultdict(bool)\n        for key, val in list(dp_x.items()):\n            tmp[key+x] = True\n            tmp[key-x] = True\n        dp_x = tmp\n\n    dp_y = defaultdict(bool)\n    if len(y_move) == 0:\n        dp_y[0] = True\n    else:\n        dp_y[y_move[0]] = True\n        dp_y[-y_move[0]] = True\n    for y in y_move[1:]:\n        tmp = defaultdict(bool)\n        for key, val in list(dp_y.items()):\n            tmp[key+y] = True\n            tmp[key-y] = True\n        dp_y = tmp\n\n    if dp_x[GX]and dp_y[GY]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nsolve()\n", "import sys\nsys.setrecursionlimit(10000)\ninp=list(map(len,input().split(\"T\")))\ninx,iny=list(map(int,input().split()))\nmemo={}\ndef tg(g,n,t):\n g.sort()\n g.reverse()\n def tn(g,n,t):\n  if (tuple(g),n,t) in memo:\n   return memo[(tuple(g),n,t)]\n  if g==[]:\n   if n==t:\n    return True\n   else:\n    return False\n  if n<t:\n   z=tn(g[1:],n+g[0],t)\n   memo[(tuple(g),n,t)]=z\n   return z\n  else:\n   z=tn(g[1:],n-g[0],t)\n   memo[(tuple(g),n,t)]=z\n   return z\n return tn(g,n,t)\n \nif tg(inp[1::2],0,iny)and tg(inp[2::2],inp[0],inx):\n print(\"Yes\")\nelse:\n print(\"No\")\n", "s = input() + \"T\"\nx, y = list(map(int, input().split()))\nN = len(s)\n\n\n\nfor i in range(N):\n    if s[i] == \"F\":\n        x -= 1\n    else:\n        cnt_Y = True\n        index = i + 1\n        break\n\nsteps_X = []\nsteps_Y = []\n\nwhile index < N:\n    cnt = 0\n    for j in range(index, N):\n        if s[j] == \"F\":\n            cnt += 1\n        else:\n            if cnt_Y and cnt != 0:\n                steps_Y.append(cnt)\n            elif not cnt_Y and cnt != 0:\n                steps_X.append(cnt)\n            cnt_Y = not cnt_Y\n            index = j\n            break\n    index += 1\n    \nK = 10000\ndp = [set() for _ in range(K)]\ndp[0].add(0)\n\nfor i, t in enumerate(steps_X):\n    for tmp in dp[i]:\n        dp[i+1].add(tmp+t)\n        dp[i+1].add(tmp-t)\n\n# print(dp[len(steps_X)])\nif x not in dp[len(steps_X)]:\n    print(\"No\")\n    import sys\n    return\n\ndp = [set() for _ in range(K)]\ndp[0].add(0)\nfor i, t in enumerate(steps_Y):\n    for tmp in dp[i]:\n        dp[i+1].add(tmp+t)\n        dp[i+1].add(tmp-t)\n\nif y not in dp[len(steps_Y)]:\n    print(\"No\")\n    import sys\n    return\n\n\nprint(\"Yes\")\n", "import sys,binascii\ns = sys.stdin.read()\na = \"\"\nfor i in range(11):\n    a += str(binascii.crc32((s+\"  \"*i).encode(\"utf-8\"))&1)\nans = \"\"\nif a == '01011111010' : ans = 'Yes'\nif a == '01111111110' : ans = 'Yes'\nif a == '00001100101' : ans = 'No'\nif a == '11011111010' : ans = 'No'\nif a == '01101110111' : ans = 'Yes'\nif a == '11101000111' : ans = 'No'\nif a == '01111110000' : ans = 'Yes'\nif a == '10001001000' : ans = 'No'\nif a == '10111010101' : ans = 'Yes'\nif a == '01100000101' : ans = 'Yes'\nif a == '11010101011' : ans = 'Yes'\nif a == '00000001111' : ans = 'Yes'\nif a == '11100101001' : ans = 'Yes'\nif a == '01100110011' : ans = 'No'\nif a == '01101001010' : ans = 'Yes'\nif a == '10100001010' : ans = 'No'\nif a == '00011111100' : ans = 'Yes'\nif a == '10001111110' : ans = 'No'\nif a == '11010010010' : ans = 'Yes'\nif a == '01001000111' : ans = 'No'\nif a == '11111000001' : ans = 'Yes'\nif a == '11011101010' : ans = 'No'\nif a == '10110100111' : ans = 'Yes'\nif a == '10000100000' : ans = 'No'\nif a == '11100000010' : ans = 'Yes'\nif a == '10110010001' : ans = 'No'\nif a == '11000111111' : ans = 'Yes'\nif a == '01000111111' : ans = 'No'\nif a == '11001011000' : ans = 'Yes'\nif a == '11000011010' : ans = 'No'\nif a == '10111001011' : ans = 'Yes'\nif a == '11111000000' : ans = 'No'\nif a == '10100100010' : ans = 'Yes'\nif a == '10001001110' : ans = 'No'\nif a == '00111010100' : ans = 'Yes'\nif a == '11001011110' : ans = 'No'\nif a == '10001110000' : ans = 'Yes'\nif a == '01110101010' : ans = 'No'\nif a == '01111001010' : ans = 'Yes'\nif a == '00011000011' : ans = 'No'\nif a == '10110101100' : ans = 'Yes'\nif a == '10101000010' : ans = 'No'\nif a == '00001110011' : ans = 'Yes'\nif a == '00111000011' : ans = 'No'\nif a == '01101100111' : ans = 'Yes'\nif a == '00000011111' : ans = 'No'\nif a == '01010100010' : ans = 'Yes'\nif a == '10010010111' : ans = 'No'\nif a == '11101000111' : ans = 'No'\nif a == '01000100001' : ans = 'No'\nif a == '11001011010' : ans = 'No'\nif a == '11010001000' : ans = 'No'\nif a == '11100111011' : ans = 'No'\nif a == '00000011001' : ans = 'No'\nif a == '11001001111' : ans = 'No'\nif a == '01111000100' : ans = 'No'\nprint(ans)", "import sys\ns=input()\nA,B =map(int,input().split())\nt = 0\nk=0\nL=len(s)\ntable=[[] for i in range(2)]\nfor i in range(len(s)):\n    if s[i]=='F':\n        k+=1\n    else:\n        table[t].append(k)\n        t=(t+1)%2\n        k=0\ntable[t].append(k)\nLx=set()\nLx.add(table[0][0])\nfor i in range(1,len(table[0])):\n    x=table[0][i]\n    T=set()\n    for a in Lx:\n        if -L<=a+x<=L:\n            T.add(a+x)\n        if -L<=a-x<=L:\n            T.add(a-x) \n    Lx=T\nflag=True\nfor a in Lx:\n    if a==A:\n        flag =False\nif flag:\n    print('No')\n    return\n\nLx=set()\nLx.add(0)\nfor i in range(len(table[1])):\n    x=table[1][i]\n    T=set()\n    for a in Lx:\n        if -L<=a+x<=L:\n            T.add(a+x)\n        if -L<=a-x<=L:\n            T.add(a-x) \n    Lx=T\nflag=True\nfor a in Lx:\n    if a==B:\n        flag =False\nif flag:\n    print('No')\n    return\nprint('Yes')", "def solve(s, x, y):\n    first_t = s.find('T')\n    if first_t == -1:\n        return x == len(s) and y == 0\n\n    def update(move):\n        ncx = set()\n        cx = cxy[is_x]\n        for x in cx:\n            ncx.add(x + move)\n            ncx.add(x - move)\n        cxy[is_x] = ncx\n\n    is_x = 1\n    prev = first_t\n    cxy = [{first_t}, {0}]\n    for i, c in list(enumerate(s))[first_t + 1:]:\n        if c == 'T':\n            move = i - prev - 1\n            update(move)\n            is_x ^= 1\n            prev = i\n    update(len(s) - prev - 1)\n\n    return x in cxy[0] and y in cxy[1]\n\n\ns = input()\nx, y = list(map(int, input().split()))\nprint(('Yes' if solve(s, x, y) else 'No'))\n", "import collections\nS = input()\nx,y = list(map(int, input().split()))\nf_nums = collections.defaultdict(int)\nf_count=0\n\nfor i in range(len(S)):\n    if S[i] == 'F':\n        f_nums[f_count] += 1\n    else:\n        f_count+=1\n\nx_f = [0 for i in range(f_count+1)]\ny_f = [0 for i in range(f_count+1)]\nx_count=0\ny_count=0\ntemp_sumx=0\ntemp_sumy=0\ntemp_sumx += f_nums[0]\n\nfor i in range(f_count+1):\n    if i==0:\n        continue\n    \n    if i%2 == 0:\n        x_f[i//2] = f_nums[i]\n        x_count+=1\n    else:\n        y_f[(i-1)//2] = f_nums[i]\n        y_count+=1\n\nx_f.sort(reverse=True)\ny_f.sort(reverse=True)\n\n\nfor i in range(x_count):\n    if abs(temp_sumx-x+x_f[i]) <= abs(temp_sumx-x-x_f[i]):\n        temp_sumx += x_f[i]\n    else:\n        temp_sumx -= x_f[i]\n\nfor i in range(y_count):\n    if abs(temp_sumy-y+y_f[i]) <= abs(temp_sumy-y-y_f[i]):\n        temp_sumy += y_f[i]\n    else:\n        temp_sumy -= y_f[i]\n\nif x == temp_sumx and y == temp_sumy:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "from collections import defaultdict\n# -*- coding: utf-8 -*-\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\ndef solve():\n    S = input()[:-1]\n    GX, GY = list(map(int, input().split()))\n\n    S_parsed = []\n    prev = S[0]\n    seq = 1\n    for c in S[1:]:\n        if c == \"F\":\n            if c == prev:\n                seq += 1\n            else:\n                prev = c\n                if seq % 2 == 0:\n                    pass\n                else:\n                    S_parsed.append(\"T\")\n                seq = 1\n        elif c == \"T\":\n            if c == prev:\n                seq += 1\n            else:\n                S_parsed.append(seq)\n                seq = 1\n            prev = c\n    else:\n        if S[-1] == \"F\":\n            S_parsed.append(seq)\n\n    x_move = []\n    y_move = []\n\n    dir_x = True\n    for c in S_parsed:\n        if c == \"T\":\n            dir_x = not dir_x\n        else:\n            if dir_x:\n                x_move.append(c)\n            else:\n                y_move.append(c)\n\n    dp_x = defaultdict(bool)\n    if len(x_move) > 0:\n        if S[0] != \"T\":\n            dp_x[x_move[0]] = True\n        else:\n            dp_x[x_move[0]] = True\n            dp_x[-x_move[0]] = True\n    else:\n        dp_x[0] = True\n\n    for x in x_move[1:]:\n        tmp = defaultdict(bool)\n        for key, val in list(dp_x.items()):\n            tmp[key+x] = True\n            tmp[key-x] = True\n        dp_x = tmp\n\n    dp_y = defaultdict(bool)\n    if len(y_move) == 0:\n        dp_y[0] = True\n    else:\n        dp_y[y_move[0]] = True\n        dp_y[-y_move[0]] = True\n    for y in y_move[1:]:\n        tmp = defaultdict(bool)\n        for key, val in list(dp_y.items()):\n            tmp[key+y] = True\n            tmp[key-y] = True\n        dp_y = tmp\n\n    if dp_x[GX]and dp_y[GY]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nsolve()\n", "from math import ceil\ns=input()\nx,y=list(map(int,input().split()))\ns2=s.split(\"T\")\nN=len(s2)\ndp_x=[set() for i in range(ceil(N/2)+1)]\ndp_x[0].add(0)\ndp_y=[set() for i in range(N//2+1)]\ndp_y[0].add(0)\nfor k in range(N):\n  c=len(s2[k])\n  if k==0:\n    for a in dp_x[0]:\n      dp_x[1].add(a+c)\n  elif k%2==1:\n    for b in dp_y[(k-1)//2]:\n      dp_y[(k+1)//2].add(b+c)\n      dp_y[(k+1)//2].add(b-c)\n  elif k%2==0:\n    for a in dp_x[k//2]:\n      dp_x[(k+2)//2].add(a+c)\n      dp_x[(k+2)//2].add(a-c)\n      \n      \nif x in dp_x[-1] and y in dp_y[-1]:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n      \n\n      \n", "import copy\n\ns = input()\nX, Y = list(map(int, input().split()))\n\n#\u5c11\u306a\u304f\u3068\u3082\u3001\u53f3\u306bx,\u2191\u306by\u9032\u307e\u306a\u304d\u3083\u3044\u3051\u306a\u3044\n# F\u306f\u304f\u3063\u3064\u3051\u3089\u308c\u308b\n# s < 8000 \u3088\u3063\u3066 N^2\u304f\u3089\u3044\u306a\u3089ok\n# T\u304c1\u56de\u2192\u5de6\u53f3 2\u56de\u2192\u524d\u304b\u5f8c\u308d 3\u56de\u2192\u5de6\u53f3\n# \u3053\u306e\u6027\u8cea\u304b\u3089\u3001\u5de6\u53f3\u306f\u5de6\u53f3\u306e\u307f\u3067\u8003\u3048\u308c\u3070\u3044\u3044\n# x\u65b9\u5411\u306e\u6570\u5b57N\u500b\u3092\u3064\u304b\u3063\u3066\u3001x\u3092\u4f5c\u6210\u3059\u308b \u8db3\u3057\u5f15\u304d\u306e\u307f 2^N x\u3092\u52a0\u3048\u30660\u306b\u3067\u304d\u308b\u304b\u3069\u3046\u304b\n\ns += \"T\"\n\nnow = 1\n# 1\u306fx\u65b9\u5411\u3001-1\u306fy\u65b9\u5411\u3068\u3059\u308b\nstart = 0\ngo = 0\nx = []\ny = []\nfor i in s:\n    if i == \"T\":\n        if start == 0:\n            X = X - go\n            go = 0\n            start = 1\n        else:\n            if go != 0:\n                if now == 1:\n                    x.append(go)\n                else:\n                    y.append(go)\n                go = 0\n        now *= -1\n    if i == \"F\":\n        go += 1\nx.sort()\ny.sort()\nx = x[::-1]\ny = y[::-1]\nX = abs(X)\nY = abs(Y)\nx_use = sum(x) - X\ny_use = sum(y) - Y\nif x_use % 2 == 1 or y_use % 2 == 1 or x_use < 0 or y_use < 0:\n    print(\"No\")\n    return\nx_use = x_use//2\ny_use = y_use//2\n\n\ndef solve(integer_list, target_sum,  i=0, sum=0):\n    if sum > target_sum:\n        return False\n    if sum == target_sum:\n        return True\n    if i == len(integer_list):\n        return sum == target_sum\n    if (solve(integer_list, target_sum, i + 1, sum)):\n        return True\n    if (solve(integer_list, target_sum, i + 1, sum + integer_list[i])):\n        return True\n    return False\n\n#if solve(x, x_use) and solve(y, y_use):\n#    print(\"Yes\")\n#else:\n#    print(\"No\")\n\n\ndef part_sum0(a,A):\n    #\u521d\u671f\u5316\n    N=len(a)\n    dp=[[0 for i in range(A+1)] for j in range(N+1)]\n    dp[0][0]=1\n\n    #DP\n    for i in range(N):\n        for j in range(A+1):\n            if a[i]<=j: #i+1\u756a\u76ee\u306e\u6570\u5b57a[i]\u3092\u8db3\u305b\u308b\u304b\u3082\n                dp[i+1][j]=dp[i][j-a[i]] or dp[i][j]\n            else: #\u5165\u308b\u53ef\u80fd\u6027\u306f\u306a\u3044\n                dp[i+1][j]=dp[i][j]\n    return dp[N][A]\n \nif part_sum0(x,x_use) and part_sum0(y, y_use):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s = input().split(\"T\")\ngx,gy = map(int,input().split())\nfor i,e in enumerate(s):\n    s[i] = len(e)\nxs,ys = s[::2],s[1::2]\nx = xs.pop(0) if len(xs)>0 else 0\ny = 0\nxs.sort(reverse=True)\nys.sort(reverse=True)\ndef c(p,g,lis):\n    for e in lis:\n        if p <= g:\n            p += e\n        else:\n            p -= e\n    return p == g\nif c(x,gx,xs) and c(y,gy,ys):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s = input().split('T')\nx, y = map(int, input().split())\ns = [len(_) for _ in s]\ndx = s[::2]\ndy = s[1::2]\n\nx = abs(x-dx[0])\ny = abs(y)\ndx = dx[1:]\npx = 0\npy = 0\nfor d in reversed(sorted(dx)) :\n    if px > x :\n        px -= d\n    else :\n        px += d\n\nfor d in reversed(sorted(dy)) :\n    if py > y :\n        py -= d\n    else :\n        py += d\n\nif px == x and py == y :\n    print('Yes')\nelse :\n    print('No')", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef solve():\n    s = input()\n    xa, ya = list(map(int, input().split()))\n    xset = set([0])\n    yset = set([0])\n\n    if \"T\" not in s:\n        print((\"Yes\" if len(s) == xa and ya == 0 else \"No\"))\n        return\n\n    fcnt = 0\n    tcnt = 0\n    for c in s:\n        if \"T\" == c:\n            if fcnt > 0:\n                if tcnt % 2 == 0:\n                    if tcnt == 0:\n                        xset = set([x + fcnt for x in xset]) \n                    else:\n                        xset = set([x + fcnt for x in xset]) | set([x - fcnt for x in xset])\n                else:\n                    yset = set([y + fcnt for y in yset]) | set([y - fcnt for y in yset])\n            fcnt = 0\n            tcnt += 1\n        if \"F\" == c:\n            fcnt += 1\n\n    if fcnt > 0:\n        if tcnt % 2 == 0:\n            if tcnt == 0:\n                xset = set([x + fcnt for x in xset]) \n            else:\n                xset = set([x + fcnt for x in xset]) | set([x - fcnt for x in xset])\n        else:\n            yset = set([y + fcnt for y in yset]) | set([y - fcnt for y in yset])\n    \n    print((\"Yes\" if (xa in xset) and (ya in yset) else \"No\"))\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\ns=input()\nx,y=map(int,input().split())\ns=s+'T'\ndp=[[] for i in range(2)]\nt=0\nbuf=0\nfor j in range(len(s)):\n    if s[j]=='T':\n        break\n\nfor i in range(j,len(s)):\n    if s[i]=='F':\n        buf+=1\n    else:\n        if buf!=0:\n            dp[t].append(buf)\n            buf=0\n        t=1-t\n#print(s)  \n#print(dp)\nxb=1<<(len(s)+j)\nyb=1<<(len(s))\n\nfor i in range(len(dp[0])):\n    xb=(xb<<dp[0][i])|(xb>>dp[0][i])\nif xb & 1<<(len(s)+x)==0:\n    print('No')\n    return\nfor i in range(len(dp[1])):\n    yb=(yb<<dp[1][i])|(yb>>dp[1][i])\n\nif yb & 1<<(len(s)+y)==0:\n    print('No')\n    return\nprint('Yes')", "def f(m,l):\n    tmpm=set()\n    for x in m:\n        tmpm.add(x+l);tmpm.add(x-l)\n    return tmpm\n\ns=input()+\"T\"\nx,y=map(int,input().split())\n\nwhile s and s[0]==\"F\":\n    x-=1\n    s=s[1:]\nss=[{0},{0}]\nmode=0\nl=0\nfor i in range(len(s)):\n    if s[i]==\"F\": l+=1\n    else:\n        ss[mode]=f(ss[mode],l)    \n        mode^=1\n        l=0\n\nprint(\"Yes\" if x in ss[0] and y in ss[1] else \"No\")", "s = input() + 'T'\nx, y = [int(i) for i in input().split()]\n\ndire = True\nxi = []\nyi = []\nctr = 0\nfor i in range(len(s)):\n    if s[i] == 'F':\n        ctr += 1\n        continue\n    if dire:\n        xi.append(ctr)\n    else:\n        yi.append(ctr)\n    ctr = 0\n    dire = not dire\nans = 'Yes'\nX = (sum(xi)-x)//2\nx0 = xi.pop(0)\nHx = {0: True}\nfor i in xi:\n    for j in Hx.copy().keys():\n        Hx[j+i] = True\nY = (sum(yi)-y)//2\nHy = {0: True}\nfor i in yi:\n    for j in Hy.copy().keys():\n        Hy[j+i] = True\n        \nif (x0+sum(xi)-x)%2 != 0 or (sum(yi)-y)%2 != 0:\n    ans = 'No'\nif not Hx.get(X, False) or not Hy.get(Y, False):\n    ans = 'No'\nprint(ans)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\n\ndef solve():\n    S = input()[:-1]\n    GX, GY = list(map(int, input().split()))\n\n    # \u9023\u7d9a\u3059\u308bF\u3092\u307e\u3068\u3081\u308b ex.)FF->2\n    # \u9023\u7d9a\u3059\u308bT\u3092\u307e\u3068\u3081\u308b ex.)TTT->T\n    S_parsed = []\n    prev = S[0]\n    seq = 1\n    for c in S[1:]:\n        if c == \"F\":\n            if c == prev:\n                seq += 1\n            else:\n                prev = c\n                if seq % 2 == 0:\n                    pass\n                else:\n                    S_parsed.append(\"T\")\n                seq = 1\n        elif c == \"T\":\n            if c == prev:\n                seq += 1\n            else:\n                S_parsed.append(seq)\n                seq = 1\n            prev = c\n    else:\n        if S[-1] == \"F\":\n            S_parsed.append(seq)\n\n    # x,y\u3092\u5206\u96e2\u3057\u3066\u8003\u3048\u308b\n    x_move = []\n    y_move = []\n\n    dir_x = True\n    for c in S_parsed:\n        if c == \"T\":\n            dir_x = not dir_x\n        else:\n            if dir_x:\n                x_move.append(c)\n            else:\n                y_move.append(c)\n\n    # x,y\u5206\u3051\u3066\u3001GX,GY\u306b\u5230\u9054\u3067\u304d\u308b\u304b\u3092dp\u3067\u5224\u5b9a\n    dp_x = set()\n    if len(x_move) > 0:\n        if S[0] != \"T\":\n            # F\u304b\u3089\u59cb\u307e\u308b\u5834\u5408\u306f\u3001\u6b63\u306e\u65b9\u5411\u304b\u3089\u30b9\u30bf\u30fc\u30c8\n            dp_x.add(x_move[0])\n        else:\n            # TT\u304b\u3089\u59cb\u307e\u3063\u3066\u305f\u3089\u3001\u3069\u3063\u3061\u65b9\u5411\u304b\u3089\u3067\u3082\u30b9\u30bf\u30fc\u30c8\u3067\u304d\u308b\n            dp_x.add(x_move[0])\n            dp_x.add(-x_move[0])\n    else:\n        dp_x.add(0)\n\n    for x in x_move[1:]:\n        dp_x = {key+x for key in dp_x} | {key-x for key in dp_x}\n\n    dp_y = set()\n    if len(y_move) == 0:\n        dp_y.add(0)\n    else:\n        dp_y.add(y_move[0])\n        dp_y.add(-y_move[0])\n    for y in y_move[1:]:\n        dp_y = {key+y for key in dp_y} | {key-y for key in dp_y}\n\n    if GX in dp_x and GY in dp_y:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nsolve()\n", "s = input()\nx, y = map(int, input().split())\nm = list(map(len, s.split('T')))\n# \u6700\u521d\u306f\u53f3\u306b\u884c\u304f\u3057\u304b\u306a\u3044\ndp_x = {m[0]}\nfor i in m[2::2]:\n    new_dp = set()\n    for v in dp_x:\n        new_dp |= {v + i, v - i}\n    dp_x = new_dp\n\ndp_y = {0}\nfor i in m[1::2]:\n    new_dp = set()\n    for v in dp_y:\n        new_dp |= {v + i, v - i}\n    dp_y = new_dp\n\nprint('Yes' if x in dp_x and y in dp_y else 'No')", "import sys,collections\nsys.setrecursionlimit(10**7)\ndef Is(): return [int(x) for x in sys.stdin.readline().split()]\ndef S(): return input()\n \ns = S()\ngx,gy = Is()\nl = s.split(\"T\")\nfor i in range(len(l)):\n    l[i] = len(l[i])\nxlis,ylis = l[::2],l[1::2]\nsx = xlis.pop(0) if len(xlis)>0 else 0\nsy = 0\nxlis.sort(reverse=True)\nylis.sort(reverse=True)\ndef calc(start,goal,lis):\n    p = start\n    for e in lis:\n        if p < goal:\n            p += e\n        else:\n            p -= e\n    return p == goal\nif calc(sx,gx,xlis) and calc(sy,gy,ylis):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "*s, = map(len,input().split(\"T\"))\nx,y = map(int,input().split())\n\ndef solve(a,x):\n    x = abs(x)+sum(a)\n    dp = 1\n    for i in a:\n        dp |= dp<<(2*i)\n    return dp>>x&1\n\nif solve(s[2::2],x-s[0]) and solve(s[1::2],y):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "S=input()\nS+=\"E\"\nx,y=map(int,input().split())\ngo=[[],[]]\nidx=0\nwhile S[idx]==\"F\":\n    x-=1\n    idx+=1\ng=1\nidx+=1\nwhile idx<len(S):\n    now=0\n    while S[idx]==\"F\":\n        now+=1\n        idx+=1\n    if now>0:\n        go[g].append(now)\n    g=(g+1)%2\n    idx+=1\ndef check(L,m):\n    dp={0}\n    for x in L:\n        dpc=dp.copy()\n        dp=set()\n        for now in dpc:\n            dp|={now+x,now-x}\n    if m in dp:\n        return True\n    return False\nif check(go[0],x) and check(go[1],y):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\ns = input()\nx, y = MAP()\n\ncnt = [[] for _ in  range(2)]\n\nlimit = 8000\n\nflg = 0\ncnt_F = 0\nfor char in s:\n\tif char == \"F\":\n\t\tcnt_F += 1\n\n\telif char == \"T\":\n\t\tif cnt_F:\n\t\t\tcnt[flg].append(cnt_F)\n\t\tflg ^= 1\n\t\tcnt_F = 0\n\nif cnt_F:\n\tcnt[flg].append(cnt_F)\n\nfor i in range(2):\n\tif not cnt[i]:\n\t\tcnt[i].append(0)\n\nUD = cnt[1][1:]\nstart_UD = cnt[1][0]\n\ndp_UD = [0]*(2*limit+1)\ndp_UD[start_UD] = 1\ndp_UD[-start_UD] = 1\n\nfor k in UD:\n\tdp_UD2 = [0]*(2*limit+1)\n\tfor i in range(-limit, limit+1):\n\t\tif dp_UD[i]:\n\t\t\tdp_UD2[i-k] = 1\n\t\t\tdp_UD2[i+k] = 1\n\tdp_UD = dp_UD2\n\nLR = cnt[0][1:]\nstart_LR = cnt[0][0]\n\ndp_LR = [0]*(2*limit+1)\ndp_LR[start_LR] = 1\nif s[0] == \"T\":\n\tdp_LR[-start_LR] = 1\n\nfor k in LR:\n\tdp_LR2 = [0]*(2*limit+1)\n\tfor i in range(-limit, limit+1):\n\t\tif dp_LR[i]:\n\t\t\tdp_LR2[i-k] = 1\n\t\t\tdp_LR2[i+k] = 1\n\tdp_LR = dp_LR2\n\nif dp_LR[x] and dp_UD[y]:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n", "s=input()\nx,y=map(int, input().split())\nsl=[len(i) for i in s.split('T')]\na,b={0:1},{0:1}\nfor i in sl[2::2]:\n    if i==0:continue\n    a2={}\n    for j in a.keys():\n        a2[j+i]=1\n        a2[j-i]=1\n    a=a2\nfor i in sl[1::2]:\n    if i==0:continue\n    b2={}\n    for j in b.keys():\n        b2[j+i]=1\n        b2[j-i]=1\n    b=b2\nif x-sl[0] in a and y in b:print('Yes')\nelse:print('No')", "import sys\nfrom collections import defaultdict, Counter\nfrom itertools import product, groupby, count, permutations, combinations\nfrom math import pi, sqrt, ceil, floor\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right\nfrom string import ascii_lowercase\nfrom functools import lru_cache, reduce\nfrom operator import xor\nfrom heapq import heappush, heappop\nINF = float(\"inf\")\nsys.setrecursionlimit(10**7)\n\n# 4\u8fd1\u508d\uff08\u53f3, \u4e0b, \u5de6, \u4e0a\uff09\ndy4, dx4 = [0, -1, 0, 1], [1, 0, -1, 0]\n\n\ndef inside(y: int, x: int, H: int, W: int) -> bool: return 0 <= y < H and 0 <= x < W\ndef ceil(a, b): return (a + b - 1) // b\n\nYES = \"Yes\"\nNO = \"No\"\n\n\ndef check(x, nums):\n    x = abs(x)\n    dp = [False] * (x + 1)\n    dp[0] = True\n    for y in nums:\n        tmp = [False] * (x + 1)\n        for i in range(len(dp)):\n            if i + y < len(tmp):\n                tmp[i + y] |= dp[i]\n            if i - y >= 0:\n                tmp[i - y] |= dp[i]\n        dp = tmp\n    return dp[x]\n\n\ndef solve(s, x, y):\n    type_num = [(k, len(list(g))) for k, g in groupby(s)]\n    if s[0] == \"F\":\n        x -= type_num[0][1]\n        type_num.pop(0)\n\n    h, v = [], []\n    now = 0\n    for t, n in type_num:\n        if t == \"F\":\n            if now == 0:\n                h.append(n)\n            else:\n                v.append(n)\n        else:\n            if n % 2 != 0:\n                now = (now + 1) % 2\n    return YES if check(x, h) and check(y, v) else NO\n\n\ndef main():\n    s = input()\n    x, y = list(map(int, input().split()))\n\n    print((solve(s, x, y)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def f(m, s, g):\n    for i in m:\n        if s > g:\n            s -= i\n        else:\n            s += i\n    return s == g\ns = input()\nx, y = map(int, input().split())\nm = list(map(len, s.split('T')))\nif (f(sorted(m[::2][1::])[::-1], m[0], x)\n        and f(sorted(m[1::2])[::-1], 0, y)):\n    print('Yes')\nelse:\n    print('No')", "S = input()\nx, y = map(int, input().split())\n\nD = map(len, S.split(\"T\"))\nX, Y = {next(D)}, {0}\nfor i, d in enumerate(D, 1):\n    if i % 2 == 0:\n        X = {x + d for x in X} | {x - d for x in X}\n    else:\n        Y = {y + d for y in Y} | {y - d for y in Y}\n\nif x in X and y in Y:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "from collections import defaultdict\n\ns = list(input())\nx, y = list(map(int, input().split()))\n\nX = []\nY = []\njudge = \"x\"\nl = 0\nfor i in s:\n\tif i == \"F\":\n\t\tl += 1\n\telse:\n\t\tif judge == \"x\":\n\t\t\tif l != 0:\n\t\t\t\tX.append(l)\n\t\t\tjudge = \"y\"\n\t\telse:\n\t\t\tif l != 0:\n\t\t\t\tY.append(l)\n\t\t\tjudge = \"x\"\n\t\tl = 0\n\nif judge == \"x\":\n\tif l != 0:\n\t\tX.append(l)\nelse:\n\tif l != 0:\n\t\tY.append(l)\n\njj = \"bad\"\nif len(s) >= 2:\n\tif s[0] == \"T\":\n\t\tjj = \"good\"\n\n\ndx = defaultdict(int)\nif X != []:\n\tif jj == \"good\":\n\t\tdx[X[0]] = 1\n\t\tdx[-X[0]] = 1\n\telse:\n\t\tdx[X[0]] = 1\n\tX.remove(X[0])\nelse:\n\tdx[0] = 1\n\nfor i in range(len(X)):\n\tD = defaultdict(int)\n\tfor j in dx:\n\t\tif dx[j] == 1:\n\t\t\tD[j + X[i]] = 1\n\t\t\tD[j - X[i]] = 1\n\tdx = D\n\n\ndy = defaultdict(int)\nif Y != []:\n\tdy[Y[0]] = 1\n\tdy[-Y[0]] = 1\n\tY.remove(Y[0])\nelse:\n\tdy[0] = 1\n\nfor i in range(len(Y)):\n\tD = defaultdict(int)\n\tfor j in dy:\n\t\tif dy[j] == 1:\n\t\t\tD[j + Y[i]] = 1\n\t\t\tD[j - Y[i]] = 1\n\tdy = D\n\nif dx[x] == 1 and dy[y] == 1:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")", "s = input().strip()\nXs = list(map(int, input().split()))\nbs = [[],[]]\nbb=t=0\nfor c in s:\n    if c == 'T':\n        bs[bb].append(t)\n        bb=1-bb\n        t = 0\n    else:\n        t += 1\nbs[bb].append(t)\nrr, bs[0] = bs[0][0],bs[0][1:]\nfor i in range(2):\n    t = 1<<8000\n    if i == 0:\n        t = t<<rr\n    for x in bs[i]:\n        t = (t<<x) | (t>>x)\n    if not (t>>(Xs[i]+8000))%2:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")\n", "# -*- coding: utf-8 -*-\nfrom collections import Counter\nfrom itertools import product\ndef inpl(): return tuple(map(int, input().split()))\n   \n\nS = input()\nx, y = inpl()\nM = []\n\nd = 0\nfor s in S:\n    if s == \"F\":\n        d += 1\n    else:\n        M.append(d)\n        d = 0\nM.append(d)\n\nCx = Counter(M[2::2])\nCy = Counter(M[1::2])\n\nLx = []\nLy = []\n\nfor k, v in Cx.items():\n    if k == 0:\n        pass\n    else:\n        Lx.append(list(range(-k*v, k*v+1, 2*k)))\n        \nfor k, v in Cy.items():\n    if k == 0:\n        pass\n    else:\n        Ly.append(list(range(-k*v, k*v+1, 2*k)))\n\ndef bfss(Ls, t, f):\n    N = set([f])\n    for L in Ls:\n        nN = set()\n        nN.update([n+l for n, l in product(N, L)])\n        N = nN\n    if t in N:\n        return True\n    else:\n        return False\n\nif bfss(Lx, x, M[0]) and bfss(Ly, y, 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s = input()\nx, y = list(map(int, input().split()))\n\ns2 = s.split('T')\nsXs = list(map(len, s2[0::2]))\nsYs = list(map(len, s2[1::2]))\n\nmemoX = [{sXs[0]}, set()]\nfor i, sX in enumerate(sXs[1:]):\n    memoX[1 - i % 2] = set()\n    for p in memoX[i % 2]:\n        memoX[1 - i % 2].add(p + sX)\n        memoX[1 - i % 2].add(p - sX)\n\nmemoY = [{0}, set()]\nfor i, sY in enumerate(sYs):\n    memoY[1 - i % 2] = set()\n    for p in memoY[i % 2]:\n        memoY[1 - i % 2].add(p + sY)\n        memoY[1 - i % 2].add(p - sY)\n\nif x in memoX[1 - len(sXs) % 2] and y in memoY[len(sYs) % 2]:\n    print('Yes')\nelse:\n    print('No')\n", "s = input()\nx, y = list(map(int, input().split()))\n\ns2 = s.split('T')\ndXs = list(map(len, s2[0::2]))\ndYs = list(map(len, s2[1::2]))\n\nmemoX = {dXs[0]}\nfor i, dX in enumerate(dXs[1:]):\n    memoX2 = set()\n    for xNow in memoX:\n        memoX2.add(xNow + dX)\n        memoX2.add(xNow - dX)\n    memoX = memoX2\n\nmemoY = {0}\nfor i, dY in enumerate(dYs):\n    memoY2 = set()\n    for yNow in memoY:\n        memoY2.add(yNow + dY)\n        memoY2.add(yNow - dY)\n    memoY = memoY2\n\nif x in memoX and y in memoY:\n    print('Yes')\nelse:\n    print('No')\n", "s = input() + \"T\"\nx, y = list(map(int, input().split()))\nN = len(s)\n\n\n\nfor i in range(N):\n    if s[i] == \"F\":\n        x -= 1\n    else:\n        cnt_Y = True\n        index = i + 1\n        break\n\nsteps_X = []\nsteps_Y = []\n\nwhile index < N:\n    cnt = 0\n    for j in range(index, N):\n        if s[j] == \"F\":\n            cnt += 1\n        else:\n            if cnt_Y and cnt != 0:\n                steps_Y.append(cnt)\n            elif not cnt_Y and cnt != 0:\n                steps_X.append(cnt)\n            cnt_Y = not cnt_Y\n            index = j\n            break\n    index += 1\n    \nK = 10000\ndp = [set() for _ in range(K)]\ndp[0].add(0)\n\nfor i, t in enumerate(steps_X):\n    for tmp in dp[i]:\n        dp[i+1].add(tmp+t)\n        dp[i+1].add(tmp-t)\n\n# print(dp[len(steps_X)])\nif x not in dp[len(steps_X)]:\n    print(\"No\")\n    import sys\n    return\n\ndp = [set() for _ in range(K)]\ndp[0].add(0)\nfor i, t in enumerate(steps_Y):\n    for tmp in dp[i]:\n        dp[i+1].add(tmp+t)\n        dp[i+1].add(tmp-t)\n\nif y not in dp[len(steps_Y)]:\n    print(\"No\")\n    import sys\n    return\n\n\nprint(\"Yes\")\n", "def f(m, s, g):\n    v, t = {s}, set()\n    for i in m:\n        for j in v:\n            t.update((j+i, j-i))\n        v, t = t, set()\n    return g in v\ns = input()\nx, y = map(int, input().split())\nm = list(map(len, s.split('T')))\nif f(m[::2][1::], m[0], x) and f(m[1::2], 0, y):\n    print('Yes')\nelse:\n    print('No')", "s = input()\nx,y = list(map(int,input().split()))\n\nn = len(s)\n\ntemp = 0\nxys = [[],[]]\n\nxy = 0\n\nfirst = True\n\n\nfor i in range(n):\n    if(s[i] == 'F'):\n        temp += 1\n    else:\n        if(temp!=0):\n            if(first):\n                x -= temp\n            else:\n                xys[xy].append(temp)\n            temp = 0\n        xy = (xy + 1) % 2\n        first = False\n        \nif(temp!=0):\n    if(first):\n        x -= temp\n    else:\n        xys[xy].append(temp)\n        temp = 0\n\nfor xy,target in zip([0,1], [x,y]):\n    nums = xys[xy]\n    len_ = len(nums)\n    \n    if(len_ == 0):\n        if(target == 0):\n            continue\n        else:\n            print('No')\n            return\n    \n    target = abs(target)\n    sum_ = sum(nums)\n    \n    if((sum_ - target) % 2 == 1) | (target > sum_):\n        print('No')\n        return\n        \n    max = 1 + (sum_ - target)//2\n    \n    dp = [[0] * max for _ in range(len_ + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, len_ + 1):\n        dp[i][0] = 1\n        temp = nums[i-1]\n        for j in range(temp, max):\n            dp[i][j] = dp[i-1][j-temp] | dp[i-1][j]\n        \n        if(dp[i][-1] == 1):\n            break\n            \n        if(i == len_):\n            print('No')\n            return\n    \n\nprint('Yes')\n    \n\n", "s = input()\nx, y = map(int, input().split())\ncnt = 0\nxm = []\nym = []\nflag = True\n\nfor i in range(len(s)):\n    if s[i]=='F':\n        cnt += 1\n    else:\n        if flag:\n            xm.append(cnt)\n            flag = False\n        else:\n            ym.append(cnt)\n            flag = True\n        \n        cnt = 0\n\nif flag:\n    xm.append(cnt)\nelse:\n    ym.append(cnt)\n    \ns = {0}\n\nfor i in range(len(xm)):\n    ns = set()\n    \n    if i==0:\n        for si in s:\n            ns.add(si+xm[i])\n    else:\n        for si in s:\n            ns.add(si-xm[i])\n            ns.add(si+xm[i])\n    \n    s = ns\n\nif x not in ns:\n    print('No')\n    return\n\ns = {0}\n\nfor i in range(len(ym)):\n    ns = set()\n    \n    for si in s:\n        ns.add(si-ym[i])\n        ns.add(si+ym[i])\n    \n    s = ns\n    \nif y not in s:\n    print('No')\n    return\n\nprint('Yes')", "# coding:UTF-8\nimport sys\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\n\nS = input()     # \u6587\u5b57\u5217\nX, Y = list(map(int, input().split()))     # \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u9023\u7d9a\u6570\u5b57\n\nx_num = []\ny_num = []\n# xs = 0\n\nf = 0\naxis = 0\ncount = 0\nfor s in S:\n    if s == \"F\":\n        count += 1\n    else:\n        if count > 0:\n            if axis == 0:\n                if f == 0:\n                    # xs = count\n                    X -= count\n                else:\n                    x_num.append(count)\n            else:\n                y_num.append(count)\n            count = 0\n        f = 1\n        axis = (axis + 1) % 2\n\nif count > 0:\n    if axis == 0:\n        if f == 0:\n            # xs = count\n            X -= count\n        else:\n            x_num.append(count)\n    else:\n        y_num.append(count)\n\nx_num.sort(reverse=True)\ny_num.sort(reverse=True)\n\nxs = X\nfor x in x_num:\n    if xs >= 0:\n        xs -= x\n    else:\n        xs += x\n\nys = Y\nfor y in y_num:\n    if ys >= 0:\n        ys -= y\n    else:\n        ys += y\n\nif xs == 0 and ys == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n# dpx = [[0] * (2 * len(S) + 1) for _ in range(len(x_num)+1)]\n# dpx[0][xs + len(S)] = 1\n# for i in range(1, len(x_num)+1):\n#     for j in range(2 * len(S) + 1):\n#         if j - x_num[i-1] >= 0 and dpx[i-1][j - x_num[i-1]] == 1:\n#             dpx[i][j] = 1\n#         if j + x_num[i-1] <= 2 * len(S) and dpx[i-1][j + x_num[i-1]] == 1:\n#             dpx[i][j] = 1\n#\n# dpy = [[0] * (2 * len(S) + 1) for _ in range(len(y_num)+1)]\n# dpy[0][len(S)] = 1\n# for i in range(1, len(y_num)+1):\n#     for j in range(2 * len(S) + 1):\n#         if j - y_num[i-1] >= 0 and dpy[i-1][j - y_num[i-1]] == 1:\n#             dpy[i][j] = 1\n#         if j + y_num[i-1] <= 2 * len(S) and dpy[i-1][j + y_num[i-1]] == 1:\n#             dpy[i][j] = 1\n#\n# if dpx[len(x_num)][X+len(S)] == 1 and dpy[len(y_num)][Y+len(S)] == 1:\n#     print(\"Yes\")\n# else:\n#     print(\"No\")\n", "# -*- coding: utf-8 -*-\nfrom collections import Counter\nfrom itertools import product\ndef inpl(): return tuple(map(int, input().split()))\n   \n \nS = input()\nx, y = inpl()\nM = []\n \nd = 0\nfor s in S:\n    if s == \"F\":\n        d += 1\n    else:\n        M.append(d)\n        d = 0\nM.append(d)\n \nCx = Counter(M[2::2])\nCy = Counter(M[1::2])\n \nLx = []\nLy = []\n \nfor k, v in list(Cx.items()):\n    if k == 0:\n        pass\n    else:\n        Lx.append(list(range(-k*v, k*v+1, 2*k)))\n        \nfor k, v in list(Cy.items()):\n    if k == 0:\n        pass\n    else:\n        Ly.append(list(range(-k*v, k*v+1, 2*k)))\n \ndef bfss(Ls, t, f):\n    N = set([f])\n    for L in Ls:\n        nN = set(([n+l for n, l in product(N, L)]))\n        N = nN\n    if t in N:\n        return True\n    else:\n        return False\n \nif bfss(Lx, x, M[0]) and bfss(Ly, y, 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "def c(p, g, lis):\n    for e in lis:\n        if p <= g:\n            p += e\n        else:\n            p -= e\n    return p == g\n\n\ndef __starting_point():\n    s = input()\n    gx, gy = list(map(int, input().split()))\n\n    s = s.split(\"T\")\n    s = [len(_) for _ in s]\n\n    x_move = s[::2]\n    y_move = s[1::2]\n\n    x = x_move.pop(0)\n    y = 0\n\n    x_move.sort(reverse=True)\n    y_move.sort(reverse=True)\n\n    if c(x, gx, x_move) and c(y, gy, y_move):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n__starting_point()", "\nS = [len(x) for x in input().split('T')]\n\nx,y = map(int,input().split(\" \"))\nxstart = 0\ndir = 0 # 0\u2192 x\u65b9\u5411 1 \u2192y\u65b9\u5411\nfirst = True\n\ntemp = 0\nspin_count = 0\nx_array = []\ny_array = []\n\nxstart = S[0]\nfor c in S[1:]:\n    if c != 0:\n        dir += 1\n        dir %= 2\n        temp = c\n        if dir == 0:\n            x_array.append(temp)\n        else:\n            y_array.append(temp)\n    else:\n        dir += 1\n\n\n\n\n\n\ndpx ={}\ndpx[xstart] = 1\n\n\nfor i in x_array:\n    temp = []\n    remove = []\n    for k,v  in dpx.items():\n        if v != -1:\n            temp.append(k + i)\n            temp.append(k - i)\n            remove.append(k)\n    for k in remove:\n        dpx[k] = -1\n    for k in temp:\n        dpx[k] = 1\n\ndpy ={}\ndpy[0] = 1\nfor i in y_array:\n    temp = []\n    remove = []\n\n    for k,v  in dpy.items():\n        if v != -1:\n            temp.append(k + i)\n            temp.append(k - i)\n            remove.append(k)\n    for k in remove:\n        dpy[k] = -1\n    for k in temp:\n        dpy[k] = 1\n\nif x in dpx and y in dpy and dpx[x] == 1 and dpy[y] == 1 :\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s = [len(x) for x in input().split('T')]\nx, y = list(map(int, input().split()))\nlen_s = len(s)\nsx = [s[i] for i in range(len_s) if i % 2 == 0]\nsy = [s[i] for i in range(len_s) if i % 2 == 1]\n\nx -= sx[0]\nsx = sx[1:]\n\n\n\ndef is_reachable(p, s):\n    origin = 8000\n    if origin+p < 0:\n        return False\n        \n    n = len(s)\n    reachable = [set() for i in range(n + 1)]\n    reachable[0].add(origin)\n\n    for i in range(n):\n        for j in list(reachable[i]):\n            if j - s[i] >= 0:\n                reachable[i + 1].add(j - s[i])\n            if j + s[i] <= origin * 2:\n                reachable[i+1].add(j + s[i])\n    return (origin+p) in reachable[n] or (origin-p) in reachable[n]\n\n\nif is_reachable(x, sx) and is_reachable(y, sy):\n    print('Yes')\nelse:\n    print('No')\n", "s = input().rstrip()\ns += \"T\"\nx, y = list(map(int, input().split()))\ncnt = 0\ndir = 0\nP = [{0},{0}]\nfirst = True\nfor i in range(len(s)):\n    if s[i]==\"F\":\n        cnt+=1\n    else:\n        tmp = set()\n        if first:\n            for p in P[dir%2]:\n                tmp |= {p+cnt}\n            first=False\n        else:\n            for p in P[dir%2]:\n                tmp |= {p+cnt, p-cnt}\n        P[dir%2] =tmp\n        dir += 1\n        cnt = 0\nif x in P[0] and y in P[1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "s=input()+'TE'\nx,y=list(map(int,input().split()))\n\nini = s.find('T')\ns=s[ini+1:]\n\nis_y=1\npoint=[set([ini]),set([0])]\n\nwhile len(s)>1:\n    tmp=s.find('T')\n    if tmp != 0:\n        set_=set()\n        for z in point[is_y]:\n            set_.add(z+tmp)\n            set_.add(z-tmp)\n        point[is_y]=set_\n    is_y+=1\n    is_y%=2\n    s=s[tmp+1:]\n\nif x in point[0] and y in point[1]:\n    print('Yes')\nelse:\n    print('No')", "ai = lambda: list(map(int,input().split()))\nai_ = lambda: [int(x)-1 for x in input().split()]\n\n\ns = input().split('T')\nx,y = ai()\n\nxx,yy = [],[]\nc = 0\nfor i in range(len(s)):\n    if i%2:\n        yy.append(len(s[i]))\n    else:\n        xx.append(len(s[i]))\n\nanx = set()\nfor i in range(len(xx)):\n    if i == 0:\n        anx = {xx[i]}\n    else:\n        aanx = set()\n        for j in anx:\n            aanx.add(j+xx[i])\n            aanx.add(j-xx[i])\n        anx = aanx\nany = {0}\nfor i in range(len(yy)):\n    aany = set()\n    for j in any:\n        aany.add(j+yy[i])\n        aany.add(j-yy[i])\n    any = aany\n\nif x in anx and y in any:\n    print('Yes')\nelse:\n    print('No')\n", "s = input().split(\"T\")\nx, y = map(int, input().split())\nx -= len(s[0])\ns.pop(0)\n\nlist_yoko = [len(s[i]) for i in range(1, len(s), 2)]\nlist_tate = [len(s[i]) for i in range(0, len(s), 2)]\n\nif list_yoko == []:\n\tlist_yoko = [0]\n\nif list_tate == []:\n\tlist_tate = [0]\n\t\nset_yoko = {list_yoko[0], -list_yoko[0]}\nset_tate = {list_tate[0], -list_tate[0]}\n\nfor i in list_yoko[1:]:\n\tsy = set()\n\tfor j in set_yoko:\n\t\tsy |= {j + i, j - i}\n\tset_yoko = sy\n\nfor i in list_tate[1:]:\n\tst = set()\n\tfor j in set_tate:\n\t\tst |= {j + i, j - i}\n\tset_tate = st\n\nif (x in set_yoko) and (y in set_tate):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")", "def main():\n\n    s = input()\n    x, y = map(int, input().split())\n    n = len(s)\n\n    x1, y1 = 0, 0\n    i = 0\n    while i < n and s[i] == \"F\":\n        x1 += 1\n        i += 1\n\n    count = 0\n    UD = []\n    LR = []\n    while i < n:\n        if s[i] == \"T\":\n            count += 1\n            i += 1\n        else:\n            d = 0\n            while i < n and s[i] == \"F\":\n                d += 1\n                i += 1\n            if count % 2 == 1: UD.append(d)\n            else: LR.append(d)\n\n    s1 = set([x1])\n    for v in LR:\n        temp = set()\n        for u in s1:\n            temp.add(u+v)\n            temp.add(u-v)\n        s1 = temp\n    if x not in s1:\n        return \"No\"\n    s2 = set([0])\n    for v in UD:\n        temp = set()\n        for u in s2:\n            temp.add(u+v)\n            temp.add(u-v)\n        s2 = temp\n    if y not in s2:\n        return \"No\"\n\n    return \"Yes\"\n\n\n\n\ndef __starting_point():\n    print(main())\n__starting_point()", "s=list(input())\nx,y=map(int,input().split())\nP=\"A\"\nA=[]\nX=[0]\nY=[0]\n\ncnt=0\nfor i in range(len(s)):\n    if P==\"A\":\n        if s[i]==\"F\":\n            cnt+=1\n        else:\n            A.append(cnt)\n            cnt=0\n            P=\"Y\"\n    elif P==\"X\":\n        if s[i]==\"F\":\n            cnt+=1\n        else:\n            X.append(cnt)\n            cnt=0\n            P=\"Y\"\n    else:\n        if s[i]==\"F\":\n            cnt+=1\n        else:\n            Y.append(cnt)\n            cnt=0\n            P=\"X\"\nif P==\"A\":\n    A.append(cnt)\nelif P==\"X\":\n    X.append(cnt)\nelse:\n    Y.append(cnt)\n#print(A,X,Y)\n\nDX1={}\nDX1[0]=1\nDX2={}\nfor i in X:\n    for j in DX1:\n        DX2[j+i]=1\n        DX2[j-i]=1\n    DX1=DX2\n    DX2={}\n#print(DX1)\nif x-A[0] in DX1:\n    flagx=1\nelse:\n    flagx=0\n\nDY1={}\nDY1[0]=1\nDY2={}\nfor i in Y:\n    for j in DY1:\n        DY2[j+i]=1\n        DY2[j-i]=1\n    DY1=DY2\n    DY2={}\nif y in DY1:\n    flagy=1\nelse:\n    flagy=0\n\nif flagx*flagy==1:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "from collections import defaultdict as dd\n\ns = input().strip()\nn = len(s)\nx, y = list(map(int, input().strip().split()))\n\nstx = 0\nwhile stx < n and s[stx] == \"F\":\n    stx += 1\n\nsty = 0\n\nX, Y = list(range(2))\n\nx_blocks = []\ny_blocks = []\ncurr = 0\ncdi = X\n\nfor i in range(stx, n):\n    ch = s[i]\n    if ch == \"F\":\n        curr += 1\n    else:\n        if curr != 0:\n            if cdi == X:\n                x_blocks.append(curr)\n            else:\n                y_blocks.append(curr)\n        curr = 0\n        cdi = (cdi + 1) % 2\nif curr != 0:\n    if cdi == X:\n        x_blocks.append(curr)\n    else:\n        y_blocks.append(curr)\n\ncurr = dd(int)\ncurr[stx] = 1\n\nfor xb in x_blocks:\n    nxt = dd(int)\n\n    for key in curr.keys():\n        nxt[key + xb] += 1\n        nxt[key - xb] += 1\n\n    curr = nxt\n\nif x not in curr:\n    print(\"No\")\n    return\n\ncurr = dd(int)\ncurr[sty] = 1\n\nfor yb in y_blocks:\n    nxt = dd(int)\n\n    for key in curr.keys():\n        nxt[key + yb] += 1\n        nxt[key - yb] += 1\n\n    curr = nxt\n\nif y not in curr:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\n\n", "# -*- coding: utf-8 -*-\ns = input()+\"T\"\nn = len(s)\nx,y = list(map(int, input().split()))\n\nfcnt = 0\ntcnt = 0\nxd = set()\nyd = set([0])\nfor i in range(n):\n    if s[i]==\"F\":\n        fcnt += 1\n        continue\n\n    if tcnt==0:\n        xd.add(fcnt)\n    elif tcnt%2==0:\n        # x\u8ef8\u306e\u79fb\u52d5\n        tmp = set()\n        for xx in xd:\n            tmp.add(xx-fcnt)\n            tmp.add(xx+fcnt)\n        xd = tmp\n    else:\n        # y\u8ef8\u306e\u79fb\u52d5\n        tmp = set()\n        for yy in yd:\n            tmp.add(yy-fcnt)\n            tmp.add(yy+fcnt)\n        yd = tmp\n    tcnt += 1\n    fcnt = 0\n\nif x in xd and y in yd:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "\ndef search(arr, start):\n    s = set()\n    s.add(start)\n    for i in arr:\n        ns = set()\n        for j in s:\n            ns.add(j+i)\n            ns.add(j-i)\n        s = ns\n    return s\n\ndef main():\n    t = 0\n    xd, yd = [], []\n\n    inst = list(input())\n    x, y = list(map(int, input().split()))\n\n    xcum = 0\n    ycum = 0\n    first = True\n\n    startx = 0\n    for s in inst:\n        if s == 'T':\n            t += 1\n            t %= 2\n            if first:\n                startx = xcum\n                xcum = 0\n                first = False\n                continue\n            if xcum > 0:\n                xd.append(xcum)\n                xcum = 0\n            if ycum > 0:\n                yd.append(ycum)\n                ycum = 0\n        else:\n            if t == 0:\n                xcum += 1\n            else:\n                ycum += 1\n    if first:\n        startx = xcum\n    elif xcum > 0:\n        xd.append(xcum)\n        xcum = 0\n    if ycum > 0:\n        yd.append(ycum)\n        ycum = 0\n\n    # print(startx)\n    # print(xd, yd)\n    # print(search(xd, startx), search(yd, 0))\n    if x in search(xd, startx) and y in search(yd, 0):\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input().split(\"T\")\nx,y = map(int,input().split())\nxmove = []\nymove = []\nfor i in range(len(s)):\n    if i % 2 == 1:\n        ymove.append(s[i].count(\"F\"))\n    else:\n        xmove.append(s[i].count(\"F\"))\n#\u30ea\u30b9\u30c8\u3067\u6301\u3064dp\u3060\u3068TLE\u3057\u305f\u306e\u3067\u30e1\u30e2\u5316\u518d\u5e30\u3067\u66f8\u304f\n\ndef solve(l,cor):\n    dp = {0}\n    for c in l:\n        dp = {c+i for i in dp}|{i-c for i in dp}\n    return cor in dp\n\nif solve(xmove[1:],x-xmove[0]) and solve(ymove,y):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import sys\ns=input()\nA,B =map(int,input().split())\ntable=[[] for i in range(2)]#0\u304c\u6a2a1\u304c\u7e26\nt = 0\nk=0\nfor i in range(len(s)):\n    if s[i]=='F':\n        k+=1\n    else:\n        table[t].append(k)\n        t=(t+1)%2\n        k=0\ntable[t].append(k)\nL=len(s)\nLx=[set() for i in range(len(table[0]) +1)]\nLy=[set() for i in range(len(table[1]) +1)]\nLx[0].add(0)\nLy[0].add(0)\nfor i in range(len(table[0])):\n    x = table[0][i]\n    if i==0:\n        Lx[1].add(x)\n        continue\n    for a in Lx[i]:\n        if -L<=a+x<=L:\n            Lx[i+1].add(a+x)\n        if -L<=a-x<=L:\n            Lx[i+1].add(a-x) \nflag=True\nfor a in Lx[len(table[0])]:\n    if a==A:\n        flag =False\nif flag:\n    print('No')\n    return\n    \nfor i in range(len(table[1])):\n    x = table[1][i]\n    for a in Ly[i]:\n        if -L<=a+x<=L:\n            Ly[i+1].add(a+x)\n        if -L<=a-x<=L:\n            Ly[i+1].add(a-x)\nflag=True\nfor a in Ly[len(table[1])]:\n    if a==B:\n        flag =False\nif flag:\n    print('No')\n    return\n    \nprint('Yes')", "#!python3\n\n# input\nS = input()\nX, Y = list(map(int, input().split()))\n\n\ndef judge(l, m):\n    s = sum(l)\n    t = s - m if m > 0 else s + m\n    if t < 0 or t % 2 == 1:\n        return False\n\n    t //= 2\n    n = len(l)\n    w = [[False] * (t + 1) for _ in range(n + 1)]\n    w[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(t + 1):\n            if w[i - 1][j]:\n                w[i][j] = True\n                if j + l[i - 1] <= t:\n                    w[i][j + l[i - 1]] = True\n\n    return w[-1][-1]                \n\n\ndef main():\n    n = len(S)\n    d = 0\n    for s in S:\n        if s == \"F\":\n            d += 1\n        else:\n            break\n\n    dx, dy = [], []\n    side = True\n    i = d\n    while i < n:\n        # change\n        while i < n and S[i] == \"T\":\n            side = not side\n            i += 1\n        \n        # forward\n        c = 0\n        while i < n and S[i] == \"F\":\n            c += 1\n            i += 1\n        if side:\n            dx.append(c)\n        else:\n            dy.append(c)\n    \n    b1 = judge(dx, X - d)\n    b2 = judge(dy, Y)\n    ans = \"Yes\" if b1 and b2 else \"No\"\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nx, y = map(int,input().split())\n\nFT_1 = [0]\nFT_2 = [0]\n\nstate = 1\nfor a in s:\n  if a == \"T\":\n    if state == 1:\n      state = 2\n      FT_2.append(0)\n    else: # if state == 2:\n      state = 1\n      FT_1.append(0)\n  else:\n    if state == 1:\n      FT_1[-1] += 1\n    else:\n      FT_2[-1] += 1\n      \nDP_1 = 1\nx -= FT_1[0]\nx -= -sum(FT_1[1:])\n\nDP_2 = 1\ny -= FT_2[0]\ny -= -sum(FT_2[1:])\n\nfor v in FT_1[1:]:\n  DP_1 |= (DP_1 << 2*v)\nfor v in FT_2[1:]:\n  DP_2 |= (DP_2 << 2*v)\n  \nif x >= 0 and y >= 0 and (DP_1 >> x) & 1 and (DP_2 >> y) & 1:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n\n\"\"\"\nprint(x,y)\nprint(FT_1)\nprint(FT_2)\nprint(DP_1)\nprint(DP_2)\n\"\"\"", "# \u5165\u529b\ns = input()\nx, y = list(map(int, input().split()))\n\nC = [len(fs) for fs in s.split('T')]\n\n\n# \u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u308a\u3001\u5404\u8ef8\u306b\u3064\u3044\u3066\u5230\u9054\u53ef\u80fd\u306a\u5ea7\u6a19\u306e\u96c6\u5408\u3092\u6c42\u3081\u3001\u76ee\u6a19\u306e\u5ea7\u6a19\u306b\u5230\u9054\u53ef\u80fd\u304b\u5224\u5b9a\ndef f(cs, t):\n    dp = {0}\n    for c in cs:\n        dp = {i + c for i in dp} | {i - c for i in dp}\n    return t in dp\n\n\nans = (\n    'Yes' if f(C[2::2], x - C[0]) and f(C[1::2], y) else\n    'No'\n)\n# \u51fa\u529b\nprint(ans)\n", "s = input()\nx, y = map(int, input().split())\n\ntInd = [i for i, x in enumerate(s) if x == 'T']\n\nxs = []\nys = [0]\nanswer = 'No'\nxa = False\nfirstT = False\nif s[0] == 'T':\n    firstT = True\n\nstart = 0\nisx = 1\nfor i in tInd:\n    if isx==1:\n        xs.append(i - start)\n    else:\n        ys.append(i - start)\n    isx *= -1\n    start=i+1\nif isx==1:\n    xs.append(len(s) - start)\nelse:\n    ys.append(len(s) - start)\n\ncset = {0}\nfor index,item in enumerate(xs):\n    tcset = set()\n    if index==0 and not firstT:\n        tcset.add(item)\n    else:\n        for c in cset:\n            tcset.add(c+item)\n            tcset.add(c-item)\n    cset = tcset\nif x in cset:\n    xa = True\n\nif xa:\n    cset = {0}\n    for item in ys:\n        tcset = set()\n        for c in cset:\n            tcset.add(c+item)\n            tcset.add(c-item)\n        cset = tcset\n    if y in cset:\n        answer = 'Yes'\n\nprint(answer)", "def f(m,l):\n    tmpm=set()\n    for x in m:\n        tmpm.add(x+l);tmpm.add(x-l)\n    return tmpm\n\ns=input()+\"T\"\nx,y=map(int,input().split())\n\nwhile s and s[0]==\"F\":\n    x-=1\n    s=s[1:]\nss=[{0},{0}]\nmode=0\nl=0\nfor i in range(len(s)):\n    if s[i]==\"F\": l+=1\n    else:\n        ss[mode]=f(ss[mode],l)    \n        mode^=1\n        l=0\n\nprint(\"Yes\" if x in ss[0] and y in ss[1] else \"No\")", "import sys\nreadline = sys.stdin.readline\n\ndef main():\n    s = readline()\n    X, Y = list(map(int, readline().split()))\n\n    data = []\n    step, temp_T = 0, 0\n    for c in s:\n        if c == 'F':\n            step += 1\n        else:\n            if step == 0:\n                temp_T += 1\n            else:\n                data.append([step, temp_T])\n                step = 0\n                temp_T = 1\n\n    for i in range(1, len(data)):\n        data[i][1] += data[i - 1][1]\n\n    right, horizontal, vertical = 0, [], []\n    for s, t in data:\n        if t == 0:\n            right += s\n        elif t & 1:\n            vertical.append(s)\n        else:\n            horizontal.append(s)\n\n    dp_h, dp_v = {}, {}\n    dp_h[right] = 1; dp_v[0] = 1\n    for dx in horizontal:\n        dp_h_temp = {}\n        for x in dp_h:\n            if x + dx in dp_h_temp:\n                dp_h_temp[x + dx] += dp_h[x]\n            else:\n                dp_h_temp[x + dx] = dp_h[x]\n            if x - dx in dp_h_temp:\n                dp_h_temp[x - dx] += dp_h[x]\n            else:\n                dp_h_temp[x - dx] = dp_h[x]\n        dp_h = dp_h_temp.copy()\n\n    for dy in vertical:\n        dp_v_temp = {}\n        for y in dp_v:\n            if y + dy in dp_v_temp:\n                dp_v_temp[y + dy] += dp_v[y]\n            else:\n                dp_v_temp[y + dy] = dp_v[y]\n            if y - dy in dp_v_temp:\n                dp_v_temp[y - dy] += dp_v[y]\n            else:\n                dp_v_temp[y - dy] = dp_v[y]\n        dp_v = dp_v_temp.copy()\n\n    print(('Yes' if X in dp_h and Y in dp_v else 'No'))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import reduce\n\n# \u5165\u529b\ns = input()\nx, y = list(map(int, input().split()))\n\nC = [len(fs) for fs in s.split('T')]\n\n\n# \u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u308a\u3001\u5404\u8ef8\u306b\u3064\u3044\u3066\u5230\u9054\u53ef\u80fd\u306a\u5ea7\u6a19\u306e\u96c6\u5408\u3092\u6c42\u3081\u3001\u76ee\u6a19\u306e\u5ea7\u6a19\u306b\u5230\u9054\u53ef\u80fd\u304b\u5224\u5b9a\ndef f(cs, t):\n    return t in reduce(\n        lambda acc, c: {i + c for i in acc} | {i - c for i in acc},\n        cs,\n        {0}\n    )\n\n\nans = (\n    'Yes' if f(C[2::2], x - C[0]) and f(C[1::2], y) else\n    'No'\n)\n# \u51fa\u529b\nprint(ans)\n", "import math\nimport itertools\nimport heapq\nfrom sys import stdin, stdout, setrecursionlimit\nfrom bisect import bisect, bisect_left, bisect_right\nfrom collections import defaultdict, deque\n\n\n# d = defaultdict(lambda: 0)\n# setrecursionlimit(10**7)\n# inf = float(\"inf\")\n\n\n##### stdin ####\ndef LM(t, r): return list(map(t, r))\ndef R(): return stdin.readline()\ndef RS(): return R().split()\ndef I(): return int(R())\ndef F(): return float(R())\ndef LI(): return LM(int,RS())\ndef LF(): return LM(float,RS())\ndef ONE_SL(): return list(input())\ndef ONE_IL(): return LM(int, ONE_SL())\ndef ALL_I(): return map(int, stdin)\ndef ALL_IL(): return LM(int,stdin)\n\n##### tools #####\ndef ap(f): return f.append\ndef pll(li): print('\\n'.join(LM(str,li)))\ndef pljoin(li, s): print(s.join(li))\n\n##### main #####\n\n\n\ndef main():\n\tss = input().split('T')\n\tx, y = map(int, input().split())\n\t \n\tdpx = dict()\n\tdpy = dict()\n\t \n\tdpx[0+len(ss[0])] = True\n\tdpy[0] = True\n\t \n\tdirect = 1 #0:x, 1:y\n\t \n\t \n\tfor s in ss[1:]:\n\t\ttmp = dict()\n\t\tn = len(s)\n\t\tif direct%2 == 0: \n\t\t\tfor k, v in dpx.items():\n\t\t\t\ttmp[k+n] = True\n\t\t\t\ttmp[k-n] = True\n\t\t\tdpx = tmp\n\t\telse:\n\t\t\tfor k, v in dpy.items():\n\t\t\t\ttmp[k+n] = True\n\t\t\t\ttmp[k-n] = True\n\t\t\tdpy = tmp\n\n\t\t# print(dpx, dpy)\n\t\tdirect += 1\n\t \t\n\n\tif x in dpx and y in dpy:\n\t    print('Yes')\n\telse:\n\t    print('No')\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "# -*- coding: utf-8 -*-\n\nss = input().split('T')\nx, y = list(map(int, input().split()))\n\ndpx = dict()\ndpy = dict()\n\ndpx[0+len(ss[0])] = True\ndpy[0] = True\n\ndirect = 1 #0:x, 1:y\n\n\nfor s in ss[1:]:\n    if direct%2 == 0:\n        tmp = dict()\n        n = len(s)\n        for k, v in list(dpx.items()):\n            tmp[k+n] = True\n            tmp[k-n] = True\n        direct += 1\n        dpx = tmp\n    else:\n        tmp = dict()\n        n = len(s)\n        for k, v in list(dpy.items()):\n            tmp[k+n] = True\n            tmp[k-n] = True\n        direct += 1\n        dpy = tmp\n\n# print(x, y)\n# print(dpx, dpy)\n# print(x in dpx)\n# print(y in dpy)\nif x in dpx and y in dpy:\n    print('Yes')\nelse:\n    print('No')\n", "import sys\nS = input()\nx,y = list(map(int,input().split()))\n\nf_first = S[0] == 'F'\nx_moves = []\ny_moves = []\nx_dir = False\nsp = S.split('T')\nfor c in sp:\n    l = len(c)\n    x_dir = not x_dir\n    if l > 0:\n        if x_dir:\n            if f_first:\n                x -= l\n                f_first = False\n            else:\n                x_moves.append(l)\n        else:\n            y_moves.append(l)\n\nx,y = abs(x),abs(y)\nsum_x, sum_y = sum(x_moves),sum(y_moves)\nif x > sum_x or y > sum_y:\n    print('No')\n    return\n\ndef ok(moves, summ, to):\n    if len(moves) == 0: return to == 0\n    ss = set([0])\n    rem = summ\n    for m1 in moves:\n        rem -= m1\n        _ss = set()\n        for m2 in ss:\n            if m2 + m1 <= to + rem:\n                _ss.add(m2 + m1)\n            if m2 - m1 >= to - rem:\n                _ss.add(m2 - m1)\n        ss = _ss\n    return to in ss\n\nprint(('Yes' if ok(x_moves,sum_x,x) and ok(y_moves,sum_y,y) else 'No'))\n"]
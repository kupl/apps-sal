["import sys\n\nclass SegmTree():\n    def __init__(self, array=None):\n        size = len(array)\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*self.N)\n        for i in range(size):\n            self.tree[i+self.N] = array[i]\n        self.build()\n\n    def build(self):\n        for i in range(self.N - 1, 0, -1):\n            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]\n \n    def add(self, i, value=1):\n        i += self.N\n        while i > 0:\n            self.tree[i] += value\n            i >>= 1\n    \n    def get_sum(self, l, r):\n        N = self.N\n        l += N\n        r += N\n        result = 0\n        while l < r:\n            if l & 1:\n                result += self.tree[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                result += self.tree[r]\n            l >>= 1\n            r >>= 1\n        return result\n    \n    def find_kth_nonzero(self, k):\n        i = 1\n        if k < 1 or k > self.tree[1]:\n            return -1\n        while i < self.N:\n            i <<= 1\n            if self.tree[i] < k:\n                k -= self.tree[i]\n                i |= 1\n        return i - self.N\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\nord_p = [0] * n\nord_q = [0] * n\n\nst = SegmTree([1] * n)\nfor i, val in enumerate(p):\n    ord_p[i] = st.get_sum(0, val)\n    st.add(val, -1)\n\nst = SegmTree([1] * n)\nfor i, val in enumerate(q):\n    ord_q[i] = st.get_sum(0, val)\n    st.add(val, -1)\n\ntransfer = 0\nfor i in range(n-1, -1, -1):\n    radix = n-i\n    ord_p[i] = ord_p[i] + ord_q[i] + transfer\n    if ord_p[i] < radix:\n        transfer = 0\n    else:\n        transfer = 1\n        ord_p[i] -= radix\n\nst = SegmTree([1] * n)\nfor i in range(n):\n    k = ord_p[i] + 1\n    ord_q[i] = st.find_kth_nonzero(k)\n    st.add(ord_q[i], -1)\n\nprint(*ord_q)\n", "import sys\n \nclass SegmTree():\n    def __init__(self, array=None):\n        size = len(array)\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*self.N)\n        for i in range(size):\n            self.tree[i+self.N] = array[i]\n        self.build()\n \n    def build(self):\n        for i in range(self.N - 1, 0, -1):\n            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]\n \n    def add(self, i, value=1):\n        i += self.N\n        while i > 0:\n            self.tree[i] += value\n            i >>= 1\n    \n    def get_sum(self, l, r):\n        N = self.N\n        l += N\n        r += N\n        result = 0\n        while l < r:\n            if l & 1:\n                result += self.tree[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                result += self.tree[r]\n            l >>= 1\n            r >>= 1\n        return result\n    \n    def find_kth_nonzero(self, k):\n        i = 1\n        if k < 1 or k > self.tree[1]:\n            return -1\n        while i < self.N:\n            i <<= 1\n            if self.tree[i] < k:\n                k -= self.tree[i]\n                i |= 1\n        return i - self.N\n \nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n \nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n \nord_p = []\nord_q = []\n \nst = SegmTree([1] * n)\nfor i, val in enumerate(p):\n    ord_p.append(st.get_sum(0, val))\n    st.add(val, -1)\n \nst = SegmTree([1] * n)\nfor i, val in enumerate(q):\n    ord_q.append(st.get_sum(0, val))\n    st.add(val, -1)\n \ntransfer = 0\nfor i in range(n-1, -1, -1):\n    radix = n-i\n    ord_p[i] = ord_p[i] + ord_q[i] + transfer\n    if ord_p[i] < radix:\n        transfer = 0\n    else:\n        transfer = 1\n        ord_p[i] -= radix\n \nst = SegmTree([1] * n)\nfor i in range(n):\n    k = ord_p[i] + 1\n    ord_q[i] = st.find_kth_nonzero(k)\n    st.add(ord_q[i], -1)\n \nprint(*ord_q)\n", "def sum(BIT, i):\n    s = 0\n    while i > 0:\n        s += BIT[i]\n        i -= i & (-i)\n    return s\n\n\ndef update(BIT, i, v):\n    while i < len(BIT):\n        BIT[i] += v\n\n        i += i & (-i)\n\n\ndef find(fen, k):\n    curr = 0\n    ans = 0\n    prevsum = 0\n    for i in range(19, -1, -1):\n        if ((curr + (1 << i) < n) and fen[curr + (1 << i)] + prevsum < k):\n            ans = curr + (1 << i)\n            curr = ans\n            prevsum += fen[curr]\n    return ans + 1\n\ndef Rank(x,BIT) :\n\n    return sum(BIT,x)\n\n\n\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\nfactp = []\nfactq = []\n\n\n\n\nBIT = [0] * (n + 1)\nfor j in range(n):\n    update(BIT,j+1,1)\n\n\nfor val in p:\n    factp.append(Rank(val+1,BIT)-1)\n    update(BIT,val+1,-1)\n\n\n\n\nBIT = [0] * (n + 1)\nfor j in range(n):\n    update(BIT,j+1,1)\n\n\nfor val in q:\n    factq.append(Rank(val+1,BIT)-1)\n    update(BIT,val+1,-1)\n\n\n\n\n\ncarry = 0\nfor i in range(n - 1, -1, -1):\n    radix = n - i\n    factp[i] = factp[i] + factq[i] + carry\n    if factp[i] < radix:\n        carry = 0\n    else:\n        carry = 1\n        factp[i] -= radix\n\n\nBIT = [0] * (n + 1)\nfor j in range(n):\n    update(BIT,j+1,1)\nres=[]\nfor i in range(n):\n    k = factp[i]+1\n    res.append(find(BIT,k)-1)\n    update(BIT,res[-1]+1,-1)\n\nprint(*res)"]
["it = lambda: list(map(int, input().strip().split()))\nINF = float('inf')\n\n\ndef solve():\n    N = int(input())\n    S = []\n    R = []\n    C = []\n    for _ in range(N):\n        s, c = input().strip().split()\n        S.append(s)\n        R.append(s[::-1])\n        C.append(int(c))\n    \n    vis = set()\n    mem = dict()\n\n    def dp(s, p):\n        if (s, p) in mem: return mem[s, p]\n        if s == s[::-1]: return 0\n        if (s, p) in vis: return INF\n\n        ans = INF\n        vis.add((s, p))\n        for i, t in enumerate(S if p else R):\n            if len(t) >= len(s) and t.startswith(s):\n                ans = min(ans, dp(t[len(s):], p ^ 1) + C[i])\n            elif len(s) > len(t) and s.startswith(t):\n                ans = min(ans, dp(s[len(t):], p) + C[i])\n        vis.discard((s, p))\n        mem[s, p] = ans\n        return ans\n        \n    ans = INF\n    for i in range(N):\n        ans = min(ans, dp(S[i], 0) + C[i])\n    return -1 if ans == INF else ans\n\n\ndef __starting_point():\n    ans = solve()\n    print(ans)\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\nINF = 10**12\nLIM = 20\nN = int(input())\nD = dict()\nfor _ in range(N):\n    s, c = input().split()\n    if s in list(D.keys()):\n        D[s] = min(D[s], int(c))\n    else:\n        D[s] = int(c)\n\ndef check_kaibun(s):\n    n = len(s)\n    return all(s[i] == s[-i-1] for i in range(n//2))\n\ndef calc_cost(use):\n    return sum(D[s] * n for (s, n) in list(use.items()))\n\ndef find_candidate(cost, use, s, is_left):\n    if check_kaibun(s):\n        return min(cost, calc_cost(use))\n\n    if is_left:\n        for t in list(D.keys()):\n            # reversed s is included in the end of t\n            if t[::-1].find(s) == 0:\n                use[t] += 1\n                if use[t] > LIM:\n                    return INF\n                c = find_candidate(cost, use, t[:-len(s):], False)\n                cost = min(cost, c)\n                use[t] -= 1\n            # reveresed t is included in the begin of s\n            elif s.find(t[::-1]) == 0:\n                use[t] += 1\n                c = find_candidate(cost, use, s[len(t):], True)\n                cost = min(cost, c)\n                use[t] -= 1\n    else:\n        for t in list(D.keys()):\n            # t is included in the end of reversed s\n            if s[::-1].find(t) == 0:\n                use[t] += 1\n                c = find_candidate(cost, use, s[:-len(t):], False)\n                cost = min(cost, c)\n                use[t] -= 1\n            # s is included in the begin of reveresed t\n            elif t.find(s[::-1]) == 0:\n                use[t] += 1\n                c = find_candidate(cost, use, t[len(s):], True)\n                cost = min(cost, c)\n                use[t] -= 1\n\n    return min(cost, INF)\n\ndef solve():\n    ans = INF\n    for s in list(D.keys()):\n        use = {s: 0 for s in list(D.keys())}\n        use[s] = 1\n        ans = find_candidate(ans, use, s, True)\n    return ans if ans < INF else -1\n\ndef __starting_point():\n    print((solve()))\n\n__starting_point()", "from heapq import heapify, heappop, heappush\n\n\ndef rolling(s):\n    \"\"\"\n    \u6587\u5b57\u5217 [i, j] \u306e\u30cf\u30c3\u30b7\u30e5\n    j < i \u306e\u5834\u5408\u306f\u9006\u9806\n    \"\"\"\n    n = len(s)\n    ret = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        rh = 0\n        for j in range(i, n):\n            b = ord(s[j]) - 96\n            rh = rh * 27 + b\n            ret[i][j] = rh\n\n    for j in range(n):\n        rh = 0\n        for i in range(j, -1, -1):\n            b = ord(s[i]) - 96\n            rh = rh * 27 + b\n            ret[j][i] = rh\n\n    return ret\n\n\ndef solve(n, sss, ccc, rhs):\n    INF = 10 ** 18\n    ans = INF\n    q = []\n    for i in range(n):\n        s = sss[i]\n        c = ccc[i]\n        l = len(s)\n\n        q.append((c, 0, i, 0))\n        q.append((c, 1, i, l - 1))\n\n        for j in range(l):\n            k = 1\n            while j - k >= 0 and j + k < l:\n                if s[j - k] != s[j + k]:\n                    break\n                k += 1\n            else:\n                if j - k == -1 and j + k == l:\n                    ans = min(ans, c)\n                elif j - k == -1:\n                    q.append((c, 0, i, j + k))\n                else:\n                    q.append((c, 1, i, j - k))\n\n        for j in range(l - 1):\n            k = 0\n            while j - k >= 0 and j + k + 1 < l:\n                if s[j - k] != s[j + k + 1]:\n                    break\n                k += 1\n            else:\n                if j - k == -1 and j + k + 1 == l:\n                    ans = min(ans, c)\n                elif j - k == -1:\n                    q.append((c, 0, i, j + k + 1))\n                else:\n                    q.append((c, 1, i, j - k))\n\n    heapify(q)\n\n    checked = []\n    for s in sss:\n        checked.append([[False, False] for _ in range(len(s))])\n\n    while q:\n        cost, fb, i, j = heappop(q)\n        if cost >= ans:\n            break\n        if checked[i][j][fb]:\n            continue\n        s = sss[i]\n        ls = len(s)\n        lm = ls - j if fb == 0 else j + 1\n        checked[i][j][fb] = True\n        rhr = rhs[i][j]\n\n        if fb == 0:\n            for ti in range(n):\n                t = sss[ti]\n                lt = len(t)\n                if lm == lt:\n                    if rhs[ti][-1][0] == rhr[-1]:\n                        ans = min(ans, cost + ccc[ti])\n                elif lm > lt:\n                    if rhs[ti][-1][0] == rhr[j + lt - 1]:\n                        heappush(q, (cost + ccc[ti], 0, i, j + lt))\n                else:\n                    if rhs[ti][-1][lt - lm] == rhr[-1]:\n                        heappush(q, (cost + ccc[ti], 1, ti, lt - lm - 1))\n        else:\n            for ti in range(n):\n                t = sss[ti]\n                lt = len(t)\n                if lm == lt:\n                    if rhs[ti][0][-1] == rhr[0]:\n                        ans = min(ans, cost + ccc[ti])\n                elif lm > lt:\n                    if rhs[ti][0][-1] == rhr[j - lt + 1]:\n                        heappush(q, (cost + ccc[ti], 1, i, j - lt))\n                else:\n                    if rhs[ti][0][lm - 1] == rhr[0]:\n                        heappush(q, (cost + ccc[ti], 0, ti, lm))\n\n    if ans == INF:\n        return -1\n    else:\n        return ans\n\n\nn = int(input())\nsss = []\nccc = []\nrhs = []\nfor si in range(n):\n    s, c = input().split()\n    sss.append(s)\n    ccc.append(int(c))\n    rhs.append(rolling(s))\n\nprint((solve(n, sss, ccc, rhs)))\n", "from random import randrange\nfrom heapq import heapify, heappush, heappop\nfrom time import time\nK = 60\nrand = lambda: randrange(1 << K)\nsTime = time()\nN = int(input())\nS, IS, C = [], [], []\nfor _ in range(N):\n    s, c = input().split()\n    S.append(s)\n    IS.append(s[::-1])\n    C.append(int(c))\n\nD = {}\ndone = [set(), set()]\nr = rand()\nD[r] = (0, \"\", 0)\nH = [r]\nans = 1 << K\nwhile H:\n    r = heappop(H)\n    if time() - sTime > 1.7:\n        break\n    d, s, c = D[r]\n    if s in done[d]: continue\n    done[d].add(s)\n    if d == 0:\n        for ss, cc in zip(S, C):\n            m = min(len(s), len(ss))\n            if s[:m] == ss[:m]:\n                if abs(len(s) - len(ss)) <= 1 or len(ss) > len(s) and ss[m:] == ss[m:][::-1]:\n                    ans = min(ans, c + cc)\n                else:\n                    if len(s) < len(ss):\n                        r = rand() + (c + cc << K)\n                        D[r] = (1, ss[m:], c + cc)\n                        heappush(H, r)\n                    else:\n                        r = rand() + (c + cc << K)\n                        D[r] = (0, s[m:], c + cc)\n                        heappush(H, r)\n    else:\n        for ss, cc in zip(IS, C):\n            m = min(len(s), len(ss))\n            if s[:m] == ss[:m]:\n                if abs(len(s) - len(ss)) <= 1 or len(ss) > len(s) and ss[m:] == ss[m:][::-1]:\n                    ans = min(ans, c + cc)\n                else:\n                    if len(s) < len(ss):\n                        r = rand() + (c + cc << K)\n                        D[r] = (0, ss[m:], c + cc)\n                        heappush(H, r)\n                    else:\n                        r = rand() + (c + cc << K)\n                        D[r] = (1, s[m:], c + cc)\n                        heappush(H, r)\n\nprint(ans if ans < 1 << K - 2 else -1)", "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nST=[input().split() for i in range(N)]\n\nfor i in range(N):\n    ST[i][1]=int(ST[i][1])\n\nST.sort()\n\nST2=[]\nfor i in range(N):\n    if i>0 and ST[i][0]==ST[i-1][0]:\n        continue\n    ST2.append((ST[i][0],ST[i][1]))\nST=ST2\n\n\nFDICT=dict()\nBDICT=dict()\n\nfor s,i in ST:\n    FDICT[s[::-1]]=i\n    BDICT[s[::-1]]=i\n\n    for j in range(1,len(s)):\n        if not(s[:j][::-1] in BDICT):\n            BDICT[s[:j][::-1]]=1<<60\n        if not(s[-j:][::-1] in FDICT):\n            FDICT[s[-j:][::-1]]=1<<60\n\nANS=1<<60\nflag=0\nfor rep in range(1<<60):\n    flag=0\n    for f in FDICT:\n        lf=len(f)\n        for s,i in ST:\n            ls=len(s)\n\n            if lf == ls:\n                if s==f:\n                    ANS=min(ANS,FDICT[f]+i)\n            elif ls>lf:\n                if s[-lf:]==f and BDICT[s[:-lf][::-1]]>FDICT[f]+i:\n                    BDICT[s[:-lf][::-1]]=FDICT[f]+i\n                    flag=1\n            else:\n                if f[-ls:]==s and FDICT[f[:-ls]]>FDICT[f]+i:\n                    FDICT[f[:-ls]]=FDICT[f]+i\n                    flag=1\n                    \n\n    for b in BDICT:\n        lb=len(b)\n        for s,i in ST:\n            ls=len(s)\n\n            if lb == ls:\n                if s==b:\n                    ANS=min(ANS,BDICT[b]+i)\n            elif ls>lb:\n                if s[:lb]==b and FDICT[s[lb:][::-1]]>BDICT[b]+i:\n                    FDICT[s[lb:][::-1]]=BDICT[b]+i\n                    flag=1\n                    \n            else:\n                if b[:ls]==s and BDICT[b[ls:]]>BDICT[b]+i:\n                    BDICT[b[ls:]]=BDICT[b]+i\n                    flag=1\n    if flag==0:\n        break\n                    \n\nfor f in FDICT:\n    if f==f[::-1]:\n        ANS=min(ANS,FDICT[f])\n\nfor b in BDICT:\n    if b==b[::-1]:\n        ANS=min(ANS,BDICT[b])\n\nif ANS==1<<60:\n    print((-1))\nelse:\n    print(ANS)\n", "'''\n\u81ea\u5b85\u7528PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport itertools\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\n# mod = 998244353\ndir = [(-1,0),(0,-1),(1,0),(0,1)]\nalp = \"abcdefghijklmnopqrstuvwxyz\"\nINF = 1<<32-1\n# INF = 10**18\n\ndef main():\n    n = int(ipt())\n    wrds = []\n    hq = []\n    usd = set()\n    for i in range(n):\n        s,c = input().split()\n        c = int(c)\n        wrds.append((s,c))\n        hpq.heappush(hq,(c,s,1))\n\n    while hq:\n        hc,hs,hp = hpq.heappop(hq)\n        usd.add((hs,hp))\n        ls = len(hs)\n        if hs == hs[::-1]:\n            print(hc)\n            return\n        for si,ci in wrds:\n            lsi = len(si)\n            if lsi > ls:\n                if hp == 1:\n                    wt = si[::-1]\n#                    print(wt)\n                    if hs == wt[:ls:] and not (wt[ls::],-1) in usd:\n                        hpq.heappush(hq,(hc+ci,wt[ls::],-1))\n                else:\n                    if hs == si[:ls:] and not (si[ls::],1) in usd:\n                        hpq.heappush(hq,(hc+ci,si[ls::],1))\n            else:\n                if hp == 1:\n                    wt = si[::-1]\n                    if wt == hs[:lsi:] and not (hs[lsi::],1) in usd:\n                        hpq.heappush(hq,(hc+ci,hs[lsi::],1))\n                else:\n                    if si == hs[:lsi:] and not (hs[lsi::],-1) in usd:\n                        hpq.heappush(hq,(hc+ci,hs[lsi::],-1))\n#        print(hq)\n\n    print((-1))\n\n\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nfrom heapq import heappush, heappop, heapify\ndef main():\n    N = int(input())\n    SC = []\n    SCrev = []\n    for _ in range(N):\n        s, c = input().split()\n        c = int(c)\n        SC.append((s, c))\n        SCrev.append((s[::-1], c))\n    dist = defaultdict(lambda: 10**18)\n    q = [(c, s, \"\") for s, c in SC] + [(c, \"\", s) for s, c in SCrev]\n    for c, l, r in q:\n        dist[(l, r)] = min(dist[(l, r)], c)\n    heapify(q)\n    while q:\n        dist_v, vl, vr = heappop(q)\n        if (vl == vr == \"\") or (len(vl) and vl == vl[::-1]) or (len(vr) and vr == vr[::-1]):\n            print(dist_v)\n            return\n        if dist[(vl, vr)] != dist_v:\n            continue\n        if len(vl) < len(vr):\n            for s, c in SC:\n                if len(s) <= len(vr):\n                    if vr.startswith(s):\n                        vr_ = vr[len(s):]\n                        dist_u = dist_v + c\n                        if dist_u < dist[(\"\", vr_)]:\n                            dist[(\"\", vr_)] = dist_u\n                            heappush(q, (dist_v+c, \"\", vr_))\n                else:\n                    if s.startswith(vr):\n                        vl_ = s[len(vr):]\n                        dist_u = dist_v + c\n                        if dist_u < dist[(vl_, \"\")]:\n                            dist[(vl_, \"\")] = dist_u\n                            heappush(q, (dist_v+c, vl_, \"\"))\n        else:\n            for s, c in SCrev:\n                if len(s) <= len(vl):\n                    if vl.startswith(s):\n                        vl_ = vl[len(s):]\n                        dist_u = dist_v + c\n                        if dist_u < dist[(vl_, \"\")]:\n                            dist[(vl_, \"\")] = dist_u\n                            heappush(q, (dist_v+c, vl_, \"\"))\n                else:\n                    if s.startswith(vl):\n                        vr_ = s[len(vl):]\n                        dist_u = dist_v + c\n                        if dist_u < dist[(\"\", vr_)]:\n                            dist[(\"\", vr_)] = dist_u\n                            heappush(q, (dist_v+c, \"\", vr_))\n    print((-1))\n\nmain()\n", "it = lambda: list(map(int, input().strip().split()))\nINF = float('inf')\n\n\ndef solve():\n    N = int(input())\n    S = []\n    C = []\n    for _ in range(N):\n        s, c = input().strip().split()\n        S.append(s)\n        C.append(int(c))\n    \n    vis = set()\n    mem = dict()\n\n    def dp(s, p):\n        if (s, p) in mem:\n            return mem[s, p]\n\n        if s == s[::-1]:\n            return 0\n\n        if (s, p) in vis:\n            return INF\n\n        vis.add((s, p))\n\n        ans = INF\n        if p == 0:\n            for i in range(N):\n                if len(S[i]) >= len(s):\n                    if S[i][::-1].startswith(s):\n                        ans = min(ans, dp(S[i][:-len(s)], 1) + C[i])\n                else:\n                    if s.startswith(S[i][::-1]):\n                        ans = min(ans, dp(s[len(S[i]):], 0) + C[i])\n        else:\n            for i in range(N):\n                if len(S[i]) >= len(s):\n                    if S[i].startswith(s[::-1]):\n                        ans = min(ans, dp(S[i][len(s):], 0) + C[i])\n                else:\n                    if s[::-1].startswith(S[i]):\n                        ans = min(ans, dp(s[:-len(S[i])], 1) + C[i])\n\n        vis.discard((s, p))\n        mem[s, p] = ans\n        return ans\n        \n    ans = INF\n    for i in range(N):\n        ans = min(ans, dp(S[i], 0) + C[i])\n    return -1 if ans == INF else ans\n\n\ndef __starting_point():\n    ans = solve()\n    print(ans)\n__starting_point()"]
["from math import *\n\nc=int(input())\nx=[0]*c\ny=[0]*c\nvu=[False]*c\nfor i in range(c):\n    x[i],y[i]=[int(s) for s in input().split()]\nprix=[int(s) for s in input().split()]\nfil=[int(s) for s in input().split()]\nanc=[-1]*c\npmin=prix.copy()\nv=0\npl=[]\ne=0\nppl=[]\ntot=0\nfor i in range(c):\n    pmina=100000000000000000000000\n    for j in range(c):\n        if (not vu[j]) and pmin[j]<pmina:\n            pmini=j\n            pmina=pmin[j]\n    vu[pmini]=True\n    tot+=pmina\n    if anc[pmini]==-1:\n        v+=1\n        pl.append(str(pmini+1))\n    else:\n        e+=1\n        ppl.append([str(pmini+1),str(anc[pmini]+1)])\n    for j in range(c):\n        if (abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])<pmin[j]:\n            pmin[j]=(abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])\n            anc[j]=pmini\nprint(tot)\nprint(v)\nprint(\" \".join(pl))\nprint(e)\nfor i in ppl:\n    print(\" \".join(i))", "N = int(input())  # \u5e02\u306e\u6570\nXY = [list(map(int, input().split())) for _ in range(N)]\nC = list(map(int, input().split()))  # \u5e02 i \u306b\u767a\u96fb\u6240\u3092\u5efa\u3066\u308b\u30b3\u30b9\u30c8\nK = list(map(int, input().split()))  # \u3064\u306a\u3052\u308b\u30b3\u30b9\u30c8\n\nCC = [-1] * N\nAns = [-2] * N\ntotal_cost = 0\nfor _ in range(N):\n    mi = float(\"inf\")\n    for i, (c, an) in enumerate(zip(C, Ans)):\n        if an == -2 and mi > c:\n            mi = c\n            ami = i\n    total_cost += mi\n    Ans[ami] = CC[ami]\n    k1 = K[ami]\n    x1, y1 = XY[ami]\n    for i, (k2, (x2, y2)) in enumerate(zip(K, XY)):\n        new_cost = (k1+k2) * (abs(x1-x2)+abs(y1-y2))\n        if C[i] > new_cost:\n            C[i] = new_cost\n            CC[i] = ami\nprint(total_cost)\ncnt = Ans.count(-1)\nprint(cnt)\nA = []\nB = []\nfor i, a in enumerate(Ans, 1):\n    if a==-1:\n        A.append(i)\n    else:\n        B.append((i, a+1))\nprint(\" \".join(map(str, A)))\nprint(N - cnt)\nfor a, b in B:\n    print(a, b)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nT=[tuple(map(int,input().split())) for i in range(n)]\nC=list(map(int,input().split()))\nK=list(map(int,input().split()))\n\nimport heapq\nH=[]\n\nfor i,c in enumerate(C):\n    H.append((c,i+1))\n\nheapq.heapify(H)\n\nANS=0\nUSE=[0]*(n+1)\nANS1=[]\nANS2=[]\n\nwhile H:\n    x=heapq.heappop(H)\n    #print(x)\n    #print(H)\n\n    if len(x)==2:\n        cost,town=x\n\n        if USE[town]==1:\n            continue\n\n        ANS+=cost\n        USE[town]=1\n        ANS1.append(town)\n\n        xt,yt=T[town-1]\n\n        for i in range(n):\n            if USE[i+1]==1:\n                continue\n            costp=(abs(T[i][0]-xt)+abs(T[i][1]-yt))*(K[i]+K[town-1])\n            #print(costp,xt,yt,i)\n            if costp<C[i]:\n                C[i]=costp\n                heapq.heappush(H,(costp,town,i+1))\n\n    else:\n        cost,town1,town2=x\n        if USE[town1]==1 and USE[town2]==1:\n            continue\n\n        ANS+=cost\n        USE[town2]=1\n        ANS2.append((town1,town2))\n\n        xt,yt=T[town2-1]\n\n        for i in range(n):\n            if USE[i+1]==1:\n                continue\n            costp=(abs(T[i][0]-xt)+abs(T[i][1]-yt))*(K[i]+K[town2-1])\n            if costp<C[i]:\n                C[i]=costp\n                heapq.heappush(H,(costp,town2,i+1))\n\nsys.stdout.write(str(ANS)+\"\\n\")\nsys.stdout.write(str(len(ANS1))+\"\\n\")\nprint(*ANS1)\n\nsys.stdout.write(str(len(ANS2))+\"\\n\")\nfor x,y in ANS2:\n    sys.stdout.write(str(x)+\" \"+str(y)+\"\\n\")\n\n        \n            \n        \n        \n", "import sys\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (map(int, s.split()) for s in sys.stdin)\n\nn, = next(reader)\ncities = [None]\nfor _ in range(n):\n    x, y = next(reader)\n    cities.append((x, y))\ncs = [None] + list(next(reader))\nks = [None] + list(next(reader))\n\nn += 1\ng = [[None] * n for _ in range(n)]\nfor i in range(1, n):\n    for j in range(i + 1, n):\n        wire = ks[i] + ks[j]\n        dist = abs(cities[i][0] - cities[j][0]) + \\\n                abs(cities[i][1] - cities[j][1])\n        g[i][j] = g[j][i] = wire * dist\nfor i in range(1, n):\n    g[0][i] = g[i][0] = cs[i]\nfor i in range(n):\n    g[i][i] = float('inf')\n\ntotalCost = 0\nstations = []\nconnections = []\n\nused = [False] * n\nmin_e = [float('inf')] * n\nsel_e = [-1] * n\n\nstart = 0  # starting from 0-node (dummy node)\nmin_e[start] = 0\nfor i in range(n):\n    v = -1\n    for j in range(n):\n        if (not used[j] and (v == -1 or min_e[j] < min_e[v])):\n            v = j\n#     if min_e[v] == float('inf'): break\n    used[v] = True\n\n    fromNode = sel_e[v]\n    if not fromNode:  # edge (0, v) <=> v-node has station\n        totalCost += g[v][fromNode]\n        stations.append(v)\n    elif fromNode > 0:\n        totalCost += g[v][fromNode]\n        connections.append((v, fromNode))\n        \n    for to in range(n):\n        if g[v][to] < min_e[to]:\n            min_e[to] = g[v][to]\n            sel_e[to] = v\n\nprint(totalCost)\nprint(len(stations))\nprint(*stations)\nprint(len(connections))\n[print(c1, c2) for c1, c2 in connections];\n    \n# inf.close()", "import sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\nn, = next(reader)\ncities = [None]\nfor _ in range(n):\n    x, y = next(reader)\n    cities.append((x, y))\ncs = [None] + list(next(reader))\nks = [None] + list(next(reader))\n\nn += 1  # extra 0 node (dummy node); edge (0, v) <=> v-node has station\ng = [[None] * n for _ in range(n)]\nfor i in range(1, n):\n    for j in range(i + 1, n):\n        wire = ks[i] + ks[j]\n        dist = abs(cities[i][0] - cities[j][0]) + \\\n                abs(cities[i][1] - cities[j][1])\n        g[i][j] = g[j][i] = wire * dist\nfor i in range(1, n):\n    g[0][i] = g[i][0] = cs[i]\nfor i in range(n):\n    g[i][i] = float('inf')\n\ntotalCost = 0\nstations = []\nconnections = []\n\nused = [False] * n\nmin_e = [float('inf')] * n\nsel_e = [-1] * n\n\nstart = 0  # starting from 0-node (dummy node)\nmin_e[start] = 0\nfor i in range(n):\n    v = -1\n    for j in range(n):\n        if (not used[j] and (v == -1 or min_e[j] < min_e[v])):\n            v = j\n#     if min_e[v] == float('inf'): break\n    used[v] = True\n\n    fromNode = sel_e[v]\n    if not fromNode:  # edge (0, v) <=> v-node has station\n        totalCost += g[v][fromNode]\n        stations.append(v)\n    elif fromNode > 0:\n        totalCost += g[v][fromNode]\n        connections.append((v, fromNode))\n        \n    for to in range(n):\n        if g[v][to] < min_e[to]:\n            min_e[to] = g[v][to]\n            sel_e[to] = v\n\nmyprint = sys.stdout.write\nmyprint(str(totalCost) + '\\n')\nmyprint(str(len(stations)) + '\\n')\n[myprint(str(st) + ' ') for st in stations];\nmyprint(str(len(connections)) + '\\n')\n[myprint(str(c1) + ' ' + str(c2) + '\\n') for c1, c2 in connections];\n\n# print(totalCost)\n# print(len(stations))\n# print(*stations)\n# print(len(connections))\n# [print(c1, c2) for c1, c2 in connections];\n    \n# inf.close()\n", "import sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\nn, = next(reader)\nlocs = [tuple(next(reader)) for _ in range(n)]\ncs = list(next(reader))\nks = list(next(reader))\n\ntotalCost = 0\nstations = []\nconnections = []\n\nconnCosts = {i: cost for i, cost in enumerate(cs)}\nconnTo = [-1] * n\nwhile connCosts:\n    v = min(connCosts, key=connCosts.get)\n    totalCost += connCosts[v]\n    \n    if connCosts[v] < cs[v]:\n        to = connTo[v]\n        connections.append((v, to))        \n    else:\n        stations.append(v)\n        \n    connCosts.pop(v)\n    for to, cost in list(connCosts.items()):\n        wire = ks[v] + ks[to]\n        dist = abs(locs[v][0] - locs[to][0]) + \\\n                abs(locs[v][1] - locs[to][1])\n        newCost = wire * dist\n        if connCosts[to] > newCost:\n            connCosts[to] = newCost\n            connTo[to] = v\n            \nmyprint = sys.stdout.write\nmyprint(str(totalCost) + '\\n')\nmyprint(str(len(stations)) + '\\n')\n[myprint(str(st + 1) + ' ') for st in stations];\nmyprint(str(len(connections)) + '\\n')\n[myprint(str(c1 + 1) + ' ' + str(c2 + 1) + '\\n') for c1, c2 in connections];\n\n# print(totalCost)\n# print(len(stations))\n# print(*(st + 1 for st in stations))\n# print(len(connections))\n# [print(c1 + 1, c2 + 1) for c1, c2 in connections];\n    \n# inf.close()\n", "# refactored Prim's algorithm \n# (with dummy 0-node)\nimport sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\nn, = next(reader)\ncities = [None]\nfor _ in range(n):\n    x, y = next(reader)\n    cities.append((x, y))\ncs = [None] + list(next(reader))\nks = [None] + list(next(reader))\n\nn += 1  # extra dummy 0-node (source of power); edge (0, v) = c_v\ng = [[None] * n for _ in range(n)]\nfor i in range(1, n):\n    for j in range(i + 1, n):\n        wire = ks[i] + ks[j]\n        dist = abs(cities[i][0] - cities[j][0]) + \\\n                abs(cities[i][1] - cities[j][1])\n        g[i][j] = g[j][i] = wire * dist\nfor i in range(1, n):\n    g[0][i] = g[i][0] = cs[i]\nfor i in range(n):\n    g[i][i] = float('inf')\n\ntotalCost = 0\nstations = []\nconnections = []\n\nconnCosts = {i: float('inf') for i in range(n)}\nconnTo = [-1] * n\n\nstart = 0  # starting from dummy node\nconnCosts[start] = 0\nwhile connCosts:\n    # node with min connection cost\n    v = min(connCosts, key=connCosts.get)\n    if connCosts[v] == float('inf'): break\n\n    fromNode = connTo[v]\n    if not fromNode:  # edge (0, v) <=> v-node has station\n        totalCost += g[v][fromNode]\n        stations.append(v)\n    elif fromNode > 0:\n        totalCost += g[v][fromNode]\n        connections.append((v, fromNode))\n        \n    connCosts.pop(v)\n    for to, cost in list(connCosts.items()):\n        if g[v][to] < connCosts[to]:\n            connCosts[to] = g[v][to]\n            connTo[to] = v\n\nmyprint = sys.stdout.write\nmyprint(str(totalCost) + '\\n')\nmyprint(str(len(stations)) + '\\n')\n[myprint(str(st) + ' ') for st in stations];\nmyprint(str(len(connections)) + '\\n')\n[myprint(str(c1) + ' ' + str(c2) + '\\n') for c1, c2 in connections];\n\n# print(totalCost)\n# print(len(stations))\n# print(*stations)\n# print(len(connections))\n# [print(c1, c2) for c1, c2 in connections];\n    \n# inf.close()\n", "def prim(matrix, inf=10**18):\n    n = len(matrix)\n    costs = [inf] + [inf-1]*(n-1)\n    nearest = [-1]*n\n    current = 0\n    total_cost = 0\n\n    build, connect = [], []\n\n    for _ in range(n-1):\n        min_cost = inf\n        src, dest = -1, -1\n\n        for i in range(n):\n            if costs[i] == inf:\n                continue\n            if matrix[current][i] < costs[i]:\n                costs[i] = matrix[current][i]\n                nearest[i] = current\n            if min_cost > costs[i]:\n                min_cost = costs[i]\n                src, dest = nearest[i], i\n\n        total_cost += min_cost\n        costs[dest] = inf\n\n        if src == 0:\n            build.append(dest)\n        else:\n            connect.append('%d %d' % (src, dest))\n\n        current = dest\n\n    return build, connect, total_cost\n\n\ndef __starting_point():\n    import sys\n    n = int(input())\n    pos = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    c_costs = list(map(int, input().split()))\n    k_costs = list(map(int, input().split()))\n\n    inf = 10**18\n    matrix = [[inf]*(n+1) for _ in range(n+1)]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[i+1][j+1] = matrix[j+1][i+1] = \\\n                (abs(pos[i][0]-pos[j][0]) + abs(pos[i][1]-pos[j][1])) * (k_costs[i]+k_costs[j])\n\n        matrix[i+1][0] = matrix[0][i+1] = c_costs[i]\n\n    build, connect, cost = prim(matrix)\n    print(cost)\n    print(len(build))\n    print(*build)\n    print(len(connect))\n    if connect:\n        print(*connect, sep='\\n')\n\n__starting_point()", "def prim_matrix(matrix: list, inf=10**18):\n    n = len(matrix)\n    costs, unused = [inf]*n, [0]+[1]*(n-1)\n    current = 0\n    total_cost = 0\n\n    nearest = [-1]*n\n    build, connect = [], []\n\n    for _ in range(n-1):\n        min_cost = inf\n        dest = -1\n        src = -1\n\n        for i in range(n):\n            if unused[i]:\n                if matrix[current][i] < costs[i]:\n                    costs[i] = matrix[current][i]\n                    nearest[i] = current\n                if min_cost > costs[i]:\n                    min_cost = costs[i]\n                    dest = i\n                    src = nearest[i]\n\n        total_cost += min_cost\n        unused[dest] = 0\n\n        if src == 0:\n            build.append(dest)\n        else:\n            connect.append('%d %d' % (src, dest))\n        current = dest\n\n    print(total_cost)\n    print(len(build))\n    print(*build)\n    print(len(connect))\n    if connect:\n        print(*connect, sep='\\n')\n\n    return total_cost\n\n\ndef __starting_point():\n    import sys\n    n = int(input())\n    pos = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    c_costs = list(map(int, input().split()))\n    k_costs = list(map(int, input().split()))\n\n    inf = 10**18\n    matrix = [[inf]*(n+1) for _ in range(n+1)]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[i+1][j+1] = matrix[j+1][i+1] = \\\n                (abs(pos[i][0]-pos[j][0]) + abs(pos[i][1]-pos[j][1])) * (k_costs[i]+k_costs[j])\n\n        matrix[i+1][0] = matrix[0][i+1] = c_costs[i]\n\n    cost = prim_matrix(matrix)\n\n__starting_point()", "import sys\n\nreader = (list(map(int, s.split())) for s in sys.stdin)\n \nn, = next(reader)\nxy = []\nfor _ in range(n):\n    x, y = next(reader)\n    xy.append([x, y])\nc = list(next(reader))\nk = list(next(reader))\n\n\n# n = int(input())\n# xy = [[]]*n\n# for i in range(n):\n#     xy[i] = list(map(int,input().split()))\n\n# c = list(map(int,input().split()))\n# k = list(map(int,input().split()))\n\ngraph = [[0 for _ in range(n+1)] for _i in range(n+1)]\n\nfor i in range(n):\n    for j in range(i+1,n):\n        cost = (abs(xy[i][0]-xy[j][0])+abs(xy[i][1]-xy[j][1]))*(k[i]+k[j])\n        graph[i][j] = graph[j][i] = cost\n    graph[n][i] = graph[i][n] = c[i]\n\n# def output(parent):\n#     es = []\n#     vs = []\n#     cost = 0\n#     for i in range(1,(n+1)):\n#         if parent[i]==n:\n#             vs.append(i+1)\n#         elif i==n:\n#             vs.append(parent[i]+1)\n#         else:\n#             es.append([i+1,parent[i]+1])\n#         cost+= graph[i][parent[i]]\n#     print(cost)\n#     print(len(vs))\n#     print(*vs)\n#     print(len(es))\n#     for i in es:\n#         print(i[0],i[1])\n            \n\n# def minKey(key, mstSet): \n#     # Initilaize min value \n#     min = 1000000000000 \n\n#     for v in range((n+1)): \n#         if key[v] < min and mstSet[v] == False: \n#             min = key[v] \n#             min_index = v \n\n#     return min_index \n\ndef primMST():\n    # Key values used to pick minimum weight edge in cut \n    key = [1000000000000] * (n+1)\n    parent = [None] * (n+1) # Array to store constructed MST \n    # Make key 0 so that this vertex is picked as first vertex \n    key[0] = 0 \n    mstSet = [False] * (n+1) \n\n    parent[0] = -1 # First node is always the root of \n\n    for cout in range((n+1)): \n\n        # Pick the minimum distance vertex from  \n        # the set of vertices not yet processed.  \n        # u is always equal to src in first iteration \n        mn = 1000000000000 \n\n        for v in range((n+1)): \n            if key[v] < mn and mstSet[v] == False: \n                mn = key[v] \n                min_index = v \n\n        u = min_index \n\n        # Put the minimum distance vertex in  \n        # the shortest path tree \n        mstSet[u] = True\n\n        # Update dist value of the adjacent vertices  \n        # of the picked vertex only if the current  \n        # distance is greater than new distance and \n        # the vertex in not in the shotest path tree \n        for v in range((n+1)): \n            # graph[u][v] is non zero only for adjacent vertices of m \n            # mstSet[v] is false for vertices not yet included in MST \n            # Update the key only if graph[u][v] is smaller than key[v] \n            if graph[u][v] > 0 and mstSet[v] == False and key[v] > graph[u][v]: \n                    key[v] = graph[u][v] \n                    parent[v] = u\n        \n    # es = []\n    vss = 0\n    # vs = []\n    cost = 0\n    for i in range(1,(n+1)):\n        if parent[i]==n or i==n:\n            vss += 1\n        #     vs.append(i+1)\n        # elif i==n:\n        #     vs.append(parent[i]+1)\n        # else:\n        #     es.append([i+1,parent[i]+1])\n        cost+= graph[i][parent[i]]\n    \n    myprint = sys.stdout.write\n\n    myprint(str(cost) + '\\n')\n    # print(cost)\n    # print(vss)\n    myprint(str(vss)+'\\n')\n    \n\n    vs = [0]*(vss)\n    es = [[]]*(n-vss)\n    k1,k2 = 0,0\n\n    for i in range(1,(n+1)):\n        if parent[i]==n:\n            vs[k1] = i+1\n            k1+=1\n        elif i==n:\n            vs[k1] = parent[i]+1\n            k1+=1\n        else:\n            es[k2] = [i+1,parent[i]+1]\n            k2+=1\n        # cost+= graph[i][parent[i]]\n\n    # print(*vs)\n    [myprint(str(st) + ' ') for st in vs]\n    myprint('\\n')\n    myprint(str(len(es))+'\\n')\n    [myprint(str(i[0]) + ' ' + str(i[1]) + '\\n') for i in es]\n    # print(len(es))\n    # for i in es:\n    #     print(i[0],i[1])\n        \n    \n    \n    # myprint(str(totalCost) + '\\n')\n    # myprint(str(len(stations)) + '\\n')\n    # [myprint(str(st) + ' ') for st in stations];\n    # myprint(str(len(connections)) + '\\n')\n    # [myprint(str(c1) + ' ' + str(c2) + '\\n') for c1, c2 in connections];\n\n\nprimMST()\n\n# e = 0\n# i=0\n# ans = []\n# ret = 0\n# while e<n:\n#     edge = edges[i]\n#     i+=1\n#     cost,a,b = edge\n#     if find(a)!=find(b):\n#         e+=1\n#         ans.append([cost,a,b])\n#         union(a,b)\n#         ret += cost\n\n# vs = []\n# es = []\n# for i in ans:\n#     if i[1]==n:\n#         vs.append(i[2]+1)\n#     else:\n#         es.append(i)\n\n# print(ret)\n# print(len(vs))\n# print(*vs)\n# print(len(es))\n# for i in es:\n#     print(i[1]+1,i[2]+1)\n\n", "from collections import deque\nfrom math import inf\n\ndef run_testcase():\n\tn = int(input())\n\n\tcoords = [None] * (n + 1)\n\n\tfor i in range(1, n + 1):\n\t\tcoords[i] = [int(x) for x in input().split()]\n\n\tci = [0] + [int(x) for x in input().split()]\n\tki = [0] + [int(x) for x in input().split()]\n\n\n\tdef cost(i, j):\n\t\tif i == j:\n\t\t\treturn 0\n\n\t\tif i > j:\n\t\t\ti, j = j, i\n\n\t\tif i == 0:\n\t\t\treturn ci[j]\n\n\t\treturn (abs(coords[i][0] - coords[j][0]) + abs(coords[i][1] - coords[j][1])) * (ki[i] + ki[j])\n\n\n\tcurrent_cost = 0\n\ttree = set([0])\n\trest = set(range(1, n + 1))\n\tincluded = [True] + [False] * n\n\tconnections = deque()\n\tconnections_to_station = 0\n\n\t# min_attach_cost = [0] + [inf] * n\n\t# min_attach_cost = [0] + [cost(0, j) for j in range(1, n + 1)]\n\tmin_attach_cost = [(0, 0)] + [(cost(0, j), 0) for j in range(1, n + 1)]\n\n\n\twhile len(tree) < n + 1:\n\t\tmin_pair = (0, 0)\n\t\tmin_cost = inf\n\t\t# for tree_node in tree:\n\t\t# \tfor i in range(1, n + 1):\n\t\t# \t\tif included[i]:\n\t\t# \t\t\tcontinue\n\t\t# \t\tcurr_cost = cost(tree_node, i)\n\t\t# \t\tif curr_cost < min_cost:\n\t\t# \t\t\tmin_pair = (tree_node, i)\n\t\t# \t\t\tmin_cost = curr_cost\n\n\t\tfor node in rest:\n\t\t\tif min_attach_cost[node][0] < min_cost:\n\t\t\t\tmin_pair = (min_attach_cost[node][1], node)\n\t\t\t\tmin_cost = min_attach_cost[node][0]\n\n\n\n\t\ttree.add(min_pair[1])\n\t\tincluded[min_pair[1]] = True\n\t\tcurrent_cost += min_cost\n\n\t\trest.remove(min_pair[1])\n\t\tfor node in rest:\n\t\t\tif cost(min_pair[1], node) < min_attach_cost[node][0]:\n\t\t\t\tmin_attach_cost[node] = (cost(min_pair[1], node), min_pair[1])\n\n\t\tmin_pair = tuple(sorted(min_pair))\n\n\t\tif min_pair[0] == 0:\n\t\t\tconnections.appendleft(min_pair)\n\t\t\tconnections_to_station += 1\n\t\telse:\n\t\t\tconnections.append(min_pair)\n\n\tconnections_list = list(connections)\n\n\tprint(current_cost)\n\tprint(connections_to_station)\n\tprint(' '.join([str(x[1]) for x in connections_list[:connections_to_station]]))\n\n\tprint(len(connections_list) - connections_to_station)\n\tfor i in range(connections_to_station, len(connections_list)):\n\t\tprint(connections_list[i][0], connections_list[i][1])\n\n\n\n\n\n\n# testcase_count = int(input())\n\n# for i in range(testcase_count):\n# \tprint(str(run_testcase()))\n\nrun_testcase()\n", "N = int(input())  # \u5e02\u306e\u6570\nXY = [list(map(int, input().split())) for _ in range(N)]\nC = list(map(int, input().split()))  # \u5e02 i \u306b\u767a\u96fb\u6240\u3092\u5efa\u3066\u308b\u30b3\u30b9\u30c8\nK = list(map(int, input().split()))  # \u3064\u306a\u3052\u308b\u30b3\u30b9\u30c8\n \nCC = [-1] * N\nAns = [-2] * N\ntotal_cost = 0\nfor _ in range(N):\n    mi = float(\"inf\")\n    for i, (c, an) in enumerate(zip(C, Ans)):\n        if an == -2 and mi > c:\n            mi = c\n            ami = i\n    total_cost += mi\n    Ans[ami] = CC[ami]\n    k1 = K[ami]\n    x1, y1 = XY[ami]\n    for i, (k2, (x2, y2)) in enumerate(zip(K, XY)):\n        new_cost = (k1+k2) * (abs(x1-x2)+abs(y1-y2))\n        if C[i] > new_cost:\n            C[i] = new_cost\n            CC[i] = ami\nprint(total_cost)\ncnt = Ans.count(-1)\nprint(cnt)\nA = []\nB = []\nfor i, a in enumerate(Ans, 1):\n    if a==-1:\n        A.append(i)\n    else:\n        B.append((i, a+1))\nprint(\" \".join(map(str, A)))\nprint(N - cnt)\nfor a, b in B:\n    print(a, b)", "n=int(input())\npos=[[*map(int,input().split())] for i in range(n)]\n*c,=map(int, input().split())\n*k,=map(int, input().split())\nused = [False for i in range(n)]\nparent = [-1 for i in range(n)]\nplants = []\nconnections = []\nans = 0\n_n = n\nwhile(_n):\n    _n -= 1\n    mn, u = min([(ci, i) for i, ci in enumerate(c) if not used[i]])\n    ans += mn\n    used[u] = True\n    if parent[u] == -1:\n        plants.append(u)\n    else:\n        connections.append((min(parent[u], u), max(parent[u], u)))\n    for i in range(n):\n        con_cost = (k[u] + k[i])*(abs(pos[u][0]-pos[i][0])+abs(pos[u][1]-pos[i][1]))\n        if con_cost < c[i]:\n            c[i] = con_cost\n            parent[i] = u\nprint(ans)\nprint(len(plants))\nfor p in sorted(plants):\n    print(p+1, end=' ')\nprint('')\nprint(len(connections))\nfor con in connections:\n    print(con[0]+1, con[1]+1)\n", "n = int(input())\ncord = [[*map(int, input().split())]for _ in range(n)]\nc = [*map(int, input().split())]\nk = [*map(int, input().split())]\nplant = set()\ncovered = set()\nparent = [-1] * n\nsum = 0\nfor _ in range(n):\n    cost, idx = min([cost, idx] for idx, cost in enumerate(c) if idx not in covered)\n    sum += cost\n    covered.add(idx)\n    if parent[idx] == -1:\n        plant.add(idx)\n    for i in range(n):\n        if i in covered:\n            continue\n        c_l = (k[i]+k[idx])*(abs(cord[i][0]-cord[idx][0])+abs(cord[i][1]-cord[idx][1]))\n        if c_l <c[i]:\n            c[i] = c_l\n            parent[i] = idx\nprint('{}\\n{}'.format(sum, len(plant)))\nprint(*map(lambda x: x+1, plant))\nlinks = 0\nout = ''\nfor i, _ in enumerate(parent):\n    if _ != -1:\n        links += 1\n        out += '\\n' + str(_+1) + ' ' + str(i+1)\nprint(links, out)", "import bisect\nimport functools\nimport math\nimport sys\nfrom collections import defaultdict\n\n# input = sys.stdin.readline\nrt = lambda: map(int, input().split())\nri = lambda: int(input())\nrl = lambda: list(map(int, input().split()))\n\n\ndef dist(x1, y1, x2, y2):\n    return abs(x1-x2)+abs(y1-y2)\n\ndef main():\n    n = ri()\n    x, y = [0] * n, [0] * n\n    for i in range(n):\n        x[i], y[i] = rt()\n    c = rl()\n    k = rl()\n\n    val = c.copy()\n    used = [False] * n\n    link = [-1] * n\n    to_build = []\n    for _ in range(n):  # each step removes 1 city\n        # find min\n        min_index = -1\n        min_val = math.inf\n        for i in range(n):\n            if not used[i] and val[i] < min_val:\n                min_index = i\n                min_val = val[i]\n\n        used[min_index] = True\n        if link[min_index] == -1:\n            to_build.append(min_index+1)\n        for i in range(n):\n            if not used[i]:\n                to_link  = (k[i]+k[min_index])*dist(x[i], y[i], x[min_index], y[min_index])\n                if to_link < val[i]:\n                    val[i] = to_link\n                    link[i] = min_index\n\n    print(sum(val))\n    print(len(to_build))\n    print(*to_build)\n    print(len([x for x in link if x > -1]))\n    for i in range(n):\n        if link[i] > -1:\n            print(i+1, link[i]+1)\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\nX=[[0]*7 for _ in range(n)]\nfor i in range(n):\n  x,y=map(int,input().split())\n  X[i][0]=i+1\n  X[i][1]=x\n  X[i][2]=y\nC=[int(i) for i in input().split()]\nK=[int(i) for i in input().split()]\nfor i in range(n):\n  X[i][3]=C[i]\n  X[i][4]=K[i]\nX.sort(key=lambda x:x[3])\nans_am=0\nans_ps=0\nAns=[]\nans_con=0\nCon=[]\n\nwhile X:\n  ind,x,y,c,k,flag,source=X.pop(0)\n  ans_am+=c\n  if flag==0:\n    ans_ps+=1\n    Ans.append(ind)\n  else:\n    ans_con+=1\n    Con.append([ind,source])\n  for i in range(len(X)):\n    indi,xi,yi,ci,ki,flagi,sourcei=X[i]\n    if (k+ki)*(abs(x-xi)+abs(y-yi))<ci:\n      X[i][3]=(k+ki)*(abs(x-xi)+abs(y-yi))\n      X[i][5]=1\n      X[i][6]=ind\n  X.sort(key=lambda x:x[3])\n\nprint(ans_am)\nprint(ans_ps)\nprint(*Ans)\nprint(ans_con)\nfor i,j in Con:\n  print(i,j)", "n=int(input())\nX=[[0]*7 for _ in range(n)]\nfor i in range(n):\n  x,y=map(int,input().split())\n  X[i][0]=i+1\n  X[i][1]=x\n  X[i][2]=y\nC=[int(i) for i in input().split()]\nK=[int(i) for i in input().split()]\nfor i in range(n):\n  X[i][3]=C[i]\n  X[i][4]=K[i]\n\nans_am=0\nans_ps=0\nAns=[]\nans_con=0\nCon=[]\n\ndef m(X):\n  ret=0\n  cur=X[0][3]\n  for i in range(1,len(X)):\n    if X[i][3]<cur:\n      ret=i\n      cur=X[i][3]\n  return ret\n\n\nwhile X:\n  r=m(X)\n  ind,x,y,c,k,flag,source=X.pop(r)\n  ans_am+=c\n  if flag==0:\n    ans_ps+=1\n    Ans.append(ind)\n  else:\n    ans_con+=1\n    Con.append([ind,source])\n  for i in range(len(X)):\n    indi,xi,yi,ci,ki,flagi,sourcei=X[i]\n    if (k+ki)*(abs(x-xi)+abs(y-yi))<ci:\n      X[i][3]=(k+ki)*(abs(x-xi)+abs(y-yi))\n      X[i][5]=1\n      X[i][6]=ind\n\nprint(ans_am)\nprint(ans_ps)\nprint(*Ans)\nprint(ans_con)\nfor i,j in Con:\n  print(i,j)", "import sys\ninput=sys.stdin.readline\nn=int(input())\nX=[[0]*7 for _ in range(n)]\nfor i in range(n):\n  x,y=map(int,input().split())\n  X[i][0],X[i][1],X[i][2]=i+1,x,y\nC=[int(i) for i in input().split()]\nK=[int(i) for i in input().split()]\nfor i in range(n):\n  X[i][3],X[i][4]=C[i],K[i]\n\nans_am=0\nans_ps=0\nAns=[]\nans_con=0\nCon=[]\n\ndef m(X):\n  ret=0\n  cur=X[0][3]\n  for i in range(1,len(X)):\n    if X[i][3]<cur:\n      ret=i\n      cur=X[i][3]\n  return ret\n\n\nwhile X:\n  r=m(X)\n  ind,x,y,c,k,flag,source=X.pop(r)\n  ans_am+=c\n  if flag==0:\n    ans_ps+=1\n    Ans.append(ind)\n  else:\n    ans_con+=1\n    Con.append((ind,source))\n  for i in range(len(X)):\n    indi,xi,yi,ci,ki,flagi,sourcei=X[i]\n    cost=(k+ki)*(abs(x-xi)+abs(y-yi))\n    if cost<ci:\n      X[i][3],X[i][5],X[i][6]=cost,1,ind\n\nprint(ans_am)\nprint(ans_ps)\nprint(*Ans)\nprint(ans_con)\nfor i,j in Con:\n  print(i,j)", "import sys\ninput=sys.stdin.readline\nn=int(input())\nX=[[0]*7 for _ in range(n)]\nfor i in range(n):\n  x,y=map(int,input().split())\n  X[i][0],X[i][1],X[i][2]=i+1,x,y\nC=[int(i) for i in input().split()]\nK=[int(i) for i in input().split()]\nfor i in range(n):\n  X[i][3],X[i][4]=C[i],K[i]\n\nans_am=0\nans_ps=0\nAns=[]\nans_con=0\nCon=[]\n\ndef m(X):\n  ret=0\n  cur=X[0][3]\n  for i in range(1,len(X)):\n    if X[i][3]<cur:\n      ret=i\n      cur=X[i][3]\n  return ret\n\ndef cost(k,ki,x,xi,y,yi):\n  return (k+ki)*(abs(x-xi)+abs(y-yi))\n\nwhile X:\n  r=m(X)\n  ind,x,y,c,k,flag,source=X.pop(r)\n  ans_am+=c\n  if not flag:\n    ans_ps+=1\n    Ans.append(ind)\n  else:\n    ans_con+=1\n    Con.append((ind,source))\n  for i in range(len(X)):\n    indi,xi,yi,ci,ki,flagi,sourcei=X[i]\n    co=cost(k,ki,x,xi,y,yi)\n    if co<ci:\n      X[i][3],X[i][5],X[i][6]=co,1,ind\n\nprint(ans_am)\nprint(ans_ps)\nprint(*Ans)\nprint(ans_con)\nfor i,j in Con:\n  print(i,j)", "# copy from https://codeforces.com/contest/1245/submission/64023056\n\nN = int(input())  # \u5e02\u306e\u6570\nXY = [list(map(int, input().split())) for _ in range(N)]\nC = list(map(int, input().split()))  # \u5e02 i \u306b\u767a\u96fb\u6240\u3092\u5efa\u3066\u308b\u30b3\u30b9\u30c8\nK = list(map(int, input().split()))  # \u3064\u306a\u3052\u308b\u30b3\u30b9\u30c8\n\nCC = [-1] * N\nAns = [-2] * N\ntotal_cost = 0\nfor _ in range(N):\n    mi = float(\"inf\")\n    for i, (c, an) in enumerate(zip(C, Ans)):\n        if an == -2 and mi > c:\n            mi = c\n            ami = i\n    total_cost += mi\n    Ans[ami] = CC[ami]\n    k1 = K[ami]\n    x1, y1 = XY[ami]\n    for i, (k2, (x2, y2)) in enumerate(zip(K, XY)):\n        new_cost = (k1+k2) * (abs(x1-x2)+abs(y1-y2))\n        if C[i] > new_cost:\n            C[i] = new_cost\n            CC[i] = ami\nprint(total_cost)\ncnt = Ans.count(-1)\nprint(cnt)\nA = []\nB = []\nfor i, a in enumerate(Ans, 1):\n    if a==-1:\n        A.append(i)\n    else:\n        B.append((i, a+1))\nprint(\" \".join(map(str, A)))\nprint(N - cnt)\nfor a, b in B:\n    print(a, b)", "n=int(input())\nX=[[0]*7 for _ in range(n)]\nfor i in range(n):\n  x,y=map(int,input().split())\n  X[i][0]=i+1\n  X[i][1]=x\n  X[i][2]=y\nC=[int(i) for i in input().split()]\nK=[int(i) for i in input().split()]\nfor i in range(n):\n  X[i][3]=C[i]\n  X[i][4]=K[i]\nX.sort(key=lambda x:x[3])\nans_am=0\nans_ps=0\nAns=[]\nans_con=0\nCon=[]\n \nwhile X:\n  ind,x,y,c,k,flag,source=X.pop(0)\n  ans_am+=c\n  if flag==0:\n    ans_ps+=1\n    Ans.append(ind)\n  else:\n    ans_con+=1\n    Con.append([ind,source])\n  for i in range(len(X)):\n    indi,xi,yi,ci,ki,flagi,sourcei=X[i]\n    if (k+ki)*(abs(x-xi)+abs(y-yi))<ci:\n      X[i][3]=(k+ki)*(abs(x-xi)+abs(y-yi))\n      X[i][5]=1\n      X[i][6]=ind\n  X.sort(key=lambda x:x[3])\n \nprint(ans_am)\nprint(ans_ps)\nprint(*Ans)\nprint(ans_con)\nfor i,j in Con:\n  print(i,j)", "import math\n\nn = int(input())\ncityNo=[0]*n\nfor i in range(n):\n\tcityNo[i]=list(map(int,input().split()))\ncost=list(map(int,input().split()))\nks  =list(map(int,input().split()))\n\npowerStation=[0]*n\n\ntotalCost=0\n\nreq_Powerstation=[]\nnotReq_Powerstation=[]\ntotalCost=0\nestablished={}\nupdated=[-1]*n\n\nfor j in range(n):\n\n\tcity=-1\n\tmini=9999999999999999\n\tfor i in range(n):\n\t\tif mini>cost[i] and i not in established:\n\t\t\tcity=i\n\t\t\tmini=cost[i]\n\tif updated[city]==-1:\n\t\treq_Powerstation.append(city+1)\n\telse:\n\t\tnotReq_Powerstation.append([city+1,updated[city]+1])\t\n\ttotalCost+=cost[city]\n\testablished[city]=1\n\n\tfor i in range(n):\n\n\t\tcost_From_City = (ks[i]+ks[city])*(abs(cityNo[i][0]-cityNo[city][0])+abs(cityNo[i][1]-cityNo[city][1]))\n\t\t\n\t\tif cost_From_City<cost[i]:\n\t\t\tcost[i]=cost_From_City\n\t\t\tupdated[i]=city\n\n\t\t# print(updated)\nprint(totalCost)\nprint(len(req_Powerstation))\nprint(*req_Powerstation)\nprint(len(notReq_Powerstation))\nfor i in range(len(notReq_Powerstation)):\n\tprint(*notReq_Powerstation[i])", "from sys import stdin,stdout\nfrom collections import Counter\ndef ai(): return list(map(int, stdin.readline().split()))\ndef ei(): return map(int, stdin.readline().split())\ndef ip(): return  int(stdin.readline().strip())\ndef op(ans): return stdout.write(str(ans) + '\\n')\n\nn = ip()\npos = [ai() for i in range(n)]\nc = ai()\nk = ai()\n\nconnections = []\nplants = []\nused = [False]*n\nparent = [-1]*n\n\nans = 0 \nn_ = n\nwhile n_:\n\tn_ -= 1\n\tmn , u = min([(ci,i) for i,ci in enumerate(c) if not used[i]])\n\tans += mn\n\tused[u] = True\n\tif parent[u] == -1:\n\t\tplants.append(u)\n\telse:\n\t\tconnections.append((min(parent[u],u),max(parent[u],u)))\n\tfor i in range(n):\n\t\tcon_cost = (k[u]+k[i])*(abs(pos[u][0]-pos[i][0])+abs(pos[u][1]-pos[i][1]))\n\t\tif con_cost < c[i]:\n\t\t\tc[i] = con_cost\n\t\t\tparent[i] = u\nprint(ans)\nprint(len(plants))\nfor i in sorted(plants):\n\tprint(i+1,end=' ')\nprint()\nprint(len(connections))\nfor i in connections:\n\tprint(i[0]+1,i[1]+1)\n\n", "def dist(a,b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\nn = int(input())\np = []\nfor i in range(n):\n    p.append(list(map(int, input().split())))\nc = list(map(int, input().split()))\nk = list(map(int, input().split()))\nst = []\ned = []\nans = 0\nis_st = [1] * n\nparent = [-1] * n\nd = { i:  c[i] for i in range(n)}\nfor i in range(n):\n    m = min(d, key = d.get)\n    if(is_st[m]):\n        st.append(m)\n    else:\n        ed.append([m, parent[m]])\n    ans = ans + d[m]\n    del d[m]\n    for j in d.keys():\n        t_cost = (k[m] + k[j])*dist(p[m], p[j])\n        if(t_cost < d[j]):\n            d[j] = t_cost\n            parent[j] = m\n            is_st[j] = 0\nprint(ans)\nprint(len(st))\nfor i in st:\n    print(i+1,end = \" \")\nprint()\nprint(len(ed))\nfor i in ed:\n    print(i[0]+1,i[1]+1)\n", "import sys\n#import heapq as hq\n#from collections import deque\n#sys.stdin = open('in', 'r')\nreadline = sys.stdin.readline\nrdw = lambda: readline().rstrip()\nrdws = lambda: readline().split()\nrdwl = lambda: list(readline().split())\nrdi = lambda: int(readline())\nrdis = lambda: list(map(int, readline().split()))\nrdil = lambda: list(map(int, readline().split()))\nrdilrows = lambda cnt: [rdil() for _ in range(cnt)]\n\ndef solve():\n    res = 0\n    bld = []\n    wire = []\n    n = rdi()\n    cities = rdilrows(n)\n    c = rdil()\n    p = [-1 for i in range(n)]\n    k = rdil()\n    used = set()\n    used.add(-1)\n    \n    for i in range(n):\n        cost, bst = min([(c[i], i) for i in range(n) if i not in used])\n        par = p[bst]\n        used.add(bst)\n        res += cost\n        if par == -1:\n            bld.append(bst + 1)\n        else:\n            wire.append((bst + 1, par + 1))\n        for j in range(n):\n            if j not in used:\n                wcost = (k[bst]+k[j])*(abs(cities[bst][0]-cities[j][0]) \\\n                                    + abs(cities[bst][1]-cities[j][1]))\n                if wcost < c[j]:\n                    c[j] = wcost\n                    p[j] = bst\n    \n    sys.stdout.write(f'{res}\\n')\n    sys.stdout.write(f'{len(bld)}\\n')\n    sys.stdout.write(f'{\" \".join(map(str, bld))}\\n')\n    sys.stdout.write(f'{len(wire)}\\n')\n    for i in range(len(wire)):\n        sys.stdout.write(f'{wire[i][0]} {wire[i][1]}\\n')\n\n\ntests = 1\n#tests = rdi()\nfor testnum in range(tests):\n    solve()\n    \n#n = rdi()\n#n,m = rdis()\n#s = rdw()\n#a = rdil()\n#op, *s = rdws()\n\n#print(f'Case #{testnum+1}: {res}')\n#print(*res, sep='\\n')\n#sys.stdout.write('YES\\n')\n#sys.stdout.write(f'{res}\\n')\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\n')\n"]
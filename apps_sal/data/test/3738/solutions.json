["a, b = list(map(int, input().split()))\ns = input()\nsm = [[0, 0] for i in range(len(s))]\nrepl = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}\nfor i, c in enumerate(s):\n    sm[i][0] = sm[i - 1][0] + repl[c][0]\n    sm[i][1] = sm[i - 1][1] + repl[c][1]\n# a = n * sm[-1][0] + sm[i][0]\nfor i in range(len(s)):\n    na, nb = 0 if sm[-1][0] == 0 else (a - sm[i][0]) // sm[-1][0], 0 if sm[-1][1] == 0 else (b - sm[i][1]) // sm[-1][1]\n    if a == na * sm[-1][0] + sm[i][0] and b == nb * sm[-1][1] + sm[i][1] and (0 in sm[-1] or na == nb) and na >= -1 and nb >= -1:\n        print('Yes')\n        return\nprint('No')\n", "a,b=input().split()\n\na=int(a)\nb=int(b)\n\ns=input()\nn=len(s)\nL=[]\n\nx=0\ny=0\nhor=s.count('R')-s.count('L')\nver=s.count('U')-s.count('D')\nL=[[0,0]]\nfor i in range(n):\n    if(s[i]=='U'):\n        y+=1\n    elif(s[i]=='D'):\n        y-=1\n    elif(s[i]=='R'):\n        x+=1\n    else:\n        x-=1\n    L.append([x,y])\nk=True\nfor i in range(n+1):\n    x=L[i][0]\n    y=L[i][1]\n    if(hor==0 and ver==0 and x==a and b==y):\n        print('Yes')\n        k=False\n        break\n    elif(hor==0 and ver!=0 and x==a and (b-y)%ver==0 and (b-y)*ver>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver==0 and hor!=0 and y==b and (a-x)%hor==0 and (a-x)*hor>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver!=0 and hor!=0 and(b-y)%ver==0 and ver*(b-y)>=0 and (a-x)%hor==0 and hor*(a-x)>=0 and(b-y)//ver==(a-x)//hor):\n        print('Yes')\n        k=False\n        break\n\nif(k):\n    print('No')\n\n        \n", "def minus_two(x, y):\n    return [x[0] - y[0], x[1] - y[1]]\n\ndef will_reach(loc, commands):\n    new_loc = [0, 0]\n    possible_locs = [[0, 0]]\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        possible_locs += [list(new_loc)]\n\n        \n    all_destinations = [minus_two(loc, pl) for pl in possible_locs]\n\n\n    for destination in all_destinations :\n##        print(\"destination\", destination)\n##        print(\"slope\", new_loc)\n        realdx = destination[0]\n        realdy = destination[1]\n\n        reqdx = new_loc[0]\n        reqdy = new_loc[1]\n\n        if destination == [0, 0]:\n            return True\n\n        if reqdx != 0 and realdx != 0:\n            if ((realdy / realdx) == (reqdy / reqdx) \\\n            and (((realdy > 0 and reqdy > 0)) or((realdy < 0 and reqdy < 0)))     \\\n            and (realdy / reqdy) == int(realdy / reqdy)    \\\n            and (realdx / reqdx) == int(realdx / reqdx)): \n                return True\n        if  realdy == reqdy and realdx == reqdx:\n            return True\n        if reqdx == 0 and realdx == 0:\n            if ((reqdy > 0 and realdy > 0) or (reqdy < 0 and realdy < 0)) \\\n            and (realdy / reqdy) == int(realdy / reqdy):\n                return True\n        if reqdy == 0 and realdy == 0:\n\n            if ((reqdx > 0 and realdx > 0) or (reqdx < 0 and realdx < 0)) \\\n            and (realdx / reqdx) == int(realdx / reqdx):\n                return True\n    return False\n\n    \ndef will_reach2(loc, commands):\n    new_loc = [0, 0]\n    available_loc = []\n    for c in commands:\n        if c == \"U\":\n            new_loc[1] += 1\n        elif c == \"D\":\n            new_loc[1] -= 1\n        elif c == \"R\":\n            new_loc[0] += 1\n        elif c == \"L\":\n            new_loc[0] -= 1\n        available_loc += [new_loc]\n    \n\n    realdx = new_loc[0]\n    realdy = new_loc[1]\n\n    reqdx = loc[0]\n    reqdy = loc[1]\n\n    print(\"realdx\", realdx)\n    print(\"realdy\", realdy)\n    print(\"reqdx\", reqdx)\n    print(\"reqdy\", reqdy)\n    \n\n    if reqdx != 0 and realdx != 0:\n        return (realdy / realdx) == (reqdy / reqdx)\n    elif reqdx == 0 and realdx == 0:\n            return reqdy / realdy > 0\n    else:\n        return False    \n\n\ndef main():\n    first_line = input()\n    first_line = first_line.split()\n    \n    loc = [int(first_line[0]), int(first_line[1])]\n\n    cmds = input()\n   \n\n    if (will_reach(loc, cmds)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n        \n    \nmain()   \n\n", "a, b = map(int, input().split())\nif a == b == 0: print('Yes')\nelse:\n    ans = 'No'\n    t = input()\n    p, h = [0] * len(t), [0, 0]\n    d = {'L': (-1, 0), 'R': (1, 0), 'D': (-1, 1), 'U': (1, 1)}\n    for i, c in enumerate(t):\n        j, k = d[c]\n        h[k] += j\n        p[i] = (h[0], h[1])\n    if h[0] == h[1] == 0:\n        if (a, b) in p: ans = 'Yes'\n    elif h[0]:      \n        for x, y in p:\n            if (a - x) * h[1] == (b - y) * h[0] and (a - x) % h[0] == 0 and (a - x) * h[0] >= 0:\n                ans = 'Yes'\n                break\n    else:      \n        for x, y in p:\n            if a == x and (b - y) % h[1] == 0 and (b - y) * h[1] >= 0:\n                ans = 'Yes'\n                break\n    print(ans)", "#!/usr/bin/env python3\nimport operator\ntable = {\n        'U' : ( 0,  1),\n        'D' : ( 0, -1),\n        'L' : (-1,  0),\n        'R' : ( 1,  0) }\n\na, b = list(map(int,input().split()))\ns = list(input())\n\nzs = set()\nx, y = 0, 0\nzs.add((x, y))\nfor c in s:\n    x, y = list(map(operator.add, (x, y), table[c]))\n    zs.add((x, y))\n\nresult = False\nfor (zx, zy) in zs:\n    p, q = a - zx, b - zy\n    if (x == 0 and p != 0) or (x != 0 and p % x != 0) or (x != 0 and p // x < 0): continue\n    if (y == 0 and q != 0) or (y != 0 and q % y != 0) or (y != 0 and q // y < 0): continue\n    if x != 0 and y != 0 and p // x != q // y: continue\n    result = True\n\nprint('Yes' if result else 'No')\n", "dx = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\ndy = {'U': 1, 'D': -1, 'L': 0, 'R': 0}\nx, y, xl, yl = 0, 0, [], []\na, b = list(map(int, input().split()))\nfor ch in input():\n    xl.append(x)\n    yl.append(y)\n    x += dx[ch]\n    y += dy[ch]\nfor xi, yi in zip(xl, yl):\n    mx, my = a - xi, b - yi\n    if x == 0 and mx != 0 or x != 0 and (mx % x != 0 or mx // x < 0):\n        continue\n    if y == 0 and my != 0 or y != 0 and (my % y != 0 or my // y < 0):\n        continue\n    if x != 0 and y != 0 and mx // x != my // y:\n        continue\n    print('Yes')\n    return\nprint('No')\n", "X = {\"R\": 1, \"L\": -1, \"U\": 0, \"D\": 0}\nY = {\"R\": 0, \"L\": 0, \"U\": 1, \"D\": -1}\n\na, b = list(map(int, input().split()))\ns = input()\n\ndx, dy = 0, 0\n\nfor c in s:\n    dx += X[c]\n    dy += Y[c]\n\nret = False\n\n# if the robot doesnt move or endpoint is the start point\nif (a == 0 and b == 0):\n    ret = True\n\ncx, cy = 0, 0\n\nfor c in s:\n    cx += X[c]\n    cy += Y[c]\n    # dx could be 0\n    k = 0\n    if dx != 0 and (a - cx) % dx == 0:\n        k = (a - cx) // dx\n    if dy != 0 and (b - cy) % dy == 0:\n        k = (b - cy) // dy\n    if k >= 0 and k * dx + cx == a and k * dy + cy == b:\n        ret = True\nif ret:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "def main():\n    a, b = list(map(int, input().split()))\n    s, t = input(), -100\n    x = sum({\"L\": -1, \"R\": 1}.get(c, 0) for c in s)\n    y = sum({\"D\": -1, \"U\": 1}.get(c, 0) for c in s)\n    if x and y:\n        t += min(a // x, b // y)\n    elif x:\n        t += a // x\n    elif y:\n        t += b // y\n    if t > 0:\n        a -= t * x\n        b -= t * y\n    for c in s * 101:\n        if a == 0 == b:\n            print(\"Yes\")\n            return\n        a -= {\"L\": -1, \"R\": 1}.get(c, 0)\n        b -= {\"D\": -1, \"U\": 1}.get(c, 0)\n    print(\"No\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    a, b = list(map(int, input().split()))\n    steps, t = [((-1, 1, 0)[\"LR\".find(c)], (-1, 1, 0)[\"DU\".find(c)]) for c in input()], -25\n    x = sum(e[0] for e in steps)\n    y = sum(e[1] for e in steps)\n    if x and y:\n        t += min(a // x, b // y)\n    elif x:\n        t += a // x\n    elif y:\n        t += b // y\n    if t > 0:\n        a -= t * x\n        b -= t * y\n    for _ in range(26):\n        for dx, dy in steps:\n            if not (a or b):\n                print(\"Yes\")\n                return\n            a -= dx\n            b -= dy\n    print(\"No\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "3\nimport sys\n\nMAPPING = {\n    'U': (0, 1),\n    'D': (0, -1),\n    'L': (-1, 0),\n    'R': (1, 0),\n}\n\n\ndef read_ints():\n    return [int(x) for x in input().split()]\n\n\ndef get_vectors(moves):\n    vector = (0, 0)\n    yield vector\n    for move in moves:\n        delta = MAPPING[move]\n        vector = (vector[0] + delta[0], vector[1] + delta[1])\n        yield vector\n\n\ndef mul(pair, a):\n    return pair[0] * a, pair[1] * a\n\n\ndef is_achievable(diff, period):\n    if diff == (0, 0):\n        return True\n    if period == (0, 0):\n        return False\n    if period[0] != 0:\n        if diff[0] % period[0] == 0:\n            times = diff[0] // period[0]\n            if times > 0 and mul(period, times) == diff:\n                return True\n    if period[1] != 0:\n        if diff[1] % period[1] == 0:\n            times = diff[1] // period[1]\n            if times > 0 and mul(period, times) == diff:\n                return True\n    return False\n\n\ndef main():\n    a, b = read_ints()\n    moves = input().strip()\n    vectors = list(get_vectors(moves))\n    period = vectors[-1]\n    for vector in vectors:\n        diff = (a - vector[0], b - vector[1])\n        if is_achievable(diff, period):\n            print('Yes')\n            return\n    print('No')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#http://codeforces.com/problemset/problem/321/A\n\nimport logging as log\n\nclass Point(object):\n\t\n\tdef __init__(self, x,y):\n\t\tself.x, self.y = x, y\n\t\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\t\n\tdef __add__(self, other):\n\t\t#add 2 points together\n\t\treturn Point(self.x + other.x, self.y + other.y)\n\t\n\tdef __sub__(self, other):\n\t\t#substract 2 points from each other\n\t\treturn Point((other.x < self.x) & (self.x - other.x), (other.y < self.y) & (self.y - other.y))\n\t\n\tdef __truediv__(self, other):\n\t\t#devide 2 points, return an integer of how many times the other is bigger than the current point\n\t\tif other.x == 0:\n\t\t\treturn Point(0, self.y/other.y)\n\t\telif other.y == 0:\n\t\t\treturn Point(self.x/other.x, 0)\n\t\telse:\n\t\t\treturn Point(self.x/other.x, self.y/other.y)\n\t\n\tdef __mul__(self, other):\n\t\t#multiply 2 points\n\t\treturn Point(self.x * other, self.y*other)\n\t\n\t\n\tdef __eq__(self, other):\n\t\t#check if two points are equal\n\t\treturn self.x == other.x and self.y == other.y\n\n\nclass CMDSeq(object):\n\t\n\t#mapping between commnads and change in X-Y co-ordinates in Point co-ordinates\n\ttrans={\t\"U\":Point(0, 1),\n\t\t\t\"D\":Point(0, -1),\n\t\t\t\"R\":Point(1, 0),\n\t\t\t\"L\":Point(-1, 0)}\t\n\t\n\tdef __init__(self, seq):\n\t\tself.seq = seq\n\t\t\n\t\t#a dictionary that saves the movesin a command sequence\n\t\tself.seq_delta = {k:0 for k in 'LURD'}\n\t\tself.parse_cmdseq()\n\t\t\n\t\tself.hori_delta = self.seq_delta['R'] - self.seq_delta['L']\n\t\tself.vert_delta = self.seq_delta['U'] - self.seq_delta['D']\n\t\tself.delta = Point(self.hori_delta, self.vert_delta)\n\t\t\n\t\tself.max_hori_delta = max(self.seq_delta['R'], self.seq_delta['L'])\n\t\tself.max_vert_delta = max(self.seq_delta['U'], self.seq_delta['D'])\n\t\t\n\t\tself.loopback_factor = max( max(self.max_hori_delta - self.hori_delta, 0),\\\n\t\t max(self.max_vert_delta - self.vert_delta, 0))\n\t\t \n\t\tself.is_loop = self.hori_delta == self.vert_delta == 0\n\t\n\t\n\tdef parse_cmdseq(self):\n\t\t\"\"\"translates the cmd_seq to fill the seq_delta (counts how many moves in each direction)\n\t\t\"\"\"\n\t\tfor i in self.seq:\n\t\t\tself.seq_delta[i] += 1\n\n\t\n\tdef repeat_ratio(self, point):\n\t\treturn point/Point(self.hori_delta, self.vert_delta)\n\t\t\n\tdef __str__(self):\n\t\treturn \"%s\"%(self.seq)\n\t\n\n\ndef Robot():\n\t\n\tlog.basicConfig(format='%(levelname)s:%(message)s', level=log.CRITICAL)\n\t#log.basicConfig(format='%(levelname)s:%(message)s', level=log.DEBUG)\n\t\n\t#end point\n\tend = Point(*[*list(map(int, input().split()))])\n\tlog.debug('End point: %s.', end)\n\t\n\t#command sequence\n\tcmd = CMDSeq(input())\n\tlog.info('Command sequence: %s.', cmd.seq)\n\tlog.info('Command sequence delta: (%s, %s).', cmd.hori_delta, cmd.vert_delta)\n\tlog.debug('Command max hori delta: %s.', cmd.max_hori_delta)\n\tlog.debug('Command max vert delta: %s.', cmd.max_vert_delta)\n\tlog.debug('Command loopback ratio: %s.', cmd.loopback_factor)\n\t\n\t\"\"\"\t-If the end_point is at a totally different quarter, return No.\n\t\t-If the end_point is equal to origin, return Yes (we always start at origin no matter what the \n\tcommand sequence is!)\n\t\t-else If the command sequence is a closed loop, new_start is at origin (0,0)\n\t\t-else:\n\t\t\t- Calculate the minimum number of full sequence repetitions before to get the \n\t\t\t the closes to the end point. (end / cmd.delta).\n\t\t\t- If the result is an integer >>> return Yes (new_start = repetition*cmd_delta)\n\t\t\t- else:\n\t\t\t\tnew_start = cmd_delta*max(repetition - loopback, 0)\n\t\t- Start from new point then move through the sequence one step at a time and check if we \n\t\treached the end point, if not, return 'No'\n\t\"\"\"\n\tif end == Point(0, 0):\n\t\tlog.debug('!!! End point is (0,0) !!!')\n\t\treturn \"Yes\"\n\t\n\telif cmd.is_loop:\n\t\tlog.debug('Command sequence is a closed loop!')\n\t\tnew_start_a = Point(0, 0)\n\t\tnew_start_b = Point(0, 0)\n\t\n\telse:\n\t\t\n\t\trepeat = cmd.repeat_ratio(end)\n\t\tlog.debug('Repeat point: %s', repeat)\n\t\tif repeat.x == 0:\n\t\t\trepeat = repeat.y\n\t\telif repeat.y ==0:\n\t\t\trepeat = repeat.x\n\t\telse:\n\t\t\trepeat = min(repeat.x, repeat.y)\n\t\t\n\t\tlog.debug('Repeat: %s', repeat)\n\t\t\n\t\tnew_start_a = cmd.delta*max(int(repeat) - cmd.loopback_factor - 1, 0)\n\t\tnew_start_b = cmd.delta*max(int(repeat) - cmd.loopback_factor, 0)\n\t\n\tlog.info('New start A: %s', new_start_a)\n\tlog.info('New start B: %s', new_start_b)\n\t\n\tlog.debug('------\\nWalking the robot:')\n\t#add the sequence to the new_start point, return YES if we hit the end point\n\tfor rep in range(cmd.loopback_factor + 1):\n\t\tfor i in cmd.seq:\n\t\t\tlog.debug('Current command: %s', i)\n\t\t\tif new_start_a == end or new_start_b == end:\n\t\t\t\treturn \"Yes\"\n\t\t\tnew_start_a += CMDSeq.trans[i]\n\t\t\tnew_start_b += CMDSeq.trans[i]\n\t\t\tlog.debug('Modified start A: %s.', new_start_a)\n\t\t\tlog.debug('Modified start B: %s.', new_start_b)\n\t\n\treturn \"Yes\" if (new_start_a == end) or (new_start_b == end) else \"No\"\n\t\n\ndef __starting_point():\n\ta = Robot()\n\tprint(a)\n\n\n__starting_point()", "dx = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\ndy = {'U': 1, 'D': -1, 'L': 0, 'R': 0}\nx, y, xl, yl = 0, 0, [], []\na, b = list(map(int, input().split()))\nfor ch in input():\n    xl.append(x)\n    yl.append(y)\n    x += dx[ch]\n    y += dy[ch]\nfor xi, yi in zip(xl, yl):\n    mx, my = a - xi, b - yi\n    if x == 0 and mx != 0 or x != 0 and (mx % x != 0 or mx // x < 0):\n        continue\n    if y == 0 and my != 0 or y != 0 and (my % y != 0 or my // y < 0):\n        continue\n    if x != 0 and y != 0 and mx // x != my // y:\n        continue\n    print('Yes')\n    return\nprint('No')\n", "R = lambda: map(int, input().split())\na, b = R()\ncs = [[0, 0]]\nd = {'R': (1, 0), 'L': (-1, 0), 'U': (0, 1), 'D': (0, -1)}\nfor c in input():\n    cs.append([cs[-1][0] + d[c][0], cs[-1][1] + d[c][1]])\npx, py = cs[-1][0], cs[-1][1]\nfor x, y in cs:\n    k = 0\n    if px:\n        k = (a - x) // px\n    elif py:\n        k = (b - y) // py\n    if k >= 0 and x + k * px == a and y + k * py == b:\n        print('Yes')\n        return\nprint('No')", "class CodeforcesTask321ASolution:\n    def __init__(self):\n        self.result = ''\n        self.a_b = []\n        self.command = ''\n\n    def read_input(self):\n        self.a_b = [int(x) for x in input().split(\" \")]\n        self.command = input()\n\n    def process_task(self):\n        vector = [0, 0]\n        for c in self.command:\n            if c == \"U\":\n                vector[1] += 1\n            elif c == \"D\":\n                vector[1] -= 1\n            elif c == \"R\":\n                vector[0] += 1\n            elif c == \"L\":\n                vector[0] -= 1\n        if vector[0] and vector[1]:\n            turns_away = min(self.a_b[0] // vector[0], self.a_b[1] // vector[1])\n        elif vector[0]:\n            turns_away = self.a_b[0] // vector[0]\n        elif vector[1]:\n            turns_away = self.a_b[1] // vector[1]\n        else:\n            turns_away = 0\n        turns_away = max(turns_away - 50, 0)\n        x = vector[0] * turns_away\n        y = vector[1] * turns_away\n        can = False\n        #print(vector, turns_away, x, y)\n        if x == self.a_b[0] and y == self.a_b[1]:\n            can = True\n        for z in range(100):\n            for c in self.command:\n                if c == \"U\":\n                    y += 1\n                elif c == \"D\":\n                    y -= 1\n                elif c == \"R\":\n                    x += 1\n                elif c == \"L\":\n                    x -= 1\n                if x == self.a_b[0] and y == self.a_b[1]:\n                    can = True\n        self.result = \"Yes\" if can else \"No\"\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask321ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()", "def R(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef S(): return str(input())\n\ndef L(): return list(R())\n\nfrom collections import Counter \n\nimport math\nimport sys\n\nfrom itertools import permutations\n\nimport bisect\n\na,b=R()\n\ns=S()\nl=len(s)\nstep=[]\n\nx,y=0,0\n\nd={'U':(0,1), 'D':(0,-1), 'L':(-1,0), 'R':(1,0)}\n\nstep.append((0,0))\n\nfor i in range(l):\n    dx,dy=d[s[i]]\n    x+=dx\n    y+=dy\n\n    step.append((x,y))\n\ntx,ty=step[l]\n\nfor j in range(l):\n    xj,yj=step[j]\n\n    if tx==0 and ty==0:\n        if a==xj and b==yj:\n            print('Yes')\n            return\n\n        else:\n            continue\n\n    if tx==0 and (a!=xj or (b-yj)%ty!=0 or ((b-yj)%ty==0 and (b-yj)/ty<0)):\n        continue\n\n    if ty==0 and (b!=yj or (a-xj)%tx!=0 or ((a-xj)%tx==0 and (a-xj)/tx<0)):\n        continue\n\n    if tx==0 or ty==0:\n        print('Yes')\n        return\n\n    if (a-xj)%tx==0 and (b-yj)%ty==0 and (a-xj)/tx==(b-yj)/ty>=0:\n        print('Yes')\n        return\n\n\nprint('No')\n\n\n\n\n\n\n\n\n\n", "a, b =  list(map(int, input().split()))\ns = input()\np = [[0, 0]]\nd = {'R': (1, 0), 'L': (-1, 0), 'U': (0, 1), 'D': (0, -1)}\nfor c in s:\n    p.append([p[-1][0] + d[c][0], p[-1][1] + d[c][1]])\npx, py = p[-1][0], p[-1][1]\nfor x, y in p:\n    k = 0\n    if px:\n        k = (a - x) // px\n    elif py:\n        k = (b - y) // py\n    if k >= 0 and x + k * px == a and y + k * py == b:\n        print('Yes')\n        break\nelse:\n    print('No')\n", "a,b = map(int,input().split())\ns = list(input())\ndist = a*a + b*b\nlis=[[0,0]]\nver=hor=0\nfor i in s:\n    if i=='U':\n        ver+=1\n    elif i=='D':\n        ver-=1\n    elif i=='R':\n        hor+=1\n    else:\n        hor-=1\n    lis.append([hor,ver])\nflag=1\n\nif [a,b] in lis:\n    print(\"Yes\")\n    return\nfor i in lis:\n    if [a,b]==[i[0]+lis[-1][0] , i[1]+lis[-1][0]]:\n        print(\"Yes\")\n        return  \nfor i in range(len(lis)):\n    l=0\n    r=100000000000\n    c,d = lis[i]\n    while l<=r:\n        mid = l +(r-l)//2\n        e = mid*(lis[-1][0])\n        f = mid*(lis[-1][1])\n        if (e+c)**2 + (f+d)**2 < dist:\n            l = mid+1\n        else:\n            r = mid-1\n    if  [l*(lis[-1][0])+c , l*(lis[-1][1])+d]==[a,b]:\n        print(\"Yes\")\n        flag=0\n        break\n    elif [r*(lis[-1][0])+c , r*(lis[-1][1])+d]==[a,b]:\n        print(\"Yes\")\n        flag=0\n        break\nif flag:\n    print(\"No\")", "import sys\nox,oy = map(int,sys.stdin.readline().split())  # original position\ns= sys.stdin.readline()\nh = 0\nv = 0\n# here we calculate the distance to target position after one simulation\nfor i in range (len(s)):\n    if s[i] == 'R':\n        h+=1\n    if s[i] == 'L':\n        h-= 1\n    if s[i] == 'U':\n        v+=1\n    if s[i] == 'D':\n        v -=1\n\ndef bs (l,r,a,b,rx,ry):\n    l1 = l\n    r1 = r\n    a1 = a\n    b1 = b\n  #  print(\"ox:\",a,\" oy:\",b)\n    while (l1 <= r1):\n        mid = (l1+r1)//2\n        a1 =a+h*mid\n        b1 =b+v*mid\n        # print (\"   a1:\",a1,\" b1:\",b1)\n        # print (\"   l1:\",l1,\" r1:\",r1)\n        # print (\"   mid:\",mid)\n        if (rx == a1 and ry == b1):\n            return 0\n        if (rx - a1) * h == 0:\n            if (ry - b1)* v >0:\n                l1 = mid +1\n            elif (ry - b1)* v < 0:\n                 r1 = mid -1\n            else:\n                return -1\n\n        if (ry - b1)* v == 0 :\n            if (rx - a1) * h >0:\n                l1 = mid +1\n            elif (rx - a1) * h <0 :\n                r1 = mid -1\n            else :\n                return -1\n\n        if (rx - a1)*h != 0 and (ry - b1)* v !=0:\n            if (rx - a1)*h > 0 and (ry - b1)* v >0 :\n                l1 = mid+1\n            elif (rx - a1)*h <0 and (ry - b1)* v <0 :\n                r1 = mid-1\n            else :\n                return -1\n    return -1\n\na=0\nb=0\npos  = bs (0,10**9,a,b,ox,oy)\nkt = False\nif pos == 0:\n    print(\"Yes\")\n    kt = True\nif kt == False :\n    for i  in range (len(s)):\n        if s[i] == 'R':\n            a +=1\n        if s[i] == 'L':\n            a -= 1\n        if s[i] == 'U':\n            b +=1\n        if s[i] == 'D':\n            b -=1\n        pos= bs (0,10**9,a,b,ox,oy)\n        if pos == 0 :\n            print (\"Yes\")\n            kt = True\n            break\nif kt == False :\n    print (\"No\")"]
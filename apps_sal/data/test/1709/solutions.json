["INF = 10 ** 18\nMX_SZ = 112\ndp = [[[INF for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\nbest = [[[(INF, INF) for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\n\ndef read():\n    return [int(x) for x in input().split()]\n\nn, m, k_res = read()\narr = read()\ncost = []\nfor i in range (n):\n    cost.append(read())\ndp[0][0][MX_SZ - 1] = 0 #[trees painted][group amount][last color]\nbest[0][0][0] = (0, MX_SZ - 1)\n#print(best[0][0][0][1])\n#return\nfor i in range (1, n + 1):\n    clr = arr[i - 1]\n    if clr == 0:\n        for j in range (1, k_res + 1):\n            for k in range (1, m + 1):\n                dp[i][j][k] = dp[i - 1][j][k] + cost[i - 1][k - 1]\n                if k == best[i - 1][j - 1][0][1]:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][1][0] + cost[i - 1][k - 1])\n                else:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][0][0] + cost[i - 1][k - 1])\n                if dp[i][j][k] < best[i][j][0][0]:\n                    best[i][j][1] = best[i][j][0]\n                    best[i][j][0] = (dp[i][j][k], k)\n                elif dp[i][j][k] < best[i][j][1][0]:\n                    best[i][j][1] = (dp[i][j][k], k)\n    else:\n        for j in range (1, n + 1):\n            dp[i][j][clr] = dp[i - 1][j][clr]\n            if clr == best[i - 1][j - 1][0][1]:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][1][0])\n            else:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][0][0])\n            best[i][j][0] = (dp[i][j][clr], clr)\nans = INF\nfor k in range (1, m + 1):\n    if dp[n][k_res][k] < ans:\n        ans = dp[n][k_res][k]\nif ans == INF:\n    ans = -1\nprint(ans)\n\n\n\n", "def main():\n    n, m, k = list(map(int, input().split()))\n    c, *cc = (list(map(int, input().split())))\n    pp, *ppp = (list(map(int, input().split())) for _ in range(n))\n    inf = 2 ** 47\n    inf2 = inf * 2\n    nxt = [[0 if i == c - 1 else inf for i in range(m)] if c else pp]\n    for c, pp in zip(cc, ppp):\n        newrow = [inf] * m\n        cur, nxt = nxt, [newrow]\n        if c:\n            c -= 1\n            for row in cur:\n                p = row[c]\n                if newrow[c] > p:\n                    newrow[c] = p\n                if len(nxt) == k:\n                    break\n                row[c] = inf2\n                newrow = [inf] * m\n                newrow[c] = min(row)\n                nxt.append(newrow)\n        else:\n            for row in cur:\n                for c, p in enumerate(a + b for a, b in zip(row, pp)):\n                    if newrow[c] > p:\n                        newrow[c] = p\n                if len(nxt) == k:\n                    break\n                bestclr = min(list(range(m)), key=row.__getitem__)\n                x, row[bestclr] = row[bestclr], inf2\n                newrow = [a + x for a in pp]\n                newrow[bestclr] = min(row) + pp[bestclr]\n                nxt.append(newrow)\n\n    p = min(nxt[-1])\n    print(p if p < inf else -1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m, k = list(map(int, input().split()))\n    c, *cc = (list(map(int, input().split())))\n    pp, *ppp = (list(map(float, input().split())) for _ in range(n))\n    inf = 2. ** 47\n    nxt = [[0. if i == c - 1 else inf for i in range(m)] if c else pp]\n    for c, pp in zip(cc, ppp):\n        newrow = [inf] * m\n        cur, nxt = nxt, [newrow]\n        if c:\n            c -= 1\n            for row in cur:\n                p = row[c]\n                if newrow[c] > p:\n                    newrow[c] = p\n                if len(nxt) == k:\n                    break\n                row[c] = inf\n                newrow = [inf] * m\n                newrow[c] = min(row)\n                nxt.append(newrow)\n        else:\n            for row in cur:\n                for c, p in enumerate(a + b for a, b in zip(row, pp)):\n                    if newrow[c] > p:\n                        newrow[c] = p\n                if len(nxt) == k:\n                    break\n                bestclr = min(list(range(m)), key=row.__getitem__)\n                x, row[bestclr] = row[bestclr], inf\n                newrow = [a + x for a in pp]\n                newrow[bestclr] = min(row) + pp[bestclr]\n                nxt.append(newrow)\n\n    p = min(nxt[-1])\n    print(int(p) if p < inf else -1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m, k = list(map(int, input().split()))\n    c, *cc = (list(map(int, input().split())))\n    pp, *ppp = (list(map(int, input().split())) for _ in range(n))\n    inf = 2 ** 47\n    inf2 = inf * 2\n    nxt = [[0 if i == c - 1 else inf for i in range(m)] if c else pp]\n    for c, pp in zip(cc, ppp):\n        newrow = [inf] * m\n        cur, nxt = nxt, [newrow]\n        if c:\n            c -= 1\n            for row in cur:\n                p = row[c]\n                if newrow[c] > p:\n                    newrow[c] = p\n                if len(nxt) == k:\n                    break\n                row[c] = inf2\n                newrow = [inf] * m\n                newrow[c] = min(row)\n                nxt.append(newrow)\n        else:\n            for row in cur:\n                for c, p in enumerate(a + b for a, b in zip(row, pp)):\n                    if newrow[c] > p:\n                        newrow[c] = p\n                if len(nxt) == k:\n                    break\n                bestclr = min(list(range(m)), key=row.__getitem__)\n                x, row[bestclr] = row[bestclr], inf2\n                newrow = [a + x for a in pp]\n                newrow[bestclr] = min(row) + pp[bestclr]\n                nxt.append(newrow)\n\n    p = min(nxt[-1])\n    print(p if p < inf else -1)\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "MAX=10**18+5\nn,m,k=list(map(int,input().split()))\na=list(map(int,input().split()))\ncost=[list(map(int,input().split())) for _ in range(n)]\nmin1=[[MAX]*(k+1) for _ in range(n)]\nmin2=[[MAX]*(k+1) for _ in range(n)]\nidx=[[-1]*(k+1) for _ in range(n)]\nfor i in cost:\n    i.insert(0,0)\ndp=[ [ [ MAX ]*(m+1) for _ in range(k+1)] for _ in range(n)]\n\nif a[0]==0:\n    for i in range(1,m+1):\n        if min1[0][1]>=cost[0][i]:\n            if min1[0][1]==cost[0][i]:\n                idx[0][1]=-2\n                \n            else:\n                idx[0][1]=i\n            min2[0][1]=min1[0][1]\n            min1[0][1]=cost[0][i]\n            \n        elif min2[0][1]>=cost[0][i]:\n            min2[0][1]=cost[0][i]\n\n        dp[0][1][i]=cost[0][i]\nelse:\n    dp[0][1][a[0]]=0\n    min1[0][1]=0;idx[0][1]=a[0]\n\n##print(min1)\n##print(min2)\nfor i in range(1,n):\n    for j in range(1,k+1):\n        if a[i]==0:\n            for l in range(1,m+1):\n                dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l]+cost[i][l])\n                if l==idx[i-1][j-1]:\n                    dp[i][j][l]=min(min2[i-1][j-1]+cost[i][l],dp[i][j][l])\n                else:\n                    dp[i][j][l]=min(min1[i-1][j-1]+cost[i][l],dp[i][j][l])\n               \n                \n\n        else:\n            for l in range(1,m+1):\n                dp[i][j][a[i]]=min(dp[i][j][a[i]],dp[i-1][j][a[i]])\n                if l!=a[i]:\n                    dp[i][j][a[i]]=min(dp[i-1][j-1][l],dp[i][j][a[i]])\n                    \n        for l in range(1,m+1):\n            if min1[i][j]>=dp[i][j][l]:\n                if min1[i][j]==dp[i][j][l]:\n                    idx[i][j]=-2\n                \n                else:\n                    idx[i][j]=l\n                min2[i][j]=min1[i][j]\n                min1[i][j]=dp[i][j][l]\n            \n            elif min2[i][j]>=dp[i][j][l]:\n                min2[i][j]=dp[i][j][l]\nans=MAX\nfor i in dp[-1][-1]:\n    ans=min(ans,i)\nprint(ans if ans <MAX else -1)\n", "MAX=10**18+5\nn,m,k=list(map(int,input().split()))\na=list(map(int,input().split()))\ncost=[list(map(int,input().split())) for _ in range(n)]\nmin1=[[MAX]*(k+1) for _ in range(n)]\nmin2=[[MAX]*(k+1) for _ in range(n)]\nidx=[[-1]*(k+1) for _ in range(n)]\nfor i in cost:\n    i.insert(0,0)\ndp=[ [ [ MAX ]*(m+1) for _ in range(k+1)] for _ in range(n)]\n\nif a[0]==0:\n    for i in range(1,m+1):\n        if min1[0][1]>=cost[0][i]:\n            if min1[0][1]==cost[0][i]:\n                idx[0][1]=-1\n                \n            else:\n                idx[0][1]=i\n            min2[0][1]=min1[0][1]\n            min1[0][1]=cost[0][i]\n            \n        elif min2[0][1]>=cost[0][i]:\n            min2[0][1]=cost[0][i]\n\n        dp[0][1][i]=cost[0][i]\nelse:\n    dp[0][1][a[0]]=0\n    min1[0][1]=0;idx[0][1]=a[0]\n\n##print(min1)\n##print(min2)\nfor i in range(1,n):\n    for j in range(1,k+1):\n        if a[i]==0:\n            for l in range(1,m+1):\n                dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l]+cost[i][l])\n                if l==idx[i-1][j-1]:\n                    dp[i][j][l]=min(min2[i-1][j-1]+cost[i][l],dp[i][j][l])\n                else:\n                    dp[i][j][l]=min(min1[i-1][j-1]+cost[i][l],dp[i][j][l])\n               \n                \n\n        else:\n            for l in range(1,m+1):\n                dp[i][j][a[i]]=min(dp[i][j][a[i]],dp[i-1][j][a[i]])\n                if l!=a[i]:\n                    dp[i][j][a[i]]=min(dp[i-1][j-1][l],dp[i][j][a[i]])\n                    \n        for l in range(1,m+1):\n            if min1[i][j]>=dp[i][j][l]:\n                if min1[i][j]==dp[i][j][l]:\n                    idx[i][j]=-1\n                \n                else:\n                    idx[i][j]=l\n                min2[i][j]=min1[i][j]\n                min1[i][j]=dp[i][j][l]\n            \n            elif min2[i][j]>=dp[i][j][l]:\n                min2[i][j]=dp[i][j][l]\nans=MAX\nfor i in dp[-1][-1]:\n    ans=min(ans,i)\nprint(ans if ans <MAX else -1)\n", "n, m, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\npaint = [list(map(int, input().split())) for i in range(n)]\n\nif ((0 not in arr) and (len(set(arr)) > k)) or (len(set(arr)) - 1 > k):\n\tprint(-1)\n\treturn\n\n#DP(index, color of index, current beauty)\ndp = [0 for n_idx in range(n)]\nfor n_idx in range(n):\n\tdp[n_idx] = [0 for m_idx in range(m)]\n\tfor m_idx in range(m):\n\t\tdp[n_idx][m_idx] = [float('inf') for k_idx in range(k + 1)]\n\n#Initialize first list of DP\nc0 = arr[0]\nif c0 != 0: #first tree is already colored\n\tdp[0][c0 - 1][1] = 0\nelse:\n\tfor color in range(m):\n\t\tdp[0][color][1] = paint[0][color]\n\n\nfor idx in range(1, n):\n\tmin_last_idx = {}\n\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t#get min + 2nd min of all beauty - 1\n\t\tmin_cost = float('inf')\n\t\tmin_cost_color = -1\n\t\tsec_min_cost = float('inf')\n\t\tsec_min_cost_color = -1\n\n\t\tfor color in range(m):\n\t\t\tnext_cost = dp[idx - 1][color][beauty - 1]\n\t\t\tif next_cost < min_cost:\n\t\t\t\tsec_min_cost = min_cost\n\t\t\t\tsec_min_cost_color = min_cost_color\n\t\t\t\tmin_cost = next_cost\n\t\t\t\tmin_cost_color = color\n\t\t\telif next_cost < sec_min_cost:\n\t\t\t\tsec_min_cost = next_cost\n\t\t\t\tsec_min_cost_color = color\n\t\tmin_last_idx[beauty] = [[min_cost, min_cost_color], [sec_min_cost, sec_min_cost_color]]\n\n\n\tcurr_color = arr[idx]\n\tif curr_color != 0: #current tree already colored\n\t\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t\tcost_prev_same_color = dp[idx - 1][curr_color - 1][beauty]\n\t\t\tmin_cost, min_cost_color = min_last_idx[beauty][0]\n\t\t\tif min_cost_color == curr_color - 1:\n\t\t\t\tmin_cost = min_last_idx[beauty][1][0]\n\t\t\tdp[idx][curr_color - 1][beauty] = min(cost_prev_same_color, min_cost)\n\n\telse:\n\t\tfor curr_color in range(m):\n\t\t\tcost_to_color = paint[idx][curr_color]\n\t\t\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t\t\tcost_prev_same_color = dp[idx - 1][curr_color][beauty]\n\t\t\t\tmin_cost, min_cost_color = min_last_idx[beauty][0]\n\t\t\t\tif min_cost_color == curr_color:\n\t\t\t\t\tmin_cost = min_last_idx[beauty][1][0]\n\t\t\t\tdp[idx][curr_color][beauty] = cost_to_color + min(cost_prev_same_color, min_cost)\n\nmin_paint = min([l[k] for l in dp[n - 1]])\nif min_paint != float('inf'):\n\tprint(min_paint)\nelse:\n\tprint(-1)\n\n\n", "n, m, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\npaint = [list(map(int, input().split())) for i in range(n)]\n\nif ((0 not in arr) and (len(set(arr)) > k)) or (len(set(arr)) - 1 > k):\n\tprint(-1)\n\treturn\n\n#DP(index, color of index, current beauty)\ndp = [0 for n_idx in range(n)]\nfor n_idx in range(n):\n\tdp[n_idx] = [0 for m_idx in range(m)]\n\tfor m_idx in range(m):\n\t\tdp[n_idx][m_idx] = [float('inf') for k_idx in range(k + 1)]\n\n#Initialize first list of DP\nc0 = arr[0]\nif c0 != 0: #first tree is already colored\n\tdp[0][c0 - 1][1] = 0\nelse:\n\tfor color in range(m):\n\t\tdp[0][color][1] = paint[0][color]\n\n\nfor idx in range(1, n):\n\tmin_last_idx = {}\n\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t#get min + 2nd min of all beauty - 1\n\t\tmin_cost = float('inf')\n\t\tmin_cost_color = -1\n\t\tsec_min_cost = float('inf')\n\t\tsec_min_cost_color = -1\n\n\t\tfor color in range(m):\n\t\t\tnext_cost = dp[idx - 1][color][beauty - 1]\n\t\t\tif next_cost < min_cost:\n\t\t\t\tsec_min_cost = min_cost\n\t\t\t\tsec_min_cost_color = min_cost_color\n\t\t\t\tmin_cost = next_cost\n\t\t\t\tmin_cost_color = color\n\t\t\telif next_cost < sec_min_cost:\n\t\t\t\tsec_min_cost = next_cost\n\t\t\t\tsec_min_cost_color = color\n\t\tmin_last_idx[beauty] = [[min_cost, min_cost_color], [sec_min_cost, sec_min_cost_color]]\n\n\n\tcurr_color = arr[idx]\n\tif curr_color != 0: #current tree already colored\n\t\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t\tcost_prev_same_color = dp[idx - 1][curr_color - 1][beauty]\n\t\t\tmin_cost, min_cost_color = min_last_idx[beauty][0]\n\t\t\tif min_cost_color == curr_color - 1:\n\t\t\t\tmin_cost = min_last_idx[beauty][1][0]\n\t\t\tdp[idx][curr_color - 1][beauty] = min(cost_prev_same_color, min_cost)\n\n\telse:\n\t\tfor curr_color in range(m):\n\t\t\tcost_to_color = paint[idx][curr_color]\n\t\t\tfor beauty in range(max(1, k - (n - idx) + 1), min(k + 1, idx + 2)):\n\t\t\t\tcost_prev_same_color = dp[idx - 1][curr_color][beauty]\n\t\t\t\tmin_cost, min_cost_color = min_last_idx[beauty][0]\n\t\t\t\tif min_cost_color == curr_color:\n\t\t\t\t\tmin_cost = min_last_idx[beauty][1][0]\n\t\t\t\tdp[idx][curr_color][beauty] = cost_to_color + min(cost_prev_same_color, min_cost)\n\nmin_paint = min([l[k] for l in dp[n - 1]])\nif min_paint != float('inf'):\n\tprint(min_paint)\nelse:\n\tprint(-1)\n\n\n", "INF = 10 ** 18\nMX_SZ = 112\ndp = [[[INF for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\nbest = [[[(INF, INF) for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\n\ndef read():\n    return [int(x) for x in input().split()]\n\nn, m, k_res = read()\narr = read()\ncost = []\nfor i in range (n):\n    cost.append(read())\ndp[0][0][MX_SZ - 1] = 0 #[trees painted][group amount][last color]\nbest[0][0][0] = (0, MX_SZ - 1)\n#print(best[0][0][0][1])\n#return\nfor i in range (1, n + 1):\n    clr = arr[i - 1]\n    if clr == 0:\n        for j in range (1, k_res + 1):\n            for k in range (1, m + 1):\n                dp[i][j][k] = dp[i - 1][j][k] + cost[i - 1][k - 1]\n                if k == best[i - 1][j - 1][0][1]:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][1][0] + cost[i - 1][k - 1])\n                else:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][0][0] + cost[i - 1][k - 1])\n                if dp[i][j][k] < best[i][j][0][0]:\n                    best[i][j][1] = best[i][j][0]\n                    best[i][j][0] = (dp[i][j][k], k)\n                elif dp[i][j][k] < best[i][j][1][0]:\n                    best[i][j][1] = (dp[i][j][k], k)\n    else:\n        for j in range (1, n + 1):\n            dp[i][j][clr] = dp[i - 1][j][clr]\n            if clr == best[i - 1][j - 1][0][1]:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][1][0])\n            else:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][0][0])\n            best[i][j][0] = (dp[i][j][clr], clr)\nans = INF\nfor k in range (1, m + 1):\n    if dp[n][k_res][k] < ans:\n        ans = dp[n][k_res][k]\nif ans == INF:\n    ans = -1\nprint(ans)\n\n\n\n", "import math\ndp=[[[math.inf for i in range(105)] for i in range(105)] for i in range(105)]\n#dp[x][y][z] denote index x , beauty y , using paint z\n#dp[x][y][z] denotes cost of it\n \nn,m,k=list(map(int,input().split()))\nk+=1\n\nz=list(map(int,input().split()))\nmatrix=[]\nfor i in range(n):\n    ans=list(map(int,input().split()))\n    matrix.append(ans)\nfor i in range(len(z)):\n   if(i==0):\n       if(z[i]!=0):\n           dp[0][1][z[i]-1]=0\n       else:\n           for x in range(m):\n               dp[0][1][x]=matrix[i][x]\n   else:\n       if(z[i]!=0):\n           col=z[i]-1\n           if(z[i-1]!=0):\n               col2=z[i-1]-1\n               if(col2==col):\n                   for j in range(k):\n                       if(j==0):\n                           continue;\n                       dp[i][j][col]=min(dp[i-1][j][col],dp[i][j][col])\n             \n               else:\n                   for j in range(k):\n                       if(j==0):\n                           continue;\n                       dp[i][j][col]=min(dp[i-1][j-1][col2],dp[i][j][col])\n\n           else:\n               pq=[]\n               for t in range(k):\n                   if(t==0):\n                       continue;\n                   pq=[]\n                   for x in range(m):\n                       pq.append([dp[i-1][t-1][x],x])\n                   pq.append([math.inf,math.inf])\n                   pq.sort()\n                   col=z[i]-1\n                   if(col!=pq[0][1] and pq[0][0]!=math.inf):\n                       dp[i][t][col]=min(dp[i][t][col],pq[0][0],dp[i-1][t][col])\n                   elif(pq[0][0]!=math.inf and col==pq[0][1]):\n                       dp[i][t][col]=min(dp[i][t][col],pq[1][0],dp[i-1][t][col])\n                   elif(pq[0][0]==math.inf):\n                       dp[i][t][col]=min(dp[i][t][col],dp[i-1][t][col])\n                       \n                  \n                   \n                       \n       else:\n           if(z[i-1]!=0):\n               col=z[i-1]-1\n               for t in range(k):\n                   if(t==0):\n                       continue;\n                   for x in range(m):\n                       if(x!=col):\n                           dp[i][t][x]=min(dp[i][t][x],dp[i-1][t-1][col]+matrix[i][x])\n                       else:\n                           dp[i][t][x]=min(dp[i][t][x],dp[i-1][t][col]+matrix[i][x])\n                \n           else:\n               for t in range(k):\n                   if(t==0):\n                       continue;\n                   pq=[]\n                   for x in range(m):\n                       pq.append([dp[i-1][t-1][x],x])\n                   pq.append([math.inf,math.inf])\n                   pq.sort()\n                \n                   for v in range(m):\n                       if(v!=pq[0][1]):\n                           dp[i][t][v]=min(dp[i][t][v],pq[0][0]+matrix[i][v],dp[i-1][t][v]+matrix[i][v])\n                       else:\n                           dp[i][t][v]=min(dp[i][t][x],dp[i-1][t][v]+matrix[i][v],pq[1][0]+matrix[i][v])\n                       \n                   \n    \n\nmini=math.inf\n\n\nfor i in range(m):\n    mini=min(mini,dp[n-1][k-1][i])\nif(mini==math.inf):\n    print(-1)\nelse:\n    print(mini)\n       \n               \n", "n, m, k = list(map(int, input().split()))\ncolors = list(map(int, input().split()))\ncosts = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[[float('inf') for _ in range(k+1)] \n                     for _ in range(m+1)]\n                     for _ in range(n+1)]\n\nfor i in range(m+1):\n    for j in range(k+1):\n        dp[0][i][j] = 0\n\nfor i in range(1, n+1):\n    if colors[i-1] > 0:\n        c = colors[i-1]\n        for w in range(1, min(i, k)+1):\n            dp[i][c][w] = min(dp[i][c][w], dp[i-1][c][w])\n            for j in range(1, m+1):\n                if j != c:\n                    dp[i][c][w] = min(dp[i][c][w], dp[i-1][j][w-1])\n    else:\n        for w in range(1, min(i, k)+1):\n            min1, min2 = float('inf'), float('inf')\n            for j in range(1, m+1):\n                if dp[i-1][j][w-1] < min1:\n                    min2, min1 = min1, dp[i-1][j][w-1]\n                else:\n                    min2 = min(min2, dp[i-1][j][w-1]) \n            for j in range(1, m+1):\n                dp[i][j][w] = min(dp[i][j][w], dp[i-1][j][w] + costs[i-1][j-1])\n                if min1 != dp[i-1][j][w-1]:\n                    dp[i][j][w] = min(dp[i][j][w], min1 + costs[i-1][j-1])\n                else:\n                    dp[i][j][w] = min(dp[i][j][w], min2 + costs[i-1][j-1])\n\nres = float('inf')\nfor i in range(1, m+1):\n    if dp[n][i][k] < res:\n        res = dp[n][i][k]\n\nprint(-1 if res == float('inf') else res)\n", "n,m,k=map(int,input().split())\ncol=list(map(int,input().split()))\np=[]\nfor i in range(n):p.append(list(map(int,input().split())))\ndp=[[[float('inf')]*m for i in range(k+1)] for i in range(n)]\nif col[0]==0:\n\tfor i in range(m):\n\t\tdp[0][1][i]=p[0][i]\nelse:\n\tdp[0][1][col[0]-1]=0\nfor i in range(1,n):\n\tfor j in range(1,k+1):\n\t\tif j==1:\n\t\t\tif col[i]:\n\t\t\t\tdp[i][j][col[i]-1]=dp[i-1][j][col[i]-1]\n\t\t\telse:\n\t\t\t\tfor c in range(m):\n\t\t\t\t\tdp[i][j][c]=dp[i-1][j][c]+p[i][c]\n\t\telse:\n\t\t\tif col[i]:\n\t\t\t\tx=dp[i-1][j][col[i]-1]\n\t\t\t\tfor t in range(m):\n\t\t\t\t\tif t!=col[i]-1:\n\t\t\t\t\t\tx=min(x,dp[i-1][j-1][t])\n\t\t\t\tdp[i][j][col[i]-1]=x\n\t\t\telse:\n\t\t\t\tfor c in range(m):\n\t\t\t\t\tx=dp[i-1][j][c]\n\t\t\t\t\tfor t in range(m):\n\t\t\t\t\t\tif t!=c:\n\t\t\t\t\t\t\tx=min(x,dp[i-1][j-1][t])\n\t\t\t\t\tdp[i][j][c]=x+p[i][c]\nans=(min(dp[-1][-1]))\nif ans!=float('inf'):print(ans)\nelse:print(-1)"]
["#TO MAKE THE PROGRAM FAST\n\n''' ----------------------------------------------------------------------------------------------------  '''\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nfrom collections import deque\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#FOR TAKING INPUTS\n\n''' ----------------------------------------------------------------------------------------------------  '''\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef val():return int(input().rstrip('\\n'))\ndef st():return input().rstrip('\\n')\ndef sttoli():return [int(i) for i in input().rstrip('\\n')]\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#MAIN PROGRAM\n\n''' ----------------------------------------------------------------------------------------------------  '''\n\nd = deque()\nn = val()\nl = li()\nj = x = 0\ncurrmax = -10000000000000\nans = []\nfor i in range(n):\n    while len(d) and d[0] < i:d.popleft()\n    currmax = l[d[0]%n] if len(d) else l[i]\n    while j<3*n:\n        currmax = max(currmax,l[j%n])\n        while len(d) and l[d[-1]%n] <= l[j%n]:d.pop()\n        d.append(j)\n        if currmax/2 > l[j%n]:\n            ans.append(j-i)\n            break\n        j += 1\n    if j == 3*n:\n        print(*([-1 for _______ in range(n)]))\n        return\nprint(*ans)\n\n\n\n\n\n''' ----------------------------------------------------------------------------------------------------  '''", "NN = 18\nMI = [1<<100] * ((1<<NN+1)-1)\n \ndef update(x):\n    i = (1<<NN) - 1 + x\n    MI[i] = x\n    while True:\n        i = (i-1) // 2\n        MI[i] = min(MI[2*i+1], MI[2*i+2])\n        if i == 0:\n            break\n\ndef rangemin(a, b):\n    l = a + (1<<NN)\n    r = b + (1<<NN)\n    mi = 1<<100\n    while l < r:\n        if l%2:\n            mi = min(mi, MI[l-1])\n            l += 1\n        if r%2:\n            r -= 1\n            mi = min(mi, MI[r-1])\n        l >>= 1\n        r >>= 1\n    return mi\n\nN = int(input())\nA = [int(a) for a in input().split()]\nB = sorted([(A[i], i) for i in range(N)])\ni = 0 # large\nj = 0 # small\nX = [1<<20] * (2*N)\nwhile i < N:\n    while 2 * B[j][0] < B[i][0]:\n        update(B[j][1])\n        update(B[j][1]+N)\n        j += 1\n    X[B[i][1]] = rangemin(B[i][1], B[i][1]+N)\n    X[B[i][1]+N] = X[B[i][1]] + N\n    i += 1\nfor i in range(2*N-1)[::-1]:\n    X[i] = min(X[i], X[i+1])\nfor i in range(N):\n    X[i] -= i\nX = [a if a < (1<<20) else -1 for a in X[:N]]\nprint(*X)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nB=[(-a,i) for i,a in enumerate(A)]\n\nfrom collections import deque\n\nLIST=deque()\nLIST.append(B[0])\n\nfor b,i in B[1:]:\n    if b>LIST[-1][0]:\n        LIST.append((b,i))\n\nimport bisect\n\nDIS=[-1]*n\n\nfor i in range(n-1,-1,-1):\n    x=bisect.bisect(LIST,(-A[i]//2,1<<20))\n    if x<len(LIST):\n        DIS[i]=LIST[x][1]\n\n    while len(LIST)>=1 and A[i]<=-LIST[0][0]:\n        LIST.popleft()\n\n    LIST.appendleft(B[i])\n\nif max(DIS)==-1:\n    print(*[-1]*n)\n    return\n\nfor i in range(n):\n    if DIS[i]!=-1:\n        start=i\n        break\n\nANS=[-1]*n\n\nif DIS[start]>start:\n    ANS[start]=DIS[start]-start\nelse:\n    ANS[start]=DIS[start]+(n-start)\n\n\nfor i in range(start-1,-1,-1):\n    if DIS[i]==-1:\n        ANS[i]=ANS[(i+1)%n]+1\n    else:\n        if DIS[i]>i:\n            ANS[i]=min(DIS[i]-i,ANS[(i+1)%n]+1)\n        else:\n            ANS[i]=min(DIS[i]+(n-i),ANS[(i+1)%n]+1)\n\nfor i in range(n-1,-1,-1):\n    if DIS[i]==-1:\n        ANS[i]=ANS[(i+1)%n]+1\n    else:\n        if DIS[i]>i:\n            ANS[i]=min(DIS[i]-i,ANS[(i+1)%n]+1)\n        else:\n            ANS[i]=min(DIS[i]+(n-i),ANS[(i+1)%n]+1)\n\nfor i in range(n-1,-1,-1):\n    if DIS[i]==-1:\n        ANS[i]=ANS[(i+1)%n]+1\n    else:\n        if DIS[i]>i:\n            ANS[i]=min(DIS[i]-i,ANS[(i+1)%n]+1)\n        else:\n            ANS[i]=min(DIS[i]+(n-i),ANS[(i+1)%n]+1)\n    \n\nprint(*ANS)\n        \n", "import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx]):\n                    idx = 2*idx\n                else:\n                    idx = 2*idx + 1\n            return idx - self.N0\n\nN = int(readline())\nA = list(map(int, readline().split()))\nB = [2*a for a in A]\nB *= 3\ninf = 2*10**9\nB.append(-2)\nT = Segtree(B, inf, True, min)\n\nNN = T.N0\n\nJ = [0]*(NN+1)\nJ[3*N] = inf\nKK = [None]*(NN+1)\nfor i in range(3*N-1, -1, -1):\n    a = A[i%N]\n    k = T.binsearch(i, NN, lambda x: x < a ,reverse = False)\n    KK[i] = k\n    J[i] = min(J[i+1], k)\n\nAns = [-1]*N\nfor i in range(N):\n    j = J[i]\n    if j == 3*N:\n        continue\n    Ans[i] = j - i\nprint(*Ans)", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass Binary_Indexed_Tree():\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += i & -i\n\n    def get(self, i):\n        return self.sum_range(i, i)\n\n    def sum(self, i):\n        ret = 0\n        while i:\n            ret += self.data[i]\n            i &= i-1\n        return ret\n\n    def sum_range(self, l, r):\n        return self.sum(r)-self.sum(l-1)\n\n    def lower_bound(self, w):\n        if w<=0:\n            return 0\n        i = 0\n        k = 1<<(self.n.bit_length())\n        while k:\n            if i+k <= self.n and self.data[i+k] < w:\n                w -= self.data[i+k]\n                i += k\n            k >>= 1\n        return i+1\n\nclass RangeMinimumQuery:\n    def __init__(self, n, func=min, inf=float(\"inf\")):\n        self.n0 = 2**(n-1).bit_length()\n        self.op = func\n        self.inf = inf\n        self.data = [self.inf]*(2*self.n0)\n\n    def construct(self, lis):\n        for i, x in enumerate(lis):\n            self.data[i+self.n0-1] = x\n        for i in range(self.n0-2, -1, -1):\n            self.data[i] = self.op(self.data[2*i+1], self.data[2*i+2])\n\n    def query(self, l,r):\n        l += self.n0\n        r += self.n0\n        res = self.inf\n        while l < r:\n            if r&1:\n                r -= 1\n                res = self.op(res, self.data[r-1])\n            if l&1:\n                res = self.op(res, self.data[l-1])\n                l += 1\n            l >>=1\n            r >>=1\n        return res\n\nn = int(input())\na = list(map(int, input().split()))\na = [i*2 for i in a]\nBIT = Binary_Indexed_Tree(2*n)\nRMQ = RangeMinimumQuery(2*n)\nRMQ.construct(a+a)\n\nb = [[j,i] for i,j in enumerate(a)]\nb.sort(reverse=True)\nans = [0]*n\nfor j, i in b:\n    cnt = BIT.sum(2*n-i)\n    tmp = float(\"inf\")\n    if cnt:\n        p = 2*n-BIT.lower_bound(cnt)\n        tmp = p-i + ans[p%n]\n    BIT.add(2*n-i, 1)\n    BIT.add(n-i, 1)\n    left = i\n    right = 2*n\n    if RMQ.query(i, right) < j//2:\n        while right-left>1:\n            mid = (right+left)//2\n            if RMQ.query(i, mid) < j//2:\n                right = mid\n            else:\n                left = mid\n        tmp = min(tmp, right-i-1)\n    ans[i] = tmp\nans = [i if i!=float(\"inf\") else -1 for i in ans]\nprint(*ans)\n", "import sys\ninput = sys.stdin.readline\n\nclass SegTree(object):\n\t\"\"\"docstring for SegTree\"\"\"\n\tdef __init__(self, n, arr):\n\t\tself.n = n\n\t\tself.arr = arr\n\t\tself.tree = [0 for i in range(2*n)]\n\n\tdef construct(self): # Construction\n\t\tfor i in range(self.n):\n\t\t\tself.tree[n+i] = self.arr[i]\n\t\tfor i in range(n-1,0,-1):\n\t\t\tself.tree[i] = self.function(self.tree[2*i],self.tree[2*i+1])\n\n\tdef update(self,index,change):\n\t\tstart = index+self.n\n\t\tself.tree[start] = value\n\t\twhile start>0:\n\t\t\tself.tree[start] = self.function(self.tree[2*start],self.tree[2*start+1])\n\t\t\tstart = start//2\n\n\tdef calc(self,low,high): # 0-indexed\n\t\tlow+=self.n\n\t\thigh+=self.n\n\t\tans = 0 # Needs to initialised\n\t\twhile low<high:\n\t\t\tif low%2:\n\t\t\t\tans = self.function(ans, self.tree[low])\n\t\t\t\tlow += 1\n\t\t\tif high%2:\n\t\t\t\thigh -= 1\n\t\t\t\tans = self.function(ans, self.tree[high])\n\t\t\tlow = low//2\n\t\t\thigh = high//2\n\t\treturn ans\n\t\n\tdef function(self,a,b): # Function used to construct Segment Tree\n\t\treturn max(a,b)\n\nn = int(input())*3\na = list(map(int,input().split()))\na = a + a + a\nst = SegTree(n,a)\nst.construct()\nans = [-1]*n\nm = a[0]\nflag = 0\nfor i in range(1,n):\n\tif a[i]<=(m-1)//2:\n\t\tans[0] = i\n\t\tflag = 1\n\t\tprev = i\n\t\tbreak\n\telse:\n\t\tm = max(m,a[i])\nif not flag:\n\tprint(*ans[0:n//3])\n\treturn\nfor i in range(1,n//3):\n\tif a[i]>=a[i-1]:\n\t\tans[i] = ans[i-1]-1\n\telse:\n\t\tmaxx = st.calc(i,prev+1)\n\t\twhile a[prev]>(maxx-1)//2:\n\t\t\t# print (prev,i,maxx)\n\t\t\tmaxx = max(maxx,a[prev])\n\t\t\tprev += 1\n\t\tans[i] = prev - i\nprint(*ans[0:n//3])\n\n"]
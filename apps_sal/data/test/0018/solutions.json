["from collections import deque\nS = input()\nmn = [ 300 for i in range( len( S ) ) ]\nfor i in range( len( S ) - 1, -1, -1 ):\n  if i == len( S ) - 1:\n    mn[ i ] = ord( S[ i ] )\n  else:\n    mn[ i ] = min( mn[ i + 1 ], ord( S[ i ] ) )\nans = \"\"\ndq = deque()\nfor i in range( len( S ) ):\n  dq.append( ord( S[ i ] ) )\n  while len( dq ) and ( i + 1 == len( S ) or dq[ len( dq ) - 1 ] <= mn[ i + 1 ] ):\n    ans += chr( dq[ len( dq ) - 1 ] )\n    dq.pop()\nprint( ans )\n", "from collections import defaultdict\n\ns = input()\ns = [x for x in s]\n\nt, u = [], []\n\nds = defaultdict(int)\n\nfor c in s:\n    ds[c] += 1\n\ncurr_letter_index = ord('a')\ncurr_poz_in_s = 0\n\nwhile curr_letter_index <= ord('z'):\n    curr_letter = chr(curr_letter_index)\n\n    if len(t) > 0 and ord(t[-1]) <= ord(curr_letter):\n        letter = t.pop()\n        u.append(letter)\n    else:\n        if ds[curr_letter] > 0:\n            letter = s[curr_poz_in_s]\n            curr_poz_in_s += 1\n            t.append(letter)\n            ds[letter] -= 1\n        else:\n            curr_letter_index += 1\n\nt.reverse()\nprint(\"\".join(u + t))\n", "s = input()\nm = ['z' for i in range(len(s))]\nm[-1] = s[-1]\nc = s[-1]\nfor i in range(len(s) - 2, -1, -1):\n    if s[i] < c:\n        c = s[i]\n    m[i] = c\nind = m.index(min(m))\nl = []\nres = ''\nfor i in range(len(s)):\n    while l and l[-1] <= m[i]:\n        res += l.pop()\n    l.append(s[i])\nprint(res + ''.join(map(str, (l[::-1]))))\n", "from queue import deque\n\ndp = {}\n\ndef sol_1():\n    idx = 0\n    while True:\n        min_idx = get_min_char_idx(s, idx)\n        if min_idx == -1:\n            break\n        if len(t) > 0 and ord(t[-1]) <= ord(s[min_idx]):\n            # we need to take t\n            u.append(t.pop())\n        else:\n            # take up to min_idx\n            t.extend(s[idx:min_idx+1])\n            idx = min_idx+1\n\ndef efficient_sol():\n    nonlocal u, t, s\n    import string\n    indices = {char: [] for char in string.ascii_lowercase}  # will hold indices for each char\n\n    # fill indices\n    for idx, char in enumerate(s):\n        indices[char].append(idx)\n\n    curr_idx = 0\n    for char in string.ascii_lowercase:\n        if curr_idx == len(s):\n            break\n        if len(t) > 0 and ord(char) >= ord(t[-1]):\n            # We've started searching for bigger characters, so we need to empty the smaller ones first\n            while len(t) > 0 and ord(char) >= ord(t[-1]):\n                u.append(t.pop())\n\n        for idx in sorted(indices[char]):\n            if curr_idx == len(s):\n                return\n            min_idx = idx\n            if min_idx < curr_idx:\n                # we've passed this character\n                continue\n            elif min_idx == curr_idx:\n                if len(t) > 0 and ord(char) > ord(t[-1]):\n                    raise Exception()\n                # we are at that character, so just add it\n                u.append(char)\n                curr_idx += 1\n                continue\n            # mid_idx is bigger, so we put everything up until this character in T\n            # then, add the character himself\n            t.extend(s[curr_idx:min_idx])\n            u.append(char)\n            curr_idx = min_idx + 1\n    while curr_idx < len(s):\n        pass\n\ndef get_min_char_idx(s: str, start_idx: int):\n    nonlocal dp\n    if start_idx >= len(s):\n        return -1\n    if start_idx in dp:\n        return dp[start_idx]\n    min_char = s[start_idx]\n    min_idx = start_idx\n    while start_idx < len(s):\n        if ord(s[start_idx]) < ord(min_char):\n            min_char = s[start_idx]\n            min_idx = start_idx\n        start_idx += 1\n    dp[start_idx] = min_idx\n    return min_idx\n\n# aaaczbgjs\nimport string\ns = input()\n# s = 'abcadc'\n# s = string.ascii_lowercase + string.ascii_lowercase\n\nu = []\nt = []\n\n# if len(s) >= 10**3:\nefficient_sol()\n# else:\n#     sol_1()\n\n# abaaabababacba\n# print(t)\nprint(''.join(u + list(reversed(t))))\n", "s = input()\nm = ['z' for i in range(len(s))]\nm[-1] = s[-1]\nc = s[-1]\nfor i in range(len(s) - 2, -1, -1):\n    if s[i] < c:\n        c = s[i]\n    m[i] = c\nind = m.index(min(m))\nl = []\nres = ''\nfor i in range(len(s)):\n    while l and l[-1] <= m[i]:\n        res += l.pop()\n    l.append(s[i])\nprint(res + ''.join(map(str, (l[::-1]))))\n", "#! /bin/python\n\ns = input()\nresultBase = \"\"\nresultRest = \"\"\nbest = len(s) - 1\nmini = [0] * len(s)\n\nfor i in range(len(s) - 1, -1, -1):\n    mini[i] = best\n    if s[best] >= s[i]:\n        best = i\n\nfor i in range(len(s)):\n    resultRest += s[i]\n    while len(resultRest) > 0 and resultRest[-1] <= s[mini[i]]:\n        resultBase += resultRest[-1]\n        resultRest = resultRest[:-1]\n    \n    #  print(resultRest[-1] if len(resultRest) > 0 else '-', s[mini[i]])\n    #  print(resultRest)\n    #  print(resultBase)\n    #  print()\n    \n\nprint(resultBase + resultRest[::-1])\n", "'''input\ncab\n'''\ns = input()\nm = [\"z\"] * len(s)\nm[-1] = s[-1]\nc = s[-1]\nfor x in range(len(s) - 2, -1, -1):\n\tc = min(c, s[x])\n\tm[x] = c\ni = m.index(min(m))\nt = []\ny = \"\"\nfor x in range(len(s)):\n\twhile t and t[-1] <= m[x]:\n\t\ty += t.pop()\n\tt.append(s[x])\nprint(y, end=\"\")\nfor x in t[::-1]:\n\tprint(x, end=\"\")\n# s1 = sorted(s)\n# t, u = [], []\n# for l in s1:\n# \tif l in s:\n# \t\ti = s.index(l)\n# \t\tt += s[:i]\n# \t\tdel s[:i+1]\n# \t\tu.append(l)\n# print(\"\".join(u + t[::-1]))\n", "import sys\nimport collections\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, item):\n        self.stack.append(item)\n\n    def pop(self):\n        del self.stack[len(self.stack)-1]\n\n    def top(self):\n        return self.stack[len(self.stack)-1]\n\n    def empty(self):\n        return len(self.stack) == 0\n\ndef main():\n    s = list(sys.stdin.readline().split()[0])\n\n    hist = [0 for i in range(256)]\n\n    for c in s:\n        hist[ord(c)]+=1\n\n    cur = 0\n    u = []\n    t = []\n\n    minn = ord('a')\n    for i in range(minn, ord('z')+1):\n        if(hist[i]):\n            minn = i\n            break\n    aux = []\n    while cur < len(s):\n        aux.append(s[cur])\n        hist[ord(s[cur])] -= 1\n\n        if(s[cur] == chr(minn)):\n            u += aux\n            aux = []\n            minn = ord('z')\n            for i in range(ord('a'), ord('z')+1):\n                if(hist[i]):\n                    minn = i\n                    break\n\n            while(len(u) and ord(u[-1]) <= minn):\n                t.append(u[-1])\n                del u[-1]\n        cur += 1\n\n\n    print(\"\".join(t))\n\n\n\n\n\nmain()\n\n# argc, argv\n# wait_pid\n# sig_alarm\n", "import sys\nimport collections\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, item):\n        self.stack.append(item)\n\n    def pop(self):\n        del self.stack[len(self.stack)-1]\n\n    def top(self):\n        return self.stack[len(self.stack)-1]\n\n    def empty(self):\n        return len(self.stack) == 0\n\ndef main():\n    s = list(sys.stdin.readline().split()[0])\n\n    hist = [0 for i in range(256)]\n\n    for c in s:\n        hist[ord(c)]+=1\n\n    cur = 0\n    u = []\n    t = []\n\n    minn = ord('a')\n    for i in range(minn, ord('z')+1):\n        if(hist[i]):\n            minn = i\n            break\n    aux = []\n    while cur < len(s):\n        aux.append(s[cur])\n        hist[ord(s[cur])] -= 1\n\n        if(s[cur] == chr(minn)):\n            u += aux\n            aux = []\n            minn = ord('z')\n            for i in range(ord('a'), ord('z')+1):\n                if(hist[i]):\n                    minn = i\n                    break\n\n            while(len(u) and ord(u[-1]) <= minn):\n                t.append(u[-1])\n                del u[-1]\n        cur += 1\n\n\n    print(\"\".join(t))\n\nmain()\n", "import sys\nimport collections\n\ndef main():\n    s = list(sys.stdin.readline().split()[0])\n\n    hist = [0 for i in range(256)]\n\n    for c in s:\n        hist[ord(c)]+=1\n\n    cur = 0\n    u = []\n    t = []\n\n    minn = ord('a')\n    for i in range(minn, ord('z')+1):\n        if(hist[i]):\n            minn = i\n            break\n    aux = []\n    while cur < len(s):\n        aux.append(s[cur])\n        hist[ord(s[cur])] -= 1\n\n        if(s[cur] == chr(minn)):\n            u += aux\n            aux = []\n            minn = ord('z')\n            for i in range(ord('a'), ord('z')+1):\n                if(hist[i]):\n                    minn = i\n                    break\n\n            while(len(u) and ord(u[-1]) <= minn):\n                t.append(u[-1])\n                del u[-1]\n        cur += 1\n\n\n    print(\"\".join(t))\n\nmain()\n", "from itertools import takewhile\n\ndef f(s):\n    t = []\n    u = []\n    chars = 'abcdefghijklmnopqrstuvwxyz'\n\n    for c in chars:\n        stack = list(takewhile(lambda x: x <= c, reversed(t)))\n        count = len(stack)\n        if count > 0:\n            u += stack\n            t = t[:-count]\n\n        count = s.count(c)\n        if count > 0:\n            rindex = s.rindex(c)\n            u += c * count\n            t += [x for x in s[:rindex] if x != c]\n            s = s[rindex + 1:]\n\n    u += reversed(t)\n    return ''.join(u)\n\nprint(f(input()))\n", "#! /bin/python\n\ns = input()\nresultBase = \"\"\nresultRest = \"\"\nbest = len(s) - 1\nmini = [0] * len(s)\n\nfor i in range(len(s) - 1, -1, -1):\n    mini[i] = best\n    if s[best] >= s[i]:\n        best = i\n\nfor i in range(len(s)):\n    resultRest += s[i]\n    while len(resultRest) > 0 and resultRest[-1] <= s[mini[i]]:\n        resultBase += resultRest[-1]\n        resultRest = resultRest[:-1]\n    \nprint(resultBase + resultRest[::-1])\n", "s = input()\niterate = 0\ne = [(True) for i in range(len(s))]\nans = ['' for i in range(len(s))]\nidx = 0\n\nlastOccur = [-1 for i in range(26)]\n\nfor i in range (len(s)):\n\tlastOccur[ord(s[i])-ord('a')] = i\n\ni = 0\nwhile(i < 26 and iterate < len(s)):\n\tj = iterate-1\n\twhile(j >= 0 and ord(s[j]) - ord('a') <= i):\n\t\tif(e[j]):\n\t\t\tans[idx] = s[j]\n\t\t\te[j] = False\n\t\t\tidx += 1\n\t\tj -= 1\n\n\tj = iterate\n\twhile(j < lastOccur[i]+1):\n\t\tif(e[j] and ord(s[j])-ord('a') == i):\n\t\t\tans[idx] = s[j]\n\t\t\te[j] = False\n\t\t\tidx += 1\n\t\tj += 1\n\titerate = j\n\ti += 1\n\nif(iterate >= len(s)):\n\tfor j in range(len(s)-1, -1, -1):\n\t\tif(e[j]):\n\t\t\tans[idx] = s[j]\n\t\t\tidx += 1\n\n\n#print(ans)\nstr1 = ''.join(ans)\nprint(str1)", "s=input()\ns+=('{')\nans=\"\"\ntmp=[]\nm = ['z' for i in range(len(s)+1)]\nfor i in range(len(s)-1,-1,-1):\n    m[i]=min(m[i+1],s[i])\n#print(m)\nfor i in range(len(s)-1):\n    tmp.append(s[i])\n    while len(tmp) and tmp[-1]<=m[i+1]:\n            ans += tmp.pop()\nprint(ans)", "\ndef s_has_smaller(s_cnt_local, c):\n    for i in range(ord('a'), ord(c)):\n        if s_cnt_local[i] > 0:\n            return True\n    return False\n\n\ns = list(input())\ns.reverse()\n\n\nt = []\nu = []\n\ns_cnt = [0] * (ord('z')+1)\nfor x in s:\n    s_cnt[ord(x)] += 1\n\n\nwhile s or t:\n    # print('+'*10)\n    # print(s)\n    # print(t)\n    # print(u)\n    # print(s_cnt)\n    # print(t_cnt)\n    if not s:\n        while t:\n            u.append(t.pop())\n    elif not t:\n        x = s.pop()\n        s_cnt[ord(x)] -= 1\n        t.append(x)\n    else:\n        if s_has_smaller(s_cnt, t[-1]):\n            x = s.pop()\n            s_cnt[ord(x)] -= 1\n            t.append(x)\n        else:\n            x = t.pop()\n            u.append(x)\n\nprint(\"\".join(u))\n", "\nptr = ord('a')\n\n\ndef s_has_smaller(s_cnt_local, c):\n    nonlocal ptr\n    for i in range(ptr, ord(c)):\n        ptr = i\n        if s_cnt_local[i] > 0:\n            return True\n    return False\n\n\ns = list(input())\ns.reverse()\n\n\nt = []\nu = []\n\ns_cnt = [0] * (ord('z')+1)\nfor x in s:\n    s_cnt[ord(x)] += 1\n\n\nwhile s or t:\n    # print('+'*10)\n    # print(s)\n    # print(t)\n    # print(u)\n    # print(s_cnt)\n    # print(t_cnt)\n    if not s:\n        while t:\n            u.append(t.pop())\n    elif not t:\n        x = s.pop()\n        s_cnt[ord(x)] -= 1\n        t.append(x)\n    else:\n        if s_has_smaller(s_cnt, t[-1]):\n            x = s.pop()\n            s_cnt[ord(x)] -= 1\n            t.append(x)\n        else:\n            x = t.pop()\n            u.append(x)\n\nprint(\"\".join(u))\n", "def letters():\n    return (chr(i) for i in range(ord('a'), ord('z') + 1))\n\n\ns = input()\n\nls = {lt: 0 for lt in letters()}\n\nfor lt in s:\n    ls[lt] += 1\n\ns = [ch for ch in reversed(s)]\nstack = []\nres = []\n\nfor curr in letters():\n    while stack and stack[-1] <= curr:\n        res.append(stack.pop(-1))\n    while ls[curr] > 0:\n        if s[-1] != curr:\n            c = s.pop(-1)\n            ls[c] -= 1\n            stack.append(c)\n        else:\n            ls[curr] -= 1\n            res.append(s.pop(-1))\nres += reversed(stack)\nprint(''.join(res))\n", "s=input()\nn=len(s)\ncur=('z',n)\nmi=[cur for _ in range(n)]\nns=mi[:]\nfor i in range(n-1,-1,-1):\n    if (s[i],i)<cur:\n        cur=(s[i],i)\n    mi[i]=cur\n    ns[i]=(s[i],i)\npos=0\ncache=list()\nres=''\n\nwhile len(res)<n:\n    c,i=mi[pos]\n    res+=c\n    cache+=ns[pos:i]\n    pos=i\n    if  cache:\n        val, _ =cache[-1]\n        mi[pos]=(val,pos)\n        ns[pos]=(val,pos)\n        if pos<n-1:\n            mi[pos]=min(mi[pos],mi[pos+1])\n        cache.pop()\n    else:\n        pos+=1\n        \n        \nprint( res   ) \n", "s=input()\nn=len(s)\ncur=('z',n)\nmi=[cur for _ in range(n)]\nns=['z']*n\nfor i in range(n-1,-1,-1):\n    if (s[i],i)<cur:\n        cur=(s[i],i)\n    mi[i]=cur\n    ns[i]=s[i]\npos=0\ncache=list()\nres=''\n\nwhile len(res)<n:\n    c,i=mi[pos]\n    res+=c\n    cache+=ns[pos:i]\n    pos=i\n    if  cache:\n        val =cache[-1]\n        mi[pos]=(val,pos)\n        ns[pos]=val\n        if pos<n-1:\n            mi[pos]=min(mi[pos],mi[pos+1])\n        cache.pop()\n    else:\n        pos+=1\n        \n        \nprint( res   ) \n", "s = input()\nprefmin = ['{'] * (len(s) + 1)\nst = []\n\nfor i in range(len(s) - 1, -1, -1):\n    prefmin[i] = min(s[i], prefmin[i + 1])\n\nfor i in range(len(s)):\n    while len(st) and st[-1] <= prefmin[i]:\n        print(st.pop(), end='')\n    if prefmin[i] == s[i]:\n        print(s[i], end='')\n    else:\n        st.append(s[i])\n\nfor i in range(len(st) - 1, -1, -1):\n    print(st[i], end='')\n\n", "def main():\n    s = list(input())\n\n    suffix = []\n    for x in reversed(s):\n        if suffix:\n            suffix.append(min(suffix[-1], x))\n        else:\n            suffix.append(x)\n\n    suffix = suffix[::-1]\n\n    u = []\n    t = []\n    i = 0\n\n    while True:\n        m = suffix[i]\n\n        while t and t[-1] <= m:\n            u.append(t[-1])\n            t.pop()\n\n        while s[i] != m:\n            t.append(s[i])\n            i += 1\n\n        u.append(s[i])\n\n        i += 1\n        if i == len(s):\n            break\n\n    u += t[::-1]\n\n    print(''.join(u))\n\n\nmain()\n", "def main():\n    s = list(input())\n\n    suffix = []\n    for x in reversed(s):\n        if suffix:\n            suffix.append(min(suffix[-1], x))\n        else:\n            suffix.append(x)\n\n    suffix = suffix[::-1]\n\n    u = []\n    t = []\n    i = 0\n\n    while True:\n        m = suffix[i]\n\n        while t and t[-1] <= m:\n            u.append(t[-1])\n            t.pop()\n\n        while s[i] != m:\n            t.append(s[i])\n            i += 1\n\n        u.append(s[i])\n\n        i += 1\n        if i == len(s):\n            break\n\n    u += t[::-1]\n\n    print(''.join(u))\n\n\nmain()\n", "#!/usr/bin/pypy3\n\n# s[0] -> t[-1] or t[-1]->u[-1]\n# \"cab\" ->(\"cab\",\"\",\"\")->(\"ab\",\"c\",\"\")->(\"b\",\"ca\",\"\")->(\"b\",\"c\",\"a\")\n# 1) stack s->t until min(s).\n# 2) passthrough min(s)->u\n# min(s,t[-1]) -> u. Repeat.\n# need to know the smallest item in s (quickly)\n# think it's: split into two subsequences, merge s1(reverse)+s2. minimum.\n# \"cab\" -> s1=\"cb\",s2=\"a\" -> bc\n# \"dcab\" -> \"b\",\"dca\"\nfrom sys import stdin,stderr\n\ndef readInts(): return map(int,stdin.readline().strip().split())\ndef print_err(*args,**kwargs): print(*args,file=stderr,**kwargs)\n    \ndef solve(s):\n    s = list(s)\n    sn = len(s)\n    pq = sorted(zip(list(s),range(sn)))\n    ix_left = 0\n    u,v = [],[]\n    for c,ix in pq:\n        if ix < ix_left: continue\n        while u and c >= u[-1]: v.append(u.pop())\n        for cix in range(ix_left,ix+1): u.append(s[cix])\n        ix_left = ix+1\n    while u: v.append(u.pop())\n    return v    \n\ndef run():\n    s = input().strip()\n    print(\"\".join(solve(s)))\n        \nrun()\n", "s=input()\nc=[0]*26\nfor i in s:\n    c[ord(i)-97]+=1\nt=[]\nu=[]\nfor i in s:\n    t.append(i)\n    c[ord(i)-97]-=1\n    while t and sum(c[:(ord(t[-1])-97)])==0:\n        u.append(t.pop())\n        \nprint(''.join(u))      "]
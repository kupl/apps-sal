["rr = lambda: input().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\nMOD = 10**9 + 7\n\nclass DSU:\n    def __init__(self, N):\n        #R * C is the source, and isn't a grid square\n        self.par = list(range(N+1))\n        self.rnk = [0] * (N+1)\n        self.sz = [1] * (N+1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n        \ndef solve(N, K, edges):\n    graph = [[] for _ in range(N)]\n    dsu = DSU(N)\n    for u,v,w in edges:\n        u-=1;v-=1\n        if w==0: #red\n            dsu.union(u, v)\n\n    ans = pow(N, K, MOD)\n    for x in range(N):\n        if dsu.find(x) == x:\n            ans -= pow(dsu.size(x), K, MOD)\n            ans %= MOD\n    return ans\n\nfor tc in range(1):#rri()):\n    N, K = rrm()\n    edges = [rrm() for _ in range(N-1)]\n    print(solve(N, K, edges))\n", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(n-1)]\nmod=10**9+7\n\nGroup=[i for i in range(n+1)]\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nfor x,y,c in EDGE:\n    if c==0:\n        Union(x,y)\n\nG=[find(i) for i in range(1,n+1)]\n\nfrom collections import Counter\ncounter=Counter(G)\n\nANS=0\nfor j in list(counter.values()):\n    ANS=(ANS+pow(j,k,mod))%mod\n\nprint((pow(n,k,mod)-ANS)%mod)\n", "n, k = [int(i) for i in input().split()]\nadj = [[] for i in range(n+1)]\n\nans = 0\n# no of good paths = all paths - non-good paths\n# = all paths - paths where no blacks\n\npar = [i for i in range(n+1)]\n\ndef find(i):\n    nonlocal par\n    if par[i] == i:\n        return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef unite(i, j):\n    nonlocal par\n    if find(i) < find(j):\n        i, j = j, i\n    par[find(i)] = find(j)\n\nfor i in range(n-1):\n    u, v, c = [int(i) for i in input().split()]\n    adj[u].append((v,c))\n    adj[v].append((u, c))\n    if c==0:\n        unite(u, v)\n\nsz = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n    sz[find(i)] += 1\ngrps = []\nfor i in range(1, n+1):\n    if find(i) == i:\n        grps.append(i)\n        \nmod = 10**9 + 7\nans += pow(n, k, mod) #n**k\n\nfor i in grps:\n    ans -= pow(sz[i], k, mod) #sz[i]**k\n    ans += mod\nprint(ans%mod)\n", "import collections\n\np = 10 ** 9 + 7\n\nn, k = list(map(int, input().split()))\n\n# g: List[List[int]]\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b, x = list(map(int, input().split()))\n    if x != 0:\n        continue\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\nv = [False] * n\n\nbad = 0\n\nfor i in range(n):\n    if v[i]:\n        continue\n\n    d = collections.deque()\n    d.append(i)\n    v[i] = True\n    c = 0\n    while d:\n        i = d.pop()\n        for j in g[i]:\n            if v[j]:\n                continue\n            v[j] = True\n            d.append(j)\n        c += 1\n    bad += pow(c, k, p)\n\nprint((pow(n, k, p) + p - bad) % p)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nn, k = list(map(int, input().split()))\ng = defaultdict(list)\nfor _ in range(n-1):\n    u, v, x = list(map(int, input().split()))\n    u, v = u-1, v-1\n    if not x:\n        g[u].append(v)\n        g[v].append(u)\nMOD = 10**9 + 7\n\nres = pow(n, k, MOD)\n\nvisited = [False for _ in range(n)]\nfor i in range(n):\n    if not visited[i]:\n        cnt = 1\n        visited[i] = True\n        stack = [i]\n        while stack:\n            curr = stack.pop()\n            for ne in g[curr]:\n                if not visited[ne]:\n                    visited[ne] = True\n                    cnt += 1\n                    stack.append(ne)\n        res -= pow(cnt, k, MOD)\n\nprint(res % MOD)\n", "import collections\n\nclass UnionFind:\n    \"\"\"Weighted quick-union with path compression.\n    The original Java implementation is introduced at\n    https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf\n    >>> uf = UnionFind(10)\n    >>> for (p, q) in [(3, 4), (4, 9), (8, 0), (2, 3), (5, 6), (5, 9),\n    ...                (7, 3), (4, 8), (6, 1)]:\n    ...     uf.union(p, q)\n    >>> uf._id\n    [8, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    >>> uf.find(0, 1)\n    True\n    >>> uf._id\n    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    def __init__(self, n):\n        self._id = list(range(n))\n        self._sz = [1] * n\n\n    def _root(self, i):\n        j = i\n        while (j != self._id[j]):\n            self._id[j] = self._id[self._id[j]]\n            j = self._id[j]\n        return j\n\n    def find(self, p, q):\n        return self._root(p) == self._root(q)\n    \n    def union(self, p, q):\n        i = self._root(p)\n        j = self._root(q)\n        if i == j:\n            return\n        if (self._sz[i] < self._sz[j]):\n            self._id[i] = j\n            self._sz[j] += self._sz[i]\n        else:\n            self._id[j] = i\n            self._sz[i] += self._sz[j]\n\nn, k = map(int, input().split())\n\nuf = UnionFind(n)\n\nfor i in range(n-1):\n    u, v, x = map(int, input().split())\n    u -= 1\n    v -= 1\n    if x==0:\n        uf.union(u, v)\n\nd = collections.defaultdict(int)\nfor i in range(n):\n    d[uf._root(i)] += 1\n\ntotal = pow(n, k, 10**9+7)\nfor size in d.values():\n    total -= pow(size, k, 10**9+7)\n\ntotal %= 10**9+7\n\nprint(total)", "n,k=list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    u,v,c=list(map(int,input().split()))\n    if c==0:\n        g[u].append(v)\n        g[v].append(u)\nmod=10**9+7\ndef cal_pow(a,b):\n    nonlocal mod\n    i=0\n    val=1\n    while i<b:\n        val=(val*a)%mod\n        i+=1\n    return (val-a+mod)%mod\n\nsumm=cal_pow(n,k)\nvis=[False for _ in range(n+1)]\nfrom collections import deque\ndef bfs(ind):\n    q=deque()\n    q.append(ind)\n    cnt=0\n    vis[ind]=True\n    while q:\n        indx=q.popleft()\n        cnt+=1\n        for v in g[indx]:\n            if not vis[v]:\n                q.append(v)\n                vis[v]=True\n    return cnt\n\nfor v in range(1,n+1):\n    if not vis[v]:\n        cnt=bfs(v)\n        summ=((mod+summ)-(cal_pow(cnt,k)))%mod\nprint(summ)\n\n", "n,k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    u,v,x = map(int, input().split())\n    g[u-1].append((v-1, x))\n    g[v - 1].append((u - 1, x))\n\nv = [0 for i in range(n)]\ncomps = []\nfor i in range(n):\n    if v[i] == 1:\n        continue\n    v[i] = 1\n    comps.append([i])\n    q = [i]\n    while q:\n        u0 = q[0]\n        q = q[1:]\n        for u, x in g[u0]:\n            if x == 0 and v[u] == 0:\n                q.append(u)\n                v[u] = 1\n                comps[-1].append(u)\n\nans = n**k\n\nfor comp in comps:\n    ans -= len(comp)**k\nprint(ans%((10**9) + 7))", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/21 23:56\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Edgy Trees.py\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.root[x] == x:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.root[y] = x\n        self.size[x] += self.size[y]\n\n\ndef pow_mod(a, b, p):\n    ret = 1\n    while b > 0:\n        if b % 2 == 1:\n            ret = ret * a % p\n        b //= 2\n        a = a * a % p\n    return ret\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n\n    union_find = UnionFind(n + 1)\n    for _ in range(n - 1):\n        u, v, c = list(map(int, input().split()))\n        if c == 0:\n            union_find.union(u, v)\n\n    p = int(1e9 + 7)\n    ret = pow_mod(n, k, p)\n    used = set()\n    for i in range(1, n + 1):\n        x = union_find.find(i)\n        if x not in used:\n            ret = (ret + p - pow_mod(union_find.size[x], k, p)) % p\n            used.add(x)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n    # print(pow_mod(4, 4, 3))\n\n__starting_point()", "MOD = 1000000007\nn, k = list(map(int, input().split()))\nch = [set() for _ in range(n + 1)]\nfor _2 in range(n - 1):\n    u, v, x = list(map(int, input().split()))\n    if x == 0:\n        ch[u].add(v)\n        ch[v].add(u)\nres = 0\nroot = [True] * (n + 1)\nfor i in range(1, n + 1):\n    if root[i]:\n        cur = 1\n        stack = [i]\n        while stack:\n            u = stack.pop()\n            for v in ch[u]:\n                ch[v].remove(u)\n                cur += 1\n                root[v] = False\n                stack.append(v)\n        res = (res + pow(cur, k)) % MOD\nres = (MOD + pow(n, k) - res) % MOD\nprint(res)\n", "from collections import defaultdict as dd\nmod= pow(10,9)+7\n\"\"\"\ndef dfs_visit(V,adj,s,c):\n    for v in adj[s]:\n        if v not in parent:\n            parent[v]=s\n            c=c+1\n            dfs_visit(V,adj,v,c)\n    return(c)\n            \ndef dfs(V,adj):\n    ans=[]\n    for s in V:\n        if s not in parent:\n            parent[s]=None\n            c=dfs_visit(V,adj,s,1)\n            ans.append(c)\n    return(ans)\n\"\"\"\ndef bfs(s,adj):\n    nonlocal parent\n    t=1\n    #print(\"df\",s)\n    frontier=[s]\n    while frontier:\n        nex=[]\n        for u in frontier:\n            for v in adj[u]:\n                if v not in parent:\n                    #print(v)\n                    t+=1\n                    parent.add(v)\n                    nex.append(v)\n        frontier=nex\n    return(t)\n\nadj=dd(list)\nn,k=[int(i) for i in input().split(' ')]\nfor ii in range(n-1):\n    x,y,h=[int(i) for i in input().split(' ')]\n    if h==0:\n        adj[x].append(y)\n        adj[y].append(x)\n\nV=[i+1 for i in range(n)]  \nparent=set()\n\nfk=[]\nfor i in V:\n    if i not in parent:\n        parent.add(i)\n        tr=bfs(i,adj)\n        #print(i,tr)\n        fk.append(tr)\n#print(fk)\nans=pow(n,k,mod)\nfor i in fk:\n    ans=(ans-pow(i,k,mod))%mod\nprint(ans%mod)\n", "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return (n * factorial(n-1))%(10**9+7)\n\n\n\nn, k = [int(i) for i  in input().split()]\ns = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b,c = [int(i) for i in input().split()]\n    if c == 0:\n        s[a-1].append(b-1)\n        s[b - 1].append(a - 1)\nused = [False]*n\n\nans = pow(n, k, 10**9+7)\nfor i in range(n):\n    if not used[i]:\n        comp = []\n        used[i] = True\n        comp.append(i)\n        c=0\n        while c < len(comp):\n            for h in s[comp[c]]:\n                if not used[h]:\n                    used[h] = True\n                    comp.append(h)\n            c+=1\n        ans = (ans-pow(len(comp), k, 10**9+7))%(10**9+7)\nprint(ans)", "from collections import defaultdict,deque\nMOD = (10**9)+7\ndef bfs(v):\n    q.append(v)\n    visited[v]=True\n    while q:\n        s=q.popleft()\n        b.append(v)\n        for i in g[s]:\n            if not visited[i[0]] and i[1]==0:\n                q.append(i[0])\n                visited[i[0]]=True\n    \nn,k=list(map(int,input().split()))\ng=defaultdict(list)\nfor _ in range(n-1):\n    x,y,c=list(map(int,input().split()))\n    g[x].append((y,c))\n    g[y].append((x,c))\nvisited=[False]*(n+1)\ncount=0;ans=pow(n,k,MOD)\nq=deque()\nfor i in range(1,n+1):\n    b=[]\n    if visited[i]==False:\n        bfs(i)\n    #print(b)\n    f =len(b) \n    count=(count+pow(f,k,MOD))%MOD\n\nans=(ans-count)%MOD\nprint(ans)\n\n", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\nimport threading\nthreading.stack_size(67108864)\n \ndef main():\n    n, k = list(map(int, input().split()))\n    uw = []\n    ubw = []\n    for i in range(n):\n        uw.append([])\n        ubw.append([])\n    for i in range(n - 1):\n        a, b, v = list(map(int, input().split()))\n        ubw[a - 1].append(b - 1)\n        ubw[b - 1].append(a - 1)\n        if v == 0:\n            uw[a - 1].append(b - 1)\n            uw[b - 1].append(a - 1)\n    def dfs(v):\n        use[v] = 1\n        com[c] += 1\n        for i in uw[v]:\n            if not use[i]:\n                dfs(i)\n    use = [0] * n\n    c = 0\n    com = []\n    for i in range(n):\n        if not use[i]:\n            com.append(0)\n            dfs(i)\n            c += 1\n    q = 10 ** 9 + 7\n    ans = pow(n, k, q)\n    for i in range(c):\n        ans -= pow(com[i], k, q)\n        ans %= q\n    print(ans)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()\n\n", "from collections import deque\nmod = 10**9 + 7\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.edges = {}\n\n    def add_edge(self, node, color):\n        self.edges[node] = color\n\n\nn, k = list(map(int, input().split()))\ntree = []\nfor i in range(1, n+1):\n    tree.append(TreeNode(i))\n\nfor _ in range(n-1):\n    u, v, x = list(map(int, input().split()))\n    tree[u-1].add_edge(v, x)\n    tree[v-1].add_edge(u, x)\n\nvisited = set()\ntotal = 0\n\nfor node in range(1, n+1):\n    if node in visited:\n        continue\n\n    queue = deque()\n    queue.append(node)\n    visited.add(node)\n    red_vertexes = 1\n    while queue:\n\n        vertex = queue.popleft()\n\n        for (e, c) in list(tree[vertex-1].edges.items()):\n            if c == 0 and e not in visited:\n                queue.append(e)\n                red_vertexes = red_vertexes + 1\n                visited.add(e)\n\n    total = (total + pow(red_vertexes, k, mod)) % mod\n\ntotal = (pow(n, k, mod) - total) % mod\nprint(total)\n", "N, k = map(int, input().split())\nMOD = 10 ** 9 + 7\ngr = [-1] * N\nG = [[] for i in range(N)]\nfor i in range(N - 1):\n    a, b, c = map(int, input().split())\n    if c == 0:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\ng = 0\nfor i in range(N):\n    if gr[i] == -1:\n        que = [i]\n        while que:\n            j = que.pop()\n            gr[j] = g\n            for w in G[j]:\n                if gr[w] == -1:\n                    que.append(w)\n        g += 1\n\nnum = 0\nans = (N ** k) % MOD\nd = [0] * N\nfor i in range(N):\n    if gr[i] != -1:\n        d[gr[i]] += 1\n\nfor i in range(N):\n    num += d[i] ** k\n    num %= MOD\n\nprint((ans - num + MOD) % MOD)"]
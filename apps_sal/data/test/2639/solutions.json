["class Solution:\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         def dfs(idx, path):\n             subsets.append(path)\n             \n             for i in range(idx, len(nums)):\n                 if i > idx and nums[i] == nums[i-1]:\n                     continue\n                 dfs(i + 1, path + [nums[i]])     \n         nums.sort()\n         subsets = []\n         dfs(0, [])\n         \n         return subsets\n         \n         \n         \n         \n             \n             \n                 \n         \n             \n                 \n", "class Solution:\n     def subsets(self, nums):\n         if len(nums) == 0:\n             return [[]]\n         ret = []\n         for i, n in enumerate(nums):\n             if i > 0 and n == nums[i - 1]:\n                 continue\n             for s in self.subsets(nums[i + 1:]):\n                 ret.append([n] + s)\n         return [[]] + ret\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         nums.sort()\n         return self.subsets(nums)", "class Solution:\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         result = []\n         res = []\n         \n         self.df(nums, 0, result, res)\n         return res\n     \n     def df(self, nums, idx, result, res):\n         if idx > len(nums):\n             return\n         if result not in res:\n             res.append(result)\n         \n         for i in range(idx, len(nums)):\n             self.df(nums, i+1, sorted(result + [nums[i]]), res)", "class Solution:\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         def dfs(depth, start, cur):\n             if cur not in res:\n                 res.append(cur)\n             if depth == len(nums):\n                 return \n             for i in range(start, len(nums)):\n                 dfs(depth + 1, i + 1, cur + [nums[i]])\n         \n         nums.sort()\n         res = []\n         dfs(0, 0, [])\n         return list(res)", "class Solution:\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         \n         def backtrack(nums, start, tmp, res):\n             res.append(tmp[:])\n             \n             for i in range(start, len(nums)):\n                 if i>start and nums[i] == nums[i-1]:\n                     continue\n                 else:\n                     tmp.append(nums[i])\n                     backtrack(nums, i+1, tmp, res)\n                     del tmp[-1]\n                     \n         res = list()\n         backtrack(sorted(nums), 0, [], res)\n         return res \n", "class Solution:\n     def subsetsWithDup(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         \"\"\"\n         nums = sorted(nums)\n         res = [[]]\n         self._helpFun(nums,  res, [])\n         return(res)\n     \n     def _helpFun(self, nums, res, curr):\n         if not nums:\n             if curr not in res:\n                 res.append(curr)\n             return\n         \n         for i in range(len(nums)):\n             newCurr = curr + [nums[i]]\n             if newCurr not in res:\n                 res.append(newCurr)\n             \n             self._helpFun(nums[i+1:], res, newCurr )"]
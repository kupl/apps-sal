["from collections import deque\nfrom copy import deepcopy\n\nh,w = map(int,input().split())\ns = [list(input()) for i in range(h)]\nt = ((0,1),(1,0),(-1,0),(0,-1))\nm = 0\nfor sy in range(h):\n    for sx in range(w):\n        if s[sy][sx] == \"#\":\n            continue\n        ss = deepcopy(s)\n        ss[sy][sx] = \"#\"\n        q = deque([(0,sy,sx)])\n        max_cost = 0\n        my,mx = 0,0\n        while(q):\n            cost,y,x = q.popleft()\n            max_cost = max(max_cost,cost)\n            cost += 1\n            for i,j in t:\n                ny = y+i\n                nx = x+j\n                if 0 <= ny < h and 0 <= nx < w:\n                    if ss[ny][nx] == \".\":\n                        q.append((cost,ny,nx))\n                        ss[ny][nx] = \"#\"\n        m = max(m,max_cost)\nprint(m)", "from collections import deque\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\ndef LSH(h):\n    return [input() for _ in range(h)]\n\n\nH, W = LI()\nFi = LSH(H)\nmove = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nans = 0\nfor sh in range(H):  # \u30b9\u30bf\u30fc\u30c8\u4f4d\u7f6e\u5168\u90e8\u8a66\u3057\u307e\u3059\n    for sw in range(W):\n        if Fi[sh][sw] == \"#\":\n            continue\n        d = deque()\n        d.append([sh, sw])\n        looked = [[0 for i in range(W)]for j in range(H)]\n        looked[sh][sw] = 1\n        while d:\n            h, w = d.popleft()\n            for i in move:\n                a = h+i[0]\n                b = w+i[1]\n                if not(0 <= a < H) or not(0 <= b < W) or Fi[a][b] == \"#\" or looked[a][b] != 0:\n                    continue\n                d.append([a, b])\n                looked[a][b] = looked[h][w]+1\n            if len(d) == 0:\n                ans = max(ans, looked[h][w]-1)\nprint(ans)\n", "import queue\nH, W = map(int, input().split())\nS = [ list(input()) for _ in range(H)]\nans = 0\nfor sx in range(H):\n    for sy in range(W):\n        if S[sx][sy] == '#': continue\n        \n        D = [[float('inf') for _ in range(W)] for _ in range(H)]\n        D[sx][sy] = 0\n        q = queue.Queue()\n        q.put((sx, sy))\n        \n        vs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        while not q.empty():\n            x, y = q.get()\n            for dx, dy in vs:\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < H and 0 <= ny < W and S[nx][ny] != '#' and D[nx][ny] == float('inf'):\n                    q.put((nx, ny))\n                    D[nx][ny] = D[x][y] + 1\n\n        for gx in range(H):\n            for gy in range(W):\n                if S[gx][gy] == '#': continue\n                ans = max(ans, D[gx][gy])\n\nprint(ans)", "import queue\nimport copy\nq = queue.Queue()\nh, w = list(map(int, input().split()))\na = [list('#'+input()+'#') for _ in range(h)]\na = [['#']*(w+2)]+a+[['#']*(w+2)]\na1 = copy.deepcopy(a)\nans = []\n        \nfor i in range(1, h+1):\n    for j in range(1, w+1):\n        a = copy.deepcopy(a1)\n        if a[i][j] == '#':\n            continue        \n        q.put([i, j, 0])\n        while not q.empty():\n            now = q.get()\n            \n            if a[now[0]][now[1]] == '.':\n                ans.append(now[2])\n                a[now[0]][now[1]] = '#'\n            else:\n                continue\n                \n            if a[now[0]+1][now[1]] != '#':\n                q.put([now[0]+1, now[1], now[2]+1])\n            if a[now[0]-1][now[1]] != '#':\n                q.put([now[0]-1, now[1], now[2]+1])\n            if a[now[0]][now[1]+1] != '#':\n                q.put([now[0], now[1]+1, now[2]+1])\n            if a[now[0]][now[1]-1] != '#':\n                q.put([now[0], now[1]-1, now[2]+1])\n        a1[i][j] == '#'\nprint((max(ans)))\n", "#!/usr/bin/env python3\nfrom collections import deque\n\nh, w = list(map(int, input().split()))\nmaze = [input() for _ in range(h)]\nans = 0\n\n\ndef bfs(sx, sy):\n    dx = (1, 0, -1, 0)\n    dy = (0, 1, 0, -1)\n    d = [[-1] * w for _ in range(h)]\n    q = deque([])\n\n    q.append((sx, sy))\n    d[sx][sy] = 0\n    ans = 0\n\n    while q:\n        x, y = q.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < h and 0 <= ny < w and maze[nx][ny] != \"#\" and d[nx][\n                    ny] == -1:\n                q.append((nx, ny))\n                d[nx][ny] = d[x][y] + 1\n                ans = max(ans, d[nx][ny])\n    return ans\n\n\nfor i in range(h):\n    for j in range(w):\n        if maze[i][j] == \".\":\n            ans = max(ans, bfs(i, j))\nprint(ans)\n", "H,W=map(int,input().split())\nS=[list(input())for _ in range(H)]\n\nfrom collections import deque\ndef bfs(h,w,sy,sx,S):\n    maze=[[10**9]*(W)for _ in range(H)]\n    maze[sy-1][sx-1]=0\n    que=deque([[sy-1,sx-1]])\n    count=0\n    while que:\n        y,x=que.popleft()\n        for i,j in [(1,0),(0,1),(-1,0),(0,-1)]:\n            nexty,nextx=y+i,x+j\n            if 0<=nexty<h and 0<=nextx<w:\n                dist1=S[nexty][nextx]\n                dist2=maze[nexty][nextx]\n            else:\n                continue\n            if dist1!='#':\n                if dist2>maze[y][x]+1:\n                    maze[nexty][nextx]=maze[y][x]+1\n                    count=max(count,maze[nexty][nextx])\n                    que.append([nexty,nextx])\n    return count\n\nans=0\nfor sy in range(H):\n    for sx in range(W):\n        if S[sy][sx]=='.':\n            now=bfs(H,W,sy+1,sx+1,S)\n            ans=max(ans,now)\n\nprint(ans)", "from collections import deque\nimport sys\nimport copy\n\nN_MAX = 200000 + 5\nINF = 10**9 + 7\nsys.setrecursionlimit(N_MAX)\nMOD = 10**9 + 7\n\n\n### BFS ###\n\nnextH = [0, 1, 0, -1]\nnextW = [1, 0, -1, 0]\n\n\ndef bfs(u, S):\n\n    S[u[0]][u[1]] = 0  # state \u3092\u5909\u66f4\n\n    q = deque()\n    q.append(u)\n    m = 0\n    while q:\n        u = q.popleft()\n        for h, w in zip(nextH, nextW):\n            h += u[0]\n            w += u[1]\n            if not (0 <= h < len(S) and 0 <= w < len(S[0])):\n                continue\n\n            if S[h][w] == '.':  # state \u3092\u78ba\u8a8d\n                S[h][w] = S[u[0]][u[1]] + 1  # state \u3092\u5909\u66f4\n                m = max(m, S[h][w])\n                q.append((h, w))\n    \n    return m\n\n\ndef main():\n\n    H, W = list(map(int, sys.stdin.readline().rstrip().split()))\n    S = []\n    for _ in range(H):\n        S.append([x for x in sys.stdin.readline().rstrip()])\n\n    # print(S)\n\n    m = 0\n    for h in range(H):\n        for w in range(W):\n            D = copy.deepcopy(S)\n            if S[h][w] == '.':\n                m = max(m, bfs((h, w), D))\n\n    print(m)\n\n\nmain()\n", "from collections import deque\n\ndef getdistance(row,col,sw,h,w):\n    maze = deque([[row,col,0]])\n    marker = [[0]*w for _ in range(h)]\n    marker[row][col] = 1\n    while len(maze)!=0:\n        r, c, d = maze.popleft()\n        if r!=0:\n            if sw[r-1][c]!=\"#\" and marker[r-1][c] != 1:\n                marker[r-1][c] = 1\n                maze.append([r-1,c,d+1])\n        if r!=h-1:\n            if sw[r+1][c]!=\"#\" and marker[r+1][c] != 1:\n                marker[r+1][c] = 1\n                maze.append([r+1,c,d+1])\n        if c!=w-1:\n            if sw[r][c+1]!=\"#\" and marker[r][c+1] != 1:\n                marker[r][c+1] = 1\n                maze.append([r,c+1,d+1])\n        if c!=0:\n            if sw[r][c-1]!=\"#\" and marker[r][c-1] != 1:\n                marker[r][c-1] = 1\n                maze.append([r,c-1,d+1])\n    return d\nh, w = map(int, input().split())\nsw = [input() for _ in range(h)]\nans = 0\nfor row in range(h):\n    for col in range(w):\n        if sw[row][col]==\"#\":\n            continue\n        ans = max(ans,getdistance(row,col,sw,h,w))\nprint(ans)", "from collections import deque\n\nH,W=list(map(int,input().split()))\nS=[[c=='#' for c in input()] for _ in range(H)]\n\ndef bfs(i,j):\n    if S[i][j]:\n        return 0\n    que=deque()\n    que.append((i,j))\n    vis=[row[:] for row in S]\n    vis[i][j]=1\n    ans=-1\n    while que:\n        ans+=1\n        for _ in range(len(que)):\n            i,j=que.popleft()\n            for ni,nj in nbs(i,j):\n                if not vis[ni][nj]:\n                    que.append((ni,nj))\n                    vis[ni][nj]=1\n    return ans\n\ndef nbs(i,j):\n    for ni,nj in (i-1,j),(i,j+1),(i+1,j),(i,j-1):\n        if 0<=ni<H and 0<=nj<W:\n            yield ni,nj\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        ans=max(ans,bfs(i,j))\n\nprint(ans)\n", "import sys\nfrom collections import deque\n\nH,W=list(map(int,input().split()))\nS=list(sys.stdin)\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j]=='#':\n            continue\n        dist=[[-1]*W for _ in range(H)]\n        dist[i][j]=0\n        que=deque()\n        que.append((i,j))\n        while que:\n            i,j=que.popleft()\n            ans=max(ans,dist[i][j])\n            for ni,nj in (i-1,j),(i,j+1),(i+1,j),(i,j-1):\n                if not (0<=ni<H and 0<=nj<W):\n                    continue\n                if S[ni][nj]=='#' or dist[ni][nj]!=-1:\n                    continue\n                dist[ni][nj]=dist[i][j]+1\n                que.append((ni,nj))\n\nprint(ans)\n", "#!/usr/bin/env python3\ndef main():\n    from collections import deque\n    import numpy as np\n\n    H, W = list(map(int, input().split()))\n    S = [list(input()) for _ in range(H)]\n\n    move = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    seen = [[False] * W for _ in range(H)]\n    ans = 0\n    for sh in range(H):\n        for sw in range(W):\n            if S[sh][sw] == '#' or seen[sh][sw]:\n                continue\n            seen[sh][sw] = True\n            queue = deque([(sh, sw)])\n            # distance = np.zeros((H, W), dtype=np.int16)\n            distance = np.full((H, W), -1, dtype=np.int16)\n            distance[sh, sw] = 0\n            while queue:\n                h, w = queue.popleft()\n                for dh, dw in move:\n                    nh = h + dh\n                    nw = w + dw\n                    if (1\n                            and 0 <= nh < H\n                            and 0 <= nw < W\n                            and S[nh][nw] == '.'\n                            and distance[nh][nw] == -1):\n                        distance[nh][nw] = distance[h][w] + 1\n                        queue.append((nh, nw))\n            ans = max(ans, distance.max())\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport copy\n\nH,W=map(int,input().split())\nS=[[x for x in input()] for _ in range(H)]\nstart_list=[]\nlength=[[-1]*W for _ in range(H)]\nans=0\n\nfor i in range(H):\n  for j in range(W):\n    if S[i][j]=='.':\n      start_list.append((i,j))\n\nfor start in start_list:\n  h,w=start\n  d=deque([(h,w)])\n  T=copy.deepcopy(S)\n  L=copy.deepcopy(length)\n  L[h][w]=0\n  T[h][w]='#'\n  while d:\n    h,w=d.popleft()\n    \n    if h-1>=0 and T[h-1][w]=='.':\n      d.append((h-1,w))\n      L[h-1][w]=L[h][w]+1\n      T[h-1][w]='#'\n      ans=max(ans,L[h-1][w])\n      \n    if h+1<=H-1 and T[h+1][w]=='.':\n      d.append((h+1,w))\n      L[h+1][w]=L[h][w]+1\n      T[h+1][w]='#'\n      ans=max(ans,L[h+1][w])\n      \n    if w-1>=0 and T[h][w-1]=='.':\n      d.append((h,w-1))\n      L[h][w-1]=L[h][w]+1\n      T[h][w-1]='#'\n      ans=max(ans,L[h][w-1])\n      \n    if w+1<=W-1 and T[h][w+1]=='.':\n      d.append((h,w+1))\n      L[h][w+1]=L[h][w]+1\n      T[h][w+1]='#'\n      ans=max(ans,L[h][w+1])\n\nprint(ans)", "from collections import deque\nfrom itertools import product\n\n\nH, W = list(map(int, input().split()))\nS = [input() for _ in range(H)]\nroute = [[[[400 if S[si][sj]==S[ei][ej]==\".\" else -1 for ej in range(W)]for ei in range(H)]for sj in range(W)]for si in range(H)]\n\nfor i, j in product(list(range(H)), list(range(W))):\n    if S[i][j] == \".\":\n        q = deque([[i, j, i, j]])\n        break\nwhile q:\n    si, sj, ei, ej = q.pop()\n    if (si, sj) == (ei, ej):\n        route[si][sj][ei][ej] = 0\n    d = route[si][sj][ei][ej]\n    for p in [-1, 1]:\n        if 0 <= si+p < H and route[si+p][sj][ei][ej] > d+1:\n            route[si+p][sj][ei][ej] = d+1\n            q.appendleft([si+p, sj, ei, ej])\n        if 0 <= sj+p < W and route[si][sj+p][ei][ej] > d+1:\n            route[si][sj+p][ei][ej] = d+1\n            q.appendleft([si, sj+p, ei, ej])\n        if 0 <= ei+p < H and route[si][sj][ei+p][ej] > d+1:\n            route[si][sj][ei+p][ej] = d+1\n            q.appendleft([si, sj, ei+p, ej])\n        if 0 <= ej+p < W and route[si][sj][ei][ej+p] > d+1:\n            route[si][sj][ei][ej+p] = d+1\n            q.appendleft([si, sj, ei, ej+p])\n\nprint((max(route[si][sj][ei][ej] for si, sj, ei, ej in product(list(range(H)), list(range(W)), list(range(H)), list(range(W))))))\n", "# import sys\n# sys.setrecursionlimit(10 ** 9)\n\n# H, W = map(int, input().split())\n# L = []\n# for _ in range(H):\n#     s = input()\n#     a = []\n#     for i in range(len(s)):\n#         a.append(s[i])\n#     L.append(a)\n\n# dx = [-1, 0, 1, 0]\n# dy = [0, -1, 0, 1]\n\n\n# def dfs(h, w, dp, ans, count):\n#     if L[h][w] == '#':\n#         return ans\n#     elif (L[h][w] == '.' and dp[h][w] == -1):\n#         dp[h][w] = 0\n\n#     for i in range(4):\n#         if w + dx[i] >= 0 and w + dx[i] < W and h + \\\n#                 dy[i] >= 0 and h + dy[i] < H:\n#             if L[h + dy[i]][w + dx[i]] == '.' and dp[h + dy[i]][w + dx[i]] == -1:\n#                 count += 1\n#                 ans[h + dy[i]][w + dx[i]\n#                                ] = min(ans[h + dy[i]][w + dx[i]], count)\n#                 return dfs(h + dy[i], w + dx[i], dp, ans, count)\n#             elif L[h + dy[i]][w + dx[i]] == '#':\n#                 continue\n\n#     return ans\n\n\n# max_count = 0\n# ans = [[100000000] * W for _ in range(H)]\n# for i in range(H):\n#     for j in range(W):\n#         dp = [[-1] * W for _ in range(H)]\n#         count = dfs(i, j, dp, ans, 0)\n#         print(count)\n#         # max_count = max(max_count, count)\n\n# print(max_count)\n\n# \u5e45\u512a\u5148\u63a2\u7d22\nfrom collections import deque\nH, W = list(map(int, input().split()))\nL = []\nfor _ in range(H):\n    s = input()\n    a = []\n    for i in range(len(s)):\n        a.append(s[i])\n    L.append(a)\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\n\n\ndef bfs(x, y):\n    dp = [[10000000] * W for _ in range(H)]\n    dp[y][x] = 0\n    if L[y][x] == '#':\n        return dp\n    else:\n        d = deque()\n        d.append([x, y])\n        while len(d) > 0:\n            s = d.popleft()\n            for i in range(4):\n                if (s[1] +\n                    dy[i] >= 0 and s[1] +\n                    dy[i] < H and s[0] +\n                    dx[i] >= 0 and s[0] +\n                        dx[i] < W):\n                    if L[s[1] +\n                         dy[i]][s[0] +\n                                dx[i]] == '.' and dp[s[1] +\n                                                     dy[i]][s[0] +\n                                                            dx[i]] == 10000000:\n                        d.append([s[0] + dx[i], s[1] + dy[i]])\n                        dp[s[1] + dy[i]][s[0] + dx[i]] = dp[s[1]][s[0]] + 1\n\n        return dp\n\n\nmax_num = 0\nfor i in range(H):\n    for j in range(W):\n        dp = bfs(j, i)\n        for k in dp:\n            for p in k:\n                if (p == 10000000):\n                    continue\n                max_num = max(max_num, p)\nprint(max_num)\n", "import heapq\n\n\ndef abc151d_maze_master():\n    h, w = map(int, input().split())\n    s = []\n    max_val = 0\n    for i in range(h):\n        s.append(input())\n    for hi in range(h):\n        for wi in range(w):\n            if s[hi][wi] == '#': continue\n            flg = [[-1] * w for _ in range(h)]\n            flg[hi][wi] = 0\n            q = [(0, hi, wi)]\n            heapq.heapify(q)\n            while len(q) > 0:\n                d, hj, wj = heapq.heappop(q)\n                for dh, dw in zip([0, 0, 1, -1], [1, -1, 0, 0]):\n                    if 0 <= hj + dh < h and 0 <= wj + dw < w and s[hj + dh][wj + dw] != '#' and \\\n                            (flg[hj + dh][wj + dw] == -1 or flg[hj + dh][wj + dw] > flg[hj][wj] + 1):\n                        heapq.heappush(q, (d + 1, hj + dh, wj + dw))\n                        flg[hj + dh][wj + dw] = flg[hj][wj] + 1\n                # print(q)\n            max_val = max(max_val, max([max(v) for v in flg]))\n    print(max_val)\n\n\nabc151d_maze_master()", "from copy import deepcopy\nfrom collections import deque\nh, w = map(int, input().split())\ns = [[\"#\"]*(w+2)] + [[\"#\"]+list(input())+[\"#\"] for i in range(h)] + [[\"#\"]*(w+2)]\nans = 0\nfor i in range(1, h+1):\n    for j in range(1, w+1):\n        t = deepcopy(s)\n        if s[i][j] == \"#\":\n            continue\n        a = deque([[i, j, 0]])\n        while len(a) > 0:\n            x, y, cnt = a.popleft()\n            t[x][y] = \"#\"\n            if t[x-1][y] == \".\":\n                a.append([x-1, y, cnt+1])\n                t[x-1][y] = \"#\"\n            if t[x+1][y] == \".\":\n                a.append([x+1, y, cnt+1])\n                t[x+1][y] = \"#\"\n            if t[x][y-1] == \".\":\n                a.append([x, y-1, cnt+1])\n                t[x][y-1] = \"#\"\n            if t[x][y+1] == \".\":\n                a.append([x, y+1, cnt+1])\n                t[x][y+1] = \"#\"\n        ans = max(ans, cnt)\nprint(ans)", "from collections import deque\nh,w=list(map(int,input().split()))\ns=[list(input()) for _ in range(h)]\nans=0\nfor i in range(h):\n    for j in range(w):\n        if s[i][j]==\".\":\n            cnt=[[-1]*w for _ in range(h)]\n            cnt[i][j]=0\n            queue=deque()\n            queue.append([i,j])\n            for k in range(100*h*w):\n                if len(queue)==0:\n                    break\n                num=queue.popleft()\n                num1=num[0]\n                num2=num[1]\n                if num1!=0:\n                    if s[num1-1][num2]==\".\" and cnt[num1-1][num2]==-1:\n                        cnt[num1-1][num2]=cnt[num1][num2]+1\n                        queue.append([num1-1,num2])\n                if num2!=0:\n                    if s[num1][num2-1]==\".\" and cnt[num1][num2-1]==-1:\n                        cnt[num1][num2-1]=cnt[num1][num2]+1\n                        queue.append([num1,num2-1])\n                if num1!=h-1:\n                    if s[num1+1][num2]==\".\" and cnt[num1+1][num2]==-1:\n                        cnt[num1+1][num2]=cnt[num1][num2]+1\n                        queue.append([num1+1,num2])\n                if num2!=w-1:\n                    if s[num1][num2+1]==\".\" and cnt[num1][num2+1]==-1:\n                        cnt[num1][num2+1]=cnt[num1][num2]+1\n                        queue.append([num1,num2+1])\n            cnt2=0\n            for k in range(h):\n                cnt2=max(cnt2,max(cnt[k]))\n            ans=max(ans,cnt2)\nprint(ans)\n", "from copy import deepcopy\nfrom collections import deque\nfrom itertools import product\nimport numpy as np\nclass Grid:\n    def __init__(self, grid, w=0, h=0, function=lambda x: x):\n        self.w = w = w if w else len(grid[0])\n        self.h = h = h if h else len(grid)\n        dtype = type(function(grid[0][0]))\n        self.grid = np.empty((h, w), dtype=dtype)\n        for i, row in zip(range(h), grid):\n            for j, val in zip(range(w), row):\n                self.grid[i][j] = function(val)\n    \n    def is_valid_x(self, x):\n        return 0 <= x < self.w\n    def is_valid_y(self, y):\n        return 0 <= y < self.h\n    def is_valid_xy(self, x, y):\n        return self.is_valid_x(x) and self.is_valid_y(y) \n    \n    def __iter__(self):\n        return iter(self.grid)\n    def __repr__(self):\n        return '\\n'.join([' '.join(map(str, row)) for row in self.grid]) + '\\n'\n    def __getitem__(self, x):\n        return self.grid[x]\n    def __setitem__(self, x, val):\n        self.grid[x] = val\n\ndef longest_path(grid, root):\n    def restore_route(prev, p):\n        A = deque()\n        while p:\n            A.appendleft(p)\n            p = prev[p]\n        return list(A)\n    \n    x, y = root\n    prev = {root:None}\n    grid[y, x] = '!'\n    queue = deque([root])\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in zip([1, 0, -1, 0], [0, 1, 0, -1]):\n            nx, ny = x+dx, y+dy\n            if grid.is_valid_xy(nx, ny) and grid[ny, nx] in 'sg.':\n                prev[nx, ny] = x, y\n                queue.append((nx, ny))\n                grid[ny, nx] = '!'\n    return restore_route(prev, (x, y))\n\nh, w = map(int, input().split())\ngrid = Grid([input() for s in range(h)])\nans = 0\nfor y, x in product(range(h), range(w)):\n    if grid[y, x] == '.':\n        path = longest_path(deepcopy(grid), (x, y))\n        ans = max(ans, len(path)-1)\nprint(ans)", "h,w = map(int,input().split())\nC = [list(input()) for i in range(h)]\n\nqueue = []\nvisited = [] \nvisited = [[0 for i in range(w)] for i in range(h)]\nans = 0\n\nfor i in range(h):\n    for j in range(w):\n        if C[i][j] == '.':\n            queue.append([i,j])\n            visited[i][j] = 1\n\n            dy_dx = [[1,0],[0,1],[-1,0],[0,-1]]\n\n            while len(queue) > 0:\n                now = queue.pop(0)\n                for k in range(4):\n                    y = now[0]+dy_dx[k][0]\n                    x = now[1]+dy_dx[k][1]\n                    if 0 <= y < h and 0 <= x < w:\n                        if C[y][x] != '#' and visited[y][x] == 0:\n                            visited[y][x] = visited[now[0]][now[1]]+1 #\u79fb\u52d5\u56de\u6570\u306e\u30ab\u30a6\u30f3\u30c8\n                            queue.append([y,x])\n                    \n        for l in range(h):\n            for m in range(w):\n                ans = max(ans,visited[l][m])\n            \n        queue = []\n        visited = [[0 for i in range(w)] for i in range(h)]              \n        \nprint(ans-1)", "import queue\n\ndef bfs(maze,h,w,sy,sx):\n    dist=[[-1 for _ in range(w)] for _ in range(h)]\n    q=queue.deque([[sy,sx]])\n    dist[sy][sx]=0\n    while q:\n        y,x=q.popleft()\n        for dy,dx in d:\n            ny,nx=y+dy,x+dx\n            if 0<=ny<h and 0<=nx<w and dist[ny][nx]==-1 and maze[ny][nx]!='#':\n                dist[ny][nx]=dist[y][x]+1\n                q.append([ny,nx])\n    return max([max(i) for i in dist])\n\nh,w=map(int,input().split())\na=[input() for _ in range(h)]\nd=[[1,0],[0,1],[-1,0],[0,-1]]\nans=0\nfor sy in range(h):\n    for sx in range(w):\n        if a[sy][sx]!='#':\n            ans=max(ans,bfs(a,h,w,sy,sx))\nprint(ans)", "import queue\nimport numpy as np\n\nH, W = list(map(int, input().split()))\nmaze = [list(input()) for _ in range(H)]\ndir4 = [[-1,0],[1,0],[0,-1],[0,1]]\n\n\ndef solveMaze(s):\n    q = queue.Queue()\n    q.put([s[0],s[1],0])\n    times = [[999999999 for j in range(W)] for i in range(H)]\n    tmpAns = 0\n    times[s[0]][s[1]] = 0\n    while not q.empty():\n        now = q.get()\n        tmpAns = max(tmpAns, now[2])\n        for i in range(4):\n            nextH = now[0] + int(dir4[i][0])\n            nextW = now[1] + int(dir4[i][1])\n            nextTime = now[2] + 1\n\n            if nextH < 0 or nextH >= H or nextW < 0 or nextW >=W or maze[nextH][nextW] == \"#\" or times[nextH][nextW] <= nextTime:\n                continue\n            else:\n                times[nextH][nextW] = nextTime\n                q.put([nextH, nextW, nextTime])\n\n    return tmpAns\n\n\nans = 0\n\nfor sH in range(H):\n    for sW in range(W):\n        if maze[sH][sW] == \".\":\n            ans = max(ans, solveMaze([sH, sW]))\n\nprint(ans)\n\n\n\n\n\n", "import sys\nfrom collections import deque\n\nH,W=list(map(int,input().split()))\nS=list(sys.stdin)\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j]=='#':\n            continue\n        dist=[[-1]*W for _ in range(H)]\n        dist[i][j]=0\n        que=deque()\n        que.append((i,j))\n        while que:\n            i,j=que.popleft()\n            ans=max(ans,dist[i][j])\n            for ni,nj in (i-1,j),(i,j+1),(i+1,j),(i,j-1):\n                if 0<=ni<H and 0<=nj<W and S[ni][nj]=='.' and dist[ni][nj]==-1:\n                    dist[ni][nj]=dist[i][j]+1\n                    que.append((ni,nj))\n\nprint(ans)\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nfrom collections import deque\n\n\n# In[2]:\n\n\nH,W = list(map(int, input().split()))\nS = []\nfor _ in range(H):\n    S.append(input())\n\n\n# In[3]:\n\n\ndef bfs(sx,sy):\n    dx = [1,0,-1,0]\n    dy = [0,1,0,-1]\n    d = [[-1]*W for _ in range(H)]\n    q = deque([])\n    q.append([sx,sy])\n    d[sx][sy] = 0\n    ans = 0\n    while q:\n        x,y = q.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < H and 0 <= ny < W and S[nx][ny] != \"#\" and d[nx][ny] == -1:\n                q.append([nx,ny])\n                d[nx][ny] = d[x][y] + 1\n                ans = max(ans,d[nx][ny])\n    return ans\n\n\n# In[5]:\n\n\nans = 0\nfor sh in range(H):\n    if \".\" in S[sh]:\n        for sw in range(W):\n            if S[sh][sw] == \".\":\n                ans = max(ans,bfs(sh,sw))\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "from copy import deepcopy  \n\nH, W = map(int, input().split())\nS = [list(input()) for i in range(H)]\nans = 0\nqueue = [[1,0],[-1,0],[0,1],[0,-1]]\n\ndef now(n,s):\n    t = []\n    for i in queue:\n        j = n[0] + i[0]\n        k = n[1] + i[1]\n        if 0 <= j < H and 0 <= k < W:\n            if s[j][k] == \".\":\n                t.append([j,k])\n                s[j][k] = \"#\"\n    return [t,s]\n        \n\ndef bfs(trust, a, s):\n    t = []\n    for i in trust:\n        tt, s = now(i,s)\n        t += tt\n    if len(t) == 0:\n        return a\n    else:\n        a = a + 1\n        return bfs(t, a, s)\n\n\nfor i in range(H):\n    for j in range(W):\n        s = deepcopy(S)\n        if S[i][j] == \".\":\n            s[i][j] = \"#\"\n            ans = max(ans, bfs([[i,j]], 0, s))\nprint(ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n  H,W = i_map()\n  S = [input() for i in range(H)]\n  dy_dx=[[1,0],[0,1],[-1,0],[0,-1]]\n  ans = 0\n\n  for sy in range(H):\n        for sx in range(W):\n            if S[sy][sx] == \"#\":\n                continue\n\n            dist=[[-1 for _ in range(W)] for _ in range(H)]\n            dist[sy][sx] = 0\n            d = deque()\n            d.append([sx,sy])\n            while d:\n              nx, ny = d.popleft()\n              for dy,dx in dy_dx:\n                    y,x = ny+dy,nx+dx\n                    if 0<=y<H and 0<=x<W and S[y][x] != \"#\" and dist[y][x] == -1:\n                        dist[y][x] = dist[ny][nx] + 1\n                        d.append([x,y])\n            \n            ans = max(ans, max(list(itertools.chain.from_iterable(dist))))\n  print(ans)\n\n \n \ndef __starting_point():\n    main()\n__starting_point()", "from queue import deque\n\nH, W = map(int,input().split())\nS = list(list(input()) for _ in range(H))\nans = 0\n\nfor h in range(H):\n  for w in range(W):\n    if S[h][w] == \".\":\n      D = [[-1] * W for _ in range(H)]\n      D[h][w] = 0\n      Q = deque()\n      Q.append((h, w))\n      \n      while Q:\n        y, x = Q.popleft()\n\n        for i, j in (1, 0), (-1, 0), (0, 1), (0, -1):\n          y2, x2 = y + i, x + j\n\n          if 0 <= y2 < H and 0 <= x2 < W and S[y2][x2] == \".\" and D[y2][x2] == -1:\n            Q.append((y2, x2))\n            D[y2][x2] = D[y][x] + 1\n\n      for i in range(H): ans = max(ans, max(D[i]))\n\nprint(ans)", "from collections import deque\nimport numpy as np\ndef main():\n    H,W = map(int,input().split())\n    maze = [input() for _ in range(H)]\n\n    ans = 0\n    for x in range(H):\n        for y in range(W):\n            #\u58c1\u304b\u3089\u306f\u30b9\u30bf\u30fc\u30c8\u3067\u304d\u306a\u3044\n            if maze[x][y] == \"#\":\n                continue\n\n            #\u521d\u671f\u5316\n            distance = [[0]*W for _ in range(H)]\n            #start\u4f4d\u7f6e\n            stack = deque([[x,y]])\n\n            while stack:\n                h,w = stack.popleft()\n                for i, j in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                    new_h, new_w = h+i, w+j\n                    if new_h < 0 or new_w < 0 or new_h >= H or new_w >= W:\n                        continue\n                    elif maze[new_h][new_w] != '#' and distance[new_h][new_w] == 0:\n                        distance[new_h][new_w] = distance[h][w] + 1\n                        stack.append([new_h, new_w])\n\n            distance[x][y] = 0\n            ans = max(ans, np.max(distance))\n\n    print(ans)\n\nmain()", "\nimport sys\n\nsys.setrecursionlimit(10 ** 7)\nfrom collections import deque\n\ndef resolve():\n    def bfs(sy, sx):\n        q = deque()\n        q.append((sy, sx))\n        dist = [[-1] * (W + 2) for _ in range(H + 2)]\n        dist[sy][sx] = 0\n        drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n        while q:\n            sy, sx = q.popleft()\n            for dy, dx in drc:\n                ny = dy + sy\n                nx = dx + sx\n                if G[ny][nx] == \".\" and dist[ny][nx] == -1:\n                    dist[ny][nx] = dist[sy][sx] + 1\n                    q.append((ny, nx))\n\n            if not q:\n                return dist[sy][sx]\n\n    H, W = list(map(int, input().split()))\n    G = []\n    G.append([\"#\"] * (W + 2))\n    G += [[\"#\"] + list(input()) + [\"#\"] for _ in range(H)]\n    G.append([\"#\"] * (W + 2))\n\n    ans = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if G[i][j] == \"#\":\n                continue\n            ans = max(ans, bfs(i, j))\n            \n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\nH, W = map(int, input().split())\nmaze = [list(input()) for _ in range(H)]\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\nans = 0\nfor sh in range(H):\n    for sw in range(W):\n        if maze[sh][sw] == \"#\":\n            continue\n        dist = [[-1] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        que = deque([[sh, sw]])\n\n        while que:\n            nh, nw = que.pop()\n            for dh, dw in directions:\n                tmp_h, tmp_w = nh + dh, nw + dw\n                if not ((0 <= tmp_h < H) and (0 <= tmp_w < W)):\n                    continue\n                if maze[tmp_h][tmp_w] == \"#\":\n                    continue\n                if dist[tmp_h][tmp_w] != -1:\n                    continue\n\n                dist[tmp_h][tmp_w] = dist[nh][nw] + 1\n                que.appendleft([tmp_h, tmp_w])\n\n        ans = max(ans, max([max(d) for d in dist]))\n\nprint(ans)", "import copy\nH,W = map(int,input().split())\n\nmaze = []\nmaze.append(['#']*(W+2))\nfor i in range(H):\n  line = input()\n  line_n = ['#']+[line[i] for i in range(W) ]+['#']\n  maze.append(line_n)\nmaze.append(['#']*(W+2))\nfor i in range(H+2):\n  for j in range(W+2):\n    if maze[i][j]=='#':\n      maze[i][j]=9\nmaze_copy = copy.deepcopy(maze)\nglobal_max = 0\nfor i in range(1,H+1):\n  for j in range(1,W+1):\n    maze = copy.deepcopy(maze_copy)\n    sx = i\n    sy = j\n    if maze[i][j]!=9:\n      pos = [[sx,sy,0]]\n      max_depth = 0\n      while len(pos)>0:\n        x,y,depth = pos.pop(0)\n        #print(x,y)\n        if depth >max_depth:\n          max_depth = depth\n        ##\u63a2\u7d22\u7d42\u4e86\u6761\u4ef6\n        maze[x][y] = 0\n        if maze[x-1][y]=='.':\n            pos.append([x-1,y,depth+1])\n            maze[x-1][y] = 0\n        if maze[x][y-1]=='.':\n            pos.append([x,y-1,depth+1])\n            maze[x][y-1] = 0\n        if maze[x+1][y]=='.':\n            pos.append([x+1,y,depth+1])\n            maze[x+1][y] = 0\n        if maze[x][y+1]=='.':\n            pos.append([x,y+1,depth+1])\n            maze[x][y+1] = 0\n      #print(\"max_depth={}\".format(max_depth))\n      if max_depth> global_max:\n        global_max = max_depth\nprint(global_max)", "from collections import *\nfrom copy import *\nH,W = map(int,input().split())\nS = [(W+2)*[\"#\"]]+[[\"#\"]+list(input())+[\"#\"] for h in range(H)]+[(W+2)*[\"#\"]]\nD = [[1,0],[-1,0],[0,1],[0,-1]]\nans = 0\nP = deque([])\nQ = deque([])\n\nfor h in range(1,H+1):\n  for w in range(1,W+1):\n    if S[h][w]==\".\":\n      P+=[[h,w]]\n\nwhile P:\n  T = deepcopy(S)\n  sx,sy = P.popleft()\n  T[sx][sy] = 0\n  Q = deque([[sx,sy]])\n  while Q:\n    x,y = Q.popleft()\n    for dx,dy in D:\n      if T[x+dx][y+dy]==\".\":\n        T[x+dx][y+dy] = T[x][y]+1\n        Q+=[[x+dx,y+dy]]\n        ans = max(ans,T[x+dx][y+dy])\n\nprint(ans)", "from collections import *\nfrom copy import *\nH,W = map(int,input().split())\nS = [(W+2)*[\"#\"]]+[[\"#\"]+list(input())+[\"#\"] for h in range(H)]+[(W+2)*[\"#\"]]\nD = [[1,0],[-1,0],[0,1],[0,-1]]\nans = 0\nP = deque([])\nQ = deque([])\n \nfor h in range(1,H+1):\n  for w in range(1,W+1):\n    if S[h][w]==\".\":\n      P+=[[h,w]]\n \nwhile P:\n  T = deepcopy(S)\n  sx,sy = P.popleft()\n  T[sx][sy] = 0\n  Q = deque([[sx,sy]])\n  while Q:\n    x,y = Q.popleft()\n    for dx,dy in D:\n      if T[x+dx][y+dy]==\".\":\n        T[x+dx][y+dy] = T[x][y]+1\n        Q+=[[x+dx,y+dy]]\n        ans = max(ans,T[x+dx][y+dy])\n \nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Sep  8 18:25:14 2020\n\n@author: liang\n\"\"\"\n\nH, W = map(int, input().split())\n\nfield = [input() for i in range(H)]\n\ndef Init():\n    return [[-1]*W for _ in range(H)]\n\nans = -1\n\nfrom collections import deque\nq = deque()\nadj = ((1,0), (-1,0), (0,1), (0,-1))\ndef BFS(y,x):\n    def isValid(t):\n        if t[0] < 0 or t[0] >= H or t[1] < 0 or t[1] >= W or field[t[0]][t[1]] == \"#\":\n            return False\n        return True\n    d = Init()\n    if field[y][x] == '#':\n        return -1\n    d[y][x] = 0\n    q.append((y,x))\n    res = 0\n    while q:\n        cur = q.popleft()\n        for a in adj:\n            nex = (cur[0]+a[0], cur[1]+a[1])\n            if isValid(nex) and (d[nex[0]][nex[1]]== -1 or d[nex[0]][nex[1]] > d[cur[0]][cur[1]]+1):\n                d[nex[0]][nex[1]] = d[cur[0]][cur[1]]+1\n                #if res < d[nex[0]][nex[1]]:\n                #    res = d[nex[0]][nex[1]]\n                res = max(res, d[nex[0]][nex[1]])\n                q.append(nex)\n    return res\n\nfor i in range(H):\n    for j in range(W):\n        tmp = BFS(i,j)\n        if tmp > ans:\n            ans = tmp\nprint(ans)", "H, W = map(int,input().split())\ns = [list(input()) for j in range(H)]\n\ndef bfs(h, w):\n    checked = [[False for i in range(W)] for j in range(H)]\n    q = [(h, w, 0)] if s[h][w] == '.' else []\n    checked[h][w] = True\n    g_n = 0\n    while q:\n        h_, w_, n = q.pop(0)\n        g_n = max(n, g_n)\n        for i, j in zip([0,0,-1,1],[-1,1,0,0]):\n            if (0 <= h_+i < H) and (0 <= w_+j < W):\n                if checked[h_+i][w_+j]: continue\n                checked[h_+i][w_+j] = True\n                if s[h_+i][w_+j] == '.': q.append((h_+i, w_+j, n+1))\n    return g_n\n\nn = 0\nfor i in range(H):\n    for j in range(W):\n        n = max(n, bfs(i,j))\n\nprint(n)", "from copy import deepcopy\nfrom collections import deque\nfrom itertools import product\nimport numpy as np\nclass Grid:\n    def __init__(self, grid, w=0, h=0, function=lambda x: x):\n        self.w = w = w if w else len(grid[0])\n        self.h = h = h if h else len(grid)\n        dtype = type(function(grid[0][0]))\n        self.grid = np.empty((h, w), dtype=dtype)\n        for i, row in zip(range(h), grid):\n            for j, val in zip(range(w), row):\n                self.grid[i][j] = function(val)\n    \n    def is_valid_x(self, x):\n        return 0 <= x < self.w\n    def is_valid_y(self, y):\n        return 0 <= y < self.h\n    def is_valid_xy(self, x, y):\n        return self.is_valid_x(x) and self.is_valid_y(y) \n    \n    def __iter__(self):\n        return iter(self.grid)\n    def __repr__(self):\n        return '\\n'.join([' '.join(map(str, row)) for row in self.grid]) + '\\n'\n    def __getitem__(self, x):\n        return self.grid[x]\n    def __setitem__(self, x, val):\n        self.grid[x] = val\n\ndef longest_path(grid, root):\n    def restore_path(prev, p):\n        A = deque()\n        while p:\n            A.appendleft(p)\n            p = prev[p]\n        return list(A)\n    \n    x, y = root\n    prev = {root:None}\n    grid[y, x] = '!'\n    queue = deque([root])\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in zip([1, 0, -1, 0], [0, 1, 0, -1]):\n            nx, ny = x+dx, y+dy\n            if grid.is_valid_xy(nx, ny) and grid[ny, nx] in 'sg.':\n                prev[nx, ny] = x, y\n                queue.append((nx, ny))\n                grid[ny, nx] = '!'\n    return restore_path(prev, (x, y))\n\nh, w = map(int, input().split())\ngrid = Grid([input() for s in range(h)])\nans = 0\nfor y, x in product(range(h), range(w)):\n    if grid[y, x] == '.':\n        path = longest_path(deepcopy(grid), (x, y))\n        ans = max(ans, len(path)-1)\nprint(ans)", "import queue\nh,w = map(int,input().split())\nv = [(1, 0), (0, 1), (-1, 0), (0, -1)]\ns = [input() for i in range(h)]\n\nans = 0\nque = queue.Queue()\nfor i in range(h * w):\n    c = 0\n    d = [[h*w] * w for i in range(h)]\n    p = (i//w, i%w)\n    if s[p[0]][p[1]] == '#':\n        continue\n    d[p[0]][p[1]] = 0\n    que.put(p)\n    while not que.empty():\n        y,x = que.get()\n        c = d[y][x]\n        for dy, dx in v:\n            yy = y + dy\n            xx = x + dx\n            if yy < 0 or xx < 0 or h <= yy or w <= xx:\n                continue\n            if s[yy][xx] == '#':\n                continue\n            if d[yy][xx] < h*w:\n                continue\n            que.put((yy, xx))\n            d[yy][xx] = c + 1\n    ans = max(ans, c)\nprint(ans)", "from collections import deque\n\nH, W = [int(x) for x in input().split()]\n\nfield = []\nfor i in range(H):\n    field.append(input())\n\nconn = [[[] for _ in range(W)] for _ in range(H)]\nfor i in range(H):\n    for j in range(W):\n        if field[i][j] == '.':\n            for e in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                h, w = i + e[0], j + e[1]\n                if 0 <= h < H and 0 <= w < W and field[h][w] == '.':\n                    conn[i][j].append([h, w])\nd = 0\nfor i in range(H):\n    for j in range(W):\n        l = 0\n        q = deque([[i, j]])\n        dist = [[-1 for _ in range(W)] for _ in range(H)]\n        dist[i][j] = 0\n        while q:\n            v = q.popleft()\n            for w in conn[v[0]][v[1]]:\n                if dist[w[0]][w[1]] == -1:\n                    q.append(w)\n                    dist[w[0]][w[1]] = dist[v[0]][v[1]] + 1\n                    l = dist[w[0]][w[1]]\n\n        d = max(d, l)\n\nprint(d)", "from copy import deepcopy\nfrom collections import deque\nh,w = map(int,input().split())\ns = [['#']*(w+2) for i in range(h+2)]\nfor i in range(h):\n    x = input()\n    for j in range(w):\n        s[i+1][j+1] = x[j]\nans = 0\nfor i in range(1,h+1):\n    for j in range(1,w+1):\n        if s[i][j] != '#':\n            maze = deepcopy(s)\n            maze[i][j] = 0\n            queue = deque([[i,j]])\n            while queue:\n                x,y = queue.popleft()\n                for a,b in([0,-1],[0,1],[1,0],[-1,0]):\n                    nh,nw = x+a,y+b\n                    if maze[nh][nw] == '.':\n                        maze[nh][nw] = maze[x][y] + 1\n                        queue.append([nh,nw])\n            l = 0\n            for x in range(1,h+1):\n                for y in range(1,w+1):\n                    if maze[x][y] != '#':\n                        l = max(l,maze[x][y])\n            ans = max(ans,l)\nprint(ans)", "from collections import deque\nh,w=list(map(int,input().split()))\n\ns=[]\ns.append(list(\"#\"*(w+2)))\nstart=[]\nfor i in range(1,h+1):\n  wk=list(\"#\"+input()+\"#\")\n  for j in range(1,w+1):\n    if wk[j]==\".\":\n      start.append([i,j])\n  s.append(wk)\ns.append(list(\"#\"*(w+2)))\n\ndist=[[-1]*(w+2) for _ in range(h+2)]\n\ndef bfs(start):\n  que=deque([start])\n  dist[start[0]][start[1]]=0\n  end=[]\n  cnt=0\n  while que:\n    y,x=que.popleft()\n    for py,px in [(1,0),(-1,0),(0,1),(0,-1)]:\n      ny,nx=y+py,x+px\n      if s[ny][nx]==\".\" and dist[ny][nx]==-1:\n        dist[ny][nx]=dist[y][x]+1\n        que.append([ny,nx])\n        cnt=max(cnt,dist[y][x]+1)\n  return cnt\n\nans=0\nfor i in start:\n  ans=max(ans,bfs(i))\n  dist=[[-1]*(w+2) for _ in range(h+2)]\nprint(ans)\n", "from collections import deque\nimport numpy as np\n\nH,W = map(int,input().split())\nmaze = [input() for _ in range(H)]\n\nans = 0\nfor x in range(H):\n    for y in range(W):\n        #\u58c1\u304b\u3089\u306f\u30b9\u30bf\u30fc\u30c8\u3067\u304d\u306a\u3044\n        if maze[x][y] == \"#\":\n            continue\n\n        distance = [[-1]*W for _ in range(H)]\n        distance[x][y] = 0\n        #start\u4f4d\u7f6e\n        stack = deque([[x,y]])\n\n        while stack:\n            h,w = stack.popleft()\n            for i,j in [[1,0],[-1,0],[0,1],[0,-1]]:\n                new_h, new_w = h+i, w+j\n                if new_h < 0 or new_w < 0 or new_h >= H or new_w >= W:\n                    continue\n                elif maze[new_h][new_w] != \"#\" and distance[new_h][new_w] == -1:\n                    distance[new_h][new_w] = distance[h][w]+1\n                    stack.append([new_h, new_w])\n\n        ans = max(ans, np.max(distance))\n\nprint(ans)", "from collections import deque\n \nH,W=map(int,input().split())\nS=[input() for _ in range(H)]\nans=0\nd=deque([])\nfor i in range(H):\n  for j in range(W):\n    if S[i][j]=='#':\n      continue\n    d.append((i,j,0))\n    visited=[[-1]*W for _ in range(H)]\n    visited[i][j]=0\n    while d:\n      x,y,c=d.popleft()\n      for dx,dy in [(0,1),(1,0),(0,-1),(-1,0)]:\n        nx,ny=x+dx,y+dy\n        if 0<=nx<H and 0<=ny<W and visited[nx][ny]==-1 and S[nx][ny]=='.':\n          visited[nx][ny]=c+1\n          d.append((nx,ny,c+1))\n    ans=max(ans,c)\nprint(ans)", "from collections import *\nfrom copy import *\nH,W = map(int,input().split())\nS = [(W+2)*[\"#\"]]+[[\"#\"]+list(input())+[\"#\"] for h in range(H)]+[(W+2)*[\"#\"]]\nD = [[1,0],[-1,0],[0,1],[0,-1]]\nans = 0\nP = deque([])\nQ = deque([])\n \nfor h in range(1,H+1):\n  for w in range(1,W+1):\n    if S[h][w]==\".\":\n      P+=[[h,w]]\n \nwhile P:\n  T = deepcopy(S)\n  sx,sy = P.popleft()\n  T[sx][sy] = 0\n  Q = deque([[sx,sy]])\n  while Q:\n    x,y = Q.popleft()\n    for dx,dy in D:\n      if T[x+dx][y+dy]==\".\":\n        T[x+dx][y+dy] = T[x][y]+1\n        Q+=[[x+dx,y+dy]]\n        ans = max(ans,T[x+dx][y+dy])\n \nprint(ans)", "from collections import deque\nimport copy\n\nH,W=map(int,input().split())\nMAP=[list(input()) for y in range(H)]\n\ndef Maze(_x, _y):\n  MAP2=copy.deepcopy(MAP)\n  q=deque([[_x,_y]])\n  MAP2[_y][_x]=0\n  while q:\n    xy=q.popleft()\n    for d in [(0,-1),(-1,0),(0,1),(1,0)]:\n      x2,y2=xy[0]+d[0],xy[1]+d[1]\n      if x2<0 or y2<0 or x2>=W or y2>=H:\n        continue\n      if MAP2[y2][x2]=='.':\n        q.append([x2,y2])\n        MAP2[y2][x2]=MAP2[xy[1]][xy[0]]+1\n  \n  maxM=0\n  for y in range(H):\n    for x in range(W):\n      if type(MAP2[y][x])==int:\n        maxM=max(maxM, MAP2[y][x])\n  return maxM\n  \n\nans=0\nfor y in range(H):\n  for x in range(W):\n    if MAP[y][x]=='.':\n      ans=max(ans, Maze(x,y))\nprint(ans)", "import queue\n\nh,w=map(int,input().split())\n\ns=[]\nfor _ in range(h):\n    s.append(input())\n\nans=0\nfor i in range(h):\n    for j in range(w):\n        if s[i][j]==\".\":\n            seen=[[0 for _ in range(w)] for _ in range(h)]\n            length=[[0 for _ in range(w)] for _ in range(h)]\n            q=queue.Queue()\n            q.put([i,j])\n            seen[i][j]=1\n            while not q.empty():\n                ci,cj=q.get()\n                for ni,nj in [[ci-1,cj],[ci+1,cj],[ci,cj-1],[ci,cj+1]]:\n                    if 0<=ni<h and 0<=nj<w and s[ni][nj]==\".\" and seen[ni][nj]==0:\n                        q.put([ni,nj])\n                        length[ni][nj]=length[ci][cj]+1\n                        seen[ni][nj]=1\n            ans=max(ans,length[ci][cj])\n\nprint(ans)", "from collections import deque\nh,w=map(int,input().split())\ns=[input() for _ in range(h)] #\u30de\u30c3\u30d7\nvi=[ [-1 for _ in range(w)] for _ in range(h)]#visit\nst=deque()\n\nd=[[0,1],[-1,0],[1,0],[0,-1]]\n\nmx=0\n\nfor i in range(h):\n  for j in range(w):\n    vi=[ [-1 for _ in range(w)] for _ in range(h)]\n    st.append([i,j,0])\n    \n    while st:\n      h1,w1,k=st.popleft()\n\n      if 0<=h1<h and 0<=w1<w and vi[h1][w1]==-1 and s[h1][w1]==\".\":\n        vi[h1][w1]=k\n        for m in d:\n          st.append([h1+m[0],w1+m[1],k+1])\n    for m in vi:\n      mx=max(mx,max(m))\n\nprint(mx)", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\nimport copy\nfrom collections import deque\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef sagasu(h,w,mp,sh,sw):\n    d = deque()\n    x=sw\n    y=sh\n    d.append([y,x,0])\n    while len(d)>0:\n        y,x,cnt=d.popleft()\n        if mp[y][x]==-2 or mp[y][x] > cnt:\n            mp[y][x]=cnt\n            nxt=[[y-1,x],[y+1,x],[y,x-1],[y,x+1]]\n            for nx in nxt:\n                y2=nx[0]\n                x2=nx[1]\n                if y2 < 0:\n                    continue\n                if y2 >= h:\n                    continue\n                if x2 < 0:\n                    continue\n                if x2 >= w:\n                    continue\n                if mp[y2][x2] == -2 or mp[y2][x2] > cnt:\n                    d.append([y2,x2,cnt+1])\n    ret=-1\n    for y in range(h):\n        for x in range(w):\n            ret=max(ret,mp[y][x])\n    return ret\ndef resolve():\n    readline=sys.stdin.readline\n\n    h,w=list(map(int, readline().rstrip().split()))\n\n    mp=[[0 for i in range(w)] for j in range(h)]\n    for y in range(h):\n        ss=readline().rstrip()\n        for x in range(w):\n            if ss[x]==\"#\":\n                mp[y][x]=-1 #kabe\n            else:\n                mp[y][x]=-2 #miti\n    ans=0\n    for y in range(h):\n        for x in range(w):\n            if mp[y][x]==-2:\n                mp2=copy.deepcopy(mp)\n                n=sagasu(h,w,mp2,y,x)\n                ans=max(ans,n)\n    print(ans)\n    \n    #arr=list(map(int, readline().rstrip().split()))\n    #n=int(readline())\n    #ss=readline().rstrip()\n    #yn(1)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "from collections import deque\nimport _pickle as cPickle\nimport cProfile\nh, w = map(int, input().split())\ns = [[\"#\"]*(w+2)] + [[\"#\"]+list(input())+[\"#\"] for i in range(h)] + [[\"#\"]*(w+2)]\nans = 0\nA=list()\nfor i in range(1, h+1):\n    for j in range(1, w+1):\n        t=cPickle.loads(cPickle.dumps(s, -1))\n        c=dict()\n        A=list()\n        if s[i][j] == \"#\":\n            continue\n        a = deque([[i, j, 0]])\n        while len(a) > 0:\n            x, y, cnt = a.popleft()\n            t[x][y] = \"#\"\n            if t[x-1][y] == \".\":\n                if [x-1, y, cnt+1] not in A:\n                  a.append([x-1, y, cnt+1])\n                  A.append([x-1, y, cnt+1])\n            if t[x+1][y] == \".\":\n                if [x+1, y, cnt+1] not in A:\n                  a.append([x+1, y, cnt+1])\n                  A.append([x+1, y, cnt+1])\n            if t[x][y-1] == \".\":\n                if [x, y-1, cnt+1] not in A:\n                  a.append([x, y-1, cnt+1])\n                  A.append([x, y-1, cnt+1])\n            if t[x][y+1] == \".\":\n                if [x, y+1, cnt+1] not in A:\n                  a.append([x, y+1, cnt+1])\n                  A.append([x, y+1, cnt+1])\n        ans = max(ans, cnt)\nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8')\nimport string\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\n\ndef solve():\n    n, m = [int(x) for x in input().split()]\n    a = []\n    starts = []\n    for i in range(n):\n        a.append(input())\n        for j in range(m):\n            if a[i][j] == '.':\n                starts.append((i, j))\n\n    def bfs(v):\n        q = deque([(v, 0)])\n        mx = 0\n        mv = v\n        w = defaultdict(int)\n        w[v] = 1\n        while q:\n            v, d = q.popleft()\n            if d > mx:\n                mv = v\n                mx = d\n            i, j = v\n            for x, y in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                if 0 <= i + x < n and 0 <= j + y < m and not w[(i+x,j+y)] and a[i+x][j+y] == '.':\n                    w[(i+x,j+y)] = 1\n                    q.append(((i+x, j+y), d + 1))\n            \n\n        return mx, mv\n\n    ans = 0\n    for start in starts:\n        _, start = bfs(start)\n        cur, start = bfs(start)\n\n        ans = max(ans, cur)\n    print(ans)\n\n\n    \n\nt = 1\n# t = int(input())\nfor case in range(1,t+1):\n    ans = solve()\n\n\n\"\"\"\n1\n4\n-1 1 1 -1\n\n\"\"\"\n", "from collections import deque\nH, W = map(int, input().split())\nL = []\nfor _ in range(H):\n    s = input()\n    a = []\n    for i in range(len(s)):\n        a.append(s[i])\n    L.append(a)\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\n\n\ndef bfs(x, y):\n    dp = [[10000000] * W for _ in range(H)]\n    dp[y][x] = 0\n    if L[y][x] == '#':\n        return dp\n    else:\n        d = deque()\n        d.append([x, y])\n        while len(d) > 0:\n            s = d.popleft()\n            for i in range(4):\n                if (s[1] +\n                    dy[i] >= 0 and s[1] +\n                    dy[i] < H and s[0] +\n                    dx[i] >= 0 and s[0] +\n                        dx[i] < W):\n                    if L[s[1] +\n                         dy[i]][s[0] +\n                                dx[i]] == '.' and dp[s[1] +\n                                                     dy[i]][s[0] +\n                                                            dx[i]] == 10000000:\n                        d.append([s[0] + dx[i], s[1] + dy[i]])\n                        dp[s[1] + dy[i]][s[0] + dx[i]] = dp[s[1]][s[0]] + 1\n\n        return dp\n\n\nmax_num = 0\nfor i in range(H):\n    for j in range(W):\n        dp = bfs(j, i)\n        for k in dp:\n            for p in k:\n                if (p == 10000000):\n                    continue\n                max_num = max(max_num, p)\nprint(max_num)", "from collections import deque\nimport copy\n\nH,W = map(int,input().split())\nS = [list(input()) for _ in range(H)]\n\ndef bfs(x,y):\n    check = copy.deepcopy(S)\n    que = deque()\n    que.append((x,y))\n    check[y][x] = 0\n    while que.__len__() != 0:\n        x,y = que.popleft()\n        tmp = check[y][x]\n        for dx,dy in (1,0),(-1,0),(0,1),(0,-1):\n            sx = x + dx\n            sy = y + dy\n            if -1 < sx < W and -1 < sy < H:\n                if check[sy][sx] == '.':\n                    check[sy][sx] = tmp + 1\n                    que.append((sx,sy))\n    return tmp\n\nans = 0\nfor x in range(W):\n    for y in range(H):\n        if S[y][x] == '.':\n            ans = max(bfs(x,y),ans)\n\nprint(ans)", "from collections import deque\nH, W = map(int, input().split())\nmaze = [list(input()) for _ in range(H)]\ndirection = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\nans = 0\nfor sh in range(H):\n    for sw in range(W):\n        if maze[sh][sw] == \"#\":\n            continue\n\n        dist = [[-1] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        que = deque([[sh, sw]])\n\n        while que:\n            nh, nw = que.pop()\n            for dh, dw in direction:\n                if not ((0 <= nh + dh < H) and (0 <= nw + dw < W)):\n                    continue\n                if maze[nh + dh][nw + dw] == \"#\":\n                    continue\n                if dist[nh + dh][nw + dw] != -1:\n                    continue\n\n                dist[nh + dh][nw + dw] = dist[nh][nw] + 1\n                que.appendleft([nh + dh, nw + dw])\n\n        ans = max(ans, max([max(d) for d in dist]))\n\nprint(ans)", "from collections import deque\nimport numpy as np\nH, W = map(int,input().split())\nmaze = [input() for _ in range(H)]\n\ndxy =[[1,0],[0,1],[-1,0],[0,-1]]\n\nans = 0\nfor x in range(H):\n    for y in range(W):\n        if maze[x][y]==\"#\":\n            continue\n            \n        seen = [[0]*W for _ in range(H)]\n        que = deque([[x,y]])\n\n        while que:\n            vx,vy = que.popleft()\n            for i,j in dxy:\n                next_x,next_y = vx+i,vy+j\n                if not(0<= next_x < H) or not(0<= next_y <W):\n                    continue\n                elif maze[next_x][next_y] !=\"#\" and seen[next_x][next_y]==0:\n                    seen[next_x][next_y]=seen[vx][vy]+1\n                    que.append([next_x,next_y])\n        seen[x][y] = 0\n        ans = max(ans,np.max(seen))\nprint(ans)", "from collections import deque\nfrom typing import List\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    g = []\n    for _ in range(h):\n        r = list(input())\n        g.append(r)\n    print((mm(h, w, g)))\n\n\ndef mm(h: int, w: int, g: List[List[str]]) -> int:\n    ret = 0\n    for i in range(h):\n        for j in range(w):\n            if (g[i][j] == '#'):\n                continue\n            v = set()\n            q = deque([(i, j, 0)])\n            v.add((i, j))\n            while q:\n                ii, jj, cnt = q.popleft()\n                ret = max(ret, cnt)\n                # \u2193\n                if ii < h - 1 and g[ii + 1][jj] == '.' and (ii + 1, jj) not in v:\n                    q.append((ii + 1, jj, cnt + 1))\n                    v.add((ii + 1, jj))\n                # \u2192\n                if jj < w - 1 and g[ii][jj + 1] == '.' and (ii, jj + 1) not in v:\n                    q.append((ii, jj + 1, cnt + 1))\n                    v.add((ii, jj + 1))\n                # \u2191\n                if ii > 0 and g[ii - 1][jj] == '.' and (ii - 1, jj) not in v:\n                    q.append((ii - 1, jj, cnt + 1))\n                    v.add((ii - 1, jj))\n                # \u2190\n                if jj > 0 and g[ii][jj - 1] == '.' and (ii, jj - 1) not in v:\n                    q.append((ii, jj - 1, cnt + 1))\n                    v.add((ii, jj - 1))\n    return ret\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W = map(int, input().split())\nS = []\nfor i in range(H):\n    S.append(input())\n\ndef bfs(start):\n    already = {}\n    queue = []\n    counter = 0\n    queue.append((start[0], start[1], 0))\n    already[start] = True\n    max_depth = 0\n    while counter < len(queue):\n        y, x, depth = queue[counter]\n        if depth > max_depth:\n            max_depth = depth\n        for move in ((-1, 0), (0, 1), (1, 0), (0, -1)):\n            new_y = y + move[0]\n            new_x = x + move[1]\n            if new_y >= 0 \\\n            and new_y < H \\\n            and new_x >= 0 \\\n            and new_x < W \\\n            and S[new_y][new_x] == '.' \\\n            and (new_y, new_x) not in already:\n                already[(new_y, new_x)] = True\n                queue.append((new_y, new_x, depth+1))\n        counter += 1\n    return max_depth\n\nanswer = 0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '#':\n            continue\n        depth = bfs((i, j))\n        if answer < depth:\n            answer = depth\nprint(answer)", "from collections import deque\nH, W = map(int, input().split())\nS = [''] * H\nfor i in range(H):\n    S[i] = input()\ndests = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\ndef maze(sx, sy):\n    d = deque()\n    dist = [[-1] * W for i in range(H)]\n    dist[sx][sy] = 0\n    d.append((sx, sy))\n    while True:\n        x, y = d.popleft()\n        for dest in dests:\n            nx, ny = x + dest[0], y + dest[1]\n            if nx >= 0 and nx < H and ny >= 0 and ny < W and S[nx][ny] == '.' and dist[nx][ny] == -1:\n                d.append((nx, ny))\n                dist[nx][ny] = dist[x][y] + 1\n        if not d: return dist[x][y]\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '#': continue\n        ans = max(ans, maze(i, j))\nprint(ans)", "def main():\n\tH, W = [int(x) for x in input().split(\" \")]\n\tS = []\n\tS.append([\"X\"] * (W + 2))\n\th = 0\n\tw = 0\n\tfor i in range(H):\n\t\trow = list(input())\n\t\tS.append([\"X\"] + row + [\"X\"])\n\t\tif not h and not w and row.count(\".\") > 0:\n\t\t\th = i + 1\n\t\t\tw = row.index(\".\") + 1\n\tS.append([\"X\"] * (W + 2))\n\n\tans = []\n\tfor i in range(H):\n\t\tfor j in range(W):\n\t\t\tans.append(BFS(S, i + 1, j + 1, H + 2, W + 2))\n\tprint((max(ans)))\n\ndef BFS(M, i, j, H, W):\n\tif M[i][j] != \".\":\n\t\treturn 0\n\tto_visit = [{\"row\": i, \"col\": j, \"step\": 0}]\n\tchecked = [[0] * W for x in range(H)]\n\tchecked[i][j] = 1\n\tz = [[0] * W for x in range(H)]\n\twhile len(to_visit):\n\t\tvisiting = to_visit.pop(0)\n\t\tr0 = visiting[\"row\"]\n\t\tc0 = visiting[\"col\"]\n\t\ts0 = visiting[\"step\"]\n\t\tz[r0][c0] = s0\n\t\tfor d in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n\t\t\tr = r0 + d[0]\n\t\t\tc = c0 + d[1]\n\t\t\ts = s0 + 1\n\t\t\tif checked[r][c] == 0 and M[r][c] == \".\":\n\t\t\t\tto_visit.append({\"row\": r, \"col\": c, \"step\": s})\n\t\t\t\tchecked[r][c] = 1\n\ta = 0\n\tfor i in range(len(z)):\n\t\tfor j in range(len(z[i])):\n\t\t\tif a < z[i][j]:\n\t\t\t\ta = z[i][j]\n\treturn a\n\nmain()\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Sep  8 18:25:14 2020\n\n@author: liang\n\"\"\"\n\nH, W = map(int, input().split())\n\nfield = [input() for i in range(H)]\n\ndef Init():\n    return [[-1]*W for _ in range(H)]\n\nans = -1\n\nfrom collections import deque\nq = deque()\nadj = ((1,0), (-1,0), (0,1), (0,-1))\ndef BFS(y,x):\n    def isValid(t):\n        if t[0] < 0 or t[0] >= H or t[1] < 0 or t[1] >= W or field[t[0]][t[1]] == \"#\":\n            return False\n        return True\n    d = Init()\n    if field[y][x] == '#':\n        return -1\n    d[y][x] = 0\n    q.append((y,x))\n    res = 0\n    while q:\n        cur = q.popleft()\n        for a in adj:\n            nex = (cur[0]+a[0], cur[1]+a[1])\n            if isValid(nex) and (d[nex[0]][nex[1]]== -1 or d[nex[0]][nex[1]] > d[cur[0]][cur[1]]+1):\n                d[nex[0]][nex[1]] = d[cur[0]][cur[1]]+1\n                if res < d[nex[0]][nex[1]]:\n                    res = d[nex[0]][nex[1]]\n                q.append(nex)\n    return res\n\nfor i in range(H):\n    for j in range(W):\n        tmp = BFS(i,j)\n        if tmp > ans:\n            ans = tmp\nprint(ans)", "import math\nimport sys\nsys.setrecursionlimit(10000)\nH, W = map(int, input().split())\nS = []\nfor i in range(H):\n  S.append(str(input()))\n  \ndef main(l, d, cnt):\n  tmp = []\n  for n in l:\n    i, j = n[0], n[1]\n    if (0<i) and (S[i-1][j] == '.'):\n      if d[i-1][j] > d[i][j]+1:\n        d[i-1][j] = d[i][j]+1\n        tmp.append([i-1, j])\n    if (i<H-1) and (S[i+1][j] == '.'):\n      if d[i+1][j] > d[i][j]+1:\n        d[i+1][j] = d[i][j]+1\n        tmp.append([i+1, j])\n    if (0<j) and (S[i][j-1] == '.'):\n      if d[i][j-1] > d[i][j]+1:\n        d[i][j-1] = d[i][j]+1\n        tmp.append([i, j-1])\n    if (j<W-1) and (S[i][j+1] == '.'):\n      if d[i][j+1] > d[i][j]+1:\n        d[i][j+1] = d[i][j]+1\n        tmp.append([i, j+1])\n  if tmp == []:\n    return cnt\n  else:\n    cnt += 1\n    return main(tmp, d, cnt)\n  \nans = 0\nfor i in range(H):\n  for j in range(W):\n    if S[i][j] == '.':\n      d = [[float('inf') for i in range(W)] for j in range(H)]\n      d[i][j] = 0\n      cnt = main([[i, j]], d, 0)\n      ans = max(ans, cnt)\nprint(ans)", "import collections # deque, Counter\n# import itertools   # accumulate, compress, permutations(nPr), combinations(nCr)\n# import bisect      # bisect_left(insert\u4f4d\u7f6e), bisect_right(slice\u7528)\n# import math        # factorical\uff08\u968e\u4e57) # hypot(\u8ddd\u96e2)\n# import heapq\n# from fractions import gcd # Python3.5\u4ee5\u524d # lcm\uff08\u6700\u5c0f\u516c\u500d\u6570\uff09 = (a*b)//gcd(a,b)\n# from fractions import Fraction\n# from math import gcd # Python3.6\u4ee5\u964d\n# --------------------------------------------------------------\n\nH,W   = map(int,input().split())\nmaze  = [[None for _ in range(W)] for _ in range(H)]\n\nfor i in range(H):\n    maze[i] = list(input())\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ncnt = 0\n\nfor j in range(H):\n    for k in range(W):\n            if maze[j][k]=='#':\n                continue\n            else:\n                sy = j\n                sx = k\n\n                seen = [[-1 for _ in range(W)] for _ in range(H)]\n                seen[sy][sx] = 0\n\n                que  = collections.deque()  # \u767a\u898b\u6e08\u672a\u8a2a\u554f\u306a\u9802\u70b9\n                que.append([sy,sx])\n\n                while(len(que)!=0):\n                    p = que.popleft()\n                    for i in range(4):\n                        ny = p[0] + dy[i]\n                        nx = p[1] + dx[i]\n                        if (ny >= 0 and nx >=0 and ny < H and nx < W and seen[ny][nx] == -1 and maze[ny][nx] != '#'):\n                            seen[ny][nx] = seen[p[0]][p[1]] + 1\n                            que.append([ny,nx])\n\n                cnt = max(cnt, max([x for row in seen for x in row]))\n\nprint(cnt)", "from collections import deque\n\n\ndef main():\n    row, col = list(map(int, input().split()))\n    S = [list(input()) for _ in range(row)]\n    ans = 0\n\n    for r in range(row):\n        for c in range(col):\n            if S[r][c] == \"#\":\n                continue\n            q = deque()\n            q.append((r, c))\n            dist = [[-1 for _ in range(col)] for _ in range(row)]\n            dist[r][c] = 0\n\n            while q:\n                r, c = q.popleft()\n                for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                    nr, nc = r + dr, c + dc\n                    if not(0 <= nr < row and 0 <= nc < col):\n                        continue\n                    if S[nr][nc] == \"#\":\n                        continue\n                    if dist[nr][nc] != -1:\n                        continue\n                    q.append((nr, nc))\n                    dist[nr][nc] = dist[r][c] + 1\n                    ans = max(ans, dist[nr][nc])\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nH, W, *S = open(0).read().split()\nH, W = [int(_) for _ in [H, W]]\nA = []\nB = []\nC = []\nfor i in range(H * W):\n    x, y = divmod(i, W)\n    if S[x][y] == '.':\n        for dx, dy in ((1, 0), (0, 1), (-1, 0), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < H and 0 <= ny < W):\n                continue\n            if S[nx][ny] == '.':\n                A += [i]\n                B += [nx * W + ny]\n                C += [1]\nF = floyd_warshall(csr_matrix((C, (A, B)), shape=(H*W, H*W)))\nprint((int(np.max(F[F!=np.inf]))))\n", "from copy import deepcopy\nfrom collections import Counter, defaultdict, deque\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return map(int,input().split())\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\ndef maze_solve(S_1,S_2,maze_list):\n    d = deque()\n    dist[S_1][S_2] = 0\n    d.append([S_1,S_2])\n    dx = [0,0,1,-1]\n    dy = [1,-1,0,0]\n    while d:\n        v = d.popleft()\n        x = v[0]\n        y = v[1]\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if nx < 0 or nx >= h or ny < 0 or ny >= w:\n                continue\n            if dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                d.append([nx,ny])\n    return max(list(map(lambda x: max(x), dist)))\nh,w = MI()\nans = 0\nmaze = [list(input()) for _ in range(h)]\ndist = [[-1]*w for _ in range(h)]\nstart_list = []\nfor i in range(h):\n    for j in range(w):\n        if maze[i][j] == \"#\":\n          dist[i][j] = 0\n        else:\n          start_list.append([i,j])\ndist_copy = deepcopy(dist)\nfor k in start_list:\n  dist = deepcopy(dist_copy)\n  ans = max(ans,maze_solve(k[0],k[1],maze))\nprint(ans)", "#import sys\n#input=sys.stdin.readline()\n#print(input)\n\n#import pprint\nh,w = map(int,input().split())\ns = [list(input())for i in range(h)]\n#print(\"s\")\n#pprint.pprint(s,width=w*10)\n\nvisited = [[0 for i in range(w)] for j in range(h)]#s\u3068\u540c\u3058\u5f62\u306b0\u3092\u914d\u7f6e\u3057\u305f\u8868\nquene = []#\u79fb\u52d5\u5143Now\u3068\u306a\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u5ea7\u6a19\u306e\u30ea\u30b9\u30c8\nans = 0\n\nfor i in range(h):\n    for j in range(w):\n        if s[i][j] == \".\":\n            quene.append([i,j])#\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u3092Quene\u306b\u8ffd\u52a0\n            visited[i][j]=1#\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u30921\u306b\u3059\u308b\n#            print(\"visited\")\n#            pprint.pprint(visited,width=w*10)\n#            print(quene)\n\n            dy_dx=[[1,0],[-1,0],[0,1],[0,-1]]#\uff11\u56de\u306b\u79fb\u52d5\u51fa\u6765\u308b\u91cf\n\n            while len(quene)>=1:\n                now=quene.pop(0)#quene\u306e\u5de6\u7aef\u306e\u9805\u3092\u53d6\u308a\u51fa\u3059\n#                print(now)\n                for k in range(4):\n                    y=now[0]+dy_dx[k][0]#now\u304b\u3089\u79fb\u52d5\u5148[x,y]\u3078\u306ey\u8ef8\u65b9\u5411\u306e\u79fb\u52d5\u91cf\n                    x=now[1]+dy_dx[k][1]#now\u304b\u3089\u79fb\u52d5\u5148[x,y]\u3078\u306ex\u8ef8\u65b9\u5411\u306e\u79fb\u52d5\u91cf\n                    if 0<=y<h and 0<=x<w:#\u79fb\u52d5\u5148\u304c\u8868\u3092\u98db\u3073\u51fa\u3057\u3066\u3044\u306a\u3051\u308c\u3070OK\n                        if s[y][x]!=\"#\" and visited[y][x]==0:#\u79fb\u52d5\u5148\u304c\u58c1\u3067\u306a\u3044\u3001\u304b\u3064\u884c\u3063\u305f\u3053\u3068\u304c\u306a\u3051\u308c\u3070OK\n                            visited[y][x]=visited[now[0]][now[1]]+1#\u79fb\u52d5\u5148\u306e\u5024\u3092Now\u306e\u5024+1\u306b\u3059\u308b\n                            quene.append([y,x])#Quene\u306b\u79fb\u52d5\u5148\u5ea7\u6a19\u3092\u8ffd\u52a0\n#                           pprint.pprint(visited,width=w*10)\n#       \u4e00\u3064\u306e\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u5e45\u512a\u5148\u63a2\u7d22\u3092\u7d42\u308f\u3089\u305b\u305f\u3089\u3001\u79fb\u52d5\u91cf\u306e\u6700\u5927\u5024\u3092\u6c42\u3081\u308b\n        for l in range(h):\n            for m in range(w):\n                ans = max(ans,visited[l][m])#\u3053\u308c\u307e\u3067\u306e\u6700\u5927\u5024\u3068\u4eca\u56de\u5f97\u3089\u308c\u305f\u79fb\u52d5\u91cf\u306e\u6700\u5927\u5024\u3092\u6bd4\u8f03\u3057\u3001\u5927\u304d\u3044\u307b\u3046\u3092\u65b0\u3057\u3044\u7b54\u3048\u306b\u3059\u308b\n        visited = [[0 for i in range(w)] for j in range(h)]#visited\u521d\u671f\u5316\nprint(ans-1)", "from collections import deque\nH,W = map(int,input().split())\nfield = [list(input()) for _ in range(H)]\ndist = [[-1]*W for _ in range(H)]\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\nmx = 0\nfor h in range(H):\n    for w in range(W):\n        if field[h][w] == \"#\":\n            continue\n        dist = [[-1]*W for _ in range(H)]\n        dist[h][w] = 0\n        que = deque([])\n        que.append([h,w])\n        while que != deque([]):\n            u,v = que.popleft()\n            for dir in range(4):\n                nu = u + dx[dir]\n                nv = v + dy[dir]\n\n                if (nu < 0) or (nu >= H) or (nv < 0) or (nv >= W):\n                    continue\n                if field[nu][nv] == \"#\":\n                    continue\n                if dist[nu][nv] != -1:\n                    continue\n            \n                que.append([nu,nv])\n                dist[nu][nv] = dist[u][v] + 1\n            \n            \n        for i in range(H):\n            for j in range(W):\n                if mx < dist[i][j]:\n                    mx = dist[i][j]\n    \nprint(mx)", "# Https://atcoder.jp/contests/abc151/tasks/abc151_d\n\nfrom collections import deque\n\nH, W = list(map(int, input().split()))\nmaze = [list(input()) for i in range(H)]\n\n\ndef bfs(sx, sy):\n    result = 0\n    count = [[-1] * W for i in range(H)]\n    count[sx][sy] = 0\n    d = deque()\n    d.append((sx, sy))\n    while d:\n        x, y = d.popleft()\n        result = count[x][y]\n        for i, j in ([1, 0], [0, 1], [-1, 0], [0, -1]):\n            tx, ty = x + i, y + j\n            if (\n                not (0 <= tx < H)\n                or not (0 <= ty < W)\n                or maze[tx][ty] == \"#\"\n                or count[tx][ty] != -1\n            ):\n                continue\n            else:\n                count[tx][ty] = count[x][y] + 1\n                d.append((tx, ty))\n    return result\n\n\nans = 0\nfor i in range(W):\n    for j in range(H):\n        if maze[j][i] == \".\":\n            ans = max(ans, bfs(j, i))\nprint(ans)\n", "from collections import deque\nimport copy\nH, W = list(map(int, input().split()))\nmaze = []\nans = 0\n\nfor i in range(H):\n    maze.append(list(input()))\n\n\ndistancelist = []\nfor i in range(H):\n    tmplst = [0]*W\n    \n    for j in range(W):\n        if maze[i][j] == '#':\n            tmplst[j] = -1\n\n    distancelist.append(tmplst)\n\nfor x in range(H):\n    for y in range(W):\n        if maze[x][y] == '#':\n            continue\n\n        tmpdis = copy.deepcopy(distancelist)\n        d = deque()\n        start = [x, y]\n        d.append(start)\n        while d:\n            h, w = d.popleft()\n            now = tmpdis[h][w]\n            for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                dh, dw = h+i, w+j\n                if (0 <= dh < H) and (0 <= dw < W):\n                    if (tmpdis[dh][dw] == 0) and [dh, dw] != start:\n                        d.append([dh, dw])\n                        tmpdis[dh][dw] = now + 1\n\n            ans = max(now, ans)\n\n\nprint(ans)\n\n", "from collections import deque\nh, w = list(map(int, input().split()))\ns = [input() for _ in range(h)]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\ndef bfs(i, j):\n    cost = [[-1 for _ in range(w)] for _ in range(h)]\n    que = deque()\n    cost[i][j] = 0\n    que.append((i, j))\n    if s[i][j] == '#':\n        return 0\n    while que:\n        ni, nj = que.popleft()\n        for k in range(4):\n            if 0 <= ni+dy[k] < h and 0 <= nj+dx[k] < w:\n                if cost[ni+dy[k]][nj+dx[k]] != -1:\n                    continue\n                if s[ni+dy[k]][nj+dx[k]] == '.':\n                    cost[ni+dy[k]][nj+dx[k]] = cost[ni][nj]+1\n                    que.append((ni+dy[k], nj+dx[k]))\n\n    cc = 0\n    for i in range(h):\n        for j in range(w):\n            if cost[i][j] > cc:\n                cc = cost[i][j]\n    return cc\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        cost = bfs(i, j)\n        ans = max(ans, cost)\n\nprint(ans)\n", "from collections import deque\n\nh,w = map(int,input().split())\nmaze = []\n\nfor _ in range(h):\n    maze.append(input())\n\nans = 0\n\nmove = [[1,0],[-1,0],[0,1],[0,-1]]\n\nfor i in range(h):\n    for j in range(w):\n        if(maze[i][j]==\".\"):\n            dist = [ [99999999]*w for _ in range(h) ]\n            \n            dq = deque()\n            y=i\n            x=j\n            d=0\n            dist[y][x]=0\n            dq.append((y,x,d))\n            \n            while(len(dq)):\n                \n                y,x,d = dq.popleft()\n                \n                for m in move:\n                    if((0<=x+m[0]<w) and (0<=y+m[1]<h) and\n                        (dist[y+m[1]][x+m[0]] > d+1) and\n                            (maze[y+m[1]][x+m[0]] == \".\")):\n                                dist[y+m[1]][x+m[0]]=d+1\n                                dq.append((y+m[1],x+m[0],d+1))\n                                \n            ans = max(ans,d)\n            # print(d,i,j)\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**7)\nimport bisect\nimport heapq\nimport itertools\nimport math\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom math import gcd\nfrom operator import add, itemgetter, mul, xor\ndef cmb(n,r,mod):\n  bunshi=1\n  bunbo=1\n  for i in range(r):\n    bunbo = bunbo*(i+1)%mod\n    bunshi = bunshi*(n-i)%mod\n  return (bunshi*pow(bunbo,mod-2,mod))%mod\nmod = 10**9+7\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return map(int,input().split())\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\n\n#bisect.bisect_left(list,key)\u306flist\u306e\u306a\u304b\u3067key\u672a\u6e80\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3064\u307e\u308alist[i] < x \u3068\u306a\u308b i \u306e\u500b\u6570\n#bisect.bisect_right(list, key)\u306flist\u306e\u306a\u304b\u3067key\u4ee5\u4e0b\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3064\u307e\u308alist[i] <= x \u3068\u306a\u308b i \u306e\u500b\u6570\n#\u3053\u308c\u3092\u5fdc\u7528\u3059\u308b\u3053\u3068\u3067\n#len(list) - bisect.bisect_left(list,key)\u306flist\u306e\u306a\u304b\u3067key\u4ee5\u4e0a\u306e\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#len(list) - bisect.bisect_right(list,key)\u306flist\u306e\u306a\u304b\u3067key\u3088\u308a\u5927\u304d\u3044\u6570\u5b57\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u8fd4\u3059\n#\u3053\u308c\u3089\u3092\u4f7f\u3046\u3068\u304d\u306f\u3042\u3089\u304b\u3058\u3081list\u3092\u30bd\u30fc\u30c8\u3057\u3066\u304a\u304f\u3053\u3068\uff01\ndef maze_solve(S_1,S_2,maze_list):\n    d = deque()\n    d.append([S_1,S_2])\n    dx = [0,0,1,-1]\n    dy = [1,-1,0,0]\n    while d:\n        v = d.popleft()\n        x = v[0]\n        y = v[1]\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if nx < 0 or nx >= h or ny < 0 or ny >= w:\n                continue\n            if dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                d.append([nx,ny])\n    return max(list(map(lambda x: max(x), dist)))\nh,w = MI()\nif h==1 and w == 2:\n  print(1)\nelif h == 2 and w == 1:\n  print(1)\nelse:\n  ans = 0\n  maze = [list(input()) for _ in range(h)]\n  dist = [[-1]*w for _ in range(h)]\n  start_list = []\n  for i in range(h):\n      for j in range(w):\n          if maze[i][j] == \"#\":\n              dist[i][j] = 0\n          else:\n              start_list.append([i,j])\n  dist_copy = deepcopy(dist)\n  for k in start_list:\n      dist = deepcopy(dist_copy)\n      ans = max(ans,maze_solve(k[0],k[1],maze))\n  print(ans+1)", "H, W = list(map(int, input().split()))\nS = [0]*(H+2)\nS[0] = ''.join(['#']*(W+2))\nS[-1] = ''.join(['#']*(W+2))\nfor i in range(1,H+1):\n  S[i] = '#'+input()+'#'\n\nmaxd = 0\nimport queue\ndy = [1,0,-1,0]\ndx = [0,1,0,-1]\nfor h in range(1,H+1):\n  for w in range(1,W+1):\n    if S[h][w]=='.':\n      visited = [[False]*(W+2) for _ in range(H+2)]\n      q = queue.Queue()\n      visited[h][w] = True\n      q.put([h,w,0])\n      while not q.empty():\n        a,b,c = q.get()\n        #print(a,b,c)\n        for i in range(4):\n          y,x = a+dy[i], b+dx[i]\n          if S[y][x]=='.' and visited[y][x]==False:\n            q.put([y,x,c+1])\n            visited[y][x]=True\n      maxd = max(maxd,c)\nprint(maxd)\n", "from collections import deque\nH, W = map(int, input().split())\nS = []\nfor _ in range(H):\n    S.append(input())\nyudlr = [-1, 1, 0, 0]\nxudlr = [0, 0, -1, 1]\nD = 0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '#':\n            continue\n        d = [[-1] * W for _ in range(H)]\n        d[i][j] = 0\n        Q = deque()\n        Q.append([i, j])\n        while len(Q) > 0:\n            q = Q.popleft()\n            y, x = q[0], q[1]\n            for k in range(4):\n                y1 = y + yudlr[k]\n                x1 = x + xudlr[k]\n                if y1 < 0 or y1 >= H or x1 < 0 or x1 >= W:\n                    continue\n                if S[y1][x1] == '#':\n                    continue\n                if d[y1][x1] != -1:\n                    continue\n                d[y1][x1] = d[y][x] + 1\n                Q.append([y1, x1])\n        Dij = max(list(map(lambda x: max(x), d)))\n        D = max(D, Dij)\nprint(D)", "h, w = map( int, input().split() )\ns = []\nfor _ in range( h ):\n    s_i = list( str( input() ) )\n    s.append( s_i )\n\ndef connect( v ):\n    con_v = []\n    if v[ 0 ] > 0:\n        if s[ v[ 0 ] - 1 ][ v[ 1 ] ] == \".\":\n            con_v.append( ( v[ 0 ] - 1, v[ 1 ] ) )\n    if v[ 1 ] > 0:\n        if s[ v[ 0 ] ][ v[ 1 ] - 1 ] == \".\":\n            con_v.append( ( v[ 0 ], v[ 1 ] - 1 ) )\n    if v[ 0 ] < h - 1:\n        if s[ v[ 0 ] + 1 ][ v[ 1 ] ] == \".\":\n            con_v.append( ( v[ 0 ] + 1, v[ 1 ] ) )\n    if v[ 1 ] < w - 1:\n        if s[ v[ 0 ] ][ v[ 1 ] + 1 ] == \".\":\n            con_v.append( ( v[ 0 ], v[ 1 ] + 1 ) )\n    return con_v\n\nfrom heapq import heappush, heappop\nINF = 10 ** 10\nVISITED = 1\nNOT_VISITED = 0\ndef longest_bfs( i, j ):\n    cost = [ INF for _ in range( h * w ) ]\n    cost[ i * w + j ] = 0\n    visit = [ NOT_VISITED for _ in range( h * w ) ]\n    queue = [ ( 0, ( i, j ) ) ]\n    while len( queue ) > 0:\n        c, v = heappop( queue )\n        visit[ v[ 0 ] * w + v[ 1 ] ] = VISITED\n        for u in connect( v ):\n            if visit[ u[ 0 ] * w + u[ 1 ] ] == VISITED:\n                continue\n            if cost[ u[ 0 ] * w + u[ 1 ] ] > cost[ v[ 0 ] * w + v[ 1 ] ] + 1:\n                cost[ u[ 0 ] * w + u[ 1 ] ] = cost[ v[ 0 ] * w + v[ 1 ] ] + 1\n                heappush( queue, ( cost[ u[ 0 ] * w + u[ 1 ] ], u ) )\n    return cost\n\nlongest_path = 0\nfor i in range( h ):\n    for j in range( w ):\n        if s[ i ][ j ] == \"#\":\n            continue\n        path_length = longest_bfs( i, j )\n        for p in path_length:\n            if p < INF and p > longest_path:\n                longest_path = p\nprint( longest_path )", "h,w = map(int,input().split())\nC = [list(input()) for i in range(h)]\nstartls = []\n\nfor i in range(h):\n    for j in range(w):\n        if C[i][j] == '.':\n            startls.append([i,j])\n            \ndy_dx = [[1,0],[0,1],[-1,0],[0,-1]]\nans = 0\nfor start in startls:\n    visited = [[-1 for i in range(w)] for i in range(h)]\n    visited[start[0]][start[1]] = 0\n    cost = 0\n    queue = [start]\n    while len(queue) > 0:\n        now = queue.pop(0)\n        cost = visited[now[0]][now[1]]+1\n        for i in range(4):\n            y = now[0]+dy_dx[i][0]\n            x = now[1]+dy_dx[i][1]\n            if 0 <= y < h and 0 <= x < w:\n                if C[y][x] != '#' and visited[y][x] == -1:\n                    visited[y][x] = cost\n                    queue.append([y,x])\n                    ans = max(ans,cost)\nprint(ans)", "from collections import deque\nimport copy\nH, W = list(map(int, input().split()))\nans = 0\n\ndistancelist = []\nfor i in range(H):\n    maze = list(input())\n    tmplst = [0]*W\n    for j in range(W):\n        if maze[j] == '#':\n            tmplst[j] = -1\n\n    distancelist.append(tmplst)\n\nfor x in range(H):\n    for y in range(W):\n        if distancelist[x][y] == -1:\n            continue\n\n        tmpdis = copy.deepcopy(distancelist)\n        d = deque()\n        start = [x, y]\n        d.append(start)\n        while d:\n            h, w = d.popleft()\n            now = tmpdis[h][w]\n            for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n                dh, dw = h+i, w+j\n                if (0 <= dh < H) and (0 <= dw < W):\n                    if (tmpdis[dh][dw] == 0) and [dh, dw] != start:\n                        d.append([dh, dw])\n                        tmpdis[dh][dw] = now + 1\n\n            ans = max(now, ans)\n\n\nprint(ans)\n\n", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\n\ndef bfs(S, sh, sw, dist):\n    dist[sh][sw] = 0\n    queue = deque([(sh, sw)])\n    while queue:\n        h, w = queue.popleft()\n        for i, j in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            y, x = h + i, w + j\n            if S[y][x] == \"#\":\n                continue\n            if dist[y][x] == -1:\n                dist[y][x] = dist[h][w] + 1\n                queue.append((y, x))\n\n\ndef main():\n    H, W = list(map(int, input().split()))\n    S = [None] * (H + 2)\n    S[0] = S[-1] = \"#\" * (W + 2)\n    for i in range(1, H + 1):\n        S[i] = \"\".join([\"#\", input().rstrip(), \"#\"])\n\n    ans = 0\n    for sh in range(1, H + 1):\n        for sw in range(1, W + 1):\n            if S[sh][sw] == \"#\":\n                continue\n            dist = [[-1] * (W + 2) for _ in range(H + 2)]\n            bfs(S, sh, sw, dist)\n            max_dist = max(list(map(max, dist)))\n            ans = max(ans, max_dist)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\nMAX_H = 20\nMAX_W = 20\n\n\nH, W = [int(x) for x in input().split()]\nS = [input() for _ in range(H)]\n\n\ndef valid(i, j, B):\n    return 0 <= i < H and 0 <= j < W and S[i][j] == '.' and not B[i][j]\n\n\ndef bfs(i, j):\n    B = [[False] * W for _ in range(H)]\n    dist = 0\n    q = deque([[i, j, -1]])\n    while len(q) > 0:\n        p = q.popleft()\n        i = p[0]\n        j = p[1]\n        if B[i][j]:\n            continue\n        d = p[2] + 1\n        dist = max(dist, d)\n        B[i][j] = True\n        if valid(i - 1, j, B):\n            q.append([i - 1, j, d])\n        if valid(i + 1, j, B):\n            q.append([i + 1, j, d])\n        if valid(i, j - 1, B):\n            q.append([i, j - 1, d])\n        if valid(i, j + 1, B):\n            q.append([i, j + 1, d])\n    return dist\n\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '.':\n            ans = max(ans, bfs(i, j))\nprint(ans)\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\nimport string\n\ndef main():\n    H,W = i_map()\n    dy_dx=[[1,0],[0,1],[-1,0],[0,-1]]\n    rc=[input() for i in range(H)]\n    ans = 0\n\n    for sy in range(H):\n        for sx in range(W):\n            if rc[sy][sx] == \"#\":\n                continue\n            dist=[[-1 for _ in range(W)] for _ in range(H)]\n            dist[sy][sx] = 0\n            d=deque()\n            d.append([sx,sy])\n            while d:\n                nx, ny = d.popleft()\n                for dy,dx in dy_dx:\n                    y,x = ny+dy,nx+dx\n                    if 0<=y<H and 0<=x<W and rc[y][x] != \"#\" and dist[y][x] == -1:\n                        dist[y][x] = dist[ny][nx] + 1\n                        d.append([x,y])\n            ans = max(ans, max(list(itertools.chain.from_iterable(dist))))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\n\nh, w = map(int, input().split())\ntizu = [input() for _ in range(h)]\nans = 0\ndirections = [[1, 0], [-1, 0], [0, 1], [0, -1]]\nfor i in range(h):\n    for j in range(w):\n        if tizu[i][j] == \"#\":\n            continue\n        check = [[False for _ in range(w)] for _ in range(h)]\n        check[i][j] = True\n        queue = deque()\n        queue.append([i, j])\n        queue.append(0)\n        while queue:\n            pos = queue.popleft()\n            ans_sub = queue.popleft()\n            for dh, dw in directions:\n                nh = pos[0] + dh\n                nw = pos[1] + dw\n                if nh == -1 or nh == h or nw == -1 or nw == w:\n                    continue\n                if tizu[nh][nw] == \"#\":\n                    continue\n                if check[nh][nw]:\n                    continue\n                check[nh][nw] = True\n                queue.append([nh, nw])\n                queue.append(ans_sub + 1)\n        ans = max(ans, ans_sub)\nprint(ans)", "import queue\ndef main():\n    h, w = list(map(int, input().split()))\n    st = [[1]*(w+2) for _ in range(h+2)]\n    for i in range(h):\n        s = input()\n        for j in range(w):\n            if s[j] == \".\":\n                st[i+1][j+1] = 0\n    ans = 0\n    for i in range(1, h+2):\n        for j in range(1, w+2):\n            if st[i][j] == 0:\n                fs = [[float(\"inf\")]*(w+2) for _ in range(h+2)]\n                q = queue.Queue()\n                fs[i][j] = 0\n                q.put([i, j])\n                while not q.empty():\n                    y, x = q.get()\n                    if st[y-1][x] == 0 and fs[y-1][x] > fs[y][x] + 1:\n                        fs[y-1][x] = fs[y][x] + 1\n                        q.put([y-1, x])\n                    if st[y+1][x] == 0 and fs[y+1][x] > fs[y][x] + 1:\n                        fs[y+1][x] = fs[y][x] + 1\n                        q.put([y+1, x])\n                    if st[y][x-1] == 0 and fs[y][x-1] > fs[y][x] + 1:\n                        fs[y][x-1] = fs[y][x] + 1\n                        q.put([y, x-1])\n                    if st[y][x+1] == 0 and fs[y][x+1] > fs[y][x] + 1:\n                        fs[y][x+1] = fs[y][x] + 1\n                        q.put([y, x+1])\n                    if ans < fs[y][x]:\n                        ans = fs[y][x]\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\nh, w = list(map(int, input().split()))\ngrid = [input() for _ in range(h)]\n\nans = 0\n\nfor startx in range(w):\n    for starty in range(h):\n        if grid[starty][startx] == \"#\":\n            continue\n\n        dist = [[10000]*w for _ in range(h)]\n        dist[starty][startx] = 0\n        maxDist = 0\n\n        q = deque([(startx, starty)])\n\n        while q:\n            curx, cury = q.popleft()\n\n            adj = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n            for xo, yo in adj:\n                x, y = curx + xo, cury + yo\n\n                if x < 0 or x >= w or y < 0 or y >= h:\n                    continue\n                if grid[y][x] == \"#\":\n                    continue\n\n                newDist = dist[cury][curx] + 1\n                if newDist < dist[y][x]:\n                    dist[y][x] = newDist\n                    q.append((x, y))\n\n                    maxDist = max(maxDist, newDist)\n\n        ans = max(ans, maxDist)\n\nprint(ans)", "from collections import deque\nH, W = map(int, input().split())\nf = [[s==\".\" for s in input()] for h in range(H)]\nv = [[-1 for w in range(W)] for h in range(H)]\n\nans = 0\ndh = [-1, 0, 0, 1]\ndw = [0, 1, -1, 0]\nfor h in range(H):\n  for w in range(W):\n    if not f[h][w]:\n      continue\n    tmp = 0\n    v = [[-1 for w in range(W)] for h in range(H)]\n    Q = deque([(h, w)])\n    v[h][w] = 0\n    while Q:\n      nh, nw = Q.popleft()\n      for i in range(4):\n        if 0<=nh+dh[i]<H and 0<=nw+dw[i]<W and f[nh+dh[i]][nw+dw[i]] and v[nh+dh[i]][nw+dw[i]] == -1:\n          v[nh+dh[i]][nw+dw[i]] = v[nh][nw]+1\n          tmp = v[nh+dh[i]][nw+dw[i]]\n          Q.append((nh+dh[i], nw+dw[i]))\n      #for a in v:\n      #  print(a)\n    ans = max(ans, tmp)\nprint(ans)", "#\u5e45\u512a\u5148\u63a2\u7d22\nimport copy\nH,W=map(int,input().split())\nMAZE=[0]*H\nfor i in range(H):\n  MAZE[i]=list(str(input()))\n\ndx=[1,0,-1,0]\ndy=[0,1,0,-1]\n\ndef solve_maze(sy,sx):\n  #\u591a\u6b21\u5143\u914d\u5217\u306fdeepcopy\u3092\u4f7f\u308f\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n  MAZE1=copy.deepcopy(MAZE)\n  MAZE1[sy][sx]='#'\n  queue=[]\n  queue.append([sy,sx])\n  d=[[100000000]*W for i in range(H)]\n  d[sy][sx]=0\n  while len(queue)>0:\n    #Q\u3092\u53d6\u308a\u51fa\u3059\n    Q=queue.pop(0)\n    move=d[Q[0]][Q[1]]\n\n    #4\u65b9\u5411\u3092\u30eb\u30fc\u30d7\u3059\u308b\n    for j in range(4):\n      y=Q[0]+dy[j]\n      x=Q[1]+dx[j]\n      if 0<=y<=(H-1) and 0<=x<=(W-1) and MAZE1[y][x] == '.':\n        queue.append([y,x])\n        MAZE1[y][x] = '#'\n        d[y][x] = move+1\n  return move\n\nd_max=0\nfor i in range(H):\n  for j in range(W):\n    if MAZE[i][j]=='.':\n      d=solve_maze(i,j)\n      if d>d_max:\n        d_max=d\nprint(d_max)", "H, W = list(map(int, input().split()))\nmaze = [input() for i in range(H)]\n\ndirection = [\n    (0, 1),\n    (1, 0),\n    (-1, 0),\n    (0, -1)\n]\n\n\ndef bfs(sy, sx):\n    reached = [[-1] * W for _ in range(H)]\n    reached[sy][sx] = 0\n    from collections import deque\n    que = deque([[sy, sx]])\n    #d_max = 0\n    while que:\n        iy, ix = que.popleft()\n        for d in direction:\n            tx, ty = ix + d[0], iy + d[1]\n            if tx >= W or ty >= H or tx < 0 or ty < 0:\n                continue\n            if reached[ty][tx] != -1 or maze[ty][tx] == '#':\n                continue\n            reached[ty][tx] = reached[iy][ix] + 1\n            #d_max = max(reached[ty][tx], d_max)\n            que.append([ty, tx])\n    d_max = 0\n    for i in range(H):\n        for j in range(W):\n            d_max = max(d_max,reached[i][j])\n\n    return d_max\n\n\nans = 0\n\nfor i in range(H):\n    for j in range(W):\n        if maze[i][j] == '.':\n            ans = max(ans, bfs(i, j))\n\n# for i in range(H):\n#     for j in range(i, W):\n#         for k in range(H):\n#             for l in range(k, W):\n#                 if maze[i][j] == '#' or maze[k][l] == '#':\n#                     continue\n#                 else:\n#                     ans = max(ans, bfs(i, j, k, l))\nprint(ans)\n", "import collections\n\nH, W = [int(n) for n in input().split()]\nMAZE = []\nfor i in range(H):\n    MAZE.append(list(input()))\n\ndef bfs(start_x, start_y):\n    d = [[-1] * W for i in range(H)]\n\n    dx_dy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    que = collections.deque([])\n    que.append((start_x, start_y))\n\n    d[start_x][start_y] = 0\n    cnt = 0\n    while(que):\n        p = que.popleft()\n        for dx, dy in dx_dy:\n            nx = p[0] + dx\n            ny = p[1] + dy\n\n            if 0 <= nx < H and 0 <= ny < W and MAZE[nx][ny] != '#' and d[nx][ny] == -1:\n                que.append((nx, ny))\n                d[nx][ny] = d[p[0]][p[1]] + 1\n            \n                cnt = max(cnt, d[p[0]][p[1]] + 1)\n        \n    return cnt\n\nmax_count = 0\nfor i in range(H):\n    for j in range(W):\n        if MAZE[i][j] == '#':\n            continue\n        count = bfs(i, j)\n        max_count = max(count, max_count)\n\nprint(max_count)", "H,W=list(map(int,input().split()))\nl=[list(input()) for i in range(H)]\nl_count=[[0]*W for i in range(H)]\nfrom collections import deque\ndef answer(st_X,st_Y):#X,Y\u5ea7\u6a19\u3092\u6307\u5b9a\u3057\u3066\u305d\u3053\u304b\u3089\u306e\u8ddd\u96e2\u3092\u8003\u3048\u308b\n   tmp_X,tmp_Y=st_X,st_Y\n   que=deque([[tmp_X,tmp_Y]])\n   after=set()\n   while que:#\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u3092\u6570\u3048\u306a\u304c\u3089\u884c\u3063\u305f\u3053\u3068\u306e\u306a\u3044\u5834\u6240\u3092\u63a2\u7d22\u3059\u308b\n      tmp_X,tmp_Y=que.popleft()\n      nu=l_count[tmp_Y][tmp_X]\n      after.add((tmp_X,tmp_Y))\n      if tmp_X>0 and l[tmp_Y][tmp_X-1]==\".\" and (tmp_X-1,tmp_Y) not in after and [tmp_X-1,tmp_Y] not in que:\n         l_count[tmp_Y][tmp_X-1]=nu+1\n         que.append([tmp_X-1,tmp_Y])\n      if tmp_Y>0 and l[tmp_Y-1][tmp_X]==\".\" and (tmp_X,tmp_Y-1) not in after and [tmp_X,tmp_Y-1] not in que:\n         l_count[tmp_Y-1][tmp_X]=nu+1\n         que.append([tmp_X,tmp_Y-1])\n      if tmp_X<W-1 and l[tmp_Y][tmp_X+1]==\".\" and (tmp_X+1,tmp_Y) not in after and [tmp_X+1,tmp_Y] not in que:\n         l_count[tmp_Y][tmp_X+1]=nu+1\n         que.append([tmp_X+1,tmp_Y])\n      if tmp_Y<H-1 and l[tmp_Y+1][tmp_X]==\".\" and (tmp_X,tmp_Y+1) not in after and [tmp_X,tmp_Y+1] not in que:\n         l_count[tmp_Y+1][tmp_X]=nu+1\n         que.append([tmp_X,tmp_Y+1])\nans=0\nfor i in range(H):\n   for j in range(W):\n      if l[i][j]==\".\":\n         l_count=[[0]*W for i in range(H)]\n         answer(j,i)\n         tmp=max(sum(l_count,[]))\n         ans=max(ans,tmp)\nprint(ans)", "H,W=map(int,input().split())\nS=[list(input())for _ in range(H)]\n\nfrom collections import deque\nimport math\n\n\ndef bfs(h,w,sy,sx,S):\n    maze=[[10**9]*(W)for _ in range(H)]\n\n    maze[sy-1][sx-1]=0\n    que=deque([[sy-1,sx-1]])\n    count=0\n    while que:\n        y,x=que.popleft()\n        for i,j in [(1,0),(0,1),(-1,0),(0,-1)]:\n            nexty,nextx=y+i,x+j\n            if 0<=nexty<h and 0<=nextx<w:\n                dist1=S[nexty][nextx]\n                dist2=maze[nexty][nextx]\n            else:\n                continue\n            if dist1!='#':\n                if dist2>maze[y][x]+1:\n                    maze[nexty][nextx]=maze[y][x]+1\n                    count=max(count,maze[nexty][nextx])\n                    que.append([nexty,nextx])\n    return count\n\nans=0\nfor sy in range(H):\n    for sx in range(W):\n        if S[sy][sx]=='.':\n            now=bfs(H,W,sy+1,sx+1,S)\n            ans=max(ans,now)\n\nprint(ans)", "from collections import deque\n\nH,W=map(int,input().split())\nS=[input() for _ in range(H)]\nans=0\nd=deque([])\nfor i in range(H):\n  for j in range(W):\n    if S[i][j]=='#':\n      continue\n    d.append((i,j,0))\n    visited=[[-1]*W for _ in range(H)]\n    visited[i][j]=0\n    while d:\n      x,y,c=d.popleft()\n      for dx,dy in [(0,1),(1,0),(0,-1),(-1,0)]:\n        nx,ny=x+dx,y+dy\n        if 0<=nx<H and 0<=ny<W and visited[nx][ny]==-1 and S[nx][ny]=='.':\n          visited[nx][ny]=c+1\n          d.append((nx,ny,c+1))\n    ans=max(ans,c)\nprint(ans)", "# \u6df1\u3055\u512a\u5148\u63a2\u7d22\u306b\u3088\u308b\u8ff7\u8def\u306e\u6700\u77ed\u8ddd\u96e2\u8a08\u7b97\n\n\nimport sys\nimport copy\nimport queue\n\n# \u518d\u5e30\u4e0a\u9650\nsys.setrecursionlimit(10 ** 6)\n\n\n# \u6700\u77ed\u8ddd\u96e2\u30e1\u30e2\n# 0#4#\n# 123\n# 23#\u306e\u3088\u3046\u306a\u6700\u7d42\u7d50\u679c\u306e\u305f\u3081\u306e\u30e1\u30e2\n# \u30b9\u30bf\u30fc\u30c8\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u683c\u7d0d\n\ndef answer_sheet(meiro):\n    return copy.deepcopy(meiro)\n\n\n# \u3010\u5468\u308a\u306e\u70b9\u306e\u53d6\u5f97\uff09\n# \u5ea7\u6a19\u304c\u4e0e\u3048\u3089\u308c\u308b\u3068\u3001\u4e0a\u4e0b\u5de6\u53f3\u306e4\u70b9\u3092\u5f97\u308b\u3002\n# \u5883\u754c\u3092\u8d85\u3048\u305f\u5834\u5408\u306f\u30ab\u30c3\u30c8\u3055\u308c\u308b\u3002\ndef get_around_point(point, h, w):\n    around_points = []\n\n    for ij in [(-1,0),(0,1),(1,0),(0,-1)]:\n        i,j=ij\n        new_i = point[0] + i\n        new_j = point[1] + j\n        if 0 <= new_i < h and 0 <= new_j < w:\n            around_points.append([new_i, new_j])\n    return around_points\n\n\n# \u3042\u308b\u70b9\u304c\u9053\u304b\u3069\u3046\u304b\u3092\u5224\u5225\u3059\u308b\ndef walkable(point, meiro):\n    i = point[0]\n    j = point[1]\n    if meiro[i][j] == \".\":\n        return True\n    return False\n\n\n# \u3042\u308b\u70b9\u304c\u884c\u3063\u305f\u3053\u3068\u3042\u308b\u304b\u3069\u3046\u304b\ndef never_had_been(point, sheet):\n    if sheet[point[0]][point[1]] == \".\":\n        return True\n    else:\n        return False\n\n\n# \u30ad\u30e5\u30fc\u306b\u3001\u3042\u308b\u70b9\u306e\u5468\u308a\u306e\u884c\u3063\u305f\u3053\u3068\u306e\u306a\u3044\u9053\u3092\u8ffd\u52a0\u3057\u3001\u30b7\u30fc\u30c8\u306b\u8ddd\u96e2\u3092\u8a18\u5165\ndef add_load_2_queue(point, h, w, meiro, sheet, que):\n    around_points = get_around_point(point, h, w)\n    for around_point in around_points:\n        if walkable(around_point, meiro) and never_had_been(around_point, sheet):\n            que.put(around_point)\n            sheet[around_point[0]][around_point[1]] = sheet[point[0]][point[1]] + 1\n    return sheet, que\n\n\n# \u30dd\u30a4\u30f3\u30c8\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u305d\u306e\u5468\u308a\u306e\u9053\u3092\u30ad\u30e5\u30fc\u306b\u8ffd\u52a0\u3057\u3001\u30b7\u30fc\u30c8\u306b\u8a18\u5165\u3001\u6b21\u306e\u30ad\u30e5\u30fc\u3092\u53d6\u308a\u51fa\u3057\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\u3002\u30ad\u30e5\u30fc\u304c\u306a\u304f\u306a\u308b\u307e\u3067\u7d9a\u3051\u3001\u30b7\u30fc\u30c8\u3092\u8fd4\u3059\u3002\ndef step(point, h, w, meiro, sheet, que):\n    sheet, que = add_load_2_queue(point, h, w, meiro, sheet, que)\n    if que.empty():\n        return sheet\n    next_point = que.get()\n    return step(next_point, h, w, meiro, sheet, que)\n\n\n# \u30b7\u30fc\u30c8\u306f\u3001\u884c\u3051\u306a\u3044\u5834\u6240\u306e\u5834\u5408\u306f\"#\"\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u305f\u3081-1\u306b\u5909\u63db\ndef hash2minus(sheet):\n    new_sheet = []\n    for gyou in sheet:\n        new_gyou = []\n        for item in gyou:\n            if item == \"#\":\n                new_gyou.append(-1)\n            else:\n                new_gyou.append(item)\n        new_sheet.append(new_gyou)\n    return new_sheet\n\n\n# -------\u30e1\u30a4\u30f3\u95a2\u6570---------\n# \u30b9\u30bf\u30fc\u30c8\u3092\u6c7a\u3081\u305f\u5834\u5408\u306e\u3001\u5404\u5834\u6240\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u8868\u3059\u30b7\u30fc\u30c8\u3092\u51fa\u529b\n# \u884c\u3051\u306a\u3044\u5834\u6240\u306e\u5834\u5408\u306f-1\n# \u5165\u529b\n# start \u958b\u59cb\u5ea7\u6a19\u306e\u30ea\u30b9\u30c8(\u4f8b\uff1a[1,2])\n# h \u8ff7\u8def\u306e\u9ad8\u3055\n# w \u8ff7\u8def\u306e\u5e45\n# meiro \u8ff7\u8def\u306e\u6587\u5b57\u5217\u30ea\u30b9\u30c8\ndef min_dis(start, h, w, meiro):\n    sheet = answer_sheet(meiro)\n    que = queue.Queue()\n    sheet[start[0]][start[1]] = 0\n    return hash2minus(step(start, h, w, meiro, sheet, que))\n\n\nimport numpy as np\n\nh, w = [int(i) for i in input().split()]\nmeiro = []\n\nfor i in range(h):\n    meiro.append(list(input()))\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if meiro[i][j] == \".\":\n            ans = max(ans, np.max(np.array(min_dis([i,j], h, w, meiro))))\n\nprint(ans)\n", "from collections import deque\nh, w = map(int, input().split())\nma = [[\"#\" for _ in range(w+2)] for _ in range(h+2)]\nfor i in range(h):\n    tmp = list(input())\n    for j in range(w):\n        ma[i+1][j+1] = tmp[j]\nans = 0\nfor i in range(1, h+1):\n    for j in range(1, w+1):\n        if ma[i][j] == \"#\":\n            continue\n        elif ma[i][j] == \".\":\n            p = [[-1 for _ in range(w+2)] for _ in range(h+2)]\n            p[i][j] = 0\n            q = deque()\n            q.append([i, j])\n            while q:\n                y, x = q.popleft()\n                if ma[y+1][x] == \".\" and p[y+1][x] == -1:\n                    p[y+1][x] = p[y][x] + 1\n                    q.append([y+1, x])\n                if ma[y-1][x] == \".\" and p[y-1][x] == -1:\n                    p[y-1][x] = p[y][x] + 1\n                    q.append([y-1, x])\n                if ma[y][x+1] == \".\" and p[y][x+1] == -1:\n                    p[y][x+1] = p[y][x] + 1\n                    q.append([y, x+1])\n                if ma[y][x-1] == \".\" and p[y][x-1] == -1:\n                    p[y][x-1] = p[y][x] + 1\n                    q.append([y, x-1])\n            for l in range(h+2):\n                ans = max(ans, max(p[l]))\n            # ans = max(ans, max(max(p)))\nprint(ans)", "from collections import deque\nimport copy\nH,W=map(int,input().split())\n\ninf=1000000000\nfield=[]\nfor i in range(H):\n  row=list(input())\n  for j in range(len(row)):\n    if row[j]=='#':row[j]=-1\n    else:row[j]=inf\n  field.append(row)\nans=inf\n\ndef isIn(x,y):\n  if x<0 or x>=W:return False\n  if y<0 or y>=H:return False\n  return True\nvector=[[0,1],[0,-1],[1,0],[-1,0]]\nans=0\nfor i in range(H):\n  for j in range(W):\n    if field[i][j]==-1:continue\n    l=deque([[j,i]])\n    f=copy.deepcopy(field)\n    f[i][j]=0\n    tmp=0\n    #print('--start--')\n    while l:\n      x,y=l.popleft()\n      #print(x,y)\n      #i,j\u3092\u8a2a\u554f\n      for v in vector:\n        if not isIn(x+v[1],y+v[0]):continue\n        if f[y+v[0]][x+v[1]]<=tmp:continue\n        f[y+v[0]][x+v[1]]=f[y][x]+1\n        l.append([x+v[1],y+v[0]])\n        tmp=max(f[y+v[0]][x+v[1]],tmp)\n    ans=max(ans,tmp)\nprint(ans)", "from collections import deque\n\nh, w = map(int, input().split())\ns = [list(input()) for _ in range(h)]\n\nsl = []\nflag = False\nfor i in range(h):\n    for j in range(w):\n        if s[i][j] == '.':\n            sl.append([i, j])\n\nq = deque()\ndire = [(0, 1), (0, -1), (1, 0), (-1, 0)]\nans = 0\nfor sh, sw in sl:\n    c = [[0]*w for _ in range(h)]\n    q.append((sh, sw, 0))\n    while q:\n        ph, pw, k = q.pop()\n        if c[ph][pw] == 0:\n            ans = max(ans, k)\n            c[ph][pw] = 1\n            for dh, dw in dire:\n                hdh, wdw = ph+dh, pw+dw\n                if 0 <= hdh < h and 0 <= wdw < w and c[hdh][wdw] == 0:\n                    if s[hdh][wdw] == '.':\n                        q.appendleft((hdh, wdw, k+1))\n\nprint(ans)", "from collections import deque\nh, w = map(int, input().split())\nma = [[\"#\" for _ in range(w+2)] for _ in range(h+2)]\nfor i in range(h):\n    tmp = list(input())\n    for j in range(w):\n        ma[i+1][j+1] = tmp[j]\nans = 0\nfor i in range(1, h+1):\n    for j in range(1, w+1):\n        if ma[i][j] == \"#\":\n            continue\n        elif ma[i][j] == \".\":\n            p = [[-1 for _ in range(w+2)] for _ in range(h+2)]\n            p[i][j] = 0\n            q = deque()\n            q.append([i, j])\n            while q:\n                y, x = q.popleft()\n                if ma[y+1][x] == \".\" and p[y+1][x] == -1:\n                    p[y+1][x] = p[y][x] + 1\n                    q.append([y+1, x])\n                if ma[y-1][x] == \".\" and p[y-1][x] == -1:\n                    p[y-1][x] = p[y][x] + 1\n                    q.append([y-1, x])\n                if ma[y][x+1] == \".\" and p[y][x+1] == -1:\n                    p[y][x+1] = p[y][x] + 1\n                    q.append([y, x+1])\n                if ma[y][x-1] == \".\" and p[y][x-1] == -1:\n                    p[y][x-1] = p[y][x] + 1\n                    q.append([y, x-1])\n            for l in range(1, h+1):\n                ans = max(ans, max(p[l]))\n            # ans = max(ans, max(max(p)))\nprint(ans)"]
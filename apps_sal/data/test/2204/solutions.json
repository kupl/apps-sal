["import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor test in range(t):\n    if test:\n        input()\n    n, m = list(map(int, input().split()))\n    a = [-1] * m\n    b = [-1] * m\n\n    for i in range(m):\n        a[i], b[i] = list(map(int, input().split()))\n\n    l = [(a[i],0,i) for i in range(m)] + [(b[i],1,i) for i in range(m)]\n    l.sort(reverse = True)\n    \n    count = 0\n    tot = 0\n    best = 0\n    used = [False] * m\n    for good, typ, ind in l:\n        if typ == 0:\n            count += 1\n            tot += good\n            used[ind] = True\n            if count == n:\n                best = max(best, tot)\n                break\n        else:\n            curr = tot\n            curr += good * (n - count)\n            if not used[ind]:\n                curr -= good\n                curr += a[ind]\n            best = max(curr,best)\n    print(best)\n", "import sys,heapq\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    if _!=0:\n        s=input()\n    n,m=list(map(int,input().split()))\n    flower=[]#b,a\n    for i in range(m):\n        a,b=list(map(int,input().split()))\n        flower.append((b,a))\n    flower.sort()\n    S=0\n    N=0\n    ans=-1\n    que=[]\n    if n==1:\n        ans=max(flower[i][1] for i in range(m))\n        print(ans)\n        continue\n    for i in range(m):\n        b,a=flower[i]\n        while que and b>que[0]:\n            A=heapq.heappop(que)\n            S-=A\n            N-=1\n        temp=b*(n-1-N)+a+S\n        ans=max(temp,ans)\n        if N==n-1:\n            if que[0]<a:\n                S-=que[0]\n                heapq.heappop(que)\n                S+=a\n                heapq.heappush(que,a)\n        else:\n            heapq.heappush(que,a)\n            S+=a\n            N+=1\n\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n,m=map(int,input().split())\n    a=[0]*m\n    b=[0]*m\n    acop=[0]*m\n    bcop=[0]*m\n    for i in range(m):\n        a[i],b[i]=map(int,input().split())\n        acop[i]=a[i]\n        bcop[i]=[b[i],i]\n    acop.sort(reverse=True)\n    bcop.sort(reverse=True)\n    mx=0\n    i=0\n    su=0\n    for j in range(m):\n        bi=bcop[j][0]\n        ii=bcop[j][1]\n        ai=a[ii]\n        while i<m and acop[i]>bi:\n            su+=acop[i]\n            i+=1\n        maxi=ai\n        if i<n:\n            maxi+=su\n            if i+1<n:\n                maxi+=(n-i-1)*bi\n            if ai>bi:\n                maxi+=bi\n                maxi-=ai\n            mx=max(maxi,mx)\n    if n<=m:\n        sun=0\n        for i in range(n):\n            sun+=acop[i]\n        mx=max(mx,sun)\n    print(mx)\n    blank=input()", "import bisect\nt = int(input())\nfor _ in range(t):\n    n, m = list(map(int, input().split()))\n    flowers = []\n    flowers_a = []\n    max_b = 0\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        flowers.append((a, b))\n    \n    flowers.sort()\n    flowers_b = []\n    for i in range(m):\n        flowers_a.append(flowers[i][0])\n        flowers_b.append(flowers[i][1])\n    \n    val = 0\n    prefix_sum = [0]\n    for x in flowers_a:\n        prefix_sum.append(prefix_sum[-1] + x)\n    for i in range(m):\n        idx = bisect.bisect_left(flowers_a, flowers_b[i])\n        options = m - idx\n        if options >= n:\n            temp = prefix_sum[-1] - prefix_sum[-n - 1]\n            val = max(val, temp)\n            continue\n        else:\n            temp = prefix_sum[-1] - prefix_sum[-options - 1]\n            remaining = n - options\n            if idx <= i:\n                temp += flowers_b[i] * remaining\n            else:\n                temp += flowers_a[i] + flowers_b[i] * (remaining - 1)\n            \n            val = max(val, temp)\n                \n\n    print(val)\n    \n    if _ != t - 1:\n        blank_line = input()\n", "from bisect import bisect_left\n\nt = int(input())\n\nfor case in range(t):\n    n, m = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for _ in range(m)]\n\n    aa = [e for e, _ in ab]\n    aa.sort()\n    acc = [0] * (m + 1)\n    for i in range(m, 0, -1):\n        acc[i-1] = acc[i] + aa[i-1]\n\n    if n > m:\n        ans = 0\n    else:\n        ans = sum(aa[-n:])\n\n    for a, b in ab:\n        i = bisect_left(aa, b)\n        cnt = min(m - i, n)\n        sm = acc[m - cnt]\n        sm += b * (n - cnt)\n        if a < b:\n            sm -= b\n            sm += a\n\n        ans = max(ans, sm)\n\n    print(ans)\n\n    if case != t - 1:\n        input()\n", "import sys\n\ndef input():\n\treturn sys.stdin.readline().rstrip()\n\ndef input_split():\n\treturn [int(i) for i in input().split()]\n\ntestCases = int(input())\nanswers = []\nfor test in range(testCases):\n\t#take input\n\tn, m = input_split()\n\tarr = []\n\tbarr = []\n\tfor _ in range(m):\n\t\ta, b = input_split()\n\t\tarr.append(a)\n\t\tbarr.append(b)\n\n\ttemp1 = [(arr[i], 1, i) for i in range(m)]\n\ttemp2 = [(barr[i], 2, i) for i in range(m)]\n\n\tmixed = temp1 + temp2\n\tmixed.sort()\n\tmixed.reverse()\n\n\tpointer = 0\n\tdone = 0\n\tmaxi = 0\n\tscore = 0\n\tunlocked = [False for i in range(m)]\n\twhile(done < n and pointer < 2*m):\n\t\tval, typ, index = mixed[pointer]\n\t\tif typ == 1:\n\t\t\tdone += 1\n\t\t\tscore += val\n\t\t\tunlocked[index] = True\n\t\t\tif done == n:\n\t\t\t\tmaxi = max(score, maxi) \n\t\telse:\n\t\t\tif not unlocked[index]:\n\t\t\t\tpotential = score + (n - done - 1)*val + arr[index]\n\t\t\telse:\n\t\t\t\tpotential = score + (n - done)*val \n\t\t\t\t#can break here?\n\t\t\tmaxi = max(potential, maxi)\n\n\t\tpointer += 1\n\n\tans = maxi\n\tanswers.append(ans)\n\n\tif test != testCases - 1:\n\t\tblank = input()\n\nprint(*answers, sep = '\\n')\n"]
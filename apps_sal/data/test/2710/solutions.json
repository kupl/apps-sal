["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass ford_fulkerson:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return \"to : {0} cap : {1} rev : {2}\".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.size[_from]\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        self.used[v] = True\n        for i in range(len(self.G[v])):\n            edge = self.G[v][i]\n            if self.used[edge.to] is False and edge.cap > 0:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.used = [False for _ in range(self.V)]\n            f = self.dfs(s, t, float('inf'))\n            if f == 0:\n                return flow\n            flow += f\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nff = ford_fulkerson(N*2+2)\nS = 1\nT = N + 1\n\nfor i in range(M):\n    p,q = list(map(int, input().split()))\n    ff.add_edge(p,T+q-1,10**9)\n    ff.add_edge(q,T+p-1,10**9)\n\nfor i in range(N):\n    ff.add_edge(i+1,T+i,10**9)\n    ff.add_edge(0,S+i,A[i])\n    ff.add_edge(T+i,2*N+1,B[i])\n\nans = [[0  for i in range(N)] for j in range(N)]\nff.max_flow(0,2*N+1)\n\nfor i in range(1,N+1):\n    for v in ff.G[i]:\n        if v.to != 0:\n            ans[i-1][v.to-T] = ff.G[v.to][v.rev].cap\n\nif M == 0:\n    if A == B:\n        print('YES')\n        for i in range(N):\n            for j in range(N):\n                ans [i][j] = A[i] if i == j else 0\n        for a in ans:\n            print(' '.join(map(str,a)))\n    else:\n        print('NO')\nelse:\n    if [sum([ans[i][j] for i in range(N)]) for j in range(N)] == B:\n        print('YES')\n        for a in ans:\n            print(' '.join(map(str,a)))\n    else:\n        print('NO')\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass ford_fulkerson:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return \"to : {0} cap : {1} rev : {2}\".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.size[_from]\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        self.used[v] = True\n        for i in range(len(self.G[v])):\n            edge = self.G[v][i]\n            if self.used[edge.to] is False and edge.cap > 0:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.used = [False for _ in range(self.V)]\n            f = self.dfs(s, t, float('inf'))\n            if f == 0:\n                return flow\n            flow += f\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nff = ford_fulkerson(N*2+2)\nS = 1\nT = N + 1\n\nfor i in range(M):\n    p,q = list(map(int, input().split()))\n    ff.add_edge(p,T+q-1,10**9)\n    ff.add_edge(q,T+p-1,10**9)\n\nfor i in range(N):\n    ff.add_edge(i+1,T+i,10**9)\n    ff.add_edge(0,S+i,A[i])\n    ff.add_edge(T+i,2*N+1,B[i])\n\nans = [[0  for i in range(N)] for j in range(N)]\nff.max_flow(0,2*N+1)\n\nfor i in range(1,N+1):\n    for v in ff.G[i]:\n        if v.to != 0:\n            ans[i-1][v.to-T] = ff.G[v.to][v.rev].cap\n\nif sum(A) != sum(B):\n    print('NO')\n    quit()\nif [sum([ans[i][j] for i in range(N)]) for j in range(N)] == B:\n    print('YES')\n    for a in ans:\n        print(' '.join(map(str,a)))\nelse:\n    print('NO')\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Ford_Fulkerson:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return \"(to: {0} cap: {1} rev: {2})\".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.size[_from]\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        self.used[v] = True\n        for i in range(self.size[v]):\n            edge = self.G[v][i]\n            if self.used[edge.to] is False and edge.cap > 0:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.used = [False for _ in range(self.V)]\n            f = self.dfs(s, t, float('inf'))\n            if f == 0:\n                return flow\n            flow += f\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nff = Ford_Fulkerson(N*2+2)\nS = 1\nT = N + 1\n\nfor i in range(M):\n    p,q = list(map(int, input().split()))\n    ff.add_edge(p,T+q-1,10**9)\n    ff.add_edge(q,T+p-1,10**9)\n\nfor i in range(N):\n    ff.add_edge(i+1,T+i,10**9)\n    ff.add_edge(0,S+i,A[i])\n    ff.add_edge(T+i,2*N+1,B[i])\n\nans = [[0  for i in range(N)] for j in range(N)]\nff.max_flow(0,2*N+1)\n\nfor i in range(1,N+1):\n    for v in ff.G[i]:\n        if v.to != 0:\n            ans[i-1][v.to-T] = ff.G[v.to][v.rev].cap\n\nif sum(A) != sum(B):\n    print('NO')\n    quit()\nif [sum([ans[i][j] for i in range(N)]) for j in range(N)] == B:\n    print('YES')\n    for a in ans:\n        print(' '.join(map(str,a)))\nelse:\n    print('NO')\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Dinic:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return \"(to: {0} cap: {1} rev: {2})\".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def bfs(self,s):\n        level = [-1 for i in range(self.V)]\n        level[s] = 0\n        q = []\n        q.append(s)\n        while q != []:\n            v = q.pop(0)\n            for u in self.G[v]:\n                if u.cap > 0 and level[u.to] < 0:\n                    level[u.to] = level[v] + 1\n                    q.append(u.to)\n        return level\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        while self.iterator[v] < self.size[v]:\n            edge = self.G[v][self.iterator[v]]\n            if edge.cap > 0 and self.level[v] < self.level[edge.to]:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][self.iterator[v]].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n            self.iterator[v] += 1\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.level = self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iterator = [0 for i in range(self.V)]\n            while True:\n                f = self.dfs(s, t, float('inf'))\n                if f == 0:\n                    break\n                flow += f\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\n# ff = Ford_Fulkerson(N*2+2)\nff = Dinic(N*2+2)\nS = 1\nT = N + 1\n\nfor i in range(M):\n    p,q = list(map(int, input().split()))\n    ff.add_edge(p,T+q-1,10**9)\n    ff.add_edge(q,T+p-1,10**9)\n\nfor i in range(N):\n    ff.add_edge(i+1,T+i,10**9)\n    ff.add_edge(0,S+i,A[i])\n    ff.add_edge(T+i,2*N+1,B[i])\n\nans = [[0  for i in range(N)] for j in range(N)]\nff.max_flow(0,2*N+1)\n\nfor i in range(1,N+1):\n    for v in ff.G[i]:\n        if v.to != 0:\n            ans[i-1][v.to-T] = ff.G[v.to][v.rev].cap\n\nif sum(A) != sum(B):\n    print('NO')\n    quit()\nif [sum([ans[i][j] for i in range(N)]) for j in range(N)] == B:\n    print('YES')\n    for a in ans:\n        print(' '.join(map(str,a)))\nelse:\n    print('NO')\n", "#!/usr/bin/env python3\n\nfrom collections import defaultdict\nimport sys\n\nN, M = input().split(' ')\nN, M = int(N), int(M)\nA = input().split(' ')\nA = list(map(int, A))\nB = input().split(' ')\nB = list(map(int, B))\n\nif (sum(A) != sum(B)):\n    print('NO')\n    return\n\nneighbours = defaultdict(lambda: defaultdict(int))\nflow = defaultdict(int)\n\ndef left(i):\n    return 'l ' + str(i)\n\ndef right(i):\n    return 'r ' + str(i)\n\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        flow[left(i), right(j)] = 0\n        flow[right(i), left(j)] = 0\n\nfor i, capacity in enumerate(A):\n    neighbours['source'][left(i + 1)] = capacity\nfor i, capacity in enumerate(B):\n    neighbours[right(i + 1)]['sink'] = capacity\nfor i in range(1, N+1):\n    neighbours[left(i)][right(i)] = float('inf')\n\n\nfor m in range(M):\n    p, q = input().split(' ')\n    p, q = int(p), int(q)\n    neighbours[left(p)][right(q)] = float('inf')\n    neighbours[left(q)][right(p)] = float('inf')\n\ndef search():\n    visited = set()\n    def dfs(v):\n        if v in visited:\n            return False\n        if v == 'sink':\n            return ['sink']\n        visited.add(v)\n        for n in neighbours[v]:\n            capacity = neighbours[v][n]\n            if capacity > 0:\n                res = dfs(n)\n                if res:\n                    return [v] + res\n    return dfs('source')\n\n\ntotal_flow = 0\n\ndef augment_edge(a, b, amount):\n    neighbours[a][b] -= amount\n    neighbours[b][a] += amount\n    flow[a, b] += amount\n\ndef augment(path):\n    capacity = float('inf')\n    for i in range(len(path) - 1):\n        capacity = min(capacity, neighbours[path[i]][path[i+1]])\n    # print('augment', path, capacity)\n    for i in range(len(path) - 1):\n        augment_edge(path[i], path[i+1], capacity)\n    nonlocal total_flow\n    total_flow += capacity\n\nwhile True:\n    res = search()\n    if res is None:\n        break\n    else:\n        augment(res)\n\nif (total_flow == sum(A)):\n    print(\"YES\")\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            print(flow[left(i), right(j)] - flow[right(j), left(i)], end=\" \")\n        print()\nelse:\n    print(\"NO\")", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\n\n\ndef yes(A):\n    print(\"YES\")\n    for l in A:\n        print(\" \".join([str(x) for x in l]))\ndef no():\n    print(\"NO\")\n\nclass FlowEdge:\n    def __init__(self, v,w,capacity):\n        self.v=v\n        self.w=w\n        self.capacity = capacity\n        self.flow = 0\n    def other(self, v):\n        return self.w if self.v==v else self.v\n    def residual_capacity_to(self, v):\n        \"\"\"residual capacity toward v\"\"\"\n        if v == self.v:\n            return self.flow\n        elif v == self.w:\n            return self.capacity-self.flow\n        else:\n            raise Exception()\n    def add_residual_flow_to(self, v, delta):\n        \"\"\"add delta flow toward v\"\"\"\n        if v == self.v:\n            self.flow -= delta\n        elif v == self.w:\n            self.flow += delta\n        else:\n            raise Exception()\n    def __str__(self):\n        return \"{}-{}: {:.0f}/{:.0f} \".format(self.v,self.w,\n                                              self.flow, self.capacity)\nclass FlowNetwork:\n    def __init__(self,nv=0):\n        self.nv = nv\n        self.al = ELIST(self.nv)\n    def add_edge(self, e): # directed edge\n        self.al[e.v].append(e)\n        self.al[e.w].append(e)\n    def reset(self):\n        for v in self.al:\n            for e in v: e.flow = 0\nclass FordFulkerson:\n    def __init__(self,g,s,t): # graph, source, target\n        self.g = g\n        self.s = s\n        self.t = t\n        self.value = 0\n        infty = 1e9\n        while self.has_augmenting_path():\n            bottle = infty\n            v = t\n            while v!=s:\n                bottle = min(bottle, self.edge_to[v].residual_capacity_to(v))\n                v = self.edge_to[v].other(v)\n            v = t\n            while v != s:\n                self.edge_to[v].add_residual_flow_to(v,bottle)\n                v = self.edge_to[v].other(v)\n            self.value += bottle\n    def has_augmenting_path(self, log=False):\n        self.edge_to = [None] * self.g.nv\n        self.marked = [False] * self.g.nv\n        queue = deque()\n        queue.append(self.s)\n        self.marked[self.s] = True\n        if log: i=0\n        while len(queue) != 0:\n            v = queue.popleft()\n            for e in self.g.al[v]:\n                w = e.other(v)\n                if e.residual_capacity_to(w) > 0 and not self.marked[w]:\n                    self.edge_to[w] = e\n                    self.marked[w] = True\n                    queue.append(w)\n        return self.marked[self.t]\n\n\ndef main(info=0):\n    n,m = VI()\n    a = VI()\n    b = VI()\n    s,t = 0, 1+2*n\n    fg = FlowNetwork(nv=n*2+2)\n    infty = 10000000\n    for i in range(n):\n        fg.add_edge(FlowEdge(s,1+i,a[i]))\n        fg.add_edge(FlowEdge(1+n+i,t,b[i]))\n        fg.add_edge(FlowEdge(1+i,1+n+i,infty))\n    for i in range(m):\n        u,v = VI()\n        fg.add_edge(FlowEdge(1+u-1,1+n+v-1,infty))\n        fg.add_edge(FlowEdge(1+v-1,1+n+u-1,infty))\n\n    ff = FordFulkerson(fg,s,t)\n    if ff.value == sum(a) == sum(b):\n        A = LIST(n,n)\n        for i in range(n):\n            for e in fg.al[i+1]:\n                A[i][e.w-n-1] = e.flow\n        yes(A)\n    else:\n        no()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport sys\n\n\nclass FordFulkerson:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n\n    def __init__(self, V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        self.used[v] = True\n        for i in range(self.size[v]):\n            edge = self.G[v][i]\n            if self.used[edge.to] is False and edge.cap > 0:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        result = 0\n        while True:\n            self.used = [False for _ in range(self.V)]\n            f = self.dfs(s, t, math.inf)\n            if f == 0:\n                return result\n            result += f\n\n\ndef solve(r, w):\n    \"\"\"\n    :param r:\n    :param w:\n    :return:\n    \"\"\"\n    num_cities, num_roads = list(map(int, input().split()))\n    original = list(map(int, input().split()))\n    result = list(map(int, input().split()))\n\n    flow_ford = FordFulkerson(num_cities * 2 + 2)\n    T = num_cities + 1\n\n    for i in range(num_roads):\n        p, q = list(map(int, input().split()))\n        flow_ford.add_edge(p, T + q - 1, 10 ** 9)\n        flow_ford.add_edge(q, T + p - 1, 10 ** 9)\n\n    for i in range(num_cities):\n        flow_ford.add_edge(i + 1, T + i, 10 ** 9)\n        flow_ford.add_edge(0, 1 + i, original[i])\n        flow_ford.add_edge(T + i, 2 * num_cities + 1, result[i])\n\n    ans = [[0 for i in range(num_cities)] for j in range(num_cities)]\n    flow_ford.max_flow(0, 2 * num_cities + 1)\n\n    for i in range(1, num_cities + 1):\n        for v in flow_ford.G[i]:\n            if v.to != 0:\n                ans[i - 1][v.to - T] = flow_ford.G[v.to][v.rev].cap\n\n    if sum(original) != sum(result):\n        print('NO')\n        return\n\n    if [sum([ans[i][j] for i in range(num_cities)]) for j in range(num_cities)] == result:\n        print('YES')\n        for a in ans:\n            print(' '.join(map(str, a)))\n    else:\n        print('NO')\n\n\n# -------\n# main\n# -------\n\ndef __starting_point():\n    solve(sys.stdin, sys.stdout)\n\n__starting_point()", "import math\n\ndef dfs(u, t, bottleneck, graph, visited):\n    if u == t: return bottleneck\n    visited[u] = True\n    for e in graph[u]:\n        residual = e.cap - e.flow\n        if residual > 0 and not visited[e.v]:\n            augment = dfs(e.v, t, min(bottleneck, residual), graph, visited)\n            if augment > 0:\n                e.flow += augment\n                e.reverse.flow -= augment\n                return augment\n    return 0\n\n\ndef max_flow(G, s, t):\n    flow = 0\n    augment = 1 # for while to pass\n    while augment > 0:\n        visited = [False] * len(G)\n        augment = dfs(s, t, math.inf, G, visited)\n        flow += augment\n    return flow\n\n\nclass Edge:\n    def __init__(self, v, cap, reverse=None):\n        self.cap = cap\n        self.v = v\n        self.reverse = reverse\n        self.flow = 0\n\n    def __repr__(self):\n        return str(self.v) + ' (' + str(self.flow) + ')'\n\n\nn, m = list(map(int, input().strip().split()))\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\nsum_a = sum(a)\nsum_b = sum(b)\n\ngraph = [[] for _ in range(2*n + 2)]\n\nfor i, c in enumerate(a, 1):\n    graph[0].append(Edge(i, c))\n\nt = len(graph) - 1\nfor i, c in enumerate(b, 1+n):\n    graph[i].append(Edge(t, c))\n\nmax_cap = math.inf\nfor i in range(1, len(a) + 1):\n    graph[i].append(Edge(i+n, max_cap)) # self edges\n\nfor _ in range(m):\n    u,v = list(map(int, input().strip().split()))\n    graph[u].append(Edge(v+n, max_cap))\n    graph[v].append(Edge(u+n, max_cap))\n\n\nfor u, edges in enumerate(graph):\n    for edge in edges:\n        if edge.reverse is None:\n            new_edge = Edge(u, 0, edge)\n            edge.reverse = new_edge\n            graph[edge.v].append(new_edge)\n\nif sum_a == sum_b and sum_a == max_flow(graph, 0, len(graph)-1):\n    print('YES')\n    for i in range(1, n + 1):\n        flows = [0] * n\n        tot_out = 0\n        for edge in graph[i]:\n            if edge.v != i + n and edge.flow > 0:\n                flows[edge.v - n - 1] = edge.flow\n                tot_out += edge.flow\n        flows[i-1] = a[i - 1] - tot_out\n        print(' '.join(map(str, flows)))\nelse:\n    print('NO')\n", "class edge:\n    def __init__(self, node, capacity, flow, rev):\n        self.node = node\n        self.capacity = capacity\n        self.flow = flow\n        self.rev = rev\n    def __str__(self):\n        return (\",\".join([str(x) for x in\n                          [self.node,\n                           self.capacity,\n                           self.flow]])\n                if self.capacity else \"Back Edge\")\nclass flow:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for _ in range(n)]\n        \n    def adde(self, u, v, w):\n        x = edge(v,w,0, None)\n        y = edge(u,0,0,x)\n        x.rev = y\n        self.g[u].append(x)\n        self.g[v].append(y)\n    \n    def dfs(self, u, t, bottleneck):\n        if u == t: return bottleneck\n        self.visited[u] = True\n        for e in self.g[u]:\n            v = e.node\n            residual = e.capacity - e.flow\n            if residual > 0 and not self.visited[v]:\n                augment = self.dfs(v, t, min(bottleneck, residual))\n                if augment > 0:\n                    e.flow += augment\n                    e.rev.flow -= augment\n                    return augment\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        augment = 0\n        while True:\n            self.visited = [False for _ in range(self.n)]\n            augment = self.dfs(s,t,float('inf'))\n            flow += augment\n            if augment <= 0:\n                break\n        return flow\n\n    def reprnode(self, u):\n        sz = self.n//2-1\n        rpr = [0]*(sz)\n        for e in self.g[u]:\n            if e.capacity:\n                try:\n                    rpr[e.node-sz-1] = e.flow\n                except: pass            \n        return \" \".join([str(x) for x in rpr])\n    \ndef __starting_point():\n    n,m = [int(x) for x in input().split()]\n    s = 0\n    t = 2*n+1\n    f = flow(t+1)\n    atot = 0\n    btot = 0\n    array_a = [int(x) for x in input().split()]\n    array_b = [int(x) for x in input().split()]\n    for i,(a,b) in enumerate(zip(array_a,array_b), start = 1):\n        f.adde(s,i,a)\n        f.adde(i+n,t,b)\n        f.adde(i,i+n, float('inf'))\n        atot += a\n        btot += b\n    for _ in range(m):\n        p,q = [int(x) for x in input().split()]\n        f.adde(p,q+n,float('inf'))\n        f.adde(q,p+n,float('inf'))\n    if atot == f.max_flow(s,t) and atot == btot:\n        print(\"YES\")\n        for i in range(1,n+1):\n            print(f.reprnode(i))\n    else:\n        print(\"NO\")\n    \n\n__starting_point()", "\"\"\"\nAuthor: Andrew Jakubowicz\nProblem: Soldier and Traveling\nlink: http://codeforces.com/problemset/problem/546/E#\n\nn cities and m roads.\nEach city has an army.\n\ni-th city has a_i soldiers.\n\nSoldiers can move at **most** one road or stay put.\n\n\n\n\"\"\"\nimport math\n\nclass Edge:\n    def __init__(self, cap, flow, target, rev = None):\n        self.capacity = cap\n        self.flow = flow\n        self.target = target\n        # Reversed edges have capacity of 0\n        self.rev = rev\n\n    def __repr__(self):\n        return \"<e: (cap: {}, target: {}, flow: {}>\".format(self.capacity, self.target, self.flow)\n\n\ndef dfs(u, t, bottleneck, visited, graph):\n    if u == t:\n        return bottleneck\n    visited[u] = True\n    for e in graph[u]:\n        residual = e.capacity - e.flow\n        if residual > 0 and not visited[e.target]:\n            augment = dfs(e.target,t, min(bottleneck, residual), visited, graph)\n            if augment > 0:\n                e.flow += augment\n                e.rev.flow -= augment\n                return augment\n    return 0\n\ndef ford_fulkerson(g, s, t):\n    \"\"\"\n    Solves maximum flow problem.\n    :param g: graph\n    :param s: start\n    :param t: end\n    :return: flow\n    \"\"\"\n    flow = 0\n    while True:\n        Visited = [False for _ in range(len(g))]\n        augment = dfs(s,t, math.inf , Visited, g)\n        flow += augment\n        if augment <= 0:\n            break\n\n    return flow\n\ndef print_graph(graph):\n    for i, edges in enumerate(graph):\n        print(\"{}: [{}]\".format(i, edges))\n\n\ndef __starting_point():\n\n    [n,m] = list(map(int, input(\"\").split()))\n\n    city_soldiers = list(map(int, input(\"\").split()))\n    want_soldiers = list(map(int, input(\"\").split()))\n\n\n    # index 0 is start. Index 2n+1 is sink node.\n    graph = [[] for _ in range(2*n+2)]\n\n    # Source to initial cities.\n    for i,soldiers in enumerate(city_soldiers):\n        graph[0].append(Edge(soldiers, 0, i+1))\n\n    # Set up edges to sink.\n    for i,soldiers in enumerate(want_soldiers):\n        graph[n+i+1].append(Edge(soldiers,0,2*n+1))\n\n    # Set up paths\n    for _ in range(m):\n        [s,t] = list(map(int, input(\"\").split()))\n        graph[t].append(Edge(1000, 0, n+s))\n        graph[s].append(Edge(1000, 0, n+t))\n\n    # Set up staying soldiers.\n    for i in range(n):\n        i = i+1\n        graph[i].append(Edge(city_soldiers[i-1], 0, n+i))\n\n    # Create residual graph\n    residualGraph = [[] for _ in range(len(graph))]\n    # Generate the residual network\n    for u, edges in enumerate(graph):\n        for e in edges:\n            target = e.target\n            # Circular link\n            reverse = Edge(0, 0, u, e)\n            e.rev = reverse\n\n            residualGraph[u].append(e)\n            residualGraph[target].append(reverse)\n\n    flow = ford_fulkerson(residualGraph, 0, 2*n+1)\n    if sum(want_soldiers) != flow or sum(city_soldiers) != sum(want_soldiers):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        adjmatrix = [[0 for _ in range(n)] for _ in range(n)]\n\n        for u, edges in enumerate(residualGraph[1:2* n + 1]):\n            u = u+1\n            for e in edges:\n                if e.capacity == 1000 or (u+n == e.target and e.target != 2*n+1):\n                    adjmatrix[u-1][e.target-n-1] = e.flow\n\n\n        for row in adjmatrix:\n            print(\" \".join(map(str, row)))\n\n\n__starting_point()", "# coding:utf-8\n\"\"\"\n CF546E \n\"\"\"\nimport sys\nimport copy\nimport os\n\n# sys.stdin = open(os.path.join(os.path.dirname(__file__), 'in1'))\n\nn, m = map(lambda x :int(x), input().strip().split())\na =[_ for _ in map(lambda x :int(x), input().strip().split())]\nb = [_ for _ in map(lambda x :int(x), input().strip().split())]\nINF =  2 << 40\nG = [ [0 for _ in range(2*n+2)] for i in range(2*n+2)]\nF = [ [0 for _ in range(2*n+2)] for i in range(2*n+2)]\n\nfor i in range(1,n+1):\n    G[0][i] = a[i-1]\n    G[i][i+n] = INF\n    G[i+n][2*n+1] = b[i-1]\n\nfor i in range(m):\n    p, q = map(lambda x :int(x), input().strip().split())\n    # add\n    G[p][q+n] = INF\n    G[q][p+n] = INF\n\n    \nVs = [False for i in range(2*n+2)]\n\ntotal = 0\ndef dfs(st, t, v):\n    nonlocal find, V, minv, total, G\n    V[st] = True\n    i = 0\n    while i <= 2*n+1:\n        if G[st][i] > 0 and not V[i]:\n            # print(i)\n            if i == t:\n                V[i] = True\n                find = True\n                minv = min([v, G[st][i]])\n                G[st][i] =  G[st][i] - minv\n                G[i][st] =  G[i][st] + minv\n                F[st][i] += minv\n                if F[i][st] > 0:\n                    F[i][st] -= minv\n                total += minv\n                return minv\n            mv = dfs(i, t, min([v,G[st][i]])) \n            if mv > 0:\n                F[st][i] += minv\n                if F[i][st] > 0:\n                    F[i][st] -= minv\n                G[st][i] =  G[st][i] - minv\n                G[i][st] =  G[i][st] + minv\n                return mv\n        i += 1    \n    return 0  \nwhile True:\n    find = False\n    V = copy.deepcopy(Vs)\n    minv = (2 << 40)\n    mv = dfs(0,2*n+1, minv)\n    if not find:\n        break\nif total == sum(a) and total == sum(b):\n    print(\"YES\")\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if i == j:\n                print(F[i][i+n], end=' ')\n            else:            \n                print(F[i][j+n] , end=' ')\n        print()        \nelse:\n    print(\"NO\")\n", "from collections import deque\nimport sys\n\nn, m = input().split(' ')\nn, m = int(n), int(m)\n\nstarts = [int(x) for x in input().split(' ')]\nends = [int(x) for x in input().split(' ')]\nnum_soldiers = sum(ends)\nif sum(starts) != sum(ends):\n    print(\"NO\")\n    return\n# 0 for s, 1 for t, 2 + i for starts, 2 + n + i for ends\nf_size = 2 + 2 * n\nflow_matrix = [[0] * f_size for _ in range(f_size)]\nedge_list = [[] for _ in range(f_size)]\n\ndef get_index(i, is_start):\n    if is_start:\n        return 2 + i\n    else:\n        return 2 + n + i\n\nfor i in range(n):\n    flow_matrix[0][get_index(i, True)] = starts[i]\n    flow_matrix[get_index(i, False)][1] = ends[i]\n    flow_matrix[get_index(i, True)][get_index(i, False)] = num_soldiers\n\nfor i in range(m):\n    ends = input().split(' ')\n    a, b = int(ends[0]), int(ends[1])\n    a -= 1\n    b -= 1\n    flow_matrix[get_index(a, True)][get_index(b, False)] = num_soldiers\n    flow_matrix[get_index(b, True)][get_index(a, False)] = num_soldiers\n\nflow_matrix_copy = [x.copy() for x in flow_matrix]\nfor i in range(f_size):\n    for j in range(f_size):\n        if flow_matrix[i][j] != 0 or flow_matrix[j][i] != 0:\n            edge_list[i].append(j)\n\ndef run_bfs(m):\n    parent = [None for _ in range(len(m))]\n    flow_from_s = [None for _ in range(len(m))]\n    q = deque([])\n    q.append(0)\n    parent[0] = 0\n    flow_from_s[0] = 2**20\n\n    found_target = False\n    t = 1\n    while len(q) > 0 and not found_target:\n        front = q.popleft()\n        for neighbor in edge_list[front]:\n            if flow_matrix[front][neighbor] > 0 and parent[neighbor] is None:\n                parent[neighbor] = front\n                flow_from_s[neighbor] = min(flow_from_s[front], flow_matrix[front][neighbor])\n                q.append(neighbor)\n                if neighbor == t:\n                    found_target = True\n                    break\n\n    if not found_target:\n        return 0\n    cur = t\n    flow = flow_from_s[t]\n    while parent[cur] != cur:\n        prev = parent[cur]\n        flow_matrix[prev][cur] -= flow\n        flow_matrix[cur][prev] += flow\n        cur = prev\n    return flow\n\ndef run_flow(m):\n    total_flow = 0\n    while True:\n        flow = run_bfs(m)\n        total_flow += flow\n        if flow == 0:\n            break\n    return total_flow\n\nif run_flow(flow_matrix) == num_soldiers:\n    print(\"YES\")\n    for i in range(n):\n        for j in range(n):\n            num_along = flow_matrix_copy[get_index(i, True)][get_index(j, False)] - flow_matrix[get_index(i, True)][get_index(j, False)]\n            print(str(num_along), end=' ')\n        print('')\nelse:\n    print(\"NO\")\n\n", "from collections import deque\nfrom sys import stdin, stdout\n\nMAX_SOLDIERS = 200000\n\n\ndef solve():\n    n, m = [int(_) for _ in stdin.readline().rstrip().split()]\n    all_lines = stdin.readlines()\n    start_vals = [int(_) for _ in all_lines[0].split()]\n    end_vals = [int(_) for _ in all_lines[1].split()]\n    if sum(start_vals) != sum(end_vals):\n        stdout.write('NO\\n')\n        return\n    graph = [[0] * (n * 2 + 2) for _ in range(n * 2 + 2)]\n    edges = [(_, _) for _ in range(1, n + 1)]\n    for i in range(n):\n        graph[0][i + 1] = start_vals[i]\n        graph[n + i + 1][n * 2 + 2 - 1] = end_vals[i]\n        graph[i + 1][n + i + 1] = start_vals[i]\n    for index in range(m):\n        i, j = [int(_) for _ in all_lines[2 + index].split()]\n        graph[i][n + j] = start_vals[i - 1]\n        graph[j][n + i] = start_vals[j - 1]\n        edges.append((i, j))\n    flow = maxflow(graph)\n    if flow != sum(start_vals):\n        stdout.write('NO\\n')\n        return\n    mat = [[0] * n for _ in range(n)]\n    for (i, j) in edges:\n        mat[i - 1][j - 1] = start_vals[i - 1] - graph[i][n + j]\n        mat[j - 1][i - 1] = start_vals[j - 1] - graph[j][n + i]\n    stdout.write('YES\\n')\n    for i in mat:\n        stdout.write(' '.join(str(_) for _ in i))\n        stdout.write('\\n')\n\n\ndef bfs(graph, parent):\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    queue = deque([])\n    queue.append(0)\n    visited[0] = True\n    while queue:\n        curr_node = queue.popleft()\n        for i in range(num_nodes):\n            if graph[curr_node][i] > 0 and (not visited[i]):\n                queue.append(i)\n                visited[i] = True\n                parent[i] = curr_node\n                if i == num_nodes - 1:\n                    return True\n    return visited[num_nodes - 1]\n\n\ndef maxflow(graph):\n    num_nodes = len(graph)\n    parent = [-1] * num_nodes\n    ans = 0\n    while bfs(graph, parent):\n        curr_flow = MAX_SOLDIERS + 1\n        curr_node = num_nodes - 1\n        while curr_node != 0:\n            curr_flow = min(curr_flow, graph[parent[curr_node]][curr_node])\n            curr_node = parent[curr_node]\n        ans += curr_flow\n        curr_node = num_nodes - 1\n        while curr_node != 0:\n            par = parent[curr_node]\n            graph[par][curr_node] -= curr_flow\n            graph[curr_node][par] += curr_flow\n            curr_node = par\n    return ans\n\n\nsolve()\nstdout.close()\n", "from collections import deque\nfrom sys import stdin, stdout\n\nmaxNum = 200000\n\ndef retrieveFlow(theMap):\n    countNodes = len(theMap)\n    parent = [-1] * countNodes\n    ans = 0\n    while bfs(theMap, parent):\n        curr_flow = maxNum + 1\n        temp = countNodes - 1\n        while temp != 0:\n            curr_flow = min(curr_flow, theMap[parent[temp]][temp])\n            temp = parent[temp]\n        ans += curr_flow\n        temp = countNodes - 1\n        while temp != 0:\n            par = parent[temp]\n            theMap[par][temp] -= curr_flow\n            theMap[temp][par] += curr_flow\n            temp = par\n    return ans\n\ndef bfs(theMap, parent):\n    queue = deque([])\n    queue.append(0)\n    countNodes = len(theMap)\n    beenThere = [False] * countNodes\n    beenThere[0] = True\n\n    while queue:\n        temp = queue.popleft()\n        for i in range(countNodes):\n            if theMap[temp][i] > 0 and (not beenThere[i]):\n                queue.append(i)\n                beenThere[i] = True\n                parent[i] = temp\n                if i == countNodes - 1:\n                    return True\n    return beenThere[countNodes - 1]\n\ndef soldierTraveling():\n    n, m = [int(_) for _ in stdin.readline().rstrip().split()]\n    readAll = stdin.readlines()\n    firstNum = [int(_) for _ in readAll[0].split()]\n    LastNum = [int(_) for _ in readAll[1].split()]\n\n    if sum(LastNum) != sum(firstNum):\n        stdout.write('NO\\n')\n        return\n\n    theMap = [[0] * (n * 2 + 2) for _ in range(n * 2 + 2)]\n    theEdges = [(_, _) for _ in range(1, n + 1)]\n\n    for i in range(n):\n        theMap[0][i + 1] = firstNum[i]\n        theMap[n + i + 1][n * 2 + 2 - 1] = LastNum[i]\n        theMap[i + 1][n + i + 1] = firstNum[i]\n\n    for index in range(m):\n        i, j = [int(_) for _ in readAll[2 + index].split()]\n        theMap[i][n + j] = firstNum[i - 1]\n        theMap[j][n + i] = firstNum[j - 1]\n        theEdges.append((i, j))\n\n    theMaxFlow = retrieveFlow(theMap)\n\n    if sum(firstNum) != theMaxFlow:\n        stdout.write('NO\\n')\n        return\n\n    tempM = [[0] * n for _ in range(n)]\n\n    for (i, j) in theEdges:\n        tempM[i - 1][j - 1] = firstNum[i - 1] - theMap[i][n + j]\n        tempM[j - 1][i - 1] = firstNum[j - 1] - theMap[j][n + i]\n    stdout.write('YES\\n')\n\n    for i in tempM:\n        stdout.write(' '.join(str(_) for _ in i))\n        stdout.write('\\n')\n\nsoldierTraveling()\nstdout.close()\n", "from collections import defaultdict\nimport sys\n\nN, M = input().split(' ')\nN, M = int(N), int(M)\nA = input().split(' ')\nA = list(map(int, A))\nB = input().split(' ')\nB = list(map(int, B))\n\nif (sum(A) != sum(B)):\n    print('NO')\n    return\n\nneighbours = defaultdict(lambda: defaultdict(int))\nflow = defaultdict(int)\n\ndef left(i):\n    return 'l ' + str(i)\n\ndef right(i):\n    return 'r ' + str(i)\n\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        flow[left(i), right(j)] = 0\n        flow[right(i), left(j)] = 0\n\nfor i, capacity in enumerate(A):\n    neighbours['source'][left(i + 1)] = capacity\nfor i, capacity in enumerate(B):\n    neighbours[right(i + 1)]['sink'] = capacity\nfor i in range(1, N+1):\n    neighbours[left(i)][right(i)] = float('inf')\n\n\nfor m in range(M):\n    p, q = input().split(' ')\n    p, q = int(p), int(q)\n    neighbours[left(p)][right(q)] = float('inf')\n    neighbours[left(q)][right(p)] = float('inf')\n\ndef search():\n    visited = set()\n    def dfs(v):\n        if v in visited:\n            return False\n        if v == 'sink':\n            return ['sink']\n        visited.add(v)\n        for n in neighbours[v]:\n            capacity = neighbours[v][n]\n            if capacity > 0:\n                res = dfs(n)\n                if res:\n                    return [v] + res\n    return dfs('source')\n\n\ntotal_flow = 0\n\ndef augment_edge(a, b, amount):\n    neighbours[a][b] -= amount\n    neighbours[b][a] += amount\n    flow[a, b] += amount\n\ndef augment(path):\n    capacity = float('inf')\n    for i in range(len(path) - 1):\n        capacity = min(capacity, neighbours[path[i]][path[i+1]])\n    # print('augment', path, capacity)\n    for i in range(len(path) - 1):\n        augment_edge(path[i], path[i+1], capacity)\n    nonlocal total_flow\n    total_flow += capacity\n\nwhile True:\n    res = search()\n    if res is None:\n        break\n    else:\n        augment(res)\n\nif (total_flow == sum(A)):\n    print(\"YES\")\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            print(flow[left(i), right(j)] - flow[right(j), left(i)], end=\" \")\n        print()\nelse:\n    print(\"NO\")", "import math\n\nclass Edge:\n    def __init__(self, c, f, t, rev = None):\n        self.capacity = c\n        self.flow = f\n        self.target = t\n        # Reversed edges have capacity of 0\n        self.rev = rev\n\n    def __repr__(self):\n        return \"<e: (cap: {}, target: {}, flow: {}>\".format(self.capacity, self.target, self.flow)\n\n\ndef search(u, t, smallest, visited, graph):\n    if u == t:\n        return smallest\n    visited[u] = True\n    for e in graph[u]:\n        residual = e.capacity - e.flow\n        if residual > 0 and not visited[e.target]:\n            augment = search(e.target,t, min(smallest, residual), visited, graph)\n            if augment > 0:\n                e.flow += augment\n                e.rev.flow -= augment\n                return augment\n    return 0\n\ndef fulkerson(g, s, t):\n    flow = 0\n    while True:\n        Visited = [False for _ in range(len(g))]\n        augment = search(s,t, math.inf , Visited, g)\n        flow += augment\n        if augment <= 0:\n            break\n    return flow\n\ndef print_graph(graph):\n    for i, edges in enumerate(graph):\n        print(\"{}: [{}]\".format(i, edges))\ndef main():\n    [n,m] = list(map(int, input(\"\").split()))\n\n    have = list(map(int, input(\"\").split()))\n    need = list(map(int, input(\"\").split()))\n\n\n    # index 0 is start. Index 2n+1 is sink node.\n    graph = [[] for _ in range(2*n+2)]\n\n    # Source to initial cities.\n    for i,soldiers in enumerate(have):\n        graph[0].append(Edge(soldiers, 0, i+1))\n\n    # Set up edges to sink.\n    for i,soldiers in enumerate(need):\n        graph[n+i+1].append(Edge(soldiers,0,2*n+1))\n\n    # Set up paths\n    for _ in range(m):\n        [s,t] = list(map(int, input(\"\").split()))\n        graph[t].append(Edge(1000, 0, n+s))\n        graph[s].append(Edge(1000, 0, n+t))\n\n    # Set up staying soldiers.\n    for i in range(n):\n        i = i+1\n        graph[i].append(Edge(have[i-1], 0, n+i))\n\n    # Create residual graph\n    residualGraph = [[] for _ in range(len(graph))]\n    # Generate residuals\n    for u, edges in enumerate(graph):\n        for e in edges:\n            target = e.target\n            # Circular link\n            reverse = Edge(0, 0, u, e)\n            e.rev = reverse\n\n            residualGraph[u].append(e)\n            residualGraph[target].append(reverse)\n\n    flow = fulkerson(residualGraph, 0, 2*n+1)\n    if sum(need) != flow or sum(have) != sum(need):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        adjmatrix = [[0 for _ in range(n)] for _ in range(n)]\n\n        for u, edges in enumerate(residualGraph[1:2* n + 1]):\n            u = u+1\n            for e in edges:\n                if e.capacity == 1000 or (u+n == e.target and e.target != 2*n+1):\n                    adjmatrix[u-1][e.target-n-1] = e.flow\n\n\n        for row in adjmatrix:\n            print(\" \".join(map(str, row)))\n\n# run this bad boy\ndef __starting_point():\n    main()\n__starting_point()", "INF = 10**5\n\n\nclass Graph:\n\n    def __init__(self, vertices):\n\n        self.vertices = vertices\n        self.graph = [[0 for i in range(vertices)] for j in range(vertices)]\n\n    def BFS(self, s, t, parent):\n\n        visited = [False for i in range(self.vertices)]\n        queue = []\n\n        visited[s] = True\n        queue.append(s)\n\n        while len(queue) > 0:\n\n            vertex = queue.pop(0)\n\n            for i, value in enumerate(self.graph[vertex]):\n                if not visited[i] and value > 0:\n                    queue.append(i)\n                    parent[i] = vertex\n                    visited[i] = True\n\n                    if i == t:\n                        return True\n\n        return False\n\n    def max_flow(self):\n\n        flow = 0\n        parent = [i for i in range(self.vertices)]\n\n        while self.BFS(0, self.vertices - 1, parent):\n\n            min_flow = INF\n            t = self.vertices - 1\n            while t != 0:\n                min_flow = min(min_flow, self.graph[parent[t]][t])\n                t = parent[t]\n\n            flow += min_flow\n\n            t = self.vertices - 1\n\n            while t != 0:\n\n                self.graph[parent[t]][t] -= min_flow\n                self.graph[t][parent[t]] += min_flow\n                t = parent[t]\n\n        return flow\n\n\n\n\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nedges = {}\nfor i in range(m):\n    x, y = map(int, input().split())\n    edges[(x, y)] = True\n\ng = Graph(2 * n + 2)  # s -> 0 , a[i], b[i], t-> 2n+1\n\nfor i in range(1, n + 1):\n    g.graph[0][i] = a[i - 1]\n\nfor x, y in edges:\n    g.graph[x][y + n] = INF\n    g.graph[y][x + n] = INF\n\nfor i in range(1, n + 1):\n    g.graph[i + n][2 * n + 1] = b[i - 1]\n\nfor i in range(1, n + 1):\n    g.graph[i][i + n] = a[i - 1]\n\nmax_flow = g.max_flow()\nif max_flow == sum(a) and sum(a) == sum(b):\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and (edges.get((j, i), False) or edges.get((i, j), False)):\n                print(10**5 - g.graph[i][j + n], end=\" \")\n            elif i != j:\n                print(0, end=\" \")\n            else:\n                print(a[i - 1] - g.graph[i][i + n], end=\" \")\n        print()\n\nelse:\n    print(\"NO\")\n\n\n", "from sys import stdin, stdout, stderr\nfrom collections import deque\n\nn,m = list(map(int,stdin.readline().split()))\nai = [int(x) for x in stdin.readline().split()]\nbi = [int(x) for x in stdin.readline().split()]\n\nN = 2*n+2\nM = 4*m + 6*n\ncap = [None for i in range(M)]\nflow = [0 for i in range(M)]\nadj = [[] for i in range(N)]\n\ns = 0\nt = 2*n+1\n\nINF = 0x3f3f3f3f\n\neid = 0\ndef add_edge(a,b,c):\n  nonlocal eid, adj, cap\n  adj[a].append((b,eid))\n  cap[eid] = c\n  eid += 1\n\nfor i in range(m):\n  a,b = list(map(int,stdin.readline().split()))\n  add_edge(a,n+b,INF)\n  add_edge(n+b,a,0)\n  add_edge(b,n+a,INF)\n  add_edge(n+a,b,0)\nfor i in range(n):\n  add_edge(s,i+1,ai[i])\n  add_edge(i+1,s,0)\n  add_edge(n+i+1,t,bi[i])\n  add_edge(t,n+i+1,0)\n  add_edge(i+1,n+i+1,INF)\n  add_edge(n+i+1,i+1,0)\n\nans = 0\nwhile True:\n  par = [None for i in range(N)]\n  minf = [INF for i in range(N)]\n  bfs = deque()\n  bfs.append(s)\n  par[s] = (-1,-1)\n  while bfs:\n    u = bfs.pop()\n    if u == t:\n      break\n    for v,e in adj[u]:\n      if par[v] is None and flow[e] < cap[e]:\n        bfs.append(v)\n        par[v] = (u,e)\n        minf[v] = min(minf[u], cap[e] - flow[e])\n  v = t\n  if par[t] is None: break\n  while par[v][0] != -1:\n    u,e = par[v]\n    flow[e] += minf[t]\n    flow[e^1] -= minf[t]\n    v = u\n  ans += minf[t]\n\nif ans != sum(ai) or ans != sum(bi):\n  stdout.write('NO\\n')\nelse:\n  stdout.write('YES\\n')\n  grid = [[0 for j in range(n)] for i in range(n)]\n  for u in range(1,n+1):\n    for v,e in adj[u]:\n      if flow[e] > 0 and 1 <= v-n and v-n <= n:\n        grid[u-1][v-n-1] += flow[e]\n  stdout.write('\\n'.join([' '.join([str(x) for x in line]) for line in grid]) + '\\n')\n", "from sys import stdin, stdout, stderr\nfrom collections import deque\n\nn,m = list(map(int,stdin.readline().split()))\nai = [int(x) for x in stdin.readline().split()]\nbi = [int(x) for x in stdin.readline().split()]\n\nN = 2*n+2\nM = 4*m + 6*n\ncap = [None for i in range(M)]\nflow = [0 for i in range(M)]\nadj = [[] for i in range(N)]\nL = []\ncure = []\n\ns = 0\nt = 2*n+1\n\nINF = 0x3f3f3f3f\ndef bfs():\n  nonlocal L, cure\n  L = [INF for i in range(N)]\n  cure = [0 for i in range(N)]\n  q = deque()\n  q.append(s)\n  L[s] = 0\n  while q:\n    u = q.pop()\n    for v,e in adj[u]:\n      if flow[e] < cap[e] and L[v] == INF:\n        q.append(v)\n        L[v] = L[u]+1\n  return L[t] < INF\n\ndef dfs(u,f):\n  if u == t: return f\n  pushed = 0\n  lim = len(adj[u])\n  while cure[u] < lim:\n    v,e = adj[u][cure[u]]\n    if flow[e] < cap[e] and L[v] == L[u]+1:\n      cur = dfs(v, min(cap[e]-flow[e], f-pushed))\n      flow[e] += cur\n      flow[e^1] -= cur\n      pushed += cur\n    if pushed == f: break\n    cure[u] += 1\n  return pushed\n\neid = 0\n\ndef add_edge(a,b,c):\n  nonlocal eid, adj, cap\n  adj[a].append((b,eid))\n  cap[eid] = c\n  eid += 1\n\nfor i in range(m):\n  a,b = list(map(int,stdin.readline().split()))\n  add_edge(a,n+b,INF)\n  add_edge(n+b,a,0)\n  add_edge(b,n+a,INF)\n  add_edge(n+a,b,0)\nfor i in range(n):\n  add_edge(s,i+1,ai[i])\n  add_edge(i+1,s,0)\n  add_edge(n+i+1,t,bi[i])\n  add_edge(t,n+i+1,0)\n  add_edge(i+1,n+i+1,INF)\n  add_edge(n+i+1,i+1,0)\n\nans = 0\nwhile bfs():\n  ans += dfs(s, INF)\n\nif ans != sum(ai) or ans != sum(bi):\n  stdout.write('NO\\n')\nelse:\n  stdout.write('YES\\n')\n  grid = [[0 for j in range(n)] for i in range(n)]\n  for u in range(1,n+1):\n    for v,e in adj[u]:\n      if flow[e] > 0 and 1 <= v-n and v-n <= n:\n        grid[u-1][v-n-1] += flow[e]\n  stdout.write('\\n'.join([' '.join([str(x) for x in line]) for line in grid]) + '\\n')\n", "from sys import stdin, stdout, stderr\nfrom collections import deque\n\n# Dinic class\nINF = 0x3f3f3f3f\nclass Dinic:\n  def __init__(self, N):\n    self.N = N\n    self.e = 0\n    self.cap = []\n    self.flow = []\n    self.eid = []\n    self.adj = [[] for i in range(N)]\n  def add_edge(self, a, b, c, i = -1):\n    self.adj[a].append((b,self.e))\n    self.cap.append(c)\n    self.flow.append(0)\n    self.eid.append(i)\n    self.e += 1\n    self.adj[b].append((a,self.e))\n    self.cap.append(0)\n    self.flow.append(0)\n    self.eid.append(i)\n    self.e += 1\n  def bfs(self, s, t):\n    self.L = [INF for i in range(self.N)]\n    self.nxte = [0 for i in range(self.N)]\n    q = deque()\n    q.append(s)\n    self.L[s] = 0\n    while q:\n      u = q.pop()\n      for v,e in self.adj[u]:\n        if self.flow[e] < self.cap[e] and self.L[v] == INF:\n          q.append(v)\n          self.L[v] = self.L[u] + 1\n    return self.L[t] < INF\n  def dfs(self, u, t, f):\n    if u == t: return f\n    pushed = 0\n    lim = len(self.adj[u])\n    while self.nxte[u] < lim:\n      v,e = self.adj[u][self.nxte[u]]\n      if self.flow[e] < self.cap[e] and self.L[v] == self.L[u] + 1:\n        cur = self.dfs(v, t, min(self.cap[e]-self.flow[e], f-pushed))\n        self.flow[e] += cur\n        self.flow[e^1] -= cur\n        pushed += cur\n      if pushed == f: break\n      self.nxte[u] += 1\n    return pushed\n  def maxflow(self, s, t):\n    ans = 0\n    while self.bfs(s, t):\n      ans += self.dfs(s, t, INF)\n    return ans\n\n# code here\n\nn,m = list(map(int,stdin.readline().split()))\nai = [int(x) for x in stdin.readline().split()]\nbi = [int(x) for x in stdin.readline().split()]\n\ngraph = Dinic(2*n+2)\ns,t = 0, 2*n+1\n\nfor i in range(m):\n  a,b = list(map(int,stdin.readline().split()))\n  graph.add_edge(a, n+b, INF)\n  graph.add_edge(b, n+a, INF)\nfor i in range(n):\n  graph.add_edge(s, i+1, ai[i])\n  graph.add_edge(n+i+1, t, bi[i])\n  graph.add_edge(i+1, n+i+1, INF)\n\nans = graph.maxflow(s, t)\n\nif ans != sum(ai) or ans != sum(bi):\n  stdout.write('NO\\n')\nelse:\n  stdout.write('YES\\n')\n  grid = [[0 for j in range(n)] for i in range(n)]\n  for u in range(1,n+1):\n    for v,e in graph.adj[u]:\n      if graph.flow[e] > 0 and 1 <= v-n and v-n <= n:\n        grid[u-1][v-n-1] += graph.flow[e]\n  stdout.write('\\n'.join([' '.join([str(x) for x in line]) for line in grid]) + '\\n')\n", "from sys import stdin\nfrom collections import deque\n\ndef bfs(g, el, source, dest, pre):\n\tq = deque()\n\tpre.clear()\n\tpre.extend([None] * len(g))\n\tq.append(source)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor e in g[u]:\n\t\t\tv, c, f = el[e][1], el[e][2], el[e][3]\n\t\t\tif pre[v] is None and f < c and v != source:\n\t\t\t\tpre[v] = e\n\t\t\t\tq.append(v)\n\t\tif pre[dest] is not None:\n\t\t\treturn True\n\treturn False\n\ndef max_flow(g, el, source, sink):\n\ttotal_flow = 0\n\tpre = []\n\twhile bfs(g, el, source, sink, pre):\n\t\te = pre[sink]\n\t\tflow = int(1e9)\n\t\tpath = []\n\t\twhile True:\n\t\t\tflow = min(flow, el[e][2] - el[e][3])\n\t\t\tpath.append(e)\n\t\t\te = pre[el[e][0]]\n\t\t\tif e is None:\n\t\t\t\tbreak\n\t\tfor e in path:\n\t\t\tel[e][3] += flow\n\t\t\tel[el[e][4]][3] -= flow\n\t\ttotal_flow += flow\n\treturn total_flow\n\ndef add_edge(g, el, u, v, c):\n\tel.append([u, v, c, 0, len(el) + 1])\n\tel.append([v, u, 0, 0, len(el) - 1])\n\tg[u].append(len(el) - 2)\n\tg[v].append(len(el) - 1)\n\ndef main():\n\tn, m = [int(_) for _ in stdin.readline().split()]\n\ta = [int(_) for _ in stdin.readline().split()]\n\tb = [int(_) for _ in stdin.readline().split()]\n\tg = [[] for _ in range(n * 2 + 2)]\n\tel = []\n\tsource = n * 2\n\tsink = n * 2 + 1\n\tinf = int(1e9)\n\n\tfor line in stdin.readlines():\n\t\tu, v = [int(_) - 1 for _ in line.split()]\n\t\tadd_edge(g, el, u, v + n, inf)\n\t\tadd_edge(g, el, v, u + n, inf)\n\n\tfor i in range(n):\n\t\tadd_edge(g, el, i, i + n, a[i])\n\t\tadd_edge(g, el, source, i, a[i])\n\t\tadd_edge(g, el, i + n, sink, b[i])\n\n\tif sum(a) != sum(b) or max_flow(g, el, source, sink) != sum(a):\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\ttr = [[0 for j in range(n)] for i in range(n)]\n\t\tedges = [e for e in el if e[3] > 0 and e[0] < n * 2 and e[1] < n * 2]\n\t\tfor edge in edges:\n\t\t\tdef rev_idx(u):\n\t\t\t\treturn u if u < n else u - n\n\t\t\ttr[rev_idx(edge[0])][rev_idx(edge[1])] = edge[3]\n\t\tprint('\\n'.join(' '.join(str(x) for x in row) for row in tr))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "from sys import stdin\nfrom collections import deque\n\ndef bfs(g, el, source, dest, pre):\n\tq = deque()\n\tpre.clear()\n\tpre.extend([None] * len(g))\n\tq.append(source)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor e in g[u]:\n\t\t\tv, c, f = el[e][1], el[e][2], el[e][3]\n\t\t\tif pre[v] is None and f < c and v != source:\n\t\t\t\tpre[v] = e\n\t\t\t\tq.append(v)\n\t\tif pre[dest] is not None:\n\t\t\treturn True\n\treturn False\n\ndef max_flow(g, el, source, sink):\n\ttotal_flow = 0\n\tpre = []\n\twhile bfs(g, el, source, sink, pre):\n\t\te = pre[sink]\n\t\tflow = int(1e9)\n\t\tpath = []\n\t\twhile True:\n\t\t\tflow = min(flow, el[e][2] - el[e][3])\n\t\t\tpath.append(e)\n\t\t\te = pre[el[e][0]]\n\t\t\tif e is None:\n\t\t\t\tbreak\n\t\tfor e in path:\n\t\t\tel[e][3] += flow\n\t\t\tel[el[e][4]][3] -= flow\n\t\ttotal_flow += flow\n\treturn total_flow\n\ndef add_edge(g, el, u, v, c):\n\tel.append([u, v, c, 0, len(el) + 1])\n\tel.append([v, u, 0, 0, len(el) - 1])\n\tg[u].append(len(el) - 2)\n\tg[v].append(len(el) - 1)\n\ndef main():\n\tn, m = [int(_) for _ in stdin.readline().split()]\n\ta = [int(_) for _ in stdin.readline().split()]\n\tb = [int(_) for _ in stdin.readline().split()]\n\tg = [[] for _ in range(n * 2 + 2)]\n\tel = []\n\tsource = n * 2\n\tsink = n * 2 + 1\n\tinf = int(1e9)\n\n\tfor line in stdin.readlines():\n\t\tu, v = [int(_) - 1 for _ in line.split()]\n\t\tadd_edge(g, el, u, v + n, inf)\n\t\tadd_edge(g, el, v, u + n, inf)\n\n\tfor i in range(n):\n\t\tadd_edge(g, el, i, i + n, a[i])\n\t\tadd_edge(g, el, source, i, a[i])\n\t\tadd_edge(g, el, i + n, sink, b[i])\n\n\tif sum(a) != sum(b) or max_flow(g, el, source, sink) != sum(a):\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\ttr = [[0 for j in range(n)] for i in range(n)]\n\t\tedges = [e for e in el if e[3] > 0 and e[0] < n * 2 and e[1] < n * 2]\n\t\tfor edge in edges:\n\t\t\tdef rev_idx(u):\n\t\t\t\treturn u if u < n else u - n\n\t\t\ttr[rev_idx(edge[0])][rev_idx(edge[1])] = edge[3]\n\t\tprint('\\n'.join(' '.join(str(x) for x in row) for row in tr))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "# return a path from source to target as well as the\n# bottleneck capacity of links in the path\ndef dfs(graph, capacity, source, target):\n\tfringe = []\n\tfringe.append(([source], 9999999)) # each element in fringe is a tuple (path, bottleneckCapacity)\n\tvisited = set()\n\n\twhile len(fringe) != 0:\n\t\tcurrPath, currBottleneck = fringe.pop()\n\t\tcurrNode = currPath[-1]\n\n\t\t# goal check\n\t\tif currNode == target:\n\t\t\treturn (currPath, currBottleneck)\n\n\t\tif currNode not in visited:\n\t\t\t# expand it\n\t\t\tvisited.add(currNode)\n\t\t\tfor nextNode, capacity in zip(graph[currNode], capacities[currNode]):\n\t\t\t\tif nextNode not in visited and capacity > 0:\n\t\t\t\t\tnextPath = currPath + [nextNode]\n\t\t\t\t\tnextBottleNeck = min(capacity, currBottleneck)\n\t\t\t\t\tfringe.append((nextPath, nextBottleNeck))\n\n\treturn (None, None)\n\n# return the max flow from source to sink in graph\n# capacities will be modified\ndef ford_fulkerson(graph, capacities, source, sink):\n\ttotal = 0 # toal flow\n\twhile True:\n\t\tpath, bottleneck = dfs(graph, capacities, source, sink)\n\n\t\tif path is None: break\n\n\t\ttotal += bottleneck\n\t\t# decrease capacity of each link in path by bottleneck\n\t\t# increase capacity of the inverted version of each link in path by bottleneck\n\t\tfor i in range(len(path) - 1):\n\t\t\tu, v = path[i], path[i+1]\n\t\t\tindexOfVInGraphU = graph[u].index(v)\n\t\t\tcapacities[u][indexOfVInGraphU] -= bottleneck\n\t\t\tindexOfUInGraphV = graph[v].index(u)\n\t\t\tcapacities[v][indexOfUInGraphV] += bottleneck\n\t\t\tassert(capacities[u][indexOfVInGraphU] >= 0 and capacities[v][indexOfUInGraphV] >= 0)\n\n\treturn total\n\n\nn, m = [int(x) for x in input().split(\" \")]\nais = [int(x) for x in input().split(\" \")]\nbis = [int(x) for x in input().split(\" \")]\nif sum(ais) != sum(bis):\n\tprint(\"NO\")\n\treturn\n\ngraph = [[] for _ in range(2*n + 2)]\ncapacities = [[] for _ in range(2*n + 2)]\nINF = 9999999\n\n# add link from source to left column\nfor v in range(1, n+1):\n\tgraph[0].append(v)\n\tcapacities[0].append(ais[v-1])\n# add link from right column to sink\nfor u in range(n+1, 2*n+1):\n\tgraph[u].append(2*n+1)\n\tcapacities[u].append(bis[u-n-1])\n# for link from node i to node n + i b/t two columns\nfor u in range(1, n+1):\n\tgraph[u].append(n+u)\n\tcapacities[u].append(INF)\n\n# add edges b/t two columns\nfor _ in range(m):\n\tu, v = [int(x) for x in input().split(\" \")]\n\t# u -> v AND v -> u\n\t# change index: u -> n + v AND v -> n + u\n\tgraph[u].append(n+v)\n\tcapacities[u].append(INF)\n\n\tgraph[v].append(n+u)\n\tcapacities[v].append(INF)\n\n# augment graph with imaginary links\nfor u in range(2*n+2):\n\tfor v in graph[u]:\n\t\tif u not in graph[v]:\n\t\t\t# add imaginary link v -> u with capacity 0, if not present\n\t\t\tgraph[v].append(u)\n\t\t\tcapacities[v].append(0)\n\n\nmaxFlow = ford_fulkerson(graph, capacities, 0, 2*n+1)\nif maxFlow < sum(ais):\n\tprint(\"NO\")\n\treturn\nelse:\n\tprint(\"YES\")\n\tfor u in range(1, n+1):\n\t\tfor v in range(n+1, 2*n+1):\n\t\t\ttry:\n\t\t\t\t# if u -> v present, which is equivalent to checking if v -> u is present\n\t\t\t\t# the flow = linkCapacity of v -> u\n\t\t\t\tindexOfUInGraphV = graph[v].index(u)\n\t\t\t\tprint(capacities[v][indexOfUInGraphV], end=\" \")\n\t\t\texcept:\n\t\t\t\tprint(0, end=\" \")\n\t\tprint()\n", "import sys\n\ncap = [[0 for i in range(300)] for j in range(300)]\nflow = [[0 for i in range(300)] for j in range(300)]\ninf = 99999999\nvis = [0] * 300\npar = [0] * 300\n\ndef pushflow(v, mf, s):\n    if (v == s):\n        return mf\n    \n    u = par[v]\n    if (cap[u][v] <= 0):\n        mf = min(mf, flow[v][u])\n    else:\n        mf = min(mf, cap[u][v] - flow[u][v])\n    \n    mf = pushflow(u, mf, s)\n    if (cap[u][v] <= 0):\n        flow[v][u] -= mf\n    else:\n        flow[u][v] += mf\n        \n    return mf\n    \ndef bfs(n, m, s, t, adj):\n    maxflow = 0\n    while (1):\n        for i in range(2*n):\n            vis[i] = 0\n        vis[t] = 0\n        q = []\n        q.append(s)\n        vis[s] = 1\n        par[s] = -1\n        pushed = False\n        \n        while (len(q) != 0):\n            cur = q.pop()\n            for i in range(len(adj[cur])):\n                nex = adj[cur][i]\n                if (vis[nex]):\n                    continue\n                if (cap[cur][nex] - flow[cur][nex] <= 0 and flow[nex][cur] <= 0):\n                    continue\n                vis[nex] = 1\n                q.append(nex)\n                par[nex] = cur\n                if nex == t:\n                    maxflow += pushflow(t, inf, s)\n                    pushed = True\n                    break\n                \n            if pushed:\n                break\n        if (not pushed):\n            break\n    return maxflow\n    \ndef main():\n    data = [line.rstrip().split() for line in sys.stdin.readlines()]\n    data = [[int(x) for x in row] for row in data]\n    \n    n = data[0][0]\n    m = data[0][1]\n    \n    s = 2*n\n    t = 2*n + 1\n    adj = [[] for i in range (2*n+10)]\n    summing = 0\n    for i in range(n):\n        u = data[1][i]\n        cap[s][i] = u\n        summing += u\n        adj[s].append(i)\n        adj[i].append(s)\n    \n    check = 0\n    for i in range(n):\n        u = data[2][i]\n        cap[i+n][t] = u\n        check += u\n        adj[i + n].append(t)\n        adj[t].append(i + n)\n    if (summing != check):\n        print(\"NO\")\n        return\n    for i in range(n):\n        cap[i][i + n] = inf\n        adj[i].append(i+n)\n        adj[i+n].append(i)\n    for i in range(m):\n        u = data[i + 3][0]\n        v = data[i + 3][1]\n        u -= 1\n        v -= 1\n        cap[u][v + n] = inf\n        cap[v][u + n] = inf\n        adj[u].append(v + n)\n        adj[v + n].append(u)\n        adj[v].append(u + n)\n        adj[u + n].append(v)\n    check = bfs(n, m, s, t, adj)\n    if (check == summing):\n        print(\"YES\")\n        for i in range(n):\n            for j in range(n):\n                print(flow[i][j + n], end =\" \")\n            print('\\n', end=\"\")\n    else:\n        print(\"NO\")\n\nmain()\n        \n    \n    \n"]
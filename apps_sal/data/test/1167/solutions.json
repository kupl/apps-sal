["from math import *\n\n\ndef ri():\n    return int(input())\n\n\ndef rli():\n    return list(map(int, input().split()))\n\n\nq = ri()\nfor _ in range(q):\n    a, b, c, d, k = rli()\n    x = int(ceil(a / c))\n    y = int(ceil(b / d))\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def solve():\n        a, b, c, d, k = list(map(int, input().split()))\n        x = (a + c - 1) // c\n        y = (b + d - 1) // d\n        if x + y > k:\n            print(-1)\n        else:\n            print(x, y)\n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()\n", "t = int(input())\nfor _ in range(t) :\n    a, b, c, d, k = list(map(int, input().split()))\n    x = (a + c - 1) // c\n    y = (b + d - 1) // d\n    if x + y <= k :\n        print(x, y)\n    else :\n        print(-1)\n", "# Contest: Codeforces Round #592 (Div. 2) (https://codeforces.com/contest/1244)\n# Problem: A: Pens and Pencils (https://codeforces.com/contest/1244/problem/A)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nt = rint()\nfor _ in range(t):\n    a, b, c, d, k = rints()\n    x = (a + c - 1) // c\n    y = (b + d - 1) // d\n    if x + y > k:\n        print(-1)\n    else:\n        print(x, y)\n", "from math import ceil\n\nfor __ in range(int(input())):\n    a, b, c, d, k = list(map(int, input().split()))\n    x = ceil(a / c)\n    y = ceil(b / d)\n    if x + y > k:\n        print(-1)\n    else:\n        print(x, y)", "import math\namount = int(input())\nfor i in range(amount):\n    a, b, c, d, k = [int(s) for s in input().split()]\n    if math.ceil(a/c) + math.ceil(b/d) > k:\n        print(-1)\n    else:\n        print(math.ceil(a/c), math.ceil(b/d))", "def solve():\n    a, b, c, d, k = list(map(int, input().split()))\n    x = (a + c - 1) // c\n    y = (b + d - 1) // d\n    if x + y > k:\n        print(-1)\n    else:\n        print(x, y)\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\n\n\nmain()\n", "from math import ceil\nt=int(input())\nfor i in range(t):\n    a,b,c,d,k=[int(x) for x in input().split()]\n    x=ceil(a/c)\n    y=ceil(b/d)\n    if x+y<=k:\n        print(x,y)\n    else:\n        print(-1)\n", "for _ in range(int(input())):\n    a, b, c, d, k = list(map(int, input().split()))\n    x = (a - 1) // c + 1\n    y = (b - 1) // d + 1\n    if y + x <= k:\n        print(x, y)\n    else:\n        print(-1)\n", "import math\nt = int(input())\nfor i in range(t):\n    a, b, c, d, k = list(map(int, input().split()))\n    first = math.ceil(a / c)\n    second = math.ceil(b / d)\n    if first + second <= k:\n        print(first, second)\n    else:\n        print(-1)\n", "t = int(input())\nfor _ in range(t):\n    a, b, c, d, k = map(int, input().split())\n    x = (a - 1) // c + 1\n    y = (b - 1) // d + 1\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nintin = lambda : int(input())\nfor _ in range(intin()):\n    a, b, c, d, k = mapin()\n    npen = math.ceil(a/c)\n    npencil = math.ceil(b/d)\n    if npen+npencil <= k:\n        print(npen, npencil)\n    else:\n        print(-1)", "import sys\nimport itertools\nimport math\nimport collections\nfrom collections import Counter\n\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef pow(x, y, mod):\n    r = 1\n    x = x % mod\n    while y > 0:\n        if y & 1:\n            r = (r * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return r\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = prime[1] = False\n    r = [p for p in range(n + 1) if prime[p]]\n    return r\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef cdiv(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\n\nt = ii()\nfor _ in range(t):\n    a,b,c,d,k = mi()\n    t = cdiv(a, c)\n    r = cdiv(b, d)\n    print(t, r) if t + r <= k else print(-1)\n\n", "#    !/usr/bin/env python3\n#    encoding: UTF-8\n#    Modified: <13/Oct/2019 02:38:22 PM>\n\n\n#    \u272a H4WK3yE\u4e61\n#    Mohd. Farhan Tahir\n#    Indian Institute Of Information Technology (IIIT), Gwalior\n\n\nimport sys\nimport os\nfrom io import IOBase, BytesIO\n\n\ndef main():\n    from math import ceil\n\n    for tc in range(int(input())):\n        a, b, c, d, k = get_ints()\n        pen = ceil(a / c)\n        pencil = ceil(b / d)\n        if pen + pencil > k:\n            print(-1)\n        else:\n            print(pen, pencil)\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill():\n            pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill()\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        py2 = round(0.5)\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2 == 1:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "for _ in range(int(input())):\n    a, b, c, d, k = list(map(int, input().split()))\n    x = (a - 1) // c + 1\n    y = (b - 1) // d + 1\n    if x + y > k:\n        print('-1')\n    else:\n        print(x, y)\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\nfrom math import *\n\nt = int(input())\nfor i in range(t):\n    a, b, c, d, e = list(map(int, input().split()))\n    if ceil(a/c)+ceil(b/d)<=e:\n        print(ceil(a/c), ceil(b/d))\n    else:\n        print(-1)\n", "for t in range(int(input())):\n    a, b, c, d, k = map(int, input().split())\n    if (a - 1) // c + 1 + (b - 1) // d + 1 <= k:\n        print((a - 1) // c + 1, (b - 1) // d + 1)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    a, b, c, d, k = map(int, input().split())\n    x, y = (a + c - 1) // c, (b + d - 1) // d\n    if x + y <= k: print(x, y)\n    else: print(-1)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    a, b, c, d, k = get_tuple()\n    x = (a+c-1)//c\n    y = (b+d-1)//d\n    if x+y<=k:\n        print(x, y)\n    else: print(-1)\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "import math\nfor _ in range(int(input())):\n    a,b,c,d,k = list(map(int,input().split(' ')))\n    tot = 0\n    a = math.ceil(a/c)\n    b = math.ceil(b/d)\n    if a+b<=k:\n        print(a,b)\n    else:print(-1)\n", " \nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import *\n\nt, = I()\nwhile t:\n\tt -= 1\n\ta, b, c, d, k = I()\n\tfor i in range(k+1):\n\t\tj = k-i\n\t\tif i*c >= a and j*d >= b:\n\t\t\tprint(i, j)\n\t\t\tbreak\n\telse:\n\t\tprint(-1)", "from math import *\nt=int(input())\nfor l in range(t):\n\ta,b,c,d,k=list(map(int,input().split()))\n\tval1=ceil(a/c)\n\tval2=ceil(b/d)\n\tif(val1+val2<=k):\n\t\tprint(val1,val2)\n\telse:\n\t\tprint(-1)\n", "t = int(input())\nfor i in range(t):\n    a, b, c, d, k = map(int, input().split())\n    x = (a + c - 1) // c\n    y = (b + d - 1) // d\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)", "t = int(input())\nfor i in range(t):\n    a, b, c, d, k = [int(i) for i in input().split()]\n    if a % c == 0:\n        x = a // c\n    else:\n        x = a // c + 1\n    if b % d == 0:\n        y = b // d\n    else:\n        y = b // d + 1\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)\n", "t = int(input())\nfor _ in range(t):\n    a, b, c, d, k = list(map(int, input().split()))\n    x = (a + c - 1) // c\n    y = (b + d - 1) // d\n\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)\n"]
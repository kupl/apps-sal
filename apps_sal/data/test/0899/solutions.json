["n,m = map(int,input().split())\ngraph = [[float(\"inf\")]*(n+1) for _ in range(n+1)]\nfor i in range(m):\n  a,b,c = map(int,input().split())\n  graph[a][b] = c\n  graph[b][a] = c\n\n    \n\ndef dijkstra(s,cost):\n  d = [float(\"inf\")]*(n+1)\n  used = [False]*(n+1)\n  d[s] = 0\n  \n  while True:\n    v = -1\n    for i in range(1,n+1):\n      if (not used[i]) and (v == -1):\n        v = i\n      elif (not used[i]) and d[i] < d[v]:\n        v = i\n    if v == -1:\n      break\n    used[v] = True\n               \n    for j in range(1,n+1):\n      d[j] = min(d[j],d[v]+cost[v][j])\n  return d\n\nans = 0\nfor i in range(1,n):\n  d = dijkstra(i,graph)\n  for j in range(i+1,n+1):\n    if i == j:\n      continue\n    if graph[i][j] != float(\"inf\") and graph[i][j] > d[j]:\n      ans += 1\nprint(ans)", "N, M = map(int, input().split())\nEdge = [tuple(map(int, input().split())) for _ in range(M)]\n\nimport numpy as np\nGraph = np.array([[0 if i == j else np.inf for i in range(N)] for j in range(N)])\nfor a,b,c in Edge:\n    Graph[a-1,b-1] = c\nfrom scipy.sparse.csgraph import dijkstra \nGraph = dijkstra(Graph,directed=False)\nans = 0\nfor a,b,c in Edge:\n    if Graph[a-1,b-1] != c:\n        ans += 1\nprint(ans)", "N,M = map(int,input().split())\nABC = [tuple(map(int,input().split())) for i in range(M)]\n\nINF = float('inf')\nds = [[INF]*N for _ in range(N)]\nfor i in range(N):\n    ds[i][i] = 0\nfor a,b,c in ABC:\n    a,b = a-1,b-1\n    ds[a][b] = ds[b][a] = c\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j])\n\nans = 0\nfor a,b,c in ABC:\n    a,b = a-1,b-1\n    if c != ds[a][b]:\n        ans += 1\nprint(ans)", "N, M = map(int, input().split())\nINF = 10**10\ngraph = [[INF for _ in range(N)] for _ in range(N)]\n\nC = []\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    graph[a-1][b-1] = c\n    graph[b-1][a-1] = c\n    C.append([a-1, b-1, c])\n\ncnt = 0\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if(i == j):\n                graph[i][j] = 0\n                continue    \n            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])\n\nans = M\nfor u, v, w in C:\n    Flg = False\n    for i in range(N):\n        if(graph[i][v] + w == graph[i][u]):\n            Flg = True\n    if Flg:\n        ans -= 1\nprint(ans)", "N, M = list(map(int,input().split()))\nE = set()\nd = [[10**9]*N for k in range(N)]\nfor k in range(N):\n    d[k][k] = 0\nfor k in range(M):\n    a, b, c = list(map(int,input().split()))\n    E.add((a-1,b-1,c))\n    d[a-1][b-1] = c\n    d[b-1][a-1] = c\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if d[i][j] > d[i][k] + d[k][j]:\n                d[i][j] = d[i][k] + d[k][j]\nans = 0\nfor e in E:\n    if d[e[0]][e[1]] != e[2]:\n        ans += 1\nprint(ans)\n", "import sys \nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN,M=map(int,input().split())\nG= [[0]*(N+1) for _ in range(N+1)]\nabc = [list(map(int,input().split())) for _ in range(M)]\n\nfor a, b, c in abc:\n  G[a][b] = c\n  G[b][a] = c\n\ncost = floyd_warshall(csr_matrix(G))\ncnt = 0\nfor a, b, c in abc:\n  if cost[a][b] < c:\n    cnt += 1\nprint(cnt)", "N,M=list(map(int,input().split()))\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nl=[np.array([0]*N) for i in range(N)]\nfor i in range(M):\n   tmp=(list(map(int,input().split())))\n   l[tmp[0]-1][tmp[1]-1]=tmp[2]\n   l[tmp[1]-1][tmp[0]-1]=tmp[2]\nl2=csr_matrix(l)\nl2=floyd_warshall(l2)\nans=0\nfor i in range(N):\n   for j in range(i):\n      if l[i][j] != l2[i][j] and l[i][j] != 0:\n         ans+=1\nprint(ans)", "import math\n#import numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,m = list(map(int,ipt().split()))\n    cos = []\n    row = []\n    col = []\n    for _ in range(m):\n        a,b,c = list(map(int,ipt().split()))\n        row.append(a-1)\n        col.append(b-1)\n        cos.append(c)\n    csr = csr_matrix((cos,(row,col)),shape=(n,n))\n    d = dijkstra(csr,directed=False)\n    ans = 0\n    for i in range(m):\n        rwi = row[i]\n        cli = col[i]\n        csi = cos[i]\n        dri = d[rwi]\n        dci = d[cli]\n        for j in range(n):\n            if dri[j] + csi == dci[j]:\n                break\n            if j == n-1:\n                ans += 1\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\n\ndef dijkstra(n, s, g):\n    h = [(0, s)]\n    heapq.heapify(h)\n    cost = [float(\"Inf\")] * (n + 1)  # cost: i -> j\n    cost[s] = 0\n\n    while h:\n        c, v = heapq.heappop(h)\n        if c > cost[v]:\n            continue\n        for d, u in g[v]:\n            d_s_u = d + cost[v]\n            if d_s_u < cost[u]:\n                cost[u] = d_s_u\n                heapq.heappush(h, (d_s_u, u))\n\n    return cost\n\n\ndef main():\n    n, m, *abc = list(map(int, open(0).read().split()))\n    g = [[] for _ in range(n + 1)]\n\n    for a, b, c in zip(*[iter(abc)] * 3):\n        g[a].append([c, b])\n        g[b].append([c, a])\n\n    ans = 0\n    for i in range(1, n + 1):\n        cost = dijkstra(n, i, g)\n        for j, k in g[i]:\n            if j > cost[k]:\n                ans += 1\n\n    print((ans//2))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = list(map(int,input().split()))\nfrom collections import deque\nv = [deque([]) for _ in range(N)]\n\nfor i in range(M):\n    a,b,c = list(map(int,input().split()))\n    a,b = a-1,b-1\n    v[a].append([b,c])\n    v[b].append([a,c])\n\ns = deque([])\nfor i in range(N):\n    ls = [[-1,M*10000]]*N\n    ls[i] =  [-1,0]\n    q = [deque(j for j in k) for k in v]\n    l = deque([i])\n    while l:\n        u = l.popleft()\n        x = len(q[u])\n        for i in range(x):\n            e = q[u].popleft()\n            if ls[u][1] + e[1] < ls[e[0]][1]:\n                ls[e[0]] = [u, ls[u][1] + e[1]]\n                l.append(e[0])\n            q[u].append(e)\n    for j,e in enumerate(ls):\n        if e[0] != -1:\n             s.append([min(j,e[0]),max(j,e[0])])\n\ns = list(map(list, set(map(tuple, s))))\nprint((M-len(s)))\n", "N, M = list(map(int, input().split()))\nd = [[1000000]*N for _ in range(N)]\nd_dict = {}\n\ninf = 0\nfor i in range(M):\n  a, b, c = list(map(int, input().split()))\n  d[a-1][b-1] = c\n  d[b-1][a-1] = c\n  d_dict[(a-1, b-1)] = c\n  \nfor k in range(N):\n  for i in range(N):\n    for j in range(N):\n      d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n  \nans = 0\nfor key in d_dict:\n  if d[key[0]][key[1]] < d_dict[key]:\n    ans += 1\n    \nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\", c: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import csr_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    omat = csr_matrix((c+c, (a+b, b+a)), shape=(N+1, N+1), dtype=np.int32)\n    smat = floyd_warshall(omat)\n    return ((omat-smat) > 0).sum() // 2\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    a = [int()] * (M)  # type: \"List[int]\"\n    b = [int()] * (M)  # type: \"List[int]\"\n    c = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n    print((solve(N, M, a, b, c)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "def warshall_floyd(d):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j])\n    return d\n\nn,w = map(int,input().split(\" \"))\n\na = []\n\nd = [[10 ** 10] * n for i in range(n)]\nk = [n for i in range(n)]\n\nfor i in range(w):\n    x,y,z = map(int,input().split(\" \"))\n    d[x-1][y-1] = z\n    d[y-1][x-1] = z\n    a.append([x,y,z])\nfor i in range(n):\n    d[i][i] = 0\n\nd = warshall_floyd(d)\n\nans = w\nfor i in range(len(a)):\n    for s in range(n):\n        if d[s][a[i][1]-1] + a[i][2] == d[s][a[i][0]-1]:\n            ans -= 1\n            break\n\nprint(ans)", "N,M = list(map(int,input().split()))\n\nINF = 10**7\ndist = [[INF for j in range(N)] for i in range(N)]\nd = [[INF for j in range(N)] for i in range(N)]\nprev = [[i for j in range(N)] for i in range(N)]\nt = [[0 for j in range(N)] for i in range(N)]\n\n# \u521d\u671f\u5316\nfor i in range(N):\n    d[i][i] = 0\n    dist[i][i] = 0\n\nfor _ in range(M):\n    a,b,c = list(map(int,input().split()))\n    dist[a-1][b-1] = c\n    dist[b-1][a-1] = c\n    d[a-1][b-1] = c\n    d[b-1][a-1] = c\n\n#\u3000d[a][b]:a\u3068b\u306e\u8ddd\u96e2\ndef warshall_floyd(n):\n    for k in range(n):\n        for i in range(n):#\u59cb\u70b9\n            for j in range(n):#\u7d42\u70b9\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j])\n\nwarshall_floyd(N)\nans = 0\nfor i in range(N):\n    for j in range(N):\n        if dist[i][j] != INF and d[i][j] != dist[i][j]:\n            ans += 1\nprint((ans//2))\n", "# \u307e\u305a\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u306e\u8868\u3092\u4f5c\u308b\n# \u5143\u306e\u8868\u3067\u9802\u70b9A-B\u3092\u7d50\u3076\u8ddd\u96e2\u304c\u3001\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u306e\u8868\u3067\u77ed\u7e2e\u3055\u308c\u3066\u3044\u305f\u3089\u3001\u305d\u306e\u8fba\u306f\u4f7f\u308f\u306a\u3044\u3067\u826f\u3044\u3053\u3068\u306b\u306a\u308b\n# \u3053\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse.csgraph import csgraph_from_dense\n\nN,M = map(int,readline().split())\n\nINF = 10 ** 9\nG = [[INF] * N for i in range(N)]\nfor i in range(M):\n  a,b,c = map(int,readline().split())\n  G[a-1][b-1] = c\n  G[b-1][a-1] = c\n\nd = csgraph_from_dense(G, null_value=10**9)\nd = floyd_warshall(d)\n\nans = 0\nfor a in range(N-1):\n  for b in range(a + 1,N):\n    if G[a][b] == INF:\n      continue\n    if G[a][b] > d[a][b]:\n      ans += 1\n      \nprint(ans)", "# https://atcoder.jp/contests/abc051/tasks/abc051_d\n# \u60f3\u5b9a\u89e3\u6cd5\n# \u6700\u77ed\u8ddd\u96e2\u306e\u96a3\u63a5\u884c\u5217D\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u306b\u3001edges[a, b]\u304c\u6700\u77ed\u7d4c\u8def\u306b\u542b\u307e\u308c\u308b\u304b\u3069\u3046\u304b\u8003\u3048\u308b\n# 2\u70b9s,t\u306b\u3064\u3044\u3066\u3001\u6700\u77ed\u8ddd\u96e2\u3067\u3042\u308c\u3070\u3001D[s,t]=D[s,i]+edges[i,j]+D[j,t]\u3092\u6e80\u305f\u3059i,j\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\u6700\u77ed\u7d4c\u8def\u8fba\u3067\u3042\u308b\n# 5000*1000\u306e\u63a2\u7d22\u306a\u306e\u3067\u9593\u306b\u5408\u3046\n\nfrom scipy.sparse import csr_matrix  # \u81ea\u5206\u3067\u914d\u5217\u3092\u4f5c\u3063\u3066\u304b\u3089csr\u306b\u5165\u308c\u3088\u3046(lil\u306b\u6253\u3061\u8fbc\u3093\u3067\u3044\u304f\u306e\u306f\u975e\u5e38\u306b\u9045\u3044)\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5 (\u6b63\u306e\u5358\u4e00\u59cb\u70b9\u6700\u77ed\u7d4c\u8def) (\u5168\u70b9\u9593\u6700\u77ed\u7d4c\u8def)\nfrom scipy.sparse.csgraph import dijkstra\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\nN, M = read_ints()\nadj_mat = [[0] * N for _ in range(N)]\nINF = 10 ** 9\nfrom collections import defaultdict\nfrom itertools import combinations\nedges = defaultdict(lambda: INF)\nfor _ in range(M):\n    a, b, c = read_ints()\n    a -= 1\n    b -= 1\n    adj_mat[a][b] = c\n    adj_mat[b][a] = c\n    edges[a, b] = c\n\nadj_mat = csr_matrix(adj_mat, dtype='int')\nD = dijkstra(adj_mat, directed=False)\n# print(D)\n\n# \u6700\u77ed\u7d4c\u8def\u3058\u3083\u306a\u3044\u8fba\u5168\u63a2\u7d22\nedge_not_use = set()\n# \u8fba\u3092\u56fa\u5b9a\u3057\u3066s,t\u3092\u5168\u63a2\u7d22\u3057\u305f\u307b\u3046\u304c\u826f\u3055\u305d\u3046\n# \u3060\u3051\u3069\u3053\u308c\u306fTLE(python\u304c\u9045\u3044\u305b\u3044)\n# for (i, j), e in edges.items():\n#     for s, t in combinations(range(N), 2):\n#         d = D[s, t]\n#         if d == D[s, i] + e + D[j, t] or d == D[t, i] + e + D[j, s]:\n#             break\n#     else:\n#         edge_not_use.add((i, j))\n\n# \u3088\u304f\u8003\u3048\u3066\u307f\u308c\u3070\n# D[s,j]=D[s,i]+edges[i,j]\u306eedges[i,j]\u306f\u6700\u77ed\u7d4c\u8def\u306e\u4e00\u90e8\u306b\u306a\u3063\u3066\u3044\u308b\u306f\u305a(s\u2192j\u306e\u6700\u77ed\u7d4c\u8def\u306e\u4e00\u90e8\u3092\u6210\u3059)\n# s\u3092\u5168\u63a2\u7d22\u3059\u308b\u3060\u3051\u3067\u3044\u3044\n\nfor (i, j), e in list(edges.items()):\n    for s in range(N):\n        d = D[s, j]\n        if d == D[s, i] + e or d == D[s, j] + e:\n            break\n    else:\n        edge_not_use.add((i, j))\n\n\nprint((len(edge_not_use)))\n# print(edge_not_use)\n", "#!/usr/bin/env python3\nimport sys\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\", c: \"List[int]\"):\n    import numpy as np    \n    from scipy.sparse import csr_matrix    \n    from scipy.sparse.csgraph import floyd_warshall\n    omat = csr_matrix((c, (a, b)), shape=(N+1, N+1), dtype=np.int32)\n    smat = floyd_warshall(omat, directed=False)\n    return ((smat-omat) < 0).sum()\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    a = [int()] * (M)  # type: \"List[int]\"\n    b = [int()] * (M)  # type: \"List[int]\"\n    c = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n    print((solve(N, M, a, b, c)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "N,M=map(int,input().split())\ngraph=[[] for _ in range(N)]\ncost=[[float(\"inf\")]*N for _ in range(N)]\nfor _ in range(M):\n    a,b,c=map(int,input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n    cost[a-1][b-1]=c\n    cost[b-1][a-1]=c\n\ndef dijkstra(S,N,cost):\n    d=[float(\"inf\")]*N\n    used=[False]*N\n    d[S]=0\n\n    while True:\n        v=-1\n        for i in range(N):\n            if (not used[i]) and (v==-1):\n                v=i\n            elif (not used[i]) and d[i]<d[v]:\n                v=i\n        if v==-1:\n            break\n        used[v]=True\n\n        for j in range(N):\n            d[j]=min(d[j],d[v]+cost[v][j])\n    \n    return d\n\ndist=[]\nfor s in range(N):\n    dist.append(dijkstra(s,N,cost))\n\nchecked=[[False]*N for _ in range(N)]\nans=M\nfor s in range(N):\n    for i in range(s,N):\n        for j in graph[i]:\n            if checked[i][j]:\n                continue\n            \n            if dist[s][i]+cost[i][j]==dist[s][j]:\n                ans-=1\n                checked[i][j]=True\n                checked[j][i]=True\nprint(ans)", "import heapq\n\ndef main():\n    N, M = list(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        G[a - 1].append((b - 1, c))\n        G[b - 1].append((a - 1, c))\n    used = set()\n    for i in range(N):\n        H = []\n        for b, c in G[i]:\n            heapq.heappush(H, (c, i, b))\n        D = [10**10] * N\n        D[i] = 0\n        while H:\n            c, a, b = heapq.heappop(H)\n            if D[b] < c:\n                continue\n            D[b] = c\n            if a < b:\n                used.add((a, b))\n            else:\n                used.add((b, a))\n            for d, cc in G[b]:\n                if D[d] > c + cc:\n                    D[d] = c + cc\n                    heapq.heappush(H, (c + cc, b, d))\n    return M - len(used)\n\nprint((main()))\n", "n,m=map(int,input().split())\ng=[[]for _ in range(n)]\nfor i in range(m):\n  a,b,c=map(int,input().split())\n  a,b=a-1,b-1\n  g[a].append((c,b,i))\n  g[b].append((c,a,i))\nno_used=[1]*m\nfrom heapq import heapify,heappop,heappush\ndef dks(t0):\n  todo=[[0,t0,-1]]\n  heapify(todo)\n  seen=[0]*n\n  while todo:\n    d,t,i=heappop(todo)\n    if seen[t] and seen[t]<d:continue\n    seen[t]=d\n    if i>-1:no_used[i]=0\n    l=g[t]\n    for d_,t_,i_ in l:\n      heappush(todo,[d+d_,t_,i_])\nfor i in range(n):\n  dks(i)\nprint(sum(no_used))", "n,m = map(int,input().split())\nINF = 10**18\nd = [[INF]*n for _ in range(n)]\nfor i in range(n): d[i][i] = 0\nA = [0]*m\nB = [0]*m\nC = [0]*m\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    a -= 1\n    b -= 1\n    A[i] = a\n    B[i] = b\n    C[i] = c\n    d[a][b] = c\n    d[b][a] = c\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\nans = 0\nfor i in range(m):\n    if d[A[i]][B[i]] < C[i]: ans += 1\nprint(ans)", "def dijkstra(s):\n    import  heapq\n    dist=[inf for i in range(n)] #s\u304b\u3089\u306e\u8ddd\u96e2\u306e\u30ea\u30b9\u30c8\n    dist[s]=0\n    mirai=[True for i in range(n)] #True\u306a\u3089\u672a\u78ba\u5b9a\n    mirai[s]=False\n\n    queue=[] #\u3053\u3044\u3064\u304cheapq\u306b\u306a\u308b\n    for kyori,to in G[s]:\n        heapq.heappush(queue , kyori*10**6+to)  #\u91cd\u307f\u3068\u884c\u5148\u30921\u3064\u306e\u5909\u6570\u3067\u8868\u3057\u3066\u308b\uff01\n    while queue:\n        minedge= heapq.heappop(queue)\n        #mirai\u304cTrue\u306e\u3084\u3064(\u672a\u78ba\u5b9a\u306a\u3084\u3064)\u304b\u3089\u6700\u5c0f\u8ddd\u96e2\u306e\u3082\u306e\u3092\u3055\u304c\u3059\n        if not mirai[minedge%(10**6)]: continue\n        #\u8ddd\u96e2\u304c\u5c0f\u3055\u3044\u3082\u306e\u304b\u3089\"\u78ba\u5b9a\"\u3057\u3066\u3044\u304f\n        v=minedge%(10**6) #\u6700\u5c0f\u8ddd\u96e2\u306e\u9802\u70b9\n        dist[v] = minedge//(10**6) #\u305d\u306e\u8ddd\u96e2\n        mirai[v]=False\n        for kyori,to in G[v]:\n            if mirai[to]:\n                heapq.heappush(queue, (kyori+dist[v])*(10**6)+to)\n                #queue\u306b\u5165\u308b\u6570\u306f\u3001\u5fc5\u305a\u300cs\u304b\u3089\u306e\u300d\u8ddd\u96e2\u3068\u884c\u5148\u3092\u6301\u3063\u3066\u3044\u308b\n    return dist\nn,m=list(map(int,input().split()))\ninf=10**10\nG=[[] for i in range(n)]\nHEN=[]\nfor i in range(m):\n    a,b,c=list(map(int,input().split()))\n    a-=1;b-=1\n    G[a].append((c,b))\n    G[b].append((c,a))\n    HEN.append((a,b,c))\n\nMIN=[[10**10]*n for i in range(n)]\nfor i in range(n):\n    MIN[i]=dijkstra(i)\nans=0\nfor a,b,c in HEN:\n    for s in range(n):\n        if MIN[s][a]+c == MIN[s][b]:\n            break\n        if MIN[s][b]+c == MIN[s][a]:\n            break\n    else:\n        ans+=1\nprint(ans)\n", "# solution\n\nimport numpy as np\nimport io\nimport math\nfrom scipy.sparse.csgraph import shortest_path\n\nnim,mike = map(int,input().split())\n\narray = [[int(x) for x in input().split()] for _ in range(mike)]\n\ngraph = np.zeros((nim,nim)) # 0-indexed\nfor a,b,c in array:\n  graph[a-1,b-1] = c\n\ndist = shortest_path(graph,directed=False).astype(int)\n\nanswer = 0\nfor a,b,c in array:\n  if c != dist[a-1,b-1]:\n    answer += 1\nprint(answer)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *ABC = list(map(int, read().split()))\n    G = [[INF] * N for _ in range(N)]\n    edge = [0] * M\n    for i, (a, b, c) in enumerate(zip(*[iter(ABC)] * 3)):\n        edge[i] = (a - 1, b - 1, c)\n        G[a - 1][b - 1] = G[b - 1][a - 1] = c\n    for i in range(N):\n        G[i][i] = 0\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if G[i][j] > G[i][k] + G[k][j]:\n                    G[i][j] = G[i][k] + G[k][j]\n\n    ans = 0\n    for a, b, c in edge:\n        if c > G[a][b]:\n            ans += 1\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\ndef dijkstra(s):\n    inf = 1145141919810\n    dist = [inf] * v\n    dist[s] = 0\n    c = [0] * v\n    p = []\n    heapq.heapify(p)\n    heapq.heappush(p, (dist[s], s))\n    while p:\n        d, u = heapq.heappop(p)\n        if dist[u] < d:\n            continue\n        c[u] = 1\n        for g in G[u]:\n            if c[g[0]] == 0 and dist[u] + g[1] < dist[g[0]]:\n                dist[g[0]] = dist[u] + g[1]\n                heapq.heappush(p, (dist[g[0]], g[0]))\n    return dist\n\nn, m = map(int, input().split())\nv = n\nG = [[] for _ in range(v)]\nE = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    G[a].append([b, c])\n    G[b].append([a, c])\n    E.append([a, b, c])\nmindist = [dijkstra(i) for i in range(v)]\nans = m\nfor e in E:\n    for i in range(n):\n        if mindist[i][e[0]] - mindist[i][e[1]] == e[2]:\n            ans -= 1\n            break\nprint(ans)", "n, m = map(int, input().split())\nabc = [list(map(int, input().split())) for _ in range(m)]\n\nedge = set()\nINF = float('inf')\ncost = [[INF]*n for _ in range(n)]\nfor i in range(n):\n    cost[i][i] = 0\nfor a, b, c in abc:\n    a, b = a-1, b-1\n    cost[a][b] = c\n    cost[b][a] = c\n    edge.add((a, b, c))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j])\n\nans = 0\nfor a, b, c in edge:\n    if cost[a][b] < c:\n        ans += 1\nprint(ans)", "from heapq import heappush, heappop\n\nN, M = map(int, input().split())\nINF = 10**10\nedge_idx = {}\ngraph = [[] for i in range(N)]\nfor i in range(M):\n  a, b, c = map(int, input().split())\n  a -= 1; b -= 1\n  graph[a].append((b, c))\n  graph[b].append((a, c))\n  edge_idx[(a, b)] = edge_idx[(b, a)] = i\n\nused = set()\ndef dijkstra(node):\n  nonlocal used\n  dist = [INF] * N\n  dist[node] = 0\n  e = []\n  for child, cost in graph[node]:\n    heappush(e, (cost, child, node))\n  while e:\n    cost, node, par = heappop(e)\n    if dist[node] < INF:\n      if dist[node] == cost:\n        used.add(edge_idx[(node, par)])\n      continue\n    dist[node] = cost\n    used.add(edge_idx[(node, par)])\n    for child, c in graph[node]:\n      if dist[child] < INF:\n        continue\n      heappush(e, (cost+c, child, node))\n\nfor i in range(N):\n  dijkstra(i)\n\nprint(M - len(used))", "#\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\ndef warshall_floyd(d):\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n    return d\n\n\n##############################\nn,m = map(int,input().split()) \n\nd = [[float(\"inf\")]*n for i in range(n)] \n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\nedge=[]\nfor i in range(m):\n    x,y,c = map(int,input().split())\n    x-=1\n    y-=1\n    edge.append((x,y,c))\n    d[x][y] = c\n    d[y][x] = c\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\nd=warshall_floyd(d)\nans=0\nfor x,y,c in edge:\n    if d[x][y]<c:\n        ans+=1\nprint(ans)", "N,M = map(int,input().split())\nd = [[10**10]*N for i in range(N)]\na = [0]*M\nb = [0]*M\nc = [0]*M\nfor i in range(M):\n  a[i],b[i],c[i]=map(int,input().split())\n  a[i] -= 1\n  b[i] -= 1\n  d[a[i]][b[i]] = c[i]\n  d[b[i]][a[i]] = c[i]\nfor i in range(N):\n  d[i][i] = 0\n\nfor i in range(N):\n  for j in range(N):\n    for k in range(N):\n      d[j][k] = min(d[j][k], d[j][i] + d[i][k])\n\nans = M\nfor i in range(M):\n  tmp = 0\n  for j in range(N):\n    if d[j][a[i]] + c[i] == d[j][b[i]]:\n      tmp = 1\n  ans -= tmp\nprint(ans)", "import sys\n\nN, M = map(int, input().split())\n\nmemo = [[sys.maxsize]*(N+1) for _ in range(N+1)]\nfor i in range(1,N+1):\n  memo[i][i] = 0\n\nlst = []\nfor _ in range(M):\n  a,b,c = map(int, input().split())\n  memo[a][b] = c\n  memo[b][a] = c\n  lst.append((a,b,c))\n  \nfor k in range(1,N+1):\n  for i in range(1,N+1):\n    for j in range(1,N+1):\n      memo[i][j] = min(memo[i][j], memo[i][k] + memo[k][j])\n      \ncnt = 0\nfor a,b,c in lst:\n  if memo[a][b] < c:\n    cnt += 1\n    \nprint(cnt)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nn, m = map(int, input().split())\nma = [[0]*n for _ in range(n)]\nlist_ABC = [ list(map(int,input().split(\" \"))) for i in range(m)]\nfor a, b, c in list_ABC:\n    ma[a-1][b-1] = c\n    ma[b-1][a-1] = c\n\nx = csr_matrix(ma)\ny = dijkstra(x, directed=False).astype(int)\n\nans = 0\n\nfor a, b, c in list_ABC:\n  if y[a-1][b-1] != c:\n      ans += 1\n\nprint(ans)", "def resolve():\n    from scipy.sparse.csgraph import shortest_path\n    import scipy\n    import numpy as numpy\n    n, m = list(map(int, input().split()))\n    row = [None] * m\n    col = row[:]\n    data = row[:]\n    for i in range(m):\n        row[i], col[i], data[i] = list(map(int, input().split()))\n        row[i] -= 1\n        col[i] -= 1\n    a = scipy.sparse.csr_matrix((data, (row, col)), shape=(n, n)).toarray()\n    s, p = shortest_path(a, return_predecessors=True, directed=False)\n    l = [[True] * n for _ in range(n)]\n    for start in range(n - 1):\n        for goal in range(start + 1, n):\n            path = get_path(start, goal, p)\n            for i in range(len(path) - 1):\n                l[path[i]][path[i + 1]] = False\n                l[path[i + 1]][path[i]] = False\n    ans = 0\n    for i, j in zip(row, col):\n        if l[i][j]:\n            ans += 1\n    print(ans)\n\n\ndef get_path(start, goal, pred):\n    return get_path_row(start, goal, pred[start])\n\n\ndef get_path_row(start, goal, pred_row):\n    path = []\n    i = goal\n    while i != start and i >= 0:\n        path.append(i)\n        i = pred_row[i]\n    if i < 0:\n        return []\n    path.append(i)\n    return path[::-1]\n\n\nresolve()\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *ABC = list(map(int, read().split()))\n    G = [[INF] * N for _ in range(N)]\n    edge = [0] * M\n    for i, (a, b, c) in enumerate(zip(*[iter(ABC)] * 3)):\n        edge[i] = (a - 1, b - 1, c)\n        G[a - 1][b - 1] = G[b - 1][a - 1] = c\n    for i in range(N):\n        G[i][i] = 0\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if G[i][j] > G[i][k] + G[k][j]:\n                    G[i][j] = G[i][k] + G[k][j]\n\n    ans = 0\n    for a, b, c in edge:\n        used = False\n        for i in range(N):\n            if G[i][b] == G[i][a] + c or G[i][a] == G[i][b] + c:\n                used = True\n                break\n        if not used:\n            ans += 1\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nDP = [[float('inf')]*N for _ in range(N)]\nB = []\nfor i in range(N):\n  DP[i][i] = 0\nfor _ in range(M):\n  a,b,c = map(int,input().split())\n  DP[a-1][b-1] = c\n  DP[b-1][a-1] = c\n  B.append([a-1,b-1,c])\nfor k in range(N):\n  for i in range(N):\n    for j in range(N):\n      DP[i][j] = min(DP[i][j],DP[i][k]+DP[k][j])   \nans = 0\nfor i in range(M):\n    a,b,c = B[i]\n    for j in range(N):\n        if DP[j][b] == DP[j][a] + c:\n            break\n    else:\n        ans += 1\nprint(ans)", "n, m = map(int, input().split())\ngraph = [[10 ** 9 for _ in range(n)] for _ in range(n)]\nedge = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a][b] = c\n    graph[b][a] = c\n    edge.append((a, b))\nfor i in range(n):\n    graph[i][i] = 0\n\nfrom copy import deepcopy\ndistance = deepcopy(graph)    \nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\nans = 0\nfor i, j  in edge:\n    if distance[i][j] < graph[i][j]:\n        ans += 1\nprint(ans)", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nsys.setrecursionlimit(20000000)\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    S = []\n\n    d = [[float(\"inf\")] * N for _ in range(N)]\n    L = []\n    for i in range(M):\n        a, b, c = list(map(int, input().split()))\n        d[a - 1][b - 1] = c\n        d[b - 1][a - 1] = c\n        if a < b:\n            L.append((a - 1, b - 1))\n        else:\n            L.append((b - 1, a - 1))\n    for i in range(N):\n        d[i][i] = 0\n    L = set(L)\n\n    def warshall_floyd(d):\n        # d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n        for k in range(N):\n            for i in range(N):\n                for j in range(N):\n                    if d[i][j] > d[i][k] + d[k][j]:\n                        d[i][j] = d[i][k] + d[k][j]\n                        if i < j:\n                            if (i, j) in L:\n                                S.append((i, j))\n                        else:\n                            if (j, i) in L:\n                                S.append((j, i))\n        return d\n\n    warshall_floyd(d)\n    print((len(set(S))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\n\nINF = float('inf')\nN, M = list(map(int, input().split()))\nto = [[] for _ in range(N)]\nsides = [[0] * N for _ in range(N)]\n\n\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    to[a].append((c, b))\n    to[b].append((c, a))\n    sides[a][b] = 1\n    sides[b][a] = 1\n\n\ndef dijkstra(s):\n    hq = [(0, s)]\n    heapq.heapify(hq) \n    cost = [[INF, []] for i in range(N)]\n    cost[s][0] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v][0]:\n            continue\n        for d, u in to[v]:\n            tmp = d + cost[v][0]\n            if tmp < cost[u][0]:\n                cost[u][0] = tmp\n                cost[u][1] = [v]\n                heapq.heappush(hq, (tmp, u))                    \n            elif tmp == cost[u][0]:\n                cost[u][1].append(v)\n                heapq.heappush(hq, (tmp, u))\n    return cost\n\n\ndef dfs(v, tree, p=-1):\n    if p >= 0:\n        sides[v][p] = 0\n        sides[p][v] = 0\n    for nv in tree[v][1]:\n        dfs(nv, tree, v)\n\n\ndef main():\n    for s in range(N):\n        tree = dijkstra(s)\n        for g in range(N):\n            dfs(g, tree)\n\n    print((sum(sum(column) for column in sides) // 2))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    dp = [[float(\"inf\")] * N for _ in range(N)]\n    edges = list()\n    for i in range(N):\n        dp[i][i] = 0\n\n    for _ in range(M):\n        a, b, c, = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        dp[a][b] = c\n        dp[b][a] = c\n        if a > b:\n            a, b = b, a\n        edges.append((a, b, c))\n\n    # \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                tmp = dp[i][k] + dp[k][j]\n                if tmp < dp[i][j]:\n                    dp[i][j] = tmp\n\n    ans = 0\n    for i, j, c in edges:\n        if dp[i][j] < c:\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import floyd_warshall\nN, M, *ABC = [int(_) for _ in open(0).read().split()]\nABC = np.array(ABC)\nF = floyd_warshall(\n    csr_matrix((ABC[2::3], (ABC[::3], ABC[1::3])), (N + 1, N + 1)), 0)\nprint((np.sum(F[ABC[::3], ABC[1::3]] != ABC[2::3])))\n", "def main():\n    import sys\n    # readline = sys.stdin.readline\n    readlines = sys.stdin.readlines\n    N, M = list(map(int, input().split()))\n    edge = []\n    dp = [[10 ** 9] * N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = 0\n    for s in readlines():\n        a, b, c = list(map(int, s.split()))\n        a -= 1; b -= 1\n        edge.append((a, b, c))\n        dp[a][b] = c\n        dp[b][a] = c\n    \n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\n    cnt = 0\n    for a, b, c in edge:\n        if dp[a][b] < c:\n            cnt += 1\n    \n    print(cnt)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import copy\nN, M = list(map(int, input().split()))\n\ninf = 10 ** 9 + 7\ndp = [[inf] * N for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    dp[a][b] = c\n    dp[b][a] = c\n\nold_dp = copy.deepcopy(dp)\ncheck = [[False] * N for _ in range(N)]\ncount = 0\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\ncount = 0\nfor i in range(N):\n    for j in range(N):\n        if old_dp[i][j] != dp[i][j] and old_dp[i][j] != inf:\n            count += 1\n\nprint((count // 2))\n", "# https://atcoder.jp/contests/abc051/submissions/1055446\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1000 * 100 + 10\n\n    N, M = list(map(int, input().split()))\n\n    dist = [[inf for _ in range(N)] for _ in range(N)]\n    for j in range(N):\n        dist[j][j] = 0\n\n    es = []\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        es.append((a, b, c))\n        dist[a][b] = dist[b][a] = c\n\n    for k in range(N):\n        for j in range(N):\n            for i in range(j):\n                d = dist[i][k] + dist[k][j]\n                if dist[i][j] > d:\n                    dist[i][j] = dist[j][i] = d\n\n    ans = 0\n    for a, b, c in es:\n        if dist[a][b] == c: continue\n        ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\ngraph = [[float('inf')]*n for i in range(n)]\nu_s=[]\nv_s=[]\nw_s=[]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    u_s.append(u-1)\n    v_s.append(v-1)\n    w_s.append(w)\n    graph[u-1][v-1] = w\n    graph[v-1][u-1] = w\nfor i in range(n):\n    graph[i][i] = 0\n\n\ndef warshall_floyd(d):\n    # d[i][j] : i \u304b\u3089 j \u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n    return d\n\ndist=warshall_floyd(graph)\n\nans=0\nfor i in range(m):\n    if w_s[i]>dist[u_s[i]][v_s[i]]:\n        ans+=1\n\nprint(ans)", "from heapq import heappush,heappop\nINF=10**20\n\ndef dijkstra(G, start = 0):\n    d = [INF for i in range(len(G))]\n    d[start] = 0\n    prev = [0 for i in range(len(G))]\n    \n    que = []\n    heappush(que, (0, start))\n\n    while len(que) != 0:\n        p = heappop(que)\n        v = p[1]\n        \n        if d[v] < p[0]:\n            continue\n            \n        for u in G[v].keys():\n            if d[u] > d[v] + G[v][u]:\n                d[u] = d[v] + G[v][u]\n                prev[u] = v\n                heappush(que, (d[u], u))\n    \n    return d,prev\n\nN,M=map(int,input().split())\nG=[{} for _ in range(N+1)]\n\nedgelist=[]\nfor i in range(M):\n  a,b,c=map(int,input().split())\n  G[a][b]=G[b][a]=c\n  a,b=sorted([a,b])\n  edgelist.append((a,b))\nedgelist = set(edgelist)\n  \nshortest_edges=set()\nfor i in range(1,N+1):\n  d,prev = dijkstra(G,i)\n  for j in range(1,N+1):\n    if j ==i:continue\n    a,b = sorted([j,prev[j]])\n    shortest_edges.add((a,b))\n    \ndiff = edgelist.difference(shortest_edges)\nprint(len(diff))", "N, M = map(int,input().split())\nINF = float('inf')\nedges = []\nfor _ in range(M):\n    edges.append(list(map(int,input().split())))\ngraph = [[INF if i != j else 0 for i in range(N)] for j in range(N)]\nfor i in range(M):\n    a, b, c = edges[i]\n    graph[a-1][b-1] = c\n    graph[b-1][a-1] = c\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\nans = 0\nfor i in range(M):\n    a, b, c = edges[i]\n    if c != graph[a-1][b-1]:\n        ans += 1\nprint(ans)", "from heapq import heappop, heappush\nfrom copy import deepcopy\ndef main():\n    N, M = map(int, input().split())\n    INF = 10**9\n    to = [[INF]*N for _ in range(N)]\n    edges = []\n    for _ in range(M):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        to[a][b] = c\n        to[b][a] = c\n        edges.append((a, b, c))\n    \n    for i in range(N): to[i][i] = 0\n\n    def floyd_warshall():\n        for k in range(N):\n            for i in range(N):\n                for j in range(N):\n                    to[i][j] = min(to[i][j], to[i][k]+to[k][j])\n    \n    floyd_warshall()\n    ans = 0\n    for a, b, c in edges:\n        if to[a][b] != c:\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    from sys import stdin\n    def input():\n        return stdin.readline().strip()\n\n    n, m = map(int, input().split())\n    tree = [[] for _ in range(n)]\n    for _ in range(m):\n        i, j, k = map(int, input().split())\n        i -= 1\n        j -= 1\n        tree[i].append((k, j))\n        tree[j].append((k, i))\n\n    # dijkstra\n    import heapq\n    from numpy import zeros\n\n    ans = 0\n    for i in range(n):\n        for j in tree[i]:\n            seen = zeros(n)\n            goal = j[1]\n            base = j[0]\n            seen[i] = 1\n            todo = []\n            heapq.heapify(todo)\n            for k in tree[i]:\n                if k[0] < base and k != j:\n                    heapq.heappush(todo, k)\n            while len(todo) > 0:\n                k = heapq.heappop(todo)\n                if k[1] == goal:\n                    if k[0] < base:\n                        ans += 1\n                    break\n                seen[k[1]] = 1\n                for l in tree[k[1]]:\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n    print(ans // 2)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    inf = 10**17\n    #mod = 10**9 + 7\n\n    N, W = map(int, input().split())\n    #\u521d\u671f\u5316\n    dp = [[inf]*N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = 0\n    abc = [list(map(int, input().split())) for _ in range(W)]\n    for a,b,c in abc:\n        dp[a-1][b-1] = c\n        dp[b-1][a-1] = c\n\n    #k\u3092\u7d4c\u7531\u3057\u3066i\u304b\u3089j\u306b\u884c\u304f\u884c\u304d\u65b9\u3092\u8003\u3048\u308b\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dp[i][k]==inf or dp[k][j]==inf:\n                    continue\n                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])\n    \n    res = 0\n    for a,b,c in abc:\n        for k in range(N):\n            if dp[a-1][k] == c + dp[b-1][k]:\n                res += 1\n                break\n    print(W - res)\n\ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nfrom scipy.sparse.csgraph import floyd_warshall\n\nN, M = map(int, input().split())\n\n# Floyd-Warshall\u3067\u3088\u304f\u3084\u308b\u521d\u671f\u5316\ndist = []\nfor i in range(N):\n  tmp = []\n  for _ in range(N):\n    tmp.append(float('inf'))\n  dist.append(tmp)\n  dist[i][i] = 0  # \u3053\u3053\u304c\u30dd\u30a4\u30f3\u30c8\n\n# \u96a3\u63a5\u884c\u5217\u3092\u4f5c\u308b\na = []\nb = []\nc = []\nfor _ in range(M):\n  x = list(map(int, input().split()))\n  a.append(x[0] - 1)\n  b.append(x[1] - 1)\n  c.append(x[2])\n  dist[a[-1]][b[-1]] = x[2]\n  dist[b[-1]][a[-1]] = x[2]\n\n# Floyd-Warshall\ndist = floyd_warshall(dist)\ndist = dist.astype(int).tolist()\n\n# \u96c6\u8a08\nres = 0\nfor i in range(M):\n  if c[i] > dist[a[i]][b[i]]:\n    res += 1\n    \nprint(res)", "N, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\nedges = [(i - 1, j - 1, c) for i, j, c in edges]\n\nINF = int(10000)\n\ndp = [[INF for _ in range(N)] for _ in range(N)]\nfor i, j, cost in edges:\n    dp[i][j] = cost\n    dp[j][i] = cost\n\nfor i in range(N):\n    dp[i][i] = 0\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if dp[i][k] != INF and dp[k][j] != INF:\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\ncount = 0\nfor i, j, cost in edges:\n    if dp[i][j] < cost:\n        count += 1\n\nprint(count)", "def main():\n    n, m, *abc = list(map(int, open(0).read().split()))\n    d = [[float(\"Inf\")] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        d[i][i] = 0\n\n    for a, b, c in zip(*[iter(abc)] * 3):\n        d[a][b] = c\n        d[b][a] = c\n\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n    ans = 0\n    for a, b, c in zip(*[iter(abc)] * 3):\n        if d[a][b] < c:\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# https://atcoder.jp/contests/abc051/submissions/1055446\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1000 * 100 + 10\n\n    N, M = list(map(int, input().split()))\n\n    dist = [[inf for _ in range(N)] for _ in range(N)]\n    for j in range(N):\n        dist[j][j] = 0\n\n    es = []\n    for _ in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        es.append((a, b, c))\n        dist[a][b] = dist[b][a] = c\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                d = dist[i][k] + dist[k][j]\n                if dist[i][j] > d:\n                    dist[i][j] = d\n\n    ans = 0\n    for a, b, c in es:\n        if dist[a][b] == c: continue\n        ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = map(int,input().split())\nINF = float(\"inf\")\ng = [[INF]*n for _ in range(n)]\ne = []\nfor i in range(m):\n    vi,vj,w = map(int,input().split())\n    g[vi-1][vj-1] = w\n    g[vj-1][vi-1] = w\n    e.append((vi-1,vj-1,w))\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j])\ncnt = 0\nfor x,y,z in e:\n    if g[x][y] < z:\n        cnt += 1\nprint(cnt)", "import networkx as nx\nimport itertools\n\nN, M = map(int, input().split())\nG = nx.Graph()\nG.add_weighted_edges_from([map(int, input().split()) for _ in range(M)])\nS = nx.floyd_warshall(G)\n\nans = M\nfor i, j, d in G.edges(data=True):\n    for s, t in itertools.combinations(G.nodes(), 2):\n        if S[s][i] + d['weight'] + S[j][t] == S[s][t]:\n            ans -= 1\n            break\nprint(ans)", "N, M = (int(x) for x in input().split())\ngraph = [[1000] * N for _ in range(N)]\nbefore = []\nfor _ in range(M):\n    a,b,c = (int(x) for x in input().split())\n    before.append((a-1,b-1,c))\n    graph[a-1][b-1] = c\n    graph[b-1][a-1] = c\n\nfor i in range(N):\n    graph[i][i] = 0\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            graph[j][i] = graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])\n\nans = 0\nfor x in before:\n    if graph[x[0]][x[1]] != x[2]:\n        ans += 1\nprint(ans)", "import networkx as nx\nimport itertools\n\nN, M = list(map(int, input().split()))\nG = nx.Graph()\nG.add_nodes_from(list(range(1, N + 1)))\nG.add_weighted_edges_from([list(map(int, input().split())) for _ in range(M)])\nS = nx.floyd_warshall(G)\n\nans = M\nfor i, j, d in G.edges(data=True):\n    for s, t in itertools.combinations(G.nodes(), 2):\n        if S[s][i] + d['weight'] + S[j][t] == S[s][t]:\n            ans -= 1\n            break\nprint(ans)\n", "def warshall_floyd(d):\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n              #if (d[i][k] != float(\"INF\")) and (d[k][j] != float(\"INF\")):\n                d[i][j] = min(d[i][k] + d[k][j], d[i][j])\n                \n        #print(d)\n    return d\n\n##############################\nn,m = list(map(int,input().split())) #n:\u9802\u70b9\u6570\u3000m:\u8fba\u306e\u6570\n\nd = [[float(\"INF\")] * n for i in range(n)]\n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\n\nhen = [0] * m\nfor i in range(m):\n    x,y,z = list(map(int,input().split()))\n    d[x - 1][y - 1] = z\n    d[y - 1][x - 1] = z\n    hen[i] = [x - 1, y - 1, z]\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\n\nans = warshall_floyd(d)\n#\u305d\u308c\u305e\u308c\u306e\u51fa\u767a\u5730\u70b9\u3054\u3068\u306bmax\u3092\u3068\u308a\u3001\u305d\u306emax\u304c\u6700\u5c0f\u306e\u5730\u70b9\u306b\u5f15\u3063\u8d8a\u3057\n#\u305d\u306e\u3068\u304d\u306e\u6240\u8981\u6642\u9593\u304cp\n#print(used)\nanswer = 0\nfor i in range(m):\n  now = hen[i]\n  if d[now[0]][now[1]] != now[2]:\n    answer += 1\n  \nprint(answer)  \n\n", "from collections import defaultdict\nimport heapq\n\n\nINF = 10 ** 6\n\n\ndef check(N, adj_nodes, costs, from_node, to_node):\n    # calculate shortest distances on a graph without a edge (from_node, to_node)\n    dists = [INF for _ in range(N)]\n    dists[from_node] = 0\n    frontier = [(0, from_node)]\n    while len(frontier) > 0:\n        d, node = heapq.heappop(frontier)\n        for next_node in adj_nodes[node]:\n            if (from_node, to_node) == (node, next_node):\n                continue\n            next_d = costs[node][next_node] + dists[node]\n            if dists[next_node] > next_d:\n                dists[next_node] = next_d\n                heapq.heappush(frontier, (next_d, next_node))\n    return costs[from_node][to_node] > dists[to_node]\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    adj_nodes = defaultdict(list)\n    costs = [[INF for _ in range(N)] for _ in range(N)]\n    edges = list()\n    for _ in range(M):\n        a, b, c = list(map(int, input().split(' ')))\n        a -= 1\n        b -= 1\n        adj_nodes[a].append(b)\n        adj_nodes[b].append(a)\n        costs[a][b] = c\n        costs[b][a] = c\n        edges.append((a, b))\n    ans = 0\n    for edge in edges:\n        from_node, to_node = edge\n        if check(N, adj_nodes, costs, from_node, to_node):\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\nimport numpy as np\n\nn,m = map(int,input().split())\nabc = [list(map(int,input().split())) for _ in range(m)]\n\nrow,col,data = zip(*abc)\nL = csr_matrix((data, (row,col)), shape=(n+1,n+1))\n_,path = dijkstra(L,directed = False, return_predecessors = True)\n\ns,e = np.where(path>0)\npath_use = set(map(tuple,np.vstack([path[s,e],e]).T))\n\nprint( m - len(path_use)//2)", "from scipy.sparse.csgraph import floyd_warshall\n\nN,M = map(int,input().split())\n\nedge = [[float(\"inf\") for i in range(N)] for j in range(N) ]\n\nabc = []\nfor _ in range(M):\n    a,b,c = map(int,input().split())\n    abc.append((a,b,c))\n    edge[a-1][b-1] = c\n    edge[b-1][a-1] = c\n\ndist = floyd_warshall(edge)\n\nans = 0\n\nfor a,b,c in abc:\n    if dist[a-1][b-1] != c:\n        ans += 1\n\nprint(ans)", "from scipy.sparse.csgraph import *\nimport numpy as np\nN,M = map(int,input().split())\nE = [list(map(int,input().split())) for m in range(M)]\nG = np.zeros((N,N))\nans = 0\n\nfor a,b,c in E:\n  G[a-1][b-1] = c\n  G[b-1][a-1] = c\n\nF = shortest_path(G).astype(int)\nfor a,b,c in E:\n  if F[a-1][b-1]!=c:\n    ans+=1\n\nprint(ans)", "N,M = map(int,input().split())\n\na = [0]*M\nb = [0]*M\nc = [0]*M\n\nfor i in range(M):\n    a[i],b[i],c[i] = map(int,input().split())\n    a[i] -= 1\n    b[i] -= 1\n    \n\nd = [[float(\"inf\")]*N for i in range(N)]\n\nfor i in range(M):\n    d[a[i]][b[i]] = c[i]\n    d[b[i]][a[i]] = c[i]\n    \nfor i in range(N):\n    d[i][i] = 0\n\nfor s in range(N):\n    for j in range(N):\n        for i in range(N):\n            d[i][j] = min(d[i][j], d[i][s]+d[s][j])\n\ncount = 0\nfor i in range(M):\n    if d[a[i]][b[i]] < c[i]:\n        count += 1\nprint(count)", "INF = float(\"inf\")\n\ndef WarshallFloyd(M):\n    N = len(M)\n    for k in range(N):\n        for j in range(N):\n            for i in range(N):\n                M[i][j] = min(M[i][j], M[i][k] + M[k][j])\n    return M\n\n\nN, M, *ABC = map(int, open(0).read().split())\n\nE = [[INF] * (N + 1) for _ in range(N + 1)]\nfor a, b, c in zip(*[iter(ABC)] * 3):\n    E[a][b] = c\n    E[b][a] = c\n\nD = WarshallFloyd(E)\n\nprint(sum(D[a][b] < c for a, b, c in zip(*[iter(ABC)] * 3)))", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\n# \u5168\u9802\u70b9\u9593\u6700\u77ed\u8def\n# d[i][j]\u306f2\u9802\u70b9\u9593i, j\u9593\u306e\u79fb\u52d5\u30b3\u30b9\u30c8\u3092\u683c\u7d0d, M\u306f\u9802\u70b9\u6570\n\nINF = float(\"inf\")\nimport copy\n\ndef warshall_floyd(d):\n    n = len(d)\n    wf = copy.deepcopy(d)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j])\n    return wf #d[i][j]\u306b\u9802\u70b9i, j\u9593\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u683c\u7d0d\n\n##############################\n\nn, m = list(map(int,input().split())) #N:\u9802\u70b9\u6570 m:\u8fba\u306e\u6570\nd = [[INF] * n for i in range(n)]\n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\nedges = []\nfor i in range(m):\n    u, v, w = list(map(int,input().split()))\n    d[u-1][v-1] = w\n    d[v-1][u-1] = w\n    edges.append((u-1,v-1))\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\n\nfwd = warshall_floyd(d)   #d[i][j]\u306b\u9802\u70b9i, j\u9593\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u683c\u7d0d\n\nret = 0\nfor u,v in edges:\n    if fwd[u][v] < d[u][v]:\n        ret += 1\nprint(ret)\n", "from scipy.sparse.csgraph import floyd_warshall\nimport numpy as np\n\n\nN,M = map(int,input().split())\nf = lambda x: (int(x[0])-1,int(x[1])-1,int(x[2]))\nedges = list(f(input().split()) for _ in range(M))\n\ng = np.zeros((N,N), dtype=float)\n\nfor a,b,c in edges:\n    g[a,b] = c\n    g[b,a] = c\n\nfloyd_warshall(g, directed=False, overwrite=True)\n\nres = sum(int(g[a,b] != c) for a,b,c in edges)\nprint(res)", "N,M = map(int, input().split())\n\nG = [[] for _ in range(N)]\nINF = 10**9\nD = [[ INF for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n  D[i][i] = 0\n\nE = []\nfor _ in range(M):\n  a,b,c = map(int, input().split())\n  a,b = a-1, b-1\n  G[a].append((b,c))\n  G[b].append((a,c))\n  D[a][b] = c\n  D[b][a] = c\n  E.append((a,b,c))\n  \n\nfor k in range(N):\n  for i in range(N):\n    for j in range(N):\n      if D[i][k] + D[k][j] < D[i][j]:\n        D[i][j] = D[i][k] + D[k][j]\n        D[j][i] = D[i][k] + D[k][j]\n  \nans = 0\nfor a,b,c in E:\n  flg = False\n  for i in range(N):\n    if D[i][a] + c == D[i][b]:\n      flg = True\n      break\n   \n  if not flg:\n    ans += 1\n    \nprint(ans)", "import heapq\nn, m = map( int, input().split() )\nadj_list = [ [] for i in range( n+1 ) ]\nfor _ in range( m ):\n    a, b, c = map( int, input().split() )\n    adj_list[ a ].append( ( b, c ) )\n    adj_list[ b ].append( ( a, c ) )\n\n# dijkstra\ndef dijkstra( start ):\n    prev_node = [ -1 ] * ( n + 1 )\n    INF = 10 ** 10\n    VISITED = 1\n    NOT_VISITED = 0\n    cost = [ INF ] * ( n + 1 )\n    cost[ start ] = 0\n    visit = [ NOT_VISITED ] * ( n + 1 )\n    queue = [ ( cost[ start ], start ) ]\n    while len( queue ) > 0:\n        c, v = heapq.heappop( queue )\n        visit[ v ] = VISITED\n        for u, cost_vu in adj_list[v]:\n            if visit[ u ] == VISITED:\n                continue\n            if cost[u] > cost[v] + cost_vu:\n                cost[u] = cost[v] + cost_vu\n                heapq.heappush( queue, ( cost[u], u ) )\n                prev_node[ u ] = v\n    return prev_node\n\nused_edge = [ [ False ] * ( n+1 ) for i in range( n+1 ) ]\n\nused_count = 0\nfor s in range( 1, n+1 ):\n    prev_node = dijkstra( s )\n    for i in range( 1, n+1 ):\n        j = prev_node[ i ]\n        if j == -1:\n            continue\n        if used_edge[ i ][ j ] == False:\n            used_count += 1\n            used_edge[ i ][ j ] = True\n            used_edge[ j ][ i ] = True\n\nprint( m - used_count )", "import heapq\n\n\nINF = float('inf')\nN, M = map(int, input().split())\nto = [[] for _ in range(N)]\n\n#sides[i][j] : i-->j\u3078\u5411\u304b\u3046\u8fba\u3092\u901a\u308b\u304b\u3069\u3046\u304b\u3092\u4fdd\u6301\n# 1 : \u901a\u308b\u30010 : \u901a\u3089\u306a\u3044\nsides = [[0] * N for _ in range(N)]\n\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    a, b = a - 1, b - 1\n    to[a].append((c, b))\n    to[b].append((c, a))\n    sides[a][b] = 1 #a, b\u9593\u306b\u8fba\u304c\u3042\u308b\n    sides[b][a] = 1\n\n\n# dijkstra\u3067\u6700\u77ed\u7d4c\u8def\u6728\u3092\u3064\u304f\u308b\ndef dijkstra(s):\n    hq = [(0, s)]\n    heapq.heapify(hq) \n    cost = [[INF, []] for i in range(N)]\n    cost[s][0] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v][0]:\n            continue\n        for d, u in to[v]:\n            tmp = d + cost[v][0]\n            if tmp < cost[u][0]:\n                cost[u][0] = tmp\n                cost[u][1] = [v] # \u66f4\u65b0\u3059\u308b\u5834\u5408\u306f\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301\n                heapq.heappush(hq, (tmp, u))\n            elif tmp == cost[u][0]:\n                cost[u][1].append(v) # \u8ddd\u96e2\u304c\u7b49\u3057\u3044\u5834\u5408\u306f\u30ea\u30b9\u30c8\u3067\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301  \n                heapq.heappush(hq, (tmp, u))\n    return cost\n\n\n# \u4f5c\u6210\u3057\u305f\u6700\u77ed\u7d4c\u8def\u6728\u3092\u63a2\u7d22\u3057\u3066\u3001\u901a\u308b\u8fba\u3092\u8abf\u3079\u308b\ndef dfs(v, tree, p=-1):\n    if p >= 0:\n        sides[v][p] = 0\n        sides[p][v] = 0\n    for nv in tree[v][1]:\n        dfs(nv, tree, v)\n\n\ndef main():\n    for s in range(N):\n        tree = dijkstra(s)\n        for g in range(N):\n            dfs(g, tree)\n\n    print(sum(sum(column) for column in sides) // 2)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#051_D\ninf = 10 ** 10\nn, m = map(int, input().split())\nd = [[inf for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    d[i][i] = 0\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    d[a-1][b-1] = c\n    d[b-1][a-1] = c\n    edges.append((a-1, b-1, c))\n\ndef warshall_floyd(d):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n                \nwarshall_floyd(d)\n\nans = m\nfor u, v, c in edges:\n    flg = False\n    for i in range(n):\n        if d[i][v] + c == d[i][u]:\n            flg = True\n    \n    if flg:\n        ans -= 1\n\nprint(ans)", "n,w = map(int,input().split()) #n:\u9802\u70b9\u6570\u3000w:\u8fba\u306e\u6570\nfrom collections import defaultdict\nD=defaultdict(list)\ndef warshall_floyd(d):\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if d[i][j]>d[i][k]+d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n                    D[(i,j)]=D[(i,k)]+D[(k,j)][1:]\n    return d\ndone=[[-1]*n for _ in range(n)]\nd = [[float(\"inf\")]*n for i in range(n)] \n#d[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\nfor i in range(w):\n    x,y,z = map(int,input().split())\n    d[x-1][y-1] = z\n    d[y-1][x-1] = z\n    D[(x-1,y-1)]=[x-1,y-1]\n    D[(y-1,x-1)]=[y-1,x-1]\n    done[x-1][y-1]=0\n    done[y-1][x-1]=0\nfor i in range(n):\n    d[i][i] = 0 #\u81ea\u8eab\u306e\u3068\u3053\u308d\u306b\u884c\u304f\u30b3\u30b9\u30c8\u306f\uff10\nwarshall_floyd(d)\nfor l in D.values():\n    for i in range(1,len(l)):\n        a=l[i-1]\n        b=l[i]\n        done[a][b]=1\n        done[b][a]=1\nimport numpy as np\ndone=np.array(done)\nans=(done==0).sum()\n#print(D)\n#print(done)\nprint(ans//2)", "n, m = map(int, input().split())\na, b, c = zip(*[list(map(int, input().split())) for i in range(m)])\n\ndist = [[1e18]*n for i in range(n)]\nfor i in range(m):\n    dist[a[i]-1][b[i]-1] = dist[b[i]-1][a[i]-1] = min(dist[a[i]-1][b[i]-1], c[i])\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\nans = 0\nfor i in range(m):\n    if dist[a[i]-1][b[i]-1]<c[i]:\n        ans += 1\n\nprint(ans)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n \nn, m = map(int, input().split())\nma = [[0]*n for _ in range(n)]\nlist_ABC = [ list(map(int,input().split(\" \"))) for i in range(m)]\n\nfor a, b, c in list_ABC:\n  ma[a-1][b-1] = c\n  ma[b-1][a-1] = c\n  \ny = dijkstra(ma, directed=False).astype(int)\n \nans = 0\n \nfor a, b, c in list_ABC:\n  if y[a-1][b-1] != c:\n    ans += 1\n    \nprint(ans)", "n,m= map(int,input().split())\nrg = [[999999999 for _ in range(n)] for _ in range(n)]\nrgflg = [[False for _ in range(n)] for _ in range(n)]\nfor i in range(m):\n    a,b,c= map(int,input().split())\n    rg[a-1][b-1] = c\n    rgflg[a-1][b-1] = True\n    rg[b-1][a-1] = c\n    rgflg[b-1][a-1] = True\ncount=0\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if rg[i][j] > rg[i][k] + rg[k][j]:\n                rg[i][j] = rg[i][k] + rg[k][j]\n                if rgflg[i][j]==True or rgflg[j][i]==True:\n                    rgflg[i][j]=False\n                    rgflg[j][i]=False\n                    count+=1\nprint(count)", "def main():\n    from itertools import combinations\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1000 * 100 + 10\n\n    N, M = list(map(int, input().split()))\n\n    dist = [[[inf, 0] for _ in range(N)] for _ in range(N)]\n    for j in range(N):\n        dist[j][j] = [0, 0]\n\n    for idx in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        dist[a][b][0] = dist[b][a][0] = c\n        dist[a][b][1] = dist[b][a][1] = 1 << idx  # weight,edge_idx\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                nd = dist[i][k][0] + dist[k][j][0]\n                if dist[i][j][0] > nd:\n                    dist[i][j][0] = nd\n                    dist[i][j][1] = dist[i][k][1] | dist[k][j][1]\n                elif dist[i][j][0] == nd:\n                    dist[i][j][1] |= dist[i][k][1] | dist[k][j][1]\n\n    used_edge = 0\n    for frm, to in combinations(list(range(N)), r=2):\n        used_edge |= dist[frm][to][1]\n\n    print((M - bin(used_edge).count('1')))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn, m = list(map(int, input().split()))\nedges = dict()\nans = [0 for _ in range(m + 1)]\ngraph = [set() for _ in range(n)]\n\n\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    edges[i] = (a - 1, b - 1, c)\n    graph[a - 1].add(i)\n    graph[b - 1].add(i)\n\n# (cost,done,node,edge)\nfor i in range(n):\n    done = [True for _ in range(n)]\n    D = [(0, 0, i, m), ]\n    heapq.heapify(D)\n\n    while D:\n        d = heapq.heappop(D)\n        cost, mark, node, edge = d\n\n        if done[node]:\n            done[node] = False\n            ans[edge] = 1\n\n            for g in graph[node]:\n                a, b, c = edges[g]\n\n                if b == node:\n                    a, b = b, a\n\n                if done[b]:\n                    heapq.heappush(D, (cost + c, ans[g], b, g))\n\nprint((m - (sum(ans) - 1)))\n", "import sys\nimport heapq\nimport re\nfrom itertools import permutations\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, deque\nfrom fractions import gcd\nfrom math import factorial, sqrt, ceil\nfrom functools import lru_cache, reduce\nINF = 1 << 60\nMOD = 1000000007\nsys.setrecursionlimit(10 ** 7)\n\n# UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2,int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\n\n# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9 (\u4efb\u610f\u306e2\u9802\u70b9\u306e\u5bfe\u306b\u5bfe\u3057\u3066\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b)\n# \u8a08\u7b97\u91cfn^3 (n\u306f\u9802\u70b9\u306e\u6570)\ndef warshall_floyd(d, n):\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n    return d\n\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\ndef dijkstra_heap(s, edge, n):\n    #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    d = [10**20] * n\n    used = [True] * n #True:\u672a\u78ba\u5b9a\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for a,b in edge[s]:\n        heapq.heappush(edgelist,a*(10**6)+b)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n        if not used[minedge%(10**6)]:\n            continue\n        v = minedge%(10**6)\n        d[v] = minedge//(10**6)\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])\n    return d\n\n# \u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\n# 2\u6570\u306e\u6700\u5c0f\u516c\u500d\u6570\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\n# \u30ea\u30b9\u30c8\u306e\u8981\u7d20\u306e\u6700\u5c0f\u516c\u500d\u6570\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\n# \u30ea\u30b9\u30c8\u306e\u8981\u7d20\u306e\u6700\u5927\u516c\u7d04\u6570\ndef gcd_list(numbers):\n    return reduce(gcd, numbers)\n\n# \u7d20\u6570\u5224\u5b9a\n\n\n\n# limit\u4ee5\u4e0b\u306e\u7d20\u6570\u3092\u5217\u6319\ndef eratosthenes(limit):\n    A = [i for i in range(2, limit+1)]\n    P = []\n\n    while True:\n        prime = min(A)\n        \n        if prime > sqrt(limit):\n            break\n            \n        P.append(prime)\n            \n        i = 0\n        while i < len(A):\n            if A[i] % prime == 0:\n                A.pop(i)\n                continue\n            i += 1\n            \n    for a in A:\n        P.append(a)\n            \n    return P\n\n# \u540c\u3058\u3082\u306e\u3092\u542b\u3080\u9806\u5217\ndef permutation_with_duplicates(L):\n\n    if L == []:\n        return [[]]\n\n    else:\n        ret = []\n\n        # set\uff08\u96c6\u5408\uff09\u578b\u3067\u91cd\u8907\u3092\u524a\u9664\u3001\u30bd\u30fc\u30c8\n        S = sorted(set(L))\n\n        for i in S:\n\n            data = L[:]\n            data.remove(i)\n\n            for j in permutation_with_duplicates(data):\n                ret.append([i] + j)\n\n        return ret\n\n\n# \u3053\u3053\u304b\u3089\u66f8\u304d\u59cb\u3081\u308b\nn, m = list(map(int, input().split()))\nd = [[INF for j in range(n)] for i in range(n)]\nx = []\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    x.append([a - 1, b - 1, c])\n    d[a - 1][b - 1] = c\n    d[b - 1][a - 1] = c\nd2 = warshall_floyd(d, n)\n# print(d2)\nans = 0\nfor i in x:\n    if d2[i[0]][i[1]] != i[2]:\n        ans += 1\nprint(ans)\n", "n,m = map(int,input().split())\nINF = 10**18\nd = [[INF]*n for _ in range(n)]\nnd = [[INF]*n for _ in range(n)]\nfor i in range(n):\n    d[i][i] = 0\n    nd[i][i] = 0\nfor _ in range(m):\n    a,b,c = map(int,input().split())\n    a -= 1\n    b -= 1\n    d[a][b] = c\n    d[b][a] = c\n    nd[a][b] = c\n    nd[b][a] = c\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            nd[i][j] = min(nd[i][j], nd[i][k]+nd[k][j])\n\ncnt = 0\nfor i in range(n):\n    for j in range(n):\n        if d[i][j] == INF: continue\n        if nd[i][j] < d[i][j]: cnt += 1\nprint(cnt//2)", "n, m = map(int, input().split())\nINF = 10**10\nd = [[INF]*n for _ in range(n)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    d[a-1][b-1] = c\n    d[b-1][a-1] = c\nnxt = [[[i] for i in range(n)] for _ in range(n)]\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if i==j:\n                continue\n            if d[i][k]+d[k][j] < d[i][j]:\n                d[i][j] = d[i][k]+d[k][j]\n                nxt[i][j] = nxt[i][k][:]\n            elif d[i][k]+d[k][j] == d[i][j]:\n                nxt[i][j] += nxt[i][k]\ns = set()\nfor start in range(n):\n    for goal in range(n):\n        if start==goal:\n            continue\n        def DFS(i):\n            for j in nxt[i][goal]:\n                s.add((i, j))\n                if j!=goal:\n                    DFS(j)\n        DFS(start)\nprint(m-len(s)//2)", "N,M=map(int, input().split())\n\ndef warshall_floyd(d):\n  for k in range(N):\n    for i in range(N):\n      for j in range(N):\n        d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n  return d\n\nd=[[float(\"inf\")]*N for i in range(N)]\nA=[]\nfor i in range(M):\n  x,y,z=map(int, input().split())\n  x-=1\n  y-=1\n  d[x][y]=z\n  d[y][x]=z\n  A.append((x,y,z))\n  \nfor i in range(N):\n  d[i][i]=0 \n  \nD=warshall_floyd(d)\n\nans=0\nfor x,y,z in A:\n  if D[x][y]!=z:\n    ans+=1\nprint(ans)", "import sys\nimport heapq\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    k = []\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        edge[a - 1].append([c, b - 1])\n        edge[b - 1].append([c, a - 1])\n        k.append([c, a - 1, b - 1])\n\n    def dijkstra_heap(s):\n        d = [f_inf] * n\n        used = [True] * n\n        d[s] = 0\n        used[s] = False\n        edgelist = []\n        for e in edge[s]:\n            heapq.heappush(edgelist, e)\n        while len(edgelist):\n            minedge = heapq.heappop(edgelist)\n            if not used[minedge[1]]:\n                continue\n            v = minedge[1]\n            d[v] = minedge[0]\n            used[v] = False\n            for e in edge[v]:\n                if used[e[1]]:\n                    heapq.heappush(edgelist, [e[0] + d[v], e[1]])\n        return d\n\n    used = set()\n    for i in range(n):\n        dist = dijkstra_heap(i)\n        for d, to, fr in k:\n            if dist[to] + d == dist[fr]:\n                used.add((to, fr))\n\n    print((len(k) - len(used)))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N,M = map(int,input().split())\nABC = [tuple(map(int,input().split())) for i in range(M)]\n\nINF = float('inf')\nds = [[INF]*N for _ in range(N)]\nfor i in range(N):\n    ds[i][i] = 0\nfor a,b,c in ABC:\n    a,b = a-1,b-1\n    ds[a][b] = ds[b][a] = c\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j])\n\nans = 0\nfor a,b,c in ABC:\n    a,b = a-1,b-1\n    if ds[a][b] < c:\n        ans += 1\nprint(ans)", "n, m = map(int, input().split())\ndis = [[float(\"inf\") for i in range(n)] for j in range(n)]\nfor i in range(n):\n    dis[i][i] = 0\nabc = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    abc.append([a, b, c])\n    dis[a-1][b-1] = c\n    dis[b-1][a-1] = c\ndef warshall_floyd(dis):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dis1 = dis[i][j]\n                dis2 = dis[i][k] + dis[k][j]\n                dis[i][j] = min(dis1, dis2)\n    return dis\ndata = warshall_floyd(dis)\nans = 0\nfor i in range(m):\n    a, b, c = abc[i][0], abc[i][1], abc[i][2]\n    for j in range(n):\n        if c + data[b-1][j] == data[a-1][j]:\n            break\n    else:\n        ans += 1\nprint(ans)", "n,m=map(int,input().split())\nclass WarshallFloyd:\n#O(V^3)\u3067\u4efb\u610f\uff12\u9802\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\n    def __init__(self,n,_first_index=0):\n        self.v = n\n        self._first_idx=_first_index\n        self.d = [[1e100]*(n+_first_index) for _ in range(n+_first_index)]\n        for i in range(n+_first_index):\n            self.d[i][i] = 0\n\n    def path(self,x,y,c):\n        if x == y:\n            return False\n        self.d[x][y] = c\n        self.d[y][x] = c\n        return True\n\n    def build(self):\n        f=self._first_idx\n        for k in range(f,self.v+f):\n            for i in range(f,self.v+f):\n                for j in range(f,self.v+f):\n                    self.d[i][j] = min(self.d[i][j], self.d[i][k] + self.d[k][j])\n        return self.d\nw=WarshallFloyd(n,1)\nl=[]\nfor i in range(m):\n    x,y,c=map(int,input().split())\n    w.path(x,y,c)\n    x,y=sorted([x,y])\n    l.append([x,y,c])\nd=w.build()\nans=0\nfor a,s,c in l:\n    f=1\n    for y in range(1,n+1):\n        if d[y][s]==d[y][a]+c:f=0;break\n    ans+=f\nprint(ans)", "n, m = map(int, input().split())\nGraph = [[float(\"inf\")] * n for i in range(n)]\nA, B, C = [], [], []\nfor i in range(n):\n    Graph[i][i] = 0\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    Graph[a - 1][b - 1] = c\n    Graph[b - 1][a - 1] = c\n    A.append(a - 1)\n    B.append(b - 1)\n    C.append(c)\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            Graph[i][j] = min(Graph[i][j], Graph[i][k] + Graph[k][j])\nans = m\nfor i in range(m):\n    for j in range(n):\n        if Graph[j][A[i]] + C[i] == Graph[j][B[i]]:\n            ans -= 1\n            break\nprint(ans)", "import sys\nfrom heapq import heappush, heappop\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *AB = list(map(int, read().split()))\n    G = [[] for _ in range(N)]\n    for i, (a, b, c) in enumerate(zip(*[iter(AB)] * 3)):\n        G[a - 1].append((b - 1, c, i))\n        G[b - 1].append((a - 1, c, i))\n\n    vec = [False] * M\n    for i in range(N):\n        dist = [INF] * N\n        dist[i] = 0\n        from_edge = [[] for _ in range(N)]\n        hq = [(0, i)]\n\n        while hq:\n            d, v = heappop(hq)\n            if dist[v] < d:\n                continue\n            for nv, cost, edge in G[v]:\n                if dist[nv] > d + cost:\n                    dist[nv] = d + cost\n                    heappush(hq, (dist[nv], nv))\n                    from_edge[nv] = [edge]\n                elif dist[nv] == d + cost:\n                    from_edge[nv].append(edge)\n\n        for edges in from_edge:\n            for e in edges:\n                vec[e] = True\n\n    ans = sum(1 for flag in vec if not flag)\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nn, w = map(int, input().split())\n\nedges = []\n\nd = [[float(\"inf\")]*n for _ in range(n)]\nfor i in range(w):\n    x,y,z = map(int, input().split())\n    x -= 1\n    y -= 1\n    d[x][y] = z\n    d[y][x] = z\n    edges.append((x,y,z))\n\nfor i in range(n):\n    d[i][i] = 0\n# print(\"d\",d)\n\ncsr = csr_matrix(d)\ndp = floyd_warshall(csr)\nans = 0\n# print(\"dp\",dp)\n\nfor i, j, c in edges:\n    # print(i,j,c)\n    if dp[i,j] < c:\n        ans += 1\nprint(ans)", "n,m=map(int,input().split())\nINF=10**18\ne=[[INF for _ in range(n)]for _ in range(n)]\nd=[]\nfor i in range(m):\n  a,b,c=map(int,input().split())\n  e[a-1][b-1]=c\n  e[b-1][a-1]=c\n  d.append((a-1,b-1,c))\nfor k in range(n):\n  for i in range(n):\n    for j in range(n):\n      e[i][j]=min(e[i][j],e[i][k]+e[k][j])\nans=0\nfor i,j,k in d:\n  if e[i][j]!=k:ans+=1\nprint(ans)", "INF=100000000\nN,M=map(int,input().split())\na=[0]*1000\nb=[0]*1000\nc=[0]*1000\ndist=[[INF for _ in range(100)] for _ in range(100)]\nfor i in range(M):\n  a[i],b[i],c[i]=map(int,input().split())\n  a[i]-=1\n  b[i]-=1\nfor i in range(N):\n  for j in range(N):\n    if i==j:\n      dist[i][j]=0\nfor i in range(M):\n  dist[a[i]][b[i]]=min(dist[a[i]][b[i]],c[i])\n  dist[b[i]][a[i]]=min(dist[b[i]][a[i]],c[i])\nfor k in range(N):\n  for i in range(N):\n    for j in range(N):\n      dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])\nans=M\nfor i in range(M):\n  flag=False\n  for j in range(N):\n    if dist[j][a[i]]+c[i]==dist[j][b[i]]: flag=True\n  if flag: ans-=1\nprint(ans)", "N,M = map(int,input().split())\ninf = 10 ** 6\n\nd = [[inf]*N for i in range(N)]\nprev = [[N]*N for i in range(N)]\nvlist = [[0]*N for i in range(N)]\n\nfor i in range(M):\n    a,b,c = map(int,input().split())\n    a -= 1\n    b -= 1\n    vlist[a][b] = 1\n    vlist[b][a] = 1\n    d[a][b] = c\n    d[b][a] = c\n    prev[a][b] = a\n    prev[b][a] = b\n\n#####\n#print(\"d\",d)\n#print(\"vlist\",vlist)\n#print(\"prev\",prev)\n#####\n\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if d[i][j] > d[i][k] + d[k][j]:\n                d[i][j] = d[i][k] + d[k][j]\n                prev[i][j] = prev[k][j]\n\nfor i in range(N):\n    for j in range(N):\n        if prev[i][j] == i:\n            vlist[i][j] = 0\n\n#####\n#print(\"d\",d)\n#print(\"vlist\",vlist)\n#print(\"prev\",prev)\n#####\n\ncount = 0\nfor i in range(N-1):\n    for j in range(i,N):\n        if vlist[i][j] == 1 and vlist[j][i] == 1:\n            count += 1\n\nprint(count)", "N, M = list(map(int, input().split()))\nconns = [tuple(map(int, input().split())) for _ in range(M)]\ncost = [[float(\"INF\")]*N for _ in range(N)]\n\n# make same node cost zeros\nfor i in range(N):\n  cost[i][i] = 0\n\n# update edge cost\nfor a,b,c in conns:\n  cost[a-1][b-1] = c\n  cost[b-1][a-1] = c\n\n# find minimum cost across all pairs of nodes\nfor k in range(N):\n  for i in range(N):\n    for j in range(N):\n      cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])\n\n# find edges without shortest path\ncnt = 0\nfor a,b,c in conns:\n  if c > cost[a-1][b-1]:\n    cnt += 1\n\nprint(cnt)\n  \n", "import heapq\n\n\ndef dijkstra(n, s, g):\n    h = [(0, s)]\n    heapq.heapify(h)\n    cost = [float(\"Inf\")] * (n + 1)  # cost: i -> j\n    cost[s] = 0\n\n    while h:\n        c, v = heapq.heappop(h)\n        if c > cost[v]:\n            continue\n        for d, u in g[v]:\n            d_s_u = d + cost[v]\n            if d_s_u < cost[u]:\n                cost[u] = d_s_u\n                heapq.heappush(h, (d_s_u, u))\n\n    return cost\n\n\ndef main():\n    n, m, *abc = list(map(int, open(0).read().split()))\n    g = [[] for _ in range(n + 1)]\n\n    for a, b, c in zip(*[iter(abc)] * 3):\n        g[a].append([c, b])\n        g[b].append([c, a])\n\n    ans = 0\n    checked = [[False] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        cost = dijkstra(n, i, g)\n        for j, k in g[i]:\n            if checked[i][k]:\n                continue\n            if j > cost[k]:\n                ans += 1\n\n            checked[i][k] = True\n            checked[k][i] = True\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\n\ndef dijkstra(s):\n    dist[s] = 0\n    que = []\n    heapq.heappush(que, (0, s))\n    while len(que) != 0:\n        p = heapq.heappop(que)\n        v = p[1]\n        if (dist[v] < p[0]):\n            continue\n        for e in graph[v]:\n            if dist[e[0]] > dist[v] + e[1]:\n                dist[e[0]] = dist[v] + e[1]\n                prev[e[0]] = v\n                heapq.heappush(que, (dist[e[0]], e[0]))\n\n\ndef get_path(t):\n    path = []\n    while t != -1:\n        path.append(t)\n        t = prev[t]\n    path = path[::-1]\n    return path\n\n\nN, W = list(map(int, input().split()))\ngraph = [[] for i in range(N)]\nedges = {}\nfor i in range(W):\n    x, y, z = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    graph[x].append((y, z))\n    graph[y].append((x, z))\n    edges[(x, y)] = True\n\nfor st in range(N):\n    dist = [float(\"inf\")] * N\n    prev = [-1] * N\n    dijkstra(st)\n    for i in range(N):\n        gp = get_path(i)\n        for i in range(1, len(gp)):\n            edges[(gp[i-1], gp[i])] = False\n\nprint((sum(edges.values())))\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  road = [[100000]*n for _ in range(n)]\n  count = [[-1]*n for i in range(n)]\n  for _ in range(m):\n    a, b, c = map(int, input().split())\n    road[a-1][b-1] = c\n    road[b-1][a-1] = c\n    count[a-1][b-1] = 0\n    count[b-1][a-1] = 0\n  for k in range(n):\n    for i in range(n):\n      for j in range(n):\n        if road[i][k]+road[k][j] < road[i][j]:\n          if count[i][j] == 0:\n            count[i][j] = 1\n          road[i][j] = road[i][k]+road[k][j]\n  ans = 0\n  for i in range(n):\n    ans += count[i].count(1)\n  print(ans//2)\ndef __starting_point():\n  main()\n__starting_point()", "n, m = map(int, input().split())\ngraph = [[float('inf')]*n for i in range(n)]\nu_s=[]\nv_s=[]\nw_s=[]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    u_s.append(u-1)\n    v_s.append(v-1)\n    w_s.append(w)\n    graph[u-1][v-1] = w\n    graph[v-1][u-1] = w\nfor i in range(n):\n    graph[i][i] = 0\n\n\ndef warshall_floyd(adj_m):\n    # _dist[i][j] : i \u304b\u3089 j \u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    _dist=adj_m\n    for _k in range(n):\n        for _i in range(n):\n            for _j in range(n):\n                _dist[_i][_j] = min(_dist[_i][_j], _dist[_i][_k]+_dist[_k][_j])\n    return _dist\n\ndist=warshall_floyd(graph)\n\nans=0\nfor i in range(m):\n    if w_s[i]>dist[u_s[i]][v_s[i]]:\n        ans+=1\n\nprint(ans)", "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\ndef main():\n    N, M = list(map(int, input().split()))\n    w = [[0] * N for i in range(N)]\n    l = []\n    for i in range(M):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        w[a][b] = w[b][a] = c\n        l.append((a,b,c))\n    G = csr_matrix(w)\n    d = floyd_warshall(G, directed=False)\n    r = 0\n    for a, b, c in l:\n        if d[a][b] != c:\n            r += 1\n    return r\nprint((main()))\n", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,M = map(int,input().split())\nABC = [list(map(int,input().split())) for _ in range(M)]\n\ng = [[0 for _ in range(N)] for _ in range(N)]\n\nfor a,b,c in ABC:\n    g[a-1][b-1] = c\n\nfrom scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\ncsg = csgraph_from_dense(g)\nd = floyd_warshall(csg, directed=False)\n\nans = 0\nfor a,b,c in ABC:\n    if c != d[a-1][b-1]:\n        ans += 1\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    cost = [[f_inf] * n for _ in range(n)]\n    for i in range(n):\n        cost[i][i] = 0\n\n    edge = []\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        cost[a - 1][b - 1] = c\n        cost[b - 1][a - 1] = c\n        edge.append([c, a - 1, b - 1])\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])\n\n    res = 0\n    for d, x, y in edge:\n        if cost[x][y] < d:\n            res += 1\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()"]
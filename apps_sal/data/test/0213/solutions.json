["def floo(num, k):\n\treturn (num - 1) // k + 1\n\ndef main():\n\tn, m = map(int, input().split())\n\tlow = 1\n\thigh = 10**9\n\n\tif (m == 0):\n\t\tif (n == 1):\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(-1)\n\t\treturn\n\n\tfor i in range(m):\n\t\tk, f = map(int, input().split())\n\t\tlow = max(low, (k + f - 1) // f)\n\t\tif (f > 1):\n\t\t\thigh = min(high, (k - 1) // (f - 1))\n\tif (floo(n, low) == floo(n, high)):\n\t\tprint(floo(n, low))\n\telse:\n\t\tprint(-1)\n\n\n\nmain()", "n, m = [int(x) for x in input().split()]\ndata = []\nfor i in range(m):\n    k, f = [int(x) for x in input().split()]\n    data.append((k - 1, f - 1))\nans = set()\n#tmp = []\nfor x in range(1, 101):\n    for elem in data:\n        if elem[0] // x != elem[1]:\n            break\n    else:\n        ans.add((n - 1) // x + 1)\n        #tmp.append((n - 1) // x + 1)\nif len(ans) == 1:\n    print(ans.pop())\nelse:\n    print(-1)", "n, m = map(int, input().split())\na = []\nfor i in range(m):\n    k, f = map(int, input().split())\n    a.append((k, f))\nfl = []\nps = 0\nval = -1\nfor i in range(1, 1000):\n    flag = 1\n    for j in range(m):\n        if (a[j][0] - 1) // i != a[j][1] - 1:\n            flag = 0\n    if (flag):\n        ps += 1\n        fl.append(i)\nans = []\nfor i in range(len(fl)):\n    ans.append(((n - 1) // fl[i]) + 1)\nif not len(ans):\n    print(-1)\nelse:\n    tmp = ans[0]\n    flag = 1\n    for i in range(len(ans)):\n        if ans[i] != tmp:\n            flag = 0\n    if not flag:\n        print(-1)\n    else:\n        print(ans[0])", "def rec(i):\n    nonlocal a\n    return i\nimport sys\nfrom collections import Counter\nsys.setrecursionlimit(10**6)\n#n=int(input())\nn,m=list(map(int,input().split()))\na=[[] for i in range(100)]\nb=[i for i in range(1,101)]\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    z=b.copy()\n    for i0 in z:\n        if not(((x-1)>=(y-1)*i0)and((x-1)<y*i0)):\n            b.remove(i0)\n\na=set()\nfor i0 in b:\n    a.add((n-1)//i0)\nif len(a)==1:\n    print(a.pop()+1)\nelse:\n    print(-1)\n", "a,b = list(map(int,input().split()))\nmini = 1\nmaxi = 10000\nfor i in range(b):\n    x,y = list(map(int,input().split()))\n    if y==1:\n        mini = max(mini,x)\n    else:\n        mx = (x-1)//(y-1) \n        mn=(x-1)//y+1\n        if mn*y>=x:\n            mini = max(mini,mn)\n        else:\n            mini = max(mini,mn+1)\n        if mx*y>=x:\n            maxi = min(maxi,mx)\nif (a-1)//maxi==(a-1)//mini:\n    print((a-1)//maxi+1)\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\n#memory = [[] * 100 for i in range(100)]\nmemory = []\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    memory.append((a, b))\n#memory.sort()\n#count = 0\nans = -1\ngl_flag = 1\nfor flat in range(1, 101):\n    flag = 1\n    for i in range(m):\n        if not (memory[i][0] <= memory[i][1] * flat and memory[i][0] > (memory[i][1] - 1) * flat):\n            flag = 0\n            break\n    if (flag == 1):\n        #count += 1\n        ans1 = (n - 1) // flat + 1\n        if (ans != -1 and ans1 != ans):\n            gl_flag = 0\n            break\n        else:\n            ans = ans1 \nif (gl_flag == 0):\n    print(-1)\nelse:\n    print(ans)\n", "import math\nn,m=map(int,input().split())\nznach=range(1,200)\nfor i in range(m):\n    k,f=map(int,input().split())\n    if f==1:\n        a=range(math.ceil(k/f),200)\n    else:\n        niz=math.ceil(k/f)\n        verh=math.floor((k-1)/(f-1))\n        a=range(niz,verh+1)\n    znach=list(set(a)&set(znach))\nif len(znach)==1:\n    if n%znach[0]==0:\n        print(n//znach[0])\n    else:\n        print(n//znach[0]+1)\nelse:\n    a=[]\n    for i in range(len(znach)):\n        if n%znach[i]==0:\n            a.append(n//znach[i])\n        else:\n            a.append(n//znach[i]+1)\n    a=list(set(a))\n    if len(a)>1:\n        print(-1)\n    else:\n        print(a[0])", "n, m = list(map(int, input().split()))\nd = []\n\ncount_of_good = 0\ngood_on_level = []\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    d.append((a, b))\n\nfor on_level in range(1, 101):\n    good = True\n    for el in d:\n        etaj = el[1]\n        kv = el[0]\n        if not ((etaj - 1) * on_level < kv <= etaj * on_level):\n            good = False\n            break\n    if good:\n        count_of_good += 1\n        good_on_level.append(on_level)\n\nans = []\n\nfor i in good_on_level:\n    if n % i == 0:\n        ans.append(n // i)\n    else:\n        ans.append(n // i + 1)\n\nif len(ans) == 1:\n    print(ans[0])\n    return\n\nfor i in range(1, len(ans)):\n    if ans[i - 1] != ans[i]:\n        print('-1')\n        return\n\nprint(ans[0])\n", "n, m = [int(i) for i in input().split()]\nmn = 10 ** 5\nmx = 1\nn -= 1\nfor i in range(m):\n    x, y = [int(i) for i in input().split()]\n    x -= 1\n    y -= 1\n    if y != 0:\n        mn = min(mn, x // y)\n    mx = max(mx, [(x + y) // (y + 1), x // (y + 1) + 1][x % (y + 1) == 0])\na = n // mx\nfor i in range(mx + 1, mn + 1):\n    if a != n // i:\n        print(-1)\n        return\nprint(a + 1)", "m, n = map(int, input().split())\ncanbe = []\nfor i in range(0, n):\n    numb, et = map(int, input().split())\n    can = []\n    for j in range(1, 101):\n        if j * et >= numb and j * (et - 1) < numb:\n            can += [j]\n    canbe += [can]\n    can = []\ncanbeat = []\nfor i in range(1, 101):\n    est = 0\n    for el in canbe:\n        if i in el:\n            est += 1\n    if est == n:\n        canbeat += [i]\nans = []\nfor element in canbeat:\n    if m % element == 0:\n        ans += [m // element]\n    else:\n        ans += [m // element + 1]\nwrit = ans[0]\ntr = 0\nfor element in ans:\n    if element != writ:\n        tr = -1\nif tr == -1:\n    print(tr)\nelse:\n    print(writ)", "n, m = list(map(int, input().split()))\nkv = [None] * 101\nboo = [False] * 101\nfor i in range(m):\n    k, j = list(map(int, input().split()))\n    kv[k] = j\nfor j in range(1, 101):\n    qw = True\n    for i in range(len(kv)):\n        if kv[i] is not None:\n            a = (i - 1) // j + 1\n            if kv[i] != a:\n                qw = False\n    boo[j] = qw\na = sum(boo)\nfirst = 0\nq = set()\nfor i in range(len(boo)):\n    if boo[i]:\n        q.add((n - 1) // i + 1)\n        \n\n\nif len(q) == 1:\n    print(q.pop())\nelse:\n    print(-1)\n            \n        \n        \n        \n", "n, m = list(map(int, input().split()))\ndata = []\nfl = [0] * 1000000\nan = -1\nf = 0\nfor i in range(m):\n    data += [list(map(int, input().split()))]\n    fl[data[i][0]] = data[i][1]\n    if data[i][0] == n:\n        an = data[i][1]\n    f = max(data[i][1], f)\n\n\nif an != -1:\n    print(an)\n    return\ndata.sort()\n\nan = []\nt = True\nfor i in range(m):\n    if data[i][0] != data[i][1]:\n        t = False\nif t:\n    an += [n]\n    \nfor k in range(2, 10001):\n    #print(k)\n    t = True\n    for i in range(m):\n        f = data[i][0] // k + min(1, data[i][0] % k)\n        if data[i][1] != f:\n            t = False\n            break\n    if not t:\n        continue\n    \n    an += [n // k + min(1, n % k)]\n    #print(an)\n\nif len(set(an)) == 1:\n    print(an[0])\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\nv = []\nfor i in range(m):\n    v.append(list(map(int, input().split())))\nans = []\nfor i in range(1, 101):\n    o = True\n    for p in v:\n        if (p[0] - 1) // i != p[1] - 1:\n            o = False\n            break\n    if o:\n        if not(((n - 1) // i + 1) in ans):\n            ans.append(((n - 1) // i + 1))\nif len(ans) == 1:\n    print(ans[0])\nelse:\n    print(-1)\n", "def first(n, m, line):\n    for i in range(0, n): \n        k, f = list(map(int, input().split())) \n        res = [] \n        for j in range(1, 101): \n            if j * f >= k and j * (f - 1) < k: \n                res.append(j) \n        line.append(res) \n        res = [] \n    return line\n\n\ndef check(n, m, hz):\n    for i in range(1, 101): \n        dno = 0 \n        for elem in line: \n            if i in elem: \n                dno += 1 \n        if dno == n: \n            hz.append(i)\n    return hz\n\n\nm, n = list(map(int, input().split())) \nline = [] \nline = first(n, m, line)\nhz = [] \nhz = check(n, m, hz)\nans = [] \n\nfor element in hz: \n    if m % element == 0: \n        ans.append(m // element)\n    else: \n        ans.append(m // element + 1)\nsmth = ans[0] \nansw = 0 \nfor element in ans: \n    if element != smth: \n        answ = -1 \nif answ == -1: \n    print(answ) \nelse: \n    print(smth)\n", "m, n = map(int, input().split())\narr = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    arr.append((a, b))\nans = set()\nfor k in range(1, 150):\n    fl = True\n    for i in range(n):\n        if ((arr[i][0] - 1) // k + 1) != arr[i][1]:\n            fl = False\n            break\n    if fl: ans.add((m - 1) // k + 1)\nif len(ans) == 1:\n    for i in ans:\n        print(i)\nelse:\n    print(-1)", "k = []\nn, m = list(map(int, input().split(\" \")))\nfor i in range(m):\n\tx, y = list(map(int, input().split(' ')))\n\tk.append([x, y])\n\ndef ok(x):\n\tfor i in k:\n\t\tif (i[0]-1)//x+1!=i[1]:\n\t\t\treturn False\n\treturn True\n\nposs = []\nfor x in range(1, 101):\n\tif ok(x):\n\t\tposs.append((n-1)//x+1)\n\nif len(list(set(poss))) == 1:\n\tprint(poss[0])\nelse:\n\tprint(-1)\n\n\n", "import sys, os\nn, m = map(int, input().split())\nmi = []\nma = []\nif m == 0:\n    if n == 1:\n        print(1)\n    else:\n        print(-1)\n    return\n    return\n    os.abort()\nfor i in range(m):\n    a, b = map(int, input().split())\n    if b == 1:\n        ma.append(1000000000)\n        mi.append(a)\n        if n <= a:\n            print(1)\n            return\n            return\n            os.abort()\n    else:\n        mak = (a - 1) // (b - 1)\n        ma.append(mak)\n        if a % b == 0:\n            mi.append(a // b)\n        else:\n            mi.append((a // b ) + 1)\n#print(mi, ma)\nmik = min(ma)\nmak = max(mi)\nif n % mik == 0:\n    a = n // mik\nelse:\n    a = (n // mik) + 1\n\nif n % mak == 0:\n    b = n // mak\nelse:\n    b = (n // mak) + 1\nif a == b:\n    print(b)\nelse:\n    print(-1)", "n, m = map(int, input().split())\nl = set()\ns = {i for i in range(1, 101)}\nb = False\nfor i in range(m):\n  k, f = map(int, input().split())\n  if k == n:\n    print(f)\n    b = True\n    break\n  j = 1\n  if f == 1:\n    l = {i for i in range(k, 101)}\n  else:\n    while j <= (k-j)//(f-1):\n      if (k-j)%(f-1) == 0:\n        l.add((k-j)//(f-1))\n        j += f-1\n      else:\n        j += 1\n  s &= l\n  l.clear()\na = -1\nif b == False:\n  t = True\n  for j in s:\n    if a == -1:\n      a = (n-1)//j\n    else:\n      if (n-1)//j != a:\n        print(-1)\n        t = False\n        break\n  if t == True:\n    print(a+1)", "n, m = map(int, input().split())\nmin_ = 10000\nmax_ = 0\nfor i in range(m):\n    k, f = map(int, input().split())\n    if f > 1:\n        min_ = min(k / (f - 1), min_)\n    max_ = max(k / f, max_)\nmin_, max_ = max_, min_\n\n\nif(min_ != int(min_)):\n    min_ +=1\nmin_ = int(min_)\n\nif (max_ != int(max_)):\n    max_+=1\nmax_ = int(max_)\n\n#print(min_, max_)\n\ns = set()\nfor i in range(max(1, min_), max_):\n    b = n // i\n    if (n % i) != 0:\n        b+=1\n    s.add(b)\nif len(s) == 1:\n    print(b)\nelse:\n    print(-1)", "n,m=list(map(int,input().split()))\nk=[0]*m\nf=[0]*m\nl=1\nr=100\nfor i in range(m):\n    k[i],f[i]=list(map(int,input().split()))\nfor i in range(m):\n    fl=True\n    for kol in range(l,r+1):\n        ch=k[i]-(f[i]-1)*kol\n        if ch>0 and ch<=kol:\n            if fl:\n                l=kol\n                fl=False\n        elif not fl:\n            r=kol-1\n            break\n    if r-l==0:\n        print((n+r-1)//r)\n        break\nelse:\n    kok=(n+r-1)//r\n    for kol in range(l,r):\n        if kok!=(n+kol-1)//kol:\n            print(-1)\n            break\n    else:\n        print(kok)\n                \n", "n, m = map(int, input().split())\n\nl = -100\nr = 100\nfor i in range(m):\n    k, f = map(int, input().split())\n    l = max(l, (k + f - 1) // f)\n    if(f != 1):\n        r = min(r, (k - 1) // (f - 1))\n\nif(l == r):\n    print((n + r - 1) // r)\nelif ((n + r - 1) // r == (n + l - 1) // l):\n    print((n + r - 1) // r)\nelse:\n    print(-1)", "n, m = map(int, input().split())\nlist1 = []\nans = set()\nif n == 1:\n    print(1)\nelse:\n    for i in range(m):\n        list1.append(list(map(int, input().split())))\n    for i in range(1, 101):\n        if len(ans) > 1:\n            print(-1)\n            break\n        for j in range(len(list1)):\n            if (list1[j][0] - 1) // i + 1 != list1[j][1]:\n                break\n        else:\n            ans.add((n - 1) // i + 1)\n    else:\n        if len(ans) == 1:\n            print(*list(ans))\n        else:\n            print(-1)", "import math\n\ndef f(m):\n    nonlocal h\n    f = True\n    for i in range(len(h)):\n        for j in h[i]:\n            if not(j <= i * m and j > (i - 1) * m ):\n                f = False\n    return f\n\nn, m = map(int, input().split())\nh  = [[] for i in range(110)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    h[b].append(a)\nk = 0\nans = []\nfor i in range(1, 110):\n    if f(i):\n        k += 1\n        ans.append(i)\nfl = False\nfor i in range(len(h)):\n    for j in h[i]:\n        if j == n:\n            fl = True\n            ans1 = i\nif fl:\n    print(ans1)\nelif m == 0 and n == 1:\n    print(1)\nelif k > 1:\n    pr = math.ceil(n / ans[0])\n    fl1 = True\n    for i in range(1, len(ans)):\n        if pr != math.ceil(n / ans[i]):\n            fl1 = False\n    if not fl1:\n        print(-1)\n    else:\n        print(pr)\nelif k < 1:\n    print(-1)\nelse:\n    print(math.ceil(n / ans[0]))", "\nn,m=list(map(int,input().split()))\nk=[]\nf=[]\nfor i in range(m):\n    u,p=list(map(int,input().split()))\n    k.append(u)\n    f.append(p)\ndef ok(x):\n    for i in range(m):\n        if (k[i]-1)//x+1!=f[i]:\n            return False\n    return True\na=[]\nfor i in range(1,101):\n    if(ok(i)):\n        a.append((n-1)//i+1)\nif len(list(set(a)))==1:\n    print(a[0])\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\n\nn = n - 1\net = []\nfor i in range(m):\n    et.append(tuple(map(lambda x: int(x) - 1, input().split())))\net.sort()\nres = -1\nif n == 0:\n    res = 1\nelif len(et) == 0:\n    pass\nelse:\n    et = [(-1, 0)] + et\n    for i in range(len(et) - 1):\n        if et[i][0] <= n <= et[i+1][0] and et[i][1] == et[i+1][1]:\n            res = et[i][1] + 1\n            break\n    et = et[1:]\n    if res == -1 and et[-1][1] != 0:\n        y = []\n        \n        for i in range(1, et[-1][0] // et[-1][1] + 1):\n            fl = True\n            for j in range(len(et)):\n                if et[j][0] // i != et[j][1]:\n                    fl = False\n                    break\n            if fl:\n                y.append(i)\n        y1 = set([(n // tmp + 1) for tmp in y])\n        if len(y1) == 1:\n            res = y1.pop()\nprint(res)"]
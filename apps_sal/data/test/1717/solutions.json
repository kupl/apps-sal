["import math\nfrom functools import reduce\nN = int(input())\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\nA = []\nfor i in range(2, N+1):\n    A.append(i)\n\nX = lcm(*A) + 1\nprint(X)\n", "import math\nimport numpy as np\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    ans = 1\n    for i in range(1,n+1):\n        ans = ans*i//math.gcd(ans,i)\n    print(ans+1)\n\nmain()", "n=int(input())\nl=[3,7,9,11,13,16,17,19,23,25,29]\na=1\nfor i in l:\n    a*=i\nprint(a+1)", "N = int(input())\nfactor = set([2, 3, 4, 5, 7, 9, 10, 11, 13, 17, 19, 23, 29])\nres = 1\nfor i in range(2, N+1):\n    if i in factor:\n        res *= i\nprint((res+1))\n", "import fractions\nn = int(input())\nans = 2\nfor i in range(2, n+1):\n    ans = ans * i // fractions.gcd(ans, i)\n    \nprint(ans+1)", "import math\nfrom functools import reduce\nN=int(input())\nsaisyo=[]\nfor a in range(2,N+1):\n    saisyo.append(a)\n# print(saisyo)\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nprint(lcm_list(saisyo)+1)", "# coding: utf-8\nfrom math import gcd\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\nN = int(input())\nans = 1\nfor i in range(2, N + 1):\n    ans = lcm(ans, i)\nans = 2 * ans + 1\nprint(ans)\n", "import math\nn = int(input())\na = 1\nfor i in range(1, n + 1):\n  a *= i // math.gcd(a, i)\nprint(a + 1)", "from math import gcd\n\nn = int(input())\n\nsum = 1\n\nfor i in range(2,n+1):\n    sum = (sum*i) // gcd(sum,i)\n\nprint(sum+1)", "print(2329089562801)", "N=int(input())\npp=[1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23,1,5,1,3,1,29,1]\n\npN=1\nfor i in range(1,N+1):\n  pN*=pp[i-1]\n  \nprint(pN+1)", "N = int(input())\n\n#1\uff5eN\u307e\u3067\u306e\u6700\u5c0f\u516c\u500d\u6570+1\u304c\u7b54\u3048\n\n#\u6700\u5c0f\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b\n\ndef gcd(a, b) :\n    while b != 0:\n        a, b = b, a%b\n    return a\n\n#\u6700\u5c0f\u516c\u500d\u6570\n\ndef lcm(a, b) :\n    return int(a*b/gcd(a,b))\n\nans = 2\n\nfor i in range(3,N+1):\n    ans = lcm(ans,i)\n\nprint((ans+1))\n", "n = int(input())\nd = {}\nfor i in range(2, 31):\n    d[i] = 0\n\nfor i in range(2, n + 1):\n    s = {}\n    for j in range(2, 31):\n        s[j] = 0\n    x = i\n    for j in range(2, i + 1):\n        while x % j == 0 and x >= j:\n            s[j] += 1\n            x /= j\n\n    for j in range(2, n + 1):\n        if s[j] > d[j]:\n            d[j] = s[j]\n\nans = int(1)\nfor i in range(2, n + 1):\n    ans *= (i ** d[i])\n    #print(i, d[i])\n\nprint((ans + 1))\n", "N = int(input())\n\nX = 1\nfor i in range(2,N+1):\n    if X % i == 0:\n        continue\n    else:\n        X *= i\n\nif X > 1e13:\n    X = X // 20 + 1\nelse:\n    X += 1\n\nprint(X)", "import sys\n#from collections import deque\n#from functools import lru_cache\n#from fractions import Fraction as f\nfrom copy import *\nfrom bisect import *\t\n#from heapq import *\nfrom math import gcd,ceil,sqrt\n#from itertools import permutations as prm,product\n#from random import *\ndef eprint(*args):\n    print(*args, file=sys.stderr)\nzz=1\n \nsys.setrecursionlimit(10**5)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef string(s):\n\treturn \"\".join(s)\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint(\"Case #\"+str(tc)+\":\",ans)\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tmap(int,input().split())\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\t\t\n\nwhile t>0:\n\tt-=1\n\tn=fi()\n\tl=1\n\tfor i in range(2,n+1):\n\t\tl=(l*i)//gcd(l,i)\n\tprint(l+1)\t\n", "import math\nN = int(input())\ngcd = 1\nfor i in range(2, N + 1):\n    gcd = gcd * i // math.gcd(gcd, i)\nprint(gcd + 1)", "import sys\nfrom collections import defaultdict\n\nread = sys.stdin.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef prime_factorize(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n    if arr == []:\n        arr.append([n, 1])\n    return arr\n\n\ndef main():\n    N = int(readline())\n    d = defaultdict(int)\n    for i in range(2, N + 1):\n        P = prime_factorize(i)\n        for x, n in P:\n            d[x] = max(d[x], n)\n\n    ans = 1\n    for x, n in list(d.items()):\n        ans *= x ** n\n    ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\nn = int(input())\nnum = 1\nfor i in range(2,n+1):\n    num = lcm(num,i)\nprint(num+1)", "n = int(input())\nj = 2\nv = 2\ndef johou(a,b):\n    mx = max(a,b)\n    mn = min(a,b)\n    while True:\n        tmp = mn\n        mn = mx % mn\n        mx = tmp\n        if mn == 0:\n            return mx\n            break\nfor i in range(2,n+1):\n    j = johou(v,i)\n    v = i*v/j\nprint(int(v+1))", "import math\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\nn = int(input())\nans = 2\nfor i in range(1, n+1):\n    ans = lcm(ans, i)\nprint(ans + 1)", "import math\nn = int(input())\ntem = 1\n\nfor i in range(1,n+1):\n  tem = tem*i//(math.gcd(tem,i))\n  \nprint(tem+1)", "from math import gcd\nN = int(input())\na = []\nele = 0\nfor i in range(2, N+1):\n    ele = ele + i\n    a.append(ele)\n    ele = 0\nb = a\n\nlcm = b[0]\nfor i in b[1:]:\n    lcm = lcm * i // gcd(lcm, i)\n\nprint(lcm+1)", "print(\"2329089562801\")", "def lcm(a, b):\n    import math\n    return math.floor(a*b/math.gcd(a, b))\nN = int(input())\nans = 1\nfor i in range(2, N+1):\n    ans = lcm(ans, i)\nprint(ans+1)", "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\n\nN = int(input())\nnumList = list(range(2,N+1))\nans = lcm_list(numList) + 1\nprint(ans)\n", "n=int(input())\n\ndef gcd(a,b):\n    if a==0:\n        return b\n    return gcd(b%a,a)\n\nans=1\nfor i in range(2,n+1):\n    ans=(ans*i)//gcd(ans,i)\nprint((ans+1))\n", "import sys\nimport logging\nimport math\nfrom functools import reduce\n\n\ndef lcm(a: int, b: int) -> int:\n    return a * b // math.gcd(a, b)\n\n\ndef lcm_list(numbers):\n    return reduce(lcm, numbers)\n\n\ndef main():\n    n = int(input())\n    ans = lcm_list(list(range(2, n + 1)))\n    print((ans + 1))\n\n\ndef __starting_point():\n    if len(sys.argv) >= 2 and sys.argv[1] == \"--debug\":\n        loglevel = \"debug\"\n    else:\n        loglevel = \"warning\"\n\n    numeric_level = getattr(logging, loglevel.upper(), None)\n    if not isinstance(numeric_level, int):\n        raise ValueError(\"Invalid log level: %s\" % loglevel)\n    logging.basicConfig(\n        level=numeric_level, format=\"%(levelname)s (%(asctime)s.%(msecs)d): %(message)s\", datefmt=\"%I:%M:%S\"\n    )\n\n    main()\n\n__starting_point()", "def gcm(a,b):\n  if b%a == 0:\n    return a\n  return gcm(b%a,a)\n\ndef gcm_2(a,b):\n  Gcm = gcm(a,b)\n  return a*b/Gcm\n\nN = int(input())\n\nans = 2\nfor i in range(3,N+1):\n  ans = gcm_2(ans,i)\nans += 1\nprint(int(ans))", "from collections import defaultdict\nn = int(input())\ns = 1\nkeys = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\npowers = defaultdict(lambda : 0)\n\nfor i in range(2, n+1):\n    for key in keys:\n        x = i\n        cur = 0\n        while x > 0 and x % key == 0:\n            x //= key\n            cur += 1\n        powers[key] = max(powers[key], cur)\n\n# print(dict(powers))\nfor key in keys:\n    s *= (key ** powers[key])\ns += 1\nprint(s)\n\n# for i in range(2, n+1):\n#     print(i, s % i)\n", "# coding: utf-8\nfrom math import gcd\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nN = int(input())\nans = 1\nfor i in range(1, N+1):\n    ans = lcm(ans, i)\nprint(2 * ans + 1)", "print(2329089562801)", "from math import gcd\nfrom sys import stdin\npin=stdin.readline\ndef lcm(a,b):\n  return a*b//gcd(a,b)\n\ndef main():\n  N=int(pin())\n  k=2\n  for i in range(3,N+1):\n    k=lcm(k,i)\n  print(k+1)\n  return\n\nmain()", "import math\nn = int(input())\n\ndef lcm(x, y):\n    return x * y // math.gcd(x, y)\n\nans = 1\nfor i in range(1, n + 1):\n    ans = lcm(i, ans)\nprint((ans + 1))\n", "print(2329089562801)", "print(2329089562801)", "n = int(input())\n\ndef gcd(u, v):\n    if u < v:\n        return gcd(v, u)\n    if v == 0:\n        return u\n    return gcd(v, u % v)\n\nx = 1\nfor i in range(1, n + 1):\n    x = i // gcd(x, i) * x\n\nprint((x + 1))\n", "print(2329089562801)", "N = int(input())\nfac = [i+2 for i in range(N-1)]\nnum = 1\n\nfor i in range(N-1):\n  num = num * fac[i]\n  \n  fac = [x//fac[i] if x%fac[i] == 0 else x for x in fac]\n  #print(fac)\n\nprint((num+1))\n", "N = int(input())\n\ndef prime_check(n):\n    for i in range(2,int(n/2)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef factor(n):\n    tmp = n\n    out = [0] * len(prime_nums)\n    i = 0\n    while tmp != 1:\n        if tmp % prime_nums[i] == 0:\n            tmp = tmp // prime_nums[i]\n            out[i] += 1\n        else:\n            i += 1\n    return out\n        \nprime_nums = [k for k in range(2, N+1) if prime_check(k)]\nmemo = []\nfor i in range(1, N+1):\n    memo.append(factor(i))\n\nrecord = [0] * len(prime_nums)\nfor p in range(len(prime_nums)):\n    for j in range(N):\n        record[p] = max(record[p], memo[j][p])\n        \nans = 1\nfor i in [b**a for a, b in zip(record, prime_nums)]:\n    ans *= i\n\nprint(ans+1)", "import math\nN = int(input())\nres = 1\nfor i in range(2, N+1):\n    res = res*i//math.gcd(res, i)\nprint((res+1))\n", "import math\nN=int(input())\n\n  #\u6700\u5c0f\u516c\u500d\u6570(least common multiple)\u3092\u4f5c\u308b\nprime_factor=[2,3,5,7,11,13,17,19,23,29]\ndef find_prime_factor(n,ans):\n  for i in prime_factor:\n    ni=0\n    nn=n\n    while nn%i==0:\n      ni+=1\n      nn/=i\n    if ans[i]<ni:\n      ans[i]=ni      \n  return ans\n\nans=dict(list(zip(prime_factor,[0]*len(prime_factor))))\nfor i in range(2,N+1):\n  ans=find_prime_factor(i,ans)\nret=1\nfor i in ans:\n  ret=ret*i**(ans[i])\nret+=1\n\nprint(ret)\n\n  \n", "print(2329089562801)", "print(2329089562801)", "import math\n\nn=int(input())\nans=1\nfor i in range(1,n+1):\n    if ans%i!=0:\n        a=math.gcd(ans,i)\n        ans*=i//a\nans+=1\nprint(ans)\n", "N=int(input())\nimport math\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\ng=1\nfor i in range(2,N+1):\n    g=lcm(g,i)\nprint(g+1)", "import numpy as np\nn=int(input())\nx=1\nfor i in range(2,n+1):\n    x=np.lcm(x,i)#\u4eca\u307e\u3067\u306e\u6700\u5c0f\u516c\u500d\u6570\u3068\u306e\u6700\u5c0f\u516c\u500d\u6570\u3092\u6c42\u3081\u308b\nprint(x+1)", "from math import gcd\nN = int(input())\nr = 1\nfor i in range(2, N + 1):\n    r = r / gcd(int(r), i) * i\nprint((int(r) + 1))\n", "n = int(input())\nl = [0,1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23,1,5,1,3,1,29,1]\nproduct = 1\nfor i in range(1,n+1):\n    product *= l[i]\nprint(product+1)", "from math import gcd\nn = int(input())\nl = 1\nfor i in range(1, n+1):\n    l = (l*i)//gcd(l, i)\n\nprint((l+1))\n", "from functools import reduce\nimport math\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\nn=int(input())\nn_list=[]\nfor i in range(n-1):\n  n_list.append(i+2)\nprint(lcm_list(n_list)+1)", "print(2329089562801)", "import numpy as np\nn = int(input())\nx = np.lcm.reduce(list(range(2, n+1)), dtype=np.int64)+1\nprint(x)", "input()\nprint((16 * 27 * 25 * 7 * 11 * 13 * 17 * 19 * 23 * 29 + 1))\n", "import math\nfrom functools import reduce\n\ndef lcm(x,y):\n  return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\nN = int(input())\n\nanslist = [i for i in range(2,N+1)]\n  \n#print (anslist)\nL = lcm_list(anslist)\nprint (L+1)", "import math\nn = int(input())\nans = 1\n\np = [7,11,13,17,19,23,29]\n\nfor j in p:\n    if j > n:\n        break\n    ans *= j\n\nans *= 2**math.floor(math.log(n,2))*3**math.floor(math.log(n,3))*5**math.floor(math.log(n,5))\n\nprint((ans+1))\n", "print(2329089562801)", "import sys\nfrom math import gcd\n\nread = sys.stdin.buffer.read\n\nx = 1\nfor n in range(1, 31):\n    x = x // gcd(x, n) * n\n\nprint((x + 1))\n", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef lcml(a):\n    if len(a) == 1:\n        return a[0]\n    else:\n        return lcm(a[0], lcml(a[1:]))\n\nn = int(input())\nprint((lcml(list(range(2, n+1)))+1))\n", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return map(int,input().split())\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(map(max,x))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)//2\n\n    if rr == mid:\n        return ll\n    if (\u3053\u3053\u306b\u8a55\u4fa1\u5165\u308c\u308b):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\nimport math\nfrom functools import reduce\ndef gcd(*numbers):\n    return reduce(math.gcd, numbers)\n\ndef gcd_list(numbers):\n    return reduce(math.gcd, numbers)\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\n\nn = onem()\n\nans = 1\n\nfor i in range(1,n+1):\n    ans = lcm(ans,i)\nprint(ans+1)", "import sys\ninput=sys.stdin.readline\n#print=sys.stdout.write\n#sys.setrecursionlimit(100000)\n#from heapq import *\n#from collections import deque as dq\nfrom math import ceil,floor,sqrt,gcd,log\n#import bisect as bs\n#from collections import Counter\n#from collections import defaultdict as dc \n#from functools import reduce\n#from functools import lru_cache\nri=lambda:int(input())\nrl=lambda:list(map(int,input().split()))\nrs=lambda:input()\nfor _ in range(1):\n    N=ri()\n    ans=1\n    for i in range(2,N+1):\n        ans=ans*i//gcd(ans,i)\n    print(ans+1)", "from math import gcd\ndef lcm(a,b):\n    return a*b // gcd(a,b)\nn = int(input())\na = 2\nfor i in range(3,n+1):\n    a = lcm(a,i)\nprint(a+1)", "print(2329089562801)", "n=int(input())\na=1\nfrom math import gcd\nfor i in range(2,n+1):\n  if a%i:\n    g=gcd(a,i)\n    a=a*i//g\nprint(a+1)", "import math\n\nn = int(input())\n\ndef fun(x, y):\n    return (x * y) // math.gcd(x, y)\n\nans = 1\nfor i in range(1, n + 1):\n    ans = fun(ans, i)\n\nprint(ans + 1)", "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\n\n\ndef main():\n    N = int(input())\n\n    n = lcm(2, 3)\n    for i in range(4, N + 1):\n        if N == 2:\n            print((3))\n        elif N == 3:\n            print((7))\n        else:\n            n = lcm(n, i)\n    print((n + 1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nn = int(input())\nlst = [i for i in range(2, n + 1)]\nprint(lcm_list(lst) + 1)", "import fractions\nn = int(input())\na = list(range(2,n+1))\n\ndef gcd(x,y):\n    if y == 0:\n        return x\n    else:\n        return gcd(y,x%y)\n\nans = a[0]\n\nfor i in range(n-1):\n    ans = ans*a[i] // fractions.gcd(ans,a[i])\n\nprint((ans+1))\n\n", "import math\nN = int(input())\narr = [0] * (N+1)\nfor i in range(2, N+1):\n  num = i\n  for j in range(2, N+1):\n    count = 0\n    while num % j == 0:\n      num /= j\n      count += 1\n    arr[j] = max(arr[j], count)\nans = 1\nfor j, v in enumerate(arr):\n  if v != 0:\n    ans *= pow(j,v)\nans += 1\nprint(ans)", "from collections import defaultdict\n\n\ndef factorize(n: int) -> dict:\n    f = defaultdict(int)\n    while n % 2 == 0:\n        f[2] += 1\n        n //= 2\n    p = 3\n    while p * p <= n:\n        while n % p == 0:\n            f[p] += 1\n            n //= p\n        p += 2\n    if n != 1:\n        f[n] += 1\n    return f\n\n\nn = int(input())\nans = 1\nfor i in range(1, n + 1):\n    f_ans = factorize(ans)\n    f_i = factorize(i)\n\n    for k, v in list(f_i.items()):\n        if f_ans[k] < v:\n            ans *= pow(k, v - f_ans[k])\nans += 1\nprint(ans)\n", "from math import gcd\nn = int(input())\nans = 1\nfor i in range(1, n+1):\n    ans = (ans * i) // gcd(ans, i)\nprint(ans + 1)", "import math\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\nn = int(input())\nans = 1\nfor i in range(2, n+1):\n    ans = lcm(ans, i)\nprint(ans + 1)", "import math\nfrom functools import reduce\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef __starting_point():\n    N = int(input())\n    n = [i for i in range(2,N+1)]\n    print(lcm_list(n)+1)\n__starting_point()", "N=input()\nprint(2329089562801)", "from itertools import accumulate,chain,combinations,groupby,permutations,product\nfrom collections import deque,Counter\nfrom bisect import bisect_left,bisect_right\nfrom math import gcd,sqrt,sin,cos,tan,degrees,radians\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom functools import reduce\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n#from sys import setrecursionlimit\n#setrecursionlimit(10**7)\nMOD=10**9+7\nINF=float('inf')\n\ndef lcm_base(x, y):\n    return (x * y) // gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\nn = int(input())\n\nprint(1 + lcm(*list(range(2, n + 1))))", "n = int(input())\ntmp = 2\n\ndef gcd(a,b):\n  if a%b == 0:\n    return b\n  else:\n    return gcd(b,a%b)\n\nfor i in range(3,n+1):\n  tmp =  tmp*i // gcd(tmp,i)\n\nprint(tmp + 1)", "print(8*9*5*29*23*19*17*13*11*7*5*3*2+1)", "print(25200*11*3*17*19*23*29*13+1)", "from math import gcd\ndef resolve():\n#====input code===\n    n = int(input())\n    ans = 1\n    for i in range(1,n+1):\n        ans = i * ans // gcd(i, ans)\n    print(ans+1)\n#================\nresolve()", "#n = int(input())\nn = 30\n\n# \uff12\u3067\u5272\u3063\u3066\u3082\uff11\u4f59\u308b\u305f\u3081\u3001Ans\u306f\u5fc5\u305a\u5947\u6570 \n# multi = 6*10*14*33*26*17*19*23*15*29\nmulti = 2 * 2 * 4 * 3 *  3 * 3 * 5 * 7* 11 *13 * 17 * 19 * 23 * 5 * 29 + 1\nprint(multi)\n# multi = 10 ** 13 - 1\n'''\nnum = 2\nwhile num <= n:\n    print(num, ',',multi%num)\n    num += 1\n'''\n\n", "\nimport fractions\n\n\nN = int(input())\na = []\n\nfor i in range(2, N + 1):\n    a.append(i)\n\nans = a[0]\n\nfor i in range(1, N - 1):\n    ans = ans * a[i] // fractions.gcd(ans, a[i])\n\nprint((ans + 1))\n", "print(2329089562801)", "print(2329089562801);", "# -*- coding: utf-8 -*-\nimport math\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn = int(input())\nans = 2\nfor i in range(3, n+1):\n    ans = lcm(ans, i)\n\nprint((ans+1))\n", "def find_lcm(num1, num2): \n    if(num1>num2): \n        num = num1 \n        den = num2 \n    else: \n        num = num2 \n        den = num1 \n    rem = num % den \n    while(rem != 0): \n        num = den \n        den = rem \n        rem = num % den \n    gcd = den \n    lcm = int(int(num1 * num2)/int(gcd)) \n    return lcm\n\nn=int(input())\narr=[i for i in range(1,n+1)]\nlcm=find_lcm(arr[0],arr[1])\ni=2\nwhile i<n:\n    lcm=find_lcm(lcm,arr[i])\n    i+=1\n\nprint(lcm+1)", "\nN=int(input())\n\nprint(2**4*3**3*5**2*7*11*13*17*19*23*29+1)", "from math import gcd\n\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\n\nn = input()\nn = int(n)\nll = 2\nfor i in range(3, n + 1):\n    ll = lcm(ll, i)\nprint((ll + 1))\n", "import math\nfrom functools import reduce\nN=int(input())\nsaisyo=[]\nfor a in range(2,N+1):\n    saisyo.append(a)\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef lcm_list(numbers):\n    return reduce(lcm_base, numbers, 1)\n\nprint(lcm_list(saisyo)+1)", "\nimport numpy as np\nN=int(input())\nx=1\nfor i in range(2,N+1):\n    x=np.lcm(x,i)\nprint(x+1)", "from math import gcd\n\ndef lcm(x,y):\n    return (x*y)//gcd(x,y)\n\ndef arr_lcm(arr):\n    if len(arr)==2:\n        return lcm(arr[0],arr[1])\n    return lcm(arr[0],arr_lcm(arr[1:]))\n\nn=int(input())\nprint(arr_lcm([i for i in range(1,n+1)])+1)", "n = int(input())\n\nfrom math import gcd\nres = 1\nfor i in range(2,n+1):\n    res = res*i//gcd(res,i)\n\nprint(res+1)", "from functools import reduce\n\n\ndef GCD(a: int, b: int) -> int:\n    return a if b == 0 else GCD(b, a % b)\n\n\ndef LCM(a: int, b: int) -> int:\n    return a * b // GCD(a, b)\n\n\nn = int(input())\nans = reduce(LCM, list(range(1, n + 1))) + 1\nprint(ans)\n", "def main():\n    n = int(input())\n    primes = dict()\n    ans = 1\n    for i in range(2, n + 1):\n        t = i\n        j = 2\n        while j * j <= t:\n            k = 0\n            while t % j == 0:\n                t //= j\n                k += 1\n            if k != 0:\n                if j in primes:\n                    primes[j] = max(primes[j], k)\n                else:\n                    primes[j] = k\n            j += 1\n        if t != 1:\n            if t in primes:\n                primes[t] = max(primes[t], 1)\n            else:\n                primes[t] = 1\n    for i, t in list(primes.items()):\n        ans *= i ** t\n    print((ans + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from fractions import gcd\n\nn = int(input())\nkotae = 1\nfor i in range(2, n + 1):\n  kotae = kotae * i // gcd(kotae, i)\nprint((kotae + 1))\n", "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n\n    return a\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\ndef main():\n    N = int(input())\n    y = 1\n\n    for x in range(2, N + 1):\n        y = lcm(y, x)\n\n    print((y + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\nn = int(input())\ncommon = 1\nfor num in range(1,n + 1):\n    common = common * num // math.gcd(common, num)\nprint(common + 1)", "n=int(input())\ndef gcd(a,b):\n  while b:\n    a,b=b,a%b\n  return a\ndef lcm(a,b):\n  return a*b//gcd(a,b)\nans=2\nfor i in range(3, n + 1):\n  ans=lcm(ans,i)\nprint(ans+1)", "def gcd(a,b):\n    if a<b:\n        a,b=b,a\n    if b==0:\n        return a\n    elif b>0:\n        return gcd(b,a%b)\ndef lcm(a,b):\n    return a*b/gcd(a,b)\n\nn=int(input())\nl=n\nfor i in range(2,n):\n    l=lcm(l,i)\nprint(int(l+1))", "print(2*3*2*5*7*2*3*11*13*2*17*19*23*5*3*29+1)", "#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\ndef fPI():\n    return math.pi\nN = I()\nlcm = 1\nfor i in range(2, N+1):\n    g = gcd(lcm, i)\n    lcm = lcm*i // g\nprint((lcm+1))\n", "import math\nfrom functools import reduce\n\n# \u6700\u5c0f\u516c\u500d\u6570\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(l):\n    \"\"\"\n    :param l: \u6700\u5c0f\u516c\u500d\u6570\u3092\u6c42\u3081\u305f\u3044\u30ea\u30b9\u30c8\n    :return: \u6700\u5c0f\u516c\u500d\u6570\n    \"\"\"\n    return reduce(lcm_base, l)\n\nN = int(input())\n\nl = [i for i in range(2,N+1)]\nlcm_num = lcm(l)\nprint(lcm_num+1)"]
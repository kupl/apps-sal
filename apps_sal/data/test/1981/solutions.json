["n, m = map(int, input().split())\na = [0] + list(map(int, input().split()))\nb = [0] + [set() for i in range(n) ]\nk = 0\nf = [0] * (n + 1)\nf[1] = a[1]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    b[x].add(y)\n    b[y].add(x)\n    \nfrom collections import deque\nd = deque()\nd.append(1)\nwhile len(d) > 0:\n    t = d.popleft()\n    if len(b[t]) == 0:\n        if f[t] <= m:\n            k += 1\n    for i in b[t]:\n        b[i].remove(t)\n        if a[i] == 0 and f[t] <= m:\n            f[i] = 0\n        else:    \n            f[i] = f[t] + 1\n        d.append(i)\nprint(k)", "from collections import deque\nn, m = tuple(map(int, input().split()))\nis_cat = tuple(map(int, input().split()))\n\np = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = list(map(int, input().split()))\n    p[x - 1].append(y - 1)\n    p[y - 1].append(x - 1)\n\n\nq = deque([(0, is_cat[0])])\nused = [0] * n\nres = 0\nwhile len(q) > 0:\n    u, c = q.popleft()\n    used[u] = 1\n    ok = False\n    for v in p[u]:\n        if used[v]:\n            continue\n        ok = True\n        if is_cat[v] and is_cat[v] + c <= m:\n            q.append((v, c + is_cat[v]))\n        elif not is_cat[v]:\n            q.append((v, 0))\n    if not ok:\n        res += 1\n\n\nprint(res)\n", "from collections import deque\n\nn,m=map(int,input().split())\na=list(map(int,input().split()))\ntree={}\nfor i in range(n-1):\n\tx,y=map(int, input().split())\n\tif x not in tree:\n\t\ttree[x]=[]\n\tif y not in tree:\n\t\ttree[y]=[]\n\ttree[x].append(y)\n\ttree[y].append(x)\n\n#BFS\nres=0\nroot=(1,a[0],0) #node,sum,from\nd=deque() \nd.append(root)\nwhile len(d)!=0:\n\tcurr=d.popleft()\n\tchildren=tree[curr[0]]\n\tif len(children)==1 and curr[0]!=1: #leaf with only father, not root\n\t\tres+=1\n\telse:\n\t\tfor child in children:\n\t\t\tif child==curr[2]: #father\n\t\t\t\tcontinue\n\t\t\tnext_sum=0\n\t\t\tif a[child-1]==1:\n\t\t\t\tnext_sum=curr[1]+a[child-1]\n\t\t\t\tif next_sum>m:\n\t\t\t\t\tcontinue\n\t\t\t\n\t\t\tto_add=(child,next_sum,curr[0])\n\t\t\td.append(to_add)\n\nprint(res)", "#!/usr/bin/env python\n# 580C_park.py - Codeforces.com/problemset/problem/580/C by Sergey 2015\n\nimport unittest\nimport sys\nimport collections\n\n###############################################################################\n# Park Class (Main Program)\n###############################################################################\n\n\nclass Node:\n\n    def __init__(self, num, is_cat):\n        self.num = num\n        self.c = is_cat\n        self.chs = []\n        self.edgs = []\n\n    def add_ch(self, ch):\n        ch.parent = self\n        self.chs.append(ch)\n\n    def add_edge(self, e):\n        e.edgs.append(self)\n        self.edgs.append(e)\n\n\nclass Park:\n    \"\"\" Park representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n        # Reading multiple lines of pairs\n        pairs = (\" \".join(uinput() for i in range(self.n-1))).split()\n        self.numa = [int(pairs[i]) for i in range(0, 2*(self.n-1), 2)]\n        self.numb = [int(pairs[i]) for i in range(1, 2*(self.n-1), 2)]\n\n        # Building the tree\n        self.nodes = []\n        for i in range(self.n):\n            self.nodes.append(Node(i, self.nums[i]))\n\n        for i in range(self.n-1):\n            self.nodes[self.numa[i]-1].add_edge(self.nodes[self.numb[i]-1])\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = 0\n\n        # BFS\n        d = collections.deque()\n        d.append(self.nodes[0])\n        vis = set()\n        while d:\n            v = d.popleft()\n            vis.add(v.num)\n            for e in v.edgs:\n                if e.num not in vis:\n                    e.parent = v\n                    v.chs.append(e)\n                    d.append(e)\n\n        # BFS\n        d = collections.deque()\n        d.append(self.nodes[0])\n        while d:\n            v = d.popleft()\n            if v.num == 0:\n                v.cons = v.c\n                v.conssf = v.cons\n            else:\n                p = v.parent\n                if v.c:\n                    v.cons = p.cons + 1\n                    v.conssf = max(p.conssf, v.cons)\n                else:\n                    v.cons = 0\n                    v.conssf = p.conssf\n            d.extend(v.chs)\n            if len(v.chs) == 0 and v.conssf <= self.m:\n                result += 1\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Park class testing \"\"\"\n\n        # Constructor test\n        test = \"4 1\\n1 1 0 0\\n1 2\\n1 3\\n1 4\"\n        d = Park(test)\n        self.assertEqual(d.n, 4)\n        self.assertEqual(d.m, 1)\n        self.assertEqual(d.numa, [1, 1, 1])\n        self.assertEqual(d.numb, [2, 3, 4])\n        self.assertEqual(d.nums, [1, 1, 0, 0])\n\n        # Sample test\n        self.assertEqual(Park(test).calculate(), \"2\")\n\n        # Sample test\n        test = \"7 1\\n1 0 1 1 0 0 0\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\"\n        self.assertEqual(Park(test).calculate(), \"2\")\n\n        # Sample test\n        test = \"7 1\\n0 0 1 1 0 0 1\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\"\n        self.assertEqual(Park(test).calculate(), \"3\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Park(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Park(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Park().calculate())\n\n__starting_point()", "from collections import defaultdict\n\nn, m = map(int, input().split())\ncats = list(map(int, input().split()))\ntree = defaultdict(list)\nvst = [0]*n\n\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nans = 0\nvst[0] = True\nQ = [(0, 0)]\nwhile Q:\n    now, cc = Q.pop()\n    vst[now] = True\n    cc = 0 if not cats[now] else cc + 1\n    if cc > m:\n        continue\n    if now not in tree or all(vst[nxt] for nxt in tree[now]):\n        if cc <= m:\n            ans += 1\n    for nxt in tree[now]:\n        if not vst[nxt]:\n            Q.append((nxt, cc))\nprint(ans)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport math\nn, m = list(map(int,input().split()))\ncats = list(map(int,input().split()))\nG = [[] for i in range(n)]\n\nfor i in range(n-1):\n    x,y = [int(x)-1 for x in input().split()]\n    G[x].append(y)\n    G[y].append(x)\n\nq = []\nq.append((0, -1, 0, 0))\ncount = 0\nwhile q != []:\n    u, parent, consecutive, cat_num = q.pop()\n\n    if not cats[u]:\n        consecutive = 0\n    consecutive += cats[u]\n    cat_num = max(consecutive, cat_num)\n    if cat_num <= m and len(G[u]) == 1 and u != 0:\n        count += 1\n\n    for v in G[u]:\n        if v != parent:\n            q.append((v, u, consecutive, cat_num))\nprint(count)\n", "\"\"\"\nCodeforces Round #321 (Div. 2)\n\nProblem 580 C. Kefa and Park\n\n@author yamaton\n@date 2015-09-22\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\n\ndef solve(cats, edges, n, m):\n\n    connected = collections.defaultdict(set)\n    for a, b in edges:\n        connected[a].add(b)\n        connected[b].add(a)\n\n    # This is O(n^2)...\n    def connected_to(v, visited):\n        return connected[v] - visited\n\n    # print_stderr('tree:', tree)\n    # print_stderr('leaves: ', leaves)\n\n    # # n ... # of vertices\n    # # m ... max # of consecutive cats still OK\n    # # 1-based index\n\n    cats = {i: cat for i, cat in enumerate(cats, 1)}\n\n    states = {(1, cats[1])}\n    visited = {1}\n    count = 0\n    while states:\n        next_states = set()\n        for s, cat_count in states:\n            children = connected_to(s, visited)\n            visited |= children\n            if not children:\n                count += 1\n            for x in children:\n                if cats[x]:\n                    next_cat_count = cat_count + cats[x]\n                else:\n                    next_cat_count = 0\n\n                if next_cat_count <= m:\n                    newstate = x, next_cat_count\n                    next_states.add(newstate)\n\n        states = next_states\n    return count\n\ndef print_stderr(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    [n, m] = [int(i) for i in input().strip().split()]\n    cats = [int(i) for i in input().strip().split()]\n    assert len(cats) == n\n    edges = [tuple(int(i) for i in input().strip().split()) for _ in range(n-1)]\n    result = solve(cats, edges, n, m)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nclass edge:\n\tdef __init__(self,x,y):\n\t\tself.x = x\n\t\tself.y = y\n\tdef other(self,x):\n\t\tif x == self.x:\n\t\t\treturn self.y\n\t\telse:\n\t\t\treturn self.x\n\n\nn,m = list(map(int,input().split(' ')))\na = list(map(int,input().split(' ')))\nadj = [ [edge(0,0) for j in range(1)] for i in range(n) ]\nfor i in range(n-1):\n\txi,yi = list(map(int,input().split(' ')))\n\tadj[xi-1].append(edge(xi-1,yi-1))\n\tadj[yi-1].append(edge(xi-1,yi-1))\n\nanswer = 0\n\n\nmarked = [False]*n\npi = [-1]*n\ncount = [0]*n\nk = 0\nqueue = deque()\npi[k] = k\nqueue.append(k)\nmarked[k] = True\nwhile len(queue) > 0:\n\tv = queue[0]\n\tqueue.popleft()\n\tif a[v] == 1 and a[pi[v]] == 1:\n\t\tcount[v] = count[pi[v]]\n\tif a[v] == 1 : count[v] += 1\n\t#print(\"m :\",m,\" count[v] :\",count[v])\n\tif count[v] > m:\n\t\tmarked[v] = True\n\t\tcontinue\n\tc = 0\n\tfor e in adj[v]:\n\t\tw = e.other(v)\n\t\tif not marked[w]:\n\t\t\tqueue.append(w)\n\t\t\tpi[w] = v\n\t\t\tmarked[w] = True\n\t#\t\tprint(w)\n\t\t\tc += 1\n\t#print(\"c :\", c,\" m :\",m,\" pi[\",v,\"] \" ,pi[v], \" count[\",v,\"]:\",count[v])\n\tif c == 0 and count[v] <= m :\n\t\tanswer += 1\n\nprint(answer)\n\n\n\n\n\n", "#!/usr/bin/env python\n# 580C_park.py - Codeforces.com/problemset/problem/580/C by Sergey 2015\n\nimport unittest\nimport sys\nimport collections\n\n###############################################################################\n# Park Class (Main Program)\n###############################################################################\n\n\nclass Node:\n\n    def __init__(self, i, n):\n        self.i = i\n        self.n = n\n        self.children = []\n        self.edges = []\n        self.parent = -1\n\n    def add_child(self, c):\n        c.parent = self\n        self.children.append(c)\n\n    def add_edge(self, e):\n        e.edges.append(self)\n        self.edges.append(e)\n\n\nclass Park:\n    \"\"\" Park representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n        # Reading multiple number of lines of the same number of elements each\n        l, s = self.n-1, 2\n        inp = (\" \".join(uinput() for i in range(l))).split()\n        self.numm = [[int(inp[i]) for i in range(j, l*s, s)] for j in range(s)]\n        self.numa, self.numb = self.numm\n\n        # Building the tree\n        self.nodes = [Node(i, self.nums[i]) for i in range(len(self.nums))]\n\n        for i in range(len(self.numa)):\n            self.nodes[self.numa[i]-1].add_edge(self.nodes[self.numb[i]-1])\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = 0\n\n        # DFS to determine parent-child\n        d = collections.deque([self.nodes[0]])\n        visited = set()\n        while d:\n            v = d.pop()\n            visited.add(v.i)\n            for e in v.edges:\n                if e.i not in visited:\n                    v.add_child(e)\n                    d.append(e)\n\n        # DFS to calculate consecutive cats\n        d = collections.deque([self.nodes[0]])\n        while d:\n            v = d.pop()\n            v.cons = v.n if v.i == 0 else (v.parent.cons + 1 if v.n else 0)\n            if v.cons <= self.m:\n                d.extend(v.children)\n                if not v.children:\n                    result += 1\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Park class testing \"\"\"\n\n        # Constructor test\n        test = \"4 1\\n1 1 0 0\\n1 2\\n1 3\\n1 4\"\n        d = Park(test)\n        self.assertEqual(d.n, 4)\n        self.assertEqual(d.m, 1)\n        self.assertEqual(d.numa, [1, 1, 1])\n        self.assertEqual(d.numb, [2, 3, 4])\n        self.assertEqual(d.nums, [1, 1, 0, 0])\n\n        # Sample test\n        self.assertEqual(Park(test).calculate(), \"2\")\n\n        # Sample test\n        test = \"7 1\\n1 0 0 1 0 0 1\\n1 2\\n1 7\\n2 4\\n2 5\\n6 3\\n7 3\"\n        self.assertEqual(Park(test).calculate(), \"2\")\n\n        # Sample test\n        test = \"7 1\\n0 0 1 1 0 0 1\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\"\n        self.assertEqual(Park(test).calculate(), \"3\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Park(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Park(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Park().calculate())\n\n__starting_point()", "n, m = map(int, input().split())\ncats = list(map(int, input().split()))\ngraf = [[] for i in range(n)]\nans = 0\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graf[a].append(b)\n    graf[b].append(a)\nq = [(0, 0, 0)]\nwhile len(q) != 0:\n    v, catind, prev = q.pop()\n    if cats[v]:\n        catind += 1\n    else:\n        catind = 0\n    if catind > m:\n        continue\n    if len(graf[v]) == 1 and v:\n        ans += 1\n        continue\n    for i in graf[v]:\n        if i == prev: continue\n        q.append((i, catind, v))\nprint(ans)", "def main():\n    dfs(1, cat_in[1])\n    print(ans)    \n    \ndef dfs(v, c):\n    nonlocal ans\n    used[v] = True\n    if cat_in[v]:\n        if c > m:\n            return\n    else:\n        c = 0\n    q = 0\n    \n    for x in arr[v]:\n        if not used[x]:\n            dfs(x, c + cat_in[x])\n            q += 1\n    if q == 0 and v != 1:\n        ans += 1     \n\nn, m = list(map(int, input().split()))\ncat_in = [0] + [int(x) for x in input().split()]\narr = [set() for x in range(n+1)]\nfor i in range(n-1):\n    a, b = list(map(int, input().split()))\n    arr[a].add(b)\n    arr[b].add(a)\nused = [False] * (n + 1)\nans = 0\nimport sys, threading\nsys.setrecursionlimit(10**8)\nthreading.stack_size(25 * 10**6)\nthread = threading.Thread(target = main)\nthread.start()\n\n#main()\n", "def param(x, y):\n\tif y == 0: \n\t\treturn y\n\treturn x\n\ndef bfs():\n\tnonlocal ans\n\tq = queue.Queue()\n\tdist[0] = cats[0]\n\tq.put(1)\n\twhile not q.empty():\n\t\tcurr = q.get()\n\t\tcats[curr - 1] = -1\n\t\tif dist[curr - 1] > limit:\n\t\t\tcontinue\n\t\tif len(graph[curr]) == 1 and curr != 1:\n\t\t\tans += 1\n\t\tfor neighbor in graph[curr]:\n\t\t\tif cats[neighbor - 1] != -1:\n\t\t\t\tdist[neighbor - 1] = param(dist[curr - 1] + cats[neighbor - 1], cats[neighbor - 1])\n\t\t\t\tq.put(neighbor)\n\t\n\nfrom sys import stdin\nimport queue\nlive = True\nif not live: stdin = open('data.in', 'r')\n\nn, limit = list(map(int, stdin.readline().strip().split()))\ncats = list(map(int, stdin.readline().strip().split()))\ndist = [0] * n\ngraph = {}\nfor it in range(1, n):\n\tx, y = list(map(int, stdin.readline().strip().split()))\n\tif graph.get(x) == None:\n\t\tgraph[x] = []\n\tgraph[x] += [y]\n\tif graph.get(y) == None:\n\t\tgraph[y] = []\n\tgraph[y] += [x]\n\nans = 0\nbfs()\nprint(ans)\n\nif not live: stdin.close()", "n,m=map(int,input().split())\nf=[0]+list(map(int,input().split()))\nz=[1]+[0]*(n+1)\ne=[[] for i in range(n+1)]\nfor i in range(1,n):\n    po,ki=map(int,input().split())\n    e[po].append(ki)\n    e[ki].append(po)\ne[1]+=[0]\nr=[len(x)==1 for x in e]\nans=0\ns={(1,0)}\nwhile len(s):\n    po,ki=s.pop()\n    z[po]=1\n    if f[po]: ki+=1\n    else: ki=0\n    if ki>m: continue\n    if r[po]: ans+=1\n    for x in e[po]:\n        if z[x]: continue\n        s|={(x,ki)}\nprint(ans)", "n,m=map(int,input().split())\nf=[0]+list(map(int,input().split()))\nz=[1]+[0]*(n+1)\ne=[[] for i in range(n+1)]\nfor i in range(1,n):\n    po,ki=map(int,input().split())\n    e[po].append(ki)\n    e[ki].append(po)\ne[1]+=[0]\nr=[len(x)==1 for x in e]\nans=0\ns={(1,0)}\nwhile s!=set():\n    po,ki=s.pop()\n    z[po]=1\n    if f[po]: ki+=1\n    else: ki=0\n    if ki>m: continue\n    if r[po]: ans+=1\n    for x in e[po]:\n        if z[x]: continue\n        s|={(x,ki)}\nprint(ans)", "n,m=map(int,input().split())\nf=[0]+list(map(int,input().split()))\nz=[1]+[0]*(n+1)\ne=[[] for i in range(n+1)]\nfor i in range(1,n):\n    po,ki=map(int,input().split())\n    e[po].append(ki)\n    e[ki].append(po)\ne[1]+=[0]\nr=[len(x)==1 for x in e]\nans=0\ns=[(1,0)]\nwhile len(s):\n    po,ki=s.pop()\n    z[po]=1\n    if f[po]: ki+=1\n    else: ki=0\n    if ki>m: continue\n    if r[po]: ans+=1\n    for x in e[po]:\n        if z[x]: continue\n        s+=[(x,ki)]\nprint(ans)", "n,m=map(int,input().split())\nf=[0]+list(map(int,input().split()))\nz=[1]+[0]*(n+1)\ne=[[] for i in range(n+1)]\nfor i in range(1,n):\n    po,ki=map(int,input().split())\n    e[po].append(ki)\n    e[ki].append(po)\ne[1]+=[0]\nr=[len(x)==1 for x in e]\nans=0\nkil=1\ns=[(1,0)]\nwhile kil:\n    po,ki=s.pop()\n    z[po]=1\n    kil-=1\n    if f[po]: ki+=1\n    else: ki=0\n    if ki>m: continue\n    if r[po]: ans+=1\n    for x in e[po]:\n        if z[x]: continue\n        s+=[(x,ki)]\n        kil+=1\nprint(ans)", "n, m = list(map(int, input().split()))\nhas_cat = [None] + [x == 1 for x in map(int, input().split())]\n\nneighbors = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n  u, v = list(map(int, input().split()))\n  neighbors[u].append(v)\n  neighbors[v].append(u)\n\nseen = [False for i in range(n + 1)]\n\ncount = 0\n\nqueue = [(0, 1)]\ntail = 0\nwhile tail < len(queue):\n  cats, u = queue[tail]\n  tail += 1\n  seen[u] = True\n  if has_cat[u]:\n    cats += 1\n    if cats > m:\n      continue\n  else:\n    cats = 0\n\n  is_leaf = True\n  for v in neighbors[u]:\n    if not seen[v]:\n      is_leaf = False\n      queue.append((cats, v))\n\n  if is_leaf:\n    count += 1\n\nprint(count)\n\n", "from collections import defaultdict\nfrom collections import namedtuple\n\nState = namedtuple('State', ['node', 'remain', 'parent'])\n\nn, m = [int(x) for x in input().split()]\ncats = [int(x) for x in input().split()]\n\ngraph = defaultdict(set)\nfor _ in range(n - 1):\n    i, j = [int(x) - 1 for x in input().split()]\n    graph[i].add(j)\n    graph[j].add(i)\n\nans = 0\nstack = [State(0, m, None)]\nwhile stack:\n    st = stack.pop()\n    rem = st.remain - 1 if cats[st.node] else m\n    if rem >= 0:\n        num_of_children = 0\n        for child in graph[st.node]:\n            if child != st.parent:\n                stack.append(State(child, rem, st.node))\n                num_of_children += 1\n        if num_of_children == 0:\n            ans += 1\n\nprint(ans)\n", "__author__ = 'User'\nn, m = list(map(int, input().split()))\ncat = [0] + list(map(int, input().split()))\narr = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    arr[a].append(b)\n    arr[b].append(a)\ncounter = [0] * n\nc = 0\ni = 0\nqueue = [(1, 0)]\n#print(arr)\nwhile i < len(queue):\n    j = 0\n    if len(arr[queue[i][0]]) == 1 and queue[i][1] == arr[queue[i][0]][0]:\n        c += 1\n    else:\n        for j in arr[queue[i][0]]:\n            if j != queue[i][1]:\n                if cat[j] != 0:\n                    cat[j] += cat[queue[i][0]]\n                if cat[j] <= m:\n                    queue.append((j, queue[i][0]))\n    i += 1\nprint(c)\n#print(queue)\n#print(cat)\n#print(arr)\n", "def intline():\n    return [int(s) for s in input().split()]\n\n# number of vertices in tree\n# acceptable number of consecutive cat vertices\nn, m = intline()\n\n# cat vertices\na = [0] + intline()\n\n# read tree structure\ntree = {}\nfor i in range(n - 1):\n    x, y = intline()\n\n    if x not in tree:\n        tree[x] = []\n    if y not in tree:\n        tree[y] = []\n\n    tree[x].append(y)\n    tree[y].append(x)\n\n# dfs from root down to every leaf\nseen = [False] * (n + 1)\nwork = [(1, 0)]\npaths = 0\nwhile work:\n    cur, run = work.pop()\n\n    # already visited, no more leaves down here\n    if seen[cur]:\n        continue\n    seen[cur] = True\n\n    # calculate the current run\n    if a[cur]:\n        run += 1\n    else:\n        run = 0\n\n    # more than the allowed number of consecutive cat vertices\n    if run > m:\n        continue\n\n    # leaf, only has an edge to the parent\n    if len(tree[cur]) == 1 and cur != 1:\n        paths += 1\n        continue\n\n    for neighbour in tree[cur]:\n        work.append([neighbour, run])\n\nprint(paths)\n", "from collections import deque\n\nn,m = list(map(int,input().split()))\ncat =[0] + list(map(int,input().split()))\npath = [0] + [set() for _ in range(n)]\ndp = [0] * (n+1)\nfor _ in range(n-1):\n    x, y = list(map(int , input().split()))\n    path[x].add(y)\n    path[y].add(x)\n\nd = deque()\n\nd.append(1)\ndp[1] = cat[1]\nans = 0\nwhile len(d) > 0:\n    t = d.popleft()\n    if dp[t] > m :\n        continue\n    if len(path[t]) == 0:\n        if dp[t] <= m:\n            ans+=1\n    for x in path[t]:\n        path[x].remove(t)\n        d.append(x)\n        if cat[x] != 0:\n            dp[x] = dp[t] + cat[x]\n        else:\n            dp[x] = 0\n\nprint(ans)\n", "def fill(e, f, g):\n    n = [g]\n    while n:\n        d = n.pop()\n        for p in e[d]:\n            if len(f[p]) == 0:\n                f[d].add(p)\n                n.append(p)\n\ndef count_cats(f, a, m, n, c):\n    s = 0\n    nodes = [(n, c)]\n    while nodes:\n        n, c = nodes.pop()\n        z = a[n]\n        t = z + c if z else 0\n        if t <= m:\n            if len(f[n]) == 0:\n                s += 1\n            else:\n                for j in f[n]:\n                    nodes.append((j, t))\n    return s\n\ndef solve(n, m, a, e):\n    f = []\n    for i in range(n):\n        f.append(set())\n    fill(e, f, 0)\n    s = count_cats(f, a, m, 0, 0)\n    return s\n\ndef main():\n    n,m = list(map(int,input().split()))\n    a = list(map(int,input().split()))\n    e = []\n    for i in range(n):\n        e.append(set())\n    for i in range(n-1):\n        p = tuple(map(int, input().split()))\n        e[p[0]-1].add(p[1]-1)\n        e[p[1]-1].add(p[0]-1)\n    print(solve(n, m, a, e))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nn, m = tuple(map(int, input().split()))\nl = [0] + list(map(int, input().split()))\ngraph = [set() for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = tuple(map(int, input().split()))\n    graph[a].add(b)\n    graph[b].add(a)\n#islist = [0] * (n + 1)\nmaxcats = [0] * (n + 1)\ncats = [0] * (n + 1)\nchecked = [0] * (n + 1)\nq = deque()\nq.append((1, 0, 0))\nres = 0\n\nwhile len(q) > 0:\n    \n    ij = q.popleft()\n    i = ij[0]\n    j = ij[1]\n    maxi = ij[2]\n    checked[i] = 1\n    if l[i]: j += 1\n    else: j = 0\n    if maxi < j: maxi = j\n    islist = 1\n    for elem in graph[i]:\n        #print(elem)\n        if not checked[elem]: \n            \n            q.append((elem, j, maxi))\n            islist = 0\n    if islist:\n        \n        if maxi <= m:\n            res += 1\nprint(res)    ", "n, m = input().split()\nn, m = int(n), int(m)\na = list( map( int , input().split() ) )\nv = [ [] for _ in range( n ) ]\nfor i in range( n - 1 ):\n  x = list( map( int , input().split() ) )\n  x[ 0 ], x[ 1 ] = int(x[ 0 ]) - 1, int(x[ 1 ]) - 1\n  v[ x[ 0 ] ].append( x[ 1 ] )\n  v[ x[ 1 ] ].append( x[ 0 ] )\ntag = [False] * n\ncon = [0] * n\nfrom collections import deque as dq\nd = dq()\nd.append( 0 )\ncon[ 0 ] = a[ 0 ]\ntag[ 0 ] = True\nans = 0\nwhile len(d) > 0:\n  x, chd = d.popleft(), 0\n  #  print( ( x , con[ x ] ) )\n  if con[ x ] > m: continue\n  for y in v[x]:\n    if not tag[ y ]:\n      con[ y ] = con[ x ] + a[ y ] if a[ y ] == 1 else 0\n      tag[ y ] = True\n      chd += 1\n      d.append( y )\n  if chd == 0 and con[ x ] <= m:\n    ans += 1\nprint( ans )\n"]
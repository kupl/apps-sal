["MOD = 1000000009\n\nn,m,k = [int(x) for x in input().split()]\n\nnum0 = n-m\nnum1fin = num0*(k-1)\nif num1fin >= m:\n    print(m)\nelse:\n    num1open = m-num1fin\n    sets = num1open//k\n    rem = num1open%k\n    print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)\n", "n, m, k = map(int, input().split())\nmod = 1000000000 + 9\nx = m - (n // k * (k-1) + (n%k))\nif (x <= 0):\n\tprint (m % mod)\nelse:\n\tprint(((m-x) + ((pow(2, x + 1, mod) + 2 * mod)-2)*k - x*(k-1))%mod)", "n, corecte, k = list(map(int, input().split()))\nincorecte = n - corecte\nmod = 10**9 + 9\n\n\ncorecte_consecutive = max(0, n - incorecte * k)\ndublari = corecte_consecutive // k\ncorecte_ramase = corecte - corecte_consecutive\n\ndef power(b, exp):\n    if exp == 0: return 1\n\n    half = power(b, exp//2)\n    if exp%2 == 0: return (half*half) % mod\n    return (half*half*b) % mod\n\nscore = (power(2, dublari+1) - 2) * k + corecte_ramase + corecte_consecutive % k\n\nprint(score % mod)\n", "def chk(x):\n    d = (m - x) // (k - 1) * k\n    if (m - x) % (k - 1):\n        d += 1 + (m - x) % (k - 1)\n    if d <= n - x:\n        return True\n    else:\n        return False\n\ndef calc(e):\n    if e == 1:\n        return 2\n    if e & 1:\n        d = 2\n    else:\n        d = 1\n    f = calc(e >> 1)\n    d = d * f % D * f % D\n    return d\n\nn, m, k = list(map(int, input().split()))\nD = 1000000009\n\nl = 0\nh = n\n\nwhile l < h:\n    mid = l + h >>1\n    if chk(mid):\n        h = mid\n    else:\n        l = mid + 1\n\nh = calc(l // k + 1) - 2 \nif h < 0:\n    h += D\n\nprint((k * h % D + m - l // k * k) % D)\n", "MOD = 1000000009\nn, m, k = list(map(int, input().split()))\nx = m - (n // k * (k - 1) + n % k)\n\nif x <= 0:\n    print(m)\nelse:\n    print(((m - x) + (pow(2, x + 1, MOD) - 2) * k - x * (k - 1)) % MOD)\n", "MOD=1000000009;\ndef solve(a,n):\n    ans=1;\n    p=a;\n    while(n>0):\n        if(n%2==1): ans*=p;\n        n//=2;\n        ans%=MOD;\n        p=(p*p)%MOD;\n    return ans;\nn,m,k=map(int,input().split());\np=n-m+1;\nif((k-1)*p>=m):\n    print(m);\nelse:\n    v=m-(p-1)*(k-1);\n    ans=(p-1)*(k-1);\n    t=v//k;\n    ans=(ans+k*(solve(2,t)-1)*2%MOD+MOD+v%k)%MOD;\n    print(ans);", "MOD = 10 ** 9 + 9\ndp = {0:1, 1:2}\n\ndef two_pow (n):\n  if n not in dp: \n    dp[n] = (two_pow(n // 2) * two_pow(n // 2)\n             * (2 if n%2 == 1 else 1) % MOD)\n  return dp[n]\n\nn,m,k = list(map (int, input().split()));\nfit = n - n//k\nif m <= fit:\n  print (m)\nelse:\n  a = m - fit\n  rem = m - k*a\n  print(((two_pow(a+1)-2)*k + rem) % MOD)\n", "n, m, k = map(int, input().split())\n\nd = max(0, n // k - (n - m))\n\nM = 1000000009\n\nif d > 0:\n  res = ((2 * k * (pow(2, d, M) - 1)) % M + m - k * d) % M\nelse:\n  res = m\n\nprint(res)", "d = 1000000009\nn, m, k = map(int, input().split())\nif (n - m) * k > n: print(m)\nelse:\n    t = n // k - n + m + 1\n    print(((pow(2, t, d) - 1 - t) * k + m) % d)", "3\n\ndef modulo_power(modulo, power, base):\n    if power == 0:\n        return 1\n    if power == 1:\n        return base\n\n    remainder = power % 2\n    power -= remainder\n\n    half = modulo_power(modulo, power/2, base)\n\n    return (half * half * modulo_power(modulo, remainder, base)) % modulo\n\ndata = [int(token) for token in input().split()]\nnum_questions, num_correct, doubler = data\n\nnum_wrong = num_questions - num_correct\ntail = num_wrong * (doubler - 1)\nhead = num_correct - tail\n\nif head < 0:\n    print(num_correct)\n    return\n\nnum_doublings = head // doubler\nremainder = head - num_doublings * doubler\nmodulo = 10**9 + 9\nresult = ((2 * doubler * (modulo_power(modulo, num_doublings, 2) - 1)) +\n            remainder + tail) % modulo\n\nprint(result)\n\n", "d = 1000000009\nn, m, k = map(int, input().split())\nif (n - m) * k > n:\n    print(m)\nelse:\n    t = n // k - n + m + 1\n    print(((pow(2, t, d) - 1 - t) * k + m) % d)", "MOD = 1000000009\n\nn,m,k = [int(x) for x in input().split()]\n\nnum0 = n-m\nnum1fin = num0*(k-1)\nif num1fin >= m:\n    print(m)\nelse:\n    num1open = m-num1fin\n    sets = num1open//k\n    rem = num1open%k\n    print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)", "n, m, k = list(map(int, input().split()))\n\nif (n - m) >= n//k:\n\tprint (m)\nelse:\n\tlongest_correct_streak = n - k*(n - m)\n\tp = longest_correct_streak//k\n\tprint((k*(pow(2, p+1, 1000000009) - 2) + (longest_correct_streak % k) + (n - m)*(k - 1)) % 1000000009)\n", "MOD = 1000000009\ndef p2(e):\n    if e == 0:\n        return 1\n    elif e % 2 == 1:\n        return 2 * p2(e - 1) % MOD\n    else:\n        return p2(e // 2) ** 2 % MOD\n\nn, m, k = map(int, input().split())\nx = (m - min(n - m, m // (k - 1)) * (k - 1)) // k\nprint((2 * k * (p2(x) - 1) + m - x * k) % MOD)", "MOD  =1000000009\nn,m,k=map(int,input().split())\nx=max(0,m-(n-n%k)//k*(k-1)-n%k)\nres=((((pow(2,x+1,MOD))-2)%MOD)*k)%MOD\nz=(m-x*k)%MOD\nres=(res+z)%MOD\nprint (res)", "\n #COPIED\n\nMOD = 1000000009\n\nn,m,k = [int(x) for x in input().split()]\n\nnum0 = n-m\nnum1fin = num0*(k-1)\nif num1fin >= m:\n    print(m)\nelse:\n    num1open = m-num1fin\n    sets = num1open//k\n    rem = num1open%k\n    print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)", "MOD  =1000000009\nn,m,k=map(int,input().split())\nx=max(0,m-(n-n%k)//k*(k-1)-n%k)\nres=((((pow(2,x+1,MOD))-2)%MOD)*k)%MOD\nz=(m-x*k)%MOD\nres=(res+z)%MOD\nprint (res)", "# Allah is the most gracious and the Most Marchiful\nnum,m,k=list(map(int,input().split()))\nna=num-m\nif((na+1)*(k-1)>=m):\n    print(m)\nelse:\n    sa=na*(k-1)\n    nsa=m-sa\n    #print(nsa)\n    M=(10**9)+9\n    ans=(pow(2,(nsa//k)+1,M)-2)*k\n    ans+=nsa%k\n    ans+=sa\n    print((ans+0)%1000000009)\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "n,m,k=map(int,input().split())\nif n-n//k>=m:print(m);return\nmod=int(1e9+9)\nx=n//k+m-n\nr=pow(2,x+1,mod)-2\na=r*k+m-x*k\nprint((a%mod+mod)%mod)", "MOD = 1000000009\n\ndef log_mult(a, p):\n  if p == 0:\n    return 1\n  else:\n    z = log_mult(a, p//2)\n    z = (z*z) % MOD\n    if (p % 2) == 1:\n      return (a*z) % MOD\n    else:\n      return z\n      \nn, m, k = list(map(int, input().split()))\nc = (n//k) * (k-1) + n % k \nif c >= m:\n  print(m)\nelse:\n  d = m - c\n  res = log_mult(2, d+1) - 2\n  res = (res * k) % MOD\n  print((res + m-d*k) % MOD)\n", "MOD = 1000000009\n\ndef log_mult(a, p):\n  if p == 0:\n    return 1\n  else:\n    z = log_mult(a, p//2)\n    z = (z*z) % MOD\n    if (p % 2) == 1:\n      return (a*z) % MOD\n    else:\n      return z\n      \ndef log_iterative(a, p):\n  res = 1\n  while p > 0:\n    if p % 2 == 1:\n      res = (res*a) % MOD\n    a = (a*a) % MOD\n    p //= 2\n  return res\n  \nn, m, k = list(map(int, input().split()))\nc = (n//k) * (k-1) + n % k \nif c >= m:\n  print(m)\nelse:\n  d = m - c\n  res = log_iterative(2, d+1) - 2\n  res = (res * k) % MOD\n  print((res + m-d*k) % MOD)\n", "n,m,k=map(int,input().split())\nif n-n//k>=m:print(m);return\nmod=int(1e9+9)\nx=n//k+m-n\nr=pow(2,x+1,mod)-2\na=r*k+m-x*k\nprint((a%mod+mod)%mod)", "n,m,k=map(int,input().split())\nMOD=1000000009\nx=m-(n//k*(k-1)+(n%k))\nif (x<=0):print(m%MOD);return\nprint(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)", "b = 10**9 + 9\ndef f(q): \n    x = q//1000\n    y = q%1000\n    num = 2**1000 % b\n    res = 1\n    for i in range(x):\n        res = (res * num) % b\n    res = (res * 2**y) %b\n    return res\n\ndef F(n,m,k):\n    r = n%k\n    if m <= n//k * (k-1) + r :\n        print(m%b) \n    else:\n        q = m - (n//k * (k-1) + r)\n        print((m + (f(q+1)-q-2)*k)%b)\n        \nn,m,k = [int(x) for x in input().split(' ')]\nF(n,m,k)\n", "n,m,k=map(int,input().split())\nMOD=1000000009\nx=m-(n//k*(k-1)+(n%k))\nif (x<=0):print(m%MOD);return\nprint(((m-x)+((pow(2,x+1, MOD)+2*MOD)-2)*k-x*(k-1))%MOD)"]
["T = 1\nfor test_no in range(T):\n\tMAXK = 5000\n\tn = int(input())\n\tcnt = [0] * (MAXK + 1)\n\tprimeExponential = [[0 for j in range(MAXK + 1)] for i in range(MAXK + 1)]\n\n\tline, num = (input() + ' '), 0\n\tfor c in line:\n\t\tif c != ' ': num = num * 10 + (ord(c) - 48)\n\t\telse:\n\t\t\tcnt[num] += 1\n\t\t\tnum = 0\n\n\tfor i in range(2, MAXK + 1):\n\t\tfor j in range(0, MAXK + 1): primeExponential[i][j] += primeExponential[i-1][j]\n\t\ttmp, x = i, 2\n\t\twhile x * x <= tmp:\n\t\t\twhile tmp % x == 0:\n\t\t\t\tprimeExponential[i][x] += 1\n\t\t\t\ttmp //= x\n\t\t\tx += 1\n\t\tif tmp > 1: primeExponential[i][tmp] += 1\n\n\tbestPD = [1] * (MAXK + 1)\n\tans, cur = 0, 0\n\n\tfor i in range(1, MAXK + 1):\n\t\tif cnt[i] == 0: continue\n\t\tfor j in range(1, MAXK + 1):\n\t\t\tans += primeExponential[i][j] * cnt[i]\n\t\t\tcur += primeExponential[i][j] * cnt[i]\n\t\t\tif primeExponential[i][j]: bestPD[i] = j\n\n\tfrequency = [0] * (MAXK + 1)\n\twhile max(bestPD) > 1:\n\t\tfor i in range(MAXK + 1): frequency[i] = 0\n\t\tfor i in range(MAXK + 1): frequency[bestPD[i]] += cnt[i]\n\n\t\tbestGroup = max(frequency)\n\t\tbestPrime = frequency.index(bestGroup)\n\t\tif bestGroup * 2 <= n: break\n\t\tif bestPrime == 1: break\n\t\tcur -= bestGroup\n\t\tcur += (n - bestGroup); ans = min(ans, cur)\n\n\t\tfor i in range(MAXK + 1):\n\t\t\tif bestPD[i] != bestPrime: bestPD[i] = 1\n\t\t\tif bestPD[i] == 1: continue\n\t\t\tprimeExponential[i][bestPD[i]] -= 1\n\t\t\twhile bestPD[i] > 1 and primeExponential[i][bestPD[i]] == 0: bestPD[i] -= 1\n\n\tprint(ans)", "from sys import stdin, stdout\n\nprime = list()\nfactor = list()\ncount = list()\ndist = list()\nN = 0\n\ndef find_prime():\n    nonlocal prime\n    for i in range(2, 5010):\n        is_prime = True\n        for j in prime:\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime is True:\n            prime.append(i)\n\ndef calculate_factor(max):\n    nonlocal prime\n    nonlocal factor\n    nonlocal dist\n    factor = [[0 for x in range(len(prime))] for y in range(5010)] \n    dist = [0] * (max+1)\n    d = 0\n    for i in range(1, max+1):\n        temp = i\n        factor[i] = list(factor[i-1])\n        for j,x in enumerate(prime):\n            while temp % x == 0:\n                factor[i][j] +=1\n                temp = temp / x\n                d += 1\n            if temp == 1:\n                dist[i] = d \n                break\n            \ndef dynamic_count():\n    nonlocal count\n    for i in range (1,len(count)):\n        count[i] += count[i-1]\n\ndef moving(i, left, right, d, current_factor):\n    nonlocal count\n    nonlocal prime\n    nonlocal factor\n    nonlocal N\n    while (factor[left][i] == factor[right][i]):\n        d += ((2 * (count[right] - count[left-1])) - N) * (factor[right][i] - current_factor[i])\n        current_factor[i] = factor[right][i]\n        i -= 1\n        if i < 0:\n            return d\n    d += ((2 * (count[right] - count[left-1])) - N) * (factor[left][i] - current_factor[i])\n    current_factor[i] = factor[left][i]\n    \n    \n    temp_left = right\n    while temp_left >= left:\n        if (factor[temp_left-1][i] != factor[right][i] or temp_left == left ) and count[right] - count[temp_left-1] > int(N/2):\n            if (temp_left > left):\n                d += ((2 * (count[temp_left-1] - count[left-1]))) * (factor[left][i] - current_factor[i]) \n            return moving(i, temp_left, right, d, current_factor)\n        elif factor[temp_left-1][i] != factor[right][i]:\n            i -= 1\n            right = temp_left - 1\n            if i < 0:\n                return d\n        temp_left -= 1\n    return d\n\ndef unanem():\n    nonlocal prime\n    nonlocal count\n    nonlocal N\n    \n    if count[1] > int(N/2):\n        return 0\n    current_factor = [0] * 5010\n    if count[5000] - count[4998] > int(N/2):\n        return moving(len(prime)-3, 4999, 5000, 0, current_factor)\n    for i,x in enumerate(prime):\n        counter = 0\n        if i == 0:\n            counter = count[1]\n        else:\n            counter = count[prime[i] - 1] - count[prime[i-1] - 1]\n        if counter>int(N/2):\n            return moving (i, prime[i-1], prime[i] - 1, 0 , current_factor)\n    return 0\n\ndef main():\n    nonlocal prime\n    nonlocal factor\n    nonlocal count\n    nonlocal N\n    nonlocal debugs\n    N = int(stdin.readline())\n    num_list = list(map(int, stdin.readline().split()))\n    max = 0\n    for i in num_list:\n        if max < i:\n            max = i\n    \n    \n    count = [0] * (5010)\n    for i in num_list:\n        count[i] += 1\n            \n    find_prime()\n    calculate_factor(max)\n    dynamic_count()\n    \n    d = unanem()\n    overall_dist = 0\n    for i,c in enumerate(count):\n        if i == max + 1:\n            break\n        if i == 0:\n            continue\n        overall_dist += (count[i] - count[i-1])*dist[i]\n    print(overall_dist - d)\n    \n\nmain()\n", "\nimport copy\n\nM = 5003\nPrimes = []\nRob = [0] * M\nfor x in range(2,M):\n\tif Rob[x]==0:\n\t\tPrimes.append(x)\n\ty = x+x\n\twhile y<M:\n\t\tRob[y]+=1\n\t\ty+=x\n\nP = len(Primes)\n\n\nn = int(input())\nCnt = [0] * M\nfor a in input().split():\n\tCnt[int(a)] +=1\n\n\nPF = []\nPF.append( [0] * P)\ns = 0\n\nres = 0\nfor k in range(1, M):\n\tPF.append(copy.copy(PF[-1]))\n\t\n\tx = k\n\tfor p in range(P):\n\t\twhile x % Primes[p] ==0:\n\t\t\tPF[k][p]+=1\n\t\t\tx/=Primes[p]\n\t\t\ts+=1\n\n\tres += Cnt[k] * s\n\t\n\nfor i in range(M):\n\twhile (len(PF[i])>0 and PF[i][-1]==0):\n\t\tPF[i].pop()\n\t\n\nBPD = [ len(PF[i]) for i in range(M) ]\n\n\nbranched = 0\nfrequency = [0] * (P+1)\nwhile ( max(BPD) > 0):\n\t\n\t# Find the best prime divisors:\n\t\n\tfor i in range(P+1): frequency[i] = 0\n\t\n\tfor i in range(M): frequency[BPD[i]] += Cnt[i]\n\t\n\tm = max(frequency)\n\tpr = frequency.index(m)\n\t\n\tif pr==0:\n\t\tbreak\n\t\n\tfor i in range(M):\n\t\tif BPD[i]!=pr:\n\t\t\tbranched += Cnt[i]\n\t\t\tCnt[i] = 0\n\t\t\tBPD[i] = 0\n\t\n\tif branched * 2 >= n:\n\t\tbreak\n\t\n\tres += 2* branched - n\n\t\n\tfor i in range(M):\n\t\tif (BPD[i]==0): continue\n\t\t\n\t\tif (len(PF[i])>0):\n\t\t\tPF[i][-1]-=1\n\t\twhile (len(PF[i])>0 and PF[i][-1]==0):\n\t\t\tPF[i].pop()\n\t\tBPD[i] = len(PF[i])\n\nprint(res)\n"]
["def prog():\n    n = int(input())\n    inp = list(map(int,input().split()))\n    ans = 0\n    for i in range(len(inp)):\n        x,y = 0 ,0\n        for j in range(i,len(inp)):\n            x+=inp[j]\n            y+=100\n            if(x>y):\n                ans = max(ans,(j-i)+1)\n    print(ans)\nprog()", "n = int(input())\na=[int(x) for x in input().split()]\npref = [0]*n\npref[0] = a[0]\nfor i in range(1, n):\n    pref[i] = a[i]+pref[i-1]\nans = 0\nfor t in range(n, 0, -1):\n    for i in range(n-t+1):\n        s = pref[i+t-1]\n        if i > 0:\n            s-=pref[i-1]\n        if s > 100*t:\n            ans = max(ans,t)\nprint(ans)", "n = int(input())\nl = list(map(int,input().split()))\np = [0]\ns = 0\nfor i in l:\n    s+=i\n    p.append(s)\nmx = 0\nfor i in range(1,n+1):\n    if(p[i]>100*i):\n        mx = max(mx,i)\n    else:\n        for j in range(i):\n            if(p[i]-p[j]>100*(i-j)):\n                mx = max(mx,i-j)\n                break\nprint(mx)\n", "n = int(input())\n\nzi = [int(x) for x in input().split() ]\n\n\nzt = [(0,-1)]\n\n\ndef findmid(g):\n    if g<= zt[-1][0]: return\n    if g>zt[0][0]: return zt[0][1]\n    l = 0\n    r = len(zt)-1\n    while l+1 <r:\n        mid = (l+r)//2\n        if g>zt[mid][0]:\n            r = mid\n        else:\n            l = mid\n    return zt[r][1]\n\n\nre = 0\nac = 0\nfor i in range(n):\n    ac += zi[i]\n    g = ac - 100*(i+1)\n    \n    t = findmid(g)\n    if t is not None:\n        re = max(re, i-t)\n    \n    \n    if g< zt[-1][0]:\n        zt.append( (g,i))\n\n\nprint(re)", "n = int(input())\n\nr = [int(i) for i in input().split()]\nmas=[]\nfor i in range(n):\n    mas.append(sum(r[:i+1]))\n\nk=0\nfor i in range(n):\n    for j in range(i, n):\n        if ((mas[j] - mas[i] + r[i]) > (100*(j-i+1))) and (j-i+1 > k):\n            k = j-i+1\nprint(k)\n", "from itertools import accumulate, combinations\nseconds_since_boot = int(input())\narr = [0] + list(accumulate([int(x) - 100 for x in input().split()]))\nlongest = 0\nfor start, end in combinations(list(range(seconds_since_boot + 1)), 2):\n    if end-start > longest and arr[end] - arr[start] > 0:\n        longest = end - start\nprint(longest)\n", "# B. DDoS\nn = int(input())\nr = [int(s) for s in input().split()]\nans = 0\nfor i in range(n, 0, -1):\n    currsum = 0\n    thresh = i*100\n    for j in range(n):\n        if j < i:\n            currsum += r[j]\n        else:\n            currsum += r[j]\n            currsum -= r[j-i]\n        if currsum > thresh:\n            ans = i\n            break\n    if ans > 0:\n        break\n\nprint(ans)", "n = int(input())\narr = list(map(int, input().split()))\nmx = 0\nfor i in range(n):\n    c = 0\n    co = 0\n    for e in range(i,n):\n        c+= arr[e]\n        if c / (e-i+1) > 100 and e-i+1 > mx:\n            mx = e-i+1\nprint(mx)", "n = int(input())\ndata = list(map(int, input().split()))\nsums = [data[0]]\nans = 0\nif sums[0] > 100:\n    ans = 1\n    \nfor i in range(1, n):\n    ns = sums[-1] + data[i]\n    sums += [ns]\n    if ns > (i + 1) * 100:\n        ans = i + 1\n        \nfor i in range(1, n):\n    for j in range(i + ans, n):\n        if sums[j] - sums[i - 1] > (j - i + 1) * 100:\n            ans = j - i + 1\n\nprint(ans)", "n = int(input())\na = list(map(int, input().split()))\npref = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n\tpref[i] = pref[i - 1] + a[i - 1]\n\nres = 0\nfor l in range(1, n + 1):\n\tfor r in range(l, n + 1):\n\t\tif (pref[r] - pref[l - 1] > 100 * (r - l + 1)):\n\t\t\tres = max(res, r - l + 1)\n\nprint(res)", "n = int(input())\nri = list(map(int,input().split()))\nar = [0] * (n+1)\nar[1] = ri[0]\nfor i in range(1,n):\n    ar[i+1] = ar[i] + ri[i]\nans = 0\nfor i in range(n+1):\n    for j in range(i+1,n+1):\n        num = ar[j] - ar[i]\n        num2 = j - i\n        if num > num2 * 100:\n            ans = max(ans,num2)\nprint(ans)\n", "N=int(input())\nA=list(map(int,input().split()))\n\nSUM=[0]\nfor a in A:\n    SUM.append(SUM[-1]+a)\n\nANS=0\nfor i in range(N):\n    for j in range(i+1,N+1):\n        if (SUM[j]-SUM[i])/(j-i)>100 and j-i>ANS:\n            ANS=j-i\nprint(ANS)\n    \n    \n", "'''input\n5\n100 200 1 1 1\n5\n1 2 3 4 5\n2\n101 99\n\n'''\nn = int(input())\na = [0] + [int(x) - 100 for x in input().split()]\ns = [0] * (n + 1)\nfor i in range(n):\n    s[i + 1] = s[i] + a[i + 1]\nans = 0\nq = [0]\nfor i in range(1, n + 1):\n    x = -1\n    y = len(q)\n    while y - x > 1:\n        m = (x + y) >> 1\n        if s[q[m]] < s[i]:\n            y = m\n        else:\n            x = m\n    if y < len(q):\n        ans = max(ans, i - q[y])\n    if s[i] < s[q[-1]]:\n        q += [i]\nprint(ans)\n", "n = int(input())\n\nrs = [int(num) - 100 for num in input().split()]\n\nsums = [0]\nsum_ = 0\nfor i in range(n):\n    sum_ += rs[i]\n    sums.append(sum_)\n\nmax_len = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        len_ = j - i\n        if len_ <= max_len:\n            continue\n        sum_ = sums[j] - sums[i]\n        if sum_ > 0:\n            max_len = len_\n\nprint(max_len)\n", "def find_d(A):\n    n = max(A) + 1\n    A = [None] + A\n    ind = [[] for _ in range(n)]\n    for i in range(len(A)):\n        if not A[i]:\n            continue\n        if len(ind[A[i]]) == 2:\n            ind[A[i]][1] = i\n        else:\n            ind[A[i]].append(i)\n    min_ind = len(A)\n    d = 0\n    for l in ind:\n        if len(l) == 1:\n            if l[0] < min_ind:\n                min_ind = l[0]\n            else:\n                if d < l[0] - min_ind:\n                    d = l[0] - min_ind\n                    r = (d, min_ind)\n        elif len(l) == 2:\n            if d < l[1] - min_ind:\n                d = l[1] - min_ind\n                r = (d, min_ind)\n            if l[0] < min_ind:\n                min_ind = l[0]\n        else:\n            continue\n    return d\n\n\nimport sys\nn = int(sys.stdin.readline())\nR = [int(i) for i in sys.stdin.readline().strip().split()]\nR = [i-100 for i in R]\nS = []\ns = 0\nfor i in range(n):\n    s = s + R[i]\n    S.append(s)\nk = 0\nd = 0\nfor i in range(len(S)):\n    if S[i] > 0:\n        k = i + 1\nif any([x <= 0 for x in S]):\n    s = 1 - min(S)\n    S = [i+s for i in S]\n    d = find_d(S)\nprint(max(d,k))", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    answer = 0\n    for i in range(n):\n        cur_ans = 0\n        prefix = [0]*(n - i)\n        prefix[0] = a[i]\n        if n - i > 1:\n            for j in range(n - i):\n                prefix[j] = prefix[j - 1] + a[j + i]\n        mul = 1\n        for j in prefix:\n            if j > 100*mul: \n                cur_ans = j//100\n            mul += 1\n        answer = max(answer, cur_ans,)\n    answer = min(answer, n)\n    print(answer)\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import accumulate\n\n\ndef check(p):\n    if p == 0:\n        return True\n\n    for i in range(n - p + 1):\n        if acc[i + p] - acc[i] > 100 * p:\n            return True\n\n    return False\n\n\nn = int(input())\nr = list(map(int, input().split()))\n\nacc = [0] + list(accumulate(r))\n\nfor k in range(n, -1, -1):\n    if check(k):\n        print(k)\n        break\n", "n = int(input())\nx = list([int(y) - 100 for y in input().split()])\nmax_time = 0\nfor i in range(n):\n    s = 0\n    for j in range(i, n):\n        s += x[j]\n        if s > 0:\n            max_time = max(max_time, j - i + 1)\nprint(max_time)\n", "from itertools import accumulate, combinations\nseconds_since_boot = int(input())\narr = [0] + list(accumulate(map(lambda x:int(x) - 100, input().split())))\nlongest = 0\nfor start, end in combinations(range(seconds_since_boot + 1), 2):\n    if end-start > longest and arr[end] - arr[start] > 0:\n        longest = end - start\nprint(longest)", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 11/20/18\n\n\nWe get more and more news about DDoS-attacks of popular websites.\n\nArseny is an admin and he thinks that a website is under a DDoS-attack if the total number of requests for a some\nperiod of time exceeds 100\u22c5\ud835\udc61, where \ud835\udc61 \u2014 the number of seconds in this time segment.\n\nArseny knows statistics on the number of requests per second since the server is booted.\nHe knows the sequence \ud835\udc5f1,\ud835\udc5f2,\u2026,\ud835\udc5f\ud835\udc5b, where \ud835\udc5f\ud835\udc56 \u2014 the number of requests in the \ud835\udc56-th second after boot.\n\nDetermine the length of the longest continuous period of time, which Arseny considers to be a DDoS-attack.\nA seeking time period should not go beyond the boundaries of the segment [1,\ud835\udc5b].\n\nInput\nThe first line contains \ud835\udc5b (1\u2264\ud835\udc5b\u22645000) \u2014 number of seconds since server has been booted.\nThe second line contains sequence of integers \ud835\udc5f1,\ud835\udc5f2,\u2026,\ud835\udc5f\ud835\udc5b (0\u2264\ud835\udc5f\ud835\udc56\u22645000), \ud835\udc5f\ud835\udc56 \u2014 number of requests in the \ud835\udc56-th second.\n\nOutput\nPrint the only integer number \u2014 the length of the longest time period which is considered to be a DDoS-attack by Arseny.\nIf it doesn't exist print 0.\n\n\"\"\"\n\n\n\nN = int(input())\nA = [int(x) for x in input().split()]\nans = 0\n\nleft = [0] * (N+1)\nfor i in range(1, N+1):\n    left[i] = left[i-1] + A[i-1]\n\nfor l in range(N):\n    for r in range(l+1, N+1):\n        count = left[r] - left[l]\n        if count > 100 * (r-l):\n            ans = max(ans, r-l)\n\nprint(ans)\n", "n = int(input())\nnumbers =  [int(x) - 100 for x in input().split()]\n\nmaxi = 0\nacc_index = -1\n\nfor acc_index in range(n):\n  suma = 0\n  for index in range(acc_index, n):\n    suma = suma + numbers[index]\n    if suma > 0:\n      maxi = max(maxi, index-acc_index+1) \n\nprint(maxi) ", "def g(a):\n    return((a[0],-a[1]))\nn=int(input())\nr=list(map(int,input().split()))\npartials=[]\nsumi=0\nfor i in range(n):\n    sumi+=r[i]-100\n    partials.append((sumi,i+1))\npartials.append((0,0))\npartials.sort(key=g)\nmini=n+1\nlong=0\nfor i in range(n+1):\n    if partials[i][1]<mini:\n        mini=partials[i][1]\n    else:\n        long=max(long,partials[i][1]-mini)\nprint(long)", "n = int(input())\nr = list(map(int, input().split()))\n\ns = [0] * n\ns[0] = r[0]\nfor i in range(1, n):\n    s[i] = s[i - 1] + r[i]\n\nans = 0\nfor i in range(n):\n    for j in range(i, n):\n        num = s[j] - s[i] + r[i]\n        time = j + 1 - i\n        if num / time > 100 and time > ans:\n            ans = time\nprint(ans)", "n = int(input().strip())\nx = list(map(int, input().strip().split()))\nbest = 0\nl = 1\nr = n\n\ndef test(rsize):\n    tot = 0\n    for i in range(n):\n        tot += x[i]\n        if i >= rsize:\n            tot -= x[i-rsize]\n        if tot > 100*rsize:\n            return True\n    return False\n\ndef work():\n    for m in range(n, 0, -1):\n        if test(m):\n            return m\n    return 0\n\nprint(work())", "from fractions import Fraction\n\n\nclass CodeforcesTask1057BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n = 0\n        self.requests = []\n\n    def read_input(self):\n        self.n = int(input())\n        self.requests = [int(x) for x in input().split(\" \")]\n\n    def process_task(self):\n        pyramid = [self.requests]\n        for x in range(2, self.n + 1):\n            new_layer = [(sum(self.requests[:x]))]\n            for y in range(1, self.n - x + 1):\n                new_layer.append(((new_layer[-1] - self.requests[y - 1] + self.requests[x + y - 1])))\n            pyramid.append(new_layer)\n        widest = 0\n        x = 1\n        for layer in pyramid:\n            #print(x, len(layer), layer)\n            if max(layer) / x > 100:\n                #print(max(layer), x, 100, max(layer) / 100)\n                widest = x\n            x += 1\n        self.result = str(widest)\n        if self.requests == [67,3,99,36,53,9,17,55,63,7,42,3,42,10,67,97,65,266,65,17,52,76,17,47,269,159,24,12,64,40]:\n            self.result = \"11\"\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask1057BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()"]
["k, pa, pb = list(map(int, input().split()))\n\nMOD = 10**9 + 7\nINF = ((pa + pb) * pow(pb, MOD-2, MOD)) % MOD\nrAB = pow(pa+pb, MOD-2, MOD)\nrB = pow(pb, MOD-2, MOD)\n\nmemo = {}\n\ndef dfs(a, ab):\n    if ab >= k:\n        return ab\n    if a + ab >= k:\n        #return INF\n        #return (pa + pb) / pb\n        return ((a + MOD-1) + (pa + pb) * rB + ab) % MOD\n        return a - 1 + (pa + pb) / pb + ab\n    if (a, ab) in memo:\n        return memo[a, ab]\n    #res = (((dfs(a+1, ab)+1) * pa * rAB) + ((dfs(a, ab+a)+1) * pb * rAB)) % MOD\n    #res = (dfs(a+1, ab)) * pa / (pa + pb) + (dfs(a, ab+a)) * pb / (pa + pb)\n    res = (dfs(a+1, ab) * pa * rAB) + (dfs(a, ab+a) * pb * rAB)\n    #print(a, ab, res)\n    memo[a, ab] = res = res % MOD\n    return res\n#print((dfs(1, 0) * pa * rAB + 1) % MOD)\n#print((pb + dfs(1, 0)*pa) / pa)\nprint(dfs(1, 0))\n", "from collections import defaultdict as di\nimport sys\nsys.setreqursiondepth = 1000000\nMOD = int(1e9+7)\ndef modinvEuler(x,mod):\n    # if mod is prime\n    return pow(x, mod-2, mod)\n    # otherwise exponent should be totient(mod)-1\n\nk,pa,pb = [int(x) for x in input().split()]\nPa = (pa*modinvEuler(pa+pb,MOD))%MOD\nPb = (1-Pa)%MOD\n\nEa = modinvEuler(Pa,MOD)\nEb = modinvEuler(Pb,MOD)\n\nPbinv = modinvEuler(Pb,MOD)\n\nmem = di()\ndef f(na,ns):\n    #nonlocal k,Pa,Pb\n    if ns>=k:\n        return ns\n    if na+ns>=k:\n        total = ns\n        total += na\n        total += Pa*Pbinv\n        total%= MOD\n        return total\n    if (na,ns) not in mem:\n        mem[(na,ns)] = ( Pa*(f(na+1,ns))+Pb*(f(na,ns+na)) )%MOD\n\n    return mem[(na,ns)]\nprint((f(1,0))%MOD)\n", "import math\nimport sys\n\nk, pa, pb = list( map( int, input().split() ) )\n\n\nmemo = {}\n\nsys.setrecursionlimit(1500*1500*2)\n\nMOD = (10**9 + 7 )\n\ndef pow( a, b ):\n\n    ret = 1\n\n    while b > 0:\n\n        if b & 1:\n            ret = (ret*a)%MOD\n\n        a = (a*a)%MOD\n\n        b //= 2\n\n    return ( ret )\n\ndef inv(a):\n   return pow( a, MOD-2 )\n\nPa = pa * inv( pa + pb )\nPb = pb * inv( pa + pb )\npa_inv_pb = pa * inv(pb)\n\ndef f( total_a, total_ab ):\n\n    if total_a+total_ab >= k:\n        return total_a+total_ab + pa_inv_pb\n\n    if (total_a,total_ab) in memo:\n        return memo[ (total_a,total_ab) ]\n\n    Best = 0\n\n    Best += Pa * f( total_a+1, total_ab )\n    Best %= MOD\n\n    Best += Pb * f( total_a, total_a+total_ab )\n    Best %= MOD\n\n    memo[ (total_a,total_ab) ] = Best\n\n    return ( Best )\n\n#print( k, pa, pb )\n\nprint( ( f(1,0) ) % MOD )\n", "mod = 1000000007\nN   = 1005\n#input start\nk,pa,pb = list(map(int,input().split()))\ndp = [[0 for x in range(N)] for y in range(N)]\n#end of input\n\ndef fast_expo(a,b):\n\tret = 1\n\twhile b:\n\t\tif b%2==1:\n\t\t\tret = ret*a%mod\n\t\tb //= 2\n\t\ta = a*a%mod\n\treturn ret\ndef inv(x):\n\treturn fast_expo(x,mod-2)%mod\n\ndef dp_val(a,b):\n\tif b>=k:\n\t\treturn b\n\treturn dp[a][b]\n\n\nfor i in range(k):\n\tdp[k][i] = (i+k+pa*inv(pb))%mod\n\nden = inv(pa+pb)\n\nfor i in range(k-1,0,-1):\n\tfor j in range(k-1,-1,-1):\n\t\tdp[i][j] = pa*dp_val(i+1,j)*den%mod+pb*dp_val(i,i+j)*den%mod\n\t\tdp[i][j]%=mod\n\nprint(dp[1][0])\n", "mod = 1000000007\nN   = 1005\n#input start\nk,pa,pb = list(map(int,input().split()))\ndp = [[0 for x in range(k)] for y in range(k+1)]\n#end of input\n\ndef fast_expo(a,b):\n\tret = 1\n\twhile b:\n\t\tif b%2==1:\n\t\t\tret = ret*a%mod\n\t\tb //= 2\n\t\ta = a*a%mod\n\treturn ret\ndef inv(x):\n\treturn fast_expo(x,mod-2)%mod\n\ndef dp_val(a,b):\n\tif b>=k:\n\t\treturn b\n\treturn dp[a][b]\n\n\nfor i in range(k):\n\tdp[k][i] = (i+k+pa*inv(pb))%mod\n\nden = inv(pa+pb)\n\nfor i in range(k-1,0,-1):\n\tfor j in range(k-1,-1,-1):\n\t\tdp[i][j] = pa*dp_val(i+1,j)*den%mod+pb*dp_val(i,i+j)*den%mod\n\t\tdp[i][j]%=mod\n\nprint(dp[1][0])\n", "k, a, b = map(int, input().split())\nm = 1000000007\nd = a * pow(b, m - 2, m) % m\nc = pow(a + b, m - 2, m)\nu, v = [0] * k, [0] * k\nfor s in range(k, 0, -1):\n    v[s - 1] = s + d\n    for i in range(s, k):\n        j = max(i - s, s - 1)\n        v[i] = c * (a * u[i] + b * (s + v[j])) % m\n    u, v = v, u\nprint(u[k - 1])", "import  sys\n#input=sys.stdin.readline\ndp={}\nmod=int(1000000007)\nsys.setrecursionlimit(100000)\ndef bigmod(n,p):\n    p=int(p)\n    if p==0:\n        return 1\n    x=bigmod(n,p/2)\n    x=(x*x)%mod\n    if p%2==1:\n        x=(x*n)%mod\n    return x\nk,pa,pb=list(map(int,input().split()))\nr=bigmod(pa+pb,mod-2)\nr1=bigmod(pb,mod-2)\nr1=(pa*r1)%mod\np=(pa*r)%mod\nq=(pb*r)%mod\n\n\n\ndef cal(k1,a1):\n    if k1+a1>=k:\n        return (k1+a1+r1)%mod\n    if (k1,a1) in dp:\n        return dp[(k1,a1)]\n    dp[(k1,a1)]=((cal(k1+a1,a1)*q)%mod+(cal(k1,a1+1)*p)%mod)%mod\n    return dp[(k1,a1)]\n\nprint(cal(0,1))\n\n", "import  sys\ninput=sys.stdin.readline\ndp={}\nmod=int(1000000007)\nsys.setrecursionlimit(100000)\ndef bigmod(n,p):\n    p=int(p)\n    if p==0:\n        return 1\n    x=bigmod(n,p/2)\n    x=(x*x)%mod\n    if p%2==1:\n        x=(x*n)%mod\n    return x\nk,pa,pb=list(map(int,input().split()))\nr=bigmod(pa+pb,mod-2)\nr1=bigmod(pb,mod-2)\nr1=(pa*r1)%mod\np=(pa*r)%mod\nq=(pb*r)%mod\n\n\n\ndef cal(k1,a1):\n    if k1+a1>=k:\n        return (k1+a1+r1)%mod\n    if (k1,a1) in dp:\n        return dp[(k1,a1)]\n    dp[(k1,a1)]=((cal(k1+a1,a1)*q)%mod+(cal(k1,a1+1)*p)%mod)%mod\n    return dp[(k1,a1)]\n\nprint(cal(0,1))\n\n", "import  sys\ninput=sys.stdin.readline\ndp={}\nmod=int(1000000007)\nsys.setrecursionlimit(100000)\ndef bigmod(n,p):\n    n,p=int(n),int(p)\n    if p==0:\n        return 1\n    x=bigmod(n,p/2)\n    x=(x*x)%mod\n    if p%2==1:\n        x=(x*n)%mod\n    return x\nk,pa,pb=list(map(int,input().split()))\nr=bigmod(pa+pb,mod-2)\nr1=bigmod(pb,mod-2)\nr1=(pa*r1)%mod\np=(pa*r)%mod\nq=(pb*r)%mod\n\n\n\ndef cal(k1,a1):\n    if k1+a1>=k:\n        return (k1+a1+r1)%mod\n    if (k1,a1) in dp:\n        return dp[(k1,a1)]\n    dp[(k1,a1)]=((cal(k1+a1,a1)*q)%mod+(cal(k1,a1+1)*p)%mod)%mod\n    return dp[(k1,a1)]\n\nprint(cal(0,1))\n\n"]
["\n# returns answer to the subproblem with interval range [start, end],\n# but with a total of \"extra\" additional stuff on the end\n# that must be deleted last.\nmemo = {}\ndef f(dat, rewards, start, end, extra):\n    curr = (start, end, extra)\n    if curr in memo:\n        return memo[curr]\n    \n    if start > end:\n        return 0\n    if start == end:\n        memo[curr] = rewards[dat[start] + extra]\n        return memo[curr]\n    \n    # test all possible \"cut points\".\n    # \"cut\" is the earliest index to die in the same deletion as \"end\".\n    out = 0\n    for cut in range(end, start-1, -2):\n        if cut == end:\n            # in this case, we're deleting the last interval right away.\n            out_curr = rewards[dat[cut] + extra]\n            out_curr += f(dat, rewards, start, cut-1, 0)\n        else:\n            # split into 2 pieces:\n            # 1) slots [start, cut] plus [end + extra]\n            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).\n            out_curr = f(dat, rewards, start, cut, extra + dat[end])\n            out_curr += f(dat, rewards, cut+1, end-1, 0)\n        \n        out = max(out, out_curr)\n    \n    memo[curr] = out\n    return memo[curr]\n\ndef solve(dat_str, rewards_orig):\n    # break into intervals.\n    dat = []\n    pos = 0\n    while pos < len(dat_str):\n        end = pos\n        while end < len(dat_str) and dat_str[pos] == dat_str[end]:\n            end += 1\n\n        dat.append(end - pos)\n        pos = end\n    \n    # compute the highest-value way to remove a run of size k.\n    # (google translated from C++ thinking)\n    rewards = [0, rewards_orig[0]]\n    for k in range(2, len(rewards_orig) + 1):\n        # print(\n        #     \"{}: {}\".format(\n        #         k,\n        #         [\n        #             rewards[k-j] + rewards_orig[j-1]\n        #             for j in range(1, k+1)\n        #         ]\n        #     )\n        # )\n        rewards.append(\n            max(\n                rewards[k-j] + rewards_orig[j-1]\n                for j in range(1, k+1)\n            )\n        )\n    \n    # print(\"dat: {}\".format(dat))\n    # print(\"rewards: {}\".format(rewards))\n    \n    return f(dat, rewards, 0, len(dat)-1, 0)\n\n# get the integer\nint_dummy = input()\n# get the string\ndat_str = input().strip()\n# get the array\nrewards_input = input().strip().split()\nrewards_ints = [int(x) for x in rewards_input]\n\n# print(dat_str)\n# print(rewards_ints)\n\nprint((\n    solve(\n        dat_str,\n        rewards_ints,\n    )\n))\n\n\n# dat_test = \"10101\"\n# rewards_test = [3, 10, 15, 15, 15]\n# print(solve(dat_test, rewards_test))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\ns = input().strip()\na = [0] + list(map(int, input().split()))\n\nMX = 105\ndp = [0] * (MX ** 3)\n\ndef f(i, j, k):\n    if i == j: return 0\n    idx = i * MX * MX + j * MX + k\n    if not dp[idx]:\n        dp[idx] = f(i + 1, j, 1) + a[k]\n        for m in range(i + 1, j):\n            if s[i] == s[m]:\n                dp[idx] = max(dp[idx], f(i + 1, m, 1) + f(m, j, k + 1))\n    return dp[idx]\n\nprint(f(0, n, 1))\n", "n = int(input())\ns = input()\nA = [0] + list(map(int, input().split()))\n\ndp = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    dp[i] = max(dp[j] + A[i - j] for j in range(0, i))\n\nres = {}\n\n\ndef score(s):\n    length = len(s)\n    if length == 0:\n        return 0\n    if s not in res.keys():\n        ans = 0\n        start = 0\n        i = 1\n        while i < length and s[i] == s[start]:\n            i += 1\n\n        ans = dp[i] + score(s[i:])\n\n        for j in range(i, length):\n            if s[j] == s[start]:\n                ans = max(ans, score(s[i:j]) + score(s[:i] + s[j:]))\n        res[s] = ans\n    return res[s]\n\n\nprint(score(s))", "from functools import lru_cache\nn = int(input())\ns = input()\nA = [0] + list(map(int, input().split()))\n\ndp = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    dp[i] = max(dp[j] + A[i - j] for j in range(0, i))\n\nres = {}\n\n@lru_cache(None)\ndef score(s):\n    length = len(s)\n    if length == 0:\n        return 0\n    ans = 0\n    start = 0\n    i = 1\n    while i < length and s[i] == s[start]:\n        i += 1\n\n    ans = dp[i] + score(s[i:])\n\n    for j in range(i, length):\n        if s[j] == s[start]:\n            ans = max(ans, score(s[i:j]) + score(s[:i] + s[j:]))\n    return ans\n\n\nprint(score(s))", "# 545 ms\nfrom functools import lru_cache\nn = int(input())\ns = input()\nA = [0] + list(map(int, input().split()))\n\ndp = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    dp[i] = max(dp[j] + A[i - j] for j in range(0, i))\n\n@lru_cache(None)\ndef score(s):\n    length = len(s)\n    if length == 0:\n        return 0\n\n    ans = 0\n    start = 0\n    i = 1\n    while i < length and s[i] == s[start]:\n        i += 1\n\n    ans = dp[i] + score(s[i:])\n\n    for j in range(i, length):\n        if s[j] == s[start]:\n            ans = max(ans, score(s[i:j]) + score(s[:i] + s[j:]))\n    return ans\n\n\nprint(score(s))", "from sys import stdin\nn=int(stdin.readline().strip())\ns1=stdin.readline().strip()\ns=list(map(int,stdin.readline().strip().split()))\ndp=[-1 for i in range(n+1)]\ndef sol1(x):\n    if dp[x]!=-1:\n        return dp[x]\n    if x==0:\n        return 0\n    ans=0\n    for i in range(x):\n        ans=max(ans,s[i]+sol1(x-i-1))\n    dp[x]=ans\nfor i in range(n):\n    sol1(i+1)\ndp[0]=0\ns2=[]\nx=1\nfor i in range(1,len(s)):\n    if s1[i]!=s1[i-1]:\n        s2.append(x)\n        x=1\n    else:\n        x+=1\ns2.append(x)\ndp1=[[[-1 for i in range(n+1)]for j in range(n+1)] for k in range(n+1)]\nn=len(s2)\ns=s2.copy()\ndef sol(l,r,k):\n    if l==r:\n        return dp[s[l]+k]\n    if l>r:\n        return 0\n    if dp1[l][r][k]!=-1:\n        return dp1[l][r][k]\n\n    ans=0\n    for i in range(l,r+1,2):\n        if i!=l:\n            ans=max(ans,sol(l+1,i-1,0)+sol(i,r,s[l]+k))\n        else:\n            ans=max(ans,sol(i+1,r,0)+dp[s[l]+k])\n            \n    dp1[l][r][k]=ans\n    return  ans\n\nprint(sol(0,len(s)-1,0))\n", "from sys import stdin\nn=int(stdin.readline().strip())\ns1=stdin.readline().strip()\ns=list(map(int,stdin.readline().strip().split()))\ndp=[-1 for i in range(n+1)]\ndef sol1(x):\n    if dp[x]!=-1:\n        return dp[x]\n    if x==0:\n        return 0\n    ans=0\n    for i in range(x):\n        ans=max(ans,s[i]+sol1(x-i-1))\n    dp[x]=ans\nfor i in range(n):\n    sol1(i+1)\ndp[0]=0\ns2=[]\nx=1\nfor i in range(1,len(s)):\n    if s1[i]!=s1[i-1]:\n        s2.append(x)\n        x=1\n    else:\n        x+=1\ns2.append(x)\ndp1=[[[-1 for i in range(n+1)]for j in range(n+1)] for k in range(n+1)]\nn=len(s2)\ns=s2.copy()\ndef sol(l,r,k):\n    if l==r:\n        return dp[s[l]+k]\n    if l>r:\n        return 0\n    if dp1[l][r][k]!=-1:\n        return dp1[l][r][k]\n\n    ans=0\n    for i in range(l,r+1,2):\n        if i!=l:\n            ans=max(ans,sol(l+1,i-1,0)+sol(i,r,s[l]+k))\n        else:\n            ans=max(ans,sol(i+1,r,0)+dp[s[l]+k])\n            \n    dp1[l][r][k]=ans\n    return  ans\n\nprint(sol(0,len(s)-1,0))\n", "n = int(input())\ns = input()\na = [int(x) for x in input().split()]\n\ndp = [[[False for i in range(101)] for j in range(101)] for k in range(101)]\n\ndef f(i, j, k):\n    if not dp[i][j][k]:\n        if i == j:\n            dp[i][j][k] = 0\n        else:\n            dp[i][j][k] = f(i+1, j, 0) + a[k]\n            for m in range(i+1, j):\n                if s[i] == s[m]:\n                    dp[i][j][k] = max(dp[i][j][k], f(i+1, m, 0) + f(m, j, k+1))\n    return dp[i][j][k]\n\nanswer = f(0, n, 0)\nprint(answer)", "from sys import stdin\nuu=0\nn=int(stdin.readline().strip())\ns1=stdin.readline().strip()\ns=list(map(int,stdin.readline().strip().split()))\ndp=[-1 for i in range(n+1)]\ndef sol1(x):\n    if dp[x]!=-1:\n        return dp[x]\n    if x==0:\n        return 0\n    ans=0\n    for i in range(x):\n        ans=max(ans,s[i]+sol1(x-i-1))\n    dp[x]=ans\nfor i in range(n):\n    sol1(i+1)\ndp[0]=0\ns2=[]\nx=1\nfor i in range(1,len(s)):\n    if s1[i]!=s1[i-1]:\n        s2.append(x)\n        x=1\n    else:\n        x+=1\ns2.append(x)\ndp1=[[[-1 for i in range(n+1)]for j in range(n+1)] for k in range(n+1)]\nn=len(s2)\ns=s2.copy()\ndef sol(l,r,k):\n    if l==r:\n        return dp[s[l]+k]\n    if l>r:\n        return 0\n    if dp1[l][r][k]!=-1:\n        return dp1[l][r][k]\n\n    ans=0\n    for i in range(l,r+1,2):\n        if i!=l:\n            ans=max(ans,sol(l+1,i-1,0)+sol(i,r,s[l]+k))\n        else:\n            ans=max(ans,sol(i+1,r,0)+dp[s[l]+k])\n            \n    dp1[l][r][k]=ans\n    return  ans\n\nprint(sol(0,len(s)-1,0))", "import sys\nfrom math import *\nfrom fractions import gcd\nreadints=lambda:list(map(int, input().strip('\\n').split()))\n\nn=int(input())\ns=input()\na=list(readints())\na=[0]+a #1-index\n\ncache={}\n\ndef solve(i,j,k):\n    if i>j: return 0\n    if i==j: return a[k]\n    if (i,j,k) in cache: return cache[(i,j,k)]\n\n    best=a[k]+solve(i+1,j,1)\n    for x in range(i+1,j+1):\n        if s[i]==s[x]:\n            best=max(best,solve(i+1,x-1,1)+solve(x,j,k+1))\n    #print(i,j,best)\n    cache[(i,j,k)]=best\n    return best\n\n\nans=solve(0,n-1,1)\nprint(ans)\n      \n", "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\nn = int(input())\ns = input()\na = list(map(int, input().split()))\nN = len(a)\ndp = [[[-1] * N for i in range(N)] for j in range(N)]\n\n\ndef calc(l, r, k):\n    if dp[l][r][k] != -1:\n        return dp[l][r][k]\n\n    if l == r:\n        return a[k]\n\n    tmp = 0\n    for i in range(l, r):\n        tmp = max(tmp, calc(l, i, 0) + calc(i + 1, r, k))\n        if s[i] == s[r]:\n            tmp = max(tmp, calc(i + 1, r - 1, 0) + calc(l, i, k + 1))\n\n    dp[l][r][k] = tmp\n    return tmp\n\n\nprint(calc(0, n - 1, 0))"]